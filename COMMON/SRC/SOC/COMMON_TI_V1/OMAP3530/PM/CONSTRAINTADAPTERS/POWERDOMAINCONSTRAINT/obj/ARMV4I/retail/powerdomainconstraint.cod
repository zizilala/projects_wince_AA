; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\OMAP3530\PM\CONSTRAINTADAPTERS\POWERDOMAINCONSTRAINT\powerdomainconstraint.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|?Lock@PowerDomainConstraint@@QAAXXZ|	; PowerDomainConstraint::Lock
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.h

  00000			 AREA	 |.pdata|, PDATA
|$T38341| DCD	|$LN5@Lock|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Lock@PowerDomainConstraint@@QAAXXZ| PROC ; PowerDomainConstraint::Lock

; 74   :     {

  00000		 |$LN5@Lock|
  00000		 |$M38338|

; 75   :     }

  00000	e12fff1e	 bx          lr
  00004		 |$M38339|

			 ENDP  ; |?Lock@PowerDomainConstraint@@QAAXXZ|, PowerDomainConstraint::Lock

	EXPORT	|?Unlock@PowerDomainConstraint@@QAAXXZ|	; PowerDomainConstraint::Unlock

  00000			 AREA	 |.pdata|, PDATA
|$T38348| DCD	|$LN5@Unlock|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Unlock@PowerDomainConstraint@@QAAXXZ| PROC ; PowerDomainConstraint::Unlock

; 79   :     {

  00000		 |$LN5@Unlock|
  00000		 |$M38345|

; 80   :     }

  00000	e12fff1e	 bx          lr
  00004		 |$M38346|

			 ENDP  ; |?Unlock@PowerDomainConstraint@@QAAXXZ|, PowerDomainConstraint::Unlock

	EXPORT	|?GetPowerDomainConstraint@PowerDomainConstraint@@QAAKXZ| ; PowerDomainConstraint::GetPowerDomainConstraint

  00000			 AREA	 |.pdata|, PDATA
|$T38358| DCD	|$LN5@GetPowerDo|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetPowerDomainConstraint@PowerDomainConstraint@@QAAKXZ| PROC ; PowerDomainConstraint::GetPowerDomainConstraint

; 84   :     {

  00000		 |$LN5@GetPowerDo|
  00000		 |$M38355|

; 85   :         return m_powerDomainCurrent;

  00000	e5900024	 ldr         r0, [r0, #0x24]

; 86   :     }

  00004	e12fff1e	 bx          lr
  00008		 |$M38356|

			 ENDP  ; |?GetPowerDomainConstraint@PowerDomainConstraint@@QAAKXZ|, PowerDomainConstraint::GetPowerDomainConstraint

	EXPORT	|?InitializePowerDomain@PowerDomainConstraint@@QAAHPBG@Z| ; PowerDomainConstraint::InitializePowerDomain
	EXPORT	|??_C@_1M@KBPAKIPB@?$AAF?$AAl?$AAo?$AAo?$AAr?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@DJAHLPIB@?$AAC?$AAe?$AAi?$AAl?$AAi?$AAn?$AAg?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|RegCloseKey|
	IMPORT	|RegQueryValueExW|
	IMPORT	|RegOpenKeyExW|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T38375| DCD	|$LN14@Initialize|
	DCD	0x40003e02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1M@KBPAKIPB@?$AAF?$AAl?$AAo?$AAo?$AAr?$AA?$AA@| DCB "F", 0x0, "l", 0x0
	DCB	"o", 0x0, "o", 0x0, "r", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@DJAHLPIB@?$AAC?$AAe?$AAi?$AAl?$AAi?$AAn?$AAg?$AA?$AA@| DCB "C", 0x0
	DCB	"e", 0x0, "i", 0x0, "l", 0x0, "i", 0x0, "n", 0x0, "g", 0x0
	DCB	0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InitializePowerDomain@PowerDomainConstraint@@QAAHPBG@Z| PROC ; PowerDomainConstraint::InitializePowerDomain

; 98   : {

  00000		 |$LN14@Initialize|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M38372|
  00008	e1a05000	 mov         r5, r0

; 99   :     DWORD state;
; 100  :     DWORD size;
; 101  :     BOOL rc = TRUE;
; 102  :     HKEY hKey = NULL;

  0000c	e3a02000	 mov         r2, #0

; 103  : 
; 104  :     // read registry to get initialization information  
; 105  :     if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szContext, 0, 0, &hKey) != ERROR_SUCCESS)

  00010	e28d3008	 add         r3, sp, #8
  00014	e58d2008	 str         r2, [sp, #8]
  00018	e58d3000	 str         r3, [sp]
  0001c	e3a03000	 mov         r3, #0
  00020	e3a02000	 mov         r2, #0
  00024	e3a0010a	 mov         r0, #0xA, 2
  00028	eb000000	 bl          RegOpenKeyExW
  0002c	e3500000	 cmp         r0, #0
  00030	1a00002a	 bne         |$cleanUp$37946|

; 106  :         {
; 107  :         goto cleanUp;
; 108  :         }
; 109  :     
; 110  :     // get ceiling value
; 111  :     size = sizeof(DWORD);
; 112  :     if (RegQueryValueEx(hKey, REGEDIT_POWERDOMAIN_CEILING, 0, 0, (BYTE*)&state, &size) == ERROR_SUCCESS)

  00034	e59f10b8	 ldr         r1, [pc, #0xB8]
  00038	e59d0008	 ldr         r0, [sp, #8]
  0003c	e3a06004	 mov         r6, #4
  00040	e28de00c	 add         lr, sp, #0xC
  00044	e28d4010	 add         r4, sp, #0x10
  00048	e3a03000	 mov         r3, #0
  0004c	e3a02000	 mov         r2, #0
  00050	e58d600c	 str         r6, [sp, #0xC]
  00054	e58de004	 str         lr, [sp, #4]
  00058	e58d4000	 str         r4, [sp]
  0005c	eb000000	 bl          RegQueryValueExW
  00060	e3500000	 cmp         r0, #0
  00064	1a000004	 bne         |$LN3@Initialize|

; 113  :         {
; 114  :         m_powerDomainCeiling = max(m_powerDomainCeiling, state);

  00068	e5953018	 ldr         r3, [r5, #0x18]
  0006c	e59d2010	 ldr         r2, [sp, #0x10]
  00070	e1530002	 cmp         r3, r2
  00074	91a03002	 movls       r3, r2
  00078	e5853018	 str         r3, [r5, #0x18]
  0007c		 |$LN3@Initialize|

; 115  :         }
; 116  :     
; 117  :     // get floor value
; 118  :     size = sizeof(DWORD);
; 119  :     if (RegQueryValueEx(hKey, REGEDIT_POWERDOMAIN_FLOOR, 0, 0, (BYTE*)&state, &size) == ERROR_SUCCESS)

  0007c	e59f106c	 ldr         r1, [pc, #0x6C]
  00080	e59d0008	 ldr         r0, [sp, #8]
  00084	e3a06004	 mov         r6, #4
  00088	e28de00c	 add         lr, sp, #0xC
  0008c	e28d4010	 add         r4, sp, #0x10
  00090	e3a03000	 mov         r3, #0
  00094	e3a02000	 mov         r2, #0
  00098	e58d600c	 str         r6, [sp, #0xC]
  0009c	e58de004	 str         lr, [sp, #4]
  000a0	e58d4000	 str         r4, [sp]
  000a4	eb000000	 bl          RegQueryValueExW
  000a8	e3500000	 cmp         r0, #0
  000ac	1a000004	 bne         |$LN2@Initialize|

; 120  :         {
; 121  :         m_powerDomainFloor = min(m_powerDomainFloor, state);

  000b0	e595301c	 ldr         r3, [r5, #0x1C]
  000b4	e59d2010	 ldr         r2, [sp, #0x10]
  000b8	e1530002	 cmp         r3, r2
  000bc	21a03002	 movcs       r3, r2
  000c0	e585301c	 str         r3, [r5, #0x1C]
  000c4		 |$LN2@Initialize|

; 122  :         }
; 123  : 
; 124  :     // make sure floor (ex. D2) is not less than the ceiling (ex. D3)
; 125  :     if (m_powerDomainFloor < m_powerDomainCeiling)

  000c4	e595201c	 ldr         r2, [r5, #0x1C]
  000c8	e5953018	 ldr         r3, [r5, #0x18]

; 126  :         {
; 127  :         m_powerDomainCeiling = m_powerDomainFloor;
; 128  :         }
; 129  :  
; 130  :     m_powerDomainCurrent = m_powerDomainFloor;
; 131  : 
; 132  :     RegCloseKey(hKey);

  000cc	e59d0008	 ldr         r0, [sp, #8]
  000d0	e5852024	 str         r2, [r5, #0x24]
  000d4	e1520003	 cmp         r2, r3
  000d8	35852018	 strcc       r2, [r5, #0x18]
  000dc	eb000000	 bl          RegCloseKey
  000e0		 |$cleanUp$37946|

; 133  : 
; 134  : cleanUp:
; 135  :     return rc;

  000e0	e3a00001	 mov         r0, #1

; 136  : } 

  000e4	e28dd014	 add         sp, sp, #0x14
  000e8	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000ec	e12fff1e	 bx          lr
  000f0		 |$LN15@Initialize|
  000f0		 |$LN16@Initialize|
  000f0	00000000	 DCD         |??_C@_1M@KBPAKIPB@?$AAF?$AAl?$AAo?$AAo?$AAr?$AA?$AA@|
  000f4		 |$LN17@Initialize|
  000f4	00000000	 DCD         |??_C@_1BA@DJAHLPIB@?$AAC?$AAe?$AAi?$AAl?$AAi?$AAn?$AAg?$AA?$AA@|
  000f8		 |$M38373|

			 ENDP  ; |?InitializePowerDomain@PowerDomainConstraint@@QAAHPBG@Z|, PowerDomainConstraint::InitializePowerDomain

	EXPORT	|?FlushDomainPowerState@MpuPowerDomainConstraint@@UAAHXZ| ; MpuPowerDomainConstraint::FlushDomainPowerState
	IMPORT	|KernelIoControl|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.h

  00000			 AREA	 |.pdata|, PDATA
|$T38395| DCD	|$LN16@FlushDomai|
	DCD	0x40002702
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FlushDomainPowerState@MpuPowerDomainConstraint@@UAAHXZ| PROC ; MpuPowerDomainConstraint::FlushDomainPowerState

; 259  : {

  00000		 |$LN16@FlushDomai|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M38392|

; 260  :     BOOL rc;
; 261  :     IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN domainPowerState;
; 262  : 
; 263  :     // initialize structure
; 264  :     domainPowerState.size = sizeof(IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN);
; 265  :     domainPowerState.powerDomain = POWERDOMAIN_MPU;
; 266  :     
; 267  :     switch (GetPowerDomainConstraint())

  00008	e5903024	 ldr         r3, [r0, #0x24]
  0000c	e3a02010	 mov         r2, #0x10
  00010	e3a01005	 mov         r1, #5
  00014	e3530001	 cmp         r3, #1
  00018	e58d2008	 str         r2, [sp, #8]
  0001c	e58d100c	 str         r1, [sp, #0xC]
  00020	9a00000d	 bls         |$LN4@FlushDomai|
  00024	e3530002	 cmp         r3, #2
  00028	0a000009	 beq         |$LN3@FlushDomai|
  0002c	e3530003	 cmp         r3, #3
  00030	0a000004	 beq         |$LN2@FlushDomai|
  00034	e3530004	 cmp         r3, #4
  00038	1a00000b	 bne         |$LN5@FlushDomai|

; 285  :             domainPowerState.logicState = LOGICRETSTATE_LOGICOFF_DOMAINRET;
; 286  :             break;
; 287  : 
; 288  :         case D4:
; 289  :             // set power domain to off mode
; 290  :             domainPowerState.powerState = POWERSTATE_OFF;

  0003c	e3a03000	 mov         r3, #0

; 291  :             domainPowerState.logicState = LOGICRETSTATE_LOGICOFF_DOMAINRET;

  00040	e3a02000	 mov         r2, #0

; 292  :             break;

  00044	ea000006	 b           |$LN11@FlushDomai|
  00048		 |$LN2@FlushDomai|

; 281  : 
; 282  :         case D3:
; 283  :             // set open switch retention
; 284  :             domainPowerState.powerState = POWERSTATE_RETENTION;

  00048	e3a03001	 mov         r3, #1

; 291  :             domainPowerState.logicState = LOGICRETSTATE_LOGICOFF_DOMAINRET;

  0004c	e3a02000	 mov         r2, #0

; 292  :             break;

  00050	ea000003	 b           |$LN11@FlushDomai|
  00054		 |$LN3@FlushDomai|

; 274  :             break;
; 275  :             
; 276  :         case D2:
; 277  :             // set close switch retention
; 278  :             domainPowerState.powerState = POWERSTATE_RETENTION;

  00054	e3a03001	 mov         r3, #1

; 279  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;
; 280  :             break;

  00058	ea000000	 b           |$LN12@FlushDomai|
  0005c		 |$LN4@FlushDomai|

; 268  :         {
; 269  :         case D0:
; 270  :         case D1:
; 271  :             // set power domain to on
; 272  :             domainPowerState.powerState = POWERSTATE_ON;

  0005c	e3a03003	 mov         r3, #3
  00060		 |$LN12@FlushDomai|

; 273  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;

  00060	e3a02004	 mov         r2, #4
  00064		 |$LN11@FlushDomai|
  00064	e58d2014	 str         r2, [sp, #0x14]
  00068	e58d3010	 str         r3, [sp, #0x10]
  0006c		 |$LN5@FlushDomai|

; 293  :         }
; 294  :     
; 295  :     // send ioctl
; 296  :     rc = KernelIoControl(IOCTL_PRCM_DOMAIN_SET_POWERSTATE, &domainPowerState, 
; 297  :             sizeof(IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN), 0, 0, 0
; 298  :             );

  0006c	e59f0024	 ldr         r0, [pc, #0x24]
  00070	e3a0e000	 mov         lr, #0
  00074	e3a03000	 mov         r3, #0
  00078	e3a02010	 mov         r2, #0x10
  0007c	e28d1008	 add         r1, sp, #8
  00080	e58de004	 str         lr, [sp, #4]
  00084	e58de000	 str         lr, [sp]
  00088	eb000000	 bl          KernelIoControl

; 299  : 
; 300  :     return rc;
; 301  : }

  0008c	e28dd018	 add         sp, sp, #0x18
  00090	e49de004	 ldr         lr, [sp], #4
  00094	e12fff1e	 bx          lr
  00098		 |$LN17@FlushDomai|
  00098		 |$LN18@FlushDomai|
  00098	01f50fcc	 DCD         0x1f50fcc
  0009c		 |$M38393|

			 ENDP  ; |?FlushDomainPowerState@MpuPowerDomainConstraint@@UAAHXZ|, MpuPowerDomainConstraint::FlushDomainPowerState

	EXPORT	|?FlushDomainPowerState@IvaPowerDomainConstraint@@UAAHXZ| ; IvaPowerDomainConstraint::FlushDomainPowerState
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.h

  00000			 AREA	 |.pdata|, PDATA
|$T38412| DCD	|$LN14@FlushDomai@2|
	DCD	0x40002302
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FlushDomainPowerState@IvaPowerDomainConstraint@@UAAHXZ| PROC ; IvaPowerDomainConstraint::FlushDomainPowerState

; 345  : {

  00000		 |$LN14@FlushDomai@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M38409|

; 346  :     BOOL rc;
; 347  :     IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN domainPowerState;
; 348  : 
; 349  :     // initialize structure
; 350  :     domainPowerState.size = sizeof(IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN);
; 351  :     domainPowerState.powerDomain = POWERDOMAIN_IVA2;
; 352  :     
; 353  :     switch (GetPowerDomainConstraint())

  00008	e5903024	 ldr         r3, [r0, #0x24]
  0000c	e3a02010	 mov         r2, #0x10
  00010	e3a01008	 mov         r1, #8
  00014	e3530001	 cmp         r3, #1
  00018	e58d2008	 str         r2, [sp, #8]
  0001c	e58d100c	 str         r1, [sp, #0xC]
  00020	9a000009	 bls         |$LN4@FlushDomai@2|
  00024	e3530002	 cmp         r3, #2
  00028	0a000005	 beq         |$LN2@FlushDomai@2|
  0002c	e3530003	 cmp         r3, #3
  00030	0a000003	 beq         |$LN2@FlushDomai@2|
  00034	e3530004	 cmp         r3, #4
  00038	1a000007	 bne         |$LN5@FlushDomai@2|

; 373  : 
; 374  :         case D4:
; 375  :             // set power domain to off mode
; 376  :             domainPowerState.powerState = POWERSTATE_OFF;

  0003c	e3a03000	 mov         r3, #0

; 377  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;
; 378  :             break;

  00040	ea000002	 b           |$LN11@FlushDomai@2|
  00044		 |$LN2@FlushDomai@2|

; 360  :             break;
; 361  :             
; 362  :         case D2:
; 363  :             // set close switch retention
; 364  :             domainPowerState.powerState = POWERSTATE_RETENTION;
; 365  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;
; 366  :             break;
; 367  : 
; 368  :         case D3:
; 369  :             // set open switch retention
; 370  :             domainPowerState.powerState = POWERSTATE_RETENTION;

  00044	e3a03001	 mov         r3, #1

; 371  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;
; 372  :             break;

  00048	ea000000	 b           |$LN11@FlushDomai@2|
  0004c		 |$LN4@FlushDomai@2|

; 354  :         {
; 355  :         case D0:
; 356  :         case D1:
; 357  :             // set power domain to on
; 358  :             domainPowerState.powerState = POWERSTATE_ON;

  0004c	e3a03003	 mov         r3, #3
  00050		 |$LN11@FlushDomai@2|

; 359  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;

  00050	e3a02004	 mov         r2, #4
  00054	e58d2014	 str         r2, [sp, #0x14]
  00058	e58d3010	 str         r3, [sp, #0x10]
  0005c		 |$LN5@FlushDomai@2|

; 379  :         }
; 380  :     
; 381  :     // send ioctl
; 382  :     rc = KernelIoControl(IOCTL_PRCM_DOMAIN_SET_POWERSTATE, &domainPowerState, 
; 383  :             sizeof(IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN), 0, 0, 0
; 384  :             );

  0005c	e59f0024	 ldr         r0, [pc, #0x24]
  00060	e3a0e000	 mov         lr, #0
  00064	e3a03000	 mov         r3, #0
  00068	e3a02010	 mov         r2, #0x10
  0006c	e28d1008	 add         r1, sp, #8
  00070	e58de004	 str         lr, [sp, #4]
  00074	e58de000	 str         lr, [sp]
  00078	eb000000	 bl          KernelIoControl

; 385  : 
; 386  :     return rc;
; 387  : }

  0007c	e28dd018	 add         sp, sp, #0x18
  00080	e49de004	 ldr         lr, [sp], #4
  00084	e12fff1e	 bx          lr
  00088		 |$LN15@FlushDomai@2|
  00088		 |$LN16@FlushDomai@2|
  00088	01f50fcc	 DCD         0x1f50fcc
  0008c		 |$M38410|

			 ENDP  ; |?FlushDomainPowerState@IvaPowerDomainConstraint@@UAAHXZ|, IvaPowerDomainConstraint::FlushDomainPowerState

	EXPORT	|?FlushDomainPowerState@CorePowerDomainConstraint@@UAAHXZ| ; CorePowerDomainConstraint::FlushDomainPowerState
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.h

  00000			 AREA	 |.pdata|, PDATA
|$T38431| DCD	|$LN16@FlushDomai@3|
	DCD	0x40002702
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FlushDomainPowerState@CorePowerDomainConstraint@@UAAHXZ| PROC ; CorePowerDomainConstraint::FlushDomainPowerState

; 431  : {   

  00000		 |$LN16@FlushDomai@3|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M38428|

; 432  :     BOOL rc;
; 433  :     IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN domainPowerState;
; 434  : 
; 435  :     // initialize structure
; 436  :     domainPowerState.size = sizeof(IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN);
; 437  :     domainPowerState.powerDomain = POWERDOMAIN_CORE;
; 438  :     
; 439  :     switch (GetPowerDomainConstraint())

  00008	e5903024	 ldr         r3, [r0, #0x24]
  0000c	e3a02010	 mov         r2, #0x10
  00010	e3a01001	 mov         r1, #1
  00014	e3530001	 cmp         r3, #1
  00018	e58d2008	 str         r2, [sp, #8]
  0001c	e58d100c	 str         r1, [sp, #0xC]
  00020	9a00000d	 bls         |$LN4@FlushDomai@3|
  00024	e3530002	 cmp         r3, #2
  00028	0a000009	 beq         |$LN3@FlushDomai@3|
  0002c	e3530003	 cmp         r3, #3
  00030	0a000004	 beq         |$LN2@FlushDomai@3|
  00034	e3530004	 cmp         r3, #4
  00038	1a00000b	 bne         |$LN5@FlushDomai@3|

; 457  :             domainPowerState.logicState = LOGICRETSTATE_LOGICOFF_DOMAINRET;
; 458  :             break;
; 459  : 
; 460  :         case D4:
; 461  :             // set power domain to off mode
; 462  :             domainPowerState.powerState = POWERSTATE_OFF;

  0003c	e3a03000	 mov         r3, #0

; 463  :             domainPowerState.logicState = LOGICRETSTATE_LOGICOFF_DOMAINRET;

  00040	e3a02000	 mov         r2, #0

; 464  :             break;

  00044	ea000006	 b           |$LN11@FlushDomai@3|
  00048		 |$LN2@FlushDomai@3|

; 453  : 
; 454  :         case D3:
; 455  :             // set open switch retention
; 456  :             domainPowerState.powerState = POWERSTATE_RETENTION;

  00048	e3a03001	 mov         r3, #1

; 463  :             domainPowerState.logicState = LOGICRETSTATE_LOGICOFF_DOMAINRET;

  0004c	e3a02000	 mov         r2, #0

; 464  :             break;

  00050	ea000003	 b           |$LN11@FlushDomai@3|
  00054		 |$LN3@FlushDomai@3|

; 446  :             break;
; 447  :             
; 448  :         case D2:
; 449  :             // set close switch retention
; 450  :             domainPowerState.powerState = POWERSTATE_RETENTION;

  00054	e3a03001	 mov         r3, #1

; 451  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;
; 452  :             break;

  00058	ea000000	 b           |$LN12@FlushDomai@3|
  0005c		 |$LN4@FlushDomai@3|

; 440  :         {
; 441  :         case D0:
; 442  :         case D1:
; 443  :             // set power domain to on
; 444  :             domainPowerState.powerState = POWERSTATE_ON;

  0005c	e3a03003	 mov         r3, #3
  00060		 |$LN12@FlushDomai@3|

; 445  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;

  00060	e3a02004	 mov         r2, #4
  00064		 |$LN11@FlushDomai@3|
  00064	e58d2014	 str         r2, [sp, #0x14]
  00068	e58d3010	 str         r3, [sp, #0x10]
  0006c		 |$LN5@FlushDomai@3|

; 465  :         }
; 466  :     
; 467  :     // send ioctl
; 468  :     rc = KernelIoControl(IOCTL_PRCM_DOMAIN_SET_POWERSTATE, &domainPowerState, 
; 469  :             sizeof(IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN), 0, 0, 0
; 470  :             );

  0006c	e59f0024	 ldr         r0, [pc, #0x24]
  00070	e3a0e000	 mov         lr, #0
  00074	e3a03000	 mov         r3, #0
  00078	e3a02010	 mov         r2, #0x10
  0007c	e28d1008	 add         r1, sp, #8
  00080	e58de004	 str         lr, [sp, #4]
  00084	e58de000	 str         lr, [sp]
  00088	eb000000	 bl          KernelIoControl

; 471  : 
; 472  :     return rc;
; 473  : }

  0008c	e28dd018	 add         sp, sp, #0x18
  00090	e49de004	 ldr         lr, [sp], #4
  00094	e12fff1e	 bx          lr
  00098		 |$LN17@FlushDomai@3|
  00098		 |$LN18@FlushDomai@3|
  00098	01f50fcc	 DCD         0x1f50fcc
  0009c		 |$M38429|

			 ENDP  ; |?FlushDomainPowerState@CorePowerDomainConstraint@@UAAHXZ|, CorePowerDomainConstraint::FlushDomainPowerState

	EXPORT	|?FlushDomainPowerState@PeripheralPowerDomainConstraint@@UAAHXZ| ; PeripheralPowerDomainConstraint::FlushDomainPowerState
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.h

  00000			 AREA	 |.pdata|, PDATA
|$T38448| DCD	|$LN13@FlushDomai@4|
	DCD	0x40002102
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FlushDomainPowerState@PeripheralPowerDomainConstraint@@UAAHXZ| PROC ; PeripheralPowerDomainConstraint::FlushDomainPowerState

; 517  : {

  00000		 |$LN13@FlushDomai@4|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M38445|

; 518  :     BOOL rc;
; 519  :     IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN domainPowerState;
; 520  : 
; 521  :     // initialize structure
; 522  :     domainPowerState.size = sizeof(IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN);
; 523  :     domainPowerState.powerDomain = POWERDOMAIN_PERIPHERAL;
; 524  :     
; 525  :     switch (GetPowerDomainConstraint())

  00008	e5903024	 ldr         r3, [r0, #0x24]
  0000c	e3a02010	 mov         r2, #0x10
  00010	e3a01002	 mov         r1, #2
  00014	e3530001	 cmp         r3, #1
  00018	e58d2008	 str         r2, [sp, #8]
  0001c	e58d100c	 str         r1, [sp, #0xC]
  00020	9a000007	 bls         |$LN3@FlushDomai@4|
  00024	e3530003	 cmp         r3, #3
  00028	9a000003	 bls         |$LN2@FlushDomai@4|
  0002c	e3530004	 cmp         r3, #4
  00030	1a000007	 bne         |$LN4@FlushDomai@4|

; 540  : 
; 541  :         case D4:
; 542  :             // set power domain to off mode
; 543  :             domainPowerState.powerState = POWERSTATE_OFF;

  00034	e3a03000	 mov         r3, #0

; 544  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;
; 545  :             break;

  00038	ea000002	 b           |$LN10@FlushDomai@4|
  0003c		 |$LN2@FlushDomai@4|

; 532  :             break;
; 533  :             
; 534  :         case D2:
; 535  :         case D3:
; 536  :             // set close switch retention
; 537  :             domainPowerState.powerState = POWERSTATE_RETENTION;

  0003c	e3a03001	 mov         r3, #1

; 538  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;
; 539  :             break;

  00040	ea000000	 b           |$LN10@FlushDomai@4|
  00044		 |$LN3@FlushDomai@4|

; 526  :         {
; 527  :         case D0:
; 528  :         case D1:
; 529  :             // set power domain to on
; 530  :             domainPowerState.powerState = POWERSTATE_ON;

  00044	e3a03003	 mov         r3, #3
  00048		 |$LN10@FlushDomai@4|

; 531  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;

  00048	e3a02004	 mov         r2, #4
  0004c	e58d2014	 str         r2, [sp, #0x14]
  00050	e58d3010	 str         r3, [sp, #0x10]
  00054		 |$LN4@FlushDomai@4|

; 546  :         }
; 547  :     
; 548  :     // send ioctl
; 549  :     rc = KernelIoControl(IOCTL_PRCM_DOMAIN_SET_POWERSTATE, &domainPowerState, 
; 550  :             sizeof(IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN), 0, 0, 0
; 551  :             );

  00054	e59f0024	 ldr         r0, [pc, #0x24]
  00058	e3a0e000	 mov         lr, #0
  0005c	e3a03000	 mov         r3, #0
  00060	e3a02010	 mov         r2, #0x10
  00064	e28d1008	 add         r1, sp, #8
  00068	e58de004	 str         lr, [sp, #4]
  0006c	e58de000	 str         lr, [sp]
  00070	eb000000	 bl          KernelIoControl

; 552  : 
; 553  :     return rc;
; 554  : }

  00074	e28dd018	 add         sp, sp, #0x18
  00078	e49de004	 ldr         lr, [sp], #4
  0007c	e12fff1e	 bx          lr
  00080		 |$LN14@FlushDomai@4|
  00080		 |$LN15@FlushDomai@4|
  00080	01f50fcc	 DCD         0x1f50fcc
  00084		 |$M38446|

			 ENDP  ; |?FlushDomainPowerState@PeripheralPowerDomainConstraint@@UAAHXZ|, PeripheralPowerDomainConstraint::FlushDomainPowerState

	EXPORT	|?FlushDomainPowerState@DssPowerDomainConstraint@@UAAHXZ| ; DssPowerDomainConstraint::FlushDomainPowerState
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.h

  00000			 AREA	 |.pdata|, PDATA
|$T38465| DCD	|$LN13@FlushDomai@5|
	DCD	0x40002102
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FlushDomainPowerState@DssPowerDomainConstraint@@UAAHXZ| PROC ; DssPowerDomainConstraint::FlushDomainPowerState

; 598  : {

  00000		 |$LN13@FlushDomai@5|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M38462|

; 599  :     BOOL rc;
; 600  :     IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN domainPowerState;
; 601  : 
; 602  :     // initialize structure
; 603  :     domainPowerState.size = sizeof(IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN);
; 604  :     domainPowerState.powerDomain = POWERDOMAIN_DSS;
; 605  :     
; 606  :     switch (GetPowerDomainConstraint())

  00008	e5903024	 ldr         r3, [r0, #0x24]
  0000c	e3a02010	 mov         r2, #0x10
  00010	e3a01006	 mov         r1, #6
  00014	e3530001	 cmp         r3, #1
  00018	e58d2008	 str         r2, [sp, #8]
  0001c	e58d100c	 str         r1, [sp, #0xC]
  00020	9a000007	 bls         |$LN3@FlushDomai@5|
  00024	e3530003	 cmp         r3, #3
  00028	9a000003	 bls         |$LN2@FlushDomai@5|
  0002c	e3530004	 cmp         r3, #4
  00030	1a000007	 bne         |$LN4@FlushDomai@5|

; 621  : 
; 622  :         case D4:
; 623  :             // set power domain to off mode
; 624  :             domainPowerState.powerState = POWERSTATE_OFF;

  00034	e3a03000	 mov         r3, #0

; 625  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;
; 626  :             break;

  00038	ea000002	 b           |$LN10@FlushDomai@5|
  0003c		 |$LN2@FlushDomai@5|

; 613  :             break;
; 614  :             
; 615  :         case D2:
; 616  :         case D3:
; 617  :             // set close switch retention
; 618  :             domainPowerState.powerState = POWERSTATE_RETENTION;

  0003c	e3a03001	 mov         r3, #1

; 619  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;
; 620  :             break;

  00040	ea000000	 b           |$LN10@FlushDomai@5|
  00044		 |$LN3@FlushDomai@5|

; 607  :         {
; 608  :         case D0:
; 609  :         case D1:
; 610  :             // set power domain to on
; 611  :             domainPowerState.powerState = POWERSTATE_ON;

  00044	e3a03003	 mov         r3, #3
  00048		 |$LN10@FlushDomai@5|

; 612  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;

  00048	e3a02004	 mov         r2, #4
  0004c	e58d2014	 str         r2, [sp, #0x14]
  00050	e58d3010	 str         r3, [sp, #0x10]
  00054		 |$LN4@FlushDomai@5|

; 627  :         }
; 628  :     
; 629  :     // send ioctl
; 630  :     rc = KernelIoControl(IOCTL_PRCM_DOMAIN_SET_POWERSTATE, &domainPowerState, 
; 631  :             sizeof(IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN), 0, 0, 0
; 632  :             );

  00054	e59f0024	 ldr         r0, [pc, #0x24]
  00058	e3a0e000	 mov         lr, #0
  0005c	e3a03000	 mov         r3, #0
  00060	e3a02010	 mov         r2, #0x10
  00064	e28d1008	 add         r1, sp, #8
  00068	e58de004	 str         lr, [sp, #4]
  0006c	e58de000	 str         lr, [sp]
  00070	eb000000	 bl          KernelIoControl

; 633  : 
; 634  :     return rc;
; 635  : }

  00074	e28dd018	 add         sp, sp, #0x18
  00078	e49de004	 ldr         lr, [sp], #4
  0007c	e12fff1e	 bx          lr
  00080		 |$LN14@FlushDomai@5|
  00080		 |$LN15@FlushDomai@5|
  00080	01f50fcc	 DCD         0x1f50fcc
  00084		 |$M38463|

			 ENDP  ; |?FlushDomainPowerState@DssPowerDomainConstraint@@UAAHXZ|, DssPowerDomainConstraint::FlushDomainPowerState

	EXPORT	|?FlushDomainPowerState@SgxPowerDomainConstraint@@UAAHXZ| ; SgxPowerDomainConstraint::FlushDomainPowerState
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.h

  00000			 AREA	 |.pdata|, PDATA
|$T38482| DCD	|$LN13@FlushDomai@6|
	DCD	0x40001f02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FlushDomainPowerState@SgxPowerDomainConstraint@@UAAHXZ| PROC ; SgxPowerDomainConstraint::FlushDomainPowerState

; 679  : {

  00000		 |$LN13@FlushDomai@6|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M38479|

; 680  :     BOOL rc;
; 681  :     IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN domainPowerState;
; 682  : 
; 683  :     // initialize structure
; 684  :     domainPowerState.size = sizeof(IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN);
; 685  :     domainPowerState.powerDomain = POWERDOMAIN_SGX;
; 686  :     
; 687  :     switch (GetPowerDomainConstraint())

  00008	e5903024	 ldr         r3, [r0, #0x24]
  0000c	e3a02010	 mov         r2, #0x10
  00010	e3a0100a	 mov         r1, #0xA
  00014	e3530001	 cmp         r3, #1
  00018	e58d2008	 str         r2, [sp, #8]
  0001c	e58d100c	 str         r1, [sp, #0xC]
  00020	9a000005	 bls         |$LN3@FlushDomai@6|
  00024	e3530003	 cmp         r3, #3
  00028	9a000003	 bls         |$LN3@FlushDomai@6|
  0002c	e3530004	 cmp         r3, #4
  00030	1a000005	 bne         |$LN4@FlushDomai@6|

; 694  :             break;
; 695  :             
; 696  :         case D2:
; 697  :         case D3:
; 698  :             // currently SGX doesn't support retention
; 699  :             domainPowerState.powerState = POWERSTATE_ON;
; 700  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;
; 701  :             break;
; 702  : 
; 703  :         case D4:
; 704  :             // set power domain to off mode
; 705  :             domainPowerState.powerState = POWERSTATE_OFF;

  00034	e3a03000	 mov         r3, #0

; 706  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;
; 707  :             break;

  00038	ea000000	 b           |$LN10@FlushDomai@6|
  0003c		 |$LN3@FlushDomai@6|

; 688  :         {
; 689  :         case D0:
; 690  :         case D1:
; 691  :             // set power domain to on
; 692  :             domainPowerState.powerState = POWERSTATE_ON;

  0003c	e3a03003	 mov         r3, #3
  00040		 |$LN10@FlushDomai@6|

; 693  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;

  00040	e3a02004	 mov         r2, #4
  00044	e58d2014	 str         r2, [sp, #0x14]
  00048	e58d3010	 str         r3, [sp, #0x10]
  0004c		 |$LN4@FlushDomai@6|

; 708  :         }
; 709  :     
; 710  :     // send ioctl
; 711  :     rc = KernelIoControl(IOCTL_PRCM_DOMAIN_SET_POWERSTATE, &domainPowerState, 
; 712  :             sizeof(IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN), 0, 0, 0
; 713  :             );

  0004c	e59f0024	 ldr         r0, [pc, #0x24]
  00050	e3a0e000	 mov         lr, #0
  00054	e3a03000	 mov         r3, #0
  00058	e3a02010	 mov         r2, #0x10
  0005c	e28d1008	 add         r1, sp, #8
  00060	e58de004	 str         lr, [sp, #4]
  00064	e58de000	 str         lr, [sp]
  00068	eb000000	 bl          KernelIoControl

; 714  : 
; 715  :     return rc;
; 716  : }

  0006c	e28dd018	 add         sp, sp, #0x18
  00070	e49de004	 ldr         lr, [sp], #4
  00074	e12fff1e	 bx          lr
  00078		 |$LN14@FlushDomai@6|
  00078		 |$LN15@FlushDomai@6|
  00078	01f50fcc	 DCD         0x1f50fcc
  0007c		 |$M38480|

			 ENDP  ; |?FlushDomainPowerState@SgxPowerDomainConstraint@@UAAHXZ|, SgxPowerDomainConstraint::FlushDomainPowerState

	EXPORT	|?FlushDomainPowerState@CameraPowerDomainConstraint@@UAAHXZ| ; CameraPowerDomainConstraint::FlushDomainPowerState
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.h

  00000			 AREA	 |.pdata|, PDATA
|$T38499| DCD	|$LN13@FlushDomai@7|
	DCD	0x40002102
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FlushDomainPowerState@CameraPowerDomainConstraint@@UAAHXZ| PROC ; CameraPowerDomainConstraint::FlushDomainPowerState

; 760  : {

  00000		 |$LN13@FlushDomai@7|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M38496|

; 761  :     BOOL rc;
; 762  :     IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN domainPowerState;
; 763  : 
; 764  :     // initialize structure
; 765  :     domainPowerState.size = sizeof(IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN);
; 766  :     domainPowerState.powerDomain = POWERDOMAIN_CAMERA;
; 767  :     
; 768  :     switch (GetPowerDomainConstraint())

  00008	e5903024	 ldr         r3, [r0, #0x24]
  0000c	e3a02010	 mov         r2, #0x10
  00010	e3a01009	 mov         r1, #9
  00014	e3530001	 cmp         r3, #1
  00018	e58d2008	 str         r2, [sp, #8]
  0001c	e58d100c	 str         r1, [sp, #0xC]
  00020	9a000007	 bls         |$LN3@FlushDomai@7|
  00024	e3530003	 cmp         r3, #3
  00028	9a000003	 bls         |$LN2@FlushDomai@7|
  0002c	e3530004	 cmp         r3, #4
  00030	1a000007	 bne         |$LN4@FlushDomai@7|

; 783  : 
; 784  :         case D4:
; 785  :             // set power domain to off mode
; 786  :             domainPowerState.powerState = POWERSTATE_OFF;

  00034	e3a03000	 mov         r3, #0

; 787  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;
; 788  :             break;

  00038	ea000002	 b           |$LN10@FlushDomai@7|
  0003c		 |$LN2@FlushDomai@7|

; 775  :             break;
; 776  :             
; 777  :         case D2:
; 778  :         case D3:
; 779  :             // camera only supports CSWR
; 780  :             domainPowerState.powerState = POWERSTATE_RETENTION;

  0003c	e3a03001	 mov         r3, #1

; 781  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;
; 782  :             break;

  00040	ea000000	 b           |$LN10@FlushDomai@7|
  00044		 |$LN3@FlushDomai@7|

; 769  :         {
; 770  :         case D0:
; 771  :         case D1:
; 772  :             // set power domain to on
; 773  :             domainPowerState.powerState = POWERSTATE_ON;

  00044	e3a03003	 mov         r3, #3
  00048		 |$LN10@FlushDomai@7|

; 774  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;

  00048	e3a02004	 mov         r2, #4
  0004c	e58d2014	 str         r2, [sp, #0x14]
  00050	e58d3010	 str         r3, [sp, #0x10]
  00054		 |$LN4@FlushDomai@7|

; 789  :         }
; 790  :     
; 791  :     // send ioctl
; 792  :     rc = KernelIoControl(IOCTL_PRCM_DOMAIN_SET_POWERSTATE, &domainPowerState, 
; 793  :             sizeof(IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN), 0, 0, 0
; 794  :             );

  00054	e59f0024	 ldr         r0, [pc, #0x24]
  00058	e3a0e000	 mov         lr, #0
  0005c	e3a03000	 mov         r3, #0
  00060	e3a02010	 mov         r2, #0x10
  00064	e28d1008	 add         r1, sp, #8
  00068	e58de004	 str         lr, [sp, #4]
  0006c	e58de000	 str         lr, [sp]
  00070	eb000000	 bl          KernelIoControl

; 795  : 
; 796  :     return rc;
; 797  : }

  00074	e28dd018	 add         sp, sp, #0x18
  00078	e49de004	 ldr         lr, [sp], #4
  0007c	e12fff1e	 bx          lr
  00080		 |$LN14@FlushDomai@7|
  00080		 |$LN15@FlushDomai@7|
  00080	01f50fcc	 DCD         0x1f50fcc
  00084		 |$M38497|

			 ENDP  ; |?FlushDomainPowerState@CameraPowerDomainConstraint@@UAAHXZ|, CameraPowerDomainConstraint::FlushDomainPowerState

	EXPORT	|?FlushDomainPowerState@UsbHostPowerDomainConstraint@@UAAHXZ| ; UsbHostPowerDomainConstraint::FlushDomainPowerState
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.h

  00000			 AREA	 |.pdata|, PDATA
|$T38516| DCD	|$LN13@FlushDomai@8|
	DCD	0x40002102
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FlushDomainPowerState@UsbHostPowerDomainConstraint@@UAAHXZ| PROC ; UsbHostPowerDomainConstraint::FlushDomainPowerState

; 841  : {

  00000		 |$LN13@FlushDomai@8|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M38513|

; 842  :     BOOL rc;
; 843  :     IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN domainPowerState;
; 844  : 
; 845  :     // initialize structure
; 846  :     domainPowerState.size = sizeof(IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN);
; 847  :     domainPowerState.powerDomain = POWERDOMAIN_USBHOST;
; 848  :     
; 849  :     switch (GetPowerDomainConstraint())

  00008	e5903024	 ldr         r3, [r0, #0x24]
  0000c	e3a02010	 mov         r2, #0x10
  00010	e3a01003	 mov         r1, #3
  00014	e3530001	 cmp         r3, #1
  00018	e58d2008	 str         r2, [sp, #8]
  0001c	e58d100c	 str         r1, [sp, #0xC]
  00020	9a000007	 bls         |$LN3@FlushDomai@8|
  00024	e3530003	 cmp         r3, #3
  00028	9a000003	 bls         |$LN2@FlushDomai@8|
  0002c	e3530004	 cmp         r3, #4
  00030	1a000007	 bne         |$LN4@FlushDomai@8|

; 864  : 
; 865  :         case D4:
; 866  :             // set power domain to off mode
; 867  :             domainPowerState.powerState = POWERSTATE_OFF;

  00034	e3a03000	 mov         r3, #0

; 868  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;
; 869  :             break;

  00038	ea000002	 b           |$LN10@FlushDomai@8|
  0003c		 |$LN2@FlushDomai@8|

; 856  :             break;
; 857  :             
; 858  :         case D2:
; 859  :         case D3:
; 860  :             // usbhost only supports CSWR
; 861  :             domainPowerState.powerState = POWERSTATE_RETENTION;

  0003c	e3a03001	 mov         r3, #1

; 862  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;
; 863  :             break;

  00040	ea000000	 b           |$LN10@FlushDomai@8|
  00044		 |$LN3@FlushDomai@8|

; 850  :         {
; 851  :         case D0:
; 852  :         case D1:
; 853  :             // set power domain to on
; 854  :             domainPowerState.powerState = POWERSTATE_ON;

  00044	e3a03003	 mov         r3, #3
  00048		 |$LN10@FlushDomai@8|

; 855  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;

  00048	e3a02004	 mov         r2, #4
  0004c	e58d2014	 str         r2, [sp, #0x14]
  00050	e58d3010	 str         r3, [sp, #0x10]
  00054		 |$LN4@FlushDomai@8|

; 870  :         }
; 871  :     
; 872  :     // send ioctl
; 873  :     rc = KernelIoControl(IOCTL_PRCM_DOMAIN_SET_POWERSTATE, &domainPowerState, 
; 874  :             sizeof(IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN), 0, 0, 0
; 875  :             );

  00054	e59f0024	 ldr         r0, [pc, #0x24]
  00058	e3a0e000	 mov         lr, #0
  0005c	e3a03000	 mov         r3, #0
  00060	e3a02010	 mov         r2, #0x10
  00064	e28d1008	 add         r1, sp, #8
  00068	e58de004	 str         lr, [sp, #4]
  0006c	e58de000	 str         lr, [sp]
  00070	eb000000	 bl          KernelIoControl

; 876  : 
; 877  :     return rc;
; 878  : }

  00074	e28dd018	 add         sp, sp, #0x18
  00078	e49de004	 ldr         lr, [sp], #4
  0007c	e12fff1e	 bx          lr
  00080		 |$LN14@FlushDomai@8|
  00080		 |$LN15@FlushDomai@8|
  00080	01f50fcc	 DCD         0x1f50fcc
  00084		 |$M38514|

			 ENDP  ; |?FlushDomainPowerState@UsbHostPowerDomainConstraint@@UAAHXZ|, UsbHostPowerDomainConstraint::FlushDomainPowerState

	EXPORT	|?FlushDomainPowerState@NeonPowerDomainConstraint@@UAAHXZ| ; NeonPowerDomainConstraint::FlushDomainPowerState
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.h

  00000			 AREA	 |.pdata|, PDATA
|$T38533| DCD	|$LN13@FlushDomai@9|
	DCD	0x40002102
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FlushDomainPowerState@NeonPowerDomainConstraint@@UAAHXZ| PROC ; NeonPowerDomainConstraint::FlushDomainPowerState

; 922  : {

  00000		 |$LN13@FlushDomai@9|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M38530|

; 923  :     BOOL rc;
; 924  :     IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN domainPowerState;
; 925  : 
; 926  :     // initialize structure
; 927  :     domainPowerState.size = sizeof(IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN);
; 928  :     domainPowerState.powerDomain = POWERDOMAIN_NEON;
; 929  :     
; 930  :     switch (GetPowerDomainConstraint())

  00008	e5903024	 ldr         r3, [r0, #0x24]
  0000c	e3a02010	 mov         r2, #0x10
  00010	e3a01007	 mov         r1, #7
  00014	e3530001	 cmp         r3, #1
  00018	e58d2008	 str         r2, [sp, #8]
  0001c	e58d100c	 str         r1, [sp, #0xC]
  00020	9a000007	 bls         |$LN3@FlushDomai@9|
  00024	e3530003	 cmp         r3, #3
  00028	9a000003	 bls         |$LN2@FlushDomai@9|
  0002c	e3530004	 cmp         r3, #4
  00030	1a000007	 bne         |$LN4@FlushDomai@9|

; 945  : 
; 946  :         case D4:
; 947  :             // set power domain to off mode
; 948  :             domainPowerState.powerState = POWERSTATE_OFF;

  00034	e3a03000	 mov         r3, #0

; 949  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;
; 950  :             break;

  00038	ea000002	 b           |$LN10@FlushDomai@9|
  0003c		 |$LN2@FlushDomai@9|

; 937  :             break;
; 938  :             
; 939  :         case D2:
; 940  :         case D3:
; 941  :             // currently only supports CSWR
; 942  :             domainPowerState.powerState = POWERSTATE_RETENTION;

  0003c	e3a03001	 mov         r3, #1

; 943  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;
; 944  :             break;

  00040	ea000000	 b           |$LN10@FlushDomai@9|
  00044		 |$LN3@FlushDomai@9|

; 931  :         {
; 932  :         case D0:
; 933  :         case D1:
; 934  :             // set power domain to on
; 935  :             domainPowerState.powerState = POWERSTATE_ON;

  00044	e3a03003	 mov         r3, #3
  00048		 |$LN10@FlushDomai@9|

; 936  :             domainPowerState.logicState = LOGICRETSTATE_LOGICRET_DOMAINRET;

  00048	e3a02004	 mov         r2, #4
  0004c	e58d2014	 str         r2, [sp, #0x14]
  00050	e58d3010	 str         r3, [sp, #0x10]
  00054		 |$LN4@FlushDomai@9|

; 951  :         }
; 952  :     
; 953  :     // send ioctl
; 954  :     rc = KernelIoControl(IOCTL_PRCM_DOMAIN_SET_POWERSTATE, &domainPowerState, 
; 955  :             sizeof(IOCTL_PRCM_DOMAIN_SET_POWERSTATE_IN), 0, 0, 0
; 956  :             );

  00054	e59f0024	 ldr         r0, [pc, #0x24]
  00058	e3a0e000	 mov         lr, #0
  0005c	e3a03000	 mov         r3, #0
  00060	e3a02010	 mov         r2, #0x10
  00064	e28d1008	 add         r1, sp, #8
  00068	e58de004	 str         lr, [sp, #4]
  0006c	e58de000	 str         lr, [sp]
  00070	eb000000	 bl          KernelIoControl

; 957  : 
; 958  :     return rc;
; 959  : }

  00074	e28dd018	 add         sp, sp, #0x18
  00078	e49de004	 ldr         lr, [sp], #4
  0007c	e12fff1e	 bx          lr
  00080		 |$LN14@FlushDomai@9|
  00080		 |$LN15@FlushDomai@9|
  00080	01f50fcc	 DCD         0x1f50fcc
  00084		 |$M38531|

			 ENDP  ; |?FlushDomainPowerState@NeonPowerDomainConstraint@@UAAHXZ|, NeonPowerDomainConstraint::FlushDomainPowerState

	EXPORT	|?MaxIndex@?$IndexList@K@@QAAKXZ|	; IndexList<unsigned long>::MaxIndex
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\pm\inc\indexlist.h

  00000			 AREA	 |.pdata|, PDATA
|$T38545| DCD	|$LN5@MaxIndex|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?MaxIndex@?$IndexList@K@@QAAKXZ| PROC	; IndexList<unsigned long>::MaxIndex

; 76   :     {

  00000		 |$LN5@MaxIndex|
  00000		 |$M38542|

; 77   :         return m_maxIndex;

  00000	e5900088	 ldr         r0, [r0, #0x88]

; 78   :     }

  00004	e12fff1e	 bx          lr
  00008		 |$M38543|

			 ENDP  ; |?MaxIndex@?$IndexList@K@@QAAKXZ|, IndexList<unsigned long>::MaxIndex

	EXPORT	|?GetIndex@?$IndexList@K@@QAAPAKK@Z|	; IndexList<unsigned long>::GetIndex

  00000			 AREA	 |.pdata|, PDATA
|$T38562| DCD	|$LN12@GetIndex|
	DCD	0x40001100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetIndex@?$IndexList@K@@QAAPAKK@Z| PROC ; IndexList<unsigned long>::GetIndex

; 142  :     {

  00000		 |$LN12@GetIndex|
  00000		 |$M38559|

; 143  :         IndexData *pCurrent;
; 144  :         DWORD chunkId = id >> 5;

  00000	e1b022a1	 movs        r2, r1, lsr #5

; 145  : 
; 146  :         // find chunk
; 147  :         pCurrent = &m_Head;
; 148  :         while (chunkId)

  00004	0a000005	 beq         |$LN2@GetIndex|
  00008		 |$LL3@GetIndex|

; 149  :             {
; 150  :             --chunkId;
; 151  :             pCurrent = pCurrent->pNext;

  00008	e5903000	 ldr         r3, [r0]
  0000c	e2422001	 sub         r2, r2, #1
  00010	e1b00003	 movs        r0, r3

; 152  :             if (pCurrent == NULL) return NULL;   

  00014	0a000008	 beq         |$LN6@GetIndex|

; 145  : 
; 146  :         // find chunk
; 147  :         pCurrent = &m_Head;
; 148  :         while (chunkId)

  00018	e3520000	 cmp         r2, #0
  0001c	1afffff9	 bne         |$LL3@GetIndex|
  00020		 |$LN2@GetIndex|

; 153  :             }
; 154  : 
; 155  :         // clear mask
; 156  :         return (pCurrent->ffMask & (1 << (id & 0x1F))) ? 
; 157  :                     &(pCurrent->rgData[id & 0x1F]) : NULL;

  00020	e5903004	 ldr         r3, [r0, #4]
  00024	e201201f	 and         r2, r1, #0x1F
  00028	e3a01001	 mov         r1, #1
  0002c	e1130211	 tst         r3, r1, lsl r2
  00030	12823002	 addne       r3, r2, #2
  00034	10800103	 addne       r0, r0, r3, lsl #2

; 158  :     }

  00038	112fff1e	 bxne        lr
  0003c		 |$LN6@GetIndex|

; 153  :             }
; 154  : 
; 155  :         // clear mask
; 156  :         return (pCurrent->ffMask & (1 << (id & 0x1F))) ? 
; 157  :                     &(pCurrent->rgData[id & 0x1F]) : NULL;

  0003c	e3a00000	 mov         r0, #0

; 158  :     }

  00040	e12fff1e	 bx          lr
  00044		 |$M38560|

			 ENDP  ; |?GetIndex@?$IndexList@K@@QAAPAKK@Z|, IndexList<unsigned long>::GetIndex

	EXPORT	|?UpdatePowerDomainConstraint@PowerDomainConstraint@@MAAHK@Z| ; PowerDomainConstraint::UpdatePowerDomainConstraint
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T38579| DCD	|$LN16@UpdatePowe|
	DCD	0x40001f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdatePowerDomainConstraint@PowerDomainConstraint@@MAAHK@Z| PROC ; PowerDomainConstraint::UpdatePowerDomainConstraint

; 50   : {

  00000		 |$LN16@UpdatePowe|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M38576|
  00004	e1a04000	 mov         r4, r0

; 51   :     int i;
; 52   :     DWORD newState = (DWORD) PwrDeviceUnspecified;
; 53   : 
; 54   :     UNREFERENCED_PARAMETER(idContext);
; 55   :     
; 56   :     // first check if there is a constraint being forced
; 57   :     if (m_powerDomainForce != -1)

  00008	e5941020	 ldr         r1, [r4, #0x20]
  0000c	e3710001	 cmn         r1, #1
  00010	0a000006	 beq         |$LN13@UpdatePowe|

; 58   :         {
; 59   :         DWORD *pDataNode;
; 60   :         pDataNode = m_IndexList.GetIndex(m_powerDomainForce);

  00014	e2840028	 add         r0, r4, #0x28
  00018	eb000000	 bl          |?GetIndex@?$IndexList@K@@QAAPAKK@Z|
  0001c	e3500000	 cmp         r0, #0

; 61   :         if (pDataNode != NULL)

  00020	0a000002	 beq         |$LN13@UpdatePowe|

; 62   :             {
; 63   :             newState = *pDataNode;

  00024	e5902000	 ldr         r2, [r0]

; 64   :             }
; 65   :         }
; 66   : 
; 67   :     // get highest operating mode if not forced
; 68   :     if (newState == PwrDeviceUnspecified)

  00028	e3720001	 cmn         r2, #1
  0002c	1a00000e	 bne         |$LN2@UpdatePowe|
  00030		 |$LN13@UpdatePowe|

; 69   :         {
; 70   :         newState = m_powerDomainFloor;

  00030	e594201c	 ldr         r2, [r4, #0x1C]

; 71   :         for (i = (signed)m_powerDomainCeiling; i <= (signed)m_powerDomainFloor; ++i)

  00034	e5941018	 ldr         r1, [r4, #0x18]
  00038	e1510002	 cmp         r1, r2
  0003c	ca00000a	 bgt         |$LN2@UpdatePowe|

; 69   :         {
; 70   :         newState = m_powerDomainFloor;

  00040	e0840101	 add         r0, r4, r1, lsl #2
  00044		 |$LL4@UpdatePowe|

; 72   :             {
; 73   :             if (m_rgPowerDomainConstraints[i] > 0)

  00044	e5903004	 ldr         r3, [r0, #4]
  00048	e3530000	 cmp         r3, #0
  0004c	8a000005	 bhi         |$LN11@UpdatePowe|
  00050	e594301c	 ldr         r3, [r4, #0x1C]
  00054	e2811001	 add         r1, r1, #1
  00058	e2800004	 add         r0, r0, #4
  0005c	e1510003	 cmp         r1, r3
  00060	dafffff7	 ble         |$LL4@UpdatePowe|
  00064	ea000000	 b           |$LN2@UpdatePowe|
  00068		 |$LN11@UpdatePowe|

; 74   :                 {
; 75   :                 newState = (DWORD)i;

  00068	e1a02001	 mov         r2, r1
  0006c		 |$LN2@UpdatePowe|

; 76   :                 break;
; 77   :                 }
; 78   :             }
; 79   :         }
; 80   : 
; 81   :     // save new state
; 82   :     m_powerDomainCurrent = newState;

  0006c	e5842024	 str         r2, [r4, #0x24]

; 83   :         
; 84   :     return TRUE;

  00070	e3a00001	 mov         r0, #1

; 85   : }

  00074	e8bd4010	 ldmia       sp!, {r4, lr}
  00078	e12fff1e	 bx          lr
  0007c		 |$M38577|

			 ENDP  ; |?UpdatePowerDomainConstraint@PowerDomainConstraint@@MAAHK@Z|, PowerDomainConstraint::UpdatePowerDomainConstraint

	EXPORT	|?UpdatePowerDomainConstraint@PowerDomainConstraint@@QAAHPAXKKIK@Z| ; PowerDomainConstraint::UpdatePowerDomainConstraint
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.h

  00000			 AREA	 |.pdata|, PDATA
|$T38611| DCD	|$LN33@UpdatePowe@2|
	DCD	0x40004001
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdatePowerDomainConstraint@PowerDomainConstraint@@QAAHPAXKKIK@Z| PROC ; PowerDomainConstraint::UpdatePowerDomainConstraint

; 153  : {  

  00000		 |$LN33@UpdatePowe@2|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M38608|
  00004	e1a04003	 mov         r4, r3
  00008	e1a08002	 mov         r8, r2
  0000c	e1a05000	 mov         r5, r0

; 154  :     BOOL rc = FALSE;
; 155  :     DWORD *pDataNode;
; 156  :     DWORD id = (DWORD)hConstraintContext - 1;
; 157  :     
; 158  :     // validate parameters
; 159  :     if (size != sizeof(DWORD)) goto cleanUp;

  00010	e59de018	 ldr         lr, [sp, #0x18]
  00014	e3a06000	 mov         r6, #0
  00018	e2417001	 sub         r7, r1, #1
  0001c	e35e0004	 cmp         lr, #4
  00020	1a000033	 bne         |$cleanUp$37971|

; 160  :     if (id > m_IndexList.MaxIndex()) goto cleanUp;

  00024	e59510b0	 ldr         r1, [r5, #0xB0]
  00028	e1570001	 cmp         r7, r1
  0002c	8a000030	 bhi         |$cleanUp$37971|

; 161  : 
; 162  :     // get data node
; 163  :     pDataNode = m_IndexList.GetIndex(id);

  00030	e1a01007	 mov         r1, r7
  00034	e2850028	 add         r0, r5, #0x28
  00038	eb000000	 bl          |?GetIndex@?$IndexList@K@@QAAPAKK@Z|
  0003c	e3500000	 cmp         r0, #0

; 164  :     if (pDataNode == NULL) goto cleanUp;

  00040	0a00002b	 beq         |$cleanUp$37971|

; 165  : 
; 166  :     // determine new state
; 167  :     if (CONSTRAINT_STATE_NULL == newState)

  00044	e3740801	 cmn         r4, #1, 16

; 168  :         {
; 169  :         newState = (DWORD) PwrDeviceUnspecified;

  00048	03e04000	 mvneq       r4, #0
  0004c	0a000010	 beq         |$LN24@UpdatePowe@2|
  00050	e3e03cff	 mvn         r3, #0xFF, 24

; 170  :         }
; 171  :     else if (CONSTRAINT_STATE_FLOOR == newState)

  00054	e22330fe	 eor         r3, r3, #0xFE
  00058	e1540003	 cmp         r4, r3

; 172  :         {
; 173  :         newState = m_powerDomainFloor;

  0005c	0595401c	 ldreq       r4, [r5, #0x1C]
  00060	0a00000b	 beq         |$LN24@UpdatePowe@2|

; 174  :         }
; 175  :     else 
; 176  :         {
; 177  :         newState = max(min(newState, m_powerDomainFloor), m_powerDomainCeiling);

  00064	e595301c	 ldr         r3, [r5, #0x1C]
  00068	e5951018	 ldr         r1, [r5, #0x18]
  0006c	e1540003	 cmp         r4, r3
  00070	31a02004	 movcc       r2, r4
  00074	21a02003	 movcs       r2, r3
  00078	e1520001	 cmp         r2, r1
  0007c	9a000003	 bls         |$LN23@UpdatePowe@2|
  00080	e1540003	 cmp         r4, r3
  00084	3a000002	 bcc         |$LN24@UpdatePowe@2|
  00088	e1a04003	 mov         r4, r3
  0008c	ea000000	 b           |$LN24@UpdatePowe@2|
  00090		 |$LN23@UpdatePowe@2|
  00090	e1a04001	 mov         r4, r1
  00094		 |$LN24@UpdatePowe@2|

; 178  :         }
; 179  : 
; 180  :     // serialize access
; 181  :     Lock();
; 182  :            
; 183  :     // process constraint message
; 184  :     switch (msg)

  00094	e3580001	 cmp         r8, #1
  00098	0a000002	 beq         |$LN3@UpdatePowe@2|
  0009c	e3580102	 cmp         r8, #2, 2
  000a0	1a00000c	 bne         |$LN5@UpdatePowe@2|

; 185  :         {
; 186  :         case POWERDOMAIN_FORCE:
; 187  :             m_powerDomainForce = id;

  000a4	e5857020	 str         r7, [r5, #0x20]
  000a8		 |$LN3@UpdatePowe@2|

; 188  : 
; 189  :             //fall-through
; 190  :             
; 191  :         case CONSTRAINT_MSG_POWERDOMAIN_REQUEST:
; 192  :             // update new constraint
; 193  :             if (*pDataNode != PwrDeviceUnspecified)

  000a8	e5903000	 ldr         r3, [r0]
  000ac	e3730001	 cmn         r3, #1

; 194  :                 {
; 195  :                 m_rgPowerDomainConstraints[*pDataNode] -= 1;

  000b0	10852103	 addne       r2, r5, r3, lsl #2
  000b4	15923004	 ldrne       r3, [r2, #4]
  000b8	12433001	 subne       r3, r3, #1
  000bc	15823004	 strne       r3, [r2, #4]

; 196  :                 }
; 197  : 
; 198  :             if (newState != PwrDeviceUnspecified)

  000c0	e3740001	 cmn         r4, #1

; 199  :                 {
; 200  :                 m_rgPowerDomainConstraints[newState] += 1;

  000c4	10852104	 addne       r2, r5, r4, lsl #2
  000c8	15923004	 ldrne       r3, [r2, #4]
  000cc	12833001	 addne       r3, r3, #1
  000d0	15823004	 strne       r3, [r2, #4]

; 201  :                 }
; 202  :             *pDataNode = newState;

  000d4	e5804000	 str         r4, [r0]
  000d8		 |$LN5@UpdatePowe@2|

; 203  :             break;
; 204  :         }
; 205  :     
; 206  :     // update operating mode
; 207  :     rc = UpdatePowerDomainConstraint(
; 208  :             idContext
; 209  :             );

  000d8	e5953000	 ldr         r3, [r5]
  000dc	e59d101c	 ldr         r1, [sp, #0x1C]
  000e0	e1a00005	 mov         r0, r5
  000e4	e5933000	 ldr         r3, [r3]
  000e8	e1a0e00f	 mov         lr, pc
  000ec	e12fff13	 bx          r3
  000f0	e1a06000	 mov         r6, r0
  000f4		 |$cleanUp$37971|

; 210  :     
; 211  :     Unlock();
; 212  : 
; 213  : cleanUp:
; 214  :     return rc;
; 215  : } 

  000f4	e1a00006	 mov         r0, r6
  000f8	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000fc	e12fff1e	 bx          lr
  00100		 |$M38609|

			 ENDP  ; |?UpdatePowerDomainConstraint@PowerDomainConstraint@@QAAHPAXKKIK@Z|, PowerDomainConstraint::UpdatePowerDomainConstraint

	EXPORT	|?UpdatePowerDomainConstraint@MpuPowerDomainConstraint@@MAAHK@Z| ; MpuPowerDomainConstraint::UpdatePowerDomainConstraint
	IMPORT	|?NotifyDomainCallbacks@@YAXIIK@Z|	; NotifyDomainCallbacks
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.h

  00000			 AREA	 |.pdata|, PDATA
|$T38636| DCD	|$LN12@UpdatePowe@3|
	DCD	0x40001601
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdatePowerDomainConstraint@MpuPowerDomainConstraint@@MAAHK@Z| PROC ; MpuPowerDomainConstraint::UpdatePowerDomainConstraint

; 228  : {

  00000		 |$LN12@UpdatePowe@3|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M38633|
  00004	e1a07001	 mov         r7, r1
  00008	e1a06000	 mov         r6, r0

; 229  :     BOOL rc = TRUE;
; 230  :     DWORD powerDomainOld = GetPowerDomainConstraint();
; 231  : 
; 232  :     // determine new power domain state
; 233  :     PowerDomainConstraint::UpdatePowerDomainConstraint(idContext);

  0000c	e5964024	 ldr         r4, [r6, #0x24]
  00010	e3a05001	 mov         r5, #1
  00014	eb000000	 bl          |?UpdatePowerDomainConstraint@PowerDomainConstraint@@MAAHK@Z|

; 234  : 
; 235  :     // private mapping to power domain state
; 236  :     if (powerDomainOld != GetPowerDomainConstraint())

  00018	e5963024	 ldr         r3, [r6, #0x24]
  0001c	e1540003	 cmp         r4, r3
  00020	0a000009	 beq         |$LN1@UpdatePowe@3|

; 237  :         {
; 238  :         rc = FlushDomainPowerState();

  00024	e5963000	 ldr         r3, [r6]
  00028	e1a00006	 mov         r0, r6
  0002c	e5933008	 ldr         r3, [r3, #8]
  00030	e1a0e00f	 mov         lr, pc
  00034	e12fff13	 bx          r3

; 239  : 
; 240  :         NotifyDomainCallbacks(POWERDOMAIN_MPU, 
; 241  :             GetPowerDomainConstraint(),
; 242  :             idContext
; 243  :             );

  00038	e5961024	 ldr         r1, [r6, #0x24]
  0003c	e1a05000	 mov         r5, r0
  00040	e3a00005	 mov         r0, #5
  00044	e1a02007	 mov         r2, r7
  00048	eb000000	 bl          |?NotifyDomainCallbacks@@YAXIIK@Z|
  0004c		 |$LN1@UpdatePowe@3|

; 244  :         }
; 245  : 
; 246  :     return rc;
; 247  : }

  0004c	e1a00005	 mov         r0, r5
  00050	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M38634|

			 ENDP  ; |?UpdatePowerDomainConstraint@MpuPowerDomainConstraint@@MAAHK@Z|, MpuPowerDomainConstraint::UpdatePowerDomainConstraint

	EXPORT	|?UpdatePowerDomainConstraint@IvaPowerDomainConstraint@@MAAHK@Z| ; IvaPowerDomainConstraint::UpdatePowerDomainConstraint
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.h

  00000			 AREA	 |.pdata|, PDATA
|$T38661| DCD	|$LN12@UpdatePowe@4|
	DCD	0x40001601
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdatePowerDomainConstraint@IvaPowerDomainConstraint@@MAAHK@Z| PROC ; IvaPowerDomainConstraint::UpdatePowerDomainConstraint

; 314  : {

  00000		 |$LN12@UpdatePowe@4|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M38658|
  00004	e1a07001	 mov         r7, r1
  00008	e1a06000	 mov         r6, r0

; 315  :     BOOL rc = TRUE;
; 316  :     DWORD powerDomainOld = GetPowerDomainConstraint();
; 317  : 
; 318  :     // determine new power domain state
; 319  :     PowerDomainConstraint::UpdatePowerDomainConstraint(idContext);

  0000c	e5964024	 ldr         r4, [r6, #0x24]
  00010	e3a05001	 mov         r5, #1
  00014	eb000000	 bl          |?UpdatePowerDomainConstraint@PowerDomainConstraint@@MAAHK@Z|

; 320  : 
; 321  :     // private mapping to power domain state
; 322  :     if (powerDomainOld != GetPowerDomainConstraint())

  00018	e5963024	 ldr         r3, [r6, #0x24]
  0001c	e1540003	 cmp         r4, r3
  00020	0a000009	 beq         |$LN1@UpdatePowe@4|

; 323  :         {
; 324  :         rc = FlushDomainPowerState();

  00024	e5963000	 ldr         r3, [r6]
  00028	e1a00006	 mov         r0, r6
  0002c	e5933008	 ldr         r3, [r3, #8]
  00030	e1a0e00f	 mov         lr, pc
  00034	e12fff13	 bx          r3

; 325  : 
; 326  :         NotifyDomainCallbacks(POWERDOMAIN_IVA2, 
; 327  :             GetPowerDomainConstraint(),
; 328  :             idContext
; 329  :             );

  00038	e5961024	 ldr         r1, [r6, #0x24]
  0003c	e1a05000	 mov         r5, r0
  00040	e3a00008	 mov         r0, #8
  00044	e1a02007	 mov         r2, r7
  00048	eb000000	 bl          |?NotifyDomainCallbacks@@YAXIIK@Z|
  0004c		 |$LN1@UpdatePowe@4|

; 330  :         }
; 331  :                   
; 332  :     return rc;
; 333  : }

  0004c	e1a00005	 mov         r0, r5
  00050	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M38659|

			 ENDP  ; |?UpdatePowerDomainConstraint@IvaPowerDomainConstraint@@MAAHK@Z|, IvaPowerDomainConstraint::UpdatePowerDomainConstraint

	EXPORT	|?UpdatePowerDomainConstraint@CorePowerDomainConstraint@@MAAHK@Z| ; CorePowerDomainConstraint::UpdatePowerDomainConstraint
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.h

  00000			 AREA	 |.pdata|, PDATA
|$T38686| DCD	|$LN12@UpdatePowe@5|
	DCD	0x40001601
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdatePowerDomainConstraint@CorePowerDomainConstraint@@MAAHK@Z| PROC ; CorePowerDomainConstraint::UpdatePowerDomainConstraint

; 400  : {

  00000		 |$LN12@UpdatePowe@5|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M38683|
  00004	e1a07001	 mov         r7, r1
  00008	e1a06000	 mov         r6, r0

; 401  :     BOOL rc = TRUE;
; 402  :     DWORD powerDomainOld = GetPowerDomainConstraint();
; 403  : 
; 404  :     // determine new power domain state
; 405  :     PowerDomainConstraint::UpdatePowerDomainConstraint(idContext);

  0000c	e5964024	 ldr         r4, [r6, #0x24]
  00010	e3a05001	 mov         r5, #1
  00014	eb000000	 bl          |?UpdatePowerDomainConstraint@PowerDomainConstraint@@MAAHK@Z|

; 406  : 
; 407  :     // private mapping to power domain state
; 408  :     if (powerDomainOld != GetPowerDomainConstraint())

  00018	e5963024	 ldr         r3, [r6, #0x24]
  0001c	e1540003	 cmp         r4, r3
  00020	0a000009	 beq         |$LN1@UpdatePowe@5|

; 409  :         {
; 410  :         rc = FlushDomainPowerState();

  00024	e5963000	 ldr         r3, [r6]
  00028	e1a00006	 mov         r0, r6
  0002c	e5933008	 ldr         r3, [r3, #8]
  00030	e1a0e00f	 mov         lr, pc
  00034	e12fff13	 bx          r3

; 411  : 
; 412  :         NotifyDomainCallbacks(POWERDOMAIN_CORE, 
; 413  :             GetPowerDomainConstraint(),
; 414  :             idContext
; 415  :             );

  00038	e5961024	 ldr         r1, [r6, #0x24]
  0003c	e1a05000	 mov         r5, r0
  00040	e3a00001	 mov         r0, #1
  00044	e1a02007	 mov         r2, r7
  00048	eb000000	 bl          |?NotifyDomainCallbacks@@YAXIIK@Z|
  0004c		 |$LN1@UpdatePowe@5|

; 416  :         }
; 417  :                   
; 418  :     return rc;
; 419  : }

  0004c	e1a00005	 mov         r0, r5
  00050	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M38684|

			 ENDP  ; |?UpdatePowerDomainConstraint@CorePowerDomainConstraint@@MAAHK@Z|, CorePowerDomainConstraint::UpdatePowerDomainConstraint

	EXPORT	|?UpdatePowerDomainConstraint@PeripheralPowerDomainConstraint@@MAAHK@Z| ; PeripheralPowerDomainConstraint::UpdatePowerDomainConstraint
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.h

  00000			 AREA	 |.pdata|, PDATA
|$T38711| DCD	|$LN12@UpdatePowe@6|
	DCD	0x40001601
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdatePowerDomainConstraint@PeripheralPowerDomainConstraint@@MAAHK@Z| PROC ; PeripheralPowerDomainConstraint::UpdatePowerDomainConstraint

; 486  : {

  00000		 |$LN12@UpdatePowe@6|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M38708|
  00004	e1a07001	 mov         r7, r1
  00008	e1a06000	 mov         r6, r0

; 487  :     BOOL rc = TRUE;
; 488  :     DWORD powerDomainOld = GetPowerDomainConstraint();
; 489  : 
; 490  :     // determine new power domain state
; 491  :     PowerDomainConstraint::UpdatePowerDomainConstraint(idContext);

  0000c	e5964024	 ldr         r4, [r6, #0x24]
  00010	e3a05001	 mov         r5, #1
  00014	eb000000	 bl          |?UpdatePowerDomainConstraint@PowerDomainConstraint@@MAAHK@Z|

; 492  : 
; 493  :     // private mapping to power domain state
; 494  :     if (powerDomainOld != GetPowerDomainConstraint())

  00018	e5963024	 ldr         r3, [r6, #0x24]
  0001c	e1540003	 cmp         r4, r3
  00020	0a000009	 beq         |$LN1@UpdatePowe@6|

; 495  :         {
; 496  :         rc = FlushDomainPowerState();

  00024	e5963000	 ldr         r3, [r6]
  00028	e1a00006	 mov         r0, r6
  0002c	e5933008	 ldr         r3, [r3, #8]
  00030	e1a0e00f	 mov         lr, pc
  00034	e12fff13	 bx          r3

; 497  : 
; 498  :         NotifyDomainCallbacks(POWERDOMAIN_PERIPHERAL, 
; 499  :             GetPowerDomainConstraint(),
; 500  :             idContext
; 501  :             );

  00038	e5961024	 ldr         r1, [r6, #0x24]
  0003c	e1a05000	 mov         r5, r0
  00040	e3a00002	 mov         r0, #2
  00044	e1a02007	 mov         r2, r7
  00048	eb000000	 bl          |?NotifyDomainCallbacks@@YAXIIK@Z|
  0004c		 |$LN1@UpdatePowe@6|

; 502  :         }
; 503  :                   
; 504  :     return rc;
; 505  : }

  0004c	e1a00005	 mov         r0, r5
  00050	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M38709|

			 ENDP  ; |?UpdatePowerDomainConstraint@PeripheralPowerDomainConstraint@@MAAHK@Z|, PeripheralPowerDomainConstraint::UpdatePowerDomainConstraint

	EXPORT	|?UpdatePowerDomainConstraint@DssPowerDomainConstraint@@MAAHK@Z| ; DssPowerDomainConstraint::UpdatePowerDomainConstraint
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.h

  00000			 AREA	 |.pdata|, PDATA
|$T38736| DCD	|$LN12@UpdatePowe@7|
	DCD	0x40001601
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdatePowerDomainConstraint@DssPowerDomainConstraint@@MAAHK@Z| PROC ; DssPowerDomainConstraint::UpdatePowerDomainConstraint

; 567  : {

  00000		 |$LN12@UpdatePowe@7|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M38733|
  00004	e1a07001	 mov         r7, r1
  00008	e1a06000	 mov         r6, r0

; 568  :     BOOL rc = TRUE;
; 569  :     DWORD powerDomainOld = GetPowerDomainConstraint();
; 570  : 
; 571  :     // determine new power domain state
; 572  :     PowerDomainConstraint::UpdatePowerDomainConstraint(idContext);

  0000c	e5964024	 ldr         r4, [r6, #0x24]
  00010	e3a05001	 mov         r5, #1
  00014	eb000000	 bl          |?UpdatePowerDomainConstraint@PowerDomainConstraint@@MAAHK@Z|

; 573  : 
; 574  :     // private mapping to power domain state
; 575  :     if (powerDomainOld != GetPowerDomainConstraint())

  00018	e5963024	 ldr         r3, [r6, #0x24]
  0001c	e1540003	 cmp         r4, r3
  00020	0a000009	 beq         |$LN1@UpdatePowe@7|

; 576  :         {
; 577  :         rc = FlushDomainPowerState();

  00024	e5963000	 ldr         r3, [r6]
  00028	e1a00006	 mov         r0, r6
  0002c	e5933008	 ldr         r3, [r3, #8]
  00030	e1a0e00f	 mov         lr, pc
  00034	e12fff13	 bx          r3

; 578  : 
; 579  :         NotifyDomainCallbacks(POWERDOMAIN_DSS, 
; 580  :             GetPowerDomainConstraint(),
; 581  :             idContext
; 582  :             );

  00038	e5961024	 ldr         r1, [r6, #0x24]
  0003c	e1a05000	 mov         r5, r0
  00040	e3a00006	 mov         r0, #6
  00044	e1a02007	 mov         r2, r7
  00048	eb000000	 bl          |?NotifyDomainCallbacks@@YAXIIK@Z|
  0004c		 |$LN1@UpdatePowe@7|

; 583  :         }
; 584  : 
; 585  :     return rc;
; 586  : }

  0004c	e1a00005	 mov         r0, r5
  00050	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M38734|

			 ENDP  ; |?UpdatePowerDomainConstraint@DssPowerDomainConstraint@@MAAHK@Z|, DssPowerDomainConstraint::UpdatePowerDomainConstraint

	EXPORT	|?UpdatePowerDomainConstraint@SgxPowerDomainConstraint@@MAAHK@Z| ; SgxPowerDomainConstraint::UpdatePowerDomainConstraint
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.h

  00000			 AREA	 |.pdata|, PDATA
|$T38761| DCD	|$LN12@UpdatePowe@8|
	DCD	0x40001601
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdatePowerDomainConstraint@SgxPowerDomainConstraint@@MAAHK@Z| PROC ; SgxPowerDomainConstraint::UpdatePowerDomainConstraint

; 648  : {

  00000		 |$LN12@UpdatePowe@8|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M38758|
  00004	e1a07001	 mov         r7, r1
  00008	e1a06000	 mov         r6, r0

; 649  :     BOOL rc = TRUE;
; 650  :     DWORD powerDomainOld = GetPowerDomainConstraint();
; 651  : 
; 652  :     // determine new power domain state
; 653  :     PowerDomainConstraint::UpdatePowerDomainConstraint(idContext);

  0000c	e5964024	 ldr         r4, [r6, #0x24]
  00010	e3a05001	 mov         r5, #1
  00014	eb000000	 bl          |?UpdatePowerDomainConstraint@PowerDomainConstraint@@MAAHK@Z|

; 654  : 
; 655  :     // private mapping to power domain state
; 656  :     if (powerDomainOld != GetPowerDomainConstraint())

  00018	e5963024	 ldr         r3, [r6, #0x24]
  0001c	e1540003	 cmp         r4, r3
  00020	0a000009	 beq         |$LN1@UpdatePowe@8|

; 657  :         {
; 658  :         rc = FlushDomainPowerState();

  00024	e5963000	 ldr         r3, [r6]
  00028	e1a00006	 mov         r0, r6
  0002c	e5933008	 ldr         r3, [r3, #8]
  00030	e1a0e00f	 mov         lr, pc
  00034	e12fff13	 bx          r3

; 659  : 
; 660  :         NotifyDomainCallbacks(POWERDOMAIN_SGX, 
; 661  :             GetPowerDomainConstraint(),
; 662  :             idContext
; 663  :             );

  00038	e5961024	 ldr         r1, [r6, #0x24]
  0003c	e1a05000	 mov         r5, r0
  00040	e3a0000a	 mov         r0, #0xA
  00044	e1a02007	 mov         r2, r7
  00048	eb000000	 bl          |?NotifyDomainCallbacks@@YAXIIK@Z|
  0004c		 |$LN1@UpdatePowe@8|

; 664  :         }
; 665  :                   
; 666  :     return rc;
; 667  : }

  0004c	e1a00005	 mov         r0, r5
  00050	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M38759|

			 ENDP  ; |?UpdatePowerDomainConstraint@SgxPowerDomainConstraint@@MAAHK@Z|, SgxPowerDomainConstraint::UpdatePowerDomainConstraint

	EXPORT	|?UpdatePowerDomainConstraint@CameraPowerDomainConstraint@@MAAHK@Z| ; CameraPowerDomainConstraint::UpdatePowerDomainConstraint
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.h

  00000			 AREA	 |.pdata|, PDATA
|$T38786| DCD	|$LN12@UpdatePowe@9|
	DCD	0x40001601
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdatePowerDomainConstraint@CameraPowerDomainConstraint@@MAAHK@Z| PROC ; CameraPowerDomainConstraint::UpdatePowerDomainConstraint

; 729  : {

  00000		 |$LN12@UpdatePowe@9|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M38783|
  00004	e1a07001	 mov         r7, r1
  00008	e1a06000	 mov         r6, r0

; 730  :     BOOL rc = TRUE;
; 731  :     DWORD powerDomainOld = GetPowerDomainConstraint();
; 732  :     
; 733  :     // determine new power domain state
; 734  :     PowerDomainConstraint::UpdatePowerDomainConstraint(idContext);

  0000c	e5964024	 ldr         r4, [r6, #0x24]
  00010	e3a05001	 mov         r5, #1
  00014	eb000000	 bl          |?UpdatePowerDomainConstraint@PowerDomainConstraint@@MAAHK@Z|

; 735  : 
; 736  :     // private mapping to power domain state
; 737  :     if (powerDomainOld != GetPowerDomainConstraint())

  00018	e5963024	 ldr         r3, [r6, #0x24]
  0001c	e1540003	 cmp         r4, r3
  00020	0a000009	 beq         |$LN1@UpdatePowe@9|

; 738  :         {
; 739  :         rc = FlushDomainPowerState();

  00024	e5963000	 ldr         r3, [r6]
  00028	e1a00006	 mov         r0, r6
  0002c	e5933008	 ldr         r3, [r3, #8]
  00030	e1a0e00f	 mov         lr, pc
  00034	e12fff13	 bx          r3

; 740  :         
; 741  :         NotifyDomainCallbacks(POWERDOMAIN_CAMERA, 
; 742  :             GetPowerDomainConstraint(),
; 743  :             idContext
; 744  :             );                      

  00038	e5961024	 ldr         r1, [r6, #0x24]
  0003c	e1a05000	 mov         r5, r0
  00040	e3a00009	 mov         r0, #9
  00044	e1a02007	 mov         r2, r7
  00048	eb000000	 bl          |?NotifyDomainCallbacks@@YAXIIK@Z|
  0004c		 |$LN1@UpdatePowe@9|

; 745  :         }
; 746  :    
; 747  :     return rc;
; 748  : }

  0004c	e1a00005	 mov         r0, r5
  00050	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M38784|

			 ENDP  ; |?UpdatePowerDomainConstraint@CameraPowerDomainConstraint@@MAAHK@Z|, CameraPowerDomainConstraint::UpdatePowerDomainConstraint

	EXPORT	|?UpdatePowerDomainConstraint@UsbHostPowerDomainConstraint@@MAAHK@Z| ; UsbHostPowerDomainConstraint::UpdatePowerDomainConstraint
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.h

  00000			 AREA	 |.pdata|, PDATA
|$T38811| DCD	|$LN12@UpdatePowe@10|
	DCD	0x40001601
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdatePowerDomainConstraint@UsbHostPowerDomainConstraint@@MAAHK@Z| PROC ; UsbHostPowerDomainConstraint::UpdatePowerDomainConstraint

; 810  : {

  00000		 |$LN12@UpdatePowe@10|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M38808|
  00004	e1a07001	 mov         r7, r1
  00008	e1a06000	 mov         r6, r0

; 811  :     BOOL rc = TRUE;
; 812  :     DWORD powerDomainOld = GetPowerDomainConstraint();
; 813  : 
; 814  :     // determine new power domain state
; 815  :     PowerDomainConstraint::UpdatePowerDomainConstraint(idContext);

  0000c	e5964024	 ldr         r4, [r6, #0x24]
  00010	e3a05001	 mov         r5, #1
  00014	eb000000	 bl          |?UpdatePowerDomainConstraint@PowerDomainConstraint@@MAAHK@Z|

; 816  : 
; 817  :     // private mapping to power domain state
; 818  :     if (powerDomainOld != GetPowerDomainConstraint())

  00018	e5963024	 ldr         r3, [r6, #0x24]
  0001c	e1540003	 cmp         r4, r3
  00020	0a000009	 beq         |$LN1@UpdatePowe@10|

; 819  :         {
; 820  :         rc = FlushDomainPowerState();

  00024	e5963000	 ldr         r3, [r6]
  00028	e1a00006	 mov         r0, r6
  0002c	e5933008	 ldr         r3, [r3, #8]
  00030	e1a0e00f	 mov         lr, pc
  00034	e12fff13	 bx          r3

; 821  : 
; 822  :         NotifyDomainCallbacks(POWERDOMAIN_USBHOST, 
; 823  :             GetPowerDomainConstraint(),
; 824  :             idContext
; 825  :             );

  00038	e5961024	 ldr         r1, [r6, #0x24]
  0003c	e1a05000	 mov         r5, r0
  00040	e3a00003	 mov         r0, #3
  00044	e1a02007	 mov         r2, r7
  00048	eb000000	 bl          |?NotifyDomainCallbacks@@YAXIIK@Z|
  0004c		 |$LN1@UpdatePowe@10|

; 826  :         }
; 827  :                   
; 828  :     return rc;
; 829  : }

  0004c	e1a00005	 mov         r0, r5
  00050	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M38809|

			 ENDP  ; |?UpdatePowerDomainConstraint@UsbHostPowerDomainConstraint@@MAAHK@Z|, UsbHostPowerDomainConstraint::UpdatePowerDomainConstraint

	EXPORT	|?UpdatePowerDomainConstraint@NeonPowerDomainConstraint@@MAAHK@Z| ; NeonPowerDomainConstraint::UpdatePowerDomainConstraint
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.h

  00000			 AREA	 |.pdata|, PDATA
|$T38836| DCD	|$LN12@UpdatePowe@11|
	DCD	0x40001601
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\pm\constraintadapters\powerdomainconstraint\powerdomainconstraint.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdatePowerDomainConstraint@NeonPowerDomainConstraint@@MAAHK@Z| PROC ; NeonPowerDomainConstraint::UpdatePowerDomainConstraint

; 891  : {

  00000		 |$LN12@UpdatePowe@11|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M38833|
  00004	e1a07001	 mov         r7, r1
  00008	e1a06000	 mov         r6, r0

; 892  :     BOOL rc = TRUE;
; 893  :     DWORD powerDomainOld = GetPowerDomainConstraint();
; 894  : 
; 895  :     // determine new power domain state
; 896  :     PowerDomainConstraint::UpdatePowerDomainConstraint(idContext);

  0000c	e5964024	 ldr         r4, [r6, #0x24]
  00010	e3a05001	 mov         r5, #1
  00014	eb000000	 bl          |?UpdatePowerDomainConstraint@PowerDomainConstraint@@MAAHK@Z|

; 897  : 
; 898  :     // private mapping to power domain state
; 899  :     if (powerDomainOld != GetPowerDomainConstraint())

  00018	e5963024	 ldr         r3, [r6, #0x24]
  0001c	e1540003	 cmp         r4, r3
  00020	0a000009	 beq         |$LN1@UpdatePowe@11|

; 900  :         {
; 901  :         rc = FlushDomainPowerState();

  00024	e5963000	 ldr         r3, [r6]
  00028	e1a00006	 mov         r0, r6
  0002c	e5933008	 ldr         r3, [r3, #8]
  00030	e1a0e00f	 mov         lr, pc
  00034	e12fff13	 bx          r3

; 902  : 
; 903  :         NotifyDomainCallbacks(POWERDOMAIN_NEON, 
; 904  :             GetPowerDomainConstraint(),
; 905  :             idContext
; 906  :             );

  00038	e5961024	 ldr         r1, [r6, #0x24]
  0003c	e1a05000	 mov         r5, r0
  00040	e3a00007	 mov         r0, #7
  00044	e1a02007	 mov         r2, r7
  00048	eb000000	 bl          |?NotifyDomainCallbacks@@YAXIIK@Z|
  0004c		 |$LN1@UpdatePowe@11|

; 907  :         }
; 908  :                   
; 909  :     return rc;
; 910  : }

  0004c	e1a00005	 mov         r0, r5
  00050	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M38834|

			 ENDP  ; |?UpdatePowerDomainConstraint@NeonPowerDomainConstraint@@MAAHK@Z|, NeonPowerDomainConstraint::UpdatePowerDomainConstraint

	END
