; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\OMAP3530\MUSB\MUSBOTG\otg.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1CC@CKFJFILD@?$AAU?$AAS?$AAB?$AAC?$AAh?$AAa?$AAr?$AAg?$AAe?$AAr?$AAN?$AAo?$AAt?$AAi?$AAf?$AAy?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CC@EBHGALEG@?$AAD?$AAi?$AAs?$AAa?$AAb?$AAl?$AAe?$AAH?$AAi?$AAg?$AAh?$AAS?$AAp?$AAe?$AAe?$AAd?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BO@DFKBGJHN@?$AAs?$AAt?$AAa?$AAr?$AAt?$AAu?$AAp?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CC@EGEMNJNG@?$AAv?$AAb?$AAu?$AAs?$AA?4?$AAp?$AAo?$AAw?$AAe?$AAr?$AA?4?$AAe?$AAv?$AAe?$AAn?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|?gpHsUsbOtg@@3PAVOMAPMHSUSBOTG@@A| [ DATA ] ; gpHsUsbOtg
	EXPORT	|?g_busDx@@3W4_CEDEVICE_POWER_STATE@@A| [ DATA ] ; g_busDx

  00000			 AREA	 |.bss|, NOINIT
|?gpHsUsbOtg@@3PAVOMAPMHSUSBOTG@@A| % 0x4		; gpHsUsbOtg

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@CKFJFILD@?$AAU?$AAS?$AAB?$AAC?$AAh?$AAa?$AAr?$AAg?$AAe?$AAr?$AAN?$AAo?$AAt?$AAi?$AAf?$AAy?$AA?$AA@| DCB "U"
	DCB	0x0, "S", 0x0, "B", 0x0, "C", 0x0, "h", 0x0, "a", 0x0, "r"
	DCB	0x0, "g", 0x0, "e", 0x0, "r", 0x0, "N", 0x0, "o", 0x0, "t"
	DCB	0x0, "i", 0x0, "f", 0x0, "y", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@EBHGALEG@?$AAD?$AAi?$AAs?$AAa?$AAb?$AAl?$AAe?$AAH?$AAi?$AAg?$AAh?$AAS?$AAp?$AAe?$AAe?$AAd?$AA?$AA@| DCB "D"
	DCB	0x0, "i", 0x0, "s", 0x0, "a", 0x0, "b", 0x0, "l", 0x0, "e"
	DCB	0x0, "H", 0x0, "i", 0x0, "g", 0x0, "h", 0x0, "S", 0x0, "p"
	DCB	0x0, "e", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BO@DFKBGJHN@?$AAs?$AAt?$AAa?$AAr?$AAt?$AAu?$AAp?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB "s"
	DCB	0x0, "t", 0x0, "a", 0x0, "r", 0x0, "t", 0x0, "u", 0x0, "p"
	DCB	0x0, "T", 0x0, "i", 0x0, "m", 0x0, "e", 0x0, "o", 0x0, "u"
	DCB	0x0, "t", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.data|, DATA
|pChargerNameEvt| DCD |??_C@_1CC@EGEMNJNG@?$AAv?$AAb?$AAu?$AAs?$AA?4?$AAp?$AAo?$AAw?$AAe?$AAr?$AA?4?$AAe?$AAv?$AAe?$AAn?$AAt?$AA?$AA@|
|?g_busDx@@3W4_CEDEVICE_POWER_STATE@@A| DCD 0x4		; g_busDx

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@EGEMNJNG@?$AAv?$AAb?$AAu?$AAs?$AA?4?$AAp?$AAo?$AAw?$AAe?$AAr?$AA?4?$AAe?$AAv?$AAe?$AAn?$AAt?$AA?$AA@| DCB "v"
	DCB	0x0, "b", 0x0, "u", 0x0, "s", 0x0, ".", 0x0, "p", 0x0, "o"
	DCB	0x0, "w", 0x0, "e", 0x0, "r", 0x0, ".", 0x0, "e", 0x0, "v"
	DCB	0x0, "e", 0x0, "n", 0x0, "t", 0x0, 0x0, 0x0 ; `string'
	EXPORT	|ResetEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T42550| DCD	|$LN5@ResetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ResetEvent| PROC

; 223  : _inline BOOL ResetEvent(HANDLE h) {

  00000		 |$LN5@ResetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42547|

; 224  : 	return EventModify(h,EVENT_RESET);

  00004	e3a01002	 mov         r1, #2
  00008	eb000000	 bl          EventModify

; 225  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M42548|

			 ENDP  ; |ResetEvent|

	EXPORT	|SetEvent|

  00000			 AREA	 |.pdata|, PDATA
|$T42560| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42557|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M42558|

			 ENDP  ; |SetEvent|

	EXPORT	|GetCurrentThread|

  00000			 AREA	 |.pdata|, PDATA
|$T42569| DCD	|$LN5@GetCurrent|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentThread| PROC

; 351  : _inline HANDLE GetCurrentThread(void) {

  00000		 |$LN5@GetCurrent|
  00000		 |$M42566|

; 352  : 	return ((HANDLE)(SH_CURTHREAD+SYS_HANDLE_BASE));

  00000	e3a00041	 mov         r0, #0x41

; 353  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M42567|

			 ENDP  ; |GetCurrentThread|

	EXPORT	|??0CLockObject@@QAA@XZ|		; CLockObject::CLockObject
	IMPORT	|InitializeCriticalSection|
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T42579| DCD	|$LN5@CLockObjec|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CLockObject@@QAA@XZ| PROC		; CLockObject::CLockObject

; 36   :     CLockObject()

  00000		 |$LN5@CLockObjec|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M42576|
  00004	e1a04000	 mov         r4, r0

; 37   :     {
; 38   :         InitializeCriticalSection( &m_CSection );

  00008	eb000000	 bl          InitializeCriticalSection

; 39   :     };

  0000c	e1a00004	 mov         r0, r4
  00010	e8bd4010	 ldmia       sp!, {r4, lr}
  00014	e12fff1e	 bx          lr
  00018		 |$M42577|

			 ENDP  ; |??0CLockObject@@QAA@XZ|, CLockObject::CLockObject

	EXPORT	|??1CLockObject@@QAA@XZ|		; CLockObject::~CLockObject
	IMPORT	|DeleteCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T42587| DCD	|$LN5@CLockObjec@2|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CLockObject@@QAA@XZ| PROC		; CLockObject::~CLockObject

; 41   :     {

  00000		 |$LN5@CLockObjec@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42584|

; 42   :         DeleteCriticalSection( &m_CSection );

  00004	eb000000	 bl          DeleteCriticalSection

; 43   :     };

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M42585|

			 ENDP  ; |??1CLockObject@@QAA@XZ|, CLockObject::~CLockObject

	EXPORT	|??0CRegistryEdit@@QAA@PAUHKEY__@@PBG@Z| ; CRegistryEdit::CRegistryEdit
	IMPORT	|RegOpenKeyExW|
; File c:\wince600\public\common\oak\inc\cregedit.h

  00000			 AREA	 |.pdata|, PDATA
|$T42599| DCD	|$LN7@CRegistryE|
	DCD	0x40001402
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CRegistryEdit@@QAA@PAUHKEY__@@PBG@Z| PROC ; CRegistryEdit::CRegistryEdit

; 45   :     CRegistryEdit( HKEY hKey, LPCTSTR pszRegPath )

  00000		 |$LN7@CRegistryE|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M42596|
  00008	e1b0e002	 movs        lr, r2
  0000c	e1a05001	 mov         r5, r1
  00010	e1a04000	 mov         r4, r0

; 46   :     {
; 47   :         m_hDevKey = NULL;

  00014	e3a06000	 mov         r6, #0
  00018	e5846000	 str         r6, [r4]

; 48   :         if( pszRegPath )

  0001c	0a000007	 beq         |$LN1@CRegistryE|

; 49   :         {
; 50   :             if( RegOpenKeyEx( hKey, pszRegPath, 0, 0, &m_hDevKey ) != ERROR_SUCCESS )

  00020	e3a03000	 mov         r3, #0
  00024	e3a02000	 mov         r2, #0
  00028	e1a0100e	 mov         r1, lr
  0002c	e1a00005	 mov         r0, r5
  00030	e58d4000	 str         r4, [sp]
  00034	eb000000	 bl          RegOpenKeyExW
  00038	e3500000	 cmp         r0, #0

; 51   :             {
; 52   :                 m_hDevKey = NULL;

  0003c	15846000	 strne       r6, [r4]
  00040		 |$LN1@CRegistryE|

; 53   :             }
; 54   :         }
; 55   :     }

  00040	e1a00004	 mov         r0, r4
  00044	e28dd004	 add         sp, sp, #4
  00048	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M42597|

			 ENDP  ; |??0CRegistryEdit@@QAA@PAUHKEY__@@PBG@Z|, CRegistryEdit::CRegistryEdit

	EXPORT	|??1CRegistryEdit@@QAA@XZ|		; CRegistryEdit::~CRegistryEdit
	IMPORT	|RegCloseKey|

  00000			 AREA	 |.pdata|, PDATA
|$T42607| DCD	|$LN6@CRegistryE@2|
	DCD	0x40000701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CRegistryEdit@@QAA@XZ| PROC	; CRegistryEdit::~CRegistryEdit

; 80   :     {

  00000		 |$LN6@CRegistryE@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42604|

; 81   :         if( m_hDevKey )

  00004	e5903000	 ldr         r3, [r0]
  00008	e3530000	 cmp         r3, #0

; 82   :         {
; 83   :             RegCloseKey( m_hDevKey );

  0000c	11a00003	 movne       r0, r3
  00010	1b000000	 blne        RegCloseKey

; 84   :         }
; 85   :     }

  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$M42605|

			 ENDP  ; |??1CRegistryEdit@@QAA@XZ|, CRegistryEdit::~CRegistryEdit

	EXPORT	|?GetIsrInfo@CRegistryEdit@@QAAKPAU_DDKISRINFO_tag@@@Z| ; CRegistryEdit::GetIsrInfo
	IMPORT	|DDKReg_GetIsrInfo|

  00000			 AREA	 |.pdata|, PDATA
|$T42618| DCD	|$LN7@GetIsrInfo|
	DCD	0x40000f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetIsrInfo@CRegistryEdit@@QAAKPAU_DDKISRINFO_tag@@@Z| PROC ; CRegistryEdit::GetIsrInfo

; 102  :     {

  00000		 |$LN7@GetIsrInfo|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42615|
  00004	e3510000	 cmp         r1, #0

; 103  :         if( pddi && m_hDevKey )

  00008	0a000008	 beq         |$LN2@GetIsrInfo|
  0000c	e5903000	 ldr         r3, [r0]
  00010	e3530000	 cmp         r3, #0
  00014	0a000005	 beq         |$LN2@GetIsrInfo|

; 104  :         {
; 105  :             pddi->cbSize = sizeof( DDKISRINFO );

  00018	e3a03f43	 mov         r3, #0x43, 30
  0001c	e5813000	 str         r3, [r1]

; 106  :             DWORD status = DDKReg_GetIsrInfo( m_hDevKey, pddi );

  00020	e5900000	 ldr         r0, [r0]
  00024	eb000000	 bl          DDKReg_GetIsrInfo

; 112  :         }
; 113  :     }

  00028	e49de004	 ldr         lr, [sp], #4
  0002c	e12fff1e	 bx          lr
  00030		 |$LN2@GetIsrInfo|

; 107  :             return status;
; 108  :         }
; 109  :         else
; 110  :         {
; 111  :             return ERROR_INVALID_FUNCTION;

  00030	e3a00001	 mov         r0, #1

; 112  :         }
; 113  :     }

  00034	e49de004	 ldr         lr, [sp], #4
  00038	e12fff1e	 bx          lr
  0003c		 |$M42616|

			 ENDP  ; |?GetIsrInfo@CRegistryEdit@@QAAKPAU_DDKISRINFO_tag@@@Z|, CRegistryEdit::GetIsrInfo

	EXPORT	|?IsKeyOpened@CRegistryEdit@@QAAHXZ|	; CRegistryEdit::IsKeyOpened

  00000			 AREA	 |.pdata|, PDATA
|$T42630| DCD	|$LN7@IsKeyOpene|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsKeyOpened@CRegistryEdit@@QAAHXZ| PROC ; CRegistryEdit::IsKeyOpened

; 171  :     {

  00000		 |$LN7@IsKeyOpene|
  00000		 |$M42627|

; 172  :         return ( m_hDevKey != NULL );

  00000	e5903000	 ldr         r3, [r0]
  00004	e3530000	 cmp         r3, #0
  00008	13a00001	 movne       r0, #1
  0000c	03a00000	 moveq       r0, #0

; 173  :     }

  00010	e12fff1e	 bx          lr
  00014		 |$M42628|

			 ENDP  ; |?IsKeyOpened@CRegistryEdit@@QAAHXZ|, CRegistryEdit::IsKeyOpened

	EXPORT	|?GetDeviceHandle@DefaultBusDriver@@QAAPAXXZ| ; DefaultBusDriver::GetDeviceHandle
; File c:\wince600\public\common\oak\inc\defbus.h

  00000			 AREA	 |.pdata|, PDATA
|$T42640| DCD	|$LN5@GetDeviceH|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetDeviceHandle@DefaultBusDriver@@QAAPAXXZ| PROC ; DefaultBusDriver::GetDeviceHandle

; 167  :     HANDLE GetDeviceHandle() { return m_hDevice; };

  00000		 |$LN5@GetDeviceH|
  00000		 |$M42637|
  00000	e5900020	 ldr         r0, [r0, #0x20]
  00004	e12fff1e	 bx          lr
  00008		 |$M42638|

			 ENDP  ; |?GetDeviceHandle@DefaultBusDriver@@QAAPAXXZ|, DefaultBusDriver::GetDeviceHandle

	EXPORT	|?ThreadStart@CMiniThread@@QAAHXZ|	; CMiniThread::ThreadStart
	IMPORT	|ResumeThread|
; File c:\wince600\public\common\oak\inc\cmthread.h

  00000			 AREA	 |.pdata|, PDATA
|$T42650| DCD	|$LN7@ThreadStar|
	DCD	0x40001001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ThreadStart@CMiniThread@@QAAHXZ| PROC ; CMiniThread::ThreadStart

; 49   :     {

  00000		 |$LN7@ThreadStar|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M42647|
  00004	e1a04000	 mov         r4, r0

; 50   :         if( m_bSuspendFlag )

  00008	e5943010	 ldr         r3, [r4, #0x10]
  0000c	e3530000	 cmp         r3, #0
  00010	0a000007	 beq         |$LN2@ThreadStar|

; 51   :         {
; 52   :             if( ResumeThread( m_hThreadHandle ) == ( DWORD ) ( -1 ) )

  00014	e5940008	 ldr         r0, [r4, #8]
  00018	eb000000	 bl          ResumeThread
  0001c	e3700001	 cmn         r0, #1

; 53   :             {
; 54   :                 // failure for resume somehow
; 55   :                 return FALSE;

  00020	03a00000	 moveq       r0, #0

; 60   :     }

  00024	08bd4010	 ldmeqia     sp!, {r4, lr}
  00028	012fff1e	 bxeq        lr

; 56   :             };
; 57   :             m_bSuspendFlag = FALSE;

  0002c	e3a03000	 mov         r3, #0
  00030	e5843010	 str         r3, [r4, #0x10]
  00034		 |$LN2@ThreadStar|

; 58   :         }
; 59   :         return TRUE;

  00034	e3a00001	 mov         r0, #1

; 60   :     }

  00038	e8bd4010	 ldmia       sp!, {r4, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$M42648|

			 ENDP  ; |?ThreadStart@CMiniThread@@QAAHXZ|, CMiniThread::ThreadStart

	EXPORT	|?WaitThreadComplete@CMiniThread@@QAAHK@Z| ; CMiniThread::WaitThreadComplete
	IMPORT	|CloseHandle|
	IMPORT	|WaitForSingleObject|

  00000			 AREA	 |.pdata|, PDATA
|$T42661| DCD	|$LN8@WaitThread|
	DCD	0x40001801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?WaitThreadComplete@CMiniThread@@QAAHK@Z| PROC ; CMiniThread::WaitThreadComplete

; 92   :     {

  00000		 |$LN8@WaitThread|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M42658|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 93   :         if( !m_hThreadHandle )

  0000c	e5943008	 ldr         r3, [r4, #8]
  00010	e3530000	 cmp         r3, #0

; 94   :         {
; 95   :             return FALSE;

  00014	0a00000e	 beq         |$LN1@WaitThread|

; 96   :         };
; 97   : 
; 98   :         if( ThreadStart() )

  00018	eb000000	 bl          |?ThreadStart@CMiniThread@@QAAHXZ|
  0001c	e3500000	 cmp         r0, #0
  00020	0a00000b	 beq         |$LN1@WaitThread|

; 99   :         {
; 100  :             if( ::WaitForSingleObject( m_hThreadHandle, dwMilliSeconds ) ==
; 101  :                 WAIT_OBJECT_0 )

  00024	e5940008	 ldr         r0, [r4, #8]
  00028	e1a01005	 mov         r1, r5
  0002c	eb000000	 bl          WaitForSingleObject
  00030	e3500000	 cmp         r0, #0
  00034	1a000006	 bne         |$LN1@WaitThread|

; 102  :             {
; 103  :                 // thread dead
; 104  :                 ::CloseHandle( m_hThreadHandle );

  00038	e5940008	 ldr         r0, [r4, #8]
  0003c	eb000000	 bl          CloseHandle

; 105  :                 m_hThreadHandle = NULL;

  00040	e3a03000	 mov         r3, #0
  00044	e5843008	 str         r3, [r4, #8]

; 106  :                 return TRUE;

  00048	e3a00001	 mov         r0, #1

; 110  :     }

  0004c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$LN1@WaitThread|

; 107  :             }
; 108  :         }
; 109  :         return FALSE;

  00054	e3a00000	 mov         r0, #0

; 110  :     }

  00058	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$M42659|

			 ENDP  ; |?WaitThreadComplete@CMiniThread@@QAAHK@Z|, CMiniThread::WaitThreadComplete

	EXPORT	|?ForceTerminated@CMiniThread@@QAAHXZ|	; CMiniThread::ForceTerminated
	IMPORT	|TerminateThread|

  00000			 AREA	 |.pdata|, PDATA
|$T42672| DCD	|$LN6@ForceTermi|
	DCD	0x40001401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ForceTerminated@CMiniThread@@QAAHXZ| PROC ; CMiniThread::ForceTerminated

; 113  :     {

  00000		 |$LN6@ForceTermi|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M42669|
  00004	e1a05000	 mov         r5, r0

; 114  :         if( m_hThreadHandle )

  00008	e5953008	 ldr         r3, [r5, #8]
  0000c	e3530000	 cmp         r3, #0
  00010	0a00000a	 beq         |$LN1@ForceTermi|

; 115  :         {
; 116  : //#pragma prefast(suppress: 258, "Try to recover from a pathological failure")
; 117  :             BOOL bReturn = ::TerminateThread( m_hThreadHandle, ( DWORD ) - 1 ); // terminate abnormal

  00014	e3e06000	 mvn         r6, #0
  00018	e1a01006	 mov         r1, r6
  0001c	e1a00003	 mov         r0, r3
  00020	eb000000	 bl          TerminateThread
  00024	e1a04000	 mov         r4, r0

; 118  :             m_dwExitCode = -1;
; 119  :             ::CloseHandle( m_hThreadHandle );

  00028	e5950008	 ldr         r0, [r5, #8]
  0002c	e5856014	 str         r6, [r5, #0x14]
  00030	eb000000	 bl          CloseHandle

; 120  :             m_hThreadHandle = NULL;

  00034	e3a03000	 mov         r3, #0
  00038	e5853008	 str         r3, [r5, #8]

; 121  :             return bReturn;

  0003c	ea000000	 b           |$LN2@ForceTermi|
  00040		 |$LN1@ForceTermi|

; 122  :         };
; 123  :         return TRUE;

  00040	e3a04001	 mov         r4, #1
  00044		 |$LN2@ForceTermi|

; 124  :     }

  00044	e1a00004	 mov         r0, r4
  00048	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M42670|

			 ENDP  ; |?ForceTerminated@CMiniThread@@QAAHXZ|, CMiniThread::ForceTerminated

	EXPORT	|?ThreadProc@CMiniThread@@CAKPAX@Z|	; CMiniThread::ThreadProc
	IMPORT	|ExitThread|

  00000			 AREA	 |.pdata|, PDATA
|$T42682| DCD	|$LN5@ThreadProc|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ThreadProc@CMiniThread@@CAKPAX@Z| PROC ; CMiniThread::ThreadProc

; 154  :     {

  00000		 |$LN5@ThreadProc|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M42679|
  00004	e1a04000	 mov         r4, r0

; 155  :         CMiniThread* pThreadPtr = ( CMiniThread* ) dParam;
; 156  :         pThreadPtr->m_dwExitCode = pThreadPtr->ThreadRun();

  00008	e5943000	 ldr         r3, [r4]
  0000c	e5933000	 ldr         r3, [r3]
  00010	e1a0e00f	 mov         lr, pc
  00014	e12fff13	 bx          r3
  00018	e1a03000	 mov         r3, r0

; 157  :         ::ExitThread( pThreadPtr->m_dwExitCode );

  0001c	e5843014	 str         r3, [r4, #0x14]
  00020	eb000000	 bl          ExitThread

; 158  :         return pThreadPtr->m_dwExitCode;

  00024	e5940014	 ldr         r0, [r4, #0x14]

; 159  :     };

  00028	e8bd4010	 ldmia       sp!, {r4, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$M42680|

			 ENDP  ; |?ThreadProc@CMiniThread@@CAKPAX@Z|, CMiniThread::ThreadProc

	EXPORT	|?GetHsMusb@OMAPMHSUSBOTG@@QAAPAUHSMUSB_T@@XZ| ; OMAPMHSUSBOTG::GetHsMusb
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbotg\otg.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T42692| DCD	|$LN5@GetHsMusb|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetHsMusb@OMAPMHSUSBOTG@@QAAPAUHSMUSB_T@@XZ| PROC ; OMAPMHSUSBOTG::GetHsMusb

; 111  :     PHSMUSB_T GetHsMusb() { return m_pOTG;};

  00000		 |$LN5@GetHsMusb|
  00000		 |$M42689|
  00000	e5900150	 ldr         r0, [r0, #0x150]
  00004	e12fff1e	 bx          lr
  00008		 |$M42690|

			 ENDP  ; |?GetHsMusb@OMAPMHSUSBOTG@@QAAPAUHSMUSB_T@@XZ|, OMAPMHSUSBOTG::GetHsMusb

	EXPORT	|??0OMAPMHSUsbClientDeviceFolder@@QAA@KPBG0KKKKPAXK0@Z| ; OMAPMHSUsbClientDeviceFolder::OMAPMHSUsbClientDeviceFolder
	EXPORT	|??_7OMAPMHSUsbClientDeviceFolder@@6B@| [ DATA ] ; OMAPMHSUsbClientDeviceFolder::`vftable'
	EXPORT	|?Init@DeviceFolder@@UAAHXZ|		; DeviceFolder::Init
	EXPORT	|?LoadDevice@OMAPMHSUsbClientDeviceFolder@@UAAHXZ| ; OMAPMHSUsbClientDeviceFolder::LoadDevice
	EXPORT	|?UnloadDevice@OMAPMHSUsbClientDeviceFolder@@UAAHXZ| ; OMAPMHSUsbClientDeviceFolder::UnloadDevice
	EXPORT	|?SetPowerState@OMAPMHSUsbClientDeviceFolder@@UAAHW4_CEDEVICE_POWER_STATE@@@Z| ; OMAPMHSUsbClientDeviceFolder::SetPowerState
	EXPORT	|?GetPowerState@DeviceFolder@@UAA?AW4_CEDEVICE_POWER_STATE@@XZ| ; DeviceFolder::GetPowerState
	IMPORT	|??0DeviceFolder@@QAA@PBG0KKKKPAXK0@Z|	; DeviceFolder::DeviceFolder
	IMPORT	|??_EOMAPMHSUsbClientDeviceFolder@@UAAPAXI@Z|, WEAK |??_GOMAPMHSUsbClientDeviceFolder@@UAAPAXI@Z| ; OMAPMHSUsbClientDeviceFolder::`vector deleting destructor', OMAPMHSUsbClientDeviceFolder::`scalar deleting destructor'
	IMPORT	|?SetConfigurationData@DeviceFolder@@UAAHPAU_CE_BUS_DEVICE_CONFIGURATION_DATA@@@Z| ; DeviceFolder::SetConfigurationData
	IMPORT	|?GetConfigurationData@DeviceFolder@@UAAHPAU_CE_BUS_DEVICE_CONFIGURATION_DATA@@@Z| ; DeviceFolder::GetConfigurationData

  00000			 AREA	 |.pdata|, PDATA
|$T42705| DCD	|$LN5@OMAPMHSUsb|
	DCD	0x40001f02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7OMAPMHSUsbClientDeviceFolder@@6B@| DCD |??_EOMAPMHSUsbClientDeviceFolder@@UAAPAXI@Z| ; OMAPMHSUsbClientDeviceFolder::`vftable'
	DCD	|?Init@DeviceFolder@@UAAHXZ|
	DCD	|?LoadDevice@OMAPMHSUsbClientDeviceFolder@@UAAHXZ|
	DCD	|?UnloadDevice@OMAPMHSUsbClientDeviceFolder@@UAAHXZ|
	DCD	|?SetPowerState@OMAPMHSUsbClientDeviceFolder@@UAAHW4_CEDEVICE_POWER_STATE@@@Z|
	DCD	|?GetPowerState@DeviceFolder@@UAA?AW4_CEDEVICE_POWER_STATE@@XZ|
	DCD	|?SetConfigurationData@DeviceFolder@@UAAHPAU_CE_BUS_DEVICE_CONFIGURATION_DATA@@@Z|
	DCD	|?GetConfigurationData@DeviceFolder@@UAAHPAU_CE_BUS_DEVICE_CONFIGURATION_DATA@@@Z|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0OMAPMHSUsbClientDeviceFolder@@QAA@KPBG0KKKKPAXK0@Z| PROC ; OMAPMHSUsbClientDeviceFolder::OMAPMHSUsbClientDeviceFolder

; 195  :     {

  00000		 |$LN5@OMAPMHSUsb|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd01c	 sub         sp, sp, #0x1C
  00008		 |$M42702|
  00008	e1a09003	 mov         r9, r3
  0000c	e1a0a002	 mov         r10, r2
  00010	e1a0b001	 mov         r11, r1
  00014	e58d0018	 str         r0, [sp, #0x18]
  00018	e59d4054	 ldr         r4, [sp, #0x54]
  0001c	e59de058	 ldr         lr, [sp, #0x58]
  00020	e59d5050	 ldr         r5, [sp, #0x50]
  00024	e59d604c	 ldr         r6, [sp, #0x4C]
  00028	e59d7048	 ldr         r7, [sp, #0x48]
  0002c	e59d8044	 ldr         r8, [sp, #0x44]
  00030	e59d3040	 ldr         r3, [sp, #0x40]
  00034	e58d4010	 str         r4, [sp, #0x10]
  00038	e1a02009	 mov         r2, r9
  0003c	e1a0100a	 mov         r1, r10
  00040	e1a04000	 mov         r4, r0
  00044	e58de014	 str         lr, [sp, #0x14]
  00048	e58d500c	 str         r5, [sp, #0xC]
  0004c	e58d6008	 str         r6, [sp, #8]
  00050	e58d7004	 str         r7, [sp, #4]
  00054	e58d8000	 str         r8, [sp]
  00058	eb000000	 bl          |??0DeviceFolder@@QAA@PBG0KKKKPAXK0@Z|
  0005c	e59f3014	 ldr         r3, [pc, #0x14]
  00060	e584b060	 str         r11, [r4, #0x60]

; 196  :         DEBUGMSG(1, (TEXT("OMAPMHSUsbClientDeviceFolder(%s, %s, 0x%x, %d, %d, %d ...\r\n"),
; 197  :             lpBusName, lpTemplateRegPath, dwBusType, BusNumber, DeviceNumber, FunctionNumber));
; 198  :     };

  00064	e1a00004	 mov         r0, r4
  00068	e5843000	 str         r3, [r4]
  0006c	e28dd01c	 add         sp, sp, #0x1C
  00070	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00074	e12fff1e	 bx          lr
  00078		 |$LN6@OMAPMHSUsb|
  00078		 |$LN7@OMAPMHSUsb|
  00078	00000000	 DCD         |??_7OMAPMHSUsbClientDeviceFolder@@6B@|
  0007c		 |$M42703|

			 ENDP  ; |??0OMAPMHSUsbClientDeviceFolder@@QAA@KPBG0KKKKPAXK0@Z|, OMAPMHSUsbClientDeviceFolder::OMAPMHSUsbClientDeviceFolder

	EXPORT	|?Lock@CLockObject@@QAAXXZ|		; CLockObject::Lock
	IMPORT	|EnterCriticalSection|
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T42715| DCD	|$LN5@Lock|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Lock@CLockObject@@QAAXXZ| PROC	; CLockObject::Lock

; 45   :     {

  00000		 |$LN5@Lock|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42712|

; 46   :         EnterCriticalSection( &m_CSection );

  00004	eb000000	 bl          EnterCriticalSection

; 47   :     };

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M42713|

			 ENDP  ; |?Lock@CLockObject@@QAAXXZ|, CLockObject::Lock

	EXPORT	|?Unlock@CLockObject@@QAAXXZ|		; CLockObject::Unlock
	IMPORT	|LeaveCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T42723| DCD	|$LN5@Unlock|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Unlock@CLockObject@@QAAXXZ| PROC	; CLockObject::Unlock

; 49   :     {

  00000		 |$LN5@Unlock|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42720|

; 50   :         LeaveCriticalSection( &m_CSection );

  00004	eb000000	 bl          LeaveCriticalSection

; 51   :     };

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M42721|

			 ENDP  ; |?Unlock@CLockObject@@QAAXXZ|, CLockObject::Unlock

; File c:\wince600\public\common\oak\inc\defbus.h

  00000			 AREA	 |.pdata|, PDATA
|$T42735| DCD	|$LN7@Init|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Init@DeviceFolder@@UAAHXZ| PROC	; DeviceFolder::Init

; 78   :     virtual BOOL Init() { return (m_dwInitRegArray != NULL); }

  00000		 |$LN7@Init|
  00000		 |$M42732|
  00000	e590304c	 ldr         r3, [r0, #0x4C]
  00004	e3530000	 cmp         r3, #0
  00008	13a00001	 movne       r0, #1
  0000c	03a00000	 moveq       r0, #0
  00010	e12fff1e	 bx          lr
  00014		 |$M42733|

			 ENDP  ; |?Init@DeviceFolder@@UAAHXZ|, DeviceFolder::Init


  00000			 AREA	 |.pdata|, PDATA
|$T42745| DCD	|$LN5@GetPowerSt|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetPowerState@DeviceFolder@@UAA?AW4_CEDEVICE_POWER_STATE@@XZ| PROC ; DeviceFolder::GetPowerState

; 93   :     virtual CEDEVICE_POWER_STATE  GetPowerState() { return m_CurPowerState; };

  00000		 |$LN5@GetPowerSt|
  00000		 |$M42742|
  00000	e5900020	 ldr         r0, [r0, #0x20]
  00004	e12fff1e	 bx          lr
  00008		 |$M42743|

			 ENDP  ; |?GetPowerState@DeviceFolder@@UAA?AW4_CEDEVICE_POWER_STATE@@XZ|, DeviceFolder::GetPowerState

	IMPORT	|?LoadDevice@DeviceFolder@@UAAHXZ|	; DeviceFolder::LoadDevice
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbotg\otg.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T42756| DCD	|$LN6@LoadDevice|
	DCD	0x40001301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?LoadDevice@OMAPMHSUsbClientDeviceFolder@@UAAHXZ| PROC ; OMAPMHSUsbClientDeviceFolder::LoadDevice

; 206  :     {

  00000		 |$LN6@LoadDevice|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M42753|
  00004	e1a04000	 mov         r4, r0

; 207  :         SetPowerState(D0);

  00008	e5943000	 ldr         r3, [r4]
  0000c	e3a01000	 mov         r1, #0
  00010	e5933010	 ldr         r3, [r3, #0x10]
  00014	e1a0e00f	 mov         lr, pc
  00018	e12fff13	 bx          r3

; 208  :         BOOL bReturn = DeviceFolder::LoadDevice();

  0001c	e1a00004	 mov         r0, r4
  00020	eb000000	 bl          |?LoadDevice@DeviceFolder@@UAAHXZ|
  00024	e1b05000	 movs        r5, r0

; 209  :         if (!bReturn) 
; 210  :         { 
; 211  :             // Loading Fails
; 212  :             SetPowerState(D4);

  00028	05943000	 ldreq       r3, [r4]
  0002c	03a01004	 moveq       r1, #4
  00030	01a00004	 moveq       r0, r4
  00034	05933010	 ldreq       r3, [r3, #0x10]
  00038	01a0e00f	 moveq       lr, pc
  0003c	012fff13	 bxeq        r3

; 213  :         }
; 214  :         return bReturn;
; 215  :     }

  00040	e1a00005	 mov         r0, r5
  00044	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00048	e12fff1e	 bx          lr
  0004c		 |$M42754|

			 ENDP  ; |?LoadDevice@OMAPMHSUsbClientDeviceFolder@@UAAHXZ|, OMAPMHSUsbClientDeviceFolder::LoadDevice

	IMPORT	|?UnloadDevice@DeviceFolder@@UAAHXZ|	; DeviceFolder::UnloadDevice

  00000			 AREA	 |.pdata|, PDATA
|$T42767| DCD	|$LN6@UnloadDevi|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UnloadDevice@OMAPMHSUsbClientDeviceFolder@@UAAHXZ| PROC ; OMAPMHSUsbClientDeviceFolder::UnloadDevice

; 218  :     {

  00000		 |$LN6@UnloadDevi|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M42764|
  00004	e1a05000	 mov         r5, r0

; 219  :         BOOL bReturn = DeviceFolder::UnloadDevice();

  00008	eb000000	 bl          |?UnloadDevice@DeviceFolder@@UAAHXZ|
  0000c	e1b04000	 movs        r4, r0

; 220  :         if (bReturn) 
; 221  :         { 
; 222  :             // Unloading Success.
; 223  :             SetPowerState(D4);

  00010	15953000	 ldrne       r3, [r5]
  00014	13a01004	 movne       r1, #4
  00018	11a00005	 movne       r0, r5
  0001c	15933010	 ldrne       r3, [r3, #0x10]
  00020	11a0e00f	 movne       lr, pc
  00024	112fff13	 bxne        r3

; 224  :         }
; 225  :         return bReturn;
; 226  :     }

  00028	e1a00004	 mov         r0, r4
  0002c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00030	e12fff1e	 bx          lr
  00034		 |$M42765|

			 ENDP  ; |?UnloadDevice@OMAPMHSUsbClientDeviceFolder@@UAAHXZ|, OMAPMHSUsbClientDeviceFolder::UnloadDevice

; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T42784| DCD	|$LN15@SetPowerSt|
	DCD	0x40000b01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbotg\otg.hpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetPowerState@OMAPMHSUsbClientDeviceFolder@@UAAHW4_CEDEVICE_POWER_STATE@@@Z| PROC ; OMAPMHSUsbClientDeviceFolder::SetPowerState

; 229  :     {

  00000		 |$LN15@SetPowerSt|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M42781|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 230  :         Lock();

  0000c	e284000c	 add         r0, r4, #0xC
  00010	eb000000	 bl          EnterCriticalSection

; 231  :         m_CurPowerState = newPowerState;
; 232  :         // Should put device into idle according to m_dwDevicePhysAddr
; 233  :         switch (m_CurPowerState) {
; 234  :         case D0:
; 235  :         case D1:
; 236  :         case D2:
; 237  :             // We may want to disable host or function idle.
; 238  :             break;
; 239  :         }
; 240  : 
; 241  :         switch (m_CurPowerState) {
; 242  :         case D3:
; 243  :         case D4:
; 244  :             // We may want to enable USB function idle.
; 245  :             break;
; 246  :         }
; 247  :         Unlock();

  00014	e284000c	 add         r0, r4, #0xC
  00018	e5845020	 str         r5, [r4, #0x20]
  0001c	eb000000	 bl          LeaveCriticalSection

; 248  :         return TRUE;

  00020	e3a00001	 mov         r0, #1

; 249  :     }

  00024	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$M42782|

			 ENDP  ; |?SetPowerState@OMAPMHSUsbClientDeviceFolder@@UAAHW4_CEDEVICE_POWER_STATE@@@Z|, OMAPMHSUsbClientDeviceFolder::SetPowerState

	IMPORT	|SetDevicePowerState|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbotg\otg.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T42793| DCD	|$LN6@UpdateDevi|
	DCD	0x40000b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdateDevicePower@@YAXPAXW4_CEDEVICE_POWER_STATE@@0@Z| PROC ; UpdateDevicePower

; 136  : {

  00000		 |$LN6@UpdateDevi|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M42790|
  00004	e1a0e001	 mov         lr, r1

; 137  : 	UNREFERENCED_PARAMETER(pvoid);
; 138  : 
; 139  :     if (g_busDx == reqDx)

  00008	e59f4018	 ldr         r4, [pc, #0x18]
  0000c	e5943000	 ldr         r3, [r4]
  00010	e153000e	 cmp         r3, lr

; 140  :         return;
; 141  :     g_busDx = reqDx;
; 142  :     SetDevicePowerState(hBus, g_busDx, NULL);

  00014	13a02000	 movne       r2, #0
  00018	1584e000	 strne       lr, [r4]
  0001c	1b000000	 blne        SetDevicePowerState

; 143  : }

  00020	e8bd4010	 ldmia       sp!, {r4, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$LN7@UpdateDevi|
  00028		 |$LN8@UpdateDevi|
  00028	00000000	 DCD         |?g_busDx@@3W4_CEDEVICE_POWER_STATE@@A|
  0002c		 |$M42791|

			 ENDP  ; |?UpdateDevicePower@@YAXPAXW4_CEDEVICE_POWER_STATE@@0@Z|, UpdateDevicePower

	EXPORT	|?DeleteUSBOTGObject@@YAXPAVUSBOTG@@@Z|	; DeleteUSBOTGObject

  00000			 AREA	 |.pdata|, PDATA
|$T42807| DCD	|$LN8@DeleteUSBO|
	DCD	0x40000901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DeleteUSBOTGObject@@YAXPAVUSBOTG@@@Z| PROC ; DeleteUSBOTGObject

; 194  : {

  00000		 |$LN8@DeleteUSBO|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42804|
  00004	e3500000	 cmp         r0, #0

; 195  :     if (pUsbOtg)
; 196  :         delete pUsbOtg;

  00008	15903000	 ldrne       r3, [r0]
  0000c	13a01001	 movne       r1, #1
  00010	15933008	 ldrne       r3, [r3, #8]
  00014	11a0e00f	 movne       lr, pc
  00018	112fff13	 bxne        r3

; 197  : }

  0001c	e49de004	 ldr         lr, [sp], #4
  00020	e12fff1e	 bx          lr
  00024		 |$M42805|

			 ENDP  ; |?DeleteUSBOTGObject@@YAXPAVUSBOTG@@@Z|, DeleteUSBOTGObject

	EXPORT	|?Init@OMAPMHSUSBIdGnd@@UAAHXZ|		; OMAPMHSUSBIdGnd::Init

  00000			 AREA	 |.pdata|, PDATA
|$T42817| DCD	|$LN5@Init@2|
	DCD	0x40000701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Init@OMAPMHSUSBIdGnd@@UAAHXZ| PROC	; OMAPMHSUSBIdGnd::Init

; 222  : {    

  00000		 |$LN5@Init@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42814|

; 223  :     m_fTerminated = FALSE;

  00004	e3a03000	 mov         r3, #0
  00008	e5803034	 str         r3, [r0, #0x34]

; 224  :     ThreadStart() ;    

  0000c	eb000000	 bl          |?ThreadStart@CMiniThread@@QAAHXZ|

; 225  :     return TRUE;

  00010	e3a00001	 mov         r0, #1

; 226  :     
; 227  : }

  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$M42815|

			 ENDP  ; |?Init@OMAPMHSUSBIdGnd@@UAAHXZ|, OMAPMHSUSBIdGnd::Init

	EXPORT	|?ThreadRun@OMAPMHSUSBIdGnd@@EAAKXZ|	; OMAPMHSUSBIdGnd::ThreadRun
	IMPORT	|CeSetThreadPriority|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T42840| DCD	|$LN16@ThreadRun|
	DCD	0x40002401
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbotg\otg.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ThreadRun@OMAPMHSUSBIdGnd@@EAAKXZ| PROC ; OMAPMHSUSBIdGnd::ThreadRun

; 230  : {

  00000		 |$LN16@ThreadRun|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M42837|
  00004	e1a04000	 mov         r4, r0

; 231  :     
; 232  :     PHSMUSB_T pOTG = m_pUsbOtg->GetHsMusb();    

  00008	e594302c	 ldr         r3, [r4, #0x2C]

; 233  : 
; 234  :     m_pUsbOtg->m_pTransceiver->AconnNotifHandle(m_hIdGndIntrEvent);

  0000c	e5941030	 ldr         r1, [r4, #0x30]
  00010	e59300fc	 ldr         r0, [r3, #0xFC]
  00014	e5935150	 ldr         r5, [r3, #0x150]
  00018	e5903000	 ldr         r3, [r0]
  0001c	e593300c	 ldr         r3, [r3, #0xC]
  00020	e1a0e00f	 mov         lr, pc
  00024	e12fff13	 bx          r3

; 235  :     
; 236  :     CeSetThreadPriority(GetCurrentThread(), m_pUsbOtg->m_OTGRegCfg.idgndIstPrio);

  00028	e594302c	 ldr         r3, [r4, #0x2C]
  0002c	e3a00041	 mov         r0, #0x41
  00030	e5931118	 ldr         r1, [r3, #0x118]
  00034	eb000000	 bl          CeSetThreadPriority

; 237  : 
; 238  :     while (!m_fTerminated)

  00038	e5943034	 ldr         r3, [r4, #0x34]
  0003c	e3530000	 cmp         r3, #0
  00040	1a00000f	 bne         |$LN3@ThreadRun|
  00044	e3a06001	 mov         r6, #1
  00048		 |$LL4@ThreadRun|

; 239  :     { 
; 240  :         DWORD rc = WaitForSingleObject(m_hIdGndIntrEvent, INFINITE);         

  00048	e5940030	 ldr         r0, [r4, #0x30]
  0004c	e3e01000	 mvn         r1, #0
  00050	eb000000	 bl          WaitForSingleObject
  00054	e3500000	 cmp         r0, #0

; 241  :         if (rc != WAIT_OBJECT_0)
; 242  :         {
; 243  :             DEBUGMSG(ZONE_OTG_ERROR, (TEXT("Something wrong with IdGndIntrEvent\r\n")));
; 244  :             m_fTerminated = TRUE;
; 245  :         }
; 246  :         else
; 247  :         {                 
; 248  :             DEBUGMSG(ZONE_OTG_FUNCTION,(L"***### OMAPMHSUSBIdGnd::ThreadRun calling SessionRequest")); 
; 249  :             m_pUsbOtg->m_dwStatus |= STATUS_RETENTION_WAKEUP;

  00058	0594202c	 ldreq       r2, [r4, #0x2C]
  0005c	15846034	 strne       r6, [r4, #0x34]

; 250  :             SetEvent(pOTG->hSysIntrEvent);

  00060	03a01003	 moveq       r1, #3
  00064	059230f8	 ldreq       r3, [r2, #0xF8]
  00068	03833c01	 orreq       r3, r3, #1, 24
  0006c	058230f8	 streq       r3, [r2, #0xF8]
  00070	05950054	 ldreq       r0, [r5, #0x54]
  00074	0b000000	 bleq        EventModify
  00078	e5943034	 ldr         r3, [r4, #0x34]
  0007c	e3530000	 cmp         r3, #0
  00080	0afffff0	 beq         |$LL4@ThreadRun|
  00084		 |$LN3@ThreadRun|

; 251  :        }
; 252  :     }
; 253  :     return 1;

  00084	e3a00001	 mov         r0, #1

; 254  : }

  00088	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0008c	e12fff1e	 bx          lr
  00090		 |$M42838|

			 ENDP  ; |?ThreadRun@OMAPMHSUSBIdGnd@@EAAKXZ|, OMAPMHSUSBIdGnd::ThreadRun

	EXPORT	|?Init@OMAPMHSUSBDMA@@UAAHXZ|		; OMAPMHSUSBDMA::Init

  00000			 AREA	 |.pdata|, PDATA
|$T42850| DCD	|$LN5@Init@3|
	DCD	0x40000701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Init@OMAPMHSUSBDMA@@UAAHXZ| PROC	; OMAPMHSUSBDMA::Init

; 302  : {

  00000		 |$LN5@Init@3|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42847|

; 303  :     m_fTerminated = FALSE;

  00004	e3a03000	 mov         r3, #0
  00008	e580302c	 str         r3, [r0, #0x2C]

; 304  :     ThreadStart() ;    

  0000c	eb000000	 bl          |?ThreadStart@CMiniThread@@QAAHXZ|

; 305  :     return TRUE;

  00010	e3a00001	 mov         r0, #1

; 306  :     
; 307  : }

  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$M42848|

			 ENDP  ; |?Init@OMAPMHSUSBDMA@@UAAHXZ|, OMAPMHSUSBDMA::Init

	EXPORT	|?ThreadRun@OMAPMHSUSBDMA@@EAAKXZ|	; OMAPMHSUSBDMA::ThreadRun
	EXPORT	|??_C@_1EO@DBJAPFDC@?$AAO?$AAT?$AAG?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AAR?$AAu?$AAn?$AA?5?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAR?$AAE@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FA@FFEGOOFC@?$AAO?$AAT?$AAG?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AAR?$AAu?$AAn?$AA?5?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAS?$AAU@| [ DATA ] ; `string'
	IMPORT	|InterruptDone|
	IMPORT	|Sleep|
	IMPORT	|NKDbgPrintfW|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbotg\otg.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T42881| DCD	|$LN33@ThreadRun@2|
	DCD	0x40004a01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EO@DBJAPFDC@?$AAO?$AAT?$AAG?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AAR?$AAu?$AAn?$AA?5?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAR?$AAE@| DCB "O"
	DCB	0x0, "T", 0x0, "G", 0x0, " ", 0x0, "D", 0x0, "M", 0x0, "A"
	DCB	0x0, " ", 0x0, "T", 0x0, "h", 0x0, "r", 0x0, "e", 0x0, "a"
	DCB	0x0, "d", 0x0, "R", 0x0, "u", 0x0, "n", 0x0, " ", 0x0, "M"
	DCB	0x0, "O", 0x0, "D", 0x0, "E", 0x0, "_", 0x0, "S", 0x0, "Y"
	DCB	0x0, "S", 0x0, "T", 0x0, "E", 0x0, "M", 0x0, "_", 0x0, "R"
	DCB	0x0, "E", 0x0, "S", 0x0, "U", 0x0, "M", 0x0, "E", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FA@FFEGOOFC@?$AAO?$AAT?$AAG?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AAR?$AAu?$AAn?$AA?5?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAS?$AAU@| DCB "O"
	DCB	0x0, "T", 0x0, "G", 0x0, " ", 0x0, "D", 0x0, "M", 0x0, "A"
	DCB	0x0, " ", 0x0, "T", 0x0, "h", 0x0, "r", 0x0, "e", 0x0, "a"
	DCB	0x0, "d", 0x0, "R", 0x0, "u", 0x0, "n", 0x0, " ", 0x0, "M"
	DCB	0x0, "O", 0x0, "D", 0x0, "E", 0x0, "_", 0x0, "S", 0x0, "Y"
	DCB	0x0, "S", 0x0, "T", 0x0, "E", 0x0, "M", 0x0, "_", 0x0, "S"
	DCB	0x0, "U", 0x0, "S", 0x0, "P", 0x0, "E", 0x0, "N", 0x0, "D"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbotg\otg.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ThreadRun@OMAPMHSUSBDMA@@EAAKXZ| PROC ; OMAPMHSUSBDMA::ThreadRun

; 310  : {    

  00000		 |$LN33@ThreadRun@2|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M42878|
  00004	e1a04000	 mov         r4, r0

; 311  :     CeSetThreadPriority(GetCurrentThread(), m_pUsbOtg->m_OTGRegCfg.dmaIstPrio);

  00008	e5943030	 ldr         r3, [r4, #0x30]
  0000c	e3a00041	 mov         r0, #0x41
  00010	e5931120	 ldr         r1, [r3, #0x120]
  00014	eb000000	 bl          CeSetThreadPriority

; 312  : 
; 313  :     while (!m_fTerminated)

  00018	e594302c	 ldr         r3, [r4, #0x2C]
  0001c	e3530000	 cmp         r3, #0
  00020	1a00003b	 bne         |$LN12@ThreadRun@2|
  00024	e3a08001	 mov         r8, #1
  00028	e3a09001	 mov         r9, #1
  0002c		 |$LL13@ThreadRun@2|

; 314  :     {
; 315  :         DWORD rc = WaitForSingleObject(m_hDMAIntrEvent, INFINITE);         

  0002c	e5940034	 ldr         r0, [r4, #0x34]
  00030	e3e01000	 mvn         r1, #0
  00034	eb000000	 bl          WaitForSingleObject
  00038	e3500000	 cmp         r0, #0

; 316  :         if (rc != WAIT_OBJECT_0)
; 317  :         {
; 318  :             DEBUGMSG(ZONE_OTG_ERROR, (TEXT("Something wrong with DMA IntrEvent\r\n")));
; 319  :             m_fTerminated = TRUE;

  0003c	1584802c	 strne       r8, [r4, #0x2C]
  00040	1a00002e	 bne         |$LN6@ThreadRun@2|

; 320  :         }
; 321  :         else
; 322  :         {
; 323  :             PHSMUSB_T pOTG = m_pUsbOtg->GetHsMusb();

  00044	e5943030	 ldr         r3, [r4, #0x30]
  00048	e5936150	 ldr         r6, [r3, #0x150]

; 324  :             DWORD reg = INREG32(&pOTG->pUsbDmaRegs->Intr);

  0004c	e5963024	 ldr         r3, [r6, #0x24]

; 325  : 
; 326  :             if (pOTG->dwPwrMgmt == MODE_SYSTEM_SUSPEND)

  00050	e5962064	 ldr         r2, [r6, #0x64]
  00054	e5937000	 ldr         r7, [r3]
  00058	e3520001	 cmp         r2, #1
  0005c	1a000004	 bne         |$LN9@ThreadRun@2|

; 327  : 			{
; 328  : 	            RETAILMSG(1, (L"OTG DMA ThreadRun MODE_SYSTEM_SUSPEND\r\n"));

  00060	e59f00bc	 ldr         r0, [pc, #0xBC]
  00064		 |$LN30@ThreadRun@2|
  00064	eb000000	 bl          NKDbgPrintfW

; 329  :                 Sleep(100);

  00068	e3a00064	 mov         r0, #0x64
  0006c	eb000000	 bl          Sleep

; 330  : 			    continue;

  00070	ea000024	 b           |$LN29@ThreadRun@2|
  00074		 |$LN9@ThreadRun@2|

; 331  : 			}
; 332  : 
; 333  : 	        if (pOTG->dwPwrMgmt == MODE_SYSTEM_RESUME)

  00074	e3520002	 cmp         r2, #2

; 334  : 			{
; 335  : 	            RETAILMSG(1, (L"OTG DMA ThreadRun MODE_SYSTEM_RESUME\r\n"));

  00078	059f00a0	 ldreq       r0, [pc, #0xA0]
  0007c	0afffff8	 beq         |$LN30@ThreadRun@2|

; 336  :                 Sleep(100);
; 337  : 			    continue;
; 338  : 			}
; 339  : 
; 340  :             int i = 0;

  00080	e3a05000	 mov         r5, #0
  00084		 |$LL7@ThreadRun@2|

; 341  :             //Read the Interrupt Register and see
; 342  :             DEBUGMSG(ZONE_OTG_INFO, (TEXT("DMA Interrupt Register = 0x%x\r\n"),reg));
; 343  :             while (i < MAX_DMA_CHANNEL)
; 344  :             {
; 345  :                 if (reg & INTR_CH(i))

  00084	e1170519	 tst         r7, r9, lsl r5
  00088	0a000019	 beq         |$LN2@ThreadRun@2|

; 346  :                 {
; 347  :                     if (m_pUsbOtg->GetMode() == HOST_MODE)

  0008c	e5940030	 ldr         r0, [r4, #0x30]
  00090	e5903000	 ldr         r3, [r0]
  00094	e59330e0	 ldr         r3, [r3, #0xE0]
  00098	e1a0e00f	 mov         lr, pc
  0009c	e12fff13	 bx          r3
  000a0	e3500002	 cmp         r0, #2
  000a4	1a000006	 bne         |$LN4@ThreadRun@2|

; 348  :                         pOTG->pFuncs[HOST_MODE-1]->ProcessDMA(pOTG, (UCHAR)i);

  000a8	e596300c	 ldr         r3, [r6, #0xC]
  000ac	e20510ff	 and         r1, r5, #0xFF
  000b0	e1a00006	 mov         r0, r6
  000b4	e5933020	 ldr         r3, [r3, #0x20]
  000b8	e1a0e00f	 mov         lr, pc
  000bc	e12fff13	 bx          r3
  000c0	ea00000b	 b           |$LN2@ThreadRun@2|
  000c4		 |$LN4@ThreadRun@2|

; 349  :                     else if (m_pUsbOtg->GetMode() == DEVICE_MODE)

  000c4	e5940030	 ldr         r0, [r4, #0x30]
  000c8	e5903000	 ldr         r3, [r0]
  000cc	e59330e0	 ldr         r3, [r3, #0xE0]
  000d0	e1a0e00f	 mov         lr, pc
  000d4	e12fff13	 bx          r3
  000d8	e3500001	 cmp         r0, #1

; 350  :                         pOTG->pFuncs[DEVICE_MODE-1]->ProcessDMA(pOTG, (UCHAR)i);

  000dc	05963008	 ldreq       r3, [r6, #8]
  000e0	020510ff	 andeq       r1, r5, #0xFF
  000e4	01a00006	 moveq       r0, r6
  000e8	05933020	 ldreq       r3, [r3, #0x20]
  000ec	01a0e00f	 moveq       lr, pc
  000f0	012fff13	 bxeq        r3
  000f4		 |$LN2@ThreadRun@2|

; 351  :                     else
; 352  :                     {
; 353  :                         DEBUGMSG(ZONE_OTG_INFO, (TEXT("Ignore DMA channel %d interrupt\r\n"), i));
; 354  :                     }
; 355  :                 }
; 356  :                 i++;

  000f4	e2855001	 add         r5, r5, #1
  000f8	e3550008	 cmp         r5, #8
  000fc	baffffe0	 blt         |$LL7@ThreadRun@2|
  00100		 |$LN6@ThreadRun@2|

; 357  :             }
; 358  :         }
; 359  :         InterruptDone(m_dwDMASysIntr);

  00100	e5940038	 ldr         r0, [r4, #0x38]
  00104	eb000000	 bl          InterruptDone
  00108		 |$LN29@ThreadRun@2|
  00108	e594302c	 ldr         r3, [r4, #0x2C]
  0010c	e3530000	 cmp         r3, #0
  00110	0affffc5	 beq         |$LL13@ThreadRun@2|
  00114		 |$LN12@ThreadRun@2|

; 360  :     }
; 361  :     return 1;

  00114	e3a00001	 mov         r0, #1

; 362  : }

  00118	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  0011c	e12fff1e	 bx          lr
  00120		 |$LN34@ThreadRun@2|
  00120		 |$LN35@ThreadRun@2|
  00120	00000000	 DCD         |??_C@_1EO@DBJAPFDC@?$AAO?$AAT?$AAG?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AAR?$AAu?$AAn?$AA?5?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAR?$AAE@|
  00124		 |$LN36@ThreadRun@2|
  00124	00000000	 DCD         |??_C@_1FA@FFEGOOFC@?$AAO?$AAT?$AAG?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AAR?$AAu?$AAn?$AA?5?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAS?$AAU@|
  00128		 |$M42879|

			 ENDP  ; |?ThreadRun@OMAPMHSUSBDMA@@EAAKXZ|, OMAPMHSUSBDMA::ThreadRun

	EXPORT	|?PostInit@OMAPMHSUSBOTG@@UAAHXZ|	; OMAPMHSUSBOTG::PostInit
	IMPORT	|?PostInit@USBOTG@@UAAHXZ|		; USBOTG::PostInit

  00000			 AREA	 |.pdata|, PDATA
|$T42913| DCD	|$LN16@PostInit|
	DCD	0x40001f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PostInit@OMAPMHSUSBOTG@@UAAHXZ| PROC	; OMAPMHSUSBOTG::PostInit

; 597  : {

  00000		 |$LN16@PostInit|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M42910|
  00004	e1a04000	 mov         r4, r0

; 598  :     BOOL bReturn = FALSE;
; 599  :     DEBUGMSG(ZONE_OTG_INIT, (L"OMAPMHSUSBOTG::PostInit(): "
; 600  :         L"Start.\r\n"
; 601  :         ));    
; 602  : 
; 603  :     // Default setting to be client mode
; 604  :     m_UsbOtgState = USBOTG_b_idle;
; 605  :     m_UsbOtgInput.bit.id = 1;

  00008	e594304c	 ldr         r3, [r4, #0x4C]

; 606  : 
; 607  :     if ( GetDeviceHandle()!=NULL &&  IsKeyOpened())

  0000c	e5942020	 ldr         r2, [r4, #0x20]
  00010	e3a01009	 mov         r1, #9
  00014	e3833902	 orr         r3, r3, #2, 18
  00018	e584304c	 str         r3, [r4, #0x4C]
  0001c	e3a05000	 mov         r5, #0
  00020	e5841070	 str         r1, [r4, #0x70]
  00024	e3520000	 cmp         r2, #0
  00028	0a000004	 beq         |$LN1@PostInit|
  0002c	e594302c	 ldr         r3, [r4, #0x2C]
  00030	e3530000	 cmp         r3, #0
  00034	0a000001	 beq         |$LN1@PostInit|

; 608  :     {
; 609  :         DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("PostInit\r\n")));
; 610  :         bReturn=USBOTG::PostInit();

  00038	eb000000	 bl          |?PostInit@USBOTG@@UAAHXZ|
  0003c	e1a05000	 mov         r5, r0
  00040		 |$LN1@PostInit|

; 611  :     }
; 612  : 
; 613  :     UpdateDevicePower(m_hParent, D4, NULL);

  00040	e59f2030	 ldr         r2, [pc, #0x30]
  00044	e5940140	 ldr         r0, [r4, #0x140]
  00048	e5923000	 ldr         r3, [r2]
  0004c	e3530004	 cmp         r3, #4
  00050	13a03004	 movne       r3, #4
  00054	15823000	 strne       r3, [r2]
  00058	13a02000	 movne       r2, #0
  0005c	13a01004	 movne       r1, #4
  00060	1b000000	 blne        SetDevicePowerState

; 614  :     ThreadStart();

  00064	e28400dc	 add         r0, r4, #0xDC
  00068	eb000000	 bl          |?ThreadStart@CMiniThread@@QAAHXZ|

; 615  :     
; 616  :     return bReturn;
; 617  : }

  0006c	e1a00005	 mov         r0, r5
  00070	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00074	e12fff1e	 bx          lr
  00078		 |$LN17@PostInit|
  00078		 |$LN18@PostInit|
  00078	00000000	 DCD         |?g_busDx@@3W4_CEDEVICE_POWER_STATE@@A|
  0007c		 |$M42911|

			 ENDP  ; |?PostInit@OMAPMHSUSBOTG@@UAAHXZ|, OMAPMHSUSBOTG::PostInit

	EXPORT	|?IOControl@OMAPMHSUSBOTG@@UAAHKPAEK0KPAK@Z| ; OMAPMHSUSBOTG::IOControl
	EXPORT	|??_C@_1CK@OBPLBNBH@?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CK@MHJHMPML@?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|?IOControl@USBOTG@@UAAHKPAEK0KPAK@Z|	; USBOTG::IOControl
	IMPORT	|SetInterruptEvent|
	IMPORT	|__C_specific_handler|
	IMPORT	|memset|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T43008| DCD	|$LN116@IOControl|
	DCD	0xc0023b04

  00000			 AREA	 |.pdata|, PDATA
|$T43010| DCD	|$LN80@IOControl|
	DCD	0x40000502

  00000			 AREA	 |.pdata|, PDATA
|$T43012| DCD	|$LN94@IOControl|
	DCD	0x40000502

  00000			 AREA	 |.pdata|, PDATA
|$T43014| DCD	|$LN87@IOControl|
	DCD	0x40000502

  00000			 AREA	 |.pdata|, PDATA
|$T43016| DCD	|$LN73@IOControl|
	DCD	0x40001802

  00000			 AREA	 |.xdata|, DATA
|$T43006| DCD	0x4
	DCD	|$LN84@IOControl|
	DCD	|$LN85@IOControl|
	DCD	|$LN80@IOControl|
	DCD	|$LN81@IOControl|
	DCD	|$LN98@IOControl|
	DCD	|$LN99@IOControl|
	DCD	|$LN94@IOControl|
	DCD	|$LN95@IOControl|
	DCD	|$LN91@IOControl|
	DCD	|$LN92@IOControl|
	DCD	|$LN87@IOControl|
	DCD	|$LN88@IOControl|
	DCD	|$LN77@IOControl|
	DCD	|$LN78@IOControl|
	DCD	|$LN73@IOControl|
	DCD	|$LN74@IOControl|

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CK@OBPLBNBH@?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@| DCB "E"
	DCB	0x0, "x", 0x0, "c", 0x0, "e", 0x0, "p", 0x0, "t", 0x0, "i"
	DCB	0x0, "o", 0x0, "n", 0x0, " ", 0x0, "i", 0x0, "n", 0x0, " "
	DCB	0x0, "i", 0x0, "o", 0x0, "c", 0x0, "t", 0x0, "l", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CK@MHJHMPML@?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@| DCB "e"
	DCB	0x0, "x", 0x0, "c", 0x0, "e", 0x0, "p", 0x0, "t", 0x0, "i"
	DCB	0x0, "o", 0x0, "n", 0x0, " ", 0x0, "i", 0x0, "n", 0x0, " "
	DCB	0x0, "i", 0x0, "o", 0x0, "c", 0x0, "t", 0x0, "l", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbotg\otg.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T43006|

  00008		 |?IOControl@OMAPMHSUSBOTG@@UAAHKPAEK0KPAK@Z| PROC ; OMAPMHSUSBOTG::IOControl

; 775  : {

  00008		 |$LN116@IOControl|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d58f0	 stmdb       sp!, {r4 - r7, r11, r12, lr}
  00010	e28db01c	 add         r11, sp, #0x1C
  00014	e24dd014	 sub         sp, sp, #0x14
  00018		 |$LN114@IOControl|
  00018	e1a04003	 mov         r4, r3
  0001c	e1a07002	 mov         r7, r2
  00020	e1a0e001	 mov         lr, r1
  00024	e1a05000	 mov         r5, r0

; 776  :     BOOL bReturn = FALSE;

  00028	e3a06000	 mov         r6, #0

; 777  :     BOOL rc = FALSE;
; 778  : 
; 779  :     switch (dwCode)

  0002c	e59f1958	 ldr         r1, [pc, #0x958]
  00030	e50b6024	 str         r6, [r11, #-0x24]
  00034	e15e0001	 cmp         lr, r1
  00038	8a000146	 bhi         |$LN69@IOControl|
  0003c	0a000120	 beq         |$LN28@IOControl|
  00040	e59f1940	 ldr         r1, [pc, #0x940]
  00044	e15e0001	 cmp         lr, r1
  00048	8a0000c5	 bhi         |$LN70@IOControl|
  0004c	0a0000a4	 beq         |$LN38@IOControl|
  00050	e3a03822	 mov         r3, #0x22, 16
  00054	e3833a02	 orr         r3, r3, #2, 20
  00058	e15e0003	 cmp         lr, r3
  0005c	0a000078	 beq         |$LN24@IOControl|
  00060	e59f391c	 ldr         r3, [pc, #0x91C]
  00064	e15e0003	 cmp         lr, r3
  00068	0a000049	 beq         |$LN20@IOControl|
  0006c	e59f390c	 ldr         r3, [pc, #0x90C]
  00070	e15e0003	 cmp         lr, r3
  00074	0a000030	 beq         |$LN8@IOControl|
  00078	e59f38fc	 ldr         r3, [pc, #0x8FC]
  0007c	e15e0003	 cmp         lr, r3
  00080	0a000017	 beq         |$LN6@IOControl|
  00084	e59f38ec	 ldr         r3, [pc, #0x8EC]
  00088	e15e0003	 cmp         lr, r3
  0008c	1a0001d0	 bne         |$LN1@IOControl|

; 1073 : 
; 1074 :         case IOCTL_USBOTG_ULPI_SET_LOW_POWER_MODE:
; 1075 :             rc = StartUSBClock(TRUE);

  00090	e5953000	 ldr         r3, [r5]
  00094	e3a01001	 mov         r1, #1
  00098	e59330e4	 ldr         r3, [r3, #0xE4]
  0009c	e1a0e00f	 mov         lr, pc
  000a0	e12fff13	 bx          r3

; 1076 :             DEBUGMSG(ZONE_OTG_INFO, (TEXT("Power = 0x%x\r\n"), m_pOTG->pUsbGenRegs->Power));
; 1077 :             DEBUGMSG(ZONE_OTG_INFO, (TEXT("Set Low Power Mode\r\n")));
; 1078 :             bReturn = m_pTransceiver->SetLowPowerMode();

  000a4	e59520fc	 ldr         r2, [r5, #0xFC]
  000a8	e1a04000	 mov         r4, r0
  000ac	e5923000	 ldr         r3, [r2]
  000b0	e1a00002	 mov         r0, r2
  000b4	e5933018	 ldr         r3, [r3, #0x18]
  000b8	e1a0e00f	 mov         lr, pc
  000bc	e12fff13	 bx          r3
  000c0	e1a06000	 mov         r6, r0

; 1079 :             if (rc == TRUE)

  000c4	e3540001	 cmp         r4, #1
  000c8	1a000205	 bne         |$LN86@IOControl|

; 1080 :                 StopUSBClock();

  000cc	e5953000	 ldr         r3, [r5]
  000d0	e1a00005	 mov         r0, r5
  000d4	e59330e8	 ldr         r3, [r3, #0xE8]
  000d8	e1a0e00f	 mov         lr, pc
  000dc	e12fff13	 bx          r3

; 1081 :             break;

  000e0	ea0001ff	 b           |$LN86@IOControl|
  000e4		 |$LN6@IOControl|

; 1057 : 
; 1058 :         case IOCTL_USBOTG_DUMP_ULPI_REG:
; 1059 :             rc = StartUSBClock(TRUE);

  000e4	e5953000	 ldr         r3, [r5]
  000e8	e3a01001	 mov         r1, #1
  000ec	e1a00005	 mov         r0, r5
  000f0	e59330e4	 ldr         r3, [r3, #0xE4]
  000f4	e1a0e00f	 mov         lr, pc
  000f8	e12fff13	 bx          r3

; 1060 : 
; 1061 :             DEBUGMSG(ZONE_OTG_INFO, (TEXT("Power = 0x%x\r\n"), m_pOTG->pUsbGenRegs->Power));
; 1062 :             DEBUGMSG(ZONE_OTG_INFO, (TEXT("Dump ULPI Reg\r\n")));
; 1063 :             DEBUGMSG(ZONE_OTG_INFO, (TEXT("ULPIVBusControl = 0x%x\r\n"), INREG8(&m_pOTG->pUsbGenRegs->ulpi_regs.ULPIVbusControl)));
; 1064 :             DEBUGMSG(ZONE_OTG_INFO, (TEXT("ULPICarKitControl = 0x%x\r\n"), INREG8(&m_pOTG->pUsbGenRegs->ulpi_regs.ULPICarKitControl)));
; 1065 :             DEBUGMSG(ZONE_OTG_INFO, (TEXT("ULPIIntMask = 0x%x\r\n"), INREG8(&m_pOTG->pUsbGenRegs->ulpi_regs.ULPIIntMask)));
; 1066 :             DEBUGMSG(ZONE_OTG_INFO, (TEXT("ULPIIntSrc = 0x%x\r\n"), INREG8(&m_pOTG->pUsbGenRegs->ulpi_regs.ULPIIntSrc)));        
; 1067 :             DEBUGMSG(ZONE_OTG_INFO, (TEXT("ULPIRawData = 0x%x\r\n"), INREG8(&m_pOTG->pUsbGenRegs->ulpi_regs.ULPIRawData)));
; 1068 :             m_pTransceiver->DumpULPIRegs();

  000fc	e59520fc	 ldr         r2, [r5, #0xFC]
  00100	e1a04000	 mov         r4, r0
  00104	e5923000	 ldr         r3, [r2]
  00108	e1a00002	 mov         r0, r2
  0010c	e5933020	 ldr         r3, [r3, #0x20]
  00110	e1a0e00f	 mov         lr, pc
  00114	e12fff13	 bx          r3

; 1069 :             bReturn = TRUE;

  00118	e3a06001	 mov         r6, #1

; 1070 :             if (rc == TRUE)

  0011c	e3540001	 cmp         r4, #1
  00120	1a0001ef	 bne         |$LN86@IOControl|

; 1071 :                 StopUSBClock();

  00124	e5953000	 ldr         r3, [r5]
  00128	e1a00005	 mov         r0, r5
  0012c	e59330e8	 ldr         r3, [r3, #0xE8]
  00130	e1a0e00f	 mov         lr, pc
  00134	e12fff13	 bx          r3

; 1072 :             break;

  00138	ea0001e9	 b           |$LN86@IOControl|
  0013c		 |$LN8@IOControl|

; 1038 : 
; 1039 :         case IOCTL_USBOTG_REQUEST_SESSION_QUERY:
; 1040 :         {
; 1041 :             DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Query:\r\n")));
; 1042 :             rc = StartUSBClock(TRUE);

  0013c	e5953000	 ldr         r3, [r5]
  00140	e3a01001	 mov         r1, #1
  00144	e1a00005	 mov         r0, r5
  00148	e59330e4	 ldr         r3, [r3, #0xE4]
  0014c	e1a0e00f	 mov         lr, pc
  00150	e12fff13	 bx          r3

; 1043 :             EnterCriticalSection(&m_pOTG->regCS);

  00154	e5953150	 ldr         r3, [r5, #0x150]
  00158	e1a04000	 mov         r4, r0
  0015c	e2830038	 add         r0, r3, #0x38
  00160	eb000000	 bl          EnterCriticalSection

; 1044 :             DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("DevCtl = 0x%x\r\n"), INREG8(&m_pOTG->pUsbGenRegs->DevCtl)));
; 1045 :             DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Power  = 0x%x\r\n"), INREG8(&m_pOTG->pUsbGenRegs->Power)));
; 1046 : #ifdef DEBUG
; 1047 :             UCHAR devctl = INREG8(&m_pOTG->pUsbGenRegs->DevCtl);
; 1048 : 			UCHAR vbus = (devctl & DEVCTL_VBUS) >> 3;
; 1049 :             DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("VBus = 0x%x\r\n"), vbus));
; 1050 : #endif
; 1051 :             LeaveCriticalSection(&m_pOTG->regCS);

  00164	e5953150	 ldr         r3, [r5, #0x150]
  00168	e2830038	 add         r0, r3, #0x38
  0016c	eb000000	 bl          LeaveCriticalSection

; 1052 :             bReturn = TRUE;

  00170	e3a06001	 mov         r6, #1

; 1053 :             if (rc == TRUE)

  00174	e3540001	 cmp         r4, #1
  00178	1a0001d9	 bne         |$LN86@IOControl|

; 1054 :                 StopUSBClock();

  0017c	e5953000	 ldr         r3, [r5]
  00180	e1a00005	 mov         r0, r5
  00184	e59330e8	 ldr         r3, [r3, #0xE8]
  00188	e1a0e00f	 mov         lr, pc
  0018c	e12fff13	 bx          r3

; 1055 :         }
; 1056 :         break;

  00190	ea0001d3	 b           |$LN86@IOControl|
  00194		 |$LN20@IOControl|

; 988  : 
; 989  :         case IOCTL_USBOTG_REQUEST_SESSION_DISABLE:        
; 990  :             if (m_pOTG->operateMode != IDLE_MODE)

  00194	e5953150	 ldr         r3, [r5, #0x150]
  00198	e5d33035	 ldrb        r3, [r3, #0x35]
  0019c	e3530000	 cmp         r3, #0

; 991  :                 m_bSessionDisable = TRUE;

  001a0	13a03001	 movne       r3, #1
  001a4	1585317c	 strne       r3, [r5, #0x17C]

; 992  : 
; 993  :             DEBUGMSG(ZONE_OTG_INFO, (TEXT("IOCTL_USBOTG_REQUEST_SESSION_DISABLE\r\n")));
; 994  :             rc = StartUSBClock(TRUE);

  001a8	e5953000	 ldr         r3, [r5]
  001ac	e3a01001	 mov         r1, #1
  001b0	e1a00005	 mov         r0, r5
  001b4	e59330e4	 ldr         r3, [r3, #0xE4]
  001b8	e1a0e00f	 mov         lr, pc
  001bc	e12fff13	 bx          r3

; 995  :             EnterCriticalSection(&m_pOTG->regCS);

  001c0	e5953150	 ldr         r3, [r5, #0x150]
  001c4	e1a04000	 mov         r4, r0
  001c8	e2830038	 add         r0, r3, #0x38
  001cc	eb000000	 bl          EnterCriticalSection

; 996  :             if ((INREG8(&m_pOTG->pUsbGenRegs->DevCtl) & DEVCTL_SESSION) == DEVCTL_SESSION)

  001d0	e5953150	 ldr         r3, [r5, #0x150]
  001d4	e5933020	 ldr         r3, [r3, #0x20]
  001d8	e5d33060	 ldrb        r3, [r3, #0x60]
  001dc	e2033001	 and         r3, r3, #1
  001e0	e3530001	 cmp         r3, #1

; 997  :                 SessionRequest(FALSE, FALSE);

  001e4	05953000	 ldreq       r3, [r5]
  001e8	03a02000	 moveq       r2, #0
  001ec	03a01000	 moveq       r1, #0
  001f0	05933084	 ldreq       r3, [r3, #0x84]
  001f4	01a00005	 moveq       r0, r5
  001f8	01a0e00f	 moveq       lr, pc
  001fc	012fff13	 bxeq        r3

; 998  :             LeaveCriticalSection(&m_pOTG->regCS);

  00200	e5953150	 ldr         r3, [r5, #0x150]
  00204	e2830038	 add         r0, r3, #0x38
  00208	eb000000	 bl          LeaveCriticalSection

; 999  :             if (m_pOTG->operateMode != IDLE_MODE)

  0020c	e5953150	 ldr         r3, [r5, #0x150]
  00210	e5d33035	 ldrb        r3, [r3, #0x35]
  00214	e3530000	 cmp         r3, #0

; 1000 :                 SetInterruptEvent(m_dwSysIntr);

  00218	15950144	 ldrne       r0, [r5, #0x144]
  0021c	1b000000	 blne        SetInterruptEvent

; 1001 :             bReturn = TRUE;

  00220	e3a06001	 mov         r6, #1

; 1002 :             if (rc == TRUE)

  00224	e3540001	 cmp         r4, #1
  00228	1a0001ad	 bne         |$LN86@IOControl|

; 1003 :                 StopUSBClock();

  0022c	e5953000	 ldr         r3, [r5]
  00230	e1a00005	 mov         r0, r5
  00234	e59330e8	 ldr         r3, [r3, #0xE8]
  00238	e1a0e00f	 mov         lr, pc
  0023c	e12fff13	 bx          r3

; 1004 :             break;

  00240	ea0001a7	 b           |$LN86@IOControl|
  00244		 |$LN24@IOControl|

; 963  : 
; 964  :         case IOCTL_USBOTG_REQUEST_SESSION_ENABLE:        
; 965  :             DEBUGMSG(ZONE_OTG_INFO, (TEXT("Session Enable\r\n")));
; 966  :             rc = StartUSBClock(TRUE);

  00244	e5953000	 ldr         r3, [r5]
  00248	e3a01001	 mov         r1, #1
  0024c	e1a00005	 mov         r0, r5
  00250	e59330e4	 ldr         r3, [r3, #0xE4]
  00254	e1a0e00f	 mov         lr, pc
  00258	e12fff13	 bx          r3

; 967  :             EnterCriticalSection(&m_pOTG->regCS);

  0025c	e5953150	 ldr         r3, [r5, #0x150]
  00260	e1a04000	 mov         r4, r0
  00264	e2830038	 add         r0, r3, #0x38
  00268	eb000000	 bl          EnterCriticalSection

; 968  :             if ((INREG8(&m_pOTG->pUsbGenRegs->DevCtl) & DEVCTL_SESSION) == 0x00)

  0026c	e5953150	 ldr         r3, [r5, #0x150]
  00270	e5933020	 ldr         r3, [r3, #0x20]
  00274	e5d33060	 ldrb        r3, [r3, #0x60]
  00278	e3130001	 tst         r3, #1

; 969  :             {
; 970  :                 SessionRequest(TRUE, TRUE);

  0027c	e5953000	 ldr         r3, [r5]
  00280	e3a02001	 mov         r2, #1
  00284	e3a01001	 mov         r1, #1
  00288	e1a00005	 mov         r0, r5
  0028c	e5933084	 ldr         r3, [r3, #0x84]

; 968  :             if ((INREG8(&m_pOTG->pUsbGenRegs->DevCtl) & DEVCTL_SESSION) == 0x00)

  00290	1a000005	 bne         |$LN23@IOControl|

; 969  :             {
; 970  :                 SessionRequest(TRUE, TRUE);

  00294	e1a0e00f	 mov         lr, pc
  00298	e12fff13	 bx          r3

; 971  :                 bReturn = TRUE;            
; 972  :                 Sleep(2000); 

  0029c	e3a00e7d	 mov         r0, #0x7D, 28
  002a0	e3a06001	 mov         r6, #1
  002a4	eb000000	 bl          Sleep

; 973  :                 // It is required to sleep 2 sec for SRP as if StopUSBClock again, the DATA3 line would be reconfigured to
; 974  :                 // GPIO IN which would cause the SRP un-success.
; 975  :             }
; 976  :             else

  002a8	ea000002	 b           |$LN22@IOControl|
  002ac		 |$LN23@IOControl|

; 977  :             {
; 978  :                 DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("SessionRequest currently enable, ignore (0x%x)\r\n"), 
; 979  :                         INREG8(&m_pOTG->pUsbGenRegs->DevCtl)));
; 980  :                 DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("SessionRequest --- still try to write\r\n")));
; 981  :                 SessionRequest(TRUE, TRUE);

  002ac	e1a0e00f	 mov         lr, pc
  002b0	e12fff13	 bx          r3

; 982  :                 bReturn = TRUE;

  002b4	e3a06001	 mov         r6, #1
  002b8		 |$LN22@IOControl|

; 983  :             }                
; 984  :             LeaveCriticalSection(&m_pOTG->regCS);        

  002b8	e5953150	 ldr         r3, [r5, #0x150]
  002bc	e2830038	 add         r0, r3, #0x38
  002c0	eb000000	 bl          LeaveCriticalSection

; 985  :             if (rc == TRUE)

  002c4	e3540001	 cmp         r4, #1
  002c8	1a000185	 bne         |$LN86@IOControl|

; 986  :                 StopUSBClock();

  002cc	e5953000	 ldr         r3, [r5]
  002d0	e1a00005	 mov         r0, r5
  002d4	e59330e8	 ldr         r3, [r3, #0xE8]
  002d8	e1a0e00f	 mov         lr, pc
  002dc	e12fff13	 bx          r3

; 987  :             break;

  002e0	ea00017f	 b           |$LN86@IOControl|
  002e4		 |$LN38@IOControl|

; 894  : 
; 895  :         case IOCTL_USBOTG_REQUEST_HOST_MODE:
; 896  :             DEBUGMSG(ZONE_OTG_INFO, (TEXT("HNP Set\r\n")));
; 897  :             rc = StartUSBClock(TRUE);

  002e4	e5953000	 ldr         r3, [r5]
  002e8	e3a01001	 mov         r1, #1
  002ec	e1a00005	 mov         r0, r5
  002f0	e59330e4	 ldr         r3, [r3, #0xE4]
  002f4	e1a0e00f	 mov         lr, pc
  002f8	e12fff13	 bx          r3

; 898  :             EnterCriticalSection(&m_pOTG->regCS);

  002fc	e5953150	 ldr         r3, [r5, #0x150]
  00300	e1a04000	 mov         r4, r0
  00304	e2830038	 add         r0, r3, #0x38
  00308	eb000000	 bl          EnterCriticalSection

; 899  :             // if from IOCTL_BUS_USBOTG_HNP_ENABLE, always set it
; 900  :             if (INREG8(&m_pOTG->pUsbGenRegs->DevCtl) & DEVCTL_HOSTREQ)

  0030c	e5953150	 ldr         r3, [r5, #0x150]
  00310	e5932020	 ldr         r2, [r3, #0x20]
  00314	e5d23060	 ldrb        r3, [r2, #0x60]
  00318	e3130002	 tst         r3, #2

; 901  :             {
; 902  :                 DEBUGMSG(ZONE_OTG_INFO, (TEXT("HNP Disable\r\n")));
; 903  :                 CLRREG8(&m_pOTG->pUsbGenRegs->DevCtl, DEVCTL_HOSTREQ);

  0031c	e5d23060	 ldrb        r3, [r2, #0x60]
  00320	120330fd	 andne       r3, r3, #0xFD

; 904  :             }
; 905  :             else
; 906  :             {
; 907  :                 DEBUGMSG(ZONE_OTG_INFO, (TEXT("HNP Enable\r\n")));
; 908  :                 SETREG8(&m_pOTG->pUsbGenRegs->DevCtl, DEVCTL_HOSTREQ);

  00324	03833002	 orreq       r3, r3, #2
  00328	e5c23060	 strb        r3, [r2, #0x60]

; 909  :             }
; 910  :             m_bHNPEnable = TRUE;
; 911  : 
; 912  :             bReturn = TRUE;
; 913  :             LeaveCriticalSection(&m_pOTG->regCS);

  0032c	e5953150	 ldr         r3, [r5, #0x150]
  00330	e3a02001	 mov         r2, #1
  00334	e585216c	 str         r2, [r5, #0x16C]
  00338	e2830038	 add         r0, r3, #0x38
  0033c	e3a06001	 mov         r6, #1
  00340	eb000000	 bl          LeaveCriticalSection

; 914  :             if (rc == TRUE)

  00344	e3540001	 cmp         r4, #1
  00348	1a000165	 bne         |$LN86@IOControl|

; 915  :                 StopUSBClock();

  0034c	e5953000	 ldr         r3, [r5]
  00350	e1a00005	 mov         r0, r5
  00354	e59330e8	 ldr         r3, [r3, #0xE8]
  00358	e1a0e00f	 mov         lr, pc
  0035c	e12fff13	 bx          r3

; 916  :             break;

  00360	ea00015f	 b           |$LN86@IOControl|
  00364		 |$LN70@IOControl|

; 777  :     BOOL rc = FALSE;
; 778  : 
; 779  :     switch (dwCode)

  00364	e59f3608	 ldr         r3, [pc, #0x608]
  00368	e15e0003	 cmp         lr, r3
  0036c	0a0000e0	 beq         |$LN32@IOControl|
  00370	e59f35f8	 ldr         r3, [pc, #0x5F8]
  00374	e15e0003	 cmp         lr, r3
  00378	0a000051	 beq         |$LN28@IOControl|
  0037c	e59f35e8	 ldr         r3, [pc, #0x5E8]
  00380	e15e0003	 cmp         lr, r3
  00384	0a00002c	 beq         |$LN15@IOControl|
  00388	e59f35d8	 ldr         r3, [pc, #0x5D8]
  0038c	e15e0003	 cmp         lr, r3
  00390	1a00010f	 bne         |$LN1@IOControl|

; 1019 : 
; 1020 :         case IOCTL_USBOTG_REQUEST_STOP:
; 1021 :         {
; 1022 :             rc = StartUSBClock(TRUE);

  00394	e5953000	 ldr         r3, [r5]
  00398	e3a01001	 mov         r1, #1
  0039c	e1a00005	 mov         r0, r5
  003a0	e59330e4	 ldr         r3, [r3, #0xE4]
  003a4	e1a0e00f	 mov         lr, pc
  003a8	e12fff13	 bx          r3

; 1023 :             UINT8 DevCtl = INREG8(&m_pOTG->pUsbGenRegs->DevCtl);

  003ac	e5953150	 ldr         r3, [r5, #0x150]
  003b0	e1a07000	 mov         r7, r0
  003b4	e5932020	 ldr         r2, [r3, #0x20]

; 1024 :             DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("IOCTL_USBOTG_REQUEST_STOP\r\n")));
; 1025 :             EnterCriticalSection(&m_pOTG->regCS);

  003b8	e2830038	 add         r0, r3, #0x38
  003bc	e5d24060	 ldrb        r4, [r2, #0x60]
  003c0	eb000000	 bl          EnterCriticalSection

; 1026 :             m_bExtendOTGSuspend = TRUE;

  003c4	e3a02001	 mov         r2, #1

; 1027 :             if((DevCtl&DEVCTL_B_DEVICE) != DEVCTL_B_DEVICE)

  003c8	e2043080	 and         r3, r4, #0x80
  003cc	e5852184	 str         r2, [r5, #0x184]
  003d0	e3530080	 cmp         r3, #0x80
  003d4	0a000008	 beq         |$LN10@IOControl|

; 1028 :             {
; 1029 :                 if ((DevCtl & DEVCTL_SESSION) == DEVCTL_SESSION)

  003d8	e2043001	 and         r3, r4, #1
  003dc	e3530001	 cmp         r3, #1

; 1030 :                     SessionRequest(FALSE, FALSE);

  003e0	05953000	 ldreq       r3, [r5]
  003e4	03a02000	 moveq       r2, #0
  003e8	03a01000	 moveq       r1, #0
  003ec	05933084	 ldreq       r3, [r3, #0x84]
  003f0	01a00005	 moveq       r0, r5
  003f4	01a0e00f	 moveq       lr, pc
  003f8	012fff13	 bxeq        r3
  003fc		 |$LN10@IOControl|

; 1031 :             }
; 1032 :             CLRREG8(&m_pOTG->pUsbGenRegs->Power, POWER_SOFTCONN);

  003fc	e5953150	 ldr         r3, [r5, #0x150]
  00400	e5932020	 ldr         r2, [r3, #0x20]
  00404	e5d23001	 ldrb        r3, [r2, #1]
  00408	e20330bf	 and         r3, r3, #0xBF
  0040c	e5c23001	 strb        r3, [r2, #1]

; 1033 :             LeaveCriticalSection(&m_pOTG->regCS);

  00410	e5953150	 ldr         r3, [r5, #0x150]
  00414	e2830038	 add         r0, r3, #0x38
  00418	eb000000	 bl          LeaveCriticalSection

; 1034 :             if (rc == TRUE)

  0041c	e3570001	 cmp         r7, #1
  00420	1a00012f	 bne         |$LN86@IOControl|

; 1035 :                 StopUSBClock();

  00424	e5953000	 ldr         r3, [r5]
  00428	e1a00005	 mov         r0, r5
  0042c	e59330e8	 ldr         r3, [r3, #0xE8]
  00430	e1a0e00f	 mov         lr, pc
  00434	e12fff13	 bx          r3

; 1036 :         }
; 1037 :             break;

  00438	ea000129	 b           |$LN86@IOControl|
  0043c		 |$LN15@IOControl|

; 1005 : 
; 1006 :         case IOCTL_USBOTG_REQUEST_START:
; 1007 :             if (m_bOTGReady)

  0043c	e5953188	 ldr         r3, [r5, #0x188]
  00440	e3530000	 cmp         r3, #0
  00444	0a000126	 beq         |$LN86@IOControl|

; 1008 :             {
; 1009 :                 DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("IOCTL_USBOTG_REQUEST_START\r\n")));
; 1010 :                 rc = StartUSBClock(TRUE);

  00448	e5953000	 ldr         r3, [r5]
  0044c	e3a01001	 mov         r1, #1
  00450	e1a00005	 mov         r0, r5
  00454	e59330e4	 ldr         r3, [r3, #0xE4]
  00458	e1a0e00f	 mov         lr, pc
  0045c	e12fff13	 bx          r3

; 1011 :                 EnterCriticalSection(&m_pOTG->regCS);        

  00460	e5953150	 ldr         r3, [r5, #0x150]
  00464	e1a04000	 mov         r4, r0
  00468	e2830038	 add         r0, r3, #0x38
  0046c	eb000000	 bl          EnterCriticalSection

; 1012 :                 SETREG8(&m_pOTG->pUsbGenRegs->Power, POWER_SOFTCONN);

  00470	e5953150	 ldr         r3, [r5, #0x150]
  00474	e5932020	 ldr         r2, [r3, #0x20]
  00478	e5d23001	 ldrb        r3, [r2, #1]
  0047c	e3833040	 orr         r3, r3, #0x40
  00480	e5c23001	 strb        r3, [r2, #1]

; 1013 :                 SETREG8(&m_pOTG->pUsbGenRegs->DevCtl, DEVCTL_SESSION);

  00484	e5953150	 ldr         r3, [r5, #0x150]
  00488	e5932020	 ldr         r2, [r3, #0x20]
  0048c	e5d23060	 ldrb        r3, [r2, #0x60]
  00490	e3833001	 orr         r3, r3, #1
  00494	e5c23060	 strb        r3, [r2, #0x60]

; 1014 :                 LeaveCriticalSection(&m_pOTG->regCS);

  00498	e5953150	 ldr         r3, [r5, #0x150]
  0049c	e2830038	 add         r0, r3, #0x38
  004a0	eb000000	 bl          LeaveCriticalSection

; 1015 :                 if (rc == TRUE)

  004a4	e3540001	 cmp         r4, #1
  004a8	1a00010d	 bne         |$LN86@IOControl|

; 1016 :                     StopUSBClock();

  004ac	e5953000	 ldr         r3, [r5]
  004b0	e1a00005	 mov         r0, r5
  004b4	e59330e8	 ldr         r3, [r3, #0xE8]
  004b8	e1a0e00f	 mov         lr, pc
  004bc	e12fff13	 bx          r3

; 1017 :             }
; 1018 :             break;

  004c0	ea000107	 b           |$LN86@IOControl|
  004c4		 |$LN28@IOControl|

; 944  : 
; 945  :         case IOCTL_USBOTG_RESUME_HOST:
; 946  :         case IOCTL_BUS_USBOTG_RESUME:
; 947  :             DEBUGMSG(ZONE_OTG_INFO, (TEXT("Host Resume\r\n")));
; 948  :             rc = StartUSBClock(TRUE);

  004c4	e5953000	 ldr         r3, [r5]
  004c8	e3a01001	 mov         r1, #1
  004cc	e1a00005	 mov         r0, r5
  004d0	e59330e4	 ldr         r3, [r3, #0xE4]
  004d4	e1a0e00f	 mov         lr, pc
  004d8	e12fff13	 bx          r3

; 949  :             EnterCriticalSection(&m_pOTG->regCS);

  004dc	e5953150	 ldr         r3, [r5, #0x150]
  004e0	e1a04000	 mov         r4, r0
  004e4	e2830038	 add         r0, r3, #0x38
  004e8	eb000000	 bl          EnterCriticalSection

; 950  :             if (INREG8(&m_pOTG->pUsbGenRegs->Power) & POWER_SUSPENDM)

  004ec	e5953150	 ldr         r3, [r5, #0x150]
  004f0	e5932020	 ldr         r2, [r3, #0x20]
  004f4	e5d23001	 ldrb        r3, [r2, #1]
  004f8	e3130002	 tst         r3, #2
  004fc	0a000009	 beq         |$LN27@IOControl|

; 951  :             {
; 952  :                 SETREG8(&m_pOTG->pUsbGenRegs->Power, POWER_RESUME);

  00500	e5d23001	 ldrb        r3, [r2, #1]

; 953  :                 Sleep(10);

  00504	e3a0000a	 mov         r0, #0xA
  00508	e3833004	 orr         r3, r3, #4
  0050c	e5c23001	 strb        r3, [r2, #1]
  00510	eb000000	 bl          Sleep

; 954  :                 CLRREG8(&m_pOTG->pUsbGenRegs->Power, POWER_RESUME);

  00514	e5953150	 ldr         r3, [r5, #0x150]
  00518	e5932020	 ldr         r2, [r3, #0x20]
  0051c	e5d23001	 ldrb        r3, [r2, #1]
  00520	e20330fb	 and         r3, r3, #0xFB
  00524	e5c23001	 strb        r3, [r2, #1]
  00528		 |$LN27@IOControl|

; 955  :             }
; 956  :             else
; 957  :                 DEBUGMSG(ZONE_OTG_INFO, (TEXT("Device Mode cannot set Resume Bit\r\n")));
; 958  :             bReturn = TRUE;
; 959  :             LeaveCriticalSection(&m_pOTG->regCS);

  00528	e5953150	 ldr         r3, [r5, #0x150]
  0052c	e3a06001	 mov         r6, #1
  00530	e2830038	 add         r0, r3, #0x38
  00534	eb000000	 bl          LeaveCriticalSection

; 960  :             if (rc == TRUE)

  00538	e3540001	 cmp         r4, #1
  0053c	1a0000e8	 bne         |$LN86@IOControl|

; 961  :                 StopUSBClock();

  00540	e5953000	 ldr         r3, [r5]
  00544	e1a00005	 mov         r0, r5
  00548	e59330e8	 ldr         r3, [r3, #0xE8]
  0054c	e1a0e00f	 mov         lr, pc
  00550	e12fff13	 bx          r3

; 962  :             break;

  00554	ea0000e2	 b           |$LN86@IOControl|
  00558		 |$LN69@IOControl|

; 777  :     BOOL rc = FALSE;
; 778  : 
; 779  :     switch (dwCode)

  00558	e59f3404	 ldr         r3, [pc, #0x404]
  0055c	e15e0003	 cmp         lr, r3
  00560	8a00008f	 bhi         |$LN71@IOControl|
  00564	0a00007f	 beq         |$LN50@IOControl|
  00568	e3a0382a	 mov         r3, #0x2A, 16
  0056c	e3833e41	 orr         r3, r3, #0x41, 28
  00570	e15e0003	 cmp         lr, r3
  00574	0a00005e	 beq         |$LN32@IOControl|
  00578	e59f33e0	 ldr         r3, [pc, #0x3E0]
  0057c	e15e0003	 cmp         lr, r3
  00580	0a00003b	 beq         |$LN42@IOControl|
  00584	e59f33d0	 ldr         r3, [pc, #0x3D0]
  00588	e15e0003	 cmp         lr, r3
  0058c	0a00001b	 beq         |$LN34@IOControl|
  00590	e3a03832	 mov         r3, #0x32, 16
  00594	e3833a01	 orr         r3, r3, #1, 20
  00598	e15e0003	 cmp         lr, r3
  0059c	1a00008c	 bne         |$LN1@IOControl|

; 780  :     {
; 781  :         case IOCTL_POWER_CAPABILITIES:
; 782  :             if (pBufOut && dwLenOut >= sizeof (POWER_CAPABILITIES) && pdwActualOut)

  005a0	e59b4000	 ldr         r4, [r11]
  005a4	e3540000	 cmp         r4, #0
  005a8	0a0000cd	 beq         |$LN86@IOControl|
  005ac	e59b3004	 ldr         r3, [r11, #4]
  005b0	e3530030	 cmp         r3, #0x30
  005b4	3a0000ca	 bcc         |$LN86@IOControl|
  005b8	e59b5008	 ldr         r5, [r11, #8]
  005bc	e3550000	 cmp         r5, #0
  005c0	0a0000c7	 beq         |$LN86@IOControl|
  005c4		 |$LN77@IOControl|

; 783  :             {
; 784  :                 __try
; 785  :                 {
; 786  :                     PPOWER_CAPABILITIES PowerCaps;
; 787  :                     PowerCaps = (PPOWER_CAPABILITIES)pBufOut;
; 788  : 
; 789  :                     // Only supports D0 (permanently on) and D4(off.
; 790  :                     memset(PowerCaps, 0, sizeof(*PowerCaps));

  005c4	e3a02030	 mov         r2, #0x30
  005c8	e3a01000	 mov         r1, #0
  005cc	e1a00004	 mov         r0, r4
  005d0	eb000000	 bl          memset

; 791  :                     PowerCaps->DeviceDx = 0x11;   // d0 ~ d4

  005d4	e3a03011	 mov         r3, #0x11
  005d8	e5c43000	 strb        r3, [r4]

; 792  :                     *pdwActualOut = sizeof(*PowerCaps);

  005dc	e3a03030	 mov         r3, #0x30
  005e0	e5853000	 str         r3, [r5]

; 793  : 
; 794  :                     bReturn = TRUE;

  005e4	e3a06001	 mov         r6, #1
  005e8	e50b6024	 str         r6, [r11, #-0x24]
  005ec		 |$LN78@IOControl|

; 795  :                 }

  005ec	ea0000bc	 b           |$LN86@IOControl|
  005f0		 |$LN74@IOControl|

; 797  :                 {
; 798  :                     RETAILMSG(1, (L"exception in ioctl\r\n"));

  005f0	e59f0360	 ldr         r0, [pc, #0x360]
  005f4	eb000000	 bl          NKDbgPrintfW
  005f8	e51b6024	 ldr         r6, [r11, #-0x24]
  005fc	ea0000b8	 b           |$LN86@IOControl|
  00600		 |$LN34@IOControl|

; 917  : 
; 918  :         case IOCTL_BUS_USBOTG_HNP_DISABLE:    
; 919  :             DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("HNP Disable\r\n")));
; 920  :             rc = StartUSBClock(TRUE);

  00600	e5953000	 ldr         r3, [r5]
  00604	e3a01001	 mov         r1, #1
  00608	e1a00005	 mov         r0, r5
  0060c	e59330e4	 ldr         r3, [r3, #0xE4]
  00610	e1a0e00f	 mov         lr, pc
  00614	e12fff13	 bx          r3

; 921  :             EnterCriticalSection(&m_pOTG->regCS);

  00618	e5953150	 ldr         r3, [r5, #0x150]
  0061c	e1a04000	 mov         r4, r0
  00620	e2830038	 add         r0, r3, #0x38
  00624	eb000000	 bl          EnterCriticalSection

; 922  :             CLRREG8(&m_pOTG->pUsbGenRegs->DevCtl, DEVCTL_HOSTREQ);        

  00628	e5953150	 ldr         r3, [r5, #0x150]

; 923  :             bReturn = TRUE;
; 924  :             m_bHNPEnable = FALSE;

  0062c	e3a01000	 mov         r1, #0
  00630	e3a06001	 mov         r6, #1
  00634	e5932020	 ldr         r2, [r3, #0x20]
  00638	e5d23060	 ldrb        r3, [r2, #0x60]
  0063c	e20330fd	 and         r3, r3, #0xFD
  00640	e5c23060	 strb        r3, [r2, #0x60]

; 925  :             LeaveCriticalSection(&m_pOTG->regCS);

  00644	e5953150	 ldr         r3, [r5, #0x150]
  00648	e585116c	 str         r1, [r5, #0x16C]
  0064c	e2830038	 add         r0, r3, #0x38
  00650	eb000000	 bl          LeaveCriticalSection

; 926  :             if (rc == TRUE)

  00654	e3540001	 cmp         r4, #1
  00658	1a0000a1	 bne         |$LN86@IOControl|

; 927  :                 StopUSBClock();

  0065c	e5953000	 ldr         r3, [r5]
  00660	e1a00005	 mov         r0, r5
  00664	e59330e8	 ldr         r3, [r3, #0xE8]
  00668	e1a0e00f	 mov         lr, pc
  0066c	e12fff13	 bx          r3

; 928  :             break;

  00670	ea00009b	 b           |$LN86@IOControl|
  00674		 |$LN42@IOControl|

; 878  : 
; 879  :         case IOCTL_BUS_USBOTG_HNP_ENABLE:
; 880  :             rc = StartUSBClock(TRUE);

  00674	e5953000	 ldr         r3, [r5]
  00678	e3a01001	 mov         r1, #1
  0067c	e1a00005	 mov         r0, r5
  00680	e59330e4	 ldr         r3, [r3, #0xE4]
  00684	e1a0e00f	 mov         lr, pc
  00688	e12fff13	 bx          r3

; 881  :             EnterCriticalSection(&m_pOTG->regCS);

  0068c	e5953150	 ldr         r3, [r5, #0x150]
  00690	e1a04000	 mov         r4, r0
  00694	e2830038	 add         r0, r3, #0x38
  00698	eb000000	 bl          EnterCriticalSection

; 882  :             DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("HNP Set\r\n")));
; 883  :             DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("HNP Enable\r\n")));
; 884  :             if (m_pOTG->operateMode == DEVICE_MODE)

  0069c	e5952150	 ldr         r2, [r5, #0x150]
  006a0	e5d23035	 ldrb        r3, [r2, #0x35]
  006a4	e3530001	 cmp         r3, #1

; 885  :                 SETREG8(&m_pOTG->pUsbGenRegs->DevCtl, DEVCTL_HOSTREQ);

  006a8	e5922020	 ldr         r2, [r2, #0x20]
  006ac	e5d23060	 ldrb        r3, [r2, #0x60]
  006b0	03833002	 orreq       r3, r3, #2

; 886  :             else
; 887  :                 CLRREG8(&m_pOTG->pUsbGenRegs->DevCtl, DEVCTL_HOSTREQ);

  006b4	120330fd	 andne       r3, r3, #0xFD
  006b8	e5c23060	 strb        r3, [r2, #0x60]

; 888  :             m_bHNPEnable = TRUE;
; 889  :             bReturn = TRUE;
; 890  :             LeaveCriticalSection(&m_pOTG->regCS);

  006bc	e5953150	 ldr         r3, [r5, #0x150]
  006c0	e3a02001	 mov         r2, #1
  006c4	e585216c	 str         r2, [r5, #0x16C]
  006c8	e2830038	 add         r0, r3, #0x38
  006cc	e3a06001	 mov         r6, #1
  006d0	eb000000	 bl          LeaveCriticalSection

; 891  :             if (rc == TRUE)

  006d4	e3540001	 cmp         r4, #1
  006d8	1a000081	 bne         |$LN86@IOControl|

; 892  :                 StopUSBClock();

  006dc	e5953000	 ldr         r3, [r5]
  006e0	e1a00005	 mov         r0, r5
  006e4	e59330e8	 ldr         r3, [r3, #0xE8]
  006e8	e1a0e00f	 mov         lr, pc
  006ec	e12fff13	 bx          r3

; 893  :             break;

  006f0	ea00007b	 b           |$LN86@IOControl|
  006f4		 |$LN32@IOControl|

; 929  : 
; 930  :         case IOCTL_USBOTG_SUSPEND_HOST:
; 931  :         case IOCTL_BUS_USBOTG_SUSPEND :
; 932  :             DEBUGMSG(ZONE_OTG_INFO, (TEXT("Host Suspend\r\n")));
; 933  :             rc = StartUSBClock(TRUE);

  006f4	e5953000	 ldr         r3, [r5]
  006f8	e3a01001	 mov         r1, #1
  006fc	e1a00005	 mov         r0, r5
  00700	e59330e4	 ldr         r3, [r3, #0xE4]
  00704	e1a0e00f	 mov         lr, pc
  00708	e12fff13	 bx          r3

; 934  :             EnterCriticalSection(&m_pOTG->regCS);

  0070c	e5953150	 ldr         r3, [r5, #0x150]
  00710	e1a04000	 mov         r4, r0
  00714	e2830038	 add         r0, r3, #0x38
  00718	eb000000	 bl          EnterCriticalSection

; 935  :             if (INREG8(&m_pOTG->pUsbGenRegs->DevCtl) & DEVCTL_HOSTMODE)

  0071c	e5953150	 ldr         r3, [r5, #0x150]
  00720	e5932020	 ldr         r2, [r3, #0x20]
  00724	e5d23060	 ldrb        r3, [r2, #0x60]
  00728	e3130004	 tst         r3, #4

; 936  :                 SETREG8(&m_pOTG->pUsbGenRegs->Power, POWER_SUSPENDM/*|POWER_EN_SUSPENDM*/);

  0072c	15d23001	 ldrneb      r3, [r2, #1]
  00730	13833002	 orrne       r3, r3, #2
  00734	15c23001	 strneb      r3, [r2, #1]

; 937  :             else
; 938  :                 DEBUGMSG(ZONE_OTG_INFO, (TEXT("Device Mode cannot set Suspend Bit\r\n")));
; 939  :             bReturn = TRUE;
; 940  :             LeaveCriticalSection(&m_pOTG->regCS);

  00738	e5953150	 ldr         r3, [r5, #0x150]
  0073c	e3a06001	 mov         r6, #1
  00740	e2830038	 add         r0, r3, #0x38
  00744	eb000000	 bl          LeaveCriticalSection

; 941  :             if (rc == TRUE)

  00748	e3540001	 cmp         r4, #1
  0074c	1a000064	 bne         |$LN86@IOControl|

; 942  :                 StopUSBClock();

  00750	e5953000	 ldr         r3, [r5]
  00754	e1a00005	 mov         r0, r5
  00758	e59330e8	 ldr         r3, [r3, #0xE8]
  0075c	e1a0e00f	 mov         lr, pc
  00760	e12fff13	 bx          r3

; 943  :             break;

  00764	ea00005e	 b           |$LN86@IOControl|
  00768		 |$LN50@IOControl|

; 828  :                 }
; 829  :             }
; 830  :             break;
; 831  : 
; 832  :         case IOCTL_POWER_GET:
; 833  :             if (pBufOut != NULL && dwLenOut >= sizeof(CEDEVICE_POWER_STATE))

  00768	e59b2000	 ldr         r2, [r11]
  0076c	e3520000	 cmp         r2, #0
  00770	0a00005b	 beq         |$LN86@IOControl|
  00774	e59b3004	 ldr         r3, [r11, #4]
  00778	e3530004	 cmp         r3, #4
  0077c	3a000058	 bcc         |$LN86@IOControl|
  00780		 |$LN91@IOControl|

; 834  :             {
; 835  :                 __try
; 836  :                 {
; 837  :                     *(PCEDEVICE_POWER_STATE)pBufOut = m_Dx;

  00780	e59530f4	 ldr         r3, [r5, #0xF4]
  00784	e5823000	 str         r3, [r2]

; 838  : 
; 839  :                     bReturn = TRUE;

  00788	e3a06001	 mov         r6, #1
  0078c	e50b6024	 str         r6, [r11, #-0x24]
  00790		 |$LN92@IOControl|

; 840  : 
; 841  :                     DEBUGMSG(ZONE_OTG_INFO, (L"USBOTG: IOCTL_POWER_GET to D%u \r\n", m_Dx));
; 842  :                 }

  00790	ea000053	 b           |$LN86@IOControl|
  00794		 |$LN88@IOControl|

; 844  :                 {
; 845  :                     RETAILMSG(1, (L"Exception in ioctl\r\n"));

  00794	e59f01a8	 ldr         r0, [pc, #0x1A8]
  00798	eb000000	 bl          NKDbgPrintfW
  0079c	e51b6024	 ldr         r6, [r11, #-0x24]
  007a0	ea00004f	 b           |$LN86@IOControl|
  007a4		 |$LN71@IOControl|

; 777  :     BOOL rc = FALSE;
; 778  : 
; 779  :     switch (dwCode)

  007a4	e59f31a8	 ldr         r3, [pc, #0x1A8]
  007a8	e15e0003	 cmp         lr, r3
  007ac	0a00002c	 beq         |$LN53@IOControl|
  007b0	e59f3198	 ldr         r3, [pc, #0x198]
  007b4	e15e0003	 cmp         lr, r3
  007b8	0a00001a	 beq         |$LN47@IOControl|
  007bc	e59f3188	 ldr         r3, [pc, #0x188]
  007c0	e15e0003	 cmp         lr, r3
  007c4	0a000015	 beq         |$LN43@IOControl|
  007c8	e59f3178	 ldr         r3, [pc, #0x178]
  007cc	e15e0003	 cmp         lr, r3
  007d0	0a00000c	 beq         |$LN2@IOControl|
  007d4		 |$LN1@IOControl|

; 1087 : 
; 1088 :         default:
; 1089 :             DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("USBOTG::IOControl (0x%x)\r\n"), dwCode));
; 1090 :             bReturn = USBOTG::IOControl(dwCode, pBufIn, dwLenIn, pBufOut, dwLenOut, pdwActualOut);

  007d4	e59b3008	 ldr         r3, [r11, #8]
  007d8	e59b2004	 ldr         r2, [r11, #4]
  007dc	e59b1000	 ldr         r1, [r11]
  007e0	e58d3008	 str         r3, [sp, #8]
  007e4	e58d2004	 str         r2, [sp, #4]
  007e8	e58d1000	 str         r1, [sp]
  007ec	e1a03004	 mov         r3, r4
  007f0	e1a02007	 mov         r2, r7
  007f4	e1a0100e	 mov         r1, lr
  007f8	e1a00005	 mov         r0, r5
  007fc	eb000000	 bl          |?IOControl@USBOTG@@UAAHKPAEK0KPAK@Z|
  00800	e1a06000	 mov         r6, r0
  00804	ea000036	 b           |$LN86@IOControl|
  00808		 |$LN2@IOControl|

; 1082 : 
; 1083 :         case IOCTL_CONTEXT_RESTORE:
; 1084 :             DEBUGMSG(ZONE_OTG_INFO, (TEXT("USB OTG context restore\r\n")));
; 1085 :             ContextRestore();

  00808	e5953000	 ldr         r3, [r5]
  0080c	e1a00005	 mov         r0, r5
  00810	e5933100	 ldr         r3, [r3, #0x100]
  00814	e1a0e00f	 mov         lr, pc
  00818	e12fff13	 bx          r3

; 1086 :             break;

  0081c	ea000030	 b           |$LN86@IOControl|
  00820		 |$LN43@IOControl|

; 871  :                 }
; 872  :             }
; 873  :             break;
; 874  : 
; 875  :         case IOCTL_REGISTER_POWER_RELATIONSHIP:
; 876  :             bReturn = TRUE;

  00820	e3a06001	 mov         r6, #1

; 877  :             break;

  00824	ea00002e	 b           |$LN86@IOControl|
  00828		 |$LN47@IOControl|

; 846  :                 }
; 847  :             }
; 848  :             break;
; 849  : 
; 850  :         case IOCTL_POWER_QUERY:
; 851  :             if (pBufOut && dwLenOut >= sizeof(CEDEVICE_POWER_STATE))

  00828	e59b2000	 ldr         r2, [r11]
  0082c	e3520000	 cmp         r2, #0
  00830	0a00002b	 beq         |$LN86@IOControl|
  00834	e59b3004	 ldr         r3, [r11, #4]
  00838	e3530004	 cmp         r3, #4
  0083c	3a000028	 bcc         |$LN86@IOControl|
  00840		 |$LN98@IOControl|

; 852  :             {
; 853  :             // Return a good status on any valid query, since we are
; 854  :             // always ready to change power states (if asked for state
; 855  :             // we don't support, we move to next highest, eg D3->D4).
; 856  :                 __try
; 857  :                 {
; 858  :                     CEDEVICE_POWER_STATE ReqDx = *(PCEDEVICE_POWER_STATE)pBufOut;

  00840	e5923000	 ldr         r3, [r2]

; 859  : 
; 860  :                     if (VALID_DX(ReqDx))

  00844	e3530004	 cmp         r3, #4

; 861  :                     {
; 862  :                     // This is a valid Dx state so return a good status.
; 863  :                         bReturn = TRUE;

  00848	93a06001	 movls       r6, #1
  0084c	950b6024	 strls       r6, [r11, #-0x24]
  00850		 |$LN99@IOControl|

; 864  :                     }
; 865  : 
; 866  :                     DEBUGMSG(ZONE_OTG_INFO, (L"USBOTG: IOCTL_POWER_QUERY %d\r\n", ReqDx));
; 867  :                 }

  00850	ea000023	 b           |$LN86@IOControl|
  00854		 |$LN95@IOControl|

; 869  :                 {
; 870  :                     RETAILMSG(1, (L"Exception in ioctl\r\n"));

  00854	e59f00e8	 ldr         r0, [pc, #0xE8]
  00858	eb000000	 bl          NKDbgPrintfW
  0085c	e51b6024	 ldr         r6, [r11, #-0x24]
  00860	ea00001f	 b           |$LN86@IOControl|
  00864		 |$LN53@IOControl|

; 799  :                 }
; 800  :             }
; 801  :             break;
; 802  :             
; 803  :         case IOCTL_POWER_SET:
; 804  :             
; 805  :             if (pBufOut && dwLenOut >= sizeof(CEDEVICE_POWER_STATE))

  00864	e59b4000	 ldr         r4, [r11]
  00868	e3540000	 cmp         r4, #0
  0086c	0a00001c	 beq         |$LN86@IOControl|
  00870	e59b3004	 ldr         r3, [r11, #4]
  00874	e3530004	 cmp         r3, #4
  00878	3a000019	 bcc         |$LN86@IOControl|
  0087c		 |$LN84@IOControl|

; 806  :             {
; 807  :                 __try
; 808  :                 {
; 809  :                     CEDEVICE_POWER_STATE ReqDx = *(PCEDEVICE_POWER_STATE)pBufOut;

  0087c	e5943000	 ldr         r3, [r4]

; 810  : 
; 811  :                     m_Dx = ReqDx;
; 812  :                     m_fPowerRequest = TRUE;
; 813  : 
; 814  :                     DEBUGMSG(1, (TEXT("OTG IOCTL_POWER_SET D%d\r\n"), ReqDx));
; 815  :                     ResetEvent(m_pOTG->hPowerEvent);

  00880	e3a01002	 mov         r1, #2
  00884	e58530f4	 str         r3, [r5, #0xF4]
  00888	e3a06001	 mov         r6, #1
  0088c	e58561a0	 str         r6, [r5, #0x1A0]
  00890	e5953150	 ldr         r3, [r5, #0x150]
  00894	e5930058	 ldr         r0, [r3, #0x58]
  00898	eb000000	 bl          EventModify

; 816  :                     SetInterruptEvent(m_dwSysIntr);

  0089c	e5950144	 ldr         r0, [r5, #0x144]
  008a0	eb000000	 bl          SetInterruptEvent

; 817  :                     WaitForSingleObject(m_pOTG->hPowerEvent, INFINITE);

  008a4	e5953150	 ldr         r3, [r5, #0x150]
  008a8	e3e01000	 mvn         r1, #0
  008ac	e5930058	 ldr         r0, [r3, #0x58]
  008b0	eb000000	 bl          WaitForSingleObject

; 818  : 
; 819  :                     *(PCEDEVICE_POWER_STATE)pBufOut = m_Dx;

  008b4	e59530f4	 ldr         r3, [r5, #0xF4]

; 820  :                     *pdwActualOut = sizeof(CEDEVICE_POWER_STATE);

  008b8	e59b2008	 ldr         r2, [r11, #8]
  008bc	e3a01004	 mov         r1, #4
  008c0	e5843000	 str         r3, [r4]
  008c4	e5821000	 str         r1, [r2]

; 821  :                     bReturn = TRUE;

  008c8	e50b6024	 str         r6, [r11, #-0x24]
  008cc		 |$LN85@IOControl|

; 822  : 
; 823  : 
; 824  :                 }

  008cc	ea000004	 b           |$LN86@IOControl|
  008d0		 |$LN81@IOControl|

; 826  :                 {
; 827  :                     RETAILMSG(1, (L"Exception in ioctl\r\n"));

  008d0	e59f006c	 ldr         r0, [pc, #0x6C]
  008d4	eb000000	 bl          NKDbgPrintfW
  008d8	e51b6024	 ldr         r6, [r11, #-0x24]
  008dc	ea000000	 b           |$LN86@IOControl|
  008e0		 |$LN111@IOControl|

; 1091 :     }
; 1092 : 
; 1093 :     return bReturn;

  008e0	e51b6020	 ldr         r6, [r11, #-0x20]
  008e4		 |$LN86@IOControl|

; 1094 : }

  008e4	e1a00006	 mov         r0, r6
  008e8	e24bd01c	 sub         sp, r11, #0x1C
  008ec	e89d68f0	 ldmia       sp, {r4 - r7, r11, sp, lr}
  008f0	e12fff1e	 bx          lr

			 ENDP  ; |?IOControl@OMAPMHSUSBOTG@@UAAHKPAEK0KPAK@Z|, OMAPMHSUSBOTG::IOControl

  008f4		 |$LN80@IOControl|
  008f4		 |$LN115@IOControl|

; 825  :                 __except(EXCEPTION_EXECUTE_HANDLER)

  008f4	e52de004	 str         lr, [sp, #-4]!
  008f8	e24dd00c	 sub         sp, sp, #0xC
  008fc		 |$LN83@IOControl|
  008fc		 |$LN121@IOControl|
  008fc	e3a00001	 mov         r0, #1
  00900		 |$LN82@IOControl|
  00900	e28dd00c	 add         sp, sp, #0xC
  00904	e49df004	 ldr         pc, [sp], #4
  00908		 |$LN122@IOControl|
  00908		 |$LN94@IOControl|
  00908		 |$LN117@IOControl|

; 868  :                 __except(EXCEPTION_EXECUTE_HANDLER)

  00908	e52de004	 str         lr, [sp, #-4]!
  0090c	e24dd00c	 sub         sp, sp, #0xC
  00910		 |$LN97@IOControl|
  00910		 |$LN123@IOControl|
  00910	e3a00001	 mov         r0, #1
  00914		 |$LN96@IOControl|
  00914	e28dd00c	 add         sp, sp, #0xC
  00918	e49df004	 ldr         pc, [sp], #4
  0091c		 |$LN124@IOControl|
  0091c		 |$LN87@IOControl|
  0091c		 |$LN118@IOControl|

; 843  :                 __except(EXCEPTION_EXECUTE_HANDLER)

  0091c	e52de004	 str         lr, [sp, #-4]!
  00920	e24dd00c	 sub         sp, sp, #0xC
  00924		 |$LN90@IOControl|
  00924		 |$LN125@IOControl|
  00924	e3a00001	 mov         r0, #1
  00928		 |$LN89@IOControl|
  00928	e28dd00c	 add         sp, sp, #0xC
  0092c	e49df004	 ldr         pc, [sp], #4
  00930		 |$LN126@IOControl|
  00930		 |$LN73@IOControl|
  00930		 |$LN119@IOControl|

; 796  :                 __except(EXCEPTION_EXECUTE_HANDLER)

  00930	e52de004	 str         lr, [sp, #-4]!
  00934	e24dd00c	 sub         sp, sp, #0xC
  00938		 |$LN76@IOControl|
  00938		 |$LN127@IOControl|
  00938	e3a00001	 mov         r0, #1
  0093c		 |$LN75@IOControl|
  0093c	e28dd00c	 add         sp, sp, #0xC
  00940	e49df004	 ldr         pc, [sp], #4
  00944		 |$LN129@IOControl|
  00944		 |$LN130@IOControl|
  00944	00000000	 DCD         |??_C@_1CK@OBPLBNBH@?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@|
  00948		 |$LN131@IOControl|
  00948	80038140	 DCD         0x80038140
  0094c		 |$LN132@IOControl|
  0094c	00321018	 DCD         0x321018
  00950		 |$LN133@IOControl|
  00950	0032100c	 DCD         0x32100c
  00954		 |$LN134@IOControl|
  00954	00321008	 DCD         0x321008
  00958		 |$LN135@IOControl|
  00958	00000000	 DCD         |??_C@_1CK@MHJHMPML@?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@|
  0095c		 |$LN136@IOControl|
  0095c	002a0418	 DCD         0x2a0418
  00960		 |$LN137@IOControl|
  00960	002a0414	 DCD         0x2a0414
  00964		 |$LN138@IOControl|
  00964	00321004	 DCD         0x321004
  00968		 |$LN139@IOControl|
  00968	00222024	 DCD         0x222024
  0096c		 |$LN140@IOControl|
  0096c	00222020	 DCD         0x222020
  00970		 |$LN141@IOControl|
  00970	0022201c	 DCD         0x22201c
  00974		 |$LN142@IOControl|
  00974	00222018	 DCD         0x222018
  00978		 |$LN143@IOControl|
  00978	00222010	 DCD         0x222010
  0097c		 |$LN144@IOControl|
  0097c	0022200c	 DCD         0x22200c
  00980		 |$LN145@IOControl|
  00980	00222008	 DCD         0x222008
  00984		 |$LN146@IOControl|
  00984	00222004	 DCD         0x222004
  00988		 |$LN147@IOControl|
  00988	00222014	 DCD         0x222014
  0098c		 |$LN148@IOControl|
  0098c	002a040c	 DCD         0x2a040c
  00990		 |$LN128@IOControl|
  00990		 |$LN120@IOControl|
	EXPORT	|?LoadUnloadUSBFN@OMAPMHSUSBOTG@@UAAHH@Z| ; OMAPMHSUSBOTG::LoadUnloadUSBFN
	IMPORT	|?LoadUnloadUSBFN@USBOTG@@UAAHH@Z|	; USBOTG::LoadUnloadUSBFN

  00000			 AREA	 |.pdata|, PDATA
|$T43060| DCD	|$LN5@LoadUnload|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?LoadUnloadUSBFN@OMAPMHSUSBOTG@@UAAHH@Z| PROC ; OMAPMHSUSBOTG::LoadUnloadUSBFN

; 1114 : {

  00000		 |$LN5@LoadUnload|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43057|

; 1115 :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("OMAPMHSUSBOTG: LoadUnloadUSBFN\r\n")));
; 1116 :     BOOL bReturn = USBOTG::LoadUnloadUSBFN(fLoad);

  00004	eb000000	 bl          |?LoadUnloadUSBFN@USBOTG@@UAAHH@Z|

; 1117 :     return bReturn;
; 1118 : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M43058|

			 ENDP  ; |?LoadUnloadUSBFN@OMAPMHSUSBOTG@@UAAHH@Z|, OMAPMHSUSBOTG::LoadUnloadUSBFN

	EXPORT	|?LoadUnloadHCD@OMAPMHSUSBOTG@@UAAHH@Z|	; OMAPMHSUSBOTG::LoadUnloadHCD
	IMPORT	|?LoadUnloadHCD@USBOTG@@UAAHH@Z|	; USBOTG::LoadUnloadHCD

  00000			 AREA	 |.pdata|, PDATA
|$T43071| DCD	|$LN5@LoadUnload@2|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?LoadUnloadHCD@OMAPMHSUSBOTG@@UAAHH@Z| PROC ; OMAPMHSUSBOTG::LoadUnloadHCD

; 1138 : {

  00000		 |$LN5@LoadUnload@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43068|

; 1139 :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("LoadUnloadHCD\r\n")));
; 1140 :     BOOL bReturn = USBOTG::LoadUnloadHCD(fLoad);

  00004	eb000000	 bl          |?LoadUnloadHCD@USBOTG@@UAAHH@Z|

; 1141 :     return bReturn;
; 1142 : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M43069|

			 ENDP  ; |?LoadUnloadHCD@OMAPMHSUSBOTG@@UAAHH@Z|, OMAPMHSUSBOTG::LoadUnloadHCD

	EXPORT	|?OTGUSBFNNotfyActive@OMAPMHSUSBOTG@@UAAHPBGH@Z| ; OMAPMHSUSBOTG::OTGUSBFNNotfyActive
	IMPORT	|?OTGUSBFNNotfyActive@USBOTG@@UAAHPBGH@Z| ; USBOTG::OTGUSBFNNotfyActive

  00000			 AREA	 |.pdata|, PDATA
|$T43083| DCD	|$LN5@OTGUSBFNNo|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OTGUSBFNNotfyActive@OMAPMHSUSBOTG@@UAAHPBGH@Z| PROC ; OMAPMHSUSBOTG::OTGUSBFNNotfyActive

; 1164 : { 

  00000		 |$LN5@OTGUSBFNNo|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43080|

; 1165 :     // Work around needs this function. OTG can't set loc_conn before USBFN Ready.
; 1166 :     BOOL bReturn = USBOTG:: OTGUSBFNNotfyActive(lpDeviceName, fActive);

  00004	eb000000	 bl          |?OTGUSBFNNotfyActive@USBOTG@@UAAHPBGH@Z|

; 1167 :     return bReturn;
; 1168 : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M43081|

			 ENDP  ; |?OTGUSBFNNotfyActive@OMAPMHSUSBOTG@@UAAHPBGH@Z|, OMAPMHSUSBOTG::OTGUSBFNNotfyActive

	EXPORT	|?OTGHCDNotfyAccept@OMAPMHSUSBOTG@@UAAHPBGH@Z| ; OMAPMHSUSBOTG::OTGHCDNotfyAccept
	IMPORT	|?OTGHCDNotfyAccept@USBOTG@@UAAHPBGH@Z|	; USBOTG::OTGHCDNotfyAccept

  00000			 AREA	 |.pdata|, PDATA
|$T43095| DCD	|$LN5@OTGHCDNotf|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OTGHCDNotfyAccept@OMAPMHSUSBOTG@@UAAHPBGH@Z| PROC ; OMAPMHSUSBOTG::OTGHCDNotfyAccept

; 1190 : {

  00000		 |$LN5@OTGHCDNotf|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43092|

; 1191 :     BOOL bReturn = USBOTG:: OTGHCDNotfyAccept(lpDeviceName, fActive);

  00004	eb000000	 bl          |?OTGHCDNotfyAccept@USBOTG@@UAAHPBGH@Z|

; 1192 :     return bReturn;
; 1193 : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M43093|

			 ENDP  ; |?OTGHCDNotfyAccept@OMAPMHSUSBOTG@@UAAHPBGH@Z|, OMAPMHSUSBOTG::OTGHCDNotfyAccept

	EXPORT	|?UsbOtgConfigure@OMAPMHSUSBOTG@@UAA?AW4USBOTG_MODE@@W42@@Z| ; OMAPMHSUSBOTG::UsbOtgConfigure

  00000			 AREA	 |.pdata|, PDATA
|$T43104| DCD	|$LN5@UsbOtgConf|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UsbOtgConfigure@OMAPMHSUSBOTG@@UAA?AW4USBOTG_MODE@@W42@@Z| PROC ; OMAPMHSUSBOTG::UsbOtgConfigure

; 1213 : {

  00000		 |$LN5@UsbOtgConf|
  00000		 |$M43101|

; 1214 :     usbOtgMode = USBOTG_Bidirection;
; 1215 :     return usbOtgMode;

  00000	e3a00001	 mov         r0, #1

; 1216 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M43102|

			 ENDP  ; |?UsbOtgConfigure@OMAPMHSUSBOTG@@UAA?AW4USBOTG_MODE@@W42@@Z|, OMAPMHSUSBOTG::UsbOtgConfigure

	EXPORT	|?UpdateInput@OMAPMHSUSBOTG@@UAAHXZ|	; OMAPMHSUSBOTG::UpdateInput

  00000			 AREA	 |.pdata|, PDATA
|$T43125| DCD	|$LN14@UpdateInpu|
	DCD	0x40003801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdateInput@OMAPMHSUSBOTG@@UAAHXZ| PROC ; OMAPMHSUSBOTG::UpdateInput

; 1236 : {

  00000		 |$LN14@UpdateInpu|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M43122|
  00004	e1a04000	 mov         r4, r0

; 1237 :     BOOL rc = FALSE;
; 1238 : 
; 1239 :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("USBOTG::UpdateInput called\r\n")));
; 1240 :     rc = StartUSBClock(TRUE);

  00008	e5943000	 ldr         r3, [r4]
  0000c	e3a01001	 mov         r1, #1
  00010	e59330e4	 ldr         r3, [r3, #0xE4]
  00014	e1a0e00f	 mov         lr, pc
  00018	e12fff13	 bx          r3

; 1241 :     UCHAR devctl = INREG8(&m_pOTG->pUsbGenRegs->DevCtl);

  0001c	e594e150	 ldr         lr, [r4, #0x150]
  00020	e59e3020	 ldr         r3, [lr, #0x20]
  00024	e5d35060	 ldrb        r5, [r3, #0x60]

; 1242 :     UCHAR vbus = (devctl & DEVCTL_VBUS) >> 3;
; 1243 : 
; 1244 :     // Check the a_conn and b_conn
; 1245 :     //m_UsbOtgInput.bit.a_conn = (m_pOTG->operateMode == HOST_MODE)? 1:0;
; 1246 :     //m_UsbOtgInput.bit.b_conn = (m_pOTG->operateMode == DEVICE_MODE)? 1:0;
; 1247 :     // Read the Power register to determine the valid session
; 1248 :     //DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("VBus value = 0x%x\r\n")));
; 1249 :     // Dual Role B-Device 6.8.2    
; 1250 :     m_UsbOtgInput.bit.b_bus_req = ((devctl & DEVCTL_SESSION)?1:0);

  00028	e20530ff	 and         r3, r5, #0xFF
  0002c	e2136001	 ands        r6, r3, #1
  00030	e594304c	 ldr         r3, [r4, #0x4C]
  00034	e2052018	 and         r2, r5, #0x18
  00038	13a01001	 movne       r1, #1
  0003c	e1a071a2	 mov         r7, r2, lsr #3
  00040	03a01000	 moveq       r1, #0
  00044	e1a02003	 mov         r2, r3

; 1251 :     m_UsbOtgInput.bit.id = ((devctl & DEVCTL_B_DEVICE)? 1:0);    

  00048	e0233401	 eor         r3, r3, r1, lsl #8
  0004c	e2033c01	 and         r3, r3, #1, 24
  00050	e3150080	 tst         r5, #0x80
  00054	e0232002	 eor         r2, r3, r2
  00058	13a03001	 movne       r3, #1
  0005c	03a03000	 moveq       r3, #0
  00060	e0223783	 eor         r3, r2, r3, lsl #15
  00064	e2033902	 and         r3, r3, #2, 18
  00068	e584204c	 str         r2, [r4, #0x4C]
  0006c	e0232002	 eor         r2, r3, r2
  00070	e584204c	 str         r2, [r4, #0x4C]

; 1252 :     m_UsbOtgInput.bit.b_sess_vld = (((devctl & DEVCTL_SESSION) && (m_pOTG->operateMode == DEVICE_MODE))? 1:0);

  00074	e3560000	 cmp         r6, #0
  00078	0a000003	 beq         |$LN8@UpdateInpu|
  0007c	e5de3035	 ldrb        r3, [lr, #0x35]
  00080	e3530001	 cmp         r3, #1
  00084	03a03001	 moveq       r3, #1
  00088	0a000000	 beq         |$LN9@UpdateInpu|
  0008c		 |$LN8@UpdateInpu|
  0008c	e3a03000	 mov         r3, #0
  00090		 |$LN9@UpdateInpu|
  00090	e0223703	 eor         r3, r2, r3, lsl #14
  00094	e2033901	 and         r3, r3, #1, 18

; 1253 : 
; 1254 :     // Dual Role A-Device 6.8.2
; 1255 :     m_UsbOtgInput.bit.a_vbus_vld = ((vbus>=0x2)?1:0);

  00098	e3570002	 cmp         r7, #2
  0009c	e0232002	 eor         r2, r3, r2
  000a0	23a03001	 movcs       r3, #1
  000a4	33a03000	 movcc       r3, #0
  000a8	e0223383	 eor         r3, r2, r3, lsl #7
  000ac	e2033080	 and         r3, r3, #0x80
  000b0	e0233002	 eor         r3, r3, r2
  000b4	e584204c	 str         r2, [r4, #0x4C]

; 1256 :     //m_UsbOtgInput.bit.a_bus_req = 
; 1257 : 
; 1258 :     if (rc == TRUE)

  000b8	e3500001	 cmp         r0, #1
  000bc	e584304c	 str         r3, [r4, #0x4C]

; 1259 :         StopUSBClock();

  000c0	05943000	 ldreq       r3, [r4]
  000c4	01a00004	 moveq       r0, r4
  000c8	059330e8	 ldreq       r3, [r3, #0xE8]
  000cc	01a0e00f	 moveq       lr, pc
  000d0	012fff13	 bxeq        r3

; 1260 :     
; 1261 :     return TRUE;

  000d4	e3a00001	 mov         r0, #1

; 1262 : }

  000d8	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000dc	e12fff1e	 bx          lr
  000e0		 |$M43123|

			 ENDP  ; |?UpdateInput@OMAPMHSUSBOTG@@UAAHXZ|, OMAPMHSUSBOTG::UpdateInput

	EXPORT	|?IsSE0@OMAPMHSUSBOTG@@UAAHXZ|		; OMAPMHSUSBOTG::IsSE0

  00000			 AREA	 |.pdata|, PDATA
|$T43137| DCD	|$LN6@IsSE0|
	DCD	0x40001801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsSE0@OMAPMHSUSBOTG@@UAAHXZ| PROC	; OMAPMHSUSBOTG::IsSE0

; 1282 : {

  00000		 |$LN6@IsSE0|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M43134|
  00004	e1a05000	 mov         r5, r0

; 1283 :     BOOL bIsSE0;
; 1284 :     BOOL rc = FALSE;
; 1285 :     
; 1286 :     rc = StartUSBClock(TRUE);

  00008	e5953000	 ldr         r3, [r5]
  0000c	e3a01001	 mov         r1, #1
  00010	e59330e4	 ldr         r3, [r3, #0xE4]
  00014	e1a0e00f	 mov         lr, pc
  00018	e12fff13	 bx          r3

; 1287 :     bIsSE0 = m_pTransceiver->IsSE0();

  0001c	e59520fc	 ldr         r2, [r5, #0xFC]
  00020	e1a04000	 mov         r4, r0
  00024	e5923000	 ldr         r3, [r2]
  00028	e1a00002	 mov         r0, r2
  0002c	e593301c	 ldr         r3, [r3, #0x1C]
  00030	e1a0e00f	 mov         lr, pc
  00034	e12fff13	 bx          r3

; 1288 :     if (rc == TRUE)

  00038	e3540001	 cmp         r4, #1

; 1289 :         StopUSBClock();

  0003c	05953000	 ldreq       r3, [r5]
  00040	e1a06000	 mov         r6, r0
  00044	01a00005	 moveq       r0, r5
  00048	059330e8	 ldreq       r3, [r3, #0xE8]
  0004c	01a0e00f	 moveq       lr, pc
  00050	012fff13	 bxeq        r3

; 1290 : 
; 1291 :     DEBUGMSG(ZONE_OTG_INFO, (TEXT("IsSE0 returning %d\r\n"), bIsSE0));
; 1292 : 
; 1293 :     return bIsSE0;
; 1294 : }

  00054	e1a00006	 mov         r0, r6
  00058	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$M43135|

			 ENDP  ; |?IsSE0@OMAPMHSUSBOTG@@UAAHXZ|, OMAPMHSUSBOTG::IsSE0

	EXPORT	|?NewStateAction@OMAPMHSUSBOTG@@UAAHW4USBOTG_STATES@@T_USBOTG_OUTPUT@@@Z| ; OMAPMHSUSBOTG::NewStateAction
	IMPORT	|?NewStateAction@USBOTG@@UAAHW4USBOTG_STATES@@T_USBOTG_OUTPUT@@@Z| ; USBOTG::NewStateAction

  00000			 AREA	 |.pdata|, PDATA
|$T43149| DCD	|$LN5@NewStateAc|
	DCD	0x40000603
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?NewStateAction@OMAPMHSUSBOTG@@UAAHW4USBOTG_STATES@@T_USBOTG_OUTPUT@@@Z| PROC ; OMAPMHSUSBOTG::NewStateAction

; 1314 : {

  00000		 |$LN5@NewStateAc|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c		 |$M43146|

; 1315 :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("NewStateAction\r\n")));
; 1316 :     BOOL bReturn = USBOTG::NewStateAction(usbOtgState,usbOtgOutput);

  0000c	eb000000	 bl          |?NewStateAction@USBOTG@@UAAHW4USBOTG_STATES@@T_USBOTG_OUTPUT@@@Z|

; 1317 :     
; 1318 :     // Process extra state action if needed.
; 1319 : 
; 1320 :     return bReturn;
; 1321 : }

  00010	e89d6000	 ldmia       sp, {sp, lr}
  00014	e12fff1e	 bx          lr
  00018		 |$M43147|

			 ENDP  ; |?NewStateAction@OMAPMHSUSBOTG@@UAAHW4USBOTG_STATES@@T_USBOTG_OUTPUT@@@Z|, OMAPMHSUSBOTG::NewStateAction

	EXPORT	|?EventNotification@OMAPMHSUSBOTG@@UAAHXZ| ; OMAPMHSUSBOTG::EventNotification
	IMPORT	|?EventNotification@USBOTG@@UAAHXZ|	; USBOTG::EventNotification

  00000			 AREA	 |.pdata|, PDATA
|$T43159| DCD	|$LN5@EventNotif|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?EventNotification@OMAPMHSUSBOTG@@UAAHXZ| PROC ; OMAPMHSUSBOTG::EventNotification

; 1342 : {

  00000		 |$LN5@EventNotif|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43156|

; 1343 :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("EventNotification called\r\n")));
; 1344 :     BOOL bReturn = USBOTG::EventNotification();

  00004	eb000000	 bl          |?EventNotification@USBOTG@@UAAHXZ|

; 1345 : 
; 1346 :     return bReturn;
; 1347 : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M43157|

			 ENDP  ; |?EventNotification@OMAPMHSUSBOTG@@UAAHXZ|, OMAPMHSUSBOTG::EventNotification

	EXPORT	|?SessionRequest@OMAPMHSUSBOTG@@UAAHHH@Z| ; OMAPMHSUSBOTG::SessionRequest

  00000			 AREA	 |.pdata|, PDATA
|$T43172| DCD	|$LN9@SessionReq|
	DCD	0x40001801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SessionRequest@OMAPMHSUSBOTG@@UAAHHH@Z| PROC ; OMAPMHSUSBOTG::SessionRequest

; 1368 : {   

  00000		 |$LN9@SessionReq|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M43169|
  00004	e3510000	 cmp         r1, #0
  00008	e1a04000	 mov         r4, r0

; 1369 :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Session Request(%d, %d)\r\n"), fPulseLocConn, fPulseChrgVBus));
; 1370 :     if (fPulseLocConn || fPulseChrgVBus)

  0000c	03520000	 cmpeq       r2, #0

; 1376 :     }
; 1377 :     else
; 1378 :     {
; 1379 :         CLRREG8(&m_pOTG->pUsbGenRegs->DevCtl, DEVCTL_SESSION);

  00010	05943150	 ldreq       r3, [r4, #0x150]
  00014	05932020	 ldreq       r2, [r3, #0x20]
  00018	05d23060	 ldreqb      r3, [r2, #0x60]
  0001c	020330fe	 andeq       r3, r3, #0xFE
  00020	0a00000a	 beq         |$LN6@SessionReq|
  00024	e5943150	 ldr         r3, [r4, #0x150]
  00028	e3a00064	 mov         r0, #0x64
  0002c	e5932020	 ldr         r2, [r3, #0x20]
  00030	e5d23060	 ldrb        r3, [r2, #0x60]
  00034	e3833001	 orr         r3, r3, #1
  00038	e5c23060	 strb        r3, [r2, #0x60]
  0003c	eb000000	 bl          Sleep
  00040	e5943150	 ldr         r3, [r4, #0x150]
  00044	e5932020	 ldr         r2, [r3, #0x20]
  00048	e5d23060	 ldrb        r3, [r2, #0x60]
  0004c	e3833001	 orr         r3, r3, #1
  00050		 |$LN6@SessionReq|

; 1371 :     {
; 1372 :         // (workaround) wait and set session bit again.  Otherwise, sometimes USB transceiver VBUS doesn't go to 5V.
; 1373 :         SETREG8(&m_pOTG->pUsbGenRegs->DevCtl, DEVCTL_SESSION);          
; 1374 :         Sleep(100);
; 1375 :         SETREG8(&m_pOTG->pUsbGenRegs->DevCtl, DEVCTL_SESSION);

  00050	e5c23060	 strb        r3, [r2, #0x60]

; 1380 :     }
; 1381 : 
; 1382 :     return TRUE;

  00054	e3a00001	 mov         r0, #1

; 1383 : }

  00058	e8bd4010	 ldmia       sp!, {r4, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$M43170|

			 ENDP  ; |?SessionRequest@OMAPMHSUSBOTG@@UAAHHH@Z|, OMAPMHSUSBOTG::SessionRequest

	EXPORT	|?GetMode@OMAPMHSUSBOTG@@UAAKXZ|	; OMAPMHSUSBOTG::GetMode

  00000			 AREA	 |.pdata|, PDATA
|$T43184| DCD	|$LN12@GetMode|
	DCD	0x40000f00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetMode@OMAPMHSUSBOTG@@UAAKXZ| PROC	; OMAPMHSUSBOTG::GetMode

; 1399 : {

  00000		 |$LN12@GetMode|
  00000		 |$M43181|

; 1400 :     DWORD mode;
; 1401 : 
; 1402 :     if (INREG8(&m_pOTG->pUsbGenRegs->DevCtl) & DEVCTL_HOSTMODE)

  00000	e5902150	 ldr         r2, [r0, #0x150]
  00004	e5923020	 ldr         r3, [r2, #0x20]
  00008	e5d33060	 ldrb        r3, [r3, #0x60]
  0000c	e3130004	 tst         r3, #4

; 1403 :     {
; 1404 :         if (m_pOTG->operateMode == HOST_MODE)

  00010	e5d23035	 ldrb        r3, [r2, #0x35]
  00014	0a000003	 beq         |$LN6@GetMode|
  00018	e3530002	 cmp         r3, #2
  0001c	1a000004	 bne         |$LN2@GetMode|

; 1405 :             mode = HOST_MODE;

  00020	e3a00002	 mov         r0, #2

; 1415 :     }
; 1416 : 
; 1417 :     return mode;
; 1418 : 
; 1419 : }

  00024	e12fff1e	 bx          lr
  00028		 |$LN6@GetMode|

; 1406 :         else
; 1407 :             mode = IDLE_MODE;
; 1408 :     }
; 1409 :     else
; 1410 :     {
; 1411 :         if (m_pOTG->operateMode == DEVICE_MODE)

  00028	e3530001	 cmp         r3, #1

; 1412 :             mode = DEVICE_MODE;

  0002c	03a00001	 moveq       r0, #1

; 1415 :     }
; 1416 : 
; 1417 :     return mode;
; 1418 : 
; 1419 : }

  00030	012fff1e	 bxeq        lr
  00034		 |$LN2@GetMode|

; 1413 :         else
; 1414 :             mode = IDLE_MODE;

  00034	e3a00000	 mov         r0, #0

; 1415 :     }
; 1416 : 
; 1417 :     return mode;
; 1418 : 
; 1419 : }

  00038	e12fff1e	 bx          lr
  0003c		 |$M43182|

			 ENDP  ; |?GetMode@OMAPMHSUSBOTG@@UAAKXZ|, OMAPMHSUSBOTG::GetMode

	EXPORT	|?PowerDownDisconnect@OMAPMHSUSBOTG@@UAAXXZ| ; OMAPMHSUSBOTG::PowerDownDisconnect

  00000			 AREA	 |.pdata|, PDATA
|$T43195| DCD	|$LN12@PowerDownD|
	DCD	0x40003101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PowerDownDisconnect@OMAPMHSUSBOTG@@UAAXXZ| PROC ; OMAPMHSUSBOTG::PowerDownDisconnect

; 1440 : {

  00000		 |$LN12@PowerDownD|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43192|
  00004	e1a04000	 mov         r4, r0

; 1441 :     DWORD dwPrevState;
; 1442 :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Disconnect detected\r\n")));
; 1443 :     m_bSessionDisable = FALSE;
; 1444 :     m_disconnected = TRUE;
; 1445 : 
; 1446 :     ResetEndPoints();

  00008	e5943000	 ldr         r3, [r4]
  0000c	e3a02001	 mov         r2, #1
  00010	e3a05000	 mov         r5, #0
  00014	e59330ec	 ldr         r3, [r3, #0xEC]
  00018	e584517c	 str         r5, [r4, #0x17C]
  0001c	e584218c	 str         r2, [r4, #0x18C]
  00020	e1a0e00f	 mov         lr, pc
  00024	e12fff13	 bx          r3

; 1447 :     // If we have done the disconnect, don't process anymore.
; 1448 :     if ((m_pOTG->connect_status & CONN_DC) == 0)

  00028	e5942150	 ldr         r2, [r4, #0x150]
  0002c	e5d2304c	 ldrb        r3, [r2, #0x4C]
  00030	e3130004	 tst         r3, #4

; 1449 :         m_dwStatus |= STATUS_DISCONN_REQUEST|STATUS_WAIT_HOST_DISCONN_COMPLETE;

  00034	e59430f8	 ldr         r3, [r4, #0xF8]
  00038	03833042	 orreq       r3, r3, #0x42

; 1450 :     else
; 1451 :     {
; 1452 :         m_dwStatus &= ~STATUS_WAIT_HOST_DISCONN_COMPLETE;

  0003c	13c33040	 bicne       r3, r3, #0x40

; 1453 :         m_dwStatus |= STATUS_DISCONN_COMPLETE;

  00040	13833008	 orrne       r3, r3, #8
  00044	e58430f8	 str         r3, [r4, #0xF8]

; 1454 :     }
; 1455 : 
; 1456 :     m_pOTG->operateMode = IDLE_MODE;

  00048	e5c25035	 strb        r5, [r2, #0x35]

; 1457 :     dwPrevState = m_pOTG->connect_status;

  0004c	e5942150	 ldr         r2, [r4, #0x150]
  00050	e5d2104c	 ldrb        r1, [r2, #0x4C]

; 1458 :     m_pOTG->connect_status &= ~CONN_CCS;

  00054	e20130fe	 and         r3, r1, #0xFE
  00058	e5c2304c	 strb        r3, [r2, #0x4C]

; 1459 : 
; 1460 :     if (dwPrevState & CONN_CCS)
; 1461 :         m_pOTG->connect_status |= CONN_CSC;

  0005c	e5942150	 ldr         r2, [r4, #0x150]
  00060	e3110001	 tst         r1, #1

; 1462 :     else
; 1463 :         m_pOTG->connect_status &= ~CONN_CSC;
; 1464 : 
; 1465 :     m_pTransceiver->SetVBusSource(TRUE);

  00064	e3a01001	 mov         r1, #1
  00068	e5d2304c	 ldrb        r3, [r2, #0x4C]
  0006c	13833002	 orrne       r3, r3, #2
  00070	020330fd	 andeq       r3, r3, #0xFD
  00074	e5c2304c	 strb        r3, [r2, #0x4C]
  00078	e59400fc	 ldr         r0, [r4, #0xFC]
  0007c	e5903000	 ldr         r3, [r0]
  00080	e5933004	 ldr         r3, [r3, #4]
  00084	e1a0e00f	 mov         lr, pc
  00088	e12fff13	 bx          r3

; 1466 : 
; 1467 :     if (m_pOTG->pFuncs[DEVICE_MODE-1] != NULL)

  0008c	e5940150	 ldr         r0, [r4, #0x150]
  00090	e5903008	 ldr         r3, [r0, #8]
  00094	e3530000	 cmp         r3, #0

; 1468 :         m_pOTG->pFuncs[DEVICE_MODE-1]->Disconnect((void *)m_pOTG);

  00098	15933018	 ldrne       r3, [r3, #0x18]
  0009c	11a0e00f	 movne       lr, pc
  000a0	112fff13	 bxne        r3

; 1469 : 
; 1470 :     SoftResetMUSBController();

  000a4	e5943000	 ldr         r3, [r4]
  000a8	e3a01000	 mov         r1, #0
  000ac	e1a00004	 mov         r0, r4
  000b0	e59330f8	 ldr         r3, [r3, #0xF8]
  000b4	e1a0e00f	 mov         lr, pc
  000b8	e12fff13	 bx          r3

; 1471 : }

  000bc	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000c0	e12fff1e	 bx          lr
  000c4		 |$M43193|

			 ENDP  ; |?PowerDownDisconnect@OMAPMHSUSBOTG@@UAAXXZ|, OMAPMHSUSBOTG::PowerDownDisconnect

	EXPORT	|?OTG_ProcessEPx@OMAPMHSUSBOTG@@UAAKEH@Z| ; OMAPMHSUSBOTG::OTG_ProcessEPx

  00000			 AREA	 |.pdata|, PDATA
|$T43210| DCD	|$LN13@OTG_Proces|
	DCD	0x40002d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OTG_ProcessEPx@OMAPMHSUSBOTG@@UAAKEH@Z| PROC ; OMAPMHSUSBOTG::OTG_ProcessEPx

; 1702 : {    

  00000		 |$LN13@OTG_Proces|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M43207|
  00004	e1a07002	 mov         r7, r2
  00008	e1a08001	 mov         r8, r1
  0000c	e1a06000	 mov         r6, r0

; 1703 :     DWORD dwStatus = 0;
; 1704 :     DWORD mode;
; 1705 : 
; 1706 :     DEBUGMSG(ZONE_OTG_FUNCTION,(TEXT("OTG_ProcessEPx for ep %d, isRx %d\r\n"), endpoint, isRx));
; 1707 :     // For testing purpose, just dump the value from FIFO
; 1708 :     if (GetMode() == DEVICE_MODE)

  00010	e5963000	 ldr         r3, [r6]
  00014	e3a05000	 mov         r5, #0
  00018	e59330e0	 ldr         r3, [r3, #0xE0]
  0001c	e1a0e00f	 mov         lr, pc
  00020	e12fff13	 bx          r3
  00024	e3500001	 cmp         r0, #1

; 1709 :     {
; 1710 :         DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("m_pOTG Device Mode = 0x%x\r\n"), m_pOTG->pFuncs[DEVICE_MODE-1]));
; 1711 :         mode = DEVICE_MODE;

  00028	03a04001	 moveq       r4, #1
  0002c	0a000007	 beq         |$LN4@OTG_Proces|

; 1712 :     }
; 1713 :     else if (GetMode() == HOST_MODE)

  00030	e5963000	 ldr         r3, [r6]
  00034	e1a00006	 mov         r0, r6
  00038	e59330e0	 ldr         r3, [r3, #0xE0]
  0003c	e1a0e00f	 mov         lr, pc
  00040	e12fff13	 bx          r3
  00044	e3500002	 cmp         r0, #2
  00048	1a000015	 bne         |$LN5@OTG_Proces|

; 1714 :     {        
; 1715 :         mode = HOST_MODE;

  0004c	e3a04002	 mov         r4, #2
  00050		 |$LN4@OTG_Proces|

; 1721 :     }
; 1722 : 
; 1723 :     if (m_pOTG->pFuncs[mode-1] != NULL)

  00050	e5963150	 ldr         r3, [r6, #0x150]
  00054	e0833104	 add         r3, r3, r4, lsl #2
  00058	e5933004	 ldr         r3, [r3, #4]
  0005c	e3530000	 cmp         r3, #0
  00060	0a000010	 beq         |$LN8@OTG_Proces|

; 1724 :     {   
; 1725 :         if (isRx)
; 1726 :             dwStatus = m_pOTG->pFuncs[mode-1]->ProcessEPx_RX((void *)m_pOTG, endpoint);

  00064	e5960150	 ldr         r0, [r6, #0x150]
  00068	e3570000	 cmp         r7, #0
  0006c	e1a01008	 mov         r1, r8
  00070	e0803104	 add         r3, r0, r4, lsl #2
  00074	e5933004	 ldr         r3, [r3, #4]
  00078	0a000004	 beq         |$LN2@OTG_Proces|
  0007c	e593300c	 ldr         r3, [r3, #0xC]
  00080	e1a0e00f	 mov         lr, pc
  00084	e12fff13	 bx          r3

; 1727 :         else
; 1728 :             dwStatus = m_pOTG->pFuncs[mode-1]->ProcessEPx_TX((void *)m_pOTG, endpoint);

  00088	e1a05000	 mov         r5, r0

; 1729 :     }
; 1730 :     return dwStatus;

  0008c	ea000005	 b           |$LN8@OTG_Proces|
  00090		 |$LN2@OTG_Proces|

; 1727 :         else
; 1728 :             dwStatus = m_pOTG->pFuncs[mode-1]->ProcessEPx_TX((void *)m_pOTG, endpoint);

  00090	e5933010	 ldr         r3, [r3, #0x10]
  00094	e1a0e00f	 mov         lr, pc
  00098	e12fff13	 bx          r3
  0009c	e1a05000	 mov         r5, r0

; 1729 :     }
; 1730 :     return dwStatus;

  000a0	ea000000	 b           |$LN8@OTG_Proces|
  000a4		 |$LN5@OTG_Proces|

; 1716 :     }
; 1717 :     else
; 1718 :     {
; 1719 :         DEBUGMSG(ZONE_OTG_INFO, (TEXT("Ignore EP %d (%s) interrupt\r\n"), endpoint, isRx?(TEXT("IN")):(TEXT("OUT"))));
; 1720 :         return 0;

  000a4	e3a05000	 mov         r5, #0
  000a8		 |$LN8@OTG_Proces|

; 1731 : }

  000a8	e1a00005	 mov         r0, r5
  000ac	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000b0	e12fff1e	 bx          lr
  000b4		 |$M43208|

			 ENDP  ; |?OTG_ProcessEPx@OMAPMHSUSBOTG@@UAAKEH@Z|, OMAPMHSUSBOTG::OTG_ProcessEPx

	EXPORT	|?OTG_ProcessEP0@OMAPMHSUSBOTG@@UAAKXZ|	; OMAPMHSUSBOTG::OTG_ProcessEP0

  00000			 AREA	 |.pdata|, PDATA
|$T43222| DCD	|$LN10@OTG_Proces@2|
	DCD	0x40002301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OTG_ProcessEP0@OMAPMHSUSBOTG@@UAAKXZ| PROC ; OMAPMHSUSBOTG::OTG_ProcessEP0

; 1750 : {    

  00000		 |$LN10@OTG_Proces@2|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43219|
  00004	e1a05000	 mov         r5, r0

; 1751 :     DWORD dwStatus = 0;
; 1752 :     DWORD mode;
; 1753 : 
; 1754 :     DEBUGMSG(ZONE_OTG_FUNCTION,(TEXT("OTG_ProcessEP0\r\n")));
; 1755 :     // For testing purpose, just dump the value from FIFO    
; 1756 :     if (GetMode() == DEVICE_MODE)

  00008	e5953000	 ldr         r3, [r5]
  0000c	e3a04000	 mov         r4, #0
  00010	e59330e0	 ldr         r3, [r3, #0xE0]
  00014	e1a0e00f	 mov         lr, pc
  00018	e12fff13	 bx          r3
  0001c	e3500001	 cmp         r0, #1

; 1757 :     {
; 1758 :         DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("OTG::CSR0 = 0x%x (device)\r\n"), INREG16(&m_pOTG->pUsbCsrRegs->ep[0].CSR.CSR0)));        
; 1759 :         mode = DEVICE_MODE;

  00020	03a02001	 moveq       r2, #1
  00024	0a000007	 beq         |$LN2@OTG_Proces@2|

; 1760 :     }
; 1761 :     else if (GetMode() == HOST_MODE)

  00028	e5953000	 ldr         r3, [r5]
  0002c	e1a00005	 mov         r0, r5
  00030	e59330e0	 ldr         r3, [r3, #0xE0]
  00034	e1a0e00f	 mov         lr, pc
  00038	e12fff13	 bx          r3
  0003c	e3500002	 cmp         r0, #2
  00040	1a00000d	 bne         |$LN3@OTG_Proces@2|

; 1762 :     {        
; 1763 :         DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("OTG::CSR0 = 0x%x (host)\r\n"), INREG16(&m_pOTG->pUsbCsrRegs->ep[0].CSR.CSR0)));      
; 1764 :         mode = HOST_MODE;

  00044	e3a02002	 mov         r2, #2
  00048		 |$LN2@OTG_Proces@2|

; 1770 :     }
; 1771 : 
; 1772 :     if (m_pOTG->pFuncs[mode-1] != NULL)

  00048	e5953150	 ldr         r3, [r5, #0x150]
  0004c	e0833102	 add         r3, r3, r2, lsl #2
  00050	e5933004	 ldr         r3, [r3, #4]
  00054	e3530000	 cmp         r3, #0
  00058	0a000008	 beq         |$LN6@OTG_Proces@2|

; 1773 :         dwStatus = m_pOTG->pFuncs[mode-1]->ProcessEP0((void *)m_pOTG);

  0005c	e5950150	 ldr         r0, [r5, #0x150]
  00060	e0803102	 add         r3, r0, r2, lsl #2
  00064	e5933004	 ldr         r3, [r3, #4]
  00068	e5933008	 ldr         r3, [r3, #8]
  0006c	e1a0e00f	 mov         lr, pc
  00070	e12fff13	 bx          r3
  00074	e1a04000	 mov         r4, r0

; 1774 : 
; 1775 :     return dwStatus;

  00078	ea000000	 b           |$LN6@OTG_Proces@2|
  0007c		 |$LN3@OTG_Proces@2|

; 1765 :     }
; 1766 :     else
; 1767 :     {
; 1768 :         DEBUGMSG(ZONE_OTG_INFO, (TEXT("EP0 interrupt ignore due to incorrect mode\r\n")));
; 1769 :         return 0;

  0007c	e3a04000	 mov         r4, #0
  00080		 |$LN6@OTG_Proces@2|

; 1776 : }

  00080	e1a00004	 mov         r0, r4
  00084	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$M43220|

			 ENDP  ; |?OTG_ProcessEP0@OMAPMHSUSBOTG@@UAAKXZ|, OMAPMHSUSBOTG::OTG_ProcessEP0

	EXPORT	|?OTG_ConfigISR_stage1@OMAPMHSUSBOTG@@UAAKXZ| ; OMAPMHSUSBOTG::OTG_ConfigISR_stage1
	EXPORT	|??_C@_1M@CKAHONI@?$AAB?$AAT?$AAY?$AAP?$AAE?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DM@GBENJPGN@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAB?$AAu?$AAi?$AAl?$AAt?$AAI?$AAn?$AA?2?$AAM?$AAU?$AAS?$AAB?$AAO?$AAT?$AAG?$AA?2?$AAU?$AAS?$AAB?$AAF?$AAN?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GG@GMJJEDKI@?$AAH?$AAN?$AAP?$AA?5?$AAs?$AAw?$AAi?$AAt?$AAc?$AAh?$AAi?$AAn?$AAg?$AA?5?$AAa?$AAn?$AAd?$AA?5?$AAn?$AAe?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAd?$AAi?$AAs?$AAc?$AAo?$AAn@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DO@OIHENEJP@?$AAU?$AAS?$AAB?$AA?5?$AAC?$AAo?$AAn?$AAn?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAH?$AAo?$AAs?$AAt?$AA?5?$AAS?$AAi?$AAd?$AAe?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GK@MJDDMGMO@?$AAV?$AAB?$AAu?$AAs?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AA?9?$AA?5?$AAO?$AAT?$AAG?$AA_?$AAH?$AAa?$AAn?$AAd?$AAl?$AAe?$AAV?$AAB?$AAu?$AAs?$AAE?$AAr?$AAr?$AAo?$AAr@| [ DATA ] ; `string'
	IMPORT	|RegSetValueExW|

  00000			 AREA	 |.pdata|, PDATA
|$T43251| DCD	|$LN61@OTG_Config|
	DCD	0x40012d02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1M@CKAHONI@?$AAB?$AAT?$AAY?$AAP?$AAE?$AA?$AA@| DCB "B", 0x0, "T", 0x0
	DCB	"Y", 0x0, "P", 0x0, "E", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DM@GBENJPGN@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAB?$AAu?$AAi?$AAl?$AAt?$AAI?$AAn?$AA?2?$AAM?$AAU?$AAS?$AAB?$AAO?$AAT?$AAG?$AA?2?$AAU?$AAS?$AAB?$AAF?$AAN?$AA?$AA@| DCB "D"
	DCB	0x0, "r", 0x0, "i", 0x0, "v", 0x0, "e", 0x0, "r", 0x0, "s"
	DCB	0x0, "\\", 0x0, "B", 0x0, "u", 0x0, "i", 0x0, "l", 0x0, "t"
	DCB	0x0, "I", 0x0, "n", 0x0, "\\", 0x0, "M", 0x0, "U", 0x0, "S"
	DCB	0x0, "B", 0x0, "O", 0x0, "T", 0x0, "G", 0x0, "\\", 0x0, "U"
	DCB	0x0, "S", 0x0, "B", 0x0, "F", 0x0, "N", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GG@GMJJEDKI@?$AAH?$AAN?$AAP?$AA?5?$AAs?$AAw?$AAi?$AAt?$AAc?$AAh?$AAi?$AAn?$AAg?$AA?5?$AAa?$AAn?$AAd?$AA?5?$AAn?$AAe?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAd?$AAi?$AAs?$AAc?$AAo?$AAn@| DCB "H"
	DCB	0x0, "N", 0x0, "P", 0x0, " ", 0x0, "s", 0x0, "w", 0x0, "i"
	DCB	0x0, "t", 0x0, "c", 0x0, "h", 0x0, "i", 0x0, "n", 0x0, "g"
	DCB	0x0, " ", 0x0, "a", 0x0, "n", 0x0, "d", 0x0, " ", 0x0, "n"
	DCB	0x0, "e", 0x0, "e", 0x0, "d", 0x0, " ", 0x0, "t", 0x0, "o"
	DCB	0x0, " ", 0x0, "d", 0x0, "i", 0x0, "s", 0x0, "c", 0x0, "o"
	DCB	0x0, "n", 0x0, "n", 0x0, "e", 0x0, "c", 0x0, "t", 0x0, " "
	DCB	0x0, "d", 0x0, "e", 0x0, "v", 0x0, "i", 0x0, "c", 0x0, "e"
	DCB	0x0, " ", 0x0, "m", 0x0, "o", 0x0, "d", 0x0, "e", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DO@OIHENEJP@?$AAU?$AAS?$AAB?$AA?5?$AAC?$AAo?$AAn?$AAn?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAH?$AAo?$AAs?$AAt?$AA?5?$AAS?$AAi?$AAd?$AAe?$AA?$AN?$AA?6?$AA?$AA@| DCB "U"
	DCB	0x0, "S", 0x0, "B", 0x0, " ", 0x0, "C", 0x0, "o", 0x0, "n"
	DCB	0x0, "n", 0x0, "e", 0x0, "c", 0x0, "t", 0x0, "i", 0x0, "o"
	DCB	0x0, "n", 0x0, " ", 0x0, "f", 0x0, "o", 0x0, "r", 0x0, " "
	DCB	0x0, "H", 0x0, "o", 0x0, "s", 0x0, "t", 0x0, " ", 0x0, "S"
	DCB	0x0, "i", 0x0, "d", 0x0, "e", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GK@MJDDMGMO@?$AAV?$AAB?$AAu?$AAs?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AA?9?$AA?5?$AAO?$AAT?$AAG?$AA_?$AAH?$AAa?$AAn?$AAd?$AAl?$AAe?$AAV?$AAB?$AAu?$AAs?$AAE?$AAr?$AAr?$AAo?$AAr@| DCB "V"
	DCB	0x0, "B", 0x0, "u", 0x0, "s", 0x0, " ", 0x0, "E", 0x0, "r"
	DCB	0x0, "r", 0x0, "o", 0x0, "r", 0x0, " ", 0x0, "-", 0x0, " "
	DCB	0x0, "O", 0x0, "T", 0x0, "G", 0x0, "_", 0x0, "H", 0x0, "a"
	DCB	0x0, "n", 0x0, "d", 0x0, "l", 0x0, "e", 0x0, "V", 0x0, "B"
	DCB	0x0, "u", 0x0, "s", 0x0, "E", 0x0, "r", 0x0, "r", 0x0, "o"
	DCB	0x0, "r", 0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "b"
	DCB	0x0, "e", 0x0, " ", 0x0, "i", 0x0, "m", 0x0, "p", 0x0, "l"
	DCB	0x0, "e", 0x0, "m", 0x0, "e", 0x0, "n", 0x0, "t", 0x0, "e"
	DCB	0x0, "d", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OTG_ConfigISR_stage1@OMAPMHSUSBOTG@@UAAKXZ| PROC ; OMAPMHSUSBOTG::OTG_ConfigISR_stage1

; 1796 : {

  00000		 |$LN61@OTG_Config|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M43248|
  00008	e1a04000	 mov         r4, r0

; 1797 :     HKEY hkDevice;
; 1798 :     DWORD dwStatus;
; 1799 :     DWORD dwType, dwSize;
; 1800 :     
; 1801 :     // Step 1. Resume Interrupt
; 1802 :     if ((m_pOTG->intr_usb & INTRUSB_RESUME) == INTRUSB_RESUME)

  0000c	e5942150	 ldr         r2, [r4, #0x150]
  00010	e5d23034	 ldrb        r3, [r2, #0x34]
  00014	e2033002	 and         r3, r3, #2
  00018	e3530002	 cmp         r3, #2
  0001c	1a00000e	 bne         |$LN40@OTG_Config|

; 1803 :     {
; 1804 :         DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Resume Interrupt received\r\n")));
; 1805 :         DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Power = 0x%x\r\n"), INREG8(&m_pOTG->pUsbGenRegs->Power)));
; 1806 :         DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("DevCtl = 0x%x\r\n"), INREG8(&m_pOTG->pUsbGenRegs->DevCtl)));
; 1807 :         DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("INTR_USB = 0x%x\r\n"), m_pOTG->intr_usb));
; 1808 :         DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("INTRRX = 0x%x, INTRTX = 0x%x\r\n"), m_pOTG->intr_rx, m_pOTG->intr_tx));
; 1809 :         // Try to clear it and see if problem solved
; 1810 :         DEBUGMSG(1, (TEXT("Clear the Resume interrupt\r\n")));
; 1811 :         CLRREG8(&m_pOTG->pUsbGenRegs->IntrUSB, INTRUSB_RESUME);

  00020	e5922020	 ldr         r2, [r2, #0x20]

; 1812 : 
; 1813 :         // renable suspend interrupt as needed
; 1814 :         if (!m_pTransceiver->SupportsTransceiverWakeWithoutClock())

  00024	e5d2300a	 ldrb        r3, [r2, #0xA]
  00028	e20330fd	 and         r3, r3, #0xFD
  0002c	e5c2300a	 strb        r3, [r2, #0xA]
  00030	e59400fc	 ldr         r0, [r4, #0xFC]
  00034	e5903000	 ldr         r3, [r0]
  00038	e5933014	 ldr         r3, [r3, #0x14]
  0003c	e1a0e00f	 mov         lr, pc
  00040	e12fff13	 bx          r3
  00044	e3500000	 cmp         r0, #0

; 1815 :             SETREG8(&m_pOTG->pUsbGenRegs->IntrUSBE, INTRUSB_SUSPEND);  

  00048	05943150	 ldreq       r3, [r4, #0x150]
  0004c	05932020	 ldreq       r2, [r3, #0x20]
  00050	05d2300b	 ldreqb      r3, [r2, #0xB]
  00054	03833001	 orreq       r3, r3, #1
  00058	05c2300b	 streqb      r3, [r2, #0xB]
  0005c		 |$LN40@OTG_Config|

; 1816 :     }
; 1817 : 
; 1818 :     // Step 2. Session Request Interrupt on A Device?
; 1819 :     if ((m_pOTG->intr_usb & INTRUSB_SESSREQ) == INTRUSB_SESSREQ)

  0005c	e5943150	 ldr         r3, [r4, #0x150]
  00060	e5d33034	 ldrb        r3, [r3, #0x34]
  00064	e2033040	 and         r3, r3, #0x40
  00068	e3530040	 cmp         r3, #0x40

; 1820 :     {
; 1821 :         DEBUGMSG(ZONE_OTG_INFO, (TEXT("Session Request\r\n")));
; 1822 :         SessionRequest(TRUE, TRUE);

  0006c	05943000	 ldreq       r3, [r4]
  00070	03a02001	 moveq       r2, #1
  00074	03a01001	 moveq       r1, #1
  00078	05933084	 ldreq       r3, [r3, #0x84]
  0007c	01a00004	 moveq       r0, r4
  00080	01a0e00f	 moveq       lr, pc
  00084	012fff13	 bxeq        r3

; 1823 :     }
; 1824 : 
; 1825 :     // Step 3. VBus Interrupt on A Device?
; 1826 :     if ((m_pOTG->intr_usb & INTRUSB_VBUSERR) == INTRUSB_VBUSERR)

  00088	e5943150	 ldr         r3, [r4, #0x150]
  0008c	e3a05001	 mov         r5, #1
  00090	e5d33034	 ldrb        r3, [r3, #0x34]
  00094	e2033080	 and         r3, r3, #0x80
  00098	e3530080	 cmp         r3, #0x80
  0009c	1a000002	 bne         |$LN38@OTG_Config|

; 1827 :     {
; 1828 :         // This handles VBUS error for the case "VBUS error is generated while connecting flash drive"
; 1829 :         RETAILMSG(1, (TEXT("VBus Error - OTG_HandleVBusError to be implemented\r\n")));

  000a0	e59f0408	 ldr         r0, [pc, #0x408]
  000a4	eb000000	 bl          NKDbgPrintfW

; 1830 :                 // Suppose to call OTG_HandleVBusError
; 1831 :         m_handleVBUSError = TRUE;

  000a8	e5845194	 str         r5, [r4, #0x194]
  000ac		 |$LN38@OTG_Config|

; 1832 :     }
; 1833 :     
; 1834 :     // Step 4: Host Mode connection checking
; 1835 :     if (((m_pOTG->intr_usb & INTRUSB_CONN) == INTRUSB_CONN) && 
; 1836 :         ((INREG8(&m_pOTG->pUsbGenRegs->DevCtl) & DEVCTL_HOSTMODE) == DEVCTL_HOSTMODE))

  000ac	e5942150	 ldr         r2, [r4, #0x150]
  000b0	e3a06000	 mov         r6, #0
  000b4	e5d23034	 ldrb        r3, [r2, #0x34]
  000b8	e2033010	 and         r3, r3, #0x10
  000bc	e3530010	 cmp         r3, #0x10
  000c0	1a00006c	 bne         |$LN26@OTG_Config|
  000c4	e5923020	 ldr         r3, [r2, #0x20]
  000c8	e5d33060	 ldrb        r3, [r3, #0x60]
  000cc	e2033004	 and         r3, r3, #4
  000d0	e3530004	 cmp         r3, #4
  000d4	1a000067	 bne         |$LN26@OTG_Config|

; 1837 :     {
; 1838 :         DWORD dwPrevState;
; 1839 :         RETAILMSG(1, (TEXT("USB Connection for Host Side\r\n")));

  000d8	e59f03cc	 ldr         r0, [pc, #0x3CC]
  000dc	eb000000	 bl          NKDbgPrintfW

; 1840 :         // It may be HNP and perform role switching
; 1841 :         m_disconnected = FALSE;
; 1842 : 
; 1843 :         if (m_pOTG->operateMode == DEVICE_MODE)

  000e0	e5942150	 ldr         r2, [r4, #0x150]
  000e4	e584618c	 str         r6, [r4, #0x18C]
  000e8	e5d23035	 ldrb        r3, [r2, #0x35]
  000ec	e3530001	 cmp         r3, #1
  000f0	1a00002e	 bne         |$LN36@OTG_Config|

; 1844 :         {
; 1845 :             RETAILMSG(1, (TEXT("HNP switching and need to disconnect device mode\r\n")));

  000f4	e59f03ac	 ldr         r0, [pc, #0x3AC]
  000f8	eb000000	 bl          NKDbgPrintfW

; 1846 :             m_dwStatus |= STATUS_DISCONN_COMPLETE;
; 1847 :             m_dwStatus &= ~STATUS_WAIT_HOST_DISCONN_COMPLETE;

  000fc	e59430f8	 ldr         r3, [r4, #0xF8]

; 1848 :             //DEBUGMSG(1, (TEXT("operateMode = IDLE (HNP device to host)\r\n")));
; 1849 :             m_pOTG->operateMode = IDLE_MODE;

  00100	e5942150	 ldr         r2, [r4, #0x150]
  00104	e3c33040	 bic         r3, r3, #0x40
  00108	e3833008	 orr         r3, r3, #8
  0010c	e58430f8	 str         r3, [r4, #0xF8]
  00110	e5c26035	 strb        r6, [r2, #0x35]

; 1850 :             m_pOTG->connect_status |= CONN_DC;

  00114	e5942150	 ldr         r2, [r4, #0x150]
  00118	e5d2304c	 ldrb        r3, [r2, #0x4C]
  0011c	e3833004	 orr         r3, r3, #4
  00120	e5c2304c	 strb        r3, [r2, #0x4C]

; 1851 :             dwPrevState = m_pOTG->connect_status;

  00124	e5942150	 ldr         r2, [r4, #0x150]
  00128	e5d2104c	 ldrb        r1, [r2, #0x4C]

; 1852 :             m_pOTG->connect_status &= ~CONN_CCS;

  0012c	e20130fe	 and         r3, r1, #0xFE
  00130	e5c2304c	 strb        r3, [r2, #0x4C]

; 1853 :             if (dwPrevState & CONN_CCS) 
; 1854 :                 m_pOTG->connect_status |= CONN_CSC;

  00134	e5942150	 ldr         r2, [r4, #0x150]
  00138	e3110001	 tst         r1, #1

; 1855 :             else
; 1856 :                 m_pOTG->connect_status &= ~CONN_CSC;
; 1857 : 
; 1858 :             m_pTransceiver->SetVBusSource(TRUE);

  0013c	e3a01001	 mov         r1, #1
  00140	e5d2304c	 ldrb        r3, [r2, #0x4C]
  00144	13833002	 orrne       r3, r3, #2
  00148	020330fd	 andeq       r3, r3, #0xFD
  0014c	e5c2304c	 strb        r3, [r2, #0x4C]
  00150	e59400fc	 ldr         r0, [r4, #0xFC]
  00154	e5903000	 ldr         r3, [r0]
  00158	e5933004	 ldr         r3, [r3, #4]
  0015c	e1a0e00f	 mov         lr, pc
  00160	e12fff13	 bx          r3

; 1859 :             //UpdateBatteryCharger(BATTERY_USBHOST_DISCONNECT);
; 1860 :             if (m_pOTG->pFuncs[DEVICE_MODE-1] != NULL)

  00164	e5940150	 ldr         r0, [r4, #0x150]
  00168	e5903008	 ldr         r3, [r0, #8]
  0016c	e3530000	 cmp         r3, #0

; 1861 :                 m_pOTG->pFuncs[DEVICE_MODE-1]->Disconnect((void *)m_pOTG);                  

  00170	15933018	 ldrne       r3, [r3, #0x18]
  00174	11a0e00f	 movne       lr, pc
  00178	112fff13	 bxne        r3

; 1862 :             ResetEndPoints();

  0017c	e5943000	 ldr         r3, [r4]
  00180	e1a00004	 mov         r0, r4
  00184	e59330ec	 ldr         r3, [r3, #0xEC]
  00188	e1a0e00f	 mov         lr, pc
  0018c	e12fff13	 bx          r3

; 1863 :             // clear any disconnect interrupt
; 1864 :             m_pOTG->intr_usb  &= ~INTRUSB_DISCONN;           

  00190	e5942150	 ldr         r2, [r4, #0x150]
  00194	e5d23034	 ldrb        r3, [r2, #0x34]
  00198	e20330df	 and         r3, r3, #0xDF
  0019c	e5c23034	 strb        r3, [r2, #0x34]

; 1865 :             m_dwStatus |= STATUS_HNP_SESSION_INIT;

  001a0	e59430f8	 ldr         r3, [r4, #0xF8]
  001a4	e3833010	 orr         r3, r3, #0x10
  001a8	e58430f8	 str         r3, [r4, #0xF8]

; 1866 :         }
; 1867 :         else

  001ac	ea000026	 b           |$LN27@OTG_Config|
  001b0		 |$LN36@OTG_Config|

; 1868 :         {
; 1869 :             //DEBUGMSG(1, (TEXT("operateMode = HOST_MODE\r\n")));
; 1870 :             EnterCriticalSection(&m_pOTG->regCS);

  001b0	e2820038	 add         r0, r2, #0x38
  001b4	eb000000	 bl          EnterCriticalSection

; 1871 :             if(m_pOTG->dwPwrMgmt !=  MODE_SYSTEM_SUSPEND)

  001b8	e5942150	 ldr         r2, [r4, #0x150]
  001bc	e5923064	 ldr         r3, [r2, #0x64]
  001c0	e3530001	 cmp         r3, #1
  001c4	0a00001e	 beq         |$LN31@OTG_Config|

; 1872 :             {
; 1873 :                 m_pOTG->operateMode = HOST_MODE;

  001c8	e3a03002	 mov         r3, #2
  001cc	e5c23035	 strb        r3, [r2, #0x35]

; 1874 :                 m_pOTG->deviceType = (INREG8(&m_pOTG->pUsbGenRegs->DevCtl) & DEVCTL_B_DEVICE)? B_DEVICE: A_DEVICE;

  001d0	e5942150	 ldr         r2, [r4, #0x150]
  001d4	e5923020	 ldr         r3, [r2, #0x20]
  001d8	e5d33060	 ldrb        r3, [r3, #0x60]
  001dc	e3130080	 tst         r3, #0x80
  001e0	13a03001	 movne       r3, #1
  001e4	03a03000	 moveq       r3, #0
  001e8	e5c23036	 strb        r3, [r2, #0x36]

; 1875 : 
; 1876 :                 DEBUGMSG(ZONE_OTG_HNP, (TEXT("Connect: DeviceType [%s]\r\n"),
; 1877 :                     ((m_pOTG->deviceType & B_DEVICE)?(TEXT("B_DEVICE")):(TEXT("A_DEVICE"))) ));
; 1878 : 
; 1879 :                 m_dwStatus |= STATUS_CONNECT;

  001ec	e59430f8	 ldr         r3, [r4, #0xF8]

; 1880 :                 // Set the current connect status
; 1881 :                 dwPrevState = m_pOTG->connect_status;

  001f0	e5941150	 ldr         r1, [r4, #0x150]
  001f4	e3833001	 orr         r3, r3, #1
  001f8	e58430f8	 str         r3, [r4, #0xF8]
  001fc	e5d1204c	 ldrb        r2, [r1, #0x4C]

; 1882 :                 m_pOTG->connect_status |= CONN_CCS;

  00200	e3823001	 orr         r3, r2, #1
  00204	e5c1304c	 strb        r3, [r1, #0x4C]

; 1883 :                 if (dwPrevState & CONN_CCS)

  00208	e3120001	 tst         r2, #1

; 1884 :                     m_pOTG->connect_status &= ~CONN_CSC;

  0020c	e5942150	 ldr         r2, [r4, #0x150]
  00210	e5d2304c	 ldrb        r3, [r2, #0x4C]
  00214	120330fd	 andne       r3, r3, #0xFD

; 1885 :                 else
; 1886 :                     m_pOTG->connect_status |= CONN_CSC;

  00218	03833002	 orreq       r3, r3, #2
  0021c	e5c2304c	 strb        r3, [r2, #0x4C]

; 1887 : 
; 1888 :                 // Send the message to Host to do Host_Connect
; 1889 :                 if (m_pOTG->pFuncs[HOST_MODE-1] != NULL)

  00220	e5940150	 ldr         r0, [r4, #0x150]
  00224	e590300c	 ldr         r3, [r0, #0xC]
  00228	e3530000	 cmp         r3, #0

; 1890 :                     m_pOTG->pFuncs[HOST_MODE-1]->Connect((void *)m_pOTG);

  0022c	15933014	 ldrne       r3, [r3, #0x14]
  00230	11a0e00f	 movne       lr, pc
  00234	112fff13	 bxne        r3

; 1891 :                 LeaveCriticalSection(&m_pOTG->regCS);

  00238	e5943150	 ldr         r3, [r4, #0x150]
  0023c	e2830038	 add         r0, r3, #0x38

; 1892 :             }
; 1893 :             else

  00240	ea000000	 b           |$LN56@OTG_Config|
  00244		 |$LN31@OTG_Config|

; 1894 :             {
; 1895 :                 LeaveCriticalSection(&m_pOTG->regCS);

  00244	e2820038	 add         r0, r2, #0x38
  00248		 |$LN56@OTG_Config|
  00248	eb000000	 bl          LeaveCriticalSection
  0024c		 |$LN27@OTG_Config|

; 1896 :             }
; 1897 :         }
; 1898 : 
; 1899 :         // renable suspend interrupt as needed
; 1900 :         if (!m_pTransceiver->SupportsTransceiverWakeWithoutClock())

  0024c	e59400fc	 ldr         r0, [r4, #0xFC]
  00250	e5903000	 ldr         r3, [r0]
  00254	e5933014	 ldr         r3, [r3, #0x14]
  00258	e1a0e00f	 mov         lr, pc
  0025c	e12fff13	 bx          r3
  00260	e3500000	 cmp         r0, #0

; 1901 :             SETREG8(&m_pOTG->pUsbGenRegs->IntrUSBE, INTRUSB_SUSPEND);  

  00264	05943150	 ldreq       r3, [r4, #0x150]
  00268	05932020	 ldreq       r2, [r3, #0x20]
  0026c	05d2300b	 ldreqb      r3, [r2, #0xB]
  00270	03833001	 orreq       r3, r3, #1
  00274	05c2300b	 streqb      r3, [r2, #0xB]
  00278		 |$LN26@OTG_Config|

; 1902 :     }
; 1903 :     else if (m_pOTG->intr_usb & INTRUSB_CONN)
; 1904 :     {
; 1905 :         DEBUGMSG(ZONE_OTG_INFO, (TEXT("Invalid Connection Detect with DevCtl = 0x%x\r\n"), INREG8(&m_pOTG->pUsbGenRegs->DevCtl)));
; 1906 :     }
; 1907 :     
; 1908 :     // Step 5: Reset IRQ
; 1909 :     if ((m_pOTG->intr_usb & INTRUSB_RESET) == INTRUSB_RESET)

  00278	e5942150	 ldr         r2, [r4, #0x150]
  0027c	e5d23034	 ldrb        r3, [r2, #0x34]
  00280	e2033004	 and         r3, r3, #4
  00284	e3530004	 cmp         r3, #4
  00288	1a000080	 bne         |$cleanUp$41308|

; 1910 :     {
; 1911 :         if (((INREG8(&m_pOTG->pUsbGenRegs->DevCtl) & DEVCTL_HOSTMODE) == 0x00) 
; 1912 :             && ((m_dwStatus & STATUS_HNP_SESSION_MASK) == 0x00))// Device Mode

  0028c	e5921020	 ldr         r1, [r2, #0x20]
  00290	e5d13060	 ldrb        r3, [r1, #0x60]
  00294	e3130004	 tst         r3, #4
  00298	1a000071	 bne         |$LN5@OTG_Config|
  0029c	e59430f8	 ldr         r3, [r4, #0xF8]
  002a0	e3130030	 tst         r3, #0x30
  002a4	1a00006e	 bne         |$LN5@OTG_Config|

; 1913 :         {
; 1914 :             DWORD dwPrevState;
; 1915 :             
; 1916 :             DEBUGMSG(ZONE_OTG_INFO, (TEXT("USB Reset detected, it would be connection!!\r\n")));
; 1917 :             DEBUGMSG(ZONE_OTG_INFO, (TEXT("INTR_USB = 0x%x\r\n"), m_pOTG->intr_usb));
; 1918 :             DEBUGMSG(ZONE_OTG_INFO, (TEXT("DEVCTL = 0x%x\r\n"), INREG8(&m_pOTG->pUsbGenRegs->DevCtl)));
; 1919 :             DEBUGMSG(ZONE_OTG_INFO, (TEXT("INTRRX = 0x%x, INTRTX = 0x%x\r\n"), m_pOTG->intr_rx, m_pOTG->intr_tx));
; 1920 :             DEBUGMSG(ZONE_OTG_INFO, (TEXT("Power Mode = 0x%x\r\n"), INREG8(&m_pOTG->pUsbGenRegs->Power)));
; 1921 :             DEBUGMSG(ZONE_OTG_INFO, (TEXT("DMA INTR = 0x%x\r\n"), INREG32(&m_pOTG->pUsbDmaRegs->Intr)));
; 1922 : 
; 1923 :             m_pOTG->deviceType = ((INREG8(&m_pOTG->pUsbGenRegs->DevCtl) & DEVCTL_B_DEVICE)? B_DEVICE: A_DEVICE);

  002a8	e5d13060	 ldrb        r3, [r1, #0x60]
  002ac	e3130080	 tst         r3, #0x80
  002b0	13a03001	 movne       r3, #1
  002b4	03a03000	 moveq       r3, #0
  002b8	e5c23036	 strb        r3, [r2, #0x36]

; 1924 :             DEBUGMSG(ZONE_OTG_INFO, (TEXT("Reset: DeviceType [%s]\r\n"), 
; 1925 :                 ((m_pOTG->deviceType & B_DEVICE)?(TEXT("B_DEVICE")):(TEXT("A_DEVICE"))) ));
; 1926 : 
; 1927 :             if (m_pOTG->operateMode != HOST_MODE)

  002bc	e5942150	 ldr         r2, [r4, #0x150]
  002c0	e5d23035	 ldrb        r3, [r2, #0x35]
  002c4	e3530002	 cmp         r3, #2
  002c8	0a000041	 beq         |$LN21@OTG_Config|

; 1928 :             {       
; 1929 :                 //DEBUGMSG(1, (TEXT("operateMode = DEVICE_MODE\r\n")));
; 1930 :                 m_pOTG->operateMode = DEVICE_MODE;            

  002cc	e5c25035	 strb        r5, [r2, #0x35]

; 1931 :                 m_dwStatus |= STATUS_CONNECT;
; 1932 :                 m_dwStatus &= ~(STATUS_DISCONN_REQUEST|STATUS_WAIT_HOST_DISCONN_COMPLETE|STATUS_DISCONN_COMPLETE);

  002d0	e59430f8	 ldr         r3, [r4, #0xF8]

; 1933 :                 dwPrevState = m_pOTG->connect_status;

  002d4	e5941150	 ldr         r1, [r4, #0x150]
  002d8	e3c3304a	 bic         r3, r3, #0x4A
  002dc	e3833001	 orr         r3, r3, #1
  002e0	e58430f8	 str         r3, [r4, #0xF8]
  002e4	e5d1204c	 ldrb        r2, [r1, #0x4C]

; 1934 :                 m_pOTG->connect_status |= CONN_CCS;

  002e8	e3823001	 orr         r3, r2, #1
  002ec	e5c1304c	 strb        r3, [r1, #0x4C]

; 1935 :                 if (dwPrevState & CONN_CCS) 

  002f0	e3120001	 tst         r2, #1

; 1936 :                     m_pOTG->connect_status &= ~CONN_CSC;

  002f4	e5942150	 ldr         r2, [r4, #0x150]
  002f8	e5d2304c	 ldrb        r3, [r2, #0x4C]
  002fc	120330fd	 andne       r3, r3, #0xFD

; 1937 :                 else
; 1938 :                     m_pOTG->connect_status |= CONN_CSC;

  00300	03833002	 orreq       r3, r3, #2
  00304	e5c2304c	 strb        r3, [r2, #0x4C]

; 1939 : 
; 1940 :                 if (m_pOTG->deviceType & B_DEVICE && (INREG8(&m_pOTG->pUsbGenRegs->DevCtl) & DEVCTL_SESSION))

  00308	e5942150	 ldr         r2, [r4, #0x150]
  0030c	e5d23036	 ldrb        r3, [r2, #0x36]
  00310	e3130001	 tst         r3, #1
  00314	0a00000b	 beq         |$LN18@OTG_Config|
  00318	e5923020	 ldr         r3, [r2, #0x20]
  0031c	e5d33060	 ldrb        r3, [r3, #0x60]
  00320	e3130001	 tst         r3, #1
  00324	0a000007	 beq         |$LN18@OTG_Config|

; 1941 :                 {
; 1942 :                     m_pTransceiver->SetVBusSource(TRUE);

  00328	e59400fc	 ldr         r0, [r4, #0xFC]
  0032c	e3a01001	 mov         r1, #1
  00330	e5903000	 ldr         r3, [r0]
  00334	e5933004	 ldr         r3, [r3, #4]
  00338	e1a0e00f	 mov         lr, pc
  0033c	e12fff13	 bx          r3

; 1943 :                     m_dwbTypeConnector = 1;

  00340	e5845198	 str         r5, [r4, #0x198]

; 1944 :                 }
; 1945 :                 else

  00344	ea000000	 b           |$LN17@OTG_Config|
  00348		 |$LN18@OTG_Config|

; 1946 :                 {
; 1947 :                     m_dwbTypeConnector = 0;

  00348	e5846198	 str         r6, [r4, #0x198]
  0034c		 |$LN17@OTG_Config|

; 1948 :                 }
; 1949 : 
; 1950 :                 dwStatus = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCTSTR) REG_USBFN_DRV_PATH, 0, KEY_ALL_ACCESS, &hkDevice);

  0034c	e59f1150	 ldr         r1, [pc, #0x150]
  00350	e3a0380f	 mov         r3, #0xF, 16
  00354	e28de008	 add         lr, sp, #8
  00358	e383303f	 orr         r3, r3, #0x3F
  0035c	e3a02000	 mov         r2, #0
  00360	e3a0010a	 mov         r0, #0xA, 2
  00364	e58de000	 str         lr, [sp]
  00368	eb000000	 bl          RegOpenKeyExW
  0036c	e3500000	 cmp         r0, #0

; 1951 :                 if(dwStatus != ERROR_SUCCESS)

  00370	1a000046	 bne         |$cleanUp$41308|

; 1952 :                 {
; 1953 :                     DEBUGMSG(ZONE_OTG_WARN, (_T("UfnPdd_Init: OpenDeviceKey('%s') failed %u\r\n"), REG_USBFN_DRV_PATH, dwStatus));
; 1954 :                     goto cleanUp;
; 1955 :                 }
; 1956 : 
; 1957 :                 dwType = REG_DWORD;
; 1958 :                 dwSize = sizeof(m_dwbTypeConnector);
; 1959 :                 dwStatus = ::RegSetValueEx(hkDevice, REG_VBUS_CHARGE_B_TYPE_CONNECTOR, NULL, dwType, 
; 1960 :                     (LPBYTE) &m_dwbTypeConnector, dwSize);

  00374	e59f1124	 ldr         r1, [pc, #0x124]
  00378	e59d0008	 ldr         r0, [sp, #8]
  0037c	e3a05004	 mov         r5, #4
  00380	e284ef66	 add         lr, r4, #0x66, 30
  00384	e3a03004	 mov         r3, #4
  00388	e3a02000	 mov         r2, #0
  0038c	e58d5004	 str         r5, [sp, #4]
  00390	e58de000	 str         lr, [sp]
  00394	eb000000	 bl          RegSetValueExW
  00398	e3500000	 cmp         r0, #0

; 1966 :                     goto cleanUp;
; 1967 :                 }
; 1968 :                 RegCloseKey(hkDevice);

  0039c	e59d0008	 ldr         r0, [sp, #8]
  003a0	1a000009	 bne         |$LN13@OTG_Config|
  003a4	eb000000	 bl          RegCloseKey

; 1969 : 
; 1970 :                 m_disconnected = FALSE;
; 1971 :                 if (m_pOTG->pFuncs[DEVICE_MODE-1] != NULL)

  003a8	e5940150	 ldr         r0, [r4, #0x150]
  003ac	e584618c	 str         r6, [r4, #0x18C]
  003b0	e5903008	 ldr         r3, [r0, #8]
  003b4	e3530000	 cmp         r3, #0
  003b8	0a000023	 beq         |$LN11@OTG_Config|

; 1972 :                     m_pOTG->pFuncs[DEVICE_MODE-1]->ResetIRQ((void *)m_pOTG);

  003bc	e5933000	 ldr         r3, [r3]
  003c0	e1a0e00f	 mov         lr, pc
  003c4	e12fff13	 bx          r3

; 1973 :                 /* Clear bus suspend if there are any, because after bus reset, 
; 1974 :                 immediately bus suspend is received during host->device HNP */
; 1975 :                 if(m_pOTG->intr_usb & INTRUSB_SUSPEND)
; 1976 :                    m_pOTG->intr_usb &= ~INTRUSB_SUSPEND;
; 1977 :             }
; 1978 :             else

  003c8	ea00001f	 b           |$LN11@OTG_Config|
  003cc		 |$LN13@OTG_Config|

; 1961 :                 if(dwStatus != ERROR_SUCCESS || dwType != REG_DWORD)
; 1962 :                 {
; 1963 :                     DEBUGMSG(ZONE_OTG_WARN, (_T("UFNPDD_Init: RegQueryValueEx('%s', '%s') failed %u\r\n"),
; 1964 :                         REG_USBFN_DRV_PATH, REG_VBUS_CHARGE_B_TYPE_CONNECTOR, dwStatus));
; 1965 :                     RegCloseKey(hkDevice);

  003cc	eb000000	 bl          RegCloseKey

; 2014 :     }
; 2015 : cleanUp:

  003d0	ea00002e	 b           |$cleanUp$41308|
  003d4		 |$LN21@OTG_Config|

; 1979 :             {                
; 1980 :                 DEBUGMSG(ZONE_OTG_HNP, (TEXT("Get HNP role switch to device\r\n")));                    
; 1981 :                 ResetEndPoints();

  003d4	e5943000	 ldr         r3, [r4]
  003d8	e1a00004	 mov         r0, r4
  003dc	e59330ec	 ldr         r3, [r3, #0xEC]
  003e0	e1a0e00f	 mov         lr, pc
  003e4	e12fff13	 bx          r3

; 1982 :                 //DEBUGMSG(1, (TEXT("operateMode = IDLE (HNP host to device)\r\n")));
; 1983 :                 m_pOTG->operateMode = IDLE_MODE;

  003e8	e5943150	 ldr         r3, [r4, #0x150]
  003ec	e5c36035	 strb        r6, [r3, #0x35]

; 1984 :                 m_dwStatus |= (STATUS_DISCONN_REQUEST|STATUS_WAIT_HOST_DISCONN_COMPLETE|STATUS_HNP_SESSION_INIT);

  003f0	e59430f8	 ldr         r3, [r4, #0xF8]

; 1985 :                 dwPrevState = m_pOTG->connect_status;

  003f4	e5941150	 ldr         r1, [r4, #0x150]
  003f8	e3833052	 orr         r3, r3, #0x52
  003fc	e58430f8	 str         r3, [r4, #0xF8]
  00400	e5d1204c	 ldrb        r2, [r1, #0x4C]

; 1986 :                 m_pOTG->connect_status &= ~CONN_CCS;

  00404	e20230fe	 and         r3, r2, #0xFE
  00408	e5c1304c	 strb        r3, [r1, #0x4C]

; 1987 :                 if (dwPrevState & CONN_CCS) 

  0040c	e3120001	 tst         r2, #1

; 1988 :                     m_pOTG->connect_status |= CONN_CSC;

  00410	e5942150	 ldr         r2, [r4, #0x150]
  00414	e5d2304c	 ldrb        r3, [r2, #0x4C]
  00418	13833002	 orrne       r3, r3, #2

; 1989 :                 else
; 1990 :                     m_pOTG->connect_status &= ~CONN_CSC;

  0041c	020330fd	 andeq       r3, r3, #0xFD
  00420	e5c2304c	 strb        r3, [r2, #0x4C]

; 1991 : 
; 1992 :                 if (m_pOTG->pFuncs[HOST_MODE-1] != NULL)

  00424	e5940150	 ldr         r0, [r4, #0x150]
  00428	e590300c	 ldr         r3, [r0, #0xC]
  0042c	e3530000	 cmp         r3, #0

; 1993 :                     m_pOTG->pFuncs[HOST_MODE-1]->Disconnect((void *)m_pOTG);                                

  00430	15933018	 ldrne       r3, [r3, #0x18]
  00434	11a0e00f	 movne       lr, pc
  00438	112fff13	 bxne        r3

; 1994 :                 m_pOTG->intr_usb &= ~INTRUSB_DISCONN;

  0043c	e5942150	 ldr         r2, [r4, #0x150]
  00440	e5d23034	 ldrb        r3, [r2, #0x34]
  00444	e20330df	 and         r3, r3, #0xDF
  00448	e5c23034	 strb        r3, [r2, #0x34]
  0044c		 |$LN11@OTG_Config|

; 1995 : 
; 1996 :                 /* Clear bus suspend if there are any, because after bus reset, 
; 1997 :                 immediately bus suspend is received during host->device HNP */
; 1998 :                 if(m_pOTG->intr_usb & INTRUSB_SUSPEND)

  0044c	e5942150	 ldr         r2, [r4, #0x150]
  00450	e5d23034	 ldrb        r3, [r2, #0x34]
  00454	e3130001	 tst         r3, #1

; 1999 :                    m_pOTG->intr_usb &= ~INTRUSB_SUSPEND;

  00458	120330ff	 andne       r3, r3, #0xFF
  0045c	120330fe	 andne       r3, r3, #0xFE
  00460	15c23034	 strneb      r3, [r2, #0x34]
  00464		 |$LN5@OTG_Config|

; 2000 : 
; 2001 :             }
; 2002 :         }
; 2003 :         else
; 2004 :         {
; 2005 :             if ((m_dwStatus & STATUS_HNP_SESSION_MASK) == 0x00)
; 2006 :                 DEBUGMSG(ZONE_OTG_INFO, (TEXT("USB Babble:DevCtl;0x%x\r\n"),INREG8(&m_pOTG->pUsbGenRegs->DevCtl)));
; 2007 :             else
; 2008 :                 DEBUGMSG(ZONE_OTG_INFO, (TEXT("Wait for disconnect complete\r\n")));
; 2009 :         }
; 2010 : 
; 2011 :         // renable suspend interrupt as needed
; 2012 :         if (!m_pTransceiver->SupportsTransceiverWakeWithoutClock())

  00464	e59400fc	 ldr         r0, [r4, #0xFC]
  00468	e5903000	 ldr         r3, [r0]
  0046c	e5933014	 ldr         r3, [r3, #0x14]
  00470	e1a0e00f	 mov         lr, pc
  00474	e12fff13	 bx          r3
  00478	e3500000	 cmp         r0, #0

; 2013 :             SETREG8(&m_pOTG->pUsbGenRegs->IntrUSBE, INTRUSB_SUSPEND);  

  0047c	05943150	 ldreq       r3, [r4, #0x150]
  00480	05932020	 ldreq       r2, [r3, #0x20]
  00484	05d2300b	 ldreqb      r3, [r2, #0xB]
  00488	03833001	 orreq       r3, r3, #1
  0048c	05c2300b	 streqb      r3, [r2, #0xB]
  00490		 |$cleanUp$41308|

; 2016 :     return m_dwStatus;

  00490	e59400f8	 ldr         r0, [r4, #0xF8]

; 2017 : }

  00494	e28dd00c	 add         sp, sp, #0xC
  00498	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0049c	e12fff1e	 bx          lr
  004a0		 |$LN62@OTG_Config|
  004a0		 |$LN63@OTG_Config|
  004a0	00000000	 DCD         |??_C@_1M@CKAHONI@?$AAB?$AAT?$AAY?$AAP?$AAE?$AA?$AA@|
  004a4		 |$LN64@OTG_Config|
  004a4	00000000	 DCD         |??_C@_1DM@GBENJPGN@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAB?$AAu?$AAi?$AAl?$AAt?$AAI?$AAn?$AA?2?$AAM?$AAU?$AAS?$AAB?$AAO?$AAT?$AAG?$AA?2?$AAU?$AAS?$AAB?$AAF?$AAN?$AA?$AA@|
  004a8		 |$LN65@OTG_Config|
  004a8	00000000	 DCD         |??_C@_1GG@GMJJEDKI@?$AAH?$AAN?$AAP?$AA?5?$AAs?$AAw?$AAi?$AAt?$AAc?$AAh?$AAi?$AAn?$AAg?$AA?5?$AAa?$AAn?$AAd?$AA?5?$AAn?$AAe?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAd?$AAi?$AAs?$AAc?$AAo?$AAn@|
  004ac		 |$LN66@OTG_Config|
  004ac	00000000	 DCD         |??_C@_1DO@OIHENEJP@?$AAU?$AAS?$AAB?$AA?5?$AAC?$AAo?$AAn?$AAn?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAH?$AAo?$AAs?$AAt?$AA?5?$AAS?$AAi?$AAd?$AAe?$AA?$AN?$AA?6?$AA?$AA@|
  004b0		 |$LN67@OTG_Config|
  004b0	00000000	 DCD         |??_C@_1GK@MJDDMGMO@?$AAV?$AAB?$AAu?$AAs?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AA?9?$AA?5?$AAO?$AAT?$AAG?$AA_?$AAH?$AAa?$AAn?$AAd?$AAl?$AAe?$AAV?$AAB?$AAu?$AAs?$AAE?$AAr?$AAr?$AAo?$AAr@|
  004b4		 |$M43249|

			 ENDP  ; |?OTG_ConfigISR_stage1@OMAPMHSUSBOTG@@UAAKXZ|, OMAPMHSUSBOTG::OTG_ConfigISR_stage1

	EXPORT	|?CreateFunctionDeviceFolder@OMAPMHSUSBOTG@@UAAPAVDeviceFolder@@PBG0KKKKPAXK0@Z| ; OMAPMHSUSBOTG::CreateFunctionDeviceFolder
	IMPORT	|??2@YAPAXI@Z|				; operator new

  00000			 AREA	 |.pdata|, PDATA
|$T43273| DCD	|$LN7@CreateFunc|
	DCD	0x40002002
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CreateFunctionDeviceFolder@OMAPMHSUSBOTG@@UAAPAVDeviceFolder@@PBG0KKKKPAXK0@Z| PROC ; OMAPMHSUSBOTG::CreateFunctionDeviceFolder

; 2040 : {

  00000		 |$LN7@CreateFunc|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd01c	 sub         sp, sp, #0x1C
  00008		 |$M43270|
  00008	e1a09003	 mov         r9, r3
  0000c	e1a0a002	 mov         r10, r2
  00010	e1a0b001	 mov         r11, r1

; 2041 :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("CreateFunctionDeviceFolder\r\n")));
; 2042 :     return new OMAPMHSUsbClientDeviceFolder(OMAP_USBHS_DEV_REGS_PA,
; 2043 :         lpBusName, lpTemplateRegPath, dwBusType, BusNumber, DeviceNumber,FunctionNumber, hParent, dwMaxInitReg, lpDeviceBusName);

  00014	e3a00064	 mov         r0, #0x64
  00018	eb000000	 bl          |??2@YAPAXI@Z|
  0001c	e3500000	 cmp         r0, #0
  00020	0a000012	 beq         |$LN3@CreateFunc|
  00024	e59de054	 ldr         lr, [sp, #0x54]
  00028	e59d4050	 ldr         r4, [sp, #0x50]
  0002c	e59d504c	 ldr         r5, [sp, #0x4C]
  00030	e59d6048	 ldr         r6, [sp, #0x48]
  00034	e59d7044	 ldr         r7, [sp, #0x44]
  00038	e59d8040	 ldr         r8, [sp, #0x40]
  0003c	e3a01312	 mov         r1, #0x12, 6
  00040	e1a0300a	 mov         r3, r10
  00044	e1a0200b	 mov         r2, r11
  00048	e3811aab	 orr         r1, r1, #0xAB, 20
  0004c	e58de018	 str         lr, [sp, #0x18]
  00050	e58d4014	 str         r4, [sp, #0x14]
  00054	e58d5010	 str         r5, [sp, #0x10]
  00058	e58d600c	 str         r6, [sp, #0xC]
  0005c	e58d7008	 str         r7, [sp, #8]
  00060	e58d8004	 str         r8, [sp, #4]
  00064	e58d9000	 str         r9, [sp]
  00068	eb000000	 bl          |??0OMAPMHSUsbClientDeviceFolder@@QAA@KPBG0KKKKPAXK0@Z|
  0006c	ea000000	 b           |$LN4@CreateFunc|
  00070		 |$LN3@CreateFunc|
  00070	e3a00000	 mov         r0, #0
  00074		 |$LN4@CreateFunc|

; 2044 : }

  00074	e28dd01c	 add         sp, sp, #0x1C
  00078	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$M43271|

			 ENDP  ; |?CreateFunctionDeviceFolder@OMAPMHSUSBOTG@@UAAPAVDeviceFolder@@PBG0KKKKPAXK0@Z|, OMAPMHSUSBOTG::CreateFunctionDeviceFolder

	EXPORT	|?CreateHostDeviceFolder@OMAPMHSUSBOTG@@UAAPAVDeviceFolder@@PBG0KKKKPAXK0@Z| ; OMAPMHSUSBOTG::CreateHostDeviceFolder

  00000			 AREA	 |.pdata|, PDATA
|$T43289| DCD	|$LN7@CreateHost|
	DCD	0x40002002
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CreateHostDeviceFolder@OMAPMHSUSBOTG@@UAAPAVDeviceFolder@@PBG0KKKKPAXK0@Z| PROC ; OMAPMHSUSBOTG::CreateHostDeviceFolder

; 2068 : {

  00000		 |$LN7@CreateHost|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd01c	 sub         sp, sp, #0x1C
  00008		 |$M43286|
  00008	e1a09003	 mov         r9, r3
  0000c	e1a0a002	 mov         r10, r2
  00010	e1a0b001	 mov         r11, r1

; 2069 :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("CreateHostDeviceFolder\r\n")));
; 2070 :     return new OMAPMHSUsbClientDeviceFolder(OMAP_USBHS_HOST_REGS_PA,
; 2071 :         lpBusName, lpTemplateRegPath, dwBusType, BusNumber, DeviceNumber,FunctionNumber, hParent, dwMaxInitReg, lpDeviceBusName);

  00014	e3a00064	 mov         r0, #0x64
  00018	eb000000	 bl          |??2@YAPAXI@Z|
  0001c	e3500000	 cmp         r0, #0
  00020	0a000012	 beq         |$LN3@CreateHost|
  00024	e59de054	 ldr         lr, [sp, #0x54]
  00028	e59d4050	 ldr         r4, [sp, #0x50]
  0002c	e59d504c	 ldr         r5, [sp, #0x4C]
  00030	e59d6048	 ldr         r6, [sp, #0x48]
  00034	e59d7044	 ldr         r7, [sp, #0x44]
  00038	e59d8040	 ldr         r8, [sp, #0x40]
  0003c	e3a01312	 mov         r1, #0x12, 6
  00040	e1a0300a	 mov         r3, r10
  00044	e1a0200b	 mov         r2, r11
  00048	e3811aab	 orr         r1, r1, #0xAB, 20
  0004c	e58de018	 str         lr, [sp, #0x18]
  00050	e58d4014	 str         r4, [sp, #0x14]
  00054	e58d5010	 str         r5, [sp, #0x10]
  00058	e58d600c	 str         r6, [sp, #0xC]
  0005c	e58d7008	 str         r7, [sp, #8]
  00060	e58d8004	 str         r8, [sp, #4]
  00064	e58d9000	 str         r9, [sp]
  00068	eb000000	 bl          |??0OMAPMHSUsbClientDeviceFolder@@QAA@KPBG0KKKKPAXK0@Z|
  0006c	ea000000	 b           |$LN4@CreateHost|
  00070		 |$LN3@CreateHost|
  00070	e3a00000	 mov         r0, #0
  00074		 |$LN4@CreateHost|

; 2072 : }

  00074	e28dd01c	 add         sp, sp, #0x1C
  00078	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$M43287|

			 ENDP  ; |?CreateHostDeviceFolder@OMAPMHSUSBOTG@@UAAPAVDeviceFolder@@PBG0KKKKPAXK0@Z|, OMAPMHSUSBOTG::CreateHostDeviceFolder

	EXPORT	|?EnableSuspend@OMAPMHSUSBOTG@@UAAHH@Z|	; OMAPMHSUSBOTG::EnableSuspend

  00000			 AREA	 |.pdata|, PDATA
|$T43301| DCD	|$LN10@EnableSusp|
	DCD	0x40000e00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?EnableSuspend@OMAPMHSUSBOTG@@UAAHH@Z| PROC ; OMAPMHSUSBOTG::EnableSuspend

; 2087 : {

  00000		 |$LN10@EnableSusp|
  00000		 |$M43298|
  00000	e3510000	 cmp         r1, #0

; 2088 :     if (fEnable)
; 2089 :     {
; 2090 :         if (!m_bEnableSuspend)
; 2091 :         { 
; 2092 : 		  //PCSP_MUSB_GEN_REGS pGen = m_pOTG->pUsbGenRegs;
; 2093 :           //Keep the transceiver on during system suspend and when a USB device is attached
; 2094 :           //SETREG8(&pGen->Power, POWER_EN_SUSPENDM);       
; 2095 :         }
; 2096 :         m_bEnableSuspend = TRUE;

  00004	13a03001	 movne       r3, #1
  00008	1a000007	 bne         |$LN7@EnableSusp|

; 2097 :     }
; 2098 :     else
; 2099 :     {
; 2100 :         if (m_bEnableSuspend)

  0000c	e5903168	 ldr         r3, [r0, #0x168]
  00010	e3530000	 cmp         r3, #0

; 2101 :         {
; 2102 :           CLRREG8(&m_pOTG->pUsbGenRegs->Power, POWER_EN_SUSPENDM);

  00014	15903150	 ldrne       r3, [r0, #0x150]
  00018	15932020	 ldrne       r2, [r3, #0x20]
  0001c	15d23001	 ldrneb      r3, [r2, #1]
  00020	120330fe	 andne       r3, r3, #0xFE
  00024	15c23001	 strneb      r3, [r2, #1]

; 2103 :         }
; 2104 :         m_bEnableSuspend = FALSE;

  00028	e3a03000	 mov         r3, #0
  0002c		 |$LN7@EnableSusp|
  0002c	e5803168	 str         r3, [r0, #0x168]

; 2105 :     }
; 2106 :     return TRUE;

  00030	e3a00001	 mov         r0, #1

; 2107 : }

  00034	e12fff1e	 bx          lr
  00038		 |$M43299|

			 ENDP  ; |?EnableSuspend@OMAPMHSUSBOTG@@UAAHH@Z|, OMAPMHSUSBOTG::EnableSuspend

	EXPORT	|?StopUSBClock@OMAPMHSUSBOTG@@UAAHXZ|	; OMAPMHSUSBOTG::StopUSBClock

  00000			 AREA	 |.pdata|, PDATA
|$T43315| DCD	|$LN11@StopUSBClo|
	DCD	0x40003b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?StopUSBClock@OMAPMHSUSBOTG@@UAAHXZ| PROC ; OMAPMHSUSBOTG::StopUSBClock

; 2120 : {

  00000		 |$LN11@StopUSBClo|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43312|
  00004	e1a04000	 mov         r4, r0

; 2121 :     PCSP_MUSB_OTG_REGS pOtg;    
; 2122 : 
; 2123 :     //DWORD *pSysControlRegs;
; 2124 :     // Configure the rest of the stuff:    
; 2125 :     EnterCriticalSection(&m_csUSBClock);        

  00008	e2840f49	 add         r0, r4, #0x49, 30
  0000c	eb000000	 bl          EnterCriticalSection

; 2126 : 
; 2127 :     if (m_bUSBClockEnable == FALSE)

  00010	e594315c	 ldr         r3, [r4, #0x15C]
  00014	e3530000	 cmp         r3, #0
  00018	1a000003	 bne         |$LN3@StopUSBClo|

; 2128 :     {
; 2129 :         LeaveCriticalSection(&m_csUSBClock);

  0001c	e2840f49	 add         r0, r4, #0x49, 30
  00020	eb000000	 bl          LeaveCriticalSection

; 2130 :         return FALSE;

  00024	e3a05000	 mov         r5, #0
  00028	ea00002c	 b           |$LN4@StopUSBClo|
  0002c		 |$LN3@StopUSBClo|

; 2131 :     }
; 2132 : 
; 2133 :         (m_dwUSBUsageCount == 0)? m_dwUSBUsageCount:(m_dwUSBUsageCount--);

  0002c	e5943160	 ldr         r3, [r4, #0x160]
  00030	e3530000	 cmp         r3, #0
  00034	12433001	 subne       r3, r3, #1
  00038	15843160	 strne       r3, [r4, #0x160]

; 2134 :         if (m_dwUSBUsageCount > 0)

  0003c	e5943160	 ldr         r3, [r4, #0x160]
  00040	e3530000	 cmp         r3, #0
  00044	83a05000	 movhi       r5, #0
  00048	8a000022	 bhi         |$LN8@StopUSBClo|

; 2135 :         {            
; 2136 :             LeaveCriticalSection(&m_csUSBClock);
; 2137 :             return FALSE;
; 2138 :         }
; 2139 :         DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("+StopUSBClock\r\n")));
; 2140 :     EnableSuspend(TRUE);

  0004c	e5943000	 ldr         r3, [r4]
  00050	e3a01001	 mov         r1, #1
  00054	e1a00004	 mov         r0, r4
  00058	e59330f0	 ldr         r3, [r3, #0xF0]
  0005c	e1a0e00f	 mov         lr, pc
  00060	e12fff13	 bx          r3

; 2141 : 
; 2142 :         pOtg = m_pOTG->pUsbOtgRegs;        

  00064	e5943150	 ldr         r3, [r4, #0x150]

; 2143 :  
; 2144 :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("+StopUSBClock\r\n")));
; 2145 : 
; 2146 :     // According to TI Spec TRM Version H 25.12.3.1
; 2147 :     // Master Interface Management - force standy mode
; 2148 :     CLRREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_M_MASK);
; 2149 :     // Side Interface Management - force standby mode
; 2150 :     CLRREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_S_MASK);

  00068	e5932018	 ldr         r2, [r3, #0x18]
  0006c	e5923004	 ldr         r3, [r2, #4]

; 2151 :     // Enable Auto Idle
; 2152 :     SETREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_AUTOIDLE);
; 2153 :     // Enable Wakeup
; 2154 :     SETREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_ENABLEWAKEUP);
; 2155 :     // Enable Force Standby
; 2156 :     SETREG32(&pOtg->OTG_FORCESTDBY, OTG_FORCESTDY_ENABLEFORCE);

  00070	e3c33a03	 bic         r3, r3, #3, 20
  00074	e5823004	 str         r3, [r2, #4]
  00078	e5923004	 ldr         r3, [r2, #4]
  0007c	e3c33018	 bic         r3, r3, #0x18
  00080	e5823004	 str         r3, [r2, #4]
  00084	e5923004	 ldr         r3, [r2, #4]
  00088	e3833001	 orr         r3, r3, #1
  0008c	e5823004	 str         r3, [r2, #4]
  00090	e5923004	 ldr         r3, [r2, #4]
  00094	e3833004	 orr         r3, r3, #4
  00098	e5823004	 str         r3, [r2, #4]
  0009c	e5923014	 ldr         r3, [r2, #0x14]
  000a0	e3833001	 orr         r3, r3, #1
  000a4	e5823014	 str         r3, [r2, #0x14]

; 2157 : 
; 2158 :     DEBUGMSG(1, (TEXT("OTG SysConfig = 0x%x\r\n"), INREG32(&pOtg->OTG_SYSCONFIG)));
; 2159 : 
; 2160 :     if(m_pOTG->operateMode == IDLE_MODE)

  000a8	e5943150	 ldr         r3, [r4, #0x150]
  000ac	e5d33035	 ldrb        r3, [r3, #0x35]
  000b0	e3530000	 cmp         r3, #0

; 2161 :     {
; 2162 :         DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("***###StopUSBClock:  EnableWakeupInterrupt(TRUE)\r\n")));
; 2163 :         m_pTransceiver->EnableWakeupInterrupt(TRUE);

  000b4	059400fc	 ldreq       r0, [r4, #0xFC]
  000b8	03a01001	 moveq       r1, #1
  000bc	05903000	 ldreq       r3, [r0]
  000c0	05933008	 ldreq       r3, [r3, #8]
  000c4	01a0e00f	 moveq       lr, pc
  000c8	012fff13	 bxeq        r3

; 2164 :     }
; 2165 : 
; 2166 :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("-StopUSBClock\r\n")));
; 2167 :     m_bUSBClockEnable = FALSE;

  000cc	e3a03000	 mov         r3, #0
  000d0	e584315c	 str         r3, [r4, #0x15C]
  000d4	e3a05001	 mov         r5, #1
  000d8		 |$LN8@StopUSBClo|
  000d8	e2840f49	 add         r0, r4, #0x49, 30
  000dc	eb000000	 bl          LeaveCriticalSection
  000e0		 |$LN4@StopUSBClo|

; 2168 :     LeaveCriticalSection(&m_csUSBClock);
; 2169 :     return TRUE;
; 2170 : 
; 2171 : }

  000e0	e1a00005	 mov         r0, r5
  000e4	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000e8	e12fff1e	 bx          lr
  000ec		 |$M43313|

			 ENDP  ; |?StopUSBClock@OMAPMHSUSBOTG@@UAAHXZ|, OMAPMHSUSBOTG::StopUSBClock

	EXPORT	|?StartUSBClock@OMAPMHSUSBOTG@@UAAHH@Z|	; OMAPMHSUSBOTG::StartUSBClock

  00000			 AREA	 |.pdata|, PDATA
|$T43334| DCD	|$LN12@StartUSBCl|
	DCD	0x40004e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?StartUSBClock@OMAPMHSUSBOTG@@UAAHH@Z| PROC ; OMAPMHSUSBOTG::StartUSBClock

; 2182 : {

  00000		 |$LN12@StartUSBCl|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M43331|
  00004	e1a06001	 mov         r6, r1
  00008	e1a04000	 mov         r4, r0

; 2183 :     PCSP_MUSB_OTG_REGS pOtg;
; 2184 : 
; 2185 :     // Configure the rest of the stuff:
; 2186 :     EnterCriticalSection(&m_csUSBClock);

  0000c	e2840f49	 add         r0, r4, #0x49, 30
  00010	eb000000	 bl          EnterCriticalSection

; 2187 : 
; 2188 :     if (m_bUSBClockEnable == TRUE)

  00014	e594315c	 ldr         r3, [r4, #0x15C]
  00018	e3530001	 cmp         r3, #1
  0001c	03a05000	 moveq       r5, #0
  00020	0a00003e	 beq         |$LN9@StartUSBCl|

; 2189 :     {
; 2190 :         LeaveCriticalSection(&m_csUSBClock);
; 2191 :         return FALSE;
; 2192 :     }
; 2193 : 
; 2194 :     if(m_pOTG->operateMode == IDLE_MODE)

  00024	e5943150	 ldr         r3, [r4, #0x150]
  00028	e5d33035	 ldrb        r3, [r3, #0x35]
  0002c	e3530000	 cmp         r3, #0

; 2195 :     {
; 2196 :         DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("***###StartUSBClock:  EnableWakeupInterrupt(FALSE)\r\n")));
; 2197 :         m_pTransceiver->EnableWakeupInterrupt(FALSE);

  00030	059400fc	 ldreq       r0, [r4, #0xFC]
  00034	03a01000	 moveq       r1, #0
  00038	05903000	 ldreq       r3, [r0]
  0003c	05933008	 ldreq       r3, [r3, #8]
  00040	01a0e00f	 moveq       lr, pc
  00044	012fff13	 bxeq        r3

; 2198 :     }
; 2199 :     pOtg = m_pOTG->pUsbOtgRegs;

  00048	e5943150	 ldr         r3, [r4, #0x150]

; 2200 : 
; 2201 : 
; 2202 :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("+StartUSBClock\r\n")));
; 2203 : 
; 2204 :     EnterCriticalSection(&m_pOTG->regCS);

  0004c	e5935018	 ldr         r5, [r3, #0x18]
  00050	e2830038	 add         r0, r3, #0x38
  00054	eb000000	 bl          EnterCriticalSection

; 2205 :     UpdateDevicePower(m_hParent, D0, NULL);

  00058	e59f20d4	 ldr         r2, [pc, #0xD4]
  0005c	e5940140	 ldr         r0, [r4, #0x140]
  00060	e5923000	 ldr         r3, [r2]
  00064	e3530000	 cmp         r3, #0
  00068	13a03000	 movne       r3, #0
  0006c	15823000	 strne       r3, [r2]
  00070	13a02000	 movne       r2, #0
  00074	13a01000	 movne       r1, #0
  00078	1b000000	 blne        SetDevicePowerState

; 2206 :     LeaveCriticalSection(&m_pOTG->regCS);

  0007c	e5943150	 ldr         r3, [r4, #0x150]
  00080	e2830038	 add         r0, r3, #0x38
  00084	eb000000	 bl          LeaveCriticalSection

; 2207 : 
; 2208 :     EnableSuspend(FALSE);

  00088	e5943000	 ldr         r3, [r4]
  0008c	e3a01000	 mov         r1, #0
  00090	e1a00004	 mov         r0, r4
  00094	e59330f0	 ldr         r3, [r3, #0xF0]
  00098	e1a0e00f	 mov         lr, pc
  0009c	e12fff13	 bx          r3

; 2209 : 
; 2210 :     // TI spec TRM V.H 25.12.3.2 & 25.12.3.3
; 2211 :     // Clear the EnableForce bit
; 2212 :     CLRREG32(&pOtg->OTG_FORCESTDBY, OTG_FORCESTDY_ENABLEFORCE);

  000a0	e5953014	 ldr         r3, [r5, #0x14]

; 2213 : 
; 2214 : #if 1
; 2215 :     // Enable Wakeup
; 2216 :     SETREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_ENABLEWAKEUP);
; 2217 : 
; 2218 :     // Set the MIDLEMODE to SmartStandy
; 2219 :     CLRREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_M_MASK);
; 2220 :     SETREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_M_SMARTSTDBY);
; 2221 : 
; 2222 :     // Set the SIDLEMODE to SmartIdle
; 2223 :     CLRREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_S_MASK);
; 2224 :     SETREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_S_SMARTIDLE);
; 2225 : 
; 2226 :     // Clear the AutoIdle mode
; 2227 :     CLRREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_AUTOIDLE);
; 2228 : 
; 2229 :     // Set back the AutoIdle mode to 1
; 2230 :     SETREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_AUTOIDLE);
; 2231 : #else
; 2232 :     // Set the MIDLEMODE to NoStandy.  For smartfon, if use SmartStandy, system doesn't wake up from retention.
; 2233 :     CLRREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_M_MASK);
; 2234 :     //SETREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_M_SMARTSTDBY);
; 2235 : 
; 2236 :     // Set the SIDLEMODE to SmartIdle
; 2237 :     CLRREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_S_MASK);
; 2238 :     //SETREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_S_SMARTIDLE);
; 2239 : 
; 2240 :     // Clear the AutoIdle mode
; 2241 :     //CLRREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_AUTOIDLE);
; 2242 : 
; 2243 :     // Set back the AutoIdle mode to 1
; 2244 :     //SETREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_AUTOIDLE);
; 2245 : #endif
; 2246 : 	
; 2247 :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("-StartUSBClock\r\n")));
; 2248 : 
; 2249 :     if (fInc)

  000a4	e3560000	 cmp         r6, #0
  000a8	e3c33001	 bic         r3, r3, #1
  000ac	e5853014	 str         r3, [r5, #0x14]
  000b0	e5953004	 ldr         r3, [r5, #4]
  000b4	e3833004	 orr         r3, r3, #4
  000b8	e5853004	 str         r3, [r5, #4]
  000bc	e5953004	 ldr         r3, [r5, #4]
  000c0	e3c33a03	 bic         r3, r3, #3, 20
  000c4	e5853004	 str         r3, [r5, #4]
  000c8	e5953004	 ldr         r3, [r5, #4]
  000cc	e3833a02	 orr         r3, r3, #2, 20
  000d0	e5853004	 str         r3, [r5, #4]
  000d4	e5953004	 ldr         r3, [r5, #4]
  000d8	e3c33018	 bic         r3, r3, #0x18
  000dc	e5853004	 str         r3, [r5, #4]
  000e0	e5953004	 ldr         r3, [r5, #4]
  000e4	e3833010	 orr         r3, r3, #0x10
  000e8	e5853004	 str         r3, [r5, #4]
  000ec	e5953004	 ldr         r3, [r5, #4]
  000f0	e3c33001	 bic         r3, r3, #1
  000f4	e5853004	 str         r3, [r5, #4]
  000f8	e5953004	 ldr         r3, [r5, #4]
  000fc	e3833001	 orr         r3, r3, #1
  00100	e5853004	 str         r3, [r5, #4]

; 2250 :         m_dwUSBUsageCount++;

  00104	15943160	 ldrne       r3, [r4, #0x160]

; 2251 : 
; 2252 :     m_bUSBClockEnable = TRUE;
; 2253 :     m_pOTG->bClockStatus = TRUE;

  00108	e3a05001	 mov         r5, #1
  0010c	e584515c	 str         r5, [r4, #0x15C]
  00110	12833001	 addne       r3, r3, #1
  00114	15843160	 strne       r3, [r4, #0x160]
  00118	e5943150	 ldr         r3, [r4, #0x150]
  0011c	e5835060	 str         r5, [r3, #0x60]
  00120		 |$LN9@StartUSBCl|
  00120	e2840f49	 add         r0, r4, #0x49, 30
  00124	eb000000	 bl          LeaveCriticalSection

; 2254 :     LeaveCriticalSection(&m_csUSBClock);
; 2255 : 
; 2256 :     return TRUE;
; 2257 : 
; 2258 : }

  00128	e1a00005	 mov         r0, r5
  0012c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00130	e12fff1e	 bx          lr
  00134		 |$LN13@StartUSBCl|
  00134		 |$LN14@StartUSBCl|
  00134	00000000	 DCD         |?g_busDx@@3W4_CEDEVICE_POWER_STATE@@A|
  00138		 |$M43332|

			 ENDP  ; |?StartUSBClock@OMAPMHSUSBOTG@@UAAHH@Z|, OMAPMHSUSBOTG::StartUSBClock

	EXPORT	|?SetPowerState@OMAPMHSUSBOTG@@UAAHW4_CEDEVICE_POWER_STATE@@@Z| ; OMAPMHSUSBOTG::SetPowerState

  00000			 AREA	 |.pdata|, PDATA
|$T43366| DCD	|$LN35@SetPowerSt@2|
	DCD	0x4000f401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetPowerState@OMAPMHSUSBOTG@@UAAHW4_CEDEVICE_POWER_STATE@@@Z| PROC ; OMAPMHSUSBOTG::SetPowerState

; 2261 : {

  00000		 |$LN35@SetPowerSt@2|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M43363|
  00004	e3510000	 cmp         r1, #0
  00008	e1a08000	 mov         r8, r0

; 2262 :     PCSP_MUSB_GEN_REGS pGen = m_pOTG->pUsbGenRegs;

  0000c	e5982150	 ldr         r2, [r8, #0x150]
  00010	e5929020	 ldr         r9, [r2, #0x20]

; 2263 : 
; 2264 :     switch (reqDx)

  00014	4a0000e9	 bmi         |$cleanUp$41498|
  00018	e3510002	 cmp         r1, #2
  0001c	da00004a	 ble         |$LN19@SetPowerSt@2|
  00020	e3510004	 cmp         r1, #4
  00024	ca0000e5	 bgt         |$cleanUp$41498|

; 2349 : 			}
; 2350 :         }
; 2351 :         break;
; 2352 : 
; 2353 :         case D3:
; 2354 :         case D4:
; 2355 :         {
; 2356 :             pGen = m_pOTG->pUsbGenRegs;
; 2357 :             if (!m_disconnected)

  00028	e598318c	 ldr         r3, [r8, #0x18C]
  0002c	e3530000	 cmp         r3, #0
  00030	1a000038	 bne         |$LN7@SetPowerSt@2|

; 2358 :             {
; 2359 :                 m_pOTG->dwPwrMgmt = MODE_SYSTEM_SUSPEND;

  00034	e3a03001	 mov         r3, #1
  00038	e5823064	 str         r3, [r2, #0x64]

; 2360 :                 DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("OTG Power Down\r\n")));
; 2361 : 
; 2362 :                 if(m_pOTG->bClockStatus != TRUE)

  0003c	e5982150	 ldr         r2, [r8, #0x150]
  00040	e5923060	 ldr         r3, [r2, #0x60]
  00044	e3530001	 cmp         r3, #1
  00048	1a0000dc	 bne         |$cleanUp$41498|

; 2363 :                     goto cleanUp;
; 2364 : 
; 2365 :                 if (m_pOTG->pUsbGenRegs->DevCtl & DEVCTL_HOSTMODE)

  0004c	e5922020	 ldr         r2, [r2, #0x20]
  00050	e5d23060	 ldrb        r3, [r2, #0x60]
  00054	e3130004	 tst         r3, #4
  00058	0a00000d	 beq         |$LN4@SetPowerSt@2|

; 2366 :                 {
; 2367 :                     DEBUGMSG(ZONE_OTG_INFO, (TEXT("OTG Power Down SetDevicePowerState D3\r\n")));
; 2368 : 
; 2369 : 				    CLRREG8(&m_pOTG->pUsbGenRegs->DevCtl, DEVCTL_SESSION);

  0005c	e5d23060	 ldrb        r3, [r2, #0x60]

; 2370 : 					
; 2371 : //					Sleep(100);
; 2372 : 
; 2373 :                     SETREG8(&m_pOTG->pUsbGenRegs->Power, POWER_EN_SUSPENDM);
; 2374 :                     SETREG8(&m_pOTG->pUsbGenRegs->Power, POWER_SUSPENDM);
; 2375 : 
; 2376 : 					Sleep(100);

  00060	e20330fe	 and         r3, r3, #0xFE
  00064	e5c23060	 strb        r3, [r2, #0x60]
  00068	e5983150	 ldr         r3, [r8, #0x150]
  0006c	e5932020	 ldr         r2, [r3, #0x20]
  00070	e5d23001	 ldrb        r3, [r2, #1]
  00074	e3833001	 orr         r3, r3, #1
  00078	e5c23001	 strb        r3, [r2, #1]
  0007c	e5983150	 ldr         r3, [r8, #0x150]
  00080	e5932020	 ldr         r2, [r3, #0x20]
  00084	e5d23001	 ldrb        r3, [r2, #1]
  00088	e3833002	 orr         r3, r3, #2
  0008c	e5c23001	 strb        r3, [r2, #1]

; 2377 : 
; 2378 : 					// clock control moved to PowerDown
; 2379 :                 }
; 2380 :                 else

  00090	ea00001d	 b           |$LN32@SetPowerSt@2|
  00094		 |$LN4@SetPowerSt@2|

; 2381 :                 {
; 2382 :                     DEBUGMSG(ZONE_OTG_INFO, (TEXT("OTG Power Down SetDevicePowerState D4\r\n")));
; 2383 : 
; 2384 :                     OUTREG8(&pGen->IntrUSBE, 0);

  00094	e3a04000	 mov         r4, #0
  00098	e5c9400b	 strb        r4, [r9, #0xB]

; 2385 :                     OUTREG16(&pGen->IntrTxE, 0);

  0009c	e5c94006	 strb        r4, [r9, #6]
  000a0	e5c94007	 strb        r4, [r9, #7]

; 2386 :                     OUTREG16(&pGen->IntrRxE, 0);

  000a4	e5c94008	 strb        r4, [r9, #8]
  000a8	e5c94009	 strb        r4, [r9, #9]

; 2387 : 
; 2388 :                     // Simulate disconnect.
; 2389 :                     CLRREG8(&m_pOTG->pUsbGenRegs->Power, POWER_SOFTCONN);

  000ac	e5983150	 ldr         r3, [r8, #0x150]

; 2390 : 
; 2391 :                     // Read Interrupt status registers to clear outstanding interrupts
; 2392 :                     INREG8(&pGen->IntrUSB);
; 2393 :                     INREG16(&pGen->IntrTx);
; 2394 :                     INREG16(&pGen->IntrRx);
; 2395 : 
; 2396 :                     SessionRequest(FALSE, FALSE);

  000b0	e3a02000	 mov         r2, #0
  000b4	e3a01000	 mov         r1, #0
  000b8	e593e020	 ldr         lr, [r3, #0x20]
  000bc	e1a00008	 mov         r0, r8
  000c0	e5de3001	 ldrb        r3, [lr, #1]
  000c4	e20330bf	 and         r3, r3, #0xBF
  000c8	e5ce3001	 strb        r3, [lr, #1]
  000cc	e5d9700a	 ldrb        r7, [r9, #0xA]
  000d0	e5d96002	 ldrb        r6, [r9, #2]
  000d4	e5d94003	 ldrb        r4, [r9, #3]
  000d8	e5d95004	 ldrb        r5, [r9, #4]
  000dc	e5d93005	 ldrb        r3, [r9, #5]
  000e0	e598e000	 ldr         lr, [r8]
  000e4	e1866404	 orr         r6, r6, r4, lsl #8
  000e8	e1853403	 orr         r3, r5, r3, lsl #8
  000ec	e59e4084	 ldr         r4, [lr, #0x84]
  000f0	e1a0e00f	 mov         lr, pc
  000f4	e12fff14	 bx          r4

; 2397 : 
; 2398 :                     PowerDownDisconnect();

  000f8	e5983000	 ldr         r3, [r8]
  000fc	e1a00008	 mov         r0, r8
  00100	e59330d4	 ldr         r3, [r3, #0xD4]
  00104	e1a0e00f	 mov         lr, pc
  00108	e12fff13	 bx          r3
  0010c		 |$LN32@SetPowerSt@2|

; 2399 : 
; 2400 : 					Sleep(100);

  0010c	e3a00064	 mov         r0, #0x64
  00110	eb000000	 bl          Sleep

; 2401 : 
; 2402 : 					// clock control moved to PowerDown
; 2403 :                 }
; 2404 :             }
; 2405 :             else

  00114	ea000005	 b           |$LN2@SetPowerSt@2|
  00118		 |$LN7@SetPowerSt@2|

; 2406 :             {
; 2407 :                 if(m_pOTG->bClockStatus == TRUE)

  00118	e5923060	 ldr         r3, [r2, #0x60]
  0011c	e3a01001	 mov         r1, #1
  00120	e3530001	 cmp         r3, #1

; 2408 :                 {
; 2409 : 	                m_pOTG->dwPwrMgmt = MODE_SYSTEM_SUSPEND;

  00124	05821064	 streq       r1, [r2, #0x64]

; 2410 : 					// clock control moved to PowerDown
; 2411 :                 }
; 2412 : 
; 2413 :                 m_pOTG->dwPwrMgmt = MODE_SYSTEM_SUSPEND;

  00128	e5983150	 ldr         r3, [r8, #0x150]
  0012c	e5831064	 str         r1, [r3, #0x64]
  00130		 |$LN2@SetPowerSt@2|

; 2414 :             }
; 2415 :             m_pTransceiver->EnableWakeupInterrupt(TRUE);

  00130	e59800fc	 ldr         r0, [r8, #0xFC]
  00134	e3a01001	 mov         r1, #1
  00138	e5903000	 ldr         r3, [r0]
  0013c	e5933008	 ldr         r3, [r3, #8]
  00140	e1a0e00f	 mov         lr, pc
  00144	e12fff13	 bx          r3

; 2416 :         }
; 2417 :         break;

  00148	ea00009c	 b           |$cleanUp$41498|
  0014c		 |$LN19@SetPowerSt@2|

; 2265 :     {
; 2266 :         case D0:
; 2267 :         case D1:
; 2268 :         case D2:
; 2269 :         {
; 2270 :             BOOL a_device_present;
; 2271 :             BOOL b_device_present;
; 2272 : 
; 2273 :             if (m_pTransceiver->SupportsTransceiverWakeWithoutClock())

  0014c	e59800fc	 ldr         r0, [r8, #0xFC]
  00150	e5903000	 ldr         r3, [r0]
  00154	e5933014	 ldr         r3, [r3, #0x14]
  00158	e1a0e00f	 mov         lr, pc
  0015c	e12fff13	 bx          r3
  00160	e3500000	 cmp         r0, #0

; 2274 : 			{
; 2275 :                 // *** Transceiver in TWL4030/TPS659xx ***
; 2276 : 
; 2277 :                 a_device_present = m_pTransceiver->IsADeviceConnected();

  00164	e59800fc	 ldr         r0, [r8, #0xFC]
  00168	e5903000	 ldr         r3, [r0]
  0016c	0a000083	 beq         |$LN18@SetPowerSt@2|
  00170	e5933030	 ldr         r3, [r3, #0x30]
  00174	e1a0e00f	 mov         lr, pc
  00178	e12fff13	 bx          r3

; 2278 :                 b_device_present = m_pTransceiver->IsBDeviceConnected();

  0017c	e59820fc	 ldr         r2, [r8, #0xFC]
  00180	e1a06000	 mov         r6, r0
  00184	e5923000	 ldr         r3, [r2]
  00188	e1a00002	 mov         r0, r2
  0018c	e5933034	 ldr         r3, [r3, #0x34]
  00190	e1a0e00f	 mov         lr, pc
  00194	e12fff13	 bx          r3

; 2279 : 
; 2280 :                 m_bIncCount = FALSE;
; 2281 :                 m_pOTG->dwPwrMgmt = MODE_SYSTEM_RESUME;

  00198	e5983150	 ldr         r3, [r8, #0x150]
  0019c	e3a04000	 mov         r4, #0
  001a0	e3a02002	 mov         r2, #2
  001a4	e5884180	 str         r4, [r8, #0x180]
  001a8	e5832064	 str         r2, [r3, #0x64]

; 2282 : 
; 2283 :                 StartUSBClock(TRUE);

  001ac	e5983000	 ldr         r3, [r8]
  001b0	e1a05000	 mov         r5, r0
  001b4	e3a01001	 mov         r1, #1
  001b8	e59330e4	 ldr         r3, [r3, #0xE4]
  001bc	e1a00008	 mov         r0, r8
  001c0	e1a0e00f	 mov         lr, pc
  001c4	e12fff13	 bx          r3

; 2284 : 
; 2285 :                 if(m_disconnected)

  001c8	e598318c	 ldr         r3, [r8, #0x18C]
  001cc	e3530000	 cmp         r3, #0
  001d0	0a000048	 beq         |$LN17@SetPowerSt@2|

; 2286 :                 {
; 2287 :                     if(a_device_present)

  001d4	e3560000	 cmp         r6, #0
  001d8	0a000017	 beq         |$LN16@SetPowerSt@2|

; 2288 :                     {
; 2289 :                         OUTREG8(&pGen->IntrUSBE, INTRUSB_ALL&~INTRUSB_SOF);

  001dc	e3a030f7	 mov         r3, #0xF7
  001e0	e5c9300b	 strb        r3, [r9, #0xB]

; 2290 :                         OUTREG16(&pGen->IntrTxE, 0xffff);

  001e4	e3a030ff	 mov         r3, #0xFF
  001e8	e5c93006	 strb        r3, [r9, #6]

; 2291 :                         OUTREG16(&pGen->IntrRxE, 0xfffe);

  001ec	e3a020fe	 mov         r2, #0xFE
  001f0	e5c93007	 strb        r3, [r9, #7]
  001f4	e5c92008	 strb        r2, [r9, #8]
  001f8	e5c93009	 strb        r3, [r9, #9]

; 2292 : 
; 2293 :                         if (m_OTGRegCfg.DisableHighSpeed)

  001fc	e5983100	 ldr         r3, [r8, #0x100]
  00200	e3530000	 cmp         r3, #0

; 2294 : 						{
; 2295 :                             CLRREG8(&m_pOTG->pUsbGenRegs->Power, POWER_HSENABLE);

  00204	e5983150	 ldr         r3, [r8, #0x150]
  00208	e5932020	 ldr         r2, [r3, #0x20]
  0020c	e5d23001	 ldrb        r3, [r2, #1]
  00210	120330df	 andne       r3, r3, #0xDF
  00214	15c23001	 strneb      r3, [r2, #1]

; 2296 :                             SETREG8(&m_pOTG->pUsbGenRegs->Power, POWER_SOFTCONN);

  00218	15983150	 ldrne       r3, [r8, #0x150]
  0021c	15932020	 ldrne       r2, [r3, #0x20]
  00220	15d23001	 ldrneb      r3, [r2, #1]
  00224	13833040	 orrne       r3, r3, #0x40

; 2297 : 						}
; 2298 :                         else
; 2299 :                             SETREG8(&m_pOTG->pUsbGenRegs->Power, POWER_HSENABLE|POWER_SOFTCONN);

  00228	15c23001	 strneb      r3, [r2, #1]
  0022c	1a000063	 bne         |$cleanUp$41498|
  00230	e3833060	 orr         r3, r3, #0x60
  00234	e5c23001	 strb        r3, [r2, #1]
  00238	ea000060	 b           |$cleanUp$41498|
  0023c		 |$LN16@SetPowerSt@2|

; 2300 :                     }
; 2301 :                     else if(b_device_present)

  0023c	e3550000	 cmp         r5, #0
  00240	0a000015	 beq         |$LN12@SetPowerSt@2|

; 2302 :                     {
; 2303 :                         OUTREG8(&pGen->IntrUSBE, INTRUSB_ALL&~INTRUSB_SOF);

  00244	e3a030f7	 mov         r3, #0xF7
  00248	e5c9300b	 strb        r3, [r9, #0xB]

; 2304 :                         OUTREG16(&pGen->IntrTxE, 0xffff);

  0024c	e3a030ff	 mov         r3, #0xFF
  00250	e5c93006	 strb        r3, [r9, #6]

; 2305 :                         OUTREG16(&pGen->IntrRxE, 0xfffe);

  00254	e3a020fe	 mov         r2, #0xFE
  00258	e5c93007	 strb        r3, [r9, #7]
  0025c	e5c92008	 strb        r2, [r9, #8]
  00260	e5c93009	 strb        r3, [r9, #9]

; 2306 : 
; 2307 :                         m_dwStatus = STATUS_SESSION_RESTART;
; 2308 :                         CLRREG8(&m_pOTG->pUsbGenRegs->Power, POWER_SUSPENDM);

  00264	e5983150	 ldr         r3, [r8, #0x150]
  00268	e3a02080	 mov         r2, #0x80
  0026c	e58820f8	 str         r2, [r8, #0xF8]
  00270	e5932020	 ldr         r2, [r3, #0x20]

; 2309 :                         m_pTransceiver->SetVBusSource(TRUE);

  00274	e3a01001	 mov         r1, #1
  00278	e5d23001	 ldrb        r3, [r2, #1]
  0027c	e20330fd	 and         r3, r3, #0xFD
  00280	e5c23001	 strb        r3, [r2, #1]
  00284	e59800fc	 ldr         r0, [r8, #0xFC]
  00288	e5903000	 ldr         r3, [r0]
  0028c	e5933004	 ldr         r3, [r3, #4]
  00290	e1a0e00f	 mov         lr, pc
  00294	e12fff13	 bx          r3

; 2310 :                     }
; 2311 :                     else

  00298	ea000048	 b           |$cleanUp$41498|
  0029c		 |$LN12@SetPowerSt@2|

; 2312 :                     {
; 2313 :                         StopUSBClock();

  0029c	e5983000	 ldr         r3, [r8]
  002a0	e1a00008	 mov         r0, r8
  002a4	e59330e8	 ldr         r3, [r3, #0xE8]
  002a8	e1a0e00f	 mov         lr, pc
  002ac	e12fff13	 bx          r3

; 2314 : 
; 2315 :                         m_pOTG->bClockStatus = FALSE;

  002b0	e5983150	 ldr         r3, [r8, #0x150]

; 2316 :                         UpdateDevicePower(m_hParent, D4, NULL);

  002b4	e59f2110	 ldr         r2, [pc, #0x110]
  002b8	e5834060	 str         r4, [r3, #0x60]
  002bc	e5923000	 ldr         r3, [r2]
  002c0	e5980140	 ldr         r0, [r8, #0x140]
  002c4	e3530004	 cmp         r3, #4
  002c8	13a03004	 movne       r3, #4
  002cc	15823000	 strne       r3, [r2]
  002d0	13a02000	 movne       r2, #0
  002d4	13a01004	 movne       r1, #4
  002d8	1b000000	 blne        SetDevicePowerState

; 2317 :                         m_pTransceiver->EnableWakeupInterrupt(TRUE);

  002dc	e59800fc	 ldr         r0, [r8, #0xFC]
  002e0	e3a01001	 mov         r1, #1
  002e4	e5903000	 ldr         r3, [r0]
  002e8	e5933008	 ldr         r3, [r3, #8]
  002ec	e1a0e00f	 mov         lr, pc
  002f0	e12fff13	 bx          r3

; 2318 :                     }
; 2319 :                 }
; 2320 :                 else

  002f4	ea000031	 b           |$cleanUp$41498|
  002f8		 |$LN17@SetPowerSt@2|

; 2321 :                 {
; 2322 :                     StopUSBClock();

  002f8	e5983000	 ldr         r3, [r8]
  002fc	e1a00008	 mov         r0, r8
  00300	e59330e8	 ldr         r3, [r3, #0xE8]
  00304	e1a0e00f	 mov         lr, pc
  00308	e12fff13	 bx          r3

; 2323 : 
; 2324 :                     CLRREG8(&m_pOTG->pUsbGenRegs->Power, POWER_SUSPENDM);

  0030c	e5983150	 ldr         r3, [r8, #0x150]

; 2325 :                     m_pTransceiver->SetVBusSource(TRUE);

  00310	e3a01001	 mov         r1, #1
  00314	e5932020	 ldr         r2, [r3, #0x20]
  00318	e5d23001	 ldrb        r3, [r2, #1]
  0031c	e20330fd	 and         r3, r3, #0xFD
  00320	e5c23001	 strb        r3, [r2, #1]
  00324	e59800fc	 ldr         r0, [r8, #0xFC]
  00328	e5903000	 ldr         r3, [r0]
  0032c	e5933004	 ldr         r3, [r3, #4]
  00330	e1a0e00f	 mov         lr, pc
  00334	e12fff13	 bx          r3

; 2326 : 
; 2327 :                     m_pOTG->bClockStatus = FALSE;

  00338	e5983150	 ldr         r3, [r8, #0x150]

; 2328 :                     UpdateDevicePower(m_hParent, D4, NULL);

  0033c	e59f2088	 ldr         r2, [pc, #0x88]
  00340	e5834060	 str         r4, [r3, #0x60]
  00344	e5923000	 ldr         r3, [r2]
  00348	e5980140	 ldr         r0, [r8, #0x140]
  0034c	e3530004	 cmp         r3, #4
  00350	13a03004	 movne       r3, #4
  00354	15823000	 strne       r3, [r2]
  00358	13a02000	 movne       r2, #0
  0035c	13a01004	 movne       r1, #4
  00360	1b000000	 blne        SetDevicePowerState

; 2329 : 
; 2330 :                     m_pTransceiver->EnableWakeupInterrupt(TRUE);

  00364	e59800fc	 ldr         r0, [r8, #0xFC]
  00368	e3a01001	 mov         r1, #1
  0036c	e5903000	 ldr         r3, [r0]
  00370	e5933008	 ldr         r3, [r3, #8]
  00374	e1a0e00f	 mov         lr, pc
  00378	e12fff13	 bx          r3

; 2331 :                 }
; 2332 : 			}
; 2333 : 			else

  0037c	ea00000f	 b           |$cleanUp$41498|
  00380		 |$LN18@SetPowerSt@2|

; 2334 : 			{
; 2335 :                 // *** Transceiver is pure ULPI interface ***
; 2336 : 
; 2337 : 				// clock control moved to PowerUp
; 2338 : 
; 2339 : 				// resume transceiver configuration (may restore external VBUS control)
; 2340 : 				m_pTransceiver->Resume();

  00380	e5933028	 ldr         r3, [r3, #0x28]
  00384	e1a0e00f	 mov         lr, pc
  00388	e12fff13	 bx          r3

; 2341 : 
; 2342 :                 OUTREG8(&pGen->IntrUSBE, INTRUSB_ALL&~INTRUSB_SOF);

  0038c	e3a030f7	 mov         r3, #0xF7
  00390	e5c9300b	 strb        r3, [r9, #0xB]

; 2343 :                 OUTREG16(&pGen->IntrTxE, 0xffff);

  00394	e3a030ff	 mov         r3, #0xFF
  00398	e5c93006	 strb        r3, [r9, #6]

; 2344 :                 OUTREG16(&pGen->IntrRxE, 0xfffe);

  0039c	e3a020fe	 mov         r2, #0xFE
  003a0	e5c93007	 strb        r3, [r9, #7]
  003a4	e5c92008	 strb        r2, [r9, #8]
  003a8	e5c93009	 strb        r3, [r9, #9]

; 2345 : 
; 2346 :                 m_pOTG->dwPwrMgmt = MODE_SYSTEM_RESUME;

  003ac	e5983150	 ldr         r3, [r8, #0x150]
  003b0	e3a02002	 mov         r2, #2
  003b4	e5832064	 str         r2, [r3, #0x64]

; 2347 : 				
; 2348 :                 SetInterruptEvent(m_dwSysIntr);

  003b8	e5980144	 ldr         r0, [r8, #0x144]
  003bc	eb000000	 bl          SetInterruptEvent
  003c0		 |$cleanUp$41498|

; 2418 :     }
; 2419 : cleanUp:
; 2420 :     return TRUE;

  003c0	e3a00001	 mov         r0, #1

; 2421 : }

  003c4	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  003c8	e12fff1e	 bx          lr
  003cc		 |$LN36@SetPowerSt@2|
  003cc		 |$LN37@SetPowerSt@2|
  003cc	00000000	 DCD         |?g_busDx@@3W4_CEDEVICE_POWER_STATE@@A|
  003d0		 |$M43364|

			 ENDP  ; |?SetPowerState@OMAPMHSUSBOTG@@UAAHW4_CEDEVICE_POWER_STATE@@@Z|, OMAPMHSUSBOTG::SetPowerState

	EXPORT	|?PowerUp@OMAPMHSUSBOTG@@UAAHXZ|	; OMAPMHSUSBOTG::PowerUp

  00000			 AREA	 |.pdata|, PDATA
|$T43384| DCD	|$LN8@PowerUp|
	DCD	0x40001601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PowerUp@OMAPMHSUSBOTG@@UAAHXZ| PROC	; OMAPMHSUSBOTG::PowerUp

; 2440 : {

  00000		 |$LN8@PowerUp|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M43381|
  00004	e1a04000	 mov         r4, r0

; 2441 : 	m_bIncCount = FALSE;
; 2442 : 				
; 2443 :     StartUSBClock(TRUE);

  00008	e5943000	 ldr         r3, [r4]
  0000c	e3a02000	 mov         r2, #0
  00010	e3a01001	 mov         r1, #1
  00014	e59330e4	 ldr         r3, [r3, #0xE4]
  00018	e5842180	 str         r2, [r4, #0x180]
  0001c	e1a0e00f	 mov         lr, pc
  00020	e12fff13	 bx          r3

; 2444 :     UpdateDevicePower(m_hParent, D0, NULL);

  00024	e59f2028	 ldr         r2, [pc, #0x28]
  00028	e5940140	 ldr         r0, [r4, #0x140]
  0002c	e5923000	 ldr         r3, [r2]
  00030	e3530000	 cmp         r3, #0
  00034	13a03000	 movne       r3, #0
  00038	15823000	 strne       r3, [r2]
  0003c	13a02000	 movne       r2, #0
  00040	13a01000	 movne       r1, #0
  00044	1b000000	 blne        SetDevicePowerState

; 2445 :     return TRUE;

  00048	e3a00001	 mov         r0, #1

; 2446 : }

  0004c	e8bd4010	 ldmia       sp!, {r4, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$LN9@PowerUp|
  00054		 |$LN10@PowerUp|
  00054	00000000	 DCD         |?g_busDx@@3W4_CEDEVICE_POWER_STATE@@A|
  00058		 |$M43382|

			 ENDP  ; |?PowerUp@OMAPMHSUSBOTG@@UAAHXZ|, OMAPMHSUSBOTG::PowerUp

	EXPORT	|?PowerDown@OMAPMHSUSBOTG@@UAAHXZ|	; OMAPMHSUSBOTG::PowerDown

  00000			 AREA	 |.pdata|, PDATA
|$T43402| DCD	|$LN8@PowerDown|
	DCD	0x40001701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PowerDown@OMAPMHSUSBOTG@@UAAHXZ| PROC ; OMAPMHSUSBOTG::PowerDown

; 2465 : {

  00000		 |$LN8@PowerDown|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43399|
  00004	e1a04000	 mov         r4, r0

; 2466 :     m_dwUSBUsageCount = 0;
; 2467 :     StopUSBClock();

  00008	e5943000	 ldr         r3, [r4]
  0000c	e3a05000	 mov         r5, #0
  00010	e5845160	 str         r5, [r4, #0x160]
  00014	e59330e8	 ldr         r3, [r3, #0xE8]
  00018	e1a0e00f	 mov         lr, pc
  0001c	e12fff13	 bx          r3

; 2468 : 
; 2469 :     m_pOTG->bClockStatus = FALSE;

  00020	e5943150	 ldr         r3, [r4, #0x150]

; 2470 :     UpdateDevicePower(m_hParent, D4, NULL);

  00024	e59f202c	 ldr         r2, [pc, #0x2C]
  00028	e5835060	 str         r5, [r3, #0x60]
  0002c	e5923000	 ldr         r3, [r2]
  00030	e5940140	 ldr         r0, [r4, #0x140]
  00034	e3530004	 cmp         r3, #4
  00038	13a03004	 movne       r3, #4
  0003c	15823000	 strne       r3, [r2]
  00040	13a02000	 movne       r2, #0
  00044	13a01004	 movne       r1, #4
  00048	1b000000	 blne        SetDevicePowerState

; 2471 :      return TRUE;

  0004c	e3a00001	 mov         r0, #1

; 2472 : }

  00050	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$LN9@PowerDown|
  00058		 |$LN10@PowerDown|
  00058	00000000	 DCD         |?g_busDx@@3W4_CEDEVICE_POWER_STATE@@A|
  0005c		 |$M43400|

			 ENDP  ; |?PowerDown@OMAPMHSUSBOTG@@UAAHXZ|, OMAPMHSUSBOTG::PowerDown

	EXPORT	|?DelayByRegisterRead@OMAPMHSUSBOTG@@QAAXXZ| ; OMAPMHSUSBOTG::DelayByRegisterRead

  00000			 AREA	 |.pdata|, PDATA
|$T43415| DCD	|$LN10@DelayByReg|
	DCD	0x40000700
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DelayByRegisterRead@OMAPMHSUSBOTG@@QAAXXZ| PROC ; OMAPMHSUSBOTG::DelayByRegisterRead

; 2479 : {

  00000		 |$LN10@DelayByReg|
  00000		 |$M43412|

; 2480 :     PCSP_MUSB_OTG_REGS pOtg;
; 2481 :     DWORD i;
; 2482 : 
; 2483 :     pOtg = m_pOTG->pUsbOtgRegs;

  00000	e5903150	 ldr         r3, [r0, #0x150]
  00004	e3a0200c	 mov         r2, #0xC
  00008	e5931018	 ldr         r1, [r3, #0x18]
  0000c		 |$LL3@DelayByReg|

; 2484 : 
; 2485 :     for(i=0;i<12;i++)
; 2486 :     INREG32(&pOtg->OTG_Rev);

  0000c	e5913000	 ldr         r3, [r1]
  00010	e2522001	 subs        r2, r2, #1
  00014	1afffffc	 bne         |$LL3@DelayByReg|

; 2487 : }

  00018	e12fff1e	 bx          lr
  0001c		 |$M43413|

			 ENDP  ; |?DelayByRegisterRead@OMAPMHSUSBOTG@@QAAXXZ|, OMAPMHSUSBOTG::DelayByRegisterRead

	EXPORT	|?ContextRestore@OMAPMHSUSBOTG@@UAAHXZ|	; OMAPMHSUSBOTG::ContextRestore

  00000			 AREA	 |.pdata|, PDATA
|$T43424| DCD	|$LN5@ContextRes|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ContextRestore@OMAPMHSUSBOTG@@UAAHXZ| PROC ; OMAPMHSUSBOTG::ContextRestore

; 2493 : {

  00000		 |$LN5@ContextRes|
  00000		 |$M43421|

; 2494 :     // We do nothing here. Everything necessary is moved to SetPowerState(D2)
; 2495 :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 2496 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M43422|

			 ENDP  ; |?ContextRestore@OMAPMHSUSBOTG@@UAAHXZ|, OMAPMHSUSBOTG::ContextRestore

	EXPORT	|?ResetEndPoints@OMAPMHSUSBOTG@@UAAXXZ|	; OMAPMHSUSBOTG::ResetEndPoints

  00000			 AREA	 |.pdata|, PDATA
|$T43438| DCD	|$LN15@ResetEndPo|
	DCD	0x40002601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResetEndPoints@OMAPMHSUSBOTG@@UAAXXZ| PROC ; OMAPMHSUSBOTG::ResetEndPoints

; 2713 : {

  00000		 |$LN15@ResetEndPo|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M43435|

; 2714 :     PCSP_MUSB_GEN_REGS pGen;
; 2715 :     PCSP_MUSB_CSR_REGS pCsr;
; 2716 : 
; 2717 :     pGen = m_pOTG->pUsbGenRegs;

  00004	e5903150	 ldr         r3, [r0, #0x150]

; 2718 :     pCsr = m_pOTG->pUsbCsrRegs;
; 2719 : 
; 2720 :     DEBUGMSG(ZONE_OTG_INIT || ZONE_OTG_FUNCTION, (TEXT("ResetEndPoints\r\n")));    
; 2721 :     int i = 0;
; 2722 : 
; 2723 :     for (i = 0; i < 15; i++)

  00008	e3a01000	 mov         r1, #0
  0000c	e3a04000	 mov         r4, #0
  00010	e593e020	 ldr         lr, [r3, #0x20]
  00014	e593001c	 ldr         r0, [r3, #0x1C]
  00018		 |$LL7@ResetEndPo|

; 2724 :     {
; 2725 :         OUTREG8(&pGen->Index, i);

  00018	e5ce100e	 strb        r1, [lr, #0xE]

; 2726 : 
; 2727 :         if (i == 0)

  0001c	e3510000	 cmp         r1, #0
  00020	1a00000e	 bne         |$LN4@ResetEndPo|

; 2728 :         {
; 2729 :             SETREG16(&pCsr->ep[0].CSR.CSR0, CSR0_P_FLUSHFIFO);

  00024	e5d02002	 ldrb        r2, [r0, #2]
  00028	e5d03003	 ldrb        r3, [r0, #3]
  0002c	e1823403	 orr         r3, r2, r3, lsl #8
  00030	e3833c01	 orr         r3, r3, #1, 24
  00034	e1a02423	 mov         r2, r3, lsr #8
  00038	e5c03002	 strb        r3, [r0, #2]
  0003c	e5c02003	 strb        r2, [r0, #3]
  00040		 |$LL3@ResetEndPo|

; 2730 :             while (INREG16(&pCsr->ep[0].CSR.CSR0) & CSR0_P_FLUSHFIFO);

  00040	e5d02002	 ldrb        r2, [r0, #2]
  00044	e5d03003	 ldrb        r3, [r0, #3]
  00048	e1823403	 orr         r3, r2, r3, lsl #8
  0004c	e3130c01	 tst         r3, #1, 24
  00050	1afffffa	 bne         |$LL3@ResetEndPo|

; 2731 :             OUTREG16(&pCsr->ep[0].CSR.CSR0, 0);

  00054	e5c04002	 strb        r4, [r0, #2]
  00058	e5c04003	 strb        r4, [r0, #3]

; 2732 :         }
; 2733 :         else

  0005c	ea000008	 b           |$LN6@ResetEndPo|
  00060		 |$LN4@ResetEndPo|

; 2734 :         {
; 2735 :             OUTREG16(&pCsr->ep[i].CSR.TxCSR, 0);

  00060	e0803201	 add         r3, r0, r1, lsl #4
  00064	e5c34002	 strb        r4, [r3, #2]
  00068	e5c34003	 strb        r4, [r3, #3]

; 2736 :             OUTREG16(&pCsr->ep[i].RxCSR, 0);

  0006c	e5c34006	 strb        r4, [r3, #6]
  00070	e5c34007	 strb        r4, [r3, #7]

; 2737 :             OUTREG16(&pCsr->ep[i].TxMaxP, 0);

  00074	e5c34000	 strb        r4, [r3]
  00078	e5c34001	 strb        r4, [r3, #1]

; 2738 :             OUTREG16(&pCsr->ep[i].RxMaxP, 0);

  0007c	e5c34004	 strb        r4, [r3, #4]
  00080	e5c34005	 strb        r4, [r3, #5]
  00084		 |$LN6@ResetEndPo|
  00084	e2811001	 add         r1, r1, #1
  00088	e351000f	 cmp         r1, #0xF
  0008c	baffffe1	 blt         |$LL7@ResetEndPo|

; 2739 :         }        
; 2740 :     }
; 2741 : 
; 2742 :     return;
; 2743 : }

  00090	e8bd4010	 ldmia       sp!, {r4, lr}
  00094	e12fff1e	 bx          lr
  00098		 |$M43436|

			 ENDP  ; |?ResetEndPoints@OMAPMHSUSBOTG@@UAAXXZ|, OMAPMHSUSBOTG::ResetEndPoints

	EXPORT	|?UpdateBatteryCharger@OMAPMHSUSBOTG@@UAAXK@Z| ; OMAPMHSUSBOTG::UpdateBatteryCharger
	IMPORT	|SetEventData|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T43451| DCD	|$LN9@UpdateBatt|
	DCD	0x40001101
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbotg\otg.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdateBatteryCharger@OMAPMHSUSBOTG@@UAAXK@Z| PROC ; OMAPMHSUSBOTG::UpdateBatteryCharger

; 2759 : {

  00000		 |$LN9@UpdateBatt|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M43448|
  00004	e1a02001	 mov         r2, r1
  00008	e1a04000	 mov         r4, r0

; 2760 :     if ((m_BatteryChargeStatus == dwCurValue) || (m_BatteryChargeEvent == NULL))

  0000c	e5943178	 ldr         r3, [r4, #0x178]
  00010	e1530002	 cmp         r3, r2
  00014	0a000008	 beq         |$LN1@UpdateBatt|
  00018	e5943174	 ldr         r3, [r4, #0x174]
  0001c	e3530000	 cmp         r3, #0
  00020	0a000005	 beq         |$LN1@UpdateBatt|

; 2761 :         return;
; 2762 : 
; 2763 :     m_BatteryChargeStatus = dwCurValue;
; 2764 :     SetEventData(m_BatteryChargeEvent, m_BatteryChargeStatus);

  00024	e1a00003	 mov         r0, r3
  00028	e5842178	 str         r2, [r4, #0x178]
  0002c	eb000000	 bl          SetEventData

; 2765 :     SetEvent(m_BatteryChargeEvent);

  00030	e5940174	 ldr         r0, [r4, #0x174]
  00034	e3a01003	 mov         r1, #3
  00038	eb000000	 bl          EventModify
  0003c		 |$LN1@UpdateBatt|

; 2766 :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("OMAPMHSUSBOTG::UpdateBatteryCharger to %d\r\n"), m_BatteryChargeStatus));
; 2767 :     return;
; 2768 : }

  0003c	e8bd4010	 ldmia       sp!, {r4, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M43449|

			 ENDP  ; |?UpdateBatteryCharger@OMAPMHSUSBOTG@@UAAXK@Z|, OMAPMHSUSBOTG::UpdateBatteryCharger

	EXPORT	|?SoftResetMUSBController@OMAPMHSUSBOTG@@UAAHH@Z| ; OMAPMHSUSBOTG::SoftResetMUSBController
	IMPORT	|CeGetThreadPriority|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T43475| DCD	|$LN18@SoftResetM|
	DCD	0x40007101
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbotg\otg.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SoftResetMUSBController@OMAPMHSUSBOTG@@UAAHH@Z| PROC ; OMAPMHSUSBOTG::SoftResetMUSBController

; 2782 : {

  00000		 |$LN18@SoftResetM|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M43472|
  00004	e1a04000	 mov         r4, r0

; 2783 :     PCSP_MUSB_OTG_REGS pOtg = m_pOTG->pUsbOtgRegs;      

  00008	e5943150	 ldr         r3, [r4, #0x150]

; 2784 :     PCSP_MUSB_GEN_REGS pGen = m_pOTG->pUsbGenRegs;
; 2785 : 
; 2786 : 	UNREFERENCED_PARAMETER(bCalledFromPowerThread);
; 2787 : 
; 2788 :     DEBUGMSG(ZONE_OTG_INIT || ZONE_OTG_FUNCTION, (TEXT("SoftResetMUSBController\r\n")));    
; 2789 : 
; 2790 :     m_timeout = m_OTGRegCfg.startupTimeout;

  0000c	e5942104	 ldr         r2, [r4, #0x104]

; 2791 :     m_bRequestSession = FALSE;        

  00010	e3a08000	 mov         r8, #0
  00014	e5936018	 ldr         r6, [r3, #0x18]
  00018	e5935020	 ldr         r5, [r3, #0x20]

; 2792 :     m_dwStatus = 0;
; 2793 :     m_disconnected = TRUE;
; 2794 :     m_bSuspendTransceiver = FALSE;
; 2795 :     m_handleVBUSError = FALSE;
; 2796 : 
; 2797 :     // Softreset the MUSB controller
; 2798 :     EnterCriticalSection(&m_pOTG->regCS);

  0001c	e3a09001	 mov         r9, #1
  00020	e2830038	 add         r0, r3, #0x38
  00024	e5842170	 str         r2, [r4, #0x170]
  00028	e5848164	 str         r8, [r4, #0x164]
  0002c	e58480f8	 str         r8, [r4, #0xF8]
  00030	e584918c	 str         r9, [r4, #0x18C]
  00034	e5848190	 str         r8, [r4, #0x190]
  00038	e5848194	 str         r8, [r4, #0x194]
  0003c	eb000000	 bl          EnterCriticalSection

; 2799 :     DWORD dwPriority = CeGetThreadPriority(GetCurrentThread());

  00040	e3a00041	 mov         r0, #0x41
  00044	eb000000	 bl          CeGetThreadPriority
  00048	e1a07000	 mov         r7, r0

; 2800 :     CeSetThreadPriority(GetCurrentThread(), 1);

  0004c	e3a00041	 mov         r0, #0x41
  00050	e3a01001	 mov         r1, #1
  00054	eb000000	 bl          CeSetThreadPriority

; 2801 :     SETREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_SOFTRESET);

  00058	e5963004	 ldr         r3, [r6, #4]
  0005c	e3833002	 orr         r3, r3, #2
  00060	e5863004	 str         r3, [r6, #4]
  00064		 |$LL5@SoftResetM|

; 2802 :     // wait for reset done
; 2803 :     while ((INREG32(&pOtg->OTG_SYSSTATUS) & OTG_SYSSTATUS_RESETDONE) == 0)

  00064	e5963008	 ldr         r3, [r6, #8]
  00068	e3130001	 tst         r3, #1
  0006c	0afffffc	 beq         |$LL5@SoftResetM|

; 2804 : 	{
; 2805 : 	}
; 2806 : 
; 2807 :     EnterCriticalSection(&m_csUSBClock);        

  00070	e2840f49	 add         r0, r4, #0x49, 30
  00074	eb000000	 bl          EnterCriticalSection

; 2808 : 	m_dwUSBUsageCount = 0;
; 2809 :     m_bUSBClockEnable = FALSE;
; 2810 :     StartUSBClock(TRUE);

  00078	e5943000	 ldr         r3, [r4]
  0007c	e3a01001	 mov         r1, #1
  00080	e1a00004	 mov         r0, r4
  00084	e59330e4	 ldr         r3, [r3, #0xE4]
  00088	e5848160	 str         r8, [r4, #0x160]
  0008c	e584815c	 str         r8, [r4, #0x15C]
  00090	e1a0e00f	 mov         lr, pc
  00094	e12fff13	 bx          r3

; 2811 :     LeaveCriticalSection(&m_csUSBClock);        

  00098	e2840f49	 add         r0, r4, #0x49, 30
  0009c	eb000000	 bl          LeaveCriticalSection

; 2812 : 
; 2813 :     if (m_OTGRegCfg.DisableHighSpeed)

  000a0	e5943100	 ldr         r3, [r4, #0x100]

; 2814 :         CLRREG8(&pGen->Power, POWER_HSENABLE);
; 2815 :     CeSetThreadPriority(GetCurrentThread(), dwPriority);

  000a4	e1a01007	 mov         r1, r7
  000a8	e3a00041	 mov         r0, #0x41
  000ac	e3530000	 cmp         r3, #0
  000b0	15d53001	 ldrneb      r3, [r5, #1]
  000b4	120330df	 andne       r3, r3, #0xDF
  000b8	15c53001	 strneb      r3, [r5, #1]
  000bc	eb000000	 bl          CeSetThreadPriority

; 2816 : 
; 2817 :     ResetEndPoints();

  000c0	e5943000	 ldr         r3, [r4]
  000c4	e1a00004	 mov         r0, r4
  000c8	e59330ec	 ldr         r3, [r3, #0xEC]
  000cc	e1a0e00f	 mov         lr, pc
  000d0	e12fff13	 bx          r3

; 2818 :     LeaveCriticalSection(&m_pOTG->regCS);

  000d4	e5943150	 ldr         r3, [r4, #0x150]
  000d8	e2830038	 add         r0, r3, #0x38
  000dc	eb000000	 bl          LeaveCriticalSection

; 2819 : 
; 2820 :     // manually reset transceiver (Advisory 3.0.1.144)
; 2821 :     m_pTransceiver->Reset();

  000e0	e59400fc	 ldr         r0, [r4, #0xFC]
  000e4	e5903000	 ldr         r3, [r0]
  000e8	e5933024	 ldr         r3, [r3, #0x24]
  000ec	e1a0e00f	 mov         lr, pc
  000f0	e12fff13	 bx          r3

; 2822 : 
; 2823 :     Sleep(100);

  000f4	e3a00064	 mov         r0, #0x64
  000f8	eb000000	 bl          Sleep

; 2824 : 
; 2825 :     EnterCriticalSection(&m_pOTG->regCS);

  000fc	e5943150	 ldr         r3, [r4, #0x150]
  00100	e2830038	 add         r0, r3, #0x38
  00104	eb000000	 bl          EnterCriticalSection

; 2826 : 
; 2827 :     // TI spec TRM V.H 25.12.3.2 & 25.12.3.3
; 2828 : 
; 2829 :     // Clear the EnableForce bit 
; 2830 :     CLRREG32(&pOtg->OTG_FORCESTDBY, OTG_FORCESTDY_ENABLEFORCE);

  00108	e5963014	 ldr         r3, [r6, #0x14]

; 2831 : 
; 2832 :     // Set the MIDLEMODE to NoStandy.  For smartfon, if use SmartStandy, system doesn't wake up from retention.
; 2833 :     CLRREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_M_MASK);
; 2834 :     //SETREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_M_SMARTSTDBY);
; 2835 : 
; 2836 :     // Set the SIDLEMODE to SmartIdle
; 2837 :     CLRREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_S_MASK);
; 2838 :     //SETREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_S_SMARTIDLE);
; 2839 : 
; 2840 :     // Clear the AutoIdle mode
; 2841 :     //CLRREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_AUTOIDLE);
; 2842 : 
; 2843 :     // Set back the AutoIdle mode to 1
; 2844 :     SETREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_AUTOIDLE);
; 2845 : 
; 2846 :     // Configure to 12-pin, 8 bit ULPI    
; 2847 :     OUTREG32(&pOtg->OTG_INTERFSEL, OTG_INTERFSEL_12_PIN_ULPI);
; 2848 : 
; 2849 :     // Enable all interrupts except SOF.
; 2850 :     OUTREG8(&pGen->IntrUSBE, INTRUSB_ALL&~INTRUSB_SOF);  

  0010c	e3a020f7	 mov         r2, #0xF7

; 2851 :     OUTREG16(&pGen->IntrTxE, 0xffff);

  00110	e3a010ff	 mov         r1, #0xFF
  00114	e3c33001	 bic         r3, r3, #1
  00118	e5863014	 str         r3, [r6, #0x14]
  0011c	e5963004	 ldr         r3, [r6, #4]

; 2852 :     OUTREG16(&pGen->IntrRxE, 0xfffe);
; 2853 : 
; 2854 :     OUTREG8(&pGen->Testmode,0);    
; 2855 : 
; 2856 :     ResetEndPoints();

  00120	e1a00004	 mov         r0, r4
  00124	e3c33a03	 bic         r3, r3, #3, 20
  00128	e5863004	 str         r3, [r6, #4]
  0012c	e5963004	 ldr         r3, [r6, #4]
  00130	e3c33018	 bic         r3, r3, #0x18
  00134	e5863004	 str         r3, [r6, #4]
  00138	e5963004	 ldr         r3, [r6, #4]
  0013c	e3833001	 orr         r3, r3, #1
  00140	e5863004	 str         r3, [r6, #4]
  00144	e586900c	 str         r9, [r6, #0xC]
  00148	e5c5200b	 strb        r2, [r5, #0xB]
  0014c	e5c51006	 strb        r1, [r5, #6]
  00150	e3a030fe	 mov         r3, #0xFE
  00154	e5c51007	 strb        r1, [r5, #7]
  00158	e5c53008	 strb        r3, [r5, #8]
  0015c	e5c51009	 strb        r1, [r5, #9]
  00160	e5c5800f	 strb        r8, [r5, #0xF]
  00164	e5943000	 ldr         r3, [r4]
  00168	e59330ec	 ldr         r3, [r3, #0xEC]
  0016c	e1a0e00f	 mov         lr, pc
  00170	e12fff13	 bx          r3

; 2857 : 
; 2858 :     if (m_OTGRegCfg.DisableHighSpeed)

  00174	e5943100	 ldr         r3, [r4, #0x100]

; 2859 : 	{
; 2860 :         CLRREG8(&pGen->Power, POWER_HSENABLE);
; 2861 :         SETREG8(&pGen->Power, POWER_SOFTCONN);
; 2862 : 	}
; 2863 :     else
; 2864 : 	{
; 2865 :         SETREG8(&pGen->Power, POWER_SOFTCONN | POWER_HSENABLE);
; 2866 : 	}
; 2867 :         
; 2868 :     CLRREG8(&pGen->Power, POWER_SUSPENDM|POWER_EN_SUSPENDM);
; 2869 : 
; 2870 :     Sleep(10);

  00178	e3a0000a	 mov         r0, #0xA
  0017c	e3530000	 cmp         r3, #0
  00180	e5d53001	 ldrb        r3, [r5, #1]
  00184	120330df	 andne       r3, r3, #0xDF
  00188	15c53001	 strneb      r3, [r5, #1]
  0018c	15d53001	 ldrneb      r3, [r5, #1]
  00190	13833040	 orrne       r3, r3, #0x40
  00194	03833060	 orreq       r3, r3, #0x60
  00198	e5c53001	 strb        r3, [r5, #1]
  0019c	e5d53001	 ldrb        r3, [r5, #1]
  001a0	e20330fc	 and         r3, r3, #0xFC
  001a4	e5c53001	 strb        r3, [r5, #1]
  001a8	eb000000	 bl          Sleep

; 2871 :     
; 2872 :     LeaveCriticalSection(&m_pOTG->regCS);

  001ac	e5943150	 ldr         r3, [r4, #0x150]
  001b0	e2830038	 add         r0, r3, #0x38
  001b4	eb000000	 bl          LeaveCriticalSection

; 2873 : 
; 2874 :     return TRUE;

  001b8	e3a00001	 mov         r0, #1

; 2875 : }

  001bc	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  001c0	e12fff1e	 bx          lr
  001c4		 |$M43473|

			 ENDP  ; |?SoftResetMUSBController@OMAPMHSUSBOTG@@UAAHH@Z|, OMAPMHSUSBOTG::SoftResetMUSBController

	EXPORT	|?ReadULPIReg@OMAPMHSUSBOTG@@QAAEPAUHSMUSB_T@@E@Z| ; OMAPMHSUSBOTG::ReadULPIReg
	EXPORT	|??_C@_1GA@KDAFPHFP@?$AA?$CD?$AA?$CD?$AA?$CD?$AA?$CD?$AA?$CD?$AA?$CD?$AA?$CD?$AA?5?$AAF?$AAA?$AAI?$AAL?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAa?$AAd?$AA?5?$AAU?$AAL?$AAP?$AAI?$AA?5?$AAR?$AAe?$AAg?$AA?0?$AA?5?$AAC@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T43494| DCD	|$LN14@ReadULPIRe|
	DCD	0x40001f01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GA@KDAFPHFP@?$AA?$CD?$AA?$CD?$AA?$CD?$AA?$CD?$AA?$CD?$AA?$CD?$AA?$CD?$AA?5?$AAF?$AAA?$AAI?$AAL?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAa?$AAd?$AA?5?$AAU?$AAL?$AAP?$AAI?$AA?5?$AAR?$AAe?$AAg?$AA?0?$AA?5?$AAC@| DCB "#"
	DCB	0x0, "#", 0x0, "#", 0x0, "#", 0x0, "#", 0x0, "#", 0x0, "#"
	DCB	0x0, " ", 0x0, "F", 0x0, "A", 0x0, "I", 0x0, "L", 0x0, " "
	DCB	0x0, "t", 0x0, "o", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "a"
	DCB	0x0, "d", 0x0, " ", 0x0, "U", 0x0, "L", 0x0, "P", 0x0, "I"
	DCB	0x0, " ", 0x0, "R", 0x0, "e", 0x0, "g", 0x0, ",", 0x0, " "
	DCB	0x0, "C", 0x0, "o", 0x0, "n", 0x0, "t", 0x0, "r", 0x0, "o"
	DCB	0x0, "l", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ReadULPIReg@OMAPMHSUSBOTG@@QAAEPAUHSMUSB_T@@E@Z| PROC ; OMAPMHSUSBOTG::ReadULPIReg

; 3927 : {

  00000		 |$LN14@ReadULPIRe|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43491|
  00004	e1a04001	 mov         r4, r1

; 3928 :     DWORD dwCount = 100;
; 3929 :     UCHAR ucData = 0x00;
; 3930 :     pOTG->pUsbGenRegs->ulpi_regs.ULPIRegAddr = idx;

  00008	e5943020	 ldr         r3, [r4, #0x20]

; 3931 :     pOTG->pUsbGenRegs->ulpi_regs.ULPIRegControl = ULPI_REG_REQ | ULPI_RD_N_WR;

  0000c	e3a01005	 mov         r1, #5
  00010	e3a05064	 mov         r5, #0x64
  00014	e5c32075	 strb        r2, [r3, #0x75]
  00018	e5943020	 ldr         r3, [r4, #0x20]
  0001c	e5c31076	 strb        r1, [r3, #0x76]

; 3932 : 
; 3933 :     while ((pOTG->pUsbGenRegs->ulpi_regs.ULPIRegControl & ULPI_REG_CMPLT) == 0)

  00020	ea000003	 b           |$LN11@ReadULPIRe|
  00024		 |$LL3@ReadULPIRe|

; 3934 :     {
; 3935 :         Sleep(20);

  00024	e3a00014	 mov         r0, #0x14
  00028	eb000000	 bl          Sleep

; 3936 :         dwCount--;

  0002c	e2555001	 subs        r5, r5, #1

; 3937 :         if (dwCount == 0)

  00030	0a000009	 beq         |$LN9@ReadULPIRe|
  00034		 |$LN11@ReadULPIRe|
  00034	e5943020	 ldr         r3, [r4, #0x20]
  00038	e5d33076	 ldrb        r3, [r3, #0x76]
  0003c	e3130002	 tst         r3, #2
  00040	0afffff7	 beq         |$LL3@ReadULPIRe|

; 3942 :         }
; 3943 :     }
; 3944 :     ucData = pOTG->pUsbGenRegs->ulpi_regs.ULPIRegData;

  00044	e5943020	 ldr         r3, [r4, #0x20]

; 3945 : 
; 3946 :     pOTG->pUsbGenRegs->ulpi_regs.ULPIRegControl = 0;

  00048	e3a02000	 mov         r2, #0
  0004c	e5d30074	 ldrb        r0, [r3, #0x74]
  00050	e5c32076	 strb        r2, [r3, #0x76]

; 3947 : 
; 3948 :     return ucData;
; 3949 : }

  00054	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$LN9@ReadULPIRe|

; 3938 :         {
; 3939 :             RETAILMSG(1, (TEXT("####### FAIL to read ULPI Reg, Control = 0x%x\r\n"), 
; 3940 :                 pOTG->pUsbGenRegs->ulpi_regs.ULPIRegControl));

  0005c	e5943020	 ldr         r3, [r4, #0x20]
  00060	e59f0010	 ldr         r0, [pc, #0x10]
  00064	e5d31076	 ldrb        r1, [r3, #0x76]
  00068	eb000000	 bl          NKDbgPrintfW

; 3941 :             return 0x00;

  0006c	e3a00000	 mov         r0, #0

; 3947 : 
; 3948 :     return ucData;
; 3949 : }

  00070	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00074	e12fff1e	 bx          lr
  00078		 |$LN15@ReadULPIRe|
  00078		 |$LN16@ReadULPIRe|
  00078	00000000	 DCD         |??_C@_1GA@KDAFPHFP@?$AA?$CD?$AA?$CD?$AA?$CD?$AA?$CD?$AA?$CD?$AA?$CD?$AA?$CD?$AA?5?$AAF?$AAA?$AAI?$AAL?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAa?$AAd?$AA?5?$AAU?$AAL?$AAP?$AAI?$AA?5?$AAR?$AAe?$AAg?$AA?0?$AA?5?$AAC@|
  0007c		 |$M43492|

			 ENDP  ; |?ReadULPIReg@OMAPMHSUSBOTG@@QAAEPAUHSMUSB_T@@E@Z|, OMAPMHSUSBOTG::ReadULPIReg

	EXPORT	|OTGAttach|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbotg\otg.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T43514| DCD	|$LN8@OTGAttach|
	DCD	0x40001001
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbotg\otg.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OTGAttach| PROC

; 3975 : {

  00000		 |$LN8@OTGAttach|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M43511|
  00004	e1a04000	 mov         r4, r0

; 3976 :     BOOL bRet = FALSE;
; 3977 :     PHSMUSB_T pOTG = NULL;
; 3978 :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("OTGAttach mode=%d\r\n"), mode));
; 3979 :     
; 3980 :     // Set the corresponding MUSB_FUNCS.
; 3981 :     if ((mode >= DEVICE_MODE) && ( mode <= HOST_MODE))

  00008	e2413001	 sub         r3, r1, #1
  0000c	e3530001	 cmp         r3, #1

; 3982 :     {
; 3983 :         pOTG = gpHsUsbOtg->GetHsMusb();

  00010	959f3024	 ldrls       r3, [pc, #0x24]
  00014	e3a0e000	 mov         lr, #0
  00018	e3a00000	 mov         r0, #0

; 3984 :         pOTG->pFuncs[mode-1] = pFuncs; 
; 3985 :         bRet = TRUE;       

  0001c	95933000	 ldrls       r3, [r3]
  00020	93a00001	 movls       r0, #1
  00024	9593e150	 ldrls       lr, [r3, #0x150]
  00028	908e3101	 addls       r3, lr, r1, lsl #2
  0002c	95834004	 strls       r4, [r3, #4]

; 3986 :     }
; 3987 : 
; 3988 :     // Pass the gmHsUsb context back to device or host driver       
; 3989 :     *lppvContext = (LPVOID)pOTG;

  00030	e582e000	 str         lr, [r2]

; 3990 :     
; 3991 :     return bRet;
; 3992 : }

  00034	e8bd4010	 ldmia       sp!, {r4, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$LN9@OTGAttach|
  0003c		 |$LN10@OTGAttach|
  0003c	00000000	 DCD         |?gpHsUsbOtg@@3PAVOMAPMHSUSBOTG@@A|
  00040		 |$M43512|

			 ENDP  ; |OTGAttach|

	EXPORT	|OTGUSBClock|

  00000			 AREA	 |.pdata|, PDATA
|$T43527| DCD	|$LN9@OTGUSBCloc|
	DCD	0x40001801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OTGUSBClock| PROC

; 4007 : {

  00000		 |$LN9@OTGUSBCloc|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43524|
  00004	e1a02000	 mov         r2, r0

; 4008 :     BOOL bReturn;
; 4009 : 
; 4010 :     DEBUGMSG(1, (TEXT("OTGUSBClock(%d) called\r\n"), fStart));
; 4011 :     if (gpHsUsbOtg)

  00008	e59f304c	 ldr         r3, [pc, #0x4C]
  0000c	e5930000	 ldr         r0, [r3]
  00010	e3500000	 cmp         r0, #0
  00014	0a00000d	 beq         |$LN4@OTGUSBCloc|

; 4012 :     {
; 4013 :         if (fStart)
; 4014 :             bReturn = gpHsUsbOtg->StartUSBClock(TRUE);

  00018	e5903000	 ldr         r3, [r0]
  0001c	e3520000	 cmp         r2, #0
  00020	0a000005	 beq         |$LN3@OTGUSBCloc|
  00024	e59330e4	 ldr         r3, [r3, #0xE4]
  00028	e3a01001	 mov         r1, #1
  0002c	e1a0e00f	 mov         lr, pc
  00030	e12fff13	 bx          r3

; 4022 :     }
; 4023 :     return bReturn;
; 4024 : }

  00034	e49de004	 ldr         lr, [sp], #4
  00038	e12fff1e	 bx          lr
  0003c		 |$LN3@OTGUSBCloc|

; 4015 :         else
; 4016 :             bReturn = gpHsUsbOtg->StopUSBClock();

  0003c	e59330e8	 ldr         r3, [r3, #0xE8]
  00040	e1a0e00f	 mov         lr, pc
  00044	e12fff13	 bx          r3

; 4022 :     }
; 4023 :     return bReturn;
; 4024 : }

  00048	e49de004	 ldr         lr, [sp], #4
  0004c	e12fff1e	 bx          lr
  00050		 |$LN4@OTGUSBCloc|

; 4017 :     }
; 4018 :     else
; 4019 :     {
; 4020 :         DEBUGMSG(1, (TEXT("OTGUSBClock failed to set\r\n")));
; 4021 :         bReturn = FALSE;

  00050	e3a00000	 mov         r0, #0

; 4022 :     }
; 4023 :     return bReturn;
; 4024 : }

  00054	e49de004	 ldr         lr, [sp], #4
  00058	e12fff1e	 bx          lr
  0005c		 |$LN10@OTGUSBCloc|
  0005c		 |$LN11@OTGUSBCloc|
  0005c	00000000	 DCD         |?gpHsUsbOtg@@3PAVOMAPMHSUSBOTG@@A|
  00060		 |$M43525|

			 ENDP  ; |OTGUSBClock|

	EXPORT	|??0CMiniThread@@QAA@KH@Z|		; CMiniThread::CMiniThread
	EXPORT	|??_7CMiniThread@@6B@| [ DATA ]		; CMiniThread::`vftable'
	IMPORT	|CreateThread|
	IMPORT	|_purecall|
; File c:\wince600\public\common\oak\inc\cmthread.h

  00000			 AREA	 |.pdata|, PDATA
|$T43543| DCD	|$LN7@CMiniThrea|
	DCD	0x40001b02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7CMiniThread@@6B@| DCD |_purecall|			; CMiniThread::`vftable'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CMiniThread@@QAA@KH@Z| PROC	; CMiniThread::CMiniThread

; 29   :     CMiniThread( DWORD dwStackSize = 0, BOOL bSuspended = FALSE )

  00000		 |$LN7@CMiniThrea|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M43540|
  00008	e1b06002	 movs        r6, r2
  0000c	e1a05000	 mov         r5, r0
  00010	e59f3050	 ldr         r3, [pc, #0x50]

; 30   :     {
; 31   :         m_bTerminated = FALSE;

  00014	e3a02000	 mov         r2, #0

; 32   :         m_dwExitCode = ( DWORD ) - 1;

  00018	e5852004	 str         r2, [r5, #4]

; 33   :         m_hThreadHandle = ::CreateThread( NULL,
; 34   :                                           dwStackSize,
; 35   :                                           CMiniThread::ThreadProc,
; 36   :                                           ( LPVOID )this,
; 37   :                                           bSuspended ? CREATE_SUSPENDED : 0,
; 38   :                                           &m_dwThreadId );

  0001c	e59f2040	 ldr         r2, [pc, #0x40]
  00020	e3e00000	 mvn         r0, #0
  00024	13a04004	 movne       r4, #4
  00028	e5853000	 str         r3, [r5]
  0002c	e5850014	 str         r0, [r5, #0x14]
  00030	03a04000	 moveq       r4, #0
  00034	e285e00c	 add         lr, r5, #0xC
  00038	e1a03005	 mov         r3, r5
  0003c	e3a00000	 mov         r0, #0
  00040	e58de004	 str         lr, [sp, #4]
  00044	e58d4000	 str         r4, [sp]
  00048	eb000000	 bl          CreateThread
  0004c	e5850008	 str         r0, [r5, #8]

; 39   :         m_bSuspendFlag = bSuspended;
; 40   :     };

  00050	e1a00005	 mov         r0, r5
  00054	e5856010	 str         r6, [r5, #0x10]
  00058	e28dd008	 add         sp, sp, #8
  0005c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$LN8@CMiniThrea|
  00064		 |$LN9@CMiniThrea|
  00064	00000000	 DCD         |?ThreadProc@CMiniThread@@CAKPAX@Z|
  00068		 |$LN10@CMiniThrea|
  00068	00000000	 DCD         |??_7CMiniThread@@6B@|
  0006c		 |$M43541|

			 ENDP  ; |??0CMiniThread@@QAA@KH@Z|, CMiniThread::CMiniThread

	EXPORT	|??1CMiniThread@@QAA@XZ|		; CMiniThread::~CMiniThread

  00000			 AREA	 |.pdata|, PDATA
|$T43554| DCD	|$LN5@CMiniThrea@2|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CMiniThread@@QAA@XZ| PROC		; CMiniThread::~CMiniThread

; 44   :     {

  00000		 |$LN5@CMiniThrea@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43551|
  00004	e1a02000	 mov         r2, r0
  00008	e59f300c	 ldr         r3, [pc, #0xC]

; 45   :         ForceTerminated();

  0000c	e5823000	 str         r3, [r2]
  00010	eb000000	 bl          |?ForceTerminated@CMiniThread@@QAAHXZ|

; 46   :     }

  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$LN6@CMiniThrea@2|
  0001c		 |$LN7@CMiniThrea@2|
  0001c	00000000	 DCD         |??_7CMiniThread@@6B@|
  00020		 |$M43552|

			 ENDP  ; |??1CMiniThread@@QAA@XZ|, CMiniThread::~CMiniThread

	EXPORT	|?ThreadTerminated@CMiniThread@@QAAHK@Z| ; CMiniThread::ThreadTerminated

  00000			 AREA	 |.pdata|, PDATA
|$T43567| DCD	|$LN5@ThreadTerm|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ThreadTerminated@CMiniThread@@QAAHK@Z| PROC ; CMiniThread::ThreadTerminated

; 86   :     {

  00000		 |$LN5@ThreadTerm|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43564|

; 87   :         m_bTerminated = TRUE;

  00004	e3a03001	 mov         r3, #1
  00008	e5803004	 str         r3, [r0, #4]

; 88   :         return WaitThreadComplete( dwMilliSeconds  );

  0000c	eb000000	 bl          |?WaitThreadComplete@CMiniThread@@QAAHK@Z|

; 89   :     }

  00010	e49de004	 ldr         lr, [sp], #4
  00014	e12fff1e	 bx          lr
  00018		 |$M43565|

			 ENDP  ; |?ThreadTerminated@CMiniThread@@QAAHK@Z|, CMiniThread::ThreadTerminated

	EXPORT	|??1OMAPMHSUsbClientDeviceFolder@@UAA@XZ| ; OMAPMHSUsbClientDeviceFolder::~OMAPMHSUsbClientDeviceFolder
	IMPORT	|??1DeviceFolder@@UAA@XZ|		; DeviceFolder::~DeviceFolder
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T43594| DCD	|$LN17@OMAPMHSUsb@2|
	DCD	0x40001001
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbotg\otg.hpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1OMAPMHSUsbClientDeviceFolder@@UAA@XZ| PROC ; OMAPMHSUsbClientDeviceFolder::~OMAPMHSUsbClientDeviceFolder

; 201  :     {

  00000		 |$LN17@OMAPMHSUsb@2|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43591|
  00004	e1a05000	 mov         r5, r0
  00008	e59f302c	 ldr         r3, [pc, #0x2C]

; 202  :         SetPowerState(D4);

  0000c	e1a04005	 mov         r4, r5
  00010	e484300c	 str         r3, [r4], #0xC
  00014	e1a00004	 mov         r0, r4
  00018	eb000000	 bl          EnterCriticalSection
  0001c	e3a03004	 mov         r3, #4
  00020	e1a00004	 mov         r0, r4
  00024	e5853020	 str         r3, [r5, #0x20]
  00028	eb000000	 bl          LeaveCriticalSection

; 203  :     };

  0002c	e1a00005	 mov         r0, r5
  00030	eb000000	 bl          |??1DeviceFolder@@UAA@XZ|
  00034	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$LN18@OMAPMHSUsb@2|
  0003c		 |$LN19@OMAPMHSUsb@2|
  0003c	00000000	 DCD         |??_7OMAPMHSUsbClientDeviceFolder@@6B@|
  00040		 |$M43592|

			 ENDP  ; |??1OMAPMHSUsbClientDeviceFolder@@UAA@XZ|, OMAPMHSUsbClientDeviceFolder::~OMAPMHSUsbClientDeviceFolder

	IMPORT	|??3@YAXPAX@Z|				; operator delete

  00000			 AREA	 |.pdata|, PDATA
|$T43607| DCD	|$LN6@scalar|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GOMAPMHSUsbClientDeviceFolder@@UAAPAXI@Z| PROC ; OMAPMHSUsbClientDeviceFolder::`scalar deleting destructor'
  00000		 |$LN6@scalar|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43604|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          |??1OMAPMHSUsbClientDeviceFolder@@UAA@XZ|
  00010	e3140001	 tst         r4, #1
  00014	11a00005	 movne       r0, r5
  00018	1b000000	 blne        |??3@YAXPAX@Z|
  0001c	e1a00005	 mov         r0, r5
  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M43605|

			 ENDP  ; |??_GOMAPMHSUsbClientDeviceFolder@@UAAPAXI@Z|, OMAPMHSUsbClientDeviceFolder::`scalar deleting destructor'

	EXPORT	|??0OMAPMHSUSBIdGnd@@QAA@PAVOMAPMHSUSBOTG@@@Z| ; OMAPMHSUSBIdGnd::OMAPMHSUSBIdGnd
	EXPORT	|??_7OMAPMHSUSBIdGnd@@6B@| [ DATA ]	; OMAPMHSUSBIdGnd::`vftable'
	IMPORT	|CreateEventW|
	IMPORT	|??_EOMAPMHSUSBIdGnd@@UAAPAXI@Z|, WEAK |??_GOMAPMHSUSBIdGnd@@UAAPAXI@Z| ; OMAPMHSUSBIdGnd::`vector deleting destructor', OMAPMHSUSBIdGnd::`scalar deleting destructor'
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T43622| DCD	|$LN8@OMAPMHSUSB|
	DCD	0x40001601

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7OMAPMHSUSBIdGnd@@6B@| DCD |?ThreadRun@OMAPMHSUSBIdGnd@@EAAKXZ| ; OMAPMHSUSBIdGnd::`vftable'
	DCD	|??_EOMAPMHSUSBIdGnd@@UAAPAXI@Z|
	DCD	|?Init@OMAPMHSUSBIdGnd@@UAAHXZ|
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbotg\otg.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0OMAPMHSUSBIdGnd@@QAA@PAVOMAPMHSUSBOTG@@@Z| PROC ; OMAPMHSUSBIdGnd::OMAPMHSUSBIdGnd

; 202  : {

  00000		 |$LN8@OMAPMHSUSB|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43619|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	e2850018	 add         r0, r5, #0x18
  00010	eb000000	 bl          InitializeCriticalSection
  00014	e3a02001	 mov         r2, #1
  00018	e3a01000	 mov         r1, #0
  0001c	e1a00005	 mov         r0, r5
  00020	eb000000	 bl          |??0CMiniThread@@QAA@KH@Z|
  00024	e59fe028	 ldr         lr, [pc, #0x28]

; 203  :     m_hIdGndIntrEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  00028	e3a03000	 mov         r3, #0
  0002c	e3a02000	 mov         r2, #0
  00030	e3a01000	 mov         r1, #0
  00034	e3a00000	 mov         r0, #0
  00038	e585e000	 str         lr, [r5]
  0003c	e585402c	 str         r4, [r5, #0x2C]
  00040	eb000000	 bl          CreateEventW
  00044	e5850030	 str         r0, [r5, #0x30]

; 204  :     if (m_hIdGndIntrEvent == NULL)
; 205  :     {
; 206  :         DEBUGMSG(ZONE_OTG_ERROR, (TEXT("OMAPMHSUSBIdGnd:Failed to create event\r\n")));
; 207  :         return;
; 208  :     }
; 209  : 
; 210  :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("-OMAPMHSUSBIdGnd\r\n")));
; 211  : 
; 212  : }

  00048	e1a00005	 mov         r0, r5
  0004c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$LN9@OMAPMHSUSB|
  00054		 |$LN10@OMAPMHSUSB|
  00054	00000000	 DCD         |??_7OMAPMHSUSBIdGnd@@6B@|
  00058		 |$M43620|

			 ENDP  ; |??0OMAPMHSUSBIdGnd@@QAA@PAVOMAPMHSUSBOTG@@@Z|, OMAPMHSUSBIdGnd::OMAPMHSUSBIdGnd

	EXPORT	|??1OMAPMHSUSBIdGnd@@UAA@XZ|		; OMAPMHSUSBIdGnd::~OMAPMHSUSBIdGnd
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T43645| DCD	|$LN13@OMAPMHSUSB@2|
	DCD	0x40001301
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbotg\otg.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1OMAPMHSUSBIdGnd@@UAA@XZ| PROC	; OMAPMHSUSBIdGnd::~OMAPMHSUSBIdGnd

; 215  : {    

  00000		 |$LN13@OMAPMHSUSB@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M43642|
  00004	e1a04000	 mov         r4, r0
  00008	e59f3038	 ldr         r3, [pc, #0x38]

; 216  :     // Terminationg thread.
; 217  :     m_fTerminated = TRUE;

  0000c	e3a02001	 mov         r2, #1

; 218  :     ThreadTerminated(1000);

  00010	e3a01ffa	 mov         r1, #0xFA, 30
  00014	e5843000	 str         r3, [r4]
  00018	e5842034	 str         r2, [r4, #0x34]
  0001c	e5842004	 str         r2, [r4, #4]
  00020	eb000000	 bl          |?WaitThreadComplete@CMiniThread@@QAAHK@Z|

; 219  : }

  00024	e59f3018	 ldr         r3, [pc, #0x18]
  00028	e1a00004	 mov         r0, r4
  0002c	e5843000	 str         r3, [r4]
  00030	eb000000	 bl          |?ForceTerminated@CMiniThread@@QAAHXZ|
  00034	e2840018	 add         r0, r4, #0x18
  00038	eb000000	 bl          DeleteCriticalSection
  0003c	e8bd4010	 ldmia       sp!, {r4, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$LN14@OMAPMHSUSB@2|
  00044		 |$LN15@OMAPMHSUSB@2|
  00044	00000000	 DCD         |??_7CMiniThread@@6B@|
  00048		 |$LN16@OMAPMHSUSB@2|
  00048	00000000	 DCD         |??_7OMAPMHSUSBIdGnd@@6B@|
  0004c		 |$M43643|

			 ENDP  ; |??1OMAPMHSUSBIdGnd@@UAA@XZ|, OMAPMHSUSBIdGnd::~OMAPMHSUSBIdGnd

	EXPORT	|??0OMAPMHSUSBDMA@@QAA@PAVOMAPMHSUSBOTG@@K@Z| ; OMAPMHSUSBDMA::OMAPMHSUSBDMA
	EXPORT	|??_7OMAPMHSUSBDMA@@6B@| [ DATA ]	; OMAPMHSUSBDMA::`vftable'
	IMPORT	|InterruptInitialize|
	IMPORT	|KernelIoControl|
	IMPORT	|??_EOMAPMHSUSBDMA@@UAAPAXI@Z|, WEAK |??_GOMAPMHSUSBDMA@@UAAPAXI@Z| ; OMAPMHSUSBDMA::`vector deleting destructor', OMAPMHSUSBDMA::`scalar deleting destructor'
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T43663| DCD	|$LN10@OMAPMHSUSB@3|
	DCD	0x40002f04

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7OMAPMHSUSBDMA@@6B@| DCD |?ThreadRun@OMAPMHSUSBDMA@@EAAKXZ| ; OMAPMHSUSBDMA::`vftable'
	DCD	|??_EOMAPMHSUSBDMA@@UAAPAXI@Z|
	DCD	|?Init@OMAPMHSUSBDMA@@UAAHXZ|
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbotg\otg.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0OMAPMHSUSBDMA@@QAA@PAVOMAPMHSUSBOTG@@K@Z| PROC ; OMAPMHSUSBDMA::OMAPMHSUSBDMA

; 259  : {

  00000		 |$LN10@OMAPMHSUSB@3|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5070	 stmdb       sp!, {r4 - r6, r12, lr}
  0000c	e24dd00c	 sub         sp, sp, #0xC
  00010		 |$M43660|
  00010	e1a04001	 mov         r4, r1
  00014	e1a05000	 mov         r5, r0
  00018	e2850018	 add         r0, r5, #0x18
  0001c	eb000000	 bl          InitializeCriticalSection
  00020	e3a02001	 mov         r2, #1
  00024	e3a01000	 mov         r1, #0
  00028	e1a00005	 mov         r0, r5
  0002c	eb000000	 bl          |??0CMiniThread@@QAA@KH@Z|
  00030	e59f3080	 ldr         r3, [pc, #0x80]

; 260  :     DWORD dwDMASysIntr;
; 261  : 
; 262  :     if (!KernelIoControl(IOCTL_HAL_REQUEST_SYSINTR,
; 263  :            &dwDMAIrq,
; 264  :            sizeof(dwDMAIrq),
; 265  :            &dwDMASysIntr,
; 266  :            sizeof(dwDMASysIntr),
; 267  :            NULL))

  00034	e59f0078	 ldr         r0, [pc, #0x78]
  00038	e3a0e000	 mov         lr, #0
  0003c	e5853000	 str         r3, [r5]
  00040	e3a06004	 mov         r6, #4
  00044	e28d3008	 add         r3, sp, #8
  00048	e3a02004	 mov         r2, #4
  0004c	e28d1028	 add         r1, sp, #0x28
  00050	e5854030	 str         r4, [r5, #0x30]
  00054	e58de004	 str         lr, [sp, #4]
  00058	e58d6000	 str         r6, [sp]
  0005c	eb000000	 bl          KernelIoControl
  00060	e3500000	 cmp         r0, #0
  00064	0a00000e	 beq         |$LN1@OMAPMHSUSB@3|

; 268  :     {
; 269  :         DEBUGMSG(ZONE_OTG_ERROR, (L"ERROR: OTG_Init: "  L"Failed map OTG controller interrupt\r\n" ));
; 270  :         return;
; 271  :     }
; 272  : 
; 273  :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("DMAIRQ=0x%x, SYSINTR=0x%x\r\n"), dwDMAIrq, dwDMASysIntr));
; 274  :     m_dwDMASysIntr = dwDMASysIntr;

  00068	e59d2008	 ldr         r2, [sp, #8]

; 275  :     m_dwDMAIrq = dwDMAIrq;

  0006c	e59d1028	 ldr         r1, [sp, #0x28]

; 276  : 
; 277  :     m_hDMAIntrEvent = CreateEvent(0, FALSE, FALSE, NULL);

  00070	e3a03000	 mov         r3, #0
  00074	e5852038	 str         r2, [r5, #0x38]
  00078	e585103c	 str         r1, [r5, #0x3C]
  0007c	e3a02000	 mov         r2, #0
  00080	e3a01000	 mov         r1, #0
  00084	e3a00000	 mov         r0, #0
  00088	eb000000	 bl          CreateEventW
  0008c	e1b01000	 movs        r1, r0

; 278  :     if (m_hDMAIntrEvent == NULL)
; 279  :     {
; 280  :         DEBUGMSG(ZONE_OTG_ERROR, (TEXT("Failed to create DMA Interrupt Event handle\r\n")));
; 281  :         // We need to do clean up here
; 282  :         return;
; 283  :     }
; 284  : 
; 285  : 
; 286  :     if (!InterruptInitialize(m_dwDMASysIntr, m_hDMAIntrEvent, NULL, 0))

  00090	15950038	 ldrne       r0, [r5, #0x38]
  00094	13a03000	 movne       r3, #0
  00098	13a02000	 movne       r2, #0
  0009c	e5851034	 str         r1, [r5, #0x34]
  000a0	1b000000	 blne        InterruptInitialize
  000a4		 |$LN1@OMAPMHSUSB@3|

; 287  :     {
; 288  :         DEBUGMSG(ZONE_OTG_ERROR, (TEXT("Failed to initialize the DMA interrupt routine\r\n")));
; 289  :         // We need to do clean up here
; 290  :         return;
; 291  :     }    
; 292  : 
; 293  :     
; 294  : }

  000a4	e1a00005	 mov         r0, r5
  000a8	e28dd00c	 add         sp, sp, #0xC
  000ac	e89d6070	 ldmia       sp, {r4 - r6, sp, lr}
  000b0	e12fff1e	 bx          lr
  000b4		 |$LN11@OMAPMHSUSB@3|
  000b4		 |$LN12@OMAPMHSUSB@3|
  000b4	01010098	 DCD         0x1010098
  000b8		 |$LN13@OMAPMHSUSB@3|
  000b8	00000000	 DCD         |??_7OMAPMHSUSBDMA@@6B@|
  000bc		 |$M43661|

			 ENDP  ; |??0OMAPMHSUSBDMA@@QAA@PAVOMAPMHSUSBOTG@@K@Z|, OMAPMHSUSBDMA::OMAPMHSUSBDMA

	EXPORT	|??1OMAPMHSUSBDMA@@UAA@XZ|		; OMAPMHSUSBDMA::~OMAPMHSUSBDMA
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T43687| DCD	|$LN13@OMAPMHSUSB@4|
	DCD	0x40001201
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbotg\otg.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1OMAPMHSUSBDMA@@UAA@XZ| PROC	; OMAPMHSUSBDMA::~OMAPMHSUSBDMA

; 297  : {    

  00000		 |$LN13@OMAPMHSUSB@4|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M43684|
  00004	e1a04000	 mov         r4, r0
  00008	e59f3034	 ldr         r3, [pc, #0x34]

; 298  :     // Terminationg thread.
; 299  :     ThreadTerminated(1000);

  0000c	e3a02001	 mov         r2, #1
  00010	e3a01ffa	 mov         r1, #0xFA, 30
  00014	e5843000	 str         r3, [r4]
  00018	e5842004	 str         r2, [r4, #4]
  0001c	eb000000	 bl          |?WaitThreadComplete@CMiniThread@@QAAHK@Z|

; 300  : }

  00020	e59f3018	 ldr         r3, [pc, #0x18]
  00024	e1a00004	 mov         r0, r4
  00028	e5843000	 str         r3, [r4]
  0002c	eb000000	 bl          |?ForceTerminated@CMiniThread@@QAAHXZ|
  00030	e2840018	 add         r0, r4, #0x18
  00034	eb000000	 bl          DeleteCriticalSection
  00038	e8bd4010	 ldmia       sp!, {r4, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$LN14@OMAPMHSUSB@4|
  00040		 |$LN15@OMAPMHSUSB@4|
  00040	00000000	 DCD         |??_7CMiniThread@@6B@|
  00044		 |$LN16@OMAPMHSUSB@4|
  00044	00000000	 DCD         |??_7OMAPMHSUSBDMA@@6B@|
  00048		 |$M43685|

			 ENDP  ; |??1OMAPMHSUSBDMA@@UAA@XZ|, OMAPMHSUSBDMA::~OMAPMHSUSBDMA

	EXPORT	|??0OMAPMHSUSBOTG@@QAA@PBG@Z|		; OMAPMHSUSBOTG::OMAPMHSUSBOTG
	EXPORT	|??_7OMAPMHSUSBOTG@@6BUSBOTG@@@| [ DATA ] ; OMAPMHSUSBOTG::`vftable'
	EXPORT	|??_7OMAPMHSUSBOTG@@6BCMiniThread@@@| [ DATA ] ; OMAPMHSUSBOTG::`vftable'
	EXPORT	|?ThreadRun@OMAPMHSUSBOTG@@EAAKXZ|	; OMAPMHSUSBOTG::ThreadRun
	EXPORT	|?Init@OMAPMHSUSBOTG@@UAAHXZ|		; OMAPMHSUSBOTG::Init
	EXPORT	|?Open@USBOTG@@UAAHKK@Z|		; USBOTG::Open
	EXPORT	|?Close@DefaultBusDriver@@UAAHXZ|	; DefaultBusDriver::Close
	EXPORT	|?IsChildRemoved@DefaultBusDriver@@UAAHPBG@Z| ; DefaultBusDriver::IsChildRemoved
	EXPORT	|?DischargVBus@OMAPMHSUSBOTG@@UAAHXZ|	; OMAPMHSUSBOTG::DischargVBus
	EXPORT	|?GetOtgAConnectEvent@USBOTG@@UAAPAXXZ|	; USBOTG::GetOtgAConnectEvent
	EXPORT	|?SetChildDevicePowerState@USBOTG@@UAAHPAU_CE_BUS_POWER_STATE@@@Z| ; USBOTG::SetChildDevicePowerState
	EXPORT	|?GetChildDevicePowerState@USBOTG@@UAAHPAU_CE_BUS_POWER_STATE@@@Z| ; USBOTG::GetChildDevicePowerState
	EXPORT	|?UpdatePowerState@USBOTG@@UAAHXZ|	; USBOTG::UpdatePowerState
	EXPORT	|?GetPowerCapabilities@USBOTG@@UAA?AU_POWER_CAPABILITIES@@XZ| ; USBOTG::GetPowerCapabilities
	EXPORT	|?OTG_ConfigISR_stage2@OMAPMHSUSBOTG@@UAAKXZ| ; OMAPMHSUSBOTG::OTG_ConfigISR_stage2
	EXPORT	|?SoftResetULPILink@OMAPMHSUSBOTG@@UAAHXZ| ; OMAPMHSUSBOTG::SoftResetULPILink
	IMPORT	|StringCchCopyW|
	IMPORT	|CreateBusAccessHandle|
	IMPORT	|GetDeviceRegistryParams|
	IMPORT	|??0USBOTG@@QAA@PBG@Z|			; USBOTG::USBOTG
	IMPORT	|wcslen|
	IMPORT	|??_EOMAPMHSUSBOTG@@UAAPAXI@Z|, WEAK |??_GOMAPMHSUSBOTG@@UAAPAXI@Z| ; OMAPMHSUSBOTG::`vector deleting destructor', OMAPMHSUSBOTG::`scalar deleting destructor'
	IMPORT	|?TranslateChildBusAddr@DefaultBusDriver@@UAAHPAU_CE_BUS_TRANSLATE_BUS_ADDR@@@Z| ; DefaultBusDriver::TranslateChildBusAddr
	IMPORT	|?TranslateChildSystemAddr@DefaultBusDriver@@UAAHPAU_CE_BUS_TRANSLATE_SYSTEM_ADDR@@@Z| ; DefaultBusDriver::TranslateChildSystemAddr
	IMPORT	|?SetChildDevicePowerState@DefaultBusDriver@@UAAHPAU_CE_BUS_POWER_STATE@@PAPAVDeviceFolder@@@Z| ; DefaultBusDriver::SetChildDevicePowerState
	IMPORT	|?GetChildDevicePowerState@DefaultBusDriver@@UAAHPAU_CE_BUS_POWER_STATE@@PAPAVDeviceFolder@@@Z| ; DefaultBusDriver::GetChildDevicePowerState
	IMPORT	|?SetChildDeviceConfigurationData@DefaultBusDriver@@UAAHPAU_CE_BUS_DEVICE_CONFIGURATION_DATA@@PAPAVDeviceFolder@@@Z| ; DefaultBusDriver::SetChildDeviceConfigurationData
	IMPORT	|?GetChildDeviceConfigurationData@DefaultBusDriver@@UAAHPAU_CE_BUS_DEVICE_CONFIGURATION_DATA@@PAPAVDeviceFolder@@@Z| ; DefaultBusDriver::GetChildDeviceConfigurationData
	IMPORT	|?ActivateChild@DefaultBusDriver@@UAAHPBG@Z| ; DefaultBusDriver::ActivateChild
	IMPORT	|?DeactivateChild@DefaultBusDriver@@UAAHPBG@Z| ; DefaultBusDriver::DeactivateChild
	IMPORT	|?GetChildByName@DefaultBusDriver@@UAAPAVDeviceFolder@@PBGPAPAV2@@Z| ; DefaultBusDriver::GetChildByName
	IMPORT	|?InsertChild@DefaultBusDriver@@UAAHPAVDeviceFolder@@@Z| ; DefaultBusDriver::InsertChild
	IMPORT	|?RemoveChildByName@DefaultBusDriver@@UAAHPBG@Z| ; DefaultBusDriver::RemoveChildByName
	IMPORT	|?RemoveChildByFolder@DefaultBusDriver@@UAAHPAVDeviceFolder@@@Z| ; DefaultBusDriver::RemoveChildByFolder
	IMPORT	|?GetBusNamePrefix@USBOTG@@UAAKPAGK@Z|	; USBOTG::GetBusNamePrefix
	IMPORT	|?FastIOControl@DefaultBusDriver@@UAAHKPAEK0KPAKPAPAVDeviceFolder@@@Z| ; DefaultBusDriver::FastIOControl
	IMPORT	|?ActivateAllChildDrivers@USBOTG@@UAAHXZ| ; USBOTG::ActivateAllChildDrivers
	IMPORT	|?TimeOut@USBOTG@@UAAHW4USBOTG_WATCHITEM@@@Z| ; USBOTG::TimeOut
	IMPORT	|?GetOTGEnableBit@USBOTG@@UAAEPBG@Z|	; USBOTG::GetOTGEnableBit
	IMPORT	|?OtgRequestBus@USBOTG@@UAAHH@Z|	; USBOTG::OtgRequestBus
	IMPORT	|?OtgDropBus@USBOTG@@UAAHH@Z|		; USBOTG::OtgDropBus
	IMPORT	|?OtgSuspendBus@USBOTG@@UAAHPBGH@Z|	; USBOTG::OtgSuspendBus
	IMPORT	|?OtgEnableHNP@USBOTG@@UAAHPBGH@Z|	; USBOTG::OtgEnableHNP
	IMPORT	|?OTGNotifyDetach@USBOTG@@UAAHPBG@Z|	; USBOTG::OTGNotifyDetach
	IMPORT	|?EnterState@USBOTG@@MAAHW4USBOTG_STATES@@@Z| ; USBOTG::EnterState
	IMPORT	|?StateChange@USBOTG@@MAA?AW4USBOTG_STATES@@W42@@Z| ; USBOTG::StateChange

  00000			 AREA	 |.pdata|, PDATA
|$T43706| DCD	|$LN11@OMAPMHSUSB@5|
	DCD	0x40003801

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7OMAPMHSUSBOTG@@6BUSBOTG@@@| DCD |?Init@OMAPMHSUSBOTG@@UAAHXZ| ; OMAPMHSUSBOTG::`vftable'
	DCD	|?PostInit@OMAPMHSUSBOTG@@UAAHXZ|
	DCD	|??_EOMAPMHSUSBOTG@@UAAPAXI@Z|
	DCD	|?TranslateChildBusAddr@DefaultBusDriver@@UAAHPAU_CE_BUS_TRANSLATE_BUS_ADDR@@@Z|
	DCD	|?TranslateChildSystemAddr@DefaultBusDriver@@UAAHPAU_CE_BUS_TRANSLATE_SYSTEM_ADDR@@@Z|
	DCD	|?SetChildDevicePowerState@DefaultBusDriver@@UAAHPAU_CE_BUS_POWER_STATE@@PAPAVDeviceFolder@@@Z|
	DCD	|?GetChildDevicePowerState@DefaultBusDriver@@UAAHPAU_CE_BUS_POWER_STATE@@PAPAVDeviceFolder@@@Z|
	DCD	|?SetChildDeviceConfigurationData@DefaultBusDriver@@UAAHPAU_CE_BUS_DEVICE_CONFIGURATION_DATA@@PAPAVDeviceFolder@@@Z|
	DCD	|?GetChildDeviceConfigurationData@DefaultBusDriver@@UAAHPAU_CE_BUS_DEVICE_CONFIGURATION_DATA@@PAPAVDeviceFolder@@@Z|
	DCD	|?ActivateChild@DefaultBusDriver@@UAAHPBG@Z|
	DCD	|?DeactivateChild@DefaultBusDriver@@UAAHPBG@Z|
	DCD	|?PowerUp@OMAPMHSUSBOTG@@UAAHXZ|
	DCD	|?PowerDown@OMAPMHSUSBOTG@@UAAHXZ|
	DCD	|?Open@USBOTG@@UAAHKK@Z|
	DCD	|?Close@DefaultBusDriver@@UAAHXZ|
	DCD	|?IOControl@OMAPMHSUSBOTG@@UAAHKPAEK0KPAK@Z|
	DCD	|?GetChildByName@DefaultBusDriver@@UAAPAVDeviceFolder@@PBGPAPAV2@@Z|
	DCD	|?InsertChild@DefaultBusDriver@@UAAHPAVDeviceFolder@@@Z|
	DCD	|?RemoveChildByName@DefaultBusDriver@@UAAHPBG@Z|
	DCD	|?RemoveChildByFolder@DefaultBusDriver@@UAAHPAVDeviceFolder@@@Z|
	DCD	|?IsChildRemoved@DefaultBusDriver@@UAAHPBG@Z|
	DCD	|?GetBusNamePrefix@USBOTG@@UAAKPAGK@Z|
	DCD	|?FastIOControl@DefaultBusDriver@@UAAHKPAEK0KPAKPAPAVDeviceFolder@@@Z|
	DCD	|?CreateFunctionDeviceFolder@OMAPMHSUSBOTG@@UAAPAVDeviceFolder@@PBG0KKKKPAXK0@Z|
	DCD	|?CreateHostDeviceFolder@OMAPMHSUSBOTG@@UAAPAVDeviceFolder@@PBG0KKKKPAXK0@Z|
	DCD	|?ActivateAllChildDrivers@USBOTG@@UAAHXZ|
	DCD	|?LoadUnloadHCD@OMAPMHSUSBOTG@@UAAHH@Z|
	DCD	|?LoadUnloadUSBFN@OMAPMHSUSBOTG@@UAAHH@Z|
	DCD	|?UsbOtgConfigure@OMAPMHSUSBOTG@@UAA?AW4USBOTG_MODE@@W42@@Z|
	DCD	|?EventNotification@OMAPMHSUSBOTG@@UAAHXZ|
	DCD	|?TimeOut@USBOTG@@UAAHW4USBOTG_WATCHITEM@@@Z|
	DCD	|?NewStateAction@OMAPMHSUSBOTG@@UAAHW4USBOTG_STATES@@T_USBOTG_OUTPUT@@@Z|
	DCD	|?UpdateInput@OMAPMHSUSBOTG@@UAAHXZ|
	DCD	|?SessionRequest@OMAPMHSUSBOTG@@UAAHHH@Z|
	DCD	|?DischargVBus@OMAPMHSUSBOTG@@UAAHXZ|
	DCD	|?IsSE0@OMAPMHSUSBOTG@@UAAHXZ|
	DCD	|?GetOTGEnableBit@USBOTG@@UAAEPBG@Z|
	DCD	|?OtgRequestBus@USBOTG@@UAAHH@Z|
	DCD	|?OtgDropBus@USBOTG@@UAAHH@Z|
	DCD	|?OtgSuspendBus@USBOTG@@UAAHPBGH@Z|
	DCD	|?OtgEnableHNP@USBOTG@@UAAHPBGH@Z|
	DCD	|?OTGNotifyDetach@USBOTG@@UAAHPBG@Z|
	DCD	|?OTGUSBFNNotfyActive@OMAPMHSUSBOTG@@UAAHPBGH@Z|
	DCD	|?OTGHCDNotfyAccept@OMAPMHSUSBOTG@@UAAHPBGH@Z|
	DCD	|?GetOtgAConnectEvent@USBOTG@@UAAPAXXZ|
	DCD	|?SetChildDevicePowerState@USBOTG@@UAAHPAU_CE_BUS_POWER_STATE@@@Z|
	DCD	|?GetChildDevicePowerState@USBOTG@@UAAHPAU_CE_BUS_POWER_STATE@@@Z|
	DCD	|?UpdatePowerState@USBOTG@@UAAHXZ|
	DCD	|?GetPowerCapabilities@USBOTG@@UAA?AU_POWER_CAPABILITIES@@XZ|
	DCD	|?EnterState@USBOTG@@MAAHW4USBOTG_STATES@@@Z|
	DCD	|?StateChange@USBOTG@@MAA?AW4USBOTG_STATES@@W42@@Z|
	DCD	|?OTG_ConfigISR_stage1@OMAPMHSUSBOTG@@UAAKXZ|
	DCD	|?OTG_ConfigISR_stage2@OMAPMHSUSBOTG@@UAAKXZ|
	DCD	|?PowerDownDisconnect@OMAPMHSUSBOTG@@UAAXXZ|
	DCD	|?OTG_ProcessEP0@OMAPMHSUSBOTG@@UAAKXZ|
	DCD	|?OTG_ProcessEPx@OMAPMHSUSBOTG@@UAAKEH@Z|
	DCD	|?GetMode@OMAPMHSUSBOTG@@UAAKXZ|
	DCD	|?StartUSBClock@OMAPMHSUSBOTG@@UAAHH@Z|
	DCD	|?StopUSBClock@OMAPMHSUSBOTG@@UAAHXZ|
	DCD	|?ResetEndPoints@OMAPMHSUSBOTG@@UAAXXZ|
	DCD	|?EnableSuspend@OMAPMHSUSBOTG@@UAAHH@Z|
	DCD	|?UpdateBatteryCharger@OMAPMHSUSBOTG@@UAAXK@Z|
	DCD	|?SoftResetMUSBController@OMAPMHSUSBOTG@@UAAHH@Z|
	DCD	|?SoftResetULPILink@OMAPMHSUSBOTG@@UAAHXZ|
	DCD	|?ContextRestore@OMAPMHSUSBOTG@@UAAHXZ|
	DCD	|?SetPowerState@OMAPMHSUSBOTG@@UAAHW4_CEDEVICE_POWER_STATE@@@Z|

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7OMAPMHSUSBOTG@@6BCMiniThread@@@| DCD |?ThreadRun@OMAPMHSUSBOTG@@EAAKXZ| ; OMAPMHSUSBOTG::`vftable'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0OMAPMHSUSBOTG@@QAA@PBG@Z| PROC	; OMAPMHSUSBOTG::OMAPMHSUSBOTG

; 385  : {

  00000		 |$LN11@OMAPMHSUSB@5|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M43703|
  00004	e1a06001	 mov         r6, r1
  00008	e1a04000	 mov         r4, r0
  0000c	eb000000	 bl          |??0USBOTG@@QAA@PBG@Z|
  00010	e3a02001	 mov         r2, #1
  00014	e3a01000	 mov         r1, #0
  00018	e28400dc	 add         r0, r4, #0xDC
  0001c	eb000000	 bl          |??0CMiniThread@@QAA@KH@Z|
  00020	e59fe0b4	 ldr         lr, [pc, #0xB4]
  00024	e59f30ac	 ldr         r3, [pc, #0xAC]
  00028	e1a02006	 mov         r2, r6
  0002c	e3a0110a	 mov         r1, #0xA, 2
  00030	e2840f4e	 add         r0, r4, #0x4E, 30
  00034	e584e0dc	 str         lr, [r4, #0xDC]
  00038	e5843000	 str         r3, [r4]
  0003c	eb000000	 bl          |??0CRegistryEdit@@QAA@PAUHKEY__@@PBG@Z|

; 386  :     if (GetDeviceRegistryParams(
; 387  :         lpActivePath, &m_OTGRegCfg, dimof(s_deviceRegParams), s_deviceRegParams
; 388  :         ) != ERROR_SUCCESS)

  00040	e59f308c	 ldr         r3, [pc, #0x8C]
  00044	e3a07000	 mov         r7, #0
  00048	e3a02008	 mov         r2, #8
  0004c	e2841c01	 add         r1, r4, #1, 24
  00050	e1a00006	 mov         r0, r6
  00054	e584717c	 str         r7, [r4, #0x17C]
  00058	eb000000	 bl          GetDeviceRegistryParams

; 389  :     {
; 390  :         DEBUGMSG(ZONE_OTG_ERROR, (L"ERROR: OMAPMHSUSBOTG: "
; 391  :             L"Failed read registry parameters\r\n"
; 392  :             ));
; 393  :     }
; 394  : 
; 395  :     m_hParent = CreateBusAccessHandle(lpActivePath);

  0005c	e1a00006	 mov         r0, r6
  00060	eb000000	 bl          CreateBusAccessHandle
  00064	e5840140	 str         r0, [r4, #0x140]

; 396  :     if (m_hParent == NULL)
; 397  :         DEBUGMSG(ZONE_OTG_ERROR, (TEXT("Fail to get Bus Handle\r\n")));
; 398  : 
; 399  :     m_ActiveKeyPath = NULL;

  00068	e584713c	 str         r7, [r4, #0x13C]

; 400  :     if (lpActivePath) 

  0006c	e3560000	 cmp         r6, #0
  00070	0a00000b	 beq         |$LN1@OMAPMHSUSB@5|

; 401  :     {
; 402  :         DWORD dwLength = _tcslen(lpActivePath) + 1;

  00074	e1a00006	 mov         r0, r6
  00078	eb000000	 bl          wcslen
  0007c	e2805001	 add         r5, r0, #1

; 403  :         m_ActiveKeyPath = new TCHAR[dwLength];

  00080	e3750106	 cmn         r5, #6, 2
  00084	91a00085	 movls       r0, r5, lsl #1
  00088	83e00000	 mvnhi       r0, #0
  0008c	eb000000	 bl          |??2@YAPAXI@Z|
  00090	e3500000	 cmp         r0, #0

; 404  :         if (m_ActiveKeyPath)
; 405  :             StringCchCopy(m_ActiveKeyPath, dwLength, lpActivePath);

  00094	11a02006	 movne       r2, r6
  00098	11a01005	 movne       r1, r5
  0009c	e584013c	 str         r0, [r4, #0x13C]
  000a0	1b000000	 blne        StringCchCopyW
  000a4		 |$LN1@OMAPMHSUSB@5|

; 406  :     }
; 407  : 
; 408  :     InitializeCriticalSection(&m_csUSBClock);

  000a4	e2840f49	 add         r0, r4, #0x49, 30
  000a8	eb000000	 bl          InitializeCriticalSection

; 409  :     m_bHNPEnable = FALSE;
; 410  :     m_pDMA = NULL;
; 411  :     m_pIdGnd = NULL;
; 412  :     m_bOTGReady = FALSE;
; 413  :     m_disconnected = TRUE;

  000ac	e3a03001	 mov         r3, #1
  000b0	e584318c	 str         r3, [r4, #0x18C]

; 414  :     m_fDelayRequired = TRUE;

  000b4	e584319c	 str         r3, [r4, #0x19C]
  000b8	e584716c	 str         r7, [r4, #0x16C]
  000bc	e5847154	 str         r7, [r4, #0x154]
  000c0	e5847158	 str         r7, [r4, #0x158]
  000c4	e5847188	 str         r7, [r4, #0x188]

; 415  : }

  000c8	e1a00004	 mov         r0, r4
  000cc	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000d0	e12fff1e	 bx          lr
  000d4		 |$LN12@OMAPMHSUSB@5|
  000d4		 |$LN13@OMAPMHSUSB@5|
  000d4	00000000	 DCD         |s_deviceRegParams|
  000d8		 |$LN14@OMAPMHSUSB@5|
  000d8	00000000	 DCD         |??_7OMAPMHSUSBOTG@@6BUSBOTG@@@|
  000dc		 |$LN15@OMAPMHSUSB@5|
  000dc	00000000	 DCD         |??_7OMAPMHSUSBOTG@@6BCMiniThread@@@|
  000e0		 |$M43704|

			 ENDP  ; |??0OMAPMHSUSBOTG@@QAA@PBG@Z|, OMAPMHSUSBOTG::OMAPMHSUSBOTG

; File c:\wince600\public\common\oak\inc\defbus.h

  00000			 AREA	 |.pdata|, PDATA
|$T43719| DCD	|$LN5@Close|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Close@DefaultBusDriver@@UAAHXZ| PROC	; DefaultBusDriver::Close

; 150  :     virtual BOOL  Close() { return TRUE; };

  00000		 |$LN5@Close|
  00000		 |$M43716|
  00000	e3a00001	 mov         r0, #1
  00004	e12fff1e	 bx          lr
  00008		 |$M43717|

			 ENDP  ; |?Close@DefaultBusDriver@@UAAHXZ|, DefaultBusDriver::Close


  00000			 AREA	 |.pdata|, PDATA
|$T43728| DCD	|$LN5@IsChildRem|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsChildRemoved@DefaultBusDriver@@UAAHPBG@Z| PROC ; DefaultBusDriver::IsChildRemoved

; 162  :     virtual BOOL IsChildRemoved(LPCTSTR lpChildName) { return FALSE; }; // Can not be removed for default driver.

  00000		 |$LN5@IsChildRem|
  00000		 |$M43725|
  00000	e3a00000	 mov         r0, #0
  00004	e12fff1e	 bx          lr
  00008		 |$M43726|

			 ENDP  ; |?IsChildRemoved@DefaultBusDriver@@UAAHPBG@Z|, DefaultBusDriver::IsChildRemoved

; File c:\wince600\public\common\oak\inc\usbotg.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T43737| DCD	|$LN5@Open|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Open@USBOTG@@UAAHKK@Z| PROC		; USBOTG::Open

; 185  :     virtual BOOL  Open( DWORD   AccessCode,   DWORD   Share) { return TRUE; };

  00000		 |$LN5@Open|
  00000		 |$M43734|
  00000	e3a00001	 mov         r0, #1
  00004	e12fff1e	 bx          lr
  00008		 |$M43735|

			 ENDP  ; |?Open@USBOTG@@UAAHKK@Z|, USBOTG::Open


  00000			 AREA	 |.pdata|, PDATA
|$T43747| DCD	|$LN5@GetOtgACon|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetOtgAConnectEvent@USBOTG@@UAAPAXXZ| PROC ; USBOTG::GetOtgAConnectEvent

; 208  :     virtual HANDLE GetOtgAConnectEvent() { return m_hAConnectEvent; };

  00000		 |$LN5@GetOtgACon|
  00000		 |$M43744|
  00000	e590009c	 ldr         r0, [r0, #0x9C]
  00004	e12fff1e	 bx          lr
  00008		 |$M43745|

			 ENDP  ; |?GetOtgAConnectEvent@USBOTG@@UAAPAXXZ|, USBOTG::GetOtgAConnectEvent


  00000			 AREA	 |.pdata|, PDATA
|$T43756| DCD	|$LN5@SetChildDe|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetChildDevicePowerState@USBOTG@@UAAHPAU_CE_BUS_POWER_STATE@@@Z| PROC ; USBOTG::SetChildDevicePowerState

; 210  :     virtual BOOL SetChildDevicePowerState(PCE_BUS_POWER_STATE ) { return FALSE; };

  00000		 |$LN5@SetChildDe|
  00000		 |$M43753|
  00000	e3a00000	 mov         r0, #0
  00004	e12fff1e	 bx          lr
  00008		 |$M43754|

			 ENDP  ; |?SetChildDevicePowerState@USBOTG@@UAAHPAU_CE_BUS_POWER_STATE@@@Z|, USBOTG::SetChildDevicePowerState


  00000			 AREA	 |.pdata|, PDATA
|$T43765| DCD	|$LN5@GetChildDe|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetChildDevicePowerState@USBOTG@@UAAHPAU_CE_BUS_POWER_STATE@@@Z| PROC ; USBOTG::GetChildDevicePowerState

; 211  :     virtual BOOL GetChildDevicePowerState(PCE_BUS_POWER_STATE) { return FALSE; };

  00000		 |$LN5@GetChildDe|
  00000		 |$M43762|
  00000	e3a00000	 mov         r0, #0
  00004	e12fff1e	 bx          lr
  00008		 |$M43763|

			 ENDP  ; |?GetChildDevicePowerState@USBOTG@@UAAHPAU_CE_BUS_POWER_STATE@@@Z|, USBOTG::GetChildDevicePowerState


  00000			 AREA	 |.pdata|, PDATA
|$T43774| DCD	|$LN5@UpdatePowe|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdatePowerState@USBOTG@@UAAHXZ| PROC ; USBOTG::UpdatePowerState

; 214  :     virtual BOOL UpdatePowerState() { return TRUE ;};

  00000		 |$LN5@UpdatePowe|
  00000		 |$M43771|
  00000	e3a00001	 mov         r0, #1
  00004	e12fff1e	 bx          lr
  00008		 |$M43772|

			 ENDP  ; |?UpdatePowerState@USBOTG@@UAAHXZ|, USBOTG::UpdatePowerState

	IMPORT	|memcpy|

  00000			 AREA	 |.pdata|, PDATA
|$T43786| DCD	|$LN5@GetPowerCa|
	DCD	0x40000901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetPowerCapabilities@USBOTG@@UAA?AU_POWER_CAPABILITIES@@XZ| PROC ; USBOTG::GetPowerCapabilities

; 215  :     virtual POWER_CAPABILITIES GetPowerCapabilities() { return m_PowerCapabilities; };

  00000		 |$LN5@GetPowerCa|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M43783|
  00004	e1a04001	 mov         r4, r1
  00008	e28010a0	 add         r1, r0, #0xA0
  0000c	e1a00004	 mov         r0, r4
  00010	e3a02030	 mov         r2, #0x30
  00014	eb000000	 bl          memcpy
  00018	e1a00004	 mov         r0, r4
  0001c	e8bd4010	 ldmia       sp!, {r4, lr}
  00020	e12fff1e	 bx          lr
  00024		 |$M43784|

			 ENDP  ; |?GetPowerCapabilities@USBOTG@@UAA?AU_POWER_CAPABILITIES@@XZ|, USBOTG::GetPowerCapabilities

; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbotg\otg.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T43795| DCD	|$LN5@DischargVB|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DischargVBus@OMAPMHSUSBOTG@@UAAHXZ| PROC ; OMAPMHSUSBOTG::DischargVBus

; 98   :     virtual BOOL    DischargVBus()  { return TRUE; };

  00000		 |$LN5@DischargVB|
  00000		 |$M43792|
  00000	e3a00001	 mov         r0, #1
  00004	e12fff1e	 bx          lr
  00008		 |$M43793|

			 ENDP  ; |?DischargVBus@OMAPMHSUSBOTG@@UAAHXZ|, OMAPMHSUSBOTG::DischargVBus

	EXPORT	|??1OMAPMHSUSBOTG@@UAA@XZ|		; OMAPMHSUSBOTG::~OMAPMHSUSBOTG
	IMPORT	|??1USBOTG@@UAA@XZ|			; USBOTG::~USBOTG
	IMPORT	|ReleaseDevicePads|
	IMPORT	|CloseBusAccessHandle|
; File c:\wince600\public\common\oak\inc\cmthread.h

  00000			 AREA	 |.pdata|, PDATA
|$T43833| DCD	|$LN23@OMAPMHSUSB@6|
	DCD	0x40004201
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbotg\otg.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1OMAPMHSUSBOTG@@UAA@XZ| PROC	; OMAPMHSUSBOTG::~OMAPMHSUSBOTG

; 434  : {

  00000		 |$LN23@OMAPMHSUSB@6|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M43830|
  00004	e1a04000	 mov         r4, r0

; 435  :     if (m_ActiveKeyPath)

  00008	e594113c	 ldr         r1, [r4, #0x13C]
  0000c	e59f30f0	 ldr         r3, [pc, #0xF0]
  00010	e59f20e8	 ldr         r2, [pc, #0xE8]
  00014	e3510000	 cmp         r1, #0

; 436  :         delete [] m_ActiveKeyPath;

  00018	11a00001	 movne       r0, r1
  0001c	e5843000	 str         r3, [r4]
  00020	e58420dc	 str         r2, [r4, #0xDC]
  00024	1b000000	 blne        |??3@YAXPAX@Z|

; 437  : 
; 438  :     if (m_hParent) 

  00028	e5943140	 ldr         r3, [r4, #0x140]
  0002c	e3530000	 cmp         r3, #0
  00030	0a000013	 beq         |$LN3@OMAPMHSUSB@6|

; 439  :     {
; 440  :         EnterCriticalSection(&m_pOTG->regCS);

  00034	e5943150	 ldr         r3, [r4, #0x150]
  00038	e2830038	 add         r0, r3, #0x38
  0003c	eb000000	 bl          EnterCriticalSection

; 441  :         m_pOTG->bClockStatus=FALSE;

  00040	e5943150	 ldr         r3, [r4, #0x150]

; 442  :         UpdateDevicePower(m_hParent, D4, NULL);

  00044	e59f20b0	 ldr         r2, [pc, #0xB0]
  00048	e3a01000	 mov         r1, #0
  0004c	e5831060	 str         r1, [r3, #0x60]
  00050	e5923000	 ldr         r3, [r2]
  00054	e5940140	 ldr         r0, [r4, #0x140]
  00058	e3530004	 cmp         r3, #4
  0005c	13a03004	 movne       r3, #4
  00060	15823000	 strne       r3, [r2]
  00064	13a02000	 movne       r2, #0
  00068	13a01004	 movne       r1, #4
  0006c	1b000000	 blne        SetDevicePowerState

; 443  :         LeaveCriticalSection(&m_pOTG->regCS);

  00070	e5943150	 ldr         r3, [r4, #0x150]
  00074	e2830038	 add         r0, r3, #0x38
  00078	eb000000	 bl          LeaveCriticalSection

; 444  :         CloseBusAccessHandle(m_hParent);

  0007c	e5940140	 ldr         r0, [r4, #0x140]
  00080	eb000000	 bl          CloseBusAccessHandle
  00084		 |$LN3@OMAPMHSUSB@6|

; 445  :     }
; 446  :     
; 447  :     if (m_pDMA)

  00084	e5943154	 ldr         r3, [r4, #0x154]
  00088	e1b00003	 movs        r0, r3

; 448  :         delete m_pDMA;

  0008c	15903000	 ldrne       r3, [r0]
  00090	13a01001	 movne       r1, #1
  00094	15933004	 ldrne       r3, [r3, #4]
  00098	11a0e00f	 movne       lr, pc
  0009c	112fff13	 bxne        r3

; 449  : 
; 450  :     if (m_pIdGnd)

  000a0	e5943158	 ldr         r3, [r4, #0x158]
  000a4	e1b00003	 movs        r0, r3

; 451  :         delete m_pIdGnd;

  000a8	15903000	 ldrne       r3, [r0]
  000ac	13a01001	 movne       r1, #1
  000b0	15933004	 ldrne       r3, [r3, #4]
  000b4	11a0e00f	 movne       lr, pc
  000b8	112fff13	 bxne        r3

; 452  : 
; 453  : 	ReleaseDevicePads(OMAP_DEVICE_HSOTGUSB);

  000bc	e3a00003	 mov         r0, #3
  000c0	eb000000	 bl          ReleaseDevicePads

; 454  : }

  000c4	e1a03004	 mov         r3, r4
  000c8	e5b32138	 ldr         r2, [r3, #0x138]!
  000cc	e3520000	 cmp         r2, #0
  000d0	11a00002	 movne       r0, r2
  000d4	1b000000	 blne        RegCloseKey
  000d8	e59f3018	 ldr         r3, [pc, #0x18]
  000dc	e1a00004	 mov         r0, r4
  000e0	e5a030dc	 str         r3, [r0, #0xDC]!
  000e4	eb000000	 bl          |?ForceTerminated@CMiniThread@@QAAHXZ|
  000e8	e1a00004	 mov         r0, r4
  000ec	eb000000	 bl          |??1USBOTG@@UAA@XZ|
  000f0	e8bd4010	 ldmia       sp!, {r4, lr}
  000f4	e12fff1e	 bx          lr
  000f8		 |$LN24@OMAPMHSUSB@6|
  000f8		 |$LN25@OMAPMHSUSB@6|
  000f8	00000000	 DCD         |??_7CMiniThread@@6B@|
  000fc		 |$LN26@OMAPMHSUSB@6|
  000fc	00000000	 DCD         |?g_busDx@@3W4_CEDEVICE_POWER_STATE@@A|
  00100		 |$LN27@OMAPMHSUSB@6|
  00100	00000000	 DCD         |??_7OMAPMHSUSBOTG@@6BCMiniThread@@@|
  00104		 |$LN28@OMAPMHSUSB@6|
  00104	00000000	 DCD         |??_7OMAPMHSUSBOTG@@6BUSBOTG@@@|
  00108		 |$M43831|

			 ENDP  ; |??1OMAPMHSUSBOTG@@UAA@XZ|, OMAPMHSUSBOTG::~OMAPMHSUSBOTG

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?MapHardware@OMAPMHSUSBOTG@@AAAHXZ|	; OMAPMHSUSBOTG::MapHardware
	IMPORT	|GetLastError|
	IMPORT	|MmMapIoSpace|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|__security_check_cookie|
; File c:\wince600\public\common\oak\inc\cregedit.h

  00000			 AREA	 |.pdata|, PDATA
|$T43893| DCD	|$LN25@MapHardwar|
	DCD	0xc0008d02

  00000			 AREA	 |.xdata|, DATA
|$T43889| DCD	0xffffffe8
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbotg\otg.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T43889|

  00008		 |?MapHardware@OMAPMHSUSBOTG@@AAAHXZ| PROC ; OMAPMHSUSBOTG::MapHardware

; 636  : {    

  00008		 |$LN25@MapHardwar|
  00008	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  0000c	e24ddf46	 sub         sp, sp, #0x46, 30
  00010		 |$M43890|
  00010	e1a05000	 mov         r5, r0
  00014	e59f321c	 ldr         r3, [pc, #0x21C]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3114	 str         r3, [sp, #0x114]

; 637  :     PHYSICAL_ADDRESS pa;
; 638  :     PCSP_MUSB_GEN_REGS pGen;
; 639  :     PCSP_MUSB_OTG_REGS pOtg;
; 640  :     PCSP_MUSB_DMA_REGS pDma;
; 641  :     PCSP_MUSB_CSR_REGS pCsr;
; 642  :     volatile DWORD *pSysControlRegs;
; 643  :     DDKISRINFO dii;        
; 644  :     TCHAR *ptcChargerEvent;
; 645  :     DWORD dwDMAIrq;
; 646  :     
; 647  :     if (GetIsrInfo(&dii) != ERROR_SUCCESS) 

  00020	e1a03005	 mov         r3, r5
  00024	e5b3202c	 ldr         r2, [r3, #0x2C]!
  00028	e3520000	 cmp         r2, #0
  0002c	0a000005	 beq         |$LN19@MapHardwar|
  00030	e3a03f43	 mov         r3, #0x43, 30
  00034	e28d1008	 add         r1, sp, #8
  00038	e1a00002	 mov         r0, r2
  0003c	e58d3008	 str         r3, [sp, #8]
  00040	eb000000	 bl          DDKReg_GetIsrInfo
  00044	ea000000	 b           |$LN18@MapHardwar|
  00048		 |$LN19@MapHardwar|
  00048	e3a00001	 mov         r0, #1
  0004c		 |$LN18@MapHardwar|
  0004c	e3500000	 cmp         r0, #0
  00050	0a000003	 beq         |$LN11@MapHardwar|
  00054		 |$LN22@MapHardwar|

; 648  :     {
; 649  :         return FALSE;

  00054	e59d0114	 ldr         r0, [sp, #0x114]
  00058	eb000000	 bl          __security_check_cookie
  0005c	e3a00000	 mov         r0, #0
  00060	ea00006b	 b           |$LN12@MapHardwar|
  00064		 |$LN11@MapHardwar|
  00064	e3a03312	 mov         r3, #0x12, 6

; 650  :     }
; 651  : 
; 652  :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("IRQ = 0x%x\r\n"), dii.dwIrq));
; 653  : 
; 654  :     pa.QuadPart = OMAP35XX_MUSB_BASE_REG_PA + OMAP35XX_MUSB_GEN_OFFSET;

  00068	e3830aab	 orr         r0, r3, #0xAB, 20

; 655  :     pGen = (PCSP_MUSB_GEN_REGS)MmMapIoSpace(pa, sizeof(CSP_MUSB_GEN_REGS), FALSE);

  0006c	e3a03000	 mov         r3, #0
  00070	e3a01000	 mov         r1, #0
  00074	e3a02c01	 mov         r2, #1, 24
  00078	eb000000	 bl          MmMapIoSpace
  0007c	e1b02000	 movs        r2, r0

; 656  : 
; 657  :     if (pGen == NULL)
; 658  :     {
; 659  :         DEBUGMSG(ZONE_OTG_ERROR, (TEXT("Fail to MmMap USB General Registers\r\n")));
; 660  :         return FALSE;

  00080	0afffff3	 beq         |$LN22@MapHardwar|

; 661  :     }   
; 662  :     m_pOTG->pUsbGenRegs = pGen;

  00084	e5953150	 ldr         r3, [r5, #0x150]

; 663  :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Sizeof(CSP_MUSB_GEN_REGS)=0x%x, mapped (0x%x)\r\n"), sizeof(CSP_MUSB_GEN_REGS), pGen)); 
; 664  :  
; 665  :     pa.QuadPart = OMAP35XX_MUSB_BASE_REG_PA + OMAP35XX_MUSB_CSR_OFFSET;

  00088	e59f01a4	 ldr         r0, [pc, #0x1A4]
  0008c	e3a01000	 mov         r1, #0
  00090	e5832020	 str         r2, [r3, #0x20]

; 666  :     pCsr = (PCSP_MUSB_CSR_REGS)MmMapIoSpace(pa, sizeof(CSP_MUSB_CSR_REGS), FALSE);

  00094	e3a03000	 mov         r3, #0
  00098	e3a02c01	 mov         r2, #1, 24
  0009c	eb000000	 bl          MmMapIoSpace
  000a0	e1b02000	 movs        r2, r0

; 667  : 
; 668  :     if (pCsr == NULL)
; 669  :     {
; 670  :         DEBUGMSG(ZONE_OTG_ERROR, (TEXT("Fail to MmMap USB CSR Registers\r\n")));
; 671  :         return FALSE;

  000a4	0affffea	 beq         |$LN22@MapHardwar|

; 672  :     }   
; 673  :     m_pOTG->pUsbCsrRegs = pCsr;

  000a8	e5953150	 ldr         r3, [r5, #0x150]

; 674  :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Sizeof(CSP_MUSB_CSR_REGS)=0x%x, mapped (0x%x)\r\n"), sizeof(CSP_MUSB_CSR_REGS), pCsr)); 
; 675  : 
; 676  : 
; 677  :     pa.QuadPart = OMAP35XX_MUSB_BASE_REG_PA + OMAP35XX_MUSB_OTG_OFFSET;    

  000ac	e59f017c	 ldr         r0, [pc, #0x17C]
  000b0	e3a01000	 mov         r1, #0
  000b4	e583201c	 str         r2, [r3, #0x1C]

; 678  :     pOtg = (PCSP_MUSB_OTG_REGS)MmMapIoSpace(pa, sizeof(CSP_MUSB_OTG_REGS), FALSE);

  000b8	e3a03000	 mov         r3, #0
  000bc	e3a02018	 mov         r2, #0x18
  000c0	eb000000	 bl          MmMapIoSpace
  000c4	e1b02000	 movs        r2, r0

; 679  :     if (pOtg == NULL)
; 680  :     {
; 681  :         DEBUGMSG(ZONE_OTG_ERROR, (TEXT("Fail to MmMap USB OTG Registers\r\n")));
; 682  :         return FALSE;

  000c8	0affffe1	 beq         |$LN22@MapHardwar|

; 683  :     }   
; 684  :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Sizeof(CSP_MUSB_OTG_REGS)=0x%x, mapped (0x%x)\r\n"), sizeof(CSP_MUSB_OTG_REGS), pOtg)); 
; 685  :     m_pOTG->pUsbOtgRegs = pOtg;

  000cc	e5953150	 ldr         r3, [r5, #0x150]

; 686  : 
; 687  :     pa.QuadPart = OMAP35XX_MUSB_BASE_REG_PA + OMAP35XX_MUSB_DMA_OFFSET;        

  000d0	e59f0154	 ldr         r0, [pc, #0x154]
  000d4	e3a01000	 mov         r1, #0
  000d8	e5832018	 str         r2, [r3, #0x18]

; 688  :     pDma = (PCSP_MUSB_DMA_REGS)MmMapIoSpace(pa, sizeof(CSP_MUSB_DMA_REGS), FALSE);

  000dc	e3a03000	 mov         r3, #0
  000e0	e3a02084	 mov         r2, #0x84
  000e4	eb000000	 bl          MmMapIoSpace
  000e8	e1b02000	 movs        r2, r0

; 689  :     if (pDma == NULL)
; 690  :     {
; 691  :         DEBUGMSG(ZONE_OTG_ERROR, (TEXT("Fail to MmMap USB OTG Registers\r\n")));
; 692  :         return FALSE;

  000ec	0affffd8	 beq         |$LN22@MapHardwar|

; 693  :     }   
; 694  :     m_pOTG->pUsbDmaRegs = pDma;

  000f0	e5953150	 ldr         r3, [r5, #0x150]

; 695  : 
; 696  :     pa.QuadPart = OMAP_SYSC_GENERAL_REGS_PA; //Verify

  000f4	e59f012c	 ldr         r0, [pc, #0x12C]
  000f8	e3a01000	 mov         r1, #0
  000fc	e5832024	 str         r2, [r3, #0x24]

; 697  :     pSysControlRegs = (volatile DWORD *)MmMapIoSpace(pa, 1024, FALSE);

  00100	e3a03000	 mov         r3, #0
  00104	e3a02b01	 mov         r2, #1, 22
  00108	eb000000	 bl          MmMapIoSpace

; 698  : 
; 699  :     m_pOTG->pSysControlRegs = pSysControlRegs;

  0010c	e595e150	 ldr         lr, [r5, #0x150]
  00110	e1a04000	 mov         r4, r0

; 700  :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Sizeof(CSP_MUSB_DMA_REGS)=0x%x, mapped (0x%x)\r\n"), sizeof(CSP_MUSB_DMA_REGS), pDma)); 
; 701  : 
; 702  :     pa.QuadPart = OMAP_SYSC_PADCONFS_REGS_PA;//Verify

  00114	e59f0108	 ldr         r0, [pc, #0x108]
  00118	e3a01000	 mov         r1, #0

; 703  :     m_pOTG->pPadControlRegs = (volatile UINT8 *)MmMapIoSpace(pa, 2048, FALSE);

  0011c	e3a03000	 mov         r3, #0
  00120	e3a02b02	 mov         r2, #2, 22
  00124	e58e402c	 str         r4, [lr, #0x2C]
  00128	eb000000	 bl          MmMapIoSpace
  0012c	e595e150	 ldr         lr, [r5, #0x150]
  00130	e1a04000	 mov         r4, r0

; 704  : 
; 705  :     if (!KernelIoControl(IOCTL_HAL_REQUEST_SYSINTR, 
; 706  :                 &dii.dwIrq, 
; 707  :                 sizeof(dii.dwIrq), 
; 708  :                 &dii.dwSysintr, 
; 709  :                 sizeof(dii.dwSysintr), 
; 710  :                 NULL )) 

  00134	e59f00e4	 ldr         r0, [pc, #0xE4]
  00138	e3a06004	 mov         r6, #4
  0013c	e3a07000	 mov         r7, #0
  00140	e28d3010	 add         r3, sp, #0x10
  00144	e3a02004	 mov         r2, #4
  00148	e28d100c	 add         r1, sp, #0xC
  0014c	e58e4028	 str         r4, [lr, #0x28]
  00150	e58d7004	 str         r7, [sp, #4]
  00154	e58d6000	 str         r6, [sp]
  00158	eb000000	 bl          KernelIoControl
  0015c	e3500000	 cmp         r0, #0

; 711  :     {
; 712  :         DEBUGMSG(ZONE_OTG_ERROR, (L"ERROR: OTG_Init: "  L"Failed map OTG controller interrupt\r\n" ));
; 713  :         return FALSE;

  00160	0affffbb	 beq         |$LN22@MapHardwar|

; 714  :     }
; 715  : 
; 716  :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("IRQ=0x%x, SYSINTR=0x%x\r\n"), dii.dwIrq, dii.dwSysintr));
; 717  :     m_dwSysIntr = dii.dwSysintr;

  00164	e59d3010	 ldr         r3, [sp, #0x10]

; 718  :     m_dwIrq = dii.dwIrq;

  00168	e59d200c	 ldr         r2, [sp, #0xC]

; 719  :     
; 720  :     // Spawn a thread to wait for DMA event
; 721  :     DEBUGMSG(ZONE_OTG_FUNCTION,(TEXT("RegOpenKeyEx(%s) \r\n"), m_ActiveKeyPath));
; 722  : 
; 723  :     dwDMAIrq = m_OTGRegCfg.DMAIrq;
; 724  :     
; 725  :     m_pDMA = new OMAPMHSUSBDMA(this, dwDMAIrq);

  0016c	e595410c	 ldr         r4, [r5, #0x10C]
  00170	e3a00040	 mov         r0, #0x40
  00174	e5853144	 str         r3, [r5, #0x144]
  00178	e5852148	 str         r2, [r5, #0x148]
  0017c	eb000000	 bl          |??2@YAPAXI@Z|
  00180	e3500000	 cmp         r0, #0
  00184	0a000004	 beq         |$LN14@MapHardwar|
  00188	e1a02004	 mov         r2, r4
  0018c	e1a01005	 mov         r1, r5
  00190	eb000000	 bl          |??0OMAPMHSUSBDMA@@QAA@PAVOMAPMHSUSBOTG@@K@Z|
  00194	e1a03000	 mov         r3, r0
  00198	ea000000	 b           |$LN15@MapHardwar|
  0019c		 |$LN14@MapHardwar|
  0019c	e3a03000	 mov         r3, #0
  001a0		 |$LN15@MapHardwar|

; 726  :     if (m_pDMA == NULL)
; 727  :     {
; 728  :         DEBUGMSG(ZONE_OTG_ERROR, (TEXT("Fail to set up DMA and it would be disable\r\n")));            
; 729  :     }    
; 730  : 
; 731  :     m_pIdGnd = new OMAPMHSUSBIdGnd(this);

  001a0	e3a00038	 mov         r0, #0x38
  001a4	e5853154	 str         r3, [r5, #0x154]
  001a8	eb000000	 bl          |??2@YAPAXI@Z|
  001ac	e3500000	 cmp         r0, #0
  001b0	0a000003	 beq         |$LN16@MapHardwar|
  001b4	e1a01005	 mov         r1, r5
  001b8	eb000000	 bl          |??0OMAPMHSUSBIdGnd@@QAA@PAVOMAPMHSUSBOTG@@@Z|
  001bc	e1a0e000	 mov         lr, r0
  001c0	ea000000	 b           |$LN17@MapHardwar|
  001c4		 |$LN16@MapHardwar|
  001c4	e3a0e000	 mov         lr, #0
  001c8		 |$LN17@MapHardwar|

; 732  :     if (m_pIdGnd == NULL)
; 733  :         DEBUGMSG(ZONE_OTG_ERROR, (TEXT("OMAPMHSUSBIdGnd failed to create\r\n")));
; 734  : 
; 735  :     ptcChargerEvent = m_OTGRegCfg.szChargerNameEvt;

  001c8	e5953108	 ldr         r3, [r5, #0x108]

; 736  : 
; 737  :     DEBUGMSG(ZONE_OTG_INFO, (TEXT("OTG Charger Event(%s)\r\n"), ptcChargerEvent));
; 738  :     m_BatteryChargeEvent = CreateEvent(NULL, TRUE, FALSE, ptcChargerEvent);

  001cc	e3a02000	 mov         r2, #0
  001d0	e3a01001	 mov         r1, #1
  001d4	e3a00000	 mov         r0, #0
  001d8	e585e158	 str         lr, [r5, #0x158]
  001dc	eb000000	 bl          CreateEventW
  001e0	e5850174	 str         r0, [r5, #0x174]

; 739  :     if ((GetLastError() == ERROR_SUCCESS) || (GetLastError() == ERROR_ALREADY_EXISTS))

  001e4	eb000000	 bl          GetLastError
  001e8	e3500000	 cmp         r0, #0
  001ec	0a000003	 beq         |$LN2@MapHardwar|
  001f0	eb000000	 bl          GetLastError
  001f4	e35000b7	 cmp         r0, #0xB7

; 742  :         DEBUGMSG(ZONE_OTG_INFO, (TEXT("Battery Charger Event Create\r\n")));
; 743  :     }
; 744  :     else
; 745  :     {
; 746  :         DEBUGMSG(ZONE_OTG_ERROR, (TEXT("Battery Charger Event failure\r\n")));
; 747  :         m_BatteryChargeEvent = NULL;

  001f8	15857174	 strne       r7, [r5, #0x174]
  001fc	1a000001	 bne         |$LN1@MapHardwar|
  00200		 |$LN2@MapHardwar|

; 740  :     {
; 741  :         m_BatteryChargeStatus = 0xff;

  00200	e3a030ff	 mov         r3, #0xFF
  00204	e5853178	 str         r3, [r5, #0x178]
  00208		 |$LN1@MapHardwar|

; 748  :     }
; 749  :     return TRUE;

  00208	e59d0114	 ldr         r0, [sp, #0x114]
  0020c	eb000000	 bl          __security_check_cookie
  00210	e3a00001	 mov         r0, #1
  00214		 |$LN12@MapHardwar|

; 750  : }

  00214	e28ddf46	 add         sp, sp, #0x46, 30
  00218	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0021c	e12fff1e	 bx          lr
  00220		 |$LN26@MapHardwar|
  00220		 |$LN27@MapHardwar|
  00220	01010098	 DCD         0x1010098
  00224		 |$LN28@MapHardwar|
  00224	48002030	 DCD         0x48002030
  00228		 |$LN29@MapHardwar|
  00228	48002270	 DCD         0x48002270
  0022c		 |$LN30@MapHardwar|
  0022c	480ab200	 DCD         0x480ab200
  00230		 |$LN31@MapHardwar|
  00230	480ab400	 DCD         0x480ab400
  00234		 |$LN32@MapHardwar|
  00234	480ab100	 DCD         0x480ab100
  00238		 |$LN33@MapHardwar|
  00238	00000000	 DCD         |__security_cookie|
  0023c		 |$M43891|

			 ENDP  ; |?MapHardware@OMAPMHSUSBOTG@@AAAHXZ|, OMAPMHSUSBOTG::MapHardware

	EXPORT	|??_C@_1IM@GEPODNBC@?$AAB?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA?3?$AAH?$AAN?$AAP?$AA?5?$AAs?$AAw?$AAi?$AAt?$AAc?$AAh?$AAi?$AAn?$AAg?$AA?5?$AAa?$AAn?$AAd?$AA?5?$AAn?$AAe?$AAe?$AAd?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HI@JBKOMFKI@?$AAA?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA?3?$AAH?$AAN?$AAP?$AA?5?$AAs?$AAw?$AAi?$AAt?$AAc?$AAh?$AAi?$AAn?$AAg?$AA?5?$AAa?$AAn?$AAd?$AA?5?$AAn?$AAe?$AAe?$AAd?$AA?5@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T43930| DCD	|$LN53@OTG_Config@2|
	DCD	0x40010a02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1IM@GEPODNBC@?$AAB?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA?3?$AAH?$AAN?$AAP?$AA?5?$AAs?$AAw?$AAi?$AAt?$AAc?$AAh?$AAi?$AAn?$AAg?$AA?5?$AAa?$AAn?$AAd?$AA?5?$AAn?$AAe?$AAe?$AAd?$AA?5@| DCB "B"
	DCB	0x0, "_", 0x0, "D", 0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C"
	DCB	0x0, "E", 0x0, ":", 0x0, "H", 0x0, "N", 0x0, "P", 0x0, " "
	DCB	0x0, "s", 0x0, "w", 0x0, "i", 0x0, "t", 0x0, "c", 0x0, "h"
	DCB	0x0, "i", 0x0, "n", 0x0, "g", 0x0, " ", 0x0, "a", 0x0, "n"
	DCB	0x0, "d", 0x0, " ", 0x0, "n", 0x0, "e", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "d", 0x0, "i"
	DCB	0x0, "s", 0x0, "c", 0x0, "o", 0x0, "n", 0x0, "n", 0x0, "e"
	DCB	0x0, "c", 0x0, "t", 0x0, " ", 0x0, "d", 0x0, "e", 0x0, "v"
	DCB	0x0, "i", 0x0, "c", 0x0, "e", 0x0, " ", 0x0, "m", 0x0, "o"
	DCB	0x0, "d", 0x0, "e", 0x0, " ", 0x0, "D", 0x0, "e", 0x0, "v"
	DCB	0x0, "C", 0x0, "t", 0x0, "l", 0x0, ":", 0x0, "%", 0x0, "x"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HI@JBKOMFKI@?$AAA?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA?3?$AAH?$AAN?$AAP?$AA?5?$AAs?$AAw?$AAi?$AAt?$AAc?$AAh?$AAi?$AAn?$AAg?$AA?5?$AAa?$AAn?$AAd?$AA?5?$AAn?$AAe?$AAe?$AAd?$AA?5@| DCB "A"
	DCB	0x0, "_", 0x0, "D", 0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C"
	DCB	0x0, "E", 0x0, ":", 0x0, "H", 0x0, "N", 0x0, "P", 0x0, " "
	DCB	0x0, "s", 0x0, "w", 0x0, "i", 0x0, "t", 0x0, "c", 0x0, "h"
	DCB	0x0, "i", 0x0, "n", 0x0, "g", 0x0, " ", 0x0, "a", 0x0, "n"
	DCB	0x0, "d", 0x0, " ", 0x0, "n", 0x0, "e", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "d", 0x0, "i"
	DCB	0x0, "s", 0x0, "c", 0x0, "o", 0x0, "n", 0x0, "n", 0x0, "e"
	DCB	0x0, "c", 0x0, "t", 0x0, " ", 0x0, "d", 0x0, "e", 0x0, "v"
	DCB	0x0, "i", 0x0, "c", 0x0, "e", 0x0, " ", 0x0, "m", 0x0, "o"
	DCB	0x0, "d", 0x0, "e", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OTG_ConfigISR_stage2@OMAPMHSUSBOTG@@UAAKXZ| PROC ; OMAPMHSUSBOTG::OTG_ConfigISR_stage2

; 1492 : {    

  00000		 |$LN53@OTG_Config@2|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M43927|
  00008	e1a04000	 mov         r4, r0

; 1493 :     HKEY hkDevice;
; 1494 :     DWORD dwStatus;
; 1495 :     DWORD dwType, dwSize;
; 1496 :     
; 1497 :     // Step 1: Handling of SOF
; 1498 : 
; 1499 :     // Step 2: Handling of disconnect
; 1500 :     if ((((m_pOTG->intr_usb & INTRUSB_DISCONN) == INTRUSB_DISCONN)) || m_bSessionDisable)

  0000c	e594e150	 ldr         lr, [r4, #0x150]
  00010	e3a06000	 mov         r6, #0
  00014	e5de3034	 ldrb        r3, [lr, #0x34]
  00018	e2033020	 and         r3, r3, #0x20
  0001c	e3530020	 cmp         r3, #0x20
  00020	0a000002	 beq         |$LN34@OTG_Config@2|
  00024	e594317c	 ldr         r3, [r4, #0x17C]
  00028	e3530000	 cmp         r3, #0
  0002c	0a000077	 beq         |$LN17@OTG_Config@2|
  00030		 |$LN34@OTG_Config@2|

; 1501 :     {
; 1502 :         DWORD dwPrevState;
; 1503 :         DWORD dwCurMode = m_pOTG->operateMode;              
; 1504 :         DEBUGMSG(1, (TEXT("Host disconnect detected\r\n")));        
; 1505 :         DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Disconnect detected\r\n")));        
; 1506 : 
; 1507 :         if(!(ReadULPIReg( m_pOTG, ULPI_VENDORID_LOW_R)))

  00030	e5de5035	 ldrb        r5, [lr, #0x35]
  00034	e3a02000	 mov         r2, #0
  00038	e1a0100e	 mov         r1, lr
  0003c	e1a00004	 mov         r0, r4
  00040	eb000000	 bl          |?ReadULPIReg@OMAPMHSUSBOTG@@QAAEPAUHSMUSB_T@@E@Z|
  00044	e3500000	 cmp         r0, #0

; 1508 :         {
; 1509 :             SoftResetULPILink();

  00048	05943000	 ldreq       r3, [r4]
  0004c	01a00004	 moveq       r0, r4
  00050	059330fc	 ldreq       r3, [r3, #0xFC]
  00054	01a0e00f	 moveq       lr, pc
  00058	012fff13	 bxeq        r3

; 1510 :         }
; 1511 :         m_bSessionDisable = FALSE;
; 1512 :         m_disconnected = TRUE;
; 1513 :         if ((m_dwStatus & STATUS_HNP_SESSION_MASK) == 0x00)

  0005c	e59430f8	 ldr         r3, [r4, #0xF8]
  00060	e3a02001	 mov         r2, #1
  00064	e584617c	 str         r6, [r4, #0x17C]
  00068	e3130030	 tst         r3, #0x30
  0006c	e584218c	 str         r2, [r4, #0x18C]
  00070	1a00005b	 bne         |$LN19@OTG_Config@2|

; 1514 :         {
; 1515 :             ResetEndPoints();

  00074	e5943000	 ldr         r3, [r4]
  00078	e1a00004	 mov         r0, r4
  0007c	e59330ec	 ldr         r3, [r3, #0xEC]
  00080	e1a0e00f	 mov         lr, pc
  00084	e12fff13	 bx          r3

; 1516 :             // If we have done the disconnect, don't process anymore.
; 1517 :             if ((m_pOTG->connect_status & CONN_DC) == 0)

  00088	e5942150	 ldr         r2, [r4, #0x150]
  0008c	e5d2304c	 ldrb        r3, [r2, #0x4C]
  00090	e3130004	 tst         r3, #4

; 1518 :                 m_dwStatus |= STATUS_DISCONN_REQUEST|STATUS_WAIT_HOST_DISCONN_COMPLETE;

  00094	e59430f8	 ldr         r3, [r4, #0xF8]
  00098	03833042	 orreq       r3, r3, #0x42

; 1519 :             else                         
; 1520 :             {
; 1521 :                 m_dwStatus &= ~STATUS_WAIT_HOST_DISCONN_COMPLETE;

  0009c	13c33040	 bicne       r3, r3, #0x40

; 1522 :                 m_dwStatus |= STATUS_DISCONN_COMPLETE;           

  000a0	13833008	 orrne       r3, r3, #8
  000a4	e58430f8	 str         r3, [r4, #0xF8]

; 1523 :             }
; 1524 :             
; 1525 :             //DEBUGMSG(1, (TEXT("operateMode = IDLE (disconnect, ISR_stage2)\r\n")));
; 1526 :             m_pOTG->operateMode = IDLE_MODE;

  000a8	e5c26035	 strb        r6, [r2, #0x35]

; 1527 :             dwPrevState = m_pOTG->connect_status;

  000ac	e5942150	 ldr         r2, [r4, #0x150]
  000b0	e5d2104c	 ldrb        r1, [r2, #0x4C]

; 1528 :             m_pOTG->connect_status &= ~CONN_CCS;

  000b4	e20130fe	 and         r3, r1, #0xFE
  000b8	e5c2304c	 strb        r3, [r2, #0x4C]

; 1529 :             if (dwPrevState & CONN_CCS) 
; 1530 :                 m_pOTG->connect_status |= CONN_CSC;

  000bc	e5942150	 ldr         r2, [r4, #0x150]
  000c0	e3110001	 tst         r1, #1
  000c4	e5d2304c	 ldrb        r3, [r2, #0x4C]
  000c8	13833002	 orrne       r3, r3, #2

; 1531 :             else
; 1532 :                 m_pOTG->connect_status &= ~CONN_CSC;

  000cc	020330fd	 andeq       r3, r3, #0xFD
  000d0	e5c2304c	 strb        r3, [r2, #0x4C]

; 1533 : 
; 1534 :             if (dwCurMode == DEVICE_MODE)

  000d4	e3550001	 cmp         r5, #1
  000d8	1a00002c	 bne         |$LN27@OTG_Config@2|

; 1535 :             {
; 1536 :                 m_pTransceiver->SetVBusSource(TRUE);

  000dc	e59400fc	 ldr         r0, [r4, #0xFC]
  000e0	e3a01001	 mov         r1, #1
  000e4	e5903000	 ldr         r3, [r0]
  000e8	e5933004	 ldr         r3, [r3, #4]
  000ec	e1a0e00f	 mov         lr, pc
  000f0	e12fff13	 bx          r3

; 1537 : 
; 1538 :                 m_dwbTypeConnector = 0;
; 1539 : 
; 1540 :                 dwStatus = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCTSTR) REG_USBFN_DRV_PATH, 0, KEY_ALL_ACCESS, &hkDevice);

  000f4	e59f1328	 ldr         r1, [pc, #0x328]
  000f8	e3a0380f	 mov         r3, #0xF, 16
  000fc	e28de008	 add         lr, sp, #8
  00100	e383303f	 orr         r3, r3, #0x3F
  00104	e3a02000	 mov         r2, #0
  00108	e3a0010a	 mov         r0, #0xA, 2
  0010c	e58de000	 str         lr, [sp]
  00110	e5846198	 str         r6, [r4, #0x198]
  00114	eb000000	 bl          RegOpenKeyExW
  00118	e3500000	 cmp         r0, #0

; 1541 :                 if(dwStatus != ERROR_SUCCESS)

  0011c	1a0000b9	 bne         |$cleanUp$41145|

; 1542 :                 {
; 1543 :                     DEBUGMSG(ZONE_OTG_INFO, (_T("UfnPdd_Init: OpenDeviceKey('%s') failed %u\r\n"), REG_USBFN_DRV_PATH, dwStatus));
; 1544 :                     goto cleanUp;
; 1545 :                 }
; 1546 : 
; 1547 :                 dwType = REG_DWORD;
; 1548 :                 dwSize = sizeof(m_dwbTypeConnector);
; 1549 :                 dwStatus = ::RegSetValueEx(hkDevice, REG_VBUS_CHARGE_B_TYPE_CONNECTOR, NULL, dwType, 
; 1550 :                     (LPBYTE) &m_dwbTypeConnector, dwSize);

  00120	e59f12f8	 ldr         r1, [pc, #0x2F8]
  00124	e59d0008	 ldr         r0, [sp, #8]
  00128	e3a05004	 mov         r5, #4
  0012c	e284ef66	 add         lr, r4, #0x66, 30
  00130	e3a03004	 mov         r3, #4
  00134	e3a02000	 mov         r2, #0
  00138	e58d5004	 str         r5, [sp, #4]
  0013c	e58de000	 str         lr, [sp]
  00140	eb000000	 bl          RegSetValueExW
  00144	e3500000	 cmp         r0, #0

; 1556 :                     goto cleanUp;
; 1557 :                 }
; 1558 :                 RegCloseKey(hkDevice);

  00148	e59d0008	 ldr         r0, [sp, #8]
  0014c	1a00000d	 bne         |$LN23@OTG_Config@2|
  00150	eb000000	 bl          RegCloseKey

; 1559 : 
; 1560 :                 if (m_pOTG->pFuncs[DEVICE_MODE-1] != NULL)

  00154	e5940150	 ldr         r0, [r4, #0x150]
  00158	e5903008	 ldr         r3, [r0, #8]
  0015c	e3530000	 cmp         r3, #0

; 1561 :                     m_pOTG->pFuncs[DEVICE_MODE-1]->Disconnect((void *)m_pOTG);

  00160	15933018	 ldrne       r3, [r3, #0x18]
  00164	11a0e00f	 movne       lr, pc
  00168	112fff13	 bxne        r3

; 1562 :                 SoftResetMUSBController();

  0016c	e5943000	 ldr         r3, [r4]
  00170	e3a01000	 mov         r1, #0
  00174	e1a00004	 mov         r0, r4
  00178	e59330f8	 ldr         r3, [r3, #0xF8]
  0017c	e1a0e00f	 mov         lr, pc
  00180	e12fff13	 bx          r3
  00184	ea000016	 b           |$LN19@OTG_Config@2|
  00188		 |$LN23@OTG_Config@2|

; 1551 :                 if(dwStatus != ERROR_SUCCESS || dwType != REG_DWORD)
; 1552 :                 {
; 1553 :                     DEBUGMSG(ZONE_OTG_INFO, (_T("UFNPDD_Init: RegQueryValueEx('%s', '%s') failed %u\r\n"),
; 1554 :                         REG_USBFN_DRV_PATH, REG_VBUS_CHARGE_B_TYPE_CONNECTOR, dwStatus));
; 1555 :                     RegCloseKey(hkDevice);

  00188	eb000000	 bl          RegCloseKey

; 1677 : 
; 1678 :     }
; 1679 : cleanUp:

  0018c	ea00009d	 b           |$cleanUp$41145|
  00190		 |$LN27@OTG_Config@2|

; 1563 : 
; 1564 :             }
; 1565 :             else if (dwCurMode == HOST_MODE)

  00190	e3550002	 cmp         r5, #2
  00194	1a000012	 bne         |$LN19@OTG_Config@2|

; 1566 :             {
; 1567 :                 if (m_pOTG->pFuncs[HOST_MODE-1] != NULL)

  00198	e5940150	 ldr         r0, [r4, #0x150]
  0019c	e590300c	 ldr         r3, [r0, #0xC]
  001a0	e3530000	 cmp         r3, #0

; 1568 :                     m_pOTG->pFuncs[HOST_MODE-1]->Disconnect((void *)m_pOTG);         

  001a4	15933018	 ldrne       r3, [r3, #0x18]
  001a8	11a0e00f	 movne       lr, pc
  001ac	112fff13	 bxne        r3

; 1569 : 
; 1570 :                 SessionRequest(FALSE, FALSE);

  001b0	e5943000	 ldr         r3, [r4]
  001b4	e3a02000	 mov         r2, #0
  001b8	e3a01000	 mov         r1, #0
  001bc	e5933084	 ldr         r3, [r3, #0x84]
  001c0	e1a00004	 mov         r0, r4
  001c4	e1a0e00f	 mov         lr, pc
  001c8	e12fff13	 bx          r3

; 1571 :                 SoftResetMUSBController();

  001cc	e5943000	 ldr         r3, [r4]
  001d0	e3a01000	 mov         r1, #0
  001d4	e1a00004	 mov         r0, r4
  001d8	e59330f8	 ldr         r3, [r3, #0xF8]
  001dc	e1a0e00f	 mov         lr, pc
  001e0	e12fff13	 bx          r3
  001e4		 |$LN19@OTG_Config@2|

; 1572 : 
; 1573 :             } 
; 1574 :         }
; 1575 : 
; 1576 :         DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Disconnect with Sess = 0x%x\r\n"),INREG8(&m_pOTG->pUsbGenRegs->DevCtl)));            
; 1577 :         DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Disconnect with Pwr = 0x%x\r\n"), INREG8(&m_pOTG->pUsbGenRegs->Power)));
; 1578 :         DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Disconnect with connect_status=0x%x\r\n"), INREG8(&m_pOTG->connect_status)));
; 1579 : 
; 1580 :         // disable suspend interrupt as needed
; 1581 :         if (!m_pTransceiver->SupportsTransceiverWakeWithoutClock())

  001e4	e59400fc	 ldr         r0, [r4, #0xFC]
  001e8	e5903000	 ldr         r3, [r0]
  001ec	e5933014	 ldr         r3, [r3, #0x14]
  001f0	e1a0e00f	 mov         lr, pc
  001f4	e12fff13	 bx          r3
  001f8	e3500000	 cmp         r0, #0

; 1582 :             CLRREG8(&m_pOTG->pUsbGenRegs->IntrUSBE, INTRUSB_SUSPEND);  

  001fc	05943150	 ldreq       r3, [r4, #0x150]
  00200	05932020	 ldreq       r2, [r3, #0x20]
  00204	05d2300b	 ldreqb      r3, [r2, #0xB]
  00208	020330fe	 andeq       r3, r3, #0xFE
  0020c	05c2300b	 streqb      r3, [r2, #0xB]
  00210		 |$LN17@OTG_Config@2|

; 1583 :     }
; 1584 : 
; 1585 :     // Step 3: Handling of suspend
; 1586 :     if ((m_pOTG->intr_usb & INTRUSB_SUSPEND) == INTRUSB_SUSPEND)

  00210	e5942150	 ldr         r2, [r4, #0x150]
  00214	e5d23034	 ldrb        r3, [r2, #0x34]
  00218	e2033001	 and         r3, r3, #1
  0021c	e3530001	 cmp         r3, #1
  00220	1a000078	 bne         |$cleanUp$41145|

; 1587 :     {
; 1588 :         DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Suspend detected with DevCtl = 0x%x\r\n"), INREG8(&m_pOTG->pUsbGenRegs->DevCtl)));
; 1589 :         DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Suspend detected with Power = 0x%x\r\n"), INREG8(&m_pOTG->pUsbGenRegs->Power)));
; 1590 :         DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Suspend detected with Intr_USB = 0x%x\r\n"), m_pOTG->intr_usb));
; 1591 : 
; 1592 :         if ((m_pOTG->operateMode == DEVICE_MODE) && (m_pOTG->deviceType == A_DEVICE))

  00224	e5d21035	 ldrb        r1, [r2, #0x35]
  00228	e3510001	 cmp         r1, #1
  0022c	1a00006a	 bne         |$LN2@OTG_Config@2|
  00230	e5d23036	 ldrb        r3, [r2, #0x36]
  00234	e3530000	 cmp         r3, #0
  00238	1a000027	 bne         |$LN15@OTG_Config@2|

; 1593 :         {
; 1594 :             DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("################ DEBUG THIS, IT IS DEVICE MODE using A_DEVICE\r\n")));
; 1595 :             DWORD dwPrevState;
; 1596 :             RETAILMSG(1, (TEXT("A_DEVICE:HNP switching and need to disconnect device mode\r\n")));

  0023c	e59f01d8	 ldr         r0, [pc, #0x1D8]
  00240	eb000000	 bl          NKDbgPrintfW

; 1597 :             m_dwStatus |= STATUS_DISCONN_COMPLETE;
; 1598 :             m_dwStatus &= ~STATUS_WAIT_HOST_DISCONN_COMPLETE;

  00244	e59430f8	 ldr         r3, [r4, #0xF8]

; 1599 :             //DEBUGMSG(1, (TEXT("operateMode = IDLE (suspend device)\r\n")));
; 1600 :             m_pOTG->operateMode = IDLE_MODE;

  00248	e5942150	 ldr         r2, [r4, #0x150]
  0024c	e3c33040	 bic         r3, r3, #0x40
  00250	e3833008	 orr         r3, r3, #8
  00254	e58430f8	 str         r3, [r4, #0xF8]
  00258	e5c26035	 strb        r6, [r2, #0x35]

; 1601 :             m_pOTG->connect_status |= CONN_DC;

  0025c	e5942150	 ldr         r2, [r4, #0x150]
  00260	e5d2304c	 ldrb        r3, [r2, #0x4C]
  00264	e3833004	 orr         r3, r3, #4
  00268	e5c2304c	 strb        r3, [r2, #0x4C]

; 1602 :             dwPrevState = m_pOTG->connect_status;

  0026c	e5942150	 ldr         r2, [r4, #0x150]
  00270	e5d2104c	 ldrb        r1, [r2, #0x4C]

; 1603 :             m_pOTG->connect_status &= ~CONN_CCS;

  00274	e20130fe	 and         r3, r1, #0xFE
  00278	e5c2304c	 strb        r3, [r2, #0x4C]

; 1604 :             if (dwPrevState & CONN_CCS) 
; 1605 :                 m_pOTG->connect_status |= CONN_CSC;

  0027c	e5942150	 ldr         r2, [r4, #0x150]
  00280	e3110001	 tst         r1, #1
  00284	e5d2304c	 ldrb        r3, [r2, #0x4C]
  00288	13833002	 orrne       r3, r3, #2

; 1606 :             else
; 1607 :                 m_pOTG->connect_status &= ~CONN_CSC;

  0028c	020330fd	 andeq       r3, r3, #0xFD
  00290	e5c2304c	 strb        r3, [r2, #0x4C]

; 1608 : 
; 1609 :             if (m_pOTG->pFuncs[DEVICE_MODE-1] != NULL)

  00294	e5940150	 ldr         r0, [r4, #0x150]
  00298	e5903008	 ldr         r3, [r0, #8]
  0029c	e3530000	 cmp         r3, #0

; 1610 :                 m_pOTG->pFuncs[DEVICE_MODE-1]->Disconnect((void *)m_pOTG);     

  002a0	15933018	 ldrne       r3, [r3, #0x18]
  002a4	11a0e00f	 movne       lr, pc
  002a8	112fff13	 bxne        r3

; 1611 :             
; 1612 :             ResetEndPoints();

  002ac	e5943000	 ldr         r3, [r4]
  002b0	e1a00004	 mov         r0, r4
  002b4	e59330ec	 ldr         r3, [r3, #0xEC]
  002b8	e1a0e00f	 mov         lr, pc
  002bc	e12fff13	 bx          r3
  002c0		 |$LN49@OTG_Config@2|

; 1613 :             // clear any disconnect interrupt
; 1614 :             m_pOTG->intr_usb &= ~INTRUSB_DISCONN;           

  002c0	e5942150	 ldr         r2, [r4, #0x150]
  002c4	e5d23034	 ldrb        r3, [r2, #0x34]
  002c8	e20330df	 and         r3, r3, #0xDF
  002cc	e5c23034	 strb        r3, [r2, #0x34]

; 1615 :             m_dwStatus |= STATUS_SESSION_RESTART | STATUS_SUSPEND;

  002d0	e59430f8	 ldr         r3, [r4, #0xF8]
  002d4	e3833084	 orr         r3, r3, #0x84
  002d8	ea00003e	 b           |$LN47@OTG_Config@2|
  002dc		 |$LN15@OTG_Config@2|

; 1616 :         }
; 1617 :         else if ((m_pOTG->operateMode == DEVICE_MODE) && (m_pOTG->deviceType == B_DEVICE))

  002dc	e3510001	 cmp         r1, #1
  002e0	1a00003d	 bne         |$LN2@OTG_Config@2|
  002e4	e5d23036	 ldrb        r3, [r2, #0x36]
  002e8	e3530001	 cmp         r3, #1
  002ec	1a00002e	 bne         |$LN10@OTG_Config@2|

; 1618 :         {
; 1619 :             DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("################ DEBUG THIS, IT IS DEVICE MODE using A_DEVICE\r\n")));
; 1620 :          
; 1621 :             BYTE devctl = 0, vbuslevel;
; 1622 : 
; 1623 :             devctl = INREG8(&m_pOTG->pUsbGenRegs->DevCtl);

  002f0	e5922020	 ldr         r2, [r2, #0x20]
  002f4	e5d23060	 ldrb        r3, [r2, #0x60]

; 1624 :             vbuslevel = devctl & DEVCTL_VBUS;

  002f8	e2033018	 and         r3, r3, #0x18

; 1625 :             if(vbuslevel != DEVCTL_VBUSVALID)

  002fc	e3530018	 cmp         r3, #0x18

; 1626 :             {
; 1627 :                m_dwStatus |= STATUS_SUSPEND;

  00300	159430f8	 ldrne       r3, [r4, #0xF8]

; 1628 :                return STATUS_SUSPEND;

  00304	13a00004	 movne       r0, #4
  00308	13833004	 orrne       r3, r3, #4
  0030c	158430f8	 strne       r3, [r4, #0xF8]
  00310	1a00003d	 bne         |$LN36@OTG_Config@2|

; 1629 :             }
; 1630 : 
; 1631 :             if(m_bHNPEnable)

  00314	e594316c	 ldr         r3, [r4, #0x16C]
  00318	e3530000	 cmp         r3, #0
  0031c	0a00002e	 beq         |$LN2@OTG_Config@2|

; 1632 :             {
; 1633 :                 DWORD dwPrevState;
; 1634 :                 RETAILMSG(1, (TEXT("B_DEVICE:HNP switching and need to disconnect device mode DevCtl:%x\r\n"),INREG8(&m_pOTG->pUsbGenRegs->DevCtl)));

  00320	e5d21060	 ldrb        r1, [r2, #0x60]
  00324	e59f00ec	 ldr         r0, [pc, #0xEC]
  00328	eb000000	 bl          NKDbgPrintfW

; 1635 : 
; 1636 :                 m_dwStatus |= STATUS_DISCONN_COMPLETE;
; 1637 :                 m_dwStatus &= ~STATUS_WAIT_HOST_DISCONN_COMPLETE;

  0032c	e59430f8	 ldr         r3, [r4, #0xF8]

; 1638 :                 m_pOTG->operateMode = IDLE_MODE;

  00330	e5942150	 ldr         r2, [r4, #0x150]
  00334	e3c33040	 bic         r3, r3, #0x40
  00338	e3833008	 orr         r3, r3, #8
  0033c	e58430f8	 str         r3, [r4, #0xF8]
  00340	e5c26035	 strb        r6, [r2, #0x35]

; 1639 :                 m_pOTG->connect_status |= CONN_DC;

  00344	e5942150	 ldr         r2, [r4, #0x150]
  00348	e5d2304c	 ldrb        r3, [r2, #0x4C]
  0034c	e3833004	 orr         r3, r3, #4
  00350	e5c2304c	 strb        r3, [r2, #0x4C]

; 1640 :                 dwPrevState = m_pOTG->connect_status;

  00354	e5942150	 ldr         r2, [r4, #0x150]
  00358	e5d2104c	 ldrb        r1, [r2, #0x4C]

; 1641 :                 m_pOTG->connect_status &= ~CONN_CCS;

  0035c	e20130fe	 and         r3, r1, #0xFE
  00360	e5c2304c	 strb        r3, [r2, #0x4C]

; 1642 :                 if (dwPrevState & CONN_CCS)
; 1643 :                     m_pOTG->connect_status |= CONN_CSC;

  00364	e5942150	 ldr         r2, [r4, #0x150]
  00368	e3110001	 tst         r1, #1
  0036c	e5d2304c	 ldrb        r3, [r2, #0x4C]
  00370	13833002	 orrne       r3, r3, #2

; 1644 :                 else
; 1645 :                     m_pOTG->connect_status &= ~CONN_CSC;

  00374	020330fd	 andeq       r3, r3, #0xFD
  00378	e5c2304c	 strb        r3, [r2, #0x4C]

; 1646 : 
; 1647 :                 if (m_pOTG->pFuncs[DEVICE_MODE-1] != NULL)

  0037c	e5940150	 ldr         r0, [r4, #0x150]
  00380	e5903008	 ldr         r3, [r0, #8]
  00384	e3530000	 cmp         r3, #0

; 1648 :                     m_pOTG->pFuncs[DEVICE_MODE-1]->Disconnect((void *)m_pOTG);

  00388	15933018	 ldrne       r3, [r3, #0x18]
  0038c	11a0e00f	 movne       lr, pc
  00390	112fff13	 bxne        r3

; 1649 : 
; 1650 :                 ResetEndPoints();

  00394	e5943000	 ldr         r3, [r4]
  00398	e1a00004	 mov         r0, r4
  0039c	e59330ec	 ldr         r3, [r3, #0xEC]
  003a0	e1a0e00f	 mov         lr, pc
  003a4	e12fff13	 bx          r3

; 1651 : 
; 1652 :                 // clear any disconnect interrupt
; 1653 :                 m_pOTG->intr_usb &= ~INTRUSB_DISCONN;
; 1654 :                 m_dwStatus |= STATUS_SESSION_RESTART | STATUS_SUSPEND;
; 1655 : 
; 1656 :             }
; 1657 :             else
; 1658 :             {
; 1659 :                 // To Do...
; 1660 :                 // Stop the USB clocks and trigger on a USB wakeup interrupt.
; 1661 :                 // ensure we are not charging the battery via the USB port
; 1662 : 
; 1663 :                 // for now... do not set STATUS_SUSPEND, because this will force a reset
; 1664 :             }

  003a8	eaffffc4	 b           |$LN49@OTG_Config@2|
  003ac		 |$LN10@OTG_Config@2|

; 1665 :         }
; 1666 :         else if(m_pOTG->operateMode == DEVICE_MODE)

  003ac	e3510001	 cmp         r1, #1
  003b0	1a000009	 bne         |$LN2@OTG_Config@2|

; 1667 :         {
; 1668 :              // ??? unreachable code, what was intended?
; 1669 :              SessionRequest(FALSE, FALSE);

  003b4	e5943000	 ldr         r3, [r4]
  003b8	e3a02000	 mov         r2, #0
  003bc	e3a01000	 mov         r1, #0
  003c0	e5933084	 ldr         r3, [r3, #0x84]
  003c4	e1a00004	 mov         r0, r4
  003c8	e1a0e00f	 mov         lr, pc
  003cc	e12fff13	 bx          r3

; 1670 :              //m_disconnected = FALSE;
; 1671 :             m_dwStatus |= STATUS_SUSPEND;

  003d0	e59430f8	 ldr         r3, [r4, #0xF8]
  003d4	e3833004	 orr         r3, r3, #4
  003d8		 |$LN47@OTG_Config@2|
  003d8	e58430f8	 str         r3, [r4, #0xF8]
  003dc		 |$LN2@OTG_Config@2|

; 1672 :         }
; 1673 : 
; 1674 :         // disable suspend interrupt as needed
; 1675 :         if (!m_pTransceiver->SupportsTransceiverWakeWithoutClock())

  003dc	e59400fc	 ldr         r0, [r4, #0xFC]
  003e0	e5903000	 ldr         r3, [r0]
  003e4	e5933014	 ldr         r3, [r3, #0x14]
  003e8	e1a0e00f	 mov         lr, pc
  003ec	e12fff13	 bx          r3
  003f0	e3500000	 cmp         r0, #0

; 1676 :             CLRREG8(&m_pOTG->pUsbGenRegs->IntrUSBE, INTRUSB_SUSPEND);  

  003f4	05943150	 ldreq       r3, [r4, #0x150]
  003f8	05932020	 ldreq       r2, [r3, #0x20]
  003fc	05d2300b	 ldreqb      r3, [r2, #0xB]
  00400	020330fe	 andeq       r3, r3, #0xFE
  00404	05c2300b	 streqb      r3, [r2, #0xB]
  00408		 |$cleanUp$41145|

; 1680 :     return m_dwStatus;

  00408	e59400f8	 ldr         r0, [r4, #0xF8]
  0040c		 |$LN36@OTG_Config@2|

; 1681 : }

  0040c	e28dd00c	 add         sp, sp, #0xC
  00410	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00414	e12fff1e	 bx          lr
  00418		 |$LN54@OTG_Config@2|
  00418		 |$LN55@OTG_Config@2|
  00418	00000000	 DCD         |??_C@_1IM@GEPODNBC@?$AAB?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA?3?$AAH?$AAN?$AAP?$AA?5?$AAs?$AAw?$AAi?$AAt?$AAc?$AAh?$AAi?$AAn?$AAg?$AA?5?$AAa?$AAn?$AAd?$AA?5?$AAn?$AAe?$AAe?$AAd?$AA?5@|
  0041c		 |$LN56@OTG_Config@2|
  0041c	00000000	 DCD         |??_C@_1HI@JBKOMFKI@?$AAA?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA?3?$AAH?$AAN?$AAP?$AA?5?$AAs?$AAw?$AAi?$AAt?$AAc?$AAh?$AAi?$AAn?$AAg?$AA?5?$AAa?$AAn?$AAd?$AA?5?$AAn?$AAe?$AAe?$AAd?$AA?5@|
  00420		 |$LN57@OTG_Config@2|
  00420	00000000	 DCD         |??_C@_1M@CKAHONI@?$AAB?$AAT?$AAY?$AAP?$AAE?$AA?$AA@|
  00424		 |$LN58@OTG_Config@2|
  00424	00000000	 DCD         |??_C@_1DM@GBENJPGN@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAB?$AAu?$AAi?$AAl?$AAt?$AAI?$AAn?$AA?2?$AAM?$AAU?$AAS?$AAB?$AAO?$AAT?$AAG?$AA?2?$AAU?$AAS?$AAB?$AAF?$AAN?$AA?$AA@|
  00428		 |$M43928|

			 ENDP  ; |?OTG_ConfigISR_stage2@OMAPMHSUSBOTG@@UAAKXZ|, OMAPMHSUSBOTG::OTG_ConfigISR_stage2

	EXPORT	|?LinkRecoveryProcedure1@OMAPMHSUSBOTG@@QAAHXZ| ; OMAPMHSUSBOTG::LinkRecoveryProcedure1
	EXPORT	|??_C@_1CO@DLKKJIDB@?$AAR?$AAe?$AAs?$AAt?$AAo?$AAr?$AAe?$AA?5?$AAU?$AAL?$AAP?$AAI?$AA?5?$AAS?$AAi?$AAg?$AAn?$AAa?$AAl?$AAs?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DM@PAEGICHA@?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AA?5?$AAU?$AAL?$AAP?$AAI?$AA?5?$AAs?$AAi?$AAg?$AAn?$AAa?$AAl?$AAs?$AA?5?$AAt?$AAo?$AA?5?$AAG?$AAP?$AAI?$AAO?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|GPIOClose|
	IMPORT	|GPIOClrBit|
	IMPORT	|GPIOSetBit|
	IMPORT	|GPIOSetMode|
	IMPORT	|GPIOOpen|

  00000			 AREA	 |.pdata|, PDATA
|$T43974| DCD	|$LN24@LinkRecove|
	DCD	0x40008c01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CO@DLKKJIDB@?$AAR?$AAe?$AAs?$AAt?$AAo?$AAr?$AAe?$AA?5?$AAU?$AAL?$AAP?$AAI?$AA?5?$AAS?$AAi?$AAg?$AAn?$AAa?$AAl?$AAs?$AA?$AN?$AA?6?$AA?$AA@| DCB "R"
	DCB	0x0, "e", 0x0, "s", 0x0, "t", 0x0, "o", 0x0, "r", 0x0, "e"
	DCB	0x0, " ", 0x0, "U", 0x0, "L", 0x0, "P", 0x0, "I", 0x0, " "
	DCB	0x0, "S", 0x0, "i", 0x0, "g", 0x0, "n", 0x0, "a", 0x0, "l"
	DCB	0x0, "s", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DM@PAEGICHA@?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AA?5?$AAU?$AAL?$AAP?$AAI?$AA?5?$AAs?$AAi?$AAg?$AAn?$AAa?$AAl?$AAs?$AA?5?$AAt?$AAo?$AA?5?$AAG?$AAP?$AAI?$AAO?$AA?$AN?$AA?6?$AA?$AA@| DCB "A"
	DCB	0x0, "s", 0x0, "s", 0x0, "i", 0x0, "g", 0x0, "n", 0x0, " "
	DCB	0x0, "U", 0x0, "L", 0x0, "P", 0x0, "I", 0x0, " ", 0x0, "s"
	DCB	0x0, "i", 0x0, "g", 0x0, "n", 0x0, "a", 0x0, "l", 0x0, "s"
	DCB	0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "G", 0x0, "P"
	DCB	0x0, "I", 0x0, "O", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?LinkRecoveryProcedure1@OMAPMHSUSBOTG@@QAAHXZ| PROC ; OMAPMHSUSBOTG::LinkRecoveryProcedure1

; 2502 : {

  00000		 |$LN24@LinkRecove|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M43971|
  00004	e1a06000	 mov         r6, r0

; 2503 :     OMAP_SYSC_PADCONFS_REGS   *pConfig=NULL;
; 2504 :     HANDLE hGpio=NULL;
; 2505 :     BOOL ret = FALSE;
; 2506 : 
; 2507 :     pConfig = (OMAP_SYSC_PADCONFS_REGS*)m_pOTG->pPadControlRegs;

  00008	e5963150	 ldr         r3, [r6, #0x150]
  0000c	e3a07000	 mov         r7, #0
  00010	e5934028	 ldr         r4, [r3, #0x28]

; 2508 :     hGpio = GPIOOpen();

  00014	eb000000	 bl          GPIOOpen
  00018	e1a05000	 mov         r5, r0

; 2509 : 
; 2510 :     RETAILMSG(1, (TEXT("Assign ULPI signals to GPIO\r\n")));

  0001c	e59f0208	 ldr         r0, [pc, #0x208]
  00020	eb000000	 bl          NKDbgPrintfW

; 2511 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_STP, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4));          /*HSUSB0_STP*/
; 2512 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA0, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4));        /*HSUSB0_DATA0*/

  00024	e2849f5d	 add         r9, r4, #0x5D, 30
  00028	e3a01004	 mov         r1, #4
  0002c	e2848c01	 add         r8, r4, #1, 24

; 2513 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA1, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4));        /*HSUSB0_DATA1*/
; 2514 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA2, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4));        /*HSUSB0_DATA2*/

  00030	e1c910b0	 strh        r1, [r9]
  00034	e284bf5f	 add         r11, r4, #0x5F, 30
  00038	e1c817ba	 strh        r1, [r8, #0x7A]
  0003c	e284ac01	 add         r10, r4, #1, 24
  00040	e1cb10b0	 strh        r1, [r11]

; 2515 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA3, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4));        /*HSUSB0_DATA3*/
; 2516 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA4, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4));        /*HSUSB0_DATA4*/

  00044	e2842d06	 add         r2, r4, #6, 26
  00048	e1ca17be	 strh        r1, [r10, #0x7E]
  0004c	e2843c01	 add         r3, r4, #1, 24
  00050	e1c210b0	 strh        r1, [r2]

; 2517 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA5, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4));        /*HSUSB0_DATA5*/
; 2518 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA6, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4));        /*HSUSB0_DATA6*/

  00054	e1c318b2	 strh        r1, [r3, #0x82]
  00058	e2843f61	 add         r3, r4, #0x61, 30
  0005c	e1c310b0	 strh        r1, [r3]
  00060	e2842c01	 add         r2, r4, #1, 24

; 2519 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA7, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4));        /*HSUSB0_DATA7*/

  00064	e2843f62	 add         r3, r4, #0x62, 30
  00068	e1c218b6	 strh        r1, [r2, #0x86]
  0006c	e1c310b0	 strh        r1, [r3]

; 2520 : 
; 2521 :     // Do the recover stuff here!
; 2522 :     GPIOSetMode(hGpio, 121, GPIO_DIR_OUTPUT); // STP

  00070	e3a01079	 mov         r1, #0x79
  00074	e3a02000	 mov         r2, #0
  00078	e1a00005	 mov         r0, r5
  0007c	eb000000	 bl          GPIOSetMode

; 2523 :     GPIOSetMode(hGpio, 125, GPIO_DIR_OUTPUT); // D0

  00080	e3a02000	 mov         r2, #0
  00084	e3a0107d	 mov         r1, #0x7D
  00088	e1a00005	 mov         r0, r5
  0008c	eb000000	 bl          GPIOSetMode

; 2524 :     GPIOSetMode(hGpio, 130, GPIO_DIR_OUTPUT); // D1

  00090	e3a02000	 mov         r2, #0
  00094	e3a01082	 mov         r1, #0x82
  00098	e1a00005	 mov         r0, r5
  0009c	eb000000	 bl          GPIOSetMode

; 2525 :     GPIOSetMode(hGpio, 131, GPIO_DIR_OUTPUT); // D2

  000a0	e3a02000	 mov         r2, #0
  000a4	e3a01083	 mov         r1, #0x83
  000a8	e1a00005	 mov         r0, r5
  000ac	eb000000	 bl          GPIOSetMode

; 2526 :     GPIOSetMode(hGpio, 169, GPIO_DIR_OUTPUT); // D3

  000b0	e3a02000	 mov         r2, #0
  000b4	e3a010a9	 mov         r1, #0xA9
  000b8	e1a00005	 mov         r0, r5
  000bc	eb000000	 bl          GPIOSetMode

; 2527 :     GPIOSetMode(hGpio, 188, GPIO_DIR_OUTPUT); // D4

  000c0	e3a02000	 mov         r2, #0
  000c4	e3a010bc	 mov         r1, #0xBC
  000c8	e1a00005	 mov         r0, r5
  000cc	eb000000	 bl          GPIOSetMode

; 2528 :     GPIOSetMode(hGpio, 189, GPIO_DIR_OUTPUT); // D5

  000d0	e3a02000	 mov         r2, #0
  000d4	e3a010bd	 mov         r1, #0xBD
  000d8	e1a00005	 mov         r0, r5
  000dc	eb000000	 bl          GPIOSetMode

; 2529 :     GPIOSetMode(hGpio, 190, GPIO_DIR_OUTPUT); // D6

  000e0	e3a02000	 mov         r2, #0
  000e4	e3a010be	 mov         r1, #0xBE
  000e8	e1a00005	 mov         r0, r5
  000ec	eb000000	 bl          GPIOSetMode

; 2530 :     GPIOSetMode(hGpio, 191, GPIO_DIR_OUTPUT); // D7

  000f0	e3a02000	 mov         r2, #0
  000f4	e3a010bf	 mov         r1, #0xBF
  000f8	e1a00005	 mov         r0, r5
  000fc	eb000000	 bl          GPIOSetMode

; 2531 : 
; 2532 :     // Attempt recovery procedure 1
; 2533 :     //RETAILMSG(1, (TEXT("Attempt Recovery Procedure 1\r\n")));
; 2534 : 
; 2535 :     GPIOSetBit(hGpio, 121); // Set   STP

  00100	e3a01079	 mov         r1, #0x79
  00104	e1a00005	 mov         r0, r5
  00108	eb000000	 bl          GPIOSetBit

; 2536 :     GPIOSetBit(hGpio, 190); // Set   D6

  0010c	e3a010be	 mov         r1, #0xBE
  00110	e1a00005	 mov         r0, r5
  00114	eb000000	 bl          GPIOSetBit

; 2537 :     GPIOClrBit(hGpio, 191); // Clear D7

  00118	e3a010bf	 mov         r1, #0xBF
  0011c	e1a00005	 mov         r0, r5
  00120	eb000000	 bl          GPIOClrBit

; 2538 :     GPIOClrBit(hGpio, 125); // Clear D0

  00124	e3a0107d	 mov         r1, #0x7D
  00128	e1a00005	 mov         r0, r5
  0012c	eb000000	 bl          GPIOClrBit

; 2539 :     GPIOClrBit(hGpio, 130); // Clear D1

  00130	e3a01082	 mov         r1, #0x82
  00134	e1a00005	 mov         r0, r5
  00138	eb000000	 bl          GPIOClrBit

; 2540 :     GPIOClrBit(hGpio, 131); // Clear D2

  0013c	e3a01083	 mov         r1, #0x83
  00140	e1a00005	 mov         r0, r5
  00144	eb000000	 bl          GPIOClrBit

; 2541 :     GPIOClrBit(hGpio, 169); // Clear D3

  00148	e3a010a9	 mov         r1, #0xA9
  0014c	e1a00005	 mov         r0, r5
  00150	eb000000	 bl          GPIOClrBit

; 2542 :     GPIOClrBit(hGpio, 188); // Clear D4

  00154	e3a010bc	 mov         r1, #0xBC
  00158	e1a00005	 mov         r0, r5
  0015c	eb000000	 bl          GPIOClrBit

; 2543 :     GPIOClrBit(hGpio, 189); // Clear D5

  00160	e3a010bd	 mov         r1, #0xBD
  00164	e1a00005	 mov         r0, r5
  00168	eb000000	 bl          GPIOClrBit

; 2544 : 
; 2545 :     DelayByRegisterRead();

  0016c	e5963150	 ldr         r3, [r6, #0x150]
  00170	e3a0200c	 mov         r2, #0xC
  00174	e5931018	 ldr         r1, [r3, #0x18]
  00178		 |$LL10@LinkRecove|
  00178	e5913000	 ldr         r3, [r1]
  0017c	e2522001	 subs        r2, r2, #1
  00180	1afffffc	 bne         |$LL10@LinkRecove|

; 2546 : 
; 2547 :     GPIOClrBit(hGpio, 190); // Clear D6

  00184	e3a010be	 mov         r1, #0xBE
  00188	e1a00005	 mov         r0, r5
  0018c	eb000000	 bl          GPIOClrBit

; 2548 :     DelayByRegisterRead();

  00190	e5963150	 ldr         r3, [r6, #0x150]
  00194	e3a0200c	 mov         r2, #0xC
  00198	e5931018	 ldr         r1, [r3, #0x18]
  0019c		 |$LL15@LinkRecove|
  0019c	e5913000	 ldr         r3, [r1]
  001a0	e2522001	 subs        r2, r2, #1
  001a4	1afffffc	 bne         |$LL15@LinkRecove|

; 2549 :     GPIOClrBit(hGpio, 121); // Clear STP

  001a8	e3a01079	 mov         r1, #0x79
  001ac	e1a00005	 mov         r0, r5
  001b0	eb000000	 bl          GPIOClrBit

; 2550 : 
; 2551 :     GPIOClose(hGpio);

  001b4	e1a00005	 mov         r0, r5
  001b8	eb000000	 bl          GPIOClose

; 2552 : 
; 2553 :     RETAILMSG(1, (TEXT("Restore ULPI Signals\r\n")));

  001bc	e59f0064	 ldr         r0, [pc, #0x64]
  001c0	eb000000	 bl          NKDbgPrintfW

; 2554 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_STP, (OFF_OUTPUT_PULL_INACTIVE | INPUT_DISABLE | PULL_UP | MUX_MODE_0));          /*HSUSB0_STP*/

  001c4	e3a03f86	 mov         r3, #0x86, 30

; 2555 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA0, (OFF_INPUT_PULL_DOWN | INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0));        /*HSUSB0_DATA0*/

  001c8	e3a02c17	 mov         r2, #0x17, 24
  001cc	e1c930b0	 strh        r3, [r9]
  001d0	e1c827ba	 strh        r2, [r8, #0x7A]

; 2556 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA1, (OFF_INPUT_PULL_DOWN | INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0));        /*HSUSB0_DATA1*/

  001d4	e1cb20b0	 strh        r2, [r11]

; 2557 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA2, (OFF_INPUT_PULL_DOWN | INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0));        /*HSUSB0_DATA2*/
; 2558 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA3, (OFF_INPUT_PULL_DOWN | INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0));        /*HSUSB0_DATA3*/

  001d8	e2843d06	 add         r3, r4, #6, 26
  001dc	e1ca27be	 strh        r2, [r10, #0x7E]
  001e0	e1c320b0	 strh        r2, [r3]

; 2559 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA4, (OFF_INPUT_PULL_DOWN | INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0));        /*HSUSB0_DATA4*/

  001e4	e2843c01	 add         r3, r4, #1, 24
  001e8	e1c328b2	 strh        r2, [r3, #0x82]

; 2560 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA5, (OFF_INPUT_PULL_DOWN | INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0));        /*HSUSB0_DATA5*/

  001ec	e2843f61	 add         r3, r4, #0x61, 30
  001f0	e1c320b0	 strh        r2, [r3]

; 2561 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA6, (OFF_INPUT_PULL_DOWN | INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0));        /*HSUSB0_DATA6*/

  001f4	e2843c01	 add         r3, r4, #1, 24
  001f8	e1c328b6	 strh        r2, [r3, #0x86]

; 2562 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA7, (OFF_INPUT_PULL_DOWN | INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0));        /*HSUSB0_DATA7*/

  001fc	e2843f62	 add         r3, r4, #0x62, 30
  00200	e1c320b0	 strh        r2, [r3]

; 2563 : 
; 2564 :     if((ReadULPIReg( m_pOTG, ULPI_VENDORID_LOW_R)))

  00204	e5961150	 ldr         r1, [r6, #0x150]
  00208	e3a02000	 mov         r2, #0
  0020c	e1a00006	 mov         r0, r6
  00210	eb000000	 bl          |?ReadULPIReg@OMAPMHSUSBOTG@@QAAEPAUHSMUSB_T@@E@Z|
  00214	e3500000	 cmp         r0, #0

; 2565 :     {
; 2566 :         //RETAILMSG(1, (TEXT("Recovery Procedure 1. ULPI Link Functional\r\n")));
; 2567 :         ret = TRUE;

  00218	13a07001	 movne       r7, #1

; 2568 :     }
; 2569 : 
; 2570 :     return ret;
; 2571 : }

  0021c	e1a00007	 mov         r0, r7
  00220	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00224	e12fff1e	 bx          lr
  00228		 |$LN25@LinkRecove|
  00228		 |$LN26@LinkRecove|
  00228	00000000	 DCD         |??_C@_1CO@DLKKJIDB@?$AAR?$AAe?$AAs?$AAt?$AAo?$AAr?$AAe?$AA?5?$AAU?$AAL?$AAP?$AAI?$AA?5?$AAS?$AAi?$AAg?$AAn?$AAa?$AAl?$AAs?$AA?$AN?$AA?6?$AA?$AA@|
  0022c		 |$LN27@LinkRecove|
  0022c	00000000	 DCD         |??_C@_1DM@PAEGICHA@?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AA?5?$AAU?$AAL?$AAP?$AAI?$AA?5?$AAs?$AAi?$AAg?$AAn?$AAa?$AAl?$AAs?$AA?5?$AAt?$AAo?$AA?5?$AAG?$AAP?$AAI?$AAO?$AA?$AN?$AA?6?$AA?$AA@|
  00230		 |$M43972|

			 ENDP  ; |?LinkRecoveryProcedure1@OMAPMHSUSBOTG@@QAAHXZ|, OMAPMHSUSBOTG::LinkRecoveryProcedure1

	EXPORT	|?LinkRecoveryProcedure2@OMAPMHSUSBOTG@@QAAHXZ| ; OMAPMHSUSBOTG::LinkRecoveryProcedure2

  00000			 AREA	 |.pdata|, PDATA
|$T44027| DCD	|$LN31@LinkRecove@2|
	DCD	0x40009201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?LinkRecoveryProcedure2@OMAPMHSUSBOTG@@QAAHXZ| PROC ; OMAPMHSUSBOTG::LinkRecoveryProcedure2

; 2578 : {

  00000		 |$LN31@LinkRecove@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M44024|
  00004	e1a06000	 mov         r6, r0

; 2579 :     OMAP_SYSC_PADCONFS_REGS   *pConfig=NULL;
; 2580 :     HANDLE hGpio=NULL;
; 2581 :     BOOL ret = FALSE;
; 2582 : 
; 2583 :     pConfig = (OMAP_SYSC_PADCONFS_REGS*)m_pOTG->pPadControlRegs;

  00008	e5963150	 ldr         r3, [r6, #0x150]
  0000c	e3a07000	 mov         r7, #0
  00010	e5934028	 ldr         r4, [r3, #0x28]

; 2584 :     hGpio = GPIOOpen();

  00014	eb000000	 bl          GPIOOpen
  00018	e1a05000	 mov         r5, r0

; 2585 : 
; 2586 :     RETAILMSG(1, (TEXT("Assign ULPI signals to GPIO\r\n")));

  0001c	e59f0220	 ldr         r0, [pc, #0x220]
  00020	eb000000	 bl          NKDbgPrintfW

; 2587 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_STP, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4));          /*HSUSB0_STP*/
; 2588 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA0, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4));        /*HSUSB0_DATA0*/

  00024	e2849f5d	 add         r9, r4, #0x5D, 30
  00028	e3a01004	 mov         r1, #4
  0002c	e2848c01	 add         r8, r4, #1, 24

; 2589 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA1, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4));        /*HSUSB0_DATA1*/
; 2590 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA2, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4));        /*HSUSB0_DATA2*/

  00030	e1c910b0	 strh        r1, [r9]
  00034	e284bf5f	 add         r11, r4, #0x5F, 30
  00038	e1c817ba	 strh        r1, [r8, #0x7A]
  0003c	e284ac01	 add         r10, r4, #1, 24
  00040	e1cb10b0	 strh        r1, [r11]

; 2591 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA3, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4));        /*HSUSB0_DATA3*/
; 2592 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA4, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4));        /*HSUSB0_DATA4*/

  00044	e2842d06	 add         r2, r4, #6, 26
  00048	e1ca17be	 strh        r1, [r10, #0x7E]
  0004c	e2843c01	 add         r3, r4, #1, 24
  00050	e1c210b0	 strh        r1, [r2]

; 2593 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA5, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4));        /*HSUSB0_DATA5*/
; 2594 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA6, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4));        /*HSUSB0_DATA6*/

  00054	e1c318b2	 strh        r1, [r3, #0x82]
  00058	e2843f61	 add         r3, r4, #0x61, 30
  0005c	e1c310b0	 strh        r1, [r3]
  00060	e2842c01	 add         r2, r4, #1, 24

; 2595 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA7, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4));        /*HSUSB0_DATA7*/

  00064	e2843f62	 add         r3, r4, #0x62, 30
  00068	e1c218b6	 strh        r1, [r2, #0x86]
  0006c	e1c310b0	 strh        r1, [r3]

; 2596 : 
; 2597 :     // Do the recover stuff here!
; 2598 :     GPIOSetMode(hGpio, 121, GPIO_DIR_OUTPUT); // STP

  00070	e3a01079	 mov         r1, #0x79
  00074	e3a02000	 mov         r2, #0
  00078	e1a00005	 mov         r0, r5
  0007c	eb000000	 bl          GPIOSetMode

; 2599 :     GPIOSetMode(hGpio, 125, GPIO_DIR_OUTPUT); // D0

  00080	e3a02000	 mov         r2, #0
  00084	e3a0107d	 mov         r1, #0x7D
  00088	e1a00005	 mov         r0, r5
  0008c	eb000000	 bl          GPIOSetMode

; 2600 :     GPIOSetMode(hGpio, 130, GPIO_DIR_OUTPUT); // D1

  00090	e3a02000	 mov         r2, #0
  00094	e3a01082	 mov         r1, #0x82
  00098	e1a00005	 mov         r0, r5
  0009c	eb000000	 bl          GPIOSetMode

; 2601 :     GPIOSetMode(hGpio, 131, GPIO_DIR_OUTPUT); // D2

  000a0	e3a02000	 mov         r2, #0
  000a4	e3a01083	 mov         r1, #0x83
  000a8	e1a00005	 mov         r0, r5
  000ac	eb000000	 bl          GPIOSetMode

; 2602 :     GPIOSetMode(hGpio, 169, GPIO_DIR_OUTPUT); // D3

  000b0	e3a02000	 mov         r2, #0
  000b4	e3a010a9	 mov         r1, #0xA9
  000b8	e1a00005	 mov         r0, r5
  000bc	eb000000	 bl          GPIOSetMode

; 2603 :     GPIOSetMode(hGpio, 188, GPIO_DIR_OUTPUT); // D4

  000c0	e3a02000	 mov         r2, #0
  000c4	e3a010bc	 mov         r1, #0xBC
  000c8	e1a00005	 mov         r0, r5
  000cc	eb000000	 bl          GPIOSetMode

; 2604 :     GPIOSetMode(hGpio, 189, GPIO_DIR_OUTPUT); // D5

  000d0	e3a02000	 mov         r2, #0
  000d4	e3a010bd	 mov         r1, #0xBD
  000d8	e1a00005	 mov         r0, r5
  000dc	eb000000	 bl          GPIOSetMode

; 2605 :     GPIOSetMode(hGpio, 190, GPIO_DIR_OUTPUT); // D6

  000e0	e3a02000	 mov         r2, #0
  000e4	e3a010be	 mov         r1, #0xBE
  000e8	e1a00005	 mov         r0, r5
  000ec	eb000000	 bl          GPIOSetMode

; 2606 :     GPIOSetMode(hGpio, 191, GPIO_DIR_OUTPUT); // D7

  000f0	e3a02000	 mov         r2, #0
  000f4	e3a010bf	 mov         r1, #0xBF
  000f8	e1a00005	 mov         r0, r5
  000fc	eb000000	 bl          GPIOSetMode

; 2607 : 
; 2608 :     // Attempt recovery procedure 1
; 2609 :     //RETAILMSG(1, (TEXT("Attempt Recovery Procedure 2\r\n")));
; 2610 : 
; 2611 :     GPIOSetBit(hGpio, 190); // Set   D6

  00100	e3a010be	 mov         r1, #0xBE
  00104	e1a00005	 mov         r0, r5
  00108	eb000000	 bl          GPIOSetBit

; 2612 :     GPIOClrBit(hGpio, 191); // Clear D7

  0010c	e3a010bf	 mov         r1, #0xBF
  00110	e1a00005	 mov         r0, r5
  00114	eb000000	 bl          GPIOClrBit

; 2613 :     GPIOClrBit(hGpio, 125); // Clear D0

  00118	e3a0107d	 mov         r1, #0x7D
  0011c	e1a00005	 mov         r0, r5
  00120	eb000000	 bl          GPIOClrBit

; 2614 :     GPIOClrBit(hGpio, 130); // Clear D1

  00124	e3a01082	 mov         r1, #0x82
  00128	e1a00005	 mov         r0, r5
  0012c	eb000000	 bl          GPIOClrBit

; 2615 :     GPIOClrBit(hGpio, 131); // Clear D2

  00130	e3a01083	 mov         r1, #0x83
  00134	e1a00005	 mov         r0, r5
  00138	eb000000	 bl          GPIOClrBit

; 2616 :     GPIOClrBit(hGpio, 169); // Clear D3

  0013c	e3a010a9	 mov         r1, #0xA9
  00140	e1a00005	 mov         r0, r5
  00144	eb000000	 bl          GPIOClrBit

; 2617 :     GPIOClrBit(hGpio, 188); // Clear D4

  00148	e3a010bc	 mov         r1, #0xBC
  0014c	e1a00005	 mov         r0, r5
  00150	eb000000	 bl          GPIOClrBit

; 2618 :     GPIOClrBit(hGpio, 189); // Clear D5

  00154	e3a010bd	 mov         r1, #0xBD
  00158	e1a00005	 mov         r0, r5
  0015c	eb000000	 bl          GPIOClrBit

; 2619 : 
; 2620 :     DelayByRegisterRead();

  00160	e5963150	 ldr         r3, [r6, #0x150]
  00164	e3a0200c	 mov         r2, #0xC
  00168	e5931018	 ldr         r1, [r3, #0x18]
  0016c		 |$LL10@LinkRecove@2|
  0016c	e5913000	 ldr         r3, [r1]
  00170	e2522001	 subs        r2, r2, #1
  00174	1afffffc	 bne         |$LL10@LinkRecove@2|

; 2621 : 
; 2622 :     GPIOSetBit(hGpio, 121); // Set   STP

  00178	e3a01079	 mov         r1, #0x79
  0017c	e1a00005	 mov         r0, r5
  00180	eb000000	 bl          GPIOSetBit

; 2623 : 
; 2624 : 
; 2625 :     DelayByRegisterRead();

  00184	e5963150	 ldr         r3, [r6, #0x150]
  00188	e3a0200c	 mov         r2, #0xC
  0018c	e5931018	 ldr         r1, [r3, #0x18]
  00190		 |$LL15@LinkRecove@2|
  00190	e5913000	 ldr         r3, [r1]
  00194	e2522001	 subs        r2, r2, #1
  00198	1afffffc	 bne         |$LL15@LinkRecove@2|

; 2626 : 
; 2627 :     GPIOClrBit(hGpio, 190); // Clear D6

  0019c	e3a010be	 mov         r1, #0xBE
  001a0	e1a00005	 mov         r0, r5
  001a4	eb000000	 bl          GPIOClrBit

; 2628 :     DelayByRegisterRead();

  001a8	e5963150	 ldr         r3, [r6, #0x150]
  001ac	e3a0200c	 mov         r2, #0xC
  001b0	e5931018	 ldr         r1, [r3, #0x18]
  001b4		 |$LL20@LinkRecove@2|
  001b4	e5913000	 ldr         r3, [r1]
  001b8	e2522001	 subs        r2, r2, #1
  001bc	1afffffc	 bne         |$LL20@LinkRecove@2|

; 2629 :     GPIOClrBit(hGpio, 121); // Clear STP

  001c0	e3a01079	 mov         r1, #0x79
  001c4	e1a00005	 mov         r0, r5
  001c8	eb000000	 bl          GPIOClrBit

; 2630 : 
; 2631 :     GPIOClose(hGpio);

  001cc	e1a00005	 mov         r0, r5
  001d0	eb000000	 bl          GPIOClose

; 2632 : 
; 2633 : 
; 2634 :     RETAILMSG(1, (TEXT("Restore ULPI Signals\r\n")));

  001d4	e59f0064	 ldr         r0, [pc, #0x64]
  001d8	eb000000	 bl          NKDbgPrintfW

; 2635 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_STP, (OFF_OUTPUT_PULL_INACTIVE | INPUT_DISABLE | PULL_UP | MUX_MODE_0));          /*HSUSB0_STP*/

  001dc	e3a03f86	 mov         r3, #0x86, 30

; 2636 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA0, (OFF_INPUT_PULL_DOWN | INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0));        /*HSUSB0_DATA0*/

  001e0	e3a02c17	 mov         r2, #0x17, 24
  001e4	e1c930b0	 strh        r3, [r9]
  001e8	e1c827ba	 strh        r2, [r8, #0x7A]

; 2637 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA1, (OFF_INPUT_PULL_DOWN | INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0));        /*HSUSB0_DATA1*/

  001ec	e1cb20b0	 strh        r2, [r11]

; 2638 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA2, (OFF_INPUT_PULL_DOWN | INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0));        /*HSUSB0_DATA2*/
; 2639 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA3, (OFF_INPUT_PULL_DOWN | INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0));        /*HSUSB0_DATA3*/

  001f0	e2843d06	 add         r3, r4, #6, 26
  001f4	e1ca27be	 strh        r2, [r10, #0x7E]
  001f8	e1c320b0	 strh        r2, [r3]

; 2640 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA4, (OFF_INPUT_PULL_DOWN | INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0));        /*HSUSB0_DATA4*/

  001fc	e2843c01	 add         r3, r4, #1, 24
  00200	e1c328b2	 strh        r2, [r3, #0x82]

; 2641 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA5, (OFF_INPUT_PULL_DOWN | INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0));        /*HSUSB0_DATA5*/

  00204	e2843f61	 add         r3, r4, #0x61, 30
  00208	e1c320b0	 strh        r2, [r3]

; 2642 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA6, (OFF_INPUT_PULL_DOWN | INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0));        /*HSUSB0_DATA6*/

  0020c	e2843c01	 add         r3, r4, #1, 24
  00210	e1c328b6	 strh        r2, [r3, #0x86]

; 2643 :     OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA7, (OFF_INPUT_PULL_DOWN | INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0));        /*HSUSB0_DATA7*/

  00214	e2843f62	 add         r3, r4, #0x62, 30
  00218	e1c320b0	 strh        r2, [r3]

; 2644 : 
; 2645 :     if((ReadULPIReg( m_pOTG, ULPI_VENDORID_LOW_R)))

  0021c	e5961150	 ldr         r1, [r6, #0x150]
  00220	e3a02000	 mov         r2, #0
  00224	e1a00006	 mov         r0, r6
  00228	eb000000	 bl          |?ReadULPIReg@OMAPMHSUSBOTG@@QAAEPAUHSMUSB_T@@E@Z|
  0022c	e3500000	 cmp         r0, #0

; 2646 :     {
; 2647 :         //RETAILMSG(1, (TEXT("Recovery Procedure 2. ULPI Link Functional\r\n")));
; 2648 :         ret = TRUE;

  00230	13a07001	 movne       r7, #1

; 2649 :     }
; 2650 : 
; 2651 :     return ret;
; 2652 : }

  00234	e1a00007	 mov         r0, r7
  00238	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0023c	e12fff1e	 bx          lr
  00240		 |$LN32@LinkRecove@2|
  00240		 |$LN33@LinkRecove@2|
  00240	00000000	 DCD         |??_C@_1CO@DLKKJIDB@?$AAR?$AAe?$AAs?$AAt?$AAo?$AAr?$AAe?$AA?5?$AAU?$AAL?$AAP?$AAI?$AA?5?$AAS?$AAi?$AAg?$AAn?$AAa?$AAl?$AAs?$AA?$AN?$AA?6?$AA?$AA@|
  00244		 |$LN34@LinkRecove@2|
  00244	00000000	 DCD         |??_C@_1DM@PAEGICHA@?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AA?5?$AAU?$AAL?$AAP?$AAI?$AA?5?$AAs?$AAi?$AAg?$AAn?$AAa?$AAl?$AAs?$AA?5?$AAt?$AAo?$AA?5?$AAG?$AAP?$AAI?$AAO?$AA?$AN?$AA?6?$AA?$AA@|
  00248		 |$M44025|

			 ENDP  ; |?LinkRecoveryProcedure2@OMAPMHSUSBOTG@@QAAHXZ|, OMAPMHSUSBOTG::LinkRecoveryProcedure2

	EXPORT	|??_C@_1FK@DDAPPDML@?$AAR?$AAe?$AAc?$AAo?$AAv?$AAe?$AAr?$AAy?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAd?$AAu?$AAr?$AAe?$AA?5?$AA1?$AA?4?$AA?5?$AAU?$AAL?$AAP?$AAI?$AA?5?$AAL?$AAi?$AAn?$AAk?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FK@IJFKPHNM@?$AAR?$AAe?$AAc?$AAo?$AAv?$AAe?$AAr?$AAy?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAd?$AAu?$AAr?$AAe?$AA?5?$AA2?$AA?4?$AA?5?$AAU?$AAL?$AAP?$AAI?$AA?5?$AAL?$AAi?$AAn?$AAk?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FK@OAJGALNB@?$AAR?$AAe?$AAc?$AAo?$AAv?$AAe?$AAr?$AAy?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAd?$AAu?$AAr?$AAe?$AA?5?$AA3?$AA?4?$AA?5?$AAU?$AAL?$AAP?$AAI?$AA?5?$AAL?$AAi?$AAn?$AAk?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GM@IAJAHOFG@?$AAU?$AAL?$AAP?$AAI?$AA?5?$AAL?$AAi?$AAn?$AAk?$AA?5?$AAr?$AAe?$AAc?$AAo?$AAv?$AAe?$AAr?$AAy?$AA?5?$AAa?$AAt?$AAt?$AAe?$AAm?$AAp?$AAt?$AAe?$AAd?$AA?4?$AA?5?$AAE?$AAx@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FE@GOEGMFKN@?$AAA?$AAt?$AAt?$AAe?$AAm?$AAp?$AAt?$AA?5?$AAR?$AAe?$AAc?$AAo?$AAv?$AAe?$AAr?$AAy?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAd?$AAu?$AAr?$AAe?$AA?5?$AA3?$AA?$CB?$AA?5?$AAR?$AAe@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DO@LLECKEKC@?$AAA?$AAt?$AAt?$AAe?$AAm?$AAp?$AAt?$AA?5?$AAR?$AAe?$AAc?$AAo?$AAv?$AAe?$AAr?$AAy?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAd?$AAu?$AAr?$AAe?$AA?5?$AA2?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DO@DFMNKDEB@?$AAA?$AAt?$AAt?$AAe?$AAm?$AAp?$AAt?$AA?5?$AAR?$AAe?$AAc?$AAo?$AAv?$AAe?$AAr?$AAy?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAd?$AAu?$AAr?$AAe?$AA?5?$AA1?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T44060| DCD	|$LN32@SoftResetU|
	DCD	0x40003701

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FK@DDAPPDML@?$AAR?$AAe?$AAc?$AAo?$AAv?$AAe?$AAr?$AAy?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAd?$AAu?$AAr?$AAe?$AA?5?$AA1?$AA?4?$AA?5?$AAU?$AAL?$AAP?$AAI?$AA?5?$AAL?$AAi?$AAn?$AAk?$AA?5@| DCB "R"
	DCB	0x0, "e", 0x0, "c", 0x0, "o", 0x0, "v", 0x0, "e", 0x0, "r"
	DCB	0x0, "y", 0x0, " ", 0x0, "P", 0x0, "r", 0x0, "o", 0x0, "c"
	DCB	0x0, "e", 0x0, "d", 0x0, "u", 0x0, "r", 0x0, "e", 0x0, " "
	DCB	0x0, "1", 0x0, ".", 0x0, " ", 0x0, "U", 0x0, "L", 0x0, "P"
	DCB	0x0, "I", 0x0, " ", 0x0, "L", 0x0, "i", 0x0, "n", 0x0, "k"
	DCB	0x0, " ", 0x0, "F", 0x0, "u", 0x0, "n", 0x0, "c", 0x0, "t"
	DCB	0x0, "i", 0x0, "o", 0x0, "n", 0x0, "a", 0x0, "l", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FK@IJFKPHNM@?$AAR?$AAe?$AAc?$AAo?$AAv?$AAe?$AAr?$AAy?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAd?$AAu?$AAr?$AAe?$AA?5?$AA2?$AA?4?$AA?5?$AAU?$AAL?$AAP?$AAI?$AA?5?$AAL?$AAi?$AAn?$AAk?$AA?5@| DCB "R"
	DCB	0x0, "e", 0x0, "c", 0x0, "o", 0x0, "v", 0x0, "e", 0x0, "r"
	DCB	0x0, "y", 0x0, " ", 0x0, "P", 0x0, "r", 0x0, "o", 0x0, "c"
	DCB	0x0, "e", 0x0, "d", 0x0, "u", 0x0, "r", 0x0, "e", 0x0, " "
	DCB	0x0, "2", 0x0, ".", 0x0, " ", 0x0, "U", 0x0, "L", 0x0, "P"
	DCB	0x0, "I", 0x0, " ", 0x0, "L", 0x0, "i", 0x0, "n", 0x0, "k"
	DCB	0x0, " ", 0x0, "F", 0x0, "u", 0x0, "n", 0x0, "c", 0x0, "t"
	DCB	0x0, "i", 0x0, "o", 0x0, "n", 0x0, "a", 0x0, "l", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FK@OAJGALNB@?$AAR?$AAe?$AAc?$AAo?$AAv?$AAe?$AAr?$AAy?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAd?$AAu?$AAr?$AAe?$AA?5?$AA3?$AA?4?$AA?5?$AAU?$AAL?$AAP?$AAI?$AA?5?$AAL?$AAi?$AAn?$AAk?$AA?5@| DCB "R"
	DCB	0x0, "e", 0x0, "c", 0x0, "o", 0x0, "v", 0x0, "e", 0x0, "r"
	DCB	0x0, "y", 0x0, " ", 0x0, "P", 0x0, "r", 0x0, "o", 0x0, "c"
	DCB	0x0, "e", 0x0, "d", 0x0, "u", 0x0, "r", 0x0, "e", 0x0, " "
	DCB	0x0, "3", 0x0, ".", 0x0, " ", 0x0, "U", 0x0, "L", 0x0, "P"
	DCB	0x0, "I", 0x0, " ", 0x0, "L", 0x0, "i", 0x0, "n", 0x0, "k"
	DCB	0x0, " ", 0x0, "F", 0x0, "u", 0x0, "n", 0x0, "c", 0x0, "t"
	DCB	0x0, "i", 0x0, "o", 0x0, "n", 0x0, "a", 0x0, "l", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GM@IAJAHOFG@?$AAU?$AAL?$AAP?$AAI?$AA?5?$AAL?$AAi?$AAn?$AAk?$AA?5?$AAr?$AAe?$AAc?$AAo?$AAv?$AAe?$AAr?$AAy?$AA?5?$AAa?$AAt?$AAt?$AAe?$AAm?$AAp?$AAt?$AAe?$AAd?$AA?4?$AA?5?$AAE?$AAx@| DCB "U"
	DCB	0x0, "L", 0x0, "P", 0x0, "I", 0x0, " ", 0x0, "L", 0x0, "i"
	DCB	0x0, "n", 0x0, "k", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "c"
	DCB	0x0, "o", 0x0, "v", 0x0, "e", 0x0, "r", 0x0, "y", 0x0, " "
	DCB	0x0, "a", 0x0, "t", 0x0, "t", 0x0, "e", 0x0, "m", 0x0, "p"
	DCB	0x0, "t", 0x0, "e", 0x0, "d", 0x0, ".", 0x0, " ", 0x0, "E"
	DCB	0x0, "x", 0x0, "i", 0x0, "t", 0x0, " ", 0x0, "r", 0x0, "e"
	DCB	0x0, "c", 0x0, "o", 0x0, "v", 0x0, "e", 0x0, "r", 0x0, "y"
	DCB	0x0, " ", 0x0, "p", 0x0, "r", 0x0, "o", 0x0, "c", 0x0, "e"
	DCB	0x0, "s", 0x0, "s", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FE@GOEGMFKN@?$AAA?$AAt?$AAt?$AAe?$AAm?$AAp?$AAt?$AA?5?$AAR?$AAe?$AAc?$AAo?$AAv?$AAe?$AAr?$AAy?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAd?$AAu?$AAr?$AAe?$AA?5?$AA3?$AA?$CB?$AA?5?$AAR?$AAe@| DCB "A"
	DCB	0x0, "t", 0x0, "t", 0x0, "e", 0x0, "m", 0x0, "p", 0x0, "t"
	DCB	0x0, " ", 0x0, "R", 0x0, "e", 0x0, "c", 0x0, "o", 0x0, "v"
	DCB	0x0, "e", 0x0, "r", 0x0, "y", 0x0, " ", 0x0, "P", 0x0, "r"
	DCB	0x0, "o", 0x0, "c", 0x0, "e", 0x0, "d", 0x0, "u", 0x0, "r"
	DCB	0x0, "e", 0x0, " ", 0x0, "3", 0x0, "!", 0x0, " ", 0x0, "R"
	DCB	0x0, "e", 0x0, "s", 0x0, "e", 0x0, "t", 0x0, " ", 0x0, "P"
	DCB	0x0, "H", 0x0, "Y", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DO@LLECKEKC@?$AAA?$AAt?$AAt?$AAe?$AAm?$AAp?$AAt?$AA?5?$AAR?$AAe?$AAc?$AAo?$AAv?$AAe?$AAr?$AAy?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAd?$AAu?$AAr?$AAe?$AA?5?$AA2?$AA?$AN?$AA?6?$AA?$AA@| DCB "A"
	DCB	0x0, "t", 0x0, "t", 0x0, "e", 0x0, "m", 0x0, "p", 0x0, "t"
	DCB	0x0, " ", 0x0, "R", 0x0, "e", 0x0, "c", 0x0, "o", 0x0, "v"
	DCB	0x0, "e", 0x0, "r", 0x0, "y", 0x0, " ", 0x0, "P", 0x0, "r"
	DCB	0x0, "o", 0x0, "c", 0x0, "e", 0x0, "d", 0x0, "u", 0x0, "r"
	DCB	0x0, "e", 0x0, " ", 0x0, "2", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DO@DFMNKDEB@?$AAA?$AAt?$AAt?$AAe?$AAm?$AAp?$AAt?$AA?5?$AAR?$AAe?$AAc?$AAo?$AAv?$AAe?$AAr?$AAy?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAd?$AAu?$AAr?$AAe?$AA?5?$AA1?$AA?$AN?$AA?6?$AA?$AA@| DCB "A"
	DCB	0x0, "t", 0x0, "t", 0x0, "e", 0x0, "m", 0x0, "p", 0x0, "t"
	DCB	0x0, " ", 0x0, "R", 0x0, "e", 0x0, "c", 0x0, "o", 0x0, "v"
	DCB	0x0, "e", 0x0, "r", 0x0, "y", 0x0, " ", 0x0, "P", 0x0, "r"
	DCB	0x0, "o", 0x0, "c", 0x0, "e", 0x0, "d", 0x0, "u", 0x0, "r"
	DCB	0x0, "e", 0x0, " ", 0x0, "1", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SoftResetULPILink@OMAPMHSUSBOTG@@UAAHXZ| PROC ; OMAPMHSUSBOTG::SoftResetULPILink

; 2656 : {

  00000		 |$LN32@SoftResetU|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M44057|
  00004	e1a05000	 mov         r5, r0

; 2657 :     HANDLE hGpio=NULL;
; 2658 :     DWORD j=5;

  00008	e3a04005	 mov         r4, #5

; 2659 : 
; 2660 :     hGpio = GPIOOpen();

  0000c	eb000000	 bl          GPIOOpen
  00010	e1a06000	 mov         r6, r0
  00014		 |$LL9@SoftResetU|

; 2661 : 
; 2662 :     do
; 2663 :     {
; 2664 : 
; 2665 :         // Attempt recovery procedure 1
; 2666 :         RETAILMSG(1, (TEXT("Attempt Recovery Procedure 1\r\n")));

  00014	e59f00bc	 ldr         r0, [pc, #0xBC]
  00018	eb000000	 bl          NKDbgPrintfW

; 2667 :         if(!LinkRecoveryProcedure1())

  0001c	e1a00005	 mov         r0, r5
  00020	eb000000	 bl          |?LinkRecoveryProcedure1@OMAPMHSUSBOTG@@QAAHXZ|
  00024	e3500000	 cmp         r0, #0
  00028	1a00001d	 bne         |$LN6@SoftResetU|

; 2668 :         {
; 2669 :             // Attempt recovery procedure 2
; 2670 :             RETAILMSG(1, (TEXT("Attempt Recovery Procedure 2\r\n")));

  0002c	e59f00a0	 ldr         r0, [pc, #0xA0]
  00030	eb000000	 bl          NKDbgPrintfW

; 2671 :             if(!LinkRecoveryProcedure2())

  00034	e1a00005	 mov         r0, r5
  00038	eb000000	 bl          |?LinkRecoveryProcedure2@OMAPMHSUSBOTG@@QAAHXZ|
  0003c	e3500000	 cmp         r0, #0
  00040	1a000015	 bne         |$LN5@SoftResetU|

; 2672 :             {
; 2673 :                 // Attempt recovery procedure 3
; 2674 :                 RETAILMSG(1, (TEXT("Attempt Recovery Procedure 3! Reset PHY\r\n")));

  00044	e59f0084	 ldr         r0, [pc, #0x84]
  00048	eb000000	 bl          NKDbgPrintfW

; 2675 :                 m_pTransceiver->ResetPHY();

  0004c	e59500fc	 ldr         r0, [r5, #0xFC]
  00050	e5903000	 ldr         r3, [r0]
  00054	e593302c	 ldr         r3, [r3, #0x2C]
  00058	e1a0e00f	 mov         lr, pc
  0005c	e12fff13	 bx          r3

; 2676 : 
; 2677 :                 // Check whether LINK is functional. Otherwise restart
; 2678 :                 // Recovery Procedures.
; 2679 :                 if((ReadULPIReg( m_pOTG, ULPI_VENDORID_LOW_R)))

  00060	e5951150	 ldr         r1, [r5, #0x150]
  00064	e3a02000	 mov         r2, #0
  00068	e1a00005	 mov         r0, r5
  0006c	eb000000	 bl          |?ReadULPIReg@OMAPMHSUSBOTG@@QAAEPAUHSMUSB_T@@E@Z|
  00070	e3500000	 cmp         r0, #0
  00074	1a000006	 bne         |$LN27@SoftResetU|

; 2694 :             break;
; 2695 :         }
; 2696 : 
; 2697 : 
; 2698 :         if (j == 0)

  00078	e3540000	 cmp         r4, #0

; 2699 :             RETAILMSG(1, (TEXT("ULPI Link recovery attempted. Exit recovery process\r\n")));

  0007c	059f0048	 ldreq       r0, [pc, #0x48]
  00080	0b000000	 bleq        NKDbgPrintfW

; 2700 : 
; 2701 :     }while(j--);

  00084	e3540000	 cmp         r4, #0
  00088	e2444001	 sub         r4, r4, #1
  0008c	1affffe0	 bne         |$LL9@SoftResetU|
  00090	ea000005	 b           |$LN7@SoftResetU|
  00094		 |$LN27@SoftResetU|

; 2680 :                 {
; 2681 :                     RETAILMSG(1, (TEXT("Recovery Procedure 3. ULPI Link Functional\r\n")));

  00094	e59f002c	 ldr         r0, [pc, #0x2C]

; 2682 :                     break;

  00098	ea000002	 b           |$LN29@SoftResetU|
  0009c		 |$LN5@SoftResetU|

; 2683 :                 }
; 2684 :             }
; 2685 :             else
; 2686 :             {
; 2687 :                 RETAILMSG(1, (TEXT("Recovery Procedure 2. ULPI Link Functional\r\n")));

  0009c	e59f0020	 ldr         r0, [pc, #0x20]

; 2688 :                 break;

  000a0	ea000000	 b           |$LN29@SoftResetU|
  000a4		 |$LN6@SoftResetU|

; 2689 :             }
; 2690 :         }
; 2691 :         else
; 2692 :         {
; 2693 :             RETAILMSG(1, (TEXT("Recovery Procedure 1. ULPI Link Functional\r\n")));

  000a4	e59f0014	 ldr         r0, [pc, #0x14]
  000a8		 |$LN29@SoftResetU|
  000a8	eb000000	 bl          NKDbgPrintfW
  000ac		 |$LN7@SoftResetU|

; 2702 : 
; 2703 :     GPIOClose(hGpio);

  000ac	e1a00006	 mov         r0, r6
  000b0	eb000000	 bl          GPIOClose

; 2704 :     return TRUE;

  000b4	e3a00001	 mov         r0, #1

; 2705 : }

  000b8	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000bc	e12fff1e	 bx          lr
  000c0		 |$LN33@SoftResetU|
  000c0		 |$LN34@SoftResetU|
  000c0	00000000	 DCD         |??_C@_1FK@DDAPPDML@?$AAR?$AAe?$AAc?$AAo?$AAv?$AAe?$AAr?$AAy?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAd?$AAu?$AAr?$AAe?$AA?5?$AA1?$AA?4?$AA?5?$AAU?$AAL?$AAP?$AAI?$AA?5?$AAL?$AAi?$AAn?$AAk?$AA?5@|
  000c4		 |$LN35@SoftResetU|
  000c4	00000000	 DCD         |??_C@_1FK@IJFKPHNM@?$AAR?$AAe?$AAc?$AAo?$AAv?$AAe?$AAr?$AAy?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAd?$AAu?$AAr?$AAe?$AA?5?$AA2?$AA?4?$AA?5?$AAU?$AAL?$AAP?$AAI?$AA?5?$AAL?$AAi?$AAn?$AAk?$AA?5@|
  000c8		 |$LN36@SoftResetU|
  000c8	00000000	 DCD         |??_C@_1FK@OAJGALNB@?$AAR?$AAe?$AAc?$AAo?$AAv?$AAe?$AAr?$AAy?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAd?$AAu?$AAr?$AAe?$AA?5?$AA3?$AA?4?$AA?5?$AAU?$AAL?$AAP?$AAI?$AA?5?$AAL?$AAi?$AAn?$AAk?$AA?5@|
  000cc		 |$LN37@SoftResetU|
  000cc	00000000	 DCD         |??_C@_1GM@IAJAHOFG@?$AAU?$AAL?$AAP?$AAI?$AA?5?$AAL?$AAi?$AAn?$AAk?$AA?5?$AAr?$AAe?$AAc?$AAo?$AAv?$AAe?$AAr?$AAy?$AA?5?$AAa?$AAt?$AAt?$AAe?$AAm?$AAp?$AAt?$AAe?$AAd?$AA?4?$AA?5?$AAE?$AAx@|
  000d0		 |$LN38@SoftResetU|
  000d0	00000000	 DCD         |??_C@_1FE@GOEGMFKN@?$AAA?$AAt?$AAt?$AAe?$AAm?$AAp?$AAt?$AA?5?$AAR?$AAe?$AAc?$AAo?$AAv?$AAe?$AAr?$AAy?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAd?$AAu?$AAr?$AAe?$AA?5?$AA3?$AA?$CB?$AA?5?$AAR?$AAe@|
  000d4		 |$LN39@SoftResetU|
  000d4	00000000	 DCD         |??_C@_1DO@LLECKEKC@?$AAA?$AAt?$AAt?$AAe?$AAm?$AAp?$AAt?$AA?5?$AAR?$AAe?$AAc?$AAo?$AAv?$AAe?$AAr?$AAy?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAd?$AAu?$AAr?$AAe?$AA?5?$AA2?$AA?$AN?$AA?6?$AA?$AA@|
  000d8		 |$LN40@SoftResetU|
  000d8	00000000	 DCD         |??_C@_1DO@DFMNKDEB@?$AAA?$AAt?$AAt?$AAe?$AAm?$AAp?$AAt?$AA?5?$AAR?$AAe?$AAc?$AAo?$AAv?$AAe?$AAr?$AAy?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAd?$AAu?$AAr?$AAe?$AA?5?$AA1?$AA?$AN?$AA?6?$AA?$AA@|
  000dc		 |$M44058|

			 ENDP  ; |?SoftResetULPILink@OMAPMHSUSBOTG@@UAAHXZ|, OMAPMHSUSBOTG::SoftResetULPILink

	EXPORT	|??_C@_1DI@POPBHNLK@?$AAC?$AAa?$AAl?$AAl?$AAi?$AAn?$AAg?$AA?5?$AAS?$AAe?$AAs?$AAs?$AAi?$AAo?$AAn?$AA?5?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|IsAPIReady|
	IMPORT	|GetTickCount|
	IMPORT	|WaitForAPIReady|
	IMPORT	|WaitForMultipleObjects|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T44199| DCD	|$LN266@ThreadRun@3|
	DCD	0x40052a02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DI@POPBHNLK@?$AAC?$AAa?$AAl?$AAl?$AAi?$AAn?$AAg?$AA?5?$AAS?$AAe?$AAs?$AAs?$AAi?$AAo?$AAn?$AA?5?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| DCB "C"
	DCB	0x0, "a", 0x0, "l", 0x0, "l", 0x0, "i", 0x0, "n", 0x0, "g"
	DCB	0x0, " ", 0x0, "S", 0x0, "e", 0x0, "s", 0x0, "s", 0x0, "i"
	DCB	0x0, "o", 0x0, "n", 0x0, " ", 0x0, "R", 0x0, "e", 0x0, "q"
	DCB	0x0, "u", 0x0, "e", 0x0, "s", 0x0, "t", 0x0, "%", 0x0, "d"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbotg\otg.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ThreadRun@OMAPMHSUSBOTG@@EAAKXZ| PROC ; OMAPMHSUSBOTG::ThreadRun

; 2894 : {

  00000		 |$LN266@ThreadRun@3|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M44196|
  00008	e1a05000	 mov         r5, r0

; 2895 :     DWORD   dwEvent;
; 2896 :     DWORD   dwReady = 0x00;
; 2897 :     BOOL    fTerminated = FALSE;
; 2898 :     PCSP_MUSB_GEN_REGS pGen;
; 2899 :     PCSP_MUSB_OTG_REGS pOtg;        
; 2900 :     DWORD dwSysConfigValue;
; 2901 :     int i;
; 2902 :     BOOL  bStratupWaitDone = FALSE;
; 2903 :     DWORD dwStartTime;
; 2904 :     pGen = m_pOTG->pUsbGenRegs;

  0000c	e5953074	 ldr         r3, [r5, #0x74]

; 2905 : 
; 2906 :     CeSetThreadPriority(GetCurrentThread(), m_OTGRegCfg.otgIstPrio);

  00010	e5951040	 ldr         r1, [r5, #0x40]
  00014	e3a00041	 mov         r0, #0x41
  00018	e5936020	 ldr         r6, [r3, #0x20]
  0001c	e3a04000	 mov         r4, #0
  00020	e3a09000	 mov         r9, #0
  00024	eb000000	 bl          CeSetThreadPriority

; 2907 : 
; 2908 :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("+OMAPMHSUSBOTG::ThreadRun\r\n")));        
; 2909 :     // Wait for both musbhost and musbfn drivers to load
; 2910 :     while ((dwEvent = WaitForMultipleObjects(2, m_pOTG->hReadyEvents, FALSE, INFINITE))!= WAIT_FAILED)

  00028	e3e07000	 mvn         r7, #0
  0002c	ea000006	 b           |$LN243@ThreadRun@3|
  00030		 |$LL176@ThreadRun@3|

; 2911 :     {
; 2912 :         if (dwEvent == WAIT_OBJECT_0) // Device

  00030	e3500000	 cmp         r0, #0

; 2913 :             dwReady |= 0x01;

  00034	03844001	 orreq       r4, r4, #1
  00038	0a000001	 beq         |$LN172@ThreadRun@3|

; 2914 :         else if (dwEvent == WAIT_OBJECT_0+1) // Host

  0003c	e3500001	 cmp         r0, #1

; 2915 :             dwReady |= 0x02;

  00040	03844002	 orreq       r4, r4, #2
  00044		 |$LN172@ThreadRun@3|

; 2916 : 
; 2917 :         if (dwReady == 0x03)

  00044	e3540003	 cmp         r4, #3
  00048	0a000006	 beq         |$LN231@ThreadRun@3|
  0004c		 |$LN243@ThreadRun@3|
  0004c	e5951074	 ldr         r1, [r5, #0x74]
  00050	e1a03007	 mov         r3, r7
  00054	e3a02000	 mov         r2, #0
  00058	e3a00002	 mov         r0, #2
  0005c	eb000000	 bl          WaitForMultipleObjects
  00060	e3700001	 cmn         r0, #1
  00064	1afffff1	 bne         |$LL176@ThreadRun@3|
  00068		 |$LN231@ThreadRun@3|
  00068	e3a03caf	 mov         r3, #0xAF, 24

; 2918 :             break;
; 2919 :     }
; 2920 : 
; 2921 :     // wait for shell API
; 2922 :     WaitForAPIReady(SH_SHELL, 45000);

  0006c	e38310c8	 orr         r1, r3, #0xC8
  00070	e3a00055	 mov         r0, #0x55
  00074	eb000000	 bl          WaitForAPIReady

; 2923 : 	
; 2924 :     m_bIncCount = FALSE;    
; 2925 :     m_bExtendOTGSuspend = FALSE;
; 2926 :     // Here to update the state to idle state
; 2927 :     m_UsbOtgState = USBOTG_b_idle;
; 2928 :     m_UsbOtgInput.bit.id = 1;
; 2929 :     EventNotification();

  00078	e51530dc	 ldr         r3, [r5, #-0xDC]
  0007c	e5152090	 ldr         r2, [r5, #-0x90]
  00080	e3a04009	 mov         r4, #9
  00084	e5931074	 ldr         r1, [r3, #0x74]
  00088	e3823902	 orr         r3, r2, #2, 18
  0008c	e3a07000	 mov         r7, #0
  00090	e5053090	 str         r3, [r5, #-0x90]
  00094	e24500dc	 sub         r0, r5, #0xDC
  00098	e58570a4	 str         r7, [r5, #0xA4]
  0009c	e58570a8	 str         r7, [r5, #0xA8]
  000a0	e505406c	 str         r4, [r5, #-0x6C]
  000a4	e1a0e00f	 mov         lr, pc
  000a8	e12fff11	 bx          r1

; 2930 : 
; 2931 :     m_disconnected = TRUE;

  000ac	e3a08001	 mov         r8, #1
  000b0	e58580b0	 str         r8, [r5, #0xB0]

; 2932 :     m_bSuspendTransceiver = FALSE;

  000b4	e58570b4	 str         r7, [r5, #0xB4]

; 2933 :     m_handleVBUSError = FALSE;

  000b8	e58570b8	 str         r7, [r5, #0xB8]

; 2934 :     dwStartTime = GetTickCount();

  000bc	eb000000	 bl          GetTickCount

; 2935 : 
; 2936 :     // Now you have all drivers loading and hence can do the register on the bus...
; 2937 :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("OMAPMHSUSBOTG::ThreadRun: Enable Interrupt waiting for connection!!!\r\n")));
; 2938 : 
; 2939 :     StartUSBClock(TRUE);

  000c0	e51530dc	 ldr         r3, [r5, #-0xDC]
  000c4	e58d0000	 str         r0, [sp]
  000c8	e3a01001	 mov         r1, #1
  000cc	e59330e4	 ldr         r3, [r3, #0xE4]
  000d0	e24500dc	 sub         r0, r5, #0xDC
  000d4	e1a0e00f	 mov         lr, pc
  000d8	e12fff13	 bx          r3

; 2940 :     // Configure the rest of the stuff:
; 2941 :     pOtg = m_pOTG->pUsbOtgRegs;
; 2942 : 
; 2943 :     if (m_OTGRegCfg.DisableHighSpeed)

  000dc	e5952024	 ldr         r2, [r5, #0x24]
  000e0	e5953074	 ldr         r3, [r5, #0x74]

; 2944 :         CLRREG8(&pGen->Power, POWER_HSENABLE);
; 2945 :     
; 2946 :     // Configuring according to TI spec TRM V.H 25.12.3.2 & 25.12.3.3
; 2947 :     // Clear the EnableForce bit 
; 2948 :     CLRREG32(&pOtg->OTG_FORCESTDBY, OTG_FORCESTDY_ENABLEFORCE);
; 2949 : 
; 2950 :     // Set the MIDLEMODE to SmartStandy
; 2951 :     CLRREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_M_MASK);
; 2952 :     SETREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_M_SMARTSTDBY);
; 2953 : 
; 2954 :     // Set the SIDLEMODE to SmartIdle
; 2955 :     CLRREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_S_MASK);
; 2956 :     SETREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_S_SMARTIDLE);
; 2957 : 
; 2958 :     // Clear the AutoIdle mode
; 2959 :     CLRREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_AUTOIDLE);
; 2960 : 
; 2961 :     // Set back the AutoIdle mode to 1
; 2962 :     SETREG32(&pOtg->OTG_SYSCONFIG, OTG_SYSCONF_AUTOIDLE);
; 2963 : 
; 2964 :     // Configure to 12-pin, 8 bit ULPI    
; 2965 :     OUTREG32(&pOtg->OTG_INTERFSEL, OTG_INTERFSEL_12_PIN_ULPI);
; 2966 : 
; 2967 :     m_bRequestSession = FALSE;        
; 2968 : 
; 2969 :     m_dwStatus = 0;
; 2970 :     
; 2971 :     m_pOTG->hPowerEvent = CreateEvent(0, TRUE, FALSE, NULL);

  000e4	e3a01001	 mov         r1, #1
  000e8	e3520000	 cmp         r2, #0
  000ec	e5934018	 ldr         r4, [r3, #0x18]
  000f0	15d63001	 ldrneb      r3, [r6, #1]
  000f4	120330df	 andne       r3, r3, #0xDF
  000f8	15c63001	 strneb      r3, [r6, #1]
  000fc	e5943014	 ldr         r3, [r4, #0x14]
  00100	e3c33001	 bic         r3, r3, #1
  00104	e5843014	 str         r3, [r4, #0x14]
  00108	e5943004	 ldr         r3, [r4, #4]
  0010c	e3c33a03	 bic         r3, r3, #3, 20
  00110	e5843004	 str         r3, [r4, #4]
  00114	e5942004	 ldr         r2, [r4, #4]
  00118	e3a03000	 mov         r3, #0
  0011c	e3822a02	 orr         r2, r2, #2, 20
  00120	e5842004	 str         r2, [r4, #4]
  00124	e5940004	 ldr         r0, [r4, #4]
  00128	e3a02000	 mov         r2, #0
  0012c	e3c00018	 bic         r0, r0, #0x18
  00130	e5840004	 str         r0, [r4, #4]
  00134	e594e004	 ldr         lr, [r4, #4]
  00138	e3a00000	 mov         r0, #0
  0013c	e38ee010	 orr         lr, lr, #0x10
  00140	e584e004	 str         lr, [r4, #4]
  00144	e594e004	 ldr         lr, [r4, #4]
  00148	e3cee001	 bic         lr, lr, #1
  0014c	e584e004	 str         lr, [r4, #4]
  00150	e594e004	 ldr         lr, [r4, #4]
  00154	e38ee001	 orr         lr, lr, #1
  00158	e584e004	 str         lr, [r4, #4]
  0015c	e584800c	 str         r8, [r4, #0xC]
  00160	e5857088	 str         r7, [r5, #0x88]
  00164	e585701c	 str         r7, [r5, #0x1C]
  00168	eb000000	 bl          CreateEventW
  0016c	e5953074	 ldr         r3, [r5, #0x74]
  00170	e5830058	 str         r0, [r3, #0x58]

; 2972 :     if (m_pOTG->hPowerEvent == NULL)

  00174	e5953074	 ldr         r3, [r5, #0x74]

; 2973 :     {
; 2974 :         DEBUGMSG(ZONE_OTG_ERROR, (TEXT("Failed to create Power Event handle\r\n")));
; 2975 :         return FALSE;

  00178	e3a00000	 mov         r0, #0
  0017c	e5933058	 ldr         r3, [r3, #0x58]
  00180	e3530000	 cmp         r3, #0
  00184	0a000012	 beq         |$LN177@ThreadRun@3|

; 2976 :     }
; 2977 : 
; 2978 :     m_pOTG->hResumeEvent = CreateEvent(0, TRUE, FALSE, NULL);

  00188	e3a03000	 mov         r3, #0
  0018c	e3a02000	 mov         r2, #0
  00190	e3a01001	 mov         r1, #1
  00194	eb000000	 bl          CreateEventW
  00198	e5953074	 ldr         r3, [r5, #0x74]
  0019c	e583005c	 str         r0, [r3, #0x5C]

; 2979 :     if (m_pOTG->hResumeEvent == NULL)

  001a0	e5953074	 ldr         r3, [r5, #0x74]

; 2980 :     {
; 2981 :         DEBUGMSG(ZONE_OTG_ERROR, (TEXT("Failed to create Resume Event handle\r\n")));
; 2982 :         return FALSE;

  001a4	e3a00000	 mov         r0, #0
  001a8	e593305c	 ldr         r3, [r3, #0x5C]
  001ac	e3530000	 cmp         r3, #0
  001b0	0a000007	 beq         |$LN177@ThreadRun@3|

; 2983 :     }
; 2984 : 
; 2985 :     // Now we can set the interrupt routine
; 2986 :     m_hIntrEvent = CreateEvent(0, FALSE, FALSE, NULL);

  001b4	e3a03000	 mov         r3, #0
  001b8	e3a02000	 mov         r2, #0
  001bc	e3a01000	 mov         r1, #0
  001c0	eb000000	 bl          CreateEventW
  001c4	e1b01000	 movs        r1, r0
  001c8	e5851070	 str         r1, [r5, #0x70]

; 2987 :     if (m_hIntrEvent == NULL)

  001cc	1a000003	 bne         |$LN167@ThreadRun@3|
  001d0		 |$LN262@ThreadRun@3|

; 2988 :     {
; 2989 :         DEBUGMSG(ZONE_OTG_ERROR, (TEXT("Failed to create Interrupt Event handle\r\n")));
; 2990 :         return FALSE;

  001d0	e3a00000	 mov         r0, #0
  001d4		 |$LN177@ThreadRun@3|

; 3918 :         }
; 3919 :     }
; 3920 :     
; 3921 :     CloseHandle(m_hIntrEvent);
; 3922 :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("ThreadRun exit\r\n")));
; 3923 :     return 1;
; 3924 : }

  001d4	e28dd008	 add         sp, sp, #8
  001d8	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001dc	e12fff1e	 bx          lr
  001e0		 |$LN167@ThreadRun@3|

; 2991 :     }
; 2992 : 
; 2993 :     // Register the interrupt routine now
; 2994 :     // Initialize interrupt
; 2995 :     DEBUGMSG(ZONE_OTG_INFO, (TEXT("ThreadRun::Initialize Interrupt with sysintr = 0x%x\r\n"), m_dwSysIntr));
; 2996 :     if (!InterruptInitialize(m_dwSysIntr, m_hIntrEvent, NULL, 0))

  001e0	e5950068	 ldr         r0, [r5, #0x68]
  001e4	e3a03000	 mov         r3, #0
  001e8	e3a02000	 mov         r2, #0
  001ec	eb000000	 bl          InterruptInitialize
  001f0	e3500000	 cmp         r0, #0

; 2997 :     {
; 2998 :         DEBUGMSG(ZONE_OTG_ERROR, (TEXT("Failed to initialize the interrupt routine\r\n")));
; 2999 :         // We need to do clean up here
; 3000 :         return FALSE;

  001f4	0afffff5	 beq         |$LN262@ThreadRun@3|

; 3001 :     }
; 3002 : 
; 3003 :     m_pOTG->dwSysIntr = m_dwSysIntr;    

  001f8	e5952074	 ldr         r2, [r5, #0x74]
  001fc	e5953068	 ldr         r3, [r5, #0x68]

; 3004 :     m_pOTG->hSysIntrEvent = m_hIntrEvent;
; 3005 :     DEBUGMSG(ZONE_OTG_INFO, (TEXT("OTG -> Set SYSINTR = 0x%x\r\n"), m_pOTG->dwSysIntr));
; 3006 :     // Ready to run the DMA thread
; 3007 :     m_pIdGnd->Init();

  00200	e5823050	 str         r3, [r2, #0x50]
  00204	e5952074	 ldr         r2, [r5, #0x74]
  00208	e5953070	 ldr         r3, [r5, #0x70]
  0020c	e5823054	 str         r3, [r2, #0x54]
  00210	e595007c	 ldr         r0, [r5, #0x7C]
  00214	e5903000	 ldr         r3, [r0]
  00218	e5933008	 ldr         r3, [r3, #8]
  0021c	e1a0e00f	 mov         lr, pc
  00220	e12fff13	 bx          r3

; 3008 :     m_pDMA->Init();

  00224	e5950078	 ldr         r0, [r5, #0x78]
  00228	e5903000	 ldr         r3, [r0]
  0022c	e5933008	 ldr         r3, [r3, #8]
  00230	e1a0e00f	 mov         lr, pc
  00234	e12fff13	 bx          r3

; 3009 : 
; 3010 :     // Enable the interrupt now
; 3011 :     OUTREG8(&pGen->IntrUSBE, INTRUSB_ALL&~INTRUSB_SOF);  // Enable all interrupts except SOF.

  00238	e3a030f7	 mov         r3, #0xF7

; 3012 :     OUTREG16(&pGen->IntrTxE, 0xffff);

  0023c	e3a020ff	 mov         r2, #0xFF
  00240	e5c6300b	 strb        r3, [r6, #0xB]
  00244	e5c62006	 strb        r2, [r6, #6]

; 3013 :     OUTREG16(&pGen->IntrRxE, 0xfffe);

  00248	e3a030fe	 mov         r3, #0xFE
  0024c	e5c62007	 strb        r2, [r6, #7]
  00250	e5c63008	 strb        r3, [r6, #8]
  00254	e5c62009	 strb        r2, [r6, #9]

; 3014 : 
; 3015 :     OUTREG8(&pGen->Testmode,0);    

  00258	e5c6700f	 strb        r7, [r6, #0xF]

; 3016 : 
; 3017 :     // Set connection bit here, ready to process
; 3018 : 
; 3019 :     // Disable the session request bit for devctl
; 3020 :     DEBUGMSG(ZONE_OTG_INFO, (TEXT("DevCtl = 0x%x\r\n"), INREG8(&pGen->DevCtl)));
; 3021 :     CLRREG8(&pGen->DevCtl, DEVCTL_SESSION);

  0025c	e5d63060	 ldrb        r3, [r6, #0x60]

; 3022 :     DEBUGMSG(ZONE_OTG_INFO, (TEXT("Waiting ...\r\n")));
; 3023 :     DEBUGMSG(ZONE_OTG_INFO, (TEXT("DevCtl = 0x%x\r\n"), INREG8(&pGen->DevCtl)));
; 3024 :     DEBUGMSG(ZONE_OTG_INFO, (TEXT("IntrTxE = 0x%x\r\n"), INREG16(&pGen->IntrTxE)));
; 3025 :     DEBUGMSG(ZONE_OTG_INFO, (TEXT("IntrRxE = 0x%x\r\n"), INREG16(&pGen->IntrRxE)));
; 3026 :     DEBUGMSG(ZONE_OTG_INFO, (TEXT("IntrUSBE = 0x%x\r\n"), INREG8(&pGen->IntrUSBE)));
; 3027 :     DEBUGMSG(ZONE_OTG_INFO, (TEXT("Power = 0x%x\r\n"), INREG8(&pGen->Power)));    
; 3028 : 
; 3029 :     ResetEndPoints();

  00260	e24500dc	 sub         r0, r5, #0xDC
  00264	e20330fe	 and         r3, r3, #0xFE
  00268	e5c63060	 strb        r3, [r6, #0x60]
  0026c	e51530dc	 ldr         r3, [r5, #-0xDC]
  00270	e59330ec	 ldr         r3, [r3, #0xEC]
  00274	e1a0e00f	 mov         lr, pc
  00278	e12fff13	 bx          r3

; 3030 : 
; 3031 :     m_timeout = m_OTGRegCfg.startupTimeout;

  0027c	e5953028	 ldr         r3, [r5, #0x28]

; 3032 : 
; 3033 :     if (m_OTGRegCfg.DisableHighSpeed)

  00280	e5952024	 ldr         r2, [r5, #0x24]

; 3034 :     {
; 3035 :         CLRREG8(&pGen->Power, POWER_HSENABLE);
; 3036 :         SETREG8(&pGen->Power, POWER_SOFTCONN);
; 3037 :     }
; 3038 :     else
; 3039 :     {
; 3040 :         SETREG8(&pGen->Power, POWER_SOFTCONN|POWER_HSENABLE);
; 3041 :     }
; 3042 :         
; 3043 :     CLRREG8(&pGen->Power, POWER_EN_SUSPENDM);    
; 3044 :     
; 3045 :     m_pTransceiver->SetVBusSource(TRUE);

  00284	e3a01001	 mov         r1, #1
  00288	e5853094	 str         r3, [r5, #0x94]
  0028c	e5d63001	 ldrb        r3, [r6, #1]
  00290	e3520000	 cmp         r2, #0
  00294	120330df	 andne       r3, r3, #0xDF
  00298	15c63001	 strneb      r3, [r6, #1]
  0029c	15d63001	 ldrneb      r3, [r6, #1]
  002a0	13833040	 orrne       r3, r3, #0x40
  002a4	03833060	 orreq       r3, r3, #0x60
  002a8	e5c63001	 strb        r3, [r6, #1]
  002ac	e5d63001	 ldrb        r3, [r6, #1]
  002b0	e20330fe	 and         r3, r3, #0xFE
  002b4	e5c63001	 strb        r3, [r6, #1]
  002b8	e5950020	 ldr         r0, [r5, #0x20]
  002bc	e5903000	 ldr         r3, [r0]
  002c0	e5933004	 ldr         r3, [r3, #4]
  002c4	e1a0e00f	 mov         lr, pc
  002c8	e12fff13	 bx          r3

; 3046 : 
; 3047 :     m_bOTGReady = TRUE;

  002cc	e3a03c01	 mov         r3, #1, 24
  002d0	e383a002	 orr         r10, r3, #2
  002d4	e3a03c27	 mov         r3, #0x27, 24
  002d8	e383b010	 orr         r11, r3, #0x10
  002dc	e3a03c13	 mov         r3, #0x13, 24
  002e0	e58580ac	 str         r8, [r5, #0xAC]
  002e4	e3838088	 orr         r8, r3, #0x88
  002e8	e3a03c0b	 mov         r3, #0xB, 24
  002ec	e38370b8	 orr         r7, r3, #0xB8
  002f0	e58da004	 str         r10, [sp, #4]
  002f4		 |$LL163@ThreadRun@3|

; 3048 : 
; 3049 :     while (!fTerminated)
; 3050 :     {                        
; 3051 :         DWORD rc;
; 3052 : 
; 3053 :         if (m_pTransceiver->SupportsTransceiverWakeWithoutClock())

  002f4	e5950020	 ldr         r0, [r5, #0x20]
  002f8	e5903000	 ldr         r3, [r0]
  002fc	e5933014	 ldr         r3, [r3, #0x14]
  00300	e1a0e00f	 mov         lr, pc
  00304	e12fff13	 bx          r3

; 3054 : 		{
; 3055 : 		    DWORD delta;
; 3056 : 
; 3057 :             // *** Using transceiver in TWL4030/TPS65xxx ***
; 3058 :             rc = WaitForSingleObject(m_hIntrEvent, m_timeout);

  00308	e5951094	 ldr         r1, [r5, #0x94]
  0030c	e3500000	 cmp         r0, #0
  00310	e5950070	 ldr         r0, [r5, #0x70]
  00314	0a000299	 beq         |$LN161@ThreadRun@3|
  00318	eb000000	 bl          WaitForSingleObject

; 3059 : 
; 3060 :             if (m_fPowerRequest)

  0031c	e59530c4	 ldr         r3, [r5, #0xC4]
  00320	e1a04000	 mov         r4, r0
  00324	e3530000	 cmp         r3, #0
  00328	0a000018	 beq         |$LN187@ThreadRun@3|

; 3061 :             {
; 3062 :                 m_fPowerRequest = FALSE;
; 3063 :                 SetPowerState(m_Dx);

  0032c	e51530dc	 ldr         r3, [r5, #-0xDC]
  00330	e5951018	 ldr         r1, [r5, #0x18]
  00334	e3a02000	 mov         r2, #0
  00338	e5933104	 ldr         r3, [r3, #0x104]
  0033c	e24500dc	 sub         r0, r5, #0xDC
  00340	e58520c4	 str         r2, [r5, #0xC4]
  00344	e1a0e00f	 mov         lr, pc
  00348	e12fff13	 bx          r3

; 3064 :                 if (m_Dx == D4)

  0034c	e5953018	 ldr         r3, [r5, #0x18]
  00350	e3530004	 cmp         r3, #4
  00354	1a000009	 bne         |$LN159@ThreadRun@3|

; 3065 :                 {
; 3066 :                     ResetEvent(m_hIntrEvent);

  00358	e5950070	 ldr         r0, [r5, #0x70]
  0035c	e3a01002	 mov         r1, #2
  00360	eb000000	 bl          EventModify

; 3067 :                     m_timeout = INFINITE;
; 3068 :                     SetEvent(m_pOTG->hPowerEvent);

  00364	e3e04000	 mvn         r4, #0
  00368	e5854094	 str         r4, [r5, #0x94]
  0036c		 |$LN257@ThreadRun@3|
  0036c	e5953074	 ldr         r3, [r5, #0x74]
  00370	e3a01003	 mov         r1, #3
  00374	e5930058	 ldr         r0, [r3, #0x58]
  00378	eb000000	 bl          EventModify

; 3069 :                     continue;

  0037c	eaffffdc	 b           |$LL163@ThreadRun@3|
  00380		 |$LN159@ThreadRun@3|

; 3070 :                 }
; 3071 :                 SetEvent(m_pOTG->hPowerEvent);

  00380	e5953074	 ldr         r3, [r5, #0x74]
  00384	e3a01003	 mov         r1, #3
  00388	e5930058	 ldr         r0, [r3, #0x58]
  0038c	eb000000	 bl          EventModify
  00390		 |$LN187@ThreadRun@3|

; 3072 :             }
; 3073 : 
; 3074 :             if (rc == WAIT_TIMEOUT)

  00390	e154000a	 cmp         r4, r10
  00394	1a0000c0	 bne         |$LN158@ThreadRun@3|

; 3075 :             {
; 3076 :                 m_pTransceiver->EnableWakeupInterrupt(TRUE);

  00398	e5950020	 ldr         r0, [r5, #0x20]
  0039c	e3a01001	 mov         r1, #1
  003a0	e5903000	 ldr         r3, [r0]
  003a4	e5933008	 ldr         r3, [r3, #8]
  003a8	e1a0e00f	 mov         lr, pc
  003ac	e12fff13	 bx          r3

; 3077 :                 if(m_timeout == DO_INACTIVITY_TIMEOUT || m_timeout == DO_DISCONNECT_TIMEOUT)

  003b0	e5953094	 ldr         r3, [r5, #0x94]
  003b4	e153000b	 cmp         r3, r11
  003b8	0a000001	 beq         |$LN156@ThreadRun@3|
  003bc	e3530ffa	 cmp         r3, #0xFA, 30
  003c0	1a000009	 bne         |$LN155@ThreadRun@3|
  003c4		 |$LN156@ThreadRun@3|

; 3078 :                 {
; 3079 :                     if(!(ReadULPIReg( m_pOTG, ULPI_VENDORID_LOW_R)))

  003c4	e5951074	 ldr         r1, [r5, #0x74]
  003c8	e3a02000	 mov         r2, #0
  003cc	e24500dc	 sub         r0, r5, #0xDC
  003d0	eb000000	 bl          |?ReadULPIReg@OMAPMHSUSBOTG@@QAAEPAUHSMUSB_T@@E@Z|
  003d4	e3500000	 cmp         r0, #0

; 3080 :                     {
; 3081 :                         SoftResetULPILink();

  003d8	051530dc	 ldreq       r3, [r5, #-0xDC]
  003dc	024500dc	 subeq       r0, r5, #0xDC
  003e0	059330fc	 ldreq       r3, [r3, #0xFC]
  003e4	01a0e00f	 moveq       lr, pc
  003e8	012fff13	 bxeq        r3
  003ec		 |$LN155@ThreadRun@3|

; 3082 :                     }
; 3083 :                 }
; 3084 :                 if(m_bSuspendTransceiver)

  003ec	e59530b4	 ldr         r3, [r5, #0xB4]
  003f0	e3530000	 cmp         r3, #0
  003f4	0a000060	 beq         |$LN154@ThreadRun@3|

; 3085 :                 {
; 3086 :                     if (m_pTransceiver->IsADeviceConnected())

  003f8	e5950020	 ldr         r0, [r5, #0x20]
  003fc	e5903000	 ldr         r3, [r0]
  00400	e5933030	 ldr         r3, [r3, #0x30]
  00404	e1a0e00f	 mov         lr, pc
  00408	e12fff13	 bx          r3
  0040c	e3500000	 cmp         r0, #0
  00410	0a000022	 beq         |$LN153@ThreadRun@3|

; 3087 :                     {
; 3088 :                         // Enable to SOFTCONN bit for PC to see the connection
; 3089 :                         CLRREG8(&pGen->Power, POWER_SOFTCONN);

  00414	e5d63001	 ldrb        r3, [r6, #1]

; 3326 : 
; 3327 :                     // Wait for 45 sec or until shell is ready which ever happens first
; 3328 :                     do{
; 3329 :                         delta = GetTickCount() - dwStartTime;
; 3330 :                         // Check wheather
; 3331 :                         if(bStratupWaitDone || delta >= m_OTGRegCfg.dwActiveSyncDelay )
; 3332 :                             break;
; 3333 :                         Sleep(1000);
; 3334 :                     }while (IsAPIReady(SH_SHELL) == FALSE);
; 3335 : 
; 3336 : 
; 3337 :                     bStratupWaitDone = TRUE;
; 3338 :                     // Enable to SOFTCONN bit for PC to see the connection
; 3339 :                     if (m_OTGRegCfg.DisableHighSpeed)

  00418	e59da000	 ldr         r10, [sp]
  0041c	e20330bf	 and         r3, r3, #0xBF
  00420	e5c63001	 strb        r3, [r6, #1]
  00424		 |$LL152@ThreadRun@3|
  00424	eb000000	 bl          GetTickCount
  00428	e3590000	 cmp         r9, #0
  0042c	1a000009	 bne         |$LN150@ThreadRun@3|
  00430	e5952034	 ldr         r2, [r5, #0x34]
  00434	e040300a	 sub         r3, r0, r10
  00438	e1530002	 cmp         r3, r2
  0043c	2a000005	 bcs         |$LN150@ThreadRun@3|
  00440	e3a00ffa	 mov         r0, #0xFA, 30
  00444	eb000000	 bl          Sleep
  00448	e3a00055	 mov         r0, #0x55
  0044c	eb000000	 bl          IsAPIReady
  00450	e3500000	 cmp         r0, #0
  00454	0afffff2	 beq         |$LL152@ThreadRun@3|
  00458		 |$LN150@ThreadRun@3|

; 3090 : 
; 3091 :                         // Wait for 45 sec or until shell is ready which ever happens first
; 3092 :                         do{
; 3093 :                         delta = GetTickCount() - dwStartTime;
; 3094 :                         // Check wheather
; 3095 :                         if(bStratupWaitDone || delta >= m_OTGRegCfg.dwActiveSyncDelay )
; 3096 :                         break;
; 3097 :                         Sleep(1000);
; 3098 :                         }while (IsAPIReady(SH_SHELL) == FALSE);
; 3099 : 
; 3100 :                         bStratupWaitDone = TRUE;
; 3101 : 
; 3102 :                         // Enable to SOFTCONN bit for PC to see the connection
; 3103 :                         if (m_OTGRegCfg.DisableHighSpeed)

  00458	e5953024	 ldr         r3, [r5, #0x24]
  0045c	e59da004	 ldr         r10, [sp, #4]
  00460	e3a09001	 mov         r9, #1
  00464	e3530000	 cmp         r3, #0

; 3104 : 						{
; 3105 :                             CLRREG8(&pGen->Power, POWER_HSENABLE);

  00468	e5d63001	 ldrb        r3, [r6, #1]
  0046c	120330df	 andne       r3, r3, #0xDF
  00470	15c63001	 strneb      r3, [r6, #1]

; 3106 :                             SETREG8(&pGen->Power, POWER_SOFTCONN);

  00474	15d63001	 ldrneb      r3, [r6, #1]
  00478	13833040	 orrne       r3, r3, #0x40

; 3107 : 						}
; 3108 :                         else
; 3109 :                             SETREG8(&pGen->Power, POWER_SOFTCONN|POWER_HSENABLE);

  0047c	03833060	 orreq       r3, r3, #0x60
  00480	e5c63001	 strb        r3, [r6, #1]

; 3110 : 
; 3111 :                         // This is to put MUSB Controller functional if it is in host mode
; 3112 :                         CLRREG8(&pGen->Power, POWER_EN_SUSPENDM);

  00484	e5d63001	 ldrb        r3, [r6, #1]
  00488	e20330fe	 and         r3, r3, #0xFE
  0048c	e5c63001	 strb        r3, [r6, #1]

; 3113 :                         CLRREG8(&pGen->Power, POWER_SUSPENDM);

  00490	e5d63001	 ldrb        r3, [r6, #1]
  00494	e20330fd	 and         r3, r3, #0xFD
  00498	e5c63001	 strb        r3, [r6, #1]
  0049c	eaffff94	 b           |$LL163@ThreadRun@3|
  004a0		 |$LN153@ThreadRun@3|

; 3114 :                         continue;
; 3115 :                     }
; 3116 :                     else if(m_pTransceiver->IsBDeviceConnected())

  004a0	e5950020	 ldr         r0, [r5, #0x20]
  004a4	e5903000	 ldr         r3, [r0]
  004a8	e5933034	 ldr         r3, [r3, #0x34]
  004ac	e1a0e00f	 mov         lr, pc
  004b0	e12fff13	 bx          r3
  004b4	e3500000	 cmp         r0, #0
  004b8	0a00000f	 beq         |$LN144@ThreadRun@3|

; 3117 :                     {
; 3118 :                         RETAILMSG(1, (TEXT("Calling Session Request%d\r\n"),__LINE__));

  004bc	e59f0fe0	 ldr         r0, [pc, #0xFE0]
  004c0	e3a03b03	 mov         r3, #3, 22
  004c4	e383102e	 orr         r1, r3, #0x2E
  004c8	eb000000	 bl          NKDbgPrintfW

; 3119 :                         SessionRequest(FALSE, FALSE);

  004cc	e51530dc	 ldr         r3, [r5, #-0xDC]
  004d0	e3a02000	 mov         r2, #0
  004d4	e3a01000	 mov         r1, #0
  004d8	e5933084	 ldr         r3, [r3, #0x84]
  004dc	e24500dc	 sub         r0, r5, #0xDC
  004e0	e1a0e00f	 mov         lr, pc
  004e4	e12fff13	 bx          r3

; 3120 :                         CLRREG8(&m_pOTG->pUsbGenRegs->DevCtl, DEVCTL_HOSTREQ);

  004e8	e5953074	 ldr         r3, [r5, #0x74]
  004ec	e5932020	 ldr         r2, [r3, #0x20]
  004f0	e5d23060	 ldrb        r3, [r2, #0x60]
  004f4	e20330fd	 and         r3, r3, #0xFD
  004f8	e5c23060	 strb        r3, [r2, #0x60]
  004fc		 |$LN144@ThreadRun@3|

; 3121 :                     }
; 3122 : 
; 3123 :                     m_dwUSBUsageCount = 0;
; 3124 : 
; 3125 :                     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("+(m_timeout == DO_TRANSCEIVER_SUSPEND_TIMEOUT)\r\n")));
; 3126 : 
; 3127 :                     StopUSBClock();

  004fc	e51530dc	 ldr         r3, [r5, #-0xDC]
  00500	e3a04000	 mov         r4, #0
  00504	e24500dc	 sub         r0, r5, #0xDC
  00508	e59330e8	 ldr         r3, [r3, #0xE8]
  0050c	e5854084	 str         r4, [r5, #0x84]
  00510	e1a0e00f	 mov         lr, pc
  00514	e12fff13	 bx          r3

; 3128 :                     EnterCriticalSection(&m_pOTG->regCS);

  00518	e5953074	 ldr         r3, [r5, #0x74]
  0051c	e2830038	 add         r0, r3, #0x38
  00520	eb000000	 bl          EnterCriticalSection

; 3129 :                     m_pOTG->bClockStatus = FALSE;

  00524	e5953074	 ldr         r3, [r5, #0x74]
  00528	e5834060	 str         r4, [r3, #0x60]

; 3130 :                     UpdateDevicePower(m_hParent, D4, NULL);

  0052c	e59f4f6c	 ldr         r4, [pc, #0xF6C]
  00530	e5950064	 ldr         r0, [r5, #0x64]
  00534	e5943000	 ldr         r3, [r4]
  00538	e3530004	 cmp         r3, #4
  0053c	13a03004	 movne       r3, #4
  00540	13a02000	 movne       r2, #0
  00544	13a01004	 movne       r1, #4
  00548	15843000	 strne       r3, [r4]
  0054c	1b000000	 blne        SetDevicePowerState

; 3131 :                     LeaveCriticalSection(&m_pOTG->regCS);

  00550	e5953074	 ldr         r3, [r5, #0x74]
  00554	e2830038	 add         r0, r3, #0x38
  00558	eb000000	 bl          LeaveCriticalSection

; 3132 : 
; 3133 :                     m_timeout = INFINITE;
; 3134 :                     m_bSuspendTransceiver = FALSE;
; 3135 :                     m_pOTG->dwPwrMgmt = MODE_SYSTEM_SUSPEND;

  0055c	e3e02000	 mvn         r2, #0
  00560	e5852094	 str         r2, [r5, #0x94]
  00564	e3a02000	 mov         r2, #0
  00568	e58520b4	 str         r2, [r5, #0xB4]
  0056c	e3a02001	 mov         r2, #1
  00570		 |$LN252@ThreadRun@3|
  00570	e5953074	 ldr         r3, [r5, #0x74]
  00574	e5832064	 str         r2, [r3, #0x64]

; 3136 : 
; 3137 :                     continue;

  00578	eaffff5d	 b           |$LL163@ThreadRun@3|
  0057c		 |$LN154@ThreadRun@3|

; 3138 :                 }
; 3139 : 
; 3140 :                 m_timeout = INFINITE;
; 3141 : 
; 3142 :                 if (m_pOTG->operateMode == HOST_MODE)

  0057c	e5950074	 ldr         r0, [r5, #0x74]
  00580	e3e03000	 mvn         r3, #0
  00584	e5853094	 str         r3, [r5, #0x94]
  00588	e5d02035	 ldrb        r2, [r0, #0x35]
  0058c	e3520002	 cmp         r2, #2
  00590	0affff57	 beq         |$LL163@ThreadRun@3|

; 3143 :                 {
; 3144 :                     //EnableSuspend(TRUE);
; 3145 :                 }
; 3146 :                 else if (m_pOTG->operateMode == DEVICE_MODE)

  00594	e3520001	 cmp         r2, #1
  00598	0affff55	 beq         |$LL163@ThreadRun@3|

; 3147 :                 {
; 3148 :                 }
; 3149 :                 else
; 3150 :                 {
; 3151 :                     // If you are here, it can be either IDLE_MODE or SUSPEND_MODE
; 3152 :                     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("StopUSBClock with operateMode=%d, m_dwStatus=0x%x\r\n"),
; 3153 :                         m_pOTG->operateMode, m_dwStatus));
; 3154 : 
; 3155 :                     if ((m_dwStatus & STATUS_HNP_SESSION_MASK) == 0)

  0059c	e595301c	 ldr         r3, [r5, #0x1C]
  005a0	e3130030	 tst         r3, #0x30
  005a4	1affff52	 bne         |$LL163@ThreadRun@3|

; 3156 :                     {
; 3157 : 
; 3158 :                         if ((m_dwStatus & STATUS_SESSION_RESTART)
; 3159 :                             && ((m_dwStatus & STATUS_WAIT_HOST_DISCONN_COMPLETE) == 0x00)
; 3160 :                             && (m_pOTG->operateMode == IDLE_MODE))

  005a8	e3130080	 tst         r3, #0x80
  005ac	0a000020	 beq         |$LN138@ThreadRun@3|
  005b0	e3130040	 tst         r3, #0x40
  005b4	1a00001e	 bne         |$LN138@ThreadRun@3|
  005b8	e3520000	 cmp         r2, #0
  005bc	1a00001c	 bne         |$LN138@ThreadRun@3|

; 3161 :                         {
; 3162 : 
; 3163 :                             DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Try session restart\r\n")));
; 3164 :                             if (m_pOTG->pFuncs[DEVICE_MODE-1] != NULL)

  005c0	e5903008	 ldr         r3, [r0, #8]
  005c4	e3530000	 cmp         r3, #0

; 3165 :                                 m_pOTG->pFuncs[DEVICE_MODE-1]->Disconnect((void *)m_pOTG);

  005c8	15933018	 ldrne       r3, [r3, #0x18]
  005cc	11a0e00f	 movne       lr, pc
  005d0	112fff13	 bxne        r3

; 3166 : 
; 3167 :                             SessionRequest(FALSE, FALSE);

  005d4	e51530dc	 ldr         r3, [r5, #-0xDC]
  005d8	e3a02000	 mov         r2, #0
  005dc	e3a01000	 mov         r1, #0
  005e0	e5933084	 ldr         r3, [r3, #0x84]
  005e4	e24500dc	 sub         r0, r5, #0xDC
  005e8	e1a0e00f	 mov         lr, pc
  005ec	e12fff13	 bx          r3

; 3168 :                             CLRREG8(&m_pOTG->pUsbGenRegs->DevCtl, DEVCTL_HOSTREQ);

  005f0	e5953074	 ldr         r3, [r5, #0x74]

; 3169 :                             SessionRequest(TRUE, TRUE);

  005f4	e3a02001	 mov         r2, #1
  005f8	e3a01001	 mov         r1, #1
  005fc	e5934020	 ldr         r4, [r3, #0x20]
  00600	e24500dc	 sub         r0, r5, #0xDC
  00604	e5d43060	 ldrb        r3, [r4, #0x60]
  00608	e20330fd	 and         r3, r3, #0xFD
  0060c	e5c43060	 strb        r3, [r4, #0x60]
  00610	e51530dc	 ldr         r3, [r5, #-0xDC]
  00614	e5933084	 ldr         r3, [r3, #0x84]
  00618	e1a0e00f	 mov         lr, pc
  0061c	e12fff13	 bx          r3
  00620		 |$LN247@ThreadRun@3|

; 3170 :                             m_dwStatus &= ~STATUS_SESSION_RESTART;

  00620	e595301c	 ldr         r3, [r5, #0x1C]

; 3171 :                             m_timeout = DO_SESSCHK_TIMEOUT;

  00624	e5858094	 str         r8, [r5, #0x94]
  00628	e3c33080	 bic         r3, r3, #0x80
  0062c	e585301c	 str         r3, [r5, #0x1C]
  00630	eaffff2f	 b           |$LL163@ThreadRun@3|
  00634		 |$LN138@ThreadRun@3|

; 3172 :                         }
; 3173 :                         else if ((m_dwStatus & STATUS_WAIT_HOST_DISCONN_COMPLETE) == 0x00)

  00634	e3130040	 tst         r3, #0x40
  00638	1affff2d	 bne         |$LL163@ThreadRun@3|

; 3174 :                         {
; 3175 :                             DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("+(m_dwStatus & STATUS_WAIT_HOST_DISCONN_COMPLETE) == 0x00\r\n")));
; 3176 :                             if(m_disconnected || ((INREG8(&pGen->DevCtl) & DEVCTL_SESSION) == 0))

  0063c	e59530b0	 ldr         r3, [r5, #0xB0]
  00640	e3530000	 cmp         r3, #0
  00644	1a000002	 bne         |$LN133@ThreadRun@3|
  00648	e5d63060	 ldrb        r3, [r6, #0x60]
  0064c	e3130001	 tst         r3, #1
  00650	1affff27	 bne         |$LL163@ThreadRun@3|
  00654		 |$LN133@ThreadRun@3|

; 3177 :                             {
; 3178 :                                 ResetEndPoints();

  00654	e51530dc	 ldr         r3, [r5, #-0xDC]
  00658	e24500dc	 sub         r0, r5, #0xDC
  0065c	e59330ec	 ldr         r3, [r3, #0xEC]
  00660	e1a0e00f	 mov         lr, pc
  00664	e12fff13	 bx          r3

; 3179 :                                 m_pTransceiver->EnableWakeupInterrupt(TRUE);

  00668	e5950020	 ldr         r0, [r5, #0x20]
  0066c	e3a01001	 mov         r1, #1
  00670	e5903000	 ldr         r3, [r0]
  00674	e5933008	 ldr         r3, [r3, #8]
  00678	e1a0e00f	 mov         lr, pc
  0067c	e12fff13	 bx          r3

; 3180 : 
; 3181 :                                 m_timeout = DO_TRANSCEIVER_SUSPEND_TIMEOUT;

  00680	e3a02c0b	 mov         r2, #0xB, 24
  00684	e38230c7	 orr         r3, r2, #0xC7
  00688	e5853094	 str         r3, [r5, #0x94]

; 3182 :                                 m_bIncCount = TRUE;

  0068c	e3a03001	 mov         r3, #1
  00690	e58530a4	 str         r3, [r5, #0xA4]

; 3183 :                                 //m_disconnected = FALSE;
; 3184 :                                 m_bSuspendTransceiver = TRUE;

  00694	e58530b4	 str         r3, [r5, #0xB4]

; 3185 :                             }
; 3186 :                         }
; 3187 :                     }
; 3188 :                 }
; 3189 : 
; 3190 :                 continue;

  00698	eaffff15	 b           |$LL163@ThreadRun@3|
  0069c		 |$LN158@ThreadRun@3|

; 3191 :             }
; 3192 :             else
; 3193 :             {
; 3194 :                 if ((m_dwStatus & STATUS_SESSION_RESTART)
; 3195 :                     && ((m_dwStatus & STATUS_WAIT_HOST_DISCONN_COMPLETE) == 0x00)
; 3196 :                     && (m_pOTG->operateMode == IDLE_MODE))

  0069c	e595301c	 ldr         r3, [r5, #0x1C]
  006a0	e3130080	 tst         r3, #0x80
  006a4	0a00000d	 beq         |$LN131@ThreadRun@3|
  006a8	e3130040	 tst         r3, #0x40
  006ac	1a00000b	 bne         |$LN131@ThreadRun@3|
  006b0	e5950074	 ldr         r0, [r5, #0x74]
  006b4	e5d03035	 ldrb        r3, [r0, #0x35]
  006b8	e3530000	 cmp         r3, #0
  006bc	1a000007	 bne         |$LN131@ThreadRun@3|

; 3197 :                 {
; 3198 : 
; 3199 :                     if (m_pOTG->pFuncs[DEVICE_MODE-1] != NULL)

  006c0	e5903008	 ldr         r3, [r0, #8]
  006c4	e3530000	 cmp         r3, #0

; 3200 :                         m_pOTG->pFuncs[DEVICE_MODE-1]->Disconnect((void *)m_pOTG);

  006c8	15933018	 ldrne       r3, [r3, #0x18]
  006cc	11a0e00f	 movne       lr, pc
  006d0	112fff13	 bxne        r3

; 3201 : 
; 3202 :                     m_dwStatus &= ~STATUS_SESSION_RESTART;

  006d4	e595301c	 ldr         r3, [r5, #0x1C]
  006d8	e3c33080	 bic         r3, r3, #0x80
  006dc	e585301c	 str         r3, [r5, #0x1C]
  006e0		 |$LN131@ThreadRun@3|

; 3203 :                 }
; 3204 : 
; 3205 :                 StartUSBClock(m_bIncCount);

  006e0	e51530dc	 ldr         r3, [r5, #-0xDC]
  006e4	e59510a4	 ldr         r1, [r5, #0xA4]
  006e8	e24500dc	 sub         r0, r5, #0xDC
  006ec	e59330e4	 ldr         r3, [r3, #0xE4]
  006f0	e1a0e00f	 mov         lr, pc
  006f4	e12fff13	 bx          r3

; 3206 :                 m_bIncCount = FALSE;
; 3207 :                 if (m_dwStatus & STATUS_SESSION_RESTART)

  006f8	e595301c	 ldr         r3, [r5, #0x1C]

; 3208 :                     m_timeout = DO_SUSPEND_TIMEOUT;
; 3209 :                 else
; 3210 :                     m_timeout = INFINITE;
; 3211 : 
; 3212 :             }
; 3213 : 
; 3214 :             m_pOTG->intr_usb = INREG8(&m_pOTG->pUsbGenRegs->IntrUSB);

  006fc	e5952074	 ldr         r2, [r5, #0x74]
  00700	e3a04000	 mov         r4, #0
  00704	e3130080	 tst         r3, #0x80
  00708	03e03000	 mvneq       r3, #0
  0070c	15857094	 strne       r7, [r5, #0x94]
  00710	05853094	 streq       r3, [r5, #0x94]
  00714	e58540a4	 str         r4, [r5, #0xA4]
  00718	e5923020	 ldr         r3, [r2, #0x20]
  0071c	e5d3300a	 ldrb        r3, [r3, #0xA]
  00720	e5c23034	 strb        r3, [r2, #0x34]

; 3215 :             m_pOTG->intr_tx  |= INREG16(&m_pOTG->pUsbGenRegs->IntrTx);

  00724	e5950074	 ldr         r0, [r5, #0x74]
  00728	e5903020	 ldr         r3, [r0, #0x20]
  0072c	e1d013b2	 ldrh        r1, [r0, #0x32]
  00730	e5d32002	 ldrb        r2, [r3, #2]
  00734	e5d33003	 ldrb        r3, [r3, #3]
  00738	e1823403	 orr         r3, r2, r3, lsl #8
  0073c	e1833001	 orr         r3, r3, r1
  00740	e1c033b2	 strh        r3, [r0, #0x32]

; 3216 :             m_pOTG->intr_rx  |= INREG16(&m_pOTG->pUsbGenRegs->IntrRx);

  00744	e5950074	 ldr         r0, [r5, #0x74]
  00748	e5903020	 ldr         r3, [r0, #0x20]
  0074c	e1d013b0	 ldrh        r1, [r0, #0x30]
  00750	e5d32004	 ldrb        r2, [r3, #4]
  00754	e5d33005	 ldrb        r3, [r3, #5]
  00758	e1823403	 orr         r3, r2, r3, lsl #8
  0075c	e1833001	 orr         r3, r3, r1
  00760	e1c033b0	 strh        r3, [r0, #0x30]

; 3217 : 
; 3218 :             DEBUGMSG(ZONE_OTG_FUNCTION,(TEXT("OTG Interrupts(0x%x) intr_tx(0x%x) intr_rx(0x%x)\n"), m_pOTG->intr_usb, m_pOTG->intr_tx, m_pOTG->intr_rx ));
; 3219 : 
; 3220 :             if (m_pOTG->dwPwrMgmt == MODE_SYSTEM_RESUME)

  00764	e5952074	 ldr         r2, [r5, #0x74]
  00768	e5923064	 ldr         r3, [r2, #0x64]
  0076c	e3530002	 cmp         r3, #2
  00770	1a000067	 bne         |$LN127@ThreadRun@3|

; 3221 :             {
; 3222 :                 if (m_pOTG->operateMode == HOST_MODE)

  00774	e5d23035	 ldrb        r3, [r2, #0x35]
  00778	e3530002	 cmp         r3, #2
  0077c	1a000043	 bne         |$LN126@ThreadRun@3|

; 3223 :                 {
; 3224 :                     DWORD dwPrevState = 0;
; 3225 : 
; 3226 :                     DEBUGMSG(1, (TEXT("Resume on Host Mode\r\n")));
; 3227 :                     if (INREG8(&pGen->Power) & POWER_RESUME)

  00780	e5d63001	 ldrb        r3, [r6, #1]
  00784	e3130004	 tst         r3, #4

; 3228 :                         CLRREG8(&pGen->Power, POWER_RESUME);

  00788	15d63001	 ldrneb      r3, [r6, #1]
  0078c	120330fb	 andne       r3, r3, #0xFB
  00790	15c63001	 strneb      r3, [r6, #1]

; 3229 : 
; 3230 :                     if ( ((INREG8(&pGen->DevCtl) & DEVCTL_SESSION) == 0) || ((m_pOTG->intr_usb & INTRUSB_SUSPEND) != 0) )

  00794	e5d63060	 ldrb        r3, [r6, #0x60]
  00798	e3130001	 tst         r3, #1
  0079c	0a00000a	 beq         |$LN123@ThreadRun@3|
  007a0	e5953074	 ldr         r3, [r5, #0x74]
  007a4	e5d33034	 ldrb        r3, [r3, #0x34]
  007a8	e3130001	 tst         r3, #1
  007ac	1a000006	 bne         |$LN123@ThreadRun@3|

; 3258 :                     }
; 3259 :                     else
; 3260 :                     {
; 3261 :                         SoftResetMUSBController();

  007b0	e51530dc	 ldr         r3, [r5, #-0xDC]
  007b4	e3a01000	 mov         r1, #0
  007b8	e24500dc	 sub         r0, r5, #0xDC
  007bc	e59330f8	 ldr         r3, [r3, #0xF8]
  007c0	e1a0e00f	 mov         lr, pc
  007c4	e12fff13	 bx          r3

; 3262 :                         m_timeout = DO_USBHOST_TIMEOUT;
; 3263 :                     }
; 3264 :                 }
; 3265 :                 else

  007c8	ea00004d	 b           |$LN250@ThreadRun@3|
  007cc		 |$LN123@ThreadRun@3|

; 3231 :                     {
; 3232 :                         DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Resume Host Mode with request session again\r\n")));
; 3233 :                         ResetEndPoints();

  007cc	e51530dc	 ldr         r3, [r5, #-0xDC]
  007d0	e24500dc	 sub         r0, r5, #0xDC
  007d4	e59330ec	 ldr         r3, [r3, #0xEC]
  007d8	e1a0e00f	 mov         lr, pc
  007dc	e12fff13	 bx          r3

; 3234 :                         m_bRequestSession = TRUE;
; 3235 :                         m_pOTG->operateMode = IDLE_MODE;

  007e0	e5953074	 ldr         r3, [r5, #0x74]
  007e4	e3a02001	 mov         r2, #1
  007e8	e5852088	 str         r2, [r5, #0x88]
  007ec	e5c34035	 strb        r4, [r3, #0x35]

; 3236 :                         m_dwStatus |= STATUS_DISCONN_REQUEST;

  007f0	e595301c	 ldr         r3, [r5, #0x1C]

; 3237 :                         dwPrevState = m_pOTG->connect_status;

  007f4	e5951074	 ldr         r1, [r5, #0x74]
  007f8	e3833002	 orr         r3, r3, #2
  007fc	e585301c	 str         r3, [r5, #0x1C]
  00800	e5d1204c	 ldrb        r2, [r1, #0x4C]

; 3238 :                         m_pOTG->connect_status &= ~CONN_CCS;

  00804	e20230fe	 and         r3, r2, #0xFE
  00808	e5c1304c	 strb        r3, [r1, #0x4C]

; 3239 :                         if (dwPrevState & CONN_CCS)

  0080c	e3120001	 tst         r2, #1

; 3240 :                             m_pOTG->connect_status |= CONN_CSC;

  00810	e5952074	 ldr         r2, [r5, #0x74]
  00814	e5d2304c	 ldrb        r3, [r2, #0x4C]
  00818	13833002	 orrne       r3, r3, #2

; 3241 :                         else
; 3242 :                             m_pOTG->connect_status &= ~CONN_CSC;

  0081c	020330fd	 andeq       r3, r3, #0xFD
  00820	e5c2304c	 strb        r3, [r2, #0x4C]

; 3243 : 
; 3244 :                         if (m_pOTG->pFuncs[HOST_MODE-1] != NULL)

  00824	e5950074	 ldr         r0, [r5, #0x74]
  00828	e590300c	 ldr         r3, [r0, #0xC]
  0082c	e3530000	 cmp         r3, #0

; 3245 :                             m_pOTG->pFuncs[HOST_MODE-1]->Disconnect((void *)m_pOTG);

  00830	15933018	 ldrne       r3, [r3, #0x18]
  00834	11a0e00f	 movne       lr, pc
  00838	112fff13	 bxne        r3

; 3246 : 
; 3247 :                         SessionRequest(FALSE, FALSE);

  0083c	e51530dc	 ldr         r3, [r5, #-0xDC]
  00840	e3a02000	 mov         r2, #0
  00844	e3a01000	 mov         r1, #0
  00848	e5933084	 ldr         r3, [r3, #0x84]
  0084c	e24500dc	 sub         r0, r5, #0xDC
  00850	e1a0e00f	 mov         lr, pc
  00854	e12fff13	 bx          r3

; 3248 : 
; 3249 :                         m_disconnected = TRUE;
; 3250 :                         m_timeout = DO_SUSPEND_TIMEOUT;
; 3251 :                         Sleep(200);

  00858	e3a03001	 mov         r3, #1
  0085c	e3a000c8	 mov         r0, #0xC8
  00860	e58530b0	 str         r3, [r5, #0xB0]
  00864	e5857094	 str         r7, [r5, #0x94]
  00868	eb000000	 bl          Sleep

; 3252 :                         // Softreset the MUSB controller to recover from
; 3253 :                         // babble errors when Activesync is connected
; 3254 :                         SoftResetMUSBController();

  0086c	e51530dc	 ldr         r3, [r5, #-0xDC]
  00870	e3a01000	 mov         r1, #0
  00874	e24500dc	 sub         r0, r5, #0xDC
  00878	e59330f8	 ldr         r3, [r3, #0xF8]
  0087c	e1a0e00f	 mov         lr, pc
  00880	e12fff13	 bx          r3

; 3255 : 
; 3256 : 		                m_pOTG->dwPwrMgmt = MODE_SYSTEM_NORMAL;

  00884	e5953074	 ldr         r3, [r5, #0x74]
  00888	e5834064	 str         r4, [r3, #0x64]

; 3257 :                         continue;

  0088c	eafffe98	 b           |$LL163@ThreadRun@3|
  00890		 |$LN126@ThreadRun@3|

; 3266 :                 {
; 3267 :                     BYTE  devCtl = INREG8(&m_pOTG->pUsbGenRegs->DevCtl);
; 3268 : 
; 3269 :                     // This condition occur either on wakeup from suspend (no devices connected before suspend)
; 3270 :                     // or an USB_PRES interrupt detected
; 3271 : 
; 3272 :                     // Identify if a A or B device is connected and set the session bit only when there is a
; 3273 :                     // device connected.
; 3274 :                     // Setting a session bit without any device connected is causing USB_PRES interrupt
; 3275 : 
; 3276 :                     // VBUS state changes  immediately from VBUSVALID to "VBUS Above AValid, below VBusValid" on
; 3277 :                     // cable removal so check for VBUSVALID instead of T2 TWL_STS_VBUS
; 3278 :                     SoftResetMUSBController();

  00890	e51530dc	 ldr         r3, [r5, #-0xDC]
  00894	e5922020	 ldr         r2, [r2, #0x20]
  00898	e3a01000	 mov         r1, #0
  0089c	e59330f8	 ldr         r3, [r3, #0xF8]
  008a0	e5d24060	 ldrb        r4, [r2, #0x60]
  008a4	e24500dc	 sub         r0, r5, #0xDC
  008a8	e1a0e00f	 mov         lr, pc
  008ac	e12fff13	 bx          r3

; 3279 :                     if (m_pTransceiver->IsBDeviceConnected() ||
; 3280 :                         ((devCtl & DEVCTL_VBUS) == DEVCTL_VBUSVALID))

  008b0	e5950020	 ldr         r0, [r5, #0x20]
  008b4	e5903000	 ldr         r3, [r0]
  008b8	e5933034	 ldr         r3, [r3, #0x34]
  008bc	e1a0e00f	 mov         lr, pc
  008c0	e12fff13	 bx          r3
  008c4	e3500000	 cmp         r0, #0
  008c8	1a000005	 bne         |$LN116@ThreadRun@3|
  008cc	e2043018	 and         r3, r4, #0x18
  008d0	e3530018	 cmp         r3, #0x18

; 3284 :                         }
; 3285 :                     else
; 3286 :                         {
; 3287 :                         // No Device attached
; 3288 :                         DEBUGMSG(ZONE_OTG_FUNCTION,(TEXT("NO Device Connected\n")));
; 3289 : 
; 3290 :                         // wait for interrupt
; 3291 :                         m_timeout = DO_USBCLK_TIMEOUT;
; 3292 :                         m_pOTG->dwPwrMgmt = MODE_SYSTEM_NORMAL;

  008d4	13a02003	 movne       r2, #3
  008d8	15852094	 strne       r2, [r5, #0x94]
  008dc	13a02000	 movne       r2, #0
  008e0	1affff22	 bne         |$LN252@ThreadRun@3|
  008e4		 |$LN116@ThreadRun@3|

; 3281 :                         {
; 3282 :                         SessionRequest(TRUE, TRUE);

  008e4	e51530dc	 ldr         r3, [r5, #-0xDC]
  008e8	e3a02001	 mov         r2, #1
  008ec	e3a01001	 mov         r1, #1
  008f0	e5933084	 ldr         r3, [r3, #0x84]
  008f4	e24500dc	 sub         r0, r5, #0xDC
  008f8	e1a0e00f	 mov         lr, pc
  008fc	e12fff13	 bx          r3
  00900	e3a04000	 mov         r4, #0
  00904		 |$LN250@ThreadRun@3|

; 3283 :                         m_timeout = DO_USBCLK_TIMEOUT;

  00904	e3a03003	 mov         r3, #3
  00908	e5853094	 str         r3, [r5, #0x94]

; 3293 :                         continue;
; 3294 :                         }
; 3295 :                 }
; 3296 : 
; 3297 :                 m_pOTG->dwPwrMgmt = MODE_SYSTEM_NORMAL;

  0090c	e5953074	 ldr         r3, [r5, #0x74]
  00910	e5834064	 str         r4, [r3, #0x64]
  00914		 |$LN127@ThreadRun@3|

; 3298 :             }
; 3299 : 
; 3300 :             DEBUGMSG(ZONE_OTG_FUNCTION,(TEXT("Interrupt Variable INTRUSB(0x%x) Devctl(0x%x)\n"), m_pOTG->intr_usb, INREG8(&m_pOTG->pUsbGenRegs->DevCtl)));
; 3301 :             if((!m_pOTG->intr_usb) && (!m_pOTG->intr_tx) && (!m_pOTG->intr_rx))

  00914	e5951074	 ldr         r1, [r5, #0x74]
  00918	e5d13034	 ldrb        r3, [r1, #0x34]
  0091c	e3530000	 cmp         r3, #0
  00920	1a000007	 bne         |$LN113@ThreadRun@3|
  00924	e1d133b2	 ldrh        r3, [r1, #0x32]
  00928	e3530000	 cmp         r3, #0
  0092c	1a000004	 bne         |$LN113@ThreadRun@3|
  00930	e1d133b0	 ldrh        r3, [r1, #0x30]
  00934	e3530000	 cmp         r3, #0

; 3302 :             {
; 3303 :                 if(m_timeout == INFINITE)

  00938	05953094	 ldreq       r3, [r5, #0x94]
  0093c	03730001	 cmneq       r3, #1

; 3304 :                 {
; 3305 :                     m_timeout = DO_SUSPEND_TIMEOUT;

  00940	05857094	 streq       r7, [r5, #0x94]
  00944		 |$LN113@ThreadRun@3|

; 3306 :                 }
; 3307 :                 DEBUGMSG(ZONE_OTG_FUNCTION,(TEXT("Interrupt Variable INTRUSB No interrupt at all\n")));
; 3308 :             }
; 3309 : 
; 3310 :             DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Interrupt Variable INTRUSB(0x%x), TX(0x%x), RX(0x%x), DevCtl(0x%x), m_dwStatus(0x%x)\r\n"),
; 3311 :                 m_pOTG->intr_usb, m_pOTG->intr_tx, m_pOTG->intr_rx, INREG8(&m_pOTG->pUsbGenRegs->DevCtl), m_dwStatus));
; 3312 : 
; 3313 :             if (m_dwStatus & STATUS_RETENTION_WAKEUP)

  00944	e595301c	 ldr         r3, [r5, #0x1C]
  00948	e3130c01	 tst         r3, #1, 24
  0094c	0a000054	 beq         |$LN112@ThreadRun@3|

; 3314 :             {
; 3315 :                 DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Status Retention with DevCtl Session = 0x%x\r\n"),
; 3316 :                     INREG8(&m_pOTG->pUsbGenRegs->DevCtl)));
; 3317 : 
; 3318 :                 if(!(ReadULPIReg( m_pOTG, ULPI_VENDORID_LOW_R)))

  00950	e3a02000	 mov         r2, #0
  00954	e24500dc	 sub         r0, r5, #0xDC
  00958	eb000000	 bl          |?ReadULPIReg@OMAPMHSUSBOTG@@QAAEPAUHSMUSB_T@@E@Z|
  0095c	e3500000	 cmp         r0, #0

; 3319 :                 {
; 3320 :                     SoftResetULPILink();

  00960	051530dc	 ldreq       r3, [r5, #-0xDC]
  00964	024500dc	 subeq       r0, r5, #0xDC
  00968	059330fc	 ldreq       r3, [r3, #0xFC]
  0096c	01a0e00f	 moveq       lr, pc
  00970	012fff13	 bxeq        r3

; 3321 :                 }
; 3322 :                 if (m_pTransceiver->IsADeviceConnected())

  00974	e5950020	 ldr         r0, [r5, #0x20]
  00978	e5903000	 ldr         r3, [r0]
  0097c	e5933030	 ldr         r3, [r3, #0x30]
  00980	e1a0e00f	 mov         lr, pc
  00984	e12fff13	 bx          r3
  00988	e3500000	 cmp         r0, #0
  0098c	0a000022	 beq         |$LN110@ThreadRun@3|

; 3323 :                 {
; 3324 :                     // Enable to SOFTCONN bit for PC to see the connection
; 3325 :                     CLRREG8(&pGen->Power, POWER_SOFTCONN);

  00990	e5d63001	 ldrb        r3, [r6, #1]

; 3326 : 
; 3327 :                     // Wait for 45 sec or until shell is ready which ever happens first
; 3328 :                     do{
; 3329 :                         delta = GetTickCount() - dwStartTime;
; 3330 :                         // Check wheather
; 3331 :                         if(bStratupWaitDone || delta >= m_OTGRegCfg.dwActiveSyncDelay )
; 3332 :                             break;
; 3333 :                         Sleep(1000);
; 3334 :                     }while (IsAPIReady(SH_SHELL) == FALSE);
; 3335 : 
; 3336 : 
; 3337 :                     bStratupWaitDone = TRUE;
; 3338 :                     // Enable to SOFTCONN bit for PC to see the connection
; 3339 :                     if (m_OTGRegCfg.DisableHighSpeed)

  00994	e59da000	 ldr         r10, [sp]
  00998	e20330bf	 and         r3, r3, #0xBF
  0099c	e5c63001	 strb        r3, [r6, #1]
  009a0		 |$LL109@ThreadRun@3|
  009a0	eb000000	 bl          GetTickCount
  009a4	e3590000	 cmp         r9, #0
  009a8	1a000009	 bne         |$LN107@ThreadRun@3|
  009ac	e5952034	 ldr         r2, [r5, #0x34]
  009b0	e040300a	 sub         r3, r0, r10
  009b4	e1530002	 cmp         r3, r2
  009b8	2a000005	 bcs         |$LN107@ThreadRun@3|
  009bc	e3a00ffa	 mov         r0, #0xFA, 30
  009c0	eb000000	 bl          Sleep
  009c4	e3a00055	 mov         r0, #0x55
  009c8	eb000000	 bl          IsAPIReady
  009cc	e3500000	 cmp         r0, #0
  009d0	0afffff2	 beq         |$LL109@ThreadRun@3|
  009d4		 |$LN107@ThreadRun@3|
  009d4	e5953024	 ldr         r3, [r5, #0x24]
  009d8	e59da004	 ldr         r10, [sp, #4]
  009dc	e3a09001	 mov         r9, #1
  009e0	e3530000	 cmp         r3, #0

; 3340 : 					{
; 3341 :                         CLRREG8(&pGen->Power, POWER_HSENABLE);

  009e4	e5d63001	 ldrb        r3, [r6, #1]
  009e8	120330df	 andne       r3, r3, #0xDF
  009ec	15c63001	 strneb      r3, [r6, #1]

; 3342 :                         SETREG8(&pGen->Power, POWER_SOFTCONN);

  009f0	15d63001	 ldrneb      r3, [r6, #1]
  009f4	13833040	 orrne       r3, r3, #0x40

; 3343 : 					}
; 3344 :                     else
; 3345 :                         SETREG8(&pGen->Power, POWER_SOFTCONN|POWER_HSENABLE);

  009f8	03833060	 orreq       r3, r3, #0x60
  009fc	e5c63001	 strb        r3, [r6, #1]

; 3346 : 
; 3347 :                     // This is to put MUSB Controller functional if it is in host mode
; 3348 :                     CLRREG8(&pGen->Power, POWER_EN_SUSPENDM);

  00a00	e5d63001	 ldrb        r3, [r6, #1]
  00a04	e20330fe	 and         r3, r3, #0xFE
  00a08	e5c63001	 strb        r3, [r6, #1]

; 3349 :                     CLRREG8(&pGen->Power, POWER_SUSPENDM);

  00a0c	e5d63001	 ldrb        r3, [r6, #1]
  00a10	e20330fd	 and         r3, r3, #0xFD
  00a14	e5c63001	 strb        r3, [r6, #1]

; 3350 :                 }
; 3351 :                 else

  00a18	ea000019	 b           |$LN99@ThreadRun@3|
  00a1c		 |$LN110@ThreadRun@3|

; 3352 :                 {
; 3353 :                     // Enable to SOFTCONN bit for PC to see the connection
; 3354 :                     if (m_OTGRegCfg.DisableHighSpeed)

  00a1c	e5953024	 ldr         r3, [r5, #0x24]
  00a20	e3530000	 cmp         r3, #0

; 3355 : 					{
; 3356 :                         CLRREG8(&pGen->Power, POWER_HSENABLE);

  00a24	e5d63001	 ldrb        r3, [r6, #1]
  00a28	120330df	 andne       r3, r3, #0xDF
  00a2c	15c63001	 strneb      r3, [r6, #1]

; 3357 :                         SETREG8(&pGen->Power, POWER_SOFTCONN);

  00a30	15d63001	 ldrneb      r3, [r6, #1]
  00a34	13833040	 orrne       r3, r3, #0x40

; 3358 : 					}
; 3359 :                     else
; 3360 :                         SETREG8(&pGen->Power, POWER_SOFTCONN|POWER_HSENABLE);

  00a38	03833060	 orreq       r3, r3, #0x60
  00a3c	e5c63001	 strb        r3, [r6, #1]

; 3361 : 
; 3362 :                     // This is to put MUSB Controller functional if it is in host mode
; 3363 :                     CLRREG8(&pGen->Power, POWER_EN_SUSPENDM);

  00a40	e5d63001	 ldrb        r3, [r6, #1]
  00a44	e20330fe	 and         r3, r3, #0xFE
  00a48	e5c63001	 strb        r3, [r6, #1]

; 3364 :                     CLRREG8(&pGen->Power, POWER_SUSPENDM);

  00a4c	e5d63001	 ldrb        r3, [r6, #1]
  00a50	e20330fd	 and         r3, r3, #0xFD
  00a54	e5c63001	 strb        r3, [r6, #1]

; 3365 : 
; 3366 :                     if ((INREG8(&m_pOTG->pUsbGenRegs->DevCtl) & DEVCTL_SESSION) == 0)

  00a58	e5953074	 ldr         r3, [r5, #0x74]
  00a5c	e5933020	 ldr         r3, [r3, #0x20]
  00a60	e5d33060	 ldrb        r3, [r3, #0x60]
  00a64	e3130001	 tst         r3, #1

; 3367 :                     {
; 3368 :                         SessionRequest(TRUE, TRUE);

  00a68	051530dc	 ldreq       r3, [r5, #-0xDC]
  00a6c	03a02001	 moveq       r2, #1
  00a70	03a01001	 moveq       r1, #1
  00a74	05933084	 ldreq       r3, [r3, #0x84]
  00a78	024500dc	 subeq       r0, r5, #0xDC
  00a7c	01a0e00f	 moveq       lr, pc
  00a80	012fff13	 bxeq        r3
  00a84		 |$LN99@ThreadRun@3|

; 3369 :                     }
; 3370 :                 }
; 3371 : 
; 3372 :                 m_pOTG->dwPwrMgmt = MODE_SYSTEM_RESUME;

  00a84	e5953074	 ldr         r3, [r5, #0x74]
  00a88	e3a02002	 mov         r2, #2
  00a8c	e5832064	 str         r2, [r3, #0x64]

; 3373 : 
; 3374 :                 m_bSuspendTransceiver = FALSE;
; 3375 :                 m_dwStatus &= ~STATUS_RETENTION_WAKEUP;

  00a90	e595301c	 ldr         r3, [r5, #0x1C]
  00a94	e58540b4	 str         r4, [r5, #0xB4]

; 3376 :                 m_timeout = DO_SESSCHK_TIMEOUT;

  00a98	e5858094	 str         r8, [r5, #0x94]
  00a9c	e3c33c01	 bic         r3, r3, #1, 24
  00aa0	e585301c	 str         r3, [r5, #0x1C]
  00aa4		 |$LN112@ThreadRun@3|

; 3377 :             }
; 3378 : 
; 3379 :             if (m_dwStatus & STATUS_HNP_SESSION_PROCESS)

  00aa4	e595301c	 ldr         r3, [r5, #0x1C]
  00aa8	e3130020	 tst         r3, #0x20
  00aac	0a00000a	 beq         |$LN98@ThreadRun@3|

; 3380 :             {
; 3381 :                 DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("We can process role switch loading now\r\n")));
; 3382 :                 if ((INREG8(&m_pOTG->pUsbGenRegs->DevCtl) & DEVCTL_HOSTMODE) == 0x00)

  00ab0	e5952074	 ldr         r2, [r5, #0x74]
  00ab4	e5923020	 ldr         r3, [r2, #0x20]
  00ab8	e5d33060	 ldrb        r3, [r3, #0x60]
  00abc	e3130004	 tst         r3, #4

; 3383 :                     m_pOTG->intr_usb |= INTRUSB_RESET;

  00ac0	e5d23034	 ldrb        r3, [r2, #0x34]
  00ac4	03833004	 orreq       r3, r3, #4

; 3384 :                 else
; 3385 :                     m_pOTG->intr_usb |= INTRUSB_CONN;

  00ac8	13833010	 orrne       r3, r3, #0x10
  00acc	e5c23034	 strb        r3, [r2, #0x34]

; 3386 :                 m_dwStatus &= ~STATUS_HNP_SESSION_PROCESS;

  00ad0	e595301c	 ldr         r3, [r5, #0x1C]
  00ad4	e3c33020	 bic         r3, r3, #0x20
  00ad8	e585301c	 str         r3, [r5, #0x1C]
  00adc		 |$LN98@ThreadRun@3|

; 3387 :             }
; 3388 : 
; 3389 :             // Implement according to USB Interrupt Service Routine
; 3390 :             // USBOTGHS Functional Spec Rev 0.1 Figure 8.1 (89/174)
; 3391 : 
; 3392 :             if (m_pOTG->intr_usb)

  00adc	e5953074	 ldr         r3, [r5, #0x74]
  00ae0	e5d33034	 ldrb        r3, [r3, #0x34]
  00ae4	e3530000	 cmp         r3, #0

; 3393 :             {
; 3394 :                 OTG_ConfigISR_stage1();

  00ae8	151530dc	 ldrne       r3, [r5, #-0xDC]
  00aec	124500dc	 subne       r0, r5, #0xDC
  00af0	159330cc	 ldrne       r3, [r3, #0xCC]
  00af4	11a0e00f	 movne       lr, pc
  00af8	112fff13	 bxne        r3

; 3395 :             }
; 3396 : 
; 3397 :             if ((m_dwStatus & STATUS_HNP_SESSION_MASK) == 0x00)

  00afc	e595301c	 ldr         r3, [r5, #0x1C]
  00b00	e3130030	 tst         r3, #0x30
  00b04	1a00002d	 bne         |$LN87@ThreadRun@3|

; 3398 :             {
; 3399 :                 // Here is the handling of Tx/Rx
; 3400 :                 // First handling of Endpoint 0 interrupt first.
; 3401 :                 if (m_pOTG->intr_tx & INTR_EP(0))

  00b08	e5953074	 ldr         r3, [r5, #0x74]
  00b0c	e1d333b2	 ldrh        r3, [r3, #0x32]
  00b10	e3130001	 tst         r3, #1

; 3402 :                 {
; 3403 :                     OTG_ProcessEP0();

  00b14	151530dc	 ldrne       r3, [r5, #-0xDC]
  00b18	124500dc	 subne       r0, r5, #0xDC
  00b1c	159330d8	 ldrne       r3, [r3, #0xD8]
  00b20	11a0e00f	 movne       lr, pc
  00b24	112fff13	 bxne        r3

; 3404 :                 }
; 3405 : 
; 3406 :                 // It may be a bit odd of why not doing all the things in same loop
; 3407 :                 // but this is according to the functional spec. Reference: Inventra MUSBMHDRC
; 3408 :                 // Programmer's Guide pg 46
; 3409 :                 // Second now handling of Rx 1-15
; 3410 :                 i = 1;

  00b28	e3a04001	 mov         r4, #1
  00b2c	e3a02001	 mov         r2, #1
  00b30		 |$LL92@ThreadRun@3|

; 3411 :                 while (i <= 15)
; 3412 :                 {
; 3413 :                     if (m_pOTG->intr_rx & INTR_EP(i))

  00b30	e5953074	 ldr         r3, [r5, #0x74]
  00b34	e1d333b0	 ldrh        r3, [r3, #0x30]
  00b38	e1130412	 tst         r3, r2, lsl r4
  00b3c	0a000007	 beq         |$LN90@ThreadRun@3|

; 3414 :                         OTG_ProcessEPx((UCHAR)i, TRUE);

  00b40	e51530dc	 ldr         r3, [r5, #-0xDC]
  00b44	e3a02001	 mov         r2, #1
  00b48	e20410ff	 and         r1, r4, #0xFF
  00b4c	e59330dc	 ldr         r3, [r3, #0xDC]
  00b50	e24500dc	 sub         r0, r5, #0xDC
  00b54	e1a0e00f	 mov         lr, pc
  00b58	e12fff13	 bx          r3
  00b5c	e3a02001	 mov         r2, #1
  00b60		 |$LN90@ThreadRun@3|

; 3415 :                     i++;

  00b60	e2844001	 add         r4, r4, #1
  00b64	e354000f	 cmp         r4, #0xF
  00b68	dafffff0	 ble         |$LL92@ThreadRun@3|

; 3416 :                 }
; 3417 : 
; 3418 :                 // Third now handling of Tx 1-15
; 3419 :                 i = 1;
; 3420 :                 if (!(m_dwStatus & (STATUS_DISCONN_COMPLETE|STATUS_DISCONN_REQUEST)))

  00b6c	e595301c	 ldr         r3, [r5, #0x1C]
  00b70	e3a04001	 mov         r4, #1
  00b74	e313000a	 tst         r3, #0xA
  00b78	1a00000f	 bne         |$LN233@ThreadRun@3|
  00b7c	e3a02001	 mov         r2, #1
  00b80		 |$LL88@ThreadRun@3|

; 3421 :                 {
; 3422 :                     while (i <= 15)
; 3423 :                     {
; 3424 :                         if (m_pOTG->intr_tx & INTR_EP(i))

  00b80	e5953074	 ldr         r3, [r5, #0x74]
  00b84	e1d333b2	 ldrh        r3, [r3, #0x32]
  00b88	e1130412	 tst         r3, r2, lsl r4
  00b8c	0a000007	 beq         |$LN86@ThreadRun@3|

; 3425 :                             OTG_ProcessEPx((UCHAR)i, FALSE);

  00b90	e51530dc	 ldr         r3, [r5, #-0xDC]
  00b94	e3a02000	 mov         r2, #0
  00b98	e20410ff	 and         r1, r4, #0xFF
  00b9c	e59330dc	 ldr         r3, [r3, #0xDC]
  00ba0	e24500dc	 sub         r0, r5, #0xDC
  00ba4	e1a0e00f	 mov         lr, pc
  00ba8	e12fff13	 bx          r3
  00bac	e3a02001	 mov         r2, #1
  00bb0		 |$LN86@ThreadRun@3|

; 3426 :                         i++;

  00bb0	e2844001	 add         r4, r4, #1
  00bb4	e354000f	 cmp         r4, #0xF
  00bb8	dafffff0	 ble         |$LL88@ThreadRun@3|
  00bbc		 |$LN233@ThreadRun@3|

; 2935 : 
; 2936 :     // Now you have all drivers loading and hence can do the register on the bus...
; 2937 :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("OMAPMHSUSBOTG::ThreadRun: Enable Interrupt waiting for connection!!!\r\n")));
; 2938 : 
; 2939 :     StartUSBClock(TRUE);

  00bbc	e3a04000	 mov         r4, #0
  00bc0		 |$LN87@ThreadRun@3|

; 3427 :                     }
; 3428 :                 }
; 3429 :             }
; 3430 : 
; 3431 :             if (m_pOTG->intr_usb)

  00bc0	e5953074	 ldr         r3, [r5, #0x74]
  00bc4	e5d33034	 ldrb        r3, [r3, #0x34]
  00bc8	e3530000	 cmp         r3, #0

; 3432 :             {
; 3433 :                 OTG_ConfigISR_stage2();

  00bcc	151530dc	 ldrne       r3, [r5, #-0xDC]
  00bd0	124500dc	 subne       r0, r5, #0xDC
  00bd4	159330d0	 ldrne       r3, [r3, #0xD0]
  00bd8	11a0e00f	 movne       lr, pc
  00bdc	112fff13	 bxne        r3

; 3434 :             }
; 3435 : 
; 3436 :             if(m_handleVBUSError)

  00be0	e59530b8	 ldr         r3, [r5, #0xB8]
  00be4	e3530000	 cmp         r3, #0
  00be8	0a000009	 beq         |$LN84@ThreadRun@3|

; 3437 :             {
; 3438 :                 SessionRequest(TRUE, TRUE);

  00bec	e51530dc	 ldr         r3, [r5, #-0xDC]
  00bf0	e3a02001	 mov         r2, #1
  00bf4	e3a01001	 mov         r1, #1
  00bf8	e5933084	 ldr         r3, [r3, #0x84]
  00bfc	e24500dc	 sub         r0, r5, #0xDC
  00c00	e1a0e00f	 mov         lr, pc
  00c04	e12fff13	 bx          r3

; 3439 : 			    m_timeout = m_OTGRegCfg.startupTimeout;

  00c08	e5953028	 ldr         r3, [r5, #0x28]

; 3440 :                 m_handleVBUSError = FALSE;

  00c0c	e58540b8	 str         r4, [r5, #0xB8]
  00c10	e5853094	 str         r3, [r5, #0x94]
  00c14		 |$LN84@ThreadRun@3|

; 3441 :             }
; 3442 : 
; 3443 :             // We can clear the intr_usb, intr_tx & intr_rx
; 3444 :             if ((m_dwStatus & STATUS_HNP_SESSION_MASK) == 0x00)

  00c14	e595301c	 ldr         r3, [r5, #0x1C]

; 3445 :             {
; 3446 :                 m_pOTG->intr_rx = 0;
; 3447 :                 m_pOTG->intr_tx = 0;
; 3448 :             }
; 3449 :             m_pOTG->intr_usb = 0;
; 3450 : 
; 3451 :             if (m_dwStatus & STATUS_CONNECT)
; 3452 :             {
; 3453 :                 m_dwStatus &= ~STATUS_CONNECT;
; 3454 :                 if (m_pOTG->operateMode == HOST_MODE)
; 3455 :                     m_timeout = DO_USBHOST_TIMEOUT;

  00c18	e3a00003	 mov         r0, #3
  00c1c	e3130030	 tst         r3, #0x30
  00c20	05953074	 ldreq       r3, [r5, #0x74]
  00c24	01c343b0	 streqh      r4, [r3, #0x30]
  00c28	05953074	 ldreq       r3, [r5, #0x74]
  00c2c	01c343b2	 streqh      r4, [r3, #0x32]
  00c30	e5953074	 ldr         r3, [r5, #0x74]
  00c34	e5c34034	 strb        r4, [r3, #0x34]
  00c38	e595301c	 ldr         r3, [r5, #0x1C]
  00c3c	e3130001	 tst         r3, #1
  00c40	0a000007	 beq         |$LN80@ThreadRun@3|
  00c44	e5952074	 ldr         r2, [r5, #0x74]
  00c48	e3c33001	 bic         r3, r3, #1
  00c4c	e585301c	 str         r3, [r5, #0x1C]
  00c50	e5d23035	 ldrb        r3, [r2, #0x35]
  00c54	e3530002	 cmp         r3, #2

; 3456 :                 else
; 3457 :                     m_timeout = INFINITE;

  00c58	13e03000	 mvnne       r3, #0
  00c5c	05850094	 streq       r0, [r5, #0x94]
  00c60	15853094	 strne       r3, [r5, #0x94]
  00c64		 |$LN80@ThreadRun@3|

; 3458 :             }
; 3459 : 
; 3460 :             if ((m_dwStatus & STATUS_DISCONN_COMPLETE) && (m_pOTG->connect_status & CONN_DC))

  00c64	e595101c	 ldr         r1, [r5, #0x1C]
  00c68	e3110008	 tst         r1, #8
  00c6c	0a000033	 beq         |$LN239@ThreadRun@3|
  00c70	e5952074	 ldr         r2, [r5, #0x74]
  00c74	e5d2304c	 ldrb        r3, [r2, #0x4C]
  00c78	e3130004	 tst         r3, #4
  00c7c	0a00002f	 beq         |$LN239@ThreadRun@3|

; 3461 :             {
; 3462 :                 m_dwStatus &= ~(STATUS_DISCONN_COMPLETE|STATUS_WAIT_HOST_DISCONN_COMPLETE);

  00c80	e3c13048	 bic         r3, r1, #0x48
  00c84	e585301c	 str         r3, [r5, #0x1C]

; 3463 :                 m_pOTG->connect_status &= ~CONN_DC;

  00c88	e5d2304c	 ldrb        r3, [r2, #0x4C]
  00c8c	e20330fb	 and         r3, r3, #0xFB
  00c90	e5c2304c	 strb        r3, [r2, #0x4C]

; 3464 :                 if (m_bRequestSession)

  00c94	e5953088	 ldr         r3, [r5, #0x88]
  00c98	e3530000	 cmp         r3, #0
  00c9c	0a000008	 beq         |$LN78@ThreadRun@3|

; 3465 :                 {
; 3466 :                     m_bRequestSession = FALSE;
; 3467 :                     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Request Session Again\r\n")));
; 3468 :                     SessionRequest(TRUE, TRUE);

  00ca0	e51530dc	 ldr         r3, [r5, #-0xDC]
  00ca4	e3a02001	 mov         r2, #1
  00ca8	e3a01001	 mov         r1, #1
  00cac	e5933084	 ldr         r3, [r3, #0x84]
  00cb0	e24500dc	 sub         r0, r5, #0xDC
  00cb4	e5854088	 str         r4, [r5, #0x88]
  00cb8	e1a0e00f	 mov         lr, pc
  00cbc	e12fff13	 bx          r3

; 3469 :                 }
; 3470 :                 else

  00cc0	ea000011	 b           |$LN77@ThreadRun@3|
  00cc4		 |$LN78@ThreadRun@3|

; 3471 :                 {
; 3472 :                     if (m_bExtendOTGSuspend)

  00cc4	e59530a8	 ldr         r3, [r5, #0xA8]
  00cc8	e3530000	 cmp         r3, #0

; 3473 :                     {
; 3474 :                         m_bExtendOTGSuspend = FALSE;
; 3475 :                         m_timeout = DO_SESSCHK_TIMEOUT;
; 3476 :                     }
; 3477 :                     else
; 3478 :                     {
; 3479 :                         m_timeout = DO_USBCLK_TIMEOUT;
; 3480 :                     }
; 3481 :                     // Perform reset of all the endpoints, we need to do that.
; 3482 :                     if ((m_dwStatus & STATUS_HNP_SESSION_MASK) == 0x00)

  00ccc	e595301c	 ldr         r3, [r5, #0x1C]
  00cd0	15858094	 strne       r8, [r5, #0x94]
  00cd4	158540a8	 strne       r4, [r5, #0xA8]
  00cd8	05850094	 streq       r0, [r5, #0x94]
  00cdc	e3130030	 tst         r3, #0x30

; 3483 :                         ResetEndPoints();

  00ce0	051530dc	 ldreq       r3, [r5, #-0xDC]
  00ce4	024500dc	 subeq       r0, r5, #0xDC
  00ce8	059330ec	 ldreq       r3, [r3, #0xEC]
  00cec	01a0e00f	 moveq       lr, pc
  00cf0	012fff13	 bxeq        r3

; 3484 :                     m_pTransceiver->EnableWakeupInterrupt(TRUE);

  00cf4	e5950020	 ldr         r0, [r5, #0x20]
  00cf8	e3a01001	 mov         r1, #1
  00cfc	e5903000	 ldr         r3, [r0]
  00d00	e5933008	 ldr         r3, [r3, #8]
  00d04	e1a0e00f	 mov         lr, pc
  00d08	e12fff13	 bx          r3
  00d0c		 |$LN77@ThreadRun@3|

; 3485 : 
; 3486 :                     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Disconnect Complete and Set IOCTRL again\r\n")));
; 3487 :                 }
; 3488 : 
; 3489 :                 if (m_dwStatus & STATUS_HNP_SESSION_INIT)

  00d0c	e595301c	 ldr         r3, [r5, #0x1C]
  00d10	e3130010	 tst         r3, #0x10
  00d14	0a000009	 beq         |$LN239@ThreadRun@3|

; 3490 :                 {
; 3491 :                     // Check whether it is host mode connection or device mode connection
; 3492 :                     SetEvent(m_hIntrEvent);

  00d18	e5950070	 ldr         r0, [r5, #0x70]
  00d1c	e3a01003	 mov         r1, #3
  00d20	eb000000	 bl          EventModify

; 3493 :                     m_dwStatus |= STATUS_HNP_SESSION_PROCESS;

  00d24	e595301c	 ldr         r3, [r5, #0x1C]

; 3494 :                     m_dwStatus &= ~STATUS_HNP_SESSION_INIT;
; 3495 :                     DEBUGMSG(ZONE_OTG_HNP, (TEXT("m_bHNPSession set interrupt\r\n")));
; 3496 :                     m_timeout = INFINITE;

  00d28	e3e04000	 mvn         r4, #0
  00d2c	e5854094	 str         r4, [r5, #0x94]
  00d30	e3c33030	 bic         r3, r3, #0x30
  00d34	e3833020	 orr         r3, r3, #0x20
  00d38	e585301c	 str         r3, [r5, #0x1C]

; 3882 :                     m_dwStatus &= ~STATUS_HNP_SESSION_INIT;
; 3883 :                     DEBUGMSG(ZONE_OTG_HNP, (TEXT("m_bHNPSession set interrupt\r\n")));
; 3884 :                     m_timeout = INFINITE;

  00d3c	ea000000	 b           |$LN73@ThreadRun@3|
  00d40		 |$LN239@ThreadRun@3|

; 3494 :                     m_dwStatus &= ~STATUS_HNP_SESSION_INIT;
; 3495 :                     DEBUGMSG(ZONE_OTG_HNP, (TEXT("m_bHNPSession set interrupt\r\n")));
; 3496 :                     m_timeout = INFINITE;

  00d40	e3e04000	 mvn         r4, #0
  00d44		 |$LN73@ThreadRun@3|

; 3497 :                 }
; 3498 :             }
; 3499 : 
; 3500 :             if (m_dwStatus & STATUS_DISCONN_REQUEST)

  00d44	e595301c	 ldr         r3, [r5, #0x1C]
  00d48	e3130002	 tst         r3, #2

; 3501 :             {
; 3502 :                 m_dwStatus &= ~STATUS_DISCONN_REQUEST;

  00d4c	13c33002	 bicne       r3, r3, #2

; 3503 :                 m_dwStatus |= STATUS_DISCONN_COMPLETE;

  00d50	13833008	 orrne       r3, r3, #8
  00d54	1585301c	 strne       r3, [r5, #0x1C]

; 3504 :                 m_timeout = INFINITE;
; 3505 :             }
; 3506 : 
; 3507 :             if (m_dwStatus & STATUS_SUSPEND)

  00d58	e595301c	 ldr         r3, [r5, #0x1C]
  00d5c	15854094	 strne       r4, [r5, #0x94]
  00d60	e3130004	 tst         r3, #4
  00d64	0a0001c5	 beq         |$LN3@ThreadRun@3|

; 3508 :             {
; 3509 :                 m_dwStatus &= ~STATUS_SUSPEND;

  00d68	e3c33004	 bic         r3, r3, #4
  00d6c	e585301c	 str         r3, [r5, #0x1C]

; 3510 :                 // Need to set the infinite and wait for the disconnect signal complete
; 3511 :                 if (m_dwStatus & STATUS_WAIT_HOST_DISCONN_COMPLETE)

  00d70	e3130040	 tst         r3, #0x40

; 3512 :                     m_timeout = INFINITE;
; 3513 :                 else

  00d74	1a0001bc	 bne         |$LN263@ThreadRun@3|

; 3514 :                     m_timeout = DO_SUSPEND_TIMEOUT;

  00d78	e5857094	 str         r7, [r5, #0x94]

; 3515 :             }
; 3516 :             if(m_disconnected)
; 3517 :             {
; 3518 :                 m_timeout = DO_DISCONNECT_TIMEOUT;
; 3519 :             }
; 3520 :             else

  00d7c	ea0001bf	 b           |$LN3@ThreadRun@3|
  00d80		 |$LN161@ThreadRun@3|

; 3521 :             {
; 3522 :                 m_timeout = DO_INACTIVITY_TIMEOUT;
; 3523 :             }
; 3524 : 
; 3525 :             InterruptDone(m_dwSysIntr);
; 3526 :         }
; 3527 : 		else
; 3528 :         {
; 3529 :             // *** Using transceiver with pure ULPI interface ***
; 3530 : 
; 3531 :             rc = WaitForSingleObject(m_hIntrEvent, m_timeout);

  00d80	eb000000	 bl          WaitForSingleObject

; 3532 : 
; 3533 :             if (m_fPowerRequest)

  00d84	e59530c4	 ldr         r3, [r5, #0xC4]
  00d88	e1a04000	 mov         r4, r0
  00d8c	e3530000	 cmp         r3, #0
  00d90	0a000014	 beq         |$LN198@ThreadRun@3|

; 3534 :             {
; 3535 :                 DEBUGMSG(1, (TEXT("OTG m_fPowerRequest D%d\r\n"), m_Dx));
; 3536 :                 m_fPowerRequest = FALSE;
; 3537 :                 SetPowerState(m_Dx);

  00d94	e51530dc	 ldr         r3, [r5, #-0xDC]
  00d98	e5951018	 ldr         r1, [r5, #0x18]
  00d9c	e3a02000	 mov         r2, #0
  00da0	e5933104	 ldr         r3, [r3, #0x104]
  00da4	e24500dc	 sub         r0, r5, #0xDC
  00da8	e58520c4	 str         r2, [r5, #0xC4]
  00dac	e1a0e00f	 mov         lr, pc
  00db0	e12fff13	 bx          r3

; 3538 :                 if (m_Dx == D4)

  00db4	e5953018	 ldr         r3, [r5, #0x18]
  00db8	e3530004	 cmp         r3, #4
  00dbc	1a000005	 bne         |$LN64@ThreadRun@3|

; 3539 :                 {
; 3540 :                     ResetEvent(m_hIntrEvent);

  00dc0	e5950070	 ldr         r0, [r5, #0x70]
  00dc4	e3a01002	 mov         r1, #2
  00dc8	eb000000	 bl          EventModify

; 3541 :                     m_timeout = INFINITE;
; 3542 :                     SetEvent(m_pOTG->hPowerEvent);

  00dcc	e3e02000	 mvn         r2, #0
  00dd0	e5852094	 str         r2, [r5, #0x94]

; 3543 :                     continue;

  00dd4	eafffd64	 b           |$LN257@ThreadRun@3|
  00dd8		 |$LN64@ThreadRun@3|

; 3544 :                 }
; 3545 :                 SetEvent(m_pOTG->hPowerEvent);

  00dd8	e5953074	 ldr         r3, [r5, #0x74]
  00ddc	e3a01003	 mov         r1, #3
  00de0	e5930058	 ldr         r0, [r3, #0x58]
  00de4	eb000000	 bl          EventModify
  00de8		 |$LN198@ThreadRun@3|

; 3546 :             }
; 3547 : 
; 3548 :             if (m_pOTG->dwPwrMgmt == MODE_SYSTEM_SUSPEND)

  00de8	e5952074	 ldr         r2, [r5, #0x74]
  00dec	e5923064	 ldr         r3, [r2, #0x64]
  00df0	e3530001	 cmp         r3, #1
  00df4	1a000004	 bne         |$LN63@ThreadRun@3|

; 3549 : 			{
; 3550 :                 Sleep(100);

  00df8	e3a00064	 mov         r0, #0x64
  00dfc	eb000000	 bl          Sleep

; 3551 :                 if (rc != WAIT_TIMEOUT)

  00e00	e154000a	 cmp         r4, r10
  00e04	0afffd3a	 beq         |$LL163@ThreadRun@3|

; 3552 :                 	InterruptDone(m_dwSysIntr);
; 3553 : 			    continue;

  00e08	ea0001a1	 b           |$LN1@ThreadRun@3|
  00e0c		 |$LN63@ThreadRun@3|

; 3554 : 			}
; 3555 : 
; 3556 : 			#if SUSPEND_RESUME_DEBUG_ENABLE
; 3557 : 	            if (m_pOTG->dwPwrMgmt == MODE_SYSTEM_RESUME)
; 3558 : 				{
; 3559 : 	                RETAILMSG(1, (L"OTG ThreadRun MODE_SYSTEM_RESUME\r\n"));
; 3560 : 	                BYTE DevCtlValue = INREG8(&m_pOTG->pUsbGenRegs->DevCtl);
; 3561 : 	                dwSysConfigValue = INREG32(&m_pOTG->pUsbOtgRegs->OTG_SYSCONFIG);
; 3562 : 	                BYTE dwPowerValue = INREG8(&m_pOTG->pUsbGenRegs->Power);
; 3563 : 
; 3564 : 	                RETAILMSG(1, (TEXT("OTG: SYSCONFIG(0x%x), POWER(0x%x), DEVCTL(0x%x)\r\n"),
; 3565 : 	                    dwSysConfigValue, dwPowerValue, DevCtlValue));
; 3566 : 						
; 3567 : 	                RETAILMSG(1, (TEXT("OTG: operateMode %s\r\n"), m_pOTG->operateMode == HOST_MODE ? L"host" : m_pOTG->operateMode == DEVICE_MODE ? L"device" : L"idle"));
; 3568 : 				}
; 3569 : 			#endif
; 3570 : 				
; 3571 :             // OTG port ID pin changes will only be detected if session bit in DEVCTL register is set
; 3572 :             if (m_pOTG->dwPwrMgmt == MODE_SYSTEM_NORMAL && !(INREG8(&m_pOTG->pUsbGenRegs->DevCtl) & DEVCTL_SESSION))

  00e0c	e3530000	 cmp         r3, #0
  00e10	1a00000c	 bne         |$LN60@ThreadRun@3|
  00e14	e5922020	 ldr         r2, [r2, #0x20]
  00e18	e5d23060	 ldrb        r3, [r2, #0x60]
  00e1c	e3130001	 tst         r3, #1
  00e20	1a000008	 bne         |$LN60@ThreadRun@3|

; 3573 : 			{
; 3574 :                 SETREG8(&m_pOTG->pUsbGenRegs->DevCtl, DEVCTL_SESSION);          

  00e24	e5d23060	 ldrb        r3, [r2, #0x60]

; 3575 : 
; 3576 : 				Sleep(1);

  00e28	e3a00001	 mov         r0, #1
  00e2c	e3833001	 orr         r3, r3, #1
  00e30	e5c23060	 strb        r3, [r2, #0x60]
  00e34	eb000000	 bl          Sleep

; 3577 : 				
; 3578 : 				#if SUSPEND_RESUME_DEBUG_ENABLE
; 3579 : 		            BYTE DevCtlValue = INREG8(&m_pOTG->pUsbGenRegs->DevCtl);
; 3580 : 		            dwSysConfigValue = INREG32(&m_pOTG->pUsbOtgRegs->OTG_SYSCONFIG);
; 3581 : 		            BYTE dwPowerValue = INREG8(&m_pOTG->pUsbGenRegs->Power);
; 3582 : 
; 3583 : 		            RETAILMSG(1, (TEXT("OTG: SYSCONFIG(0x%x), POWER(0x%x), DEVCTL(0x%x), CCS %d, CSC %d\r\n"),
; 3584 : 		                      dwSysConfigValue, dwPowerValue, DevCtlValue, m_pOTG->connect_status & CONN_CCS ? 1 : 0, m_pOTG->connect_status & CONN_CSC ? 1 : 0));
; 3585 : 				#endif
; 3586 : 							  
; 3587 : 				m_timeout = 100;

  00e38	e3a03064	 mov         r3, #0x64
  00e3c	e5853094	 str         r3, [r5, #0x94]

; 3588 : 
; 3589 :                 if (rc == WAIT_TIMEOUT)

  00e40	e154000a	 cmp         r4, r10
  00e44	0afffd2a	 beq         |$LL163@ThreadRun@3|
  00e48		 |$LN60@ThreadRun@3|

; 3590 :     				continue;
; 3591 :             }
; 3592 : 
; 3593 :             OUTREG8(&pGen->IntrUSBE, INTRUSB_ALL&~INTRUSB_SOF);

  00e48	e3a030f7	 mov         r3, #0xF7
  00e4c	e5c6300b	 strb        r3, [r6, #0xB]

; 3594 : 
; 3595 : #ifdef DEBUG
; 3596 :             BYTE DevCtlValue = INREG8(&m_pOTG->pUsbGenRegs->DevCtl);
; 3597 :             BYTE dwPowerValue = INREG8(&m_pOTG->pUsbGenRegs->Power);
; 3598 : #endif
; 3599 :             dwSysConfigValue = INREG32(&m_pOTG->pUsbOtgRegs->OTG_SYSCONFIG);

  00e50	e5951074	 ldr         r1, [r5, #0x74]

; 3600 : 
; 3601 :             DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("OTG: SYSCONFIG(0x%x), POWER(0x%x), DEVCTL(0x%x)\r\n"),
; 3602 :                     dwSysConfigValue, dwPowerValue, DevCtlValue));
; 3603 : 
; 3604 :             if (rc == WAIT_TIMEOUT)

  00e54	e154000a	 cmp         r4, r10
  00e58	e5913018	 ldr         r3, [r1, #0x18]
  00e5c	e5933004	 ldr         r3, [r3, #4]
  00e60	1a000030	 bne         |$LN59@ThreadRun@3|

; 3605 :             {                        
; 3606 :                 m_timeout = INFINITE;

  00e64	e3e03000	 mvn         r3, #0
  00e68	e5853094	 str         r3, [r5, #0x94]

; 3607 : 
; 3608 :                 if (m_pOTG->operateMode == HOST_MODE)

  00e6c	e5d12035	 ldrb        r2, [r1, #0x35]
  00e70	e3520002	 cmp         r2, #2
  00e74	0afffd1e	 beq         |$LL163@ThreadRun@3|

; 3609 :                 {   
; 3610 :                     //EnableSuspend(TRUE);
; 3611 :                 }
; 3612 :                 else
; 3613 :                 {
; 3614 :                     // If you are here, it can be either IDLE_MODE or SUSPEND_MODE
; 3615 :                     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("StopUSBClock with operateMode=%d, m_dwStatus=0x%x\r\n"), 
; 3616 :                         m_pOTG->operateMode, m_dwStatus));
; 3617 : 
; 3618 :                     if ((m_dwStatus & STATUS_HNP_SESSION_MASK) == 0)

  00e78	e595301c	 ldr         r3, [r5, #0x1C]
  00e7c	e3130030	 tst         r3, #0x30
  00e80	1afffd1b	 bne         |$LL163@ThreadRun@3|

; 3619 :                     {
; 3620 : 
; 3621 :                         if ((m_dwStatus & STATUS_SESSION_RESTART) 
; 3622 :                             && ((m_dwStatus & STATUS_WAIT_HOST_DISCONN_COMPLETE) == 0x00) 
; 3623 :                             && (m_pOTG->operateMode == IDLE_MODE))

  00e84	e3130080	 tst         r3, #0x80
  00e88	0a000017	 beq         |$LN55@ThreadRun@3|
  00e8c	e3130040	 tst         r3, #0x40
  00e90	1a000015	 bne         |$LN55@ThreadRun@3|
  00e94	e3520000	 cmp         r2, #0
  00e98	1a000013	 bne         |$LN55@ThreadRun@3|

; 3624 :                         {
; 3625 : 
; 3626 :                             DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Try session restart\r\n")));                        
; 3627 :                             SessionRequest(FALSE, FALSE);

  00e9c	e51530dc	 ldr         r3, [r5, #-0xDC]
  00ea0	e3a02000	 mov         r2, #0
  00ea4	e3a01000	 mov         r1, #0
  00ea8	e5933084	 ldr         r3, [r3, #0x84]
  00eac	e24500dc	 sub         r0, r5, #0xDC
  00eb0	e1a0e00f	 mov         lr, pc
  00eb4	e12fff13	 bx          r3

; 3628 :                             CLRREG8(&m_pOTG->pUsbGenRegs->DevCtl, DEVCTL_HOSTREQ);

  00eb8	e5953074	 ldr         r3, [r5, #0x74]

; 3629 :                             SessionRequest(TRUE, TRUE);

  00ebc	e3a02001	 mov         r2, #1
  00ec0	e3a01001	 mov         r1, #1
  00ec4	e5934020	 ldr         r4, [r3, #0x20]
  00ec8	e24500dc	 sub         r0, r5, #0xDC
  00ecc	e5d43060	 ldrb        r3, [r4, #0x60]
  00ed0	e20330fd	 and         r3, r3, #0xFD
  00ed4	e5c43060	 strb        r3, [r4, #0x60]
  00ed8	e51530dc	 ldr         r3, [r5, #-0xDC]
  00edc	e5933084	 ldr         r3, [r3, #0x84]
  00ee0	e1a0e00f	 mov         lr, pc
  00ee4	e12fff13	 bx          r3

; 3630 :                             m_dwStatus &= ~STATUS_SESSION_RESTART;
; 3631 :                             m_timeout = DO_SESSCHK_TIMEOUT;

  00ee8	eafffdcc	 b           |$LN247@ThreadRun@3|
  00eec		 |$LN55@ThreadRun@3|

; 3632 :                         }
; 3633 :                         else if ((m_dwStatus & STATUS_WAIT_HOST_DISCONN_COMPLETE) == 0x00)

  00eec	e3130040	 tst         r3, #0x40
  00ef0	1afffcff	 bne         |$LL163@ThreadRun@3|

; 3634 :                         {              
; 3635 :                             DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("+(m_dwStatus & STATUS_WAIT_HOST_DISCONN_COMPLETE) == 0x00\r\n")));
; 3636 :                             if(m_disconnected || ((INREG8(&pGen->DevCtl) & DEVCTL_SESSION) == 0))

  00ef4	e59530b0	 ldr         r3, [r5, #0xB0]
  00ef8	e3530000	 cmp         r3, #0
  00efc	1a000002	 bne         |$LN51@ThreadRun@3|
  00f00	e5d63060	 ldrb        r3, [r6, #0x60]
  00f04	e3130001	 tst         r3, #1
  00f08	1afffcf9	 bne         |$LL163@ThreadRun@3|
  00f0c		 |$LN51@ThreadRun@3|

; 3637 :                             {
; 3638 :                                 // avoid continous stream of suspend interrupts
; 3639 :                                 CLRREG8(&m_pOTG->pUsbGenRegs->IntrUSBE, INTRUSB_SUSPEND);  

  00f0c	e5912020	 ldr         r2, [r1, #0x20]
  00f10	e5d2300b	 ldrb        r3, [r2, #0xB]
  00f14	e20330fe	 and         r3, r3, #0xFE
  00f18	e5c2300b	 strb        r3, [r2, #0xB]

; 3640 :                                 // in effect, we must continuously set the session bit to get host mode to work
; 3641 :                                 m_timeout = 1000;

  00f1c	e3a03ffa	 mov         r3, #0xFA, 30
  00f20	e5853094	 str         r3, [r5, #0x94]

; 3642 :                             }
; 3643 :                         }
; 3644 :                     }
; 3645 :                 }
; 3646 : 
; 3647 :                 continue;

  00f24	eafffcf2	 b           |$LL163@ThreadRun@3|
  00f28		 |$LN59@ThreadRun@3|

; 3648 :             }
; 3649 :             else
; 3650 :             {   
; 3651 :                 StartUSBClock(m_bIncCount);         

  00f28	e51530dc	 ldr         r3, [r5, #-0xDC]
  00f2c	e59510a4	 ldr         r1, [r5, #0xA4]
  00f30	e24500dc	 sub         r0, r5, #0xDC
  00f34	e59330e4	 ldr         r3, [r3, #0xE4]
  00f38	e1a0e00f	 mov         lr, pc
  00f3c	e12fff13	 bx          r3

; 3652 :                 m_bIncCount = FALSE;            
; 3653 :                 if (m_dwStatus & STATUS_SESSION_RESTART)

  00f40	e595301c	 ldr         r3, [r5, #0x1C]

; 3654 :                     m_timeout = DO_SUSPEND_TIMEOUT;
; 3655 :                 else
; 3656 :                     m_timeout = INFINITE;
; 3657 :             }
; 3658 : 
; 3659 :             m_pOTG->intr_usb = INREG8(&m_pOTG->pUsbGenRegs->IntrUSB);

  00f44	e5952074	 ldr         r2, [r5, #0x74]
  00f48	e3a04000	 mov         r4, #0
  00f4c	e3130080	 tst         r3, #0x80
  00f50	03e03000	 mvneq       r3, #0
  00f54	15857094	 strne       r7, [r5, #0x94]
  00f58	05853094	 streq       r3, [r5, #0x94]
  00f5c	e58540a4	 str         r4, [r5, #0xA4]
  00f60	e5923020	 ldr         r3, [r2, #0x20]
  00f64	e5d3300a	 ldrb        r3, [r3, #0xA]
  00f68	e5c23034	 strb        r3, [r2, #0x34]

; 3660 :             m_pOTG->intr_tx  |= INREG16(&m_pOTG->pUsbGenRegs->IntrTx);

  00f6c	e5950074	 ldr         r0, [r5, #0x74]
  00f70	e5903020	 ldr         r3, [r0, #0x20]
  00f74	e1d013b2	 ldrh        r1, [r0, #0x32]
  00f78	e5d32002	 ldrb        r2, [r3, #2]
  00f7c	e5d33003	 ldrb        r3, [r3, #3]
  00f80	e1823403	 orr         r3, r2, r3, lsl #8
  00f84	e1833001	 orr         r3, r3, r1
  00f88	e1c033b2	 strh        r3, [r0, #0x32]

; 3661 :             m_pOTG->intr_rx  |= INREG16(&m_pOTG->pUsbGenRegs->IntrRx);

  00f8c	e5950074	 ldr         r0, [r5, #0x74]
  00f90	e5903020	 ldr         r3, [r0, #0x20]
  00f94	e1d013b0	 ldrh        r1, [r0, #0x30]
  00f98	e5d32004	 ldrb        r2, [r3, #4]
  00f9c	e5d33005	 ldrb        r3, [r3, #5]
  00fa0	e1823403	 orr         r3, r2, r3, lsl #8
  00fa4	e1833001	 orr         r3, r3, r1
  00fa8	e1c033b0	 strh        r3, [r0, #0x30]

; 3662 : 
; 3663 : 			#if SUSPEND_RESUME_DEBUG_ENABLE
; 3664 : 	            if (m_pOTG->intr_usb & (INTRUSB_VBUSERR | INTRUSB_SESSREQ | INTRUSB_DISCONN  | INTRUSB_CONN | INTRUSB_RESET | INTRUSB_BABBLE | INTRUSB_RESUME | INTRUSB_SUSPEND))
; 3665 : 	            {
; 3666 : 	                RETAILMSG(1, (TEXT("OTG INTRUSB(0x%x), TX(0x%x), RX(0x%x), DevCtl(0x%x), m_dwStatus(0x%x)\r\n"),
; 3667 : 	                    m_pOTG->intr_usb, m_pOTG->intr_tx, m_pOTG->intr_rx, INREG8(&m_pOTG->pUsbGenRegs->DevCtl), m_dwStatus));
; 3668 : 	            }
; 3669 : 			#endif
; 3670 : 				
; 3671 :             //DEBUGMSG(ZONE_OTG_FUNCTION,(TEXT("OTG Interrupts(0x%x) intr_tx(0x%x) intr_rx(0x%x)\n"), m_pOTG->intr_usb, m_pOTG->intr_tx, m_pOTG->intr_rx ));
; 3672 :             DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("OTG Interrupt INTRUSB(0x%x), TX(0x%x), RX(0x%x), DevCtl(0x%x), m_dwStatus(0x%x)\r\n"),
; 3673 :                 m_pOTG->intr_usb, m_pOTG->intr_tx, m_pOTG->intr_rx, INREG8(&m_pOTG->pUsbGenRegs->DevCtl), m_dwStatus));
; 3674 : 
; 3675 :             if (m_pOTG->dwPwrMgmt == MODE_SYSTEM_RESUME)

  00fac	e5952074	 ldr         r2, [r5, #0x74]
  00fb0	e5923064	 ldr         r3, [r2, #0x64]
  00fb4	e3530002	 cmp         r3, #2
  00fb8	1a00004f	 bne         |$LN47@ThreadRun@3|

; 3676 :             {
; 3677 :                 DEBUGMSG(1, (TEXT("MODE_SYSTEM_RESUME\r\n")));
; 3678 :                 if (m_pOTG->operateMode == HOST_MODE)

  00fbc	e5d23035	 ldrb        r3, [r2, #0x35]
  00fc0	e3530002	 cmp         r3, #2
  00fc4	1a000041	 bne         |$LN46@ThreadRun@3|

; 3679 :                 {
; 3680 :                     DWORD dwPrevState = 0;
; 3681 : 
; 3682 :                     DEBUGMSG(1, (TEXT("Resume on Host Mode\r\n")));
; 3683 :                     if (INREG8(&pGen->Power) & POWER_RESUME)

  00fc8	e5d63001	 ldrb        r3, [r6, #1]
  00fcc	e3130004	 tst         r3, #4

; 3684 :                         CLRREG8(&pGen->Power, POWER_RESUME);                                

  00fd0	15d63001	 ldrneb      r3, [r6, #1]
  00fd4	120330fb	 andne       r3, r3, #0xFB
  00fd8	15c63001	 strneb      r3, [r6, #1]

; 3685 : 
; 3686 :                     if ( ((INREG8(&pGen->DevCtl) & DEVCTL_SESSION) == 0) || ((m_pOTG->intr_usb & INTRUSB_SUSPEND) != 0) )

  00fdc	e5d63060	 ldrb        r3, [r6, #0x60]
  00fe0	e3130001	 tst         r3, #1
  00fe4	0a000003	 beq         |$LN43@ThreadRun@3|
  00fe8	e5953074	 ldr         r3, [r5, #0x74]
  00fec	e5d33034	 ldrb        r3, [r3, #0x34]
  00ff0	e3130001	 tst         r3, #1

; 3720 :                     }
; 3721 :                     else
; 3722 :                         m_timeout = DO_USBHOST_TIMEOUT;
; 3723 :                 }            
; 3724 :                 else

  00ff4	0a00003c	 beq         |$LN258@ThreadRun@3|
  00ff8		 |$LN43@ThreadRun@3|

; 3687 :                     {
; 3688 :                         DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Resume Host Mode with request session again\r\n")));
; 3689 :                         ResetEndPoints();

  00ff8	e51530dc	 ldr         r3, [r5, #-0xDC]
  00ffc	e24500dc	 sub         r0, r5, #0xDC
  01000	e59330ec	 ldr         r3, [r3, #0xEC]
  01004	e1a0e00f	 mov         lr, pc
  01008	e12fff13	 bx          r3

; 3690 :                         m_bRequestSession = TRUE;
; 3691 :                         //DEBUGMSG(1, (TEXT("operateMode = IDLE (resume host)\r\n")));
; 3692 :                         m_pOTG->operateMode = IDLE_MODE;

  0100c	e5953074	 ldr         r3, [r5, #0x74]
  01010	e3a02001	 mov         r2, #1
  01014	e5852088	 str         r2, [r5, #0x88]
  01018	e5c34035	 strb        r4, [r3, #0x35]

; 3693 :                         m_dwStatus |= STATUS_DISCONN_REQUEST/*|STATUS_WAIT_HOST_DISCONN_COMPLETE*/;

  0101c	e595301c	 ldr         r3, [r5, #0x1C]

; 3694 :                         dwPrevState = m_pOTG->connect_status;

  01020	e5951074	 ldr         r1, [r5, #0x74]
  01024	e3833002	 orr         r3, r3, #2
  01028	e585301c	 str         r3, [r5, #0x1C]
  0102c	e5d1204c	 ldrb        r2, [r1, #0x4C]

; 3695 :                         m_pOTG->connect_status &= ~CONN_CCS;

  01030	e20230fe	 and         r3, r2, #0xFE
  01034	e5c1304c	 strb        r3, [r1, #0x4C]

; 3696 :                         if (dwPrevState & CONN_CCS) 

  01038	e3120001	 tst         r2, #1

; 3697 :                             m_pOTG->connect_status |= CONN_CSC;

  0103c	e5952074	 ldr         r2, [r5, #0x74]
  01040	e5d2304c	 ldrb        r3, [r2, #0x4C]
  01044	13833002	 orrne       r3, r3, #2

; 3698 :                         else
; 3699 :                             m_pOTG->connect_status &= ~CONN_CSC;

  01048	020330fd	 andeq       r3, r3, #0xFD
  0104c	e5c2304c	 strb        r3, [r2, #0x4C]

; 3700 : 
; 3701 :                         if (m_pOTG->pFuncs[HOST_MODE-1] != NULL)

  01050	e5950074	 ldr         r0, [r5, #0x74]
  01054	e590300c	 ldr         r3, [r0, #0xC]
  01058	e3530000	 cmp         r3, #0

; 3702 :                            m_pOTG->pFuncs[HOST_MODE-1]->Disconnect((void *)m_pOTG);       

  0105c	15933018	 ldrne       r3, [r3, #0x18]
  01060	11a0e00f	 movne       lr, pc
  01064	112fff13	 bxne        r3

; 3703 : 
; 3704 :                         SessionRequest(FALSE, FALSE);

  01068	e51530dc	 ldr         r3, [r5, #-0xDC]
  0106c	e3a02000	 mov         r2, #0
  01070	e3a01000	 mov         r1, #0
  01074	e5933084	 ldr         r3, [r3, #0x84]
  01078	e24500dc	 sub         r0, r5, #0xDC
  0107c	e1a0e00f	 mov         lr, pc
  01080	e12fff13	 bx          r3

; 3705 : 
; 3706 :                         m_disconnected = TRUE;
; 3707 :                         m_timeout = DO_SUSPEND_TIMEOUT;
; 3708 :                         Sleep(200);

  01084	e3a03001	 mov         r3, #1
  01088	e3a000c8	 mov         r0, #0xC8
  0108c	e58530b0	 str         r3, [r5, #0xB0]
  01090	e5857094	 str         r7, [r5, #0x94]
  01094	eb000000	 bl          Sleep

; 3709 :                         // Softreset the MUSB controller to recover from
; 3710 :                         // babble errors when Activesync is connected
; 3711 :                         SoftResetMUSBController();

  01098	e51530dc	 ldr         r3, [r5, #-0xDC]
  0109c	e3a01000	 mov         r1, #0
  010a0	e24500dc	 sub         r0, r5, #0xDC
  010a4	e59330f8	 ldr         r3, [r3, #0xF8]
  010a8	e1a0e00f	 mov         lr, pc
  010ac	e12fff13	 bx          r3

; 3712 : 
; 3713 :                         // ??? enable the session bit in OTG devctl register
; 3714 :                         SessionRequest(TRUE, TRUE);

  010b0	e51530dc	 ldr         r3, [r5, #-0xDC]
  010b4	e3a02001	 mov         r2, #1
  010b8	e3a01001	 mov         r1, #1
  010bc	e5933084	 ldr         r3, [r3, #0x84]
  010c0	e24500dc	 sub         r0, r5, #0xDC
  010c4	e1a0e00f	 mov         lr, pc
  010c8	e12fff13	 bx          r3

; 3715 : 
; 3716 :                         if (rc != WAIT_TIMEOUT)
; 3717 :                             InterruptDone(m_dwSysIntr);
; 3718 : 
; 3719 :                         continue;

  010cc	ea0000f0	 b           |$LN1@ThreadRun@3|
  010d0		 |$LN46@ThreadRun@3|

; 3725 :                 {
; 3726 :                     SessionRequest(TRUE, TRUE);

  010d0	e51530dc	 ldr         r3, [r5, #-0xDC]
  010d4	e3a02001	 mov         r2, #1
  010d8	e3a01001	 mov         r1, #1
  010dc	e5933084	 ldr         r3, [r3, #0x84]
  010e0	e24500dc	 sub         r0, r5, #0xDC
  010e4	e1a0e00f	 mov         lr, pc
  010e8	e12fff13	 bx          r3
  010ec		 |$LN258@ThreadRun@3|

; 3727 :                     m_timeout = DO_USBCLK_TIMEOUT;

  010ec	e3a03003	 mov         r3, #3
  010f0	e5853094	 str         r3, [r5, #0x94]

; 3728 :                 }
; 3729 : 
; 3730 :                 m_pOTG->dwPwrMgmt = MODE_SYSTEM_NORMAL;

  010f4	e5953074	 ldr         r3, [r5, #0x74]
  010f8	e5834064	 str         r4, [r3, #0x64]
  010fc		 |$LN47@ThreadRun@3|

; 3731 :             }
; 3732 :         
; 3733 :             //DEBUGMSG(ZONE_OTG_FUNCTION,(TEXT("Interrupt Variable INTRUSB(0x%x) Devctl(0x%x)\n"), m_pOTG->intr_usb, INREG8(&m_pOTG->pUsbGenRegs->DevCtl)));
; 3734 :             if((!m_pOTG->intr_usb) && (!m_pOTG->intr_tx) && (!m_pOTG->intr_rx))

  010fc	e5952074	 ldr         r2, [r5, #0x74]
  01100	e5d23034	 ldrb        r3, [r2, #0x34]
  01104	e3530000	 cmp         r3, #0
  01108	1a000007	 bne         |$LN35@ThreadRun@3|
  0110c	e1d233b2	 ldrh        r3, [r2, #0x32]
  01110	e3530000	 cmp         r3, #0
  01114	1a000004	 bne         |$LN35@ThreadRun@3|
  01118	e1d233b0	 ldrh        r3, [r2, #0x30]
  0111c	e3530000	 cmp         r3, #0

; 3735 :             {
; 3736 :                if(m_timeout == INFINITE)

  01120	05953094	 ldreq       r3, [r5, #0x94]
  01124	03730001	 cmneq       r3, #1

; 3737 :                {
; 3738 :                   m_timeout = DO_SUSPEND_TIMEOUT;

  01128	05857094	 streq       r7, [r5, #0x94]
  0112c		 |$LN35@ThreadRun@3|

; 3739 :                }
; 3740 :                DEBUGMSG(ZONE_OTG_FUNCTION,(TEXT("Interrupt Variable INTRUSB No interrupt at all\n")));
; 3741 :             }
; 3742 : 
; 3743 :             // STATUS_RETENTION_WAKEUP is set when IDGND event is signaled
; 3744 :             if (m_dwStatus & STATUS_RETENTION_WAKEUP)

  0112c	e595301c	 ldr         r3, [r5, #0x1C]
  01130	e3130c01	 tst         r3, #1, 24
  01134	0a000011	 beq         |$LN34@ThreadRun@3|

; 3745 :             {
; 3746 :                 DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Status Retention with DevCtl Session = 0x%x\r\n"), 
; 3747 :                     INREG8(&m_pOTG->pUsbGenRegs->DevCtl)));
; 3748 : 
; 3749 :                 if ((INREG8(&m_pOTG->pUsbGenRegs->DevCtl) & DEVCTL_SESSION) == 0)

  01138	e5922020	 ldr         r2, [r2, #0x20]
  0113c	e5d23060	 ldrb        r3, [r2, #0x60]
  01140	e3130001	 tst         r3, #1
  01144	1a000009	 bne         |$LN33@ThreadRun@3|

; 3750 :                 {
; 3751 :                     SETREG8(&m_pOTG->pUsbGenRegs->DevCtl, DEVCTL_SESSION);

  01148	e5d23060	 ldrb        r3, [r2, #0x60]

; 3752 : 
; 3753 :                     // (workaround) wait and set session bit again.  Otherwise, sometimes USB transceiver VBUS doesn't go to 5V.
; 3754 :                     Sleep(100);

  0114c	e3a00064	 mov         r0, #0x64
  01150	e3833001	 orr         r3, r3, #1
  01154	e5c23060	 strb        r3, [r2, #0x60]
  01158	eb000000	 bl          Sleep

; 3755 :                     SETREG8(&m_pOTG->pUsbGenRegs->DevCtl, DEVCTL_SESSION);

  0115c	e5953074	 ldr         r3, [r5, #0x74]
  01160	e5932020	 ldr         r2, [r3, #0x20]
  01164	e5d23060	 ldrb        r3, [r2, #0x60]
  01168	e3833001	 orr         r3, r3, #1
  0116c	e5c23060	 strb        r3, [r2, #0x60]
  01170		 |$LN33@ThreadRun@3|

; 3756 :                 }
; 3757 :             
; 3758 :                 m_dwStatus &= ~STATUS_RETENTION_WAKEUP;

  01170	e595301c	 ldr         r3, [r5, #0x1C]

; 3759 :                 m_timeout = DO_SESSCHK_TIMEOUT;            

  01174	e5858094	 str         r8, [r5, #0x94]
  01178	e3c33c01	 bic         r3, r3, #1, 24
  0117c	e585301c	 str         r3, [r5, #0x1C]
  01180		 |$LN34@ThreadRun@3|

; 3760 :             }
; 3761 : 
; 3762 :             if (m_dwStatus & STATUS_HNP_SESSION_PROCESS)

  01180	e595301c	 ldr         r3, [r5, #0x1C]
  01184	e3130020	 tst         r3, #0x20
  01188	0a00000a	 beq         |$LN32@ThreadRun@3|

; 3763 :             {
; 3764 :                 DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("We can process role switch loading now\r\n")));
; 3765 :                 if ((INREG8(&m_pOTG->pUsbGenRegs->DevCtl) & DEVCTL_HOSTMODE) == 0x00)

  0118c	e5952074	 ldr         r2, [r5, #0x74]
  01190	e5923020	 ldr         r3, [r2, #0x20]
  01194	e5d33060	 ldrb        r3, [r3, #0x60]
  01198	e3130004	 tst         r3, #4

; 3766 :                     m_pOTG->intr_usb |= INTRUSB_RESET;

  0119c	e5d23034	 ldrb        r3, [r2, #0x34]
  011a0	03833004	 orreq       r3, r3, #4

; 3767 :                 else
; 3768 :                     m_pOTG->intr_usb |= INTRUSB_CONN;

  011a4	13833010	 orrne       r3, r3, #0x10
  011a8	e5c23034	 strb        r3, [r2, #0x34]

; 3769 :                 m_dwStatus &= ~STATUS_HNP_SESSION_PROCESS;

  011ac	e595301c	 ldr         r3, [r5, #0x1C]
  011b0	e3c33020	 bic         r3, r3, #0x20
  011b4	e585301c	 str         r3, [r5, #0x1C]
  011b8		 |$LN32@ThreadRun@3|

; 3770 :             }
; 3771 :      
; 3772 :             // Implement according to USB Interrupt Service Routine
; 3773 :             // USBOTGHS Functional Spec Rev 0.1 Figure 8.1 (89/174)
; 3774 : 
; 3775 :             if (m_pOTG->intr_usb)

  011b8	e5953074	 ldr         r3, [r5, #0x74]
  011bc	e5d33034	 ldrb        r3, [r3, #0x34]
  011c0	e3530000	 cmp         r3, #0

; 3776 :             {            
; 3777 :                 OTG_ConfigISR_stage1();         

  011c4	151530dc	 ldrne       r3, [r5, #-0xDC]
  011c8	124500dc	 subne       r0, r5, #0xDC
  011cc	159330cc	 ldrne       r3, [r3, #0xCC]
  011d0	11a0e00f	 movne       lr, pc
  011d4	112fff13	 bxne        r3

; 3778 :             }
; 3779 : 
; 3780 :             if ((m_dwStatus & STATUS_HNP_SESSION_MASK) == 0x00)

  011d8	e595301c	 ldr         r3, [r5, #0x1C]
  011dc	e3130030	 tst         r3, #0x30
  011e0	1a00002d	 bne         |$LN21@ThreadRun@3|

; 3781 :             {
; 3782 :                 // Here is the handling of Tx/Rx
; 3783 :                 // First handling of Endpoint 0 interrupt first.
; 3784 :                 if (m_pOTG->intr_tx & INTR_EP(0))

  011e4	e5953074	 ldr         r3, [r5, #0x74]
  011e8	e1d333b2	 ldrh        r3, [r3, #0x32]
  011ec	e3130001	 tst         r3, #1

; 3785 :                 {
; 3786 :                     OTG_ProcessEP0();

  011f0	151530dc	 ldrne       r3, [r5, #-0xDC]
  011f4	124500dc	 subne       r0, r5, #0xDC
  011f8	159330d8	 ldrne       r3, [r3, #0xD8]
  011fc	11a0e00f	 movne       lr, pc
  01200	112fff13	 bxne        r3

; 3787 :                 }
; 3788 : 
; 3789 :                 // It may be a bit odd of why not doing all the things in same loop
; 3790 :                 // but this is according to the functional spec. Reference: Inventra MUSBMHDRC 
; 3791 :                 // Programmer's Guide pg 46
; 3792 :                 // Second now handling of Rx 1-15 
; 3793 :                 i = 1;

  01204	e3a04001	 mov         r4, #1
  01208	e3a02001	 mov         r2, #1
  0120c		 |$LL26@ThreadRun@3|

; 3794 :                 while (i <= 15)
; 3795 :                 {
; 3796 :                     if (m_pOTG->intr_rx & INTR_EP(i))

  0120c	e5953074	 ldr         r3, [r5, #0x74]
  01210	e1d333b0	 ldrh        r3, [r3, #0x30]
  01214	e1130412	 tst         r3, r2, lsl r4
  01218	0a000007	 beq         |$LN24@ThreadRun@3|

; 3797 :                         OTG_ProcessEPx((UCHAR)i, TRUE);

  0121c	e51530dc	 ldr         r3, [r5, #-0xDC]
  01220	e3a02001	 mov         r2, #1
  01224	e20410ff	 and         r1, r4, #0xFF
  01228	e59330dc	 ldr         r3, [r3, #0xDC]
  0122c	e24500dc	 sub         r0, r5, #0xDC
  01230	e1a0e00f	 mov         lr, pc
  01234	e12fff13	 bx          r3
  01238	e3a02001	 mov         r2, #1
  0123c		 |$LN24@ThreadRun@3|

; 3798 :                     i++;

  0123c	e2844001	 add         r4, r4, #1
  01240	e354000f	 cmp         r4, #0xF
  01244	dafffff0	 ble         |$LL26@ThreadRun@3|

; 3799 :                 }
; 3800 : 
; 3801 :                 // Third now handling of Tx 1-15
; 3802 :                 i = 1;
; 3803 :                 if (!(m_dwStatus & (STATUS_DISCONN_COMPLETE|STATUS_DISCONN_REQUEST)))

  01248	e595301c	 ldr         r3, [r5, #0x1C]
  0124c	e3a04001	 mov         r4, #1
  01250	e313000a	 tst         r3, #0xA
  01254	1a00000f	 bne         |$LN232@ThreadRun@3|
  01258	e3a02001	 mov         r2, #1
  0125c		 |$LL22@ThreadRun@3|

; 3804 :                 {
; 3805 :                     while (i <= 15)
; 3806 :                     {
; 3807 :                         if (m_pOTG->intr_tx & INTR_EP(i))

  0125c	e5953074	 ldr         r3, [r5, #0x74]
  01260	e1d333b2	 ldrh        r3, [r3, #0x32]
  01264	e1130412	 tst         r3, r2, lsl r4
  01268	0a000007	 beq         |$LN20@ThreadRun@3|

; 3808 :                             OTG_ProcessEPx((UCHAR)i, FALSE);

  0126c	e51530dc	 ldr         r3, [r5, #-0xDC]
  01270	e3a02000	 mov         r2, #0
  01274	e20410ff	 and         r1, r4, #0xFF
  01278	e59330dc	 ldr         r3, [r3, #0xDC]
  0127c	e24500dc	 sub         r0, r5, #0xDC
  01280	e1a0e00f	 mov         lr, pc
  01284	e12fff13	 bx          r3
  01288	e3a02001	 mov         r2, #1
  0128c		 |$LN20@ThreadRun@3|

; 3809 :                         i++;

  0128c	e2844001	 add         r4, r4, #1
  01290	e354000f	 cmp         r4, #0xF
  01294	dafffff0	 ble         |$LL22@ThreadRun@3|
  01298		 |$LN232@ThreadRun@3|

; 2935 : 
; 2936 :     // Now you have all drivers loading and hence can do the register on the bus...
; 2937 :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("OMAPMHSUSBOTG::ThreadRun: Enable Interrupt waiting for connection!!!\r\n")));
; 2938 : 
; 2939 :     StartUSBClock(TRUE);

  01298	e3a04000	 mov         r4, #0
  0129c		 |$LN21@ThreadRun@3|

; 3810 :                     }
; 3811 :                 }
; 3812 :             }
; 3813 : 
; 3814 :             if (m_pOTG->intr_usb)

  0129c	e5953074	 ldr         r3, [r5, #0x74]
  012a0	e5d33034	 ldrb        r3, [r3, #0x34]
  012a4	e3530000	 cmp         r3, #0

; 3815 :             {            
; 3816 :                 OTG_ConfigISR_stage2();         

  012a8	151530dc	 ldrne       r3, [r5, #-0xDC]
  012ac	124500dc	 subne       r0, r5, #0xDC
  012b0	159330d0	 ldrne       r3, [r3, #0xD0]
  012b4	11a0e00f	 movne       lr, pc
  012b8	112fff13	 bxne        r3

; 3817 :             }
; 3818 : 
; 3819 :             if(m_handleVBUSError)

  012bc	e59530b8	 ldr         r3, [r5, #0xB8]
  012c0	e3530000	 cmp         r3, #0
  012c4	0a00000a	 beq         |$LN18@ThreadRun@3|

; 3820 :             {
; 3821 :                 SessionRequest(FALSE, FALSE);

  012c8	e51530dc	 ldr         r3, [r5, #-0xDC]
  012cc	e3a02000	 mov         r2, #0
  012d0	e3a01000	 mov         r1, #0
  012d4	e5933084	 ldr         r3, [r3, #0x84]
  012d8	e24500dc	 sub         r0, r5, #0xDC
  012dc	e1a0e00f	 mov         lr, pc
  012e0	e12fff13	 bx          r3

; 3822 :                 m_handleVBUSError = FALSE;
; 3823 : 			    m_timeout = m_OTGRegCfg.startupTimeout;

  012e4	e5953028	 ldr         r3, [r5, #0x28]
  012e8	e58540b8	 str         r4, [r5, #0xB8]
  012ec	e5853094	 str         r3, [r5, #0x94]
  012f0	eafffbff	 b           |$LL163@ThreadRun@3|
  012f4		 |$LN18@ThreadRun@3|

; 3824 :                 continue;
; 3825 :             }
; 3826 : 
; 3827 :             // We can clear the intr_usb, intr_tx & intr_rx
; 3828 :             if ((m_dwStatus & STATUS_HNP_SESSION_MASK) == 0x00)

  012f4	e595301c	 ldr         r3, [r5, #0x1C]

; 3829 :             {
; 3830 :                 m_pOTG->intr_rx = 0;
; 3831 :                 m_pOTG->intr_tx = 0;
; 3832 :             }
; 3833 :             m_pOTG->intr_usb = 0;
; 3834 :         
; 3835 :             if (m_dwStatus & STATUS_CONNECT)
; 3836 :             {
; 3837 :                 m_dwStatus &= ~STATUS_CONNECT;
; 3838 :                 if (m_pOTG->operateMode == HOST_MODE)
; 3839 :                     m_timeout = DO_USBHOST_TIMEOUT;

  012f8	e3a00003	 mov         r0, #3
  012fc	e3130030	 tst         r3, #0x30
  01300	05953074	 ldreq       r3, [r5, #0x74]
  01304	01c343b0	 streqh      r4, [r3, #0x30]
  01308	05953074	 ldreq       r3, [r5, #0x74]
  0130c	01c343b2	 streqh      r4, [r3, #0x32]
  01310	e5953074	 ldr         r3, [r5, #0x74]
  01314	e5c34034	 strb        r4, [r3, #0x34]
  01318	e595301c	 ldr         r3, [r5, #0x1C]
  0131c	e3130001	 tst         r3, #1
  01320	0a000007	 beq         |$LN14@ThreadRun@3|
  01324	e5952074	 ldr         r2, [r5, #0x74]
  01328	e3c33001	 bic         r3, r3, #1
  0132c	e585301c	 str         r3, [r5, #0x1C]
  01330	e5d23035	 ldrb        r3, [r2, #0x35]
  01334	e3530002	 cmp         r3, #2

; 3840 :                 else
; 3841 :                     m_timeout = INFINITE;            

  01338	13e03000	 mvnne       r3, #0
  0133c	05850094	 streq       r0, [r5, #0x94]
  01340	15853094	 strne       r3, [r5, #0x94]
  01344		 |$LN14@ThreadRun@3|

; 3842 :             }
; 3843 : 
; 3844 : 
; 3845 :             if ((m_dwStatus & STATUS_DISCONN_COMPLETE) && (m_pOTG->connect_status & CONN_DC)) 

  01344	e595101c	 ldr         r1, [r5, #0x1C]
  01348	e3110008	 tst         r1, #8
  0134c	0a000038	 beq         |$LN236@ThreadRun@3|
  01350	e5952074	 ldr         r2, [r5, #0x74]
  01354	e5d2304c	 ldrb        r3, [r2, #0x4C]
  01358	e3130004	 tst         r3, #4
  0135c	0a000034	 beq         |$LN236@ThreadRun@3|

; 3846 :             {                        
; 3847 :                 m_dwStatus &= ~(STATUS_DISCONN_COMPLETE|STATUS_WAIT_HOST_DISCONN_COMPLETE);                       

  01360	e3c13048	 bic         r3, r1, #0x48
  01364	e585301c	 str         r3, [r5, #0x1C]

; 3848 :                 m_pOTG->connect_status &= ~CONN_DC;

  01368	e5d2304c	 ldrb        r3, [r2, #0x4C]
  0136c	e20330fb	 and         r3, r3, #0xFB
  01370	e5c2304c	 strb        r3, [r2, #0x4C]

; 3849 :                 if (m_bRequestSession)

  01374	e5953088	 ldr         r3, [r5, #0x88]
  01378	e3530000	 cmp         r3, #0
  0137c	0a00000d	 beq         |$LN12@ThreadRun@3|

; 3850 :                 {
; 3851 :                     m_bRequestSession = FALSE;                                
; 3852 :                     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Request Session Again\r\n")));
; 3853 :                     SETREG8(&m_pOTG->pUsbGenRegs->DevCtl, DEVCTL_SESSION);  

  01380	e5953074	 ldr         r3, [r5, #0x74]
  01384	e5854088	 str         r4, [r5, #0x88]

; 3854 : 
; 3855 :                     // (workaround) wait and set session bit again.  Otherwise, sometimes USB transceiver VBUS doesn't go to 5V.
; 3856 :                     Sleep(100);

  01388	e3a00064	 mov         r0, #0x64
  0138c	e5932020	 ldr         r2, [r3, #0x20]
  01390	e5d23060	 ldrb        r3, [r2, #0x60]
  01394	e3833001	 orr         r3, r3, #1
  01398	e5c23060	 strb        r3, [r2, #0x60]
  0139c	eb000000	 bl          Sleep

; 3857 :                     SETREG8(&m_pOTG->pUsbGenRegs->DevCtl, DEVCTL_SESSION);      

  013a0	e5953074	 ldr         r3, [r5, #0x74]
  013a4	e5932020	 ldr         r2, [r3, #0x20]
  013a8	e5d23060	 ldrb        r3, [r2, #0x60]
  013ac	e3833001	 orr         r3, r3, #1
  013b0	e5c23060	 strb        r3, [r2, #0x60]

; 3858 : 
; 3859 :                 }
; 3860 :                 else

  013b4	ea000011	 b           |$LN11@ThreadRun@3|
  013b8		 |$LN12@ThreadRun@3|

; 3861 :                 {
; 3862 :                     if (m_bExtendOTGSuspend)

  013b8	e59530a8	 ldr         r3, [r5, #0xA8]
  013bc	e3530000	 cmp         r3, #0

; 3863 :                     {
; 3864 :                         m_bExtendOTGSuspend = FALSE;
; 3865 :                         m_timeout = DO_SESSCHK_TIMEOUT;
; 3866 :                     }
; 3867 :                     else
; 3868 :                         m_timeout = DO_USBCLK_TIMEOUT;
; 3869 :                     // Perform reset of all the endpoints, we need to do that.                                
; 3870 :                     if ((m_dwStatus & STATUS_HNP_SESSION_MASK) == 0x00)

  013c0	e595301c	 ldr         r3, [r5, #0x1C]
  013c4	15858094	 strne       r8, [r5, #0x94]
  013c8	158540a8	 strne       r4, [r5, #0xA8]
  013cc	05850094	 streq       r0, [r5, #0x94]
  013d0	e3130030	 tst         r3, #0x30

; 3871 :                         ResetEndPoints();

  013d4	051530dc	 ldreq       r3, [r5, #-0xDC]
  013d8	024500dc	 subeq       r0, r5, #0xDC
  013dc	059330ec	 ldreq       r3, [r3, #0xEC]
  013e0	01a0e00f	 moveq       lr, pc
  013e4	012fff13	 bxeq        r3

; 3872 :                     m_pTransceiver->EnableWakeupInterrupt(TRUE);

  013e8	e5950020	 ldr         r0, [r5, #0x20]
  013ec	e3a01001	 mov         r1, #1
  013f0	e5903000	 ldr         r3, [r0]
  013f4	e5933008	 ldr         r3, [r3, #8]
  013f8	e1a0e00f	 mov         lr, pc
  013fc	e12fff13	 bx          r3
  01400		 |$LN11@ThreadRun@3|

; 3873 :                 
; 3874 :                     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Disconnect Complete and Set IOCTRL again\r\n")));                
; 3875 :                 }
; 3876 : 
; 3877 :                 if (m_dwStatus & STATUS_HNP_SESSION_INIT)

  01400	e595301c	 ldr         r3, [r5, #0x1C]
  01404	e3130010	 tst         r3, #0x10
  01408	0a000009	 beq         |$LN236@ThreadRun@3|

; 3878 :                 {
; 3879 :                     // Check whether it is host mode connection or device mode connection
; 3880 :                     SetEvent(m_hIntrEvent);

  0140c	e5950070	 ldr         r0, [r5, #0x70]
  01410	e3a01003	 mov         r1, #3
  01414	eb000000	 bl          EventModify

; 3881 :                     m_dwStatus |= STATUS_HNP_SESSION_PROCESS;

  01418	e595301c	 ldr         r3, [r5, #0x1C]

; 3882 :                     m_dwStatus &= ~STATUS_HNP_SESSION_INIT;
; 3883 :                     DEBUGMSG(ZONE_OTG_HNP, (TEXT("m_bHNPSession set interrupt\r\n")));
; 3884 :                     m_timeout = INFINITE;

  0141c	e3e04000	 mvn         r4, #0
  01420	e5854094	 str         r4, [r5, #0x94]
  01424	e3c33030	 bic         r3, r3, #0x30
  01428	e3833020	 orr         r3, r3, #0x20
  0142c	e585301c	 str         r3, [r5, #0x1C]
  01430	ea000000	 b           |$LN7@ThreadRun@3|
  01434		 |$LN236@ThreadRun@3|
  01434	e3e04000	 mvn         r4, #0
  01438		 |$LN7@ThreadRun@3|

; 3885 :                 }
; 3886 :             }
; 3887 : 
; 3888 :             if (m_dwStatus & STATUS_DISCONN_REQUEST)

  01438	e595301c	 ldr         r3, [r5, #0x1C]
  0143c	e3130002	 tst         r3, #2

; 3889 :             {
; 3890 :                 m_dwStatus &= ~STATUS_DISCONN_REQUEST;

  01440	13c33002	 bicne       r3, r3, #2

; 3891 :                 m_dwStatus |= STATUS_DISCONN_COMPLETE;

  01444	13833008	 orrne       r3, r3, #8
  01448	1585301c	 strne       r3, [r5, #0x1C]

; 3892 :                 m_timeout = INFINITE;
; 3893 :             }
; 3894 : 
; 3895 : 
; 3896 :             if (m_dwStatus & STATUS_SUSPEND)

  0144c	e595301c	 ldr         r3, [r5, #0x1C]
  01450	15854094	 strne       r4, [r5, #0x94]
  01454	e3130004	 tst         r3, #4
  01458	0a000008	 beq         |$LN3@ThreadRun@3|

; 3897 :             {
; 3898 :                 m_dwStatus &= ~STATUS_SUSPEND;

  0145c	e3c33004	 bic         r3, r3, #4
  01460	e585301c	 str         r3, [r5, #0x1C]

; 3899 :                 // Need to set the infinite and wait for the disconnect signal complete
; 3900 :                 if (m_dwStatus & STATUS_WAIT_HOST_DISCONN_COMPLETE)

  01464	e3130040	 tst         r3, #0x40
  01468	0a000001	 beq         |$LN4@ThreadRun@3|
  0146c		 |$LN263@ThreadRun@3|

; 3901 :                     m_timeout = INFINITE;

  0146c	e5854094	 str         r4, [r5, #0x94]

; 3902 :                 else

  01470	ea000002	 b           |$LN3@ThreadRun@3|
  01474		 |$LN4@ThreadRun@3|

; 3903 :                 {
; 3904 :                     m_timeout = DO_SUSPEND_TIMEOUT;
; 3905 :                     OUTREG8(&pGen->IntrUSBE, 0xF6/*INTRUSB_ALL&~INTRUSB_SOF&~INTRSUSPEND*/);

  01474	e3a030f6	 mov         r3, #0xF6
  01478	e5857094	 str         r7, [r5, #0x94]
  0147c	e5c6300b	 strb        r3, [r6, #0xB]
  01480		 |$LN3@ThreadRun@3|

; 3906 :                 }
; 3907 :             }
; 3908 :             if(m_disconnected)

  01480	e59530b0	 ldr         r3, [r5, #0xB0]
  01484	e3530000	 cmp         r3, #0

; 3909 :             {
; 3910 :                m_timeout = DO_DISCONNECT_TIMEOUT;

  01488	13a03ffa	 movne       r3, #0xFA, 30
  0148c	15853094	 strne       r3, [r5, #0x94]

; 3911 :             }
; 3912 :             else
; 3913 :             {
; 3914 :                m_timeout = DO_INACTIVITY_TIMEOUT;

  01490	0585b094	 streq       r11, [r5, #0x94]
  01494		 |$LN1@ThreadRun@3|

; 3915 :             }
; 3916 : 
; 3917 :             InterruptDone(m_dwSysIntr);

  01494	e5950068	 ldr         r0, [r5, #0x68]
  01498	eb000000	 bl          InterruptDone
  0149c	eafffb94	 b           |$LL163@ThreadRun@3|
  014a0		 |$LN267@ThreadRun@3|
  014a0		 |$LN268@ThreadRun@3|
  014a0	00000000	 DCD         |?g_busDx@@3W4_CEDEVICE_POWER_STATE@@A|
  014a4		 |$LN269@ThreadRun@3|
  014a4	00000000	 DCD         |??_C@_1DI@POPBHNLK@?$AAC?$AAa?$AAl?$AAl?$AAi?$AAn?$AAg?$AA?5?$AAS?$AAe?$AAs?$AAs?$AAi?$AAo?$AAn?$AA?5?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@|
  014a8		 |$M44197|

			 ENDP  ; |?ThreadRun@OMAPMHSUSBOTG@@EAAKXZ|, OMAPMHSUSBOTG::ThreadRun

	EXPORT	|?CreateUSBOTGObject@@YAPAVUSBOTG@@PAG@Z| ; CreateUSBOTGObject

  00000			 AREA	 |.pdata|, PDATA
|$T44217| DCD	|$LN8@CreateUSBO|
	DCD	0x40000f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CreateUSBOTGObject@@YAPAVUSBOTG@@PAG@Z| PROC ; CreateUSBOTGObject

; 168  : {

  00000		 |$LN8@CreateUSBO|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M44214|
  00004	e1a04000	 mov         r4, r0

; 169  : 
; 170  :     gpHsUsbOtg = new OMAPMHSUSBOTG (lpActivePath) ;

  00008	e3a00f69	 mov         r0, #0x69, 30
  0000c	eb000000	 bl          |??2@YAPAXI@Z|
  00010	e3500000	 cmp         r0, #0
  00014	0a000002	 beq         |$LN3@CreateUSBO|
  00018	e1a01004	 mov         r1, r4
  0001c	eb000000	 bl          |??0OMAPMHSUSBOTG@@QAA@PBG@Z|
  00020	ea000000	 b           |$LN5@CreateUSBO|
  00024		 |$LN3@CreateUSBO|
  00024	e3a00000	 mov         r0, #0
  00028		 |$LN5@CreateUSBO|
  00028	e59f3008	 ldr         r3, [pc, #8]
  0002c	e5830000	 str         r0, [r3]

; 171  :     return gpHsUsbOtg;
; 172  : }

  00030	e8bd4010	 ldmia       sp!, {r4, lr}
  00034	e12fff1e	 bx          lr
  00038		 |$LN9@CreateUSBO|
  00038		 |$LN10@CreateUSBO|
  00038	00000000	 DCD         |?gpHsUsbOtg@@3PAVOMAPMHSUSBOTG@@A|
  0003c		 |$M44215|

			 ENDP  ; |?CreateUSBOTGObject@@YAPAVUSBOTG@@PAG@Z|, CreateUSBOTGObject


  00000			 AREA	 |.pdata|, PDATA
|$T44230| DCD	|$LN6@scalar@2|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GOMAPMHSUSBIdGnd@@UAAPAXI@Z| PROC	; OMAPMHSUSBIdGnd::`scalar deleting destructor'
  00000		 |$LN6@scalar@2|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44227|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          |??1OMAPMHSUSBIdGnd@@UAA@XZ|
  00010	e3140001	 tst         r4, #1
  00014	11a00005	 movne       r0, r5
  00018	1b000000	 blne        |??3@YAXPAX@Z|
  0001c	e1a00005	 mov         r0, r5
  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M44228|

			 ENDP  ; |??_GOMAPMHSUSBIdGnd@@UAAPAXI@Z|, OMAPMHSUSBIdGnd::`scalar deleting destructor'


  00000			 AREA	 |.pdata|, PDATA
|$T44241| DCD	|$LN6@scalar@3|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GOMAPMHSUSBDMA@@UAAPAXI@Z| PROC	; OMAPMHSUSBDMA::`scalar deleting destructor'
  00000		 |$LN6@scalar@3|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44238|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          |??1OMAPMHSUSBDMA@@UAA@XZ|
  00010	e3140001	 tst         r4, #1
  00014	11a00005	 movne       r0, r5
  00018	1b000000	 blne        |??3@YAXPAX@Z|
  0001c	e1a00005	 mov         r0, r5
  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M44239|

			 ENDP  ; |??_GOMAPMHSUSBDMA@@UAAPAXI@Z|, OMAPMHSUSBDMA::`scalar deleting destructor'


  00000			 AREA	 |.pdata|, PDATA
|$T44252| DCD	|$LN6@scalar@4|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GOMAPMHSUSBOTG@@UAAPAXI@Z| PROC	; OMAPMHSUSBOTG::`scalar deleting destructor'
  00000		 |$LN6@scalar@4|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44249|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          |??1OMAPMHSUSBOTG@@UAA@XZ|
  00010	e3140001	 tst         r4, #1
  00014	11a00005	 movne       r0, r5
  00018	1b000000	 blne        |??3@YAXPAX@Z|
  0001c	e1a00005	 mov         r0, r5
  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M44250|

			 ENDP  ; |??_GOMAPMHSUSBOTG@@UAAPAXI@Z|, OMAPMHSUSBOTG::`scalar deleting destructor'

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|??_C@_0N@GCHGAKML@Serial_Class?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_05BCBDGGDK@RNDIS?$AA@| [ DATA ]	; `string'
	EXPORT	|??_C@_1CI@MGKPCHDE@?$AAD?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DI@KIDPGBEF@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAU?$AAS?$AAB?$AA?2?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|?Init@USBOTG@@UAAHXZ|			; USBOTG::Init
	IMPORT	|RegQueryValueExW|
	IMPORT	|CreateHSUSBOTGTransceiver|
	IMPORT	|RequestDevicePads|
	IMPORT	|LocalAlloc|
	IMPORT	|strcmp|

  00000			 AREA	 |.pdata|, PDATA
|$T44277| DCD	|$LN25@Init@4|
	DCD	0xc0008602

  00000			 AREA	 |.xdata|, DATA
|$T44273| DCD	0xffffffe4

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0N@GCHGAKML@Serial_Class?$AA@| DCB "Serial_Class", 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_05BCBDGGDK@RNDIS?$AA@| DCB "RNDIS", 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@MGKPCHDE@?$AAD?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?$AA@| DCB "D"
	DCB	0x0, "e", 0x0, "f", 0x0, "a", 0x0, "u", 0x0, "l", 0x0, "t"
	DCB	0x0, "C", 0x0, "l", 0x0, "i", 0x0, "e", 0x0, "n", 0x0, "t"
	DCB	0x0, "D", 0x0, "r", 0x0, "i", 0x0, "v", 0x0, "e", 0x0, "r"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DI@KIDPGBEF@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAU?$AAS?$AAB?$AA?2?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?$AA@| DCB "D"
	DCB	0x0, "r", 0x0, "i", 0x0, "v", 0x0, "e", 0x0, "r", 0x0, "s"
	DCB	0x0, "\\", 0x0, "U", 0x0, "S", 0x0, "B", 0x0, "\\", 0x0, "F"
	DCB	0x0, "u", 0x0, "n", 0x0, "c", 0x0, "t", 0x0, "i", 0x0, "o"
	DCB	0x0, "n", 0x0, "D", 0x0, "r", 0x0, "i", 0x0, "v", 0x0, "e"
	DCB	0x0, "r", 0x0, "s", 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T44273|

  00008		 |?Init@OMAPMHSUSBOTG@@UAAHXZ| PROC	; OMAPMHSUSBOTG::Init

; 474  : {

  00008		 |$LN25@Init@4|
  00008	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  0000c	e24ddf89	 sub         sp, sp, #0x89, 30
  00010		 |$M44274|
  00010	e1a05000	 mov         r5, r0
  00014	e59f3200	 ldr         r3, [pc, #0x200]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3220	 str         r3, [sp, #0x220]

; 475  :     int i;    
; 476  :     BOOL bReturn;
; 477  :     TCHAR szDefaultClientDriver[MAX_PATH+1]={'R','N','D','I','S'};

  00020	e3a0204e	 mov         r2, #0x4E
  00024	e3a01044	 mov         r1, #0x44
  00028	e3a00049	 mov         r0, #0x49
  0002c	e1cd21b6	 strh        r2, [sp, #0x16]
  00030	e1cd11b8	 strh        r1, [sp, #0x18]
  00034	e1cd01ba	 strh        r0, [sp, #0x1A]
  00038	e3a03052	 mov         r3, #0x52
  0003c	e3a0e053	 mov         lr, #0x53
  00040	e3a02c02	 mov         r2, #2, 24
  00044	e3a01000	 mov         r1, #0
  00048	e28d001e	 add         r0, sp, #0x1E
  0004c	e1cd31b4	 strh        r3, [sp, #0x14]
  00050	e1cde1bc	 strh        lr, [sp, #0x1C]
  00054	eb000000	 bl          memset

; 478  : 
; 479  :     m_pOTG = (PHSMUSB_T)LocalAlloc(LPTR, sizeof(HSMUSB_T));

  00058	e3a01068	 mov         r1, #0x68
  0005c	e3a00040	 mov         r0, #0x40
  00060	eb000000	 bl          LocalAlloc
  00064	e3500000	 cmp         r0, #0
  00068	e5850150	 str         r0, [r5, #0x150]

; 480  :     if (m_pOTG == NULL)

  0006c	1a000003	 bne         |$LN14@Init@4|
  00070		 |$LN22@Init@4|

; 481  :     {
; 482  :         DEBUGMSG(ZONE_OTG_ERROR, (TEXT("Failure to allocate m_pOTG memory\r\n")));
; 483  :         return FALSE;

  00070	e59d0220	 ldr         r0, [sp, #0x220]
  00074	eb000000	 bl          __security_check_cookie
  00078	e3a04000	 mov         r4, #0
  0007c	ea00005d	 b           |$LN15@Init@4|
  00080		 |$LN14@Init@4|

; 484  :     }
; 485  : 
; 486  :     memset(m_pOTG, 0x00, sizeof(HSMUSB_T)); 

  00080	e3a02068	 mov         r2, #0x68
  00084	e3a01000	 mov         r1, #0
  00088	eb000000	 bl          memset

; 487  :     // Other initialization should be done here...    
; 488  : 
; 489  :     m_pOTG->dwPwrMgmt = MODE_SYSTEM_NORMAL;

  0008c	e5953150	 ldr         r3, [r5, #0x150]
  00090	e3a07000	 mov         r7, #0
  00094	e3a04000	 mov         r4, #0
  00098	e5837064	 str         r7, [r3, #0x64]
  0009c		 |$LL13@Init@4|

; 490  :     for (i = 0; i < 2; i++)
; 491  :         m_pOTG->hReadyEvents[i] = CreateEvent(0, FALSE, FALSE, NULL);

  0009c	e3a03000	 mov         r3, #0
  000a0	e3a02000	 mov         r2, #0
  000a4	e3a01000	 mov         r1, #0
  000a8	e3a00000	 mov         r0, #0
  000ac	eb000000	 bl          CreateEventW
  000b0	e5953150	 ldr         r3, [r5, #0x150]
  000b4	e7830004	 str         r0, [r3, +r4]
  000b8	e2844004	 add         r4, r4, #4
  000bc	e3540008	 cmp         r4, #8
  000c0	bafffff5	 blt         |$LL13@Init@4|

; 492  : 
; 493  :     if(!MapHardware())

  000c4	e1a00005	 mov         r0, r5
  000c8	eb000000	 bl          |?MapHardware@OMAPMHSUSBOTG@@AAAHXZ|
  000cc	e3500000	 cmp         r0, #0

; 494  :     {
; 495  :         DEBUGMSG(ZONE_OTG_ERROR, (TEXT("Failure to map hardware\r\n")));
; 496  :         return FALSE;

  000d0	0affffe6	 beq         |$LN22@Init@4|

; 497  :     }
; 498  :     
; 499  :     InitializeCriticalSection(&m_pOTG->regCS);

  000d4	e5953150	 ldr         r3, [r5, #0x150]
  000d8	e2830038	 add         r0, r3, #0x38
  000dc	eb000000	 bl          InitializeCriticalSection

; 500  : 
; 501  :     UpdateDevicePower(m_hParent, D0, NULL);

  000e0	e59f2130	 ldr         r2, [pc, #0x130]
  000e4	e5950140	 ldr         r0, [r5, #0x140]
  000e8	e5923000	 ldr         r3, [r2]
  000ec	e3530000	 cmp         r3, #0
  000f0	13a03000	 movne       r3, #0
  000f4	15823000	 strne       r3, [r2]
  000f8	13a02000	 movne       r2, #0
  000fc	13a01000	 movne       r1, #0
  00100	1b000000	 blne        SetDevicePowerState

; 502  :     m_pOTG->bClockStatus = TRUE;

  00104	e5953150	 ldr         r3, [r5, #0x150]
  00108	e3a08001	 mov         r8, #1

; 503  :     m_fPowerRequest = FALSE;
; 504  : 
; 505  : 	if (!RequestDevicePads(OMAP_DEVICE_HSOTGUSB))

  0010c	e3a00003	 mov         r0, #3
  00110	e5838060	 str         r8, [r3, #0x60]
  00114	e58571a0	 str         r7, [r5, #0x1A0]
  00118	eb000000	 bl          RequestDevicePads
  0011c	e3500000	 cmp         r0, #0

; 506  : 	{
; 507  : 	    DEBUGMSG(ZONE_OTG_ERROR, (TEXT("Failure to request pads\r\n")));
; 508  :         return FALSE;

  00120	0affffd2	 beq         |$LN22@Init@4|

; 509  : 	}
; 510  : 
; 511  :     m_pTransceiver = CreateHSUSBOTGTransceiver(m_pOTG);

  00124	e5950150	 ldr         r0, [r5, #0x150]
  00128	eb000000	 bl          CreateHSUSBOTGTransceiver
  0012c	e3500000	 cmp         r0, #0
  00130	e58500fc	 str         r0, [r5, #0xFC]

; 512  :     if (!m_pTransceiver)
; 513  :     {
; 514  :         DEBUGMSG(ZONE_OTG_ERROR, (TEXT("Failure to initialize OTG Transceiver\r\n")));
; 515  :         return FALSE;

  00134	0affffcd	 beq         |$LN22@Init@4|

; 516  :     }
; 517  : 
; 518  :     // manually reset transceiver (Advisory 3.0.1.144)
; 519  :     m_pTransceiver->Reset();

  00138	e5903000	 ldr         r3, [r0]
  0013c	e5933024	 ldr         r3, [r3, #0x24]
  00140	e1a0e00f	 mov         lr, pc
  00144	e12fff13	 bx          r3

; 520  : 
; 521  :     {
; 522  :         HKEY hkDevice;
; 523  :         DWORD dwStatus;
; 524  :         DWORD dwType, dwSize;
; 525  : 
; 526  :         dwStatus = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCTSTR) REG_USBFN_DEFAULT_FUNC_DRV_PATH, 0, KEY_ALL_ACCESS, &hkDevice);

  00148	e59f10c4	 ldr         r1, [pc, #0xC4]
  0014c	e3a0380f	 mov         r3, #0xF, 16
  00150	e28de008	 add         lr, sp, #8
  00154	e383303f	 orr         r3, r3, #0x3F
  00158	e3a02000	 mov         r2, #0
  0015c	e3a0010a	 mov         r0, #0xA, 2
  00160	e58de000	 str         lr, [sp]
  00164	eb000000	 bl          RegOpenKeyExW
  00168	e3500000	 cmp         r0, #0

; 527  :         if(dwStatus != ERROR_SUCCESS) {

  0016c	1a00000f	 bne         |$LN6@Init@4|
  00170	e3a03c02	 mov         r3, #2, 24

; 528  :                  DEBUGMSG(ZONE_OTG_ERROR, (_T("UfnPdd_Init: OpenDeviceKey('%s') failed %u\r\n"), REG_USBFN_DRV_PATH, dwStatus));
; 529  :         }
; 530  :         else
; 531  :         {
; 532  :             dwType = REG_SZ;
; 533  :             dwSize = sizeof(szDefaultClientDriver);
; 534  :             dwStatus = ::RegQueryValueEx( hkDevice,
; 535  :                                         REG_USBFN_DEFAULT_FUNC_DRV,
; 536  :                                         NULL,
; 537  :                                         &dwType,
; 538  :                                         (LPBYTE)&szDefaultClientDriver,
; 539  :                                         &dwSize);

  00174	e59f1094	 ldr         r1, [pc, #0x94]
  00178	e59d0008	 ldr         r0, [sp, #8]
  0017c	e383300a	 orr         r3, r3, #0xA
  00180	e58d300c	 str         r3, [sp, #0xC]
  00184	e3a06001	 mov         r6, #1
  00188	e28de00c	 add         lr, sp, #0xC
  0018c	e28d4014	 add         r4, sp, #0x14
  00190	e28d3010	 add         r3, sp, #0x10
  00194	e3a02000	 mov         r2, #0
  00198	e58d6010	 str         r6, [sp, #0x10]
  0019c	e58de004	 str         lr, [sp, #4]
  001a0	e58d4000	 str         r4, [sp]
  001a4	eb000000	 bl          RegQueryValueExW

; 540  : 
; 541  :              if(dwStatus != ERROR_SUCCESS || dwType != REG_SZ) {
; 542  :                   DEBUGMSG(ZONE_OTG_ERROR, (_T("UFNPDD_Init: RegQueryValueEx('%s', '%s') failed %u\r\n"),
; 543  :                           REG_USBFN_DEFAULT_FUNC_DRV_PATH, REG_USBFN_DEFAULT_FUNC_DRV, dwStatus));
; 544  :              }
; 545  : 
; 546  :              RegCloseKey(hkDevice);

  001a8	e59d0008	 ldr         r0, [sp, #8]
  001ac	eb000000	 bl          RegCloseKey
  001b0		 |$LN6@Init@4|

; 547  :         }
; 548  :     }
; 549  : 
; 550  :     if(strcmp((const char*)&szDefaultClientDriver,"RNDIS")||strcmp((const char*)&szDefaultClientDriver,"Serial_Class"))

  001b0	e59f1054	 ldr         r1, [pc, #0x54]
  001b4	e28d0014	 add         r0, sp, #0x14
  001b8	eb000000	 bl          strcmp
  001bc	e3500000	 cmp         r0, #0
  001c0	1a000005	 bne         |$LN2@Init@4|
  001c4	e59f103c	 ldr         r1, [pc, #0x3C]
  001c8	e28d0014	 add         r0, sp, #0x14
  001cc	eb000000	 bl          strcmp
  001d0	e3500000	 cmp         r0, #0

; 553  :     }
; 554  :     else
; 555  :     {
; 556  :         m_fDelayRequired = FALSE;

  001d4	0585719c	 streq       r7, [r5, #0x19C]
  001d8	0a000000	 beq         |$LN1@Init@4|
  001dc		 |$LN2@Init@4|

; 551  :     {
; 552  :         m_fDelayRequired = TRUE;

  001dc	e585819c	 str         r8, [r5, #0x19C]
  001e0		 |$LN1@Init@4|

; 557  :     }
; 558  : 
; 559  : 
; 560  :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Accessing register with parent (0x%x)\r\n"), m_hParent));
; 561  : 
; 562  :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("FAddr = 0x%x\r\n"), INREG8(&m_pOTG->pUsbGenRegs->FAddr)));
; 563  :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("Power = 0x%x\r\n"), INREG8(&m_pOTG->pUsbGenRegs->Power)));
; 564  :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("IntrTXE = 0x%x\r\n"), INREG16(&m_pOTG->pUsbGenRegs->IntrTxE)));
; 565  :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("IntrRXE = 0x%x\r\n"), INREG16(&m_pOTG->pUsbGenRegs->IntrRxE)));
; 566  :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("OTG_Rev = 0x%x\r\n"), INREG32(&m_pOTG->pUsbOtgRegs->OTG_Rev)));
; 567  :     DEBUGMSG(ZONE_OTG_FUNCTION, (TEXT("HW Ver = 0x%x\r\n"), INREG32(&m_pOTG->pUsbGenRegs->HWVers)));
; 568  : 
; 569  :     bReturn = USBOTG::Init();

  001e0	e1a00005	 mov         r0, r5
  001e4	eb000000	 bl          |?Init@USBOTG@@UAAHXZ|
  001e8	e1a04000	 mov         r4, r0

; 570  :     
; 571  :     m_dwUSBUsageCount = 0;  

  001ec	e5857160	 str         r7, [r5, #0x160]

; 572  :     
; 573  :     return bReturn;

  001f0	e59d0220	 ldr         r0, [sp, #0x220]
  001f4	eb000000	 bl          __security_check_cookie
  001f8		 |$LN15@Init@4|

; 574  : }

  001f8	e1a00004	 mov         r0, r4
  001fc	e28ddf89	 add         sp, sp, #0x89, 30
  00200	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00204	e12fff1e	 bx          lr
  00208		 |$LN26@Init@4|
  00208		 |$LN27@Init@4|
  00208	00000000	 DCD         |??_C@_0N@GCHGAKML@Serial_Class?$AA@|
  0020c		 |$LN28@Init@4|
  0020c	00000000	 DCD         |??_C@_05BCBDGGDK@RNDIS?$AA@|
  00210		 |$LN29@Init@4|
  00210	00000000	 DCD         |??_C@_1CI@MGKPCHDE@?$AAD?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?$AA@|
  00214		 |$LN30@Init@4|
  00214	00000000	 DCD         |??_C@_1DI@KIDPGBEF@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAU?$AAS?$AAB?$AA?2?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?$AA@|
  00218		 |$LN31@Init@4|
  00218	00000000	 DCD         |?g_busDx@@3W4_CEDEVICE_POWER_STATE@@A|
  0021c		 |$LN32@Init@4|
  0021c	00000000	 DCD         |__security_cookie|
  00220		 |$M44275|

			 ENDP  ; |?Init@OMAPMHSUSBOTG@@UAAHXZ|, OMAPMHSUSBOTG::Init

	EXPORT	|??_C@_1BO@CDMCIFON@?$AAd?$AAm?$AAa?$AAI?$AAs?$AAt?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BO@HHIOKHGA@?$AAo?$AAt?$AAg?$AAI?$AAs?$AAt?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CC@NBEJDCFF@?$AAi?$AAd?$AAg?$AAn?$AAd?$AAI?$AAs?$AAt?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CE@GPPIHNAH@?$AAV?$AAb?$AAu?$AAs?$AAD?$AAi?$AAs?$AAc?$AAh?$AAa?$AAr?$AAg?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1O@KFOJGKH@?$AAD?$AAM?$AAA?$AAI?$AAr?$AAq?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T44292| DCD	|$LN5@dynamic|
	DCD	0x40000700

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BO@CDMCIFON@?$AAd?$AAm?$AAa?$AAI?$AAs?$AAt?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?$AA@| DCB "d"
	DCB	0x0, "m", 0x0, "a", 0x0, "I", 0x0, "s", 0x0, "t", 0x0, "P"
	DCB	0x0, "r", 0x0, "i", 0x0, "o", 0x0, "r", 0x0, "i", 0x0, "t"
	DCB	0x0, "y", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BO@HHIOKHGA@?$AAo?$AAt?$AAg?$AAI?$AAs?$AAt?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?$AA@| DCB "o"
	DCB	0x0, "t", 0x0, "g", 0x0, "I", 0x0, "s", 0x0, "t", 0x0, "P"
	DCB	0x0, "r", 0x0, "i", 0x0, "o", 0x0, "r", 0x0, "i", 0x0, "t"
	DCB	0x0, "y", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@NBEJDCFF@?$AAi?$AAd?$AAg?$AAn?$AAd?$AAI?$AAs?$AAt?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?$AA@| DCB "i"
	DCB	0x0, "d", 0x0, "g", 0x0, "n", 0x0, "d", 0x0, "I", 0x0, "s"
	DCB	0x0, "t", 0x0, "P", 0x0, "r", 0x0, "i", 0x0, "o", 0x0, "r"
	DCB	0x0, "i", 0x0, "t", 0x0, "y", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CE@GPPIHNAH@?$AAV?$AAb?$AAu?$AAs?$AAD?$AAi?$AAs?$AAc?$AAh?$AAa?$AAr?$AAg?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$AA@| DCB "V"
	DCB	0x0, "b", 0x0, "u", 0x0, "s", 0x0, "D", 0x0, "i", 0x0, "s"
	DCB	0x0, "c", 0x0, "h", 0x0, "a", 0x0, "r", 0x0, "g", 0x0, "e"
	DCB	0x0, "T", 0x0, "i", 0x0, "m", 0x0, "e", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1O@KFOJGKH@?$AAD?$AAM?$AAA?$AAI?$AAr?$AAq?$AA?$AA@| DCB "D", 0x0, "M"
	DCB	0x0, "A", 0x0, "I", 0x0, "r", 0x0, "q", 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text$yc|, CODE, ARM

  00000		 |??__Es_deviceRegParams@@YAXXZ| PROC	; `dynamic initializer for 's_deviceRegParams''

; 108  :     }, 

  00000		 |$LN5@dynamic|
  00000		 |$M44289|
  00000	e59f3010	 ldr         r3, [pc, #0x10]
  00004	e59f2008	 ldr         r2, [pc, #8]
  00008	e5933000	 ldr         r3, [r3]
  0000c	e5823044	 str         r3, [r2, #0x44]

; 109  :     {
; 110  :         L"DMAIrq", PARAM_DWORD, FALSE, offset(MUsbOTGRegCfg_t, DMAIrq),
; 111  :             fieldsize(MUsbOTGRegCfg_t, DMAIrq), (void *) 93
; 112  :     },
; 113  :     {
; 114  :         L"VbusDischargeTime", PARAM_DWORD, FALSE, offset(MUsbOTGRegCfg_t, vbusDischargeTime),
; 115  :             fieldsize(MUsbOTGRegCfg_t, vbusDischargeTime), (void *) 100
; 116  :     },
; 117  :     {
; 118  :         L"idgndIstPriority", PARAM_DWORD, FALSE, offset(MUsbOTGRegCfg_t, idgndIstPrio),
; 119  :             fieldsize(MUsbOTGRegCfg_t, idgndIstPrio), (void *) IDGND_IST_PRIORITY
; 120  :     }, 
; 121  :     {
; 122  :         L"otgIstPriority", PARAM_DWORD, FALSE, offset(MUsbOTGRegCfg_t, otgIstPrio),
; 123  :             fieldsize(MUsbOTGRegCfg_t, otgIstPrio), (void *) OTG_IST_PRIORITY
; 124  :     },
; 125  :     {
; 126  :         L"dmaIstPriority", PARAM_DWORD, FALSE, offset(MUsbOTGRegCfg_t, dmaIstPrio),
; 127  :             fieldsize(MUsbOTGRegCfg_t, dmaIstPrio), (void *) DMA_IST_PRIORITY
; 128  :     }
; 129  :     
; 130  : };

  00010	e12fff1e	 bx          lr
  00014		 |$LN6@dynamic|
  00014		 |$LN7@dynamic|
  00014	00000000	 DCD         |s_deviceRegParams|
  00018		 |$LN8@dynamic|
  00018	00000000	 DCD         |pChargerNameEvt|
  0001c		 |$M44290|

			 ENDP  ; |??__Es_deviceRegParams@@YAXXZ|, `dynamic initializer for 's_deviceRegParams''


  00008			 AREA	 |.data|, DATA
|s_deviceRegParams| DCD |??_C@_1BO@DFKBGJHN@?$AAs?$AAt?$AAa?$AAr?$AAt?$AAu?$AAp?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x4
	DCD	0x4
	DCD	0x1388
	DCD	|??_C@_1CC@EBHGALEG@?$AAD?$AAi?$AAs?$AAa?$AAb?$AAl?$AAe?$AAH?$AAi?$AAg?$AAh?$AAS?$AAp?$AAe?$AAe?$AAd?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x0
	DCD	0x4
	DCD	0x1
	DCD	|??_C@_1CC@CKFJFILD@?$AAU?$AAS?$AAB?$AAC?$AAh?$AAa?$AAr?$AAg?$AAe?$AAr?$AAN?$AAo?$AAt?$AAi?$AAf?$AAy?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x8
	DCD	0x4
	DCB	0x0
	DCB	0x0
	DCB	0x0
	DCB	0x0
	DCD	|??_C@_1O@KFOJGKH@?$AAD?$AAM?$AAA?$AAI?$AAr?$AAq?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0xc
	DCD	0x4
	DCD	0x5d
	DCD	|??_C@_1CE@GPPIHNAH@?$AAV?$AAb?$AAu?$AAs?$AAD?$AAi?$AAs?$AAc?$AAh?$AAa?$AAr?$AAg?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x14
	DCD	0x4
	DCD	0x64
	DCD	|??_C@_1CC@NBEJDCFF@?$AAi?$AAd?$AAg?$AAn?$AAd?$AAI?$AAs?$AAt?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x18
	DCD	0x4
	DCD	0x83
	DCD	|??_C@_1BO@HHIOKHGA@?$AAo?$AAt?$AAg?$AAI?$AAs?$AAt?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x1c
	DCD	0x4
	DCD	0x82
	DCD	|??_C@_1BO@CDMCIFON@?$AAd?$AAm?$AAa?$AAI?$AAs?$AAt?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x20
	DCD	0x4
	DCD	0x81

  00000			 AREA	 |.CRT$XCU|, DATA
|s_deviceRegParams$initializer$| DCD |??__Es_deviceRegParams@@YAXXZ|
	END
