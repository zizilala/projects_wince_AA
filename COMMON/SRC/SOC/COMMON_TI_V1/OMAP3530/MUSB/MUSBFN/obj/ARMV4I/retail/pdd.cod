; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\OMAP3530\MUSB\MUSBFN\pdd.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1BE@EKANOLAD@?$AAD?$AAV?$AAF?$AAS?$AAO?$AAr?$AAd?$AAe?$AAr?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BE@MNALJNHA@?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAD?$AAM?$AAA?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BI@IJPKENOC@?$AAT?$AAx?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BI@DJMHBPLC@?$AAR?$AAx?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@OJINAFBD@?$AAT?$AAx?$AAD?$AAm?$AAa?$AAE?$AAp?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@LKBMGMPH@?$AAR?$AAx?$AAD?$AAm?$AAa?$AAE?$AAp?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|Device_ProcessDMA|
	EXPORT	|Device_Suspend|
	EXPORT	|Device_Disconnect|
	EXPORT	|Device_ProcessEPx_TX|
	EXPORT	|Device_ProcessEPx_RX|
	EXPORT	|Device_ProcessEP0|
	EXPORT	|Device_ResumeIRQ|
	EXPORT	|Device_ResetIRQ|
	EXPORT	|gc_MUsbFuncs| [ DATA ]

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@EKANOLAD@?$AAD?$AAV?$AAF?$AAS?$AAO?$AAr?$AAd?$AAe?$AAr?$AA?$AA@| DCB "D"
	DCB	0x0, "V", 0x0, "F", 0x0, "S", 0x0, "O", 0x0, "r", 0x0, "d"
	DCB	0x0, "e", 0x0, "r", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@MNALJNHA@?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAD?$AAM?$AAA?$AA?$AA@| DCB "E"
	DCB	0x0, "n", 0x0, "a", 0x0, "b", 0x0, "l", 0x0, "e", 0x0, "D"
	DCB	0x0, "M", 0x0, "A", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BI@IJPKENOC@?$AAT?$AAx?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$AA@| DCB "T"
	DCB	0x0, "x", 0x0, "D", 0x0, "m", 0x0, "a", 0x0, "B", 0x0, "u"
	DCB	0x0, "f", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BI@DJMHBPLC@?$AAR?$AAx?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$AA@| DCB "R"
	DCB	0x0, "x", 0x0, "D", 0x0, "m", 0x0, "a", 0x0, "B", 0x0, "u"
	DCB	0x0, "f", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@OJINAFBD@?$AAT?$AAx?$AAD?$AAm?$AAa?$AAE?$AAp?$AA?$AA@| DCB "T", 0x0
	DCB	"x", 0x0, "D", 0x0, "m", 0x0, "a", 0x0, "E", 0x0, "p", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@LKBMGMPH@?$AAR?$AAx?$AAD?$AAm?$AAa?$AAE?$AAp?$AA?$AA@| DCB "R", 0x0
	DCB	"x", 0x0, "D", 0x0, "m", 0x0, "a", 0x0, "E", 0x0, "p", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.data|, DATA
|gc_MUsbFuncs| DCD |Device_ResetIRQ|
	DCD	|Device_ResumeIRQ|
	DCD	|Device_ProcessEP0|
	DCD	|Device_ProcessEPx_RX|
	DCD	|Device_ProcessEPx_TX|
	DCD	0x0
	DCD	|Device_Disconnect|
	DCD	|Device_Suspend|
	DCD	|Device_ProcessDMA|

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
|s_deviceRegParams| DCD |??_C@_1BA@LKBMGMPH@?$AAR?$AAx?$AAD?$AAm?$AAa?$AAE?$AAp?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0xc
	DCD	0x4
	DCD	0xffffffff
	DCD	|??_C@_1BA@OJINAFBD@?$AAT?$AAx?$AAD?$AAm?$AAa?$AAE?$AAp?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x10
	DCD	0x4
	DCD	0xffffffff
	DCD	|??_C@_1BI@DJMHBPLC@?$AAR?$AAx?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x14
	DCD	0x4
	DCD	0x2000
	DCD	|??_C@_1BI@IJPKENOC@?$AAT?$AAx?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x18
	DCD	0x4
	DCD	0x2800
	DCD	|??_C@_1BE@MNALJNHA@?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAD?$AAM?$AAA?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x8
	DCD	0x4
	DCD	0x1
	DCD	|??_C@_1BE@EKANOLAD@?$AAD?$AAV?$AAF?$AAS?$AAO?$AAr?$AAd?$AAe?$AAr?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x3fc
	DCD	0x4
	DCD	0x96
	EXPORT	|SetEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T48789| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M48786|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M48787|

			 ENDP  ; |SetEvent|

	EXPORT	|??_C@_1HG@LOFAKONP@?$AA?$CB?$AA?$CB?$AA?$CB?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?$DN?$AA?$DO?$AA?5?$AAP?$AAr?$AAe?$AAD?$AAm?$AAa?$AAA?$AAc?$AAt?$AAi?$AAv?$AAi?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAw@| [ DATA ] ; `string'
	IMPORT	|InterlockedIncrement|
	IMPORT	|Sleep|
	IMPORT	|LeaveCriticalSection|
	IMPORT	|WaitForSingleObject|
	IMPORT	|EnterCriticalSection|
	IMPORT	|NKDbgPrintfW|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbfn\pdd.c

  00000			 AREA	 |.pdata|, PDATA
|$T48801| DCD	|$LN15@PreDmaActi|
	DCD	0x40002901

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HG@LOFAKONP@?$AA?$CB?$AA?$CB?$AA?$CB?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?$DN?$AA?$DO?$AA?5?$AAP?$AAr?$AAe?$AAD?$AAm?$AAa?$AAA?$AAc?$AAt?$AAi?$AAv?$AAi?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAw@| DCB "!"
	DCB	0x0, "!", 0x0, "!", 0x0, " ", 0x0, "E", 0x0, "R", 0x0, "R"
	DCB	0x0, "O", 0x0, "R", 0x0, " ", 0x0, "=", 0x0, ">", 0x0, " "
	DCB	0x0, "P", 0x0, "r", 0x0, "e", 0x0, "D", 0x0, "m", 0x0, "a"
	DCB	0x0, "A", 0x0, "c", 0x0, "t", 0x0, "i", 0x0, "v", 0x0, "i"
	DCB	0x0, "a", 0x0, "t", 0x0, "i", 0x0, "o", 0x0, "n", 0x0, " "
	DCB	0x0, "w", 0x0, "r", 0x0, "o", 0x0, "n", 0x0, "g", 0x0, " "
	DCB	0x0, "f", 0x0, "o", 0x0, "r", 0x0, " ", 0x0, "E", 0x0, "P"
	DCB	0x0, " ", 0x0, "%", 0x0, "d", 0x0, ",", 0x0, " ", 0x0, "s"
	DCB	0x0, "t", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, " ", 0x0, "%"
	DCB	0x0, "d", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PreDmaActivation| PROC

; 169  : {

  00000		 |$LN15@PreDmaActi|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M48798|
  00004	e1a04000	 mov         r4, r0

; 170  : #ifdef DEBUG
; 171  : 	MUsbFnEp_t *pEP = &pPdd->ep[endPoint];
; 172  :     STransfer *pTransfer = pEP->pTransfer;
; 173  : #endif    
; 174  : 
; 175  : 	UNREFERENCED_PARAMETER(TxRx);
; 176  : 
; 177  :     DEBUGMSG(ZONE_FUNCTION, (
; 178  :         L"+PreDmaActivation\r\n"
; 179  :     ));
; 180  : 
; 181  :     if (pPdd->ep[endPoint].dmaDVFSstate != DVFS_PREDMA)

  00008	e3a03034	 mov         r3, #0x34
  0000c	e0224391	 mla         r2, r1, r3, r4
  00010	e5d230d8	 ldrb        r3, [r2, #0xD8]
  00014	e3530001	 cmp         r3, #1

; 182  :         pPdd->ep[endPoint].dmaDVFSstate = DVFS_PREDMA;
; 183  :     else
; 184  :         RETAILMSG(1, (TEXT("!!! ERROR => PreDmaActiviation wrong for EP %d, state %d\r\n"),
; 185  :             endPoint, pPdd->ep[endPoint].dmaDVFSstate));

  00018	059f0080	 ldreq       r0, [pc, #0x80]
  0001c	13a03001	 movne       r3, #1
  00020	15c230d8	 strneb      r3, [r2, #0xD8]
  00024	03a02001	 moveq       r2, #1
  00028	0b000000	 bleq        NKDbgPrintfW

; 186  : 
; 187  :     for(;;)
; 188  :     {
; 189  :     
; 190  :         // this operation needs to be atomic to handle a corner case
; 191  :         EnterCriticalSection(&pPdd->csDVFS);

  0002c	e2845b01	 add         r5, r4, #1, 22
  00030	e2850014	 add         r0, r5, #0x14
  00034	eb000000	 bl          EnterCriticalSection

; 192  : 
; 193  :         // check and wait for DVFS activity to complete
; 194  :         if (pPdd->bDVFSActive == TRUE)

  00038	e5943400	 ldr         r3, [r4, #0x400]
  0003c	e3530001	 cmp         r3, #1
  00040	1a00000f	 bne         |$LN3@PreDmaActi|
  00044	e3a03c01	 mov         r3, #1, 24
  00048	e3836002	 orr         r6, r3, #2
  0004c		 |$LL5@PreDmaActi|

; 195  :         {
; 196  :             DWORD dwRet;
; 197  : 
; 198  :             DEBUGMSG(ZONE_FUNCTION, (L"*** DVFS in progress wait before doing DMA\r\n"));
; 199  :             dwRet = WaitForSingleObject(pPdd->hDVFSActivityEvent, 0);

  0004c	e5940410	 ldr         r0, [r4, #0x410]
  00050	e3a01000	 mov         r1, #0
  00054	eb000000	 bl          WaitForSingleObject

; 200  :             if (dwRet != WAIT_TIMEOUT)

  00058	e1560000	 cmp         r6, r0
  0005c	1a000008	 bne         |$LN3@PreDmaActi|

; 216  :             break;
; 217  :         }
; 218  :         LeaveCriticalSection(&pPdd->csDVFS);  // hDVFSActivityEvent not signaled

  00060	e2850014	 add         r0, r5, #0x14
  00064	eb000000	 bl          LeaveCriticalSection

; 219  :         Sleep(1);

  00068	e3a00001	 mov         r0, #1
  0006c	eb000000	 bl          Sleep
  00070	e2850014	 add         r0, r5, #0x14
  00074	eb000000	 bl          EnterCriticalSection
  00078	e5943400	 ldr         r3, [r4, #0x400]
  0007c	e3530001	 cmp         r3, #1
  00080	0afffff1	 beq         |$LL5@PreDmaActi|
  00084		 |$LN3@PreDmaActi|

; 201  :             {
; 202  :                 InterlockedIncrement(&pPdd->nActiveDmaCount);
; 203  :                 DEBUGMSG(ZONE_DVFS, (L"***PreDma (DVFS) DmaCount(%d) endpoint(%d) Tx0Rx1(%d) pTransfer(0x%x) pBuffer(0x%x) cBuffer(%d) cTransfer(%d)\r\n",
; 204  :                     pPdd->nActiveDmaCount,endPoint, TxRx, pTransfer, pTransfer->pvBuffer, pTransfer->cbBuffer, pTransfer->cbTransferred));
; 205  :                 LeaveCriticalSection(&pPdd->csDVFS);
; 206  :                 break;
; 207  :             }
; 208  :         }
; 209  :         else
; 210  :         {
; 211  :             InterlockedIncrement(&pPdd->nActiveDmaCount);

  00084	e2843b01	 add         r3, r4, #1, 22
  00088	e2830008	 add         r0, r3, #8
  0008c	eb000000	 bl          InterlockedIncrement

; 212  :             DEBUGMSG(ZONE_DVFS, (L"***PreDma (NonDVFS) DmaCount(%d) endpoint(%d) Tx0Rx1(%d) pTransfer(0x%x) pBuffer(0x%x) cBuffer(%d) cTransfer(%d)\r\n",
; 213  :                 pPdd->nActiveDmaCount,endPoint, TxRx, pTransfer, pTransfer->pvBuffer, pTransfer->cbBuffer, pTransfer->cbTransferred));
; 214  : 
; 215  :             LeaveCriticalSection(&pPdd->csDVFS);

  00090	e2850014	 add         r0, r5, #0x14
  00094	eb000000	 bl          LeaveCriticalSection

; 220  :     }
; 221  : 
; 222  : }

  00098	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$LN16@PreDmaActi|
  000a0		 |$LN17@PreDmaActi|
  000a0	00000000	 DCD         |??_C@_1HG@LOFAKONP@?$AA?$CB?$AA?$CB?$AA?$CB?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?$DN?$AA?$DO?$AA?5?$AAP?$AAr?$AAe?$AAD?$AAm?$AAa?$AAA?$AAc?$AAt?$AAi?$AAv?$AAi?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAw@|
  000a4		 |$M48799|

			 ENDP  ; |PreDmaActivation|

	EXPORT	|??_C@_1DO@NHKFAELP@?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CD?$AA?$CD?$AA?$CD?$AAP?$AAo?$AAs?$AAt?$AAD?$AAm?$AAa?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAo?$AAn?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FI@LMBAMPFN@?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CD?$AA?$CD?$AA?$CD?$AAP?$AAo?$AAs?$AAt?$AAD?$AAm?$AAa?$AA?0?$AA?5?$AAn?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AAD?$AAm?$AAa?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM@| [ DATA ] ; `string'
	IMPORT	|InterlockedDecrement|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T48816| DCD	|$LN10@PostDmaDea|
	DCD	0x40002901

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DO@NHKFAELP@?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CD?$AA?$CD?$AA?$CD?$AAP?$AAo?$AAs?$AAt?$AAD?$AAm?$AAa?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAo?$AAn?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| DCB "*"
	DCB	0x0, "*", 0x0, "*", 0x0, "#", 0x0, "#", 0x0, "#", 0x0, "P"
	DCB	0x0, "o", 0x0, "s", 0x0, "t", 0x0, "D", 0x0, "m", 0x0, "a"
	DCB	0x0, " ", 0x0, "e", 0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r"
	DCB	0x0, " ", 0x0, "o", 0x0, "n", 0x0, " ", 0x0, "E", 0x0, "P"
	DCB	0x0, " ", 0x0, "%", 0x0, "d", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FI@LMBAMPFN@?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CD?$AA?$CD?$AA?$CD?$AAP?$AAo?$AAs?$AAt?$AAD?$AAm?$AAa?$AA?0?$AA?5?$AAn?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AAD?$AAm?$AAa?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM@| DCB "*"
	DCB	0x0, "*", 0x0, "*", 0x0, "#", 0x0, "#", 0x0, "#", 0x0, "P"
	DCB	0x0, "o", 0x0, "s", 0x0, "t", 0x0, "D", 0x0, "m", 0x0, "a"
	DCB	0x0, ",", 0x0, " ", 0x0, "n", 0x0, "A", 0x0, "c", 0x0, "t"
	DCB	0x0, "i", 0x0, "v", 0x0, "e", 0x0, "D", 0x0, "m", 0x0, "a"
	DCB	0x0, "C", 0x0, "o", 0x0, "u", 0x0, "n", 0x0, "t", 0x0, " "
	DCB	0x0, "<", 0x0, " ", 0x0, "0", 0x0, " ", 0x0, "(", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "x", 0x0, ")", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbfn\pdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PostDmaDeactivation| PROC

; 232  : {

  00000		 |$LN10@PostDmaDea|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M48813|
  00004	e1a07001	 mov         r7, r1
  00008	e1a04000	 mov         r4, r0

; 233  : #ifdef DEBUG	
; 234  : 	MUsbFnEp_t *pEP = &pPdd->ep[endPoint];
; 235  : 	STransfer *pTransfer = pEP->pTransfer;
; 236  : #endif
; 237  : 
; 238  : 	UNREFERENCED_PARAMETER(endPoint);
; 239  : 	UNREFERENCED_PARAMETER(TxRx);
; 240  : 
; 241  :     DEBUGMSG(ZONE_FUNCTION, (
; 242  :         L"+PostDmaDeactivation\r\n"
; 243  :     ));
; 244  :     
; 245  :     ASSERT(pPdd->nActiveDmaCount > 0);
; 246  : 
; 247  :     // this operation needs to be atomic to handle a corner case
; 248  :     EnterCriticalSection(&pPdd->csDVFS);

  0000c	e2846b01	 add         r6, r4, #1, 22
  00010	e2860014	 add         r0, r6, #0x14
  00014	eb000000	 bl          EnterCriticalSection

; 249  :     
; 250  :     // check if all dma's are inactive and signal ack event if so
; 251  :     InterlockedDecrement(&pPdd->nActiveDmaCount);

  00018	e2845b01	 add         r5, r4, #1, 22
  0001c	e2850008	 add         r0, r5, #8
  00020	eb000000	 bl          InterlockedDecrement

; 252  :     if (pPdd->nActiveDmaCount < 0)

  00024	e5943408	 ldr         r3, [r4, #0x408]
  00028	e3530000	 cmp         r3, #0
  0002c	aa000009	 bge         |$LN2@PostDmaDea|

; 253  :     {
; 254  :         RETAILMSG(1, (L"***###PostDma error on EP %d\r\n", endPoint));

  00030	e59f0068	 ldr         r0, [pc, #0x68]
  00034	e1a01007	 mov         r1, r7
  00038	eb000000	 bl          NKDbgPrintfW

; 255  :         RETAILMSG(1, (L"***###PostDma, nActiveDmaCount < 0 (0x%x)\r\n", pPdd->nActiveDmaCount));

  0003c	e5941408	 ldr         r1, [r4, #0x408]
  00040	e59f0054	 ldr         r0, [pc, #0x54]
  00044	eb000000	 bl          NKDbgPrintfW

; 256  :         // this may be a race condition in which it stops DMA and then process back the
; 257  :         if (pPdd->bDVFSAck == TRUE) 

  00048	e5943404	 ldr         r3, [r4, #0x404]
  0004c	e3530001	 cmp         r3, #1

; 258  :             InterlockedIncrement(&pPdd->nActiveDmaCount);       

  00050	02850008	 addeq       r0, r5, #8
  00054	0b000000	 bleq        InterlockedIncrement
  00058		 |$LN2@PostDmaDea|

; 259  :     }    
; 260  : 
; 261  :     if (pPdd->bDVFSActive == TRUE && pPdd->nActiveDmaCount <= 0 && pPdd->bDVFSAck == FALSE)

  00058	e5943400	 ldr         r3, [r4, #0x400]
  0005c	e3530001	 cmp         r3, #1
  00060	1a000009	 bne         |$LN6@PostDmaDea|
  00064	e5943408	 ldr         r3, [r4, #0x408]
  00068	e3530000	 cmp         r3, #0
  0006c	ca000006	 bgt         |$LN6@PostDmaDea|
  00070	e5943404	 ldr         r3, [r4, #0x404]
  00074	e3530000	 cmp         r3, #0

; 262  :         {
; 263  :         DEBUGMSG(ZONE_DVFS, (L"***PostDma finished all Dma's set hDVFSAckEvent EP %d, TxRx %d\r\n", endPoint, TxRx));        
; 264  :         pPdd->bDVFSAck = TRUE;
; 265  :         SetEvent(pPdd->hDVFSAckEvent);

  00078	0594040c	 ldreq       r0, [r4, #0x40C]
  0007c	03a03001	 moveq       r3, #1
  00080	03a01003	 moveq       r1, #3
  00084	05843404	 streq       r3, [r4, #0x404]
  00088	0b000000	 bleq        EventModify
  0008c		 |$LN6@PostDmaDea|

; 266  :         }
; 267  : 
; 268  :     DEBUGMSG(ZONE_DVFS, (L"***PostDma DmaCount(%d) endpoint(%d) Tx0Rx1(%d) pTransfer(0x%x) pBuffer(0x%x) cBuffer(%d) cTransfer(%d)\r\n",
; 269  :             pPdd->nActiveDmaCount,endPoint, TxRx, pTransfer, pTransfer->pvBuffer, pTransfer->cbBuffer, pTransfer->cbTransferred));
; 270  :     LeaveCriticalSection(&pPdd->csDVFS);

  0008c	e2860014	 add         r0, r6, #0x14
  00090	eb000000	 bl          LeaveCriticalSection

; 271  : 
; 272  :     DEBUGMSG(ZONE_FUNCTION, (
; 273  :         L"-PostDmaDeactivation()\r\n"
; 274  :         ));
; 275  : }

  00094	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00098	e12fff1e	 bx          lr
  0009c		 |$LN11@PostDmaDea|
  0009c		 |$LN12@PostDmaDea|
  0009c	00000000	 DCD         |??_C@_1FI@LMBAMPFN@?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CD?$AA?$CD?$AA?$CD?$AAP?$AAo?$AAs?$AAt?$AAD?$AAm?$AAa?$AA?0?$AA?5?$AAn?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AAD?$AAm?$AAa?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM@|
  000a0		 |$LN13@PostDmaDea|
  000a0	00000000	 DCD         |??_C@_1DO@NHKFAELP@?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CD?$AA?$CD?$AA?$CD?$AAP?$AAo?$AAs?$AAt?$AAD?$AAm?$AAa?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAo?$AAn?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@|
  000a4		 |$M48814|

			 ENDP  ; |PostDmaDeactivation|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|memdump|
	EXPORT	|??_C@_15MAOEGKJF@?$AA?$CF?$AAS?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_02KNHHEEKP@?5?5?$AA@| [ DATA ]	; `string'
	EXPORT	|??_C@_03NDEAONJP@?5?5?5?$AA@| [ DATA ]	; `string'
	EXPORT	|??_C@_01CLKCMJKC@?5?$AA@| [ DATA ]	; `string'
	EXPORT	|??_C@_02LMMGGCAJ@?3?5?$AA@| [ DATA ]	; `string'
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|strlen|
	IMPORT	|strcat|
	IMPORT	|__security_check_cookie|

  00000			 AREA	 |.pdata|, PDATA
|$T48861| DCD	|$LN41@memdump|
	DCD	0xc0009e02

  00000			 AREA	 |.xdata|, DATA
|$T48857| DCD	0xffffffd8

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_15MAOEGKJF@?$AA?$CF?$AAS?$AA?$AA@| DCB "%", 0x0, "S", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_02KNHHEEKP@?5?5?$AA@| DCB "  ", 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_03NDEAONJP@?5?5?5?$AA@| DCB "   ", 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_01CLKCMJKC@?5?$AA@| DCB " ", 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_02LMMGGCAJ@?3?5?$AA@| DCB ": ", 0x0		; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T48857|

  00008		 |memdump| PROC

; 424  : {    

  00008		 |$LN41@memdump|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd07c	 sub         sp, sp, #0x7C
  00010		 |$M48858|
  00010	e1a09002	 mov         r9, r2
  00014	e1cd90b0	 strh        r9, [sp]
  00018	e1a08000	 mov         r8, r0
  0001c	e59f3258	 ldr         r3, [pc, #0x258]
  00020	e5933000	 ldr         r3, [r3]
  00024	e58d3078	 str         r3, [sp, #0x78]

; 425  :     unsigned short i,j,l;
; 426  :     unsigned char tmp_str[100];
; 427  :     unsigned char tmp_str1[10];
; 428  :     for (i = 0; i < num_bytes; i += 16){

  00028	e3a05000	 mov         r5, #0
  0002c	e1b07001	 movs        r7, r1
  00030	0a000087	 beq         |$LN22@memdump|
  00034	e3a0a000	 mov         r10, #0
  00038	e58da004	 str         r10, [sp, #4]
  0003c	e3a02000	 mov         r2, #0
  00040	e28de017	 add         lr, sp, #0x17
  00044	e28d4017	 add         r4, sp, #0x17
  00048	e3a06000	 mov         r6, #0
  0004c	e28db014	 add         r11, sp, #0x14
  00050		 |$LL24@memdump|

; 429  :         unsigned short n ;
; 430  :         tmp_str[0]='\0';
; 431  :         n = i+offset ;

  00050	e089300a	 add         r3, r9, r10
  00054	e1a01803	 mov         r1, r3, lsl #16
  00058	e5cd2014	 strb        r2, [sp, #0x14]
  0005c	e1a01821	 mov         r1, r1, lsr #16

; 432  :         for (j=0; j<4; j++) {

  00060	e3a02000	 mov         r2, #0
  00064	e3a00000	 mov         r0, #0
  00068		 |$LL21@memdump|

; 433  :             l=n%16;

  00068	e1b03001	 movs        r3, r1
  0006c	4283300f	 addmi       r3, r3, #0xF
  00070	e1a03243	 mov         r3, r3, asr #4
  00074	e0413203	 sub         r3, r1, r3, lsl #4
  00078	e1a03803	 mov         r3, r3, lsl #16
  0007c	e1a03823	 mov         r3, r3, lsr #16

; 434  :             if (l>=10)

  00080	e353000a	 cmp         r3, #0xA

; 435  :             tmp_str[3-j]=(unsigned char)('A'+l-10);

  00084	22833037	 addcs       r3, r3, #0x37
  00088	274e3002	 strcsb      r3, [lr, -r2]

; 436  :             else
; 437  :             tmp_str[3-j]=(unsigned char)(l+'0');

  0008c	32833030	 addcc       r3, r3, #0x30
  00090	37443002	 strccb      r3, [r4, -r2]
  00094	e2803001	 add         r3, r0, #1
  00098	e1a02803	 mov         r2, r3, lsl #16

; 438  :             n >>= 4 ;

  0009c	e1a03221	 mov         r3, r1, lsr #4
  000a0	e1a01803	 mov         r1, r3, lsl #16
  000a4	e1a02822	 mov         r2, r2, lsr #16
  000a8	e1a01821	 mov         r1, r1, lsr #16
  000ac	e1a00002	 mov         r0, r2
  000b0	e3520004	 cmp         r2, #4
  000b4	3affffeb	 bcc         |$LL21@memdump|

; 439  :         }
; 440  :         tmp_str[4]='\0';
; 441  :         strcat ( (char *)tmp_str, ": ");

  000b8	e59f11b8	 ldr         r1, [pc, #0x1B8]
  000bc	e28d0014	 add         r0, sp, #0x14
  000c0	e5cd6018	 strb        r6, [sp, #0x18]
  000c4	eb000000	 bl          strcat

; 442  :         /*          Output the hex bytes        */
; 443  :         for (j = i; j < (i+16); j++) {

  000c8	e2856010	 add         r6, r5, #0x10
  000cc	e1550006	 cmp         r5, r6
  000d0	e1a04005	 mov         r4, r5
  000d4	aa00001e	 bge         |$LN14@memdump|
  000d8	e1a03005	 mov         r3, r5
  000dc	e3a0b000	 mov         r11, #0
  000e0		 |$LL16@memdump|

; 444  :             int m ;
; 445  :             if (j < num_bytes)  {

  000e0	e1540007	 cmp         r4, r7
  000e4	2a000010	 bcs         |$LN13@memdump|

; 446  :                 m=((unsigned int)((unsigned char)*(data+j)))/16 ;

  000e8	e7d32008	 ldrb        r2, [r3, +r8]

; 447  :                 if (m>=10)
; 448  :                     tmp_str1[0]='A'+(unsigned char)m-10;
; 449  :                 else
; 450  :                     tmp_str1[0]=(unsigned char)m+'0';
; 451  :                 m=((unsigned int)((unsigned char)*(data+j)))%16 ;
; 452  :                 if (m>=10)
; 453  :                     tmp_str1[1]='A'+(unsigned char)m-10;
; 454  :                 else
; 455  :                     tmp_str1[1]=(unsigned char)m+'0';
; 456  :                 tmp_str1[2]='\0';
; 457  :                 strcat ((char *)tmp_str, (char *)tmp_str1);

  000ec	e28d1008	 add         r1, sp, #8
  000f0	e28d0014	 add         r0, sp, #0x14
  000f4	e1a03222	 mov         r3, r2, lsr #4
  000f8	e353000a	 cmp         r3, #0xA
  000fc	a2833037	 addge       r3, r3, #0x37
  00100	b2833030	 addlt       r3, r3, #0x30
  00104	e5cd3008	 strb        r3, [sp, #8]
  00108	e202300f	 and         r3, r2, #0xF
  0010c	e353000a	 cmp         r3, #0xA
  00110	a2833037	 addge       r3, r3, #0x37
  00114	b2833030	 addlt       r3, r3, #0x30
  00118	e5cd3009	 strb        r3, [sp, #9]
  0011c	e5cdb00a	 strb        r11, [sp, #0xA]
  00120	eb000000	 bl          strcat

; 458  :                 strcat ((char *)tmp_str, " ");

  00124	e59f1148	 ldr         r1, [pc, #0x148]

; 459  :             }
; 460  :             else {

  00128	ea000000	 b           |$LN37@memdump|
  0012c		 |$LN13@memdump|

; 461  :                 strcat((char *)tmp_str,"   ");

  0012c	e59f113c	 ldr         r1, [pc, #0x13C]
  00130		 |$LN37@memdump|
  00130	e28d0014	 add         r0, sp, #0x14
  00134	eb000000	 bl          strcat
  00138	e2843001	 add         r3, r4, #1
  0013c	e1a04803	 mov         r4, r3, lsl #16
  00140	e1a04824	 mov         r4, r4, lsr #16
  00144	e1a03004	 mov         r3, r4
  00148	e1540006	 cmp         r4, r6
  0014c	baffffe3	 blt         |$LL16@memdump|
  00150	e28db014	 add         r11, sp, #0x14
  00154		 |$LN14@memdump|

; 462  :             }
; 463  :         }
; 464  :         strcat((char *)tmp_str, "  ");

  00154	e59f1110	 ldr         r1, [pc, #0x110]
  00158	e28d0014	 add         r0, sp, #0x14
  0015c	eb000000	 bl          strcat

; 465  :         l=(unsigned short)strlen((char *)tmp_str);

  00160	e28d0014	 add         r0, sp, #0x14
  00164	eb000000	 bl          strlen
  00168	e1a01800	 mov         r1, r0, lsl #16
  0016c	e1a01821	 mov         r1, r1, lsr #16

; 466  : 
; 467  :         /*         * Output the ASCII bytes        */
; 468  :         for (j = i; j < (i+16); j++){

  00170	e1550006	 cmp         r5, r6
  00174	aa000019	 bge         |$LN5@memdump|
  00178	e1a03005	 mov         r3, r5
  0017c	e28d9014	 add         r9, sp, #0x14
  00180	e3a0a020	 mov         r10, #0x20
  00184		 |$LL7@memdump|

; 469  :             if (j < num_bytes){

  00184	e1550007	 cmp         r5, r7
  00188	2a000008	 bcs         |$LN4@memdump|

; 470  :                 char c = *(data+j);

  0018c	e19330d8	 ldrsb       r3, [r3, +r8]
  00190	e1a02003	 mov         r2, r3

; 471  :                 if (c < ' ' || c > 'z')

  00194	e3520020	 cmp         r2, #0x20
  00198	ba000001	 blt         |$LN2@memdump|
  0019c	e352007a	 cmp         r2, #0x7A
  001a0	da000000	 ble         |$LN3@memdump|
  001a4		 |$LN2@memdump|

; 472  :                     c = '.';

  001a4	e3a0202e	 mov         r2, #0x2E
  001a8		 |$LN3@memdump|

; 473  :                 tmp_str[l++]=c;

  001a8	e7c12009	 strb        r2, [r1, +r9]

; 474  :             }
; 475  :             else

  001ac	ea000000	 b           |$LN38@memdump|
  001b0		 |$LN4@memdump|

; 476  :                 tmp_str[l++]=' ';

  001b0	e7c1a00b	 strb        r10, [r1, +r11]
  001b4		 |$LN38@memdump|
  001b4	e2813001	 add         r3, r1, #1
  001b8	e1a01803	 mov         r1, r3, lsl #16
  001bc	e2853001	 add         r3, r5, #1
  001c0	e1a05803	 mov         r5, r3, lsl #16
  001c4	e1a05825	 mov         r5, r5, lsr #16
  001c8	e1a03005	 mov         r3, r5
  001cc	e1550006	 cmp         r5, r6
  001d0	e1a01821	 mov         r1, r1, lsr #16
  001d4	baffffea	 blt         |$LL7@memdump|
  001d8	e1dd90b0	 ldrh        r9, [sp]

; 477  :         }
; 478  :         tmp_str[l++]='\r';        tmp_str[l++]='\n';        tmp_str[l++]='\0';
; 479  :         RETAILMSG(1, (L"%S", tmp_str));    

  001dc	e59da004	 ldr         r10, [sp, #4]
  001e0		 |$LN5@memdump|
  001e0	e28d2014	 add         r2, sp, #0x14
  001e4	e3a0000d	 mov         r0, #0xD
  001e8	e2813001	 add         r3, r1, #1
  001ec	e7c10002	 strb        r0, [r1, +r2]
  001f0	e1a02803	 mov         r2, r3, lsl #16
  001f4	e1a02822	 mov         r2, r2, lsr #16
  001f8	e2823001	 add         r3, r2, #1
  001fc	e28d1014	 add         r1, sp, #0x14
  00200	e3a0000a	 mov         r0, #0xA
  00204	e1a03803	 mov         r3, r3, lsl #16
  00208	e7c20001	 strb        r0, [r2, +r1]
  0020c	e59f0054	 ldr         r0, [pc, #0x54]
  00210	e1a03823	 mov         r3, r3, lsr #16
  00214	e28d2014	 add         r2, sp, #0x14
  00218	e3a01000	 mov         r1, #0
  0021c	e7c31002	 strb        r1, [r3, +r2]
  00220	e28d1014	 add         r1, sp, #0x14
  00224	eb000000	 bl          NKDbgPrintfW
  00228	e28a3010	 add         r3, r10, #0x10
  0022c	e1a05803	 mov         r5, r3, lsl #16
  00230	e1a05825	 mov         r5, r5, lsr #16
  00234	e1a0a005	 mov         r10, r5
  00238	e58da004	 str         r10, [sp, #4]
  0023c	e1550007	 cmp         r5, r7
  00240	e28de017	 add         lr, sp, #0x17
  00244	e28d4017	 add         r4, sp, #0x17
  00248	e3a02000	 mov         r2, #0
  0024c	e3a06000	 mov         r6, #0
  00250	3affff7e	 bcc         |$LL24@memdump|
  00254		 |$LN22@memdump|

; 424  : {    

  00254	e59d0078	 ldr         r0, [sp, #0x78]
  00258	eb000000	 bl          __security_check_cookie

; 480  :     }
; 481  : }

  0025c	e28dd07c	 add         sp, sp, #0x7C
  00260	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00264	e12fff1e	 bx          lr
  00268		 |$LN42@memdump|
  00268		 |$LN43@memdump|
  00268	00000000	 DCD         |??_C@_15MAOEGKJF@?$AA?$CF?$AAS?$AA?$AA@|
  0026c		 |$LN44@memdump|
  0026c	00000000	 DCD         |??_C@_02KNHHEEKP@?5?5?$AA@|
  00270		 |$LN45@memdump|
  00270	00000000	 DCD         |??_C@_03NDEAONJP@?5?5?5?$AA@|
  00274		 |$LN46@memdump|
  00274	00000000	 DCD         |??_C@_01CLKCMJKC@?5?$AA@|
  00278		 |$LN47@memdump|
  00278	00000000	 DCD         |??_C@_02LMMGGCAJ@?3?5?$AA@|
  0027c		 |$LN48@memdump|
  0027c	00000000	 DCD         |__security_cookie|
  00280		 |$M48859|

			 ENDP  ; |memdump|

	EXPORT	|DBGPrtSetupPkt|

  00000			 AREA	 |.pdata|, PDATA
|$T48878| DCD	|$LN5@DBGPrtSetu|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DBGPrtSetupPkt| PROC

; 484  : {

  00000		 |$LN5@DBGPrtSetu|
  00000		 |$M48875|

; 485  : #ifdef DEBUG
; 486  :     USB_DEVICE_REQUEST* pSetup =(USB_DEVICE_REQUEST*)pPkt;
; 487  :     
; 488  :     DEBUGMSG(ZONE_FUNCTION, (L" "
; 489  :         L"bmRequestType:0x%02x  bRequest:0x%02x   wValue:0x%04x   wIndex:0x%04x  wLength:0x%04x\r\n", 
; 490  :         pSetup->bmRequestType, pSetup->bRequest, pSetup->wValue, pSetup->wIndex, pSetup->wLength
; 491  :         ));
; 492  : #else
; 493  : 	UNREFERENCED_PARAMETER(pPkt);	
; 494  : #endif
; 495  : 
; 496  :     return ERROR_SUCCESS;

  00000	e3a00000	 mov         r0, #0

; 497  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M48876|

			 ENDP  ; |DBGPrtSetupPkt|

	EXPORT	|prtDescriptorInfo|

  00000			 AREA	 |.pdata|, PDATA
|$T48889| DCD	|$LN15@prtDescrip|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |prtDescriptorInfo| PROC

; 559  : {

  00000		 |$LN15@prtDescrip|
  00000		 |$M48886|

; 560  :     UFN_INTERFACE *pIFC;
; 561  :     UFN_ENDPOINT *pEP;
; 562  :     DWORD ifc, epx;
; 563  : 
; 564  : 	UNREFERENCED_PARAMETER(pFullSpeedDeviceDesc);
; 565  : 	UNREFERENCED_PARAMETER(pFullSpeedConfigDesc);
; 566  : 
; 567  :     for (ifc = 0; ifc < pFullSpeedConfig->Descriptor.bNumInterfaces; ifc++)
; 568  :     {
; 569  :         // For each endpoint in interface
; 570  :         pIFC = &pFullSpeedConfig->pInterfaces[ifc];
; 571  :         for (epx = 0; epx < pIFC->Descriptor.bNumEndpoints; epx++)
; 572  :         {
; 573  :             pEP = &pIFC->pEndpoints[epx];
; 574  :             
; 575  :             DEBUGMSG(ZONE_INFO, (TEXT("interface: %d  EP:%2.2d  direction:%s maxPacketSize:%d  Attributes:0x%x\r\n"),
; 576  :                 ifc,
; 577  :                 pEP->Descriptor.bEndpointAddress & 0x7F,
; 578  :                 ((pEP->Descriptor.bEndpointAddress & 0x80)? L"IN " : L"OUT"),
; 579  :                 pEP->Descriptor.wMaxPacketSize,
; 580  :                 pEP->Descriptor.bmAttributes));
; 581  :         }
; 582  :     }
; 583  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M48887|

			 ENDP  ; |prtDescriptorInfo|

	EXPORT	|CalcFIFOAddr|

  00000			 AREA	 |.pdata|, PDATA
|$T48901| DCD	|$LN6@CalcFIFOAd|
	DCD	0x40000400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |CalcFIFOAddr| PROC

; 587  : {

  00000		 |$LN6@CalcFIFOAd|
  00000		 |$M48898|
  00000	e3510000	 cmp         r1, #0

; 588  :     UINT fifoAddr;
; 589  : 
; 590  :     fifoAddr =  endpoint *(1024/8);

  00004	e1a00380	 mov         r0, r0, lsl #7

; 591  : 
; 592  :     if (bRxDir)
; 593  :        fifoAddr +=512/8;

  00008	12800040	 addne       r0, r0, #0x40

; 594  : 
; 595  :     return fifoAddr;
; 596  : }

  0000c	e12fff1e	 bx          lr
  00010		 |$M48899|

			 ENDP  ; |CalcFIFOAddr|

	EXPORT	|ReadFIFO|

  00000			 AREA	 |.pdata|, PDATA
|$T48925| DCD	|$LN16@ReadFIFO|
	DCD	0x40001601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ReadFIFO| PROC

; 599  : {

  00000		 |$LN16@ReadFIFO|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M48922|

; 600  :     PCSP_MUSB_GEN_REGS pGenRegs = pPdd->pUSBContext->pUsbGenRegs;
; 601  :     DWORD total  = size/4;
; 602  :     DWORD remain = size%4;
; 603  :     DWORD i;
; 604  :     DWORD *pDword =(DWORD *)pData;
; 605  : 
; 606  :     volatile ULONG *pReg = (volatile ULONG *)&pGenRegs->fifo[endpoint];

  00004	e5900020	 ldr         r0, [r0, #0x20]
  00008	e281e008	 add         lr, r1, #8
  0000c	e1b04123	 movs        r4, r3, lsr #2
  00010	e5901020	 ldr         r1, [r0, #0x20]
  00014	e2030003	 and         r0, r3, #3
  00018	e081110e	 add         r1, r1, lr, lsl #2

; 607  : 
; 608  :     // Critical section would be handled outside
; 609  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("ReadFIFO EP(%d): pData(0x%x) total (0x%x), remain (0x%x), size(0x%x)\r\n"), endpoint, pData, total, remain, size));
; 610  : 
; 611  :     // this is 32-bit align
; 612  : 
; 613  :     for (i = 0; i < total; i++)

  0001c	0a000003	 beq         |$LN4@ReadFIFO|
  00020		 |$LL6@ReadFIFO|

; 614  :     {
; 615  :         *pDword++ = INREG32(pReg);

  00020	e5913000	 ldr         r3, [r1]
  00024	e2544001	 subs        r4, r4, #1
  00028	e4823004	 str         r3, [r2], #4
  0002c	1afffffb	 bne         |$LL6@ReadFIFO|
  00030		 |$LN4@ReadFIFO|

; 616  :     }
; 617  : 
; 618  :     if (remain != 0)

  00030	e3500000	 cmp         r0, #0
  00034	0a000004	 beq         |$LN12@ReadFIFO|

; 619  :     {
; 620  :         UCHAR* pUCHAR = (UCHAR*) pDword;
; 621  :         DWORD dwTemp = INREG32(pReg);

  00038	e5913000	 ldr         r3, [r1]
  0003c		 |$LL2@ReadFIFO|

; 622  :         
; 623  :         while (remain--)
; 624  :         {
; 625  :             *pUCHAR++ = (UCHAR) (dwTemp & 0xFF);

  0003c	e4c23001	 strb        r3, [r2], #1

; 626  :             dwTemp>>=8;

  00040	e1a03423	 mov         r3, r3, lsr #8
  00044	e2500001	 subs        r0, r0, #1
  00048	1afffffb	 bne         |$LL2@ReadFIFO|
  0004c		 |$LN12@ReadFIFO|

; 627  :         }
; 628  :     }
; 629  : 
; 630  :     //RETAILMSG(1,(TEXT("Read fifo\r\n")));
; 631  :     //memdump((UCHAR*)pData,(USHORT)size,0);
; 632  :     //RETAILMSG(1,(TEXT("\r\n")));
; 633  : 
; 634  :     return TRUE;

  0004c	e3a00001	 mov         r0, #1

; 635  : }

  00050	e8bd4010	 ldmia       sp!, {r4, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M48923|

			 ENDP  ; |ReadFIFO|

	EXPORT	|WriteFIFO|

  00000			 AREA	 |.pdata|, PDATA
|$T48945| DCD	|$LN13@WriteFIFO|
	DCD	0x40001701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |WriteFIFO| PROC

; 640  : {

  00000		 |$LN13@WriteFIFO|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M48942|

; 641  :     PCSP_MUSB_GEN_REGS pGenRegs = pPdd->pUSBContext->pUsbGenRegs;
; 642  :     DWORD total  = size/4;
; 643  :     DWORD remain = size%4;
; 644  :     DWORD i;
; 645  :     DWORD *pDword =(DWORD *)pData;
; 646  :     volatile ULONG *pReg = (volatile ULONG *)&pGenRegs->fifo[endpoint];

  00004	e5900020	 ldr         r0, [r0, #0x20]
  00008	e281e008	 add         lr, r1, #8
  0000c	e1b04123	 movs        r4, r3, lsr #2
  00010	e5901020	 ldr         r1, [r0, #0x20]
  00014	e2030003	 and         r0, r3, #3
  00018	e081110e	 add         r1, r1, lr, lsl #2

; 647  : 
; 648  :     // Critical section would be handled outside
; 649  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("WriteFIFO: total (0x%x), remain (0x%x), size(0x%x)\r\n"), total, remain, size));
; 650  : 
; 651  :     //memdump((UCHAR*)pData,(USHORT)size,0);
; 652  :     //RETAILMSG(1,(TEXT("\r\n")));
; 653  : 
; 654  :     // this is 32-bit align
; 655  :     for (i = 0; i < total; i++)

  0001c	0a000003	 beq         |$LN4@WriteFIFO|
  00020		 |$LL6@WriteFIFO|

; 656  :     {
; 657  :         OUTREG32(pReg, *pDword++);

  00020	e4923004	 ldr         r3, [r2], #4
  00024	e2544001	 subs        r4, r4, #1
  00028	e5813000	 str         r3, [r1]
  0002c	1afffffb	 bne         |$LL6@WriteFIFO|
  00030		 |$LN4@WriteFIFO|

; 658  :     }
; 659  :         
; 660  :     // Set the pByte equal to the last bytes of data being transferred
; 661  :     if (remain != 0)

  00030	e3500000	 cmp         r0, #0
  00034	0a000005	 beq         |$LN1@WriteFIFO|

; 662  :     {
; 663  :         // Pointer to the first byte of data
; 664  :         USHORT *pWORD =(USHORT *)pDword;
; 665  : 
; 666  :         // Finally if there is remain
; 667  :         if (remain & 0x2)  // either 2 or 3

  00038	e3100002	 tst         r0, #2

; 668  :         {
; 669  :             // Write 2 bytes to there
; 670  :             OUTREG16(pReg, *pWORD++);

  0003c	10d230b2	 ldrneh      r3, [r2], #2
  00040	11c130b0	 strneh      r3, [r1]

; 671  :         }
; 672  : 
; 673  :         if (remain & 0x1)

  00044	e3100001	 tst         r0, #1

; 674  :         {
; 675  :             // Write 1 byte to there
; 676  :             OUTREG8(pReg, *((UCHAR*)pWORD));

  00048	15d23000	 ldrneb      r3, [r2]
  0004c	15c13000	 strneb      r3, [r1]
  00050		 |$LN1@WriteFIFO|

; 677  :         }
; 678  :     }
; 679  :     return TRUE;

  00050	e3a00001	 mov         r0, #1

; 680  : }

  00054	e8bd4010	 ldmia       sp!, {r4, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$M48943|

			 ENDP  ; |WriteFIFO|

	IMPORT	|__C_specific_handler|

  00000			 AREA	 |.pdata|, PDATA
|$T48981| DCD	|$LN35@ContinueTx|
	DCD	0xc0007904

  00000			 AREA	 |.pdata|, PDATA
|$T48983| DCD	|$LN22@ContinueTx|
	DCD	0x40000301

  00000			 AREA	 |.xdata|, DATA
|$T48979| DCD	0x1
	DCD	|$LN26@ContinueTx|
	DCD	|$LN27@ContinueTx|
	DCD	|$LN22@ContinueTx|
	DCD	|$LN23@ContinueTx|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T48979|

  00008		 |ContinueTxTransfer| PROC

; 746  : {

  00008		 |$LN35@ContinueTx|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d5ff0	 stmdb       sp!, {r4 - r12, lr}
  00010	e28db028	 add         r11, sp, #0x28
  00014	e24dd00c	 sub         sp, sp, #0xC
  00018		 |$LN33@ContinueTx|
  00018	e1a0e001	 mov         lr, r1
  0001c	e1a07000	 mov         r7, r0

; 747  :     DWORD rc = ERROR_INVALID_PARAMETER;
; 748  :     MUsbFnEp_t *pEP = &pPdd->ep[endpoint];

  00020	e3a03034	 mov         r3, #0x34
  00024	e025739e	 mla         r5, lr, r3, r7

; 749  :     PCSP_MUSB_CSR_REGS pCsrRegs = pPdd->pUSBContext->pUsbCsrRegs;

  00028	e5973020	 ldr         r3, [r7, #0x20]
  0002c	e3a04057	 mov         r4, #0x57

; 750  :     STransfer *pTransfer = pEP->pTransfer;

  00030	e59520cc	 ldr         r2, [r5, #0xCC]
  00034	e593801c	 ldr         r8, [r3, #0x1C]
  00038	e50b402c	 str         r4, [r11, #-0x2C]
  0003c	e1b09002	 movs        r9, r2
  00040	e50b9030	 str         r9, [r11, #-0x30]

; 764  :     {
; 765  :         DEBUGMSG(ZONE_ERROR, (L"ContinueTxTransfer:  error pTransfer is NULL\r\n"));
; 766  :         return ERROR_INVALID_PARAMETER;

  00044	03a04057	 moveq       r4, #0x57

; 751  :     DWORD space, txcount;
; 752  :     BOOL complete = FALSE;
; 753  :     UCHAR *pBuffer;
; 754  :     DWORD dwFlag;
; 755  :     
; 756  :     DEBUGMSG(DEBUG_PRT_INFO, (L"+UsbFnPdd!ContinueTxTransfer: "
; 757  :         L"EP %d pTransfer 0x%08x (%d, %d, %d)\r\n",
; 758  :         endpoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 759  :         pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 760  :         pTransfer != NULL ? pTransfer->dwUsbError : -1
; 761  :         ));
; 762  : 
; 763  :     if (pTransfer == NULL) 

  00048	0a000063	 beq         |$LN17@ContinueTx|
  0004c		 |$LN26@ContinueTx|

; 767  :     }    
; 768  :     
; 769  :     __try
; 770  :     {
; 771  :        
; 772  :         pBuffer =(UCHAR*)pTransfer->pvBuffer + pTransfer->cbTransferred;

  0004c	e5990010	 ldr         r0, [r9, #0x10]
  00050	e599a004	 ldr         r10, [r9, #4]
  00054	e50ba034	 str         r10, [r11, #-0x34]

; 773  :         space = pTransfer->cbBuffer - pTransfer->cbTransferred;

  00058	e599100c	 ldr         r1, [r9, #0xC]

; 774  :                 
; 775  :         if (endpoint != 0)

  0005c	e35e0000	 cmp         lr, #0
  00060	e0412000	 sub         r2, r1, r0
  00064	0a00001f	 beq         |$LN14@ContinueTx|

; 776  :         {
; 777  :             if (INREG16(&pCsrRegs->ep[endpoint].CSR.TxCSR) & TXCSR_P_TXPKTRDY)

  00068	e088820e	 add         r8, r8, lr, lsl #4
  0006c	e1d830b2	 ldrh        r3, [r8, #2]
  00070	e3130001	 tst         r3, #1
  00074	0a000000	 beq         |$LN13@ContinueTx|

; 778  :             {
; 779  :                 DEBUGMSG(ZONE_INFO, (TEXT("endpoint(%d) cbBuffer(%d) cbTransferred(%d)\r\n"), endpoint, pTransfer->cbBuffer, pTransfer->cbTransferred));
; 780  :                 DEBUGMSG(ZONE_INFO, (TEXT("TXPKTRdy bit is set ..\r\n")));
; 781  :                 goto CleanUp;

  00078	ea000057	 b           |$LN17@ContinueTx|
  0007c		 |$LN13@ContinueTx|

; 782  :             }
; 783  :             else
; 784  :             {
; 785  :                 // How many bytes we can send just now?
; 786  :                 txcount = pEP->maxPacketSize;

  0007c	e1d56abc	 ldrh        r6, [r5, #0xAC]

; 787  :                 if (txcount > space)

  00080	e1560002	 cmp         r6, r2

; 788  :                     txcount = space;

  00084	81a06002	 movhi       r6, r2

; 789  :                 
; 790  :                 if (pPdd->ep[endpoint].dmaEnabled)

  00088	e59530bc	 ldr         r3, [r5, #0xBC]
  0008c	e3530000	 cmp         r3, #0
  00090	0a000009	 beq         |$LN10@ContinueTx|

; 791  :                 {
; 792  :                     // disable DMA related bits
; 793  :                     CLRREG16(&pCsrRegs->ep[endpoint].CSR.TxCSR, TXCSR_P_AUTOSET | TXCSR_P_DMAREQENAB);

  00094	e1d820b2	 ldrh        r2, [r8, #2]
  00098	e3a03c6f	 mov         r3, #0x6F, 24
  0009c	e38330ff	 orr         r3, r3, #0xFF
  000a0	e0023003	 and         r3, r2, r3
  000a4	e1c830b2	 strh        r3, [r8, #2]

; 794  :                     
; 795  :                     // clear TXCSR_P_DMAREQMODE after clearing TXCSR_P_DMAREQENAB (per MUSBMHDRC programming guide)
; 796  :                     CLRREG16(&pCsrRegs->ep[endpoint].CSR.TxCSR, TXCSR_P_DMAREQMODE);

  000a8	e1d820b2	 ldrh        r2, [r8, #2]
  000ac	e3a03cfb	 mov         r3, #0xFB, 24
  000b0	e38330ff	 orr         r3, r3, #0xFF
  000b4	e0023003	 and         r3, r2, r3
  000b8	e1c830b2	 strh        r3, [r8, #2]
  000bc		 |$LN10@ContinueTx|

; 797  :                 }
; 798  :                 
; 799  :                 DEBUGMSG(ZONE_FUNCTION, (TEXT("WriteFIFO EP %d, Size %d\r\n"), endpoint, txcount));
; 800  :                 //memdump((uchar *)pBuffer, (unsigned short)txcount, 0);
; 801  :                 // Write data to FIFO
; 802  :                 WriteFIFO(pPdd, (UCHAR) endpoint, pBuffer, txcount);

  000bc	e1a03006	 mov         r3, r6
  000c0	e08a2000	 add         r2, r10, r0
  000c4	e20e10ff	 and         r1, lr, #0xFF
  000c8	e1a00007	 mov         r0, r7
  000cc	eb000000	 bl          WriteFIFO

; 803  :                 
; 804  :                 // We transfered some data
; 805  :                 pTransfer->cbTransferred += txcount;                

  000d0	e5993010	 ldr         r3, [r9, #0x10]
  000d4	e0833006	 add         r3, r3, r6
  000d8	e5893010	 str         r3, [r9, #0x10]

; 806  :                 SETREG16(&pCsrRegs->ep[endpoint].CSR.TxCSR, TXCSR_P_TXPKTRDY);

  000dc	e1d830b2	 ldrh        r3, [r8, #2]
  000e0	e3833001	 orr         r3, r3, #1

; 807  :             } 
; 808  :         }
; 809  :         else // endpoint == 0

  000e4	ea000033	 b           |$LN32@ContinueTx|
  000e8		 |$LN14@ContinueTx|

; 810  :         {
; 811  :             // Zero endpoint: Zero length padding needed
; 812  :             // if last packet is maxPacketSize and bytes transferred is not equal to max transfer size specified Setup transaction
; 813  :             pEP->zeroLength =
; 814  :                 (space == pEP->maxPacketSize) &&
; 815  :                 (pPdd->setupCount > pTransfer->cbBuffer);

  000e8	e1d53abc	 ldrh        r3, [r5, #0xAC]
  000ec	e1520003	 cmp         r2, r3
  000f0	1a000003	 bne         |$LN19@ContinueTx|
  000f4	e1d737b4	 ldrh        r3, [r7, #0x74]
  000f8	e1530001	 cmp         r3, r1
  000fc	83a03001	 movhi       r3, #1
  00100	8a000000	 bhi         |$LN20@ContinueTx|
  00104		 |$LN19@ContinueTx|
  00104	e3a03000	 mov         r3, #0
  00108		 |$LN20@ContinueTx|
  00108	e58530b4	 str         r3, [r5, #0xB4]

; 816  :             
; 817  :             if (pPdd->ep0State != EP0_ST_SETUP_PROCESSED)

  0010c	e59733ec	 ldr         r3, [r7, #0x3EC]
  00110	e3530001	 cmp         r3, #1
  00114	0a000000	 beq         |$LN8@ContinueTx|

; 818  :             {
; 819  :                 DEBUGMSG(ZONE_INFO, (TEXT("Invalid State = %d\r\n"), pPdd->ep0State));
; 820  :                 goto CleanUp;

  00118	ea00002f	 b           |$LN17@ContinueTx|
  0011c		 |$LN8@ContinueTx|

; 821  :             }
; 822  :             else
; 823  :             {
; 824  :                 pPdd->ep0State = EP0_ST_DATA_TX;

  0011c	e1a0a007	 mov         r10, r7
  00120	e3a03005	 mov         r3, #5
  00124	e5aa33ec	 str         r3, [r10, #0x3EC]!

; 825  :                 if (INREG16(&pCsrRegs->ep[endpoint].CSR.CSR0) & CSR0_P_TXPKTRDY)

  00128	e1d830b2	 ldrh        r3, [r8, #2]
  0012c	e3130002	 tst         r3, #2
  00130	0a000000	 beq         |$LN6@ContinueTx|

; 826  :                 {
; 827  :                     DEBUGMSG(ZONE_ERROR, (TEXT("endpoint(%d) cbBuffer(%d) cbTransferred(%d)\r\n"), endpoint, pTransfer->cbBuffer, pTransfer->cbTransferred));
; 828  :                     DEBUGMSG(ZONE_ERROR, (TEXT("TXPKTRdy bit is set ..\r\n")));
; 829  :                     goto CleanUp;

  00134	ea000028	 b           |$LN17@ContinueTx|
  00138		 |$LN6@ContinueTx|

; 830  :                 }
; 831  :                 else
; 832  :                 {
; 833  :                     // How many bytes we can send just now?
; 834  :                     txcount = pEP->maxPacketSize;

  00138	e1d56abc	 ldrh        r6, [r5, #0xAC]

; 835  :                     if (txcount > space)

  0013c	e1560002	 cmp         r6, r2

; 836  :                         txcount = space;

  00140	81a06002	 movhi       r6, r2

; 837  :                     
; 838  :                     DEBUGMSG(ZONE_INFO, (L"ContinueTxTransfer: EP0_ST_DATA_TX space_left_to_send=%d txcount=%d\r\n", space, txcount));
; 839  :                     
; 840  :                     // Write data to FIFO
; 841  :                     WriteFIFO(pPdd, EP0, pBuffer, txcount);

  00144	e1a03006	 mov         r3, r6
  00148	e51b2034	 ldr         r2, [r11, #-0x34]
  0014c	e0822000	 add         r2, r2, r0
  00150	e3a01000	 mov         r1, #0
  00154	e1a00007	 mov         r0, r7
  00158	eb000000	 bl          WriteFIFO

; 842  :                     
; 843  :                     // We transfered some data
; 844  :                     pTransfer->cbTransferred += txcount;

  0015c	e5993010	 ldr         r3, [r9, #0x10]
  00160	e0833006	 add         r3, r3, r6
  00164	e5893010	 str         r3, [r9, #0x10]

; 845  :                     
; 846  :                     DEBUGMSG(ZONE_INFO, (L"UsbFnPdd!ContinueTxTransfer: "
; 847  :                         L"Tx packet size: %d\r\n",
; 848  :                         pTransfer->cbBuffer
; 849  :                         ));
; 850  :                                         
; 851  :                     if (pTransfer->cbTransferred == pTransfer->cbBuffer)

  00168	e1a01003	 mov         r1, r3
  0016c	e599300c	 ldr         r3, [r9, #0xC]
  00170	e1510003	 cmp         r1, r3
  00174	1a00000c	 bne         |$LN3@ContinueTx|

; 852  :                     {
; 853  :                         DEBUGMSG(ZONE_INFO, (TEXT("DATAEND add\r\n")));
; 854  :                         pPdd->ep0State = EP0_ST_STATUS_OUT;

  00178	e3a03003	 mov         r3, #3
  0017c	e58a3000	 str         r3, [r10]

; 855  :                         DEBUGMSG(ZONE_INFO, (TEXT("Set OUT Msg => ep0State = 0x%x\r\n"), pPdd->ep0State));
; 856  :                         dwFlag = CSR0_P_TXPKTRDY | CSR0_P_DATAEND;
; 857  :                         pEP->pTransfer = NULL;

  00180	e3a03000	 mov         r3, #0
  00184	e58530cc	 str         r3, [r5, #0xCC]

; 858  :                         pTransfer->dwUsbError = UFN_NO_ERROR;

  00188	e5893014	 str         r3, [r9, #0x14]

; 859  :                         pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer);   

  0018c	e5970024	 ldr         r0, [r7, #0x24]
  00190	e5973028	 ldr         r3, [r7, #0x28]
  00194	e1a02009	 mov         r2, r9
  00198	e3a01064	 mov         r1, #0x64
  0019c	e3a0500a	 mov         r5, #0xA
  001a0	e1a0e00f	 mov         lr, pc
  001a4	e12fff13	 bx          r3

; 860  :                         DEBUGMSG(ZONE_INFO, (TEXT("Device_ProcessEP0: Notify - transfer completed\r\n")));                        
; 861  :                     }
; 862  :                     else

  001a8	ea000000	 b           |$LN2@ContinueTx|
  001ac		 |$LN3@ContinueTx|

; 863  :                     {
; 864  :                         dwFlag = CSR0_P_TXPKTRDY;

  001ac	e3a05002	 mov         r5, #2
  001b0		 |$LN2@ContinueTx|

; 865  :                     }                   
; 866  :                     DEBUGMSG(ZONE_INFO, (TEXT("1. Set TxPktRdy - 0\r\n")));
; 867  :                     SETREG16(&pCsrRegs->ep[endpoint].CSR.CSR0, dwFlag);                    

  001b0	e1d830b2	 ldrh        r3, [r8, #2]
  001b4	e1833005	 orr         r3, r3, r5
  001b8		 |$LN32@ContinueTx|
  001b8	e1c830b2	 strh        r3, [r8, #2]
  001bc		 |$LN27@ContinueTx|

; 868  :                 }                
; 869  :             }
; 870  :         } // if (endpoint != 0)
; 871  :     }

  001bc	ea000003	 b           |$LN28@ContinueTx|
  001c0		 |$LN23@ContinueTx|

; 873  :     {
; 874  :         pTransfer->dwUsbError = UFN_CLIENT_BUFFER_ERROR;

  001c0	e51b3030	 ldr         r3, [r11, #-0x30]
  001c4	e3a02f41	 mov         r2, #0x41, 30
  001c8	e5832014	 str         r2, [r3, #0x14]
  001cc	e51b402c	 ldr         r4, [r11, #-0x2C]
  001d0		 |$LN28@ContinueTx|

; 875  :         complete = TRUE;
; 876  :         DEBUGMSG(ZONE_ERROR, (L"UsbFnPdd!ContinueTxTransfer: UFN_CLIENT_BUFFER_ERROR"));
; 877  :     }
; 878  :     
; 879  :     rc = ERROR_SUCCESS;

  001d0	e3a04000	 mov         r4, #0
  001d4		 |$CleanUp$47297|

; 880  :     
; 881  : CleanUp:
; 882  :     
; 883  :     if (endpoint == 0)
; 884  :         prtEP0State(pPdd);
; 885  :     
; 886  :     DEBUGMSG(ZONE_FUNCTION, (L"-ContinueTxTransfer\r\n"));
; 887  :     
; 888  :     return rc;

  001d4	ea000000	 b           |$LN17@ContinueTx|
  001d8		 |$LN31@ContinueTx|
  001d8	e51b402c	 ldr         r4, [r11, #-0x2C]
  001dc		 |$LN17@ContinueTx|

; 889  : }

  001dc	e1a00004	 mov         r0, r4
  001e0	e24bd028	 sub         sp, r11, #0x28
  001e4	e89d6ff0	 ldmia       sp, {r4 - r11, sp, lr}
  001e8	e12fff1e	 bx          lr

			 ENDP  ; |ContinueTxTransfer|

  001ec		 |$LN22@ContinueTx|
  001ec		 |$LN34@ContinueTx|

; 872  :     __except(EXCEPTION_EXECUTE_HANDLER)

  001ec	e52de004	 str         lr, [sp, #-4]!
  001f0		 |$LN25@ContinueTx|
  001f0		 |$LN37@ContinueTx|
  001f0	e3a00001	 mov         r0, #1
  001f4		 |$LN24@ContinueTx|
  001f4	e49df004	 ldr         pc, [sp], #4
  001f8		 |$LN38@ContinueTx|
  001f8		 |$LN36@ContinueTx|

  00000			 AREA	 |.pdata|, PDATA
|$T49005| DCD	|$LN13@ProcessDMA|
	DCD	0x40002801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ProcessDMAChannel| PROC

; 896  : {

  00000		 |$LN13@ProcessDMA|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M49002|
  00004	e1a05003	 mov         r5, r3
  00008	e1a08002	 mov         r8, r2
  0000c	e1a0a001	 mov         r10, r1
  00010	e1a06000	 mov         r6, r0

; 897  :     PHSMUSB_T pOTG =(PHSMUSB_T)(pPdd->pUSBContext);
; 898  :     DWORD dmacntl = 0;
; 899  :     
; 900  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("ProcessDMAChannel  endpoint:%d   channel:%d\r\n"), endpoint, channel));
; 901  :     
; 902  :     //  Now actual configure the DMA channel
; 903  :     //  DMA Mode (D2)
; 904  :     EnterCriticalSection(&pPdd->dmaCS);

  00014	e5969020	 ldr         r9, [r6, #0x20]
  00018	e2860034	 add         r0, r6, #0x34
  0001c	e3a04000	 mov         r4, #0
  00020	eb000000	 bl          EnterCriticalSection

; 905  :     if (size > dwMaxPacket)

  00024	e59de028	 ldr         lr, [sp, #0x28]
  00028	e59d7024	 ldr         r7, [sp, #0x24]
  0002c	e157000e	 cmp         r7, lr

; 906  :         dmacntl |= DMA_CNTL_DMAMode;

  00030	83a04004	 movhi       r4, #4

; 907  :     //  Burst Mode (D10-9)
; 908  :     if (dwMaxPacket >= 64)

  00034	e35e0040	 cmp         lr, #0x40

; 909  :         dmacntl |= BURSTMODE_INCR16;

  00038	23844c06	 orrcs       r4, r4, #6, 24
  0003c	2a000004	 bcs         |$LN3@ProcessDMA|

; 910  :     else if (dwMaxPacket >= 32)

  00040	e35e0020	 cmp         lr, #0x20

; 911  :         dmacntl |= BURSTMODE_INCR8;

  00044	23844b01	 orrcs       r4, r4, #1, 22
  00048	2a000001	 bcs         |$LN3@ProcessDMA|

; 912  :     else if (dwMaxPacket >= 16)

  0004c	e35e0010	 cmp         lr, #0x10

; 913  :         dmacntl |= BURSTMODE_INCR4;

  00050	23844c02	 orrcs       r4, r4, #2, 24
  00054		 |$LN3@ProcessDMA|

; 914  :     else
; 915  :         dmacntl |= BURSTMODE_UNSPEC;
; 916  :     
; 917  :     //  Direction (D1) - for sure it is Tx endpoint
; 918  :     //  Interrupt Enable (D3)
; 919  :     //  Enable DMA (D0)
; 920  :     dmacntl |=(DMA_CNTL_Enable | DMA_CNTL_InterruptEnable);
; 921  :     if (IsTx)
; 922  :         dmacntl |= DMA_CNTL_Direction;
; 923  :     
; 924  :     //  Set endpoint number
; 925  :     dmacntl |=(endpoint << 4);
; 926  :     
; 927  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("DMA Channel %d\r\n"), channel));
; 928  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("DMA Addr (0x%x), Count (0x%x), Cntl(0x%x)\r\n"),
; 929  :         paData, size, dmacntl));
; 930  :     // Write address
; 931  :     OUTREG32(&pOTG->pUsbDmaRegs->dma[channel].Addr, (DWORD)paData);       

  00054	e5993024	 ldr         r3, [r9, #0x24]
  00058	e59d2020	 ldr         r2, [sp, #0x20]
  0005c	e3841009	 orr         r1, r4, #9
  00060	e0833208	 add         r3, r3, r8, lsl #4
  00064	e5832008	 str         r2, [r3, #8]

; 932  :     // Write count
; 933  :     OUTREG32(&pOTG->pUsbDmaRegs->dma[channel].Count, (DWORD)size);

  00068	e5993024	 ldr         r3, [r9, #0x24]
  0006c	e3550000	 cmp         r5, #0
  00070	13811002	 orrne       r1, r1, #2

; 934  :         
; 935  :     // Write Control
; 936  :     OUTREG32(&pOTG->pUsbDmaRegs->dma[channel].Cntl, (DWORD)dmacntl);
; 937  :     LeaveCriticalSection(&pPdd->dmaCS);

  00074	e0833208	 add         r3, r3, r8, lsl #4
  00078	e583700c	 str         r7, [r3, #0xC]
  0007c	e5993024	 ldr         r3, [r9, #0x24]
  00080	e181120a	 orr         r1, r1, r10, lsl #4
  00084	e2860034	 add         r0, r6, #0x34
  00088	e0833208	 add         r3, r3, r8, lsl #4
  0008c	e5831004	 str         r1, [r3, #4]
  00090	eb000000	 bl          LeaveCriticalSection

; 938  :     
; 939  :     return TRUE;

  00094	e3a00001	 mov         r0, #1

; 940  : }

  00098	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$M49003|

			 ENDP  ; |ProcessDMAChannel|


  00000			 AREA	 |.pdata|, PDATA
|$T49015| DCD	|$LN5@ResetDMACh|
	DCD	0x40001601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ResetDMAChannel| PROC

; 943  : {

  00000		 |$LN5@ResetDMACh|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M49012|
  00004	e1a05001	 mov         r5, r1
  00008	e1a06000	 mov         r6, r0

; 944  :     PHSMUSB_T pOTG =(PHSMUSB_T)(pPdd->pUSBContext);
; 945  : 
; 946  :     EnterCriticalSection(&pPdd->dmaCS);

  0000c	e5964020	 ldr         r4, [r6, #0x20]
  00010	e2860034	 add         r0, r6, #0x34
  00014	eb000000	 bl          EnterCriticalSection

; 947  :     OUTREG32(&pOTG->pUsbDmaRegs->dma[channel].Addr, (DWORD)0x00);    

  00018	e5943024	 ldr         r3, [r4, #0x24]
  0001c	e3a02000	 mov         r2, #0

; 948  :     // Write count
; 949  :     OUTREG32(&pOTG->pUsbDmaRegs->dma[channel].Count, (DWORD)0x00);
; 950  :         
; 951  :     // Write Control
; 952  :     OUTREG32(&pOTG->pUsbDmaRegs->dma[channel].Cntl, (DWORD)0x00);
; 953  : 
; 954  :     pPdd->bRXIsUsingUsbDMA = FALSE;
; 955  :     pPdd->bTXIsUsingUsbDMA = FALSE;
; 956  : 
; 957  :     LeaveCriticalSection(&pPdd->dmaCS);

  00020	e2860034	 add         r0, r6, #0x34
  00024	e0833205	 add         r3, r3, r5, lsl #4
  00028	e5832008	 str         r2, [r3, #8]
  0002c	e5943024	 ldr         r3, [r4, #0x24]
  00030	e0833205	 add         r3, r3, r5, lsl #4
  00034	e583200c	 str         r2, [r3, #0xC]
  00038	e5943024	 ldr         r3, [r4, #0x24]
  0003c	e0833205	 add         r3, r3, r5, lsl #4
  00040	e5832004	 str         r2, [r3, #4]
  00044	e5862438	 str         r2, [r6, #0x438]
  00048	e5862434	 str         r2, [r6, #0x434]
  0004c	eb000000	 bl          LeaveCriticalSection

; 958  : }

  00050	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M49013|

			 ENDP  ; |ResetDMAChannel|

	IMPORT	|CacheRangeFlush|
	IMPORT	|memcpy|
	IMPORT	|__rt_udiv|

  00000			 AREA	 |.pdata|, PDATA
|$T49050| DCD	|$LN30@ContinueTx@2|
	DCD	0xc0008b05

  00000			 AREA	 |.pdata|, PDATA
|$T49052| DCD	|$LN17@ContinueTx@2|
	DCD	0x40000502

  00000			 AREA	 |.xdata|, DATA
|$T49048| DCD	0x1
	DCD	|$LN21@ContinueTx@2|
	DCD	|$LN22@ContinueTx@2|
	DCD	|$LN17@ContinueTx@2|
	DCD	|$LN18@ContinueTx@2|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T49048|

  00008		 |ContinueTxDmaTransfer| PROC

; 968  : {

  00008		 |$LN30@ContinueTx@2|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d0003	 stmdb       sp!, {r0, r1}
  00010	e92d5ff0	 stmdb       sp!, {r4 - r12, lr}
  00014	e28db028	 add         r11, sp, #0x28
  00018	e24dd01c	 sub         sp, sp, #0x1C
  0001c		 |$LN28@ContinueTx@2|
  0001c	e1a0a001	 mov         r10, r1
  00020	e1a05000	 mov         r5, r0
  00024	e58b5000	 str         r5, [r11]

; 969  :     DWORD rc = ERROR_INVALID_PARAMETER;
; 970  :     MUsbFnEp_t *pEP = &pPdd->ep[endpoint];

  00028	e3a03034	 mov         r3, #0x34
  0002c	e02e539a	 mla         lr, r10, r3, r5

; 971  :     PCSP_MUSB_CSR_REGS pCsrRegs = pPdd->pUSBContext->pUsbCsrRegs;

  00030	e5953020	 ldr         r3, [r5, #0x20]
  00034	e3a08057	 mov         r8, #0x57
  00038	e28e90ac	 add         r9, lr, #0xAC
  0003c	e50b902c	 str         r9, [r11, #-0x2C]
  00040	e593301c	 ldr         r3, [r3, #0x1C]
  00044	e50b3034	 str         r3, [r11, #-0x34]

; 972  :     STransfer *pTransfer = pEP->pTransfer;

  00048	e5993020	 ldr         r3, [r9, #0x20]

; 973  :     DWORD size;
; 974  :     BOOL complete = FALSE;

  0004c	e3a02000	 mov         r2, #0
  00050	e1b06003	 movs        r6, r3
  00054	e50b6030	 str         r6, [r11, #-0x30]

; 975  :     UCHAR *pBuffer;
; 976  :     
; 977  :     
; 978  :     DEBUGMSG(DEBUG_PRT_INFO, (L"UsbFnPdd!ContinueTxDmaTransfer: "
; 979  :         L"EP %d pTransfer 0x%08x (%d, %d, %d)\r\n",
; 980  :         endpoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 981  :         pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 982  :         pTransfer != NULL ? pTransfer->dwUsbError : -1
; 983  :         ));
; 984  :     
; 985  :     if (pTransfer == NULL)

  00058	0a000067	 beq         |$LN26@ContinueTx@2|

; 986  :         goto cleanUp;
; 987  :     
; 988  :     // Is this final interrupt of transfer?
; 989  :     if ((pTransfer->cbTransferred == pTransfer->cbBuffer) && !pEP->zeroLength)

  0005c	e5962010	 ldr         r2, [r6, #0x10]
  00060	e596000c	 ldr         r0, [r6, #0xC]
  00064	e1520000	 cmp         r2, r0
  00068	05993008	 ldreq       r3, [r9, #8]
  0006c	03530000	 cmpeq       r3, #0

; 990  :     {
; 991  :         pTransfer->dwUsbError = UFN_NO_ERROR;

  00070	03a04000	 moveq       r4, #0
  00074	05864014	 streq       r4, [r6, #0x14]

; 992  :         complete = TRUE;

  00078	03a02001	 moveq       r2, #1

; 993  :         rc = ERROR_SUCCESS;

  0007c	03a08000	 moveq       r8, #0

; 986  :         goto cleanUp;
; 987  :     
; 988  :     // Is this final interrupt of transfer?
; 989  :     if ((pTransfer->cbTransferred == pTransfer->cbBuffer) && !pEP->zeroLength)

  00080	0a00005e	 beq         |$cleanUp$47409|

; 994  :         goto cleanUp;
; 995  :     }
; 996  :     
; 997  :     // Get size and buffer position
; 998  :     size = pTransfer->cbBuffer - pTransfer->cbTransferred;
; 999  :     
; 1000 :     if (!pPdd->ep[endpoint].dmaEnabled || (size < pPdd->ep[endpoint].maxPacketSize))

  00084	e59e30bc	 ldr         r3, [lr, #0xBC]
  00088	e0407002	 sub         r7, r0, r2
  0008c	e50b7038	 str         r7, [r11, #-0x38]
  00090	e3530000	 cmp         r3, #0
  00094	0a000053	 beq         |$LN8@ContinueTx@2|
  00098	e1de3abc	 ldrh        r3, [lr, #0xAC]
  0009c	e1570003	 cmp         r7, r3
  000a0	3a000050	 bcc         |$LN8@ContinueTx@2|

; 1003 :     }
; 1004 : 
; 1005 :     // If we are using PDD buffer we must check for maximal size
; 1006 :     if ((pTransfer->dwBufferPhysicalAddress == 0) &&
; 1007 :         (size > pPdd->tx0DmaBufferSize))

  000a4	e5963008	 ldr         r3, [r6, #8]
  000a8	e3530000	 cmp         r3, #0
  000ac	1a00000a	 bne         |$LN7@ContinueTx@2|
  000b0	e5951018	 ldr         r1, [r5, #0x18]
  000b4	e1570001	 cmp         r7, r1
  000b8	9a000007	 bls         |$LN7@ContinueTx@2|

; 1008 :     {
; 1009 :         // send integer multiple of maxPacket size
; 1010 :         size = pEP->maxPacketSize *(pPdd->tx0DmaBufferSize/pEP->maxPacketSize);

  000bc	e1d940b0	 ldrh        r4, [r9]
  000c0	e1a00004	 mov         r0, r4
  000c4	eb000000	 bl          __rt_udiv
  000c8	e0070490	 mul         r7, r0, r4

; 1011 :         pEP->bTxDMAShortPacket = FALSE;

  000cc	e3a04000	 mov         r4, #0
  000d0	e5894028	 str         r4, [r9, #0x28]
  000d4	e50b7038	 str         r7, [r11, #-0x38]

; 1012 : 
; 1013 :     }
; 1014 :     else

  000d8	ea000007	 b           |$LN6@ContinueTx@2|
  000dc		 |$LN7@ContinueTx@2|

; 1015 :     {
; 1016 :         pEP->bTxDMAShortPacket = (size % pEP->maxPacketSize) ? FALSE : TRUE;

  000dc	e1d900b0	 ldrh        r0, [r9]
  000e0	e1a01007	 mov         r1, r7
  000e4	eb000000	 bl          __rt_udiv
  000e8	e3510000	 cmp         r1, #0
  000ec	13a03000	 movne       r3, #0
  000f0	03a03001	 moveq       r3, #1
  000f4	e5893028	 str         r3, [r9, #0x28]
  000f8	e3a04000	 mov         r4, #0
  000fc		 |$LN6@ContinueTx@2|

; 1017 :     }
; 1018 : 
; 1019 : 
; 1020 : 
; 1021 :     EnterCriticalSection(&pPdd->dmaCS);

  000fc	e2850034	 add         r0, r5, #0x34
  00100	eb000000	 bl          EnterCriticalSection

; 1022 :     if(!pPdd->bRXIsUsingUsbDMA)

  00104	e5953438	 ldr         r3, [r5, #0x438]
  00108	e3530000	 cmp         r3, #0

; 1025 :         LeaveCriticalSection(&pPdd->dmaCS);

  0010c	e2850034	 add         r0, r5, #0x34

; 1022 :     if(!pPdd->bRXIsUsingUsbDMA)

  00110	1a000033	 bne         |$LN5@ContinueTx@2|

; 1023 :     {
; 1024 :         pPdd->bTXIsUsingUsbDMA = TRUE;

  00114	e3a03001	 mov         r3, #1
  00118	e5853434	 str         r3, [r5, #0x434]

; 1025 :         LeaveCriticalSection(&pPdd->dmaCS);

  0011c	eb000000	 bl          LeaveCriticalSection
  00120		 |$LN21@ContinueTx@2|

; 1031 :     }
; 1032 :       
; 1033 :     __try
; 1034 :     {
; 1035 :         pBuffer =(UCHAR*)pTransfer->pvBuffer + pTransfer->cbTransferred;

  00120	e5963010	 ldr         r3, [r6, #0x10]
  00124	e5961004	 ldr         r1, [r6, #4]

; 1036 :         DEBUGMSG(ZONE_FUNCTION, (L"ContinueDmaTx: Transfer(0x%x), pBuffer(0x%x), cbTransferred(%d), size(%d)\r\n",
; 1037 :             pTransfer, pBuffer, pTransfer->cbTransferred, size));
; 1038 : 
; 1039 :         {
; 1040 :             if (size > 0)

  00128	e3570000	 cmp         r7, #0
  0012c	0a000007	 beq         |$LN2@ContinueTx@2|

; 1041 :             {
; 1042 :                 memcpy(pPdd->pCachedDmaTx0Buffer, pBuffer, size);

  00130	e5950058	 ldr         r0, [r5, #0x58]
  00134	e1a02007	 mov         r2, r7
  00138	e0831001	 add         r1, r3, r1
  0013c	eb000000	 bl          memcpy

; 1043 :                 CacheRangeFlush(pPdd->pCachedDmaTx0Buffer, size, CACHE_SYNC_DISCARD);

  00140	e5950058	 ldr         r0, [r5, #0x58]
  00144	e3a02001	 mov         r2, #1
  00148	e1a01007	 mov         r1, r7
  0014c	eb000000	 bl          CacheRangeFlush
  00150		 |$LN2@ContinueTx@2|

; 1044 :             }
; 1045 : 
; 1046 :             PreDmaActivation(pPdd, endpoint, TX_TRANSFER);

  00150	e3a02000	 mov         r2, #0
  00154	e1a0100a	 mov         r1, r10
  00158	e1a00005	 mov         r0, r5
  0015c	eb000000	 bl          PreDmaActivation

; 1047 :             SETREG16(&pCsrRegs->ep[endpoint].CSR.TxCSR, TXCSR_P_AUTOSET | TXCSR_P_DMAREQENAB | TXCSR_P_DMAREQMODE);

  00160	e51b3034	 ldr         r3, [r11, #-0x34]
  00164	e083020a	 add         r0, r3, r10, lsl #4
  00168	e1d010b2	 ldrh        r1, [r0, #2]

; 1048 :             ProcessDMAChannel(pPdd, (UCHAR) endpoint, MUSB_TX_DMA_CHN, TRUE, pPdd->paDmaTx0Buffer, size, pEP->maxPacketSize);

  0016c	e3a03001	 mov         r3, #1
  00170	e3a02000	 mov         r2, #0
  00174	e3811b25	 orr         r1, r1, #0x25, 22
  00178	e1c010b2	 strh        r1, [r0, #2]
  0017c	e1d900b0	 ldrh        r0, [r9]
  00180	e595e054	 ldr         lr, [r5, #0x54]
  00184	e20a10ff	 and         r1, r10, #0xFF
  00188	e58d0008	 str         r0, [sp, #8]
  0018c	e58de000	 str         lr, [sp]
  00190	e1a00005	 mov         r0, r5
  00194	e58d7004	 str         r7, [sp, #4]
  00198	eb000000	 bl          ProcessDMAChannel
  0019c		 |$LN22@ContinueTx@2|

; 1049 :         }
; 1050 :     }

  0019c	e3a02000	 mov         r2, #0
  001a0	ea000007	 b           |$LN23@ContinueTx@2|
  001a4		 |$LN18@ContinueTx@2|

; 1052 :     {
; 1053 :         pTransfer->dwUsbError = UFN_CLIENT_BUFFER_ERROR;

  001a4	e51b6030	 ldr         r6, [r11, #-0x30]
  001a8	e3a03f41	 mov         r3, #0x41, 30

; 1054 :         complete = TRUE;

  001ac	e3a02001	 mov         r2, #1
  001b0	e5863014	 str         r3, [r6, #0x14]
  001b4	e59b5000	 ldr         r5, [r11]
  001b8	e51b902c	 ldr         r9, [r11, #-0x2C]
  001bc	e51b7038	 ldr         r7, [r11, #-0x38]
  001c0	e3a04000	 mov         r4, #0
  001c4		 |$LN23@ContinueTx@2|

; 1055 :         DEBUGMSG(ZONE_ERROR, (L"UsbFnPdd!ContinueTxTransfer: UFN_CLIENT_BUFFER_ERROR"));
; 1056 :     }
; 1057 :         
; 1058 :     // Update buffer and clear zero length flag
; 1059 :     pTransfer->cbTransferred += size;

  001c4	e5963010	 ldr         r3, [r6, #0x10]

; 1060 :     pEP->zeroLength = FALSE;
; 1061 :     
; 1062 :     rc = ERROR_SUCCESS;

  001c8	e3a08000	 mov         r8, #0
  001cc	e0833007	 add         r3, r3, r7
  001d0	e5863010	 str         r3, [r6, #0x10]
  001d4	e5894008	 str         r4, [r9, #8]
  001d8	ea000008	 b           |$cleanUp$47409|
  001dc		 |$LN27@ContinueTx@2|

; 1001 :     {
; 1002 :         return ContinueTxTransfer(pPdd, endpoint);

  001dc	e51b802c	 ldr         r8, [r11, #-0x2C]
  001e0	ea00000f	 b           |$LN1@ContinueTx@2|
  001e4		 |$LN5@ContinueTx@2|

; 1026 :     }
; 1027 :     else
; 1028 :     {
; 1029 :         LeaveCriticalSection(&pPdd->dmaCS);

  001e4	eb000000	 bl          LeaveCriticalSection
  001e8		 |$LN8@ContinueTx@2|

; 1030 :         return ContinueTxTransfer(pPdd, endpoint);

  001e8	e1a0100a	 mov         r1, r10
  001ec	e1a00005	 mov         r0, r5
  001f0	eb000000	 bl          ContinueTxTransfer
  001f4	e1a08000	 mov         r8, r0
  001f8	ea000009	 b           |$LN1@ContinueTx@2|
  001fc		 |$LN26@ContinueTx@2|

; 1060 :     pEP->zeroLength = FALSE;
; 1061 :     
; 1062 :     rc = ERROR_SUCCESS;

  001fc	e3a04000	 mov         r4, #0
  00200		 |$cleanUp$47409|

; 1063 :     
; 1064 :     
; 1065 :     
; 1066 : cleanUp:
; 1067 :     
; 1068 :     if (complete)

  00200	e3520000	 cmp         r2, #0

; 1069 :     {
; 1070 :         DEBUGMSG(DEBUG_PRT_TRANS, (L"ContinueTxDmaTransfer: call pfnNotify COMPLETE endp:%d +\r\n", endpoint));  
; 1071 :         
; 1072 :         DEBUGMSG(ZONE_PDD, (L"UsbFnPdd!ContinueTxDmaTransfer: "
; 1073 :             L"EP %d pTransfer 0x%08x (%d, %d, %d) - done\r\n",
; 1074 :             endpoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 1075 :             pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 1076 :             pTransfer != NULL ? pTransfer->dwUsbError : -1
; 1077 :             ));
; 1078 : 
; 1079 :         pEP->pTransfer = NULL;

  00204	15894020	 strne       r4, [r9, #0x20]

; 1080 :         pTransfer->dwUsbError = UFN_NO_ERROR;

  00208	15864014	 strne       r4, [r6, #0x14]

; 1081 :         DEBUGMSG(ZONE_INFO, (TEXT("ACK:ContinueTxDmaTransfer for EP %d\r\n"), endpoint));
; 1082 :         pPdd->pfnNotify(
; 1083 :             pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer
; 1084 :             );

  0020c	15950024	 ldrne       r0, [r5, #0x24]
  00210	15953028	 ldrne       r3, [r5, #0x28]
  00214	11a02006	 movne       r2, r6
  00218	13a01064	 movne       r1, #0x64
  0021c	11a0e00f	 movne       lr, pc
  00220	112fff13	 bxne        r3
  00224		 |$LN1@ContinueTx@2|

; 1085 :     }
; 1086 :     
; 1087 :     return rc;
; 1088 : }

  00224	e1a00008	 mov         r0, r8
  00228	e24bd028	 sub         sp, r11, #0x28
  0022c	e89d6ff0	 ldmia       sp, {r4 - r11, sp, lr}
  00230	e12fff1e	 bx          lr

			 ENDP  ; |ContinueTxDmaTransfer|

  00234		 |$LN17@ContinueTx@2|
  00234		 |$LN29@ContinueTx@2|

; 1051 :     __except(EXCEPTION_EXECUTE_HANDLER)

  00234	e52de004	 str         lr, [sp, #-4]!
  00238	e24dd00c	 sub         sp, sp, #0xC
  0023c		 |$LN20@ContinueTx@2|
  0023c		 |$LN32@ContinueTx@2|
  0023c	e3a00001	 mov         r0, #1
  00240		 |$LN19@ContinueTx@2|
  00240	e28dd00c	 add         sp, sp, #0xC
  00244	e49df004	 ldr         pc, [sp], #4
  00248		 |$LN33@ContinueTx@2|
  00248		 |$LN31@ContinueTx@2|

  00000			 AREA	 |.pdata|, PDATA
|$T49105| DCD	|$LN46@StartRxTra|
	DCD	0xc000a005

  00000			 AREA	 |.pdata|, PDATA
|$T49107| DCD	|$LN29@StartRxTra|
	DCD	0x40000301

  00000			 AREA	 |.pdata|, PDATA
|$T49109| DCD	|$LN22@StartRxTra|
	DCD	0x40000301

  00000			 AREA	 |.xdata|, DATA
|$T49103| DCD	0x2
	DCD	|$LN33@StartRxTra|
	DCD	|$LN34@StartRxTra|
	DCD	|$LN29@StartRxTra|
	DCD	|$LN30@StartRxTra|
	DCD	|$LN26@StartRxTra|
	DCD	|$LN27@StartRxTra|
	DCD	|$LN22@StartRxTra|
	DCD	|$LN23@StartRxTra|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T49103|

  00008		 |StartRxTransfer| PROC

; 1097 : {

  00008		 |$LN46@StartRxTra|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d0003	 stmdb       sp!, {r0, r1}
  00010	e92d5ff0	 stmdb       sp!, {r4 - r12, lr}
  00014	e28db028	 add         r11, sp, #0x28
  00018	e24dd014	 sub         sp, sp, #0x14
  0001c		 |$LN44@StartRxTra|
  0001c	e1a07001	 mov         r7, r1
  00020	e58b7004	 str         r7, [r11, #4]
  00024	e1a04000	 mov         r4, r0
  00028	e58b4000	 str         r4, [r11]

; 1098 :     DWORD rc = ERROR_INVALID_PARAMETER;
; 1099 :     MUsbFnEp_t *pEP = &pPdd->ep[endpoint];

  0002c	e3a03034	 mov         r3, #0x34
  00030	e0214397	 mla         r1, r7, r3, r4

; 1100 :     STransfer *pTransfer = pEP->pTransfer;
; 1101 :     PCSP_MUSB_CSR_REGS pCsrRegs = pPdd->pUSBContext->pUsbCsrRegs;

  00034	e5942020	 ldr         r2, [r4, #0x20]

; 1102 :     PCSP_MUSB_GEN_REGS pGenRegs = pPdd->pUSBContext->pUsbGenRegs;
; 1103 :     BOOL bNotifyDataReady = FALSE;

  00038	e3a06000	 mov         r6, #0
  0003c	e281a0ac	 add         r10, r1, #0xAC
  00040	e50ba034	 str         r10, [r11, #-0x34]
  00044	e592801c	 ldr         r8, [r2, #0x1C]
  00048	e59a3020	 ldr         r3, [r10, #0x20]
  0004c	e592e020	 ldr         lr, [r2, #0x20]
  00050	e50b603c	 str         r6, [r11, #-0x3C]
  00054	e1b05003	 movs        r5, r3
  00058	e50b5038	 str         r5, [r11, #-0x38]

; 1104 :     
; 1105 :     DEBUGMSG(ZONE_FUNCTION, (L"UsbFnPdd!StartRxTransfer: "
; 1106 :         L"EP %d pTransfer 0x%08x (%d, %d, %d)\r\n",
; 1107 :         endpoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 1108 :         pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 1109 :         pTransfer != NULL ? pTransfer->dwUsbError : -1
; 1110 :         ));
; 1111 : 
; 1112 :     if (pTransfer == NULL) 

  0005c	1a000001	 bne         |$LN18@StartRxTra|
  00060		 |$LN43@StartRxTra|

; 1113 :     {
; 1114 :         DEBUGMSG(ZONE_ERROR, (L"StartRxTransfer:  error pTransfer is NULL\r\n"));
; 1115 :         return ERROR_INVALID_PARAMETER;

  00060	e3a00057	 mov         r0, #0x57
  00064	ea000038	 b           |$LN19@StartRxTra|
  00068		 |$LN18@StartRxTra|

; 1116 :     }
; 1117 : 
; 1118 :     if (endpoint != 0)

  00068	e3570000	 cmp         r7, #0
  0006c	0a000047	 beq         |$LN17@StartRxTra|

; 1119 :     {
; 1120 :         if (pPdd->intr_rx_data_avail &(1 << endpoint))

  00070	e3a02001	 mov         r2, #1
  00074	e59433f0	 ldr         r3, [r4, #0x3F0]
  00078	e1a00712	 mov         r0, r2, lsl r7
  0007c	e1100003	 tst         r0, r3
  00080	0a000034	 beq         |$LN16@StartRxTra|

; 1121 :         {
; 1122 :             // rx FIFO has data.
; 1123 :             UCHAR *pBuffer;            
; 1124 :             DWORD space, maxSize;
; 1125 :             WORD rxcount;
; 1126 :             
; 1127 :             rxcount = INREG16(&pCsrRegs->ep[endpoint].Count.RxCount);

  00084	e0883207	 add         r3, r8, r7, lsl #4
  00088	e1d380b8	 ldrh        r8, [r3, #8]

; 1128 :             if (rxcount > pPdd->ep[endpoint].maxPacketSize)

  0008c	e1d19abc	 ldrh        r9, [r1, #0xAC]
  00090	e1580009	 cmp         r8, r9

; 1129 :             {
; 1130 :                 rxcount = 0;

  00094	83a08000	 movhi       r8, #0

; 1131 :             }
; 1132 :             
; 1133 :             pBuffer =(UCHAR*)pTransfer->pvBuffer + pTransfer->cbTransferred;               

  00098	e5952010	 ldr         r2, [r5, #0x10]

; 1134 :             space = pTransfer->cbBuffer - pTransfer->cbTransferred;

  0009c	e595300c	 ldr         r3, [r5, #0xC]
  000a0	e5951004	 ldr         r1, [r5, #4]
  000a4	e0433002	 sub         r3, r3, r2

; 1135 : 
; 1136 :             if(rxcount > space)

  000a8	e1580003	 cmp         r8, r3

; 1137 :             {
; 1138 :                 return ERROR_INVALID_PARAMETER;

  000ac	8affffeb	 bhi         |$LN43@StartRxTra|
  000b0		 |$LN26@StartRxTra|

; 1139 :             }
; 1140 :             // Get maxPacketSize
; 1141 :             maxSize = pPdd->ep[endpoint].maxPacketSize;
; 1142 :             
; 1143 :             __try
; 1144 :             {
; 1145 :                 
; 1146 :                 ReadFIFO(pPdd, (UCHAR)endpoint, pBuffer, (DWORD)rxcount);

  000b0	e1a03008	 mov         r3, r8
  000b4	e0812002	 add         r2, r1, r2
  000b8	e20710ff	 and         r1, r7, #0xFF
  000bc	e1a00004	 mov         r0, r4
  000c0	eb000000	 bl          ReadFIFO

; 1147 :                 DEBUGMSG(ZONE_INFO, (L"Received:\r\n"));
; 1148 :                 
; 1149 :                 // We transfered some data
; 1150 :                 pTransfer->cbTransferred += rxcount;

  000c4	e5953010	 ldr         r3, [r5, #0x10]

; 1151 :                 
; 1152 :                 // Is this end of transfer?
; 1153 :                 if (rxcount < maxSize)

  000c8	e1580009	 cmp         r8, r9
  000cc	e0833008	 add         r3, r3, r8
  000d0	e5853010	 str         r3, [r5, #0x10]

; 1154 :                 {
; 1155 :                     // received last block
; 1156 :                     pTransfer->dwUsbError = UFN_NO_ERROR;

  000d4	e3a02000	 mov         r2, #0
  000d8	35852014	 strcc       r2, [r5, #0x14]

; 1157 :                     bNotifyDataReady = TRUE;

  000dc	33a06001	 movcc       r6, #1
  000e0	350b603c	 strcc       r6, [r11, #-0x3C]
  000e4		 |$LN27@StartRxTra|

; 1158 :                     // Don't clear the RxPktRdy until it is ready to further received
; 1159 :                 }
; 1160 :             }

  000e4	ea000007	 b           |$LN28@StartRxTra|
  000e8		 |$LN23@StartRxTra|

; 1162 :             {
; 1163 :                 pTransfer->dwUsbError = UFN_CLIENT_BUFFER_ERROR;

  000e8	e51b5038	 ldr         r5, [r11, #-0x38]
  000ec	e3a03f41	 mov         r3, #0x41, 30
  000f0	e5853014	 str         r3, [r5, #0x14]
  000f4	e59b7004	 ldr         r7, [r11, #4]
  000f8	e59b4000	 ldr         r4, [r11]
  000fc	e51ba034	 ldr         r10, [r11, #-0x34]
  00100	e51b603c	 ldr         r6, [r11, #-0x3C]
  00104	e3a02000	 mov         r2, #0
  00108		 |$LN28@StartRxTra|

; 1164 :             }
; 1165 :             
; 1166 :             // clear intr_rx_data_avail EP0 bit
; 1167 :             pPdd->intr_rx_data_avail &= ~(1 << endpoint);           

  00108	e3a00001	 mov         r0, #1
  0010c	e59433f0	 ldr         r3, [r4, #0x3F0]

; 1168 : 
; 1169 :             pPdd->ep[endpoint].bLastRxUsedDMA = FALSE;

  00110	e3a01034	 mov         r1, #0x34
  00114	e1c33710	 bic         r3, r3, r0, lsl r7
  00118	e0214197	 mla         r1, r7, r1, r4
  0011c	e58433f0	 str         r3, [r4, #0x3F0]

; 1170 :             
; 1171 :             if (bNotifyDataReady)

  00120	e3560000	 cmp         r6, #0
  00124	e58120dc	 str         r2, [r1, #0xDC]

; 1172 :             {
; 1173 :                 pEP->pTransfer = NULL;

  00128	158a2020	 strne       r2, [r10, #0x20]

; 1174 :                 pTransfer->dwUsbError = UFN_NO_ERROR;

  0012c	15852014	 strne       r2, [r5, #0x14]

; 1175 :                 DEBUGMSG(ZONE_INFO, (TEXT("ACK: StartRxTransfer for EP %d\r\n"), endpoint));
; 1176 :                 pPdd->pfnNotify(
; 1177 :                     pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer);

  00130	15940024	 ldrne       r0, [r4, #0x24]
  00134	15943028	 ldrne       r3, [r4, #0x28]
  00138	11a02005	 movne       r2, r5
  0013c	13a01064	 movne       r1, #0x64
  00140	11a0e00f	 movne       lr, pc
  00144	112fff13	 bxne        r3

; 1249 :                     pPdd->pfnNotify(
; 1250 :                         pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer);

  00148		 |$LN2@StartRxTra|

; 1251 :                 }
; 1252 :             }
; 1253 :         }
; 1254 :     }       
; 1255 :     
; 1256 :     rc = ERROR_SUCCESS;
; 1257 :     
; 1258 :     if (endpoint == 0)
; 1259 :         prtEP0State(pPdd);
; 1260 :     DEBUGMSG(ZONE_FUNCTION, (L"-StartRxTransfer\r\n"));
; 1261 :     
; 1262 :     return rc;

  00148	e3a00000	 mov         r0, #0
  0014c		 |$LN19@StartRxTra|

; 1263 : }

  0014c	e24bd028	 sub         sp, r11, #0x28
  00150	e89d6ff0	 ldmia       sp, {r4 - r11, sp, lr}
  00154	e12fff1e	 bx          lr
  00158		 |$LN16@StartRxTra|

; 1178 :             }
; 1179 :         }
; 1180 :         else
; 1181 :         {
; 1182 :             if(pPdd->ep[endpoint].bLastRxUsedDMA == FALSE)

  00158	e59130dc	 ldr         r3, [r1, #0xDC]
  0015c	e3530000	 cmp         r3, #0

; 1183 :             {
; 1184 :             CLRREG16(&pCsrRegs->ep[endpoint].RxCSR, RXCSR_P_RXPKTRDY);

  00160	00881207	 addeq       r1, r8, r7, lsl #4
  00164	01d120b6	 ldreqh      r2, [r1, #6]
  00168	03a03cff	 moveq       r3, #0xFF, 24
  0016c	038330fe	 orreq       r3, r3, #0xFE
  00170	00023003	 andeq       r3, r2, r3
  00174	01c130b6	 streqh      r3, [r1, #6]

; 1185 :             }
; 1186 :             else
; 1187 :             {
; 1188 :                 pPdd->ep[endpoint].bLastRxUsedDMA = FALSE;

  00178	13a03000	 movne       r3, #0
  0017c	158130dc	 strne       r3, [r1, #0xDC]

; 1189 :             }
; 1190 : 
; 1191 :             SETREG16(&pGenRegs->IntrRxE, (1<<endpoint));

  00180	e1de30b8	 ldrh        r3, [lr, #8]
  00184	e1833000	 orr         r3, r3, r0
  00188	e1ce30b8	 strh        r3, [lr, #8]

; 1192 :             DEBUGMSG(ZONE_FUNCTION, (TEXT("EP %d IssueTransfer(OUT) RxCSR=0x%x\r\n"), endpoint, INREG16(&pCsrRegs->ep[endpoint].RxCSR)));
; 1193 :         }
; 1194 :     }
; 1195 :     else // if (endpoint != 0)

  0018c	eaffffed	 b           |$LN2@StartRxTra|
  00190		 |$LN17@StartRxTra|

; 1196 :     {
; 1197 :         if (pPdd->ep0State == EP0_ST_SETUP_PROCESSED)

  00190	e59433ec	 ldr         r3, [r4, #0x3EC]
  00194	e3530001	 cmp         r3, #1
  00198	1affffea	 bne         |$LN2@StartRxTra|

; 1198 :         {
; 1199 :             pPdd->ep0State = EP0_ST_DATA_RX;
; 1200 :             
; 1201 :             if (pPdd->intr_rx_data_avail &(1 << EP0))

  0019c	e59433f0	 ldr         r3, [r4, #0x3F0]
  001a0	e3a02004	 mov         r2, #4
  001a4	e58423ec	 str         r2, [r4, #0x3EC]
  001a8	e3130001	 tst         r3, #1
  001ac	0affffe5	 beq         |$LN2@StartRxTra|

; 1202 :             {
; 1203 :                 // rx FIFO has data.
; 1204 :                 UCHAR *pBuffer;            
; 1205 :                 DWORD space, maxSize;
; 1206 :                 USHORT rxcount;
; 1207 :                 
; 1208 :                 rxcount = INREG8(&pCsrRegs->ep[EP0].Count.Count0);
; 1209 :                 
; 1210 :                 pBuffer =(UCHAR*)pTransfer->pvBuffer + pTransfer->cbTransferred;               

  001b0	e5952010	 ldr         r2, [r5, #0x10]
  001b4	e5951004	 ldr         r1, [r5, #4]

; 1211 :                 space = pTransfer->cbBuffer - pTransfer->cbTransferred;

  001b8	e595300c	 ldr         r3, [r5, #0xC]
  001bc	e0433002	 sub         r3, r3, r2
  001c0	e50b302c	 str         r3, [r11, #-0x2C]
  001c4	e5d89008	 ldrb        r9, [r8, #8]

; 1212 :                 // Get maxPacketSize
; 1213 :                 maxSize = pPdd->ep[EP0].maxPacketSize;

  001c8	e1d43abc	 ldrh        r3, [r4, #0xAC]
  001cc	e50b3030	 str         r3, [r11, #-0x30]
  001d0		 |$LN33@StartRxTra|

; 1214 :                 
; 1215 :                 __try
; 1216 :                 {
; 1217 :                     USHORT dwFlag = CSR0_P_SERVICEDRXPKTRDY;
; 1218 :                     
; 1219 :                     ReadFIFO(pPdd, (UCHAR)endpoint, pBuffer, (DWORD)rxcount);

  001d0	e1a03009	 mov         r3, r9
  001d4	e0812002	 add         r2, r1, r2
  001d8	e3a01000	 mov         r1, #0
  001dc	e1a00004	 mov         r0, r4
  001e0	e3a07040	 mov         r7, #0x40
  001e4	eb000000	 bl          ReadFIFO

; 1220 :                     DEBUGMSG(ZONE_INFO, (L"Received:\r\n"));
; 1221 :                     //memdump((UCHAR *)pBuffer, (USHORT)rxcount, 0);
; 1222 :                     
; 1223 :                     // We transfered some data
; 1224 :                     pTransfer->cbTransferred = pTransfer->cbBuffer - space;

  001e8	e595300c	 ldr         r3, [r5, #0xC]

; 1225 :                     
; 1226 :                     // Is this end of transfer?
; 1227 :                     if (rxcount < maxSize)

  001ec	e51b2030	 ldr         r2, [r11, #-0x30]
  001f0	e1590002	 cmp         r9, r2
  001f4	e51b202c	 ldr         r2, [r11, #-0x2C]
  001f8	e0433002	 sub         r3, r3, r2
  001fc	e5853010	 str         r3, [r5, #0x10]

; 1228 :                     {
; 1229 :                         // received last block
; 1230 :                         pTransfer->dwUsbError = UFN_NO_ERROR;

  00200	e3a02000	 mov         r2, #0

; 1231 :                         pPdd->ep0State = EP0_ST_STATUS_IN;

  00204	33a03002	 movcc       r3, #2
  00208	35852014	 strcc       r2, [r5, #0x14]
  0020c	358433ec	 strcc       r3, [r4, #0x3EC]

; 1232 :                         bNotifyDataReady = TRUE;

  00210	33a06001	 movcc       r6, #1
  00214	350b603c	 strcc       r6, [r11, #-0x3C]

; 1233 :                         dwFlag |= CSR0_P_DATAEND;

  00218	33a07048	 movcc       r7, #0x48

; 1234 :                     }
; 1235 :                     SETREG16(&pCsrRegs->ep[EP0].CSR.CSR0, dwFlag);

  0021c	e1d830b2	 ldrh        r3, [r8, #2]
  00220	e1833007	 orr         r3, r3, r7
  00224	e1c830b2	 strh        r3, [r8, #2]
  00228		 |$LN34@StartRxTra|

; 1236 :                 }

  00228	ea000006	 b           |$LN35@StartRxTra|
  0022c		 |$LN30@StartRxTra|

; 1238 :                 {
; 1239 :                     pTransfer->dwUsbError = UFN_CLIENT_BUFFER_ERROR;

  0022c	e51b5038	 ldr         r5, [r11, #-0x38]
  00230	e3a03f41	 mov         r3, #0x41, 30
  00234	e5853014	 str         r3, [r5, #0x14]
  00238	e59b4000	 ldr         r4, [r11]
  0023c	e51ba034	 ldr         r10, [r11, #-0x34]
  00240	e51b603c	 ldr         r6, [r11, #-0x3C]
  00244	e3a02000	 mov         r2, #0
  00248		 |$LN35@StartRxTra|

; 1240 :                 }
; 1241 :                 
; 1242 :                 // clear intr_rx_data_avail EP0 bit
; 1243 :                 pPdd->intr_rx_data_avail &= ~(1 << EP0);            

  00248	e59433f0	 ldr         r3, [r4, #0x3F0]

; 1244 :                 
; 1245 :                 if (bNotifyDataReady)

  0024c	e3560000	 cmp         r6, #0
  00250	e3c33001	 bic         r3, r3, #1
  00254	e58433f0	 str         r3, [r4, #0x3F0]
  00258	0affffba	 beq         |$LN2@StartRxTra|

; 1246 :                 {
; 1247 :                     pEP->pTransfer = NULL;

  0025c	e58a2020	 str         r2, [r10, #0x20]

; 1248 :                     pTransfer->dwUsbError = UFN_NO_ERROR;

  00260	e5852014	 str         r2, [r5, #0x14]

; 1249 :                     pPdd->pfnNotify(
; 1250 :                         pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer);

  00264	e5940024	 ldr         r0, [r4, #0x24]
  00268	e5943028	 ldr         r3, [r4, #0x28]
  0026c	e1a02005	 mov         r2, r5
  00270	e3a01064	 mov         r1, #0x64
  00274	e1a0e00f	 mov         lr, pc
  00278	e12fff13	 bx          r3
  0027c	eaffffb1	 b           |$LN2@StartRxTra|
  00280		 |$LN42@StartRxTra|

; 1251 :                 }
; 1252 :             }
; 1253 :         }
; 1254 :     }       
; 1255 :     
; 1256 :     rc = ERROR_SUCCESS;
; 1257 :     
; 1258 :     if (endpoint == 0)
; 1259 :         prtEP0State(pPdd);
; 1260 :     DEBUGMSG(ZONE_FUNCTION, (L"-StartRxTransfer\r\n"));
; 1261 :     
; 1262 :     return rc;

  00280	e51b002c	 ldr         r0, [r11, #-0x2C]
  00284	eaffffb0	 b           |$LN19@StartRxTra|

			 ENDP  ; |StartRxTransfer|

  00288		 |$LN29@StartRxTra|
  00288		 |$LN45@StartRxTra|

; 1237 :                 __except(EXCEPTION_EXECUTE_HANDLER)

  00288	e52de004	 str         lr, [sp, #-4]!
  0028c		 |$LN32@StartRxTra|
  0028c		 |$LN49@StartRxTra|
  0028c	e3a00001	 mov         r0, #1
  00290		 |$LN31@StartRxTra|
  00290	e49df004	 ldr         pc, [sp], #4
  00294		 |$LN50@StartRxTra|
  00294		 |$LN22@StartRxTra|
  00294		 |$LN47@StartRxTra|

; 1161 :             __except(EXCEPTION_EXECUTE_HANDLER)

  00294	e52de004	 str         lr, [sp, #-4]!
  00298		 |$LN25@StartRxTra|
  00298		 |$LN51@StartRxTra|
  00298	e3a00001	 mov         r0, #1
  0029c		 |$LN24@StartRxTra|
  0029c	e49df004	 ldr         pc, [sp], #4
  002a0		 |$LN52@StartRxTra|
  002a0		 |$LN48@StartRxTra|

  00000			 AREA	 |.pdata|, PDATA
|$T49152| DCD	|$LN28@StartRxDma|
	DCD	0x40008b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |StartRxDmaTransfer| PROC

; 1273 : {

  00000		 |$LN28@StartRxDma|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M49149|
  00008	e1a08001	 mov         r8, r1
  0000c	e1a06000	 mov         r6, r0

; 1274 :     DWORD rc = ERROR_INVALID_PARAMETER;
; 1275 :     MUsbFnEp_t *pEP = &pPdd->ep[endpoint];
; 1276 :     STransfer *pTransfer = pEP->pTransfer;
; 1277 :     DWORD size;
; 1278 :     DWORD dwDMAPhysAddr = pTransfer->dwBufferPhysicalAddress;
; 1279 :     PCSP_MUSB_CSR_REGS pCsrRegs = pPdd->pUSBContext->pUsbCsrRegs;

  00010	e5965020	 ldr         r5, [r6, #0x20]
  00014	e3a03034	 mov         r3, #0x34
  00018	e0276398	 mla         r7, r8, r3, r6

; 1280 :     PCSP_MUSB_GEN_REGS pGenRegs = pPdd->pUSBContext->pUsbGenRegs;
; 1281 :     UINT16 RxCsr = 0;
; 1282 :         
; 1283 :     
; 1284 :     DEBUGMSG(ZONE_FUNCTION, (L"UsbFnPdd!StartRxDmaTransfer: "
; 1285 :         L"EP %d pTransfer 0x%08x (%d, %d, %d)\r\n",
; 1286 :         endpoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 1287 :         pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 1288 :         pTransfer != NULL ? pTransfer->dwUsbError : -1
; 1289 :         ));
; 1290 :     
; 1291 :     if (pTransfer == NULL)
; 1292 :         goto cleanUp;
; 1293 :     
; 1294 :     // Get size to be received
; 1295 :     size = pTransfer->cbBuffer - pTransfer->cbTransferred;
; 1296 :     
; 1297 :     if (!pPdd->ep[endpoint].dmaEnabled ||
; 1298 :         (size <= pPdd->ep[endpoint].maxPacketSize) ||
; 1299 :         (pPdd->rx0DmaState != MODE_DMA) ||
; 1300 :         !pPdd->bDMAForRX ||
; 1301 :         pPdd->intr_rx_data_avail)

  0001c	e595301c	 ldr         r3, [r5, #0x1C]
  00020	e595b020	 ldr         r11, [r5, #0x20]
  00024	e597e0cc	 ldr         lr, [r7, #0xCC]
  00028	e59740bc	 ldr         r4, [r7, #0xBC]
  0002c	e58d3004	 str         r3, [sp, #4]
  00030	e59e200c	 ldr         r2, [lr, #0xC]
  00034	e59e3010	 ldr         r3, [lr, #0x10]
  00038	e59e9008	 ldr         r9, [lr, #8]
  0003c	e3540000	 cmp         r4, #0
  00040	e042a003	 sub         r10, r2, r3
  00044	e58d9000	 str         r9, [sp]
  00048	0a000071	 beq         |$LN11@StartRxDma|
  0004c	e1d73abc	 ldrh        r3, [r7, #0xAC]
  00050	e15a0003	 cmp         r10, r3
  00054	9a00006e	 bls         |$LN11@StartRxDma|
  00058	e596301c	 ldr         r3, [r6, #0x1C]
  0005c	e3530000	 cmp         r3, #0
  00060	1a00006b	 bne         |$LN11@StartRxDma|
  00064	e5963430	 ldr         r3, [r6, #0x430]
  00068	e3530000	 cmp         r3, #0
  0006c	0a000068	 beq         |$LN11@StartRxDma|
  00070	e59633f0	 ldr         r3, [r6, #0x3F0]
  00074	e3530000	 cmp         r3, #0
  00078	1a000065	 bne         |$LN11@StartRxDma|

; 1304 :     }
; 1305 : 
; 1306 :     EnterCriticalSection(&pPdd->dmaCS);

  0007c	e2860034	 add         r0, r6, #0x34
  00080	eb000000	 bl          EnterCriticalSection

; 1307 :     if (!pPdd->bTXIsUsingUsbDMA)

  00084	e5963434	 ldr         r3, [r6, #0x434]

; 1308 :     {
; 1309 :         pPdd->bRXIsUsingUsbDMA = TRUE;
; 1310 :         LeaveCriticalSection(&pPdd->dmaCS);

  00088	e2860034	 add         r0, r6, #0x34
  0008c	e3530000	 cmp         r3, #0
  00090	1a00005e	 bne         |$LN10@StartRxDma|
  00094	e3a03001	 mov         r3, #1
  00098	e5863438	 str         r3, [r6, #0x438]
  0009c	eb000000	 bl          LeaveCriticalSection

; 1315 :         return StartRxTransfer(pPdd, endpoint);
; 1316 :     }
; 1317 : 
; 1318 :     pEP->dwRemainBuffer = 0;

  000a0	e3a04000	 mov         r4, #0
  000a4	e58740c8	 str         r4, [r7, #0xC8]

; 1319 : 
; 1320 :     // If we are using PDD buffer we must check for maximal size
; 1321 :     if (dwDMAPhysAddr == 0)

  000a8	e3590000	 cmp         r9, #0
  000ac	1a000006	 bne         |$LN8@StartRxDma|

; 1322 :     {
; 1323 :         if (size > pPdd->rx0DmaBufferSize)

  000b0	e5963014	 ldr         r3, [r6, #0x14]
  000b4	e15a0003	 cmp         r10, r3

; 1324 :         {
; 1325 :             pEP->dwRemainBuffer = size - pPdd->rx0DmaBufferSize;

  000b8	804a3003	 subhi       r3, r10, r3
  000bc	858730c8	 strhi       r3, [r7, #0xC8]

; 1326 :             size = pPdd->rx0DmaBufferSize;
; 1327 :         }
; 1328 :         dwDMAPhysAddr = pPdd->paDmaRx0Buffer;

  000c0	e596304c	 ldr         r3, [r6, #0x4C]
  000c4	8596a014	 ldrhi       r10, [r6, #0x14]
  000c8	e58d3000	 str         r3, [sp]
  000cc		 |$LN8@StartRxDma|

; 1329 :     }
; 1330 :     
; 1331 :     EnterCriticalSection(&pPdd->dmaCS);

  000cc	e2860034	 add         r0, r6, #0x34
  000d0	eb000000	 bl          EnterCriticalSection

; 1332 : 
; 1333 :     RxCsr = INREG16(&pCsrRegs->ep[endpoint].RxCSR);
; 1334 :     
; 1335 :     if(pEP->bMassStore)

  000d4	e59d2004	 ldr         r2, [sp, #4]
  000d8	e59730b8	 ldr         r3, [r7, #0xB8]
  000dc	e0829208	 add         r9, r2, r8, lsl #4
  000e0	e1d910b6	 ldrh        r1, [r9, #6]
  000e4	e3530000	 cmp         r3, #0
  000e8	0a000008	 beq         |$LN6@StartRxDma|

; 1336 :     {
; 1337 :         RxCsr &= ~(RXCSR_P_DMAREQMODE);
; 1338 :         RxCsr |= (RXCSR_P_AUTOCLEAR | RXCSR_P_DMAREQENAB);
; 1339 :         CLRREG16(&pGenRegs->IntrRxE, (1<<endpoint));

  000ec	e1db20b8	 ldrh        r2, [r11, #8]
  000f0	e3a03c57	 mov         r3, #0x57, 24
  000f4	e3a00001	 mov         r0, #1
  000f8	e38330ff	 orr         r3, r3, #0xFF
  000fc	e1c22810	 bic         r2, r2, r0, lsl r8
  00100	e0013003	 and         r3, r1, r3
  00104	e1cb20b8	 strh        r2, [r11, #8]
  00108	e3835a0a	 orr         r5, r3, #0xA, 20

; 1340 :     }
; 1341 :     else 

  0010c	ea000004	 b           |$LN5@StartRxDma|
  00110		 |$LN6@StartRxDma|

; 1342 :     {
; 1343 :         RxCsr |= (RXCSR_P_AUTOCLEAR | RXCSR_P_DMAREQENAB | RXCSR_P_DMAREQMODE);
; 1344 :         SETREG16(&pGenRegs->IntrRxE, (1<<endpoint));

  00110	e1db30b8	 ldrh        r3, [r11, #8]
  00114	e3a02001	 mov         r2, #1
  00118	e3815b2a	 orr         r5, r1, #0x2A, 22
  0011c	e1833812	 orr         r3, r3, r2, lsl r8
  00120	e1cb30b8	 strh        r3, [r11, #8]
  00124		 |$LN5@StartRxDma|

; 1345 :     }
; 1346 :     // This is to avoid race condition, if the DVFS Notify comes after PreDmaActivation, 
; 1347 :     // If it is after CheckAndHaltDMA, we need to change to StartRxTransfer. 
; 1348 :     // Otherwise, we can use directly to call StartRxTransfer    
; 1349 :     if ((pPdd->bDVFSActive) && (pPdd->rx0DmaState == MODE_FIFO))

  00124	e5963400	 ldr         r3, [r6, #0x400]
  00128	e3530000	 cmp         r3, #0
  0012c	0a000007	 beq         |$LN4@StartRxDma|
  00130	e596301c	 ldr         r3, [r6, #0x1C]
  00134	e3530001	 cmp         r3, #1
  00138	1a000004	 bne         |$LN4@StartRxDma|

; 1350 :     {
; 1351 :         pPdd->bRXIsUsingUsbDMA = FALSE;
; 1352 :         StartRxTransfer(pPdd, endpoint);

  0013c	e1a01008	 mov         r1, r8
  00140	e1a00006	 mov         r0, r6
  00144	e5864438	 str         r4, [r6, #0x438]
  00148	eb000000	 bl          StartRxTransfer

; 1353 :     }
; 1354 :     else

  0014c	ea00002b	 b           |$LN1@StartRxDma|
  00150		 |$LN4@StartRxDma|

; 1355 :     {
; 1356 :         PreDmaActivation(pPdd, endpoint, RX_TRANSFER);

  00150	e3a02001	 mov         r2, #1
  00154	e1a01008	 mov         r1, r8
  00158	e1a00006	 mov         r0, r6
  0015c	eb000000	 bl          PreDmaActivation

; 1357 :         SETREG16(&pCsrRegs->ep[endpoint].RxCSR, RxCsr);

  00160	e1d930b6	 ldrh        r3, [r9, #6]

; 1358 : 
; 1359 :         pEP->dwRxDMASize = size;
; 1360 :         ProcessDMAChannel(pPdd, (UCHAR) endpoint, MUSB_RX_DMA_CHN, FALSE, dwDMAPhysAddr, size, pEP->maxPacketSize);

  00164	e2860034	 add         r0, r6, #0x34
  00168	e3a04000	 mov         r4, #0
  0016c	e1833005	 orr         r3, r3, r5
  00170	e1c930b6	 strh        r3, [r9, #6]
  00174	e1d75abc	 ldrh        r5, [r7, #0xAC]
  00178	e587a0d0	 str         r10, [r7, #0xD0]
  0017c	e596b020	 ldr         r11, [r6, #0x20]
  00180	eb000000	 bl          EnterCriticalSection
  00184	e15a0005	 cmp         r10, r5
  00188	83a04004	 movhi       r4, #4
  0018c	e3550040	 cmp         r5, #0x40
  00190	23844c06	 orrcs       r4, r4, #6, 24
  00194	2a000004	 bcs         |$LN18@StartRxDma|
  00198	e3550020	 cmp         r5, #0x20
  0019c	23844b01	 orrcs       r4, r4, #1, 22
  001a0	2a000001	 bcs         |$LN18@StartRxDma|
  001a4	e3550010	 cmp         r5, #0x10
  001a8	23844c02	 orrcs       r4, r4, #2, 24
  001ac		 |$LN18@StartRxDma|
  001ac	e59b2024	 ldr         r2, [r11, #0x24]
  001b0	e59d1000	 ldr         r1, [sp]
  001b4	e20830ff	 and         r3, r8, #0xFF
  001b8	e1843203	 orr         r3, r4, r3, lsl #4
  001bc	e5821018	 str         r1, [r2, #0x18]
  001c0	e59b2024	 ldr         r2, [r11, #0x24]
  001c4	e3831009	 orr         r1, r3, #9
  001c8	e2860034	 add         r0, r6, #0x34
  001cc	e582a01c	 str         r10, [r2, #0x1C]
  001d0	e59b3024	 ldr         r3, [r11, #0x24]
  001d4	e5831014	 str         r1, [r3, #0x14]
  001d8	eb000000	 bl          LeaveCriticalSection

; 1361 : 
; 1362 :         if(pPdd->ep[endpoint].bLastRxUsedDMA == FALSE)

  001dc	e59730dc	 ldr         r3, [r7, #0xDC]
  001e0	e3530000	 cmp         r3, #0

; 1363 :             CLRREG16(&pCsrRegs->ep[endpoint].RxCSR, RXCSR_P_RXPKTRDY);

  001e4	01d920b6	 ldreqh      r2, [r9, #6]
  001e8	03a03cff	 moveq       r3, #0xFF, 24
  001ec	038330fe	 orreq       r3, r3, #0xFE
  001f0	00023003	 andeq       r3, r2, r3
  001f4	01c930b6	 streqh      r3, [r9, #6]

; 1364 :         else
; 1365 :             pPdd->ep[endpoint].bLastRxUsedDMA = FALSE;

  001f8	13a03000	 movne       r3, #0
  001fc	158730dc	 strne       r3, [r7, #0xDC]
  00200		 |$LN1@StartRxDma|

; 1366 :     }
; 1367 :     LeaveCriticalSection(&pPdd->dmaCS);

  00200	e2860034	 add         r0, r6, #0x34
  00204	eb000000	 bl          LeaveCriticalSection

; 1368 :     
; 1369 :     rc = ERROR_SUCCESS;
; 1370 :     
; 1371 : cleanUp:
; 1372 :     
; 1373 :     return rc;

  00208	e3a00000	 mov         r0, #0
  0020c		 |$cleanUp$47517|
  0020c	ea000003	 b           |$LN14@StartRxDma|
  00210		 |$LN10@StartRxDma|

; 1311 :     }
; 1312 :     else
; 1313 :     {
; 1314 :         LeaveCriticalSection(&pPdd->dmaCS);

  00210	eb000000	 bl          LeaveCriticalSection
  00214		 |$LN11@StartRxDma|

; 1302 :     {
; 1303 :         return StartRxTransfer(pPdd, endpoint);

  00214	e1a01008	 mov         r1, r8
  00218	e1a00006	 mov         r0, r6
  0021c	eb000000	 bl          StartRxTransfer
  00220		 |$LN14@StartRxDma|

; 1374 : }

  00220	e28dd008	 add         sp, sp, #8
  00224	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00228	e12fff1e	 bx          lr
  0022c		 |$M49150|

			 ENDP  ; |StartRxDmaTransfer|


  00000			 AREA	 |.pdata|, PDATA
|$T49164| DCD	|$LN10@Device_Res|
	DCD	0x40003e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Device_ResetIRQ| PROC

; 1396 : {

  00000		 |$LN10@Device_Res|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M49161|

; 1397 :     MUsbFnPdd_t *pPdd =((PHSMUSB_T) pHSMUSBContext)->pContext[DEVICE_CONTEXT];

  00004	e5905010	 ldr         r5, [r0, #0x10]

; 1398 :     PCSP_MUSB_GEN_REGS pGenRegs =((PHSMUSB_T) pHSMUSBContext)->pUsbGenRegs;

  00008	e5906020	 ldr         r6, [r0, #0x20]

; 1399 :     
; 1400 :     DEBUGMSG(ZONE_FUNCTION, (TEXT("+Device_ResetIRQ\r\n")));
; 1401 :     
; 1402 :     // initialize Endpoint0 setup state 
; 1403 :     pPdd->ep0State = EP0_ST_SETUP;

  0000c	e3a01000	 mov         r1, #0

; 1404 :     
; 1405 :     pPdd->intr_rx_data_avail = 0;
; 1406 :     if (pPdd->enableDMA && (pPdd->rx0DmaEp != -1) && pPdd->ep[pPdd->rx0DmaEp].dmaEnabled)

  00010	e5953008	 ldr         r3, [r5, #8]
  00014	e58513ec	 str         r1, [r5, #0x3EC]
  00018	e58513f0	 str         r1, [r5, #0x3F0]
  0001c	e3530000	 cmp         r3, #0
  00020	0a000006	 beq         |$LN5@Device_Res|
  00024	e595200c	 ldr         r2, [r5, #0xC]
  00028	e3720001	 cmn         r2, #1
  0002c	13a03034	 movne       r3, #0x34
  00030	10235392	 mlane       r3, r2, r3, r5
  00034	159330bc	 ldrne       r3, [r3, #0xBC]
  00038	13530000	 cmpne       r3, #0

; 1407 :         pPdd->rx0DmaState = MODE_DMA;

  0003c	1585101c	 strne       r1, [r5, #0x1C]
  00040		 |$LN5@Device_Res|

; 1408 :     
; 1409 :     pPdd->fPowerDown = FALSE;
; 1410 :     pPdd->dwUSBFNState = USBFN_IDLE;
; 1411 : 
; 1412 :     if ((pPdd->devState & MUSB_DEVSTAT_ATT) == 0)

  00040	e595306c	 ldr         r3, [r5, #0x6C]

; 1413 :     {
; 1414 :         // MUSB doesn't generate an attach interrrupt.  Interpret bus reset event as attach.
; 1415 :         pPdd->devState |= MUSB_DEVSTAT_ATT | MUSB_DEVSTAT_USB_RESET;
; 1416 :         pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_DETACH);

  00044	e5950024	 ldr         r0, [r5, #0x24]
  00048	e58510a4	 str         r1, [r5, #0xA4]
  0004c	e58510a8	 str         r1, [r5, #0xA8]
  00050	e3130001	 tst         r3, #1
  00054	e3a01001	 mov         r1, #1
  00058	1a00001f	 bne         |$LN4@Device_Res|
  0005c	e3833021	 orr         r3, r3, #0x21
  00060	e5954028	 ldr         r4, [r5, #0x28]
  00064	e585306c	 str         r3, [r5, #0x6C]
  00068	e3a02000	 mov         r2, #0
  0006c	e1a0e00f	 mov         lr, pc
  00070	e12fff14	 bx          r4

; 1417 :         pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_ATTACH);

  00074	e5950024	 ldr         r0, [r5, #0x24]
  00078	e5953028	 ldr         r3, [r5, #0x28]
  0007c	e3a02001	 mov         r2, #1
  00080	e3a01001	 mov         r1, #1
  00084	e1a0e00f	 mov         lr, pc
  00088	e12fff13	 bx          r3

; 1418 :         if (INREG8(&pGenRegs->Power) & POWER_HSMODE)

  0008c	e5d63001	 ldrb        r3, [r6, #1]

; 1419 :         {
; 1420 :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_SPEED, BS_HIGH_SPEED);

  00090	e5950024	 ldr         r0, [r5, #0x24]
  00094	e3a01003	 mov         r1, #3
  00098	e3130010	 tst         r3, #0x10
  0009c	e5953028	 ldr         r3, [r5, #0x28]
  000a0	0a000003	 beq         |$LN3@Device_Res|
  000a4	e3a02002	 mov         r2, #2
  000a8	e1a0e00f	 mov         lr, pc
  000ac	e12fff13	 bx          r3

; 1421 :         }
; 1422 :         else

  000b0	ea000002	 b           |$LN2@Device_Res|
  000b4		 |$LN3@Device_Res|

; 1423 :         {
; 1424 :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_SPEED, BS_FULL_SPEED);

  000b4	e3a02001	 mov         r2, #1
  000b8	e1a0e00f	 mov         lr, pc
  000bc	e12fff13	 bx          r3
  000c0		 |$LN2@Device_Res|

; 1425 :         }           
; 1426 :         // Tell MDD about reset...
; 1427 :         pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_RESET);

  000c0	e5950024	 ldr         r0, [r5, #0x24]
  000c4	e5953028	 ldr         r3, [r5, #0x28]
  000c8	e3a02002	 mov         r2, #2
  000cc	e3a01001	 mov         r1, #1
  000d0	e1a0e00f	 mov         lr, pc
  000d4	e12fff13	 bx          r3

; 1428 :     }
; 1429 :     else

  000d8	ea000003	 b           |$LN1@Device_Res|
  000dc		 |$LN4@Device_Res|

; 1430 :         pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_RESET);

  000dc	e5953028	 ldr         r3, [r5, #0x28]
  000e0	e3a02002	 mov         r2, #2
  000e4	e1a0e00f	 mov         lr, pc
  000e8	e12fff13	 bx          r3
  000ec		 |$LN1@Device_Res|

; 1431 : 
; 1432 :     prtEP0State(pPdd);
; 1433 :     DEBUGMSG(ZONE_FUNCTION, (TEXT("-Device_ResetIRQ\r\n")));
; 1434 :     return ERROR_SUCCESS;

  000ec	e3a00000	 mov         r0, #0

; 1435 : }

  000f0	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000f4	e12fff1e	 bx          lr
  000f8		 |$M49162|

			 ENDP  ; |Device_ResetIRQ|


  00000			 AREA	 |.pdata|, PDATA
|$T49173| DCD	|$LN5@Device_Res@2|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Device_ResumeIRQ| PROC

; 1455 : {

  00000		 |$LN5@Device_Res@2|
  00000		 |$M49170|

; 1456 : 	UNREFERENCED_PARAMETER(pHSMUSBContext);
; 1457 : 
; 1458 :     DEBUGMSG(ZONE_FUNCTION, (TEXT("+Device_ResumeIRQ\r\n")));
; 1459 :     return ERROR_SUCCESS;

  00000	e3a00000	 mov         r0, #0

; 1460 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M49171|

			 ENDP  ; |Device_ResumeIRQ|

	EXPORT	|Device_ReadSetup|

  00000			 AREA	 |.pdata|, PDATA
|$T49188| DCD	|$LN7@Device_Rea|
	DCD	0x40001202
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Device_ReadSetup| PROC

; 1480 : {

  00000		 |$LN7@Device_Rea|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M49185|

; 1481 :     PHSMUSB_T pUSBContxt =(PHSMUSB_T) pHSMUSBContext;
; 1482 :     MUsbFnPdd_t *pPdd =((PHSMUSB_T) pHSMUSBContext)->pContext[DEVICE_CONTEXT];
; 1483 :     PCSP_MUSB_GEN_REGS pGenRegs = pUSBContxt->pUsbGenRegs;

  00008	e5904020	 ldr         r4, [r0, #0x20]
  0000c	e5905010	 ldr         r5, [r0, #0x10]

; 1484 :     UINT32 data[2];
; 1485 :     
; 1486 :     DEBUGMSG(ZONE_FUNCTION, (L"Device_ReadSetup\r\n"));
; 1487 :     DEBUGMSG(ZONE_INFO, (L"Power register: 0x%02x\r\n", INREG8(&pGenRegs->Power)));
; 1488 :     
; 1489 :     // Read setup data
; 1490 :     data[0] = INREG32(&pGenRegs->fifo[EP0]);
; 1491 :     data[1] = INREG32(&pGenRegs->fifo[EP0]);
; 1492 :     
; 1493 :     DEBUGMSG(ZONE_INFO, (L"Device_ReadSetup: "
; 1494 :         L"%08x %08x\r\n", data[0], data[1]
; 1495 :         ));
; 1496 :     
; 1497 :     DBGPrtSetupPkt((PVOID)data);
; 1498 :     DEBUGMSG(ZONE_INFO, (TEXT("Device_ReadSetup => Notify\r\n")));
; 1499 :     pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_SETUP_PACKET, (DWORD)data);

  00010	e28d2000	 add         r2, sp, #0
  00014	e5943020	 ldr         r3, [r4, #0x20]
  00018	e3a01004	 mov         r1, #4
  0001c	e58d3000	 str         r3, [sp]
  00020	e5943020	 ldr         r3, [r4, #0x20]
  00024	e58d3004	 str         r3, [sp, #4]
  00028	e5950024	 ldr         r0, [r5, #0x24]
  0002c	e5953028	 ldr         r3, [r5, #0x28]
  00030	e1a0e00f	 mov         lr, pc
  00034	e12fff13	 bx          r3

; 1500 :     
; 1501 :     return ERROR_SUCCESS;

  00038	e3a00000	 mov         r0, #0

; 1502 : }

  0003c	e28dd008	 add         sp, sp, #8
  00040	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$M49186|

			 ENDP  ; |Device_ReadSetup|

	EXPORT	|??_C@_1M@CKAHONI@?$AAB?$AAT?$AAY?$AAP?$AAE?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DM@GBENJPGN@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAB?$AAu?$AAi?$AAl?$AAt?$AAI?$AAn?$AA?2?$AAM?$AAU?$AAS?$AAB?$AAO?$AAT?$AAG?$AA?2?$AAU?$AAS?$AAB?$AAF?$AAN?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|BusChildIoControl|
	IMPORT	|SetEventData|
	IMPORT	|RegCloseKey|
	IMPORT	|RegQueryValueExW|
	IMPORT	|RegOpenKeyExW|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T49249| DCD	|$LN73@Device_Pro|
	DCD	0xc000fe04

  00000			 AREA	 |.pdata|, PDATA
|$T49251| DCD	|$LN43@Device_Pro|
	DCD	0x40000502

  00000			 AREA	 |.pdata|, PDATA
|$T49253| DCD	|$LN50@Device_Pro|
	DCD	0x40000802

  00000			 AREA	 |.xdata|, DATA
|$T49247| DCD	0x2
	DCD	|$LN47@Device_Pro|
	DCD	|$LN48@Device_Pro|
	DCD	|$LN43@Device_Pro|
	DCD	|$LN44@Device_Pro|
	DCD	|$LN54@Device_Pro|
	DCD	|$LN55@Device_Pro|
	DCD	|$LN50@Device_Pro|
	DCD	|$LN51@Device_Pro|

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1M@CKAHONI@?$AAB?$AAT?$AAY?$AAP?$AAE?$AA?$AA@| DCB "B", 0x0, "T", 0x0
	DCB	"Y", 0x0, "P", 0x0, "E", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DM@GBENJPGN@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAB?$AAu?$AAi?$AAl?$AAt?$AAI?$AAn?$AA?2?$AAM?$AAU?$AAS?$AAB?$AAO?$AAT?$AAG?$AA?2?$AAU?$AAS?$AAB?$AAF?$AAN?$AA?$AA@| DCB "D"
	DCB	0x0, "r", 0x0, "i", 0x0, "v", 0x0, "e", 0x0, "r", 0x0, "s"
	DCB	0x0, "\\", 0x0, "B", 0x0, "u", 0x0, "i", 0x0, "l", 0x0, "t"
	DCB	0x0, "I", 0x0, "n", 0x0, "\\", 0x0, "M", 0x0, "U", 0x0, "S"
	DCB	0x0, "B", 0x0, "O", 0x0, "T", 0x0, "G", 0x0, "\\", 0x0, "U"
	DCB	0x0, "S", 0x0, "B", 0x0, "F", 0x0, "N", 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbfn\pdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T49247|

  00008		 |Device_ProcessEP0| PROC

; 1522 : {

  00008		 |$LN73@Device_Pro|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d5ff0	 stmdb       sp!, {r4 - r12, lr}
  00010	e28db028	 add         r11, sp, #0x28
  00014	e24dd020	 sub         sp, sp, #0x20
  00018		 |$LN71@Device_Pro|

; 1523 :     USB_DEVICE_REQUEST* pSetup = NULL;
; 1524 :     PHSMUSB_T pUSBContext =(PHSMUSB_T) pHSMUSBContext;
; 1525 :     PCSP_MUSB_GEN_REGS pGenRegs = pUSBContext->pUsbGenRegs;
; 1526 :     PCSP_MUSB_CSR_REGS pCsrRegs = pUSBContext->pUsbCsrRegs;

  00018	e590401c	 ldr         r4, [r0, #0x1C]

; 1527 :     MUsbFnPdd_t *pPdd = pUSBContext->pContext[DEVICE_CONTEXT];

  0001c	e5905010	 ldr         r5, [r0, #0x10]
  00020	e5901020	 ldr         r1, [r0, #0x20]

; 1528 :     UINT16 csr0Val;
; 1529 :     UINT16 rxcount;
; 1530 :     DWORD data[2];
; 1531 :     
; 1532 :     DEBUGMSG(ZONE_FUNCTION, (L"+Device_ProcessEP0 state = %d\r\n", pPdd->ep0State));
; 1533 : 
; 1534 :     csr0Val = INREG16(&pCsrRegs->ep[EP0].CSR.CSR0);

  00024	e1d420b2	 ldrh        r2, [r4, #2]

; 1535 :     rxcount = INREG16(&pCsrRegs->ep[EP0].Count.Count0);

  00028	e1d490b8	 ldrh        r9, [r4, #8]

; 1536 :     DEBUGMSG(ZONE_INFO, (TEXT("Interrupt receive with CSR0 = 0x%x, rxcount = 0x%x\r\n"), csr0Val, rxcount));
; 1537 :     
; 1538 :     if (csr0Val & CSR0_P_SENTSTALL)

  0002c	e3120004	 tst         r2, #4
  00030	e50b503c	 str         r5, [r11, #-0x3C]

; 1544 :         pPdd->ep0State = EP0_ST_SETUP;

  00034	e3a06000	 mov         r6, #0

; 1539 :     {
; 1540 :         // MUSB finished sending STALL 
; 1541 :         // clear SENTSTALL 
; 1542 :         DEBUGMSG(ZONE_INFO, (TEXT("Stall\r\n")));
; 1543 :         CLRREG16(&pCsrRegs->ep[EP0].CSR.CSR0, CSR0_P_SENTSTALL);

  00038	11d430b2	 ldrneh      r3, [r4, #2]
  0003c	13a02cff	 movne       r2, #0xFF, 24
  00040	138200fb	 orrne       r0, r2, #0xFB

; 1544 :         pPdd->ep0State = EP0_ST_SETUP;

  00044	10033000	 andne       r3, r3, r0
  00048	11c430b2	 strneh      r3, [r4, #2]
  0004c	158563ec	 strne       r6, [r5, #0x3EC]

; 1545 :         csr0Val = INREG16(&pCsrRegs->ep[EP0].CSR.CSR0);

  00050	11d420b2	 ldrneh      r2, [r4, #2]
  00054	03a03cff	 moveq       r3, #0xFF, 24
  00058	038300fb	 orreq       r0, r3, #0xFB

; 1546 :     }
; 1547 :     
; 1548 :     if (csr0Val & CSR0_P_SETUPEND)

  0005c	e3120010	 tst         r2, #0x10
  00060	0a000009	 beq         |$LN38@Device_Pro|

; 1549 :     {
; 1550 :         /* setup request ended "early" */
; 1551 :         // clear SETUPEND 
; 1552 :         DEBUGMSG(ZONE_INFO, (TEXT("SetupEnd\r\n")));
; 1553 :         if (pPdd->bSetAddress)

  00064	e59533f8	 ldr         r3, [r5, #0x3F8]
  00068	e3530000	 cmp         r3, #0

; 1554 :         {
; 1555 :             DEBUGMSG(ZONE_INFO, (L"SetAddress=%d\r\n", pPdd->ucAddress));
; 1556 :             OUTREG8(&pGenRegs->FAddr, pPdd->ucAddress); 

  0006c	15d533f4	 ldrneb      r3, [r5, #0x3F4]
  00070	15c13000	 strneb      r3, [r1]

; 1557 :             pPdd->bSetAddress = FALSE;

  00074	158563f8	 strne       r6, [r5, #0x3F8]

; 1558 :         }
; 1559 :         
; 1560 :         SETREG16(&pCsrRegs->ep[EP0].CSR.CSR0, CSR0_P_SERVICEDSETUPEND);

  00078	e1d430b2	 ldrh        r3, [r4, #2]
  0007c	e3833080	 orr         r3, r3, #0x80
  00080	e1c430b2	 strh        r3, [r4, #2]

; 1561 :         pPdd->ep0State = EP0_ST_SETUP;

  00084	e58563ec	 str         r6, [r5, #0x3EC]

; 1562 :         csr0Val = INREG16(&pCsrRegs->ep[EP0].CSR.CSR0);

  00088	e1d420b2	 ldrh        r2, [r4, #2]
  0008c		 |$LN38@Device_Pro|

; 1563 :         DEBUGMSG(ZONE_INFO, (TEXT("CSR0 = 0x%x\r\n"), csr0Val));
; 1564 :     }
; 1565 :     
; 1566 :     switch (pPdd->ep0State)

  0008c	e59533ec	 ldr         r3, [r5, #0x3EC]
  00090	e3530000	 cmp         r3, #0
  00094	0a000071	 beq         |$LN32@Device_Pro|
  00098	e3530001	 cmp         r3, #1
  0009c	0a0000a3	 beq         |$LN16@Device_Pro|
  000a0	e3530002	 cmp         r3, #2
  000a4	0a000067	 beq         |$LN34@Device_Pro|
  000a8	e3530004	 cmp         r3, #4
  000ac	0a000037	 beq         |$LN15@Device_Pro|
  000b0	e3530005	 cmp         r3, #5
  000b4	0a000008	 beq         |$LN10@Device_Pro|
  000b8	e3530006	 cmp         r3, #6
  000bc	1a0000cb	 bne         |$cleanUp$47645|

; 1773 :                     DEBUGMSG(ZONE_ERROR, (L"Device_ProcessEP0: EP0_ST_DATA_TX"));
; 1774 :                 }
; 1775 :             }
; 1776 :             break;            
; 1777 :             
; 1778 :         case EP0_ST_STATUS_OUT:
; 1779 :             // dummy state in processEP0
; 1780 :             break;
; 1781 :             
; 1782 :         case EP0_ST_ERROR:
; 1783 :             if (csr0Val & CSR0_P_SENTSTALL)

  000c0	e3120004	 tst         r2, #4
  000c4	0a0000c9	 beq         |$cleanUp$47645|

; 1784 :             {
; 1785 :                 DEBUGMSG(ZONE_INFO, (TEXT("ST_ERROR\r\n")));
; 1786 :                 pPdd->ep0State = EP0_ST_SETUP;

  000c8	e58563ec	 str         r6, [r5, #0x3EC]

; 1787 :                 CLRREG16(&pCsrRegs->ep[EP0].CSR.CSR0, CSR0_P_SENTSTALL);

  000cc	e1d430b2	 ldrh        r3, [r4, #2]
  000d0	e0033000	 and         r3, r3, r0
  000d4	e1c430b2	 strh        r3, [r4, #2]

; 1788 :             }
; 1789 :             break;

  000d8	ea0000c4	 b           |$cleanUp$47645|
  000dc		 |$LN10@Device_Pro|

; 1717 :             }
; 1718 :             break;
; 1719 :             
; 1720 :         case EP0_ST_DATA_TX:
; 1721 :             if (csr0Val & CSR0_P_TXPKTRDY)

  000dc	e3120002	 tst         r2, #2
  000e0	1a0000c2	 bne         |$cleanUp$47645|

; 1722 :                 break;
; 1723 :             
; 1724 :             {
; 1725 :                 MUsbFnEp_t *pEP = &pPdd->ep[EP0];
; 1726 :                 STransfer *pTransfer = pEP->pTransfer;

  000e4	e59530cc	 ldr         r3, [r5, #0xCC]
  000e8	e1b07003	 movs        r7, r3
  000ec	e50b7038	 str         r7, [r11, #-0x38]

; 1727 :                 UCHAR *pBuffer;
; 1728 :                 DWORD space, txcount;
; 1729 :                 
; 1730 :                 if (pTransfer == NULL) 

  000f0	0a0000be	 beq         |$cleanUp$47645|
  000f4		 |$LN54@Device_Pro|

; 1731 :                 {
; 1732 :                     DEBUGMSG(ZONE_INFO, (L"Device_ProcessEP0:  error EP0_ST_DATA_TX pTransfer is NULL\r\n"));
; 1733 :                     break;
; 1734 :                 }
; 1735 :                 
; 1736 :                 __try
; 1737 :                 {
; 1738 :                     DWORD dwFlag = 0;
; 1739 :                     pBuffer =(UCHAR*)pTransfer->pvBuffer + pTransfer->cbTransferred;

  000f4	e5972010	 ldr         r2, [r7, #0x10]

; 1740 :                     space = pTransfer->cbBuffer - pTransfer->cbTransferred;

  000f8	e597300c	 ldr         r3, [r7, #0xC]
  000fc	e5971004	 ldr         r1, [r7, #4]

; 1741 :                     
; 1742 :                     
; 1743 :                     // How many bytes we can send just now?
; 1744 :                     txcount = pEP->maxPacketSize;

  00100	e1d58abc	 ldrh        r8, [r5, #0xAC]
  00104	e0433002	 sub         r3, r3, r2

; 1745 :                     if (txcount > space)

  00108	e1580003	 cmp         r8, r3

; 1746 :                         txcount = space;

  0010c	81a08003	 movhi       r8, r3

; 1747 :                     
; 1748 :                     DEBUGMSG(ZONE_INFO, (L"Device_ProcessEP0: EP0_ST_DATA_TX bytes_left_to_send=%d sending=%d\r\n", space, txcount));
; 1749 :                     
; 1750 :                     // Write data to FIFO
; 1751 :                     WriteFIFO(pPdd, EP0, pBuffer, txcount);

  00110	e1a03008	 mov         r3, r8
  00114	e0822001	 add         r2, r2, r1
  00118	e3a01000	 mov         r1, #0
  0011c	e1a00005	 mov         r0, r5
  00120	eb000000	 bl          WriteFIFO

; 1752 :                     
; 1753 :                     // We transfered some data
; 1754 :                     pTransfer->cbTransferred += txcount;

  00124	e5973010	 ldr         r3, [r7, #0x10]

; 1755 :                     dwFlag = CSR0_P_TXPKTRDY;               

  00128	e3a02002	 mov         r2, #2
  0012c	e0833008	 add         r3, r3, r8
  00130	e5873010	 str         r3, [r7, #0x10]

; 1756 :                     
; 1757 :                     if (pTransfer->cbTransferred == pTransfer->cbBuffer)

  00134	e1a01003	 mov         r1, r3
  00138	e597300c	 ldr         r3, [r7, #0xC]
  0013c	e1510003	 cmp         r1, r3
  00140	1a00000a	 bne         |$LN5@Device_Pro|

; 1758 :                     {
; 1759 :                         pPdd->ep0State = EP0_ST_STATUS_OUT;

  00144	e3a03003	 mov         r3, #3
  00148	e58533ec	 str         r3, [r5, #0x3EC]

; 1760 :                         pEP->pTransfer = NULL;

  0014c	e58560cc	 str         r6, [r5, #0xCC]

; 1761 :                         pTransfer->dwUsbError = UFN_NO_ERROR;

  00150	e5876014	 str         r6, [r7, #0x14]

; 1762 :                         pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer);   

  00154	e5950024	 ldr         r0, [r5, #0x24]
  00158	e5953028	 ldr         r3, [r5, #0x28]
  0015c	e1a02007	 mov         r2, r7
  00160	e3a01064	 mov         r1, #0x64
  00164	e1a0e00f	 mov         lr, pc
  00168	e12fff13	 bx          r3

; 1763 :                         DEBUGMSG(ZONE_INFO, (TEXT("Device_Process0: final copy Notify - transfer completed\r\n")));
; 1764 :                         dwFlag |= CSR0_P_DATAEND;

  0016c	e3a0200a	 mov         r2, #0xA
  00170		 |$LN5@Device_Pro|

; 1765 :                     }       
; 1766 :                     
; 1767 :                     DEBUGMSG(ZONE_INFO, (TEXT("2. Device_ProcessEP0 Set TxPktRdy - 0\r\n")));
; 1768 :                     SETREG16(&pCsrRegs->ep[EP0].CSR.CSR0, dwFlag);

  00170	e1d430b2	 ldrh        r3, [r4, #2]
  00174	e1833002	 orr         r3, r3, r2
  00178	e1c430b2	 strh        r3, [r4, #2]
  0017c		 |$LN55@Device_Pro|

; 1769 :                 }

  0017c	ea00009b	 b           |$cleanUp$47645|
  00180		 |$LN51@Device_Pro|

; 1771 :                 {
; 1772 :                     pTransfer->dwUsbError = UFN_CLIENT_BUFFER_ERROR;

  00180	e51b3038	 ldr         r3, [r11, #-0x38]
  00184	e3a02f41	 mov         r2, #0x41, 30
  00188	e5832014	 str         r2, [r3, #0x14]
  0018c	ea000097	 b           |$cleanUp$47645|
  00190		 |$LN15@Device_Pro|

; 1659 :             
; 1660 :         case EP0_ST_DATA_RX:
; 1661 :             if (!(csr0Val & CSR0_P_RXPKTRDY))

  00190	e3120001	 tst         r2, #1
  00194	0a000095	 beq         |$cleanUp$47645|

; 1662 :                 break;
; 1663 :             
; 1664 :             if (pPdd->ep[EP0].pTransfer == NULL) 

  00198	e59530cc	 ldr         r3, [r5, #0xCC]
  0019c	e3530000	 cmp         r3, #0

; 1665 :             {
; 1666 :                 // set intr_rxdata_avail and when IssueTransfer() is called retrieve data
; 1667 :                 //          from FIFO and set CSR0 ServicedRxPkt bit and check for end of packet to set CSR0 DATAEND bit.
; 1668 :                 //          Will need critical section for accessing pTransfer and intr_rx_available
; 1669 :                 pPdd->intr_rx_data_avail |=(1 << EP0);
; 1670 :                 DEBUGMSG(ZONE_INFO, (L"Device_ProcessEP0:  error EP0_ST_DATA_RX pTransfer is NULL\r\n"));
; 1671 :                 break;

  001a0	0a000062	 beq         |$LN16@Device_Pro|

; 1672 :             }
; 1673 :                         
; 1674 :             {
; 1675 :                 MUsbFnEp_t *pEP = &pPdd->ep[EP0];
; 1676 :                 STransfer *pTransfer = pEP->pTransfer;

  001a4	e1a07003	 mov         r7, r3

; 1677 :                 UCHAR *pBuffer;            
; 1678 :                 DWORD space, remain, maxSize;
; 1679 :                 
; 1680 :                 pBuffer =(UCHAR*)pTransfer->pvBuffer + pTransfer->cbTransferred;               
; 1681 :                 space = pTransfer->cbBuffer - pTransfer->cbTransferred;
; 1682 :                 // Get maxPacketSize
; 1683 :                 maxSize = pPdd->ep[EP0].maxPacketSize;

  001a8	e1d5aabc	 ldrh        r10, [r5, #0xAC]
  001ac	e50b7038	 str         r7, [r11, #-0x38]
  001b0	e5972010	 ldr         r2, [r7, #0x10]
  001b4	e5971004	 ldr         r1, [r7, #4]
  001b8		 |$LN47@Device_Pro|

; 1684 :                 
; 1685 :                 __try
; 1686 :                 {
; 1687 :                     USHORT dwFlag = CSR0_P_SERVICEDRXPKTRDY;
; 1688 :                     remain = rxcount;
; 1689 :                     
; 1690 :                     ReadFIFO(pPdd, (UCHAR)EP0, pBuffer, (DWORD)rxcount);

  001b8	e1a03009	 mov         r3, r9
  001bc	e0822001	 add         r2, r2, r1
  001c0	e3a01000	 mov         r1, #0
  001c4	e1a00005	 mov         r0, r5
  001c8	e3a08040	 mov         r8, #0x40
  001cc	eb000000	 bl          ReadFIFO

; 1691 :                     
; 1692 :                     DEBUGMSG(ZONE_INFO, (L"Device_ProcessEP0: EP0_ST_DATA_RX received data\r\n"));                    
; 1693 :                     
; 1694 :                     // We transfered some data
; 1695 :                     pTransfer->cbTransferred += rxcount;

  001d0	e5973010	 ldr         r3, [r7, #0x10]

; 1696 :                     
; 1697 :                     // Is this end of transfer?
; 1698 :                     if (rxcount < maxSize)

  001d4	e159000a	 cmp         r9, r10
  001d8	e0893003	 add         r3, r9, r3
  001dc	e5873010	 str         r3, [r7, #0x10]
  001e0	2a00000a	 bcs         |$LN11@Device_Pro|

; 1699 :                     {
; 1700 :                         // received last block
; 1701 :                         pTransfer->dwUsbError = UFN_NO_ERROR;
; 1702 :                         pPdd->ep0State = EP0_ST_STATUS_IN;

  001e4	e3a03002	 mov         r3, #2
  001e8	e5876014	 str         r6, [r7, #0x14]
  001ec	e58533ec	 str         r3, [r5, #0x3EC]

; 1703 :                         pEP->pTransfer = NULL;

  001f0	e58560cc	 str         r6, [r5, #0xCC]

; 1704 :                         pPdd->pfnNotify(
; 1705 :                             pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer);

  001f4	e5950024	 ldr         r0, [r5, #0x24]
  001f8	e5953028	 ldr         r3, [r5, #0x28]
  001fc	e1a02007	 mov         r2, r7
  00200	e3a01064	 mov         r1, #0x64
  00204	e1a0e00f	 mov         lr, pc
  00208	e12fff13	 bx          r3

; 1706 :                         dwFlag |= CSR0_P_DATAEND;

  0020c	e3a08048	 mov         r8, #0x48
  00210		 |$LN11@Device_Pro|

; 1707 :                     }
; 1708 :                     SETREG16(&pCsrRegs->ep[EP0].CSR.CSR0, dwFlag);

  00210	e1d430b2	 ldrh        r3, [r4, #2]
  00214	e1833008	 orr         r3, r3, r8
  00218	e1c430b2	 strh        r3, [r4, #2]
  0021c		 |$LN48@Device_Pro|

; 1709 :                 }

  0021c	ea000003	 b           |$LN49@Device_Pro|
  00220		 |$LN44@Device_Pro|

; 1711 :                 {
; 1712 :                     pTransfer->dwUsbError = UFN_CLIENT_BUFFER_ERROR;

  00220	e51b3038	 ldr         r3, [r11, #-0x38]
  00224	e3a02f41	 mov         r2, #0x41, 30
  00228	e5832014	 str         r2, [r3, #0x14]
  0022c	e51b503c	 ldr         r5, [r11, #-0x3C]
  00230		 |$LN49@Device_Pro|

; 1713 :                 }
; 1714 :                 
; 1715 :                 // clear intr_rx_data_avail EP0 bit
; 1716 :                 pPdd->intr_rx_data_avail &= ~(1 << EP0);            

  00230	e59533f0	 ldr         r3, [r5, #0x3F0]
  00234	e3c33001	 bic         r3, r3, #1

; 1654 :             break;
; 1655 :             
; 1656 :         case EP0_ST_SETUP_PROCESSED:
; 1657 :             pPdd->intr_rx_data_avail |=(1 << EP0);

  00238	e58533f0	 str         r3, [r5, #0x3F0]

; 1658 :             break;

  0023c	ea00006b	 b           |$cleanUp$47645|
  00240		 |$LN67@Device_Pro|

; 1790 :             
; 1791 :         default:
; 1792 :             break;
; 1793 :         }
; 1794 : cleanUp:                
; 1795 :         prtEP0State(pPdd);
; 1796 :         DEBUGMSG(ZONE_FUNCTION, (L"-Device_ProcessEP0\r\n"));
; 1797 :         
; 1798 :         return ERROR_SUCCESS;

  00240	e51b0034	 ldr         r0, [r11, #-0x34]
  00244	ea00006a	 b           |$LN40@Device_Pro|
  00248		 |$LN34@Device_Pro|

; 1567 :     {
; 1568 :         case EP0_ST_STATUS_IN:
; 1569 :             // dummy state in processEP0
; 1570 :             if (pPdd->bSetAddress)

  00248	e59533f8	 ldr         r3, [r5, #0x3F8]
  0024c	e3530000	 cmp         r3, #0

; 1571 :             {
; 1572 :                 DEBUGMSG(ZONE_INFO, (L"SetAddress=%d\r\n", pPdd->ucAddress));
; 1573 :                 OUTREG8(&pGenRegs->FAddr, pPdd->ucAddress); 

  00250	15d533f4	 ldrneb      r3, [r5, #0x3F4]
  00254	15c13000	 strneb      r3, [r1]

; 1574 :                 pPdd->bSetAddress = FALSE;

  00258	158563f8	 strne       r6, [r5, #0x3F8]

; 1575 :             }
; 1576 :             pPdd->ep0State = EP0_ST_SETUP;

  0025c	e58563ec	 str         r6, [r5, #0x3EC]
  00260		 |$LN32@Device_Pro|

; 1577 :             DEBUGMSG(ZONE_INFO, (TEXT("In EP0 Status IN state.  Change to EP0 SETUP state.\r\n")));
; 1578 :             
; 1579 :             // if received packet while in EP0_ST_STATUS_IN, continue process SETUP packet.
; 1580 :             
; 1581 :             
; 1582 :         case EP0_ST_SETUP:
; 1583 :             if (rxcount < 8)

  00260	e3590008	 cmp         r9, #8
  00264	3a000061	 bcc         |$cleanUp$47645|

; 1584 :                 break;
; 1585 :             if (!(csr0Val & CSR0_P_RXPKTRDY))

  00268	e3120001	 tst         r2, #1
  0026c	0a00005f	 beq         |$cleanUp$47645|

; 1586 :                 break;        
; 1587 :             data[0] = INREG32(&pGenRegs->fifo[EP0]);

  00270	e5913020	 ldr         r3, [r1, #0x20]
  00274	e50b3030	 str         r3, [r11, #-0x30]

; 1588 :             data[1] = INREG32(&pGenRegs->fifo[EP0]);        

  00278	e5913020	 ldr         r3, [r1, #0x20]

; 1589 :             DEBUGMSG(ZONE_INFO, (L"EP0_ST_SETUP receives 0x%x 0x%x\r\n", data[0], data[1]));
; 1590 :             pSetup =(USB_DEVICE_REQUEST*)data;
; 1591 :             if ((pSetup->bmRequestType == 0) &&
; 1592 :                     (pSetup->bRequest == USB_REQUEST_SET_CONFIGURATION)){

  0027c	e55b2030	 ldrb        r2, [r11, #-0x30]
  00280	e50b302c	 str         r3, [r11, #-0x2C]
  00284	e3520000	 cmp         r2, #0
  00288	e55b302f	 ldrb        r3, [r11, #-0x2F]
  0028c	1a000034	 bne         |$LN29@Device_Pro|
  00290	e3530009	 cmp         r3, #9
  00294	1a000032	 bne         |$LN29@Device_Pro|

; 1593 :                 HKEY hkDevice;
; 1594 :                 DWORD dwStatus;
; 1595 :                 DWORD dwType, dwSize;
; 1596 :                 DWORD dwbTypeConnector = 0;
; 1597 : 
; 1598 :                 DEBUGMSG(ZONE_INFO, (L"EP0_ST_SETUP receives USB_REQUEST_SET_CONFIGURATION"));
; 1599 : 
; 1600 :                 dwStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCTSTR) REG_USBFN_DRV_PATH, 0, KEY_ALL_ACCESS, &hkDevice);

  00298	e59f1190	 ldr         r1, [pc, #0x190]
  0029c	e3a0380f	 mov         r3, #0xF, 16
  002a0	e3a04000	 mov         r4, #0
  002a4	e24be040	 sub         lr, r11, #0x40
  002a8	e383303f	 orr         r3, r3, #0x3F
  002ac	e3a02000	 mov         r2, #0
  002b0	e3a0010a	 mov         r0, #0xA, 2
  002b4	e50b4038	 str         r4, [r11, #-0x38]
  002b8	e58de000	 str         lr, [sp]
  002bc	eb000000	 bl          RegOpenKeyExW
  002c0	e3500000	 cmp         r0, #0

; 1601 :                 if(dwStatus != ERROR_SUCCESS) {

  002c4	1a000049	 bne         |$cleanUp$47645|

; 1602 :                        DEBUGMSG(ZONE_WARNING, (_T("UfnPdd_Init: OpenDeviceKey('%s') failed %u\r\n"), REG_USBFN_DRV_PATH, dwStatus));
; 1603 :                        goto cleanUp;
; 1604 :                 }
; 1605 : 
; 1606 :                 dwType = REG_DWORD;
; 1607 :                 dwSize = sizeof(dwbTypeConnector);
; 1608 :                 dwStatus = RegQueryValueEx(hkDevice, REG_VBUS_CHARGE_B_TYPE_CONNECTOR, NULL, &dwType, 
; 1609 :                           (LPBYTE) &dwbTypeConnector, &dwSize);

  002c8	e59f115c	 ldr         r1, [pc, #0x15C]
  002cc	e51b0040	 ldr         r0, [r11, #-0x40]
  002d0	e3a06004	 mov         r6, #4
  002d4	e3a07004	 mov         r7, #4
  002d8	e24be034	 sub         lr, r11, #0x34
  002dc	e24b4038	 sub         r4, r11, #0x38
  002e0	e24b303c	 sub         r3, r11, #0x3C
  002e4	e3a02000	 mov         r2, #0
  002e8	e50b603c	 str         r6, [r11, #-0x3C]
  002ec	e50b7034	 str         r7, [r11, #-0x34]
  002f0	e58de004	 str         lr, [sp, #4]
  002f4	e58d4000	 str         r4, [sp]
  002f8	eb000000	 bl          RegQueryValueExW
  002fc	e3500000	 cmp         r0, #0

; 1610 : 
; 1611 :                 if(dwStatus != ERROR_SUCCESS || dwType != REG_DWORD) {

  00300	1a000014	 bne         |$LN26@Device_Pro|
  00304	e51b303c	 ldr         r3, [r11, #-0x3C]
  00308	e3530004	 cmp         r3, #4
  0030c	1a000011	 bne         |$LN26@Device_Pro|

; 1616 :                 }
; 1617 : 
; 1618 :                 RegCloseKey(hkDevice);

  00310	e51b0040	 ldr         r0, [r11, #-0x40]
  00314	eb000000	 bl          RegCloseKey

; 1619 : 
; 1620 :                 if(dwbTypeConnector){

  00318	e51b3038	 ldr         r3, [r11, #-0x38]
  0031c	e3530000	 cmp         r3, #0

; 1621 :                     SetEventData( pPdd->hVbusChargeEvent, BATTERY_USBHOST_CONNECT );

  00320	e5950428	 ldr         r0, [r5, #0x428]

; 1619 : 
; 1620 :                 if(dwbTypeConnector){

  00324	0a000005	 beq         |$LN25@Device_Pro|

; 1621 :                     SetEventData( pPdd->hVbusChargeEvent, BATTERY_USBHOST_CONNECT );

  00328	e3a01001	 mov         r1, #1

; 1622 :                     SetEvent( pPdd->hVbusChargeEvent );
; 1623 :                     DEBUGMSG(ZONE_PDD, (_T("UFNPDD_Init: B-Type connector\r\n")));
; 1624 :                 }else{

  0032c	ea000004	 b           |$LN69@Device_Pro|
  00330		 |$LN16@Device_Pro|

; 1654 :             break;
; 1655 :             
; 1656 :         case EP0_ST_SETUP_PROCESSED:
; 1657 :             pPdd->intr_rx_data_avail |=(1 << EP0);

  00330	e59533f0	 ldr         r3, [r5, #0x3F0]
  00334	e3833001	 orr         r3, r3, #1
  00338	e58533f0	 str         r3, [r5, #0x3F0]

; 1658 :             break;

  0033c	ea00002b	 b           |$cleanUp$47645|
  00340		 |$LN25@Device_Pro|

; 1625 :                     SetEventData( pPdd->hVbusChargeEvent,  BATTERY_USBHOST_DISCONNECT );  

  00340	e3a01000	 mov         r1, #0
  00344		 |$LN69@Device_Pro|
  00344	eb000000	 bl          SetEventData

; 1626 :                     SetEvent( pPdd->hVbusChargeEvent );

  00348	e5950428	 ldr         r0, [r5, #0x428]
  0034c	e3a01003	 mov         r1, #3
  00350	eb000000	 bl          EventModify

; 1627 :                     DEBUGMSG(ZONE_PDD, (_T("UFNPDD_Init: Not an B-Type connector\r\n")));
; 1628 :                 }
; 1629 :             }
; 1630 :             else if ((pSetup->bmRequestType == (USB_REQUEST_HOST_TO_DEVICE | USB_REQUEST_STANDARD | USB_REQUEST_FOR_DEVICE)) &&

  00354	ea00001d	 b           |$LN20@Device_Pro|
  00358		 |$LN26@Device_Pro|

; 1612 :                     DEBUGMSG(ZONE_WARNING, (_T("UFNPDD_Init: RegQueryValueEx('%s', '%s') failed %u\r\n"),
; 1613 :                             REG_USBFN_DRV_PATH, REG_VBUS_CHARGE_B_TYPE_CONNECTOR, dwStatus));
; 1614 :                     RegCloseKey(hkDevice);

  00358	e51b0040	 ldr         r0, [r11, #-0x40]
  0035c	eb000000	 bl          RegCloseKey

; 1615 :                     goto cleanUp;

  00360	ea000022	 b           |$cleanUp$47645|
  00364		 |$LN29@Device_Pro|

; 1631 :                     (pSetup->bRequest == USB_REQUEST_SET_FEATURE))

  00364	e3520000	 cmp         r2, #0
  00368	1a000018	 bne         |$LN20@Device_Pro|
  0036c	e3530003	 cmp         r3, #3
  00370	1a000016	 bne         |$LN20@Device_Pro|

; 1632 :             {
; 1633 :                 //Host Negotiation Protocol is enabled
; 1634 :                 switch(pSetup->wValue)

  00374	e15b32be	 ldrh        r3, [r11, #-0x2E]
  00378	e3530003	 cmp         r3, #3
  0037c	0a00000b	 beq         |$LN19@Device_Pro|
  00380	e3530004	 cmp         r3, #4
  00384	0a000005	 beq         |$LN18@Device_Pro|
  00388	e3530005	 cmp         r3, #5
  0038c	1a00000f	 bne         |$LN20@Device_Pro|

; 1644 : 
; 1645 :                     case USB_FEATURE_A_ALT_HNP_SUPPORT:
; 1646 :                         pPdd->devState |= MUSB_DEVSTAT_A_ALT_HNP_SUPPORT;

  00390	e595306c	 ldr         r3, [r5, #0x6C]
  00394	e3833080	 orr         r3, r3, #0x80

; 1639 :                         break;
; 1640 : 
; 1641 :                     case USB_FEATURE_A_HNP_SUPPORT:
; 1642 :                         pPdd->devState |= MUSB_DEVSTAT_A_HNP_SUPPORT;

  00398	e585306c	 str         r3, [r5, #0x6C]

; 1643 :                         break;

  0039c	ea00000b	 b           |$LN20@Device_Pro|
  003a0		 |$LN18@Device_Pro|

; 1639 :                         break;
; 1640 : 
; 1641 :                     case USB_FEATURE_A_HNP_SUPPORT:
; 1642 :                         pPdd->devState |= MUSB_DEVSTAT_A_HNP_SUPPORT;

  003a0	e595306c	 ldr         r3, [r5, #0x6C]
  003a4	e3833c01	 orr         r3, r3, #1, 24
  003a8	e585306c	 str         r3, [r5, #0x6C]

; 1643 :                         break;

  003ac	ea000007	 b           |$LN20@Device_Pro|
  003b0		 |$LN19@Device_Pro|

; 1635 :                 {
; 1636 :                     case USB_FEATURE_B_HNP_ENABLE:
; 1637 :                         pPdd->devState |= MUSB_DEVSTAT_B_HNP_ENABLE;

  003b0	e595306c	 ldr         r3, [r5, #0x6C]

; 1638 :                         BusChildIoControl(pPdd->hParentBus,IOCTL_BUS_USBOTG_HNP_ENABLE,NULL,0);

  003b4	e59f106c	 ldr         r1, [pc, #0x6C]
  003b8	e5950030	 ldr         r0, [r5, #0x30]
  003bc	e3833c02	 orr         r3, r3, #2, 24
  003c0	e585306c	 str         r3, [r5, #0x6C]
  003c4	e3a03000	 mov         r3, #0
  003c8	e3a02000	 mov         r2, #0
  003cc	eb000000	 bl          BusChildIoControl
  003d0		 |$LN20@Device_Pro|

; 1647 :                         break;
; 1648 :                     }
; 1649 :             }
; 1650 : 
; 1651 :             pPdd->ep0State = EP0_ST_SETUP_PROCESSED;
; 1652 : 
; 1653 :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_SETUP_PACKET, (DWORD)data);        

  003d0	e5950024	 ldr         r0, [r5, #0x24]
  003d4	e5953028	 ldr         r3, [r5, #0x28]
  003d8	e3a04001	 mov         r4, #1
  003dc	e24b2030	 sub         r2, r11, #0x30
  003e0	e3a01004	 mov         r1, #4
  003e4	e58543ec	 str         r4, [r5, #0x3EC]
  003e8	e1a0e00f	 mov         lr, pc
  003ec	e12fff13	 bx          r3
  003f0		 |$cleanUp$47645|

; 1790 :             
; 1791 :         default:
; 1792 :             break;
; 1793 :         }
; 1794 : cleanUp:                
; 1795 :         prtEP0State(pPdd);
; 1796 :         DEBUGMSG(ZONE_FUNCTION, (L"-Device_ProcessEP0\r\n"));
; 1797 :         
; 1798 :         return ERROR_SUCCESS;

  003f0	e3a00000	 mov         r0, #0
  003f4		 |$LN40@Device_Pro|

; 1799 : }

  003f4	e24bd028	 sub         sp, r11, #0x28
  003f8	e89d6ff0	 ldmia       sp, {r4 - r11, sp, lr}
  003fc	e12fff1e	 bx          lr

			 ENDP  ; |Device_ProcessEP0|

  00400		 |$LN43@Device_Pro|
  00400		 |$LN72@Device_Pro|

; 1710 :                 __except(EXCEPTION_EXECUTE_HANDLER)

  00400	e52de004	 str         lr, [sp, #-4]!
  00404	e24dd008	 sub         sp, sp, #8
  00408		 |$LN46@Device_Pro|
  00408		 |$LN76@Device_Pro|
  00408	e3a00001	 mov         r0, #1
  0040c		 |$LN45@Device_Pro|
  0040c	e28dd008	 add         sp, sp, #8
  00410	e49df004	 ldr         pc, [sp], #4
  00414		 |$LN77@Device_Pro|
  00414		 |$LN50@Device_Pro|
  00414		 |$LN74@Device_Pro|

; 1770 :                 __except(EXCEPTION_EXECUTE_HANDLER)

  00414	e52de004	 str         lr, [sp, #-4]!
  00418	e24dd008	 sub         sp, sp, #8
  0041c		 |$LN53@Device_Pro|
  0041c		 |$LN78@Device_Pro|
  0041c	e3a00001	 mov         r0, #1
  00420		 |$LN52@Device_Pro|
  00420	e28dd008	 add         sp, sp, #8
  00424	e49df004	 ldr         pc, [sp], #4
  00428		 |$LN80@Device_Pro|
  00428		 |$LN81@Device_Pro|
  00428	002a0414	 DCD         0x2a0414
  0042c		 |$LN82@Device_Pro|
  0042c	00000000	 DCD         |??_C@_1M@CKAHONI@?$AAB?$AAT?$AAY?$AAP?$AAE?$AA?$AA@|
  00430		 |$LN83@Device_Pro|
  00430	00000000	 DCD         |??_C@_1DM@GBENJPGN@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAB?$AAu?$AAi?$AAl?$AAt?$AAI?$AAn?$AA?2?$AAM?$AAU?$AAS?$AAB?$AAO?$AAT?$AAG?$AA?2?$AAU?$AAS?$AAB?$AAF?$AAN?$AA?$AA@|
  00434		 |$LN79@Device_Pro|
  00434		 |$LN75@Device_Pro|

  00000			 AREA	 |.pdata|, PDATA
|$T49300| DCD	|$LN44@Device_Pro@2|
	DCD	0xc000dd04

  00000			 AREA	 |.pdata|, PDATA
|$T49302| DCD	|$LN28@Device_Pro@2|
	DCD	0x40000301

  00000			 AREA	 |.xdata|, DATA
|$T49298| DCD	0x1
	DCD	|$LN32@Device_Pro@2|
	DCD	|$LN33@Device_Pro@2|
	DCD	|$LN28@Device_Pro@2|
	DCD	|$LN29@Device_Pro@2|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T49298|

  00008		 |Device_ProcessEPx_RX| PROC

; 1823 : {

  00008		 |$LN44@Device_Pro@2|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d5ff0	 stmdb       sp!, {r4 - r12, lr}
  00010	e28db028	 add         r11, sp, #0x28
  00014	e24dd010	 sub         sp, sp, #0x10
  00018		 |$LN42@Device_Pro@2|
  00018	e1a08001	 mov         r8, r1
  0001c	e1a03000	 mov         r3, r0
  00020	e50b3038	 str         r3, [r11, #-0x38]

; 1824 :     DWORD rc = ERROR_SUCCESS;
; 1825 :     PHSMUSB_T pUSBContext =(PHSMUSB_T) pHSMUSBContext;
; 1826 :     PCSP_MUSB_CSR_REGS pCsrRegs = pUSBContext->pUsbCsrRegs;
; 1827 :     MUsbFnPdd_t *pPdd = pUSBContext->pContext[DEVICE_CONTEXT];

  00024	e5934010	 ldr         r4, [r3, #0x10]
  00028	e593301c	 ldr         r3, [r3, #0x1C]

; 1828 :     UINT16 csrVal;
; 1829 :     MUsbFnEp_t *pEP = &pPdd->ep[endpoint];

  0002c	e3a02034	 mov         r2, #0x34
  00030	e0264298	 mla         r6, r8, r2, r4

; 1830 :     UINT16 rxcount;
; 1831 :     STransfer *pTransfer = pEP->pTransfer;
; 1832 :     
; 1833 :     DEBUGMSG(ZONE_FUNCTION, (L"+Device_ProcessEPx_RX: endpoint=%d\r\n", endpoint));
; 1834 :     csrVal = INREG16(&pCsrRegs->ep[endpoint].RxCSR);

  00034	e083a208	 add         r10, r3, r8, lsl #4
  00038	e59650cc	 ldr         r5, [r6, #0xCC]
  0003c	e1da30b6	 ldrh        r3, [r10, #6]

; 1835 :     rxcount = INREG16(&pCsrRegs->ep[endpoint].Count.RxCount);

  00040	e50b502c	 str         r5, [r11, #-0x2C]
  00044	e1da70b8	 ldrh        r7, [r10, #8]

; 1836 : 
; 1837 :     
; 1838 :     if (csrVal & RXCSR_P_SENTSTALL)

  00048	e3130040	 tst         r3, #0x40

; 1839 :     {
; 1840 :         // MUSB finished sending STALL 
; 1841 :         // clear SENTSTALL 
; 1842 :         DEBUGMSG(1, (TEXT("Stall\r\n")));
; 1843 :         if (pEP != NULL)
; 1844 :            pEP->stalled = FALSE;

  0004c	e3a09000	 mov         r9, #0
  00050	158690c0	 strne       r9, [r6, #0xC0]

; 1845 :         CLRREG16(&pCsrRegs->ep[endpoint].RxCSR, RXCSR_P_SENTSTALL);

  00054	11da20b6	 ldrneh      r2, [r10, #6]
  00058	13a03cff	 movne       r3, #0xFF, 24
  0005c	138330bf	 orrne       r3, r3, #0xBF
  00060	10023003	 andne       r3, r2, r3
  00064	11ca30b6	 strneh      r3, [r10, #6]

; 1846 :         csrVal = INREG16(&pCsrRegs->ep[endpoint].RxCSR);

  00068	11da30b6	 ldrneh      r3, [r10, #6]

; 1847 :     }
; 1848 :     
; 1849 :     if (csrVal & RXCSR_P_OVERRUN)

  0006c	e3130004	 tst         r3, #4
  00070	0a000015	 beq         |$LN22@Device_Pro@2|

; 1850 :     {
; 1851 :         // clear OVERRUN 
; 1852 :         DEBUGMSG(ZONE_ERROR, (TEXT("Overrun\r\n")));
; 1853 :         CLRREG16(&pCsrRegs->ep[endpoint].RxCSR, RXCSR_P_OVERRUN);

  00074	e1da10b6	 ldrh        r1, [r10, #6]
  00078	e3a03cff	 mov         r3, #0xFF, 24
  0007c	e38330fb	 orr         r3, r3, #0xFB
  00080	e0013003	 and         r3, r1, r3
  00084	e1ca30b6	 strh        r3, [r10, #6]

; 1854 :         if (pTransfer != NULL)

  00088	e3550000	 cmp         r5, #0
  0008c	0a000008	 beq         |$LN21@Device_Pro@2|

; 1855 :         {
; 1856 :            pTransfer->dwUsbError = UFN_CLIENT_BUFFER_ERROR;

  00090	e3a03f41	 mov         r3, #0x41, 30
  00094	e5853014	 str         r3, [r5, #0x14]

; 1857 :            pEP->pTransfer = NULL;

  00098	e58690cc	 str         r9, [r6, #0xCC]

; 1858 :            pPdd->pfnNotify(
; 1859 :                pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer);

  0009c	e5940024	 ldr         r0, [r4, #0x24]
  000a0	e5943028	 ldr         r3, [r4, #0x28]
  000a4	e1a02005	 mov         r2, r5
  000a8	e3a01064	 mov         r1, #0x64
  000ac	e1a0e00f	 mov         lr, pc
  000b0	e12fff13	 bx          r3
  000b4		 |$LN21@Device_Pro@2|

; 1860 :         }
; 1861 : 
; 1862 :         pPdd->intr_rx_data_avail &=(1 << endpoint);

  000b4	e59433f0	 ldr         r3, [r4, #0x3F0]
  000b8	e3a02001	 mov         r2, #1

; 1863 :         return ERROR_SUCCESS;

  000bc	e0033812	 and         r3, r3, r2, lsl r8
  000c0		 |$LN41@Device_Pro@2|
  000c0	e3a00000	 mov         r0, #0
  000c4	e58433f0	 str         r3, [r4, #0x3F0]
  000c8	ea0000a8	 b           |$LN25@Device_Pro@2|
  000cc		 |$LN22@Device_Pro@2|

; 1864 :     }
; 1865 :     
; 1866 :     if (!(csrVal & RXCSR_P_RXPKTRDY))

  000cc	e3130001	 tst         r3, #1
  000d0	1a000001	 bne         |$LN20@Device_Pro@2|
  000d4		 |$LN34@Device_Pro@2|
  000d4		 |$cleanUp$47773|

; 1867 :     {
; 1868 :         return ERROR_SUCCESS;

  000d4	e3a00000	 mov         r0, #0
  000d8	ea0000a4	 b           |$LN25@Device_Pro@2|
  000dc		 |$LN20@Device_Pro@2|

; 1869 :     }
; 1870 :     
; 1871 :     if (pTransfer == NULL) 

  000dc	e3550000	 cmp         r5, #0

; 1872 :     {
; 1873 :         DEBUGMSG(ZONE_ERROR, (L"!!! Device_ProcessEPx_RX:  pTransfer is NULL\r\n"));
; 1874 :         pPdd->intr_rx_data_avail |= (1 << endpoint);

  000e0	059433f0	 ldreq       r3, [r4, #0x3F0]
  000e4	03a02001	 moveq       r2, #1

; 1875 :         return ERROR_SUCCESS;

  000e8	01833812	 orreq       r3, r3, r2, lsl r8

; 1869 :     }
; 1870 :     
; 1871 :     if (pTransfer == NULL) 

  000ec	0afffff3	 beq         |$LN41@Device_Pro@2|

; 1876 :     }
; 1877 : 
; 1878 :     if (rxcount > pPdd->ep[endpoint].maxPacketSize)

  000f0	e1d63abc	 ldrh        r3, [r6, #0xAC]
  000f4	e1570003	 cmp         r7, r3

; 1879 :     {
; 1880 :         rxcount = 0;

  000f8	83a07000	 movhi       r7, #0
  000fc		 |$LN32@Device_Pro@2|

; 1881 :     }
; 1882 : 
; 1883 :     __try
; 1884 :     {
; 1885 :         UCHAR *pBuffer;
; 1886 : 
; 1887 :         if ((pPdd->ep[endpoint].dmaEnabled) &&
; 1888 :             ((pTransfer->cbBuffer - pTransfer->cbTransferred) > pEP->maxPacketSize) &&
; 1889 :             pPdd->bRXIsUsingUsbDMA)

  000fc	e59630bc	 ldr         r3, [r6, #0xBC]
  00100	e3530000	 cmp         r3, #0
  00104	0a000054	 beq         |$PROCESS_FIFO$47776|
  00108	e5951010	 ldr         r1, [r5, #0x10]
  0010c	e50b1034	 str         r1, [r11, #-0x34]
  00110	e595300c	 ldr         r3, [r5, #0xC]
  00114	e1d62abc	 ldrh        r2, [r6, #0xAC]
  00118	e0433001	 sub         r3, r3, r1
  0011c	e1530002	 cmp         r3, r2
  00120	9a00004d	 bls         |$PROCESS_FIFO$47776|
  00124	e5943438	 ldr         r3, [r4, #0x438]
  00128	e3530000	 cmp         r3, #0
  0012c	0a00004a	 beq         |$PROCESS_FIFO$47776|

; 1890 :         {
; 1891 :             UCHAR channel = MUSB_RX_DMA_CHN;
; 1892 :             DWORD size;
; 1893 : 
; 1894 :             pBuffer =(UCHAR*)pTransfer->pvBuffer + pTransfer->cbTransferred;

  00130	e5953004	 ldr         r3, [r5, #4]
  00134	e50b3030	 str         r3, [r11, #-0x30]

; 1895 :             EnterCriticalSection(&pPdd->dmaCS);

  00138	e2840034	 add         r0, r4, #0x34
  0013c	eb000000	 bl          EnterCriticalSection

; 1896 :             if (INREG32(&pUSBContext->pUsbDmaRegs->dma[channel].Addr) == 0x00)

  00140	e51b2038	 ldr         r2, [r11, #-0x38]
  00144	e5923024	 ldr         r3, [r2, #0x24]
  00148	e2832010	 add         r2, r3, #0x10
  0014c	e5923008	 ldr         r3, [r2, #8]
  00150	e3530000	 cmp         r3, #0

; 1903 :                     LeaveCriticalSection(&pPdd->dmaCS);

  00154	e2840034	 add         r0, r4, #0x34

; 1896 :             if (INREG32(&pUSBContext->pUsbDmaRegs->dma[channel].Addr) == 0x00)

  00158	1a000008	 bne         |$LN13@Device_Pro@2|

; 1897 :             {
; 1898 :                 if (pPdd->rx0DmaState == MODE_DMA)

  0015c	e594301c	 ldr         r3, [r4, #0x1C]
  00160	e3530000	 cmp         r3, #0
  00164	1a00003b	 bne         |$LN14@Device_Pro@2|

; 1899 :                 {
; 1900 :                     DEBUGMSG(ZONE_INFO, (L"EP %d for channel %d not setup yet\r\n", endpoint, channel));
; 1901 :                     size = 0;
; 1902 :                     pPdd->intr_rx_data_avail |= (1 << endpoint);

  00168	e59433f0	 ldr         r3, [r4, #0x3F0]
  0016c	e3a02001	 mov         r2, #1

; 1903 :                     LeaveCriticalSection(&pPdd->dmaCS);

  00170	e1833812	 orr         r3, r3, r2, lsl r8
  00174	e58433f0	 str         r3, [r4, #0x3F0]
  00178	eb000000	 bl          LeaveCriticalSection

; 1904 :                     goto cleanUp;

  0017c	eaffffd4	 b           |$LN34@Device_Pro@2|
  00180		 |$LN13@Device_Pro@2|

; 1905 :                 }
; 1906 :                 else
; 1907 :                 {
; 1908 :                     DEBUGMSG(ZONE_DVFS, (TEXT("Process FIFO even though size larger than maxpacket size (rxcount[%d])\r\n"),
; 1909 :                         rxcount));
; 1910 :                     LeaveCriticalSection(&pPdd->dmaCS);
; 1911 :                     goto PROCESS_FIFO;
; 1912 :                 }
; 1913 :             }
; 1914 : 
; 1915 :             size = pEP->dwRxDMASize - INREG32(&pUSBContext->pUsbDmaRegs->dma[channel].Count);

  00180	e592200c	 ldr         r2, [r2, #0xC]
  00184	e59630d0	 ldr         r3, [r6, #0xD0]

; 1916 : 
; 1917 :             LeaveCriticalSection(&pPdd->dmaCS);

  00188	e0433002	 sub         r3, r3, r2
  0018c	e50b3038	 str         r3, [r11, #-0x38]
  00190	eb000000	 bl          LeaveCriticalSection

; 1918 : 
; 1919 :             DEBUGMSG(ZONE_FUNCTION, (L"Device_ProcessEPx_Rx:RXDMA count:%d,start(0x%x),cur(0x%x),pvBuffer(0x%x),cbTransferred(%d),cbBuffer(%d),pBuffer(0x%x)\r\n",
; 1920 :                 size, pPdd->paDmaRx0Buffer, INREG32(&pUSBContext->pUsbDmaRegs->dma[channel].Addr), pTransfer->pvBuffer, pTransfer->cbTransferred, pTransfer->cbBuffer, pBuffer));
; 1921 : 
; 1922 : 
; 1923 :             if ((pTransfer->cbTransferred + size + rxcount) < pEP->maxPacketSize)

  00194	e5952010	 ldr         r2, [r5, #0x10]
  00198	e1d61abc	 ldrh        r1, [r6, #0xAC]
  0019c	e51b3038	 ldr         r3, [r11, #-0x38]
  001a0	e0873003	 add         r3, r7, r3
  001a4	e0833002	 add         r3, r3, r2
  001a8	e1530001	 cmp         r3, r1
  001ac	2a000009	 bcs         |$LN12@Device_Pro@2|

; 1924 :             {
; 1925 :                 CLRREG16(&pCsrRegs->ep[endpoint].RxCSR, RXCSR_P_AUTOCLEAR | RXCSR_P_DMAREQENAB | RXCSR_P_DMAREQMODE);

  001b0	e1da20b6	 ldrh        r2, [r10, #6]
  001b4	e3a03c57	 mov         r3, #0x57, 24
  001b8	e38330ff	 orr         r3, r3, #0xFF
  001bc	e0023003	 and         r3, r2, r3
  001c0	e1ca30b6	 strh        r3, [r10, #6]

; 1926 : 
; 1927 :                 EnterCriticalSection(&pPdd->dmaCS);

  001c4	e2840034	 add         r0, r4, #0x34
  001c8	eb000000	 bl          EnterCriticalSection

; 1928 :                 pPdd->bDMAForRX = FALSE;
; 1929 :                 LeaveCriticalSection(&pPdd->dmaCS);

  001cc	e2840034	 add         r0, r4, #0x34
  001d0	e5849430	 str         r9, [r4, #0x430]
  001d4	eb000000	 bl          LeaveCriticalSection
  001d8		 |$LN12@Device_Pro@2|

; 1930 :             }
; 1931 : 
; 1932 :             if ((size > 0) && (pTransfer->dwBufferPhysicalAddress == 0))

  001d8	e51ba038	 ldr         r10, [r11, #-0x38]
  001dc	e35a0000	 cmp         r10, #0
  001e0	0a000007	 beq         |$LN11@Device_Pro@2|
  001e4	e5953008	 ldr         r3, [r5, #8]
  001e8	e3530000	 cmp         r3, #0

; 1933 :                 memcpy(pBuffer, pPdd->pDmaRx0Buffer , size);

  001ec	05941048	 ldreq       r1, [r4, #0x48]
  001f0	01a0200a	 moveq       r2, r10
  001f4	051b3034	 ldreq       r3, [r11, #-0x34]
  001f8	051b0030	 ldreq       r0, [r11, #-0x30]
  001fc	00830000	 addeq       r0, r3, r0
  00200	0b000000	 bleq        memcpy
  00204		 |$LN11@Device_Pro@2|

; 1934 : 
; 1935 :             // Update buffer and clear zero length flag
; 1936 :             pTransfer->cbTransferred += size;

  00204	e5953010	 ldr         r3, [r5, #0x10]

; 1937 : 
; 1938 :             ResetDMAChannel(pPdd, channel);

  00208	e3a01001	 mov         r1, #1
  0020c	e1a00004	 mov         r0, r4
  00210	e08a3003	 add         r3, r10, r3
  00214	e5853010	 str         r3, [r5, #0x10]
  00218	eb000000	 bl          ResetDMAChannel

; 1939 :             EnterCriticalSection(&pPdd->csDVFS);

  0021c	e284ab01	 add         r10, r4, #1, 22
  00220	e28a0014	 add         r0, r10, #0x14
  00224	eb000000	 bl          EnterCriticalSection

; 1940 :             if ((pPdd->ep[endpoint].dmaDVFSstate == DVFS_PREDMA) && pPdd->ep[endpoint].dmaEnabled)

  00228	e5d630d8	 ldrb        r3, [r6, #0xD8]
  0022c	e3530001	 cmp         r3, #1
  00230	1a000007	 bne         |$LN10@Device_Pro@2|
  00234	e59630bc	 ldr         r3, [r6, #0xBC]
  00238	e3530000	 cmp         r3, #0

; 1941 :             {
; 1942 :                 pPdd->ep[endpoint].dmaDVFSstate = DVFS_POSTDMA;

  0023c	13a03002	 movne       r3, #2
  00240	15c630d8	 strneb      r3, [r6, #0xD8]

; 1943 :                 PostDmaDeactivation(pPdd, endpoint, RX_TRANSFER);

  00244	13a02001	 movne       r2, #1
  00248	11a01008	 movne       r1, r8
  0024c	11a00004	 movne       r0, r4
  00250	1b000000	 blne        PostDmaDeactivation
  00254		 |$LN10@Device_Pro@2|

; 1944 :             }
; 1945 :             LeaveCriticalSection(&pPdd->csDVFS);

  00254	e28a0014	 add         r0, r10, #0x14
  00258		 |$LN14@Device_Pro@2|
  00258	eb000000	 bl          LeaveCriticalSection
  0025c		 |$PROCESS_FIFO$47776|

; 1946 : 
; 1947 : 
; 1948 :             DEBUGMSG(ZONE_FUNCTION, (L"Device_ProcessEPx_Rx:Tot transfer(%d), rxcount(%d), pBuffer to ReadFIFO(0x%x)\r\n",
; 1949 :                 pTransfer->cbTransferred, rxcount, ((UCHAR*)pTransfer->pvBuffer + pTransfer->cbTransferred)));
; 1950 :         }
; 1951 : 
; 1952 : PROCESS_FIFO:
; 1953 : 
; 1954 :         if(rxcount== pEP->maxPacketSize)

  0025c	e1d63abc	 ldrh        r3, [r6, #0xAC]
  00260	e1570003	 cmp         r7, r3
  00264	1a000005	 bne         |$LN9@Device_Pro@2|

; 1955 :         {
; 1956 :             EnterCriticalSection(&pPdd->dmaCS);

  00268	e2840034	 add         r0, r4, #0x34
  0026c	eb000000	 bl          EnterCriticalSection

; 1957 :             pPdd->bDMAForRX = TRUE;

  00270	e3a03001	 mov         r3, #1
  00274	e5843430	 str         r3, [r4, #0x430]

; 1958 :             LeaveCriticalSection(&pPdd->dmaCS);

  00278	e2840034	 add         r0, r4, #0x34
  0027c	eb000000	 bl          LeaveCriticalSection
  00280		 |$LN9@Device_Pro@2|

; 1959 :         }
; 1960 : 
; 1961 :         if((pTransfer->cbTransferred + rxcount) <= pTransfer->cbBuffer)

  00280	e5950010	 ldr         r0, [r5, #0x10]
  00284	e595200c	 ldr         r2, [r5, #0xC]
  00288	e0803007	 add         r3, r0, r7
  0028c	e1530002	 cmp         r3, r2
  00290	8a00000e	 bhi         |$LN8@Device_Pro@2|

; 1962 :         {
; 1963 :             if (rxcount)

  00294	e3570000	 cmp         r7, #0
  00298	0a000008	 beq         |$LN7@Device_Pro@2|

; 1964 :             {
; 1965 :                 pBuffer =(UCHAR*)pTransfer->pvBuffer + pTransfer->cbTransferred;

  0029c	e5952004	 ldr         r2, [r5, #4]

; 1966 :             ReadFIFO(pPdd, (UCHAR)endpoint, pBuffer, (DWORD)rxcount);

  002a0	e1a03007	 mov         r3, r7
  002a4	e20810ff	 and         r1, r8, #0xFF
  002a8	e0802002	 add         r2, r0, r2
  002ac	e1a00004	 mov         r0, r4
  002b0	eb000000	 bl          ReadFIFO

; 1967 : 
; 1968 :                 // We transfered some data
; 1969 :                 pTransfer->cbTransferred += rxcount;

  002b4	e5953010	 ldr         r3, [r5, #0x10]
  002b8	e0873003	 add         r3, r7, r3
  002bc	e5853010	 str         r3, [r5, #0x10]
  002c0		 |$LN7@Device_Pro@2|

; 1970 :             }
; 1971 : 
; 1972 :             // clear intr_rx_data_avail EP bit
; 1973 :             pPdd->intr_rx_data_avail &= ~(1 << endpoint);

  002c0	e3a02001	 mov         r2, #1
  002c4	e59433f0	 ldr         r3, [r4, #0x3F0]
  002c8	e1c33812	 bic         r3, r3, r2, lsl r8
  002cc	ea000004	 b           |$LN39@Device_Pro@2|
  002d0		 |$LN8@Device_Pro@2|

; 1974 :         }
; 1975 :         else if (rxcount)

  002d0	e3570000	 cmp         r7, #0
  002d4	0a000003	 beq         |$LN5@Device_Pro@2|

; 1976 :         {
; 1977 :             // set intr_rx_data_avail EP bit
; 1978 :             pPdd->intr_rx_data_avail |= (1 << endpoint);

  002d8	e59433f0	 ldr         r3, [r4, #0x3F0]
  002dc	e3a02001	 mov         r2, #1
  002e0	e1833812	 orr         r3, r3, r2, lsl r8
  002e4		 |$LN39@Device_Pro@2|
  002e4	e58433f0	 str         r3, [r4, #0x3F0]
  002e8		 |$LN5@Device_Pro@2|

; 1979 :         }
; 1980 : 
; 1981 :         // Is this end of transfer?
; 1982 :         // I guess the system doesn't send out the zero-length packet from host.
; 1983 :         if ((rxcount < pPdd->ep[endpoint].maxPacketSize) ||(rxcount == 0) || (pTransfer->cbTransferred == pTransfer->cbBuffer))

  002e8	e1d63abc	 ldrh        r3, [r6, #0xAC]
  002ec	e1570003	 cmp         r7, r3
  002f0	3a000009	 bcc         |$LN3@Device_Pro@2|
  002f4	e3570000	 cmp         r7, #0
  002f8	0a000007	 beq         |$LN3@Device_Pro@2|
  002fc	e5952010	 ldr         r2, [r5, #0x10]
  00300	e595300c	 ldr         r3, [r5, #0xC]
  00304	e1520003	 cmp         r2, r3
  00308	0a000003	 beq         |$LN3@Device_Pro@2|

; 2000 :             DEBUGMSG(DEBUG_PRT_TRANS, (L"Device_ProcessEPx_RX: call pfnNotify COMPLETE -\r\n"));
; 2001 :         }
; 2002 :         else
; 2003 :         {
; 2004 :             rc = StartRxDmaTransfer(pPdd, endpoint);

  0030c	e1a01008	 mov         r1, r8
  00310	e1a00004	 mov         r0, r4
  00314	eb000000	 bl          StartRxDmaTransfer
  00318	ea00000e	 b           |$LN33@Device_Pro@2|
  0031c		 |$LN3@Device_Pro@2|

; 1984 :         {
; 1985 :             // received last block
; 1986 :             DEBUGMSG(DEBUG_PRT_TRANS, (L"Device_ProcessEPx_RX: call pfnNotify COMPLETE endp:%d +\r\n", endpoint));
; 1987 : 
; 1988 :             // May need to add Critical Section for DVFS
; 1989 :             pTransfer->dwUsbError = UFN_NO_ERROR;

  0031c	e5859014	 str         r9, [r5, #0x14]

; 1990 :             pEP->pTransfer = NULL;

  00320	e58690cc	 str         r9, [r6, #0xCC]

; 1991 :             //memdump((uchar *)pTransfer->pvBuffer, (unsigned short) pTransfer->cbTransferred, 0);
; 1992 :             // Don't clear RXCSR_P_PXPKTRDY here, let the next time it start to do that.
; 1993 :             if ((pPdd->ep[endpoint].dmaEnabled) && (pPdd->rx0DmaState == MODE_FIFO))

  00324	e59630bc	 ldr         r3, [r6, #0xBC]
  00328	e3530000	 cmp         r3, #0
  0032c	0a000002	 beq         |$LN2@Device_Pro@2|
  00330	e594301c	 ldr         r3, [r4, #0x1C]
  00334	e3530001	 cmp         r3, #1

; 1994 :                 pPdd->rx0DmaState = MODE_DMA;

  00338	0584901c	 streq       r9, [r4, #0x1C]
  0033c		 |$LN2@Device_Pro@2|

; 1995 : 
; 1996 :             pEP->bLastRxUsedDMA = FALSE;

  0033c	e58690dc	 str         r9, [r6, #0xDC]

; 1997 : 
; 1998 :             pPdd->pfnNotify(
; 1999 :                 pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer);

  00340	e5940024	 ldr         r0, [r4, #0x24]
  00344	e5943028	 ldr         r3, [r4, #0x28]
  00348	e1a02005	 mov         r2, r5
  0034c	e3a01064	 mov         r1, #0x64
  00350	e1a0e00f	 mov         lr, pc
  00354	e12fff13	 bx          r3
  00358		 |$LN33@Device_Pro@2|

; 2005 :         }
; 2006 :     }

  00358	eaffff5d	 b           |$LN34@Device_Pro@2|
  0035c		 |$LN29@Device_Pro@2|

; 2008 :     {
; 2009 :         pTransfer->dwUsbError = UFN_CLIENT_BUFFER_ERROR;

  0035c	e51b302c	 ldr         r3, [r11, #-0x2C]
  00360	e3a02f41	 mov         r2, #0x41, 30
  00364	e5832014	 str         r2, [r3, #0x14]
  00368	eaffff59	 b           |$LN34@Device_Pro@2|
  0036c		 |$LN38@Device_Pro@2|

; 2010 :     }
; 2011 :     return ERROR_SUCCESS;
; 2012 : 
; 2013 : cleanUp:
; 2014 : 
; 2015 :     DEBUGMSG(ZONE_FUNCTION, (L"-Device_ProcessEPx_RX\r\n"));
; 2016 : 
; 2017 :     return ERROR_SUCCESS;

  0036c	e51b002c	 ldr         r0, [r11, #-0x2C]
  00370		 |$LN25@Device_Pro@2|

; 2018 : }

  00370	e24bd028	 sub         sp, r11, #0x28
  00374	e89d6ff0	 ldmia       sp, {r4 - r11, sp, lr}
  00378	e12fff1e	 bx          lr

			 ENDP  ; |Device_ProcessEPx_RX|

  0037c		 |$LN28@Device_Pro@2|
  0037c		 |$LN43@Device_Pro@2|

; 2007 :     __except(EXCEPTION_EXECUTE_HANDLER)

  0037c	e52de004	 str         lr, [sp, #-4]!
  00380		 |$LN31@Device_Pro@2|
  00380		 |$LN46@Device_Pro@2|
  00380	e3a00001	 mov         r0, #1
  00384		 |$LN30@Device_Pro@2|
  00384	e49df004	 ldr         pc, [sp], #4
  00388		 |$LN47@Device_Pro@2|
  00388		 |$LN45@Device_Pro@2|

  00000			 AREA	 |.pdata|, PDATA
|$T49339| DCD	|$LN30@Device_Pro@3|
	DCD	0xc0006c04

  00000			 AREA	 |.pdata|, PDATA
|$T49341| DCD	|$LN16@Device_Pro@3|
	DCD	0x40000301

  00000			 AREA	 |.xdata|, DATA
|$T49337| DCD	0x1
	DCD	|$LN20@Device_Pro@3|
	DCD	|$LN21@Device_Pro@3|
	DCD	|$LN16@Device_Pro@3|
	DCD	|$LN17@Device_Pro@3|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T49337|

  00008		 |Device_ProcessEPx_TX| PROC

; 2040 : {

  00008		 |$LN30@Device_Pro@3|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d5ff0	 stmdb       sp!, {r4 - r12, lr}
  00010	e28db028	 add         r11, sp, #0x28
  00014	e24dd004	 sub         sp, sp, #4
  00018		 |$LN28@Device_Pro@3|
  00018	e1a0a001	 mov         r10, r1

; 2041 :     PHSMUSB_T pUSBContext =(PHSMUSB_T) pHSMUSBContext;
; 2042 :     PCSP_MUSB_CSR_REGS pCsrRegs = pUSBContext->pUsbCsrRegs;
; 2043 :     MUsbFnPdd_t *pPdd = pUSBContext->pContext[DEVICE_CONTEXT];

  0001c	e5906010	 ldr         r6, [r0, #0x10]
  00020	e590301c	 ldr         r3, [r0, #0x1C]

; 2044 :     MUsbFnEp_t *pEP = &pPdd->ep[endpoint];

  00024	e3a02034	 mov         r2, #0x34
  00028	e024629a	 mla         r4, r10, r2, r6

; 2045 :     STransfer *pTransfer = pEP->pTransfer;
; 2046 :     UINT16 csrVal;
; 2047 :     
; 2048 :     DEBUGMSG(DEBUG_PRT_INFO, (L"+Device_ProcessEPx_TX: endpoint=%d\r\n", endpoint));
; 2049 :     csrVal = INREG16(&pCsrRegs->ep[endpoint].CSR.TxCSR);

  0002c	e083520a	 add         r5, r3, r10, lsl #4
  00030	e59480cc	 ldr         r8, [r4, #0xCC]
  00034	e1d500b2	 ldrh        r0, [r5, #2]
  00038	e50b802c	 str         r8, [r11, #-0x2C]

; 2050 :     
; 2051 :     if (csrVal & TXCSR_P_SENTSTALL)

  0003c	e3100020	 tst         r0, #0x20

; 2052 :     {
; 2053 :         // MUSB finished sending STALL 
; 2054 :         // clear SENTSTALL 
; 2055 :         DEBUGMSG(ZONE_INFO, (TEXT("Stall\r\n")));
; 2056 : 
; 2057 :         pEP->stalled = FALSE;

  00040	e3a09000	 mov         r9, #0
  00044	158490c0	 strne       r9, [r4, #0xC0]

; 2058 :         CLRREG16(&pCsrRegs->ep[endpoint].CSR.TxCSR, TXCSR_P_SENTSTALL);

  00048	11d520b2	 ldrneh      r2, [r5, #2]
  0004c	13a03cff	 movne       r3, #0xFF, 24
  00050	138330df	 orrne       r3, r3, #0xDF
  00054	10023003	 andne       r3, r2, r3
  00058	11c530b2	 strneh      r3, [r5, #2]

; 2059 :         csrVal = INREG16(&pCsrRegs->ep[endpoint].CSR.TxCSR);

  0005c	11d500b2	 ldrneh      r0, [r5, #2]

; 2060 :     }
; 2061 :     
; 2062 :     if (csrVal & TXCSR_P_UNDERRUN)

  00060	e3100004	 tst         r0, #4

; 2063 :     {
; 2064 :         // clear UNDERRUN 
; 2065 :         DEBUGMSG(ZONE_INFO, (TEXT("Underrun\r\n")));
; 2066 :         CLRREG16(&pCsrRegs->ep[endpoint].CSR.TxCSR, TXCSR_P_UNDERRUN);

  00064	11d520b2	 ldrneh      r2, [r5, #2]
  00068	13a03cff	 movne       r3, #0xFF, 24
  0006c	138330fb	 orrne       r3, r3, #0xFB
  00070	10023003	 andne       r3, r2, r3
  00074	11c530b2	 strneh      r3, [r5, #2]

; 2067 :     }
; 2068 :     
; 2069 :     // check if finished sending packet (TXPKTRDY bit clear when finished)
; 2070 :     if (csrVal & TXCSR_P_TXPKTRDY) 

  00078	e3100001	 tst         r0, #1
  0007c	0a000001	 beq         |$LN10@Device_Pro@3|
  00080		 |$LN27@Device_Pro@3|

; 2071 :     {
; 2072 :         DEBUGMSG(ZONE_ERROR, (TEXT("TXCSR_P_TXPKTRDY\r\n")));
; 2073 :         return ERROR_SUCCESS;

  00080	e3a00000	 mov         r0, #0
  00084	ea000048	 b           |$LN13@Device_Pro@3|
  00088		 |$LN10@Device_Pro@3|

; 2074 :     }
; 2075 :     
; 2076 :     if (pTransfer == NULL) 

  00088	e3580000	 cmp         r8, #0

; 2077 :     {
; 2078 :         DEBUGMSG(ZONE_INFO, (L"Device_ProcessEPx_TX:  pTransfer is NULL\r\n"));
; 2079 :         return ERROR_SUCCESS;

  0008c	0afffffb	 beq         |$LN27@Device_Pro@3|
  00090		 |$LN20@Device_Pro@3|

; 2080 :     }
; 2081 :     
; 2082 :     __try
; 2083 :     {
; 2084 :         UCHAR *pBuffer;
; 2085 :         DWORD space, txcount;
; 2086 : 
; 2087 :         pBuffer =(UCHAR*)pTransfer->pvBuffer + pTransfer->cbTransferred;

  00090	e5981010	 ldr         r1, [r8, #0x10]

; 2088 :         space = pTransfer->cbBuffer - pTransfer->cbTransferred;

  00094	e598300c	 ldr         r3, [r8, #0xC]
  00098	e5982004	 ldr         r2, [r8, #4]

; 2089 : 
; 2090 : 
; 2091 :         // How many bytes we can send just now?
; 2092 :         txcount = pEP->maxPacketSize;

  0009c	e1d40abc	 ldrh        r0, [r4, #0xAC]
  000a0	e0433001	 sub         r3, r3, r1

; 2093 :         if (txcount > space)

  000a4	e1500003	 cmp         r0, r3
  000a8	e1a07000	 mov         r7, r0

; 2094 :             txcount = space;

  000ac	81a07003	 movhi       r7, r3

; 2095 : 
; 2096 :         DEBUGMSG(ZONE_INFO, (L"Device_ProcessEPx_TX: bytes_left_to_send=%d sending=%d\r\n", space, txcount));
; 2097 : 
; 2098 :         if (txcount)

  000b0	e3570000	 cmp         r7, #0
  000b4	0a00000b	 beq         |$LN6@Device_Pro@3|

; 2099 :         {
; 2100 :             // Write data to FIFO
; 2101 :             WriteFIFO(pPdd, (UCHAR) endpoint, pBuffer, txcount);

  000b8	e1a03007	 mov         r3, r7
  000bc	e0822001	 add         r2, r2, r1
  000c0	e20a10ff	 and         r1, r10, #0xFF
  000c4	e1a00006	 mov         r0, r6
  000c8	eb000000	 bl          WriteFIFO

; 2102 : 
; 2103 :             // We transfered some data
; 2104 :             pTransfer->cbTransferred += txcount;

  000cc	e5983010	 ldr         r3, [r8, #0x10]
  000d0	e0833007	 add         r3, r3, r7
  000d4	e5883010	 str         r3, [r8, #0x10]

; 2105 :             SETREG16(&pCsrRegs->ep[endpoint].CSR.TxCSR, TXCSR_P_TXPKTRDY);

  000d8	e1d530b2	 ldrh        r3, [r5, #2]
  000dc	e3833001	 orr         r3, r3, #1
  000e0	e1c530b2	 strh        r3, [r5, #2]
  000e4	ea00002a	 b           |$LN21@Device_Pro@3|
  000e8		 |$LN6@Device_Pro@3|

; 2106 :             DEBUGMSG(DEBUG_PRT_TRANS, (L"EPX_TX sent %d bytes\r\n", txcount));
; 2107 :         }
; 2108 :          // don't send zero byte data packet to see if USB mass storage works
; 2109 :         else if (((pTransfer->cbTransferred % pEP->maxPacketSize) == 0) && (!pEP->bZeroLengthSent) && (!pEP->bMassStore))

  000e8	eb000000	 bl          __rt_udiv
  000ec	e3510000	 cmp         r1, #0
  000f0	1a000009	 bne         |$LN4@Device_Pro@3|
  000f4	e59430c4	 ldr         r3, [r4, #0xC4]
  000f8	e3530000	 cmp         r3, #0
  000fc	059430b8	 ldreq       r3, [r4, #0xB8]
  00100	03530000	 cmpeq       r3, #0

; 2110 :         {
; 2111 :             // send zero-length end of packet
; 2112 :             SETREG16(&pCsrRegs->ep[endpoint].CSR.TxCSR, TXCSR_P_TXPKTRDY);

  00104	01d530b2	 ldreqh      r3, [r5, #2]

; 2113 : 
; 2114 :             pEP->bZeroLengthSent = TRUE;

  00108	03a02001	 moveq       r2, #1
  0010c	03833001	 orreq       r3, r3, #1
  00110	01c530b2	 streqh      r3, [r5, #2]
  00114	058420c4	 streq       r2, [r4, #0xC4]

; 2106 :             DEBUGMSG(DEBUG_PRT_TRANS, (L"EPX_TX sent %d bytes\r\n", txcount));
; 2107 :         }
; 2108 :          // don't send zero byte data packet to see if USB mass storage works
; 2109 :         else if (((pTransfer->cbTransferred % pEP->maxPacketSize) == 0) && (!pEP->bZeroLengthSent) && (!pEP->bMassStore))

  00118	0a00001d	 beq         |$LN21@Device_Pro@3|
  0011c		 |$LN4@Device_Pro@3|

; 2115 :         }
; 2116 :         else
; 2117 :         {
; 2118 :             // ACK_COMPLETE
; 2119 :             DEBUGMSG(DEBUG_PRT_TRANS, (L"Device_ProcessEPx_TX: call pfnNotify COMPLETE endp:%d +\r\n", endpoint));
; 2120 :             // May need to add Critical Section for DVFS
; 2121 :             if (pPdd->ep[endpoint].dmaEnabled && pPdd->bTXIsUsingUsbDMA)

  0011c	e59430bc	 ldr         r3, [r4, #0xBC]
  00120	e3530000	 cmp         r3, #0
  00124	0a000012	 beq         |$LN2@Device_Pro@3|
  00128	e5963434	 ldr         r3, [r6, #0x434]
  0012c	e3530000	 cmp         r3, #0
  00130	0a00000f	 beq         |$LN2@Device_Pro@3|

; 2122 :             {
; 2123 :                 ResetDMAChannel(pPdd, MUSB_TX_DMA_CHN);

  00134	e3a01000	 mov         r1, #0
  00138	e1a00006	 mov         r0, r6
  0013c	eb000000	 bl          ResetDMAChannel

; 2124 :                 EnterCriticalSection(&pPdd->csDVFS);

  00140	e2865b01	 add         r5, r6, #1, 22
  00144	e2850014	 add         r0, r5, #0x14
  00148	eb000000	 bl          EnterCriticalSection

; 2125 :                 if (pPdd->ep[endpoint].dmaDVFSstate == DVFS_PREDMA)

  0014c	e5d430d8	 ldrb        r3, [r4, #0xD8]
  00150	e3530001	 cmp         r3, #1

; 2126 :                 {
; 2127 :                     pPdd->ep[endpoint].dmaDVFSstate = DVFS_POSTDMA;

  00154	03a03002	 moveq       r3, #2
  00158	05c430d8	 streqb      r3, [r4, #0xD8]

; 2128 :                     PostDmaDeactivation(pPdd, endpoint, TX_TRANSFER);

  0015c	03a02000	 moveq       r2, #0
  00160	01a0100a	 moveq       r1, r10
  00164	01a00006	 moveq       r0, r6
  00168	0b000000	 bleq        PostDmaDeactivation

; 2129 :                 }
; 2130 :                 LeaveCriticalSection(&pPdd->csDVFS);

  0016c	e2850014	 add         r0, r5, #0x14
  00170	eb000000	 bl          LeaveCriticalSection
  00174		 |$LN2@Device_Pro@3|

; 2131 :             }
; 2132 : 
; 2133 :             pEP->pTransfer = NULL;

  00174	e58490cc	 str         r9, [r4, #0xCC]

; 2134 :             pTransfer->dwUsbError = UFN_NO_ERROR;

  00178	e5889014	 str         r9, [r8, #0x14]

; 2135 : 
; 2136 :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer);

  0017c	e5960024	 ldr         r0, [r6, #0x24]
  00180	e5963028	 ldr         r3, [r6, #0x28]
  00184	e1a02008	 mov         r2, r8
  00188	e3a01064	 mov         r1, #0x64
  0018c	e1a0e00f	 mov         lr, pc
  00190	e12fff13	 bx          r3
  00194		 |$LN21@Device_Pro@3|

; 2137 :             //DEBUGMSG(DEBUG_PRT_TRANS, (L"Device_ProcessEPx_TX: call pfnNotify COMPLETE -\r\n"));
; 2138 :             //DEBUGMSG(ZONE_INFO, (TEXT("Device_ProcessEPx_TX: ACK_COMPLETE\r\n")));
; 2139 :         }
; 2140 :     }

  00194	eaffffb9	 b           |$LN27@Device_Pro@3|
  00198		 |$LN17@Device_Pro@3|

; 2142 :     {
; 2143 :         pTransfer->dwUsbError = UFN_CLIENT_BUFFER_ERROR;

  00198	e51b302c	 ldr         r3, [r11, #-0x2C]
  0019c	e3a02f41	 mov         r2, #0x41, 30
  001a0	e5832014	 str         r2, [r3, #0x14]
  001a4	eaffffb5	 b           |$LN27@Device_Pro@3|
  001a8		 |$LN26@Device_Pro@3|

; 2144 :         DEBUGMSG(ZONE_ERROR, (L"Device_ProcessEPx_TX: EXCEPTION_EXECUTE_HANDLER"));
; 2145 :     }
; 2146 :     
; 2147 :     DEBUGMSG(ZONE_FUNCTION, (L"-Device_ProcessEPx_TX\r\n"));
; 2148 :     
; 2149 :     return ERROR_SUCCESS;

  001a8	e51b002c	 ldr         r0, [r11, #-0x2C]
  001ac		 |$LN13@Device_Pro@3|

; 2150 : }

  001ac	e24bd028	 sub         sp, r11, #0x28
  001b0	e89d6ff0	 ldmia       sp, {r4 - r11, sp, lr}
  001b4	e12fff1e	 bx          lr

			 ENDP  ; |Device_ProcessEPx_TX|

  001b8		 |$LN16@Device_Pro@3|
  001b8		 |$LN29@Device_Pro@3|

; 2141 :     __except(EXCEPTION_EXECUTE_HANDLER)

  001b8	e52de004	 str         lr, [sp, #-4]!
  001bc		 |$LN19@Device_Pro@3|
  001bc		 |$LN32@Device_Pro@3|
  001bc	e3a00001	 mov         r0, #1
  001c0		 |$LN18@Device_Pro@3|
  001c0	e49df004	 ldr         pc, [sp], #4
  001c4		 |$LN33@Device_Pro@3|
  001c4		 |$LN31@Device_Pro@3|

  00000			 AREA	 |.pdata|, PDATA
|$T49386| DCD	|$LN41@Device_Pro@4|
	DCD	0xc000db04

  00000			 AREA	 |.pdata|, PDATA
|$T49388| DCD	|$LN27@Device_Pro@4|
	DCD	0x40000301

  00000			 AREA	 |.xdata|, DATA
|$T49384| DCD	0x1
	DCD	|$LN31@Device_Pro@4|
	DCD	|$LN32@Device_Pro@4|
	DCD	|$LN27@Device_Pro@4|
	DCD	|$LN28@Device_Pro@4|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T49384|

  00008		 |Device_ProcessDMA| PROC

; 2168 : {

  00008		 |$LN41@Device_Pro@4|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d5ff0	 stmdb       sp!, {r4 - r12, lr}
  00010	e28db028	 add         r11, sp, #0x28
  00014	e24dd028	 sub         sp, sp, #0x28
  00018		 |$LN39@Device_Pro@4|
  00018	e1a0a001	 mov         r10, r1

; 2169 :     MUsbFnPdd_t *pPdd =((PHSMUSB_T) pHSMUSBContext)->pContext[DEVICE_CONTEXT];

  0001c	e5904010	 ldr         r4, [r0, #0x10]

; 2170 :     PCSP_MUSB_CSR_REGS pCsrRegs = pPdd->pUSBContext->pUsbCsrRegs;
; 2171 :     PHSMUSB_T pOTG =(PHSMUSB_T)(pPdd->pUSBContext);
; 2172 :     MUsbFnEp_t *pEP;
; 2173 :     STransfer *pTransfer;
; 2174 :     
; 2175 :     DEBUGMSG(DEBUG_PRT_INFO, (L"Device_ProcessDMA: channel %d\r\n", channel));
; 2176 :     
; 2177 :     if (channel == MUSB_TX_DMA_CHN)

  00020	e1b0300a	 movs        r3, r10
  00024	e50b4038	 str         r4, [r11, #-0x38]
  00028	e5947020	 ldr         r7, [r4, #0x20]
  0002c	e597101c	 ldr         r1, [r7, #0x1C]
  00030	e50b104c	 str         r1, [r11, #-0x4C]
  00034	1a00003c	 bne         |$LN21@Device_Pro@4|

; 2178 :     {
; 2179 :         DWORD endpoint = pPdd->tx0DmaEp;

  00038	e5946010	 ldr         r6, [r4, #0x10]

; 2180 :         
; 2181 :         pEP = &pPdd->ep[endpoint];

  0003c	e3a03034	 mov         r3, #0x34
  00040	e0254396	 mla         r5, r6, r3, r4

; 2182 :         pTransfer = pEP->pTransfer;

  00044	e59530cc	 ldr         r3, [r5, #0xCC]
  00048	e1b08003	 movs        r8, r3

; 2183 : 
; 2184 :         if (pTransfer == NULL) 

  0004c	1a000001	 bne         |$LN20@Device_Pro@4|
  00050		 |$LN38@Device_Pro@4|

; 2185 :         {
; 2186 :             DEBUGMSG(ZONE_DVFS, (L"Device_ProcessDMA:  error pTransfer is NULL\r\n"));
; 2187 :             return ERROR_INVALID_PARAMETER;

  00050	e3a00057	 mov         r0, #0x57
  00054	ea000025	 b           |$LN22@Device_Pro@4|
  00058		 |$LN20@Device_Pro@4|

; 2188 :         }    
; 2189 : 
; 2190 :         DEBUGMSG(ZONE_FUNCTION, (TEXT("Device_ProcessDMA TX, EP %d Cntl(0x%x) pTransfer(0x%x), pvBuffer(0x%x), cbBuffer(0x%x), cbTransferred(0x%x)\r\n"),             
; 2191 :             endpoint, INREG32(&pOTG->pUsbDmaRegs->dma[channel].Cntl), pTransfer, pTransfer->pvBuffer, pTransfer->cbBuffer, pTransfer->cbTransferred));
; 2192 :         
; 2193 :         DEBUGMSG(DEBUG_PRT_INFO, (TEXT("Device_ProcessDMA: cbBuffer=%d  cbTransferred=%d\r\n"), pTransfer->cbBuffer, pTransfer->cbTransferred));
; 2194 :         
; 2195 :         // Done using DMA controller.  disable DMA related bits.
; 2196 :         //  When controller finishes sending FIFO data, should generate interrupt and call IST.
; 2197 :         CLRREG16(&pCsrRegs->ep[endpoint].CSR.TxCSR, TXCSR_P_AUTOSET | TXCSR_P_DMAREQENAB);

  00058	e0817206	 add         r7, r1, r6, lsl #4
  0005c	e1d720b2	 ldrh        r2, [r7, #2]
  00060	e3a03c6f	 mov         r3, #0x6F, 24
  00064	e38330ff	 orr         r3, r3, #0xFF
  00068	e0023003	 and         r3, r2, r3
  0006c	e1c730b2	 strh        r3, [r7, #2]

; 2198 : 
; 2199 :         // clear TXCSR_P_DMAREQMODE after clearing TXCSR_P_DMAREQENAB (per MUSBMHDRC programming guide)
; 2200 :         CLRREG16(&pCsrRegs->ep[endpoint].CSR.TxCSR, TXCSR_P_DMAREQMODE);

  00070	e1d720b2	 ldrh        r2, [r7, #2]
  00074	e3a03cfb	 mov         r3, #0xFB, 24
  00078	e38330ff	 orr         r3, r3, #0xFF
  0007c	e0023003	 and         r3, r2, r3
  00080	e1c730b2	 strh        r3, [r7, #2]

; 2201 : 
; 2202 :         ResetDMAChannel(pPdd, MUSB_TX_DMA_CHN);

  00084	e3a01000	 mov         r1, #0
  00088	e1a00004	 mov         r0, r4
  0008c	eb000000	 bl          ResetDMAChannel

; 2203 : 
; 2204 :         EnterCriticalSection(&pPdd->csDVFS);

  00090	e2849b01	 add         r9, r4, #1, 22
  00094	e2890014	 add         r0, r9, #0x14
  00098	eb000000	 bl          EnterCriticalSection

; 2205 :         if (pPdd->ep[endpoint].dmaDVFSstate == DVFS_PREDMA)

  0009c	e5d530d8	 ldrb        r3, [r5, #0xD8]
  000a0	e3530001	 cmp         r3, #1

; 2206 :         {
; 2207 :             pPdd->ep[endpoint].dmaDVFSstate = DVFS_POSTDMA;

  000a4	03a03002	 moveq       r3, #2
  000a8	05c530d8	 streqb      r3, [r5, #0xD8]

; 2208 :             PostDmaDeactivation(pPdd, endpoint, TX_TRANSFER);

  000ac	03a02000	 moveq       r2, #0
  000b0	01a01006	 moveq       r1, r6
  000b4	01a00004	 moveq       r0, r4
  000b8	0b000000	 bleq        PostDmaDeactivation

; 2209 :         }
; 2210 :         LeaveCriticalSection(&pPdd->csDVFS);

  000bc	e2890014	 add         r0, r9, #0x14
  000c0	eb000000	 bl          LeaveCriticalSection

; 2211 : 
; 2212 :         if ((pTransfer->cbBuffer - pTransfer->cbTransferred) == 0)

  000c4	e598200c	 ldr         r2, [r8, #0xC]
  000c8	e5983010	 ldr         r3, [r8, #0x10]
  000cc	e0523003	 subs        r3, r2, r3
  000d0	1a000009	 bne         |$LN18@Device_Pro@4|

; 2213 :         {
; 2214 :             // DMA finished loading FIFO with last packet in pTransfer buffer.  Manually set TXPKTRDY to let MUSB transmit it.
; 2215 : 
; 2216 :             DEBUGMSG(DEBUG_PRT_INFO, (TEXT("Device_ProcessDMA: no more data to send.  There should be data in FIFO.  Set TXPKTRDY. \r\n")));
; 2217 : 
; 2218 :             // test don't set TXPKTRDY and see if USB mass storage works (no zero length data packets)
; 2219 :             if(pEP->bMassStore)

  000d4	e59530b8	 ldr         r3, [r5, #0xB8]
  000d8	e3530000	 cmp         r3, #0

; 2220 :             {
; 2221 :                 // call ContinueTxDmaTransfer() to see if more data left in pTransfer buffer
; 2222 :                 ContinueTxDmaTransfer(pPdd, endpoint);
; 2223 :             }
; 2224 :             else

  000dc	1a00000e	 bne         |$LN14@Device_Pro@4|

; 2225 :             {
; 2226 :                 SETREG16(&pCsrRegs->ep[endpoint].CSR.TxCSR, TXCSR_P_TXPKTRDY);

  000e0	e1d730b2	 ldrh        r3, [r7, #2]
  000e4	e3833001	 orr         r3, r3, #1
  000e8	e1c730b2	 strh        r3, [r7, #2]

; 2352 : 
; 2353 :                 pPdd->pfnNotify(
; 2354 :                     pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer
; 2355 :                     );

  000ec		 |$LN5@Device_Pro@4|

; 2356 : 
; 2357 :             }
; 2358 :         }
; 2359 :     }
; 2360 : 
; 2361 :     return ERROR_SUCCESS;

  000ec	e3a00000	 mov         r0, #0
  000f0		 |$LN22@Device_Pro@4|

; 2362 : }

  000f0	e24bd028	 sub         sp, r11, #0x28
  000f4	e89d6ff0	 ldmia       sp, {r4 - r11, sp, lr}
  000f8	e12fff1e	 bx          lr
  000fc		 |$LN18@Device_Pro@4|

; 2227 :             }
; 2228 :         }
; 2229 :         // set up for next block of data to transmit
; 2230 :         //            if ((pTransfer->cbBuffer - pTransfer->cbTransferred) > pPdd->ep[endpoint].maxPacketSize)
; 2231 :         else   // set up DMA to copy next block of data to FIFO
; 2232 :         {
; 2233 :             // call ContinueTxDmaTransfer() to see if more data left in pTransfer buffer
; 2234 :             if (pEP->bTxDMAShortPacket == TRUE)

  000fc	e59530d4	 ldr         r3, [r5, #0xD4]
  00100	e3530001	 cmp         r3, #1

; 2235 :             {
; 2236 :                 SETREG16(&pCsrRegs->ep[endpoint].CSR.TxCSR, TXCSR_P_TXPKTRDY);

  00104	01d730b2	 ldreqh      r3, [r7, #2]

; 2237 :                 pEP->bTxDMAShortPacket = FALSE;

  00108	03a02000	 moveq       r2, #0
  0010c	03833001	 orreq       r3, r3, #1
  00110	01c730b2	 streqh      r3, [r7, #2]
  00114	058520d4	 streq       r2, [r5, #0xD4]

; 2227 :             }
; 2228 :         }
; 2229 :         // set up for next block of data to transmit
; 2230 :         //            if ((pTransfer->cbBuffer - pTransfer->cbTransferred) > pPdd->ep[endpoint].maxPacketSize)
; 2231 :         else   // set up DMA to copy next block of data to FIFO
; 2232 :         {
; 2233 :             // call ContinueTxDmaTransfer() to see if more data left in pTransfer buffer
; 2234 :             if (pEP->bTxDMAShortPacket == TRUE)

  00118	0afffff3	 beq         |$LN5@Device_Pro@4|
  0011c		 |$LN14@Device_Pro@4|

; 2238 :             }
; 2239 :             else
; 2240 :             {
; 2241 :                 ContinueTxDmaTransfer(pPdd, endpoint);

  0011c	e1a01006	 mov         r1, r6
  00120	e1a00004	 mov         r0, r4
  00124	eb000000	 bl          ContinueTxDmaTransfer

; 2242 :             }
; 2243 :         }

  00128	eaffffef	 b           |$LN5@Device_Pro@4|
  0012c		 |$LN21@Device_Pro@4|

; 2244 : 
; 2245 :     }
; 2246 :     else if (channel == MUSB_RX_DMA_CHN)

  0012c	e3530001	 cmp         r3, #1
  00130	1affffed	 bne         |$LN5@Device_Pro@4|

; 2247 :     {
; 2248 :         DWORD endpoint				= pPdd->rx0DmaEp;

  00134	e594600c	 ldr         r6, [r4, #0xC]

; 2249 :         DWORD size					= 0;
; 2250 :         UCHAR *pBuffer				= NULL;
; 2251 :         PCSP_MUSB_CSR_REGS pCsrRegs = pPdd->pUSBContext->pUsbCsrRegs;
; 2252 :         WORD rxcount				= 0;
; 2253 :         UINT16 csrVal				= 0;
; 2254 : 
; 2255 :         csrVal = INREG16(&pCsrRegs->ep[endpoint].RxCSR);
; 2256 : 
; 2257 :         pEP = &pPdd->ep[endpoint];

  00138	e3a03034	 mov         r3, #0x34
  0013c	e3a00000	 mov         r0, #0
  00140	e50b6030	 str         r6, [r11, #-0x30]
  00144	e3a0e000	 mov         lr, #0
  00148	e0234396	 mla         r3, r6, r3, r4
  0014c	e0812206	 add         r2, r1, r6, lsl #4
  00150	e28390ac	 add         r9, r3, #0xAC
  00154	e50b9034	 str         r9, [r11, #-0x34]
  00158	e1d220b6	 ldrh        r2, [r2, #6]

; 2258 :         pTransfer = pEP->pTransfer;

  0015c	e5993020	 ldr         r3, [r9, #0x20]
  00160	e50b0048	 str         r0, [r11, #-0x48]
  00164	e1b05003	 movs        r5, r3
  00168	e50b503c	 str         r5, [r11, #-0x3C]
  0016c	e50b102c	 str         r1, [r11, #-0x2C]
  00170	e14be5b0	 strh        lr, [r11, #-0x50]

; 2259 : 
; 2260 :         if (pTransfer == NULL)
; 2261 :         {
; 2262 :             DEBUGMSG(ZONE_DVFS, (L"Device_ProcessDMA:  error pTransfer is NULL\r\n"));
; 2263 :             return ERROR_INVALID_PARAMETER;

  00174	0affffb5	 beq         |$LN38@Device_Pro@4|
  00178		 |$LN31@Device_Pro@4|

; 2264 :         }
; 2265 : 
; 2266 :         DEBUGMSG(ZONE_INFO, (TEXT("Device_ProcessDMA RX, EP %d Cntl(0x%x) pTransfer(0x%x), pvBuffer(0x%x), cbBuffer(0x%x), cbTransferred(0x%x)\r\n"),
; 2267 :             endpoint, INREG32(&pOTG->pUsbDmaRegs->dma[channel].Cntl), pTransfer, pTransfer->pvBuffer, pTransfer->cbBuffer, pTransfer->cbTransferred));
; 2268 : 
; 2269 :         __try
; 2270 :         {
; 2271 :             pBuffer =(UCHAR*)pTransfer->pvBuffer + pTransfer->cbTransferred;

  00178	e5953010	 ldr         r3, [r5, #0x10]
  0017c	e50b3044	 str         r3, [r11, #-0x44]
  00180	e5953004	 ldr         r3, [r5, #4]
  00184	e50b3040	 str         r3, [r11, #-0x40]

; 2272 :             EnterCriticalSection(&pPdd->dmaCS);

  00188	e2840034	 add         r0, r4, #0x34
  0018c	eb000000	 bl          EnterCriticalSection

; 2273 : 
; 2274 :             size = (INREG32(&pOTG->pUsbDmaRegs->dma[channel].Addr) == 0x00) ?
; 2275 :                     0 : pEP->dwRxDMASize - INREG32(&pOTG->pUsbDmaRegs->dma[channel].Count);

  00190	e5973024	 ldr         r3, [r7, #0x24]
  00194	e083220a	 add         r2, r3, r10, lsl #4
  00198	e5923008	 ldr         r3, [r2, #8]
  0019c	e3530000	 cmp         r3, #0
  001a0	03a08000	 moveq       r8, #0
  001a4	1592200c	 ldrne       r2, [r2, #0xC]
  001a8	15993024	 ldrne       r3, [r9, #0x24]
  001ac	10438002	 subne       r8, r3, r2

; 2276 : 
; 2277 :             LeaveCriticalSection(&pPdd->dmaCS);

  001b0	e2840034	 add         r0, r4, #0x34
  001b4	e50b8048	 str         r8, [r11, #-0x48]
  001b8	eb000000	 bl          LeaveCriticalSection

; 2278 :             // According to the specification, you get this interrupt because the DMA COUNT = 0
; 2279 :             rxcount = INREG16(&pCsrRegs->ep[endpoint].Count.RxCount);

  001bc	e51b204c	 ldr         r2, [r11, #-0x4C]
  001c0	e0823206	 add         r3, r2, r6, lsl #4
  001c4	e1d370b8	 ldrh        r7, [r3, #8]
  001c8	e14b75b0	 strh        r7, [r11, #-0x50]

; 2280 : 
; 2281 :             if ((size > 0) && (pTransfer->dwBufferPhysicalAddress == 0))

  001cc	e3580000	 cmp         r8, #0
  001d0	0a000007	 beq         |$LN8@Device_Pro@4|
  001d4	e5953008	 ldr         r3, [r5, #8]
  001d8	e3530000	 cmp         r3, #0

; 2282 :                 memcpy(pBuffer, pPdd->pDmaRx0Buffer , size);

  001dc	05941048	 ldreq       r1, [r4, #0x48]
  001e0	01a02008	 moveq       r2, r8
  001e4	051b3044	 ldreq       r3, [r11, #-0x44]
  001e8	051b0040	 ldreq       r0, [r11, #-0x40]
  001ec	00830000	 addeq       r0, r3, r0
  001f0	0b000000	 bleq        memcpy
  001f4		 |$LN8@Device_Pro@4|

; 2283 : 
; 2284 :             // Now ResetDMAChannel
; 2285 :             ResetDMAChannel(pPdd, channel);

  001f4	e1a0100a	 mov         r1, r10
  001f8	e1a00004	 mov         r0, r4
  001fc	eb000000	 bl          ResetDMAChannel

; 2286 :             EnterCriticalSection(&pPdd->csDVFS);

  00200	e284ab01	 add         r10, r4, #1, 22
  00204	e28a0014	 add         r0, r10, #0x14
  00208	eb000000	 bl          EnterCriticalSection

; 2287 :             if (pPdd->ep[endpoint].dmaDVFSstate == DVFS_PREDMA)

  0020c	e3a01034	 mov         r1, #0x34
  00210	e0224196	 mla         r2, r6, r1, r4
  00214	e5d230d8	 ldrb        r3, [r2, #0xD8]
  00218	e3530001	 cmp         r3, #1

; 2288 :             {
; 2289 :                 pPdd->ep[endpoint].dmaDVFSstate = DVFS_POSTDMA;

  0021c	03a03002	 moveq       r3, #2
  00220	05c230d8	 streqb      r3, [r2, #0xD8]

; 2290 :                 PostDmaDeactivation(pPdd, endpoint, RX_TRANSFER);

  00224	03a02001	 moveq       r2, #1
  00228	01a01006	 moveq       r1, r6
  0022c	01a00004	 moveq       r0, r4
  00230	0b000000	 bleq        PostDmaDeactivation

; 2291 :             }
; 2292 :             LeaveCriticalSection(&pPdd->csDVFS);

  00234	e28a0014	 add         r0, r10, #0x14
  00238	eb000000	 bl          LeaveCriticalSection
  0023c		 |$LN32@Device_Pro@4|

; 2293 : 
; 2294 :         }

  0023c	e51ba04c	 ldr         r10, [r11, #-0x4C]
  00240	ea000008	 b           |$LN33@Device_Pro@4|
  00244		 |$LN28@Device_Pro@4|

; 2296 :         {
; 2297 :             pTransfer->dwUsbError = UFN_CLIENT_BUFFER_ERROR;

  00244	e51b503c	 ldr         r5, [r11, #-0x3C]
  00248	e3a03f41	 mov         r3, #0x41, 30
  0024c	e5853014	 str         r3, [r5, #0x14]
  00250	e51b4038	 ldr         r4, [r11, #-0x38]
  00254	e51b9034	 ldr         r9, [r11, #-0x34]
  00258	e51b6030	 ldr         r6, [r11, #-0x30]
  0025c	e51b8048	 ldr         r8, [r11, #-0x48]
  00260	e51ba02c	 ldr         r10, [r11, #-0x2C]
  00264	e15b75b0	 ldrh        r7, [r11, #-0x50]
  00268		 |$LN33@Device_Pro@4|

; 2298 :             DEBUGMSG(ZONE_ERROR, (L"UsbFnPdd!Device_ProcessDMA: UFN_CLIENT_BUFFER_ERROR"));
; 2299 :         }
; 2300 : 
; 2301 :         // Update buffer and clear zero length flag
; 2302 :         pTransfer->cbTransferred += size;

  00268	e5953010	 ldr         r3, [r5, #0x10]

; 2303 : 
; 2304 :         pEP->bLastRxUsedDMA = TRUE;

  0026c	e3a02001	 mov         r2, #1
  00270	e0883003	 add         r3, r8, r3
  00274	e5853010	 str         r3, [r5, #0x10]

; 2305 : 
; 2306 :         // test.  don't buffer.  pass everything received from each interrupt
; 2307 :         if ((pEP->dwRemainBuffer > 0) && (size % pPdd->ep[endpoint].maxPacketSize == 0)
; 2308 :             && /*(!rxcount) &&*/ (pPdd->rx0DmaState == MODE_DMA))

  00278	e599301c	 ldr         r3, [r9, #0x1C]
  0027c	e5892030	 str         r2, [r9, #0x30]
  00280	e3530000	 cmp         r3, #0
  00284	9a00000d	 bls         |$LN6@Device_Pro@4|
  00288	e3a03034	 mov         r3, #0x34
  0028c	e0234396	 mla         r3, r6, r3, r4
  00290	e1a01008	 mov         r1, r8
  00294	e1d30abc	 ldrh        r0, [r3, #0xAC]
  00298	eb000000	 bl          __rt_udiv
  0029c	e3510000	 cmp         r1, #0
  002a0	1a000006	 bne         |$LN6@Device_Pro@4|
  002a4	e594301c	 ldr         r3, [r4, #0x1C]
  002a8	e3530000	 cmp         r3, #0
  002ac	1a000003	 bne         |$LN6@Device_Pro@4|

; 2309 :         {
; 2310 :             StartRxDmaTransfer(pPdd, endpoint);

  002b0	e1a01006	 mov         r1, r6
  002b4	e1a00004	 mov         r0, r4
  002b8	eb000000	 bl          StartRxDmaTransfer

; 2311 :         }
; 2312 :         else

  002bc	eaffff8a	 b           |$LN5@Device_Pro@4|
  002c0		 |$LN6@Device_Pro@4|

; 2313 :         {
; 2314 :             pEP->dwRemainBuffer = 0;

  002c0	e3a08000	 mov         r8, #0
  002c4	e589801c	 str         r8, [r9, #0x1C]

; 2315 :             DEBUGMSG(ZONE_FUNCTION, (TEXT("Device_ProcessDMA rxcount(%d), size(%d), ReadFIFO pTransfer(0x%x), pBuffer(0x%x), cbBuffer(0x%x), cbTransferred(0x%x)\r\n"),
; 2316 :                 size, rxcount, pTransfer, pTransfer->pvBuffer, pTransfer->cbBuffer, pTransfer->cbTransferred));
; 2317 :             if((pTransfer->cbTransferred + rxcount) <= pTransfer->cbBuffer)

  002c8	e5950010	 ldr         r0, [r5, #0x10]
  002cc	e595200c	 ldr         r2, [r5, #0xC]
  002d0	e0873000	 add         r3, r7, r0
  002d4	e1530002	 cmp         r3, r2
  002d8	8a00000e	 bhi         |$LN4@Device_Pro@4|

; 2318 :             {
; 2319 :                 if(rxcount)

  002dc	e3570000	 cmp         r7, #0
  002e0	0a000008	 beq         |$LN3@Device_Pro@4|

; 2320 :                 {
; 2321 :                     pBuffer =(UCHAR*)pTransfer->pvBuffer + pTransfer->cbTransferred;

  002e4	e5952004	 ldr         r2, [r5, #4]

; 2322 :                     ReadFIFO(pPdd, (UCHAR)endpoint, pBuffer, (DWORD)rxcount);

  002e8	e1a03007	 mov         r3, r7
  002ec	e20610ff	 and         r1, r6, #0xFF
  002f0	e0802002	 add         r2, r0, r2
  002f4	e1a00004	 mov         r0, r4
  002f8	eb000000	 bl          ReadFIFO

; 2323 : 
; 2324 :                     // We transfered some data
; 2325 :                     pTransfer->cbTransferred += rxcount;

  002fc	e5953010	 ldr         r3, [r5, #0x10]
  00300	e0873003	 add         r3, r7, r3
  00304	e5853010	 str         r3, [r5, #0x10]
  00308		 |$LN3@Device_Pro@4|

; 2326 :                 }
; 2327 : 
; 2328 :                 // clear intr_rx_data_avail EP bit
; 2329 :                 pPdd->intr_rx_data_avail &= ~(1 << endpoint);

  00308	e3a02001	 mov         r2, #1
  0030c	e59433f0	 ldr         r3, [r4, #0x3F0]
  00310	e1c33612	 bic         r3, r3, r2, lsl r6
  00314	ea000004	 b           |$LN37@Device_Pro@4|
  00318		 |$LN4@Device_Pro@4|

; 2330 :             }
; 2331 :             else if (rxcount)

  00318	e3570000	 cmp         r7, #0
  0031c	0a000003	 beq         |$LN1@Device_Pro@4|

; 2332 :             {
; 2333 :                 // set intr_rx_data_avail EP bit
; 2334 :                 pPdd->intr_rx_data_avail |= (1 << endpoint);

  00320	e59433f0	 ldr         r3, [r4, #0x3F0]
  00324	e3a02001	 mov         r2, #1
  00328	e1833612	 orr         r3, r3, r2, lsl r6
  0032c		 |$LN37@Device_Pro@4|
  0032c	e58433f0	 str         r3, [r4, #0x3F0]
  00330		 |$LN1@Device_Pro@4|

; 2335 :             }
; 2336 : 
; 2337 :             CLRREG16(&pCsrRegs->ep[endpoint].RxCSR, RXCSR_P_AUTOCLEAR | RXCSR_P_DMAREQENAB | RXCSR_P_DMAREQMODE);

  00330	e08a0206	 add         r0, r10, r6, lsl #4
  00334	e1d010b6	 ldrh        r1, [r0, #6]
  00338	e3a03c57	 mov         r3, #0x57, 24
  0033c	e38330ff	 orr         r3, r3, #0xFF
  00340	e0013003	 and         r3, r1, r3
  00344	e1c030b6	 strh        r3, [r0, #6]

; 2338 : 
; 2339 :             DEBUGMSG(ZONE_INFO, (L"Device_ProcessDMA: RX DMA buffer count:%d   FIFO count:%d\r\n", size, rxcount));
; 2340 :             {
; 2341 :                 DEBUGMSG(DEBUG_PRT_TRANS, (L"Device_ProcessDMA: call pfnNotify COMPLETE endp:%d +\r\n", endpoint));
; 2342 : 
; 2343 :                 DEBUGMSG(DEBUG_PRT_TRANS, (L"UsbFnPdd!Device_ProcessDMA: "
; 2344 :                     L"EP %d pTransfer 0x%08x (%d, %d, %d) - done\r\n",
; 2345 :                     endpoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 2346 :                     pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 2347 :                     pTransfer != NULL ? pTransfer->dwUsbError : -1
; 2348 :                     ));
; 2349 :                 DEBUGMSG(DEBUG_PRT_TRANS, (TEXT("ACK: ProcessDMATransfer for EP %d\r\n"), endpoint));
; 2350 :                 pEP->pTransfer = NULL;

  00348	e5898020	 str         r8, [r9, #0x20]

; 2351 :                 pTransfer->dwUsbError = UFN_NO_ERROR;

  0034c	e5858014	 str         r8, [r5, #0x14]

; 2352 : 
; 2353 :                 pPdd->pfnNotify(
; 2354 :                     pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer
; 2355 :                     );

  00350	e5940024	 ldr         r0, [r4, #0x24]
  00354	e5943028	 ldr         r3, [r4, #0x28]
  00358	e1a02005	 mov         r2, r5
  0035c	e3a01064	 mov         r1, #0x64
  00360	e1a0e00f	 mov         lr, pc
  00364	e12fff13	 bx          r3
  00368	eaffff5f	 b           |$LN5@Device_Pro@4|
  0036c		 |$LN36@Device_Pro@4|

; 2356 : 
; 2357 :             }
; 2358 :         }
; 2359 :     }
; 2360 : 
; 2361 :     return ERROR_SUCCESS;

  0036c	e51b002c	 ldr         r0, [r11, #-0x2C]
  00370	eaffff5e	 b           |$LN22@Device_Pro@4|

			 ENDP  ; |Device_ProcessDMA|

  00374		 |$LN27@Device_Pro@4|
  00374		 |$LN40@Device_Pro@4|

; 2295 :         __except(EXCEPTION_EXECUTE_HANDLER)

  00374	e52de004	 str         lr, [sp, #-4]!
  00378		 |$LN30@Device_Pro@4|
  00378		 |$LN43@Device_Pro@4|
  00378	e3a00001	 mov         r0, #1
  0037c		 |$LN29@Device_Pro@4|
  0037c	e49df004	 ldr         pc, [sp], #4
  00380		 |$LN44@Device_Pro@4|
  00380		 |$LN42@Device_Pro@4|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T49412| DCD	|$LN12@Device_Dis|
	DCD	0x40002e01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbfn\pdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Device_Disconnect| PROC

; 2380 : {

  00000		 |$LN12@Device_Dis|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M49409|

; 2381 :     MUsbFnPdd_t *pPdd =((PHSMUSB_T) pHSMUSBContext)->pContext[DEVICE_CONTEXT];

  00004	e5904010	 ldr         r4, [r0, #0x10]

; 2382 :     PHSMUSB_T pOTG =(PHSMUSB_T)(pPdd->pUSBContext);    
; 2383 :     DEBUGMSG(ZONE_FUNCTION, (L"Device_Disconnect\r\n"));
; 2384 : 
; 2385 :     SetEventData( pPdd->hVbusChargeEvent,  BATTERY_USBHOST_DISCONNECT );  

  00008	e3a01000	 mov         r1, #0
  0000c	e5940428	 ldr         r0, [r4, #0x428]
  00010	e5945020	 ldr         r5, [r4, #0x20]
  00014	eb000000	 bl          SetEventData

; 2386 :     SetEvent( pPdd->hVbusChargeEvent );

  00018	e5940428	 ldr         r0, [r4, #0x428]
  0001c	e3a01003	 mov         r1, #3
  00020	eb000000	 bl          EventModify

; 2387 : 
; 2388 :     // We are not configured anymore
; 2389 :     // Let MDD process change
; 2390 :     pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_DETACH);

  00024	e5940024	 ldr         r0, [r4, #0x24]
  00028	e5943028	 ldr         r3, [r4, #0x28]
  0002c	e3a02000	 mov         r2, #0
  00030	e3a01001	 mov         r1, #1
  00034	e1a0e00f	 mov         lr, pc
  00038	e12fff13	 bx          r3

; 2391 :     // Set internal power state to D3
; 2392 :     pPdd->devState &= ~(MUSB_DEVSTAT_ATT | 
; 2393 :                         MUSB_DEVSTAT_B_HNP_ENABLE | 
; 2394 :                         MUSB_DEVSTAT_A_HNP_SUPPORT |
; 2395 :                         MUSB_DEVSTAT_A_ALT_HNP_SUPPORT);

  0003c	e594206c	 ldr         r2, [r4, #0x6C]
  00040	e3e03c03	 mvn         r3, #3, 24
  00044	e2233081	 eor         r3, r3, #0x81
  00048	e0023003	 and         r3, r2, r3

; 2396 : 
; 2397 :     pPdd->selfPowerState = D3;
; 2398 : 
; 2399 :     EnterCriticalSection(&pPdd->powerStateCS);

  0004c	e3a02003	 mov         r2, #3
  00050	e284008c	 add         r0, r4, #0x8C
  00054	e5842064	 str         r2, [r4, #0x64]
  00058	e584306c	 str         r3, [r4, #0x6C]
  0005c	eb000000	 bl          EnterCriticalSection

; 2400 :     pPdd->fPowerDown = TRUE;
; 2401 :     if(pPdd->dwUSBFNState == USBFN_ACTIVE)

  00060	e59430a8	 ldr         r3, [r4, #0xA8]
  00064	e3a02001	 mov         r2, #1
  00068	e58420a4	 str         r2, [r4, #0xA4]
  0006c	e3530001	 cmp         r3, #1

; 2402 :     {
; 2403 :         LeaveCriticalSection(&pPdd->powerStateCS);

  00070	e284008c	 add         r0, r4, #0x8C
  00074	1a000004	 bne         |$LN3@Device_Dis|
  00078	eb000000	 bl          LeaveCriticalSection

; 2404 :         WaitForSingleObject(pPdd->hPowerDownEvent,INFINITE);

  0007c	e59400a0	 ldr         r0, [r4, #0xA0]
  00080	e3e01000	 mvn         r1, #0
  00084	eb000000	 bl          WaitForSingleObject

; 2405 :     }
; 2406 :     else

  00088	ea000000	 b           |$LN2@Device_Dis|
  0008c		 |$LN3@Device_Dis|

; 2407 :     {
; 2408 :         LeaveCriticalSection(&pPdd->powerStateCS);

  0008c	eb000000	 bl          LeaveCriticalSection
  00090		 |$LN2@Device_Dis|

; 2409 :     }
; 2410 :     if ((pOTG->connect_status & CONN_DC) == 0x00)

  00090	e5d5304c	 ldrb        r3, [r5, #0x4C]
  00094	e3130004	 tst         r3, #4

; 2411 :     {
; 2412 :         DEBUGMSG(ZONE_INFO, (TEXT("Client Mode Complete Disconnect\r\n")));
; 2413 :         pOTG->connect_status |= CONN_DC;
; 2414 :         SetEvent(pOTG->hSysIntrEvent);

  00098	05950054	 ldreq       r0, [r5, #0x54]
  0009c	03833004	 orreq       r3, r3, #4
  000a0	03a01003	 moveq       r1, #3
  000a4	05c5304c	 streqb      r3, [r5, #0x4C]
  000a8	0b000000	 bleq        EventModify

; 2415 :     }
; 2416 :     
; 2417 :     return ERROR_SUCCESS;

  000ac	e3a00000	 mov         r0, #0

; 2418 : }

  000b0	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000b4	e12fff1e	 bx          lr
  000b8		 |$M49410|

			 ENDP  ; |Device_Disconnect|


  00000			 AREA	 |.pdata|, PDATA
|$T49421| DCD	|$LN5@Device_Sus|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Device_Suspend| PROC

; 2436 : {

  00000		 |$LN5@Device_Sus|
  00000		 |$M49418|

; 2437 : 	UNREFERENCED_PARAMETER(pHSMUSBContext);
; 2438 : 
; 2439 :     return ERROR_INVALID_PARAMETER;

  00000	e3a00057	 mov         r0, #0x57

; 2440 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M49419|

			 ENDP  ; |Device_Suspend|

	EXPORT	|UfnPdd_PowerDown|

  00000			 AREA	 |.pdata|, PDATA
|$T49428| DCD	|$LN5@UfnPdd_Pow|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_PowerDown| PROC

; 2462 : {

  00000		 |$LN5@UfnPdd_Pow|
  00000		 |$M49425|

; 2463 : 	UNREFERENCED_PARAMETER(pPddContext);
; 2464 : 
; 2465 :     DEBUGMSG(ZONE_INFO, (TEXT("+UfnPdd_PowerDown\r\n")));
; 2466 : #if 0
; 2467 :     MUsbFnPdd_t *pPdd = pPddContext;
; 2468 :     PHSMUSB_T pOTG = (PHSMUSB_T)(pPdd->pUSBContext);
; 2469 :     DWORD currtime;
; 2470 :     DWORD starttime;
; 2471 : 
; 2472 : 
; 2473 :     if (pOTG->operateMode != DEVICE_MODE)
; 2474 :     {
; 2475 :         DEBUGMSG(ZONE_INFO, (TEXT("UfnPdd_PowerDown not in device mode, it is %d\r\n"), pOTG->operateMode));
; 2476 :         return;
; 2477 :     }
; 2478 : 
; 2479 :     /*
; 2480 :         Don't handle this musbotg.dll takes care of the clocks.
; 2481 :     */
; 2482 : 
; 2483 :     //CLRREG8(&pOTG->pUsbGenRegs->DevCtl, DEVCTL_SESSION);
; 2484 :     //RETAILMSG(1, (TEXT("DevCtl Power Down = 0x%x\r\n"), INREG8(&pOTG->pUsbGenRegs->DevCtl)));
; 2485 :     //CLRREG8(&pOTG->pUsbGenRegs->Power, POWER_SOFTCONN);
; 2486 :     //SETREG8(&pOTG->pUsbGenRegs->Power, POWER_EN_SUSPENDM);
; 2487 :     //RETAILMSG(1, (TEXT("Clear the Soft Conn\r\n")));
; 2488 :     pPdd->pfnEnUSBClock(FALSE);
; 2489 : 
; 2490 :     // Wait for one second
; 2491 :     starttime = GetTickCount();
; 2492 :     do {
; 2493 :         currtime = GetTickCount();
; 2494 :         if (currtime < starttime)
; 2495 :             starttime = currtime;
; 2496 :     } while (currtime - starttime < 1000);
; 2497 : #endif
; 2498 :     DEBUGMSG(ZONE_INFO, (TEXT("-UfnPdd_POwerDown\r\n")));
; 2499 : }

  00000	e12fff1e	 bx          lr
  00004		 |$M49426|

			 ENDP  ; |UfnPdd_PowerDown|

	EXPORT	|UfnPdd_PowerUp|

  00000			 AREA	 |.pdata|, PDATA
|$T49435| DCD	|$LN5@UfnPdd_Pow@2|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_PowerUp| PROC

; 2521 : {

  00000		 |$LN5@UfnPdd_Pow@2|
  00000		 |$M49432|

; 2522 : 	UNREFERENCED_PARAMETER(pPddContext);
; 2523 : 
; 2524 :     /*
; 2525 :         DONOT handle here musbotg.dll takes care of clocks.
; 2526 :     */
; 2527 : #if 0
; 2528 :     MUsbFnPdd_t *pPdd = pPddContext;
; 2529 :     PHSMUSB_T pOTG = (PHSMUSB_T)(pPdd->pUSBContext);
; 2530 : 
; 2531 :     if (pOTG->operateMode != DEVICE_MODE)
; 2532 :         return;
; 2533 : 
; 2534 :     DEBUGMSG(ZONE_POWER, (L"UfnPdd_PowerUp\r\n"));
; 2535 :     RETAILMSG(TRUE, (L"UfnPdd_PowerUp\r\n"));
; 2536 :     pPdd->pfnEnUSBClock(TRUE);
; 2537 : 
; 2538 :     SETREG8(&pOTG->pUsbGenRegs->Power, POWER_SOFTCONN);
; 2539 : #endif
; 2540 : }

  00000	e12fff1e	 bx          lr
  00004		 |$M49433|

			 ENDP  ; |UfnPdd_PowerUp|

	EXPORT	|UfnPdd_IssueTransfer|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T49457| DCD	|$LN21@UfnPdd_Iss|
	DCD	0x40004501
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbfn\pdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_IssueTransfer| PROC

; 2566 : {

  00000		 |$LN21@UfnPdd_Iss|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M49454|
  00004	e1a05002	 mov         r5, r2
  00008	e1a06001	 mov         r6, r1
  0000c	e1a04000	 mov         r4, r0

; 2567 :     DWORD rc = ERROR_INVALID_PARAMETER;
; 2568 :     MUsbFnPdd_t *pPdd = pPddContext;
; 2569 :     PHSMUSB_T pUSBContext =(PHSMUSB_T) pPdd->pUSBContext;
; 2570 :     PCSP_MUSB_CSR_REGS pCsrRegs = pUSBContext->pUsbCsrRegs;

  00010	e5943020	 ldr         r3, [r4, #0x20]

; 2571 :     
; 2572 :     
; 2573 :     DEBUGMSG(ZONE_FUNCTION, (L"UfnPdd_IssueTransfer\r\n"));
; 2574 :     
; 2575 :     EnterCriticalSection(&pPdd->powerStateCS);

  00014	e284008c	 add         r0, r4, #0x8C
  00018	e593701c	 ldr         r7, [r3, #0x1C]
  0001c	eb000000	 bl          EnterCriticalSection

; 2576 :     if(pPdd->fPowerDown == TRUE)

  00020	e59430a4	 ldr         r3, [r4, #0xA4]
  00024	e3530001	 cmp         r3, #1
  00028	03a03c01	 moveq       r3, #1, 24

; 2577 :     {
; 2578 :         pTransfer->dwUsbError = UFN_CANCELED_ERROR;

  0002c	03833001	 orreq       r3, r3, #1
  00030	05853014	 streq       r3, [r5, #0x14]
  00034	03a05000	 moveq       r5, #0
  00038	0a000030	 beq         |$LN15@UfnPdd_Iss|

; 2579 :         LeaveCriticalSection(&pPdd->powerStateCS);
; 2580 :         return ERROR_SUCCESS;
; 2581 : 
; 2582 :     }
; 2583 :     else
; 2584 :     {
; 2585 :         pPdd->dwUSBFNState = USBFN_ACTIVE;

  0003c	e3a03001	 mov         r3, #1

; 2586 :         LeaveCriticalSection(&pPdd->powerStateCS);

  00040	e284008c	 add         r0, r4, #0x8C
  00044	e58430a8	 str         r3, [r4, #0xA8]
  00048	eb000000	 bl          LeaveCriticalSection

; 2587 :     }
; 2588 : 
; 2589 :     if (pTransfer == NULL) 

  0004c	e3550000	 cmp         r5, #0

; 2590 :     {
; 2591 :         DEBUGMSG(ZONE_ERROR, (L"UfnPdd_IssueTransfer:  error pTransfer is NULL\r\n"));
; 2592 :         return ERROR_INVALID_PARAMETER;

  00050	03a05057	 moveq       r5, #0x57
  00054	0a00002b	 beq         |$LN11@UfnPdd_Iss|

; 2593 :     }    
; 2594 :     
; 2595 :     // Save transfer for interrupt thread
; 2596 :     ASSERT(pPdd->ep[endpoint].pTransfer == NULL);
; 2597 :     pPdd->ep[endpoint].pTransfer = pTransfer;

  00058	e3a03034	 mov         r3, #0x34
  0005c	e0224396	 mla         r2, r6, r3, r4

; 2598 :     
; 2599 :     // If transfer buffer is NULL length must be zero
; 2600 :     if (pTransfer->pvBuffer == NULL)

  00060	e3a08000	 mov         r8, #0
  00064	e58250cc	 str         r5, [r2, #0xCC]
  00068	e5953004	 ldr         r3, [r5, #4]
  0006c	e3530000	 cmp         r3, #0

; 2601 :         pTransfer->cbBuffer = 0;

  00070	0585800c	 streq       r8, [r5, #0xC]

; 2602 :     
; 2603 :     DEBUGMSG(ZONE_FUNCTION, (TEXT("IssueTransfer: ep(%d), length(%d), (%s) max packet(%d)\r\n"), 
; 2604 :         endpoint, pTransfer->cbBuffer, (TRANSFER_IS_IN(pTransfer)? TEXT("IN"): TEXT("OUT")), pPdd->ep[endpoint].maxPacketSize));
; 2605 : 
; 2606 :     DEBUGCHK(pTransfer->dwUsbError == UFN_NOT_COMPLETE_ERROR);
; 2607 :     
; 2608 :     if ((endpoint == 0) &&(pPdd->ep0State == EP0_ST_SETUP_PROCESSED))

  00074	e3560000	 cmp         r6, #0
  00078	059433ec	 ldreq       r3, [r4, #0x3EC]
  0007c	03530001	 cmpeq       r3, #1

; 2609 :     {
; 2610 :         SETREG16(&pCsrRegs->ep[endpoint].CSR.CSR0, CSR0_P_SERVICEDRXPKTRDY);

  00080	01d730b2	 ldreqh      r3, [r7, #2]
  00084	03833040	 orreq       r3, r3, #0x40
  00088	01c730b2	 streqh      r3, [r7, #2]

; 2611 :     }
; 2612 :     
; 2613 :     // Depending on direction
; 2614 :     if (TRANSFER_IS_IN(pTransfer))

  0008c	e5953000	 ldr         r3, [r5]
  00090	e3130080	 tst         r3, #0x80
  00094	0a00000c	 beq         |$LN5@UfnPdd_Iss|

; 2615 :     {
; 2616 : 
; 2617 :        // don't send zeroLength data (see if USB mass storage works)
; 2618 :         if(pPdd->ep[endpoint].bMassStore)

  00098	e59230b8	 ldr         r3, [r2, #0xB8]
  0009c	e3530000	 cmp         r3, #0

; 2619 :         {
; 2620 :             pPdd->ep[endpoint].zeroLength = FALSE;

  000a0	158280b4	 strne       r8, [r2, #0xB4]
  000a4	1a000004	 bne         |$LN3@UfnPdd_Iss|

; 2621 :         }
; 2622 :         else
; 2623 :         {
; 2624 :             pPdd->ep[endpoint].zeroLength =(pTransfer->cbBuffer == 0);

  000a8	e595300c	 ldr         r3, [r5, #0xC]
  000ac	e3530000	 cmp         r3, #0
  000b0	03a03001	 moveq       r3, #1
  000b4	13a03000	 movne       r3, #0
  000b8	e58230b4	 str         r3, [r2, #0xB4]
  000bc		 |$LN3@UfnPdd_Iss|

; 2625 :         }
; 2626 : 
; 2627 :             rc = ContinueTxDmaTransfer(pPdd, endpoint);

  000bc	e1a01006	 mov         r1, r6
  000c0	e1a00004	 mov         r0, r4
  000c4	eb000000	 bl          ContinueTxDmaTransfer

; 2628 :         }
; 2629 :         else

  000c8	ea000003	 b           |$LN18@UfnPdd_Iss|
  000cc		 |$LN5@UfnPdd_Iss|

; 2630 :         {
; 2631 :         pPdd->ep[endpoint].zeroLength = FALSE;
; 2632 :             rc = StartRxDmaTransfer(pPdd, endpoint);

  000cc	e1a01006	 mov         r1, r6
  000d0	e1a00004	 mov         r0, r4
  000d4	e58280b4	 str         r8, [r2, #0xB4]
  000d8	eb000000	 bl          StartRxDmaTransfer
  000dc		 |$LN18@UfnPdd_Iss|
  000dc	e1a05000	 mov         r5, r0

; 2633 :         }
; 2634 : 
; 2635 :     EnterCriticalSection(&pPdd->powerStateCS);

  000e0	e284008c	 add         r0, r4, #0x8C
  000e4	eb000000	 bl          EnterCriticalSection

; 2636 :     pPdd->dwUSBFNState = USBFN_IDLE;
; 2637 :     if(pPdd->fPowerDown == TRUE)

  000e8	e59430a4	 ldr         r3, [r4, #0xA4]
  000ec	e58480a8	 str         r8, [r4, #0xA8]
  000f0	e3530001	 cmp         r3, #1

; 2638 :     {
; 2639 :         SetEvent(pPdd->hPowerDownEvent);

  000f4	059400a0	 ldreq       r0, [r4, #0xA0]
  000f8	03a01003	 moveq       r1, #3
  000fc	0b000000	 bleq        EventModify
  00100		 |$LN15@UfnPdd_Iss|
  00100	e284008c	 add         r0, r4, #0x8C
  00104	eb000000	 bl          LeaveCriticalSection
  00108		 |$LN11@UfnPdd_Iss|

; 2640 :     }
; 2641 :     LeaveCriticalSection(&pPdd->powerStateCS);
; 2642 :     
; 2643 :     return rc;
; 2644 :     
; 2645 :     //    return ERROR_SUCCESS;
; 2646 : }

  00108	e1a00005	 mov         r0, r5
  0010c	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00110	e12fff1e	 bx          lr
  00114		 |$M49455|

			 ENDP  ; |UfnPdd_IssueTransfer|

	EXPORT	|UfnPdd_AbortTransfer|

  00000			 AREA	 |.pdata|, PDATA
|$T49474| DCD	|$LN19@UfnPdd_Abo|
	DCD	0x40005701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_AbortTransfer| PROC

; 2672 : {

  00000		 |$LN19@UfnPdd_Abo|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M49471|
  00004	e1a08002	 mov         r8, r2
  00008	e1a05001	 mov         r5, r1
  0000c	e1a04000	 mov         r4, r0

; 2673 :     MUsbFnPdd_t *pPdd = pPddContext;
; 2674 :     PCSP_MUSB_CSR_REGS pCsrRegs = pPdd->pUSBContext->pUsbCsrRegs;

  00010	e5947020	 ldr         r7, [r4, #0x20]

; 2675 :     PHSMUSB_T pOTG = pPdd->pUSBContext;
; 2676 : 
; 2677 :     EnterCriticalSection(&pOTG->regCS);

  00014	e597601c	 ldr         r6, [r7, #0x1C]
  00018	e2870038	 add         r0, r7, #0x38
  0001c	eb000000	 bl          EnterCriticalSection

; 2678 :     if(pOTG->bClockStatus)

  00020	e5973060	 ldr         r3, [r7, #0x60]
  00024	e3530000	 cmp         r3, #0
  00028	0a000023	 beq         |$LN5@UfnPdd_Abo|

; 2679 :     {
; 2680 :     if (endpoint == 0)

  0002c	e3550000	 cmp         r5, #0

; 2681 :     {
; 2682 :         SETREG16(&pCsrRegs->ep[endpoint].CSR.CSR0, CSR0_P_FLUSHFIFO);

  00030	01d630b2	 ldreqh      r3, [r6, #2]
  00034	03833c01	 orreq       r3, r3, #1, 24
  00038	01c630b2	 streqh      r3, [r6, #2]
  0003c	0a00000a	 beq         |$LN8@UfnPdd_Abo|

; 2683 :     }
; 2684 :     else
; 2685 :     {
; 2686 :         MUsbFnEp_t *pEP = &pPdd->ep[endpoint];
; 2687 : 
; 2688 :         if (pEP->dirRx)

  00040	e3a03034	 mov         r3, #0x34
  00044	e0234395	 mla         r3, r5, r3, r4

; 2689 :             SETREG16(&pCsrRegs->ep[endpoint].RxCSR, RXCSR_P_FLUSHFIFO);

  00048	e0862205	 add         r2, r6, r5, lsl #4
  0004c	e59330b0	 ldr         r3, [r3, #0xB0]
  00050	e3530000	 cmp         r3, #0
  00054	11d230b6	 ldrneh      r3, [r2, #6]
  00058	13833010	 orrne       r3, r3, #0x10
  0005c	11c230b6	 strneh      r3, [r2, #6]

; 2690 :         else
; 2691 :             SETREG16(&pCsrRegs->ep[endpoint].CSR.TxCSR, TXCSR_P_FLUSHFIFO);

  00060	01d230b2	 ldreqh      r3, [r2, #2]
  00064	03833008	 orreq       r3, r3, #8
  00068	01c230b2	 streqh      r3, [r2, #2]
  0006c		 |$LN8@UfnPdd_Abo|

; 2692 :     }
; 2693 : 
; 2694 :     if ((pPdd->rx0DmaEp == endpoint) && (pPdd->ep[endpoint].dmaEnabled))

  0006c	e594300c	 ldr         r3, [r4, #0xC]
  00070	e1530005	 cmp         r3, r5
  00074	1a000005	 bne         |$LN7@UfnPdd_Abo|
  00078	e3a03034	 mov         r3, #0x34
  0007c	e0234395	 mla         r3, r5, r3, r4
  00080	e59330bc	 ldr         r3, [r3, #0xBC]
  00084	e3530000	 cmp         r3, #0

; 2695 :         ResetDMAChannel(pPdd, MUSB_RX_DMA_CHN);

  00088	13a01001	 movne       r1, #1
  0008c	1a000008	 bne         |$LN15@UfnPdd_Abo|
  00090		 |$LN7@UfnPdd_Abo|

; 2696 :     else if ((pPdd->tx0DmaEp == endpoint) && (pPdd->ep[endpoint].dmaEnabled))

  00090	e5943010	 ldr         r3, [r4, #0x10]
  00094	e1530005	 cmp         r3, r5
  00098	1a000007	 bne         |$LN5@UfnPdd_Abo|
  0009c	e3a03034	 mov         r3, #0x34
  000a0	e0234395	 mla         r3, r5, r3, r4
  000a4	e59330bc	 ldr         r3, [r3, #0xBC]
  000a8	e3530000	 cmp         r3, #0
  000ac	0a000002	 beq         |$LN5@UfnPdd_Abo|

; 2697 :         ResetDMAChannel(pPdd, MUSB_TX_DMA_CHN);

  000b0	e3a01000	 mov         r1, #0
  000b4		 |$LN15@UfnPdd_Abo|
  000b4	e1a00004	 mov         r0, r4
  000b8	eb000000	 bl          ResetDMAChannel
  000bc		 |$LN5@UfnPdd_Abo|

; 2698 :     }
; 2699 :     LeaveCriticalSection(&pOTG->regCS);

  000bc	e2870038	 add         r0, r7, #0x38
  000c0	eb000000	 bl          LeaveCriticalSection

; 2700 : 
; 2701 :     EnterCriticalSection(&pPdd->csDVFS);

  000c4	e2847b01	 add         r7, r4, #1, 22
  000c8	e2870014	 add         r0, r7, #0x14
  000cc	eb000000	 bl          EnterCriticalSection

; 2702 :     if ((pPdd->ep[endpoint].dmaDVFSstate == DVFS_PREDMA) && pPdd->ep[endpoint].dmaEnabled)

  000d0	e3a03034	 mov         r3, #0x34
  000d4	e0264395	 mla         r6, r5, r3, r4
  000d8	e5d630d8	 ldrb        r3, [r6, #0xD8]
  000dc	e3530001	 cmp         r3, #1
  000e0	1a00000b	 bne         |$LN2@UfnPdd_Abo|
  000e4	e59630bc	 ldr         r3, [r6, #0xBC]
  000e8	e3530000	 cmp         r3, #0
  000ec	0a000008	 beq         |$LN2@UfnPdd_Abo|

; 2703 :     {
; 2704 :         MUsbFnEp_t *pEP = &pPdd->ep[endpoint];
; 2705 :         pEP->dmaDVFSstate = DVFS_POSTDMA;
; 2706 :         if (pEP->dirRx)

  000f0	e59630b0	 ldr         r3, [r6, #0xB0]
  000f4	e3a02002	 mov         r2, #2
  000f8	e5c620d8	 strb        r2, [r6, #0xD8]
  000fc	e3530000	 cmp         r3, #0

; 2707 :             PostDmaDeactivation(pPdd, endpoint, RX_TRANSFER);

  00100	13a02001	 movne       r2, #1

; 2708 :         else
; 2709 :             PostDmaDeactivation(pPdd, endpoint, TX_TRANSFER);

  00104	03a02000	 moveq       r2, #0
  00108	e1a01005	 mov         r1, r5
  0010c	e1a00004	 mov         r0, r4
  00110	eb000000	 bl          PostDmaDeactivation
  00114		 |$LN2@UfnPdd_Abo|

; 2710 :     }
; 2711 :     LeaveCriticalSection(&pPdd->csDVFS);

  00114	e2870014	 add         r0, r7, #0x14
  00118	eb000000	 bl          LeaveCriticalSection

; 2712 : 
; 2713 :     // Finish transfer
; 2714 :     pPdd->ep[endpoint].pTransfer = NULL;

  0011c	e3a03000	 mov         r3, #0
  00120	e58630cc	 str         r3, [r6, #0xCC]

; 2715 :     if (pTransfer != NULL)

  00124	e3580000	 cmp         r8, #0
  00128	0a000008	 beq         |$LN1@UfnPdd_Abo|
  0012c	e3a03c01	 mov         r3, #1, 24

; 2716 :     {
; 2717 :         pTransfer->dwUsbError = UFN_CANCELED_ERROR;

  00130	e3833001	 orr         r3, r3, #1
  00134	e5883014	 str         r3, [r8, #0x14]

; 2718 :         DEBUGMSG(ZONE_INFO, (TEXT("UfnPdd_AbortTransfer for EP %d\r\n"), endpoint));
; 2719 :         pPdd->pfnNotify(
; 2720 :            pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer
; 2721 :            );

  00138	e5940024	 ldr         r0, [r4, #0x24]
  0013c	e5943028	 ldr         r3, [r4, #0x28]
  00140	e1a02008	 mov         r2, r8
  00144	e3a01064	 mov         r1, #0x64
  00148	e1a0e00f	 mov         lr, pc
  0014c	e12fff13	 bx          r3
  00150		 |$LN1@UfnPdd_Abo|

; 2722 :     }
; 2723 :     
; 2724 :     
; 2725 :     // Done
; 2726 :     return ERROR_SUCCESS;

  00150	e3a00000	 mov         r0, #0

; 2727 : }

  00154	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00158	e12fff1e	 bx          lr
  0015c		 |$M49472|

			 ENDP  ; |UfnPdd_AbortTransfer|

	EXPORT	|UfnPdd_StallEndpoint|

  00000			 AREA	 |.pdata|, PDATA
|$T49488| DCD	|$LN10@UfnPdd_Sta|
	DCD	0x40001801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_StallEndpoint| PROC

; 2751 : {

  00000		 |$LN10@UfnPdd_Sta|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M49485|
  00004	e3510000	 cmp         r1, #0

; 2752 :     MUsbFnPdd_t *pPdd = pPddContext;
; 2753 :     MUsbFnEp_t *pEP = &pPdd->ep[endpoint];

  00008	e3a03034	 mov         r3, #0x34
  0000c	e02e0391	 mla         lr, r1, r3, r0

; 2754 :     PCSP_MUSB_CSR_REGS pCsrRegs = pPdd->pUSBContext->pUsbCsrRegs;

  00010	e5903020	 ldr         r3, [r0, #0x20]
  00014	e593201c	 ldr         r2, [r3, #0x1C]

; 2755 :     
; 2756 :     DEBUGMSG(ZONE_FUNCTION, (L"UfnPdd_StallEndpoint\r\n"));
; 2757 : 
; 2758 :     DEBUGMSG(ZONE_INFO, (L"*** UfnPdd_StallEndpoint  endpoint %d\r\n",endpoint));
; 2759 :     
; 2760 :     if (endpoint == 0)
; 2761 :     {
; 2762 :         // Stall next EP0 transaction
; 2763 :         SETREG16(&pCsrRegs->ep[endpoint].CSR.CSR0, CSR0_P_SENDSTALL);

  00018	01d230b2	 ldreqh      r3, [r2, #2]
  0001c	03833020	 orreq       r3, r3, #0x20
  00020	0a000008	 beq         |$LN7@UfnPdd_Sta|

; 2764 :     }
; 2765 :     else
; 2766 :     {
; 2767 :         
; 2768 :         // stall end point
; 2769 :         if (pEP->dirRx)

  00024	e59e30b0	 ldr         r3, [lr, #0xB0]

; 2770 :             SETREG16(&pCsrRegs->ep[endpoint].RxCSR, RXCSR_P_SENDSTALL);        

  00028	e0822201	 add         r2, r2, r1, lsl #4
  0002c	e3530000	 cmp         r3, #0
  00030	11d230b6	 ldrneh      r3, [r2, #6]
  00034	13833020	 orrne       r3, r3, #0x20
  00038	11c230b6	 strneh      r3, [r2, #6]
  0003c	1a000002	 bne         |$LN1@UfnPdd_Sta|

; 2771 :         else
; 2772 :             SETREG16(&pCsrRegs->ep[endpoint].CSR.TxCSR, TXCSR_P_SENDSTALL);        

  00040	e1d230b2	 ldrh        r3, [r2, #2]
  00044	e3833010	 orr         r3, r3, #0x10
  00048		 |$LN7@UfnPdd_Sta|
  00048	e1c230b2	 strh        r3, [r2, #2]
  0004c		 |$LN1@UfnPdd_Sta|

; 2773 :         
; 2774 :     }
; 2775 :     pEP->stalled = TRUE;

  0004c	e3a03001	 mov         r3, #1
  00050	e58e30c0	 str         r3, [lr, #0xC0]

; 2776 :     
; 2777 :     // Done
; 2778 :     return ERROR_SUCCESS;

  00054	e3a00000	 mov         r0, #0

; 2779 : }

  00058	e49de004	 ldr         lr, [sp], #4
  0005c	e12fff1e	 bx          lr
  00060		 |$M49486|

			 ENDP  ; |UfnPdd_StallEndpoint|

	EXPORT	|UfnPdd_ClearEndpointStall|

  00000			 AREA	 |.pdata|, PDATA
|$T49503| DCD	|$LN11@UfnPdd_Cle|
	DCD	0x40002501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_ClearEndpointStall| PROC

; 2803 : {

  00000		 |$LN11@UfnPdd_Cle|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M49500|
  00004	e3510000	 cmp         r1, #0

; 2804 :     MUsbFnPdd_t *pPdd = pPddContext;
; 2805 :     MUsbFnEp_t *pEP = &pPdd->ep[endpoint];

  00008	e3a03034	 mov         r3, #0x34
  0000c	e02e0391	 mla         lr, r1, r3, r0

; 2806 :     PCSP_MUSB_CSR_REGS pCsrRegs = pPdd->pUSBContext->pUsbCsrRegs;

  00010	e5903020	 ldr         r3, [r0, #0x20]
  00014	e593001c	 ldr         r0, [r3, #0x1C]

; 2807 :     UINT16 csrVal;
; 2808 :     
; 2809 :     DEBUGMSG(ZONE_FUNCTION, (L"UfnPdd_ClearEndpointStall for EP %d\r\n", endpoint));
; 2810 :     
; 2811 :     if (endpoint == 0)
; 2812 :     {
; 2813 :         CLRREG16(&pCsrRegs->ep[endpoint].CSR.CSR0, CSR0_P_SENTSTALL | CSR0_P_SENDSTALL);        

  00018	03a03cff	 moveq       r3, #0xFF, 24
  0001c	038330db	 orreq       r3, r3, #0xDB
  00020	01d020b2	 ldreqh      r2, [r0, #2]
  00024	00023003	 andeq       r3, r2, r3
  00028	01c030b2	 streqh      r3, [r0, #2]
  0002c	0a000013	 beq         |$LN1@UfnPdd_Cle|

; 2814 :     }
; 2815 :     else
; 2816 :     {
; 2817 :         // stall end point
; 2818 :         if (pEP->dirRx)

  00030	e59e30b0	 ldr         r3, [lr, #0xB0]

; 2819 :         {
; 2820 :             csrVal = INREG16(&pCsrRegs->ep[endpoint].RxCSR);

  00034	e0802201	 add         r2, r0, r1, lsl #4
  00038	e3530000	 cmp         r3, #0
  0003c	0a000008	 beq         |$LN4@UfnPdd_Cle|
  00040	e1d210b6	 ldrh        r1, [r2, #6]

; 2821 : 
; 2822 :             if(csrVal & RXCSR_P_SENTSTALL)

  00044	e3110040	 tst         r1, #0x40
  00048	0a00000c	 beq         |$LN1@UfnPdd_Cle|
  0004c	e3a03cff	 mov         r3, #0xFF, 24

; 2823 :             {
; 2824 :                 csrVal &= ~(RXCSR_P_SENDSTALL | RXCSR_P_SENTSTALL);

  00050	e383301f	 orr         r3, r3, #0x1F
  00054	e0013003	 and         r3, r1, r3

; 2825 :                 csrVal |= RXCSR_P_CLRDATATOG;

  00058	e3833080	 orr         r3, r3, #0x80

; 2826 : 
; 2827 :                 OUTREG16(&pCsrRegs->ep[endpoint].RxCSR, csrVal);

  0005c	e1c230b6	 strh        r3, [r2, #6]

; 2828 :             }
; 2829 :         }
; 2830 :         else

  00060	ea000006	 b           |$LN1@UfnPdd_Cle|
  00064		 |$LN4@UfnPdd_Cle|

; 2831 :         {
; 2832 :             csrVal = INREG16(&pCsrRegs->ep[endpoint].CSR.TxCSR);

  00064	e1d210b2	 ldrh        r1, [r2, #2]

; 2833 :                         					    
; 2834 : 			if (csrVal & TXCSR_P_SENTSTALL)

  00068	e3110020	 tst         r1, #0x20
  0006c	13a03cff	 movne       r3, #0xFF, 24

; 2835 :             {
; 2836 : 				csrVal &= ~(TXCSR_P_SENDSTALL | TXCSR_P_SENTSTALL);

  00070	1383308f	 orrne       r3, r3, #0x8F
  00074	10013003	 andne       r3, r1, r3

; 2837 :                 csrVal |= TXCSR_P_CLRDATATOG;

  00078	13833040	 orrne       r3, r3, #0x40

; 2838 : 
; 2839 :                 OUTREG16(&pCsrRegs->ep[endpoint].CSR.TxCSR, csrVal);

  0007c	11c230b2	 strneh      r3, [r2, #2]
  00080		 |$LN1@UfnPdd_Cle|

; 2840 :             }
; 2841 :         }
; 2842 :         
; 2843 :     }
; 2844 :     pEP->stalled = FALSE;

  00080	e3a03000	 mov         r3, #0
  00084	e58e30c0	 str         r3, [lr, #0xC0]

; 2845 :     
; 2846 :     return ERROR_SUCCESS;

  00088	e3a00000	 mov         r0, #0

; 2847 : }

  0008c	e49de004	 ldr         lr, [sp], #4
  00090	e12fff1e	 bx          lr
  00094		 |$M49501|

			 ENDP  ; |UfnPdd_ClearEndpointStall|

	EXPORT	|UfnPdd_IsEndpointHalted|

  00000			 AREA	 |.pdata|, PDATA
|$T49518| DCD	|$LN11@UfnPdd_IsE|
	DCD	0x40001401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_IsEndpointHalted| PROC

; 2869 : {

  00000		 |$LN11@UfnPdd_IsE|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M49515|
  00004	e3510000	 cmp         r1, #0

; 2870 :    
; 2871 :     MUsbFnPdd_t *pPdd = pPddContext;
; 2872 :     MUsbFnEp_t *pEP = &pPdd->ep[endpoint];
; 2873 :     PCSP_MUSB_CSR_REGS pCsrRegs = pPdd->pUSBContext->pUsbCsrRegs;

  00008	e5903020	 ldr         r3, [r0, #0x20]
  0000c	e593e01c	 ldr         lr, [r3, #0x1C]

; 2874 :     
; 2875 :     DEBUGMSG(ZONE_FUNCTION, (L"UfnPdd_IsEndpointHalted\r\n"));
; 2876 :         
; 2877 :     if (endpoint == 0)
; 2878 :     {
; 2879 :         *pHalted = INREG16(&pCsrRegs->ep[endpoint].CSR.CSR0) & CSR0_P_SENDSTALL;

  00010	01de30b2	 ldreqh      r3, [lr, #2]
  00014	02033020	 andeq       r3, r3, #0x20
  00018	0a000008	 beq         |$LN7@UfnPdd_IsE|

; 2880 :     }
; 2881 :     else
; 2882 :     {
; 2883 :         // stall end point
; 2884 :         if (pEP->dirRx)

  0001c	e3a03034	 mov         r3, #0x34
  00020	e0230391	 mla         r3, r1, r3, r0
  00024	e59330b0	 ldr         r3, [r3, #0xB0]
  00028	e3530000	 cmp         r3, #0

; 2885 :         {
; 2886 :             *pHalted = INREG16(&pCsrRegs->ep[endpoint].RxCSR) & RXCSR_P_SENDSTALL;

  0002c	e08e3201	 add         r3, lr, r1, lsl #4
  00030	11d330b6	 ldrneh      r3, [r3, #6]
  00034	12033020	 andne       r3, r3, #0x20

; 2887 :         }
; 2888 :         else
; 2889 :         {
; 2890 :             *pHalted = INREG16(&pCsrRegs->ep[endpoint].CSR.TxCSR) & TXCSR_P_SENDSTALL;

  00038	01d330b2	 ldreqh      r3, [r3, #2]
  0003c	02033010	 andeq       r3, r3, #0x10
  00040		 |$LN7@UfnPdd_IsE|
  00040	e5823000	 str         r3, [r2]

; 2891 :         }
; 2892 :     }
; 2893 :         
; 2894 :     // Done
; 2895 :     return ERROR_SUCCESS;

  00044	e3a00000	 mov         r0, #0

; 2896 : }

  00048	e49de004	 ldr         lr, [sp], #4
  0004c	e12fff1e	 bx          lr
  00050		 |$M49516|

			 ENDP  ; |UfnPdd_IsEndpointHalted|

	EXPORT	|UfnPdd_SendControlStatusHandshake|

  00000			 AREA	 |.pdata|, PDATA
|$T49531| DCD	|$LN13@UfnPdd_Sen|
	DCD	0x40001600
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_SendControlStatusHandshake| PROC

; 2920 : {

  00000		 |$LN13@UfnPdd_Sen|
  00000		 |$M49528|
  00000	e3510000	 cmp         r1, #0

; 2921 :     DWORD rc = ERROR_INVALID_PARAMETER;
; 2922 :     MUsbFnPdd_t *pPdd = pPddContext;
; 2923 :     PCSP_MUSB_CSR_REGS pCsrRegs = pPdd->pUSBContext->pUsbCsrRegs;

  00004	e5903020	 ldr         r3, [r0, #0x20]
  00008	e3a02057	 mov         r2, #0x57
  0000c	e593101c	 ldr         r1, [r3, #0x1C]

; 2924 :     
; 2925 :     DEBUGMSG(ZONE_FUNCTION, (L"+UfnPdd_SendControlStatusHandshake status = 0x%x\r\n", pPdd->ep0State));
; 2926 :     
; 2927 :     if (endpoint == 0)

  00010	1a00000e	 bne         |$LN8@UfnPdd_Sen|

; 2928 :     {
; 2929 :         if (pPdd->ep0State == EP0_ST_SETUP_PROCESSED)

  00014	e59033ec	 ldr         r3, [r0, #0x3EC]
  00018	e3530001	 cmp         r3, #1

; 2930 :         {
; 2931 :             DEBUGMSG(ZONE_INFO, (TEXT("SETUP_PROCESSED => STATUS_IN\r\n")));
; 2932 :             SETREG16(&pCsrRegs->ep[endpoint].CSR.CSR0, CSR0_P_SERVICEDRXPKTRDY | CSR0_P_DATAEND);

  0001c	01d130b2	 ldreqh      r3, [r1, #2]

; 2933 :             // Send zero byte to ack
; 2934 :             SETREG16(&pCsrRegs->ep[endpoint].CSR.CSR0, CSR0_P_TXPKTRDY);
; 2935 :             pPdd->ep0State = EP0_ST_STATUS_IN;

  00020	03a02002	 moveq       r2, #2
  00024	03833048	 orreq       r3, r3, #0x48
  00028	01c130b2	 streqh      r3, [r1, #2]
  0002c	01d130b2	 ldreqh      r3, [r1, #2]
  00030	03833002	 orreq       r3, r3, #2
  00034	01c130b2	 streqh      r3, [r1, #2]
  00038	058023ec	 streq       r2, [r0, #0x3EC]

; 2936 :         }
; 2937 : 
; 2938 :         // Send out zero byte data
; 2939 :         if (pPdd->ep0State == EP0_ST_STATUS_IN)
; 2940 :         {
; 2941 :             DEBUGMSG(ZONE_INFO, (L"Status In Phase\r\n"));
; 2942 :             DEBUGMSG(ZONE_INFO, (TEXT("1. Set TxPktRdy - 0\r\n")));
; 2943 :         }
; 2944 :         else if (pPdd->ep0State == EP0_ST_STATUS_OUT)
; 2945 :         {
; 2946 :             DEBUGMSG(ZONE_INFO, (L"Status Out Phase\r\n"));
; 2947 :         }
; 2948 :         else
; 2949 :             DEBUGMSG(ZONE_INFO, (L"SendControlStatusHandshake error with state %d\r\n", 
; 2950 :             pPdd->ep0State));
; 2951 :         if (pPdd->ep0State == EP0_ST_STATUS_OUT)

  0003c	e59033ec	 ldr         r3, [r0, #0x3EC]

; 2952 :             pPdd->ep0State = EP0_ST_SETUP;
; 2953 :         DEBUGMSG(ZONE_INFO, (L"Complete\r\n"));
; 2954 :         rc = ERROR_SUCCESS;

  00040	e3a02000	 mov         r2, #0
  00044	e3530003	 cmp         r3, #3
  00048	03a03000	 moveq       r3, #0
  0004c	058033ec	 streq       r3, [r0, #0x3EC]
  00050		 |$LN8@UfnPdd_Sen|

; 2955 :         
; 2956 :         prtEP0State(pPdd);
; 2957 :     }
; 2958 :     else
; 2959 :         DEBUGMSG(ZONE_INFO, (L"!!! UfnPdd_SendControlStatusHandshake called with endpoint %d\r\n", endpoint));
; 2960 :     
; 2961 :     DEBUGMSG(ZONE_FUNCTION, (L"-UfnPdd_SendControlStatusHandshake\r\n"));
; 2962 :     
; 2963 :     return rc;
; 2964 : }

  00050	e1a00002	 mov         r0, r2
  00054	e12fff1e	 bx          lr
  00058		 |$M49529|

			 ENDP  ; |UfnPdd_SendControlStatusHandshake|

	EXPORT	|UfnPdd_InitiateRemoteWakeup|

  00000			 AREA	 |.pdata|, PDATA
|$T49540| DCD	|$LN5@UfnPdd_Ini|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_InitiateRemoteWakeup| PROC

; 2987 : {

  00000		 |$LN5@UfnPdd_Ini|
  00000		 |$M49537|

; 2988 : 	UNREFERENCED_PARAMETER(pPddContext);
; 2989 : 
; 2990 :     DEBUGMSG(ZONE_FUNCTION, (L"UfnPdd_InitiateRemoteWakeup\r\n"));
; 2991 :     return ERROR_INVALID_PARAMETER;

  00000	e3a00057	 mov         r0, #0x57

; 2992 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M49538|

			 ENDP  ; |UfnPdd_InitiateRemoteWakeup|

	EXPORT	|UfnPdd_IOControl|
	IMPORT	|CeSafeCopyMemory|

  00000			 AREA	 |.pdata|, PDATA
|$T49557| DCD	|$LN20@UfnPdd_IOC|
	DCD	0x40003502
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_IOControl| PROC

; 3024 : {

  00000		 |$LN20@UfnPdd_IOC|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M49554|
  00008	e1a05003	 mov         r5, r3
  0000c	e1a06000	 mov         r6, r0
  00010	e3a03822	 mov         r3, #0x22, 16

; 3025 :     DWORD rc = ERROR_INVALID_PARAMETER;
; 3026 :     MUsbFnPdd_t *pPdd = pPddContext;
; 3027 :     UFN_PDD_INFO info;
; 3028 :     CE_BUS_POWER_STATE *pBusPowerState;
; 3029 : 
; 3030 : 	UNREFERENCED_PARAMETER(pOutSize);
; 3031 : 
; 3032 :     DEBUGMSG(ZONE_FUNCTION, (L"UfnPdd_IOControl\r\n"));
; 3033 :     
; 3034 :     switch (code)

  00014	e383ef65	 orr         lr, r3, #0x65, 30
  00018	e152000e	 cmp         r2, lr
  0001c	e3a04057	 mov         r4, #0x57
  00020	0a000013	 beq         |$LN11@UfnPdd_IOC|
  00024	e3a0382a	 mov         r3, #0x2A, 16
  00028	e383e00c	 orr         lr, r3, #0xC
  0002c	e152000e	 cmp         r2, lr
  00030	0a000004	 beq         |$LN6@UfnPdd_IOC|
  00034	e3a0382a	 mov         r3, #0x2A, 16
  00038	e3833010	 orr         r3, r3, #0x10
  0003c	e1520003	 cmp         r2, r3
  00040	1a00001f	 bne         |$LN8@UfnPdd_IOC|

; 3096 :         case IOCTL_BUS_SET_POWER_STATE:
; 3097 : #if 0
; 3098 :             if (source == MDD_IOCTL)
; 3099 :                 break;
; 3100 :             if (pInBuffer == NULL || inSize < sizeof(CE_BUS_POWER_STATE))
; 3101 :                 break;
; 3102 :             pBusPowerState =(CE_BUS_POWER_STATE*)pInBuffer;
; 3103 :             if (!CeSafeCopyMemory(
; 3104 :                 &devicePowerState, pBusPowerState->lpceDevicePowerState,
; 3105 :                 sizeof(CEDEVICE_POWER_STATE)
; 3106 :                 ))
; 3107 :                 break;
; 3108 :             SetPowerState(pPdd , devicePowerState);
; 3109 : #endif
; 3110 :             rc = ERROR_SUCCESS;
; 3111 :             break;

  00044	ea00001d	 b           |$LN16@UfnPdd_IOC|
  00048		 |$LN6@UfnPdd_IOC|

; 3082 :             break;
; 3083 :         case IOCTL_BUS_GET_POWER_STATE:
; 3084 :             if (source != MDD_IOCTL)

  00048	e3510002	 cmp         r1, #2
  0004c	1a00001c	 bne         |$LN8@UfnPdd_IOC|

; 3085 :                 break;
; 3086 :             if (pInBuffer == NULL || inSize < sizeof(CE_BUS_POWER_STATE))

  00050	e3550000	 cmp         r5, #0
  00054	0a00001a	 beq         |$LN8@UfnPdd_IOC|
  00058	e59d301c	 ldr         r3, [sp, #0x1C]
  0005c	e353000c	 cmp         r3, #0xC
  00060	3a000017	 bcc         |$LN8@UfnPdd_IOC|

; 3087 :                 break;
; 3088 :             pBusPowerState =(CE_BUS_POWER_STATE*)pInBuffer;
; 3089 :             if (!CeSafeCopyMemory(
; 3090 :                 pBusPowerState->lpceDevicePowerState, &pPdd->pmPowerState,
; 3091 :                 sizeof(CEDEVICE_POWER_STATE)
; 3092 :                 ))

  00064	e5950004	 ldr         r0, [r5, #4]
  00068	e3a02004	 mov         r2, #4
  0006c	e2861060	 add         r1, r6, #0x60

; 3093 :                 break;
; 3094 :             rc = ERROR_SUCCESS;
; 3095 :             break;

  00070	ea00000f	 b           |$LN17@UfnPdd_IOC|
  00074		 |$LN11@UfnPdd_IOC|

; 3035 :     {
; 3036 : 
; 3037 : #if 0  // WM7 specific
; 3038 :         case IOCTL_UFN_PDD_SET_INTERFACE: {
; 3039 :             DWORD dwParam;
; 3040 :             DWORD dwInterface;
; 3041 :             DWORD dwAlternateSetting;
; 3042 : 
; 3043 :             if ( source != BUS_IOCTL ||
; 3044 :                  pOutBuffer != NULL || outSize != 0 ||
; 3045 :                  pInBuffer == NULL || inSize != sizeof(DWORD) ) {
; 3046 :                 break;
; 3047 :             }
; 3048 : 
; 3049 :             dwParam = *(DWORD*)pInBuffer;
; 3050 :             dwInterface = UFN_GET_INTERFACE_NUMBER( dwParam );
; 3051 :             dwAlternateSetting = UFN_GET_INTERFACE_ALTERNATE_SETTING( dwParam );
; 3052 :             break;
; 3053 :         }
; 3054 : 
; 3055 :         case IOCTL_UFN_PDD_SET_CONFIGURATION: {
; 3056 :             DWORD dwConfiguration;
; 3057 : 
; 3058 :             if ( source != BUS_IOCTL ||
; 3059 :                  pOutBuffer != NULL || outSize != 0 ||
; 3060 :                  pInBuffer == NULL || inSize != sizeof(DWORD) ) {
; 3061 :                 break;
; 3062 :             }
; 3063 : 
; 3064 :             dwConfiguration = *(DWORD*)pInBuffer;
; 3065 : 
; 3066 :             break;
; 3067 :         }
; 3068 : #endif
; 3069 :         case IOCTL_UFN_GET_PDD_INFO:
; 3070 :             if (source != BUS_IOCTL)

  00074	e3510000	 cmp         r1, #0
  00078	1a000011	 bne         |$LN8@UfnPdd_IOC|

; 3071 :                 break;
; 3072 :             if (pOutBuffer == NULL || outSize < sizeof(UFN_PDD_INFO))

  0007c	e59d0020	 ldr         r0, [sp, #0x20]
  00080	e3500000	 cmp         r0, #0
  00084	0a00000e	 beq         |$LN8@UfnPdd_IOC|
  00088	e59d3024	 ldr         r3, [sp, #0x24]
  0008c	e353000c	 cmp         r3, #0xC
  00090	3a00000b	 bcc         |$LN8@UfnPdd_IOC|

; 3073 :                 break;
; 3074 :             info.InterfaceType = Internal;
; 3075 :             info.BusNumber = 0;

  00094	e3a02000	 mov         r2, #0

; 3076 :             info.dwAlignment = sizeof(DWORD);

  00098	e3a01004	 mov         r1, #4
  0009c	e3a03000	 mov         r3, #0
  000a0	e58d2004	 str         r2, [sp, #4]
  000a4	e58d1008	 str         r1, [sp, #8]

; 3077 :             if (!CeSafeCopyMemory(
; 3078 :                 pOutBuffer, &info, sizeof(UFN_PDD_INFO)
; 3079 :                 ))

  000a8	e3a0200c	 mov         r2, #0xC
  000ac	e28d1000	 add         r1, sp, #0
  000b0	e58d3000	 str         r3, [sp]
  000b4		 |$LN17@UfnPdd_IOC|
  000b4	eb000000	 bl          CeSafeCopyMemory
  000b8	e3500000	 cmp         r0, #0
  000bc	0a000000	 beq         |$LN8@UfnPdd_IOC|
  000c0		 |$LN16@UfnPdd_IOC|

; 3080 :                 break;
; 3081 :             rc = ERROR_SUCCESS;

  000c0	e3a04000	 mov         r4, #0
  000c4		 |$LN8@UfnPdd_IOC|

; 3112 : 
; 3113 : #if 0
; 3114 :         case IOCTL_DVFS_OPMNOTIFY:
; 3115 :         {
; 3116 :             IOCTL_DVFS_OPMNOTIFY_IN *pData =(IOCTL_DVFS_OPMNOTIFY_IN*)pInBuffer;
; 3117 :             
; 3118 :             DEBUGMSG(ZONE_DVFS, (L"HSUSBFN: received dvfs notification (%d)\r\n",
; 3119 :                 pData->notification)
; 3120 :                 );
; 3121 :             
; 3122 :             // this operation should be atomic to handle a corner case
; 3123 :             EnterCriticalSection(&pPdd->csDVFS);
; 3124 :             
; 3125 :             // signal dvfs thread to stall SDRAM access
; 3126 :             if (pData->notification == kPreNotice)
; 3127 :             {
; 3128 :                 pPdd->bDVFSActive = TRUE;
; 3129 :                 pPdd->bDVFSAck = FALSE;
; 3130 :                 
; 3131 :                 // check and halt dma if active
; 3132 :                 //
; 3133 :                 DEBUGMSG(ZONE_DVFS, (L"HSUSBFN: Halting DMA for DVFS, "
; 3134 :                     L"active dma count=%d\r\n",
; 3135 :                     pPdd->nActiveDmaCount)
; 3136 :                     );
; 3137 :                 CheckAndHaltAllDma(pPdd, TRUE);                
; 3138 :             }
; 3139 :             else if (pData->notification == kPostNotice)
; 3140 :             {
; 3141 :                 pPdd->bDVFSActive = FALSE;
; 3142 :                 pPdd->bDVFSAck = FALSE;
; 3143 :                                 
; 3144 :                 CheckAndHaltAllDma(pPdd, FALSE);
; 3145 :                 DEBUGMSG(ZONE_DVFS, (L"HSUSBFN: Post-DVFS transition done\r\n"));
; 3146 :             }
; 3147 :             LeaveCriticalSection(&pPdd->csDVFS);
; 3148 :             rc = ERROR_SUCCESS;
; 3149 :         }
; 3150 :             break;
; 3151 : 
; 3152 :         case IOCTL_DVFS_INITINFO:
; 3153 :         {
; 3154 :             IOCTL_DVFS_INITINFO_OUT *pInitInfo =(IOCTL_DVFS_INITINFO_OUT*)pOutBuffer;
; 3155 :             pInitInfo->notifyMode = kAsynchronous;
; 3156 :             pInitInfo->notifyOrder = pPdd->nDVFSOrder;
; 3157 :             rc = ERROR_SUCCESS;
; 3158 :         }
; 3159 :             break;
; 3160 :         
; 3161 :         case IOCTL_DVFS_OPMINFO:
; 3162 :         {
; 3163 :             IOCTL_DVFS_OPMINFO_IN *pData =(IOCTL_DVFS_OPMINFO_IN*)pInBuffer;
; 3164 :             CopyDVFSHandles(pPdd, pData->processId, 
; 3165 :                 pData->hAckEvent, pData->hOpmEvent
; 3166 :                 );
; 3167 :             rc = ERROR_SUCCESS;
; 3168 :         }
; 3169 :             break;
; 3170 : 
; 3171 :         case IOCTL_DVFS_DETACH:
; 3172 :         {
; 3173 :             // close all handles
; 3174 :             if (pPdd->hDVFSAckEvent != NULL)
; 3175 :             {
; 3176 :                 CloseHandle(pPdd->hDVFSAckEvent);
; 3177 :                 pPdd->hDVFSAckEvent = NULL;
; 3178 :             }
; 3179 :             
; 3180 :             if (pPdd->hDVFSActivityEvent!= NULL)
; 3181 :             {
; 3182 :                 CloseHandle(pPdd->hDVFSActivityEvent);
; 3183 :                 pPdd->hDVFSActivityEvent = NULL;
; 3184 :             }
; 3185 : 
; 3186 :             pPdd->bDVFSAck = FALSE;
; 3187 :             rc = ERROR_SUCCESS;
; 3188 :         }
; 3189 :             break;
; 3190 : 
; 3191 :         case IOCTL_DVFS_HALTMODE:
; 3192 :         {
; 3193 :             if (pPdd->bDVFSActive == FALSE)
; 3194 :             {                
; 3195 :                 IOCTL_DVFS_HALTMODE_IN *pData =(IOCTL_DVFS_HALTMODE_IN*)pInBuffer;
; 3196 :                 pPdd->rxHaltMode = pData->rxMode;
; 3197 :                 pPdd->txHaltMode = pData->txMode;
; 3198 :                 rc = ERROR_SUCCESS;
; 3199 :             }
; 3200 :             break;
; 3201 :         }
; 3202 : #endif
; 3203 :     }
; 3204 :     
; 3205 :     return rc;
; 3206 : }

  000c4	e1a00004	 mov         r0, r4
  000c8	e28dd00c	 add         sp, sp, #0xC
  000cc	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000d0	e12fff1e	 bx          lr
  000d4		 |$M49555|

			 ENDP  ; |UfnPdd_IOControl|

	EXPORT	|UfnPdd_Deinit|
	IMPORT	|LocalFree|
	IMPORT	|DeleteCriticalSection|
	IMPORT	|VirtualFree|
	IMPORT	|FreePhysMem|
	IMPORT	|CloseHandle|

  00000			 AREA	 |.pdata|, PDATA
|$T49567| DCD	|$LN11@UfnPdd_Dei|
	DCD	0x40003401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_Deinit| PROC

; 3228 : {

  00000		 |$LN11@UfnPdd_Dei|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M49564|
  00004	e1a04000	 mov         r4, r0

; 3229 :     MUsbFnPdd_t *pPdd = pPddContext;
; 3230 :     DEBUGMSG(ZONE_FUNCTION, (L"UfnPdd_Deinit\r\n"));
; 3231 : 
; 3232 :     if( pPdd->hVbusChargeEvent != INVALID_HANDLE_VALUE )

  00008	e5940428	 ldr         r0, [r4, #0x428]
  0000c	e3700001	 cmn         r0, #1
  00010	0a000002	 beq         |$LN6@UfnPdd_Dei|

; 3233 :     {
; 3234 :         CloseHandle(pPdd->hVbusChargeEvent);

  00014	eb000000	 bl          CloseHandle

; 3235 :         pPdd->hVbusChargeEvent = INVALID_HANDLE_VALUE;

  00018	e3e03000	 mvn         r3, #0
  0001c	e5843428	 str         r3, [r4, #0x428]
  00020		 |$LN6@UfnPdd_Dei|

; 3236 :     }    
; 3237 : 
; 3238 :     // Release DMA Rx0 buffer...
; 3239 :     if (pPdd->pDmaRx0Buffer != NULL)

  00020	e5943048	 ldr         r3, [r4, #0x48]
  00024	e3a05000	 mov         r5, #0
  00028	e3530000	 cmp         r3, #0
  0002c	0a000003	 beq         |$LN5@UfnPdd_Dei|

; 3240 :     {
; 3241 :         FreePhysMem(pPdd->pDmaRx0Buffer);

  00030	e1a00003	 mov         r0, r3
  00034	eb000000	 bl          FreePhysMem

; 3242 :         pPdd->pDmaRx0Buffer = NULL;

  00038	e5845048	 str         r5, [r4, #0x48]

; 3243 :         pPdd->paDmaRx0Buffer = 0;

  0003c	e584504c	 str         r5, [r4, #0x4C]
  00040		 |$LN5@UfnPdd_Dei|

; 3244 :     }
; 3245 :     
; 3246 :     // Release DMA Tx0 buffer...
; 3247 :     if (pPdd->pDmaTx0Buffer != NULL)

  00040	e5943050	 ldr         r3, [r4, #0x50]
  00044	e3530000	 cmp         r3, #0
  00048	0a000003	 beq         |$LN4@UfnPdd_Dei|

; 3248 :     {
; 3249 :         FreePhysMem(pPdd->pDmaTx0Buffer);

  0004c	e1a00003	 mov         r0, r3
  00050	eb000000	 bl          FreePhysMem

; 3250 :         pPdd->pDmaTx0Buffer = NULL;

  00054	e5845050	 str         r5, [r4, #0x50]

; 3251 :         pPdd->paDmaTx0Buffer = 0;

  00058	e5845054	 str         r5, [r4, #0x54]
  0005c		 |$LN4@UfnPdd_Dei|

; 3252 :     }
; 3253 :     
; 3254 :     if (pPdd->pCachedDmaTx0Buffer != NULL)

  0005c	e5943058	 ldr         r3, [r4, #0x58]
  00060	e3530000	 cmp         r3, #0
  00064	0a000004	 beq         |$LN3@UfnPdd_Dei|

; 3255 :     {
; 3256 :         VirtualFree(pPdd->pCachedDmaTx0Buffer, pPdd->tx0DmaBufferSize, MEM_RELEASE);

  00068	e5941018	 ldr         r1, [r4, #0x18]
  0006c	e3a02902	 mov         r2, #2, 18
  00070	e1a00003	 mov         r0, r3
  00074	eb000000	 bl          VirtualFree

; 3257 :         pPdd->pCachedDmaTx0Buffer = NULL;

  00078	e5845058	 str         r5, [r4, #0x58]
  0007c		 |$LN3@UfnPdd_Dei|

; 3258 :     }
; 3259 :     
; 3260 :     pPdd->bDVFSAck = FALSE;
; 3261 :     // release dvfs resources
; 3262 :     if (pPdd->hDVFSAckEvent != NULL) CloseHandle(pPdd->hDVFSAckEvent);

  0007c	e594340c	 ldr         r3, [r4, #0x40C]
  00080	e5845404	 str         r5, [r4, #0x404]
  00084	e3530000	 cmp         r3, #0
  00088	11a00003	 movne       r0, r3
  0008c	1b000000	 blne        CloseHandle

; 3263 :     if (pPdd->hDVFSActivityEvent != NULL) CloseHandle(pPdd->hDVFSActivityEvent);

  00090	e5943410	 ldr         r3, [r4, #0x410]
  00094	e3530000	 cmp         r3, #0
  00098	11a00003	 movne       r0, r3
  0009c	1b000000	 blne        CloseHandle

; 3264 : 
; 3265 :     DeleteCriticalSection(&pPdd->csDVFS);

  000a0	e2843b01	 add         r3, r4, #1, 22
  000a4	e2830014	 add         r0, r3, #0x14
  000a8	eb000000	 bl          DeleteCriticalSection

; 3266 : 
; 3267 : 
; 3268 :     DeleteCriticalSection(&pPdd->dmaCS);

  000ac	e2840034	 add         r0, r4, #0x34
  000b0	eb000000	 bl          DeleteCriticalSection

; 3269 :     // Delete critical section
; 3270 :     DeleteCriticalSection(&pPdd->epCS);

  000b4	e2840078	 add         r0, r4, #0x78
  000b8	eb000000	 bl          DeleteCriticalSection

; 3271 :     
; 3272 :     // Free PDD context
; 3273 :     LocalFree(pPdd);

  000bc	e1a00004	 mov         r0, r4
  000c0	eb000000	 bl          LocalFree

; 3274 :     
; 3275 :     // Done
; 3276 :     return ERROR_SUCCESS;

  000c4	e3a00000	 mov         r0, #0

; 3277 : }

  000c8	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000cc	e12fff1e	 bx          lr
  000d0		 |$M49565|

			 ENDP  ; |UfnPdd_Deinit|

	EXPORT	|UfnPdd_DeregisterDevice|

  00000			 AREA	 |.pdata|, PDATA
|$T49577| DCD	|$LN7@UfnPdd_Der|
	DCD	0x40001000
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_DeregisterDevice| PROC

; 3300 : {

  00000		 |$LN7@UfnPdd_Der|
  00000		 |$M49574|

; 3301 :     MUsbFnPdd_t *pPdd = pPddContext;
; 3302 :     DEBUGMSG(ZONE_FUNCTION, (L"UfnPdd_DeregisterDevice\r\n"));
; 3303 :     
; 3304 :     if (pPdd->tx0DmaEp != -1)

  00000	e5902010	 ldr         r2, [r0, #0x10]
  00004	e3a01000	 mov         r1, #0
  00008	e3720001	 cmn         r2, #1

; 3305 :     {
; 3306 :         pPdd->ep[pPdd->tx0DmaEp].dmaEnabled = FALSE;

  0000c	13a03034	 movne       r3, #0x34
  00010	10230392	 mlane       r3, r2, r3, r0
  00014	158310bc	 strne       r1, [r3, #0xBC]

; 3307 :     }
; 3308 :     
; 3309 :     if (pPdd->rx0DmaEp != -1)

  00018	e590200c	 ldr         r2, [r0, #0xC]
  0001c	e3720001	 cmn         r2, #1

; 3310 :     {
; 3311 :         pPdd->ep[pPdd->rx0DmaEp].dmaEnabled = FALSE;

  00020	13a03034	 movne       r3, #0x34
  00024	10230392	 mlane       r3, r2, r3, r0
  00028	158310bc	 strne       r1, [r3, #0xBC]

; 3312 :     }
; 3313 :     
; 3314 :     pPdd->tx0DmaEp = (DWORD)-1;

  0002c	e3e03000	 mvn         r3, #0
  00030	e5803010	 str         r3, [r0, #0x10]

; 3315 :     pPdd->rx0DmaEp = (DWORD)-1;

  00034	e580300c	 str         r3, [r0, #0xC]

; 3316 :         
; 3317 :     return ERROR_SUCCESS;

  00038	e3a00000	 mov         r0, #0

; 3318 : }

  0003c	e12fff1e	 bx          lr
  00040		 |$M49575|

			 ENDP  ; |UfnPdd_DeregisterDevice|

	EXPORT	|UfnPdd_Stop|

  00000			 AREA	 |.pdata|, PDATA
|$T49587| DCD	|$LN5@UfnPdd_Sto|
	DCD	0x40001001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_Stop| PROC

; 3342 : {

  00000		 |$LN5@UfnPdd_Sto|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M49584|
  00004	e1a0e000	 mov         lr, r0

; 3343 :     MUsbFnPdd_t *pPdd = pPddContext;    
; 3344 :     DEBUGMSG(ZONE_FUNCTION, (L"UfnPdd_Stop\r\n"));
; 3345 :     pPdd->devState &= ~(MUSB_DEVSTAT_ATT | 
; 3346 :                         MUSB_DEVSTAT_B_HNP_ENABLE | 
; 3347 :                         MUSB_DEVSTAT_A_HNP_SUPPORT |
; 3348 :                         MUSB_DEVSTAT_A_ALT_HNP_SUPPORT);

  00008	e59e206c	 ldr         r2, [lr, #0x6C]
  0000c	e3e03c03	 mvn         r3, #3, 24
  00010	e2233081	 eor         r3, r3, #0x81

; 3349 : 
; 3350 :     BusChildIoControl(pPdd->hParentBus,IOCTL_USBOTG_REQUEST_STOP,NULL,0);    

  00014	e59f1020	 ldr         r1, [pc, #0x20]
  00018	e59e0030	 ldr         r0, [lr, #0x30]
  0001c	e0023003	 and         r3, r2, r3
  00020	e58e306c	 str         r3, [lr, #0x6C]
  00024	e3a03000	 mov         r3, #0
  00028	e3a02000	 mov         r2, #0
  0002c	eb000000	 bl          BusChildIoControl

; 3351 : 
; 3352 :     // Done
; 3353 :     return ERROR_SUCCESS;

  00030	e3a00000	 mov         r0, #0

; 3354 : }

  00034	e49de004	 ldr         lr, [sp], #4
  00038	e12fff1e	 bx          lr
  0003c		 |$LN6@UfnPdd_Sto|
  0003c		 |$LN7@UfnPdd_Sto|
  0003c	00222024	 DCD         0x222024
  00040		 |$M49585|

			 ENDP  ; |UfnPdd_Stop|

	EXPORT	|UfnPdd_DeinitEndpoint|

  00000			 AREA	 |.pdata|, PDATA
|$T49603| DCD	|$LN8@UfnPdd_Dei@2|
	DCD	0x40002601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_DeinitEndpoint| PROC

; 3379 : {

  00000		 |$LN8@UfnPdd_Dei@2|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M49600|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 3380 :     MUsbFnPdd_t *pPdd = pPddContext;
; 3381 :     PCSP_MUSB_GEN_REGS pGenRegs = pPdd->pUSBContext->pUsbGenRegs;

  0000c	e5946020	 ldr         r6, [r4, #0x20]

; 3382 :     PCSP_MUSB_CSR_REGS pCsrRegs = pPdd->pUSBContext->pUsbCsrRegs;
; 3383 :     PHSMUSB_T pOTG = pPdd->pUSBContext;
; 3384 :     DEBUGMSG(ZONE_INFO, (L"UfnPdd_DeinitEndpoint: endpoint %d\r\n", endpoint));
; 3385 : 
; 3386 :     EnterCriticalSection(&pOTG->regCS);

  00010	e5967020	 ldr         r7, [r6, #0x20]
  00014	e596801c	 ldr         r8, [r6, #0x1C]
  00018	e2860038	 add         r0, r6, #0x38
  0001c	eb000000	 bl          EnterCriticalSection

; 3387 :     if(pOTG->bClockStatus)

  00020	e5963060	 ldr         r3, [r6, #0x60]

; 3388 :     {
; 3389 :     /* Flush the fifo, otherwise transmit error on the host during Device->=Host HNP */
; 3390 :     OUTREG16(&pGenRegs->Index, endpoint);  /* select endpoint to access rxFIFOxx registers */
; 3391 :     OUTREG16(&pCsrRegs->ep[endpoint].RxCSR, RXCSR_P_FLUSHFIFO | RXCSR_P_CLRDATATOG);
; 3392 :     OUTREG16(&pCsrRegs->ep[endpoint].CSR.TxCSR, TXCSR_P_FLUSHFIFO | TXCSR_P_CLRDATATOG);
; 3393 :     }
; 3394 :     LeaveCriticalSection(&pOTG->regCS);

  00024	e2860038	 add         r0, r6, #0x38
  00028	e3530000	 cmp         r3, #0
  0002c	10883205	 addne       r3, r8, r5, lsl #4
  00030	13a02090	 movne       r2, #0x90
  00034	11c750be	 strneh      r5, [r7, #0xE]
  00038	11c320b6	 strneh      r2, [r3, #6]
  0003c	13a02048	 movne       r2, #0x48
  00040	11c320b2	 strneh      r2, [r3, #2]
  00044	eb000000	 bl          LeaveCriticalSection

; 3395 :     
; 3396 :     if (pPdd->tx0DmaEp == endpoint)

  00048	e5943010	 ldr         r3, [r4, #0x10]
  0004c	e3a02000	 mov         r2, #0
  00050	e3e01000	 mvn         r1, #0
  00054	e1530005	 cmp         r3, r5

; 3397 :     {
; 3398 :         pPdd->ep[endpoint].dmaEnabled = FALSE;

  00058	03a03034	 moveq       r3, #0x34
  0005c	00234395	 mlaeq       r3, r5, r3, r4

; 3399 :         pPdd->tx0DmaEp = (DWORD)-1;
; 3400 :     }
; 3401 :     
; 3402 :     if (pPdd->rx0DmaEp == endpoint)
; 3403 :     {
; 3404 :         pPdd->ep[endpoint].dmaEnabled = FALSE;
; 3405 :         pPdd->rx0DmaEp = (DWORD)-1;
; 3406 :     }
; 3407 :     pPdd->ep[endpoint].dmaDVFSstate = DVFS_NODMA;
; 3408 :     
; 3409 :     // Done
; 3410 :     return ERROR_SUCCESS;

  00060	e3a00000	 mov         r0, #0
  00064	058320bc	 streq       r2, [r3, #0xBC]
  00068	e594300c	 ldr         r3, [r4, #0xC]
  0006c	05841010	 streq       r1, [r4, #0x10]
  00070	e1530005	 cmp         r3, r5
  00074	03a03034	 moveq       r3, #0x34
  00078	00234395	 mlaeq       r3, r5, r3, r4
  0007c	058320bc	 streq       r2, [r3, #0xBC]
  00080	e3a03034	 mov         r3, #0x34
  00084	e0234395	 mla         r3, r5, r3, r4
  00088	0584100c	 streq       r1, [r4, #0xC]
  0008c	e5c320d8	 strb        r2, [r3, #0xD8]

; 3411 : }

  00090	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00094	e12fff1e	 bx          lr
  00098		 |$M49601|

			 ENDP  ; |UfnPdd_DeinitEndpoint|

	EXPORT	|UfnPdd_InitEndpoint|

  00000			 AREA	 |.pdata|, PDATA
|$T49647| DCD	|$LN40@UfnPdd_Ini@2|
	DCD	0x40008b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_InitEndpoint| PROC

; 3450 : {

  00000		 |$LN40@UfnPdd_Ini@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M49644|
  00004	e1a09002	 mov         r9, r2
  00008	e1a08001	 mov         r8, r1
  0000c	e1a07000	 mov         r7, r0

; 3451 :     MUsbFnPdd_t *pPdd = pPddContext;
; 3452 :     PCSP_MUSB_GEN_REGS pGenRegs = pPdd->pUSBContext->pUsbGenRegs;
; 3453 :     PCSP_MUSB_CSR_REGS pCsrRegs = pPdd->pUSBContext->pUsbCsrRegs;
; 3454 :     UCHAR epTransferType;
; 3455 :     
; 3456 : 	UNREFERENCED_PARAMETER(alternateSetting);
; 3457 : 	UNREFERENCED_PARAMETER(interfaceNumber);
; 3458 : 	UNREFERENCED_PARAMETER(configValue);
; 3459 : 	UNREFERENCED_PARAMETER(pReserved);
; 3460 : 
; 3461 :     DEBUGMSG(ZONE_FUNCTION, (L"UfnPdd_InitEndpoint: endpoint %d  speed: %d  MaxPacketSize: %d\r\n",
; 3462 :         endpoint, speed, pEPDesc->wMaxPacketSize));
; 3463 :     
; 3464 :     pPdd->ep[endpoint].maxPacketSize = pEPDesc->wMaxPacketSize;

  00010	e5d35004	 ldrb        r5, [r3, #4]
  00014	e5d3e005	 ldrb        lr, [r3, #5]
  00018	e5974020	 ldr         r4, [r7, #0x20]
  0001c	e3a02034	 mov         r2, #0x34
  00020	e0267298	 mla         r6, r8, r2, r7
  00024	e594a01c	 ldr         r10, [r4, #0x1C]
  00028	e185e40e	 orr         lr, r5, lr, lsl #8
  0002c	e5945020	 ldr         r5, [r4, #0x20]
  00030	e1c6eabc	 strh        lr, [r6, #0xAC]

; 3465 :     pPdd->ep[endpoint].dirRx =(pEPDesc->bEndpointAddress & 0x80) ? FALSE : TRUE;

  00034	e5d3e002	 ldrb        lr, [r3, #2]

; 3466 :     pPdd->ep[endpoint].dmaDVFSstate = DVFS_NODMA;

  00038	e3a0b000	 mov         r11, #0
  0003c	e5c6b0d8	 strb        r11, [r6, #0xD8]
  00040	e31e0080	 tst         lr, #0x80
  00044	13a01000	 movne       r1, #0
  00048	03a01001	 moveq       r1, #1

; 3467 :     pPdd->ep[endpoint].bMassStore = FALSE;

  0004c	e58610b0	 str         r1, [r6, #0xB0]
  00050	e586b0b8	 str         r11, [r6, #0xB8]

; 3468 :     epTransferType = pEPDesc->bmAttributes & 0x3;

  00054	e5d34003	 ldrb        r4, [r3, #3]

; 3469 :     
; 3470 :     
; 3471 :     if (pPdd->pfnEnUSBClock)

  00058	e597302c	 ldr         r3, [r7, #0x2C]
  0005c	e3530000	 cmp         r3, #0

; 3472 :         pPdd->pfnEnUSBClock(TRUE);

  00060	13a00001	 movne       r0, #1
  00064	11a0e00f	 movne       lr, pc
  00068	112fff13	 bxne        r3

; 3473 :     EnterCriticalSection(&pPdd->epCS);

  0006c	e2870078	 add         r0, r7, #0x78
  00070	eb000000	 bl          EnterCriticalSection

; 3474 :     OUTREG16(&pGenRegs->Index, endpoint);  /* select endpoint to access rxFIFOxx registers */

  00074	e1c580be	 strh        r8, [r5, #0xE]

; 3475 :         
; 3476 :     switch (epTransferType)

  00078	e2143003	 ands        r3, r4, #3
  0007c	0a00005a	 beq         |$LN3@UfnPdd_Ini@2|
  00080	e3530002	 cmp         r3, #2
  00084	0a000022	 beq         |$LN12@UfnPdd_Ini@2|
  00088	e3530003	 cmp         r3, #3
  0008c	1a00005d	 bne         |$LN2@UfnPdd_Ini@2|

; 3477 :     {
; 3478 :         case EP_TYPE_INTERRUPT:
; 3479 :             DEBUGMSG(ZONE_INFO, (L"Interrupt endpoint\r\n"));
; 3480 :             if (pPdd->ep[endpoint].dirRx)

  00090	e59630b0	 ldr         r3, [r6, #0xB0]

; 3481 :             {
; 3482 :                 OUTREG8(&pGenRegs->RxFIFOsz, MUSB_FIFOSZ_512_BYTE);
; 3483 :                 OUTREG16(&pGenRegs->RxFIFOadd, CalcFIFOAddr(endpoint,pPdd->ep[endpoint].dirRx));

  00094	e1a02388	 mov         r2, r8, lsl #7
  00098	e3530000	 cmp         r3, #0
  0009c	e3a03006	 mov         r3, #6
  000a0	0a00000f	 beq         |$LN15@UfnPdd_Ini@2|
  000a4	e5c53063	 strb        r3, [r5, #0x63]
  000a8	e59630b0	 ldr         r3, [r6, #0xB0]
  000ac	e3530000	 cmp         r3, #0
  000b0	12822040	 addne       r2, r2, #0x40
  000b4	e1c526b6	 strh        r2, [r5, #0x66]

; 3484 :                 OUTREG16(&pCsrRegs->ep[endpoint].RxMaxP, pPdd->ep[endpoint].maxPacketSize);

  000b8	e1d63abc	 ldrh        r3, [r6, #0xAC]
  000bc	e08a2208	 add         r2, r10, r8, lsl #4

; 3485 :                 OUTREG16(&pCsrRegs->ep[endpoint].RxCSR, RXCSR_P_FLUSHFIFO | RXCSR_P_CLRDATATOG);
; 3486 :                 
; 3487 :                 DEBUGMSG(ZONE_INFO, (L"RxFIFOsz=%d\r\n", INREG8(&pGenRegs->RxFIFOsz)));
; 3488 :                 DEBUGMSG(ZONE_INFO, (L"RxFIFOadd=%d\r\n", INREG16(&pGenRegs->RxFIFOadd)));
; 3489 :                 
; 3490 :                 // Doesn't support PING in high speed mode
; 3491 :                 if (speed == BS_HIGH_SPEED)

  000c0	e3590002	 cmp         r9, #2
  000c4	e1c230b4	 strh        r3, [r2, #4]
  000c8	e3a03090	 mov         r3, #0x90
  000cc	e1c230b6	 strh        r3, [r2, #6]
  000d0	1a00004c	 bne         |$LN2@UfnPdd_Ini@2|

; 3492 :                     SETREG16(&pCsrRegs->ep[endpoint].RxCSR, RXCSR_P_DISNYET);

  000d4	e1d230b6	 ldrh        r3, [r2, #6]
  000d8	e3833a01	 orr         r3, r3, #1, 20
  000dc	e1c230b6	 strh        r3, [r2, #6]

; 3493 :             }
; 3494 :             else

  000e0	ea000048	 b           |$LN2@UfnPdd_Ini@2|
  000e4		 |$LN15@UfnPdd_Ini@2|

; 3495 :             {
; 3496 :                 OUTREG8(&pGenRegs->TxFIFOsz, MUSB_FIFOSZ_512_BYTE);

  000e4	e5c53062	 strb        r3, [r5, #0x62]

; 3497 :                 OUTREG16(&pGenRegs->TxFIFOadd, CalcFIFOAddr(endpoint,pPdd->ep[endpoint].dirRx));

  000e8	e59630b0	 ldr         r3, [r6, #0xB0]

; 3498 :                 OUTREG16(&pCsrRegs->ep[endpoint].TxMaxP, pPdd->ep[endpoint].maxPacketSize);

  000ec	e3a01b02	 mov         r1, #2, 22
  000f0	e3530000	 cmp         r3, #0
  000f4	12822040	 addne       r2, r2, #0x40
  000f8	e1c526b4	 strh        r2, [r5, #0x64]
  000fc	e1d63abc	 ldrh        r3, [r6, #0xAC]
  00100	e08a2208	 add         r2, r10, r8, lsl #4
  00104	e1c230b0	 strh        r3, [r2]

; 3499 :                 OUTREG16(&pCsrRegs->ep[endpoint].CSR.TxCSR, TXCSR_P_FLUSHFIFO | TXCSR_P_CLRDATATOG | TXCSR_P_FRCDATATOG);

  00108	e3813048	 orr         r3, r1, #0x48
  0010c	e1c230b2	 strh        r3, [r2, #2]

; 3500 :                 
; 3501 :                 DEBUGMSG(ZONE_INFO, (L"TxFIFOsz=%d\r\n", INREG8(&pGenRegs->TxFIFOsz)));
; 3502 :                 DEBUGMSG(ZONE_INFO, (L"TxFIFOadd=%d\r\n", INREG16(&pGenRegs->TxFIFOadd)));
; 3503 :             }
; 3504 :             break;

  00110	ea00003c	 b           |$LN2@UfnPdd_Ini@2|
  00114		 |$LN12@UfnPdd_Ini@2|

; 3505 :             
; 3506 :         case EP_TYPE_BULK:
; 3507 :             DEBUGMSG(ZONE_INFO, (L"Bulk endpoint\r\n"));
; 3508 :   
; 3509 :             // Bulk endpoints the of Mass Storage devices should not send zero length transfers
; 3510 :             if (speed == BS_HIGH_SPEED)

  00114	e3590002	 cmp         r9, #2

; 3511 :             {
; 3512 :                 if(pPdd->HsEpMassStoreFlags & (1<<endpoint))

  00118	e2873b01	 add         r3, r7, #1, 22
  0011c	01d332be	 ldreqh      r3, [r3, #0x2E]
  00120	e3a02001	 mov         r2, #1
  00124	e3a00001	 mov         r0, #1

; 3513 :                 {
; 3514 :                     pPdd->ep[endpoint].bMassStore = TRUE;
; 3515 :                 }
; 3516 :             }
; 3517 :             else
; 3518 :             {
; 3519 :                 if(pPdd->FsEpMassStoreFlags & (1<<endpoint))

  00128	11d332bc	 ldrneh      r3, [r3, #0x2C]
  0012c	e1130812	 tst         r3, r2, lsl r8

; 3520 :                 {
; 3521 :                     pPdd->ep[endpoint].bMassStore = TRUE;
; 3522 :                 }
; 3523 :             }
; 3524 : 
; 3525 :             if (pPdd->ep[endpoint].dirRx)

  00130	e59630b0	 ldr         r3, [r6, #0xB0]
  00134	158600b8	 strne       r0, [r6, #0xB8]

; 3526 :             {
; 3527 :                 OUTREG8(&pGenRegs->RxFIFOsz, MUSB_FIFOSZ_512_BYTE);
; 3528 :                 OUTREG16(&pGenRegs->RxFIFOadd, CalcFIFOAddr(endpoint,pPdd->ep[endpoint].dirRx));

  00138	e1a02388	 mov         r2, r8, lsl #7
  0013c	e3530000	 cmp         r3, #0
  00140	e3a03006	 mov         r3, #6
  00144	0a000015	 beq         |$LN7@UfnPdd_Ini@2|
  00148	e5c53063	 strb        r3, [r5, #0x63]
  0014c	e59630b0	 ldr         r3, [r6, #0xB0]
  00150	e3530000	 cmp         r3, #0
  00154	12822040	 addne       r2, r2, #0x40
  00158	e1c526b6	 strh        r2, [r5, #0x66]

; 3529 :                 OUTREG16(&pCsrRegs->ep[endpoint].RxMaxP, pPdd->ep[endpoint].maxPacketSize);

  0015c	e1d63abc	 ldrh        r3, [r6, #0xAC]
  00160	e08a2208	 add         r2, r10, r8, lsl #4
  00164	e1c230b4	 strh        r3, [r2, #4]

; 3530 :                 OUTREG16(&pCsrRegs->ep[endpoint].RxCSR, RXCSR_P_FLUSHFIFO | RXCSR_P_CLRDATATOG);

  00168	e3a03090	 mov         r3, #0x90
  0016c	e1c230b6	 strh        r3, [r2, #6]

; 3531 :                 pPdd->rx0DmaState = MODE_FIFO;

  00170	e587001c	 str         r0, [r7, #0x1C]

; 3532 : 
; 3533 :                 pPdd->ep[endpoint].bLastRxUsedDMA = FALSE;

  00174	e586b0dc	 str         r11, [r6, #0xDC]

; 3534 :                 if (pPdd->enableDMA && (pPdd->rx0DmaEp == -1))

  00178	e5973008	 ldr         r3, [r7, #8]
  0017c	e3530000	 cmp         r3, #0
  00180	0a000020	 beq         |$LN2@UfnPdd_Ini@2|
  00184	e597300c	 ldr         r3, [r7, #0xC]
  00188	e3730001	 cmn         r3, #1
  0018c	1a00001d	 bne         |$LN2@UfnPdd_Ini@2|

; 3535 :                 {
; 3536 :                     pPdd->rx0DmaEp = endpoint;

  00190	e587800c	 str         r8, [r7, #0xC]

; 3537 :                     pPdd->rx0DmaState = MODE_DMA;

  00194	e587b01c	 str         r11, [r7, #0x1C]

; 3555 :                     pPdd->ep[endpoint].dmaEnabled = TRUE;

  00198	e58600bc	 str         r0, [r6, #0xBC]

; 3556 :                     DEBUGMSG(ZONE_INFO, (TEXT("TX EP %d DMA Enable\r\n"), endpoint));
; 3557 :                 }
; 3558 :                 
; 3559 : 
; 3560 :                 DEBUGMSG(ZONE_INFO, (L"TxFIFOsz=%d\r\n", INREG8(&pGenRegs->TxFIFOsz)));
; 3561 :                 DEBUGMSG(ZONE_INFO, (L"TxFIFOadd=%d\r\n", INREG16(&pGenRegs->TxFIFOadd)));
; 3562 :             }
; 3563 :             break;

  0019c	ea000019	 b           |$LN2@UfnPdd_Ini@2|
  001a0		 |$LN7@UfnPdd_Ini@2|

; 3538 :                     pPdd->ep[endpoint].dmaEnabled = TRUE;
; 3539 :                     DEBUGMSG(ZONE_INFO, (TEXT("RX EP %d DMA Enable\r\n"), endpoint));
; 3540 :                 }
; 3541 :                 
; 3542 :                 DEBUGMSG(ZONE_INFO, (L"RxFIFOsz=%d\r\n", INREG8(&pGenRegs->RxFIFOsz)));
; 3543 :                 DEBUGMSG(ZONE_INFO, (L"RxFIFOadd=%d\r\n", INREG16(&pGenRegs->RxFIFOadd)));
; 3544 :             }
; 3545 :             else
; 3546 :             {
; 3547 :                 OUTREG8(&pGenRegs->TxFIFOsz, MUSB_FIFOSZ_512_BYTE);

  001a0	e5c53062	 strb        r3, [r5, #0x62]

; 3548 :                 OUTREG16(&pGenRegs->TxFIFOadd, CalcFIFOAddr(endpoint,pPdd->ep[endpoint].dirRx));

  001a4	e59630b0	 ldr         r3, [r6, #0xB0]

; 3549 :                 OUTREG16(&pCsrRegs->ep[endpoint].TxMaxP, pPdd->ep[endpoint].maxPacketSize);
; 3550 :                 OUTREG16(&pCsrRegs->ep[endpoint].CSR.TxCSR, TXCSR_P_FLUSHFIFO | TXCSR_P_CLRDATATOG);

  001a8	e3a01048	 mov         r1, #0x48
  001ac	e3530000	 cmp         r3, #0
  001b0	12822040	 addne       r2, r2, #0x40
  001b4	e1c526b4	 strh        r2, [r5, #0x64]
  001b8	e1d63abc	 ldrh        r3, [r6, #0xAC]
  001bc	e08a2208	 add         r2, r10, r8, lsl #4
  001c0	e1c230b0	 strh        r3, [r2]
  001c4	e1c210b2	 strh        r1, [r2, #2]

; 3551 :                 
; 3552 :                 if (pPdd->enableDMA && (pPdd->tx0DmaEp == -1))

  001c8	e5973008	 ldr         r3, [r7, #8]
  001cc	e3530000	 cmp         r3, #0
  001d0	0a00000c	 beq         |$LN2@UfnPdd_Ini@2|
  001d4	e5973010	 ldr         r3, [r7, #0x10]
  001d8	e3730001	 cmn         r3, #1
  001dc	1a000009	 bne         |$LN2@UfnPdd_Ini@2|

; 3553 :                 {
; 3554 :                     pPdd->tx0DmaEp = endpoint;

  001e0	e5878010	 str         r8, [r7, #0x10]

; 3555 :                     pPdd->ep[endpoint].dmaEnabled = TRUE;

  001e4	e58600bc	 str         r0, [r6, #0xBC]

; 3556 :                     DEBUGMSG(ZONE_INFO, (TEXT("TX EP %d DMA Enable\r\n"), endpoint));
; 3557 :                 }
; 3558 :                 
; 3559 : 
; 3560 :                 DEBUGMSG(ZONE_INFO, (L"TxFIFOsz=%d\r\n", INREG8(&pGenRegs->TxFIFOsz)));
; 3561 :                 DEBUGMSG(ZONE_INFO, (L"TxFIFOadd=%d\r\n", INREG16(&pGenRegs->TxFIFOadd)));
; 3562 :             }
; 3563 :             break;

  001e8	ea000006	 b           |$LN2@UfnPdd_Ini@2|
  001ec		 |$LN3@UfnPdd_Ini@2|

; 3564 :             
; 3565 :         case EP_TYPE_CTRL:
; 3566 :             DEBUGMSG(ZONE_INFO, (L"Control endpoint\r\n"));
; 3567 :             if (endpoint == 0)

  001ec	e3580000	 cmp         r8, #0

; 3568 :             {
; 3569 :                 OUTREG8(&pGenRegs->RxFIFOsz, MUSB_FIFOSZ_128_BYTE);

  001f0	03a03004	 moveq       r3, #4
  001f4	05c53063	 streqb      r3, [r5, #0x63]

; 3570 :                 OUTREG16(&pGenRegs->RxFIFOadd, 0);

  001f8	01c5b6b6	 streqh      r11, [r5, #0x66]

; 3571 :                 
; 3572 :                 OUTREG8(&pGenRegs->TxFIFOsz, MUSB_FIFOSZ_128_BYTE);

  001fc	05c53062	 streqb      r3, [r5, #0x62]

; 3573 :                 OUTREG16(&pGenRegs->TxFIFOadd, 256/8);

  00200	03a03020	 moveq       r3, #0x20
  00204	01c536b4	 streqh      r3, [r5, #0x64]
  00208		 |$LN2@UfnPdd_Ini@2|

; 3574 :                 
; 3575 :                 DEBUGMSG(ZONE_INFO, (L"RxFIFOsz=%d\r\n", INREG8(&pGenRegs->RxFIFOsz)));
; 3576 :                 DEBUGMSG(ZONE_INFO, (L"RxFIFOadd=%d\r\n", INREG16(&pGenRegs->RxFIFOadd)));
; 3577 :                 
; 3578 :                 DEBUGMSG(ZONE_INFO, (L"TxFIFOsz=%d\r\n", INREG8(&pGenRegs->TxFIFOsz)));
; 3579 :                 DEBUGMSG(ZONE_INFO, (L"TxFIFOadd=%d\r\n", INREG16(&pGenRegs->TxFIFOadd)));
; 3580 :             }
; 3581 :             
; 3582 :         case EP_TYPE_ISOCH:
; 3583 :         default:
; 3584 :             DEBUGMSG(ZONE_INFO, (L"Unsupported endpoint Transfer type\r\n"));
; 3585 :             break;
; 3586 :     }
; 3587 :     
; 3588 :     
; 3589 :     LeaveCriticalSection(&pPdd->epCS);

  00208	e2870078	 add         r0, r7, #0x78
  0020c	eb000000	 bl          LeaveCriticalSection

; 3590 :     
; 3591 :     pPdd->pfnEnUSBClock(FALSE);

  00210	e597302c	 ldr         r3, [r7, #0x2C]
  00214	e3a00000	 mov         r0, #0
  00218	e1a0e00f	 mov         lr, pc
  0021c	e12fff13	 bx          r3

; 3592 :     
; 3593 :     
; 3594 :     return ERROR_SUCCESS;

  00220	e3a00000	 mov         r0, #0

; 3595 : }

  00224	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00228	e12fff1e	 bx          lr
  0022c		 |$M49645|

			 ENDP  ; |UfnPdd_InitEndpoint|

	EXPORT	|UfnPdd_SetAddress|

  00000			 AREA	 |.pdata|, PDATA
|$T49658| DCD	|$LN5@UfnPdd_Set|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_SetAddress| PROC

; 3620 : {

  00000		 |$LN5@UfnPdd_Set|
  00000		 |$M49655|

; 3621 :     MUsbFnPdd_t *pPdd = pPddContext;
; 3622 :     DEBUGMSG(ZONE_FUNCTION, (L"UfnPdd_SetAddress\r\n"));
; 3623 :     
; 3624 :     pPdd->bSetAddress = TRUE;

  00000	e3a03001	 mov         r3, #1
  00004	e58033f8	 str         r3, [r0, #0x3F8]

; 3625 :     pPdd->ucAddress = address;

  00008	e5c013f4	 strb        r1, [r0, #0x3F4]

; 3626 :     
; 3627 :     return ERROR_SUCCESS;

  0000c	e3a00000	 mov         r0, #0

; 3628 : }

  00010	e12fff1e	 bx          lr
  00014		 |$M49656|

			 ENDP  ; |UfnPdd_SetAddress|

	EXPORT	|UfnPdd_Start|

  00000			 AREA	 |.pdata|, PDATA
|$T49668| DCD	|$LN5@UfnPdd_Sta@2|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_Start| PROC

; 3651 : {

  00000		 |$LN5@UfnPdd_Sta@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M49665|

; 3652 :     MUsbFnPdd_t *pPdd = pPddContext;
; 3653 : 
; 3654 :     DEBUGMSG(ZONE_FUNCTION, (L"UfnPdd_Start\r\n"));
; 3655 : 
; 3656 :     BusChildIoControl(pPdd->hParentBus,IOCTL_USBOTG_REQUEST_START,NULL,0);    

  00004	e59f1018	 ldr         r1, [pc, #0x18]
  00008	e5900030	 ldr         r0, [r0, #0x30]
  0000c	e3a03000	 mov         r3, #0
  00010	e3a02000	 mov         r2, #0
  00014	eb000000	 bl          BusChildIoControl

; 3657 : 
; 3658 :     return ERROR_SUCCESS;

  00018	e3a00000	 mov         r0, #0

; 3659 : }

  0001c	e49de004	 ldr         lr, [sp], #4
  00020	e12fff1e	 bx          lr
  00024		 |$LN6@UfnPdd_Sta@2|
  00024		 |$LN7@UfnPdd_Sta@2|
  00024	00222020	 DCD         0x222020
  00028		 |$M49666|

			 ENDP  ; |UfnPdd_Start|

	EXPORT	|UfnPdd_RegisterDevice|

  00000			 AREA	 |.pdata|, PDATA
|$T49750| DCD	|$LN77@UfnPdd_Reg|
	DCD	0x40009f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_RegisterDevice| PROC

; 3697 : {

  00000		 |$LN77@UfnPdd_Reg|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M49747|
  00004	e1a0a002	 mov         r10, r2
  00008	e1a09000	 mov         r9, r0

; 3698 :     // NOTE: For now use FS configuration.                                                                                  //
; 3699 :     //     Final endpoint configuration (maxPackeSize, dirRX) is done later in UfnPdd_InitEndpoint()  //
; 3700 :         
; 3701 :     MUsbFnPdd_t *pPdd = pPddContext;
; 3702 :     UFN_INTERFACE *pIFC;
; 3703 :     UFN_ENDPOINT *pEP;
; 3704 :     DWORD ep;
; 3705 :     DWORD ifc, epx;
; 3706 : 
; 3707 : 	UNREFERENCED_PARAMETER(pStringSets);
; 3708 : 	UNREFERENCED_PARAMETER(stringSets);
; 3709 : 
; 3710 :     DEBUGMSG(ZONE_PDD, (L"UsbFnPdd_RegisterDevice\r\n"));
; 3711 :     
; 3712 :     DEBUGMSG(ZONE_INFO, (L"HS configuration: \r\n"));
; 3713 :     prtDescriptorInfo(pHighSpeedDeviceDesc, pHighSpeedConfig, pHighSpeedConfigDesc);
; 3714 :     
; 3715 :     DEBUGMSG(ZONE_INFO, (L"FS configuration: \r\n"));
; 3716 :     prtDescriptorInfo(pFullSpeedDeviceDesc, pFullSpeedConfig, pFullSpeedConfigDesc);
; 3717 :         
; 3718 :     // Remember self powered flag
; 3719 :     pPdd->selfPowered =(pFullSpeedConfig->Descriptor.bmAttributes & 0x20) != 0;

  0000c	e59de028	 ldr         lr, [sp, #0x28]

; 3720 :     
; 3721 :     pPdd->ep[EP0].maxPacketSize = pFullSpeedDeviceDesc->bMaxPacketSize0;
; 3722 :     
; 3723 :     // Configure Rx EPs
; 3724 :     for (ifc = 0; ifc < pFullSpeedConfig->Descriptor.bNumInterfaces; ifc++)

  00010	e3a05000	 mov         r5, #0
  00014	e5de300b	 ldrb        r3, [lr, #0xB]
  00018	e3130020	 tst         r3, #0x20
  0001c	e59d3024	 ldr         r3, [sp, #0x24]
  00020	13a01001	 movne       r1, #1
  00024	03a01000	 moveq       r1, #0
  00028	e5891070	 str         r1, [r9, #0x70]
  0002c	e5d33007	 ldrb        r3, [r3, #7]
  00030	e1c93abc	 strh        r3, [r9, #0xAC]
  00034	e5de3008	 ldrb        r3, [lr, #8]
  00038	e3530000	 cmp         r3, #0
  0003c	0a00001f	 beq         |$LN28@UfnPdd_Reg|
  00040	e3a04000	 mov         r4, #0
  00044	e3a0b034	 mov         r11, #0x34
  00048		 |$LL30@UfnPdd_Reg|

; 3725 :     {
; 3726 :         // For each endpoint in interface
; 3727 :         pIFC = &pFullSpeedConfig->pInterfaces[ifc];

  00048	e59e3018	 ldr         r3, [lr, #0x18]

; 3728 :         for (epx = 0; epx < pIFC->Descriptor.bNumEndpoints; epx++)

  0004c	e3a07000	 mov         r7, #0
  00050	e0848003	 add         r8, r4, r3
  00054	e5d83008	 ldrb        r3, [r8, #8]
  00058	e3530000	 cmp         r3, #0
  0005c	0a000012	 beq         |$LN29@UfnPdd_Reg|
  00060	e3a06000	 mov         r6, #0
  00064	e3a0e001	 mov         lr, #1
  00068		 |$LL27@UfnPdd_Reg|

; 3729 :         {
; 3730 :             pEP = &pIFC->pEndpoints[epx];

  00068	e5983018	 ldr         r3, [r8, #0x18]

; 3731 :             // If it is Tx EP skip it
; 3732 :             if ((pEP->Descriptor.bEndpointAddress & 0x80) != 0)
; 3733 :                 continue;
; 3734 :             // Get EP address
; 3735 :             ep = pEP->Descriptor.bEndpointAddress & 0x0F;
; 3736 :             // Save max packet size & direction
; 3737 :             pPdd->ep[ep].maxPacketSize = pEP->Descriptor.wMaxPacketSize;
; 3738 :             pPdd->ep[ep].dirRx = TRUE;

  0006c	e2877001	 add         r7, r7, #1
  00070	e0863003	 add         r3, r6, r3
  00074	e5d31006	 ldrb        r1, [r3, #6]
  00078	e2866014	 add         r6, r6, #0x14
  0007c	e3110080	 tst         r1, #0x80
  00080	05d30008	 ldreqb      r0, [r3, #8]
  00084	05d32009	 ldreqb      r2, [r3, #9]
  00088	0201300f	 andeq       r3, r1, #0xF
  0008c	00219b93	 mlaeq       r1, r3, r11, r9
  00090	01803402	 orreq       r3, r0, r2, lsl #8
  00094	01c13abc	 streqh      r3, [r1, #0xAC]
  00098	0581e0b0	 streq       lr, [r1, #0xB0]
  0009c	e5d83008	 ldrb        r3, [r8, #8]
  000a0	e1570003	 cmp         r7, r3
  000a4	3affffef	 bcc         |$LL27@UfnPdd_Reg|
  000a8	e59de028	 ldr         lr, [sp, #0x28]
  000ac		 |$LN29@UfnPdd_Reg|

; 3720 :     
; 3721 :     pPdd->ep[EP0].maxPacketSize = pFullSpeedDeviceDesc->bMaxPacketSize0;
; 3722 :     
; 3723 :     // Configure Rx EPs
; 3724 :     for (ifc = 0; ifc < pFullSpeedConfig->Descriptor.bNumInterfaces; ifc++)

  000ac	e5de3008	 ldrb        r3, [lr, #8]
  000b0	e2855001	 add         r5, r5, #1
  000b4	e284401c	 add         r4, r4, #0x1C
  000b8	e1550003	 cmp         r5, r3
  000bc	3affffe1	 bcc         |$LL30@UfnPdd_Reg|
  000c0		 |$LN28@UfnPdd_Reg|

; 3739 :             
; 3740 :             if ((pEP->Descriptor.bmAttributes & 0x03) == 0x01)
; 3741 :             {
; 3742 :                 DEBUGMSG(ZONE_INFO, (L"!!! UfnPdd_RegisterDevice:  USB FN does not support ISOCH\r\n"));
; 3743 :             }
; 3744 :         }
; 3745 :     }
; 3746 :     
; 3747 :     // Configure Tx EPs
; 3748 :     for (ifc = 0; ifc < pFullSpeedConfig->Descriptor.bNumInterfaces; ifc++)

  000c0	e5de3008	 ldrb        r3, [lr, #8]
  000c4	e3a04000	 mov         r4, #0
  000c8	e3a0b000	 mov         r11, #0
  000cc	e3530000	 cmp         r3, #0
  000d0	0a00001e	 beq         |$LN20@UfnPdd_Reg|
  000d4	e3a05000	 mov         r5, #0
  000d8		 |$LL22@UfnPdd_Reg|

; 3749 :     {
; 3750 :         // For each endpoint in interface
; 3751 :         pIFC = &pFullSpeedConfig->pInterfaces[ifc];

  000d8	e59e3018	 ldr         r3, [lr, #0x18]

; 3752 :         for (epx = 0; epx < pIFC->Descriptor.bNumEndpoints; epx++)

  000dc	e3a07000	 mov         r7, #0
  000e0	e0858003	 add         r8, r5, r3
  000e4	e5d83008	 ldrb        r3, [r8, #8]
  000e8	e3530000	 cmp         r3, #0
  000ec	0a000012	 beq         |$LN21@UfnPdd_Reg|
  000f0	e3a06000	 mov         r6, #0
  000f4	e3a0e034	 mov         lr, #0x34
  000f8		 |$LL19@UfnPdd_Reg|

; 3753 :         {
; 3754 :             pEP = &pIFC->pEndpoints[epx];

  000f8	e5983018	 ldr         r3, [r8, #0x18]

; 3755 :             // If it is Rx EP skip it
; 3756 :             if ((pEP->Descriptor.bEndpointAddress & 0x80) == 0)
; 3757 :                 continue;
; 3758 :             // Get EP address
; 3759 :             ep = pEP->Descriptor.bEndpointAddress & 0x0F;
; 3760 :             // Save max packet size & direction
; 3761 :             pPdd->ep[ep].maxPacketSize = pEP->Descriptor.wMaxPacketSize;
; 3762 :             pPdd->ep[ep].dirRx = FALSE;

  000fc	e2877001	 add         r7, r7, #1
  00100	e0863003	 add         r3, r6, r3
  00104	e5d31006	 ldrb        r1, [r3, #6]
  00108	e2866014	 add         r6, r6, #0x14
  0010c	e3110080	 tst         r1, #0x80
  00110	15d30008	 ldrneb      r0, [r3, #8]
  00114	15d32009	 ldrneb      r2, [r3, #9]
  00118	1201300f	 andne       r3, r1, #0xF
  0011c	10219e93	 mlane       r1, r3, lr, r9
  00120	11803402	 orrne       r3, r0, r2, lsl #8
  00124	11c13abc	 strneh      r3, [r1, #0xAC]
  00128	1581b0b0	 strne       r11, [r1, #0xB0]
  0012c	e5d83008	 ldrb        r3, [r8, #8]
  00130	e1570003	 cmp         r7, r3
  00134	3affffef	 bcc         |$LL19@UfnPdd_Reg|
  00138	e59de028	 ldr         lr, [sp, #0x28]
  0013c		 |$LN21@UfnPdd_Reg|

; 3739 :             
; 3740 :             if ((pEP->Descriptor.bmAttributes & 0x03) == 0x01)
; 3741 :             {
; 3742 :                 DEBUGMSG(ZONE_INFO, (L"!!! UfnPdd_RegisterDevice:  USB FN does not support ISOCH\r\n"));
; 3743 :             }
; 3744 :         }
; 3745 :     }
; 3746 :     
; 3747 :     // Configure Tx EPs
; 3748 :     for (ifc = 0; ifc < pFullSpeedConfig->Descriptor.bNumInterfaces; ifc++)

  0013c	e5de3008	 ldrb        r3, [lr, #8]
  00140	e2844001	 add         r4, r4, #1
  00144	e285501c	 add         r5, r5, #0x1C
  00148	e1540003	 cmp         r4, r3
  0014c	3affffe1	 bcc         |$LL22@UfnPdd_Reg|
  00150		 |$LN20@UfnPdd_Reg|

; 3763 :             
; 3764 :             if ((pEP->Descriptor.bmAttributes & 0x03) == 0x01)
; 3765 :             {
; 3766 :                 DEBUGMSG(ZONE_INFO, (L"!!! UfnPdd_RegisterDevice:  USB FN does not support ISOCH\r\n"));
; 3767 :             }
; 3768 :             
; 3769 :         }
; 3770 :     }
; 3771 : 
; 3772 :     // Handle Special case for Mass Storage Devices
; 3773 :     pPdd->FsEpMassStoreFlags = 0;

  00150	e2893b01	 add         r3, r9, #1, 22
  00154	e1c3b2bc	 strh        r11, [r3, #0x2C]

; 3774 :     for (ifc = 0; ifc < pFullSpeedConfig->Descriptor.bNumInterfaces; ifc++)

  00158	e5de3008	 ldrb        r3, [lr, #8]
  0015c	e3a04000	 mov         r4, #0
  00160	e3530000	 cmp         r3, #0
  00164	0a00001d	 beq         |$LN12@UfnPdd_Reg|
  00168	e3a00000	 mov         r0, #0
  0016c	e3a08001	 mov         r8, #1
  00170		 |$LL14@UfnPdd_Reg|

; 3775 :     {
; 3776 :         // For each endpoint in interface
; 3777 :         pIFC = &pFullSpeedConfig->pInterfaces[ifc];

  00170	e59e3018	 ldr         r3, [lr, #0x18]
  00174	e0805003	 add         r5, r0, r3

; 3778 : 
; 3779 :         // check for mass storage device
; 3780 :         if(pIFC->Descriptor.bInterfaceClass == 0x08)

  00178	e5d53009	 ldrb        r3, [r5, #9]
  0017c	e3530008	 cmp         r3, #8
  00180	1a000011	 bne         |$LN13@UfnPdd_Reg|

; 3781 :         {
; 3782 :             // do not complete packets with 0 that end are divizable by max packet size
; 3783 :             // this will prevent the CSW packet from being sent and will force the host to reset us
; 3784 :             
; 3785 :             // set a bit flag for endpoints
; 3786 :             for (epx = 0; epx < pIFC->Descriptor.bNumEndpoints; epx++)

  00184	e5d53008	 ldrb        r3, [r5, #8]
  00188	e3a07000	 mov         r7, #0
  0018c	e3530000	 cmp         r3, #0
  00190	0a00000d	 beq         |$LN13@UfnPdd_Reg|
  00194	e3a06000	 mov         r6, #0
  00198		 |$LL10@UfnPdd_Reg|

; 3787 :             {
; 3788 :                 pEP = &pIFC->pEndpoints[epx];
; 3789 :                 // Get EP address
; 3790 :                 ep = pEP->Descriptor.bEndpointAddress & 0x0F;
; 3791 :                 // Save Bit Flag
; 3792 :                 pPdd->FsEpMassStoreFlags |= 1 << ep;

  00198	e5953018	 ldr         r3, [r5, #0x18]
  0019c	e2891b01	 add         r1, r9, #1, 22
  001a0	e1d122bc	 ldrh        r2, [r1, #0x2C]
  001a4	e0863003	 add         r3, r6, r3
  001a8	e5d33006	 ldrb        r3, [r3, #6]
  001ac	e2877001	 add         r7, r7, #1
  001b0	e2866014	 add         r6, r6, #0x14
  001b4	e203300f	 and         r3, r3, #0xF
  001b8	e1823318	 orr         r3, r2, r8, lsl r3
  001bc	e1c132bc	 strh        r3, [r1, #0x2C]
  001c0	e5d53008	 ldrb        r3, [r5, #8]
  001c4	e1570003	 cmp         r7, r3
  001c8	3afffff2	 bcc         |$LL10@UfnPdd_Reg|
  001cc		 |$LN13@UfnPdd_Reg|

; 3774 :     for (ifc = 0; ifc < pFullSpeedConfig->Descriptor.bNumInterfaces; ifc++)

  001cc	e5de3008	 ldrb        r3, [lr, #8]
  001d0	e2844001	 add         r4, r4, #1
  001d4	e280001c	 add         r0, r0, #0x1C
  001d8	e1540003	 cmp         r4, r3
  001dc	3affffe3	 bcc         |$LL14@UfnPdd_Reg|
  001e0		 |$LN12@UfnPdd_Reg|

; 3793 :             }
; 3794 :         }
; 3795 :     }
; 3796 :     pPdd->HsEpMassStoreFlags = 0;

  001e0	e2893b01	 add         r3, r9, #1, 22
  001e4	e1c3b2be	 strh        r11, [r3, #0x2E]

; 3797 :     for (ifc = 0; ifc < pFullSpeedConfig->Descriptor.bNumInterfaces; ifc++)

  001e8	e5de3008	 ldrb        r3, [lr, #8]
  001ec	e3a04000	 mov         r4, #0
  001f0	e3530000	 cmp         r3, #0
  001f4	0a00001d	 beq         |$LN5@UfnPdd_Reg|
  001f8	e3a00000	 mov         r0, #0
  001fc	e3a08001	 mov         r8, #1
  00200		 |$LL7@UfnPdd_Reg|

; 3798 :     {
; 3799 :         // For each endpoint in interface
; 3800 :         pIFC = &pHighSpeedConfig->pInterfaces[ifc];

  00200	e59a3018	 ldr         r3, [r10, #0x18]
  00204	e0835000	 add         r5, r3, r0

; 3801 : 
; 3802 :         // check for mass storage device
; 3803 :         if(pIFC->Descriptor.bInterfaceClass == 0x08)

  00208	e5d53009	 ldrb        r3, [r5, #9]
  0020c	e3530008	 cmp         r3, #8
  00210	1a000011	 bne         |$LN6@UfnPdd_Reg|

; 3804 :         {
; 3805 :             // do not complete packets with 0 that end are divizable by max packet size
; 3806 :             // this will prevent the CSW packet form being sent and will force the host to reset us
; 3807 : 
; 3808 :             // set a bit flag for endpoints
; 3809 :             for (epx = 0; epx < pIFC->Descriptor.bNumEndpoints; epx++)

  00214	e5d53008	 ldrb        r3, [r5, #8]
  00218	e3a07000	 mov         r7, #0
  0021c	e3530000	 cmp         r3, #0
  00220	0a00000d	 beq         |$LN6@UfnPdd_Reg|
  00224	e3a06000	 mov         r6, #0
  00228		 |$LL3@UfnPdd_Reg|

; 3810 :             {
; 3811 :                 pEP = &pIFC->pEndpoints[epx];
; 3812 :                 // Get EP address
; 3813 :                 ep = pEP->Descriptor.bEndpointAddress & 0x0F;
; 3814 :                 // Save Bit Flag
; 3815 :                 pPdd->HsEpMassStoreFlags |= 1 << ep;

  00228	e5953018	 ldr         r3, [r5, #0x18]
  0022c	e2891b01	 add         r1, r9, #1, 22
  00230	e1d122be	 ldrh        r2, [r1, #0x2E]
  00234	e0863003	 add         r3, r6, r3
  00238	e5d33006	 ldrb        r3, [r3, #6]
  0023c	e2877001	 add         r7, r7, #1
  00240	e2866014	 add         r6, r6, #0x14
  00244	e203300f	 and         r3, r3, #0xF
  00248	e1823318	 orr         r3, r2, r8, lsl r3
  0024c	e1c132be	 strh        r3, [r1, #0x2E]
  00250	e5d53008	 ldrb        r3, [r5, #8]
  00254	e1570003	 cmp         r7, r3
  00258	3afffff2	 bcc         |$LL3@UfnPdd_Reg|
  0025c		 |$LN6@UfnPdd_Reg|

; 3797 :     for (ifc = 0; ifc < pFullSpeedConfig->Descriptor.bNumInterfaces; ifc++)

  0025c	e5de3008	 ldrb        r3, [lr, #8]
  00260	e2844001	 add         r4, r4, #1
  00264	e280001c	 add         r0, r0, #0x1C
  00268	e1540003	 cmp         r4, r3
  0026c	3affffe3	 bcc         |$LL7@UfnPdd_Reg|
  00270		 |$LN5@UfnPdd_Reg|

; 3816 :             }
; 3817 :         }
; 3818 :     }
; 3819 : 
; 3820 :     // Done
; 3821 :     return ERROR_SUCCESS;

  00270	e3a00000	 mov         r0, #0

; 3822 : }

  00274	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00278	e12fff1e	 bx          lr
  0027c		 |$M49748|

			 ENDP  ; |UfnPdd_RegisterDevice|

	EXPORT	|UfnPdd_IsEndpointSupportable|

  00000			 AREA	 |.pdata|, PDATA
|$T49761| DCD	|$LN6@UfnPdd_IsE@2|
	DCD	0x40000700
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_IsEndpointSupportable| PROC

; 3860 : {

  00000		 |$LN6@UfnPdd_IsE@2|
  00000		 |$M49758|
  00000	e3510000	 cmp         r1, #0

; 3861 : 	UNREFERENCED_PARAMETER(pPddContext);
; 3862 : 	UNREFERENCED_PARAMETER(speed);
; 3863 : 	UNREFERENCED_PARAMETER(configurationValue);
; 3864 : 	UNREFERENCED_PARAMETER(interfaceNumber);
; 3865 : 	UNREFERENCED_PARAMETER(alternateSetting);
; 3866 : 
; 3867 :     DEBUGMSG(ZONE_FUNCTION, (L"UfnPdd_IsEndpointSupportable\r\n"));
; 3868 :     
; 3869 :     // Update maximal packet size for EP0
; 3870 :     if (endpoint == 0)
; 3871 :     {
; 3872 :         DEBUGCHK(pEPDesc->wMaxPacketSize <= 64);
; 3873 :         DEBUGCHK(pEPDesc->bmAttributes == USB_ENDPOINT_TYPE_CONTROL);
; 3874 :         pEPDesc->wMaxPacketSize = 64;

  00004	03a02040	 moveq       r2, #0x40
  00008	03a01000	 moveq       r1, #0
  0000c	05c32004	 streqb      r2, [r3, #4]
  00010	05c31005	 streqb      r1, [r3, #5]

; 3875 :     }
; 3876 :     
; 3877 :     return ERROR_SUCCESS;

  00014	e3a00000	 mov         r0, #0

; 3878 : }

  00018	e12fff1e	 bx          lr
  0001c		 |$M49759|

			 ENDP  ; |UfnPdd_IsEndpointSupportable|

	EXPORT	|UfnPdd_IsConfigurationSupportable|

  00000			 AREA	 |.pdata|, PDATA
|$T49783| DCD	|$LN20@UfnPdd_IsC|
	DCD	0x40003201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_IsConfigurationSupportable| PROC

; 3910 : {

  00000		 |$LN20@UfnPdd_IsC|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M49780|
  00004	e1a05002	 mov         r5, r2

; 3911 :     DWORD rc = ERROR_INVALID_PARAMETER;
; 3912 :     UFN_INTERFACE *pIFC;
; 3913 :     UFN_ENDPOINT *pEP;
; 3914 :     WORD ifc, epx, count;
; 3915 :     WORD size;
; 3916 : 
; 3917 : 	UNREFERENCED_PARAMETER(pPddContext);
; 3918 : 	UNREFERENCED_PARAMETER(speed);
; 3919 : 
; 3920 :     DEBUGMSG(ZONE_FUNCTION, (L"UfnPdd_IsConfigurationSupportable\r\n"));
; 3921 :     
; 3922 :     // Clear number of end points
; 3923 :     count = 0;
; 3924 :     
; 3925 :     // For each interface in configuration
; 3926 :     for (ifc = 0; ifc < pConfig->Descriptor.bNumInterfaces; ifc++)

  00008	e5d53008	 ldrb        r3, [r5, #8]
  0000c	e3a00057	 mov         r0, #0x57
  00010	e3a04000	 mov         r4, #0
  00014	e3530000	 cmp         r3, #0
  00018	e3a0e000	 mov         lr, #0
  0001c	0a000025	 beq         |$LN8@UfnPdd_IsC|
  00020		 |$LL10@UfnPdd_IsC|

; 3927 :     {
; 3928 :         // For each endpoint in interface
; 3929 :         pIFC = &pConfig->pInterfaces[ifc];

  00020	e5951018	 ldr         r1, [r5, #0x18]
  00024	e06e318e	 rsb         r3, lr, lr, lsl #3

; 3930 :         for (epx = 0; epx < pIFC->Descriptor.bNumEndpoints; epx++)

  00028	e3a08000	 mov         r8, #0
  0002c	e0816103	 add         r6, r1, r3, lsl #2
  00030	e5d63008	 ldrb        r3, [r6, #8]
  00034	e3530000	 cmp         r3, #0
  00038	0a000014	 beq         |$LN5@UfnPdd_IsC|
  0003c		 |$LL7@UfnPdd_IsC|

; 3931 :         {
; 3932 :             pEP = &pIFC->pEndpoints[epx];

  0003c	e5961018	 ldr         r1, [r6, #0x18]
  00040	e0883108	 add         r3, r8, r8, lsl #2
  00044	e0817103	 add         r7, r1, r3, lsl #2

; 3933 :             
; 3934 :             if (pEP->Descriptor.wMaxPacketSize > MAX_EPX_PKTSIZE) 

  00048	e5d71008	 ldrb        r1, [r7, #8]
  0004c	e5d73009	 ldrb        r3, [r7, #9]
  00050	e1812403	 orr         r2, r1, r3, lsl #8

; 3935 :             {
; 3936 :                 size = MAX_EPX_PKTSIZE;
; 3937 :             }
; 3938 :             else
; 3939 :             {
; 3940 :                 size = pEP->Descriptor.wMaxPacketSize;
; 3941 :             }
; 3942 :             
; 3943 :             
; 3944 :             // Is it ISO end point?
; 3945 :             if ((pEP->Descriptor.bmAttributes & 0x03) == 0x01)

  00054	e5d73007	 ldrb        r3, [r7, #7]
  00058	e3520b01	 cmp         r2, #1, 22
  0005c	83a02b01	 movhi       r2, #1, 22
  00060	e2033003	 and         r3, r3, #3
  00064	e3530001	 cmp         r3, #1
  00068	0a000014	 beq         |$cleanUp$48477|

; 3946 :             {
; 3947 :                 // Actual driver doesn't support ISO endpoints
; 3948 :                 goto cleanUp;
; 3949 :             }
; 3950 :             // Update EP size
; 3951 :             pEP->Descriptor.wMaxPacketSize = size;

  0006c	e1a03422	 mov         r3, r2, lsr #8
  00070	e5c73009	 strb        r3, [r7, #9]
  00074	e2883001	 add         r3, r8, #1
  00078	e5c72008	 strb        r2, [r7, #8]
  0007c	e5d62008	 ldrb        r2, [r6, #8]
  00080	e1a08803	 mov         r8, r3, lsl #16
  00084	e1a08828	 mov         r8, r8, lsr #16
  00088	e1580002	 cmp         r8, r2
  0008c	3affffea	 bcc         |$LL7@UfnPdd_IsC|
  00090		 |$LN5@UfnPdd_IsC|

; 3952 :         }
; 3953 :         // Add number of end points to total count
; 3954 :         count = count +pIFC->Descriptor.bNumEndpoints;

  00090	e5d62008	 ldrb        r2, [r6, #8]
  00094	e5d51008	 ldrb        r1, [r5, #8]
  00098	e28e3001	 add         r3, lr, #1
  0009c	e0822004	 add         r2, r2, r4
  000a0	e1a0e803	 mov         lr, r3, lsl #16
  000a4	e1a04802	 mov         r4, r2, lsl #16
  000a8	e1a0e82e	 mov         lr, lr, lsr #16
  000ac	e1a04824	 mov         r4, r4, lsr #16
  000b0	e15e0001	 cmp         lr, r1
  000b4	3affffd9	 bcc         |$LL10@UfnPdd_IsC|
  000b8		 |$LN8@UfnPdd_IsC|

; 3955 :     }
; 3956 :     
; 3957 :     // Can we support this configuration?
; 3958 :     if (count < USBD_EP_COUNT)

  000b8	e3540010	 cmp         r4, #0x10

; 3959 :         rc = ERROR_SUCCESS;

  000bc	33a00000	 movcc       r0, #0
  000c0		 |$cleanUp$48477|

; 3960 :     
; 3961 : cleanUp:
; 3962 :     return rc;
; 3963 : }

  000c0	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000c4	e12fff1e	 bx          lr
  000c8		 |$M49781|

			 ENDP  ; |UfnPdd_IsConfigurationSupportable|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|UfnPdd_Init|
	EXPORT	|??_C@_11LOCGONAA@?$AA?$AA@| [ DATA ]	; `string'
	EXPORT	|??_C@_1CC@CKFJFILD@?$AAU?$AAS?$AAB?$AAC?$AAh?$AAa?$AAr?$AAg?$AAe?$AAr?$AAN?$AAo?$AAt?$AAi?$AAf?$AAy?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BI@KEGLAEOK@?$AAO?$AAT?$AAG?$AAU?$AAS?$AAB?$AAC?$AAl?$AAo?$AAc?$AAk?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BE@JNKHMKGH@?$AAO?$AAT?$AAG?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CC@PKGPLCAL@?$AAo?$AAm?$AAa?$AAp?$AA_?$AAm?$AAu?$AAs?$AAb?$AAo?$AAt?$AAg?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1JG@KGFPJKPC@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAv?$AAi?$AAr?$AAt?$AAu@| [ DATA ] ; `string'
	EXPORT	|??_C@_1JO@FKEMNFJK@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc@| [ DATA ] ; `string'
	IMPORT	|GetProcAddressW|
	IMPORT	|GetModuleHandleW|
	IMPORT	|VirtualCopy|
	IMPORT	|VirtualAlloc|
	IMPORT	|AllocPhysMem|
	IMPORT	|CreateBusAccessHandle|
	IMPORT	|GetDeviceRegistryParams|
	IMPORT	|CreateEventW|
	IMPORT	|InitializeCriticalSection|
	IMPORT	|LocalAlloc|
	IMPORT	|wcscpy|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T49814| DCD	|$LN29@UfnPdd_Ini@3|
	DCD	0xc0011002

  00000			 AREA	 |.xdata|, DATA
|$T49810| DCD	0xffffffd8

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_11LOCGONAA@?$AA?$AA@| DCB 0x0, 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@CKFJFILD@?$AAU?$AAS?$AAB?$AAC?$AAh?$AAa?$AAr?$AAg?$AAe?$AAr?$AAN?$AAo?$AAt?$AAi?$AAf?$AAy?$AA?$AA@| DCB "U"
	DCB	0x0, "S", 0x0, "B", 0x0, "C", 0x0, "h", 0x0, "a", 0x0, "r"
	DCB	0x0, "g", 0x0, "e", 0x0, "r", 0x0, "N", 0x0, "o", 0x0, "t"
	DCB	0x0, "i", 0x0, "f", 0x0, "y", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BI@KEGLAEOK@?$AAO?$AAT?$AAG?$AAU?$AAS?$AAB?$AAC?$AAl?$AAo?$AAc?$AAk?$AA?$AA@| DCB "O"
	DCB	0x0, "T", 0x0, "G", 0x0, "U", 0x0, "S", 0x0, "B", 0x0, "C"
	DCB	0x0, "l", 0x0, "o", 0x0, "c", 0x0, "k", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@JNKHMKGH@?$AAO?$AAT?$AAG?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AA?$AA@| DCB "O"
	DCB	0x0, "T", 0x0, "G", 0x0, "A", 0x0, "t", 0x0, "t", 0x0, "a"
	DCB	0x0, "c", 0x0, "h", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@PKGPLCAL@?$AAo?$AAm?$AAa?$AAp?$AA_?$AAm?$AAu?$AAs?$AAb?$AAo?$AAt?$AAg?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@| DCB "o"
	DCB	0x0, "m", 0x0, "a", 0x0, "p", 0x0, "_", 0x0, "m", 0x0, "u"
	DCB	0x0, "s", 0x0, "b", 0x0, "o", 0x0, "t", 0x0, "g", 0x0, "."
	DCB	0x0, "d", 0x0, "l", 0x0, "l", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1JG@KGFPJKPC@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAv?$AAi?$AAr?$AAt?$AAu@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "U", 0x0, "f", 0x0, "n", 0x0, "P", 0x0, "d", 0x0, "d"
	DCB	0x0, "_", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, ":"
	DCB	0x0, " ", 0x0, "F", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e"
	DCB	0x0, "d", 0x0, " ", 0x0, "v", 0x0, "i", 0x0, "r", 0x0, "t"
	DCB	0x0, "u", 0x0, "a", 0x0, "l", 0x0, " ", 0x0, "c", 0x0, "o"
	DCB	0x0, "p", 0x0, "y", 0x0, " ", 0x0, "a", 0x0, "d", 0x0, "d"
	DCB	0x0, "r", 0x0, "e", 0x0, "s", 0x0, "s", 0x0, " ", 0x0, "f"
	DCB	0x0, "o", 0x0, "r", 0x0, " ", 0x0, "T", 0x0, "x", 0x0, "0"
	DCB	0x0, " ", 0x0, "b", 0x0, "u", 0x0, "f", 0x0, "f", 0x0, "e"
	DCB	0x0, "r", 0x0, " ", 0x0, "(", 0x0, "s", 0x0, "i", 0x0, "z"
	DCB	0x0, "e", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ")", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1JO@FKEMNFJK@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "U", 0x0, "f", 0x0, "n", 0x0, "P", 0x0, "d", 0x0, "d"
	DCB	0x0, "_", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, ":"
	DCB	0x0, " ", 0x0, "F", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e"
	DCB	0x0, "d", 0x0, " ", 0x0, "a", 0x0, "l", 0x0, "l", 0x0, "o"
	DCB	0x0, "c", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, " ", 0x0, "v"
	DCB	0x0, "i", 0x0, "r", 0x0, "t", 0x0, "u", 0x0, "a", 0x0, "l"
	DCB	0x0, " ", 0x0, "a", 0x0, "d", 0x0, "d", 0x0, "r", 0x0, "e"
	DCB	0x0, "s", 0x0, "s", 0x0, " ", 0x0, "f", 0x0, "o", 0x0, "r"
	DCB	0x0, " ", 0x0, "T", 0x0, "x", 0x0, "0", 0x0, " ", 0x0, "b"
	DCB	0x0, "u", 0x0, "f", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "(", 0x0, "s", 0x0, "i", 0x0, "z", 0x0, "e", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, ")", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbfn\pdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T49810|

  00008		 |UfnPdd_Init| PROC

; 3991 : {

  00008		 |$LN29@UfnPdd_Ini@3|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24ddf8e	 sub         sp, sp, #0x8E, 30
  00010		 |$M49811|
  00010	e58d3014	 str         r3, [sp, #0x14]
  00014	e58d2020	 str         r2, [sp, #0x20]
  00018	e58d1024	 str         r1, [sp, #0x24]
  0001c	e1a04000	 mov         r4, r0
  00020	e59fe41c	 ldr         lr, [pc, #0x41C]
  00024	e59ee000	 ldr         lr, [lr]
  00028	e58de234	 str         lr, [sp, #0x234]
  0002c	e3a03b01	 mov         r3, #1, 22

; 3992 :     DWORD rc = ERROR_INVALID_PARAMETER;
; 3993 :     HMODULE hOTGInstance;
; 3994 :     LPMUSB_ATTACH_PROC lphAttachProc;
; 3995 :     BOOL bRet = FALSE;
; 3996 :     PHSMUSB_T pOTG;
; 3997 :     MUsbFnPdd_t *pPdd;
; 3998 :     HKEY hkDevice;
; 3999 :     DWORD dwStatus;
; 4000 :     DWORD dwType, dwSize;
; 4001 :     TCHAR szChargeEventName[MAX_PATH+1];
; 4002 :     
; 4003 :     DEBUGMSG(ZONE_FUNCTION, (TEXT("UfnPdd_Init called\r\n")));
; 4004 :     // Allocate PDD object
; 4005 :     pPdd = LocalAlloc(LPTR, sizeof(MUsbFnPdd_t));

  00030	e383103c	 orr         r1, r3, #0x3C
  00034	e3a00040	 mov         r0, #0x40
  00038	e3a06057	 mov         r6, #0x57
  0003c	eb000000	 bl          LocalAlloc
  00040	e1b05000	 movs        r5, r0
  00044	e58d5010	 str         r5, [sp, #0x10]

; 4006 :     if (pPdd == NULL)

  00048	0a0000d9	 beq         |$cleanUp$48503|

; 4007 :         goto cleanUp;
; 4008 :     
; 4009 :     // Initialize critical section
; 4010 :     InitializeCriticalSection(&pPdd->dmaCS);

  0004c	e2850034	 add         r0, r5, #0x34
  00050	eb000000	 bl          InitializeCriticalSection

; 4011 :     InitializeCriticalSection(&pPdd->epCS);

  00054	e2850078	 add         r0, r5, #0x78
  00058	eb000000	 bl          InitializeCriticalSection

; 4012 :     
; 4013 :     InitializeCriticalSection(&pPdd->powerStateCS);

  0005c	e285008c	 add         r0, r5, #0x8C
  00060	eb000000	 bl          InitializeCriticalSection

; 4014 :     pPdd->hPowerDownEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  00064	e3a03000	 mov         r3, #0
  00068	e3a02000	 mov         r2, #0
  0006c	e3a01000	 mov         r1, #0
  00070	e3a00000	 mov         r0, #0
  00074	eb000000	 bl          CreateEventW
  00078	e3500000	 cmp         r0, #0
  0007c	e58500a0	 str         r0, [r5, #0xA0]

; 4015 :     if (pPdd->hPowerDownEvent == NULL)

  00080	0a0000cb	 beq         |$cleanUp$48503|

; 4016 :     {
; 4017 :         DEBUGMSG(TRUE, (TEXT("MUSBFN:Failed to create hPowerDownEvent\r\n")));
; 4018 :         goto cleanUp;
; 4019 :     }
; 4020 : 
; 4021 :     pPdd->devState = 0;
; 4022 :     
; 4023 :     // Read device parameters
; 4024 :     if (GetDeviceRegistryParams(
; 4025 :         szActiveKey, pPdd, dimof(s_deviceRegParams), s_deviceRegParams
; 4026 :         ) != ERROR_SUCCESS)

  00084	e59f33b4	 ldr         r3, [pc, #0x3B4]
  00088	e3a07000	 mov         r7, #0
  0008c	e3a02006	 mov         r2, #6
  00090	e1a01005	 mov         r1, r5
  00094	e1a00004	 mov         r0, r4
  00098	e585706c	 str         r7, [r5, #0x6C]
  0009c	eb000000	 bl          GetDeviceRegistryParams
  000a0	e3500000	 cmp         r0, #0
  000a4	1a0000c2	 bne         |$cleanUp$48503|

; 4027 :     {
; 4028 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: UfnPdd_Init: "
; 4029 :             L"Failed read registry parameters\r\n"
; 4030 :             ));
; 4031 :         goto cleanUp;
; 4032 :     }
; 4033 : 
; 4034 :     // Set PM to Default
; 4035 :     pPdd->pmPowerState = D4;
; 4036 :     pPdd->selfPowerState = D0;
; 4037 :     pPdd->actualPowerState = D4;
; 4038 : 
; 4039 :     InitializeCriticalSection(&pPdd->csDVFS);

  000a8	e2853b01	 add         r3, r5, #1, 22
  000ac	e2830014	 add         r0, r3, #0x14
  000b0	e3a03004	 mov         r3, #4
  000b4	e5853060	 str         r3, [r5, #0x60]
  000b8	e5853068	 str         r3, [r5, #0x68]
  000bc	e5857064	 str         r7, [r5, #0x64]
  000c0	eb000000	 bl          InitializeCriticalSection

; 4040 : 
; 4041 :     // initialize dvfs variables
; 4042 :     pPdd->bDVFSActive = FALSE;
; 4043 :     pPdd->nActiveDmaCount = 0;
; 4044 :     pPdd->hDVFSAckEvent = NULL;
; 4045 :     // bDVFSAck is required to avoid duplicate ack DVFSAck event.
; 4046 :     // this is especially when DVFS happening and it is in the process of copying
; 4047 :     pPdd->bDVFSAck = FALSE;
; 4048 :     pPdd->hDVFSActivityEvent = NULL;
; 4049 : 
; 4050 :     
; 4051 :     // Open parent bus
; 4052 :     pPdd->hParentBus = CreateBusAccessHandle(szActiveKey);

  000c4	e1a00004	 mov         r0, r4
  000c8	e5857400	 str         r7, [r5, #0x400]
  000cc	e5857408	 str         r7, [r5, #0x408]
  000d0	e585740c	 str         r7, [r5, #0x40C]
  000d4	e5857404	 str         r7, [r5, #0x404]
  000d8	e5857410	 str         r7, [r5, #0x410]
  000dc	eb000000	 bl          CreateBusAccessHandle
  000e0	e3500000	 cmp         r0, #0
  000e4	e5850030	 str         r0, [r5, #0x30]

; 4053 :     if (pPdd->hParentBus == NULL)

  000e8	0a0000b1	 beq         |$cleanUp$48503|

; 4054 :     {
; 4055 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: UfnPdd_Init: "
; 4056 :             L"Failed open parent bus driver\r\n"
; 4057 :             ));
; 4058 :         goto cleanUp;
; 4059 :     }
; 4060 :     
; 4061 :     // Set hardware to standby mode
; 4062 :     pPdd->selfPowerState = D2;
; 4063 :     
; 4064 :     
; 4065 :     // Allocate DMA Rx0 buffer
; 4066 :     pPdd->pDmaRx0Buffer = AllocPhysMem(
; 4067 :         pPdd->rx0DmaBufferSize, PAGE_READWRITE | PAGE_NOCACHE, 0, 0,
; 4068 :         &pPdd->paDmaRx0Buffer
; 4069 :         );

  000ec	e5950014	 ldr         r0, [r5, #0x14]
  000f0	e3a04002	 mov         r4, #2
  000f4	e285e04c	 add         lr, r5, #0x4C
  000f8	e3a03000	 mov         r3, #0
  000fc	e3a02000	 mov         r2, #0
  00100	e3a01f81	 mov         r1, #0x81, 30
  00104	e5854064	 str         r4, [r5, #0x64]
  00108	e58de000	 str         lr, [sp]
  0010c	eb000000	 bl          AllocPhysMem
  00110	e3500000	 cmp         r0, #0
  00114	e5850048	 str         r0, [r5, #0x48]

; 4070 :     if (pPdd->pDmaRx0Buffer == NULL)

  00118	0a0000a5	 beq         |$cleanUp$48503|

; 4071 :     {
; 4072 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: UfnPdd_Init: "
; 4073 :             L"Failed allocate DMA Rx0 buffer (size %d)\r\n",
; 4074 :             pPdd->rx0DmaBufferSize
; 4075 :             ));
; 4076 :         goto cleanUp;
; 4077 :     }
; 4078 :     
; 4079 :     // Allocate DMA Tx0 buffer
; 4080 :     pPdd->pDmaTx0Buffer = AllocPhysMem(
; 4081 :         pPdd->tx0DmaBufferSize, PAGE_READWRITE | PAGE_NOCACHE, 0, 0,
; 4082 :         &pPdd->paDmaTx0Buffer
; 4083 :         );

  0011c	e5950018	 ldr         r0, [r5, #0x18]
  00120	e285e054	 add         lr, r5, #0x54
  00124	e3a03000	 mov         r3, #0
  00128	e3a02000	 mov         r2, #0
  0012c	e3a01f81	 mov         r1, #0x81, 30
  00130	e58de000	 str         lr, [sp]
  00134	eb000000	 bl          AllocPhysMem
  00138	e3500000	 cmp         r0, #0
  0013c	e5850050	 str         r0, [r5, #0x50]

; 4084 :     if (pPdd->pDmaTx0Buffer == NULL)

  00140	0a00009b	 beq         |$cleanUp$48503|

; 4085 :     {
; 4086 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: UfnPdd_Init: "
; 4087 :             L"Failed allocate DMA Tx0 buffer (size %d)\r\n",
; 4088 :             pPdd->tx0DmaBufferSize
; 4089 :             ));
; 4090 :         goto cleanUp;
; 4091 :     }
; 4092 :         
; 4093 :     pPdd->pCachedDmaTx0Buffer = VirtualAlloc(NULL, pPdd->tx0DmaBufferSize, MEM_RESERVE, PAGE_READWRITE);

  00144	e5951018	 ldr         r1, [r5, #0x18]
  00148	e3a03004	 mov         r3, #4
  0014c	e3a02a02	 mov         r2, #2, 20
  00150	e3a00000	 mov         r0, #0
  00154	eb000000	 bl          VirtualAlloc
  00158	e3500000	 cmp         r0, #0
  0015c	e5850058	 str         r0, [r5, #0x58]

; 4094 :     if (pPdd->pCachedDmaTx0Buffer == NULL)

  00160	1a000003	 bne         |$LN13@UfnPdd_Ini@3|

; 4095 :     {
; 4096 :         RETAILMSG(1, (L"ERROR: UfnPdd_Init: "
; 4097 :             L"Failed allocate virtual address for Tx0 buffer (size %d)\r\n",
; 4098 :             pPdd->tx0DmaBufferSize
; 4099 :             ));

  00164	e59f02d0	 ldr         r0, [pc, #0x2D0]
  00168		 |$LN26@UfnPdd_Ini@3|
  00168	e5951018	 ldr         r1, [r5, #0x18]
  0016c	eb000000	 bl          NKDbgPrintfW

; 4100 :         goto cleanUp;

  00170	ea00008f	 b           |$cleanUp$48503|
  00174		 |$LN13@UfnPdd_Ini@3|

; 4101 :     }
; 4102 : 
; 4103 :     if (!VirtualCopy(pPdd->pCachedDmaTx0Buffer, (PVOID)(pPdd->paDmaTx0Buffer>>8), pPdd->tx0DmaBufferSize, PAGE_READWRITE | PAGE_PHYSICAL))

  00174	e5953054	 ldr         r3, [r5, #0x54]
  00178	e5952018	 ldr         r2, [r5, #0x18]
  0017c	e3a0eb01	 mov         lr, #1, 22
  00180	e1a01423	 mov         r1, r3, lsr #8
  00184	e38e3004	 orr         r3, lr, #4
  00188	eb000000	 bl          VirtualCopy
  0018c	e3500000	 cmp         r0, #0

; 4104 :     {
; 4105 :         RETAILMSG(1, (L"ERROR: UfnPdd_Init: "
; 4106 :             L"Failed virtual copy address for Tx0 buffer (size %d)\r\n",
; 4107 :             pPdd->tx0DmaBufferSize
; 4108 :             ));

  00190	059f02a0	 ldreq       r0, [pc, #0x2A0]
  00194	0afffff3	 beq         |$LN26@UfnPdd_Ini@3|

; 4109 :         goto cleanUp;
; 4110 :     }
; 4111 : 
; 4112 :     // Get the OTG module handle
; 4113 :     hOTGInstance = GetModuleHandle(OTG_DRIVER);

  00198	e59f0294	 ldr         r0, [pc, #0x294]
  0019c	eb000000	 bl          GetModuleHandleW
  001a0	e1b04000	 movs        r4, r0

; 4114 :     if (hOTGInstance == NULL)

  001a4	1a000003	 bne         |$LN11@UfnPdd_Ini@3|
  001a8		 |$LN25@UfnPdd_Ini@3|

; 4115 :     {
; 4116 :         DEBUGMSG(ZONE_INFO, (TEXT("Failure to load %s\r\n"), OTG_DRIVER));
; 4117 :         return ERROR_GEN_FAILURE;

  001a8	e59d0234	 ldr         r0, [sp, #0x234]
  001ac	eb000000	 bl          __security_check_cookie
  001b0	e3a0601f	 mov         r6, #0x1F
  001b4	ea000080	 b           |$LN20@UfnPdd_Ini@3|
  001b8		 |$LN11@UfnPdd_Ini@3|

; 4118 :     }
; 4119 :     
; 4120 :     lphAttachProc =(LPMUSB_ATTACH_PROC)GetProcAddress(hOTGInstance, TEXT("OTGAttach"));

  001b8	e59f1270	 ldr         r1, [pc, #0x270]
  001bc	e1a00004	 mov         r0, r4
  001c0	eb000000	 bl          GetProcAddressW
  001c4	e1b03000	 movs        r3, r0

; 4121 :     if (lphAttachProc == NULL)
; 4122 :     {
; 4123 :         DEBUGMSG(ZONE_INFO, (TEXT("Failure to get OTGAttach\r\n")));
; 4124 :         return ERROR_GEN_FAILURE;

  001c8	0afffff6	 beq         |$LN25@UfnPdd_Ini@3|

; 4125 :     }
; 4126 :     
; 4127 :     DEBUGMSG(ZONE_INFO, (TEXT("AttachProc with 4 parameters\r\n")));
; 4128 :     bRet =(*lphAttachProc)(&gc_MUsbFuncs, DEVICE_MODE, (LPLPVOID)&pOTG);

  001cc	e59f0258	 ldr         r0, [pc, #0x258]
  001d0	e28d2008	 add         r2, sp, #8
  001d4	e3a01001	 mov         r1, #1
  001d8	e1a0e00f	 mov         lr, pc
  001dc	e12fff13	 bx          r3
  001e0	e3500000	 cmp         r0, #0

; 4129 :     if (bRet == FALSE)
; 4130 :     {
; 4131 :         DEBUGMSG(ZONE_INFO, (TEXT("Error in performing the attach procedure\r\n")));
; 4132 :         return ERROR_GEN_FAILURE;

  001e4	0affffef	 beq         |$LN25@UfnPdd_Ini@3|

; 4133 :     }
; 4134 : 
; 4135 :     pPdd->pfnEnUSBClock = (LPMUSB_USBCLOCK_PROC)GetProcAddress(hOTGInstance, TEXT("OTGUSBClock"));

  001e8	e59f1238	 ldr         r1, [pc, #0x238]
  001ec	e1a00004	 mov         r0, r4
  001f0	eb000000	 bl          GetProcAddressW
  001f4	e3500000	 cmp         r0, #0
  001f8	e585002c	 str         r0, [r5, #0x2C]

; 4136 :     if (pPdd->pfnEnUSBClock == NULL)
; 4137 :     {
; 4138 :         DEBUGMSG(ZONE_INFO, (TEXT("Failure to get OTGUSBClock\r\n")));
; 4139 :         return ERROR_GEN_FAILURE;

  001fc	0affffe9	 beq         |$LN25@UfnPdd_Ini@3|

; 4140 :     }
; 4141 : 
; 4142 :     dwStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCTSTR) REG_USBFN_DRV_PATH, 0, KEY_ALL_ACCESS, &hkDevice);

  00200	e59f121c	 ldr         r1, [pc, #0x21C]
  00204	e3a0380f	 mov         r3, #0xF, 16
  00208	e28de00c	 add         lr, sp, #0xC
  0020c	e383303f	 orr         r3, r3, #0x3F
  00210	e3a02000	 mov         r2, #0
  00214	e3a0010a	 mov         r0, #0xA, 2
  00218	e58de000	 str         lr, [sp]
  0021c	eb000000	 bl          RegOpenKeyExW
  00220	e3500000	 cmp         r0, #0

; 4143 :     if(dwStatus != ERROR_SUCCESS) {

  00224	1a000062	 bne         |$cleanUp$48503|

; 4144 :         DEBUGMSG(ZONE_INFO, (_T("UfnPdd_Init: OpenDeviceKey('%s') failed %u\r\n"), szActiveKey, dwStatus));
; 4145 :         goto cleanUp;
; 4146 :     }
; 4147 : 
; 4148 :     wcscpy(szChargeEventName,TEXT(""));

  00228	e59f11f0	 ldr         r1, [pc, #0x1F0]
  0022c	e28d0028	 add         r0, sp, #0x28
  00230	eb000000	 bl          wcscpy
  00234	e3a03c02	 mov         r3, #2, 24

; 4149 :     dwType = REG_SZ;
; 4150 :     dwSize = sizeof(szChargeEventName);
; 4151 :     dwStatus = RegQueryValueEx(hkDevice, REG_VBUS_CHARGE_EVENT_NAME, NULL, &dwType, 
; 4152 :         (LPBYTE) szChargeEventName, &dwSize);

  00238	e59f11dc	 ldr         r1, [pc, #0x1DC]
  0023c	e59d000c	 ldr         r0, [sp, #0xC]
  00240	e383300a	 orr         r3, r3, #0xA
  00244	e58d301c	 str         r3, [sp, #0x1C]
  00248	e3a07001	 mov         r7, #1
  0024c	e28de01c	 add         lr, sp, #0x1C
  00250	e28d4028	 add         r4, sp, #0x28
  00254	e28d3018	 add         r3, sp, #0x18
  00258	e3a02000	 mov         r2, #0
  0025c	e58d7018	 str         r7, [sp, #0x18]
  00260	e58de004	 str         lr, [sp, #4]
  00264	e58d4000	 str         r4, [sp]
  00268	eb000000	 bl          RegQueryValueExW
  0026c	e3500000	 cmp         r0, #0

; 4153 :     if(dwStatus != ERROR_SUCCESS || dwType != REG_SZ) {

  00270	1a00004d	 bne         |$LN5@UfnPdd_Ini@3|
  00274	e59d3018	 ldr         r3, [sp, #0x18]
  00278	e3530001	 cmp         r3, #1
  0027c	1a00004a	 bne         |$LN5@UfnPdd_Ini@3|

; 4157 :         goto cleanUp;
; 4158 :     }
; 4159 :     RegCloseKey(hkDevice);

  00280	e59d000c	 ldr         r0, [sp, #0xC]
  00284	eb000000	 bl          RegCloseKey

; 4160 :     
; 4161 :     DEBUGMSG(ZONE_ERROR,(L"USBHF RegQueryValueEx "L"Using Vbus Charge Event '%s'", szChargeEventName) );
; 4162 : 
; 4163 :     if (!dwStatus) 
; 4164 :     {
; 4165 :          pPdd->hVbusChargeEvent = CreateEvent( NULL, TRUE, FALSE, szChargeEventName );

  00288	e28d3028	 add         r3, sp, #0x28
  0028c	e3a02000	 mov         r2, #0
  00290	e3a01001	 mov         r1, #1
  00294	e3a00000	 mov         r0, #0
  00298	eb000000	 bl          CreateEventW
  0029c	e3500000	 cmp         r0, #0

; 4166 :          if ( pPdd->hVbusChargeEvent == NULL )
; 4167 :          {
; 4168 :             DEBUGMSG(ZONE_ERROR,(L"UfnPdd_Init() "
; 4169 :                     L"Failed to open Vbus Charge Event '%s'",
; 4170 :                     szChargeEventName));
; 4171 : 
; 4172 :             pPdd->hVbusChargeEvent = INVALID_HANDLE_VALUE;

  002a0	03e03000	 mvneq       r3, #0
  002a4	e5850428	 str         r0, [r5, #0x428]

; 4173 :          }
; 4174 :          else
; 4175 :          {
; 4176 :             DEBUGMSG(ZONE_ERROR,(L"UfnPdd_Init() "
; 4177 :                         L"Using Vbus Charge Event '%s'", szChargeEventName) );
; 4178 :          }
; 4179 :         // if event already exists, then handle to it will be returned
; 4180 :     }
; 4181 :     else
; 4182 :     {
; 4183 :         DEBUGMSG(ZONE_ERROR,(L"UfnPdd_Init() "
; 4184 :                 L"Vbus Charge Event not defined ('%s' not set)", 
; 4185 :                 REG_VBUS_CHARGE_EVENT_NAME));
; 4186 :     }
; 4187 :     
; 4188 :     pPdd->pUSBContext = pOTG;
; 4189 :     pPdd->bDMAForRX = FALSE;
; 4190 :     pPdd->bRXIsUsingUsbDMA = FALSE;
; 4191 :     pPdd->bTXIsUsingUsbDMA = FALSE;
; 4192 : 
; 4193 :     // Set PDD interface
; 4194 :     pPddIfc->dwVersion = UFN_PDD_INTERFACE_VERSION;
; 4195 : #if 0  // WM7 specific
; 4196 :     pPddIfc->dwCapabilities = UFN_PDD_CAPS_SUPPORTS_FULL_SPEED | UFN_PDD_CAPS_SUPPORTS_HIGH_SPEED
; 4197 :                          | UFN_PDD_CAPS_SUPPORTS_MULTIPLE_CONFIGURATIONS
; 4198 :                          | UFN_PDD_CAPS_SUPPORTS_ALTERNATE_INTERFACES
; 4199 :                          | UFN_PDD_CAPS_REUSABLE_ENDPOINTS;
; 4200 : #else
; 4201 :     pPddIfc->dwCapabilities = UFN_PDD_CAPS_SUPPORTS_FULL_SPEED | UFN_PDD_CAPS_SUPPORTS_HIGH_SPEED;
; 4202 : 
; 4203 : #endif
; 4204 :     pPddIfc->dwEndpointCount = USBD_EP_COUNT;
; 4205 :     // need to uncoment
; 4206 :     pPddIfc->pvPddContext = pPdd;
; 4207 :     pPddIfc->pfnDeinit = UfnPdd_Deinit;
; 4208 :     pPddIfc->pfnIsConfigurationSupportable = UfnPdd_IsConfigurationSupportable;
; 4209 :     pPddIfc->pfnIsEndpointSupportable = UfnPdd_IsEndpointSupportable;
; 4210 :     pPddIfc->pfnInitEndpoint = UfnPdd_InitEndpoint;
; 4211 :     pPddIfc->pfnRegisterDevice = UfnPdd_RegisterDevice;
; 4212 :     pPddIfc->pfnDeregisterDevice = UfnPdd_DeregisterDevice;
; 4213 :     pPddIfc->pfnStart = UfnPdd_Start;
; 4214 :     pPddIfc->pfnStop = UfnPdd_Stop;
; 4215 :     pPddIfc->pfnIssueTransfer = UfnPdd_IssueTransfer;
; 4216 :     pPddIfc->pfnAbortTransfer = UfnPdd_AbortTransfer;
; 4217 :     pPddIfc->pfnDeinitEndpoint = UfnPdd_DeinitEndpoint;
; 4218 :     pPddIfc->pfnStallEndpoint = UfnPdd_StallEndpoint;
; 4219 :     pPddIfc->pfnClearEndpointStall = UfnPdd_ClearEndpointStall;
; 4220 :     pPddIfc->pfnSendControlStatusHandshake = UfnPdd_SendControlStatusHandshake;
; 4221 :     pPddIfc->pfnSetAddress = UfnPdd_SetAddress;
; 4222 :     pPddIfc->pfnIsEndpointHalted = UfnPdd_IsEndpointHalted;
; 4223 :     pPddIfc->pfnInitiateRemoteWakeup = UfnPdd_InitiateRemoteWakeup;
; 4224 :     pPddIfc->pfnPowerDown = UfnPdd_PowerDown;
; 4225 :     pPddIfc->pfnPowerUp = UfnPdd_PowerUp;
; 4226 :     pPddIfc->pfnIOControl = UfnPdd_IOControl;

  002a8	e59d2010	 ldr         r2, [sp, #0x10]
  002ac	05853428	 streq       r3, [r5, #0x428]
  002b0	e59d3008	 ldr         r3, [sp, #8]
  002b4	e3a01806	 mov         r1, #6, 16
  002b8	e59f0158	 ldr         r0, [pc, #0x158]
  002bc	e5823020	 str         r3, [r2, #0x20]
  002c0	e3a03000	 mov         r3, #0
  002c4	e5823430	 str         r3, [r2, #0x430]
  002c8	e5823438	 str         r3, [r2, #0x438]
  002cc	e5823434	 str         r3, [r2, #0x434]
  002d0	e59d3014	 ldr         r3, [sp, #0x14]
  002d4	e59fe138	 ldr         lr, [pc, #0x138]
  002d8	e59f4130	 ldr         r4, [pc, #0x130]
  002dc	e5831000	 str         r1, [r3]
  002e0	e583200c	 str         r2, [r3, #0xC]
  002e4	e59f2120	 ldr         r2, [pc, #0x120]
  002e8	e3a01003	 mov         r1, #3
  002ec	e5831004	 str         r1, [r3, #4]
  002f0	e3a01010	 mov         r1, #0x10
  002f4	e5832010	 str         r2, [r3, #0x10]
  002f8	e5831008	 str         r1, [r3, #8]
  002fc	e1a02003	 mov         r2, r3
  00300	e59f3100	 ldr         r3, [pc, #0x100]
  00304	e59f50f8	 ldr         r5, [pc, #0xF8]
  00308	e59f60f0	 ldr         r6, [pc, #0xF0]
  0030c	e5823040	 str         r3, [r2, #0x40]
  00310	e59f30e4	 ldr         r3, [pc, #0xE4]
  00314	e59f70dc	 ldr         r7, [pc, #0xDC]
  00318	e59f80d4	 ldr         r8, [pc, #0xD4]
  0031c	e5823044	 str         r3, [r2, #0x44]
  00320	e59f30c8	 ldr         r3, [pc, #0xC8]
  00324	e59f90c0	 ldr         r9, [pc, #0xC0]
  00328	e59fa0b8	 ldr         r10, [pc, #0xB8]
  0032c	e5823048	 str         r3, [r2, #0x48]
  00330	e59f30ac	 ldr         r3, [pc, #0xAC]
  00334	e59fb0a4	 ldr         r11, [pc, #0xA4]
  00338	e59f109c	 ldr         r1, [pc, #0x9C]
  0033c	e582304c	 str         r3, [r2, #0x4C]
  00340	e59f3090	 ldr         r3, [pc, #0x90]
  00344	e5821014	 str         r1, [r2, #0x14]
  00348	e282c018	 add         r12, r2, #0x18
  0034c	e88c4001	 stmia       r12, {r0, lr}

; 4227 :     
; 4228 :     // Save MDD context & notify function
; 4229 :     pPdd->pMddContext = pMddContext;
; 4230 :     pPdd->pfnNotify = pMddIfc->pfnNotify;
; 4231 :     
; 4232 :     // pOTG->counter++;
; 4233 :     // Should set to pPdd object
; 4234 :     pOTG->pContext[DEVICE_CONTEXT] = pPdd;
; 4235 :     // DEBUGMSG(1, (TEXT("Counter in device module = %d\r\n"), pOTG->counter));
; 4236 :     SetEvent(pOTG->hReadyEvents[DEVICE_CONTEXT]);

  00350	e3a01003	 mov         r1, #3
  00354	e5823050	 str         r3, [r2, #0x50]
  00358	e59f3074	 ldr         r3, [pc, #0x74]
  0035c	e282c020	 add         r12, r2, #0x20
  00360	e88c0ff0	 stmia       r12, {r4 - r11}
  00364	e5823054	 str         r3, [r2, #0x54]
  00368	e59f3060	 ldr         r3, [pc, #0x60]
  0036c	e5823058	 str         r3, [r2, #0x58]
  00370	e59f3054	 ldr         r3, [pc, #0x54]
  00374	e582305c	 str         r3, [r2, #0x5C]
  00378	e59d2010	 ldr         r2, [sp, #0x10]
  0037c	e59d3024	 ldr         r3, [sp, #0x24]
  00380	e5823024	 str         r3, [r2, #0x24]
  00384	e59d3020	 ldr         r3, [sp, #0x20]
  00388	e5933004	 ldr         r3, [r3, #4]
  0038c	e5823028	 str         r3, [r2, #0x28]
  00390	e59d3008	 ldr         r3, [sp, #8]
  00394	e5832010	 str         r2, [r3, #0x10]
  00398	e59d3008	 ldr         r3, [sp, #8]
  0039c	e5930000	 ldr         r0, [r3]
  003a0	eb000000	 bl          EventModify

; 4237 :     // Done
; 4238 :     rc = ERROR_SUCCESS;

  003a4	e3a06000	 mov         r6, #0
  003a8	ea000001	 b           |$cleanUp$48503|
  003ac		 |$LN5@UfnPdd_Ini@3|

; 4154 :         DEBUGMSG(ZONE_INFO, (_T("UFNPDD_Init: RegQueryValueEx('%s', '%s') failed %u\r\n"),
; 4155 :             REG_USBFN_DRV_PATH, REG_VBUS_CHARGE_EVENT_NAME, dwStatus));
; 4156 :         RegCloseKey(hkDevice);

  003ac	e59d000c	 ldr         r0, [sp, #0xC]
  003b0	eb000000	 bl          RegCloseKey
  003b4		 |$cleanUp$48503|

; 4239 : 
; 4240 : cleanUp:
; 4241 :    
; 4242 :     return rc;

  003b4	e59d0234	 ldr         r0, [sp, #0x234]
  003b8	eb000000	 bl          __security_check_cookie
  003bc		 |$LN20@UfnPdd_Ini@3|

; 4243 : }

  003bc	e1a00006	 mov         r0, r6
  003c0	e28ddf8e	 add         sp, sp, #0x8E, 30
  003c4	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  003c8	e12fff1e	 bx          lr
  003cc		 |$LN30@UfnPdd_Ini@3|
  003cc		 |$LN31@UfnPdd_Ini@3|
  003cc	00000000	 DCD         |UfnPdd_IOControl|
  003d0		 |$LN32@UfnPdd_Ini@3|
  003d0	00000000	 DCD         |UfnPdd_PowerUp|
  003d4		 |$LN33@UfnPdd_Ini@3|
  003d4	00000000	 DCD         |UfnPdd_PowerDown|
  003d8		 |$LN34@UfnPdd_Ini@3|
  003d8	00000000	 DCD         |UfnPdd_InitiateRemoteWakeup|
  003dc		 |$LN35@UfnPdd_Ini@3|
  003dc	00000000	 DCD         |UfnPdd_IsConfigurationSupportable|
  003e0		 |$LN36@UfnPdd_Ini@3|
  003e0	00000000	 DCD         |UfnPdd_StallEndpoint|
  003e4		 |$LN37@UfnPdd_Ini@3|
  003e4	00000000	 DCD         |UfnPdd_IsEndpointHalted|
  003e8		 |$LN38@UfnPdd_Ini@3|
  003e8	00000000	 DCD         |UfnPdd_DeinitEndpoint|
  003ec		 |$LN39@UfnPdd_Ini@3|
  003ec	00000000	 DCD         |UfnPdd_AbortTransfer|
  003f0		 |$LN40@UfnPdd_Ini@3|
  003f0	00000000	 DCD         |UfnPdd_SetAddress|
  003f4		 |$LN41@UfnPdd_Ini@3|
  003f4	00000000	 DCD         |UfnPdd_IssueTransfer|
  003f8		 |$LN42@UfnPdd_Ini@3|
  003f8	00000000	 DCD         |UfnPdd_Stop|
  003fc		 |$LN43@UfnPdd_Ini@3|
  003fc	00000000	 DCD         |UfnPdd_SendControlStatusHandshake|
  00400		 |$LN44@UfnPdd_Ini@3|
  00400	00000000	 DCD         |UfnPdd_Start|
  00404		 |$LN45@UfnPdd_Ini@3|
  00404	00000000	 DCD         |UfnPdd_DeregisterDevice|
  00408		 |$LN46@UfnPdd_Ini@3|
  00408	00000000	 DCD         |UfnPdd_ClearEndpointStall|
  0040c		 |$LN47@UfnPdd_Ini@3|
  0040c	00000000	 DCD         |UfnPdd_Deinit|
  00410		 |$LN48@UfnPdd_Ini@3|
  00410	00000000	 DCD         |UfnPdd_RegisterDevice|
  00414		 |$LN49@UfnPdd_Ini@3|
  00414	00000000	 DCD         |UfnPdd_InitEndpoint|
  00418		 |$LN50@UfnPdd_Ini@3|
  00418	00000000	 DCD         |UfnPdd_IsEndpointSupportable|
  0041c		 |$LN51@UfnPdd_Ini@3|
  0041c	00000000	 DCD         |??_C@_1CC@CKFJFILD@?$AAU?$AAS?$AAB?$AAC?$AAh?$AAa?$AAr?$AAg?$AAe?$AAr?$AAN?$AAo?$AAt?$AAi?$AAf?$AAy?$AA?$AA@|
  00420		 |$LN52@UfnPdd_Ini@3|
  00420	00000000	 DCD         |??_C@_11LOCGONAA@?$AA?$AA@|
  00424		 |$LN53@UfnPdd_Ini@3|
  00424	00000000	 DCD         |??_C@_1DM@GBENJPGN@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAB?$AAu?$AAi?$AAl?$AAt?$AAI?$AAn?$AA?2?$AAM?$AAU?$AAS?$AAB?$AAO?$AAT?$AAG?$AA?2?$AAU?$AAS?$AAB?$AAF?$AAN?$AA?$AA@|
  00428		 |$LN54@UfnPdd_Ini@3|
  00428	00000000	 DCD         |??_C@_1BI@KEGLAEOK@?$AAO?$AAT?$AAG?$AAU?$AAS?$AAB?$AAC?$AAl?$AAo?$AAc?$AAk?$AA?$AA@|
  0042c		 |$LN55@UfnPdd_Ini@3|
  0042c	00000000	 DCD         |gc_MUsbFuncs|
  00430		 |$LN56@UfnPdd_Ini@3|
  00430	00000000	 DCD         |??_C@_1BE@JNKHMKGH@?$AAO?$AAT?$AAG?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AA?$AA@|
  00434		 |$LN57@UfnPdd_Ini@3|
  00434	00000000	 DCD         |??_C@_1CC@PKGPLCAL@?$AAo?$AAm?$AAa?$AAp?$AA_?$AAm?$AAu?$AAs?$AAb?$AAo?$AAt?$AAg?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@|
  00438		 |$LN58@UfnPdd_Ini@3|
  00438	00000000	 DCD         |??_C@_1JG@KGFPJKPC@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAv?$AAi?$AAr?$AAt?$AAu@|
  0043c		 |$LN59@UfnPdd_Ini@3|
  0043c	00000000	 DCD         |??_C@_1JO@FKEMNFJK@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc@|
  00440		 |$LN60@UfnPdd_Ini@3|
  00440	00000000	 DCD         |s_deviceRegParams|
  00444		 |$LN61@UfnPdd_Ini@3|
  00444	00000000	 DCD         |__security_cookie|
  00448		 |$M49812|

			 ENDP  ; |UfnPdd_Init|

	EXPORT	|UfnPdd_DllEntry|

  00000			 AREA	 |.pdata|, PDATA
|$T49856| DCD	|$LN5@UfnPdd_Dll|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_DllEntry| PROC

; 4269 : {

  00000		 |$LN5@UfnPdd_Dll|
  00000		 |$M49853|

; 4270 : 	UNREFERENCED_PARAMETER(hDllHandle);
; 4271 : 	UNREFERENCED_PARAMETER(reason);
; 4272 : 	UNREFERENCED_PARAMETER(pReserved);
; 4273 : 
; 4274 :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 4275 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M49854|

			 ENDP  ; |UfnPdd_DllEntry|

	END
