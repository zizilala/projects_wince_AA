; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\OMAP3530\MUSB\MUSBHCD\USB2COM\cdevice.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1DK@JPBDFEOB@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAI?$AAN?$AAV?$AAA?$AAL?$AAI?$AAD?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DE@IMCKALLA@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAD?$AAO?$AAN?$AAE?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DI@CEGNOBAM@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAF?$AAA?$AAI?$AAL?$AAE?$AAD?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HO@PGHDEMEK@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAI?$AAG?$AAN?$AAA?$AAL?$AA_?$AAN?$AAE?$AAW?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1II@FBBOBKGN@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAI?$AAN?$AAS?$AAE?$AAR?$AAT?$AA_?$AAN?$AAE?$AAW?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FC@LCLFDJDO@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA_?$AAN?$AAE?$AAW?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EI@COKEBMOE@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA_?$AAN?$AAE?$AAW?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GG@HPGGGHKI@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HG@KPBCOGEF@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FG@CFFAAPDL@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GA@NDHJOKMM@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAD?$AAE?$AAT?$AAE?$AAR?$AAM?$AAI?$AAN?$AAE?$AA_?$AAC@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GM@JADKDKDC@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HM@NPLCKJLH@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HE@MEMGEMJJ@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAE?$AAT?$AAU?$AAP?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GM@BCHKIAPP@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HM@FNPCBDHK@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EI@BBOOKHNN@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAL?$AAE?$AAA?$AAV?$AAE?$AA_?$AAA?$AAD?$AAD?$AAR?$AAE@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FI@LGLHPFAK@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HG@BLNLBKIO@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FG@NMCKCJLL@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAR?$AAE?$AAS?$AAE?$AAT?$AA_?$AAA?$AAN?$AAD?$AA_?$AAE@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EI@KNOIBOPH@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAU?$AAS?$AAI?$AAN?$AAG?$AA_?$AAA?$AAD?$AAD?$AAR?$AAE@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FI@COMJHLEF@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAO?$AAP?$AAE?$AAN?$AAI?$AAN?$AAG?$AA_?$AAE?$AAN?$AAD@| [ DATA ] ; `string'

  00000			 AREA	 |.data|, DATA
|cszCfgStateStrings| DCD |??_C@_1FI@COMJHLEF@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAO?$AAP?$AAE?$AAN?$AAI?$AAN?$AAG?$AA_?$AAE?$AAN?$AAD@|
	DCD	|??_C@_1EI@KNOIBOPH@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAU?$AAS?$AAI?$AAN?$AAG?$AA_?$AAA?$AAD?$AAD?$AAR?$AAE@|
	DCD	|??_C@_1FG@NMCKCJLL@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAR?$AAE?$AAS?$AAE?$AAT?$AA_?$AAA?$AAN?$AAD?$AA_?$AAE@|
	DCD	|??_C@_1HG@BLNLBKIO@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@|
	DCD	|??_C@_1FI@LGLHPFAK@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@|
	DCD	|??_C@_1EI@BBOOKHNN@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAL?$AAE?$AAA?$AAV?$AAE?$AA_?$AAA?$AAD?$AAD?$AAR?$AAE@|
	DCD	|??_C@_1HM@FNPCBDHK@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@|
	DCD	|??_C@_1GM@BCHKIAPP@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@|
	DCD	|??_C@_1HE@MEMGEMJJ@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAE?$AAT?$AAU?$AAP?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI@|
	DCD	|??_C@_1HM@NPLCKJLH@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@|
	DCD	|??_C@_1GM@JADKDKDC@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@|
	DCD	|??_C@_1GA@NDHJOKMM@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAD?$AAE?$AAT?$AAE?$AAR?$AAM?$AAI?$AAN?$AAE?$AA_?$AAC@|
	DCD	|??_C@_1FG@CFFAAPDL@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@|
	DCD	|??_C@_1HG@KPBCOGEF@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@|
	DCD	|??_C@_1GG@HPGGGHKI@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@|
	DCD	|??_C@_1EI@COKEBMOE@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA_?$AAN?$AAE?$AAW?$AA_@|
	DCD	|??_C@_1FC@LCLFDJDO@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA_?$AAN?$AAE?$AAW?$AA_@|
	DCD	|??_C@_1II@FBBOBKGN@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAI?$AAN?$AAS?$AAE?$AAR?$AAT?$AA_?$AAN?$AAE?$AAW?$AA_@|
	DCD	|??_C@_1HO@PGHDEMEK@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAI?$AAG?$AAN?$AAA?$AAL?$AA_?$AAN?$AAE?$AAW?$AA_@|
	DCD	|??_C@_1DI@CEGNOBAM@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAF?$AAA?$AAI?$AAL?$AAE?$AAD?$AA?$AA@|
	DCD	|??_C@_1DE@IMCKALLA@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAD?$AAO?$AAN?$AAE?$AA?$AA@|
	DCD	|??_C@_1DK@JPBDFEOB@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAI?$AAN?$AAV?$AAA?$AAL?$AAI?$AAD?$AA?$AA@|

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DK@JPBDFEOB@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAI?$AAN?$AAV?$AAA?$AAL?$AAI?$AAD?$AA?$AA@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "I", 0x0, "N", 0x0, "V", 0x0, "A"
	DCB	0x0, "L", 0x0, "I", 0x0, "D", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DE@IMCKALLA@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAD?$AAO?$AAN?$AAE?$AA?$AA@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "D", 0x0, "O", 0x0, "N", 0x0, "E"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DI@CEGNOBAM@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAF?$AAA?$AAI?$AAL?$AAE?$AAD?$AA?$AA@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "F", 0x0, "A", 0x0, "I", 0x0, "L"
	DCB	0x0, "E", 0x0, "D", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HO@PGHDEMEK@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAI?$AAG?$AAN?$AAA?$AAL?$AA_?$AAN?$AAE?$AAW?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "S", 0x0, "I", 0x0, "G", 0x0, "N"
	DCB	0x0, "A", 0x0, "L", 0x0, "_", 0x0, "N", 0x0, "E", 0x0, "W"
	DCB	0x0, "_", 0x0, "D", 0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C"
	DCB	0x0, "E", 0x0, "_", 0x0, "E", 0x0, "N", 0x0, "T", 0x0, "E"
	DCB	0x0, "R", 0x0, "_", 0x0, "O", 0x0, "P", 0x0, "E", 0x0, "R"
	DCB	0x0, "A", 0x0, "T", 0x0, "I", 0x0, "O", 0x0, "N", 0x0, "A"
	DCB	0x0, "L", 0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T"
	DCB	0x0, "E", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1II@FBBOBKGN@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAI?$AAN?$AAS?$AAE?$AAR?$AAT?$AA_?$AAN?$AAE?$AAW?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "I", 0x0, "N", 0x0, "S", 0x0, "E"
	DCB	0x0, "R", 0x0, "T", 0x0, "_", 0x0, "N", 0x0, "E", 0x0, "W"
	DCB	0x0, "_", 0x0, "D", 0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C"
	DCB	0x0, "E", 0x0, "_", 0x0, "I", 0x0, "N", 0x0, "T", 0x0, "O"
	DCB	0x0, "_", 0x0, "U", 0x0, "P", 0x0, "S", 0x0, "T", 0x0, "R"
	DCB	0x0, "E", 0x0, "A", 0x0, "M", 0x0, "_", 0x0, "H", 0x0, "U"
	DCB	0x0, "B", 0x0, "_", 0x0, "P", 0x0, "O", 0x0, "R", 0x0, "T"
	DCB	0x0, "_", 0x0, "A", 0x0, "R", 0x0, "R", 0x0, "A", 0x0, "Y"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FC@LCLFDJDO@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA_?$AAN?$AAE?$AAW?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "C", 0x0, "R", 0x0, "E", 0x0, "A"
	DCB	0x0, "T", 0x0, "E", 0x0, "_", 0x0, "N", 0x0, "E", 0x0, "W"
	DCB	0x0, "_", 0x0, "F", 0x0, "U", 0x0, "N", 0x0, "C", 0x0, "T"
	DCB	0x0, "I", 0x0, "O", 0x0, "N", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EI@COKEBMOE@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA_?$AAN?$AAE?$AAW?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "C", 0x0, "R", 0x0, "E", 0x0, "A"
	DCB	0x0, "T", 0x0, "E", 0x0, "_", 0x0, "N", 0x0, "E", 0x0, "W"
	DCB	0x0, "_", 0x0, "H", 0x0, "U", 0x0, "B", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GG@HPGGGHKI@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "S", 0x0, "C", 0x0, "H", 0x0, "E"
	DCB	0x0, "D", 0x0, "U", 0x0, "L", 0x0, "I", 0x0, "N", 0x0, "G"
	DCB	0x0, "_", 0x0, "G", 0x0, "E", 0x0, "T", 0x0, "_", 0x0, "H"
	DCB	0x0, "U", 0x0, "B", 0x0, "_", 0x0, "D", 0x0, "E", 0x0, "S"
	DCB	0x0, "C", 0x0, "R", 0x0, "I", 0x0, "P", 0x0, "T", 0x0, "O"
	DCB	0x0, "R", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HG@KPBCOGEF@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "S", 0x0, "C", 0x0, "H", 0x0, "E"
	DCB	0x0, "D", 0x0, "U", 0x0, "L", 0x0, "I", 0x0, "N", 0x0, "G"
	DCB	0x0, "_", 0x0, "G", 0x0, "E", 0x0, "T", 0x0, "_", 0x0, "I"
	DCB	0x0, "N", 0x0, "I", 0x0, "T", 0x0, "I", 0x0, "A", 0x0, "L"
	DCB	0x0, "_", 0x0, "H", 0x0, "U", 0x0, "B", 0x0, "_", 0x0, "D"
	DCB	0x0, "E", 0x0, "S", 0x0, "C", 0x0, "R", 0x0, "I", 0x0, "P"
	DCB	0x0, "T", 0x0, "O", 0x0, "R", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FG@CFFAAPDL@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "S", 0x0, "C", 0x0, "H", 0x0, "E"
	DCB	0x0, "D", 0x0, "U", 0x0, "L", 0x0, "I", 0x0, "N", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "E", 0x0, "T", 0x0, "_", 0x0, "C"
	DCB	0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GA@NDHJOKMM@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAD?$AAE?$AAT?$AAE?$AAR?$AAM?$AAI?$AAN?$AAE?$AA_?$AAC@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "D", 0x0, "E", 0x0, "T", 0x0, "E"
	DCB	0x0, "R", 0x0, "M", 0x0, "I", 0x0, "N", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "T", 0x0, "O", 0x0, "_", 0x0, "C", 0x0, "H"
	DCB	0x0, "O", 0x0, "O", 0x0, "S", 0x0, "E", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GM@JADKDKDC@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "S", 0x0, "C", 0x0, "H", 0x0, "E"
	DCB	0x0, "D", 0x0, "U", 0x0, "L", 0x0, "I", 0x0, "N", 0x0, "G"
	DCB	0x0, "_", 0x0, "G", 0x0, "E", 0x0, "T", 0x0, "_", 0x0, "C"
	DCB	0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G", 0x0, "_"
	DCB	0x0, "D", 0x0, "E", 0x0, "S", 0x0, "C", 0x0, "R", 0x0, "I"
	DCB	0x0, "P", 0x0, "T", 0x0, "O", 0x0, "R", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HM@NPLCKJLH@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "S", 0x0, "C", 0x0, "H", 0x0, "E"
	DCB	0x0, "D", 0x0, "U", 0x0, "L", 0x0, "I", 0x0, "N", 0x0, "G"
	DCB	0x0, "_", 0x0, "G", 0x0, "E", 0x0, "T", 0x0, "_", 0x0, "I"
	DCB	0x0, "N", 0x0, "I", 0x0, "T", 0x0, "I", 0x0, "A", 0x0, "L"
	DCB	0x0, "_", 0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I"
	DCB	0x0, "G", 0x0, "_", 0x0, "D", 0x0, "E", 0x0, "S", 0x0, "C"
	DCB	0x0, "R", 0x0, "I", 0x0, "P", 0x0, "T", 0x0, "O", 0x0, "R"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HE@MEMGEMJJ@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAE?$AAT?$AAU?$AAP?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "S", 0x0, "E", 0x0, "T", 0x0, "U"
	DCB	0x0, "P", 0x0, "_", 0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F"
	DCB	0x0, "I", 0x0, "G", 0x0, "U", 0x0, "R", 0x0, "A", 0x0, "T"
	DCB	0x0, "I", 0x0, "O", 0x0, "N", 0x0, "_", 0x0, "D", 0x0, "E"
	DCB	0x0, "S", 0x0, "C", 0x0, "R", 0x0, "I", 0x0, "P", 0x0, "T"
	DCB	0x0, "O", 0x0, "R", 0x0, "_", 0x0, "A", 0x0, "R", 0x0, "R"
	DCB	0x0, "A", 0x0, "Y", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GM@BCHKIAPP@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "S", 0x0, "C", 0x0, "H", 0x0, "E"
	DCB	0x0, "D", 0x0, "U", 0x0, "L", 0x0, "I", 0x0, "N", 0x0, "G"
	DCB	0x0, "_", 0x0, "G", 0x0, "E", 0x0, "T", 0x0, "_", 0x0, "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "D", 0x0, "E", 0x0, "S", 0x0, "C", 0x0, "R", 0x0, "I"
	DCB	0x0, "P", 0x0, "T", 0x0, "O", 0x0, "R", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HM@FNPCBDHK@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "S", 0x0, "C", 0x0, "H", 0x0, "E"
	DCB	0x0, "D", 0x0, "U", 0x0, "L", 0x0, "I", 0x0, "N", 0x0, "G"
	DCB	0x0, "_", 0x0, "G", 0x0, "E", 0x0, "T", 0x0, "_", 0x0, "I"
	DCB	0x0, "N", 0x0, "I", 0x0, "T", 0x0, "I", 0x0, "A", 0x0, "L"
	DCB	0x0, "_", 0x0, "D", 0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C"
	DCB	0x0, "E", 0x0, "_", 0x0, "D", 0x0, "E", 0x0, "S", 0x0, "C"
	DCB	0x0, "R", 0x0, "I", 0x0, "P", 0x0, "T", 0x0, "O", 0x0, "R"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EI@BBOOKHNN@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAL?$AAE?$AAA?$AAV?$AAE?$AA_?$AAA?$AAD?$AAD?$AAR?$AAE@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "L", 0x0, "E", 0x0, "A", 0x0, "V"
	DCB	0x0, "E", 0x0, "_", 0x0, "A", 0x0, "D", 0x0, "D", 0x0, "R"
	DCB	0x0, "E", 0x0, "S", 0x0, "S", 0x0, "0", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FI@LGLHPFAK@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "S", 0x0, "C", 0x0, "H", 0x0, "E"
	DCB	0x0, "D", 0x0, "U", 0x0, "L", 0x0, "I", 0x0, "N", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "E", 0x0, "T", 0x0, "_", 0x0, "A"
	DCB	0x0, "D", 0x0, "D", 0x0, "R", 0x0, "E", 0x0, "S", 0x0, "S"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HG@BLNLBKIO@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "S", 0x0, "C", 0x0, "H", 0x0, "E"
	DCB	0x0, "D", 0x0, "U", 0x0, "L", 0x0, "I", 0x0, "N", 0x0, "G"
	DCB	0x0, "_", 0x0, "G", 0x0, "E", 0x0, "T", 0x0, "_", 0x0, "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "D", 0x0, "E", 0x0, "S", 0x0, "C", 0x0, "R", 0x0, "I"
	DCB	0x0, "P", 0x0, "T", 0x0, "O", 0x0, "R", 0x0, "_", 0x0, "T"
	DCB	0x0, "E", 0x0, "S", 0x0, "T", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FG@NMCKCJLL@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAR?$AAE?$AAS?$AAE?$AAT?$AA_?$AAA?$AAN?$AAD?$AA_?$AAE@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "R", 0x0, "E", 0x0, "S", 0x0, "E"
	DCB	0x0, "T", 0x0, "_", 0x0, "A", 0x0, "N", 0x0, "D", 0x0, "_"
	DCB	0x0, "E", 0x0, "N", 0x0, "A", 0x0, "B", 0x0, "L", 0x0, "E"
	DCB	0x0, "_", 0x0, "P", 0x0, "O", 0x0, "R", 0x0, "T", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EI@KNOIBOPH@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAU?$AAS?$AAI?$AAN?$AAG?$AA_?$AAA?$AAD?$AAD?$AAR?$AAE@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "U", 0x0, "S", 0x0, "I", 0x0, "N"
	DCB	0x0, "G", 0x0, "_", 0x0, "A", 0x0, "D", 0x0, "D", 0x0, "R"
	DCB	0x0, "E", 0x0, "S", 0x0, "S", 0x0, "0", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FI@COMJHLEF@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAO?$AAP?$AAE?$AAN?$AAI?$AAN?$AAG?$AA_?$AAE?$AAN?$AAD@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "O", 0x0, "P", 0x0, "E", 0x0, "N"
	DCB	0x0, "I", 0x0, "N", 0x0, "G", 0x0, "_", 0x0, "E", 0x0, "N"
	DCB	0x0, "D", 0x0, "P", 0x0, "O", 0x0, "I", 0x0, "N", 0x0, "T"
	DCB	0x0, "0", 0x0, "_", 0x0, "P", 0x0, "I", 0x0, "P", 0x0, "E"
	DCB	0x0, 0x0, 0x0				; `string'
	EXPORT	|ResetEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T37639| DCD	|$LN5@ResetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ResetEvent| PROC

; 223  : _inline BOOL ResetEvent(HANDLE h) {

  00000		 |$LN5@ResetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37636|

; 224  : 	return EventModify(h,EVENT_RESET);

  00004	e3a01002	 mov         r1, #2
  00008	eb000000	 bl          EventModify

; 225  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M37637|

			 ENDP  ; |ResetEvent|

	EXPORT	|SetEvent|

  00000			 AREA	 |.pdata|, PDATA
|$T37649| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37646|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M37647|

			 ENDP  ; |SetEvent|

	EXPORT	|GetCurrentThread|

  00000			 AREA	 |.pdata|, PDATA
|$T37658| DCD	|$LN5@GetCurrent|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentThread| PROC

; 351  : _inline HANDLE GetCurrentThread(void) {

  00000		 |$LN5@GetCurrent|
  00000		 |$M37655|

; 352  : 	return ((HANDLE)(SH_CURTHREAD+SYS_HANDLE_BASE));

  00000	e3a00041	 mov         r0, #0x41

; 353  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M37656|

			 ENDP  ; |GetCurrentThread|

	EXPORT	|?UnlockCountdown@Countdown@@QAAXXZ|	; Countdown::UnlockCountdown
	IMPORT	|LeaveCriticalSection|
	IMPORT	|EnterCriticalSection|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T37666| DCD	|$LN5@UnlockCoun|
	DCD	0x40000901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UnlockCountdown@Countdown@@QAAXXZ| PROC ; Countdown::UnlockCountdown

; 60   :     void UnlockCountdown () {

  00000		 |$LN5@UnlockCoun|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37663|
  00004	e1a04000	 mov         r4, r0

; 61   :         EnterCriticalSection(&cs);

  00008	eb000000	 bl          EnterCriticalSection

; 62   :         lock = FALSE;

  0000c	e3a03000	 mov         r3, #0

; 63   :         LeaveCriticalSection(&cs);

  00010	e1a00004	 mov         r0, r4
  00014	e5843018	 str         r3, [r4, #0x18]
  00018	eb000000	 bl          LeaveCriticalSection

; 64   :     }

  0001c	e8bd4010	 ldmia       sp!, {r4, lr}
  00020	e12fff1e	 bx          lr
  00024		 |$M37664|

			 ENDP  ; |?UnlockCountdown@Countdown@@QAAXXZ|, Countdown::UnlockCountdown

	EXPORT	|?Addr0LockEntry@CDeviceGlobal@@QAA?AW4e_CritSec_Status@@K@Z| ; CDeviceGlobal::Addr0LockEntry
	IMPORT	|?EnterCritSec_Ex@CritSec_Ex@@QAA?AW4e_CritSec_Status@@K@Z| ; CritSec_Ex::EnterCritSec_Ex
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T37677| DCD	|$LN5@Addr0LockE|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Addr0LockEntry@CDeviceGlobal@@QAA?AW4e_CritSec_Status@@K@Z| PROC ; CDeviceGlobal::Addr0LockEntry

; 58   :     CritSec_Status Addr0LockEntry(ULONG ulTimeout) { return m_csAddress0Lock.EnterCritSec_Ex(ulTimeout); };

  00000		 |$LN5@Addr0LockE|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37674|
  00004	e280002c	 add         r0, r0, #0x2C
  00008	eb000000	 bl          |?EnterCritSec_Ex@CritSec_Ex@@QAA?AW4e_CritSec_Status@@K@Z|
  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M37675|

			 ENDP  ; |?Addr0LockEntry@CDeviceGlobal@@QAA?AW4e_CritSec_Status@@K@Z|, CDeviceGlobal::Addr0LockEntry

	EXPORT	|?Addr0LockPrepareDelete@CDeviceGlobal@@QAAXXZ| ; CDeviceGlobal::Addr0LockPrepareDelete
	IMPORT	|?PrepareDeleteCritSec_Ex@CritSec_Ex@@QAAXXZ| ; CritSec_Ex::PrepareDeleteCritSec_Ex

  00000			 AREA	 |.pdata|, PDATA
|$T37685| DCD	|$LN5@Addr0LockP|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Addr0LockPrepareDelete@CDeviceGlobal@@QAAXXZ| PROC ; CDeviceGlobal::Addr0LockPrepareDelete

; 59   :     void Addr0LockPrepareDelete() { m_csAddress0Lock.PrepareDeleteCritSec_Ex ();};

  00000		 |$LN5@Addr0LockP|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37682|
  00004	e280002c	 add         r0, r0, #0x2C
  00008	eb000000	 bl          |?PrepareDeleteCritSec_Ex@CritSec_Ex@@QAAXXZ|
  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M37683|

			 ENDP  ; |?Addr0LockPrepareDelete@CDeviceGlobal@@QAAXXZ|, CDeviceGlobal::Addr0LockPrepareDelete

	EXPORT	|?Addr0LockLeave@CDeviceGlobal@@QAAXXZ|	; CDeviceGlobal::Addr0LockLeave
	IMPORT	|?LeaveCritSec_Ex@CritSec_Ex@@QAAXXZ|	; CritSec_Ex::LeaveCritSec_Ex

  00000			 AREA	 |.pdata|, PDATA
|$T37693| DCD	|$LN5@Addr0LockL|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Addr0LockLeave@CDeviceGlobal@@QAAXXZ| PROC ; CDeviceGlobal::Addr0LockLeave

; 60   :     void Addr0LockLeave() { m_csAddress0Lock.LeaveCritSec_Ex ();};

  00000		 |$LN5@Addr0LockL|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37690|
  00004	e280002c	 add         r0, r0, #0x2C
  00008	eb000000	 bl          |?LeaveCritSec_Ex@CritSec_Ex@@QAAXXZ|
  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M37691|

			 ENDP  ; |?Addr0LockLeave@CDeviceGlobal@@QAAXXZ|, CDeviceGlobal::Addr0LockLeave

	EXPORT	|?ObjCountdownInc@CDeviceGlobal@@QAAHXZ| ; CDeviceGlobal::ObjCountdownInc
	IMPORT	|?IncrCountdown@Countdown@@QAAHXZ|	; Countdown::IncrCountdown

  00000			 AREA	 |.pdata|, PDATA
|$T37703| DCD	|$LN5@ObjCountdo|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ObjCountdownInc@CDeviceGlobal@@QAAHXZ| PROC ; CDeviceGlobal::ObjCountdownInc

; 62   :     BOOL ObjCountdownInc () {return  m_objCountdown.IncrCountdown (); };

  00000		 |$LN5@ObjCountdo|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37700|
  00004	e2800054	 add         r0, r0, #0x54
  00008	eb000000	 bl          |?IncrCountdown@Countdown@@QAAHXZ|
  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M37701|

			 ENDP  ; |?ObjCountdownInc@CDeviceGlobal@@QAAHXZ|, CDeviceGlobal::ObjCountdownInc

	EXPORT	|?ObjCountdownDec@CDeviceGlobal@@QAAXXZ| ; CDeviceGlobal::ObjCountdownDec
	IMPORT	|?DecrCountdown@Countdown@@QAAXXZ|	; Countdown::DecrCountdown

  00000			 AREA	 |.pdata|, PDATA
|$T37711| DCD	|$LN5@ObjCountdo@2|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ObjCountdownDec@CDeviceGlobal@@QAAXXZ| PROC ; CDeviceGlobal::ObjCountdownDec

; 63   :     void ObjCountdownDec () { m_objCountdown.DecrCountdown ();};

  00000		 |$LN5@ObjCountdo@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37708|
  00004	e2800054	 add         r0, r0, #0x54
  00008	eb000000	 bl          |?DecrCountdown@Countdown@@QAAXXZ|
  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M37709|

			 ENDP  ; |?ObjCountdownDec@CDeviceGlobal@@QAAXXZ|, CDeviceGlobal::ObjCountdownDec

	EXPORT	|?GetpUSBDSelectConfigurationProc@CDeviceGlobal@@QAAP6AHPBU_USB_DEVICE@@PAE@ZXZ| ; CDeviceGlobal::GetpUSBDSelectConfigurationProc

  00000			 AREA	 |.pdata|, PDATA
|$T37721| DCD	|$LN5@GetpUSBDSe|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetpUSBDSelectConfigurationProc@CDeviceGlobal@@QAAP6AHPBU_USB_DEVICE@@PAE@ZXZ| PROC ; CDeviceGlobal::GetpUSBDSelectConfigurationProc

; 68   :     LPUSBD_SELECT_CONFIGURATION_PROC GetpUSBDSelectConfigurationProc() { return m_pUSBDSelectConfigurationProc; };

  00000		 |$LN5@GetpUSBDSe|
  00000		 |$M37718|
  00000	e5900078	 ldr         r0, [r0, #0x78]
  00004	e12fff1e	 bx          lr
  00008		 |$M37719|

			 ENDP  ; |?GetpUSBDSelectConfigurationProc@CDeviceGlobal@@QAAP6AHPBU_USB_DEVICE@@PAE@ZXZ|, CDeviceGlobal::GetpUSBDSelectConfigurationProc

	EXPORT	|?GetpUSBDSuspendedResumed@CDeviceGlobal@@QAAP6AHPAXH@ZXZ| ; CDeviceGlobal::GetpUSBDSuspendedResumed

  00000			 AREA	 |.pdata|, PDATA
|$T37731| DCD	|$LN5@GetpUSBDSu|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetpUSBDSuspendedResumed@CDeviceGlobal@@QAAP6AHPAXH@ZXZ| PROC ; CDeviceGlobal::GetpUSBDSuspendedResumed

; 69   :     LPUSBD_SUSPEND_RESUME_PROC GetpUSBDSuspendedResumed() { return m_pUSBDSuspendResumed; };

  00000		 |$LN5@GetpUSBDSu|
  00000		 |$M37728|
  00000	e5900084	 ldr         r0, [r0, #0x84]
  00004	e12fff1e	 bx          lr
  00008		 |$M37729|

			 ENDP  ; |?GetpUSBDSuspendedResumed@CDeviceGlobal@@QAAP6AHPAXH@ZXZ|, CDeviceGlobal::GetpUSBDSuspendedResumed

	EXPORT	|?GetpUSBDAttachProc@CDeviceGlobal@@QAAP6AHPAXIIPBU_USB_DEVICE@@PAPAX@ZXZ| ; CDeviceGlobal::GetpUSBDAttachProc

  00000			 AREA	 |.pdata|, PDATA
|$T37741| DCD	|$LN5@GetpUSBDAt|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetpUSBDAttachProc@CDeviceGlobal@@QAAP6AHPAXIIPBU_USB_DEVICE@@PAPAX@ZXZ| PROC ; CDeviceGlobal::GetpUSBDAttachProc

; 70   :     LPUSBD_ATTACH_PROC GetpUSBDAttachProc() { return m_pUSBDAttachProc; };

  00000		 |$LN5@GetpUSBDAt|
  00000		 |$M37738|
  00000	e590007c	 ldr         r0, [r0, #0x7C]
  00004	e12fff1e	 bx          lr
  00008		 |$M37739|

			 ENDP  ; |?GetpUSBDAttachProc@CDeviceGlobal@@QAAP6AHPAXIIPBU_USB_DEVICE@@PAPAX@ZXZ|, CDeviceGlobal::GetpUSBDAttachProc

	EXPORT	|?GetpUSBDDetachProc@CDeviceGlobal@@QAAP6AHPAX@ZXZ| ; CDeviceGlobal::GetpUSBDDetachProc

  00000			 AREA	 |.pdata|, PDATA
|$T37751| DCD	|$LN5@GetpUSBDDe|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetpUSBDDetachProc@CDeviceGlobal@@QAAP6AHPAX@ZXZ| PROC ; CDeviceGlobal::GetpUSBDDetachProc

; 71   :     LPUSBD_DETACH_PROC GetpUSBDDetachProc() { return m_pUSBDDetachProc; };

  00000		 |$LN5@GetpUSBDDe|
  00000		 |$M37748|
  00000	e5900080	 ldr         r0, [r0, #0x80]
  00004	e12fff1e	 bx          lr
  00008		 |$M37749|

			 ENDP  ; |?GetpUSBDDetachProc@CDeviceGlobal@@QAAP6AHPAX@ZXZ|, CDeviceGlobal::GetpUSBDDetachProc

	EXPORT	|?GetpHcdContext@CDeviceGlobal@@QAAPAXXZ| ; CDeviceGlobal::GetpHcdContext

  00000			 AREA	 |.pdata|, PDATA
|$T37761| DCD	|$LN5@GetpHcdCon|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetpHcdContext@CDeviceGlobal@@QAAPAXXZ| PROC ; CDeviceGlobal::GetpHcdContext

; 72   :     LPVOID             GetpHcdContext() { return m_pvHcdContext ;};

  00000		 |$LN5@GetpHcdCon|
  00000		 |$M37758|
  00000	e5900088	 ldr         r0, [r0, #0x88]
  00004	e12fff1e	 bx          lr
  00008		 |$M37759|

			 ENDP  ; |?GetpHcdContext@CDeviceGlobal@@QAAPAXXZ|, CDeviceGlobal::GetpHcdContext

	EXPORT	|?GetDeviceAddress@CDevice@@QAAEXZ|	; CDevice::GetDeviceAddress

  00000			 AREA	 |.pdata|, PDATA
|$T37771| DCD	|$LN5@GetDeviceA|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetDeviceAddress@CDevice@@QAAEXZ| PROC ; CDevice::GetDeviceAddress

; 250  :     UCHAR GetDeviceAddress() { return m_address; };

  00000		 |$LN5@GetDeviceA|
  00000		 |$M37768|
  00000	e5d00020	 ldrb        r0, [r0, #0x20]
  00004	e12fff1e	 bx          lr
  00008		 |$M37769|

			 ENDP  ; |?GetDeviceAddress@CDevice@@QAAEXZ|, CDevice::GetDeviceAddress

	EXPORT	|??0CDeviceGlobal@@QAA@XZ|		; CDeviceGlobal::CDeviceGlobal
	EXPORT	|??_7CDeviceGlobal@@6B@| [ DATA ]	; CDeviceGlobal::`vftable'
	IMPORT	|InitializeCriticalSection|
	IMPORT	|??0Countdown@@QAA@K@Z|			; Countdown::Countdown
	IMPORT	|??0CritSec_Ex@@QAA@XZ|			; CritSec_Ex::CritSec_Ex
	IMPORT	|_purecall|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T37781| DCD	|$LN5@CDeviceGlo|
	DCD	0x40001901

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7CDeviceGlobal@@6B@| DCD |_purecall|		; CDeviceGlobal::`vftable'
	DCD	|_purecall|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CDeviceGlobal@@QAA@XZ| PROC	; CDeviceGlobal::CDeviceGlobal

; 87   : {

  00000		 |$LN5@CDeviceGlo|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37778|
  00004	e1a04000	 mov         r4, r0
  00008	e59f3050	 ldr         r3, [pc, #0x50]
  0000c	e480302c	 str         r3, [r0], #0x2C
  00010	eb000000	 bl          |??0CritSec_Ex@@QAA@XZ|
  00014	e3a01000	 mov         r1, #0
  00018	e2840054	 add         r0, r4, #0x54
  0001c	eb000000	 bl          |??0Countdown@@QAA@K@Z|

; 88   : 
; 89   :     m_dwFreeAddressArray[0]=0x00000001;

  00020	e3a03001	 mov         r3, #1
  00024	e584301c	 str         r3, [r4, #0x1C]

; 90   :     m_dwFreeAddressArray[1] = m_dwFreeAddressArray[2] = m_dwFreeAddressArray[3] = 0x00000000;

  00028	e3a03000	 mov         r3, #0

; 91   :     
; 92   :     m_hUSBDInstance = NULL;
; 93   :     m_pUSBDAttachProc = NULL;
; 94   :     m_pUSBDDetachProc = NULL;
; 95   :     m_pvHcdContext = NULL;
; 96   :     m_pUSBDSelectConfigurationProc = NULL;
; 97   : #ifdef DEBUG
; 98   :     g_fAlreadyCalled = FALSE;
; 99   : #endif // DEBUG
; 100  :     //InitCritSec_Ex( &m_csAddress0Lock );
; 101  :     InitializeCriticalSection( &m_csFreeAddressArrayLock );

  0002c	e2840008	 add         r0, r4, #8
  00030	e5843028	 str         r3, [r4, #0x28]
  00034	e5843024	 str         r3, [r4, #0x24]
  00038	e5843020	 str         r3, [r4, #0x20]
  0003c	e5843074	 str         r3, [r4, #0x74]
  00040	e584307c	 str         r3, [r4, #0x7C]
  00044	e5843080	 str         r3, [r4, #0x80]
  00048	e5843088	 str         r3, [r4, #0x88]
  0004c	e5843078	 str         r3, [r4, #0x78]
  00050	eb000000	 bl          InitializeCriticalSection

; 102  : };

  00054	e1a00004	 mov         r0, r4
  00058	e8bd4010	 ldmia       sp!, {r4, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$LN6@CDeviceGlo|
  00060		 |$LN7@CDeviceGlo|
  00060	00000000	 DCD         |??_7CDeviceGlobal@@6B@|
  00064		 |$M37779|

			 ENDP  ; |??0CDeviceGlobal@@QAA@XZ|, CDeviceGlobal::CDeviceGlobal

	EXPORT	|?Initialize@CDeviceGlobal@@QAAHPAX@Z|	; CDeviceGlobal::Initialize
	EXPORT	|??_C@_1BE@NANPENDH@?$AAH?$AAc?$AAd?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CE@MBINLHH@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AAe?$AAd?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CE@KAKNBFJP@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAD?$AAe?$AAt?$AAa?$AAc?$AAh?$AAe?$AAd?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CO@MCCAIHAO@?$AAH?$AAc?$AAd?$AAS?$AAe?$AAl?$AAe?$AAc?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DC@HKGGOMPG@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAS?$AAu?$AAs?$AAp?$AAe?$AAn?$AAd?$AAe?$AAR?$AAe?$AAs?$AAu?$AAm?$AAe?$AAd?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BC@MPAIGMIO@?$AAU?$AAS?$AAB?$AAD?$AA?4?$AAD?$AAL?$AAL?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|GetProcAddressW|
	IMPORT	|LoadDriver|
	IMPORT	|?Initialize@CritSec_Ex@@QAAXXZ|	; CritSec_Ex::Initialize
	IMPORT	|?gc_HcdFuncs@@3U_HCD_FUNCS@@A|		; gc_HcdFuncs
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T37800| DCD	|$LN10@Initialize|
	DCD	0x40004101

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@NANPENDH@?$AAH?$AAc?$AAd?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AA?$AA@| DCB "H"
	DCB	0x0, "c", 0x0, "d", 0x0, "A", 0x0, "t", 0x0, "t", 0x0, "a"
	DCB	0x0, "c", 0x0, "h", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CE@MBINLHH@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AAe?$AAd?$AA?$AA@| DCB "H"
	DCB	0x0, "c", 0x0, "d", 0x0, "D", 0x0, "e", 0x0, "v", 0x0, "i"
	DCB	0x0, "c", 0x0, "e", 0x0, "A", 0x0, "t", 0x0, "t", 0x0, "a"
	DCB	0x0, "c", 0x0, "h", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CE@KAKNBFJP@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAD?$AAe?$AAt?$AAa?$AAc?$AAh?$AAe?$AAd?$AA?$AA@| DCB "H"
	DCB	0x0, "c", 0x0, "d", 0x0, "D", 0x0, "e", 0x0, "v", 0x0, "i"
	DCB	0x0, "c", 0x0, "e", 0x0, "D", 0x0, "e", 0x0, "t", 0x0, "a"
	DCB	0x0, "c", 0x0, "h", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CO@MCCAIHAO@?$AAH?$AAc?$AAd?$AAS?$AAe?$AAl?$AAe?$AAc?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@| DCB "H"
	DCB	0x0, "c", 0x0, "d", 0x0, "S", 0x0, "e", 0x0, "l", 0x0, "e"
	DCB	0x0, "c", 0x0, "t", 0x0, "C", 0x0, "o", 0x0, "n", 0x0, "f"
	DCB	0x0, "i", 0x0, "g", 0x0, "u", 0x0, "r", 0x0, "a", 0x0, "t"
	DCB	0x0, "i", 0x0, "o", 0x0, "n", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DC@HKGGOMPG@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAS?$AAu?$AAs?$AAp?$AAe?$AAn?$AAd?$AAe?$AAR?$AAe?$AAs?$AAu?$AAm?$AAe?$AAd?$AA?$AA@| DCB "H"
	DCB	0x0, "c", 0x0, "d", 0x0, "D", 0x0, "e", 0x0, "v", 0x0, "i"
	DCB	0x0, "c", 0x0, "e", 0x0, "S", 0x0, "u", 0x0, "s", 0x0, "p"
	DCB	0x0, "e", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "R", 0x0, "e"
	DCB	0x0, "s", 0x0, "u", 0x0, "m", 0x0, "e", 0x0, "d", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BC@MPAIGMIO@?$AAU?$AAS?$AAB?$AAD?$AA?4?$AAD?$AAL?$AAL?$AA?$AA@| DCB "U"
	DCB	0x0, "S", 0x0, "B", 0x0, "D", 0x0, ".", 0x0, "D", 0x0, "L"
	DCB	0x0, "L", 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Initialize@CDeviceGlobal@@QAAHPAX@Z| PROC ; CDeviceGlobal::Initialize

; 139  : {

  00000		 |$LN10@Initialize|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37797|
  00004	e1a04000	 mov         r4, r0

; 140  :     DEBUGMSG( ZONE_INIT, (TEXT("%s: +CDeviceGlobal::Initialize\n"),GetControllerName()));
; 141  :     m_pHcd=pHcd;
; 142  : #ifdef DEBUG
; 143  :     DEBUGCHK( !g_fAlreadyCalled );
; 144  :     g_fAlreadyCalled = TRUE;
; 145  : #endif // DEBUG
; 146  : 
; 147  :     DEBUGCHK( DWORD(8 * sizeof( m_dwFreeAddressArray )) == DWORD(USB_MAX_ADDRESS + 1) &&
; 148  :               8 * sizeof( m_dwFreeAddressArray[0] ) == 32 &&
; 149  :               m_dwFreeAddressArray[ 0 ] == 0x00000001 &&
; 150  :               m_dwFreeAddressArray[ 1 ] == 0x00000000 &&
; 151  :               m_dwFreeAddressArray[ 2 ] == 0x00000000 &&
; 152  :               m_dwFreeAddressArray[ 3 ] == 0x00000000 );
; 153  : 
; 154  :     m_csAddress0Lock.Initialize();

  00008	e284002c	 add         r0, r4, #0x2C
  0000c	e5841004	 str         r1, [r4, #4]
  00010	eb000000	 bl          |?Initialize@CritSec_Ex@@QAAXXZ|

; 155  :     m_objCountdown.UnlockCountdown ();

  00014	e2840054	 add         r0, r4, #0x54
  00018	eb000000	 bl          EnterCriticalSection
  0001c	e3a03000	 mov         r3, #0
  00020	e2840054	 add         r0, r4, #0x54
  00024	e584306c	 str         r3, [r4, #0x6C]
  00028	eb000000	 bl          LeaveCriticalSection

; 156  :     // establish links to USBD.dll
; 157  :     {
; 158  :         // this procedure is called to establish a link to USBD
; 159  :         LPUSBD_HCD_ATTACH_PROC  lpHcdAttachProc = NULL;
; 160  :         // this is defined in uhcddrv.cpp
; 161  :         extern HCD_FUNCS gc_HcdFuncs;
; 162  : 
; 163  :         DEBUGCHK( m_pHcd != NULL &&
; 164  :                   m_hUSBDInstance == NULL &&
; 165  :                   m_pUSBDDetachProc == NULL &&
; 166  :                   m_pUSBDAttachProc == NULL &&
; 167  :                   m_pvHcdContext == NULL );
; 168  : 
; 169  :         m_hUSBDInstance = LoadDriver(TEXT("USBD.DLL"));

  0002c	e59f00cc	 ldr         r0, [pc, #0xCC]
  00030	eb000000	 bl          LoadDriver
  00034	e3500000	 cmp         r0, #0
  00038	e5840074	 str         r0, [r4, #0x74]

; 170  :         if ( m_hUSBDInstance == NULL ) {
; 171  :             DEBUGMSG(ZONE_ERROR,(TEXT("%s: -CDevice::Initialize - Could not load USBD.DLL\r\n"),GetControllerName()));
; 172  :             return FALSE;

  0003c	0a000026	 beq         |$LN1@Initialize|

; 173  :         }
; 174  :         lpHcdAttachProc = (LPUSBD_HCD_ATTACH_PROC) GetProcAddress(m_hUSBDInstance, TEXT("HcdAttach"));

  00040	e59f10b4	 ldr         r1, [pc, #0xB4]
  00044	eb000000	 bl          GetProcAddressW

; 175  :         m_pUSBDAttachProc = (LPUSBD_ATTACH_PROC) GetProcAddress(m_hUSBDInstance, TEXT("HcdDeviceAttached"));

  00048	e59f10a8	 ldr         r1, [pc, #0xA8]
  0004c	e1a05000	 mov         r5, r0
  00050	e5940074	 ldr         r0, [r4, #0x74]
  00054	eb000000	 bl          GetProcAddressW

; 176  :         m_pUSBDDetachProc = (LPUSBD_DETACH_PROC) GetProcAddress(m_hUSBDInstance, TEXT("HcdDeviceDetached"));

  00058	e59f1094	 ldr         r1, [pc, #0x94]
  0005c	e1a03000	 mov         r3, r0
  00060	e5940074	 ldr         r0, [r4, #0x74]
  00064	e584307c	 str         r3, [r4, #0x7C]
  00068	eb000000	 bl          GetProcAddressW

; 177  :         m_pUSBDSelectConfigurationProc = (LPUSBD_SELECT_CONFIGURATION_PROC)GetProcAddress(m_hUSBDInstance, TEXT("HcdSelectConfiguration"));// Optional

  0006c	e59f107c	 ldr         r1, [pc, #0x7C]
  00070	e1a03000	 mov         r3, r0
  00074	e5940074	 ldr         r0, [r4, #0x74]
  00078	e5843080	 str         r3, [r4, #0x80]
  0007c	eb000000	 bl          GetProcAddressW

; 178  :         m_pUSBDSuspendResumed = (LPUSBD_SUSPEND_RESUME_PROC) GetProcAddress(m_hUSBDInstance, TEXT("HcdDeviceSuspendeResumed"));

  00080	e59f1064	 ldr         r1, [pc, #0x64]
  00084	e1a03000	 mov         r3, r0
  00088	e5940074	 ldr         r0, [r4, #0x74]
  0008c	e5843078	 str         r3, [r4, #0x78]
  00090	eb000000	 bl          GetProcAddressW

; 179  :         if ( m_pUSBDAttachProc == NULL ||
; 180  :              m_pUSBDDetachProc == NULL ||
; 181  :              lpHcdAttachProc == NULL ||
; 182  :              (*lpHcdAttachProc)(m_pHcd, &gc_HcdFuncs,  &m_pvHcdContext) == FALSE ) {

  00094	e594307c	 ldr         r3, [r4, #0x7C]
  00098	e5840084	 str         r0, [r4, #0x84]
  0009c	e3530000	 cmp         r3, #0
  000a0	0a00000d	 beq         |$LN1@Initialize|
  000a4	e5943080	 ldr         r3, [r4, #0x80]
  000a8	e3530000	 cmp         r3, #0
  000ac	0a00000a	 beq         |$LN1@Initialize|
  000b0	e3550000	 cmp         r5, #0
  000b4	0a000008	 beq         |$LN1@Initialize|
  000b8	e59f1028	 ldr         r1, [pc, #0x28]
  000bc	e5940004	 ldr         r0, [r4, #4]
  000c0	e2842088	 add         r2, r4, #0x88
  000c4	e1a0e00f	 mov         lr, pc
  000c8	e12fff15	 bx          r5
  000cc	e3500000	 cmp         r0, #0

; 186  :         }
; 187  :         DEBUGCHK( m_pvHcdContext != NULL );
; 188  :     }
; 189  : 
; 190  : 
; 191  :     DEBUGMSG( ZONE_INIT, (TEXT("%s: -CDevice::Initialize, success!\n"),GetControllerName()));
; 192  :     return TRUE;

  000d0	13a00001	 movne       r0, #1

; 193  : }

  000d4	18bd4030	 ldmneia     sp!, {r4, r5, lr}
  000d8	112fff1e	 bxne        lr
  000dc		 |$LN1@Initialize|

; 183  : 
; 184  :             DEBUGMSG(ZONE_ERROR, (TEXT("%s: -CDevice::Initialize - Could not establish USBD links\n"),GetControllerName()));
; 185  :             return FALSE;

  000dc	e3a00000	 mov         r0, #0

; 193  : }

  000e0	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000e4	e12fff1e	 bx          lr
  000e8		 |$LN11@Initialize|
  000e8		 |$LN12@Initialize|
  000e8	00000000	 DCD         |?gc_HcdFuncs@@3U_HCD_FUNCS@@A|
  000ec		 |$LN13@Initialize|
  000ec	00000000	 DCD         |??_C@_1DC@HKGGOMPG@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAS?$AAu?$AAs?$AAp?$AAe?$AAn?$AAd?$AAe?$AAR?$AAe?$AAs?$AAu?$AAm?$AAe?$AAd?$AA?$AA@|
  000f0		 |$LN14@Initialize|
  000f0	00000000	 DCD         |??_C@_1CO@MCCAIHAO@?$AAH?$AAc?$AAd?$AAS?$AAe?$AAl?$AAe?$AAc?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@|
  000f4		 |$LN15@Initialize|
  000f4	00000000	 DCD         |??_C@_1CE@KAKNBFJP@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAD?$AAe?$AAt?$AAa?$AAc?$AAh?$AAe?$AAd?$AA?$AA@|
  000f8		 |$LN16@Initialize|
  000f8	00000000	 DCD         |??_C@_1CE@MBINLHH@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AAe?$AAd?$AA?$AA@|
  000fc		 |$LN17@Initialize|
  000fc	00000000	 DCD         |??_C@_1BE@NANPENDH@?$AAH?$AAc?$AAd?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AA?$AA@|
  00100		 |$LN18@Initialize|
  00100	00000000	 DCD         |??_C@_1BC@MPAIGMIO@?$AAU?$AAS?$AAB?$AAD?$AA?4?$AAD?$AAL?$AAL?$AA?$AA@|
  00104		 |$M37798|

			 ENDP  ; |?Initialize@CDeviceGlobal@@QAAHPAX@Z|, CDeviceGlobal::Initialize

	EXPORT	|?DeInitialize@CDeviceGlobal@@QAAXXZ|	; CDeviceGlobal::DeInitialize
	EXPORT	|??_C@_1BE@MDMBICMJ@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAt?$AAa?$AAc?$AAh?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|FreeLibrary|
	IMPORT	|?WaitForCountdown@Countdown@@QAAXH@Z|	; Countdown::WaitForCountdown

  00000			 AREA	 |.pdata|, PDATA
|$T37817| DCD	|$LN7@DeInitiali|
	DCD	0x40001e01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@MDMBICMJ@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAt?$AAa?$AAc?$AAh?$AA?$AA@| DCB "H"
	DCB	0x0, "c", 0x0, "d", 0x0, "D", 0x0, "e", 0x0, "t", 0x0, "a"
	DCB	0x0, "c", 0x0, "h", 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DeInitialize@CDeviceGlobal@@QAAXXZ| PROC ; CDeviceGlobal::DeInitialize

; 206  : {

  00000		 |$LN7@DeInitiali|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37814|
  00004	e1a04000	 mov         r4, r0

; 207  :     DEBUGMSG( ZONE_INIT, (TEXT("%s: +CDevice::DeInitialize\n"),GetControllerName()));
; 208  : 
; 209  : #ifdef DEBUG
; 210  :     DEBUGCHK(g_fAlreadyCalled == TRUE);
; 211  :     g_fAlreadyCalled = FALSE;
; 212  : #endif // DEBUG
; 213  : 
; 214  :     // wait for any stray detach threads
; 215  :     // This can block waiting for a callback into a client driver to return.
; 216  :     // Since callbacks aren't supposed to block this oughtn't cause deadlock,
; 217  :     // but a misbehaving client driver can cause us serious grief.
; 218  :     // Nonetheless, not waiting means we might free USBD.DLL while it's still in use.
; 219  :     //DeleteCountdown(&m_objCountdown);
; 220  :     m_objCountdown.WaitForCountdown( TRUE);

  00008	e3a01001	 mov         r1, #1
  0000c	e2840054	 add         r0, r4, #0x54
  00010	eb000000	 bl          |?WaitForCountdown@Countdown@@QAAXH@Z|

; 221  : 
; 222  :     // unload USBD.dll
; 223  :     if ( m_hUSBDInstance ) {

  00014	e5943074	 ldr         r3, [r4, #0x74]
  00018	e3a05000	 mov         r5, #0
  0001c	e3530000	 cmp         r3, #0
  00020	0a000009	 beq         |$LN2@DeInitiali|

; 224  :         LPUSBD_HCD_DETACH_PROC lpHcdDetachProc;
; 225  :         lpHcdDetachProc = (LPUSBD_HCD_DETACH_PROC) GetProcAddress(m_hUSBDInstance, TEXT("HcdDetach"));

  00024	e59f1048	 ldr         r1, [pc, #0x48]
  00028	e1a00003	 mov         r0, r3
  0002c	eb000000	 bl          GetProcAddressW
  00030	e1b03000	 movs        r3, r0

; 226  :         if ( lpHcdDetachProc != NULL ) {
; 227  :             (*lpHcdDetachProc)(m_pvHcdContext);

  00034	15940088	 ldrne       r0, [r4, #0x88]
  00038	11a0e00f	 movne       lr, pc
  0003c	112fff13	 bxne        r3

; 228  :         }
; 229  :         FreeLibrary( m_hUSBDInstance );

  00040	e5940074	 ldr         r0, [r4, #0x74]
  00044	eb000000	 bl          FreeLibrary

; 230  :         m_hUSBDInstance = NULL;

  00048	e5845074	 str         r5, [r4, #0x74]
  0004c		 |$LN2@DeInitiali|

; 231  :     }
; 232  :     m_pUSBDAttachProc = NULL;
; 233  :     m_pUSBDDetachProc = NULL;
; 234  :     m_pvHcdContext = NULL;
; 235  : 
; 236  :     m_dwFreeAddressArray[0] = 0x00000001;

  0004c	e3a03001	 mov         r3, #1
  00050	e584301c	 str         r3, [r4, #0x1C]
  00054	e584507c	 str         r5, [r4, #0x7C]
  00058	e5845080	 str         r5, [r4, #0x80]
  0005c	e5845088	 str         r5, [r4, #0x88]

; 237  :     m_dwFreeAddressArray[1] = m_dwFreeAddressArray[2] = m_dwFreeAddressArray[3] = 0x00000000;

  00060	e5845028	 str         r5, [r4, #0x28]
  00064	e5845024	 str         r5, [r4, #0x24]
  00068	e5845020	 str         r5, [r4, #0x20]

; 238  : 
; 239  : 
; 240  :     DEBUGMSG( ZONE_INIT, (TEXT("%s: -CDevice::DeInitialize\n"),GetControllerName()));
; 241  : }

  0006c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00070	e12fff1e	 bx          lr
  00074		 |$LN8@DeInitiali|
  00074		 |$LN9@DeInitiali|
  00074	00000000	 DCD         |??_C@_1BE@MDMBICMJ@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAt?$AAa?$AAc?$AAh?$AA?$AA@|
  00078		 |$M37815|

			 ENDP  ; |?DeInitialize@CDeviceGlobal@@QAAXXZ|, CDeviceGlobal::DeInitialize

	EXPORT	|?ReserveAddress@CDeviceGlobal@@QAAHAAE@Z| ; CDeviceGlobal::ReserveAddress

  00000			 AREA	 |.pdata|, PDATA
|$T37837| DCD	|$LN12@ReserveAdd|
	DCD	0x40002201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ReserveAddress@CDeviceGlobal@@QAAHAAE@Z| PROC ; CDeviceGlobal::ReserveAddress

; 256  : {

  00000		 |$LN12@ReserveAdd|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M37834|
  00004	e1a07001	 mov         r7, r1
  00008	e1a04000	 mov         r4, r0

; 257  :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("%s: +CDeviceGlobal::ReserveAddress\n"),GetControllerName()) );
; 258  : 
; 259  :     BOOL fSuccess = FALSE;
; 260  : 
; 261  :     EnterCriticalSection( &m_csFreeAddressArrayLock );

  0000c	e2840008	 add         r0, r4, #8
  00010	e3a05000	 mov         r5, #0
  00014	eb000000	 bl          EnterCriticalSection

; 262  : 
; 263  :     // the address has 7 bits:
; 264  :     //
; 265  :     // xxyyyyyb
; 266  :     //
; 267  :     // xxb is the index into the m_dwFreeAddressArray (0-3)
; 268  :     // yyyyyb is the bit of the m_dwFreeAddressArray[xxb] DWORD
; 269  :     // that the address corresponds to
; 270  : 
; 271  :     // address 0 should always be marked used
; 272  :     DEBUGCHK(m_dwFreeAddressArray[0] & 1 );
; 273  : 
; 274  :     for ( UCHAR address = 1; address <= USB_MAX_ADDRESS; address++ ) {

  00018	e3a00001	 mov         r0, #1
  0001c	e3a02001	 mov         r2, #1
  00020	e3a01001	 mov         r1, #1
  00024		 |$LL4@ReserveAdd|

; 275  :         const UCHAR index = (address >> 5); // 5 == log base 2 of 32

  00024	e1a032a0	 mov         r3, r0, lsr #5
  00028	e203e0ff	 and         lr, r3, #0xFF

; 276  :         const UCHAR bit = address & (32 - 1); // 32 == # of bits in DWORD
; 277  :         if ( (m_dwFreeAddressArray[ index ] & (1 << bit)) == 0 ) {

  0002c	e084310e	 add         r3, r4, lr, lsl #2
  00030	e593301c	 ldr         r3, [r3, #0x1C]
  00034	e202601f	 and         r6, r2, #0x1F
  00038	e1130611	 tst         r3, r1, lsl r6
  0003c	0a000005	 beq         |$LN8@ReserveAdd|
  00040	e2823001	 add         r3, r2, #1
  00044	e20300ff	 and         r0, r3, #0xFF
  00048	e1a02000	 mov         r2, r0
  0004c	e350007f	 cmp         r0, #0x7F
  00050	9afffff3	 bls         |$LL4@ReserveAdd|
  00054	ea000006	 b           |$LN2@ReserveAdd|
  00058		 |$LN8@ReserveAdd|

; 278  :             // this address is free
; 279  :             fSuccess = TRUE;
; 280  :             rAddress = address;
; 281  :             // mark address as used
; 282  :             m_dwFreeAddressArray[ index ] |= (1 << bit);

  00058	e084210e	 add         r2, r4, lr, lsl #2
  0005c	e5c70000	 strb        r0, [r7]
  00060	e592301c	 ldr         r3, [r2, #0x1C]
  00064	e3a01001	 mov         r1, #1
  00068	e3a05001	 mov         r5, #1
  0006c	e1833611	 orr         r3, r3, r1, lsl r6
  00070	e582301c	 str         r3, [r2, #0x1C]
  00074		 |$LN2@ReserveAdd|

; 283  :             break;
; 284  :         }
; 285  :     }
; 286  :     LeaveCriticalSection( &m_csFreeAddressArrayLock );

  00074	e2840008	 add         r0, r4, #8
  00078	eb000000	 bl          LeaveCriticalSection

; 287  : 
; 288  :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("%s: -CDevice::ReserveAddress, returning rAddress %d, success = %d\n"),GetControllerName(), rAddress, fSuccess ) );
; 289  :     return fSuccess;
; 290  : }

  0007c	e1a00005	 mov         r0, r5
  00080	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00084	e12fff1e	 bx          lr
  00088		 |$M37835|

			 ENDP  ; |?ReserveAddress@CDeviceGlobal@@QAAHAAE@Z|, CDeviceGlobal::ReserveAddress

	EXPORT	|?FreeAddress@CDeviceGlobal@@QAAXE@Z|	; CDeviceGlobal::FreeAddress

  00000			 AREA	 |.pdata|, PDATA
|$T37847| DCD	|$LN5@FreeAddres|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FreeAddress@CDeviceGlobal@@QAAXE@Z| PROC ; CDeviceGlobal::FreeAddress

; 302  : {

  00000		 |$LN5@FreeAddres|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37844|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 303  :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("%s: +CDeviceGlobal::FreeAddress - address = %d\n"),GetControllerName(), address) );
; 304  : 
; 305  :     EnterCriticalSection( &m_csFreeAddressArrayLock );

  0000c	e2850008	 add         r0, r5, #8
  00010	eb000000	 bl          EnterCriticalSection

; 306  : 
; 307  :     // the address has 7 bits:
; 308  :     //
; 309  :     // xxyyyyyb
; 310  :     //
; 311  :     // xxb is the index into the m_dwFreeAddressArray (0-3)
; 312  :     // yyyyyb is the bit of the m_dwFreeAddressArray[xxb] DWORD
; 313  :     // that the address corresponds to
; 314  : 
; 315  :     const UCHAR index = (address >> 5); // 5 == log base 2 of 32

  00014	e1a032a4	 mov         r3, r4, lsr #5
  00018	e20330ff	 and         r3, r3, #0xFF
  0001c	e085e103	 add         lr, r5, r3, lsl #2

; 316  :     const UCHAR bit = address & (32 - 1); // 32 == # of bits in DWORD
; 317  : 
; 318  :     // make sure this address is marked as used
; 319  :     DEBUGCHK( index < 4 &&
; 320  :               (m_dwFreeAddressArray[ index ] & ( 1 << bit )) );
; 321  : 
; 322  :     // free this address
; 323  :     m_dwFreeAddressArray[ index ] &= ~(1 << bit);

  00020	e59e201c	 ldr         r2, [lr, #0x1C]
  00024	e204301f	 and         r3, r4, #0x1F
  00028	e3a01001	 mov         r1, #1

; 324  : 
; 325  :     LeaveCriticalSection( &m_csFreeAddressArrayLock );

  0002c	e1c23311	 bic         r3, r2, r1, lsl r3
  00030	e2850008	 add         r0, r5, #8
  00034	e58e301c	 str         r3, [lr, #0x1C]
  00038	eb000000	 bl          LeaveCriticalSection

; 326  : 
; 327  :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("%s: -CDevice::FreeAddress - address = %d\n"),GetControllerName(), address) );
; 328  : }

  0003c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M37845|

			 ENDP  ; |?FreeAddress@CDeviceGlobal@@QAAXE@Z|, CDeviceGlobal::FreeAddress

	EXPORT	|?TransferDoneCallbackSetEvent@CDevice@@KAKPAX@Z| ; CDevice::TransferDoneCallbackSetEvent
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T37860| DCD	|$LN7@TransferDo|
	DCD	0x40000601
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TransferDoneCallbackSetEvent@CDevice@@KAKPAX@Z| PROC ; CDevice::TransferDoneCallbackSetEvent

; 345  : {

  00000		 |$LN7@TransferDo|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37857|

; 346  :     DEBUGCHK( context );
; 347  :     SetEvent( (HANDLE) context );

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 348  :     return 0;

  0000c	e3a00000	 mov         r0, #0

; 349  : }

  00010	e49de004	 ldr         lr, [sp], #4
  00014	e12fff1e	 bx          lr
  00018		 |$M37858|

			 ENDP  ; |?TransferDoneCallbackSetEvent@CDevice@@KAKPAX@Z|, CDevice::TransferDoneCallbackSetEvent

	EXPORT	|??0CDevice@@QAA@EABU_USB_DEVICE_INFO@@HHEQAVCDeviceGlobal@@QAVCHub@@E@Z| ; CDevice::CDevice
	EXPORT	|??_7CDevice@@6B@| [ DATA ]		; CDevice::`vftable'
	EXPORT	|?DisableDevice@CDevice@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z| ; CDevice::DisableDevice
	EXPORT	|?SuspendResume@CDevice@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z| ; CDevice::SuspendResume
	EXPORT	|?ResumeNotification@CDevice@@UAAHXZ|	; CDevice::ResumeNotification
	EXPORT	|?NotifyOnSuspendedResumed@CDevice@@UAAHH@Z| ; CDevice::NotifyOnSuspendedResumed
	EXPORT	|?GetUSB2TT@CDevice@@UAAPAVCHub@@AAE0AAH@Z| ; CDevice::GetUSB2TT
	EXPORT	|?SignalHub@CDevice@@UAAXXZ|		; CDevice::SignalHub
	IMPORT	|memcpy|
	IMPORT	|??_ECDevice@@UAAPAXI@Z|, WEAK |??_GCDevice@@UAAPAXI@Z| ; CDevice::`vector deleting destructor', CDevice::`scalar deleting destructor'

  00000			 AREA	 |.pdata|, PDATA
|$T37874| DCD	|$LN5@CDevice|
	DCD	0x40002101

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7CDevice@@6B@| DCD |??_ECDevice@@UAAPAXI@Z|		; CDevice::`vftable'
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|?DisableDevice@CDevice@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|
	DCD	|?SuspendResume@CDevice@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|
	DCD	|?ResumeNotification@CDevice@@UAAHXZ|
	DCD	|?NotifyOnSuspendedResumed@CDevice@@UAAHH@Z|
	DCD	|_purecall|
	DCD	|?GetUSB2TT@CDevice@@UAAPAVCHub@@AAE0AAH@Z|
	DCD	|?SignalHub@CDevice@@UAAXXZ|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CDevice@@QAA@EABU_USB_DEVICE_INFO@@HHEQAVCDeviceGlobal@@QAVCHub@@E@Z| PROC ; CDevice::CDevice

; 387  : {

  00000		 |$LN5@CDevice|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M37871|
  00004	e1a08003	 mov         r8, r3
  00008	e1a06002	 mov         r6, r2
  0000c	e1a07001	 mov         r7, r1
  00010	e1a09000	 mov         r9, r0
  00014	e59fe064	 ldr         lr, [pc, #0x64]
  00018	e59d4028	 ldr         r4, [sp, #0x28]
  0001c	e5dd502c	 ldrb        r5, [sp, #0x2C]
  00020	e2890024	 add         r0, r9, #0x24
  00024	e3a02020	 mov         r2, #0x20
  00028	e1a01006	 mov         r1, r6
  0002c	e589e000	 str         lr, [r9]
  00030	e5894004	 str         r4, [r9, #4]
  00034	e5c95008	 strb        r5, [r9, #8]
  00038	e5c97020	 strb        r7, [r9, #0x20]
  0003c	eb000000	 bl          memcpy
  00040	e59de024	 ldr         lr, [sp, #0x24]
  00044	e59d201c	 ldr         r2, [sp, #0x1C]
  00048	e5dd1020	 ldrb        r1, [sp, #0x20]
  0004c	e3a03000	 mov         r3, #0

; 388  :     DEBUGMSG( ZONE_DEVICE && ZONE_VERBOSE, (TEXT("%s: +CDevice::CDevice\n"),GetControllerName()) );
; 389  :     m_fIsSuspend = FALSE;
; 390  :     DEBUGCHK( m_deviceInfo.dwCount == sizeof( USB_DEVICE ) &&
; 391  :               m_deviceInfo.Descriptor.bDescriptorType == USB_DEVICE_DESCRIPTOR_TYPE &&
; 392  :               m_deviceInfo.Descriptor.bLength == sizeof( USB_DEVICE_DESCRIPTOR ) &&
; 393  :               address <= USB_MAX_ADDRESS &&
; 394  :               tierNumber <= USB_MAXIMUM_HUB_TIER + 1 );
; 395  : 
; 396  :     InitializeCriticalSection( &m_csDeviceLock );

  00050	e289000c	 add         r0, r9, #0xC
  00054	e589e050	 str         lr, [r9, #0x50]
  00058	e5892048	 str         r2, [r9, #0x48]
  0005c	e5c9104c	 strb        r1, [r9, #0x4C]
  00060	e5898044	 str         r8, [r9, #0x44]
  00064	e5c93054	 strb        r3, [r9, #0x54]
  00068	e589305c	 str         r3, [r9, #0x5C]
  0006c	e5893058	 str         r3, [r9, #0x58]
  00070	eb000000	 bl          InitializeCriticalSection

; 397  :     DEBUGMSG( ZONE_DEVICE && ZONE_VERBOSE, (TEXT("%s: -CDevice::CDevice\n"),GetControllerName()) );
; 398  : }

  00074	e1a00009	 mov         r0, r9
  00078	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$LN6@CDevice|
  00080		 |$LN7@CDevice|
  00080	00000000	 DCD         |??_7CDevice@@6B@|
  00084		 |$M37872|

			 ENDP  ; |??0CDevice@@QAA@EABU_USB_DEVICE_INFO@@HHEQAVCDeviceGlobal@@QAVCHub@@E@Z|, CDevice::CDevice

; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T37885| DCD	|$LN5@ResumeNoti|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResumeNotification@CDevice@@UAAHXZ| PROC ; CDevice::ResumeNotification

; 172  :     virtual BOOL ResumeNotification() { return FALSE; };

  00000		 |$LN5@ResumeNoti|
  00000		 |$M37882|
  00000	e3a00000	 mov         r0, #0
  00004	e12fff1e	 bx          lr
  00008		 |$M37883|

			 ENDP  ; |?ResumeNotification@CDevice@@UAAHXZ|, CDevice::ResumeNotification


  00000			 AREA	 |.pdata|, PDATA
|$T37894| DCD	|$LN5@NotifyOnSu|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?NotifyOnSuspendedResumed@CDevice@@UAAHH@Z| PROC ; CDevice::NotifyOnSuspendedResumed

; 173  :     virtual BOOL NotifyOnSuspendedResumed(BOOL /*fResumed*/) { return FALSE; };

  00000		 |$LN5@NotifyOnSu|
  00000		 |$M37891|
  00000	e3a00000	 mov         r0, #0
  00004	e12fff1e	 bx          lr
  00008		 |$M37892|

			 ENDP  ; |?NotifyOnSuspendedResumed@CDevice@@UAAHH@Z|, CDevice::NotifyOnSuspendedResumed


  00000			 AREA	 |.pdata|, PDATA
|$T37901| DCD	|$LN5@SignalHub|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SignalHub@CDevice@@UAAXXZ| PROC	; CDevice::SignalHub

; 178  :     virtual void SignalHub() { return;};               

  00000		 |$LN5@SignalHub|
  00000		 |$M37898|
  00000	e12fff1e	 bx          lr
  00004		 |$M37899|

			 ENDP  ; |?SignalHub@CDevice@@UAAXXZ|, CDevice::SignalHub

; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T37918| DCD	|$LN11@GetUSB2TT|
	DCD	0x40001e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetUSB2TT@CDevice@@UAAPAVCHub@@AAE0AAH@Z| PROC ; CDevice::GetUSB2TT

; 461  : {

  00000		 |$LN11@GetUSB2TT|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37915|
  00004	e1a05003	 mov         r5, r3

; 462  :     if (!m_fIsHighSpeed) {

  00008	e590e048	 ldr         lr, [r0, #0x48]
  0000c	e35e0000	 cmp         lr, #0
  00010	1a000014	 bne         |$LN4@GetUSB2TT|

; 463  :         CHub *  pHub = m_pAttachedHub;

  00014	e590e004	 ldr         lr, [r0, #4]

; 464  :         UCHAR  sAttachedPort = m_sAttachedPort;

  00018	e5d04008	 ldrb        r4, [r0, #8]
  0001c	e35e0000	 cmp         lr, #0

; 465  :         while (pHub!=NULL && pHub->m_fIsHighSpeed!=TRUE) {

  00020	0a000011	 beq         |$LN5@GetUSB2TT|
  00024		 |$LL3@GetUSB2TT|
  00024	e59e0048	 ldr         r0, [lr, #0x48]
  00028	e3500001	 cmp         r0, #1
  0002c	0a000003	 beq         |$LN2@GetUSB2TT|

; 466  :             sAttachedPort = pHub->m_sAttachedPort;
; 467  :             pHub =  pHub->m_pAttachedHub;

  00030	e59e0004	 ldr         r0, [lr, #4]
  00034	e5de4008	 ldrb        r4, [lr, #8]
  00038	e1b0e000	 movs        lr, r0
  0003c	1afffff8	 bne         |$LL3@GetUSB2TT|
  00040		 |$LN2@GetUSB2TT|

; 468  :         }
; 469  :         if (pHub) {

  00040	e35e0000	 cmp         lr, #0
  00044	0a000008	 beq         |$LN5@GetUSB2TT|

; 470  :             pTTAddr = pHub->m_address;

  00048	e5de3020	 ldrb        r3, [lr, #0x20]
  0004c	e5c13000	 strb        r3, [r1]

; 471  :             pTTPort = sAttachedPort;

  00050	e5c24000	 strb        r4, [r2]

; 472  :             ASSERT(sAttachedPort!=0 && sAttachedPort<= pHub->m_usbHubDescriptor.bNumberOfPorts);
; 473  :             ttContext = pHub->m_pAddedTT[sAttachedPort-1];

  00054	e59e30b4	 ldr         r3, [lr, #0xB4]
  00058	e0833104	 add         r3, r3, r4, lsl #2
  0005c	e5133004	 ldr         r3, [r3, #-4]
  00060	e5853000	 str         r3, [r5]

; 474  :         }
; 475  :         return pHub;

  00064	ea000000	 b           |$LN5@GetUSB2TT|
  00068		 |$LN4@GetUSB2TT|

; 476  :     }
; 477  :     return NULL;

  00068	e3a0e000	 mov         lr, #0
  0006c		 |$LN5@GetUSB2TT|

; 478  : }

  0006c	e1a0000e	 mov         r0, lr
  00070	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00074	e12fff1e	 bx          lr
  00078		 |$M37916|

			 ENDP  ; |?GetUSB2TT@CDevice@@UAAPAVCHub@@AAE0AAH@Z|, CDevice::GetUSB2TT

	EXPORT	|?DeleteUsbConfigurationStructure@CDevice@@QBAXAAU_NON_CONST_USB_CONFIGURATION@@@Z| ; CDevice::DeleteUsbConfigurationStructure
	IMPORT	|??3@YAXPAX@Z|				; operator delete

  00000			 AREA	 |.pdata|, PDATA
|$T37939| DCD	|$LN17@DeleteUsbC|
	DCD	0x40002c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DeleteUsbConfigurationStructure@CDevice@@QBAXAAU_NON_CONST_USB_CONFIGURATION@@@Z| PROC ; CDevice::DeleteUsbConfigurationStructure

; 713  : {

  00000		 |$LN17@DeleteUsbC|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M37936|
  00004	e1a04001	 mov         r4, r1

; 714  :     DEBUGMSG( ZONE_DEVICE && ZONE_VERBOSE, (TEXT("%s: +CDevice::DeleteUsbConfigurationStructure\n"),GetControllerName()));
; 715  : 
; 716  :     // this code is right out of the destructor of OHCD.cpp
; 717  :     if ( rConfig.lpInterfaces ) {

  00008	e5943018	 ldr         r3, [r4, #0x18]
  0000c	e3a09000	 mov         r9, #0
  00010	e1b05003	 movs        r5, r3
  00014	0a000020	 beq         |$LN8@DeleteUsbC|

; 718  :         DEBUGCHK( rConfig.Descriptor.bDescriptorType == USB_CONFIGURATION_DESCRIPTOR_TYPE &&
; 719  :                   rConfig.Descriptor.bLength == sizeof( USB_CONFIGURATION_DESCRIPTOR ) &&
; 720  :                   rConfig.dwNumInterfaces >= rConfig.Descriptor.bNumInterfaces );
; 721  :         LPNON_CONST_USB_INTERFACE lpInterface = rConfig.lpInterfaces;
; 722  :         for ( UINT iInterface = 0; iInterface < rConfig.dwNumInterfaces; ++iInterface, ++lpInterface ) {

  00018	e5943014	 ldr         r3, [r4, #0x14]
  0001c	e3a06000	 mov         r6, #0
  00020	e3530000	 cmp         r3, #0
  00024	9a000019	 bls         |$LN5@DeleteUsbC|
  00028		 |$LL7@DeleteUsbC|

; 723  :             if ( lpInterface->lpEndpoints ) {

  00028	e5953014	 ldr         r3, [r5, #0x14]
  0002c	e1b07003	 movs        r7, r3
  00030	0a00000e	 beq         |$LN4@DeleteUsbC|

; 724  :                 DEBUGCHK( lpInterface->Descriptor.bDescriptorType == USB_INTERFACE_DESCRIPTOR_TYPE );
; 725  :                 LPNON_CONST_USB_ENDPOINT lpEndpoint = lpInterface->lpEndpoints;
; 726  :                 for ( UINT iEndpoint = 0; iEndpoint < lpInterface->Descriptor.bNumEndpoints; ++iEndpoint, ++lpEndpoint ) {

  00034	e5d53008	 ldrb        r3, [r5, #8]
  00038	e3a08000	 mov         r8, #0
  0003c	e3530000	 cmp         r3, #0
  00040	0a000007	 beq         |$LN1@DeleteUsbC|
  00044		 |$LL3@DeleteUsbC|

; 727  :                     delete [] lpEndpoint->lpbExtended;

  00044	e597000c	 ldr         r0, [r7, #0xC]
  00048	eb000000	 bl          |??3@YAXPAX@Z|

; 728  :                     lpEndpoint->lpbExtended = NULL;

  0004c	e587900c	 str         r9, [r7, #0xC]
  00050	e5d53008	 ldrb        r3, [r5, #8]
  00054	e2888001	 add         r8, r8, #1
  00058	e2877014	 add         r7, r7, #0x14
  0005c	e1580003	 cmp         r8, r3
  00060	3afffff7	 bcc         |$LL3@DeleteUsbC|
  00064		 |$LN1@DeleteUsbC|

; 729  :                 }
; 730  :                 delete [] lpInterface->lpEndpoints;

  00064	e5950014	 ldr         r0, [r5, #0x14]
  00068	eb000000	 bl          |??3@YAXPAX@Z|

; 731  :                 lpInterface->lpEndpoints = NULL;

  0006c	e5859014	 str         r9, [r5, #0x14]
  00070		 |$LN4@DeleteUsbC|

; 732  :             }
; 733  :             delete [] lpInterface->lpbExtended;

  00070	e5950010	 ldr         r0, [r5, #0x10]
  00074	eb000000	 bl          |??3@YAXPAX@Z|

; 734  :             lpInterface->lpbExtended = NULL;

  00078	e5859010	 str         r9, [r5, #0x10]
  0007c	e5943014	 ldr         r3, [r4, #0x14]
  00080	e2866001	 add         r6, r6, #1
  00084	e285501c	 add         r5, r5, #0x1C
  00088	e1560003	 cmp         r6, r3
  0008c	3affffe5	 bcc         |$LL7@DeleteUsbC|
  00090		 |$LN5@DeleteUsbC|

; 735  :         }
; 736  :         delete [] rConfig.lpInterfaces;

  00090	e5940018	 ldr         r0, [r4, #0x18]
  00094	eb000000	 bl          |??3@YAXPAX@Z|

; 737  :         rConfig.lpInterfaces = NULL;

  00098	e5849018	 str         r9, [r4, #0x18]
  0009c		 |$LN8@DeleteUsbC|

; 738  :     }
; 739  :     delete [] rConfig.lpbExtended;

  0009c	e5940010	 ldr         r0, [r4, #0x10]
  000a0	eb000000	 bl          |??3@YAXPAX@Z|

; 740  :     rConfig.lpbExtended = NULL;

  000a4	e5849010	 str         r9, [r4, #0x10]

; 741  : 
; 742  :     DEBUGMSG( ZONE_DEVICE && ZONE_VERBOSE, (TEXT("%s: -CDevice::DeleteUsbConfigurationStructure\n"),GetControllerName()));
; 743  : }

  000a8	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000ac	e12fff1e	 bx          lr
  000b0		 |$M37937|

			 ENDP  ; |?DeleteUsbConfigurationStructure@CDevice@@QBAXAAU_NON_CONST_USB_CONFIGURATION@@@Z|, CDevice::DeleteUsbConfigurationStructure

	EXPORT	|?AllocatePipeArray@CDevice@@IAAHXZ|	; CDevice::AllocatePipeArray
	IMPORT	|??2@YAPAXI@Z|				; operator new
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T37961| DCD	|$LN16@AllocatePi|
	DCD	0x40003301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AllocatePipeArray@CDevice@@IAAHXZ| PROC ; CDevice::AllocatePipeArray

; 757  : {

  00000		 |$LN16@AllocatePi|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M37958|
  00004	e1a05000	 mov         r5, r0

; 758  :     DEBUGMSG( ZONE_DEVICE && ZONE_VERBOSE, (TEXT("%s: +CDevice(%s tier %d)::AllocatePipeArray\n"),GetControllerName(), GetDeviceType(), m_tierNumber ) );
; 759  : 
; 760  :     BOOL fSuccess = FALSE;
; 761  : 
; 762  :     EnterCriticalSection( &m_csDeviceLock );

  00008	e285000c	 add         r0, r5, #0xC
  0000c	e3a06000	 mov         r6, #0
  00010	eb000000	 bl          EnterCriticalSection

; 763  : 
; 764  :     DEBUGCHK( m_ppCPipe == NULL && // shouldn't be allocated yet
; 765  :               m_maxNumPipes == 0 && // shouldn't be allocated yet
; 766  :               m_deviceInfo.lpActiveConfig != NULL &&
; 767  :               m_deviceInfo.lpActiveConfig->lpInterfaces != NULL &&
; 768  :               m_deviceInfo.lpActiveConfig->lpInterfaces[0].Descriptor.bNumEndpoints <= 15 );
; 769  : 
; 770  :     // number of endpoints does not include the endpoint 0
; 771  :     int numPipes = 1;
; 772  : 
; 773  :     int bNumberEndpoints = 0;
; 774  :     int bInterfaceNumber = m_deviceInfo.lpActiveConfig->lpInterfaces[0].Descriptor.bInterfaceNumber;

  00014	e5957040	 ldr         r7, [r5, #0x40]
  00018	e3a0e001	 mov         lr, #1
  0001c	e3a02000	 mov         r2, #0
  00020	e5979018	 ldr         r9, [r7, #0x18]

; 775  :     int bCurNumEndpoints;
; 776  :     for(DWORD i = 0; i < m_deviceInfo.lpActiveConfig->dwNumInterfaces; ++i){

  00024	e5973014	 ldr         r3, [r7, #0x14]
  00028	e5d98006	 ldrb        r8, [r9, #6]
  0002c	e3530000	 cmp         r3, #0
  00030	9a000013	 bls         |$LN5@AllocatePi|
  00034	e1a03007	 mov         r3, r7
  00038	e5934014	 ldr         r4, [r3, #0x14]
  0003c	e3a01000	 mov         r1, #0
  00040		 |$LL7@AllocatePi|

; 777  :         if(bInterfaceNumber == m_deviceInfo.lpActiveConfig->lpInterfaces[i].Descriptor.bInterfaceNumber){

  00040	e0810009	 add         r0, r1, r9
  00044	e5d03006	 ldrb        r3, [r0, #6]
  00048	e1580003	 cmp         r8, r3
  0004c	1a000004	 bne         |$LN4@AllocatePi|

; 778  :             bCurNumEndpoints = m_deviceInfo.lpActiveConfig->lpInterfaces[i].Descriptor.bNumEndpoints;

  00050	e5d03008	 ldrb        r3, [r0, #8]

; 779  :             if(bNumberEndpoints < bCurNumEndpoints)

  00054	e1520003	 cmp         r2, r3
  00058	aa000006	 bge         |$LN6@AllocatePi|

; 780  :                 bNumberEndpoints = bCurNumEndpoints;

  0005c	e1a02003	 mov         r2, r3

; 781  :         } else {

  00060	ea000004	 b           |$LN6@AllocatePi|
  00064		 |$LN4@AllocatePi|

; 782  :             bInterfaceNumber = m_deviceInfo.lpActiveConfig->lpInterfaces[i].Descriptor.bInterfaceNumber;

  00064	e5973018	 ldr         r3, [r7, #0x18]

; 783  :             numPipes += bNumberEndpoints;

  00068	e08ee002	 add         lr, lr, r2
  0006c	e0833001	 add         r3, r3, r1
  00070	e5d38006	 ldrb        r8, [r3, #6]

; 784  :             bNumberEndpoints = m_deviceInfo.lpActiveConfig->lpInterfaces[i].Descriptor.bNumEndpoints;

  00074	e5d32008	 ldrb        r2, [r3, #8]
  00078		 |$LN6@AllocatePi|
  00078	e281101c	 add         r1, r1, #0x1C
  0007c	e2544001	 subs        r4, r4, #1
  00080	1affffee	 bne         |$LL7@AllocatePi|
  00084		 |$LN5@AllocatePi|

; 785  :         }
; 786  :     }
; 787  :     numPipes += bNumberEndpoints;

  00084	e08e4002	 add         r4, lr, r2

; 788  : 
; 789  :     DEBUGMSG( ZONE_DEVICE && ZONE_VERBOSE, (TEXT("%s: CDevice(%s tier %d)::AllocatePipeArray - attempting to allocate %d pipes\n"),GetControllerName(), GetDeviceType(), m_tierNumber, numPipes) );
; 790  :     m_ppCPipe = new CPipeAbs* [ numPipes ];

  00088	e3740107	 cmn         r4, #7, 2
  0008c	91a00104	 movls       r0, r4, lsl #2
  00090	83e00000	 mvnhi       r0, #0
  00094	eb000000	 bl          |??2@YAPAXI@Z|
  00098	e3500000	 cmp         r0, #0
  0009c	e585005c	 str         r0, [r5, #0x5C]

; 791  :     if ( m_ppCPipe != NULL ) {

  000a0	0a000004	 beq         |$LN1@AllocatePi|

; 792  :         memset( m_ppCPipe, 0, numPipes * sizeof( CPipeAbs * ) );

  000a4	e1a02104	 mov         r2, r4, lsl #2
  000a8	e3a01000	 mov         r1, #0
  000ac	eb000000	 bl          memset

; 793  :         m_maxNumPipes = (UCHAR)numPipes;

  000b0	e5c54054	 strb        r4, [r5, #0x54]

; 794  :         fSuccess = TRUE;

  000b4	e3a06001	 mov         r6, #1
  000b8		 |$LN1@AllocatePi|

; 795  :     }
; 796  :     DEBUGMSG( ZONE_ERROR && !m_ppCPipe, (TEXT("%s: CDevice(%s tier %d)::AllocatePipeArray - no memory!\n"),GetControllerName(), GetDeviceType(), m_tierNumber ) );
; 797  : 
; 798  :     LeaveCriticalSection( &m_csDeviceLock );

  000b8	e285000c	 add         r0, r5, #0xC
  000bc	eb000000	 bl          LeaveCriticalSection

; 799  : 
; 800  :     DEBUGMSG( ZONE_DEVICE && ZONE_VERBOSE, (TEXT("%s: -CDevice(%s tier %d)::AllocatePipeArray, returning BOOL %d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, fSuccess) );
; 801  :     return fSuccess;
; 802  : }

  000c0	e1a00006	 mov         r0, r6
  000c4	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000c8	e12fff1e	 bx          lr
  000cc		 |$M37959|

			 ENDP  ; |?AllocatePipeArray@CDevice@@IAAHXZ|, CDevice::AllocatePipeArray


  00000			 AREA	 |.pdata|, PDATA
|$T37974| DCD	|$LN6@DisableDev|
	DCD	0x40000e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DisableDevice@CDevice@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z| PROC ; CDevice::DisableDevice

; 1276 : {

  00000		 |$LN6@DisableDev|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37971|
  00004	e1a0e000	 mov         lr, r0

; 1277 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: CHub(%s tier %d)::DisableDevice - address = %d, pipeIndex = %d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, address, fReset) );
; 1278 :     HCD_REQUEST_STATUS status = requestIgnored;
; 1279 :     if (address == m_address ) { // If it is this device

  00008	e5de3020	 ldrb        r3, [lr, #0x20]
  0000c	e3a00002	 mov         r0, #2
  00010	e1510003	 cmp         r1, r3
  00014	1a000005	 bne         |$LN1@DisableDev|

; 1280 :         m_pAttachedHub->DisableOffStreamDevice( address, fReset);

  00018	e59e0004	 ldr         r0, [lr, #4]
  0001c	e5903000	 ldr         r3, [r0]
  00020	e593303c	 ldr         r3, [r3, #0x3C]
  00024	e1a0e00f	 mov         lr, pc
  00028	e12fff13	 bx          r3

; 1281 :         status = requestOK;

  0002c	e3a00001	 mov         r0, #1
  00030		 |$LN1@DisableDev|

; 1282 :     }
; 1283 :     return status;
; 1284 : }

  00030	e49de004	 ldr         lr, [sp], #4
  00034	e12fff1e	 bx          lr
  00038		 |$M37972|

			 ENDP  ; |?DisableDevice@CDevice@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|, CDevice::DisableDevice


  00000			 AREA	 |.pdata|, PDATA
|$T37987| DCD	|$LN8@SuspendRes|
	DCD	0x40001a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SuspendResume@CDevice@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z| PROC ; CDevice::SuspendResume

; 1302 : {

  00000		 |$LN8@SuspendRes|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M37984|
  00004	e1a06002	 mov         r6, r2
  00008	e1a07001	 mov         r7, r1
  0000c	e1a05000	 mov         r5, r0

; 1303 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: +CHub(%s tier %d)::SuspendResume - address = %d, fSuspend = %d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, address, fSuspend) );
; 1304 : 
; 1305 :     HCD_REQUEST_STATUS status = requestIgnored;
; 1306 : 
; 1307 :     EnterCriticalSection( &m_csDeviceLock );

  00010	e285000c	 add         r0, r5, #0xC
  00014	e3a04002	 mov         r4, #2
  00018	eb000000	 bl          EnterCriticalSection

; 1308 :     if ( address == m_address ) {

  0001c	e5d53020	 ldrb        r3, [r5, #0x20]
  00020	e1570003	 cmp         r7, r3
  00024	1a00000a	 bne         |$LN1@SuspendRes|

; 1309 :         if (m_pAttachedHub->SuspendResumeOffStreamDevice(address, fSuspend)) {

  00028	e5950004	 ldr         r0, [r5, #4]
  0002c	e1a02006	 mov         r2, r6
  00030	e1a01007	 mov         r1, r7
  00034	e5903000	 ldr         r3, [r0]
  00038	e5933040	 ldr         r3, [r3, #0x40]
  0003c	e1a0e00f	 mov         lr, pc
  00040	e12fff13	 bx          r3
  00044	e3500000	 cmp         r0, #0

; 1310 :             m_fIsSuspend=fSuspend;
; 1311 :             status = requestOK;

  00048	13a04001	 movne       r4, #1

; 1312 :         }
; 1313 :         else
; 1314 :             status = requestFailed;

  0004c	03a04000	 moveq       r4, #0
  00050	15856058	 strne       r6, [r5, #0x58]
  00054		 |$LN1@SuspendRes|

; 1315 :     }
; 1316 :     LeaveCriticalSection( &m_csDeviceLock );

  00054	e285000c	 add         r0, r5, #0xC
  00058	eb000000	 bl          LeaveCriticalSection

; 1317 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: -CHub(%s tier %d)::SuspendResume - address = %d, returing HCD_REQUEST_STATUS %d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, address, status) );
; 1318 :     return status;
; 1319 : }

  0005c	e1a00004	 mov         r0, r4
  00060	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00064	e12fff1e	 bx          lr
  00068		 |$M37985|

			 ENDP  ; |?SuspendResume@CDevice@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|, CDevice::SuspendResume

	EXPORT	|?GetDescriptor@CHub@@IAAHQAVCPipeAbs@@EEEGPAX@Z| ; CHub::GetDescriptor
	IMPORT	|WaitForSingleObject|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T38019| DCD	|$LN22@GetDescrip|
	DCD	0x40006e02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetDescriptor@CHub@@IAAHQAVCPipeAbs@@EEEGPAX@Z| PROC ; CHub::GetDescriptor

; 2004 : {

  00000		 |$LN22@GetDescrip|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd054	 sub         sp, sp, #0x54
  00008		 |$M38016|
  00008	e1a0b003	 mov         r11, r3
  0000c	e5cd2038	 strb        r2, [sp, #0x38]
  00010	e58d1048	 str         r1, [sp, #0x48]
  00014	e1a09000	 mov         r9, r0
  00018	e3a03c01	 mov         r3, #1, 24

; 2005 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("%s: +CHub(%s tier %d)::GetDescriptor - address = %d, Type = %d, Index = %d, Size = %d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, address, descriptorType, descriptorIndex, wDescriptorSize) );
; 2006 : 
; 2007 :     PREFAST_DEBUGCHK( pControlPipe != NULL );
; 2008 :     PREFAST_DEBUGCHK( pBuffer != NULL );
; 2009 :     DEBUGCHK( m_hHubStatusChangeEvent != NULL );
; 2010 : 
; 2011 :     BOOL                fTransferDone = FALSE;
; 2012 :     DWORD               dwBytesTransferred = 0;
; 2013 :     DWORD               dwErrorFlags = USB_NOT_COMPLETE_ERROR;
; 2014 :     HCD_REQUEST_STATUS  status = requestFailed;
; 2015 :     USB_DEVICE_REQUEST  usbRequest;
; 2016 : 
; 2017 :     if ( descriptorType == USB_HUB_DESCRIPTOR_TYPE ) {

  0001c	e35b0029	 cmp         r11, #0x29
  00020	e3834003	 orr         r4, r3, #3

; 2018 :         DEBUGCHK( descriptorIndex == 0 &&
; 2019 :                   wDescriptorSize >= USB_HUB_DESCRIPTOR_MINIMUM_SIZE );
; 2020 :         usbRequest.bmRequestType = USB_REQUEST_DEVICE_TO_HOST | USB_REQUEST_CLASS | USB_REQUEST_FOR_DEVICE;

  00024	03a030a0	 moveq       r3, #0xA0

; 2021 :     } else {
; 2022 :         DEBUGCHK( (descriptorType == USB_DEVICE_DESCRIPTOR_TYPE && descriptorIndex == 0 && (wDescriptorSize == ENDPOINT_ZERO_MIN_MAXPACKET_SIZE || wDescriptorSize == sizeof( USB_DEVICE_DESCRIPTOR ) ) ) ||
; 2023 :                   (descriptorType == USB_CONFIGURATION_DESCRIPTOR_TYPE && wDescriptorSize >= sizeof( USB_CONFIGURATION_DESCRIPTOR ) ) );
; 2024 :         usbRequest.bmRequestType = USB_REQUEST_DEVICE_TO_HOST | USB_REQUEST_STANDARD | USB_REQUEST_FOR_DEVICE;

  00028	13a03080	 movne       r3, #0x80
  0002c	e5cd304c	 strb        r3, [sp, #0x4C]

; 2025 :     }
; 2026 :     usbRequest.bRequest = USB_REQUEST_GET_DESCRIPTOR;
; 2027 :     usbRequest.wValue = USB_DESCRIPTOR_MAKE_TYPE_AND_INDEX(descriptorType, descriptorIndex);

  00030	e5dd3078	 ldrb        r3, [sp, #0x78]

; 2028 :     usbRequest.wIndex = 0;
; 2029 :     usbRequest.wLength = wDescriptorSize;

  00034	e1dd07bc	 ldrh        r0, [sp, #0x7C]

; 2030 : 
; 2031 :     if ( !m_fHubThreadClosing ) {

  00038	e59920b8	 ldr         r2, [r9, #0xB8]
  0003c	e183340b	 orr         r3, r3, r11, lsl #8
  00040	e3a0e000	 mov         lr, #0
  00044	e3a05000	 mov         r5, #0
  00048	e3a07006	 mov         r7, #6
  0004c	e3a08000	 mov         r8, #0
  00050	e59da080	 ldr         r10, [sp, #0x80]
  00054	e1cd34be	 strh        r3, [sp, #0x4E]
  00058	e58d4044	 str         r4, [sp, #0x44]
  0005c	e58de03c	 str         lr, [sp, #0x3C]
  00060	e58d5040	 str         r5, [sp, #0x40]
  00064	e3a06000	 mov         r6, #0
  00068	e5cd704d	 strb        r7, [sp, #0x4D]
  0006c	e1cd85b0	 strh        r8, [sp, #0x50]
  00070	e1cd05b2	 strh        r0, [sp, #0x52]
  00074	e3520000	 cmp         r2, #0
  00078	1a00003b	 bne         |$LN13@GetDescrip|

; 2032 :         status = pControlPipe->IssueTransfer(
; 2033 :                                  address, // address of device
; 2034 :                                  TransferDoneCallbackSetEvent, // callback routine
; 2035 :                                  m_hHubStatusChangeEvent, // callback param
; 2036 :                                  USB_IN_TRANSFER | USB_SEND_TO_DEVICE, // transfer flags
; 2037 :                                  &usbRequest, // control request
; 2038 :                                  0, // dwStartingFrame (not used)
; 2039 :                                  0, // dwFrames (not used)
; 2040 :                                  NULL, // aLengths (not used)
; 2041 :                                  wDescriptorSize, // buffer size
; 2042 :                                  pBuffer, // buffer
; 2043 :                                  0, // phys addr of buffer (not used)
; 2044 :                                  this, // cancel ID
; 2045 :                                  NULL, // adwIsochErrors (not used)
; 2046 :                                  NULL, // adwIsochLengths (not used)
; 2047 :                                  &fTransferDone, // OUT status param
; 2048 :                                  &dwBytesTransferred, // OUT status param
; 2049 :                                  &dwErrorFlags ); // OUT status param

  0007c	e28d4044	 add         r4, sp, #0x44
  00080	e58d4034	 str         r4, [sp, #0x34]
  00084	e1dd47bc	 ldrh        r4, [sp, #0x7C]
  00088	e5911000	 ldr         r1, [r1]
  0008c	e28d5040	 add         r5, sp, #0x40
  00090	e58d4014	 str         r4, [sp, #0x14]
  00094	e591800c	 ldr         r8, [r1, #0xC]
  00098	e58d5030	 str         r5, [sp, #0x30]
  0009c	e3a04d42	 mov         r4, #0x42, 26
  000a0	e59930bc	 ldr         r3, [r9, #0xBC]
  000a4	e59f2108	 ldr         r2, [pc, #0x108]
  000a8	e28d603c	 add         r6, sp, #0x3C
  000ac	e28d704c	 add         r7, sp, #0x4C
  000b0	e5dd1038	 ldrb        r1, [sp, #0x38]
  000b4	e59d0048	 ldr         r0, [sp, #0x48]
  000b8	e3a05000	 mov         r5, #0
  000bc	e58d4000	 str         r4, [sp]
  000c0	e58d602c	 str         r6, [sp, #0x2C]
  000c4	e58d5028	 str         r5, [sp, #0x28]
  000c8	e58d5024	 str         r5, [sp, #0x24]
  000cc	e58d9020	 str         r9, [sp, #0x20]
  000d0	e58d501c	 str         r5, [sp, #0x1C]
  000d4	e58da018	 str         r10, [sp, #0x18]
  000d8	e58d5010	 str         r5, [sp, #0x10]
  000dc	e58d500c	 str         r5, [sp, #0xC]
  000e0	e58d5008	 str         r5, [sp, #8]
  000e4	e58d7004	 str         r7, [sp, #4]
  000e8	e1a0e00f	 mov         lr, pc
  000ec	e12fff18	 bx          r8
  000f0	e1a06000	 mov         r6, r0

; 2050 : 
; 2051 :         if ( status == requestOK ) {

  000f4	e3560001	 cmp         r6, #1
  000f8	1a000017	 bne         |$LN17@GetDescrip|

; 2052 :             DWORD dwResult = WaitForSingleObject( m_hHubStatusChangeEvent, STANDARD_REQUEST_TIMEOUT );

  000fc	e59900bc	 ldr         r0, [r9, #0xBC]
  00100	e3a01f7d	 mov         r1, #0x7D, 30
  00104	eb000000	 bl          WaitForSingleObject

; 2053 :             if (!fTransferDone || dwResult!= WAIT_OBJECT_0) {

  00108	e59de03c	 ldr         lr, [sp, #0x3C]
  0010c	e35e0000	 cmp         lr, #0
  00110	0a000001	 beq         |$LN3@GetDescrip|
  00114	e3500000	 cmp         r0, #0

; 2058 :                     ResetEvent(m_hHubStatusChangeEvent);

  00118	0a000010	 beq         |$LN19@GetDescrip|
  0011c		 |$LN3@GetDescrip|

; 2054 :                 pControlPipe->AbortTransfer( NULL, // callback function
; 2055 :                                              NULL, // callback parameter
; 2056 :                                              this ); // cancel ID

  0011c	e59d0048	 ldr         r0, [sp, #0x48]
  00120	e1a03009	 mov         r3, r9
  00124	e3a02000	 mov         r2, #0
  00128	e5901000	 ldr         r1, [r0]
  0012c	e5914010	 ldr         r4, [r1, #0x10]
  00130	e3a01000	 mov         r1, #0
  00134	e1a0e00f	 mov         lr, pc
  00138	e12fff14	 bx          r4

; 2057 :                 if ( !m_fHubThreadClosing && m_hHubStatusChangeEvent!=NULL ) {

  0013c	e59930b8	 ldr         r3, [r9, #0xB8]
  00140	e3530000	 cmp         r3, #0
  00144	1a000004	 bne         |$LN17@GetDescrip|
  00148	e59930bc	 ldr         r3, [r9, #0xBC]
  0014c	e3530000	 cmp         r3, #0

; 2058 :                     ResetEvent(m_hHubStatusChangeEvent);

  00150	13a01002	 movne       r1, #2
  00154	11a00003	 movne       r0, r3
  00158	1b000000	 blne        EventModify
  0015c		 |$LN17@GetDescrip|
  0015c	e59de03c	 ldr         lr, [sp, #0x3C]
  00160		 |$LN19@GetDescrip|
  00160	e1dd07bc	 ldrh        r0, [sp, #0x7C]
  00164	e59d4044	 ldr         r4, [sp, #0x44]
  00168	e59d5040	 ldr         r5, [sp, #0x40]
  0016c		 |$LN13@GetDescrip|

; 2059 :                 }
; 2060 :             }
; 2061 :         }
; 2062 :         DEBUGCHK( fTransferDone );
; 2063 :     }
; 2064 : 
; 2065 : #ifndef USB_STRICT_ENFORCEMENT
; 2066 :     // Some IHVs have lazy firmware writers who didn't bother to set the
; 2067 :     // descriptor type field in all of their descriptors. Sigh.
; 2068 :     if ( PUSB_COMMON_DESCRIPTOR(pBuffer)->bDescriptorType == 0 ) {

  0016c	e5da3001	 ldrb        r3, [r10, #1]
  00170	e3530000	 cmp         r3, #0

; 2069 :         DEBUGMSG(ZONE_WARNING, (TEXT("CHub::GetDescriptor - forcing descr type 0x%x to 0x%x\n"), PUSB_COMMON_DESCRIPTOR(pBuffer)->bDescriptorType, descriptorType));
; 2070 :         PUSB_COMMON_DESCRIPTOR(pBuffer)->bDescriptorType = descriptorType;

  00174	05cab001	 streqb      r11, [r10, #1]

; 2071 :     }
; 2072 : #endif
; 2073 : 
; 2074 :     BOOL fSuccess = (status == requestOK &&
; 2075 :                     fTransferDone &&
; 2076 :                     dwBytesTransferred == wDescriptorSize &&
; 2077 :                     dwErrorFlags == USB_NO_ERROR &&
; 2078 :                     PUSB_COMMON_DESCRIPTOR(pBuffer)->bDescriptorType == descriptorType);

  00178	e3560001	 cmp         r6, #1
  0017c	1a000008	 bne         |$LN11@GetDescrip|
  00180	e35e0000	 cmp         lr, #0
  00184	0a000006	 beq         |$LN11@GetDescrip|
  00188	e1550000	 cmp         r5, r0
  0018c	1a000004	 bne         |$LN11@GetDescrip|
  00190	e3540000	 cmp         r4, #0
  00194	05da3001	 ldreqb      r3, [r10, #1]
  00198	0153000b	 cmpeq       r3, r11
  0019c	03a00001	 moveq       r0, #1
  001a0	0a000000	 beq         |$LN12@GetDescrip|
  001a4		 |$LN11@GetDescrip|
  001a4	e3a00000	 mov         r0, #0
  001a8		 |$LN12@GetDescrip|

; 2079 :     // note, don't check length since some descriptors can be variable
; 2080 :     // length (i.e. configuration descriptor bLength field will read
; 2081 :     // sizeof( USB_CONFIGURATION_DESCRIPTOR ), but we may have requested
; 2082 :     // more than this. Or, we may only have requested USB_HUB_DESCRIPTOR_MINIMUM_SIZE
; 2083 :     // but the hub descriptor can be longer.
; 2084 : 
; 2085 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("%s: -CHub(%s tier %d)::GetDescriptor - address = %d, Type = %d, Index = %d, Size = %d, returning %d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, address, descriptorType, descriptorIndex, wDescriptorSize, fSuccess) );
; 2086 :     return fSuccess;
; 2087 : }

  001a8	e28dd054	 add         sp, sp, #0x54
  001ac	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001b0	e12fff1e	 bx          lr
  001b4		 |$LN23@GetDescrip|
  001b4		 |$LN24@GetDescrip|
  001b4	00000000	 DCD         |?TransferDoneCallbackSetEvent@CDevice@@KAKPAX@Z|
  001b8		 |$M38017|

			 ENDP  ; |?GetDescriptor@CHub@@IAAHQAVCPipeAbs@@EEEGPAX@Z|, CHub::GetDescriptor

	EXPORT	|?DetachDownstreamDeviceThread@CHub@@IAAKXZ| ; CHub::DetachDownstreamDeviceThread
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T38044| DCD	|$LN11@DetachDown|
	DCD	0x40001901
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DetachDownstreamDeviceThread@CHub@@IAAKXZ| PROC ; CHub::DetachDownstreamDeviceThread

; 2112 : {

  00000		 |$LN11@DetachDown|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M38041|
  00004	e1a05000	 mov         r5, r0

; 2113 :     DEBUGMSG( ZONE_ATTACH, (TEXT("%s: +CHub::DetachDownstreamDeviceThread\n"),GetControllerName()) );
; 2114 : 
; 2115 :     CDevice* pDeviceToDetach = m_pDetachedDevice;//(CDevice*) context;
; 2116 :     m_pDetachedDevice=NULL;
; 2117 :     SetEvent(m_pDetachedDeviceHandled);

  00008	e5950064	 ldr         r0, [r5, #0x64]
  0000c	e5954060	 ldr         r4, [r5, #0x60]
  00010	e3a03000	 mov         r3, #0
  00014	e3a01003	 mov         r1, #3
  00018	e5853060	 str         r3, [r5, #0x60]
  0001c	eb000000	 bl          EventModify

; 2118 :     PREFAST_DEBUGCHK( pDeviceToDetach != NULL );
; 2119 : 
; 2120 :     pDeviceToDetach->HandleDetach();

  00020	e5943000	 ldr         r3, [r4]
  00024	e1a00004	 mov         r0, r4
  00028	e5933030	 ldr         r3, [r3, #0x30]
  0002c	e1a0e00f	 mov         lr, pc
  00030	e12fff13	 bx          r3

; 2121 :     delete pDeviceToDetach;

  00034	e5943000	 ldr         r3, [r4]
  00038	e3a01001	 mov         r1, #1
  0003c	e1a00004	 mov         r0, r4
  00040	e5933000	 ldr         r3, [r3]
  00044	e1a0e00f	 mov         lr, pc
  00048	e12fff13	 bx          r3

; 2122 : 
; 2123 :     //DecrCountdown(&m_objCountdown);
; 2124 :     m_pDeviceGlobal->ObjCountdownDec();

  0004c	e5953050	 ldr         r3, [r5, #0x50]
  00050	e2830054	 add         r0, r3, #0x54
  00054	eb000000	 bl          |?DecrCountdown@Countdown@@QAAXXZ|

; 2125 : 
; 2126 :     DEBUGMSG( ZONE_ATTACH, (TEXT("%s: -CHub::DetachDownstreamDeviceThread\n"),GetControllerName()) );
; 2127 : 
; 2128 :     return 0;

  00058	e3a00000	 mov         r0, #0

; 2129 : }

  0005c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$M38042|

			 ENDP  ; |?DetachDownstreamDeviceThread@CHub@@IAAKXZ|, CHub::DetachDownstreamDeviceThread

	EXPORT	|?AllocateDeviceArray@CHub@@IAAHXZ|	; CHub::AllocateDeviceArray

  00000			 AREA	 |.pdata|, PDATA
|$T38060| DCD	|$LN11@AllocateDe|
	DCD	0x40002801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AllocateDeviceArray@CHub@@IAAHXZ| PROC ; CHub::AllocateDeviceArray

; 2220 : {

  00000		 |$LN11@AllocateDe|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M38057|
  00004	e1a04000	 mov         r4, r0

; 2221 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: +CHub(%s tier %d)::AllocateDeviceArray\n"),GetControllerName(), GetDeviceType(), m_tierNumber) );
; 2222 : 
; 2223 :     BOOL fSuccess = FALSE;
; 2224 : 
; 2225 :     EnterCriticalSection( &m_csDeviceLock  );

  00008	e284000c	 add         r0, r4, #0xC
  0000c	e3a05000	 mov         r5, #0
  00010	eb000000	 bl          EnterCriticalSection

; 2226 : 
; 2227 :     DEBUGCHK( m_ppCDeviceOnPort == NULL &&
; 2228 :               m_usbHubDescriptor.bNumberOfPorts > 0 );
; 2229 : 
; 2230 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: CHub(%s tier %d)::AllocateDeviceArray - attempting to allocate %d devices\n"),GetControllerName(), GetDeviceType(), m_tierNumber, m_usbHubDescriptor.bNumberOfPorts ) );
; 2231 :     m_ppCDeviceOnPort = new CDevice* [ m_usbHubDescriptor.bNumberOfPorts ];

  00014	e5d4306a	 ldrb        r3, [r4, #0x6A]
  00018	e1a00103	 mov         r0, r3, lsl #2
  0001c	eb000000	 bl          |??2@YAPAXI@Z|

; 2232 :     m_pAddedTT = new BOOL [m_usbHubDescriptor.bNumberOfPorts ];

  00020	e5d4306a	 ldrb        r3, [r4, #0x6A]
  00024	e58400b0	 str         r0, [r4, #0xB0]
  00028	e1a00103	 mov         r0, r3, lsl #2
  0002c	eb000000	 bl          |??2@YAPAXI@Z|

; 2233 :     if ( m_ppCDeviceOnPort != NULL && m_pAddedTT!=NULL ) {

  00030	e59430b0	 ldr         r3, [r4, #0xB0]
  00034	e58400b4	 str         r0, [r4, #0xB4]
  00038	e1b02003	 movs        r2, r3
  0003c	0a000012	 beq         |$LN4@AllocateDe|
  00040	e3500000	 cmp         r0, #0
  00044	0a000010	 beq         |$LN4@AllocateDe|

; 2234 :         memset( m_ppCDeviceOnPort, 0, m_usbHubDescriptor.bNumberOfPorts * sizeof( CDevice* ) );

  00048	e5d4306a	 ldrb        r3, [r4, #0x6A]
  0004c	e1a00002	 mov         r0, r2
  00050	e3a01000	 mov         r1, #0
  00054	e1a02103	 mov         r2, r3, lsl #2
  00058	eb000000	 bl          memset

; 2235 :         for (DWORD dwIndex=0;dwIndex<m_usbHubDescriptor.bNumberOfPorts; dwIndex++)

  0005c	e5d4306a	 ldrb        r3, [r4, #0x6A]
  00060	e3a02000	 mov         r2, #0
  00064	e3530000	 cmp         r3, #0
  00068	0a000006	 beq         |$LN1@AllocateDe|
  0006c	e3a01000	 mov         r1, #0
  00070		 |$LL3@AllocateDe|

; 2236 :             m_pAddedTT[dwIndex] = NULL;

  00070	e59430b4	 ldr         r3, [r4, #0xB4]
  00074	e7831102	 str         r1, [r3, +r2, lsl #2]
  00078	e5d4306a	 ldrb        r3, [r4, #0x6A]
  0007c	e2822001	 add         r2, r2, #1
  00080	e1520003	 cmp         r2, r3
  00084	3afffff9	 bcc         |$LL3@AllocateDe|
  00088		 |$LN1@AllocateDe|

; 2237 :         fSuccess = TRUE;

  00088	e3a05001	 mov         r5, #1
  0008c		 |$LN4@AllocateDe|

; 2238 :     }
; 2239 :     DEBUGMSG( ZONE_HUB && ZONE_ERROR && !m_ppCDeviceOnPort, (TEXT("%s: CHub(%s tier %d)::AllocateDeviceArray - no memory!\n"),GetControllerName(), GetDeviceType(), m_tierNumber ) );
; 2240 : 
; 2241 :     LeaveCriticalSection( &m_csDeviceLock );

  0008c	e284000c	 add         r0, r4, #0xC
  00090	eb000000	 bl          LeaveCriticalSection

; 2242 : 
; 2243 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: -CHub(%s tier %d)::AllocateDeviceArray, returning BOOL %d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, fSuccess) );
; 2244 :     return fSuccess;
; 2245 : }

  00094	e1a00005	 mov         r0, r5
  00098	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$M38058|

			 ENDP  ; |?AllocateDeviceArray@CHub@@IAAHXZ|, CHub::AllocateDeviceArray

	EXPORT	|?HandleDetach@CHub@@UAAXXZ|		; CHub::HandleDetach
	IMPORT	|CloseHandle|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T38112| DCD	|$LN46@HandleDeta|
	DCD	0x40005d01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HandleDetach@CHub@@UAAXXZ| PROC	; CHub::HandleDetach

; 2258 : {

  00000		 |$LN46@HandleDeta|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M38109|
  00004	e1a04000	 mov         r4, r0

; 2259 :     DEBUGMSG( ZONE_HUB || ZONE_ATTACH, (TEXT("%s: +CHub(%s tier %d)::HandleDetach\n"),GetControllerName(), GetDeviceType(), m_tierNumber) );
; 2260 : 
; 2261 :     // close our hub thread
; 2262 :     DEBUGCHK( m_hHubStatusChangeEvent && m_hHubStatusChangeThread );
; 2263 :     // tell the thread to abort port status change processing.
; 2264 :     // ***DO NOT*** enter m_csDeviceLock here, otherwise we will
; 2265 :     // block the thread trying to close
; 2266 :     m_fHubThreadClosing = TRUE;
; 2267 :     SetEvent( m_hHubStatusChangeEvent );

  00008	e59400bc	 ldr         r0, [r4, #0xBC]
  0000c	e3a03001	 mov         r3, #1
  00010	e3a01003	 mov         r1, #3
  00014	e58430b8	 str         r3, [r4, #0xB8]
  00018	eb000000	 bl          EventModify

; 2268 :     SetEvent( m_hHubSuspendBlockEvent );

  0001c	e59400c4	 ldr         r0, [r4, #0xC4]
  00020	e3a01003	 mov         r1, #3
  00024	eb000000	 bl          EventModify

; 2269 : 
; 2270 :     // If we are the root hub then this is a total shutdown rather than a detach,
; 2271 :     // so we force anybody in the middle of address assignment to give up.
; 2272 :     if (m_tierNumber == 0)

  00028	e5d4304c	 ldrb        r3, [r4, #0x4C]
  0002c	e3530000	 cmp         r3, #0

; 2273 :         //PrepareDeleteCritSec_Ex( &m_csAddress0Lock );
; 2274 :         m_pDeviceGlobal->Addr0LockPrepareDelete();

  00030	05943050	 ldreq       r3, [r4, #0x50]
  00034	0283002c	 addeq       r0, r3, #0x2C
  00038	0b000000	 bleq        |?PrepareDeleteCritSec_Ex@CritSec_Ex@@QAAXXZ|
  0003c		 |$LL10@HandleDeta|

; 2275 : 
; 2276 :     // In the case where the hub was detached right when a new function was
; 2277 :     // being attached on one of its ports, the hub thread can be at
; 2278 :     // AttachDevice - DEVICE_CONFIG_STATUS_SIGNAL_NEW_DEVICE_ENTER_OPERATIONAL_STATE.
; 2279 :     // At this point, the thread is somewhere in USBD.DLL, and not in UHCI.DLL, and we
; 2280 :     // need to wait until USBD is finished. USBD can have a dialog up asking the
; 2281 :     // user for the driver's DLL name. So, we don't want to just blindly call
; 2282 :     // TerminateThread if the wait fails.
; 2283 :     DWORD dwWaitReturn = WAIT_FAILED;
; 2284 : #ifdef DEBUG
; 2285 :     DWORD dwTickCountStart = GetTickCount();
; 2286 : #endif // DEBUG
; 2287 :     do {
; 2288 :         dwWaitReturn = WaitForSingleObject( m_hHubStatusChangeThread, 1000 );

  0003c	e59400c0	 ldr         r0, [r4, #0xC0]
  00040	e3a01ffa	 mov         r1, #0xFA, 30
  00044	eb000000	 bl          WaitForSingleObject
  00048	e3500000	 cmp         r0, #0

; 2289 :         DEBUGMSG( ZONE_WARNING && dwWaitReturn != WAIT_OBJECT_0, (TEXT("%s: CHub(%s tier %d)::HandleDetach - hub thread blocked - could be waiting for user input\n"),GetControllerName(), GetDeviceType(), m_tierNumber) );
; 2290 :     } while ( dwWaitReturn != WAIT_OBJECT_0 );

  0004c	1afffffa	 bne         |$LL10@HandleDeta|

; 2291 :     DEBUGMSG( ZONE_ATTACH, (TEXT("%s: CHub(%s tier %d)::HandleDetach - status change thread closed in %d ms\n"),GetControllerName(), GetDeviceType(), m_tierNumber, GetTickCount() - dwTickCountStart ) );
; 2292 : 
; 2293 :     EnterCriticalSection( &m_csDeviceLock );

  00050	e284000c	 add         r0, r4, #0xC
  00054	eb000000	 bl          EnterCriticalSection

; 2294 : 
; 2295 : #ifdef DEBUG
; 2296 :     if ( m_address == 0 ) {
; 2297 :         // root hub - no pipes
; 2298 :         DEBUGCHK( m_ppCPipe == NULL &&
; 2299 :                   m_maxNumPipes == 0 );
; 2300 :     } else {
; 2301 :         // external hub - should have two pipes
; 2302 :         DEBUGCHK( m_ppCPipe != NULL &&
; 2303 :                   m_maxNumPipes == 2 &&
; 2304 :                   m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ] != NULL &&
; 2305 :                   m_ppCPipe[ STATUS_CHANGE_INTERRUPT_PIPE ] != NULL );
; 2306 :     }
; 2307 : #endif // DEBUG
; 2308 :     for ( UCHAR pipe = 0; m_ppCPipe!=NULL && pipe < m_maxNumPipes; pipe++ ) {

  00058	e3a05000	 mov         r5, #0
  0005c	e3a07000	 mov         r7, #0
  00060	ea000015	 b           |$LN43@HandleDeta|
  00064		 |$LL7@HandleDeta|
  00064	e5d43054	 ldrb        r3, [r4, #0x54]
  00068	e1550003	 cmp         r5, r3
  0006c	2a000015	 bcs         |$LN41@HandleDeta|

; 2309 :         m_ppCPipe[ pipe ]->ClosePipe();

  00070	e594305c	 ldr         r3, [r4, #0x5C]
  00074	e1a06105	 mov         r6, r5, lsl #2
  00078	e7960003	 ldr         r0, [r6, +r3]
  0007c	e5903000	 ldr         r3, [r0]
  00080	e5933008	 ldr         r3, [r3, #8]
  00084	e1a0e00f	 mov         lr, pc
  00088	e12fff13	 bx          r3

; 2310 :         delete m_ppCPipe[ pipe ];

  0008c	e594305c	 ldr         r3, [r4, #0x5C]
  00090	e7963003	 ldr         r3, [r6, +r3]
  00094	e1b00003	 movs        r0, r3
  00098	15903000	 ldrne       r3, [r0]
  0009c	13a01001	 movne       r1, #1
  000a0	15933000	 ldrne       r3, [r3]
  000a4	11a0e00f	 movne       lr, pc
  000a8	112fff13	 bxne        r3

; 2311 :         m_ppCPipe[ pipe ] = NULL;

  000ac	e594205c	 ldr         r2, [r4, #0x5C]
  000b0	e2853001	 add         r3, r5, #1
  000b4	e20350ff	 and         r5, r3, #0xFF
  000b8	e7867002	 str         r7, [r6, +r2]
  000bc		 |$LN43@HandleDeta|
  000bc	e594305c	 ldr         r3, [r4, #0x5C]
  000c0	e3530000	 cmp         r3, #0
  000c4	1affffe6	 bne         |$LL7@HandleDeta|
  000c8		 |$LN41@HandleDeta|

; 2312 :     }
; 2313 :     // m_ppCPipe[] will be freed in ~CDevice
; 2314 : 
; 2315 :     // if m_ppCDeviceOnPort was not allocated ok, EnterOperationalState
; 2316 :     // would have failed, and we should never be at HandleDetach stage.
; 2317 :     PREFAST_DEBUGCHK( m_ppCDeviceOnPort != NULL );
; 2318 :     // we need to detach all the devices on our ports
; 2319 :     for ( UCHAR port = 1; port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  000c8	e5d4306a	 ldrb        r3, [r4, #0x6A]
  000cc	e3a05001	 mov         r5, #1
  000d0	e3530001	 cmp         r3, #1
  000d4	3a00001c	 bcc         |$LN2@HandleDeta|
  000d8	e3a06001	 mov         r6, #1
  000dc		 |$LL4@HandleDeta|

; 2320 :         // Don't call DetachDevice, because that function is intended for
; 2321 :         // when this hub is active. It has the extra overhead of spinning off
; 2322 :         // a thread to do the detach work. Instead, just call the HandleDetach
; 2323 :         // procedure directly
; 2324 :         if ( m_ppCDeviceOnPort[ port - 1 ] != NULL ) {

  000dc	e59430b0	 ldr         r3, [r4, #0xB0]
  000e0	e0832105	 add         r2, r3, r5, lsl #2
  000e4	e5123004	 ldr         r3, [r2, #-4]
  000e8	e3530000	 cmp         r3, #0
  000ec	0a000010	 beq         |$LN3@HandleDeta|

; 2325 :             m_ppCDeviceOnPort[ port - 1 ]->HandleDetach();

  000f0	e1a00003	 mov         r0, r3
  000f4	e5903000	 ldr         r3, [r0]
  000f8	e5933030	 ldr         r3, [r3, #0x30]
  000fc	e1a0e00f	 mov         lr, pc
  00100	e12fff13	 bx          r3

; 2326 :             delete m_ppCDeviceOnPort[ port - 1 ];

  00104	e59430b0	 ldr         r3, [r4, #0xB0]
  00108	e0833105	 add         r3, r3, r5, lsl #2
  0010c	e5133004	 ldr         r3, [r3, #-4]
  00110	e1b00003	 movs        r0, r3
  00114	15903000	 ldrne       r3, [r0]
  00118	13a01001	 movne       r1, #1
  0011c	15933000	 ldrne       r3, [r3]
  00120	11a0e00f	 movne       lr, pc
  00124	112fff13	 bxne        r3

; 2327 :             m_ppCDeviceOnPort[ port - 1 ] = NULL;

  00128	e59430b0	 ldr         r3, [r4, #0xB0]
  0012c	e0833105	 add         r3, r3, r5, lsl #2
  00130	e5037004	 str         r7, [r3, #-4]
  00134		 |$LN3@HandleDeta|
  00134	e5d4206a	 ldrb        r2, [r4, #0x6A]
  00138	e2863001	 add         r3, r6, #1
  0013c	e20350ff	 and         r5, r3, #0xFF
  00140	e1a06005	 mov         r6, r5
  00144	e1550002	 cmp         r5, r2
  00148	9affffe3	 bls         |$LL4@HandleDeta|
  0014c		 |$LN2@HandleDeta|

; 2328 :         }
; 2329 :     }
; 2330 :     // m_ppCDeviceOnPort[] will be freed in ~CHub
; 2331 : 
; 2332 :     // Now that all pipes are closed, we can close our thread/event handles.
; 2333 :     // If we did this earlier, we would risk having a callback from an
; 2334 :     // active pipe, and having TransferDoneCallbackSetEvent accidentally
; 2335 :     // set a dead m_hHubStatusChangeEvent
; 2336 :     CloseHandle( m_hHubStatusChangeThread );

  0014c	e59400c0	 ldr         r0, [r4, #0xC0]
  00150	eb000000	 bl          CloseHandle

; 2337 :     m_hHubStatusChangeThread = NULL;
; 2338 : 
; 2339 :     CloseHandle( m_hHubStatusChangeEvent );

  00154	e59400bc	 ldr         r0, [r4, #0xBC]
  00158	e58470c0	 str         r7, [r4, #0xC0]
  0015c	eb000000	 bl          CloseHandle

; 2340 :     m_hHubStatusChangeEvent = NULL;
; 2341 : 
; 2342 :     LeaveCriticalSection( &m_csDeviceLock );

  00160	e284000c	 add         r0, r4, #0xC
  00164	e58470bc	 str         r7, [r4, #0xBC]
  00168	eb000000	 bl          LeaveCriticalSection

; 2343 : 
; 2344 :     DEBUGMSG( ZONE_HUB || ZONE_ATTACH, (TEXT("%s: -CHub(%s tier %d)::HandleDetach\n"),GetControllerName(), GetDeviceType(), m_tierNumber ) );
; 2345 : }

  0016c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00170	e12fff1e	 bx          lr
  00174		 |$M38110|

			 ENDP  ; |?HandleDetach@CHub@@UAAXXZ|, CHub::HandleDetach

	EXPORT	|?OpenPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IQBU_USB_ENDPOINT_DESCRIPTOR@@QAI@Z| ; CHub::OpenPipe

  00000			 AREA	 |.pdata|, PDATA
|$T38129| DCD	|$LN11@OpenPipe|
	DCD	0x40002501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OpenPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IQBU_USB_ENDPOINT_DESCRIPTOR@@QAI@Z| PROC ; CHub::OpenPipe

; 2369 : {

  00000		 |$LN11@OpenPipe|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M38126|
  00004	e1a07003	 mov         r7, r3
  00008	e1a08002	 mov         r8, r2
  0000c	e1a09001	 mov         r9, r1
  00010	e1a05000	 mov         r5, r0

; 2370 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: +CHub(%s tier %d)::OpenPipe - address = %d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, address) );
; 2371 : 
; 2372 :     HCD_REQUEST_STATUS status = requestIgnored;
; 2373 : 
; 2374 :     EnterCriticalSection( &m_csDeviceLock );

  00014	e285000c	 add         r0, r5, #0xC
  00018	e3a04002	 mov         r4, #2
  0001c	eb000000	 bl          EnterCriticalSection

; 2375 : 
; 2376 :     // no one should be calling OpenPipe on hubs, since we handle
; 2377 :     // hubs internally.
; 2378 :     DEBUGCHK( address != m_address );
; 2379 : 
; 2380 :     PREFAST_DEBUGCHK( m_ppCDeviceOnPort != NULL );
; 2381 :     for ( UCHAR port = 1; status == requestIgnored && port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  00020	e3a06001	 mov         r6, #1
  00024		 |$LL4@OpenPipe|
  00024	e5d5e06a	 ldrb        lr, [r5, #0x6A]
  00028	e156000e	 cmp         r6, lr
  0002c	8a000013	 bhi         |$LN2@OpenPipe|

; 2382 :         if ( m_ppCDeviceOnPort[ port - 1 ] != NULL ) {

  00030	e595e0b0	 ldr         lr, [r5, #0xB0]
  00034	e08ee106	 add         lr, lr, r6, lsl #2
  00038	e51ee004	 ldr         lr, [lr, #-4]
  0003c	e35e0000	 cmp         lr, #0
  00040	0a00000a	 beq         |$LN3@OpenPipe|

; 2383 :             status = m_ppCDeviceOnPort[ port - 1 ]->OpenPipe( address,
; 2384 :                                                               lpEndpointDescriptor,
; 2385 :                                                               lpiEndpointIndex );

  00044	e595e0b0	 ldr         lr, [r5, #0xB0]
  00048	e1a03007	 mov         r3, r7
  0004c	e1a02008	 mov         r2, r8
  00050	e08e1106	 add         r1, lr, r6, lsl #2
  00054	e5110004	 ldr         r0, [r1, #-4]
  00058	e1a01009	 mov         r1, r9
  0005c	e5904000	 ldr         r4, [r0]
  00060	e5944008	 ldr         r4, [r4, #8]
  00064	e1a0e00f	 mov         lr, pc
  00068	e12fff14	 bx          r4
  0006c	e1a04000	 mov         r4, r0
  00070		 |$LN3@OpenPipe|
  00070	e2863001	 add         r3, r6, #1
  00074	e20360ff	 and         r6, r3, #0xFF
  00078	e3540002	 cmp         r4, #2
  0007c	0affffe8	 beq         |$LL4@OpenPipe|
  00080		 |$LN2@OpenPipe|

; 2386 :         }
; 2387 :     }
; 2388 : 
; 2389 :     LeaveCriticalSection( &m_csDeviceLock );

  00080	e285000c	 add         r0, r5, #0xC
  00084	eb000000	 bl          LeaveCriticalSection

; 2390 : 
; 2391 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CHub(%s tier %d)::OpenPipe - address = %d, returing HCD_REQUEST_STATUS %d\n"), GetDeviceType(), m_tierNumber, address, status) );
; 2392 :     return status;
; 2393 : }

  00088	e1a00004	 mov         r0, r4
  0008c	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$M38127|

			 ENDP  ; |?OpenPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IQBU_USB_ENDPOINT_DESCRIPTOR@@QAI@Z|, CHub::OpenPipe

	EXPORT	|?ClosePipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z| ; CHub::ClosePipe

  00000			 AREA	 |.pdata|, PDATA
|$T38145| DCD	|$LN11@ClosePipe|
	DCD	0x40002301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ClosePipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z| PROC ; CHub::ClosePipe

; 2411 : {

  00000		 |$LN11@ClosePipe|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M38142|
  00004	e1a07002	 mov         r7, r2
  00008	e1a08001	 mov         r8, r1
  0000c	e1a04000	 mov         r4, r0

; 2412 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CHub(%s tier %d)::ClosePipe - address = %d, pipeIndex = %d\n"), GetDeviceType(), m_tierNumber, address, pipeIndex) );
; 2413 : 
; 2414 :     HCD_REQUEST_STATUS status = requestIgnored;
; 2415 : 
; 2416 :     EnterCriticalSection( &m_csDeviceLock );

  00010	e284000c	 add         r0, r4, #0xC
  00014	e3a06002	 mov         r6, #2
  00018	eb000000	 bl          EnterCriticalSection

; 2417 : 
; 2418 :     // no one should be calling ClosePipe on hubs, since we handle
; 2419 :     // hubs internally.
; 2420 :     DEBUGCHK( address != m_address );
; 2421 : 
; 2422 :     PREFAST_DEBUGCHK( m_ppCDeviceOnPort != NULL );
; 2423 :     for ( UCHAR port = 1; status == requestIgnored && port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  0001c	e3a05001	 mov         r5, #1
  00020		 |$LL4@ClosePipe|
  00020	e5d4306a	 ldrb        r3, [r4, #0x6A]
  00024	e1550003	 cmp         r5, r3
  00028	8a000012	 bhi         |$LN2@ClosePipe|

; 2424 :         if ( m_ppCDeviceOnPort[ port - 1 ] != NULL ) {

  0002c	e59430b0	 ldr         r3, [r4, #0xB0]
  00030	e0833105	 add         r3, r3, r5, lsl #2
  00034	e5133004	 ldr         r3, [r3, #-4]
  00038	e3530000	 cmp         r3, #0
  0003c	0a000009	 beq         |$LN3@ClosePipe|

; 2425 :             status = m_ppCDeviceOnPort[ port - 1 ]->ClosePipe( address,
; 2426 :                                                                pipeIndex );

  00040	e59430b0	 ldr         r3, [r4, #0xB0]
  00044	e1a02007	 mov         r2, r7
  00048	e1a01008	 mov         r1, r8
  0004c	e0833105	 add         r3, r3, r5, lsl #2
  00050	e5130004	 ldr         r0, [r3, #-4]
  00054	e5903000	 ldr         r3, [r0]
  00058	e593300c	 ldr         r3, [r3, #0xC]
  0005c	e1a0e00f	 mov         lr, pc
  00060	e12fff13	 bx          r3
  00064	e1a06000	 mov         r6, r0
  00068		 |$LN3@ClosePipe|
  00068	e2853001	 add         r3, r5, #1
  0006c	e20350ff	 and         r5, r3, #0xFF
  00070	e3560002	 cmp         r6, #2
  00074	0affffe9	 beq         |$LL4@ClosePipe|
  00078		 |$LN2@ClosePipe|

; 2427 :         }
; 2428 :     }
; 2429 : 
; 2430 :     LeaveCriticalSection( &m_csDeviceLock );

  00078	e284000c	 add         r0, r4, #0xC
  0007c	eb000000	 bl          LeaveCriticalSection

; 2431 : 
; 2432 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: -CHub(%s tier %d)::ClosePipe - address = %d, pipeIndex = %d, returing HCD_REQUEST_STATUS %d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, address, pipeIndex, status) );
; 2433 :     return status;
; 2434 : }

  00080	e1a00006	 mov         r0, r6
  00084	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$M38143|

			 ENDP  ; |?ClosePipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|, CHub::ClosePipe

	EXPORT	|?IssueTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z| ; CHub::IssueTransfer

  00000			 AREA	 |.pdata|, PDATA
|$T38177| DCD	|$LN11@IssueTrans|
	DCD	0x40004602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IssueTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z| PROC ; CHub::IssueTransfer

; 2471 : {

  00000		 |$LN11@IssueTrans|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd03c	 sub         sp, sp, #0x3C
  00008		 |$M38174|
  00008	e1a07003	 mov         r7, r3
  0000c	e1a08002	 mov         r8, r2
  00010	e1a09001	 mov         r9, r1
  00014	e1a05000	 mov         r5, r0

; 2472 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CHub(%s tier %d)::IssueTransfer, address = %d, pipe = %d\n"), GetDeviceType(), m_tierNumber, address, pipeIndex));
; 2473 : 
; 2474 :     HCD_REQUEST_STATUS status = requestIgnored;
; 2475 : 
; 2476 :     EnterCriticalSection( &m_csDeviceLock );

  00018	e285000c	 add         r0, r5, #0xC
  0001c	e3a04002	 mov         r4, #2
  00020	eb000000	 bl          EnterCriticalSection

; 2477 : 
; 2478 :     // no one should be calling IssueTransfer on hubs, since we handle
; 2479 :     // hubs internally.
; 2480 :     DEBUGCHK( address != m_address );
; 2481 : 
; 2482 :     PREFAST_DEBUGCHK( m_ppCDeviceOnPort != NULL );
; 2483 :     for ( UCHAR port = 1; status == requestIgnored && port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  00024	e59da098	 ldr         r10, [sp, #0x98]
  00028	e59db094	 ldr         r11, [sp, #0x94]
  0002c	e3a06001	 mov         r6, #1
  00030		 |$LL4@IssueTrans|
  00030	e5d5306a	 ldrb        r3, [r5, #0x6A]
  00034	e1560003	 cmp         r6, r3
  00038	8a000030	 bhi         |$LN2@IssueTrans|

; 2484 :         if ( m_ppCDeviceOnPort[ port - 1 ] != NULL ) {            

  0003c	e59530b0	 ldr         r3, [r5, #0xB0]
  00040	e0833106	 add         r3, r3, r6, lsl #2
  00044	e5133004	 ldr         r3, [r3, #-4]
  00048	e3530000	 cmp         r3, #0
  0004c	0a000027	 beq         |$LN3@IssueTrans|

; 2485 :             status = m_ppCDeviceOnPort[ port - 1 ]->IssueTransfer(
; 2486 :                                                         address,
; 2487 :                                                         pipeIndex,
; 2488 :                                                         lpStartAddress,
; 2489 :                                                         lpvNotifyParameter,
; 2490 :                                                         dwFlags,
; 2491 :                                                         lpvControlHeader,
; 2492 :                                                         dwStartingFrame,
; 2493 :                                                         dwFrames,
; 2494 :                                                         aLengths,
; 2495 :                                                         dwBufferSize,
; 2496 :                                                         lpvBuffer,
; 2497 :                                                         paBuffer,
; 2498 :                                                         lpvCancelId,
; 2499 :                                                         adwIsochErrors,
; 2500 :                                                         adwIsochLengths,
; 2501 :                                                         lpfComplete,
; 2502 :                                                         lpdwBytesTransfered,
; 2503 :                                                         lpdwError );

  00050	e58da038	 str         r10, [sp, #0x38]
  00054	e59da090	 ldr         r10, [sp, #0x90]
  00058	e59510b0	 ldr         r1, [r5, #0xB0]
  0005c	e1a03007	 mov         r3, r7
  00060	e58da030	 str         r10, [sp, #0x30]
  00064	e59da08c	 ldr         r10, [sp, #0x8C]
  00068	e0811106	 add         r1, r1, r6, lsl #2
  0006c	e5110004	 ldr         r0, [r1, #-4]
  00070	e58da02c	 str         r10, [sp, #0x2C]
  00074	e59da088	 ldr         r10, [sp, #0x88]
  00078	e5904000	 ldr         r4, [r0]
  0007c	e1a02008	 mov         r2, r8
  00080	e58da028	 str         r10, [sp, #0x28]
  00084	e59da084	 ldr         r10, [sp, #0x84]
  00088	e5944010	 ldr         r4, [r4, #0x10]
  0008c	e1a01009	 mov         r1, r9
  00090	e58da024	 str         r10, [sp, #0x24]
  00094	e59da080	 ldr         r10, [sp, #0x80]
  00098	e58db034	 str         r11, [sp, #0x34]
  0009c	e58da020	 str         r10, [sp, #0x20]
  000a0	e59da07c	 ldr         r10, [sp, #0x7C]
  000a4	e58da01c	 str         r10, [sp, #0x1C]
  000a8	e59da078	 ldr         r10, [sp, #0x78]
  000ac	e58da018	 str         r10, [sp, #0x18]
  000b0	e59da074	 ldr         r10, [sp, #0x74]
  000b4	e58da014	 str         r10, [sp, #0x14]
  000b8	e59da070	 ldr         r10, [sp, #0x70]
  000bc	e58da010	 str         r10, [sp, #0x10]
  000c0	e59da06c	 ldr         r10, [sp, #0x6C]
  000c4	e58da00c	 str         r10, [sp, #0xC]
  000c8	e59da068	 ldr         r10, [sp, #0x68]
  000cc	e58da008	 str         r10, [sp, #8]
  000d0	e59da064	 ldr         r10, [sp, #0x64]
  000d4	e58da004	 str         r10, [sp, #4]
  000d8	e59da060	 ldr         r10, [sp, #0x60]
  000dc	e58da000	 str         r10, [sp]
  000e0	e1a0e00f	 mov         lr, pc
  000e4	e12fff14	 bx          r4
  000e8	e59da098	 ldr         r10, [sp, #0x98]
  000ec	e1a04000	 mov         r4, r0
  000f0		 |$LN3@IssueTrans|
  000f0	e2863001	 add         r3, r6, #1
  000f4	e20360ff	 and         r6, r3, #0xFF
  000f8	e3540002	 cmp         r4, #2
  000fc	0affffcb	 beq         |$LL4@IssueTrans|
  00100		 |$LN2@IssueTrans|

; 2504 :         }
; 2505 :     }
; 2506 : 
; 2507 :     LeaveCriticalSection( &m_csDeviceLock );

  00100	e285000c	 add         r0, r5, #0xC
  00104	eb000000	 bl          LeaveCriticalSection

; 2508 : 
; 2509 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CHub(%s tier %d)::IssueTransfer address = %d, pipe = %d, returing HCD_REQUEST_STATUS %d\n"), GetDeviceType(), m_tierNumber, address, pipeIndex, status ) );
; 2510 :     return status;
; 2511 : }

  00108	e1a00004	 mov         r0, r4
  0010c	e28dd03c	 add         sp, sp, #0x3C
  00110	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00114	e12fff1e	 bx          lr
  00118		 |$M38175|

			 ENDP  ; |?IssueTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z|, CHub::IssueTransfer

	EXPORT	|?AbortTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXQBX@Z| ; CHub::AbortTransfer

  00000			 AREA	 |.pdata|, PDATA
|$T38196| DCD	|$LN11@AbortTrans|
	DCD	0x40002b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AbortTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXQBX@Z| PROC ; CHub::AbortTransfer

; 2534 : {

  00000		 |$LN11@AbortTrans|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M38193|
  00008	e1a07003	 mov         r7, r3
  0000c	e1a08002	 mov         r8, r2
  00010	e1a09001	 mov         r9, r1
  00014	e1a05000	 mov         r5, r0

; 2535 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: +CHub(%s tier %d)::AbortTransfer - address = %d, pipeIndex = %d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, address, pipeIndex) );
; 2536 : 
; 2537 :     HCD_REQUEST_STATUS status = requestIgnored;
; 2538 : 
; 2539 :     EnterCriticalSection( &m_csDeviceLock );

  00018	e285000c	 add         r0, r5, #0xC
  0001c	e3a04002	 mov         r4, #2
  00020	eb000000	 bl          EnterCriticalSection

; 2540 : 
; 2541 :     // no one should be calling AbortTransfer on hubs, since we handle
; 2542 :     // hubs internally.
; 2543 :     DEBUGCHK( address != m_address );
; 2544 : 
; 2545 :     PREFAST_DEBUGCHK( m_ppCDeviceOnPort != NULL );
; 2546 :     for ( UCHAR port = 1; status == requestIgnored && port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  00024	e59da030	 ldr         r10, [sp, #0x30]
  00028	e59db02c	 ldr         r11, [sp, #0x2C]
  0002c	e3a06001	 mov         r6, #1
  00030		 |$LL4@AbortTrans|
  00030	e5d5e06a	 ldrb        lr, [r5, #0x6A]
  00034	e156000e	 cmp         r6, lr
  00038	8a000015	 bhi         |$LN2@AbortTrans|

; 2547 :         if ( m_ppCDeviceOnPort[ port - 1 ] != NULL ) {

  0003c	e595e0b0	 ldr         lr, [r5, #0xB0]
  00040	e08ee106	 add         lr, lr, r6, lsl #2
  00044	e51ee004	 ldr         lr, [lr, #-4]
  00048	e35e0000	 cmp         lr, #0
  0004c	0a00000c	 beq         |$LN3@AbortTrans|

; 2548 :             status = m_ppCDeviceOnPort[ port - 1 ]->AbortTransfer( address,
; 2549 :                                                                    pipeIndex,
; 2550 :                                                                    lpCancelAddress,
; 2551 :                                                                    lpvNotifyParameter,
; 2552 :                                                                    lpvCancelId );

  00050	e59510b0	 ldr         r1, [r5, #0xB0]
  00054	e1a03007	 mov         r3, r7
  00058	e1a02008	 mov         r2, r8
  0005c	e0811106	 add         r1, r1, r6, lsl #2
  00060	e5110004	 ldr         r0, [r1, #-4]
  00064	e1a01009	 mov         r1, r9
  00068	e58da004	 str         r10, [sp, #4]
  0006c	e5904000	 ldr         r4, [r0]
  00070	e58db000	 str         r11, [sp]
  00074	e5944014	 ldr         r4, [r4, #0x14]
  00078	e1a0e00f	 mov         lr, pc
  0007c	e12fff14	 bx          r4
  00080	e1a04000	 mov         r4, r0
  00084		 |$LN3@AbortTrans|
  00084	e2863001	 add         r3, r6, #1
  00088	e20360ff	 and         r6, r3, #0xFF
  0008c	e3540002	 cmp         r4, #2
  00090	0affffe6	 beq         |$LL4@AbortTrans|
  00094		 |$LN2@AbortTrans|

; 2553 :         }
; 2554 :     }
; 2555 : 
; 2556 :     LeaveCriticalSection( &m_csDeviceLock );

  00094	e285000c	 add         r0, r5, #0xC
  00098	eb000000	 bl          LeaveCriticalSection

; 2557 : 
; 2558 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: -CHub(%s tier %d)::AbortTransfer - address = %d, pipeIndex = %d, returing HCD_REQUEST_STATUS %d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, address, pipeIndex, status) );
; 2559 :     return status;
; 2560 : }

  0009c	e1a00004	 mov         r0, r4
  000a0	e28dd008	 add         sp, sp, #8
  000a4	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  000a8	e12fff1e	 bx          lr
  000ac		 |$M38194|

			 ENDP  ; |?AbortTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXQBX@Z|, CHub::AbortTransfer

	EXPORT	|?IsPipeHalted@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQAH@Z| ; CHub::IsPipeHalted

  00000			 AREA	 |.pdata|, PDATA
|$T38213| DCD	|$LN11@IsPipeHalt|
	DCD	0x40002501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsPipeHalted@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQAH@Z| PROC ; CHub::IsPipeHalted

; 2581 : {

  00000		 |$LN11@IsPipeHalt|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M38210|
  00004	e1a07003	 mov         r7, r3
  00008	e1a08002	 mov         r8, r2
  0000c	e1a09001	 mov         r9, r1
  00010	e1a05000	 mov         r5, r0

; 2582 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CHub(%s tier %d)::IsPipeHalted - address = %d, pipeIndex = %d\n"), GetDeviceType(), m_tierNumber, address, pipeIndex) );
; 2583 : 
; 2584 :     HCD_REQUEST_STATUS status = requestIgnored;
; 2585 : 
; 2586 :     EnterCriticalSection( &m_csDeviceLock );

  00014	e285000c	 add         r0, r5, #0xC
  00018	e3a04002	 mov         r4, #2
  0001c	eb000000	 bl          EnterCriticalSection

; 2587 : 
; 2588 :     // no one should be calling IsPipeHalted on hubs, since we handle
; 2589 :     // hubs internally.
; 2590 :     DEBUGCHK( address != m_address );
; 2591 : 
; 2592 :     PREFAST_DEBUGCHK( m_ppCDeviceOnPort != NULL );
; 2593 :     for ( UCHAR port = 1; status == requestIgnored && port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  00020	e3a06001	 mov         r6, #1
  00024		 |$LL4@IsPipeHalt|
  00024	e5d5e06a	 ldrb        lr, [r5, #0x6A]
  00028	e156000e	 cmp         r6, lr
  0002c	8a000013	 bhi         |$LN2@IsPipeHalt|

; 2594 :         if ( m_ppCDeviceOnPort[ port - 1 ] != NULL ) {

  00030	e595e0b0	 ldr         lr, [r5, #0xB0]
  00034	e08ee106	 add         lr, lr, r6, lsl #2
  00038	e51ee004	 ldr         lr, [lr, #-4]
  0003c	e35e0000	 cmp         lr, #0
  00040	0a00000a	 beq         |$LN3@IsPipeHalt|

; 2595 :             status = m_ppCDeviceOnPort[ port - 1 ]->IsPipeHalted( address,
; 2596 :                                                                   pipeIndex,
; 2597 :                                                                   lpbHalted );

  00044	e595e0b0	 ldr         lr, [r5, #0xB0]
  00048	e1a03007	 mov         r3, r7
  0004c	e1a02008	 mov         r2, r8
  00050	e08e1106	 add         r1, lr, r6, lsl #2
  00054	e5110004	 ldr         r0, [r1, #-4]
  00058	e1a01009	 mov         r1, r9
  0005c	e5904000	 ldr         r4, [r0]
  00060	e5944018	 ldr         r4, [r4, #0x18]
  00064	e1a0e00f	 mov         lr, pc
  00068	e12fff14	 bx          r4
  0006c	e1a04000	 mov         r4, r0
  00070		 |$LN3@IsPipeHalt|
  00070	e2863001	 add         r3, r6, #1
  00074	e20360ff	 and         r6, r3, #0xFF
  00078	e3540002	 cmp         r4, #2
  0007c	0affffe8	 beq         |$LL4@IsPipeHalt|
  00080		 |$LN2@IsPipeHalt|

; 2598 :         }
; 2599 :     }
; 2600 : 
; 2601 :     LeaveCriticalSection( &m_csDeviceLock );

  00080	e285000c	 add         r0, r5, #0xC
  00084	eb000000	 bl          LeaveCriticalSection

; 2602 : 
; 2603 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: -CHub(%s tier %d)::IsPipeHalted - address = %d, pipe = %d, returing HCD_REQUEST_STATUS %d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, address, pipeIndex, status) );
; 2604 :     return status;
; 2605 : }

  00088	e1a00004	 mov         r0, r4
  0008c	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$M38211|

			 ENDP  ; |?IsPipeHalted@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQAH@Z|, CHub::IsPipeHalted

	EXPORT	|?ResetPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z| ; CHub::ResetPipe

  00000			 AREA	 |.pdata|, PDATA
|$T38229| DCD	|$LN11@ResetPipe|
	DCD	0x40002301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResetPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z| PROC ; CHub::ResetPipe

; 2623 : {

  00000		 |$LN11@ResetPipe|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M38226|
  00004	e1a07002	 mov         r7, r2
  00008	e1a08001	 mov         r8, r1
  0000c	e1a04000	 mov         r4, r0

; 2624 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CHub(%s tier %d)::ResetPipe - address = %d, pipeIndex = %d\n"), GetDeviceType(), m_tierNumber, address, pipeIndex) );
; 2625 : 
; 2626 :     HCD_REQUEST_STATUS status = requestIgnored;
; 2627 : 
; 2628 :     EnterCriticalSection( &m_csDeviceLock );

  00010	e284000c	 add         r0, r4, #0xC
  00014	e3a06002	 mov         r6, #2
  00018	eb000000	 bl          EnterCriticalSection

; 2629 : 
; 2630 :     // no one should be calling ResetPipe on hubs, since we handle
; 2631 :     // hubs internally.
; 2632 :     DEBUGCHK( address != m_address );
; 2633 :     PREFAST_DEBUGCHK( m_ppCDeviceOnPort!=NULL );
; 2634 :     
; 2635 :     DEBUGCHK( m_ppCDeviceOnPort != NULL );
; 2636 :     for ( UCHAR port = 1; status == requestIgnored && port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  0001c	e3a05001	 mov         r5, #1
  00020		 |$LL4@ResetPipe|
  00020	e5d4306a	 ldrb        r3, [r4, #0x6A]
  00024	e1550003	 cmp         r5, r3
  00028	8a000012	 bhi         |$LN2@ResetPipe|

; 2637 :         if ( m_ppCDeviceOnPort[ port - 1 ] != NULL ) {

  0002c	e59430b0	 ldr         r3, [r4, #0xB0]
  00030	e0833105	 add         r3, r3, r5, lsl #2
  00034	e5133004	 ldr         r3, [r3, #-4]
  00038	e3530000	 cmp         r3, #0
  0003c	0a000009	 beq         |$LN3@ResetPipe|

; 2638 :             status = m_ppCDeviceOnPort[ port - 1 ]->ResetPipe( address,
; 2639 :                                                                pipeIndex );

  00040	e59430b0	 ldr         r3, [r4, #0xB0]
  00044	e1a02007	 mov         r2, r7
  00048	e1a01008	 mov         r1, r8
  0004c	e0833105	 add         r3, r3, r5, lsl #2
  00050	e5130004	 ldr         r0, [r3, #-4]
  00054	e5903000	 ldr         r3, [r0]
  00058	e593301c	 ldr         r3, [r3, #0x1C]
  0005c	e1a0e00f	 mov         lr, pc
  00060	e12fff13	 bx          r3
  00064	e1a06000	 mov         r6, r0
  00068		 |$LN3@ResetPipe|
  00068	e2853001	 add         r3, r5, #1
  0006c	e20350ff	 and         r5, r3, #0xFF
  00070	e3560002	 cmp         r6, #2
  00074	0affffe9	 beq         |$LL4@ResetPipe|
  00078		 |$LN2@ResetPipe|

; 2640 :         }
; 2641 :     }
; 2642 : 
; 2643 :     LeaveCriticalSection( &m_csDeviceLock );

  00078	e284000c	 add         r0, r4, #0xC
  0007c	eb000000	 bl          LeaveCriticalSection

; 2644 : 
; 2645 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: -CHub(%s tier %d)::ResetPipe - address = %d, pipeIndex = %d, returing HCD_REQUEST_STATUS %d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, address, pipeIndex, status) );
; 2646 :     return status;
; 2647 : }

  00080	e1a00006	 mov         r0, r6
  00084	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$M38227|

			 ENDP  ; |?ResetPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|, CHub::ResetPipe

	EXPORT	|?DisableDevice@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z| ; CHub::DisableDevice

  00000			 AREA	 |.pdata|, PDATA
|$T38245| DCD	|$LN13@DisableDev@2|
	DCD	0x40002801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DisableDevice@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z| PROC ; CHub::DisableDevice

; 2664 : {

  00000		 |$LN13@DisableDev@2|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M38242|
  00004	e1a08002	 mov         r8, r2
  00008	e1a07001	 mov         r7, r1
  0000c	e1a04000	 mov         r4, r0

; 2665 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CHub(%s tier %d)::DisableDevice - address = %d, pipeIndex = %d\n"), GetDeviceType(), m_tierNumber, address, fReset) );
; 2666 : 
; 2667 :     HCD_REQUEST_STATUS status = requestIgnored;
; 2668 : 
; 2669 :     EnterCriticalSection( &m_csDeviceLock );

  00010	e284000c	 add         r0, r4, #0xC
  00014	e3a06002	 mov         r6, #2
  00018	eb000000	 bl          EnterCriticalSection

; 2670 :     if ( address != m_address ) {

  0001c	e5d43020	 ldrb        r3, [r4, #0x20]
  00020	e1570003	 cmp         r7, r3
  00024	0a000017	 beq         |$LN6@DisableDev@2|

; 2671 :         PREFAST_DEBUGCHK( m_ppCDeviceOnPort != NULL );
; 2672 :         for ( UCHAR port = 1; status == requestIgnored && port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  00028	e3a05001	 mov         r5, #1
  0002c		 |$LL5@DisableDev@2|
  0002c	e5d4306a	 ldrb        r3, [r4, #0x6A]
  00030	e1550003	 cmp         r5, r3
  00034	8a000014	 bhi         |$LN1@DisableDev@2|

; 2673 :             if ( m_ppCDeviceOnPort[ port - 1 ] != NULL ) {

  00038	e59430b0	 ldr         r3, [r4, #0xB0]
  0003c	e0833105	 add         r3, r3, r5, lsl #2
  00040	e5133004	 ldr         r3, [r3, #-4]
  00044	e3530000	 cmp         r3, #0
  00048	0a000009	 beq         |$LN4@DisableDev@2|

; 2674 :                 status =  m_ppCDeviceOnPort[ port - 1 ]-> DisableDevice(address, fReset);

  0004c	e59430b0	 ldr         r3, [r4, #0xB0]
  00050	e1a02008	 mov         r2, r8
  00054	e1a01007	 mov         r1, r7
  00058	e0833105	 add         r3, r3, r5, lsl #2
  0005c	e5130004	 ldr         r0, [r3, #-4]
  00060	e5903000	 ldr         r3, [r0]
  00064	e5933020	 ldr         r3, [r3, #0x20]
  00068	e1a0e00f	 mov         lr, pc
  0006c	e12fff13	 bx          r3
  00070	e1a06000	 mov         r6, r0
  00074		 |$LN4@DisableDev@2|
  00074	e2853001	 add         r3, r5, #1
  00078	e20350ff	 and         r5, r3, #0xFF
  0007c	e3560002	 cmp         r6, #2
  00080	0affffe9	 beq         |$LL5@DisableDev@2|

; 2675 :             }
; 2676 :         }
; 2677 :     }
; 2678 :     else { // It should not happens

  00084	ea000000	 b           |$LN1@DisableDev@2|
  00088		 |$LN6@DisableDev@2|

; 2679 :         ASSERT(FALSE);
; 2680 :         status = requestFailed;

  00088	e3a06000	 mov         r6, #0
  0008c		 |$LN1@DisableDev@2|

; 2681 :     }
; 2682 :     LeaveCriticalSection( &m_csDeviceLock );

  0008c	e284000c	 add         r0, r4, #0xC
  00090	eb000000	 bl          LeaveCriticalSection

; 2683 : 
; 2684 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: -CHub(%s tier %d)::DisableDevice - address = %d, returing HCD_REQUEST_STATUS %d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, address, status) );
; 2685 :     return status;
; 2686 : }

  00094	e1a00006	 mov         r0, r6
  00098	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$M38243|

			 ENDP  ; |?DisableDevice@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|, CHub::DisableDevice

	EXPORT	|?NotifyOnSuspendedResumed@CHub@@UAAHH@Z| ; CHub::NotifyOnSuspendedResumed

  00000			 AREA	 |.pdata|, PDATA
|$T38260| DCD	|$LN12@NotifyOnSu@2|
	DCD	0x40001d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?NotifyOnSuspendedResumed@CHub@@UAAHH@Z| PROC ; CHub::NotifyOnSuspendedResumed

; 2688 : {

  00000		 |$LN12@NotifyOnSu@2|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M38257|
  00004	e1a06001	 mov         r6, r1
  00008	e1a05000	 mov         r5, r0

; 2689 :     for ( UCHAR port = 1; m_ppCDeviceOnPort != NULL && port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  0000c	e59530b0	 ldr         r3, [r5, #0xB0]
  00010	e3a04001	 mov         r4, #1
  00014	e1b02003	 movs        r2, r3
  00018	0a000012	 beq         |$LN9@NotifyOnSu@2|
  0001c		 |$LL4@NotifyOnSu@2|
  0001c	e5d5306a	 ldrb        r3, [r5, #0x6A]
  00020	e1540003	 cmp         r4, r3
  00024	8a00000f	 bhi         |$LN9@NotifyOnSu@2|

; 2690 :         if ( m_ppCDeviceOnPort[ port - 1 ] != NULL ) { // Notify all down stream device.

  00028	e0823104	 add         r3, r2, r4, lsl #2
  0002c	e5133004	 ldr         r3, [r3, #-4]
  00030	e3530000	 cmp         r3, #0

; 2691 :             m_ppCDeviceOnPort[ port - 1 ]-> NotifyOnSuspendedResumed(fResumed);

  00034	159530b0	 ldrne       r3, [r5, #0xB0]
  00038	11a01006	 movne       r1, r6
  0003c	10833104	 addne       r3, r3, r4, lsl #2
  00040	15130004	 ldrne       r0, [r3, #-4]
  00044	15903000	 ldrne       r3, [r0]
  00048	1593302c	 ldrne       r3, [r3, #0x2C]
  0004c	11a0e00f	 movne       lr, pc
  00050	112fff13	 bxne        r3
  00054	e59520b0	 ldr         r2, [r5, #0xB0]
  00058	e2843001	 add         r3, r4, #1
  0005c	e20340ff	 and         r4, r3, #0xFF
  00060	e3520000	 cmp         r2, #0
  00064	1affffec	 bne         |$LL4@NotifyOnSu@2|
  00068		 |$LN9@NotifyOnSu@2|

; 2692 :         }
; 2693 :     }
; 2694 :     return TRUE;

  00068	e3a00001	 mov         r0, #1

; 2695 : }

  0006c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00070	e12fff1e	 bx          lr
  00074		 |$M38258|

			 ENDP  ; |?NotifyOnSuspendedResumed@CHub@@UAAHH@Z|, CHub::NotifyOnSuspendedResumed

	EXPORT	|?SuspendResume@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z| ; CHub::SuspendResume

  00000			 AREA	 |.pdata|, PDATA
|$T38276| DCD	|$LN13@SuspendRes@2|
	DCD	0x40002801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SuspendResume@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z| PROC ; CHub::SuspendResume

; 2713 : {

  00000		 |$LN13@SuspendRes@2|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M38273|
  00004	e1a08002	 mov         r8, r2
  00008	e1a07001	 mov         r7, r1
  0000c	e1a04000	 mov         r4, r0

; 2714 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CHub(%s tier %d)::SuspendResume - address = %d, fSuspend = %d\n"), GetDeviceType(), m_tierNumber, address, fSuspend) );
; 2715 : 
; 2716 :     HCD_REQUEST_STATUS status = requestIgnored;
; 2717 : 
; 2718 :     EnterCriticalSection( &m_csDeviceLock );

  00010	e284000c	 add         r0, r4, #0xC
  00014	e3a06002	 mov         r6, #2
  00018	eb000000	 bl          EnterCriticalSection

; 2719 :     if ( address != m_address ) {

  0001c	e5d43020	 ldrb        r3, [r4, #0x20]
  00020	e1570003	 cmp         r7, r3
  00024	0a000017	 beq         |$LN6@SuspendRes@2|

; 2720 :         PREFAST_DEBUGCHK( m_ppCDeviceOnPort != NULL );
; 2721 :         for ( UCHAR port = 1; status == requestIgnored && port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  00028	e3a05001	 mov         r5, #1
  0002c		 |$LL5@SuspendRes@2|
  0002c	e5d4306a	 ldrb        r3, [r4, #0x6A]
  00030	e1550003	 cmp         r5, r3
  00034	8a000014	 bhi         |$LN1@SuspendRes@2|

; 2722 :             if ( m_ppCDeviceOnPort[ port - 1 ] != NULL ) {

  00038	e59430b0	 ldr         r3, [r4, #0xB0]
  0003c	e0833105	 add         r3, r3, r5, lsl #2
  00040	e5133004	 ldr         r3, [r3, #-4]
  00044	e3530000	 cmp         r3, #0
  00048	0a000009	 beq         |$LN4@SuspendRes@2|

; 2723 :                 status = m_ppCDeviceOnPort[ port - 1 ] ->SuspendResume(address, fSuspend) ;

  0004c	e59430b0	 ldr         r3, [r4, #0xB0]
  00050	e1a02008	 mov         r2, r8
  00054	e1a01007	 mov         r1, r7
  00058	e0833105	 add         r3, r3, r5, lsl #2
  0005c	e5130004	 ldr         r0, [r3, #-4]
  00060	e5903000	 ldr         r3, [r0]
  00064	e5933024	 ldr         r3, [r3, #0x24]
  00068	e1a0e00f	 mov         lr, pc
  0006c	e12fff13	 bx          r3
  00070	e1a06000	 mov         r6, r0
  00074		 |$LN4@SuspendRes@2|
  00074	e2853001	 add         r3, r5, #1
  00078	e20350ff	 and         r5, r3, #0xFF
  0007c	e3560002	 cmp         r6, #2
  00080	0affffe9	 beq         |$LL5@SuspendRes@2|

; 2724 :             }
; 2725 :         }
; 2726 :     }
; 2727 :     else { // It should not happens

  00084	ea000000	 b           |$LN1@SuspendRes@2|
  00088		 |$LN6@SuspendRes@2|

; 2728 :         ASSERT(FALSE);
; 2729 :         status = requestFailed;

  00088	e3a06000	 mov         r6, #0
  0008c		 |$LN1@SuspendRes@2|

; 2730 :     }
; 2731 :     LeaveCriticalSection( &m_csDeviceLock );

  0008c	e284000c	 add         r0, r4, #0xC
  00090	eb000000	 bl          LeaveCriticalSection

; 2732 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: -CHub(%s tier %d)::SuspendResume - address = %d, returing HCD_REQUEST_STATUS %d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, address, status) );
; 2733 :     return status;
; 2734 : }

  00094	e1a00006	 mov         r0, r6
  00098	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$M38274|

			 ENDP  ; |?SuspendResume@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|, CHub::SuspendResume

	EXPORT	|?SuspendResumeOffStreamDevice@CHub@@UAAHIH@Z| ; CHub::SuspendResumeOffStreamDevice
	IMPORT	|Sleep|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T38302| DCD	|$LN21@SuspendRes@3|
	DCD	0x40003b01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SuspendResumeOffStreamDevice@CHub@@UAAHIH@Z| PROC ; CHub::SuspendResumeOffStreamDevice

; 2762 : {

  00000		 |$LN21@SuspendRes@3|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M38299|
  00004	e1a07002	 mov         r7, r2
  00008	e1a06000	 mov         r6, r0

; 2763 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: +CHub(%s tier %d)::SuspendResume - address = %d, fSuspend = %d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, address, fSuspend) );
; 2764 :     BOOL fReturn = FALSE;
; 2765 :     for ( UCHAR port = 1; port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  0000c	e5d6006a	 ldrb        r0, [r6, #0x6A]
  00010	e3a08000	 mov         r8, #0
  00014	e3a05001	 mov         r5, #1
  00018	e3500001	 cmp         r0, #1
  0001c	3a00002f	 bcc         |$LN18@SuspendRes@3|
  00020	e596e0b0	 ldr         lr, [r6, #0xB0]
  00024		 |$LL6@SuspendRes@3|

; 2766 :         if (m_ppCDeviceOnPort[ port - 1 ]!= NULL && m_ppCDeviceOnPort[ port - 1 ]->GetDeviceAddress()== address) { // Found.

  00024	e08e2105	 add         r2, lr, r5, lsl #2
  00028	e5123004	 ldr         r3, [r2, #-4]
  0002c	e3530000	 cmp         r3, #0
  00030	0a000002	 beq         |$LN5@SuspendRes@3|
  00034	e5d33020	 ldrb        r3, [r3, #0x20]
  00038	e1530001	 cmp         r3, r1
  0003c	0a000004	 beq         |$LN16@SuspendRes@3|
  00040		 |$LN5@SuspendRes@3|

; 2763 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: +CHub(%s tier %d)::SuspendResume - address = %d, fSuspend = %d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, address, fSuspend) );
; 2764 :     BOOL fReturn = FALSE;
; 2765 :     for ( UCHAR port = 1; port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  00040	e2853001	 add         r3, r5, #1
  00044	e20350ff	 and         r5, r3, #0xFF
  00048	e1550000	 cmp         r5, r0
  0004c	9afffff4	 bls         |$LL6@SuspendRes@3|
  00050	ea000022	 b           |$LN18@SuspendRes@3|
  00054		 |$LN16@SuspendRes@3|

; 2767 :             if (SetOrClearFeature( port,
; 2768 :                    fSuspend? USB_REQUEST_SET_FEATURE: USB_REQUEST_CLEAR_FEATURE,
; 2769 :                    USB_HUB_FEATURE_PORT_SUSPEND)) {

  00054	e5961000	 ldr         r1, [r6]
  00058	e3570000	 cmp         r7, #0
  0005c	13a02003	 movne       r2, #3
  00060	e5914050	 ldr         r4, [r1, #0x50]
  00064	03a02001	 moveq       r2, #1
  00068	e20220ff	 and         r2, r2, #0xFF
  0006c	e1a01005	 mov         r1, r5
  00070	e3a03002	 mov         r3, #2
  00074	e1a00006	 mov         r0, r6
  00078	e1a0e00f	 mov         lr, pc
  0007c	e12fff14	 bx          r4
  00080	e3500000	 cmp         r0, #0
  00084	0a000015	 beq         |$LN18@SuspendRes@3|

; 2770 :                 fReturn = TRUE;

  00088	e3a08001	 mov         r8, #1

; 2771 :                 if ( !fSuspend) { // If it is resume.

  0008c	e3570000	 cmp         r7, #0
  00090	1a00000a	 bne         |$LN11@SuspendRes@3|

; 2772 :                     Sleep(20);

  00094	e3a00014	 mov         r0, #0x14
  00098	eb000000	 bl          Sleep

; 2773 :                     m_ppCDeviceOnPort[ port-1 ]-> ResumeNotification();

  0009c	e59630b0	 ldr         r3, [r6, #0xB0]
  000a0	e0833105	 add         r3, r3, r5, lsl #2
  000a4	e5130004	 ldr         r0, [r3, #-4]
  000a8	e5903000	 ldr         r3, [r0]
  000ac	e5933028	 ldr         r3, [r3, #0x28]
  000b0	e1a0e00f	 mov         lr, pc
  000b4	e12fff13	 bx          r3

; 2774 :                 }
; 2775 :                 m_ppCDeviceOnPort[ port-1 ]-> NotifyOnSuspendedResumed(!fSuspend);

  000b8	e3a01001	 mov         r1, #1
  000bc	ea000000	 b           |$LN12@SuspendRes@3|
  000c0		 |$LN11@SuspendRes@3|
  000c0	e3a01000	 mov         r1, #0
  000c4		 |$LN12@SuspendRes@3|
  000c4	e59630b0	 ldr         r3, [r6, #0xB0]
  000c8	e0833105	 add         r3, r3, r5, lsl #2
  000cc	e5130004	 ldr         r0, [r3, #-4]
  000d0	e5903000	 ldr         r3, [r0]
  000d4	e593302c	 ldr         r3, [r3, #0x2C]
  000d8	e1a0e00f	 mov         lr, pc
  000dc	e12fff13	 bx          r3
  000e0		 |$LN18@SuspendRes@3|

; 2776 :             }
; 2777 :             break;
; 2778 :         }
; 2779 :     }
; 2780 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CHub(%s tier %d)::SuspendResume - address = %d, returing HCD_REQUEST_STATUS %d\n"), GetDeviceType(), m_tierNumber, address, fReturn) );
; 2781 :     return fReturn;
; 2782 : }

  000e0	e1a00008	 mov         r0, r8
  000e4	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000e8	e12fff1e	 bx          lr
  000ec		 |$M38300|

			 ENDP  ; |?SuspendResumeOffStreamDevice@CHub@@UAAHIH@Z|, CHub::SuspendResumeOffStreamDevice

	EXPORT	|?PowerAllHubPorts@CRootHub@@EAAHXZ|	; CRootHub::PowerAllHubPorts

  00000			 AREA	 |.pdata|, PDATA
|$T38311| DCD	|$LN5@PowerAllHu|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PowerAllHubPorts@CRootHub@@EAAHXZ| PROC ; CRootHub::PowerAllHubPorts

; 2901 : {

  00000		 |$LN5@PowerAllHu|
  00000		 |$M38308|

; 2902 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("%s: +CRootHub::PowerAllHubPorts\n"),GetControllerName()) );
; 2903 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("-CRootHub::PowerAllHubPorts\n")) );
; 2904 :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 2905 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M38309|

			 ENDP  ; |?PowerAllHubPorts@CRootHub@@EAAHXZ|, CRootHub::PowerAllHubPorts

	EXPORT	|?WaitForPortStatusChange@CRootHub@@EAAHAAEAAU_USB_HUB_AND_PORT_STATUS@@@Z| ; CRootHub::WaitForPortStatusChange

  00000			 AREA	 |.pdata|, PDATA
|$T38333| DCD	|$LN25@WaitForPor|
	DCD	0x40004e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?WaitForPortStatusChange@CRootHub@@EAAHAAEAAU_USB_HUB_AND_PORT_STATUS@@@Z| PROC ; CRootHub::WaitForPortStatusChange

; 2923 : {

  00000		 |$LN25@WaitForPor|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M38330|
  00004	e1a08002	 mov         r8, r2
  00008	e1a09001	 mov         r9, r1
  0000c	e1a05000	 mov         r5, r0

; 2924 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("+CRootHub::WaitForPortStatusChange\n")) );
; 2925 : 
; 2926 :     BOOL fSuccess = FALSE;
; 2927 :     // root hub - we need to poll for status changes.
; 2928 :     while ( !m_fHubThreadClosing && !fSuccess ) {

  00010	e59530b8	 ldr         r3, [r5, #0xB8]
  00014	e3a06000	 mov         r6, #0
  00018	e3530000	 cmp         r3, #0
  0001c	1a000042	 bne         |$LN2@WaitForPor|
  00020		 |$LL13@WaitForPor|
  00020	e3560000	 cmp         r6, #0
  00024	1a00002a	 bne         |$LN22@WaitForPor|

; 2929 :         if (!m_pCHcd->WaitForPortStatusChange(m_hHubStatusChangeEvent)) {

  00028	e59500c8	 ldr         r0, [r5, #0xC8]
  0002c	e59510bc	 ldr         r1, [r5, #0xBC]
  00030	e5903000	 ldr         r3, [r0]
  00034	e5933038	 ldr         r3, [r3, #0x38]
  00038	e1a0e00f	 mov         lr, pc
  0003c	e12fff13	 bx          r3
  00040	e3500000	 cmp         r0, #0

; 2930 :             // If HCD does not support Root Hub Status Change. We do follows
; 2931 :             WaitForSingleObject( m_hHubStatusChangeEvent, 100 );

  00044	059500bc	 ldreq       r0, [r5, #0xBC]
  00048	03a01064	 moveq       r1, #0x64
  0004c	0b000000	 bleq        WaitForSingleObject

; 2932 :         }
; 2933 :         if ( m_fHubThreadClosing ) {

  00050	e59530b8	 ldr         r3, [r5, #0xB8]
  00054	e3530000	 cmp         r3, #0
  00058	1a000033	 bne         |$LN2@WaitForPor|

; 2934 :             break;
; 2935 :         }
; 2936 : 
; 2937 :         DEBUGMSG(ZONE_ATTACH && ZONE_VERBOSE, (TEXT("CRootHub::WaitForPortStatusChange::NoOfPort(0x%x)\r\n"), m_usbHubDescriptor.bNumberOfPorts));
; 2938 :         for ( UCHAR port = 1; !fSuccess && port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  0005c	e3a04001	 mov         r4, #1
  00060		 |$LL9@WaitForPor|
  00060	e5d5306a	 ldrb        r3, [r5, #0x6A]
  00064	e1540003	 cmp         r4, r3
  00068	8a000014	 bhi         |$LN7@WaitForPor|

; 2939 :             if ( m_pCHcd->DidPortStatusChange( port ) ) {

  0006c	e59500c8	 ldr         r0, [r5, #0xC8]
  00070	e1a01004	 mov         r1, r4
  00074	e5903000	 ldr         r3, [r0]
  00078	e5933024	 ldr         r3, [r3, #0x24]
  0007c	e1a0e00f	 mov         lr, pc
  00080	e12fff13	 bx          r3
  00084	e3500000	 cmp         r0, #0
  00088	0a000008	 beq         |$LN8@WaitForPor|

; 2940 :                 // port status changed on this port
; 2941 :                 rPort = port;

  0008c	e5c94000	 strb        r4, [r9]

; 2942 :                 // we could just call CHW::GetPortStatus, but it is
; 2943 :                 // better to call CRootHub::GetStatus which is
; 2944 :                 // designed to implement the virtual CHub::GetStatus function.
; 2945 :                 fSuccess = GetStatus( port, rStatus );

  00090	e5953000	 ldr         r3, [r5]
  00094	e1a02008	 mov         r2, r8
  00098	e1a01004	 mov         r1, r4
  0009c	e5933058	 ldr         r3, [r3, #0x58]
  000a0	e1a00005	 mov         r0, r5
  000a4	e1a0e00f	 mov         lr, pc
  000a8	e12fff13	 bx          r3
  000ac	e1a06000	 mov         r6, r0
  000b0		 |$LN8@WaitForPor|
  000b0	e2843001	 add         r3, r4, #1
  000b4	e20340ff	 and         r4, r3, #0xFF
  000b8	e3560000	 cmp         r6, #0
  000bc	0affffe7	 beq         |$LL9@WaitForPor|
  000c0		 |$LN7@WaitForPor|

; 2924 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("+CRootHub::WaitForPortStatusChange\n")) );
; 2925 : 
; 2926 :     BOOL fSuccess = FALSE;
; 2927 :     // root hub - we need to poll for status changes.
; 2928 :     while ( !m_fHubThreadClosing && !fSuccess ) {

  000c0	e59530b8	 ldr         r3, [r5, #0xB8]
  000c4	e3530000	 cmp         r3, #0
  000c8	0affffd4	 beq         |$LL13@WaitForPor|

; 2946 :                 DEBUGMSG(ZONE_ATTACH && ZONE_VERBOSE, (TEXT("GetStatus return %d\r\n"), fSuccess));
; 2947 :             }
; 2948 :         }
; 2949 :     }
; 2950 :     if (fSuccess) {

  000cc	e3560000	 cmp         r6, #0
  000d0	0a000015	 beq         |$LN2@WaitForPor|
  000d4		 |$LN22@WaitForPor|

; 2951 :         // acknowledge the change bits
; 2952 :         for (USHORT bit = 0; bit < 16; ++bit) {

  000d4	e3a02000	 mov         r2, #0
  000d8	e3a07000	 mov         r7, #0
  000dc	e3a0a001	 mov         r10, #1
  000e0		 |$LL4@WaitForPor|

; 2953 :             if (rStatus.change.word & (1 << bit))

  000e0	e1d830b2	 ldrh        r3, [r8, #2]
  000e4	e113021a	 tst         r3, r10, lsl r2
  000e8	0a000009	 beq         |$LN3@WaitForPor|

; 2954 :                 SetOrClearFeature( rPort, USB_REQUEST_CLEAR_FEATURE, bit | 0x10 );

  000ec	e5952000	 ldr         r2, [r5]
  000f0	e3873010	 orr         r3, r7, #0x10
  000f4	e5d91000	 ldrb        r1, [r9]
  000f8	e5924050	 ldr         r4, [r2, #0x50]
  000fc	e1a03803	 mov         r3, r3, lsl #16
  00100	e3a02001	 mov         r2, #1
  00104	e1a03823	 mov         r3, r3, lsr #16
  00108	e1a00005	 mov         r0, r5
  0010c	e1a0e00f	 mov         lr, pc
  00110	e12fff14	 bx          r4
  00114		 |$LN3@WaitForPor|
  00114	e2873001	 add         r3, r7, #1
  00118	e1a02803	 mov         r2, r3, lsl #16
  0011c	e1a02822	 mov         r2, r2, lsr #16
  00120	e1a07002	 mov         r7, r2
  00124	e3520010	 cmp         r2, #0x10
  00128	3affffec	 bcc         |$LL4@WaitForPor|
  0012c		 |$LN2@WaitForPor|

; 2955 :         }
; 2956 :     }
; 2957 : 
; 2958 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("%s: -CRootHub::WaitForPortStatusChange, rPort = %d, fSuccess = %d\n"),GetControllerName(), rPort, fSuccess) );
; 2959 :     return fSuccess;
; 2960 : }

  0012c	e1a00006	 mov         r0, r6
  00130	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00134	e12fff1e	 bx          lr
  00138		 |$M38331|

			 ENDP  ; |?WaitForPortStatusChange@CRootHub@@EAAHAAEAAU_USB_HUB_AND_PORT_STATUS@@@Z|, CRootHub::WaitForPortStatusChange

	EXPORT	|?GetStatus@CRootHub@@EAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z| ; CRootHub::GetStatus

  00000			 AREA	 |.pdata|, PDATA
|$T38345| DCD	|$LN5@GetStatus|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetStatus@CRootHub@@EAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z| PROC ; CRootHub::GetStatus

; 2977 : {

  00000		 |$LN5@GetStatus|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38342|

; 2978 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CRootHub::GetStatus - port = %d\n"), port ));
; 2979 : 
; 2980 :     DEBUGCHK( port <= m_usbHubDescriptor.bNumberOfPorts );
; 2981 : 
; 2982 :     // CHW::GetPortStatus will not clear the change bits
; 2983 :     BOOL fSuccess = m_pCHcd->GetPortStatus( port, rStatus );

  00004	e59000c8	 ldr         r0, [r0, #0xC8]

; 2984 : 
; 2985 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: -CRootHub::GetStatus - port = %d, returing BOOL %d\n"),GetControllerName(), port, fSuccess ) );
; 2986 :     return fSuccess;

  00008	e5903000	 ldr         r3, [r0]
  0000c	e5933028	 ldr         r3, [r3, #0x28]
  00010	e1a0e00f	 mov         lr, pc
  00014	e12fff13	 bx          r3

; 2987 : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$M38343|

			 ENDP  ; |?GetStatus@CRootHub@@EAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z|, CRootHub::GetStatus

	EXPORT	|?ResetAndEnablePort@CRootHub@@EAAHE@Z|	; CRootHub::ResetAndEnablePort

  00000			 AREA	 |.pdata|, PDATA
|$T38356| DCD	|$LN5@ResetAndEn|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResetAndEnablePort@CRootHub@@EAAHE@Z| PROC ; CRootHub::ResetAndEnablePort

; 3001 : {

  00000		 |$LN5@ResetAndEn|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38353|

; 3002 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("%s: +CRootHub::ResetAndEnablePort - port = %d\n"),GetControllerName(), port) );
; 3003 : 
; 3004 :     DEBUGCHK( port >= 1 && port <= m_usbHubDescriptor.bNumberOfPorts );
; 3005 : 
; 3006 :     BOOL fSuccess = m_pCHcd->ResetAndEnablePort( port );

  00004	e59000c8	 ldr         r0, [r0, #0xC8]

; 3007 : 
; 3008 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("%s: -CRootHub::ResetAndEnablePort - port = %d, returning %d\n"),GetControllerName(), port, fSuccess ) );
; 3009 :     return fSuccess;

  00008	e5903000	 ldr         r3, [r0]
  0000c	e5933030	 ldr         r3, [r3, #0x30]
  00010	e1a0e00f	 mov         lr, pc
  00014	e12fff13	 bx          r3

; 3010 : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$M38354|

			 ENDP  ; |?ResetAndEnablePort@CRootHub@@EAAHE@Z|, CRootHub::ResetAndEnablePort

	EXPORT	|?DisablePort@CRootHub@@EAAXE@Z|	; CRootHub::DisablePort

  00000			 AREA	 |.pdata|, PDATA
|$T38365| DCD	|$LN5@DisablePor|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DisablePort@CRootHub@@EAAXE@Z| PROC	; CRootHub::DisablePort

; 3023 : {

  00000		 |$LN5@DisablePor|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38362|

; 3024 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("%s: +CRootHub::DisablePort - port = %d\n"),GetControllerName(), port) );
; 3025 : 
; 3026 :     DEBUGCHK( port >= 1 && port <= m_usbHubDescriptor.bNumberOfPorts );
; 3027 : 
; 3028 :     m_pCHcd->DisablePort( port );

  00004	e59000c8	 ldr         r0, [r0, #0xC8]
  00008	e5903000	 ldr         r3, [r0]
  0000c	e5933034	 ldr         r3, [r3, #0x34]
  00010	e1a0e00f	 mov         lr, pc
  00014	e12fff13	 bx          r3

; 3029 : 
; 3030 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("%s: -CRootHub::DisablePort - port = %d\n"),GetControllerName(), port) );
; 3031 : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$M38363|

			 ENDP  ; |?DisablePort@CRootHub@@EAAXE@Z|, CRootHub::DisablePort

	EXPORT	|?SetOrClearFeature@CRootHub@@EAAHGEG@Z| ; CRootHub::SetOrClearFeature

  00000			 AREA	 |.pdata|, PDATA
|$T38378| DCD	|$LN5@SetOrClear|
	DCD	0x40000901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetOrClearFeature@CRootHub@@EAAHGEG@Z| PROC ; CRootHub::SetOrClearFeature

; 3054 : {

  00000		 |$LN5@SetOrClear|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M38375|

; 3055 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: +CRootHub::SetOrClearFeature - port = %d, set/clear = 0x%x, feature = 0x%x\n"),GetControllerName(), port, setOrClearFeature, feature) );
; 3056 : 
; 3057 : #ifdef DEBUG
; 3058 : {
; 3059 :     if ( setOrClearFeature == USB_REQUEST_CLEAR_FEATURE ) {
; 3060 :         if ( port == 0 ) {
; 3061 :             // USB spec 1.1, 11.16.2.2 - these are the only
; 3062 :             // features which should be cleared for ports
; 3063 :             DEBUGCHK( feature == USB_HUB_FEATURE_C_HUB_LOCAL_POWER ||
; 3064 :                       feature == USB_HUB_FEATURE_C_HUB_OVER_CURRENT ||
; 3065 :                       feature == USB_FEATURE_ENDPOINT_STALL );
; 3066 :         } else {
; 3067 :             // USB spec 1.1, 11.16.2.2 - these are the only
; 3068 :             // features which should be cleared for ports
; 3069 :             DEBUGCHK( feature == USB_HUB_FEATURE_PORT_ENABLE ||
; 3070 :                       feature == USB_HUB_FEATURE_PORT_SUSPEND ||
; 3071 :                       feature == USB_HUB_FEATURE_PORT_POWER ||
; 3072 :                       feature == USB_HUB_FEATURE_C_PORT_CONNECTION ||
; 3073 :                       feature == USB_HUB_FEATURE_C_PORT_RESET ||
; 3074 :                       feature == USB_HUB_FEATURE_C_PORT_ENABLE ||
; 3075 :                       feature == USB_HUB_FEATURE_C_PORT_SUSPEND ||
; 3076 :                       feature == USB_HUB_FEATURE_C_PORT_OVER_CURRENT );
; 3077 :         }
; 3078 :     } else if ( setOrClearFeature == USB_REQUEST_SET_FEATURE ) {
; 3079 :         // should only be setting port features
; 3080 :         DEBUGCHK( port > 0 &&
; 3081 :                   (feature == USB_HUB_FEATURE_PORT_RESET ||
; 3082 :                    feature == USB_HUB_FEATURE_PORT_SUSPEND ||
; 3083 :                    feature == USB_HUB_FEATURE_PORT_INDICATOR ||
; 3084 :                    feature == USB_HUB_FEATURE_PORT_POWER) );
; 3085 :     } else {
; 3086 :         // shouldn't be here
; 3087 :         DebugBreak();
; 3088 :     }
; 3089 :     DEBUGCHK( port <= m_usbHubDescriptor.bNumberOfPorts );
; 3090 : }
; 3091 : #endif // DEBUG
; 3092 : 
; 3093 :     BOOL fSuccess = m_pCHcd->RootHubFeature((UCHAR)port, setOrClearFeature, feature);

  00004	e59000c8	 ldr         r0, [r0, #0xC8]

; 3094 : 
; 3095 :     DEBUGMSG( ZONE_ERROR && !fSuccess, (TEXT("%s: CRootHub::SetOrClearFeature - port = %d, set/clear = 0x%x, feature = 0x%x, FAILED\n"),GetControllerName(), port, setOrClearFeature, feature ) );
; 3096 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CRootHub::SetOrClearFeature - port = %d, set/clear = 0x%x, feature = 0x%x, returing BOOL %d\n"), port, setOrClearFeature, feature, fSuccess) );
; 3097 :     return fSuccess;

  00008	e20110ff	 and         r1, r1, #0xFF
  0000c	e590e000	 ldr         lr, [r0]
  00010	e59e402c	 ldr         r4, [lr, #0x2C]
  00014	e1a0e00f	 mov         lr, pc
  00018	e12fff14	 bx          r4

; 3098 : }

  0001c	e8bd4010	 ldmia       sp!, {r4, lr}
  00020	e12fff1e	 bx          lr
  00024		 |$M38376|

			 ENDP  ; |?SetOrClearFeature@CRootHub@@EAAHGEG@Z|, CRootHub::SetOrClearFeature

	EXPORT	|?SetOrClearRemoteWakup@CRootHub@@EAAHH@Z| ; CRootHub::SetOrClearRemoteWakup

  00000			 AREA	 |.pdata|, PDATA
|$T38387| DCD	|$LN5@SetOrClear@2|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetOrClearRemoteWakup@CRootHub@@EAAHH@Z| PROC ; CRootHub::SetOrClearRemoteWakup

; 3110 : {

  00000		 |$LN5@SetOrClear@2|
  00000		 |$M38384|

; 3111 :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 3112 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M38385|

			 ENDP  ; |?SetOrClearRemoteWakup@CRootHub@@EAAHH@Z|, CRootHub::SetOrClearRemoteWakup

	EXPORT	|?PowerAllHubPorts@CExternalHub@@EAAHXZ| ; CExternalHub::PowerAllHubPorts

  00000			 AREA	 |.pdata|, PDATA
|$T38405| DCD	|$LN15@PowerAllHu@2|
	DCD	0x40002501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PowerAllHubPorts@CExternalHub@@EAAHXZ| PROC ; CExternalHub::PowerAllHubPorts

; 3276 : {

  00000		 |$LN15@PowerAllHu@2|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M38402|
  00004	e1a07000	 mov         r7, r0

; 3277 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("%s: +CExternalHub::PowerAllHubPorts\n"),GetControllerName()) );
; 3278 : 
; 3279 :     BOOL fFailed = FALSE;

  00008	e3a05000	 mov         r5, #0

; 3280 : 
; 3281 :     for ( UCHAR port = 1; !fFailed && port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  0000c	e3a06001	 mov         r6, #1
  00010		 |$LL4@PowerAllHu@2|
  00010	e5d7306a	 ldrb        r3, [r7, #0x6A]
  00014	e1560003	 cmp         r6, r3
  00018	8a000017	 bhi         |$LN2@PowerAllHu@2|

; 3282 :         fFailed = !SetOrClearFeature( port,
; 3283 :                                       USB_REQUEST_SET_FEATURE,
; 3284 :                                       USB_HUB_FEATURE_PORT_POWER );

  0001c	e5971000	 ldr         r1, [r7]
  00020	e3a03008	 mov         r3, #8
  00024	e3a02003	 mov         r2, #3
  00028	e5914050	 ldr         r4, [r1, #0x50]
  0002c	e1a01006	 mov         r1, r6
  00030	e1a00007	 mov         r0, r7
  00034	e1a0e00f	 mov         lr, pc
  00038	e12fff14	 bx          r4
  0003c	e3500000	 cmp         r0, #0
  00040	03a05001	 moveq       r5, #1
  00044	0a000008	 beq         |$LN3@PowerAllHu@2|

; 3285 :         if (!fFailed)
; 3286 :             SetOrClearFeature(port,
; 3287 :                                       USB_REQUEST_SET_FEATURE,
; 3288 :                                       USB_HUB_FEATURE_PORT_INDICATOR); // Set to the Auto Indicator.

  00048	e5971000	 ldr         r1, [r7]
  0004c	e3a03016	 mov         r3, #0x16
  00050	e3a02003	 mov         r2, #3
  00054	e5914050	 ldr         r4, [r1, #0x50]
  00058	e1a01006	 mov         r1, r6
  0005c	e1a00007	 mov         r0, r7
  00060	e3a05000	 mov         r5, #0
  00064	e1a0e00f	 mov         lr, pc
  00068	e12fff14	 bx          r4
  0006c		 |$LN3@PowerAllHu@2|
  0006c	e2863001	 add         r3, r6, #1
  00070	e20360ff	 and         r6, r3, #0xFF
  00074	e3550000	 cmp         r5, #0
  00078	0affffe4	 beq         |$LL4@PowerAllHu@2|
  0007c		 |$LN2@PowerAllHu@2|

; 3289 :     }
; 3290 : 
; 3291 :     DEBUGMSG( ZONE_ERROR && fFailed, (TEXT("%s: CExternalHub::PowerAllHubPorts - failed!\n"),GetControllerName()) );
; 3292 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("%s: -CExternalHub::PowerAllHubPorts, returing %d\n"),GetControllerName(), !fFailed) );
; 3293 :     return !fFailed;

  0007c	e3550000	 cmp         r5, #0
  00080	03a00001	 moveq       r0, #1

; 3294 : }

  00084	08bd40f0	 ldmeqia     sp!, {r4 - r7, lr}

; 3289 :     }
; 3290 : 
; 3291 :     DEBUGMSG( ZONE_ERROR && fFailed, (TEXT("%s: CExternalHub::PowerAllHubPorts - failed!\n"),GetControllerName()) );
; 3292 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("%s: -CExternalHub::PowerAllHubPorts, returing %d\n"),GetControllerName(), !fFailed) );
; 3293 :     return !fFailed;

  00088	13a00000	 movne       r0, #0

; 3294 : }

  0008c	18bd40f0	 ldmneia     sp!, {r4 - r7, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$M38403|

			 ENDP  ; |?PowerAllHubPorts@CExternalHub@@EAAHXZ|, CExternalHub::PowerAllHubPorts

	EXPORT	|?GetStatusChangeBitmap@CExternalHub@@AAAHAAK@Z| ; CExternalHub::GetStatusChangeBitmap
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T38427| DCD	|$LN15@GetStatusC|
	DCD	0x40005502
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetStatusChangeBitmap@CExternalHub@@AAAHAAK@Z| PROC ; CExternalHub::GetStatusChangeBitmap

; 3309 : {

  00000		 |$LN15@GetStatusC|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd044	 sub         sp, sp, #0x44
  00008		 |$M38424|
  00008	e1a09001	 mov         r9, r1
  0000c	e1a08000	 mov         r8, r0

; 3310 : #define HUB_INTERRUPT_TRANFER_TIMEOUT (10*1000)
; 3311 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("%s: +CExternalHub::GetStatusChangeBitmap\n"),GetControllerName()) );
; 3312 : 
; 3313 :     // for 1-7 ports,  the bitmap will be 1 byte,
; 3314 :     // for 8-15 ports, the bitmap will be 2 bytes,
; 3315 :     // etc. We only support up to 31 ports since
; 3316 :     // DWORD is 4 bytes.
; 3317 :     DEBUGCHK( m_usbHubDescriptor.bNumberOfPorts <= 31 );
; 3318 :     const DWORD         dwBitmapSize = 1 + (m_usbHubDescriptor.bNumberOfPorts >> 3);

  00010	e5d8306a	 ldrb        r3, [r8, #0x6A]

; 3319 :     BOOL                fSuccess = FALSE;
; 3320 :     BOOL                fTransferDone = FALSE;
; 3321 :     DWORD               dwBytesTransferred = 0;
; 3322 :     DWORD               dwErrorFlags = USB_NOT_COMPLETE_ERROR;
; 3323 :     HCD_REQUEST_STATUS  status = requestFailed;
; 3324 : 
; 3325 :     rdwHubBitmap = 0;

  00014	e3a02000	 mov         r2, #0
  00018	e5892000	 str         r2, [r9]

; 3326 : 
; 3327 :     // pipe 1 = status change endpoint pipe
; 3328 :     if ( !m_fHubThreadClosing) {

  0001c	e598e0b8	 ldr         lr, [r8, #0xB8]
  00020	e3a02c01	 mov         r2, #1, 24
  00024	e3822003	 orr         r2, r2, #3
  00028	e1a031a3	 mov         r3, r3, lsr #3
  0002c	e3a01000	 mov         r1, #0
  00030	e3a00000	 mov         r0, #0
  00034	e35e0000	 cmp         lr, #0
  00038	e58d2040	 str         r2, [sp, #0x40]
  0003c	e283a001	 add         r10, r3, #1
  00040	e58d1038	 str         r1, [sp, #0x38]
  00044	e58d003c	 str         r0, [sp, #0x3C]
  00048	1a00003c	 bne         |$LN7@GetStatusC|

; 3329 :         DEBUGCHK( m_maxNumPipes == 2 );
; 3330 :         PREFAST_DEBUGCHK( m_ppCPipe != NULL );
; 3331 :         PREFAST_DEBUGCHK( m_ppCPipe[ STATUS_CHANGE_INTERRUPT_PIPE ] != NULL );
; 3332 : 
; 3333 :         status = m_ppCPipe[ STATUS_CHANGE_INTERRUPT_PIPE ]->IssueTransfer(
; 3334 :                                     m_address, // hub address,
; 3335 :                                     TransferDoneCallbackSetEvent, // callback func
; 3336 :                                     m_hHubStatusChangeEvent, // callback param
; 3337 :                                     USB_IN_TRANSFER | USB_SEND_TO_DEVICE, // transfer flags
; 3338 :                                     NULL, // lpvControlHeader (not used)
; 3339 :                                     0, // dwStartingFrame (not used)
; 3340 :                                     0, // dwFrames (not used)
; 3341 :                                     NULL, // aLengths (not used)
; 3342 :                                     dwBitmapSize, // bitmap size to read
; 3343 :                                     &rdwHubBitmap, // data buffer
; 3344 :                                     0, // physical address of buffer (not used)
; 3345 :                                     this, // cancel id
; 3346 :                                     NULL, // adwIsochErrors (not used)
; 3347 :                                     NULL, // adwIsochLengths (not used)
; 3348 :                                     &fTransferDone, // OUT status param
; 3349 :                                     &dwBytesTransferred, // OUT status param
; 3350 :                                     &dwErrorFlags ); // OUT status param

  0004c	e598e05c	 ldr         lr, [r8, #0x5C]
  00050	e28d403c	 add         r4, sp, #0x3C
  00054	e58d4030	 str         r4, [sp, #0x30]
  00058	e59e0004	 ldr         r0, [lr, #4]
  0005c	e59830bc	 ldr         r3, [r8, #0xBC]
  00060	e59f20e8	 ldr         r2, [pc, #0xE8]
  00064	e590e000	 ldr         lr, [r0]
  00068	e5d81020	 ldrb        r1, [r8, #0x20]
  0006c	e28d6040	 add         r6, sp, #0x40
  00070	e59e700c	 ldr         r7, [lr, #0xC]
  00074	e28d5038	 add         r5, sp, #0x38
  00078	e3a0bd42	 mov         r11, #0x42, 26
  0007c	e3a04000	 mov         r4, #0
  00080	e58d6034	 str         r6, [sp, #0x34]
  00084	e58d502c	 str         r5, [sp, #0x2C]
  00088	e58d4028	 str         r4, [sp, #0x28]
  0008c	e58d4024	 str         r4, [sp, #0x24]
  00090	e58d8020	 str         r8, [sp, #0x20]
  00094	e58d401c	 str         r4, [sp, #0x1C]
  00098	e58d9018	 str         r9, [sp, #0x18]
  0009c	e58da014	 str         r10, [sp, #0x14]
  000a0	e58d4010	 str         r4, [sp, #0x10]
  000a4	e58d400c	 str         r4, [sp, #0xC]
  000a8	e58d4008	 str         r4, [sp, #8]
  000ac	e58d4004	 str         r4, [sp, #4]
  000b0	e58db000	 str         r11, [sp]
  000b4	e1a0e00f	 mov         lr, pc
  000b8	e12fff17	 bx          r7

; 3351 :         DEBUGMSG( ZONE_ERROR && status != requestOK, (TEXT("%s: CExternalHub::GetStatusChangeBitmap - error issuing transfer!\n"),GetControllerName()));
; 3352 :         if ( status == requestOK ) {

  000bc	e3500001	 cmp         r0, #1
  000c0	1a00001e	 bne         |$LN7@GetStatusC|

; 3353 :             WaitForSingleObject( m_hHubStatusChangeEvent, INFINITE);                    

  000c4	e59800bc	 ldr         r0, [r8, #0xBC]
  000c8	e3e01000	 mvn         r1, #0
  000cc	eb000000	 bl          WaitForSingleObject

; 3354 :             DEBUGMSG(ZONE_ATTACH, (TEXT("CExternalHub::: Get Data value 0x%x, fTransferDone %d\r\n"), rdwHubBitmap, fTransferDone));
; 3355 :             if (!fTransferDone ) {

  000d0	e59d3038	 ldr         r3, [sp, #0x38]
  000d4	e3530000	 cmp         r3, #0
  000d8	1a00000e	 bne         |$LN12@GetStatusC|

; 3356 :                 m_ppCPipe[ STATUS_CHANGE_INTERRUPT_PIPE ]->AbortTransfer(
; 3357 :                                                NULL, // callback function
; 3358 :                                                NULL, // callback parameter
; 3359 :                                                this ); // cancel ID

  000dc	e598105c	 ldr         r1, [r8, #0x5C]
  000e0	e1a03008	 mov         r3, r8
  000e4	e3a02000	 mov         r2, #0
  000e8	e5910004	 ldr         r0, [r1, #4]
  000ec	e3a01000	 mov         r1, #0
  000f0	e5904000	 ldr         r4, [r0]
  000f4	e5944010	 ldr         r4, [r4, #0x10]
  000f8	e1a0e00f	 mov         lr, pc
  000fc	e12fff14	 bx          r4

; 3360 :                 // After Abort the has been called. So reset the event.
; 3361 :                 ResetEvent( m_hHubStatusChangeEvent );

  00100	e59800bc	 ldr         r0, [r8, #0xBC]
  00104	e3a01002	 mov         r1, #2
  00108	eb000000	 bl          EventModify

; 3362 :             }
; 3363 :             else
; 3364 :                 DEBUGCHK( fTransferDone );
; 3365 :         }
; 3366 :     }
; 3367 :     fSuccess = ( status == requestOK &&
; 3368 :                  fTransferDone &&
; 3369 :                  dwBytesTransferred == dwBitmapSize &&
; 3370 :                  dwErrorFlags == USB_NO_ERROR &&
; 3371 :                  rdwHubBitmap != 0 );

  0010c	e59d3038	 ldr         r3, [sp, #0x38]
  00110	e3530000	 cmp         r3, #0
  00114	0a000009	 beq         |$LN7@GetStatusC|
  00118		 |$LN12@GetStatusC|
  00118	e59d303c	 ldr         r3, [sp, #0x3C]
  0011c	e153000a	 cmp         r3, r10
  00120	1a000006	 bne         |$LN7@GetStatusC|
  00124	e59d3040	 ldr         r3, [sp, #0x40]
  00128	e3530000	 cmp         r3, #0
  0012c	1a000003	 bne         |$LN7@GetStatusC|
  00130	e5993000	 ldr         r3, [r9]
  00134	e3530000	 cmp         r3, #0
  00138	13a00001	 movne       r0, #1
  0013c	1a000000	 bne         |$LN8@GetStatusC|
  00140		 |$LN7@GetStatusC|
  00140	e3a00000	 mov         r0, #0
  00144		 |$LN8@GetStatusC|

; 3372 : 
; 3373 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("-CExternal::GetStatusChangeBitmap, bitmap = 0x%08x, returing fSuccess = %d\n"), rdwHubBitmap, fSuccess) );
; 3374 :     return fSuccess;
; 3375 : }

  00144	e28dd044	 add         sp, sp, #0x44
  00148	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0014c	e12fff1e	 bx          lr
  00150		 |$LN16@GetStatusC|
  00150		 |$LN17@GetStatusC|
  00150	00000000	 DCD         |?TransferDoneCallbackSetEvent@CDevice@@KAKPAX@Z|
  00154		 |$M38425|

			 ENDP  ; |?GetStatusChangeBitmap@CExternalHub@@AAAHAAK@Z|, CExternalHub::GetStatusChangeBitmap

	EXPORT	|?WaitForPortStatusChange@CExternalHub@@EAAHAAEAAU_USB_HUB_AND_PORT_STATUS@@@Z| ; CExternalHub::WaitForPortStatusChange

  00000			 AREA	 |.pdata|, PDATA
|$T38452| DCD	|$LN24@WaitForPor@2|
	DCD	0x40004a02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?WaitForPortStatusChange@CExternalHub@@EAAHAAEAAU_USB_HUB_AND_PORT_STATUS@@@Z| PROC ; CExternalHub::WaitForPortStatusChange

; 3393 : {

  00000		 |$LN24@WaitForPor@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M38449|
  00008	e1a0a002	 mov         r10, r2
  0000c	e1a05001	 mov         r5, r1
  00010	e1a06000	 mov         r6, r0

; 3394 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("%s: +CExternalHub::WaitForPortStatusChange\n"),GetControllerName()) );
; 3395 : 
; 3396 :     DWORD dwStatusChangeBitmap = 0;

  00014	e3a03000	 mov         r3, #0

; 3397 :     BOOL  fSuccess = FALSE;
; 3398 : 
; 3399 :     if ( GetStatusChangeBitmap( dwStatusChangeBitmap ) ) {

  00018	e28d1000	 add         r1, sp, #0
  0001c	e58d3000	 str         r3, [sp]
  00020	e3a04000	 mov         r4, #0
  00024	eb000000	 bl          |?GetStatusChangeBitmap@CExternalHub@@AAAHAAK@Z|
  00028	e3500000	 cmp         r0, #0
  0002c	0a000039	 beq         |$LN1@WaitForPor@2|

; 3400 :         DEBUGCHK( dwStatusChangeBitmap != 0 );
; 3401 :         // see which port changed
; 3402 :         for ( rPort = 0; rPort <= m_usbHubDescriptor.bNumberOfPorts; rPort++ ) {

  00030	e3a03000	 mov         r3, #0
  00034	e59d1000	 ldr         r1, [sp]
  00038	e5c53000	 strb        r3, [r5]
  0003c	e3a00001	 mov         r0, #1
  00040		 |$LL12@WaitForPor@2|

; 3403 :             if ( dwStatusChangeBitmap & (1 << rPort) ) {

  00040	e5d53000	 ldrb        r3, [r5]
  00044	e1110310	 tst         r1, r0, lsl r3
  00048	1a000005	 bne         |$LN18@WaitForPor@2|
  0004c	e2833001	 add         r3, r3, #1
  00050	e5c53000	 strb        r3, [r5]
  00054	e20320ff	 and         r2, r3, #0xFF
  00058	e5d6306a	 ldrb        r3, [r6, #0x6A]
  0005c	e1520003	 cmp         r2, r3
  00060	9afffff6	 bls         |$LL12@WaitForPor@2|
  00064		 |$LN18@WaitForPor@2|

; 3404 :                 // deal with this port change, and report others next time around
; 3405 :                 break;
; 3406 :             }
; 3407 :         }
; 3408 :         DEBUGCHK( rPort <= m_usbHubDescriptor.bNumberOfPorts );
; 3409 : //        if (m_fIsHighSpeed) { //USB2.0 11.24.2.7 This will cause Reset squence and get speed correctly.
; 3410 : //            BOOL bResult=SetOrClearFeature(rPort,USB_REQUEST_SET_FEATURE,USB_HUB_FEATURE_PORT_RESET);
; 3411 : //            ASSERT(bResult==TRUE);
; 3412 : //        }
; 3413 :         // now we need to get the actual status change
; 3414 :         if ( GetStatus( rPort, rStatus ) ) {

  00064	e5963000	 ldr         r3, [r6]
  00068	e5d51000	 ldrb        r1, [r5]
  0006c	e1a0200a	 mov         r2, r10
  00070	e5933058	 ldr         r3, [r3, #0x58]
  00074	e1a00006	 mov         r0, r6
  00078	e1a0e00f	 mov         lr, pc
  0007c	e12fff13	 bx          r3
  00080	e3500000	 cmp         r0, #0
  00084	0a000023	 beq         |$LN1@WaitForPor@2|

; 3415 :             // we need to clear each of the changed feature flags
; 3416 :             // otherwise we will get the change notification
; 3417 :             // forever.
; 3418 :             //
; 3419 :             // For ports, each changeBit corresponds to the change
; 3420 :             // feature "changeBit | 0x10". This happens due to the
; 3421 :             // way features are numbered.
; 3422 : 
; 3423 :             UCHAR maxChangeBit = USB_HUB_FEATURE_PORT_RESET;
; 3424 :             UCHAR changeBitToClearFeature = 0x10;
; 3425 :             if ( rPort == 0 ) { // change was on the hub itself

  00088	e5d53000	 ldrb        r3, [r5]
  0008c	e3a08004	 mov         r8, #4
  00090	e3a09010	 mov         r9, #0x10
  00094	e3530000	 cmp         r3, #0

; 3426 :                 // For hubs, each changeBit corresponds directly to
; 3427 :                 // the feature "changeBit", so we | with 0.
; 3428 :                 maxChangeBit = USB_HUB_FEATURE_C_HUB_OVER_CURRENT;
; 3429 :                 changeBitToClearFeature = 0;
; 3430 :             }
; 3431 :             for ( UCHAR changeBit = 0; !m_fHubThreadClosing && changeBit <= maxChangeBit; changeBit++ ) {

  00098	e59630b8	 ldr         r3, [r6, #0xB8]
  0009c	03a08001	 moveq       r8, #1
  000a0	03a09000	 moveq       r9, #0
  000a4	e3530000	 cmp         r3, #0
  000a8	e3a07000	 mov         r7, #0
  000ac	1a000014	 bne         |$LN21@WaitForPor@2|
  000b0	e3a0b001	 mov         r11, #1
  000b4		 |$LL6@WaitForPor@2|
  000b4	e1570008	 cmp         r7, r8
  000b8	8a000011	 bhi         |$LN21@WaitForPor@2|

; 3432 :                 if ( rStatus.change.word & (1 << changeBit) ) {

  000bc	e1da30b2	 ldrh        r3, [r10, #2]
  000c0	e113071b	 tst         r3, r11, lsl r7
  000c4	0a000009	 beq         |$LN5@WaitForPor@2|

; 3433 :                     SetOrClearFeature( rPort,
; 3434 :                                        USB_REQUEST_CLEAR_FEATURE,
; 3435 :                                        changeBit | changeBitToClearFeature );

  000c8	e5962000	 ldr         r2, [r6]
  000cc	e1893007	 orr         r3, r9, r7
  000d0	e5d51000	 ldrb        r1, [r5]
  000d4	e5924050	 ldr         r4, [r2, #0x50]
  000d8	e1a03803	 mov         r3, r3, lsl #16
  000dc	e3a02001	 mov         r2, #1
  000e0	e1a03823	 mov         r3, r3, lsr #16
  000e4	e1a00006	 mov         r0, r6
  000e8	e1a0e00f	 mov         lr, pc
  000ec	e12fff14	 bx          r4
  000f0		 |$LN5@WaitForPor@2|
  000f0	e59620b8	 ldr         r2, [r6, #0xB8]
  000f4	e2873001	 add         r3, r7, #1
  000f8	e20370ff	 and         r7, r3, #0xFF
  000fc	e3520000	 cmp         r2, #0
  00100	0affffeb	 beq         |$LL6@WaitForPor@2|
  00104		 |$LN21@WaitForPor@2|

; 3436 :                     // Could add recover if this fails...
; 3437 :                 }
; 3438 :             }
; 3439 : 
; 3440 :             if(rPort > m_usbHubDescriptor.bNumberOfPorts)

  00104	e5d52000	 ldrb        r2, [r5]
  00108	e5d6306a	 ldrb        r3, [r6, #0x6A]
  0010c	e1520003	 cmp         r2, r3

; 3441 :                 fSuccess = FALSE; //Otherwise an access violation will occur.

  00110	83a04000	 movhi       r4, #0

; 3442 :             else
; 3443 :                 fSuccess = TRUE;

  00114	93a04001	 movls       r4, #1
  00118		 |$LN1@WaitForPor@2|

; 3444 :         }
; 3445 :     }
; 3446 : 
; 3447 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("%s: -CExternal::WaitForPortStatusChange, returing rPort = %d, fSuccess = %d\n"),GetControllerName(), rPort, fSuccess) );
; 3448 :     return fSuccess;
; 3449 : }

  00118	e1a00004	 mov         r0, r4
  0011c	e28dd004	 add         sp, sp, #4
  00120	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00124	e12fff1e	 bx          lr
  00128		 |$M38450|

			 ENDP  ; |?WaitForPortStatusChange@CExternalHub@@EAAHAAEAAU_USB_HUB_AND_PORT_STATUS@@@Z|, CExternalHub::WaitForPortStatusChange

	EXPORT	|?GetStatus@CExternalHub@@EAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z| ; CExternalHub::GetStatus

  00000			 AREA	 |.pdata|, PDATA
|$T38470| DCD	|$LN14@GetStatus@2|
	DCD	0x40005602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetStatus@CExternalHub@@EAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z| PROC ; CExternalHub::GetStatus

; 3466 : {

  00000		 |$LN14@GetStatus@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd04c	 sub         sp, sp, #0x4C
  00008		 |$M38467|
  00008	e1a0a002	 mov         r10, r2
  0000c	e3510000	 cmp         r1, #0
  00010	e1a09000	 mov         r9, r0
  00014	e3a03c01	 mov         r3, #1, 24

; 3467 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: +CExternalHub::GetStatus - port = %d\n"),GetControllerName(), port ));
; 3468 : 
; 3469 :     PREFAST_DEBUGCHK( m_ppCPipe != NULL);
; 3470 :     DEBUGCHK( m_maxNumPipes == 2 &&
; 3471 :               m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ] != NULL &&
; 3472 :               port <= m_usbHubDescriptor.bNumberOfPorts );
; 3473 : 
; 3474 :     BOOL                fTransferDone = FALSE;
; 3475 :     DWORD               dwBytesTransferred = 0;
; 3476 :     DWORD               dwErrorFlags = USB_NOT_COMPLETE_ERROR;

  00018	e3833003	 orr         r3, r3, #3
  0001c	e58d3040	 str         r3, [sp, #0x40]

; 3477 :     HCD_REQUEST_STATUS  status = requestFailed;
; 3478 :     USB_DEVICE_REQUEST  usbRequest;
; 3479 : 
; 3480 :     if ( port == 0 ) {
; 3481 :         // requst is to the hub iteself
; 3482 :         usbRequest.bmRequestType = USB_REQUEST_DEVICE_TO_HOST | USB_REQUEST_CLASS | USB_REQUEST_FOR_DEVICE;

  00020	03a030a0	 moveq       r3, #0xA0

; 3483 :     } else {
; 3484 :         // request is to an actual port
; 3485 :         usbRequest.bmRequestType = USB_REQUEST_DEVICE_TO_HOST | USB_REQUEST_CLASS | USB_REQUEST_FOR_OTHER;

  00024	13a030a3	 movne       r3, #0xA3
  00028	e5cd3044	 strb        r3, [sp, #0x44]

; 3486 :     }
; 3487 :     usbRequest.bRequest = USB_REQUEST_GET_STATUS;
; 3488 :     usbRequest.wValue = 0;
; 3489 :     usbRequest.wIndex = port;
; 3490 :     usbRequest.wLength = sizeof( USB_HUB_AND_PORT_STATUS );
; 3491 :     // wLength should be 4, according to USB spec 1.1 11.16.2.5/11.16.2.6
; 3492 :     DEBUGCHK( sizeof( USB_HUB_AND_PORT_STATUS ) == 4 );
; 3493 : 
; 3494 :     if ( !m_fHubThreadClosing ) {

  0002c	e59930b8	 ldr         r3, [r9, #0xB8]
  00030	e3a02000	 mov         r2, #0
  00034	e3a00000	 mov         r0, #0
  00038	e58d2038	 str         r2, [sp, #0x38]
  0003c	e58d003c	 str         r0, [sp, #0x3C]
  00040	e3a02000	 mov         r2, #0
  00044	e3a00000	 mov         r0, #0
  00048	e3a0e004	 mov         lr, #4
  0004c	e3530000	 cmp         r3, #0
  00050	e5cd2045	 strb        r2, [sp, #0x45]
  00054	e1cd04b6	 strh        r0, [sp, #0x46]
  00058	e1cd14b8	 strh        r1, [sp, #0x48]
  0005c	e1cde4ba	 strh        lr, [sp, #0x4A]
  00060	1a000037	 bne         |$LN8@GetStatus@2|

; 3495 :         status = m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ]->IssueTransfer(
; 3496 :                          m_address, // address of this hub
; 3497 :                          TransferDoneCallbackSetEvent, // callback func
; 3498 :                          m_hHubStatusChangeEvent, // callback param
; 3499 :                          USB_IN_TRANSFER | USB_SEND_TO_DEVICE, // transfer flags
; 3500 :                          &usbRequest, // control request
; 3501 :                          0, // dwStartingFrame (not used)
; 3502 :                          0, // dwFrames (not used)
; 3503 :                          NULL, // aLengths (not used)
; 3504 :                          sizeof( USB_HUB_AND_PORT_STATUS ), // buffer size
; 3505 :                          &rStatus, // buffer
; 3506 :                          0, // phys addr of buffer (not used)
; 3507 :                          this, // cancel id
; 3508 :                          NULL, // adwIsochErrors (not used)
; 3509 :                          NULL, // adwIsochLengths (not used)
; 3510 :                          &fTransferDone, // OUT param for transfer
; 3511 :                          &dwBytesTransferred, // OUT param for transfer
; 3512 :                          &dwErrorFlags ); // OUT param for transfer

  00064	e599105c	 ldr         r1, [r9, #0x5C]
  00068	e28d403c	 add         r4, sp, #0x3C
  0006c	e58d4030	 str         r4, [sp, #0x30]
  00070	e5910000	 ldr         r0, [r1]
  00074	e3a04000	 mov         r4, #0
  00078	e58d4028	 str         r4, [sp, #0x28]
  0007c	e590e000	 ldr         lr, [r0]
  00080	e58d4024	 str         r4, [sp, #0x24]
  00084	e58d401c	 str         r4, [sp, #0x1C]
  00088	e58d4010	 str         r4, [sp, #0x10]
  0008c	e58d400c	 str         r4, [sp, #0xC]
  00090	e58d4008	 str         r4, [sp, #8]
  00094	e59e800c	 ldr         r8, [lr, #0xC]
  00098	e59930bc	 ldr         r3, [r9, #0xBC]
  0009c	e59f20b0	 ldr         r2, [pc, #0xB0]
  000a0	e5d91020	 ldrb        r1, [r9, #0x20]
  000a4	e28d6040	 add         r6, sp, #0x40
  000a8	e28d5038	 add         r5, sp, #0x38
  000ac	e3a0b004	 mov         r11, #4
  000b0	e28d7044	 add         r7, sp, #0x44
  000b4	e3a04d42	 mov         r4, #0x42, 26
  000b8	e58d6034	 str         r6, [sp, #0x34]
  000bc	e58d502c	 str         r5, [sp, #0x2C]
  000c0	e58d9020	 str         r9, [sp, #0x20]
  000c4	e58da018	 str         r10, [sp, #0x18]
  000c8	e58db014	 str         r11, [sp, #0x14]
  000cc	e58d7004	 str         r7, [sp, #4]
  000d0	e58d4000	 str         r4, [sp]
  000d4	e1a0e00f	 mov         lr, pc
  000d8	e12fff18	 bx          r8

; 3513 :         if ( status == requestOK ) {

  000dc	e3500001	 cmp         r0, #1
  000e0	1a000017	 bne         |$LN8@GetStatus@2|

; 3514 :             WaitForSingleObject( m_hHubStatusChangeEvent, INFINITE );

  000e4	e59900bc	 ldr         r0, [r9, #0xBC]
  000e8	e3e01000	 mvn         r1, #0
  000ec	eb000000	 bl          WaitForSingleObject

; 3515 :             if ( m_fHubThreadClosing ) {

  000f0	e59930b8	 ldr         r3, [r9, #0xB8]
  000f4	e3530000	 cmp         r3, #0
  000f8	0a000008	 beq         |$LN1@GetStatus@2|

; 3516 :                 m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ]->AbortTransfer(
; 3517 :                                              NULL, // callback function
; 3518 :                                              NULL, // callback parameter
; 3519 :                                              this ); // cancel ID

  000fc	e599105c	 ldr         r1, [r9, #0x5C]
  00100	e1a03009	 mov         r3, r9
  00104	e3a02000	 mov         r2, #0
  00108	e5910000	 ldr         r0, [r1]
  0010c	e3a01000	 mov         r1, #0
  00110	e5904000	 ldr         r4, [r0]
  00114	e5944010	 ldr         r4, [r4, #0x10]
  00118	e1a0e00f	 mov         lr, pc
  0011c	e12fff14	 bx          r4
  00120		 |$LN1@GetStatus@2|

; 3520 :             }
; 3521 :         }
; 3522 :         DEBUGMSG(1, (TEXT("Abort Transfer for Device Address 0x%x\r\n"),
; 3523 :             m_address));
; 3524 :         DEBUGCHK( fTransferDone );
; 3525 :     }
; 3526 :     BOOL fSuccess = (status == requestOK &&
; 3527 :                      fTransferDone &&
; 3528 :                      dwBytesTransferred == sizeof( USB_HUB_AND_PORT_STATUS ) &&
; 3529 :                      dwErrorFlags == USB_NO_ERROR);

  00120	e59d3038	 ldr         r3, [sp, #0x38]
  00124	e3530000	 cmp         r3, #0
  00128	0a000005	 beq         |$LN8@GetStatus@2|
  0012c	e59d303c	 ldr         r3, [sp, #0x3C]
  00130	e3530004	 cmp         r3, #4
  00134	059d3040	 ldreq       r3, [sp, #0x40]
  00138	03530000	 cmpeq       r3, #0
  0013c	03a00001	 moveq       r0, #1
  00140	0a000000	 beq         |$LN9@GetStatus@2|
  00144		 |$LN8@GetStatus@2|
  00144	e3a00000	 mov         r0, #0
  00148		 |$LN9@GetStatus@2|

; 3530 : 
; 3531 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: -CExternalHub::GetStatus - port = %d, returing BOOL %d\n"),GetControllerName(), port, fSuccess) );
; 3532 :     return fSuccess;
; 3533 : }

  00148	e28dd04c	 add         sp, sp, #0x4C
  0014c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00150	e12fff1e	 bx          lr
  00154		 |$LN15@GetStatus@2|
  00154		 |$LN16@GetStatus@2|
  00154	00000000	 DCD         |?TransferDoneCallbackSetEvent@CDevice@@KAKPAX@Z|
  00158		 |$M38468|

			 ENDP  ; |?GetStatus@CExternalHub@@EAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z|, CExternalHub::GetStatus

	EXPORT	|?ResetAndEnablePort@CExternalHub@@EAAHE@Z| ; CExternalHub::ResetAndEnablePort

  00000			 AREA	 |.pdata|, PDATA
|$T38492| DCD	|$LN18@ResetAndEn@2|
	DCD	0x40004e02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResetAndEnablePort@CExternalHub@@EAAHE@Z| PROC ; CExternalHub::ResetAndEnablePort

; 3547 : {

  00000		 |$LN18@ResetAndEn@2|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M38489|
  00008	e1a07001	 mov         r7, r1
  0000c	e1a06000	 mov         r6, r0

; 3548 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("%s: +CExternalHub::ResetAndEnablePort - port = %d\n"),GetControllerName(), port) );
; 3549 : 
; 3550 :     DEBUGCHK( port >= 1 && port <= m_usbHubDescriptor.bNumberOfPorts );
; 3551 : 
; 3552 :     BOOL fSuccess = FALSE;
; 3553 : 
; 3554 :     if ( !SetOrClearFeature( port,
; 3555 :                             USB_REQUEST_SET_FEATURE,
; 3556 :                             USB_HUB_FEATURE_PORT_RESET ) ) {

  00010	e596e000	 ldr         lr, [r6]
  00014	e3a03004	 mov         r3, #4
  00018	e3a02003	 mov         r2, #3
  0001c	e59e4050	 ldr         r4, [lr, #0x50]
  00020	e3a05000	 mov         r5, #0
  00024	e1a0e00f	 mov         lr, pc
  00028	e12fff14	 bx          r4
  0002c	e3500000	 cmp         r0, #0

; 3557 :         DEBUGMSG( ZONE_ERROR, (TEXT("%s: -CExternalHub::ResetAndEnablePort - could set reset feature for port %d\n"),GetControllerName(), port) );
; 3558 :         return FALSE;

  00030	0a00003b	 beq         |$LN9@ResetAndEn@2|

; 3559 :     }
; 3560 :     for ( UCHAR attempt = 0; !m_fHubThreadClosing && attempt < 5; attempt++ ) {

  00034	e59630b8	 ldr         r3, [r6, #0xB8]
  00038	e3a04000	 mov         r4, #0
  0003c	e3530000	 cmp         r3, #0
  00040	1a000038	 bne         |$LN15@ResetAndEn@2|
  00044	e3a09000	 mov         r9, #0
  00048	e3a08001	 mov         r8, #1
  0004c		 |$LL5@ResetAndEn@2|
  0004c	e3540005	 cmp         r4, #5
  00050	2a000034	 bcs         |$LN15@ResetAndEn@2|

; 3561 :         DWORD   dwStatusChangeBitmap = 0;
; 3562 :         // USB2.0 11.5.1.5 20 ms resetting period.
; 3563 :         Sleep(20);

  00054	e3a00014	 mov         r0, #0x14
  00058	e58d9000	 str         r9, [sp]
  0005c	eb000000	 bl          Sleep

; 3564 :         if ( GetStatusChangeBitmap( dwStatusChangeBitmap ) &&
; 3565 :              (dwStatusChangeBitmap & (1 << port)) ) {

  00060	e28d1000	 add         r1, sp, #0
  00064	e1a00006	 mov         r0, r6
  00068	eb000000	 bl          |?GetStatusChangeBitmap@CExternalHub@@AAAHAAK@Z|
  0006c	e3500000	 cmp         r0, #0
  00070	0a000002	 beq         |$LN4@ResetAndEn@2|
  00074	e59d3000	 ldr         r3, [sp]
  00078	e1130718	 tst         r3, r8, lsl r7
  0007c	1a000005	 bne         |$LN12@ResetAndEn@2|
  00080		 |$LN4@ResetAndEn@2|

; 3559 :     }
; 3560 :     for ( UCHAR attempt = 0; !m_fHubThreadClosing && attempt < 5; attempt++ ) {

  00080	e59620b8	 ldr         r2, [r6, #0xB8]
  00084	e2843001	 add         r3, r4, #1
  00088	e20340ff	 and         r4, r3, #0xFF
  0008c	e3520000	 cmp         r2, #0
  00090	0affffed	 beq         |$LL5@ResetAndEn@2|
  00094	ea000023	 b           |$LN15@ResetAndEn@2|
  00098		 |$LN12@ResetAndEn@2|

; 3566 :             USB_HUB_AND_PORT_STATUS portStatus;
; 3567 :             fSuccess = ( GetStatus( port, portStatus ) &&
; 3568 :                          portStatus.change.port.ResetChange && // port has reset
; 3569 :                          !portStatus.status.port.PortReset && // reset no longer asserted
; 3570 :                          portStatus.status.port.PortEnabled && // port enabled
; 3571 :                          SetOrClearFeature( port, // clear reset change flag
; 3572 :                                             USB_REQUEST_CLEAR_FEATURE,
; 3573 :                                             USB_HUB_FEATURE_C_PORT_RESET ) );

  00098	e5963000	 ldr         r3, [r6]
  0009c	e28d2004	 add         r2, sp, #4
  000a0	e1a01007	 mov         r1, r7
  000a4	e5933058	 ldr         r3, [r3, #0x58]
  000a8	e1a00006	 mov         r0, r6
  000ac	e1a0e00f	 mov         lr, pc
  000b0	e12fff13	 bx          r3
  000b4	e3500000	 cmp         r0, #0
  000b8	0a000019	 beq         |$LN9@ResetAndEn@2|
  000bc	e1dd30b6	 ldrh        r3, [sp, #6]
  000c0	e3130010	 tst         r3, #0x10
  000c4	0a000016	 beq         |$LN9@ResetAndEn@2|
  000c8	e1dd20b4	 ldrh        r2, [sp, #4]
  000cc	e1a03802	 mov         r3, r2, lsl #16
  000d0	e1a03823	 mov         r3, r3, lsr #16
  000d4	e3130010	 tst         r3, #0x10
  000d8	1a000011	 bne         |$LN9@ResetAndEn@2|
  000dc	e1a03802	 mov         r3, r2, lsl #16
  000e0	e1a03823	 mov         r3, r3, lsr #16
  000e4	e3130002	 tst         r3, #2
  000e8	0a00000d	 beq         |$LN9@ResetAndEn@2|
  000ec	e5961000	 ldr         r1, [r6]
  000f0	e3a03014	 mov         r3, #0x14
  000f4	e3a02001	 mov         r2, #1
  000f8	e5914050	 ldr         r4, [r1, #0x50]
  000fc	e1a01007	 mov         r1, r7
  00100	e1a00006	 mov         r0, r6
  00104	e1a0e00f	 mov         lr, pc
  00108	e12fff14	 bx          r4
  0010c	e3500000	 cmp         r0, #0
  00110	0a000003	 beq         |$LN9@ResetAndEn@2|

; 3574 :             if (fSuccess) { // According Specification. 50 ms delay after this.
; 3575 :                 Sleep(50);

  00114	e3a00032	 mov         r0, #0x32
  00118	e3a05001	 mov         r5, #1
  0011c	eb000000	 bl          Sleep
  00120	ea000000	 b           |$LN15@ResetAndEn@2|
  00124		 |$LN9@ResetAndEn@2|

; 3566 :             USB_HUB_AND_PORT_STATUS portStatus;
; 3567 :             fSuccess = ( GetStatus( port, portStatus ) &&
; 3568 :                          portStatus.change.port.ResetChange && // port has reset
; 3569 :                          !portStatus.status.port.PortReset && // reset no longer asserted
; 3570 :                          portStatus.status.port.PortEnabled && // port enabled
; 3571 :                          SetOrClearFeature( port, // clear reset change flag
; 3572 :                                             USB_REQUEST_CLEAR_FEATURE,
; 3573 :                                             USB_HUB_FEATURE_C_PORT_RESET ) );

  00124	e3a05000	 mov         r5, #0
  00128		 |$LN15@ResetAndEn@2|

; 3576 :             }
; 3577 :             break;
; 3578 :         }
; 3579 :     }
; 3580 : #if 0
; 3581 :     while ( fSuccess && !m_fHubThreadClosing ) {
; 3582 :         // make sure reset is signalled for at least 10ms
; 3583 :         Sleep( 10 );
; 3584 :         fSuccess = !m_fHubThreadClosing && GetStatus( port, portStatus );
; 3585 :         if ( fSuccess &&
; 3586 :              portStatus.change.port.ResetChange && // port has reset
; 3587 :              !portStatus.status.port.PortReset && // reset no longer asserted
; 3588 :              portStatus.status.port.PortEnabled ) { // port enabled
; 3589 : 
; 3590 :             DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("%s: CExternalHub::ResetAndEnablePort - status.change = 0x%x, status.word = 0x%x\n"),GetControllerName(), portStatus.change.word, portStatus.status.word) );
; 3591 :             Sleep( 10 ); // give reset 10 ms to take hold
; 3592 :             break;
; 3593 :         }
; 3594 :     }
; 3595 : #endif
; 3596 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("%s: -CExternalHub::ResetAndEnablePort - port = %d, returning %d\n"),GetControllerName(), port, fSuccess ) );
; 3597 :     return fSuccess;
; 3598 : }

  00128	e1a00005	 mov         r0, r5
  0012c	e28dd008	 add         sp, sp, #8
  00130	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00134	e12fff1e	 bx          lr
  00138		 |$M38490|

			 ENDP  ; |?ResetAndEnablePort@CExternalHub@@EAAHE@Z|, CExternalHub::ResetAndEnablePort

	EXPORT	|?DisablePort@CExternalHub@@EAAXE@Z|	; CExternalHub::DisablePort

  00000			 AREA	 |.pdata|, PDATA
|$T38501| DCD	|$LN6@DisablePor@2|
	DCD	0x40000e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DisablePort@CExternalHub@@EAAXE@Z| PROC ; CExternalHub::DisablePort

; 3611 : {

  00000		 |$LN6@DisablePor@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M38498|

; 3612 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("%s: +CExternalHub::DisablePort - port = %d\n"),GetControllerName(), port) );
; 3613 : 
; 3614 :     if ( !m_fHubThreadClosing ) {

  00004	e59030b8	 ldr         r3, [r0, #0xB8]
  00008	e3530000	 cmp         r3, #0
  0000c	1a000007	 bne         |$LN1@DisablePor@2|

; 3615 :         SetOrClearFeature( port,
; 3616 :                            USB_REQUEST_CLEAR_FEATURE,
; 3617 :                            USB_HUB_FEATURE_PORT_ENABLE );

  00010	e590e000	 ldr         lr, [r0]
  00014	e3a03001	 mov         r3, #1
  00018	e3a02001	 mov         r2, #1
  0001c	e59e4050	 ldr         r4, [lr, #0x50]
  00020	e1a0e00f	 mov         lr, pc
  00024	e12fff14	 bx          r4

; 3618 :         // disable port can take time to act
; 3619 :         Sleep( 10 );

  00028	e3a0000a	 mov         r0, #0xA
  0002c	eb000000	 bl          Sleep
  00030		 |$LN1@DisablePor@2|

; 3620 :     }
; 3621 : 
; 3622 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("%s: -CExternalHub::DisablePort - port = %d\n"),GetControllerName(), port) );
; 3623 : }

  00030	e8bd4010	 ldmia       sp!, {r4, lr}
  00034	e12fff1e	 bx          lr
  00038		 |$M38499|

			 ENDP  ; |?DisablePort@CExternalHub@@EAAXE@Z|, CExternalHub::DisablePort

	EXPORT	|?SetOrClearFeature@CExternalHub@@EAAHGEG@Z| ; CExternalHub::SetOrClearFeature

  00000			 AREA	 |.pdata|, PDATA
|$T38520| DCD	|$LN14@SetOrClear@3|
	DCD	0x40005302
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetOrClearFeature@CExternalHub@@EAAHGEG@Z| PROC ; CExternalHub::SetOrClearFeature

; 3645 : {

  00000		 |$LN14@SetOrClear@3|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd04c	 sub         sp, sp, #0x4C
  00008		 |$M38517|
  00008	e1a04003	 mov         r4, r3
  0000c	e3510000	 cmp         r1, #0
  00010	e1a09000	 mov         r9, r0
  00014	e3a03c01	 mov         r3, #1, 24

; 3646 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: +CExternalHub::SetOrClearFeature - port = %d, set/clear = 0x%x, feature = 0x%x\n"),GetControllerName(), port, setOrClearFeature, feature) );
; 3647 : 
; 3648 : #ifdef DEBUG
; 3649 : {
; 3650 :     if ( setOrClearFeature == USB_REQUEST_CLEAR_FEATURE ) {
; 3651 :         if ( port == 0 ) {
; 3652 :             // USB spec 1.1, 11.16.2.2 - these are the only
; 3653 :             // features which should be cleared for ports
; 3654 :             DEBUGCHK( feature == USB_HUB_FEATURE_C_HUB_LOCAL_POWER ||
; 3655 :                       feature == USB_HUB_FEATURE_C_HUB_OVER_CURRENT ||
; 3656 :                       feature == USB_FEATURE_ENDPOINT_STALL );
; 3657 :         } else {
; 3658 :             // USB spec 1.1, 11.16.2.2 - these are the only
; 3659 :             // features which should be cleared for ports
; 3660 :             DEBUGCHK( feature == USB_HUB_FEATURE_PORT_ENABLE ||
; 3661 :                       feature == USB_HUB_FEATURE_PORT_SUSPEND ||
; 3662 :                       feature == USB_HUB_FEATURE_PORT_POWER ||
; 3663 :                       feature == USB_HUB_FEATURE_C_PORT_CONNECTION ||
; 3664 :                       feature == USB_HUB_FEATURE_C_PORT_RESET ||
; 3665 :                       feature == USB_HUB_FEATURE_C_PORT_ENABLE ||
; 3666 :                       feature == USB_HUB_FEATURE_C_PORT_SUSPEND ||
; 3667 :                       feature == USB_HUB_FEATURE_C_PORT_OVER_CURRENT );
; 3668 :         }
; 3669 :     } else if ( setOrClearFeature == USB_REQUEST_SET_FEATURE ) {
; 3670 :         // should only be setting port features
; 3671 :         DEBUGCHK( port > 0 &&
; 3672 :                   (feature == USB_HUB_FEATURE_PORT_RESET ||
; 3673 :                    feature == USB_HUB_FEATURE_PORT_SUSPEND ||
; 3674 :                    feature == USB_HUB_FEATURE_PORT_INDICATOR ||
; 3675 :                    feature == USB_HUB_FEATURE_PORT_POWER) );
; 3676 :     } else {
; 3677 :         // shouldn't be here
; 3678 :         DebugBreak();
; 3679 :     }
; 3680 :     DEBUGCHK( m_maxNumPipes == 2 && // control and status change
; 3681 :               m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ] != NULL &&
; 3682 :               port <= m_usbHubDescriptor.bNumberOfPorts );
; 3683 : }
; 3684 : #endif // DEBUG
; 3685 : 
; 3686 :     BOOL                fTransferDone = FALSE;
; 3687 :     DWORD               dwBytesTransferred = 0;
; 3688 :     DWORD               dwErrorFlags = USB_NOT_COMPLETE_ERROR;

  00018	e383e003	 orr         lr, r3, #3
  0001c	e3a03000	 mov         r3, #0
  00020	e58d3038	 str         r3, [sp, #0x38]

; 3689 :     HCD_REQUEST_STATUS  status = requestFailed;
; 3690 :     USB_DEVICE_REQUEST  usbRequest;
; 3691 :     if ( port == 0 ) {
; 3692 :         usbRequest.bmRequestType = USB_REQUEST_HOST_TO_DEVICE | USB_REQUEST_CLASS | USB_REQUEST_FOR_DEVICE;

  00024	03a03020	 moveq       r3, #0x20

; 3693 :     } else {
; 3694 :         usbRequest.bmRequestType = USB_REQUEST_HOST_TO_DEVICE | USB_REQUEST_CLASS | USB_REQUEST_FOR_OTHER;

  00028	13a03023	 movne       r3, #0x23
  0002c	e5cd3044	 strb        r3, [sp, #0x44]

; 3695 :     }
; 3696 :     usbRequest.bRequest = setOrClearFeature;
; 3697 :     usbRequest.wValue = feature;
; 3698 :     usbRequest.wIndex = port;
; 3699 :     usbRequest.wLength = 0;
; 3700 :     PREFAST_DEBUGCHK(m_ppCPipe != NULL);
; 3701 :     
; 3702 :     if ( !m_fHubThreadClosing ) {

  00030	e59930b8	 ldr         r3, [r9, #0xB8]
  00034	e3a00000	 mov         r0, #0
  00038	e58d003c	 str         r0, [sp, #0x3C]
  0003c	e3a00000	 mov         r0, #0
  00040	e3530000	 cmp         r3, #0
  00044	e58de040	 str         lr, [sp, #0x40]
  00048	e5cd2045	 strb        r2, [sp, #0x45]
  0004c	e1cd44b6	 strh        r4, [sp, #0x46]
  00050	e1cd14b8	 strh        r1, [sp, #0x48]
  00054	e1cd04ba	 strh        r0, [sp, #0x4A]
  00058	1a000036	 bne         |$LN8@SetOrClear@3|

; 3703 :         status = m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ]->IssueTransfer(
; 3704 :                          m_address, // address of this hub
; 3705 :                          TransferDoneCallbackSetEvent, // callback func
; 3706 :                          m_hHubStatusChangeEvent, // callback param
; 3707 :                          USB_OUT_TRANSFER | USB_SEND_TO_DEVICE, // transfer flags
; 3708 :                          &usbRequest, // control request
; 3709 :                          0, // dwStartingFrame (not used)
; 3710 :                          0, // dwFrames (not used)
; 3711 :                          NULL, // aLengths (not used)
; 3712 :                          0, // buffer size
; 3713 :                          NULL, // buffer
; 3714 :                          0, // phys addr of buffer (not used)
; 3715 :                          this, // cancel id
; 3716 :                          NULL, // adwIsochErrors (not used)
; 3717 :                          NULL, // adwIsochLengths (not used)
; 3718 :                          &fTransferDone, // OUT param for transfer
; 3719 :                          &dwBytesTransferred, // OUT param for transfer
; 3720 :                          &dwErrorFlags ); // OUT param for transfer

  0005c	e599105c	 ldr         r1, [r9, #0x5C]
  00060	e59930bc	 ldr         r3, [r9, #0xBC]
  00064	e59f20dc	 ldr         r2, [pc, #0xDC]
  00068	e5910000	 ldr         r0, [r1]
  0006c	e5d91020	 ldrb        r1, [r9, #0x20]
  00070	e28d6040	 add         r6, sp, #0x40
  00074	e590e000	 ldr         lr, [r0]
  00078	e28d403c	 add         r4, sp, #0x3C
  0007c	e28d5038	 add         r5, sp, #0x38
  00080	e59e800c	 ldr         r8, [lr, #0xC]
  00084	e28d7044	 add         r7, sp, #0x44
  00088	e3a0ba01	 mov         r11, #1, 20
  0008c	e3a0a000	 mov         r10, #0
  00090	e58d6034	 str         r6, [sp, #0x34]
  00094	e58d4030	 str         r4, [sp, #0x30]
  00098	e58d502c	 str         r5, [sp, #0x2C]
  0009c	e58da028	 str         r10, [sp, #0x28]
  000a0	e58da024	 str         r10, [sp, #0x24]
  000a4	e58d9020	 str         r9, [sp, #0x20]
  000a8	e58da01c	 str         r10, [sp, #0x1C]
  000ac	e58da018	 str         r10, [sp, #0x18]
  000b0	e58da014	 str         r10, [sp, #0x14]
  000b4	e58da010	 str         r10, [sp, #0x10]
  000b8	e58da00c	 str         r10, [sp, #0xC]
  000bc	e58da008	 str         r10, [sp, #8]
  000c0	e58d7004	 str         r7, [sp, #4]
  000c4	e58db000	 str         r11, [sp]
  000c8	e1a0e00f	 mov         lr, pc
  000cc	e12fff18	 bx          r8

; 3721 :         if ( status == requestOK ) {

  000d0	e3500001	 cmp         r0, #1
  000d4	1a000017	 bne         |$LN8@SetOrClear@3|

; 3722 :             WaitForSingleObject( m_hHubStatusChangeEvent,STANDARD_REQUEST_TIMEOUT);         

  000d8	e59900bc	 ldr         r0, [r9, #0xBC]
  000dc	e3a01f7d	 mov         r1, #0x7D, 30
  000e0	eb000000	 bl          WaitForSingleObject

; 3723 :             if ( m_fHubThreadClosing ) {

  000e4	e59930b8	 ldr         r3, [r9, #0xB8]
  000e8	e3530000	 cmp         r3, #0
  000ec	0a000008	 beq         |$LN1@SetOrClear@3|

; 3724 :                 m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ]->AbortTransfer(
; 3725 :                                                NULL, // callback function
; 3726 :                                                NULL, // callback parameter
; 3727 :                                                this ); // cancel ID

  000f0	e599105c	 ldr         r1, [r9, #0x5C]
  000f4	e1a03009	 mov         r3, r9
  000f8	e3a02000	 mov         r2, #0
  000fc	e5910000	 ldr         r0, [r1]
  00100	e3a01000	 mov         r1, #0
  00104	e5904000	 ldr         r4, [r0]
  00108	e5944010	 ldr         r4, [r4, #0x10]
  0010c	e1a0e00f	 mov         lr, pc
  00110	e12fff14	 bx          r4
  00114		 |$LN1@SetOrClear@3|

; 3728 :             }
; 3729 :         }
; 3730 :         //DEBUGCHK( fTransferDone );
; 3731 :     }
; 3732 :     BOOL fSuccess = (status == requestOK &&
; 3733 :                      fTransferDone &&
; 3734 :                      dwBytesTransferred == 0 &&
; 3735 :                      dwErrorFlags == USB_NO_ERROR);

  00114	e59d3038	 ldr         r3, [sp, #0x38]
  00118	e3530000	 cmp         r3, #0
  0011c	0a000005	 beq         |$LN8@SetOrClear@3|
  00120	e59d303c	 ldr         r3, [sp, #0x3C]
  00124	e3530000	 cmp         r3, #0
  00128	059d3040	 ldreq       r3, [sp, #0x40]
  0012c	03530000	 cmpeq       r3, #0
  00130	03a00001	 moveq       r0, #1
  00134	0a000000	 beq         |$LN9@SetOrClear@3|
  00138		 |$LN8@SetOrClear@3|
  00138	e3a00000	 mov         r0, #0
  0013c		 |$LN9@SetOrClear@3|

; 3736 : 
; 3737 :     DEBUGMSG( ZONE_ERROR && !fSuccess, (TEXT("%s: CExternalHub::SetOrClearFeature - port = %d, set/clear = 0x%x, feature = 0x%x, FAILED\n"),GetControllerName(), port, setOrClearFeature, feature ) );
; 3738 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: -CExternalHub::SetOrClearFeature - port = %d, set/clear = 0x%x, feature = 0x%x, returing BOOL %d\n"),GetControllerName(), port, setOrClearFeature, feature, fSuccess) );
; 3739 :     return fSuccess;
; 3740 : }

  0013c	e28dd04c	 add         sp, sp, #0x4C
  00140	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00144	e12fff1e	 bx          lr
  00148		 |$LN15@SetOrClear@3|
  00148		 |$LN16@SetOrClear@3|
  00148	00000000	 DCD         |?TransferDoneCallbackSetEvent@CDevice@@KAKPAX@Z|
  0014c		 |$M38518|

			 ENDP  ; |?SetOrClearFeature@CExternalHub@@EAAHGEG@Z|, CExternalHub::SetOrClearFeature

	EXPORT	|?SetOrClearRemoteWakup@CExternalHub@@EAAHH@Z| ; CExternalHub::SetOrClearRemoteWakup

  00000			 AREA	 |.pdata|, PDATA
|$T38540| DCD	|$LN13@SetOrClear@4|
	DCD	0x40005502
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetOrClearRemoteWakup@CExternalHub@@EAAHH@Z| PROC ; CExternalHub::SetOrClearRemoteWakup

; 3752 : {

  00000		 |$LN13@SetOrClear@4|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd04c	 sub         sp, sp, #0x4C
  00008		 |$M38537|
  00008	e3510000	 cmp         r1, #0
  0000c	e1a09000	 mov         r9, r0
  00010	e3a03c01	 mov         r3, #1, 24

; 3753 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: +CExternalHub::SetOrClearRemoteWakup - bSet = %d\r\n"),GetControllerName(), bSet) );
; 3754 : 
; 3755 :     BOOL                fTransferDone = FALSE;
; 3756 :     DWORD               dwBytesTransferred = 0;
; 3757 :     DWORD               dwErrorFlags = USB_NOT_COMPLETE_ERROR;

  00014	e3833003	 orr         r3, r3, #3
  00018	e3a02000	 mov         r2, #0

; 3758 :     HCD_REQUEST_STATUS  status = requestFailed;
; 3759 :     USB_DEVICE_REQUEST  usbRequest;
; 3760 :     
; 3761 :     usbRequest.bmRequestType = USB_REQUEST_HOST_TO_DEVICE | USB_REQUEST_FOR_DEVICE;

  0001c	e58d3040	 str         r3, [sp, #0x40]

; 3762 :     usbRequest.bRequest = (bSet? USB_REQUEST_SET_FEATURE : USB_REQUEST_CLEAR_FEATURE);
; 3763 :     usbRequest.wValue = USB_FEATURE_REMOTE_WAKEUP;
; 3764 :     usbRequest.wIndex = 0;
; 3765 :     usbRequest.wLength = 0;
; 3766 : 
; 3767 :     if ( !m_fHubThreadClosing ) {

  00020	e59930b8	 ldr         r3, [r9, #0xB8]
  00024	e3a01000	 mov         r1, #0
  00028	e3a00000	 mov         r0, #0
  0002c	e58d2038	 str         r2, [sp, #0x38]
  00030	e58d103c	 str         r1, [sp, #0x3C]
  00034	e5cd0044	 strb        r0, [sp, #0x44]
  00038	13a02003	 movne       r2, #3
  0003c	03a02001	 moveq       r2, #1
  00040	e3a01001	 mov         r1, #1
  00044	e3a00000	 mov         r0, #0
  00048	e3a0e000	 mov         lr, #0
  0004c	e3530000	 cmp         r3, #0
  00050	e5cd2045	 strb        r2, [sp, #0x45]
  00054	e1cd14b6	 strh        r1, [sp, #0x46]
  00058	e1cd04b8	 strh        r0, [sp, #0x48]
  0005c	e1cde4ba	 strh        lr, [sp, #0x4A]
  00060	1a000036	 bne         |$LN8@SetOrClear@4|

; 3768 :         status = m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ]->IssueTransfer(
; 3769 :                          m_address, // address of this hub
; 3770 :                          TransferDoneCallbackSetEvent, // callback func
; 3771 :                          m_hHubStatusChangeEvent, // callback param
; 3772 :                          USB_OUT_TRANSFER | USB_SEND_TO_DEVICE, // transfer flags
; 3773 :                          &usbRequest, // control request
; 3774 :                          0, // dwStartingFrame (not used)
; 3775 :                          0, // dwFrames (not used)
; 3776 :                          NULL, // aLengths (not used)
; 3777 :                          0, // buffer size
; 3778 :                          NULL, // buffer
; 3779 :                          0, // phys addr of buffer (not used)
; 3780 :                          this, // cancel id
; 3781 :                          NULL, // adwIsochErrors (not used)
; 3782 :                          NULL, // adwIsochLengths (not used)
; 3783 :                          &fTransferDone, // OUT param for transfer
; 3784 :                          &dwBytesTransferred, // OUT param for transfer
; 3785 :                          &dwErrorFlags ); // OUT param for transfer

  00064	e599105c	 ldr         r1, [r9, #0x5C]
  00068	e59930bc	 ldr         r3, [r9, #0xBC]
  0006c	e59f20dc	 ldr         r2, [pc, #0xDC]
  00070	e5910000	 ldr         r0, [r1]
  00074	e5d91020	 ldrb        r1, [r9, #0x20]
  00078	e28d6040	 add         r6, sp, #0x40
  0007c	e590e000	 ldr         lr, [r0]
  00080	e28d403c	 add         r4, sp, #0x3C
  00084	e28d5038	 add         r5, sp, #0x38
  00088	e59e800c	 ldr         r8, [lr, #0xC]
  0008c	e28d7044	 add         r7, sp, #0x44
  00090	e3a0ba01	 mov         r11, #1, 20
  00094	e3a0a000	 mov         r10, #0
  00098	e58d6034	 str         r6, [sp, #0x34]
  0009c	e58d4030	 str         r4, [sp, #0x30]
  000a0	e58d502c	 str         r5, [sp, #0x2C]
  000a4	e58da028	 str         r10, [sp, #0x28]
  000a8	e58da024	 str         r10, [sp, #0x24]
  000ac	e58d9020	 str         r9, [sp, #0x20]
  000b0	e58da01c	 str         r10, [sp, #0x1C]
  000b4	e58da018	 str         r10, [sp, #0x18]
  000b8	e58da014	 str         r10, [sp, #0x14]
  000bc	e58da010	 str         r10, [sp, #0x10]
  000c0	e58da00c	 str         r10, [sp, #0xC]
  000c4	e58da008	 str         r10, [sp, #8]
  000c8	e58d7004	 str         r7, [sp, #4]
  000cc	e58db000	 str         r11, [sp]
  000d0	e1a0e00f	 mov         lr, pc
  000d4	e12fff18	 bx          r8

; 3786 :         if ( status == requestOK ) {

  000d8	e3500001	 cmp         r0, #1
  000dc	1a000017	 bne         |$LN8@SetOrClear@4|

; 3787 :             WaitForSingleObject( m_hHubStatusChangeEvent, INFINITE );

  000e0	e59900bc	 ldr         r0, [r9, #0xBC]
  000e4	e3e01000	 mvn         r1, #0
  000e8	eb000000	 bl          WaitForSingleObject

; 3788 :             if ( m_fHubThreadClosing ) {

  000ec	e59930b8	 ldr         r3, [r9, #0xB8]
  000f0	e3530000	 cmp         r3, #0
  000f4	0a000008	 beq         |$LN1@SetOrClear@4|

; 3789 :                 m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ]->AbortTransfer(
; 3790 :                                                NULL, // callback function
; 3791 :                                                NULL, // callback parameter
; 3792 :                                                this ); // cancel ID

  000f8	e599105c	 ldr         r1, [r9, #0x5C]
  000fc	e1a03009	 mov         r3, r9
  00100	e3a02000	 mov         r2, #0
  00104	e5910000	 ldr         r0, [r1]
  00108	e3a01000	 mov         r1, #0
  0010c	e5904000	 ldr         r4, [r0]
  00110	e5944010	 ldr         r4, [r4, #0x10]
  00114	e1a0e00f	 mov         lr, pc
  00118	e12fff14	 bx          r4
  0011c		 |$LN1@SetOrClear@4|

; 3793 :             }
; 3794 :         }
; 3795 :         DEBUGCHK( fTransferDone );
; 3796 :     }
; 3797 :     BOOL fSuccess = (status == requestOK &&
; 3798 :                      fTransferDone &&
; 3799 :                      dwBytesTransferred == 0 &&
; 3800 :                      dwErrorFlags == USB_NO_ERROR);

  0011c	e59d3038	 ldr         r3, [sp, #0x38]
  00120	e3530000	 cmp         r3, #0
  00124	0a000005	 beq         |$LN8@SetOrClear@4|
  00128	e59d303c	 ldr         r3, [sp, #0x3C]
  0012c	e3530000	 cmp         r3, #0
  00130	059d3040	 ldreq       r3, [sp, #0x40]
  00134	03530000	 cmpeq       r3, #0
  00138	03a00001	 moveq       r0, #1
  0013c	0a000000	 beq         |$LN9@SetOrClear@4|
  00140		 |$LN8@SetOrClear@4|
  00140	e3a00000	 mov         r0, #0
  00144		 |$LN9@SetOrClear@4|

; 3801 : 
; 3802 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CExternalHub::SetOrClearRemoteWakup -  returing BOOL %d\n"),fSuccess));
; 3803 :     return fSuccess;
; 3804 :     
; 3805 : }

  00144	e28dd04c	 add         sp, sp, #0x4C
  00148	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0014c	e12fff1e	 bx          lr
  00150		 |$LN14@SetOrClear@4|
  00150		 |$LN15@SetOrClear@4|
  00150	00000000	 DCD         |?TransferDoneCallbackSetEvent@CDevice@@KAKPAX@Z|
  00154		 |$M38538|

			 ENDP  ; |?SetOrClearRemoteWakup@CExternalHub@@EAAHH@Z|, CExternalHub::SetOrClearRemoteWakup

	EXPORT	|?SignalHub@CExternalHub@@UAAXXZ|	; CExternalHub::SignalHub
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T38554| DCD	|$LN8@SignalHub@2|
	DCD	0x40000e01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SignalHub@CExternalHub@@UAAXXZ| PROC	; CExternalHub::SignalHub

; 3811 : { 

  00000		 |$LN8@SignalHub@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M38551|
  00004	e1a04000	 mov         r4, r0

; 3812 :     if (m_hHubStatusChangeEvent) 

  00008	e59430bc	 ldr         r3, [r4, #0xBC]
  0000c	e3530000	 cmp         r3, #0

; 3813 :         SetEvent(m_hHubStatusChangeEvent); 

  00010	13a01003	 movne       r1, #3
  00014	11a00003	 movne       r0, r3
  00018	1b000000	 blne        EventModify

; 3814 :     // We need to call this again so that it would go to next tier ... until the end    
; 3815 :     SignalHubStatusChange();

  0001c	e5943000	 ldr         r3, [r4]
  00020	e1a00004	 mov         r0, r4
  00024	e5933044	 ldr         r3, [r3, #0x44]
  00028	e1a0e00f	 mov         lr, pc
  0002c	e12fff13	 bx          r3

; 3816 : 
; 3817 : }

  00030	e8bd4010	 ldmia       sp!, {r4, lr}
  00034	e12fff1e	 bx          lr
  00038		 |$M38552|

			 ENDP  ; |?SignalHub@CExternalHub@@UAAXXZ|, CExternalHub::SignalHub

	EXPORT	|?NotifyOnSuspendedResumed@CFunction@@UAAHH@Z| ; CFunction::NotifyOnSuspendedResumed
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T38571| DCD	|$LN8@NotifyOnSu@3|
	DCD	0x40001701
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?NotifyOnSuspendedResumed@CFunction@@UAAHH@Z| PROC ; CFunction::NotifyOnSuspendedResumed

; 3968 : {

  00000		 |$LN8@NotifyOnSu@3|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M38568|
  00004	e1a06001	 mov         r6, r1
  00008	e1a04000	 mov         r4, r0

; 3969 :     EnterCriticalSection( &m_csDeviceLock );

  0000c	e284000c	 add         r0, r4, #0xC
  00010	eb000000	 bl          EnterCriticalSection

; 3970 :     LPUSBD_SUSPEND_RESUME_PROC pProc= m_pCHcd->GetpUSBDSuspendedResumed();

  00014	e5943068	 ldr         r3, [r4, #0x68]

; 3971 :     BOOL fSuccess = FALSE;

  00018	e3a05000	 mov         r5, #0
  0001c	e5933084	 ldr         r3, [r3, #0x84]
  00020	e1b02003	 movs        r2, r3

; 3972 :     if (pProc && m_lpvDetachId ) {

  00024	0a000007	 beq         |$LN1@NotifyOnSu@3|
  00028	e5943060	 ldr         r3, [r4, #0x60]
  0002c	e3530000	 cmp         r3, #0
  00030	0a000004	 beq         |$LN1@NotifyOnSu@3|

; 3973 :         fSuccess = (*pProc)(m_lpvDetachId, fResumed);

  00034	e1a01006	 mov         r1, r6
  00038	e1a00003	 mov         r0, r3
  0003c	e1a0e00f	 mov         lr, pc
  00040	e12fff12	 bx          r2
  00044	e1a05000	 mov         r5, r0
  00048		 |$LN1@NotifyOnSu@3|

; 3974 :     }
; 3975 :     LeaveCriticalSection( &m_csDeviceLock );

  00048	e284000c	 add         r0, r4, #0xC
  0004c	eb000000	 bl          LeaveCriticalSection

; 3976 :     return fSuccess;
; 3977 : }

  00050	e1a00005	 mov         r0, r5
  00054	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$M38569|

			 ENDP  ; |?NotifyOnSuspendedResumed@CFunction@@UAAHH@Z|, CFunction::NotifyOnSuspendedResumed

	EXPORT	|?OpenPipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IQBU_USB_ENDPOINT_DESCRIPTOR@@QAI@Z| ; CFunction::OpenPipe
	EXPORT	|??_C@_1DI@CPJNJMAA@?$AAI?$AAs?$AAo?$AAc?$AAh?$AAr?$AAo?$AAn?$AAo?$AAu?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AAe?$AAd?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|?CreateControlPipe@@YAPAVCPipeAbs@@QBU_USB_ENDPOINT_DESCRIPTOR@@HHEEEHQAVCHcd@@@Z| ; CreateControlPipe
	IMPORT	|NKDbgPrintfW|
	IMPORT	|?CreateBulkPipe@@YAPAVCPipeAbs@@QBU_USB_ENDPOINT_DESCRIPTOR@@HHEEEHQAVCHcd@@@Z| ; CreateBulkPipe
	IMPORT	|?CreateInterruptPipe@@YAPAVCPipeAbs@@QBU_USB_ENDPOINT_DESCRIPTOR@@HHEEEHQAVCHcd@@@Z| ; CreateInterruptPipe
	IMPORT	|memcmp|

  00000			 AREA	 |.pdata|, PDATA
|$T38610| DCD	|$LN42@OpenPipe@2|
	DCD	0x4000c802

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DI@CPJNJMAA@?$AAI?$AAs?$AAo?$AAc?$AAh?$AAr?$AAo?$AAn?$AAo?$AAu?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AAe?$AAd?$AA?$AN?$AA?6?$AA?$AA@| DCB "I"
	DCB	0x0, "s", 0x0, "o", 0x0, "c", 0x0, "h", 0x0, "r", 0x0, "o"
	DCB	0x0, "n", 0x0, "o", 0x0, "u", 0x0, "s", 0x0, " ", 0x0, "n"
	DCB	0x0, "o", 0x0, "t", 0x0, " ", 0x0, "s", 0x0, "u", 0x0, "p"
	DCB	0x0, "p", 0x0, "o", 0x0, "r", 0x0, "t", 0x0, "e", 0x0, "d"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OpenPipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IQBU_USB_ENDPOINT_DESCRIPTOR@@QAI@Z| PROC ; CFunction::OpenPipe

; 4002 : {

  00000		 |$LN42@OpenPipe@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd02c	 sub         sp, sp, #0x2C
  00008		 |$M38607|
  00008	e1a0b002	 mov         r11, r2
  0000c	e1a06000	 mov         r6, r0
  00010	e58db018	 str         r11, [sp, #0x18]
  00014	e58d6024	 str         r6, [sp, #0x24]
  00018	e58d301c	 str         r3, [sp, #0x1C]

; 4003 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("%s: +CFunction(tier %d)::OpenPipe - address = %d\n"),GetControllerName(), m_tierNumber, address) );
; 4004 : 
; 4005 :     HCD_REQUEST_STATUS status = requestIgnored;
; 4006 :     UCHAR pipe				  = 0;
; 4007 : 	UCHAR bNumEndpoints		  = 0;
; 4008 : 	UCHAR bEndpoint			  = 0;
; 4009 : 	UCHAR bMaxEndpoints		  = 0;
; 4010 :     int cInterfaces			  = 0;
; 4011 :     BOOL fFound				  = FALSE;
; 4012 : 
; 4013 :     // don't have to enter critical section until after checking
; 4014 :     // m_address (since m_address is const). That ensures we
; 4015 :     // won't wait for the critical section unless we actually
; 4016 :     // have something to do
; 4017 :     if ( address == m_address ) {

  0001c	e5d6e020	 ldrb        lr, [r6, #0x20]
  00020	e3a08002	 mov         r8, #2
  00024	e3a07000	 mov         r7, #0
  00028	e151000e	 cmp         r1, lr
  0002c	1a0000b6	 bne         |$LN24@OpenPipe@2|

; 4018 :         EnterCriticalSection( &m_csDeviceLock );

  00030	e286000c	 add         r0, r6, #0xC
  00034	eb000000	 bl          EnterCriticalSection

; 4019 :         // OpenPipe is referring to this device. Must return
; 4020 :         // something other than requestIgnored.
; 4021 :         status = requestFailed;
; 4022 : 
; 4023 :         PREFAST_DEBUGCHK( m_ppCPipe != NULL);
; 4024 :         DEBUGCHK( m_maxNumPipes > 0 &&
; 4025 :                   m_deviceInfo.lpActiveConfig != NULL &&
; 4026 :                   m_deviceInfo.lpActiveConfig->lpInterfaces != NULL);// &&
; 4027 : //                  m_maxNumPipes == m_deviceInfo.lpActiveConfig->lpInterfaces[0].Descriptor.bNumEndpoints + 1 );
; 4028 : 
; 4029 : //        DEBUGCHK( m_deviceInfo.lpActiveConfig->lpInterfaces[0].lpEndpoints != NULL );
; 4030 :         // There are m_maxNumPipes, but the endpoint descriptor for
; 4031 :         // the control pipe to endpoint 0 is not stored in our array of
; 4032 :         // endpoint descriptors. Thus, we only need to check
; 4033 :         // m_maxNumPipes - 1 pipes. The pipe needs to be indexed from 1,
; 4034 :         // since 0 already refers to the endpoint0 control pipe.
; 4035 : //        DEBUGCHK( m_maxNumPipes - 1 == m_deviceInfo.lpActiveConfig->lpInterfaces[0].Descriptor.bNumEndpoints );
; 4036 :         DEBUGCHK( m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ] != NULL );
; 4037 :         pipe = 0;
; 4038 :         fFound = FALSE;
; 4039 :         bMaxEndpoints = 0;
; 4040 :         cInterfaces = m_deviceInfo.lpActiveConfig->dwNumInterfaces;

  00038	e5963040	 ldr         r3, [r6, #0x40]
  0003c	e3a01000	 mov         r1, #0
  00040	e3a08000	 mov         r8, #0
  00044	e593a014	 ldr         r10, [r3, #0x14]
  00048	e5cd1011	 strb        r1, [sp, #0x11]
  0004c	e3a04000	 mov         r4, #0

; 4041 :         if (cInterfaces < 1) {

  00050	e35a0001	 cmp         r10, #1

; 4042 :             DEBUGCHK(0); // shouldn't be possible - test is here to make prefast happy.
; 4043 :             return status;

  00054	b3a08000	 movlt       r8, #0
  00058	e58da028	 str         r10, [sp, #0x28]
  0005c	e3a09000	 mov         r9, #0
  00060	ba0000a9	 blt         |$LN24@OpenPipe@2|

; 4044 :         }
; 4045 :         for ( UCHAR bInterface = 0; bInterface < cInterfaces && !fFound; bInterface++ ){

  00064	e3a05000	 mov         r5, #0
  00068	e35a0000	 cmp         r10, #0
  0006c	da0000a4	 ble         |$LN1@OpenPipe@2|
  00070		 |$LL22@OpenPipe@2|
  00070	e3540000	 cmp         r4, #0
  00074	1a00002f	 bne         |$LN35@OpenPipe@2|

; 4046 :             bNumEndpoints = m_deviceInfo.lpActiveConfig->lpInterfaces[bInterface].Descriptor.bNumEndpoints;

  00078	e5932018	 ldr         r2, [r3, #0x18]
  0007c	e0653185	 rsb         r3, r5, r5, lsl #3

; 4047 :             for(bEndpoint = 0; bEndpoint < bNumEndpoints && !fFound; bEndpoint++ ){

  00080	e3a07000	 mov         r7, #0
  00084	e0823103	 add         r3, r2, r3, lsl #2
  00088	e5d3b008	 ldrb        r11, [r3, #8]
  0008c	e58d3014	 str         r3, [sp, #0x14]
  00090	e1b0200b	 movs        r2, r11
  00094	e58d2020	 str         r2, [sp, #0x20]
  00098	0a000015	 beq         |$LN17@OpenPipe@2|
  0009c	e59da018	 ldr         r10, [sp, #0x18]
  000a0	e1a06003	 mov         r6, r3
  000a4		 |$LL19@OpenPipe@2|
  000a4	e3540000	 cmp         r4, #0
  000a8	1a00000d	 bne         |$LN36@OpenPipe@2|

; 4048 :                 if ( memcmp( &m_deviceInfo.lpActiveConfig->lpInterfaces[bInterface].lpEndpoints[ bEndpoint ].Descriptor, lpEndpointDescriptor, sizeof( USB_ENDPOINT_DESCRIPTOR ) ) == 0 ) {

  000ac	e5961014	 ldr         r1, [r6, #0x14]
  000b0	e0873107	 add         r3, r7, r7, lsl #2
  000b4	e3a02007	 mov         r2, #7
  000b8	e0813103	 add         r3, r1, r3, lsl #2
  000bc	e2830004	 add         r0, r3, #4
  000c0	e1a0100a	 mov         r1, r10
  000c4	eb000000	 bl          memcmp
  000c8	e59d2020	 ldr         r2, [sp, #0x20]
  000cc	e2873001	 add         r3, r7, #1
  000d0	e3500000	 cmp         r0, #0
  000d4	e20370ff	 and         r7, r3, #0xFF

; 4049 :                     fFound = TRUE;

  000d8	03a04001	 moveq       r4, #1
  000dc	e1570002	 cmp         r7, r2
  000e0	3affffef	 bcc         |$LL19@OpenPipe@2|
  000e4		 |$LN36@OpenPipe@2|

; 4002 : {

  000e4	e59d6024	 ldr         r6, [sp, #0x24]

; 4019 :         // OpenPipe is referring to this device. Must return
; 4020 :         // something other than requestIgnored.
; 4021 :         status = requestFailed;
; 4022 : 
; 4023 :         PREFAST_DEBUGCHK( m_ppCPipe != NULL);
; 4024 :         DEBUGCHK( m_maxNumPipes > 0 &&
; 4025 :                   m_deviceInfo.lpActiveConfig != NULL &&
; 4026 :                   m_deviceInfo.lpActiveConfig->lpInterfaces != NULL);// &&
; 4027 : //                  m_maxNumPipes == m_deviceInfo.lpActiveConfig->lpInterfaces[0].Descriptor.bNumEndpoints + 1 );
; 4028 : 
; 4029 : //        DEBUGCHK( m_deviceInfo.lpActiveConfig->lpInterfaces[0].lpEndpoints != NULL );
; 4030 :         // There are m_maxNumPipes, but the endpoint descriptor for
; 4031 :         // the control pipe to endpoint 0 is not stored in our array of
; 4032 :         // endpoint descriptors. Thus, we only need to check
; 4033 :         // m_maxNumPipes - 1 pipes. The pipe needs to be indexed from 1,
; 4034 :         // since 0 already refers to the endpoint0 control pipe.
; 4035 : //        DEBUGCHK( m_maxNumPipes - 1 == m_deviceInfo.lpActiveConfig->lpInterfaces[0].Descriptor.bNumEndpoints );
; 4036 :         DEBUGCHK( m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ] != NULL );
; 4037 :         pipe = 0;
; 4038 :         fFound = FALSE;
; 4039 :         bMaxEndpoints = 0;
; 4040 :         cInterfaces = m_deviceInfo.lpActiveConfig->dwNumInterfaces;

  000e8	e59da028	 ldr         r10, [sp, #0x28]

; 4057 :                 pipe = pipe + (UCHAR)bMaxEndpoints;

  000ec	e5dd1011	 ldrb        r1, [sp, #0x11]
  000f0	e59d3014	 ldr         r3, [sp, #0x14]
  000f4		 |$LN17@OpenPipe@2|
  000f4	e5d33007	 ldrb        r3, [r3, #7]
  000f8	e3530000	 cmp         r3, #0
  000fc	0a000002	 beq         |$LN15@OpenPipe@2|

; 4050 :                 }
; 4051 :             }
; 4052 :             if(m_deviceInfo.lpActiveConfig->lpInterfaces[bInterface].Descriptor.bAlternateSetting != 0){
; 4053 :                 if(bMaxEndpoints < bNumEndpoints)

  00100	e1590002	 cmp         r9, r2
  00104	2a000004	 bcs         |$LN21@OpenPipe@2|

; 4054 :                     bMaxEndpoints = bNumEndpoints;
; 4055 :             }
; 4056 :             else {

  00108	ea000002	 b           |$LN37@OpenPipe@2|
  0010c		 |$LN15@OpenPipe@2|

; 4057 :                 pipe = pipe + (UCHAR)bMaxEndpoints;

  0010c	e0893001	 add         r3, r9, r1
  00110	e20310ff	 and         r1, r3, #0xFF
  00114	e5cd1011	 strb        r1, [sp, #0x11]
  00118		 |$LN37@OpenPipe@2|

; 4058 :                 bMaxEndpoints = bNumEndpoints;

  00118	e1a0900b	 mov         r9, r11
  0011c		 |$LN21@OpenPipe@2|
  0011c	e2853001	 add         r3, r5, #1
  00120	e20350ff	 and         r5, r3, #0xFF
  00124	e5963040	 ldr         r3, [r6, #0x40]
  00128	e155000a	 cmp         r5, r10
  0012c	baffffcf	 blt         |$LL22@OpenPipe@2|

; 4059 :             }
; 4060 : 
; 4061 :         }
; 4062 : 
; 4063 :         DEBUGCHK(fFound);
; 4064 : 
; 4065 :         if(fFound){

  00130	e3540000	 cmp         r4, #0
  00134	0a000072	 beq         |$LN1@OpenPipe@2|
  00138		 |$LN35@OpenPipe@2|

; 4066 :             pipe = pipe + (UCHAR)bEndpoint;
; 4067 : 
; 4068 :             DEBUGMSG( ZONE_ERROR && pipe == m_maxNumPipes, (TEXT("%s: CFunction(tier %d)::OpenPipe - endpoint descriptor doesn't match any of this device's endpoints!\n"),GetControllerName(), m_tierNumber) );
; 4069 :             if ( pipe < m_maxNumPipes ) {

  00138	e5d62054	 ldrb        r2, [r6, #0x54]
  0013c	e0873001	 add         r3, r7, r1
  00140	e20370ff	 and         r7, r3, #0xFF
  00144	e1570002	 cmp         r7, r2
  00148	2a00006d	 bcs         |$LN1@OpenPipe@2|

; 4070 :                 if ( m_ppCPipe[ pipe ] != NULL ) {

  0014c	e596305c	 ldr         r3, [r6, #0x5C]
  00150	e7933107	 ldr         r3, [r3, +r7, lsl #2]
  00154	e3530000	 cmp         r3, #0

; 4071 :                     DEBUGMSG( ZONE_WARNING, (TEXT("%s: CFunction(tier %d)::OpenPipe - address %d pipe %d appears to have been opened before\n"),GetControllerName(), m_tierNumber, address, pipe) );
; 4072 :                     status = requestOK;
; 4073 :                     *lpiEndpointIndex = pipe;
; 4074 :                 } else {

  00158	1a00005a	 bne         |$LN39@OpenPipe@2|

; 4075 :                     UCHAR uTTAddress=0;
; 4076 :                     UCHAR uTTPort=0;
; 4077 :                     BOOL ttContext = NULL;
; 4078 :                     GetUSB2TT(uTTAddress, uTTPort,ttContext);

  0015c	e5963000	 ldr         r3, [r6]
  00160	e3a09000	 mov         r9, #0
  00164	e3a0a000	 mov         r10, #0
  00168	e5934034	 ldr         r4, [r3, #0x34]
  0016c	e3a05000	 mov         r5, #0
  00170	e28d3014	 add         r3, sp, #0x14
  00174	e28d2010	 add         r2, sp, #0x10
  00178	e28d1011	 add         r1, sp, #0x11
  0017c	e1a00006	 mov         r0, r6
  00180	e5cd9011	 strb        r9, [sp, #0x11]
  00184	e5cda010	 strb        r10, [sp, #0x10]
  00188	e58d5014	 str         r5, [sp, #0x14]
  0018c	e1a0e00f	 mov         lr, pc
  00190	e12fff14	 bx          r4

; 4079 :                     switch ( lpEndpointDescriptor->bmAttributes & USB_ENDPOINT_TYPE_MASK ) {

  00194	e59db018	 ldr         r11, [sp, #0x18]
  00198	e5db3003	 ldrb        r3, [r11, #3]
  0019c	e2133003	 ands        r3, r3, #3
  001a0	0a000024	 beq         |$LN5@OpenPipe@2|
  001a4	e3530001	 cmp         r3, #1
  001a8	0a00001f	 beq         |$LN3@OpenPipe@2|
  001ac	e3530002	 cmp         r3, #2
  001b0	0a00000f	 beq         |$LN6@OpenPipe@2|
  001b4	e3530003	 cmp         r3, #3
  001b8	1a00002d	 bne         |$LN7@OpenPipe@2|

; 4091 :                         break;
; 4092 :                       case USB_ENDPOINT_TYPE_INTERRUPT:
; 4093 :                         m_ppCPipe[ pipe ] = CreateInterruptPipe( lpEndpointDescriptor,
; 4094 :                                                                 m_fIsLowSpeed,m_fIsHighSpeed,m_address,
; 4095 :                                                                 uTTAddress,uTTPort,ttContext,
; 4096 :                                                                 m_pCHcd);

  001bc	e5960068	 ldr         r0, [r6, #0x68]
  001c0	e59de014	 ldr         lr, [sp, #0x14]
  001c4	e5dd4010	 ldrb        r4, [sp, #0x10]
  001c8	e5dd5011	 ldrb        r5, [sp, #0x11]
  001cc	e5d63020	 ldrb        r3, [r6, #0x20]
  001d0	e5962048	 ldr         r2, [r6, #0x48]
  001d4	e5961044	 ldr         r1, [r6, #0x44]
  001d8	e58d000c	 str         r0, [sp, #0xC]
  001dc	e1a0000b	 mov         r0, r11
  001e0	e58de008	 str         lr, [sp, #8]
  001e4	e58d4004	 str         r4, [sp, #4]
  001e8	e58d5000	 str         r5, [sp]
  001ec	eb000000	 bl          |?CreateInterruptPipe@@YAPAVCPipeAbs@@QBU_USB_ENDPOINT_DESCRIPTOR@@HHEEEHQAVCHcd@@@Z|

; 4097 :                         break;

  001f0	ea00001d	 b           |$LN38@OpenPipe@2|
  001f4		 |$LN6@OpenPipe@2|

; 4080 :                       case USB_ENDPOINT_TYPE_BULK:
; 4081 :                         m_ppCPipe[ pipe ] = CreateBulkPipe( lpEndpointDescriptor,
; 4082 :                                                            m_fIsLowSpeed,m_fIsHighSpeed,m_address,
; 4083 :                                                            uTTAddress,uTTPort,ttContext,
; 4084 :                                                            m_pCHcd);

  001f4	e5960068	 ldr         r0, [r6, #0x68]
  001f8	e59de014	 ldr         lr, [sp, #0x14]
  001fc	e5dd4010	 ldrb        r4, [sp, #0x10]
  00200	e5dd5011	 ldrb        r5, [sp, #0x11]
  00204	e5d63020	 ldrb        r3, [r6, #0x20]
  00208	e5962048	 ldr         r2, [r6, #0x48]
  0020c	e5961044	 ldr         r1, [r6, #0x44]
  00210	e58d000c	 str         r0, [sp, #0xC]
  00214	e1a0000b	 mov         r0, r11
  00218	e58de008	 str         lr, [sp, #8]
  0021c	e58d4004	 str         r4, [sp, #4]
  00220	e58d5000	 str         r5, [sp]
  00224	eb000000	 bl          |?CreateBulkPipe@@YAPAVCPipeAbs@@QBU_USB_ENDPOINT_DESCRIPTOR@@HHEEEHQAVCHcd@@@Z|

; 4085 :                         break;

  00228	ea00000f	 b           |$LN38@OpenPipe@2|
  0022c		 |$LN3@OpenPipe@2|

; 4098 :                       case USB_ENDPOINT_TYPE_ISOCHRONOUS:
; 4099 : #if 0
; 4100 :                         m_ppCPipe[ pipe ] = CreateIsochronousPipe( lpEndpointDescriptor,
; 4101 :                                                                   m_fIsLowSpeed,m_fIsHighSpeed,m_address,
; 4102 :                                                                   uTTAddress,uTTPort,ttContext,
; 4103 :                                                                   m_pCHcd);
; 4104 : #else
; 4105 :                         RETAILMSG(1, (TEXT("Isochronous not supported\r\n")));

  0022c	e59f00e8	 ldr         r0, [pc, #0xE8]
  00230	eb000000	 bl          NKDbgPrintfW

; 4106 : #endif
; 4107 :                         break;

  00234	ea00000e	 b           |$LN7@OpenPipe@2|
  00238		 |$LN5@OpenPipe@2|

; 4086 :                       case USB_ENDPOINT_TYPE_CONTROL:
; 4087 :                         m_ppCPipe[ pipe ] = CreateControlPipe( lpEndpointDescriptor,
; 4088 :                                                               m_fIsLowSpeed,m_fIsHighSpeed,m_address,
; 4089 :                                                               uTTAddress,uTTPort,ttContext,
; 4090 :                                                               m_pCHcd);

  00238	e5960068	 ldr         r0, [r6, #0x68]
  0023c	e59de014	 ldr         lr, [sp, #0x14]
  00240	e5dd4010	 ldrb        r4, [sp, #0x10]
  00244	e5dd5011	 ldrb        r5, [sp, #0x11]
  00248	e5d63020	 ldrb        r3, [r6, #0x20]
  0024c	e5962048	 ldr         r2, [r6, #0x48]
  00250	e5961044	 ldr         r1, [r6, #0x44]
  00254	e58d000c	 str         r0, [sp, #0xC]
  00258	e1a0000b	 mov         r0, r11
  0025c	e58de008	 str         lr, [sp, #8]
  00260	e58d4004	 str         r4, [sp, #4]
  00264	e58d5000	 str         r5, [sp]
  00268	eb000000	 bl          |?CreateControlPipe@@YAPAVCPipeAbs@@QBU_USB_ENDPOINT_DESCRIPTOR@@HHEEEHQAVCHcd@@@Z|
  0026c		 |$LN38@OpenPipe@2|
  0026c	e596305c	 ldr         r3, [r6, #0x5C]
  00270	e7830107	 str         r0, [r3, +r7, lsl #2]
  00274		 |$LN7@OpenPipe@2|

; 4108 : #ifdef DEBUG
; 4109 :                       default:
; 4110 :                         DebugBreak(); // shouldn't be here
; 4111 :                             break;
; 4112 : #endif // DEBUG
; 4113 :                     }
; 4114 :                     if ( m_ppCPipe[ pipe ] != NULL &&
; 4115 :                          m_ppCPipe[ pipe ]->SetReservedDeviceAddr(m_address) && 
; 4116 :                          m_ppCPipe[ pipe ]->OpenPipe() == requestOK ) {

  00274	e596305c	 ldr         r3, [r6, #0x5C]
  00278	e7933107	 ldr         r3, [r3, +r7, lsl #2]
  0027c	e3530000	 cmp         r3, #0
  00280	0a000014	 beq         |$LN2@OpenPipe@2|
  00284	e596305c	 ldr         r3, [r6, #0x5C]
  00288	e5d61020	 ldrb        r1, [r6, #0x20]
  0028c	e7930107	 ldr         r0, [r3, +r7, lsl #2]
  00290	e5903000	 ldr         r3, [r0]
  00294	e5933024	 ldr         r3, [r3, #0x24]
  00298	e1a0e00f	 mov         lr, pc
  0029c	e12fff13	 bx          r3
  002a0	e3500000	 cmp         r0, #0
  002a4	0a00000b	 beq         |$LN2@OpenPipe@2|
  002a8	e596305c	 ldr         r3, [r6, #0x5C]
  002ac	e7930107	 ldr         r0, [r3, +r7, lsl #2]
  002b0	e5903000	 ldr         r3, [r0]
  002b4	e5933004	 ldr         r3, [r3, #4]
  002b8	e1a0e00f	 mov         lr, pc
  002bc	e12fff13	 bx          r3
  002c0	e3500001	 cmp         r0, #1
  002c4	1a000003	 bne         |$LN2@OpenPipe@2|
  002c8		 |$LN39@OpenPipe@2|

; 4117 :                         DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("%s: CFunction(tier %d)::OpenPipe - opened new pipe, address %d, pipe %d\n"),GetControllerName(), m_tierNumber, address, pipe ) );
; 4118 :                         status = requestOK;
; 4119 :                         *lpiEndpointIndex = pipe;

  002c8	e59d301c	 ldr         r3, [sp, #0x1C]
  002cc	e3a08001	 mov         r8, #1
  002d0	e5837000	 str         r7, [r3]

; 4120 :                     } else {

  002d4	ea00000a	 b           |$LN1@OpenPipe@2|
  002d8		 |$LN2@OpenPipe@2|

; 4121 :                         delete m_ppCPipe[ pipe ];

  002d8	e596305c	 ldr         r3, [r6, #0x5C]
  002dc	e7933107	 ldr         r3, [r3, +r7, lsl #2]
  002e0	e1b00003	 movs        r0, r3
  002e4	15903000	 ldrne       r3, [r0]
  002e8	13a01001	 movne       r1, #1
  002ec	15933000	 ldrne       r3, [r3]
  002f0	11a0e00f	 movne       lr, pc
  002f4	112fff13	 bxne        r3

; 4122 :                         m_ppCPipe[ pipe ] = NULL;

  002f8	e596305c	 ldr         r3, [r6, #0x5C]
  002fc	e3a02000	 mov         r2, #0
  00300	e7832107	 str         r2, [r3, +r7, lsl #2]
  00304		 |$LN1@OpenPipe@2|

; 4123 :                     }
; 4124 :                 }
; 4125 :             }
; 4126 :         }
; 4127 :         LeaveCriticalSection( &m_csDeviceLock );

  00304	e286000c	 add         r0, r6, #0xC
  00308	eb000000	 bl          LeaveCriticalSection
  0030c		 |$LN24@OpenPipe@2|

; 4128 :     }
; 4129 : 
; 4130 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("%s: -CFunction(tier %d)::OpenPipe - address = %d, returing HCD_REQUEST_STATUS %d\n"),GetControllerName(), m_tierNumber, address, status) );
; 4131 :     return status;
; 4132 : }

  0030c	e1a00008	 mov         r0, r8
  00310	e28dd02c	 add         sp, sp, #0x2C
  00314	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00318	e12fff1e	 bx          lr
  0031c		 |$LN43@OpenPipe@2|
  0031c		 |$LN44@OpenPipe@2|
  0031c	00000000	 DCD         |??_C@_1DI@CPJNJMAA@?$AAI?$AAs?$AAo?$AAc?$AAh?$AAr?$AAo?$AAn?$AAo?$AAu?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AAe?$AAd?$AA?$AN?$AA?6?$AA?$AA@|
  00320		 |$M38608|

			 ENDP  ; |?OpenPipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IQBU_USB_ENDPOINT_DESCRIPTOR@@QAI@Z|, CFunction::OpenPipe

	EXPORT	|?ClosePipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@II@Z| ; CFunction::ClosePipe

  00000			 AREA	 |.pdata|, PDATA
|$T38630| DCD	|$LN9@ClosePipe@2|
	DCD	0x40002801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ClosePipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@II@Z| PROC ; CFunction::ClosePipe

; 4151 : {

  00000		 |$LN9@ClosePipe@2|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M38627|
  00004	e1a05002	 mov         r5, r2
  00008	e1a04000	 mov         r4, r0

; 4152 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("%s: +CFunction(tier %d)::ClosePipe - address = %d, pipe = %d\n"),GetControllerName(), m_tierNumber, address, pipeIndex) );
; 4153 : 
; 4154 :     HCD_REQUEST_STATUS status = requestIgnored;
; 4155 : 
; 4156 : 
; 4157 :     // don't have to enter critical section until after checking
; 4158 :     // m_address (since m_address is const). That ensures we
; 4159 :     // won't wait for the critical section unless we actually
; 4160 :     // have something to do
; 4161 :     if ( address == m_address ) {

  0000c	e5d43020	 ldrb        r3, [r4, #0x20]
  00010	e3a06002	 mov         r6, #2
  00014	e1510003	 cmp         r1, r3
  00018	1a00001d	 bne         |$LN2@ClosePipe@2|

; 4162 :         EnterCriticalSection( &m_csDeviceLock );

  0001c	e284000c	 add         r0, r4, #0xC
  00020	eb000000	 bl          EnterCriticalSection

; 4163 :         status = requestOK; // if the pipe doesn't exists, we can return
; 4164 :                             // that ClosePipe worked
; 4165 :         if ( pipeIndex < m_maxNumPipes && m_ppCPipe[ pipeIndex ] != NULL ) {

  00024	e5d43054	 ldrb        r3, [r4, #0x54]
  00028	e3a06001	 mov         r6, #1
  0002c	e1550003	 cmp         r5, r3
  00030	2a000015	 bcs         |$LN1@ClosePipe@2|
  00034	e594305c	 ldr         r3, [r4, #0x5C]
  00038	e7933105	 ldr         r3, [r3, +r5, lsl #2]
  0003c	e3530000	 cmp         r3, #0
  00040	0a000011	 beq         |$LN1@ClosePipe@2|

; 4166 :             status = m_ppCPipe[ pipeIndex ]->ClosePipe( );

  00044	e594305c	 ldr         r3, [r4, #0x5C]
  00048	e7930105	 ldr         r0, [r3, +r5, lsl #2]
  0004c	e5903000	 ldr         r3, [r0]
  00050	e5933008	 ldr         r3, [r3, #8]
  00054	e1a0e00f	 mov         lr, pc
  00058	e12fff13	 bx          r3

; 4167 :             DEBUGMSG( ZONE_FUNCTION, (TEXT("%s: CFunction(tier %d)::ClosePipe - address = %d, deleting pipe %d\n"),GetControllerName(), m_tierNumber, address, pipeIndex) );
; 4168 :             delete m_ppCPipe[ pipeIndex ];

  0005c	e594305c	 ldr         r3, [r4, #0x5C]
  00060	e1a06000	 mov         r6, r0
  00064	e7933105	 ldr         r3, [r3, +r5, lsl #2]
  00068	e1b00003	 movs        r0, r3
  0006c	15903000	 ldrne       r3, [r0]
  00070	13a01001	 movne       r1, #1
  00074	15933000	 ldrne       r3, [r3]
  00078	11a0e00f	 movne       lr, pc
  0007c	112fff13	 bxne        r3

; 4169 :             m_ppCPipe[ pipeIndex ] = NULL;

  00080	e594305c	 ldr         r3, [r4, #0x5C]
  00084	e3a02000	 mov         r2, #0
  00088	e7832105	 str         r2, [r3, +r5, lsl #2]
  0008c		 |$LN1@ClosePipe@2|

; 4170 :         }
; 4171 :     #ifdef DEBUG
; 4172 :         else {
; 4173 :             DEBUGMSG( ZONE_WARNING, (TEXT("%s: CFunction(tier %d)::ClosePipe - warning, pipe does not exist. Returning requestOK\n"),GetControllerName(), m_tierNumber) );
; 4174 :         }
; 4175 :     #endif // DEBUG
; 4176 :         LeaveCriticalSection( &m_csDeviceLock );

  0008c	e284000c	 add         r0, r4, #0xC
  00090	eb000000	 bl          LeaveCriticalSection
  00094		 |$LN2@ClosePipe@2|

; 4177 :     }
; 4178 : 
; 4179 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("%s: -CFunction(tier %d)::ClosePipe - address = %d, pipe = %d, returing HCD_REQUEST_STATUS %d\n"),GetControllerName(), m_tierNumber, address, pipeIndex, status) );
; 4180 :     return status;
; 4181 : }

  00094	e1a00006	 mov         r0, r6
  00098	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$M38628|

			 ENDP  ; |?ClosePipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|, CFunction::ClosePipe

	EXPORT	|?IssueTransfer@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z| ; CFunction::IssueTransfer
	EXPORT	|??_C@_1LG@HEEINJNP@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAI?$AAs?$AAs?$AAu?$AAe?$AAT?$AAr?$AAa@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T38646| DCD	|$LN11@IssueTrans@2|
	DCD	0x40005002

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1LG@HEEINJNP@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAI?$AAs?$AAs?$AAu?$AAe?$AAT?$AAr?$AAa@| DCB "!"
	DCB	0x0, "!", 0x0, "!", 0x0, "C", 0x0, "F", 0x0, "u", 0x0, "n"
	DCB	0x0, "c", 0x0, "t", 0x0, "i", 0x0, "o", 0x0, "n", 0x0, "("
	DCB	0x0, " ", 0x0, "t", 0x0, "i", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, ")", 0x0, ":", 0x0, ":", 0x0, "I"
	DCB	0x0, "s", 0x0, "s", 0x0, "u", 0x0, "e", 0x0, "T", 0x0, "r"
	DCB	0x0, "a", 0x0, "n", 0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r"
	DCB	0x0, " ", 0x0, "o", 0x0, "n", 0x0, " ", 0x0, "s", 0x0, "u"
	DCB	0x0, "s", 0x0, "p", 0x0, "e", 0x0, "n", 0x0, "d", 0x0, " "
	DCB	0x0, "s", 0x0, "t", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, " "
	DCB	0x0, "i", 0x0, "s", 0x0, " ", 0x0, "i", 0x0, "l", 0x0, "l"
	DCB	0x0, "g", 0x0, "l", 0x0, "e", 0x0, ",", 0x0, " ", 0x0, "a"
	DCB	0x0, "d", 0x0, "d", 0x0, "r", 0x0, "e", 0x0, "s", 0x0, "s"
	DCB	0x0, " ", 0x0, "=", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ","
	DCB	0x0, " ", 0x0, "p", 0x0, "i", 0x0, "p", 0x0, "e", 0x0, " "
	DCB	0x0, "=", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IssueTransfer@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z| PROC ; CFunction::IssueTransfer

; 4218 : {

  00000		 |$LN11@IssueTrans@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd048	 sub         sp, sp, #0x48
  00008		 |$M38643|
  00008	e1a07001	 mov         r7, r1
  0000c	e1a04000	 mov         r4, r0
  00010	e58d703c	 str         r7, [sp, #0x3C]
  00014	e58d4044	 str         r4, [sp, #0x44]
  00018	e58d3038	 str         r3, [sp, #0x38]
  0001c	e1a05002	 mov         r5, r2

; 4219 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("+CFunction(tier %d)::IssueTransfer\n"), m_tierNumber));
; 4220 : 
; 4221 :     HCD_REQUEST_STATUS status = requestIgnored;
; 4222 : 
; 4223 :     // don't have to enter critical section until after checking
; 4224 :     // m_address (since m_address is const). That ensures we
; 4225 :     // won't wait for the critical section unless we actually
; 4226 :     // have something to do
; 4227 :     if ( address == m_address ) {

  00020	e5d4e020	 ldrb        lr, [r4, #0x20]
  00024	e3a06002	 mov         r6, #2
  00028	e157000e	 cmp         r7, lr
  0002c	1a00003e	 bne         |$LN4@IssueTrans@2|

; 4228 :         EnterCriticalSection( &m_csDeviceLock );

  00030	e284000c	 add         r0, r4, #0xC
  00034	eb000000	 bl          EnterCriticalSection

; 4229 :         status = requestFailed;
; 4230 :         if (m_fIsSuspend ) {

  00038	e594e058	 ldr         lr, [r4, #0x58]
  0003c	e3a06000	 mov         r6, #0
  00040	e35e0000	 cmp         lr, #0
  00044	0a000005	 beq         |$LN3@IssueTrans@2|

; 4231 :             RETAILMSG(1,(TEXT("!!!CFunction( tier %d)::IssueTransfer on suspend state is illgle, address = %d, pipe = %d\n"), m_tierNumber, address, pipeIndex));

  00048	e5d4104c	 ldrb        r1, [r4, #0x4C]
  0004c	e59f00e8	 ldr         r0, [pc, #0xE8]
  00050	e1a03005	 mov         r3, r5
  00054	e1a02007	 mov         r2, r7
  00058	eb000000	 bl          NKDbgPrintfW

; 4232 :             ASSERT(FALSE);
; 4233 :         }
; 4234 :         else

  0005c	ea000030	 b           |$LN1@IssueTrans@2|
  00060		 |$LN3@IssueTrans@2|

; 4235 :         if ( pipeIndex < m_maxNumPipes && m_ppCPipe[ pipeIndex ] != NULL ) {

  00060	e5d43054	 ldrb        r3, [r4, #0x54]
  00064	e1550003	 cmp         r5, r3
  00068	2a00002d	 bcs         |$LN1@IssueTrans@2|
  0006c	e594305c	 ldr         r3, [r4, #0x5C]
  00070	e7933105	 ldr         r3, [r3, +r5, lsl #2]
  00074	e3530000	 cmp         r3, #0
  00078	0a000029	 beq         |$LN1@IssueTrans@2|

; 4236 :             DEBUGMSG(ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("CFunction::IssueTransfer => pipeIndex[%d], size[%d], dir[%s]\r\n"),
; 4237 :                 pipeIndex, dwBufferSize, ((dwFlags & USB_IN_TRANSFER)? TEXT("IN"):TEXT("OUT"))));
; 4238 :             status = m_ppCPipe[ pipeIndex ]->IssueTransfer(
; 4239 :                                                         (UCHAR)address,
; 4240 :                                                         lpStartAddress,
; 4241 :                                                         lpvNotifyParameter,
; 4242 :                                                         dwFlags,
; 4243 :                                                         lpvControlHeader,
; 4244 :                                                         dwStartingFrame,
; 4245 :                                                         dwFrames,
; 4246 :                                                         aLengths,
; 4247 :                                                         dwBufferSize,
; 4248 :                                                         lpvBuffer,
; 4249 :                                                         paBuffer,
; 4250 :                                                         lpvCancelId,
; 4251 :                                                         adwIsochErrors,
; 4252 :                                                         adwIsochLengths,
; 4253 :                                                         lpfComplete,
; 4254 :                                                         lpdwBytesTransfered,
; 4255 :                                                         lpdwError );

  0007c	e594305c	 ldr         r3, [r4, #0x5C]
  00080	e59d40a4	 ldr         r4, [sp, #0xA4]
  00084	e59d608c	 ldr         r6, [sp, #0x8C]
  00088	e7930105	 ldr         r0, [r3, +r5, lsl #2]
  0008c	e58d4034	 str         r4, [sp, #0x34]
  00090	e59d40a0	 ldr         r4, [sp, #0xA0]
  00094	e5903000	 ldr         r3, [r0]
  00098	e59d5090	 ldr         r5, [sp, #0x90]
  0009c	e58d4030	 str         r4, [sp, #0x30]
  000a0	e59d409c	 ldr         r4, [sp, #0x9C]
  000a4	e593300c	 ldr         r3, [r3, #0xC]
  000a8	e59d7088	 ldr         r7, [sp, #0x88]
  000ac	e58d402c	 str         r4, [sp, #0x2C]
  000b0	e59d4098	 ldr         r4, [sp, #0x98]
  000b4	e58d3040	 str         r3, [sp, #0x40]
  000b8	e59d8084	 ldr         r8, [sp, #0x84]
  000bc	e58d4028	 str         r4, [sp, #0x28]
  000c0	e59d4094	 ldr         r4, [sp, #0x94]
  000c4	e59d9080	 ldr         r9, [sp, #0x80]
  000c8	e59da07c	 ldr         r10, [sp, #0x7C]
  000cc	e58d4024	 str         r4, [sp, #0x24]
  000d0	e59d4074	 ldr         r4, [sp, #0x74]
  000d4	e59db078	 ldr         r11, [sp, #0x78]
  000d8	e59d103c	 ldr         r1, [sp, #0x3C]
  000dc	e58d4004	 str         r4, [sp, #4]
  000e0	e59d4070	 ldr         r4, [sp, #0x70]
  000e4	e59d306c	 ldr         r3, [sp, #0x6C]
  000e8	e59d2038	 ldr         r2, [sp, #0x38]
  000ec	e58d4000	 str         r4, [sp]
  000f0	e59d4040	 ldr         r4, [sp, #0x40]
  000f4	e20110ff	 and         r1, r1, #0xFF
  000f8	e58d5020	 str         r5, [sp, #0x20]
  000fc	e58d601c	 str         r6, [sp, #0x1C]
  00100	e58d7018	 str         r7, [sp, #0x18]
  00104	e58d8014	 str         r8, [sp, #0x14]
  00108	e58d9010	 str         r9, [sp, #0x10]
  0010c	e58da00c	 str         r10, [sp, #0xC]
  00110	e58db008	 str         r11, [sp, #8]
  00114	e1a0e00f	 mov         lr, pc
  00118	e12fff14	 bx          r4
  0011c	e59d4044	 ldr         r4, [sp, #0x44]
  00120	e1a06000	 mov         r6, r0
  00124		 |$LN1@IssueTrans@2|

; 4256 :         }
; 4257 :         LeaveCriticalSection( &m_csDeviceLock );

  00124	e284000c	 add         r0, r4, #0xC
  00128	eb000000	 bl          LeaveCriticalSection
  0012c		 |$LN4@IssueTrans@2|

; 4258 :     }
; 4259 : 
; 4260 : 
; 4261 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("%s: -CFunction(tier %d)::IssueTransfer - returing HCD_REQUEST_STATUS %d\n"),GetControllerName(), m_tierNumber, status ) );
; 4262 :     return status;
; 4263 : }

  0012c	e1a00006	 mov         r0, r6
  00130	e28dd048	 add         sp, sp, #0x48
  00134	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00138	e12fff1e	 bx          lr
  0013c		 |$LN12@IssueTrans@2|
  0013c		 |$LN13@IssueTrans@2|
  0013c	00000000	 DCD         |??_C@_1LG@HEEINJNP@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAI?$AAs?$AAs?$AAu?$AAe?$AAT?$AAr?$AAa@|
  00140		 |$M38644|

			 ENDP  ; |?IssueTransfer@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z|, CFunction::IssueTransfer

	EXPORT	|?AbortTransfer@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXQBX@Z| ; CFunction::AbortTransfer

  00000			 AREA	 |.pdata|, PDATA
|$T38662| DCD	|$LN7@AbortTrans@2|
	DCD	0x40002101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AbortTransfer@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXQBX@Z| PROC ; CFunction::AbortTransfer

; 4286 : {

  00000		 |$LN7@AbortTrans@2|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M38659|
  00004	e1a07003	 mov         r7, r3
  00008	e1a06002	 mov         r6, r2
  0000c	e1a05000	 mov         r5, r0

; 4287 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("%s: +CFunction(tier %d)::AbortTransfer - address = %d, pipe = %d\n"),GetControllerName(), m_tierNumber, address, pipeIndex) );
; 4288 : 
; 4289 :     HCD_REQUEST_STATUS status = requestIgnored;
; 4290 : 
; 4291 :     // don't have to enter critical section until after checking
; 4292 :     // m_address (since m_address is const). That ensures we
; 4293 :     // won't wait for the critical section unless we actually
; 4294 :     // have something to do
; 4295 :     if ( address == m_address ) {

  00010	e5d5e020	 ldrb        lr, [r5, #0x20]
  00014	e3a04002	 mov         r4, #2
  00018	e151000e	 cmp         r1, lr
  0001c	1a000015	 bne         |$LN2@AbortTrans@2|

; 4296 :         EnterCriticalSection( &m_csDeviceLock );

  00020	e285000c	 add         r0, r5, #0xC
  00024	eb000000	 bl          EnterCriticalSection

; 4297 :         status = requestFailed;
; 4298 :         if ( pipeIndex < m_maxNumPipes && m_ppCPipe[ pipeIndex ] != NULL ) {

  00028	e5d51054	 ldrb        r1, [r5, #0x54]
  0002c	e3a04000	 mov         r4, #0
  00030	e1560001	 cmp         r6, r1
  00034	2a00000d	 bcs         |$LN1@AbortTrans@2|
  00038	e595105c	 ldr         r1, [r5, #0x5C]
  0003c	e7911106	 ldr         r1, [r1, +r6, lsl #2]
  00040	e3510000	 cmp         r1, #0
  00044	0a000009	 beq         |$LN1@AbortTrans@2|

; 4299 :             status = m_ppCPipe[ pipeIndex ]->AbortTransfer( lpCancelAddress,
; 4300 :                                                             lpvNotifyParameter,
; 4301 :                                                             lpvCancelId );

  00048	e595105c	 ldr         r1, [r5, #0x5C]
  0004c	e59d3018	 ldr         r3, [sp, #0x18]
  00050	e59d2014	 ldr         r2, [sp, #0x14]
  00054	e7910106	 ldr         r0, [r1, +r6, lsl #2]
  00058	e1a01007	 mov         r1, r7
  0005c	e5904000	 ldr         r4, [r0]
  00060	e5944010	 ldr         r4, [r4, #0x10]
  00064	e1a0e00f	 mov         lr, pc
  00068	e12fff14	 bx          r4
  0006c	e1a04000	 mov         r4, r0
  00070		 |$LN1@AbortTrans@2|

; 4302 :         }
; 4303 :         LeaveCriticalSection( &m_csDeviceLock );

  00070	e285000c	 add         r0, r5, #0xC
  00074	eb000000	 bl          LeaveCriticalSection
  00078		 |$LN2@AbortTrans@2|

; 4304 :     }
; 4305 : 
; 4306 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("%s: -CFunction(tier %d)::AbortTransfer - address = %d, pipe = %d, returing HCD_REQUEST_STATUS %d\n"),GetControllerName(), m_tierNumber, address, pipeIndex, status) );
; 4307 :     return status;
; 4308 : }

  00078	e1a00004	 mov         r0, r4
  0007c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00080	e12fff1e	 bx          lr
  00084		 |$M38660|

			 ENDP  ; |?AbortTransfer@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXQBX@Z|, CFunction::AbortTransfer

	EXPORT	|?IsPipeHalted@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQAH@Z| ; CFunction::IsPipeHalted
	EXPORT	|??_C@_1LE@DHENCBPM@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAI?$AAs?$AAP?$AAi?$AAp?$AAe?$AAH?$AAa@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T38678| DCD	|$LN11@IsPipeHalt@2|
	DCD	0x40002a01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1LE@DHENCBPM@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAI?$AAs?$AAP?$AAi?$AAp?$AAe?$AAH?$AAa@| DCB "!"
	DCB	0x0, "!", 0x0, "!", 0x0, "C", 0x0, "F", 0x0, "u", 0x0, "n"
	DCB	0x0, "c", 0x0, "t", 0x0, "i", 0x0, "o", 0x0, "n", 0x0, "("
	DCB	0x0, " ", 0x0, "t", 0x0, "i", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, ")", 0x0, ":", 0x0, ":", 0x0, "I"
	DCB	0x0, "s", 0x0, "P", 0x0, "i", 0x0, "p", 0x0, "e", 0x0, "H"
	DCB	0x0, "a", 0x0, "l", 0x0, "t", 0x0, "e", 0x0, "d", 0x0, " "
	DCB	0x0, "o", 0x0, "n", 0x0, " ", 0x0, "s", 0x0, "u", 0x0, "s"
	DCB	0x0, "p", 0x0, "e", 0x0, "n", 0x0, "d", 0x0, " ", 0x0, "s"
	DCB	0x0, "t", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, " ", 0x0, "i"
	DCB	0x0, "s", 0x0, " ", 0x0, "i", 0x0, "l", 0x0, "l", 0x0, "g"
	DCB	0x0, "l", 0x0, "e", 0x0, ",", 0x0, " ", 0x0, "a", 0x0, "d"
	DCB	0x0, "d", 0x0, "r", 0x0, "e", 0x0, "s", 0x0, "s", 0x0, " "
	DCB	0x0, "=", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ",", 0x0, " "
	DCB	0x0, "p", 0x0, "i", 0x0, "p", 0x0, "e", 0x0, " ", 0x0, "="
	DCB	0x0, " ", 0x0, "%", 0x0, "d", 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsPipeHalted@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQAH@Z| PROC ; CFunction::IsPipeHalted

; 4329 : {

  00000		 |$LN11@IsPipeHalt@2|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M38675|
  00004	e1a08003	 mov         r8, r3
  00008	e1a05002	 mov         r5, r2
  0000c	e1a07001	 mov         r7, r1
  00010	e1a04000	 mov         r4, r0

; 4330 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("%s: +CFunction(tier %d)::IsPipeHalted - address = %d, pipe = %d\n"),GetControllerName(), m_tierNumber, address, pipeIndex) );
; 4331 : 
; 4332 :     HCD_REQUEST_STATUS status = requestIgnored;
; 4333 : 
; 4334 :     // don't have to enter critical section until after checking
; 4335 :     // m_address (since m_address is const). That ensures we
; 4336 :     // won't wait for the critical section unless we actually
; 4337 :     // have something to do
; 4338 :     if ( address == m_address ) {

  00014	e5d4e020	 ldrb        lr, [r4, #0x20]
  00018	e3a06002	 mov         r6, #2
  0001c	e157000e	 cmp         r7, lr
  00020	1a00001c	 bne         |$LN4@IsPipeHalt@2|

; 4339 :         EnterCriticalSection( &m_csDeviceLock );

  00024	e284000c	 add         r0, r4, #0xC
  00028	eb000000	 bl          EnterCriticalSection

; 4340 :         status = requestFailed;
; 4341 :         if (m_fIsSuspend ) {

  0002c	e594e058	 ldr         lr, [r4, #0x58]
  00030	e3a06000	 mov         r6, #0
  00034	e35e0000	 cmp         lr, #0
  00038	0a000005	 beq         |$LN3@IsPipeHalt@2|

; 4342 :             RETAILMSG(1,(TEXT("!!!CFunction( tier %d)::IsPipeHalted on suspend state is illgle, address = %d, pipe = %d\n"), m_tierNumber, address, pipeIndex));

  0003c	e5d4104c	 ldrb        r1, [r4, #0x4C]
  00040	e59f005c	 ldr         r0, [pc, #0x5C]
  00044	e1a03005	 mov         r3, r5
  00048	e1a02007	 mov         r2, r7
  0004c	eb000000	 bl          NKDbgPrintfW

; 4343 :             ASSERT(FALSE);
; 4344 :         }
; 4345 :         else

  00050	ea00000e	 b           |$LN1@IsPipeHalt@2|
  00054		 |$LN3@IsPipeHalt@2|

; 4346 :         if ( pipeIndex < m_maxNumPipes && m_ppCPipe[ pipeIndex ] != NULL ) {

  00054	e5d43054	 ldrb        r3, [r4, #0x54]
  00058	e1550003	 cmp         r5, r3
  0005c	2a00000b	 bcs         |$LN1@IsPipeHalt@2|
  00060	e594305c	 ldr         r3, [r4, #0x5C]
  00064	e7933105	 ldr         r3, [r3, +r5, lsl #2]
  00068	e3530000	 cmp         r3, #0
  0006c	0a000007	 beq         |$LN1@IsPipeHalt@2|

; 4347 :             status = m_ppCPipe[ pipeIndex ]->IsPipeHalted( lpbHalted );

  00070	e594305c	 ldr         r3, [r4, #0x5C]
  00074	e1a01008	 mov         r1, r8
  00078	e7930105	 ldr         r0, [r3, +r5, lsl #2]
  0007c	e5903000	 ldr         r3, [r0]
  00080	e5933014	 ldr         r3, [r3, #0x14]
  00084	e1a0e00f	 mov         lr, pc
  00088	e12fff13	 bx          r3
  0008c	e1a06000	 mov         r6, r0
  00090		 |$LN1@IsPipeHalt@2|

; 4348 :         }
; 4349 :         LeaveCriticalSection( &m_csDeviceLock );

  00090	e284000c	 add         r0, r4, #0xC
  00094	eb000000	 bl          LeaveCriticalSection
  00098		 |$LN4@IsPipeHalt@2|

; 4350 :     }
; 4351 : 
; 4352 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("%s: -CFunction(tier %d)::IsPipeHalted - address = %d, pipe = %d, returing HCD_REQUEST_STATUS %d\n"),GetControllerName(), m_tierNumber, address, pipeIndex, status) );
; 4353 :     return status;
; 4354 : }

  00098	e1a00006	 mov         r0, r6
  0009c	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000a0	e12fff1e	 bx          lr
  000a4		 |$LN12@IsPipeHalt@2|
  000a4		 |$LN13@IsPipeHalt@2|
  000a4	00000000	 DCD         |??_C@_1LE@DHENCBPM@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAI?$AAs?$AAP?$AAi?$AAp?$AAe?$AAH?$AAa@|
  000a8		 |$M38676|

			 ENDP  ; |?IsPipeHalted@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQAH@Z|, CFunction::IsPipeHalted

	EXPORT	|?HandleDetach@CFunction@@EAAXXZ|	; CFunction::HandleDetach
	IMPORT	|__C_specific_handler|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T38719| DCD	|$LN30@HandleDeta@2|
	DCD	0xc0003c03

  00000			 AREA	 |.pdata|, PDATA
|$T38721| DCD	|$LN12@HandleDeta@2|
	DCD	0x40000301

  00000			 AREA	 |.xdata|, DATA
|$T38717| DCD	0x1
	DCD	|$LN16@HandleDeta@2|
	DCD	|$LN17@HandleDeta@2|
	DCD	|$LN12@HandleDeta@2|
	DCD	|$LN13@HandleDeta@2|
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T38717|

  00008		 |?HandleDetach@CFunction@@EAAXXZ| PROC	; CFunction::HandleDetach

; 4427 : {

  00008		 |$LN30@HandleDeta@2|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d58f0	 stmdb       sp!, {r4 - r7, r11, r12, lr}
  00010	e28db01c	 add         r11, sp, #0x1C
  00014		 |$LN28@HandleDeta@2|
  00014	e1a04000	 mov         r4, r0

; 4428 :     DEBUGMSG( ZONE_ATTACH || ZONE_FUNCTION, (TEXT("%s: +CFunction(tier %d)::HandleDetach\n"),GetControllerName(), m_tierNumber) );
; 4429 : 
; 4430 :     EnterCriticalSection( &m_csDeviceLock );

  00018	e284000c	 add         r0, r4, #0xC
  0001c	eb000000	 bl          EnterCriticalSection

; 4431 : 
; 4432 :     PREFAST_DEBUGCHK( m_ppCPipe != NULL );
; 4433 :     DEBUGCHK( m_maxNumPipes > 0 &&
; 4434 :               m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ] != NULL );
; 4435 : 
; 4436 :     for ( UCHAR pipe = 0; pipe < m_maxNumPipes; pipe++ ) {

  00020	e5d43054	 ldrb        r3, [r4, #0x54]
  00024	e3a06000	 mov         r6, #0
  00028	e3530000	 cmp         r3, #0
  0002c	e3a05000	 mov         r5, #0
  00030	0a00001a	 beq         |$LN4@HandleDeta@2|
  00034	e3a07000	 mov         r7, #0
  00038		 |$LL6@HandleDeta@2|

; 4437 :         if ( m_ppCPipe[ pipe ] != NULL ) {

  00038	e594305c	 ldr         r3, [r4, #0x5C]
  0003c	e1a02106	 mov         r2, r6, lsl #2
  00040	e7b23003	 ldr         r3, [r2, +r3]!
  00044	e3530000	 cmp         r3, #0
  00048	0a00000e	 beq         |$LN5@HandleDeta@2|

; 4438 :             DEBUGMSG(ZONE_ATTACH, (TEXT("HandleDetach close pipe %d\r\n"), pipe));
; 4439 :             m_ppCPipe[ pipe ]->ClosePipe();

  0004c	e5920000	 ldr         r0, [r2]
  00050	e5903000	 ldr         r3, [r0]
  00054	e5933008	 ldr         r3, [r3, #8]
  00058	e1a0e00f	 mov         lr, pc
  0005c	e12fff13	 bx          r3

; 4440 :             delete m_ppCPipe[ pipe ];

  00060	e594305c	 ldr         r3, [r4, #0x5C]
  00064	e7933106	 ldr         r3, [r3, +r6, lsl #2]
  00068	e1b00003	 movs        r0, r3
  0006c	15903000	 ldrne       r3, [r0]
  00070	13a01001	 movne       r1, #1
  00074	15933000	 ldrne       r3, [r3]
  00078	11a0e00f	 movne       lr, pc
  0007c	112fff13	 bxne        r3

; 4441 :             m_ppCPipe[ pipe ] = NULL;

  00080	e594305c	 ldr         r3, [r4, #0x5C]
  00084	e7835106	 str         r5, [r3, +r6, lsl #2]
  00088		 |$LN5@HandleDeta@2|
  00088	e5d42054	 ldrb        r2, [r4, #0x54]
  0008c	e2873001	 add         r3, r7, #1
  00090	e20360ff	 and         r6, r3, #0xFF
  00094	e1a07006	 mov         r7, r6
  00098	e1560002	 cmp         r6, r2
  0009c	3affffe5	 bcc         |$LL6@HandleDeta@2|
  000a0		 |$LN4@HandleDeta@2|

; 4442 :         }
; 4443 :     }
; 4444 :     // m_ppCPipe[] freed in ~CDevice
; 4445 : 
; 4446 :     DEBUGCHK( m_pCHcd->GetpUSBDDetachProc() != NULL );
; 4447 :     DEBUGCHK( m_lpvDetachId != NULL );
; 4448 : 
; 4449 :     if(m_hFunctionFeatureEvent) {

  000a0	e5943064	 ldr         r3, [r4, #0x64]
  000a4	e3530000	 cmp         r3, #0
  000a8	0a000004	 beq         |$LN2@HandleDeta@2|

; 4450 :         SetEvent(m_hFunctionFeatureEvent);

  000ac	e3a01003	 mov         r1, #3
  000b0	e1a00003	 mov         r0, r3
  000b4	eb000000	 bl          EventModify

; 4451 :         CloseHandle(m_hFunctionFeatureEvent);

  000b8	e5940064	 ldr         r0, [r4, #0x64]
  000bc	eb000000	 bl          CloseHandle
  000c0		 |$LN2@HandleDeta@2|

; 4452 :     }
; 4453 :     m_hFunctionFeatureEvent = NULL;
; 4454 : 
; 4455 :     LPVOID lpvDetachId = m_lpvDetachId;

  000c0	e5946060	 ldr         r6, [r4, #0x60]

; 4456 :     m_lpvDetachId = NULL;
; 4457 : 
; 4458 :     LeaveCriticalSection( &m_csDeviceLock );

  000c4	e284000c	 add         r0, r4, #0xC
  000c8	e5845060	 str         r5, [r4, #0x60]
  000cc	e5845064	 str         r5, [r4, #0x64]
  000d0	eb000000	 bl          LeaveCriticalSection
  000d4		 |$LN16@HandleDeta@2|

; 4459 : 
; 4460 :     // Inform USBD of device detach, so the message can be passed
; 4461 :     // along to the client driver.
; 4462 : #pragma prefast(disable: 322, "Recover gracefully from hardware failure")
; 4463 :     __try {
; 4464 :         (*m_pCHcd->GetpUSBDDetachProc())(lpvDetachId);

  000d4	e5943068	 ldr         r3, [r4, #0x68]
  000d8	e1a00006	 mov         r0, r6
  000dc	e5933080	 ldr         r3, [r3, #0x80]
  000e0	e1a0e00f	 mov         lr, pc
  000e4	e12fff13	 bx          r3
  000e8		 |$LN17@HandleDeta@2|
  000e8	eaffffff	 b           |$LN18@HandleDeta@2|
  000ec		 |$LN13@HandleDeta@2|
  000ec		 |$LN18@HandleDeta@2|

; 4466 :     }
; 4467 : #pragma prefast(pop)
; 4468 : 
; 4469 :     DEBUGMSG( ZONE_ATTACH || ZONE_FUNCTION, (TEXT("%s: -CFunction(tier %d)::HandleDetach\n"),GetControllerName(), m_tierNumber) );
; 4470 : }

  000ec	e24bd01c	 sub         sp, r11, #0x1C
  000f0	e89d68f0	 ldmia       sp, {r4 - r7, r11, sp, lr}
  000f4	e12fff1e	 bx          lr

			 ENDP  ; |?HandleDetach@CFunction@@EAAXXZ|, CFunction::HandleDetach

  000f8		 |$LN12@HandleDeta@2|
  000f8		 |$LN29@HandleDeta@2|

; 4465 :     } __except( EXCEPTION_EXECUTE_HANDLER ) {

  000f8	e52de004	 str         lr, [sp, #-4]!
  000fc		 |$LN15@HandleDeta@2|
  000fc		 |$LN32@HandleDeta@2|
  000fc	e3a00001	 mov         r0, #1
  00100		 |$LN14@HandleDeta@2|
  00100	e49df004	 ldr         pc, [sp], #4
  00104		 |$LN33@HandleDeta@2|
  00104		 |$LN31@HandleDeta@2|
	EXPORT	|?SetOrClearFeature@CFunction@@AAAHEGEG@Z| ; CFunction::SetOrClearFeature
	EXPORT	|??_C@_1KI@NHPPIIBA@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAS?$AAe?$AAt?$AAO?$AAr?$AAC?$AAl?$AAe@| [ DATA ] ; `string'
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T38749| DCD	|$LN17@SetOrClear@5|
	DCD	0x40005c02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1KI@NHPPIIBA@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAS?$AAe?$AAt?$AAO?$AAr?$AAC?$AAl?$AAe@| DCB "!"
	DCB	0x0, "!", 0x0, "!", 0x0, "C", 0x0, "F", 0x0, "u", 0x0, "n"
	DCB	0x0, "c", 0x0, "t", 0x0, "i", 0x0, "o", 0x0, "n", 0x0, "("
	DCB	0x0, " ", 0x0, "t", 0x0, "i", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, ")", 0x0, ":", 0x0, ":", 0x0, "S"
	DCB	0x0, "e", 0x0, "t", 0x0, "O", 0x0, "r", 0x0, "C", 0x0, "l"
	DCB	0x0, "e", 0x0, "a", 0x0, "r", 0x0, "F", 0x0, "e", 0x0, "a"
	DCB	0x0, "t", 0x0, "u", 0x0, "r", 0x0, "e", 0x0, " ", 0x0, "o"
	DCB	0x0, "n", 0x0, " ", 0x0, "s", 0x0, "u", 0x0, "s", 0x0, "p"
	DCB	0x0, "e", 0x0, "n", 0x0, "d", 0x0, " ", 0x0, "s", 0x0, "t"
	DCB	0x0, "a", 0x0, "t", 0x0, "e", 0x0, " ", 0x0, "i", 0x0, "s"
	DCB	0x0, " ", 0x0, "i", 0x0, "l", 0x0, "l", 0x0, "g", 0x0, "l"
	DCB	0x0, "e", 0x0, ",", 0x0, " ", 0x0, "a", 0x0, "d", 0x0, "d"
	DCB	0x0, "r", 0x0, "e", 0x0, "s", 0x0, "s", 0x0, " ", 0x0, "="
	DCB	0x0, " ", 0x0, "%", 0x0, "d", 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetOrClearFeature@CFunction@@AAAHEGEG@Z| PROC ; CFunction::SetOrClearFeature

; 4494 : {

  00000		 |$LN17@SetOrClear@5|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd04c	 sub         sp, sp, #0x4C
  00008		 |$M38746|
  00008	e1a09000	 mov         r9, r0

; 4495 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("%s: +CFunction::SetOrClearFeature - recipient = %d, wIndex = %d, set/clear = 0x%x, feature = 0x%x\n"),GetControllerName(), recipient, wIndex, setOrClearFeature, feature) );
; 4496 : 
; 4497 : #ifdef DEBUG
; 4498 :     {
; 4499 :     switch(recipient) {
; 4500 :             case USB_DEVICE_RECIPIENT:
; 4501 :                 // USB spec 1.1, 9.4 - there is only one
; 4502 :                 // features which should be set or cleared for ports
; 4503 :                 DEBUGCHK( wIndex == 0 && (feature == USB_DEVICE_REMOTE_WAKEUP || 
; 4504 :                     feature == USB_FEATURE_B_HNP_ENABLE || feature == USB_FEATURE_A_HNP_SUPPORT || feature == USB_FEATURE_A_ALT_HNP_SUPPORT) );
; 4505 :                 break;
; 4506 :             case USB_ENDPOINT_RECIPIENT:
; 4507 :                 // USB spec 1.1, 9.4 - there is only one
; 4508 :                 // features which should be set or cleared for endpoints
; 4509 :                 DEBUGCHK( feature == USB_FEATURE_ENDPOINT_HALT );
; 4510 :                 break;
; 4511 :             case USB_INTERFACE_RECIPIENT:
; 4512 :                 // USB spec 1.1, 9.4 - there are not features available at this time
; 4513 :                 DEBUGCHK( 0);
; 4514 :                 break;
; 4515 :             default:
; 4516 :                 DEBUGCHK(0);
; 4517 :     }
; 4518 :         DEBUGCHK( m_ppCPipe != NULL && m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ] != NULL);
; 4519 :     }
; 4520 : #endif // DEBUG
; 4521 : 
; 4522 :     BOOL                fTransferDone = FALSE;
; 4523 :     DWORD               dwBytesTransferred = 0;
; 4524 :     DWORD               dwErrorFlags = USB_NOT_COMPLETE_ERROR;
; 4525 :     HCD_REQUEST_STATUS  status = requestFailed;
; 4526 :     USB_DEVICE_REQUEST  usbRequest;
; 4527 : 
; 4528 :     usbRequest.bmRequestType = recipient;
; 4529 :     usbRequest.bRequest = setOrClearFeature;
; 4530 :     usbRequest.wValue = feature;

  0000c	e1dd47b0	 ldrh        r4, [sp, #0x70]
  00010	e3a00c01	 mov         r0, #1, 24
  00014	e380e003	 orr         lr, r0, #3

; 4531 :     usbRequest.wIndex = wIndex;
; 4532 :     usbRequest.wLength = 0;
; 4533 :     PREFAST_DEBUGCHK(m_ppCPipe!=NULL);
; 4534 :     EnterCriticalSection( &m_csDeviceLock );

  00018	e3a05000	 mov         r5, #0
  0001c	e3a06000	 mov         r6, #0
  00020	e3a07000	 mov         r7, #0
  00024	e1cd44b6	 strh        r4, [sp, #0x46]
  00028	e289000c	 add         r0, r9, #0xC
  0002c	e3a04000	 mov         r4, #0
  00030	e58de040	 str         lr, [sp, #0x40]
  00034	e58d5038	 str         r5, [sp, #0x38]
  00038	e58d603c	 str         r6, [sp, #0x3C]
  0003c	e5cd1044	 strb        r1, [sp, #0x44]
  00040	e5cd3045	 strb        r3, [sp, #0x45]
  00044	e1cd24b8	 strh        r2, [sp, #0x48]
  00048	e1cd74ba	 strh        r7, [sp, #0x4A]
  0004c	eb000000	 bl          EnterCriticalSection

; 4535 :     if (m_fIsSuspend ) {

  00050	e5993058	 ldr         r3, [r9, #0x58]
  00054	e3530000	 cmp         r3, #0
  00058	0a000004	 beq         |$LN6@SetOrClear@5|

; 4536 :         RETAILMSG(1,(TEXT("!!!CFunction( tier %d)::SetOrClearFeature on suspend state is illgle, address = %d\n"), m_tierNumber, m_address));

  0005c	e5d92020	 ldrb        r2, [r9, #0x20]
  00060	e5d9104c	 ldrb        r1, [r9, #0x4C]
  00064	e59f0100	 ldr         r0, [pc, #0x100]
  00068	eb000000	 bl          NKDbgPrintfW

; 4537 :         ASSERT(FALSE);
; 4538 :     }
; 4539 :     else {

  0006c	ea00002c	 b           |$LN13@SetOrClear@5|
  00070		 |$LN6@SetOrClear@5|

; 4540 :         status = m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ]->IssueTransfer(
; 4541 :                          m_address, // address of this function
; 4542 :                          TransferDoneCallbackSetEvent, // callback func
; 4543 :                          m_hFunctionFeatureEvent, // callback param
; 4544 :                          USB_OUT_TRANSFER | USB_SEND_TO_DEVICE, // transfer flags
; 4545 :                          &usbRequest, // control request
; 4546 :                          0, // dwStartingFrame (not used)
; 4547 :                          0, // dwFrames (not used)
; 4548 :                          NULL, // aLengths (not used)
; 4549 :                          0, // buffer size
; 4550 :                          NULL, // buffer
; 4551 :                          0, // phys addr of buffer (not used)
; 4552 :                          this, // cancel id
; 4553 :                          NULL, // adwIsochErrors (not used)
; 4554 :                          NULL, // adwIsochLengths (not used)
; 4555 :                          &fTransferDone, // OUT param for transfer
; 4556 :                          &dwBytesTransferred, // OUT param for transfer
; 4557 :                          &dwErrorFlags ); // OUT param for transfer

  00070	e599105c	 ldr         r1, [r9, #0x5C]
  00074	e5993064	 ldr         r3, [r9, #0x64]
  00078	e59f20e8	 ldr         r2, [pc, #0xE8]
  0007c	e5910000	 ldr         r0, [r1]
  00080	e5d91020	 ldrb        r1, [r9, #0x20]
  00084	e28d6040	 add         r6, sp, #0x40
  00088	e590e000	 ldr         lr, [r0]
  0008c	e28d403c	 add         r4, sp, #0x3C
  00090	e28d5038	 add         r5, sp, #0x38
  00094	e59e800c	 ldr         r8, [lr, #0xC]
  00098	e28d7044	 add         r7, sp, #0x44
  0009c	e3a0ba01	 mov         r11, #1, 20
  000a0	e3a0a000	 mov         r10, #0
  000a4	e58d6034	 str         r6, [sp, #0x34]
  000a8	e58d4030	 str         r4, [sp, #0x30]
  000ac	e58d502c	 str         r5, [sp, #0x2C]
  000b0	e58da028	 str         r10, [sp, #0x28]
  000b4	e58da024	 str         r10, [sp, #0x24]
  000b8	e58d9020	 str         r9, [sp, #0x20]
  000bc	e58da01c	 str         r10, [sp, #0x1C]
  000c0	e58da018	 str         r10, [sp, #0x18]
  000c4	e58da014	 str         r10, [sp, #0x14]
  000c8	e58da010	 str         r10, [sp, #0x10]
  000cc	e58da00c	 str         r10, [sp, #0xC]
  000d0	e58da008	 str         r10, [sp, #8]
  000d4	e58d7004	 str         r7, [sp, #4]
  000d8	e58db000	 str         r11, [sp]
  000dc	e1a0e00f	 mov         lr, pc
  000e0	e12fff18	 bx          r8
  000e4	e1a04000	 mov         r4, r0

; 4558 :         if ( status == requestOK ) {

  000e8	e3540001	 cmp         r4, #1
  000ec	1a00000c	 bne         |$LN13@SetOrClear@5|

; 4559 :             DWORD dwReturn = WaitForSingleObject( m_hFunctionFeatureEvent, STANDARD_REQUEST_TIMEOUT );

  000f0	e5990064	 ldr         r0, [r9, #0x64]
  000f4	e3a01f7d	 mov         r1, #0x7D, 30
  000f8	eb000000	 bl          WaitForSingleObject

; 4560 :             DEBUGCHK( fTransferDone );
; 4561 :             if (!fTransferDone || dwReturn!= WAIT_OBJECT_0) {

  000fc	e59d3038	 ldr         r3, [sp, #0x38]
  00100	e3530000	 cmp         r3, #0
  00104	0a000001	 beq         |$LN2@SetOrClear@5|
  00108	e3500000	 cmp         r0, #0
  0010c	0a000004	 beq         |$LN13@SetOrClear@5|
  00110		 |$LN2@SetOrClear@5|

; 4562 : #ifdef DEBUG
; 4563 :                 HCD_REQUEST_STATUS abortStatus = m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ]->AbortTransfer(NULL, NULL, this );
; 4564 :                 ASSERT(abortStatus == requestOK);
; 4565 : #endif
; 4566 :                 if (m_hFunctionFeatureEvent)

  00110	e5993064	 ldr         r3, [r9, #0x64]
  00114	e3530000	 cmp         r3, #0

; 4567 :                     ResetEvent(m_hFunctionFeatureEvent);

  00118	13a01002	 movne       r1, #2
  0011c	11a00003	 movne       r0, r3
  00120	1b000000	 blne        EventModify
  00124		 |$LN13@SetOrClear@5|

; 4568 :             }
; 4569 :         }
; 4570 :     }
; 4571 :     LeaveCriticalSection( &m_csDeviceLock );

  00124	e289000c	 add         r0, r9, #0xC
  00128	eb000000	 bl          LeaveCriticalSection

; 4572 : 
; 4573 :     BOOL fSuccess = (status == requestOK &&
; 4574 :                      fTransferDone &&
; 4575 :                      dwBytesTransferred == 0 &&
; 4576 :                      dwErrorFlags == USB_NO_ERROR);

  0012c	e3540001	 cmp         r4, #1
  00130	1a000008	 bne         |$LN11@SetOrClear@5|
  00134	e59d3038	 ldr         r3, [sp, #0x38]
  00138	e3530000	 cmp         r3, #0
  0013c	0a000005	 beq         |$LN11@SetOrClear@5|
  00140	e59d303c	 ldr         r3, [sp, #0x3C]
  00144	e3530000	 cmp         r3, #0
  00148	059d3040	 ldreq       r3, [sp, #0x40]
  0014c	03530000	 cmpeq       r3, #0
  00150	03a00001	 moveq       r0, #1
  00154	0a000000	 beq         |$LN12@SetOrClear@5|
  00158		 |$LN11@SetOrClear@5|
  00158	e3a00000	 mov         r0, #0
  0015c		 |$LN12@SetOrClear@5|

; 4577 : 
; 4578 :     DEBUGMSG( ZONE_ERROR && !fSuccess, (TEXT("%s: CFunction::SetOrClearFeature - recipient = %d, wIndex = %d, set/clear = 0x%x, feature = 0x%x, FAILED\n"),GetControllerName(), recipient, wIndex, setOrClearFeature, feature ) );
; 4579 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: -CFunction::SetOrClearFeature - recipient = %d, wIndex = %d, set/clear = 0x%x, feature = 0x%x, returing BOOL %d\n"),GetControllerName(), recipient, wIndex, setOrClearFeature, feature, fSuccess) );
; 4580 :     return fSuccess;
; 4581 : }

  0015c	e28dd04c	 add         sp, sp, #0x4C
  00160	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00164	e12fff1e	 bx          lr
  00168		 |$LN18@SetOrClear@5|
  00168		 |$LN19@SetOrClear@5|
  00168	00000000	 DCD         |?TransferDoneCallbackSetEvent@CDevice@@KAKPAX@Z|
  0016c		 |$LN20@SetOrClear@5|
  0016c	00000000	 DCD         |??_C@_1KI@NHPPIIBA@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAS?$AAe?$AAt?$AAO?$AAr?$AAC?$AAl?$AAe@|
  00170		 |$M38747|

			 ENDP  ; |?SetOrClearFeature@CFunction@@AAAHEGEG@Z|, CFunction::SetOrClearFeature

	EXPORT	|?ReserveAddress@CDevice@@QAAHAAE@Z|	; CDevice::ReserveAddress
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T38763| DCD	|$LN5@ReserveAdd@2|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ReserveAddress@CDevice@@QAAHAAE@Z| PROC ; CDevice::ReserveAddress

; 248  :     BOOL ReserveAddress( OUT UCHAR& rAddress ) { return m_pDeviceGlobal->ReserveAddress(rAddress); };

  00000		 |$LN5@ReserveAdd@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38760|
  00004	e5900050	 ldr         r0, [r0, #0x50]
  00008	eb000000	 bl          |?ReserveAddress@CDeviceGlobal@@QAAHAAE@Z|
  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M38761|

			 ENDP  ; |?ReserveAddress@CDevice@@QAAHAAE@Z|, CDevice::ReserveAddress

	EXPORT	|?FreeAddress@CDevice@@QAAXE@Z|		; CDevice::FreeAddress

  00000			 AREA	 |.pdata|, PDATA
|$T38772| DCD	|$LN5@FreeAddres@2|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FreeAddress@CDevice@@QAAXE@Z| PROC	; CDevice::FreeAddress

; 249  :     void  FreeAddress( IN const UCHAR address ) { m_pDeviceGlobal->FreeAddress(address); };

  00000		 |$LN5@FreeAddres@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38769|
  00004	e5900050	 ldr         r0, [r0, #0x50]
  00008	eb000000	 bl          |?FreeAddress@CDeviceGlobal@@QAAXE@Z|
  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M38770|

			 ENDP  ; |?FreeAddress@CDevice@@QAAXE@Z|, CDevice::FreeAddress

	EXPORT	|??1CDeviceGlobal@@QAA@XZ|		; CDeviceGlobal::~CDeviceGlobal
	IMPORT	|??1CritSec_Ex@@QAA@XZ|			; CritSec_Ex::~CritSec_Ex
	IMPORT	|??1Countdown@@QAA@XZ|			; Countdown::~Countdown
	IMPORT	|DeleteCriticalSection|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T38780| DCD	|$LN5@CDeviceGlo@2|
	DCD	0x40000e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CDeviceGlobal@@QAA@XZ| PROC	; CDeviceGlobal::~CDeviceGlobal

; 120  : {

  00000		 |$LN5@CDeviceGlo@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M38777|
  00004	e1a04000	 mov         r4, r0
  00008	e59f3024	 ldr         r3, [pc, #0x24]

; 121  :     DeInitialize();

  0000c	e5843000	 str         r3, [r4]
  00010	eb000000	 bl          |?DeInitialize@CDeviceGlobal@@QAAXXZ|

; 122  :     // all devices, and hence all addresses, should have been freed by now
; 123  :     DeleteCriticalSection( &m_csFreeAddressArrayLock );

  00014	e2840008	 add         r0, r4, #8
  00018	eb000000	 bl          DeleteCriticalSection

; 124  :     //DeleteCritSec_Ex( &m_csAddress0Lock );
; 125  : }

  0001c	e2840054	 add         r0, r4, #0x54
  00020	eb000000	 bl          |??1Countdown@@QAA@XZ|
  00024	e284002c	 add         r0, r4, #0x2C
  00028	eb000000	 bl          |??1CritSec_Ex@@QAA@XZ|
  0002c	e8bd4010	 ldmia       sp!, {r4, lr}
  00030	e12fff1e	 bx          lr
  00034		 |$LN6@CDeviceGlo@2|
  00034		 |$LN7@CDeviceGlo@2|
  00034	00000000	 DCD         |??_7CDeviceGlobal@@6B@|
  00038		 |$M38778|

			 ENDP  ; |??1CDeviceGlobal@@QAA@XZ|, CDeviceGlobal::~CDeviceGlobal

	EXPORT	|??1CDevice@@UAA@XZ|			; CDevice::~CDevice
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T38799| DCD	|$LN13@CDevice@2|
	DCD	0x40002601
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CDevice@@UAA@XZ| PROC		; CDevice::~CDevice

; 412  : {

  00000		 |$LN13@CDevice@2|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M38796|
  00004	e1a04000	 mov         r4, r0
  00008	e59f3084	 ldr         r3, [pc, #0x84]

; 413  :     DEBUGMSG( ZONE_DEVICE && ZONE_VERBOSE, (TEXT("%s: +CDevice::~CDevice\n"),GetControllerName()) );
; 414  : 
; 415  :     // delete m_deviceInfo structure
; 416  :     if ( m_deviceInfo.lpConfigs != NULL ) {

  0000c	e594203c	 ldr         r2, [r4, #0x3C]
  00010	e3a07000	 mov         r7, #0
  00014	e5843000	 str         r3, [r4]
  00018	e3520000	 cmp         r2, #0
  0001c	0a000010	 beq         |$LN4@CDevice@2|

; 417  :         DEBUGCHK( m_deviceInfo.Descriptor.bDescriptorType == USB_DEVICE_DESCRIPTOR_TYPE &&
; 418  :                   m_deviceInfo.Descriptor.bLength == sizeof( USB_DEVICE_DESCRIPTOR ) &&
; 419  :                   m_deviceInfo.dwCount == sizeof( USB_DEVICE_INFO ) &&
; 420  :                   m_deviceInfo.Descriptor.bNumConfigurations > 0 );
; 421  :         for ( UINT config = 0; config < m_deviceInfo.Descriptor.bNumConfigurations; config++ ) {

  00020	e5d43039	 ldrb        r3, [r4, #0x39]
  00024	e3a06000	 mov         r6, #0
  00028	e3530000	 cmp         r3, #0
  0002c	0a000009	 beq         |$LN1@CDevice@2|
  00030	e3a05000	 mov         r5, #0
  00034		 |$LL3@CDevice@2|
  00034	e594303c	 ldr         r3, [r4, #0x3C]

; 422  :             DeleteUsbConfigurationStructure( m_deviceInfo.lpConfigs[ config ] );

  00038	e1a00004	 mov         r0, r4
  0003c	e0851003	 add         r1, r5, r3
  00040	eb000000	 bl          |?DeleteUsbConfigurationStructure@CDevice@@QBAXAAU_NON_CONST_USB_CONFIGURATION@@@Z|
  00044	e5d43039	 ldrb        r3, [r4, #0x39]
  00048	e2866001	 add         r6, r6, #1
  0004c	e2855020	 add         r5, r5, #0x20
  00050	e1560003	 cmp         r6, r3
  00054	3afffff6	 bcc         |$LL3@CDevice@2|
  00058		 |$LN1@CDevice@2|

; 423  :         }
; 424  :         delete [] m_deviceInfo.lpConfigs;

  00058	e594003c	 ldr         r0, [r4, #0x3C]
  0005c	eb000000	 bl          |??3@YAXPAX@Z|

; 425  :         m_deviceInfo.lpConfigs = NULL;

  00060	e584703c	 str         r7, [r4, #0x3C]
  00064		 |$LN4@CDevice@2|

; 426  :     }
; 427  :     m_deviceInfo.lpActiveConfig = NULL;
; 428  : 
; 429  : #ifdef DEBUG
; 430  : {
; 431  :     DEBUGCHK( (m_ppCPipe == NULL && m_maxNumPipes == 0) ||
; 432  :               (m_ppCPipe != NULL && m_maxNumPipes > 0) );
; 433  :     // all pipes should have been closed/deleted by HandleDetach
; 434  :     for ( UCHAR pipe = 0; m_ppCPipe && pipe < m_maxNumPipes; pipe++ ) {
; 435  :         DEBUGCHK( m_ppCPipe[ pipe ] == NULL );
; 436  :     }
; 437  : }
; 438  : #endif // DEBUG
; 439  :     delete [] m_ppCPipe;

  00064	e594005c	 ldr         r0, [r4, #0x5C]
  00068	e5847040	 str         r7, [r4, #0x40]
  0006c	eb000000	 bl          |??3@YAXPAX@Z|

; 440  :     m_ppCPipe = NULL;
; 441  :     m_maxNumPipes = 0;
; 442  : 
; 443  :     // free address
; 444  :     FreeAddress( m_address );

  00070	e5d41020	 ldrb        r1, [r4, #0x20]
  00074	e5940050	 ldr         r0, [r4, #0x50]
  00078	e584705c	 str         r7, [r4, #0x5C]
  0007c	e5c47054	 strb        r7, [r4, #0x54]
  00080	eb000000	 bl          |?FreeAddress@CDeviceGlobal@@QAAXE@Z|

; 445  : 
; 446  :     // nothing to be done with any of these:
; 447  :     // m_deviceInfo;   // holds device's USB descriptors
; 448  :     // m_fIsLowSpeed;  // indicates if device is low speed
; 449  :     // m_tierNumber;   // indicates tier # of device
; 450  : 
; 451  :     DeleteCriticalSection( &m_csDeviceLock );

  00084	e284000c	 add         r0, r4, #0xC
  00088	eb000000	 bl          DeleteCriticalSection

; 452  :     DEBUGMSG( ZONE_DEVICE && ZONE_VERBOSE, (TEXT("%s: -CDevice::~CDevice\n"),GetControllerName()) );
; 453  : }

  0008c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$LN14@CDevice@2|
  00094		 |$LN15@CDevice@2|
  00094	00000000	 DCD         |??_7CDevice@@6B@|
  00098		 |$M38797|

			 ENDP  ; |??1CDevice@@UAA@XZ|, CDevice::~CDevice

	EXPORT	|?CreateUsbConfigurationStructure@CDevice@@QBAHAAU_NON_CONST_USB_CONFIGURATION@@QAEI@Z| ; CDevice::CreateUsbConfigurationStructure

  00000			 AREA	 |.pdata|, PDATA
|$T38848| DCD	|$LN56@CreateUsbC|
	DCD	0x4000dd02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CreateUsbConfigurationStructure@CDevice@@QBAHAAU_NON_CONST_USB_CONFIGURATION@@QAEI@Z| PROC ; CDevice::CreateUsbConfigurationStructure

; 499  : {

  00000		 |$LN56@CreateUsbC|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M38845|
  00008	e1a07001	 mov         r7, r1
  0000c	e58d7004	 str         r7, [sp, #4]
  00010	e1a09003	 mov         r9, r3
  00014	e1b08002	 movs        r8, r2
  00018	e58d000c	 str         r0, [sp, #0xC]

; 500  :     DEBUGMSG( ZONE_DESCRIPTORS && ZONE_VERBOSE, (TEXT("%s: +CDevice::CreateUsbConfigurationStructure\n"),GetControllerName()));
; 501  : 
; 502  :     DEBUGCHK( pDataBuffer != NULL &&
; 503  :               dataBufferLen == rConfig.Descriptor.wTotalLength );
; 504  : 
; 505  :     PUSB_CONFIGURATION_DESCRIPTOR pusbConfigDesc = (PUSB_CONFIGURATION_DESCRIPTOR) pDataBuffer;
; 506  :     DEBUGCHK( memcmp( &rConfig.Descriptor, pusbConfigDesc, sizeof( USB_CONFIGURATION_DESCRIPTOR ) ) == 0 );
; 507  : 
; 508  : #ifdef DEBUG
; 509  :     DumpConfigDescriptor( &rConfig.Descriptor );
; 510  : #endif // DEBUG
; 511  : 
; 512  :     rConfig.dwNumInterfaces = 0;

  0001c	e3a03000	 mov         r3, #0
  00020	e5873014	 str         r3, [r7, #0x14]

; 513  :     rConfig.lpbExtended = NULL;

  00024	e5873010	 str         r3, [r7, #0x10]

; 514  :     rConfig.lpInterfaces = NULL;

  00028	e5873018	 str         r3, [r7, #0x18]

; 515  :     rConfig.dwExtendedSize = 0;

  0002c	e587301c	 str         r3, [r7, #0x1C]

; 516  : 
; 517  :     BOOL retval = FALSE;

  00030	e3a00000	 mov         r0, #0

; 518  : 
; 519  :     if ( pusbConfigDesc != NULL &&
; 520  :          pusbConfigDesc->wTotalLength == rConfig.Descriptor.wTotalLength &&
; 521  :          dataBufferLen == pusbConfigDesc->wTotalLength &&
; 522  :          pusbConfigDesc->bLength >= sizeof( USB_CONFIGURATION_DESCRIPTOR ) &&
; 523  :          pusbConfigDesc->bDescriptorType == USB_CONFIGURATION_DESCRIPTOR_TYPE ) {

  00034	0a0000c5	 beq         |$LN37@CreateUsbC|
  00038	e5d86002	 ldrb        r6, [r8, #2]
  0003c	e5d84003	 ldrb        r4, [r8, #3]
  00040	e5d75006	 ldrb        r5, [r7, #6]
  00044	e5d7e007	 ldrb        lr, [r7, #7]
  00048	e1862404	 orr         r2, r6, r4, lsl #8
  0004c	e185e40e	 orr         lr, r5, lr, lsl #8
  00050	e152000e	 cmp         r2, lr
  00054	1a0000bd	 bne         |$LN37@CreateUsbC|
  00058	e1590002	 cmp         r9, r2
  0005c	1a0000bb	 bne         |$LN37@CreateUsbC|
  00060	e5d84000	 ldrb        r4, [r8]
  00064	e3540009	 cmp         r4, #9
  00068	3a0000b8	 bcc         |$LN37@CreateUsbC|
  0006c	e5d83001	 ldrb        r3, [r8, #1]
  00070	e3530002	 cmp         r3, #2
  00074	1a0000b5	 bne         |$LN37@CreateUsbC|

; 524  : 
; 525  :         UINT offset = pusbConfigDesc->bLength;
; 526  :         PUSB_COMMON_DESCRIPTOR pusbCommon = NULL;
; 527  :         rConfig.dwCount = sizeof ( NON_CONST_USB_CONFIGURATION );

  00078	e3a03020	 mov         r3, #0x20
  0007c	e5873000	 str         r3, [r7]

; 528  : 
; 529  :         // first step - count number of extended bytes for this config descriptor,
; 530  :         // and copy data if needed
; 531  :         {
; 532  :             UINT configDescExtendedBytes = 0;

  00080	e3a05000	 mov         r5, #0

; 533  :             while ( offset + configDescExtendedBytes < dataBufferLen ) {

  00084	e1540009	 cmp         r4, r9
  00088	2a000015	 bcs         |$LN32@CreateUsbC|
  0008c	e0846008	 add         r6, r4, r8
  00090		 |$LL36@CreateUsbC|

; 534  :                 pusbCommon = (PUSB_COMMON_DESCRIPTOR)(pDataBuffer + offset + configDescExtendedBytes );

  00090	e0862005	 add         r2, r6, r5

; 535  :                 if ( pusbCommon->bDescriptorType != USB_INTERFACE_DESCRIPTOR_TYPE ) {

  00094	e5d23001	 ldrb        r3, [r2, #1]
  00098	e3530004	 cmp         r3, #4
  0009c	0a000004	 beq         |$LN34@CreateUsbC|

; 536  :                     configDescExtendedBytes += pusbCommon->bLength;

  000a0	e5d23000	 ldrb        r3, [r2]
  000a4	e0855003	 add         r5, r5, r3
  000a8	e0853004	 add         r3, r5, r4
  000ac	e1530009	 cmp         r3, r9
  000b0	3afffff6	 bcc         |$LL36@CreateUsbC|
  000b4		 |$LN34@CreateUsbC|

; 537  :                 } else {
; 538  :                     break;
; 539  :                 }
; 540  :             }
; 541  :             // next, copy Config Descriptor's extended bytes
; 542  :             if ( configDescExtendedBytes > 0 ) {

  000b4	e3550000	 cmp         r5, #0
  000b8	0a000009	 beq         |$LN32@CreateUsbC|

; 543  :                 rConfig.lpbExtended = new BYTE[ configDescExtendedBytes ];

  000bc	e1a00005	 mov         r0, r5
  000c0	eb000000	 bl          |??2@YAPAXI@Z|
  000c4	e3500000	 cmp         r0, #0
  000c8	e5870010	 str         r0, [r7, #0x10]

; 544  :                 if ( rConfig.lpbExtended == NULL ) {

  000cc	0a0000a2	 beq         |$configDescMemoryError$35903|

; 545  :                     goto configDescMemoryError;
; 546  :                 }
; 547  :                 rConfig.dwExtendedSize = configDescExtendedBytes ;
; 548  :                 memcpy(  rConfig.lpbExtended, pDataBuffer + offset, configDescExtendedBytes );

  000d0	e1a02005	 mov         r2, r5
  000d4	e1a01006	 mov         r1, r6
  000d8	e587501c	 str         r5, [r7, #0x1C]
  000dc	eb000000	 bl          memcpy

; 549  :                 offset += configDescExtendedBytes;

  000e0	e0844005	 add         r4, r4, r5
  000e4		 |$LN32@CreateUsbC|

; 550  :             #ifdef DEBUG
; 551  :                 DumpExtendedBytes( rConfig.lpbExtended, configDescExtendedBytes );
; 552  :             #endif // DEBUG
; 553  :             }
; 554  :         }
; 555  :         // second step - get the number of interfaces for this configuration
; 556  :         // note - this isn't always the same as the bNumInterfaces field of
; 557  :         // rConfig.Descriptor, due to Alternate settings for Interfaces
; 558  :         {
; 559  :             UINT x = 0; // temporary counter
; 560  :             DEBUGCHK( rConfig.dwNumInterfaces == 0 );
; 561  :             while ( offset + x + sizeof( USB_INTERFACE_DESCRIPTOR ) < dataBufferLen ) {

  000e4	e2841009	 add         r1, r4, #9
  000e8	e1510009	 cmp         r1, r9
  000ec	e3a02000	 mov         r2, #0
  000f0	2a00000b	 bcs         |$LN28@CreateUsbC|
  000f4	e084e008	 add         lr, r4, r8
  000f8		 |$LL29@CreateUsbC|

; 562  :                 pusbCommon = (PUSB_COMMON_DESCRIPTOR)(pDataBuffer + offset + x);

  000f8	e08e0002	 add         r0, lr, r2

; 563  :                 if ( pusbCommon->bDescriptorType == USB_INTERFACE_DESCRIPTOR_TYPE ) {

  000fc	e5d03001	 ldrb        r3, [r0, #1]
  00100	e3530004	 cmp         r3, #4

; 564  :                     rConfig.dwNumInterfaces++;

  00104	05973014	 ldreq       r3, [r7, #0x14]
  00108	02833001	 addeq       r3, r3, #1
  0010c	05873014	 streq       r3, [r7, #0x14]

; 565  :                 }
; 566  :                 x += pusbCommon->bLength;

  00110	e5d03000	 ldrb        r3, [r0]
  00114	e0822003	 add         r2, r2, r3
  00118	e0813002	 add         r3, r1, r2
  0011c	e1530009	 cmp         r3, r9
  00120	3afffff4	 bcc         |$LL29@CreateUsbC|
  00124		 |$LN28@CreateUsbC|

; 567  :             }
; 568  :         }
; 569  : 
; 570  :         // next - create array for INTERFACE objects
; 571  :         DEBUGCHK( rConfig.lpInterfaces == NULL );
; 572  :         if ( rConfig.dwNumInterfaces > 0 ) {

  00124	e5973014	 ldr         r3, [r7, #0x14]
  00128	e1b02003	 movs        r2, r3
  0012c	0a000086	 beq         |$LN21@CreateUsbC|

; 573  :             // allocate this many interface objects
; 574  :             rConfig.lpInterfaces = new NON_CONST_USB_INTERFACE[ rConfig.dwNumInterfaces ];

  00130	e59f3238	 ldr         r3, [pc, #0x238]
  00134	e1520003	 cmp         r2, r3
  00138	90623182	 rsbls       r3, r2, r2, lsl #3
  0013c	91a00103	 movls       r0, r3, lsl #2
  00140	83e00000	 mvnhi       r0, #0
  00144	eb000000	 bl          |??2@YAPAXI@Z|
  00148	e3500000	 cmp         r0, #0
  0014c	e5870018	 str         r0, [r7, #0x18]

; 575  :             if ( rConfig.lpInterfaces == NULL ) {

  00150	0a000081	 beq         |$configDescMemoryError$35903|

; 576  :                 goto configDescMemoryError;
; 577  :             }
; 578  :             memset( rConfig.lpInterfaces, 0, rConfig.dwNumInterfaces * sizeof( NON_CONST_USB_INTERFACE ) );

  00154	e5973014	 ldr         r3, [r7, #0x14]
  00158	e3a01000	 mov         r1, #0
  0015c	e0633183	 rsb         r3, r3, r3, lsl #3
  00160	e1a02103	 mov         r2, r3, lsl #2
  00164	eb000000	 bl          memset

; 579  :             for ( UCHAR interfaceNumber = 0; interfaceNumber < rConfig.dwNumInterfaces; interfaceNumber++ ) {

  00168	e5973014	 ldr         r3, [r7, #0x14]
  0016c	e3a01000	 mov         r1, #0
  00170	e5cd1000	 strb        r1, [sp]
  00174	e3530000	 cmp         r3, #0
  00178	9a000073	 bls         |$LN21@CreateUsbC|
  0017c	e3a0201c	 mov         r2, #0x1C
  00180		 |$LL23@CreateUsbC|

; 580  :                 NON_CONST_USB_INTERFACE & rInterface = rConfig.lpInterfaces[ interfaceNumber ];

  00180	e5976018	 ldr         r6, [r7, #0x18]
  00184	e0613181	 rsb         r3, r1, r1, lsl #3

; 581  :                 rInterface.dwCount = sizeof( NON_CONST_USB_INTERFACE );
; 582  :                 // for each interface,
; 583  :                 // 1) Copy the interface descriptor
; 584  :                 // 2) Allocate and copy any extended bytes
; 585  :                 // 3) Allocate room for endpoints, if any
; 586  :                 // 4) Copy over endpoints -
; 587  :                 //      for each endpoint:
; 588  :                 //      a) copy the endpoint descriptor
; 589  :                 //      b) copy any extended bytes
; 590  : 
; 591  : 
; 592  :                 // we should now be pointing to a complete USB_INTERFACE_DESCRIPTOR
; 593  :                 DEBUGCHK( offset + sizeof( USB_CONFIGURATION_DESCRIPTOR ) <= dataBufferLen );
; 594  :                 PUSB_INTERFACE_DESCRIPTOR pusbInterfaceDesc = (PUSB_INTERFACE_DESCRIPTOR)(pDataBuffer + offset);
; 595  :                 DEBUGCHK( pusbInterfaceDesc->bLength >= sizeof( USB_INTERFACE_DESCRIPTOR ) &&
; 596  :                           pusbInterfaceDesc->bDescriptorType == USB_INTERFACE_DESCRIPTOR_TYPE );
; 597  : 
; 598  :                 // 1) copy interface descriptor, and skip over it
; 599  :                 memcpy( &rInterface.Descriptor, pusbInterfaceDesc, sizeof( USB_INTERFACE_DESCRIPTOR ) );

  00188	e0841008	 add         r1, r4, r8
  0018c	e7a62103	 str         r2, [r6, +r3, lsl #2]!
  00190	e3a02009	 mov         r2, #9
  00194	e2860004	 add         r0, r6, #4
  00198	eb000000	 bl          memcpy

; 600  :                 offset += pusbInterfaceDesc->bLength;

  0019c	e7d43008	 ldrb        r3, [r4, +r8]

; 601  :             #ifdef DEBUG
; 602  :                 DumpInterfaceDescriptor( &rInterface.Descriptor );
; 603  :             #endif // DEBUG
; 604  : 
; 605  :                 // 2) copy any extended info, if it exists
; 606  :                 {
; 607  :                     UINT interfaceDescExtendedBytes = 0;

  001a0	e3a05000	 mov         r5, #0
  001a4	e0844003	 add         r4, r4, r3

; 608  :                     while ( offset + interfaceDescExtendedBytes < dataBufferLen ) {

  001a8	e1540009	 cmp         r4, r9
  001ac	2a00001b	 bcs         |$LN16@CreateUsbC|
  001b0	e084a008	 add         r10, r4, r8
  001b4		 |$LL20@CreateUsbC|

; 609  :                         pusbCommon = (PUSB_COMMON_DESCRIPTOR)(pDataBuffer + offset + interfaceDescExtendedBytes);

  001b4	e08a2005	 add         r2, r10, r5

; 610  :                         if ( pusbCommon->bDescriptorType != USB_INTERFACE_DESCRIPTOR_TYPE &&
; 611  :                              pusbCommon->bDescriptorType != USB_ENDPOINT_DESCRIPTOR_TYPE &&
; 612  :                              offset + interfaceDescExtendedBytes + pusbCommon->bLength <= dataBufferLen ) {

  001b8	e5d23001	 ldrb        r3, [r2, #1]
  001bc	e3530004	 cmp         r3, #4
  001c0	0a00000a	 beq         |$LN18@CreateUsbC|
  001c4	e3530005	 cmp         r3, #5
  001c8	0a000008	 beq         |$LN18@CreateUsbC|
  001cc	e5d23000	 ldrb        r3, [r2]
  001d0	e0832005	 add         r2, r3, r5
  001d4	e0823004	 add         r3, r2, r4
  001d8	e1530009	 cmp         r3, r9
  001dc	8a000003	 bhi         |$LN18@CreateUsbC|
  001e0	e0823004	 add         r3, r2, r4
  001e4	e1530009	 cmp         r3, r9

; 613  : 
; 614  :                             interfaceDescExtendedBytes += pusbCommon->bLength;

  001e8	e1a05002	 mov         r5, r2
  001ec	3afffff0	 bcc         |$LL20@CreateUsbC|
  001f0		 |$LN18@CreateUsbC|

; 615  :                         } else {
; 616  :                             break;
; 617  :                         }
; 618  :                     }
; 619  :                     DEBUGCHK( rInterface.lpbExtended == NULL );
; 620  :                     if ( interfaceDescExtendedBytes > 0 ) {

  001f0	e3550000	 cmp         r5, #0
  001f4	0a000009	 beq         |$LN16@CreateUsbC|

; 621  :                         rInterface.lpbExtended = new BYTE[ interfaceDescExtendedBytes ];

  001f8	e1a00005	 mov         r0, r5
  001fc	eb000000	 bl          |??2@YAPAXI@Z|
  00200	e3500000	 cmp         r0, #0
  00204	e5860010	 str         r0, [r6, #0x10]

; 622  :                         if ( rInterface.lpbExtended == NULL ) {

  00208	0a000053	 beq         |$configDescMemoryError$35903|

; 623  :                             goto configDescMemoryError;
; 624  :                         }
; 625  :                         rInterface.dwExtendedSize = interfaceDescExtendedBytes ;
; 626  :                         memcpy( rInterface.lpbExtended, pDataBuffer + offset, interfaceDescExtendedBytes );

  0020c	e1a02005	 mov         r2, r5
  00210	e1a0100a	 mov         r1, r10
  00214	e5865018	 str         r5, [r6, #0x18]
  00218	eb000000	 bl          memcpy

; 627  :                         offset += interfaceDescExtendedBytes;

  0021c	e0844005	 add         r4, r4, r5
  00220		 |$LN16@CreateUsbC|

; 628  :                     #ifdef DEBUG
; 629  :                         DumpExtendedBytes( rInterface.lpbExtended, interfaceDescExtendedBytes );
; 630  :                     #endif // DEBUG
; 631  :                     }
; 632  :                 }
; 633  : 
; 634  :                 // 3) allocate any endpoints
; 635  :                 DEBUGCHK( rInterface.lpEndpoints == NULL );
; 636  :                 if ( rInterface.Descriptor.bNumEndpoints == 0 ) {

  00220	e5d63008	 ldrb        r3, [r6, #8]
  00224	e3530000	 cmp         r3, #0
  00228	0a00003f	 beq         |$LN22@CreateUsbC|

; 637  :                     continue; // continue interface loop
; 638  :                 }
; 639  :                 rInterface.lpEndpoints = new NON_CONST_USB_ENDPOINT[ rInterface.Descriptor.bNumEndpoints ];

  0022c	e0833103	 add         r3, r3, r3, lsl #2
  00230	e1a00103	 mov         r0, r3, lsl #2
  00234	eb000000	 bl          |??2@YAPAXI@Z|
  00238	e3500000	 cmp         r0, #0
  0023c	e5860014	 str         r0, [r6, #0x14]

; 640  :                 if ( rInterface.lpEndpoints == NULL ) {

  00240	0a000045	 beq         |$configDescMemoryError$35903|

; 641  :                     goto configDescMemoryError;
; 642  :                 }
; 643  : 
; 644  :                 memset( rInterface.lpEndpoints, 0, rInterface.Descriptor.bNumEndpoints * sizeof( NON_CONST_USB_ENDPOINT ) );

  00244	e5d63008	 ldrb        r3, [r6, #8]
  00248	e3a01000	 mov         r1, #0
  0024c	e0833103	 add         r3, r3, r3, lsl #2
  00250	e1a02103	 mov         r2, r3, lsl #2
  00254	eb000000	 bl          memset

; 645  :                 for ( UINT endpoint = 0; endpoint < rInterface.Descriptor.bNumEndpoints; endpoint++ ) {

  00258	e5d63008	 ldrb        r3, [r6, #8]
  0025c	e3a0b000	 mov         r11, #0
  00260	e3530000	 cmp         r3, #0
  00264	0a000030	 beq         |$LN22@CreateUsbC|

; 641  :                     goto configDescMemoryError;
; 642  :                 }
; 643  : 
; 644  :                 memset( rInterface.lpEndpoints, 0, rInterface.Descriptor.bNumEndpoints * sizeof( NON_CONST_USB_ENDPOINT ) );

  00268	e3a0a000	 mov         r10, #0
  0026c		 |$LL10@CreateUsbC|

; 646  :                     NON_CONST_USB_ENDPOINT & rEndpoint = rInterface.lpEndpoints[ endpoint ];

  0026c	e5963014	 ldr         r3, [r6, #0x14]

; 647  :                     rEndpoint.dwCount = sizeof( NON_CONST_USB_ENDPOINT );
; 648  : 
; 649  :                     // should now be pointing at an endpoint descriptor
; 650  :                     PUSB_ENDPOINT_DESCRIPTOR pusbEndpointDesc = (PUSB_ENDPOINT_DESCRIPTOR)(pDataBuffer + offset);
; 651  :                     DEBUGCHK( pusbEndpointDesc->bDescriptorType == USB_ENDPOINT_DESCRIPTOR_TYPE &&
; 652  :                               pusbEndpointDesc->bLength >= sizeof( USB_ENDPOINT_DESCRIPTOR ) );
; 653  : 
; 654  :                     // 4a) copy the endpoint descriptor
; 655  :                     memcpy( &rEndpoint.Descriptor, pDataBuffer + offset, sizeof( USB_ENDPOINT_DESCRIPTOR ) );

  00270	e3a01014	 mov         r1, #0x14
  00274	e3a02007	 mov         r2, #7
  00278	e7a3100a	 str         r1, [r3, +r10]!
  0027c	e0841008	 add         r1, r4, r8
  00280	e2830004	 add         r0, r3, #4
  00284	e58d3008	 str         r3, [sp, #8]
  00288	eb000000	 bl          memcpy

; 656  :                     offset += pusbEndpointDesc->bLength;

  0028c	e7d43008	 ldrb        r3, [r4, +r8]

; 657  :                 #ifdef DEBUG
; 658  :                     DumpEndpointDescriptor( &rEndpoint.Descriptor );
; 659  :                 #endif // DEBUG
; 660  : 
; 661  :                     // 4b) copy any extended info, if it exists
; 662  :                     UINT endpointDescExtendedBytes = 0;

  00290	e3a05000	 mov         r5, #0
  00294	e0844003	 add         r4, r4, r3

; 663  :                     while ( offset + endpointDescExtendedBytes < dataBufferLen ) {

  00298	e1540009	 cmp         r4, r9
  0029c	2a00001d	 bcs         |$LN9@CreateUsbC|
  002a0	e0847008	 add         r7, r4, r8
  002a4		 |$LL7@CreateUsbC|

; 664  :                         pusbCommon = (PUSB_COMMON_DESCRIPTOR)(pDataBuffer + offset + endpointDescExtendedBytes);

  002a4	e0872005	 add         r2, r7, r5

; 665  :                         if ( pusbCommon->bDescriptorType != USB_ENDPOINT_DESCRIPTOR_TYPE &&
; 666  :                              pusbCommon->bDescriptorType != USB_INTERFACE_DESCRIPTOR_TYPE &&
; 667  :                              offset + endpointDescExtendedBytes + pusbCommon->bLength <= dataBufferLen ) {

  002a8	e5d23001	 ldrb        r3, [r2, #1]
  002ac	e3530005	 cmp         r3, #5
  002b0	0a00000a	 beq         |$LN5@CreateUsbC|
  002b4	e3530004	 cmp         r3, #4
  002b8	0a000008	 beq         |$LN5@CreateUsbC|
  002bc	e5d23000	 ldrb        r3, [r2]
  002c0	e0832005	 add         r2, r3, r5
  002c4	e0823004	 add         r3, r2, r4
  002c8	e1530009	 cmp         r3, r9
  002cc	8a000003	 bhi         |$LN5@CreateUsbC|
  002d0	e0823004	 add         r3, r2, r4
  002d4	e1530009	 cmp         r3, r9

; 668  : 
; 669  :                             endpointDescExtendedBytes += pusbCommon->bLength;

  002d8	e1a05002	 mov         r5, r2
  002dc	3afffff0	 bcc         |$LL7@CreateUsbC|
  002e0		 |$LN5@CreateUsbC|

; 670  :                         } else {
; 671  :                             break;
; 672  :                         }
; 673  :                     }
; 674  :                     DEBUGCHK( rEndpoint.lpbExtended == NULL );
; 675  :                     if ( endpointDescExtendedBytes > 0 ) {

  002e0	e59d7004	 ldr         r7, [sp, #4]
  002e4	e3550000	 cmp         r5, #0
  002e8	0a00000a	 beq         |$LN9@CreateUsbC|

; 676  :                         rEndpoint.lpbExtended = new BYTE[ endpointDescExtendedBytes ];

  002ec	e1a00005	 mov         r0, r5
  002f0	eb000000	 bl          |??2@YAPAXI@Z|
  002f4	e59d3008	 ldr         r3, [sp, #8]
  002f8	e3500000	 cmp         r0, #0
  002fc	e583000c	 str         r0, [r3, #0xC]

; 677  :                         if ( rEndpoint.lpbExtended == NULL ) {

  00300	0a000015	 beq         |$configDescMemoryError$35903|

; 678  :                             goto configDescMemoryError;
; 679  :                         }
; 680  :                         rEndpoint.dwExtendedSize = endpointDescExtendedBytes ;
; 681  :                         memcpy( rEndpoint.lpbExtended, pDataBuffer + offset, endpointDescExtendedBytes );

  00304	e1a02005	 mov         r2, r5
  00308	e0841008	 add         r1, r4, r8
  0030c	e5835010	 str         r5, [r3, #0x10]
  00310	eb000000	 bl          memcpy

; 682  :                         offset += endpointDescExtendedBytes;

  00314	e0844005	 add         r4, r4, r5
  00318		 |$LN9@CreateUsbC|
  00318	e5d63008	 ldrb        r3, [r6, #8]
  0031c	e28bb001	 add         r11, r11, #1
  00320	e28aa014	 add         r10, r10, #0x14
  00324	e15b0003	 cmp         r11, r3
  00328	3affffcf	 bcc         |$LL10@CreateUsbC|
  0032c		 |$LN22@CreateUsbC|

; 579  :             for ( UCHAR interfaceNumber = 0; interfaceNumber < rConfig.dwNumInterfaces; interfaceNumber++ ) {

  0032c	e5dd3000	 ldrb        r3, [sp]
  00330	e5972014	 ldr         r2, [r7, #0x14]
  00334	e2833001	 add         r3, r3, #1
  00338	e20310ff	 and         r1, r3, #0xFF
  0033c	e1510002	 cmp         r1, r2
  00340	e3a0201c	 mov         r2, #0x1C
  00344	e5cd1000	 strb        r1, [sp]
  00348	3affff8c	 bcc         |$LL23@CreateUsbC|
  0034c		 |$LN21@CreateUsbC|

; 683  :                     #ifdef DEBUG
; 684  :                         DumpExtendedBytes( rEndpoint.lpbExtended, endpointDescExtendedBytes );
; 685  :                     #endif // DEBUG
; 686  :                     }
; 687  :                 } // end endpoint for loop
; 688  :             } // end interface for loop
; 689  :         } // end check for interfaces
; 690  :         retval = TRUE;

  0034c	e3a00001	 mov         r0, #1
  00350		 |$LN37@CreateUsbC|

; 700  : }

  00350	e28dd010	 add         sp, sp, #0x10
  00354	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00358	e12fff1e	 bx          lr
  0035c		 |$configDescMemoryError$35903|

; 691  :     }
; 692  :     DEBUGMSG( ZONE_DESCRIPTORS && ZONE_VERBOSE, (TEXT("%s: -CDevice::CreateUsbConfigurationStructure - returning %d\n"),GetControllerName(), retval));
; 693  :     return retval;
; 694  : 
; 695  : 
; 696  : configDescMemoryError:
; 697  :     DEBUGMSG( ZONE_ERROR, (TEXT("%s: -CDevice::CreateUsbConfigurationStructure - error allocating memory\n"),GetControllerName()));
; 698  :     DeleteUsbConfigurationStructure( rConfig );

  0035c	e59d000c	 ldr         r0, [sp, #0xC]
  00360	e1a01007	 mov         r1, r7
  00364	eb000000	 bl          |?DeleteUsbConfigurationStructure@CDevice@@QBAXAAU_NON_CONST_USB_CONFIGURATION@@@Z|

; 699  :     return FALSE;

  00368	e3a00000	 mov         r0, #0
  0036c	eafffff7	 b           |$LN37@CreateUsbC|
  00370		 |$LN57@CreateUsbC|
  00370		 |$LN58@CreateUsbC|
  00370	09249249	 DCD         0x9249249
  00374		 |$M38846|

			 ENDP  ; |?CreateUsbConfigurationStructure@CDevice@@QBAHAAU_NON_CONST_USB_CONFIGURATION@@QAEI@Z|, CDevice::CreateUsbConfigurationStructure

	EXPORT	|??0CHub@@QAA@EABU_USB_DEVICE_INFO@@HHEABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@QAV0@E@Z| ; CHub::CHub
	EXPORT	|??_7CHub@@6B@| [ DATA ]		; CHub::`vftable'
	EXPORT	|?ResumeNotification@CHub@@UAAHXZ|	; CHub::ResumeNotification
	EXPORT	|?DisableOffStreamDevice@CHub@@UAAHIH@Z| ; CHub::DisableOffStreamDevice
	EXPORT	|?SignalHubStatusChange@CHub@@UAAXXZ|	; CHub::SignalHubStatusChange
	IMPORT	|CreateEventW|
	IMPORT	|??_ECHub@@UAAPAXI@Z|, WEAK |??_GCHub@@UAAPAXI@Z| ; CHub::`vector deleting destructor', CHub::`scalar deleting destructor'

  00000			 AREA	 |.pdata|, PDATA
|$T38864| DCD	|$LN5@CHub|
	DCD	0x40002d02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7CHub@@6B@| DCD |??_ECHub@@UAAPAXI@Z|		; CHub::`vftable'
	DCD	|_purecall|
	DCD	|?OpenPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IQBU_USB_ENDPOINT_DESCRIPTOR@@QAI@Z|
	DCD	|?ClosePipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|
	DCD	|?IssueTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z|
	DCD	|?AbortTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXQBX@Z|
	DCD	|?IsPipeHalted@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQAH@Z|
	DCD	|?ResetPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|
	DCD	|?DisableDevice@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|
	DCD	|?SuspendResume@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|
	DCD	|?ResumeNotification@CHub@@UAAHXZ|
	DCD	|?NotifyOnSuspendedResumed@CHub@@UAAHH@Z|
	DCD	|?HandleDetach@CHub@@UAAXXZ|
	DCD	|?GetUSB2TT@CDevice@@UAAPAVCHub@@AAE0AAH@Z|
	DCD	|?SignalHub@CDevice@@UAAXXZ|
	DCD	|?DisableOffStreamDevice@CHub@@UAAHIH@Z|
	DCD	|?SuspendResumeOffStreamDevice@CHub@@UAAHIH@Z|
	DCD	|?SignalHubStatusChange@CHub@@UAAXXZ|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CHub@@QAA@EABU_USB_DEVICE_INFO@@HHEABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@QAV0@E@Z| PROC ; CHub::CHub

; 992  : {

  00000		 |$LN5@CHub|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M38861|
  00008	e1a08000	 mov         r8, r0
  0000c	e5dd5040	 ldrb        r5, [sp, #0x40]
  00010	e59d603c	 ldr         r6, [sp, #0x3C]
  00014	e59d7038	 ldr         r7, [sp, #0x38]
  00018	e5dde030	 ldrb        lr, [sp, #0x30]
  0001c	e59d402c	 ldr         r4, [sp, #0x2C]
  00020	e58d5010	 str         r5, [sp, #0x10]
  00024	e58d600c	 str         r6, [sp, #0xC]
  00028	e58d7008	 str         r7, [sp, #8]
  0002c	e58de004	 str         lr, [sp, #4]
  00030	e58d4000	 str         r4, [sp]
  00034	eb000000	 bl          |??0CDevice@@QAA@EABU_USB_DEVICE_INFO@@HHEQAVCDeviceGlobal@@QAVCHub@@E@Z|
  00038	e59f3070	 ldr         r3, [pc, #0x70]
  0003c	e1a00008	 mov         r0, r8
  00040	e59d1034	 ldr         r1, [sp, #0x34]
  00044	e4803068	 str         r3, [r0], #0x68
  00048	e3a02047	 mov         r2, #0x47
  0004c	eb000000	 bl          memcpy
  00050	e3a0e000	 mov         lr, #0

; 993  :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: +CHub::CHub\n"),GetControllerName()) );
; 994  :     m_pDetachedDevice=NULL;
; 995  :     m_pDetachedDeviceHandled = CreateEvent(NULL,TRUE,FALSE,NULL); // Manual Reset Event;

  00054	e3a03000	 mov         r3, #0
  00058	e3a02000	 mov         r2, #0
  0005c	e3a01001	 mov         r1, #1
  00060	e3a00000	 mov         r0, #0
  00064	e588e0b0	 str         lr, [r8, #0xB0]
  00068	e588e0b8	 str         lr, [r8, #0xB8]
  0006c	e588e0bc	 str         lr, [r8, #0xBC]
  00070	e588e0c0	 str         lr, [r8, #0xC0]
  00074	e588e060	 str         lr, [r8, #0x60]
  00078	e58870c8	 str         r7, [r8, #0xC8]
  0007c	eb000000	 bl          CreateEventW
  00080	e1a03000	 mov         r3, r0

; 996  :     m_hHubSuspendBlockEvent = CreateEvent(NULL,TRUE,TRUE,NULL); // Manual Reset Event;

  00084	e5883064	 str         r3, [r8, #0x64]
  00088	e3a03000	 mov         r3, #0
  0008c	e3a00000	 mov         r0, #0
  00090	e3a02001	 mov         r2, #1
  00094	e3a01001	 mov         r1, #1
  00098	eb000000	 bl          CreateEventW
  0009c	e58800c4	 str         r0, [r8, #0xC4]

; 997  :     DEBUGCHK( rDeviceInfo.Descriptor.bDeviceClass == USB_DEVICE_CLASS_HUB &&
; 998  :               rUsbHubDescriptor.bDescriptorType == USB_HUB_DESCRIPTOR_TYPE &&
; 999  :               rUsbHubDescriptor.bDescriptorLength >= USB_HUB_DESCRIPTOR_MINIMUM_SIZE &&
; 1000 :               rUsbHubDescriptor.bNumberOfPorts > 0 &&
; 1001 :               tierNumber <= USB_MAXIMUM_HUB_TIER );
; 1002 : 
; 1003 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: -CHub::CHub\n"),GetControllerName()) );
; 1004 : }

  000a0	e1a00008	 mov         r0, r8
  000a4	e28dd014	 add         sp, sp, #0x14
  000a8	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000ac	e12fff1e	 bx          lr
  000b0		 |$LN6@CHub|
  000b0		 |$LN7@CHub|
  000b0	00000000	 DCD         |??_7CHub@@6B@|
  000b4		 |$M38862|

			 ENDP  ; |??0CHub@@QAA@EABU_USB_DEVICE_INFO@@HHEABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@QAV0@E@Z|, CHub::CHub

; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T38881| DCD	|$LN7@ResumeNoti@2|
	DCD	0x40000901
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.hpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResumeNotification@CHub@@UAAHXZ| PROC ; CHub::ResumeNotification

; 396  :     virtual BOOL ResumeNotification() { 

  00000		 |$LN7@ResumeNoti@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38878|
  00004	e1a03000	 mov         r3, r0

; 397  :         DEBUGMSG( ZONE_ATTACH, (TEXT("CHub(%s tier %d):: ResumeNotification(%d) !\n"), GetDeviceType(), m_tierNumber,m_address) );
; 398  :         m_fIsSuspend = FALSE;
; 399  :         return SetEvent(m_hHubSuspendBlockEvent);

  00008	e59300c4	 ldr         r0, [r3, #0xC4]
  0000c	e3a02000	 mov         r2, #0
  00010	e3a01003	 mov         r1, #3
  00014	e5832058	 str         r2, [r3, #0x58]
  00018	eb000000	 bl          EventModify

; 400  :     };

  0001c	e49de004	 ldr         lr, [sp], #4
  00020	e12fff1e	 bx          lr
  00024		 |$M38879|

			 ENDP  ; |?ResumeNotification@CHub@@UAAHXZ|, CHub::ResumeNotification


  00000			 AREA	 |.pdata|, PDATA
|$T38892| DCD	|$LN11@SignalHubS|
	DCD	0x40001a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SignalHubStatusChange@CHub@@UAAXXZ| PROC ; CHub::SignalHubStatusChange

; 404  :     virtual void SignalHubStatusChange() {                

  00000		 |$LN11@SignalHubS|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M38889|
  00004	e1a04000	 mov         r4, r0

; 405  :         for (UCHAR port2 = 1; port2 <= m_usbHubDescriptor.bNumberOfPorts; port2++)

  00008	e5d4306a	 ldrb        r3, [r4, #0x6A]
  0000c	e3a01001	 mov         r1, #1
  00010	e3530001	 cmp         r3, #1
  00014	3a000011	 bcc         |$LN2@SignalHubS|
  00018	e3a05001	 mov         r5, #1
  0001c		 |$LL4@SignalHubS|

; 406  :         {
; 407  :             if (m_ppCDeviceOnPort[port2-1] != NULL)

  0001c	e59430b0	 ldr         r3, [r4, #0xB0]
  00020	e0833101	 add         r3, r3, r1, lsl #2
  00024	e5133004	 ldr         r3, [r3, #-4]
  00028	e3530000	 cmp         r3, #0

; 408  :             {
; 409  :                 m_ppCDeviceOnPort[port2-1]->SignalHub();                

  0002c	159430b0	 ldrne       r3, [r4, #0xB0]
  00030	10833101	 addne       r3, r3, r1, lsl #2
  00034	15130004	 ldrne       r0, [r3, #-4]
  00038	15903000	 ldrne       r3, [r0]
  0003c	15933038	 ldrne       r3, [r3, #0x38]
  00040	11a0e00f	 movne       lr, pc
  00044	112fff13	 bxne        r3
  00048	e5d4206a	 ldrb        r2, [r4, #0x6A]
  0004c	e2853001	 add         r3, r5, #1
  00050	e20310ff	 and         r1, r3, #0xFF
  00054	e1a05001	 mov         r5, r1
  00058	e1510002	 cmp         r1, r2
  0005c	9affffee	 bls         |$LL4@SignalHubS|
  00060		 |$LN2@SignalHubS|

; 410  :             }
; 411  :              
; 412  :         }
; 413  :     };    

  00060	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00064	e12fff1e	 bx          lr
  00068		 |$M38890|

			 ENDP  ; |?SignalHubStatusChange@CHub@@UAAXXZ|, CHub::SignalHubStatusChange

	EXPORT	|??1CHub@@UAA@XZ|			; CHub::~CHub
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T38902| DCD	|$LN9@CHub@2|
	DCD	0x40001e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CHub@@UAA@XZ| PROC			; CHub::~CHub

; 1018 : {

  00000		 |$LN9@CHub@2|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M38899|
  00004	e1a04000	 mov         r4, r0
  00008	e59f3064	 ldr         r3, [pc, #0x64]

; 1019 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: +CHub::~CHub\n"),GetControllerName()) );
; 1020 : 
; 1021 :     // this should have been taken care of in HandleDetach,
; 1022 :     // or if EnterOperationalState failed.
; 1023 :     DEBUGCHK( m_hHubStatusChangeEvent == NULL );
; 1024 :     DEBUGCHK( m_hHubStatusChangeThread == NULL );
; 1025 :     DEBUGCHK( m_pDetachedDevice == NULL);
; 1026 : 
; 1027 : #ifdef DEBUG
; 1028 :     if ( m_ppCDeviceOnPort != NULL ) {
; 1029 :         for ( UCHAR port = 1; port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {
; 1030 :             // devices should have been freed by HandleDetach
; 1031 :             DEBUGCHK( m_ppCDeviceOnPort[ port - 1 ] == NULL );
; 1032 :         }
; 1033 :     }
; 1034 : #endif // DEBUG
; 1035 :     if (m_ppCDeviceOnPort){

  0000c	e59420b0	 ldr         r2, [r4, #0xB0]
  00010	e3a05000	 mov         r5, #0
  00014	e5843000	 str         r3, [r4]
  00018	e3520000	 cmp         r2, #0
  0001c	0a000002	 beq         |$LN4@CHub@2|

; 1036 :         delete [] m_ppCDeviceOnPort;

  00020	e1a00002	 mov         r0, r2
  00024	eb000000	 bl          |??3@YAXPAX@Z|

; 1037 :         m_ppCDeviceOnPort = NULL;

  00028	e58450b0	 str         r5, [r4, #0xB0]
  0002c		 |$LN4@CHub@2|

; 1038 :     }
; 1039 :     if (m_pAddedTT){

  0002c	e59430b4	 ldr         r3, [r4, #0xB4]
  00030	e3530000	 cmp         r3, #0
  00034	0a000002	 beq         |$LN3@CHub@2|

; 1040 :         delete m_pAddedTT;

  00038	e1a00003	 mov         r0, r3
  0003c	eb000000	 bl          |??3@YAXPAX@Z|

; 1041 :         m_pAddedTT = NULL;

  00040	e58450b4	 str         r5, [r4, #0xB4]
  00044		 |$LN3@CHub@2|

; 1042 :     }
; 1043 :     if (m_pDetachedDeviceHandled)

  00044	e5943064	 ldr         r3, [r4, #0x64]
  00048	e3530000	 cmp         r3, #0

; 1044 :         CloseHandle(m_pDetachedDeviceHandled );    

  0004c	11a00003	 movne       r0, r3
  00050	1b000000	 blne        CloseHandle

; 1045 :     if (m_hHubSuspendBlockEvent)

  00054	e59430c4	 ldr         r3, [r4, #0xC4]
  00058	e3530000	 cmp         r3, #0

; 1046 :         CloseHandle(m_hHubSuspendBlockEvent);

  0005c	11a00003	 movne       r0, r3
  00060	1b000000	 blne        CloseHandle

; 1047 :     // nothing to do with m_usbHubDescriptor
; 1048 :     // nothing to do with m_fHubThreadClosing
; 1049 : 
; 1050 :     // rest of work done in ~CDevice
; 1051 : 
; 1052 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: -CHub::~CHub\n"),GetControllerName()) );
; 1053 : }

  00064	e1a00004	 mov         r0, r4
  00068	eb000000	 bl          |??1CDevice@@UAA@XZ|
  0006c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00070	e12fff1e	 bx          lr
  00074		 |$LN10@CHub@2|
  00074		 |$LN11@CHub@2|
  00074	00000000	 DCD         |??_7CHub@@6B@|
  00078		 |$M38900|

			 ENDP  ; |??1CHub@@UAA@XZ|, CHub::~CHub

	EXPORT	|?DetachDownstreamDeviceThreadStub@CHub@@KAKPAX@Z| ; CHub::DetachDownstreamDeviceThreadStub

  00000			 AREA	 |.pdata|, PDATA
|$T38914| DCD	|$LN5@DetachDown@2|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DetachDownstreamDeviceThreadStub@CHub@@KAKPAX@Z| PROC ; CHub::DetachDownstreamDeviceThreadStub

; 2089 : {

  00000		 |$LN5@DetachDown@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38911|

; 2090 :     return ((CHub *)context )->DetachDownstreamDeviceThread();

  00004	eb000000	 bl          |?DetachDownstreamDeviceThread@CHub@@IAAKXZ|

; 2091 : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M38912|

			 ENDP  ; |?DetachDownstreamDeviceThreadStub@CHub@@KAKPAX@Z|, CHub::DetachDownstreamDeviceThreadStub

	EXPORT	|?DetachDevice@CHub@@IAAXE@Z|		; CHub::DetachDevice
	IMPORT	|CeGetThreadPriority|
	IMPORT	|CeSetThreadPriority|
	IMPORT	|g_IstThreadPriority|
	IMPORT	|CreateThread|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T38940| DCD	|$LN19@DetachDevi|
	DCD	0x40005002
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DetachDevice@CHub@@IAAXE@Z| PROC	; CHub::DetachDevice

; 2144 : {

  00000		 |$LN19@DetachDevi|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M38937|
  00008	e1a06001	 mov         r6, r1
  0000c	e1a05000	 mov         r5, r0

; 2145 :     DEBUGMSG( ZONE_ATTACH, (TEXT("%s: +CHub(%s tier %d)::DetachDevice - port = %d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, port) );
; 2146 : 
; 2147 :     CDevice*    pDevToDetach = NULL;
; 2148 :     // remove the device from our array. This will prevent
; 2149 :     // USBD from issuing any more requests to the device
; 2150 :     // or its pipes.
; 2151 :     EnterCriticalSection( &m_csDeviceLock );

  00010	e285000c	 add         r0, r5, #0xC
  00014	eb000000	 bl          EnterCriticalSection

; 2152 :     PREFAST_DEBUGCHK( m_ppCDeviceOnPort != NULL );
; 2153 :     DEBUGCHK( port >= 1 &&
; 2154 :               port <= m_usbHubDescriptor.bNumberOfPorts );
; 2155 :     pDevToDetach = m_ppCDeviceOnPort[ port - 1 ];

  00018	e59530b0	 ldr         r3, [r5, #0xB0]

; 2156 :     m_ppCDeviceOnPort[ port - 1 ] = NULL;

  0001c	e3a07000	 mov         r7, #0
  00020	e0833106	 add         r3, r3, r6, lsl #2
  00024	e5132004	 ldr         r2, [r3, #-4]
  00028	e5037004	 str         r7, [r3, #-4]
  0002c	e1b04002	 movs        r4, r2

; 2157 :     if (pDevToDetach) {
; 2158 :         BOOL fSuccess;
; 2159 :         //fSuccess = IncrCountdown(&m_objCountdown);
; 2160 :         fSuccess = m_pDeviceGlobal->ObjCountdownInc();

  00030	15953050	 ldrne       r3, [r5, #0x50]
  00034	12830054	 addne       r0, r3, #0x54
  00038	1b000000	 blne        |?IncrCountdown@Countdown@@QAAHXZ|

; 2161 :         // if the countdown couldn't be incremented then it must have
; 2162 :         // been deleted already, which would mean that all devices
; 2163 :         // have already been detached. Which would mean that the current
; 2164 :         // thread has already exited which is clearly not the case.
; 2165 :         DEBUGCHK( fSuccess );
; 2166 :     }
; 2167 :     LeaveCriticalSection( &m_csDeviceLock );

  0003c	e285000c	 add         r0, r5, #0xC
  00040	eb000000	 bl          LeaveCriticalSection

; 2168 :     // it is possible that we get a device detach
; 2169 :     // on a NULL device. That is, if we failed to
; 2170 :     // configure the device and it was left plugged
; 2171 :     // into the USB port. When it is unplugged, a
; 2172 :     // detach message will be read from the port.
; 2173 :     DEBUGMSG( ZONE_ATTACH && ZONE_WARNING && !pDevToDetach, (TEXT("%s: CHub(%s tier %d)::DetachDevice - reading NULL device detached on port %d, doing nothing.\n"),GetControllerName(), GetDeviceType(), m_tierNumber, port) );
; 2174 :     if ( pDevToDetach != NULL ) {

  00044	e3540000	 cmp         r4, #0
  00048	0a000028	 beq         |$LN5@DetachDevi|

; 2175 :         ASSERT(m_pDetachedDevice==NULL);
; 2176 :         m_pDetachedDevice=pDevToDetach;
; 2177 :         HANDLE hWorkerThread = NULL;
; 2178 :         if (m_pDetachedDeviceHandled) {

  0004c	e5953064	 ldr         r3, [r5, #0x64]
  00050	e5854060	 str         r4, [r5, #0x60]
  00054	e3530000	 cmp         r3, #0
  00058	0a000016	 beq         |$LN3@DetachDevi|

; 2179 :             ResetEvent(m_pDetachedDeviceHandled);

  0005c	e3a01002	 mov         r1, #2
  00060	e1a00003	 mov         r0, r3
  00064	eb000000	 bl          EventModify

; 2180 :             hWorkerThread=CreateThread( 0, 0, DetachDownstreamDeviceThreadStub, this, 0, NULL );

  00068	e59f20cc	 ldr         r2, [pc, #0xCC]
  0006c	e1a03005	 mov         r3, r5
  00070	e3a01000	 mov         r1, #0
  00074	e3a00000	 mov         r0, #0
  00078	e58d7004	 str         r7, [sp, #4]
  0007c	e58d7000	 str         r7, [sp]
  00080	eb000000	 bl          CreateThread
  00084	e1b04000	 movs        r4, r0

; 2181 :         }
; 2182 :         if ( hWorkerThread != NULL ) {

  00088	0a00000a	 beq         |$LN3@DetachDevi|

; 2183 :             DEBUGMSG( ZONE_ATTACH, (TEXT("%s: CHub(%s tier %d)::DetachDevice - created worker thread to handle device detach\n"),GetControllerName(), GetDeviceType(), m_tierNumber ));
; 2184 :             CeSetThreadPriority( hWorkerThread, g_IstThreadPriority + RELATIVE_PRIO_DOWNSTREAM);

  0008c	e59f30a4	 ldr         r3, [pc, #0xA4]
  00090	e1a00004	 mov         r0, r4
  00094	e5933000	 ldr         r3, [r3]
  00098	e2831003	 add         r1, r3, #3
  0009c	eb000000	 bl          CeSetThreadPriority

; 2185 :             // Wait for Thread DetachDownstreamDeviceThreadStub take m_pDetachedDevice before ending.
; 2186 :             WaitForSingleObject(m_pDetachedDeviceHandled,INFINITE);

  000a0	e5950064	 ldr         r0, [r5, #0x64]
  000a4	e3e01000	 mvn         r1, #0
  000a8	eb000000	 bl          WaitForSingleObject

; 2187 :             ASSERT(m_pDetachedDevice==NULL);
; 2188 :             CloseHandle( hWorkerThread );

  000ac	e1a00004	 mov         r0, r4
  000b0	eb000000	 bl          CloseHandle

; 2189 :             hWorkerThread = NULL;
; 2190 :         } else {

  000b4	ea000007	 b           |$LN2@DetachDevi|
  000b8		 |$LN3@DetachDevi|

; 2191 :             DWORD OriginalPrio = CeGetThreadPriority(GetCurrentThread());

  000b8	e3a00041	 mov         r0, #0x41
  000bc	eb000000	 bl          CeGetThreadPriority
  000c0	e1a04000	 mov         r4, r0

; 2192 :             // no threads available - need to handle detach ourself, which
; 2193 :             // can potentially block this hub for a while
; 2194 :             DEBUGMSG( ZONE_ATTACH, (TEXT("%s: CHub(%s tier %d)::DetachDevice - no threads available, doing detach work now.\n"),GetControllerName(), GetDeviceType(), m_tierNumber ));
; 2195 :             DetachDownstreamDeviceThread();

  000c4	e1a00005	 mov         r0, r5
  000c8	eb000000	 bl          |?DetachDownstreamDeviceThread@CHub@@IAAKXZ|

; 2196 :             CeSetThreadPriority(GetCurrentThread(), OriginalPrio);

  000cc	e1a01004	 mov         r1, r4
  000d0	e3a00041	 mov         r0, #0x41
  000d4	eb000000	 bl          CeSetThreadPriority
  000d8		 |$LN2@DetachDevi|

; 2197 :         }
; 2198 :         DEBUGCHK( hWorkerThread == NULL );
; 2199 :         DisablePort( port );

  000d8	e5953000	 ldr         r3, [r5]
  000dc	e1a01006	 mov         r1, r6
  000e0	e1a00005	 mov         r0, r5
  000e4	e5933060	 ldr         r3, [r3, #0x60]
  000e8	e1a0e00f	 mov         lr, pc
  000ec	e12fff13	 bx          r3
  000f0		 |$LN5@DetachDevi|

; 2200 :     }
; 2201 :     if (m_pAddedTT[port-1]) {  // This is TT, we need delete this.

  000f0	e59530b4	 ldr         r3, [r5, #0xB4]
  000f4	e0833106	 add         r3, r3, r6, lsl #2
  000f8	e5133004	 ldr         r3, [r3, #-4]
  000fc	e3530000	 cmp         r3, #0
  00100	0a000009	 beq         |$LN1@DetachDevi|

; 2202 :         m_pDeviceGlobal->DeleteTt(m_address,port,m_pAddedTT[port-1]);

  00104	e5950050	 ldr         r0, [r5, #0x50]
  00108	e5d51020	 ldrb        r1, [r5, #0x20]
  0010c	e1a02006	 mov         r2, r6
  00110	e590e000	 ldr         lr, [r0]
  00114	e59e4004	 ldr         r4, [lr, #4]
  00118	e1a0e00f	 mov         lr, pc
  0011c	e12fff14	 bx          r4

; 2203 :         m_pAddedTT[port-1]=FALSE;

  00120	e59530b4	 ldr         r3, [r5, #0xB4]
  00124	e0833106	 add         r3, r3, r6, lsl #2
  00128	e5037004	 str         r7, [r3, #-4]
  0012c		 |$LN1@DetachDevi|

; 2204 :     }
; 2205 :     DEBUGMSG( ZONE_ATTACH, (TEXT("%s: -CHub(%s tier %d)::DetachDevice - port = %d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, port) );
; 2206 : }

  0012c	e28dd008	 add         sp, sp, #8
  00130	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00134	e12fff1e	 bx          lr
  00138		 |$LN20@DetachDevi|
  00138		 |$LN21@DetachDevi|
  00138	00000000	 DCD         |g_IstThreadPriority|
  0013c		 |$LN22@DetachDevi|
  0013c	00000000	 DCD         |?DetachDownstreamDeviceThreadStub@CHub@@KAKPAX@Z|
  00140		 |$M38938|

			 ENDP  ; |?DetachDevice@CHub@@IAAXE@Z|, CHub::DetachDevice

	EXPORT	|??0CRootHub@@QAA@ABU_USB_DEVICE_INFO@@HHABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@@Z| ; CRootHub::CRootHub
	EXPORT	|??_7CRootHub@@6B@| [ DATA ]		; CRootHub::`vftable'
	EXPORT	|?EnterOperationalState@CRootHub@@UAAHQAVCPipeAbs@@@Z| ; CRootHub::EnterOperationalState
	IMPORT	|??_ECRootHub@@UAAPAXI@Z|, WEAK |??_GCRootHub@@UAAPAXI@Z| ; CRootHub::`vector deleting destructor', CRootHub::`scalar deleting destructor'

  00000			 AREA	 |.pdata|, PDATA
|$T38956| DCD	|$LN5@CRootHub|
	DCD	0x40001802

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7CRootHub@@6B@| DCD |??_ECRootHub@@UAAPAXI@Z|	; CRootHub::`vftable'
	DCD	|?EnterOperationalState@CRootHub@@UAAHQAVCPipeAbs@@@Z|
	DCD	|?OpenPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IQBU_USB_ENDPOINT_DESCRIPTOR@@QAI@Z|
	DCD	|?ClosePipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|
	DCD	|?IssueTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z|
	DCD	|?AbortTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXQBX@Z|
	DCD	|?IsPipeHalted@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQAH@Z|
	DCD	|?ResetPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|
	DCD	|?DisableDevice@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|
	DCD	|?SuspendResume@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|
	DCD	|?ResumeNotification@CHub@@UAAHXZ|
	DCD	|?NotifyOnSuspendedResumed@CHub@@UAAHH@Z|
	DCD	|?HandleDetach@CHub@@UAAXXZ|
	DCD	|?GetUSB2TT@CDevice@@UAAPAVCHub@@AAE0AAH@Z|
	DCD	|?SignalHub@CDevice@@UAAXXZ|
	DCD	|?DisableOffStreamDevice@CHub@@UAAHIH@Z|
	DCD	|?SuspendResumeOffStreamDevice@CHub@@UAAHIH@Z|
	DCD	|?SignalHubStatusChange@CHub@@UAAXXZ|
	DCD	|?PowerAllHubPorts@CRootHub@@EAAHXZ|
	DCD	|?WaitForPortStatusChange@CRootHub@@EAAHAAEAAU_USB_HUB_AND_PORT_STATUS@@@Z|
	DCD	|?SetOrClearFeature@CRootHub@@EAAHGEG@Z|
	DCD	|?SetOrClearRemoteWakup@CRootHub@@EAAHH@Z|
	DCD	|?GetStatus@CRootHub@@EAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z|
	DCD	|?ResetAndEnablePort@CRootHub@@EAAHE@Z|
	DCD	|?DisablePort@CRootHub@@EAAXE@Z|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CRootHub@@QAA@ABU_USB_DEVICE_INFO@@HHABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@@Z| PROC ; CRootHub::CRootHub

; 2805 : {

  00000		 |$LN5@CRootHub|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M38953|
  00008	e1a04003	 mov         r4, r3
  0000c	e1a03002	 mov         r3, r2
  00010	e1a02001	 mov         r2, r1
  00014	e1a05000	 mov         r5, r0
  00018	e59d102c	 ldr         r1, [sp, #0x2C]
  0001c	e59de028	 ldr         lr, [sp, #0x28]
  00020	e3a06000	 mov         r6, #0
  00024	e58d100c	 str         r1, [sp, #0xC]
  00028	e3a01000	 mov         r1, #0
  0002c	e58de008	 str         lr, [sp, #8]
  00030	e58d6014	 str         r6, [sp, #0x14]
  00034	e58d6010	 str         r6, [sp, #0x10]
  00038	e58d6004	 str         r6, [sp, #4]
  0003c	e58d4000	 str         r4, [sp]
  00040	eb000000	 bl          |??0CHub@@QAA@EABU_USB_DEVICE_INFO@@HHEABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@QAV0@E@Z|
  00044	e59f3010	 ldr         r3, [pc, #0x10]

; 2806 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: +CRootHub::CRootHub\n"),GetControllerName()) );
; 2807 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: -CRootHub::CRootHub\n"),GetControllerName()) );
; 2808 : }

  00048	e1a00005	 mov         r0, r5
  0004c	e5853000	 str         r3, [r5]
  00050	e28dd018	 add         sp, sp, #0x18
  00054	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$LN6@CRootHub|
  0005c		 |$LN7@CRootHub|
  0005c	00000000	 DCD         |??_7CRootHub@@6B@|
  00060		 |$M38954|

			 ENDP  ; |??0CRootHub@@QAA@ABU_USB_DEVICE_INFO@@HHABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@@Z|, CRootHub::CRootHub

	EXPORT	|??1CRootHub@@UAA@XZ|			; CRootHub::~CRootHub

  00000			 AREA	 |.pdata|, PDATA
|$T38966| DCD	|$LN5@CRootHub@2|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CRootHub@@UAA@XZ| PROC		; CRootHub::~CRootHub

; 2822 : {

  00000		 |$LN5@CRootHub@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38963|
  00004	e1a02000	 mov         r2, r0
  00008	e59f300c	 ldr         r3, [pc, #0xC]

; 2823 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CRootHub::~CRootHub\n")) );
; 2824 :     // Nothing to do here yet...
; 2825 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: -CRootHub::~CRootHub\n"),GetControllerName()) );
; 2826 : }

  0000c	e5823000	 str         r3, [r2]
  00010	eb000000	 bl          |??1CHub@@UAA@XZ|
  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$LN6@CRootHub@2|
  0001c		 |$LN7@CRootHub@2|
  0001c	00000000	 DCD         |??_7CRootHub@@6B@|
  00020		 |$M38964|

			 ENDP  ; |??1CRootHub@@UAA@XZ|, CRootHub::~CRootHub

	EXPORT	|??0CExternalHub@@QAA@EABU_USB_DEVICE_INFO@@HHEABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@QAVCHub@@E@Z| ; CExternalHub::CExternalHub
	EXPORT	|??_7CExternalHub@@6B@| [ DATA ]	; CExternalHub::`vftable'
	EXPORT	|?EnterOperationalState@CExternalHub@@UAAHQAVCPipeAbs@@@Z| ; CExternalHub::EnterOperationalState
	IMPORT	|??_ECExternalHub@@UAAPAXI@Z|, WEAK |??_GCExternalHub@@UAAPAXI@Z| ; CExternalHub::`vector deleting destructor', CExternalHub::`scalar deleting destructor'

  00000			 AREA	 |.pdata|, PDATA
|$T38981| DCD	|$LN5@CExternalH|
	DCD	0x40001702

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7CExternalHub@@6B@| DCD |??_ECExternalHub@@UAAPAXI@Z| ; CExternalHub::`vftable'
	DCD	|?EnterOperationalState@CExternalHub@@UAAHQAVCPipeAbs@@@Z|
	DCD	|?OpenPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IQBU_USB_ENDPOINT_DESCRIPTOR@@QAI@Z|
	DCD	|?ClosePipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|
	DCD	|?IssueTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z|
	DCD	|?AbortTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXQBX@Z|
	DCD	|?IsPipeHalted@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQAH@Z|
	DCD	|?ResetPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|
	DCD	|?DisableDevice@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|
	DCD	|?SuspendResume@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|
	DCD	|?ResumeNotification@CHub@@UAAHXZ|
	DCD	|?NotifyOnSuspendedResumed@CHub@@UAAHH@Z|
	DCD	|?HandleDetach@CHub@@UAAXXZ|
	DCD	|?GetUSB2TT@CDevice@@UAAPAVCHub@@AAE0AAH@Z|
	DCD	|?SignalHub@CExternalHub@@UAAXXZ|
	DCD	|?DisableOffStreamDevice@CHub@@UAAHIH@Z|
	DCD	|?SuspendResumeOffStreamDevice@CHub@@UAAHIH@Z|
	DCD	|?SignalHubStatusChange@CHub@@UAAXXZ|
	DCD	|?PowerAllHubPorts@CExternalHub@@EAAHXZ|
	DCD	|?WaitForPortStatusChange@CExternalHub@@EAAHAAEAAU_USB_HUB_AND_PORT_STATUS@@@Z|
	DCD	|?SetOrClearFeature@CExternalHub@@EAAHGEG@Z|
	DCD	|?SetOrClearRemoteWakup@CExternalHub@@EAAHH@Z|
	DCD	|?GetStatus@CExternalHub@@EAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z|
	DCD	|?ResetAndEnablePort@CExternalHub@@EAAHE@Z|
	DCD	|?DisablePort@CExternalHub@@EAAXE@Z|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CExternalHub@@QAA@EABU_USB_DEVICE_INFO@@HHEABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@QAVCHub@@E@Z| PROC ; CExternalHub::CExternalHub

; 3134 : {

  00000		 |$LN5@CExternalH|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M38978|
  00008	e1a09000	 mov         r9, r0
  0000c	e5dde048	 ldrb        lr, [sp, #0x48]
  00010	e59d4044	 ldr         r4, [sp, #0x44]
  00014	e59d5040	 ldr         r5, [sp, #0x40]
  00018	e59d603c	 ldr         r6, [sp, #0x3C]
  0001c	e5dd7038	 ldrb        r7, [sp, #0x38]
  00020	e59d8034	 ldr         r8, [sp, #0x34]
  00024	e58de014	 str         lr, [sp, #0x14]
  00028	e58d4010	 str         r4, [sp, #0x10]
  0002c	e58d500c	 str         r5, [sp, #0xC]
  00030	e58d6008	 str         r6, [sp, #8]
  00034	e58d7004	 str         r7, [sp, #4]
  00038	e58d8000	 str         r8, [sp]
  0003c	eb000000	 bl          |??0CHub@@QAA@EABU_USB_DEVICE_INFO@@HHEABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@QAV0@E@Z|
  00040	e59f3010	 ldr         r3, [pc, #0x10]

; 3135 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: +CExternalHub::CExternalHub\n"),GetControllerName()) );
; 3136 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: -CExternalHub::CExternalHub\n"),GetControllerName()) );
; 3137 : }

  00044	e1a00009	 mov         r0, r9
  00048	e5893000	 str         r3, [r9]
  0004c	e28dd018	 add         sp, sp, #0x18
  00050	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$LN6@CExternalH|
  00058		 |$LN7@CExternalH|
  00058	00000000	 DCD         |??_7CExternalHub@@6B@|
  0005c		 |$M38979|

			 ENDP  ; |??0CExternalHub@@QAA@EABU_USB_DEVICE_INFO@@HHEABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@QAVCHub@@E@Z|, CExternalHub::CExternalHub

	EXPORT	|??1CExternalHub@@UAA@XZ|		; CExternalHub::~CExternalHub

  00000			 AREA	 |.pdata|, PDATA
|$T38991| DCD	|$LN5@CExternalH@2|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CExternalHub@@UAA@XZ| PROC		; CExternalHub::~CExternalHub

; 3151 : {

  00000		 |$LN5@CExternalH@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38988|
  00004	e1a02000	 mov         r2, r0
  00008	e59f300c	 ldr         r3, [pc, #0xC]

; 3152 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: +CExternalHub::~CExternalHub\n"),GetControllerName()) );
; 3153 :     // Nothing to do here yet...
; 3154 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: -CExternalHub::~CExternalHub\n"),GetControllerName()) );
; 3155 : }

  0000c	e5823000	 str         r3, [r2]
  00010	eb000000	 bl          |??1CHub@@UAA@XZ|
  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$LN6@CExternalH@2|
  0001c		 |$LN7@CExternalH@2|
  0001c	00000000	 DCD         |??_7CExternalHub@@6B@|
  00020		 |$M38989|

			 ENDP  ; |??1CExternalHub@@UAA@XZ|, CExternalHub::~CExternalHub

	EXPORT	|??0CFunction@@QAA@EABU_USB_DEVICE_INFO@@HHEQAVCHcd@@QAVCHub@@E@Z| ; CFunction::CFunction
	EXPORT	|??_7CFunction@@6B@| [ DATA ]		; CFunction::`vftable'
	EXPORT	|?EnterOperationalState@CFunction@@UAAHQAVCPipeAbs@@@Z| ; CFunction::EnterOperationalState
	EXPORT	|?ResetPipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@II@Z| ; CFunction::ResetPipe
	IMPORT	|??_ECFunction@@UAAPAXI@Z|, WEAK |??_GCFunction@@UAAPAXI@Z| ; CFunction::`vector deleting destructor', CFunction::`scalar deleting destructor'

  00000			 AREA	 |.pdata|, PDATA
|$T39007| DCD	|$LN5@CFunction|
	DCD	0x40001902

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7CFunction@@6B@| DCD |??_ECFunction@@UAAPAXI@Z|	; CFunction::`vftable'
	DCD	|?EnterOperationalState@CFunction@@UAAHQAVCPipeAbs@@@Z|
	DCD	|?OpenPipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IQBU_USB_ENDPOINT_DESCRIPTOR@@QAI@Z|
	DCD	|?ClosePipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|
	DCD	|?IssueTransfer@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z|
	DCD	|?AbortTransfer@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXQBX@Z|
	DCD	|?IsPipeHalted@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQAH@Z|
	DCD	|?ResetPipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|
	DCD	|?DisableDevice@CDevice@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|
	DCD	|?SuspendResume@CDevice@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|
	DCD	|?ResumeNotification@CDevice@@UAAHXZ|
	DCD	|?NotifyOnSuspendedResumed@CFunction@@UAAHH@Z|
	DCD	|?HandleDetach@CFunction@@EAAXXZ|
	DCD	|?GetUSB2TT@CDevice@@UAAPAVCHub@@AAE0AAH@Z|
	DCD	|?SignalHub@CDevice@@UAAXXZ|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CFunction@@QAA@EABU_USB_DEVICE_INFO@@HHEQAVCHcd@@QAVCHub@@E@Z| PROC ; CFunction::CFunction

; 3841 : {

  00000		 |$LN5@CFunction|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M39004|
  00008	e1a08000	 mov         r8, r0
  0000c	e5dd503c	 ldrb        r5, [sp, #0x3C]
  00010	e59d6038	 ldr         r6, [sp, #0x38]
  00014	e59d7034	 ldr         r7, [sp, #0x34]
  00018	e5dde030	 ldrb        lr, [sp, #0x30]
  0001c	e59d402c	 ldr         r4, [sp, #0x2C]
  00020	e58d5010	 str         r5, [sp, #0x10]
  00024	e58d600c	 str         r6, [sp, #0xC]
  00028	e58d7008	 str         r7, [sp, #8]
  0002c	e58de004	 str         lr, [sp, #4]
  00030	e58d4000	 str         r4, [sp]
  00034	eb000000	 bl          |??0CDevice@@QAA@EABU_USB_DEVICE_INFO@@HHEQAVCDeviceGlobal@@QAVCHub@@E@Z|
  00038	e59f3020	 ldr         r3, [pc, #0x20]
  0003c	e3a02000	 mov         r2, #0
  00040	e5882060	 str         r2, [r8, #0x60]
  00044	e5883000	 str         r3, [r8]
  00048	e5882064	 str         r2, [r8, #0x64]
  0004c	e5887068	 str         r7, [r8, #0x68]

; 3842 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("%s: +CFunction(tier %d)::CFunction\n"),GetControllerName(), tierNumber) );
; 3843 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("%s: -CFunction(tier %d)::CFunction\n"),GetControllerName(), tierNumber) );
; 3844 : }

  00050	e1a00008	 mov         r0, r8
  00054	e28dd014	 add         sp, sp, #0x14
  00058	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$LN6@CFunction|
  00060		 |$LN7@CFunction|
  00060	00000000	 DCD         |??_7CFunction@@6B@|
  00064		 |$M39005|

			 ENDP  ; |??0CFunction@@QAA@EABU_USB_DEVICE_INFO@@HHEQAVCHcd@@QAVCHub@@E@Z|, CFunction::CFunction

	EXPORT	|??1CFunction@@UAA@XZ|			; CFunction::~CFunction

  00000			 AREA	 |.pdata|, PDATA
|$T39017| DCD	|$LN5@CFunction@2|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CFunction@@UAA@XZ| PROC		; CFunction::~CFunction

; 3859 : {

  00000		 |$LN5@CFunction@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M39014|
  00004	e1a02000	 mov         r2, r0
  00008	e59f300c	 ldr         r3, [pc, #0xC]

; 3860 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("%s: +CFunction(tier %d)::~CFunction\n"),GetControllerName(), m_tierNumber) );
; 3861 : 
; 3862 :     DEBUGCHK( m_lpvDetachId == NULL );
; 3863 : 
; 3864 :     // rest of processing done in base destructors...
; 3865 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("%s: -CFunction(tier %d)::~CFunction\n"),GetControllerName(), m_tierNumber) );
; 3866 : }

  0000c	e5823000	 str         r3, [r2]
  00010	eb000000	 bl          |??1CDevice@@UAA@XZ|
  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$LN6@CFunction@2|
  0001c		 |$LN7@CFunction@2|
  0001c	00000000	 DCD         |??_7CFunction@@6B@|
  00020		 |$M39015|

			 ENDP  ; |??1CFunction@@UAA@XZ|, CFunction::~CFunction

	EXPORT	|??_C@_1EC@ILBLKPKJ@?$AAU?$AAS?$AAB?$AAD?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AAP?$AAr?$AAo?$AAc?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAa?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CE@KLMPEJIO@?$AAm?$AA_?$AAd?$AAe?$AAv?$AAi?$AAc?$AAe?$AAI?$AAn?$AAf?$AAo?$AA?5?$AA?$DN?$AA?$DO?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CC@DFLIAIAA@?$AAd?$AAw?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DC@BCNGPCJI@?$AAU?$AAS?$AAB?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAD?$AAE?$AAS?$AAC?$AAR?$AAI?$AAP?$AAT?$AAO?$AAR?$AA?3?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CC@NCKMOJH@?$AAb?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DC@DEHNMMLJ@?$AAb?$AAD?$AAe?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AAo?$AAr?$AAT?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CA@DGABLCAF@?$AAb?$AAc?$AAd?$AAU?$AAS?$AAB?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CM@HDJIFDFM@?$AAb?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DC@FKLDIJED@?$AAb?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAS?$AAu?$AAb?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DC@CABHEAEA@?$AAb?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAP?$AAr?$AAo?$AAt?$AAo?$AAc?$AAo?$AAl?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DC@DPMLGMIH@?$AAb?$AAM?$AAa?$AAx?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AAS?$AAi?$AAz?$AAe?$AA0?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CE@MNGHCBFG@?$AAi?$AAd?$AAV?$AAe?$AAn?$AAd?$AAo?$AAr?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CG@KOCAHDAM@?$AAi?$AAd?$AAP?$AAr?$AAo?$AAd?$AAu?$AAc?$AAt?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CG@KJNNFNMN@?$AAb?$AAc?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CO@OAEHEGJL@?$AAi?$AAM?$AAa?$AAn?$AAu?$AAf?$AAa?$AAc?$AAt?$AAu?$AAr?$AAe?$AAr?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CE@LAEKEHNO@?$AAi?$AAP?$AAr?$AAo?$AAd?$AAu?$AAc?$AAt?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CO@HLPIHMEI@?$AAi?$AAS?$AAe?$AAr?$AAi?$AAa?$AAl?$AAN?$AAu?$AAm?$AAb?$AAe?$AAr?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DI@JNOOEBFJ@?$AAb?$AAN?$AAu?$AAm?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AAs?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GE@OKHKLFOB@?$AAS?$AAE?$AAT?$AA?5?$AAF?$AAE?$AAA?$AAT?$AAU?$AAR?$AAE?$AA?5?$AAU?$AAS?$AAB?$AA_?$AAF?$AAE?$AAA?$AAT?$AAU?$AAR?$AAE?$AA_?$AAB?$AA_?$AAH?$AAN?$AAP?$AA_?$AAE?$AAN@| [ DATA ] ; `string'
	IMPORT	|?BusChildIoControl@CHcd@@QAAHKPAXK@Z|	; CHcd::BusChildIoControl
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T39080| DCD	|$LN53@EnterOpera|
	DCD	0x40009702

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EC@ILBLKPKJ@?$AAU?$AAS?$AAB?$AAD?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AAP?$AAr?$AAo?$AAc?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAa?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6@| DCB "U"
	DCB	0x0, "S", 0x0, "B", 0x0, "D", 0x0, "A", 0x0, "t", 0x0, "t"
	DCB	0x0, "a", 0x0, "c", 0x0, "h", 0x0, "P", 0x0, "r", 0x0, "o"
	DCB	0x0, "c", 0x0, " ", 0x0, "w", 0x0, "i", 0x0, "t", 0x0, "h"
	DCB	0x0, " ", 0x0, "a", 0x0, "d", 0x0, "d", 0x0, "r", 0x0, "e"
	DCB	0x0, "s", 0x0, "s", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CE@KLMPEJIO@?$AAm?$AA_?$AAd?$AAe?$AAv?$AAi?$AAc?$AAe?$AAI?$AAn?$AAf?$AAo?$AA?5?$AA?$DN?$AA?$DO?$AA?$AN?$AA?6?$AA?$AA@| DCB "m"
	DCB	0x0, "_", 0x0, "d", 0x0, "e", 0x0, "v", 0x0, "i", 0x0, "c"
	DCB	0x0, "e", 0x0, "I", 0x0, "n", 0x0, "f", 0x0, "o", 0x0, " "
	DCB	0x0, "=", 0x0, ">", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@DFLIAIAA@?$AAd?$AAw?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "d"
	DCB	0x0, "w", 0x0, "C", 0x0, "o", 0x0, "u", 0x0, "n", 0x0, "t"
	DCB	0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%"
	DCB	0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DC@BCNGPCJI@?$AAU?$AAS?$AAB?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAD?$AAE?$AAS?$AAC?$AAR?$AAI?$AAP?$AAT?$AAO?$AAR?$AA?3?$AA?$AN?$AA?6?$AA?$AA@| DCB "U"
	DCB	0x0, "S", 0x0, "B", 0x0, "_", 0x0, "D", 0x0, "E", 0x0, "V"
	DCB	0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_", 0x0, "D", 0x0, "E"
	DCB	0x0, "S", 0x0, "C", 0x0, "R", 0x0, "I", 0x0, "P", 0x0, "T"
	DCB	0x0, "O", 0x0, "R", 0x0, ":", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@NCKMOJH@?$AAb?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "b"
	DCB	0x0, "L", 0x0, "e", 0x0, "n", 0x0, "g", 0x0, "t", 0x0, "h"
	DCB	0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%"
	DCB	0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DC@DEHNMMLJ@?$AAb?$AAD?$AAe?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AAo?$AAr?$AAT?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "b"
	DCB	0x0, "D", 0x0, "e", 0x0, "s", 0x0, "c", 0x0, "r", 0x0, "i"
	DCB	0x0, "p", 0x0, "t", 0x0, "o", 0x0, "r", 0x0, "T", 0x0, "y"
	DCB	0x0, "p", 0x0, "e", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CA@DGABLCAF@?$AAb?$AAc?$AAd?$AAU?$AAS?$AAB?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "b"
	DCB	0x0, "c", 0x0, "d", 0x0, "U", 0x0, "S", 0x0, "B", 0x0, " "
	DCB	0x0, "=", 0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%", 0x0, "x"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CM@HDJIFDFM@?$AAb?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "b"
	DCB	0x0, "D", 0x0, "e", 0x0, "v", 0x0, "i", 0x0, "c", 0x0, "e"
	DCB	0x0, "C", 0x0, "l", 0x0, "a", 0x0, "s", 0x0, "s", 0x0, " "
	DCB	0x0, "=", 0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%", 0x0, "x"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DC@FKLDIJED@?$AAb?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAS?$AAu?$AAb?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "b"
	DCB	0x0, "D", 0x0, "e", 0x0, "v", 0x0, "i", 0x0, "c", 0x0, "e"
	DCB	0x0, "S", 0x0, "u", 0x0, "b", 0x0, "C", 0x0, "l", 0x0, "a"
	DCB	0x0, "s", 0x0, "s", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DC@CABHEAEA@?$AAb?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAP?$AAr?$AAo?$AAt?$AAo?$AAc?$AAo?$AAl?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "b"
	DCB	0x0, "D", 0x0, "e", 0x0, "v", 0x0, "i", 0x0, "c", 0x0, "e"
	DCB	0x0, "P", 0x0, "r", 0x0, "o", 0x0, "t", 0x0, "o", 0x0, "c"
	DCB	0x0, "o", 0x0, "l", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DC@DPMLGMIH@?$AAb?$AAM?$AAa?$AAx?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AAS?$AAi?$AAz?$AAe?$AA0?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "b"
	DCB	0x0, "M", 0x0, "a", 0x0, "x", 0x0, "P", 0x0, "a", 0x0, "c"
	DCB	0x0, "k", 0x0, "e", 0x0, "t", 0x0, "S", 0x0, "i", 0x0, "z"
	DCB	0x0, "e", 0x0, "0", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CE@MNGHCBFG@?$AAi?$AAd?$AAV?$AAe?$AAn?$AAd?$AAo?$AAr?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "i"
	DCB	0x0, "d", 0x0, "V", 0x0, "e", 0x0, "n", 0x0, "d", 0x0, "o"
	DCB	0x0, "r", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CG@KOCAHDAM@?$AAi?$AAd?$AAP?$AAr?$AAo?$AAd?$AAu?$AAc?$AAt?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "i"
	DCB	0x0, "d", 0x0, "P", 0x0, "r", 0x0, "o", 0x0, "d", 0x0, "u"
	DCB	0x0, "c", 0x0, "t", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CG@KJNNFNMN@?$AAb?$AAc?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "b"
	DCB	0x0, "c", 0x0, "d", 0x0, "D", 0x0, "e", 0x0, "v", 0x0, "i"
	DCB	0x0, "c", 0x0, "e", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CO@OAEHEGJL@?$AAi?$AAM?$AAa?$AAn?$AAu?$AAf?$AAa?$AAc?$AAt?$AAu?$AAr?$AAe?$AAr?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "i"
	DCB	0x0, "M", 0x0, "a", 0x0, "n", 0x0, "u", 0x0, "f", 0x0, "a"
	DCB	0x0, "c", 0x0, "t", 0x0, "u", 0x0, "r", 0x0, "e", 0x0, "r"
	DCB	0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%"
	DCB	0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CE@LAEKEHNO@?$AAi?$AAP?$AAr?$AAo?$AAd?$AAu?$AAc?$AAt?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "i"
	DCB	0x0, "P", 0x0, "r", 0x0, "o", 0x0, "d", 0x0, "u", 0x0, "c"
	DCB	0x0, "t", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CO@HLPIHMEI@?$AAi?$AAS?$AAe?$AAr?$AAi?$AAa?$AAl?$AAN?$AAu?$AAm?$AAb?$AAe?$AAr?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "i"
	DCB	0x0, "S", 0x0, "e", 0x0, "r", 0x0, "i", 0x0, "a", 0x0, "l"
	DCB	0x0, "N", 0x0, "u", 0x0, "m", 0x0, "b", 0x0, "e", 0x0, "r"
	DCB	0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%"
	DCB	0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DI@JNOOEBFJ@?$AAb?$AAN?$AAu?$AAm?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AAs?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "b"
	DCB	0x0, "N", 0x0, "u", 0x0, "m", 0x0, "C", 0x0, "o", 0x0, "n"
	DCB	0x0, "f", 0x0, "i", 0x0, "g", 0x0, "u", 0x0, "r", 0x0, "a"
	DCB	0x0, "t", 0x0, "i", 0x0, "o", 0x0, "n", 0x0, "s", 0x0, " "
	DCB	0x0, "=", 0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%", 0x0, "x"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GE@OKHKLFOB@?$AAS?$AAE?$AAT?$AA?5?$AAF?$AAE?$AAA?$AAT?$AAU?$AAR?$AAE?$AA?5?$AAU?$AAS?$AAB?$AA_?$AAF?$AAE?$AAA?$AAT?$AAU?$AAR?$AAE?$AA_?$AAB?$AA_?$AAH?$AAN?$AAP?$AA_?$AAE?$AAN@| DCB "S"
	DCB	0x0, "E", 0x0, "T", 0x0, " ", 0x0, "F", 0x0, "E", 0x0, "A"
	DCB	0x0, "T", 0x0, "U", 0x0, "R", 0x0, "E", 0x0, " ", 0x0, "U"
	DCB	0x0, "S", 0x0, "B", 0x0, "_", 0x0, "F", 0x0, "E", 0x0, "A"
	DCB	0x0, "T", 0x0, "U", 0x0, "R", 0x0, "E", 0x0, "_", 0x0, "B"
	DCB	0x0, "_", 0x0, "H", 0x0, "N", 0x0, "P", 0x0, "_", 0x0, "E"
	DCB	0x0, "N", 0x0, "A", 0x0, "B", 0x0, "L", 0x0, "E", 0x0, " "
	DCB	0x0, "i", 0x0, "s", 0x0, " ", 0x0, "F", 0x0, "a", 0x0, "i"
	DCB	0x0, "l", 0x0, "e", 0x0, "d", 0x0, " ", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?EnterOperationalState@CFunction@@UAAHQAVCPipeAbs@@@Z| PROC ; CFunction::EnterOperationalState

; 3882 : {

  00000		 |$LN53@EnterOpera|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M39077|
  00008	e1a05001	 mov         r5, r1
  0000c	e1a06000	 mov         r6, r0

; 3883 :     DEBUGMSG( ZONE_FUNCTION, (TEXT("%s: +CFunction(tier %d)::EnterOperationalState\n"),GetControllerName(), m_tierNumber) );
; 3884 : 
; 3885 :     BOOL fSuccess = FALSE;
; 3886 : 
; 3887 :     EnterCriticalSection( &m_csDeviceLock );

  00010	e286000c	 add         r0, r6, #0xC
  00014	e3a04000	 mov         r4, #0
  00018	eb000000	 bl          EnterCriticalSection

; 3888 : 
; 3889 :     DEBUGCHK( m_pCHcd->GetpUSBDAttachProc() != NULL &&
; 3890 :               m_pCHcd->GetpHcdContext() != NULL &&
; 3891 :               m_lpvDetachId == NULL &&  // device not attached yet
; 3892 :               m_ppCPipe == NULL && // not allocated yet
; 3893 :               m_maxNumPipes == 0 && // refers to m_ppCPipe, which is not allocated
; 3894 :               m_address > 0 &&
; 3895 :               m_address <= USB_MAX_ADDRESS &&
; 3896 :               pEndpoint0Pipe != NULL ); // control pipe to endpoint 0
; 3897 : 
; 3898 :     DEBUGCHK(m_hFunctionFeatureEvent == NULL);
; 3899 :     // m_hFunctionFeatureEvent - Auto Reset, and Initial State = non-signaled
; 3900 :     m_hFunctionFeatureEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

  0001c	e3a03000	 mov         r3, #0
  00020	e3a02000	 mov         r2, #0
  00024	e3a01000	 mov         r1, #0
  00028	e3a00000	 mov         r0, #0
  0002c	eb000000	 bl          CreateEventW
  00030	e1a03000	 mov         r3, r0

; 3901 :   
; 3902 :     if ( AllocatePipeArray() ) {

  00034	e1a00006	 mov         r0, r6
  00038	e5863064	 str         r3, [r6, #0x64]
  0003c	eb000000	 bl          |?AllocatePipeArray@CDevice@@IAAHXZ|
  00040	e3500000	 cmp         r0, #0
  00044	0a000063	 beq         |$LN49@EnterOpera|

; 3903 :         m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ] = pEndpoint0Pipe;

  00048	e596205c	 ldr         r2, [r6, #0x5C]

; 3904 :         if (SetOrClearFeature( USB_REQUEST_FOR_DEVICE,0,USB_REQUEST_SET_FEATURE,USB_FEATURE_B_HNP_ENABLE)){

  0004c	e3a0e003	 mov         lr, #3
  00050	e3a03003	 mov         r3, #3
  00054	e5825000	 str         r5, [r2]
  00058	e3a02000	 mov         r2, #0
  0005c	e3a01000	 mov         r1, #0
  00060	e1a00006	 mov         r0, r6
  00064	e58de000	 str         lr, [sp]
  00068	eb000000	 bl          |?SetOrClearFeature@CFunction@@AAAHEGEG@Z|
  0006c	e3500000	 cmp         r0, #0
  00070	0a000008	 beq         |$LN3@EnterOpera|

; 3905 :             BOOL bReturn = SetOrClearFeature( USB_REQUEST_FOR_DEVICE,0,USB_REQUEST_SET_FEATURE,USB_FEATURE_A_HNP_SUPPORT ) ;

  00074	e3a03004	 mov         r3, #4
  00078	e58d3000	 str         r3, [sp]
  0007c	e3a03003	 mov         r3, #3
  00080	e3a02000	 mov         r2, #0
  00084	e3a01000	 mov         r1, #0
  00088	e1a00006	 mov         r0, r6
  0008c	eb000000	 bl          |?SetOrClearFeature@CFunction@@AAAHEGEG@Z|

; 3906 :             DEBUGCHK(bReturn);
; 3907 :             bReturn = m_pCHcd->BusChildIoControl(IOCTL_BUS_USBOTG_HNP_ENABLE,NULL,0);

  00090	e59f11c0	 ldr         r1, [pc, #0x1C0]

; 3908 :             ASSERT(bReturn);        
; 3909 :         }
; 3910 :         else

  00094	ea000002	 b           |$LN50@EnterOpera|
  00098		 |$LN3@EnterOpera|

; 3911 :         {
; 3912 :             RETAILMSG(1,(TEXT("SET FEATURE USB_FEATURE_B_HNP_ENABLE is Failed \r\n")));       

  00098	e59f01b4	 ldr         r0, [pc, #0x1B4]
  0009c	eb000000	 bl          NKDbgPrintfW

; 3913 :             m_pCHcd->BusChildIoControl(IOCTL_BUS_USBOTG_HNP_DISABLE, NULL, 0);

  000a0	e59f11a8	 ldr         r1, [pc, #0x1A8]
  000a4		 |$LN50@EnterOpera|
  000a4	e5960068	 ldr         r0, [r6, #0x68]
  000a8	e3a03000	 mov         r3, #0
  000ac	e3a02000	 mov         r2, #0
  000b0	eb000000	 bl          |?BusChildIoControl@CHcd@@QAAHKPAXK@Z|

; 3914 :         }
; 3915 :         LeaveCriticalSection( &m_csDeviceLock );

  000b4	e286000c	 add         r0, r6, #0xC
  000b8	eb000000	 bl          LeaveCriticalSection

; 3916 : #if 1
; 3917 :         {
; 3918 :             USB_DEVICE_DESCRIPTOR                   Descriptor;            
; 3919 :             LPNON_CONST_USB_CONFIGURATION           lpActiveConfig;
; 3920 : 
; 3921 :             Descriptor = m_deviceInfo.Descriptor;            

  000bc	e28d0004	 add         r0, sp, #4
  000c0	e2861028	 add         r1, r6, #0x28
  000c4	e3a02012	 mov         r2, #0x12
  000c8	eb000000	 bl          memcpy

; 3922 :             lpActiveConfig = m_deviceInfo.lpActiveConfig;
; 3923 :             RETAILMSG(1, (TEXT("USBDAttachProc with address %d\r\n"), m_address));

  000cc	e5d61020	 ldrb        r1, [r6, #0x20]
  000d0	e59f0174	 ldr         r0, [pc, #0x174]
  000d4	eb000000	 bl          NKDbgPrintfW

; 3924 :             RETAILMSG(1, (TEXT("m_deviceInfo =>\r\n")));

  000d8	e59f0168	 ldr         r0, [pc, #0x168]
  000dc	eb000000	 bl          NKDbgPrintfW

; 3925 :             RETAILMSG(1, (TEXT("dwCount = 0x%x\r\n"), m_deviceInfo.dwCount));

  000e0	e5961024	 ldr         r1, [r6, #0x24]
  000e4	e59f0158	 ldr         r0, [pc, #0x158]
  000e8	eb000000	 bl          NKDbgPrintfW

; 3926 :             RETAILMSG(1, (TEXT("USB_DEVICE_DESCRIPTOR:\r\n")));

  000ec	e59f014c	 ldr         r0, [pc, #0x14C]
  000f0	eb000000	 bl          NKDbgPrintfW

; 3927 :             RETAILMSG(1, (TEXT("bLength = 0x%x\r\n"), Descriptor.bLength));

  000f4	e5dd1004	 ldrb        r1, [sp, #4]
  000f8	e59f013c	 ldr         r0, [pc, #0x13C]
  000fc	eb000000	 bl          NKDbgPrintfW

; 3928 :             RETAILMSG(1, (TEXT("bDescriptorType = 0x%x\r\n"), Descriptor.bDescriptorType));

  00100	e5dd1005	 ldrb        r1, [sp, #5]
  00104	e59f012c	 ldr         r0, [pc, #0x12C]
  00108	eb000000	 bl          NKDbgPrintfW

; 3929 :             RETAILMSG(1, (TEXT("bcdUSB = 0x%x\r\n"), Descriptor.bcdUSB));

  0010c	e1dd10b6	 ldrh        r1, [sp, #6]
  00110	e59f011c	 ldr         r0, [pc, #0x11C]
  00114	eb000000	 bl          NKDbgPrintfW

; 3930 :             RETAILMSG(1, (TEXT("bDeviceClass = 0x%x\r\n"), Descriptor.bDeviceClass));

  00118	e5dd1008	 ldrb        r1, [sp, #8]
  0011c	e59f010c	 ldr         r0, [pc, #0x10C]
  00120	eb000000	 bl          NKDbgPrintfW

; 3931 :             RETAILMSG(1, (TEXT("bDeviceSubClass = 0x%x\r\n"), Descriptor.bDeviceSubClass));

  00124	e5dd1009	 ldrb        r1, [sp, #9]
  00128	e59f00fc	 ldr         r0, [pc, #0xFC]
  0012c	eb000000	 bl          NKDbgPrintfW

; 3932 :             RETAILMSG(1, (TEXT("bDeviceProtocol = 0x%x\r\n"), Descriptor.bDeviceProtocol));

  00130	e5dd100a	 ldrb        r1, [sp, #0xA]
  00134	e59f00ec	 ldr         r0, [pc, #0xEC]
  00138	eb000000	 bl          NKDbgPrintfW

; 3933 :             RETAILMSG(1, (TEXT("bMaxPacketSize0 = 0x%x\r\n"), Descriptor.bMaxPacketSize0));

  0013c	e5dd100b	 ldrb        r1, [sp, #0xB]
  00140	e59f00dc	 ldr         r0, [pc, #0xDC]
  00144	eb000000	 bl          NKDbgPrintfW

; 3934 :             RETAILMSG(1, (TEXT("idVendor = 0x%x\r\n"), Descriptor.idVendor));

  00148	e1dd10bc	 ldrh        r1, [sp, #0xC]
  0014c	e59f00cc	 ldr         r0, [pc, #0xCC]
  00150	eb000000	 bl          NKDbgPrintfW

; 3935 :             RETAILMSG(1, (TEXT("idProduct = 0x%x\r\n"), Descriptor.idProduct));

  00154	e1dd10be	 ldrh        r1, [sp, #0xE]
  00158	e59f00bc	 ldr         r0, [pc, #0xBC]
  0015c	eb000000	 bl          NKDbgPrintfW

; 3936 :             RETAILMSG(1, (TEXT("bcdDevice = 0x%x\r\n"), Descriptor.bcdDevice));

  00160	e1dd11b0	 ldrh        r1, [sp, #0x10]
  00164	e59f00ac	 ldr         r0, [pc, #0xAC]
  00168	eb000000	 bl          NKDbgPrintfW

; 3937 :             RETAILMSG(1, (TEXT("iManufacturer = 0x%x\r\n"), Descriptor.iManufacturer));

  0016c	e5dd1012	 ldrb        r1, [sp, #0x12]
  00170	e59f009c	 ldr         r0, [pc, #0x9C]
  00174	eb000000	 bl          NKDbgPrintfW

; 3938 :             RETAILMSG(1, (TEXT("iProduct = 0x%x\r\n"), Descriptor.iProduct));

  00178	e5dd1013	 ldrb        r1, [sp, #0x13]
  0017c	e59f008c	 ldr         r0, [pc, #0x8C]
  00180	eb000000	 bl          NKDbgPrintfW

; 3939 :             RETAILMSG(1, (TEXT("iSerialNumber = 0x%x\r\n"), Descriptor.iSerialNumber));

  00184	e5dd1014	 ldrb        r1, [sp, #0x14]
  00188	e59f007c	 ldr         r0, [pc, #0x7C]
  0018c	eb000000	 bl          NKDbgPrintfW

; 3940 :             RETAILMSG(1, (TEXT("bNumConfigurations = 0x%x\r\n"), Descriptor.bNumConfigurations));

  00190	e5dd1015	 ldrb        r1, [sp, #0x15]
  00194	e59f006c	 ldr         r0, [pc, #0x6C]
  00198	eb000000	 bl          NKDbgPrintfW

; 3941 :           
; 3942 :         }
; 3943 : #endif
; 3944 :         fSuccess = (*m_pCHcd->GetpUSBDAttachProc())(m_pCHcd->GetpHcdContext(), // context for Host Controller Driver
; 3945 :                                         m_address, // used to indicate this specific device
; 3946 :                                         ENDPOINT0_CONTROL_PIPE, // index of endpoint 0 pipe
; 3947 :                                         LPCUSB_DEVICE( &m_deviceInfo ), // USB descriptors
; 3948 :                                         &m_lpvDetachId ); // used to tell USBD this device is being detached

  0019c	e5963068	 ldr         r3, [r6, #0x68]
  001a0	e5d61020	 ldrb        r1, [r6, #0x20]
  001a4	e2865060	 add         r5, r6, #0x60
  001a8	e5930088	 ldr         r0, [r3, #0x88]
  001ac	e593407c	 ldr         r4, [r3, #0x7C]
  001b0	e2863024	 add         r3, r6, #0x24
  001b4	e3a02000	 mov         r2, #0
  001b8	e58d5000	 str         r5, [sp]
  001bc	e1a0e00f	 mov         lr, pc
  001c0	e12fff14	 bx          r4
  001c4	e1a04000	 mov         r4, r0

; 3949 :         DEBUGCHK( !fSuccess || m_lpvDetachId != NULL );
; 3950 :         EnterCriticalSection( &m_csDeviceLock );

  001c8	e286000c	 add         r0, r6, #0xC
  001cc	eb000000	 bl          EnterCriticalSection

; 3951 :     }
; 3952 :     if ( !fSuccess ) {

  001d0	e3540000	 cmp         r4, #0
  001d4	1a000005	 bne         |$LN1@EnterOpera|
  001d8		 |$LN49@EnterOpera|

; 3953 :         DEBUGMSG( ZONE_ERROR, (TEXT("%s: CFunction(tier %d)::EnterOperationalState - failed\n"),GetControllerName(), m_tierNumber) );
; 3954 :         // caller will handle pEndpoint0Pipe
; 3955 :         delete [] m_ppCPipe;

  001d8	e596005c	 ldr         r0, [r6, #0x5C]
  001dc	eb000000	 bl          |??3@YAXPAX@Z|

; 3956 :         m_ppCPipe = NULL;

  001e0	e3a03000	 mov         r3, #0
  001e4	e586305c	 str         r3, [r6, #0x5C]

; 3957 :         m_maxNumPipes = 0;

  001e8	e5c63054	 strb        r3, [r6, #0x54]

; 3958 : 
; 3959 :         m_lpvDetachId = NULL;

  001ec	e5863060	 str         r3, [r6, #0x60]
  001f0		 |$LN1@EnterOpera|

; 3960 :     }
; 3961 :     LeaveCriticalSection( &m_csDeviceLock );

  001f0	e286000c	 add         r0, r6, #0xC
  001f4	eb000000	 bl          LeaveCriticalSection

; 3962 : 
; 3963 :     DEBUGMSG( ZONE_FUNCTION, (TEXT("%s: -CFunction(tier %d)::EnterOperationalState, returning BOOL %d\n"),GetControllerName(), m_tierNumber, fSuccess) );
; 3964 :     return fSuccess;
; 3965 : }

  001f8	e1a00004	 mov         r0, r4
  001fc	e28dd018	 add         sp, sp, #0x18
  00200	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00204	e12fff1e	 bx          lr
  00208		 |$LN54@EnterOpera|
  00208		 |$LN55@EnterOpera|
  00208	00000000	 DCD         |??_C@_1DI@JNOOEBFJ@?$AAb?$AAN?$AAu?$AAm?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AAs?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  0020c		 |$LN56@EnterOpera|
  0020c	00000000	 DCD         |??_C@_1CO@HLPIHMEI@?$AAi?$AAS?$AAe?$AAr?$AAi?$AAa?$AAl?$AAN?$AAu?$AAm?$AAb?$AAe?$AAr?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  00210		 |$LN57@EnterOpera|
  00210	00000000	 DCD         |??_C@_1CE@LAEKEHNO@?$AAi?$AAP?$AAr?$AAo?$AAd?$AAu?$AAc?$AAt?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  00214		 |$LN58@EnterOpera|
  00214	00000000	 DCD         |??_C@_1CO@OAEHEGJL@?$AAi?$AAM?$AAa?$AAn?$AAu?$AAf?$AAa?$AAc?$AAt?$AAu?$AAr?$AAe?$AAr?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  00218		 |$LN59@EnterOpera|
  00218	00000000	 DCD         |??_C@_1CG@KJNNFNMN@?$AAb?$AAc?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  0021c		 |$LN60@EnterOpera|
  0021c	00000000	 DCD         |??_C@_1CG@KOCAHDAM@?$AAi?$AAd?$AAP?$AAr?$AAo?$AAd?$AAu?$AAc?$AAt?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  00220		 |$LN61@EnterOpera|
  00220	00000000	 DCD         |??_C@_1CE@MNGHCBFG@?$AAi?$AAd?$AAV?$AAe?$AAn?$AAd?$AAo?$AAr?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  00224		 |$LN62@EnterOpera|
  00224	00000000	 DCD         |??_C@_1DC@DPMLGMIH@?$AAb?$AAM?$AAa?$AAx?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AAS?$AAi?$AAz?$AAe?$AA0?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  00228		 |$LN63@EnterOpera|
  00228	00000000	 DCD         |??_C@_1DC@CABHEAEA@?$AAb?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAP?$AAr?$AAo?$AAt?$AAo?$AAc?$AAo?$AAl?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  0022c		 |$LN64@EnterOpera|
  0022c	00000000	 DCD         |??_C@_1DC@FKLDIJED@?$AAb?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAS?$AAu?$AAb?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  00230		 |$LN65@EnterOpera|
  00230	00000000	 DCD         |??_C@_1CM@HDJIFDFM@?$AAb?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  00234		 |$LN66@EnterOpera|
  00234	00000000	 DCD         |??_C@_1CA@DGABLCAF@?$AAb?$AAc?$AAd?$AAU?$AAS?$AAB?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  00238		 |$LN67@EnterOpera|
  00238	00000000	 DCD         |??_C@_1DC@DEHNMMLJ@?$AAb?$AAD?$AAe?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AAo?$AAr?$AAT?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  0023c		 |$LN68@EnterOpera|
  0023c	00000000	 DCD         |??_C@_1CC@NCKMOJH@?$AAb?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  00240		 |$LN69@EnterOpera|
  00240	00000000	 DCD         |??_C@_1DC@BCNGPCJI@?$AAU?$AAS?$AAB?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAD?$AAE?$AAS?$AAC?$AAR?$AAI?$AAP?$AAT?$AAO?$AAR?$AA?3?$AA?$AN?$AA?6?$AA?$AA@|
  00244		 |$LN70@EnterOpera|
  00244	00000000	 DCD         |??_C@_1CC@DFLIAIAA@?$AAd?$AAw?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  00248		 |$LN71@EnterOpera|
  00248	00000000	 DCD         |??_C@_1CE@KLMPEJIO@?$AAm?$AA_?$AAd?$AAe?$AAv?$AAi?$AAc?$AAe?$AAI?$AAn?$AAf?$AAo?$AA?5?$AA?$DN?$AA?$DO?$AA?$AN?$AA?6?$AA?$AA@|
  0024c		 |$LN72@EnterOpera|
  0024c	00000000	 DCD         |??_C@_1EC@ILBLKPKJ@?$AAU?$AAS?$AAB?$AAD?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AAP?$AAr?$AAo?$AAc?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAa?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6@|
  00250		 |$LN73@EnterOpera|
  00250	002a0418	 DCD         0x2a0418
  00254		 |$LN74@EnterOpera|
  00254	00000000	 DCD         |??_C@_1GE@OKHKLFOB@?$AAS?$AAE?$AAT?$AA?5?$AAF?$AAE?$AAA?$AAT?$AAU?$AAR?$AAE?$AA?5?$AAU?$AAS?$AAB?$AA_?$AAF?$AAE?$AAA?$AAT?$AAU?$AAR?$AAE?$AA_?$AAB?$AA_?$AAH?$AAN?$AAP?$AA_?$AAE?$AAN@|
  00258		 |$LN75@EnterOpera|
  00258	002a0414	 DCD         0x2a0414
  0025c		 |$M39078|

			 ENDP  ; |?EnterOperationalState@CFunction@@UAAHQAVCPipeAbs@@@Z|, CFunction::EnterOperationalState

	EXPORT	|??_C@_1KO@DBPBLAEA@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAR?$AAe?$AAs?$AAe?$AAt?$AAP?$AAi?$AAp@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T39117| DCD	|$LN13@ResetPipe@2|
	DCD	0x40003c02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1KO@DBPBLAEA@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAR?$AAe?$AAs?$AAe?$AAt?$AAP?$AAi?$AAp@| DCB "!"
	DCB	0x0, "!", 0x0, "!", 0x0, "C", 0x0, "F", 0x0, "u", 0x0, "n"
	DCB	0x0, "c", 0x0, "t", 0x0, "i", 0x0, "o", 0x0, "n", 0x0, "("
	DCB	0x0, " ", 0x0, "t", 0x0, "i", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, ")", 0x0, ":", 0x0, ":", 0x0, "R"
	DCB	0x0, "e", 0x0, "s", 0x0, "e", 0x0, "t", 0x0, "P", 0x0, "i"
	DCB	0x0, "p", 0x0, "e", 0x0, " ", 0x0, "o", 0x0, "n", 0x0, " "
	DCB	0x0, "s", 0x0, "u", 0x0, "s", 0x0, "p", 0x0, "e", 0x0, "n"
	DCB	0x0, "d", 0x0, " ", 0x0, "s", 0x0, "t", 0x0, "a", 0x0, "t"
	DCB	0x0, "e", 0x0, " ", 0x0, "i", 0x0, "s", 0x0, " ", 0x0, "i"
	DCB	0x0, "l", 0x0, "l", 0x0, "g", 0x0, "l", 0x0, "e", 0x0, ","
	DCB	0x0, " ", 0x0, "a", 0x0, "d", 0x0, "d", 0x0, "r", 0x0, "e"
	DCB	0x0, "s", 0x0, "s", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "%"
	DCB	0x0, "d", 0x0, ",", 0x0, " ", 0x0, "p", 0x0, "i", 0x0, "p"
	DCB	0x0, "e", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "%", 0x0, "d"
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResetPipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@II@Z| PROC ; CFunction::ResetPipe

; 4372 : {

  00000		 |$LN13@ResetPipe@2|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M39114|
  00008	e1b06002	 movs        r6, r2
  0000c	e1a07001	 mov         r7, r1
  00010	e1a04000	 mov         r4, r0

; 4373 :     // Some [broken] devices panic if you try to clear the HALT feature on EP0.
; 4374 :     // Since it's an unnecessary operation in any case, we'll translate it to a NOP.
; 4375 :     if (pipeIndex == 0)
; 4376 :         return requestOK;

  00014	03a05001	 moveq       r5, #1
  00018	0a00002f	 beq         |$LN5@ResetPipe@2|

; 4377 : 
; 4378 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("%s: +CFunction(tier %d)::ResetPipe - address = %d, pipe = %d\n"),GetControllerName(), m_tierNumber, address, pipeIndex) );
; 4379 : 
; 4380 :     HCD_REQUEST_STATUS status = requestIgnored;
; 4381 : 
; 4382 :     // don't have to enter critical section until after checking
; 4383 :     // m_address (since m_address is const). That ensures we
; 4384 :     // won't wait for the critical section unless we actually
; 4385 :     // have something to do
; 4386 :     if ( address == m_address ) {

  0001c	e5d43020	 ldrb        r3, [r4, #0x20]
  00020	e3a05002	 mov         r5, #2
  00024	e1570003	 cmp         r7, r3
  00028	1a00002b	 bne         |$LN5@ResetPipe@2|

; 4387 :         status = requestFailed;
; 4388 :         EnterCriticalSection( &m_csDeviceLock );

  0002c	e284000c	 add         r0, r4, #0xC
  00030	e3a05000	 mov         r5, #0
  00034	eb000000	 bl          EnterCriticalSection

; 4389 :         if (m_fIsSuspend ) {

  00038	e5943058	 ldr         r3, [r4, #0x58]
  0003c	e3530000	 cmp         r3, #0
  00040	0a000005	 beq         |$LN4@ResetPipe@2|

; 4390 :             RETAILMSG(1,(TEXT("!!!CFunction( tier %d)::ResetPipe on suspend state is illgle, address = %d, pipe = %d\n"), m_tierNumber, address, pipeIndex));

  00044	e5d4104c	 ldrb        r1, [r4, #0x4C]
  00048	e59f009c	 ldr         r0, [pc, #0x9C]
  0004c	e1a03006	 mov         r3, r6
  00050	e1a02007	 mov         r2, r7
  00054	eb000000	 bl          NKDbgPrintfW

; 4391 :             ASSERT(FALSE);
; 4392 :         }
; 4393 :         else

  00058	ea00001d	 b           |$LN1@ResetPipe@2|
  0005c		 |$LN4@ResetPipe@2|

; 4394 :         if ( pipeIndex < m_maxNumPipes && m_ppCPipe[ pipeIndex ] != NULL ) {

  0005c	e5d43054	 ldrb        r3, [r4, #0x54]
  00060	e1560003	 cmp         r6, r3
  00064	2a00001a	 bcs         |$LN1@ResetPipe@2|
  00068	e594305c	 ldr         r3, [r4, #0x5C]
  0006c	e7933106	 ldr         r3, [r3, +r6, lsl #2]
  00070	e3530000	 cmp         r3, #0
  00074	0a000016	 beq         |$LN1@ResetPipe@2|

; 4395 :             m_ppCPipe[ pipeIndex ]->ResetEndPoint();

  00078	e594305c	 ldr         r3, [r4, #0x5C]
  0007c	e7930106	 ldr         r0, [r3, +r6, lsl #2]
  00080	e5903000	 ldr         r3, [r0]
  00084	e593301c	 ldr         r3, [r3, #0x1C]
  00088	e1a0e00f	 mov         lr, pc
  0008c	e12fff13	 bx          r3

; 4396 :             m_ppCPipe[ pipeIndex ]->ClearHaltedFlag();

  00090	e594305c	 ldr         r3, [r4, #0x5C]
  00094	e7930106	 ldr         r0, [r3, +r6, lsl #2]
  00098	e5903000	 ldr         r3, [r0]
  0009c	e5933018	 ldr         r3, [r3, #0x18]
  000a0	e1a0e00f	 mov         lr, pc
  000a4	e12fff13	 bx          r3

; 4397 : 
; 4398 :             if(SetOrClearFeature( USB_ENDPOINT_RECIPIENT,
; 4399 :                                   m_ppCPipe[ pipeIndex ]->m_bEndpointAddress,
; 4400 :                                   USB_REQUEST_CLEAR_FEATURE,
; 4401 :                                   USB_FEATURE_ENDPOINT_HALT ))

  000a8	e594205c	 ldr         r2, [r4, #0x5C]
  000ac	e3a0e000	 mov         lr, #0
  000b0	e3a03001	 mov         r3, #1
  000b4	e7922106	 ldr         r2, [r2, +r6, lsl #2]
  000b8	e3a01002	 mov         r1, #2
  000bc	e1a00004	 mov         r0, r4
  000c0	e5d22004	 ldrb        r2, [r2, #4]
  000c4	e58de000	 str         lr, [sp]
  000c8	eb000000	 bl          |?SetOrClearFeature@CFunction@@AAAHEGEG@Z|
  000cc	e3500000	 cmp         r0, #0

; 4402 :                 status = requestOK;

  000d0	13a05001	 movne       r5, #1
  000d4		 |$LN1@ResetPipe@2|

; 4403 :         }
; 4404 :         LeaveCriticalSection( &m_csDeviceLock );

  000d4	e284000c	 add         r0, r4, #0xC
  000d8	eb000000	 bl          LeaveCriticalSection
  000dc		 |$LN5@ResetPipe@2|

; 4405 :     }
; 4406 : 
; 4407 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("%s: -CFunction(tier %d)::ResetPipe - address = %d, pipe = %d, returing HCD_REQUEST_STATUS %d\n"),GetControllerName(), m_tierNumber, address, pipeIndex, status) );
; 4408 :     return status;
; 4409 : }

  000dc	e1a00005	 mov         r0, r5
  000e0	e28dd004	 add         sp, sp, #4
  000e4	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000e8	e12fff1e	 bx          lr
  000ec		 |$LN14@ResetPipe@2|
  000ec		 |$LN15@ResetPipe@2|
  000ec	00000000	 DCD         |??_C@_1KO@DBPBLAEA@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAR?$AAe?$AAs?$AAe?$AAt?$AAP?$AAi?$AAp@|
  000f0		 |$M39115|

			 ENDP  ; |?ResetPipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|, CFunction::ResetPipe


  00000			 AREA	 |.pdata|, PDATA
|$T39130| DCD	|$LN6@scalar|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GCDevice@@UAAPAXI@Z| PROC		; CDevice::`scalar deleting destructor'
  00000		 |$LN6@scalar|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M39127|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          |??1CDevice@@UAA@XZ|
  00010	e3140001	 tst         r4, #1
  00014	11a00005	 movne       r0, r5
  00018	1b000000	 blne        |??3@YAXPAX@Z|
  0001c	e1a00005	 mov         r0, r5
  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M39128|

			 ENDP  ; |??_GCDevice@@UAAPAXI@Z|, CDevice::`scalar deleting destructor'


  00000			 AREA	 |.pdata|, PDATA
|$T39141| DCD	|$LN6@scalar@2|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GCHub@@UAAPAXI@Z| PROC		; CHub::`scalar deleting destructor'
  00000		 |$LN6@scalar@2|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M39138|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          |??1CHub@@UAA@XZ|
  00010	e3140001	 tst         r4, #1
  00014	11a00005	 movne       r0, r5
  00018	1b000000	 blne        |??3@YAXPAX@Z|
  0001c	e1a00005	 mov         r0, r5
  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M39139|

			 ENDP  ; |??_GCHub@@UAAPAXI@Z|, CHub::`scalar deleting destructor'

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?AttachDevice@CHub@@IAAXEHH@Z|		; CHub::AttachDevice
	EXPORT	|??_C@_1II@HDIFDMNL@?$AA?$CB?$AAU?$AAS?$AAB?$AA?5?$AAw?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAa?$AAt?$AAt?$AAa?$AAc?$AAh?$AA?5?$AAh?$AAi?$AAg?$AAh@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HE@DLPCNLDH@?$AA?$CB?$AAC?$AAH?$AAu?$AAb?$AA?3?$AA?3?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAw?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAi?$AAn?$AAv@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HK@HGAGGCPB@?$AAU?$AAS?$AAB?$AA?5?$AAs?$AAp?$AAe?$AAc?$AAi?$AAf?$AAi?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAd?$AAo?$AAe?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAw@| [ DATA ] ; `string'
	IMPORT	|HcdPdd_CheckConfigPower|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|__security_check_cookie|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T39317| DCD	|$LN205@AttachDevi|
	DCD	0xc0035402

  00000			 AREA	 |.xdata|, DATA
|$T39313| DCD	0xffffffd8

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1II@HDIFDMNL@?$AA?$CB?$AAU?$AAS?$AAB?$AA?5?$AAw?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAa?$AAt?$AAt?$AAa?$AAc?$AAh?$AA?5?$AAh?$AAi?$AAg?$AAh@| DCB "!"
	DCB	0x0, "U", 0x0, "S", 0x0, "B", 0x0, " ", 0x0, "w", 0x0, "a"
	DCB	0x0, "r", 0x0, "n", 0x0, "i", 0x0, "n", 0x0, "g", 0x0, ":"
	DCB	0x0, " ", 0x0, "c", 0x0, "a", 0x0, "n", 0x0, "n", 0x0, "o"
	DCB	0x0, "t", 0x0, " ", 0x0, "a", 0x0, "t", 0x0, "t", 0x0, "a"
	DCB	0x0, "c", 0x0, "h", 0x0, " ", 0x0, "h", 0x0, "i", 0x0, "g"
	DCB	0x0, "h", 0x0, "-", 0x0, "p", 0x0, "o", 0x0, "w", 0x0, "e"
	DCB	0x0, "r", 0x0, " ", 0x0, "d", 0x0, "e", 0x0, "v", 0x0, "i"
	DCB	0x0, "c", 0x0, "e", 0x0, " ", 0x0, "t", 0x0, "o", 0x0, " "
	DCB	0x0, "a", 0x0, " ", 0x0, "b", 0x0, "u", 0x0, "s", 0x0, "-"
	DCB	0x0, "p", 0x0, "o", 0x0, "w", 0x0, "e", 0x0, "r", 0x0, "e"
	DCB	0x0, "d", 0x0, " ", 0x0, "h", 0x0, "u", 0x0, "b", 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HE@DLPCNLDH@?$AA?$CB?$AAC?$AAH?$AAu?$AAb?$AA?3?$AA?3?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAw?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAi?$AAn?$AAv@| DCB "!"
	DCB	0x0, "C", 0x0, "H", 0x0, "u", 0x0, "b", 0x0, ":", 0x0, ":"
	DCB	0x0, "A", 0x0, "t", 0x0, "t", 0x0, "a", 0x0, "c", 0x0, "h"
	DCB	0x0, "D", 0x0, "e", 0x0, "v", 0x0, "i", 0x0, "c", 0x0, "e"
	DCB	0x0, " ", 0x0, "w", 0x0, "a", 0x0, "r", 0x0, "n", 0x0, "i"
	DCB	0x0, "n", 0x0, "g", 0x0, ":", 0x0, " ", 0x0, "i", 0x0, "n"
	DCB	0x0, "v", 0x0, "a", 0x0, "l", 0x0, "i", 0x0, "d", 0x0, " "
	DCB	0x0, "p", 0x0, "o", 0x0, "w", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "c", 0x0, "o", 0x0, "n", 0x0, "f", 0x0, "i", 0x0, "g"
	DCB	0x0, "u", 0x0, "r", 0x0, "a", 0x0, "t", 0x0, "i", 0x0, "o"
	DCB	0x0, "n", 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HK@HGAGGCPB@?$AAU?$AAS?$AAB?$AA?5?$AAs?$AAp?$AAe?$AAc?$AAi?$AAf?$AAi?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAd?$AAo?$AAe?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAw@| DCB "U"
	DCB	0x0, "S", 0x0, "B", 0x0, " ", 0x0, "s", 0x0, "p", 0x0, "e"
	DCB	0x0, "c", 0x0, "i", 0x0, "f", 0x0, "i", 0x0, "c", 0x0, "a"
	DCB	0x0, "t", 0x0, "i", 0x0, "o", 0x0, "n", 0x0, " ", 0x0, "d"
	DCB	0x0, "o", 0x0, "e", 0x0, "s", 0x0, " ", 0x0, "n", 0x0, "o"
	DCB	0x0, "t", 0x0, " ", 0x0, "a", 0x0, "l", 0x0, "l", 0x0, "o"
	DCB	0x0, "w", 0x0, " ", 0x0, "m", 0x0, "o", 0x0, "r", 0x0, "e"
	DCB	0x0, " ", 0x0, "t", 0x0, "h", 0x0, "a", 0x0, "n", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, " ", 0x0, "h", 0x0, "u", 0x0, "b"
	DCB	0x0, "s", 0x0, " ", 0x0, "i", 0x0, "n", 0x0, " ", 0x0, "a"
	DCB	0x0, " ", 0x0, "r", 0x0, "o", 0x0, "w", 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T39313|

  00008		 |?AttachDevice@CHub@@IAAXEHH@Z| PROC	; CHub::AttachDevice

; 1387 : {

  00008		 |$LN205@AttachDevi|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd0f0	 sub         sp, sp, #0xF0
  00010		 |$M39314|
  00010	e58d3080	 str         r3, [sp, #0x80]
  00014	e58d2084	 str         r2, [sp, #0x84]
  00018	e5cd1040	 strb        r1, [sp, #0x40]
  0001c	e1a09000	 mov         r9, r0
  00020	e59fed2c	 ldr         lr, [pc, #0xD2C]
  00024	e59ee000	 ldr         lr, [lr]
  00028	e58de0ec	 str         lr, [sp, #0xEC]

; 1388 :     DEBUGMSG( ZONE_ATTACH, (TEXT("%s: +CHub(%s tier %d)::AttachDevice - port = %d, fIsLowSpeed = %d, fIsHighSpeed =%d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, port, fIsLowSpeed, fIsHighSpeed ) );
; 1389 : 
; 1390 :     DEBUGCHK( port > 0 && port <= m_usbHubDescriptor.bNumberOfPorts );
; 1391 : 
; 1392 :     // device related variables
; 1393 :     CDevice*                pNewDevice = NULL;
; 1394 :     UCHAR                   address = 0xff; // illegal address

  0002c	e3a030ff	 mov         r3, #0xFF

; 1395 : 	USB_DEVICE_INFO         deviceInfo = {0};

  00030	e3a06000	 mov         r6, #0
  00034	e3a0201c	 mov         r2, #0x1C
  00038	e3a01000	 mov         r1, #0
  0003c	e28d004c	 add         r0, sp, #0x4C
  00040	e5cd3039	 strb        r3, [sp, #0x39]
  00044	e58d6044	 str         r6, [sp, #0x44]
  00048	eb000000	 bl          memset

; 1396 :     USB_HUB_DESCRIPTOR      usbHubDescriptor = {0};

  0004c	e3a03000	 mov         r3, #0
  00050	e3a02046	 mov         r2, #0x46
  00054	e3a01000	 mov         r1, #0
  00058	e28d00a5	 add         r0, sp, #0xA5
  0005c	e5cd30a4	 strb        r3, [sp, #0xA4]
  00060	eb000000	 bl          memset

; 1397 :     CPipeAbs*               pControlPipe = NULL; // pipe to device's endpoint 0
; 1398 : 
; 1399 :     // setup process related varibles
; 1400 :     BOOL                    fUsingAddr0 = FALSE;
; 1401 :     DEVICE_CONFIG_STATUS    configStatus = DEVICE_CONFIG_STATUS_OPENING_ENDPOINT0_PIPE;
; 1402 :     UCHAR                   configFailures = 0;
; 1403 :     UINT                    currentConfigDescriptorIndex = 0;
; 1404 :     BOOL                    fPipeHalted = FALSE;
; 1405 : 
; 1406 :     deviceInfo.dwCount = sizeof( USB_DEVICE_INFO );
; 1407 :     deviceInfo.lpActiveConfig = NULL;
; 1408 :     deviceInfo.lpConfigs = NULL;
; 1409 : 
; 1410 :     if ( !ReserveAddress( address ) ) {

  00064	e5990050	 ldr         r0, [r9, #0x50]
  00068	e3a0e020	 mov         lr, #0x20
  0006c	e3a02000	 mov         r2, #0
  00070	e3a04000	 mov         r4, #0
  00074	e3a08000	 mov         r8, #0
  00078	e3a05000	 mov         r5, #0
  0007c	e3a07000	 mov         r7, #0
  00080	e3a03000	 mov         r3, #0
  00084	e28d1039	 add         r1, sp, #0x39
  00088	e58de048	 str         lr, [sp, #0x48]
  0008c	e3a0a000	 mov         r10, #0
  00090	e58d5078	 str         r5, [sp, #0x78]
  00094	e3a0b000	 mov         r11, #0
  00098	e5cd7038	 strb        r7, [sp, #0x38]
  0009c	e58d306c	 str         r3, [sp, #0x6C]
  000a0	e58d203c	 str         r2, [sp, #0x3C]
  000a4	e58d4064	 str         r4, [sp, #0x64]
  000a8	e58d8060	 str         r8, [sp, #0x60]
  000ac	eb000000	 bl          |?ReserveAddress@CDeviceGlobal@@QAAHAAE@Z|
  000b0	e3500000	 cmp         r0, #0

; 1411 :         DEBUGMSG( ZONE_WARNING, (TEXT("%s: CHub(%s tier %d)::AttachDevice - all USB addresses are in use!\n"),GetControllerName(), GetDeviceType(), m_tierNumber) );
; 1412 :         // don't do any attach processing
; 1413 :         configStatus = DEVICE_CONFIG_STATUS_DONE;
; 1414 :     }
; 1415 :     while ( configStatus != DEVICE_CONFIG_STATUS_DONE ) {

  000b4	0a00031d	 beq         |$LN157@AttachDevi|
  000b8	e5dd8039	 ldrb        r8, [sp, #0x39]
  000bc		 |$LN170@AttachDevi|
  000bc	e59d0060	 ldr         r0, [sp, #0x60]
  000c0		 |$LN172@AttachDevi|
  000c0	e59d103c	 ldr         r1, [sp, #0x3C]
  000c4	e5dde0a4	 ldrb        lr, [sp, #0xA4]
  000c8	e5dd405d	 ldrb        r4, [sp, #0x5D]
  000cc	e59d2064	 ldr         r2, [sp, #0x64]
  000d0		 |$LL97@AttachDevi|

; 1416 :         if ( m_fHubThreadClosing || fPipeHalted || configFailures > 2 ) {

  000d0	e59930b8	 ldr         r3, [r9, #0xB8]
  000d4	e1b05003	 movs        r5, r3
  000d8	1a000003	 bne         |$LN94@AttachDevi|
  000dc	e3510000	 cmp         r1, #0
  000e0	1a000001	 bne         |$LN94@AttachDevi|
  000e4	e3570002	 cmp         r7, #2
  000e8	9a000000	 bls         |$LN95@AttachDevi|
  000ec		 |$LN94@AttachDevi|

; 1417 :             configStatus = DEVICE_CONFIG_STATUS_FAILED;

  000ec	e3a0b013	 mov         r11, #0x13
  000f0		 |$LN95@AttachDevi|

; 1418 :         }
; 1419 :                
; 1420 :         DEBUGMSG( ZONE_ATTACH, (TEXT("CHub(tier %d)::AttachDevice - status = %s, failures = %d\n"),  m_tierNumber, STATUS_TO_STRING( configStatus ), configFailures ) );        
; 1421 :         switch ( configStatus ) {

  000f0	e35b0013	 cmp         r11, #0x13
  000f4	8a00030a	 bhi         |$LN92@AttachDevi|
  000f8	e1a0308b	 mov         r3, r11, lsl #1
  000fc	e083300f	 add         r3, r3, pc
  00100	e1d330b4	 ldrh        r3, [r3, #4]
  00104	e08ff003	 add         pc, pc, r3
  00108		 |$LN182@AttachDevi|
  00108		 |$LN181@AttachDevi|
  00108		 |$LN183@AttachDevi|
  00108	0024		 DCW         0x24
  0010a		 |$LN184@AttachDevi|
  0010a	0188		 DCW         0x188
  0010c		 |$LN185@AttachDevi|
  0010c	01b8		 DCW         0x1b8
  0010e		 |$LN186@AttachDevi|
  0010e	01ec		 DCW         0x1ec
  00110		 |$LN187@AttachDevi|
  00110	0250		 DCW         0x250
  00112		 |$LN188@AttachDevi|
  00112	03d8		 DCW         0x3d8
  00114		 |$LN189@AttachDevi|
  00114	03fc		 DCW         0x3fc
  00116		 |$LN190@AttachDevi|
  00116	049c		 DCW         0x49c
  00118		 |$LN191@AttachDevi|
  00118	04f0		 DCW         0x4f0
  0011a		 |$LN192@AttachDevi|
  0011a	055c		 DCW         0x55c
  0011c		 |$LN193@AttachDevi|
  0011c	05b8		 DCW         0x5b8
  0011e		 |$LN194@AttachDevi|
  0011e	0698		 DCW         0x698
  00120		 |$LN195@AttachDevi|
  00120	07b0		 DCW         0x7b0
  00122		 |$LN196@AttachDevi|
  00122	093c		 DCW         0x93c
  00124		 |$LN197@AttachDevi|
  00124	093c		 DCW         0x93c
  00126		 |$LN198@AttachDevi|
  00126	09c8		 DCW         0x9c8
  00128		 |$LN199@AttachDevi|
  00128	0a3c		 DCW         0xa3c
  0012a		 |$LN200@AttachDevi|
  0012a	0a90		 DCW         0xa90
  0012c		 |$LN201@AttachDevi|
  0012c	0ab8		 DCW         0xab8
  0012e		 |$LN202@AttachDevi|
  0012e	0ae8		 DCW         0xae8
  00130		 |$LN91@AttachDevi|

; 1422 :         case DEVICE_CONFIG_STATUS_OPENING_ENDPOINT0_PIPE:
; 1423 :         {
; 1424 :             // Create TT if it is neccessary.
; 1425 :             if (m_fIsHighSpeed && !fIsHighSpeed &&  !m_pAddedTT[port-1]) { // Hi-Speed Hub and Low Speed device.

  00130	e5993048	 ldr         r3, [r9, #0x48]
  00134	e3530000	 cmp         r3, #0
  00138	0a000012	 beq         |$LN90@AttachDevi|
  0013c	e59d3080	 ldr         r3, [sp, #0x80]
  00140	e3530000	 cmp         r3, #0
  00144	1a00000f	 bne         |$LN90@AttachDevi|
  00148	e59930b4	 ldr         r3, [r9, #0xB4]
  0014c	e5dd4040	 ldrb        r4, [sp, #0x40]
  00150	e0833104	 add         r3, r3, r4, lsl #2
  00154	e5133004	 ldr         r3, [r3, #-4]
  00158	e3530000	 cmp         r3, #0
  0015c	1a000009	 bne         |$LN90@AttachDevi|

; 1426 :                 m_pAddedTT[port-1] = m_pDeviceGlobal->AddedTt(m_address,port);

  00160	e5990050	 ldr         r0, [r9, #0x50]
  00164	e5d91020	 ldrb        r1, [r9, #0x20]
  00168	e1a02004	 mov         r2, r4
  0016c	e5903000	 ldr         r3, [r0]
  00170	e5933000	 ldr         r3, [r3]
  00174	e1a0e00f	 mov         lr, pc
  00178	e12fff13	 bx          r3
  0017c	e59930b4	 ldr         r3, [r9, #0xB4]
  00180	e0833104	 add         r3, r3, r4, lsl #2
  00184	e5030004	 str         r0, [r3, #-4]
  00188		 |$LN90@AttachDevi|

; 1427 :             }
; 1428 :             DEBUGCHK( pControlPipe == NULL );
; 1429 :             USB_ENDPOINT_DESCRIPTOR usbEndpointZeroDescriptor;
; 1430 :             usbEndpointZeroDescriptor.bDescriptorType = USB_ENDPOINT_DESCRIPTOR_TYPE;
; 1431 :             usbEndpointZeroDescriptor.bEndpointAddress = 0;
; 1432 :             // usbEndpointZeroDescriptor.bInterval = ; <- ignored for control pipes
; 1433 :             usbEndpointZeroDescriptor.bLength = sizeof( USB_ENDPOINT_DESCRIPTOR );
; 1434 :             usbEndpointZeroDescriptor.bmAttributes = USB_ENDPOINT_TYPE_CONTROL;
; 1435 :             usbEndpointZeroDescriptor.wMaxPacketSize = ENDPOINT_ZERO_MIN_MAXPACKET_SIZE;
; 1436 :             UCHAR uTTHubAddr= m_address;
; 1437 :             UCHAR uTTHubPort= port;
; 1438 :             BOOL ttContext = NULL;
; 1439 :             GetUSB2TT(uTTHubAddr,uTTHubPort,ttContext);

  00188	e3a0a005	 mov         r10, #5
  0018c	e5d94020	 ldrb        r4, [r9, #0x20]
  00190	e5cda089	 strb        r10, [sp, #0x89]
  00194	e3a0a000	 mov         r10, #0
  00198	e5cda08a	 strb        r10, [sp, #0x8A]
  0019c	e3a0a007	 mov         r10, #7
  001a0	e5cd4068	 strb        r4, [sp, #0x68]
  001a4	e5dd4040	 ldrb        r4, [sp, #0x40]
  001a8	e5993000	 ldr         r3, [r9]
  001ac	e5cda088	 strb        r10, [sp, #0x88]
  001b0	e3a0a000	 mov         r10, #0
  001b4	e5cda08b	 strb        r10, [sp, #0x8B]
  001b8	e5935034	 ldr         r5, [r3, #0x34]
  001bc	e5cd4069	 strb        r4, [sp, #0x69]
  001c0	e3a0a008	 mov         r10, #8
  001c4	e3a04000	 mov         r4, #0
  001c8	e1cda8bc	 strh        r10, [sp, #0x8C]
  001cc	e28d3098	 add         r3, sp, #0x98
  001d0	e28d2069	 add         r2, sp, #0x69
  001d4	e28d1068	 add         r1, sp, #0x68
  001d8	e1a00009	 mov         r0, r9
  001dc	e58d4098	 str         r4, [sp, #0x98]
  001e0	e1a0e00f	 mov         lr, pc
  001e4	e12fff15	 bx          r5

; 1440 :             pControlPipe = CreateControlPipe( &usbEndpointZeroDescriptor,
; 1441 :                                              fIsLowSpeed, fIsHighSpeed ,0,
; 1442 :                                              uTTHubAddr,uTTHubPort,ttContext,
; 1443 :                                              m_pCHcd);

  001e8	e59d2098	 ldr         r2, [sp, #0x98]
  001ec	e5dd1069	 ldrb        r1, [sp, #0x69]
  001f0	e59930c8	 ldr         r3, [r9, #0xC8]
  001f4	e5dd0068	 ldrb        r0, [sp, #0x68]
  001f8	e58d2008	 str         r2, [sp, #8]
  001fc	e59d2080	 ldr         r2, [sp, #0x80]
  00200	e58d1004	 str         r1, [sp, #4]
  00204	e59d1084	 ldr         r1, [sp, #0x84]
  00208	e58d300c	 str         r3, [sp, #0xC]
  0020c	e58d0000	 str         r0, [sp]
  00210	e3a03000	 mov         r3, #0
  00214	e28d0088	 add         r0, sp, #0x88
  00218	eb000000	 bl          |?CreateControlPipe@@YAPAVCPipeAbs@@QBU_USB_ENDPOINT_DESCRIPTOR@@HHEEEHQAVCHcd@@@Z|
  0021c	e1b0a000	 movs        r10, r0

; 1444 :             if ( pControlPipe && pControlPipe->SetReservedDeviceAddr(address) && pControlPipe->OpenPipe() == requestOK ) {

  00220	0a00000f	 beq         |$LN89@AttachDevi|
  00224	e59a3000	 ldr         r3, [r10]
  00228	e1a01008	 mov         r1, r8
  0022c	e1a0000a	 mov         r0, r10
  00230	e5933024	 ldr         r3, [r3, #0x24]
  00234	e1a0e00f	 mov         lr, pc
  00238	e12fff13	 bx          r3
  0023c	e3500000	 cmp         r0, #0
  00240	0a000007	 beq         |$LN89@AttachDevi|
  00244	e59a3000	 ldr         r3, [r10]
  00248	e1a0000a	 mov         r0, r10
  0024c	e5933004	 ldr         r3, [r3, #4]
  00250	e1a0e00f	 mov         lr, pc
  00254	e12fff13	 bx          r3
  00258	e3500001	 cmp         r0, #1

; 1445 :                     // success
; 1446 :                     configStatus = DEVICE_CONFIG_STATUS_USING_ADDRESS0;
; 1447 :             } else {

  0025c	03a0b001	 moveq       r11, #1
  00260	0affff95	 beq         |$LN170@AttachDevi|
  00264		 |$LN89@AttachDevi|

; 1448 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("%s: CHub(%s tier %d)::AttachDevice - failure on %s step, unable to open control pipe\n"),GetControllerName(), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1449 :                 configFailures++;

  00264	e2873001	 add         r3, r7, #1

; 1450 :                 delete pControlPipe;

  00268	e35a0000	 cmp         r10, #0
  0026c	e20370ff	 and         r7, r3, #0xFF
  00270	159a3000	 ldrne       r3, [r10]
  00274	e5cd7038	 strb        r7, [sp, #0x38]
  00278	13a01001	 movne       r1, #1
  0027c	15933000	 ldrne       r3, [r3]
  00280	11a0000a	 movne       r0, r10
  00284	11a0e00f	 movne       lr, pc
  00288	112fff13	 bxne        r3

; 1451 :                 pControlPipe = NULL;
; 1452 :             }
; 1453 :             break;

  0028c	e3a0a000	 mov         r10, #0
  00290	eaffff89	 b           |$LN170@AttachDevi|
  00294		 |$LN87@AttachDevi|

; 1454 :         }
; 1455 :         case DEVICE_CONFIG_STATUS_USING_ADDRESS0:
; 1456 :         {
; 1457 :             DEBUGCHK( !fUsingAddr0 );
; 1458 :             fUsingAddr0 = TRUE;
; 1459 :             //if (EnterCritSec_Ex( &m_csAddress0Lock, INFINITE ) != CSS_SUCCESS) {
; 1460 :             if (m_pDeviceGlobal->Addr0LockEntry(INFINITE )!= CSS_SUCCESS) {

  00294	e5993050	 ldr         r3, [r9, #0x50]
  00298	e3a05001	 mov         r5, #1
  0029c	e3e01000	 mvn         r1, #0
  002a0	e283002c	 add         r0, r3, #0x2C
  002a4	e58d5078	 str         r5, [sp, #0x78]
  002a8	eb000000	 bl          |?EnterCritSec_Ex@CritSec_Ex@@QAA?AW4e_CritSec_Status@@K@Z|
  002ac	e3500000	 cmp         r0, #0
  002b0	0a000027	 beq         |$LN86@AttachDevi|

; 1461 :                 DEBUGMSG( ZONE_ATTACH, (TEXT("CHub(tier %d)::AttachDevice - shutdown signalled during enumeration\n"),  m_tierNumber) );
; 1462 :                 fUsingAddr0 = FALSE;
; 1463 :                 configStatus = DEVICE_CONFIG_STATUS_FAILED;
; 1464 :             } else

  002b4	e3a05000	 mov         r5, #0
  002b8	e58d5078	 str         r5, [sp, #0x78]
  002bc	e3a0b013	 mov         r11, #0x13
  002c0	eaffff7d	 b           |$LN170@AttachDevi|
  002c4		 |$LN84@AttachDevi|

; 1468 :         }
; 1469 :         case DEVICE_CONFIG_STATUS_RESET_AND_ENABLE_PORT:
; 1470 :         {
; 1471 :             DEBUGCHK( fUsingAddr0 );
; 1472 :             if ( ResetAndEnablePort( port ) ) {

  002c4	e5993000	 ldr         r3, [r9]
  002c8	e5dd1040	 ldrb        r1, [sp, #0x40]
  002cc	e1a00009	 mov         r0, r9
  002d0	e593305c	 ldr         r3, [r3, #0x5C]
  002d4	e1a0e00f	 mov         lr, pc
  002d8	e12fff13	 bx          r3
  002dc	e3500000	 cmp         r0, #0

; 1473 :                 configStatus = DEVICE_CONFIG_STATUS_SCHEDULING_GET_DEVICE_DESCRIPTOR_TEST;
; 1474 :             } else {

  002e0	13a0b003	 movne       r11, #3
  002e4	1affff74	 bne         |$LN170@AttachDevi|
  002e8		 |$LN83@AttachDevi|

; 1475 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("%s: CHub(%s tier %d)::AttachDevice - failure on %s step, unable to reset/enable port\n"),GetControllerName(), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1476 :                 configFailures++;

  002e8	e2873001	 add         r3, r7, #1
  002ec	e20370ff	 and         r7, r3, #0xFF
  002f0	e5cd7038	 strb        r7, [sp, #0x38]

; 1477 :             }
; 1478 :             break;

  002f4	eaffff70	 b           |$LN170@AttachDevi|
  002f8		 |$LN81@AttachDevi|

; 1479 :         }
; 1480 :         case DEVICE_CONFIG_STATUS_SCHEDULING_GET_DEVICE_DESCRIPTOR_TEST: 
; 1481 :         {
; 1482 :             if ( GetDescriptor( pControlPipe,
; 1483 :                                 0,
; 1484 :                                 USB_DEVICE_DESCRIPTOR_TYPE,
; 1485 :                                 0, // descriptor index
; 1486 :                                 ENDPOINT_ZERO_MIN_MAXPACKET_SIZE,
; 1487 :                                 &deviceInfo.Descriptor ) ) {

  002f8	e3a0e008	 mov         lr, #8
  002fc	e28d304c	 add         r3, sp, #0x4C
  00300	e58de004	 str         lr, [sp, #4]
  00304	e3a0e000	 mov         lr, #0
  00308	e58d3008	 str         r3, [sp, #8]
  0030c	e3a03001	 mov         r3, #1
  00310	e3a02000	 mov         r2, #0
  00314	e1a0100a	 mov         r1, r10
  00318	e1a00009	 mov         r0, r9
  0031c	e58de000	 str         lr, [sp]
  00320	eb000000	 bl          |?GetDescriptor@CHub@@IAAHQAVCPipeAbs@@EEEGPAX@Z|
  00324	e3500000	 cmp         r0, #0

; 1488 :                 // success
; 1489 :                 configStatus = DEVICE_CONFIG_STATUS_SCHEDULING_SET_ADDRESS;
; 1490 :             } else {

  00328	13a0b004	 movne       r11, #4
  0032c	1affff62	 bne         |$LN170@AttachDevi|

; 1491 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("%s: CHub(%s tier %d)::AttachDevice - failure on %s step\n"),GetControllerName(), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1492 :                 pControlPipe->IsPipeHalted( &fPipeHalted );

  00330	e59a3000	 ldr         r3, [r10]
  00334	e28d103c	 add         r1, sp, #0x3C
  00338	e1a0000a	 mov         r0, r10
  0033c	e5933014	 ldr         r3, [r3, #0x14]
  00340	e1a0e00f	 mov         lr, pc
  00344	e12fff13	 bx          r3

; 1493 : 
; 1494 :                 configFailures++;

  00348	e2873001	 add         r3, r7, #1
  0034c	e20370ff	 and         r7, r3, #0xFF
  00350	e5cd7038	 strb        r7, [sp, #0x38]
  00354		 |$LN86@AttachDevi|

; 1465 :                 // successfully acquired the Address0Lock
; 1466 :                 configStatus = DEVICE_CONFIG_STATUS_RESET_AND_ENABLE_PORT;
; 1467 :             break;

  00354	e3a0b002	 mov         r11, #2
  00358	eaffff57	 b           |$LN170@AttachDevi|
  0035c		 |$LN78@AttachDevi|

; 1495 :                 configStatus = DEVICE_CONFIG_STATUS_RESET_AND_ENABLE_PORT;                
; 1496 :             }
; 1497 :             break;
; 1498 :         }
; 1499 :         case DEVICE_CONFIG_STATUS_SCHEDULING_SET_ADDRESS:
; 1500 :         {
; 1501 :             DEBUGCHK( fUsingAddr0 &&
; 1502 :                       pControlPipe != NULL &&
; 1503 :                       address > 0 );
; 1504 :             BOOL                fTransferDone = FALSE;
; 1505 :             DWORD               dwBytesTransferred = 0;

  0035c	e3a02000	 mov         r2, #0

; 1506 :             DWORD               dwErrorFlags = USB_NOT_COMPLETE_ERROR;
; 1507 :             HCD_REQUEST_STATUS  status = requestFailed;
; 1508 :             USB_DEVICE_REQUEST  usbRequest;
; 1509 : 
; 1510 :             usbRequest.bmRequestType = USB_REQUEST_HOST_TO_DEVICE | USB_REQUEST_STANDARD | USB_REQUEST_FOR_DEVICE;
; 1511 :             usbRequest.bRequest = USB_REQUEST_SET_ADDRESS;
; 1512 :             usbRequest.wValue = address; // new address
; 1513 :             usbRequest.wIndex = 0;
; 1514 :             usbRequest.wLength = 0;

  00360	e58d2074	 str         r2, [sp, #0x74]
  00364	e3a03000	 mov         r3, #0
  00368	e3a02c01	 mov         r2, #1, 24
  0036c	e58d3070	 str         r3, [sp, #0x70]
  00370	e3823003	 orr         r3, r2, #3
  00374	e3a01000	 mov         r1, #0
  00378	e3a00005	 mov         r0, #5
  0037c	e3a0e000	 mov         lr, #0
  00380	e3a04000	 mov         r4, #0
  00384	e58d307c	 str         r3, [sp, #0x7C]
  00388	e5cd1090	 strb        r1, [sp, #0x90]
  0038c	e5cd0091	 strb        r0, [sp, #0x91]
  00390	e1cde9b4	 strh        lr, [sp, #0x94]
  00394	e1cd49b6	 strh        r4, [sp, #0x96]
  00398	e1cd89b2	 strh        r8, [sp, #0x92]

; 1515 :             // Note - at this point, the device is listening on address 0,
; 1516 :             // so we pass 0, not "address", to the IssueTransfer function
; 1517 :             if ( !m_fHubThreadClosing ) {

  0039c	e3550000	 cmp         r5, #0
  003a0	1a000044	 bne         |$LN74@AttachDevi|

; 1518 :                 status = pControlPipe->IssueTransfer(
; 1519 :                                         0, // device address (addr0)
; 1520 :                                         TransferDoneCallbackSetEvent, // callback func
; 1521 :                                         m_hHubStatusChangeEvent, // callback param
; 1522 :                                         USB_OUT_TRANSFER | USB_SEND_TO_DEVICE, // transfer params
; 1523 :                                         &usbRequest, // control request
; 1524 :                                         0, // dwStartingFrame (not used)
; 1525 :                                         0, // dwFrames (not used)
; 1526 :                                         NULL, // aLengths (not used)
; 1527 :                                         0, // buffer size
; 1528 :                                         NULL, // buffer
; 1529 :                                         0, // phys addr of buffer (not used)
; 1530 :                                         this, // cancel id
; 1531 :                                         NULL, // adwIsochErrors (not used)
; 1532 :                                         NULL, // adwIsochLengths (not used)
; 1533 :                                         &fTransferDone, // OUT status param
; 1534 :                                         &dwBytesTransferred, // OUT status param
; 1535 :                                         &dwErrorFlags ); // OUT status param

  003a4	e28d407c	 add         r4, sp, #0x7C
  003a8	e59a1000	 ldr         r1, [r10]
  003ac	e58d4034	 str         r4, [sp, #0x34]
  003b0	e3a04000	 mov         r4, #0
  003b4	e58d4028	 str         r4, [sp, #0x28]
  003b8	e58d4024	 str         r4, [sp, #0x24]
  003bc	e58d401c	 str         r4, [sp, #0x1C]
  003c0	e58d4018	 str         r4, [sp, #0x18]
  003c4	e58d4014	 str         r4, [sp, #0x14]
  003c8	e58d4010	 str         r4, [sp, #0x10]
  003cc	e58d400c	 str         r4, [sp, #0xC]
  003d0	e58d4008	 str         r4, [sp, #8]
  003d4	e591800c	 ldr         r8, [r1, #0xC]
  003d8	e3a04a01	 mov         r4, #1, 20
  003dc	e59930bc	 ldr         r3, [r9, #0xBC]
  003e0	e59f295c	 ldr         r2, [pc, #0x95C]
  003e4	e28d5074	 add         r5, sp, #0x74
  003e8	e28d6070	 add         r6, sp, #0x70
  003ec	e28d7090	 add         r7, sp, #0x90
  003f0	e58d4000	 str         r4, [sp]
  003f4	e3a01000	 mov         r1, #0
  003f8	e1a0000a	 mov         r0, r10
  003fc	e58d5030	 str         r5, [sp, #0x30]
  00400	e58d602c	 str         r6, [sp, #0x2C]
  00404	e58d9020	 str         r9, [sp, #0x20]
  00408	e58d7004	 str         r7, [sp, #4]
  0040c	e1a0e00f	 mov         lr, pc
  00410	e12fff18	 bx          r8

; 1536 :                 if ( status == requestOK ) {

  00414	e3500001	 cmp         r0, #1
  00418	1a000023	 bne         |$LN165@AttachDevi|

; 1537 :                     WaitForSingleObject( m_hHubStatusChangeEvent, INFINITE );

  0041c	e59900bc	 ldr         r0, [r9, #0xBC]
  00420	e3e01000	 mvn         r1, #0
  00424	eb000000	 bl          WaitForSingleObject

; 1538 :                     if ( m_fHubThreadClosing ) {

  00428	e59930b8	 ldr         r3, [r9, #0xB8]
  0042c	e3530000	 cmp         r3, #0
  00430	0a00000a	 beq         |$LN123@AttachDevi|

; 1539 :                         pControlPipe->AbortTransfer( NULL, // callback function
; 1540 :                                                      NULL, // callback parameter
; 1541 :                                                      this ); // cancel ID

  00434	e59a1000	 ldr         r1, [r10]
  00438	e1a03009	 mov         r3, r9
  0043c	e3a02000	 mov         r2, #0
  00440	e5914010	 ldr         r4, [r1, #0x10]
  00444	e3a01000	 mov         r1, #0
  00448	e1a0000a	 mov         r0, r10
  0044c	e1a0e00f	 mov         lr, pc
  00450	e12fff14	 bx          r4

; 1542 :                         ResetEvent(m_hHubStatusChangeEvent);

  00454	e59900bc	 ldr         r0, [r9, #0xBC]
  00458	e3a01002	 mov         r1, #2
  0045c	eb000000	 bl          EventModify
  00460		 |$LN123@AttachDevi|

; 1543 :                     }
; 1544 :                 }
; 1545 :                 DEBUGCHK( fTransferDone );
; 1546 :             }
; 1547 :             if ( status == requestOK &&
; 1548 :                  fTransferDone &&
; 1549 :                  dwBytesTransferred == 0 &&
; 1550 :                  dwErrorFlags == USB_NO_ERROR ) {

  00460	e59d3070	 ldr         r3, [sp, #0x70]
  00464	e3530000	 cmp         r3, #0
  00468	0a00000f	 beq         |$LN165@AttachDevi|
  0046c	e59d3074	 ldr         r3, [sp, #0x74]
  00470	e3530000	 cmp         r3, #0
  00474	1a00000c	 bne         |$LN165@AttachDevi|
  00478	e59d307c	 ldr         r3, [sp, #0x7C]
  0047c	e3530000	 cmp         r3, #0
  00480	1a000009	 bne         |$LN165@AttachDevi|

; 1551 :                 configStatus = DEVICE_CONFIG_STATUS_LEAVE_ADDRESS0;
; 1552 :             } else {

  00484	e59d2064	 ldr         r2, [sp, #0x64]
  00488	e59d0060	 ldr         r0, [sp, #0x60]
  0048c	e5dd405d	 ldrb        r4, [sp, #0x5D]
  00490	e59d103c	 ldr         r1, [sp, #0x3C]
  00494	e3a0b005	 mov         r11, #5
  00498		 |$LN175@AttachDevi|
  00498	e5dde0a4	 ldrb        lr, [sp, #0xA4]
  0049c		 |$LN167@AttachDevi|
  0049c	e5dd7038	 ldrb        r7, [sp, #0x38]
  004a0	e59d6044	 ldr         r6, [sp, #0x44]
  004a4	e5dd8039	 ldrb        r8, [sp, #0x39]
  004a8	eaffff08	 b           |$LL97@AttachDevi|
  004ac		 |$LN165@AttachDevi|

; 1912 :                 configStatus = DEVICE_CONFIG_STATUS_DONE;
; 1913 :             } else {
; 1914 :                 // don't do any retries here! EnterOperationalState
; 1915 :                 // should only be tried once
; 1916 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("%s: CHub(%s tier %d)::AttachDevice - failure on %s step, aborting attach process\n"),GetControllerName(), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1917 :                 configStatus = DEVICE_CONFIG_STATUS_FAILED;
; 1918 :                 configFailures = 0xff;
; 1919 :             }
; 1920 :             break;

  004ac	e5dd8039	 ldrb        r8, [sp, #0x39]
  004b0	e59d6044	 ldr         r6, [sp, #0x44]
  004b4	e5dd7038	 ldrb        r7, [sp, #0x38]
  004b8		 |$LN74@AttachDevi|
  004b8	e59a3000	 ldr         r3, [r10]
  004bc	e2872001	 add         r2, r7, #1
  004c0	e20270ff	 and         r7, r2, #0xFF
  004c4	e5933014	 ldr         r3, [r3, #0x14]
  004c8	e5cd7038	 strb        r7, [sp, #0x38]
  004cc	e28d103c	 add         r1, sp, #0x3C
  004d0	e1a0000a	 mov         r0, r10
  004d4	e1a0e00f	 mov         lr, pc
  004d8	e12fff13	 bx          r3
  004dc	e3a0b002	 mov         r11, #2
  004e0	eafffef5	 b           |$LN170@AttachDevi|
  004e4		 |$LN72@AttachDevi|

; 1553 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("%s: CHub(%s tier %d)::AttachDevice - failure on %s step, fTransferDone = %d, dwBytesTrans = 0x%x, dwErrorFlags = 0x%x\n"),GetControllerName(), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ), fTransferDone, dwBytesTransferred, dwErrorFlags ) );
; 1554 :                 configFailures++;
; 1555 :                 pControlPipe->IsPipeHalted( &fPipeHalted );
; 1556 :                 configStatus = DEVICE_CONFIG_STATUS_RESET_AND_ENABLE_PORT;
; 1557 :             }
; 1558 :             break;
; 1559 :         }
; 1560 :         case DEVICE_CONFIG_STATUS_LEAVE_ADDRESS0:
; 1561 :         {
; 1562 :             DEBUGCHK( fUsingAddr0 );
; 1563 :             // it can take some time for SetAddress to
; 1564 :             // take effect. In the OHCD code, there is a comment
; 1565 :             // that some devices (i.e. Andromeda hub) need a
; 1566 :             // delay here
; 1567 :             Sleep( 10 );

  004e4	e3a0000a	 mov         r0, #0xA
  004e8	eb000000	 bl          Sleep

; 1568 :             //LeaveCritSec_Ex( &m_csAddress0Lock );
; 1569 :             m_pDeviceGlobal->Addr0LockLeave();

  004ec	e5993050	 ldr         r3, [r9, #0x50]
  004f0	e283002c	 add         r0, r3, #0x2C
  004f4	eb000000	 bl          |?LeaveCritSec_Ex@CritSec_Ex@@QAAXXZ|

; 1570 :             fUsingAddr0 = FALSE;
; 1571 :             configStatus = DEVICE_CONFIG_STATUS_SCHEDULING_GET_INITIAL_DEVICE_DESCRIPTOR;
; 1572 :             break;

  004f8	e3a05000	 mov         r5, #0
  004fc	e58d5078	 str         r5, [sp, #0x78]
  00500	e3a0b006	 mov         r11, #6
  00504	eafffeec	 b           |$LN170@AttachDevi|
  00508		 |$LN71@AttachDevi|

; 1573 :         }
; 1574 :         case DEVICE_CONFIG_STATUS_SCHEDULING_GET_INITIAL_DEVICE_DESCRIPTOR:
; 1575 :         {
; 1576 :             if ( GetDescriptor( pControlPipe,
; 1577 :                                 address,
; 1578 :                                 USB_DEVICE_DESCRIPTOR_TYPE,
; 1579 :                                 0, // descriptor index
; 1580 :                                 ENDPOINT_ZERO_MIN_MAXPACKET_SIZE,
; 1581 :                                 &deviceInfo.Descriptor ) ) {

  00508	e3a0e008	 mov         lr, #8
  0050c	e28d304c	 add         r3, sp, #0x4C
  00510	e58de004	 str         lr, [sp, #4]
  00514	e3a0e000	 mov         lr, #0
  00518	e58d3008	 str         r3, [sp, #8]
  0051c	e3a03001	 mov         r3, #1
  00520	e1a02008	 mov         r2, r8
  00524	e1a0100a	 mov         r1, r10
  00528	e1a00009	 mov         r0, r9
  0052c	e58de000	 str         lr, [sp]
  00530	eb000000	 bl          |?GetDescriptor@CHub@@IAAHQAVCPipeAbs@@EEEGPAX@Z|
  00534	e3500000	 cmp         r0, #0
  00538	0a000013	 beq         |$LN70@AttachDevi|

; 1582 : 
; 1583 :                 DEBUGCHK( m_tierNumber <= USB_MAXIMUM_HUB_TIER );
; 1584 :                 if ( m_tierNumber == USB_MAXIMUM_HUB_TIER &&
; 1585 :                      deviceInfo.Descriptor.bDeviceClass == USB_DEVICE_CLASS_HUB ) {

  0053c	e5d9304c	 ldrb        r3, [r9, #0x4C]
  00540	e3530005	 cmp         r3, #5
  00544	1a000007	 bne         |$LN69@AttachDevi|
  00548	e5dd3050	 ldrb        r3, [sp, #0x50]
  0054c	e3530009	 cmp         r3, #9
  00550	1a000004	 bne         |$LN69@AttachDevi|

; 1586 :                     RETAILMSG( 1, (TEXT("USB specification does not allow more than %d hubs in a row\n"), USB_MAXIMUM_HUB_TIER ));

  00554	e59f07f4	 ldr         r0, [pc, #0x7F4]
  00558	e3a01005	 mov         r1, #5
  0055c	eb000000	 bl          NKDbgPrintfW
  00560	e3a0b013	 mov         r11, #0x13
  00564	eafffed4	 b           |$LN170@AttachDevi|
  00568		 |$LN69@AttachDevi|

; 1587 :                     configStatus = DEVICE_CONFIG_STATUS_FAILED;
; 1588 :                 } else {
; 1589 :                     // success
; 1590 :                     if ( deviceInfo.Descriptor.bMaxPacketSize0 > ENDPOINT_ZERO_MIN_MAXPACKET_SIZE ) {

  00568	e5dd1053	 ldrb        r1, [sp, #0x53]
  0056c	e3510008	 cmp         r1, #8

; 1591 :                         pControlPipe->ChangeMaxPacketSize( deviceInfo.Descriptor.bMaxPacketSize0 );

  00570	859a3000	 ldrhi       r3, [r10]
  00574	81a0000a	 movhi       r0, r10
  00578	85933020	 ldrhi       r3, [r3, #0x20]
  0057c	81a0e00f	 movhi       lr, pc
  00580	812fff13	 bxhi        r3

; 1592 :                     }
; 1593 :                     configStatus = DEVICE_CONFIG_STATUS_SCHEDULING_GET_DEVICE_DESCRIPTOR;
; 1594 :                 }
; 1595 :             } else {

  00584	e3a0b007	 mov         r11, #7
  00588	eafffecb	 b           |$LN170@AttachDevi|
  0058c		 |$LN70@AttachDevi|

; 1596 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("%s: CHub(%s tier %d)::AttachDevice - failure on %s step\n"),GetControllerName(), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1597 :                 pControlPipe->IsPipeHalted( &fPipeHalted );

  0058c	e59a3000	 ldr         r3, [r10]
  00590	e28d103c	 add         r1, sp, #0x3C
  00594	e1a0000a	 mov         r0, r10
  00598	e5933014	 ldr         r3, [r3, #0x14]
  0059c	e1a0e00f	 mov         lr, pc
  005a0	e12fff13	 bx          r3

; 1598 :                 configFailures++;
; 1599 :             }
; 1600 :             break;

  005a4	eaffff4f	 b           |$LN83@AttachDevi|
  005a8		 |$LN65@AttachDevi|

; 1601 :         }
; 1602 :         case DEVICE_CONFIG_STATUS_SCHEDULING_GET_DEVICE_DESCRIPTOR:
; 1603 :         {
; 1604 :             if ( GetDescriptor( pControlPipe,
; 1605 :                                 address,
; 1606 :                                 USB_DEVICE_DESCRIPTOR_TYPE,
; 1607 :                                 0, // descriptor index
; 1608 :                                 sizeof( deviceInfo.Descriptor ),
; 1609 :                                 &deviceInfo.Descriptor ) ) {

  005a8	e28d304c	 add         r3, sp, #0x4C
  005ac	e3a02012	 mov         r2, #0x12
  005b0	e58d3008	 str         r3, [sp, #8]
  005b4	e58d2004	 str         r2, [sp, #4]
  005b8	e3a0e000	 mov         lr, #0
  005bc	e3a03001	 mov         r3, #1
  005c0	e1a02008	 mov         r2, r8
  005c4	e1a0100a	 mov         r1, r10
  005c8	e1a00009	 mov         r0, r9
  005cc	e58de000	 str         lr, [sp]
  005d0	eb000000	 bl          |?GetDescriptor@CHub@@IAAHQAVCPipeAbs@@EEEGPAX@Z|
  005d4	e3500000	 cmp         r0, #0

; 1610 :                 // success
; 1611 :                 configStatus = DEVICE_CONFIG_STATUS_SETUP_CONFIGURATION_DESCRIPTOR_ARRAY;
; 1612 :             #ifdef DEBUG
; 1613 :                 DumpDeviceDescriptor( &deviceInfo.Descriptor );
; 1614 :             #endif // DEBUG
; 1615 :             } else {

  005d8	13a0b008	 movne       r11, #8
  005dc	1afffeb6	 bne         |$LN170@AttachDevi|

; 1616 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("%s: CHub(%s tier %d)::AttachDevice - failure on %s step\n"),GetControllerName(), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1617 :                 pControlPipe->IsPipeHalted( &fPipeHalted );

  005e0	e59a3000	 ldr         r3, [r10]
  005e4	e28d103c	 add         r1, sp, #0x3C
  005e8	e1a0000a	 mov         r0, r10
  005ec	e5933014	 ldr         r3, [r3, #0x14]
  005f0	e1a0e00f	 mov         lr, pc
  005f4	e12fff13	 bx          r3

; 1618 :                 configFailures++;
; 1619 :             }
; 1620 :             break;

  005f8	eaffff3a	 b           |$LN83@AttachDevi|
  005fc		 |$LN62@AttachDevi|

; 1621 :         }
; 1622 :         case DEVICE_CONFIG_STATUS_SETUP_CONFIGURATION_DESCRIPTOR_ARRAY:
; 1623 :         {
; 1624 :             DEBUGCHK( deviceInfo.lpActiveConfig == NULL &&
; 1625 :                       deviceInfo.lpConfigs == NULL );
; 1626 : 
; 1627 :             const UINT numConfigurations = deviceInfo.Descriptor.bNumConfigurations;
; 1628 :             deviceInfo.lpConfigs = new NON_CONST_USB_CONFIGURATION[ numConfigurations ];

  005fc	e374037e	 cmn         r4, #0x7E, 6
  00600	91a00284	 movls       r0, r4, lsl #5
  00604	83e00000	 mvnhi       r0, #0
  00608	eb000000	 bl          |??2@YAPAXI@Z|
  0060c	e3500000	 cmp         r0, #0
  00610	e58d0060	 str         r0, [sp, #0x60]

; 1629 :             if ( deviceInfo.lpConfigs != NULL ) {

  00614	0a00000f	 beq         |$LN61@AttachDevi|

; 1630 :                 memset( deviceInfo.lpConfigs, 0, numConfigurations * sizeof( NON_CONST_USB_CONFIGURATION ) );

  00618	e1a02284	 mov         r2, r4, lsl #5
  0061c	e3a01000	 mov         r1, #0
  00620	eb000000	 bl          memset

; 1631 :                 for ( UINT config = 0; config < numConfigurations ; config++ ) {

  00624	e3540000	 cmp         r4, #0
  00628	0a000006	 beq         |$LN58@AttachDevi|
  0062c	e3a02000	 mov         r2, #0
  00630	e3a01020	 mov         r1, #0x20
  00634		 |$LL60@AttachDevi|

; 1632 :                     deviceInfo.lpConfigs[ config ].dwCount = sizeof( NON_CONST_USB_CONFIGURATION );

  00634	e59d3060	 ldr         r3, [sp, #0x60]
  00638	e2544001	 subs        r4, r4, #1
  0063c	e7821003	 str         r1, [r2, +r3]
  00640	e2822020	 add         r2, r2, #0x20
  00644	1afffffa	 bne         |$LL60@AttachDevi|
  00648		 |$LN58@AttachDevi|

; 1633 :                 }
; 1634 :                 currentConfigDescriptorIndex = 0;
; 1635 :                 configStatus = DEVICE_CONFIG_STATUS_SCHEDULING_GET_INITIAL_CONFIG_DESCRIPTOR;

  00648	e3a03000	 mov         r3, #0
  0064c	e58d306c	 str         r3, [sp, #0x6C]
  00650	e3a0b009	 mov         r11, #9
  00654	eafffe98	 b           |$LN170@AttachDevi|
  00658		 |$LN61@AttachDevi|

; 1636 :             } else {
; 1637 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("%s: CHub(%s tier %d)::AttachDevice - failure on %s step, no memory\n"),GetControllerName(), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1638 :                 configFailures++;

  00658	e2873001	 add         r3, r7, #1
  0065c	e20370ff	 and         r7, r3, #0xFF
  00660	e5cd7038	 strb        r7, [sp, #0x38]

; 1639 :             }
; 1640 :             break;

  00664	eafffe95	 b           |$LN172@AttachDevi|
  00668		 |$LN56@AttachDevi|

; 1641 :         }
; 1642 :         case DEVICE_CONFIG_STATUS_SCHEDULING_GET_INITIAL_CONFIG_DESCRIPTOR:
; 1643 :         {
; 1644 :             DEBUGCHK( currentConfigDescriptorIndex < deviceInfo.Descriptor.bNumConfigurations );
; 1645 :             DEBUGCHK( deviceInfo.lpActiveConfig == NULL &&
; 1646 :                       deviceInfo.lpConfigs != NULL );
; 1647 : 
; 1648 :             if ( GetDescriptor( pControlPipe,
; 1649 :                                 address,
; 1650 :                                 USB_CONFIGURATION_DESCRIPTOR_TYPE,
; 1651 :                                 (UCHAR)currentConfigDescriptorIndex,
; 1652 :                                 sizeof( deviceInfo.lpConfigs[ currentConfigDescriptorIndex ].Descriptor ),
; 1653 :                                 &deviceInfo.lpConfigs[ currentConfigDescriptorIndex ].Descriptor ) ) {

  00668	e59d206c	 ldr         r2, [sp, #0x6C]
  0066c	e3a04009	 mov         r4, #9
  00670	e1a0100a	 mov         r1, r10
  00674	e0803282	 add         r3, r0, r2, lsl #5
  00678	e2833004	 add         r3, r3, #4
  0067c	e58d3008	 str         r3, [sp, #8]
  00680	e202e0ff	 and         lr, r2, #0xFF
  00684	e3a03002	 mov         r3, #2
  00688	e1a02008	 mov         r2, r8
  0068c	e1a00009	 mov         r0, r9
  00690	e58d4004	 str         r4, [sp, #4]
  00694	e58de000	 str         lr, [sp]
  00698	eb000000	 bl          |?GetDescriptor@CHub@@IAAHQAVCPipeAbs@@EEEGPAX@Z|
  0069c	e3500000	 cmp         r0, #0

; 1654 :                 // success
; 1655 :                 configStatus = DEVICE_CONFIG_STATUS_SCHEDULING_GET_CONFIG_DESCRIPTOR;
; 1656 :             } else {

  006a0	13a0b00a	 movne       r11, #0xA
  006a4	1afffe84	 bne         |$LN170@AttachDevi|

; 1657 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("%s: CHub(%s tier %d)::AttachDevice - failure on %s step\n"),GetControllerName(), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1658 :                 pControlPipe->IsPipeHalted( &fPipeHalted );

  006a8	e59a3000	 ldr         r3, [r10]
  006ac	e28d103c	 add         r1, sp, #0x3C
  006b0	e1a0000a	 mov         r0, r10
  006b4	e5933014	 ldr         r3, [r3, #0x14]
  006b8	e1a0e00f	 mov         lr, pc
  006bc	e12fff13	 bx          r3

; 1659 :                 configFailures++;
; 1660 :             }
; 1661 :             break;

  006c0	eaffff08	 b           |$LN83@AttachDevi|
  006c4		 |$LN53@AttachDevi|

; 1662 :         }
; 1663 :         case DEVICE_CONFIG_STATUS_SCHEDULING_GET_CONFIG_DESCRIPTOR:
; 1664 :         {
; 1665 :             DEBUGCHK( currentConfigDescriptorIndex < deviceInfo.Descriptor.bNumConfigurations );
; 1666 :             DEBUGCHK( deviceInfo.lpActiveConfig == NULL &&
; 1667 :                       deviceInfo.lpConfigs != NULL &&
; 1668 :                       deviceInfo.lpConfigs[ currentConfigDescriptorIndex ].Descriptor.bDescriptorType == USB_CONFIGURATION_DESCRIPTOR_TYPE &&
; 1669 :                       deviceInfo.lpConfigs[ currentConfigDescriptorIndex ].Descriptor.bLength == sizeof( USB_CONFIGURATION_DESCRIPTOR ) &&
; 1670 :                       deviceInfo.lpConfigs[ currentConfigDescriptorIndex ].lpbExtended == NULL &&
; 1671 :                       deviceInfo.lpConfigs[ currentConfigDescriptorIndex ].lpInterfaces == NULL );
; 1672 : 
; 1673 :             const USHORT wTotalLength = deviceInfo.lpConfigs[ currentConfigDescriptorIndex ].Descriptor.wTotalLength;

  006c4	e59d606c	 ldr         r6, [sp, #0x6C]
  006c8	e0803286	 add         r3, r0, r6, lsl #5
  006cc	e5d32006	 ldrb        r2, [r3, #6]
  006d0	e5d33007	 ldrb        r3, [r3, #7]
  006d4	e1825403	 orr         r5, r2, r3, lsl #8

; 1674 :             PUCHAR pDataBuffer = new UCHAR[ wTotalLength ];            

  006d8	e1a00005	 mov         r0, r5
  006dc	eb000000	 bl          |??2@YAPAXI@Z|
  006e0	e1b04000	 movs        r4, r0

; 1675 :             if ( pDataBuffer != NULL &&
; 1676 :                  GetDescriptor( pControlPipe,
; 1677 :                                 address,
; 1678 :                                 USB_CONFIGURATION_DESCRIPTOR_TYPE,
; 1679 :                                 (UCHAR)currentConfigDescriptorIndex,
; 1680 :                                 wTotalLength,
; 1681 :                                 pDataBuffer ) &&
; 1682 :                  memcmp( &deviceInfo.lpConfigs[ currentConfigDescriptorIndex ].Descriptor, pDataBuffer, sizeof( USB_CONFIGURATION_DESCRIPTOR ) ) == 0 &&
; 1683 :                  CreateUsbConfigurationStructure( deviceInfo.lpConfigs[ currentConfigDescriptorIndex ], pDataBuffer, wTotalLength ) ) {

  006e4	0a000022	 beq         |$LN52@AttachDevi|
  006e8	e20620ff	 and         r2, r6, #0xFF
  006ec	e58d2000	 str         r2, [sp]
  006f0	e1a02008	 mov         r2, r8
  006f4	e3a03002	 mov         r3, #2
  006f8	e1a0100a	 mov         r1, r10
  006fc	e1a00009	 mov         r0, r9
  00700	e58d4008	 str         r4, [sp, #8]
  00704	e58d5004	 str         r5, [sp, #4]
  00708	eb000000	 bl          |?GetDescriptor@CHub@@IAAHQAVCPipeAbs@@EEEGPAX@Z|
  0070c	e3500000	 cmp         r0, #0
  00710	0a000017	 beq         |$LN52@AttachDevi|
  00714	e59de060	 ldr         lr, [sp, #0x60]
  00718	e3a02009	 mov         r2, #9
  0071c	e1a01004	 mov         r1, r4
  00720	e08e6286	 add         r6, lr, r6, lsl #5
  00724	e2860004	 add         r0, r6, #4
  00728	eb000000	 bl          memcmp
  0072c	e3500000	 cmp         r0, #0
  00730	1a00000f	 bne         |$LN52@AttachDevi|
  00734	e1a03005	 mov         r3, r5
  00738	e1a02004	 mov         r2, r4
  0073c	e1a01006	 mov         r1, r6
  00740	e1a00009	 mov         r0, r9
  00744	eb000000	 bl          |?CreateUsbConfigurationStructure@CDevice@@QBAHAAU_NON_CONST_USB_CONFIGURATION@@QAEI@Z|
  00748	e3500000	 cmp         r0, #0
  0074c	0a000008	 beq         |$LN52@AttachDevi|

; 1684 :                 // success
; 1685 :                 currentConfigDescriptorIndex++;
; 1686 :                 if ( currentConfigDescriptorIndex < deviceInfo.Descriptor.bNumConfigurations ) {

  00750	e59d606c	 ldr         r6, [sp, #0x6C]
  00754	e5dd305d	 ldrb        r3, [sp, #0x5D]
  00758	e2866001	 add         r6, r6, #1
  0075c	e1560003	 cmp         r6, r3

; 1687 :                     // need to get more descriptors
; 1688 :                     configStatus = DEVICE_CONFIG_STATUS_SCHEDULING_GET_INITIAL_CONFIG_DESCRIPTOR;

  00760	33a0b009	 movcc       r11, #9
  00764	e58d606c	 str         r6, [sp, #0x6C]
  00768	3a00000a	 bcc         |$LN49@AttachDevi|

; 1689 :                 } else {
; 1690 :                     // done getting config descriptors
; 1691 :                     configStatus = DEVICE_CONFIG_STATUS_DETERMINE_CONFIG_TO_CHOOSE;

  0076c	e3a0b00b	 mov         r11, #0xB

; 1692 :                 }
; 1693 :             } else {

  00770	ea000008	 b           |$LN49@AttachDevi|
  00774		 |$LN52@AttachDevi|

; 1694 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("%s: CHub(%s tier %d)::AttachDevice - failure on %s step\n"),GetControllerName(), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1695 :                 pControlPipe->IsPipeHalted( &fPipeHalted );

  00774	e59a3000	 ldr         r3, [r10]
  00778	e28d103c	 add         r1, sp, #0x3C
  0077c	e1a0000a	 mov         r0, r10
  00780	e5933014	 ldr         r3, [r3, #0x14]
  00784	e1a0e00f	 mov         lr, pc
  00788	e12fff13	 bx          r3

; 1696 :                 configFailures++;

  0078c	e2873001	 add         r3, r7, #1
  00790	e20370ff	 and         r7, r3, #0xFF
  00794	e5cd7038	 strb        r7, [sp, #0x38]
  00798		 |$LN49@AttachDevi|

; 1697 :             }
; 1698 :             delete [] pDataBuffer;

  00798	e1a00004	 mov         r0, r4
  0079c	eb000000	 bl          |??3@YAXPAX@Z|

; 1699 :             pDataBuffer = NULL;
; 1700 :             break;

  007a0	ea00015a	 b           |$LN173@AttachDevi|
  007a4		 |$LN48@AttachDevi|

; 1701 :         }
; 1702 :         case DEVICE_CONFIG_STATUS_DETERMINE_CONFIG_TO_CHOOSE:
; 1703 :         {
; 1704 :             // We're not terribly smart about picking a config when the first one won't work. C'est la vie.
; 1705 :             // Also, we cannot check the device's actual power status until after it's configured.
; 1706 :             
; 1707 :             BYTE bConfig = 0;
; 1708 :             if ( m_pCHcd->GetpUSBDSelectConfigurationProc()!=NULL  // This function is supported by USBD.
; 1709 :                     && deviceInfo.Descriptor.bNumConfigurations > 1 ) {

  007a4	e59930c8	 ldr         r3, [r9, #0xC8]
  007a8	e3a02000	 mov         r2, #0
  007ac	e5cd2041	 strb        r2, [sp, #0x41]
  007b0	e5933078	 ldr         r3, [r3, #0x78]
  007b4	e3530000	 cmp         r3, #0
  007b8	0a000010	 beq         |$LN46@AttachDevi|
  007bc	e3540001	 cmp         r4, #1
  007c0	9a00000e	 bls         |$LN46@AttachDevi|

; 1710 :                 if (!(*m_pCHcd->GetpUSBDSelectConfigurationProc())(LPCUSB_DEVICE(&deviceInfo),&bConfig) || 
; 1711 :                         bConfig >= deviceInfo.Descriptor.bNumConfigurations ) { // if can not find anything return to 0.

  007c4	e28d1041	 add         r1, sp, #0x41
  007c8	e28d0048	 add         r0, sp, #0x48
  007cc	e1a0e00f	 mov         lr, pc
  007d0	e12fff13	 bx          r3
  007d4	e5dd405d	 ldrb        r4, [sp, #0x5D]
  007d8	e3500000	 cmp         r0, #0
  007dc	0a000002	 beq         |$LN45@AttachDevi|
  007e0	e5dd2041	 ldrb        r2, [sp, #0x41]
  007e4	e1520004	 cmp         r2, r4

; 1712 :                     bConfig = 0;

  007e8	3a000001	 bcc         |$LN174@AttachDevi|
  007ec		 |$LN45@AttachDevi|
  007ec	e3a02000	 mov         r2, #0
  007f0	e5cd2041	 strb        r2, [sp, #0x41]
  007f4		 |$LN174@AttachDevi|
  007f4	e59d103c	 ldr         r1, [sp, #0x3C]
  007f8	e5dde0a4	 ldrb        lr, [sp, #0xA4]
  007fc	e59d0060	 ldr         r0, [sp, #0x60]
  00800		 |$LN46@AttachDevi|

; 1713 :                 }
; 1714 :             }
; 1715 :             DEBUGMSG( ZONE_ATTACH, (TEXT("%s: CHub(%s tier %d)::AttachDevice - Select Configuration %d on %s step\n"),GetControllerName(), GetDeviceType(), m_tierNumber,bConfig,STATUS_TO_STRING( configStatus ) ) );
; 1716 :             if (deviceInfo.lpConfigs[bConfig].Descriptor.bmAttributes & SELF_POWERED) {

  00800	e0805282	 add         r5, r0, r2, lsl #5
  00804	e5d5300b	 ldrb        r3, [r5, #0xB]
  00808	e3130040	 tst         r3, #0x40
  0080c	1a000026	 bne         |$LN151@AttachDevi|

; 1717 :                 // the device we're attaching is self-powered so power is of little concern
; 1718 :             } else {
; 1719 :                 DWORD dwCfgPower = deviceInfo.lpConfigs[bConfig].Descriptor.MaxPower * 2; // MaxPower is in units of 2mA

  00810	e5d5300c	 ldrb        r3, [r5, #0xC]
  00814	e3530000	 cmp         r3, #0
  00818	e1a05083	 mov         r5, r3, lsl #1

; 1720 :                 if (deviceInfo.lpConfigs[bConfig].Descriptor.MaxPower == 0) {

  0081c	1a000007	 bne         |$LN42@AttachDevi|

; 1721 :                     RETAILMSG(1, (TEXT("!CHub::AttachDevice warning: invalid power configuration\n")));

  00820	e59f0524	 ldr         r0, [pc, #0x524]
  00824	eb000000	 bl          NKDbgPrintfW

; 1722 :                     dwCfgPower = 500; // If MaxPower is illigal, assume the maximum power is required.

  00828	e5dde0a4	 ldrb        lr, [sp, #0xA4]
  0082c	e59d0060	 ldr         r0, [sp, #0x60]
  00830	e5dd405d	 ldrb        r4, [sp, #0x5D]
  00834	e59d103c	 ldr         r1, [sp, #0x3C]
  00838	e5dd2041	 ldrb        r2, [sp, #0x41]
  0083c	e3a05f7d	 mov         r5, #0x7D, 30
  00840		 |$LN42@AttachDevi|

; 1723 :                 }
; 1724 :                 {
; 1725 :                     BOOL isOK;
; 1726 :                     if (m_deviceInfo.lpConfigs == NULL) {

  00840	e599303c	 ldr         r3, [r9, #0x3C]
  00844	e3530000	 cmp         r3, #0
  00848	1a00000a	 bne         |$LN41@AttachDevi|

; 1727 :                         // we must be a root hub; check with the PDD
; 1728 :                         isOK = HcdPdd_CheckConfigPower(port, dwCfgPower, 0);

  0084c	e5dd0040	 ldrb        r0, [sp, #0x40]
  00850	e3a02000	 mov         r2, #0
  00854	e1a01005	 mov         r1, r5
  00858	eb000000	 bl          HcdPdd_CheckConfigPower
  0085c	e5dd405d	 ldrb        r4, [sp, #0x5D]
  00860	e5dde0a4	 ldrb        lr, [sp, #0xA4]
  00864	e59d103c	 ldr         r1, [sp, #0x3C]
  00868	e5dd2041	 ldrb        r2, [sp, #0x41]
  0086c	e1a03000	 mov         r3, r0
  00870	e59d0060	 ldr         r0, [sp, #0x60]
  00874	ea000006	 b           |$LN36@AttachDevi|
  00878		 |$LN41@AttachDevi|

; 1729 :                     } else if (m_deviceInfo.lpActiveConfig->Descriptor.bmAttributes & SELF_POWERED) {

  00878	e5993040	 ldr         r3, [r9, #0x40]
  0087c	e5d3300b	 ldrb        r3, [r3, #0xB]
  00880	e3130040	 tst         r3, #0x40

; 1730 :                         // we're self-powered so we can attach a high-powered device
; 1731 :                         isOK = TRUE;

  00884	1a000008	 bne         |$LN151@AttachDevi|

; 1732 :                     } else if (dwCfgPower <= 100) {

  00888	e3550064	 cmp         r5, #0x64

; 1733 :                         // we're bus-powered so we can only attach low-powered devices
; 1734 :                         isOK = TRUE;
; 1735 :                     } else {

  0088c	9a000006	 bls         |$LN151@AttachDevi|

; 1736 :                         isOK = FALSE;

  00890	e3a03000	 mov         r3, #0
  00894		 |$LN36@AttachDevi|

; 1737 :                     }
; 1738 :                     if ( ! isOK ) {

  00894	e3530000	 cmp         r3, #0
  00898	1a000003	 bne         |$LN151@AttachDevi|

; 1739 :                         RETAILMSG(1, (TEXT("!USB warning: cannot attach high-power device to a bus-powered hub\n")));

  0089c	e59f04a4	 ldr         r0, [pc, #0x4A4]
  008a0	eb000000	 bl          NKDbgPrintfW
  008a4	e3a0b013	 mov         r11, #0x13
  008a8	eafffe03	 b           |$LN170@AttachDevi|
  008ac		 |$LN151@AttachDevi|

; 1740 :                         configStatus = DEVICE_CONFIG_STATUS_FAILED;
; 1741 :                     }
; 1742 :                 }
; 1743 :             }
; 1744 :             if (configStatus != DEVICE_CONFIG_STATUS_FAILED) {
; 1745 :                 DEBUGCHK( deviceInfo.lpActiveConfig == NULL && deviceInfo.lpConfigs != NULL );
; 1746 : 
; 1747 :                 deviceInfo.lpActiveConfig = &deviceInfo.lpConfigs[bConfig];

  008ac	e0802282	 add         r2, r0, r2, lsl #5
  008b0	e58d2064	 str         r2, [sp, #0x64]

; 1748 :                 DEBUGCHK( deviceInfo.lpActiveConfig->lpInterfaces != NULL );
; 1749 : 
; 1750 :                 configStatus = DEVICE_CONFIG_STATUS_SCHEDULING_SET_CONFIG;

  008b4	e3a0b00c	 mov         r11, #0xC

; 1751 :             }
; 1752 :             break;

  008b8	eafffe04	 b           |$LL97@AttachDevi|
  008bc		 |$LN33@AttachDevi|

; 1753 :         }
; 1754 :         case DEVICE_CONFIG_STATUS_SCHEDULING_SET_CONFIG:
; 1755 :         {
; 1756 :             DEBUGCHK( deviceInfo.lpActiveConfig != NULL );
; 1757 : 
; 1758 :             BOOL                fTransferDone = FALSE;
; 1759 :             DWORD               dwBytesTransferred = 0;

  008bc	e3a01000	 mov         r1, #0

; 1760 :             DWORD               dwErrorFlags = USB_NOT_COMPLETE_ERROR;
; 1761 :             HCD_REQUEST_STATUS  status = requestFailed;
; 1762 :             USB_DEVICE_REQUEST  usbRequest;
; 1763 : 
; 1764 :             usbRequest.bmRequestType = USB_REQUEST_HOST_TO_DEVICE | USB_REQUEST_STANDARD | USB_REQUEST_FOR_DEVICE;
; 1765 :             usbRequest.bRequest = USB_REQUEST_SET_CONFIGURATION;

  008c0	e58d1074	 str         r1, [sp, #0x74]
  008c4	e3a03000	 mov         r3, #0
  008c8	e3a01c01	 mov         r1, #1, 24
  008cc	e58d307c	 str         r3, [sp, #0x7C]
  008d0	e3813003	 orr         r3, r1, #3
  008d4	e3a00000	 mov         r0, #0
  008d8	e3a0e009	 mov         lr, #9
  008dc	e58d3070	 str         r3, [sp, #0x70]
  008e0	e5cd009c	 strb        r0, [sp, #0x9C]
  008e4	e5cde09d	 strb        lr, [sp, #0x9D]

; 1766 :             usbRequest.wValue = deviceInfo.lpActiveConfig->Descriptor.bConfigurationValue;

  008e8	e5d23009	 ldrb        r3, [r2, #9]

; 1767 :             usbRequest.wIndex = 0;

  008ec	e3a02000	 mov         r2, #0

; 1768 :             usbRequest.wLength = 0;

  008f0	e3a01000	 mov         r1, #0
  008f4	e1cd39be	 strh        r3, [sp, #0x9E]
  008f8	e1cd2ab0	 strh        r2, [sp, #0xA0]
  008fc	e1cd1ab2	 strh        r1, [sp, #0xA2]

; 1769 :             if ( !m_fHubThreadClosing ) {

  00900	e3550000	 cmp         r5, #0
  00904	1a000048	 bne         |$LN28@AttachDevi|

; 1770 :                 status = pControlPipe->IssueTransfer(
; 1771 :                                             address, // device rAddress
; 1772 :                                             TransferDoneCallbackSetEvent, // callback
; 1773 :                                             m_hHubStatusChangeEvent, // param for callback
; 1774 :                                             USB_OUT_TRANSFER | USB_SEND_TO_DEVICE, // transfer flags
; 1775 :                                             &usbRequest, // control request
; 1776 :                                             0, // dwStartingFrame (not used)
; 1777 :                                             0, // dwFrames (not used)
; 1778 :                                             NULL, // aLengths (not used)
; 1779 :                                             0, // buffer size
; 1780 :                                             NULL, // data buffer
; 1781 :                                             0, // phys addr of buffer (not used)
; 1782 :                                             this, // cancel ID
; 1783 :                                             NULL, // adwIsochErrors (not used)
; 1784 :                                             NULL, // adwIsochLengths (not used)
; 1785 :                                             &fTransferDone, // OUT status param
; 1786 :                                             &dwBytesTransferred, // OUT status param
; 1787 :                                             &dwErrorFlags ); // OUT status param

  00908	e28d4070	 add         r4, sp, #0x70
  0090c	e59a1000	 ldr         r1, [r10]
  00910	e58d4034	 str         r4, [sp, #0x34]
  00914	e3a04000	 mov         r4, #0
  00918	e58d4028	 str         r4, [sp, #0x28]
  0091c	e58d4024	 str         r4, [sp, #0x24]
  00920	e58d401c	 str         r4, [sp, #0x1C]
  00924	e58d4018	 str         r4, [sp, #0x18]
  00928	e58d4014	 str         r4, [sp, #0x14]
  0092c	e58d4010	 str         r4, [sp, #0x10]
  00930	e58d400c	 str         r4, [sp, #0xC]
  00934	e58d4008	 str         r4, [sp, #8]
  00938	e591800c	 ldr         r8, [r1, #0xC]
  0093c	e3a04a01	 mov         r4, #1, 20
  00940	e59930bc	 ldr         r3, [r9, #0xBC]
  00944	e59f23f8	 ldr         r2, [pc, #0x3F8]
  00948	e28d5074	 add         r5, sp, #0x74
  0094c	e28d607c	 add         r6, sp, #0x7C
  00950	e28d709c	 add         r7, sp, #0x9C
  00954	e5dd1039	 ldrb        r1, [sp, #0x39]
  00958	e58d4000	 str         r4, [sp]
  0095c	e1a0000a	 mov         r0, r10
  00960	e58d5030	 str         r5, [sp, #0x30]
  00964	e58d602c	 str         r6, [sp, #0x2C]
  00968	e58d9020	 str         r9, [sp, #0x20]
  0096c	e58d7004	 str         r7, [sp, #4]
  00970	e1a0e00f	 mov         lr, pc
  00974	e12fff18	 bx          r8

; 1788 :                 if ( status == requestOK ) {

  00978	e3500001	 cmp         r0, #1
  0097c	1a000027	 bne         |$LN161@AttachDevi|

; 1789 :                     DWORD dwResult = WaitForSingleObject( m_hHubStatusChangeEvent, STANDARD_REQUEST_TIMEOUT );

  00980	e59900bc	 ldr         r0, [r9, #0xBC]
  00984	e3a01f7d	 mov         r1, #0x7D, 30
  00988	eb000000	 bl          WaitForSingleObject

; 1790 :                     if ( m_fHubThreadClosing || dwResult!= WAIT_OBJECT_0 ) {

  0098c	e59930b8	 ldr         r3, [r9, #0xB8]
  00990	e3530000	 cmp         r3, #0
  00994	1a000001	 bne         |$LN29@AttachDevi|
  00998	e3500000	 cmp         r0, #0
  0099c	0a00000a	 beq         |$LN131@AttachDevi|
  009a0		 |$LN29@AttachDevi|

; 1791 :                         pControlPipe->AbortTransfer( NULL, // callback function
; 1792 :                                                      NULL, // callback parameter
; 1793 :                                                      this ); // cancel ID

  009a0	e59a1000	 ldr         r1, [r10]
  009a4	e1a03009	 mov         r3, r9
  009a8	e3a02000	 mov         r2, #0
  009ac	e5914010	 ldr         r4, [r1, #0x10]
  009b0	e3a01000	 mov         r1, #0
  009b4	e1a0000a	 mov         r0, r10
  009b8	e1a0e00f	 mov         lr, pc
  009bc	e12fff14	 bx          r4

; 1794 :                         ResetEvent(m_hHubStatusChangeEvent);                        

  009c0	e59900bc	 ldr         r0, [r9, #0xBC]
  009c4	e3a01002	 mov         r1, #2
  009c8	eb000000	 bl          EventModify
  009cc		 |$LN131@AttachDevi|

; 1795 :                     }
; 1796 :                 }
; 1797 :                 DEBUGCHK( fTransferDone );
; 1798 :             }
; 1799 :             if ( status == requestOK &&
; 1800 :                  fTransferDone &&
; 1801 :                  dwBytesTransferred == 0 &&
; 1802 :                  dwErrorFlags == USB_NO_ERROR ) {

  009cc	e59d307c	 ldr         r3, [sp, #0x7C]
  009d0	e3530000	 cmp         r3, #0
  009d4	0a000011	 beq         |$LN161@AttachDevi|
  009d8	e59d3074	 ldr         r3, [sp, #0x74]
  009dc	e3530000	 cmp         r3, #0
  009e0	1a00000e	 bne         |$LN161@AttachDevi|
  009e4	e59d3070	 ldr         r3, [sp, #0x70]
  009e8	e3530000	 cmp         r3, #0
  009ec	1a00000b	 bne         |$LN161@AttachDevi|

; 1803 :                 // move to next step
; 1804 :                 if ( deviceInfo.Descriptor.bDeviceClass == USB_DEVICE_CLASS_HUB ) {

  009f0	e5dd3050	 ldrb        r3, [sp, #0x50]

; 1805 :                     // more steps need to happen for hubs
; 1806 :                     usbHubDescriptor.bDescriptorLength = USB_HUB_DESCRIPTOR_MINIMUM_SIZE;
; 1807 :                     configStatus = DEVICE_CONFIG_STATUS_SCHEDULING_GET_INITIAL_HUB_DESCRIPTOR;
; 1808 :                 } else {

  009f4	e59d2064	 ldr         r2, [sp, #0x64]
  009f8	e59d0060	 ldr         r0, [sp, #0x60]
  009fc	e3530009	 cmp         r3, #9
  00a00	03a0e009	 moveq       lr, #9
  00a04	e5dd405d	 ldrb        r4, [sp, #0x5D]
  00a08	e59d103c	 ldr         r1, [sp, #0x3C]
  00a0c	05cde0a4	 streqb      lr, [sp, #0xA4]
  00a10	03a0b00d	 moveq       r11, #0xD
  00a14	0afffea0	 beq         |$LN167@AttachDevi|

; 1809 :                     configStatus = DEVICE_CONFIG_STATUS_CREATE_NEW_FUNCTION;
; 1810 :                 }
; 1811 :             } else {

  00a18	e3a0b010	 mov         r11, #0x10
  00a1c	eafffe9d	 b           |$LN175@AttachDevi|
  00a20		 |$LN161@AttachDevi|

; 1912 :                 configStatus = DEVICE_CONFIG_STATUS_DONE;
; 1913 :             } else {
; 1914 :                 // don't do any retries here! EnterOperationalState
; 1915 :                 // should only be tried once
; 1916 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("%s: CHub(%s tier %d)::AttachDevice - failure on %s step, aborting attach process\n"),GetControllerName(), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1917 :                 configStatus = DEVICE_CONFIG_STATUS_FAILED;
; 1918 :                 configFailures = 0xff;
; 1919 :             }
; 1920 :             break;

  00a20	e5dd8039	 ldrb        r8, [sp, #0x39]
  00a24	e59d6044	 ldr         r6, [sp, #0x44]
  00a28	e5dd7038	 ldrb        r7, [sp, #0x38]
  00a2c		 |$LN28@AttachDevi|
  00a2c	e59a3000	 ldr         r3, [r10]
  00a30	e28d103c	 add         r1, sp, #0x3C
  00a34	e1a0000a	 mov         r0, r10
  00a38	e5933014	 ldr         r3, [r3, #0x14]
  00a3c	e1a0e00f	 mov         lr, pc
  00a40	e12fff13	 bx          r3
  00a44	eafffe27	 b           |$LN83@AttachDevi|
  00a48		 |$LN24@AttachDevi|

; 1812 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("%s: CHub(%s tier %d)::AttachDevice - failure on %s step, fTransferDone = %d, dwBytesTrans = 0x%x, dwErrorFlags = 0x%x\n"),GetControllerName(), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ), fTransferDone, dwBytesTransferred, dwErrorFlags ) );
; 1813 :                 pControlPipe->IsPipeHalted( &fPipeHalted );
; 1814 :                 configFailures++;
; 1815 :             }
; 1816 :             break;
; 1817 :         }
; 1818 :         case DEVICE_CONFIG_STATUS_SCHEDULING_GET_INITIAL_HUB_DESCRIPTOR:
; 1819 :         case DEVICE_CONFIG_STATUS_SCHEDULING_GET_HUB_DESCRIPTOR:
; 1820 :         {
; 1821 :             DEBUGCHK( deviceInfo.Descriptor.bDeviceClass == USB_DEVICE_CLASS_HUB );
; 1822 :             DEBUGCHK( (configStatus == DEVICE_CONFIG_STATUS_SCHEDULING_GET_INITIAL_HUB_DESCRIPTOR &&
; 1823 :                        usbHubDescriptor.bDescriptorLength == USB_HUB_DESCRIPTOR_MINIMUM_SIZE) ||
; 1824 :                       (configStatus == DEVICE_CONFIG_STATUS_SCHEDULING_GET_HUB_DESCRIPTOR &&
; 1825 :                        usbHubDescriptor.bDescriptorLength > USB_HUB_DESCRIPTOR_MINIMUM_SIZE &&
; 1826 :                        usbHubDescriptor.bDescriptorLength <= sizeof( usbHubDescriptor ) ) );
; 1827 :             const UCHAR descriptorLengthToGet = usbHubDescriptor.bDescriptorLength;
; 1828 :             if ( GetDescriptor( pControlPipe,
; 1829 :                                 address,
; 1830 :                                 USB_HUB_DESCRIPTOR_TYPE,
; 1831 :                                 0, // hub descriptor index is 0
; 1832 :                                 descriptorLengthToGet,
; 1833 :                                 &usbHubDescriptor ) ) {

  00a48	e28d30a4	 add         r3, sp, #0xA4
  00a4c	e1a0500e	 mov         r5, lr
  00a50	e58de004	 str         lr, [sp, #4]
  00a54	e58d3008	 str         r3, [sp, #8]
  00a58	e3a0e000	 mov         lr, #0
  00a5c	e3a03029	 mov         r3, #0x29
  00a60	e1a02008	 mov         r2, r8
  00a64	e1a0100a	 mov         r1, r10
  00a68	e1a00009	 mov         r0, r9
  00a6c	e58de000	 str         lr, [sp]
  00a70	eb000000	 bl          |?GetDescriptor@CHub@@IAAHQAVCPipeAbs@@EEEGPAX@Z|
  00a74	e3500000	 cmp         r0, #0
  00a78	0a000009	 beq         |$LN23@AttachDevi|

; 1834 :                 // success
; 1835 :                 if ( usbHubDescriptor.bDescriptorLength > descriptorLengthToGet ) {

  00a7c	e5dde0a4	 ldrb        lr, [sp, #0xA4]

; 1836 :                     DEBUGCHK( configStatus == DEVICE_CONFIG_STATUS_SCHEDULING_GET_INITIAL_HUB_DESCRIPTOR );
; 1837 :                     configStatus = DEVICE_CONFIG_STATUS_SCHEDULING_GET_HUB_DESCRIPTOR;
; 1838 :                 } else {

  00a80	e59d2064	 ldr         r2, [sp, #0x64]
  00a84	e59d0060	 ldr         r0, [sp, #0x60]
  00a88	e15e0005	 cmp         lr, r5
  00a8c	e5dd405d	 ldrb        r4, [sp, #0x5D]
  00a90	e59d103c	 ldr         r1, [sp, #0x3C]
  00a94	83a0b00e	 movhi       r11, #0xE
  00a98	8afffd8c	 bhi         |$LL97@AttachDevi|

; 1839 :                     DEBUGCHK( usbHubDescriptor.bDescriptorLength == descriptorLengthToGet );
; 1840 :                 #ifdef DEBUG
; 1841 :                     DumpHubDescriptor( &usbHubDescriptor );
; 1842 :                 #endif // DEBUG
; 1843 :                     configStatus = DEVICE_CONFIG_STATUS_CREATE_NEW_HUB;
; 1844 :                 }
; 1845 :             } else {

  00a9c	e3a0b00f	 mov         r11, #0xF
  00aa0	eafffd8a	 b           |$LL97@AttachDevi|
  00aa4		 |$LN23@AttachDevi|

; 1846 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("%s: CHub(%s tier %d)::AttachDevice - failure on %s step\n"),GetControllerName(), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1847 :                 pControlPipe->IsPipeHalted( &fPipeHalted );

  00aa4	e59a3000	 ldr         r3, [r10]
  00aa8	e28d103c	 add         r1, sp, #0x3C
  00aac	e1a0000a	 mov         r0, r10
  00ab0	e5933014	 ldr         r3, [r3, #0x14]
  00ab4	e1a0e00f	 mov         lr, pc
  00ab8	e12fff13	 bx          r3

; 1848 :                 configFailures++;

  00abc	e2873001	 add         r3, r7, #1
  00ac0	e20370ff	 and         r7, r3, #0xFF
  00ac4	e5cd7038	 strb        r7, [sp, #0x38]

; 1849 :                 // Restore bDescriptorLength for the retry.
; 1850 :                 usbHubDescriptor.bDescriptorLength = descriptorLengthToGet;

  00ac8	e1a0e005	 mov         lr, r5

; 1851 :             }
; 1852 :             break;

  00acc	e5cd50a4	 strb        r5, [sp, #0xA4]
  00ad0	ea00008f	 b           |$LN176@AttachDevi|
  00ad4		 |$LN19@AttachDevi|

; 1853 :         }
; 1854 :         case DEVICE_CONFIG_STATUS_CREATE_NEW_HUB:
; 1855 :         {
; 1856 :             DEBUGCHK( pNewDevice == NULL );
; 1857 :             DEBUGCHK( deviceInfo.Descriptor.bDeviceClass == USB_DEVICE_CLASS_HUB &&
; 1858 :                       usbHubDescriptor.bDescriptorType == USB_HUB_DESCRIPTOR_TYPE &&
; 1859 :                       usbHubDescriptor.bDescriptorLength >= USB_HUB_DESCRIPTOR_MINIMUM_SIZE &&
; 1860 :                       deviceInfo.lpActiveConfig->lpInterfaces[0].Descriptor.bNumEndpoints == 1);
; 1861 : 
; 1862 :             DEBUGCHK( m_tierNumber < USB_MAXIMUM_HUB_TIER );
; 1863 :             pNewDevice = new CExternalHub( address,
; 1864 :                                            deviceInfo,
; 1865 :                                            fIsLowSpeed,fIsHighSpeed,
; 1866 :                                            m_tierNumber + 1,
; 1867 :                                            usbHubDescriptor,
; 1868 :                                            m_pCHcd,
; 1869 :                                            this,port);

  00ad4	e3a000cc	 mov         r0, #0xCC
  00ad8	eb000000	 bl          |??2@YAPAXI@Z|
  00adc	e3500000	 cmp         r0, #0
  00ae0	0a000012	 beq         |$LN111@AttachDevi|
  00ae4	e5d9304c	 ldrb        r3, [r9, #0x4C]
  00ae8	e599e0c8	 ldr         lr, [r9, #0xC8]
  00aec	e5dd5040	 ldrb        r5, [sp, #0x40]
  00af0	e2833001	 add         r3, r3, #1
  00af4	e20330ff	 and         r3, r3, #0xFF
  00af8	e58de00c	 str         lr, [sp, #0xC]
  00afc	e59de080	 ldr         lr, [sp, #0x80]
  00b00	e58d3004	 str         r3, [sp, #4]
  00b04	e59d3084	 ldr         r3, [sp, #0x84]
  00b08	e28d40a4	 add         r4, sp, #0xA4
  00b0c	e28d2048	 add         r2, sp, #0x48
  00b10	e1a01008	 mov         r1, r8
  00b14	e58d5014	 str         r5, [sp, #0x14]
  00b18	e58d9010	 str         r9, [sp, #0x10]
  00b1c	e58d4008	 str         r4, [sp, #8]
  00b20	e58de000	 str         lr, [sp]
  00b24	eb000000	 bl          |??0CExternalHub@@QAA@EABU_USB_DEVICE_INFO@@HHEABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@QAVCHub@@E@Z|
  00b28	e1a06000	 mov         r6, r0
  00b2c	ea000000	 b           |$LN177@AttachDevi|
  00b30		 |$LN111@AttachDevi|
  00b30	e3a06000	 mov         r6, #0
  00b34		 |$LN177@AttachDevi|

; 1870 :             if ( pNewDevice != NULL ) {

  00b34	e3560000	 cmp         r6, #0
  00b38	e58d6044	 str         r6, [sp, #0x44]
  00b3c	0afffde9	 beq         |$LN83@AttachDevi|

; 1871 :                 configStatus = DEVICE_CONFIG_STATUS_INSERT_NEW_DEVICE_INTO_UPSTREAM_HUB_PORT_ARRAY;
; 1872 :             } else {

  00b40	e3a0b011	 mov         r11, #0x11
  00b44	eafffd5c	 b           |$LN170@AttachDevi|
  00b48		 |$LN16@AttachDevi|

; 1873 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("%s: CHub(%s tier %d)::AttachDevice - failure on %s step, no memory\n"),GetControllerName(), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1874 :                 configFailures++;
; 1875 :             }
; 1876 :             break;
; 1877 :         }
; 1878 :         case DEVICE_CONFIG_STATUS_CREATE_NEW_FUNCTION:
; 1879 :         {
; 1880 :             DEBUGCHK( pNewDevice == NULL );
; 1881 :             DEBUGCHK( deviceInfo.Descriptor.bDeviceClass != USB_DEVICE_CLASS_HUB );
; 1882 :             DEBUGCHK( m_tierNumber <= USB_MAXIMUM_HUB_TIER );
; 1883 :             pNewDevice = new CFunction( address,
; 1884 :                                         deviceInfo,
; 1885 :                                         fIsLowSpeed,fIsHighSpeed,
; 1886 :                                         m_tierNumber + 1,
; 1887 :                                         m_pCHcd,
; 1888 :                                         this,port);

  00b48	e3a0006c	 mov         r0, #0x6C
  00b4c	eb000000	 bl          |??2@YAPAXI@Z|
  00b50	e3500000	 cmp         r0, #0
  00b54	0afffff5	 beq         |$LN111@AttachDevi|
  00b58	e5d9204c	 ldrb        r2, [r9, #0x4C]
  00b5c	e599e0c8	 ldr         lr, [r9, #0xC8]
  00b60	e5dd4040	 ldrb        r4, [sp, #0x40]
  00b64	e2822001	 add         r2, r2, #1
  00b68	e59d3084	 ldr         r3, [sp, #0x84]
  00b6c	e58de008	 str         lr, [sp, #8]
  00b70	e59de080	 ldr         lr, [sp, #0x80]
  00b74	e20220ff	 and         r2, r2, #0xFF
  00b78	e58d2004	 str         r2, [sp, #4]
  00b7c	e28d2048	 add         r2, sp, #0x48
  00b80	e1a01008	 mov         r1, r8
  00b84	e58d4010	 str         r4, [sp, #0x10]
  00b88	e58d900c	 str         r9, [sp, #0xC]
  00b8c	e58de000	 str         lr, [sp]
  00b90	eb000000	 bl          |??0CFunction@@QAA@EABU_USB_DEVICE_INFO@@HHEQAVCHcd@@QAVCHub@@E@Z|
  00b94	e1a06000	 mov         r6, r0
  00b98	eaffffe5	 b           |$LN177@AttachDevi|
  00b9c		 |$LN13@AttachDevi|

; 1889 :             if ( pNewDevice != NULL ) {
; 1890 :                 configStatus = DEVICE_CONFIG_STATUS_INSERT_NEW_DEVICE_INTO_UPSTREAM_HUB_PORT_ARRAY;
; 1891 :             } else {
; 1892 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("%s: CHub(%s tier %d)::AttachDevice - failure on %s step, no memory\n"),GetControllerName(), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1893 :                 configFailures++;
; 1894 :             }
; 1895 :             break;
; 1896 :         }
; 1897 :         case DEVICE_CONFIG_STATUS_INSERT_NEW_DEVICE_INTO_UPSTREAM_HUB_PORT_ARRAY:
; 1898 :         {
; 1899 :             DEBUGCHK( pNewDevice != NULL );
; 1900 :             EnterCriticalSection( &m_csDeviceLock );

  00b9c	e289000c	 add         r0, r9, #0xC
  00ba0	eb000000	 bl          EnterCriticalSection

; 1901 :             DEBUGCHK( m_ppCDeviceOnPort != NULL &&
; 1902 :                       m_ppCDeviceOnPort[ port - 1 ] == NULL );
; 1903 :             m_ppCDeviceOnPort[ port - 1 ] = pNewDevice;

  00ba4	e59930b0	 ldr         r3, [r9, #0xB0]

; 1904 :             LeaveCriticalSection( &m_csDeviceLock );

  00ba8	e5dd2040	 ldrb        r2, [sp, #0x40]
  00bac	e289000c	 add         r0, r9, #0xC
  00bb0	e0833102	 add         r3, r3, r2, lsl #2
  00bb4	e5036004	 str         r6, [r3, #-4]
  00bb8	eb000000	 bl          LeaveCriticalSection

; 1905 :             configStatus = DEVICE_CONFIG_STATUS_SIGNAL_NEW_DEVICE_ENTER_OPERATIONAL_STATE;
; 1906 :             break;

  00bbc	e3a0b012	 mov         r11, #0x12
  00bc0	eafffd3d	 b           |$LN170@AttachDevi|
  00bc4		 |$LN12@AttachDevi|

; 1907 :         }
; 1908 :         case DEVICE_CONFIG_STATUS_SIGNAL_NEW_DEVICE_ENTER_OPERATIONAL_STATE:
; 1909 :         {
; 1910 :             DEBUGCHK( pNewDevice != NULL );
; 1911 :             if ( pNewDevice->EnterOperationalState( pControlPipe ) ) {

  00bc4	e5963000	 ldr         r3, [r6]
  00bc8	e1a0100a	 mov         r1, r10
  00bcc	e1a00006	 mov         r0, r6
  00bd0	e5933004	 ldr         r3, [r3, #4]
  00bd4	e1a0e00f	 mov         lr, pc
  00bd8	e12fff13	 bx          r3
  00bdc	e3500000	 cmp         r0, #0
  00be0	1a000052	 bne         |$LN157@AttachDevi|

; 1912 :                 configStatus = DEVICE_CONFIG_STATUS_DONE;
; 1913 :             } else {
; 1914 :                 // don't do any retries here! EnterOperationalState
; 1915 :                 // should only be tried once
; 1916 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("%s: CHub(%s tier %d)::AttachDevice - failure on %s step, aborting attach process\n"),GetControllerName(), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1917 :                 configStatus = DEVICE_CONFIG_STATUS_FAILED;
; 1918 :                 configFailures = 0xff;
; 1919 :             }
; 1920 :             break;

  00be4	e3a070ff	 mov         r7, #0xFF
  00be8	e5cd7038	 strb        r7, [sp, #0x38]
  00bec	e3a0b013	 mov         r11, #0x13
  00bf0	eafffd31	 b           |$LN170@AttachDevi|
  00bf4		 |$LN9@AttachDevi|

; 1921 :         }
; 1922 :         case DEVICE_CONFIG_STATUS_FAILED:
; 1923 :         {
; 1924 :             if ( pNewDevice != NULL ) {

  00bf4	e3560000	 cmp         r6, #0
  00bf8	0a000011	 beq         |$LN8@AttachDevi|

; 1925 :                 // this means we have placed the device into our array
; 1926 :                 EnterCriticalSection( &m_csDeviceLock );

  00bfc	e289000c	 add         r0, r9, #0xC
  00c00	eb000000	 bl          EnterCriticalSection

; 1927 :                 DEBUGCHK( (m_fHubThreadClosing && m_ppCDeviceOnPort[ port - 1 ] == NULL) ||
; 1928 :                           m_ppCDeviceOnPort[ port - 1 ] == pNewDevice );
; 1929 :                 m_ppCDeviceOnPort[ port - 1 ] = NULL;

  00c04	e59930b0	 ldr         r3, [r9, #0xB0]

; 1930 :                 LeaveCriticalSection( &m_csDeviceLock );

  00c08	e5dd4040	 ldrb        r4, [sp, #0x40]
  00c0c	e3a02000	 mov         r2, #0
  00c10	e289000c	 add         r0, r9, #0xC
  00c14	e0833104	 add         r3, r3, r4, lsl #2
  00c18	e5032004	 str         r2, [r3, #-4]
  00c1c	eb000000	 bl          LeaveCriticalSection

; 1931 :                 // address will be freed by destructor
; 1932 :                 // deviceInfo will be freed by destructor
; 1933 :                 delete pNewDevice;

  00c20	e5963000	 ldr         r3, [r6]
  00c24	e3a01001	 mov         r1, #1
  00c28	e1a00006	 mov         r0, r6
  00c2c	e5933000	 ldr         r3, [r3]
  00c30	e1a0e00f	 mov         lr, pc
  00c34	e12fff13	 bx          r3

; 1934 :                 pNewDevice = NULL;

  00c38	e3a03000	 mov         r3, #0
  00c3c	e58d3044	 str         r3, [sp, #0x44]

; 1935 :             } else {

  00c40	ea000013	 b           |$LN133@AttachDevi|
  00c44		 |$LN8@AttachDevi|

; 1936 :                 if ( deviceInfo.lpConfigs != NULL ) {

  00c44	e3500000	 cmp         r0, #0
  00c48	0a00000d	 beq         |$LN6@AttachDevi|

; 1937 :                     for ( UINT config = 0; config < deviceInfo.Descriptor.bNumConfigurations; config++ ) {

  00c4c	e3a05000	 mov         r5, #0
  00c50	e3540000	 cmp         r4, #0
  00c54	0a000009	 beq         |$LN3@AttachDevi|
  00c58	e3a04000	 mov         r4, #0
  00c5c		 |$LL5@AttachDevi|
  00c5c	e0841000	 add         r1, r4, r0

; 1938 :                         DeleteUsbConfigurationStructure( deviceInfo.lpConfigs[ config ] );

  00c60	e1a00009	 mov         r0, r9
  00c64	eb000000	 bl          |?DeleteUsbConfigurationStructure@CDevice@@QBAXAAU_NON_CONST_USB_CONFIGURATION@@@Z|
  00c68	e5dd305d	 ldrb        r3, [sp, #0x5D]
  00c6c	e2855001	 add         r5, r5, #1
  00c70	e59d0060	 ldr         r0, [sp, #0x60]
  00c74	e1550003	 cmp         r5, r3
  00c78	e2844020	 add         r4, r4, #0x20
  00c7c	3afffff6	 bcc         |$LL5@AttachDevi|
  00c80		 |$LN3@AttachDevi|

; 1939 :                     }
; 1940 :                     delete [] deviceInfo.lpConfigs;

  00c80	eb000000	 bl          |??3@YAXPAX@Z|
  00c84		 |$LN6@AttachDevi|

; 1941 :                 }
; 1942 :                 DEBUGCHK( address > 0 && address <= USB_MAX_ADDRESS );
; 1943 :                 FreeAddress( address );

  00c84	e5990050	 ldr         r0, [r9, #0x50]
  00c88	e1a01008	 mov         r1, r8
  00c8c	eb000000	 bl          |?FreeAddress@CDeviceGlobal@@QAAXE@Z|
  00c90	e5dd4040	 ldrb        r4, [sp, #0x40]
  00c94		 |$LN133@AttachDevi|

; 1944 :             }
; 1945 :             if ( pControlPipe ) {

  00c94	e35a0000	 cmp         r10, #0
  00c98	0a00000b	 beq         |$LN2@AttachDevi|

; 1946 :                 pControlPipe->ClosePipe();

  00c9c	e59a3000	 ldr         r3, [r10]
  00ca0	e1a0000a	 mov         r0, r10
  00ca4	e5933008	 ldr         r3, [r3, #8]
  00ca8	e1a0e00f	 mov         lr, pc
  00cac	e12fff13	 bx          r3

; 1947 :                 delete pControlPipe;

  00cb0	e59a3000	 ldr         r3, [r10]
  00cb4	e3a01001	 mov         r1, #1
  00cb8	e1a0000a	 mov         r0, r10
  00cbc	e5933000	 ldr         r3, [r3]
  00cc0	e1a0e00f	 mov         lr, pc
  00cc4	e12fff13	 bx          r3

; 1948 :                 pControlPipe = NULL;

  00cc8	e3a0a000	 mov         r10, #0
  00ccc		 |$LN2@AttachDevi|

; 1949 :             }
; 1950 :             fPipeHalted = TRUE;
; 1951 :             DisablePort( port );

  00ccc	e5993000	 ldr         r3, [r9]
  00cd0	e3a02001	 mov         r2, #1
  00cd4	e1a01004	 mov         r1, r4
  00cd8	e5933060	 ldr         r3, [r3, #0x60]
  00cdc	e1a00009	 mov         r0, r9
  00ce0	e58d203c	 str         r2, [sp, #0x3C]
  00ce4	e1a0e00f	 mov         lr, pc
  00ce8	e12fff13	 bx          r3

; 1952 :             if ( fUsingAddr0 ) {

  00cec	e59d3078	 ldr         r3, [sp, #0x78]
  00cf0	e3530000	 cmp         r3, #0
  00cf4	0a000004	 beq         |$LN1@AttachDevi|

; 1953 :                 //LeaveCritSec_Ex( &m_csAddress0Lock );
; 1954 :                 m_pDeviceGlobal->Addr0LockLeave();

  00cf8	e5993050	 ldr         r3, [r9, #0x50]
  00cfc	e283002c	 add         r0, r3, #0x2C
  00d00	eb000000	 bl          |?LeaveCritSec_Ex@CritSec_Ex@@QAAXXZ|

; 1955 :                 fUsingAddr0 = FALSE;

  00d04	e3a05000	 mov         r5, #0
  00d08	e58d5078	 str         r5, [sp, #0x78]
  00d0c		 |$LN1@AttachDevi|

; 1956 :             }
; 1957 :             configStatus = DEVICE_CONFIG_STATUS_DONE;

  00d0c	e3a0b014	 mov         r11, #0x14
  00d10		 |$LN173@AttachDevi|
  00d10	e5dde0a4	 ldrb        lr, [sp, #0xA4]
  00d14		 |$LN176@AttachDevi|
  00d14	e59d2064	 ldr         r2, [sp, #0x64]
  00d18	e59d0060	 ldr         r0, [sp, #0x60]
  00d1c	e5dd405d	 ldrb        r4, [sp, #0x5D]
  00d20	e59d103c	 ldr         r1, [sp, #0x3C]
  00d24		 |$LN92@AttachDevi|
  00d24	e59d6044	 ldr         r6, [sp, #0x44]
  00d28	e35b0014	 cmp         r11, #0x14
  00d2c	1afffce7	 bne         |$LL97@AttachDevi|
  00d30		 |$LN157@AttachDevi|

; 1387 : {

  00d30	e59d00ec	 ldr         r0, [sp, #0xEC]
  00d34	eb000000	 bl          __security_check_cookie

; 1958 :             break;
; 1959 :         }
; 1960 :     #ifdef DEBUG
; 1961 :         default:
; 1962 :         {
; 1963 :             DebugBreak(); // should never get here!
; 1964 :             break;
; 1965 :         }
; 1966 :     #endif // DEBUG
; 1967 :         } // end of switch ( configStatus )
; 1968 :     } // end of while ( configStatus != DEVICE_CONFIG_STATUS_DONE )
; 1969 : 
; 1970 :     DEBUGMSG( ZONE_ATTACH, (TEXT("%s: -CHub(%s tier %d)::AttachDevice - port = %d, fIsLowSpeed = %d, address = %d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, port, fIsLowSpeed, address ) );
; 1971 : }

  00d38	e28dd0f0	 add         sp, sp, #0xF0
  00d3c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00d40	e12fff1e	 bx          lr
  00d44		 |$LN206@AttachDevi|
  00d44		 |$LN207@AttachDevi|
  00d44	00000000	 DCD         |?TransferDoneCallbackSetEvent@CDevice@@KAKPAX@Z|
  00d48		 |$LN208@AttachDevi|
  00d48	00000000	 DCD         |??_C@_1II@HDIFDMNL@?$AA?$CB?$AAU?$AAS?$AAB?$AA?5?$AAw?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAa?$AAt?$AAt?$AAa?$AAc?$AAh?$AA?5?$AAh?$AAi?$AAg?$AAh@|
  00d4c		 |$LN209@AttachDevi|
  00d4c	00000000	 DCD         |??_C@_1HE@DLPCNLDH@?$AA?$CB?$AAC?$AAH?$AAu?$AAb?$AA?3?$AA?3?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAw?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAi?$AAn?$AAv@|
  00d50		 |$LN210@AttachDevi|
  00d50	00000000	 DCD         |??_C@_1HK@HGAGGCPB@?$AAU?$AAS?$AAB?$AA?5?$AAs?$AAp?$AAe?$AAc?$AAi?$AAf?$AAi?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAd?$AAo?$AAe?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAw@|
  00d54		 |$LN211@AttachDevi|
  00d54	00000000	 DCD         |__security_cookie|
  00d58		 |$M39315|

			 ENDP  ; |?AttachDevice@CHub@@IAAXEHH@Z|, CHub::AttachDevice

; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T39346| DCD	|$LN17@DisableOff|
	DCD	0x40003802
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DisableOffStreamDevice@CHub@@UAAHIH@Z| PROC ; CHub::DisableOffStreamDevice

; 2736 : {

  00000		 |$LN17@DisableOff|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M39343|
  00008	e1a08002	 mov         r8, r2
  0000c	e1a09001	 mov         r9, r1
  00010	e1a04000	 mov         r4, r0

; 2737 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: +CHub(%s tier %d)::DisableOffStreamDevice - address = %d, pipeIndex = %d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, address, fReset) );
; 2738 :     EnterCriticalSection( &m_csDeviceLock );

  00014	e284000c	 add         r0, r4, #0xC
  00018	eb000000	 bl          EnterCriticalSection

; 2739 :     BOOL fReturn = FALSE;
; 2740 :     for ( UCHAR port = 1; port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  0001c	e5d4706a	 ldrb        r7, [r4, #0x6A]
  00020	e3a06000	 mov         r6, #0
  00024	e3a05001	 mov         r5, #1
  00028	e3570001	 cmp         r7, #1
  0002c	3a000025	 bcc         |$LN14@DisableOff|
  00030	e594e0b0	 ldr         lr, [r4, #0xB0]
  00034		 |$LL6@DisableOff|

; 2741 :         if ( m_ppCDeviceOnPort[ port - 1 ] != NULL &&  m_ppCDeviceOnPort[ port - 1 ]->GetDeviceAddress()==address) {

  00034	e08e0105	 add         r0, lr, r5, lsl #2
  00038	e5103004	 ldr         r3, [r0, #-4]
  0003c	e3530000	 cmp         r3, #0
  00040	0a000002	 beq         |$LN5@DisableOff|
  00044	e5d33020	 ldrb        r3, [r3, #0x20]
  00048	e1530009	 cmp         r3, r9
  0004c	0a000004	 beq         |$LN12@DisableOff|
  00050		 |$LN5@DisableOff|

; 2739 :     BOOL fReturn = FALSE;
; 2740 :     for ( UCHAR port = 1; port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  00050	e2853001	 add         r3, r5, #1
  00054	e20350ff	 and         r5, r3, #0xFF
  00058	e1550007	 cmp         r5, r7
  0005c	9afffff4	 bls         |$LL6@DisableOff|
  00060	ea000018	 b           |$LN14@DisableOff|
  00064		 |$LN12@DisableOff|

; 2742 :             USB_HUB_AND_PORT_STATUS     hubStatus;
; 2743 :             if (GetStatus(port, hubStatus) && hubStatus.status.port.PortConnected) {

  00064	e5943000	 ldr         r3, [r4]
  00068	e28d2000	 add         r2, sp, #0
  0006c	e1a01005	 mov         r1, r5
  00070	e5933058	 ldr         r3, [r3, #0x58]
  00074	e1a00004	 mov         r0, r4
  00078	e1a0e00f	 mov         lr, pc
  0007c	e12fff13	 bx          r3
  00080	e3500000	 cmp         r0, #0
  00084	0a00000e	 beq         |$LN1@DisableOff|
  00088	e1dd30b0	 ldrh        r3, [sp]
  0008c	e3130001	 tst         r3, #1
  00090	0a00000b	 beq         |$LN1@DisableOff|

; 2744 :                 // Hub Status change thread will NOT wake up by Disable Port becuase
; 2745 :                 // DisablePort will NOT generate  hubStatus.change.port.PortEnableChange 
; 2746 :                 // So after DisablePort(port), we have to call AttachDevice Manually
; 2747 :                 DetachDevice(port );

  00094	e1a01005	 mov         r1, r5
  00098	e1a00004	 mov         r0, r4
  0009c	eb000000	 bl          |?DetachDevice@CHub@@IAAXE@Z|

; 2748 :                 if (fReset) 

  000a0	e3580000	 cmp         r8, #0

; 2749 :                     AttachDevice( port, hubStatus.status.port.DeviceIsLowSpeed,hubStatus.status.port.DeviceIsHighSpeed );

  000a4	11dd20b0	 ldrneh      r2, [sp]
  000a8	11a01005	 movne       r1, r5
  000ac	11a00004	 movne       r0, r4
  000b0	11a03a82	 movne       r3, r2, lsl #21
  000b4	11a02b02	 movne       r2, r2, lsl #22
  000b8	11a02fa2	 movne       r2, r2, lsr #31
  000bc	11a03fa3	 movne       r3, r3, lsr #31
  000c0	1b000000	 blne        |?AttachDevice@CHub@@IAAXEHH@Z|
  000c4		 |$LN1@DisableOff|

; 2750 :             }
; 2751 :             fReturn = TRUE;

  000c4	e3a06001	 mov         r6, #1
  000c8		 |$LN14@DisableOff|

; 2752 :             break;
; 2753 :         }
; 2754 :     }
; 2755 :     LeaveCriticalSection( &m_csDeviceLock );    

  000c8	e284000c	 add         r0, r4, #0xC
  000cc	eb000000	 bl          LeaveCriticalSection

; 2756 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: -CHub(%s tier %d)::DisableOffStreamDevice - address = %d, returing HCD_REQUEST_STATUS %d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, address, fReturn) );
; 2757 :     ASSERT(fReturn == TRUE);
; 2758 :     return fReturn;
; 2759 : 
; 2760 : }

  000d0	e1a00006	 mov         r0, r6
  000d4	e28dd004	 add         sp, sp, #4
  000d8	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000dc	e12fff1e	 bx          lr
  000e0		 |$M39344|

			 ENDP  ; |?DisableOffStreamDevice@CHub@@UAAHIH@Z|, CHub::DisableOffStreamDevice


  00000			 AREA	 |.pdata|, PDATA
|$T39360| DCD	|$LN8@scalar@3|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GCRootHub@@UAAPAXI@Z| PROC		; CRootHub::`scalar deleting destructor'
  00000		 |$LN8@scalar@3|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M39357|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	e59f301c	 ldr         r3, [pc, #0x1C]
  00010	e5853000	 str         r3, [r5]
  00014	eb000000	 bl          |??1CHub@@UAA@XZ|
  00018	e3140001	 tst         r4, #1
  0001c	11a00005	 movne       r0, r5
  00020	1b000000	 blne        |??3@YAXPAX@Z|
  00024	e1a00005	 mov         r0, r5
  00028	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$LN9@scalar@3|
  00030		 |$LN10@scalar@3|
  00030	00000000	 DCD         |??_7CRootHub@@6B@|
  00034		 |$M39358|

			 ENDP  ; |??_GCRootHub@@UAAPAXI@Z|, CRootHub::`scalar deleting destructor'


  00000			 AREA	 |.pdata|, PDATA
|$T39376| DCD	|$LN8@scalar@4|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GCExternalHub@@UAAPAXI@Z| PROC	; CExternalHub::`scalar deleting destructor'
  00000		 |$LN8@scalar@4|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M39373|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	e59f301c	 ldr         r3, [pc, #0x1C]
  00010	e5853000	 str         r3, [r5]
  00014	eb000000	 bl          |??1CHub@@UAA@XZ|
  00018	e3140001	 tst         r4, #1
  0001c	11a00005	 movne       r0, r5
  00020	1b000000	 blne        |??3@YAXPAX@Z|
  00024	e1a00005	 mov         r0, r5
  00028	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$LN9@scalar@4|
  00030		 |$LN10@scalar@4|
  00030	00000000	 DCD         |??_7CExternalHub@@6B@|
  00034		 |$M39374|

			 ENDP  ; |??_GCExternalHub@@UAAPAXI@Z|, CExternalHub::`scalar deleting destructor'


  00000			 AREA	 |.pdata|, PDATA
|$T39392| DCD	|$LN8@scalar@5|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GCFunction@@UAAPAXI@Z| PROC	; CFunction::`scalar deleting destructor'
  00000		 |$LN8@scalar@5|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M39389|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	e59f301c	 ldr         r3, [pc, #0x1C]
  00010	e5853000	 str         r3, [r5]
  00014	eb000000	 bl          |??1CDevice@@UAA@XZ|
  00018	e3140001	 tst         r4, #1
  0001c	11a00005	 movne       r0, r5
  00020	1b000000	 blne        |??3@YAXPAX@Z|
  00024	e1a00005	 mov         r0, r5
  00028	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$LN9@scalar@5|
  00030		 |$LN10@scalar@5|
  00030	00000000	 DCD         |??_7CFunction@@6B@|
  00034		 |$M39390|

			 ENDP  ; |??_GCFunction@@UAAPAXI@Z|, CFunction::`scalar deleting destructor'

	EXPORT	|?HubStatusChangeThread@CHub@@AAAKXZ|	; CHub::HubStatusChangeThread
	EXPORT	|??_C@_1HE@EJNPOODG@?$AAC?$AAH?$AAu?$AAb?$AA?3?$AA?3?$AAH?$AAu?$AAb?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AAC?$AAh?$AAa?$AAn?$AAg?$AAe?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?5?$AA?9?$AA?5?$AAd?$AAe@| [ DATA ] ; `string'
	EXPORT	|??_C@_1IM@DCJHGIOD@?$AAC?$AAH?$AAu?$AAb?$AA?$CI?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAH?$AAu?$AAb?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AAC?$AAh?$AAa?$AAn?$AAg?$AAe?$AAT?$AAh@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T39441| DCD	|$LN59@HubStatusC|
	DCD	0x4000f602

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HE@EJNPOODG@?$AAC?$AAH?$AAu?$AAb?$AA?3?$AA?3?$AAH?$AAu?$AAb?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AAC?$AAh?$AAa?$AAn?$AAg?$AAe?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?5?$AA?9?$AA?5?$AAd?$AAe@| DCB "C"
	DCB	0x0, "H", 0x0, "u", 0x0, "b", 0x0, ":", 0x0, ":", 0x0, "H"
	DCB	0x0, "u", 0x0, "b", 0x0, "S", 0x0, "t", 0x0, "a", 0x0, "t"
	DCB	0x0, "u", 0x0, "s", 0x0, "C", 0x0, "h", 0x0, "a", 0x0, "n"
	DCB	0x0, "g", 0x0, "e", 0x0, "T", 0x0, "h", 0x0, "r", 0x0, "e"
	DCB	0x0, "a", 0x0, "d", 0x0, " ", 0x0, "-", 0x0, " ", 0x0, "d"
	DCB	0x0, "e", 0x0, "v", 0x0, "i", 0x0, "c", 0x0, "e", 0x0, " "
	DCB	0x0, "a", 0x0, "t", 0x0, "t", 0x0, "a", 0x0, "c", 0x0, "h"
	DCB	0x0, "e", 0x0, "d", 0x0, " ", 0x0, "o", 0x0, "n", 0x0, " "
	DCB	0x0, "p", 0x0, "o", 0x0, "r", 0x0, "t", 0x0, " ", 0x0, "%"
	DCB	0x0, "d", 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1IM@DCJHGIOD@?$AAC?$AAH?$AAu?$AAb?$AA?$CI?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAH?$AAu?$AAb?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AAC?$AAh?$AAa?$AAn?$AAg?$AAe?$AAT?$AAh@| DCB "C"
	DCB	0x0, "H", 0x0, "u", 0x0, "b", 0x0, "(", 0x0, "t", 0x0, "i"
	DCB	0x0, "e", 0x0, "r", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ")"
	DCB	0x0, ":", 0x0, ":", 0x0, "H", 0x0, "u", 0x0, "b", 0x0, "S"
	DCB	0x0, "t", 0x0, "a", 0x0, "t", 0x0, "u", 0x0, "s", 0x0, "C"
	DCB	0x0, "h", 0x0, "a", 0x0, "n", 0x0, "g", 0x0, "e", 0x0, "T"
	DCB	0x0, "h", 0x0, "r", 0x0, "e", 0x0, "a", 0x0, "d", 0x0, " "
	DCB	0x0, "-", 0x0, " ", 0x0, "a", 0x0, "d", 0x0, "d", 0x0, "r"
	DCB	0x0, " ", 0x0, "%", 0x0, "d", 0x0, " ", 0x0, "p", 0x0, "o"
	DCB	0x0, "r", 0x0, "t", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, " "
	DCB	0x0, "o", 0x0, "v", 0x0, "e", 0x0, "r", 0x0, " ", 0x0, "c"
	DCB	0x0, "u", 0x0, "r", 0x0, "r", 0x0, "e", 0x0, "n", 0x0, "t"
	DCB	0x0, "!", 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HubStatusChangeThread@CHub@@AAAKXZ| PROC ; CHub::HubStatusChangeThread

; 1082 : {

  00000		 |$LN59@HubStatusC|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M39438|
  00008	e1a05000	 mov         r5, r0

; 1083 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("%s: +CHub(%s tier %d)::HubStatusChangeThread\n"),GetControllerName(), GetDeviceType(), m_tierNumber ) );
; 1084 :     DEBUGCHK( m_hHubStatusChangeEvent != NULL && m_hHubStatusChangeThread != NULL );
; 1085 : 
; 1086 :     UCHAR                       port;
; 1087 :     USB_HUB_AND_PORT_STATUS     hubStatus;
; 1088 :     BOOL                        fSuccess = FALSE;
; 1089 : 
; 1090 :     // before we can process port changes, we need
; 1091 :     // to power all ports
; 1092 :     while ( !m_fHubThreadClosing && !fSuccess) {

  0000c	e59530b8	 ldr         r3, [r5, #0xB8]
  00010	e3a00000	 mov         r0, #0
  00014	e3530000	 cmp         r3, #0
  00018	1a00000f	 bne         |$LN27@HubStatusC|
  0001c		 |$LL29@HubStatusC|
  0001c	e3500000	 cmp         r0, #0
  00020	1a000007	 bne         |$LN28@HubStatusC|

; 1093 :         fSuccess = PowerAllHubPorts();

  00024	e5953000	 ldr         r3, [r5]
  00028	e1a00005	 mov         r0, r5
  0002c	e5933048	 ldr         r3, [r3, #0x48]
  00030	e1a0e00f	 mov         lr, pc
  00034	e12fff13	 bx          r3
  00038	e59530b8	 ldr         r3, [r5, #0xB8]
  0003c	e3530000	 cmp         r3, #0
  00040	0afffff5	 beq         |$LL29@HubStatusC|
  00044		 |$LN28@HubStatusC|

; 1094 :     }
; 1095 :     if ( !m_fHubThreadClosing ) {

  00044	e59530b8	 ldr         r3, [r5, #0xB8]
  00048	e3530000	 cmp         r3, #0

; 1096 : #if 0
; 1097 :         Sleep( 2 * m_usbHubDescriptor.bPowerOnToPowerGood );
; 1098 : #else
; 1099 :         // According to the USB spec 1.1, section 7.1.7.1, there
; 1100 :         // is supposed to be a delay of up to 100ms (t2) before the device
; 1101 :         // can signal attach. I don't know if the software is
; 1102 :         // supposed to implement this delay. No harm in implementing
; 1103 :         // it though.
; 1104 :         Sleep( 100 + 2 * m_usbHubDescriptor.bPowerOnToPowerGood );

  0004c	05d5306d	 ldreqb      r3, [r5, #0x6D]
  00050	02833032	 addeq       r3, r3, #0x32
  00054	01a00083	 moveq       r0, r3, lsl #1
  00058	0b000000	 bleq        Sleep
  0005c		 |$LN27@HubStatusC|

; 1105 : #endif
; 1106 :     }
; 1107 :     SetOrClearRemoteWakup(TRUE);

  0005c	e5953000	 ldr         r3, [r5]
  00060	e3a01001	 mov         r1, #1
  00064	e1a00005	 mov         r0, r5
  00068	e5933054	 ldr         r3, [r3, #0x54]
  0006c	e1a0e00f	 mov         lr, pc
  00070	e12fff13	 bx          r3

; 1108 :     while ( !m_fHubThreadClosing ) {

  00074	e59530b8	 ldr         r3, [r5, #0xB8]
  00078	e3530000	 cmp         r3, #0
  0007c	1a0000cf	 bne         |$LN56@HubStatusC|
  00080	e3a03cff	 mov         r3, #0xFF, 24
  00084	e38370fe	 orr         r7, r3, #0xFE
  00088		 |$LL26@HubStatusC|

; 1109 :         
; 1110 :         fSuccess = (WaitForSingleObject(m_hHubSuspendBlockEvent,INFINITE) == WAIT_OBJECT_0);

  00088	e59500c4	 ldr         r0, [r5, #0xC4]
  0008c	e3e01000	 mvn         r1, #0
  00090	eb000000	 bl          WaitForSingleObject

; 1111 :         if (m_fHubThreadClosing || !fSuccess)

  00094	e59530b8	 ldr         r3, [r5, #0xB8]
  00098	e3500000	 cmp         r0, #0
  0009c	03a02001	 moveq       r2, #1
  000a0	13a02000	 movne       r2, #0
  000a4	e3530000	 cmp         r3, #0
  000a8	1a0000c4	 bne         |$LN56@HubStatusC|
  000ac	e3520000	 cmp         r2, #0
  000b0	0a0000c2	 beq         |$LN56@HubStatusC|

; 1112 :             break;
; 1113 :         
; 1114 :         fSuccess = WaitForPortStatusChange( port, hubStatus );

  000b4	e5953000	 ldr         r3, [r5]
  000b8	e28d2004	 add         r2, sp, #4
  000bc	e28d1000	 add         r1, sp, #0
  000c0	e593304c	 ldr         r3, [r3, #0x4C]
  000c4	e1a00005	 mov         r0, r5
  000c8	e1a0e00f	 mov         lr, pc
  000cc	e12fff13	 bx          r3

; 1115 :         if ( m_fHubThreadClosing || !fSuccess ) {

  000d0	e59530b8	 ldr         r3, [r5, #0xB8]
  000d4	e3530000	 cmp         r3, #0
  000d8	1a0000b8	 bne         |$LN56@HubStatusC|
  000dc	e3500000	 cmp         r0, #0
  000e0	0a0000b3	 beq         |$LN1@HubStatusC|

; 1116 :                 DEBUGMSG( ZONE_ERROR && !m_fHubThreadClosing, (TEXT("%s: CHub(%s tier %d)::HubStatusChangeThread - error reading port status change\n"),GetControllerName(), GetDeviceType(), m_tierNumber ));
; 1117 :             continue; // loop will exit if m_fHubThreadClosing is set
; 1118 :         }
; 1119 :         if ( port == 0 ) { // Port 0 indicate this is hub status.

  000e4	e5dd0000	 ldrb        r0, [sp]
  000e8	e3500000	 cmp         r0, #0
  000ec	1a00000b	 bne         |$LN20@HubStatusC|

; 1120 :             if (hubStatus.change.hub.OverCurrentIndicatorChange ) {

  000f0	e1dd30b6	 ldrh        r3, [sp, #6]
  000f4	e3130002	 tst         r3, #2
  000f8	0a0000ad	 beq         |$LN1@HubStatusC|

; 1121 :                 if ( hubStatus.status.hub.OverCurrentIndicator ) {

  000fc	e1dd30b4	 ldrh        r3, [sp, #4]
  00100	e3130002	 tst         r3, #2
  00104	0a0000aa	 beq         |$LN1@HubStatusC|

; 1122 :                     RETAILMSG(1, (TEXT("CHub(tier %d)::HubStatusChangeThread - addr %d port %d over current!\n"),
; 1123 :                                   m_tierNumber, m_address, port));

  00108	e5d52020	 ldrb        r2, [r5, #0x20]
  0010c	e5d5104c	 ldrb        r1, [r5, #0x4C]
  00110	e1a03000	 mov         r3, r0
  00114	e59f02b8	 ldr         r0, [pc, #0x2B8]
  00118	eb000000	 bl          NKDbgPrintfW

; 1124 :                 } else {
; 1125 :                     // hub is no longer over current - re-enumerate all ports
; 1126 :                     // Could re-enumerate all hub ports during hub over-current recovery...
; 1127 :                 }
; 1128 :             }
; 1129 :             continue;

  0011c	ea0000a4	 b           |$LN1@HubStatusC|
  00120		 |$LN20@HubStatusC|

; 1130 :         }
; 1131 : 
; 1132 :         // we will get here if the status of port # "port" has changed.
; 1133 :         // the status information will be in "hubStatus"
; 1134 :         DEBUGCHK( port <= m_usbHubDescriptor.bNumberOfPorts );
; 1135 :         DEBUGMSG( ZONE_ATTACH, (TEXT("%s: CHub(%s tier %d)::HubStatusChangeThread - port %d, change = 0x%04x, status = 0x%04x\n"),GetControllerName(), GetDeviceType(), m_tierNumber, port, hubStatus.change.word, hubStatus.status.word ) );
; 1136 : 
; 1137 :         if (hubStatus.change.port.OverCurrentChange ) {

  00120	e1dd20b6	 ldrh        r2, [sp, #6]
  00124	e1a03802	 mov         r3, r2, lsl #16
  00128	e1a03823	 mov         r3, r3, lsr #16
  0012c	e3130008	 tst         r3, #8
  00130	0a000015	 beq         |$LN14@HubStatusC|

; 1138 :             if ( hubStatus.status.port.PortOverCurrent ) {

  00134	e1dd30b4	 ldrh        r3, [sp, #4]
  00138	e3130008	 tst         r3, #8
  0013c	0a000010	 beq         |$LN15@HubStatusC|

; 1139 :                 RETAILMSG(1, (TEXT("CHub(tier %d)::HubStatusChangeThread - addr %d port %d over current!\n"),
; 1140 :                               m_tierNumber, m_address, port));

  00140	e5d52020	 ldrb        r2, [r5, #0x20]
  00144	e5d5104c	 ldrb        r1, [r5, #0x4C]
  00148	e1a03000	 mov         r3, r0
  0014c	e59f0280	 ldr         r0, [pc, #0x280]
  00150	eb000000	 bl          NKDbgPrintfW

; 1141 :                 DetachDevice( port );

  00154	e5dd1000	 ldrb        r1, [sp]
  00158	e1a00005	 mov         r0, r5
  0015c	eb000000	 bl          |?DetachDevice@CHub@@IAAXE@Z|

; 1142 : #if 1   // the "correct" thing to do, according to my reading of the USB spec
; 1143 :                 SetOrClearFeature( port, USB_REQUEST_CLEAR_FEATURE, USB_HUB_FEATURE_PORT_POWER );

  00160	e5952000	 ldr         r2, [r5]
  00164	e5dd1000	 ldrb        r1, [sp]
  00168	e3a03008	 mov         r3, #8
  0016c	e5924050	 ldr         r4, [r2, #0x50]
  00170	e3a02001	 mov         r2, #1
  00174	e1a00005	 mov         r0, r5
  00178	e1a0e00f	 mov         lr, pc
  0017c	e12fff14	 bx          r4

; 1144 : #else   // another approach
; 1145 :                 do {
; 1146 :                     Sleep( 500 );
; 1147 :                     GetStatus( port, hubStatus );
; 1148 :                 } while (hubStatus.status.port.PortOverCurrent && !m_fHubThreadClosing);
; 1149 :                 hubStatus.change.port.ConnectStatusChange = 1;
; 1150 : #endif
; 1151 :             } else {

  00180	ea000001	 b           |$LN14@HubStatusC|
  00184		 |$LN15@HubStatusC|

; 1152 :                 // port is no longer over current - pretend this is a normal attach
; 1153 :                 // simulate a connect status change. this has the undesirable but basically harmless
; 1154 :                 // side effect of wasting 100 ms to needlessly debounce the power rail.
; 1155 :                 hubStatus.change.port.ConnectStatusChange = 1;

  00184	e3823001	 orr         r3, r2, #1
  00188	e1cd30b6	 strh        r3, [sp, #6]
  0018c		 |$LN14@HubStatusC|

; 1156 :             }
; 1157 :         }
; 1158 :         // Resume Notification.
; 1159 :         EnterCriticalSection( &m_csDeviceLock );

  0018c	e285000c	 add         r0, r5, #0xC
  00190	eb000000	 bl          EnterCriticalSection

; 1160 :         if ( hubStatus.change.port.SuspendChange && !hubStatus.status.port.PortSuspended  && 
; 1161 :                 m_ppCDeviceOnPort[port-1]!=NULL ) {

  00194	e1dd30b6	 ldrh        r3, [sp, #6]
  00198	e3130004	 tst         r3, #4
  0019c	0a00000e	 beq         |$LN13@HubStatusC|
  001a0	e1dd30b4	 ldrh        r3, [sp, #4]
  001a4	e3130004	 tst         r3, #4
  001a8	1a00000b	 bne         |$LN13@HubStatusC|
  001ac	e5dd2000	 ldrb        r2, [sp]
  001b0	e59530b0	 ldr         r3, [r5, #0xB0]
  001b4	e0833102	 add         r3, r3, r2, lsl #2
  001b8	e5133004	 ldr         r3, [r3, #-4]
  001bc	e3530000	 cmp         r3, #0

; 1162 :             m_ppCDeviceOnPort[port-1]->ResumeNotification();

  001c0	159530b0	 ldrne       r3, [r5, #0xB0]
  001c4	10833102	 addne       r3, r3, r2, lsl #2
  001c8	15130004	 ldrne       r0, [r3, #-4]
  001cc	15903000	 ldrne       r3, [r0]
  001d0	15933028	 ldrne       r3, [r3, #0x28]
  001d4	11a0e00f	 movne       lr, pc
  001d8	112fff13	 bxne        r3
  001dc		 |$LN13@HubStatusC|

; 1163 :         }
; 1164 :         LeaveCriticalSection( &m_csDeviceLock );

  001dc	e285000c	 add         r0, r5, #0xC
  001e0	eb000000	 bl          LeaveCriticalSection

; 1165 :         if ( hubStatus.change.port.PortEnableChange &&
; 1166 :              !hubStatus.status.port.PortEnabled &&
; 1167 :              hubStatus.status.port.PortConnected ) {

  001e4	e1dd20b6	 ldrh        r2, [sp, #6]
  001e8	e3120002	 tst         r2, #2
  001ec	0a00001b	 beq         |$LN11@HubStatusC|
  001f0	e1dd10b4	 ldrh        r1, [sp, #4]
  001f4	e1a03801	 mov         r3, r1, lsl #16
  001f8	e1a03823	 mov         r3, r3, lsr #16
  001fc	e3130002	 tst         r3, #2
  00200	1a000016	 bne         |$LN11@HubStatusC|
  00204	e3110001	 tst         r1, #1
  00208	0a000014	 beq         |$LN11@HubStatusC|

; 1168 :             // Connected device has become disabled. If the device was
; 1169 :             // already successfully attached, let's try detach/reattach.
; 1170 :             // It is important to check that the device was successfully
; 1171 :             // attached - otherwise, we can get into an infinite loop
; 1172 :             // of try attach, fail, disable port, retry attach.
; 1173 :             BOOL fDeviceIsPresent;
; 1174 : 
; 1175 :             EnterCriticalSection( &m_csDeviceLock );

  0020c	e285000c	 add         r0, r5, #0xC
  00210	eb000000	 bl          EnterCriticalSection

; 1176 :             DEBUGCHK( m_ppCDeviceOnPort != NULL );
; 1177 :             fDeviceIsPresent = ( m_ppCDeviceOnPort[ port - 1 ] != NULL );

  00214	e59520b0	 ldr         r2, [r5, #0xB0]
  00218	e5dd3000	 ldrb        r3, [sp]

; 1178 :             LeaveCriticalSection( &m_csDeviceLock );

  0021c	e285000c	 add         r0, r5, #0xC
  00220	e0823103	 add         r3, r2, r3, lsl #2
  00224	e5133004	 ldr         r3, [r3, #-4]
  00228	e3530000	 cmp         r3, #0
  0022c	13a04001	 movne       r4, #1
  00230	03a04000	 moveq       r4, #0
  00234	eb000000	 bl          LeaveCriticalSection

; 1179 : 
; 1180 :             if ( fDeviceIsPresent ) {

  00238	e3540000	 cmp         r4, #0
  0023c	0a000006	 beq         |$LN55@HubStatusC|

; 1181 :                 DEBUGMSG( ZONE_WARNING, (TEXT("%s: CHub(%s tier %d)::HubStatusChangeThread - device on port %d is connected but has been disabled. Trying to detach & re-attach\n"),GetControllerName(), GetDeviceType(), m_tierNumber, port) );
; 1182 :                 DetachDevice( port );

  00240	e5dd1000	 ldrb        r1, [sp]
  00244	e1a00005	 mov         r0, r5
  00248	eb000000	 bl          |?DetachDevice@CHub@@IAAXE@Z|

; 1183 :                 // this will cause device attach below, since
; 1184 :                 // hubStatus.status.port.PortConnected is already set
; 1185 :                 hubStatus.change.port.ConnectStatusChange = 1;

  0024c	e1dd30b6	 ldrh        r3, [sp, #6]
  00250	e3832001	 orr         r2, r3, #1
  00254	e1cd20b6	 strh        r2, [sp, #6]
  00258	ea000000	 b           |$LN11@HubStatusC|
  0025c		 |$LN55@HubStatusC|
  0025c	e1dd20b6	 ldrh        r2, [sp, #6]
  00260		 |$LN11@HubStatusC|

; 1186 :                 DEBUGCHK( hubStatus.status.port.PortConnected );
; 1187 :             }
; 1188 :         } // we can ignore all other enabled changes
; 1189 : 
; 1190 :         // now check for connect changes
; 1191 :         if ( hubStatus.change.port.ConnectStatusChange ) {

  00260	e3120001	 tst         r2, #1
  00264	0a000052	 beq         |$LN1@HubStatusC|

; 1192 :             EnterCriticalSection( &m_csDeviceLock );

  00268	e285000c	 add         r0, r5, #0xC
  0026c	eb000000	 bl          EnterCriticalSection

; 1193 :             BOOL fDeviceAlreadyExists = (m_ppCDeviceOnPort[ port - 1 ] != NULL);

  00270	e59520b0	 ldr         r2, [r5, #0xB0]
  00274	e5dd3000	 ldrb        r3, [sp]

; 1194 :             LeaveCriticalSection( &m_csDeviceLock );

  00278	e285000c	 add         r0, r5, #0xC
  0027c	e0823103	 add         r3, r2, r3, lsl #2
  00280	e5133004	 ldr         r3, [r3, #-4]
  00284	e3530000	 cmp         r3, #0
  00288	13a04001	 movne       r4, #1
  0028c	03a04000	 moveq       r4, #0
  00290	eb000000	 bl          LeaveCriticalSection

; 1195 : 
; 1196 :             // we got a connect status change notification on this port, so...
; 1197 :             if (fDeviceAlreadyExists) {

  00294	e3540000	 cmp         r4, #0

; 1198 :                 // ... a change when the device is already here must be a detach;
; 1199 :                 //     if there's still something connected then it must be new.
; 1200 :                 DEBUGMSG( ZONE_ATTACH, (TEXT("%s: CHub(%s tier %d)::HubStatusChangeThread - device detached on port %d\n"),GetControllerName(), GetDeviceType(), m_tierNumber, port ) );
; 1201 :                 DetachDevice(port);

  00298	15dd1000	 ldrneb      r1, [sp]
  0029c	11a00005	 movne       r0, r5
  002a0	1b000000	 blne        |?DetachDevice@CHub@@IAAXE@Z|

; 1202 : #ifdef DEBUG
; 1203 :                 if ( hubStatus.status.port.PortConnected ) {
; 1204 :                     DEBUGMSG( (ZONE_WARNING && ZONE_VERBOSE) || ZONE_ATTACH,
; 1205 :                               (TEXT("CHub(%s tier %d)::HubStatusChangeThread -")
; 1206 :                                TEXT(" quick detach and re-attach on port %d\n"),
; 1207 :                                GetDeviceType(), m_tierNumber, port) );
; 1208 :                 }
; 1209 : #endif // DEBUG
; 1210 :             }
; 1211 :             // ... a change with no device present must be an attach
; 1212 :             //     but section 7.1.7.1 of the USB 1.1 spec says we're
; 1213 :             //     responsible for de-bouncing the attach signalling.
; 1214 :             //
; 1215 :             // we do the de-bouncing by waiting until a 100 ms interval
; 1216 :             // (t3 on figure 7-19 in the spec) elapses with no connection
; 1217 :             // status change on the port. Then we can examine the current
; 1218 :             // connect status reliably.
; 1219 :             BOOL fPoll = TRUE;

  002a4	e3a06001	 mov         r6, #1
  002a8		 |$LL8@HubStatusC|

; 1222 :                 USB_HUB_AND_PORT_STATUS hubStatus2;
; 1223 :                 Sleep( 100 );

  002a8	e3a00064	 mov         r0, #0x64
  002ac	eb000000	 bl          Sleep

; 1224 :                 if ( GetStatus( port, hubStatus2 ) == FALSE ) {

  002b0	e5953000	 ldr         r3, [r5]
  002b4	e5dd1000	 ldrb        r1, [sp]
  002b8	e28d2008	 add         r2, sp, #8
  002bc	e5933058	 ldr         r3, [r3, #0x58]
  002c0	e1a00005	 mov         r0, r5
  002c4	e1a0e00f	 mov         lr, pc
  002c8	e12fff13	 bx          r3
  002cc	e3500000	 cmp         r0, #0
  002d0	0a000012	 beq         |$LN54@HubStatusC|

; 1227 :                     fPoll = FALSE;
; 1228 :                 }
; 1229 :                 else if ( hubStatus2.change.port.ConnectStatusChange ) {

  002d4	e1dd30ba	 ldrh        r3, [sp, #0xA]
  002d8	e3130001	 tst         r3, #1
  002dc	0a000009	 beq         |$LN4@HubStatusC|

; 1230 :                     // ack the status change and wait again
; 1231 :                     SetOrClearFeature( port, USB_REQUEST_CLEAR_FEATURE,
; 1232 :                                        USB_HUB_FEATURE_C_PORT_CONNECTION );

  002e0	e5952000	 ldr         r2, [r5]
  002e4	e5dd1000	 ldrb        r1, [sp]
  002e8	e3a03010	 mov         r3, #0x10
  002ec	e5924050	 ldr         r4, [r2, #0x50]
  002f0	e3a02001	 mov         r2, #1
  002f4	e1a00005	 mov         r0, r5
  002f8	e1a0e00f	 mov         lr, pc
  002fc	e12fff14	 bx          r4

; 1233 :                 }
; 1234 :                 else {

  00300	e1dd30b4	 ldrh        r3, [sp, #4]
  00304	ea000002	 b           |$LN3@HubStatusC|
  00308		 |$LN4@HubStatusC|

; 1235 :                     // ah, stability.
; 1236 :                     hubStatus.status.word = hubStatus2.status.word;

  00308	e1dd30b8	 ldrh        r3, [sp, #8]

; 1237 :                     fPoll = FALSE;

  0030c	e3a06000	 mov         r6, #0
  00310	e1cd30b4	 strh        r3, [sp, #4]
  00314		 |$LN3@HubStatusC|

; 1220 : 
; 1221 :             while (fPoll) {

  00314	e3560000	 cmp         r6, #0
  00318	1affffe2	 bne         |$LL8@HubStatusC|
  0031c	ea000002	 b           |$LN53@HubStatusC|
  00320		 |$LN54@HubStatusC|

; 1225 :                     // failed to get status; probably power-cycle or upper-level detach
; 1226 :                     hubStatus.status.port.PortConnected = FALSE;

  00320	e1dd30b4	 ldrh        r3, [sp, #4]
  00324	e0033007	 and         r3, r3, r7
  00328	e1cd30b4	 strh        r3, [sp, #4]
  0032c		 |$LN53@HubStatusC|

; 1238 :                 }
; 1239 :             }
; 1240 :             // We have to reset port and get speed infomation.
; 1241 :             DEBUGMSG(ZONE_ATTACH, (TEXT("CHub::ResetAndEnablePort\r\n")));
; 1242 :             if(hubStatus.status.port.PortConnected)

  0032c	e3130001	 tst         r3, #1
  00330	0a00001f	 beq         |$LN1@HubStatusC|

; 1243 :             {
; 1244 :                 ResetAndEnablePort( port );

  00334	e5953000	 ldr         r3, [r5]
  00338	e5dd1000	 ldrb        r1, [sp]
  0033c	e1a00005	 mov         r0, r5
  00340	e593305c	 ldr         r3, [r3, #0x5C]
  00344	e1a0e00f	 mov         lr, pc
  00348	e12fff13	 bx          r3

; 1245 :                 Sleep(20);

  0034c	e3a00014	 mov         r0, #0x14
  00350	eb000000	 bl          Sleep

; 1246 :                 GetStatus(port , hubStatus);

  00354	e5953000	 ldr         r3, [r5]
  00358	e5dd1000	 ldrb        r1, [sp]
  0035c	e28d2004	 add         r2, sp, #4
  00360	e5933058	 ldr         r3, [r3, #0x58]
  00364	e1a00005	 mov         r0, r5
  00368	e1a0e00f	 mov         lr, pc
  0036c	e12fff13	 bx          r3

; 1247 :                 if ( hubStatus.status.port.PortConnected ) {

  00370	e1dd30b4	 ldrh        r3, [sp, #4]
  00374	e3130001	 tst         r3, #1
  00378	0a00000d	 beq         |$LN1@HubStatusC|

; 1248 :                     // device attach
; 1249 :                     RETAILMSG( 1, (TEXT("CHub::HubStatusChangeThread - device attached on port %d\n"), port ) );

  0037c	e5dd1000	 ldrb        r1, [sp]
  00380	e59f0048	 ldr         r0, [pc, #0x48]
  00384	eb000000	 bl          NKDbgPrintfW

; 1250 :                     AttachDevice( port,
; 1251 :                                   hubStatus.status.port.DeviceIsLowSpeed,
; 1252 :                                   m_fIsHighSpeed?hubStatus.status.port.DeviceIsHighSpeed:FALSE );

  00388	e5953048	 ldr         r3, [r5, #0x48]
  0038c	e1dd20b4	 ldrh        r2, [sp, #4]
  00390	e5dd1000	 ldrb        r1, [sp]
  00394	e3530000	 cmp         r3, #0
  00398	11a03a82	 movne       r3, r2, lsl #21
  0039c	e1a02b02	 mov         r2, r2, lsl #22
  003a0	11a03fa3	 movne       r3, r3, lsr #31
  003a4	03a03000	 moveq       r3, #0
  003a8	e1a02fa2	 mov         r2, r2, lsr #31
  003ac	e1a00005	 mov         r0, r5
  003b0	eb000000	 bl          |?AttachDevice@CHub@@IAAXEHH@Z|
  003b4		 |$LN1@HubStatusC|
  003b4	e59530b8	 ldr         r3, [r5, #0xB8]
  003b8	e3530000	 cmp         r3, #0
  003bc	0affff31	 beq         |$LL26@HubStatusC|
  003c0		 |$LN56@HubStatusC|

; 1253 :                 }
; 1254 :             }
; 1255 :         } // end of ConnectStatusChange processing
; 1256 :     }
; 1257 :     DEBUGMSG( ZONE_HUB, (TEXT("%s: -CHub(%s tier %d)::HubStatusChangeThread, THREAD EXITING, returning 0\n"),GetControllerName(), GetDeviceType(), m_tierNumber ) );
; 1258 :     return 0;

  003c0	e3a00000	 mov         r0, #0

; 1259 : }

  003c4	e28dd00c	 add         sp, sp, #0xC
  003c8	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  003cc	e12fff1e	 bx          lr
  003d0		 |$LN60@HubStatusC|
  003d0		 |$LN61@HubStatusC|
  003d0	00000000	 DCD         |??_C@_1HE@EJNPOODG@?$AAC?$AAH?$AAu?$AAb?$AA?3?$AA?3?$AAH?$AAu?$AAb?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AAC?$AAh?$AAa?$AAn?$AAg?$AAe?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?5?$AA?9?$AA?5?$AAd?$AAe@|
  003d4		 |$LN62@HubStatusC|
  003d4	00000000	 DCD         |??_C@_1IM@DCJHGIOD@?$AAC?$AAH?$AAu?$AAb?$AA?$CI?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAH?$AAu?$AAb?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AAC?$AAh?$AAa?$AAn?$AAg?$AAe?$AAT?$AAh@|
  003d8		 |$M39439|

			 ENDP  ; |?HubStatusChangeThread@CHub@@AAAKXZ|, CHub::HubStatusChangeThread

	EXPORT	|?HubStatusChangeThreadStub@CHub@@KAKPAX@Z| ; CHub::HubStatusChangeThreadStub

  00000			 AREA	 |.pdata|, PDATA
|$T39454| DCD	|$LN5@HubStatusC@2|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HubStatusChangeThreadStub@CHub@@KAKPAX@Z| PROC ; CHub::HubStatusChangeThreadStub

; 1068 : {

  00000		 |$LN5@HubStatusC@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M39451|

; 1069 :     return ((CHub*)context)->HubStatusChangeThread();

  00004	eb000000	 bl          |?HubStatusChangeThread@CHub@@AAAKXZ|

; 1070 : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M39452|

			 ENDP  ; |?HubStatusChangeThreadStub@CHub@@KAKPAX@Z|, CHub::HubStatusChangeThreadStub


  00000			 AREA	 |.pdata|, PDATA
|$T39466| DCD	|$LN10@EnterOpera@2|
	DCD	0x40003102
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?EnterOperationalState@CRootHub@@UAAHQAVCPipeAbs@@@Z| PROC ; CRootHub::EnterOperationalState

; 2842 : {

  00000		 |$LN10@EnterOpera@2|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M39463|
  00008	e1a04000	 mov         r4, r0

; 2843 :     DEBUGMSG( ZONE_HUB, (TEXT("%s: +CRootHub::EnterOperationalState\n"),GetControllerName()) );
; 2844 : 
; 2845 :     BOOL fSuccess = FALSE;
; 2846 : 
; 2847 :     EnterCriticalSection( &m_csDeviceLock );

  0000c	e284000c	 add         r0, r4, #0xC
  00010	e3a05000	 mov         r5, #0
  00014	eb000000	 bl          EnterCriticalSection

; 2848 : 
; 2849 :     // don't need to allocate a Pipe array for Root Hubs
; 2850 :     DEBUGCHK( m_address == 0 &&
; 2851 :               m_maxNumPipes == 0 &&
; 2852 :               m_ppCPipe == NULL &&
; 2853 :               pEndpoint0Pipe == NULL &&
; 2854 :               m_deviceInfo.Descriptor.bDeviceClass == USB_DEVICE_CLASS_HUB &&
; 2855 :               m_deviceInfo.Descriptor.bNumConfigurations == 0 &&
; 2856 :               m_deviceInfo.lpActiveConfig == NULL &&
; 2857 :               m_deviceInfo.lpConfigs == NULL );
; 2858 : 
; 2859 :     DEBUGCHK( m_hHubStatusChangeEvent == NULL && m_hHubStatusChangeThread == NULL );
; 2860 : 
; 2861 :     // m_hHubStatusChangeEvent - Auto Reset, and Initial State = non-signaled
; 2862 :     m_hHubStatusChangeEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

  00018	e3a03000	 mov         r3, #0
  0001c	e3a02000	 mov         r2, #0
  00020	e3a01000	 mov         r1, #0
  00024	e3a00000	 mov         r0, #0
  00028	eb000000	 bl          CreateEventW
  0002c	e3500000	 cmp         r0, #0
  00030	e58400bc	 str         r0, [r4, #0xBC]

; 2863 : 
; 2864 :     if ( m_hHubStatusChangeEvent != NULL &&
; 2865 :          AllocateDeviceArray() ) {

  00034	0a00001a	 beq         |$LN1@EnterOpera@2|
  00038	e1a00004	 mov         r0, r4
  0003c	eb000000	 bl          |?AllocateDeviceArray@CHub@@IAAHXZ|
  00040	e3500000	 cmp         r0, #0
  00044	e3a06000	 mov         r6, #0
  00048	0a00000f	 beq         |$LN7@EnterOpera@2|

; 2866 : 
; 2867 :         m_hHubStatusChangeThread = CreateThread( 0, 0, HubStatusChangeThreadStub, this, 0, NULL );

  0004c	e59f206c	 ldr         r2, [pc, #0x6C]
  00050	e1a03004	 mov         r3, r4
  00054	e3a01000	 mov         r1, #0
  00058	e3a00000	 mov         r0, #0
  0005c	e58d6004	 str         r6, [sp, #4]
  00060	e58d6000	 str         r6, [sp]
  00064	eb000000	 bl          CreateThread
  00068	e3500000	 cmp         r0, #0
  0006c	e58400c0	 str         r0, [r4, #0xC0]

; 2868 :         if ( m_hHubStatusChangeThread != NULL ) {

  00070	0a000005	 beq         |$LN7@EnterOpera@2|

; 2869 :             CeSetThreadPriority( m_hHubStatusChangeThread, g_IstThreadPriority + RELATIVE_PRIO_STSCHG);

  00074	e59f3040	 ldr         r3, [pc, #0x40]
  00078	e5933000	 ldr         r3, [r3]
  0007c	e2831005	 add         r1, r3, #5
  00080	eb000000	 bl          CeSetThreadPriority

; 2870 :             fSuccess = TRUE;

  00084	e3a05001	 mov         r5, #1

; 2871 :         }
; 2872 :     }
; 2873 :     if ( !fSuccess ) {

  00088	ea000005	 b           |$LN1@EnterOpera@2|
  0008c		 |$LN7@EnterOpera@2|

; 2874 :         // m_ppCDeviceOnPort will be freed in ~CHub if needed
; 2875 : 
; 2876 :         if ( m_hHubStatusChangeEvent ) {

  0008c	e59430bc	 ldr         r3, [r4, #0xBC]
  00090	e3530000	 cmp         r3, #0
  00094	0a000002	 beq         |$LN1@EnterOpera@2|

; 2877 :             CloseHandle( m_hHubStatusChangeEvent );

  00098	e1a00003	 mov         r0, r3
  0009c	eb000000	 bl          CloseHandle

; 2878 :             m_hHubStatusChangeEvent = NULL;

  000a0	e58460bc	 str         r6, [r4, #0xBC]
  000a4		 |$LN1@EnterOpera@2|

; 2879 :         }
; 2880 :         DEBUGCHK( m_hHubStatusChangeThread == NULL );
; 2881 :     }
; 2882 : 
; 2883 :     LeaveCriticalSection( &m_csDeviceLock );

  000a4	e284000c	 add         r0, r4, #0xC
  000a8	eb000000	 bl          LeaveCriticalSection

; 2884 : 
; 2885 :     DEBUGMSG( ZONE_HUB, (TEXT("%s: -CRootHub::EnterOperationalState, returning BOOL %d\n"),GetControllerName(), fSuccess) );
; 2886 :     return fSuccess;
; 2887 : }

  000ac	e1a00005	 mov         r0, r5
  000b0	e28dd008	 add         sp, sp, #8
  000b4	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000b8	e12fff1e	 bx          lr
  000bc		 |$LN11@EnterOpera@2|
  000bc		 |$LN12@EnterOpera@2|
  000bc	00000000	 DCD         |g_IstThreadPriority|
  000c0		 |$LN13@EnterOpera@2|
  000c0	00000000	 DCD         |?HubStatusChangeThreadStub@CHub@@KAKPAX@Z|
  000c4		 |$M39464|

			 ENDP  ; |?EnterOperationalState@CRootHub@@UAAHQAVCPipeAbs@@@Z|, CRootHub::EnterOperationalState


  00000			 AREA	 |.pdata|, PDATA
|$T39487| DCD	|$LN13@EnterOpera@3|
	DCD	0x40007a02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?EnterOperationalState@CExternalHub@@UAAHQAVCPipeAbs@@@Z| PROC ; CExternalHub::EnterOperationalState

; 3172 : {

  00000		 |$LN13@EnterOpera@3|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M39484|
  00008	e1a09001	 mov         r9, r1
  0000c	e1a07000	 mov         r7, r0

; 3173 :     DEBUGMSG( ZONE_HUB, (TEXT("%s: +CExternalHub::EnterOperationalState\n"),GetControllerName()) );
; 3174 : 
; 3175 :     BOOL fSuccess = FALSE;
; 3176 : 
; 3177 :     EnterCriticalSection( &m_csDeviceLock );

  00010	e287000c	 add         r0, r7, #0xC
  00014	e3a08000	 mov         r8, #0
  00018	eb000000	 bl          EnterCriticalSection

; 3178 : 
; 3179 :     DEBUGCHK( m_address > 0 &&
; 3180 :               m_address <= USB_MAX_ADDRESS &&
; 3181 :               m_maxNumPipes == 0 && // not yet allocated
; 3182 :               m_ppCPipe == NULL && // not yet allocated
; 3183 :               pEndpoint0Pipe != NULL && // should be passed in non NULL by caller
; 3184 :               m_deviceInfo.Descriptor.bDeviceClass == USB_DEVICE_CLASS_HUB );
; 3185 : 
; 3186 :     DEBUGCHK( m_hHubStatusChangeEvent == NULL );
; 3187 :     // m_hHubStatusChangeEvent - Auto Reset, and Initial State = non-signaled
; 3188 :     m_hHubStatusChangeEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

  0001c	e3a03000	 mov         r3, #0
  00020	e3a02000	 mov         r2, #0
  00024	e3a01000	 mov         r1, #0
  00028	e3a00000	 mov         r0, #0
  0002c	eb000000	 bl          CreateEventW

; 3189 : 
; 3190 :     #ifdef DEBUG
; 3191 :     {
; 3192 : 
; 3193 : #ifndef USB_STRICT_ENFORCEMENT
; 3194 :         // The correct settings are listed in the 1.1 USB spec at section 11.15.1.
; 3195 :         // I have found at least one hub (builtin on the Clarion CDC) that does this wrong.
; 3196 :         if (!m_fIsHighSpeed)
; 3197 :             m_deviceInfo.lpActiveConfig->lpInterfaces[0].lpEndpoints[0].Descriptor.bInterval = 0xff;
; 3198 : #endif
; 3199 :         // check for status change endpoint descriptor
; 3200 :         const USB_ENDPOINT_DESCRIPTOR& rED = m_deviceInfo.lpActiveConfig->lpInterfaces[0].lpEndpoints[0].Descriptor;
; 3201 :         DEBUGCHK( rED.bDescriptorType == USB_ENDPOINT_DESCRIPTOR_TYPE &&
; 3202 :                   (rED.bEndpointAddress & 0xf) > 0 &&
; 3203 :                   (rED.bInterval == 0xff || m_fIsHighSpeed) &&
; 3204 :                   (rED.bmAttributes & USB_ENDPOINT_TYPE_MASK) == USB_ENDPOINT_TYPE_INTERRUPT );
; 3205 :     }
; 3206 :     #endif // DEBUG
; 3207 :     UCHAR uTTAddress=0;
; 3208 :     UCHAR uTTPort=0;
; 3209 :     BOOL ttContext = NULL;
; 3210 :     GetUSB2TT(uTTAddress, uTTPort, ttContext);

  00030	e5973000	 ldr         r3, [r7]
  00034	e1a04000	 mov         r4, r0
  00038	e3a0b000	 mov         r11, #0
  0003c	e5935034	 ldr         r5, [r3, #0x34]
  00040	e3a06000	 mov         r6, #0
  00044	e3a0a000	 mov         r10, #0
  00048	e28d3014	 add         r3, sp, #0x14
  0004c	e28d2010	 add         r2, sp, #0x10
  00050	e28d1011	 add         r1, sp, #0x11
  00054	e1a00007	 mov         r0, r7
  00058	e58740bc	 str         r4, [r7, #0xBC]
  0005c	e5cdb011	 strb        r11, [sp, #0x11]
  00060	e5cd6010	 strb        r6, [sp, #0x10]
  00064	e58da014	 str         r10, [sp, #0x14]
  00068	e1a0e00f	 mov         lr, pc
  0006c	e12fff15	 bx          r5

; 3211 :     CPipeAbs* pStatusChangePipe = CreateInterruptPipe ( &m_deviceInfo.lpActiveConfig->lpInterfaces[0].lpEndpoints[0].Descriptor,
; 3212 :                                                             m_fIsLowSpeed,m_fIsHighSpeed,m_address,
; 3213 :                                                             uTTAddress,uTTPort,ttContext,
; 3214 :                                                             m_pCHcd);

  00070	e5973040	 ldr         r3, [r7, #0x40]
  00074	e59750c8	 ldr         r5, [r7, #0xC8]
  00078	e59d6014	 ldr         r6, [sp, #0x14]
  0007c	e5933018	 ldr         r3, [r3, #0x18]
  00080	e5dde010	 ldrb        lr, [sp, #0x10]
  00084	e5dd4011	 ldrb        r4, [sp, #0x11]
  00088	e5930014	 ldr         r0, [r3, #0x14]
  0008c	e5d73020	 ldrb        r3, [r7, #0x20]
  00090	e5972048	 ldr         r2, [r7, #0x48]
  00094	e5971044	 ldr         r1, [r7, #0x44]
  00098	e2800004	 add         r0, r0, #4
  0009c	e58d500c	 str         r5, [sp, #0xC]
  000a0	e58d6008	 str         r6, [sp, #8]
  000a4	e58de004	 str         lr, [sp, #4]
  000a8	e58d4000	 str         r4, [sp]
  000ac	eb000000	 bl          |?CreateInterruptPipe@@YAPAVCPipeAbs@@QBU_USB_ENDPOINT_DESCRIPTOR@@HHEEEHQAVCHcd@@@Z|
  000b0	e1b04000	 movs        r4, r0
  000b4	e3a05000	 mov         r5, #0

; 3215 : 
; 3216 :     // be sure to call OpenPipe last
; 3217 :     if ( pStatusChangePipe != NULL &&
; 3218 :          m_hHubStatusChangeEvent != NULL &&
; 3219 :          AllocatePipeArray() &&
; 3220 :          AllocateDeviceArray() &&
; 3221 :          pStatusChangePipe->SetReservedDeviceAddr(m_address) && 
; 3222 :          requestOK == pStatusChangePipe->OpenPipe() ) {

  000b8	0a000038	 beq         |$LN8@EnterOpera@3|
  000bc	e59730bc	 ldr         r3, [r7, #0xBC]
  000c0	e3530000	 cmp         r3, #0
  000c4	0a00002f	 beq         |$LN3@EnterOpera@3|
  000c8	e1a00007	 mov         r0, r7
  000cc	eb000000	 bl          |?AllocatePipeArray@CDevice@@IAAHXZ|
  000d0	e3500000	 cmp         r0, #0
  000d4	0a00002b	 beq         |$LN3@EnterOpera@3|
  000d8	e1a00007	 mov         r0, r7
  000dc	eb000000	 bl          |?AllocateDeviceArray@CHub@@IAAHXZ|
  000e0	e3500000	 cmp         r0, #0
  000e4	0a000027	 beq         |$LN3@EnterOpera@3|
  000e8	e5943000	 ldr         r3, [r4]
  000ec	e5d71020	 ldrb        r1, [r7, #0x20]
  000f0	e1a00004	 mov         r0, r4
  000f4	e5933024	 ldr         r3, [r3, #0x24]
  000f8	e1a0e00f	 mov         lr, pc
  000fc	e12fff13	 bx          r3
  00100	e3500000	 cmp         r0, #0
  00104	0a00001f	 beq         |$LN3@EnterOpera@3|
  00108	e5943000	 ldr         r3, [r4]
  0010c	e1a00004	 mov         r0, r4
  00110	e5933004	 ldr         r3, [r3, #4]
  00114	e1a0e00f	 mov         lr, pc
  00118	e12fff13	 bx          r3
  0011c	e3500001	 cmp         r0, #1
  00120	1a000018	 bne         |$LN3@EnterOpera@3|

; 3223 : 
; 3224 :         // Thread will use the pipes, so put them into our array
; 3225 :         DEBUGCHK( m_maxNumPipes == 2 &&
; 3226 :                   m_ppCPipe != NULL );
; 3227 :         m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ] = pEndpoint0Pipe;

  00124	e597105c	 ldr         r1, [r7, #0x5C]

; 3228 :         m_ppCPipe[ STATUS_CHANGE_INTERRUPT_PIPE ] = pStatusChangePipe;
; 3229 :         m_hHubStatusChangeThread = CreateThread( 0, 0, HubStatusChangeThreadStub, this, 0, NULL );

  00128	e59f20b4	 ldr         r2, [pc, #0xB4]
  0012c	e1a03007	 mov         r3, r7
  00130	e5819000	 str         r9, [r1]
  00134	e597e05c	 ldr         lr, [r7, #0x5C]
  00138	e3a01000	 mov         r1, #0
  0013c	e3a00000	 mov         r0, #0
  00140	e58e4004	 str         r4, [lr, #4]
  00144	e58d5004	 str         r5, [sp, #4]
  00148	e58d5000	 str         r5, [sp]
  0014c	eb000000	 bl          CreateThread
  00150	e3500000	 cmp         r0, #0
  00154	e58700c0	 str         r0, [r7, #0xC0]

; 3230 :         if ( m_hHubStatusChangeThread != NULL ) {

  00158	0a000005	 beq         |$LN4@EnterOpera@3|

; 3231 :             CeSetThreadPriority( m_hHubStatusChangeThread, g_IstThreadPriority + RELATIVE_PRIO_STSCHG);

  0015c	e59f307c	 ldr         r3, [pc, #0x7C]
  00160	e5933000	 ldr         r3, [r3]
  00164	e2831005	 add         r1, r3, #5
  00168	eb000000	 bl          CeSetThreadPriority

; 3232 :             fSuccess = TRUE;

  0016c	e3a08001	 mov         r8, #1

; 3233 :         } else {

  00170	ea000014	 b           |$LN1@EnterOpera@3|
  00174		 |$LN4@EnterOpera@3|

; 3234 :             pStatusChangePipe->ClosePipe();

  00174	e5943000	 ldr         r3, [r4]
  00178	e1a00004	 mov         r0, r4
  0017c	e5933008	 ldr         r3, [r3, #8]
  00180	e1a0e00f	 mov         lr, pc
  00184	e12fff13	 bx          r3
  00188		 |$LN3@EnterOpera@3|

; 3235 :         }
; 3236 :     }
; 3237 :     if ( !fSuccess ) {
; 3238 :         // pStatusChangePipe would have been closed above in case of failure
; 3239 :         delete pStatusChangePipe;

  00188	e5943000	 ldr         r3, [r4]
  0018c	e3a01001	 mov         r1, #1
  00190	e1a00004	 mov         r0, r4
  00194	e5933000	 ldr         r3, [r3]
  00198	e1a0e00f	 mov         lr, pc
  0019c	e12fff13	 bx          r3
  001a0		 |$LN8@EnterOpera@3|

; 3240 : 
; 3241 :         // caller will take care of closing the endpoint 0 pipe. We NULL out
; 3242 :         // the entries in the m_ppCPipe array because otherwise both our
; 3243 :         // ~CDevice destructor and the caller would try to free the pipe.
; 3244 :         m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ] = NULL;

  001a0	e597305c	 ldr         r3, [r7, #0x5C]
  001a4	e5835000	 str         r5, [r3]

; 3245 :         m_ppCPipe[ STATUS_CHANGE_INTERRUPT_PIPE ] = NULL;

  001a8	e597305c	 ldr         r3, [r7, #0x5C]
  001ac	e5835004	 str         r5, [r3, #4]

; 3246 :         // m_ppCPipe[] will be freed in ~CDevice
; 3247 : 
; 3248 :         // m_ppCDeviceOnPort [] will be freed in ~CHub
; 3249 : 
; 3250 :         if ( m_hHubStatusChangeEvent ) {

  001b0	e59730bc	 ldr         r3, [r7, #0xBC]
  001b4	e3530000	 cmp         r3, #0
  001b8	0a000002	 beq         |$LN1@EnterOpera@3|

; 3251 :             CloseHandle( m_hHubStatusChangeEvent );

  001bc	e1a00003	 mov         r0, r3
  001c0	eb000000	 bl          CloseHandle

; 3252 :             m_hHubStatusChangeEvent = NULL;

  001c4	e58750bc	 str         r5, [r7, #0xBC]
  001c8		 |$LN1@EnterOpera@3|

; 3253 :         }
; 3254 : 
; 3255 :         DEBUGCHK( m_hHubStatusChangeThread == NULL );
; 3256 :     }
; 3257 : 
; 3258 :     LeaveCriticalSection( &m_csDeviceLock );

  001c8	e287000c	 add         r0, r7, #0xC
  001cc	eb000000	 bl          LeaveCriticalSection

; 3259 : 
; 3260 :     DEBUGMSG( ZONE_HUB, (TEXT("%s: -CExternalHub::EnterOperationalState, returning BOOL %d\n"),GetControllerName(), fSuccess) );
; 3261 :     return fSuccess;
; 3262 : }

  001d0	e1a00008	 mov         r0, r8
  001d4	e28dd018	 add         sp, sp, #0x18
  001d8	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001dc	e12fff1e	 bx          lr
  001e0		 |$LN14@EnterOpera@3|
  001e0		 |$LN15@EnterOpera@3|
  001e0	00000000	 DCD         |g_IstThreadPriority|
  001e4		 |$LN16@EnterOpera@3|
  001e4	00000000	 DCD         |?HubStatusChangeThreadStub@CHub@@KAKPAX@Z|
  001e8		 |$M39485|

			 ENDP  ; |?EnterOperationalState@CExternalHub@@UAAHQAVCPipeAbs@@@Z|, CExternalHub::EnterOperationalState

	END
