; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\OMAP3530\MUSB\MUSBHCD\USB2COM\cphysmem.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|PulseEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T34034| DCD	|$LN5@PulseEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PulseEvent| PROC

; 211  : _inline BOOL PulseEvent(HANDLE h) {

  00000		 |$LN5@PulseEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M34031|

; 212  : 	return EventModify(h,EVENT_PULSE);

  00004	e3a01001	 mov         r1, #1
  00008	eb000000	 bl          EventModify

; 213  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M34032|

			 ENDP  ; |PulseEvent|

	EXPORT	|?InitializeListHead@@YAXPAUtMEMLIST@@@Z| ; InitializeListHead
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cphysmem.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T34042| DCD	|$LN5@Initialize|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InitializeListHead@@YAXPAUtMEMLIST@@@Z| PROC ; InitializeListHead

; 226  : {

  00000		 |$LN5@Initialize|
  00000		 |$M34039|

; 227  :     _ListHead->next = _ListHead->prev = _ListHead;

  00000	e5800010	 str         r0, [r0, #0x10]
  00004	e580000c	 str         r0, [r0, #0xC]

; 228  : }

  00008	e12fff1e	 bx          lr
  0000c		 |$M34040|

			 ENDP  ; |?InitializeListHead@@YAXPAUtMEMLIST@@@Z|, InitializeListHead

	EXPORT	|?FirstNode@@YAPAUtMEMLIST@@PAU1@@Z|	; FirstNode

  00000			 AREA	 |.pdata|, PDATA
|$T34052| DCD	|$LN5@FirstNode|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FirstNode@@YAPAUtMEMLIST@@PAU1@@Z| PROC ; FirstNode

; 235  : { 

  00000		 |$LN5@FirstNode|
  00000		 |$M34049|

; 236  :     return(_ListHead->next); 

  00000	e590000c	 ldr         r0, [r0, #0xC]

; 237  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M34050|

			 ENDP  ; |?FirstNode@@YAPAUtMEMLIST@@PAU1@@Z|, FirstNode

	EXPORT	|?RemoveNode@@YAXPAUtMEMLIST@@@Z|	; RemoveNode

  00000			 AREA	 |.pdata|, PDATA
|$T34060| DCD	|$LN5@RemoveNode|
	DCD	0x40000a00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?RemoveNode@@YAXPAUtMEMLIST@@@Z| PROC	; RemoveNode

; 244  : {

  00000		 |$LN5@RemoveNode|
  00000		 |$M34057|

; 245  :     pNode->prev->next = pNode->next;

  00000	e5902010	 ldr         r2, [r0, #0x10]
  00004	e590300c	 ldr         r3, [r0, #0xC]

; 246  :     pNode->next->prev = pNode->prev;
; 247  :     pNode->next = NULL;

  00008	e3a01000	 mov         r1, #0
  0000c	e582300c	 str         r3, [r2, #0xC]
  00010	e590200c	 ldr         r2, [r0, #0xC]
  00014	e5903010	 ldr         r3, [r0, #0x10]
  00018	e5823010	 str         r3, [r2, #0x10]
  0001c	e580100c	 str         r1, [r0, #0xC]

; 248  :     pNode->prev = NULL;

  00020	e5801010	 str         r1, [r0, #0x10]

; 249  : }

  00024	e12fff1e	 bx          lr
  00028		 |$M34058|

			 ENDP  ; |?RemoveNode@@YAXPAUtMEMLIST@@@Z|, RemoveNode

	EXPORT	|?InsertNodeBefore@@YAXPAUtMEMLIST@@0@Z| ; InsertNodeBefore

  00000			 AREA	 |.pdata|, PDATA
|$T34069| DCD	|$LN5@InsertNode|
	DCD	0x40000700
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InsertNodeBefore@@YAXPAUtMEMLIST@@0@Z| PROC ; InsertNodeBefore

; 257  : {

  00000		 |$LN5@InsertNode|
  00000		 |$M34066|

; 258  :     pNodeExisting->prev->next = pNodeNew;

  00000	e5913010	 ldr         r3, [r1, #0x10]
  00004	e583000c	 str         r0, [r3, #0xC]

; 259  :     pNodeNew->prev = pNodeExisting->prev;

  00008	e5913010	 ldr         r3, [r1, #0x10]

; 260  :     pNodeNew->next = pNodeExisting;

  0000c	e580100c	 str         r1, [r0, #0xC]
  00010	e5803010	 str         r3, [r0, #0x10]

; 261  :     pNodeExisting->prev = pNodeNew;

  00014	e5810010	 str         r0, [r1, #0x10]

; 262  : }

  00018	e12fff1e	 bx          lr
  0001c		 |$M34067|

			 ENDP  ; |?InsertNodeBefore@@YAXPAUtMEMLIST@@0@Z|, InsertNodeBefore

	EXPORT	|?CreateNewNode@CPhysMem@@AAAPAUtMEMLIST@@KKK@Z| ; CPhysMem::CreateNewNode
	IMPORT	|LocalAlloc|

  00000			 AREA	 |.pdata|, PDATA
|$T34092| DCD	|$LN15@CreateNewN|
	DCD	0x40002001
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cphysmem.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CreateNewNode@CPhysMem@@AAAPAUtMEMLIST@@KKK@Z| PROC ; CPhysMem::CreateNewNode

; 384  : {

  00000		 |$LN15@CreateNewN|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M34089|
  00004	e1a05003	 mov         r5, r3
  00008	e1a06002	 mov         r6, r2
  0000c	e1b07001	 movs        r7, r1

; 385  : #ifdef DEBUG
; 386  :     if ( dwSize == 0 ) {
; 387  :         DEBUGCHK( dwVirtAddr == 0 &&
; 388  :                   dwPhysAddr == 0 );
; 389  :     } else {
; 390  :         DEBUGCHK( dwSize % CPHYSMEM_MEMORY_ALIGNMENT == 0 &&
; 391  :                   dwPhysAddr % CPHYSMEM_MEMORY_ALIGNMENT == 0 &&
; 392  :                   PUCHAR(dwVirtAddr) == PaToVa( dwPhysAddr ) );
; 393  :     }
; 394  : #endif // DEBUG
; 395  : 
; 396  :     PMEMLIST pNode;
; 397  :     //
; 398  :     // If we already have a node allocated and sitting around, use it.
; 399  :     //
; 400  :     if ((dwSize == 0) || IsListEmpty(m_pNodeFreeListHead)) {

  00010	e3a08000	 mov         r8, #0
  00014	0a00000d	 beq         |$LN3@CreateNewN|
  00018	e590e040	 ldr         lr, [r0, #0x40]
  0001c	e59e000c	 ldr         r0, [lr, #0xC]
  00020	e150000e	 cmp         r0, lr
  00024	0a000009	 beq         |$LN3@CreateNewN|

; 402  :     } else {
; 403  :         pNode = FirstNode(m_pNodeFreeListHead);

  00028	e1a04000	 mov         r4, r0

; 404  :         RemoveNode(pNode);

  0002c	e594e010	 ldr         lr, [r4, #0x10]
  00030	e594000c	 ldr         r0, [r4, #0xC]
  00034	e58e000c	 str         r0, [lr, #0xC]
  00038	e594e00c	 ldr         lr, [r4, #0xC]
  0003c	e5940010	 ldr         r0, [r4, #0x10]
  00040	e58e0010	 str         r0, [lr, #0x10]
  00044	e584800c	 str         r8, [r4, #0xC]
  00048	e5848010	 str         r8, [r4, #0x10]
  0004c	ea000003	 b           |$LN11@CreateNewN|
  00050		 |$LN3@CreateNewN|

; 401  :         pNode = (PMEMLIST) CPhysMem_Alloc(LPTR, sizeof(MEMLIST));

  00050	e3a01014	 mov         r1, #0x14
  00054	e3a00040	 mov         r0, #0x40
  00058	eb000000	 bl          LocalAlloc
  0005c	e1a04000	 mov         r4, r0

; 404  :         RemoveNode(pNode);

  00060		 |$LN11@CreateNewN|

; 405  :     }
; 406  : 
; 407  :     if (pNode != NULL) {

  00060	e3540000	 cmp         r4, #0

; 408  :         pNode->dwVirtAddr = dwVirtAddr;

  00064	15846000	 strne       r6, [r4]

; 409  :         pNode->dwPhysAddr = dwPhysAddr;

  00068	1284c004	 addne       r12, r4, #4
  0006c	188c01a0	 stmneia     r12, {r5, r7, r8}

; 410  :         pNode->dwSize = dwSize;
; 411  :         pNode->next = NULL;
; 412  :         pNode->prev = NULL;

  00070	15848010	 strne       r8, [r4, #0x10]

; 413  :     #ifdef DEBUG
; 414  :         _tcscpy( pNode->szDescription, TEXT("Default Desc") );
; 415  :     #endif // DEBUG
; 416  :     }
; 417  :     
; 418  :     return (pNode);
; 419  : }

  00074	e1a00004	 mov         r0, r4
  00078	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$M34090|

			 ENDP  ; |?CreateNewNode@CPhysMem@@AAAPAUtMEMLIST@@KKK@Z|, CPhysMem::CreateNewNode

	EXPORT	|?DeleteNode@CPhysMem@@AAAHPAUtMEMLIST@@@Z| ; CPhysMem::DeleteNode
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cphysmem.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T34112| DCD	|$LN9@DeleteNode|
	DCD	0x40000a00
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cphysmem.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DeleteNode@CPhysMem@@AAAHPAUtMEMLIST@@@Z| PROC ; CPhysMem::DeleteNode

; 438  : {

  00000		 |$LN9@DeleteNode|
  00000		 |$M34109|

; 439  :     //
; 440  :     // We don't actually delete any of the nodes. We just keep them on our
; 441  :     // free list to use later. Keeps us from thrashing on the heap.
; 442  :     //
; 443  : #ifdef DEBUG
; 444  :     pNode->dwSize = 0xdeadbeef;
; 445  :     pNode->dwPhysAddr = 0xdeadbeef;
; 446  :     pNode->dwVirtAddr = 0xdeadbeef;
; 447  :     _tcscpy( pNode->szDescription, TEXT("Deleted Node") );
; 448  : #endif // DEBUG
; 449  :     InsertNodeBefore(pNode, FirstNode(m_pNodeFreeListHead));

  00000	e5903040	 ldr         r3, [r0, #0x40]

; 450  :     return(TRUE);

  00004	e3a00001	 mov         r0, #1
  00008	e593200c	 ldr         r2, [r3, #0xC]
  0000c	e5923010	 ldr         r3, [r2, #0x10]
  00010	e583100c	 str         r1, [r3, #0xC]
  00014	e5923010	 ldr         r3, [r2, #0x10]
  00018	e581200c	 str         r2, [r1, #0xC]
  0001c	e5813010	 str         r3, [r1, #0x10]
  00020	e5821010	 str         r1, [r2, #0x10]

; 451  : }

  00024	e12fff1e	 bx          lr
  00028		 |$M34110|

			 ENDP  ; |?DeleteNode@CPhysMem@@AAAHPAUtMEMLIST@@@Z|, CPhysMem::DeleteNode

	EXPORT	|?FindFreeBlock@CPhysMem@@AAAPAUtMEMLIST@@KH@Z| ; CPhysMem::FindFreeBlock
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cphysmem.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T34143| DCD	|$LN21@FindFreeBl|
	DCD	0x40001d01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cphysmem.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FindFreeBlock@CPhysMem@@AAAPAUtMEMLIST@@KH@Z| PROC ; CPhysMem::FindFreeBlock

; 474  : {

  00000		 |$LN21@FindFreeBl|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M34140|
  00004	e3520000	 cmp         r2, #0
  00008	e1a0e000	 mov         lr, r0

; 475  :     DEBUGCHK( dwSize >= CPHYSMEM_MEMORY_ALIGNMENT &&
; 476  :               dwSize % CPHYSMEM_MEMORY_ALIGNMENT == 0 );
; 477  :     //
; 478  :     // The free list is sorted by increasing block sizes, so just find the 
; 479  :     // first block that's at least "dwSize" big.
; 480  :     //
; 481  :     PMEMLIST pNode = FirstNode(FREELIST(fHighPri));

  0000c	159e3074	 ldrne       r3, [lr, #0x74]
  00010	059e305c	 ldreq       r3, [lr, #0x5C]
  00014	e593000c	 ldr         r0, [r3, #0xC]
  00018		 |$LL3@FindFreeBl|

; 482  :     
; 483  :     while (!EndOfList(FREELIST(fHighPri), pNode)) {

  00018	e3520000	 cmp         r2, #0
  0001c	159e3074	 ldrne       r3, [lr, #0x74]
  00020	059e305c	 ldreq       r3, [lr, #0x5C]
  00024	e1530000	 cmp         r3, r0
  00028	0a00000e	 beq         |$LN2@FindFreeBl|

; 484  :         if (dwSize <= pNode->dwSize) {

  0002c	e5903008	 ldr         r3, [r0, #8]
  00030	e1510003	 cmp         r1, r3

; 485  :             RemoveNode(pNode);
; 486  :             return (pNode);
; 487  :         }
; 488  :         pNode = pNode->next;

  00034	8590000c	 ldrhi       r0, [r0, #0xC]
  00038	8afffff6	 bhi         |$LL3@FindFreeBl|
  0003c	e5902010	 ldr         r2, [r0, #0x10]
  00040	e590300c	 ldr         r3, [r0, #0xC]
  00044	e3a01000	 mov         r1, #0
  00048	e582300c	 str         r3, [r2, #0xC]
  0004c	e590200c	 ldr         r2, [r0, #0xC]
  00050	e5903010	 ldr         r3, [r0, #0x10]
  00054	e5823010	 str         r3, [r2, #0x10]
  00058	e580100c	 str         r1, [r0, #0xC]
  0005c	e5801010	 str         r1, [r0, #0x10]

; 492  : }

  00060	e49de004	 ldr         lr, [sp], #4
  00064	e12fff1e	 bx          lr
  00068		 |$LN2@FindFreeBl|

; 489  :     }
; 490  :     
; 491  :     return (NULL);

  00068	e3a00000	 mov         r0, #0

; 492  : }

  0006c	e49de004	 ldr         lr, [sp], #4
  00070	e12fff1e	 bx          lr
  00074		 |$M34141|

			 ENDP  ; |?FindFreeBlock@CPhysMem@@AAAPAUtMEMLIST@@KH@Z|, CPhysMem::FindFreeBlock

	EXPORT	|?AddNodeToFreeList@CPhysMem@@AAAHPAUtMEMLIST@@H@Z| ; CPhysMem::AddNodeToFreeList
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cphysmem.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T34231| DCD	|$LN57@AddNodeToF|
	DCD	0x40006601
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cphysmem.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AddNodeToFreeList@CPhysMem@@AAAHPAUtMEMLIST@@H@Z| PROC ; CPhysMem::AddNodeToFreeList

; 517  : {

  00000		 |$LN57@AddNodeToF|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M34228|
  00004	e1b05002	 movs        r5, r2
  00008	e1a0e001	 mov         lr, r1

; 518  :     //
; 519  :     // The free list is sorted by increasing block sizes, not by increasing
; 520  :     // address so we must scan the list for any possible connecting free blocks,
; 521  :     // and then coalesce them into a single free block. There will be at most
; 522  :     // two blocks to find (one on either end) so scan for both of them.
; 523  :     //
; 524  :     PMEMLIST pNodeTraverse = FirstNode(FREELIST(fHighPri));

  0000c	15901074	 ldrne       r1, [r0, #0x74]
  00010	0590105c	 ldreq       r1, [r0, #0x5C]

; 525  :     
; 526  :     PMEMLIST pNodePrevious = NULL; // Points to the previous connecting free block
; 527  :     PMEMLIST pNodeNext = NULL;     // Points to the next connecting free block
; 528  :     //
; 529  :     // The endpoints that we are trying to match up to.
; 530  :     //
; 531  :     DWORD dwThisPA = pNode->dwPhysAddr;

  00014	e59e7004	 ldr         r7, [lr, #4]

; 532  :     DWORD dwNextPA = MEMLIST_NEXT_PA(pNode);

  00018	e59e3008	 ldr         r3, [lr, #8]
  0001c	e591200c	 ldr         r2, [r1, #0xC]
  00020	e3a01000	 mov         r1, #0
  00024	e3a04000	 mov         r4, #0
  00028	e0838007	 add         r8, r3, r7
  0002c		 |$LL13@AddNodeToF|

; 533  : 
; 534  :     //
; 535  :     // Walk the list looking for blocks that are next to this one.
; 536  :     //
; 537  :     while (!EndOfList(FREELIST(fHighPri), pNodeTraverse)) {

  0002c	e3550000	 cmp         r5, #0
  00030	15903074	 ldrne       r3, [r0, #0x74]
  00034	0590305c	 ldreq       r3, [r0, #0x5C]
  00038	e1530002	 cmp         r3, r2
  0003c	0a00000d	 beq         |$LN53@AddNodeToF|

; 538  : 
; 539  :         if (dwThisPA == MEMLIST_NEXT_PA(pNodeTraverse)) {

  00040	e5926004	 ldr         r6, [r2, #4]
  00044	e5923008	 ldr         r3, [r2, #8]
  00048	e0833006	 add         r3, r3, r6
  0004c	e1570003	 cmp         r7, r3

; 540  :             //
; 541  :             // We've found the block just ahead of this one. Remember it.
; 542  :             //
; 543  :             pNodePrevious = pNodeTraverse;

  00050	01a04002	 moveq       r4, r2
  00054	0a000001	 beq         |$LN9@AddNodeToF|

; 544  : 
; 545  :         } else if (dwNextPA == pNodeTraverse->dwPhysAddr) {

  00058	e1580006	 cmp         r8, r6

; 546  :             //
; 547  :             // We've found the block just after of this one.
; 548  :             //
; 549  :             pNodeNext = pNodeTraverse;

  0005c	01a01002	 moveq       r1, r2
  00060		 |$LN9@AddNodeToF|

; 550  :         }
; 551  : 
; 552  :         if ((pNodePrevious == NULL) || (pNodeNext == NULL)) {

  00060	e3540000	 cmp         r4, #0
  00064	0a000001	 beq         |$LN7@AddNodeToF|
  00068	e3510000	 cmp         r1, #0
  0006c	1a000001	 bne         |$LN53@AddNodeToF|
  00070		 |$LN7@AddNodeToF|

; 553  :             //
; 554  :             // We haven't connected both ends, so keep on looking...
; 555  :             //
; 556  :             pNodeTraverse = pNodeTraverse->next;

  00070	e592200c	 ldr         r2, [r2, #0xC]

; 557  :         } else {
; 558  :             //
; 559  :             // We've found blocks to connect on both ends, let's get on with it.
; 560  :             //
; 561  :             break;
; 562  :         }
; 563  :     }

  00074	eaffffec	 b           |$LL13@AddNodeToF|
  00078		 |$LN53@AddNodeToF|

; 564  :     
; 565  : 
; 566  :     if (pNodePrevious != NULL) {

  00078	e3a06000	 mov         r6, #0
  0007c	e3540000	 cmp         r4, #0
  00080	0a000017	 beq         |$LN36@AddNodeToF|

; 567  :         //
; 568  :         // Combine with the previous block.
; 569  :         //
; 570  :         RemoveNode(pNodePrevious);

  00084	e5942010	 ldr         r2, [r4, #0x10]
  00088	e594300c	 ldr         r3, [r4, #0xC]
  0008c	e582300c	 str         r3, [r2, #0xC]
  00090	e594200c	 ldr         r2, [r4, #0xC]
  00094	e5943010	 ldr         r3, [r4, #0x10]
  00098	e5823010	 str         r3, [r2, #0x10]

; 571  :         //
; 572  :         // Grow pNode to hold both.
; 573  :         //
; 574  :         pNode->dwSize = pNode->dwSize + pNodePrevious->dwSize;

  0009c	e5943008	 ldr         r3, [r4, #8]
  000a0	e584600c	 str         r6, [r4, #0xC]
  000a4	e5846010	 str         r6, [r4, #0x10]
  000a8	e59e2008	 ldr         r2, [lr, #8]
  000ac	e0833002	 add         r3, r3, r2
  000b0	e58e3008	 str         r3, [lr, #8]

; 575  :         pNode->dwVirtAddr = pNodePrevious->dwVirtAddr;

  000b4	e5943000	 ldr         r3, [r4]
  000b8	e58e3000	 str         r3, [lr]

; 576  :         pNode->dwPhysAddr = pNodePrevious->dwPhysAddr;

  000bc	e5943004	 ldr         r3, [r4, #4]
  000c0	e58e3004	 str         r3, [lr, #4]

; 577  :         DeleteNode(pNodePrevious);

  000c4	e5903040	 ldr         r3, [r0, #0x40]
  000c8	e593200c	 ldr         r2, [r3, #0xC]
  000cc	e5923010	 ldr         r3, [r2, #0x10]
  000d0	e583400c	 str         r4, [r3, #0xC]
  000d4	e5923010	 ldr         r3, [r2, #0x10]
  000d8	e584200c	 str         r2, [r4, #0xC]
  000dc	e5843010	 str         r3, [r4, #0x10]
  000e0	e5824010	 str         r4, [r2, #0x10]
  000e4		 |$LN36@AddNodeToF|

; 578  :     }
; 579  : 
; 580  :     if (pNodeNext != NULL) {

  000e4	e3510000	 cmp         r1, #0
  000e8	0a000013	 beq         |$LN44@AddNodeToF|

; 581  :         //
; 582  :         // Combine with the next block.
; 583  :         //
; 584  :         RemoveNode(pNodeNext);

  000ec	e5912010	 ldr         r2, [r1, #0x10]
  000f0	e591300c	 ldr         r3, [r1, #0xC]
  000f4	e582300c	 str         r3, [r2, #0xC]
  000f8	e591200c	 ldr         r2, [r1, #0xC]
  000fc	e5913010	 ldr         r3, [r1, #0x10]
  00100	e5823010	 str         r3, [r2, #0x10]

; 585  :         //
; 586  :         // Grow pNode to hold both.
; 587  :         //
; 588  :         pNode->dwSize = pNode->dwSize + pNodeNext->dwSize;

  00104	e5913008	 ldr         r3, [r1, #8]
  00108	e581600c	 str         r6, [r1, #0xC]
  0010c	e5816010	 str         r6, [r1, #0x10]
  00110	e59e2008	 ldr         r2, [lr, #8]
  00114	e0833002	 add         r3, r3, r2
  00118	e58e3008	 str         r3, [lr, #8]

; 589  :     #ifdef DEBUG
; 590  :         // take description of the largest block
; 591  :         _tcscpy( pNode->szDescription, pNodeNext->szDescription );
; 592  :     #endif // DEBUG
; 593  :         DeleteNode(pNodeNext);

  0011c	e5903040	 ldr         r3, [r0, #0x40]
  00120	e593200c	 ldr         r2, [r3, #0xC]
  00124	e5923010	 ldr         r3, [r2, #0x10]
  00128	e583100c	 str         r1, [r3, #0xC]
  0012c	e5923010	 ldr         r3, [r2, #0x10]
  00130	e581200c	 str         r2, [r1, #0xC]
  00134	e5813010	 str         r3, [r1, #0x10]
  00138	e5821010	 str         r1, [r2, #0x10]
  0013c		 |$LN44@AddNodeToF|

; 594  :     }
; 595  : 
; 596  :     //
; 597  :     // Add pNode to the free list in sorted size order.
; 598  :     //
; 599  :     pNodeTraverse = FirstNode(FREELIST(fHighPri));

  0013c	e3550000	 cmp         r5, #0
  00140	15903074	 ldrne       r3, [r0, #0x74]
  00144	0590305c	 ldreq       r3, [r0, #0x5C]
  00148	e593100c	 ldr         r1, [r3, #0xC]
  0014c		 |$LL3@AddNodeToF|

; 600  :     
; 601  :     while (!EndOfList(FREELIST(fHighPri), pNodeTraverse)) {

  0014c	e3550000	 cmp         r5, #0
  00150	15903074	 ldrne       r3, [r0, #0x74]
  00154	0590305c	 ldreq       r3, [r0, #0x5C]
  00158	e1530001	 cmp         r3, r1
  0015c	0a000004	 beq         |$LN54@AddNodeToF|

; 602  : 
; 603  :         if (pNode->dwSize <= pNodeTraverse->dwSize) {

  00160	e59e2008	 ldr         r2, [lr, #8]
  00164	e5913008	 ldr         r3, [r1, #8]
  00168	e1520003	 cmp         r2, r3

; 604  :             break;
; 605  :         }
; 606  :         pNodeTraverse = pNodeTraverse->next;

  0016c	8591100c	 ldrhi       r1, [r1, #0xC]
  00170	8afffff5	 bhi         |$LL3@AddNodeToF|
  00174		 |$LN54@AddNodeToF|

; 607  :     }
; 608  : 
; 609  :     //
; 610  :     // Insert this node before the traverse node.
; 611  :     //
; 612  :     InsertNodeBefore(pNode, pNodeTraverse);

  00174	e5913010	 ldr         r3, [r1, #0x10]

; 613  : 
; 614  :     return TRUE;

  00178	e3a00001	 mov         r0, #1
  0017c	e583e00c	 str         lr, [r3, #0xC]
  00180	e5913010	 ldr         r3, [r1, #0x10]
  00184	e58e100c	 str         r1, [lr, #0xC]
  00188	e58e3010	 str         r3, [lr, #0x10]
  0018c	e581e010	 str         lr, [r1, #0x10]

; 615  : }

  00190	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00194	e12fff1e	 bx          lr
  00198		 |$M34229|

			 ENDP  ; |?AddNodeToFreeList@CPhysMem@@AAAHPAUtMEMLIST@@H@Z|, CPhysMem::AddNodeToFreeList

	EXPORT	|?FreeList@CPhysMem@@AAAHPAPAUtMEMLIST@@@Z| ; CPhysMem::FreeList
	IMPORT	|LocalFree|

  00000			 AREA	 |.pdata|, PDATA
|$T34246| DCD	|$LN11@FreeList|
	DCD	0x40001401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FreeList@CPhysMem@@AAAHPAPAUtMEMLIST@@@Z| PROC ; CPhysMem::FreeList

; 660  : {

  00000		 |$LN11@FreeList|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M34243|
  00004	e1a04001	 mov         r4, r1

; 661  :     PMEMLIST pCurrent;
; 662  :     PMEMLIST pNext;
; 663  : 
; 664  :     if ( *ppHead != NULL ) {

  00008	e5943000	 ldr         r3, [r4]
  0000c	e3530000	 cmp         r3, #0
  00010	0a00000b	 beq         |$LN3@FreeList|

; 665  :         pCurrent = (*ppHead)->next;

  00014	e593500c	 ldr         r5, [r3, #0xC]
  00018	ea000003	 b           |$LN8@FreeList|
  0001c		 |$LL2@FreeList|

; 666  :         while ( pCurrent != *ppHead ) {
; 667  :             DEBUGCHK( pCurrent != NULL );
; 668  :             pNext = pCurrent->next;
; 669  :             CPhysMem_Free( pCurrent );

  0001c	e1a00005	 mov         r0, r5
  00020	e595500c	 ldr         r5, [r5, #0xC]
  00024	eb000000	 bl          LocalFree
  00028	e5943000	 ldr         r3, [r4]
  0002c		 |$LN8@FreeList|

; 670  :             pCurrent = pNext;

  0002c	e1550003	 cmp         r5, r3
  00030	1afffff9	 bne         |$LL2@FreeList|

; 671  :         }
; 672  :         CPhysMem_Free( *ppHead );

  00034	e5940000	 ldr         r0, [r4]
  00038	eb000000	 bl          LocalFree

; 673  :         *ppHead = NULL;

  0003c	e3a03000	 mov         r3, #0
  00040	e5843000	 str         r3, [r4]
  00044		 |$LN3@FreeList|

; 674  :     }
; 675  : 
; 676  :     return(TRUE);

  00044	e3a00001	 mov         r0, #1

; 677  : }

  00048	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M34244|

			 ENDP  ; |?FreeList@CPhysMem@@AAAHPAPAUtMEMLIST@@@Z|, CPhysMem::FreeList

	EXPORT	|?AllocateSpecialMemory@CPhysMem@@QAAHKQAPAE@Z| ; CPhysMem::AllocateSpecialMemory

  00000			 AREA	 |.pdata|, PDATA
|$T34257| DCD	|$LN6@AllocateSp|
	DCD	0x40000800
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AllocateSpecialMemory@CPhysMem@@QAAHKQAPAE@Z| PROC ; CPhysMem::AllocateSpecialMemory

; 697  : {

  00000		 |$LN6@AllocateSp|
  00000		 |$M34254|

; 698  :     DEBUGCHK( dwSize <= USBPAGESIZE );
; 699  :     PREFAST_DEBUGCHK( pVirtAddr != NULL );
; 700  : 
; 701  :     // during suspend/resume this routine will be called again; we can safely
; 702  :     // leave the special memory set aside since we will always need the same amount.
; 703  :     if(!m_bSpecialTaken) {

  00000	e590304c	 ldr         r3, [r0, #0x4C]
  00004	e3530000	 cmp         r3, #0

; 704  :         m_bSpecialTaken = TRUE;

  00008	03a03001	 moveq       r3, #1
  0000c	0580304c	 streq       r3, [r0, #0x4C]

; 705  :         DEBUGCHK( m_dwSpecialPA == VaToPa( PUCHAR(m_dwSpecialVA) ) );
; 706  :         DEBUGCHK( m_dwSpecialPA % CPHYSMEM_MEMORY_ALIGNMENT == 0 );
; 707  :     }
; 708  : 
; 709  :     *pVirtAddr = (PUCHAR) m_dwSpecialVA;

  00010	e5903048	 ldr         r3, [r0, #0x48]

; 710  : 
; 711  :     DEBUGMSG(ZONE_CPHYSMEM && ZONE_VERBOSE,(TEXT("CPhysMem AllocateMemory : bSpecial allocated\r\n")));
; 712  :     return(TRUE);

  00014	e3a00001	 mov         r0, #1
  00018	e5823000	 str         r3, [r2]

; 713  : }

  0001c	e12fff1e	 bx          lr
  00020		 |$M34255|

			 ENDP  ; |?AllocateSpecialMemory@CPhysMem@@QAAHKQAPAE@Z|, CPhysMem::AllocateSpecialMemory

	EXPORT	|?FreeSpecialMemory@CPhysMem@@QAAXQAE@Z| ; CPhysMem::FreeSpecialMemory

  00000			 AREA	 |.pdata|, PDATA
|$T34265| DCD	|$LN5@FreeSpecia|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FreeSpecialMemory@CPhysMem@@QAAXQAE@Z| PROC ; CPhysMem::FreeSpecialMemory

; 727  : {

  00000		 |$LN5@FreeSpecia|
  00000		 |$M34262|

; 728  : 
; 729  :     DEBUGCHK( m_dwSpecialVA == (DWORD) virtAddr );
; 730  :     DEBUGCHK( m_bSpecialTaken );
; 731  : 
; 732  :     m_bSpecialTaken = FALSE;

  00000	e3a03000	 mov         r3, #0
  00004	e580304c	 str         r3, [r0, #0x4C]

; 733  : }

  00008	e12fff1e	 bx          lr
  0000c		 |$M34263|

			 ENDP  ; |?FreeSpecialMemory@CPhysMem@@QAAXQAE@Z|, CPhysMem::FreeSpecialMemory

	EXPORT	|?AllocateMemory@CPhysMem@@QAAHKQAPAEKPAH@Z| ; CPhysMem::AllocateMemory
	IMPORT	|WaitForSingleObject|
	IMPORT	|LeaveCriticalSection|
	IMPORT	|EnterCriticalSection|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cphysmem.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T34307| DCD	|$LN32@AllocateMe|
	DCD	0x40005b01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cphysmem.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AllocateMemory@CPhysMem@@QAAHKQAPAEKPAH@Z| PROC ; CPhysMem::AllocateMemory

; 756  : {

  00000		 |$LN32@AllocateMe|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M34304|
  00004	e1a08002	 mov         r8, r2
  00008	e1a04000	 mov         r4, r0
  0000c	e2411001	 sub         r1, r1, #1
  00010	e3c1101f	 bic         r1, r1, #0x1F
  00014	e2819020	 add         r9, r1, #0x20
  00018		 |$LL24@AllocateMe|

; 757  : #ifdef DEBUG
; 758  :     PREFAST_DEBUGCHK( pszMemDescription != NULL );
; 759  :     DEBUGCHK( dwPassedInSize > 0 );
; 760  :     // for now, only the following sets of flags should be passed in
; 761  :     DEBUGCHK( dwFlags == 0 || // low priority, allow blocking
; 762  :               dwFlags == CPHYSMEM_FLAG_NOBLOCK || // low priority, no blocking
; 763  :               dwFlags == (CPHYSMEM_FLAG_HIGHPRIORITY | CPHYSMEM_FLAG_NOBLOCK) ); // high pri, no blocking
; 764  : 
; 765  :     if ( dwFlags & CPHYSMEM_FLAG_NOBLOCK ) {
; 766  :         // pfRequestingAbort will be ignored for NO_BLOCK transfers,
; 767  :         // so why is caller passing it in? Note that nothing
; 768  :         // bad will happen if pfRequestingAbort != NULL, so
; 769  :         // this check can be removed in the future if need be.
; 770  :         DEBUGCHK( pfRequestingAbort == NULL );
; 771  :     } else {
; 772  :         // blocking transfers must pass in a pointer
; 773  :         // for allowing the transfer to abort, and
; 774  :         // the original state of this abort request
; 775  :         // should be FALSE. If not, the blocking
; 776  :         // request is ignored.
; 777  :         DEBUGCHK( pfRequestingAbort != NULL &&
; 778  :                   *pfRequestingAbort == FALSE );
; 779  :     }
; 780  : #endif // DEBUG
; 781  : 
; 782  :     PMEMLIST    pNode = NULL;
; 783  :     const BOOL  fHighPri = !!(dwFlags & CPHYSMEM_FLAG_HIGHPRIORITY);

  00018	e3130001	 tst         r3, #1
  0001c	13a06001	 movne       r6, #1
  00020	03a06000	 moveq       r6, #0

; 784  :     const BOOL  fNoBlock = !!(dwFlags & CPHYSMEM_FLAG_NOBLOCK);

  00024	e3130002	 tst         r3, #2
  00028	13a07001	 movne       r7, #1

; 785  :     // We keep our block sizes in multiples of CPHYSMEM_MEMORY_ALIGNMENT
; 786  :     DWORD       dwSize = ( (dwPassedInSize - 1) & ~(CPHYSMEM_MEMORY_ALIGNMENT - 1) )
; 787  :                                  + CPHYSMEM_MEMORY_ALIGNMENT;
; 788  : 
; 789  :     PREFAST_DEBUGCHK( pVirtAddr != NULL );
; 790  :     DEBUGCHK( dwSize % CPHYSMEM_MEMORY_ALIGNMENT == 0 );
; 791  :     DEBUGCHK( dwSize - dwPassedInSize < CPHYSMEM_MEMORY_ALIGNMENT );
; 792  :     DEBUGMSG(ZONE_CPHYSMEM && ZONE_VERBOSE && (dwSize != dwPassedInSize),
; 793  :              (TEXT("AllocateMemory Desc = %s: (roundup %d->%d)\r\n"), pszMemDescription, dwPassedInSize, dwSize ));
; 794  : 
; 795  :     EnterCriticalSection( &m_csLock );

  0002c	e2840010	 add         r0, r4, #0x10
  00030	03a07000	 moveq       r7, #0
  00034	eb000000	 bl          EnterCriticalSection

; 796  : 
; 797  :     DEBUGMSG( ZONE_CPHYSMEM && ZONE_VERBOSE, (TEXT("CPhysMem: Heap pri = %d before allocation of %d bytes:\n"), fHighPri, dwSize ) );
; 798  :     VALIDATE_HEAPS(fHighPri);
; 799  : 
; 800  :     //
; 801  :     // Scan the free list for the first chunk that's just big enough to satisfy
; 802  :     // this request. Remove from the free list. Chop it up (unless the result 
; 803  :     // is less than CPHYSMEM_MEMORY_ALIGNMENT bytes). Then re-sort the remaining
; 804  :     // free chunk back into the free list and place the newly allocated chunk on
; 805  :     // the IN USE list.
; 806  :     //
; 807  :     pNode = FindFreeBlock(dwSize, fHighPri);

  00038	e1a02006	 mov         r2, r6
  0003c	e1a01009	 mov         r1, r9
  00040	e1a00004	 mov         r0, r4
  00044	eb000000	 bl          |?FindFreeBlock@CPhysMem@@AAAPAUtMEMLIST@@KH@Z|
  00048	e1b05000	 movs        r5, r0

; 808  :     if ( pNode == NULL ) {

  0004c	1a00001f	 bne         |$LN2@AllocateMe|

; 809  :         if ( fHighPri ) {

  00050	e3560000	 cmp         r6, #0
  00054	0a000003	 beq         |$LN10@AllocateMe|

; 810  :             //
; 811  :             // Not available from High Priority region, try allocating from Normal region.
; 812  :             //
; 813  :             LeaveCriticalSection(&m_csLock);

  00058	e2840010	 add         r0, r4, #0x10
  0005c	eb000000	 bl          LeaveCriticalSection

; 814  : 
; 815  :             DEBUGCHK( dwFlags == (CPHYSMEM_FLAG_HIGHPRIORITY | CPHYSMEM_FLAG_NOBLOCK) );
; 816  :             return AllocateMemory( DEBUG_PARAM( pszMemDescription )
; 817  :                                    dwPassedInSize,
; 818  :                                    pVirtAddr,
; 819  :                                    CPHYSMEM_FLAG_NOBLOCK, // dwFlags & ~CPHYSMEM_FLAG_HIGHPRIORITY,
; 820  :                                    pfRequestingAbort );

  00060	e3a03002	 mov         r3, #2
  00064	eaffffeb	 b           |$LL24@AllocateMe|
  00068		 |$LN10@AllocateMe|

; 821  : 
; 822  :         } else if ( !fNoBlock &&
; 823  :                     pfRequestingAbort != NULL ) {

  00068	e3570000	 cmp         r7, #0
  0006c	1a00002a	 bne         |$LN8@AllocateMe|
  00070	e59d7020	 ldr         r7, [sp, #0x20]
  00074	e3570000	 cmp         r7, #0
  00078	0a000027	 beq         |$LN8@AllocateMe|
  0007c	e3a0a001	 mov         r10, #1
  00080		 |$LL7@AllocateMe|

; 824  :             //
; 825  :             // Caller requested block for memory 
; 826  :             //
; 827  :         #ifdef DEBUG
; 828  :             DWORD dwStartBlockTickCount = GetTickCount();
; 829  :         #endif // DEBUG
; 830  :             do {
; 831  :                 LeaveCriticalSection(&m_csLock);

  00080	e2840010	 add         r0, r4, #0x10
  00084	eb000000	 bl          LeaveCriticalSection

; 832  : 
; 833  :                 if ( *pfRequestingAbort == FALSE ) {

  00088	e5973000	 ldr         r3, [r7]
  0008c	e3530000	 cmp         r3, #0
  00090	1a000006	 bne         |$LN3@AllocateMe|

; 834  :                     m_fHasBlocked = TRUE;
; 835  :                     WaitForSingleObject(m_hFreeMemEvent, CPHYSMEM_BLOCK_FOR_MEM_INTERVAL );

  00094	e594002c	 ldr         r0, [r4, #0x2C]
  00098	e3e01000	 mvn         r1, #0
  0009c	e584a030	 str         r10, [r4, #0x30]
  000a0	eb000000	 bl          WaitForSingleObject

; 836  : 
; 837  :                     if ( *pfRequestingAbort ) {

  000a4	e5973000	 ldr         r3, [r7]
  000a8	e3530000	 cmp         r3, #0
  000ac	1a00001c	 bne         |$LN27@AllocateMe|
  000b0		 |$LN3@AllocateMe|

; 838  :                         *pVirtAddr = NULL;
; 839  :                         return FALSE;
; 840  :                     }
; 841  : 
; 842  :                     // if this fails, we've been waiting for memory too long
; 843  :                     DEBUGCHK( GetTickCount() - dwStartBlockTickCount < CPHYSMEM_DEBUG_MAXIMUM_BLOCK_TIME );
; 844  :                 }
; 845  : 
; 846  :                 EnterCriticalSection(&m_csLock);

  000b0	e2840010	 add         r0, r4, #0x10
  000b4	eb000000	 bl          EnterCriticalSection

; 847  : 
; 848  :                 pNode = FindFreeBlock(dwSize, fHighPri);

  000b8	e3a02000	 mov         r2, #0
  000bc	e1a01009	 mov         r1, r9
  000c0	e1a00004	 mov         r0, r4
  000c4	eb000000	 bl          |?FindFreeBlock@CPhysMem@@AAAPAUtMEMLIST@@KH@Z|
  000c8	e1b05000	 movs        r5, r0

; 849  :             } while ( pNode == NULL );

  000cc	0affffeb	 beq         |$LL7@AllocateMe|
  000d0		 |$LN2@AllocateMe|

; 854  :             *pVirtAddr = NULL;
; 855  :             return FALSE;
; 856  :         }
; 857  :     }
; 858  : 
; 859  :     // case pNode == NULL should have been handled above
; 860  : 
; 861  :     if ( pNode->dwSize - dwSize >= CPHYSMEM_MEMORY_ALIGNMENT) {

  000d0	e5953008	 ldr         r3, [r5, #8]
  000d4	e0431009	 sub         r1, r3, r9
  000d8	e3510020	 cmp         r1, #0x20
  000dc	3a00000a	 bcc         |$LN1@AllocateMe|

; 862  :         // There's enough left over to create a new block.
; 863  :         PMEMLIST pNodeNew = CreateNewNode(pNode->dwSize - dwSize,
; 864  :                                           pNode->dwVirtAddr + dwSize, 
; 865  :                                           pNode->dwPhysAddr + dwSize);

  000e0	e5953004	 ldr         r3, [r5, #4]
  000e4	e5952000	 ldr         r2, [r5]
  000e8	e1a00004	 mov         r0, r4
  000ec	e0833009	 add         r3, r3, r9
  000f0	e0822009	 add         r2, r2, r9
  000f4	eb000000	 bl          |?CreateNewNode@CPhysMem@@AAAPAUtMEMLIST@@KKK@Z|
  000f8	e1a01000	 mov         r1, r0

; 866  :     #ifdef DEBUG
; 867  :         _tcscpy( pNodeNew->szDescription, pNode->szDescription );
; 868  :     #endif // DEBUG
; 869  :         AddNodeToFreeList(pNodeNew, fHighPri);

  000fc	e1a00004	 mov         r0, r4
  00100	e1a02006	 mov         r2, r6
  00104	eb000000	 bl          |?AddNodeToFreeList@CPhysMem@@AAAHPAUtMEMLIST@@H@Z|

; 870  : 
; 871  :         pNode->dwSize = dwSize; // remember to resize old block

  00108	e5859008	 str         r9, [r5, #8]
  0010c		 |$LN1@AllocateMe|

; 872  :     }
; 873  : 
; 874  : #ifdef DEBUG
; 875  :     // add description to block
; 876  :     DEBUGCHK( _tcslen( pszMemDescription ) < CPHYSMEM_MAX_DEBUG_NODE_DESCRIPTION_LENGTH );
; 877  :     _tcscpy( pNode->szDescription, pszMemDescription );
; 878  :     // trash the memory before we return it to caller
; 879  :     memset( PUCHAR( pNode->dwVirtAddr ), GARBAGE, pNode->dwSize );
; 880  : #endif // DEBUG
; 881  : 
; 882  :     DEBUGMSG(ZONE_CPHYSMEM, (TEXT("CPhysMem AllocateMemory : PA = 0x%08X, VA = 0x%08X, Size = %d, Desc = %s\r\n"),
; 883  :                           pNode->dwPhysAddr, pNode->dwVirtAddr, pNode->dwSize, pNode->szDescription ) );
; 884  : 
; 885  :     // mark this node used
; 886  :     InsertNodeBefore(pNode, FirstNode(INUSELIST(fHighPri)));

  0010c	e3560000	 cmp         r6, #0
  00110	0a000006	 beq         |$LN18@AllocateMe|
  00114	e5943070	 ldr         r3, [r4, #0x70]
  00118	ea000005	 b           |$LN19@AllocateMe|
  0011c		 |$LN8@AllocateMe|

; 850  :             // rest of processing done below
; 851  :         } else {
; 852  :             DEBUGMSG( ZONE_WARNING, (TEXT("CPhysMem AllocateMemory : No memory available") ));
; 853  :             LeaveCriticalSection(&m_csLock);

  0011c	e2840010	 add         r0, r4, #0x10
  00120	eb000000	 bl          LeaveCriticalSection
  00124		 |$LN27@AllocateMe|
  00124	e3a03000	 mov         r3, #0
  00128	e3a00000	 mov         r0, #0
  0012c	ea00000b	 b           |$LN29@AllocateMe|
  00130		 |$LN18@AllocateMe|

; 872  :     }
; 873  : 
; 874  : #ifdef DEBUG
; 875  :     // add description to block
; 876  :     DEBUGCHK( _tcslen( pszMemDescription ) < CPHYSMEM_MAX_DEBUG_NODE_DESCRIPTION_LENGTH );
; 877  :     _tcscpy( pNode->szDescription, pszMemDescription );
; 878  :     // trash the memory before we return it to caller
; 879  :     memset( PUCHAR( pNode->dwVirtAddr ), GARBAGE, pNode->dwSize );
; 880  : #endif // DEBUG
; 881  : 
; 882  :     DEBUGMSG(ZONE_CPHYSMEM, (TEXT("CPhysMem AllocateMemory : PA = 0x%08X, VA = 0x%08X, Size = %d, Desc = %s\r\n"),
; 883  :                           pNode->dwPhysAddr, pNode->dwVirtAddr, pNode->dwSize, pNode->szDescription ) );
; 884  : 
; 885  :     // mark this node used
; 886  :     InsertNodeBefore(pNode, FirstNode(INUSELIST(fHighPri)));

  00130	e5943060	 ldr         r3, [r4, #0x60]
  00134		 |$LN19@AllocateMe|
  00134	e593200c	 ldr         r2, [r3, #0xC]

; 887  : 
; 888  :     VALIDATE_HEAPS(fHighPri);
; 889  : 
; 890  :     LeaveCriticalSection(&m_csLock);

  00138	e2840010	 add         r0, r4, #0x10
  0013c	e5923010	 ldr         r3, [r2, #0x10]
  00140	e583500c	 str         r5, [r3, #0xC]
  00144	e5923010	 ldr         r3, [r2, #0x10]
  00148	e585200c	 str         r2, [r5, #0xC]
  0014c	e5853010	 str         r3, [r5, #0x10]
  00150	e5825010	 str         r5, [r2, #0x10]
  00154	eb000000	 bl          LeaveCriticalSection

; 891  : 
; 892  :     DEBUGCHK( pNode->dwPhysAddr % CPHYSMEM_MEMORY_ALIGNMENT == 0 );
; 893  :     *pVirtAddr = PUCHAR( pNode->dwVirtAddr );

  00158	e5953000	 ldr         r3, [r5]

; 894  :     return TRUE;

  0015c	e3a00001	 mov         r0, #1
  00160		 |$LN29@AllocateMe|
  00160	e5883000	 str         r3, [r8]

; 895  : }

  00164	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00168	e12fff1e	 bx          lr
  0016c		 |$M34305|

			 ENDP  ; |?AllocateMemory@CPhysMem@@QAAHKQAPAEKPAH@Z|, CPhysMem::AllocateMemory

	EXPORT	|?FreeMemory@CPhysMem@@QAAXQAEKK@Z|	; CPhysMem::FreeMemory
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T34347| DCD	|$LN29@FreeMemory|
	DCD	0x40003a01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cphysmem.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FreeMemory@CPhysMem@@QAAXQAEKK@Z| PROC ; CPhysMem::FreeMemory

; 915  : {

  00000		 |$LN29@FreeMemory|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M34344|
  00004	e1a08002	 mov         r8, r2
  00008	e1a09001	 mov         r9, r1
  0000c	e1a04000	 mov         r4, r0
  00010	e3a0a000	 mov         r10, #0
  00014		 |$LL22@FreeMemory|

; 916  :     // for now, only the following sets of flags should be passed in
; 917  :     DEBUGCHK( dwFlags == 0 || // low priority, allow blocking
; 918  :               dwFlags == CPHYSMEM_FLAG_NOBLOCK || // low priority, no blocking
; 919  :               dwFlags == (CPHYSMEM_FLAG_HIGHPRIORITY | CPHYSMEM_FLAG_NOBLOCK) ); // high pri, no blocking
; 920  : 
; 921  :     BOOL fRemoved = FALSE;
; 922  :     BOOL fHighPri = !!(dwFlags & CPHYSMEM_FLAG_HIGHPRIORITY);

  00014	e3130001	 tst         r3, #1
  00018	13a06001	 movne       r6, #1

; 923  : 
; 924  :     // caller of FreeMemory is capable of calling
; 925  :     // PaToVa or VaToPa if they need to. Also, 
; 926  :     // we shouldn't be called to free NULL memory.
; 927  :     DEBUGCHK( virtAddr != NULL && physAddr != 0 ); 
; 928  :     DEBUGCHK( virtAddr == PaToVa( physAddr ) );
; 929  :     DEBUGCHK( physAddr % CPHYSMEM_MEMORY_ALIGNMENT == 0 );
; 930  : 
; 931  :     EnterCriticalSection(&m_csLock);

  0001c	e2840010	 add         r0, r4, #0x10
  00020	03a06000	 moveq       r6, #0
  00024	e3a07000	 mov         r7, #0
  00028	eb000000	 bl          EnterCriticalSection

; 932  : 
; 933  :     PMEMLIST pNode = FirstNode(INUSELIST(fHighPri));

  0002c	e3560000	 cmp         r6, #0
  00030	15943070	 ldrne       r3, [r4, #0x70]
  00034	05943060	 ldreq       r3, [r4, #0x60]
  00038	e593500c	 ldr         r5, [r3, #0xC]
  0003c		 |$LL5@FreeMemory|

; 934  :     
; 935  :     DEBUGMSG( ZONE_CPHYSMEM && ZONE_VERBOSE, (TEXT("CPhysMem: Heap pri = %d before free VA = 0x%08x:\n"), fHighPri, virtAddr ) );
; 936  :     VALIDATE_HEAPS(fHighPri);
; 937  : 
; 938  :     //
; 939  :     // Walk the list looking for this block
; 940  :     //
; 941  :     while (!EndOfList(INUSELIST(fHighPri), pNode)) {

  0003c	e3560000	 cmp         r6, #0
  00040	15943070	 ldrne       r3, [r4, #0x70]
  00044	05943060	 ldreq       r3, [r4, #0x60]
  00048	e1530005	 cmp         r3, r5
  0004c	0a000014	 beq         |$LN4@FreeMemory|

; 942  : 
; 943  :         if ((pNode->dwVirtAddr == (DWORD) virtAddr) &&
; 944  :             (pNode->dwPhysAddr == (DWORD) physAddr)) {

  00050	e5953000	 ldr         r3, [r5]
  00054	e1530009	 cmp         r3, r9
  00058	1a000002	 bne         |$LN3@FreeMemory|
  0005c	e5953004	 ldr         r3, [r5, #4]
  00060	e1530008	 cmp         r3, r8
  00064	0a000001	 beq         |$LN25@FreeMemory|
  00068		 |$LN3@FreeMemory|

; 961  :             break;
; 962  :         }
; 963  :         pNode = pNode->next;

  00068	e595500c	 ldr         r5, [r5, #0xC]

; 964  :     }

  0006c	eafffff2	 b           |$LL5@FreeMemory|
  00070		 |$LN25@FreeMemory|

; 945  :             
; 946  :         #ifdef DEBUG
; 947  :             // trash this memory
; 948  :             DEBUGCHK( pNode->dwSize > 0 ); // otherwise, why are we calling FreeMemory??
; 949  :             memset( PUCHAR( pNode->dwVirtAddr ), GARBAGE, pNode->dwSize );
; 950  : 
; 951  :             DEBUGMSG(ZONE_CPHYSMEM, 
; 952  :                      (TEXT("CPhysMem FreeMemory : PA = 0x%08X, VA = 0x%08X, Size = %d, Desc = %s\r\n"),
; 953  :                      pNode->dwPhysAddr, pNode->dwVirtAddr, pNode->dwSize, pNode->szDescription ));
; 954  : 
; 955  :             // change description
; 956  :             _tcscpy( pNode->szDescription, TEXT("Freed Memory") );
; 957  :         #endif // DEBUG
; 958  :             RemoveNode(pNode);

  00070	e5950010	 ldr         r0, [r5, #0x10]
  00074	e595300c	 ldr         r3, [r5, #0xC]

; 959  :             AddNodeToFreeList(pNode, fHighPri);

  00078	e1a02006	 mov         r2, r6
  0007c	e1a01005	 mov         r1, r5
  00080	e580300c	 str         r3, [r0, #0xC]
  00084	e595e00c	 ldr         lr, [r5, #0xC]
  00088	e5953010	 ldr         r3, [r5, #0x10]
  0008c	e1a00004	 mov         r0, r4
  00090	e58e3010	 str         r3, [lr, #0x10]
  00094	e585a00c	 str         r10, [r5, #0xC]
  00098	e585a010	 str         r10, [r5, #0x10]
  0009c	eb000000	 bl          |?AddNodeToFreeList@CPhysMem@@AAAHPAUtMEMLIST@@H@Z|

; 960  :             fRemoved = TRUE;

  000a0	e3a07001	 mov         r7, #1
  000a4		 |$LN4@FreeMemory|

; 965  :     
; 966  :     if (fHighPri && !fRemoved) {

  000a4	e3560000	 cmp         r6, #0
  000a8	0a000005	 beq         |$LN2@FreeMemory|
  000ac	e3570000	 cmp         r7, #0
  000b0	1a000003	 bne         |$LN2@FreeMemory|

; 967  :         LeaveCriticalSection(&m_csLock);

  000b4	e2840010	 add         r0, r4, #0x10
  000b8	eb000000	 bl          LeaveCriticalSection

; 968  : 
; 969  :         //
; 970  :         // Try removing from normal region.
; 971  :         //
; 972  :         DEBUGCHK( dwFlags == ( CPHYSMEM_FLAG_HIGHPRIORITY | CPHYSMEM_FLAG_NOBLOCK ) );
; 973  :         FreeMemory( virtAddr,
; 974  :                     physAddr,
; 975  :                     CPHYSMEM_FLAG_NOBLOCK ); // dwFlags & ~CPHYSMEM_FLAG_HIGHPRIORITY

  000bc	e3a03002	 mov         r3, #2
  000c0	eaffffd3	 b           |$LL22@FreeMemory|
  000c4		 |$LN2@FreeMemory|

; 976  :         return;
; 977  :     }
; 978  :     DEBUGCHK( fRemoved );
; 979  :     
; 980  :     DEBUGMSG( ZONE_CPHYSMEM && ZONE_VERBOSE, (TEXT("CPhysMem: Heap pri = %d after free VA = 0x%08x:\n"), fHighPri, virtAddr ) );
; 981  :     VALIDATE_HEAPS(fHighPri);
; 982  : 
; 983  :     LeaveCriticalSection(&m_csLock);

  000c4	e2840010	 add         r0, r4, #0x10
  000c8	eb000000	 bl          LeaveCriticalSection

; 984  : 
; 985  :     //
; 986  :     // Signal everyone waiting for memory that some just became available.
; 987  :     //
; 988  :     if (m_fHasBlocked)

  000cc	e5943030	 ldr         r3, [r4, #0x30]
  000d0	e3530000	 cmp         r3, #0

; 989  :         PulseEvent(m_hFreeMemEvent);

  000d4	1594002c	 ldrne       r0, [r4, #0x2C]
  000d8	13a01001	 movne       r1, #1
  000dc	1b000000	 blne        EventModify

; 990  : }

  000e0	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  000e4	e12fff1e	 bx          lr
  000e8		 |$M34345|

			 ENDP  ; |?FreeMemory@CPhysMem@@QAAXQAEKK@Z|, CPhysMem::FreeMemory

	EXPORT	|?ReleaseBlockedCalls@CPhysMem@@QAAHXZ|	; CPhysMem::ReleaseBlockedCalls
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T34361| DCD	|$LN8@ReleaseBlo|
	DCD	0x40000901
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cphysmem.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ReleaseBlockedCalls@CPhysMem@@QAAHXZ| PROC ; CPhysMem::ReleaseBlockedCalls

; 998  : {

  00000		 |$LN8@ReleaseBlo|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M34358|

; 999  :     //
; 1000 :     // Signal everyone waiting for memory to check if they have been aborted.
; 1001 :     //
; 1002 :     if (m_fHasBlocked)

  00004	e5903030	 ldr         r3, [r0, #0x30]
  00008	e3530000	 cmp         r3, #0

; 1003 :         PulseEvent(m_hFreeMemEvent);

  0000c	1590002c	 ldrne       r0, [r0, #0x2C]
  00010	13a01001	 movne       r1, #1
  00014	1b000000	 blne        EventModify

; 1004 :     
; 1005 :     return(TRUE);

  00018	e3a00001	 mov         r0, #1

; 1006 : }

  0001c	e49de004	 ldr         lr, [sp], #4
  00020	e12fff1e	 bx          lr
  00024		 |$M34359|

			 ENDP  ; |?ReleaseBlockedCalls@CPhysMem@@QAAHXZ|, CPhysMem::ReleaseBlockedCalls

	EXPORT	|?ReInit@CPhysMem@@QAAXXZ|		; CPhysMem::ReInit
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cphysmem.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T34416| DCD	|$LN34@ReInit|
	DCD	0x40006901
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cphysmem.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ReInit@CPhysMem@@QAAXXZ| PROC	; CPhysMem::ReInit

; 173  : {

  00000		 |$LN34@ReInit|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M34413|
  00004	e1a04000	 mov         r4, r0

; 174  :     PMEMLIST pNode;
; 175  :     EnterCriticalSection(&m_csLock);

  00008	e2840010	 add         r0, r4, #0x10
  0000c	eb000000	 bl          EnterCriticalSection

; 176  :     //
; 177  :     // Create dummy entries for the list head (simpler linked list code)
; 178  :     //
; 179  :     m_pNodeFreeListHead = CreateNewNode(0, 0, 0);

  00010	e3a03000	 mov         r3, #0
  00014	e3a02000	 mov         r2, #0
  00018	e3a01000	 mov         r1, #0
  0001c	e1a00004	 mov         r0, r4
  00020	eb000000	 bl          |?CreateNewNode@CPhysMem@@AAAPAUtMEMLIST@@KKK@Z|
  00024	e3500000	 cmp         r0, #0
  00028	e5840040	 str         r0, [r4, #0x40]

; 180  :     if (m_pNodeFreeListHead) InitializeListHead(m_pNodeFreeListHead);

  0002c	15800010	 strne       r0, [r0, #0x10]
  00030	1580000c	 strne       r0, [r0, #0xC]

; 181  : 
; 182  :     DEBUGMSG(ZONE_CPHYSMEM && ZONE_VERBOSE, (TEXT("CPhysMem Init : NodeFreeListHead = 0x%08X\r\n"),
; 183  :                           m_pNodeFreeListHead));
; 184  :     
; 185  :     m_pFreeListHead = CreateNewNode(0, 0, 0);

  00034	e1a00004	 mov         r0, r4
  00038	e3a03000	 mov         r3, #0
  0003c	e3a02000	 mov         r2, #0
  00040	e3a01000	 mov         r1, #0
  00044	eb000000	 bl          |?CreateNewNode@CPhysMem@@AAAPAUtMEMLIST@@KKK@Z|
  00048	e3500000	 cmp         r0, #0
  0004c	e584005c	 str         r0, [r4, #0x5C]

; 186  :     if (m_pFreeListHead) InitializeListHead(m_pFreeListHead);

  00050	15800010	 strne       r0, [r0, #0x10]
  00054	1580000c	 strne       r0, [r0, #0xC]

; 187  : 
; 188  :     m_pInUseListHead = CreateNewNode(0, 0, 0);

  00058	e1a00004	 mov         r0, r4
  0005c	e3a03000	 mov         r3, #0
  00060	e3a02000	 mov         r2, #0
  00064	e3a01000	 mov         r1, #0
  00068	eb000000	 bl          |?CreateNewNode@CPhysMem@@AAAPAUtMEMLIST@@KKK@Z|
  0006c	e3500000	 cmp         r0, #0
  00070	e5840060	 str         r0, [r4, #0x60]

; 189  :     if (m_pInUseListHead) InitializeListHead(m_pInUseListHead);

  00074	15800010	 strne       r0, [r0, #0x10]
  00078	1580000c	 strne       r0, [r0, #0xC]

; 190  :     
; 191  : 
; 192  :     DEBUGMSG(ZONE_CPHYSMEM && ZONE_VERBOSE, (TEXT("CPhysMem Init : FreeListHead = 0x%08X, InUseListHead = 0x%08X\r\n"), m_pFreeListHead, m_pInUseListHead));
; 193  : 
; 194  :     m_pHighPriorityFreeListHead = CreateNewNode(0, 0, 0);

  0007c	e1a00004	 mov         r0, r4
  00080	e3a03000	 mov         r3, #0
  00084	e3a02000	 mov         r2, #0
  00088	e3a01000	 mov         r1, #0
  0008c	eb000000	 bl          |?CreateNewNode@CPhysMem@@AAAPAUtMEMLIST@@KKK@Z|
  00090	e3500000	 cmp         r0, #0
  00094	e5840074	 str         r0, [r4, #0x74]

; 195  :     if (m_pHighPriorityFreeListHead) InitializeListHead(m_pHighPriorityFreeListHead);

  00098	15800010	 strne       r0, [r0, #0x10]
  0009c	1580000c	 strne       r0, [r0, #0xC]

; 196  : 
; 197  :     m_pHighPriorityInUseListHead = CreateNewNode(0, 0, 0);

  000a0	e1a00004	 mov         r0, r4
  000a4	e3a03000	 mov         r3, #0
  000a8	e3a02000	 mov         r2, #0
  000ac	e3a01000	 mov         r1, #0
  000b0	eb000000	 bl          |?CreateNewNode@CPhysMem@@AAAPAUtMEMLIST@@KKK@Z|
  000b4	e3500000	 cmp         r0, #0
  000b8	e5840070	 str         r0, [r4, #0x70]

; 198  :     if (m_pHighPriorityInUseListHead) InitializeListHead(m_pHighPriorityInUseListHead);

  000bc	15800010	 strne       r0, [r0, #0x10]
  000c0	1580000c	 strne       r0, [r0, #0xC]

; 199  : 
; 200  :     DEBUGMSG(ZONE_CPHYSMEM && ZONE_VERBOSE, (TEXT("CPhysMem Init : HighPriFreeListHead = 0x%08X, HighPriInUseListHead = 0x%08X\r\n"),
; 201  :                           m_pHighPriorityFreeListHead, m_pHighPriorityInUseListHead));
; 202  : 
; 203  :     // Send an alert if we're being constructed under OOM conditions.
; 204  :     m_fInitted =
; 205  :         (m_pNodeFreeListHead && m_pFreeListHead && m_pInUseListHead &&
; 206  :          m_pHighPriorityFreeListHead && m_pHighPriorityInUseListHead);

  000c4	e5943040	 ldr         r3, [r4, #0x40]
  000c8	e3530000	 cmp         r3, #0
  000cc	0a00000b	 beq         |$LN12@ReInit|
  000d0	e594305c	 ldr         r3, [r4, #0x5C]
  000d4	e3530000	 cmp         r3, #0
  000d8	0a000008	 beq         |$LN12@ReInit|
  000dc	e5943060	 ldr         r3, [r4, #0x60]
  000e0	e3530000	 cmp         r3, #0
  000e4	0a000005	 beq         |$LN12@ReInit|
  000e8	e5943074	 ldr         r3, [r4, #0x74]
  000ec	e3530000	 cmp         r3, #0
  000f0	15943070	 ldrne       r3, [r4, #0x70]
  000f4	13530000	 cmpne       r3, #0
  000f8	13a0e001	 movne       lr, #1
  000fc	1a000000	 bne         |$LN13@ReInit|
  00100		 |$LN12@ReInit|
  00100	e3a0e000	 mov         lr, #0
  00104		 |$LN13@ReInit|

; 207  : 
; 208  :     //
; 209  :     // One big chunk on the free list to start things off.
; 210  :     //
; 211  :     pNode = CreateNewNode(m_dwNormalSize, m_dwNormalVA, m_dwNormalPA);

  00104	e5943050	 ldr         r3, [r4, #0x50]
  00108	e5942054	 ldr         r2, [r4, #0x54]
  0010c	e5941058	 ldr         r1, [r4, #0x58]
  00110	e1a00004	 mov         r0, r4
  00114	e584e024	 str         lr, [r4, #0x24]
  00118	eb000000	 bl          |?CreateNewNode@CPhysMem@@AAAPAUtMEMLIST@@KKK@Z|
  0011c	e3500000	 cmp         r0, #0
  00120	e3a05000	 mov         r5, #0

; 212  :     if (pNode) {

  00124	0a000008	 beq         |$LN4@ReInit|

; 213  : #ifdef DEBUG
; 214  :         _tcscpy( pNode->szDescription, TEXT("Free Low Pri Mem") );
; 215  : #endif // DEBUG
; 216  :     
; 217  :         DEBUGMSG(ZONE_CPHYSMEM && ZONE_VERBOSE, (TEXT("CPhysMem Init : Main Free Heap Node = 0x%08X\r\n"), pNode));
; 218  :     
; 219  :         InsertNodeBefore(pNode, FirstNode(m_pFreeListHead));

  00128	e594305c	 ldr         r3, [r4, #0x5C]
  0012c	e593200c	 ldr         r2, [r3, #0xC]
  00130	e5923010	 ldr         r3, [r2, #0x10]
  00134	e583000c	 str         r0, [r3, #0xC]
  00138	e5923010	 ldr         r3, [r2, #0x10]
  0013c	e580200c	 str         r2, [r0, #0xC]
  00140	e5803010	 str         r3, [r0, #0x10]
  00144	e5820010	 str         r0, [r2, #0x10]

; 220  : 
; 221  :         VALIDATE_HEAPS(FALSE);
; 222  :     } else

  00148	ea000000	 b           |$LN3@ReInit|
  0014c		 |$LN4@ReInit|

; 223  :         m_fInitted = FALSE;

  0014c	e5845024	 str         r5, [r4, #0x24]
  00150		 |$LN3@ReInit|

; 224  :     
; 225  :     //
; 226  :     // Same thing for High Priority Region
; 227  :     //
; 228  :     pNode = CreateNewNode(m_dwHighPrioritySize, m_dwHighPriorityVA, m_dwHighPriorityPA);

  00150	e5943064	 ldr         r3, [r4, #0x64]
  00154	e5942068	 ldr         r2, [r4, #0x68]
  00158	e594106c	 ldr         r1, [r4, #0x6C]
  0015c	e1a00004	 mov         r0, r4
  00160	eb000000	 bl          |?CreateNewNode@CPhysMem@@AAAPAUtMEMLIST@@KKK@Z|
  00164	e3500000	 cmp         r0, #0

; 229  :     if (pNode) {

  00168	0a000008	 beq         |$LN2@ReInit|

; 230  : #ifdef DEBUG
; 231  :         _tcscpy( pNode->szDescription, TEXT("Free High Pri Mem") );
; 232  : #endif // DEBUG
; 233  :     
; 234  :         DEBUGMSG(ZONE_CPHYSMEM && ZONE_VERBOSE, (TEXT("CPhysMem Init : HighPri Free Heap Node = 0x%08X\r\n"),
; 235  :                                                  pNode));
; 236  :     
; 237  :         InsertNodeBefore(pNode, FirstNode(m_pHighPriorityFreeListHead));

  0016c	e5943074	 ldr         r3, [r4, #0x74]
  00170	e593200c	 ldr         r2, [r3, #0xC]
  00174	e5923010	 ldr         r3, [r2, #0x10]
  00178	e583000c	 str         r0, [r3, #0xC]
  0017c	e5923010	 ldr         r3, [r2, #0x10]
  00180	e580200c	 str         r2, [r0, #0xC]
  00184	e5803010	 str         r3, [r0, #0x10]
  00188	e5820010	 str         r0, [r2, #0x10]

; 238  :     
; 239  :         VALIDATE_HEAPS(TRUE);
; 240  :     } else

  0018c	ea000000	 b           |$LN1@ReInit|
  00190		 |$LN2@ReInit|

; 241  :         m_fInitted = FALSE;

  00190	e5845024	 str         r5, [r4, #0x24]
  00194		 |$LN1@ReInit|

; 242  : 
; 243  :     LeaveCriticalSection(&m_csLock);

  00194	e2840010	 add         r0, r4, #0x10
  00198	eb000000	 bl          LeaveCriticalSection

; 244  : }

  0019c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  001a0	e12fff1e	 bx          lr
  001a4		 |$M34414|

			 ENDP  ; |?ReInit@CPhysMem@@QAAXXZ|, CPhysMem::ReInit

	EXPORT	|??1CPhysMem@@QAA@XZ|			; CPhysMem::~CPhysMem
	IMPORT	|FreePhysMem|
	IMPORT	|CloseHandle|
	IMPORT	|DeleteCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T34424| DCD	|$LN6@CPhysMem|
	DCD	0x40001b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CPhysMem@@QAA@XZ| PROC		; CPhysMem::~CPhysMem

; 631  : {

  00000		 |$LN6@CPhysMem|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M34421|
  00004	e1a04000	 mov         r4, r0

; 632  :     DeleteCriticalSection(&m_csLock);

  00008	e2840010	 add         r0, r4, #0x10
  0000c	eb000000	 bl          DeleteCriticalSection

; 633  :     CloseHandle(m_hFreeMemEvent);

  00010	e594002c	 ldr         r0, [r4, #0x2C]
  00014	eb000000	 bl          CloseHandle

; 634  : 
; 635  :     FreeList(&m_pInUseListHead);

  00018	e2841060	 add         r1, r4, #0x60
  0001c	e1a00004	 mov         r0, r4
  00020	eb000000	 bl          |?FreeList@CPhysMem@@AAAHPAPAUtMEMLIST@@@Z|

; 636  :     FreeList(&m_pFreeListHead);

  00024	e284105c	 add         r1, r4, #0x5C
  00028	e1a00004	 mov         r0, r4
  0002c	eb000000	 bl          |?FreeList@CPhysMem@@AAAHPAPAUtMEMLIST@@@Z|

; 637  :     FreeList(&m_pHighPriorityInUseListHead);

  00030	e2841070	 add         r1, r4, #0x70
  00034	e1a00004	 mov         r0, r4
  00038	eb000000	 bl          |?FreeList@CPhysMem@@AAAHPAPAUtMEMLIST@@@Z|

; 638  :     FreeList(&m_pHighPriorityFreeListHead);

  0003c	e2841074	 add         r1, r4, #0x74
  00040	e1a00004	 mov         r0, r4
  00044	eb000000	 bl          |?FreeList@CPhysMem@@AAAHPAPAUtMEMLIST@@@Z|

; 639  : 
; 640  :     FreeList(&m_pNodeFreeListHead);

  00048	e2841040	 add         r1, r4, #0x40
  0004c	e1a00004	 mov         r0, r4
  00050	eb000000	 bl          |?FreeList@CPhysMem@@AAAHPAPAUtMEMLIST@@@Z|

; 641  : 
; 642  :     if (!m_fPhysFromPlat)

  00054	e5943028	 ldr         r3, [r4, #0x28]
  00058	e3530000	 cmp         r3, #0

; 643  :         FreePhysMem(m_pPhysicalBufferAddr);

  0005c	0594003c	 ldreq       r0, [r4, #0x3C]
  00060	0b000000	 bleq        FreePhysMem

; 644  : }

  00064	e8bd4010	 ldmia       sp!, {r4, lr}
  00068	e12fff1e	 bx          lr
  0006c		 |$M34422|

			 ENDP  ; |??1CPhysMem@@QAA@XZ|, CPhysMem::~CPhysMem

	EXPORT	|??0CPhysMem@@QAA@KKPAE0@Z|		; CPhysMem::CPhysMem
	IMPORT	|InitializeCriticalSection|
	IMPORT	|CreateEventW|
	IMPORT	|AllocPhysMem|
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T34440| DCD	|$LN8@CPhysMem@2|
	DCD	0x40005c02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CPhysMem@@QAA@KKPAE0@Z| PROC	; CPhysMem::CPhysMem

; 58   : {

  00000		 |$LN8@CPhysMem@2|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M34437|
  00008	e3530000	 cmp         r3, #0
  0000c	e1a08002	 mov         r8, r2
  00010	e1a07001	 mov         r7, r1
  00014	e1a06000	 mov         r6, r0
  00018	e59d1020	 ldr         r1, [sp, #0x20]
  0001c	e8860180	 stmia       r6, {r7, r8}
  00020	e586100c	 str         r1, [r6, #0xC]

; 59   : 
; 60   :     ASSERT(cbSize > 0 && cbHighPrioritySize > 0); // must be so or the driver cannot work.
; 61   : 
; 62   :     //
; 63   :     // The PDD can pass in a physical buffer, or we'll try to allocate one from 
; 64   :     // system RAM.
; 65   :     //
; 66   :     if (pVirtAddr && pPhysAddr) {

  00024	13510000	 cmpne       r1, #0

; 67   :         DEBUGMSG(ZONE_INIT,(TEXT("DMA buffer passed in from PDD\r\n")));
; 68   :         m_pPhysicalBufferAddr = pVirtAddr;
; 69   :         m_dwNormalVA = (DWORD) pVirtAddr;
; 70   :         m_dwNormalPA = (DWORD) pPhysAddr;
; 71   :         m_fPhysFromPlat = TRUE;

  00028	13a02001	 movne       r2, #1
  0002c	15862028	 strne       r2, [r6, #0x28]
  00030	e5863008	 str         r3, [r6, #8]
  00034	e3a09000	 mov         r9, #0
  00038	1586303c	 strne       r3, [r6, #0x3C]
  0003c	15863054	 strne       r3, [r6, #0x54]
  00040	15861050	 strne       r1, [r6, #0x50]
  00044	1a000009	 bne         |$LN2@CPhysMem@2|

; 72   :     }
; 73   :     else {
; 74   :         DEBUGMSG(ZONE_INIT,(TEXT("Allocating DMA buffer from system RAM\r\n")));
; 75   : 
; 76   :         m_pPhysicalBufferAddr = (PUCHAR)AllocPhysMem(cbSize,
; 77   :                                              PAGE_READWRITE|PAGE_NOCACHE,
; 78   :                                              0,    // Default alignment
; 79   :                                              0,    // Reserved
; 80   :                                              &m_dwNormalPA);

  00048	e2863050	 add         r3, r6, #0x50
  0004c	e58d3000	 str         r3, [sp]
  00050	e3a03000	 mov         r3, #0
  00054	e3a02000	 mov         r2, #0
  00058	e3a01f81	 mov         r1, #0x81, 30
  0005c	e1a00007	 mov         r0, r7
  00060	eb000000	 bl          AllocPhysMem
  00064	e586003c	 str         r0, [r6, #0x3C]

; 81   :         
; 82   :         m_dwNormalVA = (DWORD) m_pPhysicalBufferAddr;

  00068	e5860054	 str         r0, [r6, #0x54]

; 83   :         m_fPhysFromPlat = FALSE;

  0006c	e5869028	 str         r9, [r6, #0x28]
  00070		 |$LN2@CPhysMem@2|

; 84   :     }
; 85   :     {   // we want all blocks to have their Phys Addr divisible by
; 86   :         // CPHYSMEM_MEMORY_ALIGNMENT. To achieve this, we start off
; 87   :         // having the physical memory block aligned properly, and
; 88   :         // then allocate memory only in blocks divisible by 
; 89   :         // CPHYSMEM_MEMORY_ALIGNMENT
; 90   :         const DWORD dwOffset = m_dwNormalPA & (CPHYSMEM_MEMORY_ALIGNMENT - 1);

  00070	e5963050	 ldr         r3, [r6, #0x50]
  00074	e213001f	 ands        r0, r3, #0x1F

; 91   :         DEBUGCHK( dwOffset == m_dwNormalPA % CPHYSMEM_MEMORY_ALIGNMENT );
; 92   :         DEBUGCHK( cbSize > CPHYSMEM_MEMORY_ALIGNMENT );
; 93   :         if ( dwOffset != 0 ) {

  00078	0a000008	 beq         |$LN1@CPhysMem@2|

; 94   :             // skip over the first few bytes of memory, as it is not
; 95   :             // aligned properly. This shouldn't happen though, because
; 96   :             // the new memory should have been aligned on a page boundary
; 97   :             DEBUGCHK( 0 );
; 98   :             // we can't code -= dwOffset because then we'll enter
; 99   :             // memory that we don't own.
; 100  :             m_dwNormalVA += CPHYSMEM_MEMORY_ALIGNMENT - dwOffset;

  0007c	e5962054	 ldr         r2, [r6, #0x54]

; 101  :             m_dwNormalPA += CPHYSMEM_MEMORY_ALIGNMENT - dwOffset;

  00080	e0433000	 sub         r3, r3, r0
  00084	e2831020	 add         r1, r3, #0x20
  00088	e0423000	 sub         r3, r2, r0
  0008c	e2833020	 add         r3, r3, #0x20

; 102  :             cbSize -= CPHYSMEM_MEMORY_ALIGNMENT - dwOffset;

  00090	e0802007	 add         r2, r0, r7
  00094	e5863054	 str         r3, [r6, #0x54]
  00098	e5861050	 str         r1, [r6, #0x50]
  0009c	e2427020	 sub         r7, r2, #0x20
  000a0		 |$LN1@CPhysMem@2|

; 103  :         }
; 104  :     }
; 105  :     
; 106  :     m_dwTotalPhysMemSize = cbSize;
; 107  :     m_PaVaConversion = m_dwNormalPA - m_dwNormalVA;

  000a0	e5961054	 ldr         r1, [r6, #0x54]
  000a4	e5965050	 ldr         r5, [r6, #0x50]

; 108  :     
; 109  :     DEBUGMSG(ZONE_INIT,
; 110  :         (TEXT("CPhysMem   Total Alloc Region PhysAddr = 0x%08X, VirtAddr = 0x%08X, size = %d\r\n"),
; 111  :         m_dwNormalPA, m_dwNormalVA, m_dwTotalPhysMemSize));
; 112  : 
; 113  :     //
; 114  :     // Set aside a page for the special request.
; 115  :     //
; 116  :     m_dwSpecialVA = (DWORD) m_dwNormalVA;
; 117  :     m_dwSpecialPA = (DWORD) m_dwNormalPA;
; 118  :     m_dwNormalVA += USBPAGESIZE;
; 119  :     m_dwNormalPA += USBPAGESIZE;
; 120  :     cbSize -= USBPAGESIZE;
; 121  :     m_bSpecialTaken = FALSE;
; 122  :     memset((PVOID) m_dwSpecialVA, 0x00, USBPAGESIZE);

  000a8	e3a02a01	 mov         r2, #1, 20
  000ac	e286c048	 add         r12, r6, #0x48
  000b0	e88c0202	 stmia       r12, {r1, r9}
  000b4	e5960048	 ldr         r0, [r6, #0x48]
  000b8	e0453001	 sub         r3, r5, r1
  000bc	e281ea01	 add         lr, r1, #1, 20
  000c0	e2854a01	 add         r4, r5, #1, 20
  000c4	e3a01000	 mov         r1, #0
  000c8	e286c034	 add         r12, r6, #0x34
  000cc	e88c0088	 stmia       r12, {r3, r7}
  000d0	e5865044	 str         r5, [r6, #0x44]
  000d4	e286c050	 add         r12, r6, #0x50
  000d8	e88c4010	 stmia       r12, {r4, lr}
  000dc	eb000000	 bl          memset

; 123  : 
; 124  :     DEBUGMSG(ZONE_INIT,
; 125  :         (TEXT("CPhysMem Special Alloc Region PhysAddr = 0x%08X, VirtAddr = 0x%08X, size = %d\r\n"),
; 126  :         m_dwSpecialPA, m_dwSpecialVA, USBPAGESIZE));
; 127  : 
; 128  :     //
; 129  :     // Set aside the High Priority region.
; 130  :     //
; 131  :     m_dwHighPriorityVA = (DWORD) m_dwNormalVA;
; 132  :     m_dwHighPriorityPA = (DWORD) m_dwNormalPA;
; 133  :     m_dwNormalVA += cbHighPrioritySize;
; 134  :     m_dwNormalPA += cbHighPrioritySize;
; 135  :     cbSize -= cbHighPrioritySize;
; 136  :     m_dwHighPrioritySize = cbHighPrioritySize;
; 137  :     memset((PVOID) m_dwHighPriorityVA, 0x00, m_dwHighPrioritySize);

  000e0	e1a02008	 mov         r2, r8
  000e4	e3a01000	 mov         r1, #0
  000e8	e5963054	 ldr         r3, [r6, #0x54]
  000ec	e5964050	 ldr         r4, [r6, #0x50]
  000f0	e286c068	 add         r12, r6, #0x68
  000f4	e88c0108	 stmia       r12, {r3, r8}
  000f8	e0833008	 add         r3, r3, r8
  000fc	e084e008	 add         lr, r4, r8
  00100	e5960068	 ldr         r0, [r6, #0x68]
  00104	e5864064	 str         r4, [r6, #0x64]
  00108	e5863054	 str         r3, [r6, #0x54]
  0010c	e586e050	 str         lr, [r6, #0x50]
  00110	eb000000	 bl          memset
  00114	e0473008	 sub         r3, r7, r8

; 138  : 
; 139  :     DEBUGMSG(ZONE_INIT,
; 140  :         (TEXT("CPhysMem HighPri Alloc Region PhysAddr = 0x%08X, VirtAddr = 0x%08X, size = %d\r\n"),
; 141  :         m_dwHighPriorityPA, m_dwHighPriorityVA, m_dwHighPrioritySize));
; 142  : 
; 143  :     //
; 144  :     // And the rest is for normal allocations.
; 145  :     //
; 146  :     m_dwNormalSize = cbSize;
; 147  :     memset((PVOID) m_dwNormalVA, 0x00, m_dwNormalSize);

  00118	e5960054	 ldr         r0, [r6, #0x54]
  0011c	e2433a01	 sub         r3, r3, #1, 20
  00120	e1a02003	 mov         r2, r3
  00124	e3a01000	 mov         r1, #0
  00128	e5863058	 str         r3, [r6, #0x58]
  0012c	eb000000	 bl          memset

; 148  :     
; 149  :     DEBUGMSG(ZONE_INIT,
; 150  :         (TEXT("CPhysMem  Normal Alloc Region PhysAddr = 0x%08X, VirtAddr = 0x%08X, size = %d\r\n"),
; 151  :         m_dwNormalPA, m_dwNormalVA, m_dwNormalSize));
; 152  : 
; 153  : 
; 154  : 
; 155  :     m_hFreeMemEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

  00130	e3a03000	 mov         r3, #0
  00134	e3a02000	 mov         r2, #0
  00138	e3a01001	 mov         r1, #1
  0013c	e3a00000	 mov         r0, #0
  00140	eb000000	 bl          CreateEventW
  00144	e1a03000	 mov         r3, r0

; 156  :     m_fHasBlocked = FALSE;
; 157  :     InitializeCriticalSection(&m_csLock);

  00148	e2860010	 add         r0, r6, #0x10
  0014c	e286c02c	 add         r12, r6, #0x2C
  00150	e88c0208	 stmia       r12, {r3, r9}
  00154	eb000000	 bl          InitializeCriticalSection

; 158  : 
; 159  :     ReInit();

  00158	e1a00006	 mov         r0, r6
  0015c	eb000000	 bl          |?ReInit@CPhysMem@@QAAXXZ|

; 160  : 
; 161  : }

  00160	e1a00006	 mov         r0, r6
  00164	e28dd004	 add         sp, sp, #4
  00168	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  0016c	e12fff1e	 bx          lr
  00170		 |$M34438|

			 ENDP  ; |??0CPhysMem@@QAA@KKPAE0@Z|, CPhysMem::CPhysMem

	END
