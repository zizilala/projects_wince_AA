; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\OMAP3530\MUSB\MUSBHCD\PDD\system.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|maxPower| [ DATA ]
	EXPORT	|gc_MUsbFuncs| [ DATA ]
	EXPORT	|dwMaxCurrent| [ DATA ]
	IMPORT	|Host_ProcessDMA|
	IMPORT	|Host_Suspend|
	IMPORT	|Host_Disconnect|
	IMPORT	|Host_Connect|
	IMPORT	|Host_ProcessEPxTx|
	IMPORT	|Host_ProcessEPxRx|
	IMPORT	|Host_ProcessEP0|
	IMPORT	|Host_ResumeIRQ|

  00000			 AREA	 |.data|, DATA
|maxPower| DCD	0x64
|gc_MUsbFuncs| DCD 0x0
	DCD	|Host_ResumeIRQ|
	DCD	|Host_ProcessEP0|
	DCD	|Host_ProcessEPxRx|
	DCD	|Host_ProcessEPxTx|
	DCD	|Host_Connect|
	DCD	|Host_Disconnect|
	DCD	|Host_Suspend|
	DCD	|Host_ProcessDMA|
|dwMaxCurrent| DCD 0x64
	EXPORT	|SetEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T41403| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41400|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M41401|

			 ENDP  ; |SetEvent|

	EXPORT	|HcdPdd_DllMain|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\pdd\system.c

  00000			 AREA	 |.pdata|, PDATA
|$T41412| DCD	|$LN5@HcdPdd_Dll|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_DllMain| PROC

; 85   : {

  00000		 |$LN5@HcdPdd_Dll|
  00000		 |$M41409|

; 86   :     UnusedParameter(hinstDLL);
; 87   :     UnusedParameter(dwReason);
; 88   :     UnusedParameter(lpvReserved);
; 89   : 
; 90   :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 91   : }

  00004	e12fff1e	 bx          lr
  00008		 |$M41410|

			 ENDP  ; |HcdPdd_DllMain|

	EXPORT	|??_C@_1CC@NPEFILDH@?$AAP?$AAh?$AAy?$AAs?$AAi?$AAc?$AAa?$AAl?$AAP?$AAa?$AAg?$AAe?$AAS?$AAi?$AAz?$AAe?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|RegCloseKey|
	IMPORT	|RegQueryValueExW|
	IMPORT	|RegOpenKeyExW|

  00000			 AREA	 |.pdata|, PDATA
|$T41424| DCD	|$LN8@GetRegistr|
	DCD	0x40002602

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@NPEFILDH@?$AAP?$AAh?$AAy?$AAs?$AAi?$AAc?$AAa?$AAl?$AAP?$AAa?$AAg?$AAe?$AAS?$AAi?$AAz?$AAe?$AA?$AA@| DCB "P"
	DCB	0x0, "h", 0x0, "y", 0x0, "s", 0x0, "i", 0x0, "c", 0x0, "a"
	DCB	0x0, "l", 0x0, "P", 0x0, "a", 0x0, "g", 0x0, "e", 0x0, "S"
	DCB	0x0, "i", 0x0, "z", 0x0, "e", 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetRegistryPhysicalMemSize| PROC

; 96   : {

  00000		 |$LN8@GetRegistr|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M41421|
  00008	e1a06001	 mov         r6, r1
  0000c	e1a01000	 mov         r1, r0

; 97   :     HKEY hKey;
; 98   :     DWORD dwData;
; 99   :     DWORD dwSize;
; 100  :     DWORD dwType;
; 101  :     BOOL  fRet=FALSE;
; 102  :     DWORD dwRet;
; 103  :     // Open key
; 104  :     dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,RegKeyPath,0,0,&hKey);

  00010	e28d3008	 add         r3, sp, #8
  00014	e58d3000	 str         r3, [sp]
  00018	e3a03000	 mov         r3, #0
  0001c	e3a02000	 mov         r2, #0
  00020	e3a0010a	 mov         r0, #0xA, 2
  00024	e3a05000	 mov         r5, #0
  00028	eb000000	 bl          RegOpenKeyExW
  0002c	e3500000	 cmp         r0, #0

; 105  :     if (dwRet != ERROR_SUCCESS) {
; 106  :         DEBUGMSG(ZONE_ERROR,(TEXT("!EHCD:GetRegistryConfig RegOpenKeyEx(%s) failed %d\r\n"),
; 107  :                              RegKeyPath, dwRet));
; 108  :         return FALSE;

  00030	13a05000	 movne       r5, #0
  00034	1a000012	 bne         |$LN4@GetRegistr|

; 109  :     }
; 110  : 
; 111  :     // Read base address, range from registry and determine IOSpace
; 112  :     dwSize = sizeof(dwData);
; 113  :     dwRet = RegQueryValueEx(hKey, REG_PHYSICAL_PAGE_SIZE, 0, &dwType, (PUCHAR)&dwData, &dwSize);

  00038	e59f1054	 ldr         r1, [pc, #0x54]
  0003c	e59d0008	 ldr         r0, [sp, #8]
  00040	e3a07004	 mov         r7, #4
  00044	e28de00c	 add         lr, sp, #0xC
  00048	e28d4010	 add         r4, sp, #0x10
  0004c	e28d3014	 add         r3, sp, #0x14
  00050	e3a02000	 mov         r2, #0
  00054	e58d700c	 str         r7, [sp, #0xC]
  00058	e58de004	 str         lr, [sp, #4]
  0005c	e58d4000	 str         r4, [sp]
  00060	eb000000	 bl          RegQueryValueExW
  00064	e3500000	 cmp         r0, #0

; 114  :     if (dwRet == ERROR_SUCCESS) {

  00068	1a000003	 bne         |$LN2@GetRegistr|

; 115  :         if (lpdwPhyscialMemSize)

  0006c	e3560000	 cmp         r6, #0

; 116  :             *lpdwPhyscialMemSize = dwData;

  00070	159d3010	 ldrne       r3, [sp, #0x10]

; 117  :         fRet=TRUE;

  00074	e3a05001	 mov         r5, #1
  00078	15863000	 strne       r3, [r6]
  0007c		 |$LN2@GetRegistr|

; 118  :     }
; 119  :     RegCloseKey(hKey);

  0007c	e59d0008	 ldr         r0, [sp, #8]
  00080	eb000000	 bl          RegCloseKey

; 120  :     return fRet;

  00084		 |$LN4@GetRegistr|

; 121  : }

  00084	e1a00005	 mov         r0, r5
  00088	e28dd018	 add         sp, sp, #0x18
  0008c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$LN9@GetRegistr|
  00094		 |$LN10@GetRegistr|
  00094	00000000	 DCD         |??_C@_1CC@NPEFILDH@?$AAP?$AAh?$AAy?$AAs?$AAi?$AAc?$AAa?$AAl?$AAP?$AAa?$AAg?$AAe?$AAS?$AAi?$AAz?$AAe?$AA?$AA@|
  00098		 |$M41422|

			 ENDP  ; |GetRegistryPhysicalMemSize|

	EXPORT	|??_C@_1BG@OGBHGPNH@?$AAM?$AAa?$AAx?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T41438| DCD	|$LN8@GetRegistr@2|
	DCD	0x40002602

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BG@OGBHGPNH@?$AAM?$AAa?$AAx?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AA?$AA@| DCB "M"
	DCB	0x0, "a", 0x0, "x", 0x0, "C", 0x0, "u", 0x0, "r", 0x0, "r"
	DCB	0x0, "e", 0x0, "n", 0x0, "t", 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetRegistryMaxPower| PROC

; 127  : {

  00000		 |$LN8@GetRegistr@2|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M41435|
  00008	e1a06001	 mov         r6, r1
  0000c	e1a01000	 mov         r1, r0

; 128  :     HKEY hKey;
; 129  :     DWORD dwData;
; 130  :     DWORD dwSize;
; 131  :     DWORD dwType;
; 132  :     BOOL  fRet=FALSE;
; 133  :     DWORD dwRet;
; 134  :     // Open key
; 135  :     dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,RegKeyPath,0,0,&hKey);

  00010	e28d3008	 add         r3, sp, #8
  00014	e58d3000	 str         r3, [sp]
  00018	e3a03000	 mov         r3, #0
  0001c	e3a02000	 mov         r2, #0
  00020	e3a0010a	 mov         r0, #0xA, 2
  00024	e3a05000	 mov         r5, #0
  00028	eb000000	 bl          RegOpenKeyExW
  0002c	e3500000	 cmp         r0, #0

; 136  :     if (dwRet != ERROR_SUCCESS) {
; 137  :         DEBUGMSG(ZONE_ERROR,(TEXT("!EHCD:GetRegistryConfig RegOpenKeyEx(%s) failed %d\r\n"),
; 138  :                              RegKeyPath, dwRet));
; 139  :         return FALSE;

  00030	13a05000	 movne       r5, #0
  00034	1a000012	 bne         |$LN4@GetRegistr@2|

; 140  :     }
; 141  : 
; 142  :     // Read base address, range from registry and determine IOSpace
; 143  :     dwSize = sizeof(dwData);
; 144  :     dwRet = RegQueryValueEx(hKey, REG_MAX_CURRENT, 0, &dwType, (PUCHAR)&dwData, &dwSize);

  00038	e59f1054	 ldr         r1, [pc, #0x54]
  0003c	e59d0008	 ldr         r0, [sp, #8]
  00040	e3a07004	 mov         r7, #4
  00044	e28de00c	 add         lr, sp, #0xC
  00048	e28d4010	 add         r4, sp, #0x10
  0004c	e28d3014	 add         r3, sp, #0x14
  00050	e3a02000	 mov         r2, #0
  00054	e58d700c	 str         r7, [sp, #0xC]
  00058	e58de004	 str         lr, [sp, #4]
  0005c	e58d4000	 str         r4, [sp]
  00060	eb000000	 bl          RegQueryValueExW
  00064	e3500000	 cmp         r0, #0

; 145  :     if (dwRet == ERROR_SUCCESS) {

  00068	1a000003	 bne         |$LN2@GetRegistr@2|

; 146  :         if (lpdwMaxCurrent)

  0006c	e3560000	 cmp         r6, #0

; 147  :             *lpdwMaxCurrent = dwData;

  00070	159d3010	 ldrne       r3, [sp, #0x10]

; 148  :         fRet=TRUE;

  00074	e3a05001	 mov         r5, #1
  00078	15863000	 strne       r3, [r6]
  0007c		 |$LN2@GetRegistr@2|

; 149  :     }
; 150  :     RegCloseKey(hKey);

  0007c	e59d0008	 ldr         r0, [sp, #8]
  00080	eb000000	 bl          RegCloseKey

; 151  :     return fRet;

  00084		 |$LN4@GetRegistr@2|

; 152  : }

  00084	e1a00005	 mov         r0, r5
  00088	e28dd018	 add         sp, sp, #0x18
  0008c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$LN9@GetRegistr@2|
  00094		 |$LN10@GetRegistr@2|
  00094	00000000	 DCD         |??_C@_1BG@OGBHGPNH@?$AAM?$AAa?$AAx?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AA?$AA@|
  00098		 |$M41436|

			 ENDP  ; |GetRegistryMaxPower|

	EXPORT	|ConfigureMHDRCCard|

  00000			 AREA	 |.pdata|, PDATA
|$T41449| DCD	|$LN5@ConfigureM|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ConfigureMHDRCCard| PROC

; 174  : {

  00000		 |$LN5@ConfigureM|
  00000		 |$M41446|

; 175  : 	UNREFERENCED_PARAMETER(pPddObject);
; 176  : 
; 177  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("ConfigureMHDRCCard\r\n")));
; 178  :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 179  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M41447|

			 ENDP  ; |ConfigureMHDRCCard|

	EXPORT	|??_C@_1BE@EKANOLAD@?$AAD?$AAV?$AAF?$AAS?$AAO?$AAr?$AAd?$AAe?$AAr?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_17PKGAGD@?$AAD?$AAm?$AAa?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|HalFreeCommonBuffer|
	IMPORT	|HcdMdd_DestroyMemoryObject|
	IMPORT	|HcdMdd_DestroyHcdObject|
	IMPORT	|FreeIntChainHandler|
	IMPORT	|HcdMdd_CreateHcdObject|
	IMPORT	|HcdMdd_CreateMemoryObject|
	IMPORT	|HalAllocateCommonBuffer|
	IMPORT	|DDKReg_GetWindowInfo|
	IMPORT	|wcsncpy|

  00000			 AREA	 |.pdata|, PDATA
|$T41503| DCD	|$LN40@Initialize|
	DCD	0x4000e102

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@EKANOLAD@?$AAD?$AAV?$AAF?$AAS?$AAO?$AAr?$AAd?$AAe?$AAr?$AA?$AA@| DCB "D"
	DCB	0x0, "V", 0x0, "F", 0x0, "S", 0x0, "O", 0x0, "r", 0x0, "d"
	DCB	0x0, "e", 0x0, "r", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_17PKGAGD@?$AAD?$AAm?$AAa?$AA?$AA@| DCB "D", 0x0, "m", 0x0, "a", 0x0
	DCB	0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |InitializeMHDRC| PROC

; 203  : {     

  00000		 |$LN40@Initialize|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd090	 sub         sp, sp, #0x90
  00008		 |$M41500|
  00008	e1a09001	 mov         r9, r1
  0000c	e1a05000	 mov         r5, r0

; 204  :     BOOL fResult = FALSE;
; 205  :     LPVOID pobMem = NULL;
; 206  :     LPVOID pobMHCD = NULL;
; 207  :     DWORD dwHPPhysicalMemSize = 0;
; 208  :     HKEY    hKey;
; 209  :     DDKWINDOWINFO dwi;
; 210  : 
; 211  :     if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,szDriverRegKey,0,0,&hKey)!= ERROR_SUCCESS) {

  00010	e28d3010	 add         r3, sp, #0x10
  00014	e58d3000	 str         r3, [sp]
  00018	e3a03000	 mov         r3, #0
  0001c	e3a02000	 mov         r2, #0
  00020	e3a0010a	 mov         r0, #0xA, 2
  00024	e3a06000	 mov         r6, #0
  00028	e3a08000	 mov         r8, #0
  0002c	e3a0a000	 mov         r10, #0
  00030	eb000000	 bl          RegOpenKeyExW
  00034	e3500000	 cmp         r0, #0

; 212  :         DEBUGMSG(ZONE_ERROR,(TEXT("InitializeMHDRC:GetRegistryConfig RegOpenKeyEx(%s) failed\r\n"),
; 213  :                              szDriverRegKey));
; 214  :         return FALSE;

  00038	1a0000c8	 bne         |$LN1@Initialize|

; 215  :     }
; 216  : 
; 217  :     dwi.cbSize=sizeof(dwi);
; 218  :     if ( DDKReg_GetWindowInfo(hKey, &dwi ) !=ERROR_SUCCESS) {

  0003c	e59d0010	 ldr         r0, [sp, #0x10]
  00040	e3a03074	 mov         r3, #0x74
  00044	e28d101c	 add         r1, sp, #0x1C
  00048	e58d301c	 str         r3, [sp, #0x1C]
  0004c	eb000000	 bl          DDKReg_GetWindowInfo
  00050	e3500000	 cmp         r0, #0
  00054	e3a04000	 mov         r4, #0
  00058	1a0000a5	 bne         |$InitializeMHDRC_Error$41094|

; 219  :         DEBUGMSG(ZONE_ERROR,(TEXT("InitializeMHDRC:DDKReg_GetWindowInfo or  DDKReg_GetWindowInfo failed\r\n")));
; 220  :         goto InitializeMHDRC_Error;
; 221  :     }
; 222  :     
; 223  : 	fResult = ConfigureMHDRCCard(pPddObject);
; 224  :     if (!fResult) {
; 225  :         goto InitializeMHDRC_Error;
; 226  :     }
; 227  : 
; 228  :     pPddObject->bDMASupport = FALSE;
; 229  :     if ( hKey!=NULL)  {

  0005c	e59d0010	 ldr         r0, [sp, #0x10]
  00060	e5854250	 str         r4, [r5, #0x250]
  00064	e3500000	 cmp         r0, #0
  00068	0a000011	 beq         |$LN16@Initialize|

; 230  :         DWORD dwDMA;
; 231  :         DWORD dwType;
; 232  :         DWORD dwLength = sizeof(DWORD);
; 233  :         if (RegQueryValueEx(hKey, HCD_DMA_SUPPORT, 0, &dwType, (PUCHAR)&dwDMA, &dwLength) == ERROR_SUCCESS)

  0006c	e59f130c	 ldr         r1, [pc, #0x30C]
  00070	e3a07004	 mov         r7, #4
  00074	e28de008	 add         lr, sp, #8
  00078	e28d400c	 add         r4, sp, #0xC
  0007c	e28d3014	 add         r3, sp, #0x14
  00080	e3a02000	 mov         r2, #0
  00084	e58d7008	 str         r7, [sp, #8]
  00088	e58de004	 str         lr, [sp, #4]
  0008c	e58d4000	 str         r4, [sp]
  00090	eb000000	 bl          RegQueryValueExW
  00094	e3500000	 cmp         r0, #0
  00098	1a000004	 bne         |$LN37@Initialize|

; 234  :             pPddObject->bDMASupport = ((dwDMA == 0)? FALSE: TRUE);

  0009c	e59d300c	 ldr         r3, [sp, #0xC]
  000a0	e3530000	 cmp         r3, #0
  000a4	03a03000	 moveq       r3, #0
  000a8	13a03001	 movne       r3, #1
  000ac	e5853250	 str         r3, [r5, #0x250]
  000b0		 |$LN37@Initialize|
  000b0	e59d0010	 ldr         r0, [sp, #0x10]
  000b4		 |$LN16@Initialize|

; 235  :     }
; 236  : 
; 237  :     DEBUGMSG(ZONE_VERBOSE, (TEXT("DMA Support = %d\r\n"), pPddObject->bDMASupport));
; 238  : #if 0
; 239  :     RETAILMSG(1, (TEXT("Force DMA support to 0\r\n")));
; 240  :     pPddObject->bDMASupport = 0;
; 241  : #endif
; 242  :     pPddObject->dwDMAMode = 1;

  000b4	e3a03001	 mov         r3, #1

; 243  :     DEBUGMSG(ZONE_VERBOSE, (TEXT("DMA Mode = %d\r\n"), pPddObject->dwDMAMode));
; 244  : 
; 245  : 
; 246  :     pPddObject->nDVFSOrder = 150;

  000b8	e3a02096	 mov         r2, #0x96
  000bc	e5853254	 str         r3, [r5, #0x254]
  000c0	e585225c	 str         r2, [r5, #0x25C]

; 247  :     if ( hKey!=NULL)  {

  000c4	e3500000	 cmp         r0, #0
  000c8	0a000010	 beq         |$LN13@Initialize|

; 248  :         DWORD dwDVFSOrder = 0;
; 249  :         DWORD dwType;
; 250  :         DWORD dwLength = sizeof(DWORD);
; 251  :         if (RegQueryValueEx(hKey, HCD_DVFS_ORDER, 0, &dwType, (PUCHAR)&dwDVFSOrder, &dwLength) == ERROR_SUCCESS)

  000cc	e59f12a8	 ldr         r1, [pc, #0x2A8]
  000d0	e3a07000	 mov         r7, #0
  000d4	e3a0b004	 mov         r11, #4
  000d8	e28de00c	 add         lr, sp, #0xC
  000dc	e28d4008	 add         r4, sp, #8
  000e0	e28d3014	 add         r3, sp, #0x14
  000e4	e3a02000	 mov         r2, #0
  000e8	e58d7008	 str         r7, [sp, #8]
  000ec	e58db00c	 str         r11, [sp, #0xC]
  000f0	e58de004	 str         lr, [sp, #4]
  000f4	e58d4000	 str         r4, [sp]
  000f8	eb000000	 bl          RegQueryValueExW
  000fc	e3500000	 cmp         r0, #0
  00100	1a000002	 bne         |$LN13@Initialize|

; 252  :             if (dwDVFSOrder != 0)

  00104	e59d3008	 ldr         r3, [sp, #8]
  00108	e3530000	 cmp         r3, #0

; 253  :                 pPddObject->nDVFSOrder = dwDVFSOrder;

  0010c	1585325c	 strne       r3, [r5, #0x25C]
  00110		 |$LN13@Initialize|

; 254  :     }
; 255  :     DEBUGMSG(ZONE_VERBOSE, (TEXT("InitializeMHDRC pPddObject[0x%x], order[%d]\r\n"), pPddObject, pPddObject->nDVFSOrder));
; 256  : 
; 257  :     // get max current that can be supplied to devices inserted into the OTG port
; 258  :     GetRegistryMaxPower(szDriverRegKey, &dwMaxCurrent);

  00110	e28d3008	 add         r3, sp, #8
  00114	e58d3000	 str         r3, [sp]
  00118	e3a03000	 mov         r3, #0
  0011c	e3a02000	 mov         r2, #0
  00120	e1a01009	 mov         r1, r9
  00124	e3a0010a	 mov         r0, #0xA, 2
  00128	eb000000	 bl          RegOpenKeyExW
  0012c	e3500000	 cmp         r0, #0
  00130	1a000010	 bne         |$LN30@Initialize|
  00134	e59f123c	 ldr         r1, [pc, #0x23C]
  00138	e59d0008	 ldr         r0, [sp, #8]
  0013c	e3a07004	 mov         r7, #4
  00140	e28de00c	 add         lr, sp, #0xC
  00144	e28d4014	 add         r4, sp, #0x14
  00148	e28d3018	 add         r3, sp, #0x18
  0014c	e3a02000	 mov         r2, #0
  00150	e58d700c	 str         r7, [sp, #0xC]
  00154	e58de004	 str         lr, [sp, #4]
  00158	e58d4000	 str         r4, [sp]
  0015c	eb000000	 bl          RegQueryValueExW
  00160	e3500000	 cmp         r0, #0
  00164	059f2208	 ldreq       r2, [pc, #0x208]
  00168	059d3014	 ldreq       r3, [sp, #0x14]
  0016c	e59d0008	 ldr         r0, [sp, #8]
  00170	05823000	 streq       r3, [r2]
  00174	eb000000	 bl          RegCloseKey
  00178		 |$LN30@Initialize|

; 259  : 
; 260  :     // The PDD can supply a buffer of contiguous physical memory here, or can let the 
; 261  :     // MDD try to allocate the memory from system RAM.  We will use the HalAllocateCommonBuffer()
; 262  :     // API to allocate the memory and bus controller physical addresses and pass this information
; 263  :     // into the MDD.
; 264  :     if (GetRegistryPhysicalMemSize(szDriverRegKey,&pPddObject->dwPhysicalMemSize)) {

  00178	e28d3008	 add         r3, sp, #8
  0017c	e58d3000	 str         r3, [sp]
  00180	e3a03000	 mov         r3, #0
  00184	e3a02000	 mov         r2, #0
  00188	e1a01009	 mov         r1, r9
  0018c	e3a0010a	 mov         r0, #0xA, 2
  00190	e3a07000	 mov         r7, #0
  00194	eb000000	 bl          RegOpenKeyExW
  00198	e3500000	 cmp         r0, #0
  0019c	1a000026	 bne         |$LN12@Initialize|
  001a0	e59f11c8	 ldr         r1, [pc, #0x1C8]
  001a4	e59d0008	 ldr         r0, [sp, #8]
  001a8	e3a0b004	 mov         r11, #4
  001ac	e28de014	 add         lr, sp, #0x14
  001b0	e28d400c	 add         r4, sp, #0xC
  001b4	e28d3018	 add         r3, sp, #0x18
  001b8	e3a02000	 mov         r2, #0
  001bc	e58db014	 str         r11, [sp, #0x14]
  001c0	e58de004	 str         lr, [sp, #4]
  001c4	e58d4000	 str         r4, [sp]
  001c8	eb000000	 bl          RegQueryValueExW
  001cc	e3500000	 cmp         r0, #0
  001d0	1a000003	 bne         |$LN33@Initialize|
  001d4	e375000c	 cmn         r5, #0xC
  001d8	159d300c	 ldrne       r3, [sp, #0xC]
  001dc	e3a07001	 mov         r7, #1
  001e0	1585300c	 strne       r3, [r5, #0xC]
  001e4		 |$LN33@Initialize|
  001e4	e59d0008	 ldr         r0, [sp, #8]
  001e8	eb000000	 bl          RegCloseKey
  001ec	e3570000	 cmp         r7, #0
  001f0	0a000011	 beq         |$LN12@Initialize|

; 265  :         // A quarter for High priority Memory.
; 266  :         dwHPPhysicalMemSize = pPddObject->dwPhysicalMemSize/4;
; 267  :         // Align with page size.        
; 268  :         pPddObject->dwPhysicalMemSize = (pPddObject->dwPhysicalMemSize + PAGE_SIZE -1) & ~(PAGE_SIZE -1);

  001f4	e3e03b0d	 mvn         r3, #0xD, 22
  001f8	e223e0fb	 eor         lr, r3, #0xFB
  001fc	e59e2000	 ldr         r2, [lr]
  00200	e595000c	 ldr         r0, [r5, #0xC]

; 269  :         dwHPPhysicalMemSize = ((dwHPPhysicalMemSize +  PAGE_SIZE -1) & ~(PAGE_SIZE -1));
; 270  :     }
; 271  :     else 

  00204	e3a04000	 mov         r4, #0
  00208	e1a03002	 mov         r3, r2
  0020c	e2431001	 sub         r1, r3, #1
  00210	e0803002	 add         r3, r0, r2
  00214	e2433001	 sub         r3, r3, #1
  00218	e1c33001	 bic         r3, r3, r1
  0021c	e585300c	 str         r3, [r5, #0xC]
  00220	e59e3000	 ldr         r3, [lr]
  00224	e1a02003	 mov         r2, r3
  00228	e0833120	 add         r3, r3, r0, lsr #2
  0022c	e2433001	 sub         r3, r3, #1
  00230	e2422001	 sub         r2, r2, #1
  00234	e1c3a002	 bic         r10, r3, r2
  00238	ea000001	 b           |$LN11@Initialize|
  0023c		 |$LN12@Initialize|

; 272  :         pPddObject->dwPhysicalMemSize=0;

  0023c	e3a04000	 mov         r4, #0
  00240	e585400c	 str         r4, [r5, #0xC]
  00244		 |$LN11@Initialize|

; 273  :     
; 274  :     if (pPddObject->dwPhysicalMemSize<gcTotalAvailablePhysicalMemory) { // Setup Minimun requirement.

  00244	e595300c	 ldr         r3, [r5, #0xC]

; 275  :         pPddObject->dwPhysicalMemSize = gcTotalAvailablePhysicalMemory;
; 276  :         dwHPPhysicalMemSize = gcHighPriorityPhysicalMemory;
; 277  :     }
; 278  : 
; 279  :     pPddObject->AdapterObject.ObjectSize = sizeof(DMA_ADAPTER_OBJECT);
; 280  :     pPddObject->AdapterObject.InterfaceType = dwi.dwInterfaceType;
; 281  :     pPddObject->AdapterObject.BusNumber = dwi.dwBusNumber;

  00248	e59d2020	 ldr         r2, [sp, #0x20]

; 282  :     if ((pPddObject->pvVirtualAddress = HalAllocateCommonBuffer(&pPddObject->AdapterObject, pPddObject->dwPhysicalMemSize, &pPddObject->LogicalAddress, FALSE)) == NULL) {

  0024c	e3a0e00c	 mov         lr, #0xC
  00250	e3530802	 cmp         r3, #2, 16
  00254	33a03802	 movcc       r3, #2, 16
  00258	3585300c	 strcc       r3, [r5, #0xC]
  0025c	e59d3024	 ldr         r3, [sp, #0x24]
  00260	e595100c	 ldr         r1, [r5, #0xC]
  00264	e5852020	 str         r2, [r5, #0x20]
  00268	e585301c	 str         r3, [r5, #0x1C]
  0026c	e3a03000	 mov         r3, #0
  00270	e2852010	 add         r2, r5, #0x10
  00274	e2850018	 add         r0, r5, #0x18
  00278	33a0a902	 movcc       r10, #2, 18
  0027c	e1c5e1b8	 strh        lr, [r5, #0x18]
  00280	eb000000	 bl          HalAllocateCommonBuffer
  00284	e1b02000	 movs        r2, r0
  00288	e5852008	 str         r2, [r5, #8]
  0028c	0a000018	 beq         |$InitializeMHDRC_Error$41094|

; 283  :         goto InitializeMHDRC_Error;
; 284  :     }
; 285  : 
; 286  : 	pobMem = HcdMdd_CreateMemoryObject(pPddObject->dwPhysicalMemSize, dwHPPhysicalMemSize, (PUCHAR) pPddObject->pvVirtualAddress, (PUCHAR) pPddObject->LogicalAddress.LowPart);

  00290	e5953010	 ldr         r3, [r5, #0x10]
  00294	e595000c	 ldr         r0, [r5, #0xC]
  00298	e1a0100a	 mov         r1, r10
  0029c	eb000000	 bl          HcdMdd_CreateMemoryObject
  002a0	e1b06000	 movs        r6, r0

; 287  :     if (!pobMem) {

  002a4	0a000012	 beq         |$InitializeMHDRC_Error$41094|

; 288  :         goto InitializeMHDRC_Error;
; 289  :     }
; 290  : 
; 291  : 	pobMHCD = HcdMdd_CreateHcdObject(pPddObject, pobMem, szDriverRegKey, 0x00, 0x00);

  002a8	e3a03000	 mov         r3, #0
  002ac	e1a02009	 mov         r2, r9
  002b0	e1a01006	 mov         r1, r6
  002b4	e1a00005	 mov         r0, r5
  002b8	e58d4000	 str         r4, [sp]
  002bc	eb000000	 bl          HcdMdd_CreateHcdObject
  002c0	e1b08000	 movs        r8, r0

; 292  :     if (!pobMHCD) {

  002c4	0a00000a	 beq         |$InitializeMHDRC_Error$41094|

; 293  :         goto InitializeMHDRC_Error;
; 294  :     }
; 295  : 
; 296  :     pPddObject->lpvMemoryObject = pobMem;
; 297  :     pPddObject->lpvMHCDMddObject = pobMHCD;
; 298  :     DEBUGMSG(ZONE_VERBOSE, (TEXT("InitializeMHDRC with Base(0x%x), MddObject(0x%x)\r\n"), pPddObject, pPddObject->lpvMHCDMddObject));
; 299  :     _tcsncpy(pPddObject->szDriverRegKey, szDriverRegKey, MAX_PATH);    

  002c8	e3a02f41	 mov         r2, #0x41, 30
  002cc	e1a01009	 mov         r1, r9
  002d0	e2850024	 add         r0, r5, #0x24
  002d4	e5856000	 str         r6, [r5]
  002d8	e5858004	 str         r8, [r5, #4]
  002dc	eb000000	 bl          wcsncpy

; 300  :     
; 301  :     if ( hKey!=NULL)  {

  002e0	e59d0010	 ldr         r0, [sp, #0x10]
  002e4	e3500000	 cmp         r0, #0

; 302  :         RegCloseKey(hKey);

  002e8	1b000000	 blne        RegCloseKey

; 303  :     }
; 304  : 
; 305  :     DEBUGMSG(ZONE_VERBOSE, (TEXT("InitializeMHDRC success\r\n")));
; 306  :     return TRUE;

  002ec	e3a00001	 mov         r0, #1
  002f0	ea00001b	 b           |$LN21@Initialize|
  002f4		 |$InitializeMHDRC_Error$41094|

; 307  : 
; 308  : InitializeMHDRC_Error:
; 309  :     if (pPddObject->IsrHandle) {

  002f4	e5953248	 ldr         r3, [r5, #0x248]
  002f8	e3530000	 cmp         r3, #0
  002fc	0a000002	 beq         |$LN5@Initialize|

; 310  :         FreeIntChainHandler(pPddObject->IsrHandle);

  00300	e1a00003	 mov         r0, r3
  00304	eb000000	 bl          FreeIntChainHandler

; 311  :         pPddObject->IsrHandle = NULL;

  00308	e5854248	 str         r4, [r5, #0x248]
  0030c		 |$LN5@Initialize|

; 312  :     }
; 313  :     
; 314  :     if (pobMHCD)

  0030c	e3580000	 cmp         r8, #0

; 315  :         HcdMdd_DestroyHcdObject(pobMHCD);

  00310	11a00008	 movne       r0, r8
  00314	1b000000	 blne        HcdMdd_DestroyHcdObject

; 316  :     if (pobMem)

  00318	e3560000	 cmp         r6, #0

; 317  :         HcdMdd_DestroyMemoryObject(pobMem);

  0031c	11a00006	 movne       r0, r6
  00320	1b000000	 blne        HcdMdd_DestroyMemoryObject

; 318  :     if(pPddObject->pvVirtualAddress)

  00324	e5953008	 ldr         r3, [r5, #8]
  00328	e1b0e003	 movs        lr, r3

; 319  :         HalFreeCommonBuffer(&pPddObject->AdapterObject, pPddObject->dwPhysicalMemSize, pPddObject->LogicalAddress, pPddObject->pvVirtualAddress, FALSE);

  0032c	15952010	 ldrne       r2, [r5, #0x10]
  00330	15953014	 ldrne       r3, [r5, #0x14]
  00334	1595100c	 ldrne       r1, [r5, #0xC]
  00338	12850018	 addne       r0, r5, #0x18
  0033c	158d4004	 strne       r4, [sp, #4]
  00340	158de000	 strne       lr, [sp]
  00344	1b000000	 blne        HalFreeCommonBuffer

; 320  : 
; 321  :     pPddObject->lpvMemoryObject = NULL;
; 322  :     pPddObject->lpvMHCDMddObject = NULL;
; 323  :     pPddObject->pvVirtualAddress = NULL;
; 324  :     if ( hKey!=NULL) 

  00348	e59d0010	 ldr         r0, [sp, #0x10]
  0034c	e5854000	 str         r4, [r5]
  00350	e5854004	 str         r4, [r5, #4]
  00354	e3500000	 cmp         r0, #0
  00358	e5854008	 str         r4, [r5, #8]

; 325  :         RegCloseKey(hKey);

  0035c	1b000000	 blne        RegCloseKey
  00360		 |$LN1@Initialize|

; 326  : 
; 327  :     return FALSE;

  00360	e3a00000	 mov         r0, #0
  00364		 |$LN21@Initialize|

; 328  : }

  00364	e28dd090	 add         sp, sp, #0x90
  00368	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0036c	e12fff1e	 bx          lr
  00370		 |$LN41@Initialize|
  00370		 |$LN42@Initialize|
  00370	00000000	 DCD         |??_C@_1CC@NPEFILDH@?$AAP?$AAh?$AAy?$AAs?$AAi?$AAc?$AAa?$AAl?$AAP?$AAa?$AAg?$AAe?$AAS?$AAi?$AAz?$AAe?$AA?$AA@|
  00374		 |$LN43@Initialize|
  00374	00000000	 DCD         |dwMaxCurrent|
  00378		 |$LN44@Initialize|
  00378	00000000	 DCD         |??_C@_1BG@OGBHGPNH@?$AAM?$AAa?$AAx?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AA?$AA@|
  0037c		 |$LN45@Initialize|
  0037c	00000000	 DCD         |??_C@_1BE@EKANOLAD@?$AAD?$AAV?$AAF?$AAS?$AAO?$AAr?$AAd?$AAe?$AAr?$AA?$AA@|
  00380		 |$LN46@Initialize|
  00380	00000000	 DCD         |??_C@_17PKGAGD@?$AAD?$AAm?$AAa?$AA?$AA@|
  00384		 |$M41501|

			 ENDP  ; |InitializeMHDRC|

	EXPORT	|HcdPdd_PreTransferActivation|
	IMPORT	|InterlockedIncrement|
	IMPORT	|LeaveCriticalSection|
	IMPORT	|WaitForSingleObject|
	IMPORT	|EnterCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T41522| DCD	|$LN13@HcdPdd_Pre|
	DCD	0x40001c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_PreTransferActivation| PROC

; 396  : {    

  00000		 |$LN13@HcdPdd_Pre|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M41519|
  00004	e1a04000	 mov         r4, r0

; 397  :     BOOL retVal=TRUE;
; 398  :     DEBUGMSG(ZONE_FUNCTION, (
; 399  :         L"+PreDmaActivation\r\n"
; 400  :     ));
; 401  : 
; 402  :     for (;;)
; 403  :     {
; 404  :     
; 405  :         // this operation needs to be atomic to handle a corner case
; 406  :         EnterCriticalSection(&pPdd->csDVFS);

  00008	e2840e27	 add         r0, r4, #0x27, 28
  0000c	eb000000	 bl          EnterCriticalSection

; 407  :         
; 408  :         // check and wait for DVFS activity to complete
; 409  :         if (pPdd->bDVFSActive == TRUE)

  00010	e5943260	 ldr         r3, [r4, #0x260]
  00014	e3530001	 cmp         r3, #1
  00018	1a00000d	 bne         |$LN3@HcdPdd_Pre|
  0001c	e3a03c01	 mov         r3, #1, 24
  00020	e3835002	 orr         r5, r3, #2
  00024		 |$LL5@HcdPdd_Pre|

; 410  :         {
; 411  :             DWORD dwRet;
; 412  : 
; 413  :             DEBUGMSG(ZONE_FUNCTION, (L"*** DVFS in progress wait before doing DMA\r\n"));
; 414  :             dwRet = WaitForSingleObject(pPdd->hDVFSActivityEvent, 0);

  00024	e594026c	 ldr         r0, [r4, #0x26C]
  00028	e3a01000	 mov         r1, #0
  0002c	eb000000	 bl          WaitForSingleObject

; 415  :             if (dwRet != WAIT_TIMEOUT)

  00030	e1550000	 cmp         r5, r0
  00034	1a000006	 bne         |$LN3@HcdPdd_Pre|

; 426  :             break;
; 427  :         }
; 428  :         LeaveCriticalSection(&pPdd->csDVFS);  // hDVFSActivityEvent not signaled

  00038	e2840e27	 add         r0, r4, #0x27, 28
  0003c	eb000000	 bl          LeaveCriticalSection
  00040	e2840e27	 add         r0, r4, #0x27, 28
  00044	eb000000	 bl          EnterCriticalSection
  00048	e5943260	 ldr         r3, [r4, #0x260]
  0004c	e3530001	 cmp         r3, #1
  00050	0afffff3	 beq         |$LL5@HcdPdd_Pre|
  00054		 |$LN3@HcdPdd_Pre|

; 416  :             {
; 417  :                 InterlockedIncrement(&pPdd->nActiveDmaCount);
; 418  :                 LeaveCriticalSection(&pPdd->csDVFS);
; 419  :                 break;
; 420  :             }
; 421  :         }
; 422  :         else
; 423  :         {
; 424  :             InterlockedIncrement(&pPdd->nActiveDmaCount);

  00054	e2840f99	 add         r0, r4, #0x99, 30
  00058	eb000000	 bl          InterlockedIncrement

; 425  :             LeaveCriticalSection(&pPdd->csDVFS);

  0005c	e2840e27	 add         r0, r4, #0x27, 28
  00060	eb000000	 bl          LeaveCriticalSection

; 429  : 
; 430  :     }
; 431  : 
; 432  :     DEBUGMSG(ZONE_HCD, (
; 433  :         L"PreDmaActivation() with count %d\r\n", pPdd->nActiveDmaCount
; 434  :         ));
; 435  : 
; 436  :     return retVal;

  00064	e3a00001	 mov         r0, #1

; 437  : }

  00068	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0006c	e12fff1e	 bx          lr
  00070		 |$M41520|

			 ENDP  ; |HcdPdd_PreTransferActivation|

	EXPORT	|HcdPdd_PostTransferDeactivation|
	IMPORT	|InterlockedDecrement|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T41534| DCD	|$LN8@HcdPdd_Pos|
	DCD	0x40001201
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\pdd\system.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_PostTransferDeactivation| PROC

; 447  : {

  00000		 |$LN8@HcdPdd_Pos|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M41531|
  00004	e1a04000	 mov         r4, r0

; 448  :         
; 449  :     DEBUGMSG(ZONE_HCD, (
; 450  :         L"+PostDmaDeactivation\r\n"
; 451  :     ));
; 452  :     
; 453  :     ASSERT(pPdd->nActiveDmaCount > 0);
; 454  : 
; 455  :     // this operation needs to be atomic to handle a corner case
; 456  :     EnterCriticalSection(&pPdd->csDVFS);

  00008	e2840e27	 add         r0, r4, #0x27, 28
  0000c	eb000000	 bl          EnterCriticalSection

; 457  :     
; 458  :     // check if all dma's are inactive and signal ack event if so
; 459  :     InterlockedDecrement(&pPdd->nActiveDmaCount);

  00010	e2840f99	 add         r0, r4, #0x99, 30
  00014	eb000000	 bl          InterlockedDecrement

; 460  :     if (pPdd->bDVFSActive == TRUE && pPdd->nActiveDmaCount <= 0)

  00018	e5943260	 ldr         r3, [r4, #0x260]
  0001c	e3530001	 cmp         r3, #1
  00020	1a000004	 bne         |$LN4@HcdPdd_Pos|
  00024	e5943264	 ldr         r3, [r4, #0x264]
  00028	e3530000	 cmp         r3, #0

; 461  :         {
; 462  :         DEBUGMSG(ZONE_HCD, (L"***USBHCD:finished all Dma's set hDVFSAckEvent\r\n"));
; 463  :         SetEvent(pPdd->hDVFSAckEvent);

  0002c	d5940268	 ldrle       r0, [r4, #0x268]
  00030	d3a01003	 movle       r1, #3
  00034	db000000	 blle        EventModify
  00038		 |$LN4@HcdPdd_Pos|

; 464  :         }
; 465  : 
; 466  :     LeaveCriticalSection(&pPdd->csDVFS);

  00038	e2840e27	 add         r0, r4, #0x27, 28
  0003c	eb000000	 bl          LeaveCriticalSection

; 467  : 
; 468  :     DEBUGMSG(ZONE_HCD, (
; 469  :         L"PostDmaDeactivation() with count %d\r\n", pPdd->nActiveDmaCount
; 470  :         ));
; 471  : }

  00040	e8bd4010	 ldmia       sp!, {r4, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$M41532|

			 ENDP  ; |HcdPdd_PostTransferDeactivation|

	EXPORT	|HcdPdd_Init|
	EXPORT	|??_C@_1BE@JNKHMKGH@?$AAO?$AAT?$AAG?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BI@KEGLAEOK@?$AAO?$AAT?$AAG?$AAU?$AAS?$AAB?$AAC?$AAl?$AAo?$AAc?$AAk?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CC@PKGPLCAL@?$AAo?$AAm?$AAa?$AAp?$AA_?$AAm?$AAu?$AAs?$AAb?$AAo?$AAt?$AAg?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|free|
	IMPORT	|DeleteCriticalSection|
	IMPORT	|CloseBusAccessHandle|
	IMPORT	|GetProcAddressW|
	IMPORT	|GetModuleHandleW|
	IMPORT	|CreateBusAccessHandle|
	IMPORT	|g_dwContext|
	IMPORT	|InitializeCriticalSection|
	IMPORT	|malloc|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T41552| DCD	|$LN17@HcdPdd_Ini|
	DCD	0x40004b02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@JNKHMKGH@?$AAO?$AAT?$AAG?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AA?$AA@| DCB "O"
	DCB	0x0, "T", 0x0, "G", 0x0, "A", 0x0, "t", 0x0, "t", 0x0, "a"
	DCB	0x0, "c", 0x0, "h", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BI@KEGLAEOK@?$AAO?$AAT?$AAG?$AAU?$AAS?$AAB?$AAC?$AAl?$AAo?$AAc?$AAk?$AA?$AA@| DCB "O"
	DCB	0x0, "T", 0x0, "G", 0x0, "U", 0x0, "S", 0x0, "B", 0x0, "C"
	DCB	0x0, "l", 0x0, "o", 0x0, "c", 0x0, "k", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@PKGPLCAL@?$AAo?$AAm?$AAa?$AAp?$AA_?$AAm?$AAu?$AAs?$AAb?$AAo?$AAt?$AAg?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@| DCB "o"
	DCB	0x0, "m", 0x0, "a", 0x0, "p", 0x0, "_", 0x0, "m", 0x0, "u"
	DCB	0x0, "s", 0x0, "b", 0x0, "o", 0x0, "t", 0x0, "g", 0x0, "."
	DCB	0x0, "d", 0x0, "l", 0x0, "l", 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\pdd\system.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_Init| PROC

; 493  : {

  00000		 |$LN17@HcdPdd_Ini|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M41549|
  00008	e1a05000	 mov         r5, r0

; 494  :     SMHCDPdd *  pPddObject = malloc(sizeof(SMHCDPdd));

  0000c	e3a00fa2	 mov         r0, #0xA2, 30
  00010	eb000000	 bl          malloc
  00014	e1b04000	 movs        r4, r0

; 495  :     BOOL        fRet = FALSE;
; 496  :     HMODULE m_hOTGInstance;
; 497  :     LPMUSB_ATTACH_PROC lphAttachProc;
; 498  :     PHSMUSB_T pOTG;
; 499  : 
; 500  : 
; 501  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("HcdPdd_Init+\r\n")));
; 502  :     if (pPddObject) {

  00018	0a000035	 beq         |$LN1@HcdPdd_Ini|

; 503  :         pPddObject->pvVirtualAddress = NULL;

  0001c	e3a06000	 mov         r6, #0

; 504  :         InitializeCriticalSection(&pPddObject->csPdd);

  00020	e2840f8d	 add         r0, r4, #0x8D, 30
  00024	e5846008	 str         r6, [r4, #8]
  00028	eb000000	 bl          InitializeCriticalSection

; 505  :         pPddObject->IsrHandle = NULL;
; 506  :         pPddObject->hParentBusHandle = CreateBusAccessHandle((LPCWSTR)g_dwContext); 

  0002c	e59f30f4	 ldr         r3, [pc, #0xF4]
  00030	e5846248	 str         r6, [r4, #0x248]
  00034	e5930000	 ldr         r0, [r3]
  00038	eb000000	 bl          CreateBusAccessHandle
  0003c	e1a03000	 mov         r3, r0

; 507  :         
; 508  :         fRet = InitializeMHDRC(pPddObject, (LPCWSTR)dwContext);

  00040	e1a00004	 mov         r0, r4
  00044	e1a01005	 mov         r1, r5
  00048	e584324c	 str         r3, [r4, #0x24C]
  0004c	eb000000	 bl          InitializeMHDRC
  00050	e3500000	 cmp         r0, #0

; 509  :         if (!fRet)

  00054	0a000022	 beq         |$LN14@HcdPdd_Ini|

; 510  :             goto END;
; 511  :     }
; 512  :     else
; 513  :     {
; 514  :         DEBUGMSG(ZONE_WARNING, (TEXT("HcdPdd_Init cannot allocate pPddObject\r\n")));
; 515  :         goto END;
; 516  :     }
; 517  : 
; 518  : 
; 519  :    InitializeCriticalSection(&pPddObject->csDVFS);

  00058	e2840e27	 add         r0, r4, #0x27, 28
  0005c	eb000000	 bl          InitializeCriticalSection

; 520  : 
; 521  :     // initialize dvfs variables
; 522  :     pPddObject->bDVFSActive = FALSE;
; 523  :     pPddObject->nActiveDmaCount = 0;
; 524  :     pPddObject->hDVFSAckEvent = NULL;
; 525  :     pPddObject->hDVFSActivityEvent = NULL;    
; 526  : 
; 527  :     // Now we need to register for the OTG to acknowledge it is ready.
; 528  :     // Get the OTG module handle
; 529  :     m_hOTGInstance = GetModuleHandle(OTG_DRIVER);

  00060	e59f00bc	 ldr         r0, [pc, #0xBC]
  00064	e5846260	 str         r6, [r4, #0x260]
  00068	e5846264	 str         r6, [r4, #0x264]
  0006c	e5846268	 str         r6, [r4, #0x268]
  00070	e584626c	 str         r6, [r4, #0x26C]
  00074	eb000000	 bl          GetModuleHandleW
  00078	e1b05000	 movs        r5, r0

; 530  :     if (m_hOTGInstance == NULL)

  0007c	0a000021	 beq         |$LN2@HcdPdd_Ini|

; 531  :     {
; 532  :         DEBUGMSG(ZONE_ERROR, (TEXT("Failure to load %s\r\n"), OTG_DRIVER));
; 533  :         goto END;
; 534  :     }
; 535  : 
; 536  :     pPddObject->m_lpUSBClockProc = (LPMUSB_USBCLOCK_PROC)GetProcAddress(m_hOTGInstance, TEXT("OTGUSBClock"));

  00080	e59f1098	 ldr         r1, [pc, #0x98]
  00084	e1a00005	 mov         r0, r5
  00088	eb000000	 bl          GetProcAddressW
  0008c	e3500000	 cmp         r0, #0
  00090	e5840258	 str         r0, [r4, #0x258]

; 537  :     if (pPddObject->m_lpUSBClockProc == NULL)

  00094	0a00001b	 beq         |$LN2@HcdPdd_Ini|

; 538  :     {
; 539  :         DEBUGMSG(ZONE_ERROR, (TEXT("Failure to get OTGUSBClock\r\n")));
; 540  :         goto END;
; 541  :     }
; 542  : 
; 543  :     lphAttachProc = (LPMUSB_ATTACH_PROC)GetProcAddress(m_hOTGInstance, TEXT("OTGAttach"));

  00098	e59f107c	 ldr         r1, [pc, #0x7C]
  0009c	e1a00005	 mov         r0, r5
  000a0	eb000000	 bl          GetProcAddressW
  000a4	e1b03000	 movs        r3, r0

; 544  :     if (lphAttachProc == NULL)

  000a8	0a000016	 beq         |$LN2@HcdPdd_Ini|

; 545  :     {
; 546  :         DEBUGMSG(ZONE_ERROR, (TEXT("Failure to get OTGAttach\r\n")));
; 547  :         goto END;
; 548  :     }
; 549  : 
; 550  :     fRet = (*lphAttachProc)(&gc_MUsbFuncs, HOST_MODE, (LPLPVOID)&pOTG);

  000ac	e59f0064	 ldr         r0, [pc, #0x64]
  000b0	e28d2000	 add         r2, sp, #0
  000b4	e3a01002	 mov         r1, #2
  000b8	e1a0e00f	 mov         lr, pc
  000bc	e12fff13	 bx          r3
  000c0	e3500000	 cmp         r0, #0

; 551  :     if (fRet == FALSE)

  000c4	0a000006	 beq         |$LN14@HcdPdd_Ini|

; 552  :     {
; 553  :         DEBUGMSG(ZONE_ERROR, (TEXT("Error in performing the attach procedure\r\n")));
; 554  :         goto END;
; 555  :     }
; 556  : 
; 557  :     pOTG->pContext[HOST_MODE-1] = pPddObject;

  000c8	e59d3000	 ldr         r3, [sp]

; 558  : 
; 559  :     SetEvent(pOTG->hReadyEvents[HOST_MODE-1]);

  000cc	e3a01003	 mov         r1, #3
  000d0	e5834014	 str         r4, [r3, #0x14]
  000d4	e59d3000	 ldr         r3, [sp]
  000d8	e5930004	 ldr         r0, [r3, #4]
  000dc	eb000000	 bl          EventModify
  000e0		 |$END$41214|

; 560  : END:
; 561  :     if(!fRet)

  000e0	ea000008	 b           |$LN2@HcdPdd_Ini|
  000e4		 |$LN14@HcdPdd_Ini|

; 562  :     {
; 563  :         if (pPddObject && pPddObject->hParentBusHandle)

  000e4	e594324c	 ldr         r3, [r4, #0x24C]
  000e8	e3530000	 cmp         r3, #0

; 564  :              CloseBusAccessHandle(pPddObject->hParentBusHandle);

  000ec	11a00003	 movne       r0, r3
  000f0	1b000000	 blne        CloseBusAccessHandle
  000f4		 |$LN1@HcdPdd_Ini|

; 565  :             
; 566  :         DeleteCriticalSection(&pPddObject->csPdd);

  000f4	e2840f8d	 add         r0, r4, #0x8D, 30
  000f8	eb000000	 bl          DeleteCriticalSection

; 567  :         free(pPddObject);

  000fc	e1a00004	 mov         r0, r4
  00100	eb000000	 bl          free

; 568  :         pPddObject = NULL;

  00104	e3a04000	 mov         r4, #0
  00108		 |$LN2@HcdPdd_Ini|

; 569  :     }
; 570  :     
; 571  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("HcdPdd_Init-\r\n")));
; 572  :     return (DWORD)pPddObject;
; 573  : }

  00108	e1a00004	 mov         r0, r4
  0010c	e28dd004	 add         sp, sp, #4
  00110	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00114	e12fff1e	 bx          lr
  00118		 |$LN18@HcdPdd_Ini|
  00118		 |$LN19@HcdPdd_Ini|
  00118	00000000	 DCD         |gc_MUsbFuncs|
  0011c		 |$LN20@HcdPdd_Ini|
  0011c	00000000	 DCD         |??_C@_1BE@JNKHMKGH@?$AAO?$AAT?$AAG?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AA?$AA@|
  00120		 |$LN21@HcdPdd_Ini|
  00120	00000000	 DCD         |??_C@_1BI@KEGLAEOK@?$AAO?$AAT?$AAG?$AAU?$AAS?$AAB?$AAC?$AAl?$AAo?$AAc?$AAk?$AA?$AA@|
  00124		 |$LN22@HcdPdd_Ini|
  00124	00000000	 DCD         |??_C@_1CC@PKGPLCAL@?$AAo?$AAm?$AAa?$AAp?$AA_?$AAm?$AAu?$AAs?$AAb?$AAo?$AAt?$AAg?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@|
  00128		 |$LN23@HcdPdd_Ini|
  00128	00000000	 DCD         |g_dwContext|
  0012c		 |$M41550|

			 ENDP  ; |HcdPdd_Init|

	EXPORT	|HcdPdd_CheckConfigPower|

  00000			 AREA	 |.pdata|, PDATA
|$T41571| DCD	|$LN7@HcdPdd_Che|
	DCD	0x40000800
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_CheckConfigPower| PROC

; 599  : {

  00000		 |$LN7@HcdPdd_Che|
  00000		 |$M41568|

; 600  : 	UNREFERENCED_PARAMETER(bPort);
; 601  : 
; 602  :     return ((dwCfgPower + dwTotalPower) > dwMaxCurrent) ? FALSE : TRUE;

  00000	e59f3014	 ldr         r3, [pc, #0x14]
  00004	e0812002	 add         r2, r1, r2
  00008	e5933000	 ldr         r3, [r3]
  0000c	e1520003	 cmp         r2, r3
  00010	83a00000	 movhi       r0, #0
  00014	93a00001	 movls       r0, #1

; 603  : }

  00018	e12fff1e	 bx          lr
  0001c		 |$LN8@HcdPdd_Che|
  0001c		 |$LN9@HcdPdd_Che|
  0001c	00000000	 DCD         |dwMaxCurrent|
  00020		 |$M41569|

			 ENDP  ; |HcdPdd_CheckConfigPower|

	EXPORT	|HcdPdd_PowerUp|

  00000			 AREA	 |.pdata|, PDATA
|$T41580| DCD	|$LN5@HcdPdd_Pow|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_PowerUp| PROC

; 621  : {

  00000		 |$LN5@HcdPdd_Pow|
  00000		 |$M41577|

; 622  : #if 0
; 623  :     SMHCDPdd * pPddObject = (SMHCDPdd *)hDeviceContext;
; 624  :     HcdMdd_PowerUp(pPddObject->lpvMHCDMddObject);
; 625  : #else
; 626  : 	UNREFERENCED_PARAMETER(hDeviceContext);
; 627  : #endif
; 628  :     return;
; 629  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M41578|

			 ENDP  ; |HcdPdd_PowerUp|

	EXPORT	|HcdPdd_PowerDown|

  00000			 AREA	 |.pdata|, PDATA
|$T41587| DCD	|$LN5@HcdPdd_Pow@2|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_PowerDown| PROC

; 647  : {

  00000		 |$LN5@HcdPdd_Pow@2|
  00000		 |$M41584|

; 648  : #if 0
; 649  :     SMHCDPdd * pPddObject = (SMHCDPdd *)hDeviceContext;
; 650  :     HcdMdd_PowerDown(pPddObject->lpvMHCDMddObject);
; 651  : #else
; 652  : 	UNREFERENCED_PARAMETER(hDeviceContext);
; 653  : #endif
; 654  :     return;
; 655  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M41585|

			 ENDP  ; |HcdPdd_PowerDown|

	EXPORT	|HcdPdd_Deinit|

  00000			 AREA	 |.pdata|, PDATA
|$T41598| DCD	|$LN8@HcdPdd_Dei|
	DCD	0x40001b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_Deinit| PROC

; 673  : {

  00000		 |$LN8@HcdPdd_Dei|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M41595|
  00008	e1a04000	 mov         r4, r0

; 674  :     SMHCDPdd * pPddObject = (SMHCDPdd *)hDeviceContext;
; 675  : 
; 676  :     if(pPddObject->lpvMHCDMddObject)

  0000c	e5943004	 ldr         r3, [r4, #4]
  00010	e3530000	 cmp         r3, #0

; 677  :         HcdMdd_DestroyHcdObject(pPddObject->lpvMHCDMddObject);

  00014	11a00003	 movne       r0, r3
  00018	1b000000	 blne        HcdMdd_DestroyHcdObject

; 678  :     if(pPddObject->lpvMemoryObject)

  0001c	e5943000	 ldr         r3, [r4]
  00020	e3530000	 cmp         r3, #0

; 679  :         HcdMdd_DestroyMemoryObject(pPddObject->lpvMemoryObject);

  00024	11a00003	 movne       r0, r3
  00028	1b000000	 blne        HcdMdd_DestroyMemoryObject

; 680  :     if(pPddObject->pvVirtualAddress)

  0002c	e5943008	 ldr         r3, [r4, #8]
  00030	e1b0e003	 movs        lr, r3

; 681  :         HalFreeCommonBuffer(&pPddObject->AdapterObject, pPddObject->dwPhysicalMemSize, pPddObject->LogicalAddress, pPddObject->pvVirtualAddress, FALSE);

  00034	15942010	 ldrne       r2, [r4, #0x10]
  00038	15943014	 ldrne       r3, [r4, #0x14]
  0003c	1594100c	 ldrne       r1, [r4, #0xC]
  00040	13a05000	 movne       r5, #0
  00044	12840018	 addne       r0, r4, #0x18
  00048	158d5004	 strne       r5, [sp, #4]
  0004c	158de000	 strne       lr, [sp]
  00050	1b000000	 blne        HalFreeCommonBuffer

; 682  : 
; 683  :     free(pPddObject);

  00054	e1a00004	 mov         r0, r4
  00058	eb000000	 bl          free

; 684  :     return TRUE;

  0005c	e3a00001	 mov         r0, #1

; 685  :     
; 686  : }

  00060	e28dd008	 add         sp, sp, #8
  00064	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00068	e12fff1e	 bx          lr
  0006c		 |$M41596|

			 ENDP  ; |HcdPdd_Deinit|

	EXPORT	|HcdPdd_Open|

  00000			 AREA	 |.pdata|, PDATA
|$T41608| DCD	|$LN5@HcdPdd_Ope|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_Open| PROC

; 707  : {    

  00000		 |$LN5@HcdPdd_Ope|
  00000		 |$M41605|

; 708  :     UnusedParameter(AccessCode);
; 709  :     UnusedParameter(ShareMode);
; 710  : 
; 711  :     return hDeviceContext; // we can be opened, but only once!
; 712  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M41606|

			 ENDP  ; |HcdPdd_Open|

	EXPORT	|HcdPdd_Close|

  00000			 AREA	 |.pdata|, PDATA
|$T41617| DCD	|$LN5@HcdPdd_Clo|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_Close| PROC

; 730  : {

  00000		 |$LN5@HcdPdd_Clo|
  00000		 |$M41614|

; 731  :     UnusedParameter(hOpenContext);
; 732  : 
; 733  :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 734  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M41615|

			 ENDP  ; |HcdPdd_Close|

	EXPORT	|HcdPdd_Read|

  00000			 AREA	 |.pdata|, PDATA
|$T41626| DCD	|$LN5@HcdPdd_Rea|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_Read| PROC

; 754  : {

  00000		 |$LN5@HcdPdd_Rea|
  00000		 |$M41623|

; 755  :     UnusedParameter(hOpenContext);
; 756  :     UnusedParameter(pBuffer);
; 757  :     UnusedParameter(Count);
; 758  : 
; 759  :     return (DWORD)-1; // an error occured

  00000	e3e00000	 mvn         r0, #0

; 760  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M41624|

			 ENDP  ; |HcdPdd_Read|

	EXPORT	|HcdPdd_Write|

  00000			 AREA	 |.pdata|, PDATA
|$T41635| DCD	|$LN5@HcdPdd_Wri|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_Write| PROC

; 781  : {

  00000		 |$LN5@HcdPdd_Wri|
  00000		 |$M41632|

; 782  :     UnusedParameter(hOpenContext);
; 783  :     UnusedParameter(pSourceBytes);
; 784  :     UnusedParameter(NumberOfBytes);
; 785  : 
; 786  :     return (DWORD)-1;

  00000	e3e00000	 mvn         r0, #0

; 787  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M41633|

			 ENDP  ; |HcdPdd_Write|

	EXPORT	|HcdPdd_Seek|

  00000			 AREA	 |.pdata|, PDATA
|$T41644| DCD	|$LN5@HcdPdd_See|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_Seek| PROC

; 805  : {

  00000		 |$LN5@HcdPdd_See|
  00000		 |$M41641|

; 806  :     UnusedParameter(hOpenContext);
; 807  :     UnusedParameter(Amount);
; 808  :     UnusedParameter(Type);
; 809  : 
; 810  :     return (DWORD)-1;

  00000	e3e00000	 mvn         r0, #0

; 811  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M41642|

			 ENDP  ; |HcdPdd_Seek|

	EXPORT	|HcdPdd_IOControl|

  00000			 AREA	 |.pdata|, PDATA
|$T41653| DCD	|$LN8@HcdPdd_IOC|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_IOControl| PROC

; 830  : {

  00000		 |$LN8@HcdPdd_IOC|
  00000		 |$M41650|

; 831  :     BOOL rc = FALSE;
; 832  : 
; 833  : 	UNREFERENCED_PARAMETER(pdwActualOut);
; 834  : 	UNREFERENCED_PARAMETER(dwLenOut);
; 835  : 	UNREFERENCED_PARAMETER(pBufOut);
; 836  : 	UNREFERENCED_PARAMETER(dwLenIn);
; 837  : 	UNREFERENCED_PARAMETER(pBufIn);
; 838  : 	UNREFERENCED_PARAMETER(context);
; 839  : 
; 840  :     DEBUGMSG(ZONE_FUNCTION, (L"HcdPdd_IOControl with context (0x%x)\r\n", context));
; 841  : 
; 842  :     switch (dwCode)
; 843  :         {
; 844  :         case IOCTL_DVFS_OPPNOTIFY:
; 845  :             break;
; 846  : #if 0        
; 847  :         case IOCTL_DVFS_OPMNOTIFY:
; 848  :         {
; 849  :             IOCTL_DVFS_OPMNOTIFY_IN *pData =(IOCTL_DVFS_OPMNOTIFY_IN*)pBufIn;
; 850  :             
; 851  :             DEBUGMSG(ZONE_FUNCTION, (L"HcdPdd: received dvfs notification (%d)\r\n",
; 852  :                 pData->notification)
; 853  :                 );
; 854  :             
; 855  :             // this operation should be atomic to handle a corner case
; 856  :             EnterCriticalSection(&pPdd->csDVFS);
; 857  :             
; 858  :             // signal dvfs thread to stall SDRAM access
; 859  :             if (pData->notification == kPreNotice)
; 860  :             {
; 861  :                 pPdd->bDVFSActive = TRUE;
; 862  :                 HcdMdd_SignalExternalHub(pPdd->lpvMHCDMddObject);
; 863  :                 
; 864  :                 // check and halt dma if active
; 865  :                 //
; 866  :                 DEBUGMSG(ZONE_FUNCTION, (L"HcdPdd: Halting DMA for DVFS, "
; 867  :                     L"active dma count=%d\r\n",
; 868  :                     pPdd->nActiveDmaCount)
; 869  :                     );
; 870  :                 CheckAndHaltAllDma(pPdd, TRUE);
; 871  :                 DEBUGMSG(ZONE_FUNCTION, (L"HcdPdd: Pre-DVFS transition done\r\n"));
; 872  :             }
; 873  :             else if (pData->notification == kPostNotice)
; 874  :             {
; 875  :                 pPdd->bDVFSActive = FALSE;
; 876  :                 
; 877  :                 DEBUGMSG(ZONE_FUNCTION, (L"HcdPdd: continuing DMA for DVFS\r\n"));
; 878  :                 CheckAndHaltAllDma(pPdd, FALSE);
; 879  :                 DEBUGMSG(ZONE_FUNCTION, (L"HcdPdd: Post-DVFS transition done\r\n"));
; 880  :             }
; 881  :             LeaveCriticalSection(&pPdd->csDVFS);
; 882  :             rc = TRUE;
; 883  :         }
; 884  :             break;
; 885  : 
; 886  :         case IOCTL_DVFS_INITINFO:
; 887  :         {
; 888  :             IOCTL_DVFS_INITINFO_OUT *pInitInfo =(IOCTL_DVFS_INITINFO_OUT*)pBufOut;
; 889  :             pInitInfo->notifyMode = kAsynchronous;
; 890  :             pInitInfo->notifyOrder = pPdd->nDVFSOrder;
; 891  :             RETAILMSG(1, (TEXT("HSUSBHCD::DVFS_INITINFO return order %d\r\n"), pPdd->nDVFSOrder));
; 892  :             rc = TRUE;
; 893  :         }
; 894  :             break;
; 895  :         
; 896  :         case IOCTL_DVFS_OPMINFO:
; 897  :         {
; 898  :             IOCTL_DVFS_OPMINFO_IN *pData =(IOCTL_DVFS_OPMINFO_IN*)pBufIn;
; 899  :             CopyDVFSHandles(pPdd, pData->processId, 
; 900  :                 pData->hAckEvent, pData->hOpmEvent
; 901  :                 );
; 902  :             RETAILMSG(1, (TEXT("HSUSBHCD::DVFS_OPMINFO\r\n")));
; 903  :             rc = TRUE;
; 904  :         }
; 905  :             break;
; 906  : 
; 907  :         case IOCTL_DVFS_DETACH:
; 908  :         {
; 909  :             // close all handles
; 910  :             if (pPdd->hDVFSAckEvent != NULL)
; 911  :             {
; 912  :                 CloseHandle(pPdd->hDVFSAckEvent);
; 913  :                 pPdd->hDVFSAckEvent = NULL;
; 914  :             }
; 915  :             
; 916  :             if (pPdd->hDVFSActivityEvent!= NULL)
; 917  :             {
; 918  :                 CloseHandle(pPdd->hDVFSActivityEvent);
; 919  :                 pPdd->hDVFSActivityEvent = NULL;
; 920  :             }
; 921  :             rc = TRUE;
; 922  :         }
; 923  :             break;
; 924  : 
; 925  :         case IOCTL_DVFS_HALTMODE:
; 926  :         {
; 927  :             if (pPdd->bDVFSActive == FALSE)
; 928  :             {                
; 929  :                 IOCTL_DVFS_HALTMODE_IN *pData =(IOCTL_DVFS_HALTMODE_IN*)pBufIn;
; 930  :                 pPdd->rxHaltMode = pData->rxMode;
; 931  :                 pPdd->txHaltMode = pData->txMode;
; 932  :                 rc = TRUE;
; 933  :             }
; 934  :             break;
; 935  :         }
; 936  : #endif        
; 937  :         }
; 938  :     return rc;

  00000	e3a00000	 mov         r0, #0

; 939  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M41651|

			 ENDP  ; |HcdPdd_IOControl|

	EXPORT	|HcdPdd_InitiatePowerUp|

  00000			 AREA	 |.pdata|, PDATA
|$T41660| DCD	|$LN5@HcdPdd_Ini@2|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_InitiatePowerUp| PROC

; 961  : {

  00000		 |$LN5@HcdPdd_Ini@2|
  00000		 |$M41657|

; 962  : 	UNREFERENCED_PARAMETER(hDeviceContext);
; 963  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M41658|

			 ENDP  ; |HcdPdd_InitiatePowerUp|

	END
