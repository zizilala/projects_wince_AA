; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\OMAP3530\MUSB\MUSBHCD\MUSBMHDRC\chw.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1DK@JPBDFEOB@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAI?$AAN?$AAV?$AAA?$AAL?$AAI?$AAD?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DE@IMCKALLA@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAD?$AAO?$AAN?$AAE?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DI@CEGNOBAM@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAF?$AAA?$AAI?$AAL?$AAE?$AAD?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HO@PGHDEMEK@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAI?$AAG?$AAN?$AAA?$AAL?$AA_?$AAN?$AAE?$AAW?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1II@FBBOBKGN@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAI?$AAN?$AAS?$AAE?$AAR?$AAT?$AA_?$AAN?$AAE?$AAW?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FC@LCLFDJDO@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA_?$AAN?$AAE?$AAW?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EI@COKEBMOE@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA_?$AAN?$AAE?$AAW?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GG@HPGGGHKI@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HG@KPBCOGEF@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FG@CFFAAPDL@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GA@NDHJOKMM@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAD?$AAE?$AAT?$AAE?$AAR?$AAM?$AAI?$AAN?$AAE?$AA_?$AAC@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GM@JADKDKDC@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HM@NPLCKJLH@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HE@MEMGEMJJ@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAE?$AAT?$AAU?$AAP?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GM@BCHKIAPP@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HM@FNPCBDHK@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EI@BBOOKHNN@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAL?$AAE?$AAA?$AAV?$AAE?$AA_?$AAA?$AAD?$AAD?$AAR?$AAE@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FI@LGLHPFAK@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HG@BLNLBKIO@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FG@NMCKCJLL@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAR?$AAE?$AAS?$AAE?$AAT?$AA_?$AAA?$AAN?$AAD?$AA_?$AAE@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EI@KNOIBOPH@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAU?$AAS?$AAI?$AAN?$AAG?$AA_?$AAA?$AAD?$AAD?$AAR?$AAE@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FI@COMJHLEF@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAO?$AAP?$AAE?$AAN?$AAI?$AAN?$AAG?$AA_?$AAE?$AAN?$AAD@| [ DATA ] ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|dummpDesc| DCB	0x7
	DCB	0x5
	DCB	0xff
	DCB	0x3
	DCW	0x8
	DCB	0x1

  00000			 AREA	 |.data|, DATA
|cszCfgStateStrings| DCD |??_C@_1FI@COMJHLEF@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAO?$AAP?$AAE?$AAN?$AAI?$AAN?$AAG?$AA_?$AAE?$AAN?$AAD@|
	DCD	|??_C@_1EI@KNOIBOPH@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAU?$AAS?$AAI?$AAN?$AAG?$AA_?$AAA?$AAD?$AAD?$AAR?$AAE@|
	DCD	|??_C@_1FG@NMCKCJLL@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAR?$AAE?$AAS?$AAE?$AAT?$AA_?$AAA?$AAN?$AAD?$AA_?$AAE@|
	DCD	|??_C@_1HG@BLNLBKIO@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@|
	DCD	|??_C@_1FI@LGLHPFAK@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@|
	DCD	|??_C@_1EI@BBOOKHNN@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAL?$AAE?$AAA?$AAV?$AAE?$AA_?$AAA?$AAD?$AAD?$AAR?$AAE@|
	DCD	|??_C@_1HM@FNPCBDHK@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@|
	DCD	|??_C@_1GM@BCHKIAPP@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@|
	DCD	|??_C@_1HE@MEMGEMJJ@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAE?$AAT?$AAU?$AAP?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI@|
	DCD	|??_C@_1HM@NPLCKJLH@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@|
	DCD	|??_C@_1GM@JADKDKDC@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@|
	DCD	|??_C@_1GA@NDHJOKMM@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAD?$AAE?$AAT?$AAE?$AAR?$AAM?$AAI?$AAN?$AAE?$AA_?$AAC@|
	DCD	|??_C@_1FG@CFFAAPDL@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@|
	DCD	|??_C@_1HG@KPBCOGEF@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@|
	DCD	|??_C@_1GG@HPGGGHKI@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@|
	DCD	|??_C@_1EI@COKEBMOE@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA_?$AAN?$AAE?$AAW?$AA_@|
	DCD	|??_C@_1FC@LCLFDJDO@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA_?$AAN?$AAE?$AAW?$AA_@|
	DCD	|??_C@_1II@FBBOBKGN@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAI?$AAN?$AAS?$AAE?$AAR?$AAT?$AA_?$AAN?$AAE?$AAW?$AA_@|
	DCD	|??_C@_1HO@PGHDEMEK@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAI?$AAG?$AAN?$AAA?$AAL?$AA_?$AAN?$AAE?$AAW?$AA_@|
	DCD	|??_C@_1DI@CEGNOBAM@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAF?$AAA?$AAI?$AAL?$AAE?$AAD?$AA?$AA@|
	DCD	|??_C@_1DE@IMCKALLA@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAD?$AAO?$AAN?$AAE?$AA?$AA@|
	DCD	|??_C@_1DK@JPBDFEOB@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAI?$AAN?$AAV?$AAA?$AAL?$AAI?$AAD?$AA?$AA@|

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DK@JPBDFEOB@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAI?$AAN?$AAV?$AAA?$AAL?$AAI?$AAD?$AA?$AA@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "I", 0x0, "N", 0x0, "V", 0x0, "A"
	DCB	0x0, "L", 0x0, "I", 0x0, "D", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DE@IMCKALLA@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAD?$AAO?$AAN?$AAE?$AA?$AA@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "D", 0x0, "O", 0x0, "N", 0x0, "E"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DI@CEGNOBAM@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAF?$AAA?$AAI?$AAL?$AAE?$AAD?$AA?$AA@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "F", 0x0, "A", 0x0, "I", 0x0, "L"
	DCB	0x0, "E", 0x0, "D", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HO@PGHDEMEK@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAI?$AAG?$AAN?$AAA?$AAL?$AA_?$AAN?$AAE?$AAW?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "S", 0x0, "I", 0x0, "G", 0x0, "N"
	DCB	0x0, "A", 0x0, "L", 0x0, "_", 0x0, "N", 0x0, "E", 0x0, "W"
	DCB	0x0, "_", 0x0, "D", 0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C"
	DCB	0x0, "E", 0x0, "_", 0x0, "E", 0x0, "N", 0x0, "T", 0x0, "E"
	DCB	0x0, "R", 0x0, "_", 0x0, "O", 0x0, "P", 0x0, "E", 0x0, "R"
	DCB	0x0, "A", 0x0, "T", 0x0, "I", 0x0, "O", 0x0, "N", 0x0, "A"
	DCB	0x0, "L", 0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T"
	DCB	0x0, "E", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1II@FBBOBKGN@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAI?$AAN?$AAS?$AAE?$AAR?$AAT?$AA_?$AAN?$AAE?$AAW?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "I", 0x0, "N", 0x0, "S", 0x0, "E"
	DCB	0x0, "R", 0x0, "T", 0x0, "_", 0x0, "N", 0x0, "E", 0x0, "W"
	DCB	0x0, "_", 0x0, "D", 0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C"
	DCB	0x0, "E", 0x0, "_", 0x0, "I", 0x0, "N", 0x0, "T", 0x0, "O"
	DCB	0x0, "_", 0x0, "U", 0x0, "P", 0x0, "S", 0x0, "T", 0x0, "R"
	DCB	0x0, "E", 0x0, "A", 0x0, "M", 0x0, "_", 0x0, "H", 0x0, "U"
	DCB	0x0, "B", 0x0, "_", 0x0, "P", 0x0, "O", 0x0, "R", 0x0, "T"
	DCB	0x0, "_", 0x0, "A", 0x0, "R", 0x0, "R", 0x0, "A", 0x0, "Y"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FC@LCLFDJDO@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA_?$AAN?$AAE?$AAW?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "C", 0x0, "R", 0x0, "E", 0x0, "A"
	DCB	0x0, "T", 0x0, "E", 0x0, "_", 0x0, "N", 0x0, "E", 0x0, "W"
	DCB	0x0, "_", 0x0, "F", 0x0, "U", 0x0, "N", 0x0, "C", 0x0, "T"
	DCB	0x0, "I", 0x0, "O", 0x0, "N", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EI@COKEBMOE@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA_?$AAN?$AAE?$AAW?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "C", 0x0, "R", 0x0, "E", 0x0, "A"
	DCB	0x0, "T", 0x0, "E", 0x0, "_", 0x0, "N", 0x0, "E", 0x0, "W"
	DCB	0x0, "_", 0x0, "H", 0x0, "U", 0x0, "B", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GG@HPGGGHKI@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "S", 0x0, "C", 0x0, "H", 0x0, "E"
	DCB	0x0, "D", 0x0, "U", 0x0, "L", 0x0, "I", 0x0, "N", 0x0, "G"
	DCB	0x0, "_", 0x0, "G", 0x0, "E", 0x0, "T", 0x0, "_", 0x0, "H"
	DCB	0x0, "U", 0x0, "B", 0x0, "_", 0x0, "D", 0x0, "E", 0x0, "S"
	DCB	0x0, "C", 0x0, "R", 0x0, "I", 0x0, "P", 0x0, "T", 0x0, "O"
	DCB	0x0, "R", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HG@KPBCOGEF@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "S", 0x0, "C", 0x0, "H", 0x0, "E"
	DCB	0x0, "D", 0x0, "U", 0x0, "L", 0x0, "I", 0x0, "N", 0x0, "G"
	DCB	0x0, "_", 0x0, "G", 0x0, "E", 0x0, "T", 0x0, "_", 0x0, "I"
	DCB	0x0, "N", 0x0, "I", 0x0, "T", 0x0, "I", 0x0, "A", 0x0, "L"
	DCB	0x0, "_", 0x0, "H", 0x0, "U", 0x0, "B", 0x0, "_", 0x0, "D"
	DCB	0x0, "E", 0x0, "S", 0x0, "C", 0x0, "R", 0x0, "I", 0x0, "P"
	DCB	0x0, "T", 0x0, "O", 0x0, "R", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FG@CFFAAPDL@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "S", 0x0, "C", 0x0, "H", 0x0, "E"
	DCB	0x0, "D", 0x0, "U", 0x0, "L", 0x0, "I", 0x0, "N", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "E", 0x0, "T", 0x0, "_", 0x0, "C"
	DCB	0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GA@NDHJOKMM@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAD?$AAE?$AAT?$AAE?$AAR?$AAM?$AAI?$AAN?$AAE?$AA_?$AAC@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "D", 0x0, "E", 0x0, "T", 0x0, "E"
	DCB	0x0, "R", 0x0, "M", 0x0, "I", 0x0, "N", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "T", 0x0, "O", 0x0, "_", 0x0, "C", 0x0, "H"
	DCB	0x0, "O", 0x0, "O", 0x0, "S", 0x0, "E", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GM@JADKDKDC@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "S", 0x0, "C", 0x0, "H", 0x0, "E"
	DCB	0x0, "D", 0x0, "U", 0x0, "L", 0x0, "I", 0x0, "N", 0x0, "G"
	DCB	0x0, "_", 0x0, "G", 0x0, "E", 0x0, "T", 0x0, "_", 0x0, "C"
	DCB	0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G", 0x0, "_"
	DCB	0x0, "D", 0x0, "E", 0x0, "S", 0x0, "C", 0x0, "R", 0x0, "I"
	DCB	0x0, "P", 0x0, "T", 0x0, "O", 0x0, "R", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HM@NPLCKJLH@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "S", 0x0, "C", 0x0, "H", 0x0, "E"
	DCB	0x0, "D", 0x0, "U", 0x0, "L", 0x0, "I", 0x0, "N", 0x0, "G"
	DCB	0x0, "_", 0x0, "G", 0x0, "E", 0x0, "T", 0x0, "_", 0x0, "I"
	DCB	0x0, "N", 0x0, "I", 0x0, "T", 0x0, "I", 0x0, "A", 0x0, "L"
	DCB	0x0, "_", 0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I"
	DCB	0x0, "G", 0x0, "_", 0x0, "D", 0x0, "E", 0x0, "S", 0x0, "C"
	DCB	0x0, "R", 0x0, "I", 0x0, "P", 0x0, "T", 0x0, "O", 0x0, "R"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HE@MEMGEMJJ@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAE?$AAT?$AAU?$AAP?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "S", 0x0, "E", 0x0, "T", 0x0, "U"
	DCB	0x0, "P", 0x0, "_", 0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F"
	DCB	0x0, "I", 0x0, "G", 0x0, "U", 0x0, "R", 0x0, "A", 0x0, "T"
	DCB	0x0, "I", 0x0, "O", 0x0, "N", 0x0, "_", 0x0, "D", 0x0, "E"
	DCB	0x0, "S", 0x0, "C", 0x0, "R", 0x0, "I", 0x0, "P", 0x0, "T"
	DCB	0x0, "O", 0x0, "R", 0x0, "_", 0x0, "A", 0x0, "R", 0x0, "R"
	DCB	0x0, "A", 0x0, "Y", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GM@BCHKIAPP@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "S", 0x0, "C", 0x0, "H", 0x0, "E"
	DCB	0x0, "D", 0x0, "U", 0x0, "L", 0x0, "I", 0x0, "N", 0x0, "G"
	DCB	0x0, "_", 0x0, "G", 0x0, "E", 0x0, "T", 0x0, "_", 0x0, "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "D", 0x0, "E", 0x0, "S", 0x0, "C", 0x0, "R", 0x0, "I"
	DCB	0x0, "P", 0x0, "T", 0x0, "O", 0x0, "R", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HM@FNPCBDHK@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "S", 0x0, "C", 0x0, "H", 0x0, "E"
	DCB	0x0, "D", 0x0, "U", 0x0, "L", 0x0, "I", 0x0, "N", 0x0, "G"
	DCB	0x0, "_", 0x0, "G", 0x0, "E", 0x0, "T", 0x0, "_", 0x0, "I"
	DCB	0x0, "N", 0x0, "I", 0x0, "T", 0x0, "I", 0x0, "A", 0x0, "L"
	DCB	0x0, "_", 0x0, "D", 0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C"
	DCB	0x0, "E", 0x0, "_", 0x0, "D", 0x0, "E", 0x0, "S", 0x0, "C"
	DCB	0x0, "R", 0x0, "I", 0x0, "P", 0x0, "T", 0x0, "O", 0x0, "R"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EI@BBOOKHNN@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAL?$AAE?$AAA?$AAV?$AAE?$AA_?$AAA?$AAD?$AAD?$AAR?$AAE@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "L", 0x0, "E", 0x0, "A", 0x0, "V"
	DCB	0x0, "E", 0x0, "_", 0x0, "A", 0x0, "D", 0x0, "D", 0x0, "R"
	DCB	0x0, "E", 0x0, "S", 0x0, "S", 0x0, "0", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FI@LGLHPFAK@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "S", 0x0, "C", 0x0, "H", 0x0, "E"
	DCB	0x0, "D", 0x0, "U", 0x0, "L", 0x0, "I", 0x0, "N", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "E", 0x0, "T", 0x0, "_", 0x0, "A"
	DCB	0x0, "D", 0x0, "D", 0x0, "R", 0x0, "E", 0x0, "S", 0x0, "S"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HG@BLNLBKIO@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAS?$AAC?$AAH?$AAE?$AAD?$AAU?$AAL?$AAI?$AAN?$AAG?$AA_@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "S", 0x0, "C", 0x0, "H", 0x0, "E"
	DCB	0x0, "D", 0x0, "U", 0x0, "L", 0x0, "I", 0x0, "N", 0x0, "G"
	DCB	0x0, "_", 0x0, "G", 0x0, "E", 0x0, "T", 0x0, "_", 0x0, "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "D", 0x0, "E", 0x0, "S", 0x0, "C", 0x0, "R", 0x0, "I"
	DCB	0x0, "P", 0x0, "T", 0x0, "O", 0x0, "R", 0x0, "_", 0x0, "T"
	DCB	0x0, "E", 0x0, "S", 0x0, "T", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FG@NMCKCJLL@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAR?$AAE?$AAS?$AAE?$AAT?$AA_?$AAA?$AAN?$AAD?$AA_?$AAE@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "R", 0x0, "E", 0x0, "S", 0x0, "E"
	DCB	0x0, "T", 0x0, "_", 0x0, "A", 0x0, "N", 0x0, "D", 0x0, "_"
	DCB	0x0, "E", 0x0, "N", 0x0, "A", 0x0, "B", 0x0, "L", 0x0, "E"
	DCB	0x0, "_", 0x0, "P", 0x0, "O", 0x0, "R", 0x0, "T", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EI@KNOIBOPH@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAU?$AAS?$AAI?$AAN?$AAG?$AA_?$AAA?$AAD?$AAD?$AAR?$AAE@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "U", 0x0, "S", 0x0, "I", 0x0, "N"
	DCB	0x0, "G", 0x0, "_", 0x0, "A", 0x0, "D", 0x0, "D", 0x0, "R"
	DCB	0x0, "E", 0x0, "S", 0x0, "S", 0x0, "0", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FI@COMJHLEF@?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU?$AAS?$AA_?$AAO?$AAP?$AAE?$AAN?$AAI?$AAN?$AAG?$AA_?$AAE?$AAN?$AAD@| DCB "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C", 0x0, "E", 0x0, "_"
	DCB	0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F", 0x0, "I", 0x0, "G"
	DCB	0x0, "_", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, "_", 0x0, "O", 0x0, "P", 0x0, "E", 0x0, "N"
	DCB	0x0, "I", 0x0, "N", 0x0, "G", 0x0, "_", 0x0, "E", 0x0, "N"
	DCB	0x0, "D", 0x0, "P", 0x0, "O", 0x0, "I", 0x0, "N", 0x0, "T"
	DCB	0x0, "0", 0x0, "_", 0x0, "P", 0x0, "I", 0x0, "P", 0x0, "E"
	DCB	0x0, 0x0, 0x0				; `string'
	EXPORT	|SetEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T43855| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43852|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M43853|

			 ENDP  ; |SetEvent|

	EXPORT	|?SetStatus@CQTD@@QAAXK@Z|		; CQTD::SetStatus
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\ctd.h

  00000			 AREA	 |.pdata|, PDATA
|$T43864| DCD	|$LN5@SetStatus|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetStatus@CQTD@@QAAXK@Z| PROC	; CQTD::SetStatus

; 85   :     void SetStatus(DWORD status) { m_dwStatus = status;};

  00000		 |$LN5@SetStatus|
  00000		 |$M43861|
  00000	e5801028	 str         r1, [r0, #0x28]
  00004	e12fff1e	 bx          lr
  00008		 |$M43862|

			 ENDP  ; |?SetStatus@CQTD@@QAAXK@Z|, CQTD::SetStatus

	EXPORT	|?SetCurTfrSize@CQTD@@QAAXK@Z|		; CQTD::SetCurTfrSize

  00000			 AREA	 |.pdata|, PDATA
|$T43873| DCD	|$LN5@SetCurTfrS|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetCurTfrSize@CQTD@@QAAXK@Z| PROC	; CQTD::SetCurTfrSize

; 87   :     void SetCurTfrSize(DWORD size) { m_cbCurTransferred = size;};

  00000		 |$LN5@SetCurTfrS|
  00000		 |$M43870|
  00000	e5801020	 str         r1, [r0, #0x20]
  00004	e12fff1e	 bx          lr
  00008		 |$M43871|

			 ENDP  ; |?SetCurTfrSize@CQTD@@QAAXK@Z|, CQTD::SetCurTfrSize

	EXPORT	|?GetStatus@CQTD@@QAAKXZ|		; CQTD::GetStatus

  00000			 AREA	 |.pdata|, PDATA
|$T43883| DCD	|$LN5@GetStatus|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetStatus@CQTD@@QAAKXZ| PROC		; CQTD::GetStatus

; 90   :     DWORD GetStatus() { return m_dwStatus; };

  00000		 |$LN5@GetStatus|
  00000		 |$M43880|
  00000	e5900028	 ldr         r0, [r0, #0x28]
  00004	e12fff1e	 bx          lr
  00008		 |$M43881|

			 ENDP  ; |?GetStatus@CQTD@@QAAKXZ|, CQTD::GetStatus

	EXPORT	|?GetTDType@CQTD@@QAAKXZ|		; CQTD::GetTDType

  00000			 AREA	 |.pdata|, PDATA
|$T43893| DCD	|$LN5@GetTDType|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetTDType@CQTD@@QAAKXZ| PROC		; CQTD::GetTDType

; 92   :     DWORD GetTDType() { return m_dwTDType; };

  00000		 |$LN5@GetTDType|
  00000		 |$M43890|
  00000	e590000c	 ldr         r0, [r0, #0xC]
  00004	e12fff1e	 bx          lr
  00008		 |$M43891|

			 ENDP  ; |?GetTDType@CQTD@@QAAKXZ|, CQTD::GetTDType

	EXPORT	|?GetDataSize@CQTD@@QAAKXZ|		; CQTD::GetDataSize

  00000			 AREA	 |.pdata|, PDATA
|$T43903| DCD	|$LN5@GetDataSiz|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetDataSize@CQTD@@QAAKXZ| PROC	; CQTD::GetDataSize

; 93   :     DWORD GetDataSize() { return m_cbData; };

  00000		 |$LN5@GetDataSiz|
  00000		 |$M43900|
  00000	e5900018	 ldr         r0, [r0, #0x18]
  00004	e12fff1e	 bx          lr
  00008		 |$M43901|

			 ENDP  ; |?GetDataSize@CQTD@@QAAKXZ|, CQTD::GetDataSize

	EXPORT	|?GetPAData@CQTD@@QAAKXZ|		; CQTD::GetPAData

  00000			 AREA	 |.pdata|, PDATA
|$T43913| DCD	|$LN5@GetPAData|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetPAData@CQTD@@QAAKXZ| PROC		; CQTD::GetPAData

; 94   :     DWORD GetPAData() { return m_dwPAData; };

  00000		 |$LN5@GetPAData|
  00000		 |$M43910|
  00000	e5900010	 ldr         r0, [r0, #0x10]
  00004	e12fff1e	 bx          lr
  00008		 |$M43911|

			 ENDP  ; |?GetPAData@CQTD@@QAAKXZ|, CQTD::GetPAData

	EXPORT	|?GetVAData@CQTD@@QAAKXZ|		; CQTD::GetVAData

  00000			 AREA	 |.pdata|, PDATA
|$T43923| DCD	|$LN5@GetVAData|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetVAData@CQTD@@QAAKXZ| PROC		; CQTD::GetVAData

; 95   :     DWORD GetVAData() { return m_dwVAData; };

  00000		 |$LN5@GetVAData|
  00000		 |$M43920|
  00000	e5900014	 ldr         r0, [r0, #0x14]
  00004	e12fff1e	 bx          lr
  00008		 |$M43921|

			 ENDP  ; |?GetVAData@CQTD@@QAAKXZ|, CQTD::GetVAData

	EXPORT	|?GetTotTfrSize@CQTD@@QAAKXZ|		; CQTD::GetTotTfrSize

  00000			 AREA	 |.pdata|, PDATA
|$T43933| DCD	|$LN5@GetTotTfrS|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetTotTfrSize@CQTD@@QAAKXZ| PROC	; CQTD::GetTotTfrSize

; 96   :     DWORD GetTotTfrSize() { return m_cbTransferred; };

  00000		 |$LN5@GetTotTfrS|
  00000		 |$M43930|
  00000	e590001c	 ldr         r0, [r0, #0x1C]
  00004	e12fff1e	 bx          lr
  00008		 |$M43931|

			 ENDP  ; |?GetTotTfrSize@CQTD@@QAAKXZ|, CQTD::GetTotTfrSize

	EXPORT	|?GetPacketSize@CQTD@@QAAKXZ|		; CQTD::GetPacketSize

  00000			 AREA	 |.pdata|, PDATA
|$T43943| DCD	|$LN5@GetPacketS|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetPacketSize@CQTD@@QAAKXZ| PROC	; CQTD::GetPacketSize

; 98   :     DWORD GetPacketSize() { return m_dwPacketSize;};    

  00000		 |$LN5@GetPacketS|
  00000		 |$M43940|
  00000	e590002c	 ldr         r0, [r0, #0x2C]
  00004	e12fff1e	 bx          lr
  00008		 |$M43941|

			 ENDP  ; |?GetPacketSize@CQTD@@QAAKXZ|, CQTD::GetPacketSize

	EXPORT	|?GetQH@CQTD@@QAAPAVCQH@@XZ|		; CQTD::GetQH

  00000			 AREA	 |.pdata|, PDATA
|$T43953| DCD	|$LN5@GetQH|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetQH@CQTD@@QAAPAVCQH@@XZ| PROC	; CQTD::GetQH

; 103  :     CQH *GetQH() { return m_pQh;};

  00000		 |$LN5@GetQH|
  00000		 |$M43950|
  00000	e5900004	 ldr         r0, [r0, #4]
  00004	e12fff1e	 bx          lr
  00008		 |$M43951|

			 ENDP  ; |?GetQH@CQTD@@QAAPAVCQH@@XZ|, CQTD::GetQH

	EXPORT	|?GetPipe@CQH@@QAAPAVCPipe@@XZ|		; CQH::GetPipe

  00000			 AREA	 |.pdata|, PDATA
|$T43963| DCD	|$LN5@GetPipe|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetPipe@CQH@@QAAPAVCPipe@@XZ| PROC	; CQH::GetPipe

; 156  :     CPipe *GetPipe() { return m_pPipe;};

  00000		 |$LN5@GetPipe|
  00000		 |$M43960|
  00000	e5900000	 ldr         r0, [r0]
  00004	e12fff1e	 bx          lr
  00008		 |$M43961|

			 ENDP  ; |?GetPipe@CQH@@QAAPAVCPipe@@XZ|, CQH::GetPipe

	EXPORT	|??0LockObject@@QAA@XZ|			; LockObject::LockObject
	IMPORT	|InitializeCriticalSection|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T43973| DCD	|$LN5@LockObject|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0LockObject@@QAA@XZ| PROC		; LockObject::LockObject

; 71   :     LockObject() { InitializeCriticalSection(&m_CSection); };

  00000		 |$LN5@LockObject|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M43970|
  00004	e1a04000	 mov         r4, r0
  00008	eb000000	 bl          InitializeCriticalSection
  0000c	e1a00004	 mov         r0, r4
  00010	e8bd4010	 ldmia       sp!, {r4, lr}
  00014	e12fff1e	 bx          lr
  00018		 |$M43971|

			 ENDP  ; |??0LockObject@@QAA@XZ|, LockObject::LockObject

	EXPORT	|??1LockObject@@QAA@XZ|			; LockObject::~LockObject
	IMPORT	|DeleteCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T43981| DCD	|$LN5@LockObject@2|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1LockObject@@QAA@XZ| PROC		; LockObject::~LockObject

; 72   :     ~LockObject() { DeleteCriticalSection( &m_CSection); };

  00000		 |$LN5@LockObject@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43978|
  00004	eb000000	 bl          DeleteCriticalSection
  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M43979|

			 ENDP  ; |??1LockObject@@QAA@XZ|, LockObject::~LockObject

	EXPORT	|?Lock@LockObject@@QAAXXZ|		; LockObject::Lock
	IMPORT	|EnterCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T43989| DCD	|$LN5@Lock|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Lock@LockObject@@QAAXXZ| PROC	; LockObject::Lock

; 73   :     void Lock(void) { EnterCriticalSection(&m_CSection); };

  00000		 |$LN5@Lock|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43986|
  00004	eb000000	 bl          EnterCriticalSection
  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M43987|

			 ENDP  ; |?Lock@LockObject@@QAAXXZ|, LockObject::Lock

	EXPORT	|?Unlock@LockObject@@QAAXXZ|		; LockObject::Unlock
	IMPORT	|LeaveCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T43997| DCD	|$LN5@Unlock|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Unlock@LockObject@@QAAXXZ| PROC	; LockObject::Unlock

; 74   :     void Unlock(void) {LeaveCriticalSection( &m_CSection); };

  00000		 |$LN5@Unlock|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43994|
  00004	eb000000	 bl          LeaveCriticalSection
  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M43995|

			 ENDP  ; |?Unlock@LockObject@@QAAXXZ|, LockObject::Unlock

	EXPORT	|?GetNumberOfPort@CHub@@QAAHXZ|		; CHub::GetNumberOfPort
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T44007| DCD	|$LN5@GetNumberO|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetNumberOfPort@CHub@@QAAHXZ| PROC	; CHub::GetNumberOfPort

; 433  :     int         GetNumberOfPort() { return m_usbHubDescriptor.bNumberOfPorts;};

  00000		 |$LN5@GetNumberO|
  00000		 |$M44004|
  00000	e5d0006a	 ldrb        r0, [r0, #0x6A]
  00004	e12fff1e	 bx          lr
  00008		 |$M44005|

			 ENDP  ; |?GetNumberOfPort@CHub@@QAAHXZ|, CHub::GetNumberOfPort

	EXPORT	|?GetDeviceOnPort@CHub@@QAAPAPAVCDevice@@XZ| ; CHub::GetDeviceOnPort

  00000			 AREA	 |.pdata|, PDATA
|$T44017| DCD	|$LN5@GetDeviceO|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetDeviceOnPort@CHub@@QAAPAPAVCDevice@@XZ| PROC ; CHub::GetDeviceOnPort

; 434  :     CDevice**   GetDeviceOnPort() { return m_ppCDeviceOnPort; };    

  00000		 |$LN5@GetDeviceO|
  00000		 |$M44014|
  00000	e59000b0	 ldr         r0, [r0, #0xB0]
  00004	e12fff1e	 bx          lr
  00008		 |$M44015|

			 ENDP  ; |?GetDeviceOnPort@CHub@@QAAPAPAVCDevice@@XZ|, CHub::GetDeviceOnPort

	EXPORT	|?GetEndptDescriptor@CPipe@@QAA?AU_USB_ENDPOINT_DESCRIPTOR@@XZ| ; CPipe::GetEndptDescriptor
	IMPORT	|memcpy|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\cpipe.h

  00000			 AREA	 |.pdata|, PDATA
|$T44029| DCD	|$LN5@GetEndptDe|
	DCD	0x40000901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetEndptDescriptor@CPipe@@QAA?AU_USB_ENDPOINT_DESCRIPTOR@@XZ| PROC ; CPipe::GetEndptDescriptor

; 96   :     USB_ENDPOINT_DESCRIPTOR GetEndptDescriptor() { return m_usbEndpointDescriptor;};

  00000		 |$LN5@GetEndptDe|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M44026|
  00004	e1a04001	 mov         r4, r1
  00008	e2801034	 add         r1, r0, #0x34
  0000c	e1a00004	 mov         r0, r4
  00010	e3a02007	 mov         r2, #7
  00014	eb000000	 bl          memcpy
  00018	e1a00004	 mov         r0, r4
  0001c	e8bd4010	 ldmia       sp!, {r4, lr}
  00020	e12fff1e	 bx          lr
  00024		 |$M44027|

			 ENDP  ; |?GetEndptDescriptor@CPipe@@QAA?AU_USB_ENDPOINT_DESCRIPTOR@@XZ|, CPipe::GetEndptDescriptor

	EXPORT	|?GetMappedEndPoint@CPipe@@QAAEXZ|	; CPipe::GetMappedEndPoint

  00000			 AREA	 |.pdata|, PDATA
|$T44039| DCD	|$LN5@GetMappedE|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetMappedEndPoint@CPipe@@QAAEXZ| PROC ; CPipe::GetMappedEndPoint

; 103  :     UCHAR   GetMappedEndPoint(void) { return m_mappedEndpoint; };

  00000		 |$LN5@GetMappedE|
  00000		 |$M44036|
  00000	e5d00058	 ldrb        r0, [r0, #0x58]
  00004	e12fff1e	 bx          lr
  00008		 |$M44037|

			 ENDP  ; |?GetMappedEndPoint@CPipe@@QAAEXZ|, CPipe::GetMappedEndPoint

	EXPORT	|?SetMappedEndPoint@CPipe@@QAAXE@Z|	; CPipe::SetMappedEndPoint

  00000			 AREA	 |.pdata|, PDATA
|$T44048| DCD	|$LN5@SetMappedE|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetMappedEndPoint@CPipe@@QAAXE@Z| PROC ; CPipe::SetMappedEndPoint

; 104  :     void    SetMappedEndPoint(UCHAR mappedEP) { m_mappedEndpoint = mappedEP;};

  00000		 |$LN5@SetMappedE|
  00000		 |$M44045|
  00000	e5c01058	 strb        r1, [r0, #0x58]
  00004	e12fff1e	 bx          lr
  00008		 |$M44046|

			 ENDP  ; |?SetMappedEndPoint@CPipe@@QAAXE@Z|, CPipe::SetMappedEndPoint

	EXPORT	|?GetEPTransferEvent@CPipe@@QAAPAXXZ|	; CPipe::GetEPTransferEvent

  00000			 AREA	 |.pdata|, PDATA
|$T44058| DCD	|$LN5@GetEPTrans|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetEPTransferEvent@CPipe@@QAAPAXXZ| PROC ; CPipe::GetEPTransferEvent

; 108  :     HANDLE  GetEPTransferEvent(void) { return m_hEPTransferEvent;};

  00000		 |$LN5@GetEPTrans|
  00000		 |$M44055|
  00000	e590005c	 ldr         r0, [r0, #0x5C]
  00004	e12fff1e	 bx          lr
  00008		 |$M44056|

			 ENDP  ; |?GetEPTransferEvent@CPipe@@QAAPAXXZ|, CPipe::GetEPTransferEvent

	EXPORT	|?GetDMATransferEvent@CPipe@@QAAPAXXZ|	; CPipe::GetDMATransferEvent

  00000			 AREA	 |.pdata|, PDATA
|$T44068| DCD	|$LN5@GetDMATran|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetDMATransferEvent@CPipe@@QAAPAXXZ| PROC ; CPipe::GetDMATransferEvent

; 109  :     HANDLE  GetDMATransferEvent(void) { return m_hDMATransferEvent;};

  00000		 |$LN5@GetDMATran|
  00000		 |$M44065|
  00000	e5900060	 ldr         r0, [r0, #0x60]
  00004	e12fff1e	 bx          lr
  00008		 |$M44066|

			 ENDP  ; |?GetDMATransferEvent@CPipe@@QAAPAXXZ|, CPipe::GetDMATransferEvent

	EXPORT	|?GetTransferMode@CPipe@@QAAEXZ|	; CPipe::GetTransferMode

  00000			 AREA	 |.pdata|, PDATA
|$T44078| DCD	|$LN5@GetTransfe|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetTransferMode@CPipe@@QAAEXZ| PROC	; CPipe::GetTransferMode

; 110  :     UCHAR   GetTransferMode(void) { return m_ucTransferMode;};

  00000		 |$LN5@GetTransfe|
  00000		 |$M44075|
  00000	e5d00014	 ldrb        r0, [r0, #0x14]
  00004	e12fff1e	 bx          lr
  00008		 |$M44076|

			 ENDP  ; |?GetTransferMode@CPipe@@QAAEXZ|, CPipe::GetTransferMode

	EXPORT	|?GetRootHub@CHcd@@QAAPAVCRootHub@@XZ|	; CHcd::GetRootHub
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T44088| DCD	|$LN5@GetRootHub|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetRootHub@CHcd@@QAAPAVCRootHub@@XZ| PROC ; CHcd::GetRootHub

; 100  :     CRootHub* GetRootHub() { return m_pCRootHub;};

  00000		 |$LN5@GetRootHub|
  00000		 |$M44085|
  00000	e59000ac	 ldr         r0, [r0, #0xAC]
  00004	e12fff1e	 bx          lr
  00008		 |$M44086|

			 ENDP  ; |?GetRootHub@CHcd@@QAAPAVCRootHub@@XZ|, CHcd::GetRootHub

	EXPORT	|?GetOTGContext@CHcd@@QAAPAXXZ|		; CHcd::GetOTGContext

  00000			 AREA	 |.pdata|, PDATA
|$T44098| DCD	|$LN5@GetOTGCont|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetOTGContext@CHcd@@QAAPAXXZ| PROC	; CHcd::GetOTGContext

; 121  :     PVOID   GetOTGContext() { return m_pOTG;};

  00000		 |$LN5@GetOTGCont|
  00000		 |$M44095|
  00000	e59000b0	 ldr         r0, [r0, #0xB0]
  00004	e12fff1e	 bx          lr
  00008		 |$M44096|

			 ENDP  ; |?GetOTGContext@CHcd@@QAAPAXXZ|, CHcd::GetOTGContext

	EXPORT	|?SetOTGContext@CHcd@@QAAXPAX@Z|	; CHcd::SetOTGContext

  00000			 AREA	 |.pdata|, PDATA
|$T44107| DCD	|$LN5@SetOTGCont|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetOTGContext@CHcd@@QAAXPAX@Z| PROC	; CHcd::SetOTGContext

; 122  :     void    SetOTGContext(PVOID pOTG) { m_pOTG = pOTG;};    

  00000		 |$LN5@SetOTGCont|
  00000		 |$M44104|
  00000	e58010b0	 str         r1, [r0, #0xB0]
  00004	e12fff1e	 bx          lr
  00008		 |$M44105|

			 ENDP  ; |?SetOTGContext@CHcd@@QAAXPAX@Z|, CHcd::SetOTGContext

	EXPORT	|??0CBusyPipeList@@QAA@K@Z|		; CBusyPipeList::CBusyPipeList
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T44121| DCD	|$LN7@CBusyPipeL|
	DCD	0x40000801
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.h

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CBusyPipeList@@QAA@K@Z| PROC	; CBusyPipeList::CBusyPipeList

; 179  :     CBusyPipeList(DWORD dwFrameSize) { m_FrameListSize=dwFrameSize;};

  00000		 |$LN7@CBusyPipeL|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44118|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          InitializeCriticalSection
  00010	e58540b4	 str         r4, [r5, #0xB4]
  00014	e1a00005	 mov         r0, r5
  00018	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0001c	e12fff1e	 bx          lr
  00020		 |$M44119|

			 ENDP  ; |??0CBusyPipeList@@QAA@K@Z|, CBusyPipeList::CBusyPipeList

	EXPORT	|?SetRxDataAvail@CHW@@QAAXE@Z|		; CHW::SetRxDataAvail

  00000			 AREA	 |.pdata|, PDATA
|$T44130| DCD	|$LN5@SetRxDataA|
	DCD	0x40000600
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetRxDataAvail@CHW@@QAAXE@Z| PROC	; CHW::SetRxDataAvail

; 387  :     void SetRxDataAvail(UCHAR endpoint) { m_intr_rx_avail |= (1<<endpoint);};

  00000		 |$LN5@SetRxDataA|
  00000		 |$M44127|
  00000	e2802c02	 add         r2, r0, #2, 24
  00004	e1d237ba	 ldrh        r3, [r2, #0x7A]
  00008	e3a00001	 mov         r0, #1
  0000c	e1833110	 orr         r3, r3, r0, lsl r1
  00010	e1c237ba	 strh        r3, [r2, #0x7A]
  00014	e12fff1e	 bx          lr
  00018		 |$M44128|

			 ENDP  ; |?SetRxDataAvail@CHW@@QAAXE@Z|, CHW::SetRxDataAvail

	EXPORT	|?GetRxDataAvail@CHW@@QAAHE@Z|		; CHW::GetRxDataAvail

  00000			 AREA	 |.pdata|, PDATA
|$T44143| DCD	|$LN7@GetRxDataA|
	DCD	0x40000700
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetRxDataAvail@CHW@@QAAHE@Z| PROC	; CHW::GetRxDataAvail

; 388  :     BOOL GetRxDataAvail(UCHAR endpoint) { return ((m_intr_rx_avail & (1<<endpoint))? TRUE: FALSE);};

  00000		 |$LN7@GetRxDataA|
  00000		 |$M44140|
  00000	e2803c02	 add         r3, r0, #2, 24
  00004	e1d337ba	 ldrh        r3, [r3, #0x7A]
  00008	e3a02001	 mov         r2, #1
  0000c	e1130112	 tst         r3, r2, lsl r1
  00010	13a00001	 movne       r0, #1
  00014	03a00000	 moveq       r0, #0
  00018	e12fff1e	 bx          lr
  0001c		 |$M44141|

			 ENDP  ; |?GetRxDataAvail@CHW@@QAAHE@Z|, CHW::GetRxDataAvail

	EXPORT	|?ClrRxDataAvail@CHW@@QAAXE@Z|		; CHW::ClrRxDataAvail

  00000			 AREA	 |.pdata|, PDATA
|$T44152| DCD	|$LN5@ClrRxDataA|
	DCD	0x40000600
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ClrRxDataAvail@CHW@@QAAXE@Z| PROC	; CHW::ClrRxDataAvail

; 389  :     void ClrRxDataAvail(UCHAR endpoint) { (m_intr_rx_avail &=~(1<<endpoint));};    

  00000		 |$LN5@ClrRxDataA|
  00000		 |$M44149|
  00000	e2802c02	 add         r2, r0, #2, 24
  00004	e1d237ba	 ldrh        r3, [r2, #0x7A]
  00008	e3a00001	 mov         r0, #1
  0000c	e1c33110	 bic         r3, r3, r0, lsl r1
  00010	e1c237ba	 strh        r3, [r2, #0x7A]
  00014	e12fff1e	 bx          lr
  00018		 |$M44150|

			 ENDP  ; |?ClrRxDataAvail@CHW@@QAAXE@Z|, CHW::ClrRxDataAvail

	EXPORT	|??0CDummyPipe@@QAA@QAVCPhysMem@@@Z|	; CDummyPipe::CDummyPipe
	EXPORT	|??_7CDummyPipe@@6B@| [ DATA ]		; CDummyPipe::`vftable'
	EXPORT	|?OpenPipe@CDummyPipe@@UAA?AW4HCD_REQUEST_STATUS@@XZ| ; CDummyPipe::OpenPipe
	EXPORT	|?ClosePipe@CDummyPipe@@UAA?AW4HCD_REQUEST_STATUS@@XZ| ; CDummyPipe::ClosePipe
	EXPORT	|?IssueTransfer@CDummyPipe@@UAA?AW4HCD_REQUEST_STATUS@@EQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z| ; CDummyPipe::IssueTransfer
	EXPORT	|?AbortTransfer@CDummyPipe@@UAA?AW4HCD_REQUEST_STATUS@@Q6AKPAX@ZQAXPBX@Z| ; CDummyPipe::AbortTransfer
	EXPORT	|?IsPipeHalted@CDummyPipe@@UAA?AW4HCD_REQUEST_STATUS@@QAH@Z| ; CDummyPipe::IsPipeHalted
	EXPORT	|?ClearHaltedFlag@CDummyPipe@@UAAXXZ|	; CDummyPipe::ClearHaltedFlag
	EXPORT	|?ChangeMaxPacketSize@CPipeAbs@@UAAXG@Z| ; CPipeAbs::ChangeMaxPacketSize
	EXPORT	|?SetReservedDeviceAddr@CPipe@@UAAHE@Z|	; CPipe::SetReservedDeviceAddr
	EXPORT	|?GetReservedDeviceAddr@CPipe@@UAAEXZ|	; CPipe::GetReservedDeviceAddr
	EXPORT	|?GetCPhysMem@CDummyPipe@@UAAPAVCPhysMem@@XZ| ; CDummyPipe::GetCPhysMem
	EXPORT	|?ScheduleTransfer@CDummyPipe@@EAA?AW4HCD_REQUEST_STATUS@@XZ| ; CDummyPipe::ScheduleTransfer
	EXPORT	|?CheckForDoneTransfers@CDummyPipe@@MAAHXZ| ; CDummyPipe::CheckForDoneTransfers
	EXPORT	|?ProcessEP@CDummyPipe@@MAAHKH@Z|	; CDummyPipe::ProcessEP
	EXPORT	|?AreTransferParametersValid@CDummyPipe@@MBAHPBUSTRANSFER@@@Z| ; CDummyPipe::AreTransferParametersValid
	IMPORT	|??0CPipe@@QAA@QBU_USB_ENDPOINT_DESCRIPTOR@@HHEEEHQAVCMhcd@@@Z| ; CPipe::CPipe
	IMPORT	|??_ECDummyPipe@@UAAPAXI@Z|, WEAK |??_GCDummyPipe@@UAAPAXI@Z| ; CDummyPipe::`vector deleting destructor', CDummyPipe::`scalar deleting destructor'
	IMPORT	|?ResetEndPoint@CPipe@@UAAXXZ|		; CPipe::ResetEndPoint
	IMPORT	|_purecall|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T44163| DCD	|$LN5@CDummyPipe|
	DCD	0x40001a02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7CDummyPipe@@6B@| DCD |??_ECDummyPipe@@UAAPAXI@Z|	; CDummyPipe::`vftable'
	DCD	|?OpenPipe@CDummyPipe@@UAA?AW4HCD_REQUEST_STATUS@@XZ|
	DCD	|?ClosePipe@CDummyPipe@@UAA?AW4HCD_REQUEST_STATUS@@XZ|
	DCD	|?IssueTransfer@CDummyPipe@@UAA?AW4HCD_REQUEST_STATUS@@EQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z|
	DCD	|?AbortTransfer@CDummyPipe@@UAA?AW4HCD_REQUEST_STATUS@@Q6AKPAX@ZQAXPBX@Z|
	DCD	|?IsPipeHalted@CDummyPipe@@UAA?AW4HCD_REQUEST_STATUS@@QAH@Z|
	DCD	|?ClearHaltedFlag@CDummyPipe@@UAAXXZ|
	DCD	|?ResetEndPoint@CPipe@@UAAXXZ|
	DCD	|?ChangeMaxPacketSize@CPipeAbs@@UAAXG@Z|
	DCD	|?SetReservedDeviceAddr@CPipe@@UAAHE@Z|
	DCD	|?GetReservedDeviceAddr@CPipe@@UAAEXZ|
	DCD	|?GetCPhysMem@CDummyPipe@@UAAPAVCPhysMem@@XZ|
	DCD	|?ScheduleTransfer@CDummyPipe@@EAA?AW4HCD_REQUEST_STATUS@@XZ|
	DCD	|?CheckForDoneTransfers@CDummyPipe@@MAAHXZ|
	DCD	|?ProcessEP@CDummyPipe@@MAAHKH@Z|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|?AreTransferParametersValid@CDummyPipe@@MBAHPBUSTRANSFER@@@Z|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CDummyPipe@@QAA@QAVCPhysMem@@@Z| PROC ; CDummyPipe::CDummyPipe

; 82   : {

  00000		 |$LN5@CDummyPipe|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M44160|
  00008	e1a04001	 mov         r4, r1
  0000c	e1a05000	 mov         r5, r0
  00010	e59f104c	 ldr         r1, [pc, #0x4C]
  00014	e3a07000	 mov         r7, #0
  00018	e3a060ff	 mov         r6, #0xFF
  0001c	e3a03001	 mov         r3, #1
  00020	e3a02000	 mov         r2, #0
  00024	e58d7010	 str         r7, [sp, #0x10]
  00028	e58d700c	 str         r7, [sp, #0xC]
  0002c	e58d6008	 str         r6, [sp, #8]
  00030	e58d6004	 str         r6, [sp, #4]
  00034	e58d6000	 str         r6, [sp]
  00038	eb000000	 bl          |??0CPipe@@QAA@QBU_USB_ENDPOINT_DESCRIPTOR@@HHEEEHQAVCMhcd@@@Z|
  0003c	e59f301c	 ldr         r3, [pc, #0x1C]
  00040	e5854064	 str         r4, [r5, #0x64]

; 83   :     ASSERT( m_pCPhysMem!=NULL);
; 84   :     m_bFrameSMask = 0xff;

  00044	e5c5601d	 strb        r6, [r5, #0x1D]
  00048	e5853000	 str         r3, [r5]

; 85   :     m_bFrameCMask = 0;

  0004c	e5c5701e	 strb        r7, [r5, #0x1E]

; 86   : 
; 87   : };

  00050	e1a00005	 mov         r0, r5
  00054	e28dd014	 add         sp, sp, #0x14
  00058	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$LN6@CDummyPipe|
  00060		 |$LN7@CDummyPipe|
  00060	00000000	 DCD         |??_7CDummyPipe@@6B@|
  00064		 |$LN8@CDummyPipe|
  00064	00000000	 DCD         |dummpDesc|
  00068		 |$M44161|

			 ENDP  ; |??0CDummyPipe@@QAA@QAVCPhysMem@@@Z|, CDummyPipe::CDummyPipe

; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\pipeabs.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T44173| DCD	|$LN5@ChangeMaxP|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ChangeMaxPacketSize@CPipeAbs@@UAAXG@Z| PROC ; CPipeAbs::ChangeMaxPacketSize

; 61   :     virtual void ChangeMaxPacketSize( IN const USHORT ) {ASSERT(FALSE);}; // only available for Controller endpoint

  00000		 |$LN5@ChangeMaxP|
  00000		 |$M44170|
  00000	e12fff1e	 bx          lr
  00004		 |$M44171|

			 ENDP  ; |?ChangeMaxPacketSize@CPipeAbs@@UAAXG@Z|, CPipeAbs::ChangeMaxPacketSize

; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\cpipe.h

  00000			 AREA	 |.pdata|, PDATA
|$T44184| DCD	|$LN5@SetReserve|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetReservedDeviceAddr@CPipe@@UAAHE@Z| PROC ; CPipe::SetReservedDeviceAddr

; 99   :     BOOL  SetReservedDeviceAddr(UCHAR bReservedDeviceAddr) { m_bReservedDeviceAddr = bReservedDeviceAddr; return TRUE;};

  00000		 |$LN5@SetReserve|
  00000		 |$M44181|
  00000	e5c0101c	 strb        r1, [r0, #0x1C]
  00004	e3a00001	 mov         r0, #1
  00008	e12fff1e	 bx          lr
  0000c		 |$M44182|

			 ENDP  ; |?SetReservedDeviceAddr@CPipe@@UAAHE@Z|, CPipe::SetReservedDeviceAddr


  00000			 AREA	 |.pdata|, PDATA
|$T44194| DCD	|$LN5@GetReserve|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetReservedDeviceAddr@CPipe@@UAAEXZ| PROC ; CPipe::GetReservedDeviceAddr

; 100  :     UCHAR GetReservedDeviceAddr() { return m_bReservedDeviceAddr;};

  00000		 |$LN5@GetReserve|
  00000		 |$M44191|
  00000	e5d0001c	 ldrb        r0, [r0, #0x1C]
  00004	e12fff1e	 bx          lr
  00008		 |$M44192|

			 ENDP  ; |?GetReservedDeviceAddr@CPipe@@UAAEXZ|, CPipe::GetReservedDeviceAddr

	EXPORT	|??1CDummyPipe@@UAA@XZ|			; CDummyPipe::~CDummyPipe
	IMPORT	|??1CPipe@@UAA@XZ|			; CPipe::~CPipe
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.h

  00000			 AREA	 |.pdata|, PDATA
|$T44202| DCD	|$LN5@CDummyPipe@2|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CDummyPipe@@UAA@XZ| PROC		; CDummyPipe::~CDummyPipe

; 80   :     virtual ~CDummyPipe() {;};

  00000		 |$LN5@CDummyPipe@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44199|
  00004	e1a02000	 mov         r2, r0
  00008	e59f300c	 ldr         r3, [pc, #0xC]
  0000c	e5823000	 str         r3, [r2]
  00010	eb000000	 bl          |??1CPipe@@UAA@XZ|
  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$LN6@CDummyPipe@2|
  0001c		 |$LN7@CDummyPipe@2|
  0001c	00000000	 DCD         |??_7CDummyPipe@@6B@|
  00020		 |$M44200|

			 ENDP  ; |??1CDummyPipe@@UAA@XZ|, CDummyPipe::~CDummyPipe


  00000			 AREA	 |.pdata|, PDATA
|$T44213| DCD	|$LN5@IssueTrans|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IssueTransfer@CDummyPipe@@UAA?AW4HCD_REQUEST_STATUS@@EQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z| PROC ; CDummyPipe::IssueTransfer

; 102  :         { return requestFailed;};

  00000		 |$LN5@IssueTrans|
  00000		 |$M44210|
  00000	e3a00000	 mov         r0, #0
  00004	e12fff1e	 bx          lr
  00008		 |$M44211|

			 ENDP  ; |?IssueTransfer@CDummyPipe@@UAA?AW4HCD_REQUEST_STATUS@@EQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z|, CDummyPipe::IssueTransfer


  00000			 AREA	 |.pdata|, PDATA
|$T44222| DCD	|$LN5@OpenPipe|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OpenPipe@CDummyPipe@@UAA?AW4HCD_REQUEST_STATUS@@XZ| PROC ; CDummyPipe::OpenPipe

; 105  :         { return requestFailed;};

  00000		 |$LN5@OpenPipe|
  00000		 |$M44219|
  00000	e3a00000	 mov         r0, #0
  00004	e12fff1e	 bx          lr
  00008		 |$M44220|

			 ENDP  ; |?OpenPipe@CDummyPipe@@UAA?AW4HCD_REQUEST_STATUS@@XZ|, CDummyPipe::OpenPipe


  00000			 AREA	 |.pdata|, PDATA
|$T44231| DCD	|$LN5@ClosePipe|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ClosePipe@CDummyPipe@@UAA?AW4HCD_REQUEST_STATUS@@XZ| PROC ; CDummyPipe::ClosePipe

; 108  :         { return requestFailed;};

  00000		 |$LN5@ClosePipe|
  00000		 |$M44228|
  00000	e3a00000	 mov         r0, #0
  00004	e12fff1e	 bx          lr
  00008		 |$M44229|

			 ENDP  ; |?ClosePipe@CDummyPipe@@UAA?AW4HCD_REQUEST_STATUS@@XZ|, CDummyPipe::ClosePipe


  00000			 AREA	 |.pdata|, PDATA
|$T44240| DCD	|$LN5@IsPipeHalt|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsPipeHalted@CDummyPipe@@UAA?AW4HCD_REQUEST_STATUS@@QAH@Z| PROC ; CDummyPipe::IsPipeHalted

; 111  :         {   

  00000		 |$LN5@IsPipeHalt|
  00000		 |$M44237|

; 112  :             ASSERT(FALSE);
; 113  :             return requestFailed;

  00000	e3a00000	 mov         r0, #0

; 114  :         };

  00004	e12fff1e	 bx          lr
  00008		 |$M44238|

			 ENDP  ; |?IsPipeHalted@CDummyPipe@@UAA?AW4HCD_REQUEST_STATUS@@QAH@Z|, CDummyPipe::IsPipeHalted


  00000			 AREA	 |.pdata|, PDATA
|$T44247| DCD	|$LN5@ClearHalte|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ClearHaltedFlag@CDummyPipe@@UAAXXZ| PROC ; CDummyPipe::ClearHaltedFlag

; 116  :     virtual void ClearHaltedFlag( void ) {;};    

  00000		 |$LN5@ClearHalte|
  00000		 |$M44244|
  00000	e12fff1e	 bx          lr
  00004		 |$M44245|

			 ENDP  ; |?ClearHaltedFlag@CDummyPipe@@UAAXXZ|, CDummyPipe::ClearHaltedFlag


  00000			 AREA	 |.pdata|, PDATA
|$T44256| DCD	|$LN5@AbortTrans|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AbortTransfer@CDummyPipe@@UAA?AW4HCD_REQUEST_STATUS@@Q6AKPAX@ZQAXPBX@Z| PROC ; CDummyPipe::AbortTransfer

; 122  :         {return requestFailed;};

  00000		 |$LN5@AbortTrans|
  00000		 |$M44253|
  00000	e3a00000	 mov         r0, #0
  00004	e12fff1e	 bx          lr
  00008		 |$M44254|

			 ENDP  ; |?AbortTransfer@CDummyPipe@@UAA?AW4HCD_REQUEST_STATUS@@Q6AKPAX@ZQAXPBX@Z|, CDummyPipe::AbortTransfer


  00000			 AREA	 |.pdata|, PDATA
|$T44266| DCD	|$LN5@GetCPhysMe|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetCPhysMem@CDummyPipe@@UAAPAVCPhysMem@@XZ| PROC ; CDummyPipe::GetCPhysMem

; 127  :     virtual CPhysMem * GetCPhysMem() {return m_pCPhysMem;};

  00000		 |$LN5@GetCPhysMe|
  00000		 |$M44263|
  00000	e5900064	 ldr         r0, [r0, #0x64]
  00004	e12fff1e	 bx          lr
  00008		 |$M44264|

			 ENDP  ; |?GetCPhysMem@CDummyPipe@@UAAPAVCPhysMem@@XZ|, CDummyPipe::GetCPhysMem


  00000			 AREA	 |.pdata|, PDATA
|$T44275| DCD	|$LN5@ScheduleTr|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ScheduleTransfer@CDummyPipe@@EAA?AW4HCD_REQUEST_STATUS@@XZ| PROC ; CDummyPipe::ScheduleTransfer

; 134  :     HCD_REQUEST_STATUS  ScheduleTransfer( void ) { return requestFailed;};

  00000		 |$LN5@ScheduleTr|
  00000		 |$M44272|
  00000	e3a00000	 mov         r0, #0
  00004	e12fff1e	 bx          lr
  00008		 |$M44273|

			 ENDP  ; |?ScheduleTransfer@CDummyPipe@@EAA?AW4HCD_REQUEST_STATUS@@XZ|, CDummyPipe::ScheduleTransfer


  00000			 AREA	 |.pdata|, PDATA
|$T44284| DCD	|$LN5@AreTransfe|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AreTransferParametersValid@CDummyPipe@@MBAHPBUSTRANSFER@@@Z| PROC ; CDummyPipe::AreTransferParametersValid

; 152  :     virtual BOOL    AreTransferParametersValid( const STransfer * /*pTransfer = NULL*/ )  const { return FALSE;};

  00000		 |$LN5@AreTransfe|
  00000		 |$M44281|
  00000	e3a00000	 mov         r0, #0
  00004	e12fff1e	 bx          lr
  00008		 |$M44282|

			 ENDP  ; |?AreTransferParametersValid@CDummyPipe@@MBAHPBUSTRANSFER@@@Z|, CDummyPipe::AreTransferParametersValid


  00000			 AREA	 |.pdata|, PDATA
|$T44293| DCD	|$LN5@CheckForDo|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CheckForDoneTransfers@CDummyPipe@@MAAHXZ| PROC ; CDummyPipe::CheckForDoneTransfers

; 154  :     BOOL    CheckForDoneTransfers( void) { return FALSE; };

  00000		 |$LN5@CheckForDo|
  00000		 |$M44290|
  00000	e3a00000	 mov         r0, #0
  00004	e12fff1e	 bx          lr
  00008		 |$M44291|

			 ENDP  ; |?CheckForDoneTransfers@CDummyPipe@@MAAHXZ|, CDummyPipe::CheckForDoneTransfers


  00000			 AREA	 |.pdata|, PDATA
|$T44302| DCD	|$LN5@ProcessEP|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ProcessEP@CDummyPipe@@MAAHKH@Z| PROC	; CDummyPipe::ProcessEP

; 156  :     {

  00000		 |$LN5@ProcessEP|
  00000		 |$M44299|

; 157  :         UNREFERENCED_PARAMETER(isDMA);
; 158  :         UNREFERENCED_PARAMETER(dwStatus); 
; 159  :         return FALSE; 

  00000	e3a00000	 mov         r0, #0

; 160  :     };

  00004	e12fff1e	 bx          lr
  00008		 |$M44300|

			 ENDP  ; |?ProcessEP@CDummyPipe@@MAAHKH@Z|, CDummyPipe::ProcessEP

	IMPORT	|??3@YAXPAX@Z|				; operator delete

  00000			 AREA	 |.pdata|, PDATA
|$T44316| DCD	|$LN8@scalar|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GCDummyPipe@@UAAPAXI@Z| PROC	; CDummyPipe::`scalar deleting destructor'
  00000		 |$LN8@scalar|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44313|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	e59f301c	 ldr         r3, [pc, #0x1C]
  00010	e5853000	 str         r3, [r5]
  00014	eb000000	 bl          |??1CPipe@@UAA@XZ|
  00018	e3140001	 tst         r4, #1
  0001c	11a00005	 movne       r0, r5
  00020	1b000000	 blne        |??3@YAXPAX@Z|
  00024	e1a00005	 mov         r0, r5
  00028	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$LN9@scalar|
  00030		 |$LN10@scalar|
  00030	00000000	 DCD         |??_7CDummyPipe@@6B@|
  00034		 |$M44314|

			 ENDP  ; |??_GCDummyPipe@@UAAPAXI@Z|, CDummyPipe::`scalar deleting destructor'

	EXPORT	|?DeInit@CBusyPipeList@@QAAXXZ|		; CBusyPipeList::DeInit
	IMPORT	|CloseHandle|
	IMPORT	|TerminateThread|
	IMPORT	|WaitForSingleObject|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T44330| DCD	|$LN11@DeInit|
	DCD	0x40002501
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DeInit@CBusyPipeList@@QAAXXZ| PROC	; CBusyPipeList::DeInit

; 150  : {

  00000		 |$LN11@DeInit|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44327|
  00004	e1a04000	 mov         r4, r0

; 151  :     m_fCheckTransferThreadClosing=TRUE;  
; 152  :     // We just check Update EP
; 153  :     if ( m_hUpdateEPEvent != NULL ) {

  00008	e59430c4	 ldr         r3, [r4, #0xC4]
  0000c	e3a02001	 mov         r2, #1
  00010	e58420b8	 str         r2, [r4, #0xB8]
  00014	e3530000	 cmp         r3, #0
  00018	e3a05000	 mov         r5, #0
  0001c	0a000013	 beq         |$LN4@DeInit|

; 154  :        SetEvent(m_hUpdateEPEvent);

  00020	e3a01003	 mov         r1, #3
  00024	e1a00003	 mov         r0, r3
  00028	eb000000	 bl          EventModify

; 155  :        if ( m_hCheckForDoneTransfersThread ) {

  0002c	e59430c8	 ldr         r3, [r4, #0xC8]
  00030	e3530000	 cmp         r3, #0
  00034	0a00000a	 beq         |$LN3@DeInit|
  00038	e3a02c13	 mov         r2, #0x13, 24

; 156  :            DWORD dwWaitReturn = WaitForSingleObject( m_hCheckForDoneTransfersThread, 5000 );

  0003c	e3821088	 orr         r1, r2, #0x88
  00040	e1a00003	 mov         r0, r3
  00044	eb000000	 bl          WaitForSingleObject
  00048	e3500000	 cmp         r0, #0

; 157  :            if ( dwWaitReturn != WAIT_OBJECT_0 ) {
; 158  :                 DEBUGCHK( 0 ); // check why thread is blocked
; 159  : #pragma prefast(suppress: 258, "Try to recover gracefully from a pathological failure")
; 160  :                 TerminateThread( m_hCheckForDoneTransfersThread, DWORD(-1) );

  0004c	159400c8	 ldrne       r0, [r4, #0xC8]
  00050	13e01000	 mvnne       r1, #0
  00054	1b000000	 blne        TerminateThread

; 161  :            }
; 162  :            CloseHandle( m_hCheckForDoneTransfersThread );

  00058	e59400c8	 ldr         r0, [r4, #0xC8]
  0005c	eb000000	 bl          CloseHandle

; 163  :            m_hCheckForDoneTransfersThread = NULL;

  00060	e58450c8	 str         r5, [r4, #0xC8]
  00064		 |$LN3@DeInit|

; 164  :         }
; 165  :         CloseHandle( m_hUpdateEPEvent);

  00064	e59400c4	 ldr         r0, [r4, #0xC4]
  00068	eb000000	 bl          CloseHandle

; 166  :         m_hUpdateEPEvent = NULL;

  0006c	e58450c4	 str         r5, [r4, #0xC4]
  00070		 |$LN4@DeInit|

; 167  :     }
; 168  : 
; 169  :     if (m_hEP0CheckForDoneTransfersEvent)

  00070	e59430bc	 ldr         r3, [r4, #0xBC]
  00074	e3530000	 cmp         r3, #0
  00078	0a000003	 beq         |$LN1@DeInit|

; 170  :     {
; 171  :         CloseHandle(m_hEP0CheckForDoneTransfersEvent);

  0007c	e1a00003	 mov         r0, r3
  00080	eb000000	 bl          CloseHandle

; 172  :         m_hEP0CheckForDoneTransfersEvent = NULL;            

  00084	e58450bc	 str         r5, [r4, #0xBC]

; 173  :         m_PipeListInfoEP0CheckForDoneTransfersCount = NULL;

  00088	e58450c0	 str         r5, [r4, #0xC0]
  0008c		 |$LN1@DeInit|

; 174  :     }        
; 175  : }

  0008c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$M44328|

			 ENDP  ; |?DeInit@CBusyPipeList@@QAAXXZ|, CBusyPipeList::DeInit

	EXPORT	|?SignalCheckForDoneDMA@CBusyPipeList@@QAAHE@Z| ; CBusyPipeList::SignalCheckForDoneDMA
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T44345| DCD	|$LN8@SignalChec|
	DCD	0x40000e01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SignalCheckForDoneDMA@CBusyPipeList@@QAAHE@Z| PROC ; CBusyPipeList::SignalCheckForDoneDMA

; 193  : {    

  00000		 |$LN8@SignalChec|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44342|

; 194  :     if (m_hDMA2Handles[channel])

  00004	e0803101	 add         r3, r0, r1, lsl #2
  00008	e5933094	 ldr         r3, [r3, #0x94]
  0000c	e3530000	 cmp         r3, #0
  00010	0a000005	 beq         |$LN1@SignalChec|

; 195  :     {        
; 196  :         DEBUGMSG(ZONE_PIPE, (TEXT("Release DMA for channel %d\r\n"), channel));
; 197  :         DEBUGCHK( m_hDMA2Handles[channel] && m_hCheckForDoneTransfersThread );
; 198  :         DEBUGMSG(ZONE_PIPE, (TEXT("CBusyPipeList::SignalCheckForDoneDMA at channel %d\r\n"), channel));
; 199  :         SetEvent( m_hDMA2Handles[channel]);

  00014	e3a01003	 mov         r1, #3
  00018	e1a00003	 mov         r0, r3
  0001c	eb000000	 bl          EventModify

; 200  :         return TRUE;

  00020	e3a00001	 mov         r0, #1

; 203  : }

  00024	e49de004	 ldr         lr, [sp], #4
  00028	e12fff1e	 bx          lr
  0002c		 |$LN1@SignalChec|

; 201  :     }
; 202  :     return FALSE;

  0002c	e3a00000	 mov         r0, #0

; 203  : }

  00030	e49de004	 ldr         lr, [sp], #4
  00034	e12fff1e	 bx          lr
  00038		 |$M44343|

			 ENDP  ; |?SignalCheckForDoneDMA@CBusyPipeList@@QAAHE@Z|, CBusyPipeList::SignalCheckForDoneDMA

	EXPORT	|?SignalCheckForDoneTransfers@CBusyPipeList@@QAAXEE@Z| ; CBusyPipeList::SignalCheckForDoneTransfers
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T44359| DCD	|$LN8@SignalChec@2|
	DCD	0x40000b01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SignalCheckForDoneTransfers@CBusyPipeList@@QAAXEE@Z| PROC ; CBusyPipeList::SignalCheckForDoneTransfers

; 223  : {    

  00000		 |$LN8@SignalChec@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44356|

; 224  :     if (m_hEP2Handles[USB_ENDPOINT(endpoint)][ucIsOut])

  00004	e201300f	 and         r3, r1, #0xF
  00008	e0823083	 add         r3, r2, r3, lsl #1
  0000c	e0803103	 add         r3, r0, r3, lsl #2
  00010	e5933014	 ldr         r3, [r3, #0x14]
  00014	e3530000	 cmp         r3, #0

; 225  :     {       
; 226  :         DEBUGMSG(ZONE_PIPE, (TEXT("CBusyPipeList::SignalCheckForDoneTransfer at ep %d OUT %d\r\n"), endpoint, ucIsOut));
; 227  :         SetEvent( m_hEP2Handles[USB_ENDPOINT(endpoint)][ucIsOut]);

  00018	13a01003	 movne       r1, #3
  0001c	11a00003	 movne       r0, r3
  00020	1b000000	 blne        EventModify

; 228  :     }
; 229  : }

  00024	e49de004	 ldr         lr, [sp], #4
  00028	e12fff1e	 bx          lr
  0002c		 |$M44357|

			 ENDP  ; |?SignalCheckForDoneTransfers@CBusyPipeList@@QAAXEE@Z|, CBusyPipeList::SignalCheckForDoneTransfers

	EXPORT	|?CheckForDoneTransfersThread@CBusyPipeList@@AAAKXZ| ; CBusyPipeList::CheckForDoneTransfersThread
	IMPORT	|WaitForMultipleObjects|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T44430| DCD	|$LN70@CheckForDo@2|
	DCD	0x4000b002
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CheckForDoneTransfersThread@CBusyPipeList@@AAAKXZ| PROC ; CBusyPipeList::CheckForDoneTransfersThread

; 249  : {

  00000		 |$LN70@CheckForDo@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dde29	 sub         sp, sp, #0x29, 28
  00008		 |$M44427|
  00008	e1a04000	 mov         r4, r0

; 250  :     DWORD timeout = INFINITE;
; 251  :     DWORD dwErr = 0;
; 252  :     EVENT_INFO EventInfoObj[HOST_MAX_EP+1+DMA_MAX_CHANNEL];
; 253  :     HANDLE hWaitHandle[HOST_MAX_EP+2+DMA_MAX_CHANNEL];
; 254  :     DWORD hCount;    
; 255  : 
; 256  :     DEBUGMSG( ZONE_TRANSFER && ZONE_VERBOSE, (TEXT("+CPipe::CheckForDoneTransfersThread\n")) );
; 257  :     
; 258  :     PPIPE_LIST_ELEMENT pCurrent = NULL;
; 259  :        
; 260  :     int i = 0;
; 261  :     for (i = 0; i < HOST_MAX_EP+1+DMA_MAX_CHANNEL; i++)

  0000c	e28d30b0	 add         r3, sp, #0xB0
  00010	e3a02028	 mov         r2, #0x28
  00014	e3a00000	 mov         r0, #0
  00018	e3a010ff	 mov         r1, #0xFF
  0001c		 |$LL28@CheckForDo@2|

; 262  :     {
; 263  :         EventInfoObj[i].pPipe = NULL;

  0001c	e5830004	 str         r0, [r3, #4]

; 264  :         EventInfoObj[i].IsDMA = FALSE;

  00020	e5830000	 str         r0, [r3]

; 265  :         EventInfoObj[i].ucReservedDeviceAddr = 0xff;

  00024	e5c31008	 strb        r1, [r3, #8]

; 266  :         EventInfoObj[i].ucDeviceEndPoint = 0xff;

  00028	e5c31009	 strb        r1, [r3, #9]
  0002c	e283300c	 add         r3, r3, #0xC
  00030	e2522001	 subs        r2, r2, #1
  00034	1afffff8	 bne         |$LL28@CheckForDo@2|

; 267  :     }    
; 268  :     
; 269  :     // First add the EP Update Event into the hWaitHandle first.
; 270  :     hWaitHandle[0] = m_hUpdateEPEvent;

  00038	e59430c4	 ldr         r3, [r4, #0xC4]

; 271  :     
; 272  :     hCount = 1;
; 273  : 
; 274  :     while ( !m_fCheckTransferThreadClosing ) {

  0003c	e59420b8	 ldr         r2, [r4, #0xB8]
  00040	e3a09001	 mov         r9, #1
  00044	e58d300c	 str         r3, [sp, #0xC]
  00048	e3520000	 cmp         r2, #0
  0004c	1a00007e	 bne         |$LN64@CheckForDo@2|
  00050	e28d50b0	 add         r5, sp, #0xB0
  00054	e28d80b0	 add         r8, sp, #0xB0
  00058		 |$LL25@CheckForDo@2|

; 275  :         UCHAR signal_evt;
; 276  :         CPipe * pSignalPipe;
; 277  :         BOOL  signal_isDMA;        
; 278  :         UCHAR signal_ep;
; 279  : 
; 280  :         // Wait for any of the endpoint generate interrupt.        
; 281  :         dwErr = WaitForMultipleObjects(hCount, hWaitHandle, FALSE, timeout);        

  00058	e3e03000	 mvn         r3, #0
  0005c	e3a02000	 mov         r2, #0
  00060	e28d100c	 add         r1, sp, #0xC
  00064	e1a00009	 mov         r0, r9
  00068	eb000000	 bl          WaitForMultipleObjects

; 282  : 
; 283  :         // Receive either timeout or event signal
; 284  :         if (( m_fCheckTransferThreadClosing ) || (dwErr == WAIT_FAILED))

  0006c	e59430b8	 ldr         r3, [r4, #0xB8]
  00070	e3530000	 cmp         r3, #0
  00074	1a000074	 bne         |$LN64@CheckForDo@2|
  00078	e3700001	 cmn         r0, #1
  0007c	0a000072	 beq         |$LN64@CheckForDo@2|

; 285  :         {
; 286  :             DEBUGMSG(ZONE_ERROR, (TEXT("WaitForMultipleObjects in BusyPipe failed with err %d\r\n"),
; 287  :                 GetLastError()));
; 288  :             break;
; 289  :         }
; 290  : 
; 291  :         if (dwErr == WAIT_OBJECT_0)

  00080	e3500000	 cmp         r0, #0
  00084	1a00004c	 bne         |$LN21@CheckForDo@2|

; 292  :         {                          
; 293  :             DWORD dwCurEPSetList = 0;
; 294  :             pCurrent = m_pBusyPipeList;                        

  00088	e59430cc	 ldr         r3, [r4, #0xCC]
  0008c	e3a02000	 mov         r2, #0
  00090	e58d2000	 str         r2, [sp]

; 295  :             hCount = 1;

  00094	e1b06003	 movs        r6, r3
  00098	e3a09001	 mov         r9, #1

; 296  :             while (pCurrent != NULL)

  0009c	0a000067	 beq         |$LN59@CheckForDo@2|
  000a0	e28d50bc	 add         r5, sp, #0xBC
  000a4	e28d70bc	 add         r7, sp, #0xBC
  000a8	e28d8010	 add         r8, sp, #0x10
  000ac		 |$LL20@CheckForDo@2|

; 297  :             {
; 298  :                 USB_ENDPOINT_DESCRIPTOR endptDesc = pCurrent->pPipe->GetEndptDescriptor();            

  000ac	e596a000	 ldr         r10, [r6]
  000b0	e28d0004	 add         r0, sp, #4
  000b4	e3a02007	 mov         r2, #7
  000b8	e28a1034	 add         r1, r10, #0x34
  000bc	eb000000	 bl          memcpy

; 299  :                 UCHAR endpoint = USB_ENDPOINT(endptDesc.bEndpointAddress);

  000c0	e5ddb006	 ldrb        r11, [sp, #6]
  000c4	e31b000f	 tst         r11, #0xF

; 300  :                 // Re-assign the handle onto the hWaitHandle
; 301  :                 // hWaitHandle[0] is always there, so, we don't need to 
; 302  :                 // worry about that.
; 303  :                 if (endpoint == 0)

  000c8	1a000014	 bne         |$LN18@CheckForDo@2|

; 304  :                 {                   
; 305  :                     DWORD EPSet = dwCurEPSetList & 1;                    
; 306  :                     if ((m_hEP0CheckForDoneTransfersEvent) && (EPSet == 0))

  000cc	e59430bc	 ldr         r3, [r4, #0xBC]
  000d0	e3530000	 cmp         r3, #0
  000d4	0a000034	 beq         |$LN10@CheckForDo@2|
  000d8	e59da000	 ldr         r10, [sp]
  000dc	e31a0001	 tst         r10, #1
  000e0	1a000031	 bne         |$LN10@CheckForDo@2|

; 307  :                     {
; 308  :                         hWaitHandle[hCount] = m_hEP0CheckForDoneTransfersEvent;

  000e4	e4883004	 str         r3, [r8], #4

; 309  :                         EventInfoObj[hCount].pPipe = NULL;
; 310  :                         EventInfoObj[hCount].IsDMA = FALSE;
; 311  :                         EventInfoObj[hCount].ucReservedDeviceAddr = pCurrent->pPipe->GetReservedDeviceAddr();

  000e8	e5960000	 ldr         r0, [r6]
  000ec	e3a02000	 mov         r2, #0
  000f0	e5852004	 str         r2, [r5, #4]
  000f4	e5903000	 ldr         r3, [r0]
  000f8	e487200c	 str         r2, [r7], #0xC
  000fc	e5933028	 ldr         r3, [r3, #0x28]
  00100	e1a0e00f	 mov         lr, pc
  00104	e12fff13	 bx          r3

; 312  :                         EventInfoObj[hCount].ucDeviceEndPoint = endptDesc.bEndpointAddress;
; 313  :                         m_hEP2Handles[0][DIR_IN] = m_hEP2Handles[0][DIR_OUT] = m_hEP0CheckForDoneTransfersEvent;

  00108	e59430bc	 ldr         r3, [r4, #0xBC]

; 314  :                         dwCurEPSetList |= 1;
; 315  :                         hCount++;

  0010c	e38aa001	 orr         r10, r10, #1
  00110	e58da000	 str         r10, [sp]
  00114	e5843018	 str         r3, [r4, #0x18]
  00118	e5843014	 str         r3, [r4, #0x14]

; 316  :                     }
; 317  :                     else if (EPSet != 0)
; 318  :                         DEBUGMSG(1, (TEXT("EP 0 has been setup\r\n")));
; 319  :                     else
; 320  :                         DEBUGMSG(ZONE_WARNING, (TEXT("Warning!!! EndPoint 0 => no handle\r\n")));
; 321  :                                                 
; 322  :                 }
; 323  :                 else // Non-endpoint 0

  0011c	ea00001e	 b           |$LN65@CheckForDo@2|
  00120		 |$LN18@CheckForDo@2|

; 324  :                 {
; 325  :                     // For the rest of the non-control pipe, just
; 326  :                     // register the handle associated with the pipe.
; 327  :                     if (!pCurrent->pPipe->GetEPTransferEvent())

  00120	e59a305c	 ldr         r3, [r10, #0x5C]
  00124	e3530000	 cmp         r3, #0
  00128	0a00000d	 beq         |$LN11@CheckForDo@2|

; 328  :                         DEBUGMSG(1, (TEXT("ERROR!!! No Transfer Event for EP 0x%x\r\n"), endpoint));
; 329  :                     else
; 330  :                     {
; 331  :                         hWaitHandle[hCount] = pCurrent->pPipe->GetEPTransferEvent();

  0012c	e4883004	 str         r3, [r8], #4

; 332  :                         EventInfoObj[hCount].pPipe = pCurrent->pPipe;

  00130	e5962000	 ldr         r2, [r6]

; 333  :                         EventInfoObj[hCount].IsDMA = FALSE;
; 334  :                         EventInfoObj[hCount].ucReservedDeviceAddr = pCurrent->pPipe->GetReservedDeviceAddr();

  00134	e3a03000	 mov         r3, #0
  00138	e487300c	 str         r3, [r7], #0xC
  0013c	e5923000	 ldr         r3, [r2]
  00140	e1a00002	 mov         r0, r2
  00144	e5852004	 str         r2, [r5, #4]
  00148	e5933028	 ldr         r3, [r3, #0x28]
  0014c	e1a0e00f	 mov         lr, pc
  00150	e12fff13	 bx          r3
  00154	e5c50008	 strb        r0, [r5, #8]

; 335  :                         EventInfoObj[hCount].ucDeviceEndPoint = endptDesc.bEndpointAddress;

  00158	e5c5b009	 strb        r11, [r5, #9]

; 336  :                         hCount++;

  0015c	e285500c	 add         r5, r5, #0xC
  00160	e2899001	 add         r9, r9, #1
  00164		 |$LN11@CheckForDo@2|

; 337  :                     }
; 338  : 
; 339  :                     // Finally do the DMA event
; 340  :                     if (pCurrent->pPipe->GetDMATransferEvent())

  00164	e5963000	 ldr         r3, [r6]
  00168	e5933060	 ldr         r3, [r3, #0x60]
  0016c	e3530000	 cmp         r3, #0
  00170	0a00000d	 beq         |$LN10@CheckForDo@2|

; 341  :                     {
; 342  :                         hWaitHandle[hCount] = pCurrent->pPipe->GetDMATransferEvent();

  00174	e4883004	 str         r3, [r8], #4

; 343  :                         EventInfoObj[hCount].pPipe = pCurrent->pPipe;

  00178	e5962000	 ldr         r2, [r6]

; 344  :                         EventInfoObj[hCount].IsDMA = TRUE;
; 345  :                         EventInfoObj[hCount].ucReservedDeviceAddr = pCurrent->pPipe->GetReservedDeviceAddr();

  0017c	e3a03001	 mov         r3, #1
  00180	e487300c	 str         r3, [r7], #0xC
  00184	e5923000	 ldr         r3, [r2]
  00188	e1a00002	 mov         r0, r2
  0018c	e5852004	 str         r2, [r5, #4]
  00190	e5933028	 ldr         r3, [r3, #0x28]
  00194	e1a0e00f	 mov         lr, pc
  00198	e12fff13	 bx          r3
  0019c		 |$LN65@CheckForDo@2|
  0019c	e5c50008	 strb        r0, [r5, #8]

; 346  :                         EventInfoObj[hCount].ucDeviceEndPoint = endptDesc.bEndpointAddress;

  001a0	e5c5b009	 strb        r11, [r5, #9]

; 347  :                         hCount++;

  001a4	e285500c	 add         r5, r5, #0xC
  001a8	e2899001	 add         r9, r9, #1
  001ac		 |$LN10@CheckForDo@2|

; 348  :                     }
; 349  :                 }              
; 350  : 
; 351  :                 pCurrent = pCurrent->pNext;

  001ac	e5963004	 ldr         r3, [r6, #4]
  001b0	e1b06003	 movs        r6, r3
  001b4	1affffbc	 bne         |$LL20@CheckForDo@2|

; 352  :             }            
; 353  :             DEBUGMSG(ZONE_PIPE, (TEXT("CBusyPipeL ist::Total no of event = %d\r\n"), hCount));
; 354  :             continue;

  001b8	ea00001e	 b           |$LN66@CheckForDo@2|
  001bc		 |$LN21@CheckForDo@2|

; 355  :         }
; 356  : 
; 357  :         signal_evt = (UCHAR)(dwErr - WAIT_OBJECT_0);

  001bc	e20030ff	 and         r3, r0, #0xFF

; 358  :         // Find out which pipe corresponding to
; 359  :         pSignalPipe = EventInfoObj[signal_evt].pPipe;

  001c0	e0832083	 add         r2, r3, r3, lsl #1
  001c4	e0853102	 add         r3, r5, r2, lsl #2

; 360  :         // Is this DMA signal?
; 361  :         signal_isDMA = EventInfoObj[signal_evt].IsDMA;
; 362  : 
; 363  :         signal_ep = USB_ENDPOINT(EventInfoObj[signal_evt].ucDeviceEndPoint);

  001c8	e5d36009	 ldrb        r6, [r3, #9]

; 364  : 
; 365  : 
; 366  :         DEBUGMSG(ZONE_TRANSFER, (TEXT("CBusyPipeList get signal evt %d EP 0x%x signal, DMA (%d)\r\n"), 
; 367  :             signal_evt, ((signal_ep ==0)? 0:(pSignalPipe->GetEndptDescriptor()).bEndpointAddress), 
; 368  :             signal_isDMA));
; 369  :        
; 370  :         Lock();

  001cc	e5937004	 ldr         r7, [r3, #4]
  001d0	e7988102	 ldr         r8, [r8, +r2, lsl #2]
  001d4	e1a00004	 mov         r0, r4
  001d8	eb000000	 bl          EnterCriticalSection

; 371  :         pCurrent = m_pBusyPipeList;

  001dc	e59430cc	 ldr         r3, [r4, #0xCC]
  001e0	ea000033	 b           |$LN67@CheckForDo@2|
  001e4		 |$LL9@CheckForDo@2|

; 374  : #ifdef DEBUG
; 375  :             USB_ENDPOINT_DESCRIPTOR endptDesc = pCurrent->pPipe->GetEndptDescriptor();
; 376  : #endif
; 377  :             BOOL match = FALSE;
; 378  :             // Find out which actual data is being transferred.
; 379  :             // We need to check the endpoint and also the status.
; 380  : 
; 381  :             // Need to find out which actual pipe is sending 
; 382  :             // as there are now more than 1 pipes in same endpoint
; 383  :             if (!signal_isDMA)

  001e4	e3580000	 cmp         r8, #0
  001e8	1a000028	 bne         |$LN7@CheckForDo@2|

; 384  :             {
; 385  :                 if (signal_ep != 0)

  001ec	e316000f	 tst         r6, #0xF
  001f0	0a000019	 beq         |$LN6@CheckForDo@2|

; 386  :                     match = (pCurrent->pPipe == pSignalPipe);

  001f4	e5953000	 ldr         r3, [r5]
  001f8	e1530007	 cmp         r3, r7
  001fc	1a00002b	 bne         |$LN60@CheckForDo@2|
  00200		 |$LN54@CheckForDo@2|

; 399  :             {
; 400  :                 // We don't need to loop through, just check                
; 401  :                 DEBUGMSG(ZONE_TRANSFER, (TEXT("CBusyPipeThread=>ProcessEP %d dir %d\r\n"), 
; 402  :                     USB_ENDPOINT(endptDesc.bEndpointAddress), USB_ENDPOINT_DIRECTION_OUT(endptDesc.bEndpointAddress)));
; 403  :                 pCurrent->pPipe->ProcessEP(STATUS_PROCESS_INTR, signal_isDMA);

  00200	e5950000	 ldr         r0, [r5]
  00204	e1a02008	 mov         r2, r8
  00208	e3a01000	 mov         r1, #0
  0020c	e5903000	 ldr         r3, [r0]
  00210	e5933038	 ldr         r3, [r3, #0x38]
  00214	e1a0e00f	 mov         lr, pc
  00218	e12fff13	 bx          r3

; 404  :                 pCurrent->pPipe->CheckForDoneTransfers();

  0021c	e5950000	 ldr         r0, [r5]
  00220	e5903000	 ldr         r3, [r0]
  00224	e5933034	 ldr         r3, [r3, #0x34]
  00228	e1a0e00f	 mov         lr, pc
  0022c	e12fff13	 bx          r3
  00230		 |$LN8@CheckForDo@2|

; 408  :         }        
; 409  :         Unlock();

  00230	e1a00004	 mov         r0, r4
  00234	eb000000	 bl          LeaveCriticalSection
  00238		 |$LN66@CheckForDo@2|
  00238	e28d80b0	 add         r8, sp, #0xB0
  0023c	e28d50b0	 add         r5, sp, #0xB0
  00240		 |$LN59@CheckForDo@2|
  00240	e59430b8	 ldr         r3, [r4, #0xB8]
  00244	e3530000	 cmp         r3, #0
  00248	0affff82	 beq         |$LL25@CheckForDo@2|
  0024c		 |$LN64@CheckForDo@2|

; 410  :     }
; 411  :     DEBUGMSG( ZONE_TRANSFER && ZONE_VERBOSE, (TEXT("-CPipe::CheckForDoneTransfersThread\n")) );
; 412  :     return 0;

  0024c	e3a00000	 mov         r0, #0

; 413  : }

  00250	e28dde29	 add         sp, sp, #0x29, 28
  00254	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00258	e12fff1e	 bx          lr
  0025c		 |$LN6@CheckForDo@2|

; 387  :                 else
; 388  :                     match = pCurrent->pPipe->m_pCMhcd->IsDeviceLockEP0(pCurrent->pPipe->GetReservedDeviceAddr());

  0025c	e5950000	 ldr         r0, [r5]
  00260	e5903000	 ldr         r3, [r0]
  00264	e5933028	 ldr         r3, [r3, #0x28]
  00268	e1a0e00f	 mov         lr, pc
  0026c	e12fff13	 bx          r3
  00270	e5953000	 ldr         r3, [r5]
  00274	e1a01000	 mov         r1, r0
  00278	e593000c	 ldr         r0, [r3, #0xC]
  0027c	e5903000	 ldr         r3, [r0]
  00280	e593307c	 ldr         r3, [r3, #0x7C]
  00284	e1a0e00f	 mov         lr, pc
  00288	e12fff13	 bx          r3

; 389  :             }
; 390  :             else

  0028c	ea000005	 b           |$LN34@CheckForDo@2|
  00290		 |$LN7@CheckForDo@2|

; 391  :             {
; 392  :                 if (signal_ep == 0)

  00290	e316000f	 tst         r6, #0xF
  00294	0a000005	 beq         |$LN60@CheckForDo@2|

; 393  :                     DEBUGMSG(1, (TEXT("Wrong!! EP0 cannot have DMA interrupt!!\r\n")));
; 394  :                 else
; 395  :                     match = (pCurrent->pPipe == pSignalPipe);

  00298	e5953000	 ldr         r3, [r5]
  0029c	e1530007	 cmp         r3, r7
  002a0	0affffd6	 beq         |$LN54@CheckForDo@2|
  002a4	e3a00000	 mov         r0, #0
  002a8		 |$LN34@CheckForDo@2|

; 396  :             }
; 397  : 
; 398  :             if (match)

  002a8	e3500000	 cmp         r0, #0
  002ac	1affffd3	 bne         |$LN54@CheckForDo@2|
  002b0		 |$LN60@CheckForDo@2|

; 405  :                 break;
; 406  :             }         
; 407  :             pCurrent = pCurrent->pNext;

  002b0	e5953004	 ldr         r3, [r5, #4]
  002b4		 |$LN67@CheckForDo@2|
  002b4	e1b05003	 movs        r5, r3
  002b8	1affffc9	 bne         |$LL9@CheckForDo@2|

; 372  :              
; 373  :         while ( pCurrent != NULL ) {            

  002bc	eaffffdb	 b           |$LN8@CheckForDo@2|
  002c0		 |$M44428|

			 ENDP  ; |?CheckForDoneTransfersThread@CBusyPipeList@@AAAKXZ|, CBusyPipeList::CheckForDoneTransfersThread

	EXPORT	|?AddToBusyPipeList@CBusyPipeList@@QAAHQAVCPipe@@H@Z| ; CBusyPipeList::AddToBusyPipeList
	IMPORT	|CreateEventW|
	IMPORT	|??2@YAPAXI@Z|				; operator new
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T44475| DCD	|$LN44@AddToBusyP|
	DCD	0x40006a02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AddToBusyPipeList@CBusyPipeList@@QAAHQAVCPipe@@H@Z| PROC ; CBusyPipeList::AddToBusyPipeList

; 433  : {

  00000		 |$LN44@AddToBusyP|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M44472|
  00008	e1a05002	 mov         r5, r2
  0000c	e1a06001	 mov         r6, r1
  00010	e1a04000	 mov         r4, r0

; 434  :     DEBUGMSG( ZONE_PIPE, (TEXT("+CPipe::AddToBusyPipeList - new pipe(%s) 0x%x, pri %d\n"), pPipe->GetPipeType(), pPipe, fHighPriority ));    
; 435  :     PREFAST_DEBUGCHK( pPipe != NULL );
; 436  :     BOOL fSuccess = FALSE;
; 437  : 
; 438  :     // make sure there nothing on the pipe already (it only gets officially added after this function succeeds).
; 439  :     Lock();

  00014	e3a08000	 mov         r8, #0
  00018	eb000000	 bl          EnterCriticalSection

; 440  : #ifdef DEBUG
; 441  : {
; 442  :     // make sure this pipe isn't already in the list. That should never happen.
; 443  :     // also check that our m_debug_numItemsOnBusyPipeList is correct
; 444  :     PPIPE_LIST_ELEMENT pBusy = m_pBusyPipeList;
; 445  :     int count = 0;
; 446  :     while ( pBusy != NULL ) {
; 447  :         DEBUGCHK( pBusy->pPipe != NULL &&
; 448  :                   pBusy->pPipe != pPipe );
; 449  :         pBusy = pBusy->pNext;
; 450  :         count++;
; 451  :     }
; 452  :     DEBUGCHK( m_debug_numItemsOnBusyPipeList == count );
; 453  : }
; 454  : #endif // DEBUG
; 455  :     
; 456  :     PPIPE_LIST_ELEMENT pNewBusyElement = new PIPE_LIST_ELEMENT;

  0001c	e3a00008	 mov         r0, #8
  00020	eb000000	 bl          |??2@YAPAXI@Z|
  00024	e3500000	 cmp         r0, #0
  00028	e3a09000	 mov         r9, #0

; 457  :     if ( pNewBusyElement != NULL ) {

  0002c	0a000009	 beq         |$LN21@AddToBusyP|

; 458  :         pNewBusyElement->pPipe = pPipe;

  00030	e5806000	 str         r6, [r0]

; 459  :         if ( fHighPriority || m_pBusyPipeList == NULL ) {

  00034	e3550000	 cmp         r5, #0
  00038	1a000002	 bne         |$LN19@AddToBusyP|
  0003c	e59430cc	 ldr         r3, [r4, #0xCC]
  00040	e1b02003	 movs        r2, r3
  00044	1a00002f	 bne         |$LN41@AddToBusyP|
  00048		 |$LN19@AddToBusyP|

; 460  :             // add pipe to start of list
; 461  :             pNewBusyElement->pNext = m_pBusyPipeList;

  00048	e59430cc	 ldr         r3, [r4, #0xCC]
  0004c	e5803004	 str         r3, [r0, #4]

; 462  :             m_pBusyPipeList = pNewBusyElement;

  00050	e58400cc	 str         r0, [r4, #0xCC]
  00054		 |$LN18@AddToBusyP|

; 471  :         }
; 472  :         fSuccess = TRUE;

  00054	e3a08001	 mov         r8, #1
  00058		 |$LN21@AddToBusyP|

; 473  :     #ifdef DEBUG
; 474  :         m_debug_numItemsOnBusyPipeList++;
; 475  :     #endif // DEBUG
; 476  :     }
; 477  : 
; 478  :     // Finally check if endpoint 0, register it.
; 479  :     USB_ENDPOINT_DESCRIPTOR endptDesc = pPipe->GetEndptDescriptor();

  00058	e28d0000	 add         r0, sp, #0
  0005c	e2861034	 add         r1, r6, #0x34
  00060	e3a02007	 mov         r2, #7
  00064	eb000000	 bl          memcpy

; 480  :     UCHAR endpoint = USB_ENDPOINT(endptDesc.bEndpointAddress);

  00068	e5dd3002	 ldrb        r3, [sp, #2]
  0006c	e313000f	 tst         r3, #0xF

; 481  :         
; 482  :     if (endpoint == 0)

  00070	1a000043	 bne         |$LN1@AddToBusyP|

; 483  :     {
; 484  : 
; 485  :         pPipe->SetMappedEndPoint(0);

  00074	e5c69058	 strb        r9, [r6, #0x58]

; 486  : 
; 487  :         DEBUGMSG(ZONE_PIPE|ZONE_DEBUG, (TEXT("AddToBusyPipeList with EP %d, devaddr %d\r\n"), endpoint, pPipe->GetReservedDeviceAddr()));
; 488  :             
; 489  :         if (m_hEP0CheckForDoneTransfersEvent)

  00078	e59430bc	 ldr         r3, [r4, #0xBC]
  0007c	e3530000	 cmp         r3, #0
  00080	0a000028	 beq         |$LN14@AddToBusyP|

; 490  :         {
; 491  :             if (m_PipeListInfoEP0CheckForDoneTransfersCount == NULL)

  00084	e59430c0	 ldr         r3, [r4, #0xC0]
  00088	e1b05003	 movs        r5, r3
  0008c	0a00003c	 beq         |$LN1@AddToBusyP|

; 492  :                 DEBUGMSG(ZONE_ERROR, (TEXT("CBusyPipeList::ERROR - EP Handle has been created but count is not\r\n")));
; 493  :             else
; 494  :             {
; 495  :                 PPIPE_LIST_INFO pLast = NULL;

  00090	e3a07000	 mov         r7, #0

; 496  :                 PPIPE_LIST_INFO pTemp = m_PipeListInfoEP0CheckForDoneTransfersCount;                

  00094		 |$LL11@AddToBusyP|

; 497  :                 while (pTemp != NULL)
; 498  :                 {
; 499  :                     if (pTemp->deviceAddr == pPipe->GetReservedDeviceAddr())

  00094	e5963000	 ldr         r3, [r6]
  00098	e1a00006	 mov         r0, r6
  0009c	e5933028	 ldr         r3, [r3, #0x28]
  000a0	e1a0e00f	 mov         lr, pc
  000a4	e12fff13	 bx          r3
  000a8	e5d53000	 ldrb        r3, [r5]
  000ac	e1530000	 cmp         r3, r0
  000b0	0a000003	 beq         |$LN36@AddToBusyP|

; 500  :                     {
; 501  :                         DEBUGMSG(1, (TEXT("Device EP %d has been added\r\n"), endpoint));
; 502  :                         break;
; 503  :                     }
; 504  :                     pLast = pTemp;
; 505  :                     pTemp = pTemp->pNext;

  000b4	e5953004	 ldr         r3, [r5, #4]
  000b8	e1a07005	 mov         r7, r5
  000bc	e1b05003	 movs        r5, r3
  000c0	1afffff3	 bne         |$LL11@AddToBusyP|
  000c4		 |$LN36@AddToBusyP|

; 506  :                 }
; 507  : 
; 508  :                 if (pTemp == NULL)

  000c4	e3550000	 cmp         r5, #0
  000c8	1a00002d	 bne         |$LN1@AddToBusyP|

; 509  :                 {
; 510  :                     pTemp = new PIPE_LIST_INFO;

  000cc	e3a00008	 mov         r0, #8
  000d0	eb000000	 bl          |??2@YAPAXI@Z|

; 511  :                     pTemp->deviceAddr = pPipe->GetReservedDeviceAddr();

  000d4	e5963000	 ldr         r3, [r6]
  000d8	e1a05000	 mov         r5, r0
  000dc	e1a00006	 mov         r0, r6
  000e0	e5933028	 ldr         r3, [r3, #0x28]
  000e4	e1a0e00f	 mov         lr, pc
  000e8	e12fff13	 bx          r3
  000ec	e5c50000	 strb        r0, [r5]

; 512  :                     pTemp->pNext = NULL;

  000f0	e5859004	 str         r9, [r5, #4]

; 513  :                     if (pLast == NULL) // Head should not happen here, anyway.

  000f4	e3570000	 cmp         r7, #0
  000f8	1a000008	 bne         |$LN7@AddToBusyP|

; 514  :                         m_PipeListInfoEP0CheckForDoneTransfersCount = pTemp;

  000fc	e58450c0	 str         r5, [r4, #0xC0]

; 515  :                     else

  00100	ea00001f	 b           |$LN1@AddToBusyP|
  00104		 |$LL17@AddToBusyP|

; 463  :         } else {
; 464  :             // add pipe to end of list
; 465  :             PPIPE_LIST_ELEMENT pLastElement = m_pBusyPipeList;
; 466  :             while ( pLastElement->pNext != NULL ) {
; 467  :                 pLastElement = pLastElement->pNext;

  00104	e5922004	 ldr         r2, [r2, #4]
  00108		 |$LN41@AddToBusyP|
  00108	e5923004	 ldr         r3, [r2, #4]
  0010c	e3530000	 cmp         r3, #0
  00110	1afffffb	 bne         |$LL17@AddToBusyP|

; 468  :             }
; 469  :             pNewBusyElement->pNext = NULL;

  00114	e5809004	 str         r9, [r0, #4]

; 470  :             pLastElement->pNext = pNewBusyElement;

  00118	e5820004	 str         r0, [r2, #4]
  0011c	eaffffcc	 b           |$LN18@AddToBusyP|
  00120		 |$LN7@AddToBusyP|

; 516  :                         pLast->pNext = pTemp;

  00120	e5875004	 str         r5, [r7, #4]

; 517  :                 }
; 518  :             }
; 519  :         }
; 520  :         else // if m_hEP0CheckForDoneTransfersEvent is not created yet

  00124	ea000016	 b           |$LN1@AddToBusyP|
  00128		 |$LN14@AddToBusyP|

; 521  :         {
; 522  :             m_hEP0CheckForDoneTransfersEvent = CreateEvent( NULL, FALSE, FALSE, NULL );  

  00128	e3a03000	 mov         r3, #0
  0012c	e3a02000	 mov         r2, #0
  00130	e3a01000	 mov         r1, #0
  00134	e3a00000	 mov         r0, #0
  00138	eb000000	 bl          CreateEventW
  0013c	e3500000	 cmp         r0, #0
  00140	e58400bc	 str         r0, [r4, #0xBC]

; 523  :             if (m_hEP0CheckForDoneTransfersEvent == NULL)

  00144	0a00000e	 beq         |$LN1@AddToBusyP|

; 524  :                 DEBUGMSG(ZONE_ERROR, (TEXT("CBusyPipeList- CreateEvent failure!!!\r\n")));
; 525  :             else
; 526  :             {
; 527  :                 if (m_PipeListInfoEP0CheckForDoneTransfersCount != NULL)

  00148	e59430c0	 ldr         r3, [r4, #0xC0]
  0014c	e3530000	 cmp         r3, #0
  00150	1a00000b	 bne         |$LN1@AddToBusyP|

; 528  :                     DEBUGMSG(ZONE_ERROR, (TEXT("CBusyPipeList EP %d , index has orphan count\r\n"), 
; 529  :                         endpoint));
; 530  :                 else
; 531  :                 {
; 532  :                     m_PipeListInfoEP0CheckForDoneTransfersCount = new PIPE_LIST_INFO;

  00154	e3a00008	 mov         r0, #8
  00158	eb000000	 bl          |??2@YAPAXI@Z|
  0015c	e58400c0	 str         r0, [r4, #0xC0]

; 533  :                     m_PipeListInfoEP0CheckForDoneTransfersCount->deviceAddr = pPipe->GetReservedDeviceAddr();

  00160	e5963000	 ldr         r3, [r6]
  00164	e1a00006	 mov         r0, r6
  00168	e5933028	 ldr         r3, [r3, #0x28]
  0016c	e1a0e00f	 mov         lr, pc
  00170	e12fff13	 bx          r3
  00174	e59430c0	 ldr         r3, [r4, #0xC0]
  00178	e5c30000	 strb        r0, [r3]

; 534  :                     m_PipeListInfoEP0CheckForDoneTransfersCount->pNext = NULL;

  0017c	e59430c0	 ldr         r3, [r4, #0xC0]
  00180	e5839004	 str         r9, [r3, #4]
  00184		 |$LN1@AddToBusyP|

; 535  :                 }
; 536  :             }
; 537  :         } // end the else case.
; 538  :         
; 539  : 
; 540  : #ifdef DEBUG
; 541  :         int count = 0;
; 542  :         PPIPE_LIST_INFO pList = m_PipeListInfoEP0CheckForDoneTransfersCount;
; 543  :         while (pList != NULL)
; 544  :         {
; 545  :             count++;
; 546  :             pList = pList->pNext;
; 547  :         }
; 548  : 
; 549  :         DEBUGMSG(ZONE_PIPE|ZONE_DEBUG, (TEXT("AddBusyPipeList leaving EP %d, count %d\r\n"),
; 550  :             endpoint, count));
; 551  : #endif
; 552  :     }  // if (endpoint == 0)
; 553  :     SetEvent(m_hUpdateEPEvent); 

  00184	e59400c4	 ldr         r0, [r4, #0xC4]
  00188	e3a01003	 mov         r1, #3
  0018c	eb000000	 bl          EventModify

; 554  :     
; 555  :     Unlock();

  00190	e1a00004	 mov         r0, r4
  00194	eb000000	 bl          LeaveCriticalSection

; 556  :     DEBUGMSG( ZONE_PIPE, (TEXT("-CPipe::AddToBusyPipeList - new pipe(%s) 0x%x, pri %d, returning BOOL %d\n"), pPipe->GetPipeType(), pPipe, fHighPriority, fSuccess) );    
; 557  :     return fSuccess;
; 558  : }

  00198	e1a00008	 mov         r0, r8
  0019c	e28dd008	 add         sp, sp, #8
  001a0	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  001a4	e12fff1e	 bx          lr
  001a8		 |$M44473|

			 ENDP  ; |?AddToBusyPipeList@CBusyPipeList@@QAAHQAVCPipe@@H@Z|, CBusyPipeList::AddToBusyPipeList

	EXPORT	|?SignalDisconnectComplete@CBusyPipeList@@QAAHPAX@Z| ; CBusyPipeList::SignalDisconnectComplete
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T44490| DCD	|$LN8@SignalDisc|
	DCD	0x40001901
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SignalDisconnectComplete@CBusyPipeList@@QAAHPAX@Z| PROC ; CBusyPipeList::SignalDisconnectComplete

; 568  : {

  00000		 |$LN8@SignalDisc|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44487|
  00004	e1a02001	 mov         r2, r1

; 569  :     PHSMUSB_T pOTG = (PHSMUSB_T)(pContext);
; 570  :     
; 571  :     if ((m_pBusyPipeList == NULL) && (m_PipeListInfoEP0CheckForDoneTransfersCount == NULL) && (!m_SignalDisconnectACK))

  00008	e59030cc	 ldr         r3, [r0, #0xCC]
  0000c	e3530000	 cmp         r3, #0
  00010	1a000010	 bne         |$LN1@SignalDisc|
  00014	e59030c0	 ldr         r3, [r0, #0xC0]
  00018	e3530000	 cmp         r3, #0
  0001c	1a00000d	 bne         |$LN1@SignalDisc|
  00020	e59030d0	 ldr         r3, [r0, #0xD0]
  00024	e3530000	 cmp         r3, #0
  00028	1a00000a	 bne         |$LN1@SignalDisc|

; 572  :     {
; 573  :         {
; 574  :             m_SignalDisconnectACK = TRUE;        

  0002c	e3a03001	 mov         r3, #1
  00030	e58030d0	 str         r3, [r0, #0xD0]

; 575  :             pOTG->connect_status |= CONN_DC;

  00034	e5d2304c	 ldrb        r3, [r2, #0x4C]

; 576  :             DEBUGMSG(ZONE_DEBUG, (TEXT("Signal Disconnect Complete\r\n")));
; 577  :             SetEvent(pOTG->hSysIntrEvent);

  00038	e5920054	 ldr         r0, [r2, #0x54]
  0003c	e3a01003	 mov         r1, #3
  00040	e3833004	 orr         r3, r3, #4
  00044	e5c2304c	 strb        r3, [r2, #0x4C]
  00048	eb000000	 bl          EventModify

; 578  :             return TRUE;

  0004c	e3a00001	 mov         r0, #1

; 583  : }

  00050	e49de004	 ldr         lr, [sp], #4
  00054	e12fff1e	 bx          lr
  00058		 |$LN1@SignalDisc|

; 579  :         }
; 580  :     }
; 581  : 
; 582  :     return FALSE;

  00058	e3a00000	 mov         r0, #0

; 583  : }

  0005c	e49de004	 ldr         lr, [sp], #4
  00060	e12fff1e	 bx          lr
  00064		 |$M44488|

			 ENDP  ; |?SignalDisconnectComplete@CBusyPipeList@@QAAHPAX@Z|, CBusyPipeList::SignalDisconnectComplete

	EXPORT	|?DeInitialize@CHW@@UAAXXZ|		; CHW::DeInitialize

  00000			 AREA	 |.pdata|, PDATA
|$T44498| DCD	|$LN5@DeInitiali|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DeInitialize@CHW@@UAAXXZ| PROC	; CHW::DeInitialize

; 815  : {

  00000		 |$LN5@DeInitiali|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44495|

; 816  :    // Stop The Controller.
; 817  :     {
; 818  :         // Stop USB Controller
; 819  :     }
; 820  :     m_cBusyPipeList.DeInit();

  00004	e28000c0	 add         r0, r0, #0xC0
  00008	eb000000	 bl          |?DeInit@CBusyPipeList@@QAAXXZ|

; 821  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M44496|

			 ENDP  ; |?DeInitialize@CHW@@UAAXXZ|, CHW::DeInitialize

	EXPORT	|?EnterOperationalState@CHW@@QAAXXZ|	; CHW::EnterOperationalState

  00000			 AREA	 |.pdata|, PDATA
|$T44505| DCD	|$LN5@EnterOpera|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?EnterOperationalState@CHW@@QAAXXZ| PROC ; CHW::EnterOperationalState

; 838  : {

  00000		 |$LN5@EnterOpera|
  00000		 |$M44502|

; 839  :     
; 840  :     DEBUGMSG(ZONE_INIT && ZONE_REGISTERS && ZONE_VERBOSE, (TEXT("CHW::EnterOperationalState - clearing status reg\n")));
; 841  : 
; 842  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M44503|

			 ENDP  ; |?EnterOperationalState@CHW@@QAAXXZ|, CHW::EnterOperationalState

	EXPORT	|?GetFrameNumber@CHW@@UAAHPAK@Z|	; CHW::GetFrameNumber
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T44521| DCD	|$LN8@GetFrameNu|
	DCD	0x40000a00
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetFrameNumber@CHW@@UAAHPAK@Z| PROC	; CHW::GetFrameNumber

; 855  : {

  00000		 |$LN8@GetFrameNu|
  00000		 |$M44518|

; 856  :     PHSMUSB_T pOTG = (PHSMUSB_T)GetOTGContext();

  00000	e59030b0	 ldr         r3, [r0, #0xB0]
  00004	e3530000	 cmp         r3, #0

; 857  :     if (pOTG == NULL)
; 858  :         return FALSE;

  00008	03a00000	 moveq       r0, #0

; 859  : 
; 860  :     *lpdwFrameNumber = INREG16(&pOTG->pUsbGenRegs->Frame);

  0000c	15933020	 ldrne       r3, [r3, #0x20]

; 861  :     return TRUE;

  00010	13a00001	 movne       r0, #1
  00014	15d3200c	 ldrneb      r2, [r3, #0xC]
  00018	15d3300d	 ldrneb      r3, [r3, #0xD]
  0001c	11823403	 orrne       r3, r2, r3, lsl #8
  00020	15813000	 strne       r3, [r1]

; 862  : }

  00024	e12fff1e	 bx          lr
  00028		 |$M44519|

			 ENDP  ; |?GetFrameNumber@CHW@@UAAHPAK@Z|, CHW::GetFrameNumber

	EXPORT	|?GetFrameLength@CHW@@UAAHPAG@Z|	; CHW::GetFrameLength

  00000			 AREA	 |.pdata|, PDATA
|$T44531| DCD	|$LN5@GetFrameLe|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetFrameLength@CHW@@UAAHPAG@Z| PROC	; CHW::GetFrameLength

; 876  : {

  00000		 |$LN5@GetFrameLe|
  00000		 |$M44528|
  00000	e3a03cea	 mov         r3, #0xEA, 24

; 877  :     *lpuFrameLength=60000; // same as EHCI

  00004	e3833060	 orr         r3, r3, #0x60
  00008	e1c130b0	 strh        r3, [r1]

; 878  :     return TRUE;

  0000c	e3a00001	 mov         r0, #1

; 879  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M44529|

			 ENDP  ; |?GetFrameLength@CHW@@UAAHPAG@Z|, CHW::GetFrameLength

	EXPORT	|?SetFrameLength@CHW@@UAAHPAXG@Z|	; CHW::SetFrameLength

  00000			 AREA	 |.pdata|, PDATA
|$T44540| DCD	|$LN5@SetFrameLe|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetFrameLength@CHW@@UAAHPAXG@Z| PROC	; CHW::SetFrameLength

; 896  : {

  00000		 |$LN5@SetFrameLe|
  00000		 |$M44537|

; 897  :     BOOL fSuccess = FALSE;
; 898  : 
; 899  :     // to prevent multiple threads from simultaneously adjusting the
; 900  :     // frame length, InterlockedTestExchange is used. This is
; 901  :     // cheaper than using a critical section.
; 902  :     return fSuccess;

  00000	e3a00000	 mov         r0, #0

; 903  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M44538|

			 ENDP  ; |?SetFrameLength@CHW@@UAAHPAXG@Z|, CHW::SetFrameLength

	EXPORT	|?StopAdjustingFrame@CHW@@UAAHXZ|	; CHW::StopAdjustingFrame

  00000			 AREA	 |.pdata|, PDATA
|$T44549| DCD	|$LN5@StopAdjust|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?StopAdjustingFrame@CHW@@UAAHXZ| PROC	; CHW::StopAdjustingFrame

; 916  : {

  00000		 |$LN5@StopAdjust|
  00000		 |$M44546|

; 917  :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 918  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M44547|

			 ENDP  ; |?StopAdjustingFrame@CHW@@UAAHXZ|, CHW::StopAdjustingFrame

	EXPORT	|?CeResumeThread@CHW@@AAAKXZ|		; CHW::CeResumeThread
	IMPORT	|Sleep|

  00000			 AREA	 |.pdata|, PDATA
|$T44563| DCD	|$LN13@CeResumeTh|
	DCD	0x40002c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CeResumeThread@CHW@@AAAKXZ| PROC	; CHW::CeResumeThread

; 942  : {

  00000		 |$LN13@CeResumeTh|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M44560|
  00004	e1a04000	 mov         r4, r0

; 943  :     // reconstruct the objects at the same addresses where they were before;
; 944  :     // this allows us not to have to alert the PDD that the addresses have changed.
; 945  : 
; 946  :     DEBUGCHK( g_fPowerResuming == FALSE );
; 947  : 
; 948  :     // order is important! resuming indicates that the hcd object is temporarily invalid
; 949  :     // while powerup simply signals that a powerup event has occurred. once the powerup
; 950  :     // flag is cleared, we will repeat this whole sequence should it get resignalled.
; 951  :     g_fPowerUpFlag = FALSE;
; 952  :     g_fPowerResuming = TRUE;
; 953  : 
; 954  :     DeviceDeInitialize();

  00008	e5943000	 ldr         r3, [r4]
  0000c	e3a02001	 mov         r2, #1
  00010	e3a06000	 mov         r6, #0
  00014	e5933010	 ldr         r3, [r3, #0x10]
  00018	e584629c	 str         r6, [r4, #0x29C]
  0001c	e58422a0	 str         r2, [r4, #0x2A0]
  00020	e1a0e00f	 mov         lr, pc
  00024	e12fff13	 bx          r3

; 955  :     for(;;) {  // breaks out upon successful reinit of the object
; 956  : 
; 957  :         if (DeviceInitialize())

  00028	e5943000	 ldr         r3, [r4]
  0002c	e1a00004	 mov         r0, r4
  00030	e593300c	 ldr         r3, [r3, #0xC]
  00034	e1a0e00f	 mov         lr, pc
  00038	e12fff13	 bx          r3
  0003c	e3500000	 cmp         r0, #0
  00040	1a00000e	 bne         |$LN9@CeResumeTh|
  00044	e3a05c3a	 mov         r5, #0x3A, 24
  00048		 |$LL4@CeResumeTh|

; 958  :             break;
; 959  :         // getting here means we couldn't reinit the HCD object!
; 960  :         ASSERT(FALSE);
; 961  :         DEBUGMSG(ZONE_ERROR, (TEXT("USB cannot reinit the HCD at CE resume; retrying...\n")));
; 962  :         DeviceDeInitialize();

  00048	e5943000	 ldr         r3, [r4]
  0004c	e1a00004	 mov         r0, r4
  00050	e5933010	 ldr         r3, [r3, #0x10]
  00054	e1a0e00f	 mov         lr, pc
  00058	e12fff13	 bx          r3

; 963  :         Sleep(15000);

  0005c	e3850098	 orr         r0, r5, #0x98
  00060	eb000000	 bl          Sleep
  00064	e5943000	 ldr         r3, [r4]
  00068	e1a00004	 mov         r0, r4
  0006c	e593300c	 ldr         r3, [r3, #0xC]
  00070	e1a0e00f	 mov         lr, pc
  00074	e12fff13	 bx          r3
  00078	e3500000	 cmp         r0, #0
  0007c	0afffff1	 beq         |$LL4@CeResumeTh|
  00080		 |$LN9@CeResumeTh|

; 964  :     }
; 965  : 
; 966  :     // the hcd object is valid again. if a power event occurred between the two flag
; 967  :     // assignments above then the IST will reinitiate this sequence.
; 968  :     g_fPowerResuming = FALSE;
; 969  :     if (g_fPowerUpFlag)

  00080	e594329c	 ldr         r3, [r4, #0x29C]
  00084	e58462a0	 str         r6, [r4, #0x2A0]
  00088	e3530000	 cmp         r3, #0

; 970  :         PowerMgmtCallback(TRUE);

  0008c	15943000	 ldrne       r3, [r4]
  00090	13a01001	 movne       r1, #1
  00094	11a00004	 movne       r0, r4
  00098	15933018	 ldrne       r3, [r3, #0x18]
  0009c	11a0e00f	 movne       lr, pc
  000a0	112fff13	 bxne        r3

; 971  :     
; 972  :     return 0;

  000a4	e3a00000	 mov         r0, #0

; 973  : }

  000a8	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000ac	e12fff1e	 bx          lr
  000b0		 |$M44561|

			 ENDP  ; |?CeResumeThread@CHW@@AAAKXZ|, CHW::CeResumeThread

	EXPORT	|?DidPortStatusChange@CHW@@UAAHE@Z|	; CHW::DidPortStatusChange
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T44581| DCD	|$LN15@DidPortSta|
	DCD	0x40001901
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DidPortStatusChange@CHW@@UAAHE@Z| PROC ; CHW::DidPortStatusChange

; 986  : {

  00000		 |$LN15@DidPortSta|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M44578|
  00004	e3510000	 cmp         r1, #0

; 987  :     PHSMUSB_T pOTG;
; 988  :     DWORD PortSpeed = 0x00; // 0x01 - LS, 0x10 - FS, 0x11 - HS
; 989  :     // port == specifies root hub itself, whose status never changes
; 990  :     if ( port > 0 ) {

  00008	0a000012	 beq         |$LN1@DidPortSta|

; 991  :         DEBUGMSG(ZONE_VERBOSE, (TEXT("CHW::DidPortStatusChange for port %d\r\n"), port));
; 992  :         // Reset the port now and make sure it is okay
; 993  :         pOTG = (PHSMUSB_T)GetOTGContext();

  0000c	e59030b0	 ldr         r3, [r0, #0xB0]
  00010	e1b04003	 movs        r4, r3

; 994  :         if (pOTG == NULL)
; 995  :             return FALSE;

  00014	0a00000f	 beq         |$LN1@DidPortSta|

; 996  : 
; 997  :         DEBUGMSG(ZONE_HCD, (TEXT("CHW::B4 Power = 0x%x\r\n"), pOTG->pUsbGenRegs->Power));
; 998  :         ResetAndEnablePort(port);

  00018	e5903000	 ldr         r3, [r0]
  0001c	e5933030	 ldr         r3, [r3, #0x30]
  00020	e1a0e00f	 mov         lr, pc
  00024	e12fff13	 bx          r3

; 999  :         DEBUGMSG(ZONE_HCD, (TEXT("CHW::DidPortStatusChange: After reset\r\n")));
; 1000 :         DEBUGMSG(ZONE_HCD, (TEXT("CHW::Power = 0x%x\r\n"), INREG8(&pOTG->pUsbGenRegs->Power)));
; 1001 :         DEBUGMSG(ZONE_HCD, (TEXT("CHW::DevCtl = 0x%x\r\n"), INREG8(&pOTG->pUsbGenRegs->DevCtl)));
; 1002 :         if (INREG8(&pOTG->pUsbGenRegs->DevCtl) & DEVCTL_LSDEV)

  00028	e5942020	 ldr         r2, [r4, #0x20]
  0002c	e5d23060	 ldrb        r3, [r2, #0x60]
  00030	e3130020	 tst         r3, #0x20
  00034	1a000002	 bne         |$LN9@DidPortSta|

; 1003 :             PortSpeed = 0x01;
; 1004 :         else if (INREG8(&pOTG->pUsbGenRegs->DevCtl) & DEVCTL_FSDEV) 

  00038	e5d23060	 ldrb        r3, [r2, #0x60]
  0003c	e3130040	 tst         r3, #0x40

; 1005 :             PortSpeed = ((INREG8(&pOTG->pUsbGenRegs->Power) & POWER_HSMODE)? 0x11: 0x10);               

  00040	15d23001	 ldrneb      r3, [r2, #1]
  00044		 |$LN9@DidPortSta|

; 1006 : 
; 1007 :         DEBUGMSG(ZONE_HCD, (TEXT("CHW::PortSpeed = %s\r\n"), 
; 1008 :             ((PortSpeed == 0x01)? TEXT("LS"): ((PortSpeed == 0x10)? TEXT("FS"): TEXT("HS")))));
; 1009 : 
; 1010 :         // Now testing and see the connect status
; 1011 :         DEBUGMSG(ZONE_HCD, (TEXT("Connect Status = 0x%x\r\n"), pOTG->connect_status));
; 1012 :         if (pOTG->connect_status & CONN_CSC)

  00044	e5d4304c	 ldrb        r3, [r4, #0x4C]
  00048	e3130002	 tst         r3, #2

; 1013 :             return TRUE;

  0004c	13a00001	 movne       r0, #1

; 1016 : }

  00050	18bd4010	 ldmneia     sp!, {r4, lr}
  00054	112fff1e	 bxne        lr
  00058		 |$LN1@DidPortSta|

; 1014 :     }
; 1015 :     return FALSE;

  00058	e3a00000	 mov         r0, #0

; 1016 : }

  0005c	e8bd4010	 ldmia       sp!, {r4, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$M44579|

			 ENDP  ; |?DidPortStatusChange@CHW@@UAAHE@Z|, CHW::DidPortStatusChange

	EXPORT	|?GetPortStatus@CHW@@UAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z| ; CHW::GetPortStatus
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T44604| DCD	|$LN15@GetPortSta|
	DCD	0x40004201
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetPortStatus@CHW@@UAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z| PROC ; CHW::GetPortStatus

; 1033 : {

  00000		 |$LN15@GetPortSta|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44601|
  00004	e1a0e002	 mov         lr, r2

; 1034 :     PHSMUSB_T pOTG = (PHSMUSB_T)GetOTGContext();

  00008	e59030b0	 ldr         r3, [r0, #0xB0]
  0000c	e1b04003	 movs        r4, r3

; 1035 :     if (pOTG == NULL)
; 1036 :     {
; 1037 :         DEBUGMSG(ZONE_ERROR, (TEXT("GetPortStatus with pOTG failed\r\n")));
; 1038 :         return FALSE;

  00010	03a00000	 moveq       r0, #0

; 1073 : }

  00014	08bd4030	 ldmeqia     sp!, {r4, r5, lr}
  00018	012fff1e	 bxeq        lr

; 1039 :     }
; 1040 :     memset( &rStatus, 0, sizeof( USB_HUB_AND_PORT_STATUS ) );

  0001c	e3a03000	 mov         r3, #0
  00020	e1ce30b0	 strh        r3, [lr]
  00024	e1ce30b2	 strh        r3, [lr, #2]

; 1041 :     if ( port > 0 ) {

  00028	e3510000	 cmp         r1, #0
  0002c	0a000032	 beq         |$LN1@GetPortSta|

; 1042 :         // request refers to a root hub port
; 1043 :        
; 1044 :         // read the port status register
; 1045 :         rStatus.change.port.ConnectStatusChange = ((pOTG->connect_status & CONN_CSC)? 1:0);

  00030	e5d4304c	 ldrb        r3, [r4, #0x4C]

; 1046 :         rStatus.change.port.PortEnableChange = 0;
; 1047 :         rStatus.change.port.OverCurrentChange = 0;

  00034	e1de20b2	 ldrh        r2, [lr, #2]

; 1048 :         rStatus.status.port.DeviceIsLowSpeed = (INREG8(&pOTG->pUsbGenRegs->DevCtl) & DEVCTL_LSDEV);
; 1049 :         rStatus.status.port.DeviceIsHighSpeed = ((INREG8(&pOTG->pUsbGenRegs->Power) & POWER_HSMODE)? 1:0) ;
; 1050 :         rStatus.status.port.PortConnected = ((pOTG->connect_status & CONN_CCS)?1:0);
; 1051 :         rStatus.status.port.PortEnabled = 1;
; 1052 :         rStatus.status.port.PortOverCurrent = 0;
; 1053 :         rStatus.status.port.PortPower = 1;
; 1054 :         rStatus.status.port.PortReset = INREG8(&pOTG->pUsbGenRegs->Power) & POWER_RESET;

  00038	e3a05cff	 mov         r5, #0xFF, 24
  0003c	e3130002	 tst         r3, #2
  00040	e3a03cff	 mov         r3, #0xFF, 24
  00044	e38330f4	 orr         r3, r3, #0xF4
  00048	13a01001	 movne       r1, #1
  0004c	03a01000	 moveq       r1, #0
  00050	e0022003	 and         r2, r2, r3
  00054	e2013001	 and         r3, r1, #1
  00058	e1823003	 orr         r3, r2, r3
  0005c	e1de10b0	 ldrh        r1, [lr]
  00060	e1ce30b2	 strh        r3, [lr, #2]
  00064	e5942020	 ldr         r2, [r4, #0x20]
  00068	e3a03cfd	 mov         r3, #0xFD, 24
  0006c	e38330ff	 orr         r3, r3, #0xFF
  00070	e5d22060	 ldrb        r2, [r2, #0x60]
  00074	e0011003	 and         r1, r1, r3
  00078	e1ce10b0	 strh        r1, [lr]
  0007c	e5943020	 ldr         r3, [r4, #0x20]
  00080	e5d33001	 ldrb        r3, [r3, #1]
  00084	e3130010	 tst         r3, #0x10
  00088	13a03001	 movne       r3, #1
  0008c	03a03000	 moveq       r3, #0
  00090	e0213503	 eor         r3, r1, r3, lsl #10
  00094	e2033b01	 and         r3, r3, #1, 22
  00098	e0232001	 eor         r2, r3, r1
  0009c	e1ce20b0	 strh        r2, [lr]
  000a0	e5d4304c	 ldrb        r3, [r4, #0x4C]
  000a4	e3130001	 tst         r3, #1
  000a8	e3a03cfe	 mov         r3, #0xFE, 24
  000ac	e38330f4	 orr         r3, r3, #0xF4
  000b0	13a01001	 movne       r1, #1
  000b4	03a01000	 moveq       r1, #0
  000b8	e0022003	 and         r2, r2, r3
  000bc	e2013001	 and         r3, r1, #1
  000c0	e3a01c01	 mov         r1, #1, 24
  000c4	e1822003	 orr         r2, r2, r3
  000c8	e3813002	 orr         r3, r1, #2
  000cc	e1821003	 orr         r1, r2, r3
  000d0	e1ce10b0	 strh        r1, [lr]
  000d4	e5942020	 ldr         r2, [r4, #0x20]
  000d8	e38530ef	 orr         r3, r5, #0xEF
  000dc	e5d20001	 ldrb        r0, [r2, #1]
  000e0	e0012003	 and         r2, r1, r3
  000e4	e1ce20b0	 strh        r2, [lr]

; 1055 :         rStatus.status.port.PortSuspended =  INREG8(&pOTG->pUsbGenRegs->Power) & POWER_SUSPENDM;

  000e8	e5941020	 ldr         r1, [r4, #0x20]
  000ec	e38530fb	 orr         r3, r5, #0xFB
  000f0	e0022003	 and         r2, r2, r3
  000f4	e5d13001	 ldrb        r3, [r1, #1]
  000f8	e1ce20b0	 strh        r2, [lr]
  000fc		 |$LN1@GetPortSta|

; 1056 :     }
; 1057 : #ifdef DEBUG
; 1058 :     else {
; 1059 :         // request is to Hub. rStatus was already memset to 0 above.
; 1060 :         DEBUGCHK( port == 0 );
; 1061 :         // local power supply good
; 1062 :         DEBUGCHK( rStatus.status.hub.LocalPowerStatus == 0 );
; 1063 :         // no over current condition
; 1064 :         DEBUGCHK( rStatus.status.hub.OverCurrentIndicator == 0 );
; 1065 :         // no change in power supply status
; 1066 :         DEBUGCHK( rStatus.change.hub.LocalPowerChange == 0 );
; 1067 :         // no change in over current status
; 1068 :         DEBUGCHK( rStatus.change.hub.OverCurrentIndicatorChange == 0 );
; 1069 :     }
; 1070 : #endif // DEBUG
; 1071 : 
; 1072 :     return TRUE;

  000fc	e3a00001	 mov         r0, #1

; 1073 : }

  00100	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00104	e12fff1e	 bx          lr
  00108		 |$M44602|

			 ENDP  ; |?GetPortStatus@CHW@@UAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z|, CHW::GetPortStatus

	EXPORT	|?RootHubFeature@CHW@@UAAHEEG@Z|	; CHW::RootHubFeature
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T44623| DCD	|$LN24@RootHubFea|
	DCD	0x40002401
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?RootHubFeature@CHW@@UAAHEEG@Z| PROC	; CHW::RootHubFeature

; 1091 : {

  00000		 |$LN24@RootHubFea|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44620|

; 1092 :     PHSMUSB_T pOTG = (PHSMUSB_T)GetOTGContext();

  00004	e590e0b0	 ldr         lr, [r0, #0xB0]
  00008	e35e0000	 cmp         lr, #0

; 1093 :     if (pOTG == NULL)

  0000c	1a000002	 bne         |$LN16@RootHubFea|
  00010		 |$LN21@RootHubFea|

; 1094 :     {
; 1095 :         DEBUGMSG(ZONE_HCD, (TEXT("GetPortStatus with pOTG failed\r\n")));
; 1096 :         return FALSE;

  00010	e3a00000	 mov         r0, #0

; 1146 : }

  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$LN16@RootHubFea|

; 1097 :     }
; 1098 : 
; 1099 :     if (port == 0) {

  0001c	e3510000	 cmp         r1, #0

; 1100 :         // request is to Hub but...
; 1101 :         // uhci has no way to tweak features for the root hub.
; 1102 :         return FALSE;

  00020	0afffffa	 beq         |$LN21@RootHubFea|

; 1103 :     }
; 1104 : 
; 1105 :     DEBUGMSG(ZONE_HCD, (TEXT("SetOrClearFeature(0x%x), feature(0x%x), port(%d)\r\n"), setOrClearFeature, feature, port));
; 1106 :     // mask the change bits because we write 1 to them to clear them //      
; 1107 :     if (setOrClearFeature == USB_REQUEST_SET_FEATURE)

  00024	e3520003	 cmp         r2, #3
  00028	1a00000c	 bne         |$LN14@RootHubFea|

; 1108 :     {
; 1109 :         switch (feature) {

  0002c	e3530002	 cmp         r3, #2
  00030	0a000013	 beq         |$LN3@RootHubFea|
  00034	e3530004	 cmp         r3, #4
  00038	0a000002	 beq         |$LN11@RootHubFea|
  0003c	e3530008	 cmp         r3, #8
  00040	0a00000f	 beq         |$LN3@RootHubFea|

; 1113 :                 break;
; 1114 :             case USB_HUB_FEATURE_PORT_SUSPEND:            
; 1115 :                 DEBUGMSG(ZONE_HCD, (TEXT("USB_HUB_FEATURE_PORT_SUSPEND\r\n")));
; 1116 :                 break;
; 1117 :             case USB_HUB_FEATURE_PORT_POWER:            
; 1118 :                 DEBUGMSG(ZONE_HCD, (TEXT("USB_HUB_FEATURE_PORT_POWER\r\n")));
; 1119 :                 break;
; 1120 :             default: return FALSE;

  00044	eafffff1	 b           |$LN21@RootHubFea|
  00048		 |$LN11@RootHubFea|

; 1110 :             case USB_HUB_FEATURE_PORT_RESET:            
; 1111 :                 DEBUGMSG(ZONE_HCD, (TEXT("USB_HUB_FEATURE_PORT_RESET\r\n")));
; 1112 :                 ResetAndEnablePort(1);

  00048	e5903000	 ldr         r3, [r0]
  0004c	e3a01001	 mov         r1, #1
  00050	e5933030	 ldr         r3, [r3, #0x30]
  00054	e1a0e00f	 mov         lr, pc
  00058	e12fff13	 bx          r3

; 1121 :         }
; 1122 :     }
; 1123 :     else

  0005c	ea000008	 b           |$LN3@RootHubFea|
  00060		 |$LN14@RootHubFea|

; 1124 :     {
; 1125 :         switch (feature) {

  00060	e3530001	 cmp         r3, #1
  00064	0a000006	 beq         |$LN3@RootHubFea|
  00068	e3530002	 cmp         r3, #2
  0006c	0a000004	 beq         |$LN3@RootHubFea|
  00070	e3530010	 cmp         r3, #0x10

; 1126 :             case USB_HUB_FEATURE_PORT_ENABLE:
; 1127 :                 DEBUGMSG(ZONE_HCD, (TEXT("CLEAR: USB_HUB_FEATURE_PORT_ENABLE\r\n")));
; 1128 :                 break;
; 1129 :             case USB_HUB_FEATURE_PORT_SUSPEND:    
; 1130 :                 DEBUGMSG(ZONE_HCD, (TEXT("CLEAR: USB_HUB_FEATURE_PORT_SUSPEND\r\n")));
; 1131 :                 break;
; 1132 :             case USB_HUB_FEATURE_C_PORT_CONNECTION:       
; 1133 :                     // I think it should be done by critical section or function pointer in OTG side
; 1134 :                 DEBUGMSG(ZONE_HCD, (TEXT("USB_HUB_FEATURE_C_PORT_CONNECTION\r\n")));
; 1135 :                 pOTG->connect_status &= ~CONN_CSC; // clear the connect status change
; 1136 :                 break;
; 1137 :             case USB_HUB_FEATURE_C_PORT_ENABLE:           
; 1138 :             case USB_HUB_FEATURE_C_PORT_RESET:            
; 1139 :             case USB_HUB_FEATURE_C_PORT_SUSPEND:
; 1140 :             case USB_HUB_FEATURE_C_PORT_OVER_CURRENT:
; 1141 :             case USB_HUB_FEATURE_PORT_POWER:
; 1142 :             default: return FALSE;

  00074	1affffe5	 bne         |$LN21@RootHubFea|
  00078	e5de304c	 ldrb        r3, [lr, #0x4C]
  0007c	e20330fd	 and         r3, r3, #0xFD
  00080	e5ce304c	 strb        r3, [lr, #0x4C]
  00084		 |$LN3@RootHubFea|

; 1143 :         }
; 1144 :     }
; 1145 :     return TRUE;

  00084	e3a00001	 mov         r0, #1

; 1146 : }

  00088	e49de004	 ldr         lr, [sp], #4
  0008c	e12fff1e	 bx          lr
  00090		 |$M44621|

			 ENDP  ; |?RootHubFeature@CHW@@UAAHEEG@Z|, CHW::RootHubFeature

	EXPORT	|?ResetAndEnablePort@CHW@@UAAHE@Z|	; CHW::ResetAndEnablePort
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T44639| DCD	|$LN9@ResetAndEn|
	DCD	0x40001701
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResetAndEnablePort@CHW@@UAAHE@Z| PROC ; CHW::ResetAndEnablePort

; 1164 : {

  00000		 |$LN9@ResetAndEn|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M44636|

; 1165 :     BOOL fSuccess = TRUE;
; 1166 :     PHSMUSB_T pOTG = (PHSMUSB_T)GetOTGContext();

  00004	e59030b0	 ldr         r3, [r0, #0xB0]
  00008	e1b04003	 movs        r4, r3

; 1167 :     if (pOTG == NULL)
; 1168 :         return FALSE;

  0000c	03a00000	 moveq       r0, #0

; 1187 : }

  00010	08bd4010	 ldmeqia     sp!, {r4, lr}
  00014	012fff1e	 bxeq        lr

; 1169 : 
; 1170 :     DEBUGMSG(ZONE_HCD, (TEXT("ResetAndEnablePort(%d)\r\n"), port));        
; 1171 :         // USB 1.1 spec, 7.1.7.3 - device may take up to 10 ms
; 1172 :         // to recover after reset is removed
; 1173 :         //Do a reset now no matter what
; 1174 :     if (port > 0)

  00018	e3510000	 cmp         r1, #0
  0001c	0a000009	 beq         |$LN1@ResetAndEn|

; 1175 :     {
; 1176 :         // We do the Power |= POWER_RESET
; 1177 :         SETREG8(&pOTG->pUsbGenRegs->Power, POWER_RESET);

  00020	e5942020	 ldr         r2, [r4, #0x20]

; 1178 :         Sleep(50); // Sleep for 50ms after reset as request

  00024	e3a00032	 mov         r0, #0x32
  00028	e5d23001	 ldrb        r3, [r2, #1]
  0002c	e3833008	 orr         r3, r3, #8
  00030	e5c23001	 strb        r3, [r2, #1]
  00034	eb000000	 bl          Sleep

; 1179 :         // We do the Power &= ~POWER_RESET
; 1180 :         CLRREG8(&pOTG->pUsbGenRegs->Power, POWER_RESET);

  00038	e5942020	 ldr         r2, [r4, #0x20]
  0003c	e5d23001	 ldrb        r3, [r2, #1]
  00040	e20330f7	 and         r3, r3, #0xF7
  00044	e5c23001	 strb        r3, [r2, #1]
  00048		 |$LN1@ResetAndEn|

; 1181 :     }
; 1182 : 
; 1183 :     Sleep( 10 );

  00048	e3a0000a	 mov         r0, #0xA
  0004c	eb000000	 bl          Sleep

; 1184 :   
; 1185 : 
; 1186 :     return fSuccess;

  00050	e3a00001	 mov         r0, #1

; 1187 : }

  00054	e8bd4010	 ldmia       sp!, {r4, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$M44637|

			 ENDP  ; |?ResetAndEnablePort@CHW@@UAAHE@Z|, CHW::ResetAndEnablePort

	EXPORT	|?DisablePort@CHW@@UAAXE@Z|		; CHW::DisablePort

  00000			 AREA	 |.pdata|, PDATA
|$T44646| DCD	|$LN5@DisablePor|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DisablePort@CHW@@UAAXE@Z| PROC	; CHW::DisablePort

; 1199 : {

  00000		 |$LN5@DisablePor|
  00000		 |$M44643|

; 1200 : #if 0
; 1201 :     PORTSC portSC=Read_PORTSC(port);;
; 1202 :     // no point doing any work unless the port is enabled
; 1203 :     if ( portSC.bit.Power && portSC.bit.Owner==0 && portSC.bit.Enabled ) {
; 1204 :         // clear port enabled bit and enabled change bit,
; 1205 :         // but don't alter the connect status change bit,
; 1206 :         // which is write-clear.
; 1207 :         portSC.bit.Enabled=0;
; 1208 :         portSC.bit.ConnectStatusChange=0;
; 1209 :         portSC.bit.EnableChange=1;
; 1210 :         portSC.bit.OverCurrentChange=0;        
; 1211 :         Write_PORTSC( port, portSC );
; 1212 : 
; 1213 :         // disable port can take some time to act, because
; 1214 :         // a USB request may have been in progress on the port.
; 1215 :         Sleep( 10 );
; 1216 :     }
; 1217 : #else
; 1218 : #ifdef DEBUG
; 1219 :     DEBUGMSG(ZONE_HCD, (TEXT("CHW::DisablePort %d\r\n"), port));
; 1220 : #else
; 1221 :     UNREFERENCED_PARAMETER(port);
; 1222 : #endif
; 1223 : #endif
; 1224 : }

  00000	e12fff1e	 bx          lr
  00004		 |$M44644|

			 ENDP  ; |?DisablePort@CHW@@UAAXE@Z|, CHW::DisablePort

	EXPORT	|?AcquireDMAChannel@CHW@@QAAEPAVCPipe@@@Z| ; CHW::AcquireDMAChannel
	IMPORT	|HcdPdd_PreTransferActivation|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\cpipe.h

  00000			 AREA	 |.bss|, NOINIT
|?next_availDMA@?1??AcquireDMAChannel@CHW@@QAAEPAVCPipe@@@Z@4HA| % 0x4 ; `CHW::AcquireDMAChannel'::`2'::next_availDMA

  00000			 AREA	 |.pdata|, PDATA
|$T44682| DCD	|$LN28@AcquireDMA|
	DCD	0x40004d02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AcquireDMAChannel@CHW@@QAAEPAVCPipe@@@Z| PROC ; CHW::AcquireDMAChannel

; 1307 : {

  00000		 |$LN28@AcquireDMA|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M44679|
  00008	e1a0a001	 mov         r10, r1
  0000c	e1a07000	 mov         r7, r0

; 1308 :     int i;
; 1309 :     PHSMUSB_T pOTG = (PHSMUSB_T)pPipe->m_pCMhcd->GetOTGContext();

  00010	e59a300c	 ldr         r3, [r10, #0xC]

; 1310 :     USB_ENDPOINT_DESCRIPTOR endptDesc = pPipe->GetEndptDescriptor();

  00014	e28d0000	 add         r0, sp, #0
  00018	e28a1034	 add         r1, r10, #0x34
  0001c	e593b0b0	 ldr         r11, [r3, #0xB0]
  00020	e3a02007	 mov         r2, #7
  00024	eb000000	 bl          memcpy

; 1311 :     USHORT deviceInfo = ((pPipe->GetReservedDeviceAddr() << 8)| (endptDesc.bEndpointAddress & 0xff));

  00028	e59a3000	 ldr         r3, [r10]
  0002c	e1a0000a	 mov         r0, r10
  00030	e5933028	 ldr         r3, [r3, #0x28]
  00034	e1a0e00f	 mov         lr, pc
  00038	e12fff13	 bx          r3

; 1312 :     UCHAR channel = 0xff;
; 1313 :     UCHAR avail_channel = 0xff;
; 1314 :     BOOL  fNewChannel = FALSE;
; 1315 :     static int next_availDMA = 0;    
; 1316 : 
; 1317 : #ifdef DEBUG
; 1318 : 	UCHAR endpoint = USB_ENDPOINT(endptDesc.bEndpointAddress);
; 1319 : #endif
; 1320 : 
; 1321 :     int start = next_availDMA;

  0003c	e59f20ec	 ldr         r2, [pc, #0xEC]
  00040	e5dd3002	 ldrb        r3, [sp, #2]

; 1322 :     i = start;
; 1323 :     EnterCriticalSection(&m_csDMAChannel);

  00044	e3a050ff	 mov         r5, #0xFF
  00048	e5922000	 ldr         r2, [r2]
  0004c	e1833400	 orr         r3, r3, r0, lsl #8
  00050	e1a09803	 mov         r9, r3, lsl #16
  00054	e2870f72	 add         r0, r7, #0x72, 30
  00058	e58d2000	 str         r2, [sp]
  0005c	e1a06002	 mov         r6, r2
  00060	e1a09829	 mov         r9, r9, lsr #16
  00064	e3a040ff	 mov         r4, #0xFF
  00068	e3a08000	 mov         r8, #0
  0006c	eb000000	 bl          EnterCriticalSection

; 1324 :     for (;;)
; 1325 :     {
; 1326 :         if (m_DMAChannel[i] == deviceInfo)

  00070	e1a01006	 mov         r1, r6
  00074	e0873081	 add         r3, r7, r1, lsl #1
  00078	ea00000a	 b           |$LN24@AcquireDMA|
  0007c		 |$LL10@AcquireDMA|

; 1329 :             break;
; 1330 :         }
; 1331 :         else if ((m_DMAChannel[i] == 0xff) && (avail_channel == 0xff))

  0007c	e35300ff	 cmp         r3, #0xFF
  00080	035400ff	 cmpeq       r4, #0xFF

; 1332 :             avail_channel = (UCHAR)i;
; 1333 : 
; 1334 :         i = (i+1)%MAX_DMA_CHANNEL;

  00084	e2862001	 add         r2, r6, #1
  00088	020640ff	 andeq       r4, r6, #0xFF
  0008c	e1b03002	 movs        r3, r2
  00090	42833007	 addmi       r3, r3, #7
  00094	e1a031c3	 mov         r3, r3, asr #3
  00098	e0426183	 sub         r6, r2, r3, lsl #3

; 1335 :         if (i == start)

  0009c	e1560001	 cmp         r6, r1
  000a0	0a000005	 beq         |$LN22@AcquireDMA|
  000a4	e0873086	 add         r3, r7, r6, lsl #1
  000a8		 |$LN24@AcquireDMA|
  000a8	e2833c01	 add         r3, r3, #1, 24
  000ac	e1d33bb8	 ldrh        r3, [r3, #0xB8]
  000b0	e1530009	 cmp         r3, r9
  000b4	1afffff0	 bne         |$LL10@AcquireDMA|

; 1327 :         {
; 1328 :             channel = (UCHAR)i;

  000b8	e20650ff	 and         r5, r6, #0xFF
  000bc		 |$LN22@AcquireDMA|

; 1336 :             break;
; 1337 :     }
; 1338 : 
; 1339 :     if (channel == 0xff)

  000bc	e35500ff	 cmp         r5, #0xFF
  000c0	1a00000d	 bne         |$LN3@AcquireDMA|

; 1340 :     {
; 1341 :         channel = avail_channel;

  000c4	e1a05004	 mov         r5, r4

; 1342 :         if (avail_channel != 0xff)

  000c8	e35400ff	 cmp         r4, #0xFF
  000cc	0a00000e	 beq         |$LN2@AcquireDMA|

; 1343 :         {
; 1344 :             m_DMAChannel[avail_channel] = deviceInfo;
; 1345 :             next_availDMA = (avail_channel+1)%MAX_DMA_CHANNEL;

  000d0	e2841001	 add         r1, r4, #1
  000d4	e1b03001	 movs        r3, r1
  000d8	42833007	 addmi       r3, r3, #7
  000dc	e1a031c3	 mov         r3, r3, asr #3
  000e0	e0413183	 sub         r3, r1, r3, lsl #3
  000e4	e59f1044	 ldr         r1, [pc, #0x44]
  000e8	e0872084	 add         r2, r7, r4, lsl #1
  000ec	e2822c01	 add         r2, r2, #1, 24
  000f0	e5813000	 str         r3, [r1]
  000f4	e1c29bb8	 strh        r9, [r2, #0xB8]

; 1346 :             fNewChannel = TRUE;

  000f8	e3a08001	 mov         r8, #1
  000fc		 |$LN3@AcquireDMA|

; 1347 :         }
; 1348 :     }
; 1349 : 
; 1350 :     if (avail_channel != 0xff)

  000fc	e35400ff	 cmp         r4, #0xFF

; 1351 :     {
; 1352 :         // Finally set the m_hEP2Handles 
; 1353 :         m_cBusyPipeList.m_hDMA2Handles[channel] = pPipe->GetDMATransferEvent();        

  00100	159a2060	 ldrne       r2, [r10, #0x60]
  00104	10873105	 addne       r3, r7, r5, lsl #2
  00108	15832154	 strne       r2, [r3, #0x154]
  0010c		 |$LN2@AcquireDMA|

; 1354 :     }
; 1355 : 
; 1356 :     if (fNewChannel)

  0010c	e3580000	 cmp         r8, #0

; 1357 :         HcdPdd_PreTransferActivation((SMHCDPdd *)pOTG->pContext[HOST_MODE-1]);

  00110	159b0014	 ldrne       r0, [r11, #0x14]
  00114	1b000000	 blne        HcdPdd_PreTransferActivation

; 1358 : 
; 1359 :     LeaveCriticalSection(&m_csDMAChannel);

  00118	e2870f72	 add         r0, r7, #0x72, 30
  0011c	eb000000	 bl          LeaveCriticalSection

; 1360 :            
; 1361 :     DEBUGMSG(ZONE_HCD|ZONE_DEBUG, (TEXT("AcquireDMAChannel:ep %d, device %d channel %d value = 0x%x\r\n"),
; 1362 :         endpoint, pPipe->GetReservedDeviceAddr(), channel, ((channel == 0xff)?0x00:m_DMAChannel[channel])));
; 1363 : 
; 1364 : 
; 1365 :     return channel;
; 1366 : }

  00120	e1a00005	 mov         r0, r5
  00124	e28dd008	 add         sp, sp, #8
  00128	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0012c	e12fff1e	 bx          lr
  00130		 |$LN29@AcquireDMA|
  00130		 |$LN30@AcquireDMA|
  00130	00000000	 DCD         |?next_availDMA@?1??AcquireDMAChannel@CHW@@QAAEPAVCPipe@@@Z@4HA|
  00134		 |$M44680|

			 ENDP  ; |?AcquireDMAChannel@CHW@@QAAEPAVCPipe@@@Z|, CHW::AcquireDMAChannel

	EXPORT	|?Channel2DeviceInfo@CHW@@QAAGE@Z|	; CHW::Channel2DeviceInfo

  00000			 AREA	 |.pdata|, PDATA
|$T44696| DCD	|$LN5@Channel2De|
	DCD	0x40000400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Channel2DeviceInfo@CHW@@QAAGE@Z| PROC ; CHW::Channel2DeviceInfo

; 1376 : {

  00000		 |$LN5@Channel2De|
  00000		 |$M44693|

; 1377 :     return m_DMAChannel[channel];

  00000	e28130dc	 add         r3, r1, #0xDC
  00004	e0803083	 add         r3, r0, r3, lsl #1
  00008	e1d300b0	 ldrh        r0, [r3]

; 1378 : }

  0000c	e12fff1e	 bx          lr
  00010		 |$M44694|

			 ENDP  ; |?Channel2DeviceInfo@CHW@@QAAGE@Z|, CHW::Channel2DeviceInfo

	EXPORT	|?DeviceInfo2Channel@CHW@@QAAEPAVCPipe@@@Z| ; CHW::DeviceInfo2Channel
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\cpipe.h

  00000			 AREA	 |.pdata|, PDATA
|$T44715| DCD	|$LN14@DeviceInfo|
	DCD	0x40002702
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DeviceInfo2Channel@CHW@@QAAEPAVCPipe@@@Z| PROC ; CHW::DeviceInfo2Channel

; 1387 : {

  00000		 |$LN14@DeviceInfo|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M44712|
  00008	e1a04001	 mov         r4, r1
  0000c	e1a05000	 mov         r5, r0

; 1388 :     int i; 
; 1389 :     USB_ENDPOINT_DESCRIPTOR endptDesc = pPipe->GetEndptDescriptor();

  00010	e28d0000	 add         r0, sp, #0
  00014	e2841034	 add         r1, r4, #0x34
  00018	e3a02007	 mov         r2, #7
  0001c	eb000000	 bl          memcpy

; 1390 :     USHORT deviceInfo = ((pPipe->GetReservedDeviceAddr() << 8)| (endptDesc.bEndpointAddress & 0xff));

  00020	e5943000	 ldr         r3, [r4]
  00024	e1a00004	 mov         r0, r4
  00028	e5933028	 ldr         r3, [r3, #0x28]
  0002c	e1a0e00f	 mov         lr, pc
  00030	e12fff13	 bx          r3
  00034	e5dd3002	 ldrb        r3, [sp, #2]

; 1391 : 
; 1392 :     EnterCriticalSection(&m_csDMAChannel);

  00038	e2856f72	 add         r6, r5, #0x72, 30
  0003c	e1833400	 orr         r3, r3, r0, lsl #8
  00040	e1a07803	 mov         r7, r3, lsl #16
  00044	e1a00006	 mov         r0, r6
  00048	e1a07827	 mov         r7, r7, lsr #16
  0004c	eb000000	 bl          EnterCriticalSection

; 1393 :     for (i = 0; i < DMA_MAX_CHANNEL; i++)

  00050	e3a04000	 mov         r4, #0
  00054		 |$LL4@DeviceInfo|

; 1394 :     {
; 1395 :         if (m_DMAChannel[i] == deviceInfo)

  00054	e2853c01	 add         r3, r5, #1, 24
  00058	e1d33bb8	 ldrh        r3, [r3, #0xB8]
  0005c	e1530007	 cmp         r3, r7
  00060	0a000007	 beq         |$LN10@DeviceInfo|
  00064	e2844001	 add         r4, r4, #1
  00068	e3540008	 cmp         r4, #8
  0006c	e2855002	 add         r5, r5, #2
  00070	bafffff7	 blt         |$LL4@DeviceInfo|

; 1399 :         }
; 1400 :     }
; 1401 :     
; 1402 :     LeaveCriticalSection(&m_csDMAChannel);

  00074	e1a00006	 mov         r0, r6
  00078	eb000000	 bl          LeaveCriticalSection

; 1403 :     return 0xff;

  0007c	e3a000ff	 mov         r0, #0xFF
  00080	ea000002	 b           |$LN5@DeviceInfo|
  00084		 |$LN10@DeviceInfo|

; 1396 :         {
; 1397 :             LeaveCriticalSection(&m_csDMAChannel);

  00084	e1a00006	 mov         r0, r6
  00088	eb000000	 bl          LeaveCriticalSection

; 1398 :             return (UCHAR)i;

  0008c	e20400ff	 and         r0, r4, #0xFF

; 1403 :     return 0xff;

  00090		 |$LN5@DeviceInfo|

; 1404 : }

  00090	e28dd008	 add         sp, sp, #8
  00094	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00098	e12fff1e	 bx          lr
  0009c		 |$M44713|

			 ENDP  ; |?DeviceInfo2Channel@CHW@@QAAEPAVCPipe@@@Z|, CHW::DeviceInfo2Channel

	EXPORT	|?DumpRxCSR@CHW@@QAAXE@Z|		; CHW::DumpRxCSR
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T44729| DCD	|$LN8@DumpRxCSR|
	DCD	0x40000e01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DumpRxCSR@CHW@@QAAXE@Z| PROC		; CHW::DumpRxCSR

; 1432 : {

  00000		 |$LN8@DumpRxCSR|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44726|
  00004	e1a05001	 mov         r5, r1

; 1433 :     PHSMUSB_T pOTG;        
; 1434 :     UCHAR csrIndex = INDEX(endpoint);    
; 1435 : 
; 1436 :     pOTG = (PHSMUSB_T)GetOTGContext();

  00008	e59030b0	 ldr         r3, [r0, #0xB0]
  0000c	e1b04003	 movs        r4, r3

; 1437 :     if (pOTG == NULL)

  00010	0a000006	 beq         |$LN2@DumpRxCSR|

; 1438 :     {
; 1439 :         DEBUGMSG(ZONE_ERROR, (TEXT("CHW::ConfigEP failed\r\n")));
; 1440 :         return;
; 1441 :     }  
; 1442 :     DEBUGMSG(ZONE_DEBUG, (TEXT("DumpCSR: EP %d\r\n"), endpoint));
; 1443 :     EnterCriticalSection(&pOTG->regCS); 

  00014	e2840038	 add         r0, r4, #0x38
  00018	eb000000	 bl          EnterCriticalSection

; 1444 :     OUTREG8(&pOTG->pUsbGenRegs->Index, csrIndex);

  0001c	e5942020	 ldr         r2, [r4, #0x20]
  00020	e205300f	 and         r3, r5, #0xF

; 1445 :     
; 1446 :     DEBUGMSG(ZONE_DEBUG, (TEXT("RxCSR = 0x%x\r\n"), INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR)));
; 1447 :     DEBUGMSG(ZONE_DEBUG, (TEXT("RxCount = 0x%x\r\n"), INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].Count.RxCount)));
; 1448 : 
; 1449 :     LeaveCriticalSection(&pOTG->regCS);    

  00024	e2840038	 add         r0, r4, #0x38
  00028	e5c2300e	 strb        r3, [r2, #0xE]
  0002c	eb000000	 bl          LeaveCriticalSection
  00030		 |$LN2@DumpRxCSR|

; 1450 : }

  00030	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00034	e12fff1e	 bx          lr
  00038		 |$M44727|

			 ENDP  ; |?DumpRxCSR@CHW@@QAAXE@Z|, CHW::DumpRxCSR

	EXPORT	|?AcquirePhysicalEndPoint@CHW@@QAAEPAVCPipe@@@Z| ; CHW::AcquirePhysicalEndPoint
	EXPORT	|??_C@_1DE@OFOMOBKP@?$AAF?$AAA?$AAI?$AAL?$AAE?$AAD?$AA?5?$AAT?$AAO?$AA?5?$AAG?$AAE?$AAT?$AA?5?$AAT?$AAH?$AAE?$AA?5?$AAE?$AAP?$AA?$CB?$AA?$CB?$AA?$CB?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|NKDbgPrintfW|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\cpipe.h

  00000			 AREA	 |.pdata|, PDATA
|$T44769| DCD	|$LN39@AcquirePhy|
	DCD	0x40007002

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DE@OFOMOBKP@?$AAF?$AAA?$AAI?$AAL?$AAE?$AAD?$AA?5?$AAT?$AAO?$AA?5?$AAG?$AAE?$AAT?$AA?5?$AAT?$AAH?$AAE?$AA?5?$AAE?$AAP?$AA?$CB?$AA?$CB?$AA?$CB?$AA?$AN?$AA?6?$AA?$AA@| DCB "F"
	DCB	0x0, "A", 0x0, "I", 0x0, "L", 0x0, "E", 0x0, "D", 0x0, " "
	DCB	0x0, "T", 0x0, "O", 0x0, " ", 0x0, "G", 0x0, "E", 0x0, "T"
	DCB	0x0, " ", 0x0, "T", 0x0, "H", 0x0, "E", 0x0, " ", 0x0, "E"
	DCB	0x0, "P", 0x0, "!", 0x0, "!", 0x0, "!", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.data|, DATA
|?next_assigned_EP@?1??AcquirePhysicalEndPoint@CHW@@QAAEPAVCPipe@@@Z@4PAHA| DCD 0x1 ; `CHW::AcquirePhysicalEndPoint'::`2'::next_assigned_EP
	DCD	0x1
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AcquirePhysicalEndPoint@CHW@@QAAEPAVCPipe@@@Z| PROC ; CHW::AcquirePhysicalEndPoint

; 1460 : {

  00000		 |$LN39@AcquirePhy|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M44766|
  00008	e1a09001	 mov         r9, r1
  0000c	e1a05000	 mov         r5, r0

; 1461 :     int i;    
; 1462 :     USB_ENDPOINT_DESCRIPTOR endptDesc = pPipe->GetEndptDescriptor();

  00010	e28d0000	 add         r0, sp, #0
  00014	e2891034	 add         r1, r9, #0x34
  00018	e3a02007	 mov         r2, #7
  0001c	eb000000	 bl          memcpy

; 1463 :     UCHAR endpoint = USB_ENDPOINT(endptDesc.bEndpointAddress);

  00020	e5dd7002	 ldrb        r7, [sp, #2]

; 1464 :     UCHAR isOut = USB_ENDPOINT_DIRECTION_OUT(endptDesc.bEndpointAddress)?1:0;    
; 1465 :     UCHAR mappedEP = 0xff;
; 1466 :     UCHAR avail_EP = 0xff;
; 1467 :     UCHAR reuse_EP = 0xff;
; 1468 :     USHORT deviceInfo = ((pPipe->GetReservedDeviceAddr() << 8)| (endptDesc.bEndpointAddress & 0xff));

  00024	e5993000	 ldr         r3, [r9]
  00028	e1a00009	 mov         r0, r9
  0002c	e3170080	 tst         r7, #0x80
  00030	03a02001	 moveq       r2, #1
  00034	13a02000	 movne       r2, #0
  00038	e5933028	 ldr         r3, [r3, #0x28]
  0003c	e202a0ff	 and         r10, r2, #0xFF
  00040	e207800f	 and         r8, r7, #0xF
  00044	e3a040ff	 mov         r4, #0xFF
  00048	e3a060ff	 mov         r6, #0xFF
  0004c	e3a0b0ff	 mov         r11, #0xFF
  00050	e1a0e00f	 mov         lr, pc
  00054	e12fff13	 bx          r3
  00058	e1873400	 orr         r3, r7, r0, lsl #8
  0005c	e1a07803	 mov         r7, r3, lsl #16
  00060	e1a07827	 mov         r7, r7, lsr #16

; 1469 : 
; 1470 :     // Try to implement a circular queue and see if it can get improved.
; 1471 :     static int next_assigned_EP[2] = {1,1}; // {IN, OUT}
; 1472 : 
; 1473 :     if (USB_ENDPOINT(endpoint) == 0)

  00064	e318000f	 tst         r8, #0xF
  00068	1a000007	 bne         |$LN17@AcquirePhy|

; 1474 :     {
; 1475 :         for (i = 0; i < MAX_DIR; i++)

  0006c	e3a02002	 mov         r2, #2
  00070		 |$LL16@AcquirePhy|

; 1476 :         {            
; 1477 :             m_EndPoint[0][i].usDeviceInfo = deviceInfo;

  00070	e2853c01	 add         r3, r5, #1, 24
  00074	e1c37eb2	 strh        r7, [r3, #0xE2]
  00078	e2855004	 add         r5, r5, #4
  0007c	e2522001	 subs        r2, r2, #1
  00080	1afffffa	 bne         |$LL16@AcquirePhy|

; 1478 :             // No need to update the m_hEP2Handles
; 1479 :         }
; 1480 :         return 0;

  00084	e3a04000	 mov         r4, #0
  00088	ea000042	 b           |$LN18@AcquirePhy|
  0008c		 |$LN17@AcquirePhy|

; 1481 :     }
; 1482 : 
; 1483 :     EnterCriticalSection(&m_csEndPoint);

  0008c	e2850f99	 add         r0, r5, #0x99, 30
  00090	eb000000	 bl          EnterCriticalSection

; 1484 :     i = next_assigned_EP[isOut];

  00094	e59f0120	 ldr         r0, [pc, #0x120]
  00098	e7b0210a	 ldr         r2, [r0, +r10, lsl #2]!

; 1485 :     int start = i;
; 1486 : 
; 1487 :     for (;;)
; 1488 :     {
; 1489 :         if (m_EndPoint[i][isOut].usDeviceInfo == deviceInfo)

  0009c	e08a3082	 add         r3, r10, r2, lsl #1
  000a0	e0853103	 add         r3, r5, r3, lsl #2
  000a4	e2833c01	 add         r3, r3, #1, 24
  000a8	e1d31eb2	 ldrh        r1, [r3, #0xE2]
  000ac	e1a08002	 mov         r8, r2
  000b0	e1510007	 cmp         r1, r7
  000b4	0a00001a	 beq         |$LN33@AcquirePhy|
  000b8	e3a03cff	 mov         r3, #0xFF, 24
  000bc	e383e0ff	 orr         lr, r3, #0xFF
  000c0		 |$LL13@AcquirePhy|

; 1492 :             break;
; 1493 :         }        
; 1494 :         else if ((m_EndPoint[i][isOut].usDeviceInfo == 0xffff) && (reuse_EP == 0xff) &&
; 1495 :             (m_EndPoint[i][isOut].usPrevDevInfo == deviceInfo))

  000c0	e151000e	 cmp         r1, lr
  000c4	1a00000b	 bne         |$LN7@AcquirePhy|
  000c8	e35b00ff	 cmp         r11, #0xFF
  000cc	0282303c	 addeq       r3, r2, #0x3C
  000d0	008a3083	 addeq       r3, r10, r3, lsl #1
  000d4	00853103	 addeq       r3, r5, r3, lsl #2
  000d8	01d330b0	 ldreqh      r3, [r3]
  000dc	01530007	 cmpeq       r3, r7

; 1496 :         {
; 1497 :             avail_EP = (UCHAR)i;

  000e0	020260ff	 andeq       r6, r2, #0xFF

; 1498 :             reuse_EP = (UCHAR)i;

  000e4	01a0b006	 moveq       r11, r6
  000e8	0a000002	 beq         |$LN7@AcquirePhy|

; 1499 :         }
; 1500 :         else if ((m_EndPoint[i][isOut].usDeviceInfo == 0xffff) && (avail_EP == 0xff))

  000ec	e151000e	 cmp         r1, lr
  000f0	035600ff	 cmpeq       r6, #0xFF

; 1501 :         {         
; 1502 :             avail_EP = (UCHAR)i;

  000f4	020260ff	 andeq       r6, r2, #0xFF
  000f8		 |$LN7@AcquirePhy|

; 1503 :         }  
; 1504 :         
; 1505 :         i++;

  000f8	e2822001	 add         r2, r2, #1

; 1506 :         if (i >= HOST_MAX_EPNUM)

  000fc	e3520010	 cmp         r2, #0x10

; 1507 :             i = 1;

  00100	a3a02001	 movge       r2, #1

; 1508 : 
; 1509 :         if (i == start)

  00104	e1520008	 cmp         r2, r8
  00108	0a000006	 beq         |$LN34@AcquirePhy|
  0010c	e08a3082	 add         r3, r10, r2, lsl #1
  00110	e0853103	 add         r3, r5, r3, lsl #2
  00114	e2833c01	 add         r3, r3, #1, 24
  00118	e1d31eb2	 ldrh        r1, [r3, #0xE2]
  0011c	e1510007	 cmp         r1, r7
  00120	1affffe6	 bne         |$LL13@AcquirePhy|
  00124		 |$LN33@AcquirePhy|

; 1490 :         {
; 1491 :             mappedEP = (UCHAR)i;

  00124	e20240ff	 and         r4, r2, #0xFF
  00128		 |$LN34@AcquirePhy|

; 1510 :             break;
; 1511 :     }
; 1512 :     
; 1513 :     if (mappedEP == 0xff)

  00128	e35400ff	 cmp         r4, #0xFF
  0012c	1a000012	 bne         |$LN1@AcquirePhy|

; 1514 :     {
; 1515 :         mappedEP = avail_EP;        

  00130	e1a04006	 mov         r4, r6

; 1516 :         if (avail_EP != 0xff)

  00134	e35600ff	 cmp         r6, #0xFF
  00138	0a00001a	 beq         |$LN3@AcquirePhy|

; 1517 :         {
; 1518 :             next_assigned_EP[isOut] = mappedEP;
; 1519 :             next_assigned_EP[isOut]++;

  0013c	e2863001	 add         r3, r6, #1

; 1520 :             if (next_assigned_EP[isOut] >= HOST_MAX_EPNUM)

  00140	e3530010	 cmp         r3, #0x10
  00144	e5803000	 str         r3, [r0]

; 1521 :                 next_assigned_EP[isOut] = 1;

  00148	a3a03001	 movge       r3, #1
  0014c	a5803000	 strge       r3, [r0]

; 1522 :             m_EndPoint[avail_EP][isOut].usDeviceInfo = deviceInfo;

  00150	e08a3086	 add         r3, r10, r6, lsl #1

; 1523 :             m_EndPoint[avail_EP][isOut].usPrevDevInfo = deviceInfo;

  00154	e286203c	 add         r2, r6, #0x3C
  00158	e0853103	 add         r3, r5, r3, lsl #2
  0015c	e08a2082	 add         r2, r10, r2, lsl #1
  00160	e2833c01	 add         r3, r3, #1, 24
  00164	e0852102	 add         r2, r5, r2, lsl #2
  00168	e1c37eb2	 strh        r7, [r3, #0xE2]
  0016c	e1c270b0	 strh        r7, [r2]

; 1524 :             m_EndPointInUseCount++;

  00170	e5953260	 ldr         r3, [r5, #0x260]
  00174	e2833001	 add         r3, r3, #1
  00178	e5853260	 str         r3, [r5, #0x260]
  0017c		 |$LN1@AcquirePhy|

; 1532 :         }
; 1533 : 
; 1534 :     }
; 1535 : 
; 1536 :     // Finally set the m_hEP2Handles 
; 1537 :     m_cBusyPipeList.m_hEP2Handles[mappedEP][isOut] = pPipe->GetEPTransferEvent();

  0017c	e599205c	 ldr         r2, [r9, #0x5C]
  00180	e08a3084	 add         r3, r10, r4, lsl #1
  00184	e0853103	 add         r3, r5, r3, lsl #2
  00188	e58320d4	 str         r2, [r3, #0xD4]

; 1538 :     pPipe->SetMappedEndPoint(mappedEP);
; 1539 : 
; 1540 :     LeaveCriticalSection(&m_csEndPoint);

  0018c	e2850f99	 add         r0, r5, #0x99, 30
  00190	e5c94058	 strb        r4, [r9, #0x58]
  00194	eb000000	 bl          LeaveCriticalSection

; 1541 :     DEBUGMSG(ZONE_HCD, (TEXT("AcquirePhysicalEP(ep[%d], device[%d]) (%s) value 0x%x, MEP %d\r\n"),
; 1542 :         endpoint, pPipe->GetReservedDeviceAddr(), isOut? TEXT("OUT"):TEXT("IN"), deviceInfo, mappedEP));
; 1543 :     return mappedEP;

  00198		 |$LN18@AcquirePhy|

; 1544 : }

  00198	e1a00004	 mov         r0, r4
  0019c	e28dd008	 add         sp, sp, #8
  001a0	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001a4	e12fff1e	 bx          lr
  001a8		 |$LN3@AcquirePhy|

; 1525 :             DEBUGMSG(ZONE_HCD, (TEXT("AcquirePhysicalEndPoint for EP 0x%x Device 0x%x -> Mapped %d [%s]\r\n"),
; 1526 :                 endptDesc.bEndpointAddress, pPipe->GetReservedDeviceAddr(), mappedEP, isOut?TEXT("OUT"):TEXT("IN")));
; 1527 :         }
; 1528 :         else
; 1529 :         {
; 1530 :             RETAILMSG(1, (TEXT("FAILED TO GET THE EP!!!\r\n")));

  001a8	e59f0008	 ldr         r0, [pc, #8]
  001ac	eb000000	 bl          NKDbgPrintfW

; 1531 :             return 0xff;

  001b0	e3a040ff	 mov         r4, #0xFF
  001b4	eafffff7	 b           |$LN18@AcquirePhy|
  001b8		 |$LN40@AcquirePhy|
  001b8		 |$LN41@AcquirePhy|
  001b8	00000000	 DCD         |??_C@_1DE@OFOMOBKP@?$AAF?$AAA?$AAI?$AAL?$AAE?$AAD?$AA?5?$AAT?$AAO?$AA?5?$AAG?$AAE?$AAT?$AA?5?$AAT?$AAH?$AAE?$AA?5?$AAE?$AAP?$AA?$CB?$AA?$CB?$AA?$CB?$AA?$AN?$AA?6?$AA?$AA@|
  001bc		 |$LN42@AcquirePhy|
  001bc	00000000	 DCD         |?next_assigned_EP@?1??AcquirePhysicalEndPoint@CHW@@QAAEPAVCPipe@@@Z@4PAHA|
  001c0		 |$M44767|

			 ENDP  ; |?AcquirePhysicalEndPoint@CHW@@QAAEPAVCPipe@@@Z|, CHW::AcquirePhysicalEndPoint

	EXPORT	|?ReleasePhysicalEndPoint@CHW@@QAAHPAVCPipe@@HH@Z| ; CHW::ReleasePhysicalEndPoint
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\cpipe.h

  00000			 AREA	 |.pdata|, PDATA
|$T44804| DCD	|$LN23@ReleasePhy|
	DCD	0x40007802
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ReleasePhysicalEndPoint@CHW@@QAAHPAVCPipe@@HH@Z| PROC ; CHW::ReleasePhysicalEndPoint

; 1554 : {

  00000		 |$LN23@ReleasePhy|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M44801|
  00008	e1a0a003	 mov         r10, r3
  0000c	e1a05002	 mov         r5, r2
  00010	e1a08001	 mov         r8, r1
  00014	e1a04000	 mov         r4, r0

; 1555 :     UCHAR mappedEP = pPipe->GetMappedEndPoint();
; 1556 :     USB_ENDPOINT_DESCRIPTOR endptDesc = pPipe->GetEndptDescriptor();

  00018	e5d87058	 ldrb        r7, [r8, #0x58]
  0001c	e28d0000	 add         r0, sp, #0
  00020	e2881034	 add         r1, r8, #0x34
  00024	e3a02007	 mov         r2, #7
  00028	eb000000	 bl          memcpy

; 1557 :     UCHAR isOut = USB_ENDPOINT_DIRECTION_OUT(endptDesc.bEndpointAddress)?1:0;

  0002c	e5dde002	 ldrb        lr, [sp, #2]
  00030	e31e0080	 tst         lr, #0x80
  00034	03a00001	 moveq       r0, #1
  00038	13a00000	 movne       r0, #0
  0003c	e20060ff	 and         r6, r0, #0xFF

; 1558 : 
; 1559 :     // Avoid Crash situation
; 1560 :     if ((mappedEP <= 0) || (mappedEP >= HOST_MAX_EPNUM))

  00040	e1b09007	 movs        r9, r7
  00044	0a000061	 beq         |$LN7@ReleasePhy|
  00048	e3590010	 cmp         r9, #0x10
  0004c	2a00005f	 bcs         |$LN7@ReleasePhy|

; 1562 :         
; 1563 :     EnterCriticalSection(&m_csEndPoint);

  00050	e2840f99	 add         r0, r4, #0x99, 30
  00054	eb000000	 bl          EnterCriticalSection

; 1564 : 
; 1565 :     // Currently release it only if it is very busy.    
; 1566 :     if ((m_EndPointInUseCount >= 1) || (fForce))

  00058	e5943260	 ldr         r3, [r4, #0x260]
  0005c	e3530001	 cmp         r3, #1
  00060	2a000001	 bcs         |$LN5@ReleasePhy|
  00064	e3550000	 cmp         r5, #0
  00068	0a000056	 beq         |$LN3@ReleasePhy|
  0006c		 |$LN5@ReleasePhy|

; 1567 :     {
; 1568 :         PHSMUSB_T pOTG;               
; 1569 :         pOTG = (PHSMUSB_T)GetOTGContext();
; 1570 : 
; 1571 :         m_EndPoint[mappedEP][isOut].usDeviceInfo = 0xffff;

  0006c	e0863087	 add         r3, r6, r7, lsl #1
  00070	e0841103	 add         r1, r4, r3, lsl #2
  00074	e3a02cff	 mov         r2, #0xFF, 24
  00078	e59450b0	 ldr         r5, [r4, #0xB0]
  0007c	e2813c01	 add         r3, r1, #1, 24
  00080	e38220ff	 orr         r2, r2, #0xFF

; 1572 :         if (fClearAll)

  00084	e35a0000	 cmp         r10, #0
  00088	e1c32eb2	 strh        r2, [r3, #0xE2]

; 1573 :             m_EndPoint[mappedEP][isOut].usPrevDevInfo = 0xffff;

  0008c	1287303c	 addne       r3, r7, #0x3C
  00090	10863083	 addne       r3, r6, r3, lsl #1
  00094	10843103	 addne       r3, r4, r3, lsl #2
  00098	11c320b0	 strneh      r2, [r3]

; 1574 :         m_EndPointInUseCount--;

  0009c	e5943260	 ldr         r3, [r4, #0x260]

; 1575 :         m_cBusyPipeList.m_hEP2Handles[mappedEP][isOut] = NULL;

  000a0	e3a02000	 mov         r2, #0

; 1576 :         pPipe->SetMappedEndPoint(0xff);

  000a4	e3a000ff	 mov         r0, #0xFF
  000a8	e2433001	 sub         r3, r3, #1
  000ac	e5843260	 str         r3, [r4, #0x260]
  000b0	e58120d4	 str         r2, [r1, #0xD4]
  000b4	e5c80058	 strb        r0, [r8, #0x58]

; 1577 :         if (pOTG != NULL)

  000b8	e3550000	 cmp         r5, #0
  000bc	0a000041	 beq         |$LN3@ReleasePhy|

; 1578 :         {
; 1579 :             EnterCriticalSection(&pOTG->regCS); 

  000c0	e2850038	 add         r0, r5, #0x38
  000c4	eb000000	 bl          EnterCriticalSection

; 1580 :             OUTREG8(&pOTG->pUsbGenRegs->Index, USB_ENDPOINT(mappedEP));

  000c8	e5953020	 ldr         r3, [r5, #0x20]
  000cc	e209e00f	 and         lr, r9, #0xF

; 1581 :             // Flush the endpoint
; 1582 :             if (isOut)

  000d0	e3560000	 cmp         r6, #0
  000d4	e5c3e00e	 strb        lr, [r3, #0xE]

; 1583 :             {
; 1584 :                 SETREG16(&pOTG->pUsbCsrRegs->ep[USB_ENDPOINT(mappedEP)].CSR.TxCSR, TXCSR_H_FlushFIFO);

  000d8	e595301c	 ldr         r3, [r5, #0x1C]
  000dc	e083120e	 add         r1, r3, lr, lsl #4
  000e0	0a00001b	 beq         |$LN2@ReleasePhy|
  000e4	e5d12002	 ldrb        r2, [r1, #2]
  000e8	e5d13003	 ldrb        r3, [r1, #3]
  000ec	e3a00c47	 mov         r0, #0x47, 24

; 1585 :                 SETREG16(&pOTG->pUsbCsrRegs->ep[USB_ENDPOINT(mappedEP)].CSR.TxCSR, TXCSR_H_FlushFIFO);
; 1586 : 
; 1587 :                 DWORD txcsr = (TXCSR_H_AutoSet|TXCSR_H_DMAReqEn|TXCSR_H_FrcDataTog|TXCSR_H_Mode);
; 1588 :                 CLRREG16(&pOTG->pUsbCsrRegs->ep[USB_ENDPOINT(mappedEP)].CSR.TxCSR, txcsr);

  000f0	e38000ff	 orr         r0, r0, #0xFF
  000f4	e1823403	 orr         r3, r2, r3, lsl #8
  000f8	e3833008	 orr         r3, r3, #8
  000fc	e1a02423	 mov         r2, r3, lsr #8
  00100	e5c13002	 strb        r3, [r1, #2]
  00104	e5c12003	 strb        r2, [r1, #3]
  00108	e595301c	 ldr         r3, [r5, #0x1C]
  0010c	e083120e	 add         r1, r3, lr, lsl #4
  00110	e5d12002	 ldrb        r2, [r1, #2]
  00114	e5d13003	 ldrb        r3, [r1, #3]
  00118	e1823403	 orr         r3, r2, r3, lsl #8
  0011c	e3833008	 orr         r3, r3, #8
  00120	e1a02423	 mov         r2, r3, lsr #8
  00124	e5c13002	 strb        r3, [r1, #2]
  00128	e5c12003	 strb        r2, [r1, #3]
  0012c	e595301c	 ldr         r3, [r5, #0x1C]
  00130	e083120e	 add         r1, r3, lr, lsl #4
  00134	e5d12002	 ldrb        r2, [r1, #2]
  00138	e5d13003	 ldrb        r3, [r1, #3]
  0013c	e1823403	 orr         r3, r2, r3, lsl #8
  00140	e0033000	 and         r3, r3, r0
  00144	e1a02423	 mov         r2, r3, lsr #8
  00148	e5c13002	 strb        r3, [r1, #2]
  0014c	e5c12003	 strb        r2, [r1, #3]

; 1589 : 
; 1590 :             }
; 1591 :             else

  00150	ea00001a	 b           |$LN1@ReleasePhy|
  00154		 |$LN2@ReleasePhy|

; 1592 :             {
; 1593 :                 SETREG16(&pOTG->pUsbCsrRegs->ep[USB_ENDPOINT(mappedEP)].RxCSR, RXCSR_H_FlushFIFO);            

  00154	e5d12006	 ldrb        r2, [r1, #6]
  00158	e5d13007	 ldrb        r3, [r1, #7]
  0015c	e3a00c1f	 mov         r0, #0x1F, 24

; 1594 :                 SETREG16(&pOTG->pUsbCsrRegs->ep[USB_ENDPOINT(mappedEP)].RxCSR, RXCSR_H_FlushFIFO);            
; 1595 : 
; 1596 :                 DWORD rxcsr = (RXCSR_H_AutoClr|RXCSR_H_AutoReq|RXCSR_H_DMAReqEn);
; 1597 :                 CLRREG16(&pOTG->pUsbCsrRegs->ep[USB_ENDPOINT(mappedEP)].RxCSR, rxcsr);

  00160	e38000ff	 orr         r0, r0, #0xFF
  00164	e1823403	 orr         r3, r2, r3, lsl #8
  00168	e3833010	 orr         r3, r3, #0x10
  0016c	e1a02423	 mov         r2, r3, lsr #8
  00170	e5c13006	 strb        r3, [r1, #6]
  00174	e5c12007	 strb        r2, [r1, #7]
  00178	e595301c	 ldr         r3, [r5, #0x1C]
  0017c	e083120e	 add         r1, r3, lr, lsl #4
  00180	e5d12006	 ldrb        r2, [r1, #6]
  00184	e5d13007	 ldrb        r3, [r1, #7]
  00188	e1823403	 orr         r3, r2, r3, lsl #8
  0018c	e3833010	 orr         r3, r3, #0x10
  00190	e1a02423	 mov         r2, r3, lsr #8
  00194	e5c13006	 strb        r3, [r1, #6]
  00198	e5c12007	 strb        r2, [r1, #7]
  0019c	e595301c	 ldr         r3, [r5, #0x1C]
  001a0	e083120e	 add         r1, r3, lr, lsl #4
  001a4	e5d12006	 ldrb        r2, [r1, #6]
  001a8	e5d13007	 ldrb        r3, [r1, #7]
  001ac	e1823403	 orr         r3, r2, r3, lsl #8
  001b0	e0033000	 and         r3, r3, r0
  001b4	e1a02423	 mov         r2, r3, lsr #8
  001b8	e5c13006	 strb        r3, [r1, #6]
  001bc	e5c12007	 strb        r2, [r1, #7]
  001c0		 |$LN1@ReleasePhy|

; 1598 :             }
; 1599 :             LeaveCriticalSection(&pOTG->regCS); 

  001c0	e2850038	 add         r0, r5, #0x38
  001c4	eb000000	 bl          LeaveCriticalSection
  001c8		 |$LN3@ReleasePhy|

; 1600 :         }
; 1601 : 
; 1602 :             DEBUGMSG(ZONE_DEBUG, (TEXT("ReleasePhysicalEndPoint for EP 0x%x Device 0x%x -> Mapped %d [%s]\r\n"),
; 1603 :             endptDesc.bEndpointAddress, pPipe->GetReservedDeviceAddr(), mappedEP, isOut?TEXT("OUT"):TEXT("IN")));
; 1604 :     }
; 1605 : 
; 1606 :     LeaveCriticalSection(&m_csEndPoint);

  001c8	e2840f99	 add         r0, r4, #0x99, 30
  001cc	eb000000	 bl          LeaveCriticalSection
  001d0		 |$LN7@ReleasePhy|

; 1561 :         return TRUE;

  001d0	e3a00001	 mov         r0, #1

; 1607 :     return TRUE;
; 1608 : }

  001d4	e28dd008	 add         sp, sp, #8
  001d8	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  001dc	e12fff1e	 bx          lr
  001e0		 |$M44802|

			 ENDP  ; |?ReleasePhysicalEndPoint@CHW@@QAAHPAVCPipe@@HH@Z|, CHW::ReleasePhysicalEndPoint

	EXPORT	|?GetCurrentToggleBit@CHW@@QAAEEE@Z|	; CHW::GetCurrentToggleBit
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T44824| DCD	|$LN12@GetCurrent|
	DCD	0x40001600
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetCurrentToggleBit@CHW@@QAAEEE@Z| PROC ; CHW::GetCurrentToggleBit

; 1617 : {

  00000		 |$LN12@GetCurrent|
  00000		 |$M44821|

; 1618 :     DWORD DataToggle;
; 1619 :     PHSMUSB_T pOTG;        
; 1620 : 
; 1621 :     pOTG = (PHSMUSB_T)GetOTGContext();

  00000	e59030b0	 ldr         r3, [r0, #0xB0]
  00004	e3530000	 cmp         r3, #0

; 1622 :     if (pOTG == NULL)
; 1623 :     {
; 1624 :         DEBUGMSG(ZONE_ERROR, (TEXT("CHW::GetCurrentToggleBit failed\r\n")));
; 1625 :         return 0xff;

  00008	03a000ff	 moveq       r0, #0xFF

; 1642 : }

  0000c	012fff1e	 bxeq        lr

; 1626 :     }  
; 1627 : 
; 1628 :     if (isIn)

  00010	e3520000	 cmp         r2, #0

; 1629 :     {
; 1630 :         DataToggle = (INREG16(&pOTG->pUsbCsrRegs->ep[USB_ENDPOINT(mappedEP)].RxCSR) & RXCSR_H_DataToggle);

  00014	e593201c	 ldr         r2, [r3, #0x1C]
  00018	e201300f	 and         r3, r1, #0xF
  0001c	e0823203	 add         r3, r2, r3, lsl #4
  00020	15d32006	 ldrneb      r2, [r3, #6]
  00024	15d33007	 ldrneb      r3, [r3, #7]
  00028	11823403	 orrne       r3, r2, r3, lsl #8
  0002c	12033c02	 andne       r3, r3, #2, 24

; 1631 :     }
; 1632 :     else
; 1633 :     {
; 1634 :         DataToggle = (INREG16(&pOTG->pUsbCsrRegs->ep[USB_ENDPOINT(mappedEP)].CSR.TxCSR) & TXCSR_H_DataToggle);

  00030	05d32002	 ldreqb      r2, [r3, #2]
  00034	05d33003	 ldreqb      r3, [r3, #3]
  00038	01823403	 orreq       r3, r2, r3, lsl #8
  0003c	02033c01	 andeq       r3, r3, #1, 24

; 1635 : 
; 1636 :     }
; 1637 : 
; 1638 :     DEBUGMSG(ZONE_DEBUG, (TEXT("GetCurrentToggle bit for mapped EP %d (%s) = DataToggle (0x%x)\r\n"),
; 1639 :         USB_ENDPOINT(mappedEP), isIn? TEXT("IN"):TEXT("OUT"), DataToggle));
; 1640 : 
; 1641 :     return ((DataToggle != 0)? 1: 0);

  00040	e3530000	 cmp         r3, #0
  00044	13a03001	 movne       r3, #1
  00048	120300ff	 andne       r0, r3, #0xFF
  0004c	03a03000	 moveq       r3, #0
  00050	020300ff	 andeq       r0, r3, #0xFF

; 1642 : }

  00054	e12fff1e	 bx          lr
  00058		 |$M44822|

			 ENDP  ; |?GetCurrentToggleBit@CHW@@QAAEEE@Z|, CHW::GetCurrentToggleBit

	EXPORT	|?SignalHubChangeEvent@CHW@@UAAHH@Z|	; CHW::SignalHubChangeEvent
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T44844| DCD	|$LN12@SignalHubC|
	DCD	0x40000901
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SignalHubChangeEvent@CHW@@UAAHH@Z| PROC ; CHW::SignalHubChangeEvent

; 1649 : {

  00000		 |$LN12@SignalHubC|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44841|
  00004	e3510000	 cmp         r1, #0

; 1650 :     if (fConnect)
; 1651 :         SetEvent(m_hUsbHubConnectEvent); 

  00008	159001a8	 ldrne       r0, [r0, #0x1A8]
  0000c	e3a01003	 mov         r1, #3

; 1652 :     else
; 1653 :         SetEvent(m_hUsbHubDisconnectEvent);

  00010	059001ac	 ldreq       r0, [r0, #0x1AC]
  00014	eb000000	 bl          EventModify

; 1654 :     return TRUE;

  00018	e3a00001	 mov         r0, #1

; 1655 : };

  0001c	e49de004	 ldr         lr, [sp], #4
  00020	e12fff1e	 bx          lr
  00024		 |$M44842|

			 ENDP  ; |?SignalHubChangeEvent@CHW@@UAAHH@Z|, CHW::SignalHubChangeEvent

	EXPORT	|?SuspendHostController@CHW@@AAAXXZ|	; CHW::SuspendHostController

  00000			 AREA	 |.pdata|, PDATA
|$T44851| DCD	|$LN5@SuspendHos|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SuspendHostController@CHW@@AAAXXZ| PROC ; CHW::SuspendHostController

; 1702 : {

  00000		 |$LN5@SuspendHos|
  00000		 |$M44848|

; 1703 :     DEBUGMSG(ZONE_DEBUG, (TEXT("+CHW::SuspendHostController\r\n")));
; 1704 :     // Clock must have started already.
; 1705 :     // Procedure to do:
; 1706 :     // (1) Set the Suspend Bit on the Power D0
; 1707 :     // (2) Stop the USB Clock 
; 1708 : #if 0
; 1709 :     PHSMUSB_T pOTG;        
; 1710 : 
; 1711 :     pOTG = (PHSMUSB_T)GetOTGContext();
; 1712 :     if (pOTG == NULL)
; 1713 :     {
; 1714 :         DEBUGMSG(ZONE_ERROR, (TEXT("CHW::SuspendHostController failed\r\n")));
; 1715 :         return;
; 1716 :     }  
; 1717 : 
; 1718 :     //pOTG->dwPwrMgmt = MODE_SYSTEM_SUSPEND;
; 1719 :     // Clear the DEVCTL_SESSION at this point
; 1720 :     // This is to avoid the activation of HNP during suspend which does not suppose to do.    
; 1721 :     //CLRREG8(&pOTG->pUsbGenRegs->DevCtl, DEVCTL_SESSION);
; 1722 :     //SETREG8(&pOTG->pUsbGenRegs->Power, POWER_SUSPENDM);
; 1723 : 
; 1724 :     //Keep the transceiver on during system suspend and when a USB device is attached
; 1725 :     //SETREG8(&pOTG->pUsbGenRegs->Power, POWER_EN_SUSPENDM);
; 1726 : #endif
; 1727 :     DEBUGMSG(ZONE_DEBUG, (TEXT("-CHW::SuspendHostController\r\n")));
; 1728 : }

  00000	e12fff1e	 bx          lr
  00004		 |$M44849|

			 ENDP  ; |?SuspendHostController@CHW@@AAAXXZ|, CHW::SuspendHostController

	EXPORT	|?ResumeHostController@CHW@@AAAXXZ|	; CHW::ResumeHostController

  00000			 AREA	 |.pdata|, PDATA
|$T44858| DCD	|$LN5@ResumeHost|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResumeHostController@CHW@@AAAXXZ| PROC ; CHW::ResumeHostController

; 1731 : {

  00000		 |$LN5@ResumeHost|
  00000		 |$M44855|

; 1732 : #if 0
; 1733 :     PHSMUSB_T pOTG;        
; 1734 : 
; 1735 :     pOTG = (PHSMUSB_T)GetOTGContext();
; 1736 :     if (pOTG == NULL)
; 1737 :     {
; 1738 :         DEBUGMSG(ZONE_ERROR, (TEXT("CHW::ResumeHostController failed\r\n")));
; 1739 :         return;
; 1740 :     }  
; 1741 : 
; 1742 :     DEBUGMSG(ZONE_DEBUG, (TEXT("CHW::ResumeHostController\r\n")));
; 1743 :     pOTG->dwPwrMgmt = MODE_SYSTEM_RESUME;
; 1744 :     SETREG8(&pOTG->pUsbGenRegs->Power, POWER_RESUME);
; 1745 : #endif
; 1746 : }

  00000	e12fff1e	 bx          lr
  00004		 |$M44856|

			 ENDP  ; |?ResumeHostController@CHW@@AAAXXZ|, CHW::ResumeHostController

	EXPORT	|?SetDeviceAddress@CHW@@UAAXEEEEE@Z|	; CHW::SetDeviceAddress
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T44875| DCD	|$LN11@SetDeviceA|
	DCD	0x40003701
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetDeviceAddress@CHW@@UAAXEEEEE@Z| PROC ; CHW::SetDeviceAddress

; 1756 : {

  00000		 |$LN11@SetDeviceA|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M44872|
  00004	e1a06003	 mov         r6, r3
  00008	e1a05002	 mov         r5, r2

; 1757 :     PHSMUSB_T pOTG;
; 1758 :     pOTG = (PHSMUSB_T)GetOTGContext();    

  0000c	e59040b0	 ldr         r4, [r0, #0xB0]

; 1759 : 
; 1760 :     OUTREG8(&pOTG->pUsbGenRegs->Index, USB_ENDPOINT(mappedEP));

  00010	e201e00f	 and         lr, r1, #0xF
  00014	e1b0000e	 movs        r0, lr
  00018	e5941020	 ldr         r1, [r4, #0x20]
  0001c	e5c1000e	 strb        r0, [r1, #0xE]

; 1761 :     //OUTREG8(&pOTG->pUsbGenRegs->FAddr, ucAddress);
; 1762 : 
; 1763 :     DEBUGMSG(ZONE_HCD, (TEXT("SetDeviceAddress DevAddr 0x%x, HubAddress 0x%x, HubPort 0x%x\r\n"),
; 1764 :         ucDevAddress, ucHubAddress, ucHubPort));
; 1765 : 
; 1766 :     if (USB_ENDPOINT(mappedEP) == 0)

  00020	1a00000f	 bne         |$LN4@SetDeviceA|

; 1767 :     {
; 1768 :         OUTREG8(&pOTG->pUsbGenRegs->ep[0].TxFuncAddr, ucDevAddress);

  00024	e5941020	 ldr         r1, [r4, #0x20]

; 1769 :         OUTREG8(&pOTG->pUsbGenRegs->ep[0].RxFuncAddr, ucDevAddress);
; 1770 : 
; 1771 :         OUTREG8(&pOTG->pUsbGenRegs->ep[0].TxHubAddr, 0x80|ucHubAddress);

  00028	e3860080	 orr         r0, r6, #0x80

; 1772 :         OUTREG8(&pOTG->pUsbGenRegs->ep[0].RxHubAddr, 0x80|ucHubAddress);
; 1773 : 
; 1774 :         OUTREG8(&pOTG->pUsbGenRegs->ep[0].TxHubPort, ucHubPort);

  0002c	e5dde010	 ldrb        lr, [sp, #0x10]
  00030	e5c15080	 strb        r5, [r1, #0x80]
  00034	e5943020	 ldr         r3, [r4, #0x20]
  00038	e5c35084	 strb        r5, [r3, #0x84]
  0003c	e5943020	 ldr         r3, [r4, #0x20]
  00040	e5c30082	 strb        r0, [r3, #0x82]
  00044	e5943020	 ldr         r3, [r4, #0x20]
  00048	e5c30086	 strb        r0, [r3, #0x86]
  0004c	e5943020	 ldr         r3, [r4, #0x20]
  00050	e5c3e083	 strb        lr, [r3, #0x83]

; 1775 :         OUTREG8(&pOTG->pUsbGenRegs->ep[0].RxHubPort, ucHubPort);

  00054	e5943020	 ldr         r3, [r4, #0x20]
  00058	e5c3e087	 strb        lr, [r3, #0x87]

; 1792 : 
; 1793 :         }
; 1794 :     }
; 1795 :     DEBUGMSG(ZONE_HCD, (TEXT("CHW::SetDeviceAddress(ep(0x%x), dev addr(0x%x), hub addr(0x%x), port (0x%x)), index(0x%x)\r\n"), mappedEP, ucDevAddress, ucHubAddress, ucHubPort, INDEX(mappedEP)));
; 1796 : }

  0005c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$LN4@SetDeviceA|

; 1776 : 
; 1777 : 
; 1778 :     }
; 1779 :     else 
; 1780 :     {
; 1781 :         if (outdir) // OUT

  00064	e5dd3014	 ldrb        r3, [sp, #0x14]
  00068	e3530000	 cmp         r3, #0
  0006c	0a00000d	 beq         |$LN2@SetDeviceA|

; 1782 :         {
; 1783 :             OUTREG8(&pOTG->pUsbGenRegs->ep[INDEX(mappedEP)].TxFuncAddr, ucDevAddress);

  00070	e5942020	 ldr         r2, [r4, #0x20]
  00074	e28e3010	 add         r3, lr, #0x10

; 1784 :             OUTREG8(&pOTG->pUsbGenRegs->ep[INDEX(mappedEP)].TxHubAddr, 0x80|ucHubAddress);
; 1785 :             OUTREG8(&pOTG->pUsbGenRegs->ep[INDEX(mappedEP)].TxHubPort, ucHubPort);

  00078	e5dd1010	 ldrb        r1, [sp, #0x10]
  0007c	e0823183	 add         r3, r2, r3, lsl #3
  00080	e5c35000	 strb        r5, [r3]
  00084	e5943020	 ldr         r3, [r4, #0x20]
  00088	e3862080	 orr         r2, r6, #0x80
  0008c	e083318e	 add         r3, r3, lr, lsl #3
  00090	e5c32082	 strb        r2, [r3, #0x82]
  00094	e5943020	 ldr         r3, [r4, #0x20]
  00098	e083318e	 add         r3, r3, lr, lsl #3
  0009c	e5c31083	 strb        r1, [r3, #0x83]

; 1792 : 
; 1793 :         }
; 1794 :     }
; 1795 :     DEBUGMSG(ZONE_HCD, (TEXT("CHW::SetDeviceAddress(ep(0x%x), dev addr(0x%x), hub addr(0x%x), port (0x%x)), index(0x%x)\r\n"), mappedEP, ucDevAddress, ucHubAddress, ucHubPort, INDEX(mappedEP)));
; 1796 : }

  000a0	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000a4	e12fff1e	 bx          lr
  000a8		 |$LN2@SetDeviceA|

; 1786 :         }
; 1787 :         else
; 1788 :         {
; 1789 :             OUTREG8(&pOTG->pUsbGenRegs->ep[INDEX(mappedEP)].RxFuncAddr, ucDevAddress);

  000a8	e5943020	 ldr         r3, [r4, #0x20]

; 1790 :             OUTREG8(&pOTG->pUsbGenRegs->ep[INDEX(mappedEP)].RxHubAddr, 0x80|ucHubAddress);

  000ac	e3861080	 orr         r1, r6, #0x80

; 1791 :             OUTREG8(&pOTG->pUsbGenRegs->ep[INDEX(mappedEP)].RxHubPort, ucHubPort);

  000b0	e5dd2010	 ldrb        r2, [sp, #0x10]
  000b4	e083318e	 add         r3, r3, lr, lsl #3
  000b8	e5c35084	 strb        r5, [r3, #0x84]
  000bc	e5943020	 ldr         r3, [r4, #0x20]
  000c0	e083318e	 add         r3, r3, lr, lsl #3
  000c4	e5c31086	 strb        r1, [r3, #0x86]
  000c8	e5943020	 ldr         r3, [r4, #0x20]
  000cc	e083318e	 add         r3, r3, lr, lsl #3
  000d0	e5c32087	 strb        r2, [r3, #0x87]

; 1792 : 
; 1793 :         }
; 1794 :     }
; 1795 :     DEBUGMSG(ZONE_HCD, (TEXT("CHW::SetDeviceAddress(ep(0x%x), dev addr(0x%x), hub addr(0x%x), port (0x%x)), index(0x%x)\r\n"), mappedEP, ucDevAddress, ucHubAddress, ucHubPort, INDEX(mappedEP)));
; 1796 : }

  000d4	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000d8	e12fff1e	 bx          lr
  000dc		 |$M44873|

			 ENDP  ; |?SetDeviceAddress@CHW@@UAAXEEEEE@Z|, CHW::SetDeviceAddress

	EXPORT	|?IsDMASupport@CHW@@UAAHXZ|		; CHW::IsDMASupport
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T44890| DCD	|$LN8@IsDMASuppo|
	DCD	0x40000600
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsDMASupport@CHW@@UAAHXZ| PROC	; CHW::IsDMASupport

; 1798 : {

  00000		 |$LN8@IsDMASuppo|
  00000		 |$M44887|

; 1799 :     PHSMUSB_T pOTG;        
; 1800 :     pOTG = (PHSMUSB_T)GetOTGContext();

  00000	e59030b0	 ldr         r3, [r0, #0xB0]
  00004	e3530000	 cmp         r3, #0

; 1801 :     if (pOTG == NULL)
; 1802 :     {
; 1803 :         DEBUGMSG(ZONE_ERROR, (TEXT("CHW::IsDMASupport failed\r\n")));
; 1804 :         return FALSE;

  00008	03a00000	 moveq       r0, #0

; 1805 :     }
; 1806 : 
; 1807 :     SMHCDPdd * pPdd = (SMHCDPdd *)pOTG->pContext[HOST_MODE-1];

  0000c	15933014	 ldrne       r3, [r3, #0x14]

; 1808 : 
; 1809 :     return (pPdd->bDMASupport);

  00010	15930250	 ldrne       r0, [r3, #0x250]

; 1810 : }

  00014	e12fff1e	 bx          lr
  00018		 |$M44888|

			 ENDP  ; |?IsDMASupport@CHW@@UAAHXZ|, CHW::IsDMASupport

	EXPORT	|?GetDMAMode@CHW@@UAAKXZ|		; CHW::GetDMAMode
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T44905| DCD	|$LN8@GetDMAMode|
	DCD	0x40000600
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetDMAMode@CHW@@UAAKXZ| PROC		; CHW::GetDMAMode

; 1813 : {

  00000		 |$LN8@GetDMAMode|
  00000		 |$M44902|

; 1814 :     PHSMUSB_T pOTG;        
; 1815 :     pOTG = (PHSMUSB_T)GetOTGContext();

  00000	e59030b0	 ldr         r3, [r0, #0xB0]
  00004	e3530000	 cmp         r3, #0

; 1816 :     if (pOTG == NULL)
; 1817 :     {
; 1818 :         DEBUGMSG(ZONE_ERROR, (TEXT("CHW::GetDMAMode failed\r\n")));
; 1819 :         return FALSE;

  00008	03a00000	 moveq       r0, #0

; 1820 :     }
; 1821 : 
; 1822 :     SMHCDPdd * pPdd = (SMHCDPdd *)pOTG->pContext[HOST_MODE-1];

  0000c	15933014	 ldrne       r3, [r3, #0x14]

; 1823 : 
; 1824 :     return (pPdd->dwDMAMode);

  00010	15930254	 ldrne       r0, [r3, #0x254]

; 1825 : }

  00014	e12fff1e	 bx          lr
  00018		 |$M44903|

			 ENDP  ; |?GetDMAMode@CHW@@UAAKXZ|, CHW::GetDMAMode

	EXPORT	|?IsHostConnect@CHW@@UAAHXZ|		; CHW::IsHostConnect
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T44921| DCD	|$LN9@IsHostConn|
	DCD	0x40000b00
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsHostConnect@CHW@@UAAHXZ| PROC	; CHW::IsHostConnect

; 1834 : {

  00000		 |$LN9@IsHostConn|
  00000		 |$M44918|

; 1835 :     PHSMUSB_T pOTG;    
; 1836 :     pOTG = (PHSMUSB_T)GetOTGContext();

  00000	e59030b0	 ldr         r3, [r0, #0xB0]
  00004	e3530000	 cmp         r3, #0

; 1837 :     if (pOTG == NULL)
; 1838 :     {
; 1839 :         DEBUGMSG(ZONE_HCD, (TEXT("CHW::IsHostConnect failed\r\n")));
; 1840 :         return FALSE;

  00008	0a000005	 beq         |$LN1@IsHostConn|

; 1841 :     }
; 1842 : 
; 1843 :     UCHAR devctl = INREG8(&pOTG->pUsbGenRegs->DevCtl);

  0000c	e5933020	 ldr         r3, [r3, #0x20]
  00010	e5d33060	 ldrb        r3, [r3, #0x60]

; 1844 :     if ((devctl & DEVCTL_SESSION) && (devctl & DEVCTL_HOSTMODE))

  00014	e3130001	 tst         r3, #1
  00018	13130004	 tstne       r3, #4

; 1845 :     {
; 1846 :         DEBUGMSG(ZONE_HCD, (TEXT("IsHostConnect return TRUE\r\n")));
; 1847 :         return TRUE;

  0001c	13a00001	 movne       r0, #1

; 1853 : }

  00020	112fff1e	 bxne        lr
  00024		 |$LN1@IsHostConn|

; 1848 :     }
; 1849 : 
; 1850 :     DEBUGMSG(ZONE_DEBUG, (TEXT("IsHostConnect return devctl = 0x%x\r\n"), devctl));
; 1851 :     DEBUGMSG(ZONE_HCD, (TEXT("IsHostConnect return FALSE\r\n")));
; 1852 :     return FALSE;

  00024	e3a00000	 mov         r0, #0

; 1853 : }

  00028	e12fff1e	 bx          lr
  0002c		 |$M44919|

			 ENDP  ; |?IsHostConnect@CHW@@UAAHXZ|, CHW::IsHostConnect

	EXPORT	|?GetRxCount@CHW@@QAAKPAXE@Z|		; CHW::GetRxCount

  00000			 AREA	 |.pdata|, PDATA
|$T44934| DCD	|$LN8@GetRxCount|
	DCD	0x40001501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetRxCount@CHW@@QAAKPAXE@Z| PROC	; CHW::GetRxCount

; 1857 : {

  00000		 |$LN8@GetRxCount|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44931|
  00004	e1b05001	 movs        r5, r1

; 1858 :     PHSMUSB_T pOTG = (PHSMUSB_T)(pContext);
; 1859 :     UCHAR csrIndex = INDEX(endpoint);

  00008	e202400f	 and         r4, r2, #0xF

; 1860 :     DWORD dwCount;
; 1861 :     DEBUGMSG(ZONE_HCD, (TEXT("GetRxCount for endpoint %d\r\n"), endpoint));
; 1862 :     if (pOTG == NULL)
; 1863 :     {
; 1864 :         DEBUGMSG(ZONE_ERROR, (TEXT("Failure to restore configure\r\n")));
; 1865 :         return 0;

  0000c	03a04000	 moveq       r4, #0
  00010	0a00000c	 beq         |$LN4@GetRxCount|

; 1866 :     }
; 1867 : 
; 1868 :     // Set the Index Register
; 1869 :     EnterCriticalSection(&pOTG->regCS); 

  00014	e2850038	 add         r0, r5, #0x38
  00018	eb000000	 bl          EnterCriticalSection

; 1870 :     OUTREG8(&pOTG->pUsbGenRegs->Index, csrIndex);

  0001c	e5953020	 ldr         r3, [r5, #0x20]

; 1871 :     if (USB_ENDPOINT(endpoint) != 0)

  00020	e3540000	 cmp         r4, #0

; 1872 :         dwCount = INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].Count.RxCount);
; 1873 :     else
; 1874 :         dwCount = INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].Count.Count0);
; 1875 :     
; 1876 :     LeaveCriticalSection(&pOTG->regCS);    

  00024	e2850038	 add         r0, r5, #0x38
  00028	e5c3400e	 strb        r4, [r3, #0xE]
  0002c	e595301c	 ldr         r3, [r5, #0x1C]
  00030	e0833204	 add         r3, r3, r4, lsl #4
  00034	15d32008	 ldrneb      r2, [r3, #8]
  00038	15d33009	 ldrneb      r3, [r3, #9]
  0003c	11824403	 orrne       r4, r2, r3, lsl #8
  00040	01d340b8	 ldreqh      r4, [r3, #8]
  00044	eb000000	 bl          LeaveCriticalSection

; 1877 :     return dwCount;

  00048		 |$LN4@GetRxCount|

; 1878 : }

  00048	e1a00004	 mov         r0, r4
  0004c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$M44932|

			 ENDP  ; |?GetRxCount@CHW@@QAAKPAXE@Z|, CHW::GetRxCount

	EXPORT	|?CheckDMAResult@CHW@@QAAKPAXE@Z|	; CHW::CheckDMAResult
	EXPORT	|??_C@_1DA@MKPOBGHE@?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAN?$AAo?$AAt?$AA?5?$AAR?$AAe?$AAs?$AAp?$AAo?$AAn?$AAd?$AAi?$AAn?$AAg?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T44949| DCD	|$LN9@CheckDMARe|
	DCD	0x40001101

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DA@MKPOBGHE@?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAN?$AAo?$AAt?$AA?5?$AAR?$AAe?$AAs?$AAp?$AAo?$AAn?$AAd?$AAi?$AAn?$AAg?$AA?$AN?$AA?6?$AA?$AA@| DCB "D"
	DCB	0x0, "e", 0x0, "v", 0x0, "i", 0x0, "c", 0x0, "e", 0x0, " "
	DCB	0x0, "N", 0x0, "o", 0x0, "t", 0x0, " ", 0x0, "R", 0x0, "e"
	DCB	0x0, "s", 0x0, "p", 0x0, "o", 0x0, "n", 0x0, "d", 0x0, "i"
	DCB	0x0, "n", 0x0, "g", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CheckDMAResult@CHW@@QAAKPAXE@Z| PROC	; CHW::CheckDMAResult

; 1884 : {

  00000		 |$LN9@CheckDMARe|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44946|
  00004	e3510000	 cmp         r1, #0

; 1885 :     PHSMUSB_T pOTG = (PHSMUSB_T)(pContext);
; 1886 :     DWORD dmacntl;
; 1887 :     DWORD dwError = USB_NO_ERROR;

  00008	e3a00000	 mov         r0, #0

; 1888 :     DEBUGMSG(ZONE_HCD, (TEXT("+CheckDMAResult for channel %d\r\n"), channel));
; 1889 :     if (pOTG == NULL)
; 1890 :     {
; 1891 :         DEBUGMSG(ZONE_ERROR, (TEXT("Failure to restore configure\r\n")));
; 1892 :         return FALSE;

  0000c	03a00000	 moveq       r0, #0

; 1900 :     }
; 1901 : 
; 1902 :     return dwError;
; 1903 : }

  00010	049de004	 ldreq       lr, [sp], #4
  00014	012fff1e	 bxeq        lr

; 1893 :     }
; 1894 :     dmacntl = INREG32(&pOTG->pUsbDmaRegs->dma[channel].Cntl);

  00018	e5913024	 ldr         r3, [r1, #0x24]
  0001c	e0833202	 add         r3, r3, r2, lsl #4
  00020	e5933004	 ldr         r3, [r3, #4]

; 1895 : 
; 1896 :     if (dmacntl & DMA_CNTL_BusError)

  00024	e3130c01	 tst         r3, #1, 24
  00028	0a000002	 beq         |$LN1@CheckDMARe|

; 1897 :     {
; 1898 :         RETAILMSG(1, (TEXT("Device Not Responding\r\n")));

  0002c	e59f000c	 ldr         r0, [pc, #0xC]
  00030	eb000000	 bl          NKDbgPrintfW

; 1899 :         dwError = USB_DEVICE_NOT_RESPONDING_ERROR;

  00034	e3a00005	 mov         r0, #5
  00038		 |$LN1@CheckDMARe|

; 1900 :     }
; 1901 : 
; 1902 :     return dwError;
; 1903 : }

  00038	e49de004	 ldr         lr, [sp], #4
  0003c	e12fff1e	 bx          lr
  00040		 |$LN10@CheckDMARe|
  00040		 |$LN11@CheckDMARe|
  00040	00000000	 DCD         |??_C@_1DA@MKPOBGHE@?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAN?$AAo?$AAt?$AA?5?$AAR?$AAe?$AAs?$AAp?$AAo?$AAn?$AAd?$AAi?$AAn?$AAg?$AA?$AN?$AA?6?$AA?$AA@|
  00044		 |$M44947|

			 ENDP  ; |?CheckDMAResult@CHW@@QAAKPAXE@Z|, CHW::CheckDMAResult

	EXPORT	|?RestoreRxConfig@CHW@@QAAHPAXE@Z|	; CHW::RestoreRxConfig

  00000			 AREA	 |.pdata|, PDATA
|$T44963| DCD	|$LN6@RestoreRxC|
	DCD	0x40001a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?RestoreRxConfig@CHW@@QAAHPAXE@Z| PROC ; CHW::RestoreRxConfig

; 1910 : {

  00000		 |$LN6@RestoreRxC|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44960|
  00004	e1b04001	 movs        r4, r1

; 1911 :     PHSMUSB_T pOTG = (PHSMUSB_T)(pContext);
; 1912 :     USHORT rxcsr = 0;
; 1913 :     UCHAR csrIndex = INDEX(endpoint);    

  00008	e202500f	 and         r5, r2, #0xF

; 1914 :     if (pOTG == NULL)
; 1915 :     {
; 1916 :         DEBUGMSG(ZONE_ERROR, (TEXT("Failure to restore configure\r\n")));
; 1917 :         return FALSE;

  0000c	03a00000	 moveq       r0, #0

; 1928 : }

  00010	08bd4030	 ldmeqia     sp!, {r4, r5, lr}
  00014	012fff1e	 bxeq        lr

; 1918 :     }
; 1919 : 
; 1920 :     // Set the Index Register
; 1921 :     EnterCriticalSection(&pOTG->regCS); 

  00018	e2840038	 add         r0, r4, #0x38
  0001c	eb000000	 bl          EnterCriticalSection

; 1922 :     OUTREG8(&pOTG->pUsbGenRegs->Index, csrIndex);

  00020	e5943020	 ldr         r3, [r4, #0x20]
  00024	e3a02c1f	 mov         r2, #0x1F, 24

; 1923 : 
; 1924 :     rxcsr = (RXCSR_H_AutoClr|RXCSR_H_AutoReq|RXCSR_H_DMAReqEn);
; 1925 :     CLRREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR, rxcsr);

  00028	e382e0ff	 orr         lr, r2, #0xFF
  0002c	e5c3500e	 strb        r5, [r3, #0xE]
  00030	e594301c	 ldr         r3, [r4, #0x1C]

; 1926 :     LeaveCriticalSection(&pOTG->regCS);    

  00034	e2840038	 add         r0, r4, #0x38
  00038	e0831205	 add         r1, r3, r5, lsl #4
  0003c	e5d12006	 ldrb        r2, [r1, #6]
  00040	e5d13007	 ldrb        r3, [r1, #7]
  00044	e1823403	 orr         r3, r2, r3, lsl #8
  00048	e003300e	 and         r3, r3, lr
  0004c	e1a02423	 mov         r2, r3, lsr #8
  00050	e5c13006	 strb        r3, [r1, #6]
  00054	e5c12007	 strb        r2, [r1, #7]
  00058	eb000000	 bl          LeaveCriticalSection

; 1927 :     return TRUE;

  0005c	e3a00001	 mov         r0, #1

; 1928 : }

  00060	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00064	e12fff1e	 bx          lr
  00068		 |$M44961|

			 ENDP  ; |?RestoreRxConfig@CHW@@QAAHPAXE@Z|, CHW::RestoreRxConfig

	EXPORT	|?UpdateDataToggle@CHW@@UAAHQAVCPipe@@HH@Z| ; CHW::UpdateDataToggle
	IMPORT	|?GetDataToggle@CPipe@@QAAEXZ|		; CPipe::GetDataToggle
	IMPORT	|?IsDataToggle@CPipe@@QAAHXZ|		; CPipe::IsDataToggle
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\cpipe.h

  00000			 AREA	 |.pdata|, PDATA
|$T44999| DCD	|$LN36@UpdateData|
	DCD	0x40007a02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdateDataToggle@CHW@@UAAHQAVCPipe@@HH@Z| PROC ; CHW::UpdateDataToggle

; 1941 : {

  00000		 |$LN36@UpdateData|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M44996|
  00008	e1a08003	 mov         r8, r3
  0000c	e1a09002	 mov         r9, r2
  00010	e1a05001	 mov         r5, r1

; 1942 :     PHSMUSB_T pOTG;    
; 1943 : 
; 1944 :     pOTG = (PHSMUSB_T)GetOTGContext();

  00014	e59000b0	 ldr         r0, [r0, #0xB0]
  00018	e1b04000	 movs        r4, r0

; 1945 :     if (pOTG == NULL)
; 1946 :     {
; 1947 :         DEBUGMSG(ZONE_ERROR, (TEXT("CHW::ConfigEP failed\r\n")));
; 1948 :         return FALSE;

  0001c	03a00000	 moveq       r0, #0
  00020	0a00006d	 beq         |$LN18@UpdateData|

; 1949 :     }  
; 1950 : 
; 1951 :     USB_ENDPOINT_DESCRIPTOR endptDesc = pPipe->GetEndptDescriptor();

  00024	e28d0000	 add         r0, sp, #0
  00028	e2851034	 add         r1, r5, #0x34
  0002c	e3a02007	 mov         r2, #7
  00030	eb000000	 bl          memcpy

; 1952 :     UCHAR endpoint = USB_ENDPOINT(endptDesc.bEndpointAddress);

  00034	e5dda002	 ldrb        r10, [sp, #2]

; 1953 :     UCHAR mappedEP = pPipe->GetMappedEndPoint();

  00038	e5d57058	 ldrb        r7, [r5, #0x58]

; 1954 :     UCHAR outdir   = USB_ENDPOINT_DIRECTION_OUT(endptDesc.bEndpointAddress);
; 1955 : 
; 1956 : 
; 1957 :     EnterCriticalSection(&pOTG->regCS);

  0003c	e2840038	 add         r0, r4, #0x38
  00040	e31a0080	 tst         r10, #0x80
  00044	03a06001	 moveq       r6, #1
  00048	13a06000	 movne       r6, #0
  0004c	eb000000	 bl          EnterCriticalSection

; 1958 :     // Set the Index Register
; 1959 :     OUTREG8(&pOTG->pUsbGenRegs->Index, USB_ENDPOINT(mappedEP));

  00050	e5943020	 ldr         r3, [r4, #0x20]
  00054	e207700f	 and         r7, r7, #0xF

; 1960 : 
; 1961 :     if (!pPipe->IsDataToggle())

  00058	e1a00005	 mov         r0, r5
  0005c	e5c3700e	 strb        r7, [r3, #0xE]
  00060	eb000000	 bl          |?IsDataToggle@CPipe@@QAAHXZ|
  00064	e3500000	 cmp         r0, #0

; 1962 :     {
; 1963 :         LeaveCriticalSection(&pOTG->regCS);
; 1964 :         return TRUE;

  00068	0a000058	 beq         |$LN1@UpdateData|

; 1965 :     }
; 1966 : 
; 1967 :     if (endpoint != 0)

  0006c	e31a000f	 tst         r10, #0xF
  00070	0a000056	 beq         |$LN1@UpdateData|

; 1968 :     {
; 1969 :         if (outdir)

  00074	e3560000	 cmp         r6, #0
  00078	0a00002a	 beq         |$LN14@UpdateData|

; 1970 :         {
; 1971 :             if (fResetDataToggle)

  0007c	e3590000	 cmp         r9, #0
  00080	0a00000b	 beq         |$LN13@UpdateData|

; 1972 :             {
; 1973 :                 OUTREG16(&pOTG->pUsbCsrRegs->ep[USB_ENDPOINT(mappedEP)].CSR.TxCSR, 0);

  00084	e594301c	 ldr         r3, [r4, #0x1C]
  00088	e3a02000	 mov         r2, #0
  0008c	e0833207	 add         r3, r3, r7, lsl #4
  00090	e5c32002	 strb        r2, [r3, #2]
  00094	e5c32003	 strb        r2, [r3, #3]

; 1974 :                 SETREG16(&pOTG->pUsbCsrRegs->ep[USB_ENDPOINT(mappedEP)].CSR.TxCSR,
; 1975 :                     TXCSR_H_ClrDataTog|TXCSR_H_FlushFIFO);

  00098	e594301c	 ldr         r3, [r4, #0x1C]
  0009c	e0831207	 add         r1, r3, r7, lsl #4
  000a0	e5d12002	 ldrb        r2, [r1, #2]
  000a4	e5d13003	 ldrb        r3, [r1, #3]
  000a8	e1823403	 orr         r3, r2, r3, lsl #8
  000ac	e3833048	 orr         r3, r3, #0x48
  000b0	ea000018	 b           |$LN33@UpdateData|
  000b4		 |$LN13@UpdateData|

; 1976 :             }
; 1977 :             else if (fUpdateDataToggle)

  000b4	e3580000	 cmp         r8, #0
  000b8	0a000044	 beq         |$LN1@UpdateData|

; 1978 :             {
; 1979 :                 DWORD dwDataToggle = (INREG16(&pOTG->pUsbCsrRegs->ep[USB_ENDPOINT(mappedEP)].CSR.TxCSR) & TXCSR_H_DataToggle);

  000bc	e594301c	 ldr         r3, [r4, #0x1C]

; 1980 :                 UCHAR ucNextDataToggle = ((dwDataToggle != 0)? 1: 0);
; 1981 :                 if (pPipe->GetDataToggle() != ucNextDataToggle)

  000c0	e1a00005	 mov         r0, r5
  000c4	e0833207	 add         r3, r3, r7, lsl #4
  000c8	e5d32002	 ldrb        r2, [r3, #2]
  000cc	e5d33003	 ldrb        r3, [r3, #3]
  000d0	e1823403	 orr         r3, r2, r3, lsl #8
  000d4	e2133c01	 ands        r3, r3, #1, 24
  000d8	13a06001	 movne       r6, #1
  000dc	03a06000	 moveq       r6, #0
  000e0	eb000000	 bl          |?GetDataToggle@CPipe@@QAAEXZ|
  000e4	e20630ff	 and         r3, r6, #0xFF
  000e8	e1500003	 cmp         r0, r3
  000ec	0a000037	 beq         |$LN1@UpdateData|

; 1982 :                 {
; 1983 :                     if (pPipe->GetDataToggle() == 0)                    

  000f0	e1a00005	 mov         r0, r5
  000f4	eb000000	 bl          |?GetDataToggle@CPipe@@QAAEXZ|

; 1984 :                         SETREG16(&pOTG->pUsbCsrRegs->ep[USB_ENDPOINT(mappedEP)].CSR.TxCSR, TXCSR_H_ClrDataTog);

  000f8	e594301c	 ldr         r3, [r4, #0x1C]
  000fc	e3500000	 cmp         r0, #0
  00100	e0831207	 add         r1, r3, r7, lsl #4
  00104	e5d12002	 ldrb        r2, [r1, #2]
  00108	e5d13003	 ldrb        r3, [r1, #3]
  0010c	e1823403	 orr         r3, r2, r3, lsl #8
  00110	03833040	 orreq       r3, r3, #0x40

; 1985 :                     else
; 1986 :                         SETREG16(&pOTG->pUsbCsrRegs->ep[USB_ENDPOINT(mappedEP)].CSR.TxCSR, 
; 1987 :                             TXCSR_H_DataTogWrEn|TXCSR_H_DataToggle);

  00114	13833c03	 orrne       r3, r3, #3, 24
  00118		 |$LN33@UpdateData|
  00118	e1a02423	 mov         r2, r3, lsr #8
  0011c	e5c13002	 strb        r3, [r1, #2]
  00120	e5c12003	 strb        r2, [r1, #3]

; 1988 :                 }
; 1989 :             }
; 1990 : 
; 1991 :         }
; 1992 :         else

  00124	ea000029	 b           |$LN1@UpdateData|
  00128		 |$LN14@UpdateData|

; 1993 :         {
; 1994 :             if (fResetDataToggle)

  00128	e3590000	 cmp         r9, #0
  0012c	0a00000b	 beq         |$LN6@UpdateData|

; 1995 :             {
; 1996 :                 OUTREG16(&pOTG->pUsbCsrRegs->ep[USB_ENDPOINT(mappedEP)].RxCSR, 0);

  00130	e594301c	 ldr         r3, [r4, #0x1C]
  00134	e3a02000	 mov         r2, #0
  00138	e0833207	 add         r3, r3, r7, lsl #4
  0013c	e5c32006	 strb        r2, [r3, #6]
  00140	e5c32007	 strb        r2, [r3, #7]

; 1997 :                 SETREG16(&pOTG->pUsbCsrRegs->ep[USB_ENDPOINT(mappedEP)].RxCSR, 
; 1998 :                     RXCSR_H_ClrDataTog|RXCSR_H_FlushFIFO);

  00144	e594301c	 ldr         r3, [r4, #0x1C]
  00148	e0831207	 add         r1, r3, r7, lsl #4
  0014c	e5d12006	 ldrb        r2, [r1, #6]
  00150	e5d13007	 ldrb        r3, [r1, #7]
  00154	e1823403	 orr         r3, r2, r3, lsl #8
  00158	e3833090	 orr         r3, r3, #0x90
  0015c	ea000018	 b           |$LN32@UpdateData|
  00160		 |$LN6@UpdateData|

; 1999 :             }
; 2000 :             else if (fUpdateDataToggle)

  00160	e3580000	 cmp         r8, #0
  00164	0a000019	 beq         |$LN1@UpdateData|

; 2001 :             {
; 2002 :                 DWORD dwDataToggle = (INREG16(&pOTG->pUsbCsrRegs->ep[USB_ENDPOINT(mappedEP)].RxCSR) & RXCSR_H_DataToggle);

  00168	e594301c	 ldr         r3, [r4, #0x1C]

; 2003 :                 UCHAR ucNextDataToggle = ((dwDataToggle != 0)? 1: 0);
; 2004 :                 if (pPipe->GetDataToggle() != ucNextDataToggle)

  0016c	e1a00005	 mov         r0, r5
  00170	e0833207	 add         r3, r3, r7, lsl #4
  00174	e5d32006	 ldrb        r2, [r3, #6]
  00178	e5d33007	 ldrb        r3, [r3, #7]
  0017c	e1823403	 orr         r3, r2, r3, lsl #8
  00180	e2133c02	 ands        r3, r3, #2, 24
  00184	13a06001	 movne       r6, #1
  00188	03a06000	 moveq       r6, #0
  0018c	eb000000	 bl          |?GetDataToggle@CPipe@@QAAEXZ|
  00190	e20630ff	 and         r3, r6, #0xFF
  00194	e1500003	 cmp         r0, r3
  00198	0a00000c	 beq         |$LN1@UpdateData|

; 2005 :                 {
; 2006 :                     if (pPipe->GetDataToggle() == 0)

  0019c	e1a00005	 mov         r0, r5
  001a0	eb000000	 bl          |?GetDataToggle@CPipe@@QAAEXZ|

; 2007 :                         SETREG16(&pOTG->pUsbCsrRegs->ep[USB_ENDPOINT(mappedEP)].RxCSR, RXCSR_H_ClrDataTog);

  001a4	e594301c	 ldr         r3, [r4, #0x1C]
  001a8	e3500000	 cmp         r0, #0
  001ac	e0831207	 add         r1, r3, r7, lsl #4
  001b0	e5d12006	 ldrb        r2, [r1, #6]
  001b4	e5d13007	 ldrb        r3, [r1, #7]
  001b8	e1823403	 orr         r3, r2, r3, lsl #8
  001bc	03833080	 orreq       r3, r3, #0x80

; 2008 :                     else
; 2009 :                         SETREG16(&pOTG->pUsbCsrRegs->ep[USB_ENDPOINT(mappedEP)].RxCSR, 
; 2010 :                             RXCSR_H_DataTogWrEn|RXCSR_H_DataToggle);

  001c0	13833c06	 orrne       r3, r3, #6, 24
  001c4		 |$LN32@UpdateData|
  001c4	e1a02423	 mov         r2, r3, lsr #8
  001c8	e5c13006	 strb        r3, [r1, #6]
  001cc	e5c12007	 strb        r2, [r1, #7]
  001d0		 |$LN1@UpdateData|

; 2011 :                         DEBUGMSG(ZONE_DEBUG, (TEXT("UpdateDataToggle for EP 0x%x (mappedEP 0x%x) DeviceAddr(0x%x)=> RxCSR(0x%x)\r\n"),
; 2012 :                         endpoint, mappedEP, pPipe->GetReservedDeviceAddr(), INREG16(&pOTG->pUsbCsrRegs->ep[USB_ENDPOINT(mappedEP)].RxCSR)));
; 2013 : 
; 2014 :                 }
; 2015 :             }
; 2016 : 
; 2017 :         }
; 2018 :     }
; 2019 :     
; 2020 :     LeaveCriticalSection(&pOTG->regCS);

  001d0	e2840038	 add         r0, r4, #0x38
  001d4	eb000000	 bl          LeaveCriticalSection

; 2021 :     return TRUE;

  001d8	e3a00001	 mov         r0, #1
  001dc		 |$LN18@UpdateData|

; 2022 : }

  001dc	e28dd008	 add         sp, sp, #8
  001e0	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  001e4	e12fff1e	 bx          lr
  001e8		 |$M44997|

			 ENDP  ; |?UpdateDataToggle@CHW@@UAAHQAVCPipe@@HH@Z|, CHW::UpdateDataToggle

	EXPORT	|?InitFIFO@CHW@@UAAHQAVCPipe@@@Z|	; CHW::InitFIFO
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\cpipe.h

  00000			 AREA	 |.pdata|, PDATA
|$T45038| DCD	|$LN26@InitFIFO|
	DCD	0x40004b02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InitFIFO@CHW@@UAAHQAVCPipe@@@Z| PROC	; CHW::InitFIFO

; 2033 : {

  00000		 |$LN26@InitFIFO|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M45035|
  00008	e1a05001	 mov         r5, r1

; 2034 :     PHSMUSB_T pOTG;    
; 2035 :     int i;
; 2036 : 
; 2037 :     pOTG = (PHSMUSB_T)GetOTGContext();

  0000c	e59030b0	 ldr         r3, [r0, #0xB0]
  00010	e1b04003	 movs        r4, r3

; 2038 :     if (pOTG == NULL)
; 2039 :     {
; 2040 :         DEBUGMSG(ZONE_ERROR, (TEXT("CHW::ConfigEP failed\r\n")));
; 2041 :         return FALSE;

  00014	03a00000	 moveq       r0, #0
  00018	0a000040	 beq         |$LN9@InitFIFO|

; 2042 :     }  
; 2043 : 
; 2044 :     USB_ENDPOINT_DESCRIPTOR endptDesc = pPipe->GetEndptDescriptor();

  0001c	e28d0000	 add         r0, sp, #0
  00020	e2851034	 add         r1, r5, #0x34
  00024	e3a02007	 mov         r2, #7
  00028	eb000000	 bl          memcpy

; 2045 :     UCHAR endpoint = USB_ENDPOINT(endptDesc.bEndpointAddress);

  0002c	e5dd7002	 ldrb        r7, [sp, #2]

; 2046 :     UCHAR mappedEP = pPipe->GetMappedEndPoint();

  00030	e5d56058	 ldrb        r6, [r5, #0x58]

; 2047 :     UCHAR outdir   = USB_ENDPOINT_DIRECTION_OUT(endptDesc.bEndpointAddress);
; 2048 : 
; 2049 : 
; 2050 :     EnterCriticalSection(&pOTG->regCS);

  00034	e2840038	 add         r0, r4, #0x38
  00038	e3170080	 tst         r7, #0x80
  0003c	03a05001	 moveq       r5, #1
  00040	13a05000	 movne       r5, #0
  00044	eb000000	 bl          EnterCriticalSection

; 2051 :     // Set the Index Register
; 2052 :     OUTREG8(&pOTG->pUsbGenRegs->Index, USB_ENDPOINT(mappedEP));
; 2053 : 
; 2054 :     USHORT size			  = max(endptDesc.wMaxPacketSize, 8);    

  00048	e1dd20b4	 ldrh        r2, [sp, #4]
  0004c	e5943020	 ldr         r3, [r4, #0x20]
  00050	e206100f	 and         r1, r6, #0xF
  00054	e3520008	 cmp         r2, #8
  00058	e5c3100e	 strb        r1, [r3, #0xE]
  0005c	81a03002	 movhi       r3, r2
  00060	93a03008	 movls       r3, #8
  00064	e1a00803	 mov         r0, r3, lsl #16

; 2055 :     DWORD pwr_of_two	  = size>>3;
; 2056 :     DWORD fifo_size_index = 0;
; 2057 :     // To avoid the change dynamically, each endpoint has been reserved for
; 2058 :     // max packet size *2 
; 2059 :     DWORD fifo_addr_index = (1024*USB_ENDPOINT(mappedEP))>>3;         

  00068	e1a03501	 mov         r3, r1, lsl #10
  0006c	e1a00820	 mov         r0, r0, lsr #16
  00070	e1a061c3	 mov         r6, r3, asr #3
  00074	e1a021a0	 mov         r2, r0, lsr #3

; 2060 :     
; 2061 :     i = 0;

  00078	e3a03000	 mov         r3, #0
  0007c	e3a0e000	 mov         lr, #0
  00080	e3a01001	 mov         r1, #1
  00084		 |$LL7@InitFIFO|

; 2062 :     while (i < 10 ) // max = 4096 i.e. i = 9
; 2063 :     {
; 2064 :         if (pwr_of_two & (1<<i)) 

  00084	e1120311	 tst         r2, r1, lsl r3
  00088	1a000003	 bne         |$LN22@InitFIFO|

; 2067 :             break;
; 2068 :         }        
; 2069 :         i++;

  0008c	e2833001	 add         r3, r3, #1
  00090	e353000a	 cmp         r3, #0xA
  00094	bafffffa	 blt         |$LL7@InitFIFO|

; 2062 :     while (i < 10 ) // max = 4096 i.e. i = 9
; 2063 :     {
; 2064 :         if (pwr_of_two & (1<<i)) 

  00098	ea000000	 b           |$LN6@InitFIFO|
  0009c		 |$LN22@InitFIFO|

; 2065 :         {
; 2066 :             fifo_size_index = i;

  0009c	e1a0e003	 mov         lr, r3
  000a0		 |$LN6@InitFIFO|

; 2070 :     }
; 2071 : 
; 2072 :     DEBUGMSG(ZONE_HCD|ZONE_DEBUG, (TEXT("Fifo size = %d, index = %d\r\n"), size, fifo_size_index));
; 2073 :     if (endpoint != 0)
; 2074 :     {
; 2075 :         if (outdir)
; 2076 :         {
; 2077 :             OUTREG8(&pOTG->pUsbGenRegs->TxFIFOsz, fifo_size_index);

  000a0	e5943020	 ldr         r3, [r4, #0x20]
  000a4	e317000f	 tst         r7, #0xF
  000a8	0a00000d	 beq         |$LN4@InitFIFO|
  000ac	e3550000	 cmp         r5, #0

; 2078 :             // Add index 512 = 4096 bytes for seperate the addr from Rx
; 2079 :             OUTREG16(&pOTG->pUsbGenRegs->TxFIFOadd, fifo_addr_index+0x40);                        

  000b0	15c3e062	 strneb      lr, [r3, #0x62]
  000b4	15943020	 ldrne       r3, [r4, #0x20]
  000b8	12862040	 addne       r2, r6, #0x40
  000bc	11a01422	 movne       r1, r2, lsr #8
  000c0	15c32064	 strneb      r2, [r3, #0x64]
  000c4	15c31065	 strneb      r1, [r3, #0x65]
  000c8	1a000011	 bne         |$LN1@InitFIFO|

; 2080 :         }
; 2081 :         else
; 2082 :         {
; 2083 :             OUTREG8(&pOTG->pUsbGenRegs->RxFIFOsz, fifo_size_index);
; 2084 :             OUTREG16(&pOTG->pUsbGenRegs->RxFIFOadd, fifo_addr_index);            

  000cc	e5c3e063	 strb        lr, [r3, #0x63]
  000d0	e5943020	 ldr         r3, [r4, #0x20]
  000d4	e1a02426	 mov         r2, r6, lsr #8
  000d8	e5c36066	 strb        r6, [r3, #0x66]
  000dc	e5c32067	 strb        r2, [r3, #0x67]

; 2085 : 
; 2086 :         }
; 2087 :     }
; 2088 :     else

  000e0	ea00000b	 b           |$LN1@InitFIFO|
  000e4		 |$LN4@InitFIFO|

; 2089 :     {
; 2090 :         // endpoint 0, set the FIFO size to be 64 bytes
; 2091 :         OUTREG8(&pOTG->pUsbGenRegs->TxFIFOsz, fifo_size_index);
; 2092 :         OUTREG16(&pOTG->pUsbGenRegs->TxFIFOadd, fifo_addr_index);
; 2093 :         fifo_addr_index = fifo_addr_index + (size>>3);

  000e4	e5c3e062	 strb        lr, [r3, #0x62]
  000e8	e5943020	 ldr         r3, [r4, #0x20]
  000ec	e1a02426	 mov         r2, r6, lsr #8
  000f0	e08611a0	 add         r1, r6, r0, lsr #3

; 2094 : 
; 2095 :         OUTREG8(&pOTG->pUsbGenRegs->RxFIFOsz, fifo_size_index);        
; 2096 :         OUTREG16(&pOTG->pUsbGenRegs->RxFIFOadd, fifo_addr_index);            

  000f4	e5c36064	 strb        r6, [r3, #0x64]
  000f8	e5c32065	 strb        r2, [r3, #0x65]
  000fc	e5943020	 ldr         r3, [r4, #0x20]
  00100	e1a00421	 mov         r0, r1, lsr #8
  00104	e5c3e063	 strb        lr, [r3, #0x63]
  00108	e5943020	 ldr         r3, [r4, #0x20]
  0010c	e5c31066	 strb        r1, [r3, #0x66]
  00110	e5c30067	 strb        r0, [r3, #0x67]
  00114		 |$LN1@InitFIFO|

; 2097 :     }
; 2098 : 
; 2099 :     DEBUGMSG(ZONE_DEBUG, (TEXT("FIFO Address setup for device ep %d, mapped %d\r\n"), endpoint, USB_ENDPOINT(mappedEP)));
; 2100 :     DEBUGMSG(ZONE_DEBUG, (TEXT("RxFIFOAddr = 0x%x\r\n"), INREG16(&pOTG->pUsbGenRegs->RxFIFOadd)));
; 2101 :     DEBUGMSG(ZONE_DEBUG, (TEXT("TxFIFOAddr = 0x%x\r\n"), INREG16(&pOTG->pUsbGenRegs->TxFIFOadd)));
; 2102 :     DEBUGMSG(ZONE_DEBUG, (TEXT("RxFIFOsz = 0x%x\r\n"), INREG8(&pOTG->pUsbGenRegs->RxFIFOsz)));
; 2103 :     DEBUGMSG(ZONE_DEBUG, (TEXT("TxFIFOsz = 0x%x\r\n"), INREG8(&pOTG->pUsbGenRegs->TxFIFOsz)));
; 2104 :     DEBUGMSG(ZONE_DEBUG, (TEXT("RxCSR = 0x%x\r\n"),INREG16(&pOTG->pUsbCsrRegs->ep[USB_ENDPOINT(mappedEP)].RxCSR)));
; 2105 :     DEBUGMSG(ZONE_DEBUG, (TEXT("TxCSR = 0x%x\r\n"),INREG16(&pOTG->pUsbCsrRegs->ep[USB_ENDPOINT(mappedEP)].CSR.TxCSR)));
; 2106 :     
; 2107 :     LeaveCriticalSection(&pOTG->regCS);

  00114	e2840038	 add         r0, r4, #0x38
  00118	eb000000	 bl          LeaveCriticalSection

; 2108 :     return TRUE;

  0011c	e3a00001	 mov         r0, #1
  00120		 |$LN9@InitFIFO|

; 2109 : }

  00120	e28dd008	 add         sp, sp, #8
  00124	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00128	e12fff1e	 bx          lr
  0012c		 |$M45036|

			 ENDP  ; |?InitFIFO@CHW@@UAAHQAVCPipe@@@Z|, CHW::InitFIFO

	EXPORT	|?ConfigEP@CHW@@UAAHQBU_USB_ENDPOINT_DESCRIPTOR@@EEEEHEH@Z| ; CHW::ConfigEP
	EXPORT	|??_C@_1FG@LOOHOAMO@?$AAC?$AAH?$AAW?$AA?3?$AA?3?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAE?$AAP?$AA?5?$AA?9?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAt@| [ DATA ] ; `string'
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T45066| DCD	|$LN32@ConfigEP|
	DCD	0x4000c802

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FG@LOOHOAMO@?$AAC?$AAH?$AAW?$AA?3?$AA?3?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAE?$AAP?$AA?5?$AA?9?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAt@| DCB "C"
	DCB	0x0, "H", 0x0, "W", 0x0, ":", 0x0, ":", 0x0, "C", 0x0, "o"
	DCB	0x0, "n", 0x0, "f", 0x0, "i", 0x0, "g", 0x0, "E", 0x0, "P"
	DCB	0x0, " ", 0x0, "-", 0x0, " ", 0x0, "n", 0x0, "o", 0x0, "t"
	DCB	0x0, " ", 0x0, "s", 0x0, "u", 0x0, "p", 0x0, "p", 0x0, "o"
	DCB	0x0, "r", 0x0, "t", 0x0, " ", 0x0, "o", 0x0, "f", 0x0, " "
	DCB	0x0, "t", 0x0, "h", 0x0, "i", 0x0, "s", 0x0, " ", 0x0, "t"
	DCB	0x0, "y", 0x0, "p", 0x0, "e", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ConfigEP@CHW@@UAAHQBU_USB_ENDPOINT_DESCRIPTOR@@EEEEHEH@Z| PROC ; CHW::ConfigEP

; 2125 : {

  00000		 |$LN32@ConfigEP|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M45063|
  00008	e5cd3008	 strb        r3, [sp, #8]
  0000c	e1a0b002	 mov         r11, r2
  00010	e1a05001	 mov         r5, r1
  00014	e1a07000	 mov         r7, r0

; 2126 :     PHSMUSB_T pOTG;
; 2127 :     UCHAR endpoint;
; 2128 :     UCHAR protocol;
; 2129 :     UCHAR outdir;
; 2130 :     UCHAR csrIndex;    
; 2131 :     pOTG = (PHSMUSB_T)GetOTGContext();

  00018	e597e0b0	 ldr         lr, [r7, #0xB0]
  0001c	e1b0600e	 movs        r6, lr

; 2132 :     if (pOTG == NULL)
; 2133 :     {
; 2134 :         DEBUGMSG(ZONE_ERROR, (TEXT("CHW::ConfigEP failed\r\n")));
; 2135 :         return FALSE;

  00020	03a00000	 moveq       r0, #0
  00024	0a0000b9	 beq         |$LN20@ConfigEP|

; 2136 :     }
; 2137 : 
; 2138 :     endpoint = USB_ENDPOINT(lpEndpointDescriptor->bEndpointAddress);

  00028	e5d59002	 ldrb        r9, [r5, #2]

; 2139 :     protocol = lpEndpointDescriptor->bmAttributes & USB_ENDPOINT_TYPE_MASK;

  0002c	e5d53003	 ldrb        r3, [r5, #3]

; 2140 :     outdir = USB_ENDPOINT_DIRECTION_OUT(lpEndpointDescriptor->bEndpointAddress);
; 2141 :   
; 2142 :     DEBUGMSG(ZONE_HCD, (TEXT("ConfigEP TransferMode(0x%x), EP(0x%x), Dev(0x%x), DIR:%s\r\n"),
; 2143 :         transferMode, endpoint, bDeviceAddress, outdir?(TEXT("OUT")):(TEXT("IN"))));
; 2144 : 
; 2145 :     // Set the Index Register
; 2146 :     EnterCriticalSection(&pOTG->regCS); 

  00030	e2860038	 add         r0, r6, #0x38
  00034	e3190080	 tst         r9, #0x80
  00038	03a08001	 moveq       r8, #1
  0003c	13a08000	 movne       r8, #0
  00040	e203a003	 and         r10, r3, #3
  00044	eb000000	 bl          EnterCriticalSection

; 2147 :     OUTREG8(&pOTG->pUsbGenRegs->Index, INDEX(mappedEP));    

  00048	e5963020	 ldr         r3, [r6, #0x20]
  0004c	e20b400f	 and         r4, r11, #0xF

; 2148 : 
; 2149 :     if (endpoint == 0) // Endpoint 0, there is no need to do any configuration

  00050	e219000f	 ands        r0, r9, #0xF
  00054	e5c3400e	 strb        r4, [r3, #0xE]
  00058	1a00000f	 bne         |$LN18@ConfigEP|

; 2150 :     {
; 2151 :         DEBUGMSG(ZONE_HCD, (TEXT("Configure the speed of the device\r\n")));
; 2152 :         DEBUGMSG(ZONE_HCD, (TEXT("CSR0 = 0x%x\r\n"), pOTG->pUsbCsrRegs->ep[0].CSR.CSR0));
; 2153 :         DEBUGMSG(ZONE_HCD, (TEXT("ConfigData=0x%x\r\n"), pOTG->pUsbCsrRegs->ep[0].Config.ConfigData));
; 2154 :         DEBUGMSG(ZONE_HCD, (TEXT("Speed of Device = 0x%x\r\n"), speed));
; 2155 :         DEBUGMSG(ZONE_HCD, (TEXT("ConfigEP: EP0 with bDeviceAddress = %d\r\n"), bDeviceAddress));
; 2156 :         // Set the speed 
; 2157 :         OUTREG8(&pOTG->pUsbCsrRegs->ep[0].Type.Type0, (speed << 6));

  0005c	e59d3038	 ldr         r3, [sp, #0x38]
  00060	e596201c	 ldr         r2, [r6, #0x1C]

; 2158 :         SetDeviceAddress(mappedEP, bDeviceAddress, bHubAddress, bHubPort, outdir);

  00064	e5dd5034	 ldrb        r5, [sp, #0x34]
  00068	e1a03303	 mov         r3, r3, lsl #6
  0006c	e5c2300a	 strb        r3, [r2, #0xA]
  00070	e5971000	 ldr         r1, [r7]
  00074	e5dd3030	 ldrb        r3, [sp, #0x30]
  00078	e5dd2008	 ldrb        r2, [sp, #8]
  0007c	e5914064	 ldr         r4, [r1, #0x64]
  00080	e1a0100b	 mov         r1, r11
  00084	e1a00007	 mov         r0, r7
  00088	e58d8004	 str         r8, [sp, #4]
  0008c	e58d5000	 str         r5, [sp]
  00090	e1a0e00f	 mov         lr, pc
  00094	e12fff14	 bx          r4

; 2159 :     }
; 2160 :     else

  00098	ea000099	 b           |$LN2@ConfigEP|
  0009c		 |$LN18@ConfigEP|

; 2161 :     {
; 2162 :         csrIndex = INDEX(mappedEP);
; 2163 :         // 1. Setup RxType or TxType
; 2164 :         // 2. Setup RxMaxP or TxMaxP
; 2165 :         // 3. Setup Interval
; 2166 :         // 4. Setup RxCSR or TxCSR - data toggle bit
; 2167 :         // 5. Check and see if flush is required
; 2168 :         // 6. Set the TxFuncAddr/RxFuncAddr
; 2169 :         switch (protocol)

  0009c	e1b0300a	 movs        r3, r10
  000a0	0a000097	 beq         |$LN2@ConfigEP|
  000a4	e2433002	 sub         r3, r3, #2
  000a8	e3530001	 cmp         r3, #1
  000ac	8a000092	 bhi         |$LN1@ConfigEP|

; 2170 :         {
; 2171 :         case (USB_ENDPOINT_TYPE_BULK):
; 2172 :         case (USB_ENDPOINT_TYPE_INTERRUPT):
; 2173 :             {
; 2174 :                 if (outdir)
; 2175 :                 {
; 2176 :                     USHORT txcsr;
; 2177 :                     // step 1
; 2178 :                     UCHAR txtype = (UCHAR)RxTxTYPE(speed, protocol, endpoint);
; 2179 :                     OUTREG8(&pOTG->pUsbCsrRegs->ep[csrIndex].Type.TxType, txtype);

  000b0	e59d2038	 ldr         r2, [sp, #0x38]
  000b4	e596101c	 ldr         r1, [r6, #0x1C]
  000b8	e20a3003	 and         r3, r10, #3
  000bc	e1832102	 orr         r2, r3, r2, lsl #2
  000c0	e200300f	 and         r3, r0, #0xF
  000c4	e1833202	 orr         r3, r3, r2, lsl #4
  000c8	e3580000	 cmp         r8, #0
  000cc	e0811204	 add         r1, r1, r4, lsl #4
  000d0	0a00004a	 beq         |$LN13@ConfigEP|
  000d4	e5c1300a	 strb        r3, [r1, #0xA]

; 2180 : 
; 2181 :                     // step 2                                        
; 2182 :                     OUTREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].TxMaxP, lpEndpointDescriptor->wMaxPacketSize);

  000d8	e5d51004	 ldrb        r1, [r5, #4]
  000dc	e5d53005	 ldrb        r3, [r5, #5]
  000e0	e596201c	 ldr         r2, [r6, #0x1C]

; 2183 : 
; 2184 :                     // step 3 - set to 0 at this point, should change later
; 2185 :                     if (protocol == USB_ENDPOINT_TYPE_BULK)

  000e4	e35a0002	 cmp         r10, #2
  000e8	e1811403	 orr         r1, r1, r3, lsl #8
  000ec	e0822204	 add         r2, r2, r4, lsl #4
  000f0	e1a03421	 mov         r3, r1, lsr #8
  000f4	e5c21000	 strb        r1, [r2]
  000f8	e5c23001	 strb        r3, [r2, #1]

; 2186 :                         OUTREG8(&pOTG->pUsbCsrRegs->ep[csrIndex].timeout.TxInterval, 0);

  000fc	e596301c	 ldr         r3, [r6, #0x1C]
  00100	03a02000	 moveq       r2, #0

; 2187 :                     else
; 2188 :                         OUTREG8(&pOTG->pUsbCsrRegs->ep[csrIndex].timeout.TxInterval, lpEndpointDescriptor->bInterval);

  00104	15d52006	 ldrneb      r2, [r5, #6]
  00108	e0833204	 add         r3, r3, r4, lsl #4

; 2189 : 
; 2190 :                     // step 4                     
; 2191 :                     // clear AutoSet, DMAReqEn, FrcDataTog
; 2192 :                     txcsr = (TXCSR_H_AutoSet|TXCSR_H_DMAReqEn|TXCSR_H_FrcDataTog|TXCSR_H_Mode);
; 2193 :                     CLRREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR, txcsr);
; 2194 : 
; 2195 :                     // if DMA enable, set the AutoSet = 1, DMAReqEnab = 1
; 2196 :                     if (transferMode != TRANSFER_FIFO)

  0010c	e5dd103c	 ldrb        r1, [sp, #0x3C]
  00110	e5c3200b	 strb        r2, [r3, #0xB]
  00114	e596301c	 ldr         r3, [r6, #0x1C]
  00118	e3a02c47	 mov         r2, #0x47, 24
  0011c	e38200ff	 orr         r0, r2, #0xFF
  00120	e083e204	 add         lr, r3, r4, lsl #4
  00124	e5de2002	 ldrb        r2, [lr, #2]
  00128	e5de3003	 ldrb        r3, [lr, #3]
  0012c	e3510000	 cmp         r1, #0
  00130	e1823403	 orr         r3, r2, r3, lsl #8
  00134	e0033000	 and         r3, r3, r0
  00138	e1a02423	 mov         r2, r3, lsr #8
  0013c	e5ce3002	 strb        r3, [lr, #2]
  00140	e5ce2003	 strb        r2, [lr, #3]
  00144	0a000008	 beq         |$LN10@ConfigEP|

; 2197 :                     {
; 2198 :                         txcsr = (TXCSR_H_AutoSet|TXCSR_H_DMAReqEn|TXCSR_H_DMAReqMode);
; 2199 :                         SETREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR, txcsr);

  00148	e596301c	 ldr         r3, [r6, #0x1C]
  0014c	e0831204	 add         r1, r3, r4, lsl #4
  00150	e5d12002	 ldrb        r2, [r1, #2]
  00154	e5d13003	 ldrb        r3, [r1, #3]
  00158	e1823403	 orr         r3, r2, r3, lsl #8
  0015c	e3833b25	 orr         r3, r3, #0x25, 22
  00160	e1a02423	 mov         r2, r3, lsr #8
  00164	e5c13002	 strb        r3, [r1, #2]
  00168	e5c12003	 strb        r2, [r1, #3]
  0016c		 |$LN10@ConfigEP|

; 2200 :                     }
; 2201 : 
; 2202 :                     // set the mode, clr data tog
; 2203 :                     if (bClrTog)

  0016c	e59d3040	 ldr         r3, [sp, #0x40]
  00170	e3530000	 cmp         r3, #0
  00174	0a000008	 beq         |$LN9@ConfigEP|

; 2204 :                         SETREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR, TXCSR_H_ClrDataTog);

  00178	e596301c	 ldr         r3, [r6, #0x1C]
  0017c	e0831204	 add         r1, r3, r4, lsl #4
  00180	e5d12002	 ldrb        r2, [r1, #2]
  00184	e5d13003	 ldrb        r3, [r1, #3]
  00188	e1823403	 orr         r3, r2, r3, lsl #8
  0018c	e3833040	 orr         r3, r3, #0x40
  00190	e1a02423	 mov         r2, r3, lsr #8
  00194	e5c13002	 strb        r3, [r1, #2]
  00198	e5c12003	 strb        r2, [r1, #3]
  0019c		 |$LN9@ConfigEP|

; 2205 : 
; 2206 :                     // step 5
; 2207 :                     if (INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR) & TXCSR_H_FIFONotEmpty)

  0019c	e596301c	 ldr         r3, [r6, #0x1C]

; 2208 :                     {
; 2209 :                         // Need to check if double buffering, if so, do twice.
; 2210 :                         SETREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR, TXCSR_H_FlushFIFO);
; 2211 :                     }
; 2212 : 
; 2213 :                     // Step 6
; 2214 :                     SetDeviceAddress(mappedEP, bDeviceAddress , bHubAddress, bHubPort, outdir);

  001a0	e5dd5034	 ldrb        r5, [sp, #0x34]
  001a4	e1a00007	 mov         r0, r7
  001a8	e0831204	 add         r1, r3, r4, lsl #4
  001ac	e5d12002	 ldrb        r2, [r1, #2]
  001b0	e5d13003	 ldrb        r3, [r1, #3]
  001b4	e58d8004	 str         r8, [sp, #4]
  001b8	e58d5000	 str         r5, [sp]
  001bc	e1823403	 orr         r3, r2, r3, lsl #8
  001c0	e3130002	 tst         r3, #2
  001c4	15d12002	 ldrneb      r2, [r1, #2]
  001c8	15d13003	 ldrneb      r3, [r1, #3]
  001cc	11823403	 orrne       r3, r2, r3, lsl #8
  001d0	13833008	 orrne       r3, r3, #8
  001d4	11a02423	 movne       r2, r3, lsr #8
  001d8	15c13002	 strneb      r3, [r1, #2]
  001dc	15c12003	 strneb      r2, [r1, #3]
  001e0	e5972000	 ldr         r2, [r7]
  001e4	e5dd3030	 ldrb        r3, [sp, #0x30]
  001e8	e1a0100b	 mov         r1, r11
  001ec	e5924064	 ldr         r4, [r2, #0x64]
  001f0	e5dd2008	 ldrb        r2, [sp, #8]
  001f4	e1a0e00f	 mov         lr, pc
  001f8	e12fff14	 bx          r4

; 2215 :                     
; 2216 :                 }
; 2217 :                 else

  001fc	ea000040	 b           |$LN2@ConfigEP|
  00200		 |$LN13@ConfigEP|

; 2218 :                 {
; 2219 :                     USHORT  rxcsr;
; 2220 :                     
; 2221 :                     // step 0, clear the mode if set in order to enable Rx mode
; 2222 :                     //CLRREG16(&pOTG->pUsbGenRegs->INDEX_REG.hIndex.CSR.TxCSR, TXCSR_H_Mode);
; 2223 :                     //OUTREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR, 0);
; 2224 :                     
; 2225 :                     // step 1
; 2226 :                     UCHAR rxtype = (UCHAR)RxTxTYPE(speed, protocol, endpoint);
; 2227 :                     OUTREG8(&pOTG->pUsbCsrRegs->ep[csrIndex].RxType, rxtype);

  00200	e5c1300c	 strb        r3, [r1, #0xC]

; 2228 : 
; 2229 :                     // step 2                    
; 2230 :                     OUTREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxMaxP, lpEndpointDescriptor->wMaxPacketSize);

  00204	e596301c	 ldr         r3, [r6, #0x1C]
  00208	e5d51004	 ldrb        r1, [r5, #4]
  0020c	e5d52005	 ldrb        r2, [r5, #5]
  00210	e0830204	 add         r0, r3, r4, lsl #4

; 2231 :                     DEBUGMSG(ZONE_HCD, (TEXT("ConfigEP: RxMaxP = 0x%x\r\n"), INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxMaxP)));
; 2232 : 
; 2233 :                     // step 3 - set to 0 at this point, should change later
; 2234 :                     if (protocol == USB_ENDPOINT_TYPE_BULK)

  00214	e35a0002	 cmp         r10, #2
  00218	e1813402	 orr         r3, r1, r2, lsl #8
  0021c	e5c03004	 strb        r3, [r0, #4]
  00220	e1a03423	 mov         r3, r3, lsr #8
  00224	e5c03005	 strb        r3, [r0, #5]

; 2235 :                         OUTREG8(&pOTG->pUsbCsrRegs->ep[csrIndex].RxInterval, 0);

  00228	e596301c	 ldr         r3, [r6, #0x1C]
  0022c	03a02000	 moveq       r2, #0

; 2236 :                     else
; 2237 :                         OUTREG8(&pOTG->pUsbCsrRegs->ep[csrIndex].RxInterval, lpEndpointDescriptor->bInterval);

  00230	15d52006	 ldrneb      r2, [r5, #6]
  00234	e0833204	 add         r3, r3, r4, lsl #4

; 2238 : 
; 2239 :                     // step 4                     
; 2240 :                     // clear AutoClr, AutoReq, DMAReqMode,DMAReqEn
; 2241 :                     rxcsr = (RXCSR_H_AutoClr|RXCSR_H_AutoReq|RXCSR_H_DMAReqEn);
; 2242 : 
; 2243 :                     CLRREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR, rxcsr);
; 2244 :                     // set data toggle bit
; 2245 :                     if (bClrTog)

  00238	e59d1040	 ldr         r1, [sp, #0x40]
  0023c	e5c3200d	 strb        r2, [r3, #0xD]
  00240	e596301c	 ldr         r3, [r6, #0x1C]
  00244	e3a02c1f	 mov         r2, #0x1F, 24
  00248	e38200ff	 orr         r0, r2, #0xFF
  0024c	e083e204	 add         lr, r3, r4, lsl #4
  00250	e5de2006	 ldrb        r2, [lr, #6]
  00254	e5de3007	 ldrb        r3, [lr, #7]
  00258	e3510000	 cmp         r1, #0
  0025c	e1823403	 orr         r3, r2, r3, lsl #8
  00260	e0033000	 and         r3, r3, r0
  00264	e1a02423	 mov         r2, r3, lsr #8
  00268	e5ce3006	 strb        r3, [lr, #6]
  0026c	e5ce2007	 strb        r2, [lr, #7]
  00270	0a000008	 beq         |$LN4@ConfigEP|

; 2246 :                         SETREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR, RXCSR_H_ClrDataTog);

  00274	e596301c	 ldr         r3, [r6, #0x1C]
  00278	e0831204	 add         r1, r3, r4, lsl #4
  0027c	e5d12006	 ldrb        r2, [r1, #6]
  00280	e5d13007	 ldrb        r3, [r1, #7]
  00284	e1823403	 orr         r3, r2, r3, lsl #8
  00288	e3833080	 orr         r3, r3, #0x80
  0028c	e1a02423	 mov         r2, r3, lsr #8
  00290	e5c13006	 strb        r3, [r1, #6]
  00294	e5c12007	 strb        r2, [r1, #7]
  00298		 |$LN4@ConfigEP|

; 2247 : 
; 2248 :                                         
; 2249 :                     // step 5
; 2250 :                     if (INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR) & RXCSR_H_RxPktRdy)

  00298	e596301c	 ldr         r3, [r6, #0x1C]

; 2251 :                     {
; 2252 :                         // Need to check if double buffering, if so, do twice.
; 2253 :                         SETREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR, RXCSR_H_FlushFIFO);
; 2254 :                     }                    
; 2255 : 
; 2256 :                     // Step 6
; 2257 :                     SetDeviceAddress(mappedEP, bDeviceAddress, bHubAddress, bHubPort, outdir);

  0029c	e5dd5034	 ldrb        r5, [sp, #0x34]
  002a0	e1a00007	 mov         r0, r7
  002a4	e0831204	 add         r1, r3, r4, lsl #4
  002a8	e5d12006	 ldrb        r2, [r1, #6]
  002ac	e5d13007	 ldrb        r3, [r1, #7]
  002b0	e58d8004	 str         r8, [sp, #4]
  002b4	e58d5000	 str         r5, [sp]
  002b8	e1823403	 orr         r3, r2, r3, lsl #8
  002bc	e3130001	 tst         r3, #1
  002c0	15d12006	 ldrneb      r2, [r1, #6]
  002c4	15d13007	 ldrneb      r3, [r1, #7]
  002c8	11823403	 orrne       r3, r2, r3, lsl #8
  002cc	13833010	 orrne       r3, r3, #0x10
  002d0	11a02423	 movne       r2, r3, lsr #8
  002d4	15c13006	 strneb      r3, [r1, #6]
  002d8	15c12007	 strneb      r2, [r1, #7]
  002dc	e5972000	 ldr         r2, [r7]
  002e0	e5dd3030	 ldrb        r3, [sp, #0x30]
  002e4	e1a0100b	 mov         r1, r11
  002e8	e5924064	 ldr         r4, [r2, #0x64]
  002ec	e5dd2008	 ldrb        r2, [sp, #8]
  002f0	e1a0e00f	 mov         lr, pc
  002f4	e12fff14	 bx          r4

; 2258 :                 }
; 2259 :             }
; 2260 :             break;

  002f8	ea000001	 b           |$LN2@ConfigEP|
  002fc		 |$LN1@ConfigEP|

; 2261 :         case (USB_ENDPOINT_TYPE_CONTROL):
; 2262 :             DEBUGMSG(ZONE_ERROR, (TEXT("CHW::ConfigEP - Control EP (%d) can only happen in EP0\r\n"), endpoint));
; 2263 :             break;
; 2264 :         case (USB_ENDPOINT_TYPE_ISOCHRONOUS):
; 2265 :         default:
; 2266 :             RETAILMSG(1, (TEXT("CHW::ConfigEP - not support of this type\r\n")));

  002fc	e59f0018	 ldr         r0, [pc, #0x18]
  00300	eb000000	 bl          NKDbgPrintfW
  00304		 |$LN2@ConfigEP|

; 2267 :             break;
; 2268 :         }
; 2269 :     }
; 2270 : 
; 2271 :     LeaveCriticalSection(&pOTG->regCS);    

  00304	e2860038	 add         r0, r6, #0x38
  00308	eb000000	 bl          LeaveCriticalSection

; 2272 :     return TRUE;

  0030c	e3a00001	 mov         r0, #1
  00310		 |$LN20@ConfigEP|

; 2273 : 
; 2274 : }

  00310	e28dd00c	 add         sp, sp, #0xC
  00314	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00318	e12fff1e	 bx          lr
  0031c		 |$LN33@ConfigEP|
  0031c		 |$LN34@ConfigEP|
  0031c	00000000	 DCD         |??_C@_1FG@LOOHOAMO@?$AAC?$AAH?$AAW?$AA?3?$AA?3?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAE?$AAP?$AA?5?$AA?9?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAt@|
  00320		 |$M45064|

			 ENDP  ; |?ConfigEP@CHW@@UAAHQBU_USB_ENDPOINT_DESCRIPTOR@@EEEEHEH@Z|, CHW::ConfigEP

	EXPORT	|?PrintRxTxCSR@CHW@@QAAXE@Z|		; CHW::PrintRxTxCSR
	EXPORT	|??_C@_1DG@ECBNBIKH@?$AAP?$AAr?$AAi?$AAn?$AAt?$AA?5?$AAR?$AAx?$AAC?$AAS?$AAR?$AA?3?$AA?$CF?$AAx?$AA?5?$AAT?$AAx?$AAC?$AAS?$AAR?$AA?3?$AA?$CF?$AAx?$AA?5?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T45087| DCD	|$LN9@PrintRxTxC|
	DCD	0x40001601

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DG@ECBNBIKH@?$AAP?$AAr?$AAi?$AAn?$AAt?$AA?5?$AAR?$AAx?$AAC?$AAS?$AAR?$AA?3?$AA?$CF?$AAx?$AA?5?$AAT?$AAx?$AAC?$AAS?$AAR?$AA?3?$AA?$CF?$AAx?$AA?5?$AA?$AN?$AA?6?$AA?$AA@| DCB "P"
	DCB	0x0, "r", 0x0, "i", 0x0, "n", 0x0, "t", 0x0, " ", 0x0, "R"
	DCB	0x0, "x", 0x0, "C", 0x0, "S", 0x0, "R", 0x0, ":", 0x0, "%"
	DCB	0x0, "x", 0x0, " ", 0x0, "T", 0x0, "x", 0x0, "C", 0x0, "S"
	DCB	0x0, "R", 0x0, ":", 0x0, "%", 0x0, "x", 0x0, " ", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PrintRxTxCSR@CHW@@QAAXE@Z| PROC	; CHW::PrintRxTxCSR

; 2276 : {

  00000		 |$LN9@PrintRxTxC|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45084|

; 2277 :     PHSMUSB_T pOTG = (PHSMUSB_T)GetOTGContext();

  00004	e59050b0	 ldr         r5, [r0, #0xB0]

; 2278 :     UCHAR csrIndex = INDEX(MappedEP);

  00008	e201400f	 and         r4, r1, #0xF

; 2279 :     USHORT reg1 = 0;
; 2280 :     USHORT reg2 = 0;
; 2281 :     EnterCriticalSection(&pOTG->regCS);

  0000c	e2850038	 add         r0, r5, #0x38
  00010	eb000000	 bl          EnterCriticalSection

; 2282 :     OUTREG8(&pOTG->pUsbGenRegs->Index, INDEX(MappedEP));

  00014	e5953020	 ldr         r3, [r5, #0x20]

; 2283 :     reg2 = INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR);
; 2284 :     reg1 = INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR);
; 2285 :     RETAILMSG(1, (TEXT("Print RxCSR:%x TxCSR:%x \r\n"),reg1,reg2));

  00018	e59f0034	 ldr         r0, [pc, #0x34]
  0001c	e5c3400e	 strb        r4, [r3, #0xE]
  00020	e595301c	 ldr         r3, [r5, #0x1C]
  00024	e0833204	 add         r3, r3, r4, lsl #4
  00028	e5d3e002	 ldrb        lr, [r3, #2]
  0002c	e5d32003	 ldrb        r2, [r3, #3]
  00030	e5d31006	 ldrb        r1, [r3, #6]
  00034	e5d33007	 ldrb        r3, [r3, #7]
  00038	e18e2402	 orr         r2, lr, r2, lsl #8
  0003c	e1811403	 orr         r1, r1, r3, lsl #8
  00040	eb000000	 bl          NKDbgPrintfW

; 2286 :     LeaveCriticalSection(&pOTG->regCS);

  00044	e2850038	 add         r0, r5, #0x38
  00048	eb000000	 bl          LeaveCriticalSection

; 2287 : }

  0004c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$LN10@PrintRxTxC|
  00054		 |$LN11@PrintRxTxC|
  00054	00000000	 DCD         |??_C@_1DG@ECBNBIKH@?$AAP?$AAr?$AAi?$AAn?$AAt?$AA?5?$AAR?$AAx?$AAC?$AAS?$AAR?$AA?3?$AA?$CF?$AAx?$AA?5?$AAT?$AAx?$AAC?$AAS?$AAR?$AA?3?$AA?$CF?$AAx?$AA?5?$AA?$AN?$AA?6?$AA?$AA@|
  00058		 |$M45085|

			 ENDP  ; |?PrintRxTxCSR@CHW@@QAAXE@Z|, CHW::PrintRxTxCSR

	EXPORT	|?CheckTxCSR@CHW@@QAAKE@Z|		; CHW::CheckTxCSR
	EXPORT	|??_C@_1EG@PLHCCOK@?$AAT?$AAx?$AAC?$AAS?$AAR?$AA_?$AAH?$AA_?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAa?$AAt?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AAc?$AAl?$AAe?$AAa?$AAr?$AA?5?$AAi?$AAt@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CM@EHMOJMHC@?$AAT?$AAx?$AAC?$AAS?$AAR?$AA?5?$AAT?$AAx?$AAS?$AAt?$AAa?$AAl?$AAl?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CG@HEKDHLPK@?$AAC?$AAS?$AAR?$AA0?$AA?5?$AAN?$AAA?$AAK?$AA?5?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T45116| DCD	|$LN23@CheckTxCSR|
	DCD	0x40006701

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EG@PLHCCOK@?$AAT?$AAx?$AAC?$AAS?$AAR?$AA_?$AAH?$AA_?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAa?$AAt?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AAc?$AAl?$AAe?$AAa?$AAr?$AA?5?$AAi?$AAt@| DCB "T"
	DCB	0x0, "x", 0x0, "C", 0x0, "S", 0x0, "R", 0x0, "_", 0x0, "H"
	DCB	0x0, "_", 0x0, "E", 0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r"
	DCB	0x0, " ", 0x0, "a", 0x0, "t", 0x0, " ", 0x0, "E", 0x0, "P"
	DCB	0x0, " ", 0x0, "%", 0x0, "d", 0x0, ",", 0x0, " ", 0x0, "c"
	DCB	0x0, "l", 0x0, "e", 0x0, "a", 0x0, "r", 0x0, " ", 0x0, "i"
	DCB	0x0, "t", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CM@EHMOJMHC@?$AAT?$AAx?$AAC?$AAS?$AAR?$AA?5?$AAT?$AAx?$AAS?$AAt?$AAa?$AAl?$AAl?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AN?$AA?6?$AA?$AA@| DCB "T"
	DCB	0x0, "x", 0x0, "C", 0x0, "S", 0x0, "R", 0x0, " ", 0x0, "T"
	DCB	0x0, "x", 0x0, "S", 0x0, "t", 0x0, "a", 0x0, "l", 0x0, "l"
	DCB	0x0, " ", 0x0, "E", 0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CG@HEKDHLPK@?$AAC?$AAS?$AAR?$AA0?$AA?5?$AAN?$AAA?$AAK?$AA?5?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AN?$AA?6?$AA?$AA@| DCB "C"
	DCB	0x0, "S", 0x0, "R", 0x0, "0", 0x0, " ", 0x0, "N", 0x0, "A"
	DCB	0x0, "K", 0x0, " ", 0x0, "T", 0x0, "i", 0x0, "m", 0x0, "e"
	DCB	0x0, "o", 0x0, "u", 0x0, "t", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CheckTxCSR@CHW@@QAAKE@Z| PROC	; CHW::CheckTxCSR

; 2291 : {

  00000		 |$LN23@CheckTxCSR|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45113|

; 2292 :     PHSMUSB_T pOTG = (PHSMUSB_T)GetOTGContext();

  00004	e59040b0	 ldr         r4, [r0, #0xB0]

; 2293 :     UCHAR csrIndex = INDEX(MappedEP);

  00008	e201500f	 and         r5, r1, #0xF

; 2294 : 
; 2295 :     EnterCriticalSection(&pOTG->regCS);

  0000c	e2840038	 add         r0, r4, #0x38
  00010	eb000000	 bl          EnterCriticalSection

; 2296 :     OUTREG8(&pOTG->pUsbGenRegs->Index, INDEX(MappedEP));

  00014	e5943020	 ldr         r3, [r4, #0x20]

; 2297 :     // First check if RxPktRdy bit is set
; 2298 :     // Read the total no of bytes available
; 2299 :     if (USB_ENDPOINT(MappedEP) == 0) // Endpoint 0, read the COUNT0

  00018	e3550000	 cmp         r5, #0
  0001c	e5c3500e	 strb        r5, [r3, #0xE]

; 2300 :     {
; 2301 :         USHORT reg = INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0);

  00020	e594301c	 ldr         r3, [r4, #0x1C]
  00024	1a000016	 bne         |$LN8@CheckTxCSR|
  00028	e0833205	 add         r3, r3, r5, lsl #4
  0002c	e5d32002	 ldrb        r2, [r3, #2]
  00030	e5d33003	 ldrb        r3, [r3, #3]
  00034	e1823403	 orr         r3, r2, r3, lsl #8

; 2302 :         if (reg & CSR0_H_NAKTimeout)

  00038	e3130080	 tst         r3, #0x80
  0003c	0a00004d	 beq         |$LN1@CheckTxCSR|

; 2303 :         {
; 2304 :             RETAILMSG(1, (TEXT("CSR0 NAK Timeout\r\n")));

  00040	e59f0150	 ldr         r0, [pc, #0x150]
  00044	eb000000	 bl          NKDbgPrintfW

; 2305 :             CLRREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0, CSR0_H_NAKTimeout);

  00048	e594301c	 ldr         r3, [r4, #0x1C]
  0004c	e3a02cff	 mov         r2, #0xFF, 24
  00050	e382107f	 orr         r1, r2, #0x7F
  00054	e083e205	 add         lr, r3, r5, lsl #4
  00058	e5de2002	 ldrb        r2, [lr, #2]
  0005c	e5de3003	 ldrb        r3, [lr, #3]

; 2306 :             // Set the ReqPkt again and see            
; 2307 :             LeaveCriticalSection(&pOTG->regCS);

  00060	e2840038	 add         r0, r4, #0x38
  00064	e1823403	 orr         r3, r2, r3, lsl #8
  00068	e0033001	 and         r3, r3, r1
  0006c	e1a02423	 mov         r2, r3, lsr #8
  00070	e5ce3002	 strb        r3, [lr, #2]
  00074	e5ce2003	 strb        r2, [lr, #3]
  00078	eb000000	 bl          LeaveCriticalSection

; 2308 :             return USB_DEVICE_NOT_RESPONDING_ERROR;

  0007c	e3a06005	 mov         r6, #5
  00080	ea00003f	 b           |$LN9@CheckTxCSR|
  00084		 |$LN8@CheckTxCSR|

; 2309 :         }
; 2310 :     }
; 2311 :     else
; 2312 :     {
; 2313 :         USHORT reg = INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR);

  00084	e0830205	 add         r0, r3, r5, lsl #4
  00088	e5d02002	 ldrb        r2, [r0, #2]
  0008c	e5d03003	 ldrb        r3, [r0, #3]
  00090	e1823403	 orr         r3, r2, r3, lsl #8

; 2314 :         if (reg & TXCSR_H_NAKTimeout)

  00094	e3130080	 tst         r3, #0x80
  00098	0a00000a	 beq         |$LN5@CheckTxCSR|

; 2315 :         {
; 2316 :             CLRREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR, TXCSR_H_NAKTimeout);

  0009c	e5d01002	 ldrb        r1, [r0, #2]
  000a0	e5d03003	 ldrb        r3, [r0, #3]
  000a4	e3a02cff	 mov         r2, #0xFF, 24
  000a8	e382207f	 orr         r2, r2, #0x7F
  000ac	e1813403	 orr         r3, r1, r3, lsl #8
  000b0	e0033002	 and         r3, r3, r2
  000b4	e1a02423	 mov         r2, r3, lsr #8
  000b8	e5c03002	 strb        r3, [r0, #2]
  000bc	e5c02003	 strb        r2, [r0, #3]
  000c0	e3a06005	 mov         r6, #5
  000c4	ea00002c	 b           |$LN19@CheckTxCSR|
  000c8		 |$LN5@CheckTxCSR|

; 2318 :             return USB_DEVICE_NOT_RESPONDING_ERROR;
; 2319 :         }
; 2320 :         else if (reg & TXCSR_H_RxStall)

  000c8	e3130020	 tst         r3, #0x20
  000cc	0a000017	 beq         |$LN3@CheckTxCSR|

; 2321 :         {
; 2322 :             RETAILMSG(1, (TEXT("TxCSR TxStall Error\r\n")));

  000d0	e59f00bc	 ldr         r0, [pc, #0xBC]
  000d4	eb000000	 bl          NKDbgPrintfW

; 2323 :             // Not sure if it should clear in here            
; 2324 :             CLRREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR, TXCSR_H_RxStall);

  000d8	e594301c	 ldr         r3, [r4, #0x1C]
  000dc	e3a02cff	 mov         r2, #0xFF, 24
  000e0	e38210df	 orr         r1, r2, #0xDF
  000e4	e0830205	 add         r0, r3, r5, lsl #4
  000e8	e5d02002	 ldrb        r2, [r0, #2]
  000ec	e5d03003	 ldrb        r3, [r0, #3]

; 2325 :             SETREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR, TXCSR_H_ClrDataTog);

  000f0	e3a06004	 mov         r6, #4
  000f4	e1823403	 orr         r3, r2, r3, lsl #8
  000f8	e0033001	 and         r3, r3, r1
  000fc	e1a02423	 mov         r2, r3, lsr #8
  00100	e5c03002	 strb        r3, [r0, #2]
  00104	e5c02003	 strb        r2, [r0, #3]
  00108	e594301c	 ldr         r3, [r4, #0x1C]
  0010c	e0831205	 add         r1, r3, r5, lsl #4
  00110	e5d12002	 ldrb        r2, [r1, #2]
  00114	e5d13003	 ldrb        r3, [r1, #3]
  00118	e1823403	 orr         r3, r2, r3, lsl #8
  0011c	e3833040	 orr         r3, r3, #0x40
  00120	e1a02423	 mov         r2, r3, lsr #8
  00124	e5c13002	 strb        r3, [r1, #2]
  00128	e5c12003	 strb        r2, [r1, #3]
  0012c	ea000012	 b           |$LN19@CheckTxCSR|
  00130		 |$LN3@CheckTxCSR|

; 2326 :             LeaveCriticalSection(&pOTG->regCS);
; 2327 :             return USB_STALL_ERROR;
; 2328 :         }
; 2329 :         else if (reg & TXCSR_H_Error)

  00130	e3130004	 tst         r3, #4
  00134	0a00000f	 beq         |$LN1@CheckTxCSR|

; 2330 :         {
; 2331 :             RETAILMSG(1, (TEXT("TxCSR_H_Error at EP %d, clear it\r\n"), csrIndex));

  00138	e59f0050	 ldr         r0, [pc, #0x50]
  0013c	e1a01005	 mov         r1, r5
  00140	eb000000	 bl          NKDbgPrintfW

; 2332 :             CLRREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR, TXCSR_H_Error);

  00144	e594301c	 ldr         r3, [r4, #0x1C]
  00148	e3a02cff	 mov         r2, #0xFF, 24
  0014c	e38210fb	 orr         r1, r2, #0xFB
  00150	e0830205	 add         r0, r3, r5, lsl #4
  00154	e5d02002	 ldrb        r2, [r0, #2]
  00158	e5d03003	 ldrb        r3, [r0, #3]
  0015c	e3a06005	 mov         r6, #5
  00160	e1823403	 orr         r3, r2, r3, lsl #8
  00164	e0033001	 and         r3, r3, r1
  00168	e1a02423	 mov         r2, r3, lsr #8
  0016c	e5c03002	 strb        r3, [r0, #2]
  00170	e5c02003	 strb        r2, [r0, #3]
  00174	ea000000	 b           |$LN19@CheckTxCSR|
  00178		 |$LN1@CheckTxCSR|
  00178	e3a06000	 mov         r6, #0

; 2315 :         {
; 2316 :             CLRREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR, TXCSR_H_NAKTimeout);

  0017c		 |$LN19@CheckTxCSR|

; 2317 :             LeaveCriticalSection(&pOTG->regCS);

  0017c	e2840038	 add         r0, r4, #0x38
  00180	eb000000	 bl          LeaveCriticalSection
  00184		 |$LN9@CheckTxCSR|

; 2333 :             LeaveCriticalSection(&pOTG->regCS);
; 2334 :             return USB_DEVICE_NOT_RESPONDING_ERROR;
; 2335 :         }
; 2336 : 
; 2337 :     }
; 2338 :     LeaveCriticalSection(&pOTG->regCS);
; 2339 :     return USB_NO_ERROR;
; 2340 : }

  00184	e1a00006	 mov         r0, r6
  00188	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0018c	e12fff1e	 bx          lr
  00190		 |$LN24@CheckTxCSR|
  00190		 |$LN25@CheckTxCSR|
  00190	00000000	 DCD         |??_C@_1EG@PLHCCOK@?$AAT?$AAx?$AAC?$AAS?$AAR?$AA_?$AAH?$AA_?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAa?$AAt?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AAc?$AAl?$AAe?$AAa?$AAr?$AA?5?$AAi?$AAt@|
  00194		 |$LN26@CheckTxCSR|
  00194	00000000	 DCD         |??_C@_1CM@EHMOJMHC@?$AAT?$AAx?$AAC?$AAS?$AAR?$AA?5?$AAT?$AAx?$AAS?$AAt?$AAa?$AAl?$AAl?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AN?$AA?6?$AA?$AA@|
  00198		 |$LN27@CheckTxCSR|
  00198	00000000	 DCD         |??_C@_1CG@HEKDHLPK@?$AAC?$AAS?$AAR?$AA0?$AA?5?$AAN?$AAA?$AAK?$AA?5?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AN?$AA?6?$AA?$AA@|
  0019c		 |$M45114|

			 ENDP  ; |?CheckTxCSR@CHW@@QAAKE@Z|, CHW::CheckTxCSR

	EXPORT	|?CheckRxCSR@CHW@@QAAKE@Z|		; CHW::CheckRxCSR
	EXPORT	|??_C@_1BK@BOEDCOMO@?$AAN?$AAA?$AAK?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EG@DJCLFNB@?$AAR?$AAx?$AAC?$AAS?$AAR?$AA_?$AAH?$AA_?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAa?$AAt?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AAc?$AAl?$AAe?$AAa?$AAr?$AA?5?$AAi?$AAt@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HE@PPBFEKOG@?$AAD?$AAe?$AAb?$AAu?$AAg?$AA?5?$AAp?$AAu?$AAr?$AAp?$AAo?$AAs?$AAe?$AA?0?$AA?5?$AAr?$AAe?$AAa?$AAd?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAF?$AAI?$AAF?$AAO?$AA?5?$AAa?$AAn?$AAd@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CA@ILNHIEFH@?$AAR?$AAx?$AAT?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@FBGKBILJ@?$AAR?$AAx?$AAI?$AAn?$AAt?$AAe?$AAr?$AAv?$AAa?$AAl?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CA@NLAFCFEK@?$AAR?$AAx?$AAM?$AAa?$AAx?$AAP?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CC@NLOOOCJA@?$AAR?$AAx?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CE@KCNNGIAN@?$AAF?$AAI?$AAF?$AAO?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CE@FLDNEIC@?$AAT?$AAx?$AAF?$AAI?$AAF?$AAO?$AAS?$AAz?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CE@MMHDCDHO@?$AAR?$AAx?$AAF?$AAI?$AAF?$AAO?$AAS?$AAz?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CG@FEBMBIBF@?$AAT?$AAx?$AAF?$AAI?$AAF?$AAO?$AAa?$AAd?$AAd?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CG@MPMMBINL@?$AAR?$AAx?$AAF?$AAI?$AAF?$AAO?$AAa?$AAd?$AAd?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CA@DFGPJAME@?$AAE?$AAP?$AAI?$AAN?$AAF?$AAO?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CK@CCMLIFMF@?$AAC?$AAS?$AAR?$AA0?$AA?5?$AAR?$AAx?$AAS?$AAt?$AAa?$AAl?$AAl?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CE@NCLPFOEK@?$AAC?$AAS?$AAR?$AA0?$AA?5?$AAH?$AAa?$AAl?$AAt?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T45174| DCD	|$LN52@CheckRxCSR|
	DCD	0x4000ae01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@BOEDCOMO@?$AAN?$AAA?$AAK?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AN?$AA?6?$AA?$AA@| DCB "N"
	DCB	0x0, "A", 0x0, "K", 0x0, "T", 0x0, "i", 0x0, "m", 0x0, "e"
	DCB	0x0, "o", 0x0, "u", 0x0, "t", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EG@DJCLFNB@?$AAR?$AAx?$AAC?$AAS?$AAR?$AA_?$AAH?$AA_?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAa?$AAt?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AAc?$AAl?$AAe?$AAa?$AAr?$AA?5?$AAi?$AAt@| DCB "R"
	DCB	0x0, "x", 0x0, "C", 0x0, "S", 0x0, "R", 0x0, "_", 0x0, "H"
	DCB	0x0, "_", 0x0, "E", 0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r"
	DCB	0x0, " ", 0x0, "a", 0x0, "t", 0x0, " ", 0x0, "E", 0x0, "P"
	DCB	0x0, " ", 0x0, "%", 0x0, "d", 0x0, ",", 0x0, " ", 0x0, "c"
	DCB	0x0, "l", 0x0, "e", 0x0, "a", 0x0, "r", 0x0, " ", 0x0, "i"
	DCB	0x0, "t", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HE@PPBFEKOG@?$AAD?$AAe?$AAb?$AAu?$AAg?$AA?5?$AAp?$AAu?$AAr?$AAp?$AAo?$AAs?$AAe?$AA?0?$AA?5?$AAr?$AAe?$AAa?$AAd?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAF?$AAI?$AAF?$AAO?$AA?5?$AAa?$AAn?$AAd@| DCB "D"
	DCB	0x0, "e", 0x0, "b", 0x0, "u", 0x0, "g", 0x0, " ", 0x0, "p"
	DCB	0x0, "u", 0x0, "r", 0x0, "p", 0x0, "o", 0x0, "s", 0x0, "e"
	DCB	0x0, ",", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "a", 0x0, "d"
	DCB	0x0, " ", 0x0, "t", 0x0, "h", 0x0, "e", 0x0, " ", 0x0, "F"
	DCB	0x0, "I", 0x0, "F", 0x0, "O", 0x0, " ", 0x0, "a", 0x0, "n"
	DCB	0x0, "d", 0x0, " ", 0x0, "s", 0x0, "e", 0x0, "e", 0x0, " "
	DCB	0x0, "w", 0x0, "h", 0x0, "a", 0x0, "t", 0x0, " ", 0x0, "i"
	DCB	0x0, "t", 0x0, " ", 0x0, "i", 0x0, "s", 0x0, " ", 0x0, "="
	DCB	0x0, ">", 0x0, " ", 0x0, "h", 0x0, "a", 0x0, "c", 0x0, "k"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CA@ILNHIEFH@?$AAR?$AAx?$AAT?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "R"
	DCB	0x0, "x", 0x0, "T", 0x0, "y", 0x0, "p", 0x0, "e", 0x0, " "
	DCB	0x0, "=", 0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%", 0x0, "x"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@FBGKBILJ@?$AAR?$AAx?$AAI?$AAn?$AAt?$AAe?$AAr?$AAv?$AAa?$AAl?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "R"
	DCB	0x0, "x", 0x0, "I", 0x0, "n", 0x0, "t", 0x0, "e", 0x0, "r"
	DCB	0x0, "v", 0x0, "a", 0x0, "l", 0x0, " ", 0x0, "=", 0x0, " "
	DCB	0x0, "0", 0x0, "x", 0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CA@NLAFCFEK@?$AAR?$AAx?$AAM?$AAa?$AAx?$AAP?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "R"
	DCB	0x0, "x", 0x0, "M", 0x0, "a", 0x0, "x", 0x0, "P", 0x0, " "
	DCB	0x0, "=", 0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%", 0x0, "x"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@NLOOOCJA@?$AAR?$AAx?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "R"
	DCB	0x0, "x", 0x0, "C", 0x0, "o", 0x0, "u", 0x0, "n", 0x0, "t"
	DCB	0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%"
	DCB	0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CE@KCNNGIAN@?$AAF?$AAI?$AAF?$AAO?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "F"
	DCB	0x0, "I", 0x0, "F", 0x0, "O", 0x0, "S", 0x0, "i", 0x0, "z"
	DCB	0x0, "e", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CE@FLDNEIC@?$AAT?$AAx?$AAF?$AAI?$AAF?$AAO?$AAS?$AAz?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "T"
	DCB	0x0, "x", 0x0, "F", 0x0, "I", 0x0, "F", 0x0, "O", 0x0, "S"
	DCB	0x0, "z", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CE@MMHDCDHO@?$AAR?$AAx?$AAF?$AAI?$AAF?$AAO?$AAS?$AAz?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "R"
	DCB	0x0, "x", 0x0, "F", 0x0, "I", 0x0, "F", 0x0, "O", 0x0, "S"
	DCB	0x0, "z", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CG@FEBMBIBF@?$AAT?$AAx?$AAF?$AAI?$AAF?$AAO?$AAa?$AAd?$AAd?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "T"
	DCB	0x0, "x", 0x0, "F", 0x0, "I", 0x0, "F", 0x0, "O", 0x0, "a"
	DCB	0x0, "d", 0x0, "d", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CG@MPMMBINL@?$AAR?$AAx?$AAF?$AAI?$AAF?$AAO?$AAa?$AAd?$AAd?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "R"
	DCB	0x0, "x", 0x0, "F", 0x0, "I", 0x0, "F", 0x0, "O", 0x0, "a"
	DCB	0x0, "d", 0x0, "d", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CA@DFGPJAME@?$AAE?$AAP?$AAI?$AAN?$AAF?$AAO?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "E"
	DCB	0x0, "P", 0x0, "I", 0x0, "N", 0x0, "F", 0x0, "O", 0x0, " "
	DCB	0x0, "=", 0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%", 0x0, "x"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CK@CCMLIFMF@?$AAC?$AAS?$AAR?$AA0?$AA?5?$AAR?$AAx?$AAS?$AAt?$AAa?$AAl?$AAl?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AN?$AA?6?$AA?$AA@| DCB "C"
	DCB	0x0, "S", 0x0, "R", 0x0, "0", 0x0, " ", 0x0, "R", 0x0, "x"
	DCB	0x0, "S", 0x0, "t", 0x0, "a", 0x0, "l", 0x0, "l", 0x0, " "
	DCB	0x0, "E", 0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CE@NCLPFOEK@?$AAC?$AAS?$AAR?$AA0?$AA?5?$AAH?$AAa?$AAl?$AAt?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AN?$AA?6?$AA?$AA@| DCB "C"
	DCB	0x0, "S", 0x0, "R", 0x0, "0", 0x0, " ", 0x0, "H", 0x0, "a"
	DCB	0x0, "l", 0x0, "t", 0x0, " ", 0x0, "E", 0x0, "r", 0x0, "r"
	DCB	0x0, "o", 0x0, "r", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CheckRxCSR@CHW@@QAAKE@Z| PROC	; CHW::CheckRxCSR

; 2343 : {

  00000		 |$LN52@CheckRxCSR|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45171|

; 2344 :     PHSMUSB_T pOTG = (PHSMUSB_T)GetOTGContext();

  00004	e59040b0	 ldr         r4, [r0, #0xB0]

; 2345 :     UCHAR csrIndex = INDEX(MappedEP);

  00008	e201500f	 and         r5, r1, #0xF

; 2346 : 
; 2347 :     EnterCriticalSection(&pOTG->regCS);

  0000c	e2840038	 add         r0, r4, #0x38
  00010	eb000000	 bl          EnterCriticalSection

; 2348 :     OUTREG8(&pOTG->pUsbGenRegs->Index, INDEX(MappedEP));

  00014	e5943020	 ldr         r3, [r4, #0x20]

; 2349 :     // First check if RxPktRdy bit is set
; 2350 :     // Read the total no of bytes available
; 2351 :     if (USB_ENDPOINT(MappedEP) == 0) // Endpoint 0, read the COUNT0

  00018	e3550000	 cmp         r5, #0
  0001c	e5c3500e	 strb        r5, [r3, #0xE]

; 2352 :     {
; 2353 :         USHORT reg = INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0);

  00020	e594301c	 ldr         r3, [r4, #0x1C]
  00024	1a00001c	 bne         |$LN10@CheckRxCSR|
  00028	e0833205	 add         r3, r3, r5, lsl #4
  0002c	e5d32002	 ldrb        r2, [r3, #2]
  00030	e5d33003	 ldrb        r3, [r3, #3]
  00034	e1823403	 orr         r3, r2, r3, lsl #8

; 2354 :         if (reg & CSR0_H_Error)

  00038	e3130010	 tst         r3, #0x10
  0003c	0a000005	 beq         |$LN9@CheckRxCSR|

; 2355 :         {
; 2356 :             RETAILMSG(1, (TEXT("CSR0 Halt Error\r\n")));

  00040	e59f026c	 ldr         r0, [pc, #0x26C]
  00044	eb000000	 bl          NKDbgPrintfW

; 2357 :             CLRREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0, CSR0_H_Error);

  00048	e3a02cff	 mov         r2, #0xFF, 24
  0004c	e38210ef	 orr         r1, r2, #0xEF
  00050	e3a06005	 mov         r6, #5
  00054	ea000006	 b           |$LN49@CheckRxCSR|
  00058		 |$LN9@CheckRxCSR|

; 2360 :             return USB_DEVICE_NOT_RESPONDING_ERROR;
; 2361 :         }
; 2362 :         else if (reg & CSR0_H_RxStall)

  00058	e3130004	 tst         r3, #4
  0005c	0a000080	 beq         |$LN1@CheckRxCSR|

; 2363 :         {
; 2364 :             RETAILMSG(1, (TEXT("CSR0 RxStall Error\r\n")));

  00060	e59f0248	 ldr         r0, [pc, #0x248]
  00064	eb000000	 bl          NKDbgPrintfW

; 2365 :             // Not sure if it should clear in here            
; 2366 :             CLRREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0, CSR0_H_RxStall);

  00068	e3a02cff	 mov         r2, #0xFF, 24
  0006c	e38210fb	 orr         r1, r2, #0xFB
  00070	e3a06004	 mov         r6, #4
  00074		 |$LN49@CheckRxCSR|
  00074	e594301c	 ldr         r3, [r4, #0x1C]
  00078	e0830205	 add         r0, r3, r5, lsl #4
  0007c	e5d02002	 ldrb        r2, [r0, #2]
  00080	e5d03003	 ldrb        r3, [r0, #3]
  00084	e1823403	 orr         r3, r2, r3, lsl #8
  00088	e0033001	 and         r3, r3, r1
  0008c	e1a02423	 mov         r2, r3, lsr #8
  00090	e5c03002	 strb        r3, [r0, #2]
  00094	e5c02003	 strb        r2, [r0, #3]
  00098	ea000072	 b           |$LN45@CheckRxCSR|
  0009c		 |$LN10@CheckRxCSR|

; 2367 :             LeaveCriticalSection(&pOTG->regCS);
; 2368 :             return USB_STALL_ERROR;
; 2369 :         }        
; 2370 :     }
; 2371 :     else
; 2372 :     {
; 2373 :         USHORT reg = INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR);        

  0009c	e083e205	 add         lr, r3, r5, lsl #4
  000a0	e5de2006	 ldrb        r2, [lr, #6]
  000a4	e5de3007	 ldrb        r3, [lr, #7]
  000a8	e1823403	 orr         r3, r2, r3, lsl #8

; 2374 :         DEBUGMSG(ZONE_HCD, (TEXT("CheckRxCSR = 0x%x\r\n"), reg));
; 2375 :         if (reg & RXCSR_H_Error)

  000ac	e3130004	 tst         r3, #4
  000b0	0a000046	 beq         |$LN5@CheckRxCSR|

; 2376 :         {
; 2377 :             RETAILMSG(1, (TEXT("RxCSR_H_Error at EP %d, clear it\r\n"), csrIndex));

  000b4	e59f01f0	 ldr         r0, [pc, #0x1F0]
  000b8	e1a01005	 mov         r1, r5
  000bc	eb000000	 bl          NKDbgPrintfW

; 2378 :             RETAILMSG(1, (TEXT("Debug purpose, read the FIFO and see what it is => hack\r\n")));

  000c0	e59f01e0	 ldr         r0, [pc, #0x1E0]
  000c4	eb000000	 bl          NKDbgPrintfW

; 2379 :             CLRREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR, RXCSR_H_Error);

  000c8	e594301c	 ldr         r3, [r4, #0x1C]
  000cc	e3a02cff	 mov         r2, #0xFF, 24
  000d0	e38210fb	 orr         r1, r2, #0xFB
  000d4	e083e205	 add         lr, r3, r5, lsl #4
  000d8	e5de2006	 ldrb        r2, [lr, #6]
  000dc	e5de3007	 ldrb        r3, [lr, #7]

; 2380 :             RETAILMSG(1, (TEXT("RxType = 0x%x\r\n"), INREG8(&pOTG->pUsbCsrRegs->ep[csrIndex].RxType)));

  000e0	e59f01bc	 ldr         r0, [pc, #0x1BC]
  000e4	e1823403	 orr         r3, r2, r3, lsl #8
  000e8	e0033001	 and         r3, r3, r1
  000ec	e1a02423	 mov         r2, r3, lsr #8
  000f0	e5ce3006	 strb        r3, [lr, #6]
  000f4	e5ce2007	 strb        r2, [lr, #7]
  000f8	e594301c	 ldr         r3, [r4, #0x1C]
  000fc	e0833205	 add         r3, r3, r5, lsl #4
  00100	e5d3100c	 ldrb        r1, [r3, #0xC]
  00104	eb000000	 bl          NKDbgPrintfW

; 2381 :             RETAILMSG(1, (TEXT("RxInterval = 0x%x\r\n"), INREG8(&pOTG->pUsbCsrRegs->ep[csrIndex].RxInterval)));

  00108	e594301c	 ldr         r3, [r4, #0x1C]
  0010c	e59f018c	 ldr         r0, [pc, #0x18C]
  00110	e0833205	 add         r3, r3, r5, lsl #4
  00114	e5d3100d	 ldrb        r1, [r3, #0xD]
  00118	eb000000	 bl          NKDbgPrintfW

; 2382 :             RETAILMSG(1, (TEXT("RxMaxP = 0x%x\r\n"), INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxMaxP)));

  0011c	e594301c	 ldr         r3, [r4, #0x1C]
  00120	e59f0174	 ldr         r0, [pc, #0x174]
  00124	e0833205	 add         r3, r3, r5, lsl #4
  00128	e5d32004	 ldrb        r2, [r3, #4]
  0012c	e5d33005	 ldrb        r3, [r3, #5]
  00130	e1821403	 orr         r1, r2, r3, lsl #8
  00134	eb000000	 bl          NKDbgPrintfW

; 2383 :             RETAILMSG(1, (TEXT("RxCount = 0x%x\r\n"), INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].Count.RxCount)));

  00138	e594301c	 ldr         r3, [r4, #0x1C]
  0013c	e59f0154	 ldr         r0, [pc, #0x154]
  00140	e0833205	 add         r3, r3, r5, lsl #4
  00144	e5d32008	 ldrb        r2, [r3, #8]
  00148	e5d33009	 ldrb        r3, [r3, #9]
  0014c	e1821403	 orr         r1, r2, r3, lsl #8
  00150	eb000000	 bl          NKDbgPrintfW

; 2384 :             RETAILMSG(1, (TEXT("FIFOSize = 0x%x\r\n"), INREG8(&pOTG->pUsbCsrRegs->ep[csrIndex].Config.FIFOSize)));            

  00154	e594301c	 ldr         r3, [r4, #0x1C]
  00158	e59f0134	 ldr         r0, [pc, #0x134]
  0015c	e0833205	 add         r3, r3, r5, lsl #4
  00160	e5d3100f	 ldrb        r1, [r3, #0xF]
  00164	eb000000	 bl          NKDbgPrintfW

; 2385 :             RETAILMSG(1, (TEXT("TxFIFOSz = 0x%x\r\n"), INREG8(&pOTG->pUsbGenRegs->TxFIFOsz)));

  00168	e5943020	 ldr         r3, [r4, #0x20]
  0016c	e59f011c	 ldr         r0, [pc, #0x11C]
  00170	e5d31062	 ldrb        r1, [r3, #0x62]
  00174	eb000000	 bl          NKDbgPrintfW

; 2386 :             RETAILMSG(1, (TEXT("RxFIFOSz = 0x%x\r\n"), INREG8(&pOTG->pUsbGenRegs->RxFIFOsz)));

  00178	e5943020	 ldr         r3, [r4, #0x20]
  0017c	e59f0108	 ldr         r0, [pc, #0x108]
  00180	e5d31063	 ldrb        r1, [r3, #0x63]
  00184	eb000000	 bl          NKDbgPrintfW

; 2387 :             RETAILMSG(1, (TEXT("TxFIFOadd = 0x%x\r\n"), INREG16(&pOTG->pUsbGenRegs->TxFIFOadd)));

  00188	e5943020	 ldr         r3, [r4, #0x20]
  0018c	e59f00f4	 ldr         r0, [pc, #0xF4]
  00190	e5d32064	 ldrb        r2, [r3, #0x64]
  00194	e5d33065	 ldrb        r3, [r3, #0x65]
  00198	e1821403	 orr         r1, r2, r3, lsl #8
  0019c	eb000000	 bl          NKDbgPrintfW

; 2388 :             RETAILMSG(1, (TEXT("RxFIFOadd = 0x%x\r\n"), INREG16(&pOTG->pUsbGenRegs->RxFIFOadd)));

  001a0	e5943020	 ldr         r3, [r4, #0x20]
  001a4	e59f00d8	 ldr         r0, [pc, #0xD8]
  001a8	e5d32066	 ldrb        r2, [r3, #0x66]
  001ac	e5d33067	 ldrb        r3, [r3, #0x67]
  001b0	e1821403	 orr         r1, r2, r3, lsl #8
  001b4	eb000000	 bl          NKDbgPrintfW

; 2389 :             RETAILMSG(1, (TEXT("EPINFO = 0x%x\r\n"), INREG8(&pOTG->pUsbGenRegs->EPInfo)));

  001b8	e5943020	 ldr         r3, [r4, #0x20]
  001bc	e59f00bc	 ldr         r0, [pc, #0xBC]
  001c0	e5d31078	 ldrb        r1, [r3, #0x78]
  001c4	eb000000	 bl          NKDbgPrintfW
  001c8	e3a06005	 mov         r6, #5
  001cc	ea000025	 b           |$LN45@CheckRxCSR|
  001d0		 |$LN5@CheckRxCSR|

; 2390 : 
; 2391 :             LeaveCriticalSection(&pOTG->regCS);
; 2392 :             return USB_DEVICE_NOT_RESPONDING_ERROR;
; 2393 :         }
; 2394 :         else if (reg & RXCSR_H_NAKTimeout)

  001d0	e3130008	 tst         r3, #8
  001d4	0a00000c	 beq         |$LN3@CheckRxCSR|

; 2395 :         {           
; 2396 :             CLRREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR, RXCSR_H_NAKTimeout|RXCSR_H_ReqPkt);

  001d8	e5de1006	 ldrb        r1, [lr, #6]
  001dc	e5de3007	 ldrb        r3, [lr, #7]
  001e0	e3a02cff	 mov         r2, #0xFF, 24
  001e4	e38220d7	 orr         r2, r2, #0xD7
  001e8	e1813403	 orr         r3, r1, r3, lsl #8

; 2397 :             RETAILMSG(1, (TEXT("NAKTimeout\r\n")));

  001ec	e59f0088	 ldr         r0, [pc, #0x88]
  001f0	e0032002	 and         r2, r3, r2
  001f4	e1a03422	 mov         r3, r2, lsr #8
  001f8	e5ce2006	 strb        r2, [lr, #6]
  001fc	e5ce3007	 strb        r3, [lr, #7]
  00200	eb000000	 bl          NKDbgPrintfW
  00204	e3a06005	 mov         r6, #5
  00208	ea000016	 b           |$LN45@CheckRxCSR|
  0020c		 |$LN3@CheckRxCSR|

; 2398 :             LeaveCriticalSection(&pOTG->regCS);
; 2399 :             return USB_DEVICE_NOT_RESPONDING_ERROR;
; 2400 :         }
; 2401 :         else if (reg & RXCSR_H_RxStall)

  0020c	e3130040	 tst         r3, #0x40
  00210	0a000013	 beq         |$LN1@CheckRxCSR|

; 2402 :         {
; 2403 :             DEBUGMSG(ZONE_ERROR, (TEXT("RxCSR RxStall Error at ep %d\r\n"), csrIndex));
; 2404 :             // Not sure if it should clear in here            
; 2405 :             CLRREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR, RXCSR_H_RxStall);

  00214	e5de1006	 ldrb        r1, [lr, #6]
  00218	e5de3007	 ldrb        r3, [lr, #7]
  0021c	e3a02cff	 mov         r2, #0xFF, 24
  00220	e38220bf	 orr         r2, r2, #0xBF
  00224	e1813403	 orr         r3, r1, r3, lsl #8
  00228	e0033002	 and         r3, r3, r2
  0022c	e1a02423	 mov         r2, r3, lsr #8
  00230	e5ce3006	 strb        r3, [lr, #6]
  00234	e5ce2007	 strb        r2, [lr, #7]

; 2406 :             SETREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR, RXCSR_H_ClrDataTog);

  00238	e594301c	 ldr         r3, [r4, #0x1C]
  0023c	e3a06004	 mov         r6, #4
  00240	e0831205	 add         r1, r3, r5, lsl #4
  00244	e5d12006	 ldrb        r2, [r1, #6]
  00248	e5d13007	 ldrb        r3, [r1, #7]
  0024c	e1823403	 orr         r3, r2, r3, lsl #8
  00250	e3833080	 orr         r3, r3, #0x80
  00254	e1a02423	 mov         r2, r3, lsr #8
  00258	e5c13006	 strb        r3, [r1, #6]
  0025c	e5c12007	 strb        r2, [r1, #7]
  00260	ea000000	 b           |$LN45@CheckRxCSR|
  00264		 |$LN1@CheckRxCSR|
  00264	e3a06000	 mov         r6, #0

; 2357 :             CLRREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0, CSR0_H_Error);

  00268		 |$LN45@CheckRxCSR|

; 2358 :             // Set the ReqPkt again and see            
; 2359 :             LeaveCriticalSection(&pOTG->regCS);

  00268	e2840038	 add         r0, r4, #0x38
  0026c	eb000000	 bl          LeaveCriticalSection

; 2407 :             LeaveCriticalSection(&pOTG->regCS);
; 2408 :             return USB_STALL_ERROR;
; 2409 :         }
; 2410 :     }
; 2411 :     LeaveCriticalSection(&pOTG->regCS);
; 2412 :     return USB_NO_ERROR;
; 2413 : }

  00270	e1a00006	 mov         r0, r6
  00274	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00278	e12fff1e	 bx          lr
  0027c		 |$LN53@CheckRxCSR|
  0027c		 |$LN54@CheckRxCSR|
  0027c	00000000	 DCD         |??_C@_1BK@BOEDCOMO@?$AAN?$AAA?$AAK?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AN?$AA?6?$AA?$AA@|
  00280		 |$LN55@CheckRxCSR|
  00280	00000000	 DCD         |??_C@_1CA@DFGPJAME@?$AAE?$AAP?$AAI?$AAN?$AAF?$AAO?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  00284		 |$LN56@CheckRxCSR|
  00284	00000000	 DCD         |??_C@_1CG@MPMMBINL@?$AAR?$AAx?$AAF?$AAI?$AAF?$AAO?$AAa?$AAd?$AAd?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  00288		 |$LN57@CheckRxCSR|
  00288	00000000	 DCD         |??_C@_1CG@FEBMBIBF@?$AAT?$AAx?$AAF?$AAI?$AAF?$AAO?$AAa?$AAd?$AAd?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  0028c		 |$LN58@CheckRxCSR|
  0028c	00000000	 DCD         |??_C@_1CE@MMHDCDHO@?$AAR?$AAx?$AAF?$AAI?$AAF?$AAO?$AAS?$AAz?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  00290		 |$LN59@CheckRxCSR|
  00290	00000000	 DCD         |??_C@_1CE@FLDNEIC@?$AAT?$AAx?$AAF?$AAI?$AAF?$AAO?$AAS?$AAz?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  00294		 |$LN60@CheckRxCSR|
  00294	00000000	 DCD         |??_C@_1CE@KCNNGIAN@?$AAF?$AAI?$AAF?$AAO?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  00298		 |$LN61@CheckRxCSR|
  00298	00000000	 DCD         |??_C@_1CC@NLOOOCJA@?$AAR?$AAx?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  0029c		 |$LN62@CheckRxCSR|
  0029c	00000000	 DCD         |??_C@_1CA@NLAFCFEK@?$AAR?$AAx?$AAM?$AAa?$AAx?$AAP?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  002a0		 |$LN63@CheckRxCSR|
  002a0	00000000	 DCD         |??_C@_1CI@FBGKBILJ@?$AAR?$AAx?$AAI?$AAn?$AAt?$AAe?$AAr?$AAv?$AAa?$AAl?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  002a4		 |$LN64@CheckRxCSR|
  002a4	00000000	 DCD         |??_C@_1CA@ILNHIEFH@?$AAR?$AAx?$AAT?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  002a8		 |$LN65@CheckRxCSR|
  002a8	00000000	 DCD         |??_C@_1HE@PPBFEKOG@?$AAD?$AAe?$AAb?$AAu?$AAg?$AA?5?$AAp?$AAu?$AAr?$AAp?$AAo?$AAs?$AAe?$AA?0?$AA?5?$AAr?$AAe?$AAa?$AAd?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAF?$AAI?$AAF?$AAO?$AA?5?$AAa?$AAn?$AAd@|
  002ac		 |$LN66@CheckRxCSR|
  002ac	00000000	 DCD         |??_C@_1EG@DJCLFNB@?$AAR?$AAx?$AAC?$AAS?$AAR?$AA_?$AAH?$AA_?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAa?$AAt?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AAc?$AAl?$AAe?$AAa?$AAr?$AA?5?$AAi?$AAt@|
  002b0		 |$LN67@CheckRxCSR|
  002b0	00000000	 DCD         |??_C@_1CK@CCMLIFMF@?$AAC?$AAS?$AAR?$AA0?$AA?5?$AAR?$AAx?$AAS?$AAt?$AAa?$AAl?$AAl?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AN?$AA?6?$AA?$AA@|
  002b4		 |$LN68@CheckRxCSR|
  002b4	00000000	 DCD         |??_C@_1CE@NCLPFOEK@?$AAC?$AAS?$AAR?$AA0?$AA?5?$AAH?$AAa?$AAl?$AAt?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AN?$AA?6?$AA?$AA@|
  002b8		 |$M45172|

			 ENDP  ; |?CheckRxCSR@CHW@@QAAKE@Z|, CHW::CheckRxCSR

	EXPORT	|?ReadFIFO@CHW@@UAAKPAXE0KPAH@Z|	; CHW::ReadFIFO
	EXPORT	|??_C@_1DM@OEEGCANF@?$AAR?$AAe?$AAa?$AAd?$AAF?$AAI?$AAF?$AAO?$AA?5?$AAU?$AAS?$AAB?$AA?5?$AAN?$AAo?$AAt?$AA?5?$AAR?$AAe?$AAs?$AAp?$AAo?$AAn?$AAd?$AAi?$AAn?$AAg?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DM@NJMLNKGC@?$AAA?$AAs?$AAs?$AAu?$AAm?$AAe?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAn?$AAe?$AAx?$AAt?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?5?$AAa?$AAr?$AAr?$AAi?$AAv?$AAe?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GC@EHKOAKKD@?$AAW?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?$CB?$AA?$CB?$AA?$CB?$AA?5?$AAN?$AAo?$AAt?$AA?5?$AAe?$AAn?$AAo?$AAu?$AAg?$AAh?$AA?5?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AAs?$AAi?$AAz@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EA@HHCJHPPM@?$AAR?$AAe?$AAa?$AAd?$AAF?$AAI?$AAF?$AAO?$AA?5?$AAC?$AAr?$AAi?$AAt?$AAi?$AAc?$AAa?$AAl?$AAS?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?3?$AA?5?$AAO?$AAU?$AAT?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.h

  00000			 AREA	 |.pdata|, PDATA
|$T45234| DCD	|$LN37@ReadFIFO|
	DCD	0x40005f01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DM@OEEGCANF@?$AAR?$AAe?$AAa?$AAd?$AAF?$AAI?$AAF?$AAO?$AA?5?$AAU?$AAS?$AAB?$AA?5?$AAN?$AAo?$AAt?$AA?5?$AAR?$AAe?$AAs?$AAp?$AAo?$AAn?$AAd?$AAi?$AAn?$AAg?$AA?$AN?$AA?6?$AA?$AA@| DCB "R"
	DCB	0x0, "e", 0x0, "a", 0x0, "d", 0x0, "F", 0x0, "I", 0x0, "F"
	DCB	0x0, "O", 0x0, " ", 0x0, "U", 0x0, "S", 0x0, "B", 0x0, " "
	DCB	0x0, "N", 0x0, "o", 0x0, "t", 0x0, " ", 0x0, "R", 0x0, "e"
	DCB	0x0, "s", 0x0, "p", 0x0, "o", 0x0, "n", 0x0, "d", 0x0, "i"
	DCB	0x0, "n", 0x0, "g", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DM@NJMLNKGC@?$AAA?$AAs?$AAs?$AAu?$AAm?$AAe?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAn?$AAe?$AAx?$AAt?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?5?$AAa?$AAr?$AAr?$AAi?$AAv?$AAe?$AA?$AN?$AA?6?$AA?$AA@| DCB "A"
	DCB	0x0, "s", 0x0, "s", 0x0, "u", 0x0, "m", 0x0, "e", 0x0, " "
	DCB	0x0, "t", 0x0, "h", 0x0, "e", 0x0, " ", 0x0, "n", 0x0, "e"
	DCB	0x0, "x", 0x0, "t", 0x0, " ", 0x0, "d", 0x0, "a", 0x0, "t"
	DCB	0x0, "a", 0x0, " ", 0x0, "a", 0x0, "r", 0x0, "r", 0x0, "i"
	DCB	0x0, "v", 0x0, "e", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GC@EHKOAKKD@?$AAW?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?$CB?$AA?$CB?$AA?$CB?$AA?5?$AAN?$AAo?$AAt?$AA?5?$AAe?$AAn?$AAo?$AAu?$AAg?$AAh?$AA?5?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AAs?$AAi?$AAz@| DCB "W"
	DCB	0x0, "a", 0x0, "r", 0x0, "n", 0x0, "i", 0x0, "n", 0x0, "g"
	DCB	0x0, "!", 0x0, "!", 0x0, "!", 0x0, " ", 0x0, "N", 0x0, "o"
	DCB	0x0, "t", 0x0, " ", 0x0, "e", 0x0, "n", 0x0, "o", 0x0, "u"
	DCB	0x0, "g", 0x0, "h", 0x0, " ", 0x0, "b", 0x0, "u", 0x0, "f"
	DCB	0x0, "f", 0x0, "e", 0x0, "r", 0x0, " ", 0x0, "s", 0x0, "i"
	DCB	0x0, "z", 0x0, "e", 0x0, ".", 0x0, " ", 0x0, "N", 0x0, "e"
	DCB	0x0, "e", 0x0, "d", 0x0, " ", 0x0, "t", 0x0, "o", 0x0, " "
	DCB	0x0, "f", 0x0, "i", 0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EA@HHCJHPPM@?$AAR?$AAe?$AAa?$AAd?$AAF?$AAI?$AAF?$AAO?$AA?5?$AAC?$AAr?$AAi?$AAt?$AAi?$AAc?$AAa?$AAl?$AAS?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?3?$AA?5?$AAO?$AAU?$AAT?$AA?$AN?$AA?6?$AA?$AA@| DCB "R"
	DCB	0x0, "e", 0x0, "a", 0x0, "d", 0x0, "F", 0x0, "I", 0x0, "F"
	DCB	0x0, "O", 0x0, " ", 0x0, "C", 0x0, "r", 0x0, "i", 0x0, "t"
	DCB	0x0, "i", 0x0, "c", 0x0, "a", 0x0, "l", 0x0, "S", 0x0, "e"
	DCB	0x0, "c", 0x0, "t", 0x0, "i", 0x0, "o", 0x0, "n", 0x0, ":"
	DCB	0x0, " ", 0x0, "O", 0x0, "U", 0x0, "T", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ReadFIFO@CHW@@UAAKPAXE0KPAH@Z| PROC	; CHW::ReadFIFO

; 2500 : {

  00000		 |$LN37@ReadFIFO|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M45231|
  00004	e1a07003	 mov         r7, r3
  00008	e1a04002	 mov         r4, r2
  0000c	e1a05001	 mov         r5, r1
  00010	e1a0a000	 mov         r10, r0

; 2501 :     PHSMUSB_T pOTG = (PHSMUSB_T)(pContext);
; 2502 :     DWORD total = 0;
; 2503 :     DWORD remain = 0;
; 2504 :     DWORD dwCount = 0;    
; 2505 :     DWORD dwRead = 0;    
; 2506 :     UCHAR csrIndex;
; 2507 :     // To be implemented
; 2508 :     // First set the index register 
; 2509 :     *pRet = -1;

  00014	e59d8024	 ldr         r8, [sp, #0x24]

; 2510 :     EnterCriticalSection(&pOTG->regCS);

  00018	e3e03000	 mvn         r3, #0
  0001c	e2850038	 add         r0, r5, #0x38
  00020	e5883000	 str         r3, [r8]
  00024	e3a06000	 mov         r6, #0
  00028	eb000000	 bl          EnterCriticalSection

; 2511 :     OUTREG8(&pOTG->pUsbGenRegs->Index, INDEX(endpoint));

  0002c	e595e020	 ldr         lr, [r5, #0x20]
  00030	e204900f	 and         r9, r4, #0xF
  00034	e1b01009	 movs        r1, r9
  00038	e5ce100e	 strb        r1, [lr, #0xE]

; 2512 :     csrIndex = INDEX(endpoint);
; 2513 :     if (USB_ENDPOINT(endpoint) == 0) 
; 2514 :     {
; 2515 :         USHORT reg = INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0);

  0003c	e1a0e001	 mov         lr, r1
  00040	1a000008	 bne         |$LN15@ReadFIFO|
  00044	e595201c	 ldr         r2, [r5, #0x1C]
  00048	e0821201	 add         r1, r2, r1, lsl #4
  0004c	e5d12002	 ldrb        r2, [r1, #2]
  00050	e5d13003	 ldrb        r3, [r1, #3]
  00054	e1823403	 orr         r3, r2, r3, lsl #8

; 2516 :         if(reg & CSR0_H_RxPktRdy) 

  00058	e3130001	 tst         r3, #1
  0005c	0a000039	 beq         |$LN8@ReadFIFO|

; 2517 :             dwCount = INREG8(&pOTG->pUsbCsrRegs->ep[csrIndex].Count.Count0);            

  00060	e5d13008	 ldrb        r3, [r1, #8]

; 2518 :     }
; 2519 :     else

  00064	ea000009	 b           |$LN12@ReadFIFO|
  00068		 |$LN15@ReadFIFO|

; 2520 :     {
; 2521 :         USHORT reg = INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR);

  00068	e595301c	 ldr         r3, [r5, #0x1C]
  0006c	e0831201	 add         r1, r3, r1, lsl #4
  00070	e5d12006	 ldrb        r2, [r1, #6]
  00074	e5d13007	 ldrb        r3, [r1, #7]
  00078	e1823403	 orr         r3, r2, r3, lsl #8

; 2522 :         if (reg & RXCSR_H_RxPktRdy)

  0007c	e3130001	 tst         r3, #1
  00080	0a000030	 beq         |$LN8@ReadFIFO|

; 2523 :             dwCount = INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].Count.RxCount);

  00084	e5d12008	 ldrb        r2, [r1, #8]
  00088	e5d13009	 ldrb        r3, [r1, #9]
  0008c	e1823403	 orr         r3, r2, r3, lsl #8
  00090		 |$LN12@ReadFIFO|

; 2524 :     }
; 2525 : 
; 2526 :     DEBUGMSG(ZONE_TRANSFER, (TEXT("ReadFIFO dwCount=%d, size=%d\r\n"), dwCount, size));
; 2527 :     if (dwCount > size) 

  00090	e59d4020	 ldr         r4, [sp, #0x20]
  00094	e1530004	 cmp         r3, r4
  00098	9a000011	 bls         |$LN11@ReadFIFO|

; 2528 :     { 
; 2529 :         DWORD dwErr = USB_CLIENT_BUFFER_ERROR;
; 2530 :         RETAILMSG(1, (TEXT("Warning!!! Not enough buffer size. Need to fix\r\n")));

  0009c	e59f00d4	 ldr         r0, [pc, #0xD4]
  000a0	eb000000	 bl          NKDbgPrintfW

; 2531 :         RETAILMSG(1, (TEXT("ReadFIFO CriticalSection: OUT\r\n")));

  000a4	e59f00c8	 ldr         r0, [pc, #0xC8]
  000a8	eb000000	 bl          NKDbgPrintfW

; 2532 :         if (size == 0)

  000ac	e3540000	 cmp         r4, #0
  000b0	1a000009	 bne         |$LN10@ReadFIFO|

; 2533 :         {
; 2534 :             RETAILMSG(1, (TEXT("Assume the next data arrive\r\n")));

  000b4	e59f00b4	 ldr         r0, [pc, #0xB4]
  000b8	eb000000	 bl          NKDbgPrintfW

; 2535 :             SetRxDataAvail(USB_ENDPOINT(endpoint));

  000bc	e28a2c02	 add         r2, r10, #2, 24
  000c0	e1d237ba	 ldrh        r3, [r2, #0x7A]
  000c4	e3a01001	 mov         r1, #1

; 2536 :             *pRet = 0;

  000c8	e3a00000	 mov         r0, #0
  000cc	e1833911	 orr         r3, r3, r1, lsl r9

; 2537 :             dwErr = USB_NO_ERROR;

  000d0	e1c237ba	 strh        r3, [r2, #0x7A]
  000d4	e5880000	 str         r0, [r8]

; 2538 :         }
; 2539 :         else

  000d8	ea00001d	 b           |$LN34@ReadFIFO|
  000dc		 |$LN10@ReadFIFO|

; 2540 :             dwErr = USB_CLIENT_BUFFER_ERROR;

  000dc	e3a04f41	 mov         r4, #0x41, 30
  000e0	ea00001c	 b           |$LN33@ReadFIFO|
  000e4		 |$LN11@ReadFIFO|

; 2542 :         return dwErr;
; 2543 :     }
; 2544 :     // Read the data with dwCount
; 2545 :     if (dwCount != 0)  // In case of IN data arrive

  000e4	e3530000	 cmp         r3, #0
  000e8	0a000016	 beq         |$LN8@ReadFIFO|

; 2546 :     {
; 2547 :         DWORD i = 0;
; 2548 :         DWORD *pData = (DWORD *)pBuff;        
; 2549 :         total = dwCount/4;

  000ec	e1b02123	 movs        r2, r3, lsr #2

; 2550 :         remain = dwCount%4;

  000f0	e2031003	 and         r1, r3, #3

; 2551 : 
; 2552 : 		// this is 32-bit align
; 2553 : 		for (i = 0; i < total; i++)

  000f4	0a000007	 beq         |$LN5@ReadFIFO|
  000f8	e28e0008	 add         r0, lr, #8
  000fc	e1a06102	 mov         r6, r2, lsl #2
  00100		 |$LL7@ReadFIFO|

; 2554 : 		{
; 2555 : 			*pData++ = INREG32(&pOTG->pUsbGenRegs->fifo[csrIndex]);

  00100	e5953020	 ldr         r3, [r5, #0x20]
  00104	e2522001	 subs        r2, r2, #1
  00108	e0833100	 add         r3, r3, r0, lsl #2
  0010c	e5933000	 ldr         r3, [r3]
  00110	e4873004	 str         r3, [r7], #4
  00114	1afffff9	 bne         |$LL7@ReadFIFO|
  00118		 |$LN5@ReadFIFO|

; 2556 : 			dwRead = dwRead + 4;
; 2557 : 		}
; 2558 : 	        
; 2559 : 		// Set the pByte equal to the last bytes of data being transferred
; 2560 : 		if (remain != 0)

  00118	e3510000	 cmp         r1, #0
  0011c	0a00000b	 beq         |$LN25@ReadFIFO|

; 2561 : 		{
; 2562 : 			UCHAR* pUCHAR = (UCHAR*) pData;
; 2563 : 			DWORD dwTemp = INREG32(&pOTG->pUsbGenRegs->fifo[csrIndex]);

  00120	e5952020	 ldr         r2, [r5, #0x20]
  00124	e28e3008	 add         r3, lr, #8
  00128	e0866001	 add         r6, r6, r1
  0012c	e0823103	 add         r3, r2, r3, lsl #2
  00130	e5933000	 ldr         r3, [r3]
  00134		 |$LL3@ReadFIFO|

; 2564 : 	        
; 2565 : 			while (remain--)
; 2566 : 			{
; 2567 : 				*pUCHAR++ = (UCHAR) (dwTemp & 0xFF);

  00134	e4c73001	 strb        r3, [r7], #1

; 2568 : 				dwTemp>>=8;

  00138	e1a03423	 mov         r3, r3, lsr #8
  0013c	e2511001	 subs        r1, r1, #1
  00140	1afffffb	 bne         |$LL3@ReadFIFO|

; 2569 : 				dwRead++;
; 2570 : 			}
; 2571 : 		}
; 2572 :     }
; 2573 :     else

  00144	ea000001	 b           |$LN25@ReadFIFO|
  00148		 |$LN8@ReadFIFO|

; 2574 :     {
; 2575 :         RETAILMSG(1, (TEXT("ReadFIFO USB Not Responding\r\n")));

  00148	e59f001c	 ldr         r0, [pc, #0x1C]
  0014c	eb000000	 bl          NKDbgPrintfW
  00150		 |$LN25@ReadFIFO|

; 2576 : //        return USB_DEVICE_NOT_RESPONDING_ERROR;
; 2577 :     }
; 2578 : 
; 2579 : #if 0
; 2580 :     {
; 2581 :         DWORD i = 0;
; 2582 :         UCHAR *pByte = (UCHAR *)pBuff;
; 2583 :         RETAILMSG(1, (TEXT("Receive total of %d byte\r\n"), dwRead));
; 2584 :         for (i = 0; i < dwRead; i++)
; 2585 :             RETAILMSG(1, (TEXT("0x%x "), *(pByte+i)));
; 2586 :         RETAILMSG(1, (TEXT("\r\n")));
; 2587 :     }
; 2588 : #endif    
; 2589 :     *pRet = dwRead;

  00150	e5886000	 str         r6, [r8]
  00154		 |$LN34@ReadFIFO|
  00154	e3a04000	 mov         r4, #0
  00158		 |$LN33@ReadFIFO|

; 2541 :         LeaveCriticalSection(&pOTG->regCS);

  00158	e2850038	 add         r0, r5, #0x38
  0015c	eb000000	 bl          LeaveCriticalSection

; 2590 :     LeaveCriticalSection(&pOTG->regCS);
; 2591 :     return USB_NO_ERROR;
; 2592 : }

  00160	e1a00004	 mov         r0, r4
  00164	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00168	e12fff1e	 bx          lr
  0016c		 |$LN38@ReadFIFO|
  0016c		 |$LN39@ReadFIFO|
  0016c	00000000	 DCD         |??_C@_1DM@OEEGCANF@?$AAR?$AAe?$AAa?$AAd?$AAF?$AAI?$AAF?$AAO?$AA?5?$AAU?$AAS?$AAB?$AA?5?$AAN?$AAo?$AAt?$AA?5?$AAR?$AAe?$AAs?$AAp?$AAo?$AAn?$AAd?$AAi?$AAn?$AAg?$AA?$AN?$AA?6?$AA?$AA@|
  00170		 |$LN40@ReadFIFO|
  00170	00000000	 DCD         |??_C@_1DM@NJMLNKGC@?$AAA?$AAs?$AAs?$AAu?$AAm?$AAe?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAn?$AAe?$AAx?$AAt?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?5?$AAa?$AAr?$AAr?$AAi?$AAv?$AAe?$AA?$AN?$AA?6?$AA?$AA@|
  00174		 |$LN41@ReadFIFO|
  00174	00000000	 DCD         |??_C@_1EA@HHCJHPPM@?$AAR?$AAe?$AAa?$AAd?$AAF?$AAI?$AAF?$AAO?$AA?5?$AAC?$AAr?$AAi?$AAt?$AAi?$AAc?$AAa?$AAl?$AAS?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?3?$AA?5?$AAO?$AAU?$AAT?$AA?$AN?$AA?6?$AA?$AA@|
  00178		 |$LN42@ReadFIFO|
  00178	00000000	 DCD         |??_C@_1GC@EHKOAKKD@?$AAW?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?$CB?$AA?$CB?$AA?$CB?$AA?5?$AAN?$AAo?$AAt?$AA?5?$AAe?$AAn?$AAo?$AAu?$AAg?$AAh?$AA?5?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AAs?$AAi?$AAz@|
  0017c		 |$M45232|

			 ENDP  ; |?ReadFIFO@CHW@@UAAKPAXE0KPAH@Z|, CHW::ReadFIFO

	EXPORT	|?ClearDMAChannel@CHW@@QAAHE@Z|		; CHW::ClearDMAChannel
	EXPORT	|??_C@_1EA@JGLCNLGH@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAC?$AAl?$AAe?$AAa?$AAr?$AAD?$AAM?$AAA?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?$CI?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T45257| DCD	|$LN10@ClearDMACh|
	DCD	0x40001d01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EA@JGLCNLGH@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAC?$AAl?$AAe?$AAa?$AAr?$AAD?$AAM?$AAA?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?$CI?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "F"
	DCB	0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, " "
	DCB	0x0, "t", 0x0, "o", 0x0, " ", 0x0, "C", 0x0, "l", 0x0, "e"
	DCB	0x0, "a", 0x0, "r", 0x0, "D", 0x0, "M", 0x0, "A", 0x0, "C"
	DCB	0x0, "h", 0x0, "a", 0x0, "n", 0x0, "n", 0x0, "e", 0x0, "l"
	DCB	0x0, "(", 0x0, "%", 0x0, "d", 0x0, ")", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ClearDMAChannel@CHW@@QAAHE@Z| PROC	; CHW::ClearDMAChannel

; 2595 : {

  00000		 |$LN10@ClearDMACh|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45254|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 2596 :     PHSMUSB_T pOTG;
; 2597 :     pOTG = (PHSMUSB_T)GetOTGContext();

  0000c	e59530b0	 ldr         r3, [r5, #0xB0]
  00010	e1b06003	 movs        r6, r3

; 2598 :     if (pOTG == NULL)

  00014	1a000004	 bne         |$LN1@ClearDMACh|

; 2599 :     {
; 2600 :         RETAILMSG(1, (TEXT("Failed to ClearDMAChannel(%d)\r\n"), channel));

  00018	e59f0050	 ldr         r0, [pc, #0x50]
  0001c	eb000000	 bl          NKDbgPrintfW

; 2601 :         return FALSE;

  00020	e3a00000	 mov         r0, #0

; 2614 : }

  00024	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$LN1@ClearDMACh|

; 2602 :     }
; 2603 : 
; 2604 :     EnterCriticalSection(&m_csDMAChannel);

  0002c	e2850f72	 add         r0, r5, #0x72, 30
  00030	eb000000	 bl          EnterCriticalSection

; 2605 :     // Write Control
; 2606 :     OUTREG32(&pOTG->pUsbDmaRegs->dma[channel].Cntl, (DWORD)0x00);

  00034	e5963024	 ldr         r3, [r6, #0x24]
  00038	e3a02000	 mov         r2, #0

; 2607 : 
; 2608 :     OUTREG32(&pOTG->pUsbDmaRegs->dma[channel].Addr, (DWORD)0x00);
; 2609 :     // Write count
; 2610 :     OUTREG32(&pOTG->pUsbDmaRegs->dma[channel].Count, (DWORD)0x00);
; 2611 :     LeaveCriticalSection(&m_csDMAChannel);

  0003c	e2850f72	 add         r0, r5, #0x72, 30
  00040	e0833204	 add         r3, r3, r4, lsl #4
  00044	e5832004	 str         r2, [r3, #4]
  00048	e5963024	 ldr         r3, [r6, #0x24]
  0004c	e0833204	 add         r3, r3, r4, lsl #4
  00050	e5832008	 str         r2, [r3, #8]
  00054	e5963024	 ldr         r3, [r6, #0x24]
  00058	e0833204	 add         r3, r3, r4, lsl #4
  0005c	e583200c	 str         r2, [r3, #0xC]
  00060	eb000000	 bl          LeaveCriticalSection

; 2612 : 
; 2613 :     return TRUE;

  00064	e3a00001	 mov         r0, #1

; 2614 : }

  00068	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0006c	e12fff1e	 bx          lr
  00070		 |$LN11@ClearDMACh|
  00070		 |$LN12@ClearDMACh|
  00070	00000000	 DCD         |??_C@_1EA@JGLCNLGH@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAC?$AAl?$AAe?$AAa?$AAr?$AAD?$AAM?$AAA?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?$CI?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  00074		 |$M45255|

			 ENDP  ; |?ClearDMAChannel@CHW@@QAAHE@Z|, CHW::ClearDMAChannel

	EXPORT	|?ProcessDMAChannel@CHW@@QAAHPAXEEH0KK@Z| ; CHW::ProcessDMAChannel

  00000			 AREA	 |.pdata|, PDATA
|$T45276| DCD	|$LN13@ProcessDMA|
	DCD	0x40003301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ProcessDMAChannel@CHW@@QAAHPAXEEH0KK@Z| PROC ; CHW::ProcessDMAChannel

; 2618 : {

  00000		 |$LN13@ProcessDMA|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M45273|
  00004	e1a06003	 mov         r6, r3
  00008	e1a0a002	 mov         r10, r2
  0000c	e1a07001	 mov         r7, r1
  00010	e1a08000	 mov         r8, r0

; 2619 :     PHSMUSB_T pOTG = (PHSMUSB_T)(pContext);
; 2620 :     DWORD dmacntl = 0;
; 2621 : 
; 2622 :     EnterCriticalSection(&m_csDMAChannel);

  00014	e2880f72	 add         r0, r8, #0x72, 30
  00018	e3a04000	 mov         r4, #0
  0001c	eb000000	 bl          EnterCriticalSection

; 2623 :     OUTREG32(&pOTG->pUsbDmaRegs->dma[channel].Cntl, (DWORD)0x00);

  00020	e597e024	 ldr         lr, [r7, #0x24]
  00024	e3a02000	 mov         r2, #0

; 2624 : 
; 2625 :     OUTREG32(&pOTG->pUsbDmaRegs->dma[channel].Addr, (DWORD)0x00);
; 2626 :     // Write count
; 2627 :     OUTREG32(&pOTG->pUsbDmaRegs->dma[channel].Count, (DWORD)0x00);
; 2628 : 
; 2629 :     //  Now actual configure the DMA channel
; 2630 :     //  DMA Mode (D2)
; 2631 :     if (size > dwMaxPacket)

  00028	e59d9028	 ldr         r9, [sp, #0x28]
  0002c	e08ee206	 add         lr, lr, r6, lsl #4
  00030	e58e2004	 str         r2, [lr, #4]
  00034	e597e024	 ldr         lr, [r7, #0x24]
  00038	e59d502c	 ldr         r5, [sp, #0x2C]
  0003c	e08ee206	 add         lr, lr, r6, lsl #4
  00040	e58e2008	 str         r2, [lr, #8]
  00044	e597e024	 ldr         lr, [r7, #0x24]
  00048	e1590005	 cmp         r9, r5

; 2632 :         dmacntl |= DMA_CNTL_DMAMode;

  0004c	83a04004	 movhi       r4, #4
  00050	e08e3206	 add         r3, lr, r6, lsl #4

; 2633 : 
; 2634 :     //  Burst Mode (D10-9)
; 2635 :     if (dwMaxPacket >= 64)

  00054	e3550040	 cmp         r5, #0x40
  00058	e583200c	 str         r2, [r3, #0xC]

; 2636 :         dmacntl |= BURSTMODE_INCR16;

  0005c	23844c06	 orrcs       r4, r4, #6, 24
  00060	2a000004	 bcs         |$LN3@ProcessDMA|

; 2637 :     else if (dwMaxPacket >= 32)

  00064	e3550020	 cmp         r5, #0x20

; 2638 :         dmacntl |= BURSTMODE_INCR8;

  00068	23844b01	 orrcs       r4, r4, #1, 22
  0006c	2a000001	 bcs         |$LN3@ProcessDMA|

; 2639 :     else if (dwMaxPacket >= 16)

  00070	e3550010	 cmp         r5, #0x10

; 2640 :         dmacntl |= BURSTMODE_INCR4;

  00074	23844c02	 orrcs       r4, r4, #2, 24
  00078		 |$LN3@ProcessDMA|

; 2641 :     else
; 2642 :         dmacntl |= BURSTMODE_UNSPEC;
; 2643 : 
; 2644 :     //  Direction (D1) - for sure it is Tx endpoint
; 2645 :     //  Interrupt Enable (D3)
; 2646 :     //  Enable DMA (D0)
; 2647 :     dmacntl |= (DMA_CNTL_Enable|DMA_CNTL_InterruptEnable);
; 2648 :     if (IsTx)

  00078	e59d3020	 ldr         r3, [sp, #0x20]

; 2649 :         dmacntl |= DMA_CNTL_Direction;
; 2650 : 
; 2651 :     //  Set endpoint number
; 2652 :     dmacntl |= (INDEX(endpoint) << 4);
; 2653 : 
; 2654 :     DEBUGMSG(ZONE_HCD, (TEXT("DMA Channel %d\r\n"), channel));
; 2655 :     DEBUGMSG(ZONE_HCD, (TEXT("DMA Channel(%d), Addr (0x%x), Count (0x%x), Cntl(0x%x), ep %d\r\n"),
; 2656 :         channel, (DWORD)ppData, size, dmacntl, INDEX(endpoint)));
; 2657 :     DEBUGMSG(ZONE_HCD, (TEXT("DMA EP %d from 0x%x to 0x%x\r\n"), INDEX(endpoint), (DWORD)ppData, (DWORD)ppData+size));
; 2658 : 
; 2659 :     // Write address
; 2660 :     OUTREG32(&pOTG->pUsbDmaRegs->dma[channel].Addr, (DWORD)ppData);

  0007c	e59d2024	 ldr         r2, [sp, #0x24]
  00080	e3840009	 orr         r0, r4, #9
  00084	e3530000	 cmp         r3, #0
  00088	e5973024	 ldr         r3, [r7, #0x24]
  0008c	13800002	 orrne       r0, r0, #2

; 2661 : 
; 2662 :     // Write count
; 2663 :     OUTREG32(&pOTG->pUsbDmaRegs->dma[channel].Count, (DWORD)size);
; 2664 : 
; 2665 :     // Write Control
; 2666 :     OUTREG32(&pOTG->pUsbDmaRegs->dma[channel].Cntl, (DWORD)dmacntl);

  00090	e20a100f	 and         r1, r10, #0xF
  00094	e0833206	 add         r3, r3, r6, lsl #4
  00098	e5832008	 str         r2, [r3, #8]
  0009c	e5973024	 ldr         r3, [r7, #0x24]
  000a0	e1802201	 orr         r2, r0, r1, lsl #4

; 2667 :     LeaveCriticalSection(&m_csDMAChannel);

  000a4	e2880f72	 add         r0, r8, #0x72, 30
  000a8	e0833206	 add         r3, r3, r6, lsl #4
  000ac	e583900c	 str         r9, [r3, #0xC]
  000b0	e5973024	 ldr         r3, [r7, #0x24]
  000b4	e0833206	 add         r3, r3, r6, lsl #4
  000b8	e5832004	 str         r2, [r3, #4]
  000bc	eb000000	 bl          LeaveCriticalSection

; 2668 : 
; 2669 :     return TRUE;

  000c0	e3a00001	 mov         r0, #1

; 2670 : }

  000c4	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  000c8	e12fff1e	 bx          lr
  000cc		 |$M45274|

			 ENDP  ; |?ProcessDMAChannel@CHW@@QAAHPAXEEH0KK@Z|, CHW::ProcessDMAChannel

	EXPORT	|?WriteDMA@CHW@@UAAHPAXEE0KK0@Z|	; CHW::WriteDMA
	IMPORT	|__rt_udiv|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\ctd.h

  00000			 AREA	 |.pdata|, PDATA
|$T45324| DCD	|$LN27@WriteDMA|
	DCD	0x40005702
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?WriteDMA@CHW@@UAAHPAXEE0KK0@Z| PROC	; CHW::WriteDMA

; 2674 : {

  00000		 |$LN27@WriteDMA|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M45321|
  00008	e5cd3010	 strb        r3, [sp, #0x10]
  0000c	e1a0b002	 mov         r11, r2
  00010	e1a08001	 mov         r8, r1
  00014	e58d0014	 str         r0, [sp, #0x14]

; 2675 :     PHSMUSB_T pOTG = (PHSMUSB_T)pContext;
; 2676 :     CQTD *pQTD = (CQTD *)pData;
; 2677 :     CPipe *pPipe = pQTD->GetQH()->GetPipe();        

  00018	e59d7048	 ldr         r7, [sp, #0x48]

; 2678 :     UCHAR csrIndex = INDEX(endpoint);
; 2679 :     USHORT txcsr;    
; 2680 :     
; 2681 :     DEBUGMSG(ZONE_TRANSFER|ZONE_HCD, (TEXT("WriteDMA: maxpacket=0x%x, size=0x%x\r\n"), 
; 2682 :         dwMaxPacket, size));
; 2683 : 
; 2684 :     EnterCriticalSection(&pOTG->regCS);

  0001c	e2880038	 add         r0, r8, #0x38
  00020	e20ba00f	 and         r10, r11, #0xF
  00024	e597e004	 ldr         lr, [r7, #4]
  00028	e59e9000	 ldr         r9, [lr]
  0002c	eb000000	 bl          EnterCriticalSection

; 2685 :     // First configure the mode
; 2686 :     OUTREG8(&pOTG->pUsbGenRegs->Index, INDEX(endpoint));    

  00030	e598e020	 ldr         lr, [r8, #0x20]

; 2687 :     txcsr = INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR);

  00034	e3a03c4b	 mov         r3, #0x4B, 24

; 2688 : 
; 2689 :     txcsr &= ~(TXCSR_H_AutoSet|TXCSR_H_DMAReqMode|TXCSR_H_DMAReqEn);

  00038	e38350ff	 orr         r5, r3, #0xFF
  0003c	e5cea00e	 strb        r10, [lr, #0xE]
  00040	e598e01c	 ldr         lr, [r8, #0x1C]
  00044	e08e620a	 add         r6, lr, r10, lsl #4
  00048	e5d64002	 ldrb        r4, [r6, #2]
  0004c	e5d6e003	 ldrb        lr, [r6, #3]
  00050	e184e40e	 orr         lr, r4, lr, lsl #8
  00054	e00e3005	 and         r3, lr, r5

; 2690 :     txcsr |= TXCSR_H_Mode;

  00058	e3833a02	 orr         r3, r3, #2, 20

; 2691 :     OUTREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR, txcsr);

  0005c	e1a02423	 mov         r2, r3, lsr #8
  00060	e5c63002	 strb        r3, [r6, #2]
  00064	e5c62003	 strb        r2, [r6, #3]

; 2692 : 
; 2693 :     txcsr = INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR);    

  00068	e598301c	 ldr         r3, [r8, #0x1C]
  0006c	e083020a	 add         r0, r3, r10, lsl #4
  00070	e5d02002	 ldrb        r2, [r0, #2]
  00074	e5d03003	 ldrb        r3, [r0, #3]
  00078	e182e403	 orr         lr, r2, r3, lsl #8

; 2694 :     
; 2695 :     if(txcsr & TXCSR_H_RxStall)

  0007c	e31e0020	 tst         lr, #0x20
  00080	0a000008	 beq         |$LN7@WriteDMA|

; 2696 :     {
; 2697 :        CLRREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR, TXCSR_H_RxStall);

  00084	e5d01002	 ldrb        r1, [r0, #2]
  00088	e5d03003	 ldrb        r3, [r0, #3]
  0008c	e3a02cff	 mov         r2, #0xFF, 24
  00090	e38220df	 orr         r2, r2, #0xDF
  00094	e1813403	 orr         r3, r1, r3, lsl #8
  00098	e0033002	 and         r3, r3, r2
  0009c	e1a02423	 mov         r2, r3, lsr #8
  000a0	e5c03002	 strb        r3, [r0, #2]
  000a4	e5c02003	 strb        r2, [r0, #3]
  000a8		 |$LN7@WriteDMA|

; 2698 :     }
; 2699 : 
; 2700 :     if (size <= dwMaxPacket)

  000a8	e59d4040	 ldr         r4, [sp, #0x40]
  000ac	e59d5044	 ldr         r5, [sp, #0x44]
  000b0	e1540005	 cmp         r4, r5
  000b4	8a000008	 bhi         |$LN6@WriteDMA|
  000b8	e3a03c6b	 mov         r3, #0x6B, 24

; 2701 :     {
; 2702 :         // Disable autoset
; 2703 :         txcsr &= ~(TXCSR_H_AutoSet|TXCSR_H_DMAReqMode);
; 2704 :         txcsr |= TXCSR_H_DMAReqEn;        
; 2705 :         if (pPipe->GetTransferMode() == TRANSFER_DMA0)

  000bc	e5d92014	 ldrb        r2, [r9, #0x14]
  000c0	e38330ff	 orr         r3, r3, #0xFF
  000c4	e00e3003	 and         r3, lr, r3
  000c8	e3836a01	 orr         r6, r3, #1, 20
  000cc	e3520001	 cmp         r2, #1
  000d0	1a00000a	 bne         |$LN2@WriteDMA|

; 2706 :             pQTD->SetStatus(STATUS_WAIT_DMA_WR_RESPONSE);

  000d4	e3a03007	 mov         r3, #7

; 2707 :         else

  000d8	ea000009	 b           |$LN24@WriteDMA|
  000dc		 |$LN6@WriteDMA|

; 2708 :             pQTD->SetStatus(STATUS_WAIT_DMA_WR_2_FIFO_TXPKT_NOTRDY);
; 2709 :     }
; 2710 :     else
; 2711 :     {
; 2712 :         txcsr |= (TXCSR_H_AutoSet|TXCSR_H_DMAReqMode|TXCSR_H_DMAReqEn);

  000dc	e38e3b25	 orr         r3, lr, #0x25, 22
  000e0	e1a06803	 mov         r6, r3, lsl #16

; 2713 :         // Last Packet is Maxpacket size
; 2714 :         if (size % dwMaxPacket == 0)

  000e4	e1a00005	 mov         r0, r5
  000e8	e1a01004	 mov         r1, r4
  000ec	e1a06826	 mov         r6, r6, lsr #16
  000f0	eb000000	 bl          __rt_udiv
  000f4	e3510000	 cmp         r1, #0

; 2715 :             pQTD->SetStatus(STATUS_WAIT_DMA_WR_2_FIFO_TXPKT_RDY);

  000f8	03a03008	 moveq       r3, #8
  000fc	0a000000	 beq         |$LN24@WriteDMA|
  00100		 |$LN2@WriteDMA|

; 2716 :         else // you still need to set the TxPktRdy one more time
; 2717 :             pQTD->SetStatus(STATUS_WAIT_DMA_WR_2_FIFO_TXPKT_NOTRDY);

  00100	e3a03009	 mov         r3, #9
  00104		 |$LN24@WriteDMA|
  00104	e5873028	 str         r3, [r7, #0x28]

; 2718 :             
; 2719 :     }
; 2720 : 
; 2721 :     OUTREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR, txcsr);

  00108	e598301c	 ldr         r3, [r8, #0x1C]
  0010c	e1a02426	 mov         r2, r6, lsr #8

; 2722 : 
; 2723 :     LeaveCriticalSection(&pOTG->regCS);

  00110	e2880038	 add         r0, r8, #0x38
  00114	e083320a	 add         r3, r3, r10, lsl #4
  00118	e5c36002	 strb        r6, [r3, #2]
  0011c	e5c32003	 strb        r2, [r3, #3]
  00120	eb000000	 bl          LeaveCriticalSection

; 2724 :     return(ProcessDMAChannel((void *)pOTG, endpoint, channel, TRUE, ppData, size, dwMaxPacket));

  00124	e59d203c	 ldr         r2, [sp, #0x3C]
  00128	e5dd3010	 ldrb        r3, [sp, #0x10]
  0012c	e59d0014	 ldr         r0, [sp, #0x14]
  00130	e58d2004	 str         r2, [sp, #4]
  00134	e3a0e001	 mov         lr, #1
  00138	e1a0200b	 mov         r2, r11
  0013c	e1a01008	 mov         r1, r8
  00140	e58d500c	 str         r5, [sp, #0xC]
  00144	e58d4008	 str         r4, [sp, #8]
  00148	e58de000	 str         lr, [sp]
  0014c	eb000000	 bl          |?ProcessDMAChannel@CHW@@QAAHPAXEEH0KK@Z|

; 2725 :     
; 2726 : }

  00150	e28dd018	 add         sp, sp, #0x18
  00154	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00158	e12fff1e	 bx          lr
  0015c		 |$M45322|

			 ENDP  ; |?WriteDMA@CHW@@UAAHPAXEE0KK0@Z|, CHW::WriteDMA

	EXPORT	|?WriteFIFO@CHW@@UAAHPAXE0K@Z|		; CHW::WriteFIFO

  00000			 AREA	 |.pdata|, PDATA
|$T45344| DCD	|$LN14@WriteFIFO|
	DCD	0x40002501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?WriteFIFO@CHW@@UAAHPAXE0K@Z| PROC	; CHW::WriteFIFO

; 2729 : {

  00000		 |$LN14@WriteFIFO|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M45341|
  00004	e1a04003	 mov         r4, r3
  00008	e1a07001	 mov         r7, r1

; 2730 :     PHSMUSB_T pOTG = (PHSMUSB_T)pContext;
; 2731 :     int total  = size/4;
; 2732 :     int remain = size%4;
; 2733 :     int i;
; 2734 :     DWORD *pDword = (DWORD *)pData;
; 2735 :     UCHAR csrIndex;
; 2736 : 
; 2737 :     //memdump((uchar *)pData, (USHORT)size, 0);
; 2738 :     // Critical section would be handled outside
; 2739 :     DEBUGMSG(ZONE_HCD, (TEXT("WriteFIFO: total (0x%x), remain (0x%x), size(0x%x)\r\n"), total, remain, size));
; 2740 :     // Set Index register again
; 2741 :     OUTREG8(&pOTG->pUsbGenRegs->Index, INDEX(endpoint));

  0000c	e5970020	 ldr         r0, [r7, #0x20]
  00010	e59de014	 ldr         lr, [sp, #0x14]
  00014	e202600f	 and         r6, r2, #0xF
  00018	e5c0600e	 strb        r6, [r0, #0xE]
  0001c	e20e0003	 and         r0, lr, #3
  00020	e1a0512e	 mov         r5, lr, lsr #2

; 2742 :     csrIndex = INDEX(endpoint);
; 2743 : 
; 2744 :     // Zero-length data transferred
; 2745 :     if (size == 0)

  00024	e35e0000	 cmp         lr, #0

; 2746 :         return TRUE;

  00028	0a000016	 beq         |$LN1@WriteFIFO|

; 2747 : 
; 2748 :     // this is 32-bit align
; 2749 :     for (i = 0; i < total; i++)

  0002c	e3550000	 cmp         r5, #0
  00030	da000006	 ble         |$LN4@WriteFIFO|
  00034	e2861008	 add         r1, r6, #8
  00038		 |$LL6@WriteFIFO|

; 2750 :     {
; 2751 :         OUTREG32(&pOTG->pUsbGenRegs->fifo[csrIndex], *pDword++);

  00038	e5973020	 ldr         r3, [r7, #0x20]
  0003c	e4942004	 ldr         r2, [r4], #4
  00040	e2555001	 subs        r5, r5, #1
  00044	e0833101	 add         r3, r3, r1, lsl #2
  00048	e5832000	 str         r2, [r3]
  0004c	1afffff9	 bne         |$LL6@WriteFIFO|
  00050		 |$LN4@WriteFIFO|

; 2752 :     }
; 2753 : 
; 2754 :     if (remain != 0)

  00050	e3500000	 cmp         r0, #0
  00054	0a00000b	 beq         |$LN1@WriteFIFO|

; 2755 :     {
; 2756 :         // Pointer to the first byte of data
; 2757 :         USHORT *pWORD =(USHORT *)pDword;
; 2758 : 
; 2759 :         // Finally if there is remain
; 2760 :         if (remain & 0x2)  // either 2 or 3

  00058	e3100002	 tst         r0, #2

; 2761 :         {
; 2762 :             // Write 2 bytes to there
; 2763 :             OUTREG16(&pOTG->pUsbGenRegs->fifo[csrIndex], *pWORD++);        

  0005c	15972020	 ldrne       r2, [r7, #0x20]
  00060	10d410b2	 ldrneh      r1, [r4], #2
  00064	12863008	 addne       r3, r6, #8
  00068	10823103	 addne       r3, r2, r3, lsl #2
  0006c	11c310b0	 strneh      r1, [r3]

; 2764 :         }
; 2765 : 
; 2766 :         if (remain & 0x1)

  00070	e3100001	 tst         r0, #1

; 2767 :         {
; 2768 :             // Write 1 byte to there
; 2769 :             OUTREG8(&pOTG->pUsbGenRegs->fifo[csrIndex], *((UCHAR*)pWORD));

  00074	15972020	 ldrne       r2, [r7, #0x20]
  00078	15d41000	 ldrneb      r1, [r4]
  0007c	12863008	 addne       r3, r6, #8
  00080	10823103	 addne       r3, r2, r3, lsl #2
  00084	15c31000	 strneb      r1, [r3]
  00088		 |$LN1@WriteFIFO|

; 2770 :         }
; 2771 :     }
; 2772 : 
; 2773 : 	return TRUE;       

  00088	e3a00001	 mov         r0, #1

; 2774 : }

  0008c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$M45342|

			 ENDP  ; |?WriteFIFO@CHW@@UAAHPAXE0K@Z|, CHW::WriteFIFO

	EXPORT	|?SendOutDMA@CHW@@UAAHEPAX@Z|		; CHW::SendOutDMA
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\ctd.h

  00000			 AREA	 |.pdata|, PDATA
|$T45365| DCD	|$LN10@SendOutDMA|
	DCD	0x40001d01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SendOutDMA@CHW@@UAAHEPAX@Z| PROC	; CHW::SendOutDMA

; 2782 : {

  00000		 |$LN10@SendOutDMA|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45362|
  00004	e1a05002	 mov         r5, r2
  00008	e1a06001	 mov         r6, r1

; 2783 :     CQTD *pQTD = (CQTD *)pData;
; 2784 :     PHSMUSB_T pOTG;    
; 2785 :     BOOL    bResult = FALSE;
; 2786 :     UCHAR   csrIndex;
; 2787 : 
; 2788 : #ifdef DEBUG
; 2789 :     CPipe *pPipe = pQTD->GetQH()->GetPipe();  
; 2790 : #endif
; 2791 : 
; 2792 :     pOTG = (PHSMUSB_T)GetOTGContext();

  0000c	e59030b0	 ldr         r3, [r0, #0xB0]
  00010	e1b04003	 movs        r4, r3

; 2793 :     if (pOTG == NULL)
; 2794 :     {
; 2795 :         DEBUGMSG(ZONE_ERROR, (TEXT("Failed to read the FIFO for ep %d\r\n"), endpoint));
; 2796 :         return bResult;

  00014	03a00000	 moveq       r0, #0

; 2820 : 
; 2821 : }

  00018	08bd4070	 ldmeqia     sp!, {r4 - r6, lr}
  0001c	012fff1e	 bxeq        lr

; 2797 :     }
; 2798 :         
; 2799 :     // Set Index Register
; 2800 :     EnterCriticalSection(&pOTG->regCS);    

  00020	e2840038	 add         r0, r4, #0x38
  00024	eb000000	 bl          EnterCriticalSection

; 2801 :     OUTREG8(&pOTG->pUsbGenRegs->Index, INDEX(endpoint));

  00028	e5943020	 ldr         r3, [r4, #0x20]
  0002c	e206200f	 and         r2, r6, #0xF

; 2802 :     csrIndex = INDEX(endpoint);
; 2803 : 
; 2804 : #ifdef DEBUG
; 2805 :     DWORD DataToggle = (INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR) & TXCSR_H_DataToggle);
; 2806 :     DEBUGMSG(ZONE_HCD|0, (TEXT("[DataToggle]:SendOutDMA:Data OUT Trasaction on EP %d Device Addr %d DataToggle = 0x%x\r\n"), 
; 2807 :                 csrIndex, pPipe->GetReservedDeviceAddr(), DataToggle));
; 2808 : #endif
; 2809 : 
; 2810 :     // 2. Set the SetupPkt & TxPtRdy bits
; 2811 :     SETREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR, TXCSR_H_TxPktRdy);
; 2812 :     
; 2813 :     DEBUGMSG(ZONE_HCD|ZONE_DEBUG, (TEXT("SendOutDMA at ep %d (index %d) TxPktRdy\r\n"), endpoint, csrIndex));
; 2814 : 
; 2815 :     // 3. Wait for transfer interrupt signal
; 2816 :     pQTD->SetStatus(STATUS_WAIT_RESPONSE);            

  00030	e3a0e003	 mov         lr, #3
  00034	e5c3200e	 strb        r2, [r3, #0xE]
  00038	e594301c	 ldr         r3, [r4, #0x1C]

; 2817 :     LeaveCriticalSection(&pOTG->regCS);

  0003c	e2840038	 add         r0, r4, #0x38
  00040	e0831202	 add         r1, r3, r2, lsl #4
  00044	e5d12002	 ldrb        r2, [r1, #2]
  00048	e5d13003	 ldrb        r3, [r1, #3]
  0004c	e1823403	 orr         r3, r2, r3, lsl #8
  00050	e3833001	 orr         r3, r3, #1
  00054	e1a02423	 mov         r2, r3, lsr #8
  00058	e5c13002	 strb        r3, [r1, #2]
  0005c	e5c12003	 strb        r2, [r1, #3]
  00060	e585e028	 str         lr, [r5, #0x28]
  00064	eb000000	 bl          LeaveCriticalSection

; 2818 : 
; 2819 :     return TRUE;

  00068	e3a00001	 mov         r0, #1

; 2820 : 
; 2821 : }

  0006c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00070	e12fff1e	 bx          lr
  00074		 |$M45363|

			 ENDP  ; |?SendOutDMA@CHW@@UAAHEPAX@Z|, CHW::SendOutDMA

	EXPORT	|?ResetEndPoint@CHW@@QAAXE@Z|		; CHW::ResetEndPoint
	EXPORT	|??_C@_1EI@KCPHDJG@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAa?$AAd?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAF?$AAI?$AAF?$AAO?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAe?$AAp?$AA?5?$AA?$CF@| [ DATA ] ; `string'
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T45381| DCD	|$LN10@ResetEndPo|
	DCD	0x40000f01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EI@KCPHDJG@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAa?$AAd?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAF?$AAI?$AAF?$AAO?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAe?$AAp?$AA?5?$AA?$CF@| DCB "F"
	DCB	0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, " "
	DCB	0x0, "t", 0x0, "o", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "a"
	DCB	0x0, "d", 0x0, " ", 0x0, "t", 0x0, "h", 0x0, "e", 0x0, " "
	DCB	0x0, "F", 0x0, "I", 0x0, "F", 0x0, "O", 0x0, " ", 0x0, "f"
	DCB	0x0, "o", 0x0, "r", 0x0, " ", 0x0, "e", 0x0, "p", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResetEndPoint@CHW@@QAAXE@Z| PROC	; CHW::ResetEndPoint

; 3230 : {

  00000		 |$LN10@ResetEndPo|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M45378|

; 3231 :     PHSMUSB_T pOTG;
; 3232 :     DWORD csrIndex;
; 3233 :     DWORD dir;
; 3234 :     UCHAR endpoint;
; 3235 : 
; 3236 :     pOTG = (PHSMUSB_T)GetOTGContext();

  00004	e59030b0	 ldr         r3, [r0, #0xB0]
  00008	e1b04003	 movs        r4, r3

; 3237 :     if (pOTG == NULL)

  0000c	1a000003	 bne         |$LN1@ResetEndPo|

; 3238 :     {
; 3239 :         RETAILMSG(1, (TEXT("Failed to read the FIFO for ep %d\r\n"), endpointAddress));

  00010	e59f0020	 ldr         r0, [pc, #0x20]
  00014	eb000000	 bl          NKDbgPrintfW

; 3278 : }

  00018	e8bd4010	 ldmia       sp!, {r4, lr}
  0001c	e12fff1e	 bx          lr
  00020		 |$LN1@ResetEndPo|

; 3240 :         return;
; 3241 :     }
; 3242 : 
; 3243 :     csrIndex = INDEX(endpointAddress);
; 3244 :     dir = USB_ENDPOINT_DIRECTION_IN(endpointAddress);
; 3245 :     endpoint = USB_ENDPOINT(endpointAddress);
; 3246 : 
; 3247 :     EnterCriticalSection(&pOTG->regCS); 

  00020	e2840038	 add         r0, r4, #0x38
  00024	eb000000	 bl          EnterCriticalSection

; 3248 : #if 0
; 3249 :     OUTREG8(&pOTG->pUsbGenRegs->Index, INDEX(endpoint));
; 3250 : 
; 3251 :     DEBUGMSG(ZONE_DEBUG, (TEXT("CHW::ResetEndpoint at ep %d, dir IN %d, csrIndex %d\r\n"),
; 3252 :         endpoint, dir, csrIndex));
; 3253 :     if (USB_ENDPOINT(endpoint) == 0)
; 3254 :     {
; 3255 :         DEBUGMSG(ZONE_HCD, (TEXT("CSR0 register = 0x%x\r\n"), INREG16(&pOTG->pUsbCsrRegs->ep[0].CSR.CSR0)));
; 3256 :         SETREG16(&pOTG->pUsbCsrRegs->ep[0].CSR.CSR0, CSR0_H_FlushFIFO);
; 3257 :     }
; 3258 :     else {
; 3259 :         if (dir)
; 3260 :         {
; 3261 :             SETREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR, RXCSR_H_FlushFIFO|RXCSR_H_ClrDataTog);
; 3262 :             CLRREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR, RXCSR_H_ReqPkt);
; 3263 :             DEBUGMSG(ZONE_HCD, (TEXT("FlushFIFO::RXCSR (%d) register = 0x%x\r\n"), endpoint, 
; 3264 :                 INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR)));
; 3265 :             DEBUGMSG(ZONE_HCD, (TEXT("FlushFIFO: RxCount(0x%x)\r\n"), INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].Count.RxCount)));
; 3266 : 
; 3267 : 
; 3268 :         }
; 3269 :         else
; 3270 :         {
; 3271 :             DEBUGMSG(ZONE_HCD, (TEXT("CHW::ResetEndPoint::FlushFIFO::TXCSR (%d) register = 0x%x\r\n"), endpoint, 
; 3272 :                 INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR)));
; 3273 :             SETREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR, TXCSR_H_FlushFIFO|TXCSR_H_ClrDataTog);
; 3274 :         }
; 3275 :     }
; 3276 : #endif    
; 3277 :     LeaveCriticalSection(&pOTG->regCS);

  00028	e2840038	 add         r0, r4, #0x38
  0002c	eb000000	 bl          LeaveCriticalSection

; 3278 : }

  00030	e8bd4010	 ldmia       sp!, {r4, lr}
  00034	e12fff1e	 bx          lr
  00038		 |$LN11@ResetEndPo|
  00038		 |$LN12@ResetEndPo|
  00038	00000000	 DCD         |??_C@_1EI@KCPHDJG@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAa?$AAd?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAF?$AAI?$AAF?$AAO?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAe?$AAp?$AA?5?$AA?$CF@|
  0003c		 |$M45379|

			 ENDP  ; |?ResetEndPoint@CHW@@QAAXE@Z|, CHW::ResetEndPoint

	EXPORT	|?LockEP0@CHW@@UAAHE@Z|			; CHW::LockEP0

  00000			 AREA	 |.pdata|, PDATA
|$T45396| DCD	|$LN9@LockEP0|
	DCD	0x40001201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?LockEP0@CHW@@UAAHE@Z| PROC		; CHW::LockEP0

; 3286 : {

  00000		 |$LN9@LockEP0|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45393|
  00004	e1a06001	 mov         r6, r1
  00008	e1a05000	 mov         r5, r0

; 3287 :     BOOL fLock = FALSE;
; 3288 : 
; 3289 :     DEBUGMSG(ZONE_HCD, (TEXT("LockEP0 => 0x%x\r\n"), address));
; 3290 : 
; 3291 :     EnterCriticalSection(&m_LockEP0DeviceAddress.hLockCS);

  0000c	e2850d0a	 add         r0, r5, #0xA, 26
  00010	e3a04000	 mov         r4, #0
  00014	eb000000	 bl          EnterCriticalSection

; 3292 : 
; 3293 :     if (m_LockEP0DeviceAddress.ucLockEP == 0xFF)

  00018	e5d5327c	 ldrb        r3, [r5, #0x27C]
  0001c	e35300ff	 cmp         r3, #0xFF

; 3294 :     {
; 3295 :         m_LockEP0DeviceAddress.ucLockEP = address;

  00020	05c5627c	 streqb      r6, [r5, #0x27C]
  00024	0a000001	 beq         |$LN6@LockEP0|

; 3296 :         fLock = TRUE;       
; 3297 :     }
; 3298 :     else if (m_LockEP0DeviceAddress.ucLockEP == address)

  00028	e1530006	 cmp         r3, r6
  0002c	1a000000	 bne         |$LN1@LockEP0|
  00030		 |$LN6@LockEP0|

; 3299 :     {
; 3300 :         DEBUGMSG(1, (TEXT("Address %d for ep 0  is not unlocked\r\n"), address));
; 3301 :         fLock = TRUE;

  00030	e3a04001	 mov         r4, #1
  00034		 |$LN1@LockEP0|

; 3302 :     }    
; 3303 :     LeaveCriticalSection(&m_LockEP0DeviceAddress.hLockCS);

  00034	e2850d0a	 add         r0, r5, #0xA, 26
  00038	eb000000	 bl          LeaveCriticalSection

; 3304 :     return fLock;
; 3305 : }

  0003c	e1a00004	 mov         r0, r4
  00040	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$M45394|

			 ENDP  ; |?LockEP0@CHW@@UAAHE@Z|, CHW::LockEP0

	EXPORT	|?UnlockEP0@CHW@@UAAXE@Z|		; CHW::UnlockEP0

  00000			 AREA	 |.pdata|, PDATA
|$T45405| DCD	|$LN7@UnlockEP0|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UnlockEP0@CHW@@UAAXE@Z| PROC		; CHW::UnlockEP0

; 3312 : {

  00000		 |$LN7@UnlockEP0|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45402|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 3313 :     DEBUGMSG(ZONE_HCD, (TEXT("UnLockEP0 => 0x%x\r\n"), address));
; 3314 :     EnterCriticalSection(&m_LockEP0DeviceAddress.hLockCS);

  0000c	e2850d0a	 add         r0, r5, #0xA, 26
  00010	eb000000	 bl          EnterCriticalSection

; 3315 :     if (m_LockEP0DeviceAddress.ucLockEP == address)

  00014	e5d5327c	 ldrb        r3, [r5, #0x27C]

; 3316 :         m_LockEP0DeviceAddress.ucLockEP = 0xFF;
; 3317 :     else
; 3318 :         DEBUGMSG(1, (TEXT("Cannot unlock as used by other device address %d\r\n"), address));
; 3319 :     LeaveCriticalSection(&m_LockEP0DeviceAddress.hLockCS);

  00018	e2850d0a	 add         r0, r5, #0xA, 26
  0001c	e1530004	 cmp         r3, r4
  00020	03a030ff	 moveq       r3, #0xFF
  00024	05c5327c	 streqb      r3, [r5, #0x27C]
  00028	eb000000	 bl          LeaveCriticalSection

; 3320 : }

  0002c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00030	e12fff1e	 bx          lr
  00034		 |$M45403|

			 ENDP  ; |?UnlockEP0@CHW@@UAAXE@Z|, CHW::UnlockEP0

	EXPORT	|?IsDeviceLockEP0@CHW@@UAAHE@Z|		; CHW::IsDeviceLockEP0

  00000			 AREA	 |.pdata|, PDATA
|$T45416| DCD	|$LN6@IsDeviceLo|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsDeviceLockEP0@CHW@@UAAHE@Z| PROC	; CHW::IsDeviceLockEP0

; 3323 : {

  00000		 |$LN6@IsDeviceLo|
  00000		 |$M45413|

; 3324 :     if (m_LockEP0DeviceAddress.ucLockEP == address)

  00000	e5d0327c	 ldrb        r3, [r0, #0x27C]
  00004	e1530001	 cmp         r3, r1

; 3325 :         return TRUE;

  00008	03a00001	 moveq       r0, #1

; 3326 : 
; 3327 :     return FALSE;

  0000c	13a00000	 movne       r0, #0

; 3328 : }

  00010	e12fff1e	 bx          lr
  00014		 |$M45414|

			 ENDP  ; |?IsDeviceLockEP0@CHW@@UAAHE@Z|, CHW::IsDeviceLockEP0

	EXPORT	|Host_ResumeIRQ|

  00000			 AREA	 |.pdata|, PDATA
|$T45425| DCD	|$LN5@Host_Resum|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Host_ResumeIRQ| PROC

; 3348 : {

  00000		 |$LN5@Host_Resum|
  00000		 |$M45422|

; 3349 :     UNREFERENCED_PARAMETER(pHSMUSBContext);
; 3350 :     DEBUGMSG(ZONE_DEBUG, (TEXT("+Host_ResumeIRQ\r\n")));
; 3351 :     return ERROR_SUCCESS;

  00000	e3a00000	 mov         r0, #0

; 3352 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M45423|

			 ENDP  ; |Host_ResumeIRQ|

	EXPORT	|Host_ProcessEPxRx|

  00000			 AREA	 |.pdata|, PDATA
|$T45437| DCD	|$LN5@Host_Proce|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Host_ProcessEPxRx| PROC

; 3371 : {        

  00000		 |$LN5@Host_Proce|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45434|

; 3372 :     PHSMUSB_T pHsUsb = (PHSMUSB_T)pHSMUSBContext;
; 3373 :     SMHCDPdd * pPdd = (SMHCDPdd *)pHsUsb->pContext[HOST_MODE-1];
; 3374 :     CMhcd *pMhcd = (CMhcd *)pPdd->lpvMHCDMddObject;

  00004	e5903014	 ldr         r3, [r0, #0x14]

; 3375 : 
; 3376 :     DEBUGMSG(ZONE_TRANSFER|ZONE_HCD, (TEXT("Host_ProcessEPxRx ep %d indx %d+\r\n"), endpoint, R_RX_INDEX(endpoint)));
; 3377 :     
; 3378 :     pMhcd->SignalCheckForDoneTransfers((unsigned char)R_RX_INDEX(endpoint), 0);

  00008	e3a02000	 mov         r2, #0
  0000c	e20110ff	 and         r1, r1, #0xFF
  00010	e5930004	 ldr         r0, [r3, #4]
  00014	e5903000	 ldr         r3, [r0]
  00018	e59330a0	 ldr         r3, [r3, #0xA0]
  0001c	e1a0e00f	 mov         lr, pc
  00020	e12fff13	 bx          r3

; 3379 :     DEBUGMSG(ZONE_HCD, (TEXT("Host_ProcessEPxRx-\r\n")));
; 3380 : 
; 3381 :     return ERROR_SUCCESS;

  00024	e3a00000	 mov         r0, #0

; 3382 : }

  00028	e49de004	 ldr         lr, [sp], #4
  0002c	e12fff1e	 bx          lr
  00030		 |$M45435|

			 ENDP  ; |Host_ProcessEPxRx|

	EXPORT	|Host_ProcessEPxTx|

  00000			 AREA	 |.pdata|, PDATA
|$T45449| DCD	|$LN5@Host_Proce@2|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Host_ProcessEPxTx| PROC

; 3402 : {        

  00000		 |$LN5@Host_Proce@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45446|

; 3403 :     PHSMUSB_T pHsUsb = (PHSMUSB_T)pHSMUSBContext;
; 3404 :     SMHCDPdd * pPdd = (SMHCDPdd *)pHsUsb->pContext[HOST_MODE-1];
; 3405 :     CMhcd *pMhcd = (CMhcd *)pPdd->lpvMHCDMddObject;

  00004	e5903014	 ldr         r3, [r0, #0x14]

; 3406 : 
; 3407 :     DEBUGMSG(ZONE_TRANSFER|ZONE_HCD, (TEXT("Host_ProcessEPxTx mapped ep %d indx %d\r\n"), endpoint, R_TX_INDEX(endpoint)));
; 3408 :     DEBUGMSG(ZONE_TRANSFER, (TEXT("Host_ProcessEPxTx mapped ep %d indx %d\r\n"), endpoint, R_TX_INDEX(endpoint)));
; 3409 :     pMhcd->SignalCheckForDoneTransfers((unsigned char)R_TX_INDEX(endpoint), 1);

  00008	e3a02001	 mov         r2, #1
  0000c	e20110ff	 and         r1, r1, #0xFF
  00010	e5930004	 ldr         r0, [r3, #4]
  00014	e5903000	 ldr         r3, [r0]
  00018	e59330a0	 ldr         r3, [r3, #0xA0]
  0001c	e1a0e00f	 mov         lr, pc
  00020	e12fff13	 bx          r3

; 3410 :     DEBUGMSG(ZONE_HCD, (TEXT("Host_ProcessEPxTx-\r\n")));
; 3411 : 
; 3412 :     return ERROR_SUCCESS;

  00024	e3a00000	 mov         r0, #0

; 3413 : }

  00028	e49de004	 ldr         lr, [sp], #4
  0002c	e12fff1e	 bx          lr
  00030		 |$M45447|

			 ENDP  ; |Host_ProcessEPxTx|

	EXPORT	|Host_ProcessEP0|

  00000			 AREA	 |.pdata|, PDATA
|$T45466| DCD	|$LN7@Host_Proce@3|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Host_ProcessEP0| PROC

; 3433 : {

  00000		 |$LN7@Host_Proce@3|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45463|

; 3434 :     return Host_ProcessEPxTx(pHSMUSBContext, 0);

  00004	e5903014	 ldr         r3, [r0, #0x14]
  00008	e3a02001	 mov         r2, #1
  0000c	e3a01000	 mov         r1, #0
  00010	e5930004	 ldr         r0, [r3, #4]
  00014	e5903000	 ldr         r3, [r0]
  00018	e59330a0	 ldr         r3, [r3, #0xA0]
  0001c	e1a0e00f	 mov         lr, pc
  00020	e12fff13	 bx          r3
  00024	e3a00000	 mov         r0, #0

; 3435 : }

  00028	e49de004	 ldr         lr, [sp], #4
  0002c	e12fff1e	 bx          lr
  00030		 |$M45464|

			 ENDP  ; |Host_ProcessEP0|

	EXPORT	|Host_Connect|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T45480| DCD	|$LN7@Host_Conne|
	DCD	0x40001401
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Host_Connect| PROC

; 3454 : {

  00000		 |$LN7@Host_Conne|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M45477|
  00004	e1a02000	 mov         r2, r0

; 3455 :     PHSMUSB_T pHsUsb = (PHSMUSB_T)pHSMUSBContext;
; 3456 :     SMHCDPdd * pPdd = (SMHCDPdd *)pHsUsb->pContext[HOST_MODE-1];
; 3457 :     CHcd *pHcd = (CHcd *)pPdd->lpvMHCDMddObject;

  00008	e5923014	 ldr         r3, [r2, #0x14]

; 3458 : 
; 3459 :     // This one should be set only on connect or it would have
; 3460 :     // racing condition causing access violation.
; 3461 :     pHcd->SetOTGContext(pHSMUSBContext);        
; 3462 :     pHcd->SetSignalDisconnectACK(FALSE);

  0000c	e3a01000	 mov         r1, #0
  00010	e5934004	 ldr         r4, [r3, #4]
  00014	e5943000	 ldr         r3, [r4]
  00018	e1a00004	 mov         r0, r4
  0001c	e58420b0	 str         r2, [r4, #0xB0]
  00020	e5933048	 ldr         r3, [r3, #0x48]
  00024	e1a0e00f	 mov         lr, pc
  00028	e12fff13	 bx          r3

; 3463 :     pHcd->SignalHubChangeEvent(TRUE);    

  0002c	e5943000	 ldr         r3, [r4]
  00030	e3a01001	 mov         r1, #1
  00034	e1a00004	 mov         r0, r4
  00038	e5933014	 ldr         r3, [r3, #0x14]
  0003c	e1a0e00f	 mov         lr, pc
  00040	e12fff13	 bx          r3

; 3464 :     DEBUGMSG(ZONE_HCD, (TEXT("Host_Connect\r\n")));    
; 3465 :     return ERROR_SUCCESS;

  00044	e3a00000	 mov         r0, #0

; 3466 : }

  00048	e8bd4010	 ldmia       sp!, {r4, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M45478|

			 ENDP  ; |Host_Connect|

	EXPORT	|Host_Disconnect|

  00000			 AREA	 |.pdata|, PDATA
|$T45491| DCD	|$LN6@Host_Disco|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Host_Disconnect| PROC

; 3485 : {

  00000		 |$LN6@Host_Disco|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M45488|

; 3486 :     PHSMUSB_T pHsUsb = (PHSMUSB_T)pHSMUSBContext;
; 3487 :     SMHCDPdd * pPdd = (SMHCDPdd *)pHsUsb->pContext[HOST_MODE-1];
; 3488 :     CHcd *pHcd = (CHcd *)pPdd->lpvMHCDMddObject;

  00004	e5903014	 ldr         r3, [r0, #0x14]

; 3489 : 
; 3490 :     pHcd->SignalHubChangeEvent(FALSE);

  00008	e3a01000	 mov         r1, #0
  0000c	e5934004	 ldr         r4, [r3, #4]
  00010	e5943000	 ldr         r3, [r4]
  00014	e1a00004	 mov         r0, r4
  00018	e5933014	 ldr         r3, [r3, #0x14]
  0001c	e1a0e00f	 mov         lr, pc
  00020	e12fff13	 bx          r3

; 3491 : 
; 3492 :     if(pHcd->m_fHCDState == USBHCD_ACTIVE)

  00024	e59430a0	 ldr         r3, [r4, #0xA0]
  00028	e3530001	 cmp         r3, #1

; 3493 :     {
; 3494 :         WaitForSingleObject(pHcd->m_hPowerDownEvent, INFINITE);

  0002c	059400a4	 ldreq       r0, [r4, #0xA4]
  00030	03e01000	 mvneq       r1, #0
  00034	0b000000	 bleq        WaitForSingleObject

; 3495 :     }
; 3496 :     // Jeffrey: HNP
; 3497 :     //pHsUsb->pUsbGenRegs->DevCtl &= ~DEVCTL_SESSION;
; 3498 :     DEBUGMSG(ZONE_HCD, (TEXT("Host_Disconnect\r\n")));
; 3499 :     
; 3500 :     return ERROR_SUCCESS;

  00038	e3a00000	 mov         r0, #0

; 3501 : }

  0003c	e8bd4010	 ldmia       sp!, {r4, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M45489|

			 ENDP  ; |Host_Disconnect|

	EXPORT	|Host_Suspend|

  00000			 AREA	 |.pdata|, PDATA
|$T45500| DCD	|$LN5@Host_Suspe|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Host_Suspend| PROC

; 3519 : {

  00000		 |$LN5@Host_Suspe|
  00000		 |$M45497|

; 3520 :     UNREFERENCED_PARAMETER(pHSMUSBContext);
; 3521 :     return ERROR_SUCCESS;

  00000	e3a00000	 mov         r0, #0

; 3522 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M45498|

			 ENDP  ; |Host_Suspend|

	EXPORT	|Host_ProcessDMA|

  00000			 AREA	 |.pdata|, PDATA
|$T45512| DCD	|$LN5@Host_Proce@4|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Host_ProcessDMA| PROC

; 3541 : {

  00000		 |$LN5@Host_Proce@4|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45509|

; 3542 :     PHSMUSB_T pHsUsb = (PHSMUSB_T)pContext;
; 3543 :     SMHCDPdd * pPdd = (SMHCDPdd *)pHsUsb->pContext[HOST_MODE-1];
; 3544 :     CMhcd *pMhcd = (CMhcd *)pPdd->lpvMHCDMddObject;

  00004	e5903014	 ldr         r3, [r0, #0x14]

; 3545 : 
; 3546 :     DEBUGMSG(ZONE_HCD, (TEXT("Host_ProcessDMA with channel %d\r\n"), channel));    
; 3547 :     // Not sure if we should use the SetEventData by accessing different bit for different endpoint
; 3548 :     // However, it would require some critical section handling.  Anyway, each pipe would have an associate 
; 3549 :     // DMA event handle and we can set the event with corresponding channel.    
; 3550 :     pMhcd->SignalCheckForDoneDMA(channel);

  00008	e5930004	 ldr         r0, [r3, #4]
  0000c	e5903000	 ldr         r3, [r0]
  00010	e59330a4	 ldr         r3, [r3, #0xA4]
  00014	e1a0e00f	 mov         lr, pc
  00018	e12fff13	 bx          r3

; 3551 :     return ERROR_SUCCESS;

  0001c	e3a00000	 mov         r0, #0

; 3552 : }

  00020	e49de004	 ldr         lr, [sp], #4
  00024	e12fff1e	 bx          lr
  00028		 |$M45510|

			 ENDP  ; |Host_ProcessDMA|

	EXPORT	|??1CBusyPipeList@@QAA@XZ|		; CBusyPipeList::~CBusyPipeList
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T45523| DCD	|$LN7@CBusyPipeL@2|
	DCD	0x40000701
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.h

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CBusyPipeList@@QAA@XZ| PROC	; CBusyPipeList::~CBusyPipeList

; 180  :     ~CBusyPipeList() {DeInit();};

  00000		 |$LN7@CBusyPipeL@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M45520|
  00004	e1a04000	 mov         r4, r0
  00008	eb000000	 bl          |?DeInit@CBusyPipeList@@QAAXXZ|
  0000c	e1a00004	 mov         r0, r4
  00010	eb000000	 bl          DeleteCriticalSection
  00014	e8bd4010	 ldmia       sp!, {r4, lr}
  00018	e12fff1e	 bx          lr
  0001c		 |$M45521|

			 ENDP  ; |??1CBusyPipeList@@QAA@XZ|, CBusyPipeList::~CBusyPipeList

	EXPORT	|?SignalDisconnectComplete@CHW@@QAAHXZ|	; CHW::SignalDisconnectComplete
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T45537| DCD	|$LN7@SignalDisc@2|
	DCD	0x40000601
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.h

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SignalDisconnectComplete@CHW@@QAAHXZ| PROC ; CHW::SignalDisconnectComplete

; 386  :     BOOL SignalDisconnectComplete(void) { return (m_cBusyPipeList.SignalDisconnectComplete(GetOTGContext()));};

  00000		 |$LN7@SignalDisc@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45534|
  00004	e59010b0	 ldr         r1, [r0, #0xB0]
  00008	e28000c0	 add         r0, r0, #0xC0
  0000c	eb000000	 bl          |?SignalDisconnectComplete@CBusyPipeList@@QAAHPAX@Z|
  00010	e49de004	 ldr         lr, [sp], #4
  00014	e12fff1e	 bx          lr
  00018		 |$M45535|

			 ENDP  ; |?SignalDisconnectComplete@CHW@@QAAHXZ|, CHW::SignalDisconnectComplete

	EXPORT	|?CheckForDoneTransfersThreadStub@CBusyPipeList@@CAKPAX@Z| ; CBusyPipeList::CheckForDoneTransfersThreadStub
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T45547| DCD	|$LN5@CheckForDo@3|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CheckForDoneTransfersThreadStub@CBusyPipeList@@CAKPAX@Z| PROC ; CBusyPipeList::CheckForDoneTransfersThreadStub

; 232  : {

  00000		 |$LN5@CheckForDo@3|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45544|

; 233  :     return ((CBusyPipeList *)pContext)->CheckForDoneTransfersThread( );

  00004	eb000000	 bl          |?CheckForDoneTransfersThread@CBusyPipeList@@AAAKXZ|

; 234  : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M45545|

			 ENDP  ; |?CheckForDoneTransfersThreadStub@CBusyPipeList@@CAKPAX@Z|, CBusyPipeList::CheckForDoneTransfersThreadStub

	EXPORT	|??0CHW@@QAA@QAVCPhysMem@@PAXK@Z|	; CHW::CHW
	EXPORT	|??_7CHW@@6B@| [ DATA ]			; CHW::`vftable'
	EXPORT	|?PowerMgmtCallback@CHW@@UAAXH@Z|	; CHW::PowerMgmtCallback
	EXPORT	|?WaitForPortStatusChange@CHW@@UAAHPAX@Z| ; CHW::WaitForPortStatusChange
	EXPORT	|?SuspendHC@CHcd@@UAAHXZ|		; CHcd::SuspendHC
	EXPORT	|?SetSignalDisconnectACK@CHW@@UAAXH@Z|	; CHW::SetSignalDisconnectACK
	EXPORT	|?ProcessTD@CHW@@UAAHEPAX@Z|		; CHW::ProcessTD
	EXPORT	|?SignalHubStatusChange@CHcd@@UAAXXZ|	; CHcd::SignalHubStatusChange
	EXPORT	|?ResumeNotification@CHcd@@MAAHXZ|	; CHcd::ResumeNotification
	EXPORT	|?Initialize@CHW@@UAAHXZ|		; CHW::Initialize
	EXPORT	|?SignalCheckForDoneTransfers@CHW@@UAAXEE@Z| ; CHW::SignalCheckForDoneTransfers
	EXPORT	|?SignalCheckForDoneDMA@CHW@@UAAXE@Z|	; CHW::SignalCheckForDoneDMA
	IMPORT	|??0CHcd@@QAA@XZ|			; CHcd::CHcd
	IMPORT	|??_ECHW@@UAAPAXI@Z|, WEAK |??_GCHW@@UAAPAXI@Z| ; CHW::`vector deleting destructor', CHW::`scalar deleting destructor'
	IMPORT	|?DisableDevice@CHcd@@UAAHIH@Z|		; CHcd::DisableDevice
	IMPORT	|?SuspendResume@CHcd@@UAAHIH@Z|		; CHcd::SuspendResume
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T45575| DCD	|$LN21@CHW|
	DCD	0x40003b01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7CHW@@6B@| DCD |_purecall|				; CHW::`vftable'
	DCD	|_purecall|
	DCD	|??_ECHW@@UAAPAXI@Z|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|?SignalHubChangeEvent@CHW@@UAAHH@Z|
	DCD	|?PowerMgmtCallback@CHW@@UAAXH@Z|
	DCD	|?DisableDevice@CHcd@@UAAHIH@Z|
	DCD	|?SuspendResume@CHcd@@UAAHIH@Z|
	DCD	|?DidPortStatusChange@CHW@@UAAHE@Z|
	DCD	|?GetPortStatus@CHW@@UAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z|
	DCD	|?RootHubFeature@CHW@@UAAHEEG@Z|
	DCD	|?ResetAndEnablePort@CHW@@UAAHE@Z|
	DCD	|?DisablePort@CHW@@UAAXE@Z|
	DCD	|?WaitForPortStatusChange@CHW@@UAAHPAX@Z|
	DCD	|?SuspendHC@CHcd@@UAAHXZ|
	DCD	|?InitFIFO@CHW@@UAAHQAVCPipe@@@Z|
	DCD	|?UpdateDataToggle@CHW@@UAAHQAVCPipe@@HH@Z|
	DCD	|?SetSignalDisconnectACK@CHW@@UAAXH@Z|
	DCD	|?ConfigEP@CHW@@UAAHQBU_USB_ENDPOINT_DESCRIPTOR@@EEEEHEH@Z|
	DCD	|?ProcessTD@CHW@@UAAHEPAX@Z|
	DCD	|?SendOutDMA@CHW@@UAAHEPAX@Z|
	DCD	|?WriteFIFO@CHW@@UAAHPAXE0K@Z|
	DCD	|?ReadFIFO@CHW@@UAAKPAXE0KPAH@Z|
	DCD	|?WriteDMA@CHW@@UAAHPAXEE0KK0@Z|
	DCD	|?SetDeviceAddress@CHW@@UAAXEEEEE@Z|
	DCD	|?IsHostConnect@CHW@@UAAHXZ|
	DCD	|?IsDMASupport@CHW@@UAAHXZ|
	DCD	|?GetDMAMode@CHW@@UAAKXZ|
	DCD	|?LockEP0@CHW@@UAAHE@Z|
	DCD	|?UnlockEP0@CHW@@UAAXE@Z|
	DCD	|?IsDeviceLockEP0@CHW@@UAAHE@Z|
	DCD	|?GetFrameNumber@CHW@@UAAHPAK@Z|
	DCD	|?GetFrameLength@CHW@@UAAHPAG@Z|
	DCD	|?SetFrameLength@CHW@@UAAHPAXG@Z|
	DCD	|?StopAdjustingFrame@CHW@@UAAHXZ|
	DCD	|?SignalHubStatusChange@CHcd@@UAAXXZ|
	DCD	|?ResumeNotification@CHcd@@MAAHXZ|
	DCD	|?Initialize@CHW@@UAAHXZ|
	DCD	|?DeInitialize@CHW@@UAAXXZ|
	DCD	|?SignalCheckForDoneTransfers@CHW@@UAAXEE@Z|
	DCD	|?SignalCheckForDoneDMA@CHW@@UAAXE@Z|
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CHW@@QAA@QAVCPhysMem@@PAXK@Z| PROC	; CHW::CHW

; 725  : {    

  00000		 |$LN21@CHW|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M45572|
  00004	e1a06002	 mov         r6, r2
  00008	e1a05001	 mov         r5, r1
  0000c	e1a07000	 mov         r7, r0
  00010	eb000000	 bl          |??0CHcd@@QAA@XZ|
  00014	e59f30cc	 ldr         r3, [pc, #0xCC]
  00018	e1a04007	 mov         r4, r7
  0001c	e48430c0	 str         r3, [r4], #0xC0
  00020	e1a00004	 mov         r0, r4
  00024	eb000000	 bl          InitializeCriticalSection
  00028	e3a03b01	 mov         r3, #1, 22
  0002c	e58430b4	 str         r3, [r4, #0xB4]

; 726  :     int i; 
; 727  : // definitions for static variables    
; 728  :     g_fPowerUpFlag = FALSE;
; 729  :     g_fPowerResuming = FALSE;
; 730  :     dwSysIntr = 1;//Verify
; 731  :     //m_pHcd = pHcd;
; 732  :     m_pMem = pCPhysMem;
; 733  :     m_pPddContext = pvUhcdPddObject;
; 734  :     //m_FrameListMask = FRAME_LIST_SIZE-1;  
; 735  :     m_hUsbHubConnectEvent = NULL;
; 736  :     m_hUsbHubDisconnectEvent = NULL;
; 737  : 
; 738  :     m_intr_rx_avail = 0;

  00030	e2873c02	 add         r3, r7, #2, 24

; 739  :     m_bDoResume=FALSE;
; 740  :     m_NumOfPort = 1; // Hardcoded as this point

  00034	e3a04000	 mov         r4, #0
  00038	e3a02001	 mov         r2, #1

; 741  :     InitializeCriticalSection( &m_csFrameCounter );

  0003c	e2870f65	 add         r0, r7, #0x65, 30
  00040	e587429c	 str         r4, [r7, #0x29C]
  00044	e58742a0	 str         r4, [r7, #0x2A0]
  00048	e58741a8	 str         r4, [r7, #0x1A8]
  0004c	e58741ac	 str         r4, [r7, #0x1AC]
  00050	e1c347ba	 strh        r4, [r3, #0x7A]
  00054	e58741b4	 str         r4, [r7, #0x1B4]
  00058	e5875294	 str         r5, [r7, #0x294]
  0005c	e5876298	 str         r6, [r7, #0x298]
  00060	e58720bc	 str         r2, [r7, #0xBC]
  00064	eb000000	 bl          InitializeCriticalSection

; 742  :     InitializeCriticalSection(&m_csDMAChannel);

  00068	e2870f72	 add         r0, r7, #0x72, 30
  0006c	eb000000	 bl          InitializeCriticalSection

; 743  :     InitializeCriticalSection(&m_csEndPoint);

  00070	e2870f99	 add         r0, r7, #0x99, 30
  00074	eb000000	 bl          InitializeCriticalSection

; 744  :     m_hLockDMAAccess = CreateEvent(NULL, FALSE, TRUE, NULL);    

  00078	e3a03000	 mov         r3, #0
  0007c	e3a02001	 mov         r2, #1
  00080	e3a01000	 mov         r1, #0
  00084	e3a00000	 mov         r0, #0
  00088	eb000000	 bl          CreateEventW

; 745  :     for (i = 0; i < MAX_DMA_CHANNEL; i++)
; 746  :         m_DMAChannel[i] = 0xff;     

  0008c	e2873f6e	 add         r3, r7, #0x6E, 30
  00090	e2832010	 add         r2, r3, #0x10
  00094	e58701dc	 str         r0, [r7, #0x1DC]
  00098	e3a010ff	 mov         r1, #0xFF
  0009c		 |$LN17@CHW|
  0009c	e0c310b2	 strh        r1, [r3], #2
  000a0	e1530002	 cmp         r3, r2
  000a4	1afffffc	 bne         |$LN17@CHW|

; 747  :     for (i = 0; i < HOST_MAX_EPNUM; i++)

  000a8	e3a03cff	 mov         r3, #0xFF, 24
  000ac	e38320ff	 orr         r2, r3, #0xFF
  000b0	e1a01007	 mov         r1, r7
  000b4	e3a00010	 mov         r0, #0x10
  000b8		 |$LL3@CHW|

; 748  :     {
; 749  :         m_EndPoint[i][DIR_IN].usDeviceInfo = 0xffff;

  000b8	e2813c01	 add         r3, r1, #1, 24
  000bc	e1c32eb2	 strh        r2, [r3, #0xE2]

; 750  :         m_EndPoint[i][DIR_OUT].usDeviceInfo = 0xffff;

  000c0	e1c32eb6	 strh        r2, [r3, #0xE6]

; 751  :         m_EndPoint[i][DIR_IN].usPrevDevInfo = 0xffff;

  000c4	e1c32eb0	 strh        r2, [r3, #0xE0]

; 752  :         m_EndPoint[i][DIR_OUT].usPrevDevInfo = 0xffff;

  000c8	e1c32eb4	 strh        r2, [r3, #0xE4]
  000cc	e2811008	 add         r1, r1, #8
  000d0	e2500001	 subs        r0, r0, #1
  000d4	1afffff7	 bne         |$LL3@CHW|

; 753  :     }
; 754  : 
; 755  :     m_EndPointInUseCount = 0;

  000d8	e5874260	 str         r4, [r7, #0x260]

; 756  : }

  000dc	e1a00007	 mov         r0, r7
  000e0	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000e4	e12fff1e	 bx          lr
  000e8		 |$LN22@CHW|
  000e8		 |$LN23@CHW|
  000e8	00000000	 DCD         |??_7CHW@@6B@|
  000ec		 |$M45573|

			 ENDP  ; |??0CHW@@QAA@QAVCPhysMem@@PAXK@Z|, CHW::CHW

; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T45586| DCD	|$LN5@SuspendHC|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SuspendHC@CHcd@@UAAHXZ| PROC		; CHcd::SuspendHC

; 118  :     virtual BOOL    SuspendHC() { return FALSE; }; // Default does not support it function.

  00000		 |$LN5@SuspendHC|
  00000		 |$M45583|
  00000	e3a00000	 mov         r0, #0
  00004	e12fff1e	 bx          lr
  00008		 |$M45584|

			 ENDP  ; |?SuspendHC@CHcd@@UAAHXZ|, CHcd::SuspendHC


  00000			 AREA	 |.pdata|, PDATA
|$T45594| DCD	|$LN6@SignalHubS|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SignalHubStatusChange@CHcd@@UAAXXZ| PROC ; CHcd::SignalHubStatusChange

; 159  :     virtual void SignalHubStatusChange() {

  00000		 |$LN6@SignalHubS|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45591|

; 160  :         if (m_pCRootHub!=NULL)

  00004	e59030ac	 ldr         r3, [r0, #0xAC]
  00008	e3530000	 cmp         r3, #0

; 161  :             m_pCRootHub->SignalHubStatusChange();

  0000c	11a00003	 movne       r0, r3
  00010	15903000	 ldrne       r3, [r0]
  00014	15933044	 ldrne       r3, [r3, #0x44]
  00018	11a0e00f	 movne       lr, pc
  0001c	112fff13	 bxne        r3

; 162  :     }

  00020	e49de004	 ldr         lr, [sp], #4
  00024	e12fff1e	 bx          lr
  00028		 |$M45592|

			 ENDP  ; |?SignalHubStatusChange@CHcd@@UAAXXZ|, CHcd::SignalHubStatusChange

; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T45611| DCD	|$LN10@ResumeNoti|
	DCD	0x40002001
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResumeNotification@CHcd@@MAAHXZ| PROC ; CHcd::ResumeNotification

; 167  :     virtual BOOL ResumeNotification ()  {

  00000		 |$LN10@ResumeNoti|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45608|
  00004	e1a04000	 mov         r4, r0

; 168  :         Lock();

  00008	e284008c	 add         r0, r4, #0x8C
  0000c	eb000000	 bl          EnterCriticalSection

; 169  :         BOOL fReturn = FALSE;
; 170  :         if (m_pCRootHub) {

  00010	e59430ac	 ldr         r3, [r4, #0xAC]
  00014	e3a05000	 mov         r5, #0
  00018	e3530000	 cmp         r3, #0
  0001c	0a000012	 beq         |$LN1@ResumeNoti|

; 171  :             fReturn = m_pCRootHub->ResumeNotification();

  00020	e1a00003	 mov         r0, r3
  00024	e5903000	 ldr         r3, [r0]
  00028	e5933028	 ldr         r3, [r3, #0x28]
  0002c	e1a0e00f	 mov         lr, pc
  00030	e12fff13	 bx          r3

; 172  :             m_pCRootHub->NotifyOnSuspendedResumed(FALSE);

  00034	e59420ac	 ldr         r2, [r4, #0xAC]
  00038	e1a05000	 mov         r5, r0
  0003c	e3a01000	 mov         r1, #0
  00040	e5923000	 ldr         r3, [r2]
  00044	e1a00002	 mov         r0, r2
  00048	e593302c	 ldr         r3, [r3, #0x2C]
  0004c	e1a0e00f	 mov         lr, pc
  00050	e12fff13	 bx          r3

; 173  :             m_pCRootHub->NotifyOnSuspendedResumed(TRUE);

  00054	e59400ac	 ldr         r0, [r4, #0xAC]
  00058	e3a01001	 mov         r1, #1
  0005c	e5903000	 ldr         r3, [r0]
  00060	e593302c	 ldr         r3, [r3, #0x2C]
  00064	e1a0e00f	 mov         lr, pc
  00068	e12fff13	 bx          r3
  0006c		 |$LN1@ResumeNoti|

; 174  :         }
; 175  :         Unlock();

  0006c	e284008c	 add         r0, r4, #0x8C
  00070	eb000000	 bl          LeaveCriticalSection

; 176  :         return fReturn;
; 177  :     }

  00074	e1a00005	 mov         r0, r5
  00078	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$M45609|

			 ENDP  ; |?ResumeNotification@CHcd@@MAAHXZ|, CHcd::ResumeNotification

	EXPORT	|?SetSignalDisconnectACK@CBusyPipeList@@QAAXH@Z| ; CBusyPipeList::SetSignalDisconnectACK
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.h

  00000			 AREA	 |.pdata|, PDATA
|$T45620| DCD	|$LN5@SetSignalD|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetSignalDisconnectACK@CBusyPipeList@@QAAXH@Z| PROC ; CBusyPipeList::SetSignalDisconnectACK

; 190  :     void    SetSignalDisconnectACK(BOOL fAck) { m_SignalDisconnectACK = fAck;};

  00000		 |$LN5@SetSignalD|
  00000		 |$M45617|
  00000	e58010d0	 str         r1, [r0, #0xD0]
  00004	e12fff1e	 bx          lr
  00008		 |$M45618|

			 ENDP  ; |?SetSignalDisconnectACK@CBusyPipeList@@QAAXH@Z|, CBusyPipeList::SetSignalDisconnectACK


  00000			 AREA	 |.pdata|, PDATA
|$T45632| DCD	|$LN7@SetSignalD@2|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetSignalDisconnectACK@CHW@@UAAXH@Z| PROC ; CHW::SetSignalDisconnectACK

; 367  :     void    SetSignalDisconnectACK(BOOL fAck) { m_cBusyPipeList.SetSignalDisconnectACK(fAck); };

  00000		 |$LN7@SetSignalD@2|
  00000		 |$M45629|
  00000	e5801190	 str         r1, [r0, #0x190]
  00004	e12fff1e	 bx          lr
  00008		 |$M45630|

			 ENDP  ; |?SetSignalDisconnectACK@CHW@@UAAXH@Z|, CHW::SetSignalDisconnectACK

; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T45654| DCD	|$LN10@SignalChec@3|
	DCD	0x40000c01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.h

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SignalCheckForDoneTransfers@CHW@@UAAXEE@Z| PROC ; CHW::SignalCheckForDoneTransfers

; 233  :     virtual void    SignalCheckForDoneTransfers( IN const UCHAR endpoint, IN const UCHAR ucIsOut ) { 

  00000		 |$LN10@SignalChec@3|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45651|

; 234  :             m_cBusyPipeList.SignalCheckForDoneTransfers(endpoint, ucIsOut);

  00004	e201300f	 and         r3, r1, #0xF
  00008	e0822083	 add         r2, r2, r3, lsl #1
  0000c	e28030c0	 add         r3, r0, #0xC0
  00010	e0833102	 add         r3, r3, r2, lsl #2
  00014	e5933014	 ldr         r3, [r3, #0x14]
  00018	e3530000	 cmp         r3, #0
  0001c	13a01003	 movne       r1, #3
  00020	11a00003	 movne       r0, r3
  00024	1b000000	 blne        EventModify

; 235  :         };

  00028	e49de004	 ldr         lr, [sp], #4
  0002c	e12fff1e	 bx          lr
  00030		 |$M45652|

			 ENDP  ; |?SignalCheckForDoneTransfers@CHW@@UAAXEE@Z|, CHW::SignalCheckForDoneTransfers


  00000			 AREA	 |.pdata|, PDATA
|$T45663| DCD	|$LN5@SignalChec@4|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SignalCheckForDoneDMA@CHW@@UAAXE@Z| PROC ; CHW::SignalCheckForDoneDMA

; 237  :     virtual void    SignalCheckForDoneDMA( IN const UCHAR channel ) { 

  00000		 |$LN5@SignalChec@4|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45660|

; 238  :             m_cBusyPipeList.SignalCheckForDoneDMA(channel);

  00004	e28000c0	 add         r0, r0, #0xC0
  00008	eb000000	 bl          |?SignalCheckForDoneDMA@CBusyPipeList@@QAAHE@Z|

; 239  :         };

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M45661|

			 ENDP  ; |?SignalCheckForDoneDMA@CHW@@UAAXE@Z|, CHW::SignalCheckForDoneDMA

	EXPORT	|??1CHW@@UAA@XZ|			; CHW::~CHW
	IMPORT	|??1CHcd@@UAA@XZ|			; CHcd::~CHcd
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T45684| DCD	|$LN11@CHW@2|
	DCD	0x40001201
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CHW@@UAA@XZ| PROC			; CHW::~CHW

; 758  : {

  00000		 |$LN11@CHW@2|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45681|
  00004	e1a05000	 mov         r5, r0
  00008	e59f3034	 ldr         r3, [pc, #0x34]

; 759  :     DeInitialize();

  0000c	e1a04005	 mov         r4, r5
  00010	e48430c0	 str         r3, [r4], #0xC0
  00014	e1a00004	 mov         r0, r4
  00018	eb000000	 bl          |?DeInit@CBusyPipeList@@QAAXXZ|

; 760  :     DeleteCriticalSection( &m_csFrameCounter );

  0001c	e2850f65	 add         r0, r5, #0x65, 30
  00020	eb000000	 bl          DeleteCriticalSection

; 761  : }

  00024	e1a00004	 mov         r0, r4
  00028	eb000000	 bl          |?DeInit@CBusyPipeList@@QAAXXZ|
  0002c	e1a00004	 mov         r0, r4
  00030	eb000000	 bl          DeleteCriticalSection
  00034	e1a00005	 mov         r0, r5
  00038	eb000000	 bl          |??1CHcd@@UAA@XZ|
  0003c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$LN12@CHW@2|
  00044		 |$LN13@CHW@2|
  00044	00000000	 DCD         |??_7CHW@@6B@|
  00048		 |$M45682|

			 ENDP  ; |??1CHW@@UAA@XZ|, CHW::~CHW

	EXPORT	|?CeResumeThreadStub@CHW@@CAKPAX@Z|	; CHW::CeResumeThreadStub

  00000			 AREA	 |.pdata|, PDATA
|$T45696| DCD	|$LN5@CeResumeTh@2|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CeResumeThreadStub@CHW@@CAKPAX@Z| PROC ; CHW::CeResumeThreadStub

; 920  : {

  00000		 |$LN5@CeResumeTh@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45693|

; 921  :     return ((CHW *)context)->CeResumeThread ( );

  00004	eb000000	 bl          |?CeResumeThread@CHW@@AAAKXZ|

; 922  : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M45694|

			 ENDP  ; |?CeResumeThreadStub@CHW@@CAKPAX@Z|, CHW::CeResumeThreadStub

; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.bss|, NOINIT
|?bDisconnect@?1??WaitForPortStatusChange@CHW@@UAAHPAX@Z@4HA| % 0x4 ; `CHW::WaitForPortStatusChange'::`2'::bDisconnect

  00000			 AREA	 |.pdata|, PDATA
|$T45741| DCD	|$LN42@WaitForPor|
	DCD	0x40004602
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?WaitForPortStatusChange@CHW@@UAAHPAX@Z| PROC ; CHW::WaitForPortStatusChange

; 1226 : {

  00000		 |$LN42@WaitForPor|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M45738|
  00008	e1a07001	 mov         r7, r1
  0000c	e1a04000	 mov         r4, r0

; 1227 :     DWORD dwErr;
; 1228 :     DWORD timeout = 500;
; 1229 :     static BOOL bDisconnect = FALSE;
; 1230 :     if ((m_hUsbHubDisconnectEvent) && (m_hUsbHubConnectEvent)) {

  00010	e59431ac	 ldr         r3, [r4, #0x1AC]
  00014	e3a05f7d	 mov         r5, #0x7D, 30
  00018	e3530000	 cmp         r3, #0
  0001c	0a000038	 beq         |$LN17@WaitForPor|
  00020	e59431a8	 ldr         r3, [r4, #0x1A8]
  00024	e3530000	 cmp         r3, #0
  00028	0a000035	 beq         |$LN17@WaitForPor|
  0002c	e3a03c01	 mov         r3, #1, 24
  00030	e59f60dc	 ldr         r6, [pc, #0xDC]
  00034	e3838002	 orr         r8, r3, #2
  00038	e3a09000	 mov         r9, #0
  0003c		 |$LL18@WaitForPor|

; 1231 :        for(;;)
; 1232 :        {           
; 1233 :             if (m_hHubChanged!=NULL) {
; 1234 :                 HANDLE hArray[3];
; 1235 :                 hArray[0]=m_hUsbHubConnectEvent;
; 1236 :                 hArray[1]=m_hUsbHubDisconnectEvent;

  0003c	e59411ac	 ldr         r1, [r4, #0x1AC]
  00040	e59421a8	 ldr         r2, [r4, #0x1A8]
  00044	e3570000	 cmp         r7, #0

; 1237 :                 hArray[2]=m_hHubChanged;
; 1238 :                 dwErr = WaitForMultipleObjects(3,hArray,FALSE,timeout);

  00048	158d100c	 strne       r1, [sp, #0xC]
  0004c	128d1008	 addne       r1, sp, #8

; 1239 :             }
; 1240 :             else
; 1241 :             {
; 1242 :                 HANDLE hArray[2];
; 1243 :                 hArray[0] = m_hUsbHubConnectEvent;
; 1244 :                 hArray[1] = m_hUsbHubDisconnectEvent;
; 1245 :                 dwErr = WaitForMultipleObjects(2, hArray, FALSE,timeout);

  00050	058d1004	 streq       r1, [sp, #4]
  00054	158d2008	 strne       r2, [sp, #8]
  00058	13a00003	 movne       r0, #3
  0005c	058d2000	 streq       r2, [sp]
  00060	028d1000	 addeq       r1, sp, #0
  00064	e1a03005	 mov         r3, r5
  00068	03a00002	 moveq       r0, #2
  0006c	e3a02000	 mov         r2, #0
  00070	158d7010	 strne       r7, [sp, #0x10]
  00074	eb000000	 bl          WaitForMultipleObjects

; 1246 :             }
; 1247 :             if (dwErr == WAIT_OBJECT_0+1)

  00078	e3500001	 cmp         r0, #1
  0007c	0a00001c	 beq         |$LN38@WaitForPor|

; 1249 :             else if (dwErr == WAIT_TIMEOUT) 

  00080	e1500008	 cmp         r0, r8
  00084	1a00001c	 bne         |$LN36@WaitForPor|

; 1250 :             {
; 1251 :                 BOOL bSignalDetach = FALSE;
; 1252 :                 CRootHub *pRootHub = GetRootHub();

  00088	e59430ac	 ldr         r3, [r4, #0xAC]
  0008c	e1b02003	 movs        r2, r3

; 1253 :                 if (pRootHub == NULL)

  00090	0affffe9	 beq         |$LL18@WaitForPor|

; 1254 :                 {                    
; 1255 :                     DEBUGMSG(1, (TEXT("RootHUB::NULL\r\n")));
; 1256 :                     bSignalDetach = TRUE;
; 1257 :                 }
; 1258 :                 else 
; 1259 :                 {
; 1260 :                     CDevice ** ppDevicePort;
; 1261 :                     int port = pRootHub->GetNumberOfPort();             
; 1262 :                     DEBUGMSG(ZONE_HCD, (TEXT("RootHUB:NoOfPort = %d\r\n"), port));
; 1263 :                     ppDevicePort = pRootHub->GetDeviceOnPort();

  00094	e59230b0	 ldr         r3, [r2, #0xB0]
  00098	e5d2106a	 ldrb        r1, [r2, #0x6A]
  0009c	e1b00003	 movs        r0, r3

; 1264 :                     if (ppDevicePort == NULL)
; 1265 :                     {         
; 1266 :                         DEBUGMSG(1, (TEXT("RootHUB::ppDevicePort = NULL\r\n")));
; 1267 :                         bSignalDetach = TRUE;
; 1268 :                     }
; 1269 :                     else

  000a0	0a00000b	 beq         |$LN3@WaitForPor|

; 1270 :                     {
; 1271 :                         int i = 0;
; 1272 :                         int no_device = 0;

  000a4	e3a02000	 mov         r2, #0

; 1273 :                         for (i = 0; i < port; i++)

  000a8	e3510000	 cmp         r1, #0
  000ac	da000006	 ble         |$LN5@WaitForPor|
  000b0	e1a0e001	 mov         lr, r1
  000b4		 |$LL7@WaitForPor|

; 1274 :                         {
; 1275 :                             DEBUGMSG(ZONE_HCD, (TEXT("RootHUB:Port[%d] = 0x%x\r\n"), i, ppDevicePort[i]));                                    
; 1276 :                             if (ppDevicePort[i] == NULL)

  000b4	e5903000	 ldr         r3, [r0]
  000b8	e2800004	 add         r0, r0, #4
  000bc	e3530000	 cmp         r3, #0

; 1277 :                                 no_device++;

  000c0	02822001	 addeq       r2, r2, #1
  000c4	e25ee001	 subs        lr, lr, #1
  000c8	1afffff9	 bne         |$LL7@WaitForPor|
  000cc		 |$LN5@WaitForPor|

; 1278 :                         }
; 1279 :                         if (no_device == port)

  000cc	e1520001	 cmp         r2, r1
  000d0	1a000005	 bne         |$LN28@WaitForPor|
  000d4		 |$LN3@WaitForPor|

; 1280 :                             bSignalDetach = TRUE;
; 1281 :                     }
; 1282 : 
; 1283 :                     if ((bSignalDetach) && (bDisconnect))

  000d4	e5963000	 ldr         r3, [r6]
  000d8	e3530000	 cmp         r3, #0

; 1284 :                     {
; 1285 :                         bDisconnect = FALSE;
; 1286 :                         SignalDisconnectComplete();

  000dc	159410b0	 ldrne       r1, [r4, #0xB0]
  000e0	128400c0	 addne       r0, r4, #0xC0
  000e4	15869000	 strne       r9, [r6]
  000e8	1b000000	 blne        |?SignalDisconnectComplete@CBusyPipeList@@QAAHPAX@Z|
  000ec		 |$LN28@WaitForPor|

; 1287 :                     }
; 1288 :                     timeout = INFINITE;

  000ec	e3e05000	 mvn         r5, #0

; 1289 :                 }
; 1290 :             }
; 1291 : 
; 1292 :             if (dwErr != WAIT_TIMEOUT)

  000f0	eaffffd1	 b           |$LL18@WaitForPor|
  000f4		 |$LN38@WaitForPor|

; 1248 :                 bDisconnect = TRUE;

  000f4	e3a03001	 mov         r3, #1
  000f8	e5863000	 str         r3, [r6]
  000fc		 |$LN36@WaitForPor|

; 1293 :                 return TRUE;

  000fc	e3a00001	 mov         r0, #1
  00100	ea000000	 b           |$LN20@WaitForPor|
  00104		 |$LN17@WaitForPor|

; 1294 :        }
; 1295 :     }    
; 1296 :     return FALSE;

  00104	e3a00000	 mov         r0, #0
  00108		 |$LN20@WaitForPor|

; 1297 : }

  00108	e28dd014	 add         sp, sp, #0x14
  0010c	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00110	e12fff1e	 bx          lr
  00114		 |$LN43@WaitForPor|
  00114		 |$LN44@WaitForPor|
  00114	00000000	 DCD         |?bDisconnect@?1??WaitForPortStatusChange@CHW@@UAAHPAX@Z@4HA|
  00118		 |$M45739|

			 ENDP  ; |?WaitForPortStatusChange@CHW@@UAAHPAX@Z|, CHW::WaitForPortStatusChange

	EXPORT	|?ReleaseDMAChannel@CHW@@QAAHPAVCPipe@@E@Z| ; CHW::ReleaseDMAChannel
	IMPORT	|HcdPdd_PostTransferDeactivation|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\hcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T45761| DCD	|$LN9@ReleaseDMA|
	DCD	0x40001a01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ReleaseDMAChannel@CHW@@QAAHPAVCPipe@@E@Z| PROC ; CHW::ReleaseDMAChannel

; 1413 : {

  00000		 |$LN9@ReleaseDMA|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45758|
  00004	e1a05002	 mov         r5, r2
  00008	e1a06000	 mov         r6, r0

; 1414 :     PHSMUSB_T pOTG;
; 1415 :     if ((channel < 0)|| (channel >= DMA_MAX_CHANNEL))

  0000c	e3550008	 cmp         r5, #8
  00010	2a000011	 bcs         |$LN1@ReleaseDMA|

; 1417 :     
; 1418 :     pOTG = (PHSMUSB_T)pPipe->m_pCMhcd->GetOTGContext();    

  00014	e591300c	 ldr         r3, [r1, #0xC]

; 1419 :     EnterCriticalSection(&m_csDMAChannel);

  00018	e2860f72	 add         r0, r6, #0x72, 30
  0001c	e59340b0	 ldr         r4, [r3, #0xB0]
  00020	eb000000	 bl          EnterCriticalSection

; 1420 :     ClearDMAChannel(channel);

  00024	e1a01005	 mov         r1, r5
  00028	e1a00006	 mov         r0, r6
  0002c	eb000000	 bl          |?ClearDMAChannel@CHW@@QAAHE@Z|

; 1421 :     m_DMAChannel[channel] = 0xff;     

  00030	e0863085	 add         r3, r6, r5, lsl #1
  00034	e2833c01	 add         r3, r3, #1, 24
  00038	e3a020ff	 mov         r2, #0xFF
  0003c	e1c32bb8	 strh        r2, [r3, #0xB8]

; 1422 :     m_cBusyPipeList.m_hDMA2Handles[channel] = NULL;

  00040	e0863105	 add         r3, r6, r5, lsl #2
  00044	e3a02000	 mov         r2, #0

; 1423 :     LeaveCriticalSection(&m_csDMAChannel);

  00048	e2860f72	 add         r0, r6, #0x72, 30
  0004c	e5832154	 str         r2, [r3, #0x154]
  00050	eb000000	 bl          LeaveCriticalSection

; 1424 :   
; 1425 :     HcdPdd_PostTransferDeactivation((SMHCDPdd *)pOTG->pContext[HOST_MODE-1]);

  00054	e5940014	 ldr         r0, [r4, #0x14]
  00058	eb000000	 bl          HcdPdd_PostTransferDeactivation
  0005c		 |$LN1@ReleaseDMA|

; 1416 :         return TRUE;

  0005c	e3a00001	 mov         r0, #1

; 1426 : 
; 1427 :     return TRUE;
; 1428 : }

  00060	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00064	e12fff1e	 bx          lr
  00068		 |$M45759|

			 ENDP  ; |?ReleaseDMAChannel@CHW@@QAAHPAVCPipe@@E@Z|, CHW::ReleaseDMAChannel

	IMPORT	|SetInterruptEvent|

  00000			 AREA	 |.pdata|, PDATA
|$T45782| DCD	|$LN17@PowerMgmtC|
	DCD	0x40001a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PowerMgmtCallback@CHW@@UAAXH@Z| PROC	; CHW::PowerMgmtCallback

; 1669 : {

  00000		 |$LN17@PowerMgmtC|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M45779|

; 1670 : 
; 1671 :     PHSMUSB_T pOTG;            
; 1672 : 
; 1673 :     pOTG = (PHSMUSB_T)GetOTGContext();

  00004	e59030b0	 ldr         r3, [r0, #0xB0]
  00008	e1b04003	 movs        r4, r3

; 1674 :     if (pOTG == NULL)

  0000c	0a000013	 beq         |$LN2@PowerMgmtC|

; 1675 :     {
; 1676 :         DEBUGMSG(ZONE_ERROR, (TEXT("CHW::PowerMgmt failed\r\n")));
; 1677 :         return;
; 1678 :     }  
; 1679 : 
; 1680 :     if (pOTG->operateMode != HOST_MODE)

  00010	e5d43035	 ldrb        r3, [r4, #0x35]
  00014	e3530002	 cmp         r3, #2
  00018	1a000010	 bne         |$LN2@PowerMgmtC|

; 1681 :         return;
; 1682 : 
; 1683 :     SMHCDPdd *pPdd = (SMHCDPdd *)pOTG->pContext[HOST_MODE-1];

  0001c	e5943014	 ldr         r3, [r4, #0x14]

; 1684 :     if ( fOff )

  00020	e3510000	 cmp         r1, #0

; 1685 :     {
; 1686 :         SuspendHostController();
; 1687 :         if (pPdd->m_lpUSBClockProc)

  00024	e5933258	 ldr         r3, [r3, #0x258]
  00028	0a000006	 beq         |$LN4@PowerMgmtC|
  0002c	e3530000	 cmp         r3, #0
  00030	0a00000a	 beq         |$LN2@PowerMgmtC|

; 1688 :             pPdd->m_lpUSBClockProc(FALSE);        

  00034	e3a00000	 mov         r0, #0
  00038	e1a0e00f	 mov         lr, pc
  0003c	e12fff13	 bx          r3

; 1697 :     }
; 1698 :     
; 1699 :     return;
; 1700 : }

  00040	e8bd4010	 ldmia       sp!, {r4, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$LN4@PowerMgmtC|

; 1689 :     }
; 1690 :     else
; 1691 :     {   // resuming...
; 1692 :         if (pPdd->m_lpUSBClockProc)

  00048	e3530000	 cmp         r3, #0

; 1693 :             pPdd->m_lpUSBClockProc(TRUE);

  0004c	13a00001	 movne       r0, #1
  00050	11a0e00f	 movne       lr, pc
  00054	112fff13	 bxne        r3

; 1694 :         ResumeHostController();
; 1695 :         DEBUGMSG(1, (TEXT("SetInterruptEvent for SysIntr 0x%x\r\n"), pOTG->dwSysIntr));
; 1696 :         SetInterruptEvent(pOTG->dwSysIntr);

  00058	e5940050	 ldr         r0, [r4, #0x50]
  0005c	eb000000	 bl          SetInterruptEvent
  00060		 |$LN2@PowerMgmtC|

; 1697 :     }
; 1698 :     
; 1699 :     return;
; 1700 : }

  00060	e8bd4010	 ldmia       sp!, {r4, lr}
  00064	e12fff1e	 bx          lr
  00068		 |$M45780|

			 ENDP  ; |?PowerMgmtCallback@CHW@@UAAXH@Z|, CHW::PowerMgmtCallback

	EXPORT	|?ReadDMA@CHW@@QAAKPAXEE0KKPAVCQTD@@@Z|	; CHW::ReadDMA
	EXPORT	|??_C@_1GO@KEJCKFIF@?$AAR?$AAe?$AAa?$AAd?$AAD?$AAM?$AAA?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAT?$AAo?$AAt?$AAT?$AAf?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FI@MCGAOEPM@?$AAR?$AAe?$AAa?$AAd?$AAD?$AAM?$AAA?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?5?$AA0?$AA?0?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAR?$AAx?$AAC@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@KBIGIHKK@?$AAD?$AAe?$AAb?$AAu?$AAg?$AA?5?$AAh?$AAe?$AAr?$AAe?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\ctd.h

  00000			 AREA	 |.pdata|, PDATA
|$T45835| DCD	|$LN33@ReadDMA|
	DCD	0x40006702

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GO@KEJCKFIF@?$AAR?$AAe?$AAa?$AAd?$AAD?$AAM?$AAA?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAT?$AAo?$AAt?$AAT?$AAf?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN@| DCB "R"
	DCB	0x0, "e", 0x0, "a", 0x0, "d", 0x0, "D", 0x0, "M", 0x0, "A"
	DCB	0x0, " ", 0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e"
	DCB	0x0, "d", 0x0, " ", 0x0, "w", 0x0, "i", 0x0, "t", 0x0, "h"
	DCB	0x0, " ", 0x0, "T", 0x0, "o", 0x0, "t", 0x0, "T", 0x0, "f"
	DCB	0x0, "r", 0x0, "S", 0x0, "i", 0x0, "z", 0x0, "e", 0x0, " "
	DCB	0x0, "=", 0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%", 0x0, "x"
	DCB	0x0, ",", 0x0, " ", 0x0, "B", 0x0, "u", 0x0, "f", 0x0, "f"
	DCB	0x0, "e", 0x0, "r", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FI@MCGAOEPM@?$AAR?$AAe?$AAa?$AAd?$AAD?$AAM?$AAA?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?5?$AA0?$AA?0?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAR?$AAx?$AAC@| DCB "R"
	DCB	0x0, "e", 0x0, "a", 0x0, "d", 0x0, "D", 0x0, "M", 0x0, "A"
	DCB	0x0, " ", 0x0, "w", 0x0, "i", 0x0, "t", 0x0, "h", 0x0, " "
	DCB	0x0, "c", 0x0, "o", 0x0, "u", 0x0, "n", 0x0, "t", 0x0, " "
	DCB	0x0, "=", 0x0, " ", 0x0, "0", 0x0, ",", 0x0, " ", 0x0, "w"
	DCB	0x0, "i", 0x0, "t", 0x0, "h", 0x0, " ", 0x0, "R", 0x0, "x"
	DCB	0x0, "C", 0x0, "S", 0x0, "R", 0x0, " ", 0x0, "=", 0x0, " "
	DCB	0x0, "0", 0x0, "x", 0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@KBIGIHKK@?$AAD?$AAe?$AAb?$AAu?$AAg?$AA?5?$AAh?$AAe?$AAr?$AAe?$AA?$AN?$AA?6?$AA?$AA@| DCB "D"
	DCB	0x0, "e", 0x0, "b", 0x0, "u", 0x0, "g", 0x0, " ", 0x0, "h"
	DCB	0x0, "e", 0x0, "r", 0x0, "e", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ReadDMA@CHW@@QAAKPAXEE0KKPAVCQTD@@@Z| PROC ; CHW::ReadDMA

; 2417 : {

  00000		 |$LN33@ReadDMA|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M45832|
  00008	e5cd3010	 strb        r3, [sp, #0x10]
  0000c	e1a0b002	 mov         r11, r2
  00010	e1a05001	 mov         r5, r1
  00014	e1a0a000	 mov         r10, r0

; 2418 :     PHSMUSB_T pOTG = (PHSMUSB_T)(pContext);
; 2419 :     USHORT rxcsr;    
; 2420 :     UCHAR  mode = 0;
; 2421 :     DWORD  dwCount = 0;
; 2422 :     DWORD  dwReadSize = 0;    
; 2423 :     UCHAR csrIndex = INDEX(endpoint);    
; 2424 :     EnterCriticalSection(&pOTG->regCS);

  00018	e20b700f	 and         r7, r11, #0xF
  0001c	e2850038	 add         r0, r5, #0x38
  00020	e1a09007	 mov         r9, r7
  00024	e3a08000	 mov         r8, #0
  00028	eb000000	 bl          EnterCriticalSection

; 2425 :     OUTREG8(&pOTG->pUsbGenRegs->Index, INDEX(endpoint));

  0002c	e595e020	 ldr         lr, [r5, #0x20]

; 2426 : 
; 2427 :     
; 2428 : 
; 2429 :     dwCount = INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].Count.RxCount);

  00030	e59d6044	 ldr         r6, [sp, #0x44]
  00034	e5ce900e	 strb        r9, [lr, #0xE]
  00038	e595e01c	 ldr         lr, [r5, #0x1C]
  0003c	e08ee209	 add         lr, lr, r9, lsl #4
  00040	e5de4008	 ldrb        r4, [lr, #8]
  00044	e5dee009	 ldrb        lr, [lr, #9]
  00048	e194440e	 orrs        r4, r4, lr, lsl #8

; 2430 : 
; 2431 : #ifndef SHIP_BUILD
; 2432 :     if (dwCount == 0) 

  0004c	1a00000c	 bne         |$LN15@ReadDMA|

; 2433 :     {
; 2434 :         DWORD cbStart = pCurTD->GetTotTfrSize();
; 2435 :         RETAILMSG(1, (TEXT("ReadDMA failed with TotTfrSize = 0x%x, Buffer = 0x%x\r\n"), cbStart, pCurTD->GetDataSize()));

  00050	e5962018	 ldr         r2, [r6, #0x18]
  00054	e596101c	 ldr         r1, [r6, #0x1C]
  00058	e59f0138	 ldr         r0, [pc, #0x138]
  0005c	eb000000	 bl          NKDbgPrintfW

; 2436 :         memdump(pvData, (USHORT)cbStart, 0);
; 2437 :         RETAILMSG(1, (TEXT("ReadDMA with count = 0, with RxCSR = 0x%x\r\n"), INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR)));

  00060	e595301c	 ldr         r3, [r5, #0x1C]
  00064	e59f0128	 ldr         r0, [pc, #0x128]
  00068	e0833209	 add         r3, r3, r9, lsl #4
  0006c	e5d32006	 ldrb        r2, [r3, #6]
  00070	e5d33007	 ldrb        r3, [r3, #7]
  00074	e1821403	 orr         r1, r2, r3, lsl #8
  00078	eb000000	 bl          NKDbgPrintfW

; 2438 :         // Dump the data
; 2439 :         RETAILMSG(1, (TEXT("Debug here\r\n")));

  0007c	e59f010c	 ldr         r0, [pc, #0x10C]
  00080	eb000000	 bl          NKDbgPrintfW
  00084		 |$LN15@ReadDMA|

; 2440 :         // Force dwCount = dwMaxPacket
; 2441 :         //dwCount = dwMaxPacket;
; 2442 :     }
; 2443 : #endif
; 2444 : 
; 2445 :     if (size < dwCount)

  00084	e59d003c	 ldr         r0, [sp, #0x3C]
  00088	e1500004	 cmp         r0, r4
  0008c	2a00000e	 bcs         |$LN6@ReadDMA|

; 2446 :     {
; 2447 :         DWORD dwErr = USB_CLIENT_BUFFER_ERROR;
; 2448 : 
; 2449 :         // We need to ack back to MDD the failure
; 2450 :         DEBUGMSG(ZONE_WARNING, (TEXT("Warning!!! Not enough buffer size!!!\r\n")));
; 2451 :         dwCount = size;                
; 2452 :         if (size == 0)

  00090	e3500000	 cmp         r0, #0
  00094	1a000008	 bne         |$LN5@ReadDMA|

; 2453 :         {
; 2454 :             RETAILMSG(1, (TEXT("Assume the next data arrive\r\n")));

  00098	e59f00ec	 ldr         r0, [pc, #0xEC]
  0009c	eb000000	 bl          NKDbgPrintfW

; 2455 :             SetRxDataAvail(USB_ENDPOINT(endpoint));

  000a0	e28a2c02	 add         r2, r10, #2, 24
  000a4	e1d237ba	 ldrh        r3, [r2, #0x7A]
  000a8	e3a01001	 mov         r1, #1

; 2456 :             dwErr = USB_NO_ERROR;

  000ac	e3a04000	 mov         r4, #0
  000b0	e1833711	 orr         r3, r3, r1, lsl r7
  000b4	e1c237ba	 strh        r3, [r2, #0x7A]

; 2457 :         }
; 2458 :         else

  000b8	ea000000	 b           |$LN4@ReadDMA|
  000bc		 |$LN5@ReadDMA|

; 2459 :             dwErr = USB_CLIENT_BUFFER_ERROR;

  000bc	e3a04f41	 mov         r4, #0x41, 30
  000c0		 |$LN4@ReadDMA|

; 2460 :         LeaveCriticalSection(&pOTG->regCS);

  000c0	e2850038	 add         r0, r5, #0x38
  000c4	eb000000	 bl          LeaveCriticalSection

; 2461 : 
; 2462 :         // Using ReadFIFO to clear up the FIFO
; 2463 :         return dwErr;

  000c8	ea00002b	 b           |$LN8@ReadDMA|
  000cc		 |$LN6@ReadDMA|

; 2464 :     }
; 2465 :         
; 2466 :     if ((dwCount >= dwMaxPacket) && (size > dwCount))   
; 2467 :         mode = 1;
; 2468 :     
; 2469 :     DEBUGMSG(ZONE_TRANSFER|ZONE_HCD, (TEXT("ReadDMA(%d): count=0x%x, maxpacket=0x%x, size=0x%x\r\n"), 
; 2470 :         mode, dwCount, dwMaxPacket, size));
; 2471 :     // First clear the REQPKT
; 2472 :     rxcsr = INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR); 

  000cc	e595301c	 ldr         r3, [r5, #0x1C]
  000d0	e59d7040	 ldr         r7, [sp, #0x40]
  000d4	e3a02cff	 mov         r2, #0xFF, 24

; 2473 :     rxcsr &= ~(RXCSR_H_ReqPkt);

  000d8	e0833209	 add         r3, r3, r9, lsl #4
  000dc	e38210df	 orr         r1, r2, #0xDF
  000e0	e5d32006	 ldrb        r2, [r3, #6]
  000e4	e5d33007	 ldrb        r3, [r3, #7]
  000e8	e1540007	 cmp         r4, r7
  000ec	21500004	 cmpcs       r0, r4
  000f0	83a08001	 movhi       r8, #1

; 2474 :     
; 2475 :     if (mode == 0)

  000f4	e1823403	 orr         r3, r2, r3, lsl #8
  000f8	e3580000	 cmp         r8, #0
  000fc	e0032001	 and         r2, r3, r1
  00100	03a03c1f	 moveq       r3, #0x1F, 24

; 2476 :     {
; 2477 :         dwReadSize = dwCount;
; 2478 :         rxcsr &= ~(RXCSR_H_AutoReq);

  00104	038330ff	 orreq       r3, r3, #0xFF
  00108	00023003	 andeq       r3, r2, r3

; 2479 :         rxcsr |= (RXCSR_H_AutoClr| RXCSR_H_DMAReqEn);
; 2480 :         pCurTD->SetStatus(STATUS_WAIT_DMA_0_RD_FIFO_COMPLETE);

  0010c	03831a0a	 orreq       r1, r3, #0xA, 20

; 2481 :     }
; 2482 :     else

  00110	13a03c17	 movne       r3, #0x17, 24

; 2483 :     {
; 2484 :         dwReadSize = size;
; 2485 :         rxcsr &= ~(RXCSR_H_DMAReqMode);

  00114	138330ff	 orrne       r3, r3, #0xFF
  00118	03a0200a	 moveq       r2, #0xA
  0011c	10023003	 andne       r3, r2, r3

; 2486 :         rxcsr |= (RXCSR_H_AutoReq| RXCSR_H_AutoClr|RXCSR_H_DMAReqEn);
; 2487 :         pCurTD->SetStatus(STATUS_WAIT_DMA_1_RD_FIFO_COMPLETE);

  00120	13a0200b	 movne       r2, #0xB
  00124	e5862028	 str         r2, [r6, #0x28]
  00128	13831a0e	 orrne       r1, r3, #0xE, 20

; 2488 :     }
; 2489 :     OUTREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR, rxcsr);

  0012c	e595301c	 ldr         r3, [r5, #0x1C]
  00130	11a04000	 movne       r4, r0
  00134	e1a02421	 mov         r2, r1, lsr #8

; 2490 :     LeaveCriticalSection(&pOTG->regCS);

  00138	e0833209	 add         r3, r3, r9, lsl #4
  0013c	e5c31006	 strb        r1, [r3, #6]
  00140	e2850038	 add         r0, r5, #0x38
  00144	e5c32007	 strb        r2, [r3, #7]
  00148	eb000000	 bl          LeaveCriticalSection

; 2491 :         
; 2492 :     pCurTD->SetCurTfrSize(dwReadSize);    
; 2493 :     ProcessDMAChannel((void *)pOTG, endpoint, channel, FALSE, pBuff, dwReadSize, dwMaxPacket);

  0014c	e59d2038	 ldr         r2, [sp, #0x38]
  00150	e5dd3010	 ldrb        r3, [sp, #0x10]
  00154	e3a0e000	 mov         lr, #0
  00158	e58d2004	 str         r2, [sp, #4]
  0015c	e1a0200b	 mov         r2, r11
  00160	e1a01005	 mov         r1, r5
  00164	e1a0000a	 mov         r0, r10
  00168	e5864020	 str         r4, [r6, #0x20]
  0016c	e58d700c	 str         r7, [sp, #0xC]
  00170	e58d4008	 str         r4, [sp, #8]
  00174	e58de000	 str         lr, [sp]
  00178	eb000000	 bl          |?ProcessDMAChannel@CHW@@QAAHPAXEEH0KK@Z|

; 2494 :     
; 2495 :     return dwReadSize;

  0017c		 |$LN8@ReadDMA|

; 2496 : }

  0017c	e1a00004	 mov         r0, r4
  00180	e28dd014	 add         sp, sp, #0x14
  00184	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00188	e12fff1e	 bx          lr
  0018c		 |$LN34@ReadDMA|
  0018c		 |$LN35@ReadDMA|
  0018c	00000000	 DCD         |??_C@_1DM@NJMLNKGC@?$AAA?$AAs?$AAs?$AAu?$AAm?$AAe?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAn?$AAe?$AAx?$AAt?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?5?$AAa?$AAr?$AAr?$AAi?$AAv?$AAe?$AA?$AN?$AA?6?$AA?$AA@|
  00190		 |$LN36@ReadDMA|
  00190	00000000	 DCD         |??_C@_1BK@KBIGIHKK@?$AAD?$AAe?$AAb?$AAu?$AAg?$AA?5?$AAh?$AAe?$AAr?$AAe?$AA?$AN?$AA?6?$AA?$AA@|
  00194		 |$LN37@ReadDMA|
  00194	00000000	 DCD         |??_C@_1FI@MCGAOEPM@?$AAR?$AAe?$AAa?$AAd?$AAD?$AAM?$AAA?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?5?$AA0?$AA?0?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAR?$AAx?$AAC@|
  00198		 |$LN38@ReadDMA|
  00198	00000000	 DCD         |??_C@_1GO@KEJCKFIF@?$AAR?$AAe?$AAa?$AAd?$AAD?$AAM?$AAA?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAT?$AAo?$AAt?$AAT?$AAf?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN@|
  0019c		 |$M45833|

			 ENDP  ; |?ReadDMA@CHW@@QAAKPAXEE0KKPAVCQTD@@@Z|, CHW::ReadDMA

	EXPORT	|??_C@_1EM@CHCHNIDI@?$AAN?$AAo?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?5?$AAa?$AAv?$AAa?$AAi?$AAl?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAR?$AAx?$AAC?$AAS?$AAR?$AA?5?$AA?$DN?$AA?5?$AA0@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HK@FIIANMKL@?$AAC?$AAH?$AAW?$AA?3?$AA?3?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAT?$AAD?$AA?3?$AA?5?$AAT?$AAI?$AAM?$AAE?$AAO?$AAU?$AAT?$AA?5?$AAS?$AAe?$AAn?$AAd?$AAi?$AAn?$AAg?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EI@MNPANNOD@?$AAS?$AAo?$AAm?$AAe?$AAt?$AAh?$AAi?$AAn?$AAg?$AA?5?$AAw?$AAr?$AAo?$AAn?$AAg?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?5?$AA?$CF?$AAd?$AA?$CB?$AA?$CB@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GG@IBBFPGMN@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?0?$AA?5?$AAg@| [ DATA ] ; `string'
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\ctd.h

  00000			 AREA	 |.pdata|, PDATA
|$T46015| DCD	|$LN135@ProcessTD|
	DCD	0x40019e02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EM@CHCHNIDI@?$AAN?$AAo?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?5?$AAa?$AAv?$AAa?$AAi?$AAl?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAR?$AAx?$AAC?$AAS?$AAR?$AA?5?$AA?$DN?$AA?5?$AA0@| DCB "N"
	DCB	0x0, "o", 0x0, " ", 0x0, "d", 0x0, "a", 0x0, "t", 0x0, "a"
	DCB	0x0, " ", 0x0, "a", 0x0, "v", 0x0, "a", 0x0, "i", 0x0, "l"
	DCB	0x0, "a", 0x0, "b", 0x0, "l", 0x0, "e", 0x0, " ", 0x0, "w"
	DCB	0x0, "i", 0x0, "t", 0x0, "h", 0x0, " ", 0x0, "R", 0x0, "x"
	DCB	0x0, "C", 0x0, "S", 0x0, "R", 0x0, " ", 0x0, "=", 0x0, " "
	DCB	0x0, "0", 0x0, "x", 0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HK@FIIANMKL@?$AAC?$AAH?$AAW?$AA?3?$AA?3?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAT?$AAD?$AA?3?$AA?5?$AAT?$AAI?$AAM?$AAE?$AAO?$AAU?$AAT?$AA?5?$AAS?$AAe?$AAn?$AAd?$AAi?$AAn?$AAg?$AA?5@| DCB "C"
	DCB	0x0, "H", 0x0, "W", 0x0, ":", 0x0, ":", 0x0, "P", 0x0, "r"
	DCB	0x0, "o", 0x0, "c", 0x0, "e", 0x0, "s", 0x0, "s", 0x0, "T"
	DCB	0x0, "D", 0x0, ":", 0x0, " ", 0x0, "T", 0x0, "I", 0x0, "M"
	DCB	0x0, "E", 0x0, "O", 0x0, "U", 0x0, "T", 0x0, " ", 0x0, "S"
	DCB	0x0, "e", 0x0, "n", 0x0, "d", 0x0, "i", 0x0, "n", 0x0, "g"
	DCB	0x0, " ", 0x0, "Z", 0x0, "E", 0x0, "R", 0x0, "O", 0x0, "_"
	DCB	0x0, "L", 0x0, "E", 0x0, "N", 0x0, "G", 0x0, "T", 0x0, "H"
	DCB	0x0, " ", 0x0, "P", 0x0, "A", 0x0, "C", 0x0, "K", 0x0, "E"
	DCB	0x0, "T", 0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%", 0x0, "0"
	DCB	0x0, "4", 0x0, "X", 0x0, ";", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EI@MNPANNOD@?$AAS?$AAo?$AAm?$AAe?$AAt?$AAh?$AAi?$AAn?$AAg?$AA?5?$AAw?$AAr?$AAo?$AAn?$AAg?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?5?$AA?$CF?$AAd?$AA?$CB?$AA?$CB@| DCB "S"
	DCB	0x0, "o", 0x0, "m", 0x0, "e", 0x0, "t", 0x0, "h", 0x0, "i"
	DCB	0x0, "n", 0x0, "g", 0x0, " ", 0x0, "w", 0x0, "r", 0x0, "o"
	DCB	0x0, "n", 0x0, "g", 0x0, " ", 0x0, "w", 0x0, "i", 0x0, "t"
	DCB	0x0, "h", 0x0, " ", 0x0, "s", 0x0, "t", 0x0, "a", 0x0, "t"
	DCB	0x0, "u", 0x0, "s", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, "!"
	DCB	0x0, "!", 0x0, "!", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GG@IBBFPGMN@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?0?$AA?5?$AAg@| DCB "F"
	DCB	0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, " "
	DCB	0x0, "t", 0x0, "o", 0x0, " ", 0x0, "g", 0x0, "e", 0x0, "t"
	DCB	0x0, " ", 0x0, "t", 0x0, "h", 0x0, "e", 0x0, " ", 0x0, "D"
	DCB	0x0, "M", 0x0, "A", 0x0, " ", 0x0, "c", 0x0, "h", 0x0, "a"
	DCB	0x0, "n", 0x0, "n", 0x0, "e", 0x0, "l", 0x0, ",", 0x0, " "
	DCB	0x0, "g", 0x0, "o", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "t"
	DCB	0x0, "o", 0x0, " ", 0x0, "F", 0x0, "I", 0x0, "F", 0x0, "O"
	DCB	0x0, " ", 0x0, "m", 0x0, "o", 0x0, "d", 0x0, "e", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ProcessTD@CHW@@UAAHEPAX@Z| PROC	; CHW::ProcessTD

; 2832 : {

  00000		 |$LN135@ProcessTD|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd024	 sub         sp, sp, #0x24
  00008		 |$M46012|
  00008	e1a07002	 mov         r7, r2
  0000c	e1a09001	 mov         r9, r1
  00010	e1a08000	 mov         r8, r0

; 2833 :     CQTD *pQTD = (CQTD *)pData;
; 2834 :     CPipe *pPipe = pQTD->GetQH()->GetPipe();        

  00014	e5973004	 ldr         r3, [r7, #4]

; 2835 :     PHSMUSB_T pOTG;
; 2836 :     DWORD dwType;
; 2837 :     BOOL    bResult = FALSE;
; 2838 :     UCHAR   csrIndex;
; 2839 :     
; 2840 :     pOTG = (PHSMUSB_T)GetOTGContext();

  00018	e598e0b0	 ldr         lr, [r8, #0xB0]
  0001c	e3a05000	 mov         r5, #0
  00020	e593a000	 ldr         r10, [r3]
  00024	e1b0600e	 movs        r6, lr

; 2841 :     if (pOTG == NULL)
; 2842 :     {
; 2843 :         DEBUGMSG(ZONE_ERROR, (TEXT("Failed to read the FIFO for ep %d\r\n"), endpoint));
; 2844 :         return bResult;

  00028	0a00015f	 beq         |$LN130@ProcessTD|

; 2845 :     }
; 2846 : 
; 2847 :     dwType = pQTD->GetTDType();

  0002c	e597300c	 ldr         r3, [r7, #0xC]

; 2848 :         
; 2849 :     
; 2850 :     switch(dwType) 

  00030	e3530001	 cmp         r3, #1
  00034	0a00015a	 beq         |$LN42@ProcessTD|
  00038	e3530002	 cmp         r3, #2
  0003c	0a0000ea	 beq         |$LN38@ProcessTD|
  00040	e3530003	 cmp         r3, #3
  00044	0a000043	 beq         |$LN26@ProcessTD|
  00048	e3530004	 cmp         r3, #4
  0004c	0a000025	 beq         |$LN4@ProcessTD|
  00050	e3530005	 cmp         r3, #5
  00054	1a00017f	 bne         |$LN40@ProcessTD|

; 3001 :     case (TD_STATUS_OUT):
; 3002 :         DEBUGMSG(ZONE_HCD, (TEXT("Process TD_STATUS_OUT\r\n")));
; 3003 :         if (endpoint != 0) 

  00058	e3590000	 cmp         r9, #0

; 3004 :         {
; 3005 :             DEBUGMSG(ZONE_ERROR, (TEXT("Control Pipe for ep %d not support\r\n"), endpoint));
; 3006 :             bResult = FALSE;
; 3007 :         }
; 3008 :         else

  0005c	1a000152	 bne         |$LN130@ProcessTD|

; 3009 :         {
; 3010 :             // Set Index Register
; 3011 :             EnterCriticalSection(&pOTG->regCS);    

  00060	e2860038	 add         r0, r6, #0x38
  00064	eb000000	 bl          EnterCriticalSection

; 3012 :             OUTREG8(&pOTG->pUsbGenRegs->Index, INDEX(endpoint));

  00068	e5963020	 ldr         r3, [r6, #0x20]
  0006c	e3a04000	 mov         r4, #0
  00070	e3a02cff	 mov         r2, #0xFF, 24
  00074	e5c3400e	 strb        r4, [r3, #0xE]

; 3013 :             csrIndex = INDEX(endpoint);
; 3014 : 
; 3015 :             // 0. Clear any thing before access - as it has some invalid IN transcation from analyzer
; 3016 :             CLRREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0, CSR0_H_RxPktRdy|CSR0_H_ReqPkt|CSR0_H_SetupPkt);

  00078	e596e01c	 ldr         lr, [r6, #0x1C]
  0007c	e38210d6	 orr         r1, r2, #0xD6

; 3017 : 
; 3018 :             {   
; 3019 :                 UCHAR DataToggle = 0;
; 3020 :                 if(INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0) & CSR0_H_DataToggle)
; 3021 :                     DataToggle = 1;//Verify
; 3022 : 
; 3023 :                 //UCHAR DataToggle = (INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0) & CSR0_H_DataToggle) >> CSR0_H_DataToggle;
; 3024 :                 DEBUGMSG(ZONE_HCD, (TEXT("[DataToggle]:Request:Status OUT Trasaction on EP 0 Device Addr %d DataToggle = %d\r\n"), 
; 3025 :                         pPipe->GetReservedDeviceAddr(), DataToggle));
; 3026 :             }
; 3027 : 
; 3028 :             pQTD->SetCurTfrSize(0);            
; 3029 :             // 1. Set the StatusPkt, TxPktRdy
; 3030 :             SETREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0, (CSR0_H_StatusPkt|CSR0_H_TxPktRdy));            
; 3031 : 
; 3032 :             // 2. Wait for transfer interrupt signal
; 3033 :             pQTD->SetStatus(STATUS_WAIT_RESPONSE);

  00080	e3a05003	 mov         r5, #3
  00084	e5de2002	 ldrb        r2, [lr, #2]
  00088	e5de3003	 ldrb        r3, [lr, #3]

; 3034 :             LeaveCriticalSection(&pOTG->regCS);

  0008c	e1823403	 orr         r3, r2, r3, lsl #8
  00090	e0033001	 and         r3, r3, r1
  00094	e1a02423	 mov         r2, r3, lsr #8
  00098	e5ce3002	 strb        r3, [lr, #2]
  0009c	e5ce2003	 strb        r2, [lr, #3]
  000a0	e596301c	 ldr         r3, [r6, #0x1C]
  000a4	e5d32002	 ldrb        r2, [r3, #2]
  000a8	e5d33003	 ldrb        r3, [r3, #3]
  000ac	e5874020	 str         r4, [r7, #0x20]
  000b0	e596101c	 ldr         r1, [r6, #0x1C]
  000b4	e1823403	 orr         r3, r2, r3, lsl #8
  000b8	e5d12002	 ldrb        r2, [r1, #2]
  000bc	e5d13003	 ldrb        r3, [r1, #3]
  000c0	e1823403	 orr         r3, r2, r3, lsl #8
  000c4	e3833042	 orr         r3, r3, #0x42
  000c8	e1a02423	 mov         r2, r3, lsr #8
  000cc	e5c13002	 strb        r3, [r1, #2]
  000d0	e5c12003	 strb        r2, [r1, #3]
  000d4	e5875028	 str         r5, [r7, #0x28]
  000d8		 |$LN132@ProcessTD|
  000d8	e2860038	 add         r0, r6, #0x38
  000dc	eb000000	 bl          LeaveCriticalSection

; 3035 :             bResult = TRUE;

  000e0	e3a05001	 mov         r5, #1

; 3036 :         }
; 3037 :         break;

  000e4	ea00015b	 b           |$LN40@ProcessTD|
  000e8		 |$LN4@ProcessTD|

; 3178 : 
; 3179 :     case (TD_STATUS_IN):
; 3180 :         DEBUGMSG(ZONE_HCD, (TEXT("Process TD_STATUS_IN\r\n")));
; 3181 :         if (endpoint != 0) 

  000e8	e3590000	 cmp         r9, #0

; 3182 :         {
; 3183 :             DEBUGMSG(ZONE_ERROR, (TEXT("Control Pipe for ep %d not support\r\n"), endpoint));
; 3184 :             bResult = FALSE;
; 3185 :         }
; 3186 :         else

  000ec	1a00012e	 bne         |$LN130@ProcessTD|

; 3187 :         {
; 3188 :             // Set Index Register
; 3189 :             EnterCriticalSection(&pOTG->regCS);    

  000f0	e2860038	 add         r0, r6, #0x38
  000f4	eb000000	 bl          EnterCriticalSection

; 3190 :             OUTREG8(&pOTG->pUsbGenRegs->Index, INDEX(endpoint));

  000f8	e5963020	 ldr         r3, [r6, #0x20]
  000fc	e3a02000	 mov         r2, #0
  00100	e3a01cff	 mov         r1, #0xFF, 24
  00104	e5c3200e	 strb        r2, [r3, #0xE]

; 3191 :             csrIndex = INDEX(endpoint);
; 3192 : 
; 3193 :             // 0. Clear any thing before access - as it has some invalid IN transcation from analyzer
; 3194 :             CLRREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0, CSR0_H_RxPktRdy|CSR0_H_ReqPkt|CSR0_H_SetupPkt);

  00108	e596e01c	 ldr         lr, [r6, #0x1C]
  0010c	e38110d6	 orr         r1, r1, #0xD6

; 3195 : 
; 3196 : #ifdef DEBUG
; 3197 :             {
; 3198 :                 DWORD DataToggle = (INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0) & CSR0_H_DataToggle);
; 3199 :                 DEBUGMSG(ZONE_HCD, (TEXT("[DataToggle]:Request:Status IN Trasaction on EP 0 Device Addr %d DataToggle = 0x%x\r\n"), 
; 3200 :                         pPipe->GetReservedDeviceAddr(), DataToggle));
; 3201 :             }
; 3202 : #endif
; 3203 : 
; 3204 :             // 1. Set the StatusPkt, TxPktRdy
; 3205 :             SETREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0, (CSR0_H_StatusPkt|CSR0_H_ReqPkt));            
; 3206 : 
; 3207 :             // 2. Wait for transfer interrupt signal
; 3208 :             pQTD->SetStatus(STATUS_WAIT_RESPONSE);

  00110	e3a04003	 mov         r4, #3
  00114	e5de2002	 ldrb        r2, [lr, #2]
  00118	e5de3003	 ldrb        r3, [lr, #3]

; 3209 :             LeaveCriticalSection(&pOTG->regCS);

  0011c	e1823403	 orr         r3, r2, r3, lsl #8
  00120	e0033001	 and         r3, r3, r1
  00124	e1a02423	 mov         r2, r3, lsr #8
  00128	e5ce3002	 strb        r3, [lr, #2]
  0012c	e5ce2003	 strb        r2, [lr, #3]
  00130	e596101c	 ldr         r1, [r6, #0x1C]
  00134	e5d12002	 ldrb        r2, [r1, #2]
  00138	e5d13003	 ldrb        r3, [r1, #3]
  0013c	e1823403	 orr         r3, r2, r3, lsl #8
  00140	e3833060	 orr         r3, r3, #0x60
  00144	e1a02423	 mov         r2, r3, lsr #8
  00148	e5c13002	 strb        r3, [r1, #2]
  0014c	e5c12003	 strb        r2, [r1, #3]
  00150	e5874028	 str         r4, [r7, #0x28]

; 3210 :             bResult = TRUE;
; 3211 :         }
; 3212 : 
; 3213 :         break;

  00154	eaffffdf	 b           |$LN132@ProcessTD|
  00158		 |$LN26@ProcessTD|

; 3038 :     case (TD_DATA_OUT):
; 3039 :         {
; 3040 :             // Set Index Register
; 3041 :             EnterCriticalSection(&pOTG->regCS);    

  00158	e2860038	 add         r0, r6, #0x38
  0015c	eb000000	 bl          EnterCriticalSection

; 3042 :             OUTREG8(&pOTG->pUsbGenRegs->Index, INDEX(endpoint));

  00160	e5963020	 ldr         r3, [r6, #0x20]
  00164	e209400f	 and         r4, r9, #0xF
  00168	e5cd4010	 strb        r4, [sp, #0x10]
  0016c	e5c3400e	 strb        r4, [r3, #0xE]

; 3043 :             csrIndex = INDEX(endpoint);
; 3044 : 
; 3045 :             DEBUGMSG(ZONE_TRANSFER, (TEXT("Request OUT Transfer for EP %d, size %d MappedEP %d, Device %d, TxCSR 0x%x\r\n"),
; 3046 :                 INDEX(endpoint), pQTD->GetDataSize() - pQTD->GetTotTfrSize(),  USB_ENDPOINT(pPipe->GetMappedEndPoint()),
; 3047 :                 pPipe->GetReservedDeviceAddr(), INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR)));
; 3048 :             
; 3049 :             // 1. Load data into FIFO
; 3050 :             // 1.a. Get the virtual address of buffer and corresponding start address (must be 0)
; 3051 :             UCHAR *pvData = (UCHAR *)pQTD->GetVAData();
; 3052 :             UCHAR *ppData = (UCHAR *)pQTD->GetPAData();
; 3053 :             DWORD cbStart = pQTD->GetTotTfrSize();
; 3054 :             DWORD cbTemp = cbStart;
; 3055 :             DWORD dwPacketSize = pQTD->GetPacketSize();
; 3056 :             DWORD cbToTransfer;            
; 3057 : 
; 3058 :             if (pPipe->GetTransferMode() == TRANSFER_DMA1)          

  00170	e5972014	 ldr         r2, [r7, #0x14]
  00174	e5da3014	 ldrb        r3, [r10, #0x14]
  00178	e597102c	 ldr         r1, [r7, #0x2C]
  0017c	e58d2020	 str         r2, [sp, #0x20]
  00180	e5972010	 ldr         r2, [r7, #0x10]
  00184	e3530002	 cmp         r3, #2

; 3059 :             {
; 3060 :                 cbToTransfer = pQTD->GetDataSize() - cbStart;                          

  00188	e5973018	 ldr         r3, [r7, #0x18]
  0018c	e58d2018	 str         r2, [sp, #0x18]
  00190	e597201c	 ldr         r2, [r7, #0x1C]
  00194	e58d101c	 str         r1, [sp, #0x1C]
  00198	e58d2014	 str         r2, [sp, #0x14]
  0019c	e043b002	 sub         r11, r3, r2

; 3061 :             }
; 3062 :             else

  001a0	0a000001	 beq         |$LN51@ProcessTD|

; 3063 :             {
; 3064 :                 cbToTransfer = min(pQTD->GetDataSize() - cbStart, dwPacketSize);                           

  001a4	e15b0001	 cmp         r11, r1
  001a8	21a0b001	 movcs       r11, r1
  001ac		 |$LN51@ProcessTD|

; 3065 :             }
; 3066 : 
; 3067 :             // We need to get the max packet size in here            
; 3068 :             DEBUGMSG( ZONE_HCD, (TEXT("Packet Size = 0x%x for ep %d\r\n"), dwPacketSize, endpoint));
; 3069 :             DEBUGMSG( ZONE_HCD, (TEXT("Process TD_DATA_OUT at endpoint %d size %d\r\n"), endpoint, cbToTransfer));
; 3070 :             //memdump((UCHAR *)(pvData+cbTemp), (USHORT)cbToTransfer, 0);
; 3071 : 
; 3072 :             // 1.c Clear any thing before access - as it has some invalid OUT transcation from analyzer
; 3073 :             if (endpoint == 0)
; 3074 :                 CLRREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0, CSR0_H_TxPktRdy);

  001ac	e596301c	 ldr         r3, [r6, #0x1C]
  001b0	e3590000	 cmp         r9, #0
  001b4	e3a02cff	 mov         r2, #0xFF, 24
  001b8	e0830204	 add         r0, r3, r4, lsl #4
  001bc	e5d01002	 ldrb        r1, [r0, #2]
  001c0	e5d03003	 ldrb        r3, [r0, #3]
  001c4	038220fd	 orreq       r2, r2, #0xFD

; 3075 :             else
; 3076 :                 CLRREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR, TXCSR_H_TxPktRdy);

  001c8	138220fe	 orrne       r2, r2, #0xFE
  001cc	e1813403	 orr         r3, r1, r3, lsl #8
  001d0	e0033002	 and         r3, r3, r2
  001d4	e1a02423	 mov         r2, r3, lsr #8
  001d8	e5c03002	 strb        r3, [r0, #2]
  001dc	e5c02003	 strb        r2, [r0, #3]

; 3077 :             //SETREG16(&pOTG->pUsbGenRegs->INDEX_REG.hIndex.CSR.TxCSR, TXCSR_H_ClrDataTog);
; 3078 :             
; 3079 :             // 1.d Set the current size to be transferred.
; 3080 :             pQTD->SetCurTfrSize(cbToTransfer);
; 3081 :             
; 3082 : 
; 3083 : //            UpdateDataToggle(pPipe, FALSE, TRUE);
; 3084 : 
; 3085 :             LeaveCriticalSection(&pOTG->regCS);

  001e0	e2860038	 add         r0, r6, #0x38
  001e4	e587b020	 str         r11, [r7, #0x20]
  001e8	eb000000	 bl          LeaveCriticalSection

; 3086 : 
; 3087 :             if (endpoint == 0)
; 3088 :                 DEBUGMSG(ZONE_HCD, (TEXT("Request OUT ProcessTD EP %d Dev %d data Toggle = 0x%x\r\n"), 
; 3089 :                     endpoint, pPipe->GetReservedDeviceAddr(), INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0) & CSR0_H_DataToggle));
; 3090 :             else
; 3091 :                 DEBUGMSG(ZONE_HCD, (TEXT("Request OUT ProcessTD EP %d Dev %d data Toggle = 0x%x\r\n"), 
; 3092 :                     endpoint, pPipe->GetReservedDeviceAddr(), INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR)& TXCSR_H_DataToggle));
; 3093 : 
; 3094 :             // Dump the TxCSR before out 
; 3095 :             // 1.e Now put data into FIFO for ep 
; 3096 :             if ((pPipe->GetTransferMode() != TRANSFER_FIFO) && (USB_ENDPOINT(endpoint) != 0) && (cbToTransfer != 0))

  001ec	e5da3014	 ldrb        r3, [r10, #0x14]
  001f0	e3530000	 cmp         r3, #0
  001f4	0a00000f	 beq         |$PROCESS_WRITE_FIFO$43228|
  001f8	e3540000	 cmp         r4, #0
  001fc	0a00000d	 beq         |$PROCESS_WRITE_FIFO$43228|
  00200	e35b0000	 cmp         r11, #0
  00204	0a00000b	 beq         |$PROCESS_WRITE_FIFO$43228|

; 3097 :             {    
; 3098 :                 if (pQTD->GetStatus() == STATUS_PROCESS_DMA)

  00208	e5971028	 ldr         r1, [r7, #0x28]
  0020c	e3510006	 cmp         r1, #6
  00210	1a000044	 bne         |$LN18@ProcessTD|

; 3099 :                 {                                    
; 3100 :                     UCHAR channel = pPipe->m_pCMhcd->AcquireDMAChannel(pPipe);

  00214	e59a000c	 ldr         r0, [r10, #0xC]
  00218	e1a0100a	 mov         r1, r10
  0021c	eb000000	 bl          |?AcquireDMAChannel@CHW@@QAAEPAVCPipe@@@Z|
  00220	e1a03000	 mov         r3, r0
  00224	e5cd3011	 strb        r3, [sp, #0x11]

; 3101 :                     if (channel == 0xff)

  00228	e35300ff	 cmp         r3, #0xFF
  0022c	1a000023	 bne         |$LN17@ProcessTD|

; 3102 :                     {
; 3103 :                         RETAILMSG(1, (TEXT("Failed to get the DMA channel, goto to FIFO mode\r\n")));

  00230	e59f043c	 ldr         r0, [pc, #0x43C]
  00234	eb000000	 bl          NKDbgPrintfW
  00238		 |$PROCESS_WRITE_FIFO$43228|

; 3117 :             {                
; 3118 : PROCESS_WRITE_FIFO:
; 3119 :                 EnterCriticalSection(&pOTG->regCS);

  00238	e2860038	 add         r0, r6, #0x38
  0023c	eb000000	 bl          EnterCriticalSection

; 3120 :                 WriteFIFO((void *)pOTG, endpoint, (DWORD *)(pvData+cbTemp), cbToTransfer);                      

  00240	e5980000	 ldr         r0, [r8]
  00244	e59d1014	 ldr         r1, [sp, #0x14]
  00248	e59d3020	 ldr         r3, [sp, #0x20]
  0024c	e5904058	 ldr         r4, [r0, #0x58]
  00250	e1a00008	 mov         r0, r8
  00254	e0813003	 add         r3, r1, r3
  00258	e1a01006	 mov         r1, r6
  0025c	e1a02009	 mov         r2, r9
  00260	e58db000	 str         r11, [sp]
  00264	e1a0e00f	 mov         lr, pc
  00268	e12fff14	 bx          r4

; 3121 : 
; 3122 :                 // 2. Set the SetupPkt & TxPtRdy bits
; 3123 :                 if (endpoint == 0)
; 3124 :                     DEBUGMSG(ZONE_HCD, (TEXT("Data OUT Packet requested with CSR0 = 0x%x\r\n"), 
; 3125 :                         INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0)));
; 3126 :                 else
; 3127 :                     DEBUGMSG(ZONE_HCD, (TEXT("Data OUT Packet requested with TxCSR = 0x%x\r\n"), 
; 3128 :                         INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR)));
; 3129 : 
; 3130 :                 if (endpoint == 0)

  0026c	e3590000	 cmp         r9, #0

; 3131 :                 {
; 3132 : #ifdef DEBUG
; 3133 :                     DWORD DataToggle = (INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0) & CSR0_H_DataToggle);
; 3134 :                     DEBUGMSG(ZONE_HCD, (TEXT("[DataToggle]:Request:Data OUT Trasaction on EP %d Device Addr %d DataToggle = 0x%x\r\n"), 
; 3135 :                                 csrIndex, pPipe->GetReservedDeviceAddr(), DataToggle));
; 3136 : #endif
; 3137 :                     UpdateDataToggle(pPipe, FALSE, TRUE);

  00270	e3a03001	 mov         r3, #1
  00274	e3a02000	 mov         r2, #0
  00278	1a00002d	 bne         |$LN11@ProcessTD|
  0027c	e5980000	 ldr         r0, [r8]
  00280	e1a0100a	 mov         r1, r10
  00284	e5904044	 ldr         r4, [r0, #0x44]
  00288	e1a00008	 mov         r0, r8
  0028c	e1a0e00f	 mov         lr, pc
  00290	e12fff14	 bx          r4

; 3138 :                     SETREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0, CSR0_H_TxPktRdy);                

  00294	e596301c	 ldr         r3, [r6, #0x1C]
  00298	e5dd0010	 ldrb        r0, [sp, #0x10]
  0029c	e0831200	 add         r1, r3, r0, lsl #4
  002a0	e5d12002	 ldrb        r2, [r1, #2]
  002a4	e5d13003	 ldrb        r3, [r1, #3]
  002a8	e1823403	 orr         r3, r2, r3, lsl #8
  002ac	e3833002	 orr         r3, r3, #2
  002b0	e1a02423	 mov         r2, r3, lsr #8
  002b4	e5c13002	 strb        r3, [r1, #2]
  002b8	e5c12003	 strb        r2, [r1, #3]

; 3139 :                 }
; 3140 :                 else

  002bc	eaffff85	 b           |$LN132@ProcessTD|
  002c0		 |$LN17@ProcessTD|

; 3104 :                         goto PROCESS_WRITE_FIFO;
; 3105 :                     }
; 3106 :                     UpdateDataToggle(pPipe, FALSE, TRUE);

  002c0	e5980000	 ldr         r0, [r8]
  002c4	e3a03001	 mov         r3, #1
  002c8	e3a02000	 mov         r2, #0
  002cc	e5904044	 ldr         r4, [r0, #0x44]
  002d0	e1a00008	 mov         r0, r8
  002d4	e1a0100a	 mov         r1, r10
  002d8	e1a0e00f	 mov         lr, pc
  002dc	e12fff14	 bx          r4

; 3107 : 					
; 3108 :                     DEBUGMSG(ZONE_TRANSFER, (TEXT("ProcessTD::WriteDMA at ep %d (mapped %d), size %d channel %d\r\n"), 
; 3109 :                         endpoint, pPipe->GetMappedEndPoint(), cbToTransfer, channel));                    
; 3110 :                     bResult = WriteDMA((void *)pOTG, pPipe->GetMappedEndPoint(), channel, (DWORD *)(ppData+cbTemp), 
; 3111 :                         cbToTransfer, dwPacketSize, (void *)pQTD);                                        

  002e0	e59d1014	 ldr         r1, [sp, #0x14]
  002e4	e59d0018	 ldr         r0, [sp, #0x18]
  002e8	e5983000	 ldr         r3, [r8]
  002ec	e5da2058	 ldrb        r2, [r10, #0x58]
  002f0	e0814000	 add         r4, r1, r0
  002f4	e1a01006	 mov         r1, r6
  002f8	e59d601c	 ldr         r6, [sp, #0x1C]
  002fc	e5935060	 ldr         r5, [r3, #0x60]
  00300	e5dd3011	 ldrb        r3, [sp, #0x11]
  00304	e58d6008	 str         r6, [sp, #8]
  00308	e1a00008	 mov         r0, r8
  0030c	e58d700c	 str         r7, [sp, #0xC]
  00310	e58db004	 str         r11, [sp, #4]
  00314	e58d4000	 str         r4, [sp]
  00318	e1a0e00f	 mov         lr, pc
  0031c	e12fff15	 bx          r5
  00320	e1a05000	 mov         r5, r0

; 3112 :                 }
; 3113 :                 else

  00324	ea0000cb	 b           |$LN40@ProcessTD|
  00328		 |$LN18@ProcessTD|

; 3114 :                     RETAILMSG(1, (TEXT("Something wrong with status %d!!!\r\n"), pQTD->GetStatus()));

  00328	e59f0340	 ldr         r0, [pc, #0x340]
  0032c	eb000000	 bl          NKDbgPrintfW

; 3115 :             }
; 3116 :             else 

  00330	ea0000c8	 b           |$LN40@ProcessTD|
  00334		 |$LN11@ProcessTD|

; 3141 :                 {                                        
; 3142 : #ifdef DEBUG
; 3143 :                     DWORD DataToggle = (INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR) & TXCSR_H_DataToggle);
; 3144 :                     DEBUGMSG(ZONE_HCD, (TEXT("[DataToggle]:Request:Data OUT Trasaction on EP %d Device Addr %d DataToggle = 0x%x\r\n"), 
; 3145 :                                     csrIndex, pPipe->GetReservedDeviceAddr(), DataToggle));
; 3146 : #endif
; 3147 :                     UpdateDataToggle(pPipe, FALSE, TRUE);

  00334	e5981000	 ldr         r1, [r8]
  00338	e1a00008	 mov         r0, r8
  0033c	e5914044	 ldr         r4, [r1, #0x44]
  00340	e1a0100a	 mov         r1, r10
  00344	e1a0e00f	 mov         lr, pc
  00348	e12fff14	 bx          r4

; 3148 :                     DEBUGMSG(ZONE_TRANSFER, (TEXT("Request OUT data for ep %d size %d\r\n"), csrIndex, cbToTransfer));
; 3149 :                     SETREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR, TXCSR_H_TxPktRdy);                

  0034c	e596301c	 ldr         r3, [r6, #0x1C]

; 3150 : #if 1
; 3151 :                     if (cbToTransfer > 0)                  

  00350	e5dd0010	 ldrb        r0, [sp, #0x10]
  00354	e35b0000	 cmp         r11, #0
  00358	e0831200	 add         r1, r3, r0, lsl #4
  0035c	e5d12002	 ldrb        r2, [r1, #2]
  00360	e5d13003	 ldrb        r3, [r1, #3]
  00364	e1823403	 orr         r3, r2, r3, lsl #8
  00368	e3833001	 orr         r3, r3, #1
  0036c	e1a02423	 mov         r2, r3, lsr #8
  00370	e5c13002	 strb        r3, [r1, #2]

; 3152 :                         pQTD->SetStatus(STATUS_WAIT_RESPONSE);            

  00374	13a03003	 movne       r3, #3
  00378	e5c12003	 strb        r2, [r1, #3]
  0037c	15873028	 strne       r3, [r7, #0x28]
  00380	1affff54	 bne         |$LN132@ProcessTD|

; 3153 :                     else
; 3154 :                     {
; 3155 :                         UINT32 timeout = 100000;

  00384	e596301c	 ldr         r3, [r6, #0x1C]
  00388	e3a02b61	 mov         r2, #0x61, 22
  0038c	e3821e2a	 orr         r1, r2, #0x2A, 28
  00390	e0830200	 add         r0, r3, r0, lsl #4
  00394		 |$LL7@ProcessTD|

; 3156 :                         while (INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR) & TXCSR_H_TxPktRdy && timeout-- > 0);

  00394	e5d02002	 ldrb        r2, [r0, #2]
  00398	e5d03003	 ldrb        r3, [r0, #3]
  0039c	e1823403	 orr         r3, r2, r3, lsl #8
  003a0	e3130001	 tst         r3, #1
  003a4	0a000002	 beq         |$LN6@ProcessTD|
  003a8	e3510000	 cmp         r1, #0
  003ac	e2411001	 sub         r1, r1, #1
  003b0	1afffff7	 bne         |$LL7@ProcessTD|
  003b4		 |$LN6@ProcessTD|

; 3157 : 
; 3158 :                         if (timeout == 0) {

  003b4	e3510000	 cmp         r1, #0

; 3159 :                             RETAILMSG(1,(L"CHW::ProcessTD: TIMEOUT Sending ZERO_LENGTH PACKET 0x%04X;\r\n",
; 3160 :                             INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.TxCSR)));

  003b8	05d02002	 ldreqb      r2, [r0, #2]
  003bc	05d03003	 ldreqb      r3, [r0, #3]
  003c0	059f02a4	 ldreq       r0, [pc, #0x2A4]
  003c4	01821403	 orreq       r1, r2, r3, lsl #8
  003c8	0b000000	 bleq        NKDbgPrintfW

; 3161 :                         }
; 3162 : 					
; 3163 :                         pQTD->SetStatus(STATUS_COMPLETE);

  003cc	e3a03011	 mov         r3, #0x11
  003d0	e5873028	 str         r3, [r7, #0x28]

; 3164 :                         pPipe->CheckForDoneTransfers();

  003d4	e59a3000	 ldr         r3, [r10]
  003d8	e1a0000a	 mov         r0, r10
  003dc	e5933034	 ldr         r3, [r3, #0x34]
  003e0	e1a0e00f	 mov         lr, pc
  003e4	e12fff13	 bx          r3

; 3165 :                     }
; 3166 : #else
; 3167 :                     pQTD->SetStatus(STATUS_WAIT_RESPONSE);            
; 3168 : #endif
; 3169 : 
; 3170 :                 }
; 3171 : 
; 3172 :                 // 3. Wait for transfer interrupt signal                
; 3173 :                 LeaveCriticalSection(&pOTG->regCS);
; 3174 :                 bResult = TRUE;
; 3175 :             }
; 3176 :         }
; 3177 :         break;

  003e8	eaffff3a	 b           |$LN132@ProcessTD|
  003ec		 |$LN38@ProcessTD|

; 2904 :         }
; 2905 :         break;         
; 2906 : 
; 2907 :     case (TD_DATA_IN):
; 2908 :         {
; 2909 :             BOOL bRequestData = TRUE;
; 2910 : 
; 2911 :             DEBUGMSG(ZONE_HCD, (TEXT("Request IN Transfer for EP %d, Dev %d size %d, PipeMapped %d, RxCSR(0x%x)\r\n"),
; 2912 :                 INDEX(endpoint), pPipe->GetReservedDeviceAddr(), pQTD->GetDataSize() - pQTD->GetTotTfrSize(), USB_ENDPOINT(pPipe->GetMappedEndPoint()),
; 2913 :                 INREG16(&pOTG->pUsbCsrRegs->ep[INDEX(endpoint)].RxCSR)));
; 2914 : 
; 2915 :             // Check if there is any data already available
; 2916 :             if (GetRxDataAvail(USB_ENDPOINT(endpoint)))

  003ec	e2883c02	 add         r3, r8, #2, 24
  003f0	e1d337ba	 ldrh        r3, [r3, #0x7A]
  003f4	e209400f	 and         r4, r9, #0xF
  003f8	e3a02001	 mov         r2, #1
  003fc	e1a09412	 mov         r9, r2, lsl r4
  00400	e3a0b001	 mov         r11, #1
  00404	e1130009	 tst         r3, r9
  00408	e3a03003	 mov         r3, #3
  0040c	0a00002a	 beq         |$LN128@ProcessTD|

; 2917 :             {
; 2918 :                 pQTD->SetStatus(STATUS_WAIT_RESPONSE);            
; 2919 :                 // Set Index Register
; 2920 :                 EnterCriticalSection(&pOTG->regCS);    

  00410	e2860038	 add         r0, r6, #0x38
  00414	e5873028	 str         r3, [r7, #0x28]
  00418	eb000000	 bl          EnterCriticalSection

; 2921 :                 OUTREG8(&pOTG->pUsbGenRegs->Index, INDEX(endpoint));

  0041c	e5963020	 ldr         r3, [r6, #0x20]
  00420	e1a01004	 mov         r1, r4
  00424	e5c3100e	 strb        r1, [r3, #0xE]

; 2922 :                 csrIndex = INDEX(endpoint);
; 2923 : 
; 2924 :                 //Check if RxCount
; 2925 :                 DWORD dwTotal = INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].Count.RxCount);

  00428	e596301c	 ldr         r3, [r6, #0x1C]
  0042c	e0830201	 add         r0, r3, r1, lsl #4
  00430	e5d02008	 ldrb        r2, [r0, #8]
  00434	e5d03009	 ldrb        r3, [r0, #9]
  00438	e192e403	 orrs        lr, r2, r3, lsl #8

; 2926 :                 // We check the RxCount if it is smaller than data size since i found it sometimes,
; 2927 :                 // it gives weird values.
; 2928 :                 //RETAILMSG(1, (TEXT("ProcessTD:DataIN: RxDataAvail =%d, Count = %d, RxCSR = 0x%x\r\n"),
; 2929 :                 //      GetRxDataAvail(USB_ENDPOINT(endpoint)),
; 2930 :                 //      dwTotal,
; 2931 :                 //      INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR)));
; 2932 : 
; 2933 :                 if (((dwTotal > 0) && (dwTotal <= pQTD->GetDataSize())) &&
; 2934 :                     (INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR) & RXCSR_H_RxPktRdy))

  0043c	0a000014	 beq         |$LN36@ProcessTD|
  00440	e5973018	 ldr         r3, [r7, #0x18]
  00444	e15e0003	 cmp         lr, r3
  00448	8a000011	 bhi         |$LN36@ProcessTD|
  0044c	e5d02006	 ldrb        r2, [r0, #6]
  00450	e5d03007	 ldrb        r3, [r0, #7]
  00454	e1823403	 orr         r3, r2, r3, lsl #8
  00458	e3130001	 tst         r3, #1
  0045c	0a00000c	 beq         |$LN36@ProcessTD|

; 2935 :                 {   
; 2936 :                     bRequestData = FALSE;
; 2937 :                     ClrRxDataAvail(USB_ENDPOINT(endpoint));

  00460	e2880c02	 add         r0, r8, #2, 24
  00464	e1d037ba	 ldrh        r3, [r0, #0x7A]

; 2938 :                     Host_ProcessEPxRx((PVOID)pOTG, USB_ENDPOINT(endpoint));                    

  00468	e3a02000	 mov         r2, #0
  0046c	e3a0b000	 mov         r11, #0
  00470	e1c33009	 bic         r3, r3, r9
  00474	e1c037ba	 strh        r3, [r0, #0x7A]
  00478	e5963014	 ldr         r3, [r6, #0x14]
  0047c	e5930004	 ldr         r0, [r3, #4]
  00480	e5903000	 ldr         r3, [r0]
  00484	e59330a0	 ldr         r3, [r3, #0xA0]
  00488	e1a0e00f	 mov         lr, pc
  0048c	e12fff13	 bx          r3
  00490	ea000005	 b           |$LN49@ProcessTD|
  00494		 |$LN36@ProcessTD|

; 2939 :                 }
; 2940 :                 else if (dwTotal == 0)

  00494	e35e0000	 cmp         lr, #0

; 2941 :                 {
; 2942 :                     RETAILMSG(1, (TEXT("No data available with RxCSR = 0x%x\r\n"),
; 2943 :                         INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR)));

  00498	05d02006	 ldreqb      r2, [r0, #6]
  0049c	05d03007	 ldreqb      r3, [r0, #7]
  004a0	059f01c0	 ldreq       r0, [pc, #0x1C0]
  004a4	01821403	 orreq       r1, r2, r3, lsl #8
  004a8	0b000000	 bleq        NKDbgPrintfW
  004ac		 |$LN49@ProcessTD|

; 2944 :                     //Sleep(1);
; 2945 :                 }
; 2946 : 
; 2947 :                 LeaveCriticalSection(&pOTG->regCS);

  004ac	e2860038	 add         r0, r6, #0x38
  004b0	eb000000	 bl          LeaveCriticalSection

; 2948 :             }
; 2949 :         
; 2950 :             if (bRequestData)

  004b4	e35b0000	 cmp         r11, #0
  004b8	0a000066	 beq         |$LN40@ProcessTD|
  004bc		 |$LN128@ProcessTD|

; 2951 :             {
; 2952 :                 // Set Index Register
; 2953 :                 EnterCriticalSection(&pOTG->regCS);    

  004bc	e2860038	 add         r0, r6, #0x38
  004c0	eb000000	 bl          EnterCriticalSection

; 2954 :                 OUTREG8(&pOTG->pUsbGenRegs->Index, INDEX(endpoint));

  004c4	e5963020	 ldr         r3, [r6, #0x20]
  004c8	e1b09004	 movs        r9, r4
  004cc	e5c3900e	 strb        r9, [r3, #0xE]

; 2955 :                 csrIndex = INDEX(endpoint);
; 2956 : 
; 2957 :                 if (USB_ENDPOINT(endpoint) == 0)

  004d0	1a000014	 bne         |$LN32@ProcessTD|

; 2958 :                 {               
; 2959 : #ifdef DEBUG
; 2960 :                     DWORD DataToggle = (INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0) & CSR0_H_DataToggle);
; 2961 :                     DEBUGMSG(ZONE_HCD, (TEXT("[DataToggle]: Request:Data IN Trasaction on EP 0 Device Addr %d DataToggle = 0x%x\r\n"), 
; 2962 :                         pPipe->GetReservedDeviceAddr(), DataToggle));
; 2963 : #endif
; 2964 :                     // 0. Clear anything before access - as it has some invalid IN transaction from analyzer
; 2965 :                     CLRREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0, CSR0_H_RxPktRdy|CSR0_H_StatusPkt|CSR0_H_SetupPkt);

  004d4	e596301c	 ldr         r3, [r6, #0x1C]
  004d8	e3a02cff	 mov         r2, #0xFF, 24
  004dc	e38220b6	 orr         r2, r2, #0xB6
  004e0	e0830209	 add         r0, r3, r9, lsl #4
  004e4	e5d01002	 ldrb        r1, [r0, #2]
  004e8	e5d03003	 ldrb        r3, [r0, #3]
  004ec	e1813403	 orr         r3, r1, r3, lsl #8
  004f0	e0033002	 and         r3, r3, r2
  004f4	e1a02423	 mov         r2, r3, lsr #8
  004f8	e5c03002	 strb        r3, [r0, #2]
  004fc	e5c02003	 strb        r2, [r0, #3]

; 2966 :                     // 1. Set ReqPkt (CSR0.D5) = 1
; 2967 :                     SETREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0, CSR0_H_ReqPkt);

  00500	e596301c	 ldr         r3, [r6, #0x1C]
  00504	e0831209	 add         r1, r3, r9, lsl #4
  00508	e5d12002	 ldrb        r2, [r1, #2]
  0050c	e5d13003	 ldrb        r3, [r1, #3]
  00510	e1823403	 orr         r3, r2, r3, lsl #8
  00514	e3833020	 orr         r3, r3, #0x20
  00518	e1a02423	 mov         r2, r3, lsr #8
  0051c	e5c13002	 strb        r3, [r1, #2]
  00520	e5c12003	 strb        r2, [r1, #3]

; 2968 :                     
; 2969 :                 }
; 2970 :                 else

  00524	ea000049	 b           |$LN88@ProcessTD|
  00528		 |$LN32@ProcessTD|

; 2971 :                 {
; 2972 :                     // 0. Clear any thing before access - as it has some invalid IN transcation from analyzer
; 2973 :                     //CLRREG16(&pOTG->pUsbGenRegs->INDEX_REG.hIndex.RxCSR, RXCSR_H_RxPktRdy);
; 2974 :                     //RETAILMSG(1, (TEXT("Force Toggle to see\r\n")));
; 2975 :                     //SETREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR, RXCSR_H_DataTogWrEn|RXCSR_H_DataToggle);
; 2976 : #ifdef DEBUG
; 2977 : 					DWORD DataToggle = (INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR) & RXCSR_H_DataToggle);
; 2978 :                     DEBUGMSG(ZONE_HCD, (TEXT("[DataToggle]:Request:IN Transaction on EP %d Device Addr %d DataToggle = 0x%x\r\n"),
; 2979 :                         csrIndex, pPipe->GetReservedDeviceAddr(), DataToggle));
; 2980 : 
; 2981 :                     USB_ENDPOINT_DESCRIPTOR endpt = pPipe->GetEndptDescriptor();
; 2982 :                     DEBUGMSG(ZONE_HCD, (TEXT("[DataToggle]: Set EP 0x%x(mapped 0x%x) DeviceAddr 0x%x Suggest DataToggle=%d, Actual DataToggle=0x%x\r\n"),
; 2983 :                         endpt.bEndpointAddress, pPipe->GetMappedEndPoint(), pPipe->GetReservedDeviceAddr(), pPipe->GetDataToggle(), DataToggle));
; 2984 : #endif
; 2985 :                
; 2986 :                     //Don't know why it doesn't work: Need to Fix that
; 2987 :                     UpdateDataToggle(pPipe, FALSE, TRUE);                    

  00528	e5981000	 ldr         r1, [r8]
  0052c	e3a03001	 mov         r3, #1
  00530	e3a02000	 mov         r2, #0
  00534	e5914044	 ldr         r4, [r1, #0x44]
  00538	e1a0100a	 mov         r1, r10
  0053c	e1a00008	 mov         r0, r8
  00540	e1a0e00f	 mov         lr, pc
  00544	e12fff14	 bx          r4

; 2988 :                     //UpdateDataToggle(pPipe, FALSE, FALSE);                    
; 2989 :                     // 1. Set ReqPkt (CSR0.D5) = 1
; 2990 :                     DEBUGMSG(ZONE_TRANSFER, (TEXT("Request IN data for EP %d, index %d, MappedEP %d Dev %d, Toggle 0x%x\r\n"), USB_ENDPOINT(endpoint), csrIndex,
; 2991 :                              USB_ENDPOINT(pPipe->GetMappedEndPoint()), pPipe->GetReservedDeviceAddr(), 
; 2992 :                              INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR) & RXCSR_H_DataToggle));
; 2993 :                     CLRREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR, RXCSR_H_RxPktRdy);

  00548	e596301c	 ldr         r3, [r6, #0x1C]
  0054c	e3a02cff	 mov         r2, #0xFF, 24
  00550	e38220fe	 orr         r2, r2, #0xFE
  00554	e0830209	 add         r0, r3, r9, lsl #4
  00558	e5d01006	 ldrb        r1, [r0, #6]
  0055c	e5d03007	 ldrb        r3, [r0, #7]
  00560	e1813403	 orr         r3, r1, r3, lsl #8
  00564	e0033002	 and         r3, r3, r2
  00568	e1a02423	 mov         r2, r3, lsr #8
  0056c	e5c03006	 strb        r3, [r0, #6]
  00570	e5c02007	 strb        r2, [r0, #7]

; 2994 :                     SETREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].RxCSR, RXCSR_H_ReqPkt);

  00574	e596301c	 ldr         r3, [r6, #0x1C]
  00578	e0831209	 add         r1, r3, r9, lsl #4
  0057c	e5d12006	 ldrb        r2, [r1, #6]
  00580	e5d13007	 ldrb        r3, [r1, #7]
  00584	e1823403	 orr         r3, r2, r3, lsl #8
  00588	e3833020	 orr         r3, r3, #0x20
  0058c	e1a02423	 mov         r2, r3, lsr #8
  00590	e5c13006	 strb        r3, [r1, #6]

; 2995 :                     pQTD->SetStatus(STATUS_WAIT_RESPONSE);                                

  00594	e3a03003	 mov         r3, #3
  00598	e5c12007	 strb        r2, [r1, #7]
  0059c	e5873028	 str         r3, [r7, #0x28]

; 2996 :                 }                
; 2997 :                 LeaveCriticalSection(&pOTG->regCS);
; 2998 :             }
; 2999 :         }
; 3000 :         break;

  005a0	ea00002a	 b           |$LN88@ProcessTD|
  005a4		 |$LN42@ProcessTD|

; 2851 :     {
; 2852 :     case (TD_SETUP):
; 2853 :         if (endpoint != 0) 

  005a4	e3590000	 cmp         r9, #0
  005a8	0a000001	 beq         |$LN41@ProcessTD|
  005ac		 |$LN130@ProcessTD|

; 2854 :         {
; 2855 :             DEBUGMSG(ZONE_ERROR, (TEXT("Control Pipe for ep %d not support\r\n"), endpoint));
; 2856 :             bResult = FALSE;

  005ac	e3a05000	 mov         r5, #0

; 2857 :         }
; 2858 :         else

  005b0	ea000028	 b           |$LN40@ProcessTD|
  005b4		 |$LN41@ProcessTD|

; 2859 :         {
; 2860 :                         
; 2861 :             // 1. Load 8 bytes of data into FIFO
; 2862 :             // 1.a. Get the virtual address of buffer and corresponding start address (must be 0)
; 2863 :             UCHAR *pvData = (UCHAR *)pQTD->GetVAData();
; 2864 :             DWORD cbStart = pQTD->GetTotTfrSize();
; 2865 :             DWORD cbTemp = cbStart;
; 2866 :             DWORD cbToTransfer = pQTD->GetDataSize() - cbStart;
; 2867 : 
; 2868 :             // 1.b. Check the size, if not equal to 8 bytes, warning!!!
; 2869 :             if (cbToTransfer != 8)
; 2870 :                 DEBUGMSG(ZONE_ERROR, (TEXT("Warning!! Setup Data is not 8 bytes, it is %d bytes!!!\r\n"), pQTD->GetDataSize()));
; 2871 :             
; 2872 :             // Set Index Register
; 2873 :             EnterCriticalSection(&pOTG->regCS);    

  005b4	e5975014	 ldr         r5, [r7, #0x14]
  005b8	e597401c	 ldr         r4, [r7, #0x1C]
  005bc	e2860038	 add         r0, r6, #0x38
  005c0	eb000000	 bl          EnterCriticalSection

; 2874 :             OUTREG8(&pOTG->pUsbGenRegs->Index, INDEX(endpoint));

  005c4	e5963020	 ldr         r3, [r6, #0x20]
  005c8	e3a02000	 mov         r2, #0

; 2875 :             csrIndex = INDEX(endpoint);
; 2876 :             
; 2877 :             memdump((UCHAR *)(pvData+cbTemp), 8, 0);
; 2878 :             // 1.c Now put 8 bytes data into FIFO for ep 0            
; 2879 :             WriteFIFO((void *)pOTG, 0, (DWORD *)(pvData+cbTemp), 8);                      

  005cc	e3a09008	 mov         r9, #8
  005d0	e5c3200e	 strb        r2, [r3, #0xE]
  005d4	e5981000	 ldr         r1, [r8]
  005d8	e0843005	 add         r3, r4, r5
  005dc	e3a02000	 mov         r2, #0
  005e0	e5914058	 ldr         r4, [r1, #0x58]
  005e4	e1a01006	 mov         r1, r6
  005e8	e1a00008	 mov         r0, r8
  005ec	e58d9000	 str         r9, [sp]
  005f0	e1a0e00f	 mov         lr, pc
  005f4	e12fff14	 bx          r4

; 2880 : 
; 2881 :             // Set current tfr size
; 2882 :             pQTD->SetCurTfrSize(8);

  005f8	e5879020	 str         r9, [r7, #0x20]

; 2883 : 
; 2884 :             // 1.d Clear anything before access - as it has some invalid IN transaction from analyzer
; 2885 :             CLRREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0, CSR0_H_RxPktRdy|CSR0_H_ReqPkt|CSR0_H_StatusPkt);

  005fc	e596e01c	 ldr         lr, [r6, #0x1C]
  00600	e3a03cff	 mov         r3, #0xFF, 24
  00604	e383109e	 orr         r1, r3, #0x9E
  00608	e5de2002	 ldrb        r2, [lr, #2]
  0060c	e5de3003	 ldrb        r3, [lr, #3]

; 2886 : 
; 2887 : #ifdef DEBUG
; 2888 :             {
; 2889 :                 DWORD DataToggle = (INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0) & CSR0_H_DataToggle);
; 2890 :                 DEBUGMSG(ZONE_HCD, (TEXT("[DataToggle]:Request:Setup OUT Trasaction on EP 0 Device Addr %d DataToggle = 0x%x\r\n"), 
; 2891 :                         pPipe->GetReservedDeviceAddr(), DataToggle));
; 2892 :             }
; 2893 : #endif
; 2894 : 
; 2895 :             // 2. Set the SetupPkt & TxPtRdy bits
; 2896 :             DEBUGMSG(ZONE_HCD, (TEXT("Setup Packet requested with CSR0 = 0x%x\r\n"), 
; 2897 :                 INREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0)));
; 2898 :             SETREG16(&pOTG->pUsbCsrRegs->ep[csrIndex].CSR.CSR0, (CSR0_H_SetupPkt|CSR0_H_TxPktRdy));
; 2899 : 
; 2900 :             // 3. Wait for transfer interrupt signal
; 2901 :             pQTD->SetStatus(STATUS_WAIT_RESPONSE);            

  00610	e3a04003	 mov         r4, #3

; 2902 :             bResult = TRUE;
; 2903 :             LeaveCriticalSection(&pOTG->regCS);

  00614	e3a05001	 mov         r5, #1
  00618	e1823403	 orr         r3, r2, r3, lsl #8
  0061c	e0033001	 and         r3, r3, r1
  00620	e1a02423	 mov         r2, r3, lsr #8
  00624	e5ce3002	 strb        r3, [lr, #2]
  00628	e5ce2003	 strb        r2, [lr, #3]
  0062c	e596101c	 ldr         r1, [r6, #0x1C]
  00630	e5d12002	 ldrb        r2, [r1, #2]
  00634	e5d13003	 ldrb        r3, [r1, #3]
  00638	e1823403	 orr         r3, r2, r3, lsl #8
  0063c	e383300a	 orr         r3, r3, #0xA
  00640	e1a02423	 mov         r2, r3, lsr #8
  00644	e5c13002	 strb        r3, [r1, #2]
  00648	e5c12003	 strb        r2, [r1, #3]
  0064c	e5874028	 str         r4, [r7, #0x28]

; 2995 :                     pQTD->SetStatus(STATUS_WAIT_RESPONSE);                                

  00650		 |$LN88@ProcessTD|
  00650	e2860038	 add         r0, r6, #0x38
  00654	eb000000	 bl          LeaveCriticalSection
  00658		 |$LN40@ProcessTD|

; 3214 :     
; 3215 :     default:
; 3216 :         break;
; 3217 :     }
; 3218 :                 
; 3219 :     return bResult;
; 3220 : 
; 3221 : }

  00658	e1a00005	 mov         r0, r5
  0065c	e28dd024	 add         sp, sp, #0x24
  00660	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00664	e12fff1e	 bx          lr
  00668		 |$LN136@ProcessTD|
  00668		 |$LN137@ProcessTD|
  00668	00000000	 DCD         |??_C@_1EM@CHCHNIDI@?$AAN?$AAo?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?5?$AAa?$AAv?$AAa?$AAi?$AAl?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAR?$AAx?$AAC?$AAS?$AAR?$AA?5?$AA?$DN?$AA?5?$AA0@|
  0066c		 |$LN138@ProcessTD|
  0066c	00000000	 DCD         |??_C@_1HK@FIIANMKL@?$AAC?$AAH?$AAW?$AA?3?$AA?3?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAT?$AAD?$AA?3?$AA?5?$AAT?$AAI?$AAM?$AAE?$AAO?$AAU?$AAT?$AA?5?$AAS?$AAe?$AAn?$AAd?$AAi?$AAn?$AAg?$AA?5@|
  00670		 |$LN139@ProcessTD|
  00670	00000000	 DCD         |??_C@_1EI@MNPANNOD@?$AAS?$AAo?$AAm?$AAe?$AAt?$AAh?$AAi?$AAn?$AAg?$AA?5?$AAw?$AAr?$AAo?$AAn?$AAg?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?5?$AA?$CF?$AAd?$AA?$CB?$AA?$CB@|
  00674		 |$LN140@ProcessTD|
  00674	00000000	 DCD         |??_C@_1GG@IBBFPGMN@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?0?$AA?5?$AAg@|
  00678		 |$M46013|

			 ENDP  ; |?ProcessTD@CHW@@UAAHEPAX@Z|, CHW::ProcessTD

	EXPORT	|?Init@CBusyPipeList@@QAAHXZ|		; CBusyPipeList::Init
	IMPORT	|CeSetThreadPriority|
	IMPORT	|g_IstThreadPriority|
	IMPORT	|CreateThread|

  00000			 AREA	 |.pdata|, PDATA
|$T46036| DCD	|$LN19@Init|
	DCD	0x40003402
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Init@CBusyPipeList@@QAAHXZ| PROC	; CBusyPipeList::Init

; 104  : {

  00000		 |$LN19@Init|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M46033|
  00008	e1a04000	 mov         r4, r0

; 105  :     int i;
; 106  :     DEBUGMSG(ZONE_PIPE, (TEXT("CBusyPipeList::Init+\r\n")));
; 107  :     m_fCheckTransferThreadClosing=FALSE;     

  0000c	e3a05000	 mov         r5, #0

; 108  :     m_pBusyPipeList = NULL;
; 109  : #ifdef DEBUG
; 110  :     m_debug_numItemsOnBusyPipeList = 0;
; 111  : #endif
; 112  :     // In order to identify which endpoint , we need to find out which endpoint is receiving
; 113  :     // intr.
; 114  : 
; 115  :     // Create endpoint update event
; 116  :     m_hUpdateEPEvent = CreateEvent( NULL, FALSE, FALSE, NULL );    

  00010	e3a03000	 mov         r3, #0
  00014	e3a02000	 mov         r2, #0
  00018	e3a01000	 mov         r1, #0
  0001c	e3a00000	 mov         r0, #0
  00020	e58450b8	 str         r5, [r4, #0xB8]
  00024	e58450cc	 str         r5, [r4, #0xCC]
  00028	eb000000	 bl          CreateEventW
  0002c	e3500000	 cmp         r0, #0
  00030	e58400c4	 str         r0, [r4, #0xC4]

; 117  :     if ( m_hUpdateEPEvent == NULL ) {    
; 118  :         DEBUGMSG(ZONE_ERROR, (TEXT("-CPipe::Initialize. Error creating process done transfers event\n")));            
; 119  :         return FALSE;

  00034	e3a00000	 mov         r0, #0
  00038	0a00001f	 beq         |$LN9@Init|

; 120  :     }
; 121  :   
; 122  :     // set up our thread to check for done transfers
; 123  :     // currently, the context passed to CheckForDoneTransfersThread is ignored
; 124  :     m_hCheckForDoneTransfersThread = CreateThread( 0, 0, CheckForDoneTransfersThreadStub, (PVOID)this, 0, NULL );

  0003c	e59f2088	 ldr         r2, [pc, #0x88]
  00040	e1a03004	 mov         r3, r4
  00044	e3a01000	 mov         r1, #0
  00048	e58d5004	 str         r5, [sp, #4]
  0004c	e58d5000	 str         r5, [sp]
  00050	eb000000	 bl          CreateThread
  00054	e3500000	 cmp         r0, #0
  00058	e58400c8	 str         r0, [r4, #0xC8]

; 125  :     if ( m_hCheckForDoneTransfersThread == NULL ) {
; 126  :         DEBUGMSG(ZONE_ERROR, (TEXT("-CPipe::Initialize. Error creating process done transfers thread\n")));
; 127  :         return FALSE;

  0005c	03a00000	 moveq       r0, #0
  00060	0a000015	 beq         |$LN9@Init|

; 128  :     }
; 129  :     CeSetThreadPriority( m_hCheckForDoneTransfersThread, g_IstThreadPriority + RELATIVE_PRIO_CHECKDONE );

  00064	e59f305c	 ldr         r3, [pc, #0x5C]
  00068	e5933000	 ldr         r3, [r3]
  0006c	e2431001	 sub         r1, r3, #1
  00070	eb000000	 bl          CeSetThreadPriority

; 130  : 
; 131  :     m_hEP0CheckForDoneTransfersEvent = NULL;            

  00074	e58450bc	 str         r5, [r4, #0xBC]

; 132  :     m_PipeListInfoEP0CheckForDoneTransfersCount = NULL;

  00078	e58450c0	 str         r5, [r4, #0xC0]
  0007c	e1a03004	 mov         r3, r4
  00080	e3a02010	 mov         r2, #0x10
  00084		 |$LL6@Init|

; 133  :     
; 134  :     for (i = 0; i < HOST_MAX_EPNUM; i++)
; 135  :     {
; 136  :         m_hEP2Handles[i][DIR_IN] = NULL;

  00084	e5835014	 str         r5, [r3, #0x14]

; 137  :         m_hEP2Handles[i][DIR_OUT] = NULL;

  00088	e5835018	 str         r5, [r3, #0x18]
  0008c	e2833008	 add         r3, r3, #8
  00090	e2522001	 subs        r2, r2, #1
  00094	1afffffa	 bne         |$LL6@Init|

; 138  :     }
; 139  : 
; 140  :     for (i = 0; i < DMA_MAX_CHANNEL; i++)
; 141  :     {
; 142  :         m_hDMA2Handles[i] = NULL;

  00098	e2843094	 add         r3, r4, #0x94
  0009c	e2832020	 add         r2, r3, #0x20
  000a0	e3a01000	 mov         r1, #0
  000a4		 |$LN15@Init|
  000a4	e4831004	 str         r1, [r3], #4
  000a8	e1530002	 cmp         r3, r2
  000ac	1afffffc	 bne         |$LN15@Init|

; 143  :     }
; 144  : 
; 145  :     m_SignalDisconnectACK = TRUE;

  000b0	e3a03001	 mov         r3, #1
  000b4	e58430d0	 str         r3, [r4, #0xD0]

; 146  :     return TRUE;

  000b8	e3a00001	 mov         r0, #1
  000bc		 |$LN9@Init|

; 147  : 
; 148  : }

  000bc	e28dd008	 add         sp, sp, #8
  000c0	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000c4	e12fff1e	 bx          lr
  000c8		 |$LN20@Init|
  000c8		 |$LN21@Init|
  000c8	00000000	 DCD         |g_IstThreadPriority|
  000cc		 |$LN22@Init|
  000cc	00000000	 DCD         |?CheckForDoneTransfersThreadStub@CBusyPipeList@@CAKPAX@Z|
  000d0		 |$M46034|

			 ENDP  ; |?Init@CBusyPipeList@@QAAHXZ|, CBusyPipeList::Init

	EXPORT	|?RemoveFromBusyPipeList@CBusyPipeList@@QAAXQAVCPipe@@@Z| ; CBusyPipeList::RemoveFromBusyPipeList
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T46076| DCD	|$LN35@RemoveFrom|
	DCD	0x40005602
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?RemoveFromBusyPipeList@CBusyPipeList@@QAAXQAVCPipe@@@Z| PROC ; CBusyPipeList::RemoveFromBusyPipeList

; 599  : {

  00000		 |$LN35@RemoveFrom|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M46073|
  00008	e1a07001	 mov         r7, r1
  0000c	e1a05000	 mov         r5, r0

; 600  :     DEBUGMSG( ZONE_PIPE && ZONE_VERBOSE, (TEXT("+CPipe::RemoveFromBusyPipeList - pipe(%s) 0x%x\n"), pPipe->GetPipeType(), pPipe ) );    
; 601  :     Lock();

  00010	eb000000	 bl          EnterCriticalSection

; 602  : #ifdef DEBUG
; 603  :     BOOL debug_fRemovedPipe = FALSE;
; 604  :     {
; 605  :         // check m_debug_numItemsOnBusyPipeList
; 606  :         PPIPE_LIST_ELEMENT pBusy = m_pBusyPipeList;
; 607  :         int count = 0;
; 608  :         while ( pBusy != NULL ) {
; 609  :             DEBUGCHK( pBusy->pPipe != NULL );
; 610  :             pBusy = pBusy->pNext;
; 611  :             count++;
; 612  :         }
; 613  :         DEBUGCHK( m_debug_numItemsOnBusyPipeList == count );
; 614  :     }
; 615  : #endif // DEBUG
; 616  :     PPIPE_LIST_ELEMENT pPrev = NULL;
; 617  :     PPIPE_LIST_ELEMENT pCurrent = m_pBusyPipeList;

  00014	e59560cc	 ldr         r6, [r5, #0xCC]

; 618  :     USB_ENDPOINT_DESCRIPTOR endptDesc = pPipe->GetEndptDescriptor();

  00018	e28d0000	 add         r0, sp, #0
  0001c	e2871034	 add         r1, r7, #0x34
  00020	e3a02007	 mov         r2, #7
  00024	e1a04006	 mov         r4, r6
  00028	e3a08000	 mov         r8, #0
  0002c	eb000000	 bl          memcpy

; 619  :     UCHAR endpoint = USB_ENDPOINT(endptDesc.bEndpointAddress);

  00030	e5dd9002	 ldrb        r9, [sp, #2]

; 620  : 
; 621  :     while ( pCurrent != NULL ) {

  00034	e3560000	 cmp         r6, #0
  00038	0a00000e	 beq         |$LN15@RemoveFrom|
  0003c		 |$LL16@RemoveFrom|

; 622  :         if ( pCurrent->pPipe == pPipe ) {

  0003c	e5943000	 ldr         r3, [r4]
  00040	e1530007	 cmp         r3, r7
  00044	0a000004	 beq         |$LN29@RemoveFrom|

; 633  :             pCurrent = NULL;
; 634  :         #ifdef DEBUG
; 635  :             debug_fRemovedPipe = TRUE;
; 636  :             DEBUGCHK( --m_debug_numItemsOnBusyPipeList >= 0 );
; 637  :         #endif // DEBUG
; 638  :             break;
; 639  :         } else {
; 640  :             // Check next item
; 641  :             pPrev = pCurrent;
; 642  :             pCurrent = pPrev->pNext;

  00048	e5943004	 ldr         r3, [r4, #4]
  0004c	e1a08004	 mov         r8, r4
  00050	e1b04003	 movs        r4, r3
  00054	1afffff8	 bne         |$LL16@RemoveFrom|

; 655  :         {
; 656  :             if (pListTemp->deviceAddr == pPipe->GetReservedDeviceAddr())

  00058	ea000006	 b           |$LN15@RemoveFrom|
  0005c		 |$LN29@RemoveFrom|

; 623  :             // Remove item from the linked list
; 624  :             if ( pCurrent == m_pBusyPipeList ) {

  0005c	e1540006	 cmp         r4, r6

; 625  :                 DEBUGCHK( pPrev == NULL );
; 626  :                 m_pBusyPipeList = m_pBusyPipeList->pNext;

  00060	05963004	 ldreq       r3, [r6, #4]

; 627  :             } else {
; 628  :                 DEBUGCHK( pPrev != NULL &&
; 629  :                           pPrev->pNext == pCurrent );
; 630  :                 pPrev->pNext = pCurrent->pNext;
; 631  :             }
; 632  :             delete pCurrent;

  00064	e1a00004	 mov         r0, r4
  00068	058530cc	 streq       r3, [r5, #0xCC]
  0006c	15943004	 ldrne       r3, [r4, #4]
  00070	15883004	 strne       r3, [r8, #4]
  00074	eb000000	 bl          |??3@YAXPAX@Z|
  00078		 |$LN15@RemoveFrom|

; 643  :         }
; 644  :     }
; 645  : 
; 646  :     // Finally, close the handle and notify the removal 
; 647  :     if (endpoint == 0)

  00078	e319000f	 tst         r9, #0xF
  0007c	1a000021	 bne         |$LN10@RemoveFrom|

; 648  :     {
; 649  :         BOOL fFound = FALSE;
; 650  :         PPIPE_LIST_INFO pListTemp = m_PipeListInfoEP0CheckForDoneTransfersCount;

  00080	e59530c0	 ldr         r3, [r5, #0xC0]
  00084	e3a08000	 mov         r8, #0
  00088	e1b04003	 movs        r4, r3

; 651  :         PPIPE_LIST_INFO pListPrev;
; 652  : 
; 653  :         pListPrev = pListTemp;

  0008c	e1a06004	 mov         r6, r4

; 654  :         while (pListTemp != NULL)

  00090	0a000015	 beq         |$LN5@RemoveFrom|
  00094		 |$LL9@RemoveFrom|

; 655  :         {
; 656  :             if (pListTemp->deviceAddr == pPipe->GetReservedDeviceAddr())

  00094	e5973000	 ldr         r3, [r7]
  00098	e1a00007	 mov         r0, r7
  0009c	e5933028	 ldr         r3, [r3, #0x28]
  000a0	e1a0e00f	 mov         lr, pc
  000a4	e12fff13	 bx          r3
  000a8	e5d43000	 ldrb        r3, [r4]
  000ac	e1530000	 cmp         r3, r0
  000b0	0a000004	 beq         |$LN30@RemoveFrom|

; 669  :                 }
; 670  :                 break;
; 671  :             }
; 672  :             pListPrev = pListTemp;
; 673  :             pListTemp = pListTemp->pNext;   

  000b4	e5943004	 ldr         r3, [r4, #4]
  000b8	e1a06004	 mov         r6, r4
  000bc	e1b04003	 movs        r4, r3
  000c0	1afffff3	 bne         |$LL9@RemoveFrom|

; 655  :         {
; 656  :             if (pListTemp->deviceAddr == pPipe->GetReservedDeviceAddr())

  000c4	ea000008	 b           |$LN5@RemoveFrom|
  000c8		 |$LN30@RemoveFrom|

; 657  :             {
; 658  :                 fFound = TRUE;
; 659  :                 DEBUGMSG(ZONE_PIPE|ZONE_DEBUG, (TEXT("RemoveFromBusyPipeList found the device\r\n")));
; 660  :                 if (pListPrev == pListTemp) // head

  000c8	e1560004	 cmp         r6, r4

; 661  :                 {
; 662  :                     delete pListTemp;

  000cc	e1a00004	 mov         r0, r4
  000d0	1a000002	 bne         |$LN6@RemoveFrom|
  000d4	eb000000	 bl          |??3@YAXPAX@Z|

; 663  :                     m_PipeListInfoEP0CheckForDoneTransfersCount = NULL;

  000d8	e58580c0	 str         r8, [r5, #0xC0]

; 664  :                 }
; 665  :                 else

  000dc	ea000005	 b           |$LN32@RemoveFrom|
  000e0		 |$LN6@RemoveFrom|

; 666  :                 {
; 667  :                     pListPrev->pNext = pListTemp->pNext;

  000e0	e5943004	 ldr         r3, [r4, #4]

; 668  :                     delete pListTemp;

  000e4	e5863004	 str         r3, [r6, #4]
  000e8	eb000000	 bl          |??3@YAXPAX@Z|
  000ec		 |$LN5@RemoveFrom|

; 674  :         } // end while (pListTemp != NULL)
; 675  : 
; 676  :         if (fFound == FALSE)
; 677  :             DEBUGMSG(ZONE_PIPE, (TEXT("Warning! Not able to find EP %d,DevAddr %d\r\n"),
; 678  :                 endpoint, pPipe->GetReservedDeviceAddr()));
; 679  : 
; 680  : 
; 681  :         if (m_PipeListInfoEP0CheckForDoneTransfersCount == NULL)

  000ec	e59530c0	 ldr         r3, [r5, #0xC0]
  000f0	e3530000	 cmp         r3, #0
  000f4	1a00000f	 bne         |$LN1@RemoveFrom|
  000f8		 |$LN32@RemoveFrom|

; 682  :         {
; 683  :             DEBUGMSG(ZONE_PIPE|ZONE_DEBUG, (TEXT("RemoveBusyPipeList for EP %d  -clear\r\n"),
; 684  :                 endpoint));
; 685  :             if (USB_ENDPOINT(endpoint) == 0)
; 686  :                 DEBUGMSG(ZONE_PIPE, (TEXT("RemoveBusyPipeList clean EP 0\r\n")));
; 687  :             CloseHandle(m_hEP0CheckForDoneTransfersEvent);

  000f8	e59500bc	 ldr         r0, [r5, #0xBC]
  000fc	eb000000	 bl          CloseHandle

; 688  :             m_hEP0CheckForDoneTransfersEvent = NULL;

  00100	e58580bc	 str         r8, [r5, #0xBC]

; 689  :         }
; 690  : 
; 691  : #ifdef DEBUG
; 692  :         int count = 0;
; 693  :         PPIPE_LIST_INFO pList = m_PipeListInfoEP0CheckForDoneTransfersCount;
; 694  :         while (pList != NULL)
; 695  :         {
; 696  :             count++;
; 697  :             pList = pList->pNext;
; 698  :         }
; 699  : 
; 700  :         DEBUGMSG(ZONE_PIPE|ZONE_DEBUG, (TEXT("RemoveBusyPipeList leaving EP %d, count %d\r\n"),
; 701  :             endpoint, count));
; 702  : #endif
; 703  :     } // if (endpoint == 0)
; 704  :     else

  00104	ea00000b	 b           |$LN1@RemoveFrom|
  00108		 |$LN10@RemoveFrom|

; 705  :     {        
; 706  :         UCHAR channel = pPipe->m_pCMhcd->DeviceInfo2Channel(pPipe);                

  00108	e597000c	 ldr         r0, [r7, #0xC]
  0010c	e1a01007	 mov         r1, r7
  00110	eb000000	 bl          |?DeviceInfo2Channel@CHW@@QAAEPAVCPipe@@@Z|
  00114	e1a02000	 mov         r2, r0

; 707  :         pPipe->m_pCMhcd->ReleaseDMAChannel(pPipe, channel);

  00118	e597000c	 ldr         r0, [r7, #0xC]
  0011c	e1a01007	 mov         r1, r7
  00120	eb000000	 bl          |?ReleaseDMAChannel@CHW@@QAAHPAVCPipe@@E@Z|

; 708  :         pPipe->m_pCMhcd->ReleasePhysicalEndPoint(pPipe, TRUE, TRUE);

  00124	e597000c	 ldr         r0, [r7, #0xC]
  00128	e3a03001	 mov         r3, #1
  0012c	e3a02001	 mov         r2, #1
  00130	e1a01007	 mov         r1, r7
  00134	eb000000	 bl          |?ReleasePhysicalEndPoint@CHW@@QAAHPAVCPipe@@HH@Z|
  00138		 |$LN1@RemoveFrom|

; 709  :         DEBUGMSG(ZONE_PIPE, (TEXT("RemoveFromBusyPipeList: Release all\r\n")));
; 710  :     }
; 711  : 
; 712  :     SetEvent(m_hUpdateEPEvent);

  00138	e59500c4	 ldr         r0, [r5, #0xC4]
  0013c	e3a01003	 mov         r1, #3
  00140	eb000000	 bl          EventModify

; 713  :         
; 714  :     Unlock();    

  00144	e1a00005	 mov         r0, r5
  00148	eb000000	 bl          LeaveCriticalSection

; 715  :     DEBUGMSG( ZONE_PIPE && ZONE_VERBOSE && debug_fRemovedPipe, (TEXT("-CPipe::RemoveFromBusyPipeList, removed pipe(%s) 0x%x\n"), pPipe->GetPipeType(), pPipe));
; 716  :     DEBUGMSG( ZONE_PIPE && ZONE_VERBOSE && !debug_fRemovedPipe, (TEXT("-CPipe::RemoveFromBusyPipeList, pipe(%s) 0x%x was not on busy list\n"), pPipe->GetPipeType(), pPipe ));
; 717  : }

  0014c	e28dd008	 add         sp, sp, #8
  00150	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00154	e12fff1e	 bx          lr
  00158		 |$M46074|

			 ENDP  ; |?RemoveFromBusyPipeList@CBusyPipeList@@QAAXQAVCPipe@@@Z|, CBusyPipeList::RemoveFromBusyPipeList


  00000			 AREA	 |.pdata|, PDATA
|$T46087| DCD	|$LN6@scalar@2|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GCHW@@UAAPAXI@Z| PROC		; CHW::`scalar deleting destructor'
  00000		 |$LN6@scalar@2|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M46084|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          |??1CHW@@UAA@XZ|
  00010	e3140001	 tst         r4, #1
  00014	11a00005	 movne       r0, r5
  00018	1b000000	 blne        |??3@YAXPAX@Z|
  0001c	e1a00005	 mov         r0, r5
  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M46085|

			 ENDP  ; |??_GCHW@@UAAPAXI@Z|, CHW::`scalar deleting destructor'


  00000			 AREA	 |.pdata|, PDATA
|$T46097| DCD	|$LN6@Initialize|
	DCD	0x40001e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Initialize@CHW@@UAAHXZ| PROC		; CHW::Initialize

; 783  : {   

  00000		 |$LN6@Initialize|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M46094|
  00004	e1a05000	 mov         r5, r0

; 784  :     DEBUGMSG( ZONE_INIT, (TEXT("+CHW::Initialize\n")));
; 785  : 
; 786  :     // set up the frame list area.
; 787  :     if (m_cBusyPipeList.Init()==FALSE) {

  00008	e28500c0	 add         r0, r5, #0xC0
  0000c	eb000000	 bl          |?Init@CBusyPipeList@@QAAHXZ|
  00010	e3500000	 cmp         r0, #0

; 788  :         DEBUGMSG( ZONE_ERROR, (TEXT("-CHW::Initialize - zero Register Base or CeriodicMgr or CAsyncMgr fails\n")));
; 789  :         ASSERT(FALSE);
; 790  :         return FALSE;

  00014	e3a00000	 mov         r0, #0
  00018	0a000014	 beq         |$LN2@Initialize|

; 791  :     }
; 792  :     m_hUsbHubConnectEvent = CreateEvent( NULL, FALSE, FALSE, NULL );    

  0001c	e3a03000	 mov         r3, #0
  00020	e3a02000	 mov         r2, #0
  00024	e3a01000	 mov         r1, #0
  00028	eb000000	 bl          CreateEventW
  0002c	e1a03000	 mov         r3, r0

; 793  :     m_hUsbHubDisconnectEvent = CreateEvent( NULL, FALSE, FALSE, NULL );    

  00030	e58531a8	 str         r3, [r5, #0x1A8]
  00034	e3a03000	 mov         r3, #0
  00038	e3a00000	 mov         r0, #0
  0003c	e3a02000	 mov         r2, #0
  00040	e3a01000	 mov         r1, #0
  00044	eb000000	 bl          CreateEventW

; 794  :     InitializeCriticalSection(&m_LockEP0DeviceAddress.hLockCS);    

  00048	e2854d0a	 add         r4, r5, #0xA, 26
  0004c	e1a03000	 mov         r3, r0
  00050	e1a00004	 mov         r0, r4
  00054	e58531ac	 str         r3, [r5, #0x1AC]
  00058	eb000000	 bl          InitializeCriticalSection

; 795  :     m_LockEP0DeviceAddress.ucLockEP = 0xff;

  0005c	e3a030ff	 mov         r3, #0xFF

; 796  : 
; 797  :     DEBUGMSG(ZONE_INIT && ZONE_REGISTERS, (TEXT("CHW::Initialize - signalling global reset\n")));    
; 798  :     m_fifo_avail_addr = 0;    

  00060	e3a02000	 mov         r2, #0
  00064	e5c5327c	 strb        r3, [r5, #0x27C]
  00068	e14420b8	 strh        r2, [r4, #-8]

; 799  : 
; 800  :     return TRUE;

  0006c	e3a00001	 mov         r0, #1
  00070		 |$LN2@Initialize|

; 801  : }

  00070	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00074	e12fff1e	 bx          lr
  00078		 |$M46095|

			 ENDP  ; |?Initialize@CHW@@UAAHXZ|, CHW::Initialize

	END
