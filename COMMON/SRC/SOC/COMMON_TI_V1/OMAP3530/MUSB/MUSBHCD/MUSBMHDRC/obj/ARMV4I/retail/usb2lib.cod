; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\OMAP3530\MUSB\MUSBHCD\MUSBMHDRC\usb2lib.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|?m_lRef@USB2lib@@0JA| [ DATA ]		; USB2lib::m_lRef
	EXPORT	|?CMASKS@USB2lib@@0PAEA| [ DATA ]	; USB2lib::CMASKS

  00000			 AREA	 |.bss|, NOINIT
|?m_lRef@USB2lib@@0JA| % 0x4				; USB2lib::m_lRef

  00000			 AREA	 |.data|, DATA
|?CMASKS@USB2lib@@0PAEA| DCB 0x1c			; USB2lib::CMASKS
	DCB	0x38
	DCB	0x70
	DCB	0xe0
	DCB	0xc1
	DCB	0x83
	DCB	0x7
	DCB	0xe
	EXPORT	|??0LockObject@@QAA@XZ|			; LockObject::LockObject
	IMPORT	|InitializeCriticalSection|
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T32732| DCD	|$LN5@LockObject|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0LockObject@@QAA@XZ| PROC		; LockObject::LockObject

; 71   :     LockObject() { InitializeCriticalSection(&m_CSection); };

  00000		 |$LN5@LockObject|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M32729|
  00004	e1a04000	 mov         r4, r0
  00008	eb000000	 bl          InitializeCriticalSection
  0000c	e1a00004	 mov         r0, r4
  00010	e8bd4010	 ldmia       sp!, {r4, lr}
  00014	e12fff1e	 bx          lr
  00018		 |$M32730|

			 ENDP  ; |??0LockObject@@QAA@XZ|, LockObject::LockObject

	EXPORT	|??1LockObject@@QAA@XZ|			; LockObject::~LockObject
	IMPORT	|DeleteCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T32740| DCD	|$LN5@LockObject@2|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1LockObject@@QAA@XZ| PROC		; LockObject::~LockObject

; 72   :     ~LockObject() { DeleteCriticalSection( &m_CSection); };

  00000		 |$LN5@LockObject@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M32737|
  00004	eb000000	 bl          DeleteCriticalSection
  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M32738|

			 ENDP  ; |??1LockObject@@QAA@XZ|, LockObject::~LockObject

	EXPORT	|?Lock@LockObject@@QAAXXZ|		; LockObject::Lock
	IMPORT	|EnterCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T32748| DCD	|$LN5@Lock|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Lock@LockObject@@QAAXXZ| PROC	; LockObject::Lock

; 73   :     void Lock(void) { EnterCriticalSection(&m_CSection); };

  00000		 |$LN5@Lock|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M32745|
  00004	eb000000	 bl          EnterCriticalSection
  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M32746|

			 ENDP  ; |?Lock@LockObject@@QAAXXZ|, LockObject::Lock

	EXPORT	|?Unlock@LockObject@@QAAXXZ|		; LockObject::Unlock
	IMPORT	|LeaveCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T32756| DCD	|$LN5@Unlock|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Unlock@LockObject@@QAAXXZ| PROC	; LockObject::Unlock

; 74   :     void Unlock(void) {LeaveCriticalSection( &m_CSection); };

  00000		 |$LN5@Unlock|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M32753|
  00004	eb000000	 bl          LeaveCriticalSection
  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M32754|

			 ENDP  ; |?Unlock@LockObject@@QAAXXZ|, LockObject::Unlock

	EXPORT	|?GetHubAddress@TransactionTrasnlate@@QAAEXZ| ; TransactionTrasnlate::GetHubAddress
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\usb2lib.h

  00000			 AREA	 |.pdata|, PDATA
|$T32766| DCD	|$LN5@GetHubAddr|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetHubAddress@TransactionTrasnlate@@QAAEXZ| PROC ; TransactionTrasnlate::GetHubAddress

; 152  :     UCHAR GetHubAddress() { return m_uHubAddress; };

  00000		 |$LN5@GetHubAddr|
  00000		 |$M32763|
  00000	e5d00000	 ldrb        r0, [r0]
  00004	e12fff1e	 bx          lr
  00008		 |$M32764|

			 ENDP  ; |?GetHubAddress@TransactionTrasnlate@@QAAEXZ|, TransactionTrasnlate::GetHubAddress

	EXPORT	|?GetHubPort@TransactionTrasnlate@@QAAEXZ| ; TransactionTrasnlate::GetHubPort

  00000			 AREA	 |.pdata|, PDATA
|$T32776| DCD	|$LN5@GetHubPort|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetHubPort@TransactionTrasnlate@@QAAEXZ| PROC ; TransactionTrasnlate::GetHubPort

; 153  :     UCHAR GetHubPort() { return m_uPort; };

  00000		 |$LN5@GetHubPort|
  00000		 |$M32773|
  00000	e5d00001	 ldrb        r0, [r0, #1]
  00004	e12fff1e	 bx          lr
  00008		 |$M32774|

			 ENDP  ; |?GetHubPort@TransactionTrasnlate@@QAAEXZ|, TransactionTrasnlate::GetHubPort

	EXPORT	|?SetNextTT@TransactionTrasnlate@@QAAPAV1@PAV1@@Z| ; TransactionTrasnlate::SetNextTT

  00000			 AREA	 |.pdata|, PDATA
|$T32788| DCD	|$LN5@SetNextTT|
	DCD	0x40000400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetNextTT@TransactionTrasnlate@@QAAPAV1@PAV1@@Z| PROC ; TransactionTrasnlate::SetNextTT

; 157  :     TransactionTrasnlate * SetNextTT(TransactionTrasnlate * pNextTT) { 

  00000		 |$LN5@SetNextTT|
  00000		 |$M32785|
  00000	e1a03000	 mov         r3, r0

; 158  :         TransactionTrasnlate * pReturn = m_pNextTT;

  00004	e593000c	 ldr         r0, [r3, #0xC]

; 159  :         m_pNextTT = pNextTT;

  00008	e583100c	 str         r1, [r3, #0xC]

; 160  :         return  pReturn;
; 161  :     }

  0000c	e12fff1e	 bx          lr
  00010		 |$M32786|

			 ENDP  ; |?SetNextTT@TransactionTrasnlate@@QAAPAV1@PAV1@@Z|, TransactionTrasnlate::SetNextTT

	EXPORT	|?GetNextTT@TransactionTrasnlate@@QAAPAV1@XZ| ; TransactionTrasnlate::GetNextTT

  00000			 AREA	 |.pdata|, PDATA
|$T32798| DCD	|$LN5@GetNextTT|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetNextTT@TransactionTrasnlate@@QAAPAV1@XZ| PROC ; TransactionTrasnlate::GetNextTT

; 162  :     TransactionTrasnlate * GetNextTT() { return  m_pNextTT; };

  00000		 |$LN5@GetNextTT|
  00000		 |$M32795|
  00000	e590000c	 ldr         r0, [r0, #0xC]
  00004	e12fff1e	 bx          lr
  00008		 |$M32796|

			 ENDP  ; |?GetNextTT@TransactionTrasnlate@@QAAPAV1@XZ|, TransactionTrasnlate::GetNextTT

	EXPORT	|??0TransactionTrasnlate@@QAA@EEQAXPAV0@@Z| ; TransactionTrasnlate::TransactionTrasnlate
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\usb2lib.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T32813| DCD	|$LN10@Transactio|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0TransactionTrasnlate@@QAA@EEQAXPAV0@@Z| PROC ; TransactionTrasnlate::TransactionTrasnlate

; 43   : {

  00000		 |$LN10@Transactio|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M32810|

; 44   :     m_pNextTT =  pNextTT;

  00004	e59de008	 ldr         lr, [sp, #8]

; 45   :     m_dwThink_time =1;

  00008	e3a04001	 mov         r4, #1
  0000c	e5c01000	 strb        r1, [r0]
  00010	e280c004	 add         r12, r0, #4
  00014	e88c4018	 stmia       r12, {r3, r4, lr}
  00018	e5c02001	 strb        r2, [r0, #1]
  0001c	e1a03000	 mov         r3, r0
  00020	e3a01000	 mov         r1, #0
  00024	e3a02020	 mov         r2, #0x20
  00028		 |$LL3@Transactio|

; 46   :     for (DWORD dwIndex=0; dwIndex<MAXFRAMES; dwIndex++) {
; 47   :         TT_frame[dwIndex]=NULL;

  00028	e5831010	 str         r1, [r3, #0x10]

; 48   :         frame_budget[dwIndex].time_used=0;;

  0002c	e5831090	 str         r1, [r3, #0x90]
  00030	e2833004	 add         r3, r3, #4
  00034	e2522001	 subs        r2, r2, #1
  00038	1afffffa	 bne         |$LL3@Transactio|

; 49   :     }
; 50   : }

  0003c	e8bd4010	 ldmia       sp!, {r4, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M32811|

			 ENDP  ; |??0TransactionTrasnlate@@QAA@EEQAXPAV0@@Z|, TransactionTrasnlate::TransactionTrasnlate

	EXPORT	|??1TransactionTrasnlate@@QAA@XZ|	; TransactionTrasnlate::~TransactionTrasnlate
	IMPORT	|??3@YAXPAX@Z|				; operator delete

  00000			 AREA	 |.pdata|, PDATA
|$T32825| DCD	|$LN11@Transactio@2|
	DCD	0x40000e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1TransactionTrasnlate@@QAA@XZ| PROC	; TransactionTrasnlate::~TransactionTrasnlate

; 52   : {

  00000		 |$LN11@Transactio@2|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M32822|
  00004	e1a04000	 mov         r4, r0

; 53   :     for (DWORD dwIndex=0; dwIndex<MAXFRAMES; dwIndex++) {

  00008	e3a05020	 mov         r5, #0x20
  0000c	e3a06000	 mov         r6, #0
  00010		 |$LL4@Transactio@2|

; 54   :         LPEndpointBugetList pCurList = TT_frame[dwIndex];

  00010	e5943010	 ldr         r3, [r4, #0x10]
  00014	e3530000	 cmp         r3, #0

; 55   :         if (pCurList!=NULL) {
; 56   :             LPEndpointBugetList pNextList = pCurList ->pNextEndpt;
; 57   :             delete pCurList;

  00018	11a00003	 movne       r0, r3
  0001c	1b000000	 blne        |??3@YAXPAX@Z|

; 58   :             pCurList = pNextList;
; 59   :         }
; 60   :         TT_frame[dwIndex]=NULL;

  00020	e5846010	 str         r6, [r4, #0x10]
  00024	e2844004	 add         r4, r4, #4
  00028	e2555001	 subs        r5, r5, #1
  0002c	1afffff7	 bne         |$LL4@Transactio@2|

; 61   :     }
; 62   : };

  00030	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00034	e12fff1e	 bx          lr
  00038		 |$M32823|

			 ENDP  ; |??1TransactionTrasnlate@@QAA@XZ|, TransactionTrasnlate::~TransactionTrasnlate

	EXPORT	|?FindBestTimeSlot@TransactionTrasnlate@@AAAHGGPAU_ENDPOINTBUGETLIST@@PAK@Z| ; TransactionTrasnlate::FindBestTimeSlot

  00000			 AREA	 |.pdata|, PDATA
|$T32840| DCD	|$LN14@FindBestTi|
	DCD	0x40001501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FindBestTimeSlot@TransactionTrasnlate@@AAAHGGPAU_ENDPOINTBUGETLIST@@PAK@Z| PROC ; TransactionTrasnlate::FindBestTimeSlot

; 171  : {

  00000		 |$LN14@FindBestTi|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M32837|
  00004	e1b0e003	 movs        lr, r3

; 172  :     while (lpList) {

  00008	0a00000c	 beq         |$LN11@FindBestTi|
  0000c		 |$LL6@FindBestTi|

; 173  :         // Check this is no overlap.
; 174  :         if (lpList->endpt.start_time  >= start_time +  time_duration) { // Empty Slot has been found.

  0000c	e1de31b2	 ldrh        r3, [lr, #0x12]
  00010	e0820001	 add         r0, r2, r1
  00014	e1530000	 cmp         r3, r0
  00018	aa000008	 bge         |$LN11@FindBestTi|

; 175  :             break;
; 176  :         }
; 177  :         else if (lpList->endpt.start_time +  lpList->endpt.calc_bus_time <= start_time) { // Have not reach yet . Continue

  0001c	e1de41b0	 ldrh        r4, [lr, #0x10]

; 178  :             lpList = lpList ->pNextEndpt;

  00020	e59ee000	 ldr         lr, [lr]
  00024	e0840003	 add         r0, r4, r3
  00028	e1500001	 cmp         r0, r1

; 179  :         }
; 180  :         else { // We have overlap. Let us move slot later.
; 181  :             start_time = lpList->endpt.start_time +  lpList->endpt.calc_bus_time;

  0002c	c0843003	 addgt       r3, r4, r3
  00030	c1a01803	 movgt       r1, r3, lsl #16
  00034	c1a01821	 movgt       r1, r1, lsr #16
  00038	e35e0000	 cmp         lr, #0
  0003c	1afffff2	 bne         |$LL6@FindBestTi|
  00040		 |$LN11@FindBestTi|

; 182  :             lpList =  lpList ->pNextEndpt;
; 183  :         }
; 184  :     }
; 185  :     *pdwReturn = start_time;

  00040	e59d3008	 ldr         r3, [sp, #8]

; 186  :     return TRUE;

  00044	e3a00001	 mov         r0, #1
  00048	e5831000	 str         r1, [r3]

; 187  : }

  0004c	e8bd4010	 ldmia       sp!, {r4, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$M32838|

			 ENDP  ; |?FindBestTimeSlot@TransactionTrasnlate@@AAAHGGPAU_ENDPOINTBUGETLIST@@PAK@Z|, TransactionTrasnlate::FindBestTimeSlot

	EXPORT	|?InsertEp@TransactionTrasnlate@@AAAHKPAU_EndpointBuget@@@Z| ; TransactionTrasnlate::InsertEp
	IMPORT	|??2@YAPAXI@Z|				; operator new
	IMPORT	|memcpy|

  00000			 AREA	 |.pdata|, PDATA
|$T32861| DCD	|$LN20@InsertEp|
	DCD	0x40003901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InsertEp@TransactionTrasnlate@@AAAHKPAU_EndpointBuget@@@Z| PROC ; TransactionTrasnlate::InsertEp

; 189  : {

  00000		 |$LN20@InsertEp|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M32858|
  00004	e1a06002	 mov         r6, r2
  00008	e1a07001	 mov         r7, r1
  0000c	e1a08000	 mov         r8, r0

; 190  :     if (frameIndex>=MAXFRAMES || ep == NULL) {

  00010	e3570020	 cmp         r7, #0x20
  00014	2a00002e	 bcs         |$LN12@InsertEp|
  00018	e3560000	 cmp         r6, #0
  0001c	0a00002c	 beq         |$LN12@InsertEp|

; 193  :     }
; 194  :     BOOL bReturn = FALSE;
; 195  :     EndpointBugetList * pNewEpList = new EndpointBugetList;

  00020	e3a0001c	 mov         r0, #0x1C
  00024	e3a05000	 mov         r5, #0
  00028	eb000000	 bl          |??2@YAPAXI@Z|
  0002c	e1b04000	 movs        r4, r0

; 196  :     if (pNewEpList) {

  00030	0a000028	 beq         |$LN14@InsertEp|

; 197  :         pNewEpList->endpt = *ep;

  00034	e2840004	 add         r0, r4, #4
  00038	e3a02018	 mov         r2, #0x18
  0003c	e1a01006	 mov         r1, r6
  00040	eb000000	 bl          memcpy

; 198  :         // find out where is not
; 199  :         EndpointBugetList * pPrevNode=NULL;
; 200  :         EndpointBugetList * pCurNode = TT_frame[frameIndex];

  00044	e0887107	 add         r7, r8, r7, lsl #2
  00048	e5978010	 ldr         r8, [r7, #0x10]
  0004c	e3a01000	 mov         r1, #0

; 201  :         bReturn = TRUE;

  00050	e3a05001	 mov         r5, #1
  00054	e1b00008	 movs        r0, r8

; 202  :         while (pCurNode) {

  00058	0a00001a	 beq         |$LN3@InsertEp|
  0005c	e1d6e0be	 ldrh        lr, [r6, #0xE]
  00060		 |$LL10@InsertEp|

; 203  :             if (pCurNode->endpt.start_time +  pCurNode->endpt.calc_bus_time <= ep->start_time) { // Continue

  00060	e1d021b2	 ldrh        r2, [r0, #0x12]
  00064	e1d031b0	 ldrh        r3, [r0, #0x10]
  00068	e0823003	 add         r3, r2, r3
  0006c	e153000e	 cmp         r3, lr
  00070	ca000004	 bgt         |$LN8@InsertEp|

; 204  :                 pPrevNode = pCurNode;
; 205  :                 pCurNode =pCurNode->pNextEndpt;

  00074	e5903000	 ldr         r3, [r0]
  00078	e1a01000	 mov         r1, r0
  0007c	e1b00003	 movs        r0, r3
  00080	1afffff6	 bne         |$LL10@InsertEp|

; 190  :     if (frameIndex>=MAXFRAMES || ep == NULL) {

  00084	ea000005	 b           |$LN17@InsertEp|
  00088		 |$LN8@InsertEp|

; 206  :             }
; 207  :             else if (pCurNode->endpt.start_time >= ep->start_time+ep->calc_bus_time) { // Find hole

  00088	e1d630bc	 ldrh        r3, [r6, #0xC]
  0008c	e1d021b2	 ldrh        r2, [r0, #0x12]
  00090	e083300e	 add         r3, r3, lr
  00094	e1520003	 cmp         r2, r3
  00098	ba000006	 blt         |$LN6@InsertEp|

; 208  :                 bReturn=TRUE;

  0009c	e3a05001	 mov         r5, #1
  000a0		 |$LN17@InsertEp|

; 209  :                 break;
; 210  :             }
; 211  :             else {// This is really bad. Someone try to inserted something that has overlap.
; 212  :                 ASSERT(FALSE);
; 213  :                 bReturn = FALSE;
; 214  :                 break;
; 215  :             }
; 216  :         }
; 217  :         if (bReturn) { // We reached last one.
; 218  :             if (pPrevNode) { // Not first.

  000a0	e3510000	 cmp         r1, #0
  000a4	0a000007	 beq         |$LN3@InsertEp|

; 219  :                 pNewEpList->pNextEndpt = pPrevNode ->pNextEndpt;

  000a8	e5913000	 ldr         r3, [r1]
  000ac	e5843000	 str         r3, [r4]

; 220  :                 pPrevNode->pNextEndpt = pNewEpList;

  000b0	e5814000	 str         r4, [r1]

; 221  :             } else { // This is first.

  000b4	ea000007	 b           |$LN14@InsertEp|
  000b8		 |$LN6@InsertEp|

; 224  :             }
; 225  :         }
; 226  :         else // Fails we have to clean it.
; 227  :             delete pNewEpList;

  000b8	e1a00004	 mov         r0, r4
  000bc	e3a05000	 mov         r5, #0
  000c0	eb000000	 bl          |??3@YAXPAX@Z|
  000c4	ea000003	 b           |$LN14@InsertEp|
  000c8		 |$LN3@InsertEp|

; 222  :                 pNewEpList->pNextEndpt = TT_frame[frameIndex];

  000c8	e5848000	 str         r8, [r4]

; 223  :                 TT_frame[frameIndex] = pNewEpList;

  000cc	e5874010	 str         r4, [r7, #0x10]

; 228  :     }
; 229  :     return bReturn;

  000d0	ea000000	 b           |$LN14@InsertEp|
  000d4		 |$LN12@InsertEp|

; 191  :         ASSERT(FALSE);
; 192  :         return FALSE;

  000d4	e3a05000	 mov         r5, #0
  000d8		 |$LN14@InsertEp|

; 230  : };

  000d8	e1a00005	 mov         r0, r5
  000dc	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000e0	e12fff1e	 bx          lr
  000e4		 |$M32859|

			 ENDP  ; |?InsertEp@TransactionTrasnlate@@AAAHKPAU_EndpointBuget@@@Z|, TransactionTrasnlate::InsertEp

	EXPORT	|?RemoveEp@TransactionTrasnlate@@AAAHKPAU_EndpointBuget@@@Z| ; TransactionTrasnlate::RemoveEp

  00000			 AREA	 |.pdata|, PDATA
|$T32879| DCD	|$LN19@RemoveEp|
	DCD	0x40002c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?RemoveEp@TransactionTrasnlate@@AAAHKPAU_EndpointBuget@@@Z| PROC ; TransactionTrasnlate::RemoveEp

; 232  : {

  00000		 |$LN19@RemoveEp|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M32876|
  00004	e1a0e002	 mov         lr, r2

; 233  :     if (frameIndex>=MAXFRAMES || ep == NULL) {

  00008	e3510020	 cmp         r1, #0x20
  0000c	2a000023	 bcs         |$LN11@RemoveEp|
  00010	e35e0000	 cmp         lr, #0
  00014	0a000021	 beq         |$LN11@RemoveEp|

; 236  :     }
; 237  :     BOOL bReturn=FALSE;
; 238  :     EndpointBugetList * pPrevNode=NULL;
; 239  :     EndpointBugetList * pCurNode = TT_frame[frameIndex];

  00018	e0806101	 add         r6, r0, r1, lsl #2
  0001c	e5963010	 ldr         r3, [r6, #0x10]
  00020	e3a04000	 mov         r4, #0
  00024	e3a05000	 mov         r5, #0
  00028	e1b00003	 movs        r0, r3

; 240  :     while (pCurNode) {

  0002c	0a00001c	 beq         |$LN13@RemoveEp|
  00030	e1de20be	 ldrh        r2, [lr, #0xE]
  00034		 |$LL10@RemoveEp|

; 241  :         if (pCurNode->endpt.start_time +  pCurNode->endpt.calc_bus_time <= ep->start_time) { // Continue

  00034	e1d011b2	 ldrh        r1, [r0, #0x12]
  00038	e1d031b0	 ldrh        r3, [r0, #0x10]
  0003c	e0813003	 add         r3, r1, r3
  00040	e1530002	 cmp         r3, r2
  00044	ca000004	 bgt         |$LN8@RemoveEp|

; 242  :             pPrevNode = pCurNode;
; 243  :             pCurNode =pCurNode->pNextEndpt;

  00048	e5903000	 ldr         r3, [r0]
  0004c	e1a05000	 mov         r5, r0
  00050	e1b00003	 movs        r0, r3
  00054	1afffff6	 bne         |$LL10@RemoveEp|

; 233  :     if (frameIndex>=MAXFRAMES || ep == NULL) {

  00058	ea000011	 b           |$LN13@RemoveEp|
  0005c		 |$LN8@RemoveEp|

; 244  :         }
; 245  :         else if ( pCurNode->endpt.start_time == ep->start_time && pCurNode->endpt.calc_bus_time == ep->calc_bus_time) {

  0005c	e1d031b2	 ldrh        r3, [r0, #0x12]
  00060	e1530002	 cmp         r3, r2
  00064	1a00000d	 bne         |$LN11@RemoveEp|
  00068	e1d021b0	 ldrh        r2, [r0, #0x10]
  0006c	e1de30bc	 ldrh        r3, [lr, #0xC]
  00070	e1520003	 cmp         r2, r3
  00074	1a000009	 bne         |$LN11@RemoveEp|

; 246  :             bReturn=TRUE;
; 247  :             break;
; 248  :         }
; 249  :         else { // Either overlap or behind, We can not find this one.
; 250  :             bReturn=FALSE;
; 251  :             break;            
; 252  :         }
; 253  :     };
; 254  :     if (bReturn == TRUE && pCurNode!=NULL) {
; 255  :         if (pPrevNode) // Not first one.
; 256  :             pPrevNode->pNextEndpt=pCurNode->pNextEndpt;

  00078	e5903000	 ldr         r3, [r0]
  0007c	e3a04001	 mov         r4, #1
  00080	e3550000	 cmp         r5, #0
  00084	0a000002	 beq         |$LN3@RemoveEp|
  00088	e5853000	 str         r3, [r5]

; 259  :         delete pCurNode;

  0008c	eb000000	 bl          |??3@YAXPAX@Z|
  00090	ea000003	 b           |$LN13@RemoveEp|
  00094		 |$LN3@RemoveEp|

; 257  :         else
; 258  :             TT_frame[frameIndex]= pCurNode->pNextEndpt;

  00094	e5863010	 str         r3, [r6, #0x10]

; 259  :         delete pCurNode;

  00098	eb000000	 bl          |??3@YAXPAX@Z|
  0009c	ea000000	 b           |$LN13@RemoveEp|
  000a0		 |$LN11@RemoveEp|

; 234  :         ASSERT(FALSE);
; 235  :         return FALSE;

  000a0	e3a04000	 mov         r4, #0
  000a4		 |$LN13@RemoveEp|

; 260  :     }
; 261  :     else
; 262  :         ASSERT(FALSE);
; 263  :     return bReturn;
; 264  : 
; 265  : }

  000a4	e1a00004	 mov         r0, r4
  000a8	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000ac	e12fff1e	 bx          lr
  000b0		 |$M32877|

			 ENDP  ; |?RemoveEp@TransactionTrasnlate@@AAAHKPAU_EndpointBuget@@@Z|, TransactionTrasnlate::RemoveEp

	EXPORT	|??0USB2lib@@QAA@XZ|			; USB2lib::USB2lib
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T32904| DCD	|$LN23@USB2lib|
	DCD	0x40001801
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\usb2lib.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0USB2lib@@QAA@XZ| PROC		; USB2lib::USB2lib

; 268  : {

  00000		 |$LN23@USB2lib|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M32901|
  00004	e1a04000	 mov         r4, r0
  00008	eb000000	 bl          InitializeCriticalSection

; 269  :     // allocate at TT to test with
; 270  :     //myHC.tthead = (PTT) malloc(sizeof(TT));
; 271  :     Lock();

  0000c	e1a00004	 mov         r0, r4
  00010	eb000000	 bl          EnterCriticalSection
  00014	e3a03c1b	 mov         r3, #0x1B, 24

; 272  :     pTTRoot = NULL;
; 273  :     thinktime = HS_HC_THINK_TIME;
; 274  :     allocation_limit = HS_MAX_PERIODIC_ALLOCATION;

  00018	e3833058	 orr         r3, r3, #0x58
  0001c	e3a01000	 mov         r1, #0
  00020	e3a00064	 mov         r0, #0x64

; 275  :     speed = HSSPEED;

  00024	e3a0e002	 mov         lr, #2
  00028	e2842024	 add         r2, r4, #0x24
  0002c	e284c018	 add         r12, r4, #0x18
  00030	e88c4009	 stmia       r12, {r0, r3, lr}
  00034	e5841014	 str         r1, [r4, #0x14]

; 276  : 
; 277  :     for (int i=0; i<MAXFRAMES; i++) {
; 278  :         for (int j=0; j < MICROFRAMES_PER_FRAME; j++) {
; 279  :             HS_microframe_info[i][j].time_used = 0;

  00038	e2823b01	 add         r3, r2, #1, 22
  0003c	e3a01000	 mov         r1, #0
  00040		 |$LN19@USB2lib|
  00040	e4821004	 str         r1, [r2], #4
  00044	e1520003	 cmp         r2, r3
  00048	1afffffc	 bne         |$LN19@USB2lib|

; 280  :         }
; 281  :     }
; 282  :     Unlock();

  0004c	e1a00004	 mov         r0, r4
  00050	eb000000	 bl          LeaveCriticalSection

; 283  : }

  00054	e1a00004	 mov         r0, r4
  00058	e8bd4010	 ldmia       sp!, {r4, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$M32902|

			 ENDP  ; |??0USB2lib@@QAA@XZ|, USB2lib::USB2lib

	EXPORT	|??_GTransactionTrasnlate@@QAAPAXI@Z|	; TransactionTrasnlate::`scalar deleting destructor'

  00000			 AREA	 |.pdata|, PDATA
|$T32915| DCD	|$LN6@scalar|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GTransactionTrasnlate@@QAAPAXI@Z| PROC ; TransactionTrasnlate::`scalar deleting destructor'
  00000		 |$LN6@scalar|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M32912|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          |??1TransactionTrasnlate@@QAA@XZ|
  00010	e3140001	 tst         r4, #1
  00014	11a00005	 movne       r0, r5
  00018	1b000000	 blne        |??3@YAXPAX@Z|
  0001c	e1a00005	 mov         r0, r5
  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M32913|

			 ENDP  ; |??_GTransactionTrasnlate@@QAAPAXI@Z|, TransactionTrasnlate::`scalar deleting destructor'

	EXPORT	|?DeleteTt@USB2lib@@QAAHEEH@Z|		; USB2lib::DeleteTt
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T32980| DCD	|$LN41@DeleteTt|
	DCD	0x40002401
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\usb2lib.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DeleteTt@USB2lib@@QAAHEEH@Z| PROC	; USB2lib::DeleteTt

; 314  : {

  00000		 |$LN41@DeleteTt|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M32977|
  00004	e1a07002	 mov         r7, r2
  00008	e1a08001	 mov         r8, r1
  0000c	e1a06000	 mov         r6, r0

; 315  : 	UNREFERENCED_PARAMETER(ttContext);
; 316  : 	
; 317  : 	BOOL bReturn = FALSE;
; 318  :     Lock();

  00010	e3a05000	 mov         r5, #0
  00014	eb000000	 bl          EnterCriticalSection

; 319  :     TransactionTrasnlate * pPrevTT= NULL;
; 320  :     TransactionTrasnlate * pCurTT = pTTRoot;

  00018	e5963014	 ldr         r3, [r6, #0x14]
  0001c	e3a0e000	 mov         lr, #0
  00020	e1b04003	 movs        r4, r3

; 321  : 
; 322  :     while ( pCurTT!=NULL ) {

  00024	0a000014	 beq         |$LN3@DeleteTt|
  00028		 |$LL7@DeleteTt|

; 323  :         if (pCurTT->GetHubAddress()==uHubAddress && pCurTT->GetHubPort() == uPort)

  00028	e5d43000	 ldrb        r3, [r4]
  0002c	e1530008	 cmp         r3, r8
  00030	1a000002	 bne         |$LN5@DeleteTt|
  00034	e5d43001	 ldrb        r3, [r4, #1]
  00038	e1530007	 cmp         r3, r7
  0003c	0a000003	 beq         |$LN37@DeleteTt|
  00040		 |$LN5@DeleteTt|

; 324  :             break;
; 325  :         else {
; 326  :             pPrevTT = pCurTT;
; 327  :             pCurTT = pCurTT->GetNextTT();

  00040	e594300c	 ldr         r3, [r4, #0xC]
  00044	e1a0e004	 mov         lr, r4
  00048	e1b04003	 movs        r4, r3
  0004c	1afffff5	 bne         |$LL7@DeleteTt|
  00050		 |$LN37@DeleteTt|

; 328  :         }
; 329  :     }
; 330  :     if (pCurTT) { // We found one matched.

  00050	e3540000	 cmp         r4, #0
  00054	0a000008	 beq         |$LN3@DeleteTt|

; 331  :         if (pPrevTT) { // Not First One.
; 332  :             pPrevTT ->SetNextTT(pCurTT->GetNextTT());

  00058	e594300c	 ldr         r3, [r4, #0xC]
  0005c	e35e0000	 cmp         lr, #0

; 333  :             delete pCurTT;

  00060	e1a00004	 mov         r0, r4
  00064	158e300c	 strne       r3, [lr, #0xC]

; 334  :         }
; 335  :         else { // First one
; 336  :             pTTRoot = pCurTT->GetNextTT();
; 337  :             delete pCurTT;

  00068	05863014	 streq       r3, [r6, #0x14]
  0006c	eb000000	 bl          |??1TransactionTrasnlate@@QAA@XZ|
  00070	e1a00004	 mov         r0, r4
  00074	eb000000	 bl          |??3@YAXPAX@Z|

; 338  :         }
; 339  :         bReturn=TRUE;

  00078	e3a05001	 mov         r5, #1
  0007c		 |$LN3@DeleteTt|

; 340  :      }
; 341  :     Unlock();

  0007c	e1a00006	 mov         r0, r6
  00080	eb000000	 bl          LeaveCriticalSection

; 342  :     return bReturn;
; 343  : }

  00084	e1a00005	 mov         r0, r5
  00088	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0008c	e12fff1e	 bx          lr
  00090		 |$M32978|

			 ENDP  ; |?DeleteTt@USB2lib@@QAAHEEH@Z|, USB2lib::DeleteTt

	EXPORT	|?GetTT@USB2lib@@QAAPAVTransactionTrasnlate@@EEH@Z| ; USB2lib::GetTT
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T33015| DCD	|$LN23@GetTT|
	DCD	0x40001501
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\usb2lib.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetTT@USB2lib@@QAAPAVTransactionTrasnlate@@EEH@Z| PROC ; USB2lib::GetTT

; 345  : {

  00000		 |$LN23@GetTT|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M33012|
  00004	e1a06002	 mov         r6, r2
  00008	e1a07001	 mov         r7, r1
  0000c	e1a05000	 mov         r5, r0

; 346  : 	UNREFERENCED_PARAMETER(pContext);
; 347  : 
; 348  :     Lock();

  00010	eb000000	 bl          EnterCriticalSection

; 349  :     TransactionTrasnlate * pFoundTT = pTTRoot;

  00014	e5953014	 ldr         r3, [r5, #0x14]
  00018	ea000006	 b           |$LN20@GetTT|
  0001c		 |$LL4@GetTT|

; 350  :     while (pFoundTT) {
; 351  :         if (pFoundTT->GetHubAddress() == uHubAddress && pFoundTT->GetHubPort() == uHubPort)

  0001c	e5d43000	 ldrb        r3, [r4]
  00020	e1530007	 cmp         r3, r7
  00024	1a000002	 bne         |$LN2@GetTT|
  00028	e5d43001	 ldrb        r3, [r4, #1]
  0002c	e1530006	 cmp         r3, r6
  00030	0a000002	 beq         |$LN19@GetTT|
  00034		 |$LN2@GetTT|

; 352  :             break;
; 353  :         else
; 354  :             pFoundTT = pFoundTT->GetNextTT();

  00034	e594300c	 ldr         r3, [r4, #0xC]
  00038		 |$LN20@GetTT|
  00038	e1b04003	 movs        r4, r3
  0003c	1afffff6	 bne         |$LL4@GetTT|
  00040		 |$LN19@GetTT|

; 355  :     }
; 356  :     Unlock();

  00040	e1a00005	 mov         r0, r5
  00044	eb000000	 bl          LeaveCriticalSection

; 357  :     return pFoundTT;
; 358  : }

  00048	e1a00004	 mov         r0, r4
  0004c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$M33013|

			 ENDP  ; |?GetTT@USB2lib@@QAAPAVTransactionTrasnlate@@EEH@Z|, USB2lib::GetTT

	EXPORT	|?Add_bitstuff@USB2lib@@ABAII@Z|	; USB2lib::Add_bitstuff

  00000			 AREA	 |.pdata|, PDATA
|$T33025| DCD	|$LN5@Add_bitstu|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Add_bitstuff@USB2lib@@ABAII@Z| PROC	; USB2lib::Add_bitstuff

; 361  : {

  00000		 |$LN5@Add_bitstu|
  00000		 |$M33022|

; 362  :     // Bit stuffing is 16.6666% extra.
; 363  :     // But we'll calculate bitstuffing as 16% extra with an add of a 4bit
; 364  :     // shift (i.e.  value + value/16) to avoid floats.
; 365  :     return (bus_time + (bus_time>>4));

  00000	e0810221	 add         r0, r1, r1, lsr #4

; 366  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M33023|

			 ENDP  ; |?Add_bitstuff@USB2lib@@ABAII@Z|, USB2lib::Add_bitstuff

	EXPORT	|?Compute_nonsplit_overhead@USB2lib@@AAAHPAU_EndpointBuget@@@Z| ; USB2lib::Compute_nonsplit_overhead

  00000			 AREA	 |.pdata|, PDATA
|$T33036| DCD	|$LN17@Compute_no|
	DCD	0x40001c00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Compute_nonsplit_overhead@USB2lib@@AAAHPAU_EndpointBuget@@@Z| PROC ; USB2lib::Compute_nonsplit_overhead

; 375  : {

  00000		 |$LN17@Compute_no|
  00000		 |$M33033|

; 376  :     if (ep->speed == HSSPEED)

  00000	e5d1300a	 ldrb        r3, [r1, #0xA]
  00004	e3530002	 cmp         r3, #2
  00008	1a00000d	 bne         |$LN12@Compute_no|

; 377  :     {
; 378  :         if (ep->direction == OUTDIR)

  0000c	e5d13009	 ldrb        r3, [r1, #9]
  00010	e3530001	 cmp         r3, #1

; 379  :         {
; 380  :             if (ep->ep_type == isoch)

  00014	e5913004	 ldr         r3, [r1, #4]
  00018	1a000004	 bne         |$LN11@Compute_no|
  0001c	e3530003	 cmp         r3, #3

; 381  :             {
; 382  :                 return HS_TOKEN_SAME_OVERHEAD + HS_DATA_SAME_OVERHEAD + thinktime;

  00020	e5903018	 ldr         r3, [r0, #0x18]
  00024	02830026	 addeq       r0, r3, #0x26

; 383  :             } else // interrupt
; 384  :             {
; 385  :                 return HS_TOKEN_SAME_OVERHEAD + HS_DATA_SAME_OVERHEAD +
; 386  :                     HS_HANDSHAKE_OVERHEAD + thinktime;

  00028	1283002d	 addne       r0, r3, #0x2D

; 412  :     }
; 413  : }

  0002c	e12fff1e	 bx          lr
  00030		 |$LN11@Compute_no|

; 387  :             }
; 388  :         } else
; 389  :         { // IN
; 390  :             if (ep->ep_type == isoch)

  00030	e3530003	 cmp         r3, #3

; 391  :             {
; 392  :                 return HS_TOKEN_TURN_OVERHEAD + HS_DATA_TURN_OVERHEAD + thinktime;

  00034	e5903018	 ldr         r3, [r0, #0x18]
  00038	02830012	 addeq       r0, r3, #0x12

; 393  :                 
; 394  :             } else // interrupt
; 395  :             {
; 396  :                 return HS_TOKEN_TURN_OVERHEAD + HS_DATA_TURN_OVERHEAD +
; 397  :                     HS_HANDSHAKE_OVERHEAD + thinktime;

  0003c	12830019	 addne       r0, r3, #0x19

; 412  :     }
; 413  : }

  00040	e12fff1e	 bx          lr
  00044		 |$LN12@Compute_no|

; 398  :             }
; 399  :         }  // end of IN overhead calculations
; 400  :     } else  if (ep->speed == FSSPEED)

  00044	e3530001	 cmp         r3, #1
  00048	1a000005	 bne         |$LN4@Compute_no|

; 401  :     {
; 402  :         if (ep->ep_type == isoch)

  0004c	e5913004	 ldr         r3, [r1, #4]
  00050	e3530003	 cmp         r3, #3

; 403  :         {
; 404  :             return FS_ISOCH_OVERHEAD + thinktime;

  00054	e5903018	 ldr         r3, [r0, #0x18]
  00058	02830009	 addeq       r0, r3, #9

; 405  :         } else // interrupt
; 406  :         {
; 407  :             return FS_INT_OVERHEAD + thinktime;

  0005c	1283000d	 addne       r0, r3, #0xD

; 412  :     }
; 413  : }

  00060	e12fff1e	 bx          lr
  00064		 |$LN4@Compute_no|

; 408  :         }
; 409  :     } else  // LS
; 410  :     {
; 411  :         return LS_INT_OVERHEAD + thinktime;

  00064	e5903018	 ldr         r3, [r0, #0x18]
  00068	e2830075	 add         r0, r3, #0x75

; 412  :     }
; 413  : }

  0006c	e12fff1e	 bx          lr
  00070		 |$M33034|

			 ENDP  ; |?Compute_nonsplit_overhead@USB2lib@@AAAHPAU_EndpointBuget@@@Z|, USB2lib::Compute_nonsplit_overhead

	EXPORT	|?ConvertBtoHFrame@USB2lib@@AAAXEEPAE0@Z| ; USB2lib::ConvertBtoHFrame

  00000			 AREA	 |.pdata|, PDATA
|$T33047| DCD	|$LN8@ConvertBto|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ConvertBtoHFrame@USB2lib@@AAAXEEPAE0@Z| PROC ; USB2lib::ConvertBtoHFrame

; 690  : {

  00000		 |$LN8@ConvertBto|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M33044|
  00004	e1a0e003	 mov         lr, r3

; 691  :     // The budgeter returns funky values that we have to convert to something
; 692  :     // that the host controller understands.
; 693  :     // If bus micro frame is -1, that means that the start split is scheduled 
; 694  :     // in the last microframe of the previous bus frame.
; 695  :     // to convert to hframes, you simply change the microframe to 0 and 
; 696  :     // keep the bus frame (see one of the tables in the host controller spec 
; 697  :     // eg 4-17.
; 698  :     if(BUFrame == 0xFF) {

  00008	e59d400c	 ldr         r4, [sp, #0xC]
  0000c	e3a05000	 mov         r5, #0
  00010	e35200ff	 cmp         r2, #0xFF

; 699  :         *HUFrame = 0;

  00014	05c45000	 streqb      r5, [r4]

; 700  :         *HFrame = BFrame;

  00018	05ce1000	 streqb      r1, [lr]

; 701  :     }
; 702  :         
; 703  :     // if the budgeter returns a value in the range from 0-6
; 704  :     // we simply add one to the bus micro frame to get the host 
; 705  :     // microframe
; 706  :     if(BUFrame >= 0 && BUFrame <= 6) {

  0001c	e3520006	 cmp         r2, #6

; 707  :         *HUFrame = BUFrame + 1;

  00020	92820001	 addls       r0, r2, #1
  00024	95c40000	 strlsb      r0, [r4]

; 708  :         *HFrame = BFrame;

  00028	95ce1000	 strlsb      r1, [lr]

; 709  :     }
; 710  : 
; 711  :     // if the budgeter returns a value of 7 for the bframe
; 712  :     // then the HUframe = 0 and the HUframe = buframe +1
; 713  :     if(BUFrame == 7) {

  0002c	e3520007	 cmp         r2, #7

; 714  :         *HUFrame = 0;
; 715  :         *HFrame = BFrame + 1;

  00030	02813001	 addeq       r3, r1, #1
  00034	05c45000	 streqb      r5, [r4]
  00038	05ce3000	 streqb      r3, [lr]

; 716  :     }
; 717  : }

  0003c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M33045|

			 ENDP  ; |?ConvertBtoHFrame@USB2lib@@AAAXEEPAE0@Z|, USB2lib::ConvertBtoHFrame

	EXPORT	|?AddedEp@TransactionTrasnlate@@QAAHPAU_EndpointBuget@@@Z| ; TransactionTrasnlate::AddedEp

  00000			 AREA	 |.pdata|, PDATA
|$T33080| DCD	|$LN45@AddedEp|
	DCD	0x40008202
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AddedEp@TransactionTrasnlate@@QAAHPAU_EndpointBuget@@@Z| PROC ; TransactionTrasnlate::AddedEp

; 64   : {

  00000		 |$LN45@AddedEp|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M33077|
  00008	e1b04001	 movs        r4, r1
  0000c	e1a06000	 mov         r6, r0

; 65   :     BOOL bReturn = TRUE;

  00010	e3a05001	 mov         r5, #1

; 66   :     if (ep) {

  00014	0a000077	 beq         |$LN1@AddedEp|

; 67   :        // split or nonsplit FS/LS speed allocation
; 68   :         // classic allocation
; 69   :         // split allocation
; 70   :         unsigned int min_used = frame_budget[0].time_used;
; 71   : 
; 72   :         if (ep->period > MAXFRAMES)

  00018	e1d430b2	 ldrh        r3, [r4, #2]
  0001c	e5960090	 ldr         r0, [r6, #0x90]

; 73   :             ep->actual_period = MAXFRAMES;
; 74   :         else
; 75   :             ep->actual_period = ep->period;
; 76   : 
; 77   :         // Look at all candidate frames for this period to find the one with min
; 78   :         // allocated bus time.  
; 79   :         //
; 80   :         for (unsigned int i=1; i < ep->actual_period ; i++) {

  00020	e3a02001	 mov         r2, #1
  00024	e3530020	 cmp         r3, #0x20
  00028	83a03020	 movhi       r3, #0x20
  0002c	e1a09803	 mov         r9, r3, lsl #16
  00030	e1a09829	 mov         r9, r9, lsr #16
  00034	e3590001	 cmp         r9, #1
  00038	e1c431b0	 strh        r3, [r4, #0x10]
  0003c	9a000009	 bls         |$LN23@AddedEp|
  00040	e2861004	 add         r1, r6, #4
  00044		 |$LL25@AddedEp|

; 81   :             if (frame_budget[i].time_used < min_used) {

  00044	e5913090	 ldr         r3, [r1, #0x90]

; 82   :                 min_used = frame_budget[i].time_used;
; 83   :                 ep->start_frame = (UCHAR)i;

  00048	e2811004	 add         r1, r1, #4
  0004c	e1530000	 cmp         r3, r0
  00050	31a00003	 movcc       r0, r3
  00054	35c42012	 strccb      r2, [r4, #0x12]
  00058	e1d431b0	 ldrh        r3, [r4, #0x10]
  0005c	e2822001	 add         r2, r2, #1
  00060	e1520003	 cmp         r2, r3
  00064	3afffff6	 bcc         |$LL25@AddedEp|
  00068		 |$LN23@AddedEp|

; 84   :             }
; 85   :         }
; 86   :         //***
; 87   :         //*** 2. Calculate classic time required
; 88   :         //***
; 89   : 
; 90   :         // Calculate classic overhead
; 91   :         DWORD overhead;
; 92   :         if (ep->ep_type == isoch) {

  00068	e5943004	 ldr         r3, [r4, #4]

; 93   :             if (ep->speed == FSSPEED)

  0006c	e5d4200a	 ldrb        r2, [r4, #0xA]
  00070	e3530003	 cmp         r3, #3
  00074	1a000004	 bne         |$LN21@AddedEp|
  00078	e3520001	 cmp         r2, #1
  0007c	1a00004c	 bne         |$LN20@AddedEp|

; 94   :                 overhead = FS_ISOCH_OVERHEAD + m_dwThink_time;

  00080	e5963008	 ldr         r3, [r6, #8]
  00084	e2833009	 add         r3, r3, #9

; 95   :             else {
; 96   :                 ASSERT(FALSE);
; 97   :                 return FALSE;
; 98   :             }
; 99   :         } 
; 100  :         else  { // interrupt

  00088	ea000003	 b           |$LN16@AddedEp|
  0008c		 |$LN21@AddedEp|

; 101  :             if (ep->speed == FSSPEED)
; 102  :                 overhead = FS_INT_OVERHEAD + m_dwThink_time;

  0008c	e5963008	 ldr         r3, [r6, #8]
  00090	e3520001	 cmp         r2, #1
  00094	0283300d	 addeq       r3, r3, #0xD

; 103  :             else
; 104  :                 overhead = LS_INT_OVERHEAD + m_dwThink_time;

  00098	12833075	 addne       r3, r3, #0x75
  0009c		 |$LN16@AddedEp|

; 105  :         }
; 106  : 
; 107  :         // Classic bus time, NOT including bitstuffing overhead (in FS byte times) since we do best case budget
; 108  :         ep->calc_bus_time = (USHORT)(ep->max_packet * (ep->speed!=LSSPEED?1:8) + overhead);

  0009c	e3520000	 cmp         r2, #0
  000a0	e1d420b0	 ldrh        r2, [r4]
  000a4	13a01001	 movne       r1, #1
  000a8	03a01008	 moveq       r1, #8

; 109  : 
; 110  :         USHORT latest_start = FS_SOF + HUB_FS_ADJ;  // initial start time must be after the SOF transaction
; 111  : 
; 112  :         for (i=0; ep->start_frame + i < MAXFRAMES && bReturn==TRUE; i += ep->actual_period) {

  000ac	e0233192	 mla         r3, r2, r1, r3
  000b0	e5d47012	 ldrb        r7, [r4, #0x12]
  000b4	e3a05024	 mov         r5, #0x24
  000b8	e1a08803	 mov         r8, r3, lsl #16
  000bc	e1a08828	 mov         r8, r8, lsr #16
  000c0	e1c480bc	 strh        r8, [r4, #0xC]
  000c4	e3a0b000	 mov         r11, #0
  000c8	e3570020	 cmp         r7, #0x20
  000cc	2a000017	 bcs         |$LN41@AddedEp|
  000d0	e086a107	 add         r10, r6, r7, lsl #2
  000d4	e28de004	 add         lr, sp, #4
  000d8		 |$LL15@AddedEp|

; 113  :             DWORD t=0;
; 114  :             if (FindBestTimeSlot(latest_start,ep->calc_bus_time,TT_frame[ep->start_frame + i],&t)) {

  000d8	e3a0e000	 mov         lr, #0
  000dc	e59a3010	 ldr         r3, [r10, #0x10]
  000e0	e58de004	 str         lr, [sp, #4]
  000e4	e28de004	 add         lr, sp, #4
  000e8	e1a02008	 mov         r2, r8
  000ec	e1a01005	 mov         r1, r5
  000f0	e1a00006	 mov         r0, r6
  000f4	e58de000	 str         lr, [sp]
  000f8	eb000000	 bl          |?FindBestTimeSlot@TransactionTrasnlate@@AAAHGGPAU_ENDPOINTBUGETLIST@@PAK@Z|
  000fc	e3500000	 cmp         r0, #0
  00100	0a000029	 beq         |$LN12@AddedEp|

; 115  :                 ASSERT(t>=latest_start);
; 116  :                 // update latest start time as required
; 117  :                 if (t > latest_start)

  00104	e59d3004	 ldr         r3, [sp, #4]
  00108	e08bb009	 add         r11, r11, r9
  0010c	e08aa109	 add         r10, r10, r9, lsl #2
  00110	e1530005	 cmp         r3, r5

; 118  :                     latest_start = (USHORT)t;

  00114	81a05803	 movhi       r5, r3, lsl #16
  00118	e5d43012	 ldrb        r3, [r4, #0x12]
  0011c	81a05825	 movhi       r5, r5, lsr #16
  00120	e28de004	 add         lr, sp, #4
  00124	e083300b	 add         r3, r3, r11
  00128	e3530020	 cmp         r3, #0x20
  0012c	3affffe9	 bcc         |$LL15@AddedEp|
  00130		 |$LN41@AddedEp|

; 124  :                 break;
; 125  :             }
; 126  :         } // end of for loop looking for latest start time
; 127  : 
; 128  :         if (bReturn==TRUE) {

  00130	e3a03b01	 mov         r3, #1, 22

; 129  :             // Set the start time for the new endpoint
; 130  :             ep->start_time = latest_start;
; 131  : 
; 132  :             if ((ep->start_time + ep->calc_bus_time) > FS_MAX_PERIODIC_ALLOCATION)  {

  00134	e3832085	 orr         r2, r3, #0x85
  00138	e0883005	 add         r3, r8, r5
  0013c	e1530002	 cmp         r3, r2
  00140	e1c450be	 strh        r5, [r4, #0xE]

; 133  :             //      error("start time %d past end of frame", ep->start_time + ep->calc_bus_time);
; 134  :                 ep->calc_bus_time = 0;
; 135  :                 return FALSE;

  00144	ca000018	 bgt         |$LN12@AddedEp|

; 136  :             }
; 137  :             BOOL bRet=TRUE;

  00148	e3a05001	 mov         r5, #1

; 138  :             for (i=0; ep->start_frame + i < MAXFRAMES; i += ep->actual_period) {

  0014c	e3a08000	 mov         r8, #0
  00150	e3570020	 cmp         r7, #0x20
  00154	2a000027	 bcs         |$LN1@AddedEp|
  00158		 |$LL7@AddedEp|

; 139  :                 bRet &= InsertEp(ep->start_frame + i, ep);

  00158	e5d43012	 ldrb        r3, [r4, #0x12]
  0015c	e1a02004	 mov         r2, r4
  00160	e1a00006	 mov         r0, r6
  00164	e0831008	 add         r1, r3, r8
  00168	eb000000	 bl          |?InsertEp@TransactionTrasnlate@@AAAHKPAU_EndpointBuget@@@Z|

; 140  :                 ASSERT(bRet==TRUE);
; 141  :                 frame_budget[0].time_used += ep->calc_bus_time;

  0016c	e1d420bc	 ldrh        r2, [r4, #0xC]
  00170	e5963090	 ldr         r3, [r6, #0x90]
  00174	e0005005	 and         r5, r0, r5
  00178	e0823003	 add         r3, r2, r3
  0017c	e5863090	 str         r3, [r6, #0x90]
  00180	e1d431b0	 ldrh        r3, [r4, #0x10]
  00184	e5d42012	 ldrb        r2, [r4, #0x12]
  00188	e0888003	 add         r8, r8, r3
  0018c	e0823008	 add         r3, r2, r8
  00190	e3530020	 cmp         r3, #0x20
  00194	3affffef	 bcc         |$LL7@AddedEp|

; 142  :             }
; 143  :             if (bRet == FALSE) {

  00198	e3550000	 cmp         r5, #0
  0019c	1a000015	 bne         |$LN1@AddedEp|

; 144  :                 for (i=0; ep->start_frame + i < MAXFRAMES; i += ep->actual_period) {

  001a0	e20230ff	 and         r3, r2, #0xFF
  001a4	e3a07000	 mov         r7, #0
  001a8	ea000010	 b           |$LN42@AddedEp|
  001ac		 |$LN12@AddedEp|

; 119  :             }
; 120  :             else { // Runout the slot this one.
; 121  :                 ASSERT(FALSE);
; 122  :                 ep->calc_bus_time = 0;

  001ac	e3a03000	 mov         r3, #0
  001b0	e1c430bc	 strh        r3, [r4, #0xC]
  001b4		 |$LN20@AddedEp|

; 123  :                 bReturn= FALSE;

  001b4	e3a05000	 mov         r5, #0

; 124  :                 break;
; 125  :             }
; 126  :         } // end of for loop looking for latest start time
; 127  : 
; 128  :         if (bReturn==TRUE) {

  001b8	ea00000e	 b           |$LN1@AddedEp|
  001bc		 |$LL3@AddedEp|

; 145  :                     RemoveEp(ep->start_frame + i, ep);

  001bc	e5d43012	 ldrb        r3, [r4, #0x12]
  001c0	e1a02004	 mov         r2, r4
  001c4	e1a00006	 mov         r0, r6
  001c8	e0831007	 add         r1, r3, r7
  001cc	eb000000	 bl          |?RemoveEp@TransactionTrasnlate@@AAAHKPAU_EndpointBuget@@@Z|

; 146  :                     frame_budget[0].time_used -= ep->calc_bus_time;

  001d0	e1d420bc	 ldrh        r2, [r4, #0xC]
  001d4	e5963090	 ldr         r3, [r6, #0x90]
  001d8	e0433002	 sub         r3, r3, r2
  001dc	e5863090	 str         r3, [r6, #0x90]
  001e0	e1d431b0	 ldrh        r3, [r4, #0x10]
  001e4	e5d42012	 ldrb        r2, [r4, #0x12]
  001e8	e0877003	 add         r7, r7, r3
  001ec	e0823007	 add         r3, r2, r7
  001f0		 |$LN42@AddedEp|
  001f0	e3530020	 cmp         r3, #0x20
  001f4	3afffff0	 bcc         |$LL3@AddedEp|
  001f8		 |$LN1@AddedEp|

; 147  :                 }
; 148  :             }
; 149  :             bReturn = bRet;
; 150  :         }
; 151  : 
; 152  :     }
; 153  :     ASSERT(bReturn);
; 154  :     return bReturn;
; 155  : }

  001f8	e1a00005	 mov         r0, r5
  001fc	e28dd008	 add         sp, sp, #8
  00200	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00204	e12fff1e	 bx          lr
  00208		 |$M33078|

			 ENDP  ; |?AddedEp@TransactionTrasnlate@@QAAHPAU_EndpointBuget@@@Z|, TransactionTrasnlate::AddedEp

	EXPORT	|?DeletedEp@TransactionTrasnlate@@QAAHPAU_EndpointBuget@@@Z| ; TransactionTrasnlate::DeletedEp

  00000			 AREA	 |.pdata|, PDATA
|$T33095| DCD	|$LN12@DeletedEp|
	DCD	0x40001b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DeletedEp@TransactionTrasnlate@@QAAHPAU_EndpointBuget@@@Z| PROC ; TransactionTrasnlate::DeletedEp

; 157  : {

  00000		 |$LN12@DeletedEp|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M33092|
  00004	e1a04001	 mov         r4, r1
  00008	e1a07000	 mov         r7, r0

; 158  :     BOOL bReturn = TRUE;
; 159  :     for (unsigned int i=0; ep->start_frame + i < MAXFRAMES; i += ep->actual_period) {

  0000c	e5d41012	 ldrb        r1, [r4, #0x12]
  00010	e3a05001	 mov         r5, #1
  00014	e3a06000	 mov         r6, #0
  00018	e3510020	 cmp         r1, #0x20
  0001c	2a00000f	 bcs         |$LN3@DeletedEp|
  00020		 |$LL5@DeletedEp|

; 160  :         if (RemoveEp(ep->start_frame + i, ep))

  00020	e1a02004	 mov         r2, r4
  00024	e0811006	 add         r1, r1, r6
  00028	e1a00007	 mov         r0, r7
  0002c	eb000000	 bl          |?RemoveEp@TransactionTrasnlate@@AAAHKPAU_EndpointBuget@@@Z|
  00030	e3500000	 cmp         r0, #0

; 161  :             frame_budget[0].time_used -= ep->calc_bus_time;

  00034	11d420bc	 ldrneh      r2, [r4, #0xC]
  00038	15973090	 ldrne       r3, [r7, #0x90]

; 162  :         else{
; 163  :             ASSERT(FALSE);
; 164  :             bReturn=FALSE;

  0003c	03a05000	 moveq       r5, #0
  00040	10433002	 subne       r3, r3, r2
  00044	15873090	 strne       r3, [r7, #0x90]
  00048	e1d431b0	 ldrh        r3, [r4, #0x10]
  0004c	e5d41012	 ldrb        r1, [r4, #0x12]
  00050	e0866003	 add         r6, r6, r3
  00054	e0813006	 add         r3, r1, r6
  00058	e3530020	 cmp         r3, #0x20
  0005c	3affffef	 bcc         |$LL5@DeletedEp|
  00060		 |$LN3@DeletedEp|

; 165  :         }
; 166  :     }
; 167  :     return bReturn;    
; 168  : }

  00060	e1a00005	 mov         r0, r5
  00064	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00068	e12fff1e	 bx          lr
  0006c		 |$M33093|

			 ENDP  ; |?DeletedEp@TransactionTrasnlate@@QAAHPAU_EndpointBuget@@@Z|, TransactionTrasnlate::DeletedEp

	EXPORT	|??1USB2lib@@QAA@XZ|			; USB2lib::~USB2lib
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T33128| DCD	|$LN22@USB2lib@2|
	DCD	0x40001401
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\usb2lib.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1USB2lib@@QAA@XZ| PROC		; USB2lib::~USB2lib

; 285  : {

  00000		 |$LN22@USB2lib@2|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M33125|
  00004	e1a05000	 mov         r5, r0

; 286  :     Lock();

  00008	eb000000	 bl          EnterCriticalSection

; 287  :     TransactionTrasnlate * pCurTT= pTTRoot;

  0000c	e5953014	 ldr         r3, [r5, #0x14]
  00010	e1b06003	 movs        r6, r3

; 288  :     while (pCurTT) {

  00014	0a000007	 beq         |$LN1@USB2lib@2|
  00018		 |$LL2@USB2lib@2|

; 289  :         TransactionTrasnlate * pNextTT = pCurTT->GetNextTT();
; 290  :         delete pCurTT;

  00018	e596400c	 ldr         r4, [r6, #0xC]
  0001c	e1a00006	 mov         r0, r6
  00020	eb000000	 bl          |??1TransactionTrasnlate@@QAA@XZ|
  00024	e1a00006	 mov         r0, r6
  00028	eb000000	 bl          |??3@YAXPAX@Z|

; 291  :         pCurTT = pNextTT;

  0002c	e1a06004	 mov         r6, r4
  00030	e3540000	 cmp         r4, #0
  00034	1afffff7	 bne         |$LL2@USB2lib@2|
  00038		 |$LN1@USB2lib@2|

; 292  :     }
; 293  :     Unlock();

  00038	e1a00005	 mov         r0, r5
  0003c	eb000000	 bl          LeaveCriticalSection

; 294  : }

  00040	e1a00005	 mov         r0, r5
  00044	eb000000	 bl          DeleteCriticalSection
  00048	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M33126|

			 ENDP  ; |??1USB2lib@@QAA@XZ|, USB2lib::~USB2lib

	EXPORT	|?AddedTt@USB2lib@@QAAHEE@Z|		; USB2lib::AddedTt
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T33152| DCD	|$LN14@AddedTt|
	DCD	0x40002402
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\usb2lib.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AddedTt@USB2lib@@QAAHEE@Z| PROC	; USB2lib::AddedTt

; 297  : {

  00000		 |$LN14@AddedTt|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M33149|
  00008	e1a06002	 mov         r6, r2
  0000c	e1a07001	 mov         r7, r1
  00010	e1a05000	 mov         r5, r0

; 298  :     BOOL bReturn = FALSE;
; 299  :     Lock();

  00014	e3a04000	 mov         r4, #0
  00018	eb000000	 bl          EnterCriticalSection

; 300  :     if (GetTT( uHubAddress,uPort, TRUE) == NULL) {//Verify

  0001c	e3a03001	 mov         r3, #1
  00020	e1a02006	 mov         r2, r6
  00024	e1a01007	 mov         r1, r7
  00028	e1a00005	 mov         r0, r5
  0002c	eb000000	 bl          |?GetTT@USB2lib@@QAAPAVTransactionTrasnlate@@EEH@Z|
  00030	e3500000	 cmp         r0, #0
  00034	1a00000e	 bne         |$LN3@AddedTt|

; 301  :         TransactionTrasnlate * pNewTT = new TransactionTrasnlate(uHubAddress,uPort, pTTRoot);

  00038	e3a00e11	 mov         r0, #0x11, 28
  0003c	eb000000	 bl          |??2@YAPAXI@Z|
  00040	e3500000	 cmp         r0, #0
  00044	0a000006	 beq         |$LN6@AddedTt|
  00048	e5953014	 ldr         r3, [r5, #0x14]
  0004c	e3a0e000	 mov         lr, #0
  00050	e1a02006	 mov         r2, r6
  00054	e1a01007	 mov         r1, r7
  00058	e58de000	 str         lr, [sp]
  0005c	eb000000	 bl          |??0TransactionTrasnlate@@QAA@EEQAXPAV0@@Z|
  00060	ea000000	 b           |$LN7@AddedTt|
  00064		 |$LN6@AddedTt|
  00064	e3a00000	 mov         r0, #0
  00068		 |$LN7@AddedTt|

; 302  :         if ( pNewTT) {

  00068	e3500000	 cmp         r0, #0
  0006c	0a000001	 beq         |$LN1@AddedTt|

; 303  :             pTTRoot=pNewTT;

  00070	e5850014	 str         r0, [r5, #0x14]
  00074		 |$LN3@AddedTt|

; 304  :             bReturn=TRUE;
; 305  :         }
; 306  :     }
; 307  :     else
; 308  :         bReturn=TRUE;

  00074	e3a04001	 mov         r4, #1
  00078		 |$LN1@AddedTt|

; 309  :     Unlock();

  00078	e1a00005	 mov         r0, r5
  0007c	eb000000	 bl          LeaveCriticalSection

; 310  :     return bReturn;
; 311  :         
; 312  : }

  00080	e1a00004	 mov         r0, r4
  00084	e28dd004	 add         sp, sp, #4
  00088	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0008c	e12fff1e	 bx          lr
  00090		 |$M33150|

			 ENDP  ; |?AddedTt@USB2lib@@QAAHEE@Z|, USB2lib::AddedTt

	EXPORT	|?AllocUsb2BusTime@USB2lib@@QAAHEEHPAU_EndpointBuget@@@Z| ; USB2lib::AllocUsb2BusTime
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T33207| DCD	|$LN63@AllocUsb2B|
	DCD	0x4000b601
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\usb2lib.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AllocUsb2BusTime@USB2lib@@QAAHEEHPAU_EndpointBuget@@@Z| PROC ; USB2lib::AllocUsb2BusTime

; 416  : {

  00000		 |$LN63@AllocUsb2B|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M33204|
  00004	e1a08003	 mov         r8, r3
  00008	e1a09002	 mov         r9, r2
  0000c	e1a0a001	 mov         r10, r1
  00010	e1a07000	 mov         r7, r0

; 417  :     int retv;
; 418  :     unsigned   changed_eps, i, min_used;
; 419  :     //PEndpoint curr_ep, last_ep, p;
; 420  : 
; 421  :     changed_eps = 0;
; 422  : 
; 423  :     retv = 1;
; 424  :     Lock();

  00014	e3a04001	 mov         r4, #1
  00018	eb000000	 bl          EnterCriticalSection

; 425  :     // OVERVIEW of algorithm steps:
; 426  :     //  1. Determine starting frame # for period
; 427  :     //  2. Calculate classic time required
; 428  :     //  3. For all period frames, find the latest starting time so we can check the classic allocation later
; 429  :     //  4. Process each frame data structure for endpoint period in budget window
; 430  :     //  5.   Now check allocation for each frame using shift adjustment based on latest start time
; 431  :     //  6a.  Now move isoch endpoints, insert new isoch and then move interrupt endpoints
; 432  :     //  6b.  Now insert new interrupt and move rest of interrupt endpoints
; 433  :     //  7.   Allocate HS bus time
; 434  :     //  8.   Allocate classic bus time
; 435  : 
; 436  : 
; 437  :     //***
; 438  :     //*** 1. Determine starting frame # for period
; 439  :     //***
; 440  : 
; 441  : 
; 442  : 
; 443  :     // Also remember the maximum frame time allocation since it will be used to pass the allocation check.
; 444  : 
; 445  :     // Find starting frame number for reasonable balance of all classic frames
; 446  : 
; 447  :     ep->start_frame = 0;

  0001c	e59d5020	 ldr         r5, [sp, #0x20]
  00020	e3a06000	 mov         r6, #0

; 448  :     ep->start_microframe = 0;
; 449  :     ep->num_completes = 0;
; 450  :     ep->num_starts = 0;
; 451  : 
; 452  :     // check that this endpoint isn't already allocated
; 453  :     if (ep->calc_bus_time)

  00024	e1d5e0bc	 ldrh        lr, [r5, #0xC]
  00028	e5c56012	 strb        r6, [r5, #0x12]
  0002c	e5c56013	 strb        r6, [r5, #0x13]
  00030	e35e0000	 cmp         lr, #0
  00034	e5c56015	 strb        r6, [r5, #0x15]
  00038	e5c56014	 strb        r6, [r5, #0x14]
  0003c	1a00005c	 bne         |$LN56@AllocUsb2B|

; 459  :     }
; 460  : 
; 461  :     // handle nonsplit HS allocation
; 462  :     if (ep->speed == HSSPEED) {

  00040	e5d5300a	 ldrb        r3, [r5, #0xA]
  00044	e3530002	 cmp         r3, #2
  00048	1a000046	 bne         |$LN32@AllocUsb2B|

; 463  : 
; 464  :         min_used = HS_microframe_info[0][0].time_used;
; 465  : 
; 466  :         if (ep->period > MAXFRAMES*MICROFRAMES_PER_FRAME)

  0004c	e1d530b2	 ldrh        r3, [r5, #2]
  00050	e5971024	 ldr         r1, [r7, #0x24]

; 467  :             ep->actual_period = MAXFRAMES*MICROFRAMES_PER_FRAME;
; 468  :         else
; 469  :             ep->actual_period = ep->period;
; 470  : 
; 471  :         // Look at all candidate frames for this period to find the one with min
; 472  :         // allocated bus time.  
; 473  :         //
; 474  :         for (i=1; i < ep->actual_period; i++){

  00054	e3a02001	 mov         r2, #1
  00058	e3530c01	 cmp         r3, #1, 24
  0005c	83a03c01	 movhi       r3, #1, 24
  00060	e1c531b0	 strh        r3, [r5, #0x10]
  00064	e1a03803	 mov         r3, r3, lsl #16
  00068	e1a03823	 mov         r3, r3, lsr #16
  0006c	e3530001	 cmp         r3, #1
  00070	9a00000c	 bls         |$LN27@AllocUsb2B|
  00074		 |$LL29@AllocUsb2B|

; 475  :             if (HS_microframe_info[i/MICROFRAMES_PER_FRAME][i % MICROFRAMES_PER_FRAME].time_used < min_used)

  00074	e1a001a2	 mov         r0, r2, lsr #3
  00078	e202e007	 and         lr, r2, #7
  0007c	e08e3180	 add         r3, lr, r0, lsl #3
  00080	e0873103	 add         r3, r7, r3, lsl #2
  00084	e5933024	 ldr         r3, [r3, #0x24]

; 476  :             {
; 477  :                 min_used = HS_microframe_info[i/MICROFRAMES_PER_FRAME][i % MICROFRAMES_PER_FRAME].time_used;
; 478  :                 ep->start_frame = (UCHAR)(i / MICROFRAMES_PER_FRAME);
; 479  :                 ep->start_microframe = (UCHAR)(i % MICROFRAMES_PER_FRAME);

  00088	e2822001	 add         r2, r2, #1
  0008c	e1530001	 cmp         r3, r1
  00090	31a01003	 movcc       r1, r3
  00094	35c50012	 strccb      r0, [r5, #0x12]
  00098	35c5e013	 strccb      lr, [r5, #0x13]
  0009c	e1d531b0	 ldrh        r3, [r5, #0x10]
  000a0	e1520003	 cmp         r2, r3
  000a4	3afffff2	 bcc         |$LL29@AllocUsb2B|
  000a8		 |$LN27@AllocUsb2B|

; 480  :             }
; 481  :         }
; 482  : 
; 483  :         // compute and allocate HS bandwidth
; 484  :         ep->calc_bus_time = (USHORT)(Compute_nonsplit_overhead(ep) + Add_bitstuff(ep->max_packet));

  000a8	e1a01005	 mov         r1, r5
  000ac	e1a00007	 mov         r0, r7
  000b0	eb000000	 bl          |?Compute_nonsplit_overhead@USB2lib@@AAAHPAU_EndpointBuget@@@Z|
  000b4	e1d510b0	 ldrh        r1, [r5]

; 485  :         for (i = (ep->start_frame*MICROFRAMES_PER_FRAME) + ep->start_microframe;

  000b8	e5d5e012	 ldrb        lr, [r5, #0x12]
  000bc	e1d521d3	 ldrsb       r2, [r5, #0x13]
  000c0	e0803221	 add         r3, r0, r1, lsr #4
  000c4	e0833001	 add         r3, r3, r1
  000c8	e082018e	 add         r0, r2, lr, lsl #3
  000cc	e1c530bc	 strh        r3, [r5, #0xC]

; 486  :                 i < MAXFRAMES*MICROFRAMES_PER_FRAME;
; 487  :                 i += ep->actual_period){

  000d0	e3500c01	 cmp         r0, #1, 24
  000d4	2a000021	 bcs         |$LN18@AllocUsb2B|
  000d8	e3a03c1b	 mov         r3, #0x1B, 24
  000dc	e383e058	 orr         lr, r3, #0x58
  000e0		 |$LL25@AllocUsb2B|

; 488  :             HS_microframe_info[i/MICROFRAMES_PER_FRAME][i % MICROFRAMES_PER_FRAME].time_used +=ep->calc_bus_time;

  000e0	e1a021a0	 mov         r2, r0, lsr #3
  000e4	e2003007	 and         r3, r0, #7
  000e8	e0833182	 add         r3, r3, r2, lsl #3
  000ec	e0871103	 add         r1, r7, r3, lsl #2
  000f0	e5912024	 ldr         r2, [r1, #0x24]
  000f4	e1d530bc	 ldrh        r3, [r5, #0xC]
  000f8	e0833002	 add         r3, r3, r2
  000fc	e5813024	 str         r3, [r1, #0x24]

; 489  :             if (HS_microframe_info[i/MICROFRAMES_PER_FRAME][i % MICROFRAMES_PER_FRAME].time_used >HS_MAX_PERIODIC_ALLOCATION)

  00100	e153000e	 cmp         r3, lr
  00104	e1d531b0	 ldrh        r3, [r5, #0x10]

; 490  :                 retv = 0;

  00108	83a04000	 movhi       r4, #0
  0010c	e0800003	 add         r0, r0, r3
  00110	e3500c01	 cmp         r0, #1, 24
  00114	3afffff1	 bcc         |$LL25@AllocUsb2B|

; 491  :         }
; 492  :         if (! retv)  // if allocation failed, deallocate

  00118	e3540000	 cmp         r4, #0
  0011c	1a00000f	 bne         |$LN18@AllocUsb2B|

; 493  :         {
; 494  :             for (i = (ep->start_frame*MICROFRAMES_PER_FRAME) + ep->start_microframe;

  00120	e5d52012	 ldrb        r2, [r5, #0x12]
  00124	e1d531d3	 ldrsb       r3, [r5, #0x13]
  00128	e0830182	 add         r0, r3, r2, lsl #3
  0012c	ea000009	 b           |$LN57@AllocUsb2B|
  00130		 |$LL20@AllocUsb2B|

; 497  :                 HS_microframe_info[i/MICROFRAMES_PER_FRAME][i % MICROFRAMES_PER_FRAME].time_used -= ep->calc_bus_time;

  00130	e1a021a0	 mov         r2, r0, lsr #3
  00134	e2003007	 and         r3, r0, #7
  00138	e0833182	 add         r3, r3, r2, lsl #3
  0013c	e0871103	 add         r1, r7, r3, lsl #2
  00140	e5912024	 ldr         r2, [r1, #0x24]
  00144	e1d530bc	 ldrh        r3, [r5, #0xC]
  00148	e0423003	 sub         r3, r2, r3
  0014c	e5813024	 str         r3, [r1, #0x24]
  00150	e1d531b0	 ldrh        r3, [r5, #0x10]
  00154	e0800003	 add         r0, r0, r3
  00158		 |$LN57@AllocUsb2B|
  00158	e3500c01	 cmp         r0, #1, 24
  0015c	3afffff3	 bcc         |$LL20@AllocUsb2B|
  00160		 |$LN18@AllocUsb2B|

; 495  :                     i < MAXFRAMES*MICROFRAMES_PER_FRAME;
; 496  :                     i += ep->actual_period){

  00160	e1a06004	 mov         r6, r4
  00164	ea000012	 b           |$LN56@AllocUsb2B|
  00168		 |$LN32@AllocUsb2B|

; 498  :             }
; 499  :         }
; 500  :         Unlock();
; 501  :         return retv;
; 502  :     }
; 503  :     
; 504  :  
; 505  :     // above handles all speeds, the rest of this code is for split transaction processing
; 506  : 
; 507  :     //***
; 508  :     //*** 2. Calculate classic time required
; 509  :     //***
; 510  :     TransactionTrasnlate * pTT=GetTT( uHubAddress,uHubPort,ttContext);

  00168	e1a03008	 mov         r3, r8
  0016c	e1a02009	 mov         r2, r9
  00170	e1a0100a	 mov         r1, r10
  00174	e1a00007	 mov         r0, r7
  00178	eb000000	 bl          |?GetTT@USB2lib@@QAAPAVTransactionTrasnlate@@EEH@Z|
  0017c	e3500000	 cmp         r0, #0

; 511  :     if (pTT== NULL || pTT->AddedEp(ep)!=TRUE) {

  00180	0a00004d	 beq         |$LN16@AllocUsb2B|
  00184	e1a01005	 mov         r1, r5
  00188	eb000000	 bl          |?AddedEp@TransactionTrasnlate@@QAAHPAU_EndpointBuget@@@Z|
  0018c	e3500001	 cmp         r0, #1
  00190	1a000049	 bne         |$LN16@AllocUsb2B|

; 514  :     }
; 515  :     
; 516  :     if ((ep->start_time + ep->calc_bus_time) > FS_MAX_PERIODIC_ALLOCATION)

  00194	e1d580be	 ldrh        r8, [r5, #0xE]
  00198	e1d520bc	 ldrh        r2, [r5, #0xC]
  0019c	e3a03b01	 mov         r3, #1, 22
  001a0	e3833085	 orr         r3, r3, #0x85
  001a4	e0829008	 add         r9, r2, r8
  001a8	e1590003	 cmp         r9, r3
  001ac	da000003	 ble         |$LN15@AllocUsb2B|

; 517  :     {
; 518  : //      error("start time %d past end of frame", ep->start_time + ep->calc_bus_time);
; 519  :         ep->calc_bus_time = 0;

  001b0	e1c560bc	 strh        r6, [r5, #0xC]
  001b4		 |$LN56@AllocUsb2B|

; 454  :     {
; 455  :         DEBUGMSG(1,(TEXT("endpoint already allocated\r\n")));
; 456  :         ASSERT(FALSE);
; 457  :         Unlock();

  001b4	e1a00007	 mov         r0, r7
  001b8	eb000000	 bl          LeaveCriticalSection

; 458  :         return 0;

  001bc	ea000041	 b           |$LN34@AllocUsb2B|
  001c0		 |$LN15@AllocUsb2B|

; 520  :         Unlock();
; 521  :         return 0;
; 522  :     }
; 523  : 
; 524  :     ep->start_microframe = (CHAR)((ep->start_time /  FS_BYTES_PER_MICROFRAME) - 1);

  001c0	e59fa10c	 ldr         r10, [pc, #0x10C]

; 525  :     UCHAR lastcs = (UCHAR)(( (ep->start_time + ep->calc_bus_time) / FS_BYTES_PER_MICROFRAME) + 1);
; 526  : 
; 527  :     // determine number of splits (starts and completes)
; 528  :     if (ep->direction == OUTDIR) {

  001c4	e5d50009	 ldrb        r0, [r5, #9]
  001c8	e0c3ea98	 smull       lr, r3, r8, r10
  001cc	e0c24a99	 smull       r4, r2, r9, r10
  001d0	e0833008	 add         r3, r3, r8
  001d4	e1a033c3	 mov         r3, r3, asr #7
  001d8	e0822009	 add         r2, r2, r9
  001dc	e0833fa3	 add         r3, r3, r3, lsr #31
  001e0	e1a023c2	 mov         r2, r2, asr #7
  001e4	e2431001	 sub         r1, r3, #1
  001e8	e0823fa2	 add         r3, r2, r2, lsr #31
  001ec	e1a01c01	 mov         r1, r1, lsl #24
  001f0	e2833001	 add         r3, r3, #1
  001f4	e1a01c41	 mov         r1, r1, asr #24
  001f8	e203e0ff	 and         lr, r3, #0xFF
  001fc	e3500001	 cmp         r0, #1

; 529  :         if (ep->ep_type == isoch)

  00200	e5953004	 ldr         r3, [r5, #4]
  00204	e5c51013	 strb        r1, [r5, #0x13]
  00208	1a00000a	 bne         |$LN14@AllocUsb2B|
  0020c	e3530003	 cmp         r3, #3
  00210	1a00001c	 bne         |$LN9@AllocUsb2B|

; 530  :         {
; 531  :             ep->num_starts = (UCHAR)((ep->max_packet / FS_BYTES_PER_MICROFRAME) + 1);

  00214	e1d510b0	 ldrh        r1, [r5]

; 532  :             ep->num_completes = 0;

  00218	e5c56015	 strb        r6, [r5, #0x15]
  0021c	e0c32a91	 smull       r2, r3, r1, r10
  00220	e0833001	 add         r3, r3, r1
  00224	e1a033c3	 mov         r3, r3, asr #7
  00228	e0833fa3	 add         r3, r3, r3, lsr #31
  0022c	e2833001	 add         r3, r3, #1
  00230	e5c53014	 strb        r3, [r5, #0x14]

; 533  :         } else // interrupt
; 534  :         {
; 535  :             ep->num_starts = 1;
; 536  :             ep->num_completes = 2;
; 537  :             if (ep->start_microframe + 1 < 6)
; 538  :                 ep->num_completes++;
; 539  :         }
; 540  :     } else { // IN

  00234	ea00001c	 b           |$LN1@AllocUsb2B|
  00238		 |$LN14@AllocUsb2B|

; 541  :         if (ep->ep_type == isoch) {

  00238	e3530003	 cmp         r3, #3
  0023c	1a000011	 bne         |$LN9@AllocUsb2B|

; 542  :             ep->num_starts = 1;
; 543  :             ep->num_completes = lastcs - (ep->start_microframe + 1);

  00240	e04e3001	 sub         r3, lr, r1
  00244	e28320ff	 add         r2, r3, #0xFF
  00248	e3a03001	 mov         r3, #1
  0024c	e5c53014	 strb        r3, [r5, #0x14]
  00250	e5c52015	 strb        r2, [r5, #0x15]

; 544  :             if (lastcs <= 6)

  00254	e35e0006	 cmp         lr, #6
  00258	8a000004	 bhi         |$LN8@AllocUsb2B|

; 545  :             {
; 546  :                 if ((ep->start_microframe + 1) == 0)

  0025c	e2913001	 adds        r3, r1, #1

; 547  :                     ep->num_completes++;

  00260	02823001	 addeq       r3, r2, #1
  00264	0a00000f	 beq         |$LN59@AllocUsb2B|

; 549  :                     ep->num_completes += 2;  // this can cause one CS to be in the next frame

  00268	e2823002	 add         r3, r2, #2
  0026c	ea00000d	 b           |$LN59@AllocUsb2B|
  00270		 |$LN8@AllocUsb2B|

; 550  :             }
; 551  :             else if (lastcs == 7)

  00270	e35e0007	 cmp         lr, #7
  00274	1a00000c	 bne         |$LN1@AllocUsb2B|

; 552  :             {
; 553  :                 if ((ep->start_microframe + 1) != 0)

  00278	e2913001	 adds        r3, r1, #1
  0027c	0a00000a	 beq         |$LN1@AllocUsb2B|

; 547  :                     ep->num_completes++;

  00280	e2823001	 add         r3, r2, #1

; 548  :                 else

  00284	ea000007	 b           |$LN59@AllocUsb2B|
  00288		 |$LN9@AllocUsb2B|

; 554  :                     ep->num_completes++;  // only one more CS if late in the frame.
; 555  :             }
; 556  : 
; 557  :         } else // interrupt
; 558  :         {
; 559  :             ep->num_starts = 1;
; 560  :             ep->num_completes = 2;
; 561  :             if (ep->start_microframe + 1 < 6)

  00288	e2813001	 add         r3, r1, #1
  0028c	e3a00002	 mov         r0, #2
  00290	e3a02001	 mov         r2, #1
  00294	e3530006	 cmp         r3, #6
  00298	e5c50015	 strb        r0, [r5, #0x15]
  0029c	e5c52014	 strb        r2, [r5, #0x14]
  002a0	aa000001	 bge         |$LN1@AllocUsb2B|

; 562  :                 ep->num_completes++;

  002a4	e3a03003	 mov         r3, #3
  002a8		 |$LN59@AllocUsb2B|
  002a8	e5c53015	 strb        r3, [r5, #0x15]
  002ac		 |$LN1@AllocUsb2B|

; 563  :         }
; 564  :     }  // end of IN
; 565  :     Unlock();

  002ac	e1a00007	 mov         r0, r7
  002b0	eb000000	 bl          LeaveCriticalSection

; 566  :     return retv;

  002b4	e3a06001	 mov         r6, #1
  002b8	ea000002	 b           |$LN34@AllocUsb2B|
  002bc		 |$LN16@AllocUsb2B|

; 512  :         Unlock();

  002bc	e1a00007	 mov         r0, r7
  002c0	eb000000	 bl          LeaveCriticalSection

; 513  :         return 0;

  002c4	e3a06000	 mov         r6, #0
  002c8		 |$LN34@AllocUsb2B|

; 567  : }

  002c8	e1a00006	 mov         r0, r6
  002cc	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  002d0	e12fff1e	 bx          lr
  002d4		 |$LN64@AllocUsb2B|
  002d4		 |$LN65@AllocUsb2B|
  002d4	ae4c415d	 DCD         0xae4c415d
  002d8		 |$M33205|

			 ENDP  ; |?AllocUsb2BusTime@USB2lib@@QAAHEEHPAU_EndpointBuget@@@Z|, USB2lib::AllocUsb2BusTime

	EXPORT	|?FreeUsb2BusTime@USB2lib@@QAAXEEHPAU_EndpointBuget@@@Z| ; USB2lib::FreeUsb2BusTime
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\usb2com\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T33231| DCD	|$LN20@FreeUsb2Bu|
	DCD	0x40003001
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\omap3530\musb\musbhcd\musbmhdrc\usb2lib.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FreeUsb2BusTime@USB2lib@@QAAXEEHPAU_EndpointBuget@@@Z| PROC ; USB2lib::FreeUsb2BusTime

; 570  : {

  00000		 |$LN20@FreeUsb2Bu|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M33228|
  00004	e1a06003	 mov         r6, r3
  00008	e1a07002	 mov         r7, r2
  0000c	e1a08001	 mov         r8, r1
  00010	e1a05000	 mov         r5, r0

; 571  :     Lock();

  00014	eb000000	 bl          EnterCriticalSection

; 572  :     if (ep && ep->calc_bus_time!=0){

  00018	e59d4018	 ldr         r4, [sp, #0x18]
  0001c	e3540000	 cmp         r4, #0
  00020	0a000022	 beq         |$LN1@FreeUsb2Bu|
  00024	e1d4e0bc	 ldrh        lr, [r4, #0xC]
  00028	e35e0000	 cmp         lr, #0
  0002c	0a00001f	 beq         |$LN1@FreeUsb2Bu|

; 573  :     // handle nonsplit HS allocation
; 574  :         if (ep->speed == HSSPEED) {

  00030	e5d4e00a	 ldrb        lr, [r4, #0xA]
  00034	e35e0002	 cmp         lr, #2
  00038	1a000014	 bne         |$LN8@FreeUsb2Bu|

; 575  :             for (DWORD i = (ep->start_frame*MICROFRAMES_PER_FRAME) + ep->start_microframe;

  0003c	e5d42012	 ldrb        r2, [r4, #0x12]
  00040	e1d431d3	 ldrsb       r3, [r4, #0x13]
  00044	e0831182	 add         r1, r3, r2, lsl #3

; 576  :                    i < MAXFRAMES*MICROFRAMES_PER_FRAME;
; 577  :                    i += ep->actual_period){

  00048	e3510c01	 cmp         r1, #1, 24
  0004c	2a000017	 bcs         |$LN1@FreeUsb2Bu|
  00050	e3a0e000	 mov         lr, #0
  00054		 |$LL7@FreeUsb2Bu|

; 578  :                 if (HS_microframe_info[i/MICROFRAMES_PER_FRAME][i % MICROFRAMES_PER_FRAME].time_used >= ep->calc_bus_time)

  00054	e1a021a1	 mov         r2, r1, lsr #3
  00058	e2013007	 and         r3, r1, #7
  0005c	e0833182	 add         r3, r3, r2, lsl #3
  00060	e0852103	 add         r2, r5, r3, lsl #2
  00064	e5923024	 ldr         r3, [r2, #0x24]
  00068	e1d400bc	 ldrh        r0, [r4, #0xC]
  0006c	e1530000	 cmp         r3, r0

; 579  :                     HS_microframe_info[i/MICROFRAMES_PER_FRAME][i % MICROFRAMES_PER_FRAME].time_used -= ep->calc_bus_time;

  00070	20433000	 subcs       r3, r3, r0
  00074	25823024	 strcs       r3, [r2, #0x24]

; 580  :                 else {
; 581  :                     ASSERT(FALSE);
; 582  :                     HS_microframe_info[i/MICROFRAMES_PER_FRAME][i % MICROFRAMES_PER_FRAME].time_used =0;

  00078	3582e024	 strcc       lr, [r2, #0x24]
  0007c	e1d431b0	 ldrh        r3, [r4, #0x10]
  00080	e0811003	 add         r1, r1, r3
  00084	e3510c01	 cmp         r1, #1, 24
  00088	3afffff1	 bcc         |$LL7@FreeUsb2Bu|

; 583  :                 }
; 584  :             }
; 585  :         }
; 586  :         else {

  0008c	ea000007	 b           |$LN1@FreeUsb2Bu|
  00090		 |$LN8@FreeUsb2Bu|

; 587  :             TransactionTrasnlate * pTT=GetTT( uHubAddress,uHubPort,ttContext);

  00090	e1a03006	 mov         r3, r6
  00094	e1a02007	 mov         r2, r7
  00098	e1a01008	 mov         r1, r8
  0009c	e1a00005	 mov         r0, r5
  000a0	eb000000	 bl          |?GetTT@USB2lib@@QAAPAVTransactionTrasnlate@@EEH@Z|
  000a4	e3500000	 cmp         r0, #0

; 588  :             if (pTT!=NULL)
; 589  :                 pTT->DeletedEp(ep);

  000a8	11a01004	 movne       r1, r4
  000ac	1b000000	 blne        |?DeletedEp@TransactionTrasnlate@@QAAHPAU_EndpointBuget@@@Z|
  000b0		 |$LN1@FreeUsb2Bu|

; 590  :         }
; 591  :      }
; 592  :     Unlock();

  000b0	e1a00005	 mov         r0, r5
  000b4	eb000000	 bl          LeaveCriticalSection

; 593  : }

  000b8	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000bc	e12fff1e	 bx          lr
  000c0		 |$M33229|

			 ENDP  ; |?FreeUsb2BusTime@USB2lib@@QAAXEEHPAU_EndpointBuget@@@Z|, USB2lib::FreeUsb2BusTime

	EXPORT	|?GetSMASK@USB2lib@@QAAEPAU_EndpointBuget@@@Z| ; USB2lib::GetSMASK

  00000			 AREA	 |.pdata|, PDATA
|$T33246| DCD	|$LN12@GetSMASK|
	DCD	0x40002002
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetSMASK@USB2lib@@QAAEPAU_EndpointBuget@@@Z| PROC ; USB2lib::GetSMASK

; 597  : {

  00000		 |$LN12@GetSMASK|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M33243|
  00008	e1a05001	 mov         r5, r1

; 598  :     UCHAR       tmp = 0;
; 599  : 
; 600  : 
; 601  :     if(Ep->speed == HSSPEED) {

  0000c	e5d5300a	 ldrb        r3, [r5, #0xA]
  00010	e3a04000	 mov         r4, #0
  00014	e3530002	 cmp         r3, #2

; 602  : //DBGPRINT(("in GetSMASK StartUFrame on High Speed Endpoint = 0x%x\n", Ep->start_microframe));
; 603  :         tmp |= 1 << Ep->start_microframe;

  00018	01d531d3	 ldreqsb     r3, [r5, #0x13]
  0001c	03a02001	 moveq       r2, #1
  00020	01a03312	 moveq       r3, r2, lsl r3
  00024	020340ff	 andeq       r4, r3, #0xFF
  00028	0a000010	 beq         |$LN1@GetSMASK|

; 604  :     } else {
; 605  :         ULONG       ilop;
; 606  :         UCHAR       HFrame;         // H (Host) frame for endpoint
; 607  :         UCHAR       HUFrame;        // H (Host) micro frame for endpoint
; 608  :         // For Full and Low Speed Endpoints 
; 609  :         // the budgeter returns a bframe. Convert to HUFrame to get SMASK
; 610  :         ConvertBtoHFrame((UCHAR)Ep->start_frame, (UCHAR)Ep->start_microframe, &HFrame, &HUFrame);

  0002c	e5d52013	 ldrb        r2, [r5, #0x13]
  00030	e5d51012	 ldrb        r1, [r5, #0x12]
  00034	e28de004	 add         lr, sp, #4
  00038	e28d3005	 add         r3, sp, #5
  0003c	e58de000	 str         lr, [sp]
  00040	eb000000	 bl          |?ConvertBtoHFrame@USB2lib@@AAAXEEPAE0@Z|

; 611  : 
; 612  :         for(ilop = 0; ilop < Ep->num_starts; ilop++) {

  00044	e5d53014	 ldrb        r3, [r5, #0x14]
  00048	e1b01003	 movs        r1, r3
  0004c	0a000007	 beq         |$LN1@GetSMASK|
  00050	e5dd2004	 ldrb        r2, [sp, #4]
  00054	e3a00001	 mov         r0, #1
  00058		 |$LL3@GetSMASK|

; 613  :             tmp |= 1 << HUFrame++;

  00058	e1843210	 orr         r3, r4, r0, lsl r2
  0005c	e2822001	 add         r2, r2, #1
  00060	e20340ff	 and         r4, r3, #0xFF
  00064	e20220ff	 and         r2, r2, #0xFF
  00068	e2511001	 subs        r1, r1, #1
  0006c	1afffff9	 bne         |$LL3@GetSMASK|
  00070		 |$LN1@GetSMASK|

; 614  :         }
; 615  :     }
; 616  : 
; 617  :     return tmp;
; 618  : };

  00070	e1a00004	 mov         r0, r4
  00074	e28dd008	 add         sp, sp, #8
  00078	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$M33244|

			 ENDP  ; |?GetSMASK@USB2lib@@QAAEPAU_EndpointBuget@@@Z|, USB2lib::GetSMASK

	EXPORT	|?GetCMASK@USB2lib@@QAAEPAU_EndpointBuget@@@Z| ; USB2lib::GetCMASK

  00000			 AREA	 |.pdata|, PDATA
|$T33267| DCD	|$LN22@GetCMASK|
	DCD	0x40003d02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetCMASK@USB2lib@@QAAEPAU_EndpointBuget@@@Z| PROC ; USB2lib::GetCMASK

; 633  : {

  00000		 |$LN22@GetCMASK|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M33264|
  00008	e1a05001	 mov         r5, r1

; 634  : 
; 635  :     if(Ep->speed == HSSPEED) {

  0000c	e5d5300a	 ldrb        r3, [r5, #0xA]
  00010	e3530002	 cmp         r3, #2
  00014	1a000001	 bne         |$LN11@GetCMASK|
  00018		 |$LN19@GetCMASK|

; 636  :         return 0;

  00018	e3a04000	 mov         r4, #0
  0001c	ea00002f	 b           |$LN1@GetCMASK|
  00020		 |$LN11@GetCMASK|

; 637  :     } else if(Ep->ep_type == interrupt) {

  00020	e5953004	 ldr         r3, [r5, #4]
  00024	e3530002	 cmp         r3, #2
  00028	1a000009	 bne         |$LN9@GetCMASK|

; 638  :         UCHAR       HFrame;         // H (Host) frame for endpoint
; 639  :         UCHAR       HUFrame;        // H (Host) micro frame for endpoint
; 640  : 
; 641  :         ConvertBtoHFrame((UCHAR)Ep->start_frame, (UCHAR)Ep->start_microframe, 
; 642  :             &HFrame, &HUFrame);

  0002c	e5d52013	 ldrb        r2, [r5, #0x13]
  00030	e5d51012	 ldrb        r1, [r5, #0x12]
  00034	e28de004	 add         lr, sp, #4
  00038	e28d3005	 add         r3, sp, #5
  0003c	e58de000	 str         lr, [sp]
  00040	eb000000	 bl          |?ConvertBtoHFrame@USB2lib@@AAAXEEPAE0@Z|

; 643  : 
; 644  :         return CMASKS[HUFrame];

  00044	e59f20a4	 ldr         r2, [pc, #0xA4]
  00048	e5dd3004	 ldrb        r3, [sp, #4]
  0004c	e7d34002	 ldrb        r4, [r3, +r2]
  00050	ea000022	 b           |$LN1@GetCMASK|
  00054		 |$LN9@GetCMASK|

; 645  :     } else {
; 646  :         // Split ISO!
; 647  :         UCHAR       HFrame;         // H (Host) frame for endpoint
; 648  :         UCHAR       HUFrame;        // H (Host) micro frame for endpoint
; 649  :         UCHAR       tmp = 0;
; 650  :         ULONG       NumCompletes;
; 651  : 
; 652  :         if(Ep->direction == OUTDIR) {

  00054	e5d53009	 ldrb        r3, [r5, #9]
  00058	e3a04000	 mov         r4, #0
  0005c	e3530001	 cmp         r3, #1

; 653  :             // Split iso out -- NO complete splits
; 654  :             return 0;

  00060	0affffec	 beq         |$LN19@GetCMASK|

; 655  :         }
; 656  :         ConvertBtoHFrame((UCHAR)Ep->start_frame, (UCHAR)Ep->start_microframe, 
; 657  :             &HFrame, &HUFrame);

  00064	e5d52013	 ldrb        r2, [r5, #0x13]
  00068	e5d51012	 ldrb        r1, [r5, #0x12]
  0006c	e28de004	 add         lr, sp, #4
  00070	e28d3005	 add         r3, sp, #5
  00074	e58de000	 str         lr, [sp]
  00078	eb000000	 bl          |?ConvertBtoHFrame@USB2lib@@AAAXEEPAE0@Z|

; 658  : 
; 659  :         HUFrame += 2;  

  0007c	e5dd3004	 ldrb        r3, [sp, #4]

; 660  :         NumCompletes = Ep->num_completes;
; 661  : 
; 662  :         //      ASSERT(NumCompletes > 0);
; 663  : 
; 664  :         //
; 665  :         //  Set all CMASKS bits to be set at the end of the frame
; 666  :         // 
; 667  :         for(;  HUFrame < 8; HUFrame++) {

  00080	e5d52015	 ldrb        r2, [r5, #0x15]
  00084	e2833002	 add         r3, r3, #2
  00088	e20330ff	 and         r3, r3, #0xFF
  0008c	e1a01003	 mov         r1, r3
  00090	e3530008	 cmp         r3, #8
  00094	2a000009	 bcs         |$LN15@GetCMASK|
  00098	e3a00001	 mov         r0, #1
  0009c		 |$LL6@GetCMASK|

; 668  :             tmp |= 1 <<  HUFrame;

  0009c	e1843310	 orr         r3, r4, r0, lsl r3

; 669  :             NumCompletes--; 

  000a0	e2522001	 subs        r2, r2, #1
  000a4	e20340ff	 and         r4, r3, #0xFF

; 670  :             if(!NumCompletes){

  000a8	0a00000c	 beq         |$LN1@GetCMASK|
  000ac	e2813001	 add         r3, r1, #1
  000b0	e20330ff	 and         r3, r3, #0xFF
  000b4	e1a01003	 mov         r1, r3
  000b8	e3530008	 cmp         r3, #8
  000bc	3afffff6	 bcc         |$LL6@GetCMASK|
  000c0		 |$LN15@GetCMASK|

; 671  :                 break;
; 672  :             }
; 673  :         }
; 674  : 
; 675  :         //
; 676  :         // Now set all CMASKS bits to be set at the end of the 
; 677  :         // frame I.E. for the next frame wrap condition
; 678  :         // 
; 679  :         while(NumCompletes) {

  000c0	e3520000	 cmp         r2, #0
  000c4	0a000005	 beq         |$LN1@GetCMASK|
  000c8	e2431008	 sub         r1, r3, #8
  000cc	e3a00001	 mov         r0, #1
  000d0		 |$LL2@GetCMASK|

; 680  :             tmp |= 1 << (HUFrame - 8); 

  000d0	e1843110	 orr         r3, r4, r0, lsl r1

; 681  :             NumCompletes--;

  000d4	e2522001	 subs        r2, r2, #1
  000d8	e20340ff	 and         r4, r3, #0xFF
  000dc	1afffffb	 bne         |$LL2@GetCMASK|
  000e0		 |$LN1@GetCMASK|

; 682  :         }
; 683  : 
; 684  : //DBGPRINT(("in GetCMASK HFRAME = 0x%x HUFRAME 0x%x\n", HFrame, HUFrame));
; 685  :         return tmp;
; 686  :     }
; 687  : }

  000e0	e1a00004	 mov         r0, r4
  000e4	e28dd008	 add         sp, sp, #8
  000e8	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000ec	e12fff1e	 bx          lr
  000f0		 |$LN23@GetCMASK|
  000f0		 |$LN24@GetCMASK|
  000f0	00000000	 DCD         |?CMASKS@USB2lib@@0PAEA|
  000f4		 |$M33265|

			 ENDP  ; |?GetCMASK@USB2lib@@QAAEPAU_EndpointBuget@@@Z|, USB2lib::GetCMASK

	END
