ARM macroassembler      Page:1 
    1 00000000          ;/* 
    2 00000000          ;=============================================================================== 
    3 00000000          ;*             Texas Instruments OMAP(TM) Platform Software 
    4 00000000          ;* (c) Copyright Texas Instruments, Incorporated. All Rights Reserved. 
    5 00000000          ;* 
    6 00000000          ;* Use of this software is controlled by the terms and conditions found 
    7 00000000          ;* in the license agreement under which this software has been supplied. 
    8 00000000          ;* 
    9 00000000          ;=============================================================================== 
   10 00000000          ;*/ 
   11 00000000          ; 
   12 00000000          ;  File:  cpu.s 
   13 00000000            
   14 00000000                  INCLUDE kxarm.h 
    1 00000000          ; 
    2 00000000          ; Copyright (c) Microsoft Corporation.  All rights reserved. 
    3 00000000          ; 
    4 00000000          ; 
    5 00000000          ; Use of this sample source code is subject to the terms of the Microsoft 
    6 00000000          ; license agreement under which you licensed this sample source code. If 
    7 00000000          ; you did not accept the terms of the license agreement, you are not 
    8 00000000          ; authorized to use this sample source code. For the terms of the license, 
    9 00000000          ; please see the license agreement between you and Microsoft or, if applicable, 
   10 00000000          ; see the LICENSE.RTF on your install media or the root of your tools installation. 
   11 00000000          ; THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES. 
   12 00000000          ; 
   13 00000000          ;++ 
   14 00000000          ; 
   15 00000000          ; 
   16 00000000          ; Module Name: 
   17 00000000          ; 
   18 00000000          ;    kxarm.h 
   19 00000000          ; 
   20 00000000          ; Abstract: 
   21 00000000          ; 
   22 00000000          ;    This is an implementation of the WINCE/ARM Calling Sequence 
   23 00000000          ;    Specification. 
   24 00000000          ; 
   25 00000000          ; Environment: 
   26 00000000          ;    String Library 
   27 00000000          ; 
   28 00000000          ; Revision History: 
   29 00000000          ;-- 
   30 00000000            
   31 00000000                          GBLS    VBar 
   32 00000000          VBar    SETS    "|" 
   33 00000000                          GBLL    HaveExceptHandler 
   34 00000000                          GBLS    AreaName 
   35 00000000                          GBLS    FuncName 
   36 00000000                          GBLS    PrologName 
   37 00000000                          GBLS    FuncEndName 
   38 00000000                          GBLS    ExceptHandler 
   39 00000000                          GBLS    ExceptData 
   40 00000000          AreaName SETS   "|.text|" 
   41 00000000          HaveExceptHandler SETL {FALSE} 
   42 00000000            
   43 00000000                  MACRO 
   44 00000000                  TEXTAREA 
   45 00000000                  AREA |.text|,ALIGN=2,CODE,READONLY 
   46 00000000          AreaName SETS "|.text|" 
   47 00000000                  MEND 
   48 00000000            
   49 00000000              MACRO 
   50 00000000              THUMBAREA 
   51 00000000              AREA |.text|,ALIGN=2,CODE,READONLY,THUMB 
   52 00000000          AreaName SETS "|.text|" 
   53 00000000              MEND 
   54 00000000            
   55 00000000                  MACRO 
   56 00000000                  STARTUPTEXT 
   57 00000000                  AREA |.astart|,ALIGN=2,CODE 
   58 00000000          AreaName SETS "|.astart|" 
   59 00000000                  MEND 
   60 00000000            
   61 00000000                  MACRO 
   62 00000000                  START_REGION    $NameBegin 
   63 00000000                  LCLS    TempName 
   64 00000000          TempName SETS    VBar:CC:"$NameBegin":CC:VBar 
   65 00000000                  EXPORT  $TempName[DATA] 
   66 00000000          $TempName 
   67 00000000                  MEND 
   68 00000000            
   69 00000000                  MACRO 
   70 00000000                  END_REGION              $NameEnd 
   71 00000000                  LCLS    TempName 
   72 00000000          TempName SETS    VBar:CC:"$NameEnd":CC:VBar 
   73 00000000                  EXPORT  $TempName[DATA] 
   74 00000000          $TempName 
   75 00000000                  MEND 
   76 00000000            
   77 00000000          ; 
   78 00000000          ;   This macro should be used if the assembly function is in ARM 
   79 00000000          ; 
   80 00000000            
   81 00000000                  MACRO 
   82 00000000                  NESTED_ARMENTRY $Name 
   83 00000000          FuncName    SETS    VBar:CC:"$Name":CC:VBar 
   84 00000000          PrologName  SETS    VBar:CC:"$Name":CC:"_Prolog":CC:VBar 
   85 00000000          FuncEndName SETS    VBar:CC:"$Name":CC:"_end":CC:VBar 
   86 00000000                  LCLS    ExceptBit 
   87 00000000                  IF HaveExceptHandler 
   88 00000000          ExceptBit   SETS        "0x80000000" 
   89 00000000                  ELSE 
   90 00000000          ExceptBit   SETS        "0" 
   91 00000000                  ENDIF 
   92 00000000            
   93 00000000                  AREA |.pdata|,ALIGN=2,PDATA 
   94 00000000                  DCD         $FuncName 
   95 00000000              DCD     (($PrologName-$FuncName)/4) :OR: ((($FuncEndName-$FuncName)/4):SHL:8) :OR: 0x40000000 :OR: $ExceptBit 
   96 00000000                  AREA $AreaName,CODE,READONLY 
   97 00000000                  ALIGN   2 
   98 00000000                  EXPORT  $FuncName [FUNC] 
   99 00000000                  IF HaveExceptHandler 
  100 00000000              DCD $ExceptHandler 
  101 00000000              DCD $ExceptData 
  102 00000000          HaveExceptHandler SETL {FALSE} 
  103 00000000                  ENDIF 
  104 00000000          $FuncName 
  105 00000000                  ROUT 
  106 00000000                  MEND 
  107 00000000            
  108 00000000          ; 
  109 00000000          ;   This macro should be used if the assembly function is in THUMB 
  110 00000000          ; 
  111 00000000                  MACRO 
  112 00000000                  NESTED_THUMBENTRY       $Name 
  113 00000000          FuncName    SETS    VBar:CC:"$Name":CC:VBar 
  114 00000000          PrologName  SETS    VBar:CC:"$Name":CC:"_Prolog":CC:VBar 
  115 00000000          FuncEndName SETS    VBar:CC:"$Name":CC:"_end":CC:VBar 
  116 00000000                  LCLS    ExceptBit 
  117 00000000                  IF HaveExceptHandler 
  118 00000000          ExceptBit   SETS        "0x80000000" 
  119 00000000                  ELSE 
  120 00000000          ExceptBit   SETS        "0" 
  121 00000000                  ENDIF 
  122 00000000            
  123 00000000                  AREA |.pdata|,ALIGN=2,PDATA 
  124 00000000                  DCD         $FuncName 
  125 00000000              DCD     (($PrologName-$FuncName)/2) :OR: ((($FuncEndName-$FuncName)/2):SHL:8) :OR: $ExceptBit 
  126 00000000                  AREA $AreaName,CODE,READONLY 
  127 00000000                  ALIGN   2 
  128 00000000                  EXPORT  $FuncName [FUNC] 
  129 00000000                  IF HaveExceptHandler 
  130 00000000              DCD $ExceptHandler 
  131 00000000              DCD $ExceptData 
  132 00000000          HaveExceptHandler SETL {FALSE} 
  133 00000000                  ENDIF 
  134 00000000          $FuncName 
  135 00000000                  ROUT 
  136 00000000                  MEND 
  137 00000000            
  138 00000000          ; 
  139 00000000          ;   This macro should be used if the assembly function is in ARM 
  140 00000000          ; 
  141 00000000                  MACRO 
  142 00000000                  NESTED_ENTRY    $Name 
  143 00000000          FuncName    SETS    VBar:CC:"$Name":CC:VBar 
  144 00000000          PrologName  SETS    VBar:CC:"$Name":CC:"_Prolog":CC:VBar 
  145 00000000          FuncEndName SETS    VBar:CC:"$Name":CC:"_end":CC:VBar 
  146 00000000                  LCLS    ExceptBit 
  147 00000000                  IF HaveExceptHandler 
  148 00000000          ExceptBit   SETS        "0x80000000" 
  149 00000000                  ELSE 
  150 00000000          ExceptBit   SETS        "0" 
  151 00000000                  ENDIF 
  152 00000000            
  153 00000000                  AREA |.pdata|,ALIGN=2,PDATA 
  154 00000000                  DCD         $FuncName 
  155 00000000              DCD     (($PrologName-$FuncName)/4) :OR: ((($FuncEndName-$FuncName)/4):SHL:8) :OR: 0x40000000 :OR: $ExceptBit 
  156 00000000                  AREA $AreaName,CODE,READONLY 
  157 00000000                  ALIGN   2 
  158 00000000                  EXPORT  $FuncName [FUNC] 
  159 00000000                  IF HaveExceptHandler 
  160 00000000              DCD $ExceptHandler 
  161 00000000              DCD $ExceptData 
  162 00000000          HaveExceptHandler SETL {FALSE} 
  163 00000000                  ENDIF 
  164 00000000          $FuncName 
  165 00000000                  ROUT 
  166 00000000                  MEND 
  167 00000000            
  168 00000000                  MACRO 
  169 00000000                  PROLOG_END 
  170 00000000          $PrologName 
  171 00000000                  MEND 
  172 00000000            
  173 00000000                  MACRO 
  174 00000000                  LEAF_ENTRY      $Name 
  175 00000000          FuncName SETS    VBar:CC:"$Name":CC:VBar 
  176 00000000          PrologName SETS "Invalid Prolog" 
  177 00000000          FuncEndName SETS    VBar:CC:"$Name":CC:"_end":CC:VBar 
  178 00000000                  ALIGN   2 
  179 00000000                  EXPORT  $FuncName [FUNC] 
  180 00000000          $FuncName 
  181 00000000                  ROUT 
  182 00000000                  MEND 
  183 00000000            
  184 00000000                  MACRO 
  185 00000000                  ALTERNATE_ENTRY $Name 
  186 00000000                  LCLS    TempName 
  187 00000000          TempName SETS    VBar:CC:"$Name":CC:VBar 
  188 00000000                  EXPORT  $TempName [FUNC] 
  189 00000000          $TempName 
  190 00000000                  MEND 
  191 00000000            
  192 00000000                  MACRO 
  193 00000000                  ENTRY_END       $Name 
  194 00000000          $FuncEndName 
  195 00000000                  MEND 
  196 00000000            
  197 00000000                  MACRO 
  198 00000000                  EXCEPTION_HANDLER       $Handler 
  199 00000000          ExceptHandler SETS    VBar:CC:"$Handler":CC:VBar 
  200 00000000          ExceptData SETS "0" 
  201 00000000          HaveExceptHandler SETL {TRUE} 
  202 00000000                  MEND 
  203 00000000            
  204 00000000                  MACRO 
  205 00000000                  EXCEPTION_HANDLER_DATA  $Handler, $HandlerData 
  206 00000000          ExceptHandler SETS    VBar:CC:"$Handler":CC:VBar 
  207 00000000          ExceptData SETS    VBar:CC:"$HandlerData":CC:VBar 
  208 00000000          HaveExceptHandler SETL {TRUE} 
  209 00000000                  MEND 
  210 00000000            
  211 00000000                  MACRO 
  212 00000000                  EXCEPTION_HANDLER_MILLICODE     $Handler, $HandlerData 
  213 00000000          ExceptHandler SETS    "$Handler" 
  214 00000000          ExceptData SETS    "$HandlerData" 
  215 00000000          HaveExceptHandler SETL {TRUE} 
  216 00000000                  MEND 
  217 00000000            
  218 00000000            
  219 00000000                  END 
   15 00000000                  INCLUDE armmacros.s 
    1 00000000          ; 
    2 00000000          ; Copyright (c) Microsoft Corporation.  All rights reserved. 
    3 00000000          ; 
    4 00000000          ; 
    5 00000000          ; Use of this sample source code is subject to the terms of the Microsoft 
    6 00000000          ; license agreement under which you licensed this sample source code. If 
    7 00000000          ; you did not accept the terms of the license agreement, you are not 
    8 00000000          ; authorized to use this sample source code. For the terms of the license, 
    9 00000000          ; please see the license agreement between you and Microsoft or, if applicable, 
   10 00000000          ; see the LICENSE.RTF on your install media or the root of your tools installation. 
   11 00000000          ; THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES. 
   12 00000000          ; 
   13 00000000            
   14 00000000          ;/*********************************************************************** 
   15 00000000          ;  Copyright (c) ARM Limited 1998.  All rights reserved. 
   16 00000000          ; 
   17 00000000          ; NOTE: The CALL and CALLEQ macros shouldn't be used in OS startup code 
   18 00000000          ;       before the MMU is enabled since in the Thumbing case it relies 
   19 00000000          ;       on an absolute address which will be virtual in the case of the 
   20 00000000          ;       OS code and if the MMU isn't enabled, all branches should be 
   21 00000000          ;       relative (or a computed physical address). 
   22 00000000          ; 
   23 00000000          ;***********************************************************************/ 
   24 00000000            
   25 00000000            IF Interworking :LOR: Thumbing 
   26 00000000            
   27 00000000              MACRO 
   28 00000000              CALL $Fn 
   29 00000000              ldr     r12, =$Fn 
   30 00000000              mov     lr, pc 
   31 00000000              bx      r12 
   32 00000000              MEND 
   33 00000000            
   34 00000000              MACRO 
   35 00000000              CALLEQ $Fn 
   36 00000000              ldreq   r12, =$Fn 
   37 00000000              moveq   lr, pc 
   38 00000000              bxeq    r12 
   39 00000000              MEND 
   40 00000000            
   41 00000000              MACRO 
   42 00000000              RETURN 
   43 00000000              bx      lr 
   44 00000000              MEND 
   45 00000000            
   46 00000000              MACRO 
   47 00000000              RETURN_EQ 
   48 00000000              bxeq    lr 
   49 00000000              MEND 
   50 00000000            
   51 00000000              MACRO 
   52 00000000              RETURN_NE 
   53 00000000              bxne    lr 
   54 00000000              MEND 
   55 00000000            
   56 00000000            ELSE 
   83 00000000            ENDIF 
   84 00000000            
   85 00000000              END  
   16 00000000                  INCLUDE omap3530_const.inc 
    1 00000000          ; All rights reserved ADENEO EMBEDDED 2010 
    2 00000000          ; 
    3 00000000          ;============================================================================== 
    4 00000000          ;             Texas Instruments OMAP(TM) Platform Software 
    5 00000000          ; (c) Copyright Texas Instruments, Incorporated. All Rights Reserved. 
    6 00000000          ; 
    7 00000000          ; Use of this software is controlled by the terms and conditions found 
    8 00000000          ; in the license agreement under which this software has been supplied. 
    9 00000000          ; 
   10 00000000          ;============================================================================== 
   11 00000000          ; 
   12 00000000          ; 
   13 00000000          ;  File: omap35xx_const.inc 
   14 00000000          ; 
   15 00000000            
   16 00000000          ;------------------------------------------------------------------------------ 
   17 00000000          ; Physical Address of Registers 
   18 00000000          OMAP_CONTEXT_RESTORE_REGS_PA    EQU 0x48002910 
   19 00000000          OMAP_SDRC_REGS_PA               EQU 0x6D000000 
   20 00000000            
   21 00000000          ;------------------------------------------------------------------------------ 
   22 00000000          ; Useful constants 
   23 00000000          WFI                             EQU 0xE320F003 
   24 00000000          SMI                             EQU 0xE1600070 
   25 00000000          SMI_INVAL_L2                    EQU 0x0001 
   26 00000000            
   27 00000000          ;------------------------------------------------------------------------------ 
   28 00000000          ; following offset must be kept in sync with the CPUIDLE_INFO data structure 
   29 00000000          ; defined in oal_prcm.h 
   30 00000000            
   31 00000000          SDRC_REGS_OFFSET                EQU 0x0000 
   32 00000000          MPU_CM_REGS_OFFSET              EQU 0x0004 
   33 00000000          CORE_CM_REGS_OFFSET             EQU 0x0008 
   34 00000000          CLOCK_CTRL_CM_REGS_OFFSET       EQU 0x000C 
   35 00000000          GPTIMER_REGS_OFFSET             EQU 0x0010 
   36 00000000          MPU_PRM_REGS_OFFSET             EQU 0x0014 
   37 00000000          CORE_PRM_REGS_OFFSET            EQU 0x0018 
   38 00000000          GLOBAL_PRM_REGS_OFFSET                  EQU     0x001C 
   39 00000000          MPU_CONTEXT_PA_OFFSET           EQU 0x0020 
   40 00000000          MPU_CONTEXT_VA_OFFSET           EQU 0x0024 
   41 00000000          SDRC_HIGH_RFR_FREQ_OFFSET       EQU 0x0028 
   42 00000000          SDRC_LOW_RFR_FREQ_OFFSET        EQU 0x002C 
   43 00000000          TLB_INV_FUNC_ADDR_OFFSET        EQU 0x0030 
   44 00000000            
   45 00000000          ;------------------------------------------------------------------------------ 
   46 00000000            
   47 00000000          SDRC_SYSCONFIG_OA               EQU 0x0010 
   48 00000000          SDRC_MR_0_OA                    EQU 0x0084 
   49 00000000          SDRC_MR_1_OA                    EQU 0x00B4 
   50 00000000            
   51 00000000          SDRC_EMR2_0_OA                  EQU 0x008C 
   52 00000000          SDRC_EMR2_1_OA                  EQU 0x00BC 
   53 00000000            
   54 00000000          SDRC_MANUAL_0_OA                EQU 0x00A8 
   55 00000000          SDRC_MANUAL_1_OA                EQU 0x00D8 
   56 00000000            
   57 00000000          SDRC_POWER_OA                   EQU 0x0070  ; enable/disable SDRAM self-refresh 
   58 00000000          SDRC_DLLA_CTRL_OA               EQU 0x0060 
   59 00000000          SDRC_DLLA_STATUS_OA             EQU 0x0064 
   60 00000000          SDRC_RFR_CTRL_0_OA              EQU 0x00A4 
   61 00000000          SDRC_RFR_CTRL_1_OA              EQU 0x00D4 
   62 00000000            
   63 00000000          SDRC_MANUAL_AUTOREFRESH_CMD     EQU 0x0002 
   64 00000000            
   65 00000000          SDRC_POWER_CLKCTRL_MASK         EQU 0x0003 
   66 00000000            
   67 00000000          SDRC_SYSCONFIG_MRS_BIT          EQU 0x0100 
   68 00000000            
   69 00000000          SDRC_DLL_DLLIDLE_BIT            EQU 0x0004 
   70 00000000          SDRC_DLL_ENADLL_BIT             EQU 0x0003 
   71 00000000          SDRC_DLL_LOCKDLL_BIT            EQU 0x0002 
   72 00000000          SDRC_DLL_DLLPHASE_BIT           EQU 0x0001 
   73 00000000          SDRC_DLL_TIMING_WAIT_COUNT      EQU 0x0800 
   74 00000000            
   75 00000000          SDRC_DLLA_STATUS_UNLOCKED       EQU 0x0000 
   76 00000000          SDRC_DLLA_STATUS_LOCKED         EQU 0x0004 
   77 00000000            
   78 00000000          SDRC_RFR_CTRL0_ARE_SHIFT        EQU 0x0000 
   79 00000000          SDRC_RFR_CTRL0_ARCV_SHIFT       EQU 0x0008 
   80 00000000            
   81 00000000          SDRC_ENABLE_ICLK                EQU 0x0001 
   82 00000000          SDRC_DISABLE_ICLK               EQU 0x0000 
   83 00000000            
   84 00000000          SDRAM_REFRESH_DELAY_VAL         EQU 0x1000  ; time to wait for autorefresh 
   85 00000000            
   86 00000000          ;------------------------------------------------------------------------------ 
   87 00000000          CM_CLKEN_PLL_OA                 EQU 0x0000 
   88 00000000          CM_IDLEST_CKGEN_OA              EQU 0x0020 
   89 00000000          CM_IDLEST_PLL_MPU_OA            EQU 0x0024 
   90 00000000          CM_CLKSEL1_PLL_OA               EQU 0x0040 
   91 00000000            
   92 00000000          CM_IDLEST_ST_MPU_CLK_BIT        EQU 0x0001 
   93 00000000            
   94 00000000          CM_CLKSEL1_PLL_M2_SHIFT         EQU 0x001B 
   95 00000000            
   96 00000000          CM_CLKEN_PLL_DPLL_LOWBYPASS     EQU 0x0005 
   97 00000000          CM_CLKEN_PLL_DPLL_HIGHBYPASS    EQU 0x0006 
   98 00000000          CM_CLKEN_PLL_DPLL_LOCKED        EQU 0x0007 
   99 00000000          CM_CLKEN_PLL_DPLL_MASK          EQU 0x0007 
  100 00000000            
  101 00000000          DVFS_LOW_OPP_STALL              EQU 0x0000 
  102 00000000          DVFS_HIGH_OPP_STALL             EQU 0x0010 ;0x00C8 
  103 00000000            
  104 00000000          ;------------------------------------------------------------------------------ 
  105 00000000          CM_CLKSTST_CORE_OA              EQU 0x004C 
  106 00000000          CM_ICLKEN1_CORE_OA              EQU 0x0010 
  107 00000000          CM_IDLEST1_CORE_OA              EQU 0x0020 
  108 00000000            
  109 00000000          CM_CLKSTST_CLKACTIVITY_L3_BIT   EQU 0x0001 
  110 00000000          CM_ICLKEN1_CORE_SDRC_BIT        EQU 0x0001 
  111 00000000            
  112 00000000          ;------------------------------------------------------------------------------ 
  113 00000000          PRM_PWRSTCTRL_MPU_OA            EQU 0x00E0 
  114 00000000            
  115 00000000          ;------------------------------------------------------------------------------ 
  116 00000000          PRM_RSTCTRL_GLOBAL_OA                   EQU 0x0050 
  117 00000000          PRM_RSTCTRL_RST_GS_BIT                  EQU     0x0002 
  118 00000000            
  119 00000000          ;------------------------------------------------------------------------------ 
  120 00000000          PRM_LOGICL1CACHERETSTATE_VAL    EQU 0x0004 
  121 00000000          PRM_POWERSTATE_MASK             EQU 0x0003 
  122 00000000          PRM_POWERSTATE_OFF_VAL          EQU 0x0000 
  123 00000000          PRM_POWERSTATE_RET_VAL          EQU 0x0001 
  124 00000000          PRM_POWERSTATE_ON_VAL           EQU 0x0003 
  125 00000000            
  126 00000000          ;------------------------------------------------------------------------------ 
  127 00000000          TIMER_TCRR_OA                   EQU 0x0028  ; tcrr offset for gptimer1 
  128 00000000            
  129 00000000          ;------------------------------------------------------------------------------ 
  130 00000000          ; location of restore register and offsets to the various fields. 
  131 00000000          ; Must be kept in sync with OMAP_CONTEXT_RESTORE_REGS structure 
  132 00000000          OEM_CPU_INFO_PA_OFFSET          EQU 0x1C 
  133 00000000          OEM_CPU_INFO_UA_OFFSET          EQU 0x20 
  134 00000000            
  135 00000000          ;------------------------------------------------------------------------------ 
  136 00000000          ; useful ARM masks 
  137 00000000          IRQ_MASK                        EQU 0x80    ; IRQ mask value 
  138 00000000          FIQ_MASK                        EQU 0x40    ; FIQ mask value 
  139 00000000          MODE_MASK                       EQU 0x1F    ; Processor Mode Mask 
  140 00000000          TBIT_MASK                       EQU 0x20    ; Thumb mode bit mask  
  141 00000000            
  142 00000000          ;------------------------------------------------------------------------------ 
  143 00000000          ; ARM modes 
  144 00000000          USR_MODE                        EQU 0x10    ; user mode 
  145 00000000          FIQ_MODE                        EQU 0x11    ; Fast Interrupt Mode (FIQ) 
  146 00000000          IRQ_MODE                        EQU 0x12    ; Interrupt Mode (IRQ) 
  147 00000000          SUP_MODE                        EQU 0x13    ; Supervisor Mode 
  148 00000000          ABORT_MODE                      EQU 0x17    ; Abort Mode 
  149 00000000          UNDEF_MODE                      EQU 0x1B    ; undef Mode 
  150 00000000          SYS_MODE                        EQU 0x1F    ; sys Mode 
  151 00000000            
  152 00000000          ;------------------------------------------------------------------------------ 
  153 00000000          ; Cache related constants 
  154 00000000          ICACHE_MASK                     EQU 0x1000 
  155 00000000          DCACHE_MASK                     EQU 0x0004 
  156 00000000          MAX_ASSOCIATIVITY               EQU 0x03FF  ; max val of associativity (10-bit) 
  157 00000000          MAX_SETNUMBER                   EQU 0x7FFF  ; max val for set number (15-bit) 
  158 00000000            
  159 00000000          ;------------------------------------------------------------------------------ 
  160 00000000          ; MMU related constants 
  161 00000000          MMU_MASK                        EQU 0x0001 
  162 00000000          DESC_MASK                       EQU 0x0003 
  163 00000000          PTL1_SECTION                    EQU 0x0002  
  164 00000000          PTL1_KRW                        EQU 0x0400  ; bits 10, 11 
  165 00000000          TTBRBIT_MASK                    EQU 0xFFFFC000 
  166 00000000          MB_BOUNDARY                     EQU 0xFFF00000 
  167 00000000          WINCE_FIRSTPT                   EQU 0xFFFD0000 ; from armhigh.inc 
  168 00000000            
  169 00000000          ;------------------------------------------------------------------------------ 
  170 00000000            
  171 00000000                  END 
   17 00000000            
   18 00000000                  EXPORT OALCPUStart 
   19 00000000                  EXPORT OALCPUIdle 
   20 00000000                  EXPORT OALCPUEnd 
   21 00000000                  EXPORT OALUpdateCoreFreq 
   22 00000000                  EXPORT OALCPUWarmReset 
   23 00000000                  EXPORT OALInvalidateTlb 
   24 00000000                  EXPORT OALGetTTBR 
   25 00000000                  EXPORT INTERRUPTS_STATUS 
   26 00000000            
   27 00000000                  TEXTAREA 
   45                           AREA |.text|,ALIGN=2,CODE,READONLY 
   46 00000000          AreaName SETS "|.text|" 
   28 00000000            
   29 00000000          BEGIN_REGION 
   30 00000000            
   31 00000000            
   32 00000000                  ;ldr         r5, =0x480025e0 
   33 00000000                  ;ldr         r1, =0xFFFF0000 
   34 00000000                  ;ldr         r2, =0x1C 
   35 00000000                  ;ldr         r3, [r5] 
   36 00000000                  ;and         r3, r3, r1 
   37 00000000                  ;orr         r3, r3, r2 
   38 00000000                  ;str         r3, [r5] 
   39 00000000            
   40 00000000                   
   41 00000000          ;------------------------------------------------------------------------------- 
   42 00000000          ; 
   43 00000000          ;  Function:  OALCPUStart 
   44 00000000          ; 
   45 00000000          ;  Marker indicating the start of cpu specific assembly. Never should get called 
   46 00000000          ; 
   47 00000000           LEAF_ENTRY OALCPUStart 
  175 00000000          FuncName SETS    VBar:CC:"OALCPUStart":CC:VBar 
  176 00000000          PrologName SETS "Invalid Prolog" 
  177 00000000          FuncEndName SETS    VBar:CC:"OALCPUStart":CC:"_end":CC:VBar 
  178 00000000                  ALIGN   2 
  179 00000000                  EXPORT  |OALCPUStart| [FUNC] 
  180 00000000          |OALCPUStart| 
  181 00000000                  ROUT 
   48 00000000 e1a00000         nop         
   49 00000004           ENTRY_END OALCPUStart 
  194 00000004          |OALCPUStart_end| 
   50 00000004          ;------------------------------------------------------------------------------- 
   51 00000004            
   52 00000004          ;------------------------------------------------------------------------------- 
   53 00000004          ; 
   54 00000004          ;  constants 
   55 00000004          ; 
   56 00000004          max_assoc 
   57 00000004 000003ff        DCD         MAX_ASSOCIATIVITY 
   58 00000008            
   59 00000008          max_setnum 
   60 00000008 00007fff        DCD         MAX_SETNUMBER          
   61 0000000c          ;------------------------------------------------------------------------------- 
   62 0000000c            
   63 0000000c          ;------------------------------------------------------------------------------- 
   64 0000000c          ; 
   65 0000000c          ;  Function:  SaveContext 
   66 0000000c          ; 
   67 0000000c          ;  This function puts the mpu to OFF 
   68 0000000c          ; 
   69 0000000c          SaveContext 
   70 0000000c                                                  ;-------------------------------------- 
   71 0000000c                                                  ; save sp before modifiying the stack 
   72 0000000c e1a0100d         mov        r1, sp    
   73 00000010 e92d5ff8         stmdb      sp!, {r3 - r12, lr}  
   74 00000014            
   75 00000014                                                  ;-------------------------------------- 
   76 00000014                                                  ; save content of all registers           
   77 00000014 e14f2000         mrs        r2, SPSR 
   78 00000018                                                  ;-------------------------------------- 
   79 00000018                                                  ; save the stack pointer stored in r1 
   80 00000018 e1a03001         mov        r3, r1 
   81 0000001c e8a0000c         stmia      r0!, {r2 - r3} 
   82 00000020                                                  ;-------------------------------------- 
   83 00000020                                                  ; save coprocessor access control reg 
   84 00000020 ee111f50         mrc        p15, 0, r1, c1, c0, 2 
   85 00000024            
   86 00000024                                                  ;-------------------------------------- 
   87 00000024                                                  ; save TTBR0, TTBR1, Trans. tbl base 
   88 00000024 ee122f10         mrc        p15, 0, r2, c2, c0, 0 
   89 00000028 ee123f30         mrc        p15, 0, r3, c2, c0, 1 
   90 0000002c ee124f50         mrc        p15, 0, r4, c2, c0, 2 
   91 00000030                   
   92 00000030                                                  ;-------------------------------------- 
   93 00000030                                                  ; Data TLB lockdown, instr. TLB lockdown 
   94 00000030 ee1a5f10         mrc        p15, 0, r5, c10, c0, 0 
   95 00000034 ee1a6f30         mrc        p15, 0, r6, c10, c0, 1 
   96 00000038 e8a0007e         stmia      r0!, {r1-r6} 
   97 0000003c            
   98 0000003c                                                  ;-------------------------------------- 
   99 0000003c                                                  ; Primary remap, normal remap regs. 
  100 0000003c ee1a1f12         mrc        p15, 0, r1, c10, c2, 0         
  101 00000040 ee1a2f32         mrc        p15, 0, r2, c10, c2, 1 
  102 00000044            
  103 00000044                                                  ;-------------------------------------- 
  104 00000044                                                  ; secure/non-secure vector base address 
  105 00000044                                                  ; FCSE PI, Context PID 
  106 00000044 ee1c3f10         mrc        p15, 0, r3, c12, c0, 0 
  107 00000048 ee1d4f10         mrc        p15, 0, r4, c13, c0, 0 
  108 0000004c ee1d5f30         mrc        p15, 0, r5, c13, c0, 1 
  109 00000050 e8a0003e         stmia      r0!, {r1 - r5} 
  110 00000054                                                  ;-------------------------------------- 
  111 00000054                                                  ; domain access control reg 
  112 00000054                                                  ; data status fault, inst. status fault 
  113 00000054                                                  ; data aux fault status,  
  114 00000054                                                  ; intr. aux fault status, 
  115 00000054                                                  ; data fault addr, instr fault addr 
  116 00000054 ee131f10         mrc        p15, 0, r1, c3, c0, 0 
  117 00000058 ee152f10         mrc        p15, 0, r2, c5, c0, 0 
  118 0000005c ee153f30         mrc        p15, 0, r3, c5, c0, 1 
  119 00000060 ee154f11         mrc        p15, 0, r4, c5, c1, 0 
  120 00000064 ee155f31         mrc        p15, 0, r5, c5, c1, 1 
  121 00000068 ee166f10         mrc        p15, 0, r6, c6, c0, 0 
  122 0000006c ee167f50         mrc        p15, 0, r7, c6, c0, 2 
  123 00000070 e8a000fe         stmia      r0!, {r1 - r7} 
  124 00000074            
  125 00000074                                                  ;-------------------------------------- 
  126 00000074                                                  ; user r/w thread & proc id 
  127 00000074                                                  ; user r/o thread and proc id 
  128 00000074                                                  ; priv only thread and proc id 
  129 00000074                                                  ; cache size selction 
  130 00000074 ee1d1f50         mrc        p15, 0, r1, c13, c0, 2 
  131 00000078 ee1d2f70         mrc        p15, 0, r2, c13, c0, 3 
  132 0000007c ee1d3f90         mrc        p15, 0, r3, c13, c0, 4                                         
  133 00000080 ee504f10         mrc        p15, 2, r4, c0, c0, 0 
  134 00000084 e8a0001e         stmia      r0!, {r1 - r4} 
  135 00000088            
  136 00000088            
  137 00000088                                                  ;-------------------------------------- 
  138 00000088                                                  ; save all modes 
  139 00000088 e10f3000         mrs        r3, cpsr 
  140 0000008c                                                  ;-------------------------------------- 
  141 0000008c                                                  ; fiq mode 
  142 0000008c e3c3101f         bic        r1, r3, #MODE_MASK 
  143 00000090 e3811011         orr        r1, r1, #FIQ_MODE 
  144 00000094 e129f001         msr        cpsr, r1 
  145 00000098 e14f7000         mrs        r7, spsr 
  146 0000009c e8a07f80         stmia      r0!, {r7 - r14} 
  147 000000a0                                                  ;-------------------------------------- 
  148 000000a0                                                  ; irq mode 
  149 000000a0 e3c3101f         bic        r1, r3, #MODE_MASK 
  150 000000a4 e3811012         orr        r1, r1, #IRQ_MODE 
  151 000000a8 e129f001         msr        cpsr, r1 
  152 000000ac e14f7000         mrs        r7, spsr 
  153 000000b0 e8a06080         stmia      r0!, {r7, r13, r14} 
  154 000000b4                                                  ;-------------------------------------- 
  155 000000b4                                                  ; abort mode 
  156 000000b4 e3c3101f         bic        r1, r3, #MODE_MASK 
  157 000000b8 e3811017         orr        r1, r1, #ABORT_MODE 
  158 000000bc e129f001         msr        cpsr, r1 
  159 000000c0 e14f7000         mrs        r7, spsr 
  160 000000c4 e8a06080         stmia      r0!, {r7, r13, r14} 
  161 000000c8                                                  ;-------------------------------------- 
  162 000000c8                                                  ; undef mode 
  163 000000c8 e3c3101f         bic        r1, r3, #MODE_MASK 
  164 000000cc e381101b         orr        r1, r1, #UNDEF_MODE 
  165 000000d0 e129f001         msr        cpsr, r1 
  166 000000d4 e14f7000         mrs        r7, spsr 
  167 000000d8 e8a06080         stmia      r0!, {r7, r13, r14} 
  168 000000dc                                                  ;-------------------------------------- 
  169 000000dc                                                  ; system/user mode 
  170 000000dc e3c3101f         bic        r1, r3, #MODE_MASK 
  171 000000e0 e381101f         orr        r1, r1, #SYS_MODE 
  172 000000e4 e129f001         msr        cpsr, r1 
  173 000000e8 e14f7000         mrs        r7, spsr 
  174 000000ec e8a06080         stmia      r0!, {r7, r13, r14} 
  175 000000f0                                                  ;-------------------------------------- 
  176 000000f0                                                  ; original mode 
  177 000000f0 e129f003         msr        CPSR, r3 
  178 000000f4                                                  ;-------------------------------------- 
  179 000000f4                                                  ; control register 
  180 000000f4 ee114f10         mrc        p15, 0, r4, c1, c0, 0 
  181 000000f8 e8a00018         stmia      r0!, {r3, r4} 
  182 000000fc                                                  ;-------------------------------------- 
  183 000000fc                                                  ; need to flush all cache, copied 
  184 000000fc                                                  ; from cache code 
  185 000000fc ee300f30         mrc     p15, 1, r0, c0, c0, 1   ; read clidr 
  186 00000100 e2103407         ands    r3, r0, #0x7000000   
  187 00000104 e1a03ba3         mov     r3, r3, lsr #23         ; cache level value 
  188 00000108 0a00001b         beq     donea                
  189 0000010c            
  190 0000010c e3a0a000         mov     r10, #0                 ; start clean at cache level 0 
  191 00000110 e08a20aa loop1a  add     r2, r10, r10, lsr #1    ; work out 3x current cache level 
  192 00000114 e1a01230         mov     r1, r0, lsr r2          ; extract cache type bits from clidr 
  193 00000118 e2011007         and     r1, r1, #7              ; mask of the bits for current cache only 
  194 0000011c e3510002         cmp     r1, #2                  ; see what cache we have at this level 
  195 00000120 ba000012         blt     skipa                   ; skip if no cache, or just i-cache 
  196 00000124            
  197 00000124 ee40af10         mcr     p15, 2, r10, c0, c0, 0  ; select current cache level in cssr 
  198 00000128 e3a01000         mov     r1, #0 
  199 0000012c ee071f95         mcr     p15, 0, r1, c7, c5, 4   ; prefetch flush to sync the change to the cachesize id reg 
  200 00000130 ee301f10         mrc     p15, 1, r1, c0, c0, 0   ; read the new csidr 
  201 00000134 e2012007         and     r2, r1, #7              ; extract the length of the cache lines 
  202 00000138 e2822004         add     r2, r2, #4              ; add 4 (line length offset)         
  203 0000013c e51f4140         ldr     r4, max_assoc 
  204 00000140 e01441a1         ands    r4, r4, r1, lsr #3      ; r4 is maximum number on the way size 
warning:Instruction clz not supported for -cpu "-arch 4t"
  205 00000144 e16f5f14         clz     r5, r4                  ; r5 find bit position of way size increment         
  206 00000148 e51f7148         ldr     r7, max_setnum 
  207 0000014c e01776a1         ands    r7, r7, r1, lsr #13     ; r7 extract max number of the index size 
  208 00000150            
  209 00000150 e1a09004 loop2a  mov     r9, r4                  ; r9 is working copy of max way size 
  210 00000154 e18ab519 loop3a  orr     r11, r10, r9, lsl r5    ; factor way and cache number into r11 
  211 00000158 e18bb217         orr     r11, r11, r7, lsl r2    ; factor index number into r11 
  212 0000015c            
  213 0000015c ee07bf5e         mcr     p15, 0, r11, c7, c14, 2 ; clean and invalidate by set/way 
  214 00000160            
  215 00000160 e2599001         subs    r9, r9, #1              ; decrement the way 
  216 00000164 aafffffa         bge     loop3a 
  217 00000168            
  218 00000168 e2577001         subs    r7, r7, #1              ; decrement the index 
  219 0000016c aafffff7         bge     loop2a 
  220 00000170            
  221 00000170 e28aa002 skipa   add     r10, r10, #2            ; increment cache number 
  222 00000174 e153000a         cmp     r3, r10 
  223 00000178 caffffe4         bgt     loop1a 
  224 0000017c            
  225 0000017c e3a0a000 donea   mov     r10, #0                 ; switch back to cache level 0 
  226 00000180 ee40af10         mcr     p15, 2, r10, c0, c0, 0  ; select current cache level in cssr 
  227 00000184                   
  228 00000184 e8bd5ff8         ldmia   sp!, {r3 - r12, lr}  
  229 00000188 e1a0f00e         mov     pc, lr       
  230 0000018c          ;------------------------------------------------------------------------------- 
  231 0000018c            
  232 0000018c          ;------------------------------------------------------------------------------- 
  233 0000018c          ; 
  234 0000018c          ;  Function:  OALCPUIdle 
  235 0000018c          ; 
  236 0000018c          ;  This function puts the mpu in suspend. 
  237 0000018c          ;  r0 = addr CPUIDLE_INFO 
  238 0000018c          ; 
  239 0000018c           LEAF_ENTRY OALCPUIdle 
  175 0000018c          FuncName SETS    VBar:CC:"OALCPUIdle":CC:VBar 
  176 0000018c          PrologName SETS "Invalid Prolog" 
  177 0000018c          FuncEndName SETS    VBar:CC:"OALCPUIdle":CC:"_end":CC:VBar 
  178 0000018c                  ALIGN   2 
  179 0000018c                  EXPORT  |OALCPUIdle| [FUNC] 
  180 0000018c          |OALCPUIdle| 
  181 0000018c                  ROUT 
  240 0000018c                                                   ;-------------------------------------- 
  241 0000018c                                                   ; store register values into stack     
  242 0000018c                                                   ; 
  243 0000018c e92d5ff8         stmdb      sp!, {r3 - r12, lr}  
  244 00000190                                                   ;-------------------------------------- 
  245 00000190                                                   ; check if mpu is going to off     
  246 00000190                                                   ; 
  247 00000190 e5901014         ldr        r1, [r0, #MPU_PRM_REGS_OFFSET] 
  248 00000194 e59120e0         ldr        r2, [r1, #PRM_PWRSTCTRL_MPU_OA] 
  249 00000198 e2023003         and        r3, r2, #PRM_POWERSTATE_MASK         
  250 0000019c e3530000         cmp        r3, #PRM_POWERSTATE_OFF_VAL 
  251 000001a0            
  252 000001a0                                                   ;-------------------------------------- 
  253 000001a0                                                   ; check for open switch retention 
  254 000001a0                                                   ; 
  255 000001a0 12023004         andne      r3, r2, #PRM_LOGICL1CACHERETSTATE_VAL 
  256 000001a4 13530000         cmpne      r3, #0 
  257 000001a8                   
  258 000001a8                                                   ;-------------------------------------- 
  259 000001a8                                                   ; save register context if going to OFF 
  260 000001a8                                                   ; mode 
  261 000001a8                                                   ; 
  262 000001a8 e1a04000         mov        r4, r0 
  263 000001ac 05900024         ldreq      r0, [r0, #MPU_CONTEXT_VA_OFFSET] 
  264 000001b0 0bffff95         bleq       SaveContext 
  265 000001b4            
  266 000001b4                                                           ;-------------------------------------- 
  267 000001b4 e5941000         ldr        r1, [r4, #SDRC_REGS_OFFSET]                 
  268 000001b8 e5915070         ldr        r5, [r1, #SDRC_POWER_OA] 
  269 000001bc e3855040         orr        r5, r5, #0x40            ;enable self refresh on idle req 
  270 000001c0 e5815070         str        r5, [r1, #SDRC_POWER_OA] ;write back to SDRC_POWER register 
  271 000001c4            
  272 000001c4                                                   ;-------------------------------------- 
  273 000001c4                                                   ; memory barrier     
  274 000001c4                                                   ; 
  275 000001c4 e3a02000         mov        r2, #0x0 
  276 000001c8 ee072f9a         mcr        p15, 0, r2, c7, c10, 4         
  277 000001cc ee072fba         mcr        p15, 0, r2, c7, c10, 5     
  278 000001d0 e1a00000         nop                        
  279 000001d4 e320f003         dcd        WFI 
  280 000001d8                                    
  281 000001d8                                                   ;-------------------------------------- 
  282 000001d8                                                   ; r1 = CORE_CM regs 
  283 000001d8                                                   ; r2 = CM_CLKSTST_CORE value 
  284 000001d8                                                   ; wait for L3 to lock 
  285 000001d8                                                   ; 
  286 000001d8 e5941008         ldr        r1, [r4, #CORE_CM_REGS_OFFSET] 
  287 000001dc                   
  288 000001dc          |$_OALCPUIdle_L3_Lock_Loop| 
  289 000001dc e591204c         ldr        r2, [r1, #CM_CLKSTST_CORE_OA] 
  290 000001e0 e2122001         ands       r2, r2, #CM_CLKSTST_CLKACTIVITY_L3_BIT 
  291 000001e4 0afffffc         beq        |$_OALCPUIdle_L3_Lock_Loop|        
  292 000001e8            
  293 000001e8          |$_wait_sdrc_ok| 
  294 000001e8 e5912020         ldr     r2, [r1, #CM_IDLEST1_CORE_OA]         
  295 000001ec e2022002         and     r2, r2, #0x2 
  296 000001f0 e3520000         cmp     r2, #0 
  297 000001f4 1afffffb         bne     |$_wait_sdrc_ok| 
  298 000001f8 e5941000         ldr     r1, [r4, #SDRC_REGS_OFFSET]                 
  299 000001fc e5915070         ldr     r5, [r1, #SDRC_POWER_OA] 
  300 00000200 e3c55040         bic     r5, r5, #0x40 
  301 00000204 e5815070         str     r5, [r1, #SDRC_POWER_OA] 
  302 00000208                                                      ;-------------------------------------- 
  303 00000208                                                      ; Is dll in lock mode? 
  304 00000208          |$_wait_dll_lock|                                             
  305 00000208 e5915060         ldr     r5, [r1, #SDRC_DLLA_CTRL_OA]         
  306 0000020c e3150004         tst     r5, #0x4 
  307 00000210 112fff1e         bxne    lr 
  308 00000214                                                      ;-------------------------------------- 
  309 00000214                                                      ; wait till dll locks 
  310 00000214 e5915064         ldr     r5, [r1, #SDRC_DLLA_STATUS_OA]     
  311 00000218 e2055004         and     r5, r5, #0x4 
  312 0000021c e3550004         cmp     r5, #0x4 
  313 00000220 1afffff8         bne     |$_wait_dll_lock| 
  314 00000224                   
  315 00000224            
  316 00000224 e8bd5ff8         ldmia      sp!, {r3 - r12, lr}  
  317 00000228 e1a0f00e         mov        pc, lr                
  318 0000022c           ENTRY_END OALCPUIdle 
  194 0000022c          |OALCPUIdle_end| 
  319 0000022c          ;------------------------------------------------------------------------------- 
  320 0000022c            
  321 0000022c          ;------------------------------------------------------------------------------- 
  322 0000022c          ; 
  323 0000022c          ;  Function:  CPUStall 
  324 0000022c          ; 
  325 0000022c          ;  loops [r0] amount 
  326 0000022c          ;  r0 = amount to loop 
  327 0000022c          ; 
  328 0000022c          ;  uses: r0 
  329 0000022c          ; 
  330 0000022c          CPUStall 
  331 0000022c e3500000         cmp         r0, #0x0 
  332 00000230 12400001         subne       r0, r0, #0x1 
  333 00000234 1afffffc         bne         CPUStall 
  334 00000238                   
  335 00000238 e1a0f00e         mov         pc, lr 
  336 0000023c          ;------------------------------------------------------------------------------- 
  337 0000023c            
  338 0000023c          ;------------------------------------------------------------------------------- 
  339 0000023c          ; 
  340 0000023c          ;  Function:  GPTWait 
  341 0000023c          ; 
  342 0000023c          ;  number of gptimer ticks to wait 
  343 0000023c          ;  r0 = amount of gpt to wait 
  344 0000023c          ;  r5 = addr CPUIDLE_INFO 
  345 0000023c          ; 
  346 0000023c          ;  uses: r0, r1 
  347 0000023c          ; 
  348 0000023c          GPTWait                                          
  349 0000023c e5951010         ldr         r1, [r5, #GPTIMER_REGS_OFFSET] 
  350 00000240 e5911028         ldr         r1, [r1, #TIMER_TCRR_OA] 
  351 00000244 e2800001         add         r0, r0, #1 
  352 00000248 e0800001         add         r0, r0, r1         
  353 0000024c            
  354 0000024c                                                   ;-------------------------------------- 
  355 0000024c                                                   ; loop until the requested amount of 
  356 0000024c                                                   ; ticks went by 
  357 0000024c                                                   ; 
  358 0000024c          |$_GPTWait_Loop| 
  359 0000024c            
  360 0000024c e5951010         ldr         r1, [r5, #GPTIMER_REGS_OFFSET] 
  361 00000250 e5911028         ldr         r1, [r1, #TIMER_TCRR_OA] 
  362 00000254 e1510000         cmp         r1, r0 
  363 00000258 1afffffb         bne         |$_GPTWait_Loop| 
  364 0000025c                   
  365 0000025c e1a0f00e         mov         pc, lr 
  366 00000260          ;------------------------------------------------------------------------------- 
  367 00000260            
  368 00000260          ;------------------------------------------------------------------------------- 
  369 00000260          ; 
  370 00000260          ;  Function:  SDRCEnable 
  371 00000260          ; 
  372 00000260          ;  This function enables/disables access to SDRAM. 
  373 00000260          ;  r0 = 1:enable SDRC iclk, 0:disable SDRC iclk 
  374 00000260          ;  r6 = ref CORE_CM_REGS 
  375 00000260          ; 
  376 00000260          ;  return: none 
  377 00000260          ; 
  378 00000260          ;  uses: r0 - r1 
  379 00000260          ; 
  380 00000260          SDRCEnable 
  381 00000260                                                   ;-------------------------------------- 
  382 00000260                                                   ; setup pointers 
  383 00000260                                                   ; r1 = req SDRC iclk mode 
  384 00000260 e1a01080         mov         r1, r0, LSL #CM_ICLKEN1_CORE_SDRC_BIT 
  385 00000264 e3310002         teq         r1, #(1 :SHL: CM_ICLKEN1_CORE_SDRC_BIT) 
  386 00000268                           
  387 00000268                                                   ;-------------------------------------- 
  388 00000268                                                   ; clear/set EN_SDRC in CM_ICLKEN1_CORE 
  389 00000268 e5960010         ldr         r0, [r6, #CM_ICLKEN1_CORE_OA] 
  390 0000026c 13c00002         bicne       r0, r0, #(1 :SHL: CM_ICLKEN1_CORE_SDRC_BIT) 
  391 00000270 03800002         orreq       r0, r0, #(1 :SHL: CM_ICLKEN1_CORE_SDRC_BIT) 
  392 00000274 e5860010         str         r0, [r6, #CM_ICLKEN1_CORE_OA] 
  393 00000278            
  394 00000278                                                   ;-------------------------------------- 
  395 00000278                                                   ; wait until EN_SDRC is in the correct 
  396 00000278                                                   ; state 
  397 00000278          _SDRCEnable_chk1 
  398 00000278 e5960020         ldr         r0, [r6, #CM_IDLEST1_CORE_OA] 
  399 0000027c e2000002         and         r0, r0, #(1 :SHL: CM_ICLKEN1_CORE_SDRC_BIT) 
  400 00000280 e1300001         teq         r0, r1 
  401 00000284 0afffffb         beq         _SDRCEnable_chk1 
  402 00000288            
  403 00000288 e12fff1e         bx          lr                   ;return 
  404 0000028c          ;------------------------------------------------------------------------------- 
  405 0000028c            
  406 0000028c          ;------------------------------------------------------------------------------- 
  407 0000028c          ; 
  408 0000028c          ;  Function:  SetDpllMode 
  409 0000028c          ; 
  410 0000028c          ;  Puts DPLL in bypass or locked 
  411 0000028c          ;  r0 = 5 : enable low power bypass, 6 : fast relock bypass, 7 : no bypass 
  412 0000028c          ;  r1 = addr CM_CLKEN_xxx (must be CM_CLKEN_PLL, CM_CLKEN_MPU, CM_CLKEN_IVA2) 
  413 0000028c          ;  r5 = addr CPUIDLE_INFO 
  414 0000028c          ; 
  415 0000028c          ;  uses: r2, r3 
  416 0000028c          ; 
  417 0000028c          SetDpllMode 
  418 0000028c            
  419 0000028c                                                   ;-------------------------------------- 
  420 0000028c                                                   ; setup pointers 
  421 0000028c                                                   ; r2 = req dpll mode 
  422 0000028c                                                   ; r3 = ref CM_CLKEN_xxx 
  423 0000028c e1a02000         mov         r2, r0 
  424 00000290 e1a03001         mov         r3, r1 
  425 00000294                   
  426 00000294                                                   ;-------------------------------------- 
  427 00000294                                                   ; check if dpll is already at the 
  428 00000294                                                   ; requested state 
  429 00000294 e5930000         ldr         r0, [r3] 
  430 00000298 e2001007         and         r1, r0, #CM_CLKEN_PLL_DPLL_MASK 
  431 0000029c e1310002         teq         r1, r2 
  432 000002a0 0a000009         beq         |$_SetDpllMode_exit| 
  433 000002a4                       
  434 000002a4                                                   ;-------------------------------------- 
  435 000002a4                                                   ; update dpll to requested state 
  436 000002a4 e3c00007         bic         r0, r0, #CM_CLKEN_PLL_DPLL_MASK 
  437 000002a8 e1800002         orr         r0, r0, r2 
  438 000002ac e5830000         str         r0, [r3] 
  439 000002b0            
  440 000002b0                                                   ;-------------------------------------- 
  441 000002b0                                                   ; setup for test loop 
  442 000002b0 e3320007         teq         r2, #CM_CLKEN_PLL_DPLL_LOCKED 
  443 000002b4 13a01000         movne       r1, #0 
  444 000002b8 03a01001         moveq       r1, #1 
  445 000002bc                                                   ;-------------------------------------- 
  446 000002bc                                                   ; loop until dpll in desired state 
  447 000002bc          _SetDpllMode_chk1 
  448 000002bc e5930020         ldr         r0, [r3, #CM_IDLEST_CKGEN_OA] 
  449 000002c0 e2000001         and         r0, r0, #1 
  450 000002c4 e1300001         teq         r0, r1 
  451 000002c8 1afffffb         bne         _SetDpllMode_chk1 
  452 000002cc            
  453 000002cc          |$_SetDpllMode_exit| 
  454 000002cc e12fff1e         bx          lr                   ; return 
  455 000002d0          ;------------------------------------------------------------------------------- 
  456 000002d0            
  457 000002d0          ;------------------------------------------------------------------------------- 
  458 000002d0          ; 
  459 000002d0          ;  Function:  OALUpdateCoreFreq 
  460 000002d0          ; 
  461 000002d0          ;  changes the core dpll frequency 
  462 000002d0          ; 
  463 000002d0          ;  r0 = addr CPUIDLE_INFO 
  464 000002d0          ;  r1 = value for CM_CLKEN_PLL 
  465 000002d0          ;  r2 = value for CM_CLKSEL1_PLL 
  466 000002d0          ; 
  467 000002d0           LEAF_ENTRY OALUpdateCoreFreq 
  175 000002d0          FuncName SETS    VBar:CC:"OALUpdateCoreFreq":CC:VBar 
  176 000002d0          PrologName SETS "Invalid Prolog" 
  177 000002d0          FuncEndName SETS    VBar:CC:"OALUpdateCoreFreq":CC:"_end":CC:VBar 
  178 000002d0                  ALIGN   2 
  179 000002d0                  EXPORT  |OALUpdateCoreFreq| [FUNC] 
  180 000002d0          |OALUpdateCoreFreq| 
  181 000002d0                  ROUT 
  468 000002d0            
  469 000002d0 e92d47f8         stmdb       sp!, {r3 - r10, lr} 
  470 000002d4                                                   ;-------------------------------------- 
  471 000002d4                                                   ; memory barrier 
  472 000002d4 e3a03000         mov         r3, #0             
  473 000002d8 ee073fba         mcr             p15, 0, r3, c7, c10, 5  
  474 000002dc            
  475 000002dc                                                   ;-------------------------------------- 
  476 000002dc                                                   ; setup pointers                                          
  477 000002dc                                                   ; r5 = ref SDRC_REGS 
  478 000002dc                                                   ; r6 = ref CORE_CM_REGS 
  479 000002dc                                                   ; r7 = ref CLOCK_CTRL_CM_REGS         
  480 000002dc                                                   ; r8 = value for CM_CLKEN_PLL 
  481 000002dc                                                   ; r9 = value for CM_CLKSEL1_PLL 
  482 000002dc e5905000         ldr         r5, [r0, #SDRC_REGS_OFFSET] 
  483 000002e0 e5906008         ldr         r6, [r0, #CORE_CM_REGS_OFFSET] 
  484 000002e4 e590700c         ldr         r7, [r0, #CLOCK_CTRL_CM_REGS_OFFSET] 
  485 000002e8 e1a08001         mov         r8, r1 
  486 000002ec e1a09002         mov         r9, r2 
  487 000002f0                   
  488 000002f0                                                   ;-------------------------------------- 
  489 000002f0                                                   ; Get current DLL mode, to be used  
  490 000002f0                                                   ; later 
  491 000002f0 e5952060         ldr         r2, [r5, #SDRC_DLLA_CTRL_OA] 
  492 000002f4            
  493 000002f4                                                   ;-------------------------------------- 
  494 000002f4                                                   ; Determine OPP Transition 
  495 000002f4 e1a03da9         mov         r3, r9 LSR #CM_CLKSEL1_PLL_M2_SHIFT 
  496 000002f8 e3530001         cmp         r3, #1 
  497 000002fc            
  498 000002fc                                                   ;-------------------------------------- 
  499 000002fc                                                   ; set wait time and idle mask 
  500 000002fc                                                   ; LOW OPP -> DLL unlock mode 
  501 000002fc                                                   ; HIGH OPP -> DLL lock mode 
  502 000002fc                                                   ; GET refresh rate 
  503 000002fc 13a04000         movne       r4, #DVFS_LOW_OPP_STALL 
  504 00000300 03a04010         moveq       r4, #DVFS_HIGH_OPP_STALL 
  505 00000304 13a03000         movne       r3, #SDRC_DLLA_STATUS_UNLOCKED 
  506 00000308 03a03004         moveq       r3, #SDRC_DLLA_STATUS_LOCKED 
  507 0000030c            
  508 0000030c                                                   ;-------------------------------------- 
  509 0000030c                                                   ; set LOCKDLL for <= 83 mhz 
  510 0000030c                                                   ; clr LOCKDLL for > 83 mhz 
  511 0000030c 13822004         orrne       r2, r2, #(1 :SHL: SDRC_DLL_LOCKDLL_BIT) 
  512 00000310 03c22004         biceq       r2, r2, #(1 :SHL: SDRC_DLL_LOCKDLL_BIT) 
  513 00000314 e5852060         str         r2, [r5, #SDRC_DLLA_CTRL_OA] 
  514 00000318            
  515 00000318                                                   ;-------------------------------------- 
  516 00000318                                                   ; restrict access to SDRAM 
  517 00000318 e3a00000         mov         r0, #SDRC_DISABLE_ICLK 
  518 0000031c ebffffcf         bl          SDRCEnable 
  519 00000320                   
  520 00000320                                                   ;-------------------------------------- 
  521 00000320                                                   ; update w/ new m,n values and dpll  
  522 00000320                                                   ; configuration 
  523 00000320 e5879040         str         r9, [r7, #CM_CLKSEL1_PLL_OA]                                          
  524 00000324 e5878000         str         r8, [r7, #CM_CLKEN_PLL_OA] 
  525 00000328            
  526 00000328                                                   ;-------------------------------------- 
  527 00000328                                                   ; stall a predefined amount 
  528 00000328 e3540000         cmp         r4, #0 
  529 0000032c 11a00004         movne       r0, r4 
  530 00000330 1bffffbd         blne        CPUStall 
  531 00000334            
  532 00000334                                                   ;-------------------------------------- 
  533 00000334                                                   ; allow access to SDRAM 
  534 00000334 e3a00001         mov         r0, #SDRC_ENABLE_ICLK 
  535 00000338 ebffffc8         bl          SDRCEnable           
  536 0000033c            
  537 0000033c                                                   ;-------------------------------------- 
  538 0000033c                                                   ; wait for status to match expected 
  539 0000033c                                                   ; state 
  540 0000033c          _OALUpdateCoreFreq_chk1 
  541 0000033c            
  542 0000033c e5952064         ldr         r2, [r5, #SDRC_DLLA_STATUS_OA] 
  543 00000340 e1520003         cmp         r2, r3 
  544 00000344 1afffffc         bne         _OALUpdateCoreFreq_chk1 
  545 00000348                   
  546 00000348 e8bd47f8         ldmia       sp!, {r3 - r10, lr} 
  547 0000034c e12fff1e         bx          lr                   ; return 
  548 00000350                   
  549 00000350           ENTRY_END OALUpdateCoreFreq 
  194 00000350          |OALUpdateCoreFreq_end| 
  550 00000350          ;------------------------------------------------------------------------------- 
  551 00000350            
  552 00000350          ;------------------------------------------------------------------------------ 
  553 00000350          ; 
  554 00000350          ;  Function:  OALCPUWarmReset 
  555 00000350          ; 
  556 00000350          ;  Perform a warm reset of the CPU and follow advisory 3.1.1.176 that requires 
  557 00000350          ;  disabling the DDR before resetting for proper recovery 
  558 00000350          ; 
  559 00000350          ;  r0 = addr CPUIDLE_INFO 
  560 00000350          ; 
  561 00000350           LEAF_ENTRY OALCPUWarmReset 
  175 00000350          FuncName SETS    VBar:CC:"OALCPUWarmReset":CC:VBar 
  176 00000350          PrologName SETS "Invalid Prolog" 
  177 00000350          FuncEndName SETS    VBar:CC:"OALCPUWarmReset":CC:"_end":CC:VBar 
  178 00000350                  ALIGN   2 
  179 00000350                  EXPORT  |OALCPUWarmReset| [FUNC] 
  180 00000350          |OALCPUWarmReset| 
  181 00000350                  ROUT 
  562 00000350            
  563 00000350                                                      ;---------------------------------- 
  564 00000350                                                   ; memory barrier 
  565 00000350 e3a03000         mov         r3, #0 
  566 00000354 ee073fba         mcr         p15, 0, r3, c7, c10, 5 
  567 00000358                                                          ;------------------------------ 
  568 00000358                                                   ; setup pointers 
  569 00000358                                                   ; r5 = ref GLOBAL_PRM_REGS 
  570 00000358                                                   ; r6 = ref CORE_CM_REGS 
  571 00000358 e590501c         ldr         r5, [r0, #GLOBAL_PRM_REGS_OFFSET] 
  572 0000035c e5906008         ldr         r6, [r0, #CORE_CM_REGS_OFFSET] 
  573 00000360                                                   ;------------------------------------- 
  574 00000360                                                   ; Disable SDRC ICLK 
  575 00000360 e3a00000         mov         r0, #SDRC_DISABLE_ICLK 
  576 00000364 ebffffbd         bl          SDRCEnable 
  577 00000368                                                    ;------------------------------------ 
  578 00000368                                                    ; Perform global reset 
  579 00000368 e3a03002         mov                    r3, #PRM_RSTCTRL_RST_GS_BIT 
  580 0000036c e5853050         str                    r3, [r5, #PRM_RSTCTRL_GLOBAL_OA] 
  581 00000370                                                   ;------------------------------------- 
  582 00000370                                                   ; Wait for ever until reset 
  583 00000370          LoopForEver 
  584 00000370 ebfffffe                bl                      LoopForEver 
  585 00000374            
  586 00000374           ENTRY_END OALCPUWarmReset 
  194 00000374          |OALCPUWarmReset_end| 
  587 00000374            
  588 00000374          ;------------------------------------------------------------------------------ 
  589 00000374            
  590 00000374                  ; ensure any literals used by above code are located before OALCPUEnd so they get copied to SRAM 
  591 00000374            
  592 00000374                  LTORG 
  593 00000374            
  594 00000374          ;------------------------------------------------------------------------------- 
  595 00000374          ; 
  596 00000374          ;  Function:  OALCPUEnd 
  597 00000374          ; 
  598 00000374          ;  Marker indicating the end of cpu specific assembly. Never should get called 
  599 00000374          ; 
  600 00000374           LEAF_ENTRY OALCPUEnd 
  175 00000374          FuncName SETS    VBar:CC:"OALCPUEnd":CC:VBar 
  176 00000374          PrologName SETS "Invalid Prolog" 
  177 00000374          FuncEndName SETS    VBar:CC:"OALCPUEnd":CC:"_end":CC:VBar 
  178 00000374                  ALIGN   2 
  179 00000374                  EXPORT  |OALCPUEnd| [FUNC] 
  180 00000374          |OALCPUEnd| 
  181 00000374                  ROUT 
  601 00000374 e1a00000         nop         
  602 00000378           ENTRY_END OALCPUEnd 
  194 00000378          |OALCPUEnd_end| 
  603 00000378          ;------------------------------------------------------------------------------- 
  604 00000378            
  605 00000378          ;------------------------------------------------------------------------------- 
  606 00000378          ; 
  607 00000378          ;  Function:  INTERRUPTS_STATUS 
  608 00000378          ; 
  609 00000378          ;  returns current arm interrupts status. 
  610 00000378          ; 
  611 00000378           LEAF_ENTRY INTERRUPTS_STATUS 
  175 00000378          FuncName SETS    VBar:CC:"INTERRUPTS_STATUS":CC:VBar 
  176 00000378          PrologName SETS "Invalid Prolog" 
  177 00000378          FuncEndName SETS    VBar:CC:"INTERRUPTS_STATUS":CC:"_end":CC:VBar 
  178 00000378                  ALIGN   2 
  179 00000378                  EXPORT  |INTERRUPTS_STATUS| [FUNC] 
  180 00000378          |INTERRUPTS_STATUS| 
  181 00000378                  ROUT 
  612 00000378            
  613 00000378 e10f0000         mrs     r0, cpsr                    ; (r0) = current status 
  614 0000037c e2100080         ands    r0, r0, #0x80               ; was interrupt enabled? 
  615 00000380 03a00001         moveq   r0, #1                      ; yes, return 1 
  616 00000384 13a00000         movne   r0, #0                      ; no, return 0 
  617 00000388            
  618 00000388           ENTRY_END INTERRUPTS_STATUS 
  194 00000388          |INTERRUPTS_STATUS_end| 
  619 00000388            
  620 00000388          ;------------------------------------------------------------------------------- 
  621 00000388          ; 
  622 00000388          ;  Function:  OALInvalidateTlb 
  623 00000388          ; 
  624 00000388          ;  This function Invalidates the TLBs and enable I and D Cache 
  625 00000388          ; 
  626 00000388           LEAF_ENTRY OALInvalidateTlb 
  175 00000388          FuncName SETS    VBar:CC:"OALInvalidateTlb":CC:VBar 
  176 00000388          PrologName SETS "Invalid Prolog" 
  177 00000388          FuncEndName SETS    VBar:CC:"OALInvalidateTlb":CC:"_end":CC:VBar 
  178 00000388                  ALIGN   2 
  179 00000388                  EXPORT  |OALInvalidateTlb| [FUNC] 
  180 00000388          |OALInvalidateTlb| 
  181 00000388                  ROUT 
  627 00000388 e3a01000         mov        r1, #0 
  628 0000038c ee112f10         mrc        p15, 0, r2, c1, c0, 0 ; get control code 
  629 00000390 ee081f17         mcr        p15, 0, r1, c8, c7, 0 ; invalidate TLB 
  630 00000394 e3822a01         orr        r2, r2, #ICACHE_MASK 
  631 00000398 e3822004         orr        r2, r2, #DCACHE_MASK 
  632 0000039c ee012f10         mcr        p15, 0, r2, c1, c0, 0 ; enable i/d cache 
  633 000003a0 ee071f9a         mcr        p15, 0, r1, c7, c10, 4; drain write buffers 
  634 000003a4 e1a00000         nop                  
  635 000003a8            
  636 000003a8 e1a0f00e         mov        pc, lr                        
  637 000003ac               
  638 000003ac           ENTRY_END OALInvalidateTlb 
  194 000003ac          |OALInvalidateTlb_end| 
  639 000003ac          ;------------------------------------------------------------------------------- 
  640 000003ac            
  641 000003ac          ;------------------------------------------------------------------------------- 
  642 000003ac          ; 
  643 000003ac          ;  Function:  OALGetTTBR 
  644 000003ac          ; 
  645 000003ac          ;  work-around a new kernel feature which marks all non-cached memory 
  646 000003ac          ;  as non-executable. 
  647 000003ac          ; 
  648 000003ac           LEAF_ENTRY OALGetTTBR 
  175 000003ac          FuncName SETS    VBar:CC:"OALGetTTBR":CC:VBar 
  176 000003ac          PrologName SETS "Invalid Prolog" 
  177 000003ac          FuncEndName SETS    VBar:CC:"OALGetTTBR":CC:"_end":CC:VBar 
  178 000003ac                  ALIGN   2 
  179 000003ac                  EXPORT  |OALGetTTBR| [FUNC] 
  180 000003ac          |OALGetTTBR| 
  181 000003ac                  ROUT 
  649 000003ac            
  650 000003ac ee121f50         mrc         p15, 0, r1, c2, c0, 2 ; determine if using TTBR0 or 1 
  651 000003b0 e2011007         and         r1, r1, #0x7 
  652 000003b4 e3510000         cmp         r1, #0x0 
  653 000003b8 0e120f10         mrceq       p15, 0, r0, c2, c0, 0 ; get TTBR from either TTBR0 or 1 
  654 000003bc 1e120f30         mrcne       p15, 0, r0, c2, c0, 1 
  655 000003c0 e3c0001f         bic         r0, r0, #0x1F          ; clear control bits 
  656 000003c4 e12fff1e         bx          lr  
  657 000003c8            
  658 000003c8           ENTRY_END OALGetTTBR 
  194 000003c8          |OALGetTTBR_end| 
  659 000003c8            
  660 000003c8            
  661 000003c8           EXPORT OALGetL2Aux 
  662 000003c8           LEAF_ENTRY OALGetL2Aux 
  175 000003c8          FuncName SETS    VBar:CC:"OALGetL2Aux":CC:VBar 
  176 000003c8          PrologName SETS "Invalid Prolog" 
  177 000003c8          FuncEndName SETS    VBar:CC:"OALGetL2Aux":CC:"_end":CC:VBar 
  178 000003c8                  ALIGN   2 
  179 000003c8                  EXPORT  |OALGetL2Aux| [FUNC] 
  180 000003c8          |OALGetL2Aux| 
  181 000003c8                  ROUT 
  663 000003c8 ee390f50         mrc     p15, 1, r0, c9, c0, 2 
  664 000003cc e1a0f00e         mov     pc, lr 
  665 000003d0           ENTRY_END OALGetL2Aux 
  194 000003d0          |OALGetL2Aux_end| 
  666 000003d0                   
  667 000003d0            
  668 000003d0          END_REGION 
  669 000003d0          ;------------------------------------------------------------------------------- 
  670 000003d0            
  671 000003d0                  END 
Assembly terminated, errors: 0, warnings: 1 
