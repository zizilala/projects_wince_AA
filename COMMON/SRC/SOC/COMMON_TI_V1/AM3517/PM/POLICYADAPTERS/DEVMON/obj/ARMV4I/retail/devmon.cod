; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\AM3517\PM\POLICYADAPTERS\DEVMON\devmon.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.data|, DATA
|s_DevPerfTable| DCD 0x0
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x1
	DCD	0x4
	DCD	0x0
	DCD	0x1
	DCD	0x2
	DCD	0x4
	DCD	0x0
	DCD	0x1
	DCD	0x3
	DCD	0x4
	DCD	0x1
	DCD	0x1
	DCD	0x4
	DCD	0x4
	DCD	0x1
	DCD	0x1
	DCD	0x5
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x6
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x7
	DCD	0x4
	DCD	0x0
	DCD	0x1
	DCD	0x8
	DCD	0x4
	DCD	0x0
	DCD	0x1
	DCD	0x9
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0xa
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0xb
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0xc
	DCD	0x4
	DCD	0x0
	DCD	0x1
	DCD	0xd
	DCD	0x4
	DCD	0x0
	DCD	0x1
	DCD	0xe
	DCD	0x4
	DCD	0x0
	DCD	0x1
	DCD	0xf
	DCD	0x4
	DCD	0x0
	DCD	0x1
	DCD	0x10
	DCD	0x4
	DCD	0x0
	DCD	0x1
	DCD	0x11
	DCD	0x4
	DCD	0x0
	DCD	0x1
	DCD	0x12
	DCD	0x4
	DCD	0x0
	DCD	0x1
	DCD	0x13
	DCD	0x4
	DCD	0x0
	DCD	0x1
	DCD	0x14
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x15
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x16
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x17
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x18
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x19
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x1a
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x1b
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x1c
	DCD	0x4
	DCD	0x2
	DCD	0x1
	DCD	0x1d
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x1e
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x1f
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x20
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x21
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x22
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x23
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x24
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x25
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x26
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x27
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x28
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x29
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x2a
	DCD	0x4
	DCD	0x1
	DCD	0x2
	DCD	0x2b
	DCD	0x4
	DCD	0x1
	DCD	0x2
	DCD	0x2c
	DCD	0x4
	DCD	0x1
	DCD	0x2
	DCD	0x2d
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x2e
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x2f
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x30
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x31
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x32
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x33
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x34
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x35
	DCD	0x4
	DCD	0x0
	DCD	0x2
	DCD	0x36
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x37
	DCD	0x4
	DCD	0x0
	DCD	0x6
	DCD	0x38
	DCD	0x4
	DCD	0x0
	DCD	0x6
	DCD	0x39
	DCD	0x4
	DCD	0x0
	DCD	0x6
	DCD	0x3a
	DCD	0x4
	DCD	0x2
	DCD	0x6
	DCD	0x3b
	DCD	0x4
	DCD	0x2
	DCD	0xffffffff
	DCD	0x3c
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x3d
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x3e
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x3f
	DCD	0x4
	DCD	0x2
	DCD	0x3
	DCD	0x40
	DCD	0x4
	DCD	0x2
	DCD	0x3
	DCD	0x41
	DCD	0x4
	DCD	0x2
	DCD	0x3
	DCD	0x42
	DCD	0x4
	DCD	0x2
	DCD	0xffffffff
	DCD	0x43
	DCD	0x4
	DCD	0x2
	DCD	0xffffffff
	DCD	0x44
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x49
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x45
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x46
	DCD	0x4
	DCD	0x0
	DCD	0xffffffff
	DCD	0x48
	DCD	0x4
	DCD	0x2
	DCD	0x8
	%	16
	EXPORT	|?Lock@@YAXXZ|				; Lock
	IMPORT	|EnterCriticalSection|

  00000			 AREA	 |.bss|, NOINIT
|s_DeviceMonitorInfo| % 0x78
|s_DeviceMonitorInfo| % 0x78
; File c:\wince600\platform\common\src\soc\common_ti_v1\am3517\pm\policyadapters\devmon\devmon.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T37743| DCD	|$LN5@Lock|
	DCD	0x40000701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Lock@@YAXXZ| PROC			; Lock

; 66   : {

  00000		 |$LN5@Lock|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37740|

; 67   :     EnterCriticalSection(&s_DeviceMonitorInfo.cs);

  00004	e59f300c	 ldr         r3, [pc, #0xC]
  00008	e2830004	 add         r0, r3, #4
  0000c	eb000000	 bl          EnterCriticalSection

; 68   : }

  00010	e49de004	 ldr         lr, [sp], #4
  00014	e12fff1e	 bx          lr
  00018		 |$LN6@Lock|
  00018		 |$LN7@Lock|
  00018	00000000	 DCD         |s_DeviceMonitorInfo|
  0001c		 |$M37741|

			 ENDP  ; |?Lock@@YAXXZ|, Lock

	EXPORT	|?Unlock@@YAXXZ|			; Unlock
	IMPORT	|LeaveCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T37752| DCD	|$LN5@Unlock|
	DCD	0x40000701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Unlock@@YAXXZ| PROC			; Unlock

; 78   : {

  00000		 |$LN5@Unlock|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37749|

; 79   :     LeaveCriticalSection(&s_DeviceMonitorInfo.cs);

  00004	e59f300c	 ldr         r3, [pc, #0xC]
  00008	e2830004	 add         r0, r3, #4
  0000c	eb000000	 bl          LeaveCriticalSection

; 80   : }

  00010	e49de004	 ldr         lr, [sp], #4
  00014	e12fff1e	 bx          lr
  00018		 |$LN6@Unlock|
  00018		 |$LN7@Unlock|
  00018	00000000	 DCD         |s_DeviceMonitorInfo|
  0001c		 |$M37750|

			 ENDP  ; |?Unlock@@YAXXZ|, Unlock

	EXPORT	|?InitializeSuspendState@@YAHPBG@Z|	; InitializeSuspendState
	EXPORT	|??_C@_1BK@CFNMIKKN@?$AAS?$AAu?$AAs?$AAp?$AAe?$AAn?$AAd?$AAS?$AAt?$AAa?$AAt?$AAe?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|RegCloseKey|
	IMPORT	|KernelIoControl|
	IMPORT	|RegQueryValueExW|
	IMPORT	|RegOpenKeyExW|

  00000			 AREA	 |.pdata|, PDATA
|$T37764| DCD	|$LN8@Initialize|
	DCD	0x40002902

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@CFNMIKKN@?$AAS?$AAu?$AAs?$AAp?$AAe?$AAn?$AAd?$AAS?$AAt?$AAa?$AAt?$AAe?$AA?$AA@| DCB "S"
	DCB	0x0, "u", 0x0, "s", 0x0, "p", 0x0, "e", 0x0, "n", 0x0, "d"
	DCB	0x0, "S", 0x0, "t", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InitializeSuspendState@@YAHPBG@Z| PROC ; InitializeSuspendState

; 92   : {

  00000		 |$LN8@Initialize|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M37761|
  00008	e1a01000	 mov         r1, r0

; 93   :     DWORD state;
; 94   :     DWORD size;
; 95   :     BOOL rc = TRUE;
; 96   :     HKEY hKey = NULL;

  0000c	e3a02000	 mov         r2, #0

; 97   : 
; 98   :     // read registry to get initialization information
; 99   :     if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szContext, 0, 0, &hKey) != ERROR_SUCCESS)

  00010	e28d3008	 add         r3, sp, #8
  00014	e58d2008	 str         r2, [sp, #8]
  00018	e58d3000	 str         r3, [sp]
  0001c	e3a03000	 mov         r3, #0
  00020	e3a02000	 mov         r2, #0
  00024	e3a0010a	 mov         r0, #0xA, 2
  00028	eb000000	 bl          RegOpenKeyExW
  0002c	e3500000	 cmp         r0, #0
  00030	1a000015	 bne         |$cleanUp$37594|

; 100  :         {
; 101  :         goto cleanUp;
; 102  :         }
; 103  : 
; 104  :     // get ceiling value
; 105  :     size = sizeof(DWORD);
; 106  :     if (RegQueryValueEx(hKey, SYSTEM_SUSPEND_STATE, 0, 0, (BYTE*)&state, &size) == ERROR_SUCCESS)

  00034	e59f1064	 ldr         r1, [pc, #0x64]
  00038	e59d0008	 ldr         r0, [sp, #8]
  0003c	e3a05004	 mov         r5, #4
  00040	e28de00c	 add         lr, sp, #0xC
  00044	e28d4010	 add         r4, sp, #0x10
  00048	e3a03000	 mov         r3, #0
  0004c	e3a02000	 mov         r2, #0
  00050	e58d500c	 str         r5, [sp, #0xC]
  00054	e58de004	 str         lr, [sp, #4]
  00058	e58d4000	 str         r4, [sp]
  0005c	eb000000	 bl          RegQueryValueExW
  00060	e3500000	 cmp         r0, #0

; 107  :         {
; 108  :         KernelIoControl(IOCTL_PRCM_SET_SUSPENDSTATE, &state, sizeof(DWORD), NULL, 0, NULL);

  00064	059f0030	 ldreq       r0, [pc, #0x30]
  00068	03a0e000	 moveq       lr, #0
  0006c	03a03000	 moveq       r3, #0
  00070	03a02004	 moveq       r2, #4
  00074	028d1010	 addeq       r1, sp, #0x10
  00078	058de004	 streq       lr, [sp, #4]
  0007c	058de000	 streq       lr, [sp]
  00080	0b000000	 bleq        KernelIoControl

; 109  :         }
; 110  : 
; 111  :     RegCloseKey(hKey);

  00084	e59d0008	 ldr         r0, [sp, #8]
  00088	eb000000	 bl          RegCloseKey
  0008c		 |$cleanUp$37594|

; 112  : 
; 113  : cleanUp:
; 114  :     return rc;

  0008c	e3a00001	 mov         r0, #1

; 115  : }

  00090	e28dd014	 add         sp, sp, #0x14
  00094	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00098	e12fff1e	 bx          lr
  0009c		 |$LN9@Initialize|
  0009c		 |$LN10@Initialize|
  0009c	01f50fd0	 DCD         0x1f50fd0
  000a0		 |$LN11@Initialize|
  000a0	00000000	 DCD         |??_C@_1BK@CFNMIKKN@?$AAS?$AAu?$AAs?$AAp?$AAe?$AAn?$AAd?$AAS?$AAt?$AAa?$AAt?$AAe?$AA?$AA@|
  000a4		 |$M37762|

			 ENDP  ; |?InitializeSuspendState@@YAHPBG@Z|, InitializeSuspendState

	EXPORT	|?UpdateConstraint@@YAXPAUDevicePerformanceMapTbl_t@@H@Z| ; UpdateConstraint
	IMPORT	|PmxUpdateConstraint|

  00000			 AREA	 |.pdata|, PDATA
|$T37781| DCD	|$LN17@UpdateCons|
	DCD	0x40004d02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdateConstraint@@YAXPAUDevicePerformanceMapTbl_t@@H@Z| PROC ; UpdateConstraint

; 128  : {

  00000		 |$LN17@UpdateCons|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M37778|
  00008	e1a06000	 mov         r6, r0

; 129  :     DWORD i;
; 130  :     DWORD opm = (DWORD)kOpm0;
; 131  :     POWERDOMAIN_CONSTRAINT_INFO domainConstraint;
; 132  : 
; 133  :     // check domain states
; 134  :     if (pDeviceMap->powerDomain != POWERDOMAIN_NULL)

  0000c	e596500c	 ldr         r5, [r6, #0xC]
  00010	e3a0e000	 mov         lr, #0
  00014	e59f4114	 ldr         r4, [pc, #0x114]
  00018	e3750001	 cmn         r5, #1
  0001c	e58de000	 str         lr, [sp]
  00020	0a00002b	 beq         |$LN6@UpdateCons|

; 135  :         {
; 136  :         if (bPreNotify == TRUE && (s_DeviceMonitorInfo.domainMask & (1 << pDeviceMap->powerDomain)) == 0)

  00024	e3510001	 cmp         r1, #1
  00028	1a000012	 bne         |$LN8@UpdateCons|
  0002c	e5943018	 ldr         r3, [r4, #0x18]
  00030	e3a02001	 mov         r2, #1
  00034	e1130512	 tst         r3, r2, lsl r5
  00038	1a000025	 bne         |$LN6@UpdateCons|

; 137  :             {
; 138  :             // apply constraint if we don't already have a constraint
; 139  :             // on the power domain
; 140  : 
; 141  :             // initialize structure
; 142  :             domainConstraint.powerDomain = pDeviceMap->powerDomain;
; 143  :             domainConstraint.state = DEFAULT_ENABLE_DOMAIN_POWERSTATE;
; 144  :             domainConstraint.size = sizeof(POWERDOMAIN_CONSTRAINT_INFO);
; 145  : 
; 146  :             // apply constraint
; 147  :             PmxUpdateConstraint(s_DeviceMonitorInfo.hDomainConstraint, 
; 148  :                 CONSTRAINT_MSG_POWERDOMAIN_REQUEST, 
; 149  :                 &domainConstraint, 
; 150  :                 sizeof(POWERDOMAIN_CONSTRAINT_INFO)
; 151  :                 );

  0003c	e5940024	 ldr         r0, [r4, #0x24]
  00040	e3a0e002	 mov         lr, #2
  00044	e3a0700c	 mov         r7, #0xC
  00048	e3a0300c	 mov         r3, #0xC
  0004c	e28d2004	 add         r2, sp, #4
  00050	e3a01001	 mov         r1, #1
  00054	e58d5008	 str         r5, [sp, #8]
  00058	e58de00c	 str         lr, [sp, #0xC]
  0005c	e58d7004	 str         r7, [sp, #4]
  00060	eb000000	 bl          PmxUpdateConstraint

; 152  : 
; 153  :             // set domain mask
; 154  :             s_DeviceMonitorInfo.domainMask |= (1 << pDeviceMap->powerDomain);

  00064	e596200c	 ldr         r2, [r6, #0xC]
  00068	e5943018	 ldr         r3, [r4, #0x18]
  0006c	e3a01001	 mov         r1, #1
  00070	e1833211	 orr         r3, r3, r1, lsl r2
  00074	ea000014	 b           |$LN14@UpdateCons|
  00078		 |$LN8@UpdateCons|

; 155  :             }
; 156  :         else if (bPreNotify == FALSE && s_DeviceMonitorInfo.rgDomainCount[pDeviceMap->powerDomain] == 0)                 

  00078	e3510000	 cmp         r1, #0
  0007c	1a000014	 bne         |$LN6@UpdateCons|
  00080	e0843105	 add         r3, r4, r5, lsl #2
  00084	e5933050	 ldr         r3, [r3, #0x50]
  00088	e3530000	 cmp         r3, #0
  0008c	1a000010	 bne         |$LN6@UpdateCons|
  00090	e3e03cff	 mvn         r3, #0xFF, 24

; 157  :             {
; 158  :             // release constraint on domain if we no longer need it
; 159  : 
; 160  :             // initialize structure
; 161  :             domainConstraint.powerDomain = pDeviceMap->powerDomain;
; 162  :             domainConstraint.state = CONSTRAINT_STATE_NULL;
; 163  :             domainConstraint.size = sizeof(POWERDOMAIN_CONSTRAINT_INFO);
; 164  : 
; 165  :             // apply constraint
; 166  :             PmxUpdateConstraint(s_DeviceMonitorInfo.hDomainConstraint, 
; 167  :                 CONSTRAINT_MSG_POWERDOMAIN_REQUEST, 
; 168  :                 &domainConstraint, 
; 169  :                 sizeof(POWERDOMAIN_CONSTRAINT_INFO)
; 170  :                 );

  00094	e5940024	 ldr         r0, [r4, #0x24]
  00098	e22330ff	 eor         r3, r3, #0xFF
  0009c	e58d300c	 str         r3, [sp, #0xC]
  000a0	e3a0e00c	 mov         lr, #0xC
  000a4	e3a0300c	 mov         r3, #0xC
  000a8	e28d2004	 add         r2, sp, #4
  000ac	e3a01001	 mov         r1, #1
  000b0	e58d5008	 str         r5, [sp, #8]
  000b4	e58de004	 str         lr, [sp, #4]
  000b8	eb000000	 bl          PmxUpdateConstraint

; 171  : 
; 172  :             // clear domain mask
; 173  :             s_DeviceMonitorInfo.domainMask &= ~(1 << pDeviceMap->powerDomain);

  000bc	e596200c	 ldr         r2, [r6, #0xC]
  000c0	e5943018	 ldr         r3, [r4, #0x18]
  000c4	e3a01001	 mov         r1, #1
  000c8	e1c33211	 bic         r3, r3, r1, lsl r2
  000cc		 |$LN14@UpdateCons|
  000cc	e59de000	 ldr         lr, [sp]
  000d0	e5843018	 str         r3, [r4, #0x18]
  000d4		 |$LN6@UpdateCons|

; 174  :             }
; 175  :         }
; 176  : 
; 177  :     // check operating mode
; 178  :         for (i = (DWORD)kOpm0; i < (DWORD)kOpmCount; ++i)

  000d4	e3a02000	 mov         r2, #0
  000d8	e1a01004	 mov         r1, r4
  000dc		 |$LL5@UpdateCons|

; 179  :             {
; 180  :             if (s_DeviceMonitorInfo.rgOpmCount[i] > 0)

  000dc	e5913028	 ldr         r3, [r1, #0x28]

; 181  :                 {
; 182  :                 opm = i;

  000e0	e2811004	 add         r1, r1, #4
  000e4	e3530000	 cmp         r3, #0
  000e8	81a0e002	 movhi       lr, r2
  000ec	858d2000	 strhi       r2, [sp]
  000f0	e2822001	 add         r2, r2, #1
  000f4	e352000a	 cmp         r2, #0xA
  000f8	3afffff7	 bcc         |$LL5@UpdateCons|

; 183  :                 }
; 184  :             }
; 185  : 
; 186  :         // check if the constraint needs to be changed
; 187  :         if (opm != s_DeviceMonitorInfo.currentOpm)

  000fc	e594301c	 ldr         r3, [r4, #0x1C]
  00100	e15e0003	 cmp         lr, r3
  00104	0a000006	 beq         |$LN1@UpdateCons|

; 188  :             {
; 189  :             PmxUpdateConstraint(s_DeviceMonitorInfo.hDvfsConstraint, 
; 190  :                 CONSTRAINT_MSG_DVFS_REQUEST, 
; 191  :                 &opm, 
; 192  :                 sizeof(DWORD)
; 193  :                 );

  00108	e5940020	 ldr         r0, [r4, #0x20]
  0010c	e3a03004	 mov         r3, #4
  00110	e28d2000	 add         r2, sp, #0
  00114	e3a01001	 mov         r1, #1
  00118	eb000000	 bl          PmxUpdateConstraint

; 194  : 
; 195  :             s_DeviceMonitorInfo.currentOpm = opm;

  0011c	e59d3000	 ldr         r3, [sp]
  00120	e584301c	 str         r3, [r4, #0x1C]
  00124		 |$LN1@UpdateCons|

; 196  :             }
; 197  : 
; 198  : }

  00124	e28dd010	 add         sp, sp, #0x10
  00128	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0012c	e12fff1e	 bx          lr
  00130		 |$LN18@UpdateCons|
  00130		 |$LN19@UpdateCons|
  00130	00000000	 DCD         |s_DeviceMonitorInfo|
  00134		 |$M37779|

			 ENDP  ; |?UpdateConstraint@@YAXPAUDevicePerformanceMapTbl_t@@H@Z|, UpdateConstraint

	EXPORT	|?DEVMON_InitPolicy@@YAPAXPBG@Z|	; DEVMON_InitPolicy
	EXPORT	|??_C@_19BINEIDCP@?$AAD?$AAV?$AAF?$AAS?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1O@MGOKFMBN@?$AAP?$AAW?$AAR?$AAD?$AAO?$AAM?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|PmxSetConstraintById|
	IMPORT	|InitializeCriticalSection|
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T37794| DCD	|$LN5@DEVMON_Ini|
	DCD	0x40002e02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_19BINEIDCP@?$AAD?$AAV?$AAF?$AAS?$AA?$AA@| DCB "D", 0x0, "V", 0x0, "F"
	DCB	0x0, "S", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1O@MGOKFMBN@?$AAP?$AAW?$AAR?$AAD?$AAO?$AAM?$AA?$AA@| DCB "P", 0x0, "W"
	DCB	0x0, "R", 0x0, "D", 0x0, "O", 0x0, "M", 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DEVMON_InitPolicy@@YAPAXPBG@Z| PROC	; DEVMON_InitPolicy

; 210  : {

  00000		 |$LN5@DEVMON_Ini|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M37791|
  00008	e1a05000	 mov         r5, r0

; 211  :     DWORD dwLevel = CONSTRAINT_STATE_NULL;
; 212  :     POWERDOMAIN_CONSTRAINT_INFO domainConstraint;
; 213  :     
; 214  :     // initializt global structure
; 215  :     memset(&s_DeviceMonitorInfo, 0, sizeof(DeviceMonitorPolicyInfo_t));

  0000c	e59f60a0	 ldr         r6, [pc, #0xA0]
  00010	e3e03cff	 mvn         r3, #0xFF, 24
  00014	e22340ff	 eor         r4, r3, #0xFF
  00018	e1a00006	 mov         r0, r6
  0001c	e3a02078	 mov         r2, #0x78
  00020	e3a01000	 mov         r1, #0
  00024	e58d4000	 str         r4, [sp]
  00028	eb000000	 bl          memset

; 216  : 
; 217  :     s_DeviceMonitorInfo.currentOpm = kOpm0;
; 218  :     s_DeviceMonitorInfo.cookie = DEVMON_COOKIE;

  0002c	e59f307c	 ldr         r3, [pc, #0x7C]
  00030	e3a02000	 mov         r2, #0
  00034	e586201c	 str         r2, [r6, #0x1C]

; 219  :     InitializeCriticalSection(&s_DeviceMonitorInfo.cs);

  00038	e2860004	 add         r0, r6, #4
  0003c	e5863000	 str         r3, [r6]
  00040	eb000000	 bl          InitializeCriticalSection

; 220  : 
; 221  :     s_DeviceMonitorInfo.hDvfsConstraint = PmxSetConstraintById(
; 222  :         CONSTRAINT_ID_DVFS, 
; 223  :         CONSTRAINT_MSG_DVFS_REQUEST, 
; 224  :         &dwLevel,
; 225  :         sizeof(DWORD)
; 226  :         );

  00044	e59f0060	 ldr         r0, [pc, #0x60]
  00048	e3a03004	 mov         r3, #4
  0004c	e28d2000	 add         r2, sp, #0
  00050	e3a01001	 mov         r1, #1
  00054	eb000000	 bl          PmxSetConstraintById
  00058	e1a0e000	 mov         lr, r0

; 227  : 
; 228  :     // initialize domain constraint
; 229  :     domainConstraint.powerDomain = POWERDOMAIN_CORE;
; 230  :     domainConstraint.size = sizeof(POWERDOMAIN_CONSTRAINT_INFO);
; 231  :     domainConstraint.state = CONSTRAINT_STATE_NULL;
; 232  :     
; 233  :     s_DeviceMonitorInfo.hDomainConstraint = PmxSetConstraintById(
; 234  :         CONSTRAINT_ID_DOMAIN, 
; 235  :         CONSTRAINT_MSG_POWERDOMAIN_REQUEST, 
; 236  :         (void*)&domainConstraint, 
; 237  :         sizeof(POWERDOMAIN_CONSTRAINT_INFO)
; 238  :         );

  0005c	e59f0044	 ldr         r0, [pc, #0x44]
  00060	e3a07001	 mov         r7, #1
  00064	e3a0800c	 mov         r8, #0xC
  00068	e3a0300c	 mov         r3, #0xC
  0006c	e28d2004	 add         r2, sp, #4
  00070	e3a01001	 mov         r1, #1
  00074	e586e020	 str         lr, [r6, #0x20]
  00078	e58d7008	 str         r7, [sp, #8]
  0007c	e58d8004	 str         r8, [sp, #4]
  00080	e58d400c	 str         r4, [sp, #0xC]
  00084	eb000000	 bl          PmxSetConstraintById
  00088	e1a03000	 mov         r3, r0

; 239  :     
; 240  :     // initialize suspend state
; 241  :     InitializeSuspendState(szContext);

  0008c	e1a00005	 mov         r0, r5
  00090	e5863024	 str         r3, [r6, #0x24]
  00094	eb000000	 bl          |?InitializeSuspendState@@YAHPBG@Z|

; 242  : 
; 243  :     return (HANDLE)&s_DeviceMonitorInfo;
; 244  : } 

  00098	e1a00006	 mov         r0, r6
  0009c	e28dd010	 add         sp, sp, #0x10
  000a0	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000a4	e12fff1e	 bx          lr
  000a8		 |$LN6@DEVMON_Ini|
  000a8		 |$LN7@DEVMON_Ini|
  000a8	00000000	 DCD         |??_C@_1O@MGOKFMBN@?$AAP?$AAW?$AAR?$AAD?$AAO?$AAM?$AA?$AA@|
  000ac		 |$LN8@DEVMON_Ini|
  000ac	00000000	 DCD         |??_C@_19BINEIDCP@?$AAD?$AAV?$AAF?$AAS?$AA?$AA@|
  000b0		 |$LN9@DEVMON_Ini|
  000b0	646d6f6e	 DCD         0x646d6f6e
  000b4		 |$LN10@DEVMON_Ini|
  000b4	00000000	 DCD         |s_DeviceMonitorInfo|
  000b8		 |$M37792|

			 ENDP  ; |?DEVMON_InitPolicy@@YAPAXPBG@Z|, DEVMON_InitPolicy

	EXPORT	|?DEVMON_DeinitPolicy@@YAHPAX@Z|	; DEVMON_DeinitPolicy
	IMPORT	|DeleteCriticalSection|
	IMPORT	|PmxReleaseConstraint|

  00000			 AREA	 |.pdata|, PDATA
|$T37810| DCD	|$LN8@DEVMON_Dei|
	DCD	0x40000f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DEVMON_DeinitPolicy@@YAHPAX@Z| PROC	; DEVMON_DeinitPolicy

; 256  : {

  00000		 |$LN8@DEVMON_Dei|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37807|

; 257  :     BOOL rc = FALSE;
; 258  : 
; 259  :     // validate parameters
; 260  :     if (hPolicyAdapter != (HANDLE)&s_DeviceMonitorInfo) goto cleanUp;

  00004	e59f402c	 ldr         r4, [pc, #0x2C]
  00008	e3a03000	 mov         r3, #0
  0000c	e1500004	 cmp         r0, r4
  00010	1a000005	 bne         |$cleanUp$37644|

; 261  : 
; 262  :     // reset structure
; 263  :     if (s_DeviceMonitorInfo.hDvfsConstraint != NULL)

  00014	e5940020	 ldr         r0, [r4, #0x20]
  00018	e3500000	 cmp         r0, #0

; 264  :         {
; 265  :         PmxReleaseConstraint(s_DeviceMonitorInfo.hDvfsConstraint);

  0001c	1b000000	 blne        PmxReleaseConstraint

; 266  :         }
; 267  : 
; 268  :     DeleteCriticalSection(&s_DeviceMonitorInfo.cs);

  00020	e2840004	 add         r0, r4, #4
  00024	eb000000	 bl          DeleteCriticalSection

; 269  : 
; 270  :     rc = TRUE;

  00028	e3a03001	 mov         r3, #1
  0002c		 |$cleanUp$37644|

; 271  : 
; 272  : cleanUp:
; 273  :     return rc;
; 274  : } 

  0002c	e1a00003	 mov         r0, r3
  00030	e8bd4010	 ldmia       sp!, {r4, lr}
  00034	e12fff1e	 bx          lr
  00038		 |$LN9@DEVMON_Dei|
  00038		 |$LN10@DEVMON_Dei|
  00038	00000000	 DCD         |s_DeviceMonitorInfo|
  0003c		 |$M37808|

			 ENDP  ; |?DEVMON_DeinitPolicy@@YAHPAX@Z|, DEVMON_DeinitPolicy

	EXPORT	|?DEVMON_PreDeviceStateChange@@YAHPAXIII@Z| ; DEVMON_PreDeviceStateChange

  00000			 AREA	 |.pdata|, PDATA
|$T37827| DCD	|$LN14@DEVMON_Pre|
	DCD	0x40003201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DEVMON_PreDeviceStateChange@@YAHPAXIII@Z| PROC ; DEVMON_PreDeviceStateChange

; 289  : {

  00000		 |$LN14@DEVMON_Pre|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37824|
  00004	e1a0e001	 mov         lr, r1

; 290  :     // validate parameters
; 291  :     if (hPolicyAdapter != (HANDLE)&s_DeviceMonitorInfo) return FALSE;

  00008	e59f10b4	 ldr         r1, [pc, #0xB4]
  0000c	e1500001	 cmp         r0, r1
  00010	13a00000	 movne       r0, #0

; 327  : }

  00014	18bd4010	 ldmneia     sp!, {r4, lr}
  00018	112fff1e	 bxne        lr

; 292  : 
; 293  :     // record the new device state for the device
; 294  :     if (dev >= OMAP_DEVICE_GENERIC) return TRUE;

  0001c	e35e0049	 cmp         lr, #0x49
  00020	2a000023	 bcs         |$LN2@DEVMON_Pre|

; 295  : 
; 296  :     UPDATE_DEVICE_STATE(s_DevPerfTable, dev, newState);

  00024	e59f0094	 ldr         r0, [pc, #0x94]

; 297  :         
; 298  :     // D3 is the inflection point
; 299  :     if (newState < (UINT)D3 && oldState >= (UINT)D3)

  00028	e3530003	 cmp         r3, #3
  0002c	e080420e	 add         r4, r0, lr, lsl #4
  00030	e5843004	 str         r3, [r4, #4]
  00034	2a00000e	 bcs         |$LN10@DEVMON_Pre|
  00038	e3520003	 cmp         r2, #3
  0003c	3a00001c	 bcc         |$LN2@DEVMON_Pre|

; 300  :         {
; 301  :         // apply any constraints defined for device
; 302  :         //
; 303  :         s_DeviceMonitorInfo.rgOpmCount[s_DevPerfTable[dev].opm] += 1;

  00040	e5943008	 ldr         r3, [r4, #8]

; 304  : 
; 305  :         // update power domain states
; 306  :         if (s_DevPerfTable[dev].powerDomain != POWERDOMAIN_NULL)

  00044	e594400c	 ldr         r4, [r4, #0xC]
  00048	e0812103	 add         r2, r1, r3, lsl #2
  0004c	e5923028	 ldr         r3, [r2, #0x28]
  00050	e3740001	 cmn         r4, #1
  00054	e2833001	 add         r3, r3, #1
  00058	e5823028	 str         r3, [r2, #0x28]

; 307  :             {
; 308  :             s_DeviceMonitorInfo.rgDomainCount[s_DevPerfTable[dev].powerDomain] += 1;

  0005c	10812104	 addne       r2, r1, r4, lsl #2
  00060	15923050	 ldrne       r3, [r2, #0x50]

; 309  :             }
; 310  :         UpdateConstraint(&s_DevPerfTable[dev], TRUE);

  00064	e3a01001	 mov         r1, #1
  00068	12833001	 addne       r3, r3, #1
  0006c	15823050	 strne       r3, [r2, #0x50]
  00070	ea00000d	 b           |$LN11@DEVMON_Pre|
  00074		 |$LN10@DEVMON_Pre|

; 311  :         }
; 312  :     else if (newState >= (UINT)D3 && oldState < (UINT)D3)

  00074	e3520003	 cmp         r2, #3
  00078	2a00000d	 bcs         |$LN2@DEVMON_Pre|

; 313  :         {
; 314  :         // release any constraints defined for device
; 315  :         //
; 316  :         s_DeviceMonitorInfo.rgOpmCount[s_DevPerfTable[dev].opm] -= 1;

  0007c	e5943008	 ldr         r3, [r4, #8]

; 317  : 
; 318  :         // update power domain states
; 319  :         if (s_DevPerfTable[dev].powerDomain != POWERDOMAIN_NULL)

  00080	e594400c	 ldr         r4, [r4, #0xC]
  00084	e0812103	 add         r2, r1, r3, lsl #2
  00088	e5923028	 ldr         r3, [r2, #0x28]
  0008c	e3740001	 cmn         r4, #1
  00090	e2433001	 sub         r3, r3, #1
  00094	e5823028	 str         r3, [r2, #0x28]

; 320  :             {
; 321  :             s_DeviceMonitorInfo.rgDomainCount[s_DevPerfTable[dev].powerDomain] -= 1;

  00098	10812104	 addne       r2, r1, r4, lsl #2
  0009c	15923050	 ldrne       r3, [r2, #0x50]

; 322  :             }
; 323  :         UpdateConstraint(&s_DevPerfTable[dev], FALSE);

  000a0	e3a01000	 mov         r1, #0
  000a4	12433001	 subne       r3, r3, #1
  000a8	15823050	 strne       r3, [r2, #0x50]
  000ac		 |$LN11@DEVMON_Pre|
  000ac	e080020e	 add         r0, r0, lr, lsl #4
  000b0	eb000000	 bl          |?UpdateConstraint@@YAXPAUDevicePerformanceMapTbl_t@@H@Z|
  000b4		 |$LN2@DEVMON_Pre|

; 324  :         }
; 325  :     
; 326  :     return TRUE;

  000b4	e3a00001	 mov         r0, #1

; 327  : }

  000b8	e8bd4010	 ldmia       sp!, {r4, lr}
  000bc	e12fff1e	 bx          lr
  000c0		 |$LN15@DEVMON_Pre|
  000c0		 |$LN16@DEVMON_Pre|
  000c0	00000000	 DCD         |s_DevPerfTable|
  000c4		 |$LN17@DEVMON_Pre|
  000c4	00000000	 DCD         |s_DeviceMonitorInfo|
  000c8		 |$M37825|

			 ENDP  ; |?DEVMON_PreDeviceStateChange@@YAHPAXIII@Z|, DEVMON_PreDeviceStateChange

	EXPORT	|?DEVMON_PostDeviceStateChange@@YAHPAXIII@Z| ; DEVMON_PostDeviceStateChange

  00000			 AREA	 |.pdata|, PDATA
|$T37839| DCD	|$LN5@DEVMON_Pos|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DEVMON_PostDeviceStateChange@@YAHPAXIII@Z| PROC ; DEVMON_PostDeviceStateChange

; 342  : {

  00000		 |$LN5@DEVMON_Pos|
  00000		 |$M37836|

; 343  :     UNREFERENCED_PARAMETER(hPolicyAdapter);
; 344  :     UNREFERENCED_PARAMETER(dev);
; 345  :     UNREFERENCED_PARAMETER(oldState);
; 346  :     UNREFERENCED_PARAMETER(newState);
; 347  :     return FALSE;

  00000	e3a00000	 mov         r0, #0

; 348  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M37837|

			 ENDP  ; |?DEVMON_PostDeviceStateChange@@YAHPAXIII@Z|, DEVMON_PostDeviceStateChange

	EXPORT	|??0?$IndexList@K@@QAA@XZ|		; IndexList<unsigned long>::IndexList<unsigned long>
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\pm\inc\indexlist.h

  00000			 AREA	 |.pdata|, PDATA
|$T37849| DCD	|$LN5@IndexList|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0?$IndexList@K@@QAA@XZ| PROC	; IndexList<unsigned long>::IndexList<unsigned long>

; 51   :     IndexList()

  00000		 |$LN5@IndexList|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37846|
  00004	e1a04000	 mov         r4, r0

; 52   :     {        
; 53   :         memset(&m_Head, 0, sizeof(IndexData));

  00008	e3a02088	 mov         r2, #0x88
  0000c	e3a01000	 mov         r1, #0
  00010	eb000000	 bl          memset

; 54   :         m_maxIndex = INDEXED_CHUNK_SIZE - 1;

  00014	e3a0301f	 mov         r3, #0x1F
  00018	e5843088	 str         r3, [r4, #0x88]

; 55   :     }

  0001c	e1a00004	 mov         r0, r4
  00020	e8bd4010	 ldmia       sp!, {r4, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M37847|

			 ENDP  ; |??0?$IndexList@K@@QAA@XZ|, IndexList<unsigned long>::IndexList<unsigned long>

	EXPORT	|??1?$IndexList@K@@QAA@XZ|		; IndexList<unsigned long>::~IndexList<unsigned long>
	IMPORT	|??3@YAXPAX@Z|				; operator delete

  00000			 AREA	 |.pdata|, PDATA
|$T37862| DCD	|$LN9@IndexList@2|
	DCD	0x40000b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1?$IndexList@K@@QAA@XZ| PROC	; IndexList<unsigned long>::~IndexList<unsigned long>

; 58   :     {

  00000		 |$LN9@IndexList@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37859|

; 59   :         IndexData *pCurrent;
; 60   :         IndexData *pDelete;
; 61   : 
; 62   :         pCurrent = m_Head.pNext;

  00004	e5903000	 ldr         r3, [r0]
  00008	e1b04003	 movs        r4, r3

; 63   :         while (pCurrent != NULL)

  0000c	0a000004	 beq         |$LN1@IndexList@2|
  00010		 |$LL2@IndexList@2|

; 64   :             {
; 65   :             pDelete = pCurrent;

  00010	e1a00004	 mov         r0, r4

; 66   :             pCurrent = pCurrent->pNext;

  00014	e5944000	 ldr         r4, [r4]

; 67   :             delete pDelete;

  00018	eb000000	 bl          |??3@YAXPAX@Z|
  0001c	e3540000	 cmp         r4, #0
  00020	1afffffa	 bne         |$LL2@IndexList@2|
  00024		 |$LN1@IndexList@2|

; 68   :             }
; 69   :     }

  00024	e8bd4010	 ldmia       sp!, {r4, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$M37860|

			 ENDP  ; |??1?$IndexList@K@@QAA@XZ|, IndexList<unsigned long>::~IndexList<unsigned long>

	IMPORT	|atexit|

  00000			 AREA	 |.pdata|, PDATA
|$T37872| DCD	|$LN7@dynamic|
	DCD	0x40000e01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\am3517\pm\policyadapters\devmon\devmon.cpp

  00000			 AREA	 |.text$yc|, CODE, ARM

  00000		 |??__Es_IndexList@@YAXXZ| PROC		; `dynamic initializer for 's_IndexList''

; 54   : static IndexList<DWORD>             s_IndexList;

  00000		 |$LN7@dynamic|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37869|
  00004	e59f4028	 ldr         r4, [pc, #0x28]
  00008	e3a02088	 mov         r2, #0x88
  0000c	e3a01000	 mov         r1, #0
  00010	e1a00004	 mov         r0, r4
  00014	eb000000	 bl          memset
  00018	e59f0010	 ldr         r0, [pc, #0x10]
  0001c	e3a0301f	 mov         r3, #0x1F
  00020	e5843088	 str         r3, [r4, #0x88]
  00024	eb000000	 bl          atexit
  00028	e8bd4010	 ldmia       sp!, {r4, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$LN8@dynamic|
  00030		 |$LN9@dynamic|
  00030	00000000	 DCD         |??__Fs_IndexList@@YAXXZ|
  00034		 |$LN10@dynamic|
  00034	00000000	 DCD         |s_IndexList|
  00038		 |$M37870|

			 ENDP  ; |??__Es_IndexList@@YAXXZ|, `dynamic initializer for 's_IndexList''


  00000			 AREA	 |.pdata|, PDATA
|$T37896| DCD	|$LN12@dynamic@2|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text$yd|, CODE, ARM

  00000		 |??__Fs_IndexList@@YAXXZ| PROC		; `dynamic atexit destructor for 's_IndexList''
  00000		 |$LN12@dynamic@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37893|
  00004	e59f3020	 ldr         r3, [pc, #0x20]
  00008	e5934000	 ldr         r4, [r3]
  0000c	ea000002	 b           |$LN9@dynamic@2|
  00010		 |$LL4@dynamic@2|
  00010	e1a00004	 mov         r0, r4
  00014	e5944000	 ldr         r4, [r4]
  00018	eb000000	 bl          |??3@YAXPAX@Z|
  0001c		 |$LN9@dynamic@2|
  0001c	e3540000	 cmp         r4, #0
  00020	1afffffa	 bne         |$LL4@dynamic@2|
  00024	e8bd4010	 ldmia       sp!, {r4, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$LN13@dynamic@2|
  0002c		 |$LN14@dynamic@2|
  0002c	00000000	 DCD         |s_IndexList|
  00030		 |$M37894|

			 ENDP  ; |??__Fs_IndexList@@YAXXZ|, `dynamic atexit destructor for 's_IndexList''


  000f0			 AREA	 |.bss|, NOINIT
|s_IndexList| %	0x8c

  00000			 AREA	 |.CRT$XCU|, DATA
|s_IndexList$initializer$| DCD |??__Es_IndexList@@YAXXZ|
	END
