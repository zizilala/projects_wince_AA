ARM macroassembler      Page:1 
    1 00000000          ;/* 
    2 00000000          ;=============================================================================== 
    3 00000000          ;*             Texas Instruments OMAP(TM) Platform Software 
    4 00000000          ;* (c) Copyright Texas Instruments, Incorporated. All Rights Reserved. 
    5 00000000          ;* 
    6 00000000          ;* Use of this software is controlled by the terms and conditions found 
    7 00000000          ;* in the license agreement under which this software has been supplied. 
    8 00000000          ;* 
    9 00000000          ;=============================================================================== 
   10 00000000          ;*/ 
   11 00000000          ; 
   12 00000000          ;  File:  cpu.s 
   13 00000000            
   14 00000000                  INCLUDE kxarm.h 
    1 00000000          ; 
    2 00000000          ; Copyright (c) Microsoft Corporation.  All rights reserved. 
    3 00000000          ; 
    4 00000000          ; 
    5 00000000          ; Use of this sample source code is subject to the terms of the Microsoft 
    6 00000000          ; license agreement under which you licensed this sample source code. If 
    7 00000000          ; you did not accept the terms of the license agreement, you are not 
    8 00000000          ; authorized to use this sample source code. For the terms of the license, 
    9 00000000          ; please see the license agreement between you and Microsoft or, if applicable, 
   10 00000000          ; see the LICENSE.RTF on your install media or the root of your tools installation. 
   11 00000000          ; THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES. 
   12 00000000          ; 
   13 00000000          ;++ 
   14 00000000          ; 
   15 00000000          ; 
   16 00000000          ; Module Name: 
   17 00000000          ; 
   18 00000000          ;    kxarm.h 
   19 00000000          ; 
   20 00000000          ; Abstract: 
   21 00000000          ; 
   22 00000000          ;    This is an implementation of the WINCE/ARM Calling Sequence 
   23 00000000          ;    Specification. 
   24 00000000          ; 
   25 00000000          ; Environment: 
   26 00000000          ;    String Library 
   27 00000000          ; 
   28 00000000          ; Revision History: 
   29 00000000          ;-- 
   30 00000000            
   31 00000000                          GBLS    VBar 
   32 00000000          VBar    SETS    "|" 
   33 00000000                          GBLL    HaveExceptHandler 
   34 00000000                          GBLS    AreaName 
   35 00000000                          GBLS    FuncName 
   36 00000000                          GBLS    PrologName 
   37 00000000                          GBLS    FuncEndName 
   38 00000000                          GBLS    ExceptHandler 
   39 00000000                          GBLS    ExceptData 
   40 00000000          AreaName SETS   "|.text|" 
   41 00000000          HaveExceptHandler SETL {FALSE} 
   42 00000000            
   43 00000000                  MACRO 
   44 00000000                  TEXTAREA 
   45 00000000                  AREA |.text|,ALIGN=2,CODE,READONLY 
   46 00000000          AreaName SETS "|.text|" 
   47 00000000                  MEND 
   48 00000000            
   49 00000000              MACRO 
   50 00000000              THUMBAREA 
   51 00000000              AREA |.text|,ALIGN=2,CODE,READONLY,THUMB 
   52 00000000          AreaName SETS "|.text|" 
   53 00000000              MEND 
   54 00000000            
   55 00000000                  MACRO 
   56 00000000                  STARTUPTEXT 
   57 00000000                  AREA |.astart|,ALIGN=2,CODE 
   58 00000000          AreaName SETS "|.astart|" 
   59 00000000                  MEND 
   60 00000000            
   61 00000000                  MACRO 
   62 00000000                  START_REGION    $NameBegin 
   63 00000000                  LCLS    TempName 
   64 00000000          TempName SETS    VBar:CC:"$NameBegin":CC:VBar 
   65 00000000                  EXPORT  $TempName[DATA] 
   66 00000000          $TempName 
   67 00000000                  MEND 
   68 00000000            
   69 00000000                  MACRO 
   70 00000000                  END_REGION              $NameEnd 
   71 00000000                  LCLS    TempName 
   72 00000000          TempName SETS    VBar:CC:"$NameEnd":CC:VBar 
   73 00000000                  EXPORT  $TempName[DATA] 
   74 00000000          $TempName 
   75 00000000                  MEND 
   76 00000000            
   77 00000000          ; 
   78 00000000          ;   This macro should be used if the assembly function is in ARM 
   79 00000000          ; 
   80 00000000            
   81 00000000                  MACRO 
   82 00000000                  NESTED_ARMENTRY $Name 
   83 00000000          FuncName    SETS    VBar:CC:"$Name":CC:VBar 
   84 00000000          PrologName  SETS    VBar:CC:"$Name":CC:"_Prolog":CC:VBar 
   85 00000000          FuncEndName SETS    VBar:CC:"$Name":CC:"_end":CC:VBar 
   86 00000000                  LCLS    ExceptBit 
   87 00000000                  IF HaveExceptHandler 
   88 00000000          ExceptBit   SETS        "0x80000000" 
   89 00000000                  ELSE 
   90 00000000          ExceptBit   SETS        "0" 
   91 00000000                  ENDIF 
   92 00000000            
   93 00000000                  AREA |.pdata|,ALIGN=2,PDATA 
   94 00000000                  DCD         $FuncName 
   95 00000000              DCD     (($PrologName-$FuncName)/4) :OR: ((($FuncEndName-$FuncName)/4):SHL:8) :OR: 0x40000000 :OR: $ExceptBit 
   96 00000000                  AREA $AreaName,CODE,READONLY 
   97 00000000                  ALIGN   2 
   98 00000000                  EXPORT  $FuncName [FUNC] 
   99 00000000                  IF HaveExceptHandler 
  100 00000000              DCD $ExceptHandler 
  101 00000000              DCD $ExceptData 
  102 00000000          HaveExceptHandler SETL {FALSE} 
  103 00000000                  ENDIF 
  104 00000000          $FuncName 
  105 00000000                  ROUT 
  106 00000000                  MEND 
  107 00000000            
  108 00000000          ; 
  109 00000000          ;   This macro should be used if the assembly function is in THUMB 
  110 00000000          ; 
  111 00000000                  MACRO 
  112 00000000                  NESTED_THUMBENTRY       $Name 
  113 00000000          FuncName    SETS    VBar:CC:"$Name":CC:VBar 
  114 00000000          PrologName  SETS    VBar:CC:"$Name":CC:"_Prolog":CC:VBar 
  115 00000000          FuncEndName SETS    VBar:CC:"$Name":CC:"_end":CC:VBar 
  116 00000000                  LCLS    ExceptBit 
  117 00000000                  IF HaveExceptHandler 
  118 00000000          ExceptBit   SETS        "0x80000000" 
  119 00000000                  ELSE 
  120 00000000          ExceptBit   SETS        "0" 
  121 00000000                  ENDIF 
  122 00000000            
  123 00000000                  AREA |.pdata|,ALIGN=2,PDATA 
  124 00000000                  DCD         $FuncName 
  125 00000000              DCD     (($PrologName-$FuncName)/2) :OR: ((($FuncEndName-$FuncName)/2):SHL:8) :OR: $ExceptBit 
  126 00000000                  AREA $AreaName,CODE,READONLY 
  127 00000000                  ALIGN   2 
  128 00000000                  EXPORT  $FuncName [FUNC] 
  129 00000000                  IF HaveExceptHandler 
  130 00000000              DCD $ExceptHandler 
  131 00000000              DCD $ExceptData 
  132 00000000          HaveExceptHandler SETL {FALSE} 
  133 00000000                  ENDIF 
  134 00000000          $FuncName 
  135 00000000                  ROUT 
  136 00000000                  MEND 
  137 00000000            
  138 00000000          ; 
  139 00000000          ;   This macro should be used if the assembly function is in ARM 
  140 00000000          ; 
  141 00000000                  MACRO 
  142 00000000                  NESTED_ENTRY    $Name 
  143 00000000          FuncName    SETS    VBar:CC:"$Name":CC:VBar 
  144 00000000          PrologName  SETS    VBar:CC:"$Name":CC:"_Prolog":CC:VBar 
  145 00000000          FuncEndName SETS    VBar:CC:"$Name":CC:"_end":CC:VBar 
  146 00000000                  LCLS    ExceptBit 
  147 00000000                  IF HaveExceptHandler 
  148 00000000          ExceptBit   SETS        "0x80000000" 
  149 00000000                  ELSE 
  150 00000000          ExceptBit   SETS        "0" 
  151 00000000                  ENDIF 
  152 00000000            
  153 00000000                  AREA |.pdata|,ALIGN=2,PDATA 
  154 00000000                  DCD         $FuncName 
  155 00000000              DCD     (($PrologName-$FuncName)/4) :OR: ((($FuncEndName-$FuncName)/4):SHL:8) :OR: 0x40000000 :OR: $ExceptBit 
  156 00000000                  AREA $AreaName,CODE,READONLY 
  157 00000000                  ALIGN   2 
  158 00000000                  EXPORT  $FuncName [FUNC] 
  159 00000000                  IF HaveExceptHandler 
  160 00000000              DCD $ExceptHandler 
  161 00000000              DCD $ExceptData 
  162 00000000          HaveExceptHandler SETL {FALSE} 
  163 00000000                  ENDIF 
  164 00000000          $FuncName 
  165 00000000                  ROUT 
  166 00000000                  MEND 
  167 00000000            
  168 00000000                  MACRO 
  169 00000000                  PROLOG_END 
  170 00000000          $PrologName 
  171 00000000                  MEND 
  172 00000000            
  173 00000000                  MACRO 
  174 00000000                  LEAF_ENTRY      $Name 
  175 00000000          FuncName SETS    VBar:CC:"$Name":CC:VBar 
  176 00000000          PrologName SETS "Invalid Prolog" 
  177 00000000          FuncEndName SETS    VBar:CC:"$Name":CC:"_end":CC:VBar 
  178 00000000                  ALIGN   2 
  179 00000000                  EXPORT  $FuncName [FUNC] 
  180 00000000          $FuncName 
  181 00000000                  ROUT 
  182 00000000                  MEND 
  183 00000000            
  184 00000000                  MACRO 
  185 00000000                  ALTERNATE_ENTRY $Name 
  186 00000000                  LCLS    TempName 
  187 00000000          TempName SETS    VBar:CC:"$Name":CC:VBar 
  188 00000000                  EXPORT  $TempName [FUNC] 
  189 00000000          $TempName 
  190 00000000                  MEND 
  191 00000000            
  192 00000000                  MACRO 
  193 00000000                  ENTRY_END       $Name 
  194 00000000          $FuncEndName 
  195 00000000                  MEND 
  196 00000000            
  197 00000000                  MACRO 
  198 00000000                  EXCEPTION_HANDLER       $Handler 
  199 00000000          ExceptHandler SETS    VBar:CC:"$Handler":CC:VBar 
  200 00000000          ExceptData SETS "0" 
  201 00000000          HaveExceptHandler SETL {TRUE} 
  202 00000000                  MEND 
  203 00000000            
  204 00000000                  MACRO 
  205 00000000                  EXCEPTION_HANDLER_DATA  $Handler, $HandlerData 
  206 00000000          ExceptHandler SETS    VBar:CC:"$Handler":CC:VBar 
  207 00000000          ExceptData SETS    VBar:CC:"$HandlerData":CC:VBar 
  208 00000000          HaveExceptHandler SETL {TRUE} 
  209 00000000                  MEND 
  210 00000000            
  211 00000000                  MACRO 
  212 00000000                  EXCEPTION_HANDLER_MILLICODE     $Handler, $HandlerData 
  213 00000000          ExceptHandler SETS    "$Handler" 
  214 00000000          ExceptData SETS    "$HandlerData" 
  215 00000000          HaveExceptHandler SETL {TRUE} 
  216 00000000                  MEND 
  217 00000000            
  218 00000000            
  219 00000000                  END 
   15 00000000                  INCLUDE armmacros.s 
    1 00000000          ; 
    2 00000000          ; Copyright (c) Microsoft Corporation.  All rights reserved. 
    3 00000000          ; 
    4 00000000          ; 
    5 00000000          ; Use of this sample source code is subject to the terms of the Microsoft 
    6 00000000          ; license agreement under which you licensed this sample source code. If 
    7 00000000          ; you did not accept the terms of the license agreement, you are not 
    8 00000000          ; authorized to use this sample source code. For the terms of the license, 
    9 00000000          ; please see the license agreement between you and Microsoft or, if applicable, 
   10 00000000          ; see the LICENSE.RTF on your install media or the root of your tools installation. 
   11 00000000          ; THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES. 
   12 00000000          ; 
   13 00000000            
   14 00000000          ;/*********************************************************************** 
   15 00000000          ;  Copyright (c) ARM Limited 1998.  All rights reserved. 
   16 00000000          ; 
   17 00000000          ; NOTE: The CALL and CALLEQ macros shouldn't be used in OS startup code 
   18 00000000          ;       before the MMU is enabled since in the Thumbing case it relies 
   19 00000000          ;       on an absolute address which will be virtual in the case of the 
   20 00000000          ;       OS code and if the MMU isn't enabled, all branches should be 
   21 00000000          ;       relative (or a computed physical address). 
   22 00000000          ; 
   23 00000000          ;***********************************************************************/ 
   24 00000000            
   25 00000000            IF Interworking :LOR: Thumbing 
   26 00000000            
   27 00000000              MACRO 
   28 00000000              CALL $Fn 
   29 00000000              ldr     r12, =$Fn 
   30 00000000              mov     lr, pc 
   31 00000000              bx      r12 
   32 00000000              MEND 
   33 00000000            
   34 00000000              MACRO 
   35 00000000              CALLEQ $Fn 
   36 00000000              ldreq   r12, =$Fn 
   37 00000000              moveq   lr, pc 
   38 00000000              bxeq    r12 
   39 00000000              MEND 
   40 00000000            
   41 00000000              MACRO 
   42 00000000              RETURN 
   43 00000000              bx      lr 
   44 00000000              MEND 
   45 00000000            
   46 00000000              MACRO 
   47 00000000              RETURN_EQ 
   48 00000000              bxeq    lr 
   49 00000000              MEND 
   50 00000000            
   51 00000000              MACRO 
   52 00000000              RETURN_NE 
   53 00000000              bxne    lr 
   54 00000000              MEND 
   55 00000000            
   56 00000000            ELSE 
   83 00000000            ENDIF 
   84 00000000            
   85 00000000              END  
   16 00000000                  INCLUDE am3517_const.inc 
    1 00000000          ; All rights reserved ADENEO EMBEDDED 2010 
    2 00000000          ; 
    3 00000000          ;============================================================================== 
    4 00000000          ;             Texas Instruments OMAP(TM) Platform Software 
    5 00000000          ; (c) Copyright Texas Instruments, Incorporated. All Rights Reserved. 
    6 00000000          ; 
    7 00000000          ; Use of this software is controlled by the terms and conditions found 
    8 00000000          ; in the license agreement under which this software has been supplied. 
    9 00000000          ; 
   10 00000000          ;============================================================================== 
   11 00000000          ; 
   12 00000000          ; 
   13 00000000          ;  File: omap35xx_const.inc 
   14 00000000          ; 
   15 00000000            
   16 00000000          ;------------------------------------------------------------------------------ 
   17 00000000          ; Physical Address of Registers 
   18 00000000          OMAP_CONTEXT_RESTORE_REGS_PA    EQU 0x48002910 
   19 00000000          OMAP_SDRC_REGS_PA               EQU 0x6D000000 
   20 00000000            
   21 00000000          ;------------------------------------------------------------------------------ 
   22 00000000          ; Useful constants 
   23 00000000          WFI                             EQU 0xE320F003 
   24 00000000          SMI                             EQU 0xE1600070 
   25 00000000          SMI_INVAL_L2                    EQU 0x0001 
   26 00000000            
   27 00000000          ;------------------------------------------------------------------------------ 
   28 00000000          ; following offset must be kept in sync with the CPUIDLE_INFO data structure 
   29 00000000          ; defined in oal_prcm.h 
   30 00000000            
   31 00000000          SDRC_REGS_OFFSET                EQU 0x0000 
   32 00000000          MPU_CM_REGS_OFFSET              EQU 0x0004 
   33 00000000          CORE_CM_REGS_OFFSET             EQU 0x0008 
   34 00000000          CLOCK_CTRL_CM_REGS_OFFSET       EQU 0x000C 
   35 00000000          GPTIMER_REGS_OFFSET             EQU 0x0010 
   36 00000000          MPU_PRM_REGS_OFFSET             EQU 0x0014 
   37 00000000          CORE_PRM_REGS_OFFSET            EQU 0x0018 
   38 00000000          GLOBAL_PRM_REGS_OFFSET                  EQU     0x001C 
   39 00000000          MPU_CONTEXT_PA_OFFSET           EQU 0x0020 
   40 00000000          MPU_CONTEXT_VA_OFFSET           EQU 0x0024 
   41 00000000          SDRC_HIGH_RFR_FREQ_OFFSET       EQU 0x0028 
   42 00000000          SDRC_LOW_RFR_FREQ_OFFSET        EQU 0x002C 
   43 00000000          TLB_INV_FUNC_ADDR_OFFSET        EQU 0x0030 
   44 00000000            
   45 00000000          ;------------------------------------------------------------------------------ 
   46 00000000            
   47 00000000          SDRC_SYSCONFIG_OA               EQU 0x0010 
   48 00000000          SDRC_MR_0_OA                    EQU 0x0084 
   49 00000000          SDRC_MR_1_OA                    EQU 0x00B4 
   50 00000000            
   51 00000000          SDRC_EMR2_0_OA                  EQU 0x008C 
   52 00000000          SDRC_EMR2_1_OA                  EQU 0x00BC 
   53 00000000            
   54 00000000          SDRC_MANUAL_0_OA                EQU 0x00A8 
   55 00000000          SDRC_MANUAL_1_OA                EQU 0x00D8 
   56 00000000            
   57 00000000          SDRC_POWER_OA                   EQU 0x0070  ; enable/disable SDRAM self-refresh 
   58 00000000          SDRC_DLLA_CTRL_OA               EQU 0x0060 
   59 00000000          SDRC_DLLA_STATUS_OA             EQU 0x0064 
   60 00000000          SDRC_RFR_CTRL_0_OA              EQU 0x00A4 
   61 00000000          SDRC_RFR_CTRL_1_OA              EQU 0x00D4 
   62 00000000            
   63 00000000          SDRC_MANUAL_AUTOREFRESH_CMD     EQU 0x0002 
   64 00000000            
   65 00000000          SDRC_POWER_CLKCTRL_MASK         EQU 0x0003 
   66 00000000            
   67 00000000          SDRC_SYSCONFIG_MRS_BIT          EQU 0x0100 
   68 00000000            
   69 00000000          SDRC_DLL_DLLIDLE_BIT            EQU 0x0004 
   70 00000000          SDRC_DLL_ENADLL_BIT             EQU 0x0003 
   71 00000000          SDRC_DLL_LOCKDLL_BIT            EQU 0x0002 
   72 00000000          SDRC_DLL_DLLPHASE_BIT           EQU 0x0001 
   73 00000000          SDRC_DLL_TIMING_WAIT_COUNT      EQU 0x0800 
   74 00000000            
   75 00000000          SDRC_DLLA_STATUS_UNLOCKED       EQU 0x0000 
   76 00000000          SDRC_DLLA_STATUS_LOCKED         EQU 0x0004 
   77 00000000            
   78 00000000          SDRC_RFR_CTRL0_ARE_SHIFT        EQU 0x0000 
   79 00000000          SDRC_RFR_CTRL0_ARCV_SHIFT       EQU 0x0008 
   80 00000000            
   81 00000000          SDRC_ENABLE_ICLK                EQU 0x0001 
   82 00000000          SDRC_DISABLE_ICLK               EQU 0x0000 
   83 00000000            
   84 00000000          SDRAM_REFRESH_DELAY_VAL         EQU 0x1000  ; time to wait for autorefresh 
   85 00000000            
   86 00000000          ;------------------------------------------------------------------------------ 
   87 00000000          CM_CLKEN_PLL_OA                 EQU 0x0000 
   88 00000000          CM_IDLEST_CKGEN_OA              EQU 0x0020 
   89 00000000          CM_IDLEST_PLL_MPU_OA            EQU 0x0024 
   90 00000000          CM_CLKSEL1_PLL_OA               EQU 0x0040 
   91 00000000            
   92 00000000          CM_IDLEST_ST_MPU_CLK_BIT        EQU 0x0001 
   93 00000000            
   94 00000000          CM_CLKSEL1_PLL_M2_SHIFT         EQU 0x001B 
   95 00000000            
   96 00000000          CM_CLKEN_PLL_DPLL_LOWBYPASS     EQU 0x0005 
   97 00000000          CM_CLKEN_PLL_DPLL_HIGHBYPASS    EQU 0x0006 
   98 00000000          CM_CLKEN_PLL_DPLL_LOCKED        EQU 0x0007 
   99 00000000          CM_CLKEN_PLL_DPLL_MASK          EQU 0x0007 
  100 00000000            
  101 00000000          DVFS_LOW_OPP_STALL              EQU 0x0000 
  102 00000000          DVFS_HIGH_OPP_STALL             EQU 0x0010 ;0x00C8 
  103 00000000            
  104 00000000          ;------------------------------------------------------------------------------ 
  105 00000000          CM_CLKSTST_CORE_OA              EQU 0x004C 
  106 00000000          CM_ICLKEN1_CORE_OA              EQU 0x0010 
  107 00000000          CM_IDLEST1_CORE_OA              EQU 0x0020 
  108 00000000            
  109 00000000          CM_CLKSTST_CLKACTIVITY_L3_BIT   EQU 0x0001 
  110 00000000          CM_ICLKEN1_CORE_SDRC_BIT        EQU 0x0001 
  111 00000000            
  112 00000000          ;------------------------------------------------------------------------------ 
  113 00000000          PRM_PWRSTCTRL_MPU_OA            EQU 0x00E0 
  114 00000000            
  115 00000000          ;------------------------------------------------------------------------------ 
  116 00000000          PRM_LOGICL1CACHERETSTATE_VAL    EQU 0x0004 
  117 00000000          PRM_POWERSTATE_MASK             EQU 0x0003 
  118 00000000          PRM_POWERSTATE_OFF_VAL          EQU 0x0000 
  119 00000000          PRM_POWERSTATE_RET_VAL          EQU 0x0001 
  120 00000000          PRM_POWERSTATE_ON_VAL           EQU 0x0003 
  121 00000000            
  122 00000000          ;------------------------------------------------------------------------------ 
  123 00000000          TIMER_TCRR_OA                   EQU 0x0028  ; tcrr offset for gptimer1 
  124 00000000            
  125 00000000          ;------------------------------------------------------------------------------ 
  126 00000000          ; location of restore register and offsets to the various fields. 
  127 00000000          ; Must be kept in sync with OMAP_CONTEXT_RESTORE_REGS structure 
  128 00000000          OEM_CPU_INFO_PA_OFFSET          EQU 0x1C 
  129 00000000          OEM_CPU_INFO_UA_OFFSET          EQU 0x20 
  130 00000000            
  131 00000000          ;------------------------------------------------------------------------------ 
  132 00000000          ; useful ARM masks 
  133 00000000          IRQ_MASK                        EQU 0x80    ; IRQ mask value 
  134 00000000          FIQ_MASK                        EQU 0x40    ; FIQ mask value 
  135 00000000          MODE_MASK                       EQU 0x1F    ; Processor Mode Mask 
  136 00000000          TBIT_MASK                       EQU 0x20    ; Thumb mode bit mask  
  137 00000000            
  138 00000000          ;------------------------------------------------------------------------------ 
  139 00000000          ; ARM modes 
  140 00000000          USR_MODE                        EQU 0X10    ; user mode 
  141 00000000          FIQ_MODE                        EQU 0x11    ; Fast Interrupt Mode (FIQ) 
  142 00000000          IRQ_MODE                        EQU 0x12    ; Interrupt Mode (IRQ) 
  143 00000000          SUP_MODE                        EQU 0x13    ; Supervisor Mode 
  144 00000000          ABORT_MODE                      EQU 0x17    ; Abort Mode 
  145 00000000          UNDEF_MODE                      EQU 0x1B    ; undef Mode 
  146 00000000          SYS_MODE                        EQU 0x1F    ; sys Mode 
  147 00000000            
  148 00000000          ;------------------------------------------------------------------------------ 
  149 00000000          ; Cache related constants 
  150 00000000          ICACHE_MASK                     EQU 0x1000 
  151 00000000          DCACHE_MASK                     EQU 0x0004 
  152 00000000          MAX_ASSOCIATIVITY               EQU 0x03FF  ; max val of associativity (10-bit) 
  153 00000000          MAX_SETNUMBER                   EQU 0x7FFF  ; max val for set number (15-bit) 
  154 00000000            
  155 00000000          ;------------------------------------------------------------------------------ 
  156 00000000          ; MMU related constants 
  157 00000000          MMU_MASK                        EQU 0x0001 
  158 00000000          DESC_MASK                       EQU 0x0003 
  159 00000000          PTL1_SECTION                    EQU 0x0002  
  160 00000000          PTL1_KRW                        EQU 0x0400  ; bits 10, 11 
  161 00000000          TTBRBIT_MASK                    EQU 0xFFFFC000 
  162 00000000          MB_BOUNDARY                     EQU 0xFFF00000 
  163 00000000          WINCE_FIRSTPT                   EQU 0xFFFD0000 ; from armhigh.inc 
  164 00000000            
  165 00000000          ;------------------------------------------------------------------------------ 
  166 00000000            
  167 00000000                  END 
   17 00000000            
   18 00000000                  EXPORT OALCPUStart 
   19 00000000                  EXPORT OALCPUIdle 
   20 00000000                  EXPORT OALCPUEnd 
   21 00000000                  EXPORT OALUpdateCoreFreq 
   22 00000000                  EXPORT OALInvalidateTlb 
   23 00000000                  EXPORT OALGetTTBR 
   24 00000000                  EXPORT INTERRUPTS_STATUS 
   25 00000000            
   26 00000000                  TEXTAREA 
   45                           AREA |.text|,ALIGN=2,CODE,READONLY 
   46 00000000          AreaName SETS "|.text|" 
   27 00000000            
   28 00000000          BEGIN_REGION 
   29 00000000            
   30 00000000            
   31 00000000                  ;ldr         r5, =0x480025e0 
   32 00000000                  ;ldr         r1, =0xFFFF0000 
   33 00000000                  ;ldr         r2, =0x1C 
   34 00000000                  ;ldr         r3, [r5] 
   35 00000000                  ;and         r3, r3, r1 
   36 00000000                  ;orr         r3, r3, r2 
   37 00000000                  ;str         r3, [r5] 
   38 00000000            
   39 00000000                   
   40 00000000          ;------------------------------------------------------------------------------- 
   41 00000000          ; 
   42 00000000          ;  Function:  OALCPUStart 
   43 00000000          ; 
   44 00000000          ;  Marker indicating the start of cpu specific assembly. Never should get called 
   45 00000000          ; 
   46 00000000           LEAF_ENTRY OALCPUStart 
  175 00000000          FuncName SETS    VBar:CC:"OALCPUStart":CC:VBar 
  176 00000000          PrologName SETS "Invalid Prolog" 
  177 00000000          FuncEndName SETS    VBar:CC:"OALCPUStart":CC:"_end":CC:VBar 
  178 00000000                  ALIGN   2 
  179 00000000                  EXPORT  |OALCPUStart| [FUNC] 
  180 00000000          |OALCPUStart| 
  181 00000000                  ROUT 
   47 00000000 e1a00000         nop         
   48 00000004           ENTRY_END OALCPUStart 
  194 00000004          |OALCPUStart_end| 
   49 00000004          ;------------------------------------------------------------------------------- 
   50 00000004            
   51 00000004          ;------------------------------------------------------------------------------- 
   52 00000004          ; 
   53 00000004          ;  constants 
   54 00000004          ; 
   55 00000004          max_assoc 
   56 00000004 000003ff        DCD         MAX_ASSOCIATIVITY 
   57 00000008            
   58 00000008          max_setnum 
   59 00000008 00007fff        DCD         MAX_SETNUMBER          
   60 0000000c          ;------------------------------------------------------------------------------- 
   61 0000000c            
   62 0000000c          ;------------------------------------------------------------------------------- 
   63 0000000c          ; 
   64 0000000c          ;  Function:  SaveContext 
   65 0000000c          ; 
   66 0000000c          ;  This function puts the mpu to OFF 
   67 0000000c          ; 
   68 0000000c          SaveContext 
   69 0000000c                                                  ;-------------------------------------- 
   70 0000000c                                                  ; save sp before modifiying the stack 
   71 0000000c e1a0100d         mov        r1, sp    
   72 00000010 e92d5ff8         stmdb      sp!, {r3 - r12, lr}  
   73 00000014            
   74 00000014                                                  ;-------------------------------------- 
   75 00000014                                                  ; save content of all registers           
   76 00000014 e14f2000         mrs        r2, SPSR 
   77 00000018                                                  ;-------------------------------------- 
   78 00000018                                                  ; save the stack pointer stored in r1 
   79 00000018 e1a03001         mov        r3, r1 
   80 0000001c e8a0000c         stmia      r0!, {r2 - r3} 
   81 00000020                                                  ;-------------------------------------- 
   82 00000020                                                  ; save coprocessor access control reg 
   83 00000020 ee111f50         mrc        p15, 0, r1, c1, c0, 2 
   84 00000024            
   85 00000024                                                  ;-------------------------------------- 
   86 00000024                                                  ; save TTBR0, TTBR1, Trans. tbl base 
   87 00000024 ee122f10         mrc        p15, 0, r2, c2, c0, 0 
   88 00000028 ee123f30         mrc        p15, 0, r3, c2, c0, 1 
   89 0000002c ee124f50         mrc        p15, 0, r4, c2, c0, 2 
   90 00000030                   
   91 00000030                                                  ;-------------------------------------- 
   92 00000030                                                  ; Data TLB lockdown, instr. TLB lockdown 
   93 00000030 ee1a5f10         mrc        p15, 0, r5, c10, c0, 0 
   94 00000034 ee1a6f30         mrc        p15, 0, r6, c10, c0, 1 
   95 00000038 e8a0007e         stmia      r0!, {r1-r6} 
   96 0000003c            
   97 0000003c                                                  ;-------------------------------------- 
   98 0000003c                                                  ; Primary remap, normal remap regs. 
   99 0000003c ee1a1f12         mrc        p15, 0, r1, c10, c2, 0         
  100 00000040 ee1a2f32         mrc        p15, 0, r2, c10, c2, 1 
  101 00000044            
  102 00000044                                                  ;-------------------------------------- 
  103 00000044                                                  ; secure/non-secure vector base address 
  104 00000044                                                  ; FCSE PI, Context PID 
  105 00000044 ee1c3f10         mrc        p15, 0, r3, c12, c0, 0 
  106 00000048 ee1d4f10         mrc        p15, 0, r4, c13, c0, 0 
  107 0000004c ee1d5f30         mrc        p15, 0, r5, c13, c0, 1 
  108 00000050 e8a0003e         stmia      r0!, {r1 - r5} 
  109 00000054                                                  ;-------------------------------------- 
  110 00000054                                                  ; domain access control reg 
  111 00000054                                                  ; data status fault, inst. status fault 
  112 00000054                                                  ; data aux fault status,  
  113 00000054                                                  ; intr. aux fault status, 
  114 00000054                                                  ; data fault addr, instr fault addr 
  115 00000054 ee131f10         mrc        p15, 0, r1, c3, c0, 0 
  116 00000058 ee152f10         mrc        p15, 0, r2, c5, c0, 0 
  117 0000005c ee153f30         mrc        p15, 0, r3, c5, c0, 1 
  118 00000060 ee154f11         mrc        p15, 0, r4, c5, c1, 0 
  119 00000064 ee155f31         mrc        p15, 0, r5, c5, c1, 1 
  120 00000068 ee166f10         mrc        p15, 0, r6, c6, c0, 0 
  121 0000006c ee167f50         mrc        p15, 0, r7, c6, c0, 2 
  122 00000070 e8a000fe         stmia      r0!, {r1 - r7} 
  123 00000074            
  124 00000074                                                  ;-------------------------------------- 
  125 00000074                                                  ; user r/w thread & proc id 
  126 00000074                                                  ; user r/o thread and proc id 
  127 00000074                                                  ; priv only thread and proc id 
  128 00000074                                                  ; cache size selction 
  129 00000074 ee1d1f50         mrc        p15, 0, r1, c13, c0, 2 
  130 00000078 ee1d2f70         mrc        p15, 0, r2, c13, c0, 3 
  131 0000007c ee1d3f90         mrc        p15, 0, r3, c13, c0, 4                                         
  132 00000080 ee504f10         mrc        p15, 2, r4, c0, c0, 0 
  133 00000084 e8a0001e         stmia      r0!, {r1 - r4} 
  134 00000088            
  135 00000088            
  136 00000088                                                  ;-------------------------------------- 
  137 00000088                                                  ; save all modes 
  138 00000088 e10f3000         mrs        r3, cpsr 
  139 0000008c                                                  ;-------------------------------------- 
  140 0000008c                                                  ; fiq mode 
  141 0000008c e3c3101f         bic        r1, r3, #MODE_MASK 
  142 00000090 e3811011         orr        r1, r1, #FIQ_MODE 
  143 00000094 e129f001         msr        cpsr, r1 
  144 00000098 e14f7000         mrs        r7, spsr 
  145 0000009c e8a07f80         stmia      r0!, {r7 - r14} 
  146 000000a0                                                  ;-------------------------------------- 
  147 000000a0                                                  ; irq mode 
  148 000000a0 e3c3101f         bic        r1, r3, #MODE_MASK 
  149 000000a4 e3811012         orr        r1, r1, #IRQ_MODE 
  150 000000a8 e129f001         msr        cpsr, r1 
  151 000000ac e14f7000         mrs        r7, spsr 
  152 000000b0 e8a06080         stmia      r0!, {r7, r13, r14} 
  153 000000b4                                                  ;-------------------------------------- 
  154 000000b4                                                  ; abort mode 
  155 000000b4 e3c3101f         bic        r1, r3, #MODE_MASK 
  156 000000b8 e3811017         orr        r1, r1, #ABORT_MODE 
  157 000000bc e129f001         msr        cpsr, r1 
  158 000000c0 e14f7000         mrs        r7, spsr 
  159 000000c4 e8a06080         stmia      r0!, {r7, r13, r14} 
  160 000000c8                                                  ;-------------------------------------- 
  161 000000c8                                                  ; undef mode 
  162 000000c8 e3c3101f         bic        r1, r3, #MODE_MASK 
  163 000000cc e381101b         orr        r1, r1, #UNDEF_MODE 
  164 000000d0 e129f001         msr        cpsr, r1 
  165 000000d4 e14f7000         mrs        r7, spsr 
  166 000000d8 e8a06080         stmia      r0!, {r7, r13, r14} 
  167 000000dc                                                  ;-------------------------------------- 
  168 000000dc                                                  ; system/user mode 
  169 000000dc e3c3101f         bic        r1, r3, #MODE_MASK 
  170 000000e0 e381101f         orr        r1, r1, #SYS_MODE 
  171 000000e4 e129f001         msr        cpsr, r1 
  172 000000e8 e14f7000         mrs        r7, spsr 
  173 000000ec e8a06080         stmia      r0!, {r7, r13, r14} 
  174 000000f0                                                  ;-------------------------------------- 
  175 000000f0                                                  ; original mode 
  176 000000f0 e129f003         msr        CPSR, r3 
  177 000000f4                                                  ;-------------------------------------- 
  178 000000f4                                                  ; control register 
  179 000000f4 ee114f10         mrc        p15, 0, r4, c1, c0, 0 
  180 000000f8 e8a00018         stmia      r0!, {r3, r4} 
  181 000000fc                                                  ;-------------------------------------- 
  182 000000fc                                                  ; need to flush all cache, copied 
  183 000000fc                                                  ; from cache code 
  184 000000fc ee300f30         mrc     p15, 1, r0, c0, c0, 1   ; read clidr 
  185 00000100 e2103407         ands    r3, r0, #0x7000000   
  186 00000104 e1a03ba3         mov     r3, r3, lsr #23         ; cache level value 
  187 00000108 0a00001b         beq     donea                
  188 0000010c            
  189 0000010c e3a0a000         mov     r10, #0                 ; start clean at cache level 0 
  190 00000110 e08a20aa loop1a  add     r2, r10, r10, lsr #1    ; work out 3x current cache level 
  191 00000114 e1a01230         mov     r1, r0, lsr r2          ; extract cache type bits from clidr 
  192 00000118 e2011007         and     r1, r1, #7              ; mask of the bits for current cache only 
  193 0000011c e3510002         cmp     r1, #2                  ; see what cache we have at this level 
  194 00000120 ba000012         blt     skipa                   ; skip if no cache, or just i-cache 
  195 00000124            
  196 00000124 ee40af10         mcr     p15, 2, r10, c0, c0, 0  ; select current cache level in cssr 
  197 00000128 e3a01000         mov     r1, #0 
  198 0000012c ee071f95         mcr     p15, 0, r1, c7, c5, 4   ; prefetch flush to sync the change to the cachesize id reg 
  199 00000130 ee301f10         mrc     p15, 1, r1, c0, c0, 0   ; read the new csidr 
  200 00000134 e2012007         and     r2, r1, #7              ; extract the length of the cache lines 
  201 00000138 e2822004         add     r2, r2, #4              ; add 4 (line length offset)         
  202 0000013c e51f4140         ldr     r4, max_assoc 
  203 00000140 e01441a1         ands    r4, r4, r1, lsr #3      ; r4 is maximum number on the way size 
warning:Instruction clz not supported for -cpu "-arch 4t"
  204 00000144 e16f5f14         clz     r5, r4                  ; r5 find bit position of way size increment         
  205 00000148 e51f7148         ldr     r7, max_setnum 
  206 0000014c e01776a1         ands    r7, r7, r1, lsr #13     ; r7 extract max number of the index size 
  207 00000150            
  208 00000150 e1a09004 loop2a  mov     r9, r4                  ; r9 is working copy of max way size 
  209 00000154 e18ab519 loop3a  orr     r11, r10, r9, lsl r5    ; factor way and cache number into r11 
  210 00000158 e18bb217         orr     r11, r11, r7, lsl r2    ; factor index number into r11 
  211 0000015c            
  212 0000015c ee07bf5e         mcr     p15, 0, r11, c7, c14, 2 ; clean and invalidate by set/way 
  213 00000160            
  214 00000160 e2599001         subs    r9, r9, #1              ; decrement the way 
  215 00000164 aafffffa         bge     loop3a 
  216 00000168            
  217 00000168 e2577001         subs    r7, r7, #1              ; decrement the index 
  218 0000016c aafffff7         bge     loop2a 
  219 00000170            
  220 00000170 e28aa002 skipa   add     r10, r10, #2            ; increment cache number 
  221 00000174 e153000a         cmp     r3, r10 
  222 00000178 caffffe4         bgt     loop1a 
  223 0000017c            
  224 0000017c e3a0a000 donea   mov     r10, #0                 ; swith back to cache level 0 
  225 00000180 ee40af10         mcr     p15, 2, r10, c0, c0, 0  ; select current cache level in cssr 
  226 00000184                   
  227 00000184 e8bd5ff8         ldmia   sp!, {r3 - r12, lr}  
  228 00000188 e1a0f00e         mov     pc, lr       
  229 0000018c          ;------------------------------------------------------------------------------- 
  230 0000018c            
  231 0000018c          ;------------------------------------------------------------------------------- 
  232 0000018c          ; 
  233 0000018c          ;  Function:  OALCPUIdle 
  234 0000018c          ; 
  235 0000018c          ;  This function puts the mpu in suspend. 
  236 0000018c          ;  r0 = addr CPUIDLE_INFO 
  237 0000018c          ; 
  238 0000018c           LEAF_ENTRY OALCPUIdle 
  175 0000018c          FuncName SETS    VBar:CC:"OALCPUIdle":CC:VBar 
  176 0000018c          PrologName SETS "Invalid Prolog" 
  177 0000018c          FuncEndName SETS    VBar:CC:"OALCPUIdle":CC:"_end":CC:VBar 
  178 0000018c                  ALIGN   2 
  179 0000018c                  EXPORT  |OALCPUIdle| [FUNC] 
  180 0000018c          |OALCPUIdle| 
  181 0000018c                  ROUT 
  239 0000018c                                                   ;-------------------------------------- 
  240 0000018c                                                   ; store register values into stack     
  241 0000018c                                                   ; 
  242 0000018c e92d5ff8         stmdb      sp!, {r3 - r12, lr}  
  243 00000190                                                   ;-------------------------------------- 
  244 00000190                                                   ; check if mpu is going to off     
  245 00000190                                                   ; 
  246 00000190 e5901014         ldr        r1, [r0, #MPU_PRM_REGS_OFFSET] 
  247 00000194 e59120e0         ldr        r2, [r1, #PRM_PWRSTCTRL_MPU_OA] 
  248 00000198 e2023003         and        r3, r2, #PRM_POWERSTATE_MASK         
  249 0000019c e3530000         cmp        r3, #PRM_POWERSTATE_OFF_VAL 
  250 000001a0            
  251 000001a0                                                   ;-------------------------------------- 
  252 000001a0                                                   ; check for open switch retention 
  253 000001a0                                                   ; 
  254 000001a0 12023004         andne      r3, r2, #PRM_LOGICL1CACHERETSTATE_VAL 
  255 000001a4 13530000         cmpne      r3, #0 
  256 000001a8                   
  257 000001a8                                                   ;-------------------------------------- 
  258 000001a8                                                   ; save register context if going to OFF 
  259 000001a8                                                   ; mode 
  260 000001a8                                                   ; 
  261 000001a8 e1a04000         mov        r4, r0 
  262 000001ac 05900024         ldreq      r0, [r0, #MPU_CONTEXT_VA_OFFSET] 
  263 000001b0 0bffff95         bleq       SaveContext 
  264 000001b4                                                   ;-------------------------------------- 
  265 000001b4                                                   ; memory barrier     
  266 000001b4                                                   ; 
  267 000001b4 e3a02000         mov        r2, #0x0 
  268 000001b8 ee072f9a         mcr        p15, 0, r2, c7, c10, 4         
  269 000001bc ee072fba         mcr        p15, 0, r2, c7, c10, 5     
  270 000001c0 e1a00000         nop                        
  271 000001c4 e320f003         dcd        WFI 
  272 000001c8                                    
  273 000001c8                                                   ;-------------------------------------- 
  274 000001c8                                                   ; r1 = CORE_CM regs 
  275 000001c8                                                   ; r2 = CM_CLKSTST_CORE value 
  276 000001c8                                                   ; wait for L3 to lock 
  277 000001c8                                                   ; 
  278 000001c8 e5941008         ldr        r1, [r4, #CORE_CM_REGS_OFFSET] 
  279 000001cc                   
  280 000001cc          |$_OALCPUIdle_L3_Lock_Loop| 
  281 000001cc e591204c         ldr        r2, [r1, #CM_CLKSTST_CORE_OA] 
  282 000001d0 e2122001         ands       r2, r2, #CM_CLKSTST_CLKACTIVITY_L3_BIT 
  283 000001d4 0afffffc         beq        |$_OALCPUIdle_L3_Lock_Loop|         
  284 000001d8            
  285 000001d8 e8bd5ff8         ldmia      sp!, {r3 - r12, lr}  
  286 000001dc e1a0f00e         mov        pc, lr                
  287 000001e0           ENTRY_END OALCPUIdle 
  194 000001e0          |OALCPUIdle_end| 
  288 000001e0          ;------------------------------------------------------------------------------- 
  289 000001e0            
  290 000001e0          ;------------------------------------------------------------------------------- 
  291 000001e0          ; 
  292 000001e0          ;  Function:  CPUStall 
  293 000001e0          ; 
  294 000001e0          ;  loops [r0] amount 
  295 000001e0          ;  r0 = amount to loop 
  296 000001e0          ; 
  297 000001e0          ;  uses: r0 
  298 000001e0          ; 
  299 000001e0          CPUStall 
  300 000001e0 e3500000         cmp         r0, #0x0 
  301 000001e4 12400001         subne       r0, r0, #0x1 
  302 000001e8 1afffffc         bne         CPUStall 
  303 000001ec                   
  304 000001ec e1a0f00e         mov         pc, lr 
  305 000001f0          ;------------------------------------------------------------------------------- 
  306 000001f0            
  307 000001f0          ;------------------------------------------------------------------------------- 
  308 000001f0          ; 
  309 000001f0          ;  Function:  GPTWait 
  310 000001f0          ; 
  311 000001f0          ;  number of gptimer ticks to wait 
  312 000001f0          ;  r0 = amount of gpt to wait 
  313 000001f0          ;  r5 = addr CPUIDLE_INFO 
  314 000001f0          ; 
  315 000001f0          ;  uses: r0, r1 
  316 000001f0          ; 
  317 000001f0          GPTWait                                          
  318 000001f0 e5951010         ldr         r1, [r5, #GPTIMER_REGS_OFFSET] 
  319 000001f4 e5911028         ldr         r1, [r1, #TIMER_TCRR_OA] 
  320 000001f8 e2800001         add         r0, r0, #1 
  321 000001fc e0800001         add         r0, r0, r1         
  322 00000200            
  323 00000200                                                   ;-------------------------------------- 
  324 00000200                                                   ; loop until the requested amount of 
  325 00000200                                                   ; ticks went by 
  326 00000200                                                   ; 
  327 00000200          |$_GPTWait_Loop| 
  328 00000200            
  329 00000200 e5951010         ldr         r1, [r5, #GPTIMER_REGS_OFFSET] 
  330 00000204 e5911028         ldr         r1, [r1, #TIMER_TCRR_OA] 
  331 00000208 e1510000         cmp         r1, r0 
  332 0000020c 1afffffb         bne         |$_GPTWait_Loop| 
  333 00000210                   
  334 00000210 e1a0f00e         mov         pc, lr 
  335 00000214          ;------------------------------------------------------------------------------- 
  336 00000214            
  337 00000214          ;------------------------------------------------------------------------------- 
  338 00000214          ; 
  339 00000214          ;  Function:  SDRCEnable 
  340 00000214          ; 
  341 00000214          ;  This function enables/disables access to SDRAM. 
  342 00000214          ;  r0 = 1:enable SDRC iclk, 0:disable SDRC iclk 
  343 00000214          ;  r6 = ref CORE_CM_REGS 
  344 00000214          ; 
  345 00000214          ;  return: none 
  346 00000214          ; 
  347 00000214          ;  uses: r0 - r1 
  348 00000214          ; 
  349 00000214          SDRCEnable 
  350 00000214                                                   ;-------------------------------------- 
  351 00000214                                                   ; setup pointers 
  352 00000214                                                   ; r1 = req SDRC iclk mode 
  353 00000214 e1a01080         mov         r1, r0, LSL #CM_ICLKEN1_CORE_SDRC_BIT 
  354 00000218 e3310002         teq         r1, #(1 :SHL: CM_ICLKEN1_CORE_SDRC_BIT) 
  355 0000021c                           
  356 0000021c                                                   ;-------------------------------------- 
  357 0000021c                                                   ; clear/set EN_SDRC in CM_ICLKEN1_CORE 
  358 0000021c e5960010         ldr         r0, [r6, #CM_ICLKEN1_CORE_OA] 
  359 00000220 13c00002         bicne       r0, r0, #(1 :SHL: CM_ICLKEN1_CORE_SDRC_BIT) 
  360 00000224 03800002         orreq       r0, r0, #(1 :SHL: CM_ICLKEN1_CORE_SDRC_BIT) 
  361 00000228 e5860010         str         r0, [r6, #CM_ICLKEN1_CORE_OA] 
  362 0000022c            
  363 0000022c                                                   ;-------------------------------------- 
  364 0000022c                                                   ; wait until EN_SDRC is in the correct 
  365 0000022c                                                   ; state 
  366 0000022c          _SDRCEnable_chk1 
  367 0000022c e5960020         ldr         r0, [r6, #CM_IDLEST1_CORE_OA] 
  368 00000230 e2000002         and         r0, r0, #(1 :SHL: CM_ICLKEN1_CORE_SDRC_BIT) 
  369 00000234 e1300001         teq         r0, r1 
  370 00000238 0afffffb         beq         _SDRCEnable_chk1 
  371 0000023c            
  372 0000023c e12fff1e         bx          lr                   ;return 
  373 00000240          ;------------------------------------------------------------------------------- 
  374 00000240            
  375 00000240          ;------------------------------------------------------------------------------- 
  376 00000240          ; 
  377 00000240          ;  Function:  SetDpllMode 
  378 00000240          ; 
  379 00000240          ;  Puts DPLL in bypass or locked 
  380 00000240          ;  r0 = 5 : enable low power bypass, 6 : fast relock bypass, 7 : no bypass 
  381 00000240          ;  r1 = addr CM_CLKEN_xxx (must be CM_CLKEN_PLL, CM_CLKEN_MPU, CM_CLKEN_IVA2) 
  382 00000240          ;  r5 = addr CPUIDLE_INFO 
  383 00000240          ; 
  384 00000240          ;  uses: r2, r3 
  385 00000240          ; 
  386 00000240          SetDpllMode 
  387 00000240            
  388 00000240                                                   ;-------------------------------------- 
  389 00000240                                                   ; setup pointers 
  390 00000240                                                   ; r2 = req dpll mode 
  391 00000240                                                   ; r3 = ref CM_CLKEN_xxx 
  392 00000240 e1a02000         mov         r2, r0 
  393 00000244 e1a03001         mov         r3, r1 
  394 00000248                   
  395 00000248                                                   ;-------------------------------------- 
  396 00000248                                                   ; check if dpll is already at the 
  397 00000248                                                   ; requested state 
  398 00000248 e5930000         ldr         r0, [r3] 
  399 0000024c e2001007         and         r1, r0, #CM_CLKEN_PLL_DPLL_MASK 
  400 00000250 e1310002         teq         r1, r2 
  401 00000254 0a000009         beq         |$_SetDpllMode_exit| 
  402 00000258                       
  403 00000258                                                   ;-------------------------------------- 
  404 00000258                                                   ; update dpll to requested state 
  405 00000258 e3c00007         bic         r0, r0, #CM_CLKEN_PLL_DPLL_MASK 
  406 0000025c e1800002         orr         r0, r0, r2 
  407 00000260 e5830000         str         r0, [r3] 
  408 00000264            
  409 00000264                                                   ;-------------------------------------- 
  410 00000264                                                   ; setup for test loop 
  411 00000264 e3320007         teq         r2, #CM_CLKEN_PLL_DPLL_LOCKED 
  412 00000268 13a01000         movne       r1, #0 
  413 0000026c 03a01001         moveq       r1, #1 
  414 00000270                                                   ;-------------------------------------- 
  415 00000270                                                   ; loop until dpll in desired state 
  416 00000270          _SetDpllMode_chk1 
  417 00000270 e5930020         ldr         r0, [r3, #CM_IDLEST_CKGEN_OA] 
  418 00000274 e2000001         and         r0, r0, #1 
  419 00000278 e1300001         teq         r0, r1 
  420 0000027c 1afffffb         bne         _SetDpllMode_chk1 
  421 00000280            
  422 00000280          |$_SetDpllMode_exit| 
  423 00000280 e12fff1e         bx          lr                   ; return 
  424 00000284          ;------------------------------------------------------------------------------- 
  425 00000284            
  426 00000284          ;------------------------------------------------------------------------------- 
  427 00000284          ; 
  428 00000284          ;  Function:  OALUpdateCoreFreq 
  429 00000284          ; 
  430 00000284          ;  changes the core dpll frequency 
  431 00000284          ; 
  432 00000284          ;  r0 = addr CPUIDLE_INFO 
  433 00000284          ;  r1 = value for CM_CLKEN_PLL 
  434 00000284          ;  r2 = value for CM_CLKSEL1_PLL 
  435 00000284          ; 
  436 00000284           LEAF_ENTRY OALUpdateCoreFreq 
  175 00000284          FuncName SETS    VBar:CC:"OALUpdateCoreFreq":CC:VBar 
  176 00000284          PrologName SETS "Invalid Prolog" 
  177 00000284          FuncEndName SETS    VBar:CC:"OALUpdateCoreFreq":CC:"_end":CC:VBar 
  178 00000284                  ALIGN   2 
  179 00000284                  EXPORT  |OALUpdateCoreFreq| [FUNC] 
  180 00000284          |OALUpdateCoreFreq| 
  181 00000284                  ROUT 
  437 00000284            
  438 00000284 e92d47f8         stmdb       sp!, {r3 - r10, lr} 
  439 00000288                                                   ;-------------------------------------- 
  440 00000288                                                   ; memory barrier 
  441 00000288 e3a03000         mov         r3, #0             
  442 0000028c ee073fba         mcr             p15, 0, r3, c7, c10, 5  
  443 00000290            
  444 00000290                                                   ;-------------------------------------- 
  445 00000290                                                   ; setup pointers                                          
  446 00000290                                                   ; r5 = ref SDRC_REGS 
  447 00000290                                                   ; r6 = ref CORE_CM_REGS 
  448 00000290                                                   ; r7 = ref CLOCK_CTRL_CM_REGS         
  449 00000290                                                   ; r8 = value for CM_CLKEN_PLL 
  450 00000290                                                   ; r9 = value for CM_CLKSEL1_PLL 
  451 00000290 e5905000         ldr         r5, [r0, #SDRC_REGS_OFFSET] 
  452 00000294 e5906008         ldr         r6, [r0, #CORE_CM_REGS_OFFSET] 
  453 00000298 e590700c         ldr         r7, [r0, #CLOCK_CTRL_CM_REGS_OFFSET] 
  454 0000029c e1a08001         mov         r8, r1 
  455 000002a0 e1a09002         mov         r9, r2 
  456 000002a4                   
  457 000002a4                                                   ;-------------------------------------- 
  458 000002a4                                                   ; Get current DLL mode, to be used  
  459 000002a4                                                   ; later 
  460 000002a4 e5952060         ldr         r2, [r5, #SDRC_DLLA_CTRL_OA] 
  461 000002a8            
  462 000002a8                                                   ;-------------------------------------- 
  463 000002a8                                                   ; Determine OPP Transition 
  464 000002a8 e1a03da9         mov         r3, r9 LSR #CM_CLKSEL1_PLL_M2_SHIFT 
  465 000002ac e3530001         cmp         r3, #1 
  466 000002b0            
  467 000002b0                                                   ;-------------------------------------- 
  468 000002b0                                                   ; set wait time and idle mask 
  469 000002b0                                                   ; LOW OPP -> DLL unlock mode 
  470 000002b0                                                   ; HIGH OPP -> DLL lock mode 
  471 000002b0                                                   ; GET refresh rate 
  472 000002b0 13a04000         movne       r4, #DVFS_LOW_OPP_STALL 
  473 000002b4 03a04010         moveq       r4, #DVFS_HIGH_OPP_STALL 
  474 000002b8 13a03000         movne       r3, #SDRC_DLLA_STATUS_UNLOCKED 
  475 000002bc 03a03004         moveq       r3, #SDRC_DLLA_STATUS_LOCKED 
  476 000002c0            
  477 000002c0                                                   ;-------------------------------------- 
  478 000002c0                                                   ; set LOCKDLL for <= 83 mhz 
  479 000002c0                                                   ; clr LOCKDLL for > 83 mhz 
  480 000002c0 13822004         orrne       r2, r2, #(1 :SHL: SDRC_DLL_LOCKDLL_BIT) 
  481 000002c4 03c22004         biceq       r2, r2, #(1 :SHL: SDRC_DLL_LOCKDLL_BIT) 
  482 000002c8 e5852060         str         r2, [r5, #SDRC_DLLA_CTRL_OA] 
  483 000002cc            
  484 000002cc                                                   ;-------------------------------------- 
  485 000002cc                                                   ; restrict access to SDRAM 
  486 000002cc e3a00000         mov         r0, #SDRC_DISABLE_ICLK 
  487 000002d0 ebffffcf         bl          SDRCEnable 
  488 000002d4                   
  489 000002d4                                                   ;-------------------------------------- 
  490 000002d4                                                   ; update w/ new m,n values and dpll  
  491 000002d4                                                   ; configuration 
  492 000002d4 e5879040         str         r9, [r7, #CM_CLKSEL1_PLL_OA]                                          
  493 000002d8 e5878000         str         r8, [r7, #CM_CLKEN_PLL_OA] 
  494 000002dc            
  495 000002dc                                                   ;-------------------------------------- 
  496 000002dc                                                   ; stall a predefined amount 
  497 000002dc e3540000         cmp         r4, #0 
  498 000002e0 11a00004         movne       r0, r4 
  499 000002e4 1bffffbd         blne        CPUStall 
  500 000002e8            
  501 000002e8                                                   ;-------------------------------------- 
  502 000002e8                                                   ; allow access to SDRAM 
  503 000002e8 e3a00001         mov         r0, #SDRC_ENABLE_ICLK 
  504 000002ec ebffffc8         bl          SDRCEnable           
  505 000002f0            
  506 000002f0                                                   ;-------------------------------------- 
  507 000002f0                                                   ; wait for status to match expected 
  508 000002f0                                                   ; state 
  509 000002f0          _OALUpdateCoreFreq_chk1 
  510 000002f0            
  511 000002f0 e5952064         ldr         r2, [r5, #SDRC_DLLA_STATUS_OA] 
  512 000002f4 e1520003         cmp         r2, r3 
  513 000002f8 1afffffc         bne         _OALUpdateCoreFreq_chk1 
  514 000002fc                   
  515 000002fc e8bd47f8         ldmia       sp!, {r3 - r10, lr} 
  516 00000300 e12fff1e         bx          lr                   ; return 
  517 00000304                   
  518 00000304           ENTRY_END OALUpdateCoreFreq 
  194 00000304          |OALUpdateCoreFreq_end| 
  519 00000304          ;------------------------------------------------------------------------------- 
  520 00000304            
  521 00000304          ;------------------------------------------------------------------------------- 
  522 00000304          ; 
  523 00000304          ;  Function:  OALCPUEnd 
  524 00000304          ; 
  525 00000304          ;  Marker indicating the end of cpu specific assembly. Never should get called 
  526 00000304          ; 
  527 00000304           LEAF_ENTRY OALCPUEnd 
  175 00000304          FuncName SETS    VBar:CC:"OALCPUEnd":CC:VBar 
  176 00000304          PrologName SETS "Invalid Prolog" 
  177 00000304          FuncEndName SETS    VBar:CC:"OALCPUEnd":CC:"_end":CC:VBar 
  178 00000304                  ALIGN   2 
  179 00000304                  EXPORT  |OALCPUEnd| [FUNC] 
  180 00000304          |OALCPUEnd| 
  181 00000304                  ROUT 
  528 00000304 e1a00000         nop         
  529 00000308           ENTRY_END OALCPUEnd 
  194 00000308          |OALCPUEnd_end| 
  530 00000308          ;------------------------------------------------------------------------------- 
  531 00000308            
  532 00000308          ;------------------------------------------------------------------------------- 
  533 00000308          ; 
  534 00000308          ;  Function:  INTERRUPTS_STATUS 
  535 00000308          ; 
  536 00000308          ;  returns current arm interrupts status. 
  537 00000308          ; 
  538 00000308           LEAF_ENTRY INTERRUPTS_STATUS 
  175 00000308          FuncName SETS    VBar:CC:"INTERRUPTS_STATUS":CC:VBar 
  176 00000308          PrologName SETS "Invalid Prolog" 
  177 00000308          FuncEndName SETS    VBar:CC:"INTERRUPTS_STATUS":CC:"_end":CC:VBar 
  178 00000308                  ALIGN   2 
  179 00000308                  EXPORT  |INTERRUPTS_STATUS| [FUNC] 
  180 00000308          |INTERRUPTS_STATUS| 
  181 00000308                  ROUT 
  539 00000308            
  540 00000308 e10f0000         mrs     r0, cpsr                    ; (r0) = current status 
  541 0000030c e2100080         ands    r0, r0, #0x80               ; was interrupt enabled? 
  542 00000310 03a00001         moveq   r0, #1                      ; yes, return 1 
  543 00000314 13a00000         movne   r0, #0                      ; no, return 0 
  544 00000318            
  545 00000318           ENTRY_END INTERRUPTS_STATUS 
  194 00000318          |INTERRUPTS_STATUS_end| 
  546 00000318            
  547 00000318          ;------------------------------------------------------------------------------- 
  548 00000318          ; 
  549 00000318          ;  Function:  OALInvalidateTlb 
  550 00000318          ; 
  551 00000318          ;  This function Invalidates the TLBs and enable I and D Cache 
  552 00000318          ; 
  553 00000318           LEAF_ENTRY OALInvalidateTlb 
  175 00000318          FuncName SETS    VBar:CC:"OALInvalidateTlb":CC:VBar 
  176 00000318          PrologName SETS "Invalid Prolog" 
  177 00000318          FuncEndName SETS    VBar:CC:"OALInvalidateTlb":CC:"_end":CC:VBar 
  178 00000318                  ALIGN   2 
  179 00000318                  EXPORT  |OALInvalidateTlb| [FUNC] 
  180 00000318          |OALInvalidateTlb| 
  181 00000318                  ROUT 
  554 00000318 e3a01000         mov        r1, #0 
  555 0000031c ee112f10         mrc        p15, 0, r2, c1, c0, 0 ; get control code 
  556 00000320 ee081f17         mcr        p15, 0, r1, c8, c7, 0 ; invalidate TLB 
  557 00000324 e3822a01         orr        r2, r2, #ICACHE_MASK 
  558 00000328 e3822004         orr        r2, r2, #DCACHE_MASK 
  559 0000032c ee012f10         mcr        p15, 0, r2, c1, c0, 0 ; enable i/d cache 
  560 00000330 ee071f9a         mcr        p15, 0, r1, c7, c10, 4; drain write buffers 
  561 00000334 e1a00000         nop                  
  562 00000338            
  563 00000338 e1a0f00e         mov        pc, lr                        
  564 0000033c               
  565 0000033c           ENTRY_END OALInvalidateTlb 
  194 0000033c          |OALInvalidateTlb_end| 
  566 0000033c          ;------------------------------------------------------------------------------- 
  567 0000033c            
  568 0000033c          ;------------------------------------------------------------------------------- 
  569 0000033c          ; 
  570 0000033c          ;  Function:  OALGetTTBR 
  571 0000033c          ; 
  572 0000033c          ;  work-around a new kernel feature which marks all non-cached memory 
  573 0000033c          ;  as non-executable. 
  574 0000033c          ; 
  575 0000033c           LEAF_ENTRY OALGetTTBR 
  175 0000033c          FuncName SETS    VBar:CC:"OALGetTTBR":CC:VBar 
  176 0000033c          PrologName SETS "Invalid Prolog" 
  177 0000033c          FuncEndName SETS    VBar:CC:"OALGetTTBR":CC:"_end":CC:VBar 
  178 0000033c                  ALIGN   2 
  179 0000033c                  EXPORT  |OALGetTTBR| [FUNC] 
  180 0000033c          |OALGetTTBR| 
  181 0000033c                  ROUT 
  576 0000033c            
  577 0000033c ee121f50         mrc         p15, 0, r1, c2, c0, 2 ; determine if using TTBR0 or 1 
  578 00000340 e2011007         and         r1, r1, #0x7 
  579 00000344 e3510000         cmp         r1, #0x0 
  580 00000348 0e120f10         mrceq       p15, 0, r0, c2, c0, 0 ; get TTBR from either TTBR0 or 1 
  581 0000034c 1e120f30         mrcne       p15, 0, r0, c2, c0, 1 
  582 00000350 e3c0001f         bic         r0, r0, #0x1F          ; clear control bits 
  583 00000354 e12fff1e         bx          lr  
  584 00000358            
  585 00000358           ENTRY_END OALGetTTBR 
  194 00000358          |OALGetTTBR_end| 
  586 00000358            
  587 00000358          END_REGION 
  588 00000358          ;------------------------------------------------------------------------------- 
  589 00000358            
  590 00000358                  END 
Assembly terminated, errors: 0, warnings: 1 
