; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\AM3517\USB\USBFN\cppidma.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.bss|, NOINIT
|f_CppiObj| %	0x4

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	IMPORT	|DeleteCriticalSection|
	IMPORT	|LeaveCriticalSection|
	IMPORT	|USBCDMA_DeregisterUsbModule|
	IMPORT	|EnterCriticalSection|
; File c:\wince600\platform\common\src\soc\common_ti_v1\am3517\usb\usbfn\cppidma.c

  00000			 AREA	 |.pdata|, PDATA
|$T47424| DCD	|$LN7@cppiPoolDe|
	DCD	0x40001901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiPoolDeinit| PROC

; 232  : {

  00000		 |$LN7@cppiPoolDe|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47421|
  00004	e1b05000	 movs        r5, r0

; 233  :     DEBUGCHK(cppi != NULL);
; 234  :     if (cppi == NULL)

  00008	0a000013	 beq         |$LN3@cppiPoolDe|

; 235  : 	{
; 236  :         return;
; 237  : 	}
; 238  : 
; 239  :     // Only free once
; 240  :     if (cppi->pool == NULL)

  0000c	e5953898	 ldr         r3, [r5, #0x898]
  00010	e3530000	 cmp         r3, #0
  00014	0a000010	 beq         |$LN3@cppiPoolDe|

; 241  : 	{
; 242  :         return;
; 243  : 	}
; 244  : 
; 245  :     DEBUGMSG(ZONE_INIT,
; 246  :         (L"+cppiPoolDeinit\r\n"));
; 247  : 
; 248  :     LOCK_HD_POOL(cppi);

  00018	e2854b02	 add         r4, r5, #2, 22
  0001c	e28400b8	 add         r0, r4, #0xB8
  00020	eb000000	 bl          EnterCriticalSection

; 249  : 
; 250  :     USBCDMA_DeregisterUsbModule(cppi->hUsbCdma);

  00024	e5950020	 ldr         r0, [r5, #0x20]
  00028	eb000000	 bl          USBCDMA_DeregisterUsbModule

; 251  : 
; 252  :     cppi->poolHead = NULL;

  0002c	e3a03000	 mov         r3, #0

; 253  :     cppi->poolFree = 0;
; 254  :     cppi->poolUsed = 0;
; 255  :     cppi->poolMaxSize = 0;
; 256  :     cppi->paPool.QuadPart = 0;
; 257  :     cppi->pool = NULL;
; 258  : 
; 259  :     UNLOCK_HD_POOL(cppi);

  00030	e28400b8	 add         r0, r4, #0xB8
  00034	e58538b4	 str         r3, [r5, #0x8B4]
  00038	e58538b0	 str         r3, [r5, #0x8B0]
  0003c	e58538ac	 str         r3, [r5, #0x8AC]
  00040	e58538a8	 str         r3, [r5, #0x8A8]
  00044	e58538a0	 str         r3, [r5, #0x8A0]
  00048	e58538a4	 str         r3, [r5, #0x8A4]
  0004c	e5853898	 str         r3, [r5, #0x898]
  00050	eb000000	 bl          LeaveCriticalSection

; 260  : 
; 261  :     DeleteCriticalSection(&cppi->poolLock);

  00054	e28400b8	 add         r0, r4, #0xB8
  00058	eb000000	 bl          DeleteCriticalSection
  0005c		 |$LN3@cppiPoolDe|

; 262  : 
; 263  :     DEBUGMSG(ZONE_INIT,
; 264  :         (L"-cppiPoolDeinit\r\n"));
; 265  : }

  0005c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$M47422|

			 ENDP  ; |cppiPoolDeinit|

	EXPORT	|??_C@_1FO@JMNGHGHF@?$AAc?$AAp?$AAp?$AAi?$AAH?$AAd?$AAA?$AAl?$AAl?$AAo?$AAc?$AA?3?$AA?5?$AAM?$AAi?$AAs?$AAa?$AAl?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAd?$AAe?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt@| [ DATA ] ; `string'
	EXPORT	|??_C@_1JM@MEFHOMOC@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1LA@HMIKCFGL@?$AAc?$AAp?$AAp?$AAi?$AAH?$AAd?$AAA?$AAl?$AAl?$AAo?$AAc?$AA?3?$AA?5?$AAF?$AAA?$AAI?$AAL?$AAE?$AAD?$AA?5?$AA?9?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAd?$AAe?$AAs@| [ DATA ] ; `string'
	IMPORT	|NKDbgPrintfW|

  00000			 AREA	 |.pdata|, PDATA
|$T47437| DCD	|$LN11@cppiHdAllo|
	DCD	0x40002801

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FO@JMNGHGHF@?$AAc?$AAp?$AAp?$AAi?$AAH?$AAd?$AAA?$AAl?$AAl?$AAo?$AAc?$AA?3?$AA?5?$AAM?$AAi?$AAs?$AAa?$AAl?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAd?$AAe?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt@| DCB "c"
	DCB	0x0, "p", 0x0, "p", 0x0, "i", 0x0, "H", 0x0, "d", 0x0, "A"
	DCB	0x0, "l", 0x0, "l", 0x0, "o", 0x0, "c", 0x0, ":", 0x0, " "
	DCB	0x0, "M", 0x0, "i", 0x0, "s", 0x0, "a", 0x0, "l", 0x0, "i"
	DCB	0x0, "g", 0x0, "n", 0x0, "e", 0x0, "d", 0x0, " ", 0x0, "d"
	DCB	0x0, "e", 0x0, "s", 0x0, "c", 0x0, "r", 0x0, "i", 0x0, "p"
	DCB	0x0, "t", 0x0, "o", 0x0, "r", 0x0, " ", 0x0, "-", 0x0, " "
	DCB	0x0, "0", 0x0, "x", 0x0, "%", 0x0, "0", 0x0, "8", 0x0, "x"
	DCB	0x0, "!", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1JM@MEFHOMOC@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| DCB "C"
	DCB	0x0, ":", 0x0, "\\", 0x0, "W", 0x0, "I", 0x0, "N", 0x0, "C"
	DCB	0x0, "E", 0x0, "6", 0x0, "0", 0x0, "0", 0x0, "\\", 0x0, "P"
	DCB	0x0, "L", 0x0, "A", 0x0, "T", 0x0, "F", 0x0, "O", 0x0, "R"
	DCB	0x0, "M", 0x0, "\\", 0x0, "C", 0x0, "O", 0x0, "M", 0x0, "M"
	DCB	0x0, "O", 0x0, "N", 0x0, "\\", 0x0, "S", 0x0, "R", 0x0, "C"
	DCB	0x0, "\\", 0x0, "S", 0x0, "O", 0x0, "C", 0x0, "\\", 0x0, "C"
	DCB	0x0, "O", 0x0, "M", 0x0, "M", 0x0, "O", 0x0, "N", 0x0, "_"
	DCB	0x0, "T", 0x0, "I", 0x0, "_", 0x0, "V", 0x0, "1", 0x0, "\\"
	DCB	0x0, "A", 0x0, "M", 0x0, "3", 0x0, "5", 0x0, "1", 0x0, "7"
	DCB	0x0, "\\", 0x0, "U", 0x0, "S", 0x0, "B", 0x0, "\\", 0x0, "U"
	DCB	0x0, "S", 0x0, "B", 0x0, "F", 0x0, "N", 0x0, "\\", 0x0, "."
	DCB	0x0, "\\", 0x0, "c", 0x0, "p", 0x0, "p", 0x0, "i", 0x0, "d"
	DCB	0x0, "m", 0x0, "a", 0x0, ".", 0x0, "c", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "%", 0x0, "s", 0x0, " ", 0x0, "l", 0x0, "i", 0x0, "n"
	DCB	0x0, "e", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ":", 0x0, " "
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1LA@HMIKCFGL@?$AAc?$AAp?$AAp?$AAi?$AAH?$AAd?$AAA?$AAl?$AAl?$AAo?$AAc?$AA?3?$AA?5?$AAF?$AAA?$AAI?$AAL?$AAE?$AAD?$AA?5?$AA?9?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAd?$AAe?$AAs@| DCB "c"
	DCB	0x0, "p", 0x0, "p", 0x0, "i", 0x0, "H", 0x0, "d", 0x0, "A"
	DCB	0x0, "l", 0x0, "l", 0x0, "o", 0x0, "c", 0x0, ":", 0x0, " "
	DCB	0x0, "F", 0x0, "A", 0x0, "I", 0x0, "L", 0x0, "E", 0x0, "D"
	DCB	0x0, " ", 0x0, "-", 0x0, " ", 0x0, "O", 0x0, "u", 0x0, "t"
	DCB	0x0, " ", 0x0, "o", 0x0, "f", 0x0, " ", 0x0, "d", 0x0, "e"
	DCB	0x0, "s", 0x0, "c", 0x0, "r", 0x0, "i", 0x0, "p", 0x0, "t"
	DCB	0x0, "o", 0x0, "r", 0x0, "s", 0x0, " ", 0x0, "(", 0x0, "i"
	DCB	0x0, "n", 0x0, "c", 0x0, "r", 0x0, "e", 0x0, "a", 0x0, "s"
	DCB	0x0, "e", 0x0, " ", 0x0, "D", 0x0, "e", 0x0, "s", 0x0, "c"
	DCB	0x0, "r", 0x0, "i", 0x0, "p", 0x0, "t", 0x0, "o", 0x0, "r"
	DCB	0x0, "C", 0x0, "o", 0x0, "u", 0x0, "n", 0x0, "t", 0x0, " "
	DCB	0x0, "r", 0x0, "e", 0x0, "g", 0x0, "i", 0x0, "s", 0x0, "t"
	DCB	0x0, "r", 0x0, "y", 0x0, " ", 0x0, "s", 0x0, "e", 0x0, "t"
	DCB	0x0, "t", 0x0, "i", 0x0, "n", 0x0, "g", 0x0, ")", 0x0, "!"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiHdAlloc| PROC

; 352  : {

  00000		 |$LN11@cppiHdAllo|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M47434|
  00004	e1b05000	 movs        r5, r0

; 353  :     HOST_DESCRIPTOR *hd;
; 354  : 
; 355  :     DEBUGCHK(cppi != NULL);
; 356  :     if (cppi == NULL)
; 357  : 	{
; 358  :         return NULL;

  00008	03a04000	 moveq       r4, #0
  0000c	0a00001c	 beq         |$LN7@cppiHdAllo|

; 359  : 	}
; 360  : 
; 361  :     LOCK_HD_POOL(cppi);

  00010	e2856b02	 add         r6, r5, #2, 22
  00014	e28600b8	 add         r0, r6, #0xB8
  00018	eb000000	 bl          EnterCriticalSection

; 362  :     hd = cppi->poolHead;

  0001c	e59538b4	 ldr         r3, [r5, #0x8B4]

; 363  :     if (hd != NULL)
; 364  : 	{
; 365  :         cppi->poolHead = hd->next;
; 366  : 	}
; 367  : 
; 368  :     UNLOCK_HD_POOL(cppi);

  00020	e28600b8	 add         r0, r6, #0xB8
  00024	e1b04003	 movs        r4, r3
  00028	15943028	 ldrne       r3, [r4, #0x28]
  0002c	158538b4	 strne       r3, [r5, #0x8B4]
  00030	eb000000	 bl          LeaveCriticalSection

; 369  : 
; 370  :     if (hd == NULL) 

  00034	e3540000	 cmp         r4, #0
  00038	1a000007	 bne         |$LN2@cppiHdAllo|

; 371  : 	{
; 372  :         ERRORMSG(1,
; 373  :             (L"cppiHdAlloc: FAILED - Out of descriptors (increase DescriptorCount registry setting)!\r\n"));

  0003c	e59f1054	 ldr         r1, [pc, #0x54]
  00040	e59f004c	 ldr         r0, [pc, #0x4C]
  00044	e3a03c01	 mov         r3, #1, 24
  00048	e3832075	 orr         r2, r3, #0x75
  0004c	eb000000	 bl          NKDbgPrintfW
  00050	e59f0044	 ldr         r0, [pc, #0x44]
  00054	eb000000	 bl          NKDbgPrintfW

; 374  :     }
; 375  :     else 

  00058	ea000009	 b           |$LN7@cppiHdAllo|
  0005c		 |$LN2@cppiHdAllo|

; 376  : 	{
; 377  :         ERRORMSG(((UINT32)hd & (CPPI_HD_ALIGN - 1)),
; 378  :             (L"cppiHdAlloc: Misaligned descriptor - 0x%08x!\r\n",
; 379  :             hd));

  0005c	e314003f	 tst         r4, #0x3F
  00060	0a000007	 beq         |$LN7@cppiHdAllo|
  00064	e59f102c	 ldr         r1, [pc, #0x2C]
  00068	e59f0024	 ldr         r0, [pc, #0x24]
  0006c	e3a03c01	 mov         r3, #1, 24
  00070	e383207b	 orr         r2, r3, #0x7B
  00074	eb000000	 bl          NKDbgPrintfW
  00078	e59f0010	 ldr         r0, [pc, #0x10]
  0007c	e1a01004	 mov         r1, r4
  00080	eb000000	 bl          NKDbgPrintfW
  00084		 |$LN7@cppiHdAllo|

; 380  :     }
; 381  : 
; 382  :     return hd;
; 383  : }

  00084	e1a00004	 mov         r0, r4
  00088	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0008c	e12fff1e	 bx          lr
  00090		 |$LN12@cppiHdAllo|
  00090		 |$LN13@cppiHdAllo|
  00090	00000000	 DCD         |??_C@_1FO@JMNGHGHF@?$AAc?$AAp?$AAp?$AAi?$AAH?$AAd?$AAA?$AAl?$AAl?$AAo?$AAc?$AA?3?$AA?5?$AAM?$AAi?$AAs?$AAa?$AAl?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAd?$AAe?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt@|
  00094		 |$LN14@cppiHdAllo|
  00094	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  00098		 |$LN15@cppiHdAllo|
  00098	00000000	 DCD         |??_C@_1JM@MEFHOMOC@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  0009c		 |$LN16@cppiHdAllo|
  0009c	00000000	 DCD         |??_C@_1LA@HMIKCFGL@?$AAc?$AAp?$AAp?$AAi?$AAH?$AAd?$AAA?$AAl?$AAl?$AAo?$AAc?$AA?3?$AA?5?$AAF?$AAA?$AAI?$AAL?$AAE?$AAD?$AA?5?$AA?9?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAd?$AAe?$AAs@|
  000a0		 |$M47435|

			 ENDP  ; |cppiHdAlloc|

	EXPORT	|??_C@_1FI@GDHDOONE@?$AAc?$AAp?$AAp?$AAi?$AAH?$AAd?$AAF?$AAr?$AAe?$AAe?$AA?3?$AA?5?$AAN?$AAo?$AAt?$AA?5?$AAa?$AA?5?$AAH?$AAo?$AAs?$AAt?$AA?5?$AAd?$AAe?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AAo@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T47452| DCD	|$LN8@cppiHdFree|
	DCD	0x40002101

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FI@GDHDOONE@?$AAc?$AAp?$AAp?$AAi?$AAH?$AAd?$AAF?$AAr?$AAe?$AAe?$AA?3?$AA?5?$AAN?$AAo?$AAt?$AA?5?$AAa?$AA?5?$AAH?$AAo?$AAs?$AAt?$AA?5?$AAd?$AAe?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AAo@| DCB "c"
	DCB	0x0, "p", 0x0, "p", 0x0, "i", 0x0, "H", 0x0, "d", 0x0, "F"
	DCB	0x0, "r", 0x0, "e", 0x0, "e", 0x0, ":", 0x0, " ", 0x0, "N"
	DCB	0x0, "o", 0x0, "t", 0x0, " ", 0x0, "a", 0x0, " ", 0x0, "H"
	DCB	0x0, "o", 0x0, "s", 0x0, "t", 0x0, " ", 0x0, "d", 0x0, "e"
	DCB	0x0, "s", 0x0, "c", 0x0, "r", 0x0, "i", 0x0, "p", 0x0, "t"
	DCB	0x0, "o", 0x0, "r", 0x0, " ", 0x0, "t", 0x0, "y", 0x0, "p"
	DCB	0x0, "e", 0x0, " ", 0x0, "%", 0x0, "u", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiHdFree| PROC

; 398  : {

  00000		 |$LN8@cppiHdFree|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M47449|
  00004	e1a05001	 mov         r5, r1
  00008	e1b06000	 movs        r6, r0

; 399  :     UINT32 type;
; 400  : 
; 401  :     DEBUGCHK(cppi != NULL);
; 402  :     if (cppi == NULL)

  0000c	0a000017	 beq         |$LN4@cppiHdFree|

; 403  : 	{
; 404  :         return;
; 405  : 	}
; 406  : 
; 407  :     DEBUGCHK(hd != NULL);
; 408  :     if (hd == NULL)

  00010	e3550000	 cmp         r5, #0
  00014	0a000015	 beq         |$LN4@cppiHdFree|

; 409  : 	{
; 410  :         return;
; 411  : 	}
; 412  : 
; 413  :     type = (hd->DescInfo & USB_CPPI41_DESC_TYPE_MASK) >> USB_CPPI41_DESC_TYPE_SHIFT;

  00018	e5953000	 ldr         r3, [r5]
  0001c	e1a04da3	 mov         r4, r3, lsr #27

; 414  :     if (type != USB_CPPI41_DESC_TYPE_HOST) 

  00020	e3540010	 cmp         r4, #0x10
  00024	0a000009	 beq         |$LN1@cppiHdFree|

; 415  : 	{
; 416  :         ERRORMSG(TRUE,
; 417  :             (L"cppiHdFree: Not a Host descriptor type %u\r\n",
; 418  :             type));

  00028	e59f1050	 ldr         r1, [pc, #0x50]
  0002c	e59f0048	 ldr         r0, [pc, #0x48]
  00030	e3a03c01	 mov         r3, #1, 24
  00034	e38320a2	 orr         r2, r3, #0xA2
  00038	eb000000	 bl          NKDbgPrintfW
  0003c	e59f0034	 ldr         r0, [pc, #0x34]
  00040	e1a01004	 mov         r1, r4
  00044	eb000000	 bl          NKDbgPrintfW

; 426  : }

  00048	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$LN1@cppiHdFree|

; 419  :         return;
; 420  :     }
; 421  : 
; 422  :     LOCK_HD_POOL(cppi);

  00050	e2864b02	 add         r4, r6, #2, 22
  00054	e28400b8	 add         r0, r4, #0xB8
  00058	eb000000	 bl          EnterCriticalSection

; 423  :     hd->next = cppi->poolHead;

  0005c	e59638b4	 ldr         r3, [r6, #0x8B4]

; 424  :     cppi->poolHead = hd;
; 425  :     UNLOCK_HD_POOL(cppi);

  00060	e28400b8	 add         r0, r4, #0xB8
  00064	e5853028	 str         r3, [r5, #0x28]
  00068	e58658b4	 str         r5, [r6, #0x8B4]
  0006c	eb000000	 bl          LeaveCriticalSection
  00070		 |$LN4@cppiHdFree|

; 426  : }

  00070	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00074	e12fff1e	 bx          lr
  00078		 |$LN9@cppiHdFree|
  00078		 |$LN10@cppiHdFree|
  00078	00000000	 DCD         |??_C@_1FI@GDHDOONE@?$AAc?$AAp?$AAp?$AAi?$AAH?$AAd?$AAF?$AAr?$AAe?$AAe?$AA?3?$AA?5?$AAN?$AAo?$AAt?$AA?5?$AAa?$AA?5?$AAH?$AAo?$AAs?$AAt?$AA?5?$AAd?$AAe?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AAo@|
  0007c		 |$LN11@cppiHdFree|
  0007c	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  00080		 |$LN12@cppiHdFree|
  00080	00000000	 DCD         |??_C@_1JM@MEFHOMOC@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  00084		 |$M47450|

			 ENDP  ; |cppiHdFree|

	IMPORT	|USBCDMA_DescriptorVAtoPA|

  00000			 AREA	 |.pdata|, PDATA
|$T47468| DCD	|$LN9@cppiDescri|
	DCD	0x40001601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiDescriptorVAtoPA| PROC

; 432  : {

  00000		 |$LN9@cppiDescri|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M47465|
  00004	e1b01000	 movs        r1, r0

; 433  :     UINT32 pa = 0;

  00008	e3a00000	 mov         r0, #0

; 434  : 
; 435  :     if (va != NULL) 

  0000c	0a00000e	 beq         |$LN1@cppiDescri|

; 436  : 	{
; 437  :         UINT32 vaPoolBase  = (UINT32)f_CppiObj->pool;

  00010	e59f303c	 ldr         r3, [pc, #0x3C]
  00014	e5932000	 ldr         r2, [r3]
  00018	e5920898	 ldr         r0, [r2, #0x898]

; 438  :         UINT32 vaPoolLimit = (UINT32)f_CppiObj->pool + f_CppiObj->poolMaxSize;
; 439  : 
; 440  :         if (((UINT32)va < vaPoolBase) || ((UINT32)va > vaPoolLimit))

  0001c	e1510000	 cmp         r1, r0
  00020	3a000007	 bcc         |$LN2@cppiDescri|
  00024	e59238a8	 ldr         r3, [r2, #0x8A8]
  00028	e0803003	 add         r3, r0, r3
  0002c	e1510003	 cmp         r1, r3

; 443  : 		}
; 444  :         else
; 445  : 		{
; 446  :             pa = f_CppiObj->paPool.LowPart + ((UINT32)va - vaPoolBase);

  00030	959238a0	 ldrls       r3, [r2, #0x8A0]
  00034	90433000	 subls       r3, r3, r0
  00038	90830001	 addls       r0, r3, r1

; 447  : 		}
; 448  :     }
; 449  : 
; 450  :     return pa;
; 451  : }

  0003c	949de004	 ldrls       lr, [sp], #4
  00040	912fff1e	 bxls        lr
  00044		 |$LN2@cppiDescri|

; 441  : 		{
; 442  :             pa = USBCDMA_DescriptorVAtoPA(f_CppiObj->hUsbCdma, va);

  00044	e5920020	 ldr         r0, [r2, #0x20]
  00048	eb000000	 bl          USBCDMA_DescriptorVAtoPA
  0004c		 |$LN1@cppiDescri|

; 447  : 		}
; 448  :     }
; 449  : 
; 450  :     return pa;
; 451  : }

  0004c	e49de004	 ldr         lr, [sp], #4
  00050	e12fff1e	 bx          lr
  00054		 |$LN10@cppiDescri|
  00054		 |$LN11@cppiDescri|
  00054	00000000	 DCD         |f_CppiObj|
  00058		 |$M47466|

			 ENDP  ; |cppiDescriptorVAtoPA|

	IMPORT	|USBCDMA_DescriptorPAtoVA|

  00000			 AREA	 |.pdata|, PDATA
|$T47482| DCD	|$LN9@cppiDescri@2|
	DCD	0x40001601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiDescriptorPAtoVA| PROC

; 457  : {

  00000		 |$LN9@cppiDescri@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M47479|
  00004	e1b01000	 movs        r1, r0

; 458  :     void *va = NULL;

  00008	e3a00000	 mov         r0, #0

; 459  : 
; 460  :     if (pa != 0) 

  0000c	0a00000e	 beq         |$LN1@cppiDescri@2|

; 461  : 	{
; 462  :         UINT32 paPoolBase  = f_CppiObj->paPool.LowPart;

  00010	e59f303c	 ldr         r3, [pc, #0x3C]
  00014	e5932000	 ldr         r2, [r3]
  00018	e59208a0	 ldr         r0, [r2, #0x8A0]

; 463  :         UINT32 paPoolLimit = f_CppiObj->paPool.LowPart + f_CppiObj->poolMaxSize;
; 464  : 
; 465  :         if ((pa < paPoolBase) || (pa > paPoolLimit))

  0001c	e1510000	 cmp         r1, r0
  00020	3a000007	 bcc         |$LN2@cppiDescri@2|
  00024	e59238a8	 ldr         r3, [r2, #0x8A8]
  00028	e0803003	 add         r3, r0, r3
  0002c	e1510003	 cmp         r1, r3

; 468  : 		}
; 469  :         else
; 470  : 		{
; 471  :             va = (void *)(((UINT32)f_CppiObj->pool) + (pa - paPoolBase));

  00030	95923898	 ldrls       r3, [r2, #0x898]
  00034	90433000	 subls       r3, r3, r0
  00038	90830001	 addls       r0, r3, r1

; 472  : 		}
; 473  :     }
; 474  : 
; 475  :     return va;
; 476  : }

  0003c	949de004	 ldrls       lr, [sp], #4
  00040	912fff1e	 bxls        lr
  00044		 |$LN2@cppiDescri@2|

; 466  : 		{
; 467  :             va = USBCDMA_DescriptorPAtoVA(f_CppiObj->hUsbCdma, pa);

  00044	e5920020	 ldr         r0, [r2, #0x20]
  00048	eb000000	 bl          USBCDMA_DescriptorPAtoVA
  0004c		 |$LN1@cppiDescri@2|

; 472  : 		}
; 473  :     }
; 474  : 
; 475  :     return va;
; 476  : }

  0004c	e49de004	 ldr         lr, [sp], #4
  00050	e12fff1e	 bx          lr
  00054		 |$LN10@cppiDescri@2|
  00054		 |$LN11@cppiDescri@2|
  00054	00000000	 DCD         |f_CppiObj|
  00058		 |$M47480|

			 ENDP  ; |cppiDescriptorPAtoVA|

	EXPORT	|??_C@_1DK@LONLLCCG@?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAd?$AAe?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AAo?$AAr?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CF?$AAu?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T47509| DCD	|$LN18@cppiQueueP|
	DCD	0x40003701

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DK@LONLLCCG@?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAd?$AAe?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AAo?$AAr?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CF?$AAu?$AA?$AN?$AA?6?$AA?$AA@| DCB "I"
	DCB	0x0, "n", 0x0, "v", 0x0, "a", 0x0, "l", 0x0, "i", 0x0, "d"
	DCB	0x0, " ", 0x0, "d", 0x0, "e", 0x0, "s", 0x0, "c", 0x0, "r"
	DCB	0x0, "i", 0x0, "p", 0x0, "t", 0x0, "o", 0x0, "r", 0x0, " "
	DCB	0x0, "t", 0x0, "y", 0x0, "p", 0x0, "e", 0x0, " ", 0x0, "%"
	DCB	0x0, "u", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiQueuePush| PROC

; 480  : {

  00000		 |$LN18@cppiQueueP|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M47506|
  00004	e1a04002	 mov         r4, r2
  00008	e1a07001	 mov         r7, r1
  0000c	e1b08000	 movs        r8, r0

; 481  :     UINT32 value = 0;

  00010	e3a02000	 mov         r2, #0

; 482  : 
; 483  :     DEBUGCHK(pCppiRegs != NULL);
; 484  :     if (pCppiRegs == NULL)

  00014	0a00002a	 beq         |$LN8@cppiQueueP|

; 485  : 	{
; 486  :         return;
; 487  : 	}
; 488  : 
; 489  :     if (pDescriptor != NULL)

  00018	e3540000	 cmp         r4, #0
  0001c	0a000025	 beq         |$LN6@cppiQueueP|

; 490  :     {
; 491  :         UINT32 addr  = cppiDescriptorVAtoPA(pDescriptor);

  00020	e59f30b0	 ldr         r3, [pc, #0xB0]
  00024	e5932000	 ldr         r2, [r3]
  00028	e592e898	 ldr         lr, [r2, #0x898]
  0002c	e154000e	 cmp         r4, lr
  00030	3a000006	 bcc         |$LN11@cppiQueueP|
  00034	e59238a8	 ldr         r3, [r2, #0x8A8]
  00038	e083300e	 add         r3, r3, lr
  0003c	e1540003	 cmp         r4, r3
  00040	959238a0	 ldrls       r3, [r2, #0x8A0]
  00044	9043300e	 subls       r3, r3, lr
  00048	90836004	 addls       r6, r3, r4
  0004c	9a000003	 bls         |$LN10@cppiQueueP|
  00050		 |$LN11@cppiQueueP|
  00050	e5920020	 ldr         r0, [r2, #0x20]
  00054	e1a01004	 mov         r1, r4
  00058	eb000000	 bl          USBCDMA_DescriptorVAtoPA
  0005c	e1a06000	 mov         r6, r0
  00060		 |$LN10@cppiQueueP|

; 492  :         UINT32 size  = 0;
; 493  : 
; 494  :         UINT32 type = (*(UINT32*)pDescriptor & USB_CPPI41_DESC_TYPE_MASK) >> USB_CPPI41_DESC_TYPE_SHIFT;

  00060	e5943000	 ldr         r3, [r4]
  00064	e3a04000	 mov         r4, #0
  00068	e1a05da3	 mov         r5, r3, lsr #27

; 495  :         switch (type)

  0006c	e3550010	 cmp         r5, #0x10
  00070	0a00000c	 beq         |$LN3@cppiQueueP|
  00074	e3550013	 cmp         r5, #0x13
  00078	0a000008	 beq         |$LN2@cppiQueueP|

; 504  : 
; 505  :         default:
; 506  :             ERRORMSG(TRUE, (L"Invalid descriptor type %u\r\n", type));

  0007c	e59f1050	 ldr         r1, [pc, #0x50]
  00080	e59f0048	 ldr         r0, [pc, #0x48]
  00084	e3a03c01	 mov         r3, #1, 24
  00088	e38320fa	 orr         r2, r3, #0xFA
  0008c	eb000000	 bl          NKDbgPrintfW
  00090	e59f0034	 ldr         r0, [pc, #0x34]
  00094	e1a01005	 mov         r1, r5
  00098	eb000000	 bl          NKDbgPrintfW
  0009c	ea000002	 b           |$LN4@cppiQueueP|
  000a0		 |$LN2@cppiQueueP|

; 499  :             break;
; 500  : 
; 501  :         case USB_CPPI41_DESC_TYPE_TEARDOWN: /* Teardown descriptor */
; 502  :             size = (USB_CPPI_TD_SIZE - 24) / 4;

  000a0	e3a04002	 mov         r4, #2

; 503  :             break;

  000a4	ea000000	 b           |$LN4@cppiQueueP|
  000a8		 |$LN3@cppiQueueP|

; 496  :         {
; 497  :         case USB_CPPI41_DESC_TYPE_HOST:     /* Host descriptor */
; 498  :             size = (CPPI_HD_SIZE - 24) / 4;

  000a8	e3a0400a	 mov         r4, #0xA
  000ac		 |$LN4@cppiQueueP|

; 507  :         }
; 508  : 
; 509  :         value = ((addr & QMGR_QUEUE_N_REG_D_DESC_ADDR_MASK) |
; 510  :                  (size & QMGR_QUEUE_N_REG_D_DESCSZ_MASK   ));

  000ac	e3c6201f	 bic         r2, r6, #0x1F
  000b0	e204301f	 and         r3, r4, #0x1F
  000b4	e1822003	 orr         r2, r2, r3
  000b8		 |$LN6@cppiQueueP|

; 511  :     }
; 512  : 
; 513  :     pCppiRegs->QMQUEUEMGMT[queueNo].QCTRLD = value;

  000b8	e0883207	 add         r3, r8, r7, lsl #4
  000bc	e2833a05	 add         r3, r3, #5, 20
  000c0	e583200c	 str         r2, [r3, #0xC]
  000c4		 |$LN8@cppiQueueP|

; 514  : 
; 515  :     PRINTMSG(/*ZONE_PDD_DMA*/0, (L"cppiQueuePush: queue %u, value 0x%08x\r\n", queueNo, value));
; 516  : }

  000c4	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000c8	e12fff1e	 bx          lr
  000cc		 |$LN19@cppiQueueP|
  000cc		 |$LN20@cppiQueueP|
  000cc	00000000	 DCD         |??_C@_1DK@LONLLCCG@?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAd?$AAe?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AAo?$AAr?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CF?$AAu?$AA?$AN?$AA?6?$AA?$AA@|
  000d0		 |$LN21@cppiQueueP|
  000d0	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  000d4		 |$LN22@cppiQueueP|
  000d4	00000000	 DCD         |??_C@_1JM@MEFHOMOC@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  000d8		 |$LN23@cppiQueueP|
  000d8	00000000	 DCD         |f_CppiObj|
  000dc		 |$M47507|

			 ENDP  ; |cppiQueuePush|


  00000			 AREA	 |.pdata|, PDATA
|$T47538| DCD	|$LN12@cppiQueueP@2|
	DCD	0x40001d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiQueuePop| PROC

; 521  : {

  00000		 |$LN12@cppiQueueP@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M47535|
  00004	e3500000	 cmp         r0, #0

; 522  :     UINT32 value;
; 523  : 
; 524  :     DEBUGCHK(pCppiRegs != NULL);
; 525  :     if (pCppiRegs == NULL)
; 526  : 	{
; 527  :         return NULL;

  00008	03a00000	 moveq       r0, #0

; 535  : }

  0000c	049de004	 ldreq       lr, [sp], #4
  00010	012fff1e	 bxeq        lr

; 528  : 	}
; 529  : 
; 530  :     value = pCppiRegs->QMQUEUEMGMT[queueNo].QCTRLD & QMGR_QUEUE_N_REG_D_DESC_ADDR_MASK;

  00014	e0803201	 add         r3, r0, r1, lsl #4
  00018	e2833a05	 add         r3, r3, #5, 20
  0001c	e593300c	 ldr         r3, [r3, #0xC]

; 531  : 
; 532  :     PRINTMSG(/*ZONE_PDD_DMA*/0, (L"cppiQueuePop: queue %u, value 0x%08x\r\n", queueNo, value));
; 533  : 
; 534  :     return cppiDescriptorPAtoVA(value);

  00020	e3a00000	 mov         r0, #0
  00024	e3d3101f	 bics        r1, r3, #0x1F
  00028	0a00000e	 beq         |$LN4@cppiQueueP@2|
  0002c	e59f303c	 ldr         r3, [pc, #0x3C]
  00030	e5932000	 ldr         r2, [r3]
  00034	e59208a0	 ldr         r0, [r2, #0x8A0]
  00038	e1510000	 cmp         r1, r0
  0003c	3a000007	 bcc         |$LN5@cppiQueueP@2|
  00040	e59238a8	 ldr         r3, [r2, #0x8A8]
  00044	e0803003	 add         r3, r0, r3
  00048	e1510003	 cmp         r1, r3
  0004c	95923898	 ldrls       r3, [r2, #0x898]
  00050	90433000	 subls       r3, r3, r0
  00054	90830001	 addls       r0, r3, r1

; 535  : }

  00058	949de004	 ldrls       lr, [sp], #4
  0005c	912fff1e	 bxls        lr

; 531  : 
; 532  :     PRINTMSG(/*ZONE_PDD_DMA*/0, (L"cppiQueuePop: queue %u, value 0x%08x\r\n", queueNo, value));
; 533  : 
; 534  :     return cppiDescriptorPAtoVA(value);

  00060		 |$LN5@cppiQueueP@2|
  00060	e5920020	 ldr         r0, [r2, #0x20]
  00064	eb000000	 bl          USBCDMA_DescriptorPAtoVA
  00068		 |$LN4@cppiQueueP@2|

; 535  : }

  00068	e49de004	 ldr         lr, [sp], #4
  0006c	e12fff1e	 bx          lr
  00070		 |$LN13@cppiQueueP@2|
  00070		 |$LN14@cppiQueueP@2|
  00070	00000000	 DCD         |f_CppiObj|
  00074		 |$M47536|

			 ENDP  ; |cppiQueuePop|

	EXPORT	|??_C@_1JE@HCAMEFBJ@?$AAc?$AAp?$AAp?$AAi?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AAd?$AAT?$AAe?$AAa?$AAr?$AAd?$AAo?$AAw?$AAn?$AA?3?$AA?5?$AA?$CF?$AAs@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GE@OEBHEFNP@?$AAc?$AAp?$AAp?$AAi?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AAd?$AAT?$AAe?$AAa?$AAr?$AAd?$AAo?$AAw?$AAn?$AA?3?$AA?5?$AA?$CF?$AAs@| [ DATA ] ; `string'
	EXPORT	|??_C@_15BMCNAON@?$AAR?$AAX?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_15NHJLDDPA@?$AAT?$AAX?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T47556| DCD	|$LN11@cppiProces|
	DCD	0x40003001

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1JE@HCAMEFBJ@?$AAc?$AAp?$AAp?$AAi?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AAd?$AAT?$AAe?$AAa?$AAr?$AAd?$AAo?$AAw?$AAn?$AA?3?$AA?5?$AA?$CF?$AAs@| DCB "c"
	DCB	0x0, "p", 0x0, "p", 0x0, "i", 0x0, "P", 0x0, "r", 0x0, "o"
	DCB	0x0, "c", 0x0, "e", 0x0, "s", 0x0, "s", 0x0, "C", 0x0, "o"
	DCB	0x0, "m", 0x0, "p", 0x0, "l", 0x0, "e", 0x0, "t", 0x0, "e"
	DCB	0x0, "d", 0x0, "T", 0x0, "e", 0x0, "a", 0x0, "r", 0x0, "d"
	DCB	0x0, "o", 0x0, "w", 0x0, "n", 0x0, ":", 0x0, " ", 0x0, "%"
	DCB	0x0, "s", 0x0, " ", 0x0, "C", 0x0, "h", 0x0, " ", 0x0, "%"
	DCB	0x0, "u", 0x0, " ", 0x0, "-", 0x0, " ", 0x0, "N", 0x0, "o"
	DCB	0x0, "t", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "q", 0x0, "u"
	DCB	0x0, "e", 0x0, "s", 0x0, "t", 0x0, "e", 0x0, "d", 0x0, " "
	DCB	0x0, "f", 0x0, "o", 0x0, "r", 0x0, " ", 0x0, "t", 0x0, "h"
	DCB	0x0, "i", 0x0, "s", 0x0, " ", 0x0, "c", 0x0, "h", 0x0, "a"
	DCB	0x0, "n", 0x0, "n", 0x0, "e", 0x0, "l", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GE@OEBHEFNP@?$AAc?$AAp?$AAp?$AAi?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AAd?$AAT?$AAe?$AAa?$AAr?$AAd?$AAo?$AAw?$AAn?$AA?3?$AA?5?$AA?$CF?$AAs@| DCB "c"
	DCB	0x0, "p", 0x0, "p", 0x0, "i", 0x0, "P", 0x0, "r", 0x0, "o"
	DCB	0x0, "c", 0x0, "e", 0x0, "s", 0x0, "s", 0x0, "C", 0x0, "o"
	DCB	0x0, "m", 0x0, "p", 0x0, "l", 0x0, "e", 0x0, "t", 0x0, "e"
	DCB	0x0, "d", 0x0, "T", 0x0, "e", 0x0, "a", 0x0, "r", 0x0, "d"
	DCB	0x0, "o", 0x0, "w", 0x0, "n", 0x0, ":", 0x0, " ", 0x0, "%"
	DCB	0x0, "s", 0x0, " ", 0x0, "C", 0x0, "h", 0x0, " ", 0x0, "%"
	DCB	0x0, "u", 0x0, ",", 0x0, " ", 0x0, "N", 0x0, "U", 0x0, "L"
	DCB	0x0, "L", 0x0, " ", 0x0, "T", 0x0, "D", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_15BMCNAON@?$AAR?$AAX?$AA?$AA@| DCB "R", 0x0, "X", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_15NHJLDDPA@?$AAT?$AAX?$AA?$AA@| DCB "T", 0x0, "X", 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiProcessCompletedTeardown| PROC

; 803  : {

  00000		 |$LN11@cppiProces|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M47553|
  00004	e1a04002	 mov         r4, r2
  00008	e1a06001	 mov         r6, r1
  0000c	e1a08000	 mov         r8, r0

; 804  : #ifndef SHIP_BUILD
; 805  :     BYTE   chanNum = chanPtr->channelNo;
; 806  :     WCHAR *chanDir = chanPtr->transmit ? L"TX" : L"RX";

  00010	e5943014	 ldr         r3, [r4, #0x14]
  00014	e5d47018	 ldrb        r7, [r4, #0x18]
  00018	e3530000	 cmp         r3, #0
  0001c	159f5098	 ldrne       r5, [pc, #0x98]
  00020	059f5090	 ldreq       r5, [pc, #0x90]

; 807  : #endif
; 808  : 
; 809  :     DEBUGMSG(ZONE_PDD_DMA,
; 810  :         (L"+cppiProcessCompletedTeardown: %s Ch %u\r\n",
; 811  :         chanDir,
; 812  :         chanNum));
; 813  : 
; 814  :     if (tdPtr == NULL) 

  00024	e3560000	 cmp         r6, #0
  00028	1a00000a	 bne         |$LN2@cppiProces|

; 815  : 	{
; 816  :         ERRORMSG(TRUE,
; 817  :             (L"cppiProcessCompletedTeardown: %s Ch %u, NULL TD\r\n",
; 818  :             chanDir,
; 819  :             chanNum));

  0002c	e59f107c	 ldr         r1, [pc, #0x7C]
  00030	e59f0074	 ldr         r0, [pc, #0x74]
  00034	e3a03c03	 mov         r3, #3, 24
  00038	e3832033	 orr         r2, r3, #0x33
  0003c	eb000000	 bl          NKDbgPrintfW
  00040	e59f006c	 ldr         r0, [pc, #0x6C]
  00044	e1a02007	 mov         r2, r7
  00048	e1a01005	 mov         r1, r5
  0004c	eb000000	 bl          NKDbgPrintfW

; 830  :     }
; 831  : 
; 832  :     DEBUGMSG(ZONE_PDD_DMA,
; 833  :         (L"-cppiProcessCompletedTeardown: %s Ch %u\r\n",
; 834  :         chanDir,
; 835  :         chanNum));
; 836  : }

  00050	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$LN2@cppiProces|

; 820  :     }
; 821  :     else
; 822  :     {
; 823  :         ERRORMSG(chanPtr->isTeardownPending == FALSE,
; 824  :             (L"cppiProcessCompletedTeardown: %s Ch %u - Not requested for this channel\r\n",
; 825  :             chanDir,
; 826  :             chanNum));

  00058	e594301c	 ldr         r3, [r4, #0x1C]
  0005c	e3530000	 cmp         r3, #0
  00060	1a000008	 bne         |$LN7@cppiProces|
  00064	e59f1044	 ldr         r1, [pc, #0x44]
  00068	e59f003c	 ldr         r0, [pc, #0x3C]
  0006c	e3a03c03	 mov         r3, #3, 24
  00070	e383203a	 orr         r2, r3, #0x3A
  00074	eb000000	 bl          NKDbgPrintfW
  00078	e59f0028	 ldr         r0, [pc, #0x28]
  0007c	e1a02007	 mov         r2, r7
  00080	e1a01005	 mov         r1, r5
  00084	eb000000	 bl          NKDbgPrintfW
  00088		 |$LN7@cppiProces|

; 827  : 
; 828  :         cppiQueuePush(pPdd->pCppiRegs, USB_CPPI_TDFREE_QNUM, tdPtr);

  00088	e5980020	 ldr         r0, [r8, #0x20]
  0008c	e1a02006	 mov         r2, r6
  00090	e3a0100f	 mov         r1, #0xF
  00094	eb000000	 bl          cppiQueuePush

; 829  :         chanPtr->isTeardownPending = FALSE;

  00098	e3a03000	 mov         r3, #0
  0009c	e584301c	 str         r3, [r4, #0x1C]

; 830  :     }
; 831  : 
; 832  :     DEBUGMSG(ZONE_PDD_DMA,
; 833  :         (L"-cppiProcessCompletedTeardown: %s Ch %u\r\n",
; 834  :         chanDir,
; 835  :         chanNum));
; 836  : }

  000a0	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000a4	e12fff1e	 bx          lr
  000a8		 |$LN12@cppiProces|
  000a8		 |$LN13@cppiProces|
  000a8	00000000	 DCD         |??_C@_1JE@HCAMEFBJ@?$AAc?$AAp?$AAp?$AAi?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AAd?$AAT?$AAe?$AAa?$AAr?$AAd?$AAo?$AAw?$AAn?$AA?3?$AA?5?$AA?$CF?$AAs@|
  000ac		 |$LN14@cppiProces|
  000ac	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  000b0		 |$LN15@cppiProces|
  000b0	00000000	 DCD         |??_C@_1JM@MEFHOMOC@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  000b4		 |$LN16@cppiProces|
  000b4	00000000	 DCD         |??_C@_1GE@OEBHEFNP@?$AAc?$AAp?$AAp?$AAi?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AAd?$AAT?$AAe?$AAa?$AAr?$AAd?$AAo?$AAw?$AAn?$AA?3?$AA?5?$AA?$CF?$AAs@|
  000b8		 |$LN17@cppiProces|
  000b8	00000000	 DCD         |??_C@_15BMCNAON@?$AAR?$AAX?$AA?$AA@|
  000bc		 |$LN18@cppiProces|
  000bc	00000000	 DCD         |??_C@_15NHJLDDPA@?$AAT?$AAX?$AA?$AA@|
  000c0		 |$M47554|

			 ENDP  ; |cppiProcessCompletedTeardown|


  00000			 AREA	 |.pdata|, PDATA
|$T47580| DCD	|$LN15@cppiContro|
	DCD	0x40002f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiControllerStart| PROC

; 851  : {

  00000		 |$LN15@cppiContro|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47577|

; 852  :     struct cppi *pController = (struct cppi *)dmac;
; 853  :     CSL_CppiRegs *pCppiRegs	 = pController->pRegs;

  00004	e590e01c	 ldr         lr, [r0, #0x1C]

; 854  :     int n					 = 0;
; 855  : 
; 856  :     PRINTMSG(ZONE_PDD_INIT,
; 857  :         (L"+cppiControllerStart: Resetting Channel Info\r\n"));
; 858  : 
; 859  :     /* Initialise the CPPI tx channels
; 860  :      */
; 861  :     for (n = 0; n < dim(pController->txCppi); n++)

  00008	e3a01000	 mov         r1, #0
  0000c	e2802028	 add         r2, r0, #0x28
  00010	e3a04000	 mov         r4, #0
  00014	e3a05001	 mov         r5, #1
  00018		 |$LL6@cppiContro|

; 862  :     {
; 863  :         struct cppi_channel *txChannel = pController->txCppi + n;
; 864  : 
; 865  :         /* initialize channel fields */
; 866  :         txChannel->Channel.pPrivateData = txChannel;

  00018	e8820014	 stmia       r2, {r2, r4}

; 867  :         txChannel->Channel.bStatus = MGC_DMA_STATUS_UNKNOWN;
; 868  :         txChannel->pController = pController;

  0001c	e5820008	 str         r0, [r2, #8]

; 869  :         txChannel->transmit  = TRUE;

  00020	e5825014	 str         r5, [r2, #0x14]

; 870  :         txChannel->channelNo = (UINT8)n;

  00024	e5c21018	 strb        r1, [r2, #0x18]

; 871  :         txChannel->queueNo   = pController->txqOffset + (UINT8)(2 * n);

  00028	e5d03026	 ldrb        r3, [r0, #0x26]

; 872  :         txChannel->lastModeRndis = 0;
; 873  :         txChannel->isTeardownPending = FALSE;

  0002c	e5c2401a	 strb        r4, [r2, #0x1A]
  00030	e582401c	 str         r4, [r2, #0x1C]
  00034	e0833081	 add         r3, r3, r1, lsl #1
  00038	e5c23019	 strb        r3, [r2, #0x19]

; 874  :         txChannel->pRegs = &(pCppiRegs->CDMACHANNEL[n + pController->chanOffset]);

  0003c	e5d03024	 ldrb        r3, [r0, #0x24]
  00040	e0833001	 add         r3, r3, r1
  00044	e2833040	 add         r3, r3, #0x40
  00048	e08e3283	 add         r3, lr, r3, lsl #5
  0004c	e2811001	 add         r1, r1, #1
  00050	e582300c	 str         r3, [r2, #0xC]
  00054	e2822048	 add         r2, r2, #0x48
  00058	e351000f	 cmp         r1, #0xF
  0005c	3affffed	 bcc         |$LL6@cppiContro|

; 875  : 
; 876  :         PRINTMSG(/*ZONE_PDD_INIT*/0,
; 877  :             (L"TX Ch %02u: Queue %u, CDMA regs 0x%08x\r\n",
; 878  :             txChannel->channelNo,
; 879  :             txChannel->queueNo,
; 880  :             txChannel->pRegs));
; 881  :     }
; 882  : 
; 883  :     /* Initialise the CPPI rx channels
; 884  :      */
; 885  :     for (n = 0; n < dim(pController->rxCppi); n++)

  00060	e3a01000	 mov         r1, #0
  00064	e2802e46	 add         r2, r0, #0x46, 28
  00068		 |$LL3@cppiContro|

; 886  :     {
; 887  :         struct cppi_channel *rxChannel = pController->rxCppi + n;
; 888  : 
; 889  :         /* initialize channel fields */
; 890  :         rxChannel->Channel.pPrivateData = rxChannel;

  00068	e8820014	 stmia       r2, {r2, r4}

; 891  :         rxChannel->Channel.bStatus = MGC_DMA_STATUS_UNKNOWN;
; 892  :         rxChannel->pController = pController;

  0006c	e5820008	 str         r0, [r2, #8]

; 893  :         rxChannel->transmit  = FALSE;

  00070	e5824014	 str         r4, [r2, #0x14]

; 894  :         rxChannel->channelNo = (UINT8)n;

  00074	e5c21018	 strb        r1, [r2, #0x18]

; 895  :         rxChannel->queueNo   = pController->rxqOffset + (UINT8)n;

  00078	e5d03025	 ldrb        r3, [r0, #0x25]

; 896  :         rxChannel->lastModeRndis = 0;
; 897  :         rxChannel->isTeardownPending = FALSE;

  0007c	e5c2401a	 strb        r4, [r2, #0x1A]
  00080	e582401c	 str         r4, [r2, #0x1C]
  00084	e0833001	 add         r3, r3, r1
  00088	e5c23019	 strb        r3, [r2, #0x19]

; 898  :         rxChannel->pRegs = &(pCppiRegs->CDMACHANNEL[n + pController->chanOffset]);

  0008c	e5d03024	 ldrb        r3, [r0, #0x24]
  00090	e0833001	 add         r3, r3, r1
  00094	e2833040	 add         r3, r3, #0x40
  00098	e08e3283	 add         r3, lr, r3, lsl #5
  0009c	e2811001	 add         r1, r1, #1
  000a0	e582300c	 str         r3, [r2, #0xC]
  000a4	e2822048	 add         r2, r2, #0x48
  000a8	e351000f	 cmp         r1, #0xF
  000ac	3affffed	 bcc         |$LL3@cppiContro|

; 899  : 
; 900  :         PRINTMSG(/*ZONE_PDD_INIT*/0,
; 901  :             (L"RX Ch %02u: Queue %u, CDMA regs 0x%08x\r\n",
; 902  :             rxChannel->channelNo,
; 903  :             rxChannel->queueNo,
; 904  :             rxChannel->pRegs));
; 905  :     }
; 906  : 
; 907  :     PRINTMSG(ZONE_PDD_INIT,
; 908  :         (L"-cppiControllerStart\r\n"));
; 909  : 
; 910  :     return 0;

  000b0	e3a00000	 mov         r0, #0

; 911  : }

  000b4	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000b8	e12fff1e	 bx          lr
  000bc		 |$M47578|

			 ENDP  ; |cppiControllerStart|

	EXPORT	|cppiChannelAllocate|
	EXPORT	|??_C@_1GG@DHKDJAMA@?$AAc?$AAp?$AAp?$AAi?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?3?$AA?5?$AAn?$AAo?$AA?5?$AAR?$AAX?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAc@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GG@GGILNKFO@?$AAc?$AAp?$AAp?$AAi?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?3?$AA?5?$AAn?$AAo?$AA?5?$AAT?$AAx?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAc@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T47597| DCD	|$LN12@cppiChanne|
	DCD	0x40004901

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GG@DHKDJAMA@?$AAc?$AAp?$AAp?$AAi?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?3?$AA?5?$AAn?$AAo?$AA?5?$AAR?$AAX?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAc@| DCB "c"
	DCB	0x0, "p", 0x0, "p", 0x0, "i", 0x0, "C", 0x0, "h", 0x0, "a"
	DCB	0x0, "n", 0x0, "n", 0x0, "e", 0x0, "l", 0x0, "A", 0x0, "l"
	DCB	0x0, "l", 0x0, "o", 0x0, "c", 0x0, "a", 0x0, "t", 0x0, "e"
	DCB	0x0, ":", 0x0, " ", 0x0, "n", 0x0, "o", 0x0, " ", 0x0, "R"
	DCB	0x0, "X", 0x0, " ", 0x0, "D", 0x0, "M", 0x0, "A", 0x0, " "
	DCB	0x0, "c", 0x0, "h", 0x0, "a", 0x0, "n", 0x0, "n", 0x0, "e"
	DCB	0x0, "l", 0x0, " ", 0x0, "f", 0x0, "o", 0x0, "r", 0x0, " "
	DCB	0x0, "E", 0x0, "P", 0x0, " ", 0x0, "%", 0x0, "u", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GG@GGILNKFO@?$AAc?$AAp?$AAp?$AAi?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?3?$AA?5?$AAn?$AAo?$AA?5?$AAT?$AAx?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAc@| DCB "c"
	DCB	0x0, "p", 0x0, "p", 0x0, "i", 0x0, "C", 0x0, "h", 0x0, "a"
	DCB	0x0, "n", 0x0, "n", 0x0, "e", 0x0, "l", 0x0, "A", 0x0, "l"
	DCB	0x0, "l", 0x0, "o", 0x0, "c", 0x0, "a", 0x0, "t", 0x0, "e"
	DCB	0x0, ":", 0x0, " ", 0x0, "n", 0x0, "o", 0x0, " ", 0x0, "T"
	DCB	0x0, "x", 0x0, " ", 0x0, "D", 0x0, "M", 0x0, "A", 0x0, " "
	DCB	0x0, "c", 0x0, "h", 0x0, "a", 0x0, "n", 0x0, "n", 0x0, "e"
	DCB	0x0, "l", 0x0, " ", 0x0, "f", 0x0, "o", 0x0, "r", 0x0, " "
	DCB	0x0, "E", 0x0, "P", 0x0, " ", 0x0, "%", 0x0, "u", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiChannelAllocate| PROC

; 966  : {

  00000		 |$LN12@cppiChanne|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M47594|
  00004	e1a07003	 mov         r7, r3
  00008	e1a05002	 mov         r5, r2
  0000c	e1a04001	 mov         r4, r1
  00010	e1a06000	 mov         r6, r0

; 967  :     struct cppi *pController;
; 968  :     struct cppi_channel *otgCh;
; 969  :     CSL_UsbRegs *pUsbRegs = (CSL_UsbRegs *)NULL;
; 970  :     UINT8 chanNum;
; 971  : 
; 972  :     pController = (struct cppi *)dmac;
; 973  :     pUsbRegs = pController->pPdd->pUsbdRegs;
; 974  : 
; 975  :     PRINTMSG(ZONE_PDD_INIT,
; 976  :         (L"+cppiChannelAllocate: EP %u Tx%x pfmDma 0x%08x\r\n",
; 977  :         ep->epNumber,
; 978  :         bTransmit,
; 979  :         pFnDma));
; 980  : 
; 981  :     /* Note: The CPPI Channel numbering scheme starts from 0.
; 982  :      * whereas the Non-Control EndPoints starts with 1.
; 983  :      * Hence in order to derive Channel Number associated
; 984  :      * for a given EP, we will subtract 1
; 985  :      */
; 986  :     chanNum = (UINT8)(ep->epNumber - 1);

  00014	e1d410b0	 ldrh        r1, [r4]

; 987  : 
; 988  :     /* return the corresponding CPPI Channel Handle, and
; 989  :      * probably disable the non-CPPI irq until we need it.
; 990  :      */
; 991  :     if (bTransmit == TRUE)

  00018	e3550001	 cmp         r5, #1
  0001c	e281e0ff	 add         lr, r1, #0xFF
  00020	e20ee0ff	 and         lr, lr, #0xFF
  00024	1a000014	 bne         |$LN5@cppiChanne|

; 992  :     {
; 993  :         if (ep->epNumber > dim(pController->txCppi))

  00028	e351000f	 cmp         r1, #0xF
  0002c	9a00000a	 bls         |$LN4@cppiChanne|

; 994  :         {
; 995  :             ERRORMSG (TRUE,
; 996  :                       (L"cppiChannelAllocate: no Tx DMA channel for EP %u\r\n",
; 997  :                        ep->epNumber));

  00030	e59f10e4	 ldr         r1, [pc, #0xE4]
  00034	e59f00dc	 ldr         r0, [pc, #0xDC]
  00038	e3a03c03	 mov         r3, #3, 24
  0003c	e38320e5	 orr         r2, r3, #0xE5
  00040	eb000000	 bl          NKDbgPrintfW
  00044	e59f00d4	 ldr         r0, [pc, #0xD4]
  00048		 |$LN9@cppiChanne|
  00048	e1d410b0	 ldrh        r1, [r4]
  0004c	eb000000	 bl          NKDbgPrintfW

; 998  :             return NULL;

  00050	e3a00000	 mov         r0, #0

; 1054 : 
; 1055 :     DEBUGMSG(ZONE_PDD_INIT,
; 1056 :         (L"-cppiChannelAllocate: EP %u DMA Channel 0x%08x\r\n",
; 1057 :         ep->epNumber,
; 1058 :         &otgCh->Channel));
; 1059 : 
; 1060 :     return &(otgCh->Channel);
; 1061 : }

  00054	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$LN4@cppiChanne|

; 999  :         }
; 1000 : 
; 1001 :         otgCh = pController->txCppi + chanNum;

  0005c	e08e318e	 add         r3, lr, lr, lsl #3
  00060	e0863183	 add         r3, r6, r3, lsl #3
  00064	e2830028	 add         r0, r3, #0x28

; 1002 : 
; 1003 :         otgCh->pRegs->TXGCR =
; 1004 :             BIT31 | /* Enable
; 1005 :             qmgr |
; 1006 :             qnum? */ USB_CPPI_TXCMPL_QNUM_FN;

  00068	e590200c	 ldr         r2, [r0, #0xC]
  0006c	e3a03102	 mov         r3, #2, 2
  00070	e3833040	 orr         r3, r3, #0x40
  00074	e5823000	 str         r3, [r2]

; 1007 :     }
; 1008 :     else

  00078	ea000018	 b           |$LN3@cppiChanne|
  0007c		 |$LN5@cppiChanne|

; 1009 :     {
; 1010 :         if (ep->epNumber > dim(pController->rxCppi))

  0007c	e351000f	 cmp         r1, #0xF
  00080	9a000006	 bls         |$LN2@cppiChanne|

; 1011 :         {
; 1012 :             ERRORMSG (TRUE,
; 1013 :                       (L"cppiChannelAllocate: no RX DMA channel for EP %u\r\n",
; 1014 :                        ep->epNumber));

  00084	e59f1090	 ldr         r1, [pc, #0x90]
  00088	e59f0088	 ldr         r0, [pc, #0x88]
  0008c	e3a03c03	 mov         r3, #3, 24
  00090	e38320f6	 orr         r2, r3, #0xF6
  00094	eb000000	 bl          NKDbgPrintfW
  00098	e59f0074	 ldr         r0, [pc, #0x74]

; 1015 :             return NULL;

  0009c	eaffffe9	 b           |$LN9@cppiChanne|
  000a0		 |$LN2@cppiChanne|

; 1016 :         }
; 1017 : 
; 1018 :         otgCh = pController->rxCppi + chanNum;

  000a0	e08e318e	 add         r3, lr, lr, lsl #3
  000a4	e0863183	 add         r3, r6, r3, lsl #3
  000a8	e2830e46	 add         r0, r3, #0x46, 28

; 1019 : 
; 1020 :         otgCh->pRegs->HPCRA =
; 1021 :             ((chanNum + pController->chanOffset) |
; 1022 :             ((chanNum + pController->chanOffset) << 16));

  000ac	e5d63024	 ldrb        r3, [r6, #0x24]
  000b0	e590200c	 ldr         r2, [r0, #0xC]

; 1023 : 
; 1024 :         otgCh->pRegs->HPCRB =
; 1025 :             ((chanNum + pController->chanOffset) |
; 1026 :             ((chanNum + pController->chanOffset) << 16));
; 1027 : 
; 1028 :         otgCh->pRegs->RXGCR =
; 1029 :             BIT31 | /* Enable */
; 1030 :             BIT24 | /* Retry on starvation */
; 1031 :             BIT14 | /* Host descriptor type (default) */ /*
; 1032 :             qmgr |
; 1033 :             qnum? */ USB_CPPI_RXCMPL_QNUM_FN;

  000b4	e59f1054	 ldr         r1, [pc, #0x54]
  000b8	e083300e	 add         r3, r3, lr
  000bc	e1833803	 orr         r3, r3, r3, lsl #16
  000c0	e582300c	 str         r3, [r2, #0xC]
  000c4	e5d63024	 ldrb        r3, [r6, #0x24]
  000c8	e590200c	 ldr         r2, [r0, #0xC]
  000cc	e083300e	 add         r3, r3, lr
  000d0	e1833803	 orr         r3, r3, r3, lsl #16
  000d4	e5823010	 str         r3, [r2, #0x10]
  000d8	e590300c	 ldr         r3, [r0, #0xC]
  000dc	e5831008	 str         r1, [r3, #8]
  000e0		 |$LN3@cppiChanne|

; 1034 :     }
; 1035 : 
; 1036 :     if (otgCh->pEndPt != NULL)
; 1037 :     {
; 1038 :         PRINTMSG (ZONE_PDD_INIT,
; 1039 :                   (L"cppiChannelAllocate: re-allocating DMA %u channel from EP %u\r\n",
; 1040 :                    otgCh->channelNo, otgCh->pEndPt->epNumber));
; 1041 :     }
; 1042 : 
; 1043 :     /* Update the Channel structure with the information given */
; 1044 :     otgCh->pEndPt = ep;
; 1045 :     otgCh->Channel.bStatus = MGC_DMA_STATUS_FREE;

  000e0	e3a03001	 mov         r3, #1

; 1046 :     otgCh->Channel.pPrivateData = otgCh;
; 1047 : 
; 1048 :     otgCh->pfnDmaCompleted = pFnDma;
; 1049 :     otgCh->transmit        = bTransmit;
; 1050 :     otgCh->nISOHDQueued      = 0;

  000e4	e8800009	 stmia       r0, {r0, r3}
  000e8	e3a03000	 mov         r3, #0
  000ec	e580303c	 str         r3, [r0, #0x3C]

; 1051 :     otgCh->nISOHDPerTransfer = 0;

  000f0	e5803034	 str         r3, [r0, #0x34]

; 1052 :     otgCh->nISOHDForCallback = 0;

  000f4	e5803038	 str         r3, [r0, #0x38]

; 1053 :     otgCh->nISOHDLastIndex   = 0;

  000f8	e280c040	 add         r12, r0, #0x40
  000fc	e88c0088	 stmia       r12, {r3, r7}
  00100	e5804010	 str         r4, [r0, #0x10]
  00104	e5805014	 str         r5, [r0, #0x14]

; 1054 : 
; 1055 :     DEBUGMSG(ZONE_PDD_INIT,
; 1056 :         (L"-cppiChannelAllocate: EP %u DMA Channel 0x%08x\r\n",
; 1057 :         ep->epNumber,
; 1058 :         &otgCh->Channel));
; 1059 : 
; 1060 :     return &(otgCh->Channel);
; 1061 : }

  00108	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0010c	e12fff1e	 bx          lr
  00110		 |$LN13@cppiChanne|
  00110		 |$LN14@cppiChanne|
  00110	81004042	 DCD         0x81004042
  00114		 |$LN15@cppiChanne|
  00114	00000000	 DCD         |??_C@_1GG@DHKDJAMA@?$AAc?$AAp?$AAp?$AAi?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?3?$AA?5?$AAn?$AAo?$AA?5?$AAR?$AAX?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAc@|
  00118		 |$LN16@cppiChanne|
  00118	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  0011c		 |$LN17@cppiChanne|
  0011c	00000000	 DCD         |??_C@_1JM@MEFHOMOC@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  00120		 |$LN18@cppiChanne|
  00120	00000000	 DCD         |??_C@_1GG@GGILNKFO@?$AAc?$AAp?$AAp?$AAi?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?3?$AA?5?$AAn?$AAo?$AA?5?$AAT?$AAx?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAc@|
  00124		 |$M47595|

			 ENDP  ; |cppiChannelAllocate|

	EXPORT	|??_C@_1FO@NAGFODI@?$AAc?$AAp?$AAp?$AAi?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?3?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?9?$AA?5?$AAT?$AAe?$AAa?$AAr@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FE@MBMJCKKK@?$AAc?$AAp?$AAp?$AAi?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?3?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAA?$AAr?$AAg?$AAu@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T47613| DCD	|$LN14@cppiChanne@2|
	DCD	0x40002f01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FO@NAGFODI@?$AAc?$AAp?$AAp?$AAi?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?3?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?9?$AA?5?$AAT?$AAe?$AAa?$AAr@| DCB "c"
	DCB	0x0, "p", 0x0, "p", 0x0, "i", 0x0, "C", 0x0, "h", 0x0, "a"
	DCB	0x0, "n", 0x0, "n", 0x0, "e", 0x0, "l", 0x0, "R", 0x0, "e"
	DCB	0x0, "l", 0x0, "e", 0x0, "a", 0x0, "s", 0x0, "e", 0x0, ":"
	DCB	0x0, " ", 0x0, "E", 0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R"
	DCB	0x0, " ", 0x0, "-", 0x0, " ", 0x0, "T", 0x0, "e", 0x0, "a"
	DCB	0x0, "r", 0x0, "d", 0x0, "o", 0x0, "w", 0x0, "n", 0x0, " "
	DCB	0x0, "p", 0x0, "e", 0x0, "n", 0x0, "d", 0x0, "i", 0x0, "n"
	DCB	0x0, "g", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FE@MBMJCKKK@?$AAc?$AAp?$AAp?$AAi?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?3?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAA?$AAr?$AAg?$AAu@| DCB "c"
	DCB	0x0, "p", 0x0, "p", 0x0, "i", 0x0, "C", 0x0, "h", 0x0, "a"
	DCB	0x0, "n", 0x0, "n", 0x0, "e", 0x0, "l", 0x0, "R", 0x0, "e"
	DCB	0x0, "l", 0x0, "e", 0x0, "a", 0x0, "s", 0x0, "e", 0x0, ":"
	DCB	0x0, " ", 0x0, "I", 0x0, "n", 0x0, "v", 0x0, "a", 0x0, "l"
	DCB	0x0, "i", 0x0, "d", 0x0, " ", 0x0, "A", 0x0, "r", 0x0, "g"
	DCB	0x0, "u", 0x0, "m", 0x0, "e", 0x0, "n", 0x0, "t", 0x0, "s"
	DCB	0x0, ".", 0x0, ".", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiChannelRelease| PROC

; 1074 : {

  00000		 |$LN14@cppiChanne@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M47610|
  00004	e1b04000	 movs        r4, r0

; 1075 :     struct cppi_channel *c = (struct cppi_channel *)channel;
; 1076 : 
; 1077 :     DEBUGCHK(channel != NULL);
; 1078 : 
; 1079 :     PRINTMSG(ZONE_PDD_INIT, (L"cppiChannelRelease: Ch %u\r\n", c->channelNo));
; 1080 : 
; 1081 :     /* Sanity check on the Arguments. Verify if the State is not UNKNOWN
; 1082 :      * before trying to release the Channel.
; 1083 :      */
; 1084 :     if (channel == NULL)

  00008	1a000008	 bne         |$LN7@cppiChanne@2|

; 1085 :     {
; 1086 :         ERRORMSG (TRUE, (L"cppiChannelRelease: Invalid Arguments..\r\n"));

  0000c	e59f10a0	 ldr         r1, [pc, #0xA0]
  00010	e59f0098	 ldr         r0, [pc, #0x98]
  00014	e3a03b01	 mov         r3, #1, 22
  00018	e383203e	 orr         r2, r3, #0x3E
  0001c	eb000000	 bl          NKDbgPrintfW
  00020	e59f0090	 ldr         r0, [pc, #0x90]
  00024	eb000000	 bl          NKDbgPrintfW

; 1121 :         }
; 1122 :     }
; 1123 : }

  00028	e8bd4010	 ldmia       sp!, {r4, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$LN7@cppiChanne@2|

; 1087 :     }
; 1088 :     else if (channel->bStatus != MGC_DMA_STATUS_UNKNOWN)

  00030	e5943004	 ldr         r3, [r4, #4]
  00034	e3530000	 cmp         r3, #0
  00038	0a000018	 beq         |$LN1@cppiChanne@2|

; 1089 :     {
; 1090 :         channel->bStatus = MGC_DMA_STATUS_UNKNOWN;
; 1091 : 
; 1092 :         if (c->pEndPt == NULL)

  0003c	e5943010	 ldr         r3, [r4, #0x10]
  00040	e3a02000	 mov         r2, #0
  00044	e5842004	 str         r2, [r4, #4]
  00048	e3530000	 cmp         r3, #0

; 1093 :         {
; 1094 :             PRINTMSG(ZONE_PDD_INIT, (L"cppiChannelRelease: Releasing idle DMA channel\r\n"));
; 1095 :         }
; 1096 :         else
; 1097 : 		{
; 1098 :             c->pEndPt = NULL;
; 1099 : 		}
; 1100 : 
; 1101 :         ERRORMSG(c->isTeardownPending, (L"cppiChannelRelease: ERROR - Teardown pending\r\n"));

  0004c	e594301c	 ldr         r3, [r4, #0x1C]
  00050	15842010	 strne       r2, [r4, #0x10]
  00054	e3530000	 cmp         r3, #0
  00058	0a000006	 beq         |$LN10@cppiChanne@2|
  0005c	e59f1050	 ldr         r1, [pc, #0x50]
  00060	e59f0048	 ldr         r0, [pc, #0x48]
  00064	e3a03b01	 mov         r3, #1, 22
  00068	e383204d	 orr         r2, r3, #0x4D
  0006c	eb000000	 bl          NKDbgPrintfW
  00070	e59f0034	 ldr         r0, [pc, #0x34]
  00074	eb000000	 bl          NKDbgPrintfW
  00078		 |$LN10@cppiChanne@2|

; 1102 : 
; 1103 :         /* Disable the CDMA channel */
; 1104 :         if (c->transmit)

  00078	e5943014	 ldr         r3, [r4, #0x14]
  0007c	e3530000	 cmp         r3, #0

; 1105 :         {
; 1106 :             c->pRegs->TXGCR =
; 1107 :           /*BIT31 | */ /* Enable */
; 1108 :           /*BIT30 | */ /* Tear-down */ /*
; 1109 :             qmgr |
; 1110 :             qnum */ USB_CPPI_TDCMPL_QNUM;

  00080	1594300c	 ldrne       r3, [r4, #0xC]
  00084	13a02044	 movne       r2, #0x44
  00088	15832000	 strne       r2, [r3]

; 1121 :         }
; 1122 :     }
; 1123 : }

  0008c	18bd4010	 ldmneia     sp!, {r4, lr}
  00090	112fff1e	 bxne        lr

; 1111 :         }
; 1112 :         else
; 1113 :         {
; 1114 :             c->pRegs->RXGCR =
; 1115 :           /*BIT31 | */ /* Enable */
; 1116 :           /*BIT30 | */ /* Tear-down */
; 1117 :             BIT24 |    /* Retry on starvation */
; 1118 :             BIT14 |    /* Host descriptor type (default) */ /*
; 1119 :             qmgr |
; 1120 :             qnum */ USB_CPPI_TDCMPL_QNUM;

  00094	e594200c	 ldr         r2, [r4, #0xC]
  00098	e59f3008	 ldr         r3, [pc, #8]
  0009c	e5823008	 str         r3, [r2, #8]
  000a0		 |$LN1@cppiChanne@2|

; 1121 :         }
; 1122 :     }
; 1123 : }

  000a0	e8bd4010	 ldmia       sp!, {r4, lr}
  000a4	e12fff1e	 bx          lr
  000a8		 |$LN15@cppiChanne@2|
  000a8		 |$LN16@cppiChanne@2|
  000a8	01004044	 DCD         0x1004044
  000ac		 |$LN17@cppiChanne@2|
  000ac	00000000	 DCD         |??_C@_1FO@NAGFODI@?$AAc?$AAp?$AAp?$AAi?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?3?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?9?$AA?5?$AAT?$AAe?$AAa?$AAr@|
  000b0		 |$LN18@cppiChanne@2|
  000b0	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  000b4		 |$LN19@cppiChanne@2|
  000b4	00000000	 DCD         |??_C@_1JM@MEFHOMOC@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  000b8		 |$LN20@cppiChanne@2|
  000b8	00000000	 DCD         |??_C@_1FE@MBMJCKKK@?$AAc?$AAp?$AAp?$AAi?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?3?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAA?$AAr?$AAg?$AAu@|
  000bc		 |$M47611|

			 ENDP  ; |cppiChannelRelease|

	EXPORT	|??_C@_1GC@IDPIMKKM@?$AAc?$AAp?$AAp?$AAi?$AAR?$AAn?$AAd?$AAi?$AAs?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AA?3?$AA?5?$AAU?$AAn?$AAe?$AAx?$AAp?$AAe?$AAc?$AAt?$AAe?$AAd?$AA?5?$AAc?$AAh?$AAa?$AAn@| [ DATA ] ; `string'
	IMPORT	|__rt_udiv|

  00000			 AREA	 |.pdata|, PDATA
|$T47652| DCD	|$LN48@cppiRndisU|
	DCD	0x40006601

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GC@IDPIMKKM@?$AAc?$AAp?$AAp?$AAi?$AAR?$AAn?$AAd?$AAi?$AAs?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AA?3?$AA?5?$AAU?$AAn?$AAe?$AAx?$AAp?$AAe?$AAc?$AAt?$AAe?$AAd?$AA?5?$AAc?$AAh?$AAa?$AAn@| DCB "c"
	DCB	0x0, "p", 0x0, "p", 0x0, "i", 0x0, "R", 0x0, "n", 0x0, "d"
	DCB	0x0, "i", 0x0, "s", 0x0, "U", 0x0, "p", 0x0, "d", 0x0, "a"
	DCB	0x0, "t", 0x0, "e", 0x0, ":", 0x0, " ", 0x0, "U", 0x0, "n"
	DCB	0x0, "e", 0x0, "x", 0x0, "p", 0x0, "e", 0x0, "c", 0x0, "t"
	DCB	0x0, "e", 0x0, "d", 0x0, " ", 0x0, "c", 0x0, "h", 0x0, "a"
	DCB	0x0, "n", 0x0, "n", 0x0, "e", 0x0, "l", 0x0, " ", 0x0, "n"
	DCB	0x0, "u", 0x0, "m", 0x0, "b", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, "!", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiRndisUpdate| PROC

; 1284 : {

  00000		 |$LN48@cppiRndisU|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M47649|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 1285 :     volatile UINT32* pRndisReg	 = NULL;
; 1286 : 	UINT32  rndisRegVal			 = 0;
; 1287 :     UINT32 mode					 = 0;
; 1288 : 
; 1289 :     /* we may need to change the rndis flag for this cppi channel */
; 1290 :     if (channel->lastModeRndis != isRndis)

  0000c	e5d5301a	 ldrb        r3, [r5, #0x1A]
  00010	e1530002	 cmp         r3, r2
  00014	0a00000e	 beq         |$LN26@cppiRndisU|

; 1291 :     {
; 1292 :         /* Mode
; 1293 :         00: Transparent
; 1294 :         01: RNDIS
; 1295 :         10: CDC
; 1296 :         11: Generic RNDIS
; 1297 :         */
; 1298 :         if (channel->transmit)

  00018	e5953014	 ldr         r3, [r5, #0x14]

; 1299 :         {
; 1300 : 			pRndisReg = &pRegBase->TXMODE;
; 1301 :         }
; 1302 :         else
; 1303 :         {
; 1304 : 			pRndisReg = &pRegBase->RXMODE;
; 1305 :         }
; 1306 : 
; 1307 : 		rndisRegVal = *pRndisReg;
; 1308 :         mode = 0x3 << (channel->channelNo * 2);

  0001c	e3a0e003	 mov         lr, #3
  00020	e3530000	 cmp         r3, #0
  00024	e5d53018	 ldrb        r3, [r5, #0x18]
  00028	12841070	 addne       r1, r4, #0x70
  0002c	02841074	 addeq       r1, r4, #0x74
  00030	e5910000	 ldr         r0, [r1]
  00034	e1a03083	 mov         r3, r3, lsl #1

; 1309 : 
; 1310 :         if (isRndis > 0)

  00038	e3520000	 cmp         r2, #0

; 1311 : 		{
; 1312 :             rndisRegVal |= mode;

  0003c	c180031e	 orrgt       r0, r0, lr, lsl r3

; 1313 : 		}
; 1314 :         else
; 1315 : 		{
; 1316 :             rndisRegVal &= ~mode;

  00040	d1c0031e	 bicle       r0, r0, lr, lsl r3

; 1317 : 		}
; 1318 : 
; 1319 :         if (*pRndisReg != rndisRegVal)

  00044	e5913000	 ldr         r3, [r1]
  00048	e1530000	 cmp         r3, r0

; 1320 :         {
; 1321 :             PRINTMSG(ZONE_PDD_DMA,(L"cppiRndisUpdate: writing mode register %x\r\n", rndisRegVal));
; 1322 :             *pRndisReg = rndisRegVal;

  0004c	15810000	 strne       r0, [r1]

; 1323 :         }
; 1324 : 
; 1325 :         channel->lastModeRndis = (UINT8)isRndis;

  00050	e5c5201a	 strb        r2, [r5, #0x1A]
  00054		 |$LN26@cppiRndisU|

; 1326 :     }
; 1327 : 
; 1328 :     // The generic RNDIS size register is only used for receive channels
; 1329 :     if (isRndis && !channel->transmit)

  00054	e3520000	 cmp         r2, #0
  00058	0a000049	 beq         |$LN17@cppiRndisU|
  0005c	e5953014	 ldr         r3, [r5, #0x14]
  00060	e3530000	 cmp         r3, #0
  00064	1a000046	 bne         |$LN17@cppiRndisU|

; 1330 :     {
; 1331 :         // Round transfer size up to multiple of EP size
; 1332 :         UINT32 rndisSize = ((channel->transferSize + channel->pktSize - 1) / channel->pktSize) * channel->pktSize;

  00068	e5956028	 ldr         r6, [r5, #0x28]
  0006c	e5953024	 ldr         r3, [r5, #0x24]
  00070	e1a00006	 mov         r0, r6
  00074	e0833006	 add         r3, r3, r6
  00078	e2431001	 sub         r1, r3, #1
  0007c	eb000000	 bl          __rt_udiv

; 1333 :         if (rndisSize == 0)
; 1334 : 		{
; 1335 :             rndisSize = channel->pktSize;
; 1336 : 		}
; 1337 : 
; 1338 :         /* Set the Generic RNDIS EP reg */
; 1339 :         switch (channel->channelNo)

  00080	e5d51018	 ldrb        r1, [r5, #0x18]
  00084	e0120690	 muls        r2, r0, r6
  00088	01a02006	 moveq       r2, r6
  0008c	e351000e	 cmp         r1, #0xE
  00090	8a000033	 bhi         |$LN1@cppiRndisU|
  00094	e28f3004	 add         r3, pc, #4
  00098	e7d33001	 ldrb        r3, [r3, +r1]
  0009c	e08ff003	 add         pc, pc, r3
  000a0		 |$LN30@cppiRndisU|
  000a0		 |$LN29@cppiRndisU|
  000a0		 |$LN31@cppiRndisU|
  000a0	0ced		 DCB         0xc
  000a1		 |$LN32@cppiRndisU|
  000a1	18ed		 DCB         0x18
  000a2		 |$LN33@cppiRndisU|
  000a2	24ed		 DCB         0x24
  000a3		 |$LN34@cppiRndisU|
  000a3	30ed		 DCB         0x30
  000a4		 |$LN35@cppiRndisU|
  000a4	3ced		 DCB         0x3c
  000a5		 |$LN36@cppiRndisU|
  000a5	48ed		 DCB         0x48
  000a6		 |$LN37@cppiRndisU|
  000a6	54ed		 DCB         0x54
  000a7		 |$LN38@cppiRndisU|
  000a7	60ed		 DCB         0x60
  000a8		 |$LN39@cppiRndisU|
  000a8	6ced		 DCB         0x6c
  000a9		 |$LN40@cppiRndisU|
  000a9	78ed		 DCB         0x78
  000aa		 |$LN41@cppiRndisU|
  000aa	84ed		 DCB         0x84
  000ab		 |$LN42@cppiRndisU|
  000ab	90ed		 DCB         0x90
  000ac		 |$LN43@cppiRndisU|
  000ac	9ced		 DCB         0x9c
  000ad		 |$LN44@cppiRndisU|
  000ad	a8ed		 DCB         0xa8
  000ae		 |$LN45@cppiRndisU|
  000ae	b4ed		 DCB         0xb4
  000af		 |$LN53@cppiRndisU|

; 1359 :             break;
; 1360 :         }
; 1361 :     }
; 1362 : 
; 1363 :     PRINTMSG (FALSE,
; 1364 :               (L"cppiRndisUpdate: Ch %u MODE RegVal 0x%08x\n",
; 1365 :                channel->channelNo, *pRndisReg));
; 1366 :     return;
; 1367 : }

  000af	b4ed		 DCB         0xb4
  000b0		 |$LN16@cppiRndisU|

; 1340 :         {
; 1341 :         case 0  : pRegBase->GENRNDISSZ1  = rndisSize; break;

  000b0	e5842080	 str         r2, [r4, #0x80]

; 1359 :             break;
; 1360 :         }
; 1361 :     }
; 1362 : 
; 1363 :     PRINTMSG (FALSE,
; 1364 :               (L"cppiRndisUpdate: Ch %u MODE RegVal 0x%08x\n",
; 1365 :                channel->channelNo, *pRndisReg));
; 1366 :     return;
; 1367 : }

  000b4	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000b8	e12fff1e	 bx          lr
  000bc		 |$LN15@cppiRndisU|

; 1342 :         case 1  : pRegBase->GENRNDISSZ2  = rndisSize; break;

  000bc	e5842084	 str         r2, [r4, #0x84]

; 1359 :             break;
; 1360 :         }
; 1361 :     }
; 1362 : 
; 1363 :     PRINTMSG (FALSE,
; 1364 :               (L"cppiRndisUpdate: Ch %u MODE RegVal 0x%08x\n",
; 1365 :                channel->channelNo, *pRndisReg));
; 1366 :     return;
; 1367 : }

  000c0	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000c4	e12fff1e	 bx          lr
  000c8		 |$LN14@cppiRndisU|

; 1343 :         case 2  : pRegBase->GENRNDISSZ3  = rndisSize; break;

  000c8	e5842088	 str         r2, [r4, #0x88]

; 1359 :             break;
; 1360 :         }
; 1361 :     }
; 1362 : 
; 1363 :     PRINTMSG (FALSE,
; 1364 :               (L"cppiRndisUpdate: Ch %u MODE RegVal 0x%08x\n",
; 1365 :                channel->channelNo, *pRndisReg));
; 1366 :     return;
; 1367 : }

  000cc	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000d0	e12fff1e	 bx          lr
  000d4		 |$LN13@cppiRndisU|

; 1344 :         case 3  : pRegBase->GENRNDISSZ4  = rndisSize; break;

  000d4	e584208c	 str         r2, [r4, #0x8C]

; 1359 :             break;
; 1360 :         }
; 1361 :     }
; 1362 : 
; 1363 :     PRINTMSG (FALSE,
; 1364 :               (L"cppiRndisUpdate: Ch %u MODE RegVal 0x%08x\n",
; 1365 :                channel->channelNo, *pRndisReg));
; 1366 :     return;
; 1367 : }

  000d8	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000dc	e12fff1e	 bx          lr
  000e0		 |$LN12@cppiRndisU|

; 1345 :         case 4  : pRegBase->GENRNDISSZ5  = rndisSize; break;

  000e0	e5842090	 str         r2, [r4, #0x90]

; 1359 :             break;
; 1360 :         }
; 1361 :     }
; 1362 : 
; 1363 :     PRINTMSG (FALSE,
; 1364 :               (L"cppiRndisUpdate: Ch %u MODE RegVal 0x%08x\n",
; 1365 :                channel->channelNo, *pRndisReg));
; 1366 :     return;
; 1367 : }

  000e4	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000e8	e12fff1e	 bx          lr
  000ec		 |$LN11@cppiRndisU|

; 1346 :         case 5  : pRegBase->GENRNDISSZ6  = rndisSize; break;

  000ec	e5842094	 str         r2, [r4, #0x94]

; 1359 :             break;
; 1360 :         }
; 1361 :     }
; 1362 : 
; 1363 :     PRINTMSG (FALSE,
; 1364 :               (L"cppiRndisUpdate: Ch %u MODE RegVal 0x%08x\n",
; 1365 :                channel->channelNo, *pRndisReg));
; 1366 :     return;
; 1367 : }

  000f0	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000f4	e12fff1e	 bx          lr
  000f8		 |$LN10@cppiRndisU|

; 1347 :         case 6  : pRegBase->GENRNDISSZ7  = rndisSize; break;

  000f8	e5842098	 str         r2, [r4, #0x98]

; 1359 :             break;
; 1360 :         }
; 1361 :     }
; 1362 : 
; 1363 :     PRINTMSG (FALSE,
; 1364 :               (L"cppiRndisUpdate: Ch %u MODE RegVal 0x%08x\n",
; 1365 :                channel->channelNo, *pRndisReg));
; 1366 :     return;
; 1367 : }

  000fc	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00100	e12fff1e	 bx          lr
  00104		 |$LN9@cppiRndisU|

; 1348 :         case 7  : pRegBase->GENRNDISSZ8  = rndisSize; break;

  00104	e584209c	 str         r2, [r4, #0x9C]

; 1359 :             break;
; 1360 :         }
; 1361 :     }
; 1362 : 
; 1363 :     PRINTMSG (FALSE,
; 1364 :               (L"cppiRndisUpdate: Ch %u MODE RegVal 0x%08x\n",
; 1365 :                channel->channelNo, *pRndisReg));
; 1366 :     return;
; 1367 : }

  00108	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0010c	e12fff1e	 bx          lr
  00110		 |$LN8@cppiRndisU|

; 1349 :         case 8  : pRegBase->GENRNDISSZ9  = rndisSize; break;

  00110	e58420a0	 str         r2, [r4, #0xA0]

; 1359 :             break;
; 1360 :         }
; 1361 :     }
; 1362 : 
; 1363 :     PRINTMSG (FALSE,
; 1364 :               (L"cppiRndisUpdate: Ch %u MODE RegVal 0x%08x\n",
; 1365 :                channel->channelNo, *pRndisReg));
; 1366 :     return;
; 1367 : }

  00114	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00118	e12fff1e	 bx          lr
  0011c		 |$LN7@cppiRndisU|

; 1350 :         case 9  : pRegBase->GENRNDISSZ10 = rndisSize; break;

  0011c	e58420a4	 str         r2, [r4, #0xA4]

; 1359 :             break;
; 1360 :         }
; 1361 :     }
; 1362 : 
; 1363 :     PRINTMSG (FALSE,
; 1364 :               (L"cppiRndisUpdate: Ch %u MODE RegVal 0x%08x\n",
; 1365 :                channel->channelNo, *pRndisReg));
; 1366 :     return;
; 1367 : }

  00120	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00124	e12fff1e	 bx          lr
  00128		 |$LN6@cppiRndisU|

; 1351 :         case 10 : pRegBase->GENRNDISSZ11 = rndisSize; break;

  00128	e58420a8	 str         r2, [r4, #0xA8]

; 1359 :             break;
; 1360 :         }
; 1361 :     }
; 1362 : 
; 1363 :     PRINTMSG (FALSE,
; 1364 :               (L"cppiRndisUpdate: Ch %u MODE RegVal 0x%08x\n",
; 1365 :                channel->channelNo, *pRndisReg));
; 1366 :     return;
; 1367 : }

  0012c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00130	e12fff1e	 bx          lr
  00134		 |$LN5@cppiRndisU|

; 1352 :         case 11 : pRegBase->GENRNDISSZ12 = rndisSize; break;

  00134	e58420ac	 str         r2, [r4, #0xAC]

; 1359 :             break;
; 1360 :         }
; 1361 :     }
; 1362 : 
; 1363 :     PRINTMSG (FALSE,
; 1364 :               (L"cppiRndisUpdate: Ch %u MODE RegVal 0x%08x\n",
; 1365 :                channel->channelNo, *pRndisReg));
; 1366 :     return;
; 1367 : }

  00138	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0013c	e12fff1e	 bx          lr
  00140		 |$LN4@cppiRndisU|

; 1353 :         case 12 : pRegBase->GENRNDISSZ13 = rndisSize; break;

  00140	e58420b0	 str         r2, [r4, #0xB0]

; 1359 :             break;
; 1360 :         }
; 1361 :     }
; 1362 : 
; 1363 :     PRINTMSG (FALSE,
; 1364 :               (L"cppiRndisUpdate: Ch %u MODE RegVal 0x%08x\n",
; 1365 :                channel->channelNo, *pRndisReg));
; 1366 :     return;
; 1367 : }

  00144	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00148	e12fff1e	 bx          lr
  0014c		 |$LN3@cppiRndisU|

; 1354 :         case 13 : pRegBase->GENRNDISSZ14 = rndisSize; break;

  0014c	e58420b4	 str         r2, [r4, #0xB4]

; 1359 :             break;
; 1360 :         }
; 1361 :     }
; 1362 : 
; 1363 :     PRINTMSG (FALSE,
; 1364 :               (L"cppiRndisUpdate: Ch %u MODE RegVal 0x%08x\n",
; 1365 :                channel->channelNo, *pRndisReg));
; 1366 :     return;
; 1367 : }

  00150	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00154	e12fff1e	 bx          lr
  00158		 |$LN2@cppiRndisU|

; 1355 :         case 14 : pRegBase->GENRNDISSZ15 = rndisSize; break;

  00158	e58420b8	 str         r2, [r4, #0xB8]

; 1359 :             break;
; 1360 :         }
; 1361 :     }
; 1362 : 
; 1363 :     PRINTMSG (FALSE,
; 1364 :               (L"cppiRndisUpdate: Ch %u MODE RegVal 0x%08x\n",
; 1365 :                channel->channelNo, *pRndisReg));
; 1366 :     return;
; 1367 : }

  0015c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00160	e12fff1e	 bx          lr
  00164		 |$LN1@cppiRndisU|

; 1356 :         default:
; 1357 :             ERRORMSG(TRUE,
; 1358 :                      (L"cppiRndisUpdate: Unexpected channel number %d!\r\n", channel->channelNo));

  00164	e59f1028	 ldr         r1, [pc, #0x28]
  00168	e59f0020	 ldr         r0, [pc, #0x20]
  0016c	e3a03c05	 mov         r3, #5, 24
  00170	e383204e	 orr         r2, r3, #0x4E
  00174	eb000000	 bl          NKDbgPrintfW
  00178	e5d51018	 ldrb        r1, [r5, #0x18]
  0017c	e59f0008	 ldr         r0, [pc, #8]
  00180	eb000000	 bl          NKDbgPrintfW
  00184		 |$LN17@cppiRndisU|

; 1359 :             break;
; 1360 :         }
; 1361 :     }
; 1362 : 
; 1363 :     PRINTMSG (FALSE,
; 1364 :               (L"cppiRndisUpdate: Ch %u MODE RegVal 0x%08x\n",
; 1365 :                channel->channelNo, *pRndisReg));
; 1366 :     return;
; 1367 : }

  00184	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00188	e12fff1e	 bx          lr
  0018c		 |$LN49@cppiRndisU|
  0018c		 |$LN50@cppiRndisU|
  0018c	00000000	 DCD         |??_C@_1GC@IDPIMKKM@?$AAc?$AAp?$AAp?$AAi?$AAR?$AAn?$AAd?$AAi?$AAs?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AA?3?$AA?5?$AAU?$AAn?$AAe?$AAx?$AAp?$AAe?$AAc?$AAt?$AAe?$AAd?$AA?5?$AAc?$AAh?$AAa?$AAn@|
  00190		 |$LN51@cppiRndisU|
  00190	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  00194		 |$LN52@cppiRndisU|
  00194	00000000	 DCD         |??_C@_1JM@MEFHOMOC@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  00198		 |$M47650|

			 ENDP  ; |cppiRndisUpdate|

	IMPORT	|USBCDMA_ConfigureScheduleRx|

  00000			 AREA	 |.pdata|, PDATA
|$T47691| DCD	|$LN36@cppiNextSe|
	DCD	0x4000b502
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiNextSegment| PROC

; 1387 : {

  00000		 |$LN36@cppiNextSe|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M47688|
  00008	e1a06000	 mov         r6, r0
  0000c	e58d600c	 str         r6, [sp, #0xC]
  00010	e1a04001	 mov         r4, r1

; 1388 :     unsigned maxpacket =  chanPtr->pktSize;
; 1389 :     UINT32 remaining = chanPtr->transferSize - chanPtr->currOffset;

  00014	e5942024	 ldr         r2, [r4, #0x24]
  00018	e594302c	 ldr         r3, [r4, #0x2C]

; 1390 :     struct cppi *cppi = chanPtr->pController;
; 1391 :     HOST_DESCRIPTOR *hd = NULL;
; 1392 :     BOOL   isRndis = FALSE;
; 1393 :     UINT32 buffSz = 0;
; 1394 :     UINT32 buffPtr = 0;
; 1395 :     UINT32 nHD = 0;
; 1396 :     UINT32 i;
; 1397 :     UINT cppiCmplQNum;
; 1398 : 
; 1399 :     // For overlapped IO need to protect channel vars
; 1400 :     LOCK_ENDPOINT(pPdd);

  0001c	e5949028	 ldr         r9, [r4, #0x28]
  00020	e2860e27	 add         r0, r6, #0x27, 28
  00024	e0427003	 sub         r7, r2, r3
  00028	e5943008	 ldr         r3, [r4, #8]
  0002c	e58d3000	 str         r3, [sp]
  00030	eb000000	 bl          EnterCriticalSection

; 1401 : 
; 1402 :     if (chanPtr->pEndPt->endpointType != USB_ENDPOINT_TYPE_ISOCHRONOUS)

  00034	e5943010	 ldr         r3, [r4, #0x10]
  00038	e5d3300c	 ldrb        r3, [r3, #0xC]
  0003c	e3530001	 cmp         r3, #1
  00040	0a000004	 beq         |$LN17@cppiNextSe|

; 1403 :     {
; 1404 :         isRndis = (
; 1405 :             ((maxpacket & 0x3f) == 0) &&
; 1406 :             (remaining <= 0x00010000));

  00044	e319003f	 tst         r9, #0x3F
  00048	1a000002	 bne         |$LN17@cppiNextSe|
  0004c	e3570801	 cmp         r7, #1, 16
  00050	93a02001	 movls       r2, #1
  00054	9a000000	 bls         |$LN16@cppiNextSe|
  00058		 |$LN17@cppiNextSe|

; 1407 :     }
; 1408 :     else
; 1409 :     {
; 1410 :         // Transparent mode for ISO
; 1411 :         isRndis = FALSE;

  00058	e3a02000	 mov         r2, #0
  0005c		 |$LN16@cppiNextSe|

; 1412 :     }
; 1413 : 
; 1414 :     // The registry setting 'DisableRxGenRNDIS' should force transparent mode for RX transfers
; 1415 :     if ((!chanPtr->transmit) && (pPdd->disableRxGenRNDIS))

  0005c	e5943014	 ldr         r3, [r4, #0x14]
  00060	e3530000	 cmp         r3, #0
  00064	1a000002	 bne         |$LN15@cppiNextSe|
  00068	e5963664	 ldr         r3, [r6, #0x664]
  0006c	e3530000	 cmp         r3, #0

; 1416 : 	{
; 1417 :         isRndis = FALSE;

  00070	13a02000	 movne       r2, #0
  00074		 |$LN15@cppiNextSe|

; 1418 : 	}
; 1419 : 
; 1420 :     if (isRndis)

  00074	e3520000	 cmp         r2, #0

; 1421 : 	{
; 1422 :         buffSz = remaining;
; 1423 : 	}
; 1424 :     else

  00078	1a000001	 bne         |$LN33@cppiNextSe|

; 1425 : 	{
; 1426 :         buffSz  = min(remaining, maxpacket);

  0007c	e1570009	 cmp         r7, r9
  00080	2a000001	 bcs         |$LN22@cppiNextSe|
  00084		 |$LN33@cppiNextSe|
  00084	e1a05007	 mov         r5, r7
  00088	ea000000	 b           |$LN23@cppiNextSe|
  0008c		 |$LN22@cppiNextSe|
  0008c	e1a05009	 mov         r5, r9
  00090		 |$LN23@cppiNextSe|

; 1427 : 	}
; 1428 : 
; 1429 :     buffPtr = chanPtr->startAddr + chanPtr->currOffset;

  00090	e594002c	 ldr         r0, [r4, #0x2C]
  00094	e5943020	 ldr         r3, [r4, #0x20]

; 1430 : 
; 1431 :     cppiRndisUpdate(chanPtr, pPdd->pUsbdRegs, isRndis);

  00098	e596101c	 ldr         r1, [r6, #0x1C]
  0009c	e080a003	 add         r10, r0, r3
  000a0	e1a00004	 mov         r0, r4
  000a4	e58da004	 str         r10, [sp, #4]
  000a8	eb000000	 bl          cppiRndisUpdate

; 1432 : 
; 1433 :     PRINTMSG(ZONE_PDD_DMA && (chanPtr->transmit ? ZONE_PDD_TX : ZONE_PDD_RX),
; 1434 :              (L"cppiNextSegment: %s Ch %u, segLen %u, addr 0x%08x, lenDone %u, totalLen %u\r\n",
; 1435 :               chanPtr->transmit ? L"TX" : L"RX", chanPtr->channelNo, buffSz, buffPtr, chanPtr->actualLen, chanPtr->transferSize));
; 1436 : 
; 1437 :     // Determine completion queue based on direction
; 1438 :     if (chanPtr->transmit)

  000ac	e5943014	 ldr         r3, [r4, #0x14]

; 1439 : 	{
; 1440 :         cppiCmplQNum = USB_CPPI_TXCMPL_QNUM_FN;
; 1441 : 	}
; 1442 :     else
; 1443 : 	{
; 1444 :         cppiCmplQNum = USB_CPPI_RXCMPL_QNUM_FN;
; 1445 : 	}
; 1446 : 
; 1447 :     if (chanPtr->pEndPt->endpointType != USB_ENDPOINT_TYPE_ISOCHRONOUS)

  000b0	e594b010	 ldr         r11, [r4, #0x10]
  000b4	e3530000	 cmp         r3, #0
  000b8	e5db300c	 ldrb        r3, [r11, #0xC]
  000bc	13a08040	 movne       r8, #0x40
  000c0	03a08042	 moveq       r8, #0x42
  000c4	e3530001	 cmp         r3, #1
  000c8	0a00002f	 beq         |$LN10@cppiNextSe|

; 1448 :     {
; 1449 :         hd = cppiHdAlloc(cppi);

  000cc	e59db000	 ldr         r11, [sp]
  000d0	e1a0000b	 mov         r0, r11
  000d4	eb000000	 bl          cppiHdAlloc
  000d8	e1b0e000	 movs        lr, r0

; 1450 :         DEBUGCHK(hd != NULL);
; 1451 :         if (hd == NULL)

  000dc	0a000079	 beq         |$LN18@cppiNextSe|
  000e0	e3a03481	 mov         r3, #0x81, 8

; 1452 : 		{
; 1453 :             return;
; 1454 : 		}
; 1455 : 
; 1456 :         // Initialise the descriptor
; 1457 :         hd->DescInfo    = (USB_CPPI41_DESC_TYPE_HOST   << USB_CPPI41_DESC_TYPE_SHIFT) |
; 1458 :                           (((sizeof(*hd) - 40) / 4)    << USB_CPPI41_DESC_WORDS_SHIFT) |
; 1459 :                           buffSz;

  000e4	e3833502	 orr         r3, r3, #2, 10
  000e8	e1851003	 orr         r1, r5, r3

; 1460 :         hd->TagInfo     = 0;
; 1461 :         hd->PacketInfo  = (USB_CPPI41_PKT_TYPE_USB     << USB_CPPI41_PKT_TYPE_SHIFT) |
; 1462 :                           (USB_CPPI41_PKT_RETPLCY_FULL << USB_CPPI41_PKT_RETPLCY_SHIFT) |
; 1463 :                           (USB_CPPI41_DESC_LOC_OFFCHIP << USB_CPPI41_DESC_LOC_SHIFT) |
; 1464 :                           (USB_CPPI_XXCMPL_QMGR        << USB_CPPI41_PKT_RETQMGR_SHIFT) |
; 1465 :                           (cppiCmplQNum                << USB_CPPI41_PKT_RETQ_SHIFT);

  000ec	e3880305	 orr         r0, r8, #5, 6
  000f0	e3a06000	 mov         r6, #0
  000f4	e88e0042	 stmia       lr, {r1, r6}
  000f8	e58e0008	 str         r0, [lr, #8]

; 1466 :         hd->BuffLen     = buffSz;

  000fc	e58e500c	 str         r5, [lr, #0xC]

; 1467 :         hd->BuffPtr     = buffPtr;

  00100	e58ea010	 str         r10, [lr, #0x10]

; 1468 :         hd->NextPtr     = 0;

  00104	e58e6014	 str         r6, [lr, #0x14]

; 1469 :         hd->OrigBuffLen = hd->BuffLen;

  00108	e58e5018	 str         r5, [lr, #0x18]

; 1470 :         hd->OrigBuffPtr = hd->BuffPtr;

  0010c	e58ea01c	 str         r10, [lr, #0x1C]

; 1471 :         hd->SWData[0]   = 0;

  00110	e58e6020	 str         r6, [lr, #0x20]

; 1472 :         hd->SWData[1]   = 0;

  00114	e58e6024	 str         r6, [lr, #0x24]

; 1473 :         hd->TagInfo2    = (/* isTx */ (chanPtr->transmit ? 1 : 0) << 9) |
; 1474 :                           (/* Ch */ chanPtr->channelNo << 4) |
; 1475 :                           (/* EP */ chanPtr->channelNo + 1);

  00118	e5943014	 ldr         r3, [r4, #0x14]
  0011c	e3530000	 cmp         r3, #0
  00120	e5d43018	 ldrb        r3, [r4, #0x18]
  00124	13a02001	 movne       r2, #1
  00128	03a02000	 moveq       r2, #0

; 1476 :         hd->Index       = 0;

  0012c	e1832282	 orr         r2, r3, r2, lsl #5
  00130	e2833001	 add         r3, r3, #1
  00134	e1833202	 orr         r3, r3, r2, lsl #4
  00138	e58e3030	 str         r3, [lr, #0x30]
  0013c	e58e6034	 str         r6, [lr, #0x34]

; 1477 : 
; 1478 :          // Special handling for ZLP TX - set length to 1 and set ZLP bit
; 1479 :         if (chanPtr->transmit && buffSz == 0)

  00140	e5943014	 ldr         r3, [r4, #0x14]
  00144	e3530000	 cmp         r3, #0
  00148	0a000007	 beq         |$LN8@cppiNextSe|
  0014c	e3550000	 cmp         r5, #0

; 1480 :         {
; 1481 :             hd->PacketInfo |= USB_CPPI41_PKT_FLAGS_ZLP;

  00150	03803702	 orreq       r3, r0, #2, 14

; 1482 :             hd->DescInfo |= 1;

  00154	058e3008	 streq       r3, [lr, #8]

; 1483 :             hd->BuffLen = 1;

  00158	03a03001	 moveq       r3, #1
  0015c	03812001	 orreq       r2, r1, #1
  00160	058e300c	 streq       r3, [lr, #0xC]

; 1484 :             hd->OrigBuffLen = 1;

  00164	058e3018	 streq       r3, [lr, #0x18]
  00168	058e2000	 streq       r2, [lr]
  0016c		 |$LN8@cppiNextSe|

; 1485 :         }
; 1486 : 
; 1487 :         /* Write the pointer to the packet descriptor to the appropriate Queue
; 1488 :            in the Queue Manager to initiate the transfer
; 1489 :         */
; 1490 :         cppiQueuePush(cppi->pRegs, chanPtr->queueNo, hd);

  0016c	e5d41019	 ldrb        r1, [r4, #0x19]
  00170	e59b001c	 ldr         r0, [r11, #0x1C]
  00174	e1a0200e	 mov         r2, lr
  00178	eb000000	 bl          cppiQueuePush

; 1491 : 
; 1492 :         chanPtr->currOffset += buffSz;

  0017c	e594302c	 ldr         r3, [r4, #0x2C]
  00180	e0833005	 add         r3, r3, r5
  00184	e584302c	 str         r3, [r4, #0x2C]

; 1493 :     }
; 1494 :     else

  00188	ea000046	 b           |$LN3@cppiNextSe|
  0018c		 |$LN10@cppiNextSe|

; 1495 :     {
; 1496 :         nHD = (remaining + chanPtr->pktSize - 1) / chanPtr->pktSize;

  0018c	e594a028	 ldr         r10, [r4, #0x28]
  00190	e08a3007	 add         r3, r10, r7
  00194	e2431001	 sub         r1, r3, #1
  00198	e1a0000a	 mov         r0, r10
  0019c	eb000000	 bl          __rt_udiv
  001a0	e1a06000	 mov         r6, r0

; 1497 :         chanPtr->nISOHDPerTransfer = nHD;

  001a4	e5846034	 str         r6, [r4, #0x34]

; 1498 :         chanPtr->nISOHDForCallback = nHD;

  001a8	e5846038	 str         r6, [r4, #0x38]

; 1499 : 
; 1500 :         if (chanPtr->pEndPt->pOverlappedInfo)

  001ac	e59b3038	 ldr         r3, [r11, #0x38]
  001b0	e3530000	 cmp         r3, #0
  001b4	0a000005	 beq         |$LN6@cppiNextSe|

; 1501 :         {
; 1502 :             nHD = (chanPtr->pEndPt->pOverlappedInfo->dwBytesToIssueCallback + chanPtr->pktSize - 1) /
; 1503 :                    chanPtr->pktSize;
; 1504 : 
; 1505 :             chanPtr->nISOHDForCallback = nHD;

  001b8	e5933000	 ldr         r3, [r3]
  001bc	e1a0000a	 mov         r0, r10
  001c0	e083300a	 add         r3, r3, r10
  001c4	e2431001	 sub         r1, r3, #1
  001c8	eb000000	 bl          __rt_udiv
  001cc	e5840038	 str         r0, [r4, #0x38]
  001d0		 |$LN6@cppiNextSe|

; 1506 :         }
; 1507 : 
; 1508 :         chanPtr->nISOHDQueued += chanPtr->nISOHDPerTransfer;

  001d0	e594303c	 ldr         r3, [r4, #0x3C]

; 1509 : 
; 1510 :         PRINTMSG(ZONE_PDD_ISO,
; 1511 :                  (L"cppiNextSegment: %s Ch %u, ISO, transferSize %d, pktSize %d, %d HDs, "
; 1512 :                   L"callback on %d, queued %d\r\n",
; 1513 :                   chanPtr->transmit ? L"TX" : L"RX",
; 1514 : 				  chanPtr->channelNo, chanPtr->transferSize, chanPtr->pktSize,
; 1515 :                   chanPtr->nISOHDPerTransfer, chanPtr->nISOHDForCallback,
; 1516 :                   chanPtr->nISOHDQueued));
; 1517 : 
; 1518 :         for (i = 1; i <= chanPtr->nISOHDPerTransfer; ++i)

  001d4	e3a0a001	 mov         r10, #1
  001d8	e3560001	 cmp         r6, #1
  001dc	e0833006	 add         r3, r3, r6
  001e0	e584303c	 str         r3, [r4, #0x3C]
  001e4	3a00002f	 bcc         |$LN3@cppiNextSe|
  001e8	e3883305	 orr         r3, r8, #5, 6
  001ec	e59d8004	 ldr         r8, [sp, #4]
  001f0	e59db000	 ldr         r11, [sp]
  001f4	e58d3008	 str         r3, [sp, #8]
  001f8	e3a06000	 mov         r6, #0
  001fc		 |$LL5@cppiNextSe|

; 1519 :         {
; 1520 :             hd = cppiHdAlloc(cppi);

  001fc	e1a0000b	 mov         r0, r11
  00200	eb000000	 bl          cppiHdAlloc
  00204	e3500000	 cmp         r0, #0

; 1521 :             DEBUGCHK(hd != NULL);
; 1522 :             if (hd == NULL)

  00208	0a00002e	 beq         |$LN18@cppiNextSe|

; 1523 : 			{
; 1524 :                 return;
; 1525 : 			}
; 1526 : 
; 1527 :             // Initialise the descriptor
; 1528 :             hd->DescInfo    = (USB_CPPI41_DESC_TYPE_HOST   << USB_CPPI41_DESC_TYPE_SHIFT) |
; 1529 :                               (((sizeof(*hd) - 40) / 4)    << USB_CPPI41_DESC_WORDS_SHIFT) |
; 1530 :                               buffSz;

  0020c	e3a02481	 mov         r2, #0x81, 8
  00210	e3823502	 orr         r3, r2, #2, 10
  00214	e1853003	 orr         r3, r5, r3
  00218	e8800048	 stmia       r0, {r3, r6}

; 1531 :             hd->TagInfo     = 0;
; 1532 :             hd->PacketInfo  = (USB_CPPI41_PKT_TYPE_USB     << USB_CPPI41_PKT_TYPE_SHIFT) |
; 1533 :                               (USB_CPPI41_PKT_RETPLCY_FULL << USB_CPPI41_PKT_RETPLCY_SHIFT) |
; 1534 :                               (USB_CPPI41_DESC_LOC_OFFCHIP << USB_CPPI41_DESC_LOC_SHIFT) |
; 1535 :                               (USB_CPPI_XXCMPL_QMGR        << USB_CPPI41_PKT_RETQMGR_SHIFT) |
; 1536 :                               (cppiCmplQNum                << USB_CPPI41_PKT_RETQ_SHIFT);

  0021c	e59d3008	 ldr         r3, [sp, #8]

; 1537 :             hd->BuffLen     = buffSz;
; 1538 :             hd->BuffPtr     = buffPtr;
; 1539 :             hd->NextPtr     = 0;

  00220	e5806014	 str         r6, [r0, #0x14]

; 1540 :             hd->OrigBuffLen = hd->BuffLen;

  00224	e280c018	 add         r12, r0, #0x18
  00228	e88c0120	 stmia       r12, {r5, r8}
  0022c	e280c008	 add         r12, r0, #8
  00230	e88c0128	 stmia       r12, {r3, r5, r8}

; 1541 :             hd->OrigBuffPtr = hd->BuffPtr;
; 1542 :             hd->SWData[0]   = 0;
; 1543 :             hd->SWData[1]   = 0;
; 1544 :             hd->TagInfo2    = (/* isTx */ (chanPtr->transmit ? 1 : 0) << 9) |
; 1545 :                               (/* Ch */ chanPtr->channelNo << 4) |
; 1546 :                               (/* EP */ chanPtr->channelNo + 1);
; 1547 :             hd->Index       = i; // 1 based index
; 1548 : 
; 1549 :             /* Write the pointer to the packet descriptor to the appropriate Queue
; 1550 :                in the Queue Manager to initiate the transfer
; 1551 :             */
; 1552 :             cppiQueuePush(cppi->pRegs, chanPtr->queueNo, hd);

  00234	e1a02000	 mov         r2, r0
  00238	e5806020	 str         r6, [r0, #0x20]
  0023c	e5806024	 str         r6, [r0, #0x24]
  00240	e5943014	 ldr         r3, [r4, #0x14]
  00244	e3530000	 cmp         r3, #0
  00248	e5d43018	 ldrb        r3, [r4, #0x18]
  0024c	13a01001	 movne       r1, #1
  00250	03a01000	 moveq       r1, #0
  00254	e1831281	 orr         r1, r3, r1, lsl #5
  00258	e2833001	 add         r3, r3, #1
  0025c	e1833201	 orr         r3, r3, r1, lsl #4
  00260	e5803030	 str         r3, [r0, #0x30]
  00264	e580a034	 str         r10, [r0, #0x34]
  00268	e5d41019	 ldrb        r1, [r4, #0x19]
  0026c	e59b001c	 ldr         r0, [r11, #0x1C]
  00270	eb000000	 bl          cppiQueuePush

; 1553 : 
; 1554 :             chanPtr->currOffset += buffSz;

  00274	e594302c	 ldr         r3, [r4, #0x2C]

; 1555 :             buffPtr = chanPtr->startAddr + chanPtr->currOffset;

  00278	e5942020	 ldr         r2, [r4, #0x20]

; 1556 :             remaining -= buffSz;

  0027c	e0477005	 sub         r7, r7, r5
  00280	e0833005	 add         r3, r3, r5
  00284	e584302c	 str         r3, [r4, #0x2C]
  00288	e0838002	 add         r8, r3, r2
  0028c	e5943034	 ldr         r3, [r4, #0x34]

; 1557 :             buffSz  = min(remaining, maxpacket);

  00290	e1570009	 cmp         r7, r9
  00294	31a05007	 movcc       r5, r7
  00298	e28aa001	 add         r10, r10, #1
  0029c	21a05009	 movcs       r5, r9
  002a0	e15a0003	 cmp         r10, r3
  002a4	9affffd4	 bls         |$LL5@cppiNextSe|
  002a8		 |$LN3@cppiNextSe|

; 1558 :         }
; 1559 :     }
; 1560 : 
; 1561 :     /* If this is a receive, we need to enable Rx for this channel 
; 1562 :        in the DMA scheduler */
; 1563 :     if(!chanPtr->transmit)

  002a8	e5943014	 ldr         r3, [r4, #0x14]
  002ac	e3530000	 cmp         r3, #0

; 1564 : 	{
; 1565 :         USBCDMA_ConfigureScheduleRx(chanPtr->channelNo, TRUE);

  002b0	05d40018	 ldreqb      r0, [r4, #0x18]
  002b4	03a01001	 moveq       r1, #1
  002b8	0b000000	 bleq        USBCDMA_ConfigureScheduleRx

; 1566 : 	}
; 1567 : 
; 1568 :     UNLOCK_ENDPOINT(pPdd);

  002bc	e59d300c	 ldr         r3, [sp, #0xC]
  002c0	e2830e27	 add         r0, r3, #0x27, 28
  002c4	eb000000	 bl          LeaveCriticalSection
  002c8		 |$LN18@cppiNextSe|

; 1569 : }

  002c8	e28dd010	 add         sp, sp, #0x10
  002cc	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  002d0	e12fff1e	 bx          lr
  002d4		 |$M47689|

			 ENDP  ; |cppiNextSegment|

	EXPORT	|??_C@_1KA@OEINGMKN@?$AAc?$AAp?$AAp?$AAi?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAT?$AAe?$AAa?$AAr?$AAd?$AAo?$AAw?$AAn?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAC?$AAh?$AA?5?$AA?$CF?$AAu?$AA?5?$AA?$CI?$AAE@| [ DATA ] ; `string'
	IMPORT	|USBCDMA_KickCompletionCallback|
	IMPORT	|GetTickCount|
	IMPORT	|Sleep|

  00000			 AREA	 |.pdata|, PDATA
|$T47723| DCD	|$LN33@cppiChanne@3|
	DCD	0x40008401

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1KA@OEINGMKN@?$AAc?$AAp?$AAp?$AAi?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAT?$AAe?$AAa?$AAr?$AAd?$AAo?$AAw?$AAn?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAC?$AAh?$AA?5?$AA?$CF?$AAu?$AA?5?$AA?$CI?$AAE@| DCB "c"
	DCB	0x0, "p", 0x0, "p", 0x0, "i", 0x0, "C", 0x0, "h", 0x0, "a"
	DCB	0x0, "n", 0x0, "n", 0x0, "e", 0x0, "l", 0x0, "T", 0x0, "e"
	DCB	0x0, "a", 0x0, "r", 0x0, "d", 0x0, "o", 0x0, "w", 0x0, "n"
	DCB	0x0, ":", 0x0, " ", 0x0, "%", 0x0, "s", 0x0, " ", 0x0, "C"
	DCB	0x0, "h", 0x0, " ", 0x0, "%", 0x0, "u", 0x0, " ", 0x0, "("
	DCB	0x0, "E", 0x0, "P", 0x0, " ", 0x0, "%", 0x0, "u", 0x0, ")"
	DCB	0x0, " ", 0x0, "-", 0x0, " ", 0x0, "T", 0x0, "i", 0x0, "m"
	DCB	0x0, "e", 0x0, "d", 0x0, "-", 0x0, "o", 0x0, "u", 0x0, "t"
	DCB	0x0, " ", 0x0, "(", 0x0, "l", 0x0, "o", 0x0, "s", 0x0, "t"
	DCB	0x0, " ", 0x0, "t", 0x0, "e", 0x0, "a", 0x0, "r", 0x0, "d"
	DCB	0x0, "o", 0x0, "w", 0x0, "n", 0x0, " ", 0x0, "d", 0x0, "e"
	DCB	0x0, "s", 0x0, "c", 0x0, "r", 0x0, "i", 0x0, "p", 0x0, "t"
	DCB	0x0, "o", 0x0, "r", 0x0, ")", 0x0, "!", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiChannelTeardown| PROC

; 1576 : {

  00000		 |$LN33@cppiChanne@3|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M47720|
  00004	e1a04000	 mov         r4, r0

; 1577 :     struct cppi *cppi = channel->pController;

  00008	e5946008	 ldr         r6, [r4, #8]

; 1578 :     CSL_UsbRegs *pUsbRegs = cppi->pPdd->pUsbdRegs;
; 1579 : 
; 1580 :     BYTE   chanNum = channel->channelNo;

  0000c	e5d47018	 ldrb        r7, [r4, #0x18]

; 1581 :     BYTE   epNum   = chanNum + 1;
; 1582 :     DWORD  tc0     = 0;
; 1583 :     UINT16 csr     = 0;
; 1584 : 
; 1585 :     DEBUGMSG(ZONE_INIT || ZONE_PDD_DMA,
; 1586 :         (L"+cppiChannelTeardown: %s Ch %u (EP %u)\r\n",
; 1587 :         channel->transmit ? L"TX" : L"RX",
; 1588 :         chanNum,
; 1589 :         epNum));
; 1590 : 
; 1591 :     /* We need to cancel interrupt pacing to improve our chances of oustanding transfers being
; 1592 :        detected on their completion queue
; 1593 :     */
; 1594 :     channel->isTeardownPending = TRUE;
; 1595 : 
; 1596 :     if (channel->transmit)

  00010	e5941014	 ldr         r1, [r4, #0x14]
  00014	e5963018	 ldr         r3, [r6, #0x18]
  00018	e2872001	 add         r2, r7, #1
  0001c	e3510000	 cmp         r1, #0
  00020	e593501c	 ldr         r5, [r3, #0x1C]
  00024	e3a03001	 mov         r3, #1
  00028	e584301c	 str         r3, [r4, #0x1C]
  0002c	e20280ff	 and         r8, r2, #0xFF

; 1597 :     {
; 1598 :         /* 1. Initiate channel tear-down */
; 1599 :         channel->pRegs->TXGCR =
; 1600 :             BIT31 | /* Enable */
; 1601 :             BIT30 | /* Tear-down */ /*
; 1602 :             qmgr |
; 1603 :             qnum */ USB_CPPI_TDCMPL_QNUM;
; 1604 : 
; 1605 :         /* 2. Set USB controller TD bit */
; 1606 :         pUsbRegs->TEARDOWN |= ((1 << epNum) << USB_OTG_TXTD_SHIFT);

  00030	e3a01001	 mov         r1, #1
  00034	0a000028	 beq         |$LN14@cppiChanne@3|
  00038	e594200c	 ldr         r2, [r4, #0xC]
  0003c	e3a03103	 mov         r3, #3, 2
  00040	e3833044	 orr         r3, r3, #0x44
  00044	e5823000	 str         r3, [r2]
  00048	e595301c	 ldr         r3, [r5, #0x1C]
  0004c	e1a09811	 mov         r9, r1, lsl r8
  00050	e1833809	 orr         r3, r3, r9, lsl #16
  00054	e585301c	 str         r3, [r5, #0x1C]

; 1607 : 
; 1608 :         /* 3. Wait for CDMA completion and retry (due to TX disconnect issue) */
; 1609 :         if (channel->isTeardownPending)

  00058	e594301c	 ldr         r3, [r4, #0x1C]
  0005c	e3530000	 cmp         r3, #0

; 1610 : 		{
; 1611 :             Sleep(10);

  00060	13a0000a	 movne       r0, #0xA
  00064	1b000000	 blne        Sleep

; 1612 : 		}
; 1613 : 
; 1614 :         tc0 = GetTickCount();

  00068	eb000000	 bl          GetTickCount

; 1615 :         while ((channel->isTeardownPending) && ((GetTickCount() - tc0) < 2000)) {

  0006c	e1a0a000	 mov         r10, r0
  00070	ea00000a	 b           |$LN27@cppiChanne@3|
  00074		 |$LL12@cppiChanne@3|
  00074	eb000000	 bl          GetTickCount
  00078	e040300a	 sub         r3, r0, r10
  0007c	e3530e7d	 cmp         r3, #0x7D, 28
  00080	2a000009	 bcs         |$LN24@cppiChanne@3|

; 1616 :             pUsbRegs->TEARDOWN |= ((1 << epNum) << USB_OTG_TXTD_SHIFT);

  00084	e595301c	 ldr         r3, [r5, #0x1C]
  00088	e1833809	 orr         r3, r3, r9, lsl #16
  0008c	e585301c	 str         r3, [r5, #0x1C]

; 1617 :             USBCDMA_KickCompletionCallback(cppi->hUsbCdma);

  00090	e5960020	 ldr         r0, [r6, #0x20]
  00094	eb000000	 bl          USBCDMA_KickCompletionCallback

; 1618 :             Sleep(10);

  00098	e3a0000a	 mov         r0, #0xA
  0009c	eb000000	 bl          Sleep
  000a0		 |$LN27@cppiChanne@3|
  000a0	e594301c	 ldr         r3, [r4, #0x1C]
  000a4	e3530000	 cmp         r3, #0
  000a8	1afffff1	 bne         |$LL12@cppiChanne@3|
  000ac		 |$LN24@cppiChanne@3|

; 1619 :         }
; 1620 : 
; 1621 :         /* 4. Set USB controller TD bit */
; 1622 :         pUsbRegs->TEARDOWN |= ((1 << epNum) << USB_OTG_TXTD_SHIFT);

  000ac	e595201c	 ldr         r2, [r5, #0x1C]

; 1623 : 
; 1624 :         /* 5. Flush the EP's FIFO */
; 1625 :         csr = pUsbRegs->EPCSR[chanNum + 1].TXCSR;

  000b0	e0853207	 add         r3, r5, r7, lsl #4
  000b4	e2831c05	 add         r1, r3, #5, 24
  000b8	e1823809	 orr         r3, r2, r9, lsl #16
  000bc	e585301c	 str         r3, [r5, #0x1C]
  000c0	e1d121b2	 ldrh        r2, [r1, #0x12]
  000c4	e3a03cef	 mov         r3, #0xEF, 24

; 1626 :         csr &= ~MGC_M_TXCSR_DMAENAB;

  000c8	e38330f7	 orr         r3, r3, #0xF7
  000cc	e0023003	 and         r3, r2, r3

; 1627 :         csr |=  MGC_M_TXCSR_FLUSHFIFO;

  000d0	e3833008	 orr         r3, r3, #8

; 1628 :         pUsbRegs->EPCSR[chanNum + 1].TXCSR = csr;

  000d4	e1c131b2	 strh        r3, [r1, #0x12]

; 1629 :     }
; 1630 :     else

  000d8	ea000032	 b           |$LN10@cppiChanne@3|
  000dc		 |$LN14@cppiChanne@3|

; 1631 :     {
; 1632 :         /* 0. Enable Scheduler during teardown */
; 1633 :         USBCDMA_ConfigureScheduleRx(chanNum, TRUE);

  000dc	e1a00007	 mov         r0, r7
  000e0	eb000000	 bl          USBCDMA_ConfigureScheduleRx

; 1634 : 
; 1635 :         /* 1. Flush the EP's FIFO */
; 1636 :         csr = pUsbRegs->EPCSR[chanNum + 1].RXCSR;

  000e4	e0853207	 add         r3, r5, r7, lsl #4
  000e8	e283ac05	 add         r10, r3, #5, 24
  000ec	e1da31b6	 ldrh        r3, [r10, #0x16]

; 1637 :         csr |= (MGC_M_RXCSR_FLUSHFIFO | MGC_M_RXCSR_P_WZC_BITS);
; 1638 :         pUsbRegs->EPCSR[chanNum + 1].PERI_RXCSR = csr;
; 1639 : 
; 1640 :         /* 2. Set USB controller TD bit */
; 1641 :         pUsbRegs->TEARDOWN |= ((1 << epNum) << USB_OTG_RXTD_SHIFT);

  000f0	e3a0b001	 mov         r11, #1

; 1642 : 
; 1643 :         /* 3. Initiate channel tear-down */
; 1644 :         channel->pRegs->RXGCR =
; 1645 :             BIT31 | /* Enable */
; 1646 :             BIT30 | /* Tear-down */
; 1647 :             BIT24 | /* Retry on starvation */
; 1648 :             BIT14 | /* Host descriptor type (default) */ /*
; 1649 :             qmgr |
; 1650 :             qnum */ USB_CPPI_TDCMPL_QNUM;

  000f4	e59f2110	 ldr         r2, [pc, #0x110]
  000f8	e3833055	 orr         r3, r3, #0x55
  000fc	e1ca31b6	 strh        r3, [r10, #0x16]
  00100	e595301c	 ldr         r3, [r5, #0x1C]
  00104	e183381b	 orr         r3, r3, r11, lsl r8
  00108	e585301c	 str         r3, [r5, #0x1C]
  0010c	e594300c	 ldr         r3, [r4, #0xC]
  00110	e5832008	 str         r2, [r3, #8]

; 1651 : 
; 1652 :         /* 4. Wait for CDMA completion and retry (due to TX disconnect issue) */
; 1653 :         if (channel->isTeardownPending)

  00114	e594301c	 ldr         r3, [r4, #0x1C]
  00118	e3530000	 cmp         r3, #0

; 1654 : 		{
; 1655 :             Sleep(10);

  0011c	13a0000a	 movne       r0, #0xA
  00120	1b000000	 blne        Sleep

; 1656 : 		}
; 1657 : 
; 1658 :         tc0 = GetTickCount();

  00124	eb000000	 bl          GetTickCount

; 1659 :         while ((channel->isTeardownPending) && ((GetTickCount() - tc0) < 2000)) {

  00128	e1a09000	 mov         r9, r0
  0012c	ea00000a	 b           |$LN29@cppiChanne@3|
  00130		 |$LL8@cppiChanne@3|
  00130	eb000000	 bl          GetTickCount
  00134	e0403009	 sub         r3, r0, r9
  00138	e3530e7d	 cmp         r3, #0x7D, 28
  0013c	2a000009	 bcs         |$LN25@cppiChanne@3|

; 1660 :             pUsbRegs->TEARDOWN |= ((1 << epNum) << USB_OTG_RXTD_SHIFT);

  00140	e595301c	 ldr         r3, [r5, #0x1C]
  00144	e183381b	 orr         r3, r3, r11, lsl r8
  00148	e585301c	 str         r3, [r5, #0x1C]

; 1661 :             USBCDMA_KickCompletionCallback(cppi->hUsbCdma);

  0014c	e5960020	 ldr         r0, [r6, #0x20]
  00150	eb000000	 bl          USBCDMA_KickCompletionCallback

; 1662 :             Sleep(10);

  00154	e3a0000a	 mov         r0, #0xA
  00158	eb000000	 bl          Sleep
  0015c		 |$LN29@cppiChanne@3|
  0015c	e594301c	 ldr         r3, [r4, #0x1C]
  00160	e3530000	 cmp         r3, #0
  00164	1afffff1	 bne         |$LL8@cppiChanne@3|
  00168		 |$LN25@cppiChanne@3|

; 1663 :         }
; 1664 : 
; 1665 :         /* 5. Set USB controller TD bit */
; 1666 :         pUsbRegs->TEARDOWN |= ((1 << epNum) << USB_OTG_RXTD_SHIFT);

  00168	e595301c	 ldr         r3, [r5, #0x1C]
  0016c	e3a02cdf	 mov         r2, #0xDF, 24

; 1667 : 
; 1668 :         /* 6. Flush the EP's FIFO */
; 1669 :         csr = pUsbRegs->EPCSR[chanNum + 1].RXCSR;
; 1670 :         csr &= ~MGC_M_RXCSR_DMAENAB;

  00170	e38220aa	 orr         r2, r2, #0xAA
  00174	e183381b	 orr         r3, r3, r11, lsl r8
  00178	e585301c	 str         r3, [r5, #0x1C]
  0017c	e1da31b6	 ldrh        r3, [r10, #0x16]
  00180	e0033002	 and         r3, r3, r2

; 1671 :         csr |= (MGC_M_RXCSR_FLUSHFIFO | MGC_M_RXCSR_P_WZC_BITS);

  00184	e3833055	 orr         r3, r3, #0x55

; 1672 :         pUsbRegs->EPCSR[chanNum + 1].RXCSR = csr;

  00188	e1ca31b6	 strh        r3, [r10, #0x16]

; 1673 : 
; 1674 :         /* quiesce: wait for current dma to finish (if not cleanup)
; 1675 :          * we can't use bit zero of stateram->sopDescPtr since that
; 1676 :          * refers to an entire "DMA packet" not just emptying the
; 1677 :          * current fifo; most segments need multiple usb packets.
; 1678 :          */
; 1679 :         if (channel->Channel.bStatus == MGC_DMA_STATUS_BUSY)

  0018c	e5943004	 ldr         r3, [r4, #4]
  00190	e3530002	 cmp         r3, #2

; 1680 : 		{
; 1681 :             Sleep(50);

  00194	03a00032	 moveq       r0, #0x32
  00198	0b000000	 bleq        Sleep

; 1682 : 		}
; 1683 : 
; 1684 :         /* 7. Disable Scheduler during teardown */
; 1685 :         USBCDMA_ConfigureScheduleRx(chanNum, FALSE);

  0019c	e3a01000	 mov         r1, #0
  001a0	e1a00007	 mov         r0, r7
  001a4	eb000000	 bl          USBCDMA_ConfigureScheduleRx
  001a8		 |$LN10@cppiChanne@3|

; 1686 :     }
; 1687 : 
; 1688 :     if (channel->isTeardownPending) 

  001a8	e594301c	 ldr         r3, [r4, #0x1C]
  001ac	e3530000	 cmp         r3, #0
  001b0	0a00000b	 beq         |$LN21@cppiChanne@3|

; 1689 : 	{
; 1690 :         RETAILMSG(ZONE_WARNING,
; 1691 :             (L"cppiChannelTeardown: %s Ch %u (EP %u) - Timed-out (lost teardown descriptor)!\r\n",
; 1692 :             channel->transmit ? L"TX" : L"RX",
; 1693 :             chanNum,
; 1694 :             epNum));

  001b4	e5943014	 ldr         r3, [r4, #0x14]
  001b8	e59f0048	 ldr         r0, [pc, #0x48]
  001bc	e1a02007	 mov         r2, r7
  001c0	e3530000	 cmp         r3, #0
  001c4	159f1038	 ldrne       r1, [pc, #0x38]
  001c8	059f1030	 ldreq       r1, [pc, #0x30]
  001cc	e1a03008	 mov         r3, r8
  001d0	eb000000	 bl          NKDbgPrintfW

; 1695 :     }
; 1696 : 
; 1697 :     /* Pop all aborted BDs from the channel's queue and free them */
; 1698 :     for(;;) 
; 1699 : 	{
; 1700 :         HOST_DESCRIPTOR *hd = cppiQueuePop(cppi->pRegs, channel->queueNo);

  001d4	ea000002	 b           |$LN21@cppiChanne@3|
  001d8		 |$LL4@cppiChanne@3|

; 1701 :         if (hd != NULL) 
; 1702 : 		{
; 1703 :             cppiHdFree(cppi, hd);

  001d8	e1a01000	 mov         r1, r0
  001dc	e1a00006	 mov         r0, r6
  001e0	eb000000	 bl          cppiHdFree
  001e4		 |$LN21@cppiChanne@3|
  001e4	e5d41019	 ldrb        r1, [r4, #0x19]
  001e8	e596001c	 ldr         r0, [r6, #0x1C]
  001ec	eb000000	 bl          cppiQueuePop
  001f0	e3500000	 cmp         r0, #0
  001f4	1afffff7	 bne         |$LL4@cppiChanne@3|

; 1704 :             DEBUGMSG(/*ZONE_WARNING*/0,
; 1705 :                 (L"cppiChannelTeardown: Recovered %s BD on queue %u after tear-down\r\n",
; 1706 :                 channel->transmit ? L"TX" : L"RX",
; 1707 :                 channel->queueNo));
; 1708 :         }
; 1709 :         else
; 1710 : 		{
; 1711 :             break;
; 1712 : 		}
; 1713 :     }
; 1714 : 
; 1715 :     DEBUGMSG(ZONE_INIT || ZONE_PDD_DMA,
; 1716 :         (L"-cppiChannelTeardown: %s Ch %u (EP %u) - %s\r\n",
; 1717 :         channel->transmit ? L"TX" : L"RX",
; 1718 :         chanNum,
; 1719 :         epNum,
; 1720 :         channel->isTeardownPending ?
; 1721 :             L"FAILED!" :
; 1722 :             L"SUCCEEDED"));
; 1723 : }

  001f8	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001fc	e12fff1e	 bx          lr
  00200		 |$LN34@cppiChanne@3|
  00200		 |$LN35@cppiChanne@3|
  00200	00000000	 DCD         |??_C@_15BMCNAON@?$AAR?$AAX?$AA?$AA@|
  00204		 |$LN36@cppiChanne@3|
  00204	00000000	 DCD         |??_C@_15NHJLDDPA@?$AAT?$AAX?$AA?$AA@|
  00208		 |$LN37@cppiChanne@3|
  00208	00000000	 DCD         |??_C@_1KA@OEINGMKN@?$AAc?$AAp?$AAp?$AAi?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAT?$AAe?$AAa?$AAr?$AAd?$AAo?$AAw?$AAn?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAC?$AAh?$AA?5?$AA?$CF?$AAu?$AA?5?$AA?$CI?$AAE@|
  0020c		 |$LN38@cppiChanne@3|
  0020c	c1004044	 DCD         0xc1004044
  00210		 |$M47721|

			 ENDP  ; |cppiChannelTeardown|

	EXPORT	|??_C@_1EO@MHLFMFGL@?$AAc?$AAp?$AAp?$AAi?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAA?$AAb?$AAo?$AAr?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAD?$AAM?$AAA?$AAC?$AA?5?$AAs@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T47739| DCD	|$LN11@cppiChanne@4|
	DCD	0x40002601

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EO@MHLFMFGL@?$AAc?$AAp?$AAp?$AAi?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAA?$AAb?$AAo?$AAr?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAD?$AAM?$AAA?$AAC?$AA?5?$AAs@| DCB "c"
	DCB	0x0, "p", 0x0, "p", 0x0, "i", 0x0, "C", 0x0, "h", 0x0, "a"
	DCB	0x0, "n", 0x0, "n", 0x0, "e", 0x0, "l", 0x0, "A", 0x0, "b"
	DCB	0x0, "o", 0x0, "r", 0x0, "t", 0x0, ":", 0x0, " ", 0x0, "I"
	DCB	0x0, "n", 0x0, "v", 0x0, "a", 0x0, "l", 0x0, "i", 0x0, "d"
	DCB	0x0, " ", 0x0, "D", 0x0, "M", 0x0, "A", 0x0, "C", 0x0, " "
	DCB	0x0, "s", 0x0, "t", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiChannelAbort| PROC

; 1747 : {

  00000		 |$LN11@cppiChanne@4|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47736|
  00004	e1a04000	 mov         r4, r0

; 1748 :     int rc = 0;
; 1749 :     struct cppi_channel *otgCh = (struct cppi_channel *)channel;
; 1750 : 
; 1751 :     DEBUGMSG(ZONE_INIT || ZONE_PDD_DMA,
; 1752 :         (L"+cppiChannelAbort: %s Ch %u (EP %u)\r\n",
; 1753 :         otgCh->transmit ? L"TX" : L"RX",
; 1754 :         otgCh->channelNo,
; 1755 :         otgCh->channelNo + 1));
; 1756 : 
; 1757 :     switch (channel->bStatus)

  00008	e5943004	 ldr         r3, [r4, #4]
  0000c	e3a05000	 mov         r5, #0
  00010	e3530000	 cmp         r3, #0
  00014	0a00000e	 beq         |$LN3@cppiChanne@4|
  00018	e3530001	 cmp         r3, #1
  0001c	0a00000c	 beq         |$LN3@cppiChanne@4|
  00020	e2433002	 sub         r3, r3, #2
  00024	e3530002	 cmp         r3, #2
  00028	8a000001	 bhi         |$LN1@cppiChanne@4|

; 1758 :     {
; 1759 :     case MGC_DMA_STATUS_BUS_ABORT:
; 1760 :     case MGC_DMA_STATUS_CORE_ABORT:
; 1761 :         // from RX or TX fault irq handler
; 1762 :     case MGC_DMA_STATUS_BUSY:
; 1763 :         // The hardware needs shutting down
; 1764 :         cppiChannelTeardown(otgCh);

  0002c	eb000000	 bl          cppiChannelTeardown

; 1765 :         break;

  00030	ea000007	 b           |$LN3@cppiChanne@4|
  00034		 |$LN1@cppiChanne@4|

; 1766 : 
; 1767 :     case MGC_DMA_STATUS_UNKNOWN:
; 1768 :         DEBUGMSG(ZONE_INIT || ZONE_PDD_DMA,
; 1769 :             (L"cppiChannelAbort: %s Ch %u (EP %u) not allocated\r\n",
; 1770 :             otgCh->transmit ? L"TX" : L"RX",
; 1771 :             otgCh->channelNo,
; 1772 :             otgCh->channelNo + 1));
; 1773 : 
; 1774 :     case MGC_DMA_STATUS_FREE:
; 1775 :         break;
; 1776 : 
; 1777 :     default:
; 1778 :         ERRORMSG(TRUE, (L"cppiChannelAbort: Invalid DMAC state\r\n"));

  00034	e59f1058	 ldr         r1, [pc, #0x58]
  00038	e59f0050	 ldr         r0, [pc, #0x50]
  0003c	e3a03c06	 mov         r3, #6, 24
  00040	e38320f2	 orr         r2, r3, #0xF2
  00044	eb000000	 bl          NKDbgPrintfW
  00048	e59f003c	 ldr         r0, [pc, #0x3C]
  0004c	eb000000	 bl          NKDbgPrintfW

; 1779 :         rc = -1;

  00050	e3e05000	 mvn         r5, #0
  00054		 |$LN3@cppiChanne@4|

; 1780 :         break;
; 1781 :     }
; 1782 : 
; 1783 :     channel->bStatus = MGC_DMA_STATUS_FREE;

  00054	e3a03001	 mov         r3, #1
  00058	e5843004	 str         r3, [r4, #4]

; 1784 :     otgCh->startAddr = 0;

  0005c	e3a03000	 mov         r3, #0
  00060	e5843020	 str         r3, [r4, #0x20]

; 1785 :     otgCh->currOffset = 0;

  00064	e584302c	 str         r3, [r4, #0x2C]

; 1786 :     otgCh->transferSize = 0;

  00068	e5843024	 str         r3, [r4, #0x24]

; 1787 :     otgCh->pktSize = 0;

  0006c	e5843028	 str         r3, [r4, #0x28]

; 1788 :     otgCh->nISOHDQueued      = 0;

  00070	e584303c	 str         r3, [r4, #0x3C]

; 1789 :     otgCh->nISOHDPerTransfer = 0;

  00074	e5843034	 str         r3, [r4, #0x34]

; 1790 :     otgCh->nISOHDForCallback = 0;

  00078	e5843038	 str         r3, [r4, #0x38]

; 1791 :     otgCh->nISOHDLastIndex   = 0;

  0007c	e5843040	 str         r3, [r4, #0x40]

; 1792 : 
; 1793 :     DEBUGMSG(ZONE_INIT || ZONE_PDD_DMA,
; 1794 :         (L"-cppiChannelAbort: %s Ch %u (EP %u)\r\n",
; 1795 :         otgCh->transmit ? L"TX" : L"RX",
; 1796 :         otgCh->channelNo,
; 1797 :         otgCh->channelNo + 1));
; 1798 : 
; 1799 :     return rc;
; 1800 : }

  00080	e1a00005	 mov         r0, r5
  00084	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$LN12@cppiChanne@4|
  0008c		 |$LN13@cppiChanne@4|
  0008c	00000000	 DCD         |??_C@_1EO@MHLFMFGL@?$AAc?$AAp?$AAp?$AAi?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAA?$AAb?$AAo?$AAr?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAD?$AAM?$AAA?$AAC?$AA?5?$AAs@|
  00090		 |$LN14@cppiChanne@4|
  00090	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  00094		 |$LN15@cppiChanne@4|
  00094	00000000	 DCD         |??_C@_1JM@MEFHOMOC@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  00098		 |$M47737|

			 ENDP  ; |cppiChannelAbort|

	EXPORT	|cppiControllerDeinit|

  00000			 AREA	 |.pdata|, PDATA
|$T47756| DCD	|$LN9@cppiContro@2|
	DCD	0x40001c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiControllerDeinit| PROC

; 1861 : {

  00000		 |$LN9@cppiContro@2|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47753|

; 1862 :     struct cppi *cppi = f_CppiObj;

  00004	e59f3060	 ldr         r3, [pc, #0x60]
  00008	e5935000	 ldr         r5, [r3]

; 1863 : 
; 1864 : 	UNREFERENCED_PARAMETER(pPdd);
; 1865 : 
; 1866 :     cppiPoolDeinit(cppi);

  0000c	e3550000	 cmp         r5, #0
  00010	0a000013	 beq         |$LN5@cppiContro@2|
  00014	e5953898	 ldr         r3, [r5, #0x898]
  00018	e3530000	 cmp         r3, #0
  0001c	0a000010	 beq         |$LN5@cppiContro@2|
  00020	e2854b02	 add         r4, r5, #2, 22
  00024	e28400b8	 add         r0, r4, #0xB8
  00028	eb000000	 bl          EnterCriticalSection
  0002c	e5950020	 ldr         r0, [r5, #0x20]
  00030	eb000000	 bl          USBCDMA_DeregisterUsbModule
  00034	e3a03000	 mov         r3, #0
  00038	e28400b8	 add         r0, r4, #0xB8
  0003c	e58538b4	 str         r3, [r5, #0x8B4]
  00040	e58538b0	 str         r3, [r5, #0x8B0]
  00044	e58538ac	 str         r3, [r5, #0x8AC]
  00048	e58538a8	 str         r3, [r5, #0x8A8]
  0004c	e58538a0	 str         r3, [r5, #0x8A0]
  00050	e58538a4	 str         r3, [r5, #0x8A4]
  00054	e5853898	 str         r3, [r5, #0x898]
  00058	eb000000	 bl          LeaveCriticalSection
  0005c	e28400b8	 add         r0, r4, #0xB8
  00060	eb000000	 bl          DeleteCriticalSection
  00064		 |$LN5@cppiContro@2|

; 1867 : }

  00064	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00068	e12fff1e	 bx          lr
  0006c		 |$LN10@cppiContro@2|
  0006c		 |$LN11@cppiContro@2|
  0006c	00000000	 DCD         |f_CppiObj|
  00070		 |$M47754|

			 ENDP  ; |cppiControllerDeinit|

	EXPORT	|??_C@_1GG@PAECHJLN@?$AA?$CL?$AAc?$AAp?$AAp?$AAi?$AAP?$AAo?$AAo?$AAl?$AAI?$AAn?$AAi?$AAt?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FK@MJCBCGCD@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAc?$AAp?$AAp?$AAi?$AAH?$AAd?$AAP?$AAo?$AAo?$AAl?$AAI?$AAn?$AAi?$AAt?$AA?5?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA?5?$AAc?$AAp?$AAp@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T47772| DCD	|$LN16@cppiHdPool|
	DCD	0x40004101

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GG@PAECHJLN@?$AA?$CL?$AAc?$AAp?$AAp?$AAi?$AAP?$AAo?$AAo?$AAl?$AAI?$AAn?$AAi?$AAt?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe@| DCB "+"
	DCB	0x0, "c", 0x0, "p", 0x0, "p", 0x0, "i", 0x0, "P", 0x0, "o"
	DCB	0x0, "o", 0x0, "l", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t"
	DCB	0x0, " ", 0x0, "U", 0x0, "n", 0x0, "a", 0x0, "b", 0x0, "l"
	DCB	0x0, "e", 0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "A"
	DCB	0x0, "l", 0x0, "l", 0x0, "o", 0x0, "c", 0x0, "a", 0x0, "t"
	DCB	0x0, "e", 0x0, " ", 0x0, "D", 0x0, "e", 0x0, "s", 0x0, "c"
	DCB	0x0, "r", 0x0, "i", 0x0, "p", 0x0, "t", 0x0, "o", 0x0, "r"
	DCB	0x0, "s", 0x0, " ", 0x0, "!", 0x0, "!", 0x0, "!", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FK@MJCBCGCD@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAc?$AAp?$AAp?$AAi?$AAH?$AAd?$AAP?$AAo?$AAo?$AAl?$AAI?$AAn?$AAi?$AAt?$AA?5?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA?5?$AAc?$AAp?$AAp@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "c", 0x0, "p", 0x0, "p", 0x0, "i", 0x0, "H", 0x0, "d"
	DCB	0x0, "P", 0x0, "o", 0x0, "o", 0x0, "l", 0x0, "I", 0x0, "n"
	DCB	0x0, "i", 0x0, "t", 0x0, " ", 0x0, "b", 0x0, "e", 0x0, "f"
	DCB	0x0, "o", 0x0, "r", 0x0, "e", 0x0, " ", 0x0, "c", 0x0, "p"
	DCB	0x0, "p", 0x0, "i", 0x0, "P", 0x0, "o", 0x0, "o", 0x0, "l"
	DCB	0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, "!", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiHdPoolInit| PROC

; 271  : {

  00000		 |$LN16@cppiHdPool|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M47769|
  00004	e1b04000	 movs        r4, r0

; 272  :     unsigned descriptorCount = 0;
; 273  :     unsigned n				 = 0;
; 274  : 
; 275  :     DEBUGCHK(cppi != NULL);
; 276  :     if (cppi == NULL)

  00008	0a000037	 beq         |$done$46808|

; 277  : 	{
; 278  :         return;
; 279  : 	}
; 280  : 
; 281  :     // Only initialise once
; 282  :     if (cppi->poolUsed)

  0000c	e59438ac	 ldr         r3, [r4, #0x8AC]
  00010	e3530000	 cmp         r3, #0
  00014	1a000034	 bne         |$done$46808|

; 283  : 	{
; 284  :         goto done;
; 285  : 	}
; 286  : 
; 287  :     descriptorCount = cppi->pPdd->descriptorCount;

  00018	e5943018	 ldr         r3, [r4, #0x18]

; 288  : 
; 289  :     DEBUGMSG(ZONE_INIT,
; 290  :         (L"+cppiPoolInit: %u HDs\r\n", descriptorCount));
; 291  : 
; 292  :     if (cppi->pool == NULL) 

  0001c	e5942898	 ldr         r2, [r4, #0x898]
  00020	e5936660	 ldr         r6, [r3, #0x660]
  00024	e3520000	 cmp         r2, #0
  00028	1a000008	 bne         |$LN6@cppiHdPool|

; 293  : 	{
; 294  :         ERRORMSG(1, (L"ERROR: cppiHdPoolInit before cppiPoolInit!\r\n"));

  0002c	e59f10c8	 ldr         r1, [pc, #0xC8]
  00030	e59f00c0	 ldr         r0, [pc, #0xC0]
  00034	e3a03c01	 mov         r3, #1, 24
  00038	e3832026	 orr         r2, r3, #0x26
  0003c	eb000000	 bl          NKDbgPrintfW
  00040	e59f00b8	 ldr         r0, [pc, #0xB8]
  00044	eb000000	 bl          NKDbgPrintfW

; 333  : 
; 334  : done:
; 335  :     PRINTMSG(ZONE_INIT,
; 336  :         (L"-cppiPoolInit: Allocated %u HDs GlobalPool Free %u bytes\r\n",
; 337  :         n, cppi->poolFree));
; 338  : 
; 339  :     return;
; 340  : }

  00048	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$LN6@cppiHdPool|

; 295  :         goto done;
; 296  :     }
; 297  : 
; 298  :     LOCK_HD_POOL(cppi);

  00050	e2845b02	 add         r5, r4, #2, 22
  00054	e28500b8	 add         r0, r5, #0xB8
  00058	eb000000	 bl          EnterCriticalSection

; 299  : 
; 300  :     /* Build the Host Descriptor Free list */
; 301  :     for (n = 0; n < descriptorCount; n++)

  0005c	e3a07000	 mov         r7, #0
  00060	e3560000	 cmp         r6, #0
  00064	0a00001e	 beq         |$LN3@cppiHdPool|
  00068	e3a08102	 mov         r8, #2, 2
  0006c		 |$LL5@cppiHdPool|

; 302  :     {
; 303  :         HOST_DESCRIPTOR* hd = NULL;
; 304  : 
; 305  :         /* Allocate Memory for this Host Descriptor from our Pool. Have to return Physical Address
; 306  :            back so that it helps in easier setup of CPPI Transfers
; 307  :         */
; 308  :         if (cppi->poolFree < CPPI_HD_SIZE)

  0006c	e59438b0	 ldr         r3, [r4, #0x8B0]
  00070	e3530040	 cmp         r3, #0x40
  00074	3a000013	 bcc         |$LN12@cppiHdPool|

; 311  :             break;
; 312  :         }
; 313  :         else
; 314  :         {
; 315  :             hd = (HOST_DESCRIPTOR *)((UINT32)cppi->pool + cppi->poolUsed);

  00078	e594e8ac	 ldr         lr, [r4, #0x8AC]
  0007c	e5943898	 ldr         r3, [r4, #0x898]

; 316  : 
; 317  :             /* Set descriptor type to Host */
; 318  :             hd->DescInfo = (UINT32)(USB_CPPI41_DESC_TYPE_HOST << USB_CPPI41_DESC_TYPE_SHIFT);
; 319  : 
; 320  :             /* For every descriptor, we also maintain Physical Address */
; 321  :             hd->addr = (cppi->paPool.LowPart + cppi->poolUsed);
; 322  : 
; 323  :             cppi->poolUsed += CPPI_HD_SIZE;
; 324  :             cppi->poolFree -= CPPI_HD_SIZE;
; 325  : 
; 326  :             cppiHdFree(cppi, hd);

  00080	e1a00004	 mov         r0, r4
  00084	e7ae8003	 str         r8, [lr, +r3]!
  00088	e59428ac	 ldr         r2, [r4, #0x8AC]
  0008c	e59438a0	 ldr         r3, [r4, #0x8A0]
  00090	e1a0100e	 mov         r1, lr
  00094	e0823003	 add         r3, r2, r3
  00098	e58e302c	 str         r3, [lr, #0x2C]
  0009c	e59438ac	 ldr         r3, [r4, #0x8AC]
  000a0	e59428b0	 ldr         r2, [r4, #0x8B0]
  000a4	e2833040	 add         r3, r3, #0x40
  000a8	e2422040	 sub         r2, r2, #0x40
  000ac	e58438ac	 str         r3, [r4, #0x8AC]
  000b0	e58428b0	 str         r2, [r4, #0x8B0]
  000b4	eb000000	 bl          cppiHdFree
  000b8	e2877001	 add         r7, r7, #1
  000bc	e1570006	 cmp         r7, r6
  000c0	3affffe9	 bcc         |$LL5@cppiHdPool|

; 302  :     {
; 303  :         HOST_DESCRIPTOR* hd = NULL;
; 304  : 
; 305  :         /* Allocate Memory for this Host Descriptor from our Pool. Have to return Physical Address
; 306  :            back so that it helps in easier setup of CPPI Transfers
; 307  :         */
; 308  :         if (cppi->poolFree < CPPI_HD_SIZE)

  000c4	ea000006	 b           |$LN3@cppiHdPool|
  000c8		 |$LN12@cppiHdPool|

; 309  :         {
; 310  :             ERRORMSG(TRUE, (L"+cppiPoolInit Unable to Allocate Descriptors !!!\r\n"));

  000c8	e59f102c	 ldr         r1, [pc, #0x2C]
  000cc	e59f0024	 ldr         r0, [pc, #0x24]
  000d0	e3a03c01	 mov         r3, #1, 24
  000d4	e3832036	 orr         r2, r3, #0x36
  000d8	eb000000	 bl          NKDbgPrintfW
  000dc	e59f0010	 ldr         r0, [pc, #0x10]
  000e0	eb000000	 bl          NKDbgPrintfW
  000e4		 |$LN3@cppiHdPool|

; 327  : 
; 328  :             PRINTMSG(ZONE_INIT, (L"HD %04u: PAddr 0x%08x VAddr 0x%08x\r\n", n, hd->addr, hd));
; 329  :         }
; 330  :     }
; 331  : 
; 332  :     UNLOCK_HD_POOL(cppi);

  000e4	e28500b8	 add         r0, r5, #0xB8
  000e8	eb000000	 bl          LeaveCriticalSection
  000ec		 |$done$46808|

; 333  : 
; 334  : done:
; 335  :     PRINTMSG(ZONE_INIT,
; 336  :         (L"-cppiPoolInit: Allocated %u HDs GlobalPool Free %u bytes\r\n",
; 337  :         n, cppi->poolFree));
; 338  : 
; 339  :     return;
; 340  : }

  000ec	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000f0	e12fff1e	 bx          lr
  000f4		 |$LN17@cppiHdPool|
  000f4		 |$LN18@cppiHdPool|
  000f4	00000000	 DCD         |??_C@_1GG@PAECHJLN@?$AA?$CL?$AAc?$AAp?$AAp?$AAi?$AAP?$AAo?$AAo?$AAl?$AAI?$AAn?$AAi?$AAt?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe@|
  000f8		 |$LN19@cppiHdPool|
  000f8	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  000fc		 |$LN20@cppiHdPool|
  000fc	00000000	 DCD         |??_C@_1JM@MEFHOMOC@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  00100		 |$LN21@cppiHdPool|
  00100	00000000	 DCD         |??_C@_1FK@MJCBCGCD@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAc?$AAp?$AAp?$AAi?$AAH?$AAd?$AAP?$AAo?$AAo?$AAl?$AAI?$AAn?$AAi?$AAt?$AA?5?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA?5?$AAc?$AAp?$AAp@|
  00104		 |$M47770|

			 ENDP  ; |cppiHdPoolInit|

	EXPORT	|??_C@_1IM@POBJEFAI@?$AAc?$AAp?$AAp?$AAi?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AAd?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAC@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HE@IBPFHKOH@?$AAc?$AAp?$AAp?$AAi?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AAd?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAC@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HC@CEGIGIGI@?$AA?9?$AAc?$AAp?$AAp?$AAi?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AAd?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T47802| DCD	|$LN30@cppiProces@2|
	DCD	0x40008602

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1IM@POBJEFAI@?$AAc?$AAp?$AAp?$AAi?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AAd?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAC@| DCB "c"
	DCB	0x0, "p", 0x0, "p", 0x0, "i", 0x0, "P", 0x0, "r", 0x0, "o"
	DCB	0x0, "c", 0x0, "e", 0x0, "s", 0x0, "s", 0x0, "C", 0x0, "o"
	DCB	0x0, "m", 0x0, "p", 0x0, "l", 0x0, "e", 0x0, "t", 0x0, "e"
	DCB	0x0, "d", 0x0, "P", 0x0, "a", 0x0, "c", 0x0, "k", 0x0, "e"
	DCB	0x0, "t", 0x0, ":", 0x0, " ", 0x0, "%", 0x0, "s", 0x0, " "
	DCB	0x0, "C", 0x0, "h", 0x0, " ", 0x0, "%", 0x0, "u", 0x0, " "
	DCB	0x0, "(", 0x0, "E", 0x0, "P", 0x0, " ", 0x0, "%", 0x0, "u"
	DCB	0x0, ")", 0x0, " ", 0x0, "[", 0x0, "Q", 0x0, "%", 0x0, "u"
	DCB	0x0, ",", 0x0, " ", 0x0, "%", 0x0, "s", 0x0, "]", 0x0, ","
	DCB	0x0, " ", 0x0, "N", 0x0, "U", 0x0, "L", 0x0, "L", 0x0, " "
	DCB	0x0, "p", 0x0, "E", 0x0, "n", 0x0, "d", 0x0, "P", 0x0, "t"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HE@IBPFHKOH@?$AAc?$AAp?$AAp?$AAi?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AAd?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAC@| DCB "c"
	DCB	0x0, "p", 0x0, "p", 0x0, "i", 0x0, "P", 0x0, "r", 0x0, "o"
	DCB	0x0, "c", 0x0, "e", 0x0, "s", 0x0, "s", 0x0, "C", 0x0, "o"
	DCB	0x0, "m", 0x0, "p", 0x0, "l", 0x0, "e", 0x0, "t", 0x0, "e"
	DCB	0x0, "d", 0x0, "P", 0x0, "a", 0x0, "c", 0x0, "k", 0x0, "e"
	DCB	0x0, "t", 0x0, ":", 0x0, " ", 0x0, "%", 0x0, "s", 0x0, " "
	DCB	0x0, "C", 0x0, "h", 0x0, " ", 0x0, "%", 0x0, "u", 0x0, " "
	DCB	0x0, "(", 0x0, "E", 0x0, "P", 0x0, " ", 0x0, "%", 0x0, "u"
	DCB	0x0, ")", 0x0, ",", 0x0, " ", 0x0, "L", 0x0, "i", 0x0, "n"
	DCB	0x0, "k", 0x0, "e", 0x0, "d", 0x0, " ", 0x0, "H", 0x0, "D"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HC@CEGIGIGI@?$AA?9?$AAc?$AAp?$AAp?$AAi?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AAd?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5@| DCB "-"
	DCB	0x0, "c", 0x0, "p", 0x0, "p", 0x0, "i", 0x0, "P", 0x0, "r"
	DCB	0x0, "o", 0x0, "c", 0x0, "e", 0x0, "s", 0x0, "s", 0x0, "C"
	DCB	0x0, "o", 0x0, "m", 0x0, "p", 0x0, "l", 0x0, "e", 0x0, "t"
	DCB	0x0, "e", 0x0, "d", 0x0, "P", 0x0, "a", 0x0, "c", 0x0, "k"
	DCB	0x0, "e", 0x0, "t", 0x0, ":", 0x0, " ", 0x0, "%", 0x0, "s"
	DCB	0x0, " ", 0x0, "C", 0x0, "h", 0x0, " ", 0x0, "%", 0x0, "u"
	DCB	0x0, " ", 0x0, "(", 0x0, "E", 0x0, "P", 0x0, " ", 0x0, "%"
	DCB	0x0, "u", 0x0, ")", 0x0, ",", 0x0, " ", 0x0, "N", 0x0, "U"
	DCB	0x0, "L", 0x0, "L", 0x0, " ", 0x0, "H", 0x0, "D", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiProcessCompletedPacket| PROC

; 662  : {

  00000		 |$LN30@cppiProces@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M47799|
  00008	e1a04002	 mov         r4, r2
  0000c	e1a06001	 mov         r6, r1
  00010	e1a08000	 mov         r8, r0

; 663  :     BYTE   chanNum = chanPtr->channelNo;
; 664  :     BYTE   epNum   = chanNum + 1;
; 665  :     MGC_pfDmaCompletion pfnDmaCompleted = NULL;
; 666  :     BOOL transferComplete = TRUE;
; 667  :     UINT32 buffLen = 0;
; 668  : 
; 669  : #ifndef SHIP_BUILD
; 670  :     WCHAR *chanDir = chanPtr->transmit ? L"TX" : L"RX";

  00014	e5943014	 ldr         r3, [r4, #0x14]
  00018	e59f71f4	 ldr         r7, [pc, #0x1F4]
  0001c	e5d4a018	 ldrb        r10, [r4, #0x18]
  00020	e3530000	 cmp         r3, #0
  00024	11a05007	 movne       r5, r7
  00028	059f51cc	 ldreq       r5, [pc, #0x1CC]

; 671  : #endif
; 672  : 
; 673  :     PRINTMSG(/*ZONE_PDD_DMA*/0,
; 674  :         (L"+cppiProcessCompletedPacket: %s Ch %u (EP %u)\r\n",
; 675  :         chanDir,
; 676  :         chanNum,
; 677  :         epNum));
; 678  : 
; 679  :     if (hdPtr == NULL) 

  0002c	e3560000	 cmp         r6, #0
  00030	e28ab001	 add         r11, r10, #1
  00034	e3a09000	 mov         r9, #0
  00038	1a000005	 bne         |$LN15@cppiProces@2|

; 680  : 	{
; 681  :         PRINTMSG(ZONE_WARNING,
; 682  :             (L"-cppiProcessCompletedPacket: %s Ch %u (EP %u), NULL HD\r\n",
; 683  :             chanDir,
; 684  :             chanNum,
; 685  :             epNum));

  0003c	e59f01cc	 ldr         r0, [pc, #0x1CC]
  00040	e20b30ff	 and         r3, r11, #0xFF
  00044	e1a0200a	 mov         r2, r10
  00048	e1a01005	 mov         r1, r5
  0004c	eb000000	 bl          NKDbgPrintfW

; 686  :         return;

  00050	ea000065	 b           |$LN1@cppiProces@2|
  00054		 |$LN15@cppiProces@2|

; 687  :     }
; 688  : 
; 689  :     ERRORMSG(hdPtr->NextPtr != 0,
; 690  :         (L"cppiProcessCompletedPacket: %s Ch %u (EP %u), Linked HD\r\n",
; 691  :         chanDir,
; 692  :         chanNum,
; 693  :         epNum));

  00054	e5963014	 ldr         r3, [r6, #0x14]
  00058	e3530000	 cmp         r3, #0
  0005c	0a000009	 beq         |$LN20@cppiProces@2|
  00060	e59f11a4	 ldr         r1, [pc, #0x1A4]
  00064	e59f019c	 ldr         r0, [pc, #0x19C]
  00068	e3a03c02	 mov         r3, #2, 24
  0006c	e38320b5	 orr         r2, r3, #0xB5
  00070	eb000000	 bl          NKDbgPrintfW
  00074	e59f0188	 ldr         r0, [pc, #0x188]
  00078	e20b30ff	 and         r3, r11, #0xFF
  0007c	e1a0200a	 mov         r2, r10
  00080	e1a01005	 mov         r1, r5
  00084	eb000000	 bl          NKDbgPrintfW
  00088		 |$LN20@cppiProces@2|

; 694  : 
; 695  :     /* For overlapped IO need to protect channel vars */
; 696  :     LOCK_ENDPOINT(pPdd);

  00088	e2880e27	 add         r0, r8, #0x27, 28
  0008c	eb000000	 bl          EnterCriticalSection

; 697  : 
; 698  :     buffLen = (hdPtr->BuffLen & USB_CPPI41_HD_BUF_LENGTH_MASK);

  00090	e596300c	 ldr         r3, [r6, #0xC]

; 699  : 
; 700  :     /* Check for zero length packet */
; 701  :     if (hdPtr->PacketInfo & USB_CPPI41_PKT_FLAGS_ZLP)

  00094	e5962008	 ldr         r2, [r6, #8]
  00098	e3e014ff	 mvn         r1, #0xFF, 8
  0009c	e221e503	 eor         lr, r1, #3, 10
  000a0	e003100e	 and         r1, r3, lr

; 702  : 	{
; 703  : 		buffLen = 0;
; 704  : 	}
; 705  : 
; 706  :     chanPtr->actualLen += buffLen;

  000a4	e5943030	 ldr         r3, [r4, #0x30]
  000a8	e3120702	 tst         r2, #2, 14

; 707  : 
; 708  :     if (chanPtr->pEndPt == NULL) 

  000ac	e5942010	 ldr         r2, [r4, #0x10]
  000b0	13a01000	 movne       r1, #0
  000b4	e0830001	 add         r0, r3, r1
  000b8	e5840030	 str         r0, [r4, #0x30]
  000bc	e3520000	 cmp         r2, #0
  000c0	1a00000b	 bne         |$LN13@cppiProces@2|

; 709  : 	{
; 710  :         RETAILMSG(ZONE_WARNING,
; 711  :             (L"cppiProcessCompletedPacket: %s Ch %u (EP %u) [Q%u, %s], NULL pEndPt\r\n",
; 712  :             chanDir,
; 713  :             chanNum,
; 714  :             epNum,
; 715  :             chanPtr->queueNo,
; 716  :             chanPtr->transmit ? L"TX" : L"RX"));

  000c4	e5943014	 ldr         r3, [r4, #0x14]
  000c8	e5d42019	 ldrb        r2, [r4, #0x19]
  000cc	e59f012c	 ldr         r0, [pc, #0x12C]
  000d0	e3530000	 cmp         r3, #0
  000d4	059f7120	 ldreq       r7, [pc, #0x120]
  000d8	e58d2000	 str         r2, [sp]
  000dc	e20b30ff	 and         r3, r11, #0xFF
  000e0	e1a0200a	 mov         r2, r10
  000e4	e1a01005	 mov         r1, r5
  000e8	e58d7004	 str         r7, [sp, #4]
  000ec	eb000000	 bl          NKDbgPrintfW

; 717  :         goto done;

  000f0	ea000031	 b           |$done$47008|
  000f4		 |$LN13@cppiProces@2|

; 718  :     }
; 719  : 
; 720  :     if (chanPtr->isTeardownPending) 

  000f4	e594301c	 ldr         r3, [r4, #0x1C]
  000f8	e3530000	 cmp         r3, #0
  000fc	1a00002e	 bne         |$done$47008|

; 721  : 	{
; 722  :         DEBUGMSG(ZONE_WARNING,
; 723  :             (L"cppiProcessCompletedPacket: %s Ch %u (EP %u) - Dropped (pending teardown)!\r\n",
; 724  :             chanDir,
; 725  :             chanNum,
; 726  :             epNum));
; 727  :         goto done;
; 728  :     }
; 729  : 
; 730  :     if (chanPtr->pEndPt->endpointType != USB_ENDPOINT_TYPE_ISOCHRONOUS)

  00100	e5d2300c	 ldrb        r3, [r2, #0xC]
  00104	e3530001	 cmp         r3, #1
  00108	0a000012	 beq         |$LN24@cppiProces@2|

; 731  :     {
; 732  :         if ((chanPtr->transmit) && (chanPtr->actualLen < chanPtr->transferSize))

  0010c	e5943014	 ldr         r3, [r4, #0x14]
  00110	e3530000	 cmp         r3, #0
  00114	e5943024	 ldr         r3, [r4, #0x24]
  00118	0a000002	 beq         |$LN25@cppiProces@2|
  0011c	e1500003	 cmp         r0, r3
  00120	2a000011	 bcs         |$LN6@cppiProces@2|

; 733  :         {
; 734  :             cppiNextSegment(pPdd, chanPtr);
; 735  :             transferComplete = FALSE;
; 736  :         }
; 737  :         else if ((!chanPtr->transmit) &&

  00124	ea000007	 b           |$LN27@cppiProces@2|
  00128		 |$LN25@cppiProces@2|

; 738  :                  (chanPtr->actualLen < chanPtr->transferSize) &&
; 739  :                  (buffLen != 0) &&
; 740  :                  (buffLen == (hdPtr->OrigBuffLen & USB_CPPI41_HD_BUF_LENGTH_MASK)))

  00128	e1500003	 cmp         r0, r3
  0012c	2a000009	 bcs         |$LN24@cppiProces@2|
  00130	e3510000	 cmp         r1, #0
  00134	0a000007	 beq         |$LN24@cppiProces@2|
  00138	e5963018	 ldr         r3, [r6, #0x18]
  0013c	e003300e	 and         r3, r3, lr
  00140	e1510003	 cmp         r1, r3
  00144	1a000003	 bne         |$LN24@cppiProces@2|
  00148		 |$LN27@cppiProces@2|

; 741  :         {
; 742  :             cppiNextSegment(pPdd, chanPtr);

  00148	e1a01004	 mov         r1, r4
  0014c	e1a00008	 mov         r0, r8
  00150	eb000000	 bl          cppiNextSegment

; 743  :             transferComplete = FALSE;
; 744  :         }
; 745  :     }
; 746  : 
; 747  :     if (transferComplete)

  00154	ea000018	 b           |$done$47008|
  00158		 |$LN24@cppiProces@2|

; 748  :     {
; 749  :         // Disable Rx for this channel until a new BD has been supplied
; 750  :         if(!chanPtr->transmit)

  00158	e5943014	 ldr         r3, [r4, #0x14]
  0015c	e3530000	 cmp         r3, #0

; 751  : 		{
; 752  :             USBCDMA_ConfigureScheduleRx(chanPtr->channelNo, FALSE);

  00160	05d40018	 ldreqb      r0, [r4, #0x18]
  00164	03a01000	 moveq       r1, #0
  00168	0b000000	 bleq        USBCDMA_ConfigureScheduleRx
  0016c		 |$LN6@cppiProces@2|

; 753  : 		}
; 754  : 
; 755  :         if (chanPtr->pEndPt->endpointType != USB_ENDPOINT_TYPE_ISOCHRONOUS)

  0016c	e5943010	 ldr         r3, [r4, #0x10]
  00170	e5d3300c	 ldrb        r3, [r3, #0xC]
  00174	e3530001	 cmp         r3, #1

; 756  :         {
; 757  :             chanPtr->Channel.bStatus = MGC_DMA_STATUS_FREE;
; 758  :             pfnDmaCompleted = chanPtr->pfnDmaCompleted;
; 759  :         }
; 760  :         else

  00178	1a00000c	 bne         |$LN26@cppiProces@2|

; 761  :         {
; 762  :             chanPtr->nISOHDQueued--;

  0017c	e594303c	 ldr         r3, [r4, #0x3C]

; 763  :             chanPtr->nISOHDLastIndex = hdPtr->Index;
; 764  :             if (chanPtr->nISOHDLastIndex == chanPtr->nISOHDPerTransfer)

  00180	e5942034	 ldr         r2, [r4, #0x34]
  00184	e2433001	 sub         r3, r3, #1
  00188	e584303c	 str         r3, [r4, #0x3C]
  0018c	e5963034	 ldr         r3, [r6, #0x34]
  00190	e1530002	 cmp         r3, r2
  00194	e5843040	 str         r3, [r4, #0x40]

; 765  : 			{
; 766  :                 chanPtr->nISOHDLastIndex = 0;

  00198	03a03000	 moveq       r3, #0
  0019c	05843040	 streq       r3, [r4, #0x40]

; 767  : 			}
; 768  : 
; 769  :             // Make callback when we see the required HD
; 770  :             if (hdPtr->Index == chanPtr->nISOHDForCallback)

  001a0	e5962034	 ldr         r2, [r6, #0x34]
  001a4	e5943038	 ldr         r3, [r4, #0x38]
  001a8	e1520003	 cmp         r2, r3
  001ac	1a000002	 bne         |$done$47008|
  001b0		 |$LN26@cppiProces@2|

; 771  :             {
; 772  :                 PRINTMSG(ZONE_PDD_ISO,
; 773  :                   (L"cppiProcessCompletedPacket: %s Ch %u (EP %u), ISO HD index %d, total %d, actualLen %d, callback\r\n",
; 774  :                    chanDir, chanNum, epNum, hdPtr->Index, chanPtr->nISOHDPerTransfer, chanPtr->actualLen));
; 775  : 
; 776  :                 chanPtr->Channel.bStatus = MGC_DMA_STATUS_FREE;

  001b0	e3a03001	 mov         r3, #1

; 777  :                 pfnDmaCompleted = chanPtr->pfnDmaCompleted;

  001b4	e5949044	 ldr         r9, [r4, #0x44]
  001b8	e5843004	 str         r3, [r4, #4]
  001bc		 |$done$47008|

; 778  :             }
; 779  :         }
; 780  :     }
; 781  : 
; 782  : done:
; 783  :     cppiHdFree(f_CppiObj, hdPtr);

  001bc	e59f3034	 ldr         r3, [pc, #0x34]
  001c0	e1a01006	 mov         r1, r6
  001c4	e5930000	 ldr         r0, [r3]
  001c8	eb000000	 bl          cppiHdFree

; 784  :     UNLOCK_ENDPOINT(pPdd);

  001cc	e2880e27	 add         r0, r8, #0x27, 28
  001d0	eb000000	 bl          LeaveCriticalSection

; 785  : 
; 786  :     // Invoke DMA Completion Handler
; 787  :     if (pfnDmaCompleted != NULL)

  001d4	e3590000	 cmp         r9, #0

; 788  : 	{
; 789  :         pfnDmaCompleted(pPdd, chanNum, epNum);

  001d8	120b20ff	 andne       r2, r11, #0xFF
  001dc	11a0100a	 movne       r1, r10
  001e0	11a00008	 movne       r0, r8
  001e4	11a0e00f	 movne       lr, pc
  001e8	112fff19	 bxne        r9
  001ec		 |$LN1@cppiProces@2|

; 790  : 	}
; 791  : 
; 792  :     PRINTMSG(/*ZONE_PDD_DMA*/0, (L"-cppiProcessCompletedPacket\r\n"));
; 793  : }

  001ec	e28dd008	 add         sp, sp, #8
  001f0	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001f4	e12fff1e	 bx          lr
  001f8		 |$LN31@cppiProces@2|
  001f8		 |$LN32@cppiProces@2|
  001f8	00000000	 DCD         |f_CppiObj|
  001fc		 |$LN33@cppiProces@2|
  001fc	00000000	 DCD         |??_C@_15BMCNAON@?$AAR?$AAX?$AA?$AA@|
  00200		 |$LN34@cppiProces@2|
  00200	00000000	 DCD         |??_C@_1IM@POBJEFAI@?$AAc?$AAp?$AAp?$AAi?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AAd?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAC@|
  00204		 |$LN35@cppiProces@2|
  00204	00000000	 DCD         |??_C@_1HE@IBPFHKOH@?$AAc?$AAp?$AAp?$AAi?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AAd?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAC@|
  00208		 |$LN36@cppiProces@2|
  00208	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  0020c		 |$LN37@cppiProces@2|
  0020c	00000000	 DCD         |??_C@_1JM@MEFHOMOC@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  00210		 |$LN38@cppiProces@2|
  00210	00000000	 DCD         |??_C@_1HC@CEGIGIGI@?$AA?9?$AAc?$AAp?$AAp?$AAi?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AAd?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5@|
  00214		 |$LN39@cppiProces@2|
  00214	00000000	 DCD         |??_C@_15NHJLDDPA@?$AAT?$AAX?$AA?$AA@|
  00218		 |$M47800|

			 ENDP  ; |cppiProcessCompletedPacket|


  00000			 AREA	 |.pdata|, PDATA
|$T47825| DCD	|$LN15@cppiContro@3|
	DCD	0x40001301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiControllerStop| PROC

; 926  : {

  00000		 |$LN15@cppiContro@3|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M47822|
  00004	e1a04000	 mov         r4, r0

; 927  :     struct cppi *cppi = (struct cppi *)dmac;
; 928  :     unsigned n;
; 929  : 
; 930  :     PRINTMSG(ZONE_INIT,
; 931  :         (L"cppiControllerStop: Tearing down RX and TX Channels\r\n"));
; 932  : 
; 933  :     /* Traverse through each Tx/RX channel and abort any transfers */
; 934  : 
; 935  :     for (n = 0; n < dim(cppi->txCppi); n++)

  00008	e2845028	 add         r5, r4, #0x28
  0000c	e3a0600f	 mov         r6, #0xF
  00010		 |$LL6@cppiContro@3|

; 936  : 	{
; 937  :         cppiChannelAbort((struct dma_channel *)(cppi->txCppi + n));

  00010	e1a00005	 mov         r0, r5
  00014	eb000000	 bl          cppiChannelAbort
  00018	e2855048	 add         r5, r5, #0x48
  0001c	e2566001	 subs        r6, r6, #1
  00020	1afffffa	 bne         |$LL6@cppiContro@3|

; 938  : 	}
; 939  : 
; 940  :     for (n = 0; n < dim(cppi->rxCppi); n++)

  00024	e2844e46	 add         r4, r4, #0x46, 28
  00028	e3a0500f	 mov         r5, #0xF
  0002c		 |$LL3@cppiContro@3|

; 941  : 	{
; 942  :         cppiChannelAbort((struct dma_channel *)(cppi->rxCppi + n));

  0002c	e1a00004	 mov         r0, r4
  00030	eb000000	 bl          cppiChannelAbort
  00034	e2844048	 add         r4, r4, #0x48
  00038	e2555001	 subs        r5, r5, #1
  0003c	1afffffa	 bne         |$LL3@cppiContro@3|

; 943  : 	}
; 944  : 
; 945  :     return 0;

  00040	e3a00000	 mov         r0, #0

; 946  : }

  00044	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00048	e12fff1e	 bx          lr
  0004c		 |$M47823|

			 ENDP  ; |cppiControllerStop|

	EXPORT	|??_C@_1DI@EFPAMACA@?$AA?$CF?$AAs?$AAX?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AA?$CF?$AAu?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AAd?$AA?$CB?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EK@IMELJFPP@?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAa?$AAc?$AAt?$AAi?$AAv?$AAe?$AA?5?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?$DP?$AA?5?$AA?$CF?$AAs?$AAX?$AA?5?$AAD?$AAM?$AAA?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FC@CGPHAMLC@?$AA?$CF?$AAs?$AAX?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AA?$CF?$AAu?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAc?$AAl?$AAe?$AAa?$AAn?$AAe?$AAd?$AA?5?$AAu?$AAp?$AA?5?$AAa?$AAf?$AAt?$AAe?$AAr?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_13LPLPOHMK@?$AAR?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_13JKNELIBG@?$AAT?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T47848| DCD	|$LN22@cppiChanne@5|
	DCD	0x40004f01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DI@EFPAMACA@?$AA?$CF?$AAs?$AAX?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AA?$CF?$AAu?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AAd?$AA?$CB?$AA?$AN?$AA?6?$AA?$AA@| DCB "%"
	DCB	0x0, "s", 0x0, "X", 0x0, " ", 0x0, "D", 0x0, "M", 0x0, "A"
	DCB	0x0, " ", 0x0, "%", 0x0, "u", 0x0, " ", 0x0, "n", 0x0, "o"
	DCB	0x0, "t", 0x0, " ", 0x0, "a", 0x0, "l", 0x0, "l", 0x0, "o"
	DCB	0x0, "c", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, "d", 0x0, "!"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EK@IMELJFPP@?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAa?$AAc?$AAt?$AAi?$AAv?$AAe?$AA?5?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?$DP?$AA?5?$AA?$CF?$AAs?$AAX?$AA?5?$AAD?$AAM?$AAA?$AA?5@| DCB "p"
	DCB	0x0, "r", 0x0, "o", 0x0, "g", 0x0, "r", 0x0, "a", 0x0, "m"
	DCB	0x0, " ", 0x0, "a", 0x0, "c", 0x0, "t", 0x0, "i", 0x0, "v"
	DCB	0x0, "e", 0x0, " ", 0x0, "c", 0x0, "h", 0x0, "a", 0x0, "n"
	DCB	0x0, "n", 0x0, "e", 0x0, "l", 0x0, "?", 0x0, " ", 0x0, "%"
	DCB	0x0, "s", 0x0, "X", 0x0, " ", 0x0, "D", 0x0, "M", 0x0, "A"
	DCB	0x0, " ", 0x0, "%", 0x0, "u", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FC@CGPHAMLC@?$AA?$CF?$AAs?$AAX?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AA?$CF?$AAu?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAc?$AAl?$AAe?$AAa?$AAn?$AAe?$AAd?$AA?5?$AAu?$AAp?$AA?5?$AAa?$AAf?$AAt?$AAe?$AAr?$AA?5@| DCB "%"
	DCB	0x0, "s", 0x0, "X", 0x0, " ", 0x0, "D", 0x0, "M", 0x0, "A"
	DCB	0x0, " ", 0x0, "%", 0x0, "u", 0x0, " ", 0x0, "n", 0x0, "o"
	DCB	0x0, "t", 0x0, " ", 0x0, "c", 0x0, "l", 0x0, "e", 0x0, "a"
	DCB	0x0, "n", 0x0, "e", 0x0, "d", 0x0, " ", 0x0, "u", 0x0, "p"
	DCB	0x0, " ", 0x0, "a", 0x0, "f", 0x0, "t", 0x0, "e", 0x0, "r"
	DCB	0x0, " ", 0x0, "a", 0x0, "b", 0x0, "o", 0x0, "r", 0x0, "t"
	DCB	0x0, "!", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_13LPLPOHMK@?$AAR?$AA?$AA@| DCB "R", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_13JKNELIBG@?$AAT?$AA?$AA@| DCB "T", 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiChannelProgram| PROC

; 1148 : {

  00000		 |$LN22@cppiChanne@5|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M47845|
  00004	e1a08003	 mov         r8, r3
  00008	e1a09002	 mov         r9, r2
  0000c	e1a0a001	 mov         r10, r1
  00010	e1a07000	 mov         r7, r0

; 1149 :     struct cppi_channel *otgChannel = pChannel->pPrivateData;

  00014	e5974000	 ldr         r4, [r7]

; 1150 :     struct cppi *pController = otgChannel->pController;
; 1151 :     USBFNPDDCONTEXT *pPdd = pController->pPdd;

  00018	e594e008	 ldr         lr, [r4, #8]

; 1152 : 
; 1153 : #ifndef SHIP_BUILD
; 1154 :     BYTE chanNum = otgChannel->channelNo;

  0001c	e5d45018	 ldrb        r5, [r4, #0x18]
  00020	e59e6018	 ldr         r6, [lr, #0x18]

; 1155 : #endif
; 1156 : 
; 1157 :     PRINTMSG(/*ZONE_PDD_DMA*/0,
; 1158 :              (L"cppiChannelProgram: Ch %u, %s, len %d, pktsize %d, addr 0x%08x\r\n",
; 1159 :               chanNum, otgChannel->transmit ? L"TX" : L"RX",
; 1160 :               dwLength, packetSize, dmaAddr));
; 1161 : 
; 1162 :     LOCK_ENDPOINT(pPdd);

  00024	e2860e27	 add         r0, r6, #0x27, 28
  00028	eb000000	 bl          EnterCriticalSection

; 1163 : 
; 1164 :     switch (pChannel->bStatus)

  0002c	e597e004	 ldr         lr, [r7, #4]
  00030	e35e0000	 cmp         lr, #0
  00034	0a000014	 beq         |$LN6@cppiChanne@5|
  00038	e35e0002	 cmp         lr, #2
  0003c	0a00000a	 beq         |$LN7@cppiChanne@5|
  00040	e24ee003	 sub         lr, lr, #3
  00044	e35e0001	 cmp         lr, #1
  00048	8a000016	 bhi         |$LN9@cppiChanne@5|

; 1165 :     {
; 1166 :     case MGC_DMA_STATUS_BUS_ABORT:
; 1167 :     case MGC_DMA_STATUS_CORE_ABORT:
; 1168 :         /* fault irq handler should have handled cleanup */
; 1169 :         PRINTMSG (ZONE_WARNING,
; 1170 :                   (L"%sX DMA %u not cleaned up after abort!\r\n",
; 1171 :                    otgChannel->transmit ? L"T" : L"R",
; 1172 :                    chanNum));

  0004c	e594e014	 ldr         lr, [r4, #0x14]
  00050	e35e0000	 cmp         lr, #0
  00054	159f10d0	 ldrne       r1, [pc, #0xD0]
  00058	159f00d8	 ldrne       r0, [pc, #0xD8]
  0005c	1a00000f	 bne         |$LN19@cppiChanne@5|
  00060	e59f10c0	 ldr         r1, [pc, #0xC0]
  00064	e59f00cc	 ldr         r0, [pc, #0xCC]

; 1173 :         break;

  00068	ea00000c	 b           |$LN19@cppiChanne@5|
  0006c		 |$LN7@cppiChanne@5|

; 1174 :     case MGC_DMA_STATUS_BUSY:
; 1175 :         PRINTMSG (ZONE_WARNING,
; 1176 :                   (L"program active channel? %sX DMA %u\r\n",
; 1177 :                    otgChannel->transmit ? L"T" : L"R",
; 1178 :                    chanNum)) ;

  0006c	e5943014	 ldr         r3, [r4, #0x14]
  00070	e3530000	 cmp         r3, #0
  00074	159f10b0	 ldrne       r1, [pc, #0xB0]
  00078	159f00b4	 ldrne       r0, [pc, #0xB4]
  0007c	1a000007	 bne         |$LN19@cppiChanne@5|
  00080	e59f10a0	 ldr         r1, [pc, #0xA0]
  00084	e59f00a8	 ldr         r0, [pc, #0xA8]

; 1179 :         break;

  00088	ea000004	 b           |$LN19@cppiChanne@5|
  0008c		 |$LN6@cppiChanne@5|

; 1180 :     case MGC_DMA_STATUS_UNKNOWN:
; 1181 :         PRINTMSG (ZONE_ERROR,
; 1182 :                   (L"%sX DMA %u not allocated!\r\n",
; 1183 :                    otgChannel->transmit ? L"T" : L"R",
; 1184 :                    chanNum)) ;

  0008c	e5943014	 ldr         r3, [r4, #0x14]
  00090	e59f0098	 ldr         r0, [pc, #0x98]
  00094	e3530000	 cmp         r3, #0
  00098	159f108c	 ldrne       r1, [pc, #0x8C]
  0009c	059f1084	 ldreq       r1, [pc, #0x84]
  000a0		 |$LN19@cppiChanne@5|
  000a0	e1a02005	 mov         r2, r5
  000a4	eb000000	 bl          NKDbgPrintfW
  000a8		 |$LN9@cppiChanne@5|

; 1185 : 
; 1186 :     case MGC_DMA_STATUS_FREE:
; 1187 :         break;
; 1188 :     }
; 1189 : 
; 1190 :     /* A channel that has been torn down must be re-enabled before re-use
; 1191 :     */
; 1192 :     if (otgChannel->transmit)

  000a8	e5943014	 ldr         r3, [r4, #0x14]

; 1193 :     {
; 1194 :         if ((otgChannel->pRegs->TXGCR & BIT31) == 0) 

  000ac	e594200c	 ldr         r2, [r4, #0xC]
  000b0	e3530000	 cmp         r3, #0
  000b4	0a000006	 beq         |$LN4@cppiChanne@5|
  000b8	e5923000	 ldr         r3, [r2]
  000bc	e3130102	 tst         r3, #2, 2
  000c0	1a000007	 bne         |$LN1@cppiChanne@5|
  000c4	e3a03102	 mov         r3, #2, 2

; 1195 :         {
; 1196 :             otgChannel->pRegs->TXGCR =
; 1197 :                 BIT31 | /* Enable */ /*
; 1198 :                 qmgr |
; 1199 :                 qnum? */ USB_CPPI_TXCMPL_QNUM_FN;

  000c8	e3833040	 orr         r3, r3, #0x40
  000cc	e5823000	 str         r3, [r2]

; 1200 :         }
; 1201 :     }
; 1202 :     else

  000d0	ea000003	 b           |$LN1@cppiChanne@5|
  000d4		 |$LN4@cppiChanne@5|

; 1203 :     {
; 1204 :         if ((otgChannel->pRegs->RXGCR & BIT31) == 0) 

  000d4	e5923008	 ldr         r3, [r2, #8]
  000d8	e3130102	 tst         r3, #2, 2

; 1205 :         {
; 1206 :             otgChannel->pRegs->RXGCR =
; 1207 :                 BIT31 | /* Enable */
; 1208 :                 BIT24 | /* Retry on starvation */
; 1209 :                 BIT14 | /* Host descriptor type (default) */ /*
; 1210 :                 qmgr |
; 1211 :                 qnum? */ USB_CPPI_RXCMPL_QNUM_FN;

  000dc	059f3040	 ldreq       r3, [pc, #0x40]
  000e0	05823008	 streq       r3, [r2, #8]
  000e4		 |$LN1@cppiChanne@5|

; 1212 :         }
; 1213 :     }
; 1214 : 
; 1215 :     pChannel->bStatus = MGC_DMA_STATUS_BUSY;

  000e4	e3a03002	 mov         r3, #2
  000e8	e5873004	 str         r3, [r7, #4]

; 1216 : 
; 1217 :     /* set transfer parameters, then queue up its first segment */
; 1218 :     otgChannel->startAddr = dmaAddr;
; 1219 :     otgChannel->currOffset = 0;

  000ec	e3a03000	 mov         r3, #0

; 1220 :     otgChannel->pktSize = packetSize;
; 1221 :     otgChannel->actualLen = 0;
; 1222 :     otgChannel->transferSize = dwLength;
; 1223 : 
; 1224 :     cppiNextSegment(pPdd, otgChannel);

  000f0	e1a01004	 mov         r1, r4
  000f4	e1a00006	 mov         r0, r6
  000f8	e584302c	 str         r3, [r4, #0x2C]
  000fc	e5843030	 str         r3, [r4, #0x30]
  00100	e5849020	 str         r9, [r4, #0x20]
  00104	e584a028	 str         r10, [r4, #0x28]
  00108	e5848024	 str         r8, [r4, #0x24]
  0010c	eb000000	 bl          cppiNextSegment

; 1225 : 
; 1226 :     UNLOCK_ENDPOINT(pPdd);

  00110	e2860e27	 add         r0, r6, #0x27, 28
  00114	eb000000	 bl          LeaveCriticalSection

; 1227 : 
; 1228 :     return TRUE;

  00118	e3a00001	 mov         r0, #1

; 1229 : }

  0011c	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00120	e12fff1e	 bx          lr
  00124		 |$LN23@cppiChanne@5|
  00124		 |$LN24@cppiChanne@5|
  00124	81004042	 DCD         0x81004042
  00128		 |$LN25@cppiChanne@5|
  00128	00000000	 DCD         |??_C@_13LPLPOHMK@?$AAR?$AA?$AA@|
  0012c		 |$LN26@cppiChanne@5|
  0012c	00000000	 DCD         |??_C@_13JKNELIBG@?$AAT?$AA?$AA@|
  00130		 |$LN27@cppiChanne@5|
  00130	00000000	 DCD         |??_C@_1DI@EFPAMACA@?$AA?$CF?$AAs?$AAX?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AA?$CF?$AAu?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AAd?$AA?$CB?$AA?$AN?$AA?6?$AA?$AA@|
  00134		 |$LN28@cppiChanne@5|
  00134	00000000	 DCD         |??_C@_1EK@IMELJFPP@?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAa?$AAc?$AAt?$AAi?$AAv?$AAe?$AA?5?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?$DP?$AA?5?$AA?$CF?$AAs?$AAX?$AA?5?$AAD?$AAM?$AAA?$AA?5@|
  00138		 |$LN29@cppiChanne@5|
  00138	00000000	 DCD         |??_C@_1FC@CGPHAMLC@?$AA?$CF?$AAs?$AAX?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AA?$CF?$AAu?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAc?$AAl?$AAe?$AAa?$AAn?$AAe?$AAd?$AA?5?$AAu?$AAp?$AA?5?$AAa?$AAf?$AAt?$AAe?$AAr?$AA?5@|
  0013c		 |$M47846|

			 ENDP  ; |cppiChannelProgram|

	EXPORT	|??_C@_1DK@BKCENHLF@?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAd?$AAe?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AAo?$AAr?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CF?$AAu?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T47874| DCD	|$LN21@cppiProces@3|
	DCD	0x40003501

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DK@BKCENHLF@?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAd?$AAe?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AAo?$AAr?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CF?$AAu?$AA?$AN?$AA?6?$AA?$AA@| DCB "U"
	DCB	0x0, "n", 0x0, "k", 0x0, "n", 0x0, "o", 0x0, "w", 0x0, "n"
	DCB	0x0, " ", 0x0, "d", 0x0, "e", 0x0, "s", 0x0, "c", 0x0, "r"
	DCB	0x0, "i", 0x0, "p", 0x0, "t", 0x0, "o", 0x0, "r", 0x0, " "
	DCB	0x0, "t", 0x0, "y", 0x0, "p", 0x0, "e", 0x0, " ", 0x0, "%"
	DCB	0x0, "u", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiProcessCompletionEvent| PROC

; 591  : {

  00000		 |$LN21@cppiProces@3|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M47871|
  00004	e1b0e000	 movs        lr, r0

; 592  :     UINT32 type;
; 593  : 
; 594  :     DEBUGCHK(pPdd != NULL);
; 595  :     if (pPdd == NULL)

  00008	0a00002b	 beq         |$LN8@cppiProces@3|

; 596  : 	{
; 597  :         return;
; 598  : 	}
; 599  : 
; 600  :     DEBUGCHK(ptr != NULL);
; 601  :     if (ptr == NULL)

  0000c	e3510000	 cmp         r1, #0
  00010	0a000029	 beq         |$LN8@cppiProces@3|

; 602  : 	{
; 603  :         return;
; 604  : 	}
; 605  : 
; 606  :     type = (*(UINT32*)ptr & USB_CPPI41_DESC_TYPE_MASK) >> USB_CPPI41_DESC_TYPE_SHIFT;

  00014	e5913000	 ldr         r3, [r1]
  00018	e1a04da3	 mov         r4, r3, lsr #27

; 607  :   
; 608  : 	switch (type)

  0001c	e3540010	 cmp         r4, #0x10
  00020	0a000019	 beq         |$LN7@cppiProces@3|
  00024	e3540013	 cmp         r4, #0x13
  00028	0a000009	 beq         |$LN4@cppiProces@3|

; 647  :             break;
; 648  :         }
; 649  : 
; 650  :     default:
; 651  :         ERRORMSG(TRUE, (L"Unknown descriptor type %u\r\n", type));

  0002c	e59f109c	 ldr         r1, [pc, #0x9C]
  00030	e59f0094	 ldr         r0, [pc, #0x94]
  00034	e3a03c02	 mov         r3, #2, 24
  00038	e383208b	 orr         r2, r3, #0x8B
  0003c	eb000000	 bl          NKDbgPrintfW
  00040	e59f0080	 ldr         r0, [pc, #0x80]
  00044	e1a01004	 mov         r1, r4
  00048	eb000000	 bl          NKDbgPrintfW

; 652  :     }
; 653  : }

  0004c	e8bd4010	 ldmia       sp!, {r4, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$LN4@cppiProces@3|

; 627  :             break;
; 628  :         }
; 629  : 
; 630  :     case USB_CPPI41_DESC_TYPE_TEARDOWN: /* Teardown Descriptor */
; 631  :         {
; 632  :             TEARDOWN_DESCRIPTOR *tdPtr = (TEARDOWN_DESCRIPTOR *)ptr;
; 633  :             struct cppi *cppi = f_CppiObj;
; 634  :             struct cppi_channel *chanPtr = NULL;
; 635  :             BYTE chanNum  = (BYTE)((tdPtr->DescInfo & 0x0001f) >> 0);

  00054	e203001f	 and         r0, r3, #0x1F

; 636  :             BOOL transmit = (tdPtr->DescInfo & 0x10000) ? FALSE : TRUE;

  00058	e3130801	 tst         r3, #1, 16

; 637  :             if (transmit)
; 638  : 			{
; 639  :                 chanPtr = cppi->txCppi + (chanNum - cppi->chanOffset);

  0005c	e59f3060	 ldr         r3, [pc, #0x60]
  00060	e5932000	 ldr         r2, [r3]
  00064	e5d23024	 ldrb        r3, [r2, #0x24]
  00068	e0403003	 sub         r3, r0, r3
  0006c	e0833183	 add         r3, r3, r3, lsl #3
  00070	e0823183	 add         r3, r2, r3, lsl #3
  00074	02832028	 addeq       r2, r3, #0x28

; 640  : 			}
; 641  :             else
; 642  : 			{
; 643  :                 chanPtr = cppi->rxCppi + (chanNum - cppi->chanOffset);

  00078	12832e46	 addne       r2, r3, #0x46, 28

; 644  : 			}
; 645  : 
; 646  :             cppiProcessCompletedTeardown(pPdd, tdPtr, chanPtr);

  0007c	e1a0000e	 mov         r0, lr
  00080	eb000000	 bl          cppiProcessCompletedTeardown

; 652  :     }
; 653  : }

  00084	e8bd4010	 ldmia       sp!, {r4, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$LN7@cppiProces@3|

; 609  :     {
; 610  :     case USB_CPPI41_DESC_TYPE_HOST: /* Host Descriptor */
; 611  :         {
; 612  :             HOST_DESCRIPTOR *hdPtr = (HOST_DESCRIPTOR *)ptr;
; 613  :             struct cppi *cppi = f_CppiObj;
; 614  :             struct cppi_channel *chanPtr = NULL;
; 615  :             BYTE chanNum  = (BYTE)((hdPtr->TagInfo2 & 0x1f0) >> 4);

  0008c	e5912030	 ldr         r2, [r1, #0x30]
  00090	e1a03b82	 mov         r3, r2, lsl #23
  00094	e1a00da3	 mov         r0, r3, lsr #27

; 616  :             BOOL transmit = (hdPtr->TagInfo2 & 0x200) ? TRUE : FALSE;
; 617  :             if (transmit)
; 618  : 			{
; 619  :                 chanPtr = cppi->txCppi + chanNum;

  00098	e59f3024	 ldr         r3, [pc, #0x24]
  0009c	e3120c02	 tst         r2, #2, 24
  000a0	e0802180	 add         r2, r0, r0, lsl #3
  000a4	e5933000	 ldr         r3, [r3]

; 620  : 			}
; 621  :             else
; 622  : 			{
; 623  :                 chanPtr = cppi->rxCppi + chanNum;
; 624  : 			}
; 625  : 
; 626  :             cppiProcessCompletedPacket(pPdd, hdPtr, chanPtr);

  000a8	e1a0000e	 mov         r0, lr
  000ac	e0833182	 add         r3, r3, r2, lsl #3
  000b0	12832028	 addne       r2, r3, #0x28
  000b4	02832e46	 addeq       r2, r3, #0x46, 28
  000b8	eb000000	 bl          cppiProcessCompletedPacket
  000bc		 |$LN8@cppiProces@3|

; 652  :     }
; 653  : }

  000bc	e8bd4010	 ldmia       sp!, {r4, lr}
  000c0	e12fff1e	 bx          lr
  000c4		 |$LN22@cppiProces@3|
  000c4		 |$LN23@cppiProces@3|
  000c4	00000000	 DCD         |f_CppiObj|
  000c8		 |$LN24@cppiProces@3|
  000c8	00000000	 DCD         |??_C@_1DK@BKCENHLF@?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAd?$AAe?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AAo?$AAr?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CF?$AAu?$AA?$AN?$AA?6?$AA?$AA@|
  000cc		 |$LN25@cppiProces@3|
  000cc	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  000d0		 |$LN26@cppiProces@3|
  000d0	00000000	 DCD         |??_C@_1JM@MEFHOMOC@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  000d4		 |$M47872|

			 ENDP  ; |cppiProcessCompletionEvent|

	EXPORT	|cppiCompletionCallback|

  00000			 AREA	 |.pdata|, PDATA
|$T47894| DCD	|$LN13@cppiComple|
	DCD	0x40002301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiCompletionCallback| PROC

; 548  : {

  00000		 |$LN13@cppiComple|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M47891|
  00004	e1b05000	 movs        r5, r0

; 549  :     CSL_CppiRegs *pCppiRegs = NULL;
; 550  :     UINT32 pending2			= 0;
; 551  : 
; 552  :     DEBUGCHK(pPdd != NULL);
; 553  :     if (pPdd == NULL)

  00008	0a00001d	 beq         |$LN4@cppiComple|

; 554  : 	{
; 555  :         return;
; 556  : 	}
; 557  : 
; 558  :     PRINTMSG(/*ZONE_PDD_DMA*/0, (L"+cppiCompletionCallback\r\n"));
; 559  : 
; 560  :     pCppiRegs = pPdd->pCppiRegs;

  0000c	e5956020	 ldr         r6, [r5, #0x20]

; 561  : 
; 562  :     while ((pending2 = pCppiRegs->PEND2) & USB_CPPI_PEND2_QMSK_FN)

  00010	e2867a03	 add         r7, r6, #3, 20
  00014	ea000017	 b           |$LN1@cppiComple|
  00018		 |$LL5@cppiComple|

; 563  :     {
; 564  :         if (pending2 & QUEUE_N_BITMASK(USB_CPPI_TXCMPL_QNUM_FN))

  00018	e3140001	 tst         r4, #1
  0001c	0a000005	 beq         |$LN3@cppiComple|

; 565  : 		{
; 566  :             void *ptr = cppiQueuePop(pCppiRegs, USB_CPPI_TXCMPL_QNUM_FN);

  00020	e3a01040	 mov         r1, #0x40
  00024	e1a00006	 mov         r0, r6
  00028	eb000000	 bl          cppiQueuePop
  0002c	e1a01000	 mov         r1, r0

; 567  :             cppiProcessCompletionEvent(pPdd, ptr);

  00030	e1a00005	 mov         r0, r5
  00034	eb000000	 bl          cppiProcessCompletionEvent
  00038		 |$LN3@cppiComple|

; 568  :         }
; 569  :         if (pending2 & QUEUE_N_BITMASK(USB_CPPI_RXCMPL_QNUM_FN)) 

  00038	e3140004	 tst         r4, #4
  0003c	0a000005	 beq         |$LN2@cppiComple|

; 570  : 		{
; 571  :             void *ptr = cppiQueuePop(pCppiRegs, USB_CPPI_RXCMPL_QNUM_FN);

  00040	e3a01042	 mov         r1, #0x42
  00044	e1a00006	 mov         r0, r6
  00048	eb000000	 bl          cppiQueuePop
  0004c	e1a01000	 mov         r1, r0

; 572  :             cppiProcessCompletionEvent(pPdd, ptr);

  00050	e1a00005	 mov         r0, r5
  00054	eb000000	 bl          cppiProcessCompletionEvent
  00058		 |$LN2@cppiComple|

; 573  :         }
; 574  :         if (pending2 & QUEUE_N_BITMASK(USB_CPPI_TDCMPL_QNUM)) 

  00058	e3140010	 tst         r4, #0x10
  0005c	0a000005	 beq         |$LN1@cppiComple|

; 575  : 		{
; 576  :             void *ptr = cppiQueuePop(pCppiRegs, USB_CPPI_TDCMPL_QNUM);

  00060	e3a01044	 mov         r1, #0x44
  00064	e1a00006	 mov         r0, r6
  00068	eb000000	 bl          cppiQueuePop
  0006c	e1a01000	 mov         r1, r0

; 577  :             cppiProcessCompletionEvent(pPdd, ptr);

  00070	e1a00005	 mov         r0, r5
  00074	eb000000	 bl          cppiProcessCompletionEvent
  00078		 |$LN1@cppiComple|
  00078	e5974098	 ldr         r4, [r7, #0x98]
  0007c	e3140015	 tst         r4, #0x15
  00080	1affffe4	 bne         |$LL5@cppiComple|
  00084		 |$LN4@cppiComple|

; 578  :         }
; 579  :     }
; 580  : 
; 581  :     PRINTMSG(/*ZONE_PDD_DMA*/0, (L"-cppiCompletionCallback\r\n"));
; 582  : }

  00084	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$M47892|

			 ENDP  ; |cppiCompletionCallback|

	EXPORT	|??_C@_1EK@LBAFAOJL@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?5?$AA?$CF?$AAu?$AA?5?$AAb?$AAy?$AAt@| [ DATA ] ; `string'
	IMPORT	|USBCDMA_RegisterUsbModule|
	IMPORT	|InitializeCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T47910| DCD	|$LN12@cppiPoolIn|
	DCD	0x40003c02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EK@LBAFAOJL@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?5?$AA?$CF?$AAu?$AA?5?$AAb?$AAy?$AAt@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "F", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "a", 0x0, "l"
	DCB	0x0, "l", 0x0, "o", 0x0, "c", 0x0, "a", 0x0, "t", 0x0, "e"
	DCB	0x0, " ", 0x0, "%", 0x0, "u", 0x0, " ", 0x0, "b", 0x0, "y"
	DCB	0x0, "t", 0x0, "e", 0x0, "s", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiPoolInit| PROC

; 166  : {

  00000		 |$LN12@cppiPoolIn|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M47907|
  00008	e1b06000	 movs        r6, r0

; 167  :     unsigned descriptorCount;
; 168  : 
; 169  :     DEBUGCHK(cppi != NULL);
; 170  :     if (cppi == NULL)
; 171  : 	{
; 172  :         return FALSE;

  0000c	0a00002f	 beq         |$LN7@cppiPoolIn|

; 173  : 	}
; 174  : 
; 175  :     /* Only initialise once */
; 176  :     if (cppi->pool != NULL)

  00010	e5963898	 ldr         r3, [r6, #0x898]
  00014	e3530000	 cmp         r3, #0

; 177  : 	{
; 178  :         return TRUE;

  00018	1a00002a	 bne         |$LN9@cppiPoolIn|

; 179  : 	}
; 180  : 
; 181  :     descriptorCount = cppi->pPdd->descriptorCount;
; 182  : 
; 183  :     DEBUGMSG(ZONE_INIT,
; 184  :         (L"+cppiPoolInit: %u HDs\r\n",
; 185  :         descriptorCount));
; 186  : 
; 187  :     InitializeCriticalSection(&cppi->poolLock);

  0001c	e5963018	 ldr         r3, [r6, #0x18]
  00020	e2865b02	 add         r5, r6, #2, 22
  00024	e28500b8	 add         r0, r5, #0xB8
  00028	e5934660	 ldr         r4, [r3, #0x660]
  0002c	eb000000	 bl          InitializeCriticalSection

; 188  : 
; 189  :     LOCK_HD_POOL(cppi);

  00030	e28500b8	 add         r0, r5, #0xB8
  00034	eb000000	 bl          EnterCriticalSection

; 190  : 
; 191  :     cppi->hUsbCdma = USBCDMA_RegisterUsbModule(
; 192  :         (UINT16)descriptorCount,
; 193  :         CPPI_HD_SIZE,
; 194  :         &cppi->paPool,
; 195  :         &cppi->pool,
; 196  :         cppiCompletionCallback,
; 197  :         cppi->pPdd);

  00038	e5963018	 ldr         r3, [r6, #0x18]
  0003c	e59f20a8	 ldr         r2, [pc, #0xA8]
  00040	e2861b02	 add         r1, r6, #2, 22
  00044	e58d3004	 str         r3, [sp, #4]
  00048	e1a00804	 mov         r0, r4, lsl #16
  0004c	e2813098	 add         r3, r1, #0x98
  00050	e58d2000	 str         r2, [sp]
  00054	e3a01040	 mov         r1, #0x40
  00058	e2862e8a	 add         r2, r6, #0x8A, 28
  0005c	e1a00820	 mov         r0, r0, lsr #16
  00060	eb000000	 bl          USBCDMA_RegisterUsbModule
  00064	e1a03000	 mov         r3, r0

; 198  : 
; 199  :     cppi->poolMaxSize = descriptorCount * CPPI_HD_SIZE;
; 200  :     cppi->poolUsed = 0;
; 201  :     cppi->poolFree = cppi->poolMaxSize;
; 202  :     cppi->poolHead = NULL;
; 203  : 
; 204  :     UNLOCK_HD_POOL(cppi);

  00068	e5863020	 str         r3, [r6, #0x20]
  0006c	e3a03000	 mov         r3, #0
  00070	e1a02304	 mov         r2, r4, lsl #6
  00074	e28500b8	 add         r0, r5, #0xB8
  00078	e58638ac	 str         r3, [r6, #0x8AC]
  0007c	e58638b4	 str         r3, [r6, #0x8B4]
  00080	e58628a8	 str         r2, [r6, #0x8A8]
  00084	e58628b0	 str         r2, [r6, #0x8B0]
  00088	eb000000	 bl          LeaveCriticalSection

; 205  : 
; 206  :     ERRORMSG(cppi->pool == NULL,
; 207  :         (L"ERROR: Failed to allocate %u bytes\r\n",
; 208  :         cppi->poolMaxSize));

  0008c	e5963898	 ldr         r3, [r6, #0x898]
  00090	e3530000	 cmp         r3, #0
  00094	1a000006	 bne         |$LN5@cppiPoolIn|
  00098	e59f1048	 ldr         r1, [pc, #0x48]
  0009c	e59f0040	 ldr         r0, [pc, #0x40]
  000a0	e3a020d0	 mov         r2, #0xD0
  000a4	eb000000	 bl          NKDbgPrintfW
  000a8	e59618a8	 ldr         r1, [r6, #0x8A8]
  000ac	e59f002c	 ldr         r0, [pc, #0x2C]
  000b0	eb000000	 bl          NKDbgPrintfW
  000b4		 |$LN5@cppiPoolIn|

; 209  : 
; 210  :     DEBUGMSG(ZONE_INIT,
; 211  :         (L"-cppiPoolInit: %s - Allocated space for %u HDs\r\n",
; 212  :         (cppi->pool != NULL) ?
; 213  :             L"SUCCEEDED" :
; 214  :             L"FALIED",
; 215  :         descriptorCount));
; 216  : 
; 217  :     cppiHdPoolInit(cppi);

  000b4	e1a00006	 mov         r0, r6
  000b8	eb000000	 bl          cppiHdPoolInit

; 218  : 
; 219  :     return (cppi->pool != NULL);

  000bc	e5963898	 ldr         r3, [r6, #0x898]
  000c0	e3530000	 cmp         r3, #0
  000c4	0a000001	 beq         |$LN7@cppiPoolIn|
  000c8		 |$LN9@cppiPoolIn|
  000c8	e3a00001	 mov         r0, #1
  000cc	ea000000	 b           |$LN8@cppiPoolIn|
  000d0		 |$LN7@cppiPoolIn|
  000d0	e3a00000	 mov         r0, #0
  000d4		 |$LN8@cppiPoolIn|

; 220  : }

  000d4	e28dd008	 add         sp, sp, #8
  000d8	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000dc	e12fff1e	 bx          lr
  000e0		 |$LN13@cppiPoolIn|
  000e0		 |$LN14@cppiPoolIn|
  000e0	00000000	 DCD         |??_C@_1EK@LBAFAOJL@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?5?$AA?$CF?$AAu?$AA?5?$AAb?$AAy?$AAt@|
  000e4		 |$LN15@cppiPoolIn|
  000e4	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  000e8		 |$LN16@cppiPoolIn|
  000e8	00000000	 DCD         |??_C@_1JM@MEFHOMOC@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  000ec		 |$LN17@cppiPoolIn|
  000ec	00000000	 DCD         |cppiCompletionCallback|
  000f0		 |$M47908|

			 ENDP  ; |cppiPoolInit|

	EXPORT	|cppiControllerInit|
	EXPORT	|??_C@_1FG@INIICNMB@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AA?5?$AAC?$AAP?$AAP?$AAI?$AA?5?$AAD?$AAM?$AAA?$AA?5@| [ DATA ] ; `string'
	IMPORT	|LocalAlloc|

  00000			 AREA	 |.pdata|, PDATA
|$T47926| DCD	|$LN7@cppiContro@4|
	DCD	0x40003e01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FG@INIICNMB@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AA?5?$AAC?$AAP?$AAP?$AAI?$AA?5?$AAD?$AAM?$AAA?$AA?5@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "U", 0x0, "n", 0x0, "a", 0x0, "b", 0x0, "l", 0x0, "e"
	DCB	0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "A", 0x0, "l"
	DCB	0x0, "l", 0x0, "o", 0x0, "c", 0x0, " ", 0x0, "C", 0x0, "P"
	DCB	0x0, "P", 0x0, "I", 0x0, " ", 0x0, "D", 0x0, "M", 0x0, "A"
	DCB	0x0, " ", 0x0, "O", 0x0, "b", 0x0, "j", 0x0, "e", 0x0, "c"
	DCB	0x0, "t", 0x0, "!", 0x0, "!", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cppiControllerInit| PROC

; 1815 : {

  00000		 |$LN7@cppiContro@4|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M47923|
  00004	e1a08000	 mov         r8, r0

; 1816 :     struct cppi *cppi;
; 1817 : 
; 1818 :     if (f_CppiObj != NULL)

  00008	e59f40e4	 ldr         r4, [pc, #0xE4]
  0000c	e5947000	 ldr         r7, [r4]
  00010	e3570000	 cmp         r7, #0

; 1819 :     {
; 1820 :         return (&f_CppiObj->controller);

  00014	1a00002a	 bne         |$LN3@cppiContro@4|

; 1821 :     }
; 1822 : 
; 1823 :     if (NULL == (f_CppiObj = (struct cppi *)
; 1824 :                  LocalAlloc(LPTR, sizeof(struct cppi))))

  00018	e3a01e8d	 mov         r1, #0x8D, 28
  0001c	e3a00040	 mov         r0, #0x40
  00020	eb000000	 bl          LocalAlloc
  00024	e1b07000	 movs        r7, r0
  00028	e5847000	 str         r7, [r4]
  0002c	1a000008	 bne         |$LN1@cppiContro@4|

; 1825 :     {
; 1826 :         ERRORMSG(TRUE, (TEXT("ERROR: Unable to Alloc CPPI DMA Object!!\r\n")));

  00030	e59f10b8	 ldr         r1, [pc, #0xB8]
  00034	e59f00b0	 ldr         r0, [pc, #0xB0]
  00038	e3a03c07	 mov         r3, #7, 24
  0003c	e3832022	 orr         r2, r3, #0x22
  00040	eb000000	 bl          NKDbgPrintfW
  00044	e59f009c	 ldr         r0, [pc, #0x9C]
  00048	eb000000	 bl          NKDbgPrintfW

; 1827 :         return NULL;

  0004c	e3a07000	 mov         r7, #0
  00050	ea00001b	 b           |$LN3@cppiContro@4|
  00054		 |$LN1@cppiContro@4|

; 1828 :     }
; 1829 : 
; 1830 :     cppi = f_CppiObj;
; 1831 : 
; 1832 :     // Initialize the Cppi DmaController structure
; 1833 :     cppi->pPdd = pPdd;
; 1834 :     cppi->pRegs = pPdd->pCppiRegs;
; 1835 :     cppi->hUsbCdma = NULL;
; 1836 : 
; 1837 :     cppi->chanOffset = 0;
; 1838 :     cppi->rxqOffset = USB_CPPI_RX_QNUM;
; 1839 :     cppi->txqOffset = USB_CPPI_TX_QNUM;
; 1840 : 
; 1841 :     cppi->controller.pfnStart = cppiControllerStart;

  00054	e59f2088	 ldr         r2, [pc, #0x88]

; 1842 :     cppi->controller.pfnStop  = cppiControllerStop;

  00058	e59f1080	 ldr         r1, [pc, #0x80]

; 1843 :     cppi->controller.pfnChannelAlloc = cppiChannelAllocate;

  0005c	e59fe078	 ldr         lr, [pc, #0x78]

; 1844 :     cppi->controller.pfnChannelRelease = cppiChannelRelease;

  00060	e59f4070	 ldr         r4, [pc, #0x70]

; 1845 :     cppi->controller.channelProgram = cppiChannelProgram;

  00064	e59f5068	 ldr         r5, [pc, #0x68]

; 1846 :     cppi->controller.pfnChannelAbort = cppiChannelAbort;

  00068	e59f6060	 ldr         r6, [pc, #0x60]
  0006c	e5878018	 str         r8, [r7, #0x18]
  00070	e5983020	 ldr         r3, [r8, #0x20]
  00074	e3a09020	 mov         r9, #0x20
  00078	e3a0a000	 mov         r10, #0

; 1847 : 
; 1848 :     cppiPoolInit(cppi);

  0007c	e1a00007	 mov         r0, r7
  00080	e287c01c	 add         r12, r7, #0x1C
  00084	e88c0408	 stmia       r12, {r3, r10}
  00088	e5c7a024	 strb        r10, [r7, #0x24]
  0008c	e5c7a025	 strb        r10, [r7, #0x25]
  00090	e5c79026	 strb        r9, [r7, #0x26]
  00094	e5872000	 str         r2, [r7]
  00098	e287c004	 add         r12, r7, #4
  0009c	e88c4002	 stmia       r12, {r1, lr}
  000a0	e287c00c	 add         r12, r7, #0xC
  000a4	e88c0070	 stmia       r12, {r4 - r6}
  000a8	eb000000	 bl          cppiPoolInit

; 1849 : 
; 1850 :     pPdd->pUsbdRegs->AUTOREQR = 0;

  000ac	e598301c	 ldr         r3, [r8, #0x1C]

; 1851 : 	pPdd->pUsbdRegs->TXMODE  = 0;
; 1852 : 	pPdd->pUsbdRegs->RXMODE  = 0;
; 1853 : 
; 1854 :     return &cppi->controller;

  000b0	e583a014	 str         r10, [r3, #0x14]
  000b4	e598301c	 ldr         r3, [r8, #0x1C]
  000b8	e583a070	 str         r10, [r3, #0x70]
  000bc	e598301c	 ldr         r3, [r8, #0x1C]
  000c0	e583a074	 str         r10, [r3, #0x74]
  000c4		 |$LN3@cppiContro@4|

; 1855 : }

  000c4	e1a00007	 mov         r0, r7
  000c8	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  000cc	e12fff1e	 bx          lr
  000d0		 |$LN8@cppiContro@4|
  000d0		 |$LN9@cppiContro@4|
  000d0	00000000	 DCD         |cppiChannelAbort|
  000d4		 |$LN10@cppiContro@4|
  000d4	00000000	 DCD         |cppiChannelProgram|
  000d8		 |$LN11@cppiContro@4|
  000d8	00000000	 DCD         |cppiChannelRelease|
  000dc		 |$LN12@cppiContro@4|
  000dc	00000000	 DCD         |cppiChannelAllocate|
  000e0		 |$LN13@cppiContro@4|
  000e0	00000000	 DCD         |cppiControllerStop|
  000e4		 |$LN14@cppiContro@4|
  000e4	00000000	 DCD         |cppiControllerStart|
  000e8		 |$LN15@cppiContro@4|
  000e8	00000000	 DCD         |??_C@_1FG@INIICNMB@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AA?5?$AAC?$AAP?$AAP?$AAI?$AA?5?$AAD?$AAM?$AAA?$AA?5@|
  000ec		 |$LN16@cppiContro@4|
  000ec	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  000f0		 |$LN17@cppiContro@4|
  000f0	00000000	 DCD         |??_C@_1JM@MEFHOMOC@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  000f4		 |$LN18@cppiContro@4|
  000f4	00000000	 DCD         |f_CppiObj|
  000f8		 |$M47924|

			 ENDP  ; |cppiControllerInit|

	END
