; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\AM3517\USB\USBFN\usbfnpdd.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1CE@NGHFOCHF@?$AAD?$AAi?$AAs?$AAa?$AAb?$AAl?$AAe?$AAR?$AAx?$AAG?$AAe?$AAn?$AAR?$AAN?$AAD?$AAI?$AAS?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CA@FLLDNPDG@?$AAD?$AAe?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AAo?$AAr?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CO@GMFDDKFG@?$AAD?$AAi?$AAs?$AAa?$AAb?$AAl?$AAe?$AAP?$AAo?$AAw?$AAe?$AAr?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_00CNPNBAHC@?$AA@| [ DATA ]	; `string'
	EXPORT	|??_C@_1BM@IOLIHJIC@?$AAA?$AAc?$AAt?$AAi?$AAv?$AAi?$AAt?$AAy?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BM@OGFPDABJ@?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_17DJGGJCGD@?$AAI?$AAr?$AAq?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CE@NGHFOCHF@?$AAD?$AAi?$AAs?$AAa?$AAb?$AAl?$AAe?$AAR?$AAx?$AAG?$AAe?$AAn?$AAR?$AAN?$AAD?$AAI?$AAS?$AA?$AA@| DCB "D"
	DCB	0x0, "i", 0x0, "s", 0x0, "a", 0x0, "b", 0x0, "l", 0x0, "e"
	DCB	0x0, "R", 0x0, "x", 0x0, "G", 0x0, "e", 0x0, "n", 0x0, "R"
	DCB	0x0, "N", 0x0, "D", 0x0, "I", 0x0, "S", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CA@FLLDNPDG@?$AAD?$AAe?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AAo?$AAr?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@| DCB "D"
	DCB	0x0, "e", 0x0, "s", 0x0, "c", 0x0, "r", 0x0, "i", 0x0, "p"
	DCB	0x0, "t", 0x0, "o", 0x0, "r", 0x0, "C", 0x0, "o", 0x0, "u"
	DCB	0x0, "n", 0x0, "t", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CO@GMFDDKFG@?$AAD?$AAi?$AAs?$AAa?$AAb?$AAl?$AAe?$AAP?$AAo?$AAw?$AAe?$AAr?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?$AA@| DCB "D"
	DCB	0x0, "i", 0x0, "s", 0x0, "a", 0x0, "b", 0x0, "l", 0x0, "e"
	DCB	0x0, "P", 0x0, "o", 0x0, "w", 0x0, "e", 0x0, "r", 0x0, "M"
	DCB	0x0, "a", 0x0, "n", 0x0, "a", 0x0, "g", 0x0, "e", 0x0, "m"
	DCB	0x0, "e", 0x0, "n", 0x0, "t", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_00CNPNBAHC@?$AA@| DCB 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BM@IOLIHJIC@?$AAA?$AAc?$AAt?$AAi?$AAv?$AAi?$AAt?$AAy?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$AA@| DCB "A"
	DCB	0x0, "c", 0x0, "t", 0x0, "i", 0x0, "v", 0x0, "i", 0x0, "t"
	DCB	0x0, "y", 0x0, "E", 0x0, "v", 0x0, "e", 0x0, "n", 0x0, "t"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BM@OGFPDABJ@?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?$AA@| DCB "D"
	DCB	0x0, "m", 0x0, "a", 0x0, "B", 0x0, "u", 0x0, "f", 0x0, "f"
	DCB	0x0, "e", 0x0, "r", 0x0, "S", 0x0, "i", 0x0, "z", 0x0, "e"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@| DCB "P"
	DCB	0x0, "r", 0x0, "i", 0x0, "o", 0x0, "r", 0x0, "i", 0x0, "t"
	DCB	0x0, "y", 0x0, "2", 0x0, "5", 0x0, "6", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_17DJGGJCGD@?$AAI?$AAr?$AAq?$AA?$AA@| DCB "I", 0x0, "r", 0x0, "q", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
|f_DeviceRegParams| DCD |??_C@_17DJGGJCGD@?$AAI?$AAr?$AAq?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x0
	DCD	0x4
	DCD	0x47
	DCD	|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x4
	DCD	0x4
	DCD	0x65
	DCD	|??_C@_1BM@OGFPDABJ@?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x8
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BM@IOLIHJIC@?$AAA?$AAc?$AAt?$AAi?$AAv?$AAi?$AAt?$AAy?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$AA@|
	DCD	0x2
	DCD	0x0
	DCD	0x4c
	DCD	0x208
	DCD	|??_C@_00CNPNBAHC@?$AA@|
	DCD	|??_C@_1CO@GMFDDKFG@?$AAD?$AAi?$AAs?$AAa?$AAb?$AAl?$AAe?$AAP?$AAo?$AAw?$AAe?$AAr?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0xc
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1CA@FLLDNPDG@?$AAD?$AAe?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AAo?$AAr?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x660
	DCD	0x4
	DCD	0x200
	DCD	|??_C@_1CE@NGHFOCHF@?$AAD?$AAi?$AAs?$AAa?$AAb?$AAl?$AAe?$AAR?$AAx?$AAG?$AAe?$AAn?$AAR?$AAN?$AAD?$AAI?$AAS?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x664
	DCD	0x4
	DCD	0x0
	EXPORT	|SetEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T48442| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M48439|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M48440|

			 ENDP  ; |SetEvent|

	EXPORT	|ReadFIFO|
; File c:\wince600\platform\common\src\soc\common_ti_v1\am3517\usb\usbfn\usbfnpdd.c

  00000			 AREA	 |.pdata|, PDATA
|$T48466| DCD	|$LN16@ReadFIFO|
	DCD	0x40001501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ReadFIFO| PROC

; 191  : {

  00000		 |$LN16@ReadFIFO|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M48463|

; 192  :     DWORD total   = size / 4;
; 193  :     DWORD remain  = size % 4;
; 194  :     DWORD i		  = 0;
; 195  :     DWORD* pDword = (DWORD*)pData;
; 196  : 
; 197  :     CSL_UsbRegs* pUsbdRegs = pPdd->pUsbdRegs;
; 198  :     volatile ULONG *pReg = (volatile ULONG*)(&pUsbdRegs->FIFO[endpoint]);

  00004	e590001c	 ldr         r0, [r0, #0x1C]
  00008	e2811f42	 add         r1, r1, #0x42, 30
  0000c	e1b0e123	 movs        lr, r3, lsr #2
  00010	e0800101	 add         r0, r0, r1, lsl #2
  00014	e2031003	 and         r1, r3, #3

; 199  : 
; 200  :     // Critical section would be handled outside
; 201  :     DEBUGMSG(ZONE_PDD_RX, (TEXT("ReadFIFO EP(%d): pData(0x%x) total (0x%x), remain (0x%x), size(0x%x)\r\n"), endpoint, pData, total, remain, size));
; 202  : 
; 203  :     // this is 32-bit align
; 204  :     for (i = 0; i < total; i++)

  00018	0a000003	 beq         |$LN4@ReadFIFO|
  0001c		 |$LL6@ReadFIFO|

; 205  :     {
; 206  :         *pDword++ = INREG32(pReg);

  0001c	e5903000	 ldr         r3, [r0]
  00020	e25ee001	 subs        lr, lr, #1
  00024	e4823004	 str         r3, [r2], #4
  00028	1afffffb	 bne         |$LL6@ReadFIFO|
  0002c		 |$LN4@ReadFIFO|

; 207  :     }
; 208  :         
; 209  :     // Set the pByte equal to the last bytes of data being transferred
; 210  :     if (remain != 0)

  0002c	e3510000	 cmp         r1, #0
  00030	0a000004	 beq         |$LN12@ReadFIFO|

; 211  :     {
; 212  :         UCHAR* pUCHAR = (UCHAR*) pDword;
; 213  :         DWORD dwTemp = INREG32(pReg);

  00034	e5903000	 ldr         r3, [r0]
  00038		 |$LL2@ReadFIFO|

; 214  :         
; 215  :         while (remain--)
; 216  :         {
; 217  :             *pUCHAR++ = (UCHAR) (dwTemp & 0xFF);

  00038	e4c23001	 strb        r3, [r2], #1

; 218  :             dwTemp>>=8;

  0003c	e1a03423	 mov         r3, r3, lsr #8
  00040	e2511001	 subs        r1, r1, #1
  00044	1afffffb	 bne         |$LL2@ReadFIFO|
  00048		 |$LN12@ReadFIFO|

; 219  :         }
; 220  :     }
; 221  : 
; 222  : #if 0
; 223  :     RETAILMSG(1,(TEXT("Read fifo\r\n")));
; 224  :     memdump((UCHAR*)pData,(USHORT)size,0);
; 225  :     RETAILMSG(1,(TEXT("\r\n")));
; 226  : #endif
; 227  : 
; 228  :     return TRUE;

  00048	e3a00001	 mov         r0, #1

; 229  : }

  0004c	e49de004	 ldr         lr, [sp], #4
  00050	e12fff1e	 bx          lr
  00054		 |$M48464|

			 ENDP  ; |ReadFIFO|

	EXPORT	|WriteFIFO|

  00000			 AREA	 |.pdata|, PDATA
|$T48486| DCD	|$LN13@WriteFIFO|
	DCD	0x40001601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |WriteFIFO| PROC

; 232  : {

  00000		 |$LN13@WriteFIFO|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M48483|

; 233  :     DWORD total					= size / 4;
; 234  :     DWORD remain				= size % 4;
; 235  :     DWORD i						= 0;
; 236  :     DWORD* pDword				= (DWORD*)pData;
; 237  :     CSL_UsbRegs* pUsbdRegs = pPdd->pUsbdRegs;
; 238  :     volatile ULONG *pReg = (volatile ULONG*)(&pUsbdRegs->FIFO[endpoint]);

  00004	e590001c	 ldr         r0, [r0, #0x1C]
  00008	e2811f42	 add         r1, r1, #0x42, 30
  0000c	e1b0e123	 movs        lr, r3, lsr #2
  00010	e0800101	 add         r0, r0, r1, lsl #2
  00014	e2031003	 and         r1, r3, #3

; 239  : 
; 240  :     // Critical section would be handled outside
; 241  :     DEBUGMSG(ZONE_PDD_TX, (TEXT("WriteFIFO: total (0x%x), remain (0x%x), size(0x%x)\r\n"), total, remain, size));    
; 242  : 
; 243  : #if 0
; 244  :     RETAILMSG(1,(TEXT("Write fifo\r\n")));
; 245  :     memdump((UCHAR*)pData,(USHORT)size,0);
; 246  :     RETAILMSG(1,(TEXT("\r\n")));
; 247  : #endif
; 248  : 
; 249  :     // this is 32-bit align
; 250  :     for (i = 0; i < total; i++)

  00018	0a000003	 beq         |$LN4@WriteFIFO|
  0001c		 |$LL6@WriteFIFO|

; 251  :     {
; 252  :         OUTREG32(pReg, *pDword++);

  0001c	e4923004	 ldr         r3, [r2], #4
  00020	e25ee001	 subs        lr, lr, #1
  00024	e5803000	 str         r3, [r0]
  00028	1afffffb	 bne         |$LL6@WriteFIFO|
  0002c		 |$LN4@WriteFIFO|

; 253  :     }
; 254  : 
; 255  :     // Set the pByte equal to the last bytes of data being transferred
; 256  :     if (remain != 0)

  0002c	e3510000	 cmp         r1, #0
  00030	0a000005	 beq         |$LN1@WriteFIFO|

; 257  :     {
; 258  :         // Pointer to the first byte of data
; 259  :         USHORT *pWORD =(USHORT *)pDword;
; 260  : 
; 261  :         // Finally if there is remain
; 262  :         if (remain & 0x2)  // either 2 or 3

  00034	e3110002	 tst         r1, #2

; 263  :         {
; 264  :             // Write 2 bytes to there
; 265  :             OUTREG16(pReg, *pWORD++);        

  00038	10d230b2	 ldrneh      r3, [r2], #2
  0003c	11c030b0	 strneh      r3, [r0]

; 266  :         }
; 267  : 
; 268  :         if (remain & 0x1)

  00040	e3110001	 tst         r1, #1

; 269  :         {
; 270  :             // Write 1 byte to there
; 271  :             OUTREG8(pReg, *((UCHAR*)pWORD));

  00044	15d23000	 ldrneb      r3, [r2]
  00048	15c03000	 strneb      r3, [r0]
  0004c		 |$LN1@WriteFIFO|

; 272  :         }
; 273  :     }
; 274  :     return TRUE;

  0004c	e3a00001	 mov         r0, #1

; 275  : }

  00050	e49de004	 ldr         lr, [sp], #4
  00054	e12fff1e	 bx          lr
  00058		 |$M48484|

			 ENDP  ; |WriteFIFO|

	EXPORT	|SetupUsbRequest|

  00000			 AREA	 |.pdata|, PDATA
|$T48499| DCD	|$LN7@SetupUsbRe|
	DCD	0x40001301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetupUsbRequest| PROC

; 300  : {

  00000		 |$LN7@SetupUsbRe|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M48496|
  00004	e1a0e002	 mov         lr, r2
  00008	e1a04001	 mov         r4, r1
  0000c	e1a05000	 mov         r5, r0

; 301  :     UINT16 pktCounter = requestSize;
; 302  :     PBYTE pUsbDevReq = (PBYTE)pUsbRequest;
; 303  : 
; 304  :     DEBUGCHK(epNumber == 0);
; 305  :     DEBUGCHK(requestSize == 8);
; 306  : 
; 307  :     // Read pktCounter bytes from the EndPoint FIFO
; 308  : 	ReadFIFO(pPdd, (UCHAR)epNumber, pUsbDevReq, pktCounter);

  00010	e1a02004	 mov         r2, r4
  00014	e20e10ff	 and         r1, lr, #0xFF
  00018	eb000000	 bl          ReadFIFO

; 309  : 
; 310  :     /* Save setup packet direction & size for later use */
; 311  :     pPdd->setupDirRx = (pUsbRequest->bmRequestType & 0x80) == 0;

  0001c	e5d43000	 ldrb        r3, [r4]

; 312  :     pPdd->setupCount = pUsbRequest->wLength;

  00020	e2852c02	 add         r2, r5, #2, 24
  00024	e3130080	 tst         r3, #0x80
  00028	03a03001	 moveq       r3, #1
  0002c	13a03000	 movne       r3, #0
  00030	e5853264	 str         r3, [r5, #0x264]
  00034	e5d41006	 ldrb        r1, [r4, #6]
  00038	e5d43007	 ldrb        r3, [r4, #7]
  0003c	e1813403	 orr         r3, r1, r3, lsl #8
  00040	e1c236b8	 strh        r3, [r2, #0x68]

; 313  : 
; 314  :     PRINTMSG(ZONE_PDD_EP0,
; 315  :         (L"SetupUsbRequest: Req 0x%02x T 0x%02x V 0x%02x I 0x%x L 0x%x\r\n",
; 316  :          pUsbRequest->bmRequestType,
; 317  :          pUsbRequest->bRequest,
; 318  :          pUsbRequest->wValue,
; 319  :          pUsbRequest->wIndex,
; 320  :          pUsbRequest->wLength));
; 321  : }

  00044	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00048	e12fff1e	 bx          lr
  0004c		 |$M48497|

			 ENDP  ; |SetupUsbRequest|

	IMPORT	|InterruptDone|
	IMPORT	|Sleep|
	IMPORT	|UsbPddEp0IntrHandler|
	IMPORT	|UsbPddTxRxIntrHandler|
	IMPORT	|HandleUsbCoreInterrupt|
	IMPORT	|cppiCompletionCallback|
	IMPORT	|USBPeripheralStart|
	IMPORT	|USBFNPDD_WaitForAPIsReady|
	IMPORT	|WaitForSingleObject|

  00000			 AREA	 |.pdata|, PDATA
|$T48523| DCD	|$LN29@InterruptT|
	DCD	0x40009001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |InterruptThread| PROC

; 341  : {

  00000		 |$LN29@InterruptT|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M48520|
  00004	e1a04000	 mov         r4, r0

; 342  :     USBFNPDDCONTEXT *pPdd = pPddContext;
; 343  :     CSL_UsbRegs *pUsbdRegs = pPdd->pUsbdRegs;
; 344  : 	OMAP_SYSC_GENERAL_REGS  *pSysConfRegs = pPdd->pSysConfRegs;
; 345  :     UINT32 usbCoreIntrRegVal;
; 346  :     UINT32 usbEpIntrRegVal;
; 347  :     UINT16 intrReg;
; 348  :     UINT16 intrRxReg;
; 349  :     UINT16 intrTxReg;
; 350  :     DWORD code;
; 351  :     DWORD speed;
; 352  : 
; 353  :     /* Wait for PDD start */
; 354  :     WaitForSingleObject(pPdd->hStartEvent, INFINITE);

  00008	e594026c	 ldr         r0, [r4, #0x26C]
  0000c	e594501c	 ldr         r5, [r4, #0x1C]
  00010	e594a028	 ldr         r10, [r4, #0x28]
  00014	e3e01000	 mvn         r1, #0
  00018	eb000000	 bl          WaitForSingleObject

; 355  : 
; 356  :     // Wait for API sets to become ready (function specific)
; 357  :     USBFNPDD_WaitForAPIsReady();

  0001c	eb000000	 bl          USBFNPDD_WaitForAPIsReady

; 358  : 
; 359  :     /* Release the controller.  This is done after PDD start so that USB packet
; 360  :        processing begins immediately.  If done earlier the host can timeout the
; 361  :        function device due to delays in responding (particularly in debug builds). */
; 362  :     USBPeripheralStart(pPdd);

  00020	e1a00004	 mov         r0, r4
  00024	eb000000	 bl          USBPeripheralStart

; 363  : 
; 364  :     while (pPdd->exitIntrThread == FALSE)

  00028	e5943034	 ldr         r3, [r4, #0x34]
  0002c	e3a0b000	 mov         r11, #0
  00030	e3530000	 cmp         r3, #0
  00034	1a000071	 bne         |$LN26@InterruptT|
  00038	e3a03cff	 mov         r3, #0xFF, 24
  0003c	e38390fe	 orr         r9, r3, #0xFE
  00040		 |$LL18@InterruptT|

; 365  :     {
; 366  :         PRINTMSG(ZONE_FUNCTION, (L"+InterruptThread\r\n"));
; 367  : 
; 368  :         /* Wait for interrupt */
; 369  :         code = WaitForSingleObject(pPdd->hIntrEvent, INFINITE);

  00040	e5940030	 ldr         r0, [r4, #0x30]
  00044	e3e01000	 mvn         r1, #0
  00048	eb000000	 bl          WaitForSingleObject

; 370  : 
; 371  :         /* Exit thread when we are asked so... */
; 372  :         if (pPdd->exitIntrThread == TRUE) break;

  0004c	e5943034	 ldr         r3, [r4, #0x34]
  00050	e3530001	 cmp         r3, #1
  00054	0a000069	 beq         |$LN26@InterruptT|

; 373  : 
; 374  : #if CPPI_DMA_SUPPORT
; 375  :         /* Handle DMA interrupts */
; 376  :         cppiCompletionCallback(pPdd);

  00058	e1a00004	 mov         r0, r4
  0005c	eb000000	 bl          cppiCompletionCallback

; 377  : #endif
; 378  : 
; 379  :         /* Check for the Initial USB RESET Interrupt Condition */
; 380  : 
; 381  :         /* Get interrupt source */
; 382  : 		usbCoreIntrRegVal = pUsbdRegs->CORE_INTMASKEDR;

  00060	e5953058	 ldr         r3, [r5, #0x58]

; 383  :         PRINTMSG(/*ZONE_FUNCTION*/ 0, (L"CORE_INTMASKEDR = 0x%x\r\n", usbCoreIntrRegVal));
; 384  : 		pUsbdRegs->CORE_INTCLRR = usbCoreIntrRegVal;

  00064	e5853048	 str         r3, [r5, #0x48]

; 385  : 
; 386  : 		usbEpIntrRegVal = pUsbdRegs->EP_INTMASKEDR;

  00068	e5958038	 ldr         r8, [r5, #0x38]

; 387  :         PRINTMSG(/*ZONE_FUNCTION*/ 0, (L"EP_INTMASKEDR = 0x%x\r\n", usbEpIntrRegVal));
; 388  : 		pUsbdRegs->EP_INTCLRR = usbEpIntrRegVal;
; 389  : 
; 390  : 		pSysConfRegs->CONTROL_LVL_INTR_CLEAR |= (1 << 4);
; 391  : 
; 392  :         intrRxReg = (UINT16)((usbEpIntrRegVal   & USB_OTG_RXINT_MASK)  >> USB_OTG_RXINT_SHIFT);
; 393  :         intrTxReg = (UINT16)((usbEpIntrRegVal   & USB_OTG_TXINT_MASK)  >> USB_OTG_TXINT_SHIFT);
; 394  :         intrReg   = (UINT16)((usbCoreIntrRegVal & USB_OTG_USBINT_MASK) >> USB_OTG_USBINT_SHIFT);

  0006c	e1a02383	 mov         r2, r3, lsl #7

; 395  : 
; 396  :         /* USB Core Interrupt Handling */
; 397  :         if (intrReg != 0)

  00070	e1b07ba2	 movs        r7, r2, lsr #23
  00074	e5858028	 str         r8, [r5, #0x28]
  00078	e59a3324	 ldr         r3, [r10, #0x324]
  0007c	e1a06808	 mov         r6, r8, lsl #16
  00080	e1a06826	 mov         r6, r6, lsr #16
  00084	e3833010	 orr         r3, r3, #0x10
  00088	e58a3324	 str         r3, [r10, #0x324]
  0008c	0a000037	 beq         |$LN10@InterruptT|

; 398  :         {
; 399  :             HandleUsbCoreInterrupt(pPdd, intrReg);

  00090	e1a01ba2	 mov         r1, r2, lsr #23
  00094	e1a00004	 mov         r0, r4
  00098	eb000000	 bl          HandleUsbCoreInterrupt

; 400  : 
; 401  :             /* Check for the RESET State and if so, inform the MDD
; 402  :              * if not done already
; 403  :              */
; 404  :             if ( ( ((intrReg & MGC_M_INTR_RESET)  != 0) ||
; 405  :                    ((intrReg & MGC_M_INTR_RESUME) != 0)) &&
; 406  :                  (pPdd->resetComplete == FALSE))

  0009c	e2172004	 ands        r2, r7, #4
  000a0	1a000001	 bne         |$LN13@InterruptT|
  000a4	e3170002	 tst         r7, #2
  000a8	0a000021	 beq         |$LN14@InterruptT|
  000ac		 |$LN13@InterruptT|
  000ac	e5943038	 ldr         r3, [r4, #0x38]
  000b0	e3530000	 cmp         r3, #0
  000b4	1a00001e	 bne         |$LN14@InterruptT|

; 407  :             {
; 408  :                 pPdd->resetComplete = TRUE;
; 409  :                 pPdd->ep[0].epStage = MGC_END0_START;
; 410  :                 pPdd->fWaitingForHandshake = FALSE;
; 411  :                 /*
; 412  :                  * OTG may not detect attach/detach events correctly
; 413  :                  * on some platforms. Simulate a attach/detach event
; 414  :                  * to clear any previous state on reset.
; 415  :                  */
; 416  :                 if (pPdd->attachState == UFN_DETACH)

  000b8	e594303c	 ldr         r3, [r4, #0x3C]
  000bc	e3a02001	 mov         r2, #1
  000c0	e5842038	 str         r2, [r4, #0x38]
  000c4	e3530000	 cmp         r3, #0
  000c8	e58422a0	 str         r2, [r4, #0x2A0]
  000cc	e584b64c	 str         r11, [r4, #0x64C]
  000d0	1a000010	 bne         |$LN12@InterruptT|

; 417  :                 {
; 418  :                     PRINTMSG(ZONE_PDD_INIT, (L">>> ATTACH >>>\r\n"));
; 419  :                     pPdd->pfnNotify (pPdd->pMddContext, UFN_MSG_BUS_EVENTS,
; 420  :                                      UFN_ATTACH);

  000d4	e5940010	 ldr         r0, [r4, #0x10]
  000d8	e5943014	 ldr         r3, [r4, #0x14]
  000dc	e3a02001	 mov         r2, #1
  000e0	e3a01001	 mov         r1, #1
  000e4	e1a0e00f	 mov         lr, pc
  000e8	e12fff13	 bx          r3

; 421  :                     speed = (pUsbdRegs->POWER & CSL_USB_POWER_HSMODE_MASK) ? BS_HIGH_SPEED : BS_FULL_SPEED;

  000ec	e5d53401	 ldrb        r3, [r5, #0x401]

; 422  :                     PRINTMSG(ZONE_PDD_INIT, (L"Bus Speed: %s\r\n",
; 423  :                                              speed == BS_HIGH_SPEED ? L"HIGH" : L"FULL"));
; 424  :                     pPdd->pfnNotify (pPdd->pMddContext, UFN_MSG_BUS_SPEED, speed);

  000f0	e5940010	 ldr         r0, [r4, #0x10]
  000f4	e3a01003	 mov         r1, #3
  000f8	e3130010	 tst         r3, #0x10
  000fc	e5943014	 ldr         r3, [r4, #0x14]
  00100	13a02002	 movne       r2, #2
  00104	03a02001	 moveq       r2, #1
  00108	e1a0e00f	 mov         lr, pc
  0010c	e12fff13	 bx          r3

; 425  :                     pPdd->attachState = UFN_ATTACH;

  00110	e3a03001	 mov         r3, #1
  00114	e584303c	 str         r3, [r4, #0x3C]
  00118		 |$LN12@InterruptT|

; 426  :                 }
; 427  :                 /* Tell MDD about reset... */
; 428  :                 pPdd->pfnNotify (pPdd->pMddContext, UFN_MSG_BUS_EVENTS,
; 429  :                                  UFN_RESET);

  00118	e5940010	 ldr         r0, [r4, #0x10]
  0011c	e5943014	 ldr         r3, [r4, #0x14]
  00120	e3a02002	 mov         r2, #2
  00124	e3a01001	 mov         r1, #1
  00128	e1a0e00f	 mov         lr, pc
  0012c	e12fff13	 bx          r3

; 430  :                 PRINTMSG(ZONE_PDD_INIT, (L">>> RESET 0 >>>\r\n"));
; 431  :             }
; 432  :             else if ( ((intrReg & MGC_M_INTR_RESET) != 0) &&

  00130	ea00000e	 b           |$LN10@InterruptT|
  00134		 |$LN14@InterruptT|

; 433  :                       (pPdd->resetComplete == TRUE))

  00134	e3520000	 cmp         r2, #0
  00138	0a00000c	 beq         |$LN10@InterruptT|
  0013c	e5943038	 ldr         r3, [r4, #0x38]
  00140	e3530001	 cmp         r3, #1
  00144	1a000009	 bne         |$LN10@InterruptT|

; 434  :             {
; 435  :                 pPdd->ep[0].epStage = MGC_END0_START;
; 436  :                 pPdd->fWaitingForHandshake = FALSE;
; 437  :                 /* Tell MDD about reset... */
; 438  :                 pPdd->pfnNotify (pPdd->pMddContext, UFN_MSG_BUS_EVENTS,
; 439  :                                  UFN_RESET);

  00148	e3a0b001	 mov         r11, #1
  0014c	e584b2a0	 str         r11, [r4, #0x2A0]
  00150	e3a0b000	 mov         r11, #0
  00154	e5940010	 ldr         r0, [r4, #0x10]
  00158	e5943014	 ldr         r3, [r4, #0x14]
  0015c	e584b64c	 str         r11, [r4, #0x64C]
  00160	e3a02002	 mov         r2, #2
  00164	e3a01001	 mov         r1, #1
  00168	e1a0e00f	 mov         lr, pc
  0016c	e12fff13	 bx          r3
  00170		 |$LN10@InterruptT|

; 440  :                 PRINTMSG(ZONE_PDD_INIT, (L">>> RESET 1 >>>\r\n"));
; 441  :             }
; 442  :         }
; 443  : 
; 444  :         /* EP interrupt handling.  This needs to be done before EP0 interrupt handling
; 445  :            to prevent what looks like an RNDIS race condition.  Some EP 0 RNDIS encapsulated
; 446  :            commands require a TX on EP 1.  While the EP 1 TX is being processed another EP 0
; 447  :            setup can be received and processed but the EP 1 TX must complete before the new
; 448  :            setup command.  Processing EP 1 interrupts before EP 0 interrupts seems to be
; 449  :            enough to ensure this without adding special case code. */
; 450  :         if ((intrTxReg & ~BIT0) || intrRxReg)

  00170	e3d6c001	 bics        r12, r6, #1
  00174	1a000001	 bne         |$LN8@InterruptT|
  00178	e1190828	 tst         r9, r8, lsr #16
  0017c	0a000003	 beq         |$LN9@InterruptT|
  00180		 |$LN8@InterruptT|

; 451  :         {
; 452  :             PRINTMSG(ZONE_PDD_RX|ZONE_PDD_TX, (L"InterruptThread: TX 0x%04x, RX 0x%04x\r\n", intrTxReg & ~BIT0, intrRxReg));
; 453  :             UsbPddTxRxIntrHandler(pPdd, intrTxReg & ~BIT0, intrRxReg);

  00180	e0092828	 and         r2, r9, r8, lsr #16
  00184	e0061009	 and         r1, r6, r9
  00188	e1a00004	 mov         r0, r4
  0018c	eb000000	 bl          UsbPddTxRxIntrHandler
  00190		 |$LN9@InterruptT|

; 454  :         }
; 455  : 
; 456  :         /* Check for EP0 Interrupts */
; 457  :         if ((intrTxReg & BIT0) != 0)

  00190	e3160001	 tst         r6, #1
  00194	0a000003	 beq         |$LN5@InterruptT|

; 458  :         {
; 459  :             /* Do not process EP0 interrupts when a setup request is queued - do not
; 460  :                want to receive another setup just yet. */
; 461  :             if (pPdd->fHasQueuedSetupRequest)

  00198	e5943650	 ldr         r3, [r4, #0x650]
  0019c	e3530000	 cmp         r3, #0

; 462  :             {
; 463  :                 PRINTMSG(ZONE_PDD_EP0, (L"InterruptThread: EP 0 interrupt - ignored, waiting for handshake\r\n"));
; 464  :             }
; 465  :             else
; 466  :             {
; 467  :                 PRINTMSG(ZONE_PDD_EP0, (L"InterruptThread: EP 0 interrupt\r\n"));
; 468  :                 UsbPddEp0IntrHandler(pPdd);

  001a0	01a00004	 moveq       r0, r4
  001a4	0b000000	 bleq        UsbPddEp0IntrHandler
  001a8		 |$LN5@InterruptT|

; 469  :             }
; 470  :         }
; 471  : 
; 472  :         /* As per the Mentor Graphics Documentation, USB Core
; 473  :          * Interrupts like SOF, Disconnect and SUSPEND needs to
; 474  :          * be addressed only after EndPoint Interrupt Processing
; 475  :          */
; 476  :         if ((intrReg & MGC_M_INTR_SOF) != 0)
; 477  :         {
; 478  :             RETAILMSG(0, (L">>> SOF\r\n"));
; 479  :             /* Enable the Transmission if any are pending from our side */
; 480  :         }
; 481  :         if ((intrReg & MGC_M_INTR_DISCONNECT) != 0)

  001a8	e3170020	 tst         r7, #0x20
  001ac	0a00000a	 beq         |$LN2@InterruptT|

; 482  :         {
; 483  :             PRINTMSG(ZONE_PDD_INIT, (L">>> DISCONNECT\r\n"));
; 484  : 
; 485  :             if (pPdd->attachState == UFN_ATTACH)

  001b0	e594303c	 ldr         r3, [r4, #0x3C]
  001b4	e3530001	 cmp         r3, #1
  001b8	1a000007	 bne         |$LN2@InterruptT|

; 486  :             {
; 487  :                 pPdd->pfnNotify (pPdd->pMddContext, UFN_MSG_BUS_EVENTS,
; 488  :                                  UFN_DETACH);

  001bc	e5940010	 ldr         r0, [r4, #0x10]
  001c0	e5943014	 ldr         r3, [r4, #0x14]
  001c4	e3a02000	 mov         r2, #0
  001c8	e3a01001	 mov         r1, #1
  001cc	e1a0e00f	 mov         lr, pc
  001d0	e12fff13	 bx          r3

; 489  :                 pPdd->attachState = UFN_DETACH;

  001d4	e584b03c	 str         r11, [r4, #0x3C]

; 490  :                 pPdd->resetComplete = FALSE;

  001d8	e584b038	 str         r11, [r4, #0x38]
  001dc		 |$LN2@InterruptT|

; 491  :                 PRINTMSG(ZONE_PDD_INIT, (L">>> DETACH >>>\r\n"));
; 492  :             }
; 493  :         }
; 494  :         if (intrReg & MGC_M_INTR_SUSPEND)

  001dc	e3170001	 tst         r7, #1

; 495  :         {
; 496  :             PRINTMSG(ZONE_PDD_INIT, (L">>> SUSPEND\r\n"));
; 497  :             
; 498  :             // Seem to need a delay when resuming in order for class driver 
; 499  :             // to successfully re-establish connection.
; 500  :             Sleep(500);

  001e0	13a00f7d	 movne       r0, #0x7D, 30
  001e4	1b000000	 blne        Sleep

; 501  :         }
; 502  : 
; 503  :         /* NOTE:  The irq stays asserted until EOI is written */
; 504  :         pUsbdRegs->EOIR =  0x00;

  001e8	e585b060	 str         r11, [r5, #0x60]

; 505  :         InterruptDone (pPdd->sysIntr);

  001ec	e594002c	 ldr         r0, [r4, #0x2C]
  001f0	eb000000	 bl          InterruptDone
  001f4	e5943034	 ldr         r3, [r4, #0x34]
  001f8	e3530000	 cmp         r3, #0
  001fc	0affff8f	 beq         |$LL18@InterruptT|
  00200		 |$LN26@InterruptT|

; 506  :     }
; 507  : 
; 508  :     /* Disable interrupts */
; 509  : 	pUsbdRegs->CORE_INTMSKCLRR = USB_CORE_INTR_MASK_ALL;

  00200	e3e034fe	 mvn         r3, #0xFE, 8
  00204	e5853054	 str         r3, [r5, #0x54]

; 510  : 	pUsbdRegs->EP_INTMSKCLRR = USB_EP_INTR_MASK_ALL;

  00208	e3e03801	 mvn         r3, #1, 16
  0020c	e5853034	 str         r3, [r5, #0x34]

; 511  :     pUsbdRegs->EOIR = 0x00;

  00210	e585b060	 str         r11, [r5, #0x60]

; 512  : 
; 513  :     /* Send detach */
; 514  :     pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_DETACH);

  00214	e5940010	 ldr         r0, [r4, #0x10]
  00218	e5943014	 ldr         r3, [r4, #0x14]
  0021c	e3a02000	 mov         r2, #0
  00220	e3a01001	 mov         r1, #1
  00224	e1a0e00f	 mov         lr, pc
  00228	e12fff13	 bx          r3

; 515  :     pPdd->attachState = UFN_DETACH;

  0022c	e584b03c	 str         r11, [r4, #0x3C]

; 516  :     pPdd->resetComplete = FALSE;

  00230	e584b038	 str         r11, [r4, #0x38]

; 517  : 
; 518  :     PRINTMSG(ZONE_FUNCTION, (L"-InterruptThread\r\n"));
; 519  : 
; 520  :     return ERROR_SUCCESS;

  00234	e3a00000	 mov         r0, #0

; 521  : }

  00238	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0023c	e12fff1e	 bx          lr
  00240		 |$M48521|

			 ENDP  ; |InterruptThread|

	EXPORT	|UfnPdd_ContextSetup|
	EXPORT	|??_C@_1FO@IGBBBJEC@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAH?$AAA?$AAL?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAI?$AAN?$AAR@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FE@FCLHPLHL@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAS?$AAY?$AAS?$AAC?$AAO?$AAN?$AAF?$AA?5?$AAr?$AAe?$AAg?$AAi?$AAs?$AAt?$AAe?$AAr?$AAs?$AA?5?$AAm?$AAa?$AAp?$AAp?$AAi?$AAn?$AAg@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EO@FDOPPAGC@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAC?$AAP?$AAP?$AAI?$AA?5?$AAr?$AAe?$AAg?$AAi?$AAs?$AAt?$AAe?$AAr?$AAs?$AA?5?$AAm?$AAa?$AAp?$AAp?$AAi?$AAn?$AAg?$AA?5?$AAf?$AAa@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FK@BAOADCDO@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAl?$AAe?$AAr?$AA?5?$AAr?$AAe?$AAg?$AAi?$AAs?$AAt?$AAe?$AAr?$AAs?$AA?5?$AAm?$AAa?$AAp?$AAp@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EA@OEPLPLAG@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAo?$AAp?$AAe?$AAn?$AA?5?$AAb?$AAu?$AAs?$AA?5?$AAd?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FC@JDGAACEB@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAr?$AAe?$AAa?$AAd?$AA?5?$AAr?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?5?$AAp?$AAa?$AAr?$AAa@| [ DATA ] ; `string'
	EXPORT	|??_C@_1JO@JAGHJEHH@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EM@COOJIHLG@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AA?5?$AAP?$AAD?$AAD?$AA?5?$AAO?$AAb?$AAj?$AAe?$AAc@| [ DATA ] ; `string'
	IMPORT	|KernelIoControl|
	IMPORT	|CreateEventW|
	IMPORT	|USBPeripheralInit|
	IMPORT	|MmMapIoSpace|
	IMPORT	|CreateBusAccessHandle|
	IMPORT	|OpenEventW|
	IMPORT	|GetDeviceRegistryParams|
	IMPORT	|InitializeCriticalSection|
	IMPORT	|NKDbgPrintfW|
	IMPORT	|LocalAlloc|
	IMPORT	|USBFNPDD_Init|
	IMPORT	|wcslen|

  00000			 AREA	 |.pdata|, PDATA
|$T48545| DCD	|$LN15@UfnPdd_Con|
	DCD	0x4000b102

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FO@IGBBBJEC@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAH?$AAA?$AAL?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAI?$AAN?$AAR@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "I", 0x0, "O", 0x0, "C", 0x0, "T", 0x0, "L", 0x0, "_"
	DCB	0x0, "H", 0x0, "A", 0x0, "L", 0x0, "_", 0x0, "R", 0x0, "E"
	DCB	0x0, "Q", 0x0, "U", 0x0, "E", 0x0, "S", 0x0, "T", 0x0, "_"
	DCB	0x0, "S", 0x0, "Y", 0x0, "S", 0x0, "T", 0x0, "I", 0x0, "N"
	DCB	0x0, "R", 0x0, " ", 0x0, "c", 0x0, "a", 0x0, "l", 0x0, "l"
	DCB	0x0, " ", 0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e"
	DCB	0x0, "d", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FE@FCLHPLHL@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAS?$AAY?$AAS?$AAC?$AAO?$AAN?$AAF?$AA?5?$AAr?$AAe?$AAg?$AAi?$AAs?$AAt?$AAe?$AAr?$AAs?$AA?5?$AAm?$AAa?$AAp?$AAp?$AAi?$AAn?$AAg@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "S", 0x0, "Y", 0x0, "S", 0x0, "C", 0x0, "O", 0x0, "N"
	DCB	0x0, "F", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "g", 0x0, "i"
	DCB	0x0, "s", 0x0, "t", 0x0, "e", 0x0, "r", 0x0, "s", 0x0, " "
	DCB	0x0, "m", 0x0, "a", 0x0, "p", 0x0, "p", 0x0, "i", 0x0, "n"
	DCB	0x0, "g", 0x0, " ", 0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l"
	DCB	0x0, "e", 0x0, "d", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EO@FDOPPAGC@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAC?$AAP?$AAP?$AAI?$AA?5?$AAr?$AAe?$AAg?$AAi?$AAs?$AAt?$AAe?$AAr?$AAs?$AA?5?$AAm?$AAa?$AAp?$AAp?$AAi?$AAn?$AAg?$AA?5?$AAf?$AAa@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "C", 0x0, "P", 0x0, "P", 0x0, "I", 0x0, " ", 0x0, "r"
	DCB	0x0, "e", 0x0, "g", 0x0, "i", 0x0, "s", 0x0, "t", 0x0, "e"
	DCB	0x0, "r", 0x0, "s", 0x0, " ", 0x0, "m", 0x0, "a", 0x0, "p"
	DCB	0x0, "p", 0x0, "i", 0x0, "n", 0x0, "g", 0x0, " ", 0x0, "f"
	DCB	0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FK@BAOADCDO@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAl?$AAe?$AAr?$AA?5?$AAr?$AAe?$AAg?$AAi?$AAs?$AAt?$AAe?$AAr?$AAs?$AA?5?$AAm?$AAa?$AAp?$AAp@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "C", 0x0, "o", 0x0, "n", 0x0, "t", 0x0, "r", 0x0, "o"
	DCB	0x0, "l", 0x0, "l", 0x0, "e", 0x0, "r", 0x0, " ", 0x0, "r"
	DCB	0x0, "e", 0x0, "g", 0x0, "i", 0x0, "s", 0x0, "t", 0x0, "e"
	DCB	0x0, "r", 0x0, "s", 0x0, " ", 0x0, "m", 0x0, "a", 0x0, "p"
	DCB	0x0, "p", 0x0, "i", 0x0, "n", 0x0, "g", 0x0, " ", 0x0, "f"
	DCB	0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EA@OEPLPLAG@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAo?$AAp?$AAe?$AAn?$AA?5?$AAb?$AAu?$AAs?$AA?5?$AAd?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?$AN?$AA?6?$AA?$AA@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "F", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "o", 0x0, "p", 0x0, "e", 0x0, "n", 0x0, " "
	DCB	0x0, "b", 0x0, "u", 0x0, "s", 0x0, " ", 0x0, "d", 0x0, "r"
	DCB	0x0, "i", 0x0, "v", 0x0, "e", 0x0, "r", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FC@JDGAACEB@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAr?$AAe?$AAa?$AAd?$AA?5?$AAr?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?5?$AAp?$AAa?$AAr?$AAa@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "F", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "r", 0x0, "e", 0x0, "a", 0x0, "d", 0x0, " "
	DCB	0x0, "r", 0x0, "e", 0x0, "g", 0x0, "i", 0x0, "s", 0x0, "t"
	DCB	0x0, "r", 0x0, "y", 0x0, " ", 0x0, "p", 0x0, "a", 0x0, "r"
	DCB	0x0, "a", 0x0, "m", 0x0, "e", 0x0, "t", 0x0, "e", 0x0, "r"
	DCB	0x0, "s", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1JO@JAGHJEHH@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| DCB "C"
	DCB	0x0, ":", 0x0, "\\", 0x0, "W", 0x0, "I", 0x0, "N", 0x0, "C"
	DCB	0x0, "E", 0x0, "6", 0x0, "0", 0x0, "0", 0x0, "\\", 0x0, "P"
	DCB	0x0, "L", 0x0, "A", 0x0, "T", 0x0, "F", 0x0, "O", 0x0, "R"
	DCB	0x0, "M", 0x0, "\\", 0x0, "C", 0x0, "O", 0x0, "M", 0x0, "M"
	DCB	0x0, "O", 0x0, "N", 0x0, "\\", 0x0, "S", 0x0, "R", 0x0, "C"
	DCB	0x0, "\\", 0x0, "S", 0x0, "O", 0x0, "C", 0x0, "\\", 0x0, "C"
	DCB	0x0, "O", 0x0, "M", 0x0, "M", 0x0, "O", 0x0, "N", 0x0, "_"
	DCB	0x0, "T", 0x0, "I", 0x0, "_", 0x0, "V", 0x0, "1", 0x0, "\\"
	DCB	0x0, "A", 0x0, "M", 0x0, "3", 0x0, "5", 0x0, "1", 0x0, "7"
	DCB	0x0, "\\", 0x0, "U", 0x0, "S", 0x0, "B", 0x0, "\\", 0x0, "U"
	DCB	0x0, "S", 0x0, "B", 0x0, "F", 0x0, "N", 0x0, "\\", 0x0, "."
	DCB	0x0, "\\", 0x0, "u", 0x0, "s", 0x0, "b", 0x0, "f", 0x0, "n"
	DCB	0x0, "p", 0x0, "d", 0x0, "d", 0x0, ".", 0x0, "c", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "%", 0x0, "s", 0x0, " ", 0x0, "l", 0x0, "i", 0x0, "n"
	DCB	0x0, "e", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ":", 0x0, " "
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EM@COOJIHLG@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AA?5?$AAP?$AAD?$AAD?$AA?5?$AAO?$AAb?$AAj?$AAe?$AAc@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "U", 0x0, "n", 0x0, "a", 0x0, "b", 0x0, "l", 0x0, "e"
	DCB	0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "A", 0x0, "l"
	DCB	0x0, "l", 0x0, "o", 0x0, "c", 0x0, " ", 0x0, "P", 0x0, "D"
	DCB	0x0, "D", 0x0, " ", 0x0, "O", 0x0, "b", 0x0, "j", 0x0, "e"
	DCB	0x0, "c", 0x0, "t", 0x0, "!", 0x0, "!", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_ContextSetup| PROC

; 537  : {

  00000		 |$LN15@UfnPdd_Con|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M48542|
  00008	e1a04001	 mov         r4, r1
  0000c	e1a07000	 mov         r7, r0

; 538  :     BOOL retValue = FALSE;

  00010	e3a05000	 mov         r5, #0

; 539  :     CSL_UsbRegs *pUsbdRegs = NULL;
; 540  :     CSL_CppiRegs *pCppiRegs = NULL;
; 541  :     PHYSICAL_ADDRESS pa;
; 542  :     DWORD usbIrqVal;
; 543  : 
; 544  :     PRINTMSG(ZONE_FUNCTION, (L"+UfnPdd_ContextSetup\r\n"));
; 545  : 
; 546  :     // Initialise platform PDD
; 547  :     if (!USBFNPDD_Init())

  00014	eb000000	 bl          USBFNPDD_Init
  00018	e3500000	 cmp         r0, #0
  0001c	0a000098	 beq         |$cleanUp$47192|
  00020	e3a03c06	 mov         r3, #6, 24

; 548  :     {
; 549  :         DEBUGMSG(ZONE_ERROR, (L"UfnPdd_ContextSetup: Failed to initialise platform USBFN PDD\r\n"));
; 550  :         goto cleanUp;
; 551  :     }
; 552  : 
; 553  :     /* Allocate PDD object */
; 554  :     if (NULL == ((*ppPddContext) = (USBFNPDDCONTEXT *)
; 555  :                  LocalAlloc(LPTR, sizeof(USBFNPDDCONTEXT))))

  00024	e3831068	 orr         r1, r3, #0x68
  00028	e3a00040	 mov         r0, #0x40
  0002c	eb000000	 bl          LocalAlloc
  00030	e3500000	 cmp         r0, #0
  00034	e5840000	 str         r0, [r4]
  00038	1a000007	 bne         |$LN8@UfnPdd_Con|

; 556  :     {
; 557  :         ERRORMSG (TRUE, (TEXT("ERROR: Unable to Alloc PDD Object!!\r\n")));

  0003c	e59f1258	 ldr         r1, [pc, #0x258]
  00040	e59f0250	 ldr         r0, [pc, #0x250]
  00044	e3a03c02	 mov         r3, #2, 24
  00048	e383202d	 orr         r2, r3, #0x2D
  0004c	eb000000	 bl          NKDbgPrintfW
  00050	e59f0268	 ldr         r0, [pc, #0x268]
  00054	eb000000	 bl          NKDbgPrintfW

; 558  :         goto cleanUp;

  00058	ea000089	 b           |$cleanUp$47192|
  0005c		 |$LN8@UfnPdd_Con|

; 559  :     }
; 560  : 
; 561  :     /* Initialize critical section */
; 562  :     InitializeCriticalSection(&(*ppPddContext)->epCS);

  0005c	e2800e27	 add         r0, r0, #0x27, 28
  00060	eb000000	 bl          InitializeCriticalSection

; 563  :     (*ppPddContext)->devState = 0;

  00064	e5942000	 ldr         r2, [r4]
  00068	e3a08000	 mov         r8, #0

; 564  : 
; 565  :     PRINTMSG(ZONE_PDD_INIT, (
; 566  :                  L"UfnPdd_ContextSetup: Reading Registry Information\r\n"));
; 567  : 
; 568  :     /* Read device parameters */
; 569  :     if (GetDeviceRegistryParams (szActiveKey, *ppPddContext,
; 570  :                                  dimof(f_DeviceRegParams), f_DeviceRegParams) != ERROR_SUCCESS)

  0006c	e59f3248	 ldr         r3, [pc, #0x248]
  00070	e5828258	 str         r8, [r2, #0x258]
  00074	e5941000	 ldr         r1, [r4]
  00078	e3a02007	 mov         r2, #7
  0007c	e1a00007	 mov         r0, r7
  00080	eb000000	 bl          GetDeviceRegistryParams
  00084	e3500000	 cmp         r0, #0
  00088	0a000007	 beq         |$LN7@UfnPdd_Con|

; 571  :     {
; 572  :         ERRORMSG(TRUE, (L"ERROR: Failed read registry parameters\r\n"
; 573  :                      ));

  0008c	e59f1208	 ldr         r1, [pc, #0x208]
  00090	e59f0200	 ldr         r0, [pc, #0x200]
  00094	e3a03c02	 mov         r3, #2, 24
  00098	e383203d	 orr         r2, r3, #0x3D
  0009c	eb000000	 bl          NKDbgPrintfW
  000a0	e59f0210	 ldr         r0, [pc, #0x210]
  000a4	eb000000	 bl          NKDbgPrintfW
  000a8	ea000075	 b           |$cleanUp$47192|
  000ac		 |$LN7@UfnPdd_Con|

; 574  :         goto cleanUp;
; 575  :     }
; 576  : 
; 577  :     /* Open activity event */
; 578  :     if (wcslen((*ppPddContext)->szActivityEvent) > 0) {

  000ac	e5946000	 ldr         r6, [r4]
  000b0	e286004c	 add         r0, r6, #0x4C
  000b4	eb000000	 bl          wcslen
  000b8	e3500000	 cmp         r0, #0
  000bc	0a000006	 beq         |$LN6@UfnPdd_Con|
  000c0	e3a0381f	 mov         r3, #0x1F, 16

; 579  :         (*ppPddContext)->hActivityEvent =
; 580  :             OpenEvent(EVENT_ALL_ACCESS, FALSE, (*ppPddContext)->szActivityEvent);

  000c4	e3830003	 orr         r0, r3, #3
  000c8	e286204c	 add         r2, r6, #0x4C
  000cc	e3a01000	 mov         r1, #0
  000d0	eb000000	 bl          OpenEventW
  000d4	e5943000	 ldr         r3, [r4]
  000d8	e5830254	 str         r0, [r3, #0x254]
  000dc		 |$LN6@UfnPdd_Con|

; 581  :     }
; 582  : 
; 583  :     /* Start powered up */
; 584  :     (*ppPddContext)->currentPowerState = D0;

  000dc	e5943000	 ldr         r3, [r4]

; 585  :     (*ppPddContext)->parentBus = CreateBusAccessHandle(szActiveKey);

  000e0	e1a00007	 mov         r0, r7
  000e4	e5838048	 str         r8, [r3, #0x48]
  000e8	eb000000	 bl          CreateBusAccessHandle
  000ec	e5943000	 ldr         r3, [r4]
  000f0	e5830018	 str         r0, [r3, #0x18]

; 586  : 
; 587  :     if ( (*ppPddContext)->parentBus == NULL )

  000f4	e5943000	 ldr         r3, [r4]
  000f8	e5933018	 ldr         r3, [r3, #0x18]
  000fc	e3530000	 cmp         r3, #0
  00100	1a000007	 bne         |$LN5@UfnPdd_Con|

; 588  :     {
; 589  :         ERRORMSG (TRUE, (L"ERROR: Failed open bus driver\r\n"
; 590  :                       ));

  00104	e59f1190	 ldr         r1, [pc, #0x190]
  00108	e59f0188	 ldr         r0, [pc, #0x188]
  0010c	e3a03c02	 mov         r3, #2, 24
  00110	e383204e	 orr         r2, r3, #0x4E
  00114	eb000000	 bl          NKDbgPrintfW
  00118	e59f0194	 ldr         r0, [pc, #0x194]
  0011c	eb000000	 bl          NKDbgPrintfW
  00120	ea000057	 b           |$cleanUp$47192|
  00124		 |$LN5@UfnPdd_Con|

; 591  :         goto cleanUp;

  00124	e3a03317	 mov         r3, #0x17, 6
  00128	e3a02b02	 mov         r2, #2, 22

; 592  :     }
; 593  : 
; 594  :     PRINTMSG(ZONE_PDD_INIT, (
; 595  :                  L"UfnPdd_ContextSetup: Mapping Region 0x%08x Size 0x%x\r\n",
; 596  :                  AM3517_USB0_REGS_PA, sizeof(CSL_UsbRegs)));
; 597  : 
; 598  :     /* Map the USBD registers */
; 599  :     pa.QuadPart = AM3517_USB0_REGS_PA;

  0012c	e3830701	 orr         r0, r3, #1, 14

; 600  :     pUsbdRegs = (CSL_UsbRegs *) MmMapIoSpace(pa, sizeof(CSL_UsbRegs), FALSE);

  00130	e3a03000	 mov         r3, #0
  00134	e3822018	 orr         r2, r2, #0x18
  00138	e3a01000	 mov         r1, #0
  0013c	eb000000	 bl          MmMapIoSpace
  00140	e1b02000	 movs        r2, r0

; 601  :     if ( pUsbdRegs == NULL )

  00144	1a000007	 bne         |$LN4@UfnPdd_Con|

; 602  :     {
; 603  :         ERRORMSG (TRUE, (L"ERROR: Controller registers mapping failed\r\n"));

  00148	e59f114c	 ldr         r1, [pc, #0x14C]
  0014c	e59f0144	 ldr         r0, [pc, #0x144]
  00150	e3a03c02	 mov         r3, #2, 24
  00154	e383205b	 orr         r2, r3, #0x5B
  00158	eb000000	 bl          NKDbgPrintfW
  0015c	e59f014c	 ldr         r0, [pc, #0x14C]
  00160	eb000000	 bl          NKDbgPrintfW
  00164	ea000046	 b           |$cleanUp$47192|
  00168		 |$LN4@UfnPdd_Con|

; 604  :         goto cleanUp;
; 605  :     }
; 606  :     (*ppPddContext)->pUsbdRegs = pUsbdRegs;

  00168	e5943000	 ldr         r3, [r4]
  0016c	e3a01317	 mov         r1, #0x17, 6

; 607  : 
; 608  :     PRINTMSG(ZONE_PDD_INIT, (
; 609  :                  L"UfnPdd_ContextSetup: Mapping Region 0x%08x Size 0x%x\r\n",
; 610  :                  AM3517_CPPI_REGS_PA, sizeof (CSL_CppiRegs)));
; 611  : 
; 612  :     /* Map the CPPI registers */
; 613  :     pa.QuadPart = AM3517_CPPI_REGS_PA;

  00170	e3810a41	 orr         r0, r1, #0x41, 20
  00174	e583201c	 str         r2, [r3, #0x1C]

; 614  :     pCppiRegs = (CSL_CppiRegs *) MmMapIoSpace(pa, sizeof(CSL_CppiRegs), FALSE);

  00178	e3a03000	 mov         r3, #0
  0017c	e3a02c5e	 mov         r2, #0x5E, 24
  00180	e3a01000	 mov         r1, #0
  00184	eb000000	 bl          MmMapIoSpace
  00188	e1b02000	 movs        r2, r0

; 615  :     if ( pCppiRegs == NULL )

  0018c	1a000007	 bne         |$LN3@UfnPdd_Con|

; 616  :     {
; 617  :         ERRORMSG (TRUE, (L"ERROR: CPPI registers mapping failed\r\n"));

  00190	e59f1104	 ldr         r1, [pc, #0x104]
  00194	e59f00fc	 ldr         r0, [pc, #0xFC]
  00198	e3a03c02	 mov         r3, #2, 24
  0019c	e3832069	 orr         r2, r3, #0x69
  001a0	eb000000	 bl          NKDbgPrintfW
  001a4	e59f0100	 ldr         r0, [pc, #0x100]
  001a8	eb000000	 bl          NKDbgPrintfW
  001ac	ea000034	 b           |$cleanUp$47192|
  001b0		 |$LN3@UfnPdd_Con|

; 618  :         goto cleanUp;
; 619  :     }
; 620  :     (*ppPddContext)->pCppiRegs = pCppiRegs;

  001b0	e5943000	 ldr         r3, [r4]

; 621  : 
; 622  :     PRINTMSG(ZONE_PDD_INIT, (
; 623  :                  L"UfnPdd_ContextSetup: Mapping Region 0x%08x Size 0x%x\r\n",
; 624  :                  OMAP_SYSC_GENERAL_REGS_PA, sizeof (OMAP_SYSC_GENERAL_REGS)));
; 625  : 
; 626  :     /* Map the sys config registers */
; 627  :     pa.QuadPart = (LONGLONG)OMAP_SYSC_GENERAL_REGS_PA;

  001b4	e59f00ec	 ldr         r0, [pc, #0xEC]
  001b8	e3a01000	 mov         r1, #0
  001bc	e5832020	 str         r2, [r3, #0x20]

; 628  :     (*ppPddContext)->pSysConfRegs = (OMAP_SYSC_GENERAL_REGS*) MmMapIoSpace(pa,
; 629  :                                                                 sizeof (OMAP_SYSC_GENERAL_REGS),
; 630  :                                                                 FALSE);

  001c0	e3a03000	 mov         r3, #0
  001c4	e3a02ea6	 mov         r2, #0xA6, 28
  001c8	eb000000	 bl          MmMapIoSpace
  001cc	e5943000	 ldr         r3, [r4]
  001d0	e5830028	 str         r0, [r3, #0x28]

; 631  :     if ( (*ppPddContext)->pSysConfRegs == NULL )

  001d4	e5940000	 ldr         r0, [r4]
  001d8	e5903028	 ldr         r3, [r0, #0x28]
  001dc	e3530000	 cmp         r3, #0
  001e0	1a000007	 bne         |$LN2@UfnPdd_Con|

; 632  :     {
; 633  :         ERRORMSG (TRUE, (L"ERROR: SYSCONF registers mapping failed\r\n"
; 634  :                       ));

  001e4	e59f10b0	 ldr         r1, [pc, #0xB0]
  001e8	e59f00a8	 ldr         r0, [pc, #0xA8]
  001ec	e3a03c02	 mov         r3, #2, 24
  001f0	e383207a	 orr         r2, r3, #0x7A
  001f4	eb000000	 bl          NKDbgPrintfW
  001f8	e59f00a4	 ldr         r0, [pc, #0xA4]
  001fc	eb000000	 bl          NKDbgPrintfW
  00200	ea00001f	 b           |$cleanUp$47192|
  00204		 |$LN2@UfnPdd_Con|

; 635  :         goto cleanUp;
; 636  :     }
; 637  : 
; 638  :     PRINTMSG(ZONE_PDD_INIT, (
; 639  :                  L"UfnPdd_ContextSetup: Allocated USB 0x%08x SYS_CONF 0x%08x\r\n",
; 640  :                  (*ppPddContext)->pUsbdRegs, (*ppPddContext)->pSysConfRegs));
; 641  : 
; 642  :     /* Perform the USB Core Initialization */
; 643  :     USBPeripheralInit(*ppPddContext) ;

  00204	eb000000	 bl          USBPeripheralInit

; 644  : 
; 645  :     (*ppPddContext)->resetComplete  = FALSE;

  00208	e5941000	 ldr         r1, [r4]

; 646  : 
; 647  :     /* Create start event */
; 648  :     (*ppPddContext)->hStartEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  0020c	e3a03000	 mov         r3, #0
  00210	e3a02000	 mov         r2, #0
  00214	e5818038	 str         r8, [r1, #0x38]
  00218	e3a01000	 mov         r1, #0
  0021c	e3a00000	 mov         r0, #0
  00220	eb000000	 bl          CreateEventW
  00224	e5942000	 ldr         r2, [r4]
  00228	e1a03000	 mov         r3, r0

; 649  : 
; 650  : 	usbIrqVal = (*ppPddContext)->irq;
; 651  : 
; 652  :     if ( !KernelIoControl (IOCTL_HAL_REQUEST_SYSINTR,  &usbIrqVal,
; 653  :                            sizeof(DWORD), &(*ppPddContext)->sysIntr,
; 654  :                            sizeof((*ppPddContext)->sysIntr), NULL))

  0022c	e59f006c	 ldr         r0, [pc, #0x6C]
  00230	e582326c	 str         r3, [r2, #0x26C]
  00234	e5943000	 ldr         r3, [r4]
  00238	e3a04004	 mov         r4, #4
  0023c	e3a02004	 mov         r2, #4
  00240	e493e02c	 ldr         lr, [r3], #0x2C
  00244	e28d1008	 add         r1, sp, #8
  00248	e58d8004	 str         r8, [sp, #4]
  0024c	e58d4000	 str         r4, [sp]
  00250	e58de008	 str         lr, [sp, #8]
  00254	eb000000	 bl          KernelIoControl
  00258	e3500000	 cmp         r0, #0
  0025c	1a000007	 bne         |$LN1@UfnPdd_Con|

; 655  :     {
; 656  :         ERRORMSG (TRUE, (L"ERROR: IOCTL_HAL_REQUEST_SYSTINR call failed\r\n"
; 657  :                       ));

  00260	e59f1034	 ldr         r1, [pc, #0x34]
  00264	e59f002c	 ldr         r0, [pc, #0x2C]
  00268	e3a03c02	 mov         r3, #2, 24
  0026c	e3832091	 orr         r2, r3, #0x91
  00270	eb000000	 bl          NKDbgPrintfW
  00274	e59f0018	 ldr         r0, [pc, #0x18]
  00278	eb000000	 bl          NKDbgPrintfW
  0027c	ea000000	 b           |$cleanUp$47192|
  00280		 |$LN1@UfnPdd_Con|

; 658  :         goto cleanUp;
; 659  :     }
; 660  : 
; 661  :     PRINTMSG(ZONE_PDD_INIT, (
; 662  :                  L"UfnPdd_ContextSetup: USB Interrupt 0x%x SYSINTR 0x%x\r\n",
; 663  :                  usbIrqVal , (*ppPddContext)->sysIntr));
; 664  : 
; 665  :     retValue = TRUE;

  00280	e3a05001	 mov         r5, #1
  00284		 |$cleanUp$47192|

; 666  : 
; 667  : cleanUp:
; 668  :     PRINTMSG(ZONE_FUNCTION, (L"-UfnPdd_ContextSetup\r\n"));
; 669  : 
; 670  :     return retValue;
; 671  : }

  00284	e1a00005	 mov         r0, r5
  00288	e28dd00c	 add         sp, sp, #0xC
  0028c	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00290	e12fff1e	 bx          lr
  00294		 |$LN16@UfnPdd_Con|
  00294		 |$LN17@UfnPdd_Con|
  00294	00000000	 DCD         |??_C@_1FO@IGBBBJEC@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAH?$AAA?$AAL?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAI?$AAN?$AAR@|
  00298		 |$LN18@UfnPdd_Con|
  00298	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  0029c		 |$LN19@UfnPdd_Con|
  0029c	00000000	 DCD         |??_C@_1JO@JAGHJEHH@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  002a0		 |$LN20@UfnPdd_Con|
  002a0	01010098	 DCD         0x1010098
  002a4		 |$LN21@UfnPdd_Con|
  002a4	00000000	 DCD         |??_C@_1FE@FCLHPLHL@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAS?$AAY?$AAS?$AAC?$AAO?$AAN?$AAF?$AA?5?$AAr?$AAe?$AAg?$AAi?$AAs?$AAt?$AAe?$AAr?$AAs?$AA?5?$AAm?$AAa?$AAp?$AAp?$AAi?$AAn?$AAg@|
  002a8		 |$LN22@UfnPdd_Con|
  002a8	48002270	 DCD         0x48002270
  002ac		 |$LN23@UfnPdd_Con|
  002ac	00000000	 DCD         |??_C@_1EO@FDOPPAGC@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAC?$AAP?$AAP?$AAI?$AA?5?$AAr?$AAe?$AAg?$AAi?$AAs?$AAt?$AAe?$AAr?$AAs?$AA?5?$AAm?$AAa?$AAp?$AAp?$AAi?$AAn?$AAg?$AA?5?$AAf?$AAa@|
  002b0		 |$LN24@UfnPdd_Con|
  002b0	00000000	 DCD         |??_C@_1FK@BAOADCDO@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAl?$AAe?$AAr?$AA?5?$AAr?$AAe?$AAg?$AAi?$AAs?$AAt?$AAe?$AAr?$AAs?$AA?5?$AAm?$AAa?$AAp?$AAp@|
  002b4		 |$LN25@UfnPdd_Con|
  002b4	00000000	 DCD         |??_C@_1EA@OEPLPLAG@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAo?$AAp?$AAe?$AAn?$AA?5?$AAb?$AAu?$AAs?$AA?5?$AAd?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?$AN?$AA?6?$AA?$AA@|
  002b8		 |$LN26@UfnPdd_Con|
  002b8	00000000	 DCD         |??_C@_1FC@JDGAACEB@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAr?$AAe?$AAa?$AAd?$AA?5?$AAr?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?5?$AAp?$AAa?$AAr?$AAa@|
  002bc		 |$LN27@UfnPdd_Con|
  002bc	00000000	 DCD         |f_DeviceRegParams|
  002c0		 |$LN28@UfnPdd_Con|
  002c0	00000000	 DCD         |??_C@_1EM@COOJIHLG@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AA?5?$AAP?$AAD?$AAD?$AA?5?$AAO?$AAb?$AAj?$AAe?$AAc@|
  002c4		 |$M48543|

			 ENDP  ; |UfnPdd_ContextSetup|


  00000			 AREA	 |.pdata|, PDATA
|$T48571| DCD	|$LN10@Log2|
	DCD	0x40000900
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Log2|	 PROC

; 769  : {

  00000		 |$LN10@Log2|
  00000		 |$M48568|
  00000	e1b03000	 movs        r3, r0

; 770  :     DWORD rc = 0;

  00004	e3a00000	 mov         r0, #0

; 771  :     while ( value != 0 )

  00008	0a000004	 beq         |$LN1@Log2|
  0000c		 |$LL3@Log2|

; 772  :     {
; 773  :         value >>= 1;

  0000c	e1b030a3	 movs        r3, r3, lsr #1

; 774  :         rc++;

  00010	e2800001	 add         r0, r0, #1
  00014	1afffffc	 bne         |$LL3@Log2|

; 775  :     }
; 776  :     if ( rc > 0 ) rc--;

  00018	e3500000	 cmp         r0, #0
  0001c	12400001	 subne       r0, r0, #1
  00020		 |$LN1@Log2|

; 777  :     return rc;
; 778  : }

  00020	e12fff1e	 bx          lr
  00024		 |$M48569|

			 ENDP  ; |Log2|

	EXPORT	|UfnPdd_PowerDown|

  00000			 AREA	 |.pdata|, PDATA
|$T48578| DCD	|$LN5@UfnPdd_Pow|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_PowerDown| PROC

; 791  : {

  00000		 |$LN5@UfnPdd_Pow|
  00000		 |$M48575|

; 792  : 	UNREFERENCED_PARAMETER(pPddContext);
; 793  : 
; 794  :     PRINTMSG(ZONE_FUNCTION, (L"UfnPdd_PowerDown\r\n"));
; 795  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M48576|

			 ENDP  ; |UfnPdd_PowerDown|

	EXPORT	|UfnPdd_PowerUp|

  00000			 AREA	 |.pdata|, PDATA
|$T48585| DCD	|$LN5@UfnPdd_Pow@2|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_PowerUp| PROC

; 808  : {

  00000		 |$LN5@UfnPdd_Pow@2|
  00000		 |$M48582|

; 809  : 	UNREFERENCED_PARAMETER(pPddContext);
; 810  : 
; 811  :     PRINTMSG(ZONE_FUNCTION, (L"UfnPdd_PowerUp\r\n"));
; 812  : 
; 813  :     // Handle power changes through bus power ioctls
; 814  :     //USBPeripheralPowerUp(pPddContext);
; 815  :     //USBPeripheralStart(pPddContext);
; 816  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M48583|

			 ENDP  ; |UfnPdd_PowerUp|

	IMPORT	|USBPeripheralPowerDown|
	IMPORT	|USBPeripheralEndSession|
	IMPORT	|USBPeripheralPowerUp|
	IMPORT	|SetDevicePowerState|

  00000			 AREA	 |.pdata|, PDATA
|$T48595| DCD	|$LN16@SetPowerSt|
	DCD	0x40003d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetPowerState| PROC

; 830  : {

  00000		 |$LN16@SetPowerSt|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M48592|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 831  :     PREFAST_ASSERT(pPdd != NULL);
; 832  : 
; 833  :     PRINTMSG(ZONE_FUNCTION, (L"SetPowerState: USBFN entering D%u\r\n", newPowerState));
; 834  : 
; 835  : 	if (newPowerState != pPdd->currentPowerState)

  0000c	e5943048	 ldr         r3, [r4, #0x48]
  00010	e1550003	 cmp         r5, r3
  00014	0a000034	 beq         |$LN7@SetPowerSt|

; 836  :     {
; 837  :         if (newPowerState == D1 || newPowerState == D2)

  00018	e3550001	 cmp         r5, #1
  0001c	0a000001	 beq         |$LN8@SetPowerSt|
  00020	e3550002	 cmp         r5, #2
  00024	1a000000	 bne         |$LN9@SetPowerSt|
  00028		 |$LN8@SetPowerSt|

; 838  :         {
; 839  :             newPowerState = D0;

  00028	e3a05000	 mov         r5, #0
  0002c		 |$LN9@SetPowerSt|

; 840  :         }
; 841  :     }
; 842  : 
; 843  :     if (newPowerState != pPdd->currentPowerState)

  0002c	e1550003	 cmp         r5, r3
  00030	0a00002d	 beq         |$LN7@SetPowerSt|

; 844  :     {
; 845  :         if ((newPowerState < pPdd->currentPowerState) && (pPdd->parentBus != NULL))

  00034	aa000014	 bge         |$LN4@SetPowerSt|
  00038	e5943018	 ldr         r3, [r4, #0x18]
  0003c	e3530000	 cmp         r3, #0
  00040	0a000011	 beq         |$LN4@SetPowerSt|

; 846  :         {
; 847  :             if (SetDevicePowerState(pPdd->parentBus, newPowerState, NULL) &&
; 848  :                 (newPowerState < D3) && (pPdd->currentPowerState >= D3))

  00044	e3a02000	 mov         r2, #0
  00048	e1a01005	 mov         r1, r5
  0004c	e1a00003	 mov         r0, r3
  00050	eb000000	 bl          SetDevicePowerState
  00054	e3500000	 cmp         r0, #0
  00058	0a00000b	 beq         |$LN4@SetPowerSt|
  0005c	e3550003	 cmp         r5, #3
  00060	aa000009	 bge         |$LN4@SetPowerSt|
  00064	e5943048	 ldr         r3, [r4, #0x48]
  00068	e3530003	 cmp         r3, #3
  0006c	ba000006	 blt         |$LN4@SetPowerSt|

; 849  :             {
; 850  :                 if(pPdd->disablePowerManagement == 0)

  00070	e594300c	 ldr         r3, [r4, #0xC]
  00074	e3530000	 cmp         r3, #0
  00078	1a000003	 bne         |$LN4@SetPowerSt|

; 851  :                 {
; 852  :                     USBPeripheralPowerUp(pPdd);

  0007c	e1a00004	 mov         r0, r4
  00080	eb000000	 bl          USBPeripheralPowerUp

; 853  :                     USBPeripheralStart(pPdd);

  00084	e1a00004	 mov         r0, r4
  00088	eb000000	 bl          USBPeripheralStart
  0008c		 |$LN4@SetPowerSt|

; 854  :                 }
; 855  :             }
; 856  :         }
; 857  : 
; 858  :         if ((newPowerState > pPdd->currentPowerState) && (pPdd->parentBus != NULL))

  0008c	e5943048	 ldr         r3, [r4, #0x48]
  00090	e1550003	 cmp         r5, r3
  00094	da000013	 ble         |$LN1@SetPowerSt|
  00098	e5943018	 ldr         r3, [r4, #0x18]
  0009c	e3530000	 cmp         r3, #0
  000a0	0a000010	 beq         |$LN1@SetPowerSt|

; 859  :         {
; 860  :             if (SetDevicePowerState(pPdd->parentBus, newPowerState, NULL) &&
; 861  :                 (newPowerState >= D3) && (pPdd->currentPowerState < D3))

  000a4	e3a02000	 mov         r2, #0
  000a8	e1a01005	 mov         r1, r5
  000ac	e1a00003	 mov         r0, r3
  000b0	eb000000	 bl          SetDevicePowerState
  000b4	e3500000	 cmp         r0, #0
  000b8	0a00000a	 beq         |$LN1@SetPowerSt|
  000bc	e3550003	 cmp         r5, #3
  000c0	ba000008	 blt         |$LN1@SetPowerSt|
  000c4	e5943048	 ldr         r3, [r4, #0x48]
  000c8	e3530003	 cmp         r3, #3
  000cc	aa000005	 bge         |$LN1@SetPowerSt|

; 862  :             {
; 863  : 				USBPeripheralEndSession(pPdd);

  000d0	e1a00004	 mov         r0, r4
  000d4	eb000000	 bl          USBPeripheralEndSession

; 864  : 
; 865  :                 if(pPdd->disablePowerManagement == 0)

  000d8	e594300c	 ldr         r3, [r4, #0xC]
  000dc	e3530000	 cmp         r3, #0

; 866  :                 {
; 867  :                     USBPeripheralPowerDown(pPdd);

  000e0	01a00004	 moveq       r0, r4
  000e4	0b000000	 bleq        USBPeripheralPowerDown
  000e8		 |$LN1@SetPowerSt|

; 868  :                 }
; 869  :             }
; 870  :         }
; 871  : 
; 872  :         pPdd->currentPowerState = newPowerState;

  000e8	e5845048	 str         r5, [r4, #0x48]
  000ec		 |$LN7@SetPowerSt|

; 873  :     }
; 874  : }

  000ec	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000f0	e12fff1e	 bx          lr
  000f4		 |$M48593|

			 ENDP  ; |SetPowerState|

	EXPORT	|ContinueEp0TxTransfer|
	EXPORT	|??_C@_1GE@DIHKIOJL@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAE?$AAp?$AA0?$AAT?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?5?$AAb?$AAu@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FA@PIGNFLGJ@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAE?$AAp?$AA0?$AAT?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?5@| [ DATA ] ; `string'
	IMPORT	|LeaveCriticalSection|
	IMPORT	|EnterCriticalSection|
	IMPORT	|__C_specific_handler|
	IMPORT	|__rt_udiv|

  00000			 AREA	 |.pdata|, PDATA
|$T48628| DCD	|$LN28@ContinueEp|
	DCD	0xc0007e05

  00000			 AREA	 |.pdata|, PDATA
|$T48630| DCD	|$LN15@ContinueEp|
	DCD	0x40000501

  00000			 AREA	 |.xdata|, DATA
|$T48626| DCD	0x1
	DCD	|$LN19@ContinueEp|
	DCD	|$LN20@ContinueEp|
	DCD	|$LN15@ContinueEp|
	DCD	|$LN16@ContinueEp|

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GE@DIHKIOJL@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAE?$AAp?$AA0?$AAT?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?5?$AAb?$AAu@| DCB "C"
	DCB	0x0, "o", 0x0, "n", 0x0, "t", 0x0, "i", 0x0, "n", 0x0, "u"
	DCB	0x0, "e", 0x0, "E", 0x0, "p", 0x0, "0", 0x0, "T", 0x0, "x"
	DCB	0x0, "T", 0x0, "r", 0x0, "a", 0x0, "n", 0x0, "s", 0x0, "f"
	DCB	0x0, "e", 0x0, "r", 0x0, ":", 0x0, " ", 0x0, "C", 0x0, "l"
	DCB	0x0, "i", 0x0, "e", 0x0, "n", 0x0, "t", 0x0, " ", 0x0, "b"
	DCB	0x0, "u", 0x0, "f", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "e", 0x0, "x", 0x0, "c", 0x0, "e", 0x0, "p", 0x0, "t"
	DCB	0x0, "i", 0x0, "o", 0x0, "n", 0x0, "!", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FA@PIGNFLGJ@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAE?$AAp?$AA0?$AAT?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?5@| DCB "C"
	DCB	0x0, "o", 0x0, "n", 0x0, "t", 0x0, "i", 0x0, "n", 0x0, "u"
	DCB	0x0, "e", 0x0, "E", 0x0, "p", 0x0, "0", 0x0, "T", 0x0, "x"
	DCB	0x0, "T", 0x0, "r", 0x0, "a", 0x0, "n", 0x0, "s", 0x0, "f"
	DCB	0x0, "e", 0x0, "r", 0x0, ":", 0x0, " ", 0x0, "T", 0x0, "r"
	DCB	0x0, "a", 0x0, "n", 0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r"
	DCB	0x0, " ", 0x0, "N", 0x0, "U", 0x0, "L", 0x0, "L", 0x0, "!"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T48626|

  00008		 |ContinueEp0TxTransfer| PROC

; 890  : {

  00008		 |$LN28@ContinueEp|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d0003	 stmdb       sp!, {r0, r1}
  00010	e92d5ff0	 stmdb       sp!, {r4 - r12, lr}
  00014	e28db028	 add         r11, sp, #0x28
  00018	e24dd018	 sub         sp, sp, #0x18
  0001c		 |$LN26@ContinueEp|
  0001c	e1a07001	 mov         r7, r1
  00020	e50b7038	 str         r7, [r11, #-0x38]
  00024	e1a08000	 mov         r8, r0
  00028	e58b8000	 str         r8, [r11]

; 891  :     CSL_UsbRegs *pUsbdRegs = pPdd->pUsbdRegs;
; 892  :     UsbFnEp     *pEP = &pPdd->ep[0];

  0002c	e2884fa1	 add         r4, r8, #0xA1, 30
  00030	e50b4030	 str         r4, [r11, #-0x30]
  00034	e598501c	 ldr         r5, [r8, #0x1C]

; 893  :     STransfer   *pTransfer = pEP->pTransfer;

  00038	e5943020	 ldr         r3, [r4, #0x20]

; 894  :     BOOL complete = FALSE;

  0003c	e3a02000	 mov         r2, #0
  00040	e50b203c	 str         r2, [r11, #-0x3C]
  00044	e1b06003	 movs        r6, r3
  00048	e50b6034	 str         r6, [r11, #-0x34]

; 895  :     volatile UINT16 *pepCtrlReg;
; 896  :     UINT16  ep0CsrReg;
; 897  :     DWORD space = 0;
; 898  :     DWORD remain = 0;
; 899  :     UCHAR *pBuffer = NULL;
; 900  : 
; 901  :     DEBUGCHK(endPoint == 0);
; 902  : 
; 903  :     PRINTMSG(ZONE_PDD_EP0, (L"ContinueEp0TxTransfer: "
; 904  :                            L"pTransfer 0x%08x (%d, %d, 0x%0x)\r\n",
; 905  :                            pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 906  :                            pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 907  :                            pTransfer != NULL ? pTransfer->dwUsbError : -1));
; 908  : 
; 909  :     if (pTransfer == NULL)

  0004c	1a000004	 bne         |$LN11@ContinueEp|

; 910  :     {
; 911  :         PRINTMSG(ZONE_ERROR, (L"ContinueEp0TxTransfer: Transfer NULL!\r\n"));

  00050	e59f01b8	 ldr         r0, [pc, #0x1B8]
  00054	eb000000	 bl          NKDbgPrintfW

; 912  :         pEP->epStage = MGC_END0_START;

  00058	e3a03001	 mov         r3, #1
  0005c	e584301c	 str         r3, [r4, #0x1C]

; 913  :         goto done;

  00060	ea000063	 b           |$done$47322|
  00064		 |$LN11@ContinueEp|

; 914  :     }
; 915  : 
; 916  :     /* Enter CriticalSection */
; 917  :     LOCK_ENDPOINT(pPdd);

  00064	e2880e27	 add         r0, r8, #0x27, 28
  00068	eb000000	 bl          EnterCriticalSection

; 918  : 
; 919  :     pepCtrlReg = &pUsbdRegs->EPCSR[ endPoint ].PERI_TXCSR;

  0006c	e0853207	 add         r3, r5, r7, lsl #4
  00070	e2833c05	 add         r3, r3, #5, 24
  00074	e283a002	 add         r10, r3, #2
  00078	e50ba02c	 str         r10, [r11, #-0x2C]

; 920  :     ep0CsrReg = (*pepCtrlReg);

  0007c	e1da50b0	 ldrh        r5, [r10]
  00080	e14b54b0	 strh        r5, [r11, #-0x40]

; 921  : 
; 922  :     /* If the hardware has set the STALL Bits, clearing them before
; 923  :      * will ensure smooth USB Enumeration Process. In case we do
; 924  :      * not perform the same, the current reply being sent to
; 925  :      * the host can be interpreted as Stall or incomplete reply
; 926  :      * write into the EP FIFO and update the TxPktRdy Bits
; 927  :      */
; 928  :     if ((ep0CsrReg & MGC_M_CSR0_P_SENTSTALL) != 0)

  00084	e3150004	 tst         r5, #4

; 929  :     {
; 930  :         ep0CsrReg &= MGC_EP0_STALL_BITS;

  00088	12053024	 andne       r3, r5, #0x24

; 931  :         ep0CsrReg |= MGC_M_CSR0_P_SVDRXPKTRDY;

  0008c	13835040	 orrne       r5, r3, #0x40
  00090	114b54b0	 strneh      r5, [r11, #-0x40]

; 932  :         (*pepCtrlReg) = ep0CsrReg;

  00094	11ca50b0	 strneh      r5, [r10]

; 933  :     }
; 934  : 
; 935  :     /* First time through, check if ZLP is required for this transfer */
; 936  :     if (pTransfer->cbTransferred == 0)

  00098	e5963010	 ldr         r3, [r6, #0x10]
  0009c	e3530000	 cmp         r3, #0
  000a0	1a000011	 bne         |$LN24@ContinueEp|

; 937  :     {
; 938  :         if (pTransfer->cbBuffer > 0 &&
; 939  :             pTransfer->cbBuffer < pPdd->setupRequest.wLength &&
; 940  :             (pTransfer->cbBuffer % pEP->maxPacketSize) == 0)

  000a4	e596300c	 ldr         r3, [r6, #0xC]
  000a8	e1b01003	 movs        r1, r3
  000ac	0a00000a	 beq         |$LN8@ContinueEp|
  000b0	e5d8264a	 ldrb        r2, [r8, #0x64A]
  000b4	e5d8364b	 ldrb        r3, [r8, #0x64B]
  000b8	e1823403	 orr         r3, r2, r3, lsl #8
  000bc	e1510003	 cmp         r1, r3
  000c0	2a000005	 bcs         |$LN8@ContinueEp|
  000c4	e1d400b8	 ldrh        r0, [r4, #8]
  000c8	eb000000	 bl          __rt_udiv
  000cc	e3510000	 cmp         r1, #0

; 941  :         {
; 942  :             pEP->zlpReq = TRUE;

  000d0	03a02001	 moveq       r2, #1
  000d4	05842024	 streq       r2, [r4, #0x24]

; 937  :     {
; 938  :         if (pTransfer->cbBuffer > 0 &&
; 939  :             pTransfer->cbBuffer < pPdd->setupRequest.wLength &&
; 940  :             (pTransfer->cbBuffer % pEP->maxPacketSize) == 0)

  000d8	0a000004	 beq         |$LN25@ContinueEp|
  000dc		 |$LN8@ContinueEp|

; 945  :         {
; 946  :             pEP->zlpReq = FALSE;

  000dc	e3a07000	 mov         r7, #0
  000e0	e5847024	 str         r7, [r4, #0x24]
  000e4	e3a02001	 mov         r2, #1
  000e8	ea000001	 b           |$LN7@ContinueEp|
  000ec		 |$LN24@ContinueEp|

; 943  :         }
; 944  :         else

  000ec	e3a02001	 mov         r2, #1
  000f0		 |$LN25@ContinueEp|
  000f0	e3a07000	 mov         r7, #0
  000f4		 |$LN7@ContinueEp|

; 947  :         }
; 948  :     }
; 949  : 
; 950  :     /* Check if we have Transmitted Entire Packet */
; 951  :     if ((pTransfer->cbTransferred == pTransfer->cbBuffer) && !pEP->zlpReq)

  000f4	e5960010	 ldr         r0, [r6, #0x10]
  000f8	e596100c	 ldr         r1, [r6, #0xC]
  000fc	e1500001	 cmp         r0, r1
  00100	05943024	 ldreq       r3, [r4, #0x24]
  00104	03530000	 cmpeq       r3, #0

; 952  :     {
; 953  :         PRINTMSG(ZONE_PDD_EP0, (L"ContinueEp0TxTransfer: TX complete\r\n"));
; 954  :         pTransfer->dwUsbError = UFN_NO_ERROR;

  00108	05867014	 streq       r7, [r6, #0x14]

; 955  :         complete       = TRUE;
; 956  :         pEP->epStage   = MGC_END0_START;

  0010c	0584201c	 streq       r2, [r4, #0x1C]
  00110	03a03001	 moveq       r3, #1
  00114	050b303c	 streq       r3, [r11, #-0x3C]

; 947  :         }
; 948  :     }
; 949  : 
; 950  :     /* Check if we have Transmitted Entire Packet */
; 951  :     if ((pTransfer->cbTransferred == pTransfer->cbBuffer) && !pEP->zlpReq)

  00118	0a000029	 beq         |$cleanUp$47328|
  0011c		 |$LN19@ContinueEp|

; 957  :         goto cleanUp;
; 958  :     }
; 959  : 
; 960  :     __try
; 961  :     {
; 962  :         pBuffer = (UCHAR*)pTransfer->pvBuffer + pTransfer->cbTransferred;

  0011c	e5962004	 ldr         r2, [r6, #4]

; 963  :         space = pTransfer->cbBuffer - pTransfer->cbTransferred;
; 964  : 
; 965  :         /* How many bytes we can send just now? */
; 966  :         remain = pEP->maxPacketSize;

  00120	e1d490b8	 ldrh        r9, [r4, #8]
  00124	e0413000	 sub         r3, r1, r0

; 967  :         if (remain > space) remain = space;

  00128	e1590003	 cmp         r9, r3
  0012c	81a09003	 movhi       r9, r3

; 968  : 
; 969  :         /* Final ZLP? */
; 970  :         if (remain == 0 && pEP->zlpReq)

  00130	e3590000	 cmp         r9, #0
  00134	1a000002	 bne         |$LN3@ContinueEp|
  00138	e5943024	 ldr         r3, [r4, #0x24]
  0013c	e3530000	 cmp         r3, #0

; 971  :             pEP->zlpReq = FALSE;

  00140	15847024	 strne       r7, [r4, #0x24]
  00144		 |$LN3@ContinueEp|

; 972  : 
; 973  : 		/* Write data to FIFO */
; 974  :         PRINTMSG(ZONE_PDD_EP0, (L"ContinueEp0TxTransfer: Writing %d bytes to FIFO\r\n", remain));
; 975  : 		WriteFIFO(pPdd, (UCHAR)endPoint, pBuffer, remain);

  00144	e1a03009	 mov         r3, r9
  00148	e0822000	 add         r2, r2, r0
  0014c	e51b1038	 ldr         r1, [r11, #-0x38]
  00150	e20110ff	 and         r1, r1, #0xFF
  00154	e1a00008	 mov         r0, r8
  00158	eb000000	 bl          WriteFIFO

; 976  : 
; 977  : 		/* We transfered some data */
; 978  :         //pTransfer->cbTransferred = pTransfer->cbBuffer - space;
; 979  :         pTransfer->cbTransferred += remain;

  0015c	e5963010	 ldr         r3, [r6, #0x10]
  00160	e0833009	 add         r3, r3, r9
  00164	e5863010	 str         r3, [r6, #0x10]
  00168		 |$LN20@ContinueEp|

; 980  :     }

  00168	ea00000b	 b           |$LN21@ContinueEp|
  0016c		 |$LN16@ContinueEp|

; 982  :     {
; 983  :         pTransfer->dwUsbError = UFN_CLIENT_BUFFER_ERROR;

  0016c	e51b6034	 ldr         r6, [r11, #-0x34]

; 984  :         complete = TRUE;
; 985  :         PRINTMSG(ZONE_ERROR, (L"ContinueEp0TxTransfer: Client buffer exception!\r\n"));

  00170	e59f0094	 ldr         r0, [pc, #0x94]
  00174	e3a03f41	 mov         r3, #0x41, 30
  00178	e5863014	 str         r3, [r6, #0x14]
  0017c	e3a03001	 mov         r3, #1
  00180	e50b303c	 str         r3, [r11, #-0x3C]
  00184	eb000000	 bl          NKDbgPrintfW
  00188	e59b8000	 ldr         r8, [r11]
  0018c	e51b4030	 ldr         r4, [r11, #-0x30]
  00190	e51ba02c	 ldr         r10, [r11, #-0x2C]
  00194	e15b54b0	 ldrh        r5, [r11, #-0x40]
  00198	e3a07000	 mov         r7, #0
  0019c		 |$LN21@ContinueEp|

; 986  :     }
; 987  : 
; 988  :     /* Inform the USB Core that There is data in the FIFO */
; 989  :     ep0CsrReg &= MGC_EP0_STALL_BITS;
; 990  :     ep0CsrReg |= MGC_M_CSR0_TXPKTRDY;
; 991  : 
; 992  :     /* Check if we have Transmitted Entire Packet */
; 993  :     if (pTransfer->cbTransferred == pTransfer->cbBuffer && !pEP->zlpReq)

  0019c	e5960010	 ldr         r0, [r6, #0x10]
  001a0	e596100c	 ldr         r1, [r6, #0xC]
  001a4	e2053024	 and         r3, r5, #0x24
  001a8	e3835002	 orr         r5, r3, #2
  001ac	e1500001	 cmp         r0, r1
  001b0	05943024	 ldreq       r3, [r4, #0x24]
  001b4	03530000	 cmpeq       r3, #0

; 994  :     {
; 995  :         ep0CsrReg |= MGC_M_CSR0_P_DATAEND;
; 996  : 
; 997  :         /* Now wait for final interrupt before completing TX */
; 998  :         pEP->epStage = MGC_END0_STAGE_STATUSOUT;

  001b8	03a03005	 moveq       r3, #5
  001bc	0584301c	 streq       r3, [r4, #0x1C]
  001c0	03855008	 orreq       r5, r5, #8
  001c4		 |$cleanUp$47328|

; 999  :     }
; 1000 : 
; 1001 : cleanUp:
; 1002 :     (*pepCtrlReg) = ep0CsrReg;
; 1003 : 
; 1004 :     /* Leave CriticalSection */
; 1005 :     UNLOCK_ENDPOINT(pPdd);

  001c4	e2880e27	 add         r0, r8, #0x27, 28
  001c8	e1ca50b0	 strh        r5, [r10]
  001cc	eb000000	 bl          LeaveCriticalSection

; 1006 : 
; 1007 :     PRINTMSG(FALSE, /*TRUE, ZONE_SEND*/
; 1008 :         (L"Wrote 0x%02x into EP%u_CSR_REG\r\n", ep0CsrReg, endPoint));
; 1009 : 
; 1010 :     /* If transaction is complete we should tell MDD */
; 1011 :     if (complete == TRUE)

  001d0	e51b303c	 ldr         r3, [r11, #-0x3C]
  001d4	e3530001	 cmp         r3, #1

; 1012 :     {
; 1013 :         PRINTMSG(ZONE_PDD_EP0,
; 1014 :                  (L"ContinueEp0TxTransfer: "
; 1015 :                   L"pTransfer 0x%08x (%d, %d, 0x%0x) - notify complete\r\n",
; 1016 :                   pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 1017 :                   pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 1018 :                   pTransfer != NULL ? pTransfer->dwUsbError : -1));
; 1019 : 
; 1020 :         pEP->pTransfer = NULL;

  001d8	05847020	 streq       r7, [r4, #0x20]

; 1021 :         pPdd->pfnNotify (pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE,
; 1022 :                          (DWORD)pTransfer);

  001dc	05980010	 ldreq       r0, [r8, #0x10]
  001e0	05983014	 ldreq       r3, [r8, #0x14]
  001e4	01a02006	 moveq       r2, r6
  001e8	03a01064	 moveq       r1, #0x64
  001ec	01a0e00f	 moveq       lr, pc
  001f0	012fff13	 bxeq        r3
  001f4		 |$done$47322|

; 1023 :     }
; 1024 : 
; 1025 : done:
; 1026 :     return ;
; 1027 : }

  001f4	e24bd028	 sub         sp, r11, #0x28
  001f8	e89d6ff0	 ldmia       sp, {r4 - r11, sp, lr}
  001fc	e12fff1e	 bx          lr

			 ENDP  ; |ContinueEp0TxTransfer|

  00200		 |$LN15@ContinueEp|
  00200		 |$LN27@ContinueEp|

; 981  :     __except(EXCEPTION_EXECUTE_HANDLER)

  00200	e52de004	 str         lr, [sp, #-4]!
  00204		 |$LN18@ContinueEp|
  00204		 |$LN30@ContinueEp|
  00204	e3a00001	 mov         r0, #1
  00208		 |$LN17@ContinueEp|
  00208	e49df004	 ldr         pc, [sp], #4
  0020c		 |$LN32@ContinueEp|
  0020c		 |$LN33@ContinueEp|
  0020c	00000000	 DCD         |??_C@_1GE@DIHKIOJL@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAE?$AAp?$AA0?$AAT?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?5?$AAb?$AAu@|
  00210		 |$LN34@ContinueEp|
  00210	00000000	 DCD         |??_C@_1FA@PIGNFLGJ@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAE?$AAp?$AA0?$AAT?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?5@|
  00214		 |$LN31@ContinueEp|
  00214		 |$LN29@ContinueEp|
	EXPORT	|ContinueTxTransfer|
	EXPORT	|??_C@_1GA@LDKCJJJF@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AA0?$AAT?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?5?$AAb?$AAu?$AAf?$AAf@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HI@PMGODKCP@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAT?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FI@HNJALGAC@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAT?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AAT?$AAr?$AAa?$AAn?$AAs@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T48667| DCD	|$LN22@ContinueTx|
	DCD	0xc0007405

  00000			 AREA	 |.pdata|, PDATA
|$T48669| DCD	|$LN11@ContinueTx|
	DCD	0x40000601

  00000			 AREA	 |.xdata|, DATA
|$T48665| DCD	0x1
	DCD	|$LN15@ContinueTx|
	DCD	|$LN16@ContinueTx|
	DCD	|$LN11@ContinueTx|
	DCD	|$LN12@ContinueTx|

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GA@LDKCJJJF@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AA0?$AAT?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?5?$AAb?$AAu?$AAf?$AAf@| DCB "C"
	DCB	0x0, "o", 0x0, "n", 0x0, "t", 0x0, "i", 0x0, "n", 0x0, "u"
	DCB	0x0, "e", 0x0, "0", 0x0, "T", 0x0, "x", 0x0, "T", 0x0, "r"
	DCB	0x0, "a", 0x0, "n", 0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r"
	DCB	0x0, ":", 0x0, " ", 0x0, "C", 0x0, "l", 0x0, "i", 0x0, "e"
	DCB	0x0, "n", 0x0, "t", 0x0, " ", 0x0, "b", 0x0, "u", 0x0, "f"
	DCB	0x0, "f", 0x0, "e", 0x0, "r", 0x0, " ", 0x0, "e", 0x0, "x"
	DCB	0x0, "c", 0x0, "e", 0x0, "p", 0x0, "t", 0x0, "i", 0x0, "o"
	DCB	0x0, "n", 0x0, "!", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HI@PMGODKCP@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAT?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr@| DCB "C"
	DCB	0x0, "o", 0x0, "n", 0x0, "t", 0x0, "i", 0x0, "n", 0x0, "u"
	DCB	0x0, "e", 0x0, "T", 0x0, "x", 0x0, "T", 0x0, "r", 0x0, "a"
	DCB	0x0, "n", 0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, ":"
	DCB	0x0, " ", 0x0, "E", 0x0, "P", 0x0, " ", 0x0, "%", 0x0, "d"
	DCB	0x0, ",", 0x0, " ", 0x0, "E", 0x0, "r", 0x0, "r", 0x0, "o"
	DCB	0x0, "r", 0x0, ",", 0x0, " ", 0x0, "p", 0x0, "a", 0x0, "c"
	DCB	0x0, "k", 0x0, "e", 0x0, "t", 0x0, " ", 0x0, "T", 0x0, "X"
	DCB	0x0, " ", 0x0, "n", 0x0, "o", 0x0, "t", 0x0, " ", 0x0, "c"
	DCB	0x0, "o", 0x0, "m", 0x0, "p", 0x0, "l", 0x0, "e", 0x0, "t"
	DCB	0x0, "e", 0x0, "!", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FI@HNJALGAC@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAT?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AAT?$AAr?$AAa?$AAn?$AAs@| DCB "C"
	DCB	0x0, "o", 0x0, "n", 0x0, "t", 0x0, "i", 0x0, "n", 0x0, "u"
	DCB	0x0, "e", 0x0, "T", 0x0, "x", 0x0, "T", 0x0, "r", 0x0, "a"
	DCB	0x0, "n", 0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, ":"
	DCB	0x0, " ", 0x0, "E", 0x0, "P", 0x0, " ", 0x0, "%", 0x0, "d"
	DCB	0x0, ",", 0x0, " ", 0x0, "T", 0x0, "r", 0x0, "a", 0x0, "n"
	DCB	0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, " ", 0x0, "N"
	DCB	0x0, "U", 0x0, "L", 0x0, "L", 0x0, "!", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T48665|

  00008		 |ContinueTxTransfer| PROC

; 1043 : {

  00008		 |$LN22@ContinueTx|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d0003	 stmdb       sp!, {r0, r1}
  00010	e92d5ff0	 stmdb       sp!, {r4 - r12, lr}
  00014	e28db028	 add         r11, sp, #0x28
  00018	e24dd018	 sub         sp, sp, #0x18
  0001c		 |$LN20@ContinueTx|
  0001c	e1a07001	 mov         r7, r1
  00020	e1a05000	 mov         r5, r0
  00024	e58b5000	 str         r5, [r11]

; 1044 :     CSL_UsbRegs *pUsbdRegs = pPdd->pUsbdRegs;
; 1045 :     UsbFnEp     *pEP = &pPdd->ep[endPoint];

  00028	e0673207	 rsb         r3, r7, r7, lsl #4
  0002c	e0853103	 add         r3, r5, r3, lsl #2
  00030	e2834fa1	 add         r4, r3, #0xA1, 30
  00034	e50b4030	 str         r4, [r11, #-0x30]
  00038	e595801c	 ldr         r8, [r5, #0x1C]
  0003c	e50b803c	 str         r8, [r11, #-0x3C]

; 1046 :     STransfer   *pTransfer = pEP->pTransfer;

  00040	e5943020	 ldr         r3, [r4, #0x20]

; 1047 :     BOOL complete = FALSE;

  00044	e1b06003	 movs        r6, r3
  00048	e50b6034	 str         r6, [r11, #-0x34]

; 1048 :     volatile UINT16 *pepCtrlReg;
; 1049 :     UINT16  epCsrReg;
; 1050 : 	DWORD space = 0;
; 1051 :     DWORD count = 0;
; 1052 :     UCHAR *pBuffer = NULL;
; 1053 : 
; 1054 :     /* EP0 has its own TX handler */
; 1055 :     DEBUGCHK(endPoint != 0);
; 1056 : 
; 1057 :     PRINTMSG(ZONE_PDD_TX,
; 1058 :              (L"ContinueTxTransfer: EP %d, pTransfer 0x%08x (%d, %d, 0x%0x)\r\n",
; 1059 :               endPoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 1060 :               pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 1061 :               pTransfer != NULL ? pTransfer->dwUsbError : -1));
; 1062 : 
; 1063 :     if (pTransfer == NULL)

  0004c	1a000004	 bne         |$LN7@ContinueTx|

; 1064 :     {
; 1065 :         PRINTMSG(ZONE_ERROR, (L"ContinueTxTransfer: EP %d, Transfer NULL!\r\n", endPoint));

  00050	e59f0194	 ldr         r0, [pc, #0x194]
  00054	eb000000	 bl          NKDbgPrintfW

; 1066 :         pEP->epStage = MGC_END0_START;

  00058	e3a03001	 mov         r3, #1
  0005c	e584301c	 str         r3, [r4, #0x1C]

; 1067 :         goto done;

  00060	ea000059	 b           |$done$47364|
  00064		 |$LN7@ContinueTx|

; 1068 :     }
; 1069 : 
; 1070 :     /* Enter CriticalSection */
; 1071 :     LOCK_ENDPOINT(pPdd);

  00064	e2850e27	 add         r0, r5, #0x27, 28
  00068	eb000000	 bl          EnterCriticalSection

; 1072 : 
; 1073 :     pEP->usingDma = FALSE;
; 1074 : 
; 1075 :     pepCtrlReg = &pUsbdRegs->EPCSR[ endPoint ].PERI_TXCSR;

  0006c	e0883207	 add         r3, r8, r7, lsl #4
  00070	e2833c05	 add         r3, r3, #5, 24
  00074	e283e002	 add         lr, r3, #2
  00078	e50be038	 str         lr, [r11, #-0x38]
  0007c	e50be02c	 str         lr, [r11, #-0x2C]
  00080	e3a0a000	 mov         r10, #0
  00084	e584a028	 str         r10, [r4, #0x28]

; 1076 :     epCsrReg = (*pepCtrlReg);

  00088	e1de90b0	 ldrh        r9, [lr]

; 1077 : 
; 1078 :     /* Is this final interrupt of transfer? */
; 1079 :     if ((pTransfer->cbTransferred == pTransfer->cbBuffer) &&
; 1080 :         (pEP->zeroLength == FALSE))

  0008c	e5962010	 ldr         r2, [r6, #0x10]
  00090	e596300c	 ldr         r3, [r6, #0xC]
  00094	e14b94b0	 strh        r9, [r11, #-0x40]
  00098	e1520003	 cmp         r2, r3
  0009c	1a00000d	 bne         |$LN6@ContinueTx|
  000a0	e5943014	 ldr         r3, [r4, #0x14]
  000a4	e3530000	 cmp         r3, #0
  000a8	1a00000a	 bne         |$LN6@ContinueTx|

; 1081 :     {
; 1082 :         PRINTMSG(ZONE_PDD_TX, (L"ContinueTxTransfer: EP %d, TX complete\r\n", endPoint));
; 1083 :         pTransfer->dwUsbError = UFN_NO_ERROR;
; 1084 :         complete = TRUE;
; 1085 :         pEP->epStage = MGC_END0_START;
; 1086 :         epCsrReg &= ~(MGC_M_TXCSR_FIFONOTEMPTY | MGC_M_TXCSR_P_UNDERRUN);
; 1087 : 
; 1088 : #ifdef CPPI_DMA_SUPPORT
; 1089 :         /* For DMA case, TX interrupt only enabled when required */
; 1090 : 		pUsbdRegs->EP_INTMSKCLRR = (1 << endPoint) << USB_OTG_TXINT_SHIFT;

  000ac	e3a03001	 mov         r3, #1
  000b0	e3a01cff	 mov         r1, #0xFF, 24
  000b4	e1a02713	 mov         r2, r3, lsl r7
  000b8	e3a00001	 mov         r0, #1
  000bc	e586a014	 str         r10, [r6, #0x14]
  000c0	e38130f9	 orr         r3, r1, #0xF9
  000c4	e584001c	 str         r0, [r4, #0x1C]
  000c8	e5882034	 str         r2, [r8, #0x34]
  000cc	e3a07001	 mov         r7, #1
  000d0	e0093003	 and         r3, r9, r3

; 1091 : #endif
; 1092 : 
; 1093 :         /* NOTE: Class driver is responsible for sending zero len packet if
; 1094 :          * the transfer was a multiple of the FIFO Size.
; 1095 :          */
; 1096 :         goto cleanUp;

  000d4	ea000031	 b           |$cleanUp$47366|
  000d8		 |$LN6@ContinueTx|

; 1097 :     }
; 1098 : 
; 1099 :     /* Packet TX should always have completed */
; 1100 :     if ((epCsrReg & MGC_M_TXCSR_TXPKTRDY) != 0)

  000d8	e3190001	 tst         r9, #1
  000dc	0a000005	 beq         |$LN5@ContinueTx|

; 1101 :     {
; 1102 :         PRINTMSG(ZONE_ERROR, (L"ContinueTxTransfer: EP %d, Error, packet TX not complete!\r\n", endPoint));

  000e0	e59f0100	 ldr         r0, [pc, #0x100]
  000e4	e1a01007	 mov         r1, r7
  000e8	eb000000	 bl          NKDbgPrintfW

; 1103 :         DEBUGCHK(0);
; 1104 :         UNLOCK_ENDPOINT (pPdd);

  000ec	e2850e27	 add         r0, r5, #0x27, 28
  000f0	eb000000	 bl          LeaveCriticalSection

; 1105 :         goto done;

  000f4	ea000034	 b           |$done$47364|
  000f8		 |$LN5@ContinueTx|

; 1106 :     }
; 1107 : 
; 1108 :     /* This EP has entered the TX State wherein it Transmits
; 1109 :      * data to the Host. Depending on whether the Size fits
; 1110 :      * the FIFO in one single write or multiple writes, the EP
; 1111 :      * will return back to IDLE in this iteration itself or
; 1112 :      * further iterations
; 1113 :      */
; 1114 :     pEP->epStage = MGC_END0_STAGE_TX;

  000f8	e3a03002	 mov         r3, #2
  000fc	e584301c	 str         r3, [r4, #0x1C]
  00100		 |$LN15@ContinueTx|

; 1115 : 
; 1116 :     __try
; 1117 :     {
; 1118 :         pBuffer = (UCHAR*)pTransfer->pvBuffer + pTransfer->cbTransferred;

  00100	e5962010	 ldr         r2, [r6, #0x10]

; 1119 :         space = pTransfer->cbBuffer - pTransfer->cbTransferred;

  00104	e596300c	 ldr         r3, [r6, #0xC]
  00108	e5961004	 ldr         r1, [r6, #4]

; 1120 : 
; 1121 :         /* Non Zero Endpoint: No zero length padding needed. */
; 1122 :         pEP->zeroLength = FALSE;

  0010c	e584a014	 str         r10, [r4, #0x14]
  00110	e0433002	 sub         r3, r3, r2

; 1123 : 
; 1124 :         /* How many bytes we can send just now? */
; 1125 :         count = pEP->maxPacketSize;

  00114	e1d480b8	 ldrh        r8, [r4, #8]

; 1126 :         if (count > space) count = space;

  00118	e1580003	 cmp         r8, r3
  0011c	81a08003	 movhi       r8, r3

; 1127 : 
; 1128 :         PRINTMSG(ZONE_PDD_TX,
; 1129 :                  (L"ContinueTxTransfer: EP %d, Writing %d bytes, maxSize %d, left %d\r\n",
; 1130 :                   endPoint, count, pEP->maxPacketSize, space));
; 1131 : 
; 1132 :         /* Write data to FIFO */
; 1133 : 		WriteFIFO(pPdd, (UCHAR)endPoint, pBuffer, count);

  00120	e1a03008	 mov         r3, r8
  00124	e0812002	 add         r2, r1, r2
  00128	e20710ff	 and         r1, r7, #0xFF
  0012c	e1a00005	 mov         r0, r5
  00130	eb000000	 bl          WriteFIFO

; 1134 : 
; 1135 : 		/*
; 1136 :           * We will update the pTransfer->cbTransferred here
; 1137 :           * because we would like to receive an ACK from the Host
; 1138 :           * before declaring that the data was sent successfully
; 1139 :           * to the Host. It results in a one interrupt cycle
; 1140 :           * delay
; 1141 :         */
; 1142 :         //pTransfer->cbTransferred = pTransfer->cbBuffer - space;
; 1143 :         pTransfer->cbTransferred += count;

  00134	e5963010	 ldr         r3, [r6, #0x10]

; 1144 : 
; 1145 : #ifdef CPPI_DMA_SUPPORT
; 1146 :         /* For DMA case, TX interrupt only enabled when required */
; 1147 : 		pUsbdRegs->EP_INTMSKSETR = (1 << endPoint) << USB_OTG_TXINT_SHIFT;

  00138	e3a02001	 mov         r2, #1
  0013c	e1a02712	 mov         r2, r2, lsl r7
  00140	e0833008	 add         r3, r3, r8
  00144	e5863010	 str         r3, [r6, #0x10]
  00148	e51b303c	 ldr         r3, [r11, #-0x3C]
  0014c	e5832030	 str         r2, [r3, #0x30]
  00150		 |$LN16@ContinueTx|

; 1148 : #endif
; 1149 :     }

  00150	e3a07000	 mov         r7, #0
  00154	e51be038	 ldr         lr, [r11, #-0x38]
  00158	ea00000a	 b           |$LN17@ContinueTx|
  0015c		 |$LN12@ContinueTx|

; 1151 :     {
; 1152 :         pTransfer->dwUsbError = UFN_CLIENT_BUFFER_ERROR;

  0015c	e51b6034	 ldr         r6, [r11, #-0x34]

; 1153 :         complete = TRUE;
; 1154 :         PRINTMSG(ZONE_ERROR, (L"Continue0TxTransfer: Client buffer exception!\r\n"));

  00160	e59f007c	 ldr         r0, [pc, #0x7C]
  00164	e3a03f41	 mov         r3, #0x41, 30
  00168	e5863014	 str         r3, [r6, #0x14]
  0016c	e3a07001	 mov         r7, #1
  00170	eb000000	 bl          NKDbgPrintfW
  00174	e59b5000	 ldr         r5, [r11]
  00178	e51b4030	 ldr         r4, [r11, #-0x30]
  0017c	e51be02c	 ldr         lr, [r11, #-0x2C]
  00180	e15b94b0	 ldrh        r9, [r11, #-0x40]
  00184	e3a0a000	 mov         r10, #0
  00188		 |$LN17@ContinueTx|
  00188	e3a03c4f	 mov         r3, #0x4F, 24

; 1155 :     }
; 1156 : 
; 1157 :     epCsrReg &= ~(MGC_M_TXCSR_AUTOSET | MGC_M_TXCSR_DMAENAB);
; 1158 :     epCsrReg &= ~(MGC_M_TXCSR_FIFONOTEMPTY | MGC_M_TXCSR_P_UNDERRUN);

  0018c	e38330f8	 orr         r3, r3, #0xF8
  00190	e3a02a02	 mov         r2, #2, 20
  00194	e0091003	 and         r1, r9, r3

; 1159 :     epCsrReg |= (MGC_M_TXCSR_MODE | MGC_M_TXCSR_TXPKTRDY);

  00198	e3823001	 orr         r3, r2, #1
  0019c	e1813003	 orr         r3, r1, r3
  001a0		 |$cleanUp$47366|

; 1160 : 
; 1161 :     /* Check for the current transfer Size. For all small sized pkts < 64
; 1162 :      * this condition will become TRUE for the first iteration itself.
; 1163 :      * However, when the MDD Tries to send 512 bytes of data,
; 1164 :      * this logic will become TRUE only for the last chunk.
; 1165 :      */
; 1166 : 
; 1167 :     /* Check if we have Transmitted Entire Packet */
; 1168 :     if (pTransfer->cbTransferred == pTransfer->cbBuffer)
; 1169 :     {
; 1170 :         /* Now wait for final interrupt before completing TX */
; 1171 :         PRINTMSG(ZONE_PDD_TX, (L"ContinueTxTransfer: EP %d, all bytes written\r\n", endPoint));
; 1172 :     }
; 1173 : 
; 1174 : cleanUp:
; 1175 : 
; 1176 :     (*pepCtrlReg) = epCsrReg;
; 1177 : 
; 1178 :     /* Leave CriticalSection */
; 1179 :     UNLOCK_ENDPOINT(pPdd);

  001a0	e2850e27	 add         r0, r5, #0x27, 28
  001a4	e1ce30b0	 strh        r3, [lr]
  001a8	eb000000	 bl          LeaveCriticalSection

; 1180 : 
; 1181 :     PRINTMSG(FALSE, /*TRUE ZONE_SEND, (endPoint !=0)*/
; 1182 :         (L"Wrote 0x%02x into EP%u_CSR\r\n", epCsrReg, endPoint));
; 1183 : 
; 1184 :     /* If transaction is complete we should tell MDD */
; 1185 :     if (complete == TRUE)

  001ac	e3570001	 cmp         r7, #1

; 1186 :     {
; 1187 :         PRINTMSG(ZONE_PDD_TX,
; 1188 :                  (L"ContinueTxTransfer: "
; 1189 :                   L"EP %d, pTransfer 0x%08x (%d, %d, 0x%0x) - notify complete\r\n",
; 1190 :                   endPoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 1191 :                   pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 1192 :                   pTransfer != NULL ? pTransfer->dwUsbError : -1));
; 1193 :         pEP->pTransfer = NULL;

  001b0	0584a020	 streq       r10, [r4, #0x20]

; 1194 :         pPdd->pfnNotify (pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE,
; 1195 :                          (DWORD)pTransfer);

  001b4	05950010	 ldreq       r0, [r5, #0x10]
  001b8	05953014	 ldreq       r3, [r5, #0x14]
  001bc	01a02006	 moveq       r2, r6
  001c0	03a01064	 moveq       r1, #0x64
  001c4	01a0e00f	 moveq       lr, pc
  001c8	012fff13	 bxeq        r3
  001cc		 |$done$47364|

; 1196 :     }
; 1197 : 
; 1198 : done:
; 1199 :     return;
; 1200 : }

  001cc	e24bd028	 sub         sp, r11, #0x28
  001d0	e89d6ff0	 ldmia       sp, {r4 - r11, sp, lr}
  001d4	e12fff1e	 bx          lr

			 ENDP  ; |ContinueTxTransfer|

  001d8		 |$LN11@ContinueTx|
  001d8		 |$LN21@ContinueTx|

; 1150 :     __except(EXCEPTION_EXECUTE_HANDLER)

  001d8	e52de004	 str         lr, [sp, #-4]!
  001dc		 |$LN14@ContinueTx|
  001dc		 |$LN24@ContinueTx|
  001dc	e3a00001	 mov         r0, #1
  001e0		 |$LN13@ContinueTx|
  001e0	e49df004	 ldr         pc, [sp], #4
  001e4		 |$LN26@ContinueTx|
  001e4		 |$LN27@ContinueTx|
  001e4	00000000	 DCD         |??_C@_1GA@LDKCJJJF@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AA0?$AAT?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?5?$AAb?$AAu?$AAf?$AAf@|
  001e8		 |$LN28@ContinueTx|
  001e8	00000000	 DCD         |??_C@_1HI@PMGODKCP@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAT?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr@|
  001ec		 |$LN29@ContinueTx|
  001ec	00000000	 DCD         |??_C@_1FI@HNJALGAC@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAT?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AAT?$AAr?$AAa?$AAn?$AAs@|
  001f0		 |$LN25@ContinueTx|
  001f0		 |$LN23@ContinueTx|

  00000			 AREA	 |.pdata|, PDATA
|$T48687| DCD	|$LN6@StartRxTra|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |StartRxTransfer| PROC

; 1219 : {

  00000		 |$LN6@StartRxTra|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M48684|
  00004	e3510000	 cmp         r1, #0

; 1220 :     CSL_UsbRegs     *pUsbdRegs = pPdd->pUsbdRegs;
; 1221 :     UsbFnEp         *pEP       = &pPdd->ep[endPoint];
; 1222 : 
; 1223 : #ifdef DEBUG
; 1224 : 	STransfer		*pTransfer = pEP->pTransfer;
; 1225 : 
; 1226 :     PRINTMSG(ZONE_PDD_RX,
; 1227 :              (L"StartRxTransfer: EP %d, pTransfer 0x%08x (%d, %d, 0x%0x)\r\n",
; 1228 :               endPoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 1229 :               pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 1230 :               pTransfer != NULL ? pTransfer->dwUsbError : -1));
; 1231 : #endif
; 1232 : 
; 1233 :     if (endPoint != 0)
; 1234 :     {
; 1235 :         pEP->usingDma = FALSE;
; 1236 : 
; 1237 :         /* Enable RX interrupt now we have a transfer for this EP */
; 1238 :         pUsbdRegs->EP_INTMSKSETR = (1 << endPoint) << USB_OTG_RXINT_SHIFT;

  00008	13a03001	 movne       r3, #1
  0000c	11a02113	 movne       r2, r3, lsl r1
  00010	10613201	 rsbne       r3, r1, r1, lsl #4
  00014	e590e01c	 ldr         lr, [r0, #0x1C]
  00018	10801103	 addne       r1, r0, r3, lsl #2
  0001c	13a00000	 movne       r0, #0
  00020	11a03802	 movne       r3, r2, lsl #16
  00024	158102ac	 strne       r0, [r1, #0x2AC]
  00028	158e3030	 strne       r3, [lr, #0x30]

; 1239 :     }
; 1240 : }

  0002c	e49de004	 ldr         lr, [sp], #4
  00030	e12fff1e	 bx          lr
  00034		 |$M48685|

			 ENDP  ; |StartRxTransfer|

	EXPORT	|ContinueEp0RxTransfer|
	EXPORT	|??_C@_1GE@FICDPAIG@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAE?$AAp?$AA0?$AAR?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?5?$AAb?$AAu@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T48723| DCD	|$LN27@ContinueEp@2|
	DCD	0xc0006705

  00000			 AREA	 |.pdata|, PDATA
|$T48725| DCD	|$LN14@ContinueEp@2|
	DCD	0x40000401

  00000			 AREA	 |.xdata|, DATA
|$T48721| DCD	0x1
	DCD	|$LN18@ContinueEp@2|
	DCD	|$LN19@ContinueEp@2|
	DCD	|$LN14@ContinueEp@2|
	DCD	|$LN15@ContinueEp@2|

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GE@FICDPAIG@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAE?$AAp?$AA0?$AAR?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?5?$AAb?$AAu@| DCB "C"
	DCB	0x0, "o", 0x0, "n", 0x0, "t", 0x0, "i", 0x0, "n", 0x0, "u"
	DCB	0x0, "e", 0x0, "E", 0x0, "p", 0x0, "0", 0x0, "R", 0x0, "x"
	DCB	0x0, "T", 0x0, "r", 0x0, "a", 0x0, "n", 0x0, "s", 0x0, "f"
	DCB	0x0, "e", 0x0, "r", 0x0, ":", 0x0, " ", 0x0, "C", 0x0, "l"
	DCB	0x0, "i", 0x0, "e", 0x0, "n", 0x0, "t", 0x0, " ", 0x0, "b"
	DCB	0x0, "u", 0x0, "f", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "e", 0x0, "x", 0x0, "c", 0x0, "e", 0x0, "p", 0x0, "t"
	DCB	0x0, "i", 0x0, "o", 0x0, "n", 0x0, "!", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T48721|

  00008		 |ContinueEp0RxTransfer| PROC

; 1260 : {

  00008		 |$LN27@ContinueEp@2|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d0003	 stmdb       sp!, {r0, r1}
  00010	e92d5ff0	 stmdb       sp!, {r4 - r12, lr}
  00014	e28db028	 add         r11, sp, #0x28
  00018	e24dd014	 sub         sp, sp, #0x14
  0001c		 |$LN25@ContinueEp@2|
  0001c	e1a0a001	 mov         r10, r1
  00020	e1a08000	 mov         r8, r0
  00024	e58b8000	 str         r8, [r11]

; 1261 :     CSL_UsbRegs    *pUsbRegs     = pPdd->pUsbdRegs;
; 1262 :     UsbFnEp        *pEP           = &pPdd->ep[endPoint];

  00028	e06a320a	 rsb         r3, r10, r10, lsl #4
  0002c	e0883103	 add         r3, r8, r3, lsl #2
  00030	e2836fa1	 add         r6, r3, #0xA1, 30
  00034	e50b602c	 str         r6, [r11, #-0x2C]

; 1263 :     STransfer *pTransfer = pEP->pTransfer;
; 1264 :     BOOL complete = FALSE;
; 1265 :     volatile UINT16 *pepCtrlReg;
; 1266 :     UINT16  epCsrReg;
; 1267 :     UINT16  rcvSize = 0;
; 1268 :     DWORD space;
; 1269 :     DWORD count;
; 1270 :     UCHAR *pBuffer = NULL;
; 1271 : 	WORD maxSize;
; 1272 : 
; 1273 :     PRINTMSG(ZONE_PDD_EP0,
; 1274 :              (L"ContinueEp0RxTransfer: pTransfer 0x%08x (%d, %d, 0x%0x)\r\n",
; 1275 :               pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 1276 :               pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 1277 :               pTransfer != NULL ? pTransfer->dwUsbError : -1));
; 1278 : 
; 1279 :     /* Enter CriticalSection */
; 1280 :     LOCK_ENDPOINT(pPdd);

  00038	e2880e27	 add         r0, r8, #0x27, 28
  0003c	e5965020	 ldr         r5, [r6, #0x20]
  00040	e598401c	 ldr         r4, [r8, #0x1C]
  00044	e3a07000	 mov         r7, #0
  00048	e50b5034	 str         r5, [r11, #-0x34]
  0004c	eb000000	 bl          EnterCriticalSection

; 1281 : 
; 1282 :     pepCtrlReg = &pUsbRegs->EPCSR[ endPoint ].PERI_TXCSR;

  00050	e084220a	 add         r2, r4, r10, lsl #4
  00054	e2823c05	 add         r3, r2, #5, 24
  00058	e50b3038	 str         r3, [r11, #-0x38]

; 1283 : 
; 1284 :     epCsrReg = (*pepCtrlReg);

  0005c	e1d330b2	 ldrh        r3, [r3, #2]
  00060	e14b33bc	 strh        r3, [r11, #-0x3C]

; 1285 : 
; 1286 :     /* Got EP 0 interrupt before MDD issued transfer? */
; 1287 :     if (pTransfer == NULL)

  00064	e3550000	 cmp         r5, #0
  00068	0a00003f	 beq         |$LN24@ContinueEp@2|

; 1288 :     {
; 1289 :         PRINTMSG(ZONE_PDD_EP0, (L"ContinueEp0RxTransfer: No transfer yet"));
; 1290 :         goto cleanUp;
; 1291 :     }
; 1292 : 
; 1293 :     /* Is this a status phase (IN) interrupt for EP 0? */
; 1294 :     if (pEP->epStage == MGC_END0_STAGE_STATUSIN)

  0006c	e596301c	 ldr         r3, [r6, #0x1C]
  00070	e3530004	 cmp         r3, #4

; 1295 :     {
; 1296 :         PRINTMSG(ZONE_PDD_EP0, (L"ContinueEp0RxTransfer: RX complete\r\n"));
; 1297 :         pEP->epStage = MGC_END0_START;

  00074	03a03001	 moveq       r3, #1
  00078	0586301c	 streq       r3, [r6, #0x1C]

; 1288 :     {
; 1289 :         PRINTMSG(ZONE_PDD_EP0, (L"ContinueEp0RxTransfer: No transfer yet"));
; 1290 :         goto cleanUp;
; 1291 :     }
; 1292 : 
; 1293 :     /* Is this a status phase (IN) interrupt for EP 0? */
; 1294 :     if (pEP->epStage == MGC_END0_STAGE_STATUSIN)

  0007c	0a00003a	 beq         |$LN24@ContinueEp@2|

; 1299 :     }
; 1300 : 
; 1301 :     rcvSize = pUsbRegs->EPCSR[ endPoint ].RXCOUNT;

  00080	e2823c05	 add         r3, r2, #5, 24
  00084	e1d310b8	 ldrh        r1, [r3, #8]

; 1302 :     maxSize = pEP->maxPacketSize;

  00088	e1d690b8	 ldrh        r9, [r6, #8]

; 1303 : 
; 1304 :     /* If controller NAKs the host we can get an interrupt before the whole
; 1305 :        packet is received - just ignore and wait for whole packet to arrive. */
; 1306 :     if (rcvSize != maxSize && rcvSize != (pTransfer->cbBuffer - pTransfer->cbTransferred))

  0008c	e1510009	 cmp         r1, r9
  00090	0a000004	 beq         |$LN6@ContinueEp@2|
  00094	e595200c	 ldr         r2, [r5, #0xC]
  00098	e5953010	 ldr         r3, [r5, #0x10]
  0009c	e0423003	 sub         r3, r2, r3
  000a0	e1510003	 cmp         r1, r3
  000a4	1a000030	 bne         |$LN24@ContinueEp@2|
  000a8		 |$LN6@ContinueEp@2|

; 1307 :         goto cleanUp;
; 1308 : 
; 1309 :     /* Update the State of this EP */
; 1310 :     pEP->epStage = MGC_END0_STAGE_RX;

  000a8	e3a03003	 mov         r3, #3
  000ac	e586301c	 str         r3, [r6, #0x1C]
  000b0		 |$LN18@ContinueEp@2|

; 1311 :     __try
; 1312 :     {
; 1313 :         pBuffer = (UCHAR*)pTransfer->pvBuffer + pTransfer->cbTransferred;

  000b0	e5952010	 ldr         r2, [r5, #0x10]

; 1314 :         space = pTransfer->cbBuffer - pTransfer->cbTransferred;

  000b4	e595300c	 ldr         r3, [r5, #0xC]
  000b8	e5950004	 ldr         r0, [r5, #4]
  000bc	e0434002	 sub         r4, r3, r2

; 1315 : 
; 1316 :         /* Get number of bytes to be unloaded from FIFO
; 1317 :          * Check the FIFO's Max Pkt Size against the Size
; 1318 :          * available in the pTransfer Buffer
; 1319 :          */
; 1320 : 
; 1321 :         /* First Check what amount of space is available in the pTransfer
; 1322 :          * Buffer and also the amount of data sent by the Host. The
; 1323 :          * minimum of these two needs to be considered
; 1324 :          */
; 1325 :         count = (rcvSize > space) ? space : rcvSize;

  000c0	e1510004	 cmp         r1, r4
  000c4	91a04001	 movls       r4, r1

; 1326 : 
; 1327 :         PRINTMSG(ZONE_PDD_EP0,
; 1328 :                  (L"ContinueEp0RxTransfer: Reading %d bytes, maxSize %d, left %d\r\n",
; 1329 :                   count, maxSize, space));
; 1330 :         
; 1331 : 		/* Read data */
; 1332 : 		ReadFIFO(pPdd, (UCHAR)endPoint, pBuffer, count);

  000c8	e1a03004	 mov         r3, r4
  000cc	e0802002	 add         r2, r0, r2
  000d0	e20a10ff	 and         r1, r10, #0xFF
  000d4	e1a00008	 mov         r0, r8
  000d8	eb000000	 bl          ReadFIFO

; 1333 : 
; 1334 : 		/* We transfered some data */
; 1335 :         pTransfer->cbTransferred += count ;

  000dc	e5953010	 ldr         r3, [r5, #0x10]
  000e0	e0833004	 add         r3, r3, r4
  000e4	e5853010	 str         r3, [r5, #0x10]

; 1336 : 
; 1337 :         /* Is this end of transfer? We will determine this
; 1338 :          * situation based on two conditions.
; 1339 :          * 1. The Buffer Size inside the pTransfer is filled up
; 1340 :          * 2. The Received pkt Size is lesser than the maximum
; 1341 :          * size of the RxFIFO. The Spec says that if huge number
; 1342 :          * of data needs to be sent to the Controller, it will
; 1343 :          * send it in multiples of the wMaxPacketSize field
; 1344 :          * of the EndPoint Descriptor. The last residue data is
; 1345 :          * sent in a packet which has length lesser than wMaxPacketSize
; 1346 :          */
; 1347 :         if ((pTransfer->cbTransferred == pTransfer->cbBuffer) ||
; 1348 :             (count < maxSize))

  000e8	e1a02003	 mov         r2, r3
  000ec	e595300c	 ldr         r3, [r5, #0xC]
  000f0	e1520003	 cmp         r2, r3
  000f4	0a000002	 beq         |$LN3@ContinueEp@2|
  000f8	e1540009	 cmp         r4, r9

; 1355 : 
; 1356 :             /* Wait for the status in phase to complete */
; 1357 :             pEP->epStage = MGC_END0_STAGE_STATUSIN;

  000fc	23a04000	 movcs       r4, #0

; 1336 : 
; 1337 :         /* Is this end of transfer? We will determine this
; 1338 :          * situation based on two conditions.
; 1339 :          * 1. The Buffer Size inside the pTransfer is filled up
; 1340 :          * 2. The Received pkt Size is lesser than the maximum
; 1341 :          * size of the RxFIFO. The Spec says that if huge number
; 1342 :          * of data needs to be sent to the Controller, it will
; 1343 :          * send it in multiples of the wMaxPacketSize field
; 1344 :          * of the EndPoint Descriptor. The last residue data is
; 1345 :          * sent in a packet which has length lesser than wMaxPacketSize
; 1346 :          */
; 1347 :         if ((pTransfer->cbTransferred == pTransfer->cbBuffer) ||
; 1348 :             (count < maxSize))

  00100	2a000005	 bcs         |$LN4@ContinueEp@2|
  00104		 |$LN3@ContinueEp@2|

; 1349 :         {
; 1350 :             PRINTMSG(ZONE_PDD_EP0, (L"ContinueEp0RxTransfer: All bytes received\r\n"));
; 1351 : 
; 1352 :             /* Hand the packet to MDD at this point */
; 1353 :             pTransfer->dwUsbError = UFN_NO_ERROR;

  00104	e3a04000	 mov         r4, #0
  00108	e5854014	 str         r4, [r5, #0x14]

; 1354 :             complete = TRUE;

  0010c	e3a07001	 mov         r7, #1
  00110	e50b7030	 str         r7, [r11, #-0x30]

; 1355 : 
; 1356 :             /* Wait for the status in phase to complete */
; 1357 :             pEP->epStage = MGC_END0_STAGE_STATUSIN;

  00114	e3a03004	 mov         r3, #4
  00118	e586301c	 str         r3, [r6, #0x1C]
  0011c		 |$LN4@ContinueEp@2|

; 1358 : 
; 1359 :             /* Note: We do not ACK the final packet until UfnPdd_SendControlStatusHandshake(). */
; 1360 :             // epCsrReg |= MGC_M_CSR0_P_DATAEND;
; 1361 :         }
; 1362 : 
; 1363 :         /* Note: We do not ACK the final packet until UfnPdd_SendControlStatusHandshake(). */
; 1364 :         if (!complete)

  0011c	e3570000	 cmp         r7, #0
  00120	03a03cff	 moveq       r3, #0xFF, 24

; 1365 :         {
; 1366 :             epCsrReg &= ~MGC_M_RXCSR_RXPKTRDY;

  00124	038330be	 orreq       r3, r3, #0xBE
  00128	015b23bc	 ldreqh      r2, [r11, #-0x3C]
  0012c	00023003	 andeq       r3, r2, r3

; 1367 :             epCsrReg |= MGC_M_CSR0_P_SVDRXPKTRDY;

  00130	03833040	 orreq       r3, r3, #0x40

; 1368 :             (*pepCtrlReg) = epCsrReg;

  00134	051b2038	 ldreq       r2, [r11, #-0x38]
  00138	01c230b2	 streqh      r3, [r2, #2]
  0013c		 |$LN19@ContinueEp@2|

; 1369 :         }
; 1370 :     }

  0013c	ea00000b	 b           |$cleanUp$47413|
  00140		 |$LN15@ContinueEp@2|

; 1372 :     {
; 1373 :         pTransfer->dwUsbError = UFN_CLIENT_BUFFER_ERROR;

  00140	e51b5034	 ldr         r5, [r11, #-0x34]

; 1374 :         complete = TRUE;
; 1375 :         PRINTMSG(ZONE_ERROR, (L"ContinueEp0RxTransfer: Client buffer exception!\r\n"));

  00144	e59f0064	 ldr         r0, [pc, #0x64]
  00148	e3a03f41	 mov         r3, #0x41, 30
  0014c	e5853014	 str         r3, [r5, #0x14]
  00150	e3a07001	 mov         r7, #1
  00154	e50b7030	 str         r7, [r11, #-0x30]
  00158	eb000000	 bl          NKDbgPrintfW
  0015c	e59b8000	 ldr         r8, [r11]
  00160	e51b602c	 ldr         r6, [r11, #-0x2C]
  00164	e3a04000	 mov         r4, #0
  00168	ea000000	 b           |$cleanUp$47413|
  0016c		 |$LN24@ContinueEp@2|

; 1298 :         goto cleanUp;

  0016c	e3a04000	 mov         r4, #0
  00170		 |$cleanUp$47413|

; 1376 :     }
; 1377 : 
; 1378 : cleanUp:
; 1379 : 
; 1380 :     /* Leave CriticalSection */
; 1381 :     UNLOCK_ENDPOINT(pPdd);

  00170	e2880e27	 add         r0, r8, #0x27, 28
  00174	eb000000	 bl          LeaveCriticalSection

; 1382 : 
; 1383 :     /* If transaction is complete we should tell MDD */
; 1384 :     if (complete == TRUE)

  00178	e3570001	 cmp         r7, #1

; 1385 :     {
; 1386 :         PRINTMSG(ZONE_PDD_EP0, (L"ContinueEp0RxTransfer: "
; 1387 :                  L"pTransfer 0x%08x (%d, %d, 0x%0x) - notify complete\r\n",
; 1388 :                  pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 1389 :                  pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 1390 :                  pTransfer != NULL ? pTransfer->dwUsbError : -1));
; 1391 :         pEP->pTransfer = NULL;

  0017c	05864020	 streq       r4, [r6, #0x20]

; 1392 :         pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer);

  00180	05980010	 ldreq       r0, [r8, #0x10]
  00184	05983014	 ldreq       r3, [r8, #0x14]
  00188	01a02005	 moveq       r2, r5
  0018c	03a01064	 moveq       r1, #0x64
  00190	01a0e00f	 moveq       lr, pc
  00194	012fff13	 bxeq        r3
  00198		 |$LN1@ContinueEp@2|

; 1393 :     }
; 1394 : 
; 1395 :     return;
; 1396 : }

  00198	e24bd028	 sub         sp, r11, #0x28
  0019c	e89d6ff0	 ldmia       sp, {r4 - r11, sp, lr}
  001a0	e12fff1e	 bx          lr

			 ENDP  ; |ContinueEp0RxTransfer|

  001a4		 |$LN14@ContinueEp@2|
  001a4		 |$LN26@ContinueEp@2|

; 1371 :     __except(EXCEPTION_EXECUTE_HANDLER)

  001a4	e52de004	 str         lr, [sp, #-4]!
  001a8		 |$LN17@ContinueEp@2|
  001a8		 |$LN29@ContinueEp@2|
  001a8	e3a00001	 mov         r0, #1
  001ac		 |$LN16@ContinueEp@2|
  001ac	e49df004	 ldr         pc, [sp], #4
  001b0		 |$LN31@ContinueEp@2|
  001b0		 |$LN32@ContinueEp@2|
  001b0	00000000	 DCD         |??_C@_1GE@FICDPAIG@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAE?$AAp?$AA0?$AAR?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?5?$AAb?$AAu@|
  001b4		 |$LN30@ContinueEp@2|
  001b4		 |$LN28@ContinueEp@2|
	EXPORT	|ContinueRxTransfer|
	EXPORT	|??_C@_1FO@PLBPNCAK@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAR?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?5?$AAb?$AAu?$AAf?$AAf?$AAe@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HE@OPFCFOFH@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAR?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T48767| DCD	|$LN25@ContinueRx|
	DCD	0xc0006505

  00000			 AREA	 |.pdata|, PDATA
|$T48769| DCD	|$LN12@ContinueRx|
	DCD	0x40000501

  00000			 AREA	 |.xdata|, DATA
|$T48765| DCD	0x1
	DCD	|$LN16@ContinueRx|
	DCD	|$LN17@ContinueRx|
	DCD	|$LN12@ContinueRx|
	DCD	|$LN13@ContinueRx|

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FO@PLBPNCAK@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAR?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?5?$AAb?$AAu?$AAf?$AAf?$AAe@| DCB "C"
	DCB	0x0, "o", 0x0, "n", 0x0, "t", 0x0, "i", 0x0, "n", 0x0, "u"
	DCB	0x0, "e", 0x0, "R", 0x0, "x", 0x0, "T", 0x0, "r", 0x0, "a"
	DCB	0x0, "n", 0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, ":"
	DCB	0x0, " ", 0x0, "C", 0x0, "l", 0x0, "i", 0x0, "e", 0x0, "n"
	DCB	0x0, "t", 0x0, " ", 0x0, "b", 0x0, "u", 0x0, "f", 0x0, "f"
	DCB	0x0, "e", 0x0, "r", 0x0, " ", 0x0, "e", 0x0, "x", 0x0, "c"
	DCB	0x0, "e", 0x0, "p", 0x0, "t", 0x0, "i", 0x0, "o", 0x0, "n"
	DCB	0x0, "!", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HE@OPFCFOFH@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAR?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr@| DCB "C"
	DCB	0x0, "o", 0x0, "n", 0x0, "t", 0x0, "i", 0x0, "n", 0x0, "u"
	DCB	0x0, "e", 0x0, "R", 0x0, "x", 0x0, "T", 0x0, "r", 0x0, "a"
	DCB	0x0, "n", 0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, ":"
	DCB	0x0, " ", 0x0, "E", 0x0, "P", 0x0, " ", 0x0, "%", 0x0, "d"
	DCB	0x0, ",", 0x0, " ", 0x0, "E", 0x0, "r", 0x0, "r", 0x0, "o"
	DCB	0x0, "r", 0x0, ",", 0x0, " ", 0x0, "N", 0x0, "U", 0x0, "L"
	DCB	0x0, "L", 0x0, " ", 0x0, "t", 0x0, "r", 0x0, "a", 0x0, "n"
	DCB	0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, ",", 0x0, " "
	DCB	0x0, "C", 0x0, "S", 0x0, "R", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "x", 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T48765|

  00008		 |ContinueRxTransfer| PROC

; 1421 : {

  00008		 |$LN25@ContinueRx|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d0003	 stmdb       sp!, {r0, r1}
  00010	e92d5ff0	 stmdb       sp!, {r4 - r12, lr}
  00014	e28db028	 add         r11, sp, #0x28
  00018	e24dd018	 sub         sp, sp, #0x18
  0001c		 |$LN23@ContinueRx|
  0001c	e1a0a001	 mov         r10, r1
  00020	e1a06000	 mov         r6, r0
  00024	e58b6000	 str         r6, [r11]

; 1422 :     CSL_UsbRegs    *pUsbRegs     = pPdd->pUsbdRegs;
; 1423 :     UsbFnEp        *pEP           = &pPdd->ep[endPoint];

  00028	e06a320a	 rsb         r3, r10, r10, lsl #4
  0002c	e0863103	 add         r3, r6, r3, lsl #2
  00030	e2838fa1	 add         r8, r3, #0xA1, 30
  00034	e50b802c	 str         r8, [r11, #-0x2C]

; 1424 :     STransfer *pTransfer = pEP->pTransfer;
; 1425 :     BOOL complete = FALSE;
; 1426 :     volatile UINT16 *pepCtrlReg;
; 1427 :     UINT16  epCsrReg;
; 1428 :     UINT16  rcvSize = 0;
; 1429 :     DWORD space;
; 1430 :     DWORD count;
; 1431 :     UCHAR *pBuffer = NULL;
; 1432 : 	WORD maxSize;
; 1433 : 
; 1434 :     PRINTMSG(ZONE_PDD_RX,
; 1435 :              (L"ContinueRxTransfer: EP %d, pTransfer 0x%08x (%d, %d, 0x%0x)\r\n",
; 1436 :               endPoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 1437 :               pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 1438 :               pTransfer != NULL ? pTransfer->dwUsbError : -1));
; 1439 : 
; 1440 :     /* Enter CriticalSection */
; 1441 :     LOCK_ENDPOINT(pPdd);

  00038	e2860e27	 add         r0, r6, #0x27, 28
  0003c	e5985020	 ldr         r5, [r8, #0x20]
  00040	e596401c	 ldr         r4, [r6, #0x1C]
  00044	e50b403c	 str         r4, [r11, #-0x3C]
  00048	e3a07000	 mov         r7, #0
  0004c	e50b5034	 str         r5, [r11, #-0x34]
  00050	eb000000	 bl          EnterCriticalSection

; 1442 : 
; 1443 :     pepCtrlReg = &pUsbRegs->EPCSR[ endPoint ].PERI_RXCSR;

  00054	e084320a	 add         r3, r4, r10, lsl #4
  00058	e2832c05	 add         r2, r3, #5, 24
  0005c	e50b2038	 str         r2, [r11, #-0x38]

; 1444 :     epCsrReg = (*pepCtrlReg);

  00060	e1d290b6	 ldrh        r9, [r2, #6]

; 1445 : 
; 1446 :     /* Should always have a transfer */
; 1447 :     if (pTransfer == NULL)

  00064	e3550000	 cmp         r5, #0
  00068	1a000004	 bne         |$LN6@ContinueRx|

; 1448 :     {
; 1449 :         PRINTMSG(ZONE_ERROR, (L"ContinueRxTransfer: EP %d, Error, NULL transfer, CSR 0x%x",
; 1450 :                               endPoint, epCsrReg));

  0006c	e59f0138	 ldr         r0, [pc, #0x138]
  00070	e1a02009	 mov         r2, r9
  00074	e1a0100a	 mov         r1, r10
  00078	eb000000	 bl          NKDbgPrintfW

; 1451 :         goto cleanUp;

  0007c	ea000038	 b           |$LN22@ContinueRx|
  00080		 |$LN6@ContinueRx|

; 1452 :     }
; 1453 : 
; 1454 :     /* Arrived here before pkt received (probably after a NAK)? */
; 1455 :     if ((epCsrReg & MGC_M_RXCSR_RXPKTRDY) == 0)

  00080	e3190001	 tst         r9, #1
  00084	0a000036	 beq         |$LN22@ContinueRx|

; 1456 :     {
; 1457 :         PRINTMSG(ZONE_PDD_RX, (L"ContinueRxTransfer: EP %d, No packet received, CSR 0x%x",
; 1458 :                                endPoint, epCsrReg));
; 1459 :         goto cleanUp;
; 1460 :     }
; 1461 : 
; 1462 :     rcvSize = pUsbRegs->EPCSR[ endPoint ].RXCOUNT;

  00088	e2833c05	 add         r3, r3, #5, 24
  0008c	e1d320b8	 ldrh        r2, [r3, #8]

; 1463 :     maxSize = pEP->maxPacketSize;
; 1464 : 
; 1465 :     /* Update the State of this EP */
; 1466 :     pEP->epStage = MGC_END0_STAGE_RX;

  00090	e3a03003	 mov         r3, #3
  00094	e588301c	 str         r3, [r8, #0x1C]
  00098	e1d830b8	 ldrh        r3, [r8, #8]
  0009c	e14b34b0	 strh        r3, [r11, #-0x40]
  000a0		 |$LN16@ContinueRx|

; 1467 :     __try
; 1468 :     {
; 1469 :         pBuffer = (UCHAR*)pTransfer->pvBuffer + pTransfer->cbTransferred;

  000a0	e5951010	 ldr         r1, [r5, #0x10]

; 1470 :         space = pTransfer->cbBuffer - pTransfer->cbTransferred;

  000a4	e595300c	 ldr         r3, [r5, #0xC]
  000a8	e5950004	 ldr         r0, [r5, #4]
  000ac	e0434001	 sub         r4, r3, r1

; 1471 : 
; 1472 :         /* Get number of bytes to be unloaded from FIFO
; 1473 :          * Check the FIFO's Max Pkt Size against the Size
; 1474 :          * available in the pTransfer Buffer
; 1475 :          */
; 1476 : 
; 1477 :         /* First Check what amount of space is available in the pTransfer
; 1478 :          * Buffer and also the amount of data sent by the Host. The
; 1479 :          * minimum of these two needs to be considered
; 1480 :          */
; 1481 :         count = (rcvSize > space) ? space : rcvSize;

  000b0	e1520004	 cmp         r2, r4
  000b4	91a04002	 movls       r4, r2

; 1482 : 
; 1483 :         PRINTMSG(ZONE_PDD_RX,
; 1484 :                  (L"ContinueRxTransfer: EP %d, Reading %d bytes, maxSize %d, left %d\r\n",
; 1485 :                   endPoint, count, maxSize, space));
; 1486 : 
; 1487 : 		/* Read data */
; 1488 : 		ReadFIFO(pPdd, (UCHAR)endPoint, pBuffer, count);

  000b8	e1a03004	 mov         r3, r4
  000bc	e0802001	 add         r2, r0, r1
  000c0	e20a10ff	 and         r1, r10, #0xFF
  000c4	e1a00006	 mov         r0, r6
  000c8	eb000000	 bl          ReadFIFO

; 1489 : 
; 1490 :         /* We transfered some data */
; 1491 :         pTransfer->cbTransferred += count ;

  000cc	e5953010	 ldr         r3, [r5, #0x10]
  000d0	e0833004	 add         r3, r3, r4
  000d4	e5853010	 str         r3, [r5, #0x10]

; 1492 : 
; 1493 :         /* Is this end of transfer? We will determine this
; 1494 :          * situation based on two conditions.
; 1495 :          * 1. The Buffer Size inside the pTransfer is filled up
; 1496 :          * 2. The Received pkt Size is lesser than the maximum
; 1497 :          * size of the RxFIFO. The Spec says that if huge number
; 1498 :          * of data needs to be sent to the Controller, it will
; 1499 :          * send it in multiples of the wMaxPacketSize field
; 1500 :          * of the EndPoint Descriptor. The last residue data is
; 1501 :          * sent in a packet which has length lesser than wMaxPacketSize
; 1502 :          */
; 1503 :         if ((pTransfer->cbTransferred == pTransfer->cbBuffer) ||
; 1504 :             (count < maxSize))

  000d8	e1a02003	 mov         r2, r3
  000dc	e595300c	 ldr         r3, [r5, #0xC]
  000e0	e1520003	 cmp         r2, r3
  000e4	0a000003	 beq         |$LN2@ContinueRx|
  000e8	e15b34b0	 ldrh        r3, [r11, #-0x40]
  000ec	e1540003	 cmp         r4, r3

; 1505 :         {
; 1506 :             /* Done */
; 1507 :             PRINTMSG(ZONE_PDD_RX, (L"ContinueRxTransfer: EP %d, RX complete\r\n", endPoint));
; 1508 :             pTransfer->dwUsbError = UFN_NO_ERROR;
; 1509 :             pEP->epStage   = MGC_END0_START;
; 1510 :             complete       = TRUE;
; 1511 : 
; 1512 :             /* Disable RX interrupt */
; 1513 : 			pUsbRegs->EP_INTMSKCLRR = (1 << endPoint) << USB_OTG_RXINT_SHIFT;

  000f0	23a04000	 movcs       r4, #0

; 1492 : 
; 1493 :         /* Is this end of transfer? We will determine this
; 1494 :          * situation based on two conditions.
; 1495 :          * 1. The Buffer Size inside the pTransfer is filled up
; 1496 :          * 2. The Received pkt Size is lesser than the maximum
; 1497 :          * size of the RxFIFO. The Spec says that if huge number
; 1498 :          * of data needs to be sent to the Controller, it will
; 1499 :          * send it in multiples of the wMaxPacketSize field
; 1500 :          * of the EndPoint Descriptor. The last residue data is
; 1501 :          * sent in a packet which has length lesser than wMaxPacketSize
; 1502 :          */
; 1503 :         if ((pTransfer->cbTransferred == pTransfer->cbBuffer) ||
; 1504 :             (count < maxSize))

  000f4	2a000009	 bcs         |$LN3@ContinueRx|
  000f8		 |$LN2@ContinueRx|

; 1505 :         {
; 1506 :             /* Done */
; 1507 :             PRINTMSG(ZONE_PDD_RX, (L"ContinueRxTransfer: EP %d, RX complete\r\n", endPoint));
; 1508 :             pTransfer->dwUsbError = UFN_NO_ERROR;
; 1509 :             pEP->epStage   = MGC_END0_START;
; 1510 :             complete       = TRUE;
; 1511 : 
; 1512 :             /* Disable RX interrupt */
; 1513 : 			pUsbRegs->EP_INTMSKCLRR = (1 << endPoint) << USB_OTG_RXINT_SHIFT;

  000f8	e3a03001	 mov         r3, #1
  000fc	e3a04000	 mov         r4, #0
  00100	e1a03a13	 mov         r3, r3, lsl r10
  00104	e5854014	 str         r4, [r5, #0x14]
  00108	e3a07001	 mov         r7, #1
  0010c	e588701c	 str         r7, [r8, #0x1C]
  00110	e1a03803	 mov         r3, r3, lsl #16
  00114	e50b7030	 str         r7, [r11, #-0x30]
  00118	e51b203c	 ldr         r2, [r11, #-0x3C]
  0011c	e5823034	 str         r3, [r2, #0x34]
  00120		 |$LN3@ContinueRx|
  00120	e3a03cff	 mov         r3, #0xFF, 24

; 1514 :         }
; 1515 : 
; 1516 :         /* Packet Unloaded from RX FIFO, clear RxPktRDY */
; 1517 :         epCsrReg &= ~MGC_M_RXCSR_RXPKTRDY;

  00124	e38330fe	 orr         r3, r3, #0xFE
  00128	e0093003	 and         r3, r9, r3

; 1518 :         (*pepCtrlReg) = epCsrReg;

  0012c	e51b2038	 ldr         r2, [r11, #-0x38]
  00130	e1c230b6	 strh        r3, [r2, #6]
  00134		 |$LN17@ContinueRx|

; 1519 :     }

  00134	ea00000b	 b           |$cleanUp$47452|
  00138		 |$LN13@ContinueRx|

; 1521 :     {
; 1522 :         pTransfer->dwUsbError = UFN_CLIENT_BUFFER_ERROR;

  00138	e51b5034	 ldr         r5, [r11, #-0x34]

; 1523 :         complete = TRUE;
; 1524 :         PRINTMSG(ZONE_ERROR, (L"ContinueRxTransfer: Client buffer exception!\r\n"));

  0013c	e59f0064	 ldr         r0, [pc, #0x64]
  00140	e3a03f41	 mov         r3, #0x41, 30
  00144	e5853014	 str         r3, [r5, #0x14]
  00148	e3a07001	 mov         r7, #1
  0014c	e50b7030	 str         r7, [r11, #-0x30]
  00150	eb000000	 bl          NKDbgPrintfW
  00154	e59b6000	 ldr         r6, [r11]
  00158	e51b802c	 ldr         r8, [r11, #-0x2C]
  0015c	e3a04000	 mov         r4, #0
  00160	ea000000	 b           |$cleanUp$47452|
  00164		 |$LN22@ContinueRx|

; 1451 :         goto cleanUp;

  00164	e3a04000	 mov         r4, #0
  00168		 |$cleanUp$47452|

; 1525 :     }
; 1526 : 
; 1527 : cleanUp:
; 1528 : 
; 1529 :     /* Leave CriticalSection */
; 1530 :     UNLOCK_ENDPOINT(pPdd);

  00168	e2860e27	 add         r0, r6, #0x27, 28
  0016c	eb000000	 bl          LeaveCriticalSection

; 1531 : 
; 1532 :     /* If transaction is complete we should tell MDD */
; 1533 :     if (complete == TRUE)

  00170	e3570001	 cmp         r7, #1

; 1534 :     {
; 1535 :         PRINTMSG(ZONE_PDD_RX, (L"ContinueRxTransfer: "
; 1536 :                  L"EP %d, pTransfer 0x%08x (%d, %d, 0x%0x) - notify complete\r\n",
; 1537 :                  endPoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 1538 :                  pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 1539 :                  pTransfer != NULL ? pTransfer->dwUsbError : -1));
; 1540 :         pEP->pTransfer = NULL;

  00174	05884020	 streq       r4, [r8, #0x20]

; 1541 :         pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer);

  00178	05960010	 ldreq       r0, [r6, #0x10]
  0017c	05963014	 ldreq       r3, [r6, #0x14]
  00180	01a02005	 moveq       r2, r5
  00184	03a01064	 moveq       r1, #0x64
  00188	01a0e00f	 moveq       lr, pc
  0018c	012fff13	 bxeq        r3
  00190		 |$LN1@ContinueRx|

; 1542 :     }
; 1543 : 
; 1544 :     return;
; 1545 : }

  00190	e24bd028	 sub         sp, r11, #0x28
  00194	e89d6ff0	 ldmia       sp, {r4 - r11, sp, lr}
  00198	e12fff1e	 bx          lr

			 ENDP  ; |ContinueRxTransfer|

  0019c		 |$LN12@ContinueRx|
  0019c		 |$LN24@ContinueRx|

; 1520 :     __except(EXCEPTION_EXECUTE_HANDLER)

  0019c	e52de004	 str         lr, [sp, #-4]!
  001a0		 |$LN15@ContinueRx|
  001a0		 |$LN27@ContinueRx|
  001a0	e3a00001	 mov         r0, #1
  001a4		 |$LN14@ContinueRx|
  001a4	e49df004	 ldr         pc, [sp], #4
  001a8		 |$LN29@ContinueRx|
  001a8		 |$LN30@ContinueRx|
  001a8	00000000	 DCD         |??_C@_1FO@PLBPNCAK@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAR?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?5?$AAb?$AAu?$AAf?$AAf?$AAe@|
  001ac		 |$LN31@ContinueRx|
  001ac	00000000	 DCD         |??_C@_1HE@OPFCFOFH@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAR?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr@|
  001b0		 |$LN28@ContinueRx|
  001b0		 |$LN26@ContinueRx|
	EXPORT	|??_C@_1GE@GHDKIAKL@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAT?$AAx?$AAD?$AAm?$AAa?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?5?$AAb?$AAu@| [ DATA ] ; `string'
	EXPORT	|??_C@_1LI@BHLEPIFM@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAT?$AAx?$AAD?$AAm?$AAa?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AAI?$AAS@| [ DATA ] ; `string'
	IMPORT	|memcpy|

  00000			 AREA	 |.pdata|, PDATA
|$T48807| DCD	|$LN26@ContinueTx@2|
	DCD	0xc0007b05

  00000			 AREA	 |.pdata|, PDATA
|$T48809| DCD	|$LN14@ContinueTx@2|
	DCD	0x40000501

  00000			 AREA	 |.xdata|, DATA
|$T48805| DCD	0x1
	DCD	|$LN18@ContinueTx@2|
	DCD	|$LN19@ContinueTx@2|
	DCD	|$LN14@ContinueTx@2|
	DCD	|$LN15@ContinueTx@2|

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GE@GHDKIAKL@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAT?$AAx?$AAD?$AAm?$AAa?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?5?$AAb?$AAu@| DCB "C"
	DCB	0x0, "o", 0x0, "n", 0x0, "t", 0x0, "i", 0x0, "n", 0x0, "u"
	DCB	0x0, "e", 0x0, "T", 0x0, "x", 0x0, "D", 0x0, "m", 0x0, "a"
	DCB	0x0, "T", 0x0, "r", 0x0, "a", 0x0, "n", 0x0, "s", 0x0, "f"
	DCB	0x0, "e", 0x0, "r", 0x0, ":", 0x0, " ", 0x0, "C", 0x0, "l"
	DCB	0x0, "i", 0x0, "e", 0x0, "n", 0x0, "t", 0x0, " ", 0x0, "b"
	DCB	0x0, "u", 0x0, "f", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "e", 0x0, "x", 0x0, "c", 0x0, "e", 0x0, "p", 0x0, "t"
	DCB	0x0, "i", 0x0, "o", 0x0, "n", 0x0, "!", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1LI@BHLEPIFM@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAT?$AAx?$AAD?$AAm?$AAa?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AAI?$AAS@| DCB "C"
	DCB	0x0, "o", 0x0, "n", 0x0, "t", 0x0, "i", 0x0, "n", 0x0, "u"
	DCB	0x0, "e", 0x0, "T", 0x0, "x", 0x0, "D", 0x0, "m", 0x0, "a"
	DCB	0x0, "T", 0x0, "r", 0x0, "a", 0x0, "n", 0x0, "s", 0x0, "f"
	DCB	0x0, "e", 0x0, "r", 0x0, ":", 0x0, " ", 0x0, "E", 0x0, "P"
	DCB	0x0, " ", 0x0, "%", 0x0, "d", 0x0, ",", 0x0, " ", 0x0, "I"
	DCB	0x0, "S", 0x0, "O", 0x0, " ", 0x0, "t", 0x0, "r", 0x0, "a"
	DCB	0x0, "n", 0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, "s"
	DCB	0x0, " ", 0x0, "o", 0x0, "n", 0x0, "l", 0x0, "y", 0x0, " "
	DCB	0x0, "s", 0x0, "u", 0x0, "p", 0x0, "p", 0x0, "o", 0x0, "r"
	DCB	0x0, "t", 0x0, "e", 0x0, "d", 0x0, " ", 0x0, "w", 0x0, "i"
	DCB	0x0, "t", 0x0, "h", 0x0, " ", 0x0, "p", 0x0, "h", 0x0, "y"
	DCB	0x0, "s", 0x0, "i", 0x0, "c", 0x0, "a", 0x0, "l", 0x0, " "
	DCB	0x0, "b", 0x0, "u", 0x0, "f", 0x0, "f", 0x0, "e", 0x0, "r"
	DCB	0x0, " ", 0x0, "a", 0x0, "d", 0x0, "d", 0x0, "r", 0x0, "e"
	DCB	0x0, "s", 0x0, "s", 0x0, "e", 0x0, "s", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T48805|

  00008		 |ContinueTxDmaTransfer| PROC

; 1568 : {

  00008		 |$LN26@ContinueTx@2|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d0003	 stmdb       sp!, {r0, r1}
  00010	e92d5ff0	 stmdb       sp!, {r4 - r12, lr}
  00014	e28db028	 add         r11, sp, #0x28
  00018	e24dd020	 sub         sp, sp, #0x20
  0001c		 |$LN24@ContinueTx@2|
  0001c	e1a09001	 mov         r9, r1
  00020	e58b9004	 str         r9, [r11, #4]
  00024	e1a08000	 mov         r8, r0
  00028	e58b8000	 str         r8, [r11]

; 1569 :     CSL_UsbRegs    *pUsbdRegs     = pPdd->pUsbdRegs;
; 1570 :     UsbFnEp        *pEP           = &pPdd->ep[endPoint];

  0002c	e0693209	 rsb         r3, r9, r9, lsl #4
  00030	e0883103	 add         r3, r8, r3, lsl #2
  00034	e2835fa1	 add         r5, r3, #0xA1, 30
  00038	e50b5034	 str         r5, [r11, #-0x34]
  0003c	e598a01c	 ldr         r10, [r8, #0x1C]

; 1571 :     STransfer      *pTransfer     = pEP->pTransfer;

  00040	e5954020	 ldr         r4, [r5, #0x20]

; 1572 :     BOOL complete = FALSE;
; 1573 :     UCHAR *pBuffer = NULL;
; 1574 :     UINT16      epCsrReg;
; 1575 : 
; 1576 : #ifdef CPPI_DMA_SUPPORT
; 1577 :     struct dma_controller * pDmaCntrl =
; 1578 :                 (struct dma_controller *)pPdd->pDmaCntrl;

  00044	e598365c	 ldr         r3, [r8, #0x65C]
  00048	e50b3044	 str         r3, [r11, #-0x44]

; 1579 : #endif /* #ifdef CPPI_DMA_SUPPORT */
; 1580 : 
; 1581 :     DWORD size = 0;
; 1582 :     DWORD fullPackets;
; 1583 :     DWORD lastPacketSize;
; 1584 :     UINT32 paBuffer;
; 1585 : 
; 1586 : 
; 1587 :     PRINTMSG(ZONE_PDD_TX, (L"ContinueTxDmaTransfer: "
; 1588 :                            L"EP %d, pTransfer 0x%08x (%d, %d, 0x%0x)\r\n",
; 1589 :                            endPoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 1590 :                            pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 1591 :                            pTransfer != NULL ? pTransfer->dwUsbError : -1));
; 1592 : 
; 1593 :     /* Enter CriticalSection */
; 1594 :     LOCK_ENDPOINT(pPdd);

  0004c	e2880e27	 add         r0, r8, #0x27, 28
  00050	e50b403c	 str         r4, [r11, #-0x3C]
  00054	e50ba038	 str         r10, [r11, #-0x38]
  00058	e3a02000	 mov         r2, #0
  0005c	e50b2040	 str         r2, [r11, #-0x40]
  00060	e50b3030	 str         r3, [r11, #-0x30]
  00064	eb000000	 bl          EnterCriticalSection

; 1595 : 
; 1596 :     if (pTransfer == NULL) goto cleanUp;

  00068	e3540000	 cmp         r4, #0
  0006c	0a00005b	 beq         |$cleanUp$47490|

; 1597 : 
; 1598 :     pEP->usingDma = TRUE;
; 1599 : 
; 1600 :     /* Currently only support phyisical buffer addresses with overlapped ISO */
; 1601 :     if (pEP->endpointType == USB_ENDPOINT_TYPE_ISOCHRONOUS &&
; 1602 :         (pTransfer->dwFlags & USB_OVERLAPPED) &&
; 1603 :         pTransfer->dwBufferPhysicalAddress == 0)

  00070	e5d5300c	 ldrb        r3, [r5, #0xC]
  00074	e3a02001	 mov         r2, #1
  00078	e5852028	 str         r2, [r5, #0x28]
  0007c	e3530001	 cmp         r3, #1
  00080	1a000009	 bne         |$LN9@ContinueTx@2|
  00084	e5943000	 ldr         r3, [r4]
  00088	e3130001	 tst         r3, #1
  0008c	0a000006	 beq         |$LN9@ContinueTx@2|
  00090	e5943008	 ldr         r3, [r4, #8]
  00094	e3530000	 cmp         r3, #0
  00098	1a000003	 bne         |$LN9@ContinueTx@2|

; 1604 :     {
; 1605 :         PRINTMSG(ZONE_ERROR,
; 1606 :                  (L"ContinueTxDmaTransfer: EP %d, ISO transfers only supported with physical buffer addresses\r\n",
; 1607 :                   endPoint));

  0009c	e59f0160	 ldr         r0, [pc, #0x160]
  000a0	e1a01009	 mov         r1, r9
  000a4	eb000000	 bl          NKDbgPrintfW

; 1608 :         goto cleanUp;

  000a8	ea00004c	 b           |$cleanUp$47490|
  000ac		 |$LN9@ContinueTx@2|

; 1609 :     }
; 1610 : 
; 1611 :     /* Is this final interrupt of transfer? */
; 1612 :     if ((pTransfer->cbTransferred == pTransfer->cbBuffer) && !pEP->zeroLength)

  000ac	e5942010	 ldr         r2, [r4, #0x10]
  000b0	e594300c	 ldr         r3, [r4, #0xC]
  000b4	e1520003	 cmp         r2, r3
  000b8	05953014	 ldreq       r3, [r5, #0x14]
  000bc	03530000	 cmpeq       r3, #0

; 1613 :     {
; 1614 :         pTransfer->dwUsbError = UFN_NO_ERROR;

  000c0	03a03000	 moveq       r3, #0
  000c4	05843014	 streq       r3, [r4, #0x14]

; 1609 :     }
; 1610 : 
; 1611 :     /* Is this final interrupt of transfer? */
; 1612 :     if ((pTransfer->cbTransferred == pTransfer->cbBuffer) && !pEP->zeroLength)

  000c8	0a000044	 beq         |$cleanUp$47490|

; 1615 :         complete = TRUE;
; 1616 :         goto cleanUp;
; 1617 :     }
; 1618 : 
; 1619 :     /* Enter TX stage */
; 1620 :     pEP->epStage = MGC_END0_STAGE_TX;

  000cc	e3a03002	 mov         r3, #2
  000d0	e585301c	 str         r3, [r5, #0x1C]

; 1621 : 
; 1622 :     /* Get size and buffer position */
; 1623 :     size = pTransfer->cbBuffer - pTransfer->cbTransferred;

  000d4	e5941010	 ldr         r1, [r4, #0x10]
  000d8	e594300c	 ldr         r3, [r4, #0xC]

; 1624 : 
; 1625 :     /* If we are using PDD buffer we must check for maximal size
; 1626 :      * Note that we cannot transfer sizes greater than our DMA
; 1627 :      * Buffer Sizes. In case the total transfer requested by the
; 1628 :      * MDD layer is greater than our DMA Buffer Sizes, then the
; 1629 :      * whole Transfer needs to be stage managed by breaking into
; 1630 :      * chunks.
; 1631 :      */
; 1632 :     if ((pTransfer->dwBufferPhysicalAddress == 0) &&
; 1633 :         (size > pPdd->dmaBufferSize))

  000dc	e5942008	 ldr         r2, [r4, #8]
  000e0	e0436001	 sub         r6, r3, r1
  000e4	e50b6048	 str         r6, [r11, #-0x48]
  000e8	e3520000	 cmp         r2, #0
  000ec	1a00001e	 bne         |$LN6@ContinueTx@2|
  000f0	e5983008	 ldr         r3, [r8, #8]
  000f4	e1560003	 cmp         r6, r3

; 1634 :     {
; 1635 :         /* check for the Size below */
; 1636 :         PRINTMSG(ZONE_PDD_TX, (L"EP %u Transfer Size 0x%08x DMABufSize  0x%x\r\n",
; 1637 :                                endPoint, size, pPdd->dmaBufferSize));
; 1638 :         size = pPdd->dmaBufferSize;

  000f8	81a06003	 movhi       r6, r3
  000fc	850b3048	 strhi       r3, [r11, #-0x48]

; 1639 :     }
; 1640 : 
; 1641 :     /*
; 1642 :      * Depending on size we should use different DMA mode, we should
; 1643 :      * process packet aligned transfer in separate way to avoid
; 1644 :      * zero length packet at end of transfer.
; 1645 :      */
; 1646 :     fullPackets = size / pEP->maxPacketSize;
; 1647 :     lastPacketSize = size - fullPackets * pEP->maxPacketSize;
; 1648 : 
; 1649 :     if (pTransfer->dwBufferPhysicalAddress == 0)

  00100	e3520000	 cmp         r2, #0
  00104	1a000018	 bne         |$LN6@ContinueTx@2|

; 1650 :     {
; 1651 :         /* Point to the appropriate offset in the PDD Buffer that
; 1652 :          * needs to be copied into the Driver's DMA Buffer.
; 1653 :          */
; 1654 :         pBuffer  = pTransfer->pvBuffer;
; 1655 :         pBuffer += pTransfer->cbTransferred;

  00108	e5943004	 ldr         r3, [r4, #4]

; 1656 :         paBuffer = pEP->paDmaBuffer;

  0010c	e5957034	 ldr         r7, [r5, #0x34]
  00110	e50b702c	 str         r7, [r11, #-0x2C]
  00114		 |$LN18@ContinueTx@2|

; 1657 : 
; 1658 :         __try
; 1659 :         {
; 1660 :             if (size > 0) memcpy(pEP->pDmaBuffer, pBuffer, size);

  00114	e3560000	 cmp         r6, #0
  00118	15950030	 ldrne       r0, [r5, #0x30]
  0011c	11a02006	 movne       r2, r6
  00120	10831001	 addne       r1, r3, r1
  00124	1b000000	 blne        memcpy
  00128		 |$LN19@ContinueTx@2|

; 1661 :         }

  00128	e51b2044	 ldr         r2, [r11, #-0x44]
  0012c	ea000010	 b           |$LN3@ContinueTx@2|
  00130		 |$LN15@ContinueTx@2|

; 1663 :         {
; 1664 :             pTransfer->dwUsbError = UFN_CLIENT_BUFFER_ERROR;

  00130	e51b403c	 ldr         r4, [r11, #-0x3C]

; 1665 :             complete = TRUE;
; 1666 :             PRINTMSG(ZONE_ERROR, (L"ContinueTxDmaTransfer: Client buffer exception!\r\n"));

  00134	e59f00c4	 ldr         r0, [pc, #0xC4]
  00138	e3a03f41	 mov         r3, #0x41, 30
  0013c	e5843014	 str         r3, [r4, #0x14]
  00140	e3a03001	 mov         r3, #1
  00144	e50b3040	 str         r3, [r11, #-0x40]
  00148	eb000000	 bl          NKDbgPrintfW
  0014c	e59b9004	 ldr         r9, [r11, #4]
  00150	e59b8000	 ldr         r8, [r11]
  00154	e51ba038	 ldr         r10, [r11, #-0x38]
  00158	e51b5034	 ldr         r5, [r11, #-0x34]
  0015c	e51b2030	 ldr         r2, [r11, #-0x30]
  00160	e51b6048	 ldr         r6, [r11, #-0x48]
  00164	e51b702c	 ldr         r7, [r11, #-0x2C]
  00168	ea000001	 b           |$LN3@ContinueTx@2|
  0016c		 |$LN6@ContinueTx@2|

; 1667 :         }
; 1668 :     }
; 1669 :     else
; 1670 :     {
; 1671 :         paBuffer  = pTransfer->dwBufferPhysicalAddress;
; 1672 :         paBuffer += pTransfer->cbTransferred;

  0016c	e0817002	 add         r7, r1, r2
  00170	e51b2044	 ldr         r2, [r11, #-0x44]
  00174		 |$LN3@ContinueTx@2|

; 1673 :         DEBUGMSG(ZONE_PDD_TX,
; 1674 :                  (L"ContinueTxDmaTransfer: EP %d, DMA from client buffer 0x%08x\r\n",
; 1675 :                   endPoint, paBuffer));
; 1676 :     }
; 1677 : 
; 1678 :     epCsrReg = pUsbdRegs->EPCSR[ endPoint ].PERI_TXCSR;

  00174	e08a3209	 add         r3, r10, r9, lsl #4
  00178	e283ec05	 add         lr, r3, #5, 24
  0017c	e1de00b2	 ldrh        r0, [lr, #2]
  00180	e3a03c4f	 mov         r3, #0x4F, 24

; 1679 :     epCsrReg &= ~(MGC_M_TXCSR_AUTOSET);

  00184	e38310ff	 orr         r1, r3, #0xFF
  00188	e0001001	 and         r1, r0, r1

; 1680 :     epCsrReg |=  (MGC_M_TXCSR_DMAENAB | MGC_M_TXCSR_MODE);

  0018c	e3811a03	 orr         r1, r1, #3, 20

; 1681 :     pUsbdRegs->EPCSR[ endPoint ].PERI_TXCSR = epCsrReg;

  00190	e1ce10b2	 strh        r1, [lr, #2]

; 1682 : 
; 1683 :     if (complete) goto cleanUp;

  00194	e51b3040	 ldr         r3, [r11, #-0x40]
  00198	e3530000	 cmp         r3, #0
  0019c	1a00000f	 bne         |$cleanUp$47490|

; 1684 : 
; 1685 : #ifdef CPPI_DMA_SUPPORT
; 1686 :     // Overlapped transfer?
; 1687 :     pEP->pOverlappedInfo = NULL;

  001a0	e3a03000	 mov         r3, #0
  001a4	e5853038	 str         r3, [r5, #0x38]

; 1688 :     if (pTransfer->dwFlags & USB_OVERLAPPED)

  001a8	e5941000	 ldr         r1, [r4]
  001ac	e3110001	 tst         r1, #1

; 1689 :     {
; 1690 :         pEP->pOverlappedInfo = (PUSB_OVERLAPPED_INFO)pTransfer->pvPddTransferInfo;

  001b0	1594101c	 ldrne       r1, [r4, #0x1C]
  001b4	15851038	 strne       r1, [r5, #0x38]

; 1691 :     }
; 1692 : 
; 1693 : //#define OVERLAPPED_TEST
; 1694 : #ifdef OVERLAPPED_TEST
; 1695 :     {
; 1696 :         static USB_OVERLAPPED_INFO ov;
; 1697 :         ov.lpUserData = NULL;
; 1698 :         ov.dwBytesToIssueCallback = pTransfer->cbBuffer * 3 / 4;
; 1699 :         pEP->pOverlappedInfo = &ov;
; 1700 :     }
; 1701 : #endif
; 1702 : 
; 1703 :     /* Configure the DMA Controller now */
; 1704 : 
; 1705 :     /* Note:
; 1706 :      * 1. The maxPacketSize specifies the EP Max Fifo Size. paDmaTx0Buffer
; 1707 :      *    points to the physical Address of the Driver's Tx Buffer.
; 1708 :      *    Size specifies the transfer count.
; 1709 :      *
; 1710 :      * 2. The Transfer count is set to the minimum of the Driver's
; 1711 :      *    DMA Tx Buffer Size and pTransfer->cbBuffer.
; 1712 :      * In case the transfer size is greater than the Tx Buffer size,
; 1713 :      * then this routine will be invoked again from the Interrupt
; 1714 :      * Context also.
; 1715 :      */
; 1716 :     pDmaCntrl->channelProgram (pPdd->ep[endPoint].pDmaChan,
; 1717 :                                 pPdd->ep[endPoint].maxPacketSize,
; 1718 :                                 paBuffer,
; 1719 :                                 size);

  001b8	e0691209	 rsb         r1, r9, r9, lsl #4
  001bc	e0880101	 add         r0, r8, r1, lsl #2
  001c0	e2801c02	 add         r1, r0, #2, 24
  001c4	e1d118bc	 ldrh        r1, [r1, #0x8C]
  001c8	e59002b0	 ldr         r0, [r0, #0x2B0]
  001cc	e5924010	 ldr         r4, [r2, #0x10]
  001d0	e1a03006	 mov         r3, r6
  001d4	e1a02007	 mov         r2, r7
  001d8	e1a0e00f	 mov         lr, pc
  001dc	e12fff14	 bx          r4
  001e0		 |$cleanUp$47490|

; 1720 : #endif /* #ifdef CPPI_DMA_SUPPORT */
; 1721 : 
; 1722 : cleanUp:
; 1723 :     UNLOCK_ENDPOINT (pPdd);

  001e0	e2880e27	 add         r0, r8, #0x27, 28
  001e4	eb000000	 bl          LeaveCriticalSection
  001e8		 |$LN11@ContinueTx@2|

; 1724 : 
; 1725 :     return;
; 1726 : }

  001e8	e24bd028	 sub         sp, r11, #0x28
  001ec	e89d6ff0	 ldmia       sp, {r4 - r11, sp, lr}
  001f0	e12fff1e	 bx          lr

			 ENDP  ; |ContinueTxDmaTransfer|

  001f4		 |$LN14@ContinueTx@2|
  001f4		 |$LN25@ContinueTx@2|

; 1662 :         __except(EXCEPTION_EXECUTE_HANDLER)

  001f4	e52de004	 str         lr, [sp, #-4]!
  001f8		 |$LN17@ContinueTx@2|
  001f8		 |$LN28@ContinueTx@2|
  001f8	e3a00001	 mov         r0, #1
  001fc		 |$LN16@ContinueTx@2|
  001fc	e49df004	 ldr         pc, [sp], #4
  00200		 |$LN30@ContinueTx@2|
  00200		 |$LN31@ContinueTx@2|
  00200	00000000	 DCD         |??_C@_1GE@GHDKIAKL@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAT?$AAx?$AAD?$AAm?$AAa?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?5?$AAb?$AAu@|
  00204		 |$LN32@ContinueTx@2|
  00204	00000000	 DCD         |??_C@_1LI@BHLEPIFM@?$AAC?$AAo?$AAn?$AAt?$AAi?$AAn?$AAu?$AAe?$AAT?$AAx?$AAD?$AAm?$AAa?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AAI?$AAS@|
  00208		 |$LN29@ContinueTx@2|
  00208		 |$LN27@ContinueTx@2|
	EXPORT	|TxDmaTransferComplete|
	EXPORT	|??_C@_1DO@MIHBGHGK@?$AAE?$AAP?$AA?5?$AA?$CF?$AAu?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAi?$AAo?$AAn?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T48836| DCD	|$LN15@TxDmaTrans|
	DCD	0x40005101

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DO@MIHBGHGK@?$AAE?$AAP?$AA?5?$AA?$CF?$AAu?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAi?$AAo?$AAn?$AA?$AN?$AA?6?$AA?$AA@| DCB "E"
	DCB	0x0, "P", 0x0, " ", 0x0, "%", 0x0, "u", 0x0, " ", 0x0, "I"
	DCB	0x0, "n", 0x0, "v", 0x0, "a", 0x0, "l", 0x0, "i", 0x0, "d"
	DCB	0x0, " ", 0x0, "D", 0x0, "M", 0x0, "A", 0x0, " ", 0x0, "C"
	DCB	0x0, "o", 0x0, "m", 0x0, "p", 0x0, "l", 0x0, "e", 0x0, "t"
	DCB	0x0, "i", 0x0, "o", 0x0, "n", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TxDmaTransferComplete| PROC

; 1752 : {

  00000		 |$LN15@TxDmaTrans|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M48833|
  00004	e1a06002	 mov         r6, r2
  00008	e1a05000	 mov         r5, r0

; 1753 :     USBFNPDDCONTEXT *pPdd = (USBFNPDDCONTEXT *)pDriverContext;
; 1754 :     CSL_UsbRegs     *pUsbdRegs = pPdd->pUsbdRegs;
; 1755 :     UsbFnEp         *pEP = &pPdd->ep[endPoint];

  0000c	e0663206	 rsb         r3, r6, r6, lsl #4
  00010	e0854103	 add         r4, r5, r3, lsl #2

; 1756 :     STransfer       *pTransfer = pEP->pTransfer;

  00014	e59432a4	 ldr         r3, [r4, #0x2A4]
  00018	e595901c	 ldr         r9, [r5, #0x1C]

; 1757 :     BOOL            complete = FALSE;
; 1758 :     volatile UINT16 *pepCtrlReg;
; 1759 :     UINT16          epCsrReg;
; 1760 : 
; 1761 : #ifdef CPPI_DMA_SUPPORT
; 1762 :     struct cppi_channel *pDmaChan = (struct cppi_channel *)
; 1763 :                                     pPdd->ep[endPoint].pDmaChan;

  0001c	e594a2b0	 ldr         r10, [r4, #0x2B0]
  00020	e1b07003	 movs        r7, r3
  00024	e3a08000	 mov         r8, #0

; 1764 : #endif /* #ifdef CPPI_DMA_SUPPORT */
; 1765 : 
; 1766 : 	UNREFERENCED_PARAMETER(chanNumber);
; 1767 : 
; 1768 :     PRINTMSG(ZONE_PDD_TX,
; 1769 :              (L"TxDmaTransferComplete: "
; 1770 :               L"EP %d, pTransfer 0x%08x (%d, %d, 0x%0x)\r\n",
; 1771 :               endPoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 1772 :               pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 1773 :               pTransfer != NULL ? pTransfer->dwUsbError : -1));
; 1774 : 
; 1775 :     /* Sanity Check */
; 1776 :     if (pTransfer == NULL)

  00028	1a00000d	 bne         |$LN9@TxDmaTrans|

; 1777 :     {
; 1778 :         /* Not an error if transfer was aborted */
; 1779 :         if (pEP->epStage != MGC_END0_START)

  0002c	e59432a0	 ldr         r3, [r4, #0x2A0]
  00030	e3530001	 cmp         r3, #1
  00034	0a000007	 beq         |$LN8@TxDmaTrans|

; 1780 :             ERRORMSG(TRUE,
; 1781 :                 (L"EP %u Invalid DMA Completion\r\n", endPoint));

  00038	e59f1100	 ldr         r1, [pc, #0x100]
  0003c	e59f00f8	 ldr         r0, [pc, #0xF8]
  00040	e3a03c06	 mov         r3, #6, 24
  00044	e38320f5	 orr         r2, r3, #0xF5
  00048	eb000000	 bl          NKDbgPrintfW
  0004c	e59f00e4	 ldr         r0, [pc, #0xE4]
  00050	e1a01006	 mov         r1, r6
  00054	eb000000	 bl          NKDbgPrintfW
  00058		 |$LN8@TxDmaTrans|

; 1782 :         return 1;

  00058	e3a00001	 mov         r0, #1

; 1861 : }

  0005c	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$LN9@TxDmaTrans|

; 1783 :     }
; 1784 :     /* Enter CriticalSection */
; 1785 :     LOCK_ENDPOINT(pPdd);

  00064	e2850e27	 add         r0, r5, #0x27, 28
  00068	eb000000	 bl          EnterCriticalSection

; 1786 : 
; 1787 :     /* Update the cbTransferred member based on the DMA Transfer Count */
; 1788 : #ifdef CPPI_DMA_SUPPORT
; 1789 :     pTransfer->cbTransferred += pDmaChan->actualLen;

  0006c	e5972010	 ldr         r2, [r7, #0x10]
  00070	e59a3030	 ldr         r3, [r10, #0x30]

; 1790 : #endif
; 1791 : 
; 1792 :     /* For overlapped transfers we only get callback when transfer is complete and
; 1793 :        bytes transferred may be less than the buffer size. */
; 1794 :     if ((pTransfer->cbTransferred >= pTransfer->cbBuffer) ||
; 1795 :         (pEP->pOverlappedInfo != NULL))

  00074	e597100c	 ldr         r1, [r7, #0xC]
  00078	e3a0a000	 mov         r10, #0
  0007c	e0823003	 add         r3, r2, r3
  00080	e5873010	 str         r3, [r7, #0x10]
  00084	e1530001	 cmp         r3, r1
  00088	2a000006	 bcs         |$LN6@TxDmaTrans|
  0008c	e59432bc	 ldr         r3, [r4, #0x2BC]
  00090	e3530000	 cmp         r3, #0
  00094	1a000003	 bne         |$LN6@TxDmaTrans|

; 1834 :         }
; 1835 :     }
; 1836 :     else
; 1837 :     {
; 1838 :         /* Transfer is not complete, only one chunk was completed.
; 1839 :          * Need to start another Chunk of DMA Transfer.
; 1840 :          */
; 1841 :         ContinueTxDmaTransfer(pPdd, endPoint);

  00098	e1a01006	 mov         r1, r6
  0009c	e1a00005	 mov         r0, r5
  000a0	eb000000	 bl          ContinueTxDmaTransfer
  000a4	ea000016	 b           |$LN3@TxDmaTrans|
  000a8		 |$LN6@TxDmaTrans|

; 1796 :     {
; 1797 :         /* DMA of packet into FIFO is complete.  Check if packet has gone out on bus. */
; 1798 :         pepCtrlReg = &pUsbdRegs->EPCSR[ endPoint ].PERI_TXCSR;

  000a8	e0893206	 add         r3, r9, r6, lsl #4
  000ac	e2831c05	 add         r1, r3, #5, 24

; 1799 :         epCsrReg = *pepCtrlReg;

  000b0	e1d130b2	 ldrh        r3, [r1, #2]

; 1800 :         if ((epCsrReg & MGC_M_TXCSR_TXPKTRDY) != 0)

  000b4	e3130001	 tst         r3, #1

; 1801 :         {
; 1802 :             /* Need to wait for packet to go out onto bus. */
; 1803 :             PRINTMSG(ZONE_PDD_TX,
; 1804 :                      (L"TxDmaTransferComplete: EP %d, Wait for bus write\r\n", endPoint));
; 1805 : 
; 1806 :             /* Update stage to indicate fifo wait */
; 1807 :             pEP->epStage = MGC_END0_STAGE_ACKWAIT;
; 1808 : 
; 1809 :             /* Clear any pending EP interrupt */
; 1810 :             pUsbdRegs->EP_INTCLRR = (1 << endPoint) << USB_OTG_TXINT_SHIFT;

  000b8	e3a03001	 mov         r3, #1
  000bc	0a00000d	 beq         |$LN5@TxDmaTrans|
  000c0	e1a02613	 mov         r2, r3, lsl r6
  000c4	e3a03006	 mov         r3, #6
  000c8	e58432a0	 str         r3, [r4, #0x2A0]
  000cc	e5892028	 str         r2, [r9, #0x28]

; 1811 : 
; 1812 :             /* Enable TX interrupt */
; 1813 :             pUsbdRegs->EP_INTMSKSETR = (1 << endPoint) << USB_OTG_TXINT_SHIFT;

  000d0	e5892030	 str         r2, [r9, #0x30]

; 1814 : 
; 1815 :             /* Race condition - check if packet TX just completed */
; 1816 :             epCsrReg = *pepCtrlReg;

  000d4	e1d130b2	 ldrh        r3, [r1, #2]

; 1817 :             if ((epCsrReg & MGC_M_TXCSR_TXPKTRDY) == 0)

  000d8	e3130001	 tst         r3, #1
  000dc	1a000008	 bne         |$LN3@TxDmaTrans|

; 1818 :             {
; 1819 :                 pEP->epStage = MGC_END0_START;

  000e0	e3a03001	 mov         r3, #1
  000e4	e58432a0	 str         r3, [r4, #0x2A0]

; 1820 :                 pTransfer->dwUsbError = UFN_NO_ERROR;

  000e8	e587a014	 str         r10, [r7, #0x14]

; 1821 :                 complete = TRUE;
; 1822 : 
; 1823 :                 /* Disable TX interrupt */
; 1824 :                 pUsbdRegs->EP_INTMSKCLRR = (1 << endPoint) << USB_OTG_TXINT_SHIFT;

  000ec	e5892034	 str         r2, [r9, #0x34]

; 1825 :                 pUsbdRegs->EP_INTCLRR = (1 << endPoint) << USB_OTG_TXINT_SHIFT;

  000f0	e5892028	 str         r2, [r9, #0x28]

; 1826 :             }
; 1827 :         }
; 1828 :         else

  000f4	ea000001	 b           |$LN12@TxDmaTrans|
  000f8		 |$LN5@TxDmaTrans|

; 1829 :         {
; 1830 :             /* Now that the Transfer is complete, return back to IDLE State */
; 1831 :             pEP->epStage = MGC_END0_START;

  000f8	e58432a0	 str         r3, [r4, #0x2A0]

; 1832 :             pTransfer->dwUsbError = UFN_NO_ERROR;

  000fc	e587a014	 str         r10, [r7, #0x14]
  00100		 |$LN12@TxDmaTrans|

; 1833 :             complete = TRUE;

  00100	e3a08001	 mov         r8, #1
  00104		 |$LN3@TxDmaTrans|

; 1842 :     }
; 1843 : 
; 1844 :     /* Leave CriticalSection */
; 1845 :     UNLOCK_ENDPOINT(pPdd);

  00104	e2850e27	 add         r0, r5, #0x27, 28
  00108	eb000000	 bl          LeaveCriticalSection

; 1846 : 
; 1847 :     if (complete == TRUE)

  0010c	e3580001	 cmp         r8, #1

; 1848 :     {
; 1849 :         /* If transaction is complete we should tell MDD */
; 1850 :         PRINTMSG(ZONE_PDD_TX,
; 1851 :             (L"TxDmaTransferComplete: "
; 1852 :              L"EP %d, pTransfer 0x%08x (%d, %d, 0x%0x) - notify complete\r\n",
; 1853 :              endPoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 1854 :              pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 1855 :              pTransfer != NULL ? pTransfer->dwUsbError : -1));
; 1856 :         pEP->pTransfer = NULL;

  00110	0584a2a4	 streq       r10, [r4, #0x2A4]

; 1857 :         pPdd->pfnNotify (pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE,
; 1858 :                             (DWORD)pTransfer);

  00114	05950010	 ldreq       r0, [r5, #0x10]
  00118	05953014	 ldreq       r3, [r5, #0x14]
  0011c	01a02007	 moveq       r2, r7
  00120	03a01064	 moveq       r1, #0x64
  00124	01a0e00f	 moveq       lr, pc
  00128	012fff13	 bxeq        r3

; 1859 :     }
; 1860 :     return 0;

  0012c	e3a00000	 mov         r0, #0

; 1861 : }

  00130	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00134	e12fff1e	 bx          lr
  00138		 |$LN16@TxDmaTrans|
  00138		 |$LN17@TxDmaTrans|
  00138	00000000	 DCD         |??_C@_1DO@MIHBGHGK@?$AAE?$AAP?$AA?5?$AA?$CF?$AAu?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAi?$AAo?$AAn?$AA?$AN?$AA?6?$AA?$AA@|
  0013c		 |$LN18@TxDmaTrans|
  0013c	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  00140		 |$LN19@TxDmaTrans|
  00140	00000000	 DCD         |??_C@_1JO@JAGHJEHH@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  00144		 |$M48834|

			 ENDP  ; |TxDmaTransferComplete|

	EXPORT	|TxDmaFifoComplete|

  00000			 AREA	 |.pdata|, PDATA
|$T48857| DCD	|$LN11@TxDmaFifoC|
	DCD	0x40003901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TxDmaFifoComplete| PROC

; 1877 : {

  00000		 |$LN11@TxDmaFifoC|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M48854|
  00004	e1a06001	 mov         r6, r1
  00008	e1a05000	 mov         r5, r0

; 1878 :     USBFNPDDCONTEXT *pPdd = (USBFNPDDCONTEXT *)pDriverContext;
; 1879 :     CSL_UsbRegs     *pUsbdRegs = pPdd->pUsbdRegs;
; 1880 :     UsbFnEp         *pEP = &pPdd->ep[endPoint];

  0000c	e0663206	 rsb         r3, r6, r6, lsl #4
  00010	e0854103	 add         r4, r5, r3, lsl #2

; 1881 :     STransfer       *pTransfer = pEP->pTransfer;

  00014	e59432a4	 ldr         r3, [r4, #0x2A4]
  00018	e595901c	 ldr         r9, [r5, #0x1C]

; 1882 :     BOOL            complete = FALSE;

  0001c	e3a07000	 mov         r7, #0
  00020	e1b08003	 movs        r8, r3

; 1883 :     volatile UINT16 *pepCtrlReg;
; 1884 :     UINT16          epCsrReg;
; 1885 : 
; 1886 :     PRINTMSG(ZONE_PDD_TX,
; 1887 :              (L"TxDmaFifoComplete: "
; 1888 :               L"EP %d, pTransfer 0x%08x (%d, %d, 0x%0x)\r\n",
; 1889 :               endPoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 1890 :               pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 1891 :               pTransfer != NULL ? pTransfer->dwUsbError : -1));
; 1892 : 
; 1893 :     /* Sanity Check */
; 1894 :     if (pTransfer == NULL)
; 1895 :     {
; 1896 :         if (pEP->epStage != MGC_END0_START)

  00024	e59432a0	 ldr         r3, [r4, #0x2A0]
  00028	1a00000c	 bne         |$LN6@TxDmaFifoC|
  0002c	e3530001	 cmp         r3, #1
  00030	0a000007	 beq         |$LN5@TxDmaFifoC|

; 1897 :             ERRORMSG(TRUE, (L"EP %u Invalid DMA Completion\r\n", endPoint));

  00034	e59f10a4	 ldr         r1, [pc, #0xA4]
  00038	e59f009c	 ldr         r0, [pc, #0x9C]
  0003c	e3a03c07	 mov         r3, #7, 24
  00040	e3832069	 orr         r2, r3, #0x69
  00044	eb000000	 bl          NKDbgPrintfW
  00048	e59f0088	 ldr         r0, [pc, #0x88]
  0004c	e1a01006	 mov         r1, r6
  00050	eb000000	 bl          NKDbgPrintfW
  00054		 |$LN5@TxDmaFifoC|

; 1898 :         return 1;

  00054	e3a00001	 mov         r0, #1

; 1952 : }

  00058	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$LN6@TxDmaFifoC|

; 1899 :     }
; 1900 : 
; 1901 :     /* Check we were waiting for the final ACK interrupt */
; 1902 :     if (pEP->epStage != MGC_END0_STAGE_ACKWAIT)

  00060	e3530006	 cmp         r3, #6

; 1903 :     {
; 1904 :         PRINTMSG(ZONE_PDD_TX,
; 1905 :                  (L"TxDmaFifoComplete: EP %d, Not in fifo wait, transferred %d, len %d\r\n",
; 1906 :                   endPoint, pTransfer->cbTransferred, pTransfer->cbBuffer));
; 1907 :         return 0;

  00064	1a000018	 bne         |$LN1@TxDmaFifoC|

; 1908 :     }
; 1909 : 
; 1910 :     /* Enter CriticalSection */
; 1911 :     LOCK_ENDPOINT(pPdd);

  00068	e2850e27	 add         r0, r5, #0x27, 28
  0006c	eb000000	 bl          EnterCriticalSection

; 1912 : 
; 1913 :     /* Check that packet has gone out on bus. */
; 1914 :     pepCtrlReg = &pUsbdRegs->EPCSR[ endPoint ].PERI_TXCSR;

  00070	e0893206	 add         r3, r9, r6, lsl #4
  00074	e2833c05	 add         r3, r3, #5, 24

; 1915 :     epCsrReg = *pepCtrlReg;

  00078	e1d330b2	 ldrh        r3, [r3, #2]

; 1916 :     if ((epCsrReg & MGC_M_TXCSR_TXPKTRDY) != 0)

  0007c	e3a0a000	 mov         r10, #0

; 1917 :     {
; 1918 :         /* Need to keep waiting */
; 1919 :         PRINTMSG(ZONE_PDD_TX,
; 1920 :                  (L"TxDmaFifoComplete: EP %d, Wait for bus write\r\n", endPoint));
; 1921 :     }
; 1922 :     else
; 1923 :     {
; 1924 :         /* Now that the Transfer is complete, return back to IDLE State */
; 1925 :         pEP->epStage = MGC_END0_START;
; 1926 :         pTransfer->dwUsbError = UFN_NO_ERROR;
; 1927 :         complete = TRUE;
; 1928 :         
; 1929 :         /* Disable TX interrupt */
; 1930 :         pUsbdRegs->EP_INTMSKCLRR = (1 << endPoint) << USB_OTG_TXINT_SHIFT;
; 1931 :         pUsbdRegs->EP_INTCLRR = (1 << endPoint) << USB_OTG_TXINT_SHIFT;
; 1932 :     }
; 1933 : 
; 1934 :     /* Leave CriticalSection */
; 1935 :     UNLOCK_ENDPOINT(pPdd);

  00080	e2850e27	 add         r0, r5, #0x27, 28
  00084	e3130001	 tst         r3, #1
  00088	03a03001	 moveq       r3, #1
  0008c	03a02001	 moveq       r2, #1
  00090	01a03613	 moveq       r3, r3, lsl r6
  00094	058422a0	 streq       r2, [r4, #0x2A0]
  00098	0588a014	 streq       r10, [r8, #0x14]
  0009c	05893034	 streq       r3, [r9, #0x34]
  000a0	05893028	 streq       r3, [r9, #0x28]
  000a4	03a07001	 moveq       r7, #1
  000a8	eb000000	 bl          LeaveCriticalSection

; 1936 : 
; 1937 :     if (complete == TRUE)

  000ac	e3570001	 cmp         r7, #1

; 1938 :     {
; 1939 :         /* If transaction is complete we should tell MDD */
; 1940 :         PRINTMSG(ZONE_PDD_TX,
; 1941 :                  (L"TxDmaFifoComplete: "
; 1942 :              L"EP %d, pTransfer 0x%08x (%d, %d, 0x%0x) - notify complete\r\n",
; 1943 :              endPoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 1944 :              pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 1945 :              pTransfer != NULL ? pTransfer->dwUsbError : -1));
; 1946 :         pEP->pTransfer = NULL;

  000b0	0584a2a4	 streq       r10, [r4, #0x2A4]

; 1947 :         pPdd->pfnNotify (pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE,
; 1948 :                          (DWORD)pTransfer);

  000b4	05950010	 ldreq       r0, [r5, #0x10]
  000b8	05953014	 ldreq       r3, [r5, #0x14]
  000bc	01a02008	 moveq       r2, r8
  000c0	03a01064	 moveq       r1, #0x64
  000c4	01a0e00f	 moveq       lr, pc
  000c8	012fff13	 bxeq        r3
  000cc		 |$LN1@TxDmaFifoC|

; 1949 :     }
; 1950 : 
; 1951 :     return 0;

  000cc	e3a00000	 mov         r0, #0

; 1952 : }

  000d0	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  000d4	e12fff1e	 bx          lr
  000d8		 |$LN12@TxDmaFifoC|
  000d8		 |$LN13@TxDmaFifoC|
  000d8	00000000	 DCD         |??_C@_1DO@MIHBGHGK@?$AAE?$AAP?$AA?5?$AA?$CF?$AAu?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAi?$AAo?$AAn?$AA?$AN?$AA?6?$AA?$AA@|
  000dc		 |$LN14@TxDmaFifoC|
  000dc	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  000e0		 |$LN15@TxDmaFifoC|
  000e0	00000000	 DCD         |??_C@_1JO@JAGHJEHH@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  000e4		 |$M48855|

			 ENDP  ; |TxDmaFifoComplete|

	EXPORT	|??_C@_1LC@FLMHBHEN@?$AAS?$AAt?$AAa?$AAr?$AAt?$AAR?$AAx?$AAD?$AAm?$AAa?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AAI?$AAS?$AAO?$AA?5?$AAt@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T48877| DCD	|$LN11@StartRxDma|
	DCD	0x40004701

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1LC@FLMHBHEN@?$AAS?$AAt?$AAa?$AAr?$AAt?$AAR?$AAx?$AAD?$AAm?$AAa?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AAI?$AAS?$AAO?$AA?5?$AAt@| DCB "S"
	DCB	0x0, "t", 0x0, "a", 0x0, "r", 0x0, "t", 0x0, "R", 0x0, "x"
	DCB	0x0, "D", 0x0, "m", 0x0, "a", 0x0, "T", 0x0, "r", 0x0, "a"
	DCB	0x0, "n", 0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, ":"
	DCB	0x0, " ", 0x0, "E", 0x0, "P", 0x0, " ", 0x0, "%", 0x0, "d"
	DCB	0x0, ",", 0x0, " ", 0x0, "I", 0x0, "S", 0x0, "O", 0x0, " "
	DCB	0x0, "t", 0x0, "r", 0x0, "a", 0x0, "n", 0x0, "s", 0x0, "f"
	DCB	0x0, "e", 0x0, "r", 0x0, "s", 0x0, " ", 0x0, "o", 0x0, "n"
	DCB	0x0, "l", 0x0, "y", 0x0, " ", 0x0, "s", 0x0, "u", 0x0, "p"
	DCB	0x0, "p", 0x0, "o", 0x0, "r", 0x0, "t", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "w", 0x0, "i", 0x0, "t", 0x0, "h", 0x0, " "
	DCB	0x0, "p", 0x0, "h", 0x0, "y", 0x0, "s", 0x0, "i", 0x0, "c"
	DCB	0x0, "a", 0x0, "l", 0x0, " ", 0x0, "b", 0x0, "u", 0x0, "f"
	DCB	0x0, "f", 0x0, "e", 0x0, "r", 0x0, " ", 0x0, "a", 0x0, "d"
	DCB	0x0, "d", 0x0, "r", 0x0, "e", 0x0, "s", 0x0, "s", 0x0, "e"
	DCB	0x0, "s", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |StartRxDmaTransfer| PROC

; 1974 : {

  00000		 |$LN11@StartRxDma|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M48874|
  00004	e1a07001	 mov         r7, r1
  00008	e1a06000	 mov         r6, r0

; 1975 :     CSL_UsbRegs    *pUsbdRegs = pPdd->pUsbdRegs;
; 1976 :     UsbFnEp        *pEP = &pPdd->ep[endPoint];

  0000c	e0673207	 rsb         r3, r7, r7, lsl #4
  00010	e0864103	 add         r4, r6, r3, lsl #2

; 1977 :     STransfer      *pTransfer = pEP->pTransfer;
; 1978 : 
; 1979 :     DWORD size;
; 1980 :     USHORT cfn;
; 1981 :     UINT16 rxCsrVal;
; 1982 : 
; 1983 : #ifdef CPPI_DMA_SUPPORT
; 1984 :     UINT32  dmaAddress;
; 1985 : 
; 1986 :     struct dma_controller * pDmaCntrl =
; 1987 :                 (struct dma_controller *)pPdd->pDmaCntrl;
; 1988 : 
; 1989 : #endif /* #ifdef CPPI_DMA_SUPPORT */
; 1990 : 
; 1991 :     PRINTMSG(ZONE_PDD_RX,
; 1992 :              (L"StartRxDmaTransfer: EP %d, pTransfer 0x%08x (%d, %d, 0x%0x)\r\n",
; 1993 :               endPoint, pTransfer,
; 1994 :               pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 1995 :               pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 1996 :               pTransfer != NULL ? pTransfer->dwUsbError : -1));
; 1997 : 
; 1998 :     /* Lock the EndPoint */
; 1999 :     LOCK_ENDPOINT (pPdd);

  00014	e59452a4	 ldr         r5, [r4, #0x2A4]
  00018	e596901c	 ldr         r9, [r6, #0x1C]
  0001c	e596865c	 ldr         r8, [r6, #0x65C]
  00020	e2860e27	 add         r0, r6, #0x27, 28
  00024	eb000000	 bl          EnterCriticalSection

; 2000 : 
; 2001 :     if (pTransfer == NULL) goto cleanUp;

  00028	e3550000	 cmp         r5, #0
  0002c	0a000035	 beq         |$cleanUp$47591|

; 2002 : 
; 2003 :     pEP->usingDma = TRUE;
; 2004 : 
; 2005 :     /* Currently only support phyisical buffer addresses with overlapped ISO */
; 2006 :     if (pEP->endpointType == USB_ENDPOINT_TYPE_ISOCHRONOUS &&
; 2007 :         (pTransfer->dwFlags & USB_OVERLAPPED) &&
; 2008 :         pTransfer->dwBufferPhysicalAddress == 0)

  00030	e5d43290	 ldrb        r3, [r4, #0x290]
  00034	e3a02001	 mov         r2, #1
  00038	e58422ac	 str         r2, [r4, #0x2AC]
  0003c	e3530001	 cmp         r3, #1
  00040	1a000009	 bne         |$LN5@StartRxDma|
  00044	e5953000	 ldr         r3, [r5]
  00048	e3130001	 tst         r3, #1
  0004c	0a000006	 beq         |$LN5@StartRxDma|
  00050	e5953008	 ldr         r3, [r5, #8]
  00054	e3530000	 cmp         r3, #0
  00058	1a000003	 bne         |$LN5@StartRxDma|

; 2009 :     {
; 2010 :         PRINTMSG(ZONE_ERROR,
; 2011 :                  (L"StartRxDmaTransfer: EP %d, ISO transfers only supported with physical buffer addresses\r\n",
; 2012 :                   endPoint));

  0005c	e59f00b4	 ldr         r0, [pc, #0xB4]
  00060	e1a01007	 mov         r1, r7
  00064	eb000000	 bl          NKDbgPrintfW

; 2013 :         goto cleanUp;

  00068	ea000026	 b           |$cleanUp$47591|
  0006c		 |$LN5@StartRxDma|

; 2014 :     }
; 2015 : 
; 2016 :     /* Get size of Data to be received */
; 2017 :     size = pTransfer->cbBuffer - pTransfer->cbTransferred;

  0006c	e595100c	 ldr         r1, [r5, #0xC]
  00070	e5953010	 ldr         r3, [r5, #0x10]

; 2018 : 
; 2019 :     /* If we are using PDD buffer we must check for maximal size
; 2020 :      * Our DMA Buffer Sizes are limited. Hence, we will have to
; 2021 :      * chunk up the entire DMA Transfer in multiple blocks
; 2022 :      * wherein each block is equal to the Total DMA Buffer
; 2023 :      * Size
; 2024 :      */
; 2025 :     if ((pTransfer->dwBufferPhysicalAddress == 0) &&
; 2026 :         (size > pPdd->dmaBufferSize))

  00074	e5952008	 ldr         r2, [r5, #8]
  00078	e041e003	 sub         lr, r1, r3
  0007c	e3520000	 cmp         r2, #0
  00080	1a000002	 bne         |$LN4@StartRxDma|
  00084	e5963008	 ldr         r3, [r6, #8]
  00088	e15e0003	 cmp         lr, r3

; 2027 :     {
; 2028 :         /* check for the Size below */
; 2029 :         PRINTMSG(ZONE_PDD_RX,
; 2030 :                  (L"StartRxDmaTransfer: EP %d, transfer size 0x%x larger than DMABufSize 0x%x\r\n",
; 2031 :                   endPoint, size, pPdd->dmaBufferSize));
; 2032 :         size = pPdd->dmaBufferSize;

  0008c	81a0e003	 movhi       lr, r3
  00090		 |$LN4@StartRxDma|

; 2033 :     }
; 2034 : 
; 2035 :     /* Calculate number of USB packets (aka frames) */
; 2036 :     cfn = (USHORT)((size + pEP->maxPacketSize - 1)/pEP->maxPacketSize);
; 2037 : 
; 2038 :     /* Configure the RxCSR in DMA Mode */
; 2039 : 
; 2040 :     rxCsrVal = pUsbdRegs->EPCSR[ endPoint ].PERI_RXCSR;

  00090	e0893207	 add         r3, r9, r7, lsl #4
  00094	e2830c05	 add         r0, r3, #5, 24
  00098	e1d020b6	 ldrh        r2, [r0, #6]
  0009c	e3a03c57	 mov         r3, #0x57, 24

; 2041 :     rxCsrVal &= ~(MGC_M_RXCSR_AUTOCLEAR | MGC_M_RXCSR_DMAMODE);

  000a0	e38330ba	 orr         r3, r3, #0xBA
  000a4	e3a01a02	 mov         r1, #2, 20

; 2042 :     /* Note: Must ensure that no bits are cleared here, particularly RXPKTRDY,
; 2043 :        which could be set between reading and writing the register. */
; 2044 :     rxCsrVal |= MGC_M_RXCSR_DMAENAB | MGC_M_RXCSR_P_WZC_BITS;
; 2045 :     pUsbdRegs->EPCSR[ endPoint ].PERI_RXCSR = rxCsrVal;
; 2046 : 
; 2047 : #ifdef CPPI_DMA_SUPPORT
; 2048 :     /* Disable the Rx interrupts for this EndPoint */
; 2049 :     pUsbdRegs->EP_INTMSKCLRR = (1 << endPoint) << USB_OTG_RXINT_SHIFT;

  000a8	e0022003	 and         r2, r2, r3
  000ac	e3813045	 orr         r3, r1, #0x45
  000b0	e3a0a001	 mov         r10, #1
  000b4	e1823003	 orr         r3, r2, r3
  000b8	e1a0171a	 mov         r1, r10, lsl r7
  000bc	e1c030b6	 strh        r3, [r0, #6]
  000c0	e1a03801	 mov         r3, r1, lsl #16
  000c4	e5893034	 str         r3, [r9, #0x34]

; 2050 : 
; 2051 :     if (pTransfer->dwBufferPhysicalAddress == 0)

  000c8	e5953008	 ldr         r3, [r5, #8]
  000cc	e1b02003	 movs        r2, r3

; 2052 :     {
; 2053 :         dmaAddress = pEP->paDmaBuffer;
; 2054 :     }
; 2055 :     else
; 2056 :     {
; 2057 :         dmaAddress = (UINT32)pTransfer->dwBufferPhysicalAddress;
; 2058 :         PRINTMSG(ZONE_PDD_RX,
; 2059 :                  (L"StartRxDmaTransfer: EP %d, DMA to client buffer 0x%08x\r\n",
; 2060 :                   endPoint, dmaAddress));
; 2061 :     }
; 2062 : 
; 2063 :     // Overlapped transfer?
; 2064 :     pEP->pOverlappedInfo = NULL;

  000d0	e3a03000	 mov         r3, #0
  000d4	e58432bc	 str         r3, [r4, #0x2BC]

; 2065 :     if (pTransfer->dwFlags & USB_OVERLAPPED)

  000d8	e5951000	 ldr         r1, [r5]
  000dc	059422b8	 ldreq       r2, [r4, #0x2B8]

; 2066 :     {
; 2067 :         pEP->pOverlappedInfo = (PUSB_OVERLAPPED_INFO)pTransfer->pvPddTransferInfo;
; 2068 :     }
; 2069 : 
; 2070 : #ifdef OVERLAPPED_TEST
; 2071 :     {
; 2072 :         static USB_OVERLAPPED_INFO ov;
; 2073 :         ov.lpUserData = NULL;
; 2074 :         ov.dwBytesToIssueCallback = pTransfer->cbBuffer * 3 / 4;
; 2075 :         pEP->pOverlappedInfo = &ov;
; 2076 :     }
; 2077 : #endif
; 2078 : 
; 2079 :     /* Verify the Rx DMA Channel Condition Once
; 2080 :      * The Third argument is a bool which checks whether we
; 2081 :      * require multiple BDs or the entire request can be
; 2082 :      * serviced in one single BD. If the requested Packet
; 2083 :      * size is greater than the EpFifoMaxSize, then we
; 2084 :      * require multiple BDs to service this request
; 2085 :      */
; 2086 :     pDmaCntrl->channelProgram(
; 2087 :         pPdd->ep[endPoint].pDmaChan,
; 2088 :         pPdd->ep[endPoint].maxPacketSize,
; 2089 :         dmaAddress,
; 2090 :         size);

  000e0	e1a0300e	 mov         r3, lr
  000e4	e3110001	 tst         r1, #1
  000e8	1595101c	 ldrne       r1, [r5, #0x1C]
  000ec	158412bc	 strne       r1, [r4, #0x2BC]
  000f0	e59402b0	 ldr         r0, [r4, #0x2B0]
  000f4	e2841c02	 add         r1, r4, #2, 24
  000f8	e1d118bc	 ldrh        r1, [r1, #0x8C]
  000fc	e5984010	 ldr         r4, [r8, #0x10]
  00100	e1a0e00f	 mov         lr, pc
  00104	e12fff14	 bx          r4
  00108		 |$cleanUp$47591|

; 2091 : 
; 2092 : #endif  /* CPPI_DMA_SUPPORT */
; 2093 : 
; 2094 : cleanUp:
; 2095 :     /* Unlock the EndPoint */
; 2096 :     UNLOCK_ENDPOINT (pPdd);

  00108	e2860e27	 add         r0, r6, #0x27, 28
  0010c	eb000000	 bl          LeaveCriticalSection

; 2097 : 
; 2098 :     return;
; 2099 : }

  00110	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00114	e12fff1e	 bx          lr
  00118		 |$LN12@StartRxDma|
  00118		 |$LN13@StartRxDma|
  00118	00000000	 DCD         |??_C@_1LC@FLMHBHEN@?$AAS?$AAt?$AAa?$AAr?$AAt?$AAR?$AAx?$AAD?$AAm?$AAa?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AAI?$AAS?$AAO?$AA?5?$AAt@|
  0011c		 |$M48875|

			 ENDP  ; |StartRxDmaTransfer|

	EXPORT	|RxDmaTransferComplete|
	EXPORT	|??_C@_1GE@DBKHBDHF@?$AAR?$AAx?$AAD?$AAm?$AAa?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AA?3?$AA?5?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?5?$AAb?$AAu@| [ DATA ] ; `string'
	EXPORT	|??_C@_1JK@FELCEFFK@?$AAR?$AAx?$AAD?$AAm?$AAa?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAu?$AA?0?$AA?5?$AAE?$AAr@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T48912| DCD	|$LN29@RxDmaTrans|
	DCD	0xc0008205

  00000			 AREA	 |.pdata|, PDATA
|$T48914| DCD	|$LN16@RxDmaTrans|
	DCD	0x40000801

  00000			 AREA	 |.xdata|, DATA
|$T48910| DCD	0x1
	DCD	|$LN20@RxDmaTrans|
	DCD	|$LN21@RxDmaTrans|
	DCD	|$LN16@RxDmaTrans|
	DCD	|$LN17@RxDmaTrans|

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GE@DBKHBDHF@?$AAR?$AAx?$AAD?$AAm?$AAa?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AA?3?$AA?5?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?5?$AAb?$AAu@| DCB "R"
	DCB	0x0, "x", 0x0, "D", 0x0, "m", 0x0, "a", 0x0, "T", 0x0, "r"
	DCB	0x0, "a", 0x0, "n", 0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r"
	DCB	0x0, "C", 0x0, "o", 0x0, "m", 0x0, "p", 0x0, "l", 0x0, "e"
	DCB	0x0, "t", 0x0, "e", 0x0, ":", 0x0, " ", 0x0, "C", 0x0, "l"
	DCB	0x0, "i", 0x0, "e", 0x0, "n", 0x0, "t", 0x0, " ", 0x0, "b"
	DCB	0x0, "u", 0x0, "f", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "e", 0x0, "x", 0x0, "c", 0x0, "e", 0x0, "p", 0x0, "t"
	DCB	0x0, "i", 0x0, "o", 0x0, "n", 0x0, "!", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1JK@FELCEFFK@?$AAR?$AAx?$AAD?$AAm?$AAa?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAu?$AA?0?$AA?5?$AAE?$AAr@| DCB "R"
	DCB	0x0, "x", 0x0, "D", 0x0, "m", 0x0, "a", 0x0, "T", 0x0, "r"
	DCB	0x0, "a", 0x0, "n", 0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r"
	DCB	0x0, "C", 0x0, "o", 0x0, "m", 0x0, "p", 0x0, "l", 0x0, "e"
	DCB	0x0, "t", 0x0, "e", 0x0, ":", 0x0, " ", 0x0, "E", 0x0, "P"
	DCB	0x0, " ", 0x0, "%", 0x0, "u", 0x0, ",", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ",", 0x0, " "
	DCB	0x0, "a", 0x0, "c", 0x0, "t", 0x0, "u", 0x0, "a", 0x0, "l"
	DCB	0x0, " ", 0x0, "D", 0x0, "M", 0x0, "A", 0x0, " ", 0x0, "l"
	DCB	0x0, "e", 0x0, "n", 0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%"
	DCB	0x0, "x", 0x0, ",", 0x0, " ", 0x0, "b", 0x0, "u", 0x0, "f"
	DCB	0x0, "f", 0x0, "e", 0x0, "r", 0x0, " ", 0x0, "l", 0x0, "e"
	DCB	0x0, "f", 0x0, "t", 0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%"
	DCB	0x0, "X", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T48910|

  00008		 |RxDmaTransferComplete| PROC

; 2123 : {

  00008		 |$LN29@RxDmaTrans|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d0007	 stmdb       sp!, {r0 - r2}
  00010	e92d5ff0	 stmdb       sp!, {r4 - r12, lr}
  00014	e28db028	 add         r11, sp, #0x28
  00018	e24dd01c	 sub         sp, sp, #0x1C
  0001c		 |$LN27@RxDmaTrans|
  0001c	e1a09002	 mov         r9, r2
  00020	e58b9008	 str         r9, [r11, #8]
  00024	e1a06000	 mov         r6, r0
  00028	e58b6000	 str         r6, [r11]

; 2124 :     USBFNPDDCONTEXT *pPdd = (USBFNPDDCONTEXT *)pDriverContext;
; 2125 :     CSL_UsbRegs     *pUsbdRegs = pPdd->pUsbdRegs;
; 2126 :     UsbFnEp         *pEP = &pPdd->ep[endPoint];

  0002c	e0693209	 rsb         r3, r9, r9, lsl #4
  00030	e0861103	 add         r1, r6, r3, lsl #2
  00034	e2817fa1	 add         r7, r1, #0xA1, 30
  00038	e50b702c	 str         r7, [r11, #-0x2C]
  0003c	e596a01c	 ldr         r10, [r6, #0x1C]
  00040	e50ba038	 str         r10, [r11, #-0x38]

; 2127 :     STransfer       *pTransfer = pEP->pTransfer;

  00044	e5973020	 ldr         r3, [r7, #0x20]

; 2128 :     UCHAR *pBuffer = NULL;
; 2129 :     DWORD size;
; 2130 :     BOOL complete = FALSE;
; 2131 :     DWORD   bytesCopied = 0;
; 2132 :     UINT16 rxCsrVal = 0;
; 2133 : 
; 2134 : #ifdef CPPI_DMA_SUPPORT
; 2135 :     struct cppi_channel *pDmaChan = (struct cppi_channel *)
; 2136 :                                     pPdd->ep[endPoint].pDmaChan;

  00048	e59152b0	 ldr         r5, [r1, #0x2B0]
  0004c	e50ba030	 str         r10, [r11, #-0x30]
  00050	e1b04003	 movs        r4, r3
  00054	e50b4034	 str         r4, [r11, #-0x34]
  00058	e3a08000	 mov         r8, #0

; 2137 : #endif /* #ifdef CPPI_DMA_SUPPORT */
; 2138 : 
; 2139 : 	UNREFERENCED_PARAMETER(chanNumber);
; 2140 : 
; 2141 :     PRINTMSG(ZONE_PDD_RX,
; 2142 :              (L"RxDmaTransferComplete: EP %u, pTransfer 0x%08x (%d, %d, 0x%0x)\r\n",
; 2143 :               endPoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 2144 :               pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 2145 :               pTransfer != NULL ? pTransfer->dwUsbError : -1));
; 2146 : 
; 2147 :     /* Sanity Check */
; 2148 :     if (pTransfer == NULL)

  0005c	1a00000c	 bne         |$LN12@RxDmaTrans|

; 2149 :     {
; 2150 :         /* Not an error if transfer was aborted */
; 2151 :         if (pEP->epStage != MGC_END0_START)

  00060	e597301c	 ldr         r3, [r7, #0x1C]
  00064	e3530001	 cmp         r3, #1
  00068	0a000007	 beq         |$LN11@RxDmaTrans|

; 2152 :             ERRORMSG(TRUE,
; 2153 :                      (L"EP %u Invalid DMA Completion\r\n", endPoint));

  0006c	e59f11b8	 ldr         r1, [pc, #0x1B8]
  00070	e59f01b0	 ldr         r0, [pc, #0x1B0]
  00074	e3a03b02	 mov         r3, #2, 22
  00078	e3832069	 orr         r2, r3, #0x69
  0007c	eb000000	 bl          NKDbgPrintfW
  00080	e59f019c	 ldr         r0, [pc, #0x19C]
  00084	e1a01009	 mov         r1, r9
  00088	eb000000	 bl          NKDbgPrintfW
  0008c		 |$LN11@RxDmaTrans|

; 2154 :         return (1);

  0008c	e3a00001	 mov         r0, #1
  00090	ea00005b	 b           |$LN13@RxDmaTrans|
  00094		 |$LN12@RxDmaTrans|

; 2155 :     }
; 2156 :     /* Enter CriticalSection */
; 2157 :     LOCK_ENDPOINT(pPdd);

  00094	e2860e27	 add         r0, r6, #0x27, 28
  00098	eb000000	 bl          EnterCriticalSection

; 2158 : 
; 2159 :     if (pTransfer->dwBufferPhysicalAddress == 0)

  0009c	e5943008	 ldr         r3, [r4, #8]
  000a0	e3530000	 cmp         r3, #0
  000a4	1a000039	 bne         |$LN10@RxDmaTrans|

; 2160 :     {
; 2161 :         /* Copy Data back from DMA Buffer to Driver Buffer */
; 2162 :         pBuffer = (UCHAR*)pTransfer->pvBuffer + pTransfer->cbTransferred;

  000a8	e594a010	 ldr         r10, [r4, #0x10]

; 2163 : 
; 2164 :         /* Get size and buffer position */
; 2165 :         size = pTransfer->cbBuffer - pTransfer->cbTransferred;

  000ac	e594300c	 ldr         r3, [r4, #0xC]

; 2166 : 
; 2167 : #ifdef CPPI_DMA_SUPPORT
; 2168 :         bytesCopied = pDmaChan->actualLen;

  000b0	e5955030	 ldr         r5, [r5, #0x30]
  000b4	e594e004	 ldr         lr, [r4, #4]
  000b8	e50be03c	 str         lr, [r11, #-0x3C]
  000bc	e043300a	 sub         r3, r3, r10
  000c0	e50b3040	 str         r3, [r11, #-0x40]

; 2169 : 
; 2170 :         if (bytesCopied > size)

  000c4	e1550003	 cmp         r5, r3
  000c8	e50b5044	 str         r5, [r11, #-0x44]
  000cc	9a000008	 bls         |$LN9@RxDmaTrans|

; 2171 :         {
; 2172 :             PRINTMSG(ZONE_ERROR,
; 2173 :                      (L"RxDmaTransferComplete: EP %u, Error, actual DMA len 0x%x, buffer left 0x%X\r\n",
; 2174 :                       endPoint, pDmaChan->actualLen, pBuffer));

  000d0	e59f0148	 ldr         r0, [pc, #0x148]
  000d4	e08e300a	 add         r3, lr, r10
  000d8	e1a02005	 mov         r2, r5
  000dc	e1a01009	 mov         r1, r9
  000e0	eb000000	 bl          NKDbgPrintfW

; 2175 :             bytesCopied = size;

  000e4	e51b3040	 ldr         r3, [r11, #-0x40]
  000e8	e1a05003	 mov         r5, r3
  000ec	e50b3044	 str         r3, [r11, #-0x44]

; 2166 : 
; 2167 : #ifdef CPPI_DMA_SUPPORT
; 2168 :         bytesCopied = pDmaChan->actualLen;

  000f0	e51be03c	 ldr         lr, [r11, #-0x3C]

; 2175 :             bytesCopied = size;

  000f4		 |$LN9@RxDmaTrans|
  000f4		 |$LN20@RxDmaTrans|

; 2176 :         }
; 2177 : #endif /* #ifdef CPPI_DMA_SUPPORT */
; 2178 : 
; 2179 :         __try
; 2180 :         {
; 2181 :             /* Copy into MDD Buffer from DMA Buffer */
; 2182 :             if (bytesCopied > 0)

  000f4	e3550000	 cmp         r5, #0

; 2183 :                 memcpy(pBuffer, pEP->pDmaBuffer, bytesCopied);

  000f8	15971030	 ldrne       r1, [r7, #0x30]
  000fc	11a02005	 movne       r2, r5
  00100	108e000a	 addne       r0, lr, r10
  00104	1b000000	 blne        memcpy
  00108		 |$LN21@RxDmaTrans|

; 2184 :         }

  00108	e51ba038	 ldr         r10, [r11, #-0x38]
  0010c	ea00000a	 b           |$LN22@RxDmaTrans|
  00110		 |$LN17@RxDmaTrans|

; 2186 :         {
; 2187 :             pTransfer->dwUsbError = UFN_CLIENT_BUFFER_ERROR;

  00110	e51b4034	 ldr         r4, [r11, #-0x34]

; 2188 :             complete = TRUE;
; 2189 :             PRINTMSG(ZONE_ERROR, (L"RxDmaTransferComplete: Client buffer exception!\r\n"));

  00114	e59f0100	 ldr         r0, [pc, #0x100]
  00118	e3a03f41	 mov         r3, #0x41, 30
  0011c	e5843014	 str         r3, [r4, #0x14]
  00120	e3a08001	 mov         r8, #1
  00124	eb000000	 bl          NKDbgPrintfW
  00128	e59b9008	 ldr         r9, [r11, #8]
  0012c	e59b6000	 ldr         r6, [r11]
  00130	e51ba030	 ldr         r10, [r11, #-0x30]
  00134	e51b702c	 ldr         r7, [r11, #-0x2C]
  00138	e51b5044	 ldr         r5, [r11, #-0x44]
  0013c		 |$LN22@RxDmaTrans|

; 2190 :         }
; 2191 : 
; 2192 :         pTransfer->cbTransferred += bytesCopied;

  0013c	e5943010	 ldr         r3, [r4, #0x10]
  00140	e0832005	 add         r2, r3, r5
  00144	e5842010	 str         r2, [r4, #0x10]

; 2193 : 
; 2194 :         /* Now Perform a check if the complete chunk is over or not */
; 2195 : 
; 2196 :         /* When we get less than buffer size or transaction buffer
; 2197 :          * is full transfer finished.
; 2198 :          */
; 2199 :         if ((bytesCopied < pPdd->dmaBufferSize) ||
; 2200 :             (pTransfer->cbTransferred >= pTransfer->cbBuffer))

  00148	e5963008	 ldr         r3, [r6, #8]
  0014c	e1550003	 cmp         r5, r3
  00150	3a000007	 bcc         |$LN5@RxDmaTrans|
  00154	e594300c	 ldr         r3, [r4, #0xC]
  00158	e1520003	 cmp         r2, r3
  0015c	2a000004	 bcs         |$LN5@RxDmaTrans|

; 2205 :             complete = TRUE;
; 2206 :         }
; 2207 :         else
; 2208 :         {
; 2209 :             /* Start another transfer */
; 2210 :             StartRxDmaTransfer(pPdd, endPoint);

  00160	e1a01009	 mov         r1, r9
  00164	e1a00006	 mov         r0, r6
  00168	eb000000	 bl          StartRxDmaTransfer
  0016c	e3a05000	 mov         r5, #0
  00170	ea00000f	 b           |$LN3@RxDmaTrans|
  00174		 |$LN5@RxDmaTrans|

; 2201 :         {
; 2202 :             /* Now that the Transfer is complete, return back to IDLE State */
; 2203 :             pTransfer->dwUsbError = UFN_NO_ERROR;

  00174	e3a05000	 mov         r5, #0

; 2204 :             pEP->epStage   = MGC_END0_START;

  00178	e3a03001	 mov         r3, #1
  0017c	e5845014	 str         r5, [r4, #0x14]
  00180	e587301c	 str         r3, [r7, #0x1C]

; 2211 :         }
; 2212 :     }
; 2213 :     else

  00184	ea000009	 b           |$LN26@RxDmaTrans|
  00188		 |$LN25@RxDmaTrans|

; 2248 :     }
; 2249 : 
; 2250 :     return (0);

  00188	e51b002c	 ldr         r0, [r11, #-0x2C]
  0018c	ea00001c	 b           |$LN13@RxDmaTrans|
  00190		 |$LN10@RxDmaTrans|

; 2214 :     {
; 2215 : #ifdef CPPI_DMA_SUPPORT
; 2216 :         /* Data copied direct to client buffer */
; 2217 :         pTransfer->cbTransferred += pDmaChan->actualLen;

  00190	e5942010	 ldr         r2, [r4, #0x10]
  00194	e5953030	 ldr         r3, [r5, #0x30]

; 2218 :         pTransfer->dwUsbError = UFN_NO_ERROR;

  00198	e3a05000	 mov         r5, #0

; 2219 :         pEP->epStage = MGC_END0_START;

  0019c	e3a01001	 mov         r1, #1
  001a0	e0823003	 add         r3, r2, r3
  001a4	e5843010	 str         r3, [r4, #0x10]
  001a8	e5845014	 str         r5, [r4, #0x14]
  001ac	e587101c	 str         r1, [r7, #0x1C]
  001b0		 |$LN26@RxDmaTrans|

; 2220 :         complete = TRUE;

  001b0	e3a08001	 mov         r8, #1
  001b4		 |$LN3@RxDmaTrans|

; 2221 : #endif
; 2222 :     }
; 2223 : 
; 2224 :     if (complete == TRUE)

  001b4	e3580001	 cmp         r8, #1

; 2225 :     {
; 2226 :         /* Disable DMA */
; 2227 :         rxCsrVal = pUsbdRegs->EPCSR[ endPoint ].PERI_RXCSR;

  001b8	008a3209	 addeq       r3, r10, r9, lsl #4
  001bc	02830c05	 addeq       r0, r3, #5, 24
  001c0	01d010b6	 ldreqh      r1, [r0, #6]
  001c4	03a03cdf	 moveq       r3, #0xDF, 24

; 2228 :         rxCsrVal &= ~(MGC_M_RXCSR_DMAENAB);

  001c8	038330ba	 orreq       r3, r3, #0xBA
  001cc	00013003	 andeq       r3, r1, r3

; 2229 :         rxCsrVal |= MGC_M_RXCSR_P_WZC_BITS;

  001d0	03833045	 orreq       r3, r3, #0x45

; 2230 :         pUsbdRegs->EPCSR[ endPoint ].PERI_RXCSR = rxCsrVal;

  001d4	01c030b6	 streqh      r3, [r0, #6]

; 2231 :     }
; 2232 : 
; 2233 :     /* Leave CriticalSection */
; 2234 :     UNLOCK_ENDPOINT(pPdd);

  001d8	e2860e27	 add         r0, r6, #0x27, 28
  001dc	eb000000	 bl          LeaveCriticalSection

; 2235 : 
; 2236 :     if (complete == TRUE)

  001e0	e3580001	 cmp         r8, #1

; 2237 :     {
; 2238 :         /* If transaction is complete we should tell MDD */
; 2239 :         PRINTMSG(ZONE_PDD_RX,
; 2240 :             (L"RxDmaTransferComplete: "
; 2241 :              L"EP %d, pTransfer 0x%08x (%d, %d, 0x%0x) - notify complete\r\n",
; 2242 :              endPoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 2243 :              pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 2244 :              pTransfer != NULL ? pTransfer->dwUsbError : -1));
; 2245 :         pEP->pTransfer = NULL;

  001e4	05875020	 streq       r5, [r7, #0x20]

; 2246 :         pPdd->pfnNotify (pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE,
; 2247 :                         (DWORD)pTransfer);

  001e8	05960010	 ldreq       r0, [r6, #0x10]
  001ec	05963014	 ldreq       r3, [r6, #0x14]
  001f0	01a02004	 moveq       r2, r4
  001f4	03a01064	 moveq       r1, #0x64
  001f8	01a0e00f	 moveq       lr, pc
  001fc	012fff13	 bxeq        r3

; 2248 :     }
; 2249 : 
; 2250 :     return (0);

  00200	e3a00000	 mov         r0, #0
  00204		 |$LN13@RxDmaTrans|

; 2251 : }

  00204	e24bd028	 sub         sp, r11, #0x28
  00208	e89d6ff0	 ldmia       sp, {r4 - r11, sp, lr}
  0020c	e12fff1e	 bx          lr

			 ENDP  ; |RxDmaTransferComplete|

  00210		 |$LN16@RxDmaTrans|
  00210		 |$LN28@RxDmaTrans|

; 2185 :         __except(EXCEPTION_EXECUTE_HANDLER)

  00210	e52de004	 str         lr, [sp, #-4]!
  00214		 |$LN19@RxDmaTrans|
  00214		 |$LN31@RxDmaTrans|
  00214	e3a00001	 mov         r0, #1
  00218		 |$LN18@RxDmaTrans|
  00218	e49df004	 ldr         pc, [sp], #4
  0021c		 |$LN33@RxDmaTrans|
  0021c		 |$LN34@RxDmaTrans|
  0021c	00000000	 DCD         |??_C@_1GE@DBKHBDHF@?$AAR?$AAx?$AAD?$AAm?$AAa?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AA?3?$AA?5?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?5?$AAb?$AAu@|
  00220		 |$LN35@RxDmaTrans|
  00220	00000000	 DCD         |??_C@_1JK@FELCEFFK@?$AAR?$AAx?$AAD?$AAm?$AAa?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAu?$AA?0?$AA?5?$AAE?$AAr@|
  00224		 |$LN36@RxDmaTrans|
  00224	00000000	 DCD         |??_C@_1DO@MIHBGHGK@?$AAE?$AAP?$AA?5?$AA?$CF?$AAu?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAi?$AAo?$AAn?$AA?$AN?$AA?6?$AA?$AA@|
  00228		 |$LN37@RxDmaTrans|
  00228	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  0022c		 |$LN38@RxDmaTrans|
  0022c	00000000	 DCD         |??_C@_1JO@JAGHJEHH@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  00230		 |$LN32@RxDmaTrans|
  00230		 |$LN30@RxDmaTrans|
	EXPORT	|UfnPdd_IssueTransfer|
	EXPORT	|??_C@_1HK@LMIAFHNK@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAs?$AAs?$AAu?$AAe?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?$CF?$AAu?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr@| [ DATA ] ; `string'
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T48950| DCD	|$LN27@UfnPdd_Iss|
	DCD	0x40004b01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HK@LMIAFHNK@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAs?$AAs?$AAu?$AAe?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?$CF?$AAu?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr@| DCB "U"
	DCB	0x0, "f", 0x0, "n", 0x0, "P", 0x0, "d", 0x0, "d", 0x0, "_"
	DCB	0x0, "I", 0x0, "s", 0x0, "s", 0x0, "u", 0x0, "e", 0x0, "T"
	DCB	0x0, "r", 0x0, "a", 0x0, "n", 0x0, "s", 0x0, "f", 0x0, "e"
	DCB	0x0, "r", 0x0, ":", 0x0, " ", 0x0, "E", 0x0, "P", 0x0, "%"
	DCB	0x0, "u", 0x0, " ", 0x0, "E", 0x0, "r", 0x0, "r", 0x0, "o"
	DCB	0x0, "r", 0x0, ",", 0x0, " ", 0x0, "E", 0x0, "n", 0x0, "d"
	DCB	0x0, "p", 0x0, "o", 0x0, "i", 0x0, "n", 0x0, "t", 0x0, " "
	DCB	0x0, "n", 0x0, "o", 0x0, "t", 0x0, " ", 0x0, "i", 0x0, "n"
	DCB	0x0, "i", 0x0, "t", 0x0, "i", 0x0, "a", 0x0, "l", 0x0, "i"
	DCB	0x0, "s", 0x0, "e", 0x0, "d", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\am3517\usb\usbfn\usbfnpdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_IssueTransfer| PROC

; 2275 : {

  00000		 |$LN27@UfnPdd_Iss|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M48947|
  00004	e1a06002	 mov         r6, r2
  00008	e1a05001	 mov         r5, r1
  0000c	e1a04000	 mov         r4, r0

; 2276 :     DWORD rc = ERROR_SUCCESS;
; 2277 : 
; 2278 :     USBFNPDDCONTEXT *pPdd       = (USBFNPDDCONTEXT *)pvPddContext;
; 2279 : 
; 2280 :     if (endpoint == 0)
; 2281 :     {
; 2282 :         PRINTMSG(ZONE_PDD_EP0, (L"UfnPdd_IssueTransfer: EP 0, %s, len %d\r\n",
; 2283 :                                 TRANSFER_IS_IN(pTransfer) ? L"TX" : L"RX", pTransfer->cbBuffer));
; 2284 :     }
; 2285 :     else if (TRANSFER_IS_IN(pTransfer))
; 2286 :     {
; 2287 :         PRINTMSG(ZONE_PDD_TX, (L"UfnPdd_IssueTransfer: EP %d, TX, len %d\r\n",
; 2288 :                                endpoint, pTransfer->cbBuffer));
; 2289 :     }
; 2290 :     else
; 2291 :     {
; 2292 :         PRINTMSG(ZONE_PDD_RX, (L"UfnPdd_IssueTransfer: EP %d, RX, len %d\r\n",
; 2293 :                                endpoint, pTransfer->cbBuffer));
; 2294 :     }
; 2295 : 
; 2296 :     /* Check that EP is initialised */
; 2297 :     if (!pPdd->ep[endpoint].epInitialised)

  00010	e0653205	 rsb         r3, r5, r5, lsl #4
  00014	e0847103	 add         r7, r4, r3, lsl #2
  00018	e5973288	 ldr         r3, [r7, #0x288]
  0001c	e3a08000	 mov         r8, #0
  00020	e3530000	 cmp         r3, #0
  00024	1a000009	 bne         |$LN11@UfnPdd_Iss|

; 2298 :     {
; 2299 :         ERRORMSG(TRUE, (L"UfnPdd_IssueTransfer: EP%u Error, Endpoint not initialised\r\n",
; 2300 :                         endpoint));

  00028	e59f10f8	 ldr         r1, [pc, #0xF8]
  0002c	e59f00f0	 ldr         r0, [pc, #0xF0]
  00030	e3a03b02	 mov         r3, #2, 22
  00034	e38320fc	 orr         r2, r3, #0xFC
  00038	eb000000	 bl          NKDbgPrintfW
  0003c	e59f00dc	 ldr         r0, [pc, #0xDC]
  00040	e1a01005	 mov         r1, r5
  00044	eb000000	 bl          NKDbgPrintfW

; 2301 :         rc = ERROR_INVALID_PARAMETER;

  00048	e3a08057	 mov         r8, #0x57

; 2302 :         goto Exit;

  0004c	ea000030	 b           |$Exit$47664|
  00050		 |$LN11@UfnPdd_Iss|

; 2303 :     }
; 2304 : 
; 2305 :     LOCK_ENDPOINT (pPdd);

  00050	e2840e27	 add         r0, r4, #0x27, 28
  00054	eb000000	 bl          EnterCriticalSection

; 2306 : 
; 2307 :     /* Save transfer for interrupt thread */
; 2308 :     DEBUGCHK(pPdd->ep[endpoint].pTransfer == NULL);
; 2309 :     pPdd->ep[endpoint].pTransfer = pTransfer;

  00058	e58762a4	 str         r6, [r7, #0x2A4]

; 2310 : 
; 2311 :     /* If transfer buffer is NULL length must be zero */
; 2312 :     if (pTransfer->pvBuffer == NULL)

  0005c	e5963004	 ldr         r3, [r6, #4]
  00060	e3a09000	 mov         r9, #0

; 2313 :     {
; 2314 :         pTransfer->cbBuffer = 0 ;
; 2315 :     }
; 2316 : 
; 2317 :     DEBUGCHK(pTransfer->dwUsbError == UFN_NOT_COMPLETE_ERROR);
; 2318 : 
; 2319 :     UNLOCK_ENDPOINT (pPdd);

  00064	e2840e27	 add         r0, r4, #0x27, 28
  00068	e3530000	 cmp         r3, #0
  0006c	0586900c	 streq       r9, [r6, #0xC]
  00070	eb000000	 bl          LeaveCriticalSection

; 2320 : 
; 2321 :     /* Depending on direction */
; 2322 :     if (TRANSFER_IS_IN(pTransfer))

  00074	e5963000	 ldr         r3, [r6]
  00078	e3130080	 tst         r3, #0x80
  0007c	0a00000d	 beq         |$LN9@UfnPdd_Iss|

; 2323 :     {
; 2324 :         pPdd->ep[endpoint].zeroLength = (pTransfer->cbBuffer == 0);

  00080	e596300c	 ldr         r3, [r6, #0xC]

; 2325 : 
; 2326 :         if (endpoint == 0)
; 2327 :         {
; 2328 :             ContinueEp0TxTransfer(pPdd, endpoint);

  00084	e1a00004	 mov         r0, r4
  00088	e3530000	 cmp         r3, #0
  0008c	03a03001	 moveq       r3, #1
  00090	13a03000	 movne       r3, #0
  00094	e5873298	 str         r3, [r7, #0x298]
  00098	e3550000	 cmp         r5, #0
  0009c	1a000002	 bne         |$LN8@UfnPdd_Iss|
  000a0	e3a01000	 mov         r1, #0
  000a4	eb000000	 bl          ContinueEp0TxTransfer

; 2329 :         }
; 2330 :         else

  000a8	ea000014	 b           |$LN20@UfnPdd_Iss|
  000ac		 |$LN8@UfnPdd_Iss|

; 2331 :         {
; 2332 : #ifdef CPPI_DMA_SUPPORT
; 2333 :             ContinueTxDmaTransfer(pPdd, endpoint);

  000ac	e1a01005	 mov         r1, r5
  000b0	eb000000	 bl          ContinueTxDmaTransfer

; 2334 : #else
; 2335 :             ContinueTxTransfer(pPdd, endpoint);
; 2336 : #endif
; 2337 :         }
; 2338 :     }
; 2339 :     else

  000b4	ea000011	 b           |$LN20@UfnPdd_Iss|
  000b8		 |$LN9@UfnPdd_Iss|

; 2340 :     {
; 2341 :         pPdd->ep[endpoint].zeroLength = FALSE;
; 2342 :         pPdd->ep[endpoint].epStage = MGC_END0_STAGE_RX;

  000b8	e3a03003	 mov         r3, #3
  000bc	e58732a0	 str         r3, [r7, #0x2A0]
  000c0	e5879298	 str         r9, [r7, #0x298]

; 2343 : 
; 2344 :         if (endpoint == 0)

  000c4	e3550000	 cmp         r5, #0
  000c8	0a00000c	 beq         |$LN20@UfnPdd_Iss|

; 2345 :         {
; 2346 :             // MDD does not support synchronous completion callbacks so always 
; 2347 :             // wait for RX interrupt before processing an EP0 RX transfer.
; 2348 :             //ContinueEp0RxTransfer (pPdd, endpoint);
; 2349 :         }
; 2350 :         else
; 2351 :         {
; 2352 : #ifdef CPPI_DMA_SUPPORT
; 2353 :             /* Do not use DMA for zero length packets */
; 2354 :             if (pTransfer->cbBuffer != 0)

  000cc	e596300c	 ldr         r3, [r6, #0xC]
  000d0	e3530000	 cmp         r3, #0
  000d4	0a000003	 beq         |$LN3@UfnPdd_Iss|

; 2355 :             { 
; 2356 :                 StartRxDmaTransfer(pPdd, endpoint);

  000d8	e1a01005	 mov         r1, r5
  000dc	e1a00004	 mov         r0, r4
  000e0	eb000000	 bl          StartRxDmaTransfer

; 2357 :             }
; 2358 :             else

  000e4	ea000005	 b           |$LN20@UfnPdd_Iss|
  000e8		 |$LN3@UfnPdd_Iss|

; 2359 : #endif
; 2360 :             {
; 2361 :                 StartRxTransfer (pPdd, endpoint);

  000e8	e3a03001	 mov         r3, #1
  000ec	e594201c	 ldr         r2, [r4, #0x1C]
  000f0	e1a03513	 mov         r3, r3, lsl r5
  000f4	e58792ac	 str         r9, [r7, #0x2AC]
  000f8	e1a03803	 mov         r3, r3, lsl #16
  000fc	e5823030	 str         r3, [r2, #0x30]
  00100		 |$LN20@UfnPdd_Iss|

; 2362 :             }
; 2363 :         }
; 2364 :     }
; 2365 : 
; 2366 :     // Signal activity
; 2367 :     if (pPdd->hActivityEvent)

  00100	e5943254	 ldr         r3, [r4, #0x254]
  00104	e3530000	 cmp         r3, #0

; 2368 :         SetEvent(pPdd->hActivityEvent);

  00108	13a01003	 movne       r1, #3
  0010c	11a00003	 movne       r0, r3
  00110	1b000000	 blne        EventModify
  00114		 |$Exit$47664|

; 2369 : 
; 2370 : Exit:
; 2371 :     return (rc);
; 2372 : }

  00114	e1a00008	 mov         r0, r8
  00118	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  0011c	e12fff1e	 bx          lr
  00120		 |$LN28@UfnPdd_Iss|
  00120		 |$LN29@UfnPdd_Iss|
  00120	00000000	 DCD         |??_C@_1HK@LMIAFHNK@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAs?$AAs?$AAu?$AAe?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?$CF?$AAu?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr@|
  00124		 |$LN30@UfnPdd_Iss|
  00124	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  00128		 |$LN31@UfnPdd_Iss|
  00128	00000000	 DCD         |??_C@_1JO@JAGHJEHH@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  0012c		 |$M48948|

			 ENDP  ; |UfnPdd_IssueTransfer|

	EXPORT	|UfnPdd_AbortTransfer|

  00000			 AREA	 |.pdata|, PDATA
|$T48969| DCD	|$LN6@UfnPdd_Abo|
	DCD	0x40002c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_AbortTransfer| PROC

; 2396 : {

  00000		 |$LN6@UfnPdd_Abo|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M48966|
  00004	e1a08002	 mov         r8, r2
  00008	e1a05001	 mov         r5, r1
  0000c	e1a06000	 mov         r6, r0

; 2397 :     DWORD rc = ERROR_SUCCESS;
; 2398 :     USBFNPDDCONTEXT *pPdd      = (USBFNPDDCONTEXT *)pvPddContext;
; 2399 :     CSL_UsbRegs     *pUsbdRegs = pPdd->pUsbdRegs;
; 2400 :     UINT16 epCtrlReg;
; 2401 : 
; 2402 : #ifdef CPPI_DMA_SUPPORT
; 2403 :     struct dma_controller * pDmaCntrl =
; 2404 :                 (struct dma_controller *)pPdd->pDmaCntrl;
; 2405 : #endif /* #ifdef CPPI_DMA_SUPPORT */
; 2406 : 
; 2407 :     DEBUGCHK (endpoint < USBD_EP_COUNT);
; 2408 :     PRINTMSG(ZONE_PDD_TX|ZONE_PDD_RX|ZONE_PDD_EP0,
; 2409 :             (L"UfnPdd_AbortTransfer: EP %u\r\n", endpoint));
; 2410 : 
; 2411 :     /* Abort the Transfer by Setting the DataEnd Bit */
; 2412 :     LOCK_ENDPOINT (pPdd);

  00010	e596401c	 ldr         r4, [r6, #0x1C]
  00014	e596765c	 ldr         r7, [r6, #0x65C]
  00018	e2860e27	 add         r0, r6, #0x27, 28
  0001c	eb000000	 bl          EnterCriticalSection

; 2413 :     epCtrlReg = pUsbdRegs->EPCSR[ endpoint ].PERI_TXCSR;

  00020	e0843205	 add         r3, r4, r5, lsl #4
  00024	e283ec05	 add         lr, r3, #5, 24
  00028	e1de30b2	 ldrh        r3, [lr, #2]

; 2414 :     epCtrlReg |= MGC_M_CSR0_P_DATAEND;
; 2415 :     pUsbdRegs->EPCSR[ endpoint ].PERI_TXCSR = epCtrlReg;
; 2416 :     UNLOCK_ENDPOINT (pPdd);

  0002c	e2860e27	 add         r0, r6, #0x27, 28
  00030	e3833008	 orr         r3, r3, #8
  00034	e1ce30b2	 strh        r3, [lr, #2]
  00038	eb000000	 bl          LeaveCriticalSection

; 2417 : 
; 2418 : #ifdef CPPI_DMA_SUPPORT
; 2419 :     if (endpoint != 0)

  0003c	e3550000	 cmp         r5, #0

; 2420 :         pDmaCntrl->pfnChannelAbort (pPdd->ep[endpoint].pDmaChan);

  00040	10653205	 rsbne       r3, r5, r5, lsl #4
  00044	10863103	 addne       r3, r6, r3, lsl #2
  00048	159302b0	 ldrne       r0, [r3, #0x2B0]
  0004c	15973014	 ldrne       r3, [r7, #0x14]
  00050	11a0e00f	 movne       lr, pc
  00054	112fff13	 bxne        r3

; 2421 : #endif /* #ifdef CPPI_DMA_SUPPORT */
; 2422 : 
; 2423 :     /* Finish transfer */
; 2424 :     LOCK_ENDPOINT (pPdd);

  00058	e2860e27	 add         r0, r6, #0x27, 28
  0005c	eb000000	 bl          EnterCriticalSection

; 2425 :     pPdd->ep[endpoint].pTransfer = NULL;

  00060	e0653205	 rsb         r3, r5, r5, lsl #4
  00064	e0862103	 add         r2, r6, r3, lsl #2
  00068	e3a03000	 mov         r3, #0
  0006c	e3a01c01	 mov         r1, #1, 24
  00070	e58232a4	 str         r3, [r2, #0x2A4]

; 2426 :     pTransfer->dwUsbError = UFN_CANCELED_ERROR;

  00074	e3813001	 orr         r3, r1, #1
  00078	e5883014	 str         r3, [r8, #0x14]

; 2427 :     pPdd->ep[endpoint].epStage = MGC_END0_START;

  0007c	e3a03001	 mov         r3, #1

; 2428 :     UNLOCK_ENDPOINT (pPdd);

  00080	e2860e27	 add         r0, r6, #0x27, 28
  00084	e58232a0	 str         r3, [r2, #0x2A0]
  00088	eb000000	 bl          LeaveCriticalSection

; 2429 : 
; 2430 :     /* Inform MDD that the Current Transfer is Completed */
; 2431 :     PRINTMSG(ZONE_PDD_TX|ZONE_PDD_RX|ZONE_PDD_EP0,
; 2432 :              (L"AbortTransfer: EP %x - indicating complete to MDD\r\n", endpoint));
; 2433 :     pPdd->pfnNotify (pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE,
; 2434 :                         (DWORD)pTransfer);

  0008c	e5960010	 ldr         r0, [r6, #0x10]
  00090	e5963014	 ldr         r3, [r6, #0x14]
  00094	e1a02008	 mov         r2, r8
  00098	e3a01064	 mov         r1, #0x64
  0009c	e1a0e00f	 mov         lr, pc
  000a0	e12fff13	 bx          r3

; 2435 : 
; 2436 :     return (rc);

  000a4	e3a00000	 mov         r0, #0

; 2437 : }

  000a8	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000ac	e12fff1e	 bx          lr
  000b0		 |$M48967|

			 ENDP  ; |UfnPdd_AbortTransfer|

	EXPORT	|UfnPdd_StallEndpoint|

  00000			 AREA	 |.pdata|, PDATA
|$T48985| DCD	|$LN10@UfnPdd_Sta|
	DCD	0x40002201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_StallEndpoint| PROC

; 2457 : {

  00000		 |$LN10@UfnPdd_Sta|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M48982|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 2458 :     DWORD rc = ERROR_SUCCESS;
; 2459 : 
; 2460 :     USBFNPDDCONTEXT *pPdd      = (USBFNPDDCONTEXT *)pvPddContext;
; 2461 :     CSL_UsbRegs     *pUsbdRegs = pPdd->pUsbdRegs;
; 2462 :     volatile UINT16 *pepCtrlReg;
; 2463 :     UINT16  epCtrlVal;
; 2464 :     UINT16  epStallBit;
; 2465 : 
; 2466 :     DEBUGCHK (endpoint < USBD_EP_COUNT);
; 2467 : 
; 2468 :     PRINTMSG(ZONE_PDD_TX|ZONE_PDD_RX|ZONE_PDD_EP0,
; 2469 :         (L"UfnPdd_StallEndpoint: EP %d\r\n", endpoint));
; 2470 : 
; 2471 :     /* Critical Section Support */
; 2472 :     LOCK_ENDPOINT (pPdd);

  0000c	e595601c	 ldr         r6, [r5, #0x1C]
  00010	e2850e27	 add         r0, r5, #0x27, 28
  00014	eb000000	 bl          EnterCriticalSection

; 2473 : 
; 2474 :     /* First check which Register is to be Read */
; 2475 :     if (endpoint == 0)

  00018	e3a07001	 mov         r7, #1
  0001c	e3540000	 cmp         r4, #0

; 2476 :     {
; 2477 :         pepCtrlReg = &pUsbdRegs->EPCSR[ endpoint ].PERI_TXCSR;

  00020	02863c05	 addeq       r3, r6, #5, 24

; 2478 :         epStallBit = MGC_M_CSR0_P_SENDSTALL;

  00024	03a0e020	 moveq       lr, #0x20

; 2479 :         pPdd->ep[0].epStage = MGC_END0_START;

  00028	058572a0	 streq       r7, [r5, #0x2A0]
  0002c	0a000009	 beq         |$LN7@UfnPdd_Sta|

; 2480 :     }
; 2481 :     else
; 2482 :     {
; 2483 :         if (pPdd->ep[endpoint].dirRx == TRUE)

  00030	e0643204	 rsb         r3, r4, r4, lsl #4
  00034	e0853103	 add         r3, r5, r3, lsl #2
  00038	e5933294	 ldr         r3, [r3, #0x294]
  0003c	e3530001	 cmp         r3, #1

; 2484 :         {
; 2485 :             pepCtrlReg = &pUsbdRegs->EPCSR[ endpoint ].PERI_RXCSR;

  00040	e0863204	 add         r3, r6, r4, lsl #4
  00044	e2833c05	 add         r3, r3, #5, 24
  00048	02830006	 addeq       r0, r3, #6

; 2486 :             epStallBit = MGC_M_RXCSR_P_SENDSTALL;

  0004c	03a0e020	 moveq       lr, #0x20
  00050	0a000001	 beq         |$LN1@UfnPdd_Sta|

; 2491 :             epStallBit = MGC_M_TXCSR_P_SENDSTALL;

  00054	e3a0e010	 mov         lr, #0x10
  00058		 |$LN7@UfnPdd_Sta|

; 2487 :         }
; 2488 :         else
; 2489 :         {
; 2490 :             pepCtrlReg = &pUsbdRegs->EPCSR[ endpoint ].PERI_TXCSR;

  00058	e2830002	 add         r0, r3, #2

; 2491 :             epStallBit = MGC_M_TXCSR_P_SENDSTALL;

  0005c		 |$LN1@UfnPdd_Sta|

; 2492 :         }
; 2493 :     }
; 2494 : 
; 2495 :     epCtrlVal = (*pepCtrlReg);

  0005c	e1d020b0	 ldrh        r2, [r0]

; 2496 : 
; 2497 :     /* Stall the EndPoint by Setting the SENDSTALL Bit */
; 2498 :     epCtrlVal |= epStallBit;
; 2499 : 
; 2500 :     /* Write back */
; 2501 :     (*pepCtrlReg) = epCtrlVal;
; 2502 : 
; 2503 :     pPdd->ep[endpoint].stalled = TRUE;

  00060	e0643204	 rsb         r3, r4, r4, lsl #4
  00064	e0851103	 add         r1, r5, r3, lsl #2
  00068	e182300e	 orr         r3, r2, lr
  0006c	e1c030b0	 strh        r3, [r0]

; 2504 : 
; 2505 :     UNLOCK_ENDPOINT (pPdd);

  00070	e2850e27	 add         r0, r5, #0x27, 28
  00074	e581729c	 str         r7, [r1, #0x29C]
  00078	eb000000	 bl          LeaveCriticalSection

; 2506 : 
; 2507 :     return (rc);

  0007c	e3a00000	 mov         r0, #0

; 2508 : }

  00080	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00084	e12fff1e	 bx          lr
  00088		 |$M48983|

			 ENDP  ; |UfnPdd_StallEndpoint|

	EXPORT	|UfnPdd_ClearEndpointStall|

  00000			 AREA	 |.pdata|, PDATA
|$T49002| DCD	|$LN9@UfnPdd_Cle|
	DCD	0x40002a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_ClearEndpointStall| PROC

; 2528 : {

  00000		 |$LN9@UfnPdd_Cle|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M48999|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 2529 :     DWORD rc = ERROR_SUCCESS;
; 2530 :     USBFNPDDCONTEXT *pPdd      = (USBFNPDDCONTEXT *)pvPddContext;
; 2531 :     CSL_UsbRegs     *pUsbdRegs = pPdd->pUsbdRegs;
; 2532 : 
; 2533 :     volatile UINT16 *pepReg;
; 2534 :     UINT16  epCtrlVal;
; 2535 : 
; 2536 :     DEBUGCHK (endpoint < USBD_EP_COUNT);
; 2537 : 
; 2538 :     PRINTMSG(ZONE_PDD_TX|ZONE_PDD_RX|ZONE_PDD_EP0,
; 2539 :         (L"UfnPdd_ClearEndpointStall: EP %u\r\n", endpoint));
; 2540 : 
; 2541 :     /* Critical Section Support */
; 2542 :     LOCK_ENDPOINT (pPdd);

  0000c	e595601c	 ldr         r6, [r5, #0x1C]
  00010	e2850e27	 add         r0, r5, #0x27, 28
  00014	eb000000	 bl          EnterCriticalSection

; 2543 : 
; 2544 :     /* First check which Register is to be Read */
; 2545 :     if (endpoint == 0)

  00018	e3540000	 cmp         r4, #0

; 2546 :     {
; 2547 :         pepReg = &pUsbdRegs->EPCSR[ endpoint ].PERI_TXCSR;

  0001c	02863c05	 addeq       r3, r6, #5, 24
  00020	02831002	 addeq       r1, r3, #2

; 2548 :         epCtrlVal = (*pepReg);

  00024	01d120b0	 ldreqh      r2, [r1]
  00028	03a03cff	 moveq       r3, #0xFF, 24

; 2549 :         epCtrlVal &= ~(MGC_M_CSR0_P_SENDSTALL | MGC_M_CSR0_P_SENTSTALL);

  0002c	038330db	 orreq       r3, r3, #0xDB
  00030	00022003	 andeq       r2, r2, r3
  00034	0a000011	 beq         |$LN1@UfnPdd_Cle|

; 2550 :     }
; 2551 :     else
; 2552 :     {
; 2553 :         /* USB Class Drivers likes to use this EndPoint
; 2554 :          * as Receive EndPoint. For Receive EndPoints, configure
; 2555 :          * the RXCSR Register of the USB Controller, bits
; 2556 :          * */
; 2557 :         if (pPdd->ep[endpoint].dirRx == TRUE)

  00038	e0643204	 rsb         r3, r4, r4, lsl #4
  0003c	e0853103	 add         r3, r5, r3, lsl #2
  00040	e5933294	 ldr         r3, [r3, #0x294]
  00044	e3530001	 cmp         r3, #1

; 2558 :         {
; 2559 :             pepReg = &pUsbdRegs->EPCSR[ endpoint ].PERI_RXCSR;

  00048	e0863204	 add         r3, r6, r4, lsl #4
  0004c	e2833c05	 add         r3, r3, #5, 24
  00050	02831006	 addeq       r1, r3, #6

; 2560 :             epCtrlVal = (*pepReg);

  00054	01d120b0	 ldreqh      r2, [r1]
  00058	03a03cff	 moveq       r3, #0xFF, 24

; 2561 :             epCtrlVal &= ~(MGC_M_RXCSR_P_SENDSTALL | MGC_M_RXCSR_P_SENTSTALL);
; 2562 :             epCtrlVal &= ~MGC_M_RXCSR_P_WZC_BITS;

  0005c	0383301a	 orreq       r3, r3, #0x1A
  00060	00023003	 andeq       r3, r2, r3

; 2563 :             epCtrlVal |= MGC_M_RXCSR_CLRDATATOG;
; 2564 :         }
; 2565 :         else
; 2566 :         {
; 2567 :             pepReg = &pUsbdRegs->EPCSR[ endpoint ].PERI_TXCSR;

  00064	12831002	 addne       r1, r3, #2
  00068	03832080	 orreq       r2, r3, #0x80

; 2568 :             epCtrlVal = (*pepReg);

  0006c	11d120b0	 ldrneh      r2, [r1]
  00070	13a03cff	 movne       r3, #0xFF, 24

; 2569 :             epCtrlVal &= ~(MGC_M_TXCSR_P_SENDSTALL | MGC_M_TXCSR_P_SENTSTALL);
; 2570 :             epCtrlVal &= ~MGC_M_TXCSR_P_WZC_BITS;

  00074	13833009	 orrne       r3, r3, #9
  00078	10023003	 andne       r3, r2, r3

; 2571 :             epCtrlVal |= MGC_M_TXCSR_CLRDATATOG;

  0007c	13832040	 orrne       r2, r3, #0x40
  00080		 |$LN1@UfnPdd_Cle|

; 2572 :         }
; 2573 :     }
; 2574 : 
; 2575 :     /* Clear SENDSTALL and SENTSTALL to bring the EP out of Stall Condition */
; 2576 :     (*pepReg) = epCtrlVal;
; 2577 : 
; 2578 :     pPdd->ep[endpoint].stalled = FALSE;

  00080	e0643204	 rsb         r3, r4, r4, lsl #4
  00084	e0853103	 add         r3, r5, r3, lsl #2
  00088	e3a00000	 mov         r0, #0
  0008c	e1c120b0	 strh        r2, [r1]
  00090	e583029c	 str         r0, [r3, #0x29C]

; 2579 : 
; 2580 :     /* leave CriticalSection */
; 2581 :     UNLOCK_ENDPOINT (pPdd);

  00094	e2850e27	 add         r0, r5, #0x27, 28
  00098	eb000000	 bl          LeaveCriticalSection

; 2582 : 
; 2583 :     return (rc);

  0009c	e3a00000	 mov         r0, #0

; 2584 : }

  000a0	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000a4	e12fff1e	 bx          lr
  000a8		 |$M49000|

			 ENDP  ; |UfnPdd_ClearEndpointStall|

	EXPORT	|UfnPdd_IsEndpointHalted|

  00000			 AREA	 |.pdata|, PDATA
|$T49014| DCD	|$LN5@UfnPdd_IsE|
	DCD	0x40000f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_IsEndpointHalted| PROC

; 2606 : {

  00000		 |$LN5@UfnPdd_IsE|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M49011|
  00004	e1a06002	 mov         r6, r2
  00008	e1a04001	 mov         r4, r1
  0000c	e1a05000	 mov         r5, r0

; 2607 :     DWORD rc = ERROR_SUCCESS;
; 2608 :     USBFNPDDCONTEXT *pPdd = (USBFNPDDCONTEXT *)pvPddContext;
; 2609 : 
; 2610 :     PRINTMSG(ZONE_PDD_TX|ZONE_PDD_RX|ZONE_PDD_EP0,
; 2611 :              (L"UfnPdd_IsEndpointHalted: EP %u\r\n", endpoint));
; 2612 : 
; 2613 :     DEBUGCHK (endpoint < USBD_EP_COUNT);
; 2614 :     DEBUGCHK (pHalted != NULL);
; 2615 : 
; 2616 :     LOCK_ENDPOINT (pPdd);

  00010	e2850e27	 add         r0, r5, #0x27, 28
  00014	eb000000	 bl          EnterCriticalSection

; 2617 : 
; 2618 :     /* There is no HALT Bit in the USB Controller EP Status Registers
; 2619 :      * in the SOC. However, the driver tries to maintain the
; 2620 :      * Stall status for each EndPoint that it operates upon. We
; 2621 :      * will use this status flag to detect whether the EndPoint
; 2622 :      * is currently Active or Halted.
; 2623 :      */
; 2624 :     *pHalted = pPdd->ep[endpoint].stalled ;

  00018	e0643204	 rsb         r3, r4, r4, lsl #4
  0001c	e0853103	 add         r3, r5, r3, lsl #2
  00020	e593329c	 ldr         r3, [r3, #0x29C]

; 2625 :     UNLOCK_ENDPOINT (pPdd);

  00024	e2850e27	 add         r0, r5, #0x27, 28
  00028	e5863000	 str         r3, [r6]
  0002c	eb000000	 bl          LeaveCriticalSection

; 2626 : 
; 2627 :     return (rc);

  00030	e3a00000	 mov         r0, #0

; 2628 : 
; 2629 : }

  00034	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$M49012|

			 ENDP  ; |UfnPdd_IsEndpointHalted|

	EXPORT	|UfnPdd_SendControlStatusHandshake|

  00000			 AREA	 |.pdata|, PDATA
|$T49030| DCD	|$LN16@UfnPdd_Sen|
	DCD	0x40003801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_SendControlStatusHandshake| PROC

; 2651 : {

  00000		 |$LN16@UfnPdd_Sen|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M49027|
  00004	e1a05000	 mov         r5, r0

; 2652 :     DWORD rc = ERROR_SUCCESS;
; 2653 : 
; 2654 :     USBFNPDDCONTEXT *pPdd       = (USBFNPDDCONTEXT *)pvPddContext;
; 2655 :     CSL_UsbRegs     *pUsbdRegs  = pPdd->pUsbdRegs;
; 2656 :     UsbFnEp         *pEP        = &pPdd->ep[endpoint];

  00008	e0613201	 rsb         r3, r1, r1, lsl #4

; 2657 :     UINT16  ep0CsrReg;
; 2658 :     volatile UINT16 *pepCtrlReg;
; 2659 : 
; 2660 :     /* Handshake control for EP0 RX transfers is implemented.  Class drivers
; 2661 :        can perform EP stall, deinit and init calls between receiving the 
; 2662 :        setup packet and calling this handshake fn so the EP0 setup RX transfer
; 2663 :        is not completed until this handshake is performed.  This prevents the 
; 2664 :        host from sending packets on the other endpoints.
; 2665 :        The EP0 RX handshake is performed by delaying setting of the SVDRXPKTRDY 
; 2666 :        and DATAEND bits in the CSR.  This delays the STATUS IN part of the the 
; 2667 :        transfer and causes the controller to NAK the host until we are ready.
; 2668 :        Note: Delaying setting of just DATAEND causes a SETUPEND error.
; 2669 :      */
; 2670 : 
; 2671 :     PRINTMSG(ZONE_PDD_EP0,
; 2672 :              (L"UfnPdd_SendControlStatusHandshake: EP %d\r\n", endpoint));
; 2673 : 
; 2674 :     LOCK_ENDPOINT (pPdd);

  0000c	e595601c	 ldr         r6, [r5, #0x1C]
  00010	e2850e27	 add         r0, r5, #0x27, 28
  00014	e0854103	 add         r4, r5, r3, lsl #2
  00018	eb000000	 bl          EnterCriticalSection

; 2675 : 
; 2676 :     /* May have just received a new setup so check EP 0 stage */
; 2677 :     if (pEP->epStage == MGC_END0_START)

  0001c	e59432a0	 ldr         r3, [r4, #0x2A0]
  00020	e3530001	 cmp         r3, #1
  00024	1a00001b	 bne         |$LN10@UfnPdd_Sen|

; 2678 :     {
; 2679 :         /* Deliver a queued setup packet */
; 2680 :         if (pPdd->fHasQueuedSetupRequest)

  00028	e5953650	 ldr         r3, [r5, #0x650]
  0002c	e3530000	 cmp         r3, #0
  00030	0a000023	 beq         |$LN9@UfnPdd_Sen|

; 2681 :         {
; 2682 :             pPdd->fHasQueuedSetupRequest = FALSE;
; 2683 : 
; 2684 :             if (pPdd->queuedSetupRequest.wLength == 0)

  00034	e5d5265a	 ldrb        r2, [r5, #0x65A]
  00038	e5d5365b	 ldrb        r3, [r5, #0x65B]
  0003c	e3a01000	 mov         r1, #0
  00040	e5851650	 str         r1, [r5, #0x650]
  00044	e1923403	 orrs        r3, r2, r3, lsl #8

; 2745 : }

  00048	0a000004	 beq         |$LN5@UfnPdd_Sen|
  0004c	e5d53654	 ldrb        r3, [r5, #0x654]
  00050	e3130080	 tst         r3, #0x80
  00054	13a03002	 movne       r3, #2
  00058	03a03003	 moveq       r3, #3
  0005c	e58432a0	 str         r3, [r4, #0x2A0]
  00060		 |$LN5@UfnPdd_Sen|
  00060	e3a03001	 mov         r3, #1
  00064	e2850e27	 add         r0, r5, #0x27, 28
  00068	e585364c	 str         r3, [r5, #0x64C]
  0006c	eb000000	 bl          LeaveCriticalSection
  00070	e2853c06	 add         r3, r5, #6, 24
  00074	e5950010	 ldr         r0, [r5, #0x10]
  00078	e5954014	 ldr         r4, [r5, #0x14]
  0007c	e2832054	 add         r2, r3, #0x54
  00080	e3a01004	 mov         r1, #4
  00084	e1a0e00f	 mov         lr, pc
  00088	e12fff14	 bx          r4
  0008c	e1a00005	 mov         r0, r5
  00090	eb000000	 bl          UsbPddEp0IntrHandler
  00094	ea00000e	 b           |$LN1@UfnPdd_Sen|
  00098		 |$LN10@UfnPdd_Sen|

; 2685 :             {
; 2686 :                 /* Already done DATAEND when setup received */
; 2687 :             }
; 2688 :             else if ((pPdd->queuedSetupRequest.bmRequestType & USB_ENDPOINT_DIRECTION_MASK) != 0)
; 2689 :             {
; 2690 :                 pEP->epStage = MGC_END0_STAGE_TX;
; 2691 :             }
; 2692 :             else
; 2693 :             {
; 2694 :                 pEP->epStage = MGC_END0_STAGE_RX;
; 2695 :             }
; 2696 : 
; 2697 :             /* Will need another handshake call */
; 2698 :             pPdd->fWaitingForHandshake = TRUE;
; 2699 : 
; 2700 :             UNLOCK_ENDPOINT (pPdd);
; 2701 : 
; 2702 :             PRINTMSG(ZONE_PDD_EP0,
; 2703 :                      (L"UfnPdd_SendControlStatusHandshake: Setup pkt, len %d - sent to MDD\r\n",
; 2704 :                       pPdd->queuedSetupRequest.wLength));
; 2705 : 
; 2706 :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_SETUP_PACKET, (DWORD)&pPdd->queuedSetupRequest);
; 2707 : 
; 2708 :             // Call Ep0 interrupt handler to check if datas were received in fifo but was not handled 
; 2709 :             // beceause interrupt was skipped due to an already queuing setup packet.
; 2710 :             UsbPddEp0IntrHandler(pPdd);
; 2711 :         }
; 2712 :         else
; 2713 :         {
; 2714 :             /* No longer waiting */
; 2715 :             pPdd->fWaitingForHandshake = FALSE;
; 2716 : 
; 2717 :             UNLOCK_ENDPOINT (pPdd);
; 2718 :         }
; 2719 :     }
; 2720 :     else if (pEP->epStage == MGC_END0_STAGE_STATUSIN)

  00098	e3530004	 cmp         r3, #4
  0009c	1a00000a	 bne         |$LN2@UfnPdd_Sen|

; 2721 :     {
; 2722 :         /* Complete the RX transfer */
; 2723 :         pepCtrlReg = &pUsbdRegs->EPCSR[0].PERI_TXCSR;

  000a0	e2861c05	 add         r1, r6, #5, 24

; 2724 :         ep0CsrReg = (*pepCtrlReg);

  000a4	e1d120b2	 ldrh        r2, [r1, #2]
  000a8	e3a03cff	 mov         r3, #0xFF, 24

; 2725 :         ep0CsrReg |= MGC_M_CSR0_P_DATAEND;
; 2726 :         ep0CsrReg &= ~MGC_M_RXCSR_RXPKTRDY;
; 2727 :         ep0CsrReg |= MGC_M_CSR0_P_SVDRXPKTRDY;
; 2728 :         (*pepCtrlReg) = ep0CsrReg;

  000ac	e38330b6	 orr         r3, r3, #0xB6
  000b0	e0023003	 and         r3, r2, r3
  000b4	e3833048	 orr         r3, r3, #0x48
  000b8	e1c130b2	 strh        r3, [r1, #2]

; 2729 : 
; 2730 :         pEP->epStage = MGC_END0_START;

  000bc	e3a03001	 mov         r3, #1
  000c0	e58432a0	 str         r3, [r4, #0x2A0]
  000c4		 |$LN9@UfnPdd_Sen|

; 2731 : 
; 2732 :         /* No longer waiting */
; 2733 :         pPdd->fWaitingForHandshake = FALSE;

  000c4	e3a03000	 mov         r3, #0
  000c8	e585364c	 str         r3, [r5, #0x64C]
  000cc		 |$LN2@UfnPdd_Sen|

; 2734 : 
; 2735 :         UNLOCK_ENDPOINT (pPdd);
; 2736 :     }
; 2737 :     else
; 2738 :     {
; 2739 :         DEBUGCHK(pPdd->fHasQueuedSetupRequest == FALSE);
; 2740 : 
; 2741 :         UNLOCK_ENDPOINT (pPdd);

  000cc	e2850e27	 add         r0, r5, #0x27, 28
  000d0	eb000000	 bl          LeaveCriticalSection
  000d4		 |$LN1@UfnPdd_Sen|

; 2742 :     }
; 2743 : 
; 2744 :     return (rc);

  000d4	e3a00000	 mov         r0, #0

; 2745 : }

  000d8	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000dc	e12fff1e	 bx          lr
  000e0		 |$M49028|

			 ENDP  ; |UfnPdd_SendControlStatusHandshake|

	EXPORT	|UfnPdd_InitiateRemoteWakeup|

  00000			 AREA	 |.pdata|, PDATA
|$T49041| DCD	|$LN5@UfnPdd_Ini|
	DCD	0x40000e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_InitiateRemoteWakeup| PROC

; 2758 : {

  00000		 |$LN5@UfnPdd_Ini|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M49038|
  00004	e1a04000	 mov         r4, r0

; 2759 :     DWORD rc = ERROR_SUCCESS;
; 2760 :     USBFNPDDCONTEXT *pPdd       = (USBFNPDDCONTEXT *)pvPddContext;
; 2761 :     UINT8      powerRegVal;
; 2762 :     PRINTMSG(ZONE_FUNCTION, /*TRUE */
; 2763 :             (L"UfnPdd_InitiateRemoteWakeup:\r\n"));
; 2764 : 
; 2765 :     LOCK_ENDPOINT (pPdd);

  00008	e2840e27	 add         r0, r4, #0x27, 28
  0000c	eb000000	 bl          EnterCriticalSection

; 2766 : 
; 2767 :     /* Write into the Power Registers RESUME Bit to initiate
; 2768 :      * REMOTE WAKEUP from the Suspended State
; 2769 :      */
; 2770 : 
; 2771 :     powerRegVal = pPdd->pUsbdRegs->POWER;

  00010	e594301c	 ldr         r3, [r4, #0x1C]

; 2772 :     powerRegVal |= MGC_M_POWER_RESUME;
; 2773 :     pPdd->pUsbdRegs->POWER = powerRegVal;
; 2774 : 
; 2775 :     UNLOCK_ENDPOINT (pPdd);

  00014	e2840e27	 add         r0, r4, #0x27, 28
  00018	e2832b01	 add         r2, r3, #1, 22
  0001c	e5d23001	 ldrb        r3, [r2, #1]
  00020	e3833004	 orr         r3, r3, #4
  00024	e5c23001	 strb        r3, [r2, #1]
  00028	eb000000	 bl          LeaveCriticalSection

; 2776 : 
; 2777 :     return (rc);

  0002c	e3a00000	 mov         r0, #0

; 2778 : 
; 2779 : }

  00030	e8bd4010	 ldmia       sp!, {r4, lr}
  00034	e12fff1e	 bx          lr
  00038		 |$M49039|

			 ENDP  ; |UfnPdd_InitiateRemoteWakeup|

	EXPORT	|UfnPdd_IOControl|

  00000			 AREA	 |.pdata|, PDATA
|$T49058| DCD	|$LN25@UfnPdd_IOC|
	DCD	0x40003e02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_IOControl| PROC

; 2817 : {

  00000		 |$LN25@UfnPdd_IOC|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M49055|
  00008	e1a04003	 mov         r4, r3
  0000c	e1a05000	 mov         r5, r0
  00010	e3a03822	 mov         r3, #0x22, 16

; 2818 :     DWORD rc = ERROR_INVALID_PARAMETER;
; 2819 :     USBFNPDDCONTEXT *pPdd = (USBFNPDDCONTEXT *)pPddContext;
; 2820 : 
; 2821 :     CE_BUS_POWER_STATE *pBusPowerState;
; 2822 :     CEDEVICE_POWER_STATE devicePowerState;
; 2823 : 
; 2824 : 	UNREFERENCED_PARAMETER(pOutBuffer);
; 2825 : 	UNREFERENCED_PARAMETER(pOutSize);
; 2826 : 	UNREFERENCED_PARAMETER(outSize);
; 2827 : 
; 2828 :     PRINTMSG(ZONE_FUNCTION, (L"UfnPdd_IOControl:\r\n"));
; 2829 : 
; 2830 :     switch (code)

  00014	e383ef65	 orr         lr, r3, #0x65, 30
  00018	e152000e	 cmp         r2, lr
  0001c	e3a00057	 mov         r0, #0x57
  00020	0a00001e	 beq         |$LN15@UfnPdd_IOC|
  00024	e3a0382a	 mov         r3, #0x2A, 16
  00028	e383e00c	 orr         lr, r3, #0xC
  0002c	e152000e	 cmp         r2, lr
  00030	0a00000f	 beq         |$LN11@UfnPdd_IOC|
  00034	e3a0382a	 mov         r3, #0x2A, 16
  00038	e383e010	 orr         lr, r3, #0x10
  0003c	e152000e	 cmp         r2, lr
  00040	1a000029	 bne         |$LN12@UfnPdd_IOC|

; 2889 :         case IOCTL_BUS_SET_POWER_STATE:
; 2890 :             PRINTMSG(ZONE_PDD_INIT, (L"IOCTL_BUS_SET_POWER_STATE:\r\n"));
; 2891 :             if (source != MDD_IOCTL)

  00044	e3510002	 cmp         r1, #2
  00048	1a000027	 bne         |$LN12@UfnPdd_IOC|

; 2892 :                 break;
; 2893 :             if ((pInBuffer == NULL) ||
; 2894 :                 (inSize < sizeof(CE_BUS_POWER_STATE)))

  0004c	e3540000	 cmp         r4, #0
  00050	0a000025	 beq         |$LN12@UfnPdd_IOC|
  00054	e59d3018	 ldr         r3, [sp, #0x18]
  00058	e353000c	 cmp         r3, #0xC
  0005c	3a000022	 bcc         |$LN12@UfnPdd_IOC|

; 2895 :                 break;
; 2896 :             pBusPowerState = (CE_BUS_POWER_STATE*)pInBuffer;
; 2897 : 
; 2898 :             memcpy (&devicePowerState, pBusPowerState->lpceDevicePowerState,
; 2899 :                     sizeof(CEDEVICE_POWER_STATE));

  00060	e5943004	 ldr         r3, [r4, #4]

; 2900 : 
; 2901 :             PRINTMSG(ZONE_PDD_INIT, (L"IOCTL_BUS_SET_POWER_STATE:\r\n"));
; 2902 :             SetPowerState(pPdd , devicePowerState);

  00064	e1a00005	 mov         r0, r5
  00068	e5931000	 ldr         r1, [r3]
  0006c	eb000000	 bl          SetPowerState

; 2903 :             rc = ERROR_SUCCESS;
; 2904 :             break;

  00070	ea00001c	 b           |$LN22@UfnPdd_IOC|
  00074		 |$LN11@UfnPdd_IOC|

; 2872 :             break;
; 2873 :         }
; 2874 : #endif
; 2875 : 
; 2876 :         case IOCTL_BUS_GET_POWER_STATE:
; 2877 :             PRINTMSG(ZONE_PDD_INIT, (L"IOCTL_BUS_GET_POWER_STATE:\r\n"));
; 2878 :             if (source != MDD_IOCTL)

  00074	e3510002	 cmp         r1, #2
  00078	1a00001b	 bne         |$LN12@UfnPdd_IOC|

; 2879 :                 break;
; 2880 :             if ((pInBuffer == NULL) ||
; 2881 :                 (inSize < sizeof(CE_BUS_POWER_STATE)))

  0007c	e3540000	 cmp         r4, #0
  00080	0a000019	 beq         |$LN12@UfnPdd_IOC|
  00084	e59d3018	 ldr         r3, [sp, #0x18]
  00088	e353000c	 cmp         r3, #0xC
  0008c	3a000016	 bcc         |$LN12@UfnPdd_IOC|

; 2882 :                 break;
; 2883 :             pBusPowerState = (CE_BUS_POWER_STATE*)pInBuffer;
; 2884 : 
; 2885 :             memcpy (pBusPowerState->lpceDevicePowerState, &pPdd->currentPowerState,
; 2886 :                     sizeof(CEDEVICE_POWER_STATE));

  00090	e5942004	 ldr         r2, [r4, #4]
  00094	e5953048	 ldr         r3, [r5, #0x48]

; 2887 :             rc = ERROR_SUCCESS;

  00098	e5823000	 str         r3, [r2]

; 2888 :             break;

  0009c	ea000011	 b           |$LN22@UfnPdd_IOC|
  000a0		 |$LN15@UfnPdd_IOC|

; 2831 :     {
; 2832 : 
; 2833 :         case IOCTL_UFN_PDD_SET_CONFIGURATION:
; 2834 :             PRINTMSG(ZONE_PDD_INIT,
; 2835 :                      (L"IOCTL_UFN_PDD_SET_CONFIGURATION: value 0x%x\r\n", *((DWORD*)pInBuffer)));
; 2836 :             /* MDD will handle this request */
; 2837 : 
; 2838 :             /* When testing RNDIS with one particular PC a delay was needed here */
; 2839 : #ifdef UFN_SET_CONFIG_DELAY_REQUIRED
; 2840 :             Sleep(100);
; 2841 : #endif
; 2842 :             break;
; 2843 : 
; 2844 :         case IOCTL_UFN_PDD_SET_INTERFACE:
; 2845 :             PRINTMSG(ZONE_PDD_INIT,
; 2846 :                      (L"IOCTL_UFN_PDD_SET_INTERFACE: value 0x%x\r\n", *((DWORD*)pInBuffer)));
; 2847 :             /* MDD will handle this request */
; 2848 :             break;
; 2849 : 
; 2850 :             /* In a debug build we get a DEBUGCHK from VirtualCopy due
; 2851 :              * to the way the RNDIS client driver allocates its DMA
; 2852 :              * buffers.  Prevent the RNDIS client driver from allocating
; 2853 :              * DMA buffers by disabling this IOCTL.
; 2854 :              */
; 2855 : #ifndef DEBUG
; 2856 :         case IOCTL_UFN_GET_PDD_INFO:
; 2857 :         {
; 2858 :             UFN_PDD_INFO info;
; 2859 : 
; 2860 :             PRINTMSG(ZONE_PDD_INIT, (L"IOCTL_UFN_GET_PDD_INFO:\r\n"));
; 2861 :             if (source != BUS_IOCTL)

  000a0	e3510000	 cmp         r1, #0
  000a4	1a000010	 bne         |$LN12@UfnPdd_IOC|

; 2862 :                 break;
; 2863 :             if ((pOutBuffer == NULL) ||
; 2864 :                 (outSize < sizeof(UFN_PDD_INFO)))

  000a8	e59de01c	 ldr         lr, [sp, #0x1C]
  000ac	e35e0000	 cmp         lr, #0
  000b0	0a00000d	 beq         |$LN12@UfnPdd_IOC|
  000b4	e59d3020	 ldr         r3, [sp, #0x20]
  000b8	e353000c	 cmp         r3, #0xC
  000bc	3a00000a	 bcc         |$LN12@UfnPdd_IOC|

; 2865 :                 break;
; 2866 :             info.InterfaceType = Internal;
; 2867 :             info.BusNumber = 0;

  000c0	e3a02000	 mov         r2, #0

; 2868 :             info.dwAlignment = sizeof(DWORD);

  000c4	e3a01004	 mov         r1, #4
  000c8	e58d2004	 str         r2, [sp, #4]
  000cc	e58d1008	 str         r1, [sp, #8]
  000d0	e3a03000	 mov         r3, #0

; 2869 : 
; 2870 :             memcpy (pOutBuffer, &info, sizeof(UFN_PDD_INFO));

  000d4	e28d1000	 add         r1, sp, #0
  000d8	e3a0200c	 mov         r2, #0xC
  000dc	e1a0000e	 mov         r0, lr
  000e0	e58d3000	 str         r3, [sp]
  000e4	eb000000	 bl          memcpy
  000e8		 |$LN22@UfnPdd_IOC|

; 2871 :             rc = ERROR_SUCCESS;

  000e8	e3a00000	 mov         r0, #0
  000ec		 |$LN12@UfnPdd_IOC|

; 2905 :         case IOCTL_POWER_SET:
; 2906 :             PRINTMSG(ZONE_PDD_INIT, (L"IOCTL_POWER_SET\r\n"));
; 2907 :             break;
; 2908 :         case IOCTL_POWER_GET:
; 2909 :             PRINTMSG(ZONE_PDD_INIT, (L"IOCTL_POWER_GET\r\n"));
; 2910 :             break;
; 2911 :         default:
; 2912 :             PRINTMSG(ZONE_PDD_INIT, (L"Unknown IOCTL: %d\r\n", code));
; 2913 :         }
; 2914 :     return rc;
; 2915 : }

  000ec	e28dd00c	 add         sp, sp, #0xC
  000f0	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000f4	e12fff1e	 bx          lr
  000f8		 |$M49056|

			 ENDP  ; |UfnPdd_IOControl|

	EXPORT	|UfnPdd_DeregisterDevice|

  00000			 AREA	 |.pdata|, PDATA
|$T49076| DCD	|$LN12@UfnPdd_Der|
	DCD	0x40002a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_DeregisterDevice| PROC

; 3002 : {

  00000		 |$LN12@UfnPdd_Der|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M49073|
  00004	e1a04000	 mov         r4, r0

; 3003 :     DWORD rc = ERROR_SUCCESS;
; 3004 :     UINT16      epCsrReg = 0;
; 3005 :     UINT16      epCount  = 0;
; 3006 :     UINT8       powerRegVal;
; 3007 : 
; 3008 :     USBFNPDDCONTEXT *pPdd = (USBFNPDDCONTEXT *)pPddContext;
; 3009 :     CSL_UsbRegs     *pUsbdRegs = pPdd->pUsbdRegs;
; 3010 : 
; 3011 :     PRINTMSG(ZONE_FUNCTION, /*TRUE, */
; 3012 :             (L"UfnPdd_DeregisterDevice:\r\n"));
; 3013 : 
; 3014 :     LOCK_ENDPOINT (pPdd);

  00008	e594501c	 ldr         r5, [r4, #0x1C]
  0000c	e2840e27	 add         r0, r4, #0x27, 28
  00010	eb000000	 bl          EnterCriticalSection

; 3015 : 
; 3016 :     /* Flush the FIFO of EndPoint 0 */
; 3017 :     epCsrReg = pUsbdRegs->EPCSR[ 0 ].PERI_TXCSR;

  00014	e2852c05	 add         r2, r5, #5, 24
  00018	e1d230b2	 ldrh        r3, [r2, #2]

; 3018 :     epCsrReg |= (MGC_M_CSR0_FLUSHFIFO);
; 3019 :     pUsbdRegs->EPCSR[ 0 ].PERI_TXCSR = epCsrReg;
; 3020 : 
; 3021 :     /* Flush the FIFOs of all the Data EndPoints */
; 3022 :     for(epCount = 1; epCount < USBD_EP_COUNT; epCount++)

  0001c	e3a01001	 mov         r1, #1
  00020	e3a00001	 mov         r0, #1
  00024	e3833c01	 orr         r3, r3, #1, 24
  00028	e1c230b2	 strh        r3, [r2, #2]
  0002c	e3a06000	 mov         r6, #0
  00030		 |$LL5@UfnPdd_Der|

; 3023 :     {
; 3024 :         if (pPdd->ep[epCount].dirRx == TRUE)

  00030	e0613201	 rsb         r3, r1, r1, lsl #4
  00034	e084e103	 add         lr, r4, r3, lsl #2
  00038	e59e3294	 ldr         r3, [lr, #0x294]
  0003c	e3530001	 cmp         r3, #1

; 3025 :         {
; 3026 :             epCsrReg = pUsbdRegs->EPCSR[ epCount ].PERI_RXCSR;

  00040	e0853201	 add         r3, r5, r1, lsl #4
  00044	e2832c05	 add         r2, r3, #5, 24
  00048	01d230b6	 ldreqh      r3, [r2, #6]

; 3027 :             epCsrReg |= MGC_M_RXCSR_FLUSHFIFO;

  0004c	03833010	 orreq       r3, r3, #0x10

; 3028 :             pUsbdRegs->EPCSR[ epCount ].PERI_RXCSR = epCsrReg;

  00050	01c230b6	 streqh      r3, [r2, #6]

; 3029 :         }
; 3030 :         else
; 3031 :         {
; 3032 :             epCsrReg = pUsbdRegs->EPCSR[ epCount ].PERI_TXCSR;

  00054	11d230b2	 ldrneh      r3, [r2, #2]

; 3033 :             epCsrReg |= MGC_M_TXCSR_FLUSHFIFO;

  00058	13833008	 orrne       r3, r3, #8

; 3034 :             pUsbdRegs->EPCSR[ epCount ].PERI_TXCSR = epCsrReg;

  0005c	11c230b2	 strneh      r3, [r2, #2]
  00060	e2803001	 add         r3, r0, #1
  00064	e1a01803	 mov         r1, r3, lsl #16
  00068	e1a01821	 mov         r1, r1, lsr #16

; 3035 :         }
; 3036 : 
; 3037 :         /* Clear config */
; 3038 :         pPdd->ep[epCount].maxPacketSize = 0;

  0006c	e28e3c02	 add         r3, lr, #2, 24
  00070	e1a00001	 mov         r0, r1
  00074	e3510010	 cmp         r1, #0x10
  00078	e1c368bc	 strh        r6, [r3, #0x8C]

; 3039 :         pPdd->ep[epCount].fifoOffset = 0;

  0007c	e1c368be	 strh        r6, [r3, #0x8E]

; 3040 :         pPdd->ep[epCount].epInitialised = FALSE;

  00080	e58e6288	 str         r6, [lr, #0x288]
  00084	3affffe9	 bcc         |$LL5@UfnPdd_Der|

; 3041 :     }
; 3042 : 
; 3043 :     /* Put the Controller in SUSPEND State */
; 3044 : 
; 3045 :     /* Write into the Power Register's Enable SUSPEND Bit to initiate
; 3046 :      * the SUSPENDM Signal.
; 3047 :      */
; 3048 :     powerRegVal = pUsbdRegs->POWER;

  00088	e5d53401	 ldrb        r3, [r5, #0x401]

; 3049 :     powerRegVal |= MGC_M_POWER_ENSUSPEND;
; 3050 :     pUsbdRegs->POWER = powerRegVal;
; 3051 : 
; 3052 :     UNLOCK_ENDPOINT (pPdd);

  0008c	e2840e27	 add         r0, r4, #0x27, 28
  00090	e3833001	 orr         r3, r3, #1
  00094	e5c53401	 strb        r3, [r5, #0x401]
  00098	eb000000	 bl          LeaveCriticalSection

; 3053 : 
; 3054 :     return (rc);

  0009c	e3a00000	 mov         r0, #0

; 3055 : 
; 3056 : }

  000a0	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000a4	e12fff1e	 bx          lr
  000a8		 |$M49074|

			 ENDP  ; |UfnPdd_DeregisterDevice|

	EXPORT	|UfnPdd_Stop|
	IMPORT	|CloseHandle|
	IMPORT	|InterruptDisable|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T49091| DCD	|$LN9@UfnPdd_Sto|
	DCD	0x40002101
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\am3517\usb\usbfn\usbfnpdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_Stop| PROC

; 3074 : {

  00000		 |$LN9@UfnPdd_Sto|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M49088|
  00004	e1a04000	 mov         r4, r0

; 3075 :     DWORD rc = ERROR_SUCCESS;
; 3076 :     USBFNPDDCONTEXT *pPdd = (USBFNPDDCONTEXT *)pPddContext;
; 3077 : #ifdef CPPI_DMA_SUPPORT
; 3078 :     struct dma_controller * pDmaCntrl =
; 3079 :                 (struct dma_controller *)pPdd->pDmaCntrl;

  00008	e594065c	 ldr         r0, [r4, #0x65C]
  0000c	e1b03000	 movs        r3, r0

; 3080 : #endif /* #ifdef CPPI_DMA_SUPPORT */
; 3081 : 
; 3082 :     PRINTMSG(ZONE_FUNCTION, (L"UfnPdd_Stop:\r\n"));
; 3083 : 
; 3084 : #ifdef CPPI_DMA_SUPPORT
; 3085 :     /* Stop the DMA Controller Object */
; 3086 :     if (pDmaCntrl != NULL)
; 3087 :     {
; 3088 :         pDmaCntrl->pfnStop(pPdd->pDmaCntrl);

  00010	15933004	 ldrne       r3, [r3, #4]
  00014	11a0e00f	 movne       lr, pc
  00018	112fff13	 bxne        r3

; 3089 :     }
; 3090 : #endif /* #ifdef CPPI_DMA_SUPPORT */
; 3091 : 
; 3092 :     /* Stop the IST */
; 3093 :     pPdd->exitIntrThread = TRUE;
; 3094 : 
; 3095 :     if (pPdd->hIntrThread && pPdd->hIntrEvent)

  0001c	e5943044	 ldr         r3, [r4, #0x44]
  00020	e3a02001	 mov         r2, #1
  00024	e5842034	 str         r2, [r4, #0x34]
  00028	e3530000	 cmp         r3, #0
  0002c	0a00000a	 beq         |$LN1@UfnPdd_Sto|
  00030	e5943030	 ldr         r3, [r4, #0x30]
  00034	e3530000	 cmp         r3, #0
  00038	0a000007	 beq         |$LN1@UfnPdd_Sto|

; 3096 :     {
; 3097 :         InterruptDisable(pPdd->sysIntr);

  0003c	e594002c	 ldr         r0, [r4, #0x2C]
  00040	eb000000	 bl          InterruptDisable

; 3098 :         SetEvent(pPdd->hIntrEvent);

  00044	e5940030	 ldr         r0, [r4, #0x30]
  00048	e3a01003	 mov         r1, #3
  0004c	eb000000	 bl          EventModify

; 3099 :         WaitForSingleObject(pPdd->hIntrThread, INFINITE);

  00050	e5940044	 ldr         r0, [r4, #0x44]
  00054	e3e01000	 mvn         r1, #0
  00058	eb000000	 bl          WaitForSingleObject
  0005c		 |$LN1@UfnPdd_Sto|

; 3100 :     }
; 3101 : 
; 3102 :     CloseHandle(pPdd->hIntrThread);

  0005c	e5940044	 ldr         r0, [r4, #0x44]
  00060	eb000000	 bl          CloseHandle

; 3103 :     CloseHandle(pPdd->hIntrEvent);

  00064	e5940030	 ldr         r0, [r4, #0x30]
  00068	eb000000	 bl          CloseHandle

; 3104 : 
; 3105 :     pPdd->hIntrThread = NULL;

  0006c	e3a03000	 mov         r3, #0
  00070	e5843044	 str         r3, [r4, #0x44]

; 3106 :     pPdd->hIntrEvent  = NULL;

  00074	e5843030	 str         r3, [r4, #0x30]

; 3107 : 
; 3108 : 	return (rc);

  00078	e3a00000	 mov         r0, #0

; 3109 : }

  0007c	e8bd4010	 ldmia       sp!, {r4, lr}
  00080	e12fff1e	 bx          lr
  00084		 |$M49089|

			 ENDP  ; |UfnPdd_Stop|

	EXPORT	|UfnPdd_SetAddress|

  00000			 AREA	 |.pdata|, PDATA
|$T49102| DCD	|$LN5@UfnPdd_Set|
	DCD	0x40000600
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_SetAddress| PROC

; 3500 : {

  00000		 |$LN5@UfnPdd_Set|
  00000		 |$M49099|

; 3501 :     DWORD rc = ERROR_SUCCESS;
; 3502 :     USBFNPDDCONTEXT *pPdd = (USBFNPDDCONTEXT *)pvPddContext;
; 3503 : 
; 3504 :     PRINTMSG(ZONE_PDD_INIT, (L"UfnPdd_SetAddress: %d\r\n", address));
; 3505 : 
; 3506 :     /* Write into the FADDR Register */
; 3507 :     pPdd->devAddress = (address & 0x7F);
; 3508 :     pPdd->pUsbdRegs->FADDR = pPdd->devAddress;

  00000	e590201c	 ldr         r2, [r0, #0x1C]
  00004	e201307f	 and         r3, r1, #0x7F
  00008	e5c03040	 strb        r3, [r0, #0x40]
  0000c	e5c23400	 strb        r3, [r2, #0x400]

; 3509 : 
; 3510 :     return (rc);

  00010	e3a00000	 mov         r0, #0

; 3511 : }

  00014	e12fff1e	 bx          lr
  00018		 |$M49100|

			 ENDP  ; |UfnPdd_SetAddress|

	EXPORT	|UfnPdd_Start|
	EXPORT	|??_C@_1FE@KKBNOJNJ@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AA?5?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAi?$AAo?$AAn@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FC@JMCHKDAM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FA@JLPCCCGC@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AA?5@| [ DATA ] ; `string'
	IMPORT	|DumpUsbRegisters|
	IMPORT	|CeSetThreadPriority|
	IMPORT	|CreateThread|
	IMPORT	|InterruptInitialize|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T49119| DCD	|$LN14@UfnPdd_Sta@2|
	DCD	0x40005802

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FE@KKBNOJNJ@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AA?5?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAi?$AAo?$AAn@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "I", 0x0, "n", 0x0, "t", 0x0, "e", 0x0, "r", 0x0, "r"
	DCB	0x0, "u", 0x0, "p", 0x0, "t", 0x0, " ", 0x0, "t", 0x0, "h"
	DCB	0x0, "r", 0x0, "e", 0x0, "a", 0x0, "d", 0x0, " ", 0x0, "c"
	DCB	0x0, "r", 0x0, "e", 0x0, "a", 0x0, "t", 0x0, "i", 0x0, "o"
	DCB	0x0, "n", 0x0, " ", 0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l"
	DCB	0x0, "e", 0x0, "d", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FC@JMCHKDAM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "I", 0x0, "n", 0x0, "t", 0x0, "e", 0x0, "r", 0x0, "r"
	DCB	0x0, "u", 0x0, "p", 0x0, "t", 0x0, " ", 0x0, "i", 0x0, "n"
	DCB	0x0, "i", 0x0, "t", 0x0, "i", 0x0, "a", 0x0, "l", 0x0, "i"
	DCB	0x0, "z", 0x0, "a", 0x0, "t", 0x0, "i", 0x0, "o", 0x0, "n"
	DCB	0x0, " ", 0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e"
	DCB	0x0, "d", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FA@JLPCCCGC@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AA?5@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "E", 0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, " "
	DCB	0x0, "c", 0x0, "r", 0x0, "e", 0x0, "a", 0x0, "t", 0x0, "i"
	DCB	0x0, "n", 0x0, "g", 0x0, " ", 0x0, "i", 0x0, "n", 0x0, "t"
	DCB	0x0, "e", 0x0, "r", 0x0, "r", 0x0, "u", 0x0, "p", 0x0, "t"
	DCB	0x0, " ", 0x0, "e", 0x0, "v", 0x0, "e", 0x0, "n", 0x0, "t"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\am3517\usb\usbfn\usbfnpdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_Start| PROC

; 3528 : {

  00000		 |$LN14@UfnPdd_Sta@2|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M49116|
  00008	e1a04000	 mov         r4, r0

; 3529 :     DWORD rc = ERROR_SUCCESS;
; 3530 :     UINT32 usbIrqRegVal = 0;
; 3531 : 
; 3532 :     USBFNPDDCONTEXT  *pPdd = (USBFNPDDCONTEXT *)pPddContext;
; 3533 : 
; 3534 : #ifdef CPPI_DMA_SUPPORT
; 3535 :     /* Initialize the DMA Controller Object */
; 3536 :     struct dma_controller *pDmaCntrl = (struct dma_controller *)pPdd->pDmaCntrl;
; 3537 : #endif
; 3538 : 
; 3539 :     PRINTMSG(ZONE_FUNCTION, (L"UfnPdd_Start:\r\n"));
; 3540 : 
; 3541 :     /* Create interrupt event */
; 3542 :     pPdd->hIntrEvent = CreateEvent(0, FALSE, FALSE, NULL);

  0000c	e594665c	 ldr         r6, [r4, #0x65C]
  00010	e3a03000	 mov         r3, #0
  00014	e3a02000	 mov         r2, #0
  00018	e3a01000	 mov         r1, #0
  0001c	e3a00000	 mov         r0, #0
  00020	e3a05000	 mov         r5, #0
  00024	eb000000	 bl          CreateEventW
  00028	e1b01000	 movs        r1, r0
  0002c	e5841030	 str         r1, [r4, #0x30]

; 3543 :     if ( pPdd->hIntrEvent == NULL )

  00030	1a000008	 bne         |$LN6@UfnPdd_Sta@2|

; 3544 :     {
; 3545 :         ERRORMSG (TRUE, (L"ERROR: Error creating interrupt event\r\n"));

  00034	e59f1114	 ldr         r1, [pc, #0x114]
  00038	e59f010c	 ldr         r0, [pc, #0x10C]
  0003c	e3a03c0d	 mov         r3, #0xD, 24
  00040	e38320d9	 orr         r2, r3, #0xD9
  00044	eb000000	 bl          NKDbgPrintfW
  00048	e59f010c	 ldr         r0, [pc, #0x10C]
  0004c		 |$LN11@UfnPdd_Sta@2|
  0004c	eb000000	 bl          NKDbgPrintfW

; 3546 :         rc = ERROR_GEN_FAILURE;

  00050	e3a0501f	 mov         r5, #0x1F

; 3547 :         goto Exit;

  00054	ea000037	 b           |$Exit$48000|
  00058		 |$LN6@UfnPdd_Sta@2|

; 3548 :     }
; 3549 :     
; 3550 :     /* Initialize interrupt */
; 3551 :     if (!InterruptInitialize( pPdd->sysIntr, pPdd->hIntrEvent, NULL, 0))

  00058	e594002c	 ldr         r0, [r4, #0x2C]
  0005c	e3a03000	 mov         r3, #0
  00060	e3a02000	 mov         r2, #0
  00064	eb000000	 bl          InterruptInitialize
  00068	e3500000	 cmp         r0, #0
  0006c	1a000006	 bne         |$LN5@UfnPdd_Sta@2|

; 3552 :     {
; 3553 :         ERRORMSG (TRUE, (L"ERROR: Interrupt initialization failed\r\n"));

  00070	e59f10d8	 ldr         r1, [pc, #0xD8]
  00074	e59f00d0	 ldr         r0, [pc, #0xD0]
  00078	e3a03c0d	 mov         r3, #0xD, 24
  0007c	e38320e1	 orr         r2, r3, #0xE1
  00080	eb000000	 bl          NKDbgPrintfW
  00084	e59f00cc	 ldr         r0, [pc, #0xCC]

; 3554 :         rc = ERROR_GEN_FAILURE;
; 3555 :         goto Exit;

  00088	eaffffef	 b           |$LN11@UfnPdd_Sta@2|
  0008c		 |$LN5@UfnPdd_Sta@2|

; 3556 :     }
; 3557 : 
; 3558 :     /* Run interrupt thread */
; 3559 :     pPdd->exitIntrThread = FALSE;
; 3560 :     pPdd->hIntrThread = CreateThread (NULL, 0, InterruptThread, pPdd, 0, NULL);

  0008c	e59f20c0	 ldr         r2, [pc, #0xC0]
  00090	e3a0e000	 mov         lr, #0
  00094	e1a03004	 mov         r3, r4
  00098	e3a01000	 mov         r1, #0
  0009c	e3a00000	 mov         r0, #0
  000a0	e584e034	 str         lr, [r4, #0x34]
  000a4	e58de004	 str         lr, [sp, #4]
  000a8	e58de000	 str         lr, [sp]
  000ac	eb000000	 bl          CreateThread
  000b0	e3500000	 cmp         r0, #0
  000b4	e5840044	 str         r0, [r4, #0x44]

; 3561 :     if ( pPdd->hIntrThread == NULL )

  000b8	1a000006	 bne         |$LN4@UfnPdd_Sta@2|

; 3562 :     {
; 3563 :         ERRORMSG (TRUE, (L"ERROR: Interrupt thread creation failed\r\n"));

  000bc	e59f108c	 ldr         r1, [pc, #0x8C]
  000c0	e59f0084	 ldr         r0, [pc, #0x84]
  000c4	e3a03c0d	 mov         r3, #0xD, 24
  000c8	e38320eb	 orr         r2, r3, #0xEB
  000cc	eb000000	 bl          NKDbgPrintfW
  000d0	e59f0070	 ldr         r0, [pc, #0x70]

; 3564 :         rc = ERROR_GEN_FAILURE;
; 3565 :         goto Exit;

  000d4	eaffffdc	 b           |$LN11@UfnPdd_Sta@2|
  000d8		 |$LN4@UfnPdd_Sta@2|

; 3566 :     }
; 3567 :     CeSetThreadPriority(pPdd->hIntrThread, pPdd->priority256);

  000d8	e5941004	 ldr         r1, [r4, #4]
  000dc	eb000000	 bl          CeSetThreadPriority

; 3568 : 
; 3569 :     PRINTMSG(ZONE_PDD_INIT, (L"UfnPdd_Start: USBFnPDD IntrThread 0x%08x\r\n",
; 3570 :                              pPdd->hIntrThread));
; 3571 : 
; 3572 :     /* Power up */
; 3573 :     if ((pPdd->currentPowerState == D3) || (pPdd->currentPowerState == D4))

  000e0	e5943048	 ldr         r3, [r4, #0x48]
  000e4	e3530003	 cmp         r3, #3
  000e8	0a000001	 beq         |$LN2@UfnPdd_Sta@2|
  000ec	e3530004	 cmp         r3, #4
  000f0	1a000002	 bne         |$LN3@UfnPdd_Sta@2|
  000f4		 |$LN2@UfnPdd_Sta@2|

; 3574 :     {
; 3575 :         SetPowerState(pPdd, D0);

  000f4	e3a01000	 mov         r1, #0
  000f8	e1a00004	 mov         r0, r4
  000fc	eb000000	 bl          SetPowerState
  00100		 |$LN3@UfnPdd_Sta@2|

; 3576 :     }
; 3577 : 
; 3578 :     /* Now Enable the CORE Interrupts */
; 3579 :     usbIrqRegVal = USB_OTG_USBINT_MASK & ~(CSL_USB_INTRUSB_SOF_MASK << CSL_USB_INTMSKR_USB_SHIFT);
; 3580 :     pPdd->pUsbdRegs->CORE_INTMSKSETR = usbIrqRegVal;

  00100	e594201c	 ldr         r2, [r4, #0x1C]
  00104	e3a0377d	 mov         r3, #0x7D, 14
  00108	e3833803	 orr         r3, r3, #3, 16

; 3581 : 
; 3582 :     PRINTMSG(ZONE_PDD_INIT, (L"UfnPdd_Start: Reenabled all Interrupts \r\n"));
; 3583 :     DumpUsbRegisters(pPdd);

  0010c	e1a00004	 mov         r0, r4
  00110	e5823050	 str         r3, [r2, #0x50]
  00114	eb000000	 bl          DumpUsbRegisters

; 3584 : 
; 3585 : #ifdef CPPI_DMA_SUPPORT
; 3586 :     /* Start the DMA Controller Object */
; 3587 :     if (pDmaCntrl != NULL)

  00118	e3560000	 cmp         r6, #0

; 3588 :     {
; 3589 :         pDmaCntrl->pfnStart(pPdd->pDmaCntrl);

  0011c	1594065c	 ldrne       r0, [r4, #0x65C]
  00120	15963000	 ldrne       r3, [r6]
  00124	11a0e00f	 movne       lr, pc
  00128	112fff13	 bxne        r3

; 3590 :     }
; 3591 : #endif /* #ifdef CPPI_DMA_SUPPORT */
; 3592 : 
; 3593 :     /* Release the IST */
; 3594 :     SetEvent(pPdd->hStartEvent);

  0012c	e594026c	 ldr         r0, [r4, #0x26C]
  00130	e3a01003	 mov         r1, #3
  00134	eb000000	 bl          EventModify
  00138		 |$Exit$48000|

; 3595 : 
; 3596 : Exit:
; 3597 :     return (rc);
; 3598 : 
; 3599 : }

  00138	e1a00005	 mov         r0, r5
  0013c	e28dd008	 add         sp, sp, #8
  00140	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00144	e12fff1e	 bx          lr
  00148		 |$LN15@UfnPdd_Sta@2|
  00148		 |$LN16@UfnPdd_Sta@2|
  00148	00000000	 DCD         |??_C@_1FE@KKBNOJNJ@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AA?5?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAi?$AAo?$AAn@|
  0014c		 |$LN17@UfnPdd_Sta@2|
  0014c	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  00150		 |$LN18@UfnPdd_Sta@2|
  00150	00000000	 DCD         |??_C@_1JO@JAGHJEHH@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  00154		 |$LN19@UfnPdd_Sta@2|
  00154	00000000	 DCD         |InterruptThread|
  00158		 |$LN20@UfnPdd_Sta@2|
  00158	00000000	 DCD         |??_C@_1FC@JMCHKDAM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5@|
  0015c		 |$LN21@UfnPdd_Sta@2|
  0015c	00000000	 DCD         |??_C@_1FA@JLPCCCGC@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AA?5@|
  00160		 |$M49117|

			 ENDP  ; |UfnPdd_Start|

	EXPORT	|UfnPdd_IsEndpointSupportable|

  00000			 AREA	 |.pdata|, PDATA
|$T49138| DCD	|$LN13@UfnPdd_IsE@2|
	DCD	0x40001400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_IsEndpointSupportable| PROC

; 3806 : {

  00000		 |$LN13@UfnPdd_IsE@2|
  00000		 |$M49135|
  00000	e3510000	 cmp         r1, #0

; 3807 :     DWORD rc = ERROR_INVALID_PARAMETER;

  00004	e3a00057	 mov         r0, #0x57

; 3808 :     WORD  packetSize;
; 3809 :     BYTE  transferType;
; 3810 : 
; 3811 : 	UNREFERENCED_PARAMETER(alternateSetting);
; 3812 : 	UNREFERENCED_PARAMETER(interfaceNumber);
; 3813 : 	UNREFERENCED_PARAMETER(configurationValue);
; 3814 : 	UNREFERENCED_PARAMETER(speed);
; 3815 : 	UNREFERENCED_PARAMETER(pvPddContext);
; 3816 : 
; 3817 :     PRINTMSG(ZONE_FUNCTION, (L"+UfnPdd_IsEndpointSupportable EP %u\r\n",
; 3818 :                              endpoint));
; 3819 : 
; 3820 :     /* Update maximal packet size for EP0 */
; 3821 :     if (endpoint == 0)

  00008	1a000005	 bne         |$LN8@UfnPdd_IsE@2|

; 3822 :     {
; 3823 :         PRINTMSG(ZONE_PDD_INIT, (L"EP0 MaxPktSize 0x%x\r\n",
; 3824 :                                  pEndpointDesc->wMaxPacketSize));
; 3825 : 
; 3826 :         DEBUGCHK(pEndpointDesc->wMaxPacketSize <= 64);
; 3827 :         DEBUGCHK(pEndpointDesc->bmAttributes == USB_ENDPOINT_TYPE_CONTROL);
; 3828 :         pEndpointDesc->wMaxPacketSize = 64;

  0000c	e3a02040	 mov         r2, #0x40
  00010	e3a01000	 mov         r1, #0
  00014	e5c32004	 strb        r2, [r3, #4]
  00018	e5c31005	 strb        r1, [r3, #5]
  0001c		 |$LN3@UfnPdd_IsE@2|

; 3841 :         {
; 3842 :             /* Isochronous EndPoint  */
; 3843 :         case USB_ENDPOINT_TYPE_ISOCHRONOUS:
; 3844 :             PRINTMSG(ZONE_PDD_INIT, (TEXT("Isochronous endpoint\r\n")));
; 3845 :             rc = ERROR_SUCCESS;

  0001c	e3a00000	 mov         r0, #0
  00020		 |$LN4@UfnPdd_IsE@2|

; 3856 :             break;
; 3857 :         }
; 3858 : 
; 3859 :         /*
; 3860 :          * If Requested Size is larger than what is supported ... change it.
; 3861 :          * Note only try and change it if no errors so far... meaning Ep is
; 3862 :          * Supportable.
; 3863 :          */
; 3864 : 
; 3865 :     }
; 3866 : 
; 3867 :     return (rc);
; 3868 : 
; 3869 : }

  00020	e12fff1e	 bx          lr
  00024		 |$LN8@UfnPdd_IsE@2|

; 3829 :         rc = ERROR_SUCCESS ;
; 3830 :     }
; 3831 :     else if (endpoint < USBD_EP_COUNT)

  00024	e3510010	 cmp         r1, #0x10
  00028	2afffffc	 bcs         |$LN4@UfnPdd_IsE@2|

; 3832 :     {
; 3833 :         transferType = pEndpointDesc->bmAttributes & USB_ENDPOINT_TYPE_MASK;
; 3834 :         DEBUGCHK(transferType != USB_ENDPOINT_TYPE_CONTROL);
; 3835 : 
; 3836 :         /* Validate and adjust packet size */
; 3837 :         packetSize =
; 3838 :             (pEndpointDesc->wMaxPacketSize & USB_ENDPOINT_MAX_PACKET_SIZE_MASK);
; 3839 : 
; 3840 :         switch(transferType)

  0002c	e5d33003	 ldrb        r3, [r3, #3]
  00030	e2033003	 and         r3, r3, #3
  00034	e3530001	 cmp         r3, #1
  00038	0afffff7	 beq         |$LN3@UfnPdd_IsE@2|
  0003c	e2433002	 sub         r3, r3, #2
  00040	e3530001	 cmp         r3, #1

; 3846 :             break;
; 3847 :         case USB_ENDPOINT_TYPE_BULK:
; 3848 :         case USB_ENDPOINT_TYPE_INTERRUPT:
; 3849 :             PRINTMSG(ZONE_PDD_INIT,
; 3850 :                      (TEXT("Bulk or Intr EndPoint PktSize 0x%x\r\n"),
; 3851 :                       packetSize));
; 3852 :             rc = ERROR_SUCCESS ;
; 3853 :             break;

  00044	9afffff4	 bls         |$LN3@UfnPdd_IsE@2|

; 3854 :         default:
; 3855 :             rc = ERROR_INVALID_PARAMETER;

  00048	e3a00057	 mov         r0, #0x57

; 3856 :             break;
; 3857 :         }
; 3858 : 
; 3859 :         /*
; 3860 :          * If Requested Size is larger than what is supported ... change it.
; 3861 :          * Note only try and change it if no errors so far... meaning Ep is
; 3862 :          * Supportable.
; 3863 :          */
; 3864 : 
; 3865 :     }
; 3866 : 
; 3867 :     return (rc);
; 3868 : 
; 3869 : }

  0004c	e12fff1e	 bx          lr
  00050		 |$M49136|

			 ENDP  ; |UfnPdd_IsEndpointSupportable|

	EXPORT	|??_C@_1HO@PILHPEAA@?$AAI?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?9?$AA?5?$AAF@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HM@ONGEIPOP@?$AAI?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?9?$AA?5?$AAD@| [ DATA ] ; `string'
	IMPORT	|HalAllocateCommonBuffer|
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T49154| DCD	|$LN8@InitEndpoi|
	DCD	0x40003d02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HO@PILHPEAA@?$AAI?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?9?$AA?5?$AAF@| DCB "I"
	DCB	0x0, "n", 0x0, "i", 0x0, "t", 0x0, "E", 0x0, "n", 0x0, "d"
	DCB	0x0, "p", 0x0, "o", 0x0, "i", 0x0, "n", 0x0, "t", 0x0, "D"
	DCB	0x0, "m", 0x0, "a", 0x0, "B", 0x0, "u", 0x0, "f", 0x0, "f"
	DCB	0x0, "e", 0x0, "r", 0x0, ":", 0x0, " ", 0x0, "E", 0x0, "R"
	DCB	0x0, "R", 0x0, "O", 0x0, "R", 0x0, " ", 0x0, "-", 0x0, " "
	DCB	0x0, "F", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "a", 0x0, "l"
	DCB	0x0, "l", 0x0, "o", 0x0, "c", 0x0, "a", 0x0, "t", 0x0, "e"
	DCB	0x0, " ", 0x0, "D", 0x0, "M", 0x0, "A", 0x0, " ", 0x0, "b"
	DCB	0x0, "u", 0x0, "f", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HM@ONGEIPOP@?$AAI?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?9?$AA?5?$AAD@| DCB "I"
	DCB	0x0, "n", 0x0, "i", 0x0, "t", 0x0, "E", 0x0, "n", 0x0, "d"
	DCB	0x0, "p", 0x0, "o", 0x0, "i", 0x0, "n", 0x0, "t", 0x0, "D"
	DCB	0x0, "m", 0x0, "a", 0x0, "B", 0x0, "u", 0x0, "f", 0x0, "f"
	DCB	0x0, "e", 0x0, "r", 0x0, ":", 0x0, " ", 0x0, "E", 0x0, "R"
	DCB	0x0, "R", 0x0, "O", 0x0, "R", 0x0, " ", 0x0, "-", 0x0, " "
	DCB	0x0, "D", 0x0, "M", 0x0, "A", 0x0, " ", 0x0, "b", 0x0, "u"
	DCB	0x0, "f", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, " ", 0x0, "a"
	DCB	0x0, "l", 0x0, "r", 0x0, "e", 0x0, "a", 0x0, "d", 0x0, "y"
	DCB	0x0, " ", 0x0, "a", 0x0, "l", 0x0, "l", 0x0, "o", 0x0, "c"
	DCB	0x0, "a", 0x0, "t", 0x0, "e", 0x0, "d", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |InitEndpointDmaBuffer| PROC

; 4112 : {

  00000		 |$LN8@InitEndpoi|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M49151|
  00008	e1a05000	 mov         r5, r0

; 4113 :     BOOL rc = FALSE;
; 4114 :     UsbFnEp *ep = &pPdd->ep[epNum];

  0000c	e0613201	 rsb         r3, r1, r1, lsl #4
  00010	e0857103	 add         r7, r5, r3, lsl #2

; 4115 :     DWORD size = pPdd->dmaBufferSize;
; 4116 : 
; 4117 :     DMA_ADAPTER_OBJECT Adapter;
; 4118 :     PHYSICAL_ADDRESS pa;
; 4119 : 
; 4120 :     DEBUGMSG(ZONE_PDD_INIT,
; 4121 :         (L"+InitEndpointDmaBuffer: EP%u - %u bytes\r\n",
; 4122 :         epNum,
; 4123 :         size));
; 4124 : 
; 4125 :     if (ep->pDmaBuffer != NULL) {

  00014	e59732b4	 ldr         r3, [r7, #0x2B4]
  00018	e5956008	 ldr         r6, [r5, #8]
  0001c	e3a04000	 mov         r4, #0
  00020	e3530000	 cmp         r3, #0
  00024	0a000007	 beq         |$LN2@InitEndpoi|

; 4126 :         ERRORMSG(TRUE,
; 4127 :             (L"InitEndpointDmaBuffer: ERROR - DMA buffer already allocated\r\n"));

  00028	e59f10bc	 ldr         r1, [pc, #0xBC]
  0002c	e59f00b4	 ldr         r0, [pc, #0xB4]
  00030	e3a03a01	 mov         r3, #1, 20
  00034	e383201f	 orr         r2, r3, #0x1F
  00038	eb000000	 bl          NKDbgPrintfW
  0003c	e59f00ac	 ldr         r0, [pc, #0xAC]
  00040	eb000000	 bl          NKDbgPrintfW

; 4128 :         goto exit;

  00044	ea000022	 b           |$exit$48187|
  00048		 |$LN2@InitEndpoi|

; 4129 :     }
; 4130 : 
; 4131 :     Adapter.ObjectSize = sizeof(DMA_ADAPTER_OBJECT);
; 4132 :     Adapter.InterfaceType = Internal;
; 4133 :     Adapter.BusNumber = 0;
; 4134 : 
; 4135 :     LOCK_ENDPOINT(pPdd);

  00048	e3a0300c	 mov         r3, #0xC
  0004c	e3a02000	 mov         r2, #0
  00050	e3a01000	 mov         r1, #0
  00054	e2850e27	 add         r0, r5, #0x27, 28
  00058	e1cd30b8	 strh        r3, [sp, #8]
  0005c	e58d200c	 str         r2, [sp, #0xC]
  00060	e58d1010	 str         r1, [sp, #0x10]
  00064	eb000000	 bl          EnterCriticalSection

; 4136 :     ep->pDmaBuffer  = (UCHAR *)HalAllocateCommonBuffer(&Adapter, size, &pa, FALSE);

  00068	e3a03000	 mov         r3, #0
  0006c	e28d2000	 add         r2, sp, #0
  00070	e1a01006	 mov         r1, r6
  00074	e28d0008	 add         r0, sp, #8
  00078	eb000000	 bl          HalAllocateCommonBuffer

; 4137 :     ep->paDmaBuffer = pa.LowPart;

  0007c	e59d3000	 ldr         r3, [sp]
  00080	e1a02000	 mov         r2, r0

; 4138 :     UNLOCK_ENDPOINT(pPdd);

  00084	e2850e27	 add         r0, r5, #0x27, 28
  00088	e58732b8	 str         r3, [r7, #0x2B8]
  0008c	e58722b4	 str         r2, [r7, #0x2B4]
  00090	eb000000	 bl          LeaveCriticalSection

; 4139 : 
; 4140 :     if (ep->pDmaBuffer == NULL)

  00094	e59732b4	 ldr         r3, [r7, #0x2B4]
  00098	e3530000	 cmp         r3, #0
  0009c	1a000007	 bne         |$LN1@InitEndpoi|

; 4141 :     {
; 4142 :         ERRORMSG(TRUE,
; 4143 :             (L"InitEndpointDmaBuffer: ERROR - Failed to allocate DMA buffer\r\n"));

  000a0	e59f1044	 ldr         r1, [pc, #0x44]
  000a4	e59f003c	 ldr         r0, [pc, #0x3C]
  000a8	e3a03a01	 mov         r3, #1, 20
  000ac	e383202f	 orr         r2, r3, #0x2F
  000b0	eb000000	 bl          NKDbgPrintfW
  000b4	e59f0028	 ldr         r0, [pc, #0x28]
  000b8	eb000000	 bl          NKDbgPrintfW
  000bc	ea000004	 b           |$exit$48187|
  000c0		 |$LN1@InitEndpoi|

; 4144 :         goto exit;
; 4145 :     }
; 4146 :     memset(ep->pDmaBuffer, 0, size);

  000c0	e1a02006	 mov         r2, r6
  000c4	e3a01000	 mov         r1, #0
  000c8	e1a00003	 mov         r0, r3
  000cc	eb000000	 bl          memset

; 4147 :     rc = TRUE;

  000d0	e3a04001	 mov         r4, #1
  000d4		 |$exit$48187|

; 4148 : 
; 4149 :     DEBUGMSG(ZONE_PDD_INIT,
; 4150 :         (L"InitEndpointDmaBuffer: Allocated DMA buffer - PA 0x%08x VA 0x%08x Size 0x%x\r\n",
; 4151 :         ep->pDmaBuffer,
; 4152 :         ep->paDmaBuffer,
; 4153 :         size));
; 4154 : 
; 4155 : exit:
; 4156 :     DEBUGMSG(ZONE_PDD_INIT,
; 4157 :         (L"-InitEndpointDmaBuffer: %s\r\n",
; 4158 :         rc ?
; 4159 :             L"SUCCEEDED" :
; 4160 :             L"FAILED"));
; 4161 : 
; 4162 :     return rc;
; 4163 : }

  000d4	e1a00004	 mov         r0, r4
  000d8	e28dd014	 add         sp, sp, #0x14
  000dc	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000e0	e12fff1e	 bx          lr
  000e4		 |$LN9@InitEndpoi|
  000e4		 |$LN10@InitEndpoi|
  000e4	00000000	 DCD         |??_C@_1HO@PILHPEAA@?$AAI?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?9?$AA?5?$AAF@|
  000e8		 |$LN11@InitEndpoi|
  000e8	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  000ec		 |$LN12@InitEndpoi|
  000ec	00000000	 DCD         |??_C@_1JO@JAGHJEHH@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  000f0		 |$LN13@InitEndpoi|
  000f0	00000000	 DCD         |??_C@_1HM@ONGEIPOP@?$AAI?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?9?$AA?5?$AAD@|
  000f4		 |$M49152|

			 ENDP  ; |InitEndpointDmaBuffer|

	EXPORT	|??_C@_1GC@HMLPLGML@?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?9@| [ DATA ] ; `string'
	IMPORT	|HalFreeCommonBuffer|

  00000			 AREA	 |.pdata|, PDATA
|$T49175| DCD	|$LN6@DeinitEndp|
	DCD	0x40002802

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GC@HMLPLGML@?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?9@| DCB "D"
	DCB	0x0, "e", 0x0, "i", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, "E"
	DCB	0x0, "n", 0x0, "d", 0x0, "p", 0x0, "o", 0x0, "i", 0x0, "n"
	DCB	0x0, "t", 0x0, "D", 0x0, "m", 0x0, "a", 0x0, "B", 0x0, "u"
	DCB	0x0, "f", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "E", 0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, " "
	DCB	0x0, "-", 0x0, " ", 0x0, "N", 0x0, "o", 0x0, " ", 0x0, "D"
	DCB	0x0, "M", 0x0, "A", 0x0, " ", 0x0, "b", 0x0, "u", 0x0, "f"
	DCB	0x0, "f", 0x0, "e", 0x0, "r", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DeinitEndpointDmaBuffer| PROC

; 4170 : {

  00000		 |$LN6@DeinitEndp|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M49172|
  00008	e1a05000	 mov         r5, r0

; 4171 :     BOOL rc = FALSE;
; 4172 :     UsbFnEp *ep = &pPdd->ep[epNum];

  0000c	e0613201	 rsb         r3, r1, r1, lsl #4
  00010	e0856103	 add         r6, r5, r3, lsl #2

; 4173 :     DWORD size = pPdd->dmaBufferSize;
; 4174 : 
; 4175 :     DMA_ADAPTER_OBJECT Adapter;
; 4176 :     PHYSICAL_ADDRESS pa;
; 4177 : 
; 4178 :     DEBUGMSG(ZONE_PDD_INIT,
; 4179 :         (L"+DeinitEndpointDmaBuffer: EP%u - %u bytes\r\n",
; 4180 :         epNum,
; 4181 :         size));
; 4182 : 
; 4183 :     if (ep->pDmaBuffer == NULL) {

  00014	e59632b4	 ldr         r3, [r6, #0x2B4]
  00018	e5957008	 ldr         r7, [r5, #8]
  0001c	e3a04000	 mov         r4, #0
  00020	e3530000	 cmp         r3, #0
  00024	1a000007	 bne         |$LN1@DeinitEndp|

; 4184 :         ERRORMSG(TRUE,
; 4185 :             (L"DeinitEndpointDmaBuffer: ERROR - No DMA buffer\r\n"));

  00028	e59f106c	 ldr         r1, [pc, #0x6C]
  0002c	e59f0064	 ldr         r0, [pc, #0x64]
  00030	e3a03a01	 mov         r3, #1, 20
  00034	e3832059	 orr         r2, r3, #0x59
  00038	eb000000	 bl          NKDbgPrintfW
  0003c	e59f0050	 ldr         r0, [pc, #0x50]
  00040	eb000000	 bl          NKDbgPrintfW

; 4186 :         goto exit;

  00044	ea00000e	 b           |$exit$48209|
  00048		 |$LN1@DeinitEndp|

; 4187 :     }
; 4188 :     LOCK_ENDPOINT(pPdd);

  00048	e2850e27	 add         r0, r5, #0x27, 28
  0004c	eb000000	 bl          EnterCriticalSection

; 4189 :     pa.QuadPart = ep->paDmaBuffer;
; 4190 :     HalFreeCommonBuffer(&Adapter, size, pa, ep->pDmaBuffer, FALSE);

  00050	e59602b4	 ldr         r0, [r6, #0x2B4]
  00054	e59622b8	 ldr         r2, [r6, #0x2B8]
  00058	e3a04000	 mov         r4, #0
  0005c	e58d0000	 str         r0, [sp]
  00060	e28d0008	 add         r0, sp, #8
  00064	e3a03000	 mov         r3, #0
  00068	e1a01007	 mov         r1, r7
  0006c	e58d4004	 str         r4, [sp, #4]
  00070	eb000000	 bl          HalFreeCommonBuffer

; 4191 :     ep->pDmaBuffer = NULL;
; 4192 :     UNLOCK_ENDPOINT(pPdd);

  00074	e2850e27	 add         r0, r5, #0x27, 28
  00078	e58642b4	 str         r4, [r6, #0x2B4]
  0007c	eb000000	 bl          LeaveCriticalSection

; 4193 :     rc = TRUE;

  00080	e3a04001	 mov         r4, #1
  00084		 |$exit$48209|

; 4194 : 
; 4195 : exit:
; 4196 :     DEBUGMSG(ZONE_PDD_INIT,
; 4197 :         (L"-DeinitEndpointDmaBuffer: %s\r\n",
; 4198 :         rc ?
; 4199 :             L"SUCCEEDED" :
; 4200 :             L"FAILED"));
; 4201 : 
; 4202 :     return rc;
; 4203 : }

  00084	e1a00004	 mov         r0, r4
  00088	e28dd014	 add         sp, sp, #0x14
  0008c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$LN7@DeinitEndp|
  00094		 |$LN8@DeinitEndp|
  00094	00000000	 DCD         |??_C@_1GC@HMLPLGML@?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?9@|
  00098		 |$LN9@DeinitEndp|
  00098	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  0009c		 |$LN10@DeinitEndp|
  0009c	00000000	 DCD         |??_C@_1JO@JAGHJEHH@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  000a0		 |$M49173|

			 ENDP  ; |DeinitEndpointDmaBuffer|

	EXPORT	|GetTotalAltSettingCount|
	EXPORT	|??_C@_1KO@JAHICGJ@?$AAU?$AAF?$AAN?$AA?3?$AA?5?$AAG?$AAe?$AAt?$AAT?$AAo?$AAt?$AAa?$AAl?$AAA?$AAl?$AAt?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?3?$AAi?$AAn?$AAc@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T49202| DCD	|$LN19@GetTotalAl|
	DCD	0x40003c01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1KO@JAHICGJ@?$AAU?$AAF?$AAN?$AA?3?$AA?5?$AAG?$AAe?$AAt?$AAT?$AAo?$AAt?$AAa?$AAl?$AAA?$AAl?$AAt?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?3?$AAi?$AAn?$AAc@| DCB "U"
	DCB	0x0, "F", 0x0, "N", 0x0, ":", 0x0, " ", 0x0, "G", 0x0, "e"
	DCB	0x0, "t", 0x0, "T", 0x0, "o", 0x0, "t", 0x0, "a", 0x0, "l"
	DCB	0x0, "A", 0x0, "l", 0x0, "t", 0x0, "S", 0x0, "e", 0x0, "t"
	DCB	0x0, "t", 0x0, "i", 0x0, "n", 0x0, "g", 0x0, "C", 0x0, "o"
	DCB	0x0, "u", 0x0, "n", 0x0, "t", 0x0, ":", 0x0, "i", 0x0, "n"
	DCB	0x0, "c", 0x0, "o", 0x0, "n", 0x0, "s", 0x0, "i", 0x0, "s"
	DCB	0x0, "t", 0x0, "e", 0x0, "n", 0x0, "t", 0x0, " ", 0x0, "s"
	DCB	0x0, "i", 0x0, "z", 0x0, "e", 0x0, "(", 0x0, "%", 0x0, "d"
	DCB	0x0, ")", 0x0, ",", 0x0, " ", 0x0, "n", 0x0, "I", 0x0, "n"
	DCB	0x0, "t", 0x0, "e", 0x0, "r", 0x0, "f", 0x0, "a", 0x0, "c"
	DCB	0x0, "e", 0x0, "s", 0x0, "(", 0x0, "%", 0x0, "d", 0x0, ")"
	DCB	0x0, " ", 0x0, "b", 0x0, "N", 0x0, "u", 0x0, "m", 0x0, "I"
	DCB	0x0, "n", 0x0, "t", 0x0, "e", 0x0, "r", 0x0, "f", 0x0, "a"
	DCB	0x0, "c", 0x0, "e", 0x0, "s", 0x0, "(", 0x0, "%", 0x0, "d"
	DCB	0x0, ")", 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetTotalAltSettingCount| PROC

; 4221 : {

  00000		 |$LN19@GetTotalAl|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M49199|
  00004	e1a04000	 mov         r4, r0

; 4222 :     DWORD dwConfigSize;
; 4223 :     DWORD nAltSettings;
; 4224 :     DWORD nInterfaces;
; 4225 :     DWORD bPrevInterface;
; 4226 :     PUFN_INTERFACE pAltSetting;
; 4227 :     PUFN_ENDPOINT pEndpoint;
; 4228 :     DWORD epcount;
; 4229 :     DWORD dwConfigSerializedSize = pConfiguration->Descriptor.wTotalLength;
; 4230 : 
; 4231 :     // NOTE: we're only using the LOWORD of cbExtended to work with
; 4232 :     //       one audio driver that uses the HIWORD to pass parsing hints to the MDD.
; 4233 :     //       This limits the cfgextended to 64k, which is plenty.
; 4234 :     dwConfigSize = pConfiguration->Descriptor.bLength + 
; 4235 :                    LOWORD(pConfiguration->cbExtended);

  00008	e1d431b4	 ldrh        r3, [r4, #0x14]
  0000c	e5d4e006	 ldrb        lr, [r4, #6]
  00010	e5d42007	 ldrb        r2, [r4, #7]
  00014	e5d41004	 ldrb        r1, [r4, #4]

; 4236 : 
; 4237 :     if( dwConfigSize >= dwConfigSerializedSize )
; 4238 :     {
; 4239 :         // no room in serialized config for any interfaces or alt settings
; 4240 :         return 0;

  00018	e3a00000	 mov         r0, #0
  0001c	e18e8402	 orr         r8, lr, r2, lsl #8
  00020	e0837001	 add         r7, r3, r1
  00024	e1570008	 cmp         r7, r8
  00028	2a00002b	 bcs         |$LN16@GetTotalAl|

; 4241 :     }
; 4242 : 
; 4243 :     // point to first interface
; 4244 :     nAltSettings = 0;
; 4245 :     nInterfaces = 1; // we know there's at least one, as we handled the empty case above.
; 4246 :     pAltSetting = pConfiguration->pInterfaces;

  0002c	e594e018	 ldr         lr, [r4, #0x18]
  00030	e3a05001	 mov         r5, #1

; 4247 :     bPrevInterface = pAltSetting->Descriptor.bInterfaceNumber;

  00034	e5de6006	 ldrb        r6, [lr, #6]
  00038		 |$LL7@GetTotalAl|

; 4248 :     while( dwConfigSize < dwConfigSerializedSize )
; 4249 :     {
; 4250 :         // if we the interface changed from the last we saw
; 4251 :         if( pAltSetting->Descriptor.bInterfaceNumber != bPrevInterface )

  00038	e5de2006	 ldrb        r2, [lr, #6]
  0003c	e1520006	 cmp         r2, r6
  00040	0a000004	 beq         |$LN5@GetTotalAl|

; 4252 :         {
; 4253 :             ++nInterfaces; // keep interface count
; 4254 : 
; 4255 :             // check for size inconsistency
; 4256 :             if( nInterfaces > pConfiguration->Descriptor.bNumInterfaces )

  00044	e5d43008	 ldrb        r3, [r4, #8]
  00048	e2855001	 add         r5, r5, #1
  0004c	e1550003	 cmp         r5, r3
  00050	8a000015	 bhi         |$LN13@GetTotalAl|

; 4263 :             }
; 4264 :             bPrevInterface = pAltSetting->Descriptor.bInterfaceNumber;

  00054	e1a06002	 mov         r6, r2
  00058		 |$LN5@GetTotalAl|

; 4265 :         }
; 4266 : 
; 4267 :         dwConfigSize += (pAltSetting->Descriptor.bLength + pAltSetting->cbExtended);

  00058	e5de2004	 ldrb        r2, [lr, #4]
  0005c	e59e3014	 ldr         r3, [lr, #0x14]

; 4268 : 
; 4269 :         // point to first endpoint
; 4270 :         pEndpoint = pAltSetting->pEndpoints;
; 4271 :         for( epcount = 0; 
; 4272 :             epcount < pAltSetting->Descriptor.bNumEndpoints; 
; 4273 :             ++epcount )

  00060	e5de1008	 ldrb        r1, [lr, #8]
  00064	e59e9018	 ldr         r9, [lr, #0x18]
  00068	e0823003	 add         r3, r2, r3
  0006c	e0877003	 add         r7, r7, r3
  00070	e3510000	 cmp         r1, #0
  00074	0a000006	 beq         |$LN1@GetTotalAl|
  00078		 |$LL3@GetTotalAl|

; 4274 :         {
; 4275 :             dwConfigSize += 
; 4276 :                (pEndpoint->Descriptor.bLength + pEndpoint->cbExtended);

  00078	e5d93004	 ldrb        r3, [r9, #4]
  0007c	e5992010	 ldr         r2, [r9, #0x10]

; 4277 :             ++pEndpoint;

  00080	e2899014	 add         r9, r9, #0x14
  00084	e0833007	 add         r3, r3, r7
  00088	e0837002	 add         r7, r3, r2
  0008c	e2511001	 subs        r1, r1, #1
  00090	1afffff8	 bne         |$LL3@GetTotalAl|
  00094		 |$LN1@GetTotalAl|

; 4278 :         }
; 4279 : 
; 4280 :         ++nAltSettings;

  00094	e2800001	 add         r0, r0, #1

; 4281 :         ++pAltSetting;

  00098	e28ee01c	 add         lr, lr, #0x1C
  0009c	e1570008	 cmp         r7, r8
  000a0	3affffe4	 bcc         |$LL7@GetTotalAl|

; 4282 :     } // while size not matched
; 4283 : 
; 4284 :     return nAltSettings;
; 4285 : }

  000a4	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000a8	e12fff1e	 bx          lr
  000ac		 |$LN13@GetTotalAl|

; 4257 :             {
; 4258 :                 ERRORMSG(TRUE, (TEXT("UFN: GetTotalAltSettingCount:")
; 4259 :                          TEXT("inconsistent size(%d), nInterfaces(%d) bNumInterfaces(%d)"),
; 4260 :                          dwConfigSerializedSize, nInterfaces, 
; 4261 :                          (int)(pConfiguration->Descriptor.bNumInterfaces) ) );

  000ac	e59f1038	 ldr         r1, [pc, #0x38]
  000b0	e59f0030	 ldr         r0, [pc, #0x30]
  000b4	e3a03a01	 mov         r3, #1, 20
  000b8	e38320a5	 orr         r2, r3, #0xA5
  000bc	eb000000	 bl          NKDbgPrintfW
  000c0	e5d43008	 ldrb        r3, [r4, #8]
  000c4	e59f0018	 ldr         r0, [pc, #0x18]
  000c8	e1a02005	 mov         r2, r5
  000cc	e1a01008	 mov         r1, r8
  000d0	eb000000	 bl          NKDbgPrintfW
  000d4	e3a03cff	 mov         r3, #0xFF, 24

; 4262 :                 return INVALID_ALTSETTING_COUNT;

  000d8	e38300ff	 orr         r0, r3, #0xFF
  000dc		 |$LN16@GetTotalAl|

; 4282 :     } // while size not matched
; 4283 : 
; 4284 :     return nAltSettings;
; 4285 : }

  000dc	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000e0	e12fff1e	 bx          lr
  000e4		 |$LN20@GetTotalAl|
  000e4		 |$LN21@GetTotalAl|
  000e4	00000000	 DCD         |??_C@_1KO@JAHICGJ@?$AAU?$AAF?$AAN?$AA?3?$AA?5?$AAG?$AAe?$AAt?$AAT?$AAo?$AAt?$AAa?$AAl?$AAA?$AAl?$AAt?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?3?$AAi?$AAn?$AAc@|
  000e8		 |$LN22@GetTotalAl|
  000e8	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  000ec		 |$LN23@GetTotalAl|
  000ec	00000000	 DCD         |??_C@_1JO@JAGHJEHH@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  000f0		 |$M49200|

			 ENDP  ; |GetTotalAltSettingCount|

	EXPORT	|UfnPdd_DllEntry|
	IMPORT	|DisableThreadLibraryCalls|

  00000			 AREA	 |.pdata|, PDATA
|$T49217| DCD	|$LN9@UfnPdd_Dll|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_DllEntry| PROC

; 4306 : {

  00000		 |$LN9@UfnPdd_Dll|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M49214|

; 4307 : 	UNREFERENCED_PARAMETER(pReserved);
; 4308 : 
; 4309 :     switch (reason)

  00004	e3510001	 cmp         r1, #1

; 4310 :     {
; 4311 :     case DLL_PROCESS_ATTACH:
; 4312 :         DEBUGREGISTER(hDllHandle);
; 4313 :         DisableThreadLibraryCalls((HMODULE)hDllHandle);

  00008	0b000000	 bleq        DisableThreadLibraryCalls

; 4314 :         break;
; 4315 : 
; 4316 :     case DLL_PROCESS_DETACH:
; 4317 :         break;
; 4318 :     }
; 4319 : 
; 4320 :     return TRUE;

  0000c	e3a00001	 mov         r0, #1

; 4321 : }

  00010	e49de004	 ldr         lr, [sp], #4
  00014	e12fff1e	 bx          lr
  00018		 |$M49215|

			 ENDP  ; |UfnPdd_DllEntry|

	EXPORT	|UfnPdd_ContextTeardown|
	IMPORT	|LocalFree|
	IMPORT	|DeleteCriticalSection|
	IMPORT	|CloseBusAccessHandle|
	IMPORT	|MmUnmapIoSpace|
	IMPORT	|InterruptMask|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T49232| DCD	|$LN22@UfnPdd_Con@2|
	DCD	0x40004d02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\am3517\usb\usbfn\usbfnpdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_ContextTeardown| PROC

; 686  : {

  00000		 |$LN22@UfnPdd_Con@2|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M49229|
  00008	e1b04000	 movs        r4, r0

; 687  :     PRINTMSG(ZONE_FUNCTION, (L"+UfnPdd_ContextTeardown\r\n"));
; 688  : 
; 689  :     /* Teardown Sequence will be from bottom to top order */
; 690  : 
; 691  :     if (pPddContext != NULL)

  0000c	0a000044	 beq         |$LN13@UfnPdd_Con@2|

; 692  :     {
; 693  :         if (pPddContext->sysIntr)

  00010	e594302c	 ldr         r3, [r4, #0x2C]
  00014	e3a07000	 mov         r7, #0
  00018	e3530000	 cmp         r3, #0
  0001c	0a00000e	 beq         |$LN12@UfnPdd_Con@2|

; 694  :         {
; 695  :             /* Mask the Interrupt */
; 696  :             InterruptMask (pPddContext->sysIntr, TRUE);

  00020	e3a01001	 mov         r1, #1
  00024	e1a00003	 mov         r0, r3
  00028	eb000000	 bl          InterruptMask

; 697  : 
; 698  :             /* Signal the IST Thread to Stop Functioning */
; 699  : 
; 700  :             pPddContext->exitIntrThread = TRUE;
; 701  :             SetEvent (pPddContext->hIntrEvent) ;

  0002c	e5940030	 ldr         r0, [r4, #0x30]
  00030	e3a03001	 mov         r3, #1
  00034	e3a01003	 mov         r1, #3
  00038	e5843034	 str         r3, [r4, #0x34]
  0003c	eb000000	 bl          EventModify

; 702  : 
; 703  :             /* Release the SYSINTR */
; 704  :             KernelIoControl (IOCTL_HAL_RELEASE_SYSINTR, &(pPddContext->sysIntr),
; 705  :                              sizeof(DWORD), NULL, 0, NULL);

  00040	e59f00e8	 ldr         r0, [pc, #0xE8]
  00044	e3a03000	 mov         r3, #0
  00048	e3a02004	 mov         r2, #4
  0004c	e284102c	 add         r1, r4, #0x2C
  00050	e58d7004	 str         r7, [sp, #4]
  00054	e58d7000	 str         r7, [sp]
  00058	eb000000	 bl          KernelIoControl
  0005c		 |$LN12@UfnPdd_Con@2|

; 706  :         }
; 707  : 
; 708  :         if (pPddContext->hIntrEvent != NULL)

  0005c	e5943030	 ldr         r3, [r4, #0x30]
  00060	e3530000	 cmp         r3, #0

; 709  :         {
; 710  :             CloseHandle (pPddContext->hIntrEvent);

  00064	11a00003	 movne       r0, r3
  00068	1b000000	 blne        CloseHandle

; 711  :         }
; 712  : 
; 713  :         {
; 714  :         DWORD epNum;
; 715  :         for (epNum = 0; epNum < USBD_EP_COUNT; epNum++)

  0006c	e3a05000	 mov         r5, #0
  00070	e1a06004	 mov         r6, r4
  00074		 |$LL10@UfnPdd_Con@2|

; 716  :             if (pPddContext->ep[epNum].pDmaBuffer)

  00074	e59632b4	 ldr         r3, [r6, #0x2B4]
  00078	e3530000	 cmp         r3, #0

; 717  :                 DeinitEndpointDmaBuffer(pPddContext, epNum);

  0007c	11a01005	 movne       r1, r5
  00080	11a00004	 movne       r0, r4
  00084	1b000000	 blne        DeinitEndpointDmaBuffer
  00088	e2855001	 add         r5, r5, #1
  0008c	e3550010	 cmp         r5, #0x10
  00090	e286603c	 add         r6, r6, #0x3C
  00094	3afffff6	 bcc         |$LL10@UfnPdd_Con@2|

; 718  :         }
; 719  : 
; 720  :         if (pPddContext->pSysConfRegs != NULL)

  00098	e5943028	 ldr         r3, [r4, #0x28]
  0009c	e3530000	 cmp         r3, #0

; 721  :         {
; 722  :             MmUnmapIoSpace ((PVOID)pPddContext->pSysConfRegs, sizeof(*(pPddContext->pSysConfRegs)));

  000a0	13a01ea6	 movne       r1, #0xA6, 28
  000a4	11a00003	 movne       r0, r3
  000a8	1b000000	 blne        MmUnmapIoSpace

; 723  :         }
; 724  : 
; 725  :         if (pPddContext->pUsbPhyReset != NULL)

  000ac	e5943024	 ldr         r3, [r4, #0x24]
  000b0	e3530000	 cmp         r3, #0

; 726  :         {
; 727  :             MmUnmapIoSpace ((PVOID)pPddContext->pUsbPhyReset, sizeof(pPddContext->pUsbPhyReset));

  000b4	13a01004	 movne       r1, #4
  000b8	11a00003	 movne       r0, r3
  000bc	1b000000	 blne        MmUnmapIoSpace

; 728  :         }
; 729  : 
; 730  :         if (pPddContext->pCppiRegs != NULL)

  000c0	e5943020	 ldr         r3, [r4, #0x20]
  000c4	e3530000	 cmp         r3, #0

; 731  :         {
; 732  :             MmUnmapIoSpace (pPddContext->pCppiRegs, sizeof(*(pPddContext->pCppiRegs)));

  000c8	13a01c5e	 movne       r1, #0x5E, 24
  000cc	11a00003	 movne       r0, r3
  000d0	1b000000	 blne        MmUnmapIoSpace

; 733  :         }
; 734  : 
; 735  :         if (pPddContext->pUsbdRegs != NULL)

  000d4	e594301c	 ldr         r3, [r4, #0x1C]
  000d8	e3530000	 cmp         r3, #0
  000dc	13a02b02	 movne       r2, #2, 22

; 736  :         {
; 737  :             MmUnmapIoSpace (pPddContext->pUsbdRegs, sizeof(*(pPddContext->pUsbdRegs)));

  000e0	13821018	 orrne       r1, r2, #0x18
  000e4	11a00003	 movne       r0, r3
  000e8	1b000000	 blne        MmUnmapIoSpace

; 738  :         }
; 739  : 
; 740  :         if (pPddContext->parentBus != NULL)

  000ec	e5943018	 ldr         r3, [r4, #0x18]
  000f0	e3530000	 cmp         r3, #0

; 741  :         {
; 742  :             CloseBusAccessHandle (pPddContext->parentBus);

  000f4	11a00003	 movne       r0, r3
  000f8	1b000000	 blne        CloseBusAccessHandle

; 743  :         }
; 744  : 
; 745  :         if (pPddContext->hActivityEvent)

  000fc	e5943254	 ldr         r3, [r4, #0x254]
  00100	e3530000	 cmp         r3, #0
  00104	0a000002	 beq         |$LN1@UfnPdd_Con@2|

; 746  :         {
; 747  :             CloseHandle(pPddContext->hActivityEvent);

  00108	e1a00003	 mov         r0, r3
  0010c	eb000000	 bl          CloseHandle

; 748  :             pPddContext->hActivityEvent = NULL;

  00110	e5847254	 str         r7, [r4, #0x254]
  00114		 |$LN1@UfnPdd_Con@2|

; 749  :         }
; 750  : 
; 751  :         /* Last one in the Sequence */
; 752  :         DeleteCriticalSection (&pPddContext->epCS);

  00114	e2840e27	 add         r0, r4, #0x27, 28
  00118	eb000000	 bl          DeleteCriticalSection

; 753  :         LocalFree (pPddContext);

  0011c	e1a00004	 mov         r0, r4
  00120	eb000000	 bl          LocalFree
  00124		 |$LN13@UfnPdd_Con@2|

; 754  :     }
; 755  :     PRINTMSG(ZONE_FUNCTION, (L"-UfnPdd_ContextTeardown\r\n"));
; 756  : }

  00124	e28dd008	 add         sp, sp, #8
  00128	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0012c	e12fff1e	 bx          lr
  00130		 |$LN23@UfnPdd_Con@2|
  00130		 |$LN24@UfnPdd_Con@2|
  00130	010100d8	 DCD         0x10100d8
  00134		 |$M49230|

			 ENDP  ; |UfnPdd_ContextTeardown|

	EXPORT	|UfnPdd_Deinit|
	EXPORT	|??_C@_1HI@KGLFLGAN@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAd?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAw?$AAa?$AAi?$AAt?$AAi?$AAn?$AAg@| [ DATA ] ; `string'
	IMPORT	|cppiControllerDeinit|
	IMPORT	|GetTickCount|

  00000			 AREA	 |.pdata|, PDATA
|$T49250| DCD	|$LN16@UfnPdd_Dei|
	DCD	0x40002701

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HI@KGLFLGAN@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAd?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAw?$AAa?$AAi?$AAt?$AAi?$AAn?$AAg@| DCB "U"
	DCB	0x0, "f", 0x0, "n", 0x0, "P", 0x0, "d", 0x0, "d", 0x0, "_"
	DCB	0x0, "D", 0x0, "e", 0x0, "i", 0x0, "n", 0x0, "i", 0x0, "t"
	DCB	0x0, ":", 0x0, " ", 0x0, "t", 0x0, "i", 0x0, "m", 0x0, "e"
	DCB	0x0, "d", 0x0, " ", 0x0, "o", 0x0, "u", 0x0, "t", 0x0, " "
	DCB	0x0, "w", 0x0, "a", 0x0, "i", 0x0, "t", 0x0, "i", 0x0, "n"
	DCB	0x0, "g", 0x0, " ", 0x0, "f", 0x0, "o", 0x0, "r", 0x0, " "
	DCB	0x0, "e", 0x0, "n", 0x0, "d", 0x0, "p", 0x0, "o", 0x0, "i"
	DCB	0x0, "n", 0x0, "t", 0x0, "s", 0x0, " ", 0x0, "t", 0x0, "o"
	DCB	0x0, " ", 0x0, "g", 0x0, "o", 0x0, " ", 0x0, "i", 0x0, "d"
	DCB	0x0, "l", 0x0, "e", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_Deinit| PROC

; 2931 : {

  00000		 |$LN16@UfnPdd_Dei|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M49247|
  00004	e1a05000	 mov         r5, r0

; 2932 :     DWORD rc = ERROR_SUCCESS;
; 2933 :     BOOL endpointsNotIdle = TRUE;

  00008	e3a04001	 mov         r4, #1

; 2934 :     DWORD tc0 = GetTickCount();

  0000c	eb000000	 bl          GetTickCount
  00010	e3a03c13	 mov         r3, #0x13, 24
  00014	e3837088	 orr         r7, r3, #0x88
  00018	e1a06000	 mov         r6, r0
  0001c		 |$LL7@UfnPdd_Dei|

; 2935 :     DWORD endpoint;
; 2936 : 
; 2937 :     USBFNPDDCONTEXT *pPdd = (USBFNPDDCONTEXT *)pPddContext;
; 2938 : 
; 2939 :     DEBUGCHK(pPddContext != NULL);
; 2940 : 
; 2941 :     // Wait for endpoints to go into idle state before completing Deinit
; 2942 :     PRINTMSG(ZONE_FUNCTION, (L"UfnPdd_Deinit: waiting for endpoints to go idle\r\n"));
; 2943 :     while((endpointsNotIdle && ((GetTickCount() - tc0) < 5000)))

  0001c	eb000000	 bl          GetTickCount
  00020	e0403006	 sub         r3, r0, r6
  00024	e1530007	 cmp         r3, r7
  00028	2a00000e	 bcs         |$LN6@UfnPdd_Dei|

; 2944 :     {
; 2945 :         // reset flag
; 2946 :         endpointsNotIdle = FALSE;

  0002c	e3a04000	 mov         r4, #0
  00030	e1a02005	 mov         r2, r5
  00034	e3a01010	 mov         r1, #0x10
  00038		 |$LL5@UfnPdd_Dei|

; 2947 : 
; 2948 :         // look for endpoint status
; 2949 :         for(endpoint = 0; endpoint < USBD_EP_COUNT; endpoint++)
; 2950 :         {
; 2951 :             // only poll endpoints that have been initialised
; 2952 :             if((pPdd->ep[endpoint].epInitialised)&&
; 2953 :                (pPdd->ep[endpoint].epStage != MGC_END0_START))

  00038	e5923288	 ldr         r3, [r2, #0x288]
  0003c	e3530000	 cmp         r3, #0
  00040	159232a0	 ldrne       r3, [r2, #0x2A0]
  00044	e282203c	 add         r2, r2, #0x3C
  00048	13530001	 cmpne       r3, #1

; 2954 :             {
; 2955 :                 PRINTMSG(ZONE_FUNCTION, (L"UfnPdd_Deinit: endpoint %d in state %d (not idle!)\r\n",
; 2956 :                     endpoint, pPdd->ep[endpoint].epStage));
; 2957 :                 endpointsNotIdle = TRUE;

  0004c	13a04001	 movne       r4, #1
  00050	e2511001	 subs        r1, r1, #1
  00054	1afffff7	 bne         |$LL5@UfnPdd_Dei|

; 2958 :             }
; 2959 :         }
; 2960 : 
; 2961 :         // wait before polling again
; 2962 :         Sleep(10);

  00058	e3a0000a	 mov         r0, #0xA
  0005c	eb000000	 bl          Sleep
  00060	e3540000	 cmp         r4, #0
  00064	1affffec	 bne         |$LL7@UfnPdd_Dei|
  00068		 |$LN6@UfnPdd_Dei|

; 2963 :     }
; 2964 : 
; 2965 :     if(endpointsNotIdle)

  00068	e3540000	 cmp         r4, #0

; 2966 :     {
; 2967 :         // timed out waiting for endpoints to go idle
; 2968 :         PRINTMSG(ZONE_ERROR, (L"UfnPdd_Deinit: timed out waiting for endpoints to go idle\r\n"));

  0006c	159f0024	 ldrne       r0, [pc, #0x24]
  00070	1b000000	 blne        NKDbgPrintfW

; 2969 :     }
; 2970 : 
; 2971 : #ifdef CPPI_DMA_SUPPORT
; 2972 : 
; 2973 :     /* Deinitialize the DMA Controller Object */
; 2974 :     cppiControllerDeinit(pPdd);

  00074	e1a00005	 mov         r0, r5
  00078	eb000000	 bl          cppiControllerDeinit

; 2975 :     pPdd->pDmaCntrl = NULL;

  0007c	e3a03000	 mov         r3, #0

; 2976 : 
; 2977 : #endif /* #ifdef CPPI_DMA_SUPPORT *
; 2978 : 
; 2979 :     /* Perform the De-initialization */
; 2980 :     UfnPdd_ContextTeardown(pPdd);

  00080	e1a00005	 mov         r0, r5
  00084	e585365c	 str         r3, [r5, #0x65C]
  00088	eb000000	 bl          UfnPdd_ContextTeardown

; 2981 : 
; 2982 :     PRINTMSG(ZONE_FUNCTION, (L"UfnPdd_Deinit:\r\n"));
; 2983 : 
; 2984 :     return rc;

  0008c	e3a00000	 mov         r0, #0

; 2985 : 
; 2986 : }

  00090	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00094	e12fff1e	 bx          lr
  00098		 |$LN17@UfnPdd_Dei|
  00098		 |$LN18@UfnPdd_Dei|
  00098	00000000	 DCD         |??_C@_1HI@KGLFLGAN@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAd?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAw?$AAa?$AAi?$AAt?$AAi?$AAn?$AAg@|
  0009c		 |$M49248|

			 ENDP  ; |UfnPdd_Deinit|

	EXPORT	|UfnPdd_DeinitEndpoint|

  00000			 AREA	 |.pdata|, PDATA
|$T49270| DCD	|$LN10@UfnPdd_Dei@2|
	DCD	0x40003901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_DeinitEndpoint| PROC

; 3129 : {

  00000		 |$LN10@UfnPdd_Dei@2|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M49267|
  00004	e1a06001	 mov         r6, r1
  00008	e1a05000	 mov         r5, r0

; 3130 :     DWORD rc = ERROR_SUCCESS;
; 3131 :     DWORD intrRegVal = 0;
; 3132 : 
; 3133 :     UINT16      epCsrReg = 0;
; 3134 :     USBFNPDDCONTEXT *pPdd = (USBFNPDDCONTEXT *)pvPddContext;
; 3135 :     CSL_UsbRegs     *pUsbdRegs = pPdd->pUsbdRegs;
; 3136 : 
; 3137 : #ifdef CPPI_DMA_SUPPORT
; 3138 :     struct dma_controller *pDma   = (struct dma_controller *)pPdd->pDmaCntrl;
; 3139 :     struct cppi_channel *pDmaChan = (struct cppi_channel *)
; 3140 :                                     pPdd->ep[endpoint].pDmaChan;

  0000c	e0663206	 rsb         r3, r6, r6, lsl #4
  00010	e0854103	 add         r4, r5, r3, lsl #2

; 3141 : #endif /* #ifdef CPPI_DMA_SUPPORT */
; 3142 : 
; 3143 :     PRINTMSG(ZONE_FUNCTION, /*TRUE, */
; 3144 :             (L"UfnPdd_DeinitEndpoint: %d\r\n", endpoint));
; 3145 : 
; 3146 :     DEBUGCHK(endpoint < USBD_EP_COUNT);
; 3147 : 
; 3148 :     LOCK_ENDPOINT (pPdd);

  00014	e59482b0	 ldr         r8, [r4, #0x2B0]
  00018	e595701c	 ldr         r7, [r5, #0x1C]
  0001c	e595965c	 ldr         r9, [r5, #0x65C]
  00020	e2850e27	 add         r0, r5, #0x27, 28
  00024	eb000000	 bl          EnterCriticalSection

; 3149 : 
; 3150 :     /* Check which EndPoint is it */
; 3151 :     if (endpoint == 0)

  00028	e3560000	 cmp         r6, #0

; 3152 :     {
; 3153 :         /* For EndPoint Zero, Abort the Current Transfer by setting
; 3154 :          * up the ServRxPktRdy and the SetupEnd Bits
; 3155 :          */
; 3156 :         epCsrReg = pUsbdRegs->EPCSR[ endpoint ].PERI_TXCSR;

  0002c	02872c05	 addeq       r2, r7, #5, 24
  00030	01d230b2	 ldreqh      r3, [r2, #2]
  00034	e3a0a000	 mov         r10, #0

; 3157 :         epCsrReg |= (MGC_M_CSR0_P_SVDSETUPEND | MGC_M_CSR0_P_SVDRXPKTRDY);
; 3158 :         pUsbdRegs->EPCSR[ endpoint ].PERI_TXCSR = epCsrReg;
; 3159 :         intrRegVal |= (1 << endpoint) << USB_OTG_TXINT_SHIFT;

  00038	03a06001	 moveq       r6, #1
  0003c	038330c0	 orreq       r3, r3, #0xC0
  00040	01c230b2	 streqh      r3, [r2, #2]

; 3160 :         pPdd->fWaitingForHandshake = FALSE;

  00044	0585a64c	 streq       r10, [r5, #0x64C]
  00048	0a000019	 beq         |$LN1@UfnPdd_Dei@2|

; 3161 :     }
; 3162 :     else
; 3163 :     {
; 3164 : #ifdef CPPI_DMA_SUPPORT
; 3165 :         DeinitEndpointDmaBuffer(pPdd, endpoint);

  0004c	e1a01006	 mov         r1, r6
  00050	e1a00005	 mov         r0, r5
  00054	eb000000	 bl          DeinitEndpointDmaBuffer

; 3166 : #endif
; 3167 : 
; 3168 :         if (pPdd->ep[endpoint].dirRx == FALSE)

  00058	e5943294	 ldr         r3, [r4, #0x294]
  0005c	e3530000	 cmp         r3, #0

; 3169 :         {
; 3170 :             epCsrReg = pUsbdRegs->EPCSR[ endpoint ].PERI_TXCSR;

  00060	e0873206	 add         r3, r7, r6, lsl #4
  00064	02832c05	 addeq       r2, r3, #5, 24
  00068	01d230b2	 ldreqh      r3, [r2, #2]

; 3171 :             epCsrReg |= MGC_M_TXCSR_FLUSHFIFO;
; 3172 :             pUsbdRegs->EPCSR[ endpoint ].PERI_TXCSR = epCsrReg;
; 3173 :             intrRegVal |= (1 << endpoint) << USB_OTG_TXINT_SHIFT;

  0006c	03a01001	 moveq       r1, #1
  00070	01a06611	 moveq       r6, r1, lsl r6
  00074	03833008	 orreq       r3, r3, #8

; 3174 :         }
; 3175 :         else
; 3176 :         {
; 3177 :             epCsrReg = pUsbdRegs->EPCSR[ endpoint ].PERI_RXCSR;

  00078	12831c05	 addne       r1, r3, #5, 24
  0007c	01c230b2	 streqh      r3, [r2, #2]
  00080	11d130b6	 ldrneh      r3, [r1, #6]

; 3178 :             epCsrReg |= MGC_M_RXCSR_FLUSHFIFO;
; 3179 :             pUsbdRegs->EPCSR[ endpoint ].PERI_RXCSR = epCsrReg;
; 3180 :             intrRegVal |= (1 << endpoint) << USB_OTG_RXINT_SHIFT;

  00084	13a02001	 movne       r2, #1
  00088	11a02612	 movne       r2, r2, lsl r6
  0008c	13833010	 orrne       r3, r3, #0x10
  00090	11c130b6	 strneh      r3, [r1, #6]
  00094	11a06802	 movne       r6, r2, lsl #16

; 3181 :         }
; 3182 : 
; 3183 : #ifdef CPPI_DMA_SUPPORT
; 3184 :         /* Try Releasing the Allocated CPPI DMA Channel */
; 3185 :         if ((endpoint != 0) && (pDmaChan != NULL))

  00098	e3580000	 cmp         r8, #0
  0009c	0a000004	 beq         |$LN1@UfnPdd_Dei@2|

; 3186 :         {
; 3187 :             pDma->pfnChannelRelease ((struct dma_channel *)pDmaChan);

  000a0	e599300c	 ldr         r3, [r9, #0xC]
  000a4	e1a00008	 mov         r0, r8
  000a8	e1a0e00f	 mov         lr, pc
  000ac	e12fff13	 bx          r3

; 3188 :             pPdd->ep[endpoint].pDmaChan = NULL;

  000b0	e584a2b0	 str         r10, [r4, #0x2B0]
  000b4		 |$LN1@UfnPdd_Dei@2|

; 3189 :         }
; 3190 : #endif /* #ifdef CPPI_DMA_SUPPORT */
; 3191 :     }
; 3192 : 
; 3193 :     /* Disable the interrupts for this EndPoint */
; 3194 :     pUsbdRegs->EP_INTMSKCLRR = intrRegVal;
; 3195 : 
; 3196 :     /* Now Update the Status Vars of this EP */
; 3197 :     pPdd->ep[endpoint].epStage   = MGC_END0_START;

  000b4	e3a03001	 mov         r3, #1
  000b8	e5876034	 str         r6, [r7, #0x34]

; 3198 :     pPdd->ep[endpoint].pTransfer = NULL;
; 3199 :     pPdd->ep[endpoint].epInitialised = FALSE;
; 3200 : 
; 3201 :     UNLOCK_ENDPOINT (pPdd);

  000bc	e2850e27	 add         r0, r5, #0x27, 28
  000c0	e58432a0	 str         r3, [r4, #0x2A0]
  000c4	e584a2a4	 str         r10, [r4, #0x2A4]
  000c8	e584a288	 str         r10, [r4, #0x288]
  000cc	eb000000	 bl          LeaveCriticalSection

; 3202 : 
; 3203 :     /* Allow things to settle before EP is re-initialised */
; 3204 :     Sleep(20);

  000d0	e3a00014	 mov         r0, #0x14
  000d4	eb000000	 bl          Sleep

; 3205 : 
; 3206 :     return (rc);

  000d8	e3a00000	 mov         r0, #0

; 3207 : }

  000dc	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  000e0	e12fff1e	 bx          lr
  000e4		 |$M49268|

			 ENDP  ; |UfnPdd_DeinitEndpoint|

	EXPORT	|UfnPdd_InitEndpoint|
	EXPORT	|??_C@_1HM@BENODFNJ@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?3?$AA?5?$AAE?$AAP?$AA?$CF?$AAu?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?0@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T49319| DCD	|$LN36@UfnPdd_Ini@2|
	DCD	0x4000ae02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HM@BENODFNJ@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?3?$AA?5?$AAE?$AAP?$AA?$CF?$AAu?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?0@| DCB "U"
	DCB	0x0, "f", 0x0, "n", 0x0, "P", 0x0, "d", 0x0, "d", 0x0, "_"
	DCB	0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, "E", 0x0, "n"
	DCB	0x0, "d", 0x0, "p", 0x0, "o", 0x0, "i", 0x0, "n", 0x0, "t"
	DCB	0x0, ":", 0x0, " ", 0x0, "E", 0x0, "P", 0x0, "%", 0x0, "u"
	DCB	0x0, " ", 0x0, "E", 0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r"
	DCB	0x0, ",", 0x0, " ", 0x0, "F", 0x0, "I", 0x0, "F", 0x0, "O"
	DCB	0x0, " ", 0x0, "o", 0x0, "f", 0x0, "f", 0x0, "s", 0x0, "e"
	DCB	0x0, "t", 0x0, " ", 0x0, "n", 0x0, "o", 0x0, "t", 0x0, " "
	DCB	0x0, "d", 0x0, "e", 0x0, "t", 0x0, "e", 0x0, "r", 0x0, "m"
	DCB	0x0, "i", 0x0, "n", 0x0, "e", 0x0, "d", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_InitEndpoint| PROC

; 3251 : {

  00000		 |$LN36@UfnPdd_Ini@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M49316|
  00008	e1a05001	 mov         r5, r1
  0000c	e1a07000	 mov         r7, r0

; 3252 :     DWORD rc                      = ERROR_SUCCESS;
; 3253 :     USBFNPDDCONTEXT *pPdd         = (USBFNPDDCONTEXT *)pvPddContext;
; 3254 :     CSL_UsbRegs     *pUsbdRegs    = pPdd->pUsbdRegs;
; 3255 :     UINT8           fifoSz        = 0;
; 3256 :     UINT8           epAddress     = 0;
; 3257 :     USHORT          epMaxPktSize  = 0;
; 3258 :     UINT16          epRegVal      = 0;
; 3259 :     volatile UINT16 *pepCsrReg    = NULL;
; 3260 :     BYTE            transferType  = 0;
; 3261 :     BOOL            modeOut		  = FALSE;
; 3262 :     DWORD           intrRegVal    = 0;
; 3263 : 
; 3264 : #ifdef DEBUG
; 3265 : 	SETFNAME();
; 3266 :     FUNCTION_ENTER_MSG();
; 3267 : #endif
; 3268 : 
; 3269 : 	UNREFERENCED_PARAMETER(alternateSetting);
; 3270 : 	UNREFERENCED_PARAMETER(interfaceNumber);
; 3271 : 	UNREFERENCED_PARAMETER(configurationValue);
; 3272 : 	UNREFERENCED_PARAMETER(pvReserved);
; 3273 : 	UNREFERENCED_PARAMETER(speed);
; 3274 : 
; 3275 :     /* Get Information from the given EndPoint Descriptor Struct */
; 3276 :     epAddress    = pEndpointDesc->bEndpointAddress;
; 3277 :     epMaxPktSize = (pEndpointDesc->wMaxPacketSize &
; 3278 :                     USB_ENDPOINT_MAX_PACKET_SIZE_MASK);

  00010	e5d3e004	 ldrb        lr, [r3, #4]
  00014	e5d32005	 ldrb        r2, [r3, #5]

; 3279 :     transferType = pEndpointDesc->bmAttributes & USB_ENDPOINT_TYPE_MASK;

  00018	e5d34003	 ldrb        r4, [r3, #3]

; 3280 :     intrRegVal = 0;
; 3281 : 
; 3282 :     PRINTMSG(ZONE_PDD_INIT,
; 3283 :              (L"+UfnPdd_InitEndpoint EP%u PktSize 0x%x Type 0x%x ADDR 0x%x, Speed 0x%x\r\n",
; 3284 :               endpoint, epMaxPktSize, transferType, epAddress, speed));
; 3285 : 
; 3286 :     /* Must power up when an EP is initialised */
; 3287 :     if ((pPdd->currentPowerState == D3) || (pPdd->currentPowerState == D4))

  0001c	e3a00c07	 mov         r0, #7, 24
  00020	e18ee402	 orr         lr, lr, r2, lsl #8
  00024	e5971048	 ldr         r1, [r7, #0x48]
  00028	e38020ff	 orr         r2, r0, #0xFF
  0002c	e00e6002	 and         r6, lr, r2
  00030	e204e003	 and         lr, r4, #3
  00034	e597901c	 ldr         r9, [r7, #0x1C]
  00038	e5d38002	 ldrb        r8, [r3, #2]
  0003c	e5cde000	 strb        lr, [sp]
  00040	e3a0a000	 mov         r10, #0
  00044	e3510003	 cmp         r1, #3
  00048	0a000001	 beq         |$LN14@UfnPdd_Ini@2|
  0004c	e3510004	 cmp         r1, #4
  00050	1a000003	 bne         |$LN15@UfnPdd_Ini@2|
  00054		 |$LN14@UfnPdd_Ini@2|

; 3288 :     {
; 3289 :         SetPowerState(pPdd, D0);

  00054	e3a01000	 mov         r1, #0
  00058	e1a00007	 mov         r0, r7
  0005c	eb000000	 bl          SetPowerState
  00060	e5dde000	 ldrb        lr, [sp]
  00064		 |$LN15@UfnPdd_Ini@2|

; 3290 :     }
; 3291 : 
; 3292 :     /* Convert the MaxPktSize to the USB Controller Convention
; 3293 :      * Maximum packet size to be allowed (before any splitting within the
; 3294 :      * FIFO of Bulk packets prior to transmission). If m = SZ[3:0], the
; 3295 :      * FIFO size is calculated as 2^(m+3) for single packet buffering and
; 3296 :      * 2^(m+4) for dual packet buffering.
; 3297 :      */
; 3298 :     fifoSz = (UINT8) Log2(epMaxPktSize) - 3;

  00064	e1b02006	 movs        r2, r6
  00068	e3a03000	 mov         r3, #0
  0006c	0a000004	 beq         |$LN24@UfnPdd_Ini@2|
  00070		 |$LL26@UfnPdd_Ini@2|
  00070	e1b020a2	 movs        r2, r2, lsr #1
  00074	e2833001	 add         r3, r3, #1
  00078	1afffffc	 bne         |$LL26@UfnPdd_Ini@2|
  0007c	e3530000	 cmp         r3, #0
  00080	12433001	 subne       r3, r3, #1
  00084		 |$LN24@UfnPdd_Ini@2|

; 3299 : 
; 3300 : 
; 3301 :     // Get access to the indexed regs
; 3302 :     pUsbdRegs->INDEX = (UINT8)endpoint;

  00084	e5c9540e	 strb        r5, [r9, #0x40E]
  00088	e283b0fd	 add         r11, r3, #0xFD

; 3303 : 
; 3304 :     /* Select EP */
; 3305 :     if (endpoint != 0)

  0008c	e3550000	 cmp         r5, #0
  00090	0a000055	 beq         |$LN13@UfnPdd_Ini@2|

; 3306 :     {
; 3307 :         DEBUGCHK(endpoint < USBD_EP_COUNT);
; 3308 : 
; 3309 :         /* Check that FIFO offset has been determined in UfnPdd_RegisterDevice() */
; 3310 :         if (pPdd->ep[endpoint].fifoOffset == 0)

  00094	e0653205	 rsb         r3, r5, r5, lsl #4
  00098	e0874103	 add         r4, r7, r3, lsl #2
  0009c	e2843c02	 add         r3, r4, #2, 24
  000a0	e1d338be	 ldrh        r3, [r3, #0x8E]
  000a4	e3530000	 cmp         r3, #0
  000a8	1a000009	 bne         |$LN12@UfnPdd_Ini@2|

; 3311 :         {
; 3312 :             ERRORMSG(TRUE, (L"UfnPdd_InitEndpoint: EP%u Error, FIFO offset not determined\r\n",
; 3313 :                             endpoint));

  000ac	e59f1200	 ldr         r1, [pc, #0x200]
  000b0	e59f01f8	 ldr         r0, [pc, #0x1F8]
  000b4	e3a03b03	 mov         r3, #3, 22
  000b8	e38320f1	 orr         r2, r3, #0xF1
  000bc	eb000000	 bl          NKDbgPrintfW
  000c0	e59f01e4	 ldr         r0, [pc, #0x1E4]
  000c4	e1a01005	 mov         r1, r5
  000c8	eb000000	 bl          NKDbgPrintfW

; 3314 :             rc = ERROR_INVALID_PARAMETER;

  000cc	e3a03057	 mov         r3, #0x57

; 3315 :             goto Exit;

  000d0	ea00006f	 b           |$Exit$47953|
  000d4		 |$LN12@UfnPdd_Ini@2|

; 3316 :         }
; 3317 : 
; 3318 :         /* Setup Direction (mode_in bit)  */
; 3319 : 
; 3320 :         /* If Bit7 of the EP Address is not set, then it is Host to Device
; 3321 :          * The macro USB_ENDPOINT_DIRECTION_OUT from usb100.h checks for
; 3322 :          * bit 7 not set. Hence this EndPoint is Receive for us.
; 3323 :          */
; 3324 :         modeOut = USB_ENDPOINT_DIRECTION_OUT(epAddress);

  000d4	e3180080	 tst         r8, #0x80

; 3325 : 
; 3326 :         pPdd->ep[endpoint].maxPacketSize = epMaxPktSize;

  000d8	e2843c02	 add         r3, r4, #2, 24
  000dc	03a0a001	 moveq       r10, #1

; 3327 :         pPdd->ep[endpoint].endpointType  = transferType;
; 3328 : 
; 3329 : #ifdef CPPI_DMA_SUPPORT
; 3330 :         InitEndpointDmaBuffer(pPdd, endpoint);

  000e0	e1a01005	 mov         r1, r5
  000e4	e1a00007	 mov         r0, r7
  000e8	13a0a000	 movne       r10, #0
  000ec	e1c368bc	 strh        r6, [r3, #0x8C]
  000f0	e5c4e290	 strb        lr, [r4, #0x290]
  000f4	eb000000	 bl          InitEndpointDmaBuffer

; 3331 : #endif
; 3332 : 
; 3333 :         // Clear any previous setup
; 3334 :         pUsbdRegs->TXMAXP = 0;
; 3335 :         pUsbdRegs->TXFIFOSZ = 0;

  000f8	e2890e41	 add         r0, r9, #0x41, 28

; 3336 :         pUsbdRegs->RXMAXP = 0;

  000fc	e3a08000	 mov         r8, #0

; 3337 :         pUsbdRegs->RXFIFOSZ = 0;

  00100	e1c080b0	 strh        r8, [r0]
  00104	e2892b01	 add         r2, r9, #1, 22
  00108	e5c98462	 strb        r8, [r9, #0x462]
  0010c	e1c281b4	 strh        r8, [r2, #0x14]
  00110	e5c98463	 strb        r8, [r9, #0x463]

; 3338 : 
; 3339 :         if (modeOut == TRUE) // RX endpoint

  00114	e35a0001	 cmp         r10, #1

; 3340 :         {
; 3341 :             // Max packet and FIFO size
; 3342 : 
; 3343 :             pUsbdRegs->RXMAXP = epMaxPktSize;
; 3344 :             pUsbdRegs->RXFIFOSZ = fifoSz;
; 3345 : 
; 3346 :             pepCsrReg = &pUsbdRegs->PERI_RXCSR;

  00118	e2893b01	 add         r3, r9, #1, 22
  0011c	1a000016	 bne         |$LN11@UfnPdd_Ini@2|
  00120	e2831016	 add         r1, r3, #0x16
  00124	e1c261b4	 strh        r6, [r2, #0x14]
  00128	e5c9b463	 strb        r11, [r9, #0x463]

; 3347 : 
; 3348 :             epRegVal = (*pepCsrReg);

  0012c	e1d120b0	 ldrh        r2, [r1]

; 3349 :             epRegVal &= ~(MGC_M_RXCSR_AUTOCLEAR | MGC_M_RXCSR_DMAMODE);
; 3350 :             epRegVal |= (MGC_M_RXCSR_CLRDATATOG | MGC_M_RXCSR_FLUSHFIFO);
; 3351 :             if (transferType == USB_ENDPOINT_TYPE_INTERRUPT)

  00130	e5dd0000	 ldrb        r0, [sp]
  00134	e3a03c77	 mov         r3, #0x77, 24
  00138	e383306f	 orr         r3, r3, #0x6F
  0013c	e0023003	 and         r3, r2, r3
  00140	e3500003	 cmp         r0, #3
  00144	e3832090	 orr         r2, r3, #0x90

; 3352 :                 epRegVal |= MGC_M_RXCSR_DISNYET;
; 3353 :             else

  00148	13a03cef	 movne       r3, #0xEF, 24

; 3354 :                 epRegVal &= ~MGC_M_RXCSR_DISNYET;

  0014c	138330ff	 orrne       r3, r3, #0xFF
  00150	03822a01	 orreq       r2, r2, #1, 20
  00154	10022003	 andne       r2, r2, r3

; 3355 :             (*pepCsrReg) = epRegVal;
; 3356 : 
; 3357 :             pUsbdRegs->RXFIFOADDR = (UINT16)(pPdd->ep[endpoint].fifoOffset >> 3);

  00158	e2843c02	 add         r3, r4, #2, 24
  0015c	e1c120b0	 strh        r2, [r1]
  00160	e1d338be	 ldrh        r3, [r3, #0x8E]
  00164	e2892b01	 add         r2, r9, #1, 22
  00168	e1a031a3	 mov         r3, r3, lsr #3
  0016c	e1c236b6	 strh        r3, [r2, #0x66]

; 3358 :             pPdd->ep[endpoint].dirRx = TRUE;

  00170	e3a03001	 mov         r3, #1
  00174	e5843294	 str         r3, [r4, #0x294]

; 3359 : 
; 3360 :             // RX interrupt is enabled only when a transfer is issued by MDD.
; 3361 :             // We do not want to handle the RX interrupt before we have a
; 3362 :             // transfer structure to receive data into.
; 3363 :             intrRegVal = 0;
; 3364 :         }
; 3365 :         else // TX endpoint

  00178	ea00000e	 b           |$LN32@UfnPdd_Ini@2|
  0017c		 |$LN11@UfnPdd_Ini@2|

; 3366 :         {
; 3367 :             // Max packet and FIFO size
; 3368 : 
; 3369 :             pUsbdRegs->TXMAXP = epMaxPktSize;
; 3370 :             pUsbdRegs->TXFIFOSZ = fifoSz;
; 3371 : 
; 3372 :             pepCsrReg = &pUsbdRegs->PERI_TXCSR;

  0017c	e2831012	 add         r1, r3, #0x12
  00180	e1c060b0	 strh        r6, [r0]
  00184	e5c9b462	 strb        r11, [r9, #0x462]

; 3373 :             epRegVal = (*pepCsrReg);

  00188	e1d120b0	 ldrh        r2, [r1]
  0018c	e3a03a02	 mov         r3, #2, 20

; 3374 :             epRegVal |= (MGC_M_TXCSR_MODE | MGC_M_TXCSR_CLRDATATOG |
; 3375 :                          MGC_M_TXCSR_FLUSHFIFO);

  00190	e3833048	 orr         r3, r3, #0x48
  00194	e1823003	 orr         r3, r2, r3

; 3376 : 
; 3377 :             /* Write into the PERI_TXCSR Register to set it as TX EP */
; 3378 :             (*pepCsrReg) = epRegVal;

  00198	e1c130b0	 strh        r3, [r1]

; 3379 : 
; 3380 :             pUsbdRegs->TXFIFOADDR = (UINT16)(pPdd->ep[endpoint].fifoOffset >> 3);

  0019c	e2843c02	 add         r3, r4, #2, 24
  001a0	e1d338be	 ldrh        r3, [r3, #0x8E]
  001a4	e2892b01	 add         r2, r9, #1, 22
  001a8	e5dd0000	 ldrb        r0, [sp]
  001ac	e1a031a3	 mov         r3, r3, lsr #3
  001b0	e1c236b4	 strh        r3, [r2, #0x64]

; 3381 :             pPdd->ep[endpoint].dirRx = FALSE;

  001b4	e5848294	 str         r8, [r4, #0x294]
  001b8		 |$LN32@UfnPdd_Ini@2|

; 3382 : 
; 3383 :             // TX interrupt is enabled for non-DMA
; 3384 : #ifndef CPPI_DMA_SUPPORT
; 3385 :             intrRegVal = (1 << endpoint) << USB_OTG_TXINT_SHIFT;
; 3386 : #else
; 3387 :             intrRegVal = 0;
; 3388 : #endif
; 3389 :         }
; 3390 : 
; 3391 :         /* Set Transfer Type */
; 3392 :         DEBUGCHK(transferType != USB_ENDPOINT_TYPE_CONTROL);
; 3393 :         switch(transferType)

  001b8	e3500001	 cmp         r0, #1

; 3394 :         {
; 3395 :         case USB_ENDPOINT_TYPE_ISOCHRONOUS:
; 3396 :             /* Set the ISO bit */
; 3397 :             epRegVal = (*pepCsrReg);
; 3398 :             epRegVal |= BIT14;
; 3399 :             (*pepCsrReg) = epRegVal;
; 3400 :             break;
; 3401 :         case USB_ENDPOINT_TYPE_BULK:
; 3402 :         case USB_ENDPOINT_TYPE_INTERRUPT:
; 3403 :         default:
; 3404 :             /* Clear ISO bit - Set type to Bulk */
; 3405 :             epRegVal = (*pepCsrReg);

  001bc	11d120b0	 ldrneh      r2, [r1]
  001c0	13a03cbf	 movne       r3, #0xBF, 24

; 3406 :             epRegVal &= ~BIT14;

  001c4	138330ff	 orrne       r3, r3, #0xFF
  001c8	10023003	 andne       r3, r2, r3
  001cc	01d130b0	 ldreqh      r3, [r1]

; 3407 :             (*pepCsrReg) = epRegVal;
; 3408 :         }
; 3409 :         PRINTMSG(ZONE_PDD_INIT, /*TRUE*/
; 3410 :                  (L"EP %u FIFOSZ 0x%x FIFO 0x%x CSR 0x%x\r\n",
; 3411 :                   endpoint, fifoSz, pPdd->ep[endpoint].fifoOffset, epRegVal));
; 3412 : 
; 3413 :         /* Clear the EndPoint Stall */
; 3414 :         UfnPdd_ClearEndpointStall(pvPddContext, endpoint);

  001d0	e1a00007	 mov         r0, r7
  001d4	e3a0b000	 mov         r11, #0
  001d8	03833901	 orreq       r3, r3, #1, 18
  001dc	e1c130b0	 strh        r3, [r1]
  001e0	e1a01005	 mov         r1, r5
  001e4	eb000000	 bl          UfnPdd_ClearEndpointStall

; 3415 :     }
; 3416 :     else

  001e8	ea00000d	 b           |$LN3@UfnPdd_Ini@2|
  001ec		 |$LN13@UfnPdd_Ini@2|

; 3417 :     {
; 3418 :         /* Configure the EP0 Registers first for
; 3419 :          * Core Events Interrupts on the EP0 Interrupt Enable register
; 3420 :          */
; 3421 : 
; 3422 :         /* use pre-computed values for EP0  */
; 3423 :         pUsbdRegs->TXFIFOSZ = 3;
; 3424 :         pUsbdRegs->RXFIFOSZ = 3;
; 3425 :         pUsbdRegs->TXFIFOADDR = 0;

  001ec	e3a01003	 mov         r1, #3
  001f0	e5c91462	 strb        r1, [r9, #0x462]
  001f4	e2892b01	 add         r2, r9, #1, 22

; 3426 :         pUsbdRegs->RXFIFOADDR = 0;

  001f8	e3a08000	 mov         r8, #0
  001fc	e5c91463	 strb        r1, [r9, #0x463]
  00200	e2893b01	 add         r3, r9, #1, 22
  00204	e1c286b4	 strh        r8, [r2, #0x64]
  00208	e1c386b6	 strh        r8, [r3, #0x66]

; 3427 : 
; 3428 :         /* Update the Global FIFO Usage Count */
; 3429 :         pPdd->ep[endpoint].maxPacketSize = epMaxPktSize;

  0020c	e2873c02	 add         r3, r7, #2, 24
  00210	e1c368bc	 strh        r6, [r3, #0x8C]

; 3430 :         /* Let us use the Starting of the FIFO RAM for EP0 */
; 3431 :         pPdd->ep[endpoint].fifoOffset    = 0;

  00214	e1c388be	 strh        r8, [r3, #0x8E]
  00218	e3a03801	 mov         r3, #1, 16

; 3432 : 
; 3433 :         // Interrupt mask
; 3434 :         intrRegVal  = (1 << endpoint) << USB_OTG_RXINT_SHIFT;
; 3435 :         intrRegVal |= (1 << endpoint) << USB_OTG_TXINT_SHIFT;
; 3436 : 
; 3437 :         pPdd->fWaitingForHandshake = FALSE;

  0021c	e383b001	 orr         r11, r3, #1
  00220	e587864c	 str         r8, [r7, #0x64C]
  00224		 |$LN3@UfnPdd_Ini@2|

; 3438 :     }
; 3439 : 
; 3440 :     pPdd->ep[endpoint].epNumber = (UINT16)endpoint;

  00224	e0653205	 rsb         r3, r5, r5, lsl #4
  00228	e0876103	 add         r6, r7, r3, lsl #2
  0022c	e2863c02	 add         r3, r6, #2, 24
  00230	e1c358b4	 strh        r5, [r3, #0x84]

; 3441 : 
; 3442 : #ifdef CPPI_DMA_SUPPORT
; 3443 :     /* Select EP */
; 3444 :     if ((endpoint != 0) &&
; 3445 :         (pPdd->ep[endpoint].pDmaChan == NULL))

  00234	e3550000	 cmp         r5, #0
  00238	0a00000f	 beq         |$LN1@UfnPdd_Ini@2|
  0023c	e59632b0	 ldr         r3, [r6, #0x2B0]
  00240	e3530000	 cmp         r3, #0
  00244	1a00000c	 bne         |$LN1@UfnPdd_Ini@2|

; 3446 :     {
; 3447 :         struct dma_controller *pDma =  (struct dma_controller *)pPdd->pDmaCntrl;

  00248	e597065c	 ldr         r0, [r7, #0x65C]
  0024c	e1b01000	 movs        r1, r0

; 3448 : 
; 3449 :         if (pDma != NULL)

  00250	0a000009	 beq         |$LN1@UfnPdd_Ini@2|

; 3450 :         {
; 3451 :             pPdd->ep[endpoint].pDmaChan =  (PVOID)
; 3452 :                 pDma->pfnChannelAlloc(pPdd->pDmaCntrl, &pPdd->ep[endpoint],
; 3453 :                                       (UINT8)(modeOut == FALSE),
; 3454 :                                       (modeOut == FALSE) ?
; 3455 :                                       TxDmaTransferComplete : RxDmaTransferComplete);

  00254	e35a0000	 cmp         r10, #0
  00258	059f3048	 ldreq       r3, [pc, #0x48]
  0025c	e5914008	 ldr         r4, [r1, #8]
  00260	159f303c	 ldrne       r3, [pc, #0x3C]
  00264	03a02001	 moveq       r2, #1
  00268	13a02000	 movne       r2, #0
  0026c	e2861fa1	 add         r1, r6, #0xA1, 30
  00270	e1a0e00f	 mov         lr, pc
  00274	e12fff14	 bx          r4
  00278	e58602b0	 str         r0, [r6, #0x2B0]
  0027c		 |$LN1@UfnPdd_Ini@2|

; 3456 :         }
; 3457 :     }
; 3458 : #endif /* #ifdef  CPPI_DMA_SUPPORT */
; 3459 : 
; 3460 :     pPdd->ep[endpoint].stalled   = FALSE;
; 3461 : 
; 3462 :     /* Enable the Tx and Rx interrupts */
; 3463 :     pUsbdRegs->EP_INTMSKSETR = intrRegVal;

  0027c	e586829c	 str         r8, [r6, #0x29C]
  00280	e589b030	 str         r11, [r9, #0x30]

; 3464 : 
; 3465 :     pUsbdRegs->INDEX = 0;
; 3466 : 
; 3467 :     PRINTMSG(ZONE_PDD_INIT, /* TRUE */
; 3468 :              (L"INTMSKR 0x%08x\r\n",
; 3469 :               pUsbdRegs->EP_INTMSKR));
; 3470 : 
; 3471 :     /* EP is ready */
; 3472 :     pPdd->ep[endpoint].epInitialised = TRUE;

  00284	e3a03001	 mov         r3, #1
  00288	e5c9840e	 strb        r8, [r9, #0x40E]
  0028c	e5863288	 str         r3, [r6, #0x288]
  00290	e3a03000	 mov         r3, #0
  00294		 |$Exit$47953|

; 3473 : 
; 3474 : Exit:
; 3475 :     FUNCTION_LEAVE_MSG();
; 3476 : 
; 3477 :     return rc;
; 3478 : }

  00294	e1a00003	 mov         r0, r3
  00298	e28dd004	 add         sp, sp, #4
  0029c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  002a0	e12fff1e	 bx          lr
  002a4		 |$LN37@UfnPdd_Ini@2|
  002a4		 |$LN38@UfnPdd_Ini@2|
  002a4	00000000	 DCD         |RxDmaTransferComplete|
  002a8		 |$LN39@UfnPdd_Ini@2|
  002a8	00000000	 DCD         |TxDmaTransferComplete|
  002ac		 |$LN40@UfnPdd_Ini@2|
  002ac	00000000	 DCD         |??_C@_1HM@BENODFNJ@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?3?$AA?5?$AAE?$AAP?$AA?$CF?$AAu?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?0@|
  002b0		 |$LN41@UfnPdd_Ini@2|
  002b0	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  002b4		 |$LN42@UfnPdd_Ini@2|
  002b4	00000000	 DCD         |??_C@_1JO@JAGHJEHH@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  002b8		 |$M49317|

			 ENDP  ; |UfnPdd_InitEndpoint|

	EXPORT	|UfnPdd_RegisterDevice|
	EXPORT	|??_C@_1II@BLOEHPDP@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAe?$AAr?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?3?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAr?$AAe?$AAt@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T49368| DCD	|$LN48@UfnPdd_Reg|
	DCD	0x40009201

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1II@BLOEHPDP@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAe?$AAr?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?3?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAr?$AAe?$AAt@| DCB "U"
	DCB	0x0, "f", 0x0, "n", 0x0, "P", 0x0, "d", 0x0, "d", 0x0, "_"
	DCB	0x0, "R", 0x0, "e", 0x0, "g", 0x0, "i", 0x0, "s", 0x0, "t"
	DCB	0x0, "e", 0x0, "r", 0x0, "D", 0x0, "e", 0x0, "v", 0x0, "i"
	DCB	0x0, "c", 0x0, "e", 0x0, ":", 0x0, " ", 0x0, "E", 0x0, "r"
	DCB	0x0, "r", 0x0, "o", 0x0, "r", 0x0, " ", 0x0, "r", 0x0, "e"
	DCB	0x0, "t", 0x0, "r", 0x0, "i", 0x0, "e", 0x0, "v", 0x0, "i"
	DCB	0x0, "n", 0x0, "g", 0x0, " ", 0x0, "f", 0x0, "u", 0x0, "l"
	DCB	0x0, "l", 0x0, "-", 0x0, "s", 0x0, "p", 0x0, "e", 0x0, "e"
	DCB	0x0, "d", 0x0, " ", 0x0, "a", 0x0, "l", 0x0, "t", 0x0, "s"
	DCB	0x0, "e", 0x0, "t", 0x0, "t", 0x0, "i", 0x0, "n", 0x0, "g"
	DCB	0x0, " ", 0x0, "c", 0x0, "o", 0x0, "u", 0x0, "n", 0x0, "t"
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_RegisterDevice| PROC

; 3642 : {

  00000		 |$LN48@UfnPdd_Reg|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M49365|
  00004	e1a0b002	 mov         r11, r2
  00008	e1a08000	 mov         r8, r0

; 3643 :     DWORD dwFullNAltSettings;
; 3644 :     DWORD dwHighNAltSettings;
; 3645 :     DWORD rc = ERROR_INVALID_PARAMETER;
; 3646 : 
; 3647 :     USBFNPDDCONTEXT *pPdd = (USBFNPDDCONTEXT *)pvPddContext;
; 3648 :     UFN_INTERFACE   *pIFC = NULL;
; 3649 :     UFN_ENDPOINT    *pEP  = NULL;
; 3650 :     DWORD   ifc			  = 0;
; 3651 :     DWORD   epx           = 0;
; 3652 :     UINT16  ep            = 0;
; 3653 :     WORD    offset        = 0;
; 3654 : 
; 3655 : 	UNREFERENCED_PARAMETER(cStringSets);
; 3656 : 	UNREFERENCED_PARAMETER(pStringSets);
; 3657 : 	UNREFERENCED_PARAMETER(pFullSpeedConfigDesc);
; 3658 : 	UNREFERENCED_PARAMETER(pFullSpeedDeviceDesc);
; 3659 : 	UNREFERENCED_PARAMETER(pHighSpeedConfigDesc);
; 3660 : 	UNREFERENCED_PARAMETER(pHighSpeedDeviceDesc);
; 3661 : 
; 3662 :     PRINTMSG(ZONE_FUNCTION, (L"+UsbFnPdd_RegisterDevice\r\n"));
; 3663 : 
; 3664 :     /* Remember self powered flag */
; 3665 :     pPdd->selfPowered = (pFullSpeedConfig->Descriptor.bmAttributes & 0x20) != 0;

  0000c	e59d7028	 ldr         r7, [sp, #0x28]
  00010	e5d7300b	 ldrb        r3, [r7, #0xB]

; 3666 : 
; 3667 :     dwFullNAltSettings = GetTotalAltSettingCount(pFullSpeedConfig);

  00014	e1a00007	 mov         r0, r7
  00018	e3130020	 tst         r3, #0x20
  0001c	13a03001	 movne       r3, #1
  00020	03a03000	 moveq       r3, #0
  00024	e588325c	 str         r3, [r8, #0x25C]
  00028	eb000000	 bl          GetTotalAltSettingCount

; 3668 :     if( dwFullNAltSettings == INVALID_ALTSETTING_COUNT )

  0002c	e3a03cff	 mov         r3, #0xFF, 24
  00030	e38360ff	 orr         r6, r3, #0xFF
  00034	e1a04000	 mov         r4, r0
  00038	e1540006	 cmp         r4, r6
  0003c	1a000009	 bne         |$LN25@UfnPdd_Reg|

; 3669 :     {
; 3670 :         ERRORMSG(TRUE, (TEXT("UfnPdd_RegisterDevice: Error retrieving full-speed altsetting count")) );

  00040	e3a03c0e	 mov         r3, #0xE, 24
  00044	e3832056	 orr         r2, r3, #0x56
  00048		 |$LN45@UfnPdd_Reg|
  00048	e59f01f4	 ldr         r0, [pc, #0x1F4]
  0004c	e59f11ec	 ldr         r1, [pc, #0x1EC]
  00050	eb000000	 bl          NKDbgPrintfW
  00054	e59f01e0	 ldr         r0, [pc, #0x1E0]
  00058	eb000000	 bl          NKDbgPrintfW

; 3671 :         return ERROR_INVALID_PARAMETER;

  0005c	e3a00057	 mov         r0, #0x57

; 3768 : }

  00060	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00064	e12fff1e	 bx          lr
  00068		 |$LN25@UfnPdd_Reg|

; 3672 :     }
; 3673 : 
; 3674 :     dwHighNAltSettings = GetTotalAltSettingCount(pHighSpeedConfig);

  00068	e1a0000b	 mov         r0, r11
  0006c	eb000000	 bl          GetTotalAltSettingCount
  00070	e1a05000	 mov         r5, r0

; 3675 :     if( dwHighNAltSettings == INVALID_ALTSETTING_COUNT )

  00074	e1550006	 cmp         r5, r6

; 3676 :     {
; 3677 :         ERRORMSG(TRUE, (TEXT("UfnPdd_RegisterDevice: Error retrieving full-speed altsetting count")) );

  00078	03a03c0e	 moveq       r3, #0xE, 24
  0007c	0383205d	 orreq       r2, r3, #0x5D
  00080	0afffff0	 beq         |$LN45@UfnPdd_Reg|

; 3678 :         return ERROR_INVALID_PARAMETER;
; 3679 :     }
; 3680 : 
; 3681 :     PRINTMSG(ZONE_PDD_INIT,
; 3682 :              (L"FullSpeed NumInterfaces 0x%x, altsettings=(full=%d, high=%d) maxPktSize 0x%x:\r\n",
; 3683 :               pFullSpeedConfig->Descriptor.bNumInterfaces,
; 3684 :               dwFullNAltSettings, dwHighNAltSettings,
; 3685 :               pFullSpeedDeviceDesc->bMaxPacketSize0));
; 3686 : 
; 3687 : 
; 3688 :     /* Determine FIFO offsets for each EP */
; 3689 : 
; 3690 :     /* Clear config */
; 3691 :     for (ep = 0; ep < USBD_EP_COUNT; ++ep)

  00084	e3a02000	 mov         r2, #0
  00088	e3a01000	 mov         r1, #0
  0008c	e3a09000	 mov         r9, #0
  00090		 |$LL23@UfnPdd_Reg|

; 3692 :     {
; 3693 :         pPdd->ep[ep].maxPacketSize = 0;

  00090	e0623202	 rsb         r3, r2, r2, lsl #4
  00094	e2812001	 add         r2, r1, #1
  00098	e1a02802	 mov         r2, r2, lsl #16
  0009c	e0883103	 add         r3, r8, r3, lsl #2
  000a0	e1a02822	 mov         r2, r2, lsr #16
  000a4	e2833c02	 add         r3, r3, #2, 24

; 3694 :         pPdd->ep[ep].fifoOffset = 0;

  000a8	e1a01002	 mov         r1, r2
  000ac	e3520010	 cmp         r2, #0x10
  000b0	e1c398bc	 strh        r9, [r3, #0x8C]
  000b4	e1c398be	 strh        r9, [r3, #0x8E]
  000b8	3afffff4	 bcc         |$LL23@UfnPdd_Reg|

; 3695 :     }
; 3696 : 
; 3697 :     /* Full speed config first */
; 3698 :     for (ifc = 0; ifc < dwFullNAltSettings; ifc++)

  000bc	e3540000	 cmp         r4, #0
  000c0	0a00001b	 beq         |$LN18@UfnPdd_Reg|
  000c4	e3a0e000	 mov         lr, #0
  000c8		 |$LL20@UfnPdd_Reg|

; 3699 :     {
; 3700 :         pIFC = &pFullSpeedConfig->pInterfaces[ifc];

  000c8	e5973018	 ldr         r3, [r7, #0x18]

; 3701 : 
; 3702 :         PRINTMSG(ZONE_PDD_INIT, (L"FS Interface 0x%x EP_COUNT 0x%x:\r\n",
; 3703 :                                  ifc, pIFC->Descriptor.bNumEndpoints));
; 3704 : 
; 3705 :         for (epx = 0; epx < pIFC->Descriptor.bNumEndpoints; epx++)

  000cc	e3a0a000	 mov         r10, #0
  000d0	e08e6003	 add         r6, lr, r3
  000d4	e5d63008	 ldrb        r3, [r6, #8]
  000d8	e3530000	 cmp         r3, #0
  000dc	0a000010	 beq         |$LN19@UfnPdd_Reg|

; 3699 :     {
; 3700 :         pIFC = &pFullSpeedConfig->pInterfaces[ifc];

  000e0	e3a09000	 mov         r9, #0
  000e4		 |$LL17@UfnPdd_Reg|

; 3706 :         {
; 3707 :             pEP = &pIFC->pEndpoints[epx];

  000e4	e5963018	 ldr         r3, [r6, #0x18]
  000e8	e28aa001	 add         r10, r10, #1
  000ec	e0893003	 add         r3, r9, r3

; 3708 : 
; 3709 :             PRINTMSG(ZONE_PDD_INIT, (L"FS EP_NUM 0x%x EP MaxPktSize 0x%x\r\n",
; 3710 :                                      pEP->Descriptor.bEndpointAddress & 0x0F,
; 3711 :                                      pEP->Descriptor.wMaxPacketSize));
; 3712 : 
; 3713 :             /* Get EP address */
; 3714 :             ep = pEP->Descriptor.bEndpointAddress & 0x0F;
; 3715 : 
; 3716 :             /* Save max packet size */
; 3717 :             pPdd->ep[ep].maxPacketSize = pEP->Descriptor.wMaxPacketSize;

  000f0	e5d32006	 ldrb        r2, [r3, #6]
  000f4	e5d30008	 ldrb        r0, [r3, #8]
  000f8	e5d31009	 ldrb        r1, [r3, #9]
  000fc	e202300f	 and         r3, r2, #0xF
  00100	e0633203	 rsb         r3, r3, r3, lsl #4
  00104	e0883103	 add         r3, r8, r3, lsl #2
  00108	e2832c02	 add         r2, r3, #2, 24
  0010c	e1803401	 orr         r3, r0, r1, lsl #8
  00110	e1c238bc	 strh        r3, [r2, #0x8C]
  00114	e5d63008	 ldrb        r3, [r6, #8]
  00118	e2899014	 add         r9, r9, #0x14
  0011c	e15a0003	 cmp         r10, r3
  00120	3affffef	 bcc         |$LL17@UfnPdd_Reg|
  00124		 |$LN19@UfnPdd_Reg|

; 3695 :     }
; 3696 : 
; 3697 :     /* Full speed config first */
; 3698 :     for (ifc = 0; ifc < dwFullNAltSettings; ifc++)

  00124	e28ee01c	 add         lr, lr, #0x1C
  00128	e2544001	 subs        r4, r4, #1
  0012c	1affffe5	 bne         |$LL20@UfnPdd_Reg|
  00130	e3a09000	 mov         r9, #0
  00134		 |$LN18@UfnPdd_Reg|

; 3718 :         }
; 3719 :     }
; 3720 : 
; 3721 :     /* High speed config */
; 3722 :     for (ifc = 0; ifc < dwHighNAltSettings; ifc++)

  00134	e3550000	 cmp         r5, #0
  00138	0a00001d	 beq         |$LN12@UfnPdd_Reg|
  0013c	e3a0e000	 mov         lr, #0
  00140		 |$LL14@UfnPdd_Reg|

; 3723 :     {
; 3724 :         pIFC = &pHighSpeedConfig->pInterfaces[ifc];

  00140	e59b3018	 ldr         r3, [r11, #0x18]

; 3725 : 
; 3726 :         PRINTMSG(ZONE_PDD_INIT, (L"HS Interface 0x%x EP_COUNT 0x%x:\r\n",
; 3727 :                                  ifc, pIFC->Descriptor.bNumEndpoints));
; 3728 : 
; 3729 :         for (epx = 0; epx < pIFC->Descriptor.bNumEndpoints; epx++)

  00144	e3a04000	 mov         r4, #0
  00148	e083700e	 add         r7, r3, lr
  0014c	e5d73008	 ldrb        r3, [r7, #8]
  00150	e3530000	 cmp         r3, #0
  00154	0a000013	 beq         |$LN13@UfnPdd_Reg|

; 3723 :     {
; 3724 :         pIFC = &pHighSpeedConfig->pInterfaces[ifc];

  00158	e3a06000	 mov         r6, #0
  0015c		 |$LL11@UfnPdd_Reg|

; 3730 :         {
; 3731 :             pEP = &pIFC->pEndpoints[epx];

  0015c	e5973018	 ldr         r3, [r7, #0x18]

; 3732 : 
; 3733 :             PRINTMSG(ZONE_PDD_INIT, (L"HS EP_NUM 0x%x EP MaxPktSize 0x%x\r\n",
; 3734 :                                      pEP->Descriptor.bEndpointAddress & 0x0F,
; 3735 :                                      pEP->Descriptor.wMaxPacketSize));
; 3736 : 
; 3737 :             /* Get EP address */
; 3738 :             ep = pEP->Descriptor.bEndpointAddress & 0x0F;
; 3739 : 
; 3740 :             /* Save max packet size */
; 3741 :             if (pEP->Descriptor.wMaxPacketSize > pPdd->ep[ep].maxPacketSize)
; 3742 :                 pPdd->ep[ep].maxPacketSize = pEP->Descriptor.wMaxPacketSize;

  00160	e2844001	 add         r4, r4, #1
  00164	e0863003	 add         r3, r6, r3
  00168	e5d32006	 ldrb        r2, [r3, #6]
  0016c	e5d30008	 ldrb        r0, [r3, #8]
  00170	e5d31009	 ldrb        r1, [r3, #9]
  00174	e202300f	 and         r3, r2, #0xF
  00178	e0633203	 rsb         r3, r3, r3, lsl #4
  0017c	e0882103	 add         r2, r8, r3, lsl #2
  00180	e2823c02	 add         r3, r2, #2, 24
  00184	e1d338bc	 ldrh        r3, [r3, #0x8C]
  00188	e1801401	 orr         r1, r0, r1, lsl #8
  0018c	e2866014	 add         r6, r6, #0x14
  00190	e1510003	 cmp         r1, r3
  00194	82823c02	 addhi       r3, r2, #2, 24
  00198	81c318bc	 strhih      r1, [r3, #0x8C]
  0019c	e5d73008	 ldrb        r3, [r7, #8]
  001a0	e1540003	 cmp         r4, r3
  001a4	3affffec	 bcc         |$LL11@UfnPdd_Reg|
  001a8		 |$LN13@UfnPdd_Reg|

; 3718 :         }
; 3719 :     }
; 3720 : 
; 3721 :     /* High speed config */
; 3722 :     for (ifc = 0; ifc < dwHighNAltSettings; ifc++)

  001a8	e28ee01c	 add         lr, lr, #0x1C
  001ac	e2555001	 subs        r5, r5, #1
  001b0	1affffe2	 bne         |$LL14@UfnPdd_Reg|
  001b4		 |$LN12@UfnPdd_Reg|

; 3743 :         }
; 3744 :     }
; 3745 : 
; 3746 :     /* Now determine fifo offsets */
; 3747 : 
; 3748 :     /* Allow for EP0 fifo */
; 3749 :     offset = 64;

  001b4	e3a02040	 mov         r2, #0x40

; 3750 : 
; 3751 :     for (ep = 0; ep < USBD_EP_COUNT; ++ep)

  001b8	e3a03000	 mov         r3, #0
  001bc	e3a01000	 mov         r1, #0
  001c0		 |$LL7@UfnPdd_Reg|

; 3752 :     {
; 3753 :         if (pPdd->ep[ep].maxPacketSize > 0)

  001c0	e0633203	 rsb         r3, r3, r3, lsl #4
  001c4	e0880103	 add         r0, r8, r3, lsl #2
  001c8	e2803c02	 add         r3, r0, #2, 24
  001cc	e1d338bc	 ldrh        r3, [r3, #0x8C]
  001d0	e1b0e003	 movs        lr, r3

; 3754 :         {
; 3755 :             pPdd->ep[ep].fifoOffset = offset;

  001d4	12803c02	 addne       r3, r0, #2, 24
  001d8	11c328be	 strneh      r2, [r3, #0x8E]

; 3756 :             offset = offset + pPdd->ep[ep].maxPacketSize;

  001dc	1082300e	 addne       r3, r2, lr
  001e0	11a02803	 movne       r2, r3, lsl #16
  001e4	e2813001	 add         r3, r1, #1
  001e8	e1a03803	 mov         r3, r3, lsl #16
  001ec	e1a03823	 mov         r3, r3, lsr #16
  001f0	11a02822	 movne       r2, r2, lsr #16
  001f4	e1a01003	 mov         r1, r3
  001f8	e3530010	 cmp         r3, #0x10
  001fc	3affffef	 bcc         |$LL7@UfnPdd_Reg|

; 3757 :         }
; 3758 :     }
; 3759 : 
; 3760 :     /* Clear EP's maxPacketSize */
; 3761 :     for (ep = 0; ep < USBD_EP_COUNT; ++ep)

  00200	e3a02000	 mov         r2, #0
  00204	e3a01000	 mov         r1, #0
  00208		 |$LL3@UfnPdd_Reg|

; 3762 :         pPdd->ep[ep].maxPacketSize = 0;

  00208	e0623202	 rsb         r3, r2, r2, lsl #4
  0020c	e2812001	 add         r2, r1, #1
  00210	e1a02802	 mov         r2, r2, lsl #16
  00214	e0883103	 add         r3, r8, r3, lsl #2
  00218	e1a02822	 mov         r2, r2, lsr #16
  0021c	e2833c02	 add         r3, r3, #2, 24
  00220	e1a01002	 mov         r1, r2
  00224	e3520010	 cmp         r2, #0x10
  00228	e1c398bc	 strh        r9, [r3, #0x8C]
  0022c	3afffff5	 bcc         |$LL3@UfnPdd_Reg|

; 3763 : 
; 3764 :     rc = ERROR_SUCCESS;
; 3765 : 
; 3766 :     PRINTMSG(ZONE_FUNCTION, (L"-UfnPdd_RegisterDevice:\r\n"));
; 3767 :     return (rc);

  00230	e3a00000	 mov         r0, #0

; 3768 : }

  00234	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00238	e12fff1e	 bx          lr
  0023c		 |$LN49@UfnPdd_Reg|
  0023c		 |$LN50@UfnPdd_Reg|
  0023c	00000000	 DCD         |??_C@_1II@BLOEHPDP@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAe?$AAr?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?3?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAr?$AAe?$AAt@|
  00240		 |$LN51@UfnPdd_Reg|
  00240	00000000	 DCD         |??_C@_1JO@JAGHJEHH@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  00244		 |$LN52@UfnPdd_Reg|
  00244	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  00248		 |$M49366|

			 ENDP  ; |UfnPdd_RegisterDevice|

	EXPORT	|UfnPdd_IsConfigurationSupportable|
	EXPORT	|??_C@_1KA@EDCAFIIN@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAs?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AAS?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AAa?$AAb?$AAl@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T49410| DCD	|$LN42@UfnPdd_IsC|
	DCD	0x40007a02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1KA@EDCAFIIN@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAs?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AAS?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AAa?$AAb?$AAl@| DCB "U"
	DCB	0x0, "f", 0x0, "n", 0x0, "P", 0x0, "d", 0x0, "d", 0x0, "_"
	DCB	0x0, "I", 0x0, "s", 0x0, "C", 0x0, "o", 0x0, "n", 0x0, "f"
	DCB	0x0, "i", 0x0, "g", 0x0, "u", 0x0, "r", 0x0, "a", 0x0, "t"
	DCB	0x0, "i", 0x0, "o", 0x0, "n", 0x0, "S", 0x0, "u", 0x0, "p"
	DCB	0x0, "p", 0x0, "o", 0x0, "r", 0x0, "t", 0x0, "a", 0x0, "b"
	DCB	0x0, "l", 0x0, "e", 0x0, ":", 0x0, " ", 0x0, "E", 0x0, "r"
	DCB	0x0, "r", 0x0, "o", 0x0, "r", 0x0, " ", 0x0, "r", 0x0, "e"
	DCB	0x0, "t", 0x0, "r", 0x0, "i", 0x0, "e", 0x0, "v", 0x0, "i"
	DCB	0x0, "n", 0x0, "g", 0x0, " ", 0x0, "f", 0x0, "u", 0x0, "l"
	DCB	0x0, "l", 0x0, "-", 0x0, "s", 0x0, "p", 0x0, "e", 0x0, "e"
	DCB	0x0, "d", 0x0, " ", 0x0, "a", 0x0, "l", 0x0, "t", 0x0, "s"
	DCB	0x0, "e", 0x0, "t", 0x0, "t", 0x0, "i", 0x0, "n", 0x0, "g"
	DCB	0x0, " ", 0x0, "c", 0x0, "o", 0x0, "u", 0x0, "n", 0x0, "t"
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_IsConfigurationSupportable| PROC

; 3894 : {

  00000		 |$LN42@UfnPdd_IsC|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M49407|
  00008	e1a0a002	 mov         r10, r2
  0000c	e58da008	 str         r10, [sp, #8]
  00010	e58d1000	 str         r1, [sp]

; 3895 :     DWORD dwNAltSettings = 0;
; 3896 :     DWORD rc             = ERROR_INVALID_PARAMETER;
; 3897 :     UFN_INTERFACE *pIFC  = NULL;
; 3898 :     UFN_ENDPOINT *pEP    = NULL;
; 3899 :     WORD ifc             = 0;
; 3900 : 	WORD epx             = 0;
; 3901 : 	WORD count           = 0;
; 3902 :     WORD offset          = 0;
; 3903 : 	WORD size            = 0;
; 3904 :     WORD maxPktSize      = 0;
; 3905 : 
; 3906 : 	UNREFERENCED_PARAMETER(pvPddContext);
; 3907 : 
; 3908 :     PRINTMSG(ZONE_FUNCTION, (L"+UfnPdd_IsConfigurationSupportable:\r\n"));
; 3909 : 
; 3910 :     /* We must start with offset 64 (EP0 size) */
; 3911 :     offset = 64;
; 3912 : 
; 3913 :     /* Clear number of end points */
; 3914 :     count = 0;
; 3915 : 
; 3916 :     PRINTMSG(ZONE_PDD_INIT, (L"NumInterfaces 0x%x\r\n",
; 3917 :                              pConfiguration->Descriptor.bNumInterfaces));
; 3918 : 
; 3919 :     dwNAltSettings = GetTotalAltSettingCount(pConfiguration);

  00014	e1a0000a	 mov         r0, r10
  00018	e3a05057	 mov         r5, #0x57
  0001c	e3a04000	 mov         r4, #0
  00020	e3a08040	 mov         r8, #0x40
  00024	e3a06000	 mov         r6, #0
  00028	eb000000	 bl          GetTotalAltSettingCount
  0002c	e3a03cff	 mov         r3, #0xFF, 24

; 3920 :     if( dwNAltSettings == INVALID_ALTSETTING_COUNT )

  00030	e38330ff	 orr         r3, r3, #0xFF
  00034	e1a0e000	 mov         lr, r0
  00038	e15e0003	 cmp         lr, r3
  0003c	e58de004	 str         lr, [sp, #4]
  00040	1a000008	 bne         |$LN25@UfnPdd_IsC|

; 3921 :     {
; 3922 :         ERRORMSG(TRUE, (TEXT("UfnPdd_IsConfigurationSupportable: Error retrieving full-speed altsetting count")) );

  00044	e59f1198	 ldr         r1, [pc, #0x198]
  00048	e59f0190	 ldr         r0, [pc, #0x190]
  0004c	e3a03c0f	 mov         r3, #0xF, 24
  00050	e3832052	 orr         r2, r3, #0x52
  00054	eb000000	 bl          NKDbgPrintfW
  00058	e59f017c	 ldr         r0, [pc, #0x17C]
  0005c	eb000000	 bl          NKDbgPrintfW

; 3923 :         return ERROR_INVALID_PARAMETER;

  00060	e3a05057	 mov         r5, #0x57
  00064	ea000056	 b           |$LN1@UfnPdd_IsC|
  00068		 |$LN25@UfnPdd_IsC|

; 3924 :     }
; 3925 : 
; 3926 : 
; 3927 :     /* For each interface in configuration */
; 3928 :     for (ifc = 0; ifc < dwNAltSettings; ifc++)

  00068	e3a01000	 mov         r1, #0
  0006c	e35e0000	 cmp         lr, #0
  00070	0a00004f	 beq         |$LN22@UfnPdd_IsC|
  00074	e59d5000	 ldr         r5, [sp]
  00078	e3a09000	 mov         r9, #0
  0007c		 |$LL24@UfnPdd_IsC|

; 3929 :     {
; 3930 :         /* For each endpoint in interface */
; 3931 :         pIFC = &pConfiguration->pInterfaces[ifc];

  0007c	e59a2018	 ldr         r2, [r10, #0x18]
  00080	e0613181	 rsb         r3, r1, r1, lsl #3

; 3932 :         for (epx = 0; epx < pIFC->Descriptor.bNumEndpoints; epx++)

  00084	e3a00000	 mov         r0, #0
  00088	e0827103	 add         r7, r2, r3, lsl #2
  0008c	e5d73008	 ldrb        r3, [r7, #8]
  00090	e3530000	 cmp         r3, #0
  00094	0a00003b	 beq         |$LN19@UfnPdd_IsC|
  00098	e3a0b000	 mov         r11, #0
  0009c	e3a0ec03	 mov         lr, #3, 24
  000a0	e3a0a001	 mov         r10, #1
  000a4		 |$LL21@UfnPdd_IsC|

; 3933 :         {
; 3934 :             pEP = &pIFC->pEndpoints[epx];

  000a4	e5972018	 ldr         r2, [r7, #0x18]
  000a8	e0803100	 add         r3, r0, r0, lsl #2

; 3935 : 
; 3936 :             /* We support maximal sizes 8, 16, 32 and 64 bytes for non-ISO */
; 3937 :             size = pEP->Descriptor.wMaxPacketSize;
; 3938 : 
; 3939 :             PRINTMSG(ZONE_PDD_INIT, (L"EP %u Addr 0x%x Attributes 0x%x MaxPktSize 0x%x\r\n",
; 3940 :                                      epx, pEP->Descriptor.bEndpointAddress,
; 3941 :                                      pEP->Descriptor.bmAttributes,
; 3942 :                                      pEP->Descriptor.wMaxPacketSize));
; 3943 :             /* First round size to supported sizes */
; 3944 :             size = (WORD)(1 << Log2(size));

  000ac	e3a01000	 mov         r1, #0
  000b0	e0820103	 add         r0, r2, r3, lsl #2
  000b4	e5d02008	 ldrb        r2, [r0, #8]
  000b8	e5d03009	 ldrb        r3, [r0, #9]
  000bc	e1923403	 orrs        r3, r2, r3, lsl #8
  000c0	0a000004	 beq         |$LN28@UfnPdd_IsC|
  000c4		 |$LL30@UfnPdd_IsC|
  000c4	e1b030a3	 movs        r3, r3, lsr #1
  000c8	e2811001	 add         r1, r1, #1
  000cc	1afffffc	 bne         |$LL30@UfnPdd_IsC|
  000d0	e3510000	 cmp         r1, #0
  000d4	12411001	 subne       r1, r1, #1
  000d8		 |$LN28@UfnPdd_IsC|
  000d8	e1a0311a	 mov         r3, r10, lsl r1

; 3945 : 
; 3946 :             if (speed == BS_HIGH_SPEED)

  000dc	e3550002	 cmp         r5, #2
  000e0	e1a02803	 mov         r2, r3, lsl #16

; 3947 :             {
; 3948 :                 switch (pEP->Descriptor.bmAttributes & 0x03)

  000e4	e5d03007	 ldrb        r3, [r0, #7]
  000e8	e1a02822	 mov         r2, r2, lsr #16
  000ec	1a00000b	 bne         |$LN18@UfnPdd_IsC|
  000f0	e2133003	 ands        r3, r3, #3
  000f4	0a000011	 beq         |$LN8@UfnPdd_IsC|
  000f8	e3530001	 cmp         r3, #1
  000fc	0a000003	 beq         |$LN14@UfnPdd_IsC|
  00100	e3530002	 cmp         r3, #2
  00104	0a000003	 beq         |$LN13@UfnPdd_IsC|
  00108	e3530003	 cmp         r3, #3
  0010c	1a00000c	 bne         |$LN9@UfnPdd_IsC|
  00110		 |$LN14@UfnPdd_IsC|

; 3953 :                 case USB_ENDPOINT_TYPE_INTERRUPT:   maxPktSize = USB_HIGH_SPEED_INTERRUPT_MAX_PACKET_SIZE; break;

  00110	e3a04b01	 mov         r4, #1, 22
  00114	ea00000a	 b           |$LN9@UfnPdd_IsC|
  00118		 |$LN13@UfnPdd_IsC|

; 3949 :                 {
; 3950 :                 case USB_ENDPOINT_TYPE_CONTROL:     maxPktSize = USB_HIGH_SPEED_CONTROL_MAX_PACKET_SIZE; break;
; 3951 :                 case USB_ENDPOINT_TYPE_ISOCHRONOUS: maxPktSize = USB_HIGH_SPEED_ISOCHRONOUS_MAX_PACKET_SIZE; break;
; 3952 :                 case USB_ENDPOINT_TYPE_BULK:        maxPktSize = USB_HIGH_SPEED_BULK_MAX_PACKET_SIZE; break;

  00118	e3a04c02	 mov         r4, #2, 24
  0011c	ea000008	 b           |$LN9@UfnPdd_IsC|
  00120		 |$LN18@UfnPdd_IsC|

; 3954 :                 }
; 3955 :             }
; 3956 :             else
; 3957 :             {
; 3958 :                 switch (pEP->Descriptor.bmAttributes & 0x03)

  00120	e2133003	 ands        r3, r3, #3
  00124	0a000005	 beq         |$LN8@UfnPdd_IsC|
  00128	e3530001	 cmp         r3, #1
  0012c	0a000028	 beq         |$LN7@UfnPdd_IsC|
  00130	e3530002	 cmp         r3, #2
  00134	0a000001	 beq         |$LN8@UfnPdd_IsC|
  00138	e3530003	 cmp         r3, #3
  0013c	1a000000	 bne         |$LN9@UfnPdd_IsC|
  00140		 |$LN8@UfnPdd_IsC|

; 3959 :                 {
; 3960 :                 case USB_ENDPOINT_TYPE_CONTROL:     maxPktSize = USB_FULL_SPEED_CONTROL_MAX_PACKET_SIZE; break;

  00140	e3a04040	 mov         r4, #0x40
  00144		 |$LN9@UfnPdd_IsC|

; 3962 :                 case USB_ENDPOINT_TYPE_BULK:        maxPktSize = USB_FULL_SPEED_BULK_MAX_PACKET_SIZE; break;
; 3963 :                 case USB_ENDPOINT_TYPE_INTERRUPT:   maxPktSize = USB_FULL_SPEED_INTERRUPT_MAX_PACKET_SIZE; break;
; 3964 :                 }
; 3965 :             }
; 3966 :             if (size > maxPktSize)

  00144	e1520004	 cmp         r2, r4

; 3967 :                 size = maxPktSize;

  00148	81a02004	 movhi       r2, r4

; 3968 :             PRINTMSG(ZONE_PDD_INIT, (L"EPAddr 0x%x Size %d\r\n",
; 3969 :                                      pEP->Descriptor.bEndpointAddress, size));
; 3970 : 
; 3971 :             /* Update EP size */
; 3972 :             pEP->Descriptor.wMaxPacketSize = size;

  0014c	e1a03422	 mov         r3, r2, lsr #8
  00150	e5c03009	 strb        r3, [r0, #9]
  00154	e28b3001	 add         r3, r11, #1
  00158	e5c02008	 strb        r2, [r0, #8]
  0015c	e5d71008	 ldrb        r1, [r7, #8]

; 3973 : 
; 3974 :             /* If registry for DMA end points isn't set try to choose */
; 3975 :             if ((pEP->Descriptor.bEndpointAddress & 0x80) != 0)
; 3976 :             {
; 3977 :                 PRINTMSG(ZONE_PDD_INIT, (L"TX EP 0x%02x\r\n",
; 3978 :                                          pEP->Descriptor.bEndpointAddress));
; 3979 :             }
; 3980 :             else
; 3981 :             {
; 3982 :                 PRINTMSG(ZONE_PDD_INIT, (L"RX EP 0x%02x\r\n",
; 3983 :                                          pEP->Descriptor.bEndpointAddress));
; 3984 :             }
; 3985 :             /* Calculate total buffer size */
; 3986 :             offset = offset + size;

  00160	e1a00803	 mov         r0, r3, lsl #16
  00164	e0822008	 add         r2, r2, r8
  00168	e1a00820	 mov         r0, r0, lsr #16
  0016c	e1a08802	 mov         r8, r2, lsl #16
  00170	e1500001	 cmp         r0, r1
  00174	e1a0b000	 mov         r11, r0
  00178	e1a08828	 mov         r8, r8, lsr #16
  0017c	3affffc8	 bcc         |$LL21@UfnPdd_IsC|
  00180	e59de004	 ldr         lr, [sp, #4]
  00184	e59da008	 ldr         r10, [sp, #8]
  00188		 |$LN19@UfnPdd_IsC|

; 3987 :         }
; 3988 :         /* Add number of end points to total count */
; 3989 :         count = count + pIFC->Descriptor.bNumEndpoints;

  00188	e5d72008	 ldrb        r2, [r7, #8]
  0018c	e2893001	 add         r3, r9, #1
  00190	e1a01803	 mov         r1, r3, lsl #16
  00194	e0823006	 add         r3, r2, r6
  00198	e1a06803	 mov         r6, r3, lsl #16
  0019c	e1a01821	 mov         r1, r1, lsr #16
  001a0	e1a06826	 mov         r6, r6, lsr #16
  001a4	e1a09001	 mov         r9, r1
  001a8	e151000e	 cmp         r1, lr
  001ac	3affffb2	 bcc         |$LL24@UfnPdd_IsC|
  001b0	e3a05057	 mov         r5, #0x57
  001b4		 |$LN22@UfnPdd_IsC|

; 3990 :     }
; 3991 : 
; 3992 :     PRINTMSG(ZONE_PDD_INIT, (L"Total EP Count 0x%x Offset 0x%x\r\n",
; 3993 :                              count, offset));
; 3994 : 
; 3995 :     /* Can we support this configuration? */
; 3996 :     if (count < USBD_EP_COUNT && offset <= MGC_FIFO_RAM_SIZE)

  001b4	e3560010	 cmp         r6, #0x10
  001b8	2a000001	 bcs         |$LN1@UfnPdd_IsC|
  001bc	e3580902	 cmp         r8, #2, 18

; 3997 :     {
; 3998 :         rc = ERROR_SUCCESS;

  001c0	93a05000	 movls       r5, #0
  001c4		 |$LN1@UfnPdd_IsC|

; 3999 :     }
; 4000 : /*cleanUp:*/
; 4001 :     return rc;
; 4002 : 
; 4003 : }

  001c4	e1a00005	 mov         r0, r5
  001c8	e28dd00c	 add         sp, sp, #0xC
  001cc	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001d0	e12fff1e	 bx          lr
  001d4		 |$LN7@UfnPdd_IsC|

; 3961 :                 case USB_ENDPOINT_TYPE_ISOCHRONOUS: maxPktSize = USB_FULL_SPEED_ISOCHRONOUS_MAX_PACKET_SIZE; break;

  001d4	e38e40ff	 orr         r4, lr, #0xFF
  001d8	eaffffd9	 b           |$LN9@UfnPdd_IsC|
  001dc		 |$LN43@UfnPdd_IsC|
  001dc		 |$LN44@UfnPdd_IsC|
  001dc	00000000	 DCD         |??_C@_1KA@EDCAFIIN@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAs?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AAS?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AAa?$AAb?$AAl@|
  001e0		 |$LN45@UfnPdd_IsC|
  001e0	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  001e4		 |$LN46@UfnPdd_IsC|
  001e4	00000000	 DCD         |??_C@_1JO@JAGHJEHH@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  001e8		 |$M49408|

			 ENDP  ; |UfnPdd_IsConfigurationSupportable|

	EXPORT	|UfnPdd_Init|
	IMPORT	|cppiControllerInit|

  00000			 AREA	 |.pdata|, PDATA
|$T49429| DCD	|$LN6@UfnPdd_Ini@3|
	DCD	0x40006302
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_Init| PROC

; 4033 : {

  00000		 |$LN6@UfnPdd_Ini@3|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M49426|
  00008	e58d3004	 str         r3, [sp, #4]
  0000c	e58d200c	 str         r2, [sp, #0xC]
  00010	e58d1008	 str         r1, [sp, #8]

; 4034 :     DWORD rc = ERROR_INVALID_PARAMETER;
; 4035 : 
; 4036 :     USBFNPDDCONTEXT * pPdd      = NULL;

  00014	e3a03000	 mov         r3, #0

; 4037 : 
; 4038 :     PRINTMSG(ZONE_FUNCTION, (L"+UfnPdd_Init\r\n"));
; 4039 : 
; 4040 :     /* Invoke the UfnPdd_ContextSetup Routine to setup the
; 4041 :      * USBFN PDD Context Struct. Note that if there are any
; 4042 :      * platform specific steps required, they can be
; 4043 :      * moved away into this routine thus keeping the UfnPdd_Init
; 4044 :      * generic across
; 4045 :      */
; 4046 :     if (FALSE == UfnPdd_ContextSetup(szActiveKey, &pPdd))

  00018	e28d1000	 add         r1, sp, #0
  0001c	e58d3000	 str         r3, [sp]
  00020	e3a04057	 mov         r4, #0x57
  00024	eb000000	 bl          UfnPdd_ContextSetup
  00028	e3500000	 cmp         r0, #0

; 4047 :     {
; 4048 :         /* Failure, Invoke UfnPdd_ContextTeardown */
; 4049 :         UfnPdd_ContextTeardown(pPdd) ;

  0002c	e59d0000	 ldr         r0, [sp]
  00030	1a000001	 bne         |$LN1@UfnPdd_Ini@3|
  00034	eb000000	 bl          UfnPdd_ContextTeardown

; 4050 :         goto cleanUp;

  00038	ea00003b	 b           |$cleanUp$48168|
  0003c		 |$LN1@UfnPdd_Ini@3|

; 4051 :     }
; 4052 : 
; 4053 : #ifdef CPPI_DMA_SUPPORT
; 4054 : 
; 4055 :     /* Initialize the DMA Controller Object */
; 4056 :     pPdd->pDmaCntrl = cppiControllerInit(pPdd);

  0003c	eb000000	 bl          cppiControllerInit

; 4057 : 
; 4058 : #endif /* #ifdef CPPI_DMA_SUPPORT *
; 4059 : 
; 4060 :     /* Set PDD interface */
; 4061 :     pPddIfc->dwVersion = UFN_PDD_INTERFACE_VERSION;
; 4062 :     pPddIfc->dwCapabilities = UFN_PDD_CAPS_SUPPORTS_FULL_SPEED | UFN_PDD_CAPS_SUPPORTS_ALTERNATE_INTERFACES;
; 4063 : #ifndef UFN_DISABLE_HIGH_SPEED
; 4064 :     pPddIfc->dwCapabilities |= UFN_PDD_CAPS_SUPPORTS_HIGH_SPEED;
; 4065 : #endif
; 4066 :     pPddIfc->dwEndpointCount = USBD_EP_COUNT;
; 4067 :     pPddIfc->pvPddContext = pPdd;
; 4068 :     pPddIfc->pfnDeinit = UfnPdd_Deinit;
; 4069 :     pPddIfc->pfnIsConfigurationSupportable = UfnPdd_IsConfigurationSupportable;
; 4070 :     pPddIfc->pfnIsEndpointSupportable = UfnPdd_IsEndpointSupportable;
; 4071 :     pPddIfc->pfnInitEndpoint = UfnPdd_InitEndpoint;
; 4072 :     pPddIfc->pfnRegisterDevice = UfnPdd_RegisterDevice;
; 4073 :     pPddIfc->pfnDeregisterDevice = UfnPdd_DeregisterDevice;
; 4074 :     pPddIfc->pfnStart = UfnPdd_Start;
; 4075 :     pPddIfc->pfnStop = UfnPdd_Stop;
; 4076 :     pPddIfc->pfnIssueTransfer = UfnPdd_IssueTransfer;
; 4077 :     pPddIfc->pfnAbortTransfer = UfnPdd_AbortTransfer;
; 4078 :     pPddIfc->pfnDeinitEndpoint = UfnPdd_DeinitEndpoint;
; 4079 :     pPddIfc->pfnStallEndpoint = UfnPdd_StallEndpoint;
; 4080 :     pPddIfc->pfnClearEndpointStall = UfnPdd_ClearEndpointStall;
; 4081 :     pPddIfc->pfnSendControlStatusHandshake = UfnPdd_SendControlStatusHandshake;
; 4082 :     pPddIfc->pfnSetAddress = UfnPdd_SetAddress;
; 4083 :     pPddIfc->pfnIsEndpointHalted = UfnPdd_IsEndpointHalted;
; 4084 :     pPddIfc->pfnInitiateRemoteWakeup = UfnPdd_InitiateRemoteWakeup;
; 4085 :     pPddIfc->pfnPowerDown = UfnPdd_PowerDown;
; 4086 :     pPddIfc->pfnPowerUp = UfnPdd_PowerUp;
; 4087 :     pPddIfc->pfnIOControl = UfnPdd_IOControl;

  00040	e59d3000	 ldr         r3, [sp]
  00044	e3a02806	 mov         r2, #6, 16
  00048	e59f1138	 ldr         r1, [pc, #0x138]
  0004c	e583065c	 str         r0, [r3, #0x65C]
  00050	e59d3004	 ldr         r3, [sp, #4]
  00054	e3a0000b	 mov         r0, #0xB
  00058	e59fe124	 ldr         lr, [pc, #0x124]
  0005c	e5830004	 str         r0, [r3, #4]
  00060	e59d0000	 ldr         r0, [sp]
  00064	e5832000	 str         r2, [r3]
  00068	e3a02010	 mov         r2, #0x10
  0006c	e583000c	 str         r0, [r3, #0xC]
  00070	e5832008	 str         r2, [r3, #8]
  00074	e59f3104	 ldr         r3, [pc, #0x104]
  00078	e59d2004	 ldr         r2, [sp, #4]
  0007c	e59f40f8	 ldr         r4, [pc, #0xF8]
  00080	e59f50f0	 ldr         r5, [pc, #0xF0]
  00084	e5823010	 str         r3, [r2, #0x10]
  00088	e59f20e4	 ldr         r2, [pc, #0xE4]
  0008c	e59d3004	 ldr         r3, [sp, #4]
  00090	e59f60d8	 ldr         r6, [pc, #0xD8]
  00094	e59f70d0	 ldr         r7, [pc, #0xD0]
  00098	e5832014	 str         r2, [r3, #0x14]
  0009c	e1a02003	 mov         r2, r3
  000a0	e59f30c0	 ldr         r3, [pc, #0xC0]
  000a4	e59f80b8	 ldr         r8, [pc, #0xB8]
  000a8	e59f90b0	 ldr         r9, [pc, #0xB0]
  000ac	e5823040	 str         r3, [r2, #0x40]
  000b0	e59f30a4	 ldr         r3, [pc, #0xA4]
  000b4	e59fa09c	 ldr         r10, [pc, #0x9C]
  000b8	e59fb094	 ldr         r11, [pc, #0x94]
  000bc	e5823044	 str         r3, [r2, #0x44]
  000c0	e59f3088	 ldr         r3, [pc, #0x88]
  000c4	e282c018	 add         r12, r2, #0x18
  000c8	e88c4002	 stmia       r12, {r1, lr}
  000cc	e5823048	 str         r3, [r2, #0x48]
  000d0	e59f3074	 ldr         r3, [pc, #0x74]
  000d4	e282c020	 add         r12, r2, #0x20
  000d8	e88c0ff0	 stmia       r12, {r4 - r11}

; 4088 : 
; 4089 :     /* Save MDD context & notify function */
; 4090 :     pPdd->pMddContext = pMddContext;
; 4091 :     pPdd->pfnNotify = pMddIfc->pfnNotify;
; 4092 :     pPdd->attachState = UFN_DETACH;
; 4093 :     pPdd->resetComplete = FALSE;
; 4094 : 
; 4095 :     /* Default EP0 State */
; 4096 :     pPdd->ep[0].epStage = MGC_END0_STAGE_SETUP;
; 4097 :     pPdd->fWaitingForHandshake = FALSE;
; 4098 : 
; 4099 :     PRINTMSG(ZONE_FUNCTION, (L"-UfnPdd_Init\r\n"));
; 4100 : 
; 4101 :     /* Done */
; 4102 :     rc = ERROR_SUCCESS;

  000dc	e3a04000	 mov         r4, #0
  000e0	e582304c	 str         r3, [r2, #0x4C]
  000e4	e59f305c	 ldr         r3, [pc, #0x5C]
  000e8	e5823050	 str         r3, [r2, #0x50]
  000ec	e59f3050	 ldr         r3, [pc, #0x50]
  000f0	e5823054	 str         r3, [r2, #0x54]
  000f4	e59f3044	 ldr         r3, [pc, #0x44]
  000f8	e5823058	 str         r3, [r2, #0x58]
  000fc	e59f3038	 ldr         r3, [pc, #0x38]
  00100	e582305c	 str         r3, [r2, #0x5C]
  00104	e59d3008	 ldr         r3, [sp, #8]
  00108	e3a02000	 mov         r2, #0
  0010c	e5803010	 str         r3, [r0, #0x10]
  00110	e59d300c	 ldr         r3, [sp, #0xC]
  00114	e5933004	 ldr         r3, [r3, #4]
  00118	e5803014	 str         r3, [r0, #0x14]
  0011c	e580203c	 str         r2, [r0, #0x3C]
  00120	e5802038	 str         r2, [r0, #0x38]
  00124	e58022a0	 str         r2, [r0, #0x2A0]
  00128	e580264c	 str         r2, [r0, #0x64C]
  0012c		 |$cleanUp$48168|

; 4103 : cleanUp:
; 4104 :     return rc;
; 4105 : }

  0012c	e1a00004	 mov         r0, r4
  00130	e28dd010	 add         sp, sp, #0x10
  00134	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00138	e12fff1e	 bx          lr
  0013c		 |$LN7@UfnPdd_Ini@3|
  0013c		 |$LN8@UfnPdd_Ini@3|
  0013c	00000000	 DCD         |UfnPdd_IOControl|
  00140		 |$LN9@UfnPdd_Ini@3|
  00140	00000000	 DCD         |UfnPdd_PowerUp|
  00144		 |$LN10@UfnPdd_Ini@3|
  00144	00000000	 DCD         |UfnPdd_PowerDown|
  00148		 |$LN11@UfnPdd_Ini@3|
  00148	00000000	 DCD         |UfnPdd_InitiateRemoteWakeup|
  0014c		 |$LN12@UfnPdd_Ini@3|
  0014c	00000000	 DCD         |UfnPdd_IsEndpointHalted|
  00150		 |$LN13@UfnPdd_Ini@3|
  00150	00000000	 DCD         |UfnPdd_SetAddress|
  00154		 |$LN14@UfnPdd_Ini@3|
  00154	00000000	 DCD         |UfnPdd_StallEndpoint|
  00158		 |$LN15@UfnPdd_Ini@3|
  00158	00000000	 DCD         |UfnPdd_DeinitEndpoint|
  0015c		 |$LN16@UfnPdd_Ini@3|
  0015c	00000000	 DCD         |UfnPdd_SendControlStatusHandshake|
  00160		 |$LN17@UfnPdd_Ini@3|
  00160	00000000	 DCD         |UfnPdd_AbortTransfer|
  00164		 |$LN18@UfnPdd_Ini@3|
  00164	00000000	 DCD         |UfnPdd_IssueTransfer|
  00168		 |$LN19@UfnPdd_Ini@3|
  00168	00000000	 DCD         |UfnPdd_ClearEndpointStall|
  0016c		 |$LN20@UfnPdd_Ini@3|
  0016c	00000000	 DCD         |UfnPdd_Stop|
  00170		 |$LN21@UfnPdd_Ini@3|
  00170	00000000	 DCD         |UfnPdd_Start|
  00174		 |$LN22@UfnPdd_Ini@3|
  00174	00000000	 DCD         |UfnPdd_IsConfigurationSupportable|
  00178		 |$LN23@UfnPdd_Ini@3|
  00178	00000000	 DCD         |UfnPdd_DeregisterDevice|
  0017c		 |$LN24@UfnPdd_Ini@3|
  0017c	00000000	 DCD         |UfnPdd_RegisterDevice|
  00180		 |$LN25@UfnPdd_Ini@3|
  00180	00000000	 DCD         |UfnPdd_Deinit|
  00184		 |$LN26@UfnPdd_Ini@3|
  00184	00000000	 DCD         |UfnPdd_InitEndpoint|
  00188		 |$LN27@UfnPdd_Ini@3|
  00188	00000000	 DCD         |UfnPdd_IsEndpointSupportable|
  0018c		 |$M49427|

			 ENDP  ; |UfnPdd_Init|

	END
