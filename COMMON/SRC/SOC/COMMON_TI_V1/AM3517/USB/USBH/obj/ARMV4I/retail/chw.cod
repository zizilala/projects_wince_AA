; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\AM3517\USB\USBH\chw.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|?g_hUsbProcessingEvent@@3PAXA| [ DATA ] ; g_hUsbProcessingEvent
	EXPORT	|?m_pChw@CHW@@2PAV1@A| [ DATA ]		; CHW::m_pChw

  00000			 AREA	 |.bss|, NOINIT
|?g_hUsbProcessingEvent@@3PAXA| % 0x4			; g_hUsbProcessingEvent
|?m_pChw@CHW@@2PAV1@A| % 0x4				; CHW::m_pChw
	EXPORT	|SetEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T42856| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42853|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M42854|

			 ENDP  ; |SetEvent|

	EXPORT	|?LockProcessingThread@CHW@@QAAXXZ|	; CHW::LockProcessingThread
	IMPORT	|EnterCriticalSection|
; File c:\wince600\platform\common\src\soc\common_ti_v1\am3517\usb\usbh\chw.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T42864| DCD	|$LN5@LockProces|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?LockProcessingThread@CHW@@QAAXXZ| PROC ; CHW::LockProcessingThread

; 124  :     void LockProcessingThread() { EnterCriticalSection(&m_csUsbProcLock); }

  00000		 |$LN5@LockProces|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42861|
  00004	e2800f89	 add         r0, r0, #0x89, 30
  00008	eb000000	 bl          EnterCriticalSection
  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M42862|

			 ENDP  ; |?LockProcessingThread@CHW@@QAAXXZ|, CHW::LockProcessingThread

	EXPORT	|?UnlockProcessingThread@CHW@@QAAXXZ|	; CHW::UnlockProcessingThread
	IMPORT	|LeaveCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T42872| DCD	|$LN5@UnlockProc|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UnlockProcessingThread@CHW@@QAAXXZ| PROC ; CHW::UnlockProcessingThread

; 125  :     void UnlockProcessingThread() { LeaveCriticalSection(&m_csUsbProcLock); }

  00000		 |$LN5@UnlockProc|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42869|
  00004	e2800f89	 add         r0, r0, #0x89, 30
  00008	eb000000	 bl          LeaveCriticalSection
  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M42870|

			 ENDP  ; |?UnlockProcessingThread@CHW@@QAAXXZ|, CHW::UnlockProcessingThread

	EXPORT	|?Byte2FifoSize@CHW@@AAAEG@Z|		; CHW::Byte2FifoSize

  00000			 AREA	 |.pdata|, PDATA
|$T42886| DCD	|$LN12@Byte2FifoS|
	DCD	0x40000c00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Byte2FifoSize@CHW@@AAAEG@Z| PROC	; CHW::Byte2FifoSize

; 225  :     {

  00000		 |$LN12@Byte2FifoS|
  00000		 |$M42883|
  00000	e1a02001	 mov         r2, r1

; 226  :         for (UINT8 i = 0; i < 10; i ++)

  00004	e3a00000	 mov         r0, #0
  00008	e3a01001	 mov         r1, #1
  0000c		 |$LL4@Byte2FifoS|

; 227  :         {
; 228  :             if (bs == (1 << (i + 3)))

  0000c	e2803003	 add         r3, r0, #3
  00010	e1520311	 cmp         r2, r1, lsl r3
  00014	0a000004	 beq         |$LN8@Byte2FifoS|
  00018	e2803001	 add         r3, r0, #1
  0001c	e20300ff	 and         r0, r3, #0xFF
  00020	e350000a	 cmp         r0, #0xA
  00024	3afffff8	 bcc         |$LL4@Byte2FifoS|

; 229  :             {
; 230  :                 return i;
; 231  :             }
; 232  :         }
; 233  : 
; 234  :         return (UINT8)-1;

  00028	e3a000ff	 mov         r0, #0xFF
  0002c		 |$LN8@Byte2FifoS|

; 235  :     }

  0002c	e12fff1e	 bx          lr
  00030		 |$M42884|

			 ENDP  ; |?Byte2FifoSize@CHW@@AAAEG@Z|, CHW::Byte2FifoSize

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?memdump@@YAXPAEGG@Z|			; memdump
	EXPORT	|??_C@_15MAOEGKJF@?$AA?$CF?$AAS?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_02KNHHEEKP@?5?5?$AA@| [ DATA ]	; `string'
	EXPORT	|??_C@_03NDEAONJP@?5?5?5?$AA@| [ DATA ]	; `string'
	EXPORT	|??_C@_01CLKCMJKC@?5?$AA@| [ DATA ]	; `string'
	EXPORT	|??_C@_02LMMGGCAJ@?3?5?$AA@| [ DATA ]	; `string'
	IMPORT	|NKDbgPrintfW|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|strlen|
	IMPORT	|strcat|
	IMPORT	|__security_check_cookie|
; File c:\wince600\platform\common\src\soc\common_ti_v1\am3517\usb\usbh\chw.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T42930| DCD	|$LN43@memdump|
	DCD	0xc0009e02

  00000			 AREA	 |.xdata|, DATA
|$T42926| DCD	0xffffffd8

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_15MAOEGKJF@?$AA?$CF?$AAS?$AA?$AA@| DCB "%", 0x0, "S", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_02KNHHEEKP@?5?5?$AA@| DCB "  ", 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_03NDEAONJP@?5?5?5?$AA@| DCB "   ", 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_01CLKCMJKC@?5?$AA@| DCB " ", 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_02LMMGGCAJ@?3?5?$AA@| DCB ": ", 0x0		; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T42926|

  00008		 |?memdump@@YAXPAEGG@Z| PROC		; memdump

; 73   : {    

  00008		 |$LN43@memdump|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd07c	 sub         sp, sp, #0x7C
  00010		 |$M42927|
  00010	e1a09002	 mov         r9, r2
  00014	e1cd90b0	 strh        r9, [sp]
  00018	e1a08000	 mov         r8, r0
  0001c	e59f3258	 ldr         r3, [pc, #0x258]
  00020	e5933000	 ldr         r3, [r3]
  00024	e58d3078	 str         r3, [sp, #0x78]

; 74   :     unsigned short i,j,l;
; 75   :     unsigned char tmp_str[100];
; 76   :     unsigned char tmp_str1[10];
; 77   :     for (i = 0; i < num_bytes; i += 16){

  00028	e3a05000	 mov         r5, #0
  0002c	e1b07001	 movs        r7, r1
  00030	0a000087	 beq         |$LN22@memdump|
  00034	e3a0a000	 mov         r10, #0
  00038	e58da004	 str         r10, [sp, #4]
  0003c	e3a02000	 mov         r2, #0
  00040	e28de017	 add         lr, sp, #0x17
  00044	e28d4017	 add         r4, sp, #0x17
  00048	e3a06000	 mov         r6, #0
  0004c	e28db014	 add         r11, sp, #0x14
  00050		 |$LL24@memdump|

; 78   :         unsigned short n ;
; 79   :         tmp_str[0]='\0';
; 80   :         n = i+offset ;

  00050	e089300a	 add         r3, r9, r10
  00054	e1a01803	 mov         r1, r3, lsl #16
  00058	e5cd2014	 strb        r2, [sp, #0x14]
  0005c	e1a01821	 mov         r1, r1, lsr #16

; 81   :         for (j=0; j<4; j++) {

  00060	e3a02000	 mov         r2, #0
  00064	e3a00000	 mov         r0, #0
  00068		 |$LL21@memdump|

; 82   :             l=n%16;

  00068	e1b03001	 movs        r3, r1
  0006c	4283300f	 addmi       r3, r3, #0xF
  00070	e1a03243	 mov         r3, r3, asr #4
  00074	e0413203	 sub         r3, r1, r3, lsl #4
  00078	e1a03803	 mov         r3, r3, lsl #16
  0007c	e1a03823	 mov         r3, r3, lsr #16

; 83   :             if (l>=10)

  00080	e353000a	 cmp         r3, #0xA

; 84   :             tmp_str[3-j]=(unsigned char)('A'+l-10);

  00084	22833037	 addcs       r3, r3, #0x37
  00088	274e3002	 strcsb      r3, [lr, -r2]

; 85   :             else
; 86   :             tmp_str[3-j]=(unsigned char)(l+'0');

  0008c	32833030	 addcc       r3, r3, #0x30
  00090	37443002	 strccb      r3, [r4, -r2]
  00094	e2803001	 add         r3, r0, #1
  00098	e1a02803	 mov         r2, r3, lsl #16

; 87   :             n >>= 4 ;

  0009c	e1a03221	 mov         r3, r1, lsr #4
  000a0	e1a01803	 mov         r1, r3, lsl #16
  000a4	e1a02822	 mov         r2, r2, lsr #16
  000a8	e1a01821	 mov         r1, r1, lsr #16
  000ac	e1a00002	 mov         r0, r2
  000b0	e3520004	 cmp         r2, #4
  000b4	3affffeb	 bcc         |$LL21@memdump|

; 88   :         }
; 89   :         tmp_str[4]='\0';
; 90   :         strcat ( (char *)tmp_str, ": ");

  000b8	e59f11b8	 ldr         r1, [pc, #0x1B8]
  000bc	e28d0014	 add         r0, sp, #0x14
  000c0	e5cd6018	 strb        r6, [sp, #0x18]
  000c4	eb000000	 bl          strcat

; 91   :         /*          Output the hex bytes        */
; 92   :         for (j = i; j < (i+16); j++) {

  000c8	e2856010	 add         r6, r5, #0x10
  000cc	e1550006	 cmp         r5, r6
  000d0	e1a04005	 mov         r4, r5
  000d4	aa00001e	 bge         |$LN14@memdump|
  000d8	e1a03005	 mov         r3, r5
  000dc	e3a0b000	 mov         r11, #0
  000e0		 |$LL16@memdump|

; 93   :             int m ;
; 94   :             if (j < num_bytes)  {

  000e0	e1540007	 cmp         r4, r7
  000e4	2a000010	 bcs         |$LN13@memdump|

; 95   :                 m=((unsigned int)((unsigned char)*(data+j)))/16 ;

  000e8	e7d32008	 ldrb        r2, [r3, +r8]

; 96   :                 if (m>=10)
; 97   :                     tmp_str1[0]='A'+(unsigned char)m-10;
; 98   :                 else
; 99   :                     tmp_str1[0]=(unsigned char)m+'0';
; 100  :                 m=((unsigned int)((unsigned char)*(data+j)))%16 ;
; 101  :                 if (m>=10)
; 102  :                     tmp_str1[1]='A'+(unsigned char)m-10;
; 103  :                 else
; 104  :                     tmp_str1[1]=(unsigned char)m+'0';
; 105  :                 tmp_str1[2]='\0';
; 106  :                 strcat ((char *)tmp_str, (char *)tmp_str1);

  000ec	e28d1008	 add         r1, sp, #8
  000f0	e28d0014	 add         r0, sp, #0x14
  000f4	e1a03222	 mov         r3, r2, lsr #4
  000f8	e353000a	 cmp         r3, #0xA
  000fc	a2833037	 addge       r3, r3, #0x37
  00100	b2833030	 addlt       r3, r3, #0x30
  00104	e5cd3008	 strb        r3, [sp, #8]
  00108	e202300f	 and         r3, r2, #0xF
  0010c	e353000a	 cmp         r3, #0xA
  00110	a2833037	 addge       r3, r3, #0x37
  00114	b2833030	 addlt       r3, r3, #0x30
  00118	e5cd3009	 strb        r3, [sp, #9]
  0011c	e5cdb00a	 strb        r11, [sp, #0xA]
  00120	eb000000	 bl          strcat

; 107  :                 strcat ((char *)tmp_str, " ");

  00124	e59f1148	 ldr         r1, [pc, #0x148]

; 108  :             }
; 109  :             else {

  00128	ea000000	 b           |$LN39@memdump|
  0012c		 |$LN13@memdump|

; 110  :                 strcat((char *)tmp_str,"   ");

  0012c	e59f113c	 ldr         r1, [pc, #0x13C]
  00130		 |$LN39@memdump|
  00130	e28d0014	 add         r0, sp, #0x14
  00134	eb000000	 bl          strcat
  00138	e2843001	 add         r3, r4, #1
  0013c	e1a04803	 mov         r4, r3, lsl #16
  00140	e1a04824	 mov         r4, r4, lsr #16
  00144	e1a03004	 mov         r3, r4
  00148	e1540006	 cmp         r4, r6
  0014c	baffffe3	 blt         |$LL16@memdump|
  00150	e28db014	 add         r11, sp, #0x14
  00154		 |$LN14@memdump|

; 111  :             }
; 112  :         }
; 113  :         strcat((char *)tmp_str, "  ");

  00154	e59f1110	 ldr         r1, [pc, #0x110]
  00158	e28d0014	 add         r0, sp, #0x14
  0015c	eb000000	 bl          strcat

; 114  :         l=(unsigned short)strlen((char *)tmp_str);

  00160	e28d0014	 add         r0, sp, #0x14
  00164	eb000000	 bl          strlen
  00168	e1a01800	 mov         r1, r0, lsl #16
  0016c	e1a01821	 mov         r1, r1, lsr #16

; 115  : 
; 116  :         /*         * Output the ASCII bytes        */
; 117  :         for (j = i; j < (i+16); j++){

  00170	e1550006	 cmp         r5, r6
  00174	aa000019	 bge         |$LN5@memdump|
  00178	e1a03005	 mov         r3, r5
  0017c	e28d9014	 add         r9, sp, #0x14
  00180	e3a0a020	 mov         r10, #0x20
  00184		 |$LL7@memdump|

; 118  :             if (j < num_bytes){

  00184	e1550007	 cmp         r5, r7
  00188	2a000008	 bcs         |$LN4@memdump|

; 119  :                 char c = *(data+j);

  0018c	e19330d8	 ldrsb       r3, [r3, +r8]
  00190	e1a02003	 mov         r2, r3

; 120  :                 if (c < ' ' || c > 'z')

  00194	e3520020	 cmp         r2, #0x20
  00198	ba000001	 blt         |$LN2@memdump|
  0019c	e352007a	 cmp         r2, #0x7A
  001a0	da000000	 ble         |$LN3@memdump|
  001a4		 |$LN2@memdump|

; 121  :                     c = '.';

  001a4	e3a0202e	 mov         r2, #0x2E
  001a8		 |$LN3@memdump|

; 122  :                 tmp_str[l++]=c;

  001a8	e7c12009	 strb        r2, [r1, +r9]

; 123  :             }
; 124  :             else

  001ac	ea000000	 b           |$LN40@memdump|
  001b0		 |$LN4@memdump|

; 125  :                 tmp_str[l++]=' ';

  001b0	e7c1a00b	 strb        r10, [r1, +r11]
  001b4		 |$LN40@memdump|
  001b4	e2813001	 add         r3, r1, #1
  001b8	e1a01803	 mov         r1, r3, lsl #16
  001bc	e2853001	 add         r3, r5, #1
  001c0	e1a05803	 mov         r5, r3, lsl #16
  001c4	e1a05825	 mov         r5, r5, lsr #16
  001c8	e1a03005	 mov         r3, r5
  001cc	e1550006	 cmp         r5, r6
  001d0	e1a01821	 mov         r1, r1, lsr #16
  001d4	baffffea	 blt         |$LL7@memdump|
  001d8	e1dd90b0	 ldrh        r9, [sp]

; 126  :         }
; 127  :         tmp_str[l++]='\r';        tmp_str[l++]='\n';        tmp_str[l++]='\0';
; 128  :         RETAILMSG(1, (L"%S", tmp_str));    

  001dc	e59da004	 ldr         r10, [sp, #4]
  001e0		 |$LN5@memdump|
  001e0	e28d2014	 add         r2, sp, #0x14
  001e4	e3a0000d	 mov         r0, #0xD
  001e8	e2813001	 add         r3, r1, #1
  001ec	e7c10002	 strb        r0, [r1, +r2]
  001f0	e1a02803	 mov         r2, r3, lsl #16
  001f4	e1a02822	 mov         r2, r2, lsr #16
  001f8	e2823001	 add         r3, r2, #1
  001fc	e28d1014	 add         r1, sp, #0x14
  00200	e3a0000a	 mov         r0, #0xA
  00204	e1a03803	 mov         r3, r3, lsl #16
  00208	e7c20001	 strb        r0, [r2, +r1]
  0020c	e59f0054	 ldr         r0, [pc, #0x54]
  00210	e1a03823	 mov         r3, r3, lsr #16
  00214	e28d2014	 add         r2, sp, #0x14
  00218	e3a01000	 mov         r1, #0
  0021c	e7c31002	 strb        r1, [r3, +r2]
  00220	e28d1014	 add         r1, sp, #0x14
  00224	eb000000	 bl          NKDbgPrintfW
  00228	e28a3010	 add         r3, r10, #0x10
  0022c	e1a05803	 mov         r5, r3, lsl #16
  00230	e1a05825	 mov         r5, r5, lsr #16
  00234	e1a0a005	 mov         r10, r5
  00238	e58da004	 str         r10, [sp, #4]
  0023c	e1550007	 cmp         r5, r7
  00240	e28de017	 add         lr, sp, #0x17
  00244	e28d4017	 add         r4, sp, #0x17
  00248	e3a02000	 mov         r2, #0
  0024c	e3a06000	 mov         r6, #0
  00250	3affff7e	 bcc         |$LL24@memdump|
  00254		 |$LN22@memdump|

; 73   : {    

  00254	e59d0078	 ldr         r0, [sp, #0x78]
  00258	eb000000	 bl          __security_check_cookie

; 129  :     }
; 130  : }

  0025c	e28dd07c	 add         sp, sp, #0x7C
  00260	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00264	e12fff1e	 bx          lr
  00268		 |$LN44@memdump|
  00268		 |$LN45@memdump|
  00268	00000000	 DCD         |??_C@_15MAOEGKJF@?$AA?$CF?$AAS?$AA?$AA@|
  0026c		 |$LN46@memdump|
  0026c	00000000	 DCD         |??_C@_02KNHHEEKP@?5?5?$AA@|
  00270		 |$LN47@memdump|
  00270	00000000	 DCD         |??_C@_03NDEAONJP@?5?5?5?$AA@|
  00274		 |$LN48@memdump|
  00274	00000000	 DCD         |??_C@_01CLKCMJKC@?5?$AA@|
  00278		 |$LN49@memdump|
  00278	00000000	 DCD         |??_C@_02LMMGGCAJ@?3?5?$AA@|
  0027c		 |$LN50@memdump|
  0027c	00000000	 DCD         |__security_cookie|
  00280		 |$M42928|

			 ENDP  ; |?memdump@@YAXPAEGG@Z|, memdump

	EXPORT	|?ReadFIFO@@YAHPAKPAXK@Z|		; ReadFIFO

  00000			 AREA	 |.pdata|, PDATA
|$T42960| DCD	|$LN16@ReadFIFO|
	DCD	0x40001201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ReadFIFO@@YAHPAKPAXK@Z| PROC		; ReadFIFO

; 133  : {

  00000		 |$LN16@ReadFIFO|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42957|

; 134  :     DWORD total  = size / 4;

  00004	e1b0e122	 movs        lr, r2, lsr #2

; 135  :     DWORD remain = size % 4;

  00008	e2022003	 and         r2, r2, #3

; 136  :     DWORD i		 = 0;
; 137  : 
; 138  :     DWORD* pDword = (DWORD*)pData;
; 139  : 
; 140  :     volatile ULONG *pReg = (volatile ULONG*)pFifoBase;
; 141  : 
; 142  :     // this is 32-bit align
; 143  :     for (i = 0; i < total; i++)

  0000c	0a000003	 beq         |$LN4@ReadFIFO|
  00010		 |$LL6@ReadFIFO|

; 144  :     {
; 145  :         *pDword++ = INREG32(pReg);

  00010	e5903000	 ldr         r3, [r0]
  00014	e25ee001	 subs        lr, lr, #1
  00018	e4813004	 str         r3, [r1], #4
  0001c	1afffffb	 bne         |$LL6@ReadFIFO|
  00020		 |$LN4@ReadFIFO|

; 146  :     }
; 147  :         
; 148  :     // Set the pByte equal to the last bytes of data being transferred
; 149  :     if (remain != 0)

  00020	e3520000	 cmp         r2, #0
  00024	0a000004	 beq         |$LN12@ReadFIFO|

; 150  :     {
; 151  :         UCHAR* pUCHAR = (UCHAR*) pDword;
; 152  :         DWORD dwTemp = INREG32(pReg);

  00028	e5903000	 ldr         r3, [r0]
  0002c		 |$LL2@ReadFIFO|

; 153  :         
; 154  :         while (remain--)
; 155  :         {
; 156  :             *pUCHAR++ = (UCHAR) (dwTemp & 0xFF);

  0002c	e4c13001	 strb        r3, [r1], #1

; 157  :             dwTemp>>=8;

  00030	e1a03423	 mov         r3, r3, lsr #8
  00034	e2522001	 subs        r2, r2, #1
  00038	1afffffb	 bne         |$LL2@ReadFIFO|
  0003c		 |$LN12@ReadFIFO|

; 158  :         }
; 159  :     }
; 160  : /*
; 161  :     RETAILMSG(1,(TEXT("Read fifo\r\n")));
; 162  :     memdump((UCHAR*)pData,(USHORT)size,0);
; 163  :     RETAILMSG(1,(TEXT("\r\n")));
; 164  : */
; 165  :     return TRUE;

  0003c	e3a00001	 mov         r0, #1

; 166  : }

  00040	e49de004	 ldr         lr, [sp], #4
  00044	e12fff1e	 bx          lr
  00048		 |$M42958|

			 ENDP  ; |?ReadFIFO@@YAHPAKPAXK@Z|, ReadFIFO

	EXPORT	|?WriteFIFO@@YAHPAKPAXK@Z|		; WriteFIFO

  00000			 AREA	 |.pdata|, PDATA
|$T42978| DCD	|$LN13@WriteFIFO|
	DCD	0x40001301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?WriteFIFO@@YAHPAKPAXK@Z| PROC	; WriteFIFO

; 169  : {

  00000		 |$LN13@WriteFIFO|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42975|

; 170  :     DWORD total					= size / 4;

  00004	e1b0e122	 movs        lr, r2, lsr #2

; 171  :     DWORD remain				= size % 4;

  00008	e2022003	 and         r2, r2, #3

; 172  :     DWORD i						= 0;
; 173  :     DWORD* pDword				= (DWORD*)pData;
; 174  : 
; 175  :     volatile ULONG *pReg = (volatile ULONG*)pFifoBase;
; 176  : 
; 177  :     // Critical section would be handled outside
; 178  :     DEBUGMSG(ZONE_VERBOSE, (TEXT("WriteFIFO: total (0x%x), remain (0x%x), size(0x%x)\r\n"), total, remain, size));    
; 179  : /*
; 180  :     memdump((UCHAR*)pData,(USHORT)size,0);
; 181  :     RETAILMSG(1,(TEXT("\r\n")));
; 182  : */
; 183  :     // this is 32-bit align
; 184  :     for (i = 0; i < total; i++)

  0000c	0a000003	 beq         |$LN4@WriteFIFO|
  00010		 |$LL6@WriteFIFO|

; 185  :     {
; 186  :         OUTREG32(pReg, *pDword++);

  00010	e4913004	 ldr         r3, [r1], #4
  00014	e25ee001	 subs        lr, lr, #1
  00018	e5803000	 str         r3, [r0]
  0001c	1afffffb	 bne         |$LL6@WriteFIFO|
  00020		 |$LN4@WriteFIFO|

; 187  :     }
; 188  : 
; 189  :     // Set the pByte equal to the last bytes of data being transferred
; 190  :     if (remain != 0)

  00020	e3520000	 cmp         r2, #0
  00024	0a000005	 beq         |$LN1@WriteFIFO|

; 191  :     {
; 192  :         // Pointer to the first byte of data
; 193  :         USHORT *pWORD =(USHORT *)pDword;
; 194  : 
; 195  :         // Finally if there is remain
; 196  :         if (remain & 0x2)  // either 2 or 3

  00028	e3120002	 tst         r2, #2

; 197  :         {
; 198  :             // Write 2 bytes to there
; 199  :             OUTREG16(pReg, *pWORD++);        

  0002c	10d130b2	 ldrneh      r3, [r1], #2
  00030	11c030b0	 strneh      r3, [r0]

; 200  :         }
; 201  : 
; 202  :         if (remain & 0x1)

  00034	e3120001	 tst         r2, #1

; 203  :         {
; 204  :             // Write 1 byte to there
; 205  :             OUTREG8(pReg, *((UCHAR*)pWORD));

  00038	15d13000	 ldrneb      r3, [r1]
  0003c	15c03000	 strneb      r3, [r0]
  00040		 |$LN1@WriteFIFO|

; 206  :         }
; 207  :     }
; 208  :     return TRUE;

  00040	e3a00001	 mov         r0, #1

; 209  : }

  00044	e49de004	 ldr         lr, [sp], #4
  00048	e12fff1e	 bx          lr
  0004c		 |$M42976|

			 ENDP  ; |?WriteFIFO@@YAHPAKPAXK@Z|, WriteFIFO

	EXPORT	|?DeInitialize@CHW@@UAAXXZ|		; CHW::DeInitialize
	IMPORT	|?Deinitialize@CCppiDmaController@@QAAXXZ| ; CCppiDmaController::Deinitialize
	IMPORT	|InterruptDisable|
	IMPORT	|CloseHandle|
	IMPORT	|TerminateThread|
	IMPORT	|WaitForSingleObject|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T42998| DCD	|$LN18@DeInitiali|
	DCD	0x40004701
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\am3517\usb\usbh\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DeInitialize@CHW@@UAAXXZ| PROC	; CHW::DeInitialize

; 428  : {

  00000		 |$LN18@DeInitiali|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M42995|
  00004	e1a04000	 mov         r4, r0

; 429  :     m_fUsbInterruptThreadClosing = TRUE; // tell USBInterruptThread that we are closing
; 430  :     DEBUGMSG( ZONE_INIT, (TEXT("+CHW::DeInitialize\r\n")));
; 431  : 
; 432  :     // Wake up the interrupt thread and give it time to die.
; 433  :     if ( m_hUsbInterruptEvent ) {

  00008	e5943170	 ldr         r3, [r4, #0x170]
  0000c	e3a02001	 mov         r2, #1
  00010	e5842180	 str         r2, [r4, #0x180]
  00014	e3530000	 cmp         r3, #0
  00018	e3a07c13	 mov         r7, #0x13, 24
  0001c	e3a06000	 mov         r6, #0
  00020	0a000015	 beq         |$LN7@DeInitiali|

; 434  : 
; 435  :         SetEvent(m_hUsbInterruptEvent);

  00024	e3a01003	 mov         r1, #3
  00028	e1a00003	 mov         r0, r3
  0002c	eb000000	 bl          EventModify

; 436  :         if ( m_hUsbInterruptThread ) {

  00030	e5943174	 ldr         r3, [r4, #0x174]
  00034	e3530000	 cmp         r3, #0
  00038	0a000009	 beq         |$LN6@DeInitiali|

; 437  :             DWORD dwWaitReturn = WaitForSingleObject(m_hUsbInterruptThread, 5000);

  0003c	e3871088	 orr         r1, r7, #0x88
  00040	e1a00003	 mov         r0, r3
  00044	eb000000	 bl          WaitForSingleObject
  00048	e3500000	 cmp         r0, #0

; 438  :             if ( dwWaitReturn != WAIT_OBJECT_0 ) {
; 439  :                 DEBUGMSG( ZONE_ERROR, (TEXT("CHW::DeInitialize: m_hUsbInterruptThread didn't exit cleanly\r\n")));
; 440  :                 DEBUGCHK( 0 );
; 441  : #pragma prefast(suppress:258, "If we reach this code proper thread termination was attempted, but failed. So clean up by force is the last resort.")
; 442  : #pragma warning(push)
; 443  : #pragma warning(disable: 6258)
; 444  :                 TerminateThread(m_hUsbInterruptThread, DWORD(-1));

  0004c	15940174	 ldrne       r0, [r4, #0x174]
  00050	13e01000	 mvnne       r1, #0
  00054	1b000000	 blne        TerminateThread

; 445  : #pragma warning(pop)
; 446  :             }
; 447  :             CloseHandle(m_hUsbInterruptThread);

  00058	e5940174	 ldr         r0, [r4, #0x174]
  0005c	eb000000	 bl          CloseHandle

; 448  :             m_hUsbInterruptThread = NULL;

  00060	e5846174	 str         r6, [r4, #0x174]
  00064		 |$LN6@DeInitiali|

; 449  :         }
; 450  : 
; 451  :         // we have to close our interrupt before closing the event!
; 452  :         InterruptDisable( m_dwSysIntr );

  00064	e594016c	 ldr         r0, [r4, #0x16C]
  00068	eb000000	 bl          InterruptDisable

; 453  :         DEBUGMSG( ZONE_INIT, (TEXT("CHW::DeInitialize: closing event handle %x\r\n"), m_hUsbInterruptEvent));
; 454  :         CloseHandle(m_hUsbInterruptEvent);

  0006c	e5940170	 ldr         r0, [r4, #0x170]
  00070	eb000000	 bl          CloseHandle

; 455  :         m_hUsbInterruptEvent = NULL;

  00074	e5846170	 str         r6, [r4, #0x170]

; 456  :     } else {

  00078	ea000001	 b           |$LN4@DeInitiali|
  0007c		 |$LN7@DeInitiali|

; 457  :         InterruptDisable( m_dwSysIntr );

  0007c	e594016c	 ldr         r0, [r4, #0x16C]
  00080	eb000000	 bl          InterruptDisable
  00084		 |$LN4@DeInitiali|

; 458  :     }
; 459  : 
; 460  :     if ( m_hUsbHubChangeEvent) {

  00084	e594317c	 ldr         r3, [r4, #0x17C]
  00088	e3530000	 cmp         r3, #0
  0008c	0a000005	 beq         |$LN3@DeInitiali|

; 461  :         SetEvent(m_hUsbHubChangeEvent);

  00090	e3a01003	 mov         r1, #3
  00094	e1a00003	 mov         r0, r3
  00098	eb000000	 bl          EventModify

; 462  :         CloseHandle (m_hUsbHubChangeEvent);

  0009c	e594017c	 ldr         r0, [r4, #0x17C]
  000a0	eb000000	 bl          CloseHandle

; 463  :         m_hUsbHubChangeEvent = NULL;

  000a4	e584617c	 str         r6, [r4, #0x17C]
  000a8		 |$LN3@DeInitiali|

; 464  :     }
; 465  : 
; 466  :     if (m_hUsbProcessingThread)

  000a8	e5943178	 ldr         r3, [r4, #0x178]
  000ac	e3530000	 cmp         r3, #0
  000b0	0a000011	 beq         |$LN2@DeInitiali|

; 467  :     {
; 468  :         SetEvent(g_hUsbProcessingEvent);

  000b4	e59f505c	 ldr         r5, [pc, #0x5C]
  000b8	e3a01003	 mov         r1, #3
  000bc	e5950000	 ldr         r0, [r5]
  000c0	eb000000	 bl          EventModify

; 469  :         DWORD dwWaitReturn = WaitForSingleObject(m_hUsbProcessingThread, 5000);

  000c4	e5940178	 ldr         r0, [r4, #0x178]
  000c8	e3871088	 orr         r1, r7, #0x88
  000cc	eb000000	 bl          WaitForSingleObject
  000d0	e3500000	 cmp         r0, #0

; 470  :         if ( dwWaitReturn != WAIT_OBJECT_0 )
; 471  :         {
; 472  :             DEBUGCHK( 0 );
; 473  : #pragma prefast(suppress:258, "If we reach this code proper thread termination was attempted, but failed. So clean up by force is the last resort.")
; 474  : #pragma warning(push)
; 475  : #pragma warning(disable: 6258)
; 476  :             TerminateThread(m_hUsbProcessingThread, DWORD(-1));

  000d4	15940178	 ldrne       r0, [r4, #0x178]
  000d8	13e01000	 mvnne       r1, #0
  000dc	1b000000	 blne        TerminateThread

; 477  : #pragma warning(pop)
; 478  :         }
; 479  : 
; 480  :         CloseHandle(m_hUsbProcessingThread);

  000e0	e5940178	 ldr         r0, [r4, #0x178]
  000e4	eb000000	 bl          CloseHandle

; 481  :         m_hUsbProcessingThread = NULL;

  000e8	e5846178	 str         r6, [r4, #0x178]

; 482  :         CloseHandle(g_hUsbProcessingEvent);

  000ec	e5950000	 ldr         r0, [r5]
  000f0	eb000000	 bl          CloseHandle

; 483  :         g_hUsbProcessingEvent = NULL;

  000f4	e3a03000	 mov         r3, #0
  000f8	e5853000	 str         r3, [r5]
  000fc		 |$LN2@DeInitiali|

; 484  :     }
; 485  : 
; 486  :     m_fUsbInterruptThreadClosing = FALSE;
; 487  :     m_wFrameHigh = 0;

  000fc	e2843c01	 add         r3, r4, #1, 24

; 488  : 
; 489  : #ifdef MUSB_USEDMA
; 490  : 
; 491  :     // Deinitialize CPPI controller
; 492  :     m_dmaCrtl.Deinitialize();

  00100	e2840fca	 add         r0, r4, #0xCA, 30
  00104	e1c366b8	 strh        r6, [r3, #0x68]
  00108	e5846180	 str         r6, [r4, #0x180]
  0010c	eb000000	 bl          |?Deinitialize@CCppiDmaController@@QAAXXZ|

; 493  : 
; 494  : #endif // MUSB_USEDMA
; 495  : 
; 496  :     DEBUGMSG( ZONE_INIT, (TEXT("-CHW::DeInitialize\r\n")));
; 497  : }

  00110	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00114	e12fff1e	 bx          lr
  00118		 |$LN19@DeInitiali|
  00118		 |$LN20@DeInitiali|
  00118	00000000	 DCD         |?g_hUsbProcessingEvent@@3PAXA|
  0011c		 |$M42996|

			 ENDP  ; |?DeInitialize@CHW@@UAAXXZ|, CHW::DeInitialize

	EXPORT	|?EnterOperationalState@CHW@@QAAXXZ|	; CHW::EnterOperationalState
	EXPORT	|??_C@_1EG@HLJNPNJC@?$AAU?$AAS?$AAB?$AAH?$AA?3?$AA?5?$AAD?$AAE?$AAV?$AAC?$AAT?$AAL?$AA?5?$AAV?$AAB?$AAU?$AAS?$AA?5?$AAr?$AAe?$AAa?$AAd?$AAy?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$CB@| [ DATA ] ; `string'
	IMPORT	|Sleep|
	IMPORT	|GetTickCount|
	IMPORT	|USBHPDD_PowerVBUS|

  00000			 AREA	 |.pdata|, PDATA
|$T43018| DCD	|$LN18@EnterOpera|
	DCD	0x40003102

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EG@HLJNPNJC@?$AAU?$AAS?$AAB?$AAH?$AA?3?$AA?5?$AAD?$AAE?$AAV?$AAC?$AAT?$AAL?$AA?5?$AAV?$AAB?$AAU?$AAS?$AA?5?$AAr?$AAe?$AAa?$AAd?$AAy?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$CB@| DCB "U"
	DCB	0x0, "S", 0x0, "B", 0x0, "H", 0x0, ":", 0x0, " ", 0x0, "D"
	DCB	0x0, "E", 0x0, "V", 0x0, "C", 0x0, "T", 0x0, "L", 0x0, " "
	DCB	0x0, "V", 0x0, "B", 0x0, "U", 0x0, "S", 0x0, " ", 0x0, "r"
	DCB	0x0, "e", 0x0, "a", 0x0, "d", 0x0, "y", 0x0, " ", 0x0, "t"
	DCB	0x0, "i", 0x0, "m", 0x0, "e", 0x0, "o", 0x0, "u", 0x0, "t"
	DCB	0x0, "!", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?EnterOperationalState@CHW@@QAAXXZ| PROC ; CHW::EnterOperationalState

; 514  : {

  00000		 |$LN18@EnterOpera|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M43015|
  00008	e1a04000	 mov         r4, r0

; 515  :     DEBUGMSG( ZONE_INIT, (TEXT("+CHW::EnterOperationalState\n")));
; 516  : 
; 517  :     // Enable non-iso interrupts in CRTL register.
; 518  :     //WRITE_PORT_UCHAR( (m_portBase+USB_CTRL_REG_OFFSET), BIT3);
; 519  : 
; 520  :     // Enable interrupts in USBINTE (apart from SOF)
; 521  :     WRITE_PORT_UCHAR( (m_portBase+USB_INTRUSBE_REG_OFFSET), 0xf7);

  0000c	e5943140	 ldr         r3, [r4, #0x140]
  00010	e3a020f7	 mov         r2, #0xF7

; 522  : 
; 523  :     // set TESTMODE reg to 0
; 524  :     WRITE_PORT_UCHAR( (m_portBase+USB_TESTMODE_REG_OFFSET), 0);

  00014	e3a01000	 mov         r1, #0
  00018	e5c3240b	 strb        r2, [r3, #0x40B]
  0001c	e5943140	 ldr         r3, [r4, #0x140]

; 525  : 
; 526  : #ifdef NO_HIGHSPEED
; 527  :     // no HS
; 528  :     WRITE_PORT_UCHAR( (m_portBase+USB_POWER_REG_OFFSET), BIT0);
; 529  : #else
; 530  :     // Enable HS
; 531  :     WRITE_PORT_UCHAR( (m_portBase+USB_POWER_REG_OFFSET), BIT0|BIT5);

  00020	e3a02021	 mov         r2, #0x21

; 532  : #endif
; 533  : 
; 534  :     // VBUS power on
; 535  :     USBHPDD_PowerVBUS(TRUE);

  00024	e3a00001	 mov         r0, #1
  00028	e5c3140f	 strb        r1, [r3, #0x40F]
  0002c	e5943140	 ldr         r3, [r4, #0x140]
  00030	e5c32401	 strb        r2, [r3, #0x401]
  00034	eb000000	 bl          USBHPDD_PowerVBUS

; 536  : 
; 537  :     // Wait for VBUS power to settle - DEVCTL[3-4] bits
; 538  :     DWORD dwTimeout = GetTickCount() + 2000;

  00038	eb000000	 bl          GetTickCount

; 539  :     for(;;)
; 540  :     {
; 541  :         volatile UINT8 test = READ_PORT_UCHAR((m_portBase+USB_DEVCTL_REG_OFFSET));

  0003c	e2805e7d	 add         r5, r0, #0x7D, 28

; 542  : 
; 543  :         if ((test & (BIT3 | BIT4)) == (BIT3 | BIT4))

  00040	ea000004	 b           |$LN15@EnterOpera|
  00044		 |$LL4@EnterOpera|

; 545  : 
; 546  :         if (GetTickCount() > dwTimeout)

  00044	eb000000	 bl          GetTickCount
  00048	e1500005	 cmp         r0, r5
  0004c	8a000009	 bhi         |$LN12@EnterOpera|

; 549  :             break;
; 550  :         }
; 551  : 
; 552  :         Sleep(10);

  00050	e3a0000a	 mov         r0, #0xA
  00054	eb000000	 bl          Sleep
  00058		 |$LN15@EnterOpera|
  00058	e5943140	 ldr         r3, [r4, #0x140]
  0005c	e5d33460	 ldrb        r3, [r3, #0x460]
  00060	e5cd3000	 strb        r3, [sp]
  00064	e5dd3000	 ldrb        r3, [sp]
  00068	e2033018	 and         r3, r3, #0x18
  0006c	e3530018	 cmp         r3, #0x18
  00070	1afffff3	 bne         |$LL4@EnterOpera|

; 544  :             break;

  00074	ea000001	 b           |$LN8@EnterOpera|
  00078		 |$LN12@EnterOpera|

; 547  :         {
; 548  :             RETAILMSG(1, (L"USBH: DEVCTL VBUS ready timeout!\r\n"));

  00078	e59f0040	 ldr         r0, [pc, #0x40]
  0007c	eb000000	 bl          NKDbgPrintfW
  00080		 |$LN8@EnterOpera|

; 553  :     }
; 554  : 
; 555  :     // Clear any VBUS error due to power up
; 556  :     // WRITE_PORT_ULONG( (m_portBase+USB_INTCLRR_REG_OFFSET), 0x80 << CSL_USB_INTMSKR_USB_SHIFT);
; 557  : 
; 558  :     // Enable interrupts
; 559  :     WRITE_PORT_ULONG( (m_portBase+USB_EP_INTMSKSETR_REG_OFFSET),
; 560  :                       USB_OTG_TXINT_MASK |
; 561  :                       USB_OTG_RXINT_MASK );

  00080	e5943140	 ldr         r3, [r4, #0x140]
  00084	e3e02801	 mvn         r2, #1, 16
  00088	e3a0177f	 mov         r1, #0x7F, 14
  0008c	e5832030	 str         r2, [r3, #0x30]

; 562  :     WRITE_PORT_ULONG( (m_portBase+USB_CORE_INTMSKSETR_REG_OFFSET),
; 563  :                       USB_OTG_USBINT_MASK );

  00090	e5942140	 ldr         r2, [r4, #0x140]
  00094	e3813803	 orr         r3, r1, #3, 16

; 564  : 
; 565  :     // SOF is enabled only when required
; 566  :     WRITE_PORT_ULONG( (m_portBase+USB_CORE_INTMSKCLRR_REG_OFFSET),
; 567  :                       CSL_USB_INTRUSB_SOF_MASK << CSL_USB_INTMSKR_USB_SHIFT);

  00098	e3a01702	 mov         r1, #2, 14
  0009c	e5823050	 str         r3, [r2, #0x50]
  000a0	e5943140	 ldr         r3, [r4, #0x140]

; 568  : 
; 569  :     // start session in dev control register
; 570  :     WRITE_PORT_UCHAR( (m_portBase+USB_DEVCTL_REG_OFFSET), BIT0);

  000a4	e3a02001	 mov         r2, #1
  000a8	e5831054	 str         r1, [r3, #0x54]
  000ac	e5943140	 ldr         r3, [r4, #0x140]
  000b0	e5c32460	 strb        r2, [r3, #0x460]

; 571  : 
; 572  :     DEBUGMSG( ZONE_INIT, (TEXT("-CHW::EnterOperationalState\n")));
; 573  : }

  000b4	e28dd004	 add         sp, sp, #4
  000b8	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000bc	e12fff1e	 bx          lr
  000c0		 |$LN19@EnterOpera|
  000c0		 |$LN20@EnterOpera|
  000c0	00000000	 DCD         |??_C@_1EG@HLJNPNJC@?$AAU?$AAS?$AAB?$AAH?$AA?3?$AA?5?$AAD?$AAE?$AAV?$AAC?$AAT?$AAL?$AA?5?$AAV?$AAB?$AAU?$AAS?$AA?5?$AAr?$AAe?$AAa?$AAd?$AAy?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$CB@|
  000c4		 |$M43016|

			 ENDP  ; |?EnterOperationalState@CHW@@QAAXXZ|, CHW::EnterOperationalState

	EXPORT	|?StopHostController@CHW@@QAAXXZ|	; CHW::StopHostController

  00000			 AREA	 |.pdata|, PDATA
|$T43028| DCD	|$LN5@StopHostCo|
	DCD	0x40000f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?StopHostController@CHW@@QAAXXZ| PROC	; CHW::StopHostController

; 589  : {

  00000		 |$LN5@StopHostCo|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43025|

; 590  :     DEBUGMSG( ZONE_INIT, (TEXT("+CHW::StopHostController\n")));
; 591  : 
; 592  :     // Disable interrupts in USBINTE
; 593  :     WRITE_PORT_UCHAR( (m_portBase+USB_INTRUSBE_REG_OFFSET), 0);

  00004	e5903140	 ldr         r3, [r0, #0x140]
  00008	e3a02000	 mov         r2, #0

; 594  : 
; 595  :     // Disable interrupts
; 596  :     WRITE_PORT_ULONG( (m_portBase+USB_EP_INTMSKCLRR_REG_OFFSET),
; 597  :                       USB_OTG_TXINT_MASK |
; 598  :                       USB_OTG_RXINT_MASK );

  0000c	e3e01801	 mvn         r1, #1, 16
  00010	e5c3240b	 strb        r2, [r3, #0x40B]
  00014	e5903140	 ldr         r3, [r0, #0x140]
  00018	e3a0277f	 mov         r2, #0x7F, 14

; 599  :     WRITE_PORT_ULONG( (m_portBase+USB_CORE_INTMSKCLRR_REG_OFFSET),
; 600  :                       USB_OTG_USBINT_MASK );

  0001c	e3822803	 orr         r2, r2, #3, 16
  00020	e5831034	 str         r1, [r3, #0x34]
  00024	e5903140	 ldr         r3, [r0, #0x140]

; 601  :     
; 602  :     // Remove power
; 603  :     USBHPDD_PowerVBUS(FALSE);

  00028	e3a00000	 mov         r0, #0
  0002c	e5832054	 str         r2, [r3, #0x54]
  00030	eb000000	 bl          USBHPDD_PowerVBUS

; 604  : 
; 605  :     DEBUGMSG( ZONE_INIT, (TEXT("-CHW::StopHostController\n")));
; 606  : }

  00034	e49de004	 ldr         lr, [sp], #4
  00038	e12fff1e	 bx          lr
  0003c		 |$M43026|

			 ENDP  ; |?StopHostController@CHW@@QAAXXZ|, CHW::StopHostController

	EXPORT	|?PowerMgmtCallback@CHW@@UAAXH@Z|	; CHW::PowerMgmtCallback
	IMPORT	|SetInterruptEvent|

  00000			 AREA	 |.pdata|, PDATA
|$T43037| DCD	|$LN8@PowerMgmtC|
	DCD	0x40001001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PowerMgmtCallback@CHW@@UAAXH@Z| PROC	; CHW::PowerMgmtCallback

; 621  : {

  00000		 |$LN8@PowerMgmtC|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43034|
  00004	e3510000	 cmp         r1, #0

; 622  :     DEBUGMSG(ZONE_INIT && ZONE_VERBOSE, (TEXT("+CHW::PowerMgmtCallback(%d)\n\r"), fOff));
; 623  : 
; 624  :     if ( fOff )

  00008	0a000004	 beq         |$LN3@PowerMgmtC|

; 625  :     {   
; 626  : 		// suspending...
; 627  : 		m_fPowerResuming = FALSE;

  0000c	e3a03000	 mov         r3, #0
  00010	e5803190	 str         r3, [r0, #0x190]

; 628  :         StopHostController();

  00014	eb000000	 bl          |?StopHostController@CHW@@QAAXXZ|

; 638  :         }
; 639  :     }
; 640  : 
; 641  :     DEBUGMSG(ZONE_INIT && ZONE_VERBOSE, (TEXT("-CHW::PowerMgmtCallback\n\r")));
; 642  :     return;
; 643  : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$LN3@PowerMgmtC|

; 629  :     }
; 630  :     else
; 631  :     {   // resuming...
; 632  :         m_fPowerUpFlag = TRUE;
; 633  :         if (!m_fPowerResuming)

  00020	e5903190	 ldr         r3, [r0, #0x190]
  00024	e3a02001	 mov         r2, #1
  00028	e580218c	 str         r2, [r0, #0x18C]
  0002c	e3530000	 cmp         r3, #0

; 634  :         {
; 635  :             // can't use member data while `this' is invalid
; 636  :             DEBUGMSG(ZONE_INIT && ZONE_VERBOSE, (TEXT("CHW::PowerMgmtCallback: can't use member data while `this' is invalid\n\r")));
; 637  :             SetInterruptEvent(m_dwSysIntr);

  00030	0590016c	 ldreq       r0, [r0, #0x16C]
  00034	0b000000	 bleq        SetInterruptEvent

; 638  :         }
; 639  :     }
; 640  : 
; 641  :     DEBUGMSG(ZONE_INIT && ZONE_VERBOSE, (TEXT("-CHW::PowerMgmtCallback\n\r")));
; 642  :     return;
; 643  : }

  00038	e49de004	 ldr         lr, [sp], #4
  0003c	e12fff1e	 bx          lr
  00040		 |$M43035|

			 ENDP  ; |?PowerMgmtCallback@CHW@@UAAXH@Z|, CHW::PowerMgmtCallback

	EXPORT	|?UpdateFrameCounter@CHW@@AAAXXZ|	; CHW::UpdateFrameCounter

  00000			 AREA	 |.pdata|, PDATA
|$T43046| DCD	|$LN6@UpdateFram|
	DCD	0x40001401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdateFrameCounter@CHW@@AAAXXZ| PROC	; CHW::UpdateFrameCounter

; 1186 : {

  00000		 |$LN6@UpdateFram|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M43043|
  00004	e1a04000	 mov         r4, r0

; 1187 : 
; 1188 :     EnterCriticalSection( &m_csFrameCounter );

  00008	e2840f55	 add         r0, r4, #0x55, 30
  0000c	eb000000	 bl          EnterCriticalSection

; 1189 : 
; 1190 : #if 1 // Frame counter is only 11-bit long!
; 1191 : 
; 1192 : #ifdef DEBUG
; 1193 :     // If this fails, we haven't been called in a long time,
; 1194 :     // so the frame number is no longer accurate
; 1195 :     if (GetTickCount() - dwTickCountLastTime >= 0x700 )
; 1196 :         DEBUGMSG(1, (TEXT("CHW::UpdateFrameCounter missed frame count;")
; 1197 :                      TEXT(" isoch packets may have been dropped.\r\n")));
; 1198 :     dwTickCountLastTime = GetTickCount();
; 1199 : #endif // DEBUG
; 1200 : 
; 1201 : #else  // Original code
; 1202 : 
; 1203 : #ifdef DEBUG
; 1204 :     // If this fails, we haven't been called in a long time,
; 1205 :     // so the frame number is no longer accurate
; 1206 :     if (GetTickCount() - dwTickCountLastTime >= 64000 )
; 1207 :         DEBUGMSG(1, (TEXT("CHW::UpdateFrameCounter missed frame count;")
; 1208 :                      TEXT(" isoch packets may have been dropped.\r\n")));
; 1209 :     dwTickCountLastTime = GetTickCount();
; 1210 : #endif // DEBUG
; 1211 : 
; 1212 : #endif
; 1213 : 
; 1214 :     //WORD fn = m_pHCCA->HccaFrameNumber;
; 1215 :     WORD fn = READ_PORT_USHORT( (m_portBase + USB_FRAME_REG_OFFSET));

  00010	e2843d05	 add         r3, r4, #5, 26
  00014	e5932000	 ldr         r2, [r3]

; 1216 : 
; 1217 :     if (fn < lastFn)

  00018	e15310b4	 ldrh        r1, [r3, #-4]
  0001c	e2823b01	 add         r3, r2, #1, 22
  00020	e1d300bc	 ldrh        r0, [r3, #0xC]
  00024	e1500001	 cmp         r0, r1

; 1218 :         ++m_wFrameHigh;

  00028	32842c01	 addcc       r2, r4, #1, 24
  0002c	31d236b8	 ldrcch      r3, [r2, #0x68]
  00030	32833001	 addcc       r3, r3, #1
  00034	31c236b8	 strcch      r3, [r2, #0x68]

; 1219 :     lastFn = fn;

  00038	e2843c01	 add         r3, r4, #1, 24
  0003c	e1c303bc	 strh        r0, [r3, #0x3C]

; 1220 : 
; 1221 :     LeaveCriticalSection( &m_csFrameCounter );

  00040	e2840f55	 add         r0, r4, #0x55, 30
  00044	eb000000	 bl          LeaveCriticalSection

; 1222 : }

  00048	e8bd4010	 ldmia       sp!, {r4, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M43044|

			 ENDP  ; |?UpdateFrameCounter@CHW@@AAAXXZ|, CHW::UpdateFrameCounter

	EXPORT	|?GetFrameNumber@CHW@@UAAHPAK@Z|	; CHW::GetFrameNumber

  00000			 AREA	 |.pdata|, PDATA
|$T43057| DCD	|$LN5@GetFrameNu|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetFrameNumber@CHW@@UAAHPAK@Z| PROC	; CHW::GetFrameNumber

; 1235 : {

  00000		 |$LN5@GetFrameNu|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43054|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 1236 :     UpdateFrameCounter();

  0000c	eb000000	 bl          |?UpdateFrameCounter@CHW@@AAAXXZ|

; 1237 : 
; 1238 : #if 1 // Frame counter is only 11-bit long!
; 1239 : 
; 1240 :     *lpdwFrameNumber = ((DWORD) m_wFrameHigh << 11) | lastFn ;

  00010	e2843c01	 add         r3, r4, #1, 24
  00014	e1d326b8	 ldrh        r2, [r3, #0x68]
  00018	e1d333bc	 ldrh        r3, [r3, #0x3C]

; 1241 : 
; 1242 : #else // Original code
; 1243 : 
; 1244 :     *lpdwFrameNumber = ((DWORD) m_wFrameHigh << 16) | lastFn ;
; 1245 : 
; 1246 : #endif
; 1247 : 
; 1248 :     return TRUE;

  0001c	e3a00001	 mov         r0, #1
  00020	e1833582	 orr         r3, r3, r2, lsl #11
  00024	e5853000	 str         r3, [r5]

; 1249 : }

  00028	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$M43055|

			 ENDP  ; |?GetFrameNumber@CHW@@UAAHPAK@Z|, CHW::GetFrameNumber

	EXPORT	|?GetFrameLength@CHW@@UAAHPAG@Z|	; CHW::GetFrameLength

  00000			 AREA	 |.pdata|, PDATA
|$T43067| DCD	|$LN5@GetFrameLe|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetFrameLength@CHW@@UAAHPAG@Z| PROC	; CHW::GetFrameLength

; 1263 : {

  00000		 |$LN5@GetFrameLe|
  00000		 |$M43064|
  00000	e3a03c2e	 mov         r3, #0x2E, 24

; 1264 :     *lpuFrameLength = 12000;

  00004	e38330e0	 orr         r3, r3, #0xE0
  00008	e1c130b0	 strh        r3, [r1]

; 1265 :     return TRUE;

  0000c	e3a00001	 mov         r0, #1

; 1266 : }

  00010	e12fff1e	 bx          lr
  00014		 |$M43065|

			 ENDP  ; |?GetFrameLength@CHW@@UAAHPAG@Z|, CHW::GetFrameLength

	EXPORT	|?SetFrameLength@CHW@@UAAHPAXG@Z|	; CHW::SetFrameLength

  00000			 AREA	 |.pdata|, PDATA
|$T43076| DCD	|$LN5@SetFrameLe|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetFrameLength@CHW@@UAAHPAXG@Z| PROC	; CHW::SetFrameLength

; 1283 : {

  00000		 |$LN5@SetFrameLe|
  00000		 |$M43073|

; 1284 :     // Not supported
; 1285 :     return FALSE;

  00000	e3a00000	 mov         r0, #0

; 1286 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M43074|

			 ENDP  ; |?SetFrameLength@CHW@@UAAHPAXG@Z|, CHW::SetFrameLength

	EXPORT	|?GetPortStatus@CHW@@UAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z| ; CHW::GetPortStatus

  00000			 AREA	 |.pdata|, PDATA
|$T43096| DCD	|$LN14@GetPortSta|
	DCD	0x40003701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetPortStatus@CHW@@UAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z| PROC ; CHW::GetPortStatus

; 1321 : {

  00000		 |$LN14@GetPortSta|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43093|
  00004	e1a0e002	 mov         lr, r2
  00008	e3510000	 cmp         r1, #0

; 1322 :     memset( &rStatus, 0, sizeof( USB_HUB_AND_PORT_STATUS ) );

  0000c	e3a03000	 mov         r3, #0
  00010	e1ce30b0	 strh        r3, [lr]
  00014	e1ce30b2	 strh        r3, [lr, #2]

; 1323 : 
; 1324 :     if ( port > 0 )

  00018	0a00002c	 beq         |$LN1@GetPortSta|

; 1325 :     {
; 1326 :         rStatus.change.port.ConnectStatusChange = (m_portStatus & PORT_STATUS_CON_CHANGED) ? 1 : 0;

  0001c	e5d03196	 ldrb        r3, [r0, #0x196]

; 1327 :         rStatus.change.port.PortEnableChange = 0;
; 1328 :         rStatus.change.port.OverCurrentChange = 0;
; 1329 :         rStatus.change.port.SuspendChange = 0;
; 1330 :         rStatus.change.port.ResetChange = 0;

  00020	e1de20b2	 ldrh        r2, [lr, #2]
  00024	e3130001	 tst         r3, #1
  00028	e3a03cff	 mov         r3, #0xFF, 24
  0002c	e38330e0	 orr         r3, r3, #0xE0
  00030	13a01001	 movne       r1, #1
  00034	03a01000	 moveq       r1, #0
  00038	e0022003	 and         r2, r2, r3
  0003c	e2013001	 and         r3, r1, #1
  00040	e1823003	 orr         r3, r2, r3
  00044	e1ce30b2	 strh        r3, [lr, #2]

; 1331 :         /* high speed - !PORT_LOW_SPEED && PORT_HIGH_SPEED
; 1332 :          * low speed  - PORT_LOW_SPEED
; 1333 :          * full speed - !PORT_LOW_SPEED && !PORT_HIGH_SPEED
; 1334 :          */
; 1335 :         rStatus.status.port.DeviceIsLowSpeed = (READ_PORT_UCHAR( (m_portBase+USB_DEVCTL_REG_OFFSET)) & (1<<5))?1:0;

  00048	e5903140	 ldr         r3, [r0, #0x140]
  0004c	e5d33460	 ldrb        r3, [r3, #0x460]
  00050	e3130020	 tst         r3, #0x20
  00054	e1de30b0	 ldrh        r3, [lr]
  00058	13a01001	 movne       r1, #1
  0005c	03a01000	 moveq       r1, #0
  00060	e1a02803	 mov         r2, r3, lsl #16
  00064	e0233481	 eor         r3, r3, r1, lsl #9
  00068	e2033c02	 and         r3, r3, #2, 24
  0006c	e1a02822	 mov         r2, r2, lsr #16
  00070	e0232002	 eor         r2, r3, r2
  00074	e1ce20b0	 strh        r2, [lr]

; 1336 :         rStatus.status.port.DeviceIsHighSpeed = (READ_PORT_UCHAR( (m_portBase+USB_DEVCTL_REG_OFFSET)) & (1<<6))?1:0;

  00078	e5903140	 ldr         r3, [r0, #0x140]
  0007c	e5d33460	 ldrb        r3, [r3, #0x460]
  00080	e3130040	 tst         r3, #0x40
  00084	13a03001	 movne       r3, #1
  00088	03a03000	 moveq       r3, #0
  0008c	e0223503	 eor         r3, r2, r3, lsl #10
  00090	e2033b01	 and         r3, r3, #1, 22
  00094	e0232002	 eor         r2, r3, r2
  00098	e1ce20b0	 strh        r2, [lr]

; 1337 :         rStatus.status.port.PortConnected = (m_portStatus & PORT_STATUS_DEVICE_ATTACHED) ? 1 : 0;

  0009c	e5d03196	 ldrb        r3, [r0, #0x196]
  000a0	e3130002	 tst         r3, #2
  000a4	e3a03cfe	 mov         r3, #0xFE, 24

; 1338 :         rStatus.status.port.PortEnabled = 1;
; 1339 :         rStatus.status.port.PortOverCurrent = 0;
; 1340 :         // we assume root hub ports are always powered, but believe the HW.
; 1341 :         rStatus.status.port.PortPower = 1;
; 1342 :         rStatus.status.port.PortReset = 0;
; 1343 :         rStatus.status.port.PortSuspended = 0;

  000a8	e38330e0	 orr         r3, r3, #0xE0
  000ac	13a01001	 movne       r1, #1
  000b0	03a01000	 moveq       r1, #0
  000b4	e0022003	 and         r2, r2, r3
  000b8	e2013001	 and         r3, r1, #1
  000bc	e3a01c01	 mov         r1, #1, 24
  000c0	e1822003	 orr         r2, r2, r3
  000c4	e3813002	 orr         r3, r1, #2
  000c8	e1823003	 orr         r3, r2, r3
  000cc	e1ce30b0	 strh        r3, [lr]
  000d0		 |$LN1@GetPortSta|

; 1344 :     }
; 1345 : #ifdef DEBUG // these are available in OHCI but this driver doesn't use them
; 1346 :     else {
; 1347 :         // request is to Hub. rStatus was already memset to 0 above.
; 1348 :         DEBUGCHK( port == 0 );
; 1349 :         // local power supply good
; 1350 :         DEBUGCHK( rStatus.status.hub.LocalPowerStatus == 0 );
; 1351 :         // no over current condition
; 1352 :         DEBUGCHK( rStatus.status.hub.OverCurrentIndicator == 0 );
; 1353 :         // no change in power supply status
; 1354 :         DEBUGCHK( rStatus.change.hub.LocalPowerChange == 0 );
; 1355 :         // no change in over current status
; 1356 :         DEBUGCHK( rStatus.change.hub.OverCurrentIndicatorChange == 0 );
; 1357 :     }
; 1358 : #endif // DEBUG
; 1359 : 
; 1360 :     return TRUE;

  000d0	e3a00001	 mov         r0, #1

; 1361 : }

  000d4	e49de004	 ldr         lr, [sp], #4
  000d8	e12fff1e	 bx          lr
  000dc		 |$M43094|

			 ENDP  ; |?GetPortStatus@CHW@@UAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z|, CHW::GetPortStatus

	EXPORT	|?GetRootHubDescriptor@CHW@@QAAXAAU_USB_HUB_DESCRIPTOR@@@Z| ; CHW::GetRootHubDescriptor

  00000			 AREA	 |.pdata|, PDATA
|$T43104| DCD	|$LN5@GetRootHub|
	DCD	0x40000700
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetRootHubDescriptor@CHW@@QAAXAAU_USB_HUB_DESCRIPTOR@@@Z| PROC ; CHW::GetRootHubDescriptor

; 1375 : {

  00000		 |$LN5@GetRootHub|
  00000		 |$M43101|

; 1376 :     PREFAST_DEBUGCHK ( m_portBase != 0 );
; 1377 : 
; 1378 :     descriptor.bNumberOfPorts = 1;

  00000	e3a03001	 mov         r3, #1

; 1379 :     DEBUGCHK( descriptor.bNumberOfPorts >= 1 && descriptor.bNumberOfPorts <= 15 );
; 1380 : 
; 1381 :     descriptor.bDescriptorLength = USB_HUB_DESCRIPTOR_MINIMUM_SIZE + (1-1)*2;

  00004	e3a02009	 mov         r2, #9

; 1382 :     descriptor.bDescriptorType = USB_HUB_DESCRIPTOR_TYPE;

  00008	e3a00029	 mov         r0, #0x29
  0000c	e5c13002	 strb        r3, [r1, #2]
  00010	e5c12000	 strb        r2, [r1]
  00014	e5c10001	 strb        r0, [r1, #1]

; 1383 : }

  00018	e12fff1e	 bx          lr
  0001c		 |$M43102|

			 ENDP  ; |?GetRootHubDescriptor@CHW@@QAAXAAU_USB_HUB_DESCRIPTOR@@@Z|, CHW::GetRootHubDescriptor

	EXPORT	|?RootHubFeature@CHW@@UAAHEEG@Z|	; CHW::RootHubFeature

  00000			 AREA	 |.pdata|, PDATA
|$T43118| DCD	|$LN10@RootHubFea|
	DCD	0x40000b00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?RootHubFeature@CHW@@UAAHEEG@Z| PROC	; CHW::RootHubFeature

; 1401 : {

  00000		 |$LN10@RootHubFea|
  00000		 |$M43115|
  00000	e3510000	 cmp         r1, #0
  00004	e1a01000	 mov         r1, r0

; 1402 :     BOOL fResult = FALSE;

  00008	e3a00000	 mov         r0, #0

; 1403 : 
; 1404 :     DEBUGMSG(1, (L"!!! CHW::RootHubFeature: port %d, setorclear %d, feature %d\r\n",
; 1405 :         (UINT32)port, (UINT32)setOrClearFeature, (UINT32)feature));
; 1406 : 
; 1407 :     if (port > 0)

  0000c	0a000005	 beq         |$LN5@RootHubFea|

; 1408 :     {
; 1409 :         // Clear port port con status change feature ...
; 1410 : 
; 1411 :         if (setOrClearFeature == USB_REQUEST_CLEAR_FEATURE)

  00010	e3520001	 cmp         r2, #1

; 1412 :         {
; 1413 :             switch (feature)

  00014	03530010	 cmpeq       r3, #0x10

; 1414 :             {
; 1415 :             case USB_HUB_FEATURE_C_PORT_CONNECTION:
; 1416 : 
; 1417 :                 DEBUGMSG(1, (L"!!! CHW::RootHubFeature: port %d, setorclear USB_REQUEST_CLEAR_FEATURE, feature USB_HUB_FEATURE_C_PORT_CONNECTION\r\n",
; 1418 :                     (UINT32)port));
; 1419 : 
; 1420 :                 m_portStatus &= ~PORT_STATUS_CON_CHANGED;

  00018	05d13196	 ldreqb      r3, [r1, #0x196]

; 1421 :                 break;
; 1422 :             }
; 1423 :         }
; 1424 : 
; 1425 :         fResult = TRUE;

  0001c	e3a00001	 mov         r0, #1
  00020	020330fe	 andeq       r3, r3, #0xFE
  00024	05c13196	 streqb      r3, [r1, #0x196]
  00028		 |$LN5@RootHubFea|

; 1426 :     }
; 1427 : 
; 1428 :     DEBUGMSG(1, (L"!!! CHW::RootHubFeature: port %d, setorclear %d, feature %d, result %d\r\n",
; 1429 :         (UINT32)port, (UINT32)setOrClearFeature, (UINT32)feature, fResult));
; 1430 : 
; 1431 :     return fResult;
; 1432 : }

  00028	e12fff1e	 bx          lr
  0002c		 |$M43116|

			 ENDP  ; |?RootHubFeature@CHW@@UAAHEEG@Z|, CHW::RootHubFeature

	EXPORT	|?ResetAndEnablePort@CHW@@UAAHE@Z|	; CHW::ResetAndEnablePort

  00000			 AREA	 |.pdata|, PDATA
|$T43134| DCD	|$LN11@ResetAndEn|
	DCD	0x40001901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResetAndEnablePort@CHW@@UAAHE@Z| PROC ; CHW::ResetAndEnablePort

; 1449 : {

  00000		 |$LN11@ResetAndEn|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43131|
  00004	e3510000	 cmp         r1, #0
  00008	e1a05000	 mov         r5, r0

; 1450 :     BOOL fSuccess = TRUE;
; 1451 :     UCHAR Power;
; 1452 :     if( port >0 ){

  0000c	0a000011	 beq         |$LN1@ResetAndEn|

; 1453 :         // reset the host controller. It is recommended to wait for 50ms
; 1454 :         Power = READ_PORT_UCHAR( (m_portBase+USB_POWER_REG_OFFSET));

  00010	e5953140	 ldr         r3, [r5, #0x140]

; 1455 :         WRITE_PORT_UCHAR( (m_portBase+USB_POWER_REG_OFFSET), Power|BIT3);
; 1456 :         Sleep(200);

  00014	e3a000c8	 mov         r0, #0xC8
  00018	e5d34401	 ldrb        r4, [r3, #0x401]
  0001c	e5953140	 ldr         r3, [r5, #0x140]
  00020	e3842008	 orr         r2, r4, #8
  00024	e5c32401	 strb        r2, [r3, #0x401]
  00028	eb000000	 bl          Sleep

; 1457 :         WRITE_PORT_UCHAR( (m_portBase+USB_POWER_REG_OFFSET), Power & (~BIT3));

  0002c	e5953140	 ldr         r3, [r5, #0x140]
  00030	e20420f7	 and         r2, r4, #0xF7

; 1458 :         Power = READ_PORT_UCHAR( (m_portBase+USB_POWER_REG_OFFSET));
; 1459 :         RETAILMSG(FALSE,(TEXT("Power = 0x%x\n"),Power));
; 1460 :         Sleep(400);

  00034	e3a00e19	 mov         r0, #0x19, 28
  00038	e5c32401	 strb        r2, [r3, #0x401]
  0003c	e5953140	 ldr         r3, [r5, #0x140]
  00040	e5d34401	 ldrb        r4, [r3, #0x401]
  00044	eb000000	 bl          Sleep

; 1461 :         if(Power & (1<<4))

  00048	e3140010	 tst         r4, #0x10

; 1462 :             m_fHighSpeed = TRUE;

  0004c	13a03001	 movne       r3, #1

; 1463 :         else
; 1464 :             m_fHighSpeed = FALSE;

  00050	03a03000	 moveq       r3, #0
  00054	e5853220	 str         r3, [r5, #0x220]
  00058		 |$LN1@ResetAndEn|

; 1465 :     }
; 1466 : 
; 1467 :     DEBUGMSG( ZONE_REGISTERS, (TEXT("Root hub, after reset & enable, port %d \n"), port) );
; 1468 :     return fSuccess;

  00058	e3a00001	 mov         r0, #1

; 1469 : }

  0005c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$M43132|

			 ENDP  ; |?ResetAndEnablePort@CHW@@UAAHE@Z|, CHW::ResetAndEnablePort

	EXPORT	|?DisablePort@CHW@@UAAXE@Z|		; CHW::DisablePort

  00000			 AREA	 |.pdata|, PDATA
|$T43143| DCD	|$LN5@DisablePor|
	DCD	0x40000901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DisablePort@CHW@@UAAXE@Z| PROC	; CHW::DisablePort

; 1482 : {

  00000		 |$LN5@DisablePor|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M43140|

; 1483 :     RootHubFeature(port, USB_REQUEST_CLEAR_FEATURE, USB_HUB_FEATURE_PORT_ENABLE);

  00004	e590e000	 ldr         lr, [r0]
  00008	e3a03001	 mov         r3, #1
  0000c	e3a02001	 mov         r2, #1
  00010	e59e4038	 ldr         r4, [lr, #0x38]
  00014	e1a0e00f	 mov         lr, pc
  00018	e12fff14	 bx          r4

; 1484 : }

  0001c	e8bd4010	 ldmia       sp!, {r4, lr}
  00020	e12fff1e	 bx          lr
  00024		 |$M43141|

			 ENDP  ; |?DisablePort@CHW@@UAAXE@Z|, CHW::DisablePort

	EXPORT	|?WaitForPortStatusChange@CHW@@UAAHPAX@Z| ; CHW::WaitForPortStatusChange
	IMPORT	|WaitForMultipleObjects|

  00000			 AREA	 |.pdata|, PDATA
|$T43154| DCD	|$LN8@WaitForPor|
	DCD	0x40001a02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?WaitForPortStatusChange@CHW@@UAAHPAX@Z| PROC ; CHW::WaitForPortStatusChange

; 1486 : {

  00000		 |$LN8@WaitForPor|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M43151|
  00008	e1a0e001	 mov         lr, r1

; 1487 :     if (m_hUsbHubChangeEvent)

  0000c	e590317c	 ldr         r3, [r0, #0x17C]
  00010	e1b04003	 movs        r4, r3
  00014	0a00000f	 beq         |$LN3@WaitForPor|

; 1488 :         {
; 1489 :         if (m_hHubChanged!=NULL)

  00018	e35e0000	 cmp         lr, #0
  0001c	0a000008	 beq         |$LN2@WaitForPor|

; 1490 :             {
; 1491 :             HANDLE hArray[2];
; 1492 :             hArray[0]=m_hHubChanged;
; 1493 :             hArray[1]=m_hUsbHubChangeEvent;
; 1494 :             DEBUGMSG(ZONE_INIT && ZONE_VERBOSE, (TEXT("-CHW::WaitForPortStatusChange - multiple\n")));
; 1495 :             WaitForMultipleObjects(2,hArray,FALSE,INFINITE);

  00020	e3e03000	 mvn         r3, #0
  00024	e3a02000	 mov         r2, #0
  00028	e28d1000	 add         r1, sp, #0
  0002c	e3a00002	 mov         r0, #2
  00030	e58de000	 str         lr, [sp]
  00034	e58d4004	 str         r4, [sp, #4]
  00038	eb000000	 bl          WaitForMultipleObjects

; 1501 :             }
; 1502 :         return TRUE;

  0003c	e3a00001	 mov         r0, #1
  00040	ea000005	 b           |$LN4@WaitForPor|
  00044		 |$LN2@WaitForPor|

; 1496 :             }
; 1497 :         else
; 1498 :             {
; 1499 :             DEBUGMSG(ZONE_INIT && ZONE_VERBOSE, (TEXT("-CHW::WaitForPortStatusChange - single\n")));
; 1500 :             WaitForSingleObject(m_hUsbHubChangeEvent,INFINITE);

  00044	e3e01000	 mvn         r1, #0
  00048	e1a00004	 mov         r0, r4
  0004c	eb000000	 bl          WaitForSingleObject

; 1501 :             }
; 1502 :         return TRUE;

  00050	e3a00001	 mov         r0, #1
  00054	ea000000	 b           |$LN4@WaitForPor|
  00058		 |$LN3@WaitForPor|

; 1503 :         }
; 1504 : 
; 1505 :     return FALSE;

  00058	e3a00000	 mov         r0, #0
  0005c		 |$LN4@WaitForPor|

; 1506 : }

  0005c	e28dd008	 add         sp, sp, #8
  00060	e8bd4010	 ldmia       sp!, {r4, lr}
  00064	e12fff1e	 bx          lr
  00068		 |$M43152|

			 ENDP  ; |?WaitForPortStatusChange@CHW@@UAAHPAX@Z|, CHW::WaitForPortStatusChange

	EXPORT	|?AllocateHostEndPoint@CHW@@QAAHIKH@Z|	; CHW::AllocateHostEndPoint

  00000			 AREA	 |.pdata|, PDATA
|$T43182| DCD	|$LN34@AllocateHo|
	DCD	0x40004e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AllocateHostEndPoint@CHW@@QAAHIKH@Z| PROC ; CHW::AllocateHostEndPoint

; 2128 : {

  00000		 |$LN34@AllocateHo|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M43179|
  00004	e1a0a002	 mov         r10, r2
  00008	e1a09001	 mov         r9, r1

; 2129 :     INT32 i = 0, EpNum = -1;
; 2130 : 
; 2131 :     // Use configurable static FIFO alloc
; 2132 : 
; 2133 :     if (TransferType == TYPE_CONTROL)

  0000c	e3590001	 cmp         r9, #1
  00010	e3e04000	 mvn         r4, #0

; 2134 :     {
; 2135 :         EpNum = 0;

  00014	03a04000	 moveq       r4, #0
  00018	0a000043	 beq         |$LN3@AllocateHo|

; 2136 :         DEBUGMSG(ZONE_INIT, (TEXT("CHW::AllocateHostEndPoint: allocated EP0, type CONTROL, dir BIDIR, FIFO 64\n")));
; 2137 :     }
; 2138 :     else
; 2139 :     {
; 2140 :         EP_CONFIG *pConfig = IsDirectionIN ? m_EpInConfig : m_EpOutConfig;

  0001c	e3530000	 cmp         r3, #0
  00020	12801f8e	 addne       r1, r0, #0x8E, 30
  00024	02801e2b	 addeq       r1, r0, #0x2B, 28

; 2141 :         INT32 EpAlloc = -1;

  00028	e1a00004	 mov         r0, r4

; 2142 :         BOOL fStop = FALSE;
; 2143 : 
; 2144 :         if (TransferType == TYPE_BULK)

  0002c	e3590002	 cmp         r9, #2
  00030	e3a05000	 mov         r5, #0
  00034	1a000018	 bne         |$LN31@AllocateHo|

; 2145 :         {
; 2146 :             // Search for shared BULK EP
; 2147 :             for (i = 0; !fStop && (i < (MGC_MAX_USB_ENDS - 1)); i ++)

  00038	e3a0e000	 mov         lr, #0
  0003c	e1a02001	 mov         r2, r1
  00040		 |$LL17@AllocateHo|
  00040	e35e000f	 cmp         lr, #0xF
  00044	aa000012	 bge         |$LN15@AllocateHo|

; 2148 :             {
; 2149 :                 if ((pConfig[ i ].refCount > 0) &&
; 2150 :                     (pConfig[ i ].epTypeCurrent == TYPE_BULK) &&
; 2151 :                     pConfig[ i ].fSharedMode &&
; 2152 :                     (pConfig[ i ].fifoSize >= MaxPktSize))

  00048	e5d23000	 ldrb        r3, [r2]
  0004c	e1b06003	 movs        r6, r3
  00050	0a00000b	 beq         |$LN16@AllocateHo|
  00054	e5d23002	 ldrb        r3, [r2, #2]
  00058	e3530002	 cmp         r3, #2
  0005c	1a000008	 bne         |$LN16@AllocateHo|
  00060	e5d23004	 ldrb        r3, [r2, #4]
  00064	e3530000	 cmp         r3, #0
  00068	0a000005	 beq         |$LN16@AllocateHo|
  0006c	e1d230b6	 ldrh        r3, [r2, #6]
  00070	e153000a	 cmp         r3, r10

; 2153 :                 {
; 2154 :                     pConfig[ i ].refCount ++;

  00074	22863001	 addcs       r3, r6, #1
  00078	25c23000	 strcsb      r3, [r2]

; 2155 :                     EpNum = i + 1;

  0007c	228e4001	 addcs       r4, lr, #1

; 2156 :                     fStop = TRUE;

  00080	23a05001	 movcs       r5, #1
  00084		 |$LN16@AllocateHo|
  00084	e28ee001	 add         lr, lr, #1
  00088	e2822008	 add         r2, r2, #8
  0008c	e3550000	 cmp         r5, #0
  00090	0affffea	 beq         |$LL17@AllocateHo|
  00094		 |$LN15@AllocateHo|

; 2157 :                 }
; 2158 :             }
; 2159 :         }
; 2160 : 
; 2161 :         if (!fStop)

  00094	e3550000	 cmp         r5, #0
  00098	1a000023	 bne         |$LN3@AllocateHo|
  0009c		 |$LN31@AllocateHo|

; 2162 :         {
; 2163 :             for (i = 0; !fStop && (i < (MGC_MAX_USB_ENDS - 1)); i ++)

  0009c	e3a0e000	 mov         lr, #0
  000a0	e3a02000	 mov         r2, #0
  000a4	e20980ff	 and         r8, r9, #0xFF
  000a8		 |$LL12@AllocateHo|
  000a8	e3520078	 cmp         r2, #0x78
  000ac	aa000019	 bge         |$LN10@AllocateHo|

; 2164 :             {
; 2165 :                 if (((pConfig[ i ].epType == (UINT8)TransferType) ||
; 2166 :                      (pConfig[ i ].epType == TYPE_ANY)) &&
; 2167 :                     (pConfig[ i ].fifoSize >= MaxPktSize) &&
; 2168 :                     (pConfig[ i ].refCount == 0))

  000b0	e0823001	 add         r3, r2, r1
  000b4	e5d36001	 ldrb        r6, [r3, #1]
  000b8	e1560008	 cmp         r6, r8
  000bc	0a000001	 beq         |$LN8@AllocateHo|
  000c0	e3560005	 cmp         r6, #5
  000c4	1a00000f	 bne         |$LN11@AllocateHo|
  000c8		 |$LN8@AllocateHo|
  000c8	e0823001	 add         r3, r2, r1
  000cc	e1d370b6	 ldrh        r7, [r3, #6]
  000d0	e157000a	 cmp         r7, r10
  000d4	3a00000b	 bcc         |$LN11@AllocateHo|
  000d8	e7d23001	 ldrb        r3, [r2, +r1]
  000dc	e3530000	 cmp         r3, #0
  000e0	1a000008	 bne         |$LN11@AllocateHo|

; 2169 :                 {
; 2170 :                     if (EpAlloc >= 0)

  000e4	e3500000	 cmp         r0, #0
  000e8	4a000003	 bmi         |$LN7@AllocateHo|

; 2171 :                     {
; 2172 :                         // Only accept endpoints with smaller FIFO allocation
; 2173 :                         if (pConfig[ i ].fifoSize < pConfig[ EpAlloc ].fifoSize)

  000ec	e0813180	 add         r3, r1, r0, lsl #3
  000f0	e1d330b6	 ldrh        r3, [r3, #6]
  000f4	e1570003	 cmp         r7, r3
  000f8	2a000000	 bcs         |$LN5@AllocateHo|
  000fc		 |$LN7@AllocateHo|

; 2174 :                         {
; 2175 :                             EpAlloc = i;
; 2176 :                         }
; 2177 :                     }
; 2178 :                     else
; 2179 :                     {
; 2180 :                         EpAlloc = i;

  000fc	e1a0000e	 mov         r0, lr
  00100		 |$LN5@AllocateHo|

; 2181 :                     }
; 2182 : 
; 2183 :                     // Stop searching if endpoint is hardcoded for
; 2184 :                     // this transfer type and keep looking if
; 2185 :                     // configured for "any" transfer type
; 2186 :                     if (pConfig[ i ].epType == (UINT8)TransferType)

  00100	e1560008	 cmp         r6, r8

; 2187 :                     {
; 2188 :                         fStop = TRUE;

  00104	03a05001	 moveq       r5, #1
  00108		 |$LN11@AllocateHo|
  00108	e28ee001	 add         lr, lr, #1
  0010c	e2822008	 add         r2, r2, #8
  00110	e3550000	 cmp         r5, #0
  00114	0affffe3	 beq         |$LL12@AllocateHo|
  00118		 |$LN10@AllocateHo|

; 2189 :                     }
; 2190 :                 }
; 2191 :             }
; 2192 : 
; 2193 :             if (EpAlloc >= 0)

  00118	e3500000	 cmp         r0, #0

; 2194 :             {
; 2195 :                 pConfig[ EpAlloc ].refCount = 1;

  0011c	53a03001	 movpl       r3, #1
  00120	57e13180	 strplb      r3, [r1, +r0, lsl #3]!

; 2196 :                 pConfig[ EpAlloc ].epTypeCurrent = (UINT8)TransferType;
; 2197 :                 EpNum = EpAlloc + 1;

  00124	52804001	 addpl       r4, r0, #1
  00128	55c19002	 strplb      r9, [r1, #2]
  0012c		 |$LN3@AllocateHo|

; 2198 :             }
; 2199 :         }
; 2200 : 
; 2201 :         if (EpNum > 0)
; 2202 :         {
; 2203 :             DEBUGMSG(ZONE_INIT, (TEXT("CHW::AllocateHostEndPoint: allocated EP %u, type %d, dir %s, FIFO %d\n"),
; 2204 :                 (INT32)EpNum,
; 2205 :                 TransferType,
; 2206 :                 IsDirectionIN ? L"IN" : L"OUT",
; 2207 :                 (INT32)pConfig[ EpNum - 1 ].fifoSize));
; 2208 :         }
; 2209 :         else
; 2210 :         {
; 2211 :             DEBUGMSG(ZONE_ERROR, (TEXT("CHW::AllocateHostEndPoint: failed to alloc EP, type %d, dir %s\n"),
; 2212 :                 TransferType,
; 2213 :                 IsDirectionIN ? L"IN" : L"OUT"));
; 2214 :         }
; 2215 :     }
; 2216 : 
; 2217 :     RETAILMSG(FALSE,(TEXT("EPnum=%x\n"),EpNum));
; 2218 :     return EpNum;
; 2219 : }

  0012c	e1a00004	 mov         r0, r4
  00130	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00134	e12fff1e	 bx          lr
  00138		 |$M43180|

			 ENDP  ; |?AllocateHostEndPoint@CHW@@QAAHIKH@Z|, CHW::AllocateHostEndPoint

	EXPORT	|?FreeHostEndPoint@CHW@@QAAXIH@Z|	; CHW::FreeHostEndPoint

  00000			 AREA	 |.pdata|, PDATA
|$T43196| DCD	|$LN18@FreeHostEn|
	DCD	0x40001f00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FreeHostEndPoint@CHW@@QAAXIH@Z| PROC	; CHW::FreeHostEndPoint

; 2222 : {

  00000		 |$LN18@FreeHostEn|
  00000		 |$M43193|

; 2223 :     // Use configurable static FIFO alloc
; 2224 : 
; 2225 :     DEBUGCHK(EndpointNum < MGC_MAX_USB_ENDS);
; 2226 : 
; 2227 :     if ( (EndpointNum > 0) && (EndpointNum < MGC_MAX_USB_ENDS) )

  00000	e2413001	 sub         r3, r1, #1
  00004	e353000e	 cmp         r3, #0xE
  00008	8a00000f	 bhi         |$LN2@FreeHostEn|

; 2228 :     {
; 2229 :         EP_CONFIG *pConfig = IsDirectionIN ? m_EpInConfig : m_EpOutConfig;

  0000c	e3520000	 cmp         r2, #0
  00010	12802f8e	 addne       r2, r0, #0x8E, 30
  00014	02802e2b	 addeq       r2, r0, #0x2B, 28

; 2230 :         EndpointNum --;

  00018	e2413001	 sub         r3, r1, #1

; 2231 : 
; 2232 :         DEBUGCHK(pConfig[ EndpointNum ].refCount > 0);
; 2233 : 
; 2234 :         DEBUGMSG(ZONE_INIT, (TEXT("CHW::FreeHostEndPoint: releasing EP %u, type %d, dir %s, FIFO %d\n"),
; 2235 :             (INT32)(EndpointNum + 1),
; 2236 :             (INT32)pConfig[ EndpointNum ].epTypeCurrent,
; 2237 :             IsDirectionIN ? L"IN" : L"OUT",
; 2238 :             (INT32)pConfig[ EndpointNum ].fifoSize));
; 2239 : 
; 2240 :         switch (pConfig[ EndpointNum ].epTypeCurrent)

  0001c	e0822183	 add         r2, r2, r3, lsl #3
  00020	e5d23002	 ldrb        r3, [r2, #2]
  00024	e3530002	 cmp         r3, #2
  00028	0a000008	 beq         |$LN8@FreeHostEn|
  0002c	da000006	 ble         |$LN2@FreeHostEn|
  00030	e3530004	 cmp         r3, #4
  00034	ca000004	 bgt         |$LN2@FreeHostEn|
  00038		 |$LN7@FreeHostEn|

; 2252 :                 }
; 2253 : 
; 2254 :                 break;
; 2255 :             }
; 2256 : 
; 2257 :             // Do not break here, just fall through
; 2258 :             __fallthrough;
; 2259 : 
; 2260 :         case TYPE_ISOCHRONOUS:
; 2261 :         case TYPE_INTERRUPT:
; 2262 : 
; 2263 :             if (pConfig[ EndpointNum ].refCount == 1)

  00038	e5d23000	 ldrb        r3, [r2]
  0003c	e3a01000	 mov         r1, #0

; 2264 :             {
; 2265 :                 pConfig[ EndpointNum ].refCount = 0;
; 2266 :             }
; 2267 :             else
; 2268 :             {
; 2269 :                 DEBUGCHK(FALSE);
; 2270 :             }
; 2271 : 
; 2272 :             pConfig[ EndpointNum ].epTypeCurrent = TYPE_UNKNOWN;

  00040	e5c21002	 strb        r1, [r2, #2]
  00044	e3530001	 cmp         r3, #1
  00048	05c21000	 streqb      r1, [r2]
  0004c		 |$LN2@FreeHostEn|

; 2273 : 
; 2274 :             break;
; 2275 : 
; 2276 :         default:
; 2277 : 
; 2278 :             DEBUGCHK(FALSE);
; 2279 :         }
; 2280 :     }
; 2281 :     else
; 2282 :     {
; 2283 :         DEBUGMSG(ZONE_INIT, (TEXT("CHW::FreeHostEndPoint: releasing EP0, type CONTROL, dir BIDIR, FIFO 64\n")));
; 2284 :     }
; 2285 : }

  0004c	e12fff1e	 bx          lr
  00050		 |$LN8@FreeHostEn|

; 2241 :         {
; 2242 :         case TYPE_BULK:
; 2243 : 
; 2244 :             if (pConfig[ EndpointNum ].fSharedMode)

  00050	e5d23004	 ldrb        r3, [r2, #4]
  00054	e3530000	 cmp         r3, #0
  00058	0afffff6	 beq         |$LN7@FreeHostEn|

; 2245 :             {
; 2246 :                 // Sharing mode enabled
; 2247 :                 pConfig[ EndpointNum ].refCount --;

  0005c	e5d23000	 ldrb        r3, [r2]
  00060	e28330ff	 add         r3, r3, #0xFF
  00064	e21330ff	 ands        r3, r3, #0xFF
  00068	e5c23000	 strb        r3, [r2]

; 2248 : 
; 2249 :                 if (pConfig[ EndpointNum ].refCount == 0)

  0006c	1afffff6	 bne         |$LN2@FreeHostEn|

; 2250 :                 {
; 2251 :                     pConfig[ EndpointNum ].epTypeCurrent = TYPE_UNKNOWN;

  00070	e3a03000	 mov         r3, #0
  00074	e5c23002	 strb        r3, [r2, #2]

; 2273 : 
; 2274 :             break;
; 2275 : 
; 2276 :         default:
; 2277 : 
; 2278 :             DEBUGCHK(FALSE);
; 2279 :         }
; 2280 :     }
; 2281 :     else
; 2282 :     {
; 2283 :         DEBUGMSG(ZONE_INIT, (TEXT("CHW::FreeHostEndPoint: releasing EP0, type CONTROL, dir BIDIR, FIFO 64\n")));
; 2284 :     }
; 2285 : }

  00078	e12fff1e	 bx          lr
  0007c		 |$M43194|

			 ENDP  ; |?FreeHostEndPoint@CHW@@QAAXIH@Z|, CHW::FreeHostEndPoint

	EXPORT	|?StopHostEndpoint@CHW@@QAAXK@Z|	; CHW::StopHostEndpoint

  00000			 AREA	 |.pdata|, PDATA
|$T43208| DCD	|$LN9@StopHostEn|
	DCD	0x40002801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?StopHostEndpoint@CHW@@QAAXK@Z| PROC	; CHW::StopHostEndpoint

; 2288 : {

  00000		 |$LN9@StopHostEn|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M43205|
  00004	e1b04001	 movs        r4, r1

; 2289 :     UINT16 _HOST_CSR0, _HOST_TXCSR, _HOST_RXCSR;
; 2290 : 
; 2291 :     if(HostEndpointNum)
; 2292 :     {
; 2293 :         _HOST_RXCSR = READ_PORT_USHORT( (m_portBase + MGC_END_OFFSET(HostEndpointNum, MGC_O_HDRC_RXCSR)));

  00008	e5903140	 ldr         r3, [r0, #0x140]
  0000c	0a000019	 beq         |$LN4@StopHostEn|
  00010	e0833204	 add         r3, r3, r4, lsl #4
  00014	e2833c05	 add         r3, r3, #5, 24
  00018	e1d310b6	 ldrh        r1, [r3, #6]

; 2294 :         if(_HOST_RXCSR & MGC_M_RXCSR_H_REQPKT)

  0001c	e3110020	 tst         r1, #0x20

; 2295 :             WRITE_PORT_USHORT( (m_portBase + MGC_END_OFFSET(HostEndpointNum, MGC_O_HDRC_RXCSR)), _HOST_RXCSR&(~MGC_M_RXCSR_H_REQPKT));

  00020	15903140	 ldrne       r3, [r0, #0x140]
  00024	13a02cff	 movne       r2, #0xFF, 24
  00028	1382e0df	 orrne       lr, r2, #0xDF
  0002c	10833204	 addne       r3, r3, r4, lsl #4
  00030	12832c05	 addne       r2, r3, #5, 24
  00034	1001300e	 andne       r3, r1, lr
  00038	11c230b6	 strneh      r3, [r2, #6]

; 2296 : 
; 2297 :         _HOST_TXCSR = READ_PORT_USHORT( (m_portBase + MGC_END_OFFSET(HostEndpointNum, MGC_O_HDRC_TXCSR)));

  0003c	e5903140	 ldr         r3, [r0, #0x140]
  00040	e0833204	 add         r3, r3, r4, lsl #4
  00044	e2833c05	 add         r3, r3, #5, 24
  00048	e1d3e0b2	 ldrh        lr, [r3, #2]

; 2298 : 
; 2299 :         if(_HOST_TXCSR & MGC_M_TXCSR_TXPKTRDY)

  0004c	e31e0001	 tst         lr, #1
  00050	0a000010	 beq         |$LN1@StopHostEn|

; 2300 :             WRITE_PORT_USHORT( (m_portBase + MGC_END_OFFSET(HostEndpointNum, MGC_O_HDRC_TXCSR)), _HOST_TXCSR&(~MGC_M_TXCSR_TXPKTRDY));

  00054	e5903140	 ldr         r3, [r0, #0x140]
  00058	e3a02cff	 mov         r2, #0xFF, 24
  0005c	e38210fe	 orr         r1, r2, #0xFE
  00060	e0833204	 add         r3, r3, r4, lsl #4
  00064	e2832c05	 add         r2, r3, #5, 24
  00068	e00e3001	 and         r3, lr, r1
  0006c	e1c230b2	 strh        r3, [r2, #2]

; 2306 :     }
; 2307 : }

  00070	e8bd4010	 ldmia       sp!, {r4, lr}
  00074	e12fff1e	 bx          lr
  00078		 |$LN4@StopHostEn|

; 2301 :     }
; 2302 :     else
; 2303 :     {
; 2304 :         _HOST_CSR0 = READ_PORT_USHORT( (m_portBase + MGC_END_OFFSET(0, MGC_O_HDRC_CSR0)));

  00078	e3a02cff	 mov         r2, #0xFF, 24

; 2305 :         WRITE_PORT_USHORT( (m_portBase + MGC_END_OFFSET(0, MGC_O_HDRC_CSR0)), _HOST_CSR0&(~(MGC_M_CSR0_TXPKTRDY|MGC_M_CSR0_H_REQPKT)));

  0007c	e2833c05	 add         r3, r3, #5, 24
  00080	e1d330b2	 ldrh        r3, [r3, #2]
  00084	e38210dd	 orr         r1, r2, #0xDD
  00088	e5902140	 ldr         r2, [r0, #0x140]
  0008c	e0031001	 and         r1, r3, r1
  00090	e2823c05	 add         r3, r2, #5, 24
  00094	e1c310b2	 strh        r1, [r3, #2]
  00098		 |$LN1@StopHostEn|

; 2306 :     }
; 2307 : }

  00098	e8bd4010	 ldmia       sp!, {r4, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$M43206|

			 ENDP  ; |?StopHostEndpoint@CHW@@QAAXK@Z|, CHW::StopHostEndpoint

	EXPORT	|?ProgramHostEndpoint@CHW@@QAAXIPAX@Z|	; CHW::ProgramHostEndpoint

  00000			 AREA	 |.pdata|, PDATA
|$T43233| DCD	|$LN32@ProgramHos|
	DCD	0x40007301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ProgramHostEndpoint@CHW@@QAAXIPAX@Z| PROC ; CHW::ProgramHostEndpoint

; 2310 : void CHW::ProgramHostEndpoint(UINT32 TransferType, void *pTemp){

  00000		 |$LN32@ProgramHos|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43230|
  00004	e1a0e002	 mov         lr, r2

; 2311 :     USBED *pED = (USBED *)pTemp;
; 2312 :     UINT32 EpNum = pED->bHostEndPointNum;

  00008	e5de4010	 ldrb        r4, [lr, #0x10]

; 2313 : 
; 2314 :     if(EpNum < MGC_MAX_USB_ENDS){

  0000c	e3540010	 cmp         r4, #0x10
  00010	2a00006b	 bcs         |$LN1@ProgramHos|

; 2315 : 
; 2316 :         switch (TransferType)

  00014	e3510000	 cmp         r1, #0
  00018	0a00005b	 beq         |$LN5@ProgramHos|
  0001c	e3510002	 cmp         r1, #2
  00020	9a000057	 bls         |$LN11@ProgramHos|
  00024	e3510004	 cmp         r1, #4
  00028	8a000057	 bhi         |$LN5@ProgramHos|

; 2324 : 
; 2325 :         case TYPE_INTERRUPT:
; 2326 :         case TYPE_ISOCHRONOUS:
; 2327 : 
; 2328 :             {
; 2329 :                 UINT32 nXType = (TransferType == TYPE_INTERRUPT) ? 0x03 : 0x01;
; 2330 : 
; 2331 :                 pED->epType = (PIPE_TYPE)TransferType;
; 2332 : 
; 2333 :                 WRITE_PORT_UCHAR( (m_portBase + USB_INDEX_REG_OFFSET), (BYTE)EpNum);

  0002c	e58e1020	 str         r1, [lr, #0x20]
  00030	e5903140	 ldr         r3, [r0, #0x140]
  00034	e3510003	 cmp         r1, #3
  00038	03a05003	 moveq       r5, #3
  0003c	e5c3440e	 strb        r4, [r3, #0x40E]

; 2334 : 
; 2335 :                 if(pED->bfDirection == TD_IN_PID)

  00040	e5de3006	 ldrb        r3, [lr, #6]
  00044	13a05001	 movne       r5, #1
  00048	e3530002	 cmp         r3, #2

; 2336 :                 {
; 2337 :                     WRITE_PORT_UCHAR( (m_portBase + MGC_END_OFFSET(EpNum, MGC_O_HDRC_RXTYPE)),
; 2338 :                         (BYTE)((pED->bfIsLowSpeed?(0x3<<6):FULL_HIGH_SPEED)|(nXType<<4)|(pED->bfEndpointNumber&0xf)));

  0004c	e5de3008	 ldrb        r3, [lr, #8]
  00050	1a000012	 bne         |$LN9@ProgramHos|
  00054	e3530000	 cmp         r3, #0
  00058	13a010c0	 movne       r1, #0xC0
  0005c	1a000003	 bne         |$LN20@ProgramHos|
  00060	e5de3009	 ldrb        r3, [lr, #9]
  00064	e3530000	 cmp         r3, #0
  00068	13a01040	 movne       r1, #0x40
  0006c	03a01080	 moveq       r1, #0x80
  00070		 |$LN20@ProgramHos|
  00070	e5de3005	 ldrb        r3, [lr, #5]
  00074	e5902140	 ldr         r2, [r0, #0x140]
  00078	e203300f	 and         r3, r3, #0xF
  0007c	e1833205	 orr         r3, r3, r5, lsl #4
  00080	e1833001	 orr         r3, r3, r1
  00084	e0822204	 add         r2, r2, r4, lsl #4
  00088	e5c2350c	 strb        r3, [r2, #0x50C]

; 2339 :                     WRITE_PORT_UCHAR( (m_portBase + MGC_END_OFFSET(EpNum, MGC_O_HDRC_RXINTERVAL)),
; 2340 :                         pED->bInterval);

  0008c	e5903140	 ldr         r3, [r0, #0x140]
  00090	e5de2011	 ldrb        r2, [lr, #0x11]
  00094	e0833204	 add         r3, r3, r4, lsl #4
  00098	e5c3250d	 strb        r2, [r3, #0x50D]

; 2341 :                 }
; 2342 :                 else

  0009c	ea000011	 b           |$LN8@ProgramHos|
  000a0		 |$LN9@ProgramHos|

; 2343 :                 {
; 2344 :                     WRITE_PORT_UCHAR( (m_portBase + MGC_END_OFFSET(EpNum, MGC_O_HDRC_TXTYPE)),
; 2345 :                         (BYTE)((pED->bfIsLowSpeed?(0x3<<6):FULL_HIGH_SPEED)|(nXType<<4)|(pED->bfEndpointNumber&0xf)));

  000a0	e3530000	 cmp         r3, #0
  000a4	13a010c0	 movne       r1, #0xC0
  000a8	1a000003	 bne         |$LN24@ProgramHos|
  000ac	e5de3009	 ldrb        r3, [lr, #9]
  000b0	e3530000	 cmp         r3, #0
  000b4	13a01040	 movne       r1, #0x40
  000b8	03a01080	 moveq       r1, #0x80
  000bc		 |$LN24@ProgramHos|
  000bc	e5de3005	 ldrb        r3, [lr, #5]
  000c0	e5902140	 ldr         r2, [r0, #0x140]
  000c4	e203300f	 and         r3, r3, #0xF
  000c8	e1833205	 orr         r3, r3, r5, lsl #4
  000cc	e1833001	 orr         r3, r3, r1
  000d0	e0822204	 add         r2, r2, r4, lsl #4
  000d4	e5c2350a	 strb        r3, [r2, #0x50A]

; 2346 :                     WRITE_PORT_UCHAR( (m_portBase + MGC_END_OFFSET(EpNum, MGC_O_HDRC_TXINTERVAL)),
; 2347 :                         pED->bInterval);

  000d8	e5903140	 ldr         r3, [r0, #0x140]
  000dc	e5de2011	 ldrb        r2, [lr, #0x11]
  000e0	e0833204	 add         r3, r3, r4, lsl #4
  000e4	e5c3250b	 strb        r2, [r3, #0x50B]
  000e8		 |$LN8@ProgramHos|

; 2348 :                 }
; 2349 : 
; 2350 :                 if (m_fHighSpeed && !pED->bfIsHighSpeed && pED->bfHubAddress)

  000e8	e5903220	 ldr         r3, [r0, #0x220]
  000ec	e3530000	 cmp         r3, #0
  000f0	0a000015	 beq         |$LN7@ProgramHos|
  000f4	e5de3009	 ldrb        r3, [lr, #9]
  000f8	e3530000	 cmp         r3, #0
  000fc	1a000012	 bne         |$LN7@ProgramHos|
  00100	e5de200a	 ldrb        r2, [lr, #0xA]
  00104	e3520000	 cmp         r2, #0
  00108	0a00000f	 beq         |$LN7@ProgramHos|

; 2351 :                 {
; 2352 :                     WRITE_PORT_UCHAR( (m_portBase+MGC_BUSCTL_OFFSET(EpNum, MGC_O_HDRC_TXHUBADDR)), pED->bfHubAddress);

  0010c	e5903140	 ldr         r3, [r0, #0x140]
  00110	e0833184	 add         r3, r3, r4, lsl #3
  00114	e5c32482	 strb        r2, [r3, #0x482]

; 2353 :                     WRITE_PORT_UCHAR( (m_portBase+MGC_BUSCTL_OFFSET(EpNum, MGC_O_HDRC_RXHUBADDR)), pED->bfHubAddress);

  00118	e5903140	 ldr         r3, [r0, #0x140]
  0011c	e5de200a	 ldrb        r2, [lr, #0xA]
  00120	e0833184	 add         r3, r3, r4, lsl #3
  00124	e5c32486	 strb        r2, [r3, #0x486]

; 2354 :                     WRITE_PORT_UCHAR( (m_portBase+MGC_BUSCTL_OFFSET(EpNum, MGC_O_HDRC_TXHUBPORT)), pED->bfHubPort);

  00128	e5903140	 ldr         r3, [r0, #0x140]
  0012c	e5de200b	 ldrb        r2, [lr, #0xB]
  00130	e0833184	 add         r3, r3, r4, lsl #3
  00134	e5c32483	 strb        r2, [r3, #0x483]

; 2355 :                     WRITE_PORT_UCHAR( (m_portBase+MGC_BUSCTL_OFFSET(EpNum, MGC_O_HDRC_RXHUBPORT)), pED->bfHubPort);

  00138	e5903140	 ldr         r3, [r0, #0x140]
  0013c	e5de200b	 ldrb        r2, [lr, #0xB]
  00140	e0833184	 add         r3, r3, r4, lsl #3
  00144	e5c32487	 strb        r2, [r3, #0x487]

; 2356 :                 }
; 2357 :                 else

  00148	ea000011	 b           |$LN12@ProgramHos|
  0014c		 |$LN7@ProgramHos|

; 2358 :                 {
; 2359 :                     WRITE_PORT_UCHAR( (m_portBase+MGC_BUSCTL_OFFSET(EpNum, MGC_O_HDRC_TXHUBADDR)), 0);

  0014c	e5903140	 ldr         r3, [r0, #0x140]
  00150	e3a02000	 mov         r2, #0
  00154	e0833184	 add         r3, r3, r4, lsl #3
  00158	e5c32482	 strb        r2, [r3, #0x482]

; 2360 :                     WRITE_PORT_UCHAR( (m_portBase+MGC_BUSCTL_OFFSET(EpNum, MGC_O_HDRC_RXHUBADDR)), 0);

  0015c	e5903140	 ldr         r3, [r0, #0x140]
  00160	e0833184	 add         r3, r3, r4, lsl #3
  00164	e5c32486	 strb        r2, [r3, #0x486]

; 2361 :                     WRITE_PORT_UCHAR( (m_portBase+MGC_BUSCTL_OFFSET(EpNum, MGC_O_HDRC_TXHUBPORT)), 0);

  00168	e5903140	 ldr         r3, [r0, #0x140]
  0016c	e0833184	 add         r3, r3, r4, lsl #3
  00170	e5c32483	 strb        r2, [r3, #0x483]

; 2362 :                     WRITE_PORT_UCHAR( (m_portBase+MGC_BUSCTL_OFFSET(EpNum, MGC_O_HDRC_RXHUBPORT)), 0);

  00174	e5903140	 ldr         r3, [r0, #0x140]
  00178	e0833184	 add         r3, r3, r4, lsl #3
  0017c	e5c32487	 strb        r2, [r3, #0x487]

; 2363 :                 }
; 2364 :             }
; 2365 : 
; 2366 :             break;

  00180	ea000003	 b           |$LN12@ProgramHos|
  00184		 |$LN11@ProgramHos|

; 2317 :         {
; 2318 :         case TYPE_CONTROL:
; 2319 :         case TYPE_BULK:
; 2320 : 
; 2321 :             pED->epType = (PIPE_TYPE)TransferType;

  00184	e58e1020	 str         r1, [lr, #0x20]

; 2322 :             // Note: Bulk and control are programmed in InitializeTransaction()
; 2323 :             break;

  00188	ea000001	 b           |$LN12@ProgramHos|
  0018c		 |$LN5@ProgramHos|

; 2367 : 
; 2368 :         default:
; 2369 : 
; 2370 :             DEBUGCHK(FALSE);
; 2371 :             pED->epType = TYPE_UNKNOWN;

  0018c	e3a03000	 mov         r3, #0
  00190	e58e3020	 str         r3, [lr, #0x20]
  00194		 |$LN12@ProgramHos|

; 2372 :         }
; 2373 : 
; 2374 :         if (pED->bHostEndPointNum)

  00194	e5de2010	 ldrb        r2, [lr, #0x10]
  00198	e3520000	 cmp         r2, #0
  0019c	0a000006	 beq         |$LN4@ProgramHos|

; 2375 :         {
; 2376 :             if(pED->bfDirection == TD_IN_PID)

  001a0	e5de3006	 ldrb        r3, [lr, #6]
  001a4	e3530002	 cmp         r3, #2

; 2377 :             {
; 2378 :                 pED->hSemaphore = m_EpInProtectSem[pED->bHostEndPointNum - 1];

  001a8	e0803102	 add         r3, r0, r2, lsl #2
  001ac	059331a4	 ldreq       r3, [r3, #0x1A4]
  001b0	0a000002	 beq         |$LN29@ProgramHos|

; 2379 :             }
; 2380 :             else
; 2381 :             {
; 2382 :                 pED->hSemaphore = m_EpOutProtectSem[pED->bHostEndPointNum - 1];

  001b4	e59331e0	 ldr         r3, [r3, #0x1E0]

; 2383 :             }
; 2384 :         }
; 2385 :         else

  001b8	ea000000	 b           |$LN29@ProgramHos|
  001bc		 |$LN4@ProgramHos|

; 2386 :         {
; 2387 :             pED->hSemaphore = m_Ep0ProtectSem;

  001bc	e59031a4	 ldr         r3, [r0, #0x1A4]
  001c0		 |$LN29@ProgramHos|
  001c0	e58e3030	 str         r3, [lr, #0x30]
  001c4		 |$LN1@ProgramHos|

; 2388 :         }
; 2389 :     }
; 2390 : 
; 2391 :     RETAILMSG(FALSE,(TEXT("ProgramHostEndpoint EP %u Type %d Direction%x\n"),
; 2392 :             EpNum, pED->epType, pED->bfDirection ));
; 2393 : }

  001c4	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  001c8	e12fff1e	 bx          lr
  001cc		 |$M43231|

			 ENDP  ; |?ProgramHostEndpoint@CHW@@QAAXIPAX@Z|, CHW::ProgramHostEndpoint

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?LoadEnpointConfiguration@CHW@@AAAHXZ|	; CHW::LoadEnpointConfiguration
	EXPORT	|??_C@_1O@GHFNHFJG@?$AAS?$AAh?$AAa?$AAr?$AAe?$AAd?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1O@NNPHCMKB@?$AAD?$AAo?$AAu?$AAb?$AAl?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_19PNJNFAOM@?$AAF?$AAi?$AAf?$AAo?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_17KCFFABIP@?$AAa?$AAn?$AAy?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BE@OLFPFCKI@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BI@KEIBCIAP@?$AAi?$AAs?$AAo?$AAc?$AAh?$AAr?$AAo?$AAn?$AAo?$AAu?$AAs?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_19LOMGGDBD@?$AAb?$AAu?$AAl?$AAk?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_19BIEPDBPA@?$AAT?$AAy?$AAp?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CE@LJDLLKHL@?$AA?$CF?$AAs?$AA?2?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA?2?$AAE?$AAP?$AA?$CF?$AAu?$AA?2?$AA?$CF?$AAs?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_15BNKBCKPG@?$AAI?$AAN?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_17HCEMPBGG@?$AAO?$AAU?$AAT?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|RegCloseKey|
	IMPORT	|_wcsicmp|
	IMPORT	|RegQueryValueExW|
	IMPORT	|RegOpenKeyExW|
	IMPORT	|StringCbPrintfW|

  00000			 AREA	 |.pdata|, PDATA
|$T43262| DCD	|$LN47@LoadEnpoin|
	DCD	0xc000bb02

  00000			 AREA	 |.xdata|, DATA
|$T43258| DCD	0xffffffd8

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1O@GHFNHFJG@?$AAS?$AAh?$AAa?$AAr?$AAe?$AAd?$AA?$AA@| DCB "S", 0x0, "h"
	DCB	0x0, "a", 0x0, "r", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1O@NNPHCMKB@?$AAD?$AAo?$AAu?$AAb?$AAl?$AAe?$AA?$AA@| DCB "D", 0x0, "o"
	DCB	0x0, "u", 0x0, "b", 0x0, "l", 0x0, "e", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_19PNJNFAOM@?$AAF?$AAi?$AAf?$AAo?$AA?$AA@| DCB "F", 0x0, "i", 0x0, "f"
	DCB	0x0, "o", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_17KCFFABIP@?$AAa?$AAn?$AAy?$AA?$AA@| DCB "a", 0x0, "n", 0x0, "y", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@OLFPFCKI@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AA?$AA@| DCB "i"
	DCB	0x0, "n", 0x0, "t", 0x0, "e", 0x0, "r", 0x0, "r", 0x0, "u"
	DCB	0x0, "p", 0x0, "t", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BI@KEIBCIAP@?$AAi?$AAs?$AAo?$AAc?$AAh?$AAr?$AAo?$AAn?$AAo?$AAu?$AAs?$AA?$AA@| DCB "i"
	DCB	0x0, "s", 0x0, "o", 0x0, "c", 0x0, "h", 0x0, "r", 0x0, "o"
	DCB	0x0, "n", 0x0, "o", 0x0, "u", 0x0, "s", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_19LOMGGDBD@?$AAb?$AAu?$AAl?$AAk?$AA?$AA@| DCB "b", 0x0, "u", 0x0, "l"
	DCB	0x0, "k", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_19BIEPDBPA@?$AAT?$AAy?$AAp?$AAe?$AA?$AA@| DCB "T", 0x0, "y", 0x0, "p"
	DCB	0x0, "e", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CE@LJDLLKHL@?$AA?$CF?$AAs?$AA?2?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA?2?$AAE?$AAP?$AA?$CF?$AAu?$AA?2?$AA?$CF?$AAs?$AA?$AA@| DCB "%"
	DCB	0x0, "s", 0x0, "\\", 0x0, "C", 0x0, "O", 0x0, "N", 0x0, "F"
	DCB	0x0, "I", 0x0, "G", 0x0, "\\", 0x0, "E", 0x0, "P", 0x0, "%"
	DCB	0x0, "u", 0x0, "\\", 0x0, "%", 0x0, "s", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_15BNKBCKPG@?$AAI?$AAN?$AA?$AA@| DCB "I", 0x0, "N", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_17HCEMPBGG@?$AAO?$AAU?$AAT?$AA?$AA@| DCB "O", 0x0, "U", 0x0, "T", 0x0
	DCB	0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T43258|

  00008		 |?LoadEnpointConfiguration@CHW@@AAAHXZ| PROC ; CHW::LoadEnpointConfiguration

; 2397 : {

  00008		 |$LN47@LoadEnpoin|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd09c	 sub         sp, sp, #0x9C
  00010		 |$M43259|
  00010	e1a09000	 mov         r9, r0
  00014	e59f32d4	 ldr         r3, [pc, #0x2D4]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3098	 str         r3, [sp, #0x98]

; 2398 :     const TCHAR *pszKeyFormat = L"%s\\CONFIG\\EP%u\\%s";
; 2399 :     HKEY hKey;
; 2400 :     EP_CONFIG *pConfig;
; 2401 :     DWORD i, j, dwSize, dwType, dwTemp;
; 2402 :     TCHAR *pszDir, szTemp[ 64 ];
; 2403 :     DWORD dwFifoUsage = 0;
; 2404 :     DWORD dwFifoEmpty = MGC_FIFO_RAM_SIZE - 64; // 64 bytes reserved for control EP0.
; 2405 : 
; 2406 :     // Loop through endpoints
; 2407 :     for (i = 0; i < (MGC_MAX_USB_ENDS - 1); i ++)

  00020	e3a05000	 mov         r5, #0
  00024	e3a06000	 mov         r6, #0
  00028	e28da008	 add         r10, sp, #8
  0002c	e28db010	 add         r11, sp, #0x10
  00030		 |$LL33@LoadEnpoin|

; 2408 :     {
; 2409 :         // Loop through directions
; 2410 :         for (j = 0; j < 2; j ++)

  00030	e3a07000	 mov         r7, #0

; 2411 :         {
; 2412 :             if (j)
; 2413 :             {
; 2414 :                 pszDir = L"OUT";
; 2415 :                 pConfig = m_EpOutConfig;
; 2416 :             }
; 2417 :             else
; 2418 :             {
; 2419 :                 pszDir = L"IN";
; 2420 :                 pConfig = m_EpInConfig;
; 2421 :             }
; 2422 : 
; 2423 :             // Open endpoint key
; 2424 :             if( SUCCEEDED( StringCbPrintf( szTemp, sizeof( szTemp ),
; 2425 :                                pszKeyFormat, ((SOhcdPdd*)m_pPddContext)->szDriverRegKey, i + 1, pszDir ) ) )
; 2426 :             {
; 2427 :                 if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTemp, 0, 0, &hKey) == ERROR_SUCCESS)
; 2428 :                 {
; 2429 :                     // Get EP type
; 2430 :                     dwType = REG_SZ;
; 2431 : #pragma warning(push)
; 2432 : #pragma warning(disable: 6260 6386)
; 2433 :                     dwSize = sizeof(szTemp) * sizeof(TCHAR);
; 2434 : 
; 2435 :                     if (RegQueryValueEx(hKey, L"Type", NULL, &dwType, (LPBYTE)szTemp, &dwSize) != ERROR_SUCCESS)
; 2436 :                     {
; 2437 :                         szTemp[ 0 ] = L'\0';
; 2438 :                     }
; 2439 :                     else
; 2440 :                     {
; 2441 :                         // force zero-termination
; 2442 :                         szTemp[ (sizeof(szTemp) / sizeof(szTemp[0])) - 1 ] = L'\0';
; 2443 :                     }
; 2444 : #pragma warning(pop)
; 2445 :                     if (!wcsicmp(szTemp, L"bulk"))
; 2446 :                     {
; 2447 :                         pConfig[ i ].epType = TYPE_BULK;

  00034	e2868001	 add         r8, r6, #1
  00038		 |$LL30@LoadEnpoin|
  00038	e3570000	 cmp         r7, #0
  0003c	159fe2a8	 ldrne       lr, [pc, #0x2A8]
  00040	e5993188	 ldr         r3, [r9, #0x188]
  00044	059fe29c	 ldreq       lr, [pc, #0x29C]
  00048	e59f2294	 ldr         r2, [pc, #0x294]
  0004c	12894e2b	 addne       r4, r9, #0x2B, 28
  00050	e3a01080	 mov         r1, #0x80
  00054	e2833008	 add         r3, r3, #8
  00058	e28d0018	 add         r0, sp, #0x18
  0005c	e58de004	 str         lr, [sp, #4]
  00060	02894f8e	 addeq       r4, r9, #0x8E, 30
  00064	e58d8000	 str         r8, [sp]
  00068	eb000000	 bl          StringCbPrintfW
  0006c	e3500000	 cmp         r0, #0
  00070	4a00007a	 bmi         |$LN25@LoadEnpoin|
  00074	e3a03000	 mov         r3, #0
  00078	e3a02000	 mov         r2, #0
  0007c	e28d1018	 add         r1, sp, #0x18
  00080	e3a0010a	 mov         r0, #0xA, 2
  00084	e58da000	 str         r10, [sp]
  00088	eb000000	 bl          RegOpenKeyExW
  0008c	e3500000	 cmp         r0, #0
  00090	1a000072	 bne         |$LN25@LoadEnpoin|
  00094	e3a0e001	 mov         lr, #1
  00098	e58de00c	 str         lr, [sp, #0xC]
  0009c	e3a0ec01	 mov         lr, #1, 24
  000a0	e59d0008	 ldr         r0, [sp, #8]
  000a4	e59f1234	 ldr         r1, [pc, #0x234]
  000a8	e58de010	 str         lr, [sp, #0x10]
  000ac	e28de018	 add         lr, sp, #0x18
  000b0	e28d300c	 add         r3, sp, #0xC
  000b4	e3a02000	 mov         r2, #0
  000b8	e58de000	 str         lr, [sp]
  000bc	e58db004	 str         r11, [sp, #4]
  000c0	eb000000	 bl          RegQueryValueExW
  000c4	e59f1210	 ldr         r1, [pc, #0x210]
  000c8	e3500000	 cmp         r0, #0
  000cc	e3a03000	 mov         r3, #0
  000d0	e28d0018	 add         r0, sp, #0x18
  000d4	11cd31b8	 strneh      r3, [sp, #0x18]
  000d8	01cd39b6	 streqh      r3, [sp, #0x96]
  000dc	eb000000	 bl          _wcsicmp
  000e0	e3500000	 cmp         r0, #0
  000e4	03a03002	 moveq       r3, #2
  000e8	0a000011	 beq         |$LN44@LoadEnpoin|

; 2448 :                     }
; 2449 :                     else if (!wcsicmp(szTemp, L"isochronous"))

  000ec	e59f11e4	 ldr         r1, [pc, #0x1E4]
  000f0	e28d0018	 add         r0, sp, #0x18
  000f4	eb000000	 bl          _wcsicmp
  000f8	e3500000	 cmp         r0, #0

; 2450 :                     {
; 2451 :                         pConfig[ i ].epType = TYPE_ISOCHRONOUS;

  000fc	03a03004	 moveq       r3, #4
  00100	0a00000b	 beq         |$LN44@LoadEnpoin|

; 2452 :                     }
; 2453 :                     else if (!wcsicmp(szTemp, L"interrupt"))

  00104	e59f11c8	 ldr         r1, [pc, #0x1C8]
  00108	e28d0018	 add         r0, sp, #0x18
  0010c	eb000000	 bl          _wcsicmp
  00110	e3500000	 cmp         r0, #0

; 2454 :                     {
; 2455 :                         pConfig[ i ].epType = TYPE_INTERRUPT;

  00114	03a03003	 moveq       r3, #3
  00118	0a000005	 beq         |$LN44@LoadEnpoin|

; 2456 :                     }
; 2457 :                     else if (!wcsicmp(szTemp, L"any"))

  0011c	e59f11ac	 ldr         r1, [pc, #0x1AC]
  00120	e28d0018	 add         r0, sp, #0x18
  00124	eb000000	 bl          _wcsicmp
  00128	e3500000	 cmp         r0, #0
  0012c	1a00005c	 bne         |$LN38@LoadEnpoin|

; 2458 :                     {
; 2459 :                         pConfig[ i ].epType = TYPE_ANY;

  00130	e3a03005	 mov         r3, #5
  00134		 |$LN44@LoadEnpoin|

; 2460 :                     }
; 2461 :                     else
; 2462 :                     {
; 2463 :                         DEBUGMSG( ZONE_ERROR, (TEXT("CHW::LoadEnpointConfiguration: endpoint type invalid or unspecified, EP %u %s\n"),
; 2464 :                             i, pszDir));
; 2465 : 
; 2466 :                         RegCloseKey(hKey);
; 2467 :                         return FALSE;
; 2468 :                     }
; 2469 : 
; 2470 :                     // Get FIFO size
; 2471 :                     dwType = REG_DWORD;
; 2472 :                     dwSize = sizeof(dwTemp);
; 2473 :                     if (RegQueryValueEx(hKey, L"Fifo", NULL, &dwType, (LPBYTE)&dwTemp, &dwSize) != ERROR_SUCCESS)

  00134	e3a0e004	 mov         lr, #4
  00138	e58de00c	 str         lr, [sp, #0xC]
  0013c	e3a0e004	 mov         lr, #4
  00140	e58de010	 str         lr, [sp, #0x10]
  00144	e28de010	 add         lr, sp, #0x10
  00148	e59d0008	 ldr         r0, [sp, #8]
  0014c	e59f1178	 ldr         r1, [pc, #0x178]
  00150	e0844186	 add         r4, r4, r6, lsl #3
  00154	e58de004	 str         lr, [sp, #4]
  00158	e28de014	 add         lr, sp, #0x14
  0015c	e5c43001	 strb        r3, [r4, #1]
  00160	e28d300c	 add         r3, sp, #0xC
  00164	e3a02000	 mov         r2, #0
  00168	e58de000	 str         lr, [sp]
  0016c	eb000000	 bl          RegQueryValueExW
  00170	e3500000	 cmp         r0, #0

; 2474 :                     {
; 2475 :                         dwTemp = 0;

  00174	13a0e000	 movne       lr, #0
  00178	158de014	 strne       lr, [sp, #0x14]
  0017c	059de014	 ldreq       lr, [sp, #0x14]

; 2476 :                     }
; 2477 : 
; 2478 :                     if (!dwTemp || (dwTemp > 1024) || (dwTemp & 0x03))

  00180	e35e0000	 cmp         lr, #0
  00184	0a000046	 beq         |$LN38@LoadEnpoin|
  00188	e35e0b01	 cmp         lr, #1, 22
  0018c	8a000044	 bhi         |$LN38@LoadEnpoin|
  00190	e31e0003	 tst         lr, #3
  00194	1a000042	 bne         |$LN38@LoadEnpoin|

; 2484 :                         return FALSE;
; 2485 :                     }
; 2486 : 
; 2487 :                     pConfig[ i ].fifoSize = (UINT16)dwTemp;
; 2488 : 
; 2489 :                     // Get double buffering mode flag
; 2490 :                     pConfig[ i ].fDBMode = 0;
; 2491 :                     dwType = REG_DWORD;
; 2492 :                     dwSize = sizeof(dwTemp);
; 2493 :                     if (RegQueryValueEx(hKey, L"Double", NULL, &dwType, (LPBYTE)&dwTemp, &dwSize) == ERROR_SUCCESS)

  00198	e1c4e0b6	 strh        lr, [r4, #6]
  0019c	e3a0e000	 mov         lr, #0
  001a0	e5c4e003	 strb        lr, [r4, #3]
  001a4	e3a0e004	 mov         lr, #4
  001a8	e58de00c	 str         lr, [sp, #0xC]
  001ac	e3a0e004	 mov         lr, #4
  001b0	e58de010	 str         lr, [sp, #0x10]
  001b4	e28de010	 add         lr, sp, #0x10
  001b8	e59d0008	 ldr         r0, [sp, #8]
  001bc	e59f1104	 ldr         r1, [pc, #0x104]
  001c0	e58de004	 str         lr, [sp, #4]
  001c4	e28de014	 add         lr, sp, #0x14
  001c8	e28d300c	 add         r3, sp, #0xC
  001cc	e3a02000	 mov         r2, #0
  001d0	e58de000	 str         lr, [sp]
  001d4	eb000000	 bl          RegQueryValueExW
  001d8	e3500000	 cmp         r0, #0

; 2494 :                     {
; 2495 :                         pConfig[ i ].fDBMode = (UINT8)dwTemp;

  001dc	059d3014	 ldreq       r3, [sp, #0x14]

; 2496 :                     }
; 2497 : 
; 2498 :                     // Get sharing mode flag (applicable to bulk only) - default ON
; 2499 :                     pConfig[ i ].fSharedMode = 1;
; 2500 :                     if (pConfig[ i ].epType == TYPE_BULK || pConfig[ i ].epType == TYPE_ANY)

  001e0	e3a02001	 mov         r2, #1
  001e4	e5c42004	 strb        r2, [r4, #4]
  001e8	05c43003	 streqb      r3, [r4, #3]
  001ec	e5d43001	 ldrb        r3, [r4, #1]
  001f0	e3530002	 cmp         r3, #2
  001f4	0a000001	 beq         |$LN8@LoadEnpoin|
  001f8	e3530005	 cmp         r3, #5
  001fc	1a00000f	 bne         |$LN7@LoadEnpoin|
  00200		 |$LN8@LoadEnpoin|

; 2501 :                     {
; 2502 :                         dwType = REG_DWORD;
; 2503 :                         dwSize = sizeof(dwTemp);
; 2504 :                         if (RegQueryValueEx(hKey, L"Shared", NULL, &dwType, (LPBYTE)&dwTemp, &dwSize) == ERROR_SUCCESS)

  00200	e3a0e004	 mov         lr, #4
  00204	e58de00c	 str         lr, [sp, #0xC]
  00208	e3a0e004	 mov         lr, #4
  0020c	e58de010	 str         lr, [sp, #0x10]
  00210	e28de010	 add         lr, sp, #0x10
  00214	e59d0008	 ldr         r0, [sp, #8]
  00218	e59f10a4	 ldr         r1, [pc, #0xA4]
  0021c	e58de004	 str         lr, [sp, #4]
  00220	e28de014	 add         lr, sp, #0x14
  00224	e28d300c	 add         r3, sp, #0xC
  00228	e3a02000	 mov         r2, #0
  0022c	e58de000	 str         lr, [sp]
  00230	eb000000	 bl          RegQueryValueExW
  00234	e3500000	 cmp         r0, #0

; 2505 :                         {
; 2506 :                             pConfig[ i ].fSharedMode = (UINT8)dwTemp;

  00238	059d3014	 ldreq       r3, [sp, #0x14]
  0023c	05c43004	 streqb      r3, [r4, #4]
  00240		 |$LN7@LoadEnpoin|

; 2507 :                         }
; 2508 :                     }
; 2509 : 
; 2510 :                     if (pConfig[ i ].fDBMode)

  00240	e5d43003	 ldrb        r3, [r4, #3]

; 2511 :                     {
; 2512 :                         dwFifoUsage += (pConfig[ i ].fifoSize << 1);
; 2513 :                     }
; 2514 :                     else
; 2515 :                     {
; 2516 :                         dwFifoUsage += pConfig[ i ].fifoSize;
; 2517 :                     }
; 2518 : 
; 2519 :                     RegCloseKey(hKey);

  00244	e59d0008	 ldr         r0, [sp, #8]
  00248	e3530000	 cmp         r3, #0
  0024c	e1d430b6	 ldrh        r3, [r4, #6]
  00250	10855083	 addne       r5, r5, r3, lsl #1
  00254	00855003	 addeq       r5, r5, r3
  00258	eb000000	 bl          RegCloseKey

; 2520 :                 }
; 2521 :                 else

  0025c	ea000000	 b           |$LN29@LoadEnpoin|
  00260		 |$LN25@LoadEnpoin|

; 2522 :                 {
; 2523 :                     // There is no way to completely skip unused endpoints. We still
; 2524 :                     // have to allocate at least 8 bytes (minimum).
; 2525 :                     dwFifoUsage += 8;
; 2526 :                 }
; 2527 :             }
; 2528 :             else
; 2529 :             {
; 2530 :                 // There is no way to completely skip unused endpoints. We still
; 2531 :                 // have to allocate at least 8 bytes (minimum).
; 2532 :                 dwFifoUsage += 8;

  00260	e2855008	 add         r5, r5, #8
  00264		 |$LN29@LoadEnpoin|

; 2408 :     {
; 2409 :         // Loop through directions
; 2410 :         for (j = 0; j < 2; j ++)

  00264	e2877001	 add         r7, r7, #1
  00268	e3570002	 cmp         r7, #2
  0026c	3affff71	 bcc         |$LL30@LoadEnpoin|
  00270	e1a06008	 mov         r6, r8
  00274	e358000f	 cmp         r8, #0xF
  00278	baffff6c	 blt         |$LL33@LoadEnpoin|

; 2533 :             }
; 2534 :         }
; 2535 :     }
; 2536 : 
; 2537 :     // Validate configuration
; 2538 :     if (!dwFifoUsage || (dwFifoUsage > dwFifoEmpty))

  0027c	e3550000	 cmp         r5, #0
  00280	0a000009	 beq         |$LN1@LoadEnpoin|
  00284	e3a03c7f	 mov         r3, #0x7F, 24
  00288	e38330c0	 orr         r3, r3, #0xC0
  0028c	e1550003	 cmp         r5, r3
  00290	8a000005	 bhi         |$LN1@LoadEnpoin|

; 2542 :     }
; 2543 : 
; 2544 :     return TRUE;

  00294	e59d0098	 ldr         r0, [sp, #0x98]
  00298	eb000000	 bl          __security_check_cookie
  0029c	e3a00001	 mov         r0, #1
  002a0	ea000004	 b           |$LN34@LoadEnpoin|
  002a4		 |$LN38@LoadEnpoin|

; 2479 :                     {
; 2480 :                         DEBUGMSG( ZONE_ERROR, (TEXT("CHW::LoadEnpointConfiguration: endpoint FIFO size invalid or unspecified, EP %u %s %d\n"),
; 2481 :                             i, pszDir, dwTemp));
; 2482 : 
; 2483 :                         RegCloseKey(hKey);

  002a4	e59d0008	 ldr         r0, [sp, #8]
  002a8	eb000000	 bl          RegCloseKey
  002ac		 |$LN1@LoadEnpoin|

; 2539 :     {
; 2540 :         DEBUGMSG( ZONE_ERROR, (TEXT("CHW::LoadEnpointConfiguration: endpoint configuration not defined or invalid!\n")));
; 2541 :         return FALSE;

  002ac	e59d0098	 ldr         r0, [sp, #0x98]
  002b0	eb000000	 bl          __security_check_cookie
  002b4	e3a00000	 mov         r0, #0
  002b8		 |$LN34@LoadEnpoin|

; 2545 : }

  002b8	e28dd09c	 add         sp, sp, #0x9C
  002bc	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  002c0	e12fff1e	 bx          lr
  002c4		 |$LN48@LoadEnpoin|
  002c4		 |$LN49@LoadEnpoin|
  002c4	00000000	 DCD         |??_C@_1O@GHFNHFJG@?$AAS?$AAh?$AAa?$AAr?$AAe?$AAd?$AA?$AA@|
  002c8		 |$LN50@LoadEnpoin|
  002c8	00000000	 DCD         |??_C@_1O@NNPHCMKB@?$AAD?$AAo?$AAu?$AAb?$AAl?$AAe?$AA?$AA@|
  002cc		 |$LN51@LoadEnpoin|
  002cc	00000000	 DCD         |??_C@_19PNJNFAOM@?$AAF?$AAi?$AAf?$AAo?$AA?$AA@|
  002d0		 |$LN52@LoadEnpoin|
  002d0	00000000	 DCD         |??_C@_17KCFFABIP@?$AAa?$AAn?$AAy?$AA?$AA@|
  002d4		 |$LN53@LoadEnpoin|
  002d4	00000000	 DCD         |??_C@_1BE@OLFPFCKI@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AA?$AA@|
  002d8		 |$LN54@LoadEnpoin|
  002d8	00000000	 DCD         |??_C@_1BI@KEIBCIAP@?$AAi?$AAs?$AAo?$AAc?$AAh?$AAr?$AAo?$AAn?$AAo?$AAu?$AAs?$AA?$AA@|
  002dc		 |$LN55@LoadEnpoin|
  002dc	00000000	 DCD         |??_C@_19LOMGGDBD@?$AAb?$AAu?$AAl?$AAk?$AA?$AA@|
  002e0		 |$LN56@LoadEnpoin|
  002e0	00000000	 DCD         |??_C@_19BIEPDBPA@?$AAT?$AAy?$AAp?$AAe?$AA?$AA@|
  002e4		 |$LN57@LoadEnpoin|
  002e4	00000000	 DCD         |??_C@_1CE@LJDLLKHL@?$AA?$CF?$AAs?$AA?2?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA?2?$AAE?$AAP?$AA?$CF?$AAu?$AA?2?$AA?$CF?$AAs?$AA?$AA@|
  002e8		 |$LN58@LoadEnpoin|
  002e8	00000000	 DCD         |??_C@_15BNKBCKPG@?$AAI?$AAN?$AA?$AA@|
  002ec		 |$LN59@LoadEnpoin|
  002ec	00000000	 DCD         |??_C@_17HCEMPBGG@?$AAO?$AAU?$AAT?$AA?$AA@|
  002f0		 |$LN60@LoadEnpoin|
  002f0	00000000	 DCD         |__security_cookie|
  002f4		 |$M43260|

			 ENDP  ; |?LoadEnpointConfiguration@CHW@@AAAHXZ|, CHW::LoadEnpointConfiguration

	EXPORT	|?InitialiseFIFOs@CHW@@AAAXXZ|		; CHW::InitialiseFIFOs
; File c:\wince600\platform\common\src\soc\common_ti_v1\am3517\usb\usbh\chw.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T43333| DCD	|$LN43@Initialise|
	DCD	0x40009101
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\am3517\usb\usbh\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InitialiseFIFOs@CHW@@AAAXXZ| PROC	; CHW::InitialiseFIFOs

; 2558 : {

  00000		 |$LN43@Initialise|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M43330|
  00004	e1a07000	 mov         r7, r0

; 2559 :     // Use configurable static FIFO alloc
; 2560 : 
; 2561 :     UINT8 fifoSize, epNum, DPB;
; 2562 :     UINT16 byteFifoSize;
; 2563 : 
; 2564 :     m_wFifoOffset = 0;

  00008	e2873c01	 add         r3, r7, #1, 24
  0000c	e3a0b000	 mov         r11, #0
  00010	e1c3b9b4	 strh        r11, [r3, #0x94]

; 2565 : 
; 2566 :     // Configure control EP0
; 2567 :     byteFifoSize = 64; // 64 bytes
; 2568 :     fifoSize = Byte2FifoSize(byteFifoSize);

  00014	e3a0e000	 mov         lr, #0
  00018	e3a02001	 mov         r2, #1
  0001c		 |$LL15@Initialise|
  0001c	e28e3003	 add         r3, lr, #3
  00020	e1a03312	 mov         r3, r2, lsl r3
  00024	e3530040	 cmp         r3, #0x40
  00028	0a000004	 beq         |$LN34@Initialise|
  0002c	e28e3001	 add         r3, lr, #1
  00030	e203e0ff	 and         lr, r3, #0xFF
  00034	e35e000a	 cmp         lr, #0xA
  00038	3afffff7	 bcc         |$LL15@Initialise|
  0003c	e3a0e0ff	 mov         lr, #0xFF
  00040		 |$LN34@Initialise|

; 2569 :     DEBUGCHK(fifoSize != (UINT8)-1);
; 2570 : 
; 2571 :     // Index register
; 2572 :     WRITE_PORT_UCHAR( (m_portBase + USB_INDEX_REG_OFFSET), 0);

  00040	e2874d05	 add         r4, r7, #5, 26
  00044	e5943000	 ldr         r3, [r4]

; 2573 : 
; 2574 :     // Adjust EP FIFO pointers
; 2575 :     WRITE_PORT_USHORT( (m_portBase+MGC_O_HDRC_TXFIFOADD), m_wFifoOffset >> 3);
; 2576 :     WRITE_PORT_USHORT( (m_portBase+MGC_O_HDRC_RXFIFOADD), m_wFifoOffset >> 3);
; 2577 : 
; 2578 :     // Assign EP FIFO size
; 2579 :     WRITE_PORT_UCHAR( (m_portBase+MGC_O_HDRC_TXFIFOSZ), fifoSize);
; 2580 :     WRITE_PORT_UCHAR( (m_portBase+MGC_O_HDRC_RXFIFOSZ), fifoSize);
; 2581 : 
; 2582 :     m_wFifoOffset = m_wFifoOffset + byteFifoSize;
; 2583 : 
; 2584 :     // Configure EP<1-4>
; 2585 :     for (epNum = 0; epNum < (MGC_MAX_USB_ENDS - 1); epNum ++)

  00048	e3a0a000	 mov         r10, #0
  0004c	e3a08000	 mov         r8, #0
  00050	e5c3b40e	 strb        r11, [r3, #0x40E]
  00054	e5943000	 ldr         r3, [r4]
  00058	e1d425b4	 ldrh        r2, [r4, #0x54]
  0005c	e2831b01	 add         r1, r3, #1, 22
  00060	e1a031a2	 mov         r3, r2, lsr #3
  00064	e1c136b4	 strh        r3, [r1, #0x64]
  00068	e5943000	 ldr         r3, [r4]
  0006c	e1d425b4	 ldrh        r2, [r4, #0x54]
  00070	e2831b01	 add         r1, r3, #1, 22
  00074	e1a031a2	 mov         r3, r2, lsr #3
  00078	e1c136b6	 strh        r3, [r1, #0x66]
  0007c	e5943000	 ldr         r3, [r4]
  00080	e3a01001	 mov         r1, #1
  00084	e5c3e462	 strb        lr, [r3, #0x462]
  00088	e5943000	 ldr         r3, [r4]
  0008c	e5c3e463	 strb        lr, [r3, #0x463]
  00090	e1d435b4	 ldrh        r3, [r4, #0x54]
  00094	e2833040	 add         r3, r3, #0x40
  00098	e1c435b4	 strh        r3, [r4, #0x54]
  0009c		 |$LL9@Initialise|

; 2586 :     {
; 2587 :         // Index register
; 2588 :         WRITE_PORT_UCHAR( (m_portBase + USB_INDEX_REG_OFFSET), (epNum + 1));

  0009c	e5942000	 ldr         r2, [r4]
  000a0	e2883001	 add         r3, r8, #1
  000a4	e20380ff	 and         r8, r3, #0xFF

; 2589 : 
; 2590 :         ///////////////////////////////////////////////////////////////////////////
; 2591 :         // Configure in
; 2592 :         DPB = 0;
; 2593 : 
; 2594 :         if (m_EpInConfig[ epNum ].epType != TYPE_UNKNOWN)

  000a8	e087518a	 add         r5, r7, r10, lsl #3
  000ac	e5c2840e	 strb        r8, [r2, #0x40E]
  000b0	e5d53239	 ldrb        r3, [r5, #0x239]
  000b4	e3a09000	 mov         r9, #0
  000b8	e3530000	 cmp         r3, #0
  000bc	0a000009	 beq         |$LN6@Initialise|

; 2595 :         {
; 2596 :             byteFifoSize = m_EpInConfig[ epNum ].fifoSize;
; 2597 : 
; 2598 :             if (m_EpInConfig[ epNum ].fDBMode)

  000c0	e5d5223b	 ldrb        r2, [r5, #0x23B]
  000c4	e2853c02	 add         r3, r5, #2, 24
  000c8	e1d363be	 ldrh        r6, [r3, #0x3E]
  000cc	e3520000	 cmp         r2, #0
  000d0	0a000005	 beq         |$LN4@Initialise|

; 2599 :             {
; 2600 :                 // Double buffered
; 2601 :                 byteFifoSize <<= 1;

  000d4	e1a03086	 mov         r3, r6, lsl #1
  000d8	e1a06803	 mov         r6, r3, lsl #16
  000dc	e1a06826	 mov         r6, r6, lsr #16

; 2602 :                 DPB = (1 << 4);

  000e0	e3a09010	 mov         r9, #0x10

; 2603 :             }
; 2604 :         }
; 2605 :         else

  000e4	ea000000	 b           |$LN4@Initialise|
  000e8		 |$LN6@Initialise|

; 2606 :         {
; 2607 :             // 8 bytes minimum
; 2608 :             byteFifoSize = 8;

  000e8	e3a06008	 mov         r6, #8
  000ec		 |$LN4@Initialise|

; 2609 :         }
; 2610 : 
; 2611 :         fifoSize = Byte2FifoSize(byteFifoSize);

  000ec	e3a00000	 mov         r0, #0
  000f0		 |$LL21@Initialise|
  000f0	e2803003	 add         r3, r0, #3
  000f4	e1560311	 cmp         r6, r1, lsl r3
  000f8	0a000004	 beq         |$LN35@Initialise|
  000fc	e2803001	 add         r3, r0, #1
  00100	e20300ff	 and         r0, r3, #0xFF
  00104	e350000a	 cmp         r0, #0xA
  00108	3afffff8	 bcc         |$LL21@Initialise|
  0010c	e3a000ff	 mov         r0, #0xFF
  00110		 |$LN35@Initialise|

; 2612 : 
; 2613 :         DEBUGCHK(fifoSize != (UINT8)-1);
; 2614 :         DEBUGCHK((m_wFifoOffset + byteFifoSize) <= MGC_FIFO_RAM_SIZE);
; 2615 : 
; 2616 :         // Adjust EP FIFO pointer
; 2617 :         WRITE_PORT_USHORT( (m_portBase+MGC_O_HDRC_RXFIFOADD), m_wFifoOffset >> 3);

  00110	e5943000	 ldr         r3, [r4]
  00114	e287ec01	 add         lr, r7, #1, 24
  00118	e1de29b4	 ldrh        r2, [lr, #0x94]
  0011c	e2831b01	 add         r1, r3, #1, 22

; 2618 :         m_wFifoOffset = m_wFifoOffset + byteFifoSize;
; 2619 : 
; 2620 :         // Assign EP FIFO size
; 2621 :         WRITE_PORT_UCHAR( (m_portBase+MGC_O_HDRC_RXFIFOSZ), fifoSize | DPB);

  00120	e1800009	 orr         r0, r0, r9
  00124	e1a031a2	 mov         r3, r2, lsr #3
  00128	e1c136b6	 strh        r3, [r1, #0x66]
  0012c	e5943000	 ldr         r3, [r4]
  00130	e1de29b4	 ldrh        r2, [lr, #0x94]
  00134	e2831b01	 add         r1, r3, #1, 22
  00138	e0823006	 add         r3, r2, r6
  0013c	e1ce39b4	 strh        r3, [lr, #0x94]
  00140	e5c10063	 strb        r0, [r1, #0x63]

; 2622 : 
; 2623 :         ///////////////////////////////////////////////////////////////////////////
; 2624 :         // Configure out
; 2625 :         DPB = 0;
; 2626 : 
; 2627 :         if (m_EpOutConfig[ epNum ].epType != TYPE_UNKNOWN)

  00144	e5d532b1	 ldrb        r3, [r5, #0x2B1]
  00148	e3a06000	 mov         r6, #0
  0014c	e3530000	 cmp         r3, #0
  00150	0a000009	 beq         |$LN3@Initialise|

; 2628 :         {
; 2629 :             byteFifoSize = m_EpOutConfig[ epNum ].fifoSize;
; 2630 : 
; 2631 :             if (m_EpOutConfig[ epNum ].fDBMode)

  00154	e5d522b3	 ldrb        r2, [r5, #0x2B3]
  00158	e2853c02	 add         r3, r5, #2, 24
  0015c	e1d35bb6	 ldrh        r5, [r3, #0xB6]
  00160	e3520000	 cmp         r2, #0
  00164	0a000005	 beq         |$LN1@Initialise|

; 2632 :             {
; 2633 :                 // Double buffered
; 2634 :                 byteFifoSize <<= 1;

  00168	e1a03085	 mov         r3, r5, lsl #1
  0016c	e1a05803	 mov         r5, r3, lsl #16
  00170	e1a05825	 mov         r5, r5, lsr #16

; 2635 :                 DPB = (1 << 4);

  00174	e3a06010	 mov         r6, #0x10

; 2636 :             }
; 2637 :         }
; 2638 :         else

  00178	ea000000	 b           |$LN1@Initialise|
  0017c		 |$LN3@Initialise|

; 2639 :         {
; 2640 :             // 8 bytes minimum
; 2641 :             byteFifoSize = 8;

  0017c	e3a05008	 mov         r5, #8
  00180		 |$LN1@Initialise|

; 2642 :         }
; 2643 : 
; 2644 :         fifoSize = Byte2FifoSize(byteFifoSize);

  00180	e3a00000	 mov         r0, #0
  00184	e3a02001	 mov         r2, #1
  00188		 |$LL27@Initialise|
  00188	e2803003	 add         r3, r0, #3
  0018c	e1550312	 cmp         r5, r2, lsl r3
  00190	0a000004	 beq         |$LN36@Initialise|
  00194	e2803001	 add         r3, r0, #1
  00198	e20300ff	 and         r0, r3, #0xFF
  0019c	e350000a	 cmp         r0, #0xA
  001a0	3afffff8	 bcc         |$LL27@Initialise|
  001a4	e3a000ff	 mov         r0, #0xFF
  001a8		 |$LN36@Initialise|

; 2645 : 
; 2646 :         DEBUGCHK(fifoSize != (UINT8)-1);
; 2647 :         DEBUGCHK((m_wFifoOffset + byteFifoSize) <= MGC_FIFO_RAM_SIZE);
; 2648 : 
; 2649 :         // Adjust EP FIFO pointer
; 2650 :         WRITE_PORT_USHORT( (m_portBase+MGC_O_HDRC_TXFIFOADD), m_wFifoOffset >> 3);

  001a8	e5943000	 ldr         r3, [r4]
  001ac	e287ec01	 add         lr, r7, #1, 24
  001b0	e1de29b4	 ldrh        r2, [lr, #0x94]
  001b4	e2831b01	 add         r1, r3, #1, 22

; 2651 :         m_wFifoOffset = m_wFifoOffset + byteFifoSize;
; 2652 : 
; 2653 :         // Assign EP FIFO size
; 2654 :         WRITE_PORT_UCHAR( (m_portBase+MGC_O_HDRC_TXFIFOSZ), fifoSize | DPB);

  001b8	e1800006	 orr         r0, r0, r6
  001bc	e1a031a2	 mov         r3, r2, lsr #3
  001c0	e1c136b4	 strh        r3, [r1, #0x64]
  001c4	e5943000	 ldr         r3, [r4]
  001c8	e1de29b4	 ldrh        r2, [lr, #0x94]

; 2655 : 
; 2656 : 
; 2657 :         // Clean any previous setup
; 2658 :         WRITE_PORT_UCHAR( (m_portBase + MGC_END_OFFSET(epNum, MGC_O_HDRC_RXTYPE)), 0x0);

  001cc	e358000f	 cmp         r8, #0xF
  001d0	e2831b01	 add         r1, r3, #1, 22
  001d4	e0823005	 add         r3, r2, r5
  001d8	e1ce39b4	 strh        r3, [lr, #0x94]
  001dc	e5c10062	 strb        r0, [r1, #0x62]
  001e0	e5943000	 ldr         r3, [r4]

; 2659 :         WRITE_PORT_UCHAR( (m_portBase + MGC_END_OFFSET(epNum, MGC_O_HDRC_TXTYPE)), 0x0);
; 2660 :         WRITE_PORT_UCHAR( (m_portBase + MGC_END_OFFSET(epNum, MGC_O_HDRC_RXINTERVAL)), 0x0);
; 2661 :         WRITE_PORT_USHORT( (m_portBase + MGC_END_OFFSET(epNum, MGC_O_HDRC_RXCSR)), 0);
; 2662 :         WRITE_PORT_UCHAR( (m_portBase + MGC_END_OFFSET(epNum, MGC_O_HDRC_TXINTERVAL)), 0x0);
; 2663 :         WRITE_PORT_USHORT( (m_portBase + MGC_END_OFFSET(epNum, MGC_O_HDRC_TXCSR)), 0);

  001e4	e3a01001	 mov         r1, #1
  001e8	e083320a	 add         r3, r3, r10, lsl #4
  001ec	e5c3b50c	 strb        r11, [r3, #0x50C]
  001f0	e5943000	 ldr         r3, [r4]
  001f4	e083320a	 add         r3, r3, r10, lsl #4
  001f8	e5c3b50a	 strb        r11, [r3, #0x50A]
  001fc	e5943000	 ldr         r3, [r4]
  00200	e083320a	 add         r3, r3, r10, lsl #4
  00204	e5c3b50d	 strb        r11, [r3, #0x50D]
  00208	e5943000	 ldr         r3, [r4]
  0020c	e083320a	 add         r3, r3, r10, lsl #4
  00210	e2833c05	 add         r3, r3, #5, 24
  00214	e1c3b0b6	 strh        r11, [r3, #6]
  00218	e5943000	 ldr         r3, [r4]
  0021c	e083320a	 add         r3, r3, r10, lsl #4
  00220	e5c3b50b	 strb        r11, [r3, #0x50B]
  00224	e5943000	 ldr         r3, [r4]
  00228	e083320a	 add         r3, r3, r10, lsl #4
  0022c	e2833c05	 add         r3, r3, #5, 24
  00230	e1c3b0b2	 strh        r11, [r3, #2]
  00234	e1a0a008	 mov         r10, r8
  00238	3affff97	 bcc         |$LL9@Initialise|

; 2664 :     }
; 2665 : }

  0023c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00240	e12fff1e	 bx          lr
  00244		 |$M43331|

			 ENDP  ; |?InitialiseFIFOs@CHW@@AAAXXZ|, CHW::InitialiseFIFOs

	EXPORT	|?InitializeTransaction@CHW@@QAAXIPAX0@Z| ; CHW::InitializeTransaction
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T43378| DCD	|$LN63@Initialize|
	DCD	0x40017c02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\am3517\usb\usbh\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InitializeTransaction@CHW@@QAAXIPAX0@Z| PROC ; CHW::InitializeTransaction

; 2679 : {

  00000		 |$LN63@Initialize|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd044	 sub         sp, sp, #0x44
  00008		 |$M43375|
  00008	e1a0a003	 mov         r10, r3
  0000c	e1a0e002	 mov         lr, r2
  00010	e58da02c	 str         r10, [sp, #0x2C]
  00014	e58de030	 str         lr, [sp, #0x30]
  00018	e1a04001	 mov         r4, r1

; 2680 :     UINT8 *pPkt, *pData, epType;
; 2681 :     DWORD CopyCount;
; 2682 :     UINT16 HOST_CSR;
; 2683 :     USBED *pED = (USBED *)pEndDesc;
; 2684 :     USBTD *pTD = (USBTD *)pTransDesc;
; 2685 : 
; 2686 :     // Just in case
; 2687 :     DEBUGCHK(pED != NULL);
; 2688 :     DEBUGCHK(pTD != NULL);
; 2689 : 
; 2690 :     // Grab EP type
; 2691 :     epType = pED->bfAttributes & USB_ENDPOINT_TYPE_MASK;

  0001c	e5de3007	 ldrb        r3, [lr, #7]

; 2692 :     CopyCount = MIN(pED->bfMaxPacketSize, pTD->BytesToTransfer);

  00020	e1de50be	 ldrh        r5, [lr, #0xE]
  00024	e58d3038	 str         r3, [sp, #0x38]
  00028	e59a3058	 ldr         r3, [r10, #0x58]
  0002c	e1550003	 cmp         r5, r3
  00030	21a05003	 movcs       r5, r3

; 2693 : 
; 2694 :     // Fail transfer immediately when disconnected
; 2695 :     if ((m_portStatus & PORT_STATUS_DEVICE_ATTACHED) == 0)

  00034	e5d03196	 ldrb        r3, [r0, #0x196]
  00038	e3130002	 tst         r3, #2
  0003c	1a00000d	 bne         |$LN34@Initialize|

; 2696 :     {
; 2697 :         DEBUGMSG(ZONE_WARNING, (L"CHW::InitializeTransaction: Device disconnected - failing transfer\r\n"));
; 2698 :         *pTD->sTransfer.lpfComplete = TRUE;

  00040	e59a3040	 ldr         r3, [r10, #0x40]
  00044	e3a00001	 mov         r0, #1

; 2699 :         *pTD->sTransfer.lpdwError = USB_DEVICE_NOT_RESPONDING_ERROR;
; 2700 :         pED->bfHalted = TRUE;
; 2701 :         pED->TransferStatus = STATUS_COMPLETE;
; 2702 :         SetEvent(g_hUsbProcessingEvent);

  00048	e59f259c	 ldr         r2, [pc, #0x59C]
  0004c	e5830000	 str         r0, [r3]
  00050	e59a3048	 ldr         r3, [r10, #0x48]
  00054	e3a01005	 mov         r1, #5
  00058	e3a04002	 mov         r4, #2
  0005c	e5831000	 str         r1, [r3]
  00060	e58e0024	 str         r0, [lr, #0x24]
  00064	e58e401c	 str         r4, [lr, #0x1C]
  00068	e5920000	 ldr         r0, [r2]
  0006c		 |$LN59@Initialize|
  0006c	e3a01003	 mov         r1, #3
  00070	eb000000	 bl          EventModify

; 2703 :         return;

  00074	ea000159	 b           |$LN26@Initialize|
  00078		 |$LN34@Initialize|

; 2704 :     }
; 2705 : 
; 2706 :     // Cancel if powered down
; 2707 :     if (((SOhcdPdd*)m_pPddContext)->CurrentDx != D0)

  00078	e5903188	 ldr         r3, [r0, #0x188]
  0007c	e5933220	 ldr         r3, [r3, #0x220]
  00080	e3530000	 cmp         r3, #0
  00084	0a00000c	 beq         |$LN33@Initialize|

; 2708 :     {
; 2709 :         DEBUGMSG(ZONE_WARNING, (L"CHW::InitializeTransaction: Device powered down - cancelling transfer\r\n"));
; 2710 :         *pTD->sTransfer.lpfComplete = TRUE;

  00088	e59a3040	 ldr         r3, [r10, #0x40]
  0008c	e3a00001	 mov         r0, #1
  00090	e3a04c01	 mov         r4, #1, 24
  00094	e5830000	 str         r0, [r3]

; 2711 :         *pTD->sTransfer.lpdwError = USB_CANCELED_ERROR;

  00098	e59a2048	 ldr         r2, [r10, #0x48]

; 2712 :         pED->bfHalted = TRUE;
; 2713 :         pED->TransferStatus = STATUS_COMPLETE;
; 2714 :         SetEvent(g_hUsbProcessingEvent);

  0009c	e59f1548	 ldr         r1, [pc, #0x548]
  000a0	e3843001	 orr         r3, r4, #1
  000a4	e5823000	 str         r3, [r2]
  000a8	e3a03002	 mov         r3, #2
  000ac	e58e301c	 str         r3, [lr, #0x1C]
  000b0	e58e0024	 str         r0, [lr, #0x24]
  000b4	e5910000	 ldr         r0, [r1]

; 2715 :         return;

  000b8	eaffffeb	 b           |$LN59@Initialize|
  000bc		 |$LN33@Initialize|

; 2716 :     }
; 2717 : 
; 2718 :     switch(pED->bfDirection){

  000bc	e5de3006	 ldrb        r3, [lr, #6]
  000c0	e3530000	 cmp         r3, #0
  000c4	0a0000e9	 beq         |$LN30@Initialize|
  000c8	e3530001	 cmp         r3, #1
  000cc	0a00006b	 beq         |$LN20@Initialize|
  000d0	e3530002	 cmp         r3, #2
  000d4	1a000141	 bne         |$LN26@Initialize|

; 2872 :             }
; 2873 :         }
; 2874 :         break;
; 2875 : 
; 2876 :     case TD_IN_PID:
; 2877 : 
; 2878 :         WRITE_PORT_USHORT( (portBase+MGC_BUSCTL_OFFSET(pED->bHostEndPointNum, MGC_O_HDRC_RXFUNCADDR)), pTD->sTransfer.address);

  000d8	e5de3010	 ldrb        r3, [lr, #0x10]
  000dc	e5da2004	 ldrb        r2, [r10, #4]
  000e0	e0843183	 add         r3, r4, r3, lsl #3
  000e4	e2833b01	 add         r3, r3, #1, 22
  000e8	e1c328b4	 strh        r2, [r3, #0x84]

; 2879 :         WRITE_PORT_USHORT( (portBase + MGC_END_OFFSET(pED->bHostEndPointNum, MGC_O_HDRC_RXMAXP)), pED->bfMaxPacketSize);

  000ec	e5de3010	 ldrb        r3, [lr, #0x10]
  000f0	e1de20be	 ldrh        r2, [lr, #0xE]
  000f4	e0843203	 add         r3, r4, r3, lsl #4
  000f8	e2833c05	 add         r3, r3, #5, 24
  000fc	e1c320b4	 strh        r2, [r3, #4]

; 2880 : 
; 2881 :         if (pED->epType == TYPE_BULK)

  00100	e59e3020	 ldr         r3, [lr, #0x20]
  00104	e3530002	 cmp         r3, #2
  00108	1a000027	 bne         |$LN7@Initialize|

; 2882 :         {
; 2883 :             WRITE_PORT_UCHAR( (portBase + MGC_END_OFFSET(pED->bHostEndPointNum, MGC_O_HDRC_RXTYPE)),
; 2884 :                 ((pED->bfIsLowSpeed?(0x3<<6):FULL_HIGH_SPEED)|(2<<4)|(pED->bfEndpointNumber&0xf)));

  0010c	e5de3008	 ldrb        r3, [lr, #8]
  00110	e3530000	 cmp         r3, #0
  00114	13a010c0	 movne       r1, #0xC0
  00118	1a000003	 bne         |$LN48@Initialize|
  0011c	e5de3009	 ldrb        r3, [lr, #9]
  00120	e3530000	 cmp         r3, #0
  00124	13a01040	 movne       r1, #0x40
  00128	03a01080	 moveq       r1, #0x80
  0012c		 |$LN48@Initialize|
  0012c	e5de3005	 ldrb        r3, [lr, #5]
  00130	e5de2010	 ldrb        r2, [lr, #0x10]

; 2885 : 
; 2886 :             WRITE_PORT_UCHAR( (m_portBase + MGC_END_OFFSET(pED->bHostEndPointNum, MGC_O_HDRC_RXINTERVAL)),
; 2887 :                 pED->bInterval);

  00134	e203300f	 and         r3, r3, #0xF
  00138	e1833001	 orr         r3, r3, r1
  0013c	e3833020	 orr         r3, r3, #0x20
  00140	e0842202	 add         r2, r4, r2, lsl #4
  00144	e5c2350c	 strb        r3, [r2, #0x50C]
  00148	e5de2010	 ldrb        r2, [lr, #0x10]
  0014c	e5903140	 ldr         r3, [r0, #0x140]
  00150	e5de1011	 ldrb        r1, [lr, #0x11]
  00154	e0833202	 add         r3, r3, r2, lsl #4
  00158	e5c3150d	 strb        r1, [r3, #0x50D]

; 2888 : 
; 2889 :             if(m_fHighSpeed && !pED->bfIsHighSpeed && pED->bfHubAddress)

  0015c	e5903220	 ldr         r3, [r0, #0x220]
  00160	e3530000	 cmp         r3, #0
  00164	0a000009	 beq         |$LN8@Initialize|
  00168	e5de3009	 ldrb        r3, [lr, #9]
  0016c	e3530000	 cmp         r3, #0
  00170	1a000006	 bne         |$LN8@Initialize|
  00174	e5de200a	 ldrb        r2, [lr, #0xA]
  00178	e3520000	 cmp         r2, #0

; 2890 :             {
; 2891 :                 WRITE_PORT_UCHAR( (portBase+MGC_BUSCTL_OFFSET(pED->bHostEndPointNum, MGC_O_HDRC_RXHUBADDR)), pED->bfHubAddress);

  0017c	15de3010	 ldrneb      r3, [lr, #0x10]
  00180	10843183	 addne       r3, r4, r3, lsl #3
  00184	15c32486	 strneb      r2, [r3, #0x486]

; 2892 :                 WRITE_PORT_UCHAR( (portBase+MGC_BUSCTL_OFFSET(pED->bHostEndPointNum, MGC_O_HDRC_RXHUBPORT)), pED->bfHubPort);

  00188	15de200b	 ldrneb      r2, [lr, #0xB]
  0018c	1a000003	 bne         |$LN55@Initialize|
  00190		 |$LN8@Initialize|

; 2893 :             }
; 2894 :             else
; 2895 :             {
; 2896 :                 WRITE_PORT_UCHAR( (portBase+MGC_BUSCTL_OFFSET(pED->bHostEndPointNum, MGC_O_HDRC_RXHUBADDR)), 0);

  00190	e5de3010	 ldrb        r3, [lr, #0x10]
  00194	e3a02000	 mov         r2, #0
  00198	e0843183	 add         r3, r4, r3, lsl #3
  0019c	e5c32486	 strb        r2, [r3, #0x486]
  001a0		 |$LN55@Initialize|

; 2897 :                 WRITE_PORT_UCHAR( (portBase+MGC_BUSCTL_OFFSET(pED->bHostEndPointNum, MGC_O_HDRC_RXHUBPORT)), 0);

  001a0	e5de3010	 ldrb        r3, [lr, #0x10]
  001a4	e0843183	 add         r3, r4, r3, lsl #3
  001a8	e5c32487	 strb        r2, [r3, #0x487]
  001ac		 |$LN7@Initialize|

; 2898 :             }
; 2899 :         }
; 2900 : 
; 2901 : #ifdef MUSB_USEDMA
; 2902 : 
; 2903 :         // Use DMA transfer if applicable
; 2904 :         if (pED->pDmaChannel)

  001ac	e59e3034	 ldr         r3, [lr, #0x34]
  001b0	e1b00003	 movs        r0, r3

; 2905 :         {
; 2906 :             UINT32 nFlags = pTD->sTransfer.dwFlags;
; 2907 : 
; 2908 :             if (pED->bfToggleCarry)

  001b4	e1de32b8	 ldrh        r3, [lr, #0x28]
  001b8	0a000027	 beq         |$LN6@Initialize|

; 2909 :             {
; 2910 :                 nFlags |= USB_TOGGLE_CARRY;
; 2911 :             }
; 2912 : 
; 2913 :             BOOL fResult = pED->pDmaChannel->IssueTransfer(
; 2914 :                 pED->bfEndpointNumber,
; 2915 :                 pTD->sTransfer.address,
; 2916 :                 epType,
; 2917 :                 pED->bfMaxPacketSize,
; 2918 :                 pTD->sTransfer.lpvClientBuffer,
; 2919 :                 pTD->sTransfer.paClientBuffer,
; 2920 :                 pTD->BytesToTransfer,
; 2921 :                 pTD->sTransfer.dwFrames,
; 2922 :                 (UINT32 *)pTD->sTransfer.aLengths,
; 2923 :                 pTD->sTransfer.adwIsochErrors,
; 2924 :                 pTD->sTransfer.adwIsochLengths,
; 2925 :                 nFlags,
; 2926 :                 pED,
; 2927 :                 pTD);

  001bc	e59a403c	 ldr         r4, [r10, #0x3C]
  001c0	e59a2010	 ldr         r2, [r10, #0x10]
  001c4	e3530000	 cmp         r3, #0
  001c8	e58d403c	 str         r4, [sp, #0x3C]
  001cc	e59d402c	 ldr         r4, [sp, #0x2C]
  001d0	e58d2034	 str         r2, [sp, #0x34]
  001d4	13822102	 orrne       r2, r2, #2, 2
  001d8	158d2034	 strne       r2, [sp, #0x34]
  001dc	e5d42004	 ldrb        r2, [r4, #4]
  001e0	e58d4028	 str         r4, [sp, #0x28]
  001e4	e59d4030	 ldr         r4, [sp, #0x30]
  001e8	e5903000	 ldr         r3, [r0]
  001ec	e59a5038	 ldr         r5, [r10, #0x38]
  001f0	e58d4024	 str         r4, [sp, #0x24]
  001f4	e59d4034	 ldr         r4, [sp, #0x34]
  001f8	e5933004	 ldr         r3, [r3, #4]
  001fc	e59a6024	 ldr         r6, [r10, #0x24]
  00200	e59a7020	 ldr         r7, [r10, #0x20]
  00204	e59a8058	 ldr         r8, [r10, #0x58]
  00208	e59a9030	 ldr         r9, [r10, #0x30]
  0020c	e58d4020	 str         r4, [sp, #0x20]
  00210	e59d403c	 ldr         r4, [sp, #0x3C]
  00214	e59aa02c	 ldr         r10, [r10, #0x2C]
  00218	e1deb0be	 ldrh        r11, [lr, #0xE]
  0021c	e58d3040	 str         r3, [sp, #0x40]
  00220	e59d3038	 ldr         r3, [sp, #0x38]
  00224	e5de1005	 ldrb        r1, [lr, #5]
  00228	e58d401c	 str         r4, [sp, #0x1C]
  0022c	e59d4040	 ldr         r4, [sp, #0x40]
  00230	e2033003	 and         r3, r3, #3
  00234	e58d5018	 str         r5, [sp, #0x18]
  00238	e58d6014	 str         r6, [sp, #0x14]
  0023c	e58d7010	 str         r7, [sp, #0x10]
  00240	e58d800c	 str         r8, [sp, #0xC]
  00244	e58d9008	 str         r9, [sp, #8]
  00248	e58da004	 str         r10, [sp, #4]
  0024c	e58db000	 str         r11, [sp]
  00250	e1a0e00f	 mov         lr, pc
  00254	e12fff14	 bx          r4

; 2928 : 
; 2929 :             if (!fResult)
; 2930 :             {
; 2931 :                 DEBUGMSG(1, (L"CHW::InitializeTransaction: Failed to start DMA IN transfer!\r\n"));
; 2932 :                 DEBUGCHK(FALSE);
; 2933 :             }
; 2934 :         }
; 2935 :         else

  00258	ea0000e0	 b           |$LN26@Initialize|
  0025c		 |$LN6@Initialize|

; 2936 : 
; 2937 : #endif // MUSB_USEDMA
; 2938 : 
; 2939 :         {
; 2940 :             /*if (pTD->sTransfer.paClientBuffer != NULL)
; 2941 :             {
; 2942 :                 RETAILMSG(TRUE,(TEXT("EP %u Buff %08x Rx%x\n"), pED->bHostEndPointNum, pTD->sTransfer.paClientBuffer, pTD->BytesToTransfer));
; 2943 :             }*/
; 2944 : 
; 2945 :             /*IN Transaction*/
; 2946 :             if(pED->bfToggleCarry)

  0025c	e3530000	 cmp         r3, #0

; 2947 :                 HOST_CSR = (MGC_M_RXCSR_H_WR_DATATOGGLE|MGC_M_RXCSR_H_DATATOGGLE);
; 2948 :             else
; 2949 :                 HOST_CSR = (MGC_M_RXCSR_CLRDATATOG);
; 2950 :             WRITE_PORT_USHORT( (portBase + MGC_END_OFFSET(pED->bHostEndPointNum, MGC_O_HDRC_RXCSR)),
; 2951 :                                (HOST_CSR|MGC_M_RXCSR_H_REQPKT));

  00260	e5de3010	 ldrb        r3, [lr, #0x10]
  00264	13a02c06	 movne       r2, #6, 24
  00268	03a02080	 moveq       r2, #0x80
  0026c	e0843203	 add         r3, r4, r3, lsl #4
  00270	e2833c05	 add         r3, r3, #5, 24
  00274	e3822020	 orr         r2, r2, #0x20
  00278	e1c320b6	 strh        r2, [r3, #6]

; 2952 :         }
; 2953 : 
; 2954 :         break;

  0027c	ea0000d7	 b           |$LN26@Initialize|
  00280		 |$LN20@Initialize|

; 2784 :         }
; 2785 :         break;
; 2786 : 
; 2787 :     case TD_OUT_PID:
; 2788 : 
; 2789 :         WRITE_PORT_USHORT( (portBase+MGC_BUSCTL_OFFSET(pED->bHostEndPointNum, MGC_O_HDRC_TXFUNCADDR)), pTD->sTransfer.address);

  00280	e5de3010	 ldrb        r3, [lr, #0x10]
  00284	e5da2004	 ldrb        r2, [r10, #4]
  00288	e2833090	 add         r3, r3, #0x90
  0028c	e0843183	 add         r3, r4, r3, lsl #3
  00290	e1c320b0	 strh        r2, [r3]

; 2790 :         WRITE_PORT_USHORT( (portBase + MGC_END_OFFSET(pED->bHostEndPointNum, MGC_O_HDRC_TXMAXP)), pED->bfMaxPacketSize);

  00294	e5de3010	 ldrb        r3, [lr, #0x10]
  00298	e1de20be	 ldrh        r2, [lr, #0xE]
  0029c	e2833050	 add         r3, r3, #0x50
  002a0	e0843203	 add         r3, r4, r3, lsl #4
  002a4	e1c320b0	 strh        r2, [r3]

; 2791 : 
; 2792 :         if (pED->epType == TYPE_BULK)

  002a8	e59e3020	 ldr         r3, [lr, #0x20]
  002ac	e3530002	 cmp         r3, #2
  002b0	1a000027	 bne         |$LN17@Initialize|

; 2793 :         {
; 2794 :             WRITE_PORT_UCHAR( (portBase + MGC_END_OFFSET(pED->bHostEndPointNum, MGC_O_HDRC_TXTYPE)),
; 2795 :                 ((pED->bfIsLowSpeed?(0x3<<6):FULL_HIGH_SPEED)|(2<<4)|(pED->bfEndpointNumber&0xf)));

  002b4	e5de3008	 ldrb        r3, [lr, #8]
  002b8	e3530000	 cmp         r3, #0
  002bc	13a010c0	 movne       r1, #0xC0
  002c0	1a000003	 bne         |$LN44@Initialize|
  002c4	e5de3009	 ldrb        r3, [lr, #9]
  002c8	e3530000	 cmp         r3, #0
  002cc	13a01040	 movne       r1, #0x40
  002d0	03a01080	 moveq       r1, #0x80
  002d4		 |$LN44@Initialize|
  002d4	e5de3005	 ldrb        r3, [lr, #5]
  002d8	e5de2010	 ldrb        r2, [lr, #0x10]

; 2796 : 
; 2797 :             WRITE_PORT_UCHAR( (m_portBase + MGC_END_OFFSET(pED->bHostEndPointNum, MGC_O_HDRC_TXINTERVAL)),
; 2798 :                 pED->bInterval);

  002dc	e203300f	 and         r3, r3, #0xF
  002e0	e1833001	 orr         r3, r3, r1
  002e4	e3833020	 orr         r3, r3, #0x20
  002e8	e0842202	 add         r2, r4, r2, lsl #4
  002ec	e5c2350a	 strb        r3, [r2, #0x50A]
  002f0	e5de2010	 ldrb        r2, [lr, #0x10]
  002f4	e5903140	 ldr         r3, [r0, #0x140]
  002f8	e5de1011	 ldrb        r1, [lr, #0x11]
  002fc	e0833202	 add         r3, r3, r2, lsl #4
  00300	e5c3150b	 strb        r1, [r3, #0x50B]

; 2799 : 
; 2800 :             if(m_fHighSpeed && !pED->bfIsHighSpeed && pED->bfHubAddress)

  00304	e5903220	 ldr         r3, [r0, #0x220]
  00308	e3530000	 cmp         r3, #0
  0030c	0a000009	 beq         |$LN18@Initialize|
  00310	e5de3009	 ldrb        r3, [lr, #9]
  00314	e3530000	 cmp         r3, #0
  00318	1a000006	 bne         |$LN18@Initialize|
  0031c	e5de200a	 ldrb        r2, [lr, #0xA]
  00320	e3520000	 cmp         r2, #0

; 2801 :             {
; 2802 :                 WRITE_PORT_UCHAR( (portBase+MGC_BUSCTL_OFFSET(pED->bHostEndPointNum, MGC_O_HDRC_TXHUBADDR)), pED->bfHubAddress);

  00324	15de3010	 ldrneb      r3, [lr, #0x10]
  00328	10843183	 addne       r3, r4, r3, lsl #3
  0032c	15c32482	 strneb      r2, [r3, #0x482]

; 2803 :                 WRITE_PORT_UCHAR( (portBase+MGC_BUSCTL_OFFSET(pED->bHostEndPointNum, MGC_O_HDRC_TXHUBPORT)), pED->bfHubPort);

  00330	15de200b	 ldrneb      r2, [lr, #0xB]
  00334	1a000003	 bne         |$LN56@Initialize|
  00338		 |$LN18@Initialize|

; 2804 :             }
; 2805 :             else
; 2806 :             {
; 2807 :                 WRITE_PORT_UCHAR( (portBase+MGC_BUSCTL_OFFSET(pED->bHostEndPointNum, MGC_O_HDRC_TXHUBADDR)), 0);

  00338	e5de3010	 ldrb        r3, [lr, #0x10]
  0033c	e3a02000	 mov         r2, #0
  00340	e0843183	 add         r3, r4, r3, lsl #3
  00344	e5c32482	 strb        r2, [r3, #0x482]
  00348		 |$LN56@Initialize|

; 2808 :                 WRITE_PORT_UCHAR( (portBase+MGC_BUSCTL_OFFSET(pED->bHostEndPointNum, MGC_O_HDRC_TXHUBPORT)), 0);

  00348	e5de3010	 ldrb        r3, [lr, #0x10]
  0034c	e0843183	 add         r3, r4, r3, lsl #3
  00350	e5c32483	 strb        r2, [r3, #0x483]
  00354		 |$LN17@Initialize|

; 2809 :             }
; 2810 :         }
; 2811 : 
; 2812 : #ifdef MUSB_USEDMA
; 2813 : 
; 2814 :         if (pED->pDmaChannel)

  00354	e59e3034	 ldr         r3, [lr, #0x34]
  00358	e3530000	 cmp         r3, #0
  0035c	0a00002f	 beq         |$LN16@Initialize|

; 2815 :         {
; 2816 :             UINT32 nFlags = pTD->sTransfer.dwFlags;
; 2817 : 
; 2818 :             // Disable EP interrupt
; 2819 :             WRITE_PORT_ULONG((m_portBase+USB_EP_INTMSKCLRR_REG_OFFSET), 1 << (pED->bHostEndPointNum + USB_OTG_TXINT_SHIFT));

  00360	e5de3010	 ldrb        r3, [lr, #0x10]
  00364	e5902140	 ldr         r2, [r0, #0x140]
  00368	e3a01001	 mov         r1, #1
  0036c	e1a03311	 mov         r3, r1, lsl r3
  00370	e59a1010	 ldr         r1, [r10, #0x10]
  00374	e5823034	 str         r3, [r2, #0x34]

; 2820 : 
; 2821 :             if (pED->bfToggleCarry)

  00378	e1de32b8	 ldrh        r3, [lr, #0x28]

; 2822 :             {
; 2823 :                 nFlags |= USB_TOGGLE_CARRY;
; 2824 :             }
; 2825 : 
; 2826 :             BOOL fResult = pED->pDmaChannel->IssueTransfer(
; 2827 :                 pED->bfEndpointNumber,
; 2828 :                 pTD->sTransfer.address,
; 2829 :                 epType,
; 2830 :                 pED->bfMaxPacketSize,
; 2831 :                 pTD->sTransfer.lpvClientBuffer,
; 2832 :                 pTD->sTransfer.paClientBuffer,
; 2833 :                 pTD->BytesToTransfer,
; 2834 :                 pTD->sTransfer.dwFrames,
; 2835 :                 (UINT32 *)pTD->sTransfer.aLengths,
; 2836 :                 pTD->sTransfer.adwIsochErrors,
; 2837 :                 pTD->sTransfer.adwIsochLengths,
; 2838 :                 nFlags,
; 2839 :                 pED,
; 2840 :                 pTD);

  0037c	e59ab03c	 ldr         r11, [r10, #0x3C]
  00380	e59a4024	 ldr         r4, [r10, #0x24]
  00384	e3530000	 cmp         r3, #0
  00388	e58db040	 str         r11, [sp, #0x40]
  0038c	e59db02c	 ldr         r11, [sp, #0x2C]
  00390	e58d1034	 str         r1, [sp, #0x34]
  00394	13811102	 orrne       r1, r1, #2, 2
  00398	e5db2004	 ldrb        r2, [r11, #4]
  0039c	158d1034	 strne       r1, [sp, #0x34]
  003a0	e58db028	 str         r11, [sp, #0x28]
  003a4	e59db030	 ldr         r11, [sp, #0x30]
  003a8	e59e0034	 ldr         r0, [lr, #0x34]
  003ac	e58d403c	 str         r4, [sp, #0x3C]
  003b0	e59d4034	 ldr         r4, [sp, #0x34]
  003b4	e58db024	 str         r11, [sp, #0x24]
  003b8	e59db040	 ldr         r11, [sp, #0x40]
  003bc	e5903000	 ldr         r3, [r0]
  003c0	e58d4020	 str         r4, [sp, #0x20]
  003c4	e59d402c	 ldr         r4, [sp, #0x2C]
  003c8	e59a5020	 ldr         r5, [r10, #0x20]
  003cc	e59a6058	 ldr         r6, [r10, #0x58]
  003d0	e59a7030	 ldr         r7, [r10, #0x30]
  003d4	e59a802c	 ldr         r8, [r10, #0x2C]
  003d8	e593a004	 ldr         r10, [r3, #4]
  003dc	e58db01c	 str         r11, [sp, #0x1C]
  003e0	e594b038	 ldr         r11, [r4, #0x38]
  003e4	e59d403c	 ldr         r4, [sp, #0x3C]
  003e8	e1de90be	 ldrh        r9, [lr, #0xE]
  003ec	e59d3038	 ldr         r3, [sp, #0x38]
  003f0	e5de1005	 ldrb        r1, [lr, #5]
  003f4	e58d4014	 str         r4, [sp, #0x14]
  003f8	e2033003	 and         r3, r3, #3
  003fc	e58db018	 str         r11, [sp, #0x18]
  00400	e58d5010	 str         r5, [sp, #0x10]
  00404	e58d600c	 str         r6, [sp, #0xC]
  00408	e58d7008	 str         r7, [sp, #8]
  0040c	e58d8004	 str         r8, [sp, #4]
  00410	e58d9000	 str         r9, [sp]
  00414	e1a0e00f	 mov         lr, pc
  00418	e12fff1a	 bx          r10

; 2841 : 
; 2842 :             if (!fResult)
; 2843 :             {
; 2844 :                 DEBUGMSG(1, (L"CHW::InitializeTransaction: Failed to start DMA OUT transfer!\r\n"));
; 2845 :                 DEBUGCHK(FALSE);
; 2846 :             }
; 2847 :         }
; 2848 :         else

  0041c	ea00006f	 b           |$LN26@Initialize|
  00420		 |$LN16@Initialize|

; 2849 : 
; 2850 : #endif // MUSB_USEDMA
; 2851 : 
; 2852 :         {
; 2853 :             /*OUT Transaction*/
; 2854 :             pPkt = (UINT8 *)pTD->sTransfer.lpvClientBuffer;
; 2855 :             pData = (UINT8 *)pTD->sTransfer.lpvClientBuffer;
; 2856 :             pData += pTD->BytesTransferred;
; 2857 : 
; 2858 :             /* Perform a check if the EndPoint is NON-BULK,if so switch back
; 2859 :              * to PIO Mode wherein the CPU in the context of the Calling
; 2860 :              * Thread performs the Transfer into the EndPoint FIFO
; 2861 :              */
; 2862 :             {
; 2863 :                 pTD->TXCOUNT = CopyCount;

  00420	e58a505c	 str         r5, [r10, #0x5C]

; 2864 : 
; 2865 : 				WriteFIFO((DWORD*)(portBase+MGC_FIFO_OFFSET(pED->bHostEndPointNum)), pData, CopyCount);

  00424	e5de3010	 ldrb        r3, [lr, #0x10]
  00428	e59ae054	 ldr         lr, [r10, #0x54]
  0042c	e59a102c	 ldr         r1, [r10, #0x2C]
  00430	e2833f42	 add         r3, r3, #0x42, 30
  00434	e0840103	 add         r0, r4, r3, lsl #2
  00438	e1a02005	 mov         r2, r5
  0043c	e08e1001	 add         r1, lr, r1
  00440	eb000000	 bl          |?WriteFIFO@@YAHPAKPAXK@Z|

; 2866 :                 if(pED->bfToggleCarry)

  00444	e59d2030	 ldr         r2, [sp, #0x30]
  00448	e1d232b8	 ldrh        r3, [r2, #0x28]
  0044c	e3530000	 cmp         r3, #0

; 2867 :                     HOST_CSR = (MGC_M_TXCSR_H_WR_DATATOGGLE|MGC_M_TXCSR_H_DATATOGGLE);
; 2868 :                 else
; 2869 :                     HOST_CSR = (MGC_M_TXCSR_CLRDATATOG);
; 2870 :                 WRITE_PORT_USHORT( (portBase + MGC_END_OFFSET(pED->bHostEndPointNum, MGC_O_HDRC_TXCSR)),
; 2871 :                                    (HOST_CSR|MGC_M_TXCSR_TXPKTRDY));

  00450	e5d23010	 ldrb        r3, [r2, #0x10]
  00454	13a01c03	 movne       r1, #3, 24
  00458	03a01040	 moveq       r1, #0x40
  0045c	e0843203	 add         r3, r4, r3, lsl #4
  00460	e2833c05	 add         r3, r3, #5, 24
  00464	e3812001	 orr         r2, r1, #1
  00468	e1c320b2	 strh        r2, [r3, #2]
  0046c	ea00005b	 b           |$LN26@Initialize|
  00470		 |$LN30@Initialize|

; 2719 :     case TD_SETUP_PID:
; 2720 : 
; 2721 :         WRITE_PORT_USHORT( (portBase+MGC_BUSCTL_OFFSET(pED->bHostEndPointNum, MGC_O_HDRC_TXFUNCADDR)), pTD->sTransfer.address);

  00470	e5de3010	 ldrb        r3, [lr, #0x10]
  00474	e5da2004	 ldrb        r2, [r10, #4]
  00478	e2833090	 add         r3, r3, #0x90
  0047c	e0843183	 add         r3, r4, r3, lsl #3
  00480	e1c320b0	 strh        r2, [r3]

; 2722 :         WRITE_PORT_USHORT( (portBase+MGC_BUSCTL_OFFSET(pED->bHostEndPointNum, MGC_O_HDRC_RXFUNCADDR)), pTD->sTransfer.address);

  00484	e5de3010	 ldrb        r3, [lr, #0x10]
  00488	e5da2004	 ldrb        r2, [r10, #4]
  0048c	e0843183	 add         r3, r4, r3, lsl #3
  00490	e2833b01	 add         r3, r3, #1, 22
  00494	e1c328b4	 strh        r2, [r3, #0x84]

; 2723 :         WRITE_PORT_USHORT( (portBase + MGC_END_OFFSET(pED->bHostEndPointNum, MGC_O_HDRC_TXMAXP)), pED->bfMaxPacketSize);

  00498	e5de3010	 ldrb        r3, [lr, #0x10]
  0049c	e1de20be	 ldrh        r2, [lr, #0xE]
  004a0	e2833050	 add         r3, r3, #0x50
  004a4	e0843203	 add         r3, r4, r3, lsl #4
  004a8	e1c320b0	 strh        r2, [r3]

; 2724 :         WRITE_PORT_USHORT( (portBase + MGC_END_OFFSET(pED->bHostEndPointNum, MGC_O_HDRC_RXMAXP)), pED->bfMaxPacketSize);

  004ac	e5de3010	 ldrb        r3, [lr, #0x10]
  004b0	e1de20be	 ldrh        r2, [lr, #0xE]
  004b4	e0843203	 add         r3, r4, r3, lsl #4
  004b8	e2833c05	 add         r3, r3, #5, 24
  004bc	e1c320b4	 strh        r2, [r3, #4]

; 2725 : 
; 2726 :         WRITE_PORT_UCHAR( (portBase + MGC_END_OFFSET(0, MGC_O_HDRC_TYPE0)),
; 2727 :                 pED->bfIsHighSpeed?(0x1<<6):(pED->bfIsLowSpeed?(0x3<<6):(0x2<<6)));

  004c0	e5de3009	 ldrb        r3, [lr, #9]
  004c4	e3530000	 cmp         r3, #0
  004c8	13a03040	 movne       r3, #0x40
  004cc	1a000003	 bne         |$LN40@Initialize|
  004d0	e5de3008	 ldrb        r3, [lr, #8]
  004d4	e3530000	 cmp         r3, #0
  004d8	13a030c0	 movne       r3, #0xC0
  004dc	03a03080	 moveq       r3, #0x80
  004e0		 |$LN40@Initialize|
  004e0	e5c4350a	 strb        r3, [r4, #0x50A]

; 2728 : 
; 2729 :         /*Host controller in High Speed
; 2730 :          *Device is not High speed
; 2731 :          *Device connected after hub
; 2732 :          */
; 2733 :         if(m_fHighSpeed && !pED->bfIsHighSpeed && pED->bfHubAddress){

  004e4	e5903220	 ldr         r3, [r0, #0x220]
  004e8	e3530000	 cmp         r3, #0
  004ec	0a00000c	 beq         |$LN29@Initialize|
  004f0	e5de3009	 ldrb        r3, [lr, #9]
  004f4	e3530000	 cmp         r3, #0
  004f8	1a000009	 bne         |$LN29@Initialize|
  004fc	e5de300a	 ldrb        r3, [lr, #0xA]
  00500	e3530000	 cmp         r3, #0

; 2734 :             WRITE_PORT_UCHAR( (portBase+MGC_BUSCTL_OFFSET(0, MGC_O_HDRC_TXHUBADDR)), pED->bfHubAddress);

  00504	15c43482	 strneb      r3, [r4, #0x482]

; 2735 :             WRITE_PORT_UCHAR( (portBase+MGC_BUSCTL_OFFSET(0, MGC_O_HDRC_RXHUBADDR)), pED->bfHubAddress);

  00508	15de300a	 ldrneb      r3, [lr, #0xA]
  0050c	15c43486	 strneb      r3, [r4, #0x486]

; 2736 :             WRITE_PORT_UCHAR( (portBase+MGC_BUSCTL_OFFSET(0, MGC_O_HDRC_TXHUBPORT)), pED->bfHubPort);

  00510	15de300b	 ldrneb      r3, [lr, #0xB]
  00514	15c43483	 strneb      r3, [r4, #0x483]

; 2737 :             WRITE_PORT_UCHAR( (portBase+MGC_BUSCTL_OFFSET(0, MGC_O_HDRC_RXHUBPORT)), pED->bfHubPort);

  00518	15de300b	 ldrneb      r3, [lr, #0xB]
  0051c	15c43487	 strneb      r3, [r4, #0x487]
  00520	1a000004	 bne         |$LN28@Initialize|
  00524		 |$LN29@Initialize|

; 2738 :         }
; 2739 :         else{
; 2740 :                     WRITE_PORT_UCHAR( (portBase+MGC_BUSCTL_OFFSET(0, MGC_O_HDRC_TXHUBADDR)), 0);
; 2741 :                     WRITE_PORT_UCHAR( (portBase+MGC_BUSCTL_OFFSET(0, MGC_O_HDRC_RXHUBADDR)), 0);
; 2742 :                     WRITE_PORT_UCHAR( (portBase+MGC_BUSCTL_OFFSET(0, MGC_O_HDRC_TXHUBPORT)), 0);

  00524	e3a02000	 mov         r2, #0
  00528	e5c42482	 strb        r2, [r4, #0x482]

; 2743 :                     WRITE_PORT_UCHAR( (portBase+MGC_BUSCTL_OFFSET(0, MGC_O_HDRC_RXHUBPORT)), 0);

  0052c	e5c42486	 strb        r2, [r4, #0x486]
  00530	e5c42483	 strb        r2, [r4, #0x483]
  00534	e5c42487	 strb        r2, [r4, #0x487]
  00538		 |$LN28@Initialize|

; 2744 :                 }
; 2745 :         switch(pTD->TransferStage){

  00538	e59a3050	 ldr         r3, [r10, #0x50]
  0053c	e3530000	 cmp         r3, #0
  00540	0a00001e	 beq         |$LN25@Initialize|
  00544	e3530001	 cmp         r3, #1
  00548	0a000018	 beq         |$LN24@Initialize|
  0054c	e3530002	 cmp         r3, #2
  00550	0a000008	 beq         |$LN23@Initialize|
  00554	e3530003	 cmp         r3, #3
  00558	0a000004	 beq         |$LN22@Initialize|
  0055c	e3530004	 cmp         r3, #4
  00560	1a00001e	 bne         |$LN26@Initialize|

; 2776 :         case STAGE_STATUSOUT:
; 2777 :             /*data stage was from device to host - IN transaction*/
; 2778 :             /*Status Stage - OUT packet*/
; 2779 :             // NOTE: PING is disabled because some MSD do not support it for EP0 IN transfers
; 2780 :             WRITE_PORT_USHORT( (portBase + MGC_END_OFFSET(0, MGC_O_HDRC_CSR0)),
; 2781 :                            (MGC_M_CSR0_TXPKTRDY|MGC_M_CSR0_H_STATUSPKT |
; 2782 :                             MGC_M_CSR0_H_WR_DATATOGGLE|MGC_M_CSR0_H_DATATOGGLE|MGC_M_CSR0_H_DISPING));

  00564	e3a03c0e	 mov         r3, #0xE, 24
  00568	e3833042	 orr         r3, r3, #0x42

; 2783 :             break;

  0056c	ea000019	 b           |$LN57@Initialize|
  00570		 |$LN22@Initialize|

; 2769 :         case STAGE_STATUSIN:
; 2770 :             /*data stage was from host to device - OUT transaction*/
; 2771 :             /*Status Stage - IN packet*/
; 2772 :             WRITE_PORT_USHORT( (portBase + MGC_END_OFFSET(0, MGC_O_HDRC_CSR0)),
; 2773 :                        (MGC_M_CSR0_H_REQPKT|MGC_M_CSR0_H_STATUSPKT |
; 2774 :                         MGC_M_CSR0_H_WR_DATATOGGLE|MGC_M_CSR0_H_DATATOGGLE));

  00570	e3a02e66	 mov         r2, #0x66, 28

; 2775 :             break;

  00574	ea00000e	 b           |$LN60@Initialize|
  00578		 |$LN23@Initialize|

; 2759 :         case STAGE_DATAOUT:
; 2760 :             pPkt = (UINT8 *)pTD->sTransfer.lpvClientBuffer;
; 2761 : 
; 2762 : 			WriteFIFO((DWORD*)(portBase+MGC_FIFO_OFFSET(0)), pPkt, CopyCount);

  00578	e59a102c	 ldr         r1, [r10, #0x2C]
  0057c	e1a02005	 mov         r2, r5
  00580	e2840e42	 add         r0, r4, #0x42, 28
  00584	eb000000	 bl          |?WriteFIFO@@YAHPAKPAXK@Z|

; 2763 : 	        pTD->BytesTransferred += CopyCount;

  00588	e59a3054	 ldr         r3, [r10, #0x54]

; 2764 : 			pTD->BytesToTransfer -= CopyCount;

  0058c	e59a2058	 ldr         r2, [r10, #0x58]

; 2765 : 
; 2766 : 			/*Data Stage - OUT packet*/
; 2767 :             WRITE_PORT_USHORT( (portBase + MGC_END_OFFSET(0, MGC_O_HDRC_CSR0)),(MGC_M_CSR0_TXPKTRDY));

  00590	e2841c05	 add         r1, r4, #5, 24
  00594	e0833005	 add         r3, r3, r5
  00598	e58a3054	 str         r3, [r10, #0x54]
  0059c	e0422005	 sub         r2, r2, r5
  005a0	e3a03002	 mov         r3, #2
  005a4	e58a2058	 str         r2, [r10, #0x58]
  005a8	e1c130b2	 strh        r3, [r1, #2]

; 2768 :             break;

  005ac	ea00000b	 b           |$LN26@Initialize|
  005b0		 |$LN24@Initialize|

; 2754 :             break;
; 2755 :         case STAGE_DATAIN:
; 2756 :             // NOTE: PING is disabled because some MSD do not support it for EP0 IN transfers
; 2757 :             WRITE_PORT_USHORT( (portBase + MGC_END_OFFSET(0, MGC_O_HDRC_CSR0)),(MGC_M_CSR0_H_REQPKT|MGC_M_CSR0_H_DISPING));

  005b0	e3a02e82	 mov         r2, #0x82, 28
  005b4		 |$LN60@Initialize|
  005b4	e2843c05	 add         r3, r4, #5, 24
  005b8	e1c320b2	 strh        r2, [r3, #2]

; 2758 :             break;

  005bc	ea000007	 b           |$LN26@Initialize|
  005c0		 |$LN25@Initialize|

; 2746 :         case STAGE_SETUP:
; 2747 :             pPkt = (UINT8 *)pTD->sTransfer.lpvControlHeader;
; 2748 : 	
; 2749 : 			WriteFIFO((DWORD*)(portBase+MGC_FIFO_OFFSET(0)), pPkt, 8);

  005c0	e59a1014	 ldr         r1, [r10, #0x14]
  005c4	e3a02008	 mov         r2, #8
  005c8	e2840e42	 add         r0, r4, #0x42, 28
  005cc	eb000000	 bl          |?WriteFIFO@@YAHPAKPAXK@Z|

; 2750 : 
; 2751 : 			/*Setup Stage - SETUP packet*/
; 2752 :             WRITE_PORT_USHORT( (portBase + MGC_END_OFFSET(0, MGC_O_HDRC_CSR0)),
; 2753 :                            (MGC_M_CSR0_TXPKTRDY|MGC_M_CSR0_H_SETUPPKT|MGC_M_CSR0_H_WR_DATATOGGLE));

  005d0	e3a03b01	 mov         r3, #1, 22
  005d4	e383300a	 orr         r3, r3, #0xA
  005d8		 |$LN57@Initialize|
  005d8	e2842c05	 add         r2, r4, #5, 24
  005dc	e1c230b2	 strh        r3, [r2, #2]
  005e0		 |$LN26@Initialize|

; 2955 :     }
; 2956 : }

  005e0	e28dd044	 add         sp, sp, #0x44
  005e4	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  005e8	e12fff1e	 bx          lr
  005ec		 |$LN64@Initialize|
  005ec		 |$LN65@Initialize|
  005ec	00000000	 DCD         |?g_hUsbProcessingEvent@@3PAXA|
  005f0		 |$M43376|

			 ENDP  ; |?InitializeTransaction@CHW@@QAAXIPAX0@Z|, CHW::InitializeTransaction

	EXPORT	|?DmaTransferComplete@CHW@@SAXPAVCCppiDmaChannel@@IIIIPAX1@Z| ; CHW::DmaTransferComplete
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T43405| DCD	|$LN14@DmaTransfe|
	DCD	0x40002801
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\am3517\usb\usbh\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DmaTransferComplete@CHW@@SAXPAVCCppiDmaChannel@@IIIIPAX1@Z| PROC ; CHW::DmaTransferComplete

; 2974 : {

  00000		 |$LN14@DmaTransfe|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M43402|
  00004	e1a05003	 mov         r5, r3
  00008	e1a06001	 mov         r6, r1

; 2975 :     UNREFERENCED_PARAMETER(pChannel);
; 2976 :     UNREFERENCED_PARAMETER(nLength);
; 2977 :     UNREFERENCED_PARAMETER(nComplete);
; 2978 : 
; 2979 :     USBED *pED = (USBED *)pPrivate;
; 2980 :     USBTD *pTD = (USBTD *)pCookie;
; 2981 : 
; 2982 :     DEBUGCHK(m_pChw);
; 2983 :     DEBUGCHK(pED && pTD);
; 2984 :     DEBUGCHK(pED->pDmaChannel == pChannel);
; 2985 : 
; 2986 :     m_pChw->LockProcessingThread();

  0000c	e59f7088	 ldr         r7, [pc, #0x88]
  00010	e5972004	 ldr         r2, [r7, #4]
  00014	e2820f89	 add         r0, r2, #0x89, 30
  00018	eb000000	 bl          EnterCriticalSection

; 2987 : 
; 2988 :     pTD->BytesTransferred += nComplete;

  0001c	e59d4020	 ldr         r4, [sp, #0x20]

; 2989 :     pTD->BytesToTransfer -= nComplete;
; 2990 : 
; 2991 :     *pTD->sTransfer.lpdwBytesTransferred = nComplete;
; 2992 :     *pTD->sTransfer.lpfComplete = TRUE;

  00020	e3a08001	 mov         r8, #1

; 2993 :     *pTD->sTransfer.lpdwError = nStatus;
; 2994 : 
; 2995 :     if (nStatus != USB_NO_ERROR)

  00024	e59d101c	 ldr         r1, [sp, #0x1C]
  00028	e5942054	 ldr         r2, [r4, #0x54]
  0002c	e5940058	 ldr         r0, [r4, #0x58]
  00030	e594e044	 ldr         lr, [r4, #0x44]
  00034	e0822005	 add         r2, r2, r5
  00038	e0400005	 sub         r0, r0, r5
  0003c	e5842054	 str         r2, [r4, #0x54]
  00040	e5840058	 str         r0, [r4, #0x58]
  00044	e58e5000	 str         r5, [lr]
  00048	e5943040	 ldr         r3, [r4, #0x40]
  0004c	e3560000	 cmp         r6, #0

; 2996 :     {
; 2997 :         pED->bfHalted = TRUE;
; 2998 :     }
; 2999 : 
; 3000 :     pED->bfToggleCarry = (nOptions & USB_TOGGLE_CARRY) ? 1 : 0;
; 3001 :     pED->TransferStatus = STATUS_COMPLETE;

  00050	e3a02002	 mov         r2, #2
  00054	e5838000	 str         r8, [r3]
  00058	e5943048	 ldr         r3, [r4, #0x48]
  0005c	e5836000	 str         r6, [r3]
  00060	e59d3018	 ldr         r3, [sp, #0x18]
  00064	15818024	 strne       r8, [r1, #0x24]
  00068	e581201c	 str         r2, [r1, #0x1C]
  0006c	e3130102	 tst         r3, #2, 2
  00070	13a03001	 movne       r3, #1
  00074	03a03000	 moveq       r3, #0
  00078	e1c132b8	 strh        r3, [r1, #0x28]

; 3002 : 
; 3003 :     m_pChw->UnlockProcessingThread();

  0007c	e5973004	 ldr         r3, [r7, #4]
  00080	e2830f89	 add         r0, r3, #0x89, 30
  00084	eb000000	 bl          LeaveCriticalSection

; 3004 : 
; 3005 :     SetEvent(g_hUsbProcessingEvent);

  00088	e5970000	 ldr         r0, [r7]
  0008c	e3a01003	 mov         r1, #3
  00090	eb000000	 bl          EventModify

; 3006 : }

  00094	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00098	e12fff1e	 bx          lr
  0009c		 |$LN15@DmaTransfe|
  0009c		 |$LN16@DmaTransfe|
  0009c	00000000	 DCD         |?g_hUsbProcessingEvent@@3PAXA|
  000a0		 |$M43403|

			 ENDP  ; |?DmaTransferComplete@CHW@@SAXPAVCCppiDmaChannel@@IIIIPAX1@Z|, CHW::DmaTransferComplete

	EXPORT	|?CeResumeThread@CHW@@AAAKXZ|		; CHW::CeResumeThread

  00000			 AREA	 |.pdata|, PDATA
|$T43422| DCD	|$LN14@CeResumeTh|
	DCD	0x40002a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CeResumeThread@CHW@@AAAKXZ| PROC	; CHW::CeResumeThread

; 3032 : {

  00000		 |$LN14@CeResumeTh|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43419|
  00004	e1a04000	 mov         r4, r0

; 3033 :     DEBUGMSG(ZONE_ERROR, (TEXT("+CHW::CeResumeThread\n\r")));
; 3034 :     // reconstruct the objects at the same addresses where they were before;
; 3035 :     // this allows us not to have to alert the PDD that the addresses have changed.
; 3036 : 
; 3037 :     DEBUGCHK( m_fPowerResuming == FALSE );
; 3038 : 
; 3039 :     // order is important! resuming indicates that the hcd object is temporarily invalid
; 3040 :     // while powerup simply signals that a powerup event has occurred. once the powerup
; 3041 :     // flag is cleared, we will repeat this whole sequence should it get resignalled.
; 3042 :     m_fPowerUpFlag = FALSE;
; 3043 :     m_fPowerResuming = TRUE;
; 3044 : 
; 3045 :     DeviceDeInitialize();

  00008	e5943000	 ldr         r3, [r4]
  0000c	e3a02001	 mov         r2, #1
  00010	e3a05000	 mov         r5, #0
  00014	e5933010	 ldr         r3, [r3, #0x10]
  00018	e584518c	 str         r5, [r4, #0x18C]
  0001c	e5842190	 str         r2, [r4, #0x190]
  00020	e1a0e00f	 mov         lr, pc
  00024	e12fff13	 bx          r3

; 3046 :     for(;;) {  // breaks out upon successful reinit of the object
; 3047 : 
; 3048 :         if (DeviceInitialize())

  00028	e5943000	 ldr         r3, [r4]
  0002c	e1a00004	 mov         r0, r4
  00030	e593300c	 ldr         r3, [r3, #0xC]
  00034	e1a0e00f	 mov         lr, pc
  00038	e12fff13	 bx          r3
  0003c	ea00000b	 b           |$LN11@CeResumeTh|
  00040		 |$LL4@CeResumeTh|

; 3049 :             break;
; 3050 :         // getting here means we couldn't reinit the HCD object!
; 3051 :         ASSERT(FALSE);
; 3052 :         DEBUGMSG(ZONE_ERROR, (TEXT("USB cannot reinit the HCD at CE resume; retrying...\n\r")));
; 3053 :         DeviceDeInitialize();

  00040	e5943000	 ldr         r3, [r4]
  00044	e1a00004	 mov         r0, r4
  00048	e5933010	 ldr         r3, [r3, #0x10]
  0004c	e1a0e00f	 mov         lr, pc
  00050	e12fff13	 bx          r3

; 3054 :         Sleep(1000);

  00054	e3a00ffa	 mov         r0, #0xFA, 30
  00058	eb000000	 bl          Sleep
  0005c	e5943000	 ldr         r3, [r4]
  00060	e1a00004	 mov         r0, r4
  00064	e593300c	 ldr         r3, [r3, #0xC]
  00068	e1a0e00f	 mov         lr, pc
  0006c	e12fff13	 bx          r3
  00070		 |$LN11@CeResumeTh|
  00070	e3500000	 cmp         r0, #0
  00074	0afffff1	 beq         |$LL4@CeResumeTh|

; 3055 :     }
; 3056 : 
; 3057 :     // the hcd object is valid again. if a power event occurred between the two flag
; 3058 :     // assignments above then the IST will reinitiate this sequence.
; 3059 :     m_fPowerResuming = FALSE;
; 3060 :     if (m_fPowerUpFlag)

  00078	e594318c	 ldr         r3, [r4, #0x18C]
  0007c	e5845190	 str         r5, [r4, #0x190]
  00080	e3530000	 cmp         r3, #0

; 3061 :         PowerMgmtCallback(TRUE);

  00084	15943000	 ldrne       r3, [r4]
  00088	13a01001	 movne       r1, #1
  0008c	11a00004	 movne       r0, r4
  00090	15933024	 ldrne       r3, [r3, #0x24]
  00094	11a0e00f	 movne       lr, pc
  00098	112fff13	 bxne        r3

; 3062 : 
; 3063 :     DEBUGMSG(ZONE_ERROR, (TEXT("-CHW::CeResumeThread\n\r")));
; 3064 :     return 0;

  0009c	e3a00000	 mov         r0, #0

; 3065 : }

  000a0	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000a4	e12fff1e	 bx          lr
  000a8		 |$M43420|

			 ENDP  ; |?CeResumeThread@CHW@@AAAKXZ|, CHW::CeResumeThread

	EXPORT	|??0CHW@@QAA@SAE0KKQAVCPhysMem@@PAX@Z|	; CHW::CHW
	EXPORT	|??_7CHW@@6B@| [ DATA ]			; CHW::`vftable'
	EXPORT	|?StopAdjustingFrame@CHW@@UAAHXZ|	; CHW::StopAdjustingFrame
	EXPORT	|?DidPortStatusChange@CHW@@UAAHE@Z|	; CHW::DidPortStatusChange
	EXPORT	|?SetCapability@?ICHcd@CHW@@UAAKK@Z|	; CHW[::CHcd]::SetCapability
	EXPORT	|?GetCapability@?ICHcd@CHW@@UAAKXZ|	; CHW[::CHcd]::GetCapability
	EXPORT	|?SuspendHC@CHcd@@UAAHXZ|		; CHcd::SuspendHC
	EXPORT	|?ResumeNotification@CHcd@@MAAHXZ|	; CHcd::ResumeNotification
	EXPORT	|?Initialize@CHW@@UAAHXZ|		; CHW::Initialize
	EXPORT	|?SignalCheckForDoneTransfers@CHW@@UAAXK@Z| ; CHW::SignalCheckForDoneTransfers
	IMPORT	|CreateSemaphoreW|
	IMPORT	|?CreateDescriptors@@YAXXZ|		; CreateDescriptors
	IMPORT	|InitializeCriticalSection|
	IMPORT	|??0CCppiDmaController@@QAA@K@Z|	; CCppiDmaController::CCppiDmaController
	IMPORT	|??0CHcd@@QAA@XZ|			; CHcd::CHcd
	IMPORT	|memset|
	IMPORT	|_purecall|
	IMPORT	|??_ECHW@@UAAPAXI@Z|, WEAK |??_GCHW@@UAAPAXI@Z| ; CHW::`vector deleting destructor', CHW::`scalar deleting destructor'
	IMPORT	|?DisableDevice@CHcd@@UAAHIH@Z|		; CHcd::DisableDevice
	IMPORT	|?SuspendResume@CHcd@@UAAHIH@Z|		; CHcd::SuspendResume

  00000			 AREA	 |.pdata|, PDATA
|$T43438| DCD	|$LN11@CHW|
	DCD	0x40006a03

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7CHW@@6B@| DCD |_purecall|				; CHW::`vftable'
	DCD	|_purecall|
	DCD	|??_ECHW@@UAAPAXI@Z|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|?GetFrameNumber@CHW@@UAAHPAK@Z|
	DCD	|?GetFrameLength@CHW@@UAAHPAG@Z|
	DCD	|?SetFrameLength@CHW@@UAAHPAXG@Z|
	DCD	|?StopAdjustingFrame@CHW@@UAAHXZ|
	DCD	|?PowerMgmtCallback@CHW@@UAAXH@Z|
	DCD	|?DisableDevice@CHcd@@UAAHIH@Z|
	DCD	|?SuspendResume@CHcd@@UAAHIH@Z|
	DCD	|?DidPortStatusChange@CHW@@UAAHE@Z|
	DCD	|?GetPortStatus@CHW@@UAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z|
	DCD	|?RootHubFeature@CHW@@UAAHEEG@Z|
	DCD	|?ResetAndEnablePort@CHW@@UAAHE@Z|
	DCD	|?DisablePort@CHW@@UAAXE@Z|
	DCD	|?WaitForPortStatusChange@CHW@@UAAHPAX@Z|
	DCD	|?SetCapability@?ICHcd@CHW@@UAAKK@Z|
	DCD	|?GetCapability@?ICHcd@CHW@@UAAKXZ|
	DCD	|?SuspendHC@CHcd@@UAAHXZ|
	DCD	|?ResumeNotification@CHcd@@MAAHXZ|
	DCD	|?Initialize@CHW@@UAAHXZ|
	DCD	|?DeInitialize@CHW@@UAAXXZ|
	DCD	|?SignalCheckForDoneTransfers@CHW@@UAAXK@Z|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CHW@@QAA@SAE0KKQAVCPhysMem@@PAX@Z| PROC ; CHW::CHW

; 234  : {

  00000		 |$LN11@CHW|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d57f0	 stmdb       sp!, {r4 - r10, r12, lr}
  0000c		 |$M43435|
  0000c	e1a07003	 mov         r7, r3
  00010	e1a0a000	 mov         r10, r0
  00014	eb000000	 bl          |??0CHcd@@QAA@XZ|
  00018	e59d2028	 ldr         r2, [sp, #0x28]
  0001c	e1a0900a	 mov         r9, r10
  00020	e59d6034	 ldr         r6, [sp, #0x34]
  00024	e59fe178	 ldr         lr, [pc, #0x178]
  00028	e59d4038	 ldr         r4, [sp, #0x38]
  0002c	e59d503c	 ldr         r5, [sp, #0x3C]
  00030	e5a92140	 str         r2, [r9, #0x140]!
  00034	e59d202c	 ldr         r2, [sp, #0x2C]
  00038	e28a8f51	 add         r8, r10, #0x51, 30
  0003c	e1a01006	 mov         r1, r6
  00040	e28a0fca	 add         r0, r10, #0xCA, 30
  00044	e5882000	 str         r2, [r8]
  00048	e58ae000	 str         lr, [r10]
  0004c	e58a6150	 str         r6, [r10, #0x150]
  00050	e58a716c	 str         r7, [r10, #0x16C]
  00054	e58a4184	 str         r4, [r10, #0x184]
  00058	e58a5188	 str         r5, [r10, #0x188]
  0005c	eb000000	 bl          |??0CCppiDmaController@@QAA@K@Z|

; 235  :     // definitions for static variables
; 236  :     m_pHCCA = 0;
; 237  :     m_wFrameHigh = 0;
; 238  :     m_hUsbInterruptEvent = NULL;
; 239  :     m_hUsbHubChangeEvent = NULL;
; 240  :     m_hUsbInterruptThread = NULL;
; 241  :     m_fUsbInterruptThreadClosing = FALSE;
; 242  :     m_pControlHead = 0;
; 243  :     m_pBulkInHead = 0;
; 244  :     m_pBulkOutHead = 0;
; 245  :     m_pIntInHead = 0;
; 246  :     m_pIntOutHead = 0;
; 247  :     m_fConstructionStatus = TRUE;

  00060	e3a03001	 mov         r3, #1
  00064	e3a07000	 mov         r7, #0

; 248  : 
; 249  : #ifdef MUSB_USEDMA
; 250  : #ifdef MUSB_USEDMA_FOR_ISO
; 251  : 
; 252  :     m_pIsoInHead = NULL;
; 253  :     m_pIsoOutHead = NULL;
; 254  : 
; 255  : #endif // MUSB_USEDMA_FOR_ISO
; 256  : #endif // MUSB_USEDMA
; 257  : 
; 258  :     m_dwCap = 0;
; 259  :     m_portStatus = 0;
; 260  :     m_wFifoOffset = 0;
; 261  :     lastFn = 0;
; 262  :     m_fHighSpeed = FALSE;
; 263  :     m_fPowerUpFlag = FALSE;
; 264  :     m_fPowerResuming = FALSE;
; 265  : 
; 266  :     m_pProcessEDControl = NULL;
; 267  :     memset(m_pProcessEDIn, 0, sizeof(m_pProcessEDIn));

  00068	e3a0203c	 mov         r2, #0x3C
  0006c	e3a01000	 mov         r1, #0
  00070	e28a00c4	 add         r0, r10, #0xC4
  00074	e58a314c	 str         r3, [r10, #0x14C]
  00078	e58a7148	 str         r7, [r10, #0x148]
  0007c	e1c872b4	 strh        r7, [r8, #0x24]
  00080	e58a7170	 str         r7, [r10, #0x170]
  00084	e58a717c	 str         r7, [r10, #0x17C]
  00088	e58a7174	 str         r7, [r10, #0x174]
  0008c	e58a7180	 str         r7, [r10, #0x180]
  00090	e58a70a4	 str         r7, [r10, #0xA4]
  00094	e58a70a8	 str         r7, [r10, #0xA8]
  00098	e58a70ac	 str         r7, [r10, #0xAC]
  0009c	e58a70b0	 str         r7, [r10, #0xB0]
  000a0	e58a70b4	 str         r7, [r10, #0xB4]
  000a4	e58a70b8	 str         r7, [r10, #0xB8]
  000a8	e58a70bc	 str         r7, [r10, #0xBC]
  000ac	e58a7198	 str         r7, [r10, #0x198]
  000b0	e5ca7196	 strb        r7, [r10, #0x196]
  000b4	e1c875b0	 strh        r7, [r8, #0x50]
  000b8	e14870b8	 strh        r7, [r8, #-8]
  000bc	e58a7220	 str         r7, [r10, #0x220]
  000c0	e58a718c	 str         r7, [r10, #0x18C]
  000c4	e58a7190	 str         r7, [r10, #0x190]
  000c8	e58a70c0	 str         r7, [r10, #0xC0]
  000cc	eb000000	 bl          memset

; 268  :     memset(m_pProcessEDOut, 0, sizeof(m_pProcessEDOut));

  000d0	e3a0203c	 mov         r2, #0x3C
  000d4	e3a01000	 mov         r1, #0
  000d8	e28a0c01	 add         r0, r10, #1, 24
  000dc	eb000000	 bl          memset

; 269  : 
; 270  :     //CLEAR_INTERRUPTS();
; 271  :     InitializeCriticalSection( &m_csFrameCounter );

  000e0	e28a0f55	 add         r0, r10, #0x55, 30
  000e4	eb000000	 bl          InitializeCriticalSection

; 272  :     InitializeCriticalSection( &m_csUsbProcLock );

  000e8	e28a0f89	 add         r0, r10, #0x89, 30
  000ec	eb000000	 bl          InitializeCriticalSection

; 273  : 
; 274  :     //WRITE_PORT_UCHAR((m_portBase + USB_DEVCTL_REG_OFFSET), 0);
; 275  :     WRITE_PORT_UCHAR((m_portBase + USB_EOIR_REG_OFFSET), 0);

  000f0	e5993000	 ldr         r3, [r9]
  000f4	e5c37060	 strb        r7, [r3, #0x60]

; 276  : 
; 277  :     CreateDescriptors();

  000f8	eb000000	 bl          |?CreateDescriptors@@YAXXZ|

; 278  : 
; 279  :     /* Creation of the EP Sempahore objects. */
; 280  :     m_Ep0ProtectSem = CreateSemaphore(NULL, 1, 1, NULL);

  000fc	e3a03000	 mov         r3, #0
  00100	e3a02001	 mov         r2, #1
  00104	e3a01001	 mov         r1, #1
  00108	e3a00000	 mov         r0, #0
  0010c	eb000000	 bl          CreateSemaphoreW
  00110	e58a01a4	 str         r0, [r10, #0x1A4]

; 281  :     for (UINT8 i = 0; i < (MGC_MAX_USB_ENDS - 1); i ++)

  00114	e3a05000	 mov         r5, #0
  00118	e3a06000	 mov         r6, #0
  0011c		 |$LL4@CHW|

; 282  :     {
; 283  :         m_EpInProtectSem[i] = CreateSemaphore(NULL, 1, 1, NULL);

  0011c	e3a03000	 mov         r3, #0
  00120	e3a02001	 mov         r2, #1
  00124	e3a01001	 mov         r1, #1
  00128	e3a00000	 mov         r0, #0
  0012c	eb000000	 bl          CreateSemaphoreW
  00130	e1a03000	 mov         r3, r0
  00134	e08a4105	 add         r4, r10, r5, lsl #2

; 284  :         m_EpOutProtectSem[i] = CreateSemaphore(NULL, 1, 1, NULL);

  00138	e58431a8	 str         r3, [r4, #0x1A8]
  0013c	e3a03000	 mov         r3, #0
  00140	e3a00000	 mov         r0, #0
  00144	e3a02001	 mov         r2, #1
  00148	e3a01001	 mov         r1, #1
  0014c	eb000000	 bl          CreateSemaphoreW
  00150	e2863001	 add         r3, r6, #1
  00154	e20350ff	 and         r5, r3, #0xFF
  00158	e1a06005	 mov         r6, r5
  0015c	e355000f	 cmp         r5, #0xF
  00160	e58401e4	 str         r0, [r4, #0x1E4]
  00164	3affffec	 bcc         |$LL4@CHW|

; 285  :     }
; 286  : 
; 287  :     // Start with a clean configuration
; 288  :     memset(m_EpInConfig, 0, sizeof(m_EpInConfig));

  00168	e3a02078	 mov         r2, #0x78
  0016c	e3a01000	 mov         r1, #0
  00170	e28a0f8e	 add         r0, r10, #0x8E, 30
  00174	eb000000	 bl          memset

; 289  :     memset(m_EpOutConfig, 0, sizeof(m_EpOutConfig));

  00178	e3a02078	 mov         r2, #0x78
  0017c	e3a01000	 mov         r1, #0
  00180	e28a0e2b	 add         r0, r10, #0x2B, 28
  00184	eb000000	 bl          memset

; 290  : 
; 291  :     if (!LoadEnpointConfiguration())

  00188	e1a0000a	 mov         r0, r10
  0018c	eb000000	 bl          |?LoadEnpointConfiguration@CHW@@AAAHXZ|
  00190	e3500000	 cmp         r0, #0

; 292  :     {
; 293  :         DEBUGMSG( ZONE_ERROR, (TEXT("-CHW::CHW - failed to read EP configuration\n")));
; 294  :         m_fConstructionStatus = FALSE;

  00194	058a714c	 streq       r7, [r10, #0x14C]

; 295  :     }
; 296  : }

  00198	e1a0000a	 mov         r0, r10
  0019c	e89d67f0	 ldmia       sp, {r4 - r10, sp, lr}
  001a0	e12fff1e	 bx          lr
  001a4		 |$LN12@CHW|
  001a4		 |$LN13@CHW|
  001a4	00000000	 DCD         |??_7CHW@@6B@|
  001a8		 |$M43436|

			 ENDP  ; |??0CHW@@QAA@SAE0KKQAVCPhysMem@@PAX@Z|, CHW::CHW

	EXPORT	|?Lock@LockObject@@QAAXXZ|		; LockObject::Lock
; File c:\wince600\public\common\oak\drivers\usb\hcd\usb20\usb2com\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T43448| DCD	|$LN5@Lock|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Lock@LockObject@@QAAXXZ| PROC	; LockObject::Lock

; 74   :     void Lock(void) { EnterCriticalSection(&m_CSection); };

  00000		 |$LN5@Lock|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43445|
  00004	eb000000	 bl          EnterCriticalSection
  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M43446|

			 ENDP  ; |?Lock@LockObject@@QAAXXZ|, LockObject::Lock

	EXPORT	|?Unlock@LockObject@@QAAXXZ|		; LockObject::Unlock

  00000			 AREA	 |.pdata|, PDATA
|$T43456| DCD	|$LN5@Unlock|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Unlock@LockObject@@QAAXXZ| PROC	; LockObject::Unlock

; 75   :     void Unlock(void) {LeaveCriticalSection( &m_CSection); };

  00000		 |$LN5@Unlock|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43453|
  00004	eb000000	 bl          LeaveCriticalSection
  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M43454|

			 ENDP  ; |?Unlock@LockObject@@QAAXXZ|, LockObject::Unlock

; File c:\wince600\public\common\oak\drivers\usb\hcd\usb20\usb2com\hcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T43465| DCD	|$LN5@SuspendHC|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SuspendHC@CHcd@@UAAHXZ| PROC		; CHcd::SuspendHC

; 112  :     virtual BOOL    SuspendHC() { return FALSE; }; // Default does not support it function.

  00000		 |$LN5@SuspendHC|
  00000		 |$M43462|
  00000	e3a00000	 mov         r0, #0
  00004	e12fff1e	 bx          lr
  00008		 |$M43463|

			 ENDP  ; |?SuspendHC@CHcd@@UAAHXZ|, CHcd::SuspendHC

; File c:\wince600\public\common\oak\drivers\usb\hcd\usb20\usb2com\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T43482| DCD	|$LN10@ResumeNoti|
	DCD	0x40002001
; Function compile flags: /Ogspy
; File c:\wince600\public\common\oak\drivers\usb\hcd\usb20\usb2com\hcd.hpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResumeNotification@CHcd@@MAAHXZ| PROC ; CHcd::ResumeNotification

; 120  :     virtual BOOL ResumeNotification ()  {

  00000		 |$LN10@ResumeNoti|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43479|
  00004	e1a04000	 mov         r4, r0

; 121  :         Lock();

  00008	e284008c	 add         r0, r4, #0x8C
  0000c	eb000000	 bl          EnterCriticalSection

; 122  :         BOOL fReturn = FALSE;
; 123  :         if (m_pCRootHub) {

  00010	e59430a0	 ldr         r3, [r4, #0xA0]
  00014	e3a05000	 mov         r5, #0
  00018	e3530000	 cmp         r3, #0
  0001c	0a000012	 beq         |$LN1@ResumeNoti|

; 124  :             fReturn = m_pCRootHub->ResumeNotification();

  00020	e1a00003	 mov         r0, r3
  00024	e5903000	 ldr         r3, [r0]
  00028	e5933028	 ldr         r3, [r3, #0x28]
  0002c	e1a0e00f	 mov         lr, pc
  00030	e12fff13	 bx          r3

; 125  :             m_pCRootHub->NotifyOnSuspendedResumed(FALSE);

  00034	e59420a0	 ldr         r2, [r4, #0xA0]
  00038	e1a05000	 mov         r5, r0
  0003c	e3a01000	 mov         r1, #0
  00040	e5923000	 ldr         r3, [r2]
  00044	e1a00002	 mov         r0, r2
  00048	e593302c	 ldr         r3, [r3, #0x2C]
  0004c	e1a0e00f	 mov         lr, pc
  00050	e12fff13	 bx          r3

; 126  :             m_pCRootHub->NotifyOnSuspendedResumed(TRUE);

  00054	e59400a0	 ldr         r0, [r4, #0xA0]
  00058	e3a01001	 mov         r1, #1
  0005c	e5903000	 ldr         r3, [r0]
  00060	e593302c	 ldr         r3, [r3, #0x2C]
  00064	e1a0e00f	 mov         lr, pc
  00068	e12fff13	 bx          r3
  0006c		 |$LN1@ResumeNoti|

; 127  :         }
; 128  :         Unlock();

  0006c	e284008c	 add         r0, r4, #0x8C
  00070	eb000000	 bl          LeaveCriticalSection

; 129  :         return fReturn;
; 130  :     }

  00074	e1a00005	 mov         r0, r5
  00078	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$M43480|

			 ENDP  ; |?ResumeNotification@CHcd@@MAAHXZ|, CHcd::ResumeNotification

; File c:\wince600\platform\common\src\soc\common_ti_v1\am3517\usb\usbh\chw.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T43489| DCD	|$LN5@SignalChec|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SignalCheckForDoneTransfers@CHW@@UAAXK@Z| PROC ; CHW::SignalCheckForDoneTransfers

; 85   :     virtual void   SignalCheckForDoneTransfers ( DWORD  ) { ASSERT(FALSE); };

  00000		 |$LN5@SignalChec|
  00000		 |$M43486|
  00000	e12fff1e	 bx          lr
  00004		 |$M43487|

			 ENDP  ; |?SignalCheckForDoneTransfers@CHW@@UAAXK@Z|, CHW::SignalCheckForDoneTransfers


  00000			 AREA	 |.pdata|, PDATA
|$T43498| DCD	|$LN5@StopAdjust|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?StopAdjustingFrame@CHW@@UAAHXZ| PROC	; CHW::StopAdjustingFrame

; 94   :     BOOL StopAdjustingFrame(void) { return TRUE; };

  00000		 |$LN5@StopAdjust|
  00000		 |$M43495|
  00000	e3a00001	 mov         r0, #1
  00004	e12fff1e	 bx          lr
  00008		 |$M43496|

			 ENDP  ; |?StopAdjustingFrame@CHW@@UAAHXZ|, CHW::StopAdjustingFrame


  00000			 AREA	 |.pdata|, PDATA
|$T43508| DCD	|$LN5@GetCapabil|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetCapability@?ICHcd@CHW@@UAAKXZ| PROC ; CHW[::CHcd]::GetCapability

; 116  :     DWORD CHcd::GetCapability(void) { return m_dwCap; }

  00000		 |$LN5@GetCapabil|
  00000		 |$M43505|
  00000	e5900198	 ldr         r0, [r0, #0x198]
  00004	e12fff1e	 bx          lr
  00008		 |$M43506|

			 ENDP  ; |?GetCapability@?ICHcd@CHW@@UAAKXZ|, CHW[::CHcd]::GetCapability


  00000			 AREA	 |.pdata|, PDATA
|$T43519| DCD	|$LN5@SetCapabil|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetCapability@?ICHcd@CHW@@UAAKK@Z| PROC ; CHW[::CHcd]::SetCapability

; 117  :     DWORD CHcd::SetCapability(DWORD dwCap) { return (m_dwCap |= dwCap); }

  00000		 |$LN5@SetCapabil|
  00000		 |$M43516|
  00000	e5903198	 ldr         r3, [r0, #0x198]
  00004	e1833001	 orr         r3, r3, r1
  00008	e5803198	 str         r3, [r0, #0x198]
  0000c	e1a00003	 mov         r0, r3
  00010	e12fff1e	 bx          lr
  00014		 |$M43517|

			 ENDP  ; |?SetCapability@?ICHcd@CHW@@UAAKK@Z|, CHW[::CHcd]::SetCapability

	EXPORT	|??1CHW@@UAA@XZ|			; CHW::~CHW
	IMPORT	|??1CHcd@@UAA@XZ|			; CHcd::~CHcd
	IMPORT	|??1CCppiDmaController@@QAA@XZ|		; CCppiDmaController::~CCppiDmaController
	IMPORT	|DeleteCriticalSection|
; File c:\wince600\platform\common\src\soc\common_ti_v1\am3517\usb\usbh\chw.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T43530| DCD	|$LN13@CHW@2|
	DCD	0x40002401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CHW@@UAA@XZ| PROC			; CHW::~CHW

; 299  : {

  00000		 |$LN13@CHW@2|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M43527|
  00004	e1a04000	 mov         r4, r0
  00008	e59f307c	 ldr         r3, [pc, #0x7C]

; 300  :     DeInitialize();

  0000c	e5843000	 str         r3, [r4]
  00010	eb000000	 bl          |?DeInitialize@CHW@@UAAXXZ|

; 301  :     DeleteCriticalSection( &m_csFrameCounter );

  00014	e2840f55	 add         r0, r4, #0x55, 30
  00018	eb000000	 bl          DeleteCriticalSection

; 302  :     DeleteCriticalSection( &m_csUsbProcLock );

  0001c	e2840f89	 add         r0, r4, #0x89, 30
  00020	eb000000	 bl          DeleteCriticalSection

; 303  : 
; 304  :     if (m_Ep0ProtectSem)

  00024	e59431a4	 ldr         r3, [r4, #0x1A4]
  00028	e3530000	 cmp         r3, #0

; 305  :         CloseHandle(m_Ep0ProtectSem);

  0002c	11a00003	 movne       r0, r3
  00030	1b000000	 blne        CloseHandle

; 306  :     for (UINT8 i = 0; i < (MGC_MAX_USB_ENDS - 1); i ++)

  00034	e3a03000	 mov         r3, #0
  00038	e3a05000	 mov         r5, #0
  0003c		 |$LL5@CHW@2|

; 307  :     {
; 308  :         if (m_EpInProtectSem[i])

  0003c	e0846103	 add         r6, r4, r3, lsl #2
  00040	e59631a8	 ldr         r3, [r6, #0x1A8]
  00044	e3530000	 cmp         r3, #0

; 309  :             CloseHandle(m_EpInProtectSem[i]);

  00048	11a00003	 movne       r0, r3
  0004c	1b000000	 blne        CloseHandle

; 310  :         if (m_EpOutProtectSem[i])

  00050	e59631e4	 ldr         r3, [r6, #0x1E4]
  00054	e3530000	 cmp         r3, #0

; 311  :             CloseHandle(m_EpOutProtectSem[i]);

  00058	11a00003	 movne       r0, r3
  0005c	1b000000	 blne        CloseHandle
  00060	e2853001	 add         r3, r5, #1
  00064	e20330ff	 and         r3, r3, #0xFF
  00068	e1a05003	 mov         r5, r3
  0006c	e353000f	 cmp         r3, #0xF
  00070	3afffff1	 bcc         |$LL5@CHW@2|

; 312  :     }
; 313  : }

  00074	e2840fca	 add         r0, r4, #0xCA, 30
  00078	eb000000	 bl          |??1CCppiDmaController@@QAA@XZ|
  0007c	e1a00004	 mov         r0, r4
  00080	eb000000	 bl          |??1CHcd@@UAA@XZ|
  00084	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$LN14@CHW@2|
  0008c		 |$LN15@CHW@2|
  0008c	00000000	 DCD         |??_7CHW@@6B@|
  00090		 |$M43528|

			 ENDP  ; |??1CHW@@UAA@XZ|, CHW::~CHW


  00000			 AREA	 |.pdata|, PDATA
|$T43545| DCD	|$LN7@DidPortSta|
	DCD	0x40000b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DidPortStatusChange@CHW@@UAAHE@Z| PROC ; CHW::DidPortStatusChange

; 1299 : {

  00000		 |$LN7@DidPortSta|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M43542|

; 1300 :     USB_HUB_AND_PORT_STATUS s;
; 1301 :     CHW::GetPortStatus(port, s);

  00008	e28d2000	 add         r2, sp, #0
  0000c	eb000000	 bl          |?GetPortStatus@CHW@@UAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z|

; 1302 :     return s.change.word ? TRUE : FALSE;

  00010	e1dd30b2	 ldrh        r3, [sp, #2]
  00014	e3530000	 cmp         r3, #0
  00018	13a00001	 movne       r0, #1
  0001c	03a00000	 moveq       r0, #0

; 1303 : }

  00020	e28dd004	 add         sp, sp, #4
  00024	e49de004	 ldr         lr, [sp], #4
  00028	e12fff1e	 bx          lr
  0002c		 |$M43543|

			 ENDP  ; |?DidPortStatusChange@CHW@@UAAHE@Z|, CHW::DidPortStatusChange

	EXPORT	|?UsbProcessingThread@CHW@@AAAKXZ|	; CHW::UsbProcessingThread
	EXPORT	|??_C@_1II@LBNMOOPF@?$AAR?$AAX?$AA?5?$AAI?$AAS?$AAO?$AA?5?$AAd?$AAo?$AAe?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAm?$AAe?$AAe?$AAt?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAs?$AAc?$AAh?$AAe?$AAd?$AAu?$AAl@| [ DATA ] ; `string'
	EXPORT	|??_C@_1II@DCFKBPOJ@?$AAT?$AAX?$AA?5?$AAI?$AAS?$AAO?$AA?5?$AAd?$AAo?$AAe?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAm?$AAe?$AAe?$AAt?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAs?$AAc?$AAh?$AAe?$AAd?$AAu?$AAl@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DM@OAANCGDM@?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AAE?$AAl?$AAe?$AAm?$AAe?$AAn?$AAt?$AAF?$AAr?$AAo?$AAm?$AAL?$AAi?$AAs?$AAt?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|ReleaseSemaphore|
	IMPORT	|?FreeTD@@YAXPAU_USBTD@@@Z|		; FreeTD
	IMPORT	|?RemoveElementFromList@@YAHPAPAUListHead@@PAU1@@Z| ; RemoveElementFromList
	IMPORT	|?ValidateTransferState@CCppiDmaController@@IAAHXZ| ; CCppiDmaController::ValidateTransferState
; File c:\wince600\platform\common\src\soc\common_ti_v1\am3517\usb\usbh\chw.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T43712| DCD	|$LN263@UsbProcess|
	DCD	0x40025c02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1II@LBNMOOPF@?$AAR?$AAX?$AA?5?$AAI?$AAS?$AAO?$AA?5?$AAd?$AAo?$AAe?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAm?$AAe?$AAe?$AAt?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAs?$AAc?$AAh?$AAe?$AAd?$AAu?$AAl@| DCB "R"
	DCB	0x0, "X", 0x0, " ", 0x0, "I", 0x0, "S", 0x0, "O", 0x0, " "
	DCB	0x0, "d", 0x0, "o", 0x0, "e", 0x0, "s", 0x0, " ", 0x0, "n"
	DCB	0x0, "o", 0x0, "t", 0x0, " ", 0x0, "m", 0x0, "e", 0x0, "e"
	DCB	0x0, "t", 0x0, " ", 0x0, "t", 0x0, "h", 0x0, "e", 0x0, " "
	DCB	0x0, "s", 0x0, "c", 0x0, "h", 0x0, "e", 0x0, "d", 0x0, "u"
	DCB	0x0, "l", 0x0, "e", 0x0, "!", 0x0, " ", 0x0, "C", 0x0, "u"
	DCB	0x0, "r", 0x0, "F", 0x0, "r", 0x0, "a", 0x0, "m", 0x0, "e"
	DCB	0x0, " ", 0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, ","
	DCB	0x0, " ", 0x0, "S", 0x0, "t", 0x0, "a", 0x0, "r", 0x0, "t"
	DCB	0x0, "F", 0x0, "r", 0x0, "a", 0x0, "m", 0x0, "e", 0x0, " "
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1II@DCFKBPOJ@?$AAT?$AAX?$AA?5?$AAI?$AAS?$AAO?$AA?5?$AAd?$AAo?$AAe?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAm?$AAe?$AAe?$AAt?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAs?$AAc?$AAh?$AAe?$AAd?$AAu?$AAl@| DCB "T"
	DCB	0x0, "X", 0x0, " ", 0x0, "I", 0x0, "S", 0x0, "O", 0x0, " "
	DCB	0x0, "d", 0x0, "o", 0x0, "e", 0x0, "s", 0x0, " ", 0x0, "n"
	DCB	0x0, "o", 0x0, "t", 0x0, " ", 0x0, "m", 0x0, "e", 0x0, "e"
	DCB	0x0, "t", 0x0, " ", 0x0, "t", 0x0, "h", 0x0, "e", 0x0, " "
	DCB	0x0, "s", 0x0, "c", 0x0, "h", 0x0, "e", 0x0, "d", 0x0, "u"
	DCB	0x0, "l", 0x0, "e", 0x0, "!", 0x0, " ", 0x0, "C", 0x0, "u"
	DCB	0x0, "r", 0x0, "F", 0x0, "r", 0x0, "a", 0x0, "m", 0x0, "e"
	DCB	0x0, " ", 0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, ","
	DCB	0x0, " ", 0x0, "S", 0x0, "t", 0x0, "a", 0x0, "r", 0x0, "t"
	DCB	0x0, "F", 0x0, "r", 0x0, "a", 0x0, "m", 0x0, "e", 0x0, " "
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DM@OAANCGDM@?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AAE?$AAl?$AAe?$AAm?$AAe?$AAn?$AAt?$AAF?$AAr?$AAo?$AAm?$AAL?$AAi?$AAs?$AAt?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?6?$AA?$AA@| DCB "R"
	DCB	0x0, "e", 0x0, "m", 0x0, "o", 0x0, "v", 0x0, "e", 0x0, "E"
	DCB	0x0, "l", 0x0, "e", 0x0, "m", 0x0, "e", 0x0, "n", 0x0, "t"
	DCB	0x0, "F", 0x0, "r", 0x0, "o", 0x0, "m", 0x0, "L", 0x0, "i"
	DCB	0x0, "s", 0x0, "t", 0x0, " ", 0x0, "F", 0x0, "a", 0x0, "i"
	DCB	0x0, "l", 0x0, "e", 0x0, "d", 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\am3517\usb\usbh\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UsbProcessingThread@CHW@@AAAKXZ| PROC ; CHW::UsbProcessingThread

; 1550 : {

  00000		 |$LN263@UsbProcess|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M43709|
  00008	e1a06000	 mov         r6, r0

; 1551 :     USBED *pED;
; 1552 :     USBTD *pTD;
; 1553 :     BOOL fEnableSOF = FALSE;
; 1554 :     BOOL fEnableSOFStateChanged = FALSE;
; 1555 :     DWORD dwWait;
; 1556 : 
; 1557 : #ifdef MUSB_USEDMA
; 1558 :     DWORD dwNow, dwLastStateCheck = 0;
; 1559 : #endif
; 1560 : 
; 1561 :     for(;;)
; 1562 :     {
; 1563 :         dwWait = WaitForSingleObject(g_hUsbProcessingEvent, PROCESSING_EVENT_TIMEOUT);

  0000c	e59f394c	 ldr         r3, [pc, #0x94C]
  00010	e3a05000	 mov         r5, #0
  00014	e3a01ffa	 mov         r1, #0xFA, 30
  00018	e5930000	 ldr         r0, [r3]
  0001c	e3a0b000	 mov         r11, #0
  00020	e58d5004	 str         r5, [sp, #4]
  00024	eb000000	 bl          WaitForSingleObject

; 1564 : 
; 1565 :         if (m_fUsbInterruptThreadClosing)

  00028	e5963180	 ldr         r3, [r6, #0x180]
  0002c	e1a04000	 mov         r4, r0
  00030	e3530000	 cmp         r3, #0
  00034	1a000245	 bne         |$LN215@UsbProcess|
  00038	e3a03c01	 mov         r3, #1, 24
  0003c	e3837002	 orr         r7, r3, #2
  00040	e3a03c01	 mov         r3, #1, 24
  00044	e3838001	 orr         r8, r3, #1
  00048	e58d800c	 str         r8, [sp, #0xC]
  0004c	e58d7008	 str         r7, [sp, #8]
  00050	e3a09000	 mov         r9, #0
  00054		 |$LL133@UsbProcess|

; 1566 :             break;
; 1567 : 
; 1568 : #ifdef MUSB_USEDMA
; 1569 : 
; 1570 :         // Validate DMA transfer state
; 1571 :         //
; 1572 :         // Notes: as far as error conditions (e.g. STALL) do not trigger DMA completion
; 1573 :         //        interrupt, the only possibilities to detect those errors are:
; 1574 :         //
; 1575 :         //        1) Enable/handle both EP and CPPI interrupts;
; 1576 :         //        2) Periodically poll transfer status checking for errors.
; 1577 :         //
; 1578 :         //        The first method is too expensive involving at least TWO interrupt
; 1579 :         //        events per USB packet! We will use the second one instead.
; 1580 : 
; 1581 :         if (((SOhcdPdd*)m_pPddContext)->CurrentDx == D0) // Do not fail transfers when powered down

  00054	e5963188	 ldr         r3, [r6, #0x188]
  00058	e5933220	 ldr         r3, [r3, #0x220]
  0005c	e3530000	 cmp         r3, #0
  00060	1a00000e	 bne         |$LN127@UsbProcess|

; 1582 :         {
; 1583 :             dwNow = GetTickCount();

  00064	eb000000	 bl          GetTickCount
  00068	e1a02000	 mov         r2, r0

; 1584 :             if ((dwWait == WAIT_TIMEOUT) || ((INT32)(dwNow - dwLastStateCheck) >= PROCESSING_EVENT_TIMEOUT))

  0006c	e1540007	 cmp         r4, r7
  00070	0a000002	 beq         |$LN128@UsbProcess|
  00074	e0423005	 sub         r3, r2, r5
  00078	e3530ffa	 cmp         r3, #0xFA, 30
  0007c	ba000007	 blt         |$LN127@UsbProcess|
  00080		 |$LN128@UsbProcess|

; 1585 :             {
; 1586 :                 dwLastStateCheck = dwNow;
; 1587 :                 if (m_dmaCrtl.ValidateTransferState() && (dwWait == WAIT_TIMEOUT))

  00080	e1a05002	 mov         r5, r2
  00084	e2860fca	 add         r0, r6, #0xCA, 30
  00088	e58d5004	 str         r5, [sp, #4]
  0008c	eb000000	 bl          |?ValidateTransferState@CCppiDmaController@@IAAHXZ|
  00090	e3500000	 cmp         r0, #0
  00094	0a000001	 beq         |$LN127@UsbProcess|
  00098	e1540007	 cmp         r4, r7
  0009c	0a000223	 beq         |$LN232@UsbProcess|
  000a0		 |$LN127@UsbProcess|

; 1588 :                 {
; 1589 :                     // Nothing to do, just continue sleeping
; 1590 :                     continue;
; 1591 :                 }
; 1592 :             }
; 1593 :         }
; 1594 : 
; 1595 : #endif // MUSB_USEDMA
; 1596 : 
; 1597 :         LockProcessingThread();

  000a0	e2860f89	 add         r0, r6, #0x89, 30
  000a4	eb000000	 bl          EnterCriticalSection

; 1598 : 
; 1599 :         fEnableSOFStateChanged = FALSE;
; 1600 : 
; 1601 : 
; 1602 :         ///////////////////////////////////////////////////////////////////////////
; 1603 :         // Control requests
; 1604 : 
; 1605 :         pED = (USBED*)m_pControlHead;

  000a8	e59630a4	 ldr         r3, [r6, #0xA4]
  000ac	e3a0a000	 mov         r10, #0
  000b0	e3a07001	 mov         r7, #1
  000b4		 |$LN243@UsbProcess|
  000b4	e1b04003	 movs        r4, r3

; 1606 :         while(pED){

  000b8	1a000027	 bne         |$LN216@UsbProcess|

; 1650 :         }
; 1651 : 
; 1652 :         ///////////////////////////////////////////////////////////////////////////
; 1653 :         // Interrupt out requests
; 1654 : 
; 1655 :         pED = (USBED*)m_pIntOutHead;

  000bc	e59630b4	 ldr         r3, [r6, #0xB4]
  000c0	ea000062	 b           |$LN244@UsbProcess|
  000c4		 |$redoforsameEDCtl$41965|

; 1607 : redoforsameEDCtl:
; 1608 : 
; 1609 :             if(pED->HeadTD && (pED->HeadTD != pED->TailTD)){

  000c4	e5945014	 ldr         r5, [r4, #0x14]
  000c8	e5943018	 ldr         r3, [r4, #0x18]
  000cc	e1550003	 cmp         r5, r3
  000d0	0a00002f	 beq         |$LN137@UsbProcess|

; 1610 :                 pTD = (USBTD *)pED->HeadTD;
; 1611 :                 switch(pED->TransferStatus){

  000d4	e594301c	 ldr         r3, [r4, #0x1C]
  000d8	e3530000	 cmp         r3, #0
  000dc	0a000023	 beq         |$LN121@UsbProcess|
  000e0	e3530001	 cmp         r3, #1
  000e4	0a000013	 beq         |$LN119@UsbProcess|
  000e8	e3530002	 cmp         r3, #2
  000ec	1a000028	 bne         |$LN137@UsbProcess|

; 1627 :                         goto redoforsameEDCtl;
; 1628 :                     }
; 1629 :                     break;
; 1630 :                 case STATUS_COMPLETE:
; 1631 : 
; 1632 :                     RETAILMSG(0, (L"PCTL_%08X--\r\n", pTD));
; 1633 :                     if(RemoveElementFromList((ListHead**)&pED->HeadTD, (ListHead*)pTD)){

  000f0	e1a01005	 mov         r1, r5
  000f4	e2840014	 add         r0, r4, #0x14
  000f8	eb000000	 bl          |?RemoveElementFromList@@YAHPAPAUListHead@@PAU1@@Z|
  000fc	e3500000	 cmp         r0, #0
  00100	0a000007	 beq         |$LN116@UsbProcess|

; 1634 :                         CTRLTCMSG(1, (L"TC: EP0 len %d", pTD->BytesTransferred));
; 1635 :                         if (pTD->sTransfer.lpfnCallback)

  00104	e5953008	 ldr         r3, [r5, #8]
  00108	e3530000	 cmp         r3, #0

; 1636 :                         {
; 1637 :                             ( *pTD->sTransfer.lpfnCallback )( pTD->sTransfer.lpvCallbackParameter );

  0010c	1595000c	 ldrne       r0, [r5, #0xC]
  00110	11a0e00f	 movne       lr, pc
  00114	112fff13	 bxne        r3

; 1638 :                         }
; 1639 :                         FreeTD(pTD);

  00118	e1a00005	 mov         r0, r5
  0011c	eb000000	 bl          |?FreeTD@@YAXPAU_USBTD@@@Z|

; 1640 :                     }
; 1641 :                     else{

  00120	ea000001	 b           |$LN141@UsbProcess|
  00124		 |$LN116@UsbProcess|

; 1642 :                         RETAILMSG(1, (TEXT("RemoveElementFromList Failed\n")));

  00124	e59f0838	 ldr         r0, [pc, #0x838]
  00128	eb000000	 bl          NKDbgPrintfW
  0012c		 |$LN141@UsbProcess|

; 1643 :                     }
; 1644 :                     m_pProcessEDControl = NULL;

  0012c	e58690c0	 str         r9, [r6, #0xC0]

; 1645 :                     pED->TransferStatus = STATUS_IDLE;

  00130	e584901c	 str         r9, [r4, #0x1C]

; 1646 :                     goto redoforsameEDCtl;

  00134	ea000008	 b           |$LN216@UsbProcess|
  00138		 |$LN119@UsbProcess|

; 1617 :                         RETAILMSG(0, (L"PCTL_%08X\r\n", pTD));
; 1618 :                     }
; 1619 :                     break;
; 1620 :                 case STATUS_PROGRESS:
; 1621 :                     if ((m_portStatus & PORT_STATUS_DEVICE_ATTACHED) == 0)

  00138	e5d63196	 ldrb        r3, [r6, #0x196]
  0013c	e3130002	 tst         r3, #2
  00140	1a000013	 bne         |$LN137@UsbProcess|

; 1622 :                     {
; 1623 :                         // Device disconnected, need to fail the transfer
; 1624 :                         *pTD->sTransfer.lpfComplete = TRUE;

  00144	e5953040	 ldr         r3, [r5, #0x40]
  00148	e5837000	 str         r7, [r3]

; 1625 :                         *pTD->sTransfer.lpdwError = USB_CANCELED_ERROR;

  0014c	e5953048	 ldr         r3, [r5, #0x48]
  00150	e5838000	 str         r8, [r3]

; 1626 :                         pED->TransferStatus = STATUS_COMPLETE;

  00154	e3a03002	 mov         r3, #2
  00158	e584301c	 str         r3, [r4, #0x1C]
  0015c		 |$LN216@UsbProcess|
  0015c	e5943014	 ldr         r3, [r4, #0x14]
  00160	e3530000	 cmp         r3, #0
  00164	1affffd6	 bne         |$redoforsameEDCtl$41965|

; 1647 :                 }
; 1648 :             }
; 1649 :             pED = (USBED *)pED->NextED.next;

  00168	e5943000	 ldr         r3, [r4]
  0016c	eaffffd0	 b           |$LN243@UsbProcess|
  00170		 |$LN121@UsbProcess|

; 1612 :                 case STATUS_IDLE:
; 1613 :                     if(!pED->bfSkip){

  00170	e5d4300c	 ldrb        r3, [r4, #0xC]
  00174	e3530000	 cmp         r3, #0

; 1614 :                         m_pProcessEDControl = (PDWORD)pED;

  00178	058640c0	 streq       r4, [r6, #0xC0]

; 1615 :                         pED->TransferStatus = STATUS_PROGRESS;

  0017c	0584701c	 streq       r7, [r4, #0x1C]

; 1616 :                         InitializeTransaction((UINT32)m_portBase, pED, pTD);

  00180	05961140	 ldreq       r1, [r6, #0x140]
  00184	01a03005	 moveq       r3, r5
  00188	01a02004	 moveq       r2, r4
  0018c	01a00006	 moveq       r0, r6
  00190	0b000000	 bleq        |?InitializeTransaction@CHW@@QAAXIPAX0@Z|
  00194		 |$LN137@UsbProcess|

; 1647 :                 }
; 1648 :             }
; 1649 :             pED = (USBED *)pED->NextED.next;

  00194	e5943000	 ldr         r3, [r4]
  00198	eaffffc5	 b           |$LN243@UsbProcess|
  0019c		 |$redoforsameEDIntOut$41993|

; 1656 :         while(pED) {
; 1657 : redoforsameEDIntOut:
; 1658 : 
; 1659 :             if(pED->HeadTD && (pED->HeadTD != pED->TailTD)){

  0019c	e5945014	 ldr         r5, [r4, #0x14]
  001a0	e5943018	 ldr         r3, [r4, #0x18]
  001a4	e1550003	 cmp         r5, r3
  001a8	0a000027	 beq         |$LN107@UsbProcess|

; 1660 :                 pTD = (USBTD *)pED->HeadTD;
; 1661 :                 switch(pED->TransferStatus){

  001ac	e594301c	 ldr         r3, [r4, #0x1C]
  001b0	e3530000	 cmp         r3, #0
  001b4	0a000018	 beq         |$LN108@UsbProcess|
  001b8	e3530002	 cmp         r3, #2
  001bc	1a000022	 bne         |$LN107@UsbProcess|

; 1667 :                     }
; 1668 :                     break;
; 1669 :                 case STATUS_PROGRESS:
; 1670 :                     break;
; 1671 :                 case STATUS_COMPLETE:
; 1672 :                     if(RemoveElementFromList((ListHead**)&pED->HeadTD, (ListHead*)pTD)){

  001c0	e1a01005	 mov         r1, r5
  001c4	e2840014	 add         r0, r4, #0x14
  001c8	eb000000	 bl          |?RemoveElementFromList@@YAHPAPAUListHead@@PAU1@@Z|
  001cc	e3500000	 cmp         r0, #0
  001d0	0a000007	 beq         |$LN104@UsbProcess|

; 1673 :                         INTTCMSG(1, (L"TC: EP%d INT OUT, len %d", pED->bHostEndPointNum, pTD->BytesTransferred));
; 1674 :                         if (pTD->sTransfer.lpfnCallback)

  001d4	e5953008	 ldr         r3, [r5, #8]
  001d8	e3530000	 cmp         r3, #0

; 1675 :                         {
; 1676 :                             ( *pTD->sTransfer.lpfnCallback )( pTD->sTransfer.lpvCallbackParameter );

  001dc	1595000c	 ldrne       r0, [r5, #0xC]
  001e0	11a0e00f	 movne       lr, pc
  001e4	112fff13	 bxne        r3

; 1677 :                         }
; 1678 :                         FreeTD(pTD);

  001e8	e1a00005	 mov         r0, r5
  001ec	eb000000	 bl          |?FreeTD@@YAXPAU_USBTD@@@Z|

; 1679 :                     }
; 1680 :                     else{

  001f0	ea000001	 b           |$LN143@UsbProcess|
  001f4		 |$LN104@UsbProcess|

; 1681 :                         RETAILMSG(1,(TEXT("RemoveElementFromList Failed\n")));

  001f4	e59f0768	 ldr         r0, [pc, #0x768]
  001f8	eb000000	 bl          NKDbgPrintfW
  001fc		 |$LN143@UsbProcess|

; 1682 :                     }
; 1683 :                     m_pProcessEDOut[pED->bHostEndPointNum - 1] = NULL;

  001fc	e5d43010	 ldrb        r3, [r4, #0x10]
  00200	e0863103	 add         r3, r6, r3, lsl #2
  00204	e58390fc	 str         r9, [r3, #0xFC]

; 1684 :                     pED->TransferStatus = STATUS_IDLE;

  00208	e584901c	 str         r9, [r4, #0x1C]
  0020c		 |$LL113@UsbProcess|
  0020c	e5943014	 ldr         r3, [r4, #0x14]
  00210	e3530000	 cmp         r3, #0
  00214	1affffe0	 bne         |$redoforsameEDIntOut$41993|

; 1564 : 
; 1565 :         if (m_fUsbInterruptThreadClosing)

  00218	ea00000b	 b           |$LN107@UsbProcess|
  0021c		 |$LN108@UsbProcess|

; 1662 :                 case STATUS_IDLE:
; 1663 :                     if(!pED->bfSkip){

  0021c	e5d4300c	 ldrb        r3, [r4, #0xC]
  00220	e3530000	 cmp         r3, #0
  00224	1a000008	 bne         |$LN107@UsbProcess|

; 1664 :                         m_pProcessEDOut[pED->bHostEndPointNum - 1] = (PDWORD)pED;

  00228	e5d41010	 ldrb        r1, [r4, #0x10]

; 1665 :                         pED->TransferStatus = STATUS_PROGRESS;
; 1666 :                         InitializeTransaction((UINT32)m_portBase, pED, pTD);

  0022c	e1a03005	 mov         r3, r5
  00230	e1a02004	 mov         r2, r4
  00234	e0861101	 add         r1, r6, r1, lsl #2
  00238	e58140fc	 str         r4, [r1, #0xFC]
  0023c	e584701c	 str         r7, [r4, #0x1C]
  00240	e5961140	 ldr         r1, [r6, #0x140]
  00244	e1a00006	 mov         r0, r6
  00248	eb000000	 bl          |?InitializeTransaction@CHW@@QAAXIPAX0@Z|
  0024c		 |$LN107@UsbProcess|

; 1685 :                     goto redoforsameEDIntOut;
; 1686 :                 }
; 1687 :             }
; 1688 :             pED = (USBED *)pED->NextED.next;

  0024c	e5943000	 ldr         r3, [r4]
  00250		 |$LN244@UsbProcess|
  00250	e1b04003	 movs        r4, r3
  00254	1affffec	 bne         |$LL113@UsbProcess|

; 1689 :         }
; 1690 : 
; 1691 :         ///////////////////////////////////////////////////////////////////////////
; 1692 :         // Interrupt in requests
; 1693 : 
; 1694 :         pED = (USBED*)m_pIntInHead;

  00258	e59630b0	 ldr         r3, [r6, #0xB0]
  0025c	ea00002c	 b           |$LN246@UsbProcess|
  00260		 |$redoforsameEDIntIn$42017|

; 1695 :         while(pED) {
; 1696 : redoforsameEDIntIn:
; 1697 : 
; 1698 :             if(pED->HeadTD && (pED->HeadTD != pED->TailTD)){

  00260	e5945014	 ldr         r5, [r4, #0x14]
  00264	e5943018	 ldr         r3, [r4, #0x18]
  00268	e1550003	 cmp         r5, r3
  0026c	0a000027	 beq         |$LN95@UsbProcess|

; 1699 :                 pTD = (USBTD *)pED->HeadTD;
; 1700 :                 switch(pED->TransferStatus){

  00270	e594301c	 ldr         r3, [r4, #0x1C]
  00274	e3530000	 cmp         r3, #0
  00278	0a000018	 beq         |$LN96@UsbProcess|
  0027c	e3530002	 cmp         r3, #2
  00280	1a000022	 bne         |$LN95@UsbProcess|

; 1706 :                     }
; 1707 :                     break;
; 1708 :                 case STATUS_PROGRESS:
; 1709 :                     break;
; 1710 :                 case STATUS_COMPLETE:
; 1711 :                     if(RemoveElementFromList((ListHead**)&pED->HeadTD, (ListHead*)pTD)){

  00284	e1a01005	 mov         r1, r5
  00288	e2840014	 add         r0, r4, #0x14
  0028c	eb000000	 bl          |?RemoveElementFromList@@YAHPAPAUListHead@@PAU1@@Z|
  00290	e3500000	 cmp         r0, #0
  00294	0a000007	 beq         |$LN92@UsbProcess|

; 1712 :                         INTTCMSG(1, (L"TC: EP%d INT IN, len %d", pED->bHostEndPointNum, pTD->BytesTransferred));
; 1713 :                         if (pTD->sTransfer.lpfnCallback)

  00298	e5953008	 ldr         r3, [r5, #8]
  0029c	e3530000	 cmp         r3, #0

; 1714 :                         {
; 1715 :                             ( *pTD->sTransfer.lpfnCallback )( pTD->sTransfer.lpvCallbackParameter );

  002a0	1595000c	 ldrne       r0, [r5, #0xC]
  002a4	11a0e00f	 movne       lr, pc
  002a8	112fff13	 bxne        r3

; 1716 :                         }
; 1717 :                         FreeTD(pTD);

  002ac	e1a00005	 mov         r0, r5
  002b0	eb000000	 bl          |?FreeTD@@YAXPAU_USBTD@@@Z|

; 1718 :                     }
; 1719 :                     else{

  002b4	ea000001	 b           |$LN145@UsbProcess|
  002b8		 |$LN92@UsbProcess|

; 1720 :                         RETAILMSG(1,(TEXT("RemoveElementFromList Failed\n")));

  002b8	e59f06a4	 ldr         r0, [pc, #0x6A4]
  002bc	eb000000	 bl          NKDbgPrintfW
  002c0		 |$LN145@UsbProcess|

; 1721 :                     }
; 1722 :                     m_pProcessEDIn[pED->bHostEndPointNum - 1] = NULL;

  002c0	e5d43010	 ldrb        r3, [r4, #0x10]
  002c4	e0863103	 add         r3, r6, r3, lsl #2
  002c8	e58390c0	 str         r9, [r3, #0xC0]

; 1723 :                     pED->TransferStatus = STATUS_IDLE;

  002cc	e584901c	 str         r9, [r4, #0x1C]
  002d0		 |$LL101@UsbProcess|
  002d0	e5943014	 ldr         r3, [r4, #0x14]
  002d4	e3530000	 cmp         r3, #0
  002d8	1affffe0	 bne         |$redoforsameEDIntIn$42017|

; 1564 : 
; 1565 :         if (m_fUsbInterruptThreadClosing)

  002dc	ea00000b	 b           |$LN95@UsbProcess|
  002e0		 |$LN96@UsbProcess|

; 1701 :                 case STATUS_IDLE:
; 1702 :                     if(!pED->bfSkip){

  002e0	e5d4300c	 ldrb        r3, [r4, #0xC]
  002e4	e3530000	 cmp         r3, #0
  002e8	1a000008	 bne         |$LN95@UsbProcess|

; 1703 :                         m_pProcessEDIn[pED->bHostEndPointNum - 1] = (PDWORD)pED;

  002ec	e5d41010	 ldrb        r1, [r4, #0x10]

; 1704 :                         pED->TransferStatus = STATUS_PROGRESS;
; 1705 :                         InitializeTransaction((UINT32)m_portBase, pED, pTD);

  002f0	e1a03005	 mov         r3, r5
  002f4	e1a02004	 mov         r2, r4
  002f8	e0861101	 add         r1, r6, r1, lsl #2
  002fc	e58140c0	 str         r4, [r1, #0xC0]
  00300	e584701c	 str         r7, [r4, #0x1C]
  00304	e5961140	 ldr         r1, [r6, #0x140]
  00308	e1a00006	 mov         r0, r6
  0030c	eb000000	 bl          |?InitializeTransaction@CHW@@QAAXIPAX0@Z|
  00310		 |$LN95@UsbProcess|

; 1724 :                     goto redoforsameEDIntIn;
; 1725 :                 }
; 1726 :             }
; 1727 :             pED = (USBED *)pED->NextED.next;

  00310	e5943000	 ldr         r3, [r4]
  00314		 |$LN246@UsbProcess|
  00314	e1b04003	 movs        r4, r3
  00318	1affffec	 bne         |$LL101@UsbProcess|

; 1728 :         }
; 1729 : 
; 1730 : 
; 1731 : #ifdef MUSB_USEDMA
; 1732 : #ifdef MUSB_USEDMA_FOR_ISO
; 1733 : 
; 1734 : 
; 1735 :         ///////////////////////////////////////////////////////////////////////////
; 1736 :         // Isochronous (out) requests
; 1737 : 
; 1738 :         pED = (USBED*)m_pIsoOutHead;

  0031c	e59630bc	 ldr         r3, [r6, #0xBC]
  00320	e1b04003	 movs        r4, r3

; 1739 :         while(pED) {

  00324	1a000026	 bne         |$LL89@UsbProcess|
  00328		 |$LN241@UsbProcess|

; 1806 :         }
; 1807 : 
; 1808 : IsoOutDone: ; // NOP
; 1809 : 
; 1810 : 
; 1811 :         ///////////////////////////////////////////////////////////////////////////
; 1812 :         // Isochronous (in) requests
; 1813 : 
; 1814 :         pED = (USBED*)m_pIsoInHead;

  00328	e59630b8	 ldr         r3, [r6, #0xB8]
  0032c	e3a07001	 mov         r7, #1
  00330		 |$IsoOutDone$42053|
  00330	ea000075	 b           |$LN251@UsbProcess|
  00334		 |$redoforsameIsoOutED$42041|

; 1740 : redoforsameIsoOutED:
; 1741 : 
; 1742 :             if(pED->HeadTD && (pED->HeadTD != pED->TailTD))

  00334	e5945014	 ldr         r5, [r4, #0x14]
  00338	e5943018	 ldr         r3, [r4, #0x18]
  0033c	e1550003	 cmp         r5, r3
  00340	0a00002e	 beq         |$LN78@UsbProcess|

; 1743 :             {
; 1744 :                 pTD = (USBTD *)pED->HeadTD;
; 1745 : 
; 1746 :                 if (pTD->bAwaitingFrame)

  00344	e5953060	 ldr         r3, [r5, #0x60]
  00348	e3530000	 cmp         r3, #0
  0034c	1afffff5	 bne         |$LN241@UsbProcess|

; 1747 :                 {
; 1748 :                     break;
; 1749 :                 }
; 1750 : 
; 1751 :                 switch(pED->TransferStatus)

  00350	e594301c	 ldr         r3, [r4, #0x1C]
  00354	e3530000	 cmp         r3, #0
  00358	0a00001d	 beq         |$LN83@UsbProcess|
  0035c	e3530002	 cmp         r3, #2
  00360	1a000026	 bne         |$LN78@UsbProcess|

; 1776 : 
; 1777 :                                 RETAILMSG(FALSE,(TEXT("OUT take %d\n"),pED->bHostEndPointNum));
; 1778 :                                 goto IsoOutDone;
; 1779 :                             }
; 1780 :                         }
; 1781 :                         break;
; 1782 :                     case STATUS_PROGRESS:
; 1783 :                         break;
; 1784 :                     case STATUS_COMPLETE:
; 1785 : 
; 1786 :                         if(RemoveElementFromList((ListHead**)&pED->HeadTD, (ListHead*)pTD)){

  00364	e1a01005	 mov         r1, r5
  00368	e2840014	 add         r0, r4, #0x14
  0036c	eb000000	 bl          |?RemoveElementFromList@@YAHPAPAUListHead@@PAU1@@Z|
  00370	e3500000	 cmp         r0, #0
  00374	0a00000c	 beq         |$LN74@UsbProcess|

; 1787 :                             ISOTCMSG(1, (L"TC: EP%d ISO OUT, len %d", pED->bHostEndPointNum, pTD->BytesTransferred));
; 1788 :                             if (pTD->sTransfer.lpfnCallback)

  00378	e5953008	 ldr         r3, [r5, #8]
  0037c	e3530000	 cmp         r3, #0

; 1789 :                             {
; 1790 :                                 ( *pTD->sTransfer.lpfnCallback )( pTD->sTransfer.lpvCallbackParameter );

  00380	1595000c	 ldrne       r0, [r5, #0xC]
  00384	11a0e00f	 movne       lr, pc
  00388	112fff13	 bxne        r3

; 1791 :                             }
; 1792 :                             FreeTD(pTD);

  0038c	e1a00005	 mov         r0, r5
  00390	eb000000	 bl          |?FreeTD@@YAXPAU_USBTD@@@Z|

; 1793 :                             ReleaseSemaphore(pED->hSemaphore, 1, NULL );

  00394	e5940030	 ldr         r0, [r4, #0x30]
  00398	e3a02000	 mov         r2, #0
  0039c	e3a01001	 mov         r1, #1
  003a0	eb000000	 bl          ReleaseSemaphore

; 1794 :                             pED->bSemaphoreOwner = FALSE;

  003a4	e584902c	 str         r9, [r4, #0x2C]

; 1795 :                             RETAILMSG(FALSE,(TEXT("OUT give %d\n"),pED->bHostEndPointNum));
; 1796 :                         }
; 1797 :                         else{

  003a8	ea000001	 b           |$LN151@UsbProcess|
  003ac		 |$LN74@UsbProcess|

; 1798 :                             RETAILMSG(TRUE,(TEXT("RemoveElementFromList Failed\n")));

  003ac	e59f05b0	 ldr         r0, [pc, #0x5B0]
  003b0	eb000000	 bl          NKDbgPrintfW
  003b4		 |$LN151@UsbProcess|

; 1799 :                         }
; 1800 :                         m_pProcessEDOut[pED->bHostEndPointNum - 1] = NULL;

  003b4	e5d43010	 ldrb        r3, [r4, #0x10]
  003b8	e0863103	 add         r3, r6, r3, lsl #2
  003bc	e58390fc	 str         r9, [r3, #0xFC]

; 1801 :                         pED->TransferStatus = STATUS_IDLE;

  003c0	e584901c	 str         r9, [r4, #0x1C]
  003c4		 |$LL89@UsbProcess|
  003c4	e5943014	 ldr         r3, [r4, #0x14]
  003c8	e3530000	 cmp         r3, #0
  003cc	1affffd8	 bne         |$redoforsameIsoOutED$42041|

; 1564 : 
; 1565 :         if (m_fUsbInterruptThreadClosing)

  003d0	ea00000a	 b           |$LN78@UsbProcess|
  003d4		 |$LN83@UsbProcess|

; 1752 :                 {
; 1753 :                     case STATUS_IDLE:
; 1754 :                         if(!pED->bfSkip){

  003d4	e5d4300c	 ldrb        r3, [r4, #0xC]
  003d8	e3530000	 cmp         r3, #0
  003dc	1a000007	 bne         |$LN78@UsbProcess|

; 1755 :                             if( pED->bSemaphoreOwner == TRUE)

  003e0	e594302c	 ldr         r3, [r4, #0x2C]
  003e4	e3530001	 cmp         r3, #1
  003e8	0a000011	 beq         |$LN203@UsbProcess|

; 1759 : 
; 1760 :                                 //InitializeTransaction((UINT32)m_portBase, pED, pTD);
; 1761 :                                 pTD->bAwaitingFrame = TRUE;
; 1762 : 
; 1763 :                                 //RETAILMSG(1, (L"TX ISO: wait1 TD %08X\r\n", pTD));
; 1764 : 
; 1765 :                                 //RETAILMSG(FALSE,(TEXT("OUT take %d\n"),pED->bHostEndPointNum));
; 1766 :                                 goto IsoOutDone;
; 1767 :                             }
; 1768 :                             else if(WaitForSingleObject( pED->hSemaphore, 0 ) == WAIT_OBJECT_0){

  003ec	e5940030	 ldr         r0, [r4, #0x30]
  003f0	e3a01000	 mov         r1, #0
  003f4	eb000000	 bl          WaitForSingleObject
  003f8	e3500000	 cmp         r0, #0
  003fc	0a000003	 beq         |$LN204@UsbProcess|
  00400		 |$LN78@UsbProcess|

; 1802 :                         goto redoforsameIsoOutED;
; 1803 :                 }
; 1804 :             }
; 1805 :             pED = (USBED *)pED->NextED.next;

  00400	e5943000	 ldr         r3, [r4]
  00404	e1b04003	 movs        r4, r3
  00408	1affffed	 bne         |$LL89@UsbProcess|
  0040c	eaffffc5	 b           |$LN241@UsbProcess|
  00410		 |$LN204@UsbProcess|

; 1769 :                                 pED->bSemaphoreOwner = TRUE;
; 1770 : 
; 1771 :                                 m_pProcessEDOut[pED->bHostEndPointNum - 1] = (PDWORD)pED;

  00410	e3a07001	 mov         r7, #1
  00414	e584702c	 str         r7, [r4, #0x2C]
  00418		 |$LN259@UsbProcess|
  00418	e5d43010	 ldrb        r3, [r4, #0x10]
  0041c	e0863103	 add         r3, r6, r3, lsl #2
  00420	e58340fc	 str         r4, [r3, #0xFC]

; 1772 :                                 pED->TransferStatus = STATUS_PROGRESS;

  00424	e584701c	 str         r7, [r4, #0x1C]

; 1773 : 
; 1774 :                                 //InitializeTransaction((UINT32)m_portBase, pED, pTD);
; 1775 :                                 pTD->bAwaitingFrame = TRUE;

  00428	e5857060	 str         r7, [r5, #0x60]

; 1806 :         }
; 1807 : 
; 1808 : IsoOutDone: ; // NOP
; 1809 : 
; 1810 : 
; 1811 :         ///////////////////////////////////////////////////////////////////////////
; 1812 :         // Isochronous (in) requests
; 1813 : 
; 1814 :         pED = (USBED*)m_pIsoInHead;

  0042c	e59630b8	 ldr         r3, [r6, #0xB8]
  00430	ea000035	 b           |$LN251@UsbProcess|
  00434		 |$LN203@UsbProcess|

; 1756 :                             {
; 1757 :                                 m_pProcessEDOut[pED->bHostEndPointNum - 1] = (PDWORD)pED;
; 1758 :                                 pED->TransferStatus = STATUS_PROGRESS;

  00434	e3a07001	 mov         r7, #1

; 1564 : 
; 1565 :         if (m_fUsbInterruptThreadClosing)

  00438	eafffff6	 b           |$LN259@UsbProcess|
  0043c		 |$redoforsameIsoInED$42074|

; 1815 : 
; 1816 :         while(pED) {
; 1817 : redoforsameIsoInED:
; 1818 : 
; 1819 :             if(pED->HeadTD && (pED->HeadTD != pED->TailTD)){

  0043c	e5945014	 ldr         r5, [r4, #0x14]
  00440	e5943018	 ldr         r3, [r4, #0x18]
  00444	e1550003	 cmp         r5, r3
  00448	0a00002e	 beq         |$LN60@UsbProcess|

; 1820 :                 pTD = (USBTD *)pED->HeadTD;
; 1821 : 
; 1822 :                 if (pTD->bAwaitingFrame)

  0044c	e5953060	 ldr         r3, [r5, #0x60]
  00450	e3530000	 cmp         r3, #0
  00454	1a000035	 bne         |$IsoInDone$42086|

; 1823 :                 {
; 1824 :                     break;
; 1825 :                 }
; 1826 : 
; 1827 :                 switch(pED->TransferStatus)

  00458	e594301c	 ldr         r3, [r4, #0x1C]
  0045c	e3530000	 cmp         r3, #0
  00460	0a00001d	 beq         |$LN65@UsbProcess|
  00464	e3530002	 cmp         r3, #2
  00468	1a000026	 bne         |$LN60@UsbProcess|

; 1850 : 
; 1851 :                                 RETAILMSG(FALSE,(TEXT("IN take %d\n"),pED->bHostEndPointNum));
; 1852 :                                 goto IsoInDone;
; 1853 :                             }
; 1854 :                         }
; 1855 :                         break;
; 1856 :                     case STATUS_PROGRESS:
; 1857 :                         break;
; 1858 :                     case STATUS_COMPLETE:
; 1859 : 
; 1860 :                         if(RemoveElementFromList((ListHead**)&pED->HeadTD, (ListHead*)pTD)){

  0046c	e1a01005	 mov         r1, r5
  00470	e2840014	 add         r0, r4, #0x14
  00474	eb000000	 bl          |?RemoveElementFromList@@YAHPAPAUListHead@@PAU1@@Z|
  00478	e3500000	 cmp         r0, #0
  0047c	0a00000c	 beq         |$LN56@UsbProcess|

; 1861 :                             ISOTCMSG(1, (L"TC: EP%d ISO IN, len %d", pED->bHostEndPointNum, pTD->BytesTransferred));
; 1862 :                             if (pTD->sTransfer.lpfnCallback)

  00480	e5953008	 ldr         r3, [r5, #8]
  00484	e3530000	 cmp         r3, #0

; 1863 :                             {
; 1864 :                                 ( *pTD->sTransfer.lpfnCallback )( pTD->sTransfer.lpvCallbackParameter );

  00488	1595000c	 ldrne       r0, [r5, #0xC]
  0048c	11a0e00f	 movne       lr, pc
  00490	112fff13	 bxne        r3

; 1865 :                             }
; 1866 :                             FreeTD(pTD);

  00494	e1a00005	 mov         r0, r5
  00498	eb000000	 bl          |?FreeTD@@YAXPAU_USBTD@@@Z|

; 1867 :                             ReleaseSemaphore(pED->hSemaphore, 1, NULL );

  0049c	e5940030	 ldr         r0, [r4, #0x30]
  004a0	e3a02000	 mov         r2, #0
  004a4	e3a01001	 mov         r1, #1
  004a8	eb000000	 bl          ReleaseSemaphore

; 1868 :                             pED->bSemaphoreOwner = FALSE;

  004ac	e584902c	 str         r9, [r4, #0x2C]

; 1869 :                             RETAILMSG(FALSE,(TEXT("IN give %d\n"),pED->bHostEndPointNum));
; 1870 :                         }
; 1871 :                         else{

  004b0	ea000001	 b           |$LN157@UsbProcess|
  004b4		 |$LN56@UsbProcess|

; 1872 :                             RETAILMSG(TRUE,(TEXT("RemoveElementFromList Failed\n")));

  004b4	e59f04a8	 ldr         r0, [pc, #0x4A8]
  004b8	eb000000	 bl          NKDbgPrintfW
  004bc		 |$LN157@UsbProcess|

; 1873 :                         }
; 1874 :                         m_pProcessEDIn[pED->bHostEndPointNum - 1] = NULL;

  004bc	e5d43010	 ldrb        r3, [r4, #0x10]
  004c0	e0863103	 add         r3, r6, r3, lsl #2
  004c4	e58390c0	 str         r9, [r3, #0xC0]

; 1875 :                         pED->TransferStatus = STATUS_IDLE;

  004c8	e584901c	 str         r9, [r4, #0x1C]
  004cc		 |$LL71@UsbProcess|
  004cc	e5943014	 ldr         r3, [r4, #0x14]
  004d0	e3530000	 cmp         r3, #0
  004d4	1affffd8	 bne         |$redoforsameIsoInED$42074|

; 1564 : 
; 1565 :         if (m_fUsbInterruptThreadClosing)

  004d8	ea00000a	 b           |$LN60@UsbProcess|
  004dc		 |$LN65@UsbProcess|

; 1828 :                 {
; 1829 :                     case STATUS_IDLE:
; 1830 :                         if(!pED->bfSkip){

  004dc	e5d4300c	 ldrb        r3, [r4, #0xC]
  004e0	e3530000	 cmp         r3, #0
  004e4	1a000007	 bne         |$LN60@UsbProcess|

; 1831 :                             if( pED->bSemaphoreOwner == TRUE)

  004e8	e594302c	 ldr         r3, [r4, #0x2C]
  004ec	e3530001	 cmp         r3, #1
  004f0	0a000009	 beq         |$LN207@UsbProcess|

; 1838 : 
; 1839 :                                 //RETAILMSG(FALSE,(TEXT("IN take %d\n"),pED->bHostEndPointNum));
; 1840 :                                 goto IsoInDone;
; 1841 :                             }
; 1842 :                             else if(WaitForSingleObject( pED->hSemaphore, 0 ) == WAIT_OBJECT_0){

  004f4	e5940030	 ldr         r0, [r4, #0x30]
  004f8	e3a01000	 mov         r1, #0
  004fc	eb000000	 bl          WaitForSingleObject
  00500	e3500000	 cmp         r0, #0
  00504	0a000003	 beq         |$LN208@UsbProcess|
  00508		 |$LN60@UsbProcess|

; 1876 :                         goto redoforsameIsoInED;
; 1877 :                 }
; 1878 :             }
; 1879 :             pED = (USBED *)pED->NextED.next;

  00508	e5943000	 ldr         r3, [r4]
  0050c		 |$LN251@UsbProcess|
  0050c	e1b04003	 movs        r4, r3
  00510	1affffed	 bne         |$LL71@UsbProcess|
  00514	ea000005	 b           |$IsoInDone$42086|
  00518		 |$LN208@UsbProcess|

; 1843 :                                 pED->bSemaphoreOwner = TRUE;
; 1844 : 
; 1845 :                                 m_pProcessEDIn[pED->bHostEndPointNum - 1] = (PDWORD)pED;

  00518	e584702c	 str         r7, [r4, #0x2C]
  0051c		 |$LN207@UsbProcess|

; 1832 :                             {
; 1833 :                                 m_pProcessEDIn[pED->bHostEndPointNum - 1] = (PDWORD)pED;

  0051c	e5d43010	 ldrb        r3, [r4, #0x10]
  00520	e0863103	 add         r3, r6, r3, lsl #2
  00524	e58340c0	 str         r4, [r3, #0xC0]

; 1834 :                                 pED->TransferStatus = STATUS_PROGRESS;

  00528	e584701c	 str         r7, [r4, #0x1C]

; 1835 : 
; 1836 :                                 //InitializeTransaction((UINT32)m_portBase, pED, pTD);
; 1837 :                                 pTD->bAwaitingFrame = TRUE;

  0052c	e5857060	 str         r7, [r5, #0x60]

; 1846 :                                 pED->TransferStatus = STATUS_PROGRESS;
; 1847 : 
; 1848 :                                 //InitializeTransaction((UINT32)m_portBase, pED, pTD);
; 1849 :                                 pTD->bAwaitingFrame = TRUE;

  00530		 |$IsoInDone$42086|

; 1880 :         }
; 1881 : IsoInDone: ; // NOP
; 1882 : 
; 1883 :         // See if we have to trigger any ISO transfers
; 1884 : 
; 1885 :         {
; 1886 :             USBED *pIsoOutED = (USBED *)m_pIsoOutHead;

  00530	e59630bc	 ldr         r3, [r6, #0xBC]

; 1887 :             USBED *pIsoInED = (USBED *)m_pIsoInHead;

  00534	e59690b8	 ldr         r9, [r6, #0xB8]

; 1888 :             USBTD *pIsoOutTD = NULL;

  00538	e3a04000	 mov         r4, #0
  0053c	e1b08003	 movs        r8, r3

; 1889 :             USBTD *pIsoInTD = NULL;

  00540	e3a07000	 mov         r7, #0

; 1890 : 
; 1891 :             if (pIsoOutED && pIsoOutED->HeadTD && (pIsoOutED->HeadTD != pIsoOutED->TailTD) &&
; 1892 :                 ((USBTD *)pIsoOutED->HeadTD)->bAwaitingFrame)

  00544	0a000007	 beq         |$LN53@UsbProcess|
  00548	e5983014	 ldr         r3, [r8, #0x14]
  0054c	e1b02003	 movs        r2, r3
  00550	0a000004	 beq         |$LN53@UsbProcess|
  00554	e5983018	 ldr         r3, [r8, #0x18]
  00558	e1520003	 cmp         r2, r3
  0055c	15923060	 ldrne       r3, [r2, #0x60]
  00560	13530000	 cmpne       r3, #0

; 1893 :             {
; 1894 :                 pIsoOutTD = (USBTD *)pIsoOutED->HeadTD;

  00564	11a04002	 movne       r4, r2
  00568		 |$LN53@UsbProcess|

; 1895 :             }
; 1896 : 
; 1897 :             if (pIsoInED && pIsoInED->HeadTD && (pIsoInED->HeadTD != pIsoInED->TailTD) &&
; 1898 :                 ((USBTD *)pIsoInED->HeadTD)->bAwaitingFrame)

  00568	e3590000	 cmp         r9, #0
  0056c	0a000007	 beq         |$LN52@UsbProcess|
  00570	e5993014	 ldr         r3, [r9, #0x14]
  00574	e1b02003	 movs        r2, r3
  00578	0a000004	 beq         |$LN52@UsbProcess|
  0057c	e5993018	 ldr         r3, [r9, #0x18]
  00580	e1520003	 cmp         r2, r3
  00584	15923060	 ldrne       r3, [r2, #0x60]
  00588	13530000	 cmpne       r3, #0

; 1899 :             {
; 1900 :                 pIsoInTD = (USBTD *)pIsoInED->HeadTD;

  0058c	11a07002	 movne       r7, r2
  00590		 |$LN52@UsbProcess|

; 1901 :             }
; 1902 : 
; 1903 :             if (pIsoOutTD || pIsoInTD)

  00590	e3540000	 cmp         r4, #0
  00594	1a000001	 bne         |$LN50@UsbProcess|
  00598	e3570000	 cmp         r7, #0
  0059c	0a00004b	 beq         |$LN51@UsbProcess|
  005a0		 |$LN50@UsbProcess|

; 1904 :             {
; 1905 :                 DWORD dwCurrentFrame;
; 1906 :                 INT32 nDiff;
; 1907 : 
; 1908 :                 GetFrameNumber(&dwCurrentFrame);

  005a0	e5963000	 ldr         r3, [r6]
  005a4	e28d1000	 add         r1, sp, #0
  005a8	e1a00006	 mov         r0, r6
  005ac	e5933014	 ldr         r3, [r3, #0x14]
  005b0	e1a0e00f	 mov         lr, pc
  005b4	e12fff13	 bx          r3

; 1909 : 
; 1910 :                 fEnableSOF = FALSE;
; 1911 : 
; 1912 :                 if (pIsoOutTD)
; 1913 :                 {
; 1914 :                     nDiff = (INT32)(pIsoOutTD->sTransfer.dwStartingFrame - dwCurrentFrame);

  005b8	e59d1000	 ldr         r1, [sp]
  005bc	e3a0b000	 mov         r11, #0
  005c0	e3540000	 cmp         r4, #0
  005c4	0a000021	 beq         |$LN233@UsbProcess|
  005c8	e594201c	 ldr         r2, [r4, #0x1C]
  005cc	e0425001	 sub         r5, r2, r1

; 1915 : 
; 1916 :                     if (nDiff + ISO_MAX_FRAME_ERROR < 0)

  005d0	e2953003	 adds        r3, r5, #3
  005d4	5a000010	 bpl         |$LN46@UsbProcess|

; 1917 :                     {
; 1918 :                         RETAILMSG(1, (L"TX ISO does not meet the schedule! CurFrame %08X, StartFrame %08X\r\n",
; 1919 :                             dwCurrentFrame, pIsoOutTD->sTransfer.dwStartingFrame));

  005d8	e59f038c	 ldr         r0, [pc, #0x38C]
  005dc	eb000000	 bl          NKDbgPrintfW

; 1920 : 
; 1921 :                         // Do not currently fail this, just adjust start frames for subsequent transfers
; 1922 :                         DWORD dwAdjust = dwCurrentFrame - pIsoOutTD->sTransfer.dwStartingFrame;

  005e0	e59d1000	 ldr         r1, [sp]

; 1923 :                         USBTD *pTemp = pIsoOutTD;
; 1924 :                         while (pTemp->NextTD.next != pIsoOutED->TailTD)

  005e4	e5940000	 ldr         r0, [r4]
  005e8	e594301c	 ldr         r3, [r4, #0x1C]
  005ec	e5982018	 ldr         r2, [r8, #0x18]
  005f0	e0413003	 sub         r3, r1, r3
  005f4	e1500002	 cmp         r0, r2
  005f8	0a000007	 beq         |$LN46@UsbProcess|
  005fc		 |$LL47@UsbProcess|

; 1925 :                         {
; 1926 :                             pTemp = (USBTD *)pTemp->NextTD.next;
; 1927 :                             pTemp->sTransfer.dwStartingFrame += dwAdjust;

  005fc	e590201c	 ldr         r2, [r0, #0x1C]
  00600	e0832002	 add         r2, r3, r2
  00604	e580201c	 str         r2, [r0, #0x1C]
  00608	e5900000	 ldr         r0, [r0]
  0060c	e5982018	 ldr         r2, [r8, #0x18]
  00610	e1500002	 cmp         r0, r2
  00614	1afffff8	 bne         |$LL47@UsbProcess|

; 1923 :                         USBTD *pTemp = pIsoOutTD;
; 1924 :                         while (pTemp->NextTD.next != pIsoOutED->TailTD)

  00618	e59d1000	 ldr         r1, [sp]
  0061c		 |$LN46@UsbProcess|

; 1928 :                         }
; 1929 :                     }
; 1930 : 
; 1931 :                     if (nDiff <= 0)

  0061c	e3550000	 cmp         r5, #0

; 1932 :                     {
; 1933 :                         pIsoOutTD->bAwaitingFrame = FALSE;

  00620	e3a0a000	 mov         r10, #0
  00624	ca000007	 bgt         |$LN45@UsbProcess|
  00628	e584a060	 str         r10, [r4, #0x60]

; 1934 :                         InitializeTransaction((UINT32)m_portBase, pIsoOutED, pIsoOutTD);

  0062c	e5961140	 ldr         r1, [r6, #0x140]
  00630	e1a03004	 mov         r3, r4
  00634	e1a02008	 mov         r2, r8
  00638	e1a00006	 mov         r0, r6
  0063c	eb000000	 bl          |?InitializeTransaction@CHW@@QAAXIPAX0@Z|

; 1935 :                     }
; 1936 :                     else

  00640	e59d1000	 ldr         r1, [sp]
  00644	ea000002	 b           |$LN44@UsbProcess|
  00648		 |$LN45@UsbProcess|

; 1937 :                     {
; 1938 :                         fEnableSOF = TRUE;

  00648	e3a0b001	 mov         r11, #1
  0064c	ea000000	 b           |$LN44@UsbProcess|
  00650		 |$LN233@UsbProcess|
  00650	e3a0a000	 mov         r10, #0
  00654		 |$LN44@UsbProcess|

; 1939 :                     }
; 1940 :                 }
; 1941 : 
; 1942 :                 if (pIsoInTD)

  00654	e3570000	 cmp         r7, #0
  00658	0a00001b	 beq         |$LN38@UsbProcess|

; 1943 :                 {
; 1944 :                     nDiff = (INT32)(pIsoInTD->sTransfer.dwStartingFrame - dwCurrentFrame);

  0065c	e597201c	 ldr         r2, [r7, #0x1C]
  00660	e0425001	 sub         r5, r2, r1

; 1945 : 
; 1946 :                     if (nDiff + ISO_MAX_FRAME_ERROR < 0)

  00664	e2953003	 adds        r3, r5, #3
  00668	5a00000d	 bpl         |$LN40@UsbProcess|

; 1947 :                     {
; 1948 :                         RETAILMSG(1, (L"RX ISO does not meet the schedule! CurFrame %08X, StartFrame %08X\r\n",
; 1949 :                             dwCurrentFrame, pIsoInTD->sTransfer.dwStartingFrame));

  0066c	e59f02f4	 ldr         r0, [pc, #0x2F4]
  00670	eb000000	 bl          NKDbgPrintfW

; 1950 : 
; 1951 :                         // Do not currently fail this, just adjust start frames for subsequent transfers
; 1952 :                         DWORD dwAdjust = dwCurrentFrame - pIsoInTD->sTransfer.dwStartingFrame;

  00674	e597e01c	 ldr         lr, [r7, #0x1C]
  00678	e59d0000	 ldr         r0, [sp]

; 1953 :                         USBTD *pTemp = pIsoInTD;
; 1954 :                         while (pTemp->NextTD.next != pIsoInED->TailTD)

  0067c	e5974000	 ldr         r4, [r7]
  00680	e040000e	 sub         r0, r0, lr
  00684	ea000003	 b           |$LN254@UsbProcess|
  00688		 |$LL41@UsbProcess|

; 1955 :                         {
; 1956 :                             pTemp = (USBTD *)pTemp->NextTD.next;
; 1957 :                             pTemp->sTransfer.dwStartingFrame += dwAdjust;

  00688	e594101c	 ldr         r1, [r4, #0x1C]
  0068c	e0811000	 add         r1, r1, r0
  00690	e584101c	 str         r1, [r4, #0x1C]
  00694	e5944000	 ldr         r4, [r4]
  00698		 |$LN254@UsbProcess|
  00698	e5991018	 ldr         r1, [r9, #0x18]
  0069c	e1540001	 cmp         r4, r1
  006a0	1afffff8	 bne         |$LL41@UsbProcess|
  006a4		 |$LN40@UsbProcess|

; 1958 :                         }
; 1959 :                     }
; 1960 : 
; 1961 :                     if (nDiff <= 0)

  006a4	e3550000	 cmp         r5, #0
  006a8	ca000006	 bgt         |$LN39@UsbProcess|

; 1962 :                     {
; 1963 :                         pIsoInTD->bAwaitingFrame = FALSE;

  006ac	e587a060	 str         r10, [r7, #0x60]

; 1964 :                         InitializeTransaction((UINT32)m_portBase, pIsoInED, pIsoInTD);

  006b0	e5961140	 ldr         r1, [r6, #0x140]
  006b4	e1a03007	 mov         r3, r7
  006b8	e1a02009	 mov         r2, r9
  006bc	e1a00006	 mov         r0, r6
  006c0	eb000000	 bl          |?InitializeTransaction@CHW@@QAAXIPAX0@Z|

; 1965 :                     }
; 1966 :                     else

  006c4	ea000000	 b           |$LN38@UsbProcess|
  006c8		 |$LN39@UsbProcess|

; 1967 :                     {
; 1968 :                         fEnableSOF = TRUE;

  006c8	e3a0b001	 mov         r11, #1
  006cc		 |$LN38@UsbProcess|

; 1969 :                     }
; 1970 :                 }
; 1971 : 
; 1972 :                 fEnableSOFStateChanged = TRUE;

  006cc	e3a0a001	 mov         r10, #1
  006d0		 |$LN51@UsbProcess|

; 1973 :             }
; 1974 :         }
; 1975 : 
; 1976 : #endif // MUSB_USEDMA_FOR_ISO
; 1977 : #endif // MUSB_USEDMA
; 1978 : 
; 1979 :         ///////////////////////////////////////////////////////////////////////////
; 1980 :         // Bulk (out) requests
; 1981 : 
; 1982 :         pED = (USBED*)m_pBulkOutHead;

  006d0	e59630ac	 ldr         r3, [r6, #0xAC]
  006d4	e1b04003	 movs        r4, r3

; 1983 :         while(pED) {

  006d8	1a000025	 bne         |$LL37@UsbProcess|
  006dc		 |$LN239@UsbProcess|

; 2034 :         }
; 2035 : bulkoutdone: ; // NOP
; 2036 : 
; 2037 : 
; 2038 :         ///////////////////////////////////////////////////////////////////////////
; 2039 :         // Bulk (in) requests
; 2040 : 
; 2041 :         pED = (USBED*)m_pBulkInHead;

  006dc	e59630a8	 ldr         r3, [r6, #0xA8]
  006e0	e3a07001	 mov         r7, #1
  006e4		 |$bulkoutdone$42161|
  006e4	ea000077	 b           |$LN257@UsbProcess|
  006e8		 |$redoforsameOUTED$42149|

; 1984 : redoforsameOUTED:
; 1985 : 
; 1986 :             if(pED->HeadTD && (pED->HeadTD != pED->TailTD)){

  006e8	e5945014	 ldr         r5, [r4, #0x14]
  006ec	e5943018	 ldr         r3, [r4, #0x18]
  006f0	e1550003	 cmp         r5, r3
  006f4	0a00002d	 beq         |$LN27@UsbProcess|

; 1987 :                 pTD = (USBTD *)pED->HeadTD;
; 1988 :                 switch(pED->TransferStatus){

  006f8	e594301c	 ldr         r3, [r4, #0x1C]
  006fc	e3530000	 cmp         r3, #0
  00700	0a00001f	 beq         |$LN32@UsbProcess|
  00704	e3530002	 cmp         r3, #2
  00708	1a000028	 bne         |$LN27@UsbProcess|

; 2006 :                             RETAILMSG(FALSE,(TEXT("OUT take %d\n"),pED->bHostEndPointNum));
; 2007 :                             goto bulkoutdone;
; 2008 :                         }
; 2009 :                     }
; 2010 :                     break;
; 2011 :                 case STATUS_PROGRESS:
; 2012 :                     break;
; 2013 :                 case STATUS_COMPLETE:
; 2014 :                     if(RemoveElementFromList((ListHead**)&pED->HeadTD, (ListHead*)pTD)){

  0070c	e1a01005	 mov         r1, r5
  00710	e2840014	 add         r0, r4, #0x14
  00714	eb000000	 bl          |?RemoveElementFromList@@YAHPAPAUListHead@@PAU1@@Z|
  00718	e3500000	 cmp         r0, #0
  0071c	0a00000d	 beq         |$LN23@UsbProcess|

; 2015 :                         BULKTCMSG(1, (L"TC: EP%d BULK OUT, len %d", pED->bHostEndPointNum, pTD->BytesTransferred));
; 2016 :                         if (pTD->sTransfer.lpfnCallback)

  00720	e5953008	 ldr         r3, [r5, #8]
  00724	e3530000	 cmp         r3, #0

; 2017 :                         {
; 2018 :                             ( *pTD->sTransfer.lpfnCallback )( pTD->sTransfer.lpvCallbackParameter );

  00728	1595000c	 ldrne       r0, [r5, #0xC]
  0072c	11a0e00f	 movne       lr, pc
  00730	112fff13	 bxne        r3

; 2019 :                         }
; 2020 :                         FreeTD(pTD);

  00734	e1a00005	 mov         r0, r5
  00738	eb000000	 bl          |?FreeTD@@YAXPAU_USBTD@@@Z|

; 2021 :                         ReleaseSemaphore(pED->hSemaphore, 1, NULL );

  0073c	e5940030	 ldr         r0, [r4, #0x30]
  00740	e3a02000	 mov         r2, #0
  00744	e3a01001	 mov         r1, #1
  00748	eb000000	 bl          ReleaseSemaphore

; 2022 :                         pED->bSemaphoreOwner = FALSE;

  0074c	e3a02000	 mov         r2, #0
  00750	e584202c	 str         r2, [r4, #0x2C]

; 2023 :                         RETAILMSG(FALSE,(TEXT("OUT give %d\n"),pED->bHostEndPointNum));
; 2024 :                     }
; 2025 :                     else{

  00754	ea000002	 b           |$LN167@UsbProcess|
  00758		 |$LN23@UsbProcess|

; 2026 :                         RETAILMSG(TRUE,(TEXT("RemoveElementFromList Failed\n")));

  00758	e59f0204	 ldr         r0, [pc, #0x204]
  0075c	eb000000	 bl          NKDbgPrintfW
  00760	e3a02000	 mov         r2, #0
  00764		 |$LN167@UsbProcess|

; 2027 :                     }
; 2028 :                     m_pProcessEDOut[pED->bHostEndPointNum - 1] = NULL;

  00764	e5d43010	 ldrb        r3, [r4, #0x10]
  00768	e0863103	 add         r3, r6, r3, lsl #2
  0076c	e58320fc	 str         r2, [r3, #0xFC]

; 2029 :                     pED->TransferStatus = STATUS_IDLE;

  00770	e584201c	 str         r2, [r4, #0x1C]
  00774		 |$LL37@UsbProcess|
  00774	e5943014	 ldr         r3, [r4, #0x14]
  00778	e3530000	 cmp         r3, #0
  0077c	1affffd9	 bne         |$redoforsameOUTED$42149|

; 1564 : 
; 1565 :         if (m_fUsbInterruptThreadClosing)

  00780	ea00000a	 b           |$LN27@UsbProcess|
  00784		 |$LN32@UsbProcess|

; 1989 :                 case STATUS_IDLE:
; 1990 :                     if(!pED->bfSkip){

  00784	e5d4300c	 ldrb        r3, [r4, #0xC]
  00788	e3530000	 cmp         r3, #0
  0078c	1a000007	 bne         |$LN27@UsbProcess|

; 1991 :                         if( pED->bSemaphoreOwner == TRUE)

  00790	e594302c	 ldr         r3, [r4, #0x2C]
  00794	e3530001	 cmp         r3, #1
  00798	0a00000b	 beq         |$LN210@UsbProcess|

; 1997 :                             //RETAILMSG(FALSE,(TEXT("OUT take %d\n"),pED->bHostEndPointNum));
; 1998 :                             goto bulkoutdone;
; 1999 :                         }
; 2000 :                         else if(WaitForSingleObject( pED->hSemaphore, 0 ) == WAIT_OBJECT_0){

  0079c	e5940030	 ldr         r0, [r4, #0x30]
  007a0	e3a01000	 mov         r1, #0
  007a4	eb000000	 bl          WaitForSingleObject
  007a8	e3500000	 cmp         r0, #0
  007ac	0a000003	 beq         |$LN211@UsbProcess|
  007b0		 |$LN27@UsbProcess|

; 2030 :                     goto redoforsameOUTED;
; 2031 :                 }
; 2032 :             }
; 2033 :             pED = (USBED *)pED->NextED.next;

  007b0	e5943000	 ldr         r3, [r4]
  007b4	e1b04003	 movs        r4, r3
  007b8	1affffed	 bne         |$LL37@UsbProcess|
  007bc	eaffffc6	 b           |$LN239@UsbProcess|
  007c0		 |$LN211@UsbProcess|

; 2001 :                             pED->bSemaphoreOwner = TRUE;
; 2002 :                             m_pProcessEDOut[pED->bHostEndPointNum - 1] = (PDWORD)pED;

  007c0	e3a07001	 mov         r7, #1
  007c4	e584702c	 str         r7, [r4, #0x2C]

; 2003 :                             pED->TransferStatus = STATUS_PROGRESS;
; 2004 : 
; 2005 :                             InitializeTransaction((UINT32)m_portBase, pED, pTD);

  007c8	ea000000	 b           |$LN260@UsbProcess|
  007cc		 |$LN210@UsbProcess|

; 1994 :                             pED->TransferStatus = STATUS_PROGRESS;
; 1995 : 
; 1996 :                             InitializeTransaction((UINT32)m_portBase, pED, pTD);

  007cc	e3a07001	 mov         r7, #1
  007d0		 |$LN260@UsbProcess|

; 1992 :                         {
; 1993 :                             m_pProcessEDOut[pED->bHostEndPointNum - 1] = (PDWORD)pED;

  007d0	e5d41010	 ldrb        r1, [r4, #0x10]

; 1994 :                             pED->TransferStatus = STATUS_PROGRESS;
; 1995 : 
; 1996 :                             InitializeTransaction((UINT32)m_portBase, pED, pTD);

  007d4	e1a02004	 mov         r2, r4
  007d8	e1a03005	 mov         r3, r5
  007dc	e0861101	 add         r1, r6, r1, lsl #2
  007e0	e58140fc	 str         r4, [r1, #0xFC]
  007e4	e584701c	 str         r7, [r4, #0x1C]
  007e8	e5961140	 ldr         r1, [r6, #0x140]
  007ec	e1a00006	 mov         r0, r6
  007f0	eb000000	 bl          |?InitializeTransaction@CHW@@QAAXIPAX0@Z|

; 2034 :         }
; 2035 : bulkoutdone: ; // NOP
; 2036 : 
; 2037 : 
; 2038 :         ///////////////////////////////////////////////////////////////////////////
; 2039 :         // Bulk (in) requests
; 2040 : 
; 2041 :         pED = (USBED*)m_pBulkInHead;

  007f4	e59630a8	 ldr         r3, [r6, #0xA8]
  007f8	ea000032	 b           |$LN257@UsbProcess|
  007fc		 |$redoforsameINED$42181|

; 2042 :         while(pED) {
; 2043 : redoforsameINED:
; 2044 : 
; 2045 :             if(pED->HeadTD && (pED->HeadTD != pED->TailTD)){

  007fc	e5945014	 ldr         r5, [r4, #0x14]
  00800	e5943018	 ldr         r3, [r4, #0x18]
  00804	e1550003	 cmp         r5, r3
  00808	0a00002d	 beq         |$LN10@UsbProcess|

; 2046 :                 pTD = (USBTD *)pED->HeadTD;
; 2047 :                 switch(pED->TransferStatus){

  0080c	e594301c	 ldr         r3, [r4, #0x1C]
  00810	e3530000	 cmp         r3, #0
  00814	0a00001f	 beq         |$LN15@UsbProcess|
  00818	e3530002	 cmp         r3, #2
  0081c	1a000028	 bne         |$LN10@UsbProcess|

; 2065 :                             RETAILMSG(FALSE,(TEXT("IN take %d\n"),pED->bHostEndPointNum));
; 2066 :                             goto bulkindone;
; 2067 :                         }
; 2068 :                     }
; 2069 :                     break;
; 2070 :                 case STATUS_PROGRESS:
; 2071 :                     break;
; 2072 :                 case STATUS_COMPLETE:
; 2073 :                     if(RemoveElementFromList((ListHead**)&pED->HeadTD, (ListHead*)pTD)){

  00820	e1a01005	 mov         r1, r5
  00824	e2840014	 add         r0, r4, #0x14
  00828	eb000000	 bl          |?RemoveElementFromList@@YAHPAPAUListHead@@PAU1@@Z|
  0082c	e3500000	 cmp         r0, #0
  00830	0a00000d	 beq         |$LN6@UsbProcess|

; 2074 :                         BULKTCMSG(1, (L"TC: EP%d BULK IN, len %d", pED->bHostEndPointNum, pTD->BytesTransferred));
; 2075 :                         if (pTD->sTransfer.lpfnCallback)

  00834	e5953008	 ldr         r3, [r5, #8]
  00838	e3530000	 cmp         r3, #0

; 2076 :                         {
; 2077 :                             ( *pTD->sTransfer.lpfnCallback )( pTD->sTransfer.lpvCallbackParameter );

  0083c	1595000c	 ldrne       r0, [r5, #0xC]
  00840	11a0e00f	 movne       lr, pc
  00844	112fff13	 bxne        r3

; 2078 :                         }
; 2079 :                         FreeTD(pTD);

  00848	e1a00005	 mov         r0, r5
  0084c	eb000000	 bl          |?FreeTD@@YAXPAU_USBTD@@@Z|

; 2080 :                         ReleaseSemaphore(pED->hSemaphore, 1, NULL );

  00850	e5940030	 ldr         r0, [r4, #0x30]
  00854	e3a02000	 mov         r2, #0
  00858	e3a01001	 mov         r1, #1
  0085c	eb000000	 bl          ReleaseSemaphore

; 2081 :                         pED->bSemaphoreOwner = FALSE;

  00860	e3a02000	 mov         r2, #0
  00864	e584202c	 str         r2, [r4, #0x2C]

; 2082 :                         RETAILMSG(FALSE,(TEXT("IN give %d\n"),pED->bHostEndPointNum));
; 2083 :                     }
; 2084 :                     else{

  00868	ea000002	 b           |$LN173@UsbProcess|
  0086c		 |$LN6@UsbProcess|

; 2085 :                         RETAILMSG(TRUE,(TEXT("RemoveElementFromList Failed\n")));

  0086c	e59f00f0	 ldr         r0, [pc, #0xF0]
  00870	eb000000	 bl          NKDbgPrintfW
  00874	e3a02000	 mov         r2, #0
  00878		 |$LN173@UsbProcess|

; 2086 :                     }
; 2087 :                     m_pProcessEDIn[pED->bHostEndPointNum - 1] = NULL;

  00878	e5d43010	 ldrb        r3, [r4, #0x10]
  0087c	e0863103	 add         r3, r6, r3, lsl #2
  00880	e58320c0	 str         r2, [r3, #0xC0]

; 2088 :                     pED->TransferStatus = STATUS_IDLE;

  00884	e584201c	 str         r2, [r4, #0x1C]
  00888		 |$LL20@UsbProcess|
  00888	e5943014	 ldr         r3, [r4, #0x14]
  0088c	e3530000	 cmp         r3, #0
  00890	1affffd9	 bne         |$redoforsameINED$42181|

; 1564 : 
; 1565 :         if (m_fUsbInterruptThreadClosing)

  00894	ea00000a	 b           |$LN10@UsbProcess|
  00898		 |$LN15@UsbProcess|

; 2048 :                 case STATUS_IDLE:
; 2049 :                     if(!pED->bfSkip){

  00898	e5d4300c	 ldrb        r3, [r4, #0xC]
  0089c	e3530000	 cmp         r3, #0
  008a0	1a000007	 bne         |$LN10@UsbProcess|

; 2050 :                         if( pED->bSemaphoreOwner == TRUE)

  008a4	e594302c	 ldr         r3, [r4, #0x2C]
  008a8	e3530001	 cmp         r3, #1
  008ac	0a000009	 beq         |$LN213@UsbProcess|

; 2056 :                             //RETAILMSG(FALSE,(TEXT("IN take %d\n"),pED->bHostEndPointNum));
; 2057 :                             goto bulkindone;
; 2058 :                         }
; 2059 :                         else if(WaitForSingleObject( pED->hSemaphore, 0 ) == WAIT_OBJECT_0){

  008b0	e5940030	 ldr         r0, [r4, #0x30]
  008b4	e3a01000	 mov         r1, #0
  008b8	eb000000	 bl          WaitForSingleObject
  008bc	e3500000	 cmp         r0, #0
  008c0	0a000003	 beq         |$LN214@UsbProcess|
  008c4		 |$LN10@UsbProcess|

; 2089 :                     goto redoforsameINED;
; 2090 :                 }
; 2091 :             }
; 2092 :             pED = (USBED *)pED->NextED.next;

  008c4	e5943000	 ldr         r3, [r4]
  008c8		 |$LN257@UsbProcess|
  008c8	e1b04003	 movs        r4, r3
  008cc	1affffed	 bne         |$LL20@UsbProcess|
  008d0	ea000009	 b           |$bulkindone$42193|
  008d4		 |$LN214@UsbProcess|

; 2060 :                             pED->bSemaphoreOwner = TRUE;
; 2061 :                             m_pProcessEDIn[pED->bHostEndPointNum - 1] = (PDWORD)pED;

  008d4	e584702c	 str         r7, [r4, #0x2C]
  008d8		 |$LN213@UsbProcess|

; 2051 :                         {
; 2052 :                             m_pProcessEDIn[pED->bHostEndPointNum - 1] = (PDWORD)pED;

  008d8	e5d41010	 ldrb        r1, [r4, #0x10]

; 2053 :                             pED->TransferStatus = STATUS_PROGRESS;
; 2054 : 
; 2055 :                             InitializeTransaction((UINT32)m_portBase, pED, pTD);

  008dc	e1a03005	 mov         r3, r5
  008e0	e1a02004	 mov         r2, r4
  008e4	e0861101	 add         r1, r6, r1, lsl #2
  008e8	e58140c0	 str         r4, [r1, #0xC0]
  008ec	e584701c	 str         r7, [r4, #0x1C]
  008f0	e5961140	 ldr         r1, [r6, #0x140]
  008f4	e1a00006	 mov         r0, r6
  008f8	eb000000	 bl          |?InitializeTransaction@CHW@@QAAXIPAX0@Z|

; 2062 :                             pED->TransferStatus = STATUS_PROGRESS;
; 2063 : 
; 2064 :                             InitializeTransaction((UINT32)m_portBase, pED, pTD);

  008fc		 |$bulkindone$42193|

; 2093 :         }
; 2094 : bulkindone: ; // NOP
; 2095 : 
; 2096 : 
; 2097 : #ifdef MUSB_USEDMA
; 2098 : #ifdef MUSB_USEDMA_FOR_ISO
; 2099 : 
; 2100 :         // Enable or disable SOF interrupts
; 2101 : 
; 2102 :         if (fEnableSOFStateChanged)

  008fc	e35a0000	 cmp         r10, #0
  00900	0a000004	 beq         |$LN1@UsbProcess|

; 2103 :         {
; 2104 :             if (fEnableSOF)
; 2105 :             {
; 2106 :                 WRITE_PORT_ULONG( (m_portBase+USB_CORE_INTMSKSETR_REG_OFFSET),
; 2107 :                                   (CSL_USB_INTRUSB_SOF_MASK << CSL_USB_INTMSKR_USB_SHIFT) );

  00904	e5963140	 ldr         r3, [r6, #0x140]
  00908	e35b0000	 cmp         r11, #0
  0090c	e3a02702	 mov         r2, #2, 14
  00910	15832050	 strne       r2, [r3, #0x50]

; 2108 :             }
; 2109 :             else
; 2110 :             {
; 2111 :                 WRITE_PORT_ULONG( (m_portBase+USB_CORE_INTMSKCLRR_REG_OFFSET),
; 2112 :                                   (CSL_USB_INTRUSB_SOF_MASK << CSL_USB_INTMSKR_USB_SHIFT) );

  00914	05832054	 streq       r2, [r3, #0x54]
  00918		 |$LN1@UsbProcess|

; 2113 :             }
; 2114 :         }
; 2115 : 
; 2116 : #endif // MUSB_USEDMA_FOR_ISO
; 2117 : #endif // MUSB_USEDMA
; 2118 : 
; 2119 :         UnlockProcessingThread();

  00918	e2860f89	 add         r0, r6, #0x89, 30
  0091c	eb000000	 bl          LeaveCriticalSection
  00920	e59d5004	 ldr         r5, [sp, #4]
  00924	e59d7008	 ldr         r7, [sp, #8]
  00928	e59d800c	 ldr         r8, [sp, #0xC]
  0092c	e3a09000	 mov         r9, #0
  00930		 |$LN232@UsbProcess|
  00930	e59f3028	 ldr         r3, [pc, #0x28]
  00934	e3a01ffa	 mov         r1, #0xFA, 30
  00938	e5930000	 ldr         r0, [r3]
  0093c	eb000000	 bl          WaitForSingleObject
  00940	e5963180	 ldr         r3, [r6, #0x180]
  00944	e1a04000	 mov         r4, r0
  00948	e3530000	 cmp         r3, #0
  0094c	0afffdc0	 beq         |$LL133@UsbProcess|
  00950		 |$LN215@UsbProcess|

; 2120 : 
; 2121 :     }
; 2122 : 
; 2123 :     return 0;

  00950	e3a00000	 mov         r0, #0

; 2124 : }

  00954	e28dd010	 add         sp, sp, #0x10
  00958	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0095c	e12fff1e	 bx          lr
  00960		 |$LN264@UsbProcess|
  00960		 |$LN265@UsbProcess|
  00960	00000000	 DCD         |?g_hUsbProcessingEvent@@3PAXA|
  00964		 |$LN266@UsbProcess|
  00964	00000000	 DCD         |??_C@_1DM@OAANCGDM@?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AAE?$AAl?$AAe?$AAm?$AAe?$AAn?$AAt?$AAF?$AAr?$AAo?$AAm?$AAL?$AAi?$AAs?$AAt?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?6?$AA?$AA@|
  00968		 |$LN267@UsbProcess|
  00968	00000000	 DCD         |??_C@_1II@LBNMOOPF@?$AAR?$AAX?$AA?5?$AAI?$AAS?$AAO?$AA?5?$AAd?$AAo?$AAe?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAm?$AAe?$AAe?$AAt?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAs?$AAc?$AAh?$AAe?$AAd?$AAu?$AAl@|
  0096c		 |$LN268@UsbProcess|
  0096c	00000000	 DCD         |??_C@_1II@DCFKBPOJ@?$AAT?$AAX?$AA?5?$AAI?$AAS?$AAO?$AA?5?$AAd?$AAo?$AAe?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAm?$AAe?$AAe?$AAt?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAs?$AAc?$AAh?$AAe?$AAd?$AAu?$AAl@|
  00970		 |$M43710|

			 ENDP  ; |?UsbProcessingThread@CHW@@AAAKXZ|, CHW::UsbProcessingThread

	EXPORT	|?CeResumeThreadStub@CHW@@CAKPAX@Z|	; CHW::CeResumeThreadStub

  00000			 AREA	 |.pdata|, PDATA
|$T43727| DCD	|$LN5@CeResumeTh@2|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CeResumeThreadStub@CHW@@CAKPAX@Z| PROC ; CHW::CeResumeThreadStub

; 3011 : {

  00000		 |$LN5@CeResumeTh@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43724|

; 3012 :     return ((CHW *)context)->CeResumeThread ( );

  00004	eb000000	 bl          |?CeResumeThread@CHW@@AAAKXZ|

; 3013 : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M43725|

			 ENDP  ; |?CeResumeThreadStub@CHW@@CAKPAX@Z|, CHW::CeResumeThreadStub

	IMPORT	|??3@YAXPAX@Z|				; operator delete

  00000			 AREA	 |.pdata|, PDATA
|$T43738| DCD	|$LN6@scalar|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GCHW@@UAAPAXI@Z| PROC		; CHW::`scalar deleting destructor'
  00000		 |$LN6@scalar|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43735|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          |??1CHW@@UAA@XZ|
  00010	e3140001	 tst         r4, #1
  00014	11a00005	 movne       r0, r5
  00018	1b000000	 blne        |??3@YAXPAX@Z|
  0001c	e1a00005	 mov         r0, r5
  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M43736|

			 ENDP  ; |??_GCHW@@UAAPAXI@Z|, CHW::`scalar deleting destructor'

	EXPORT	|?UsbInterruptThread@CHW@@AAAKPAX@Z|	; CHW::UsbInterruptThread
	EXPORT	|??_C@_1II@MCJCLEKF@?$AAC?$AAH?$AAW?$AA?3?$AA?3?$AAU?$AAs?$AAb?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?3?$AA?5?$AAC?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GG@KJEIHILO@?$AAU?$AAS?$AAB?$AAH?$AA?3?$AA?5?$AAV?$AAB?$AAU?$AAS?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAd?$AAe?$AAt?$AAe?$AAc?$AAt?$AAe?$AAd?$AA?5?$AA?9?$AA?5?$AAr?$AAe?$AAs?$AAe@| [ DATA ] ; `string'
	IMPORT	|?OnCompletionEvent@CCppiDmaController@@IAAXXZ| ; CCppiDmaController::OnCompletionEvent
	IMPORT	|InterruptDone|
	IMPORT	|CeSetThreadPriority|
	IMPORT	|g_IstThreadPriority|
	IMPORT	|CreateThread|
	IMPORT	|HcdPdd_InitiatePowerUp|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T43871| DCD	|$LN169@UsbInterru|
	DCD	0x40021c02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1II@MCJCLEKF@?$AAC?$AAH?$AAW?$AA?3?$AA?3?$AAU?$AAs?$AAb?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?3?$AA?5?$AAC?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5@| DCB "C"
	DCB	0x0, "H", 0x0, "W", 0x0, ":", 0x0, ":", 0x0, "U", 0x0, "s"
	DCB	0x0, "b", 0x0, "I", 0x0, "n", 0x0, "t", 0x0, "e", 0x0, "r"
	DCB	0x0, "r", 0x0, "u", 0x0, "p", 0x0, "t", 0x0, "T", 0x0, "h"
	DCB	0x0, "r", 0x0, "e", 0x0, "a", 0x0, "d", 0x0, ":", 0x0, " "
	DCB	0x0, "C", 0x0, "a", 0x0, "n", 0x0, "n", 0x0, "o", 0x0, "t"
	DCB	0x0, " ", 0x0, "s", 0x0, "t", 0x0, "a", 0x0, "r", 0x0, "t"
	DCB	0x0, " ", 0x0, "t", 0x0, "h", 0x0, "r", 0x0, "e", 0x0, "a"
	DCB	0x0, "d", 0x0, " ", 0x0, "f", 0x0, "o", 0x0, "r", 0x0, " "
	DCB	0x0, "r", 0x0, "e", 0x0, "s", 0x0, "u", 0x0, "m", 0x0, "e"
	DCB	0x0, ";", 0x0, " ", 0x0, "s", 0x0, "l", 0x0, "e", 0x0, "e"
	DCB	0x0, "p", 0x0, "i", 0x0, "n", 0x0, "g", 0x0, ".", 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GG@KJEIHILO@?$AAU?$AAS?$AAB?$AAH?$AA?3?$AA?5?$AAV?$AAB?$AAU?$AAS?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAd?$AAe?$AAt?$AAe?$AAc?$AAt?$AAe?$AAd?$AA?5?$AA?9?$AA?5?$AAr?$AAe?$AAs?$AAe@| DCB "U"
	DCB	0x0, "S", 0x0, "B", 0x0, "H", 0x0, ":", 0x0, " ", 0x0, "V"
	DCB	0x0, "B", 0x0, "U", 0x0, "S", 0x0, " ", 0x0, "e", 0x0, "r"
	DCB	0x0, "r", 0x0, "o", 0x0, "r", 0x0, " ", 0x0, "d", 0x0, "e"
	DCB	0x0, "t", 0x0, "e", 0x0, "c", 0x0, "t", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "-", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "s"
	DCB	0x0, "e", 0x0, "t", 0x0, "t", 0x0, "i", 0x0, "n", 0x0, "g"
	DCB	0x0, " ", 0x0, "c", 0x0, "o", 0x0, "n", 0x0, "t", 0x0, "r"
	DCB	0x0, "o", 0x0, "l", 0x0, "l", 0x0, "e", 0x0, "r", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\am3517\usb\usbh\chw.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UsbInterruptThread@CHW@@AAAKPAX@Z| PROC ; CHW::UsbInterruptThread

; 665  : {

  00000		 |$LN169@UsbInterru|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M43868|
  00008	e1a04000	 mov         r4, r0

; 666  :     UINT16 IntrUsbValue;
; 667  :     UINT8  IntrTxValue;
; 668  :     UINT8  IntrRxValue;
; 669  :     DWORD  CoreIntStatus;
; 670  : 	DWORD  EpIntStatus;
; 671  :     UINT16 _HOST_CSR0, _HOST_RXCSR, _HOST_TXCSR, _RXCOUNT, _COUNT0;
; 672  :     DWORD CopyCount;
; 673  :     UINT8 *pPkt, *pData, RequestType, Reg, bShift;
; 674  :     USBTD *pTD;
; 675  :     USBED *pED;
; 676  : 
; 677  : 	UNREFERENCED_PARAMETER(context);
; 678  : 
; 679  :     DEBUGMSG(ZONE_INIT && ZONE_VERBOSE, (TEXT("+CHW::USBInterruptThread\n\r")));
; 680  : 
; 681  :     while ( !m_fUsbInterruptThreadClosing ) {

  0000c	e5943180	 ldr         r3, [r4, #0x180]
  00010	e3a09000	 mov         r9, #0
  00014	e3530000	 cmp         r3, #0
  00018	1a000032	 bne         |$LN144@UsbInterru|
  0001c	e3a03cff	 mov         r3, #0xFF, 24
  00020	e38370fb	 orr         r7, r3, #0xFB
  00024	e383a0fe	 orr         r10, r3, #0xFE
  00028	e3a03cff	 mov         r3, #0xFF, 24
  0002c	e38380ef	 orr         r8, r3, #0xEF
  00030	e58d8014	 str         r8, [sp, #0x14]
  00034	e58d7010	 str         r7, [sp, #0x10]
  00038	e58da00c	 str         r10, [sp, #0xC]
  0003c		 |$LL89@UsbInterru|

; 682  : 
; 683  :         WaitForSingleObject(m_hUsbInterruptEvent, INFINITE);

  0003c	e5940170	 ldr         r0, [r4, #0x170]
  00040	e3e01000	 mvn         r1, #0
  00044	eb000000	 bl          WaitForSingleObject

; 684  :         
; 685  :         if ( m_fUsbInterruptThreadClosing ) {

  00048	e5943180	 ldr         r3, [r4, #0x180]
  0004c	e3530000	 cmp         r3, #0
  00050	1a000024	 bne         |$LN144@UsbInterru|

; 686  :             break;
; 687  :         }
; 688  : 
; 689  :         // Power management handling.
; 690  :         // This flag gets cleared in the resume thread.
; 691  :         if(m_fPowerUpFlag)

  00054	e594318c	 ldr         r3, [r4, #0x18C]
  00058	e3530000	 cmp         r3, #0
  0005c	0a000034	 beq         |$LN86@UsbInterru|

; 692  :         {
; 693  :             if (m_fPowerResuming) {

  00060	e5943190	 ldr         r3, [r4, #0x190]
  00064	e3530000	 cmp         r3, #0
  00068	1a0001f7	 bne         |$LN142@UsbInterru|

; 694  :                 // this means we've restarted an IST and it's taken an early interrupt;
; 695  :                 // just pretend it didn't happen for now because we're about to be told to exit again.
; 696  :                 continue;
; 697  :             }
; 698  :             HcdPdd_InitiatePowerUp((DWORD) m_pPddContext);

  0006c	e5940188	 ldr         r0, [r4, #0x188]
  00070	eb000000	 bl          HcdPdd_InitiatePowerUp

; 699  :             HANDLE ht;
; 700  : 
; 701  :             while ((ht = CreateThread(NULL, 0, CeResumeThreadStub, this, 0, NULL)) == NULL) {

  00074	e59f27ec	 ldr         r2, [pc, #0x7EC]
  00078	e1a03004	 mov         r3, r4
  0007c	e3a01000	 mov         r1, #0
  00080	e3a00000	 mov         r0, #0
  00084	e58d9004	 str         r9, [sp, #4]
  00088	e58d9000	 str         r9, [sp]
  0008c	eb000000	 bl          CreateThread
  00090	e1b05000	 movs        r5, r0
  00094	1a00000d	 bne         |$LN83@UsbInterru|
  00098	e3a06c3a	 mov         r6, #0x3A, 24
  0009c		 |$LL84@UsbInterru|

; 702  :                 RETAILMSG(1, (TEXT("CHW::UsbInterruptThread: Cannot start thread for resume; sleeping.\n")));

  0009c	e59f07c8	 ldr         r0, [pc, #0x7C8]
  000a0	eb000000	 bl          NKDbgPrintfW

; 703  :                 Sleep(15000);  // 15 seconds later, maybe it'll work.

  000a4	e3860098	 orr         r0, r6, #0x98
  000a8	eb000000	 bl          Sleep
  000ac	e59f27b4	 ldr         r2, [pc, #0x7B4]
  000b0	e1a03004	 mov         r3, r4
  000b4	e3a01000	 mov         r1, #0
  000b8	e3a00000	 mov         r0, #0
  000bc	e58d9004	 str         r9, [sp, #4]
  000c0	e58d9000	 str         r9, [sp]
  000c4	eb000000	 bl          CreateThread
  000c8	e1b05000	 movs        r5, r0
  000cc	0afffff2	 beq         |$LL84@UsbInterru|
  000d0		 |$LN83@UsbInterru|

; 704  :             }
; 705  :             CeSetThreadPriority( ht, g_IstThreadPriority );

  000d0	e59f378c	 ldr         r3, [pc, #0x78C]
  000d4	e1a00005	 mov         r0, r5
  000d8	e5931000	 ldr         r1, [r3]
  000dc	eb000000	 bl          CeSetThreadPriority

; 706  :             CloseHandle(ht);

  000e0	e1a00005	 mov         r0, r5
  000e4	eb000000	 bl          CloseHandle
  000e8		 |$LN144@UsbInterru|

; 1146 :     }
; 1147 : 
; 1148 :     // Disable and clear interrupts
; 1149 :     WRITE_PORT_ULONG((m_portBase + USB_EP_INTMSKCLRR_REG_OFFSET), 
; 1150 :                         USB_OTG_TXINT_MASK |
; 1151 :                         USB_OTG_RXINT_MASK );

  000e8	e5943140	 ldr         r3, [r4, #0x140]
  000ec	e3e01801	 mvn         r1, #1, 16

; 1152 :     WRITE_PORT_ULONG((m_portBase + USB_CORE_INTMSKCLRR_REG_OFFSET), 
; 1153 :                         USB_OTG_USBINT_MASK);

  000f0	e3a0277f	 mov         r2, #0x7F, 14
  000f4	e5831034	 str         r1, [r3, #0x34]
  000f8	e5943140	 ldr         r3, [r4, #0x140]
  000fc	e3822803	 orr         r2, r2, #3, 16
  00100	e5832054	 str         r2, [r3, #0x54]

; 1154 : 
; 1155 :     WRITE_PORT_ULONG((m_portBase + USB_EP_INTCLRR_REG_OFFSET), 
; 1156 :                         USB_OTG_TXINT_MASK |
; 1157 :                         USB_OTG_RXINT_MASK );

  00104	e5943140	 ldr         r3, [r4, #0x140]
  00108	e5831028	 str         r1, [r3, #0x28]

; 1158 :     WRITE_PORT_ULONG((m_portBase + USB_CORE_INTCLRR_REG_OFFSET), 
; 1159 :                         USB_OTG_USBINT_MASK);

  0010c	e5943140	 ldr         r3, [r4, #0x140]
  00110	e5832048	 str         r2, [r3, #0x48]

; 1160 :     WRITE_PORT_ULONG((m_portBase + USB_EOIR_REG_OFFSET), 0);

  00114	e5943140	 ldr         r3, [r4, #0x140]
  00118	e5839060	 str         r9, [r3, #0x60]

; 1161 :     InterruptDone(m_dwSysIntr);

  0011c	e594016c	 ldr         r0, [r4, #0x16C]
  00120	eb000000	 bl          InterruptDone

; 1162 : 
; 1163 :     DEBUGMSG(ZONE_INIT && ZONE_VERBOSE, (TEXT("-CHW::USBInterruptThread\n")));
; 1164 : 
; 1165 :     return (0);

  00124	e3a00000	 mov         r0, #0

; 1166 : }

  00128	e28dd018	 add         sp, sp, #0x18
  0012c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00130	e12fff1e	 bx          lr
  00134		 |$LN86@UsbInterru|

; 707  : 
; 708  :             // The CE resume thread will force this IST to exit so we'll be cooperative proactively.
; 709  :             break;
; 710  :         }
; 711  : 
; 712  :         LockProcessingThread();

  00134	e2840f89	 add         r0, r4, #0x89, 30
  00138	eb000000	 bl          EnterCriticalSection

; 713  : 
; 714  : #ifdef MUSB_USEDMA
; 715  :         // Handle CDMA interrupts
; 716  :         m_dmaCrtl.OnCompletionEvent();

  0013c	e2840fca	 add         r0, r4, #0xCA, 30
  00140	eb000000	 bl          |?OnCompletionEvent@CCppiDmaController@@IAAXXZ|

; 717  : #endif
; 718  : 
; 719  :         // Inspect USB Interrupts
; 720  :         CoreIntStatus = READ_PORT_ULONG( (m_portBase+USB_CORE_INTMASKEDR_REG_OFFSET));

  00144	e5943140	 ldr         r3, [r4, #0x140]
  00148	e5932058	 ldr         r2, [r3, #0x58]

; 721  :         WRITE_PORT_ULONG( (m_portBase+USB_CORE_INTCLRR_REG_OFFSET), CoreIntStatus);

  0014c	e5943140	 ldr         r3, [r4, #0x140]

; 722  : 		EpIntStatus = READ_PORT_ULONG( (m_portBase+USB_EP_INTMASKEDR_REG_OFFSET));
; 723  :         WRITE_PORT_ULONG( (m_portBase+USB_EP_INTCLRR_REG_OFFSET), EpIntStatus);
; 724  : 
; 725  :         IntrUsbValue = (UINT16)((CoreIntStatus & USB_OTG_USBINT_MASK) >> CSL_USB_INTMSKR_USB_SHIFT);

  00150	e1a00382	 mov         r0, r2, lsl #7
  00154	e5832048	 str         r2, [r3, #0x48]
  00158	e5943140	 ldr         r3, [r4, #0x140]

; 726  :         IntrRxValue = (UINT8)((EpIntStatus & USB_OTG_RXINT_MASK) >> USB_OTG_RXINT_SHIFT);
; 727  :         IntrTxValue = (UINT8)(EpIntStatus & USB_OTG_TXINT_MASK) >> USB_OTG_TXINT_SHIFT;
; 728  :         
; 729  : 		((SOhcdPdd*)m_pPddContext)->pSysConfReg->CONTROL_LVL_INTR_CLEAR |= (1 << 4);
; 730  : 
; 731  :         DEBUGMSG(ZONE_VERBOSE, (TEXT("USBInterruptThread: IntrUsbValue=0x%x, IntrRxValue=0x%x, IntrTxValue=0x%x\n\r"), 
; 732  :             IntrUsbValue, IntrRxValue, IntrTxValue));
; 733  : 
; 734  :         if(IntrUsbValue)

  0015c	e1b00ba0	 movs        r0, r0, lsr #23
  00160	e5931038	 ldr         r1, [r3, #0x38]
  00164	e5943140	 ldr         r3, [r4, #0x140]
  00168	e1a02821	 mov         r2, r1, lsr #16
  0016c	e5831028	 str         r1, [r3, #0x28]
  00170	e5943188	 ldr         r3, [r4, #0x188]
  00174	e20290fe	 and         r9, r2, #0xFE
  00178	e201b0ff	 and         r11, r1, #0xFF
  0017c	e5932224	 ldr         r2, [r3, #0x224]
  00180	e5cdb008	 strb        r11, [sp, #8]
  00184	e5923324	 ldr         r3, [r2, #0x324]
  00188	e3833010	 orr         r3, r3, #0x10
  0018c	e5823324	 str         r3, [r2, #0x324]
  00190	0a00001a	 beq         |$LN124@UsbInterru|

; 735  :         {
; 736  :             if (IntrUsbValue & CSL_USB_INTRUSB_SOF_MASK)
; 737  :             {
; 738  :                 // SOFs are handled by the processing thread
; 739  :             }
; 740  : 
; 741  :             if (IntrUsbValue & CSL_USB_INTRUSB_VBUSERR_MASK)

  00194	e3100080	 tst         r0, #0x80
  00198	0a00000b	 beq         |$LN80@UsbInterru|

; 742  :             {
; 743  :                 // session is stopped due to VBUS error
; 744  :                 RETAILMSG(1, (L"USBH: VBUS error detected - resetting controller\r\n"));

  0019c	e59f06bc	 ldr         r0, [pc, #0x6BC]
  001a0	eb000000	 bl          NKDbgPrintfW

; 745  :                 USBHPDD_PowerVBUS(FALSE);

  001a4	e3a00000	 mov         r0, #0
  001a8	eb000000	 bl          USBHPDD_PowerVBUS

; 746  :                 WRITE_PORT_ULONG( (m_portBase+USB_CTRL_REG_OFFSET), BIT0);  // soft reset of USB module

  001ac	e5943140	 ldr         r3, [r4, #0x140]

; 747  :                 InitialiseFIFOs();

  001b0	e3a02001	 mov         r2, #1
  001b4	e1a00004	 mov         r0, r4
  001b8	e5832004	 str         r2, [r3, #4]
  001bc	eb000000	 bl          |?InitialiseFIFOs@CHW@@AAAXXZ|

; 748  :                 EnterOperationalState();

  001c0	e1a00004	 mov         r0, r4
  001c4	eb000000	 bl          |?EnterOperationalState@CHW@@QAAXXZ|

; 749  :             }
; 750  :             else

  001c8	ea00000c	 b           |$LN124@UsbInterru|
  001cc		 |$LN80@UsbInterru|

; 751  :             {
; 752  :                 if (IntrUsbValue & CSL_USB_INTRUSB_CONN_MASK)

  001cc	e3100010	 tst         r0, #0x10

; 753  :                 {
; 754  :                     //device connected
; 755  :                     m_portStatus = m_portStatus | (PORT_STATUS_CON_CHANGED | PORT_STATUS_DEVICE_ATTACHED);

  001d0	15d43196	 ldrneb      r3, [r4, #0x196]

; 756  :                     SetEvent(m_hUsbHubChangeEvent);

  001d4	13833003	 orrne       r3, r3, #3
  001d8	1a000004	 bne         |$LN156@UsbInterru|

; 757  :                 }
; 758  :                 else if (IntrUsbValue & CSL_USB_INTRUSB_DISCON_MASK)

  001dc	e3100020	 tst         r0, #0x20
  001e0	0a000006	 beq         |$LN124@UsbInterru|

; 759  :                 {
; 760  :                     //device disconnected
; 761  :                     m_portStatus = (m_portStatus & ~PORT_STATUS_DEVICE_ATTACHED) | PORT_STATUS_CON_CHANGED;

  001e4	e5d43196	 ldrb        r3, [r4, #0x196]

; 762  :                     SetEvent(m_hUsbHubChangeEvent);

  001e8	e20330fc	 and         r3, r3, #0xFC
  001ec	e3833001	 orr         r3, r3, #1
  001f0		 |$LN156@UsbInterru|
  001f0	e594017c	 ldr         r0, [r4, #0x17C]
  001f4	e3a01003	 mov         r1, #3
  001f8	e5c43196	 strb        r3, [r4, #0x196]
  001fc	eb000000	 bl          EventModify
  00200		 |$LN124@UsbInterru|

; 763  :                 }
; 764  : 
; 765  : #if 0
; 766  :                 if (IntrUsbValue & CSL_USB_INTRUSB_DRVVBUSCHG_MASK)
; 767  :                 {
; 768  :                     RETAILMSG(1, (L"USBH: DRVVBUS changed\r\n"));
; 769  :                     UINT32 drvvbus = READ_PORT_ULONG( (m_portBase+USB_STATR_REG_OFFSET));
; 770  :                     if (drvvbus)
; 771  :                         USBHPDD_PowerVBUS(TRUE);
; 772  :                 }
; 773  : #endif
; 774  :             }
; 775  : 
; 776  :             // RETAILMSG(FALSE,(TEXT("DevCtl = 0x%x"),READ_PORT_UCHAR( (m_portBase+USB_DEVCTL_REG_OFFSET))));
; 777  :         }
; 778  : 
; 779  : 
; 780  :         if (IntrTxValue & BIT0)

  00200	e31b0001	 tst         r11, #1
  00204	0a00002b	 beq         |$LN153@UsbInterru|

; 781  :         {
; 782  :             /*EP0 interrupt*/
; 783  :             pED = (USBED*)m_pProcessEDControl;

  00208	e59430c0	 ldr         r3, [r4, #0xC0]
  0020c	e1b06003	 movs        r6, r3

; 784  :             if (!pED)

  00210	0a000028	 beq         |$LN153@UsbInterru|

; 785  :             {
; 786  :                 // EP0 transfer aborted
; 787  :                 goto _skipControl;
; 788  :             }
; 789  :             pTD = (USBTD*)pED->HeadTD;

  00214	e5962014	 ldr         r2, [r6, #0x14]
  00218	e1b05002	 movs        r5, r2

; 790  : 
; 791  :             // Skip if no TDs or only the NULL TD
; 792  :             if (!pTD || pED->HeadTD == pED->TailTD)

  0021c	0a000025	 beq         |$LN153@UsbInterru|
  00220	e5963018	 ldr         r3, [r6, #0x18]
  00224	e1520003	 cmp         r2, r3
  00228	0a000022	 beq         |$LN153@UsbInterru|

; 793  :             {
; 794  :                 goto _skipControl;
; 795  :             }
; 796  : 
; 797  :             pPkt = (UINT8 *)pTD->sTransfer.lpvClientBuffer;
; 798  : 
; 799  :             // Check for an error condition (can occur at any stage)
; 800  :             _HOST_CSR0 = READ_PORT_USHORT((m_portBase + MGC_END_OFFSET(0, MGC_O_HDRC_CSR0)));

  0022c	e5943140	 ldr         r3, [r4, #0x140]
  00230	e2833c05	 add         r3, r3, #5, 24
  00234	e1d320b2	 ldrh        r2, [r3, #2]

; 801  :             if (_HOST_CSR0 & (MGC_M_CSR0_H_ERROR | MGC_M_CSR0_H_RXSTALL | MGC_M_CSR0_H_NAKTIMEOUT))

  00238	e3120094	 tst         r2, #0x94
  0023c	0a000054	 beq         |$LN69@UsbInterru|

; 802  :             {
; 803  :                 if (_HOST_CSR0 & MGC_M_CSR0_H_ERROR) {

  00240	e3120010	 tst         r2, #0x10

; 804  :                     _HOST_CSR0 &= (~MGC_M_CSR0_H_ERROR);
; 805  :                     *pTD->sTransfer.lpfComplete = TRUE;

  00244	15953040	 ldrne       r3, [r5, #0x40]
  00248	e3a0e001	 mov         lr, #1
  0024c	10022008	 andne       r2, r2, r8
  00250	1583e000	 strne       lr, [r3]

; 806  :                     *pTD->sTransfer.lpdwError = USB_DEVICE_NOT_RESPONDING_ERROR;

  00254	15953048	 ldrne       r3, [r5, #0x48]
  00258	13a08005	 movne       r8, #5
  0025c	15838000	 strne       r8, [r3]

; 846  :                         }
; 847  :                     }
; 848  :                     else{
; 849  :                         RETAILMSG(FALSE,(TEXT("STAGE_SETUP:_HOST_CSR0 = 0x%x"),_HOST_CSR0));
; 850  :                         RETAILMSG(0, (L"INCTL-NRDY\r\n"));
; 851  :                     }
; 852  :                     pED->TransferStatus = STATUS_IDLE;

  00260	03a08005	 moveq       r8, #5
  00264	e3120004	 tst         r2, #4
  00268	15953040	 ldrne       r3, [r5, #0x40]
  0026c	13a01004	 movne       r1, #4
  00270	10022007	 andne       r2, r2, r7
  00274	1583e000	 strne       lr, [r3]
  00278	15953048	 ldrne       r3, [r5, #0x48]
  0027c	15831000	 strne       r1, [r3]
  00280	e3120080	 tst         r2, #0x80
  00284	15953040	 ldrne       r3, [r5, #0x40]
  00288	13a00cff	 movne       r0, #0xFF, 24
  0028c	1380105d	 orrne       r1, r0, #0x5D
  00290	1583e000	 strne       lr, [r3]
  00294	15953048	 ldrne       r3, [r5, #0x48]
  00298	10022001	 andne       r2, r2, r1
  0029c	e3822c01	 orr         r2, r2, #1, 24
  002a0	15838000	 strne       r8, [r3]
  002a4	e5943140	 ldr         r3, [r4, #0x140]
  002a8	e2833c05	 add         r3, r3, #5, 24
  002ac	e1c320b2	 strh        r2, [r3, #2]
  002b0	e3a03002	 mov         r3, #2
  002b4	e586301c	 str         r3, [r6, #0x1C]
  002b8		 |$LN153@UsbInterru|
  002b8	e3a00000	 mov         r0, #0
  002bc		 |$LN158@UsbInterru|
  002bc	e3a0e001	 mov         lr, #1
  002c0		 |$_skipControl$41718|

; 935  :             }
; 936  :         }
; 937  : 
; 938  : _skipControl:
; 939  : 
; 940  :         /*RX interrupt*/
; 941  :         Reg = IntrRxValue;
; 942  :         bShift = 1;
; 943  :         Reg >>= 1;

  002c0	e1a0a0a9	 mov         r10, r9, lsr #1

; 944  :         while (Reg) {

  002c4	e1b0200a	 movs        r2, r10
  002c8	e3a09001	 mov         r9, #1
  002cc	0a0000f7	 beq         |$_skipRx$41790|

; 726  :         IntrRxValue = (UINT8)((EpIntStatus & USB_OTG_RXINT_MASK) >> USB_OTG_RXINT_SHIFT);
; 727  :         IntrTxValue = (UINT8)(EpIntStatus & USB_OTG_TXINT_MASK) >> USB_OTG_TXINT_SHIFT;
; 728  :         
; 729  : 		((SOhcdPdd*)m_pPddContext)->pSysConfReg->CONTROL_LVL_INTR_CLEAR |= (1 << 4);
; 730  : 
; 731  :         DEBUGMSG(ZONE_VERBOSE, (TEXT("USBInterruptThread: IntrUsbValue=0x%x, IntrRxValue=0x%x, IntrTxValue=0x%x\n\r"), 
; 732  :             IntrUsbValue, IntrRxValue, IntrTxValue));
; 733  : 
; 734  :         if(IntrUsbValue)

  002d0	e59db00c	 ldr         r11, [sp, #0xC]
  002d4		 |$LL38@UsbInterru|

; 945  :             if (Reg & 1) {

  002d4	e3120001	 tst         r2, #1
  002d8	0a0000ed	 beq         |$LN20@UsbInterru|

; 946  :                 pED = (USBED*)m_pProcessEDIn[bShift - 1];

  002dc	e0843109	 add         r3, r4, r9, lsl #2
  002e0	e59330c0	 ldr         r3, [r3, #0xC0]
  002e4	e1b07003	 movs        r7, r3

; 947  :                 if(pED){

  002e8	0a0000e9	 beq         |$LN20@UsbInterru|

; 948  :                     pTD = (USBTD*)pED->HeadTD;

  002ec	e5972014	 ldr         r2, [r7, #0x14]
  002f0	e1b05002	 movs        r5, r2

; 949  : 
; 950  :                     // Skip if no TDs or only the NULL TD
; 951  :                     if (!pTD || pED->HeadTD == pED->TailTD)

  002f4	0a0000ec	 beq         |$LN145@UsbInterru|
  002f8	e5973018	 ldr         r3, [r7, #0x18]
  002fc	e1520003	 cmp         r2, r3
  00300	0a0000e9	 beq         |$LN145@UsbInterru|

; 952  :                     {
; 953  :                         goto _skipRx;
; 954  :                     }
; 955  : 
; 956  :                     _HOST_RXCSR = READ_PORT_USHORT( (m_portBase + MGC_END_OFFSET(bShift, MGC_O_HDRC_RXCSR)));

  00304	e5943140	 ldr         r3, [r4, #0x140]
  00308	e0833209	 add         r3, r3, r9, lsl #4
  0030c	e2833c05	 add         r3, r3, #5, 24
  00310	e1d360b6	 ldrh        r6, [r3, #6]

; 957  : 
; 958  :                     /*check for RXPKTRDY*/
; 959  :                     if (_HOST_RXCSR & MGC_M_RXCSR_RXPKTRDY) {

  00314	e3160001	 tst         r6, #1
  00318	0a0000c1	 beq         |$LN31@UsbInterru|

; 960  :                         //pED->bfToggleCarry = (!pED->bfToggleCarry);
; 961  :                         pED->bfToggleCarry = (_HOST_RXCSR & (0x1<<9));

  0031c	e2063c02	 and         r3, r6, #2, 24
  00320	e1c732b8	 strh        r3, [r7, #0x28]

; 962  :                         pPkt = (UINT8*)pTD->sTransfer.lpvClientBuffer;
; 963  :                         CopyCount = _RXCOUNT = READ_PORT_USHORT( (m_portBase + MGC_END_OFFSET(bShift, MGC_O_HDRC_RXCOUNT)));

  00324	e5943140	 ldr         r3, [r4, #0x140]

; 964  : 
; 965  : 
; 966  : 						if(pTD->BytesToTransfer < CopyCount) {

  00328	e5952058	 ldr         r2, [r5, #0x58]
  0032c	e595102c	 ldr         r1, [r5, #0x2C]
  00330	e0833209	 add         r3, r3, r9, lsl #4
  00334	e2833c05	 add         r3, r3, #5, 24
  00338	e1d380b8	 ldrh        r8, [r3, #8]
  0033c	e1520008	 cmp         r2, r8
  00340	2a000084	 bcs         |$LN30@UsbInterru|

; 967  :                             /*data OVERRUN*/
; 968  :                             UINT8 temp;
; 969  :                             while (CopyCount) {

  00344	e3580000	 cmp         r8, #0
  00348	0a000005	 beq         |$LN28@UsbInterru|
  0034c	e2892f42	 add         r2, r9, #0x42, 30
  00350		 |$LL29@UsbInterru|

; 970  :                                 temp = READ_PORT_UCHAR( (m_portBase+MGC_FIFO_OFFSET(bShift)));

  00350	e5943140	 ldr         r3, [r4, #0x140]

; 971  :                                 CopyCount--;

  00354	e2588001	 subs        r8, r8, #1
  00358	e0833102	 add         r3, r3, r2, lsl #2
  0035c	e5d33000	 ldrb        r3, [r3]
  00360	1afffffa	 bne         |$LL29@UsbInterru|
  00364		 |$LN28@UsbInterru|

; 972  :                             }
; 973  :                             _HOST_RXCSR &= (~MGC_M_RXCSR_RXPKTRDY);
; 974  :                             WRITE_PORT_USHORT( (m_portBase + MGC_END_OFFSET(bShift, MGC_O_HDRC_RXCSR)),_HOST_RXCSR/*|MGC_M_RXCSR_FLUSHFIFO*/);

  00364	e5943140	 ldr         r3, [r4, #0x140]
  00368	e006200b	 and         r2, r6, r11
  0036c	e0833209	 add         r3, r3, r9, lsl #4
  00370	e2833c05	 add         r3, r3, #5, 24
  00374	e1c320b6	 strh        r2, [r3, #6]

; 975  :                             *pTD->sTransfer.lpdwBytesTransferred = 0;

  00378	e5953044	 ldr         r3, [r5, #0x44]

; 976  :                             *pTD->sTransfer.lpfComplete = TRUE;
; 977  :                             *pTD->sTransfer.lpdwError = USB_DATA_OVERRUN_ERROR;

  0037c	e3a02008	 mov         r2, #8
  00380	e5830000	 str         r0, [r3]
  00384	e5953040	 ldr         r3, [r5, #0x40]
  00388	e583e000	 str         lr, [r3]
  0038c	e5953048	 ldr         r3, [r5, #0x48]

; 978  :                             pED->bfHalted = TRUE;
; 979  :                             pED->TransferStatus = STATUS_COMPLETE;
; 980  :                         }
; 981  :                         else{

  00390	ea00009c	 b           |$LN163@UsbInterru|
  00394		 |$LN69@UsbInterru|

; 807  :                 }
; 808  :                 if(_HOST_CSR0 & MGC_M_CSR0_H_RXSTALL) {
; 809  :                     _HOST_CSR0 &= (~MGC_M_CSR0_H_RXSTALL);
; 810  :                     *pTD->sTransfer.lpfComplete = TRUE;
; 811  :                     *pTD->sTransfer.lpdwError = USB_STALL_ERROR;
; 812  :                 }
; 813  :                 if(_HOST_CSR0 & MGC_M_CSR0_H_NAKTIMEOUT) {
; 814  :                     _HOST_CSR0 &= (~(MGC_M_CSR0_H_NAKTIMEOUT|MGC_M_CSR0_H_REQPKT|MGC_M_CSR0_TXPKTRDY));
; 815  :                     *pTD->sTransfer.lpfComplete = TRUE;
; 816  :                     *pTD->sTransfer.lpdwError = USB_DEVICE_NOT_RESPONDING_ERROR;
; 817  :                 }
; 818  :                 _HOST_CSR0 |= MGC_M_CSR0_FLUSHFIFO;
; 819  :                 WRITE_PORT_USHORT((m_portBase + MGC_END_OFFSET(0, MGC_O_HDRC_CSR0)),_HOST_CSR0);
; 820  :                 pED->TransferStatus = STATUS_COMPLETE;
; 821  :                 goto _skipControl;
; 822  :             }
; 823  : 
; 824  :             switch(pTD->TransferStage){

  00394	e5953050	 ldr         r3, [r5, #0x50]
  00398	e3530000	 cmp         r3, #0
  0039c	0a000058	 beq         |$LN62@UsbInterru|
  003a0	e3530001	 cmp         r3, #1
  003a4	0a00002e	 beq         |$LN55@UsbInterru|
  003a8	e3530002	 cmp         r3, #2
  003ac	0a00001f	 beq         |$LN49@UsbInterru|
  003b0	e3530003	 cmp         r3, #3
  003b4	0a000009	 beq         |$LN44@UsbInterru|
  003b8	e3530004	 cmp         r3, #4

; 921  :                 case STAGE_STATUSOUT:
; 922  :                     _HOST_CSR0 = READ_PORT_USHORT( (m_portBase + MGC_END_OFFSET(0, MGC_O_HDRC_CSR0)));
; 923  :                     if(!(_HOST_CSR0 & MGC_M_CSR0_TXPKTRDY)){
; 924  :                         /*TX successful*/
; 925  :                     }
; 926  :                     else {
; 927  :                         RETAILMSG(FALSE,(TEXT("STAGE_STATUSOUT:_HOST_CSR0 = 0x%x"),_HOST_CSR0));
; 928  :                     }
; 929  :                     *pTD->sTransfer.lpdwBytesTransferred = pTD->BytesTransferred;
; 930  :                     *pTD->sTransfer.lpfComplete = TRUE;

  003bc	e3a0e001	 mov         lr, #1
  003c0	1a000062	 bne         |$LN152@UsbInterru|
  003c4	e5943140	 ldr         r3, [r4, #0x140]
  003c8	e5950044	 ldr         r0, [r5, #0x44]
  003cc	e5951054	 ldr         r1, [r5, #0x54]
  003d0	e2833c05	 add         r3, r3, #5, 24
  003d4	e1d320b2	 ldrh        r2, [r3, #2]
  003d8	e5801000	 str         r1, [r0]

; 931  :                     *pTD->sTransfer.lpdwError = USB_NO_ERROR;
; 932  :                     pED->TransferStatus = STATUS_COMPLETE;
; 933  :                     RETAILMSG(0, (L"4CTL_%08X\r\n", pTD));
; 934  :                     break;

  003dc	ea00000b	 b           |$LN164@UsbInterru|
  003e0		 |$LN44@UsbInterru|

; 906  :                 case STAGE_STATUSIN:
; 907  :                     _HOST_CSR0 = READ_PORT_USHORT( (m_portBase + MGC_END_OFFSET(0, MGC_O_HDRC_CSR0)));

  003e0	e5943140	 ldr         r3, [r4, #0x140]

; 908  :                     if (_HOST_CSR0 & MGC_M_CSR0_RXPKTRDY) {
; 909  :                         _HOST_CSR0 &= (~MGC_M_CSR0_RXPKTRDY);
; 910  :                         WRITE_PORT_USHORT( (m_portBase + MGC_END_OFFSET(0, MGC_O_HDRC_CSR0)),_HOST_CSR0);
; 911  :                     }
; 912  :                     else{
; 913  :                         RETAILMSG(FALSE,(TEXT("STAGE_STATUSIN:_HOST_CSR0 = 0x%x"),_HOST_CSR0));
; 914  :                     }
; 915  :                     *pTD->sTransfer.lpdwBytesTransferred = pTD->BytesTransferred;
; 916  :                     *pTD->sTransfer.lpfComplete = TRUE;

  003e4	e3a0e001	 mov         lr, #1
  003e8	e2833c05	 add         r3, r3, #5, 24
  003ec	e1d320b2	 ldrh        r2, [r3, #2]
  003f0	e3120001	 tst         r2, #1
  003f4	15943140	 ldrne       r3, [r4, #0x140]
  003f8	1002200a	 andne       r2, r2, r10
  003fc	12833c05	 addne       r3, r3, #5, 24
  00400	11c320b2	 strneh      r2, [r3, #2]
  00404	e5952044	 ldr         r2, [r5, #0x44]
  00408	e5953054	 ldr         r3, [r5, #0x54]
  0040c	e5823000	 str         r3, [r2]
  00410		 |$LN164@UsbInterru|
  00410	e5953040	 ldr         r3, [r5, #0x40]

; 917  :                     *pTD->sTransfer.lpdwError = USB_NO_ERROR;

  00414	e3a00000	 mov         r0, #0
  00418	e583e000	 str         lr, [r3]
  0041c	e5953048	 ldr         r3, [r5, #0x48]
  00420	e5830000	 str         r0, [r3]

; 918  :                     pED->TransferStatus = STATUS_COMPLETE;

  00424	e3a03002	 mov         r3, #2
  00428	e586301c	 str         r3, [r6, #0x1C]

; 919  :                     RETAILMSG(0, (L"3CTL_%08X\r\n", pTD));
; 920  :                     break;

  0042c	eaffffa3	 b           |$_skipControl$41718|
  00430		 |$LN49@UsbInterru|

; 886  :                 case STAGE_DATAOUT:
; 887  :                     /*Host to device*/
; 888  :                     _HOST_CSR0 = READ_PORT_USHORT( (m_portBase + MGC_END_OFFSET(0, MGC_O_HDRC_CSR0)));

  00430	e5943140	 ldr         r3, [r4, #0x140]
  00434	e2833c05	 add         r3, r3, #5, 24
  00438	e1d330b2	 ldrh        r3, [r3, #2]

; 889  :                     if(!(_HOST_CSR0 & MGC_M_CSR0_TXPKTRDY)){

  0043c	e3130002	 tst         r3, #2
  00440	1affff9c	 bne         |$LN153@UsbInterru|

; 890  :                         /*TX successful*/
; 891  :                         if(!pTD->BytesToTransfer){

  00444	e5953058	 ldr         r3, [r5, #0x58]

; 892  :                             /*data phase complete*/
; 893  :                             pTD->TransferStage = STAGE_STATUSIN;
; 894  :                         }
; 895  :                         else{
; 896  :                             /* data phase to continue*/
; 897  :                             pTD->TransferStage = STAGE_DATAOUT;
; 898  :                         }
; 899  :                         pED->TransferStatus = STATUS_IDLE;

  00448	e3a00000	 mov         r0, #0
  0044c	e3530000	 cmp         r3, #0
  00450	03a03003	 moveq       r3, #3
  00454	13a03002	 movne       r3, #2
  00458	e5853050	 str         r3, [r5, #0x50]
  0045c	e586001c	 str         r0, [r6, #0x1C]

; 900  :                     }
; 901  :                     else{
; 902  :                         RETAILMSG(FALSE,(TEXT("STAGE_DATAOUT:_HOST_CSR0 = 0x%x"),_HOST_CSR0));
; 903  :                         RETAILMSG(0, (L"2CTL_%08X\r\n", pTD));
; 904  :                     }
; 905  :                     break;

  00460	eaffff95	 b           |$LN158@UsbInterru|
  00464		 |$LN55@UsbInterru|

; 853  :                     break;
; 854  :                 case STAGE_DATAIN:
; 855  :                     /*Device to host*/
; 856  :                     _HOST_CSR0 = READ_PORT_USHORT( (m_portBase + MGC_END_OFFSET(0, MGC_O_HDRC_CSR0)));

  00464	e5943140	 ldr         r3, [r4, #0x140]
  00468	e2833c05	 add         r3, r3, #5, 24
  0046c	e1d370b2	 ldrh        r7, [r3, #2]

; 857  : 
; 858  :                     /*check for RXPKTRDY*/
; 859  :                     if (_HOST_CSR0 & MGC_M_CSR0_RXPKTRDY) {

  00470	e3170001	 tst         r7, #1
  00474	0affff8f	 beq         |$LN153@UsbInterru|

; 860  :                         pPkt = (UINT8*)pTD->sTransfer.lpvClientBuffer;
; 861  :                         CopyCount = _COUNT0 = READ_PORT_USHORT( (m_portBase + MGC_END_OFFSET(0, MGC_O_HDRC_COUNT0)));

  00478	e5943140	 ldr         r3, [r4, #0x140]

; 862  :                         pData = pPkt;
; 863  :                         pData += pTD->BytesTransferred;

  0047c	e5951054	 ldr         r1, [r5, #0x54]
  00480	e595202c	 ldr         r2, [r5, #0x2C]
  00484	e2833c05	 add         r3, r3, #5, 24
  00488	e1d380b8	 ldrh        r8, [r3, #8]

; 864  : 						
; 865  : 						ReadFIFO((DWORD*)(m_portBase+MGC_FIFO_OFFSET(0)), pData, CopyCount);

  0048c	e5943140	 ldr         r3, [r4, #0x140]
  00490	e0811002	 add         r1, r1, r2
  00494	e1a02008	 mov         r2, r8
  00498	e2830e42	 add         r0, r3, #0x42, 28
  0049c	eb000000	 bl          |?ReadFIFO@@YAHPAKPAXK@Z|

; 866  : 						pTD->BytesToTransfer -= CopyCount;

  004a0	e5953058	 ldr         r3, [r5, #0x58]

; 867  : 						pTD->BytesTransferred += CopyCount;

  004a4	e5952054	 ldr         r2, [r5, #0x54]

; 868  :                         _HOST_CSR0 &= (~MGC_M_CSR0_RXPKTRDY);

  004a8	e007100a	 and         r1, r7, r10
  004ac	e0433008	 sub         r3, r3, r8
  004b0	e0822008	 add         r2, r2, r8
  004b4	e5853058	 str         r3, [r5, #0x58]
  004b8	e5852054	 str         r2, [r5, #0x54]

; 869  :                         WRITE_PORT_USHORT( (m_portBase + MGC_END_OFFSET(0, MGC_O_HDRC_CSR0)),_HOST_CSR0);

  004bc	e5943140	 ldr         r3, [r4, #0x140]
  004c0	e2833c05	 add         r3, r3, #5, 24
  004c4	e1c310b2	 strh        r1, [r3, #2]

; 870  : 
; 871  :                         if(!pTD->BytesToTransfer || (_COUNT0 < pED->bfMaxPacketSize)){

  004c8	e5953058	 ldr         r3, [r5, #0x58]
  004cc	e3530000	 cmp         r3, #0
  004d0	0a000005	 beq         |$LN52@UsbInterru|
  004d4	e1d630be	 ldrh        r3, [r6, #0xE]
  004d8	e1580003	 cmp         r8, r3
  004dc	3a000002	 bcc         |$LN52@UsbInterru|

; 874  :                         }
; 875  :                         else{
; 876  :                             /* data phase to continue*/
; 877  :                             pTD->TransferStage = STAGE_DATAIN;

  004e0	e3a0e001	 mov         lr, #1
  004e4		 |$LN165@UsbInterru|
  004e4	e585e050	 str         lr, [r5, #0x50]
  004e8	ea000002	 b           |$LN51@UsbInterru|
  004ec		 |$LN52@UsbInterru|

; 872  :                             /*data phase complete*/
; 873  :                             pTD->TransferStage = STAGE_STATUSOUT;

  004ec	e3a03004	 mov         r3, #4
  004f0	e5853050	 str         r3, [r5, #0x50]
  004f4		 |$LN155@UsbInterru|
  004f4	e3a0e001	 mov         lr, #1
  004f8		 |$LN51@UsbInterru|

; 878  :                         }
; 879  :                         pED->TransferStatus = STATUS_IDLE;

  004f8	e3a00000	 mov         r0, #0
  004fc	e586001c	 str         r0, [r6, #0x1C]

; 880  :                     }
; 881  :                     else{
; 882  :                         RETAILMSG(FALSE,(TEXT("STAGE_DATAIN:_HOST_CSR0 = 0x%x"),_HOST_CSR0));
; 883  :                         RETAILMSG(0, (L"1CTL_%08X\r\n", pTD));
; 884  :                     }
; 885  :                     break;

  00500	eaffff6e	 b           |$_skipControl$41718|
  00504		 |$LN62@UsbInterru|

; 825  :                 /*case current stage*/
; 826  :                 case STAGE_SETUP:
; 827  :                     _HOST_CSR0 = READ_PORT_USHORT( (m_portBase + MGC_END_OFFSET(0, MGC_O_HDRC_CSR0)));

  00504	e5943140	 ldr         r3, [r4, #0x140]
  00508	e2833c05	 add         r3, r3, #5, 24
  0050c	e1d330b2	 ldrh        r3, [r3, #2]

; 828  :                     if(!(_HOST_CSR0 & MGC_M_CSR0_TXPKTRDY)){

  00510	e3130002	 tst         r3, #2
  00514	1afffff6	 bne         |$LN155@UsbInterru|

; 829  :                         /*TX successful*/
; 830  :                         if(pTD->BytesToTransfer){

  00518	e5953058	 ldr         r3, [r5, #0x58]

; 831  :                             /*data stage required*/
; 832  :                             pPkt = (UINT8 *)pTD->sTransfer.lpvControlHeader;
; 833  :                             RequestType = *pPkt;
; 834  :                             if(RequestType & 0x80){
; 835  :                                 /*data stage - device to host*/
; 836  :                                 pTD->TransferStage = STAGE_DATAIN;

  0051c	e3a0e001	 mov         lr, #1
  00520	e3530000	 cmp         r3, #0
  00524	0a000006	 beq         |$LN60@UsbInterru|
  00528	e5953014	 ldr         r3, [r5, #0x14]
  0052c	e5d33000	 ldrb        r3, [r3]
  00530	e3130080	 tst         r3, #0x80

; 837  :                             }
; 838  :                             else{

  00534	1affffea	 bne         |$LN165@UsbInterru|

; 839  :                                 /*data stage - host to device*/
; 840  :                                 pTD->TransferStage = STAGE_DATAOUT;

  00538	e3a03002	 mov         r3, #2
  0053c	e5853050	 str         r3, [r5, #0x50]

; 841  :                             }
; 842  :                         }
; 843  :                         else {

  00540	eaffffec	 b           |$LN51@UsbInterru|
  00544		 |$LN60@UsbInterru|

; 844  :                             /*no data stage*/
; 845  :                             pTD->TransferStage = STAGE_STATUSIN;

  00544	e3a03003	 mov         r3, #3
  00548	e5853050	 str         r3, [r5, #0x50]
  0054c	eaffffe9	 b           |$LN51@UsbInterru|
  00550		 |$LN152@UsbInterru|

; 846  :                         }
; 847  :                     }
; 848  :                     else{
; 849  :                         RETAILMSG(FALSE,(TEXT("STAGE_SETUP:_HOST_CSR0 = 0x%x"),_HOST_CSR0));
; 850  :                         RETAILMSG(0, (L"INCTL-NRDY\r\n"));
; 851  :                     }
; 852  :                     pED->TransferStatus = STATUS_IDLE;

  00550	e3a00000	 mov         r0, #0
  00554	eaffff59	 b           |$_skipControl$41718|
  00558		 |$LN30@UsbInterru|

; 982  :                             pData = pPkt;
; 983  :                             pData += pTD->BytesTransferred;

  00558	e5952054	 ldr         r2, [r5, #0x54]

; 984  : 
; 985  : 							ReadFIFO((DWORD*)(m_portBase+MGC_FIFO_OFFSET(bShift)), pData, CopyCount);

  0055c	e5940140	 ldr         r0, [r4, #0x140]
  00560	e2893f42	 add         r3, r9, #0x42, 30
  00564	e0821001	 add         r1, r2, r1
  00568	e1a02008	 mov         r2, r8
  0056c	e0800103	 add         r0, r0, r3, lsl #2
  00570	eb000000	 bl          |?ReadFIFO@@YAHPAKPAXK@Z|

; 986  : 
; 987  :                             pTD->BytesTransferred += _RXCOUNT;

  00574	e5953054	 ldr         r3, [r5, #0x54]

; 988  :                             pTD->BytesToTransfer -= _RXCOUNT;

  00578	e5952058	 ldr         r2, [r5, #0x58]

; 989  :                             _HOST_RXCSR &= (~MGC_M_RXCSR_RXPKTRDY);

  0057c	e006100b	 and         r1, r6, r11
  00580	e0883003	 add         r3, r8, r3
  00584	e0422008	 sub         r2, r2, r8
  00588	e5853054	 str         r3, [r5, #0x54]
  0058c	e5852058	 str         r2, [r5, #0x58]

; 990  :                             WRITE_PORT_USHORT( (m_portBase + MGC_END_OFFSET(bShift, MGC_O_HDRC_RXCSR)),_HOST_RXCSR);

  00590	e5943140	 ldr         r3, [r4, #0x140]

; 991  :     /*5.8.3 of USB 2.0*/
; 992  :                             if(!pTD->BytesToTransfer){
; 993  :                                 *pTD->sTransfer.lpdwBytesTransferred = pTD->BytesTransferred;
; 994  :                                 *pTD->sTransfer.lpfComplete = TRUE;

  00594	e3a0e001	 mov         lr, #1

; 995  :                                 *pTD->sTransfer.lpdwError = USB_NO_ERROR;

  00598	e3a00000	 mov         r0, #0
  0059c	e0833209	 add         r3, r3, r9, lsl #4
  005a0	e2833c05	 add         r3, r3, #5, 24
  005a4	e1c310b6	 strh        r1, [r3, #6]
  005a8	e5953058	 ldr         r3, [r5, #0x58]
  005ac	e3530000	 cmp         r3, #0
  005b0	1a000007	 bne         |$LN26@UsbInterru|
  005b4	e5952044	 ldr         r2, [r5, #0x44]
  005b8	e5953054	 ldr         r3, [r5, #0x54]
  005bc	e5823000	 str         r3, [r2]
  005c0	e5953040	 ldr         r3, [r5, #0x40]
  005c4	e583e000	 str         lr, [r3]
  005c8	e5953048	 ldr         r3, [r5, #0x48]
  005cc		 |$LN166@UsbInterru|
  005cc	e5830000	 str         r0, [r3]

; 996  :                                 pED->TransferStatus = STATUS_COMPLETE;

  005d0	ea00000e	 b           |$LN162@UsbInterru|
  005d4		 |$LN26@UsbInterru|

; 997  :                             }
; 998  :                             else if(_RXCOUNT < pED->bfMaxPacketSize){

  005d4	e1d730be	 ldrh        r3, [r7, #0xE]
  005d8	e1580003	 cmp         r8, r3
  005dc	2a00000e	 bcs         |$LN24@UsbInterru|

; 999  :                                 /*data UNDERRUN (pTD->BytesToTransfer is not 0) handling depending on USB_SHORT_TRANSFER_OK*/
; 1000 :                                 if(pTD->sTransfer.dwFlags & USB_SHORT_TRANSFER_OK){

  005e0	e5953010	 ldr         r3, [r5, #0x10]

; 1001 :                                     *pTD->sTransfer.lpdwBytesTransferred = pTD->BytesTransferred;

  005e4	e5952044	 ldr         r2, [r5, #0x44]
  005e8	e3130c02	 tst         r3, #2, 24
  005ec	e5953054	 ldr         r3, [r5, #0x54]
  005f0	e5823000	 str         r3, [r2]

; 1002 :                                     *pTD->sTransfer.lpfComplete = TRUE;

  005f4	e5953040	 ldr         r3, [r5, #0x40]
  005f8	e583e000	 str         lr, [r3]

; 1003 :                                     *pTD->sTransfer.lpdwError = USB_NO_ERROR;

  005fc	e5953048	 ldr         r3, [r5, #0x48]

; 1004 :                                     pED->TransferStatus = STATUS_COMPLETE;
; 1005 :                                 }
; 1006 :                                 else{

  00600	1afffff1	 bne         |$LN166@UsbInterru|

; 1007 :                                     *pTD->sTransfer.lpdwBytesTransferred = pTD->BytesTransferred;
; 1008 :                                     *pTD->sTransfer.lpfComplete = TRUE;
; 1009 :                                     *pTD->sTransfer.lpdwError = USB_DATA_UNDERRUN_ERROR;

  00604	e3a02009	 mov         r2, #9
  00608		 |$LN163@UsbInterru|
  00608	e5832000	 str         r2, [r3]

; 1010 :                                     pED->bfHalted = TRUE;

  0060c	e587e024	 str         lr, [r7, #0x24]
  00610		 |$LN162@UsbInterru|

; 1011 :                                     pED->TransferStatus = STATUS_COMPLETE;

  00610	e3a03002	 mov         r3, #2
  00614	e587301c	 str         r3, [r7, #0x1C]

; 1012 :                                 }
; 1013 :                             }
; 1014 :                             else

  00618	ea00001d	 b           |$LN20@UsbInterru|
  0061c		 |$LN24@UsbInterru|

; 1015 :                                 pED->TransferStatus = STATUS_IDLE;

  0061c	e587001c	 str         r0, [r7, #0x1C]

; 1016 :                         }
; 1017 :                     }
; 1018 :                     else{

  00620	ea00001b	 b           |$LN20@UsbInterru|
  00624		 |$LN31@UsbInterru|

; 1019 :                         RETAILMSG(FALSE,(TEXT("hostEP= %d HOST_RXCSR = 0x%x"),pED->bHostEndPointNum,_HOST_RXCSR));
; 1020 : 
; 1021 :                         TransferStatus Status = STATUS_IDLE;
; 1022 :                         if(_HOST_RXCSR & MGC_M_RXCSR_H_ERROR){

  00624	e3160004	 tst         r6, #4
  00628	e3a02000	 mov         r2, #0

; 1023 :                             _HOST_RXCSR &= (~(MGC_M_RXCSR_H_REQPKT|MGC_M_RXCSR_H_ERROR));

  0062c	13a02cff	 movne       r2, #0xFF, 24
  00630	138230db	 orrne       r3, r2, #0xDB
  00634	10066003	 andne       r6, r6, r3

; 1024 :                             //*pTD->sTransfer.lpdwBytesTransferred = pTD->BytesTransferred;
; 1025 :                             //*pTD->sTransfer.lpfComplete = TRUE;
; 1026 :                             //*pTD->sTransfer.lpdwError = USB_DEVICE_NOT_RESPONDING_ERROR;
; 1027 :                             Status = STATUS_NO_RESPONSE;

  00638	13a02003	 movne       r2, #3

; 1028 :                         }
; 1029 :                         if(_HOST_RXCSR & MGC_M_RXCSR_H_RXSTALL){

  0063c	e3160040	 tst         r6, #0x40
  00640	0a000009	 beq         |$LN18@UsbInterru|

; 1030 :                             _HOST_RXCSR &= (~(MGC_M_RXCSR_H_REQPKT|MGC_M_RXCSR_H_RXSTALL));
; 1031 :                             //*pTD->sTransfer.lpdwBytesTransferred = pTD->BytesTransferred;
; 1032 :                             *pTD->sTransfer.lpfComplete = TRUE;

  00644	e5953040	 ldr         r3, [r5, #0x40]
  00648	e3a01cff	 mov         r1, #0xFF, 24
  0064c	e381209f	 orr         r2, r1, #0x9F

; 1033 :                             *pTD->sTransfer.lpdwError = USB_STALL_ERROR;
; 1034 :                             pED->bfHalted = TRUE;
; 1035 :                             Status = STATUS_COMPLETE;

  00650	e583e000	 str         lr, [r3]
  00654	e5953048	 ldr         r3, [r5, #0x48]
  00658	e3a01004	 mov         r1, #4
  0065c	e0066002	 and         r6, r6, r2
  00660	e5831000	 str         r1, [r3]
  00664	e587e024	 str         lr, [r7, #0x24]
  00668	e3a02002	 mov         r2, #2
  0066c		 |$LN18@UsbInterru|

; 1036 :                         }
; 1037 :                         if(_HOST_RXCSR & MGC_M_RXCSR_DATAERROR){

  0066c	e3160008	 tst         r6, #8

; 1038 :                             _HOST_RXCSR &= (~(MGC_M_RXCSR_H_REQPKT|MGC_M_RXCSR_DATAERROR));

  00670	13a02cff	 movne       r2, #0xFF, 24
  00674	138230d7	 orrne       r3, r2, #0xD7
  00678	10066003	 andne       r6, r6, r3

; 1039 :                             //*pTD->sTransfer.lpfComplete = TRUE;
; 1040 :                             //*pTD->sTransfer.lpdwError = USB_DEVICE_NOT_RESPONDING_ERROR;
; 1041 :                             Status = STATUS_NAK;
; 1042 :                         }
; 1043 :                         WRITE_PORT_USHORT( (m_portBase + MGC_END_OFFSET(bShift, MGC_O_HDRC_RXCSR)),_HOST_RXCSR);

  0067c	e5943140	 ldr         r3, [r4, #0x140]
  00680	13a02004	 movne       r2, #4
  00684	e0833209	 add         r3, r3, r9, lsl #4
  00688	e2833c05	 add         r3, r3, #5, 24
  0068c	e1c360b6	 strh        r6, [r3, #6]

; 1044 :                         pED->TransferStatus = Status;

  00690	e587201c	 str         r2, [r7, #0x1C]
  00694		 |$LN20@UsbInterru|

; 1045 :                     }
; 1046 :                 }
; 1047 :             }
; 1048 :             Reg >>= 1;

  00694	e1a030aa	 mov         r3, r10, lsr #1
  00698	e203a0ff	 and         r10, r3, #0xFF

; 1049 :             bShift++;

  0069c	e2893001	 add         r3, r9, #1
  006a0	e20390ff	 and         r9, r3, #0xFF
  006a4	e1b0200a	 movs        r2, r10
  006a8	1affff09	 bne         |$LL38@UsbInterru|
  006ac		 |$LN145@UsbInterru|

; 726  :         IntrRxValue = (UINT8)((EpIntStatus & USB_OTG_RXINT_MASK) >> USB_OTG_RXINT_SHIFT);
; 727  :         IntrTxValue = (UINT8)(EpIntStatus & USB_OTG_TXINT_MASK) >> USB_OTG_TXINT_SHIFT;
; 728  :         
; 729  : 		((SOhcdPdd*)m_pPddContext)->pSysConfReg->CONTROL_LVL_INTR_CLEAR |= (1 << 4);
; 730  : 
; 731  :         DEBUGMSG(ZONE_VERBOSE, (TEXT("USBInterruptThread: IntrUsbValue=0x%x, IntrRxValue=0x%x, IntrTxValue=0x%x\n\r"), 
; 732  :             IntrUsbValue, IntrRxValue, IntrTxValue));
; 733  : 
; 734  :         if(IntrUsbValue)

  006ac	e5ddb008	 ldrb        r11, [sp, #8]
  006b0		 |$_skipRx$41790|

; 1050 :         }
; 1051 : 
; 1052 : _skipRx:
; 1053 : 
; 1054 :         /*TX interrupt*/
; 1055 :         Reg = IntrTxValue;
; 1056 :         bShift = 1;
; 1057 :         Reg >>= 1;

  006b0	e1a070ab	 mov         r7, r11, lsr #1

; 1058 :         while (Reg) {

  006b4	e1b02007	 movs        r2, r7
  006b8	e3a06001	 mov         r6, #1
  006bc	0a000054	 beq         |$_skipTx$41828|

; 666  :     UINT16 IntrUsbValue;
; 667  :     UINT8  IntrTxValue;
; 668  :     UINT8  IntrRxValue;
; 669  :     DWORD  CoreIntStatus;
; 670  : 	DWORD  EpIntStatus;
; 671  :     UINT16 _HOST_CSR0, _HOST_RXCSR, _HOST_TXCSR, _RXCOUNT, _COUNT0;
; 672  :     DWORD CopyCount;
; 673  :     UINT8 *pPkt, *pData, RequestType, Reg, bShift;
; 674  :     USBTD *pTD;
; 675  :     USBED *pED;
; 676  : 
; 677  : 	UNREFERENCED_PARAMETER(context);
; 678  : 
; 679  :     DEBUGMSG(ZONE_INIT && ZONE_VERBOSE, (TEXT("+CHW::USBInterruptThread\n\r")));
; 680  : 
; 681  :     while ( !m_fUsbInterruptThreadClosing ) {

  006c0	e59d8010	 ldr         r8, [sp, #0x10]
  006c4		 |$LL16@UsbInterru|

; 1059 :             if (Reg & 1) {

  006c4	e3120001	 tst         r2, #1
  006c8	0a00004b	 beq         |$LN4@UsbInterru|

; 1060 :                 pED = (USBED*)m_pProcessEDOut[bShift - 1];

  006cc	e0843106	 add         r3, r4, r6, lsl #2
  006d0	e59330fc	 ldr         r3, [r3, #0xFC]
  006d4	e1b05003	 movs        r5, r3

; 1061 :                 if(pED){

  006d8	0a000047	 beq         |$LN4@UsbInterru|

; 1062 :                     pTD = (USBTD*)pED->HeadTD;

  006dc	e5952014	 ldr         r2, [r5, #0x14]
  006e0	e1b0e002	 movs        lr, r2

; 1063 : 
; 1064 :                     // Skip if no TDs or only the NULL TD
; 1065 :                     if (!pTD || pED->HeadTD == pED->TailTD)

  006e4	0a00004a	 beq         |$_skipTx$41828|
  006e8	e5953018	 ldr         r3, [r5, #0x18]
  006ec	e1520003	 cmp         r2, r3
  006f0	0a000047	 beq         |$_skipTx$41828|

; 1066 :                     {
; 1067 :                         goto _skipTx;
; 1068 :                     }
; 1069 : 
; 1070 :                     _HOST_TXCSR = READ_PORT_USHORT( (m_portBase + MGC_END_OFFSET(bShift, MGC_O_HDRC_TXCSR)));

  006f4	e5943140	 ldr         r3, [r4, #0x140]
  006f8	e0833206	 add         r3, r3, r6, lsl #4
  006fc	e2833c05	 add         r3, r3, #5, 24
  00700	e1d320b2	 ldrh        r2, [r3, #2]

; 1071 :                     if(!(_HOST_TXCSR & MGC_M_TXCSR_H_RXSTALL) &&
; 1072 :                        !(_HOST_TXCSR & MGC_M_TXCSR_H_NAKTIMEOUT) &&
; 1073 :                        !(_HOST_TXCSR & MGC_M_TXCSR_H_ERROR))

  00704	e3120020	 tst         r2, #0x20
  00708	1a00001f	 bne         |$LN9@UsbInterru|
  0070c	e3120080	 tst         r2, #0x80
  00710	1a00001d	 bne         |$LN9@UsbInterru|
  00714	e3120004	 tst         r2, #4
  00718	1a00001b	 bne         |$LN9@UsbInterru|

; 1074 :                     {
; 1075 :                         if (!(_HOST_TXCSR & MGC_M_TXCSR_TXPKTRDY))

  0071c	e3120001	 tst         r2, #1
  00720	1a000035	 bne         |$LN4@UsbInterru|

; 1076 :                         {
; 1077 :                             /*TX successful*/
; 1078 :                             //pED->bfToggleCarry = (!pED->bfToggleCarry);
; 1079 :                             pED->bfToggleCarry = (_HOST_TXCSR & (0x1<<8));

  00724	e2023c01	 and         r3, r2, #1, 24
  00728	e1c532b8	 strh        r3, [r5, #0x28]

; 1080 :                             pTD->BytesTransferred += pTD->TXCOUNT;

  0072c	e59e005c	 ldr         r0, [lr, #0x5C]

; 1081 :                             pTD->BytesToTransfer -= pTD->TXCOUNT;

  00730	e59e3058	 ldr         r3, [lr, #0x58]
  00734	e59e1054	 ldr         r1, [lr, #0x54]

; 1082 :                             pTD->TXCOUNT = 0;

  00738	e3a09000	 mov         r9, #0
  0073c	e0433000	 sub         r3, r3, r0
  00740	e58e3058	 str         r3, [lr, #0x58]

; 1083 :                             if(pTD->BytesToTransfer)

  00744	e1a02003	 mov         r2, r3
  00748	e0803001	 add         r3, r0, r1
  0074c	e3520000	 cmp         r2, #0
  00750	e58e3054	 str         r3, [lr, #0x54]
  00754	e58e905c	 str         r9, [lr, #0x5C]

; 1084 :                             {
; 1085 :                                 pED->TransferStatus = STATUS_IDLE;

  00758	1585901c	 strne       r9, [r5, #0x1C]
  0075c	1a000026	 bne         |$LN4@UsbInterru|

; 1086 :                             }
; 1087 :                             else{
; 1088 :                                 *pTD->sTransfer.lpdwBytesTransferred = pTD->BytesTransferred;

  00760	e59e2044	 ldr         r2, [lr, #0x44]
  00764	e59e3054	 ldr         r3, [lr, #0x54]
  00768	e5823000	 str         r3, [r2]

; 1089 :                                 *pTD->sTransfer.lpfComplete = TRUE;

  0076c	e59e3040	 ldr         r3, [lr, #0x40]
  00770	e3a02001	 mov         r2, #1
  00774	e5832000	 str         r2, [r3]

; 1090 :                                 *pTD->sTransfer.lpdwError = USB_NO_ERROR;

  00778	e59e3048	 ldr         r3, [lr, #0x48]
  0077c	e5839000	 str         r9, [r3]

; 1091 :                                 pED->TransferStatus = STATUS_COMPLETE;

  00780	e3a03002	 mov         r3, #2
  00784	e585301c	 str         r3, [r5, #0x1C]

; 1092 :                             }
; 1093 :                         }
; 1094 :                         else
; 1095 :                         {
; 1096 :                             // TX not complete yet, wait for next interrupt
; 1097 :                             // RETAILMSG(1, (L"EP%d: TX not complete yet!\r\n", pED->bHostEndPointNum));
; 1098 :                         }
; 1099 :                     }
; 1100 :                     else{

  00788	ea00001b	 b           |$LN4@UsbInterru|
  0078c		 |$LN9@UsbInterru|

; 1101 :                         RETAILMSG(FALSE,(TEXT("_HOST_TXCSR = 0x%x"),_HOST_TXCSR));
; 1102 :                         TransferStatus Status = STATUS_COMPLETE;
; 1103 : 
; 1104 :                         if(_HOST_TXCSR & MGC_M_TXCSR_H_ERROR){

  0078c	e3120004	 tst         r2, #4

; 1105 :                             _HOST_TXCSR &= (~MGC_M_TXCSR_H_ERROR);

  00790	10022008	 andne       r2, r2, r8
  00794	e3a01002	 mov         r1, #2

; 1106 : 
; 1107 :                             //*pTD->sTransfer.lpdwBytesTransferred = pTD->BytesTransferred;
; 1108 :                             //*pTD->sTransfer.lpfComplete = TRUE;
; 1109 :                             //*pTD->sTransfer.lpdwError = USB_DEVICE_NOT_RESPONDING_ERROR;
; 1110 :                             Status = STATUS_NO_RESPONSE;

  00798	13a01003	 movne       r1, #3

; 1111 :                         }
; 1112 :                         if(_HOST_TXCSR & MGC_M_TXCSR_H_RXSTALL){

  0079c	e3120020	 tst         r2, #0x20
  007a0	0a00000a	 beq         |$LN2@UsbInterru|

; 1113 :                             _HOST_TXCSR &= (~MGC_M_TXCSR_H_RXSTALL);
; 1114 :                             //*pTD->sTransfer.lpdwBytesTransferred = pTD->BytesTransferred;
; 1115 :                             *pTD->sTransfer.lpfComplete = TRUE;

  007a4	e59e3040	 ldr         r3, [lr, #0x40]
  007a8	e3a00cff	 mov         r0, #0xFF, 24
  007ac	e38010df	 orr         r1, r0, #0xDF

; 1116 :                             *pTD->sTransfer.lpdwError = USB_STALL_ERROR;
; 1117 :                             pED->bfHalted = TRUE;
; 1118 :                             Status = STATUS_COMPLETE;

  007b0	e3a00001	 mov         r0, #1
  007b4	e5830000	 str         r0, [r3]
  007b8	e59e3048	 ldr         r3, [lr, #0x48]
  007bc	e3a0e004	 mov         lr, #4
  007c0	e0022001	 and         r2, r2, r1
  007c4	e583e000	 str         lr, [r3]
  007c8	e5850024	 str         r0, [r5, #0x24]
  007cc	e3a01002	 mov         r1, #2
  007d0		 |$LN2@UsbInterru|

; 1119 :                         }
; 1120 :                         if(_HOST_TXCSR & MGC_M_TXCSR_H_NAKTIMEOUT){

  007d0	e3120080	 tst         r2, #0x80

; 1121 :                             _HOST_TXCSR &= (~(MGC_M_TXCSR_H_NAKTIMEOUT|MGC_M_TXCSR_TXPKTRDY));

  007d4	13a01cff	 movne       r1, #0xFF, 24
  007d8	13813076	 orrne       r3, r1, #0x76
  007dc	10023003	 andne       r3, r2, r3

; 1122 :                             //*pTD->sTransfer.lpdwBytesTransferred = pTD->BytesTransferred;
; 1123 :                             //*pTD->sTransfer.lpfComplete = TRUE;
; 1124 :                             //*pTD->sTransfer.lpdwError = USB_DEVICE_NOT_RESPONDING_ERROR;
; 1125 :                             _HOST_TXCSR |= MGC_M_TXCSR_FLUSHFIFO;

  007e0	13832008	 orrne       r2, r3, #8

; 1126 :                             Status = STATUS_IDLE;
; 1127 :                         }
; 1128 :                         WRITE_PORT_USHORT( (m_portBase + MGC_END_OFFSET(bShift, MGC_O_HDRC_TXCSR)),_HOST_TXCSR);

  007e4	e5943140	 ldr         r3, [r4, #0x140]
  007e8	13a01000	 movne       r1, #0
  007ec	e0833206	 add         r3, r3, r6, lsl #4
  007f0	e2833c05	 add         r3, r3, #5, 24
  007f4	e1c320b2	 strh        r2, [r3, #2]

; 1129 :                         pED->TransferStatus = Status;

  007f8	e585101c	 str         r1, [r5, #0x1C]
  007fc		 |$LN4@UsbInterru|

; 1130 :                     }
; 1131 :                 }
; 1132 :             }
; 1133 :             Reg >>= 1;

  007fc	e1a030a7	 mov         r3, r7, lsr #1
  00800	e20370ff	 and         r7, r3, #0xFF

; 1134 :             bShift++;

  00804	e2863001	 add         r3, r6, #1
  00808	e20360ff	 and         r6, r3, #0xFF
  0080c	e1b02007	 movs        r2, r7
  00810	1affffab	 bne         |$LL16@UsbInterru|
  00814		 |$_skipTx$41828|

; 1135 :         }
; 1136 : 
; 1137 : _skipTx:
; 1138 : 
; 1139 :         UnlockProcessingThread();

  00814	e2840f89	 add         r0, r4, #0x89, 30
  00818	eb000000	 bl          LeaveCriticalSection

; 1140 : 
; 1141 :         SetEvent(g_hUsbProcessingEvent);

  0081c	e59f3038	 ldr         r3, [pc, #0x38]
  00820	e3a01003	 mov         r1, #3
  00824	e5930000	 ldr         r0, [r3]
  00828	eb000000	 bl          EventModify

; 1142 : 
; 1143 :         WRITE_PORT_ULONG((m_portBase + USB_EOIR_REG_OFFSET), 0);

  0082c	e5943140	 ldr         r3, [r4, #0x140]
  00830	e3a09000	 mov         r9, #0
  00834	e5839060	 str         r9, [r3, #0x60]

; 1144 : 
; 1145 :         InterruptDone(m_dwSysIntr);

  00838	e594016c	 ldr         r0, [r4, #0x16C]
  0083c	eb000000	 bl          InterruptDone
  00840	e59da00c	 ldr         r10, [sp, #0xC]
  00844	e59d7010	 ldr         r7, [sp, #0x10]
  00848	e59d8014	 ldr         r8, [sp, #0x14]
  0084c		 |$LN142@UsbInterru|
  0084c	e5943180	 ldr         r3, [r4, #0x180]
  00850	e3530000	 cmp         r3, #0
  00854	0afffdf8	 beq         |$LL89@UsbInterru|
  00858	eafffe22	 b           |$LN144@UsbInterru|
  0085c		 |$LN170@UsbInterru|
  0085c		 |$LN171@UsbInterru|
  0085c	00000000	 DCD         |?g_hUsbProcessingEvent@@3PAXA|
  00860		 |$LN172@UsbInterru|
  00860	00000000	 DCD         |??_C@_1GG@KJEIHILO@?$AAU?$AAS?$AAB?$AAH?$AA?3?$AA?5?$AAV?$AAB?$AAU?$AAS?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAd?$AAe?$AAt?$AAe?$AAc?$AAt?$AAe?$AAd?$AA?5?$AA?9?$AA?5?$AAr?$AAe?$AAs?$AAe@|
  00864		 |$LN173@UsbInterru|
  00864	00000000	 DCD         |g_IstThreadPriority|
  00868		 |$LN174@UsbInterru|
  00868	00000000	 DCD         |?CeResumeThreadStub@CHW@@CAKPAX@Z|
  0086c		 |$LN175@UsbInterru|
  0086c	00000000	 DCD         |??_C@_1II@MCJCLEKF@?$AAC?$AAH?$AAW?$AA?3?$AA?3?$AAU?$AAs?$AAb?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?3?$AA?5?$AAC?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5@|
  00870		 |$M43869|

			 ENDP  ; |?UsbInterruptThread@CHW@@AAAKPAX@Z|, CHW::UsbInterruptThread

	EXPORT	|?UsbProcessingThreadStub@CHW@@CAKPAX@Z| ; CHW::UsbProcessingThreadStub

  00000			 AREA	 |.pdata|, PDATA
|$T43887| DCD	|$LN5@UsbProcess@2|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UsbProcessingThreadStub@CHW@@CAKPAX@Z| PROC ; CHW::UsbProcessingThreadStub

; 1532 : {

  00000		 |$LN5@UsbProcess@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43884|

; 1533 :     return ((CHW *)context)->UsbProcessingThread();

  00004	eb000000	 bl          |?UsbProcessingThread@CHW@@AAAKXZ|

; 1534 : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M43885|

			 ENDP  ; |?UsbProcessingThreadStub@CHW@@CAKPAX@Z|, CHW::UsbProcessingThreadStub

	EXPORT	|?UsbInterruptThreadStub@CHW@@CAKPAX@Z|	; CHW::UsbInterruptThreadStub

  00000			 AREA	 |.pdata|, PDATA
|$T43897| DCD	|$LN5@UsbInterru@2|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UsbInterruptThreadStub@CHW@@CAKPAX@Z| PROC ; CHW::UsbInterruptThreadStub

; 647  : {

  00000		 |$LN5@UsbInterru@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43894|

; 648  :     return ((CHW *)context)->UsbInterruptThread(context);

  00004	e1a01000	 mov         r1, r0
  00008	eb000000	 bl          |?UsbInterruptThread@CHW@@AAAKPAX@Z|

; 649  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M43895|

			 ENDP  ; |?UsbInterruptThreadStub@CHW@@CAKPAX@Z|, CHW::UsbInterruptThreadStub

	IMPORT	|InterruptInitialize|
	IMPORT	|CreateEventW|
	IMPORT	|?Initialize@CCppiDmaController@@QAAHIPAX0@Z| ; CCppiDmaController::Initialize
	IMPORT	|?ReInit@CPhysMem@@QAAXXZ|		; CPhysMem::ReInit

  00000			 AREA	 |.pdata|, PDATA
|$T43907| DCD	|$LN13@Initialize@2|
	DCD	0x40006302
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Initialize@CHW@@UAAHXZ| PROC		; CHW::Initialize

; 335  : {

  00000		 |$LN13@Initialize@2|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M43904|
  00008	e1a04000	 mov         r4, r0

; 336  :     DEBUGMSG( ZONE_INIT, (TEXT("+CHW::Initialize base=0x%x, intr=0x%x\n"), m_portBase, m_dwSysIntr));
; 337  : 
; 338  : #ifdef DEBUG
; 339  :     dwTickCountLastTime = GetTickCount();
; 340  : #endif
; 341  : 
; 342  :     DEBUGCHK( m_wFrameHigh == 0 );
; 343  : 
; 344  :     if (!m_fConstructionStatus)

  0000c	e594314c	 ldr         r3, [r4, #0x14C]
  00010	e3530000	 cmp         r3, #0

; 345  :         return FALSE;

  00014	0a000054	 beq         |$LN4@Initialize@2|

; 346  : 
; 347  :     if ( m_portBase == 0 ) {

  00018	e5943140	 ldr         r3, [r4, #0x140]
  0001c	e3530000	 cmp         r3, #0

; 348  :         DEBUGMSG( ZONE_ERROR, (TEXT("-CHW::Initialize - zero Register Base\n")));
; 349  :         return FALSE;

  00020	0a000051	 beq         |$LN4@Initialize@2|

; 350  :     }
; 351  : 
; 352  :     m_pMem->ReInit();

  00024	e5940184	 ldr         r0, [r4, #0x184]
  00028	eb000000	 bl          |?ReInit@CPhysMem@@QAAXXZ|

; 353  : 
; 354  :     InitialiseFIFOs();

  0002c	e1a00004	 mov         r0, r4
  00030	eb000000	 bl          |?InitialiseFIFOs@CHW@@AAAXXZ|

; 355  :     m_bHostEndPointUseageCount = 1;
; 356  :     m_bulkEpNum = 0;
; 357  :     m_bulkEpUseCount = 0;
; 358  :     m_bulkEpConfigured = FALSE;
; 359  : 
; 360  : #ifdef MUSB_USEDMA
; 361  : 
; 362  :     m_pChw = this;

  00034	e59f614c	 ldr         r6, [pc, #0x14C]
  00038	e3a03001	 mov         r3, #1
  0003c	e3a07000	 mov         r7, #0
  00040	e5c43197	 strb        r3, [r4, #0x197]
  00044	e5c4719c	 strb        r7, [r4, #0x19C]
  00048	e5c4719d	 strb        r7, [r4, #0x19D]
  0004c	e58471a0	 str         r7, [r4, #0x1A0]
  00050	e5864004	 str         r4, [r6, #4]

; 363  : 
; 364  :     // Initialize DMA controller
; 365  :     if (!m_dmaCrtl.Initialize(AM3517_USB0_REGS_PA, m_portBase, m_cppiBase))

  00054	e5943144	 ldr         r3, [r4, #0x144]
  00058	e5942140	 ldr         r2, [r4, #0x140]
  0005c	e3a01317	 mov         r1, #0x17, 6
  00060	e3811701	 orr         r1, r1, #1, 14
  00064	e2840fca	 add         r0, r4, #0xCA, 30
  00068	eb000000	 bl          |?Initialize@CCppiDmaController@@QAAHIPAX0@Z|
  0006c	e3500000	 cmp         r0, #0

; 366  :     {
; 367  :         DEBUGMSG(ZONE_ERROR, (TEXT("-CHW::Initialize. Failed to initialize DMA\n")));
; 368  :         return FALSE;

  00070	e3a00000	 mov         r0, #0
  00074	0a00003d	 beq         |$LN9@Initialize@2|

; 369  :     }
; 370  : 
; 371  : #endif // MUSB_USEDMA
; 372  : 
; 373  :     DEBUGCHK( m_hUsbInterruptEvent == NULL );
; 374  :     m_hUsbInterruptEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

  00078	e3a03000	 mov         r3, #0
  0007c	e3a02000	 mov         r2, #0
  00080	e3a01000	 mov         r1, #0
  00084	eb000000	 bl          CreateEventW
  00088	e1a03000	 mov         r3, r0

; 375  :     m_hUsbHubChangeEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

  0008c	e5843170	 str         r3, [r4, #0x170]
  00090	e3a03000	 mov         r3, #0
  00094	e3a00000	 mov         r0, #0
  00098	e3a02000	 mov         r2, #0
  0009c	e3a01000	 mov         r1, #0
  000a0	eb000000	 bl          CreateEventW

; 376  :     if ( m_hUsbInterruptEvent == NULL || m_hUsbHubChangeEvent==NULL ){

  000a4	e5943170	 ldr         r3, [r4, #0x170]
  000a8	e584017c	 str         r0, [r4, #0x17C]
  000ac	e3530000	 cmp         r3, #0
  000b0	0a00002d	 beq         |$LN4@Initialize@2|
  000b4	e3500000	 cmp         r0, #0
  000b8	0a00002b	 beq         |$LN4@Initialize@2|

; 379  :     }
; 380  : 
; 381  :     InterruptDisable( m_dwSysIntr ); // Just to make sure this is really ours.

  000bc	e594016c	 ldr         r0, [r4, #0x16C]
  000c0	eb000000	 bl          InterruptDisable

; 382  :     // Initialize Interrupt. When interrupt id # m_sysIntr is triggered,
; 383  :     // m_hUsbInterruptEvent will be signaled. Last 2 params must be NULL
; 384  :     if ( !InterruptInitialize( m_dwSysIntr, m_hUsbInterruptEvent, NULL, NULL) ) {

  000c4	e5941170	 ldr         r1, [r4, #0x170]
  000c8	e594016c	 ldr         r0, [r4, #0x16C]
  000cc	e3a03000	 mov         r3, #0
  000d0	e3a02000	 mov         r2, #0
  000d4	eb000000	 bl          InterruptInitialize
  000d8	e3500000	 cmp         r0, #0

; 385  :         DEBUGMSG(ZONE_ERROR, (TEXT("-CHW::Initialize. Error on InterruptInitialize\r\n")));
; 386  :         return FALSE;

  000dc	e3a00000	 mov         r0, #0
  000e0	0a000022	 beq         |$LN9@Initialize@2|

; 387  :     }
; 388  : 
; 389  :     // Start up our IST - the parameter passed to the thread
; 390  :     // is unused for now
; 391  :     DEBUGCHK( m_hUsbInterruptThread == NULL &&
; 392  :               m_fUsbInterruptThreadClosing == FALSE );
; 393  :     m_hUsbInterruptThread = CreateThread( 0, 0, UsbInterruptThreadStub, this, 0, NULL );

  000e4	e59f2098	 ldr         r2, [pc, #0x98]
  000e8	e1a03004	 mov         r3, r4
  000ec	e3a01000	 mov         r1, #0
  000f0	e58d7004	 str         r7, [sp, #4]
  000f4	e58d7000	 str         r7, [sp]
  000f8	eb000000	 bl          CreateThread
  000fc	e3500000	 cmp         r0, #0
  00100	e5840174	 str         r0, [r4, #0x174]

; 394  :     if ( m_hUsbInterruptThread == NULL ) {
; 395  :         DEBUGMSG(ZONE_ERROR, (TEXT("-CHW::Initialize. Error creating IST\n")));
; 396  :         return FALSE;

  00104	0a000018	 beq         |$LN4@Initialize@2|

; 397  :     }
; 398  : 
; 399  :     CeSetThreadPriority( m_hUsbInterruptThread, g_IstThreadPriority );

  00108	e59f5070	 ldr         r5, [pc, #0x70]
  0010c	e5951000	 ldr         r1, [r5]
  00110	eb000000	 bl          CeSetThreadPriority

; 400  : 
; 401  :     g_hUsbProcessingEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

  00114	e3a03000	 mov         r3, #0
  00118	e3a02000	 mov         r2, #0
  0011c	e3a01000	 mov         r1, #0
  00120	e3a00000	 mov         r0, #0
  00124	eb000000	 bl          CreateEventW

; 402  :     m_hUsbProcessingThread = CreateThread( 0, 0, UsbProcessingThreadStub, this, 0, NULL );

  00128	e59f204c	 ldr         r2, [pc, #0x4C]
  0012c	e1a03000	 mov         r3, r0
  00130	e5863000	 str         r3, [r6]
  00134	e1a03004	 mov         r3, r4
  00138	e3a00000	 mov         r0, #0
  0013c	e3a01000	 mov         r1, #0
  00140	e58d7004	 str         r7, [sp, #4]
  00144	e58d7000	 str         r7, [sp]
  00148	eb000000	 bl          CreateThread
  0014c	e3500000	 cmp         r0, #0
  00150	e5840178	 str         r0, [r4, #0x178]

; 403  :     if ( m_hUsbProcessingThread == NULL ) {
; 404  :         DEBUGMSG(ZONE_ERROR, (TEXT("-CHW::Initialize. Error creating IST\n")));
; 405  :         return FALSE;

  00154	0a000004	 beq         |$LN4@Initialize@2|

; 406  :     }
; 407  : 
; 408  :     CeSetThreadPriority( m_hUsbProcessingThread, g_IstThreadPriority + 1 );

  00158	e5953000	 ldr         r3, [r5]
  0015c	e2831001	 add         r1, r3, #1
  00160	eb000000	 bl          CeSetThreadPriority

; 409  : 
; 410  :     DEBUGMSG(ZONE_INIT, (TEXT("-CHW::Initialize, success!\n")));
; 411  : 
; 412  :     return TRUE;

  00164	e3a00001	 mov         r0, #1
  00168	ea000000	 b           |$LN9@Initialize@2|
  0016c		 |$LN4@Initialize@2|

; 377  :         DEBUGMSG(ZONE_ERROR, (TEXT("-CHW::Initialize. Error creating USBInterrupt or USBHubEvent event\n")));
; 378  :         return FALSE;

  0016c	e3a00000	 mov         r0, #0
  00170		 |$LN9@Initialize@2|

; 413  : }

  00170	e28dd008	 add         sp, sp, #8
  00174	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00178	e12fff1e	 bx          lr
  0017c		 |$LN14@Initialize@2|
  0017c		 |$LN15@Initialize@2|
  0017c	00000000	 DCD         |?UsbProcessingThreadStub@CHW@@CAKPAX@Z|
  00180		 |$LN16@Initialize@2|
  00180	00000000	 DCD         |g_IstThreadPriority|
  00184		 |$LN17@Initialize@2|
  00184	00000000	 DCD         |?UsbInterruptThreadStub@CHW@@CAKPAX@Z|
  00188		 |$LN18@Initialize@2|
  00188	00000000	 DCD         |?g_hUsbProcessingEvent@@3PAXA|
  0018c		 |$M43905|

			 ENDP  ; |?Initialize@CHW@@UAAHXZ|, CHW::Initialize

	END
