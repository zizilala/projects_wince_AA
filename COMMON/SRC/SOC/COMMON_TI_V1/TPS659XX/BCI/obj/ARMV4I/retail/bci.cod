; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\TPS659XX\BCI\bci.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|DEVICE_IFC_MADC_GUID| [ DATA ]
	EXPORT	|DEVICE_IFC_TWL_GUID| [ DATA ]
	EXPORT	|hHotDieTriggerEvent_Test| [ DATA ]

  00000			 AREA	 |.bss|, NOINIT
|hHotDieTriggerEvent_Test| % 0x4

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
|DEVICE_IFC_MADC_GUID| DCD 0xe61ca799
	DCW	0x8ef5
	DCW	0x41e3
	DCB	0x82
	DCB	0x37
	DCB	0x2b
	DCB	0xd8
	DCB	0x87
	DCB	0x9b
	DCB	0xa4
	DCB	0xaf
|DEVICE_IFC_TWL_GUID| DCD 0xdef0a04b
	DCW	0xb967
	DCW	0x43db
	DCB	0x95
	DCB	0x9e
	DCB	0xd9
	DCB	0xfc
	DCB	0x62
	DCB	0x25
	DCB	0xcd
	DCB	0xeb
|_rgACCHGOVTH| DCD 0x157c
	DCD	0x1770
	DCD	0x1964
	DCD	0x1a90
|_rgVBATOVTH| DCD 0x11c6
	DCD	0x128e
	DCD	0x1356
	DCD	0x13ba
|_rgVBUSOVTH| DCD 0x157c
	DCD	0x1770
	DCD	0x1964
	DCD	0x1a90
	EXPORT	|PulseEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T44760| DCD	|$LN5@PulseEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PulseEvent| PROC

; 211  : _inline BOOL PulseEvent(HANDLE h) {

  00000		 |$LN5@PulseEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44757|

; 212  : 	return EventModify(h,EVENT_PULSE);

  00004	e3a01001	 mov         r1, #1
  00008	eb000000	 bl          EventModify

; 213  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M44758|

			 ENDP  ; |PulseEvent|

	EXPORT	|SetEvent|

  00000			 AREA	 |.pdata|, PDATA
|$T44770| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44767|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M44768|

			 ENDP  ; |SetEvent|

	EXPORT	|MADCOpen|
	EXPORT	|??_C@_1M@EPBPGMBG@?$AAA?$AAD?$AAC?$AA1?$AA?3?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|LocalFree|
	IMPORT	|DeviceIoControl|
	IMPORT	|CloseHandle|
	IMPORT	|LocalAlloc|
	IMPORT	|CreateFileW|
; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\inc\madc.h

  00000			 AREA	 |.pdata|, PDATA
|$T44781| DCD	|$LN8@MADCOpen|
	DCD	0x40003002

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1M@EPBPGMBG@?$AAA?$AAD?$AAC?$AA1?$AA?3?$AA?$AA@| DCB "A", 0x0, "D", 0x0
	DCB	"C", 0x0, "1", 0x0, ":", 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |MADCOpen| PROC

; 111  : {

  00000		 |$LN8@MADCOpen|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M44778|

; 112  :     HANDLE hDevice;
; 113  :     DEVICE_CONTEXT_MADC *pContext = NULL;
; 114  : 
; 115  :     hDevice = CreateFile(MADC_DEVICE_NAME, 0, 0, NULL, 0, 0, NULL);

  00008	e59f00ac	 ldr         r0, [pc, #0xAC]
  0000c	e3a06000	 mov         r6, #0
  00010	e3a03000	 mov         r3, #0
  00014	e3a02000	 mov         r2, #0
  00018	e3a01000	 mov         r1, #0
  0001c	e3a04000	 mov         r4, #0
  00020	e58d6008	 str         r6, [sp, #8]
  00024	e58d6004	 str         r6, [sp, #4]
  00028	e58d6000	 str         r6, [sp]
  0002c	eb000000	 bl          CreateFileW
  00030	e1a05000	 mov         r5, r0

; 116  :     if (hDevice == INVALID_HANDLE_VALUE) goto cleanUp;

  00034	e3750001	 cmn         r5, #1
  00038	0a00001a	 beq         |$cleanUp$43629|

; 117  : 
; 118  :     // Allocate memory for our handler...
; 119  :     pContext = (DEVICE_CONTEXT_MADC*)LocalAlloc(
; 120  :         LPTR, sizeof(DEVICE_CONTEXT_MADC)
; 121  :         );

  0003c	e3a01010	 mov         r1, #0x10
  00040	e3a00040	 mov         r0, #0x40
  00044	eb000000	 bl          LocalAlloc
  00048	e1b04000	 movs        r4, r0

; 122  :     if (pContext == NULL)
; 123  :         {
; 124  :         CloseHandle(hDevice);

  0004c	e1a00005	 mov         r0, r5
  00050	1a000001	 bne         |$LN2@MADCOpen|
  00054	eb000000	 bl          CloseHandle

; 125  :         goto cleanUp;

  00058	ea000012	 b           |$cleanUp$43629|
  0005c		 |$LN2@MADCOpen|

; 126  :         }
; 127  : 
; 128  :     // Get function pointers, fail when IOCTL isn't supported...
; 129  :     if (!DeviceIoControl(
; 130  :             hDevice, IOCTL_DDK_GET_DRIVER_IFC, (VOID*)&DEVICE_IFC_MADC_GUID,
; 131  :             sizeof(DEVICE_IFC_MADC_GUID), &pContext->ifc, sizeof(DEVICE_IFC_MADC),
; 132  :             NULL, NULL))

  0005c	e59f2054	 ldr         r2, [pc, #0x54]
  00060	e3a03822	 mov         r3, #0x22, 16
  00064	e3831b01	 orr         r1, r3, #1, 22
  00068	e3a0e00c	 mov         lr, #0xC
  0006c	e3a03010	 mov         r3, #0x10
  00070	e58d600c	 str         r6, [sp, #0xC]
  00074	e58d6008	 str         r6, [sp, #8]
  00078	e58de004	 str         lr, [sp, #4]
  0007c	e58d4000	 str         r4, [sp]
  00080	eb000000	 bl          DeviceIoControl
  00084	e3500000	 cmp         r0, #0
  00088	1a000005	 bne         |$LN1@MADCOpen|

; 133  :         {
; 134  :         CloseHandle(hDevice);

  0008c	e1a00005	 mov         r0, r5
  00090	eb000000	 bl          CloseHandle

; 135  :         LocalFree(pContext);

  00094	e1a00004	 mov         r0, r4
  00098	eb000000	 bl          LocalFree

; 136  :         pContext = NULL;

  0009c	e3a04000	 mov         r4, #0

; 137  :         goto cleanUp;

  000a0	ea000000	 b           |$cleanUp$43629|
  000a4		 |$LN1@MADCOpen|

; 138  :         }
; 139  : 
; 140  :     // Save device handle
; 141  :     pContext->hDevice = hDevice;

  000a4	e584500c	 str         r5, [r4, #0xC]
  000a8		 |$cleanUp$43629|

; 142  : 
; 143  : cleanUp:
; 144  :     return pContext;
; 145  : }

  000a8	e1a00004	 mov         r0, r4
  000ac	e28dd010	 add         sp, sp, #0x10
  000b0	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000b4	e12fff1e	 bx          lr
  000b8		 |$LN9@MADCOpen|
  000b8		 |$LN10@MADCOpen|
  000b8	00000000	 DCD         |DEVICE_IFC_MADC_GUID|
  000bc		 |$LN11@MADCOpen|
  000bc	00000000	 DCD         |??_C@_1M@EPBPGMBG@?$AAA?$AAD?$AAC?$AA1?$AA?3?$AA?$AA@|
  000c0		 |$M44779|

			 ENDP  ; |MADCOpen|

	EXPORT	|MADCReadValue|

  00000			 AREA	 |.pdata|, PDATA
|$T44797| DCD	|$LN5@MADCReadVa|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |MADCReadValue| PROC

; 166  : {

  00000		 |$LN5@MADCReadVa|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M44794|
  00004	e1a0e000	 mov         lr, r0

; 167  :     DEVICE_CONTEXT_MADC *pContext = (DEVICE_CONTEXT_MADC*)hContext;
; 168  :     return pContext->ifc.pfnReadValue(
; 169  :         pContext->ifc.context, mask, pdwResults, size
; 170  :         );

  00008	e59e0000	 ldr         r0, [lr]
  0000c	e59e4004	 ldr         r4, [lr, #4]
  00010	e1a0e00f	 mov         lr, pc
  00014	e12fff14	 bx          r4

; 171  : }

  00018	e8bd4010	 ldmia       sp!, {r4, lr}
  0001c	e12fff1e	 bx          lr
  00020		 |$M44795|

			 ENDP  ; |MADCReadValue|

	EXPORT	|MADCConvertToVolts|

  00000			 AREA	 |.pdata|, PDATA
|$T44810| DCD	|$LN5@MADCConver|
	DCD	0x40000c02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |MADCConvertToVolts| PROC

; 183  : {

  00000		 |$LN5@MADCConver|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M44807|
  00008	e1a04000	 mov         r4, r0

; 184  :     DEVICE_CONTEXT_MADC *pContext = (DEVICE_CONTEXT_MADC*)hContext;
; 185  :     return pContext->ifc.pfnConvertToVolts(
; 186  :         pContext->ifc.context, channel, pdwValues, pResults, count
; 187  :         );

  0000c	e59de00c	 ldr         lr, [sp, #0xC]
  00010	e5940000	 ldr         r0, [r4]
  00014	e5944008	 ldr         r4, [r4, #8]
  00018	e58de000	 str         lr, [sp]
  0001c	e1a0e00f	 mov         lr, pc
  00020	e12fff14	 bx          r4

; 188  : }

  00024	e28dd004	 add         sp, sp, #4
  00028	e8bd4010	 ldmia       sp!, {r4, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$M44808|

			 ENDP  ; |MADCConvertToVolts|

	IMPORT	|TWLReadRegs|
	IMPORT	|TWLWriteRegs|
; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\bci\bci.c

  00000			 AREA	 |.pdata|, PDATA
|$T44821| DCD	|$LN8@QueryVolta|
	DCD	0x40002b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |QueryVoltageMonitors| PROC

; 121  : {

  00000		 |$LN8@QueryVolta|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M44818|
  00008	e1a05000	 mov         r5, r0

; 122  :     UINT8 data;
; 123  :     DWORD dwResult = 0;
; 124  :     DEBUGMSG(ZONE_FUNCTION, (L"+QueryVoltageMonitors(pDevice=0x%08X)\r\n",
; 125  :         pDevice
; 126  :         ));
; 127  : 
; 128  :     // get access to BCIMFEN2
; 129  :     data = KEY_BCIMFEN2;
; 130  :     TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  0000c	e5950018	 ldr         r0, [r5, #0x18]
  00010	e3a06802	 mov         r6, #2, 16
  00014	e3a0e073	 mov         lr, #0x73
  00018	e3861085	 orr         r1, r6, #0x85
  0001c	e3a03001	 mov         r3, #1
  00020	e28d2000	 add         r2, sp, #0
  00024	e3a04000	 mov         r4, #0
  00028	e5cde000	 strb        lr, [sp]
  0002c	eb000000	 bl          TWLWriteRegs

; 131  : 
; 132  :     // update over-charge monitors
; 133  :     TWLReadRegs(pDevice->hTwl, TWL_BCIMFEN2, &data, 1);

  00030	e5950018	 ldr         r0, [r5, #0x18]
  00034	e3a03802	 mov         r3, #2, 16
  00038	e3831087	 orr         r1, r3, #0x87
  0003c	e3a03001	 mov         r3, #1
  00040	e28d2000	 add         r2, sp, #0
  00044	eb000000	 bl          TWLReadRegs

; 134  :     if (data & ACCHGOVEN) dwResult |= BCI_OV_VAC;

  00048	e5dd3000	 ldrb        r3, [sp]

; 135  :     if (data & VBUSOVEN) dwResult |= BCI_OV_VBUS;
; 136  : 
; 137  :     // get access to BCIMFEN4
; 138  :     data = KEY_BCIMFEN4;
; 139  :     TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  0004c	e5950018	 ldr         r0, [r5, #0x18]
  00050	e3a0e03e	 mov         lr, #0x3E
  00054	e3130080	 tst         r3, #0x80
  00058	13a04004	 movne       r4, #4
  0005c	e3130020	 tst         r3, #0x20
  00060	e3a03001	 mov         r3, #1
  00064	e28d2000	 add         r2, sp, #0
  00068	e3861085	 orr         r1, r6, #0x85
  0006c	13844002	 orrne       r4, r4, #2
  00070	e5cde000	 strb        lr, [sp]
  00074	eb000000	 bl          TWLWriteRegs

; 140  : 
; 141  :     // update over-charge monitors
; 142  :     TWLReadRegs(pDevice->hTwl, TWL_BCIMFEN4, &data, 1);

  00078	e5950018	 ldr         r0, [r5, #0x18]
  0007c	e3a03802	 mov         r3, #2, 16
  00080	e3831089	 orr         r1, r3, #0x89
  00084	e3a03001	 mov         r3, #1
  00088	e28d2000	 add         r2, sp, #0
  0008c	eb000000	 bl          TWLReadRegs

; 143  :     if (data & VBATOVEN) dwResult |= BCI_OV_VBAT;

  00090	e5dd3000	 ldrb        r3, [sp]
  00094	e3130002	 tst         r3, #2
  00098	13844001	 orrne       r4, r4, #1

; 144  : 
; 145  :     DEBUGMSG(ZONE_FUNCTION, (L"-QueryVoltageMonitors()\r\n"));
; 146  :     return dwResult;
; 147  : }

  0009c	e1a00004	 mov         r0, r4
  000a0	e28dd004	 add         sp, sp, #4
  000a4	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000a8	e12fff1e	 bx          lr
  000ac		 |$M44819|

			 ENDP  ; |QueryVoltageMonitors|


  00000			 AREA	 |.pdata|, PDATA
|$T44832| DCD	|$LN7@QueryTempe|
	DCD	0x40001a02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |QueryTemperatureMonitors| PROC

; 159  : {

  00000		 |$LN7@QueryTempe|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M44829|
  00008	e1a04000	 mov         r4, r0

; 160  :     UINT8 data;
; 161  :     DWORD dwResult = 0;
; 162  :     DEBUGMSG(ZONE_FUNCTION, (L"+QueryTemperatureMonitors(pDevice=0x%08X)\r\n",
; 163  :         pDevice
; 164  :         ));
; 165  : 
; 166  :     // get access to BCIMFEN2
; 167  :     data = KEY_BCIMFEN2;
; 168  :     TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  0000c	e5940018	 ldr         r0, [r4, #0x18]
  00010	e3a06802	 mov         r6, #2, 16
  00014	e3a0e073	 mov         lr, #0x73
  00018	e3861085	 orr         r1, r6, #0x85
  0001c	e3a03001	 mov         r3, #1
  00020	e28d2000	 add         r2, sp, #0
  00024	e3a05000	 mov         r5, #0
  00028	e5cde000	 strb        lr, [sp]
  0002c	eb000000	 bl          TWLWriteRegs

; 169  : 
; 170  :     // check temperature monitors
; 171  :     TWLReadRegs(pDevice->hTwl, TWL_BCIMFEN2, &data, 1);

  00030	e5940018	 ldr         r0, [r4, #0x18]
  00034	e3a03001	 mov         r3, #1
  00038	e28d2000	 add         r2, sp, #0
  0003c	e3861087	 orr         r1, r6, #0x87
  00040	eb000000	 bl          TWLReadRegs

; 172  :     if (data & TBATOR1EN) dwResult |= BCI_TEMP_VBAT1;

  00044	e5dd3000	 ldrb        r3, [sp]
  00048	e3130008	 tst         r3, #8
  0004c	13a05001	 movne       r5, #1

; 173  :     if (data & TBATOR2EN) dwResult |= BCI_TEMP_VBAT2;

  00050	e3130002	 tst         r3, #2
  00054	13855002	 orrne       r5, r5, #2

; 174  : 
; 175  :     DEBUGMSG(ZONE_FUNCTION, (L"-QueryTemperatureMonitors()\r\n"));
; 176  :     return dwResult;
; 177  : }

  00058	e1a00005	 mov         r0, r5
  0005c	e28dd004	 add         sp, sp, #4
  00060	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00064	e12fff1e	 bx          lr
  00068		 |$M44830|

			 ENDP  ; |QueryTemperatureMonitors|


  00000			 AREA	 |.pdata|, PDATA
|$T44843| DCD	|$LN8@QueryCurre|
	DCD	0x40002302
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |QueryCurrentMonitors| PROC

; 189  : {

  00000		 |$LN8@QueryCurre|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M44840|
  00008	e1a05000	 mov         r5, r0

; 190  :     UINT8 data;
; 191  :     DWORD dwResult = 0;
; 192  :     DEBUGMSG(ZONE_FUNCTION, (L"+QueryChargeMonitors(pDevice=0x%08X)\r\n",
; 193  :         pDevice
; 194  :         ));
; 195  : 
; 196  :     // get access to BCIMFEN2
; 197  :     data = KEY_BCIMFEN3;
; 198  :     TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  0000c	e5950018	 ldr         r0, [r5, #0x18]
  00010	e3a06802	 mov         r6, #2, 16
  00014	e3a0e09c	 mov         lr, #0x9C
  00018	e3861085	 orr         r1, r6, #0x85
  0001c	e3a03001	 mov         r3, #1
  00020	e28d2000	 add         r2, sp, #0
  00024	e3a04000	 mov         r4, #0
  00028	e5cde000	 strb        lr, [sp]
  0002c	eb000000	 bl          TWLWriteRegs

; 199  : 
; 200  :     // check charging monitors
; 201  :     TWLReadRegs(pDevice->hTwl, TWL_BCIMFEN3, &data, 1);

  00030	e5950018	 ldr         r0, [r5, #0x18]
  00034	e3a03001	 mov         r3, #1
  00038	e28d2000	 add         r2, sp, #0
  0003c	e3861088	 orr         r1, r6, #0x88
  00040	eb000000	 bl          TWLReadRegs

; 202  :     if (data & ICHGHIGHEN) dwResult |= BCI_OC_VBAT;

  00044	e5dd3000	 ldrb        r3, [sp]

; 203  :     if (data & ICHGEOCEN) dwResult |= BCI_EOC_VBAT;
; 204  : 
; 205  :     // check current gain settings
; 206  :     TWLReadRegs(pDevice->hTwl, TWL_BCICTL1, &data, 1);

  00048	e5950018	 ldr         r0, [r5, #0x18]
  0004c	e28d2000	 add         r2, sp, #0
  00050	e3130008	 tst         r3, #8
  00054	13a04001	 movne       r4, #1
  00058	e3130080	 tst         r3, #0x80
  0005c	e3a03802	 mov         r3, #2, 16
  00060	e3831097	 orr         r1, r3, #0x97
  00064	e3a03001	 mov         r3, #1
  00068	13844002	 orrne       r4, r4, #2
  0006c	eb000000	 bl          TWLReadRegs

; 207  :     if (data & CGAIN) dwResult |= BCI_CGAIN_VBAT;

  00070	e5dd3000	 ldrb        r3, [sp]
  00074	e3130020	 tst         r3, #0x20
  00078	13844003	 orrne       r4, r4, #3

; 208  : 
; 209  :     DEBUGMSG(ZONE_FUNCTION, (L"-QueryChargeMonitors()\r\n"));
; 210  :     return dwResult;
; 211  : }

  0007c	e1a00004	 mov         r0, r4
  00080	e28dd004	 add         sp, sp, #4
  00084	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$M44841|

			 ENDP  ; |QueryCurrentMonitors|


  00000			 AREA	 |.pdata|, PDATA
|$T44856| DCD	|$LN9@GetCurrent|
	DCD	0x40003b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentThreshold| PROC

; 337  : {

  00000		 |$LN9@GetCurrent|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M44853|
  00008	e1a05000	 mov         r5, r0

; 338  :     UINT8 data;
; 339  :     UINT8 threshold = 0;    

  0000c	e3a00000	 mov         r0, #0

; 340  :     DEBUGMSG(ZONE_FUNCTION, (L"+GetCurrentThreshold("
; 341  :         L"pDevice=0x%08X, ffMask=%d)\r\n",
; 342  :         pDevice, ffMask
; 343  :         ));
; 344  : 
; 345  :     switch (ffMask)

  00010	e3510001	 cmp         r1, #1
  00014	0a000012	 beq         |$LN2@GetCurrent|
  00018	e3510002	 cmp         r1, #2
  0001c	1a00002f	 bne         |$LN3@GetCurrent|

; 359  :             break;
; 360  : 
; 361  :         case BCI_EOC_VBAT:
; 362  :             // get access to BCIMFTH6
; 363  :             data = KEY_BCIMFTH8;
; 364  :             TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  00020	e5950018	 ldr         r0, [r5, #0x18]
  00024	e3a04802	 mov         r4, #2, 16
  00028	e3a0e0f4	 mov         lr, #0xF4
  0002c	e3841085	 orr         r1, r4, #0x85
  00030	e3a03001	 mov         r3, #1
  00034	e28d2000	 add         r2, sp, #0
  00038	e5cde000	 strb        lr, [sp]
  0003c	eb000000	 bl          TWLWriteRegs

; 365  :             TWLReadRegs(pDevice->hTwl, TWL_BCIMFTH8, &data, 1);

  00040	e5950018	 ldr         r0, [r5, #0x18]
  00044	e3a03001	 mov         r3, #1
  00048	e28d2000	 add         r2, sp, #0
  0004c	e3841091	 orr         r1, r4, #0x91
  00050	eb000000	 bl          TWLReadRegs

; 366  :             threshold = (data & 0xF0) >> 4;

  00054	e5dd3000	 ldrb        r3, [sp]
  00058	e1a03223	 mov         r3, r3, lsr #4
  0005c	e20300ff	 and         r0, r3, #0xFF

; 367  :             break;            

  00060	ea00001e	 b           |$LN3@GetCurrent|
  00064		 |$LN2@GetCurrent|

; 346  :         {
; 347  :         case BCI_OC_VBAT:
; 348  :             // get access to BCIMFTH8
; 349  :             data = KEY_BCIMFTH8;
; 350  :             TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  00064	e5950018	 ldr         r0, [r5, #0x18]
  00068	e3a07802	 mov         r7, #2, 16
  0006c	e3a0e0f4	 mov         lr, #0xF4
  00070	e3871085	 orr         r1, r7, #0x85
  00074	e3a03001	 mov         r3, #1
  00078	e28d2000	 add         r2, sp, #0
  0007c	e5cde000	 strb        lr, [sp]
  00080	eb000000	 bl          TWLWriteRegs

; 351  :             TWLReadRegs(pDevice->hTwl, TWL_BCIMFTH8, &data, 1);

  00084	e5950018	 ldr         r0, [r5, #0x18]
  00088	e3a06802	 mov         r6, #2, 16
  0008c	e3861091	 orr         r1, r6, #0x91
  00090	e3a03001	 mov         r3, #1
  00094	e28d2000	 add         r2, sp, #0
  00098	eb000000	 bl          TWLReadRegs

; 352  :             threshold = (data & 0x0F);

  0009c	e5dd3000	 ldrb        r3, [sp]

; 353  :             
; 354  :             // get access to BCIMFTH9
; 355  :             data = KEY_BCIMFTH9;
; 356  :             TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  000a0	e5950018	 ldr         r0, [r5, #0x18]
  000a4	e3a0e0e7	 mov         lr, #0xE7
  000a8	e203400f	 and         r4, r3, #0xF
  000ac	e3a03001	 mov         r3, #1
  000b0	e28d2000	 add         r2, sp, #0
  000b4	e3871085	 orr         r1, r7, #0x85
  000b8	e5cde000	 strb        lr, [sp]
  000bc	eb000000	 bl          TWLWriteRegs

; 357  :             TWLReadRegs(pDevice->hTwl, TWL_BCIMFTH9, &data, 1);

  000c0	e5950018	 ldr         r0, [r5, #0x18]
  000c4	e3a03001	 mov         r3, #1
  000c8	e28d2000	 add         r2, sp, #0
  000cc	e3861092	 orr         r1, r6, #0x92
  000d0	eb000000	 bl          TWLReadRegs

; 358  :             threshold |= (data & 0xF0);            

  000d4	e5dd3000	 ldrb        r3, [sp]
  000d8	e20330f0	 and         r3, r3, #0xF0
  000dc	e1830004	 orr         r0, r3, r4
  000e0		 |$LN3@GetCurrent|

; 368  :         }   
; 369  : 
; 370  :     DEBUGMSG(ZONE_FUNCTION, (L"-GetCurrentThreshold()\r\n"));
; 371  :     return threshold;    
; 372  : }

  000e0	e28dd004	 add         sp, sp, #4
  000e4	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000e8	e12fff1e	 bx          lr
  000ec		 |$M44854|

			 ENDP  ; |GetCurrentThreshold|


  00000			 AREA	 |.pdata|, PDATA
|$T44870| DCD	|$LN11@GetVoltage|
	DCD	0x40002502
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetVoltageThreshold| PROC

; 385  : {

  00000		 |$LN11@GetVoltage|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M44867|
  00008	e1a05001	 mov         r5, r1
  0000c	e1a04000	 mov         r4, r0

; 386  :     UINT8 data = 0;
; 387  :     DEBUGMSG(ZONE_FUNCTION, (L"+GetVoltageThreshold("
; 388  :         L"pDevice=0x%08X, ffMask=%d)\r\n",
; 389  :         pDevice, ffMask
; 390  :         ));
; 391  : 
; 392  :     // get access to BCIMFTH3
; 393  :     data = KEY_BCIMFTH3;
; 394  :     TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  00010	e5940018	 ldr         r0, [r4, #0x18]
  00014	e3a06802	 mov         r6, #2, 16
  00018	e3a0e06d	 mov         lr, #0x6D
  0001c	e3861085	 orr         r1, r6, #0x85
  00020	e3a03001	 mov         r3, #1
  00024	e28d2000	 add         r2, sp, #0
  00028	e5cde000	 strb        lr, [sp]
  0002c	eb000000	 bl          TWLWriteRegs

; 395  : 
; 396  :     // get contents
; 397  :     TWLReadRegs(pDevice->hTwl, TWL_BCIMFTH3, &data, 1);

  00030	e5940018	 ldr         r0, [r4, #0x18]
  00034	e3a03001	 mov         r3, #1
  00038	e28d2000	 add         r2, sp, #0
  0003c	e386108c	 orr         r1, r6, #0x8C
  00040	eb000000	 bl          TWLReadRegs

; 398  :     switch (ffMask)

  00044	e3550001	 cmp         r5, #1
  00048	0a00000b	 beq         |$LN1@GetVoltage|
  0004c	e3550002	 cmp         r5, #2
  00050	0a000006	 beq         |$LN2@GetVoltage|
  00054	e3550004	 cmp         r5, #4

; 399  :         {
; 400  :         case BCI_OV_VAC:
; 401  :             data = (data & ACCHGOVTH) >> 2;

  00058	05dd3000	 ldreqb      r3, [sp]
  0005c	0203300c	 andeq       r3, r3, #0xC
  00060	01a00123	 moveq       r0, r3, lsr #2
  00064	0a000007	 beq         |$LN4@GetVoltage|

; 407  :             
; 408  :         case BCI_OV_VBAT:
; 409  :             data = (data & VBATOVTH) >> 4;

  00068	e5dd0000	 ldrb        r0, [sp]
  0006c	ea000005	 b           |$LN4@GetVoltage|
  00070		 |$LN2@GetVoltage|

; 402  :             break;
; 403  : 
; 404  :         case BCI_OV_VBUS:
; 405  :             data = (data & VBUSOVTH);

  00070	e5dd3000	 ldrb        r3, [sp]
  00074	e2030003	 and         r0, r3, #3

; 406  :             break;

  00078	ea000002	 b           |$LN4@GetVoltage|
  0007c		 |$LN1@GetVoltage|

; 407  :             
; 408  :         case BCI_OV_VBAT:
; 409  :             data = (data & VBATOVTH) >> 4;

  0007c	e5dd3000	 ldrb        r3, [sp]
  00080	e2033030	 and         r3, r3, #0x30
  00084	e1a00223	 mov         r0, r3, lsr #4
  00088		 |$LN4@GetVoltage|

; 410  :             break;
; 411  :         }
; 412  : 
; 413  :     DEBUGMSG(ZONE_FUNCTION, (L"-GetVoltageThreshold()\r\n"));
; 414  :     return data;    
; 415  : }

  00088	e28dd004	 add         sp, sp, #4
  0008c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$M44868|

			 ENDP  ; |GetVoltageThreshold|


  00000			 AREA	 |.pdata|, PDATA
|$T44885| DCD	|$LN12@GetTempera|
	DCD	0x40004402
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetTemperatureThreshold| PROC

; 430  : {

  00000		 |$LN12@GetTempera|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M44882|
  00008	e1a04003	 mov         r4, r3
  0000c	e1b06002	 movs        r6, r2
  00010	e1a05000	 mov         r5, r0

; 431  :     UINT8 data = 0;
; 432  :     BOOL bResult = FALSE;

  00014	e3a00000	 mov         r0, #0

; 433  :     DEBUGMSG(ZONE_FUNCTION, (L"+GetTemperatureThreshold("
; 434  :         L"pDevice=0x%08X, ffMask=%d)\r\n",
; 435  :         pDevice, ffMask
; 436  :         ));
; 437  : 
; 438  :     if (pThresholdHigh == NULL || pThresholdLow == NULL) goto cleanUp;

  00018	0a000039	 beq         |$cleanUp$43955|
  0001c	e3540000	 cmp         r4, #0
  00020	0a000037	 beq         |$cleanUp$43955|

; 439  : 
; 440  :     switch (ffMask)

  00024	e3510001	 cmp         r1, #1
  00028	0a000019	 beq         |$LN2@GetTempera|
  0002c	e3510002	 cmp         r1, #2
  00030	1a000033	 bne         |$cleanUp$43955|

; 459  :             break;
; 460  : 
; 461  :         case BCI_TEMP_VBAT2:
; 462  :             // get access to BCIMFTH6
; 463  :             data = KEY_BCIMFTH6;
; 464  :             TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  00034	e3a03802	 mov         r3, #2, 16
  00038	e5950018	 ldr         r0, [r5, #0x18]
  0003c	e3837085	 orr         r7, r3, #0x85
  00040	e3a0e0bc	 mov         lr, #0xBC
  00044	e1a01007	 mov         r1, r7
  00048	e3a03001	 mov         r3, #1
  0004c	e28d2000	 add         r2, sp, #0
  00050	e5cde000	 strb        lr, [sp]
  00054	eb000000	 bl          TWLWriteRegs

; 465  : 
; 466  :             TWLReadRegs(pDevice->hTwl, TWL_BCIMFTH6, 
; 467  :                 pThresholdLow, 1
; 468  :                 );

  00058	e5950018	 ldr         r0, [r5, #0x18]
  0005c	e3a08802	 mov         r8, #2, 16
  00060	e388108f	 orr         r1, r8, #0x8F
  00064	e3a03001	 mov         r3, #1
  00068	e1a02004	 mov         r2, r4
  0006c	eb000000	 bl          TWLReadRegs

; 469  : 
; 470  :             // get access to BCIMFTH7
; 471  :             data = KEY_BCIMFTH7;
; 472  :             TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  00070	e5950018	 ldr         r0, [r5, #0x18]
  00074	e3a0e0c3	 mov         lr, #0xC3
  00078	e3a03001	 mov         r3, #1
  0007c	e28d2000	 add         r2, sp, #0
  00080	e1a01007	 mov         r1, r7
  00084	e5cde000	 strb        lr, [sp]
  00088	eb000000	 bl          TWLWriteRegs

; 473  : 
; 474  :             TWLReadRegs(pDevice->hTwl, TWL_BCIMFTH7, 
; 475  :                 pThresholdHigh, 1
; 476  :                 );  

  0008c	e3881090	 orr         r1, r8, #0x90

; 477  :             bResult = TRUE;
; 478  :             break;            

  00090	ea000016	 b           |$LN9@GetTempera|
  00094		 |$LN2@GetTempera|

; 441  :         {
; 442  :         case BCI_TEMP_VBAT1:
; 443  :             // get access to BCIMFTH4
; 444  :             data = KEY_BCIMFTH4;
; 445  :             TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  00094	e3a03802	 mov         r3, #2, 16
  00098	e5950018	 ldr         r0, [r5, #0x18]
  0009c	e3837085	 orr         r7, r3, #0x85
  000a0	e3a0e0ea	 mov         lr, #0xEA
  000a4	e1a01007	 mov         r1, r7
  000a8	e3a03001	 mov         r3, #1
  000ac	e28d2000	 add         r2, sp, #0
  000b0	e5cde000	 strb        lr, [sp]
  000b4	eb000000	 bl          TWLWriteRegs

; 446  : 
; 447  :             TWLReadRegs(pDevice->hTwl, TWL_BCIMFTH4, 
; 448  :                 pThresholdLow, 1
; 449  :                 );

  000b8	e5950018	 ldr         r0, [r5, #0x18]
  000bc	e3a08802	 mov         r8, #2, 16
  000c0	e388108d	 orr         r1, r8, #0x8D
  000c4	e3a03001	 mov         r3, #1
  000c8	e1a02004	 mov         r2, r4
  000cc	eb000000	 bl          TWLReadRegs

; 450  :             
; 451  :             // get access to BCIMFTH5
; 452  :             data = KEY_BCIMFTH5;
; 453  :             TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  000d0	e5950018	 ldr         r0, [r5, #0x18]
  000d4	e3a0e0c4	 mov         lr, #0xC4
  000d8	e3a03001	 mov         r3, #1
  000dc	e28d2000	 add         r2, sp, #0
  000e0	e1a01007	 mov         r1, r7
  000e4	e5cde000	 strb        lr, [sp]
  000e8	eb000000	 bl          TWLWriteRegs

; 454  : 
; 455  :             TWLReadRegs(pDevice->hTwl, TWL_BCIMFTH5, 
; 456  :                 pThresholdHigh, 1
; 457  :                 );            

  000ec	e388108e	 orr         r1, r8, #0x8E
  000f0		 |$LN9@GetTempera|
  000f0	e5950018	 ldr         r0, [r5, #0x18]
  000f4	e3a03001	 mov         r3, #1
  000f8	e1a02006	 mov         r2, r6
  000fc	eb000000	 bl          TWLReadRegs

; 458  :             bResult = TRUE;

  00100	e3a00001	 mov         r0, #1
  00104		 |$cleanUp$43955|

; 479  :         }
; 480  : 
; 481  : cleanUp:
; 482  :     DEBUGMSG(ZONE_FUNCTION, (L"-GetTemperatureThreshold()\r\n"));
; 483  :     return bResult;    
; 484  : }

  00104	e28dd004	 add         sp, sp, #4
  00108	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0010c	e12fff1e	 bx          lr
  00110		 |$M44883|

			 ENDP  ; |GetTemperatureThreshold|


  00000			 AREA	 |.pdata|, PDATA
|$T44901| DCD	|$LN12@SetCurrent|
	DCD	0x40005602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetCurrentThreshold| PROC

; 498  : {

  00000		 |$LN12@SetCurrent|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M44898|
  00008	e1a06002	 mov         r6, r2
  0000c	e1a04000	 mov         r4, r0

; 499  :     UINT8 data;
; 500  :     BOOL bResult = FALSE;

  00010	e3a05000	 mov         r5, #0

; 501  :     DEBUGMSG(ZONE_FUNCTION, (L"+SetCurrentThreshold("
; 502  :         L"pDevice=0x%08X, ffMask=%d, threshold=%d,\r\n",
; 503  :         pDevice, ffMask, threshold
; 504  :         ));
; 505  : 
; 506  :     switch (ffMask)

  00014	e3510001	 cmp         r1, #1
  00018	0a000015	 beq         |$LN3@SetCurrent|
  0001c	e3510002	 cmp         r1, #2
  00020	1a000048	 bne         |$LN1@SetCurrent|

; 524  :             bResult = TRUE;
; 525  :             break;
; 526  : 
; 527  :         case BCI_EOC_VBAT:
; 528  :             // get access to BCIMFTH6
; 529  :             data = KEY_BCIMFTH8;
; 530  :             TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  00024	e5940018	 ldr         r0, [r4, #0x18]
  00028	e3a05802	 mov         r5, #2, 16
  0002c	e3a0e0f4	 mov         lr, #0xF4
  00030	e3851085	 orr         r1, r5, #0x85
  00034	e3a03001	 mov         r3, #1
  00038	e28d2000	 add         r2, sp, #0
  0003c	e5cde000	 strb        lr, [sp]
  00040	eb000000	 bl          TWLWriteRegs

; 531  :             TWLReadRegs(pDevice->hTwl, TWL_BCIMFTH8, &data, 1);

  00044	e5940018	 ldr         r0, [r4, #0x18]
  00048	e3855091	 orr         r5, r5, #0x91
  0004c	e1a01005	 mov         r1, r5
  00050	e3a03001	 mov         r3, #1
  00054	e28d2000	 add         r2, sp, #0
  00058	eb000000	 bl          TWLReadRegs

; 532  : 
; 533  :             data = (data & 0x0F) | (threshold << 4);

  0005c	e5dd2000	 ldrb        r2, [sp]

; 534  :             TWLWriteRegs(pDevice->hTwl, TWL_BCIMFTH8, &data, 1);

  00060	e1a01005	 mov         r1, r5
  00064	e202200f	 and         r2, r2, #0xF
  00068	e1822206	 orr         r2, r2, r6, lsl #4
  0006c	e5cd2000	 strb        r2, [sp]

; 535  :             bResult = TRUE;
; 536  :             break;            

  00070	ea000029	 b           |$LN9@SetCurrent|
  00074		 |$LN3@SetCurrent|

; 507  :         {
; 508  :         case BCI_OC_VBAT:
; 509  :             // get access to BCIMFTH8
; 510  :             data = KEY_BCIMFTH8;
; 511  :             TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  00074	e5940018	 ldr         r0, [r4, #0x18]
  00078	e3a07802	 mov         r7, #2, 16
  0007c	e3a0e0f4	 mov         lr, #0xF4
  00080	e3871085	 orr         r1, r7, #0x85
  00084	e3a03001	 mov         r3, #1
  00088	e28d2000	 add         r2, sp, #0
  0008c	e5cde000	 strb        lr, [sp]
  00090	eb000000	 bl          TWLWriteRegs

; 512  :             TWLReadRegs(pDevice->hTwl, TWL_BCIMFTH8, &data, 1);

  00094	e5940018	 ldr         r0, [r4, #0x18]
  00098	e3875091	 orr         r5, r7, #0x91
  0009c	e1a01005	 mov         r1, r5
  000a0	e3a03001	 mov         r3, #1
  000a4	e28d2000	 add         r2, sp, #0
  000a8	eb000000	 bl          TWLReadRegs

; 513  : 
; 514  :             data = (data & 0xF0) | (threshold & 0x0F);

  000ac	e5dd2000	 ldrb        r2, [sp]

; 515  :             TWLWriteRegs(pDevice->hTwl, TWL_BCIMFTH8, &data, 1);

  000b0	e5940018	 ldr         r0, [r4, #0x18]
  000b4	e1a01005	 mov         r1, r5
  000b8	e0223006	 eor         r3, r2, r6
  000bc	e203300f	 and         r3, r3, #0xF
  000c0	e0233002	 eor         r3, r3, r2
  000c4	e5cd3000	 strb        r3, [sp]
  000c8	e3a03001	 mov         r3, #1
  000cc	e28d2000	 add         r2, sp, #0
  000d0	eb000000	 bl          TWLWriteRegs

; 516  :             
; 517  :             // get access to BCIMFTH9
; 518  :             data = KEY_BCIMFTH9;
; 519  :             TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  000d4	e5940018	 ldr         r0, [r4, #0x18]
  000d8	e3a0e0e7	 mov         lr, #0xE7
  000dc	e3a03001	 mov         r3, #1
  000e0	e28d2000	 add         r2, sp, #0
  000e4	e3871085	 orr         r1, r7, #0x85
  000e8	e5cde000	 strb        lr, [sp]
  000ec	eb000000	 bl          TWLWriteRegs

; 520  :             TWLReadRegs(pDevice->hTwl, TWL_BCIMFTH9, &data, 1);

  000f0	e5940018	 ldr         r0, [r4, #0x18]
  000f4	e3a03001	 mov         r3, #1
  000f8	e28d2000	 add         r2, sp, #0
  000fc	e3871092	 orr         r1, r7, #0x92
  00100	eb000000	 bl          TWLReadRegs

; 521  : 
; 522  :             data = (data & 0x0F) | (threshold & 0xF0);

  00104	e5dd3000	 ldrb        r3, [sp]
  00108	e3c6200f	 bic         r2, r6, #0xF

; 523  :             TWLWriteRegs(pDevice->hTwl, TWL_BCIMFTH9, &data, 1);           

  0010c	e3871092	 orr         r1, r7, #0x92
  00110	e203300f	 and         r3, r3, #0xF
  00114	e1823003	 orr         r3, r2, r3
  00118	e5cd3000	 strb        r3, [sp]
  0011c		 |$LN9@SetCurrent|
  0011c	e5940018	 ldr         r0, [r4, #0x18]
  00120	e3a03001	 mov         r3, #1
  00124	e28d2000	 add         r2, sp, #0
  00128	eb000000	 bl          TWLWriteRegs

; 537  :         }
; 538  : 
; 539  :     if (bResult != FALSE)
; 540  :         {
; 541  :         TWLWriteRegs(pDevice->hTwl, TWL_BCIMFTH3, &data, 1);

  0012c	e5940018	 ldr         r0, [r4, #0x18]
  00130	e3a03802	 mov         r3, #2, 16
  00134	e383108c	 orr         r1, r3, #0x8C
  00138	e3a03001	 mov         r3, #1
  0013c	e28d2000	 add         r2, sp, #0
  00140	e3a05001	 mov         r5, #1
  00144	eb000000	 bl          TWLWriteRegs
  00148		 |$LN1@SetCurrent|

; 542  :         }
; 543  : 
; 544  :     DEBUGMSG(ZONE_FUNCTION, (L"-SetCurrentThreshold()\r\n"));
; 545  :     return bResult;    
; 546  : }

  00148	e1a00005	 mov         r0, r5
  0014c	e28dd004	 add         sp, sp, #4
  00150	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00154	e12fff1e	 bx          lr
  00158		 |$M44899|

			 ENDP  ; |SetCurrentThreshold|


  00000			 AREA	 |.pdata|, PDATA
|$T44915| DCD	|$LN12@SetTempera|
	DCD	0x40004804
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetTemperatureThreshold| PROC

; 561  : {

  00000		 |$LN12@SetTempera|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5070	 stmdb       sp!, {r4 - r6, r12, lr}
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M44912|
  00010	e1a04000	 mov         r4, r0

; 562  :     UINT8 data;
; 563  :     BOOL bResult = FALSE;

  00014	e3a05000	 mov         r5, #0

; 564  :     DEBUGMSG(ZONE_FUNCTION, (L"+SetTemperatureThreshold("
; 565  :         L"pDevice=0x%08X, ffMask=%d, thresholdHigh=%d, thresholdLow=%d)\r\n",
; 566  :         pDevice, ffMask, thresholdHigh, thresholdLow
; 567  :         ));
; 568  : 
; 569  :     switch (ffMask)

  00018	e3510001	 cmp         r1, #1
  0001c	0a000019	 beq         |$LN3@SetTempera|
  00020	e3510002	 cmp         r1, #2
  00024	1a000039	 bne         |$LN1@SetTempera|

; 587  :             bResult = TRUE;
; 588  :             break;
; 589  : 
; 590  :         case BCI_TEMP_VBAT2:
; 591  :             // get access to BCIMFTH6
; 592  :             data = KEY_BCIMFTH6;
; 593  :             TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  00028	e3a03802	 mov         r3, #2, 16
  0002c	e5940018	 ldr         r0, [r4, #0x18]
  00030	e3835085	 orr         r5, r3, #0x85
  00034	e3a0e0bc	 mov         lr, #0xBC
  00038	e1a01005	 mov         r1, r5
  0003c	e3a03001	 mov         r3, #1
  00040	e28d2000	 add         r2, sp, #0
  00044	e5cde000	 strb        lr, [sp]
  00048	eb000000	 bl          TWLWriteRegs

; 594  : 
; 595  :             TWLWriteRegs(pDevice->hTwl, TWL_BCIMFTH6, 
; 596  :                 &thresholdLow, 1
; 597  :                 );

  0004c	e5940018	 ldr         r0, [r4, #0x18]
  00050	e3a06802	 mov         r6, #2, 16
  00054	e386108f	 orr         r1, r6, #0x8F
  00058	e3a03001	 mov         r3, #1
  0005c	e28d2024	 add         r2, sp, #0x24
  00060	eb000000	 bl          TWLWriteRegs

; 598  : 
; 599  :             // get access to BCIMFTH7
; 600  :             data = KEY_BCIMFTH7;
; 601  :             TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  00064	e5940018	 ldr         r0, [r4, #0x18]
  00068	e3a0e0c3	 mov         lr, #0xC3
  0006c	e3a03001	 mov         r3, #1
  00070	e28d2000	 add         r2, sp, #0
  00074	e1a01005	 mov         r1, r5
  00078	e5cde000	 strb        lr, [sp]
  0007c	eb000000	 bl          TWLWriteRegs

; 602  : 
; 603  :             TWLWriteRegs(pDevice->hTwl, TWL_BCIMFTH7, 
; 604  :                 &thresholdHigh, 1
; 605  :                 );  

  00080	e3861090	 orr         r1, r6, #0x90

; 606  :             bResult = TRUE;
; 607  :             break;            

  00084	ea000016	 b           |$LN9@SetTempera|
  00088		 |$LN3@SetTempera|

; 570  :         {
; 571  :         case BCI_TEMP_VBAT1:
; 572  :             // get access to BCIMFTH4
; 573  :             data = KEY_BCIMFTH4;
; 574  :             TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  00088	e3a03802	 mov         r3, #2, 16
  0008c	e5940018	 ldr         r0, [r4, #0x18]
  00090	e3835085	 orr         r5, r3, #0x85
  00094	e3a0e0ea	 mov         lr, #0xEA
  00098	e1a01005	 mov         r1, r5
  0009c	e3a03001	 mov         r3, #1
  000a0	e28d2000	 add         r2, sp, #0
  000a4	e5cde000	 strb        lr, [sp]
  000a8	eb000000	 bl          TWLWriteRegs

; 575  : 
; 576  :             TWLWriteRegs(pDevice->hTwl, TWL_BCIMFTH4, 
; 577  :                 &thresholdLow, 1
; 578  :                 );

  000ac	e5940018	 ldr         r0, [r4, #0x18]
  000b0	e3a06802	 mov         r6, #2, 16
  000b4	e386108d	 orr         r1, r6, #0x8D
  000b8	e3a03001	 mov         r3, #1
  000bc	e28d2024	 add         r2, sp, #0x24
  000c0	eb000000	 bl          TWLWriteRegs

; 579  :             
; 580  :             // get access to BCIMFTH5
; 581  :             data = KEY_BCIMFTH5;
; 582  :             TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  000c4	e5940018	 ldr         r0, [r4, #0x18]
  000c8	e3a0e0c4	 mov         lr, #0xC4
  000cc	e3a03001	 mov         r3, #1
  000d0	e28d2000	 add         r2, sp, #0
  000d4	e1a01005	 mov         r1, r5
  000d8	e5cde000	 strb        lr, [sp]
  000dc	eb000000	 bl          TWLWriteRegs

; 583  : 
; 584  :             TWLWriteRegs(pDevice->hTwl, TWL_BCIMFTH5, 
; 585  :                 &thresholdHigh, 1
; 586  :                 );            

  000e0	e386108e	 orr         r1, r6, #0x8E
  000e4		 |$LN9@SetTempera|
  000e4	e5940018	 ldr         r0, [r4, #0x18]
  000e8	e3a03001	 mov         r3, #1
  000ec	e28d2020	 add         r2, sp, #0x20
  000f0	eb000000	 bl          TWLWriteRegs

; 608  :         }
; 609  : 
; 610  :     if (bResult != FALSE)
; 611  :         {
; 612  :         TWLWriteRegs(pDevice->hTwl, TWL_BCIMFTH3, &data, 1);

  000f4	e5940018	 ldr         r0, [r4, #0x18]
  000f8	e3a03802	 mov         r3, #2, 16
  000fc	e383108c	 orr         r1, r3, #0x8C
  00100	e3a03001	 mov         r3, #1
  00104	e28d2000	 add         r2, sp, #0
  00108	e3a05001	 mov         r5, #1
  0010c	eb000000	 bl          TWLWriteRegs
  00110		 |$LN1@SetTempera|

; 613  :         }
; 614  : 
; 615  :     DEBUGMSG(ZONE_FUNCTION, (L"-SetTemperatureThreshold()\r\n"));
; 616  :     return bResult;    
; 617  : }

  00110	e1a00005	 mov         r0, r5
  00114	e28dd004	 add         sp, sp, #4
  00118	e89d6070	 ldmia       sp, {r4 - r6, sp, lr}
  0011c	e12fff1e	 bx          lr
  00120		 |$M44913|

			 ENDP  ; |SetTemperatureThreshold|


  00000			 AREA	 |.pdata|, PDATA
|$T44930| DCD	|$LN14@SetVoltage|
	DCD	0x40003d02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetVoltageThreshold| PROC

; 631  : {

  00000		 |$LN14@SetVoltage|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M44927|
  00008	e1a04002	 mov         r4, r2
  0000c	e1a07001	 mov         r7, r1
  00010	e1a05000	 mov         r5, r0

; 632  :     UINT8 data;
; 633  :     BOOL bResult = FALSE;

  00014	e3a06000	 mov         r6, #0

; 634  :     DEBUGMSG(ZONE_FUNCTION, (L"+SetVoltageThreshold("
; 635  :         L"pDevice=0x%08X, ffMask=%d, threshold=%d)\r\n",
; 636  :         pDevice, ffMask, threshold
; 637  :         ));
; 638  : 
; 639  :     // make sure the value is valid
; 640  :     if (threshold > 3) goto cleanUp;

  00018	e3540003	 cmp         r4, #3
  0001c	8a00002f	 bhi         |$cleanUp$44015|

; 641  : 
; 642  :     // get access to BCIMFTH3
; 643  :     data = KEY_BCIMFTH3;
; 644  :     TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  00020	e5950018	 ldr         r0, [r5, #0x18]
  00024	e3a08802	 mov         r8, #2, 16
  00028	e3a0e06d	 mov         lr, #0x6D
  0002c	e3881085	 orr         r1, r8, #0x85
  00030	e3a03001	 mov         r3, #1
  00034	e28d2000	 add         r2, sp, #0
  00038	e5cde000	 strb        lr, [sp]
  0003c	eb000000	 bl          TWLWriteRegs

; 645  : 
; 646  :     // get contents
; 647  :     TWLReadRegs(pDevice->hTwl, TWL_BCIMFTH3, &data, 1);

  00040	e5950018	 ldr         r0, [r5, #0x18]
  00044	e3a03001	 mov         r3, #1
  00048	e28d2000	 add         r2, sp, #0
  0004c	e388108c	 orr         r1, r8, #0x8C
  00050	eb000000	 bl          TWLReadRegs

; 648  :     switch (ffMask)

  00054	e3570001	 cmp         r7, #1
  00058	0a000012	 beq         |$LN2@SetVoltage|
  0005c	e3570002	 cmp         r7, #2
  00060	0a000008	 beq         |$LN3@SetVoltage|
  00064	e3570004	 cmp         r7, #4
  00068	1a00001c	 bne         |$cleanUp$44015|

; 649  :         {
; 650  :         case BCI_OV_VAC:
; 651  :             pDevice->dwACCHGOVTH = _rgACCHGOVTH[threshold];

  0006c	e59f307c	 ldr         r3, [pc, #0x7C]

; 652  :             data = (data & ~ACCHGOVTH) | (threshold << 2);

  00070	e5dd2000	 ldrb        r2, [sp]

; 653  :             bResult = TRUE;

  00074	e7931104	 ldr         r1, [r3, +r4, lsl #2]
  00078	e20230f3	 and         r3, r2, #0xF3
  0007c	e1833104	 orr         r3, r3, r4, lsl #2
  00080	e5851044	 str         r1, [r5, #0x44]

; 654  :             break;

  00084	ea00000e	 b           |$LN11@SetVoltage|
  00088		 |$LN3@SetVoltage|

; 655  : 
; 656  :         case BCI_OV_VBUS:
; 657  :             pDevice->dwVBUSOVTH = _rgVBUSOVTH[threshold];

  00088	e59f3060	 ldr         r3, [pc, #0x60]

; 658  :             data = (data & ~VBUSOVTH) | (threshold);

  0008c	e5dd1000	 ldrb        r1, [sp]

; 659  :             bResult = TRUE;

  00090	e2833020	 add         r3, r3, #0x20
  00094	e7932104	 ldr         r2, [r3, +r4, lsl #2]
  00098	e20130fc	 and         r3, r1, #0xFC
  0009c	e1833004	 orr         r3, r3, r4
  000a0	e585204c	 str         r2, [r5, #0x4C]

; 660  :             break;

  000a4	ea000006	 b           |$LN11@SetVoltage|
  000a8		 |$LN2@SetVoltage|

; 661  :             
; 662  :         case BCI_OV_VBAT:
; 663  :             pDevice->dwVBATOVTH = _rgVBATOVTH[threshold];

  000a8	e59f3040	 ldr         r3, [pc, #0x40]

; 664  :             data = (data & ~VBATOVTH) | (threshold << 4);

  000ac	e5dd1000	 ldrb        r1, [sp]

; 665  :             bResult = TRUE;

  000b0	e2833010	 add         r3, r3, #0x10
  000b4	e7932104	 ldr         r2, [r3, +r4, lsl #2]
  000b8	e20130cf	 and         r3, r1, #0xCF
  000bc	e1833204	 orr         r3, r3, r4, lsl #4
  000c0	e5852048	 str         r2, [r5, #0x48]
  000c4		 |$LN11@SetVoltage|

; 666  :             break;
; 667  :         }
; 668  : 
; 669  :     if (bResult != FALSE)
; 670  :         {
; 671  :         TWLWriteRegs(pDevice->hTwl, TWL_BCIMFTH3, &data, 1);

  000c4	e5950018	 ldr         r0, [r5, #0x18]
  000c8	e5cd3000	 strb        r3, [sp]
  000cc	e3a03001	 mov         r3, #1
  000d0	e28d2000	 add         r2, sp, #0
  000d4	e388108c	 orr         r1, r8, #0x8C
  000d8	e3a06001	 mov         r6, #1
  000dc	eb000000	 bl          TWLWriteRegs
  000e0		 |$cleanUp$44015|

; 672  :         }
; 673  : 
; 674  : cleanUp:
; 675  :     DEBUGMSG(ZONE_FUNCTION, (L"-SetVoltageThreshold()\r\n"));
; 676  :     return bResult;    
; 677  : }

  000e0	e1a00006	 mov         r0, r6
  000e4	e28dd004	 add         sp, sp, #4
  000e8	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000ec	e12fff1e	 bx          lr
  000f0		 |$LN15@SetVoltage|
  000f0		 |$LN16@SetVoltage|
  000f0	00000000	 DCD         |_rgACCHGOVTH|
  000f4		 |$M44928|

			 ENDP  ; |SetVoltageThreshold|


  00000			 AREA	 |.pdata|, PDATA
|$T44950| DCD	|$LN13@SetCurrent@2|
	DCD	0x40002b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetCurrentMonitors| PROC

; 691  : {

  00000		 |$LN13@SetCurrent@2|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M44947|
  00008	e1a04002	 mov         r4, r2
  0000c	e1a05001	 mov         r5, r1
  00010	e1a06000	 mov         r6, r0

; 692  :     UINT8 data;
; 693  :     BOOL bResult = FALSE;
; 694  :     DEBUGMSG(ZONE_FUNCTION, (L"+SetCurrentMonitors("
; 695  :         L"pDevice=0x%08X, ffEnable=%d, ffMask=%d)\r\n",
; 696  :         pDevice, ffEnable, ffMask
; 697  :         ));
; 698  : 
; 699  :     if (ffMask & (BCI_OC_VBAT | BCI_EOC_VBAT))

  00014	e3140003	 tst         r4, #3
  00018	0a00001f	 beq         |$LN3@SetCurrent@2|

; 700  :         {
; 701  :         // get access to BCIMFEN3
; 702  :         data = KEY_BCIMFEN3;
; 703  :         TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  0001c	e5960018	 ldr         r0, [r6, #0x18]
  00020	e3a07802	 mov         r7, #2, 16
  00024	e3a0e09c	 mov         lr, #0x9C
  00028	e3871085	 orr         r1, r7, #0x85
  0002c	e3a03001	 mov         r3, #1
  00030	e28d2000	 add         r2, sp, #0
  00034	e5cde000	 strb        lr, [sp]
  00038	eb000000	 bl          TWLWriteRegs

; 704  : 
; 705  :         // update over-charge monitors
; 706  :         TWLReadRegs(pDevice->hTwl, TWL_BCIMFEN3, &data, 1);

  0003c	e5960018	 ldr         r0, [r6, #0x18]
  00040	e3a03001	 mov         r3, #1
  00044	e28d2000	 add         r2, sp, #0
  00048	e3871088	 orr         r1, r7, #0x88
  0004c	eb000000	 bl          TWLReadRegs

; 707  :         if (ffMask & BCI_OC_VBAT)
; 708  :             {
; 709  :             data = (ffEnable & BCI_OC_VBAT) ? (data | ICHGHIGHEN) :
; 710  :                                               (data & ~ICHGHIGHEN);

  00050	e5dd3000	 ldrb        r3, [sp]
  00054	e3140001	 tst         r4, #1
  00058	0a000004	 beq         |$LN2@SetCurrent@2|
  0005c	e3150001	 tst         r5, #1
  00060	13833008	 orrne       r3, r3, #8
  00064	03c33008	 biceq       r3, r3, #8
  00068	e20330ff	 and         r3, r3, #0xFF
  0006c	e5cd3000	 strb        r3, [sp]
  00070		 |$LN2@SetCurrent@2|

; 711  :             }
; 712  : 
; 713  :         if (ffMask & BCI_EOC_VBAT)

  00070	e3140002	 tst         r4, #2
  00074	0a000003	 beq         |$LN1@SetCurrent@2|

; 714  :             {
; 715  :             data = (ffEnable & BCI_EOC_VBAT) ? (data | ICHGEOCEN) :
; 716  :                                                (data & ~ICHGEOCEN);

  00078	e3150002	 tst         r5, #2
  0007c	13833080	 orrne       r3, r3, #0x80
  00080	03c33080	 biceq       r3, r3, #0x80
  00084	e5cd3000	 strb        r3, [sp]
  00088		 |$LN1@SetCurrent@2|

; 717  :             }
; 718  :             
; 719  :         TWLWriteRegs(pDevice->hTwl, TWL_BCIMFEN3, &data, 1);

  00088	e5960018	 ldr         r0, [r6, #0x18]
  0008c	e3a03001	 mov         r3, #1
  00090	e28d2000	 add         r2, sp, #0
  00094	e3871088	 orr         r1, r7, #0x88
  00098	eb000000	 bl          TWLWriteRegs
  0009c		 |$LN3@SetCurrent@2|

; 720  :         }
; 721  : 
; 722  :     bResult = TRUE;
; 723  :             
; 724  :     DEBUGMSG(ZONE_FUNCTION, (L"-SetCurrentMonitors()\r\n"));
; 725  :     return bResult;

  0009c	e3a00001	 mov         r0, #1

; 726  : }

  000a0	e28dd004	 add         sp, sp, #4
  000a4	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000a8	e12fff1e	 bx          lr
  000ac		 |$M44948|

			 ENDP  ; |SetCurrentMonitors|


  00000			 AREA	 |.pdata|, PDATA
|$T44961| DCD	|$LN7@SetPrescal|
	DCD	0x40002802
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetPrescale| PROC

; 739  : {   

  00000		 |$LN7@SetPrescal|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M44958|
  00008	e1a05001	 mov         r5, r1
  0000c	e1a04000	 mov         r4, r0

; 740  :     UINT8 data;
; 741  :     UINT8 bcictl1;
; 742  :     DEBUGMSG(ZONE_FUNCTION, (L"+SetPrescale("
; 743  :         L"pDevice=0x%08X, preScale)\r\n",
; 744  :         pDevice, preScale
; 745  :         ));
; 746  : 
; 747  :     // update charge current scaler
; 748  :     TWLReadRegs(pDevice->hTwl, TWL_BCICTL1, &bcictl1, 1);

  00010	e5940018	 ldr         r0, [r4, #0x18]
  00014	e3a07802	 mov         r7, #2, 16
  00018	e3871097	 orr         r1, r7, #0x97
  0001c	e3a03001	 mov         r3, #1
  00020	e28d2000	 add         r2, sp, #0
  00024	eb000000	 bl          TWLReadRegs

; 749  :     bcictl1 = (preScale > 1) ? bcictl1 | CGAIN : bcictl1 & ~CGAIN;

  00028	e5dd3000	 ldrb        r3, [sp]
  0002c	e3550001	 cmp         r5, #1

; 750  :     
; 751  :     // need to pull the BCI module out of autoac mode before 
; 752  :     // setting prescale value    
; 753  :     data = KEY_BCIOFF;
; 754  :     TWLWriteRegs(pDevice->hTwl, TWL_BCIMDKEY, &data, 1);

  00030	e5940018	 ldr         r0, [r4, #0x18]
  00034	8383e020	 orrhi       lr, r3, #0x20
  00038	93c3e020	 bicls       lr, r3, #0x20
  0003c	e3a03802	 mov         r3, #2, 16
  00040	e3831075	 orr         r1, r3, #0x75
  00044	e3a0602a	 mov         r6, #0x2A
  00048	e3a03001	 mov         r3, #1
  0004c	e28d2001	 add         r2, sp, #1
  00050	e5cde000	 strb        lr, [sp]
  00054	e5cd6001	 strb        r6, [sp, #1]
  00058	eb000000	 bl          TWLWriteRegs

; 755  :         
; 756  :     // update scaling mode
; 757  :     TWLWriteRegs(pDevice->hTwl, TWL_BCICTL1, &bcictl1, 1);

  0005c	e5940018	 ldr         r0, [r4, #0x18]
  00060	e3a03001	 mov         r3, #1
  00064	e28d2000	 add         r2, sp, #0
  00068	e3871097	 orr         r1, r7, #0x97
  0006c	eb000000	 bl          TWLWriteRegs

; 758  : 
; 759  :     // enable auto charge
; 760  :     data = CONFIG_DONE | BCIAUTOAC;
; 761  :     TWLWriteRegs(pDevice->hTwl, TWL_BOOT_BCI, &data, 1);

  00070	e5940018	 ldr         r0, [r4, #0x18]
  00074	e3a03803	 mov         r3, #3, 16
  00078	e383103d	 orr         r1, r3, #0x3D
  0007c	e3a0e011	 mov         lr, #0x11
  00080	e3a03001	 mov         r3, #1
  00084	e28d2001	 add         r2, sp, #1
  00088	e5cde001	 strb        lr, [sp, #1]
  0008c	eb000000	 bl          TWLWriteRegs

; 762  : 
; 763  :     pDevice->preScale = preScale;

  00090	e5845034	 str         r5, [r4, #0x34]

; 764  : 
; 765  :     DEBUGMSG(ZONE_FUNCTION, (L"-SetPrescale()\r\n"));
; 766  : }

  00094	e28dd004	 add         sp, sp, #4
  00098	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$M44959|

			 ENDP  ; |SetPrescale|


  00000			 AREA	 |.pdata|, PDATA
|$T44979| DCD	|$LN12@SetTempera@2|
	DCD	0x40002902
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetTemperatureMonitors| PROC

; 780  : {

  00000		 |$LN12@SetTempera@2|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M44976|
  00008	e1a05002	 mov         r5, r2
  0000c	e1a04001	 mov         r4, r1
  00010	e1a06000	 mov         r6, r0

; 781  :     UINT8 data;
; 782  :     BOOL bResult = FALSE;
; 783  :     DEBUGMSG(ZONE_FUNCTION, (L"+SetTemperatureMonitors("
; 784  :         L"pDevice=0x%08X, ffEnable=%d, ffMask=%d)\r\n",
; 785  :         pDevice, ffEnable, ffMask
; 786  :         ));
; 787  : 
; 788  :     // get access to BCIMFEN2
; 789  :     data = KEY_BCIMFEN2;
; 790  :     TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  00014	e5960018	 ldr         r0, [r6, #0x18]
  00018	e3a07802	 mov         r7, #2, 16
  0001c	e3a0e073	 mov         lr, #0x73
  00020	e3871085	 orr         r1, r7, #0x85
  00024	e3a03001	 mov         r3, #1
  00028	e28d2000	 add         r2, sp, #0
  0002c	e5cde000	 strb        lr, [sp]
  00030	eb000000	 bl          TWLWriteRegs

; 791  : 
; 792  :     // update over-charge monitors
; 793  :     TWLReadRegs(pDevice->hTwl, TWL_BCIMFEN2, &data, 1);

  00034	e5960018	 ldr         r0, [r6, #0x18]
  00038	e3a03001	 mov         r3, #1
  0003c	e28d2000	 add         r2, sp, #0
  00040	e3871087	 orr         r1, r7, #0x87
  00044	eb000000	 bl          TWLReadRegs

; 794  :     if (ffMask & BCI_TEMP_VBAT1)
; 795  :         {
; 796  :         data = (ffEnable & BCI_TEMP_VBAT1) ? (data | TBATOR1EN) :
; 797  :                                              (data & ~TBATOR1EN);

  00048	e5dd3000	 ldrb        r3, [sp]
  0004c	e3150001	 tst         r5, #1
  00050	0a000004	 beq         |$LN2@SetTempera@2|
  00054	e3140001	 tst         r4, #1
  00058	13833008	 orrne       r3, r3, #8
  0005c	03c33008	 biceq       r3, r3, #8
  00060	e20330ff	 and         r3, r3, #0xFF
  00064	e5cd3000	 strb        r3, [sp]
  00068		 |$LN2@SetTempera@2|

; 798  :         }
; 799  : 
; 800  :     if (ffMask & BCI_TEMP_VBAT2)

  00068	e3150002	 tst         r5, #2
  0006c	0a000003	 beq         |$LN1@SetTempera@2|

; 801  :         {
; 802  :         data = (ffEnable & BCI_TEMP_VBAT2) ? (data | TBATOR2EN) :
; 803  :                                              (data & ~TBATOR2EN);

  00070	e3140002	 tst         r4, #2
  00074	13833002	 orrne       r3, r3, #2
  00078	03c33002	 biceq       r3, r3, #2
  0007c	e5cd3000	 strb        r3, [sp]
  00080		 |$LN1@SetTempera@2|

; 804  :         }
; 805  :         
; 806  :     TWLWriteRegs(pDevice->hTwl, TWL_BCIMFEN2, &data, 1);

  00080	e5960018	 ldr         r0, [r6, #0x18]
  00084	e3a03001	 mov         r3, #1
  00088	e28d2000	 add         r2, sp, #0
  0008c	e3871087	 orr         r1, r7, #0x87
  00090	eb000000	 bl          TWLWriteRegs

; 807  : 
; 808  :     bResult = TRUE;
; 809  :             
; 810  :     DEBUGMSG(ZONE_FUNCTION, (L"-SetOverVoltageMonitors()\r\n"));
; 811  :     return bResult;

  00094	e3a00001	 mov         r0, #1

; 812  : }

  00098	e28dd004	 add         sp, sp, #4
  0009c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000a0	e12fff1e	 bx          lr
  000a4		 |$M44977|

			 ENDP  ; |SetTemperatureMonitors|


  00000			 AREA	 |.pdata|, PDATA
|$T44991| DCD	|$LN9@UpdateChar|
	DCD	0x40002f02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UpdateChargeCurrent| PROC

; 825  : {

  00000		 |$LN9@UpdateChar|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M44988|
  00008	e1a06001	 mov         r6, r1
  0000c	e1a05000	 mov         r5, r0

; 826  :     UCHAR bcimfkey = KEY_BCIMFTH9;
; 827  :     UINT8 regVal=0;
; 828  :     BOOL bSuccess = FALSE;
; 829  : 
; 830  :     DEBUGMSG(ZONE_FUNCTION, (L"+UpdateChargeCurrent("
; 831  :         L"pDevice=0x%08X, chargeCurrent=%d)\r\n",
; 832  :         pDevice, chargeCurrent
; 833  :         ));
; 834  : 
; 835  :     // update charge current
; 836  :     //
; 837  :     if (TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &bcimfkey, 1) == FALSE)

  00010	e5950018	 ldr         r0, [r5, #0x18]
  00014	e3a04000	 mov         r4, #0
  00018	e3a07802	 mov         r7, #2, 16
  0001c	e3a0e0e7	 mov         lr, #0xE7
  00020	e3871085	 orr         r1, r7, #0x85
  00024	e5cd4000	 strb        r4, [sp]
  00028	e3a03001	 mov         r3, #1
  0002c	e28d2001	 add         r2, sp, #1
  00030	e3a04000	 mov         r4, #0
  00034	e5cde001	 strb        lr, [sp, #1]
  00038	eb000000	 bl          TWLWriteRegs
  0003c	e3500000	 cmp         r0, #0
  00040	0a000019	 beq         |$cleanUp$44075|

; 838  :         {
; 839  :         goto cleanUp;
; 840  :         }
; 841  :     
; 842  :     regVal = (UINT8) (chargeCurrent & 0xFF);
; 843  :     if (TWLWriteRegs(pDevice->hTwl, TWL_BCIIREF1, &regVal, 1) == FALSE)

  00044	e5950018	 ldr         r0, [r5, #0x18]
  00048	e3a03802	 mov         r3, #2, 16
  0004c	e383109b	 orr         r1, r3, #0x9B
  00050	e3a03001	 mov         r3, #1
  00054	e28d2000	 add         r2, sp, #0
  00058	e5cd6000	 strb        r6, [sp]
  0005c	eb000000	 bl          TWLWriteRegs
  00060	e3500000	 cmp         r0, #0
  00064	0a000010	 beq         |$cleanUp$44075|

; 844  :         {
; 845  :         goto cleanUp;
; 846  :         }
; 847  : 
; 848  : 
; 849  :     if (TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &bcimfkey, 1) == FALSE)

  00068	e5950018	 ldr         r0, [r5, #0x18]
  0006c	e3a03001	 mov         r3, #1
  00070	e28d2001	 add         r2, sp, #1
  00074	e3871085	 orr         r1, r7, #0x85
  00078	eb000000	 bl          TWLWriteRegs
  0007c	e3500000	 cmp         r0, #0
  00080	0a000009	 beq         |$cleanUp$44075|

; 850  :         {
; 851  :         goto cleanUp;
; 852  :         }
; 853  : 
; 854  :     regVal = (UINT8) (chargeCurrent >> 8);
; 855  :     if (TWLWriteRegs(pDevice->hTwl, TWL_BCIIREF2, &regVal, 1) == FALSE)

  00084	e5950018	 ldr         r0, [r5, #0x18]
  00088	e3a03802	 mov         r3, #2, 16
  0008c	e383109c	 orr         r1, r3, #0x9C
  00090	e1a0e426	 mov         lr, r6, lsr #8
  00094	e3a03001	 mov         r3, #1
  00098	e28d2000	 add         r2, sp, #0
  0009c	e5cde000	 strb        lr, [sp]
  000a0	eb000000	 bl          TWLWriteRegs
  000a4	e3500000	 cmp         r0, #0

; 856  :         {
; 857  :         goto cleanUp;
; 858  :         }
; 859  : 
; 860  :     bSuccess = TRUE;

  000a8	13a04001	 movne       r4, #1
  000ac		 |$cleanUp$44075|

; 861  : 
; 862  : cleanUp:
; 863  :     return bSuccess;
; 864  : }

  000ac	e1a00004	 mov         r0, r4
  000b0	e28dd004	 add         sp, sp, #4
  000b4	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000b8	e12fff1e	 bx          lr
  000bc		 |$M44989|

			 ENDP  ; |UpdateChargeCurrent|


  00000			 AREA	 |.pdata|, PDATA
|$T45012| DCD	|$LN19@SetVoltage@2|
	DCD	0x40005502
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetVoltageMonitors| PROC

; 880  : {

  00000		 |$LN19@SetVoltage@2|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M45009|
  00008	e1a05002	 mov         r5, r2
  0000c	e1a06001	 mov         r6, r1
  00010	e1a04000	 mov         r4, r0

; 881  :     UINT8 data;
; 882  :     BOOL bResult = FALSE;
; 883  :     DEBUGMSG(ZONE_FUNCTION, (L"+SetVoltageMonitors("
; 884  :         L"pDevice=0x%08X, ffEnable=%d, ffMask=%d)\r\n",
; 885  :         pDevice, ffEnable, ffMask
; 886  :         ));
; 887  : 
; 888  :     // over-charge monitoring for usb and ac
; 889  :     if (ffMask & (BCI_OV_VAC | BCI_OV_VBUS))

  00014	e3a08802	 mov         r8, #2, 16
  00018	e3150006	 tst         r5, #6
  0001c	0a00002b	 beq         |$LN10@SetVoltage@2|

; 890  :         {
; 891  :         // get access to BCIMFEN2
; 892  :         data = KEY_BCIMFEN2;
; 893  :         TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  00020	e5940018	 ldr         r0, [r4, #0x18]
  00024	e3a0e073	 mov         lr, #0x73
  00028	e3a03001	 mov         r3, #1
  0002c	e28d2000	 add         r2, sp, #0
  00030	e3881085	 orr         r1, r8, #0x85
  00034	e5cde000	 strb        lr, [sp]
  00038	eb000000	 bl          TWLWriteRegs

; 894  : 
; 895  :         // update over-charge monitors
; 896  :         TWLReadRegs(pDevice->hTwl, TWL_BCIMFEN2, &data, 1);

  0003c	e5940018	 ldr         r0, [r4, #0x18]
  00040	e3a07802	 mov         r7, #2, 16
  00044	e3871087	 orr         r1, r7, #0x87
  00048	e3a03001	 mov         r3, #1
  0004c	e28d2000	 add         r2, sp, #0
  00050	eb000000	 bl          TWLReadRegs

; 897  :         if (ffMask & BCI_OV_VAC)

  00054	e3150004	 tst         r5, #4
  00058	0a00000b	 beq         |$LN13@SetVoltage@2|

; 898  :             {
; 899  :             if (ffEnable & BCI_OV_VAC)
; 900  :                 {
; 901  :                 data |= ACCHGOVEN;
; 902  :                 pDevice->dwACCHGOVTH &= ~THRESHOLD_DISABLED;

  0005c	e5942044	 ldr         r2, [r4, #0x44]
  00060	e5dd3000	 ldrb        r3, [sp]
  00064	e3160004	 tst         r6, #4
  00068	0a000004	 beq         |$LN8@SetVoltage@2|
  0006c	e3831080	 orr         r1, r3, #0x80
  00070	e3c23102	 bic         r3, r2, #2, 2
  00074		 |$LN14@SetVoltage@2|
  00074	e5843044	 str         r3, [r4, #0x44]
  00078	e5cd1000	 strb        r1, [sp]

; 903  :                 }
; 904  :             else

  0007c	ea000003	 b           |$LN7@SetVoltage@2|
  00080		 |$LN8@SetVoltage@2|

; 905  :                 {
; 906  :                 data &= ~ACCHGOVEN;
; 907  :                 pDevice->dwACCHGOVTH |= THRESHOLD_DISABLED;

  00080	e203107f	 and         r1, r3, #0x7F
  00084	e3823102	 orr         r3, r2, #2, 2
  00088	eafffff9	 b           |$LN14@SetVoltage@2|
  0008c		 |$LN13@SetVoltage@2|
  0008c	e5dd1000	 ldrb        r1, [sp]
  00090		 |$LN7@SetVoltage@2|

; 908  :                 }
; 909  :             }
; 910  : 
; 911  :         if (ffMask & BCI_OV_VBUS)

  00090	e3150002	 tst         r5, #2
  00094	0a000008	 beq         |$LN4@SetVoltage@2|

; 912  :             {
; 913  :             if (ffEnable & BCI_OV_VBUS)
; 914  :                 {
; 915  :                 data |= VBUSOVEN;
; 916  :                 pDevice->dwVBUSOVTH &= ~THRESHOLD_DISABLED;

  00098	e594204c	 ldr         r2, [r4, #0x4C]
  0009c	e3160002	 tst         r6, #2
  000a0	13813020	 orrne       r3, r1, #0x20
  000a4	15cd3000	 strneb      r3, [sp]
  000a8	13c23102	 bicne       r3, r2, #2, 2

; 917  :                 }
; 918  :             else
; 919  :                 {
; 920  :                 data &= ~VBUSOVEN;
; 921  :                 pDevice->dwVBUSOVTH |= THRESHOLD_DISABLED;

  000ac	020130df	 andeq       r3, r1, #0xDF
  000b0	05cd3000	 streqb      r3, [sp]
  000b4	03823102	 orreq       r3, r2, #2, 2
  000b8	e584304c	 str         r3, [r4, #0x4C]
  000bc		 |$LN4@SetVoltage@2|

; 922  :                 }
; 923  :             }
; 924  : 
; 925  :         TWLWriteRegs(pDevice->hTwl, TWL_BCIMFEN2, &data, 1);

  000bc	e5940018	 ldr         r0, [r4, #0x18]
  000c0	e3a03001	 mov         r3, #1
  000c4	e28d2000	 add         r2, sp, #0
  000c8	e3871087	 orr         r1, r7, #0x87
  000cc	eb000000	 bl          TWLWriteRegs
  000d0		 |$LN10@SetVoltage@2|

; 926  :         }
; 927  : 
; 928  :     // over-charge monitoring for battery
; 929  :     if (ffMask & BCI_OV_VBAT)

  000d0	e3150001	 tst         r5, #1
  000d4	0a00001a	 beq         |$LN3@SetVoltage@2|

; 930  :         {
; 931  :         // get access to BCIMFEN4
; 932  :         data = KEY_BCIMFEN4;
; 933  :         TWLWriteRegs(pDevice->hTwl, TWL_BCIMFKEY, &data, 1);

  000d8	e5940018	 ldr         r0, [r4, #0x18]
  000dc	e3a0e03e	 mov         lr, #0x3E
  000e0	e3a03001	 mov         r3, #1
  000e4	e28d2000	 add         r2, sp, #0
  000e8	e3881085	 orr         r1, r8, #0x85
  000ec	e5cde000	 strb        lr, [sp]
  000f0	eb000000	 bl          TWLWriteRegs

; 934  : 
; 935  :         // update over-charge monitors
; 936  :         TWLReadRegs(pDevice->hTwl, TWL_BCIMFEN4, &data, 1);

  000f4	e5940018	 ldr         r0, [r4, #0x18]
  000f8	e3a05802	 mov         r5, #2, 16
  000fc	e3851089	 orr         r1, r5, #0x89
  00100	e3a03001	 mov         r3, #1
  00104	e28d2000	 add         r2, sp, #0
  00108	eb000000	 bl          TWLReadRegs

; 937  :         if (ffEnable & BCI_OV_VBAT)
; 938  :             {
; 939  :             data |= VBATOVEN;
; 940  :             pDevice->dwVBATOVTH &= ~THRESHOLD_DISABLED;

  0010c	e5dd3000	 ldrb        r3, [sp]
  00110	e5941048	 ldr         r1, [r4, #0x48]
  00114	e3160001	 tst         r6, #1
  00118	13832002	 orrne       r2, r3, #2
  0011c	13c13102	 bicne       r3, r1, #2, 2

; 941  :             }
; 942  :         else
; 943  :             {
; 944  :             data &= ~VBATOVEN;
; 945  :             pDevice->dwVBATOVTH |= THRESHOLD_DISABLED;

  00120	020320fd	 andeq       r2, r3, #0xFD

; 946  :             }
; 947  :                                           
; 948  :         TWLWriteRegs(pDevice->hTwl, TWL_BCIMFEN4, &data, 1);

  00124	e5940018	 ldr         r0, [r4, #0x18]
  00128	03813102	 orreq       r3, r1, #2, 2
  0012c	e5843048	 str         r3, [r4, #0x48]
  00130	e5cd2000	 strb        r2, [sp]
  00134	e3a03001	 mov         r3, #1
  00138	e28d2000	 add         r2, sp, #0
  0013c	e3851089	 orr         r1, r5, #0x89
  00140	eb000000	 bl          TWLWriteRegs
  00144		 |$LN3@SetVoltage@2|

; 949  :         }
; 950  : 
; 951  :     bResult = TRUE;
; 952  :             
; 953  :     DEBUGMSG(ZONE_FUNCTION, (L"-SetVoltageMonitors()\r\n"));
; 954  :     return bResult;

  00144	e3a00001	 mov         r0, #1

; 955  : }

  00148	e28dd004	 add         sp, sp, #4
  0014c	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00150	e12fff1e	 bx          lr
  00154		 |$M45010|

			 ENDP  ; |SetVoltageMonitors|


  00000			 AREA	 |.pdata|, PDATA
|$T45022| DCD	|$LN6@SetChargeM|
	DCD	0x40002202
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetChargeMode_ACCharge| PROC

; 967  : {

  00000		 |$LN6@SetChargeM|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M45019|
  00008	e1a04000	 mov         r4, r0

; 968  :     UINT8 data;
; 969  :     BOOL bResult = FALSE;
; 970  :     DEBUGMSG(ZONE_FUNCTION, (L"+SetChargeMode_ACCharge(pDevice=0x%08X)\r\n",
; 971  :         pDevice
; 972  :         ));
; 973  : 
; 974  :     // check if already in auto mode
; 975  :     TWLReadRegs(pDevice->hTwl, TWL_BOOT_BCI, &data, 1);

  0000c	e5940018	 ldr         r0, [r4, #0x18]
  00010	e3a05803	 mov         r5, #3, 16
  00014	e385103d	 orr         r1, r5, #0x3D
  00018	e3a03001	 mov         r3, #1
  0001c	e28d2000	 add         r2, sp, #0
  00020	eb000000	 bl          TWLReadRegs

; 976  :     if ((data & BCIAUTOAC) == 0)

  00024	e5dd3000	 ldrb        r3, [sp]
  00028	e3130001	 tst         r3, #1
  0002c	1a00000e	 bne         |$LN1@SetChargeM|

; 977  :         {
; 978  :         // disable charge mode
; 979  :         data = KEY_BCIOFF;
; 980  :         TWLWriteRegs(pDevice->hTwl, TWL_BCIMDKEY, &data, 1);

  00030	e5940018	 ldr         r0, [r4, #0x18]
  00034	e3a03802	 mov         r3, #2, 16
  00038	e3831075	 orr         r1, r3, #0x75
  0003c	e3a0e02a	 mov         lr, #0x2A
  00040	e3a03001	 mov         r3, #1
  00044	e28d2000	 add         r2, sp, #0
  00048	e5cde000	 strb        lr, [sp]
  0004c	eb000000	 bl          TWLWriteRegs

; 981  : 
; 982  :         // enable auto charge
; 983  :         data = CONFIG_DONE | BCIAUTOAC;
; 984  :         TWLWriteRegs(pDevice->hTwl, TWL_BOOT_BCI, &data, 1);

  00050	e5940018	 ldr         r0, [r4, #0x18]
  00054	e3a0e011	 mov         lr, #0x11
  00058	e3a03001	 mov         r3, #1
  0005c	e28d2000	 add         r2, sp, #0
  00060	e385103d	 orr         r1, r5, #0x3D
  00064	e5cde000	 strb        lr, [sp]
  00068	eb000000	 bl          TWLWriteRegs
  0006c		 |$LN1@SetChargeM|

; 985  :         }
; 986  : 
; 987  :     UpdateChargeCurrent(pDevice, pDevice->acChargeCurrent);

  0006c	e1d413ba	 ldrh        r1, [r4, #0x3A]
  00070	e1a00004	 mov         r0, r4
  00074	eb000000	 bl          UpdateChargeCurrent

; 988  :             
; 989  :     DEBUGMSG(ZONE_FUNCTION, (L"-SetChargeMode_ACCharge()\r\n"));
; 990  :     return bResult;

  00078	e3a00000	 mov         r0, #0

; 991  : }

  0007c	e28dd004	 add         sp, sp, #4
  00080	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00084	e12fff1e	 bx          lr
  00088		 |$M45020|

			 ENDP  ; |SetChargeMode_ACCharge|


  00000			 AREA	 |.pdata|, PDATA
|$T45034| DCD	|$LN8@SetChargeM@2|
	DCD	0x40005202
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetChargeMode_USBHost| PROC

; 1032 : {

  00000		 |$LN8@SetChargeM@2|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M45031|
  00008	e1a05000	 mov         r5, r0

; 1033 :     UINT8 data;
; 1034 :     DWORD dwOVMon = 0;
; 1035 :     BOOL bResult = FALSE;
; 1036 :     DEBUGMSG(ZONE_FUNCTION, (L"+SetChargeMode_USBHost(pDevice=0x%08X)\r\n",
; 1037 :         pDevice
; 1038 :         ));
; 1039 : 
; 1040 :     // disable auto mode
; 1041 :     data = CONFIG_DONE;
; 1042 :     TWLWriteRegs(pDevice->hTwl, TWL_BOOT_BCI, &data, 1);

  0000c	e5950018	 ldr         r0, [r5, #0x18]
  00010	e3a03803	 mov         r3, #3, 16
  00014	e383103d	 orr         r1, r3, #0x3D
  00018	e3a0e010	 mov         lr, #0x10
  0001c	e3a03001	 mov         r3, #1
  00020	e28d2000	 add         r2, sp, #0
  00024	e5cde000	 strb        lr, [sp]
  00028	eb000000	 bl          TWLWriteRegs

; 1043 : 
; 1044 :     // disable hw monitoring functions
; 1045 :     dwOVMon = QueryVoltageMonitors(pDevice);

  0002c	e1a00005	 mov         r0, r5
  00030	eb000000	 bl          QueryVoltageMonitors
  00034	e1a04000	 mov         r4, r0

; 1046 :     SetVoltageMonitors(pDevice, 0, BCI_OV_VBAT | BCI_OV_VBUS | BCI_OV_VAC);

  00038	e1a00005	 mov         r0, r5
  0003c	e3a02007	 mov         r2, #7
  00040	e3a01000	 mov         r1, #0
  00044	eb000000	 bl          SetVoltageMonitors

; 1047 : 
; 1048 :     UpdateChargeCurrent(pDevice, pDevice->usbChargeCurrent);    

  00048	e1d513b8	 ldrh        r1, [r5, #0x38]
  0004c	e1a00005	 mov         r0, r5
  00050	eb000000	 bl          UpdateChargeCurrent

; 1049 : 
; 1050 :     // put device in USB Linear charge mode
; 1051 :     data = KEY_BCIOFF;
; 1052 :     TWLWriteRegs(pDevice->hTwl, TWL_BCIMDKEY, &data, 1);

  00054	e5950018	 ldr         r0, [r5, #0x18]
  00058	e3a07802	 mov         r7, #2, 16
  0005c	e3a0e02a	 mov         lr, #0x2A
  00060	e3871075	 orr         r1, r7, #0x75
  00064	e3a03001	 mov         r3, #1
  00068	e28d2000	 add         r2, sp, #0
  0006c	e5cde000	 strb        lr, [sp]
  00070	eb000000	 bl          TWLWriteRegs

; 1053 : 
; 1054 :     // indicate USB-host charge
; 1055 :     data = USBSLOWMCHG;
; 1056 :     TWLWriteRegs(pDevice->hTwl, TWL_BCIMFSTS4, &data, 1);

  00074	e5950018	 ldr         r0, [r5, #0x18]
  00078	e3a06802	 mov         r6, #2, 16
  0007c	e3a0e002	 mov         lr, #2
  00080	e3861084	 orr         r1, r6, #0x84
  00084	e3a03001	 mov         r3, #1
  00088	e28d2000	 add         r2, sp, #0
  0008c	e5cde000	 strb        lr, [sp]
  00090	eb000000	 bl          TWLWriteRegs

; 1057 : 
; 1058 :     data = KEY_BCIUSBLINEAR;
; 1059 :     TWLWriteRegs(pDevice->hTwl, TWL_BCIMDKEY, &data, 1);

  00094	e5950018	 ldr         r0, [r5, #0x18]
  00098	e3a0e026	 mov         lr, #0x26
  0009c	e3a03001	 mov         r3, #1
  000a0	e28d2000	 add         r2, sp, #0
  000a4	e3871075	 orr         r1, r7, #0x75
  000a8	e5cde000	 strb        lr, [sp]
  000ac	eb000000	 bl          TWLWriteRegs

; 1060 : 
; 1061 :     // disable watchdog
; 1062 :     data = KEY_BCIWDKEY5;
; 1063 :     TWLWriteRegs(pDevice->hTwl, TWL_BCIWDKEY, &data, 1);

  000b0	e5950018	 ldr         r0, [r5, #0x18]
  000b4	e3a0e0f3	 mov         lr, #0xF3
  000b8	e3a03001	 mov         r3, #1
  000bc	e28d2000	 add         r2, sp, #0
  000c0	e3861095	 orr         r1, r6, #0x95
  000c4	e5cde000	 strb        lr, [sp]
  000c8	eb000000	 bl          TWLWriteRegs

; 1064 : 
; 1065 :     // re-enable monitoring functions
; 1066 :     if ((pDevice->dwACCHGOVTH & THRESHOLD_DISABLED) == 0) dwOVMon |= BCI_OV_VAC;

  000cc	e5953044	 ldr         r3, [r5, #0x44]

; 1067 :     if ((pDevice->dwVBUSOVTH & THRESHOLD_DISABLED) == 0) dwOVMon |= BCI_OV_VBUS;
; 1068 :     if ((pDevice->dwVBATOVTH & THRESHOLD_DISABLED) == 0) dwOVMon |= BCI_OV_VBAT;
; 1069 :     SetVoltageMonitors(pDevice, dwOVMon, BCI_OV_VBAT | BCI_OV_VBUS | BCI_OV_VAC);

  000d0	e3a02007	 mov         r2, #7
  000d4	e1a00005	 mov         r0, r5
  000d8	e3130102	 tst         r3, #2, 2
  000dc	e595304c	 ldr         r3, [r5, #0x4C]
  000e0	03844004	 orreq       r4, r4, #4
  000e4	e3130102	 tst         r3, #2, 2
  000e8	e5953048	 ldr         r3, [r5, #0x48]
  000ec	03844002	 orreq       r4, r4, #2
  000f0	e3130102	 tst         r3, #2, 2
  000f4	03844001	 orreq       r4, r4, #1
  000f8	e1a01004	 mov         r1, r4
  000fc	eb000000	 bl          SetVoltageMonitors

; 1070 : 
; 1071 :     TWLReadRegs(pDevice->hTwl, TWL_BCICTL1, &data, 1);

  00100	e5950018	 ldr         r0, [r5, #0x18]
  00104	e3a04802	 mov         r4, #2, 16
  00108	e3841097	 orr         r1, r4, #0x97
  0010c	e3a03001	 mov         r3, #1
  00110	e28d2000	 add         r2, sp, #0
  00114	eb000000	 bl          TWLReadRegs

; 1072 :     data |= MESVBUS;

  00118	e5dd3000	 ldrb        r3, [sp]

; 1073 :     TWLWriteRegs(pDevice->hTwl, TWL_BCICTL1, &data, 1);

  0011c	e5950018	 ldr         r0, [r5, #0x18]
  00120	e28d2000	 add         r2, sp, #0
  00124	e3833004	 orr         r3, r3, #4
  00128	e5cd3000	 strb        r3, [sp]
  0012c	e3a03001	 mov         r3, #1
  00130	e3841097	 orr         r1, r4, #0x97
  00134	eb000000	 bl          TWLWriteRegs

; 1074 :         
; 1075 :     DEBUGMSG(ZONE_FUNCTION, (L"-SetChargeMode_USBHost()\r\n"));
; 1076 :     return bResult;

  00138	e3a00000	 mov         r0, #0

; 1077 : }

  0013c	e28dd004	 add         sp, sp, #4
  00140	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00144	e12fff1e	 bx          lr
  00148		 |$M45032|

			 ENDP  ; |SetChargeMode_USBHost|

	EXPORT	|BCI_Uninitialize|
	IMPORT	|DeleteCriticalSection|
	IMPORT	|TWLInterruptMask|
	IMPORT	|TWLInterruptDisable|
	IMPORT	|WaitForSingleObject|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T45046| DCD	|$LN14@BCI_Uninit|
	DCD	0x40006501
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\bci\bci.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BCI_Uninitialize| PROC

; 1366 : {

  00000		 |$LN14@BCI_Uninit|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M45043|
  00004	e1b04000	 movs        r4, r0

; 1367 :     Device_t *pDevice;
; 1368 :     DEBUGMSG(ZONE_FUNCTION, (L"+BCI_Uninitialize(hBCI=0x%08X)\r\n", hBCI));
; 1369 : 
; 1370 :     // check for valid parameter
; 1371 :     if (hBCI == NULL) return;

  00008	0a000053	 beq         |$LN8@BCI_Uninit|

; 1372 :     pDevice = (Device_t*)hBCI;
; 1373 : 
; 1374 :     // Signal stop to threads
; 1375 :     pDevice->threadsExit = TRUE;
; 1376 : 
; 1377 :     // Close interrupt thread
; 1378 :     if (pDevice->hIntrThread != NULL)

  0000c	e5943024	 ldr         r3, [r4, #0x24]
  00010	e3a02001	 mov         r2, #1
  00014	e584203c	 str         r2, [r4, #0x3C]
  00018	e3530000	 cmp         r3, #0
  0001c	0a000007	 beq         |$LN6@BCI_Uninit|

; 1379 :         {
; 1380 :         // Set event to wake it
; 1381 :         SetEvent(pDevice->rgIntrEvents[EVENT_BCI]);

  00020	e594002c	 ldr         r0, [r4, #0x2C]
  00024	e3a01003	 mov         r1, #3
  00028	eb000000	 bl          EventModify

; 1382 :         // Wait until thread exits
; 1383 :         WaitForSingleObject(pDevice->hIntrThread, INFINITE);

  0002c	e5940024	 ldr         r0, [r4, #0x24]
  00030	e3e01000	 mvn         r1, #0
  00034	eb000000	 bl          WaitForSingleObject

; 1384 :         // Close handle
; 1385 :         CloseHandle(pDevice->hIntrThread);

  00038	e5940024	 ldr         r0, [r4, #0x24]
  0003c	eb000000	 bl          CloseHandle
  00040		 |$LN6@BCI_Uninit|

; 1386 :         }
; 1387 : 
; 1388 :     if (pDevice->hBattSignal != NULL)

  00040	e5943020	 ldr         r3, [r4, #0x20]
  00044	e3530000	 cmp         r3, #0

; 1389 :         {
; 1390 :         CloseHandle(pDevice->hBattSignal);

  00048	11a00003	 movne       r0, r3
  0004c	1b000000	 blne        CloseHandle

; 1391 :         }
; 1392 : 
; 1393 :     // release allocated resources
; 1394 :     if (pDevice->rgIntrEvents[EVENT_BCI] != NULL)

  00050	e594302c	 ldr         r3, [r4, #0x2C]
  00054	e3530000	 cmp         r3, #0
  00058	0a000020	 beq         |$LN4@BCI_Uninit|

; 1395 :         {
; 1396 :         // register for bci interrupts
; 1397 :         TWLInterruptDisable(pDevice->hTwl, TWL_INTR_ICHGHIGH);

  0005c	e59f112c	 ldr         r1, [pc, #0x12C]
  00060	e5940018	 ldr         r0, [r4, #0x18]
  00064	eb000000	 bl          TWLInterruptDisable

; 1398 :         TWLInterruptDisable(pDevice->hTwl, TWL_INTR_ICHGLOW);

  00068	e59f111c	 ldr         r1, [pc, #0x11C]
  0006c	e5940018	 ldr         r0, [r4, #0x18]
  00070	eb000000	 bl          TWLInterruptDisable

; 1399 :         TWLInterruptDisable(pDevice->hTwl, TWL_INTR_ICHGEOC);

  00074	e59f110c	 ldr         r1, [pc, #0x10C]
  00078	e5940018	 ldr         r0, [r4, #0x18]
  0007c	eb000000	 bl          TWLInterruptDisable

; 1400 :         TWLInterruptDisable(pDevice->hTwl, TWL_INTR_TBATOR2);

  00080	e59f10fc	 ldr         r1, [pc, #0xFC]
  00084	e5940018	 ldr         r0, [r4, #0x18]
  00088	eb000000	 bl          TWLInterruptDisable

; 1401 :         TWLInterruptDisable(pDevice->hTwl, TWL_INTR_TBATOR1);

  0008c	e59f10ec	 ldr         r1, [pc, #0xEC]
  00090	e5940018	 ldr         r0, [r4, #0x18]
  00094	eb000000	 bl          TWLInterruptDisable

; 1402 :         TWLInterruptDisable(pDevice->hTwl, TWL_INTR_BATSTS);

  00098	e59f10dc	 ldr         r1, [pc, #0xDC]
  0009c	e5940018	 ldr         r0, [r4, #0x18]
  000a0	eb000000	 bl          TWLInterruptDisable

; 1403 :         TWLInterruptDisable(pDevice->hTwl, TWL_INTR_VBATLVL);

  000a4	e5940018	 ldr         r0, [r4, #0x18]
  000a8	e3a03a12	 mov         r3, #0x12, 20
  000ac	e3831010	 orr         r1, r3, #0x10
  000b0	eb000000	 bl          TWLInterruptDisable

; 1404 :         TWLInterruptDisable(pDevice->hTwl, TWL_INTR_VBATOV);

  000b4	e59f10bc	 ldr         r1, [pc, #0xBC]
  000b8	e5940018	 ldr         r0, [r4, #0x18]
  000bc	eb000000	 bl          TWLInterruptDisable

; 1405 :         TWLInterruptDisable(pDevice->hTwl, TWL_INTR_VBUSOV);

  000c0	e59f10ac	 ldr         r1, [pc, #0xAC]
  000c4	e5940018	 ldr         r0, [r4, #0x18]
  000c8	eb000000	 bl          TWLInterruptDisable

; 1406 :         TWLInterruptDisable(pDevice->hTwl, TWL_INTR_ACCHGOV);

  000cc	e59f109c	 ldr         r1, [pc, #0x9C]
  000d0	e5940018	 ldr         r0, [r4, #0x18]
  000d4	eb000000	 bl          TWLInterruptDisable

; 1407 :         CloseHandle(pDevice->rgIntrEvents[EVENT_BCI]);

  000d8	e594002c	 ldr         r0, [r4, #0x2C]
  000dc	eb000000	 bl          CloseHandle
  000e0		 |$LN4@BCI_Uninit|

; 1408 :         }
; 1409 : 
; 1410 :     if (pDevice->rgIntrEvents[EVENT_POWER] != NULL)

  000e0	e5943028	 ldr         r3, [r4, #0x28]
  000e4	e3530000	 cmp         r3, #0
  000e8	0a000005	 beq         |$LN3@BCI_Uninit|

; 1411 :         {
; 1412 :         TWLInterruptMask(pDevice->hTwl, TWL_INTR_CHG_PRES, TRUE);        

  000ec	e59f1078	 ldr         r1, [pc, #0x78]
  000f0	e5940018	 ldr         r0, [r4, #0x18]
  000f4	e3a02001	 mov         r2, #1
  000f8	eb000000	 bl          TWLInterruptMask

; 1413 :         CloseHandle(pDevice->rgIntrEvents[EVENT_POWER]);

  000fc	e5940028	 ldr         r0, [r4, #0x28]
  00100	eb000000	 bl          CloseHandle
  00104		 |$LN3@BCI_Uninit|

; 1414 :         }
; 1415 : 
; 1416 :     if (pDevice->rgIntrEvents[EVENT_HOTDIE] != NULL)

  00104	e5943030	 ldr         r3, [r4, #0x30]
  00108	e3530000	 cmp         r3, #0
  0010c	0a000008	 beq         |$LN2@BCI_Uninit|

; 1417 :         {
; 1418 :         TWLInterruptMask(pDevice->hTwl, TWL_INTR_HOT_DIE, TRUE);

  00110	e5940018	 ldr         r0, [r4, #0x18]
  00114	e59f104c	 ldr         r1, [pc, #0x4C]
  00118	e3a02001	 mov         r2, #1
  0011c	eb000000	 bl          TWLInterruptMask

; 1419 :         // Unregister for Hot-Die detector interrupts
; 1420 :         TWLInterruptDisable(pDevice->hTwl, TWL_INTR_HOT_DIE);

  00120	e5940018	 ldr         r0, [r4, #0x18]
  00124	e59f103c	 ldr         r1, [pc, #0x3C]
  00128	eb000000	 bl          TWLInterruptDisable

; 1421 :         CloseHandle(pDevice->rgIntrEvents[EVENT_HOTDIE]);

  0012c	e5940030	 ldr         r0, [r4, #0x30]
  00130	eb000000	 bl          CloseHandle
  00134		 |$LN2@BCI_Uninit|

; 1422 :         }
; 1423 :     if (hHotDieTriggerEvent_Test!=NULL)

  00134	e59f3028	 ldr         r3, [pc, #0x28]
  00138	e5930000	 ldr         r0, [r3]
  0013c	e3500000	 cmp         r0, #0

; 1424 :         {
; 1425 :         CloseHandle(hHotDieTriggerEvent_Test);

  00140	1b000000	 blne        CloseHandle

; 1426 :         }
; 1427 :     
; 1428 :     // close all handles
; 1429 :     CloseHandle(pDevice->hTwl);

  00144	e5940018	 ldr         r0, [r4, #0x18]
  00148	eb000000	 bl          CloseHandle

; 1430 : 
; 1431 :     // Delete critical section
; 1432 :     DeleteCriticalSection(&pDevice->cs);

  0014c	e1a00004	 mov         r0, r4
  00150	eb000000	 bl          DeleteCriticalSection

; 1433 : 
; 1434 :     LocalFree(pDevice);

  00154	e1a00004	 mov         r0, r4
  00158	eb000000	 bl          LocalFree
  0015c		 |$LN8@BCI_Uninit|

; 1435 :     
; 1436 :     DEBUGMSG(ZONE_FUNCTION, (L"-BCI_Uninitialize()\r\n"));
; 1437 : }

  0015c	e8bd4010	 ldmia       sp!, {r4, lr}
  00160	e12fff1e	 bx          lr
  00164		 |$LN15@BCI_Uninit|
  00164		 |$LN16@BCI_Uninit|
  00164	00000000	 DCD         |hHotDieTriggerEvent_Test|
  00168		 |$LN17@BCI_Uninit|
  00168	04005004	 DCD         0x4005004
  0016c		 |$LN18@BCI_Uninit|
  0016c	01005001	 DCD         0x1005001
  00170		 |$LN19@BCI_Uninit|
  00170	03012013	 DCD         0x3012013
  00174		 |$LN20@BCI_Uninit|
  00174	02012012	 DCD         0x2012012
  00178		 |$LN21@BCI_Uninit|
  00178	01012011	 DCD         0x1012011
  0017c		 |$LN22@BCI_Uninit|
  0017c	0700200f	 DCD         0x700200f
  00180		 |$LN23@BCI_Uninit|
  00180	0600200e	 DCD         0x600200e
  00184		 |$LN24@BCI_Uninit|
  00184	0500200d	 DCD         0x500200d
  00188		 |$LN25@BCI_Uninit|
  00188	0400200c	 DCD         0x400200c
  0018c		 |$LN26@BCI_Uninit|
  0018c	0300200b	 DCD         0x300200b
  00190		 |$LN27@BCI_Uninit|
  00190	0200200a	 DCD         0x200200a
  00194		 |$M45044|

			 ENDP  ; |BCI_Uninitialize|

	EXPORT	|BCI_GetBatteryVoltage|
; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\inc\madc.h

  00000			 AREA	 |.pdata|, PDATA
|$T45081| DCD	|$LN9@BCI_GetBat|
	DCD	0x40001b02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\bci\bci.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BCI_GetBatteryVoltage| PROC

; 1448 : {

  00000		 |$LN9@BCI_GetBat|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M45078|
  00008	e1a05000	 mov         r5, r0

; 1449 :     DWORD data = 0;
; 1450 :     DWORD volts;
; 1451 :     Device_t *pDevice = (Device_t*)hBCI;
; 1452 :     
; 1453 :     // return current battery voltage
; 1454 :     MADCReadValue(pDevice->hMadc, MADC_CHANNEL_BCI4, &data, 1);

  0000c	e595301c	 ldr         r3, [r5, #0x1C]
  00010	e3a02000	 mov         r2, #0
  00014	e58d2004	 str         r2, [sp, #4]
  00018	e5930000	 ldr         r0, [r3]
  0001c	e5934004	 ldr         r4, [r3, #4]
  00020	e3a03001	 mov         r3, #1
  00024	e28d2004	 add         r2, sp, #4
  00028	e3a01601	 mov         r1, #1, 12
  0002c	e1a0e00f	 mov         lr, pc
  00030	e12fff14	 bx          r4

; 1455 :     MADCConvertToVolts(pDevice->hMadc, MADC_CHANNEL_BCI4, &data, &volts, 1);

  00034	e595201c	 ldr         r2, [r5, #0x1C]
  00038	e3a05001	 mov         r5, #1
  0003c	e28d3008	 add         r3, sp, #8
  00040	e5920000	 ldr         r0, [r2]
  00044	e5924008	 ldr         r4, [r2, #8]
  00048	e28d2004	 add         r2, sp, #4
  0004c	e3a01601	 mov         r1, #1, 12
  00050	e58d5000	 str         r5, [sp]
  00054	e1a0e00f	 mov         lr, pc
  00058	e12fff14	 bx          r4

; 1456 : 
; 1457 :     return volts;

  0005c	e59d0008	 ldr         r0, [sp, #8]

; 1458 : }

  00060	e28dd00c	 add         sp, sp, #0xC
  00064	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00068	e12fff1e	 bx          lr
  0006c		 |$M45079|

			 ENDP  ; |BCI_GetBatteryVoltage|

	EXPORT	|BCI_GetBatteryTemperature|
; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\inc\madc.h

  00000			 AREA	 |.pdata|, PDATA
|$T45103| DCD	|$LN9@BCI_GetBat@2|
	DCD	0x40001b02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\bci\bci.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BCI_GetBatteryTemperature| PROC

; 1469 : {

  00000		 |$LN9@BCI_GetBat@2|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M45100|
  00008	e1a05000	 mov         r5, r0

; 1470 :     DWORD data = 0;
; 1471 :     DWORD temp;
; 1472 :     Device_t *pDevice = (Device_t*)hBCI;
; 1473 :     
; 1474 :     // return current battery voltage
; 1475 :     MADCReadValue(pDevice->hMadc, MADC_CHANNEL_BCI0, &data, 1);

  0000c	e595301c	 ldr         r3, [r5, #0x1C]
  00010	e3a02000	 mov         r2, #0
  00014	e58d2004	 str         r2, [sp, #4]
  00018	e5930000	 ldr         r0, [r3]
  0001c	e5934004	 ldr         r4, [r3, #4]
  00020	e3a03001	 mov         r3, #1
  00024	e28d2004	 add         r2, sp, #4
  00028	e3a01801	 mov         r1, #1, 16
  0002c	e1a0e00f	 mov         lr, pc
  00030	e12fff14	 bx          r4

; 1476 :     MADCConvertToVolts(pDevice->hMadc, MADC_CHANNEL_BCI0, &data, &temp, 1);

  00034	e595201c	 ldr         r2, [r5, #0x1C]
  00038	e3a05001	 mov         r5, #1
  0003c	e28d3008	 add         r3, sp, #8
  00040	e5920000	 ldr         r0, [r2]
  00044	e5924008	 ldr         r4, [r2, #8]
  00048	e28d2004	 add         r2, sp, #4
  0004c	e3a01801	 mov         r1, #1, 16
  00050	e58d5000	 str         r5, [sp]
  00054	e1a0e00f	 mov         lr, pc
  00058	e12fff14	 bx          r4

; 1477 : 
; 1478 :     return temp;

  0005c	e59d0008	 ldr         r0, [sp, #8]

; 1479 : }

  00060	e28dd00c	 add         sp, sp, #0xC
  00064	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00068	e12fff1e	 bx          lr
  0006c		 |$M45101|

			 ENDP  ; |BCI_GetBatteryTemperature|

	EXPORT	|BCI_SetTimeouts|

  00000			 AREA	 |.pdata|, PDATA
|$T45117| DCD	|$LN6@BCI_SetTim|
	DCD	0x40000b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BCI_SetTimeouts| PROC

; 1494 : {

  00000		 |$LN6@BCI_SetTim|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45114|
  00004	e3500000	 cmp         r0, #0

; 1495 :     BOOL bResult = FALSE;

  00008	e3a0e000	 mov         lr, #0

; 1496 :     Device_t *pDevice = (Device_t*)hBCI;
; 1497 :     DEBUGMSG(ZONE_FUNCTION, (L"+BCI_SetTimeouts("
; 1498 :         L"nEOCTimeout=%d, nOverChargeTimeout=%d, nOverVoltageTimeout=%d"
; 1499 :         L" nOOBTemperatureTimeout=%d)\r\n", nEOCTimeout, nOverChargeTimeout,
; 1500 :         nOverVoltageTimeout, nOOBTemperatureTimeout)
; 1501 :         );
; 1502 : 
; 1503 :     // check for valid parameter
; 1504 :     if (pDevice == NULL) goto cleanUp;
; 1505 : 
; 1506 :     pDevice->nEndOfChargeTimeout = nEOCTimeout;
; 1507 :     pDevice->nOverChargeTimeout = nOverChargeTimeout;
; 1508 :     pDevice->nOverVoltageTimeout = nOverVoltageTimeout;
; 1509 :     pDevice->nOOBTemperatureTimeout = nOOBTemperatureTimeout;

  0000c	159de004	 ldrne       lr, [sp, #4]
  00010	1580205c	 strne       r2, [r0, #0x5C]
  00014	1280c050	 addne       r12, r0, #0x50
  00018	188c400a	 stmneia     r12, {r1, r3, lr}

; 1510 : 
; 1511 :     bResult = TRUE;

  0001c	13a0e001	 movne       lr, #1
  00020		 |$cleanUp$44270|

; 1512 :        
; 1513 : cleanUp:    
; 1514 :     DEBUGMSG(ZONE_FUNCTION, (L"-BCI_SetTimeouts()\r\n"));
; 1515 :     return bResult;
; 1516 : }

  00020	e1a0000e	 mov         r0, lr
  00024	e49de004	 ldr         lr, [sp], #4
  00028	e12fff1e	 bx          lr
  0002c		 |$M45115|

			 ENDP  ; |BCI_SetTimeouts|

	EXPORT	|BCI_SetPrescale|

  00000			 AREA	 |.pdata|, PDATA
|$T45138| DCD	|$LN10@BCI_SetPre|
	DCD	0x40002b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BCI_SetPrescale| PROC

; 1528 : {

  00000		 |$LN10@BCI_SetPre|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M45135|
  00008	e1a05001	 mov         r5, r1
  0000c	e1b04000	 movs        r4, r0

; 1529 :     BOOL bResult = FALSE;

  00010	e3a00000	 mov         r0, #0

; 1530 :     Device_t *pDevice = (Device_t*)hBCI;
; 1531 :     DEBUGMSG(ZONE_FUNCTION, (L"+BCI_SetPrescale("L"preScale=%d\r\n)", 
; 1532 :         preScale)
; 1533 :         );
; 1534 : 
; 1535 :     // check for valid parameter
; 1536 :     if (pDevice == NULL) goto cleanUp;

  00014	0a000021	 beq         |$cleanUp$44283|

; 1537 : 
; 1538 :     SetPrescale(pDevice, preScale);

  00018	e5940018	 ldr         r0, [r4, #0x18]
  0001c	e3a07802	 mov         r7, #2, 16
  00020	e3871097	 orr         r1, r7, #0x97
  00024	e3a03001	 mov         r3, #1
  00028	e28d2000	 add         r2, sp, #0
  0002c	eb000000	 bl          TWLReadRegs
  00030	e5dd3000	 ldrb        r3, [sp]
  00034	e3550001	 cmp         r5, #1
  00038	e5940018	 ldr         r0, [r4, #0x18]
  0003c	8383e020	 orrhi       lr, r3, #0x20
  00040	93c3e020	 bicls       lr, r3, #0x20
  00044	e3a03802	 mov         r3, #2, 16
  00048	e3831075	 orr         r1, r3, #0x75
  0004c	e3a0602a	 mov         r6, #0x2A
  00050	e3a03001	 mov         r3, #1
  00054	e28d2001	 add         r2, sp, #1
  00058	e5cde000	 strb        lr, [sp]
  0005c	e5cd6001	 strb        r6, [sp, #1]
  00060	eb000000	 bl          TWLWriteRegs
  00064	e5940018	 ldr         r0, [r4, #0x18]
  00068	e3a03001	 mov         r3, #1
  0006c	e28d2000	 add         r2, sp, #0
  00070	e3871097	 orr         r1, r7, #0x97
  00074	eb000000	 bl          TWLWriteRegs
  00078	e5940018	 ldr         r0, [r4, #0x18]
  0007c	e3a03803	 mov         r3, #3, 16
  00080	e383103d	 orr         r1, r3, #0x3D
  00084	e3a0e011	 mov         lr, #0x11
  00088	e3a03001	 mov         r3, #1
  0008c	e28d2001	 add         r2, sp, #1
  00090	e5cde001	 strb        lr, [sp, #1]
  00094	eb000000	 bl          TWLWriteRegs
  00098	e5845034	 str         r5, [r4, #0x34]

; 1539 : 
; 1540 :     bResult = TRUE;

  0009c	e3a00001	 mov         r0, #1
  000a0		 |$cleanUp$44283|

; 1541 :        
; 1542 : cleanUp:    
; 1543 :     DEBUGMSG(ZONE_FUNCTION, (L"-BCI_SetPrescale()\r\n"));
; 1544 :     return bResult;
; 1545 : }

  000a0	e28dd004	 add         sp, sp, #4
  000a4	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000a8	e12fff1e	 bx          lr
  000ac		 |$M45136|

			 ENDP  ; |BCI_SetPrescale|

	EXPORT	|BCI_SetChargeCurrent|
	IMPORT	|__utos|
	IMPORT	|__divs|
	IMPORT	|__stou|

  00000			 AREA	 |.pdata|, PDATA
|$T45157| DCD	|$LN16@BCI_SetCha|
	DCD	0x40002901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BCI_SetChargeCurrent| PROC

; 1559 : {

  00000		 |$LN16@BCI_SetCha|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M45154|
  00004	e1a05001	 mov         r5, r1
  00008	e1b04000	 movs        r4, r0
  0000c	e3a03c06	 mov         r3, #6, 24

; 1560 :     UINT16 bciiref1;
; 1561 :     BOOL bResult = FALSE;
; 1562 :     Device_t *pDevice = (Device_t*)hBCI;
; 1563 :     DWORD maxChargeCurrent = BCI_MAX_CHARGECURRENT;

  00010	e38330a8	 orr         r3, r3, #0xA8
  00014	e3a06000	 mov         r6, #0

; 1564 :     DEBUGMSG(ZONE_FUNCTION, (L"+BCI_SetChargeCurrent("
; 1565 :         L"mode=%d, chargeCurrent=%d)\r\n", mode, chargeCurrent)
; 1566 :         );
; 1567 : 
; 1568 :     // check for valid parameter
; 1569 :     if (pDevice == NULL) goto cleanUp;

  00018	0a00001d	 beq         |$cleanUp$44300|

; 1570 : 
; 1571 :     // check if prescalar is disabled, adjust max current accordingly
; 1572 :     if (pDevice->preScale < 2)

  0001c	e5947034	 ldr         r7, [r4, #0x34]
  00020	e3570002	 cmp         r7, #2

; 1573 :         {
; 1574 :         maxChargeCurrent >>= 1;

  00024	33a03fd5	 movcc       r3, #0xD5, 30

; 1575 :         }
; 1576 :     
; 1577 :     if (chargeCurrent > maxChargeCurrent)

  00028	e1520003	 cmp         r2, r3
  0002c	8a000018	 bhi         |$cleanUp$44300|

; 1578 :         {
; 1579 :         DEBUGMSG(ZONE_WARN, (L"WARN: invalid charge current settings "
; 1580 :             L"%d mA, must be in range of [%d, %d]mA\r\n", chargeCurrent,
; 1581 :             0, maxChargeCurrent)
; 1582 :             );
; 1583 :         goto cleanUp;
; 1584 :         }
; 1585 : 
; 1586 :     // calculate new charge current
; 1587 :     bciiref1 = (UINT16)((float)chargeCurrent/BCI_DEFAULT_CHARGECURRENT_STEPS);

  00030	e1a00002	 mov         r0, r2
  00034	eb000000	 bl          __utos
  00038	e59f1060	 ldr         r1, [pc, #0x60]
  0003c	eb000000	 bl          __divs
  00040	eb000000	 bl          __stou
  00044	e1a03800	 mov         r3, r0, lsl #16
  00048	e1a03823	 mov         r3, r3, lsr #16

; 1588 : 
; 1589 :     // check for scaled values
; 1590 :     if (pDevice->preScale > 1)

  0004c	e3570001	 cmp         r7, #1

; 1591 :         {
; 1592 :         bciiref1 >>= 1;

  00050	81a030a3	 movhi       r3, r3, lsr #1

; 1593 :         }
; 1594 : 
; 1595 :     // account for maximas
; 1596 :     if (bciiref1 == BCI_MAX_BCIIREF1)

  00054	e3530c02	 cmp         r3, #2, 24
  00058	03a03c01	 moveq       r3, #1, 24

; 1597 :         {
; 1598 :         bciiref1 -= 1;

  0005c	038330ff	 orreq       r3, r3, #0xFF

; 1599 :         }
; 1600 : 
; 1601 :     // always set high bit of BCIIREF1
; 1602 :     bciiref1 |= BCIREF1_HBIT;

  00060	e3831c02	 orr         r1, r3, #2, 24

; 1603 : 
; 1604 :     // save charge current info
; 1605 :     switch (mode)

  00064	e3550001	 cmp         r5, #1
  00068	0a000003	 beq         |$LN4@BCI_SetCha|
  0006c	e3550002	 cmp         r5, #2
  00070	1a000007	 bne         |$cleanUp$44300|

; 1609 :             break;
; 1610 : 
; 1611 :         case kBCI_USBHost:
; 1612 :             pDevice->usbChargeCurrent = bciiref1;

  00074	e1c413b8	 strh        r1, [r4, #0x38]

; 1613 :             break;

  00078	ea000000	 b           |$LN5@BCI_SetCha|
  0007c		 |$LN4@BCI_SetCha|

; 1606 :         {
; 1607 :         case kBCI_AC:
; 1608 :             pDevice->acChargeCurrent = bciiref1;

  0007c	e1c413ba	 strh        r1, [r4, #0x3A]
  00080		 |$LN5@BCI_SetCha|

; 1614 : 
; 1615 :         default:
; 1616 :             goto cleanUp;
; 1617 :         }
; 1618 : 
; 1619 :     // check current charge mode and apply new settings if applicable
; 1620 :     if (pDevice->currentMode == mode)

  00080	e5943014	 ldr         r3, [r4, #0x14]
  00084	e1530005	 cmp         r3, r5

; 1621 :         {
; 1622 :         UpdateChargeCurrent(pDevice, bciiref1);

  00088	01a00004	 moveq       r0, r4
  0008c	0b000000	 bleq        UpdateChargeCurrent

; 1623 :         }
; 1624 : 
; 1625 :     bResult = TRUE;

  00090	e3a06001	 mov         r6, #1
  00094		 |$cleanUp$44300|

; 1626 :        
; 1627 : cleanUp:    
; 1628 :     DEBUGMSG(ZONE_FUNCTION, (L"-BCI_SetChargeCurrent()\r\n"));
; 1629 :     return bResult;
; 1630 : }

  00094	e1a00006	 mov         r0, r6
  00098	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$LN17@BCI_SetCha|
  000a0		 |$LN18@BCI_SetCha|
  000a0	3fd4ff04	 DCD         0x3fd4ff04
  000a4		 |$M45155|

			 ENDP  ; |BCI_SetChargeCurrent|

	EXPORT	|BCI_QueryVoltageMonitors|
	IMPORT	|LeaveCriticalSection|
	IMPORT	|EnterCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T45170| DCD	|$LN6@BCI_QueryV|
	DCD	0x40000e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BCI_QueryVoltageMonitors| PROC

; 1641 : {   

  00000		 |$LN6@BCI_QueryV|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45167|
  00004	e1b05000	 movs        r5, r0

; 1642 :     DWORD dwResult = 0;

  00008	e3a04000	 mov         r4, #0

; 1643 :     Device_t *pDevice = (Device_t*)hBCI;
; 1644 :     
; 1645 :     DEBUGMSG(ZONE_FUNCTION, (L"+BCI_QueryVoltageMonitors()\r\n"));
; 1646 : 
; 1647 :     // check for valid parameter
; 1648 :     if (pDevice == NULL) goto cleanUp;

  0000c	0a000006	 beq         |$cleanUp$44326|

; 1649 : 
; 1650 :     EnterCriticalSection(&pDevice->cs);    

  00010	e1a00005	 mov         r0, r5
  00014	eb000000	 bl          EnterCriticalSection

; 1651 :     dwResult = QueryVoltageMonitors(pDevice);    

  00018	e1a00005	 mov         r0, r5
  0001c	eb000000	 bl          QueryVoltageMonitors
  00020	e1a04000	 mov         r4, r0

; 1652 :     LeaveCriticalSection(&pDevice->cs);

  00024	e1a00005	 mov         r0, r5
  00028	eb000000	 bl          LeaveCriticalSection
  0002c		 |$cleanUp$44326|

; 1653 :     
; 1654 : cleanUp:
; 1655 :     DEBUGMSG(ZONE_FUNCTION, (L"-BCI_QueryVoltageMonitors()\r\n"));
; 1656 :     return dwResult;
; 1657 : }

  0002c	e1a00004	 mov         r0, r4
  00030	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00034	e12fff1e	 bx          lr
  00038		 |$M45168|

			 ENDP  ; |BCI_QueryVoltageMonitors|

	EXPORT	|BCI_QueryTemperatureMonitors|

  00000			 AREA	 |.pdata|, PDATA
|$T45189| DCD	|$LN10@BCI_QueryT|
	DCD	0x40002002
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BCI_QueryTemperatureMonitors| PROC

; 1669 : {

  00000		 |$LN10@BCI_QueryT|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M45186|
  00008	e1b05000	 movs        r5, r0

; 1670 :     DWORD dwResult = 0;

  0000c	e3a04000	 mov         r4, #0

; 1671 :     Device_t *pDevice = (Device_t*)hBCI;
; 1672 :     DEBUGMSG(ZONE_FUNCTION, (L"+BCI_QueryTemperatureMonitors(pDevice=0x%08X)\r\n",
; 1673 :         pDevice
; 1674 :         ));
; 1675 : 
; 1676 :     // check for valid parameter
; 1677 :     if (pDevice == NULL) goto cleanUp;

  00010	0a000016	 beq         |$cleanUp$44337|

; 1678 : 
; 1679 :     EnterCriticalSection(&pDevice->cs);    

  00014	e1a00005	 mov         r0, r5
  00018	eb000000	 bl          EnterCriticalSection

; 1680 :     dwResult = QueryTemperatureMonitors(pDevice);    

  0001c	e5950018	 ldr         r0, [r5, #0x18]
  00020	e3a06802	 mov         r6, #2, 16
  00024	e3a0e073	 mov         lr, #0x73
  00028	e3861085	 orr         r1, r6, #0x85
  0002c	e3a03001	 mov         r3, #1
  00030	e28d2000	 add         r2, sp, #0
  00034	e5cde000	 strb        lr, [sp]
  00038	e3a04000	 mov         r4, #0
  0003c	eb000000	 bl          TWLWriteRegs
  00040	e5950018	 ldr         r0, [r5, #0x18]
  00044	e3a03001	 mov         r3, #1
  00048	e28d2000	 add         r2, sp, #0
  0004c	e3861087	 orr         r1, r6, #0x87
  00050	eb000000	 bl          TWLReadRegs
  00054	e5dd3000	 ldrb        r3, [sp]

; 1681 :     LeaveCriticalSection(&pDevice->cs);

  00058	e1a00005	 mov         r0, r5
  0005c	e3130008	 tst         r3, #8
  00060	13a04001	 movne       r4, #1
  00064	e3130002	 tst         r3, #2
  00068	13844002	 orrne       r4, r4, #2
  0006c	eb000000	 bl          LeaveCriticalSection
  00070		 |$cleanUp$44337|

; 1682 : 
; 1683 : cleanUp:
; 1684 :     DEBUGMSG(ZONE_FUNCTION, (L"-BCI_QueryTemperatureMonitors()\r\n"));
; 1685 :     return dwResult;
; 1686 : }

  00070	e1a00004	 mov         r0, r4
  00074	e28dd004	 add         sp, sp, #4
  00078	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$M45187|

			 ENDP  ; |BCI_QueryTemperatureMonitors|

	EXPORT	|BCI_QueryCurrentMonitors|

  00000			 AREA	 |.pdata|, PDATA
|$T45209| DCD	|$LN11@BCI_QueryC|
	DCD	0x40002902
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BCI_QueryCurrentMonitors| PROC

; 1698 : {

  00000		 |$LN11@BCI_QueryC|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M45206|
  00008	e1b05000	 movs        r5, r0

; 1699 :     DWORD dwResult = 0;

  0000c	e3a04000	 mov         r4, #0

; 1700 :     Device_t *pDevice = (Device_t*)hBCI;
; 1701 :     DEBUGMSG(ZONE_FUNCTION, (L"+BCI_QueryCurrentMonitors(pDevice=0x%08X)\r\n",
; 1702 :         pDevice
; 1703 :         ));
; 1704 : 
; 1705 :     // check for valid parameter
; 1706 :     if (pDevice == NULL) goto cleanUp;

  00010	0a00001f	 beq         |$cleanUp$44348|

; 1707 : 
; 1708 :     EnterCriticalSection(&pDevice->cs);    

  00014	e1a00005	 mov         r0, r5
  00018	eb000000	 bl          EnterCriticalSection

; 1709 :     dwResult = QueryCurrentMonitors(pDevice);    

  0001c	e5950018	 ldr         r0, [r5, #0x18]
  00020	e3a06802	 mov         r6, #2, 16
  00024	e3a0e09c	 mov         lr, #0x9C
  00028	e3861085	 orr         r1, r6, #0x85
  0002c	e3a03001	 mov         r3, #1
  00030	e28d2000	 add         r2, sp, #0
  00034	e5cde000	 strb        lr, [sp]
  00038	e3a04000	 mov         r4, #0
  0003c	eb000000	 bl          TWLWriteRegs
  00040	e5950018	 ldr         r0, [r5, #0x18]
  00044	e3a03001	 mov         r3, #1
  00048	e28d2000	 add         r2, sp, #0
  0004c	e3861088	 orr         r1, r6, #0x88
  00050	eb000000	 bl          TWLReadRegs
  00054	e5dd3000	 ldrb        r3, [sp]
  00058	e5950018	 ldr         r0, [r5, #0x18]
  0005c	e28d2000	 add         r2, sp, #0
  00060	e3130008	 tst         r3, #8
  00064	13a04001	 movne       r4, #1
  00068	e3130080	 tst         r3, #0x80
  0006c	e3a03802	 mov         r3, #2, 16
  00070	e3831097	 orr         r1, r3, #0x97
  00074	e3a03001	 mov         r3, #1
  00078	13844002	 orrne       r4, r4, #2
  0007c	eb000000	 bl          TWLReadRegs
  00080	e5dd3000	 ldrb        r3, [sp]

; 1710 :     LeaveCriticalSection(&pDevice->cs);

  00084	e1a00005	 mov         r0, r5
  00088	e3130020	 tst         r3, #0x20
  0008c	13844003	 orrne       r4, r4, #3
  00090	eb000000	 bl          LeaveCriticalSection
  00094		 |$cleanUp$44348|

; 1711 : 
; 1712 : cleanUp:
; 1713 :     DEBUGMSG(ZONE_FUNCTION, (L"-BCI_QueryCurrentMonitors()\r\n"));
; 1714 :     return dwResult;
; 1715 : }

  00094	e1a00004	 mov         r0, r4
  00098	e28dd004	 add         sp, sp, #4
  0009c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000a0	e12fff1e	 bx          lr
  000a4		 |$M45207|

			 ENDP  ; |BCI_QueryCurrentMonitors|

	EXPORT	|BCI_SetVoltageMonitors|

  00000			 AREA	 |.pdata|, PDATA
|$T45222| DCD	|$LN6@BCI_SetVol|
	DCD	0x40001201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BCI_SetVoltageMonitors| PROC

; 1729 : {   

  00000		 |$LN6@BCI_SetVol|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M45219|
  00004	e1a06002	 mov         r6, r2
  00008	e1a07001	 mov         r7, r1
  0000c	e1b05000	 movs        r5, r0

; 1730 :     BOOL bSuccess = FALSE;

  00010	e3a04000	 mov         r4, #0

; 1731 :     Device_t *pDevice = (Device_t*)hBCI;;
; 1732 :     
; 1733 :     DEBUGMSG(ZONE_FUNCTION, (L"+BCI_SetVoltageMonitors()\r\n"));
; 1734 : 
; 1735 :     // check for valid parameter
; 1736 :     if (pDevice == NULL) goto cleanUp;

  00014	0a000008	 beq         |$cleanUp$44363|

; 1737 : 
; 1738 :     EnterCriticalSection(&pDevice->cs);    

  00018	e1a00005	 mov         r0, r5
  0001c	eb000000	 bl          EnterCriticalSection

; 1739 :     bSuccess = SetVoltageMonitors(pDevice, ffEnable, ffMask);    

  00020	e1a02006	 mov         r2, r6
  00024	e1a01007	 mov         r1, r7
  00028	e1a00005	 mov         r0, r5
  0002c	eb000000	 bl          SetVoltageMonitors
  00030	e1a04000	 mov         r4, r0

; 1740 :     LeaveCriticalSection(&pDevice->cs);

  00034	e1a00005	 mov         r0, r5
  00038	eb000000	 bl          LeaveCriticalSection
  0003c		 |$cleanUp$44363|

; 1741 :     
; 1742 : cleanUp:
; 1743 :     DEBUGMSG(ZONE_FUNCTION, (L"-BCI_SetVoltageMonitors()\r\n"));
; 1744 :     return bSuccess;
; 1745 : }

  0003c	e1a00004	 mov         r0, r4
  00040	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$M45220|

			 ENDP  ; |BCI_SetVoltageMonitors|

	EXPORT	|BCI_SetChargeMode|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T45245| DCD	|$LN18@BCI_SetCha@2|
	DCD	0x40003002
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\bci\bci.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BCI_SetChargeMode| PROC

; 1759 : {   

  00000		 |$LN18@BCI_SetCha@2|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M45242|
  00008	e1a06002	 mov         r6, r2
  0000c	e1a05001	 mov         r5, r1
  00010	e1b04000	 movs        r4, r0

; 1760 :     UINT8 data;
; 1761 :     BOOL bSuccess = FALSE;
; 1762 :     Device_t *pDevice = (Device_t*)hBCI;;
; 1763 :     
; 1764 :     DEBUGMSG(ZONE_FUNCTION, (L"+BCI_SetChargeMode()\r\n"));
; 1765 : 
; 1766 :     // check for valid parameter
; 1767 :     if (pDevice == NULL) goto cleanUp;

  00014	0a000025	 beq         |$cleanUp$44379|

; 1768 : 
; 1769 :     EnterCriticalSection(&pDevice->cs);

  00018	e1a00004	 mov         r0, r4
  0001c	eb000000	 bl          EnterCriticalSection

; 1770 :     
; 1771 :     // look at requested mode and call correlating function
; 1772 :     switch (mode)

  00020	e3550000	 cmp         r5, #0
  00024	4a00001f	 bmi         |$LN1@BCI_SetCha@2|
  00028	e3550001	 cmp         r5, #1
  0002c	da00001a	 ble         |$LN2@BCI_SetCha@2|
  00030	e3550002	 cmp         r5, #2
  00034	1a00001b	 bne         |$LN1@BCI_SetCha@2|

; 1773 :         {
; 1774 :         case kBCI_USBHost:
; 1775 :             if (bAttached != FALSE)
; 1776 :                 {
; 1777 :                 pDevice->bAttached_USBHost = TRUE;
; 1778 : 
; 1779 :                 // enable resistive divide for usb
; 1780 :                 TWLReadRegs(pDevice->hTwl, TWL_BCICTL1, &data, 1);

  00038	e3a03802	 mov         r3, #2, 16
  0003c	e3835097	 orr         r5, r3, #0x97
  00040	e5940018	 ldr         r0, [r4, #0x18]
  00044	e1a01005	 mov         r1, r5
  00048	e3560000	 cmp         r6, #0
  0004c	e28d2000	 add         r2, sp, #0
  00050	e3a03001	 mov         r3, #1
  00054	0a000005	 beq         |$LN4@BCI_SetCha@2|
  00058	e3a0e001	 mov         lr, #1
  0005c	e584e064	 str         lr, [r4, #0x64]
  00060	eb000000	 bl          TWLReadRegs

; 1781 :                 data |= MESVBUS;

  00064	e5dd3000	 ldrb        r3, [sp]

; 1782 :                 TWLWriteRegs(pDevice->hTwl, TWL_BCICTL1, &data, 1);

  00068	e3833004	 orr         r3, r3, #4

; 1783 :                 }
; 1784 :             else

  0006c	ea000004	 b           |$LN15@BCI_SetCha@2|
  00070		 |$LN4@BCI_SetCha@2|

; 1785 :                 {
; 1786 :                 pDevice->bAttached_USBHost = FALSE;
; 1787 :                 
; 1788 :                 // disable resistive divide for usb
; 1789 :                 TWLReadRegs(pDevice->hTwl, TWL_BCICTL1, &data, 1);

  00070	e3a0e000	 mov         lr, #0
  00074	e584e064	 str         lr, [r4, #0x64]
  00078	eb000000	 bl          TWLReadRegs

; 1790 :                 data &= ~MESVBUS;

  0007c	e5dd3000	 ldrb        r3, [sp]

; 1791 :                 TWLWriteRegs(pDevice->hTwl, TWL_BCICTL1, &data, 1);

  00080	e20330fb	 and         r3, r3, #0xFB
  00084		 |$LN15@BCI_SetCha@2|
  00084	e5940018	 ldr         r0, [r4, #0x18]
  00088	e5cd3000	 strb        r3, [sp]
  0008c	e3a03001	 mov         r3, #1
  00090	e28d2000	 add         r2, sp, #0
  00094	e1a01005	 mov         r1, r5
  00098	eb000000	 bl          TWLWriteRegs
  0009c		 |$LN2@BCI_SetCha@2|

; 1792 :                 }
; 1793 :             SetEvent(pDevice->rgIntrEvents[EVENT_POWER]);
; 1794 :             break;
; 1795 :         
; 1796 :         case kBCI_AC:
; 1797 :         case kBCI_Battery:
; 1798 :             // We update based on AC voltage readings
; 1799 :             SetEvent(pDevice->rgIntrEvents[EVENT_POWER]);

  0009c	e5940028	 ldr         r0, [r4, #0x28]
  000a0	e3a01003	 mov         r1, #3
  000a4	eb000000	 bl          EventModify
  000a8		 |$LN1@BCI_SetCha@2|

; 1800 :             break;
; 1801 : 
; 1802 :         default:
; 1803 :             bSuccess = FALSE;
; 1804 :         }
; 1805 : 
; 1806 :     LeaveCriticalSection(&pDevice->cs);

  000a8	e1a00004	 mov         r0, r4
  000ac	eb000000	 bl          LeaveCriticalSection
  000b0		 |$cleanUp$44379|

; 1807 : cleanUp:
; 1808 :     DEBUGMSG(ZONE_FUNCTION, (L"-BCI_SetChargeMode()\r\n"));
; 1809 :     return bSuccess;

  000b0	e3a00000	 mov         r0, #0

; 1810 : }

  000b4	e28dd004	 add         sp, sp, #4
  000b8	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000bc	e12fff1e	 bx          lr
  000c0		 |$M45243|

			 ENDP  ; |BCI_SetChargeMode|

	EXPORT	|BCI_GetChargeMode|

  00000			 AREA	 |.pdata|, PDATA
|$T45256| DCD	|$LN6@BCI_GetCha|
	DCD	0x40000400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BCI_GetChargeMode| PROC

; 1822 : {

  00000		 |$LN6@BCI_GetCha|
  00000		 |$M45253|
  00000	e1b03000	 movs        r3, r0

; 1823 :     Device_t *pDevice;
; 1824 :     BatteryChargeMode_e mode = kBCI_Unknown;

  00004	e3a00005	 mov         r0, #5

; 1825 : 
; 1826 :     DEBUGMSG(ZONE_FUNCTION, (L"+BCI_GetChargeMode(hBCI=0x%08X)\r\n", hBCI));
; 1827 : 
; 1828 :     // check for valid parameter
; 1829 :     if (hBCI != NULL)
; 1830 :         {
; 1831 :         pDevice = (Device_t*)hBCI;
; 1832 :         mode = pDevice->currentMode;

  00008	15930014	 ldrne       r0, [r3, #0x14]

; 1833 :         }
; 1834 :     
; 1835 :     DEBUGMSG(ZONE_FUNCTION, (L"-BCI_GetChargeMode(mode=%d)\r\n", mode));
; 1836 :     return mode;
; 1837 : }

  0000c	e12fff1e	 bx          lr
  00010		 |$M45254|

			 ENDP  ; |BCI_GetChargeMode|

	EXPORT	|BCI_GetVoltageThreshold|

  00000			 AREA	 |.pdata|, PDATA
|$T45280| DCD	|$LN14@BCI_GetVol|
	DCD	0x40002c02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BCI_GetVoltageThreshold| PROC

; 1850 : {   

  00000		 |$LN14@BCI_GetVol|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M45277|
  00008	e1a05001	 mov         r5, r1
  0000c	e1b06000	 movs        r6, r0

; 1851 :     UINT dwResult = FALSE;

  00010	e3a04000	 mov         r4, #0

; 1852 :     Device_t *pDevice = (Device_t*)hBCI;
; 1853 :     
; 1854 :     DEBUGMSG(ZONE_FUNCTION, (L"+BCI_GetVoltageThreshold()\r\n"));
; 1855 : 
; 1856 :     // check for valid parameter
; 1857 :     if (pDevice == NULL) goto cleanUp;

  00014	0a000021	 beq         |$cleanUp$44411|

; 1858 : 
; 1859 :     EnterCriticalSection(&pDevice->cs);    

  00018	e1a00006	 mov         r0, r6
  0001c	eb000000	 bl          EnterCriticalSection

; 1860 :     dwResult = GetVoltageThreshold(pDevice, ffMask);    

  00020	e5960018	 ldr         r0, [r6, #0x18]
  00024	e3a04802	 mov         r4, #2, 16
  00028	e3a0e06d	 mov         lr, #0x6D
  0002c	e3841085	 orr         r1, r4, #0x85
  00030	e3a03001	 mov         r3, #1
  00034	e28d2000	 add         r2, sp, #0
  00038	e5cde000	 strb        lr, [sp]
  0003c	eb000000	 bl          TWLWriteRegs
  00040	e5960018	 ldr         r0, [r6, #0x18]
  00044	e3a03001	 mov         r3, #1
  00048	e28d2000	 add         r2, sp, #0
  0004c	e384108c	 orr         r1, r4, #0x8C
  00050	eb000000	 bl          TWLReadRegs
  00054	e3550001	 cmp         r5, #1
  00058	0a00000b	 beq         |$LN4@BCI_GetVol|
  0005c	e3550002	 cmp         r5, #2
  00060	0a000006	 beq         |$LN5@BCI_GetVol|
  00064	e3550004	 cmp         r5, #4
  00068	05dd3000	 ldreqb      r3, [sp]
  0006c	0203300c	 andeq       r3, r3, #0xC
  00070	01a04123	 moveq       r4, r3, lsr #2
  00074	0a000007	 beq         |$LN7@BCI_GetVol|
  00078	e5dd4000	 ldrb        r4, [sp]
  0007c	ea000005	 b           |$LN7@BCI_GetVol|
  00080		 |$LN5@BCI_GetVol|
  00080	e5dd3000	 ldrb        r3, [sp]
  00084	e2034003	 and         r4, r3, #3
  00088	ea000002	 b           |$LN7@BCI_GetVol|
  0008c		 |$LN4@BCI_GetVol|
  0008c	e5dd3000	 ldrb        r3, [sp]
  00090	e2033030	 and         r3, r3, #0x30
  00094	e1a04223	 mov         r4, r3, lsr #4
  00098		 |$LN7@BCI_GetVol|

; 1861 :     LeaveCriticalSection(&pDevice->cs);

  00098	e1a00006	 mov         r0, r6
  0009c	eb000000	 bl          LeaveCriticalSection
  000a0		 |$cleanUp$44411|

; 1862 :     
; 1863 : cleanUp:
; 1864 :     DEBUGMSG(ZONE_FUNCTION, (L"-BCI_GetVoltageThreshold()\r\n"));
; 1865 :     return dwResult;
; 1866 : }

  000a0	e1a00004	 mov         r0, r4
  000a4	e28dd004	 add         sp, sp, #4
  000a8	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000ac	e12fff1e	 bx          lr
  000b0		 |$M45278|

			 ENDP  ; |BCI_GetVoltageThreshold|

	EXPORT	|BCI_SetVoltageThreshold|

  00000			 AREA	 |.pdata|, PDATA
|$T45293| DCD	|$LN6@BCI_SetVol@2|
	DCD	0x40001201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BCI_SetVoltageThreshold| PROC

; 1880 : {

  00000		 |$LN6@BCI_SetVol@2|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M45290|
  00004	e1a06002	 mov         r6, r2
  00008	e1a07001	 mov         r7, r1
  0000c	e1b05000	 movs        r5, r0

; 1881 :     BOOL bSuccess = FALSE;

  00010	e3a04000	 mov         r4, #0

; 1882 :     Device_t *pDevice = (Device_t*)hBCI;
; 1883 :     DEBUGMSG(ZONE_FUNCTION, (L"+BCI_SetVoltageThreshold("
; 1884 :         L"hBCI=0x%08X, ffMask=%d, threshold=%d)\r\n",
; 1885 :         pDevice, ffMask, threshold
; 1886 :         ));
; 1887 : 
; 1888 :     // check for valid parameter
; 1889 :     if (pDevice == NULL) goto cleanUp;

  00014	0a000008	 beq         |$cleanUp$44426|

; 1890 : 
; 1891 :     EnterCriticalSection(&pDevice->cs);    

  00018	e1a00005	 mov         r0, r5
  0001c	eb000000	 bl          EnterCriticalSection

; 1892 :     bSuccess = SetVoltageThreshold(pDevice, ffMask, threshold);    

  00020	e1a02006	 mov         r2, r6
  00024	e1a01007	 mov         r1, r7
  00028	e1a00005	 mov         r0, r5
  0002c	eb000000	 bl          SetVoltageThreshold
  00030	e1a04000	 mov         r4, r0

; 1893 :     LeaveCriticalSection(&pDevice->cs);

  00034	e1a00005	 mov         r0, r5
  00038	eb000000	 bl          LeaveCriticalSection
  0003c		 |$cleanUp$44426|

; 1894 :     
; 1895 : cleanUp:
; 1896 :     DEBUGMSG(ZONE_FUNCTION, (L"-BCI_SetVoltageThreshold()\r\n"));
; 1897 :     return bSuccess;
; 1898 : }

  0003c	e1a00004	 mov         r0, r4
  00040	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$M45291|

			 ENDP  ; |BCI_SetVoltageThreshold|

	EXPORT	|BCI_GetTemperatureThreshold|

  00000			 AREA	 |.pdata|, PDATA
|$T45307| DCD	|$LN6@BCI_GetTem|
	DCD	0x40001401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BCI_GetTemperatureThreshold| PROC

; 1913 : {

  00000		 |$LN6@BCI_GetTem|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M45304|
  00004	e1a06003	 mov         r6, r3
  00008	e1a07002	 mov         r7, r2
  0000c	e1a08001	 mov         r8, r1
  00010	e1b05000	 movs        r5, r0

; 1914 :     BOOL bSuccess = FALSE;

  00014	e3a04000	 mov         r4, #0

; 1915 :     Device_t *pDevice = (Device_t*)hBCI;
; 1916 :     DEBUGMSG(ZONE_FUNCTION, (L"+BCI_GetTemperatureThreshold("
; 1917 :         L"pDevice=0x%08X, ffMask=%d)\r\n",
; 1918 :         pDevice, ffMask
; 1919 :         ));
; 1920 : 
; 1921 :     // check for valid parameter
; 1922 :     if (pDevice == NULL) goto cleanUp;

  00018	0a000009	 beq         |$cleanUp$44443|

; 1923 : 
; 1924 :     EnterCriticalSection(&pDevice->cs);    

  0001c	e1a00005	 mov         r0, r5
  00020	eb000000	 bl          EnterCriticalSection

; 1925 :     bSuccess = GetTemperatureThreshold(pDevice, ffMask, 
; 1926 :                    pThresholdHigh, pThresholdLow
; 1927 :                    );

  00024	e1a03006	 mov         r3, r6
  00028	e1a02007	 mov         r2, r7
  0002c	e1a01008	 mov         r1, r8
  00030	e1a00005	 mov         r0, r5
  00034	eb000000	 bl          GetTemperatureThreshold
  00038	e1a04000	 mov         r4, r0

; 1928 :     LeaveCriticalSection(&pDevice->cs);

  0003c	e1a00005	 mov         r0, r5
  00040	eb000000	 bl          LeaveCriticalSection
  00044		 |$cleanUp$44443|

; 1929 : 
; 1930 : cleanUp:
; 1931 :     DEBUGMSG(ZONE_FUNCTION, (L"-BCI_GetTemperatureThreshold()\r\n"));
; 1932 :     return bSuccess;    
; 1933 : }

  00044	e1a00004	 mov         r0, r4
  00048	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M45305|

			 ENDP  ; |BCI_GetTemperatureThreshold|

	EXPORT	|BCI_SetTemperatureThreshold|

  00000			 AREA	 |.pdata|, PDATA
|$T45321| DCD	|$LN6@BCI_SetTem|
	DCD	0x40001401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BCI_SetTemperatureThreshold| PROC

; 1949 : {

  00000		 |$LN6@BCI_SetTem|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M45318|
  00004	e1a06003	 mov         r6, r3
  00008	e1a07002	 mov         r7, r2
  0000c	e1a08001	 mov         r8, r1
  00010	e1b05000	 movs        r5, r0

; 1950 :     BOOL bSuccess = FALSE;

  00014	e3a04000	 mov         r4, #0

; 1951 :     Device_t *pDevice = (Device_t*)hBCI;
; 1952 :     DEBUGMSG(ZONE_FUNCTION, (L"+BCI_SetTemperatureThreshold("
; 1953 :         L"hBCI=0x%08X, ffMask=%d, thresholdHigh=%d, thresholdLow=%d)\r\n",
; 1954 :         hBCI, ffMask, thresholdHigh, thresholdLow
; 1955 :         ));
; 1956 : 
; 1957 :     // check for valid parameter
; 1958 :     if (pDevice == NULL) goto cleanUp;

  00018	0a000009	 beq         |$cleanUp$44460|

; 1959 : 
; 1960 :     EnterCriticalSection(&pDevice->cs);    

  0001c	e1a00005	 mov         r0, r5
  00020	eb000000	 bl          EnterCriticalSection

; 1961 :     bSuccess = SetTemperatureThreshold(pDevice, ffMask, 
; 1962 :                    thresholdHigh, thresholdLow
; 1963 :                    );

  00024	e1a03006	 mov         r3, r6
  00028	e1a02007	 mov         r2, r7
  0002c	e1a01008	 mov         r1, r8
  00030	e1a00005	 mov         r0, r5
  00034	eb000000	 bl          SetTemperatureThreshold
  00038	e1a04000	 mov         r4, r0

; 1964 :     LeaveCriticalSection(&pDevice->cs);

  0003c	e1a00005	 mov         r0, r5
  00040	eb000000	 bl          LeaveCriticalSection
  00044		 |$cleanUp$44460|

; 1965 : 
; 1966 : cleanUp:
; 1967 :     DEBUGMSG(ZONE_FUNCTION, (L"-BCI_SetTemperatureThreshold()\r\n"));
; 1968 :     return bSuccess;  
; 1969 : 
; 1970 : }

  00044	e1a00004	 mov         r0, r4
  00048	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M45319|

			 ENDP  ; |BCI_SetTemperatureThreshold|

	EXPORT	|BCI_SetTemperatureMonitors|

  00000			 AREA	 |.pdata|, PDATA
|$T45351| DCD	|$LN15@BCI_SetTem@2|
	DCD	0x40003002
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BCI_SetTemperatureMonitors| PROC

; 1984 : {

  00000		 |$LN15@BCI_SetTem@2|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M45348|
  00008	e1a07002	 mov         r7, r2
  0000c	e1a05001	 mov         r5, r1
  00010	e1b06000	 movs        r6, r0

; 1985 :     BOOL bSuccess = FALSE;

  00014	e3a04000	 mov         r4, #0

; 1986 :     Device_t *pDevice = (Device_t*)hBCI;
; 1987 :     DEBUGMSG(ZONE_FUNCTION, (L"+BCI_SetTemperatureMonitors("
; 1988 :         L"hBCI=0x%08X, ffEnable=%d, ffMask=%d)\r\n",
; 1989 :         hBCI, ffEnable, ffMask
; 1990 :         ));
; 1991 : 
; 1992 :     // check for valid parameter
; 1993 :     if (pDevice == NULL) goto cleanUp;

  00018	0a000024	 beq         |$cleanUp$44475|

; 1994 : 
; 1995 :     EnterCriticalSection(&pDevice->cs);    

  0001c	e1a00006	 mov         r0, r6
  00020	eb000000	 bl          EnterCriticalSection

; 1996 :     bSuccess = SetTemperatureMonitors(pDevice, ffEnable, ffMask);

  00024	e5960018	 ldr         r0, [r6, #0x18]
  00028	e3a04802	 mov         r4, #2, 16
  0002c	e3a0e073	 mov         lr, #0x73
  00030	e3841085	 orr         r1, r4, #0x85
  00034	e3a03001	 mov         r3, #1
  00038	e28d2000	 add         r2, sp, #0
  0003c	e5cde000	 strb        lr, [sp]
  00040	eb000000	 bl          TWLWriteRegs
  00044	e5960018	 ldr         r0, [r6, #0x18]
  00048	e3a03001	 mov         r3, #1
  0004c	e28d2000	 add         r2, sp, #0
  00050	e3841087	 orr         r1, r4, #0x87
  00054	eb000000	 bl          TWLReadRegs
  00058	e5dd3000	 ldrb        r3, [sp]
  0005c	e3170001	 tst         r7, #1
  00060	0a000004	 beq         |$LN5@BCI_SetTem@2|
  00064	e3150001	 tst         r5, #1
  00068	13833008	 orrne       r3, r3, #8
  0006c	03c33008	 biceq       r3, r3, #8
  00070	e20330ff	 and         r3, r3, #0xFF
  00074	e5cd3000	 strb        r3, [sp]
  00078		 |$LN5@BCI_SetTem@2|
  00078	e3170002	 tst         r7, #2
  0007c	0a000003	 beq         |$LN4@BCI_SetTem@2|
  00080	e3150002	 tst         r5, #2
  00084	13833002	 orrne       r3, r3, #2
  00088	03c33002	 biceq       r3, r3, #2
  0008c	e5cd3000	 strb        r3, [sp]
  00090		 |$LN4@BCI_SetTem@2|
  00090	e5960018	 ldr         r0, [r6, #0x18]
  00094	e3a03001	 mov         r3, #1
  00098	e28d2000	 add         r2, sp, #0
  0009c	e3841087	 orr         r1, r4, #0x87
  000a0	eb000000	 bl          TWLWriteRegs

; 1997 :     LeaveCriticalSection(&pDevice->cs);

  000a4	e1a00006	 mov         r0, r6
  000a8	e3a04001	 mov         r4, #1
  000ac	eb000000	 bl          LeaveCriticalSection
  000b0		 |$cleanUp$44475|

; 1998 : 
; 1999 : cleanUp:            
; 2000 :     DEBUGMSG(ZONE_FUNCTION, (L"-BCI_SetTemperatureMonitors()\r\n"));
; 2001 :     return bSuccess;
; 2002 : }

  000b0	e1a00004	 mov         r0, r4
  000b4	e28dd004	 add         sp, sp, #4
  000b8	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000bc	e12fff1e	 bx          lr
  000c0		 |$M45349|

			 ENDP  ; |BCI_SetTemperatureMonitors|

	EXPORT	|BCI_GetCurrentThreshold|

  00000			 AREA	 |.pdata|, PDATA
|$T45363| DCD	|$LN6@BCI_GetCur|
	DCD	0x40001001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BCI_GetCurrentThreshold| PROC

; 2015 : {

  00000		 |$LN6@BCI_GetCur|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45360|
  00004	e1a06001	 mov         r6, r1
  00008	e1b05000	 movs        r5, r0

; 2016 :     UINT8 Result = 0;

  0000c	e3a04000	 mov         r4, #0

; 2017 :     Device_t *pDevice = (Device_t*)hBCI;
; 2018 :     DEBUGMSG(ZONE_FUNCTION, (L"+BCI_GetCurrentThreshold("
; 2019 :         L"pDevice=0x%08X, ffMask=%d)\r\n",
; 2020 :         pDevice, ffMasks
; 2021 :         ));
; 2022 : 
; 2023 :     // check for valid parameter
; 2024 :     if (pDevice == NULL) goto cleanUp;

  00010	0a000007	 beq         |$cleanUp$44488|

; 2025 : 
; 2026 :     EnterCriticalSection(&pDevice->cs);    

  00014	e1a00005	 mov         r0, r5
  00018	eb000000	 bl          EnterCriticalSection

; 2027 :     Result = GetCurrentThreshold(pDevice, ffMasks);

  0001c	e1a01006	 mov         r1, r6
  00020	e1a00005	 mov         r0, r5
  00024	eb000000	 bl          GetCurrentThreshold
  00028	e1a04000	 mov         r4, r0

; 2028 :     LeaveCriticalSection(&pDevice->cs);

  0002c	e1a00005	 mov         r0, r5
  00030	eb000000	 bl          LeaveCriticalSection
  00034		 |$cleanUp$44488|

; 2029 : 
; 2030 : cleanUp:
; 2031 :     DEBUGMSG(ZONE_FUNCTION, (L"-BCI_GetCurrentThreshold()\r\n"));
; 2032 :     return Result;    
; 2033 : }

  00034	e1a00004	 mov         r0, r4
  00038	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$M45361|

			 ENDP  ; |BCI_GetCurrentThreshold|

	EXPORT	|BCI_SetCurrentThreshold|

  00000			 AREA	 |.pdata|, PDATA
|$T45376| DCD	|$LN6@BCI_SetCur|
	DCD	0x40001201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BCI_SetCurrentThreshold| PROC

; 2048 : {

  00000		 |$LN6@BCI_SetCur|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M45373|
  00004	e1a06002	 mov         r6, r2
  00008	e1a07001	 mov         r7, r1
  0000c	e1b05000	 movs        r5, r0

; 2049 :     BOOL bSuccess = FALSE;

  00010	e3a04000	 mov         r4, #0

; 2050 :     Device_t *pDevice = (Device_t*)hBCI;
; 2051 :     DEBUGMSG(ZONE_FUNCTION, (L"+BCI_SetCurrentThreshold("
; 2052 :         L"hBCI=0x%08X, ffMask=%d, threshold=%d)\r\n",
; 2053 :         hBCI, ffMask, threshold
; 2054 :         ));
; 2055 : 
; 2056 :     // check for valid parameter
; 2057 :     if (pDevice == NULL) goto cleanUp;

  00014	0a000008	 beq         |$cleanUp$44503|

; 2058 : 
; 2059 :     EnterCriticalSection(&pDevice->cs);    

  00018	e1a00005	 mov         r0, r5
  0001c	eb000000	 bl          EnterCriticalSection

; 2060 :     bSuccess = SetCurrentThreshold(pDevice, ffMask, threshold);

  00020	e1a02006	 mov         r2, r6
  00024	e1a01007	 mov         r1, r7
  00028	e1a00005	 mov         r0, r5
  0002c	eb000000	 bl          SetCurrentThreshold
  00030	e1a04000	 mov         r4, r0

; 2061 :     LeaveCriticalSection(&pDevice->cs);

  00034	e1a00005	 mov         r0, r5
  00038	eb000000	 bl          LeaveCriticalSection
  0003c		 |$cleanUp$44503|

; 2062 : 
; 2063 : cleanUp:
; 2064 :     DEBUGMSG(ZONE_FUNCTION, (L"-BCI_SetCurrentThreshold()\r\n"));
; 2065 :     return bSuccess;  
; 2066 : 
; 2067 : }

  0003c	e1a00004	 mov         r0, r4
  00040	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$M45374|

			 ENDP  ; |BCI_SetCurrentThreshold|

	EXPORT	|BCI_SetCurrentMonitors|

  00000			 AREA	 |.pdata|, PDATA
|$T45407| DCD	|$LN16@BCI_SetCur@2|
	DCD	0x40003202
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BCI_SetCurrentMonitors| PROC

; 2081 : {

  00000		 |$LN16@BCI_SetCur@2|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M45404|
  00008	e1a06002	 mov         r6, r2
  0000c	e1a07001	 mov         r7, r1
  00010	e1b04000	 movs        r4, r0

; 2082 :     BOOL bSuccess = FALSE;

  00014	e3a05000	 mov         r5, #0

; 2083 :     Device_t *pDevice = (Device_t*)hBCI;
; 2084 :     DEBUGMSG(ZONE_FUNCTION, (L"+BCI_SetCurrentMonitors("
; 2085 :         L"hBCI=0x%08X, ffEnable=%d, ffMask=%d)\r\n",
; 2086 :         hBCI, ffEnable, ffMask
; 2087 :         ));
; 2088 : 
; 2089 :     // check for valid parameter
; 2090 :     if (pDevice == NULL) goto cleanUp;

  00018	0a000026	 beq         |$cleanUp$44518|

; 2091 : 
; 2092 :     EnterCriticalSection(&pDevice->cs);    

  0001c	e1a00004	 mov         r0, r4
  00020	eb000000	 bl          EnterCriticalSection

; 2093 :     bSuccess = SetCurrentMonitors(pDevice, ffEnable, ffMask);

  00024	e3160003	 tst         r6, #3
  00028	0a00001f	 beq         |$LN6@BCI_SetCur@2|
  0002c	e5940018	 ldr         r0, [r4, #0x18]
  00030	e3a05802	 mov         r5, #2, 16
  00034	e3a0e09c	 mov         lr, #0x9C
  00038	e3851085	 orr         r1, r5, #0x85
  0003c	e3a03001	 mov         r3, #1
  00040	e28d2000	 add         r2, sp, #0
  00044	e5cde000	 strb        lr, [sp]
  00048	eb000000	 bl          TWLWriteRegs
  0004c	e5940018	 ldr         r0, [r4, #0x18]
  00050	e3a03001	 mov         r3, #1
  00054	e28d2000	 add         r2, sp, #0
  00058	e3851088	 orr         r1, r5, #0x88
  0005c	eb000000	 bl          TWLReadRegs
  00060	e5dd3000	 ldrb        r3, [sp]
  00064	e3160001	 tst         r6, #1
  00068	0a000004	 beq         |$LN5@BCI_SetCur@2|
  0006c	e3170001	 tst         r7, #1
  00070	13833008	 orrne       r3, r3, #8
  00074	03c33008	 biceq       r3, r3, #8
  00078	e20330ff	 and         r3, r3, #0xFF
  0007c	e5cd3000	 strb        r3, [sp]
  00080		 |$LN5@BCI_SetCur@2|
  00080	e3160002	 tst         r6, #2
  00084	0a000003	 beq         |$LN4@BCI_SetCur@2|
  00088	e3170002	 tst         r7, #2
  0008c	13833080	 orrne       r3, r3, #0x80
  00090	03c33080	 biceq       r3, r3, #0x80
  00094	e5cd3000	 strb        r3, [sp]
  00098		 |$LN4@BCI_SetCur@2|
  00098	e5940018	 ldr         r0, [r4, #0x18]
  0009c	e3a03001	 mov         r3, #1
  000a0	e28d2000	 add         r2, sp, #0
  000a4	e3851088	 orr         r1, r5, #0x88
  000a8	eb000000	 bl          TWLWriteRegs
  000ac		 |$LN6@BCI_SetCur@2|

; 2094 :     LeaveCriticalSection(&pDevice->cs);

  000ac	e1a00004	 mov         r0, r4
  000b0	e3a05001	 mov         r5, #1
  000b4	eb000000	 bl          LeaveCriticalSection
  000b8		 |$cleanUp$44518|

; 2095 : 
; 2096 : cleanUp:            
; 2097 :     DEBUGMSG(ZONE_FUNCTION, (L"-BCI_SetCurrentMonitors()\r\n"));
; 2098 :     return bSuccess;
; 2099 : }

  000b8	e1a00005	 mov         r0, r5
  000bc	e28dd004	 add         sp, sp, #4
  000c0	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000c4	e12fff1e	 bx          lr
  000c8		 |$M45405|

			 ENDP  ; |BCI_SetCurrentMonitors|

; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\inc\madc.h

  00000			 AREA	 |.pdata|, PDATA
|$T45431| DCD	|$LN11@IsVACValid|
	DCD	0x40003902
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\bci\bci.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |IsVACValid| PROC

; 2111 : {

  00000		 |$LN11@IsVACValid|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M45428|
  00008	e1a05000	 mov         r5, r0

; 2112 :     UINT8 fMESOrig;
; 2113 :     UINT8 fMESOut;
; 2114 :     DWORD dwResult;
; 2115 :     DWORD dwVAC_mv = 0;
; 2116 :     DWORD dwVACReading;
; 2117 :     BOOL bValid = FALSE;
; 2118 :     DEBUGMSG(ZONE_FUNCTION, (L"+IsVACValid(pDevice=0x%08X)\r\n", pDevice));
; 2119 : 
; 2120 :     // first we need to enable the pre-scaler to get any measurements from madc
; 2121 :     TWLReadRegs(pDevice->hTwl, TWL_BCICTL1, &fMESOrig, 1);

  0000c	e5950018	 ldr         r0, [r5, #0x18]
  00010	e3a08802	 mov         r8, #2, 16
  00014	e3a0e000	 mov         lr, #0
  00018	e3881097	 orr         r1, r8, #0x97
  0001c	e3a03001	 mov         r3, #1
  00020	e28d2004	 add         r2, sp, #4
  00024	e58de008	 str         lr, [sp, #8]
  00028	e3a06000	 mov         r6, #0
  0002c	eb000000	 bl          TWLReadRegs

; 2122 :     fMESOut = fMESOrig | MESVAC;

  00030	e5dd2004	 ldrb        r2, [sp, #4]

; 2123 :     TWLWriteRegs(pDevice->hTwl, TWL_BCICTL1, &fMESOut, 1);

  00034	e5950018	 ldr         r0, [r5, #0x18]
  00038	e3a03001	 mov         r3, #1
  0003c	e3822001	 orr         r2, r2, #1
  00040	e5cd2005	 strb        r2, [sp, #5]
  00044	e28d2005	 add         r2, sp, #5
  00048	e3881097	 orr         r1, r8, #0x97
  0004c	eb000000	 bl          TWLWriteRegs

; 2124 : 
; 2125 :     // check if AC is connected
; 2126 :     dwResult = MADCReadValue(pDevice->hMadc, VAC_CHANNEL, &dwVACReading, 1);

  00050	e595101c	 ldr         r1, [r5, #0x1C]
  00054	e3a03001	 mov         r3, #1
  00058	e28d200c	 add         r2, sp, #0xC
  0005c	e5910000	 ldr         r0, [r1]

; 2127 :     if (dwResult != 0)

  00060	e5914004	 ldr         r4, [r1, #4]
  00064	e3a01b02	 mov         r1, #2, 22
  00068	e1a0e00f	 mov         lr, pc
  0006c	e12fff14	 bx          r4
  00070	e3500000	 cmp         r0, #0
  00074	0a000011	 beq         |$LN1@IsVACValid|

; 2128 :         {
; 2129 :         // convert results to voltage
; 2130 :         MADCConvertToVolts(pDevice->hMadc, VAC_CHANNEL,
; 2131 :             &dwVACReading, &dwVAC_mv, 1);

  00078	e595201c	 ldr         r2, [r5, #0x1C]
  0007c	e3a07001	 mov         r7, #1
  00080	e28d3008	 add         r3, sp, #8
  00084	e5920000	 ldr         r0, [r2]
  00088	e5924008	 ldr         r4, [r2, #8]
  0008c	e28d200c	 add         r2, sp, #0xC
  00090	e3a01b02	 mov         r1, #2, 22
  00094	e58d7000	 str         r7, [sp]
  00098	e1a0e00f	 mov         lr, pc
  0009c	e12fff14	 bx          r4

; 2132 :         
; 2133 :         // is the result above the ac threshold?
; 2134 :         if (ACMINVOLT <= dwVAC_mv && dwVAC_mv < pDevice->dwACCHGOVTH) 

  000a0	e59d2008	 ldr         r2, [sp, #8]
  000a4	e3a03b03	 mov         r3, #3, 22
  000a8	e38330e4	 orr         r3, r3, #0xE4
  000ac	e1520003	 cmp         r2, r3
  000b0	3a000002	 bcc         |$LN1@IsVACValid|
  000b4	e5953044	 ldr         r3, [r5, #0x44]
  000b8	e1520003	 cmp         r2, r3

; 2135 :             {
; 2136 :             bValid = TRUE;

  000bc	33a06001	 movcc       r6, #1
  000c0		 |$LN1@IsVACValid|

; 2137 :             }
; 2138 :         }
; 2139 : 
; 2140 :     TWLWriteRegs(pDevice->hTwl, TWL_BCICTL1, &fMESOrig, 1);

  000c0	e5950018	 ldr         r0, [r5, #0x18]
  000c4	e3a03001	 mov         r3, #1
  000c8	e28d2004	 add         r2, sp, #4
  000cc	e3881097	 orr         r1, r8, #0x97
  000d0	eb000000	 bl          TWLWriteRegs

; 2141 :            
; 2142 :     DEBUGMSG(ZONE_FUNCTION, (L"-IsVACValid()=%d\r\n", bValid));
; 2143 :     return bValid;
; 2144 : }

  000d4	e1a00006	 mov         r0, r6
  000d8	e28dd010	 add         sp, sp, #0x10
  000dc	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000e0	e12fff1e	 bx          lr
  000e4		 |$M45429|

			 ENDP  ; |IsVACValid|

; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\inc\madc.h

  00000			 AREA	 |.pdata|, PDATA
|$T45455| DCD	|$LN12@IsVBUSVali|
	DCD	0x40003c02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\bci\bci.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |IsVBUSValid| PROC

; 2156 : {

  00000		 |$LN12@IsVBUSVali|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M45452|
  00008	e1a05000	 mov         r5, r0

; 2157 :     UINT8 fMESOrig;
; 2158 :     UINT8 fMESOut;
; 2159 :     DWORD dwResult;
; 2160 :     DWORD dwVBUS_mv = 0;
; 2161 :     DWORD dwVBUSReading;
; 2162 :     BOOL bValid = FALSE;
; 2163 :     DEBUGMSG(ZONE_FUNCTION, (L"+IsVBUSValid(pDevice=0x%08X)\r\n", pDevice));
; 2164 : 
; 2165 :     // check if notified of a USB connection
; 2166 :     if (pDevice->bAttached_USBHost != FALSE)

  0000c	e5953064	 ldr         r3, [r5, #0x64]
  00010	e3a02000	 mov         r2, #0
  00014	e58d2008	 str         r2, [sp, #8]
  00018	e3530000	 cmp         r3, #0
  0001c	e3a06000	 mov         r6, #0
  00020	0a00002e	 beq         |$LN3@IsVBUSVali|

; 2167 :         {
; 2168 :         // first we need to enable the pre-scaler to get any measurements from madc
; 2169 :         TWLReadRegs(pDevice->hTwl, TWL_BCICTL1, &fMESOrig, 1);

  00024	e5950018	 ldr         r0, [r5, #0x18]
  00028	e3a08802	 mov         r8, #2, 16
  0002c	e3881097	 orr         r1, r8, #0x97
  00030	e3a03001	 mov         r3, #1
  00034	e28d2004	 add         r2, sp, #4
  00038	eb000000	 bl          TWLReadRegs

; 2170 :         fMESOut = fMESOrig | MESVBUS;

  0003c	e5dd2004	 ldrb        r2, [sp, #4]

; 2171 :         TWLWriteRegs(pDevice->hTwl, TWL_BCICTL1, &fMESOut, 1);

  00040	e5950018	 ldr         r0, [r5, #0x18]
  00044	e3a03001	 mov         r3, #1
  00048	e3822004	 orr         r2, r2, #4
  0004c	e5cd2005	 strb        r2, [sp, #5]
  00050	e28d2005	 add         r2, sp, #5
  00054	e3881097	 orr         r1, r8, #0x97
  00058	eb000000	 bl          TWLWriteRegs

; 2172 :         
; 2173 :         // check if vbus is connected
; 2174 :         dwResult = MADCReadValue(pDevice->hMadc, VBUS_CHANNEL, &dwVBUSReading, 1);

  0005c	e595101c	 ldr         r1, [r5, #0x1C]
  00060	e3a03001	 mov         r3, #1
  00064	e28d200c	 add         r2, sp, #0xC
  00068	e5910000	 ldr         r0, [r1]

; 2175 :         if (dwResult != 0)

  0006c	e5914004	 ldr         r4, [r1, #4]
  00070	e3a01c01	 mov         r1, #1, 24
  00074	e1a0e00f	 mov         lr, pc
  00078	e12fff14	 bx          r4
  0007c	e3500000	 cmp         r0, #0
  00080	0a000011	 beq         |$LN1@IsVBUSVali|

; 2176 :             {
; 2177 :             // convert results to voltage
; 2178 :             MADCConvertToVolts(pDevice->hMadc, VBUS_CHANNEL,
; 2179 :                 &dwVBUSReading, &dwVBUS_mv, 1);

  00084	e595201c	 ldr         r2, [r5, #0x1C]
  00088	e3a07001	 mov         r7, #1
  0008c	e28d3008	 add         r3, sp, #8
  00090	e5920000	 ldr         r0, [r2]
  00094	e5924008	 ldr         r4, [r2, #8]
  00098	e28d200c	 add         r2, sp, #0xC
  0009c	e3a01c01	 mov         r1, #1, 24
  000a0	e58d7000	 str         r7, [sp]
  000a4	e1a0e00f	 mov         lr, pc
  000a8	e12fff14	 bx          r4

; 2180 :             
; 2181 :             // is the result above the ac threshold?
; 2182 :             if (VBUSMINVOLT <= dwVBUS_mv && dwVBUS_mv < pDevice->dwVBUSOVTH) 

  000ac	e59d2008	 ldr         r2, [sp, #8]
  000b0	e3a03c0b	 mov         r3, #0xB, 24
  000b4	e38330b8	 orr         r3, r3, #0xB8
  000b8	e1520003	 cmp         r2, r3
  000bc	3a000002	 bcc         |$LN1@IsVBUSVali|
  000c0	e595304c	 ldr         r3, [r5, #0x4C]
  000c4	e1520003	 cmp         r2, r3

; 2183 :                 {
; 2184 :                 bValid = TRUE;

  000c8	33a06001	 movcc       r6, #1
  000cc		 |$LN1@IsVBUSVali|

; 2185 :                 }
; 2186 :             }
; 2187 : 
; 2188 :         TWLWriteRegs(pDevice->hTwl, TWL_BCICTL1, &fMESOrig, 1);

  000cc	e5950018	 ldr         r0, [r5, #0x18]
  000d0	e3a03001	 mov         r3, #1
  000d4	e28d2004	 add         r2, sp, #4
  000d8	e3881097	 orr         r1, r8, #0x97
  000dc	eb000000	 bl          TWLWriteRegs
  000e0		 |$LN3@IsVBUSVali|

; 2189 :         }
; 2190 :       
; 2191 :     DEBUGMSG(ZONE_FUNCTION, (L"-IsVBUSValid()=%d\r\n", bValid));
; 2192 :     return bValid;
; 2193 : }

  000e0	e1a00006	 mov         r0, r6
  000e4	e28dd010	 add         sp, sp, #0x10
  000e8	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000ec	e12fff1e	 bx          lr
  000f0		 |$M45453|

			 ENDP  ; |IsVBUSValid|

	EXPORT	|??_C@_1FG@NHKAOOAG@?$AAB?$AAC?$AAI?$AA?3?$AA?5?$AAR?$AAe?$AAc?$AAe?$AAi?$AAv?$AAe?$AA?5?$AAH?$AAo?$AAt?$AA?9?$AAD?$AAi?$AAe?$AA?5?$AAw?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAn?$AAt@| [ DATA ] ; `string'
	IMPORT	|NKDbgPrintfW|
	IMPORT	|WaitForMultipleObjects|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T45486| DCD	|$LN48@IntrThread|
	DCD	0x40008b02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FG@NHKAOOAG@?$AAB?$AAC?$AAI?$AA?3?$AA?5?$AAR?$AAe?$AAc?$AAe?$AAi?$AAv?$AAe?$AA?5?$AAH?$AAo?$AAt?$AA?9?$AAD?$AAi?$AAe?$AA?5?$AAw?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAn?$AAt@| DCB "B"
	DCB	0x0, "C", 0x0, "I", 0x0, ":", 0x0, " ", 0x0, "R", 0x0, "e"
	DCB	0x0, "c", 0x0, "e", 0x0, "i", 0x0, "v", 0x0, "e", 0x0, " "
	DCB	0x0, "H", 0x0, "o", 0x0, "t", 0x0, "-", 0x0, "D", 0x0, "i"
	DCB	0x0, "e", 0x0, " ", 0x0, "w", 0x0, "a", 0x0, "r", 0x0, "n"
	DCB	0x0, "i", 0x0, "n", 0x0, "g", 0x0, " ", 0x0, "i", 0x0, "n"
	DCB	0x0, "t", 0x0, "e", 0x0, "r", 0x0, "r", 0x0, "u", 0x0, "p"
	DCB	0x0, "t", 0x0, " ", 0x0, "!", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\bci\bci.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |IntrThread| PROC

; 2205 : {

  00000		 |$LN48@IntrThread|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M45483|
  00008	e1a04000	 mov         r4, r0

; 2206 :     Device_t   *pDevice = (Device_t*)pContext;
; 2207 :     DWORD       timeout = INFINITE;
; 2208 :     UINT8       status;
; 2209 :     DWORD       dwEventId;
; 2210 :     
; 2211 :     BatteryChargeMode_e prevMode = kBCI_Unknown;
; 2212 : 
; 2213 : 
; 2214 :     // Loop until we are not stopped...
; 2215 :     while (!pDevice->threadsExit)

  0000c	e594303c	 ldr         r3, [r4, #0x3C]
  00010	e3e05000	 mvn         r5, #0
  00014	e3a06005	 mov         r6, #5
  00018	e3530000	 cmp         r3, #0
  0001c	1a00007c	 bne         |$LN41@IntrThread|
  00020	e3a03c01	 mov         r3, #1, 24
  00024	e59f81fc	 ldr         r8, [pc, #0x1FC]
  00028	e3837002	 orr         r7, r3, #2
  0002c	e3a09004	 mov         r9, #4
  00030	e3a0a003	 mov         r10, #3
  00034	e3a0b001	 mov         r11, #1
  00038		 |$LL29@IntrThread|

; 2216 :         {
; 2217 :         // Typically event handles associated with interrupts aren't allowed
; 2218 :         // to use WaitForMultipleObjects but since the interrupts are
; 2219 :         // actually signalled by the triton driver this will work.
; 2220 :         
; 2221 :         dwEventId = WaitForMultipleObjects(3, pDevice->rgIntrEvents, 
; 2222 :                         FALSE, timeout
; 2223 :                         );

  00038	e1a03005	 mov         r3, r5
  0003c	e3a02000	 mov         r2, #0
  00040	e2841028	 add         r1, r4, #0x28
  00044	e3a00003	 mov         r0, #3
  00048	eb000000	 bl          WaitForMultipleObjects

; 2224 :         if (pDevice->threadsExit) break;

  0004c	e594303c	 ldr         r3, [r4, #0x3C]
  00050	e3530000	 cmp         r3, #0
  00054	1a00006e	 bne         |$LN41@IntrThread|

; 2225 : 
; 2226 :         switch (dwEventId)

  00058	e3500000	 cmp         r0, #0
  0005c	0a00005b	 beq         |$LN24@IntrThread|
  00060	e3500001	 cmp         r0, #1
  00064	0a000004	 beq         |$LN21@IntrThread|
  00068	e3500002	 cmp         r0, #2
  0006c	0a000015	 beq         |$LN20@IntrThread|
  00070	e1500007	 cmp         r0, r7
  00074	1a000063	 bne         |$LN23@IntrThread|

; 2234 :                     }
; 2235 :                 DEBUGMSG(ZONE_PDD, (L"BCI: interrupt: status=0x%02X\r\n", status));
; 2236 :                 continue;
; 2237 : 
; 2238 :             case WAIT_TIMEOUT:
; 2239 :                 DEBUGMSG(ZONE_PDD, (L"BCI: timeout: %d ms\r\n", timeout));
; 2240 :                 timeout = INFINITE;

  00078	e3e05000	 mvn         r5, #0
  0007c		 |$LN21@IntrThread|

; 2253 : 
; 2254 :             default:
; 2255 :                 continue;
; 2256 :             }        
; 2257 : 
; 2258 :         // always read/update status registers
; 2259 :         TWLReadRegs(pDevice->hTwl, TWL_BCIMFSTS2, pDevice->rgBciStatus, 3);

  0007c	e5940018	 ldr         r0, [r4, #0x18]
  00080	e3a01802	 mov         r1, #2, 16
  00084	e3811082	 orr         r1, r1, #0x82
  00088	e3a03003	 mov         r3, #3
  0008c	e2842060	 add         r2, r4, #0x60
  00090	eb000000	 bl          TWLReadRegs

; 2260 :         DEBUGMSG(ZONE_PDD, (L"BCI: interrupt: "
; 2261 :             L"status[0]=%02X, status[1]=%02X, status[2]=%02X\r\n", 
; 2262 :             pDevice->rgBciStatus[0], pDevice->rgBciStatus[1],
; 2263 :             pDevice->rgBciStatus[2])
; 2264 :             );
; 2265 : 
; 2266 :         // choose correct charge mode to enter
; 2267 :         EnterCriticalSection(&pDevice->cs);

  00094	e1a00004	 mov         r0, r4
  00098	eb000000	 bl          EnterCriticalSection

; 2268 :         // check for over-voltage, over-current, or over-temperature
; 2269 :         if (pDevice->rgBciStatus[IDX_BCIMFSTS2] & (VBUSOV | ACCHGOV))

  0009c	e5d43060	 ldrb        r3, [r4, #0x60]
  000a0	e3130003	 tst         r3, #3
  000a4	0a00000b	 beq         |$LN18@IntrThread|

; 2270 :             {
; 2271 :             DEBUGMSG(ZONE_PDD, (L"BCI: over voltage detected\r\n"));
; 2272 :             if (pDevice->currentMode == kBCI_USBHost)

  000a8	e5943014	 ldr         r3, [r4, #0x14]
  000ac	e3530002	 cmp         r3, #2
  000b0	1a000039	 bne         |$LN3@IntrThread|

; 2273 :                 {
; 2274 :                 // let hw FSM handle overcharges
; 2275 :                 SetChargeMode_ACCharge(pDevice);

  000b4	e1a00004	 mov         r0, r4
  000b8	eb000000	 bl          SetChargeMode_ACCharge

; 2276 :                 pDevice->currentMode = kBCI_SurgeProtect;
; 2277 : 
; 2278 :                 // wait a second and check voltages again
; 2279 :                 timeout = pDevice->nOverVoltageTimeout;

  000bc	e5945054	 ldr         r5, [r4, #0x54]

; 2302 :                 pDevice->currentMode = kBCI_SurgeProtect;
; 2303 : 
; 2304 :                 // wait a second and check voltages again
; 2305 :                 timeout = pDevice->nOverChargeTimeout;

  000c0	e5849014	 str         r9, [r4, #0x14]

; 2306 :                 }

  000c4	ea000034	 b           |$LN3@IntrThread|
  000c8		 |$LN20@IntrThread|

; 2241 :                 // fall-through
; 2242 : 
; 2243 :             case (WAIT_OBJECT_0 + 1):
; 2244 :                 break;
; 2245 : 
; 2246 :             case (WAIT_OBJECT_0 + 2):
; 2247 :                 RETAILMSG(1, (L"BCI: Receive Hot-Die warning interrupt !\r\n"));

  000c8	e59f0154	 ldr         r0, [pc, #0x154]
  000cc	eb000000	 bl          NKDbgPrintfW

; 2248 :                 SetEvent(hHotDieTriggerEvent_Test);

  000d0	e5980000	 ldr         r0, [r8]

; 2249 :                 
; 2250 :                 //Below actions to decrease the temperature of the Power IC should be done by OEM
; 2251 :                 
; 2252 :                 continue;

  000d4	ea00003a	 b           |$LN45@IntrThread|
  000d8		 |$LN18@IntrThread|

; 2280 :                 }
; 2281 :             }
; 2282 :         else if (pDevice->rgBciStatus[IDX_BCIMFSTS3] & (TBATOR1 | TBATOR2))

  000d8	e5d43061	 ldrb        r3, [r4, #0x61]
  000dc	e3130018	 tst         r3, #0x18
  000e0	0a000007	 beq         |$LN15@IntrThread|

; 2283 :             {
; 2284 :             DEBUGMSG(ZONE_PDD, (L"BCI: OOB temperature detected\r\n"));
; 2285 :             if (pDevice->currentMode == kBCI_USBHost)

  000e4	e5943014	 ldr         r3, [r4, #0x14]
  000e8	e3530002	 cmp         r3, #2
  000ec	1a00002a	 bne         |$LN3@IntrThread|

; 2286 :                 {
; 2287 :                 // let hw FSM handle overcharges
; 2288 :                 SetChargeMode_ACCharge(pDevice);

  000f0	e1a00004	 mov         r0, r4
  000f4	eb000000	 bl          SetChargeMode_ACCharge

; 2289 :                 pDevice->currentMode = kBCI_SurgeProtect;
; 2290 : 
; 2291 :                 // wait a second and check voltages again
; 2292 :                 timeout = pDevice->nOOBTemperatureTimeout;

  000f8	e5945058	 ldr         r5, [r4, #0x58]

; 2302 :                 pDevice->currentMode = kBCI_SurgeProtect;
; 2303 : 
; 2304 :                 // wait a second and check voltages again
; 2305 :                 timeout = pDevice->nOverChargeTimeout;

  000fc	e5849014	 str         r9, [r4, #0x14]

; 2306 :                 }

  00100	ea000025	 b           |$LN3@IntrThread|
  00104		 |$LN15@IntrThread|

; 2293 :                 }
; 2294 :             }
; 2295 :         else if (pDevice->rgBciStatus[IDX_BCIMFSTS3] & (ICHGHIGH))

  00104	e3130001	 tst         r3, #1
  00108	0a000007	 beq         |$LN12@IntrThread|

; 2296 :             {
; 2297 :             DEBUGMSG(ZONE_PDD, (L"BCI: over/under charge current detected\r\n"));
; 2298 :             if (pDevice->currentMode == kBCI_USBHost)

  0010c	e5943014	 ldr         r3, [r4, #0x14]
  00110	e3530002	 cmp         r3, #2
  00114	1a000020	 bne         |$LN3@IntrThread|

; 2299 :                 {
; 2300 :                 // let hw FSM handle overcharges
; 2301 :                 SetChargeMode_ACCharge(pDevice);

  00118	e1a00004	 mov         r0, r4
  0011c	eb000000	 bl          SetChargeMode_ACCharge

; 2302 :                 pDevice->currentMode = kBCI_SurgeProtect;
; 2303 : 
; 2304 :                 // wait a second and check voltages again
; 2305 :                 timeout = pDevice->nOverChargeTimeout;

  00120	e594505c	 ldr         r5, [r4, #0x5C]
  00124	e5849014	 str         r9, [r4, #0x14]

; 2306 :                 }

  00128	ea00001b	 b           |$LN3@IntrThread|
  0012c		 |$LN12@IntrThread|

; 2307 :             }
; 2308 :         else if (pDevice->rgBciStatus[IDX_BCIMFSTS3] & (ICHGEOC))

  0012c	e3130004	 tst         r3, #4
  00130	0a000007	 beq         |$LN9@IntrThread|

; 2309 :             {
; 2310 :             DEBUGMSG(ZONE_PDD, (L"BCI: end of charge detected\r\n"));
; 2311 :             if (pDevice->currentMode == kBCI_USBHost)

  00134	e5943014	 ldr         r3, [r4, #0x14]
  00138	e3530002	 cmp         r3, #2
  0013c	1a000016	 bne         |$LN3@IntrThread|

; 2312 :                 {
; 2313 :                 // let hw FSM handle overcharges
; 2314 :                 SetChargeMode_ACCharge(pDevice);

  00140	e1a00004	 mov         r0, r4
  00144	eb000000	 bl          SetChargeMode_ACCharge

; 2315 :                 pDevice->currentMode = kBCI_EOC;
; 2316 : 
; 2317 :                 // wait a second and check voltages again
; 2318 :                 timeout = pDevice->nEndOfChargeTimeout;

  00148	e5945050	 ldr         r5, [r4, #0x50]
  0014c	e584a014	 str         r10, [r4, #0x14]

; 2319 :                 }

  00150	ea000011	 b           |$LN3@IntrThread|
  00154		 |$LN9@IntrThread|

; 2320 :             }
; 2321 :         else if (IsVACValid(pDevice))

  00154	e1a00004	 mov         r0, r4
  00158	eb000000	 bl          IsVACValid
  0015c	e3500000	 cmp         r0, #0

; 2322 :             {
; 2323 :             DEBUGMSG(ZONE_PDD, (L"BCI: Charging via VAC\r\n"));
; 2324 :             SetChargeMode_ACCharge(pDevice);

  00160	e1a00004	 mov         r0, r4
  00164	0a000002	 beq         |$LN6@IntrThread|
  00168	eb000000	 bl          SetChargeMode_ACCharge

; 2325 :             pDevice->currentMode = kBCI_AC;

  0016c	e584b014	 str         r11, [r4, #0x14]
  00170	ea000009	 b           |$LN3@IntrThread|
  00174		 |$LN6@IntrThread|

; 2326 :             }
; 2327 :         else if (IsVBUSValid(pDevice))

  00174	eb000000	 bl          IsVBUSValid
  00178	e3500000	 cmp         r0, #0

; 2328 :             {
; 2329 :             DEBUGMSG(ZONE_PDD, (L"BCI: Charging via USBHost\r\n"));
; 2330 :             SetChargeMode_USBHost(pDevice);

  0017c	e1a00004	 mov         r0, r4
  00180	0a000002	 beq         |$LN4@IntrThread|
  00184	eb000000	 bl          SetChargeMode_USBHost

; 2331 :             pDevice->currentMode = kBCI_USBHost;

  00188	e3a03002	 mov         r3, #2

; 2332 :             }
; 2333 :         else

  0018c	ea000001	 b           |$LN42@IntrThread|
  00190		 |$LN4@IntrThread|

; 2334 :             {            
; 2335 :             DEBUGMSG(ZONE_PDD, (L"BCI: Not Charging\r\n"));
; 2336 :             SetChargeMode_ACCharge(pDevice);

  00190	eb000000	 bl          SetChargeMode_ACCharge

; 2337 :             pDevice->currentMode = kBCI_Battery;

  00194	e3a03000	 mov         r3, #0
  00198		 |$LN42@IntrThread|
  00198	e5843014	 str         r3, [r4, #0x14]
  0019c		 |$LN3@IntrThread|

; 2338 :             }
; 2339 :         LeaveCriticalSection(&pDevice->cs);

  0019c	e1a00004	 mov         r0, r4
  001a0	eb000000	 bl          LeaveCriticalSection

; 2340 : 
; 2341 :         // signal battery driver of state change
; 2342 :         if (prevMode != pDevice->currentMode)

  001a4	e5942014	 ldr         r2, [r4, #0x14]
  001a8	e1560002	 cmp         r6, r2
  001ac	0a000015	 beq         |$LN23@IntrThread|

; 2343 :             {
; 2344 :             prevMode = pDevice->currentMode;
; 2345 :             if (pDevice->hBattSignal != NULL) SetEvent(pDevice->hBattSignal);

  001b0	e5943020	 ldr         r3, [r4, #0x20]
  001b4	e1a06002	 mov         r6, r2
  001b8	e3530000	 cmp         r3, #0
  001bc	0a000011	 beq         |$LN23@IntrThread|
  001c0	e1a00003	 mov         r0, r3
  001c4		 |$LN45@IntrThread|
  001c4	e3a01003	 mov         r1, #3
  001c8	eb000000	 bl          EventModify

; 2346 :             }
; 2347 :         
; 2348 :         }

  001cc	ea00000d	 b           |$LN23@IntrThread|
  001d0		 |$LN24@IntrThread|

; 2227 :             {
; 2228 :             case WAIT_OBJECT_0:
; 2229 :                 TWLReadRegs(pDevice->hTwl, TWL_PWR_ISR1, &status, 1);                

  001d0	e5940018	 ldr         r0, [r4, #0x18]
  001d4	e3a01803	 mov         r1, #3, 16
  001d8	e381102e	 orr         r1, r1, #0x2E
  001dc	e3a03001	 mov         r3, #1
  001e0	e28d2000	 add         r2, sp, #0
  001e4	eb000000	 bl          TWLReadRegs

; 2230 :                 TWLWriteRegs(pDevice->hTwl, TWL_PWR_ISR1, &status, 1);

  001e8	e5940018	 ldr         r0, [r4, #0x18]
  001ec	e3a01803	 mov         r1, #3, 16
  001f0	e381102e	 orr         r1, r1, #0x2E
  001f4	e3a03001	 mov         r3, #1
  001f8	e28d2000	 add         r2, sp, #0
  001fc	eb000000	 bl          TWLWriteRegs

; 2231 :                 if (timeout == INFINITE)

  00200	e3750001	 cmn         r5, #1

; 2232 :                     {
; 2233 :                     timeout = 100;

  00204	03a05064	 moveq       r5, #0x64
  00208		 |$LN23@IntrThread|
  00208	e594303c	 ldr         r3, [r4, #0x3C]
  0020c	e3530000	 cmp         r3, #0
  00210	0affff88	 beq         |$LL29@IntrThread|
  00214		 |$LN41@IntrThread|

; 2349 : 
; 2350 :     return ERROR_SUCCESS;

  00214	e3a00000	 mov         r0, #0

; 2351 : }

  00218	e28dd004	 add         sp, sp, #4
  0021c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00220	e12fff1e	 bx          lr
  00224		 |$LN49@IntrThread|
  00224		 |$LN50@IntrThread|
  00224	00000000	 DCD         |??_C@_1FG@NHKAOOAG@?$AAB?$AAC?$AAI?$AA?3?$AA?5?$AAR?$AAe?$AAc?$AAe?$AAi?$AAv?$AAe?$AA?5?$AAH?$AAo?$AAt?$AA?9?$AAD?$AAi?$AAe?$AA?5?$AAw?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAn?$AAt@|
  00228		 |$LN51@IntrThread|
  00228	00000000	 DCD         |hHotDieTriggerEvent_Test|
  0022c		 |$M45484|

			 ENDP  ; |IntrThread|

	EXPORT	|BCI_Initialize|
	EXPORT	|??_C@_1BK@IPMNAFIC@?$AAH?$AAo?$AAt?$AAD?$AAi?$AAe?$AAD?$AAe?$AAt?$AAe?$AAc?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BM@PDHJOICM@?$AAH?$AAo?$AAt?$AAD?$AAi?$AAe?$AAT?$AAe?$AAm?$AAp?$AAS?$AAe?$AAl?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DA@LPGHDBOE@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAB?$AAu?$AAi?$AAl?$AAt?$AAI?$AAn?$AA?2?$AAB?$AAa?$AAt?$AAt?$AAe?$AAr?$AAy?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BM@IEEIFNBO@?$AAS?$AAS?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AAP?$AAo?$AAw?$AAe?$AAr?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|CeSetThreadPriority|
	IMPORT	|CreateThread|
	IMPORT	|RegCloseKey|
	IMPORT	|RegQueryValueExW|
	IMPORT	|RegOpenKeyExW|
	IMPORT	|TWLInterruptInitialize|
	IMPORT	|CreateEventW|
	IMPORT	|TWLOpen|
	IMPORT	|InitializeCriticalSection|
	IMPORT	|memset|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T45511| DCD	|$LN27@BCI_Initia|
	DCD	0x40016702

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@IPMNAFIC@?$AAH?$AAo?$AAt?$AAD?$AAi?$AAe?$AAD?$AAe?$AAt?$AAe?$AAc?$AAt?$AA?$AA@| DCB "H"
	DCB	0x0, "o", 0x0, "t", 0x0, "D", 0x0, "i", 0x0, "e", 0x0, "D"
	DCB	0x0, "e", 0x0, "t", 0x0, "e", 0x0, "c", 0x0, "t", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BM@PDHJOICM@?$AAH?$AAo?$AAt?$AAD?$AAi?$AAe?$AAT?$AAe?$AAm?$AAp?$AAS?$AAe?$AAl?$AA?$AA@| DCB "H"
	DCB	0x0, "o", 0x0, "t", 0x0, "D", 0x0, "i", 0x0, "e", 0x0, "T"
	DCB	0x0, "e", 0x0, "m", 0x0, "p", 0x0, "S", 0x0, "e", 0x0, "l"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DA@LPGHDBOE@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAB?$AAu?$AAi?$AAl?$AAt?$AAI?$AAn?$AA?2?$AAB?$AAa?$AAt?$AAt?$AAe?$AAr?$AAy?$AA?$AA@| DCB "D"
	DCB	0x0, "r", 0x0, "i", 0x0, "v", 0x0, "e", 0x0, "r", 0x0, "s"
	DCB	0x0, "\\", 0x0, "B", 0x0, "u", 0x0, "i", 0x0, "l", 0x0, "t"
	DCB	0x0, "I", 0x0, "n", 0x0, "\\", 0x0, "B", 0x0, "a", 0x0, "t"
	DCB	0x0, "t", 0x0, "e", 0x0, "r", 0x0, "y", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BM@IEEIFNBO@?$AAS?$AAS?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AAP?$AAo?$AAw?$AAe?$AAr?$AA?$AA@| DCB "S"
	DCB	0x0, "S", 0x0, "U", 0x0, "p", 0x0, "d", 0x0, "a", 0x0, "t"
	DCB	0x0, "e", 0x0, "P", 0x0, "o", 0x0, "w", 0x0, "e", 0x0, "r"
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\bci\bci.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BCI_Initialize| PROC

; 1093 : {

  00000		 |$LN27@BCI_Initia|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd01c	 sub         sp, sp, #0x1C
  00008		 |$M45508|
  00008	e1a06003	 mov         r6, r3
  0000c	e1a04001	 mov         r4, r1
  00010	e1a07000	 mov         r7, r0

; 1094 :     Device_t *pDevice;
; 1095 :     BOOL bSuccess = FALSE;
; 1096 :     HKEY hKey;
; 1097 :     DWORD m_dwTempSel;
; 1098 :     DWORD size;
; 1099 :     DWORD dwType = REG_DWORD;

  00014	e3a03004	 mov         r3, #4

; 1100 :     UINT8 regval;
; 1101 :     DEBUGMSG(ZONE_FUNCTION, (L"+BCI_Initialize()\r\n"));
; 1102 :     UNREFERENCED_PARAMETER(nOverVoltageTimeout);
; 1103 :     
; 1104 :     // Create device structure
; 1105 :     pDevice = (Device_t *)LocalAlloc(LPTR, sizeof(Device_t));

  00018	e3a01068	 mov         r1, #0x68
  0001c	e3a00040	 mov         r0, #0x40
  00020	e58d3010	 str         r3, [sp, #0x10]
  00024	eb000000	 bl          LocalAlloc
  00028	e1b05000	 movs        r5, r0

; 1106 :     if (pDevice == NULL)

  0002c	0a0000d1	 beq         |$LN24@BCI_Initia|

; 1107 :         {
; 1108 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: BCI_Initialize: "
; 1109 :             L"Failed allocate BCI structure\r\n"
; 1110 :             ));
; 1111 :         goto cleanUp;
; 1112 :         }
; 1113 : 
; 1114 :     // initialize memory
; 1115 :     memset(pDevice, 0, sizeof(Device_t));

  00030	e3a02068	 mov         r2, #0x68
  00034	e3a01000	 mov         r1, #0
  00038	e1a00005	 mov         r0, r5
  0003c	eb000000	 bl          memset

; 1116 : 
; 1117 :     // copy timeout values
; 1118 :     pDevice->nEndOfChargeTimeout = nEOCTimeout;
; 1119 :     pDevice->nOverChargeTimeout = nOverChargeTimeout;
; 1120 :     pDevice->nOOBTemperatureTimeout = nOOBTemperatureTimeout;
; 1121 :     pDevice->nOverVoltageTimeout = nOverChargeTimeout;
; 1122 :     
; 1123 :     // initialize data structure
; 1124 :     InitializeCriticalSection(&pDevice->cs);

  00040	e1a00005	 mov         r0, r5
  00044	e5857050	 str         r7, [r5, #0x50]
  00048	e585405c	 str         r4, [r5, #0x5C]
  0004c	e5856058	 str         r6, [r5, #0x58]
  00050	e5854054	 str         r4, [r5, #0x54]
  00054	eb000000	 bl          InitializeCriticalSection

; 1125 :     pDevice->currentMode = kBCI_Unknown;
; 1126 : 
; 1127 :     // set to default charge current levels (mA)
; 1128 :     pDevice->preScale = 1;

  00058	e3a02001	 mov         r2, #1
  0005c	e5852034	 str         r2, [r5, #0x34]
  00060	e3a03005	 mov         r3, #5

; 1129 :     BCI_SetChargeCurrent(pDevice, kBCI_AC, BCI_DEFAULT_ACCHARGECURRENT);

  00064	e3a02f96	 mov         r2, #0x96, 30
  00068	e3a01001	 mov         r1, #1
  0006c	e1a00005	 mov         r0, r5
  00070	e5853014	 str         r3, [r5, #0x14]
  00074	eb000000	 bl          BCI_SetChargeCurrent

; 1130 :     BCI_SetChargeCurrent(pDevice, kBCI_USBHost, BCI_DEFAULT_USBCHARGECURRENT);

  00078	e3a02f7d	 mov         r2, #0x7D, 30
  0007c	e3a01002	 mov         r1, #2
  00080	e1a00005	 mov         r0, r5
  00084	eb000000	 bl          BCI_SetChargeCurrent

; 1131 : 
; 1132 :     // open handle to Triton driver
; 1133 :     pDevice->hTwl = TWLOpen();

  00088	eb000000	 bl          TWLOpen
  0008c	e3500000	 cmp         r0, #0
  00090	e5850018	 str         r0, [r5, #0x18]

; 1134 :     if ( pDevice->hTwl == NULL )

  00094	0a0000b7	 beq         |$LN24@BCI_Initia|

; 1135 :         {
; 1136 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: BCI_Initialize: "
; 1137 :             L"Failed open Triton device driver\r\n"
; 1138 :             ));
; 1139 :         goto cleanUp;
; 1140 :         }
; 1141 :     
; 1142 :     // open handle to Triton driver
; 1143 :     pDevice->hMadc = MADCOpen();

  00098	eb000000	 bl          MADCOpen
  0009c	e3500000	 cmp         r0, #0
  000a0	e585001c	 str         r0, [r5, #0x1C]

; 1144 :     if ( pDevice->hMadc == NULL )

  000a4	0a0000b3	 beq         |$LN24@BCI_Initia|

; 1145 :         {
; 1146 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: BCI_Initialize: "
; 1147 :             L"Failed to open MADC device driver\r\n"
; 1148 :             ));
; 1149 :         goto cleanUp;
; 1150 :         }
; 1151 : 
; 1152 :     // create a named event to signal battery of state change
; 1153 :     pDevice->hBattSignal = CreateEvent(NULL, FALSE, FALSE, BATTERYSINGAL_NAMED_EVENT);

  000a8	e59f34e8	 ldr         r3, [pc, #0x4E8]
  000ac	e3a02000	 mov         r2, #0
  000b0	e3a01000	 mov         r1, #0
  000b4	e3a00000	 mov         r0, #0
  000b8	eb000000	 bl          CreateEventW
  000bc	e1a03000	 mov         r3, r0

; 1154 :     DEBUGMSG(pDevice->hBattSignal == NULL, (L"ERROR: BCI_Initialize: "
; 1155 :         L"Failed to open battery named event (%s)", BATTERYSINGAL_NAMED_EVENT)
; 1156 :         );
; 1157 : 
; 1158 : 
; 1159 :     // Create interrupt event
; 1160 :     pDevice->rgIntrEvents[EVENT_POWER] = CreateEvent(NULL, FALSE, FALSE, NULL);

  000c0	e5853020	 str         r3, [r5, #0x20]
  000c4	e3a03000	 mov         r3, #0
  000c8	e3a00000	 mov         r0, #0
  000cc	e3a02000	 mov         r2, #0
  000d0	e3a01000	 mov         r1, #0
  000d4	eb000000	 bl          CreateEventW
  000d8	e3500000	 cmp         r0, #0
  000dc	e5850028	 str         r0, [r5, #0x28]

; 1161 :     if (pDevice->rgIntrEvents[EVENT_POWER] == NULL)

  000e0	0a0000a4	 beq         |$LN24@BCI_Initia|

; 1162 :         {
; 1163 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: BCI_Initialize: "
; 1164 :             L"Failed create interrupt Power event\r\n"
; 1165 :             ));
; 1166 :         goto cleanUp;
; 1167 :         }
; 1168 : 
; 1169 :     // Create interrupt event
; 1170 :     pDevice->rgIntrEvents[EVENT_BCI] = CreateEvent(NULL, FALSE, FALSE, NULL);

  000e4	e3a03000	 mov         r3, #0
  000e8	e3a02000	 mov         r2, #0
  000ec	e3a01000	 mov         r1, #0
  000f0	e3a00000	 mov         r0, #0
  000f4	eb000000	 bl          CreateEventW
  000f8	e3500000	 cmp         r0, #0
  000fc	e585002c	 str         r0, [r5, #0x2C]

; 1171 :     if (pDevice->rgIntrEvents[EVENT_BCI] == NULL)

  00100	0a00009c	 beq         |$LN24@BCI_Initia|

; 1172 :         {
; 1173 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: BCI_Initialize: "
; 1174 :             L"Failed create interrupt BCI event\r\n"
; 1175 :             ));
; 1176 :         goto cleanUp;
; 1177 :         }
; 1178 : 
; 1179 :     // register for AC charger interrupts
; 1180 :     if (!TWLInterruptInitialize(pDevice->hTwl, TWL_INTR_CHG_PRES, 
; 1181 :         pDevice->rgIntrEvents[EVENT_POWER]))

  00104	e5952028	 ldr         r2, [r5, #0x28]
  00108	e5950018	 ldr         r0, [r5, #0x18]
  0010c	e59f1480	 ldr         r1, [pc, #0x480]
  00110	eb000000	 bl          TWLInterruptInitialize
  00114	e3500000	 cmp         r0, #0
  00118	0a000096	 beq         |$LN24@BCI_Initia|

; 1182 :         {
; 1183 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: BCI_Initialize: "
; 1184 :             L"Failed associate event with TWL POWER interrupt\r\n"
; 1185 :             ));
; 1186 :         goto cleanUp;
; 1187 :         }
; 1188 :   
; 1189 :     // Enable AC charger event
; 1190 :     if (!TWLInterruptMask(pDevice->hTwl, TWL_INTR_CHG_PRES, FALSE))

  0011c	e5950018	 ldr         r0, [r5, #0x18]
  00120	e59f146c	 ldr         r1, [pc, #0x46C]
  00124	e3a02000	 mov         r2, #0
  00128	eb000000	 bl          TWLInterruptMask
  0012c	e3500000	 cmp         r0, #0
  00130	0a000090	 beq         |$LN24@BCI_Initia|

; 1191 :         {
; 1192 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: BCI_Initialize: "
; 1193 :             L"Failed to enable TWL POWER interrupt\r\n"
; 1194 :             ));
; 1195 :         goto cleanUp;
; 1196 :         }
; 1197 : 
; 1198 :     // register for bci interrupts
; 1199 :     if (!TWLInterruptInitialize(pDevice->hTwl, TWL_INTR_ICHGHIGH, pDevice->rgIntrEvents[EVENT_BCI]) ||
; 1200 :         !TWLInterruptInitialize(pDevice->hTwl, TWL_INTR_ICHGLOW, pDevice->rgIntrEvents[EVENT_BCI]) ||
; 1201 :         !TWLInterruptInitialize(pDevice->hTwl, TWL_INTR_ICHGEOC, pDevice->rgIntrEvents[EVENT_BCI]) ||
; 1202 :         !TWLInterruptInitialize(pDevice->hTwl, TWL_INTR_TBATOR2, pDevice->rgIntrEvents[EVENT_BCI]) ||
; 1203 :         !TWLInterruptInitialize(pDevice->hTwl, TWL_INTR_TBATOR1, pDevice->rgIntrEvents[EVENT_BCI]) ||
; 1204 :         !TWLInterruptInitialize(pDevice->hTwl, TWL_INTR_BATSTS, pDevice->rgIntrEvents[EVENT_BCI]) ||
; 1205 :         !TWLInterruptInitialize(pDevice->hTwl, TWL_INTR_VBATLVL, pDevice->rgIntrEvents[EVENT_BCI]) ||
; 1206 :         !TWLInterruptInitialize(pDevice->hTwl, TWL_INTR_VBATOV, pDevice->rgIntrEvents[EVENT_BCI]) ||
; 1207 :         !TWLInterruptInitialize(pDevice->hTwl, TWL_INTR_VBUSOV, pDevice->rgIntrEvents[EVENT_BCI]) ||
; 1208 :         !TWLInterruptInitialize(pDevice->hTwl, TWL_INTR_ACCHGOV, pDevice->rgIntrEvents[EVENT_BCI])
; 1209 :         )

  00134	e595202c	 ldr         r2, [r5, #0x2C]
  00138	e5950018	 ldr         r0, [r5, #0x18]
  0013c	e59f144c	 ldr         r1, [pc, #0x44C]
  00140	eb000000	 bl          TWLInterruptInitialize
  00144	e3500000	 cmp         r0, #0
  00148	0a00008a	 beq         |$LN24@BCI_Initia|
  0014c	e595202c	 ldr         r2, [r5, #0x2C]
  00150	e5950018	 ldr         r0, [r5, #0x18]
  00154	e59f1430	 ldr         r1, [pc, #0x430]
  00158	eb000000	 bl          TWLInterruptInitialize
  0015c	e3500000	 cmp         r0, #0
  00160	0a000084	 beq         |$LN24@BCI_Initia|
  00164	e595202c	 ldr         r2, [r5, #0x2C]
  00168	e5950018	 ldr         r0, [r5, #0x18]
  0016c	e59f1414	 ldr         r1, [pc, #0x414]
  00170	eb000000	 bl          TWLInterruptInitialize
  00174	e3500000	 cmp         r0, #0
  00178	0a00007e	 beq         |$LN24@BCI_Initia|
  0017c	e595202c	 ldr         r2, [r5, #0x2C]
  00180	e5950018	 ldr         r0, [r5, #0x18]
  00184	e59f13f8	 ldr         r1, [pc, #0x3F8]
  00188	eb000000	 bl          TWLInterruptInitialize
  0018c	e3500000	 cmp         r0, #0
  00190	0a000078	 beq         |$LN24@BCI_Initia|
  00194	e595202c	 ldr         r2, [r5, #0x2C]
  00198	e5950018	 ldr         r0, [r5, #0x18]
  0019c	e59f13dc	 ldr         r1, [pc, #0x3DC]
  001a0	eb000000	 bl          TWLInterruptInitialize
  001a4	e3500000	 cmp         r0, #0
  001a8	0a000072	 beq         |$LN24@BCI_Initia|
  001ac	e595202c	 ldr         r2, [r5, #0x2C]
  001b0	e5950018	 ldr         r0, [r5, #0x18]
  001b4	e59f13c0	 ldr         r1, [pc, #0x3C0]
  001b8	eb000000	 bl          TWLInterruptInitialize
  001bc	e3500000	 cmp         r0, #0
  001c0	0a00006c	 beq         |$LN24@BCI_Initia|
  001c4	e595202c	 ldr         r2, [r5, #0x2C]
  001c8	e5950018	 ldr         r0, [r5, #0x18]
  001cc	e3a04a12	 mov         r4, #0x12, 20
  001d0	e3841010	 orr         r1, r4, #0x10
  001d4	eb000000	 bl          TWLInterruptInitialize
  001d8	e3500000	 cmp         r0, #0
  001dc	0a000065	 beq         |$LN24@BCI_Initia|
  001e0	e595202c	 ldr         r2, [r5, #0x2C]
  001e4	e5950018	 ldr         r0, [r5, #0x18]
  001e8	e59f1388	 ldr         r1, [pc, #0x388]
  001ec	eb000000	 bl          TWLInterruptInitialize
  001f0	e3500000	 cmp         r0, #0
  001f4	0a00005f	 beq         |$LN24@BCI_Initia|
  001f8	e595202c	 ldr         r2, [r5, #0x2C]
  001fc	e5950018	 ldr         r0, [r5, #0x18]
  00200	e59f136c	 ldr         r1, [pc, #0x36C]
  00204	eb000000	 bl          TWLInterruptInitialize
  00208	e3500000	 cmp         r0, #0
  0020c	0a000059	 beq         |$LN24@BCI_Initia|
  00210	e595202c	 ldr         r2, [r5, #0x2C]
  00214	e5950018	 ldr         r0, [r5, #0x18]
  00218	e59f1350	 ldr         r1, [pc, #0x350]
  0021c	eb000000	 bl          TWLInterruptInitialize
  00220	e3500000	 cmp         r0, #0
  00224	0a000053	 beq         |$LN24@BCI_Initia|

; 1210 :         {
; 1211 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: BCI_Initialize: "
; 1212 :             L"Failed associate event with TWL BCI interrupt\r\n"
; 1213 :             ));
; 1214 :         goto cleanUp;
; 1215 :         }
; 1216 :   
; 1217 :     // Enable BCI events
; 1218 :     if (!TWLInterruptMask(pDevice->hTwl, TWL_INTR_ICHGHIGH, FALSE) ||
; 1219 :         !TWLInterruptMask(pDevice->hTwl, TWL_INTR_ICHGLOW, FALSE) ||
; 1220 :         !TWLInterruptMask(pDevice->hTwl, TWL_INTR_ICHGEOC, FALSE) ||
; 1221 :         !TWLInterruptMask(pDevice->hTwl, TWL_INTR_TBATOR2, FALSE) ||
; 1222 :         !TWLInterruptMask(pDevice->hTwl, TWL_INTR_TBATOR1, FALSE) ||
; 1223 :         !TWLInterruptMask(pDevice->hTwl, TWL_INTR_BATSTS, FALSE) ||
; 1224 :         !TWLInterruptMask(pDevice->hTwl, TWL_INTR_VBATLVL, FALSE) ||
; 1225 :         !TWLInterruptMask(pDevice->hTwl, TWL_INTR_VBATOV, FALSE) ||
; 1226 :         !TWLInterruptMask(pDevice->hTwl, TWL_INTR_VBUSOV, FALSE) ||
; 1227 :         !TWLInterruptMask(pDevice->hTwl, TWL_INTR_ACCHGOV, FALSE))

  00228	e5950018	 ldr         r0, [r5, #0x18]
  0022c	e59f135c	 ldr         r1, [pc, #0x35C]
  00230	e3a02000	 mov         r2, #0
  00234	eb000000	 bl          TWLInterruptMask
  00238	e3500000	 cmp         r0, #0
  0023c	0a00004d	 beq         |$LN24@BCI_Initia|
  00240	e5950018	 ldr         r0, [r5, #0x18]
  00244	e59f1340	 ldr         r1, [pc, #0x340]
  00248	e3a02000	 mov         r2, #0
  0024c	eb000000	 bl          TWLInterruptMask
  00250	e3500000	 cmp         r0, #0
  00254	0a000047	 beq         |$LN24@BCI_Initia|
  00258	e5950018	 ldr         r0, [r5, #0x18]
  0025c	e59f1324	 ldr         r1, [pc, #0x324]
  00260	e3a02000	 mov         r2, #0
  00264	eb000000	 bl          TWLInterruptMask
  00268	e3500000	 cmp         r0, #0
  0026c	0a000041	 beq         |$LN24@BCI_Initia|
  00270	e5950018	 ldr         r0, [r5, #0x18]
  00274	e59f1308	 ldr         r1, [pc, #0x308]
  00278	e3a02000	 mov         r2, #0
  0027c	eb000000	 bl          TWLInterruptMask
  00280	e3500000	 cmp         r0, #0
  00284	0a00003b	 beq         |$LN24@BCI_Initia|
  00288	e5950018	 ldr         r0, [r5, #0x18]
  0028c	e59f12ec	 ldr         r1, [pc, #0x2EC]
  00290	e3a02000	 mov         r2, #0
  00294	eb000000	 bl          TWLInterruptMask
  00298	e3500000	 cmp         r0, #0
  0029c	0a000035	 beq         |$LN24@BCI_Initia|
  002a0	e5950018	 ldr         r0, [r5, #0x18]
  002a4	e59f12d0	 ldr         r1, [pc, #0x2D0]
  002a8	e3a02000	 mov         r2, #0
  002ac	eb000000	 bl          TWLInterruptMask
  002b0	e3500000	 cmp         r0, #0
  002b4	0a00002f	 beq         |$LN24@BCI_Initia|
  002b8	e5950018	 ldr         r0, [r5, #0x18]
  002bc	e3a02000	 mov         r2, #0
  002c0	e3841010	 orr         r1, r4, #0x10
  002c4	eb000000	 bl          TWLInterruptMask
  002c8	e3500000	 cmp         r0, #0
  002cc	0a000029	 beq         |$LN24@BCI_Initia|
  002d0	e5950018	 ldr         r0, [r5, #0x18]
  002d4	e59f129c	 ldr         r1, [pc, #0x29C]
  002d8	e3a02000	 mov         r2, #0
  002dc	eb000000	 bl          TWLInterruptMask
  002e0	e3500000	 cmp         r0, #0
  002e4	0a000023	 beq         |$LN24@BCI_Initia|
  002e8	e5950018	 ldr         r0, [r5, #0x18]
  002ec	e59f1280	 ldr         r1, [pc, #0x280]
  002f0	e3a02000	 mov         r2, #0
  002f4	eb000000	 bl          TWLInterruptMask
  002f8	e3500000	 cmp         r0, #0
  002fc	0a00001d	 beq         |$LN24@BCI_Initia|
  00300	e5950018	 ldr         r0, [r5, #0x18]
  00304	e59f1264	 ldr         r1, [pc, #0x264]
  00308	e3a02000	 mov         r2, #0
  0030c	eb000000	 bl          TWLInterruptMask
  00310	e3500000	 cmp         r0, #0
  00314	0a000017	 beq         |$LN24@BCI_Initia|

; 1228 :         {
; 1229 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: BCI_Initialize: "
; 1230 :             L"Failed to enable TWL BCI interrupt\r\n"
; 1231 :             ));
; 1232 :         goto cleanUp;
; 1233 :         }
; 1234 : 
; 1235 :     //Open registry to read the configuration of Hot-die interrupt temperature selection
; 1236 :     if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPWSTR)REG_BATTERY_DRV_PATH, 0, 0, &hKey))

  00318	e59f124c	 ldr         r1, [pc, #0x24C]
  0031c	e28de00c	 add         lr, sp, #0xC
  00320	e3a03000	 mov         r3, #0
  00324	e3a02000	 mov         r2, #0
  00328	e3a0010a	 mov         r0, #0xA, 2
  0032c	e58de000	 str         lr, [sp]
  00330	eb000000	 bl          RegOpenKeyExW
  00334	e3500000	 cmp         r0, #0
  00338	1a00000e	 bne         |$LN24@BCI_Initia|

; 1237 :         {
; 1238 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: BCI_Initialize: "
; 1239 :             L"Failed to open Battery registry!\r\n"
; 1240 :             ));
; 1241 :         goto cleanUp;
; 1242 :         }
; 1243 :  
; 1244 :     size=sizeof(m_dwTempSel);
; 1245 :     if (ERROR_SUCCESS != RegQueryValueEx(hKey, L"HotDieTempSel", 0, &dwType, (BYTE*)&m_dwTempSel, &size))

  0033c	e59f1224	 ldr         r1, [pc, #0x224]
  00340	e59d000c	 ldr         r0, [sp, #0xC]
  00344	e3a06004	 mov         r6, #4
  00348	e28de014	 add         lr, sp, #0x14
  0034c	e28d4018	 add         r4, sp, #0x18
  00350	e28d3010	 add         r3, sp, #0x10
  00354	e3a02000	 mov         r2, #0
  00358	e58d6014	 str         r6, [sp, #0x14]
  0035c	e58de004	 str         lr, [sp, #4]
  00360	e58d4000	 str         r4, [sp]
  00364	eb000000	 bl          RegQueryValueExW
  00368	e3500000	 cmp         r0, #0

; 1246 :         {
; 1247 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: BCI_Initialize: "
; 1248 :             L"Failed to read HotDieTempSel configuration in Battery registry!\r\n"
; 1249 :             ));
; 1250 :         RegCloseKey(hKey);

  0036c	e59d000c	 ldr         r0, [sp, #0xC]
  00370	0a000007	 beq         |$LN7@BCI_Initia|
  00374	eb000000	 bl          RegCloseKey
  00378		 |$LN24@BCI_Initia|

; 1347 :         {
; 1348 :         BCI_Uninitialize(pDevice);

  00378	e1a00005	 mov         r0, r5
  0037c	eb000000	 bl          BCI_Uninitialize

; 1349 :         pDevice = NULL;

  00380	e3a05000	 mov         r5, #0
  00384		 |$LN1@BCI_Initia|

; 1350 :         }
; 1351 : 
; 1352 :     DEBUGMSG(ZONE_FUNCTION, (L"-BCI_Initialize()\r\n"));    
; 1353 :     return (HANDLE)pDevice;
; 1354 : }

  00384	e1a00005	 mov         r0, r5
  00388	e28dd01c	 add         sp, sp, #0x1C
  0038c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00390	e12fff1e	 bx          lr
  00394		 |$LN7@BCI_Initia|

; 1251 :         goto cleanUp;
; 1252 :         }
; 1253 :         RegCloseKey(hKey);

  00394	eb000000	 bl          RegCloseKey

; 1254 :     
; 1255 :     //Configure the hot-die detector for operation in its lowest temperature range
; 1256 :     TWLReadRegs(pDevice->hTwl, TWL_MISC_CFG , &regval, sizeof(regval));

  00398	e5950018	 ldr         r0, [r5, #0x18]
  0039c	e3a04803	 mov         r4, #3, 16
  003a0	e3841068	 orr         r1, r4, #0x68
  003a4	e3a03001	 mov         r3, #1
  003a8	e28d2008	 add         r2, sp, #8
  003ac	eb000000	 bl          TWLReadRegs

; 1257 :     regval |=(((UINT8)m_dwTempSel)<<6);

  003b0	e5dd0008	 ldrb        r0, [sp, #8]
  003b4	e59d1018	 ldr         r1, [sp, #0x18]

; 1258 :     TWLWriteRegs(pDevice->hTwl, TWL_MISC_CFG , &regval, sizeof(regval));

  003b8	e3a03001	 mov         r3, #1
  003bc	e28d2008	 add         r2, sp, #8
  003c0	e1801301	 orr         r1, r0, r1, lsl #6
  003c4	e5cd1008	 strb        r1, [sp, #8]
  003c8	e5950018	 ldr         r0, [r5, #0x18]
  003cc	e3841068	 orr         r1, r4, #0x68
  003d0	eb000000	 bl          TWLWriteRegs

; 1259 : 
; 1260 :     //Ensure that the hot-die interrupt in _int1  is not masked
; 1261 :     TWLReadRegs(pDevice->hTwl, TWL_PWR_IMR1 , &regval, sizeof(regval)); 

  003d4	e5950018	 ldr         r0, [r5, #0x18]
  003d8	e3a03001	 mov         r3, #1
  003dc	e28d2008	 add         r2, sp, #8
  003e0	e384102f	 orr         r1, r4, #0x2F
  003e4	eb000000	 bl          TWLReadRegs

; 1262 :     regval &=~(HOT_DIE_MASK_INT);

  003e8	e5dd3008	 ldrb        r3, [sp, #8]

; 1263 :     TWLWriteRegs(pDevice->hTwl, TWL_PWR_IMR1 , &regval, sizeof(regval));

  003ec	e28d2008	 add         r2, sp, #8
  003f0	e384102f	 orr         r1, r4, #0x2F
  003f4	e20330ef	 and         r3, r3, #0xEF
  003f8	e5cd3008	 strb        r3, [sp, #8]
  003fc	e5950018	 ldr         r0, [r5, #0x18]
  00400	e3a03001	 mov         r3, #1
  00404	eb000000	 bl          TWLWriteRegs

; 1264 : 
; 1265 :     //Ensure that the hot-die interrupt in _int2 is masked
; 1266 :     TWLReadRegs(pDevice->hTwl, TWL_PWR_IMR2 , &regval, sizeof(regval)); 

  00408	e5950018	 ldr         r0, [r5, #0x18]
  0040c	e3a03001	 mov         r3, #1
  00410	e28d2008	 add         r2, sp, #8
  00414	e3841031	 orr         r1, r4, #0x31
  00418	eb000000	 bl          TWLReadRegs

; 1267 :     regval |=HOT_DIE_MASK_INT;

  0041c	e5dd3008	 ldrb        r3, [sp, #8]

; 1268 :     TWLWriteRegs(pDevice->hTwl, TWL_PWR_IMR2 , &regval, sizeof(regval));

  00420	e28d2008	 add         r2, sp, #8
  00424	e3841031	 orr         r1, r4, #0x31
  00428	e3833010	 orr         r3, r3, #0x10
  0042c	e5cd3008	 strb        r3, [sp, #8]
  00430	e5950018	 ldr         r0, [r5, #0x18]
  00434	e3a03001	 mov         r3, #1
  00438	eb000000	 bl          TWLWriteRegs

; 1269 : 
; 1270 :     //Ensure that the hot-die detector rising and falling threshold is active
; 1271 :     TWLReadRegs(pDevice->hTwl, TWL_PWR_EDR2 , &regval, sizeof(regval));

  0043c	e5950018	 ldr         r0, [r5, #0x18]
  00440	e3a03001	 mov         r3, #1
  00444	e28d2008	 add         r2, sp, #8
  00448	e3841034	 orr         r1, r4, #0x34
  0044c	eb000000	 bl          TWLReadRegs

; 1272 :     regval |=HOT_DIE_RISING | HOT_DIE_FALLING;

  00450	e5dd3008	 ldrb        r3, [sp, #8]

; 1273 :     TWLWriteRegs(pDevice->hTwl, TWL_PWR_EDR2 , &regval, sizeof(regval));

  00454	e28d2008	 add         r2, sp, #8
  00458	e3841034	 orr         r1, r4, #0x34
  0045c	e3833003	 orr         r3, r3, #3
  00460	e5cd3008	 strb        r3, [sp, #8]
  00464	e5950018	 ldr         r0, [r5, #0x18]
  00468	e3a03001	 mov         r3, #1
  0046c	eb000000	 bl          TWLWriteRegs

; 1274 : 
; 1275 :     // Create interrupt event
; 1276 :     pDevice->rgIntrEvents[EVENT_HOTDIE]=CreateEvent(NULL, FALSE, FALSE, NULL);

  00470	e3a03000	 mov         r3, #0
  00474	e3a02000	 mov         r2, #0
  00478	e3a01000	 mov         r1, #0
  0047c	e3a00000	 mov         r0, #0
  00480	eb000000	 bl          CreateEventW
  00484	e3500000	 cmp         r0, #0
  00488	e5850030	 str         r0, [r5, #0x30]

; 1277 :     if (pDevice->rgIntrEvents[EVENT_HOTDIE]== NULL)

  0048c	0affffb9	 beq         |$LN24@BCI_Initia|

; 1278 :         {
; 1279 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: BCI_Initialize: "
; 1280 :             L"Failed create interrupt Power (Hot die) event\r\n"
; 1281 :             ));
; 1282 :         
; 1283 :         goto cleanUp;
; 1284 :         }
; 1285 : 
; 1286 :     // Create interrupt event
; 1287 :     hHotDieTriggerEvent_Test=CreateEvent(NULL, FALSE, FALSE, HOTDIETESTSIGNAL_NAMED_EVENT);

  00490	e59f30cc	 ldr         r3, [pc, #0xCC]
  00494	e3a02000	 mov         r2, #0
  00498	e3a01000	 mov         r1, #0
  0049c	e3a00000	 mov         r0, #0
  004a0	eb000000	 bl          CreateEventW
  004a4	e59f30b4	 ldr         r3, [pc, #0xB4]
  004a8	e3500000	 cmp         r0, #0
  004ac	e5830000	 str         r0, [r3]

; 1288 :     if (hHotDieTriggerEvent_Test== NULL)

  004b0	0affffb0	 beq         |$LN24@BCI_Initia|

; 1289 :         {
; 1290 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: BCI_Initialize: "
; 1291 :             L"Failed create interrupt Power (Hot die) event \r\n"
; 1292 :             ));
; 1293 :        
; 1294 :         goto cleanUp;
; 1295 :         }
; 1296 :  
; 1297 :     // register for hot die interrupts
; 1298 :     if (!TWLInterruptInitialize(pDevice->hTwl, TWL_INTR_HOT_DIE, 
; 1299 :         pDevice->rgIntrEvents[EVENT_HOTDIE]))

  004b4	e5952030	 ldr         r2, [r5, #0x30]
  004b8	e5950018	 ldr         r0, [r5, #0x18]
  004bc	e59f1098	 ldr         r1, [pc, #0x98]
  004c0	eb000000	 bl          TWLInterruptInitialize
  004c4	e3500000	 cmp         r0, #0
  004c8	0affffaa	 beq         |$LN24@BCI_Initia|

; 1300 :         {
; 1301 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: RTC_Init: "
; 1302 :             L"Failed associate event with TWL POWER (Hot die) interrupt\r\n"
; 1303 :             ));
; 1304 :         goto cleanUp;
; 1305 :         }
; 1306 :      
; 1307 :     // Enable RTC event
; 1308 :     if (!TWLInterruptMask(pDevice->hTwl, TWL_INTR_HOT_DIE, FALSE))

  004cc	e5950018	 ldr         r0, [r5, #0x18]
  004d0	e59f1084	 ldr         r1, [pc, #0x84]
  004d4	e3a02000	 mov         r2, #0
  004d8	eb000000	 bl          TWLInterruptMask
  004dc	e3500000	 cmp         r0, #0
  004e0	0affffa4	 beq         |$LN24@BCI_Initia|

; 1309 :         {
; 1310 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: BCI_Initialize: "
; 1311 :             L"Failed to enable TWL POWER (Hot die)interrupt\r\n"
; 1312 :             ));
; 1313 :         goto cleanUp;
; 1314 :         }   
; 1315 : 
; 1316 : 
; 1317 :     // Start interrupt service thread
; 1318 :     pDevice->threadsExit = FALSE;
; 1319 :     pDevice->hIntrThread = CreateThread(
; 1320 :         NULL, 0, IntrThread, pDevice, 0,NULL
; 1321 :         );

  004e4	e59f206c	 ldr         r2, [pc, #0x6C]
  004e8	e3a0e000	 mov         lr, #0
  004ec	e1a03005	 mov         r3, r5
  004f0	e3a01000	 mov         r1, #0
  004f4	e3a00000	 mov         r0, #0
  004f8	e585e03c	 str         lr, [r5, #0x3C]
  004fc	e58de004	 str         lr, [sp, #4]
  00500	e58de000	 str         lr, [sp]
  00504	eb000000	 bl          CreateThread
  00508	e3500000	 cmp         r0, #0
  0050c	e5850024	 str         r0, [r5, #0x24]

; 1322 :     if (!pDevice->hIntrThread)

  00510	0affff98	 beq         |$LN24@BCI_Initia|

; 1323 :         {
; 1324 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: BCI_Initialize: "
; 1325 :             L"Failed create interrupt thread\r\n"
; 1326 :             ));
; 1327 :         goto cleanUp;
; 1328 :         }
; 1329 : 
; 1330 :     // Set thread priority
; 1331 :     pDevice->priority256 = 130;

  00514	e3a03082	 mov         r3, #0x82

; 1332 :     CeSetThreadPriority(pDevice->hIntrThread, pDevice->priority256); 

  00518	e3a01082	 mov         r1, #0x82
  0051c	e5853040	 str         r3, [r5, #0x40]
  00520	eb000000	 bl          CeSetThreadPriority
  00524	e3a01c15	 mov         r1, #0x15, 24

; 1333 : 
; 1334 :     // set threshold values to default
; 1335 :     pDevice->dwACCHGOVTH = _rgACCHGOVTH[ACCHGOVTH_DEFAULT];
; 1336 :     pDevice->dwVBATOVTH = _rgVBATOVTH[VBATOVTH_DEFAULT];
; 1337 :     pDevice->dwVBUSOVTH = _rgVBUSOVTH[VBUSOVTH_DEFAULT];
; 1338 : 
; 1339 :     // force update of battery state
; 1340 :     PulseEvent(pDevice->rgIntrEvents[EVENT_BCI]); 

  00528	e595002c	 ldr         r0, [r5, #0x2C]
  0052c	e381107c	 orr         r1, r1, #0x7C
  00530	e3a03c19	 mov         r3, #0x19, 24
  00534	e3a02c11	 mov         r2, #0x11, 24
  00538	e585104c	 str         r1, [r5, #0x4C]
  0053c	e3833064	 orr         r3, r3, #0x64
  00540	e38220c6	 orr         r2, r2, #0xC6
  00544	e3a01001	 mov         r1, #1
  00548	e5853044	 str         r3, [r5, #0x44]
  0054c	e5852048	 str         r2, [r5, #0x48]
  00550	eb000000	 bl          EventModify
  00554		 |$cleanUp$44154|

; 1341 : 
; 1342 :     bSuccess = TRUE;
; 1343 : 
; 1344 : cleanUp:
; 1345 : 
; 1346 :     if (bSuccess == FALSE) 

  00554	eaffff8a	 b           |$LN1@BCI_Initia|
  00558		 |$LN28@BCI_Initia|
  00558		 |$LN29@BCI_Initia|
  00558	00000000	 DCD         |IntrThread|
  0055c		 |$LN30@BCI_Initia|
  0055c	04005004	 DCD         0x4005004
  00560		 |$LN31@BCI_Initia|
  00560	00000000	 DCD         |hHotDieTriggerEvent_Test|
  00564		 |$LN32@BCI_Initia|
  00564	00000000	 DCD         |??_C@_1BK@IPMNAFIC@?$AAH?$AAo?$AAt?$AAD?$AAi?$AAe?$AAD?$AAe?$AAt?$AAe?$AAc?$AAt?$AA?$AA@|
  00568		 |$LN33@BCI_Initia|
  00568	00000000	 DCD         |??_C@_1BM@PDHJOICM@?$AAH?$AAo?$AAt?$AAD?$AAi?$AAe?$AAT?$AAe?$AAm?$AAp?$AAS?$AAe?$AAl?$AA?$AA@|
  0056c		 |$LN34@BCI_Initia|
  0056c	00000000	 DCD         |??_C@_1DA@LPGHDBOE@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAB?$AAu?$AAi?$AAl?$AAt?$AAI?$AAn?$AA?2?$AAB?$AAa?$AAt?$AAt?$AAe?$AAr?$AAy?$AA?$AA@|
  00570		 |$LN35@BCI_Initia|
  00570	03012013	 DCD         0x3012013
  00574		 |$LN36@BCI_Initia|
  00574	02012012	 DCD         0x2012012
  00578		 |$LN37@BCI_Initia|
  00578	01012011	 DCD         0x1012011
  0057c		 |$LN38@BCI_Initia|
  0057c	0700200f	 DCD         0x700200f
  00580		 |$LN39@BCI_Initia|
  00580	0600200e	 DCD         0x600200e
  00584		 |$LN40@BCI_Initia|
  00584	0500200d	 DCD         0x500200d
  00588		 |$LN41@BCI_Initia|
  00588	0400200c	 DCD         0x400200c
  0058c		 |$LN42@BCI_Initia|
  0058c	0300200b	 DCD         0x300200b
  00590		 |$LN43@BCI_Initia|
  00590	0200200a	 DCD         0x200200a
  00594		 |$LN44@BCI_Initia|
  00594	01005001	 DCD         0x1005001
  00598		 |$LN45@BCI_Initia|
  00598	00000000	 DCD         |??_C@_1BM@IEEIFNBO@?$AAS?$AAS?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AAP?$AAo?$AAw?$AAe?$AAr?$AA?$AA@|
  0059c		 |$M45509|

			 ENDP  ; |BCI_Initialize|

	END
