; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\KEYPAD\GPIO_KEYPAD\gpio_keypad.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1BG@LIOJCANL@?$AAN?$AAe?$AAx?$AAt?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BI@DEPDCBKF@?$AAF?$AAi?$AAr?$AAs?$AAt?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@CLLAOEB@?$AAD?$AAe?$AAb?$AAo?$AAu?$AAn?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@LFBEMINK@?$AAS?$AAa?$AAm?$AAp?$AAl?$AAe?$AAP?$AAe?$AAr?$AAi?$AAo?$AAd?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BG@GJAODHJH@?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAW?$AAa?$AAk?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BG@LIOJCANL@?$AAN?$AAe?$AAx?$AAt?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$AA@| DCB "N"
	DCB	0x0, "e", 0x0, "x", 0x0, "t", 0x0, "R", 0x0, "e", 0x0, "p"
	DCB	0x0, "e", 0x0, "a", 0x0, "t", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BI@DEPDCBKF@?$AAF?$AAi?$AAr?$AAs?$AAt?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$AA@| DCB "F"
	DCB	0x0, "i", 0x0, "r", 0x0, "s", 0x0, "t", 0x0, "R", 0x0, "e"
	DCB	0x0, "p", 0x0, "e", 0x0, "a", 0x0, "t", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@CLLAOEB@?$AAD?$AAe?$AAb?$AAo?$AAu?$AAn?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$AA@| DCB "D"
	DCB	0x0, "e", 0x0, "b", 0x0, "o", 0x0, "u", 0x0, "n", 0x0, "c"
	DCB	0x0, "e", 0x0, "T", 0x0, "i", 0x0, "m", 0x0, "e", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@LFBEMINK@?$AAS?$AAa?$AAm?$AAp?$AAl?$AAe?$AAP?$AAe?$AAr?$AAi?$AAo?$AAd?$AA?$AA@| DCB "S"
	DCB	0x0, "a", 0x0, "m", 0x0, "p", 0x0, "l", 0x0, "e", 0x0, "P"
	DCB	0x0, "e", 0x0, "r", 0x0, "i", 0x0, "o", 0x0, "d", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BG@GJAODHJH@?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAW?$AAa?$AAk?$AAe?$AA?$AA@| DCB "E"
	DCB	0x0, "n", 0x0, "a", 0x0, "b", 0x0, "l", 0x0, "e", 0x0, "W"
	DCB	0x0, "a", 0x0, "k", 0x0, "e", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@| DCB "P"
	DCB	0x0, "r", 0x0, "i", 0x0, "o", 0x0, "r", 0x0, "i", 0x0, "t"
	DCB	0x0, "y", 0x0, "2", 0x0, "5", 0x0, "6", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
|g_deviceRegParams| DCD |??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x0
	DCD	0x4
	DCD	0x64
	DCD	|??_C@_1BG@GJAODHJH@?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAW?$AAa?$AAk?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x4
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BK@LFBEMINK@?$AAS?$AAa?$AAm?$AAp?$AAl?$AAe?$AAP?$AAe?$AAr?$AAi?$AAo?$AAd?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x8
	DCD	0x4
	DCD	0x28
	DCD	|??_C@_1BK@CLLAOEB@?$AAD?$AAe?$AAb?$AAo?$AAu?$AAn?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0xc
	DCD	0x4
	DCD	0x50
	DCD	|??_C@_1BI@DEPDCBKF@?$AAF?$AAi?$AAr?$AAs?$AAt?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x10
	DCD	0x4
	DCD	0x1f4
	DCD	|??_C@_1BG@LIOJCANL@?$AAN?$AAe?$AAx?$AAt?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x14
	DCD	0x4
	DCD	0x7d
	EXPORT	|SetEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T44067| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44064|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M44065|

			 ENDP  ; |SetEvent|

	EXPORT	|KPD_Deinit|
	IMPORT	|LocalFree|
	IMPORT	|GPIOClose|
	IMPORT	|DeleteCriticalSection|
	IMPORT	|CloseHandle|
	IMPORT	|GPIOInterruptDisable|
	IMPORT	|g_nbKeys|
	IMPORT	|GPIOInterruptWakeUp|
	IMPORT	|g_nbWakeupVKeys|
	IMPORT	|WaitForSingleObject|
	IMPORT	|g_keypadVK|

  00000			 AREA	 |.pdata|, PDATA
|$T44088| DCD	|$LN23@KPD_Deinit|
	DCD	0x40004601
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\keypad\gpio_keypad\gpio_keypad.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KPD_Deinit| PROC

; 301  : {

  00000		 |$LN23@KPD_Deinit|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M44085|
  00004	e1b04000	 movs        r4, r0

; 302  :     int i;
; 303  :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 304  :     KPD_DEVICE *pDevice = (KPD_DEVICE*)context;
; 305  : 
; 306  : 
; 307  :     DEBUGMSG(ZONE_FUNCTION, (L"+KPD_Deinit(0x%08x)\r\n", context));
; 308  : 
; 309  :     // Check if we get correct context
; 310  :     if (pDevice == NULL) {

  0000c	0a00003c	 beq         |$cleanUp$43827|

; 311  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: KPD_Deinit: "
; 312  :             L"Incorrect context parameter\r\n"
; 313  :         ));
; 314  :         goto cleanUp;
; 315  :     }
; 316  : 
; 317  :     // Close interrupt thread
; 318  :     if (pDevice->hIntrThread != NULL) {

  00010	e5943034	 ldr         r3, [r4, #0x34]
  00014	e3530000	 cmp         r3, #0
  00018	0a000007	 beq         |$LN11@KPD_Deinit|

; 319  :         // Signal stop to thread
; 320  :         pDevice->intrThreadExit = TRUE;
; 321  :         // Set event to wake it
; 322  :         SetEvent(pDevice->hIntrEvent);

  0001c	e5940030	 ldr         r0, [r4, #0x30]
  00020	e3a03001	 mov         r3, #1
  00024	e3a01003	 mov         r1, #3
  00028	e5843038	 str         r3, [r4, #0x38]
  0002c	eb000000	 bl          EventModify

; 323  :         // Wait until thread exits
; 324  :         WaitForSingleObject(pDevice->hIntrThread, INFINITE);

  00030	e5940034	 ldr         r0, [r4, #0x34]
  00034	e3e01000	 mvn         r1, #0
  00038	eb000000	 bl          WaitForSingleObject
  0003c		 |$LN11@KPD_Deinit|

; 325  :     }
; 326  : 
; 327  :     // Disable wakeup
; 328  :     if (pDevice->enableWake != 0)

  0003c	e5943004	 ldr         r3, [r4, #4]
  00040	e3530000	 cmp         r3, #0
  00044	0a00000f	 beq         |$LN7@KPD_Deinit|

; 329  :     {
; 330  :        for (i=0;i<g_nbWakeupVKeys;i++)

  00048	e59f50c4	 ldr         r5, [pc, #0xC4]
  0004c	e3a06000	 mov         r6, #0
  00050	e5953000	 ldr         r3, [r5]
  00054	e3530000	 cmp         r3, #0
  00058	da00000a	 ble         |$LN7@KPD_Deinit|
  0005c		 |$LL9@KPD_Deinit|
  0005c	e5941044	 ldr         r1, [r4, #0x44]

; 331  :        {
; 332  :             GPIOInterruptWakeUp(pDevice->hGpio,pDevice->wakeupKeys[i].gpio,
; 333  :             pDevice->wakeupKeys[i].dwSysintr,FALSE);

  00060	e594003c	 ldr         r0, [r4, #0x3C]
  00064	e3a03000	 mov         r3, #0
  00068	e0812186	 add         r2, r1, r6, lsl #3
  0006c	e5922004	 ldr         r2, [r2, #4]
  00070	e7911186	 ldr         r1, [r1, +r6, lsl #3]
  00074	eb000000	 bl          GPIOInterruptWakeUp
  00078	e5953000	 ldr         r3, [r5]
  0007c	e2866001	 add         r6, r6, #1
  00080	e1560003	 cmp         r6, r3
  00084	bafffff4	 blt         |$LL9@KPD_Deinit|
  00088		 |$LN7@KPD_Deinit|

; 334  :        }
; 335  :     }
; 336  :     // Disable interrupts
; 337  :     for (i=0;i<g_nbKeys;i++)

  00088	e59f7080	 ldr         r7, [pc, #0x80]
  0008c	e3a05000	 mov         r5, #0
  00090	e5971000	 ldr         r1, [r7]
  00094	e3510000	 cmp         r1, #0
  00098	da00000c	 ble         |$LN4@KPD_Deinit|
  0009c	e59f6068	 ldr         r6, [pc, #0x68]
  000a0		 |$LL6@KPD_Deinit|

; 338  :     {
; 339  :         if (pDevice->keypadSysintr[i] != (DWORD) SYSINTR_UNDEFINED)

  000a0	e5943040	 ldr         r3, [r4, #0x40]
  000a4	e7932105	 ldr         r2, [r3, +r5, lsl #2]
  000a8	e3720001	 cmn         r2, #1
  000ac	0a000003	 beq         |$LN5@KPD_Deinit|

; 340  :         {
; 341  :             GPIOInterruptDisable(pDevice->hGpio,g_keypadVK[i].gpio,pDevice->keypadSysintr[i]);

  000b0	e5961000	 ldr         r1, [r6]
  000b4	e594003c	 ldr         r0, [r4, #0x3C]
  000b8	eb000000	 bl          GPIOInterruptDisable
  000bc	e5971000	 ldr         r1, [r7]
  000c0		 |$LN5@KPD_Deinit|
  000c0	e2855001	 add         r5, r5, #1
  000c4	e1550001	 cmp         r5, r1
  000c8	e2866008	 add         r6, r6, #8
  000cc	bafffff3	 blt         |$LL6@KPD_Deinit|
  000d0		 |$LN4@KPD_Deinit|

; 342  :         }
; 343  :     }
; 344  : 
; 345  :     // Close interrupt handler
; 346  :     if (pDevice->hIntrEvent != NULL) CloseHandle(pDevice->hIntrEvent);

  000d0	e5943030	 ldr         r3, [r4, #0x30]
  000d4	e3530000	 cmp         r3, #0
  000d8	11a00003	 movne       r0, r3
  000dc	1b000000	 blne        CloseHandle

; 347  : 
; 348  :     // Delete critical section
; 349  :     DeleteCriticalSection(&pDevice->cs);

  000e0	e2840018	 add         r0, r4, #0x18
  000e4	eb000000	 bl          DeleteCriticalSection

; 350  : 
; 351  :     if (pDevice->hGpio == NULL)

  000e8	e594303c	 ldr         r3, [r4, #0x3C]
  000ec	e3530000	 cmp         r3, #0

; 352  :     {
; 353  :         GPIOClose(pDevice->hGpio);

  000f0	03a00000	 moveq       r0, #0
  000f4	0b000000	 bleq        GPIOClose

; 354  :     }
; 355  :     // Free device structure
; 356  :     LocalFree(pDevice);

  000f8	e1a00004	 mov         r0, r4
  000fc	eb000000	 bl          LocalFree

; 357  : 
; 358  :     // Done
; 359  :     rc = TRUE;

  00100	e3a00001	 mov         r0, #1
  00104		 |$cleanUp$43827|

; 360  : 
; 361  : cleanUp:
; 362  :     DEBUGMSG(ZONE_FUNCTION, (L"-KPD_Deinit(rc = %d)\r\n", rc));
; 363  :     return rc;
; 364  : }

  00104	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00108	e12fff1e	 bx          lr
  0010c		 |$LN24@KPD_Deinit|
  0010c		 |$LN25@KPD_Deinit|
  0010c	00000000	 DCD         |g_keypadVK|
  00110		 |$LN26@KPD_Deinit|
  00110	00000000	 DCD         |g_nbKeys|
  00114		 |$LN27@KPD_Deinit|
  00114	00000000	 DCD         |g_nbWakeupVKeys|
  00118		 |$M44086|

			 ENDP  ; |KPD_Deinit|

	EXPORT	|KPD_Open|

  00000			 AREA	 |.pdata|, PDATA
|$T44102| DCD	|$LN5@KPD_Open|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KPD_Open| PROC

; 373  : {

  00000		 |$LN5@KPD_Open|
  00000		 |$M44099|

; 374  :     UNREFERENCED_PARAMETER(context);
; 375  :     UNREFERENCED_PARAMETER(accessCode);
; 376  :     UNREFERENCED_PARAMETER(shareMode);
; 377  :     return context;
; 378  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M44100|

			 ENDP  ; |KPD_Open|

	EXPORT	|KPD_Close|

  00000			 AREA	 |.pdata|, PDATA
|$T44111| DCD	|$LN5@KPD_Close|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KPD_Close| PROC

; 387  : {

  00000		 |$LN5@KPD_Close|
  00000		 |$M44108|

; 388  :     UNREFERENCED_PARAMETER(context);
; 389  :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 390  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M44109|

			 ENDP  ; |KPD_Close|

	EXPORT	|KPD_IOControl|

  00000			 AREA	 |.pdata|, PDATA
|$T44120| DCD	|$LN5@KPD_IOCont|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KPD_IOControl| PROC

; 401  : ) {

  00000		 |$LN5@KPD_IOCont|
  00000		 |$M44117|

; 402  :     UNREFERENCED_PARAMETER(context);
; 403  :     UNREFERENCED_PARAMETER(code);
; 404  :     UNREFERENCED_PARAMETER(pInBuffer);
; 405  :     UNREFERENCED_PARAMETER(inSize);
; 406  :     UNREFERENCED_PARAMETER(pOutBuffer);
; 407  :     UNREFERENCED_PARAMETER(outSize);
; 408  :     UNREFERENCED_PARAMETER(pOutSize);
; 409  :     DEBUGMSG(ZONE_INIT, (L"KPD_IOControl"));
; 410  :     return FALSE;

  00000	e3a00000	 mov         r0, #0

; 411  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M44118|

			 ENDP  ; |KPD_IOControl|

	IMPORT	|GPIOInterruptDone|
	IMPORT	|PowerPolicyNotify|
	IMPORT	|keybd_event|
	IMPORT	|GetTickCount|
	IMPORT	|GPIOGetBit|
	IMPORT	|Sleep|
	IMPORT	|g_keypadRepeat|
	IMPORT	|LocalAlloc|
	IMPORT	|g_keypadRemap|
	IMPORT	|memcpy|
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T44213| DCD	|$LN127@KPD_IntrTh|
	DCD	0x4001b702
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KPD_IntrThread| PROC

; 420  : {

  00000		 |$LN127@KPD_IntrTh|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd060	 sub         sp, sp, #0x60
  00008		 |$M44210|
  00008	e1a0b000	 mov         r11, r0
  0000c	e58db01c	 str         r11, [sp, #0x1C]

; 421  : //#define KEY_MASK    ((1<<g_nbKeys)-1)
; 422  :     int index;
; 423  :     KPD_DEVICE *pDevice = (KPD_DEVICE*)pContext;
; 424  :     DWORD timeout, time, ix;
; 425  :     DWORD change, mask;
; 426  :     UINT16 i;
; 427  :     USHORT data;
; 428  :     UINT16 ic=0;
; 429  :     DWORD vkState[VK_KEYS/DWORD_BITS], vkNewState[VK_KEYS/DWORD_BITS];
; 430  :     KEYPAD_REMAP_STATE *pRemapState = NULL;
; 431  :     KEYPAD_REPEAT_STATE *pRepeatState = NULL;
; 432  :     BOOL keyDown;
; 433  :     UCHAR vk=0;
; 434  : 
; 435  :     DEBUGMSG(ZONE_IST, (L"KPD - Start IntrThread\r\n"));
; 436  : 
; 437  :     // Init data
; 438  :     memset(vkState, 0, sizeof(vkState));

  00010	e3a07000	 mov         r7, #0
  00014	e3a03000	 mov         r3, #0
  00018	e3a02020	 mov         r2, #0x20
  0001c	e3a01000	 mov         r1, #0
  00020	e28d0040	 add         r0, sp, #0x40
  00024	e58d7010	 str         r7, [sp, #0x10]
  00028	e58d3004	 str         r3, [sp, #4]
  0002c	eb000000	 bl          memset

; 439  : 
; 440  :     // Initialize remap informations
; 441  :     if (g_keypadRemap.count > 0) {

  00030	e59fa694	 ldr         r10, [pc, #0x694]
  00034	e1da30b0	 ldrh        r3, [r10]
  00038	e3530000	 cmp         r3, #0
  0003c	0a000005	 beq         |$LN75@KPD_IntrTh|

; 442  :         // Allocate state structure for remap
; 443  :         if ((pRemapState = LocalAlloc(
; 444  :             LPTR, g_keypadRemap.count * sizeof(KEYPAD_REMAP_STATE)
; 445  :         ))  == NULL) {

  00040	e1a01203	 mov         r1, r3, lsl #4
  00044	e3a00040	 mov         r0, #0x40
  00048	eb000000	 bl          LocalAlloc
  0004c	e1b07000	 movs        r7, r0
  00050	e58d7010	 str         r7, [sp, #0x10]
  00054	0a000198	 beq         |$LN1@KPD_IntrTh|
  00058		 |$LN75@KPD_IntrTh|

; 446  :             DEBUGMSG(ZONE_ERROR, (L" KPD_IntrThread: "
; 447  :                 L"Failed allocate memory for virtual key remap\r\n"
; 448  :             ));
; 449  :             goto cleanUp;
; 450  :         }
; 451  :     }
; 452  : 
; 453  :     // Initialize repeat informations
; 454  :     if (g_keypadRepeat.count > 0) {

  00058	e59f9670	 ldr         r9, [pc, #0x670]
  0005c	e1d930b0	 ldrh        r3, [r9]
  00060	e3530000	 cmp         r3, #0
  00064	0a000006	 beq         |$LN73@KPD_IntrTh|

; 455  :         // Allocate state structure for remap
; 456  :         if ((pRepeatState = LocalAlloc(
; 457  :             LPTR, g_keypadRepeat.count * sizeof(KEYPAD_REPEAT_STATE)
; 458  :         ))  == NULL) {

  00068	e0833083	 add         r3, r3, r3, lsl #1
  0006c	e1a01103	 mov         r1, r3, lsl #2
  00070	e3a00040	 mov         r0, #0x40
  00074	eb000000	 bl          LocalAlloc
  00078	e1b05000	 movs        r5, r0
  0007c	e58d5004	 str         r5, [sp, #4]
  00080	0a000187	 beq         |$cleanUp$43901|
  00084		 |$LN73@KPD_IntrTh|

; 459  :             DEBUGMSG(ZONE_ERROR, (L" KPD_IntrThread: "
; 460  :                 L"Failed allocate memory for virtual key auto repeat\r\n"
; 461  :             ));
; 462  :             goto cleanUp;
; 463  :         }
; 464  :     }
; 465  : 
; 466  :     // Set delay to sample period
; 467  :     timeout = INFINITE;
; 468  : 
; 469  :     // Loop until we are not stopped...
; 470  :     while (!pDevice->intrThreadExit) {

  00084	e59b3038	 ldr         r3, [r11, #0x38]
  00088	e3e05000	 mvn         r5, #0
  0008c	e3530000	 cmp         r3, #0
  00090	1a000182	 bne         |$LN114@KPD_IntrTh|
  00094	e59f863c	 ldr         r8, [pc, #0x63C]
  00098		 |$LN124@KPD_IntrTh|

; 471  : 
; 472  :         if (pDevice->intrThreadExit) break;

  00098	e3530000	 cmp         r3, #0
  0009c	1a00017f	 bne         |$LN114@KPD_IntrTh|

; 473  : 
; 474  :         keyDown = FALSE;
; 475  :         // Wait for event
; 476  :         if (WaitForSingleObject(pDevice->hIntrEvent, timeout) == WAIT_OBJECT_0)

  000a0	e59b0030	 ldr         r0, [r11, #0x30]
  000a4	e1a01005	 mov         r1, r5
  000a8	eb000000	 bl          WaitForSingleObject
  000ac	e3500000	 cmp         r0, #0
  000b0	1a000007	 bne         |$LN67@KPD_IntrTh|

; 477  :         {
; 478  :             //interrupt occured.
; 479  :             //debounce
; 480  :             while (WaitForSingleObject(pDevice->hIntrEvent, pDevice->debounceTime) == WAIT_OBJECT_0)

  000b4	ea000001	 b           |$LN118@KPD_IntrTh|
  000b8		 |$LL68@KPD_IntrTh|

; 481  :             {
; 482  :                 Sleep(1);

  000b8	e3a00001	 mov         r0, #1
  000bc	eb000000	 bl          Sleep
  000c0		 |$LN118@KPD_IntrTh|
  000c0	e59b100c	 ldr         r1, [r11, #0xC]
  000c4	e59b0030	 ldr         r0, [r11, #0x30]
  000c8	eb000000	 bl          WaitForSingleObject
  000cc	e3500000	 cmp         r0, #0
  000d0	0afffff8	 beq         |$LL68@KPD_IntrTh|
  000d4		 |$LN67@KPD_IntrTh|

; 483  :             }
; 484  :         }        
; 485  : 
; 486  :         data = 0;
; 487  :         for (index= g_nbKeys-1;index>=0;index--)

  000d4	e5984000	 ldr         r4, [r8]
  000d8	e3a06000	 mov         r6, #0
  000dc	e2545001	 subs        r5, r4, #1
  000e0	4a00000e	 bmi         |$LN64@KPD_IntrTh|
  000e4	e59f35e8	 ldr         r3, [pc, #0x5E8]
  000e8	e0834185	 add         r4, r3, r5, lsl #3
  000ec		 |$LL66@KPD_IntrTh|

; 488  :         {
; 489  :             data = data << 1;          
; 490  :             data |= (GPIOGetBit(pDevice->hGpio,g_keypadVK[index].gpio)) ? 1 : 0;              

  000ec	e5941000	 ldr         r1, [r4]
  000f0	e59b003c	 ldr         r0, [r11, #0x3C]
  000f4	eb000000	 bl          GPIOGetBit
  000f8	e3500000	 cmp         r0, #0
  000fc	13a03001	 movne       r3, #1
  00100	03a03000	 moveq       r3, #0
  00104	e1833086	 orr         r3, r3, r6, lsl #1
  00108	e1a06803	 mov         r6, r3, lsl #16
  0010c	e1a06826	 mov         r6, r6, lsr #16
  00110	e2555001	 subs        r5, r5, #1
  00114	e2444008	 sub         r4, r4, #8
  00118	5afffff3	 bpl         |$LL66@KPD_IntrTh|

; 483  :             }
; 484  :         }        
; 485  : 
; 486  :         data = 0;
; 487  :         for (index= g_nbKeys-1;index>=0;index--)

  0011c	e5984000	 ldr         r4, [r8]
  00120		 |$LN64@KPD_IntrTh|

; 491  :         }        
; 492  :         //--------------------------------------------------------------
; 493  :         // Convert physical state to virtual keys state
; 494  :         //--------------------------------------------------------------
; 495  :         // Get new state for virtual key table
; 496  :         memset(vkNewState, 0, sizeof(vkNewState));

  00120	e3a02020	 mov         r2, #0x20
  00124	e3a01000	 mov         r1, #0
  00128	e28d0020	 add         r0, sp, #0x20
  0012c	eb000000	 bl          memset

; 497  :         keyDown = FALSE;

  00130	e3a08000	 mov         r8, #0
  00134	e58d8000	 str         r8, [sp]

; 498  : 
; 499  :         for (i = 0; i < g_nbKeys; i++) 

  00138	e3a0e000	 mov         lr, #0
  0013c	e3540000	 cmp         r4, #0
  00140	da000018	 ble         |$LN61@KPD_IntrTh|
  00144	e59fa588	 ldr         r10, [pc, #0x588]
  00148	e3a03000	 mov         r3, #0
  0014c	e3a02001	 mov         r2, #1
  00150	e3a09001	 mov         r9, #1
  00154		 |$LL63@KPD_IntrTh|

; 500  :         {
; 501  :             if ((data & (1 << i)) == 0) 

  00154	e1160312	 tst         r6, r2, lsl r3
  00158	1a00000a	 bne         |$LN62@KPD_IntrTh|

; 502  :             {
; 503  :                 vk = g_keypadVK[i].vkey;

  0015c	e08a3183	 add         r3, r10, r3, lsl #3
  00160	e5d31004	 ldrb        r1, [r3, #4]

; 504  :                 vkNewState[vk >> 5] |= 1 << (vk & 0x1F);
; 505  :                 keyDown = TRUE;

  00164	e3a03001	 mov         r3, #1
  00168	e58d3000	 str         r3, [sp]
  0016c	e1a032a1	 mov         r3, r1, lsr #5
  00170	e28d0020	 add         r0, sp, #0x20
  00174	e7b02103	 ldr         r2, [r0, +r3, lsl #2]!
  00178	e201301f	 and         r3, r1, #0x1F
  0017c	e1823319	 orr         r3, r2, r9, lsl r3
  00180	e3a02001	 mov         r2, #1
  00184	e5803000	 str         r3, [r0]
  00188		 |$LN62@KPD_IntrTh|
  00188	e28e3001	 add         r3, lr, #1
  0018c	e1a0e803	 mov         lr, r3, lsl #16
  00190	e1a0e82e	 mov         lr, lr, lsr #16
  00194	e1a0300e	 mov         r3, lr
  00198	e15e0004	 cmp         lr, r4
  0019c	baffffec	 blt         |$LL63@KPD_IntrTh|
  001a0	e59f9528	 ldr         r9, [pc, #0x528]
  001a4	e59fa520	 ldr         r10, [pc, #0x520]
  001a8		 |$LN61@KPD_IntrTh|

; 506  :                 DEBUGMSG(ZONE_INFO, (L"keyDown = TRUE \r\n"));
; 507  :             }            
; 508  :         }
; 509  : 
; 510  :         //--------------------------------------------------------------
; 511  :         // Remap multi virtual keys to final virtual key
; 512  :         //--------------------------------------------------------------
; 513  :         time = GetTickCount();

  001a8	eb000000	 bl          GetTickCount

; 514  :         for (ix = 0; ix < g_keypadRemap.count; ix++) {

  001ac	e1da30b0	 ldrh        r3, [r10]
  001b0	e1a01000	 mov         r1, r0
  001b4	e3a0a000	 mov         r10, #0
  001b8	e3530000	 cmp         r3, #0
  001bc	e58d100c	 str         r1, [sp, #0xC]
  001c0	e58da008	 str         r10, [sp, #8]
  001c4	0a000099	 beq         |$LN57@KPD_IntrTh|
  001c8	e1a04007	 mov         r4, r7
  001cc	e59f74f8	 ldr         r7, [pc, #0x4F8]
  001d0	e58d4014	 str         r4, [sp, #0x14]
  001d4		 |$LL59@KPD_IntrTh|
  001d4	e5973004	 ldr         r3, [r7, #4]

; 515  :             const KEYPAD_REMAP_ITEM *pItem = &g_keypadRemap.pItem[ix];
; 516  :             KEYPAD_REMAP_STATE *pState = &pRemapState[ix];
; 517  :             DWORD state = 0;

  001d8	e3a0b000	 mov         r11, #0

; 518  :             USHORT down = 0;

  001dc	e3a05000	 mov         r5, #0
  001e0	e083918a	 add         r9, r3, r10, lsl #3

; 519  : 
; 520  :             // Count number of keys down & save down/up state
; 521  :             for (i = 0; i < pItem->keys; i ++) {

  001e4	e5d93001	 ldrb        r3, [r9, #1]
  001e8	e58d9018	 str         r9, [sp, #0x18]
  001ec	e3a0e000	 mov         lr, #0
  001f0	e1b06003	 movs        r6, r3
  001f4	0a000018	 beq         |$LN54@KPD_IntrTh|
  001f8	e5998004	 ldr         r8, [r9, #4]
  001fc	e28d9020	 add         r9, sp, #0x20
  00200	e3a07000	 mov         r7, #0
  00204	e3a0a001	 mov         r10, #1
  00208	e3a04001	 mov         r4, #1
  0020c		 |$LL56@KPD_IntrTh|

; 522  :                 vk = pItem->pVKeys[i];

  0020c	e7d8100e	 ldrb        r1, [r8, +lr]

; 523  :                 if ((vkNewState[vk >> 5] & (1 << (vk & 0x1F))) != 0) {

  00210	e1a032a1	 mov         r3, r1, lsr #5
  00214	e7992103	 ldr         r2, [r9, +r3, lsl #2]
  00218	e201301f	 and         r3, r1, #0x1F
  0021c	e1120314	 tst         r2, r4, lsl r3

; 524  :                     state |= 1 << i;
; 525  :                     down++;

  00220	12853001	 addne       r3, r5, #1
  00224	11a05803	 movne       r5, r3, lsl #16
  00228	e2873001	 add         r3, r7, #1
  0022c	118bbe1a	 orrne       r11, r11, r10, lsl lr
  00230	e1a0e803	 mov         lr, r3, lsl #16
  00234	e1a0e82e	 mov         lr, lr, lsr #16
  00238	11a05825	 movne       r5, r5, lsr #16
  0023c	e1a0700e	 mov         r7, lr
  00240	e15e0006	 cmp         lr, r6
  00244	3afffff0	 bcc         |$LL56@KPD_IntrTh|

; 589  :             }
; 590  :             // Save key state
; 591  :             pState->state = state;

  00248	e59d4014	 ldr         r4, [sp, #0x14]
  0024c	e59d9018	 ldr         r9, [sp, #0x18]
  00250	e59da008	 ldr         r10, [sp, #8]
  00254	e59d100c	 ldr         r1, [sp, #0xC]
  00258	e59f746c	 ldr         r7, [pc, #0x46C]
  0025c		 |$LN54@KPD_IntrTh|

; 526  :                 }
; 527  :             }
; 528  :             // Depending on number of keys down
; 529  :             if (down >= pItem->keys && pItem->keys > 1) {

  0025c	e1550006	 cmp         r5, r6
  00260	3a000022	 bcc         |$LN52@KPD_IntrTh|
  00264	e3560001	 cmp         r6, #1
  00268	9a000020	 bls         |$LN52@KPD_IntrTh|

; 530  :                 // Clear all mapping keys
; 531  :                 for (i = 0; i < pItem->keys; i++) {

  0026c	e3a01000	 mov         r1, #0
  00270	e3560000	 cmp         r6, #0
  00274	0a000010	 beq         |$LN49@KPD_IntrTh|
  00278	e5995004	 ldr         r5, [r9, #4]
  0027c	e3a03000	 mov         r3, #0
  00280	e3a07001	 mov         r7, #1
  00284		 |$LL51@KPD_IntrTh|

; 532  :                     vk = pItem->pVKeys[i];

  00284	e7d11005	 ldrb        r1, [r1, +r5]

; 533  :                     vkNewState[vk >> 5] &= ~(1 << (vk & 0x1F));

  00288	e2830001	 add         r0, r3, #1
  0028c	e28de020	 add         lr, sp, #0x20
  00290	e1a032a1	 mov         r3, r1, lsr #5
  00294	e7be2103	 ldr         r2, [lr, +r3, lsl #2]!
  00298	e201301f	 and         r3, r1, #0x1F
  0029c	e1a01800	 mov         r1, r0, lsl #16
  002a0	e1a01821	 mov         r1, r1, lsr #16
  002a4	e1c23317	 bic         r3, r2, r7, lsl r3
  002a8	e1510006	 cmp         r1, r6
  002ac	e58e3000	 str         r3, [lr]
  002b0	e1a03001	 mov         r3, r1
  002b4	3afffff2	 bcc         |$LL51@KPD_IntrTh|
  002b8	e59f740c	 ldr         r7, [pc, #0x40C]
  002bc		 |$LN49@KPD_IntrTh|

; 534  :                 }
; 535  :                 // All keys are down set final key
; 536  :                 vk = pItem->vkey;

  002bc	e5d91000	 ldrb        r1, [r9]

; 537  :                 vkNewState[vk >> 5] |= 1 << (vk & 0x1F);
; 538  :                 DEBUGMSG(ZONE_IST, (L" KPD_IntrThread: "
; 539  :                     L"Mapped vkey: 0x%x\r\n", vk
; 540  :                 ));
; 541  : 
; 542  :                 // Clear remap pending flag
; 543  :                 pState->pending = FALSE;

  002c0	e3a03000	 mov         r3, #0
  002c4	e5843000	 str         r3, [r4]
  002c8	e1a032a1	 mov         r3, r1, lsr #5
  002cc	e28d0020	 add         r0, sp, #0x20
  002d0	e7b02103	 ldr         r2, [r0, +r3, lsl #2]!
  002d4	e201301f	 and         r3, r1, #0x1F

; 544  :                 // Set remap processing flag
; 545  :                 pState->remapped = TRUE;

  002d8	e3a01001	 mov         r1, #1
  002dc	e5841004	 str         r1, [r4, #4]
  002e0		 |$LN119@KPD_IntrTh|
  002e0	e3a01001	 mov         r1, #1
  002e4	e1823311	 orr         r3, r2, r1, lsl r3
  002e8	e5803000	 str         r3, [r0]
  002ec	ea000044	 b           |$LN41@KPD_IntrTh|
  002f0		 |$LN52@KPD_IntrTh|

; 546  :             } else if (down > 0) {

  002f0	e3550000	 cmp         r5, #0
  002f4	0a00001f	 beq         |$LN47@KPD_IntrTh|

; 547  :                 // If already remapping or remapping is not pending
; 548  :                 // or pending time expired
; 549  :                 if (pState->remapped || !pState->pending ||
; 550  :                     (INT32)(time - pState->time) < 0 ) {

  002f8	e5943004	 ldr         r3, [r4, #4]
  002fc	e1b02003	 movs        r2, r3
  00300	1a000011	 bne         |$LN45@KPD_IntrTh|
  00304	e5943000	 ldr         r3, [r4]
  00308	e3530000	 cmp         r3, #0
  0030c	0a000011	 beq         |$LN112@KPD_IntrTh|
  00310	e5943008	 ldr         r3, [r4, #8]
  00314	e0513003	 subs        r3, r1, r3
  00318	4a00000b	 bmi         |$LN45@KPD_IntrTh|

; 555  :                     }
; 556  :                     /*
; 557  :                     // Clear all mapping keys
; 558  :                     for (i = 0; i < pItem->keys; i++) {
; 559  :                         vk = pItem->pVKeys[i];
; 560  :                         vkNewState[vk >> 5] &= ~(1 << (vk & 0x1F));
; 561  :                     }
; 562  :                     */
; 563  :                 } else if (
; 564  :                     pItem->keys == 1 && (INT32)(time - pState->time) >= 0
; 565  :                 ) {

  0031c	e3560001	 cmp         r6, #1
  00320	1a000037	 bne         |$LN41@KPD_IntrTh|

; 566  :                     // This is press and hold key
; 567  :                    DEBUGMSG(ZONE_IST, (L" KPD_IntrThread: "
; 568  :                         L"Mapped press and hold vkey: 0x%x\r\n", vk
; 569  :                     ));
; 570  :                     vk = pItem->vkey;

  00324	e5d91000	 ldrb        r1, [r9]

; 571  :                     vkNewState[vk >> 5] |= 1 << (vk & 0x1F);
; 572  :                     keyDown = TRUE;

  00328	e3a03001	 mov         r3, #1
  0032c	e58d3000	 str         r3, [sp]
  00330	e1a032a1	 mov         r3, r1, lsr #5
  00334	e28d0020	 add         r0, sp, #0x20
  00338	e7b02103	 ldr         r2, [r0, +r3, lsl #2]!
  0033c	e201301f	 and         r3, r1, #0x1F

; 573  :                     pState->pending = FALSE;

  00340	e3a01000	 mov         r1, #0
  00344	e5841000	 str         r1, [r4]
  00348	eaffffe4	 b           |$LN119@KPD_IntrTh|
  0034c		 |$LN45@KPD_IntrTh|

; 551  :                     // If we are not pending and not already remapping, start
; 552  :                     if (!pState->pending && !pState->remapped) {

  0034c	e5943000	 ldr         r3, [r4]
  00350	e3530000	 cmp         r3, #0
  00354	1a00002a	 bne         |$LN41@KPD_IntrTh|
  00358		 |$LN112@KPD_IntrTh|
  00358	e3520000	 cmp         r2, #0
  0035c	1a000028	 bne         |$LN41@KPD_IntrTh|

; 553  :                         pState->pending = TRUE;

  00360	e3a03001	 mov         r3, #1
  00364	e5843000	 str         r3, [r4]

; 554  :                         pState->time = time + pItem->delay;

  00368	e1d930b2	 ldrh        r3, [r9, #2]
  0036c	e0833001	 add         r3, r3, r1
  00370	e5843008	 str         r3, [r4, #8]

; 574  :                 }
; 575  :             } else {

  00374	ea000022	 b           |$LN41@KPD_IntrTh|
  00378		 |$LN47@KPD_IntrTh|

; 576  :                 // All keys are up, if remapping was pending set keys
; 577  :                 if (pState->pending) {

  00378	e5943000	 ldr         r3, [r4]
  0037c	e3530000	 cmp         r3, #0
  00380	0a00001d	 beq         |$LN116@KPD_IntrTh|

; 578  :                     for (i = 0; i < pItem->keys; i++) {

  00384	e3a02000	 mov         r2, #0
  00388	e3560000	 cmp         r6, #0
  0038c	0a000017	 beq         |$LN37@KPD_IntrTh|
  00390	e594500c	 ldr         r5, [r4, #0xC]
  00394	e3a0e000	 mov         lr, #0
  00398	e3a07001	 mov         r7, #1
  0039c	e3a0a001	 mov         r10, #1
  003a0		 |$LL39@KPD_IntrTh|

; 579  :                         if ((pState->state & (1 << i)) != 0) {

  003a0	e1150217	 tst         r5, r7, lsl r2
  003a4	0a000009	 beq         |$LN38@KPD_IntrTh|

; 580  :                             vk = pItem->pVKeys[i];

  003a8	e5993004	 ldr         r3, [r9, #4]

; 581  :                             vkNewState[vk >> 5] |= 1 << (vk & 0x1F);
; 582  :                             DEBUGMSG(ZONE_INFO, (L"keyDown = TRUE 2\r\n"));
; 583  :                             keyDown = TRUE;

  003ac	e3a01001	 mov         r1, #1
  003b0	e58d1000	 str         r1, [sp]
  003b4	e7d21003	 ldrb        r1, [r2, +r3]
  003b8	e28d0020	 add         r0, sp, #0x20
  003bc	e1a032a1	 mov         r3, r1, lsr #5
  003c0	e7b02103	 ldr         r2, [r0, +r3, lsl #2]!
  003c4	e201301f	 and         r3, r1, #0x1F
  003c8	e182331a	 orr         r3, r2, r10, lsl r3
  003cc	e5803000	 str         r3, [r0]
  003d0		 |$LN38@KPD_IntrTh|
  003d0	e28e3001	 add         r3, lr, #1
  003d4	e1a02803	 mov         r2, r3, lsl #16
  003d8	e1a02822	 mov         r2, r2, lsr #16
  003dc	e1a0e002	 mov         lr, r2
  003e0	e1520006	 cmp         r2, r6
  003e4	3affffed	 bcc         |$LL39@KPD_IntrTh|

; 589  :             }
; 590  :             // Save key state
; 591  :             pState->state = state;

  003e8	e59da008	 ldr         r10, [sp, #8]
  003ec	e59f72d8	 ldr         r7, [pc, #0x2D8]
  003f0		 |$LN37@KPD_IntrTh|
  003f0	e3a03000	 mov         r3, #0
  003f4	e5843000	 str         r3, [r4]
  003f8	ea000000	 b           |$LN40@KPD_IntrTh|
  003fc		 |$LN116@KPD_IntrTh|

; 497  :         keyDown = FALSE;

  003fc	e3a03000	 mov         r3, #0
  00400		 |$LN40@KPD_IntrTh|

; 584  :                         }
; 585  :                     }
; 586  :                     pState->pending = FALSE;
; 587  :                 }
; 588  :                 pState->remapped = FALSE;

  00400	e5843004	 str         r3, [r4, #4]
  00404		 |$LN41@KPD_IntrTh|

; 589  :             }
; 590  :             // Save key state
; 591  :             pState->state = state;

  00404	e584b00c	 str         r11, [r4, #0xC]
  00408	e1d730b0	 ldrh        r3, [r7]
  0040c	e28aa001	 add         r10, r10, #1
  00410	e2844010	 add         r4, r4, #0x10
  00414	e59d100c	 ldr         r1, [sp, #0xC]
  00418	e15a0003	 cmp         r10, r3
  0041c	e58da008	 str         r10, [sp, #8]
  00420	e58d4014	 str         r4, [sp, #0x14]
  00424	3affff6a	 bcc         |$LL59@KPD_IntrTh|
  00428	e59db01c	 ldr         r11, [sp, #0x1C]
  0042c	e59f929c	 ldr         r9, [pc, #0x29C]
  00430		 |$LN57@KPD_IntrTh|

; 592  :         }
; 593  : 
; 594  :         //--------------------------------------------------------------
; 595  :         // Find pressed/released keys
; 596  :         //--------------------------------------------------------------
; 597  :         for (ic = 0, vk = 0; ic < VK_KEYS/DWORD_BITS; ic++) {

  00430	e3a03000	 mov         r3, #0
  00434	e3a04000	 mov         r4, #0
  00438	e3a08000	 mov         r8, #0
  0043c	e28d2020	 add         r2, sp, #0x20
  00440	e28d1040	 add         r1, sp, #0x40
  00444		 |$LL35@KPD_IntrTh|

; 598  :             change = vkState[ic] ^ vkNewState[ic];

  00444	e7926103	 ldr         r6, [r2, +r3, lsl #2]
  00448	e7913103	 ldr         r3, [r1, +r3, lsl #2]
  0044c	e0337006	 eors        r7, r3, r6

; 599  :             if (change == 0) {
; 600  :                 vk += DWORD_BITS;

  00450	02843020	 addeq       r3, r4, #0x20
  00454	020340ff	 andeq       r4, r3, #0xFF
  00458	0a00001a	 beq         |$LN34@KPD_IntrTh|

; 601  :             } else for (mask = 1; mask != 0; mask <<= 1, vk++) {

  0045c	e3a05001	 mov         r5, #1
  00460		 |$LL30@KPD_IntrTh|

; 602  :                 // Check for change
; 603  :                 if ((change & mask) != 0) {

  00460	e1150007	 tst         r5, r7
  00464	0a000011	 beq         |$LN29@KPD_IntrTh|

; 604  :                     if ((vkNewState[ic] & mask) != 0)

  00468	e1160005	 tst         r6, r5

; 605  :                     {
; 606  :                         DEBUGMSG(ZONE_IST, (L" KPD_IntrThread: Key Down: 0x%x\r\n", vk ));
; 607  :                         keybd_event(vk, 0, 0, 0);

  0046c	e3a03000	 mov         r3, #0
  00470	e3a01000	 mov         r1, #0
  00474	e1a00004	 mov         r0, r4
  00478	0a00000a	 beq         |$LN26@KPD_IntrTh|
  0047c	e3a02000	 mov         r2, #0
  00480	eb000000	 bl          keybd_event

; 608  : 
; 609  :                         //Notify for power manager events
; 610  :                         if(vk == VK_TPOWER)

  00484	e3540081	 cmp         r4, #0x81

; 611  :                         {
; 612  :                             PowerPolicyNotify(PPN_POWERBUTTONPRESSED, 0);

  00488	e3a01000	 mov         r1, #0
  0048c	1a000002	 bne         |$LN25@KPD_IntrTh|
  00490	e3a00004	 mov         r0, #4

; 613  :                         }
; 614  :                         else
; 615  :                         {
; 616  :                             //Application button pressed
; 617  :                             //PM uses this to indicate user activity and reset timers
; 618  :                             PowerPolicyNotify(PPN_APPBUTTONPRESSED, 0);

  00494	eb000000	 bl          PowerPolicyNotify

; 619  :                         }
; 620  : 
; 621  :                         if(vk == VK_TSTAR)
; 622  :                         {
; 623  :                             DEBUGMSG(ZONE_IST, (L"VK_TSTAR\r\n"));
; 624  :                         }
; 625  :                     }
; 626  :                     else

  00498	ea000004	 b           |$LN29@KPD_IntrTh|
  0049c		 |$LN25@KPD_IntrTh|

; 613  :                         }
; 614  :                         else
; 615  :                         {
; 616  :                             //Application button pressed
; 617  :                             //PM uses this to indicate user activity and reset timers
; 618  :                             PowerPolicyNotify(PPN_APPBUTTONPRESSED, 0);

  0049c	e3a00006	 mov         r0, #6
  004a0	eb000000	 bl          PowerPolicyNotify

; 619  :                         }
; 620  : 
; 621  :                         if(vk == VK_TSTAR)
; 622  :                         {
; 623  :                             DEBUGMSG(ZONE_IST, (L"VK_TSTAR\r\n"));
; 624  :                         }
; 625  :                     }
; 626  :                     else

  004a4	ea000001	 b           |$LN29@KPD_IntrTh|
  004a8		 |$LN26@KPD_IntrTh|

; 627  :                     {
; 628  :                         DEBUGMSG(ZONE_IST, (L" KPD_IntrThread: Key Up: 0x%x\r\n", vk ));
; 629  :                         keybd_event(vk, 0, KEYEVENTF_KEYUP, 0);

  004a8	e3a02002	 mov         r2, #2
  004ac	eb000000	 bl          keybd_event
  004b0		 |$LN29@KPD_IntrTh|
  004b0	e2843001	 add         r3, r4, #1
  004b4	e20340ff	 and         r4, r3, #0xFF
  004b8	e1b05085	 movs        r5, r5, lsl #1
  004bc	1affffe7	 bne         |$LL30@KPD_IntrTh|
  004c0	e28d2020	 add         r2, sp, #0x20
  004c4	e28d1040	 add         r1, sp, #0x40
  004c8		 |$LN34@KPD_IntrTh|
  004c8	e2883001	 add         r3, r8, #1
  004cc	e1a03803	 mov         r3, r3, lsl #16
  004d0	e1a03823	 mov         r3, r3, lsr #16
  004d4	e1a08003	 mov         r8, r3
  004d8	e3530008	 cmp         r3, #8
  004dc	3affffd8	 bcc         |$LL35@KPD_IntrTh|

; 630  :                     }
; 631  :                 }
; 632  :             }
; 633  :         }
; 634  : 
; 635  :         //--------------------------------------------------------------
; 636  :         //  Check for auto-repeat keys
; 637  :         //--------------------------------------------------------------
; 638  :         for (ix = 0; ix < g_keypadRepeat.count; ix++) {

  004e0	e1d930b0	 ldrh        r3, [r9]
  004e4	e3a09000	 mov         r9, #0
  004e8	e3530000	 cmp         r3, #0
  004ec	0a000051	 beq         |$LN19@KPD_IntrTh|
  004f0	e59d3004	 ldr         r3, [sp, #4]
  004f4	e59da00c	 ldr         r10, [sp, #0xC]
  004f8	e59f51d0	 ldr         r5, [pc, #0x1D0]
  004fc	e1a04003	 mov         r4, r3
  00500	e3a08000	 mov         r8, #0
  00504	e3a00001	 mov         r0, #1
  00508		 |$LL21@KPD_IntrTh|
  00508	e5953004	 ldr         r3, [r5, #4]

; 639  :             const KEYPAD_REPEAT_ITEM *pItem = &g_keypadRepeat.pItem[ix];
; 640  :             const KEYPAD_REPEAT_BLOCK *pBlock = pItem->pBlock;
; 641  :             KEYPAD_REPEAT_STATE *pState = &pRepeatState[ix];
; 642  :             DWORD delay;
; 643  :             UCHAR vkBlock;
; 644  : 
; 645  :             vk = pItem->vkey;
; 646  :             if ((vkNewState[vk >> 5] & (1 << (vk & 0x1F))) != 0) {

  0050c	e28d2020	 add         r2, sp, #0x20
  00510	e0886003	 add         r6, r8, r3
  00514	e5d67000	 ldrb        r7, [r6]
  00518	e596100c	 ldr         r1, [r6, #0xC]
  0051c	e1a032a7	 mov         r3, r7, lsr #5
  00520	e7922103	 ldr         r2, [r2, +r3, lsl #2]
  00524	e207301f	 and         r3, r7, #0x1F
  00528	e1120310	 tst         r2, r0, lsl r3
  0052c	0a000038	 beq         |$LN18@KPD_IntrTh|

; 647  :                 if (!pState->pending) {

  00530	e5943000	 ldr         r3, [r4]
  00534	e3530000	 cmp         r3, #0
  00538	1a000008	 bne         |$LN17@KPD_IntrTh|

; 648  :                     // Key was just pressed
; 649  :                     delay = pItem->firstDelay;

  0053c	e1d630b2	 ldrh        r3, [r6, #2]
  00540	e3530000	 cmp         r3, #0

; 650  :                     if (delay == 0) delay = pDevice->firstRepeat;

  00544	059b3010	 ldreq       r3, [r11, #0x10]

; 651  :                     pState->time = time + delay;

  00548	e083300a	 add         r3, r3, r10
  0054c	e5843004	 str         r3, [r4, #4]

; 652  :                     pState->pending = TRUE;

  00550	e3a03001	 mov         r3, #1
  00554	e5843000	 str         r3, [r4]

; 653  :                     pState->blocked = FALSE;

  00558	e3a03000	 mov         r3, #0
  0055c	ea00002e	 b           |$LN121@KPD_IntrTh|
  00560		 |$LN17@KPD_IntrTh|

; 654  :                 } else if ((INT32)(time - pState->time) >= 0) {

  00560	e5943004	 ldr         r3, [r4, #4]
  00564	e05a3003	 subs        r3, r10, r3
  00568	4a00002c	 bmi         |$LN20@KPD_IntrTh|

; 655  :                     // Check if any blocking keys are pressed
; 656  :                     if (pBlock != 0) {

  0056c	e3510000	 cmp         r1, #0
  00570	0a000015	 beq         |$LN10@KPD_IntrTh|

; 657  :                         for (i = 0; i < pBlock->count; i++) {

  00574	e5d13000	 ldrb        r3, [r1]
  00578	e3a00000	 mov         r0, #0
  0057c	e1b05003	 movs        r5, r3
  00580	0a000010	 beq         |$LN115@KPD_IntrTh|
  00584	e591e004	 ldr         lr, [r1, #4]
  00588		 |$LL12@KPD_IntrTh|

; 658  :                             vkBlock = pBlock->pVKey[i];

  00588	e7d0100e	 ldrb        r1, [r0, +lr]

; 659  :                             if ((
; 660  :                                 vkNewState[vkBlock >> 5] &
; 661  :                                 (1 << (vkBlock & 0x1F))
; 662  :                             ) != 0) {

  0058c	e28d2020	 add         r2, sp, #0x20
  00590	e1a032a1	 mov         r3, r1, lsr #5
  00594	e7922103	 ldr         r2, [r2, +r3, lsl #2]
  00598	e201301f	 and         r3, r1, #0x1F
  0059c	e3a01001	 mov         r1, #1
  005a0	e1120311	 tst         r2, r1, lsl r3
  005a4	1a000005	 bne         |$LN98@KPD_IntrTh|
  005a8	e2803001	 add         r3, r0, #1
  005ac	e1a00803	 mov         r0, r3, lsl #16
  005b0	e1a00820	 mov         r0, r0, lsr #16
  005b4	e1500005	 cmp         r0, r5
  005b8	3afffff2	 bcc         |$LL12@KPD_IntrTh|

; 471  : 
; 472  :         if (pDevice->intrThreadExit) break;

  005bc	ea000001	 b           |$LN115@KPD_IntrTh|
  005c0		 |$LN98@KPD_IntrTh|

; 663  :                                 pState->blocked = TRUE;

  005c0	e3a03001	 mov         r3, #1
  005c4	e5843008	 str         r3, [r4, #8]
  005c8		 |$LN115@KPD_IntrTh|

; 497  :         keyDown = FALSE;

  005c8	e59f5100	 ldr         r5, [pc, #0x100]
  005cc		 |$LN10@KPD_IntrTh|

; 664  :                                 DEBUGMSG(ZONE_IST, (L" KPD_IntrThread: "
; 665  :                                     L"Block repeat: 0x%x because of 0x%x\r\n",
; 666  :                                     vk, vkBlock
; 667  :                                 ));
; 668  :                                 break;
; 669  :                             }
; 670  :                         }
; 671  :                     }
; 672  :                     // Repeat if not blocked
; 673  :                     if (!pState->blocked) {

  005cc	e5943008	 ldr         r3, [r4, #8]
  005d0	e3530000	 cmp         r3, #0
  005d4	1a000007	 bne         |$LN8@KPD_IntrTh|

; 674  :                         DEBUGMSG(ZONE_IST, (L" KPD_IntrThread: "
; 675  :                             L"Key Repeat: 0x%x\r\n", vk
; 676  :                         ));
; 677  :                         keybd_event(vk, 0, pItem->silent?KEYEVENTF_SILENT:0, 0);

  005d8	e5963008	 ldr         r3, [r6, #8]
  005dc	e3a01000	 mov         r1, #0
  005e0	e1a00007	 mov         r0, r7
  005e4	e3530000	 cmp         r3, #0
  005e8	13a02004	 movne       r2, #4
  005ec	03a02000	 moveq       r2, #0
  005f0	e3a03000	 mov         r3, #0
  005f4	eb000000	 bl          keybd_event
  005f8		 |$LN8@KPD_IntrTh|

; 678  :                     }
; 679  :                     // Set time for next repeat
; 680  :                     delay = pItem->nextDelay;

  005f8	e1d630b4	 ldrh        r3, [r6, #4]

; 681  :                     if (delay == 0) delay = pDevice->nextRepeat;
; 682  :                     pState->time = time + delay;
; 683  :                 }
; 684  :             } else {

  005fc	e3a00001	 mov         r0, #1
  00600	e3530000	 cmp         r3, #0
  00604	059b3014	 ldreq       r3, [r11, #0x14]
  00608	e083300a	 add         r3, r3, r10
  0060c	e5843004	 str         r3, [r4, #4]
  00610	ea000002	 b           |$LN20@KPD_IntrTh|
  00614		 |$LN18@KPD_IntrTh|

; 685  :                 pState->pending = FALSE;

  00614	e3a03000	 mov         r3, #0
  00618	e5843000	 str         r3, [r4]
  0061c		 |$LN121@KPD_IntrTh|

; 686  :                 pState->blocked = FALSE;

  0061c	e5843008	 str         r3, [r4, #8]
  00620		 |$LN20@KPD_IntrTh|
  00620	e1d530b0	 ldrh        r3, [r5]
  00624	e2899001	 add         r9, r9, #1
  00628	e2888010	 add         r8, r8, #0x10
  0062c	e1590003	 cmp         r9, r3
  00630	e284400c	 add         r4, r4, #0xC
  00634	3affffb3	 bcc         |$LL21@KPD_IntrTh|
  00638		 |$LN19@KPD_IntrTh|

; 687  :             }
; 688  :         }
; 689  : 
; 690  :         DEBUGMSG(ZONE_IST, (L" KPD_IntrThread: Prepare for next run\r\n"));
; 691  :         //--------------------------------------------------------------
; 692  :         // Prepare for next run
; 693  :         //--------------------------------------------------------------
; 694  :         // New state become old
; 695  :         memcpy(vkState, vkNewState, sizeof(vkState));

  00638	e28d0040	 add         r0, sp, #0x40
  0063c	e28d1020	 add         r1, sp, #0x20
  00640	e3a02020	 mov         r2, #0x20
  00644	eb000000	 bl          memcpy

; 696  :    
; 697  :         // Set timeout period depending on data state
; 698  :         timeout = keyDown ? pDevice->samplePeriod : INFINITE;

  00648	e59d3000	 ldr         r3, [sp]

; 699  :         DEBUGMSG(ZONE_IST, (L" KPD_IntrThread: InterruptDone, timeout set to %d\r\n", timeout));
; 700  :         // Interrupt is done
; 701  :         for (index=g_nbKeys-1;index>=0;index--)

  0064c	e59f8084	 ldr         r8, [pc, #0x84]
  00650	e3530000	 cmp         r3, #0
  00654	e5983000	 ldr         r3, [r8]
  00658	159b5008	 ldrne       r5, [r11, #8]
  0065c	03e05000	 mvneq       r5, #0
  00660	e2534001	 subs        r4, r3, #1
  00664	4a000008	 bmi         |$LN3@KPD_IntrTh|
  00668	e59f3064	 ldr         r3, [pc, #0x64]
  0066c	e0836184	 add         r6, r3, r4, lsl #3
  00670		 |$LL5@KPD_IntrTh|

; 702  :         {
; 703  :             GPIOInterruptDone(pDevice->hGpio,g_keypadVK[index].gpio,pDevice->keypadSysintr[index]);

  00670	e59b3040	 ldr         r3, [r11, #0x40]
  00674	e4161008	 ldr         r1, [r6], #-8
  00678	e59b003c	 ldr         r0, [r11, #0x3C]
  0067c	e7932104	 ldr         r2, [r3, +r4, lsl #2]
  00680	eb000000	 bl          GPIOInterruptDone
  00684	e2544001	 subs        r4, r4, #1
  00688	5afffff8	 bpl         |$LL5@KPD_IntrTh|
  0068c		 |$LN3@KPD_IntrTh|

; 459  :             DEBUGMSG(ZONE_ERROR, (L" KPD_IntrThread: "
; 460  :                 L"Failed allocate memory for virtual key auto repeat\r\n"
; 461  :             ));
; 462  :             goto cleanUp;
; 463  :         }
; 464  :     }
; 465  : 
; 466  :     // Set delay to sample period
; 467  :     timeout = INFINITE;
; 468  : 
; 469  :     // Loop until we are not stopped...
; 470  :     while (!pDevice->intrThreadExit) {

  0068c	e59b3038	 ldr         r3, [r11, #0x38]
  00690	e59d7010	 ldr         r7, [sp, #0x10]
  00694	e59f9034	 ldr         r9, [pc, #0x34]
  00698	e59fa02c	 ldr         r10, [pc, #0x2C]
  0069c	eafffe7d	 b           |$LN124@KPD_IntrTh|
  006a0		 |$LN114@KPD_IntrTh|

; 455  :         // Allocate state structure for remap
; 456  :         if ((pRepeatState = LocalAlloc(
; 457  :             LPTR, g_keypadRepeat.count * sizeof(KEYPAD_REPEAT_STATE)
; 458  :         ))  == NULL) {

  006a0	e59d5004	 ldr         r5, [sp, #4]
  006a4		 |$cleanUp$43901|

; 704  :         }
; 705  :     }
; 706  : 
; 707  : cleanUp:
; 708  : 
; 709  :     if (pRemapState != NULL) LocalFree(pRemapState);

  006a4	e59d0010	 ldr         r0, [sp, #0x10]
  006a8	e3500000	 cmp         r0, #0
  006ac	1b000000	 blne        LocalFree

; 710  :     if (pRepeatState != NULL) LocalFree(pRepeatState);

  006b0	e3550000	 cmp         r5, #0
  006b4	11a00005	 movne       r0, r5
  006b8	1b000000	 blne        LocalFree
  006bc		 |$LN1@KPD_IntrTh|

; 711  :     return ERROR_SUCCESS;

  006bc	e3a00000	 mov         r0, #0

; 712  : }

  006c0	e28dd060	 add         sp, sp, #0x60
  006c4	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  006c8	e12fff1e	 bx          lr
  006cc		 |$LN128@KPD_IntrTh|
  006cc		 |$LN129@KPD_IntrTh|
  006cc	00000000	 DCD         |g_keypadRemap|
  006d0		 |$LN130@KPD_IntrTh|
  006d0	00000000	 DCD         |g_keypadRepeat|
  006d4		 |$LN131@KPD_IntrTh|
  006d4	00000000	 DCD         |g_keypadVK|
  006d8		 |$LN132@KPD_IntrTh|
  006d8	00000000	 DCD         |g_nbKeys|
  006dc		 |$M44211|

			 ENDP  ; |KPD_IntrThread|

	EXPORT	|DllMain|
	IMPORT	|DisableThreadLibraryCalls|

  00000			 AREA	 |.pdata|, PDATA
|$T44229| DCD	|$LN8@DllMain|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DllMain| PROC

; 721  : {

  00000		 |$LN8@DllMain|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44226|

; 722  :     UNREFERENCED_PARAMETER(pReserved);
; 723  :     switch (reason) {

  00004	e3510001	 cmp         r1, #1

; 724  :     case DLL_PROCESS_ATTACH:
; 725  :         DEBUGREGISTER(hDLL);
; 726  :         DisableThreadLibraryCalls((HMODULE)hDLL);

  00008	0b000000	 bleq        DisableThreadLibraryCalls

; 727  :         break;
; 728  :     }
; 729  :     return TRUE;

  0000c	e3a00001	 mov         r0, #1

; 730  : }

  00010	e49de004	 ldr         lr, [sp], #4
  00014	e12fff1e	 bx          lr
  00018		 |$M44227|

			 ENDP  ; |DllMain|

	EXPORT	|KPD_Init|
	IMPORT	|CeSetThreadPriority|
	IMPORT	|CreateThread|
	IMPORT	|GPIOInterruptInitialize|
	IMPORT	|GPIOSetMode|
	IMPORT	|CreateEventW|
	IMPORT	|GetDeviceRegistryParams|
	IMPORT	|InitializeCriticalSection|
	IMPORT	|GPIOOpen|
	IMPORT	|g_wakeupVKeys|

  00000			 AREA	 |.pdata|, PDATA
|$T44259| DCD	|$LN45@KPD_Init|
	DCD	0x4000a702
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KPD_Init| PROC

; 148  : {

  00000		 |$LN45@KPD_Init|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M44256|
  00008	e1a05000	 mov         r5, r0

; 149  :     int i;
; 150  :     DWORD rc = (DWORD)NULL;
; 151  :     KPD_DEVICE *pDevice = NULL;
; 152  : 
; 153  : 	UNREFERENCED_PARAMETER(pBusContext);
; 154  : 
; 155  :     DEBUGMSG(ZONE_FUNCTION, (
; 156  :         L"+KPD_Init(%s, 0x%08x)\r\n", szContext, pBusContext
; 157  :     ));
; 158  : 
; 159  :     // Create device structure
; 160  :     pDevice = (KPD_DEVICE *)LocalAlloc(LPTR, sizeof(KPD_DEVICE));

  0000c	e3a01048	 mov         r1, #0x48
  00010	e3a00040	 mov         r0, #0x40
  00014	e3a0b000	 mov         r11, #0
  00018	eb000000	 bl          LocalAlloc
  0001c	e1b04000	 movs        r4, r0

; 161  :     if (pDevice == NULL) {

  00020	0a000091	 beq         |$LN42@KPD_Init|

; 162  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: KPD_Init: "
; 163  :             L"Failed allocate KDP driver structure\r\n"
; 164  :         ));
; 165  :         goto cleanUp;
; 166  :     }
; 167  : 
; 168  :     // Create sysintr holding structure
; 169  :     pDevice->keypadSysintr = (DWORD *)LocalAlloc(LPTR, g_nbKeys * sizeof(DWORD));

  00024	e59f726c	 ldr         r7, [pc, #0x26C]
  00028	e3a00040	 mov         r0, #0x40
  0002c	e5973000	 ldr         r3, [r7]
  00030	e1a01103	 mov         r1, r3, lsl #2
  00034	eb000000	 bl          LocalAlloc
  00038	e3500000	 cmp         r0, #0
  0003c	e5840040	 str         r0, [r4, #0x40]

; 170  :     if (pDevice->keypadSysintr == NULL) {

  00040	0a000089	 beq         |$LN42@KPD_Init|

; 171  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: KPD_Init: "
; 172  :             L"Failed allocate structure holding the SYSINTR\r\n"
; 173  :         ));
; 174  :         goto cleanUp;
; 175  :     }
; 176  : 
; 177  :     for (i=0;i<g_nbKeys;i++)

  00044	e5973000	 ldr         r3, [r7]
  00048	e3a02000	 mov         r2, #0
  0004c	e3530000	 cmp         r3, #0
  00050	da000006	 ble         |$LN23@KPD_Init|
  00054	e3e01000	 mvn         r1, #0
  00058		 |$LL25@KPD_Init|

; 178  :     {
; 179  :         pDevice->keypadSysintr[i] = (DWORD) SYSINTR_UNDEFINED;

  00058	e5943040	 ldr         r3, [r4, #0x40]
  0005c	e7831102	 str         r1, [r3, +r2, lsl #2]
  00060	e5973000	 ldr         r3, [r7]
  00064	e2822001	 add         r2, r2, #1
  00068	e1520003	 cmp         r2, r3
  0006c	bafffff9	 blt         |$LL25@KPD_Init|
  00070		 |$LN23@KPD_Init|

; 180  :     }
; 181  : 
; 182  : 
; 183  :    // Create wakeup keys holding structure
; 184  :     if (g_nbWakeupVKeys)

  00070	e59f921c	 ldr         r9, [pc, #0x21C]
  00074	e5993000	 ldr         r3, [r9]
  00078	e3530000	 cmp         r3, #0
  0007c	0a000005	 beq         |$LN21@KPD_Init|

; 185  :     {
; 186  :         pDevice->wakeupKeys = (WAKEUP_KEY_INFO *)LocalAlloc(LPTR, sizeof(WAKEUP_KEY_INFO) * g_nbWakeupVKeys);

  00080	e1a01183	 mov         r1, r3, lsl #3
  00084	e3a00040	 mov         r0, #0x40
  00088	eb000000	 bl          LocalAlloc
  0008c	e3500000	 cmp         r0, #0
  00090	e5840044	 str         r0, [r4, #0x44]

; 187  :         if (pDevice->wakeupKeys == NULL) {

  00094	0a000074	 beq         |$LN42@KPD_Init|
  00098		 |$LN21@KPD_Init|

; 188  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: KPD_Init: "
; 189  :                 L"Failed allocate structure holding the wakeup info\r\n"
; 190  :             ));
; 191  :             goto cleanUp;
; 192  :         }
; 193  :     }
; 194  : 
; 195  :     pDevice->hGpio = GPIOOpen();

  00098	eb000000	 bl          GPIOOpen
  0009c	e3500000	 cmp         r0, #0
  000a0	e584003c	 str         r0, [r4, #0x3C]

; 196  :     if (pDevice->hGpio == NULL)

  000a4	0a000070	 beq         |$LN42@KPD_Init|

; 197  :     {
; 198  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: KPD_Init: "
; 199  :             L"Failed to open GPIO driver\r\n"
; 200  :         ));
; 201  :         goto cleanUp;
; 202  :     }
; 203  : 
; 204  :     // Set cookie & initialize critical section
; 205  :     InitializeCriticalSection(&pDevice->cs);

  000a8	e2840018	 add         r0, r4, #0x18
  000ac	eb000000	 bl          InitializeCriticalSection

; 206  : 
; 207  :     // Read device parameters
; 208  :     if (GetDeviceRegistryParams(
; 209  :         szContext, pDevice, dimof(g_deviceRegParams), g_deviceRegParams
; 210  :     ) != ERROR_SUCCESS) {

  000b0	e59f31d8	 ldr         r3, [pc, #0x1D8]
  000b4	e3a02006	 mov         r2, #6
  000b8	e1a01004	 mov         r1, r4
  000bc	e1a00005	 mov         r0, r5
  000c0	eb000000	 bl          GetDeviceRegistryParams
  000c4	e3500000	 cmp         r0, #0
  000c8	0a000009	 beq         |$LN19@KPD_Init|

; 211  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: KPD_Init: "
; 212  :             L"Failed read KPD driver registry parameters\r\n"
; 213  :         ));
; 214  :        
; 215  :         pDevice->priority256=100;

  000cc	e3a03064	 mov         r3, #0x64

; 216  :         pDevice->samplePeriod=40;

  000d0	e3a02028	 mov         r2, #0x28

; 217  :         pDevice->debounceTime=0x50;

  000d4	e3a01050	 mov         r1, #0x50

; 218  :         pDevice->firstRepeat=500;

  000d8	e3a00f7d	 mov         r0, #0x7D, 30

; 219  :         pDevice->nextRepeat=125;

  000dc	e3a0e07d	 mov         lr, #0x7D
  000e0	e5843000	 str         r3, [r4]
  000e4	e5842008	 str         r2, [r4, #8]
  000e8	e584100c	 str         r1, [r4, #0xC]
  000ec	e5840010	 str         r0, [r4, #0x10]
  000f0	e584e014	 str         lr, [r4, #0x14]
  000f4		 |$LN19@KPD_Init|

; 220  : //        goto cleanUp;
; 221  :     }
; 222  : 
; 223  :     // Create interrupt event
; 224  :     pDevice->hIntrEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  000f4	e3a03000	 mov         r3, #0
  000f8	e3a02000	 mov         r2, #0
  000fc	e3a01000	 mov         r1, #0
  00100	e3a00000	 mov         r0, #0
  00104	eb000000	 bl          CreateEventW
  00108	e3500000	 cmp         r0, #0
  0010c	e5840030	 str         r0, [r4, #0x30]

; 225  :     if (pDevice->hIntrEvent == NULL) {

  00110	0a000055	 beq         |$LN42@KPD_Init|

; 226  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: KPD_Init: "
; 227  :             L"Failed create interrupt event\r\n"
; 228  :         ));
; 229  :         goto cleanUp;
; 230  :     }
; 231  : 
; 232  :     for (i=0;i<g_nbKeys;i++)

  00114	e5972000	 ldr         r2, [r7]
  00118	e59f816c	 ldr         r8, [pc, #0x16C]
  0011c	e3a05000	 mov         r5, #0
  00120	e3520000	 cmp         r2, #0
  00124	da000011	 ble         |$LN15@KPD_Init|
  00128	e1a06008	 mov         r6, r8
  0012c		 |$LL17@KPD_Init|

; 233  :     {
; 234  :         GPIOSetMode(pDevice->hGpio,g_keypadVK[i].gpio,
; 235  :             GPIO_DIR_INPUT|GPIO_INT_HIGH_LOW|GPIO_INT_LOW_HIGH|GPIO_DEBOUNCE_ENABLE
; 236  :             );

  0012c	e5961000	 ldr         r1, [r6]
  00130	e594003c	 ldr         r0, [r4, #0x3C]
  00134	e3a02027	 mov         r2, #0x27
  00138	eb000000	 bl          GPIOSetMode
  0013c	e5942040	 ldr         r2, [r4, #0x40]

; 237  : 
; 238  :         if (GPIOInterruptInitialize(pDevice->hGpio,g_keypadVK[i].gpio,
; 239  :             &pDevice->keypadSysintr[i],pDevice->hIntrEvent) == FALSE)

  00140	e5943030	 ldr         r3, [r4, #0x30]
  00144	e5961000	 ldr         r1, [r6]
  00148	e594003c	 ldr         r0, [r4, #0x3C]
  0014c	e0822105	 add         r2, r2, r5, lsl #2
  00150	eb000000	 bl          GPIOInterruptInitialize
  00154	e3500000	 cmp         r0, #0
  00158	0a000043	 beq         |$LN42@KPD_Init|
  0015c	e5972000	 ldr         r2, [r7]
  00160	e2855001	 add         r5, r5, #1
  00164	e2866008	 add         r6, r6, #8
  00168	e1550002	 cmp         r5, r2
  0016c	baffffee	 blt         |$LL17@KPD_Init|
  00170		 |$LN15@KPD_Init|

; 240  :         {    
; 241  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: KPD_Init: "
; 242  :                 L"Failed to initialize interrupt for GPIO %d\r\n",g_keypadVK[i].gpio
; 243  :                 ));
; 244  :             goto cleanUp;
; 245  :         }
; 246  :     }
; 247  : 
; 248  :     for (i=0;i<g_nbWakeupVKeys;i++)

  00170	e5991000	 ldr         r1, [r9]
  00174	e3a00000	 mov         r0, #0
  00178	e3510000	 cmp         r1, #0
  0017c	da00001a	 ble         |$LN11@KPD_Init|
  00180	e59fa100	 ldr         r10, [pc, #0x100]
  00184		 |$LL13@KPD_Init|

; 249  :     {
; 250  :         int j;
; 251  :         for (j=0;j<g_nbKeys;j++)

  00184	e3a05000	 mov         r5, #0
  00188	e3520000	 cmp         r2, #0
  0018c	da000013	 ble         |$LN12@KPD_Init|
  00190	e7d0600a	 ldrb        r6, [r0, +r10]
  00194	e1a0e008	 mov         lr, r8
  00198		 |$LL10@KPD_Init|

; 252  :         {
; 253  :             if (g_wakeupVKeys[i] == g_keypadVK[j].vkey)

  00198	e5de3004	 ldrb        r3, [lr, #4]
  0019c	e1560003	 cmp         r6, r3
  001a0	0a000004	 beq         |$LN36@KPD_Init|
  001a4	e2855001	 add         r5, r5, #1
  001a8	e1550002	 cmp         r5, r2
  001ac	e28ee008	 add         lr, lr, #8
  001b0	bafffff8	 blt         |$LL10@KPD_Init|
  001b4	ea000009	 b           |$LN12@KPD_Init|
  001b8		 |$LN36@KPD_Init|

; 254  :             {
; 255  :                 pDevice->wakeupKeys[i].gpio = g_keypadVK[i].gpio;

  001b8	e5942044	 ldr         r2, [r4, #0x44]
  001bc	e7983180	 ldr         r3, [r8, +r0, lsl #3]
  001c0	e7823180	 str         r3, [r2, +r0, lsl #3]

; 256  :                 pDevice->wakeupKeys[i].dwSysintr = pDevice->keypadSysintr[i];

  001c4	e5943040	 ldr         r3, [r4, #0x40]
  001c8	e5942044	 ldr         r2, [r4, #0x44]
  001cc	e7931100	 ldr         r1, [r3, +r0, lsl #2]
  001d0	e0823180	 add         r3, r2, r0, lsl #3
  001d4	e5831004	 str         r1, [r3, #4]
  001d8	e5972000	 ldr         r2, [r7]
  001dc	e5991000	 ldr         r1, [r9]
  001e0		 |$LN12@KPD_Init|
  001e0	e2800001	 add         r0, r0, #1
  001e4	e1500001	 cmp         r0, r1
  001e8	baffffe5	 blt         |$LL13@KPD_Init|
  001ec		 |$LN11@KPD_Init|

; 257  :                 break;
; 258  :             }
; 259  :         }        
; 260  :     }
; 261  : 
; 262  :     // Enable wakeup from keyboard if required
; 263  :     if (pDevice->enableWake != 0)

  001ec	e5943004	 ldr         r3, [r4, #4]
  001f0	e3530000	 cmp         r3, #0
  001f4	0a00000d	 beq         |$LN3@KPD_Init|

; 264  :     {
; 265  :        for (i=0;i<g_nbWakeupVKeys;i++)

  001f8	e3a05000	 mov         r5, #0
  001fc	e3510000	 cmp         r1, #0
  00200	da00000a	 ble         |$LN3@KPD_Init|
  00204		 |$LL5@KPD_Init|
  00204	e5941044	 ldr         r1, [r4, #0x44]

; 266  :        {
; 267  :            GPIOInterruptWakeUp(pDevice->hGpio,pDevice->wakeupKeys[i].gpio,
; 268  :             pDevice->wakeupKeys[i].dwSysintr,TRUE);

  00208	e594003c	 ldr         r0, [r4, #0x3C]
  0020c	e3a03001	 mov         r3, #1
  00210	e0812185	 add         r2, r1, r5, lsl #3
  00214	e5922004	 ldr         r2, [r2, #4]
  00218	e7911185	 ldr         r1, [r1, +r5, lsl #3]
  0021c	eb000000	 bl          GPIOInterruptWakeUp
  00220	e5993000	 ldr         r3, [r9]
  00224	e2855001	 add         r5, r5, #1
  00228	e1550003	 cmp         r5, r3
  0022c	bafffff4	 blt         |$LL5@KPD_Init|
  00230		 |$LN3@KPD_Init|

; 269  :        }
; 270  :     }
; 271  : 
; 272  :     // Start interrupt service thread
; 273  :     if ((pDevice->hIntrThread = CreateThread(
; 274  :         NULL, 0, KPD_IntrThread, pDevice, 0,NULL
; 275  :     )) == NULL) {

  00230	e59f204c	 ldr         r2, [pc, #0x4C]
  00234	e3a0e000	 mov         lr, #0
  00238	e1a03004	 mov         r3, r4
  0023c	e3a01000	 mov         r1, #0
  00240	e3a00000	 mov         r0, #0
  00244	e58de004	 str         lr, [sp, #4]
  00248	e58de000	 str         lr, [sp]
  0024c	eb000000	 bl          CreateThread
  00250	e3500000	 cmp         r0, #0
  00254	e5840034	 str         r0, [r4, #0x34]
  00258	0a000003	 beq         |$LN42@KPD_Init|

; 276  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: KPD_Init: "
; 277  :             L"Failed create interrupt thread\r\n"
; 278  :         ));
; 279  :         goto cleanUp;
; 280  :     }
; 281  :     // Set thread priority
; 282  :     CeSetThreadPriority(pDevice->hIntrThread, pDevice->priority256);

  0025c	e5941000	 ldr         r1, [r4]
  00260	eb000000	 bl          CeSetThreadPriority

; 283  : 
; 284  :     // Return non-null value
; 285  :     rc = (DWORD)pDevice;

  00264	e1a0b004	 mov         r11, r4
  00268		 |$cleanUp$43764|

; 286  : 
; 287  : cleanUp:
; 288  :     if (rc == 0) KPD_Deinit((DWORD)pDevice);

  00268	ea000001	 b           |$LN1@KPD_Init|
  0026c		 |$LN42@KPD_Init|
  0026c	e1a00004	 mov         r0, r4
  00270	eb000000	 bl          KPD_Deinit
  00274		 |$LN1@KPD_Init|

; 289  :     DEBUGMSG(ZONE_FUNCTION, (L"-KPD_Init(rc = %d\r\n", rc));
; 290  : 
; 291  :     return rc;
; 292  : }

  00274	e1a0000b	 mov         r0, r11
  00278	e28dd008	 add         sp, sp, #8
  0027c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00280	e12fff1e	 bx          lr
  00284		 |$LN46@KPD_Init|
  00284		 |$LN47@KPD_Init|
  00284	00000000	 DCD         |KPD_IntrThread|
  00288		 |$LN48@KPD_Init|
  00288	00000000	 DCD         |g_wakeupVKeys|
  0028c		 |$LN49@KPD_Init|
  0028c	00000000	 DCD         |g_keypadVK|
  00290		 |$LN50@KPD_Init|
  00290	00000000	 DCD         |g_deviceRegParams|
  00294		 |$LN51@KPD_Init|
  00294	00000000	 DCD         |g_nbWakeupVKeys|
  00298		 |$LN52@KPD_Init|
  00298	00000000	 DCD         |g_nbKeys|
  0029c		 |$M44257|

			 ENDP  ; |KPD_Init|

	END
