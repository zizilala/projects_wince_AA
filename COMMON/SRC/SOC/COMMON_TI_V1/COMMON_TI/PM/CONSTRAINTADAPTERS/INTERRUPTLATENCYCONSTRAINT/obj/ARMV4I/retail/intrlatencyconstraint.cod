; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\PM\CONSTRAINTADAPTERS\INTERRUPTLATENCYCONSTRAINT\intrlatencyconstraint.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	IMPORT	|EnterCriticalSection|

  00000			 AREA	 |.bss|, NOINIT
|s_ilInfo| %	0x18
|s_ilInfo| %	0x18
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\pm\constraintadapters\interruptlatencyconstraint\intrlatencyconstraint.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T40260| DCD	|$LN5@Lock|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Lock@@YAXXZ| PROC			; Lock

; 60   : {

  00000		 |$LN5@Lock|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M40257|

; 61   :     EnterCriticalSection(&s_ilInfo.cs);

  00004	e59f0008	 ldr         r0, [pc, #8]
  00008	eb000000	 bl          EnterCriticalSection

; 62   : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$LN6@Lock|
  00014		 |$LN7@Lock|
  00014	00000000	 DCD         |s_ilInfo|
  00018		 |$M40258|

			 ENDP  ; |?Lock@@YAXXZ|, Lock

	IMPORT	|LeaveCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T40269| DCD	|$LN5@Unlock|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Unlock@@YAXXZ| PROC			; Unlock

; 73   : {

  00000		 |$LN5@Unlock|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M40266|

; 74   :     LeaveCriticalSection(&s_ilInfo.cs);

  00004	e59f0008	 ldr         r0, [pc, #8]
  00008	eb000000	 bl          LeaveCriticalSection

; 75   : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$LN6@Unlock|
  00014		 |$LN7@Unlock|
  00014	00000000	 DCD         |s_ilInfo|
  00018		 |$M40267|

			 ENDP  ; |?Unlock@@YAXXZ|, Unlock

	EXPORT	|?INTRLAT_InitConstraint@@YAPAXPBG@Z|	; INTRLAT_InitConstraint
	IMPORT	|InitializeCriticalSection|
	IMPORT	|RegOpenKeyExW|
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T40283| DCD	|$LN7@INTRLAT_In|
	DCD	0x40001f02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?INTRLAT_InitConstraint@@YAPAXPBG@Z| PROC ; INTRLAT_InitConstraint

; 138  : {

  00000		 |$LN7@INTRLAT_In|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M40280|
  00008	e1a04000	 mov         r4, r0

; 139  :     LONG code;
; 140  :     HANDLE rc = NULL;
; 141  :     HKEY hKey = NULL;
; 142  :     
; 143  :     // Initialize data structure
; 144  :     memset(&s_ilInfo, 0, sizeof(InterruptLatencyConstraintInfo_t));

  0000c	e59f5064	 ldr         r5, [pc, #0x64]
  00010	e3a03000	 mov         r3, #0
  00014	e3a02018	 mov         r2, #0x18
  00018	e1a00005	 mov         r0, r5
  0001c	e3a01000	 mov         r1, #0
  00020	e3a06000	 mov         r6, #0
  00024	e58d3004	 str         r3, [sp, #4]
  00028	eb000000	 bl          memset
  0002c	e3e03080	 mvn         r3, #0x80

; 145  :     s_ilInfo.current = -1.0f;

  00030	e1a03b83	 mov         r3, r3, lsl #23

; 146  : 
; 147  :     // read registry to get ceiling value    
; 148  :     code = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, szContext, 0, 0, &hKey);

  00034	e5853014	 str         r3, [r5, #0x14]
  00038	e28de004	 add         lr, sp, #4
  0003c	e3a03000	 mov         r3, #0
  00040	e3a02000	 mov         r2, #0
  00044	e1a01004	 mov         r1, r4
  00048	e3a0010a	 mov         r0, #0xA, 2
  0004c	e58de000	 str         lr, [sp]
  00050	eb000000	 bl          RegOpenKeyExW
  00054	e3500000	 cmp         r0, #0

; 149  :     if (code != ERROR_SUCCESS) goto cleanUp;

  00058	1a000002	 bne         |$cleanUp$39665|

; 150  : 
; 151  :     // intialize synchronization object
; 152  :     InitializeCriticalSection(&s_ilInfo.cs);

  0005c	e1a00005	 mov         r0, r5
  00060	eb000000	 bl          InitializeCriticalSection

; 153  :     
; 154  :     rc = (HANDLE)&s_ilInfo;

  00064	e1a06005	 mov         r6, r5
  00068		 |$cleanUp$39665|

; 155  : 
; 156  : cleanUp:
; 157  :     return rc;
; 158  : } 

  00068	e1a00006	 mov         r0, r6
  0006c	e28dd008	 add         sp, sp, #8
  00070	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00074	e12fff1e	 bx          lr
  00078		 |$LN8@INTRLAT_In|
  00078		 |$LN9@INTRLAT_In|
  00078	00000000	 DCD         |s_ilInfo|
  0007c		 |$M40281|

			 ENDP  ; |?INTRLAT_InitConstraint@@YAPAXPBG@Z|, INTRLAT_InitConstraint

	EXPORT	|?INTRLAT_DeinitConstraint@@YAHPAX@Z|	; INTRLAT_DeinitConstraint
	IMPORT	|DeleteCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T40296| DCD	|$LN7@INTRLAT_De|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?INTRLAT_DeinitConstraint@@YAHPAX@Z| PROC ; INTRLAT_DeinitConstraint

; 170  : {

  00000		 |$LN7@INTRLAT_De|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M40293|

; 171  :     BOOL rc = FALSE;
; 172  : 
; 173  :     // validate parameters
; 174  :     if (hConstraintAdapter != (HANDLE)&s_ilInfo) goto cleanUp;

  00004	e59f2020	 ldr         r2, [pc, #0x20]
  00008	e3a03000	 mov         r3, #0
  0000c	e1500002	 cmp         r0, r2
  00010	1a000002	 bne         |$cleanUp$39674|

; 175  :     DeleteCriticalSection(&s_ilInfo.cs);

  00014	e1a00002	 mov         r0, r2
  00018	eb000000	 bl          DeleteCriticalSection

; 176  : 
; 177  :     rc = TRUE;

  0001c	e3a03001	 mov         r3, #1
  00020		 |$cleanUp$39674|

; 178  : 
; 179  : cleanUp:
; 180  :     return rc;
; 181  : } 

  00020	e1a00003	 mov         r0, r3
  00024	e49de004	 ldr         lr, [sp], #4
  00028	e12fff1e	 bx          lr
  0002c		 |$LN8@INTRLAT_De|
  0002c		 |$LN9@INTRLAT_De|
  0002c	00000000	 DCD         |s_ilInfo|
  00030		 |$M40294|

			 ENDP  ; |?INTRLAT_DeinitConstraint@@YAHPAX@Z|, INTRLAT_DeinitConstraint

	EXPORT	|??0?$IndexList@M@@QAA@XZ|		; IndexList<float>::IndexList<float>
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\pm\inc\indexlist.h

  00000			 AREA	 |.pdata|, PDATA
|$T40308| DCD	|$LN5@IndexList|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0?$IndexList@M@@QAA@XZ| PROC	; IndexList<float>::IndexList<float>

; 51   :     IndexList()

  00000		 |$LN5@IndexList|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M40305|
  00004	e1a04000	 mov         r4, r0

; 52   :     {        
; 53   :         memset(&m_Head, 0, sizeof(IndexData));

  00008	e3a02088	 mov         r2, #0x88
  0000c	e3a01000	 mov         r1, #0
  00010	eb000000	 bl          memset

; 54   :         m_maxIndex = INDEXED_CHUNK_SIZE - 1;

  00014	e3a0301f	 mov         r3, #0x1F
  00018	e5843088	 str         r3, [r4, #0x88]

; 55   :     }

  0001c	e1a00004	 mov         r0, r4
  00020	e8bd4010	 ldmia       sp!, {r4, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M40306|

			 ENDP  ; |??0?$IndexList@M@@QAA@XZ|, IndexList<float>::IndexList<float>

	EXPORT	|??1?$IndexList@M@@QAA@XZ|		; IndexList<float>::~IndexList<float>
	IMPORT	|??3@YAXPAX@Z|				; operator delete

  00000			 AREA	 |.pdata|, PDATA
|$T40321| DCD	|$LN9@IndexList@2|
	DCD	0x40000b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1?$IndexList@M@@QAA@XZ| PROC	; IndexList<float>::~IndexList<float>

; 58   :     {

  00000		 |$LN9@IndexList@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M40318|

; 59   :         IndexData *pCurrent;
; 60   :         IndexData *pDelete;
; 61   : 
; 62   :         pCurrent = m_Head.pNext;

  00004	e5903000	 ldr         r3, [r0]
  00008	e1b04003	 movs        r4, r3

; 63   :         while (pCurrent != NULL)

  0000c	0a000004	 beq         |$LN1@IndexList@2|
  00010		 |$LL2@IndexList@2|

; 64   :             {
; 65   :             pDelete = pCurrent;

  00010	e1a00004	 mov         r0, r4

; 66   :             pCurrent = pCurrent->pNext;

  00014	e5944000	 ldr         r4, [r4]

; 67   :             delete pDelete;

  00018	eb000000	 bl          |??3@YAXPAX@Z|
  0001c	e3540000	 cmp         r4, #0
  00020	1afffffa	 bne         |$LL2@IndexList@2|
  00024		 |$LN1@IndexList@2|

; 68   :             }
; 69   :     }

  00024	e8bd4010	 ldmia       sp!, {r4, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$M40319|

			 ENDP  ; |??1?$IndexList@M@@QAA@XZ|, IndexList<float>::~IndexList<float>

	EXPORT	|?MaxIndex@?$IndexList@M@@QAAKXZ|	; IndexList<float>::MaxIndex

  00000			 AREA	 |.pdata|, PDATA
|$T40331| DCD	|$LN5@MaxIndex|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?MaxIndex@?$IndexList@M@@QAAKXZ| PROC	; IndexList<float>::MaxIndex

; 76   :     {

  00000		 |$LN5@MaxIndex|
  00000		 |$M40328|

; 77   :         return m_maxIndex;

  00000	e5900088	 ldr         r0, [r0, #0x88]

; 78   :     }

  00004	e12fff1e	 bx          lr
  00008		 |$M40329|

			 ENDP  ; |?MaxIndex@?$IndexList@M@@QAAKXZ|, IndexList<float>::MaxIndex

	EXPORT	|?NewIndex@?$IndexList@M@@QAAHPAPAMPAK@Z| ; IndexList<float>::NewIndex
	IMPORT	|??2@YAPAXI@Z|				; operator new

  00000			 AREA	 |.pdata|, PDATA
|$T40357| DCD	|$LN20@NewIndex|
	DCD	0x40003101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?NewIndex@?$IndexList@M@@QAAHPAPAMPAK@Z| PROC ; IndexList<float>::NewIndex

; 81   :     {

  00000		 |$LN20@NewIndex|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M40354|
  00004	e1a09002	 mov         r9, r2
  00008	e1a0a001	 mov         r10, r1
  0000c	e1a08000	 mov         r8, r0

; 82   :         DWORD ffMask;
; 83   :         INT index = 0;        
; 84   :         BOOL rc = FALSE;        
; 85   :         IndexData *pCurrent;
; 86   : 
; 87   :         // find emtpy chunk
; 88   :         pCurrent = &m_Head;
; 89   :         while (pCurrent->ffMask == (-1))

  00010	e5983004	 ldr         r3, [r8, #4]
  00014	e3a05000	 mov         r5, #0
  00018	e3a06000	 mov         r6, #0
  0001c	e1a04008	 mov         r4, r8
  00020	ea000011	 b           |$LN15@NewIndex|
  00024		 |$LL7@NewIndex|

; 90   :             {
; 91   :             if (pCurrent->pNext == NULL)

  00024	e5943000	 ldr         r3, [r4]
  00028	e3530000	 cmp         r3, #0
  0002c	1a00000b	 bne         |$LN5@NewIndex|

; 92   :                 {
; 93   :                 IndexData *pNew = new IndexData;

  00030	e3a00088	 mov         r0, #0x88
  00034	eb000000	 bl          |??2@YAPAXI@Z|
  00038	e1b07000	 movs        r7, r0

; 94   :                 if (pNew == NULL) goto cleanUp;

  0003c	0a00001d	 beq         |$cleanUp$39764|

; 95   : 
; 96   :                 memset(pNew, 0, sizeof(IndexData));

  00040	e3a02088	 mov         r2, #0x88
  00044	e3a01000	 mov         r1, #0
  00048	e1a00007	 mov         r0, r7
  0004c	eb000000	 bl          memset

; 97   :                 pCurrent->pNext = pNew;

  00050	e5847000	 str         r7, [r4]

; 98   :                 m_maxIndex += INDEXED_CHUNK_SIZE;

  00054	e5983088	 ldr         r3, [r8, #0x88]
  00058	e2833020	 add         r3, r3, #0x20
  0005c	e5883088	 str         r3, [r8, #0x88]
  00060		 |$LN5@NewIndex|

; 99   :                 }
; 100  : 
; 101  :             index += INDEXED_CHUNK_SIZE;
; 102  :             pCurrent = pCurrent->pNext;

  00060	e5944000	 ldr         r4, [r4]
  00064	e2855020	 add         r5, r5, #0x20
  00068	e5943004	 ldr         r3, [r4, #4]
  0006c		 |$LN15@NewIndex|
  0006c	e3730001	 cmn         r3, #1
  00070	0affffeb	 beq         |$LL7@NewIndex|

; 103  :             }
; 104  : 
; 105  :         // get index within chunk
; 106  :         ffMask = pCurrent->ffMask;

  00074	e5942004	 ldr         r2, [r4, #4]

; 107  :         while ((ffMask & 1) == 1)

  00078	ea000001	 b           |$LN17@NewIndex|
  0007c		 |$LL2@NewIndex|

; 108  :             {
; 109  :             index++;
; 110  :             ffMask >>= 1;

  0007c	e1a020a2	 mov         r2, r2, lsr #1
  00080	e2855001	 add         r5, r5, #1
  00084		 |$LN17@NewIndex|
  00084	e2023001	 and         r3, r2, #1
  00088	e3530001	 cmp         r3, #1
  0008c	0afffffa	 beq         |$LL2@NewIndex|

; 111  :             }
; 112  : 
; 113  :         // copy empty slot info and mark as reserved
; 114  :         *pId = index;
; 115  :         *ppType = &(pCurrent->rgData[index & 0x1F]);

  00090	e205201f	 and         r2, r5, #0x1F
  00094	e2823002	 add         r3, r2, #2
  00098	e0843103	 add         r3, r4, r3, lsl #2
  0009c	e5895000	 str         r5, [r9]
  000a0	e58a3000	 str         r3, [r10]

; 116  :         pCurrent->ffMask |= (1 << (index & 0x1F));

  000a4	e5943004	 ldr         r3, [r4, #4]
  000a8	e3a01001	 mov         r1, #1

; 117  : 
; 118  :         rc = TRUE;

  000ac	e3a06001	 mov         r6, #1
  000b0	e1833211	 orr         r3, r3, r1, lsl r2
  000b4	e5843004	 str         r3, [r4, #4]
  000b8		 |$cleanUp$39764|

; 119  :     cleanUp:
; 120  :         return rc;
; 121  :     }

  000b8	e1a00006	 mov         r0, r6
  000bc	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  000c0	e12fff1e	 bx          lr
  000c4		 |$M40355|

			 ENDP  ; |?NewIndex@?$IndexList@M@@QAAHPAPAMPAK@Z|, IndexList<float>::NewIndex

	EXPORT	|?DeleteIndex@?$IndexList@M@@QAAXK@Z|	; IndexList<float>::DeleteIndex

  00000			 AREA	 |.pdata|, PDATA
|$T40370| DCD	|$LN10@DeleteInde|
	DCD	0x40000e00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DeleteIndex@?$IndexList@M@@QAAXK@Z| PROC ; IndexList<float>::DeleteIndex

; 124  :     {

  00000		 |$LN10@DeleteInde|
  00000		 |$M40367|

; 125  :         IndexData *pCurrent;
; 126  :         DWORD chunkId = id >> 5;

  00000	e1b022a1	 movs        r2, r1, lsr #5

; 127  : 
; 128  :         // find chunk
; 129  :         pCurrent = &m_Head;
; 130  :         while (chunkId)

  00004	0a000005	 beq         |$LN2@DeleteInde|
  00008		 |$LL3@DeleteInde|

; 131  :             {
; 132  :             --chunkId;
; 133  :             pCurrent = pCurrent->pNext;

  00008	e5903000	 ldr         r3, [r0]
  0000c	e2422001	 sub         r2, r2, #1
  00010	e1b00003	 movs        r0, r3

; 134  :             if (pCurrent == NULL) return;            

  00014	0a000006	 beq         |$LN4@DeleteInde|

; 127  : 
; 128  :         // find chunk
; 129  :         pCurrent = &m_Head;
; 130  :         while (chunkId)

  00018	e3520000	 cmp         r2, #0
  0001c	1afffff9	 bne         |$LL3@DeleteInde|
  00020		 |$LN2@DeleteInde|

; 135  :             }
; 136  : 
; 137  :         // clear mask
; 138  :         pCurrent->ffMask &= ~(1 << (id & 0x1F));

  00020	e5903004	 ldr         r3, [r0, #4]
  00024	e201201f	 and         r2, r1, #0x1F
  00028	e3a01001	 mov         r1, #1
  0002c	e1c33211	 bic         r3, r3, r1, lsl r2
  00030	e5803004	 str         r3, [r0, #4]
  00034		 |$LN4@DeleteInde|

; 139  :     }

  00034	e12fff1e	 bx          lr
  00038		 |$M40368|

			 ENDP  ; |?DeleteIndex@?$IndexList@M@@QAAXK@Z|, IndexList<float>::DeleteIndex

	EXPORT	|?GetIndex@?$IndexList@M@@QAAPAMK@Z|	; IndexList<float>::GetIndex

  00000			 AREA	 |.pdata|, PDATA
|$T40387| DCD	|$LN12@GetIndex|
	DCD	0x40001100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetIndex@?$IndexList@M@@QAAPAMK@Z| PROC ; IndexList<float>::GetIndex

; 142  :     {

  00000		 |$LN12@GetIndex|
  00000		 |$M40384|

; 143  :         IndexData *pCurrent;
; 144  :         DWORD chunkId = id >> 5;

  00000	e1b022a1	 movs        r2, r1, lsr #5

; 145  : 
; 146  :         // find chunk
; 147  :         pCurrent = &m_Head;
; 148  :         while (chunkId)

  00004	0a000005	 beq         |$LN2@GetIndex|
  00008		 |$LL3@GetIndex|

; 149  :             {
; 150  :             --chunkId;
; 151  :             pCurrent = pCurrent->pNext;

  00008	e5903000	 ldr         r3, [r0]
  0000c	e2422001	 sub         r2, r2, #1
  00010	e1b00003	 movs        r0, r3

; 152  :             if (pCurrent == NULL) return NULL;   

  00014	0a000008	 beq         |$LN6@GetIndex|

; 145  : 
; 146  :         // find chunk
; 147  :         pCurrent = &m_Head;
; 148  :         while (chunkId)

  00018	e3520000	 cmp         r2, #0
  0001c	1afffff9	 bne         |$LL3@GetIndex|
  00020		 |$LN2@GetIndex|

; 153  :             }
; 154  : 
; 155  :         // clear mask
; 156  :         return (pCurrent->ffMask & (1 << (id & 0x1F))) ? 
; 157  :                     &(pCurrent->rgData[id & 0x1F]) : NULL;

  00020	e5903004	 ldr         r3, [r0, #4]
  00024	e201201f	 and         r2, r1, #0x1F
  00028	e3a01001	 mov         r1, #1
  0002c	e1130211	 tst         r3, r1, lsl r2
  00030	12823002	 addne       r3, r2, #2
  00034	10800103	 addne       r0, r0, r3, lsl #2

; 158  :     }

  00038	112fff1e	 bxne        lr
  0003c		 |$LN6@GetIndex|

; 153  :             }
; 154  : 
; 155  :         // clear mask
; 156  :         return (pCurrent->ffMask & (1 << (id & 0x1F))) ? 
; 157  :                     &(pCurrent->rgData[id & 0x1F]) : NULL;

  0003c	e3a00000	 mov         r0, #0

; 158  :     }

  00040	e12fff1e	 bx          lr
  00044		 |$M40385|

			 ENDP  ; |?GetIndex@?$IndexList@M@@QAAPAMK@Z|, IndexList<float>::GetIndex

	EXPORT	|?UpdateConstraint@@YAHXZ|		; UpdateConstraint
	IMPORT	|KernelIoControl|
	IMPORT	|__ges|
	IMPORT	|__lts|
	IMPORT	|__nes|

  00000			 AREA	 |.pdata|, PDATA
|$T40410| DCD	|$LN20@UpdateCons|
	DCD	0x40003c02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\pm\constraintadapters\interruptlatencyconstraint\intrlatencyconstraint.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdateConstraint@@YAHXZ| PROC	; UpdateConstraint

; 85   : {

  00000		 |$LN20@UpdateCons|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M40407|

; 86   :     int i;
; 87   :     BOOL rc = FALSE;    
; 88   :     float *pDataNode;
; 89   :     float *pMinLatency = NULL;
; 90   :     float nullConstraint = IL_CONSTRAINT_NULL;    
; 91   :         
; 92   :     // get highest operatin mode if not forced
; 93   :     for (i = 0; i < s_IndexList.MaxIndex(); ++i)

  00008	e59f80dc	 ldr         r8, [pc, #0xDC]
  0000c	e3e03080	 mvn         r3, #0x80
  00010	e1a03b83	 mov         r3, r3, lsl #23
  00014	e5987088	 ldr         r7, [r8, #0x88]
  00018	e3a04000	 mov         r4, #0
  0001c	e58d3008	 str         r3, [sp, #8]
  00020	e3570000	 cmp         r7, #0
  00024	e3a05000	 mov         r5, #0
  00028	0a000016	 beq         |$LN17@UpdateCons|
  0002c		 |$LL10@UpdateCons|

; 94   :         {
; 95   :         pDataNode = s_IndexList.GetIndex(i);

  0002c	e1a01005	 mov         r1, r5
  00030	e1a00008	 mov         r0, r8
  00034	eb000000	 bl          |?GetIndex@?$IndexList@M@@QAAPAMK@Z|
  00038	e1b06000	 movs        r6, r0

; 96   :         if (pDataNode != NULL && *pDataNode >= 0.0f)

  0003c	0a00000c	 beq         |$LN9@UpdateCons|
  00040	e5960000	 ldr         r0, [r6]
  00044	e3a01000	 mov         r1, #0
  00048	eb000000	 bl          __ges
  0004c	e3500000	 cmp         r0, #0
  00050	0a000007	 beq         |$LN9@UpdateCons|

; 97   :             {
; 98   :             if (pMinLatency == NULL || *pDataNode < *pMinLatency)

  00054	e3540000	 cmp         r4, #0
  00058	0a000004	 beq         |$LN5@UpdateCons|
  0005c	e5941000	 ldr         r1, [r4]
  00060	e5960000	 ldr         r0, [r6]
  00064	eb000000	 bl          __lts
  00068	e3500000	 cmp         r0, #0
  0006c	0a000000	 beq         |$LN9@UpdateCons|
  00070		 |$LN5@UpdateCons|

; 99   :                 {
; 100  :                 pMinLatency = pDataNode;

  00070	e1a04006	 mov         r4, r6
  00074		 |$LN9@UpdateCons|

; 86   :     int i;
; 87   :     BOOL rc = FALSE;    
; 88   :     float *pDataNode;
; 89   :     float *pMinLatency = NULL;
; 90   :     float nullConstraint = IL_CONSTRAINT_NULL;    
; 91   :         
; 92   :     // get highest operatin mode if not forced
; 93   :     for (i = 0; i < s_IndexList.MaxIndex(); ++i)

  00074	e2855001	 add         r5, r5, #1
  00078	e1550007	 cmp         r5, r7
  0007c	3affffea	 bcc         |$LL10@UpdateCons|

; 101  :                 }
; 102  :             }
; 103  :         }
; 104  : 
; 105  :     // if no minimum latency then use a null constraint to release
; 106  :     // all constraints
; 107  :     if (pMinLatency == NULL)

  00080	e3540000	 cmp         r4, #0
  00084	1a000000	 bne         |$LN4@UpdateCons|
  00088		 |$LN17@UpdateCons|

; 108  :         {
; 109  :         pMinLatency = &nullConstraint;

  00088	e28d4008	 add         r4, sp, #8
  0008c		 |$LN4@UpdateCons|

; 110  :         }
; 111  : 
; 112  :     // Prepare to send notifications
; 113  :     if (s_ilInfo.current != *pMinLatency)

  0008c	e59f5054	 ldr         r5, [pc, #0x54]
  00090	e5941000	 ldr         r1, [r4]
  00094	e5950014	 ldr         r0, [r5, #0x14]
  00098	eb000000	 bl          __nes
  0009c	e3500000	 cmp         r0, #0
  000a0	0a00000b	 beq         |$LN3@UpdateCons|

; 114  :         {                         
; 115  :         // change operating points
; 116  :         rc = KernelIoControl(IOCTL_INTERRUPT_LATENCY_CONSTRAINT, pMinLatency, 
; 117  :                 sizeof(float), 0, 0, 0
; 118  :                 );

  000a4	e59f0038	 ldr         r0, [pc, #0x38]
  000a8	e3a0e000	 mov         lr, #0
  000ac	e3a03000	 mov         r3, #0
  000b0	e3a02004	 mov         r2, #4
  000b4	e1a01004	 mov         r1, r4
  000b8	e58de004	 str         lr, [sp, #4]
  000bc	e58de000	 str         lr, [sp]
  000c0	eb000000	 bl          KernelIoControl
  000c4	e3500000	 cmp         r0, #0

; 119  :         if (rc == FALSE) goto cleanUp;

  000c8	0a000002	 beq         |$cleanUp$39653|

; 120  :         s_ilInfo.current = *pMinLatency;

  000cc	e5943000	 ldr         r3, [r4]
  000d0	e5853014	 str         r3, [r5, #0x14]
  000d4		 |$LN3@UpdateCons|

; 121  :         }
; 122  :     rc = TRUE;

  000d4	e3a00001	 mov         r0, #1
  000d8		 |$cleanUp$39653|

; 123  : 
; 124  : cleanUp:
; 125  :     return rc;
; 126  : }

  000d8	e28dd00c	 add         sp, sp, #0xC
  000dc	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000e0	e12fff1e	 bx          lr
  000e4		 |$LN21@UpdateCons|
  000e4		 |$LN22@UpdateCons|
  000e4	02590fa4	 DCD         0x2590fa4
  000e8		 |$LN23@UpdateCons|
  000e8	00000000	 DCD         |s_ilInfo|
  000ec		 |$LN24@UpdateCons|
  000ec	00000000	 DCD         |s_IndexList|
  000f0		 |$M40408|

			 ENDP  ; |?UpdateConstraint@@YAHXZ|, UpdateConstraint

	EXPORT	|?INTRLAT_CreateConstraint@@YAPAXPAX@Z|	; INTRLAT_CreateConstraint

  00000			 AREA	 |.pdata|, PDATA
|$T40426| DCD	|$LN9@INTRLAT_Cr|
	DCD	0x40001702
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?INTRLAT_CreateConstraint@@YAPAXPAX@Z| PROC ; INTRLAT_CreateConstraint

; 193  : {

  00000		 |$LN9@INTRLAT_Cr|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M40423|

; 194  :     DWORD id;
; 195  :     float *pDataNode;
; 196  :     HANDLE rc = NULL;
; 197  :     
; 198  :     // validate parameters
; 199  :     if (hConstraintAdapter != (HANDLE)&s_ilInfo) goto cleanUp;

  00008	e59f3048	 ldr         r3, [pc, #0x48]
  0000c	e3a04000	 mov         r4, #0
  00010	e1500003	 cmp         r0, r3
  00014	1a00000a	 bne         |$cleanUp$39684|

; 200  : 
; 201  :     // get new index
; 202  :     if (s_IndexList.NewIndex(&pDataNode, &id) == FALSE)

  00018	e59f0034	 ldr         r0, [pc, #0x34]
  0001c	e28d2004	 add         r2, sp, #4
  00020	e28d1000	 add         r1, sp, #0
  00024	eb000000	 bl          |?NewIndex@?$IndexList@M@@QAAHPAPAMPAK@Z|
  00028	e3500000	 cmp         r0, #0

; 203  :         {
; 204  :         goto cleanUp;
; 205  :         }
; 206  : 
; 207  :     // initialize values
; 208  :     rc = (HANDLE)(id + 1);
; 209  :     *pDataNode = IL_CONSTRAINT_NULL;

  0002c	159d1000	 ldrne       r1, [sp]
  00030	159d2004	 ldrne       r2, [sp, #4]
  00034	13e03080	 mvnne       r3, #0x80
  00038	11a03b83	 movne       r3, r3, lsl #23
  0003c	15813000	 strne       r3, [r1]
  00040	12824001	 addne       r4, r2, #1
  00044		 |$cleanUp$39684|

; 210  : 
; 211  : cleanUp:    
; 212  :     return rc;
; 213  : } 

  00044	e1a00004	 mov         r0, r4
  00048	e28dd008	 add         sp, sp, #8
  0004c	e8bd4010	 ldmia       sp!, {r4, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$LN10@INTRLAT_Cr|
  00054		 |$LN11@INTRLAT_Cr|
  00054	00000000	 DCD         |s_IndexList|
  00058		 |$LN12@INTRLAT_Cr|
  00058	00000000	 DCD         |s_ilInfo|
  0005c		 |$M40424|

			 ENDP  ; |?INTRLAT_CreateConstraint@@YAPAXPAX@Z|, INTRLAT_CreateConstraint

	EXPORT	|?INTRLAT_UpdateConstraint@@YAHPAXK0I@Z| ; INTRLAT_UpdateConstraint

  00000			 AREA	 |.pdata|, PDATA
|$T40457| DCD	|$LN24@INTRLAT_Up|
	DCD	0x40002501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?INTRLAT_UpdateConstraint@@YAHPAXK0I@Z| PROC ; INTRLAT_UpdateConstraint

; 228  : {

  00000		 |$LN24@INTRLAT_Up|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M40454|
  00004	e1a05002	 mov         r5, r2
  00008	e1a07001	 mov         r7, r1

; 229  :     float constraintNew;
; 230  :     BOOL rc = FALSE;

  0000c	e3a04000	 mov         r4, #0

; 231  :     float *pDataNode;
; 232  :     DWORD id = (DWORD)hConstraintContext - 1;

  00010	e2401001	 sub         r1, r0, #1

; 233  :     
; 234  :     // validate parameters
; 235  :     if (size != sizeof(float)) goto cleanUp;

  00014	e3530004	 cmp         r3, #4
  00018	1a000018	 bne         |$cleanUp$39702|

; 236  :     if (id > s_IndexList.MaxIndex()) goto cleanUp;

  0001c	e59f006c	 ldr         r0, [pc, #0x6C]
  00020	e5903088	 ldr         r3, [r0, #0x88]
  00024	e1510003	 cmp         r1, r3
  00028	8a000014	 bhi         |$cleanUp$39702|

; 237  : 
; 238  :     // get data node
; 239  :     pDataNode = s_IndexList.GetIndex(id);

  0002c	eb000000	 bl          |?GetIndex@?$IndexList@M@@QAAPAMK@Z|
  00030	e1b06000	 movs        r6, r0

; 240  :     if (pDataNode == NULL) goto cleanUp;

  00034	0a000011	 beq         |$cleanUp$39702|

; 241  : 
; 242  :     // determine new opm
; 243  :     constraintNew = *(float*)pParam;

  00038	e5954000	 ldr         r4, [r5]

; 244  :     if (CONSTRAINT_STATE_NULL == *(DWORD*)pParam)

  0003c	e1a02004	 mov         r2, r4
  00040	e3720801	 cmn         r2, #1, 16

; 245  :         {
; 246  :         constraintNew = IL_CONSTRAINT_NULL;

  00044	0a000003	 beq         |$LN21@INTRLAT_Up|
  00048	e3e03cff	 mvn         r3, #0xFF, 24

; 247  :         }
; 248  :     else if (CONSTRAINT_STATE_FLOOR == *(DWORD*)pParam)

  0004c	e22330fe	 eor         r3, r3, #0xFE
  00050	e1520003	 cmp         r2, r3
  00054	1a000001	 bne         |$LN4@INTRLAT_Up|
  00058		 |$LN21@INTRLAT_Up|
  00058	e3e03080	 mvn         r3, #0x80

; 249  :         {
; 250  :         constraintNew = IL_CONSTRAINT_NULL;

  0005c	e1a04b83	 mov         r4, r3, lsl #23
  00060		 |$LN4@INTRLAT_Up|

; 251  :         }
; 252  : 
; 253  :     // serialize access
; 254  :     Lock();

  00060	e59f0024	 ldr         r0, [pc, #0x24]
  00064	eb000000	 bl          EnterCriticalSection

; 255  :            
; 256  :     // process constraint message
; 257  :     switch (msg)

  00068	e3570001	 cmp         r7, #1

; 258  :         {
; 259  :         case CONSTRAINT_MSG_INTRLAT_REQUEST:
; 260  :             *pDataNode = constraintNew;

  0006c	05864000	 streq       r4, [r6]

; 261  :             break;
; 262  :         }
; 263  :     
; 264  :     // update operating mode
; 265  :     rc = UpdateConstraint();

  00070	eb000000	 bl          |?UpdateConstraint@@YAHXZ|
  00074	e1a04000	 mov         r4, r0

; 266  :     
; 267  :     Unlock();

  00078	e59f000c	 ldr         r0, [pc, #0xC]
  0007c	eb000000	 bl          LeaveCriticalSection
  00080		 |$cleanUp$39702|

; 268  : 
; 269  : cleanUp:
; 270  :     return rc;
; 271  : } 

  00080	e1a00004	 mov         r0, r4
  00084	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$LN25@INTRLAT_Up|
  0008c		 |$LN26@INTRLAT_Up|
  0008c	00000000	 DCD         |s_ilInfo|
  00090		 |$LN27@INTRLAT_Up|
  00090	00000000	 DCD         |s_IndexList|
  00094		 |$M40455|

			 ENDP  ; |?INTRLAT_UpdateConstraint@@YAHPAXK0I@Z|, INTRLAT_UpdateConstraint

	EXPORT	|?INTRLAT_CloseConstraint@@YAHPAX@Z|	; INTRLAT_CloseConstraint

  00000			 AREA	 |.pdata|, PDATA
|$T40494| DCD	|$LN22@INTRLAT_Cl|
	DCD	0x40002401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?INTRLAT_CloseConstraint@@YAHPAX@Z| PROC ; INTRLAT_CloseConstraint

; 283  : {

  00000		 |$LN22@INTRLAT_Cl|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M40491|

; 284  :     BOOL rc = FALSE;
; 285  :     float *pDataNode;    
; 286  :     DWORD id = (DWORD)hConstraintContext - 1;
; 287  : 
; 288  :     // validate
; 289  :     if (id > s_IndexList.MaxIndex()) goto cleanUp;

  00004	e59f5080	 ldr         r5, [pc, #0x80]
  00008	e2406001	 sub         r6, r0, #1
  0000c	e3a04000	 mov         r4, #0
  00010	e5953088	 ldr         r3, [r5, #0x88]
  00014	e1560003	 cmp         r6, r3
  00018	8a000017	 bhi         |$cleanUp$39727|

; 290  : 
; 291  :     // get data node
; 292  :     pDataNode = s_IndexList.GetIndex(id);

  0001c	e1a01006	 mov         r1, r6
  00020	e1a00005	 mov         r0, r5
  00024	eb000000	 bl          |?GetIndex@?$IndexList@M@@QAAPAMK@Z|
  00028	e3500000	 cmp         r0, #0

; 293  :     if (pDataNode == NULL) goto cleanUp;

  0002c	0a000012	 beq         |$cleanUp$39727|

; 294  : 
; 295  :     Lock();       

  00030	e59f0050	 ldr         r0, [pc, #0x50]
  00034	eb000000	 bl          EnterCriticalSection

; 296  :     s_IndexList.DeleteIndex(id);

  00038	e1b022a6	 movs        r2, r6, lsr #5
  0003c	0a000005	 beq         |$LN12@INTRLAT_Cl|
  00040		 |$LL13@INTRLAT_Cl|
  00040	e5953000	 ldr         r3, [r5]
  00044	e2422001	 sub         r2, r2, #1
  00048	e1b05003	 movs        r5, r3
  0004c	0a000006	 beq         |$LN14@INTRLAT_Cl|
  00050	e3520000	 cmp         r2, #0
  00054	1afffff9	 bne         |$LL13@INTRLAT_Cl|
  00058		 |$LN12@INTRLAT_Cl|
  00058	e5953004	 ldr         r3, [r5, #4]
  0005c	e206201f	 and         r2, r6, #0x1F
  00060	e3a01001	 mov         r1, #1
  00064	e1c33211	 bic         r3, r3, r1, lsl r2
  00068	e5853004	 str         r3, [r5, #4]
  0006c		 |$LN14@INTRLAT_Cl|

; 297  :     rc = UpdateConstraint();

  0006c	eb000000	 bl          |?UpdateConstraint@@YAHXZ|
  00070	e1a04000	 mov         r4, r0

; 298  :     Unlock();

  00074	e59f000c	 ldr         r0, [pc, #0xC]
  00078	eb000000	 bl          LeaveCriticalSection
  0007c		 |$cleanUp$39727|

; 299  :     
; 300  : cleanUp:    
; 301  :     return rc;
; 302  : } 

  0007c	e1a00004	 mov         r0, r4
  00080	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00084	e12fff1e	 bx          lr
  00088		 |$LN23@INTRLAT_Cl|
  00088		 |$LN24@INTRLAT_Cl|
  00088	00000000	 DCD         |s_ilInfo|
  0008c		 |$LN25@INTRLAT_Cl|
  0008c	00000000	 DCD         |s_IndexList|
  00090		 |$M40492|

			 ENDP  ; |?INTRLAT_CloseConstraint@@YAHPAX@Z|, INTRLAT_CloseConstraint

	IMPORT	|atexit|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\pm\inc\indexlist.h

  00000			 AREA	 |.pdata|, PDATA
|$T40507| DCD	|$LN7@dynamic|
	DCD	0x40000e01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\pm\constraintadapters\interruptlatencyconstraint\intrlatencyconstraint.cpp

  00000			 AREA	 |.text$yc|, CODE, ARM

  00000		 |??__Es_IndexList@@YAXXZ| PROC		; `dynamic initializer for 's_IndexList''

; 48   : static IndexList<float>                 s_IndexList;

  00000		 |$LN7@dynamic|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M40504|
  00004	e59f4028	 ldr         r4, [pc, #0x28]
  00008	e3a02088	 mov         r2, #0x88
  0000c	e3a01000	 mov         r1, #0
  00010	e1a00004	 mov         r0, r4
  00014	eb000000	 bl          memset
  00018	e59f0010	 ldr         r0, [pc, #0x10]
  0001c	e3a0301f	 mov         r3, #0x1F
  00020	e5843088	 str         r3, [r4, #0x88]
  00024	eb000000	 bl          atexit
  00028	e8bd4010	 ldmia       sp!, {r4, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$LN8@dynamic|
  00030		 |$LN9@dynamic|
  00030	00000000	 DCD         |??__Fs_IndexList@@YAXXZ|
  00034		 |$LN10@dynamic|
  00034	00000000	 DCD         |s_IndexList|
  00038		 |$M40505|

			 ENDP  ; |??__Es_IndexList@@YAXXZ|, `dynamic initializer for 's_IndexList''


  00000			 AREA	 |.pdata|, PDATA
|$T40531| DCD	|$LN12@dynamic@2|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text$yd|, CODE, ARM

  00000		 |??__Fs_IndexList@@YAXXZ| PROC		; `dynamic atexit destructor for 's_IndexList''
  00000		 |$LN12@dynamic@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M40528|
  00004	e59f3020	 ldr         r3, [pc, #0x20]
  00008	e5934000	 ldr         r4, [r3]
  0000c	ea000002	 b           |$LN9@dynamic@2|
  00010		 |$LL4@dynamic@2|
  00010	e1a00004	 mov         r0, r4
  00014	e5944000	 ldr         r4, [r4]
  00018	eb000000	 bl          |??3@YAXPAX@Z|
  0001c		 |$LN9@dynamic@2|
  0001c	e3540000	 cmp         r4, #0
  00020	1afffffa	 bne         |$LL4@dynamic@2|
  00024	e8bd4010	 ldmia       sp!, {r4, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$LN13@dynamic@2|
  0002c		 |$LN14@dynamic@2|
  0002c	00000000	 DCD         |s_IndexList|
  00030		 |$M40529|

			 ENDP  ; |??__Fs_IndexList@@YAXXZ|, `dynamic atexit destructor for 's_IndexList''


  00030			 AREA	 |.bss|, NOINIT
|s_IndexList| %	0x8c

  00000			 AREA	 |.CRT$XCU|, DATA
|s_IndexList$initializer$| DCD |??__Es_IndexList@@YAXXZ|
	END
