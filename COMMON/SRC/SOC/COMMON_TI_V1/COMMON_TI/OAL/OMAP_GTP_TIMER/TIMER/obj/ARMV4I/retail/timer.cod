; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\OAL\OMAP_GTP_TIMER\TIMER\timer.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|timer_posted_pending_bit| [ DATA ]
	EXPORT	|g_wakeupLatencyConstraintTickCount| [ DATA ]

  00000			 AREA	 |.data|, DATA
	 COMMON	|g_TimerDevice|, 0x4

	 COMMON	|g_oalTimerContext|, 0x20

	 COMMON	|g_pTimerRegs|, 0x4


  00000			 AREA	 |.bss|, NOINIT
|?_max@?1??OEMIdle@@9@9| % 0x4				; `OEMIdle'::`2'::_max
|?_count@?1??OEMIdle@@9@9| % 0x4			; `OEMIdle'::`2'::_count

  00000			 AREA	 |.data|, DATA
|timer_posted_pending_bit| DCD 0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x1
	DCD	0x2
	DCD	0x4
	DCD	0x8
	DCD	0x0
	DCD	0x10
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x20
	DCD	0x40
	DCD	0x80
	DCD	0x100
	DCD	0x200
|g_wakeupLatencyConstraintTickCount| DCD 0x7fffffff

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|OALTimerGetReg|
	EXPORT	|??_C@_1EA@BFGMCCBB@?$AA?$AN?$AA?6?$AA?5?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAG?$AAe?$AAt?$AAR?$AAe?$AAg?$AA?3?$AA?5?$AAw?$AAa?$AAi?$AAt?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|NKDbgPrintfW|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\oal\omap_gtp_timer\timer\timer.c

  00000			 AREA	 |.pdata|, PDATA
|$T46016| DCD	|$LN13@OALTimerGe|
	DCD	0x40001e01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EA@BFGMCCBB@?$AA?$AN?$AA?6?$AA?5?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAG?$AAe?$AAt?$AAR?$AAe?$AAg?$AA?3?$AA?5?$AAw?$AAa?$AAi?$AAt?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB 0xd
	DCB	0x0, 0xa, 0x0, " ", 0x0, "O", 0x0, "A", 0x0, "L", 0x0, "T"
	DCB	0x0, "i", 0x0, "m", 0x0, "e", 0x0, "r", 0x0, "G", 0x0, "e"
	DCB	0x0, "t", 0x0, "R", 0x0, "e", 0x0, "g", 0x0, ":", 0x0, " "
	DCB	0x0, "w", 0x0, "a", 0x0, "i", 0x0, "t", 0x0, " ", 0x0, "t"
	DCB	0x0, "i", 0x0, "m", 0x0, "e", 0x0, "o", 0x0, "u", 0x0, "t"
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALTimerGetReg| PROC

; 154  : {

  00000		 |$LN13@OALTimerGe|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M46013|
  00004	e1a04000	 mov         r4, r0

; 155  :     UINT32 i=0;
; 156  : 
; 157  :     if(g_oalTimerContext.Posted)

  00008	e59f3064	 ldr         r3, [pc, #0x64]
  0000c	e3a0e000	 mov         lr, #0
  00010	e5933018	 ldr         r3, [r3, #0x18]
  00014	e3530000	 cmp         r3, #0
  00018	0a00000f	 beq         |$LN2@OALTimerGe|

; 158  :         while(INREG32(&g_pTimerRegs->TWPS) & timer_posted_pending_bit[((UINT32)addr&0xff)>>2]) 

  0001c	e59f304c	 ldr         r3, [pc, #0x4C]
  00020	e59f1044	 ldr         r1, [pc, #0x44]
  00024	e1a02c04	 mov         r2, r4, lsl #24
  00028	e5930000	 ldr         r0, [r3]
  0002c	e1a03d22	 mov         r3, r2, lsr #26
  00030	e7912103	 ldr         r2, [r1, +r3, lsl #2]
  00034	ea000002	 b           |$LN10@OALTimerGe|
  00038		 |$LL3@OALTimerGe|

; 159  : 		if(i++>TIMER_POSTED_TIMEOUT)

  00038	e35e0ffa	 cmp         lr, #0xFA, 30
  0003c	e28ee001	 add         lr, lr, #1
  00040	8a000003	 bhi         |$LN8@OALTimerGe|
  00044		 |$LN10@OALTimerGe|
  00044	e5903034	 ldr         r3, [r0, #0x34]
  00048	e1130002	 tst         r3, r2
  0004c	1afffff9	 bne         |$LL3@OALTimerGe|
  00050	ea000001	 b           |$LN2@OALTimerGe|
  00054		 |$LN8@OALTimerGe|

; 160  : 		{
; 161  : 		    RETAILMSG(1, (L"\r\n OALTimerGetReg: wait timeout"));

  00054	e59f000c	 ldr         r0, [pc, #0xC]
  00058	eb000000	 bl          NKDbgPrintfW
  0005c		 |$LN2@OALTimerGe|

; 162  : 		    break;
; 163  : 	       }
; 164  :     
; 165  :     return INREG32(addr);

  0005c	e5940000	 ldr         r0, [r4]

; 166  :     
; 167  : }

  00060	e8bd4010	 ldmia       sp!, {r4, lr}
  00064	e12fff1e	 bx          lr
  00068		 |$LN14@OALTimerGe|
  00068		 |$LN15@OALTimerGe|
  00068	00000000	 DCD         |??_C@_1EA@BFGMCCBB@?$AA?$AN?$AA?6?$AA?5?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAG?$AAe?$AAt?$AAR?$AAe?$AAg?$AA?3?$AA?5?$AAw?$AAa?$AAi?$AAt?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
  0006c		 |$LN16@OALTimerGe|
  0006c	00000000	 DCD         |timer_posted_pending_bit|
  00070		 |$LN17@OALTimerGe|
  00070	00000000	 DCD         |g_pTimerRegs|
  00074		 |$LN18@OALTimerGe|
  00074	00000000	 DCD         |g_oalTimerContext|
  00078		 |$M46014|

			 ENDP  ; |OALTimerGetReg|

	EXPORT	|OALTimerSetReg|
	EXPORT	|??_C@_1EA@OPCPFCAE@?$AA?$AN?$AA?6?$AA?5?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAS?$AAe?$AAt?$AAR?$AAe?$AAg?$AA?3?$AA?5?$AAw?$AAa?$AAi?$AAt?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T46035| DCD	|$LN13@OALTimerSe|
	DCD	0x40001f01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EA@OPCPFCAE@?$AA?$AN?$AA?6?$AA?5?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAS?$AAe?$AAt?$AAR?$AAe?$AAg?$AA?3?$AA?5?$AAw?$AAa?$AAi?$AAt?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB 0xd
	DCB	0x0, 0xa, 0x0, " ", 0x0, "O", 0x0, "A", 0x0, "L", 0x0, "T"
	DCB	0x0, "i", 0x0, "m", 0x0, "e", 0x0, "r", 0x0, "S", 0x0, "e"
	DCB	0x0, "t", 0x0, "R", 0x0, "e", 0x0, "g", 0x0, ":", 0x0, " "
	DCB	0x0, "w", 0x0, "a", 0x0, "i", 0x0, "t", 0x0, " ", 0x0, "t"
	DCB	0x0, "i", 0x0, "m", 0x0, "e", 0x0, "o", 0x0, "u", 0x0, "t"
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALTimerSetReg| PROC

; 177  : {

  00000		 |$LN13@OALTimerSe|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M46032|
  00004	e1a06001	 mov         r6, r1
  00008	e1a05000	 mov         r5, r0

; 178  :     UINT32 i=0;
; 179  : 
; 180  :     if(g_oalTimerContext.Posted)

  0000c	e59f3064	 ldr         r3, [pc, #0x64]
  00010	e3a04000	 mov         r4, #0
  00014	e5933018	 ldr         r3, [r3, #0x18]
  00018	e3530000	 cmp         r3, #0
  0001c	0a00000f	 beq         |$LN2@OALTimerSe|

; 181  :         while(INREG32(&g_pTimerRegs->TWPS) & timer_posted_pending_bit[((UINT32)addr&0xff)>>2]) 

  00020	e59f304c	 ldr         r3, [pc, #0x4C]
  00024	e59fe044	 ldr         lr, [pc, #0x44]
  00028	e1a02c05	 mov         r2, r5, lsl #24
  0002c	e5931000	 ldr         r1, [r3]
  00030	e1a03d22	 mov         r3, r2, lsr #26
  00034	e79e2103	 ldr         r2, [lr, +r3, lsl #2]
  00038	ea000002	 b           |$LN10@OALTimerSe|
  0003c		 |$LL3@OALTimerSe|

; 182  : 		if(i++>TIMER_POSTED_TIMEOUT) 

  0003c	e3540ffa	 cmp         r4, #0xFA, 30
  00040	e2844001	 add         r4, r4, #1
  00044	8a000003	 bhi         |$LN8@OALTimerSe|
  00048		 |$LN10@OALTimerSe|
  00048	e5913034	 ldr         r3, [r1, #0x34]
  0004c	e1130002	 tst         r3, r2
  00050	1afffff9	 bne         |$LL3@OALTimerSe|
  00054	ea000001	 b           |$LN2@OALTimerSe|
  00058		 |$LN8@OALTimerSe|

; 183  : 		{
; 184  : 		    RETAILMSG(1, (L"\r\n OALTimerSetReg: wait timeout"));

  00058	e59f000c	 ldr         r0, [pc, #0xC]
  0005c	eb000000	 bl          NKDbgPrintfW
  00060		 |$LN2@OALTimerSe|

; 185  : 		    break;
; 186  : 	       }
; 187  :     OUTREG32(addr, val);

  00060	e5856000	 str         r6, [r5]

; 188  : }

  00064	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00068	e12fff1e	 bx          lr
  0006c		 |$LN14@OALTimerSe|
  0006c		 |$LN15@OALTimerSe|
  0006c	00000000	 DCD         |??_C@_1EA@OPCPFCAE@?$AA?$AN?$AA?6?$AA?5?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAS?$AAe?$AAt?$AAR?$AAe?$AAg?$AA?3?$AA?5?$AAw?$AAa?$AAi?$AAt?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
  00070		 |$LN16@OALTimerSe|
  00070	00000000	 DCD         |timer_posted_pending_bit|
  00074		 |$LN17@OALTimerSe|
  00074	00000000	 DCD         |g_pTimerRegs|
  00078		 |$LN18@OALTimerSe|
  00078	00000000	 DCD         |g_oalTimerContext|
  0007c		 |$M46033|

			 ENDP  ; |OALTimerSetReg|

	EXPORT	|OALTimerStart|

  00000			 AREA	 |.pdata|, PDATA
|$T46051| DCD	|$LN13@OALTimerSt|
	DCD	0x40001c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALTimerStart| PROC

; 197  : {

  00000		 |$LN13@OALTimerSt|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M46048|

; 198  :     UINT32 i;
; 199  :     UINT tcrrExit = 0;
; 200  : 
; 201  :     // Enable match interrupt
; 202  :     OALTimerSetReg(&g_pTimerRegs->TIER, GPTIMER_TIER_MATCH);

  00004	e59f4060	 ldr         r4, [pc, #0x60]
  00008	e3a01001	 mov         r1, #1
  0000c	e5943000	 ldr         r3, [r4]
  00010	e283001c	 add         r0, r3, #0x1C
  00014	eb000000	 bl          OALTimerSetReg

; 203  : 	
; 204  :     OALTimerSetReg(&g_pTimerRegs->TCLR, OALTimerGetReg(&g_pTimerRegs->TCLR) | GPTIMER_TCLR_ST);

  00018	e5943000	 ldr         r3, [r4]
  0001c	e2830024	 add         r0, r3, #0x24
  00020	eb000000	 bl          OALTimerGetReg
  00024	e5943000	 ldr         r3, [r4]
  00028	e3801001	 orr         r1, r0, #1
  0002c	e2830024	 add         r0, r3, #0x24
  00030	eb000000	 bl          OALTimerSetReg

; 205  :     for (i = 0; i < 0x100; i++)
; 206  :     {
; 207  :     }
; 208  :     // get current TCRR value: workaround for errata 1.35
; 209  :     OALTimerGetReg(&g_pTimerRegs->TCRR);

  00034	e5943000	 ldr         r3, [r4]
  00038	e2830028	 add         r0, r3, #0x28
  0003c	eb000000	 bl          OALTimerGetReg

; 210  :     tcrrExit = OALTimerGetReg(&g_pTimerRegs->TCRR);

  00040	e5943000	 ldr         r3, [r4]
  00044	e2830028	 add         r0, r3, #0x28
  00048	eb000000	 bl          OALTimerGetReg
  0004c	e1a05000	 mov         r5, r0
  00050		 |$LL2@OALTimerSt|

; 211  :     // ERRATA 1.31 workaround (ES 1.0 only)
; 212  :     // wait for updated TCRR value
; 213  :     while (tcrrExit == (OALTimerGetReg(&g_pTimerRegs->TCRR)));	

  00050	e5943000	 ldr         r3, [r4]
  00054	e2830028	 add         r0, r3, #0x28
  00058	eb000000	 bl          OALTimerGetReg
  0005c	e1550000	 cmp         r5, r0
  00060	0afffffa	 beq         |$LL2@OALTimerSt|

; 214  : }

  00064	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00068	e12fff1e	 bx          lr
  0006c		 |$LN14@OALTimerSt|
  0006c		 |$LN15@OALTimerSt|
  0006c	00000000	 DCD         |g_pTimerRegs|
  00070		 |$M46049|

			 ENDP  ; |OALTimerStart|

	EXPORT	|OALTimerStop|

  00000			 AREA	 |.pdata|, PDATA
|$T46060| DCD	|$LN5@OALTimerSt@2|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALTimerStop| PROC

; 222  : {

  00000		 |$LN5@OALTimerSt@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M46057|

; 223  :     // stop GPTIMER1
; 224  :     OALTimerSetReg(&g_pTimerRegs->TCLR, OALTimerGetReg(&g_pTimerRegs->TCLR) & ~(GPTIMER_TCLR_ST));

  00004	e59f4024	 ldr         r4, [pc, #0x24]
  00008	e5943000	 ldr         r3, [r4]
  0000c	e2830024	 add         r0, r3, #0x24
  00010	eb000000	 bl          OALTimerGetReg
  00014	e5942000	 ldr         r2, [r4]
  00018	e1a03000	 mov         r3, r0
  0001c	e3c31001	 bic         r1, r3, #1
  00020	e2820024	 add         r0, r2, #0x24
  00024	eb000000	 bl          OALTimerSetReg

; 225  : }

  00028	e8bd4010	 ldmia       sp!, {r4, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$LN6@OALTimerSt@2|
  00030		 |$LN7@OALTimerSt@2|
  00030	00000000	 DCD         |g_pTimerRegs|
  00034		 |$M46058|

			 ENDP  ; |OALTimerStop|

	EXPORT	|UpdatePeriod|
	EXPORT	|OALTimerSetCompare|

  00000			 AREA	 |.pdata|, PDATA
|$T46077| DCD	|$LN15@OALTimerSe@2|
	DCD	0x40001001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALTimerSetCompare| PROC

; 232  : {

  00000		 |$LN15@OALTimerSe@2|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M46074|
  00004	e1a05000	 mov         r5, r0

; 233  : 
; 234  :     OALTimerSetReg(&g_pTimerRegs->TMAR, compare);

  00008	e59f402c	 ldr         r4, [pc, #0x2C]
  0000c	e1a01005	 mov         r1, r5
  00010	e5943000	 ldr         r3, [r4]
  00014	e2830038	 add         r0, r3, #0x38
  00018	eb000000	 bl          OALTimerSetReg

; 235  : 
; 236  : 	// We commented out the following line because it causes issues to the overall performance
; 237  : 	// of the system. As the tick timer is clocked at 32 kHz, the TMAR register takes some 
; 238  : 	// time to update and we loose this time waiting for it. The consequence is that we spend
; 239  : 	// more than 5% of the time in this loop where the CPU should actually be idle. Not waiting
; 240  : 	// should not have any consequence as we never actually read its value.
; 241  : 	//
; 242  :     //while ((INREG32(&g_pTimerRegs->TWPS) & GPTIMER_TWPS_TMAR) != 0);
; 243  : 
; 244  :     // make sure we don't set next timer interrupt to the past
; 245  :     //
; 246  :     if (compare < OALTimerGetReg(&g_pTimerRegs->TCRR)) UpdatePeriod(1);

  0001c	e5943000	 ldr         r3, [r4]
  00020	e2830028	 add         r0, r3, #0x28
  00024	eb000000	 bl          OALTimerGetReg
  00028	e1550000	 cmp         r5, r0
  0002c	33a00001	 movcc       r0, #1
  00030	3b000000	 blcc        UpdatePeriod

; 247  : }

  00034	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$LN16@OALTimerSe@2|
  0003c		 |$LN17@OALTimerSe@2|
  0003c	00000000	 DCD         |g_pTimerRegs|
  00040		 |$M46075|

			 ENDP  ; |OALTimerSetCompare|

	EXPORT	|OEMIdle|
	IMPORT	|g_pNKGlobal|
	IMPORT	|PrcmProfilePrevPowerState|
	IMPORT	|PrcmProcessPostMpuWakeup|
	IMPORT	|PrcmCapturePrevPowerState|
	IMPORT	|OALWakeupLatency_PopState|
	IMPORT	|g_pCPUInfo|
	IMPORT	|OALWakeupLatency_PushState|
	IMPORT	|OALContextSave|
	IMPORT	|OALWakeupLatency_IsChipOff|
	IMPORT	|OEMWriteDebugLED|
	IMPORT	|OALWakeupLatency_FindStateByMaxDelayInTicks|
	IMPORT	|OALWakeupLatency_GetDelayInTicks|
	IMPORT	|OALWakeupLatency_GetCurrentState|
	IMPORT	|PrcmInitializePrevPowerState|
	IMPORT	|fnOALCPUIdle|

  00000			 AREA	 |.pdata|, PDATA
|$T46099| DCD	|$LN19@OEMIdle|
	DCD	0x40006101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OEMIdle| PROC

; 311  : {

  00000		 |$LN19@OEMIdle|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M46096|

; 312  :     static UINT _max = 0;
; 313  :     static UINT _count = 0;
; 314  : 
; 315  :     INT delta;
; 316  :     UINT tcrrTemp;
; 317  :     UINT tcrrEnter, tcrrExit;
; 318  :     UINT idleDelta, newIdleLow;
; 319  :     INT wakeupDelay;
; 320  :     INT maxDelay;
; 321  :     DWORD latencyState;    
; 322  : 
; 323  :     UNREFERENCED_PARAMETER(idleParam);
; 324  : 
; 325  :     PrcmInitializePrevPowerState();

  00004	eb000000	 bl          PrcmInitializePrevPowerState

; 326  : 
; 327  :     // How far are we from next timer interrupt
; 328  :     // If we are really near to timer interrupt do nothing...
; 329  :     latencyState = OALWakeupLatency_GetCurrentState();

  00008	eb000000	 bl          OALWakeupLatency_GetCurrentState

; 330  :     tcrrEnter = OALTimerGetReg(&g_pTimerRegs->TCRR);

  0000c	e59f716c	 ldr         r7, [pc, #0x16C]
  00010	e1a05000	 mov         r5, r0
  00014	e5973000	 ldr         r3, [r7]
  00018	e2830028	 add         r0, r3, #0x28
  0001c	eb000000	 bl          OALTimerGetReg

; 331  :     delta = g_oalTimerContext.match - tcrrEnter;

  00020	e59f8154	 ldr         r8, [pc, #0x154]
  00024	e1a09000	 mov         r9, r0
  00028	e5983014	 ldr         r3, [r8, #0x14]

; 332  :     if (delta < (INT32)g_oalTimerContext.margin) goto cleanUp;

  0002c	e5982004	 ldr         r2, [r8, #4]
  00030	e0434009	 sub         r4, r3, r9
  00034	e1540002	 cmp         r4, r2
  00038	ba000046	 blt         |$cleanUp$45867|

; 333  : 
; 334  :     // get latency time...
; 335  :     //
; 336  :     // check if current latency is greater than current requirements
; 337  :     maxDelay = min(delta, g_wakeupLatencyConstraintTickCount);

  0003c	e59f3134	 ldr         r3, [pc, #0x134]

; 338  :     wakeupDelay = OALWakeupLatency_GetDelayInTicks(latencyState);

  00040	e1a00005	 mov         r0, r5
  00044	e5933000	 ldr         r3, [r3]
  00048	e1540003	 cmp         r4, r3
  0004c	a1a04003	 movge       r4, r3
  00050	eb000000	 bl          OALWakeupLatency_GetDelayInTicks
  00054	e1a06000	 mov         r6, r0

; 339  :     if (maxDelay < wakeupDelay)

  00058	e1540006	 cmp         r4, r6
  0005c	aa000006	 bge         |$LN16@OEMIdle|

; 340  :     {
; 341  :         // check if current state meets timing constraint
; 342  :         latencyState = OALWakeupLatency_FindStateByMaxDelayInTicks(maxDelay);

  00060	e1a00004	 mov         r0, r4
  00064	eb000000	 bl          OALWakeupLatency_FindStateByMaxDelayInTicks
  00068	e1a05000	 mov         r5, r0

; 343  :         wakeupDelay = OALWakeupLatency_GetDelayInTicks(latencyState);

  0006c	eb000000	 bl          OALWakeupLatency_GetDelayInTicks
  00070	e1a06000	 mov         r6, r0

; 344  :     }
; 345  : 
; 346  :     // check one last time to make sure we aren't going to sleep longer than
; 347  :     if (maxDelay >= wakeupDelay)

  00074	e1540006	 cmp         r4, r6
  00078	ba000036	 blt         |$cleanUp$45867|
  0007c		 |$LN16@OEMIdle|

; 348  :     {
; 349  :         //  Indicate in idle
; 350  :         OALLED(LED_IDX_IDLE, 1);

  0007c	e3a01001	 mov         r1, #1
  00080	e3a0001e	 mov         r0, #0x1E
  00084	eb000000	 bl          OEMWriteDebugLED

; 351  :         
; 352  :         if (OALWakeupLatency_IsChipOff(latencyState))

  00088	e1a00005	 mov         r0, r5
  0008c	eb000000	 bl          OALWakeupLatency_IsChipOff
  00090	e3500000	 cmp         r0, #0
  00094	0a000002	 beq         |$LN6@OEMIdle|

; 353  :         {
; 354  :             if (!OALContextSave())

  00098	eb000000	 bl          OALContextSave
  0009c	e3500000	 cmp         r0, #0
  000a0	0a00002c	 beq         |$cleanUp$45867|
  000a4		 |$LN6@OEMIdle|

; 355  :             {
; 356  :                 // Context Save Failed
; 357  :                 goto cleanUp;
; 358  :             }
; 359  :         }
; 360  :         // account for wakeup latency
; 361  :         OALWakeupLatency_PushState(latencyState);

  000a4	e1a00005	 mov         r0, r5
  000a8	eb000000	 bl          OALWakeupLatency_PushState

; 362  :         g_oalTimerContext.match -= wakeupDelay;

  000ac	e5983014	 ldr         r3, [r8, #0x14]
  000b0	e0433006	 sub         r3, r3, r6
  000b4	e5883014	 str         r3, [r8, #0x14]

; 363  :         OALTimerSetCompare(g_oalTimerContext.match);

  000b8	e5980014	 ldr         r0, [r8, #0x14]
  000bc	eb000000	 bl          OALTimerSetCompare

; 364  :     }
; 365  :     else
; 366  :     {
; 367  :         goto cleanUp;
; 368  :     }
; 369  : 
; 370  :     // Move SoC/CPU to idle mode    
; 371  :     fnOALCPUIdle(g_pCPUInfo);

  000c0	e59f30ac	 ldr         r3, [pc, #0xAC]
  000c4	e59f20a4	 ldr         r2, [pc, #0xA4]
  000c8	e5930000	 ldr         r0, [r3]
  000cc	e5923000	 ldr         r3, [r2]
  000d0	e1a0e00f	 mov         lr, pc
  000d4	e12fff13	 bx          r3

; 372  :     
; 373  :     // restore latency state
; 374  :     OALWakeupLatency_PopState();

  000d8	eb000000	 bl          OALWakeupLatency_PopState

; 375  :     
; 376  :     PrcmCapturePrevPowerState();

  000dc	eb000000	 bl          PrcmCapturePrevPowerState

; 377  : 
; 378  :     // get current TCRR value: workaround for errata 1.35
; 379  :     OALTimerGetReg(&g_pTimerRegs->TCRR);

  000e0	e5973000	 ldr         r3, [r7]
  000e4	e2830028	 add         r0, r3, #0x28
  000e8	eb000000	 bl          OALTimerGetReg

; 380  :     tcrrExit = OALTimerGetReg(&g_pTimerRegs->TCRR);

  000ec	e5973000	 ldr         r3, [r7]
  000f0	e2830028	 add         r0, r3, #0x28
  000f4	eb000000	 bl          OALTimerGetReg
  000f8	e1a04000	 mov         r4, r0

; 381  : 
; 382  :     PrcmProcessPostMpuWakeup();

  000fc	eb000000	 bl          PrcmProcessPostMpuWakeup
  00100		 |$LL4@OEMIdle|

; 383  : 
; 384  :     // ERRATA 1.31 workaround
; 385  :     do
; 386  :     {
; 387  :         tcrrTemp = OALTimerGetReg(&g_pTimerRegs->TCRR);

  00100	e5973000	 ldr         r3, [r7]
  00104	e2830028	 add         r0, r3, #0x28
  00108	eb000000	 bl          OALTimerGetReg

; 388  :     }
; 389  :     while (tcrrTemp == tcrrExit);

  0010c	e1500004	 cmp         r0, r4
  00110	0afffffa	 beq         |$LL4@OEMIdle|

; 390  : 
; 391  :     PrcmProfilePrevPowerState(tcrrTemp, wakeupDelay);

  00114	e1a01006	 mov         r1, r6
  00118	eb000000	 bl          PrcmProfilePrevPowerState

; 392  : 
; 393  :     // Update idle counter
; 394  :     idleDelta = OALTimerGetReg(&g_pTimerRegs->TCRR) - tcrrEnter;

  0011c	e5973000	 ldr         r3, [r7]
  00120	e2830028	 add         r0, r3, #0x28
  00124	eb000000	 bl          OALTimerGetReg

; 395  :     newIdleLow = curridlelow + idleDelta;

  00128	e59fe03c	 ldr         lr, [pc, #0x3C]
  0012c	e0401009	 sub         r1, r0, r9
  00130	e59e0000	 ldr         r0, [lr]
  00134	e59030d0	 ldr         r3, [r0, #0xD0]

; 396  :     if (newIdleLow < curridlelow) 

  00138	e59020d0	 ldr         r2, [r0, #0xD0]
  0013c	e0831001	 add         r1, r3, r1
  00140	e1510002	 cmp         r1, r2

; 397  : 	    curridlehigh++;

  00144	359030d4	 ldrcc       r3, [r0, #0xD4]
  00148	32833001	 addcc       r3, r3, #1
  0014c	358030d4	 strcc       r3, [r0, #0xD4]
  00150	359e0000	 ldrcc       r0, [lr]

; 398  :     curridlelow = newIdleLow;

  00154	e58010d0	 str         r1, [r0, #0xD0]
  00158		 |$cleanUp$45867|

; 399  : 
; 400  : cleanUp:
; 401  :     OALLED(LED_IDX_IDLE, 0);

  00158	e3a01000	 mov         r1, #0
  0015c	e3a0001e	 mov         r0, #0x1E
  00160	eb000000	 bl          OEMWriteDebugLED

; 402  :     return;    
; 403  : }

  00164	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00168	e12fff1e	 bx          lr
  0016c		 |$LN20@OEMIdle|
  0016c		 |$LN21@OEMIdle|
  0016c	00000000	 DCD         |g_pNKGlobal|
  00170		 |$LN22@OEMIdle|
  00170	00000000	 DCD         |fnOALCPUIdle|
  00174		 |$LN23@OEMIdle|
  00174	00000000	 DCD         |g_pCPUInfo|
  00178		 |$LN24@OEMIdle|
  00178	00000000	 DCD         |g_wakeupLatencyConstraintTickCount|
  0017c		 |$LN25@OEMIdle|
  0017c	00000000	 DCD         |g_oalTimerContext|
  00180		 |$LN26@OEMIdle|
  00180	00000000	 DCD         |g_pTimerRegs|
  00184		 |$M46097|

			 ENDP  ; |OEMIdle|

	EXPORT	|OALTimerGetCount|

  00000			 AREA	 |.pdata|, PDATA
|$T46115| DCD	|$LN5@OALTimerGe@2|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALTimerGetCount| PROC

; 660  : {

  00000		 |$LN5@OALTimerGe@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46112|

; 661  :     //  Return the timer value
; 662  :     return OALTimerGetReg(&g_pTimerRegs->TCRR);

  00004	e59f3010	 ldr         r3, [pc, #0x10]
  00008	e5933000	 ldr         r3, [r3]
  0000c	e2830028	 add         r0, r3, #0x28
  00010	eb000000	 bl          OALTimerGetReg

; 663  : }

  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$LN6@OALTimerGe@2|
  0001c		 |$LN7@OALTimerGe@2|
  0001c	00000000	 DCD         |g_pTimerRegs|
  00020		 |$M46113|

			 ENDP  ; |OALTimerGetCount|

	EXPORT	|OALTimerCountsSinceSysTick|

  00000			 AREA	 |.pdata|, PDATA
|$T46126| DCD	|$LN5@OALTimerCo|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALTimerCountsSinceSysTick| PROC

; 670  : {

  00000		 |$LN5@OALTimerCo|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46123|

; 671  :     // Return timer ticks since last interrupt
; 672  :     return (INT32)(OALTimerGetReg(&g_pTimerRegs->TCRR) - g_oalTimerContext.base);

  00004	e59f3020	 ldr         r3, [pc, #0x20]
  00008	e5933000	 ldr         r3, [r3]
  0000c	e2830028	 add         r0, r3, #0x28
  00010	eb000000	 bl          OALTimerGetReg
  00014	e59f300c	 ldr         r3, [pc, #0xC]
  00018	e5933010	 ldr         r3, [r3, #0x10]
  0001c	e0400003	 sub         r0, r0, r3

; 673  : }

  00020	e49de004	 ldr         lr, [sp], #4
  00024	e12fff1e	 bx          lr
  00028		 |$LN6@OALTimerCo|
  00028		 |$LN7@OALTimerCo|
  00028	00000000	 DCD         |g_oalTimerContext|
  0002c		 |$LN8@OALTimerCo|
  0002c	00000000	 DCD         |g_pTimerRegs|
  00030		 |$M46124|

			 ENDP  ; |OALTimerCountsSinceSysTick|

	EXPORT	|OALGetTickCount|

  00000			 AREA	 |.pdata|, PDATA
|$T46138| DCD	|$LN5@OALGetTick|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALGetTickCount| PROC

; 688  : {

  00000		 |$LN5@OALGetTick|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46135|

; 689  :     UINT64 tickCount = OALTimerGetReg(&g_pTimerRegs->TCRR);

  00004	e59f3020	 ldr         r3, [pc, #0x20]
  00008	e5933000	 ldr         r3, [r3]
  0000c	e2830028	 add         r0, r3, #0x28
  00010	eb000000	 bl          OALTimerGetReg

; 690  :     //  Returns number of 1 msec ticks
; 691  :     return (UINT32) TICK_TO_MSEC(tickCount);

  00014	e3a03ffa	 mov         r3, #0xFA, 30
  00018	e0832390	 umull       r2, r3, r0, r3
  0001c	e1a03883	 mov         r3, r3, lsl #17
  00020	e18307a2	 orr         r0, r3, r2, lsr #15

; 692  : }

  00024	e49de004	 ldr         lr, [sp], #4
  00028	e12fff1e	 bx          lr
  0002c		 |$LN6@OALGetTick|
  0002c		 |$LN7@OALGetTick|
  0002c	00000000	 DCD         |g_pTimerRegs|
  00030		 |$M46136|

			 ENDP  ; |OALGetTickCount|

	EXPORT	|OEMGetTickCount|

  00000			 AREA	 |.pdata|, PDATA
|$T46156| DCD	|$LN11@OEMGetTick|
	DCD	0x40002401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OEMGetTickCount| PROC

; 706  : {

  00000		 |$LN11@OEMGetTick|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M46153|
  00004	e59f5080	 ldr         r5, [pc, #0x80]
  00008	e59f4078	 ldr         r4, [pc, #0x78]
  0000c		 |$LL3@OEMGetTick|

; 707  :     UINT64 baseCounts;
; 708  :     UINT32 offset;
; 709  : 
; 710  :     // This code adjusts the accuracy of the returned value to the nearest
; 711  :     // MSec when the system tick exceeds 1 ms. The following code checks if
; 712  :     // a system timer interrupt occurred between reading the CurMSec value
; 713  :     // and the call to fetch the HiResTicksSinceSysTick. If so, the value of
; 714  :     // CurMSec and Offset is re-read, with the certainty that a system timer
; 715  :     // interrupt will not occur again.
; 716  :     do
; 717  :         {
; 718  :         baseCounts = g_oalTimerContext.curCounts;
; 719  :         offset = OALTimerGetCount() - g_oalTimerContext.base;

  0000c	e5953000	 ldr         r3, [r5]
  00010	e5947008	 ldr         r7, [r4, #8]
  00014	e594600c	 ldr         r6, [r4, #0xC]
  00018	e2830028	 add         r0, r3, #0x28
  0001c	eb000000	 bl          OALTimerGetReg
  00020	e5942010	 ldr         r2, [r4, #0x10]

; 720  :         }
; 721  :     while (baseCounts != g_oalTimerContext.curCounts);

  00024	e5943008	 ldr         r3, [r4, #8]
  00028	e594100c	 ldr         r1, [r4, #0xC]
  0002c	e040e002	 sub         lr, r0, r2
  00030	e1570003	 cmp         r7, r3
  00034	1afffff4	 bne         |$LL3@OEMGetTick|
  00038	e1560001	 cmp         r6, r1
  0003c	1afffff2	 bne         |$LL3@OEMGetTick|

; 722  : 
; 723  : 
; 724  :    //  Update CurMSec (kernel uses both CurMSec and GetTickCount() at different places) and return msec tick count
; 725  :     CurMSec = (UINT32)TICK_TO_MSEC(baseCounts + offset);

  00040	e3a03ffa	 mov         r3, #0xFA, 30
  00044	e0830397	 umull       r0, r3, r7, r3
  00048	e3a02ffa	 mov         r2, #0xFA, 30
  0004c	e081229e	 umull       r2, r1, lr, r2
  00050	e3a0effa	 mov         lr, #0xFA, 30
  00054	e0233e96	 mla         r3, r6, lr, r3
  00058	e0922000	 adds        r2, r2, r0
  0005c	e0a13003	 adc         r3, r1, r3
  00060	e59fe01c	 ldr         lr, [pc, #0x1C]
  00064	e1a03883	 mov         r3, r3, lsl #17
  00068	e18337a2	 orr         r3, r3, r2, lsr #15
  0006c	e59e1000	 ldr         r1, [lr]
  00070	e58130c8	 str         r3, [r1, #0xC8]

; 726  : 
; 727  :     return CurMSec;

  00074	e59e3000	 ldr         r3, [lr]
  00078	e59300c8	 ldr         r0, [r3, #0xC8]

; 728  : 
; 729  : }

  0007c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00080	e12fff1e	 bx          lr
  00084		 |$LN12@OEMGetTick|
  00084		 |$LN13@OEMGetTick|
  00084	00000000	 DCD         |g_pNKGlobal|
  00088		 |$LN14@OEMGetTick|
  00088	00000000	 DCD         |g_oalTimerContext|
  0008c		 |$LN15@OEMGetTick|
  0008c	00000000	 DCD         |g_pTimerRegs|
  00090		 |$M46154|

			 ENDP  ; |OEMGetTickCount|

	IMPORT	|__rt_udiv64by64|

  00000			 AREA	 |.pdata|, PDATA
|$T46179| DCD	|$LN10@UpdatePeri|
	DCD	0x40002601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UpdatePeriod| PROC

; 258  : {

  00000		 |$LN10@UpdatePeri|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M46176|
  00004	e1a04000	 mov         r4, r0

; 259  :     UINT32 period, match;
; 260  :     INT32 delta;
; 261  :     UINT64 offsetMSec = periodMSec;
; 262  :     UINT64 tickCount = OALGetTickCount();

  00008	eb000000	 bl          OALGetTickCount
  0000c	e1a05000	 mov         r5, r0

; 263  :     INT nDelay;
; 264  : 
; 265  :     // Calculate count difference
; 266  :     period = (UINT32)MSEC_TO_TICK(offsetMSec);

  00010	e1a00604	 mov         r0, r4, lsl #12
  00014	e1a01a24	 mov         r1, r4, lsr #20
  00018	e3a0207d	 mov         r2, #0x7D
  0001c	e3a03000	 mov         r3, #0
  00020	e3a06000	 mov         r6, #0
  00024	eb000000	 bl          __rt_udiv64by64
  00028	e2804001	 add         r4, r0, #1

; 267  : 
; 268  :     nDelay = min(period, DELTA_TIME);
; 269  :     // This is compare value
; 270  :     match = ((UINT32)MSEC_TO_TICK(tickCount)) + nDelay;

  0002c	e1a03606	 mov         r3, r6, lsl #12
  00030	e3540014	 cmp         r4, #0x14
  00034	e1831a25	 orr         r1, r3, r5, lsr #20
  00038	e1a00605	 mov         r0, r5, lsl #12
  0003c	e3a0207d	 mov         r2, #0x7D
  00040	e3a03000	 mov         r3, #0
  00044	23a04014	 movcs       r4, #0x14
  00048	eb000000	 bl          __rt_udiv64by64

; 271  : 
; 272  :     delta = (INT32)(OALTimerGetCount()+ g_oalTimerContext.margin - match);

  0004c	e59f3040	 ldr         r3, [pc, #0x40]
  00050	e0842000	 add         r2, r4, r0
  00054	e2824001	 add         r4, r2, #1
  00058	e5933000	 ldr         r3, [r3]
  0005c	e2830028	 add         r0, r3, #0x28
  00060	eb000000	 bl          OALTimerGetReg
  00064	e59f1024	 ldr         r1, [pc, #0x24]

; 273  : 
; 274  :     // If we are behind, issue interrupt as soon as possible
; 275  :     if (delta > 0)

  00068	e0402004	 sub         r2, r0, r4
  0006c	e5913004	 ldr         r3, [r1, #4]
  00070	e0823003	 add         r3, r2, r3
  00074	e3530000	 cmp         r3, #0

; 276  :     {
; 277  :         match += MSEC_TO_TICK(1);

  00078	c2844021	 addgt       r4, r4, #0x21

; 278  :     }
; 279  : 
; 280  :     // Save off match value
; 281  :     g_oalTimerContext.match = match;
; 282  : 
; 283  :     // Set timer match value
; 284  :     OALTimerSetCompare(match);

  0007c	e1a00004	 mov         r0, r4
  00080	e5814014	 str         r4, [r1, #0x14]
  00084	eb000000	 bl          OALTimerSetCompare

; 285  : }

  00088	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0008c	e12fff1e	 bx          lr
  00090		 |$LN11@UpdatePeri|
  00090		 |$LN12@UpdatePeri|
  00090	00000000	 DCD         |g_oalTimerContext|
  00094		 |$LN13@UpdatePeri|
  00094	00000000	 DCD         |g_pTimerRegs|
  00098		 |$M46177|

			 ENDP  ; |UpdatePeriod|

	EXPORT	|OALTimerUpdateRescheduleTime|

  00000			 AREA	 |.pdata|, PDATA
|$T46197| DCD	|$LN14@OALTimerUp|
	DCD	0x40002101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALTimerUpdateRescheduleTime| PROC

; 532  : {

  00000		 |$LN14@OALTimerUp|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M46194|
  00004	e1a05000	 mov         r5, r0

; 533  :     UINT32 baseMSec, periodMSec;
; 534  :     INT32 delta;
; 535  : 
; 536  :     // Get current system timer counter
; 537  :     baseMSec = CurMSec;
; 538  : 
; 539  :     // How far we are from next tick
; 540  :     delta = (INT32)(g_oalTimerContext.match - OALTimerGetCount());

  00008	e59f3070	 ldr         r3, [pc, #0x70]
  0000c	e59f6068	 ldr         r6, [pc, #0x68]
  00010	e5933000	 ldr         r3, [r3]
  00014	e5962000	 ldr         r2, [r6]
  00018	e2830028	 add         r0, r3, #0x28
  0001c	e59270c8	 ldr         r7, [r2, #0xC8]
  00020	eb000000	 bl          OALTimerGetReg
  00024	e59f404c	 ldr         r4, [pc, #0x4C]
  00028	e5943014	 ldr         r3, [r4, #0x14]
  0002c	e0532000	 subs        r2, r3, r0

; 541  : 
; 542  :     if( delta < 0 )
; 543  :     {
; 544  :         UpdatePeriod(0);
; 545  :         goto cleanUp;

  00030	4a000008	 bmi         |$LN11@OALTimerUp|

; 546  :     }
; 547  : 
; 548  :     // If timer interrupts occurs, or we are within 1 ms of the scheduled
; 549  :     // interrupt, just return - timer ISR will take care of it.
; 550  :     if ((baseMSec != CurMSec) || (delta < MSEC_TO_TICK(1))) goto cleanUp;

  00034	e5963000	 ldr         r3, [r6]
  00038	e59330c8	 ldr         r3, [r3, #0xC8]
  0003c	e1570003	 cmp         r7, r3
  00040	1a00000a	 bne         |$cleanUp$45912|
  00044	e3520021	 cmp         r2, #0x21
  00048	ba000008	 blt         |$cleanUp$45912|

; 551  : 
; 552  :     // Calculate the distance between the new time and the last timer interrupt
; 553  :       periodMSec = timeMSec - OEMGetTickCount();

  0004c	eb000000	 bl          OEMGetTickCount
  00050	e0550000	 subs        r0, r5, r0

; 554  : 
; 555  : 
; 556  :     // Trying to set reschedule time prior or equal to CurMSec - this could
; 557  :     // happen if a thread is on its way to sleep while preempted before
; 558  :     // getting into the Sleep Queue
; 559  :     if ((INT32)periodMSec < 0)

  00054	5a000001	 bpl         |$LN3@OALTimerUp|
  00058		 |$LN11@OALTimerUp|

; 560  :         {
; 561  :         periodMSec = 0;

  00058	e3a00000	 mov         r0, #0
  0005c	ea000002	 b           |$LN1@OALTimerUp|
  00060		 |$LN3@OALTimerUp|

; 562  :         }
; 563  :     else if (periodMSec > g_oalTimerContext.maxPeriodMSec)

  00060	e5943000	 ldr         r3, [r4]
  00064	e1500003	 cmp         r0, r3

; 564  :         {
; 565  :         periodMSec = g_oalTimerContext.maxPeriodMSec;

  00068	81a00003	 movhi       r0, r3
  0006c		 |$LN1@OALTimerUp|

; 566  :         }
; 567  : 
; 568  :     // Now we find new period, so update timer
; 569  :     UpdatePeriod(periodMSec);

  0006c	eb000000	 bl          UpdatePeriod
  00070		 |$cleanUp$45912|

; 570  : 
; 571  : cleanUp:
; 572  :     return;
; 573  : }

  00070	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00074	e12fff1e	 bx          lr
  00078		 |$LN15@OALTimerUp|
  00078		 |$LN16@OALTimerUp|
  00078	00000000	 DCD         |g_oalTimerContext|
  0007c		 |$LN17@OALTimerUp|
  0007c	00000000	 DCD         |g_pNKGlobal|
  00080		 |$LN18@OALTimerUp|
  00080	00000000	 DCD         |g_pTimerRegs|
  00084		 |$M46195|

			 ENDP  ; |OALTimerUpdateRescheduleTime|

	EXPORT	|OALTimerIntrHandler|
	IMPORT	|g_oalILT|
	IMPORT	|OALTickTimerIntr|

  00000			 AREA	 |.pdata|, PDATA
|$T46218| DCD	|$LN13@OALTimerIn|
	DCD	0x40004a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALTimerIntrHandler| PROC

; 585  : {

  00000		 |$LN13@OALTimerIn|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M46215|

; 586  :     UINT32 count;
; 587  :     INT32 period, delta;
; 588  :     UINT32 sysIntr = SYSINTR_NOP;
; 589  : 
; 590  : 
; 591  : 
; 592  :     // allow bsp to process timer interrupt first
; 593  :     sysIntr = OALTickTimerIntr();

  00004	eb000000	 bl          OALTickTimerIntr
  00008	e1b07000	 movs        r7, r0

; 594  :     if (sysIntr != SYSINTR_NOP) return sysIntr;

  0000c	1a00003e	 bne         |$LN7@OALTimerIn|

; 595  : 
; 596  :     // Clear interrupt
; 597  :     OALTimerSetReg(&g_pTimerRegs->TISR, GPTIMER_TIER_MATCH);

  00010	e59f410c	 ldr         r4, [pc, #0x10C]
  00014	e3a01001	 mov         r1, #1
  00018	e5943000	 ldr         r3, [r4]
  0001c	e2830018	 add         r0, r3, #0x18
  00020	eb000000	 bl          OALTimerSetReg

; 598  : 
; 599  :     // How far from interrupt we are?
; 600  :     count = OALTimerGetCount();

  00024	e5943000	 ldr         r3, [r4]
  00028	e2830028	 add         r0, r3, #0x28
  0002c	eb000000	 bl          OALTimerGetReg

; 601  :     delta = count - g_oalTimerContext.match;

  00030	e59f80e8	 ldr         r8, [pc, #0xE8]
  00034	e59f60e0	 ldr         r6, [pc, #0xE0]
  00038	e5983014	 ldr         r3, [r8, #0x14]
  0003c	e0502003	 subs        r2, r0, r3

; 602  :     
; 603  : 
; 604  :     // If delta is negative, timer fired for some reason
; 605  :     // To be safe, reprogram the timer for minimum delta
; 606  :     if (delta < 0)
; 607  :     {
; 608  :         delta = 0;

  00040	43a00000	 movmi       r0, #0
  00044	4a000024	 bmi         |$cleanUp$45926|

; 609  :         goto cleanUp;
; 610  :     }
; 611  : 
; 612  : #ifdef OAL_ILTIMING
; 613  :     if (g_oalILT.active)

  00048	e5963000	 ldr         r3, [r6]

; 614  :     {
; 615  :         g_oalILT.isrTime1 = delta;
; 616  :     }        
; 617  : #endif
; 618  : 
; 619  :     // Find how long period was
; 620  :     period = count - g_oalTimerContext.base;
; 621  :     g_oalTimerContext.curCounts += period;    
; 622  :     g_oalTimerContext.base += period;
; 623  : 
; 624  :     // Calculate actual CurMSec
; 625  :     CurMSec = (UINT32) TICK_TO_MSEC(g_oalTimerContext.curCounts);

  0004c	e59f50c4	 ldr         r5, [pc, #0xC4]
  00050	e3a09ffa	 mov         r9, #0xFA, 30
  00054	e3530000	 cmp         r3, #0
  00058	e5983010	 ldr         r3, [r8, #0x10]
  0005c	15862008	 strne       r2, [r6, #8]
  00060	e5982008	 ldr         r2, [r8, #8]
  00064	e598100c	 ldr         r1, [r8, #0xC]
  00068	e0400003	 sub         r0, r0, r3
  0006c	e0923000	 adds        r3, r2, r0
  00070	e0a12fc0	 adc         r2, r1, r0, asr #31
  00074	e5883008	 str         r3, [r8, #8]
  00078	e588200c	 str         r2, [r8, #0xC]
  0007c	e5983010	 ldr         r3, [r8, #0x10]
  00080	e3a02ffa	 mov         r2, #0xFA, 30
  00084	e5954000	 ldr         r4, [r5]
  00088	e0833000	 add         r3, r3, r0
  0008c	e5883010	 str         r3, [r8, #0x10]
  00090	e5983008	 ldr         r3, [r8, #8]
  00094	e598100c	 ldr         r1, [r8, #0xC]

; 626  : 
; 627  :     OALLED(LED_IDX_TIMER, CurMSec >> 10);

  00098	e3a0001f	 mov         r0, #0x1F
  0009c	e082e293	 umull       lr, r2, r3, r2
  000a0	e0232991	 mla         r3, r1, r9, r2
  000a4	e1a03883	 mov         r3, r3, lsl #17
  000a8	e18337ae	 orr         r3, r3, lr, lsr #15
  000ac	e58430c8	 str         r3, [r4, #0xC8]
  000b0	e5953000	 ldr         r3, [r5]
  000b4	e59330c8	 ldr         r3, [r3, #0xC8]
  000b8	e1a01523	 mov         r1, r3, lsr #10
  000bc	eb000000	 bl          OEMWriteDebugLED

; 628  : 
; 629  :     // Reschedule?
; 630  :     delta = dwReschedTime - CurMSec;

  000c0	e5953000	 ldr         r3, [r5]
  000c4	e59320c8	 ldr         r2, [r3, #0xC8]
  000c8	e59330c4	 ldr         r3, [r3, #0xC4]
  000cc	e0430002	 sub         r0, r3, r2

; 631  :     if (delta <= 0)

  000d0	e3500000	 cmp         r0, #0

; 632  :         {
; 633  :         sysIntr = SYSINTR_RESCHED;
; 634  :         delta = g_oalTimerContext.maxPeriodMSec;

  000d4	d5980000	 ldrle       r0, [r8]
  000d8	d3a07001	 movle       r7, #1
  000dc		 |$cleanUp$45926|

; 635  :         }
; 636  : 
; 637  : cleanUp:
; 638  :     // Set new period
; 639  :     UpdatePeriod(delta);

  000dc	eb000000	 bl          UpdatePeriod

; 640  : 
; 641  : #ifdef OAL_ILTIMING
; 642  :     if (g_oalILT.active) {

  000e0	e5963000	 ldr         r3, [r6]
  000e4	e3530000	 cmp         r3, #0
  000e8	0a000007	 beq         |$LN7@OALTimerIn|

; 643  :         if (--g_oalILT.counter == 0) {

  000ec	e5963014	 ldr         r3, [r6, #0x14]
  000f0	e2533001	 subs        r3, r3, #1
  000f4	e5863014	 str         r3, [r6, #0x14]

; 644  :             sysIntr = SYSINTR_TIMING;
; 645  :             g_oalILT.counter = g_oalILT.counterSet;

  000f8	05963018	 ldreq       r3, [r6, #0x18]

; 646  :             g_oalILT.isrTime2 = 0;

  000fc	03a02000	 moveq       r2, #0
  00100	03a0700a	 moveq       r7, #0xA
  00104	05863014	 streq       r3, [r6, #0x14]
  00108	0586200c	 streq       r2, [r6, #0xC]
  0010c		 |$LN7@OALTimerIn|

; 647  :         }
; 648  :     }
; 649  : #endif
; 650  : 
; 651  :     return sysIntr;
; 652  : }

  0010c	e1a00007	 mov         r0, r7
  00110	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00114	e12fff1e	 bx          lr
  00118		 |$LN14@OALTimerIn|
  00118		 |$LN15@OALTimerIn|
  00118	00000000	 DCD         |g_pNKGlobal|
  0011c		 |$LN16@OALTimerIn|
  0011c	00000000	 DCD         |g_oalILT|
  00120		 |$LN17@OALTimerIn|
  00120	00000000	 DCD         |g_oalTimerContext|
  00124		 |$LN18@OALTimerIn|
  00124	00000000	 DCD         |g_pTimerRegs|
  00128		 |$M46216|

			 ENDP  ; |OALTimerIntrHandler|

	EXPORT	|OALTimerInit|
	EXPORT	|??_C@_1DC@BNLGCJKD@?$AA?9?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HM@CJGLDOPJ@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AA?5?$AAe@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CC@DKAIBEIO@?$AA?5?$AAT?$AAi?$AAm?$AAe?$AAr?$AAU?$AAA?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CC@HBIBODEO@?$AA?5?$AAT?$AAi?$AAm?$AAe?$AAr?$AAP?$AAA?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DI@BBHLNDEO@?$AA?$CL?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CF?$AAd?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|OEMInterruptEnable|
	IMPORT	|OALIntrRequestSysIntr|
	IMPORT	|GetIrqByDevice|
	IMPORT	|EnableDeviceClocks|
	IMPORT	|BSPGetSysTimer32KClock|
	IMPORT	|OALPAtoVA|
	IMPORT	|GetAddressByDevice|
	IMPORT	|BSPGetSysTimerDevice|
	IMPORT	|g_pOemGlobal|
	IMPORT	|dwOEMMaxIdlePeriod|
	IMPORT	|dpCurSettings|
	IMPORT	|g_oalTimerIrq|

  00000			 AREA	 |.pdata|, PDATA
|$T46248| DCD	|$LN19@OALTimerIn@2|
	DCD	0x40009401

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DC@BNLGCJKD@?$AA?9?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "-"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "T", 0x0, "i", 0x0, "m"
	DCB	0x0, "e", 0x0, "r", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t"
	DCB	0x0, "(", 0x0, "r", 0x0, "c", 0x0, " ", 0x0, "=", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, ")", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HM@CJGLDOPJ@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AA?5?$AAe@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "T", 0x0, "i", 0x0, "m"
	DCB	0x0, "e", 0x0, "r", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t"
	DCB	0x0, ":", 0x0, " ", 0x0, "I", 0x0, "n", 0x0, "t", 0x0, "e"
	DCB	0x0, "r", 0x0, "r", 0x0, "u", 0x0, "p", 0x0, "t", 0x0, " "
	DCB	0x0, "e", 0x0, "n", 0x0, "a", 0x0, "b", 0x0, "l", 0x0, "e"
	DCB	0x0, " ", 0x0, "f", 0x0, "o", 0x0, "r", 0x0, " ", 0x0, "s"
	DCB	0x0, "y", 0x0, "s", 0x0, "t", 0x0, "e", 0x0, "m", 0x0, " "
	DCB	0x0, "t", 0x0, "i", 0x0, "m", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@DKAIBEIO@?$AA?5?$AAT?$AAi?$AAm?$AAe?$AAr?$AAU?$AAA?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB " "
	DCB	0x0, "T", 0x0, "i", 0x0, "m", 0x0, "e", 0x0, "r", 0x0, "U"
	DCB	0x0, "A", 0x0, ":", 0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%"
	DCB	0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@HBIBODEO@?$AA?5?$AAT?$AAi?$AAm?$AAe?$AAr?$AAP?$AAA?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB " "
	DCB	0x0, "T", 0x0, "i", 0x0, "m", 0x0, "e", 0x0, "r", 0x0, "P"
	DCB	0x0, "A", 0x0, ":", 0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%"
	DCB	0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DI@BBHLNDEO@?$AA?$CL?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CF?$AAd?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "+"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "T", 0x0, "i", 0x0, "m"
	DCB	0x0, "e", 0x0, "r", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t"
	DCB	0x0, "(", 0x0, "%", 0x0, "d", 0x0, ",", 0x0, " ", 0x0, "%"
	DCB	0x0, "d", 0x0, ",", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ")"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALTimerInit| PROC

; 418  : {

  00000		 |$LN19@OALTimerIn@2|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M46245|
  00004	e1a0e000	 mov         lr, r0

; 419  :     BOOL rc = FALSE;
; 420  :     UINT srcClock;
; 421  :     UINT32 sysIntr;
; 422  : 
; 423  : 	UNREFERENCED_PARAMETER(sysTickMSec);
; 424  : 	UNREFERENCED_PARAMETER(countsPerMSec);
; 425  : 	UNREFERENCED_PARAMETER(countsMargin);
; 426  : 
; 427  :     OALMSG(1&&OAL_FUNC, (L"+OALTimerInit(%d, %d, %d)\r\n", sysTickMSec, countsPerMSec, countsMargin ));

  00008	e59f423c	 ldr         r4, [pc, #0x23C]
  0000c	e3a06000	 mov         r6, #0
  00010	e5943440	 ldr         r3, [r4, #0x440]
  00014	e3130004	 tst         r3, #4
  00018	159f0228	 ldrne       r0, [pc, #0x228]
  0001c	11a03002	 movne       r3, r2
  00020	11a02001	 movne       r2, r1
  00024	11a0100e	 movne       r1, lr
  00028	1b000000	 blne        NKDbgPrintfW

; 428  : 
; 429  :     //  Initialize timer state information
; 430  :     g_oalTimerContext.maxPeriodMSec = dwOEMMaxIdlePeriod;   // Maximum period the timer will interrupt on, in mSec

  0002c	e59f3210	 ldr         r3, [pc, #0x210]
  00030	e59f7208	 ldr         r7, [pc, #0x208]

; 431  :     g_oalTimerContext.margin =        DELTA_TIME;           // Time needed to reprogram the timer interrupt
; 432  :     g_oalTimerContext.curCounts =     0;
; 433  :     g_oalTimerContext.base =          0;
; 434  :     g_oalTimerContext.match =         0xFFFFFFFF;
; 435  :     g_oalTimerContext.Posted =       0;
; 436  : 
; 437  :     // Set idle conversion constant and counters
; 438  :     idleconv     = MSEC_TO_TICK(1);

  00034	e59f0200	 ldr         r0, [pc, #0x200]
  00038	e5933000	 ldr         r3, [r3]
  0003c	e3a02014	 mov         r2, #0x14
  00040	e3a0e000	 mov         lr, #0
  00044	e5873000	 str         r3, [r7]
  00048	e5872004	 str         r2, [r7, #4]
  0004c	e5903000	 ldr         r3, [r0]
  00050	e587e008	 str         lr, [r7, #8]
  00054	e587e00c	 str         lr, [r7, #0xC]
  00058	e3e09000	 mvn         r9, #0
  0005c	e587e010	 str         lr, [r7, #0x10]
  00060	e5879014	 str         r9, [r7, #0x14]
  00064	e3a02021	 mov         r2, #0x21
  00068	e587e018	 str         lr, [r7, #0x18]
  0006c	e58320d8	 str         r2, [r3, #0xD8]

; 439  :     curridlehigh = 0;

  00070	e5903000	 ldr         r3, [r0]

; 440  :     curridlelow  = 0;
; 441  : 
; 442  :     // Use variable system tick
; 443  :     pOEMUpdateRescheduleTime = OALTimerUpdateRescheduleTime;

  00074	e59f21bc	 ldr         r2, [pc, #0x1BC]
  00078	e59f11b4	 ldr         r1, [pc, #0x1B4]
  0007c	e583e0d4	 str         lr, [r3, #0xD4]
  00080	e5903000	 ldr         r3, [r0]
  00084	e583e0d0	 str         lr, [r3, #0xD0]
  00088	e5923000	 ldr         r3, [r2]
  0008c	e583104c	 str         r1, [r3, #0x4C]

; 444  : 
; 445  : 	// Get virtual addresses for hardware
; 446  :     g_TimerDevice = BSPGetSysTimerDevice(); // OMAP_DEVICE_GPTIMER1

  00090	eb000000	 bl          BSPGetSysTimerDevice
  00094	e59f8194	 ldr         r8, [pc, #0x194]
  00098	e1a03000	 mov         r3, r0

; 447  :     
; 448  :     g_pTimerRegs = OALPAtoUA(GetAddressByDevice(g_TimerDevice));

  0009c	e5883000	 str         r3, [r8]
  000a0	eb000000	 bl          GetAddressByDevice
  000a4	e3a01000	 mov         r1, #0
  000a8	eb000000	 bl          OALPAtoVA
  000ac	e59f5178	 ldr         r5, [pc, #0x178]

; 449  : 	OALMSG(1 && OAL_FUNC, (L" TimerPA: 0x%x\r\n", GetAddressByDevice(g_TimerDevice)));

  000b0	e5943440	 ldr         r3, [r4, #0x440]
  000b4	e1a01000	 mov         r1, r0
  000b8	e5851000	 str         r1, [r5]
  000bc	e3130004	 tst         r3, #4
  000c0	0a000006	 beq         |$LN8@OALTimerIn@2|
  000c4	e5980000	 ldr         r0, [r8]
  000c8	eb000000	 bl          GetAddressByDevice
  000cc	e1a01000	 mov         r1, r0
  000d0	e59f0150	 ldr         r0, [pc, #0x150]
  000d4	eb000000	 bl          NKDbgPrintfW
  000d8	e5943440	 ldr         r3, [r4, #0x440]
  000dc	e5951000	 ldr         r1, [r5]
  000e0		 |$LN8@OALTimerIn@2|

; 450  : 	OALMSG(1 && OAL_FUNC, (L" TimerUA: 0x%x\r\n", g_pTimerRegs));

  000e0	e3130004	 tst         r3, #4
  000e4	159f0138	 ldrne       r0, [pc, #0x138]
  000e8	1b000000	 blne        NKDbgPrintfW

; 451  : 	// Select 32K frequency source clock
; 452  :     srcClock = BSPGetSysTimer32KClock(); // k32K_FCLK

  000ec	eb000000	 bl          BSPGetSysTimer32KClock

; 453  :     
; 454  : 	//PrcmDeviceSetSourceClocks(g_TimerDevice,1,&srcClock);
; 455  : 
; 456  :     // enable gptimer
; 457  :     EnableDeviceClocks(g_TimerDevice, TRUE);

  000f0	e5980000	 ldr         r0, [r8]
  000f4	e3a01001	 mov         r1, #1
  000f8	eb000000	 bl          EnableDeviceClocks

; 458  : 
; 459  : 
; 460  :     // stop timer
; 461  :     OALTimerSetReg(&g_pTimerRegs->TCLR, 0);

  000fc	e5953000	 ldr         r3, [r5]
  00100	e3a01000	 mov         r1, #0
  00104	e2830024	 add         r0, r3, #0x24
  00108	eb000000	 bl          OALTimerSetReg

; 462  : 
; 463  :     // Soft reset GPTIMER
; 464  :     OALTimerSetReg(&g_pTimerRegs->TIOCP, SYSCONFIG_SOFTRESET);

  0010c	e5953000	 ldr         r3, [r5]
  00110	e3a01002	 mov         r1, #2
  00114	e2830010	 add         r0, r3, #0x10
  00118	eb000000	 bl          OALTimerSetReg
  0011c		 |$LL3@OALTimerIn@2|

; 465  : 
; 466  :     // While until done
; 467  :     while ((OALTimerGetReg(&g_pTimerRegs->TISTAT) & GPTIMER_TISTAT_RESETDONE) == 0);

  0011c	e5953000	 ldr         r3, [r5]
  00120	e2830014	 add         r0, r3, #0x14
  00124	eb000000	 bl          OALTimerGetReg
  00128	e3100001	 tst         r0, #1
  0012c	0afffffa	 beq         |$LL3@OALTimerIn@2|

; 468  : 
; 469  :     // Set smart idle
; 470  :     OALTimerSetReg(
; 471  :         &g_pTimerRegs->TIOCP,
; 472  :             SYSCONFIG_SMARTIDLE|SYSCONFIG_ENAWAKEUP|
; 473  :             SYSCONFIG_AUTOIDLE
; 474  :         );

  00130	e5953000	 ldr         r3, [r5]
  00134	e3a01015	 mov         r1, #0x15
  00138	e2830010	 add         r0, r3, #0x10
  0013c	eb000000	 bl          OALTimerSetReg

; 475  : 
; 476  :     // Enable posted mode
; 477  :     OALTimerSetReg(&g_pTimerRegs->TSICR, GPTIMER_TSICR_POSTED);

  00140	e5953000	 ldr         r3, [r5]
  00144	e3a01004	 mov         r1, #4
  00148	e2830040	 add         r0, r3, #0x40
  0014c	eb000000	 bl          OALTimerSetReg

; 478  :     g_oalTimerContext.Posted =       1;
; 479  : 
; 480  :     // Set match register to avoid unwanted interrupt
; 481  :     OALTimerSetReg(&g_pTimerRegs->TMAR, 0xFFFFFFFF);

  00150	e5953000	 ldr         r3, [r5]
  00154	e3a02001	 mov         r2, #1
  00158	e1a01009	 mov         r1, r9
  0015c	e2830038	 add         r0, r3, #0x38
  00160	e5872018	 str         r2, [r7, #0x18]
  00164	eb000000	 bl          OALTimerSetReg

; 482  : 
; 483  :     // Enable match interrupt
; 484  :     OALTimerSetReg(&g_pTimerRegs->TIER, GPTIMER_TIER_MATCH);

  00168	e5953000	 ldr         r3, [r5]
  0016c	e3a01001	 mov         r1, #1
  00170	e283001c	 add         r0, r3, #0x1C
  00174	eb000000	 bl          OALTimerSetReg

; 485  : 
; 486  :     // Enable match wakeup
; 487  :     OALTimerSetReg(&g_pTimerRegs->TWER, GPTIMER_TWER_MATCH);

  00178	e5953000	 ldr         r3, [r5]
  0017c	e3a01001	 mov         r1, #1
  00180	e2830020	 add         r0, r3, #0x20
  00184	eb000000	 bl          OALTimerSetReg

; 488  : 
; 489  :     // Enable timer in auto-reload and compare mode
; 490  :     OALTimerSetReg(&g_pTimerRegs->TCLR, GPTIMER_TCLR_CE|GPTIMER_TCLR_AR|GPTIMER_TCLR_ST);

  00188	e5953000	 ldr         r3, [r5]
  0018c	e3a01043	 mov         r1, #0x43
  00190	e2830024	 add         r0, r3, #0x24
  00194	eb000000	 bl          OALTimerSetReg

; 491  : 
; 492  :     // Wait until write is done
; 493  :     //while ((INREG32(&g_pTimerRegs->TWPS) & GPTIMER_TWPS_TCLR) != 0);
; 494  : 
; 495  :     // Set global variable to tell interrupt module about timer used
; 496  :     g_oalTimerIrq = GetIrqByDevice(g_TimerDevice,NULL); // 37

  00198	e5980000	 ldr         r0, [r8]
  0019c	e3a01000	 mov         r1, #0
  001a0	eb000000	 bl          GetIrqByDevice
  001a4	e59fe074	 ldr         lr, [pc, #0x74]
  001a8	e1a03000	 mov         r3, r0

; 497  : 
; 498  :     // Request SYSINTR for timer IRQ, it is done to reserve it...
; 499  :     sysIntr = OALIntrRequestSysIntr(1, &g_oalTimerIrq, OAL_INTR_FORCE_STATIC); // 17

  001ac	e3a02004	 mov         r2, #4
  001b0	e1a0100e	 mov         r1, lr
  001b4	e3a00001	 mov         r0, #1
  001b8	e58e3000	 str         r3, [lr]
  001bc	eb000000	 bl          OALIntrRequestSysIntr

; 500  : 
; 501  :     // Enable System Tick interrupt
; 502  :     if (!OEMInterruptEnable(sysIntr, NULL, 0))

  001c0	e3a02000	 mov         r2, #0
  001c4	e3a01000	 mov         r1, #0
  001c8	eb000000	 bl          OEMInterruptEnable
  001cc	e3500000	 cmp         r0, #0
  001d0	1a000005	 bne         |$LN1@OALTimerIn@2|

; 503  :         {
; 504  :         OALMSG(OAL_ERROR, (
; 505  :             L"ERROR: OALTimerInit: Interrupt enable for system timer failed"
; 506  :             ));

  001d4	e5943440	 ldr         r3, [r4, #0x440]
  001d8	e3130001	 tst         r3, #1
  001dc	0a000005	 beq         |$cleanUp$45901|
  001e0	e59f0034	 ldr         r0, [pc, #0x34]
  001e4	eb000000	 bl          NKDbgPrintfW

; 507  :         goto cleanUp;

  001e8	ea000002	 b           |$cleanUp$45901|
  001ec		 |$LN1@OALTimerIn@2|

; 508  :         }
; 509  : 
; 510  :     // Initialize timer to maximum period
; 511  :     UpdatePeriod(g_oalTimerContext.maxPeriodMSec);

  001ec	e5970000	 ldr         r0, [r7]
  001f0	eb000000	 bl          UpdatePeriod

; 512  : 
; 513  :     // Done
; 514  :     rc = TRUE;

  001f4	e3a06001	 mov         r6, #1
  001f8		 |$cleanUp$45901|
  001f8	e5943440	 ldr         r3, [r4, #0x440]

; 515  : 
; 516  : cleanUp:
; 517  :     OALMSG(1 && OAL_FUNC, (L"-OALTimerInit(rc = %d)\r\n", rc));

  001fc	e3130004	 tst         r3, #4
  00200	159f0010	 ldrne       r0, [pc, #0x10]
  00204	11a01006	 movne       r1, r6
  00208	1b000000	 blne        NKDbgPrintfW

; 518  :     return rc;
; 519  : }

  0020c	e1a00006	 mov         r0, r6
  00210	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00214	e12fff1e	 bx          lr
  00218		 |$LN20@OALTimerIn@2|
  00218		 |$LN21@OALTimerIn@2|
  00218	00000000	 DCD         |??_C@_1DC@BNLGCJKD@?$AA?9?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  0021c		 |$LN22@OALTimerIn@2|
  0021c	00000000	 DCD         |??_C@_1HM@CJGLDOPJ@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AA?5?$AAe@|
  00220		 |$LN23@OALTimerIn@2|
  00220	00000000	 DCD         |g_oalTimerIrq|
  00224		 |$LN24@OALTimerIn@2|
  00224	00000000	 DCD         |??_C@_1CC@DKAIBEIO@?$AA?5?$AAT?$AAi?$AAm?$AAe?$AAr?$AAU?$AAA?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  00228		 |$LN25@OALTimerIn@2|
  00228	00000000	 DCD         |??_C@_1CC@HBIBODEO@?$AA?5?$AAT?$AAi?$AAm?$AAe?$AAr?$AAP?$AAA?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  0022c		 |$LN26@OALTimerIn@2|
  0022c	00000000	 DCD         |g_pTimerRegs|
  00230		 |$LN27@OALTimerIn@2|
  00230	00000000	 DCD         |g_TimerDevice|
  00234		 |$LN28@OALTimerIn@2|
  00234	00000000	 DCD         |OALTimerUpdateRescheduleTime|
  00238		 |$LN29@OALTimerIn@2|
  00238	00000000	 DCD         |g_pOemGlobal|
  0023c		 |$LN30@OALTimerIn@2|
  0023c	00000000	 DCD         |g_pNKGlobal|
  00240		 |$LN31@OALTimerIn@2|
  00240	00000000	 DCD         |g_oalTimerContext|
  00244		 |$LN32@OALTimerIn@2|
  00244	00000000	 DCD         |dwOEMMaxIdlePeriod|
  00248		 |$LN33@OALTimerIn@2|
  00248	00000000	 DCD         |??_C@_1DI@BBHLNDEO@?$AA?$CL?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CF?$AAd?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  0024c		 |$LN34@OALTimerIn@2|
  0024c	00000000	 DCD         |dpCurSettings|
  00250		 |$M46246|

			 ENDP  ; |OALTimerInit|

	END
