; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\OAL\OMAP_NEON\vfphandler.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|g_oalNeonStat| [ DATA ]

  00000			 AREA	 |.bss|, NOINIT
|g_oalNeonStat| % 0x20

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|OALHandleVFPException|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\oal\omap_neon\vfphandler.c

  00000			 AREA	 |.pdata|, PDATA
|$T44115| DCD	|$LN5@OALHandleV|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALHandleVFPException| PROC

; 45   : {

  00000		 |$LN5@OALHandleV|
  00000		 |$M44112|

; 46   :     UNREFERENCED_PARAMETER(pctx);
; 47   :     UNREFERENCED_PARAMETER(er);
; 48   :     //  All VPF exceptions handed off to OS kernel
; 49   :     return FALSE;

  00000	e3a00000	 mov         r0, #0

; 50   : }

  00004	e12fff1e	 bx          lr
  00008		 |$M44113|

			 ENDP  ; |OALHandleVFPException|

	EXPORT	|OALSaveVFPCtrlRegs|

  00000			 AREA	 |.pdata|, PDATA
|$T44122| DCD	|$LN5@OALSaveVFP|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALSaveVFPCtrlRegs| PROC

; 65   : {

  00000		 |$LN5@OALSaveVFP|
  00000		 |$M44119|

; 66   :     UNREFERENCED_PARAMETER(nMaxRegs);
; 67   :     UNREFERENCED_PARAMETER(lpExtra);
; 68   : }

  00000	e12fff1e	 bx          lr
  00004		 |$M44120|

			 ENDP  ; |OALSaveVFPCtrlRegs|

	EXPORT	|OALRestoreVFPCtrlRegs|

  00000			 AREA	 |.pdata|, PDATA
|$T44129| DCD	|$LN5@OALRestore|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALRestoreVFPCtrlRegs| PROC

; 82   : {

  00000		 |$LN5@OALRestore|
  00000		 |$M44126|

; 83   :     UNREFERENCED_PARAMETER(nMaxRegs);
; 84   :     UNREFERENCED_PARAMETER(lpExtra);
; 85   : }

  00000	e12fff1e	 bx          lr
  00004		 |$M44127|

			 ENDP  ; |OALRestoreVFPCtrlRegs|

	EXPORT	|OALInitNeonSaveArea|

  00000			 AREA	 |.pdata|, PDATA
|$T44136| DCD	|$LN5@OALInitNeo|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALInitNeonSaveArea| PROC

; 97   : {

  00000		 |$LN5@OALInitNeo|
  00000		 |$M44133|

; 98   :     UNREFERENCED_PARAMETER(pArea);
; 99   : }

  00000	e12fff1e	 bx          lr
  00004		 |$M44134|

			 ENDP  ; |OALInitNeonSaveArea|

	EXPORT	|OALSaveNeonRegistersEx|
	IMPORT	|OALSaveNeonRegisters|

  00000			 AREA	 |.pdata|, PDATA
|$T44145| DCD	|$LN14@OALSaveNeo|
	DCD	0x40002f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALSaveNeonRegistersEx| PROC

; 126  : {

  00000		 |$LN14@OALSaveNeo|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44142|

; 127  :     LPBYTE pAreaToSave = NULL;     
; 128  :        
; 129  :     /* check pArea magicNumber */
; 130  :     if (*((DWORD *)(pArea+(32*8)+4)) == SaveRestoreTagMN) 

  00004	e5903104	 ldr         r3, [r0, #0x104]
  00008	e59f20a8	 ldr         r2, [pc, #0xA8]

; 131  :     {
; 132  :         pAreaToSave = pArea;    
; 133  :         if (pArea != g_oalNeonStat.pLastRestoredCoProcArea)

  0000c	e59f40a0	 ldr         r4, [pc, #0xA0]
  00010	e3a05000	 mov         r5, #0
  00014	e1530002	 cmp         r3, r2
  00018	1a00000a	 bne         |$LN9@OALSaveNeo|
  0001c	e5943018	 ldr         r3, [r4, #0x18]
  00020	e1a05000	 mov         r5, r0
  00024	e1500003	 cmp         r0, r3

; 134  :             g_oalNeonStat.dwErrCond4++; /* Kernel Screwed up bad */        

  00028	1594300c	 ldrne       r3, [r4, #0xC]
  0002c	12833001	 addne       r3, r3, #1
  00030	1584300c	 strne       r3, [r4, #0xC]
  00034	1a000015	 bne         |$LN2@OALSaveNeo|

; 135  :         else
; 136  :             g_oalNeonStat.dwNumCorrectSave++; /* This is what should happen always ! */

  00038	e5943010	 ldr         r3, [r4, #0x10]
  0003c	e2833001	 add         r3, r3, #1
  00040	e5843010	 str         r3, [r4, #0x10]

; 137  :         
; 138  :     }
; 139  :     /* oops - error conditions - lets try to restore */
; 140  :     else if (*((DWORD *)(g_oalNeonStat.pLastRestoredCoProcArea +(32*8)+4)) == SaveRestoreTagMN)

  00044	ea000011	 b           |$LN2@OALSaveNeo|
  00048		 |$LN9@OALSaveNeo|
  00048	e5941018	 ldr         r1, [r4, #0x18]
  0004c	e5913104	 ldr         r3, [r1, #0x104]
  00050	e1530002	 cmp         r3, r2
  00054	1a00000a	 bne         |$LN5@OALSaveNeo|

; 141  :     {
; 142  :         pAreaToSave = g_oalNeonStat.pLastRestoredCoProcArea;       
; 143  :         /* get some stats on type of Kernel error */
; 144  :         if (pArea == g_oalNeonStat.pLastSavedCoProcArea) /* Back-to-Back Thread Switch Scenario */

  00058	e594301c	 ldr         r3, [r4, #0x1C]
  0005c	e1a05001	 mov         r5, r1
  00060	e1500003	 cmp         r0, r3

; 145  :             g_oalNeonStat.dwErrCond1++;

  00064	05943000	 ldreq       r3, [r4]
  00068	02833001	 addeq       r3, r3, #1
  0006c	05843000	 streq       r3, [r4]
  00070	0a000006	 beq         |$LN2@OALSaveNeo|

; 146  :         else {               
; 147  :             g_oalNeonStat.dwErrCond2++; /* Multiple Thread Switch Scenario */

  00074	e5943004	 ldr         r3, [r4, #4]
  00078	e2833001	 add         r3, r3, #1
  0007c	e5843004	 str         r3, [r4, #4]

; 148  :         }
; 149  :     }
; 150  :     /* oops oops - dont know what to do - lets log and skip */
; 151  :     else

  00080	ea000002	 b           |$LN2@OALSaveNeo|
  00084		 |$LN5@OALSaveNeo|

; 152  :     {
; 153  :         g_oalNeonStat.dwErrCond3++;

  00084	e5943008	 ldr         r3, [r4, #8]
  00088	e2833001	 add         r3, r3, #1
  0008c	e5843008	 str         r3, [r4, #8]
  00090		 |$LN2@OALSaveNeo|

; 154  :     }
; 155  : 
; 156  :     /* if valid Area to Save */
; 157  :     if (pAreaToSave)

  00090	e3550000	 cmp         r5, #0
  00094	0a000004	 beq         |$LN1@OALSaveNeo|

; 158  :     {
; 159  :         OALSaveNeonRegisters(pAreaToSave);        

  00098	e1a00005	 mov         r0, r5
  0009c	eb000000	 bl          OALSaveNeonRegisters

; 160  :         *((DWORD *)(pAreaToSave+(32*8)+4)) = 0;

  000a0	e3a03000	 mov         r3, #0
  000a4	e5853104	 str         r3, [r5, #0x104]

; 161  :         g_oalNeonStat.pLastSavedCoProcArea = pAreaToSave;        

  000a8	e584501c	 str         r5, [r4, #0x1C]
  000ac		 |$LN1@OALSaveNeo|

; 162  :     }    
; 163  : 
; 164  :     
; 165  :     return;
; 166  : }

  000ac	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000b0	e12fff1e	 bx          lr
  000b4		 |$LN15@OALSaveNeo|
  000b4		 |$LN16@OALSaveNeo|
  000b4	00000000	 DCD         |g_oalNeonStat|
  000b8		 |$LN17@OALSaveNeo|
  000b8	1a2b3c4d	 DCD         0x1a2b3c4d
  000bc		 |$M44143|

			 ENDP  ; |OALSaveNeonRegistersEx|

	EXPORT	|OALRestoreNeonRegistersEx|
	IMPORT	|OALRestoreNeonRegisters|

  00000			 AREA	 |.pdata|, PDATA
|$T44156| DCD	|$LN5@OALRestore@2|
	DCD	0x40000e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALRestoreNeonRegistersEx| PROC

; 176  : {    

  00000		 |$LN5@OALRestore@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M44153|
  00004	e1a04000	 mov         r4, r0

; 177  :     DWORD * lastSaveRestoreStatus = (DWORD *)(pArea+(32*8)+4);      
; 178  :     OALRestoreNeonRegisters(pArea);    

  00008	eb000000	 bl          OALRestoreNeonRegisters

; 179  :     *lastSaveRestoreStatus = SaveRestoreTagMN;        

  0000c	e59f3020	 ldr         r3, [pc, #0x20]

; 180  :     g_oalNeonStat.pLastRestoredCoProcArea = pArea;

  00010	e59f2018	 ldr         r2, [pc, #0x18]
  00014	e5843104	 str         r3, [r4, #0x104]
  00018	e5824018	 str         r4, [r2, #0x18]

; 181  :     g_oalNeonStat.dwNumRestore++;     

  0001c	e5923014	 ldr         r3, [r2, #0x14]
  00020	e2833001	 add         r3, r3, #1
  00024	e5823014	 str         r3, [r2, #0x14]

; 182  :     return;
; 183  : }

  00028	e8bd4010	 ldmia       sp!, {r4, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$LN6@OALRestore@2|
  00030		 |$LN7@OALRestore@2|
  00030	00000000	 DCD         |g_oalNeonStat|
  00034		 |$LN8@OALRestore@2|
  00034	1a2b3c4d	 DCD         0x1a2b3c4d
  00038		 |$M44154|

			 ENDP  ; |OALRestoreNeonRegistersEx|

	EXPORT	|OALVFPInitialize|
	IMPORT	|OALVFPEnable|

  00000			 AREA	 |.pdata|, PDATA
|$T44167| DCD	|$LN5@OALVFPInit|
	DCD	0x40001b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALVFPInitialize| PROC

; 193  : {

  00000		 |$LN5@OALVFPInit|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M44164|
  00004	e1a06000	 mov         r6, r0

; 194  :     //  Enable the VFP    
; 195  :     OALVFPEnable();

  00008	eb000000	 bl          OALVFPEnable

; 196  : 
; 197  :     // Vector Floating Point support
; 198  :     pOemGlobal->pfnHandleVFPExcp      = OALHandleVFPException;
; 199  :     pOemGlobal->pfnSaveVFPCtrlRegs    = OALSaveVFPCtrlRegs;
; 200  :     pOemGlobal->pfnRestoreVFPCtrlRegs = OALRestoreVFPCtrlRegs;
; 201  : 
; 202  :     // Note: VFP and NEON share the same registers. Although CE6 kernel saves/restores
; 203  :     //       VFPv2 regs (16 64 bit regs) but not on all thread switches, 
; 204  :     //       so need to save/restore all VFPv3 VFP/NEON regs at every thread switch.
; 205  :     pOemGlobal->pfnInitCoProcRegs    = OALInitNeonSaveArea;

  0000c	e59fe054	 ldr         lr, [pc, #0x54]
  00010	e59f304c	 ldr         r3, [pc, #0x4C]
  00014	e59f2044	 ldr         r2, [pc, #0x44]
  00018	e59f103c	 ldr         r1, [pc, #0x3C]

; 206  :     pOemGlobal->pfnSaveCoProcRegs    = OALSaveNeonRegisters; //use Extended functions

  0001c	e59f4034	 ldr         r4, [pc, #0x34]

; 207  :     pOemGlobal->pfnRestoreCoProcRegs = OALRestoreNeonRegisters; // Use Extended funtions

  00020	e59f502c	 ldr         r5, [pc, #0x2C]

; 208  :     pOemGlobal->cbCoProcRegSize      = NEON_SAVEAREA_SIZE;

  00024	e3a00f42	 mov         r0, #0x42, 30

; 209  :     pOemGlobal->fSaveCoProcReg       = TRUE;

  00028	e3a07001	 mov         r7, #1
  0002c	e586e078	 str         lr, [r6, #0x78]
  00030	e5863128	 str         r3, [r6, #0x128]
  00034	e5862120	 str         r2, [r6, #0x120]
  00038	e5861124	 str         r1, [r6, #0x124]
  0003c	e586407c	 str         r4, [r6, #0x7C]
  00040	e5865080	 str         r5, [r6, #0x80]
  00044	e5860084	 str         r0, [r6, #0x84]
  00048	e5867088	 str         r7, [r6, #0x88]

; 210  : }

  0004c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$LN6@OALVFPInit|
  00054		 |$LN7@OALVFPInit|
  00054	00000000	 DCD         |OALRestoreNeonRegisters|
  00058		 |$LN8@OALVFPInit|
  00058	00000000	 DCD         |OALSaveNeonRegisters|
  0005c		 |$LN9@OALVFPInit|
  0005c	00000000	 DCD         |OALRestoreVFPCtrlRegs|
  00060		 |$LN10@OALVFPInit|
  00060	00000000	 DCD         |OALSaveVFPCtrlRegs|
  00064		 |$LN11@OALVFPInit|
  00064	00000000	 DCD         |OALHandleVFPException|
  00068		 |$LN12@OALVFPInit|
  00068	00000000	 DCD         |OALInitNeonSaveArea|
  0006c		 |$M44165|

			 ENDP  ; |OALVFPInitialize|

	END
