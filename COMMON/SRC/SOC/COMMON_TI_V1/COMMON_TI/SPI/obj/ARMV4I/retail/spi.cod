; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\SPI\spi.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1CA@CCIKILKA@?$AAA?$AAc?$AAt?$AAi?$AAv?$AAi?$AAt?$AAy?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CG@FKLAKBOO@?$AAD?$AAV?$AAF?$AAS?$AAA?$AAs?$AAy?$AAn?$AAc?$AAE?$AAv?$AAe?$AAn?$AAt?$AAN?$AAa?$AAm?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@CGEFNBAB@?$AAR?$AAx?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@BJJLAMLA@?$AAT?$AAx?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@BKONPLFM@?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_19OBNDINH@?$AAP?$AAo?$AAr?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|DEVICE_IFC_SPI_GUID| [ DATA ]
	EXPORT	|dpCurSettings| [ DATA ]

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CA@CCIKILKA@?$AAA?$AAc?$AAt?$AAi?$AAv?$AAi?$AAt?$AAy?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB "A"
	DCB	0x0, "c", 0x0, "t", 0x0, "i", 0x0, "v", 0x0, "i", 0x0, "t"
	DCB	0x0, "y", 0x0, "T", 0x0, "i", 0x0, "m", 0x0, "e", 0x0, "o"
	DCB	0x0, "u", 0x0, "t", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CG@FKLAKBOO@?$AAD?$AAV?$AAF?$AAS?$AAA?$AAs?$AAy?$AAn?$AAc?$AAE?$AAv?$AAe?$AAn?$AAt?$AAN?$AAa?$AAm?$AAe?$AA?$AA@| DCB "D"
	DCB	0x0, "V", 0x0, "F", 0x0, "S", 0x0, "A", 0x0, "s", 0x0, "y"
	DCB	0x0, "n", 0x0, "c", 0x0, "E", 0x0, "v", 0x0, "e", 0x0, "n"
	DCB	0x0, "t", 0x0, "N", 0x0, "a", 0x0, "m", 0x0, "e", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@CGEFNBAB@?$AAR?$AAx?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?$AA@| DCB "R"
	DCB	0x0, "x", 0x0, "B", 0x0, "u", 0x0, "f", 0x0, "f", 0x0, "e"
	DCB	0x0, "r", 0x0, "S", 0x0, "i", 0x0, "z", 0x0, "e", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@BJJLAMLA@?$AAT?$AAx?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?$AA@| DCB "T"
	DCB	0x0, "x", 0x0, "B", 0x0, "u", 0x0, "f", 0x0, "f", 0x0, "e"
	DCB	0x0, "r", 0x0, "S", 0x0, "i", 0x0, "z", 0x0, "e", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@BKONPLFM@?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB "T", 0x0
	DCB	"i", 0x0, "m", 0x0, "e", 0x0, "o", 0x0, "u", 0x0, "t", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_19OBNDINH@?$AAP?$AAo?$AAr?$AAt?$AA?$AA@| DCB "P", 0x0, "o", 0x0, "r"
	DCB	0x0, "t", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.data|, DATA
|dpCurSettings| DCB "S", 0x0, "P", 0x0, "I", 0x0, 0x0, 0x0
	%	56
	DCB	"E", 0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, "s", 0x0
	DCB	0x0, 0x0
	%	50
	DCB	"W", 0x0, "a", 0x0, "r", 0x0, "n", 0x0, "i", 0x0, "n", 0x0
	DCB	"g", 0x0, "s", 0x0, 0x0, 0x0
	%	46
	DCB	"F", 0x0, "u", 0x0, "n", 0x0, "c", 0x0, "t", 0x0, "i", 0x0
	DCB	"o", 0x0, "n", 0x0, 0x0, 0x0
	%	46
	DCB	"I", 0x0, "n", 0x0, "f", 0x0, "o", 0x0, 0x0, 0x0
	%	54
	DCB	"I", 0x0, "S", 0x0, "T", 0x0, 0x0, 0x0
	%	56
	DCB	"D", 0x0, "M", 0x0, "A", 0x0, 0x0, 0x0
	%	56
	DCB	"D", 0x0, "V", 0x0, "F", 0x0, "S", 0x0, 0x0, 0x0
	%	54
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCD	0x3

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
|DEVICE_IFC_SPI_GUID| DCD 0x2e559225
	DCW	0xc95e
	DCW	0x4300
	DCB	0x86
	DCB	0xe9
	DCB	0x6a
	DCB	0x5c
	DCB	0xbc
	DCB	0x7
	DCB	0x32
	DCB	0x8f
|g_deviceRegParams| DCD |??_C@_19OBNDINH@?$AAP?$AAo?$AAr?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x1
	DCD	0x38
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BA@BKONPLFM@?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x28
	DCD	0x4
	DCD	0x1f4
	DCD	|??_C@_1BK@BJJLAMLA@?$AAT?$AAx?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x2c
	DCD	0x4
	DCD	0x4000
	DCD	|??_C@_1BK@CGEFNBAB@?$AAR?$AAx?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x30
	DCD	0x4
	DCD	0x4000
	DCD	|??_C@_1CG@FKLAKBOO@?$AAD?$AAV?$AAF?$AAS?$AAA?$AAs?$AAy?$AAn?$AAc?$AAE?$AAv?$AAe?$AAn?$AAt?$AAN?$AAa?$AAm?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x54
	DCD	0x208
	DCD	0x0
	DCD	|??_C@_1CA@CCIKILKA@?$AAA?$AAc?$AAt?$AAi?$AAv?$AAi?$AAt?$AAy?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x270
	DCD	0x4
	DCD	0x5
	EXPORT	|ResetEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T45688| DCD	|$LN5@ResetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ResetEvent| PROC

; 223  : _inline BOOL ResetEvent(HANDLE h) {

  00000		 |$LN5@ResetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45685|

; 224  : 	return EventModify(h,EVENT_RESET);

  00004	e3a01002	 mov         r1, #2
  00008	eb000000	 bl          EventModify

; 225  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M45686|

			 ENDP  ; |ResetEvent|

	EXPORT	|SetEvent|

  00000			 AREA	 |.pdata|, PDATA
|$T45698| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45695|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M45696|

			 ENDP  ; |SetEvent|

	EXPORT	|GetCurrentProcessId|
	IMPORT	|__GetUserKData|

  00000			 AREA	 |.pdata|, PDATA
|$T45707| DCD	|$LN5@GetCurrent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentProcessId| PROC

; 373  : _inline DWORD GetCurrentProcessId(void) {

  00000		 |$LN5@GetCurrent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45704|

; 374  :     return __GetUserKData (SYSHANDLE_OFFSET + (SH_CURPROC * sizeof(HANDLE)));

  00004	e3a0000c	 mov         r0, #0xC
  00008	eb000000	 bl          __GetUserKData

; 375  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M45705|

			 ENDP  ; |GetCurrentProcessId|

	EXPORT	|DmaSetElementAndFrameCount|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\inc\omap_sdma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T45717| DCD	|$LN5@DmaSetElem|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaSetElementAndFrameCount| PROC

; 386  : {

  00000		 |$LN5@DmaSetElem|
  00000		 |$M45714|

; 387  :     // setup frame and element count for destination side
; 388  :     //
; 389  :     OUTREG32(&pDataInfo->pDmaLcReg->CEN , countElements);

  00000	e5903014	 ldr         r3, [r0, #0x14]
  00004	e5831014	 str         r1, [r3, #0x14]

; 390  :     OUTREG32(&pDataInfo->pDmaLcReg->CFN , countFrames);

  00008	e5903014	 ldr         r3, [r0, #0x14]
  0000c	e5832018	 str         r2, [r3, #0x18]

; 391  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M45715|

			 ENDP  ; |DmaSetElementAndFrameCount|

	EXPORT	|DmaStop|

  00000			 AREA	 |.pdata|, PDATA
|$T45728| DCD	|$LN12@DmaStop|
	DCD	0x40001201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaStop| PROC

; 449  : {

  00000		 |$LN12@DmaStop|
  00000	e24dd004	 sub         sp, sp, #4
  00004		 |$M45725|

; 450  :     volatile ULONG ulCCR;
; 451  :     BOOL breakLoop = FALSE;
; 452  : 
; 453  :     // disable standby in dma controller
; 454  :     //
; 455  :     CLRREG32(&pDataInfo->pDmaLcReg->CCR , DMA_CCR_ENABLE);

  00004	e5902014	 ldr         r2, [r0, #0x14]
  00008	e3a01000	 mov         r1, #0
  0000c	e5923000	 ldr         r3, [r2]
  00010	e3c33080	 bic         r3, r3, #0x80
  00014	e5823000	 str         r3, [r2]
  00018	e5902014	 ldr         r2, [r0, #0x14]
  0001c		 |$LL5@DmaStop|

; 456  : 
; 457  :     // ensure DMA transfer is completed by polling the active bits
; 458  :     //
; 459  :     while (breakLoop == FALSE)
; 460  :         {
; 461  :         ulCCR = INREG32(&pDataInfo->pDmaLcReg->CCR);

  0001c	e5923000	 ldr         r3, [r2]
  00020	e58d3000	 str         r3, [sp]

; 462  :         if ((ulCCR & DMA_CCR_WR_ACTIVE) || (ulCCR & DMA_CCR_RD_ACTIVE))

  00024	e59d3000	 ldr         r3, [sp]
  00028	e3130b01	 tst         r3, #1, 22
  0002c	059d3000	 ldreq       r3, [sp]
  00030	03130c02	 tsteq       r3, #2, 24

; 463  :             {
; 464  :             // fix this infinite loop
; 465  :             //
; 466  :             continue;
; 467  :             }
; 468  :         else
; 469  :             {
; 470  :             breakLoop = TRUE;

  00034	03a01001	 moveq       r1, #1
  00038	e3510000	 cmp         r1, #0
  0003c	0afffff6	 beq         |$LL5@DmaStop|

; 471  :             }
; 472  :         }
; 473  : 
; 474  : }

  00040	e28dd004	 add         sp, sp, #4
  00044	e12fff1e	 bx          lr
  00048		 |$M45726|

			 ENDP  ; |DmaStop|

	EXPORT	|DmaStart|

  00000			 AREA	 |.pdata|, PDATA
|$T45736| DCD	|$LN5@DmaStart|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaStart| PROC

; 487  : {

  00000		 |$LN5@DmaStart|
  00000		 |$M45733|

; 488  :     // enable the dma channel
; 489  :     //
; 490  :     SETREG32(&pDataInfo->pDmaLcReg->CCR , DMA_CCR_ENABLE);

  00000	e5902014	 ldr         r2, [r0, #0x14]
  00004	e5923000	 ldr         r3, [r2]
  00008	e3833080	 orr         r3, r3, #0x80
  0000c	e5823000	 str         r3, [r2]

; 491  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M45734|

			 ENDP  ; |DmaStart|

	EXPORT	|DmaGetStatus|

  00000			 AREA	 |.pdata|, PDATA
|$T45746| DCD	|$LN5@DmaGetStat|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaGetStatus| PROC

; 559  : {

  00000		 |$LN5@DmaGetStat|
  00000		 |$M45743|

; 560  :     return INREG32(&pDataInfo->pDmaLcReg->CSR);

  00000	e5903014	 ldr         r3, [r0, #0x14]
  00004	e593000c	 ldr         r0, [r3, #0xC]

; 561  : }

  00008	e12fff1e	 bx          lr
  0000c		 |$M45744|

			 ENDP  ; |DmaGetStatus|

	EXPORT	|DmaClearStatus|

  00000			 AREA	 |.pdata|, PDATA
|$T45755| DCD	|$LN5@DmaClearSt|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaClearStatus| PROC

; 575  : {

  00000		 |$LN5@DmaClearSt|
  00000		 |$M45752|

; 576  :     OUTREG32(&pDataInfo->pDmaLcReg->CSR, dwStatus);

  00000	e5903014	 ldr         r3, [r0, #0x14]
  00004	e583100c	 str         r1, [r3, #0xC]

; 577  : }

  00008	e12fff1e	 bx          lr
  0000c		 |$M45753|

			 ENDP  ; |DmaClearStatus|

	EXPORT	|DUMP_DMA_REGS|
	EXPORT	|??_C@_1CI@FLNANDFB@?$AAC?$AAC?$AAR?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@HJOAFDIL@?$AAC?$AAL?$AAN?$AAK?$AA_?$AAC?$AAT?$AAR?$AAL?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@OJOGIMIO@?$AAC?$AAI?$AAC?$AAR?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@OOGCCADM@?$AAC?$AAS?$AAR?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@DOOBPJPF@?$AAC?$AAS?$AAD?$AAP?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@GJLBFIHK@?$AAC?$AAE?$AAN?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@CEFJFIBN@?$AAC?$AAF?$AAN?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@ICCEPAFF@?$AAC?$AAS?$AAS?$AAA?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@CBMOPOBE@?$AAC?$AAD?$AAS?$AAA?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@FFMGOKAE@?$AAC?$AAS?$AAE?$AAI?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@DBCGJBPK@?$AAC?$AAS?$AAF?$AAI?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@PGCMOEEF@?$AAC?$AAD?$AAE?$AAI?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@JCMMJPLL@?$AAC?$AAD?$AAF?$AAI?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@NLPBJPAO@?$AAC?$AAS?$AAA?$AAC?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@HIBLJBEP@?$AAC?$AAD?$AAA?$AAC?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@BPPLKOOL@?$AAC?$AAC?$AAE?$AAN?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@HLBLNFBF@?$AAC?$AAC?$AAF?$AAN?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@FIDDJIDB@?$AAC?$AAO?$AAL?$AAO?$AAR?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|NKDbgPrintfW|
	IMPORT	|DmaGetLogicalChannel|

  00000			 AREA	 |.pdata|, PDATA
|$T45765| DCD	|$LN6@DUMP_DMA_R|
	DCD	0x40005101

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@FLNANDFB@?$AAC?$AAC?$AAR?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| DCB "C"
	DCB	0x0, "C", 0x0, "R", 0x0, " ", 0x0, " ", 0x0, " ", 0x0, " "
	DCB	0x0, " ", 0x0, " ", 0x0, ":", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@HJOAFDIL@?$AAC?$AAL?$AAN?$AAK?$AA_?$AAC?$AAT?$AAR?$AAL?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| DCB "C"
	DCB	0x0, "L", 0x0, "N", 0x0, "K", 0x0, "_", 0x0, "C", 0x0, "T"
	DCB	0x0, "R", 0x0, "L", 0x0, ":", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@OJOGIMIO@?$AAC?$AAI?$AAC?$AAR?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| DCB "C"
	DCB	0x0, "I", 0x0, "C", 0x0, "R", 0x0, " ", 0x0, " ", 0x0, " "
	DCB	0x0, " ", 0x0, " ", 0x0, ":", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@OOGCCADM@?$AAC?$AAS?$AAR?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| DCB "C"
	DCB	0x0, "S", 0x0, "R", 0x0, " ", 0x0, " ", 0x0, " ", 0x0, " "
	DCB	0x0, " ", 0x0, " ", 0x0, ":", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@DOOBPJPF@?$AAC?$AAS?$AAD?$AAP?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| DCB "C"
	DCB	0x0, "S", 0x0, "D", 0x0, "P", 0x0, " ", 0x0, " ", 0x0, " "
	DCB	0x0, " ", 0x0, " ", 0x0, ":", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@GJLBFIHK@?$AAC?$AAE?$AAN?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| DCB "C"
	DCB	0x0, "E", 0x0, "N", 0x0, " ", 0x0, " ", 0x0, " ", 0x0, " "
	DCB	0x0, " ", 0x0, " ", 0x0, ":", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@CEFJFIBN@?$AAC?$AAF?$AAN?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| DCB "C"
	DCB	0x0, "F", 0x0, "N", 0x0, " ", 0x0, " ", 0x0, " ", 0x0, " "
	DCB	0x0, " ", 0x0, " ", 0x0, ":", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@ICCEPAFF@?$AAC?$AAS?$AAS?$AAA?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| DCB "C"
	DCB	0x0, "S", 0x0, "S", 0x0, "A", 0x0, " ", 0x0, " ", 0x0, " "
	DCB	0x0, " ", 0x0, " ", 0x0, ":", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@CBMOPOBE@?$AAC?$AAD?$AAS?$AAA?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| DCB "C"
	DCB	0x0, "D", 0x0, "S", 0x0, "A", 0x0, " ", 0x0, " ", 0x0, " "
	DCB	0x0, " ", 0x0, " ", 0x0, ":", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@FFMGOKAE@?$AAC?$AAS?$AAE?$AAI?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| DCB "C"
	DCB	0x0, "S", 0x0, "E", 0x0, "I", 0x0, " ", 0x0, " ", 0x0, " "
	DCB	0x0, " ", 0x0, " ", 0x0, ":", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@DBCGJBPK@?$AAC?$AAS?$AAF?$AAI?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| DCB "C"
	DCB	0x0, "S", 0x0, "F", 0x0, "I", 0x0, " ", 0x0, " ", 0x0, " "
	DCB	0x0, " ", 0x0, " ", 0x0, ":", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@PGCMOEEF@?$AAC?$AAD?$AAE?$AAI?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| DCB "C"
	DCB	0x0, "D", 0x0, "E", 0x0, "I", 0x0, " ", 0x0, " ", 0x0, " "
	DCB	0x0, " ", 0x0, " ", 0x0, ":", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@JCMMJPLL@?$AAC?$AAD?$AAF?$AAI?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| DCB "C"
	DCB	0x0, "D", 0x0, "F", 0x0, "I", 0x0, " ", 0x0, " ", 0x0, " "
	DCB	0x0, " ", 0x0, " ", 0x0, ":", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@NLPBJPAO@?$AAC?$AAS?$AAA?$AAC?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| DCB "C"
	DCB	0x0, "S", 0x0, "A", 0x0, "C", 0x0, " ", 0x0, " ", 0x0, " "
	DCB	0x0, " ", 0x0, " ", 0x0, ":", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@HIBLJBEP@?$AAC?$AAD?$AAA?$AAC?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| DCB "C"
	DCB	0x0, "D", 0x0, "A", 0x0, "C", 0x0, " ", 0x0, " ", 0x0, " "
	DCB	0x0, " ", 0x0, " ", 0x0, ":", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@BPPLKOOL@?$AAC?$AAC?$AAE?$AAN?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| DCB "C"
	DCB	0x0, "C", 0x0, "E", 0x0, "N", 0x0, " ", 0x0, " ", 0x0, " "
	DCB	0x0, " ", 0x0, " ", 0x0, ":", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@HLBLNFBF@?$AAC?$AAC?$AAF?$AAN?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| DCB "C"
	DCB	0x0, "C", 0x0, "F", 0x0, "N", 0x0, " ", 0x0, " ", 0x0, " "
	DCB	0x0, " ", 0x0, " ", 0x0, ":", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@FIDDJIDB@?$AAC?$AAO?$AAL?$AAO?$AAR?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@| DCB "C"
	DCB	0x0, "O", 0x0, "L", 0x0, "O", 0x0, "R", 0x0, " ", 0x0, " "
	DCB	0x0, " ", 0x0, " ", 0x0, ":", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "X", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DUMP_DMA_REGS| PROC

; 678  : {

  00000		 |$LN6@DUMP_DMA_R|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45762|
  00004	e1a05001	 mov         r5, r1

; 679  :     OMAP_DMA_LC_REGS *pDmaLcReg = (OMAP_DMA_LC_REGS*)DmaGetLogicalChannel(hDmaChannel);

  00008	eb000000	 bl          DmaGetLogicalChannel
  0000c	e1b04000	 movs        r4, r0

; 680  :     if (pDmaLcReg == NULL)

  00010	0a000037	 beq         |$LN2@DUMP_DMA_R|

; 681  :         {
; 682  :         return;
; 683  :         }
; 684  : 
; 685  :     RETAILMSG(1,(szMsg));

  00014	e1a00005	 mov         r0, r5
  00018	eb000000	 bl          NKDbgPrintfW

; 686  : 
; 687  :     RETAILMSG(1,(TEXT("CCR      : 0x%08X\r\n"), INREG32(&pDmaLcReg->CCR   )));

  0001c	e5941000	 ldr         r1, [r4]
  00020	e59f0118	 ldr         r0, [pc, #0x118]
  00024	eb000000	 bl          NKDbgPrintfW

; 688  :     RETAILMSG(1,(TEXT("CLNK_CTRL: 0x%08X\r\n"), INREG32(&pDmaLcReg->CLNK_CTRL)));

  00028	e5941004	 ldr         r1, [r4, #4]
  0002c	e59f0108	 ldr         r0, [pc, #0x108]
  00030	eb000000	 bl          NKDbgPrintfW

; 689  :     RETAILMSG(1,(TEXT("CICR     : 0x%08X\r\n"), INREG32(&pDmaLcReg->CICR  )));

  00034	e5941008	 ldr         r1, [r4, #8]
  00038	e59f00f8	 ldr         r0, [pc, #0xF8]
  0003c	eb000000	 bl          NKDbgPrintfW

; 690  :     RETAILMSG(1,(TEXT("CSR      : 0x%08X\r\n"), INREG32(&pDmaLcReg->CSR   )));

  00040	e594100c	 ldr         r1, [r4, #0xC]
  00044	e59f00e8	 ldr         r0, [pc, #0xE8]
  00048	eb000000	 bl          NKDbgPrintfW

; 691  :     RETAILMSG(1,(TEXT("CSDP     : 0x%08X\r\n"), INREG32(&pDmaLcReg->CSDP  )));

  0004c	e5941010	 ldr         r1, [r4, #0x10]
  00050	e59f00d8	 ldr         r0, [pc, #0xD8]
  00054	eb000000	 bl          NKDbgPrintfW

; 692  :     RETAILMSG(1,(TEXT("CEN      : 0x%08X\r\n"), INREG32(&pDmaLcReg->CEN   )));

  00058	e5941014	 ldr         r1, [r4, #0x14]
  0005c	e59f00c8	 ldr         r0, [pc, #0xC8]
  00060	eb000000	 bl          NKDbgPrintfW

; 693  :     RETAILMSG(1,(TEXT("CFN      : 0x%08X\r\n"), INREG32(&pDmaLcReg->CFN   )));

  00064	e5941018	 ldr         r1, [r4, #0x18]
  00068	e59f00b8	 ldr         r0, [pc, #0xB8]
  0006c	eb000000	 bl          NKDbgPrintfW

; 694  :     RETAILMSG(1,(TEXT("CSSA     : 0x%08X\r\n"), INREG32(&pDmaLcReg->CSSA  )));

  00070	e594101c	 ldr         r1, [r4, #0x1C]
  00074	e59f00a8	 ldr         r0, [pc, #0xA8]
  00078	eb000000	 bl          NKDbgPrintfW

; 695  :     RETAILMSG(1,(TEXT("CDSA     : 0x%08X\r\n"), INREG32(&pDmaLcReg->CDSA  )));

  0007c	e5941020	 ldr         r1, [r4, #0x20]
  00080	e59f0098	 ldr         r0, [pc, #0x98]
  00084	eb000000	 bl          NKDbgPrintfW

; 696  :     RETAILMSG(1,(TEXT("CSEI     : 0x%08X\r\n"), INREG32(&pDmaLcReg->CSEI  )));

  00088	e5941024	 ldr         r1, [r4, #0x24]
  0008c	e59f0088	 ldr         r0, [pc, #0x88]
  00090	eb000000	 bl          NKDbgPrintfW

; 697  :     RETAILMSG(1,(TEXT("CSFI     : 0x%08X\r\n"), INREG32(&pDmaLcReg->CSFI  )));

  00094	e5941028	 ldr         r1, [r4, #0x28]
  00098	e59f0078	 ldr         r0, [pc, #0x78]
  0009c	eb000000	 bl          NKDbgPrintfW

; 698  :     RETAILMSG(1,(TEXT("CDEI     : 0x%08X\r\n"), INREG32(&pDmaLcReg->CDEI  )));

  000a0	e594102c	 ldr         r1, [r4, #0x2C]
  000a4	e59f0068	 ldr         r0, [pc, #0x68]
  000a8	eb000000	 bl          NKDbgPrintfW

; 699  :     RETAILMSG(1,(TEXT("CDFI     : 0x%08X\r\n"), INREG32(&pDmaLcReg->CDFI  )));

  000ac	e5941030	 ldr         r1, [r4, #0x30]
  000b0	e59f0058	 ldr         r0, [pc, #0x58]
  000b4	eb000000	 bl          NKDbgPrintfW

; 700  :     RETAILMSG(1,(TEXT("CSAC     : 0x%08X\r\n"), INREG32(&pDmaLcReg->CSAC  )));

  000b8	e5941034	 ldr         r1, [r4, #0x34]
  000bc	e59f0048	 ldr         r0, [pc, #0x48]
  000c0	eb000000	 bl          NKDbgPrintfW

; 701  :     RETAILMSG(1,(TEXT("CDAC     : 0x%08X\r\n"), INREG32(&pDmaLcReg->CDAC  )));

  000c4	e5941038	 ldr         r1, [r4, #0x38]
  000c8	e59f0038	 ldr         r0, [pc, #0x38]
  000cc	eb000000	 bl          NKDbgPrintfW

; 702  :     RETAILMSG(1,(TEXT("CCEN     : 0x%08X\r\n"), INREG32(&pDmaLcReg->CCEN  )));

  000d0	e594103c	 ldr         r1, [r4, #0x3C]
  000d4	e59f0028	 ldr         r0, [pc, #0x28]
  000d8	eb000000	 bl          NKDbgPrintfW

; 703  :     RETAILMSG(1,(TEXT("CCFN     : 0x%08X\r\n"), INREG32(&pDmaLcReg->CCFN  )));

  000dc	e5941040	 ldr         r1, [r4, #0x40]
  000e0	e59f0018	 ldr         r0, [pc, #0x18]
  000e4	eb000000	 bl          NKDbgPrintfW

; 704  :     RETAILMSG(1,(TEXT("COLOR    : 0x%08X\r\n"), INREG32(&pDmaLcReg->COLOR )));

  000e8	e5941044	 ldr         r1, [r4, #0x44]
  000ec	e59f0008	 ldr         r0, [pc, #8]
  000f0	eb000000	 bl          NKDbgPrintfW
  000f4		 |$LN2@DUMP_DMA_R|

; 705  : }

  000f4	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000f8	e12fff1e	 bx          lr
  000fc		 |$LN7@DUMP_DMA_R|
  000fc		 |$LN8@DUMP_DMA_R|
  000fc	00000000	 DCD         |??_C@_1CI@FIDDJIDB@?$AAC?$AAO?$AAL?$AAO?$AAR?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@|
  00100		 |$LN9@DUMP_DMA_R|
  00100	00000000	 DCD         |??_C@_1CI@HLBLNFBF@?$AAC?$AAC?$AAF?$AAN?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@|
  00104		 |$LN10@DUMP_DMA_R|
  00104	00000000	 DCD         |??_C@_1CI@BPPLKOOL@?$AAC?$AAC?$AAE?$AAN?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@|
  00108		 |$LN11@DUMP_DMA_R|
  00108	00000000	 DCD         |??_C@_1CI@HIBLJBEP@?$AAC?$AAD?$AAA?$AAC?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@|
  0010c		 |$LN12@DUMP_DMA_R|
  0010c	00000000	 DCD         |??_C@_1CI@NLPBJPAO@?$AAC?$AAS?$AAA?$AAC?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@|
  00110		 |$LN13@DUMP_DMA_R|
  00110	00000000	 DCD         |??_C@_1CI@JCMMJPLL@?$AAC?$AAD?$AAF?$AAI?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@|
  00114		 |$LN14@DUMP_DMA_R|
  00114	00000000	 DCD         |??_C@_1CI@PGCMOEEF@?$AAC?$AAD?$AAE?$AAI?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@|
  00118		 |$LN15@DUMP_DMA_R|
  00118	00000000	 DCD         |??_C@_1CI@DBCGJBPK@?$AAC?$AAS?$AAF?$AAI?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@|
  0011c		 |$LN16@DUMP_DMA_R|
  0011c	00000000	 DCD         |??_C@_1CI@FFMGOKAE@?$AAC?$AAS?$AAE?$AAI?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@|
  00120		 |$LN17@DUMP_DMA_R|
  00120	00000000	 DCD         |??_C@_1CI@CBMOPOBE@?$AAC?$AAD?$AAS?$AAA?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@|
  00124		 |$LN18@DUMP_DMA_R|
  00124	00000000	 DCD         |??_C@_1CI@ICCEPAFF@?$AAC?$AAS?$AAS?$AAA?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@|
  00128		 |$LN19@DUMP_DMA_R|
  00128	00000000	 DCD         |??_C@_1CI@CEFJFIBN@?$AAC?$AAF?$AAN?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@|
  0012c		 |$LN20@DUMP_DMA_R|
  0012c	00000000	 DCD         |??_C@_1CI@GJLBFIHK@?$AAC?$AAE?$AAN?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@|
  00130		 |$LN21@DUMP_DMA_R|
  00130	00000000	 DCD         |??_C@_1CI@DOOBPJPF@?$AAC?$AAS?$AAD?$AAP?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@|
  00134		 |$LN22@DUMP_DMA_R|
  00134	00000000	 DCD         |??_C@_1CI@OOGCCADM@?$AAC?$AAS?$AAR?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@|
  00138		 |$LN23@DUMP_DMA_R|
  00138	00000000	 DCD         |??_C@_1CI@OJOGIMIO@?$AAC?$AAI?$AAC?$AAR?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@|
  0013c		 |$LN24@DUMP_DMA_R|
  0013c	00000000	 DCD         |??_C@_1CI@HJOAFDIL@?$AAC?$AAL?$AAN?$AAK?$AA_?$AAC?$AAT?$AAR?$AAL?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@|
  00140		 |$LN25@DUMP_DMA_R|
  00140	00000000	 DCD         |??_C@_1CI@FLNANDFB@?$AAC?$AAC?$AAR?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?5?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AN?$AA?6?$AA?$AA@|
  00144		 |$M45763|

			 ENDP  ; |DUMP_DMA_REGS|

	EXPORT	|SpiDmaTxEnabled|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\spi\spi_priv.h

  00000			 AREA	 |.pdata|, PDATA
|$T45796| DCD	|$LN7@SpiDmaTxEn|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SpiDmaTxEnabled| PROC

; 155  : {

  00000		 |$LN7@SpiDmaTxEn|
  00000		 |$M45793|

; 156  :     //  Return enabled BOOL
; 157  :     return( pInstance->hTxDmaChannel != NULL );

  00000	e5903018	 ldr         r3, [r0, #0x18]
  00004	e3530000	 cmp         r3, #0
  00008	13a00001	 movne       r0, #1
  0000c	03a00000	 moveq       r0, #0

; 158  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M45794|

			 ENDP  ; |SpiDmaTxEnabled|

	EXPORT	|SpiDmaRxEnabled|

  00000			 AREA	 |.pdata|, PDATA
|$T45808| DCD	|$LN7@SpiDmaRxEn|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SpiDmaRxEnabled| PROC

; 164  : {

  00000		 |$LN7@SpiDmaRxEn|
  00000		 |$M45805|

; 165  :     //  Return enabled BOOL
; 166  :     return( pInstance->hRxDmaChannel != NULL );

  00000	e590301c	 ldr         r3, [r0, #0x1C]
  00004	e3530000	 cmp         r3, #0
  00008	13a00001	 movne       r0, #1
  0000c	03a00000	 moveq       r0, #0

; 167  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M45806|

			 ENDP  ; |SpiDmaRxEnabled|

	EXPORT	|CheckAndHaltAllDma|
	IMPORT	|LeaveCriticalSection|
	IMPORT	|EnterCriticalSection|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T45822| DCD	|$LN9@CheckAndHa|
	DCD	0x40001301
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\spi\spi.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |CheckAndHaltAllDma| PROC

; 93   : {

  00000		 |$LN9@CheckAndHa|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45819|
  00004	e1a05001	 mov         r5, r1

; 94   :     SPI_DEVICE *pDevice = pInstance->pDevice;

  00008	e5904004	 ldr         r4, [r0, #4]

; 95   :     
; 96   :     DEBUGMSG(ZONE_FUNCTION, (
; 97   :         L"+CheckAndHaltAllDma(0x%08x, %d)\r\n", 
; 98   :         pInstance, bHalt
; 99   :         ));
; 100  : 
; 101  :     EnterCriticalSection(&pDevice->csDVFS);

  0000c	e2840f97	 add         r0, r4, #0x97, 30
  00010	eb000000	 bl          EnterCriticalSection

; 102  : 
; 103  :     if (pDevice->nActiveDmaCount == 0 && bHalt == TRUE)

  00014	e5943048	 ldr         r3, [r4, #0x48]
  00018	e3530000	 cmp         r3, #0
  0001c	1a000006	 bne         |$LN5@CheckAndHa|
  00020	e3550001	 cmp         r5, #1
  00024	1a000004	 bne         |$LN5@CheckAndHa|

; 104  :         {
; 105  :         if (pDevice->hDVFSAsyncEvent != NULL)

  00028	e5943050	 ldr         r3, [r4, #0x50]
  0002c	e3530000	 cmp         r3, #0

; 106  :             {
; 107  :             SetEvent(pDevice->hDVFSAsyncEvent);

  00030	13a01003	 movne       r1, #3
  00034	11a00003	 movne       r0, r3
  00038	1b000000	 blne        EventModify
  0003c		 |$LN5@CheckAndHa|

; 108  :             }
; 109  :         }
; 110  :     
; 111  :     LeaveCriticalSection(&pDevice->csDVFS);

  0003c	e2840f97	 add         r0, r4, #0x97, 30
  00040	eb000000	 bl          LeaveCriticalSection

; 112  : 
; 113  :     DEBUGMSG(ZONE_FUNCTION, (L"-CheckAndHaltAllDma()\r\n"));
; 114  : }

  00044	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00048	e12fff1e	 bx          lr
  0004c		 |$M45820|

			 ENDP  ; |CheckAndHaltAllDma|

	EXPORT	|PreDmaActivation|
	IMPORT	|InterlockedIncrement|
	IMPORT	|WaitForSingleObject|

  00000			 AREA	 |.pdata|, PDATA
|$T45831| DCD	|$LN6@PreDmaActi|
	DCD	0x40001401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PreDmaActivation| PROC

; 125  : {

  00000		 |$LN6@PreDmaActi|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M45828|

; 126  :     SPI_DEVICE *pDevice = pInstance->pDevice;

  00004	e5904004	 ldr         r4, [r0, #4]

; 127  :     
; 128  :     DEBUGMSG(ZONE_FUNCTION, (
; 129  :         L"+PreDmaActivation(0x%08x)\r\n", pInstance
; 130  :     ));
; 131  :     
; 132  :     // this operation needs to be atomic to handle a corner case
; 133  :     EnterCriticalSection(&pDevice->csDVFS);

  00008	e2840f97	 add         r0, r4, #0x97, 30
  0000c	eb000000	 bl          EnterCriticalSection

; 134  :     
; 135  :     // check and wait for DVFS activity to complete
; 136  :     if (pDevice->bDVFSActive == TRUE)

  00010	e5943044	 ldr         r3, [r4, #0x44]
  00014	e3530001	 cmp         r3, #1
  00018	1a000006	 bne         |$LN1@PreDmaActi|

; 137  :         {
; 138  :         // avoid deadlock's while waiting for dvfs transitions
; 139  :         //
; 140  :         LeaveCriticalSection(&pDevice->csDVFS);

  0001c	e2840f97	 add         r0, r4, #0x97, 30
  00020	eb000000	 bl          LeaveCriticalSection

; 141  :         WaitForSingleObject(pDevice->hDVFSInactiveEvent, INFINITE);

  00024	e594004c	 ldr         r0, [r4, #0x4C]
  00028	e3e01000	 mvn         r1, #0
  0002c	eb000000	 bl          WaitForSingleObject

; 142  :         EnterCriticalSection(&pDevice->csDVFS);

  00030	e2840f97	 add         r0, r4, #0x97, 30
  00034	eb000000	 bl          EnterCriticalSection
  00038		 |$LN1@PreDmaActi|

; 143  :         }
; 144  :     InterlockedIncrement(&pDevice->nActiveDmaCount);

  00038	e2840048	 add         r0, r4, #0x48
  0003c	eb000000	 bl          InterlockedIncrement

; 145  : 
; 146  :     LeaveCriticalSection(&pDevice->csDVFS);

  00040	e2840f97	 add         r0, r4, #0x97, 30
  00044	eb000000	 bl          LeaveCriticalSection

; 147  : 
; 148  :     DEBUGMSG(ZONE_FUNCTION, (
; 149  :         L"-PreDmaActivation()\r\n"
; 150  :         ));
; 151  : }

  00048	e8bd4010	 ldmia       sp!, {r4, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M45829|

			 ENDP  ; |PreDmaActivation|

	EXPORT	|PostDmaDeactivation|
	IMPORT	|InterlockedDecrement|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T45844| DCD	|$LN9@PostDmaDea|
	DCD	0x40001501
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\spi\spi.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PostDmaDeactivation| PROC

; 161  : {

  00000		 |$LN9@PostDmaDea|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M45841|

; 162  :     SPI_DEVICE *pDevice = pInstance->pDevice;

  00004	e5904004	 ldr         r4, [r0, #4]

; 163  :     
; 164  :     DEBUGMSG(ZONE_FUNCTION, (
; 165  :         L"+PostDmaDeactivation(0x%08x)\r\n", pInstance
; 166  :     ));
; 167  :     
; 168  :     ASSERT(pDevice->nActiveDmaCount > 0);
; 169  : 
; 170  :     // this operation needs to be atomic to handle a corner case
; 171  :     EnterCriticalSection(&pDevice->csDVFS);

  00008	e2840f97	 add         r0, r4, #0x97, 30
  0000c	eb000000	 bl          EnterCriticalSection

; 172  :     
; 173  :     // check if all dma's are inactive and signal ack event if so
; 174  :     InterlockedDecrement(&pDevice->nActiveDmaCount);

  00010	e2840048	 add         r0, r4, #0x48
  00014	eb000000	 bl          InterlockedDecrement

; 175  :     if (pDevice->bDVFSActive == TRUE && pDevice->nActiveDmaCount <= 0)

  00018	e5943044	 ldr         r3, [r4, #0x44]
  0001c	e3530001	 cmp         r3, #1
  00020	1a000007	 bne         |$LN5@PostDmaDea|
  00024	e5943048	 ldr         r3, [r4, #0x48]
  00028	e3530000	 cmp         r3, #0
  0002c	ca000004	 bgt         |$LN5@PostDmaDea|

; 176  :         {
; 177  :         if (pDevice->hDVFSAsyncEvent != NULL) 

  00030	e5943050	 ldr         r3, [r4, #0x50]
  00034	e3530000	 cmp         r3, #0

; 178  :         {
; 179  :             SetEvent(pDevice->hDVFSAsyncEvent);

  00038	13a01003	 movne       r1, #3
  0003c	11a00003	 movne       r0, r3
  00040	1b000000	 blne        EventModify
  00044		 |$LN5@PostDmaDea|

; 180  :         }
; 181  :         }
; 182  : 
; 183  :     LeaveCriticalSection(&pDevice->csDVFS);

  00044	e2840f97	 add         r0, r4, #0x97, 30
  00048	eb000000	 bl          LeaveCriticalSection

; 184  : 
; 185  :     DEBUGMSG(ZONE_FUNCTION, (
; 186  :         L"-PostDmaDeactivation()\r\n"
; 187  :         ));
; 188  : }

  0004c	e8bd4010	 ldmia       sp!, {r4, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$M45842|

			 ENDP  ; |PostDmaDeactivation|

	EXPORT	|SPIPowerTimerThread|
	IMPORT	|ReleaseMutex|
	IMPORT	|SetDevicePowerState|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T45866| DCD	|$LN19@SPIPowerTi|
	DCD	0x40003101
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\spi\spi.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPIPowerTimerThread| PROC

; 201  : {

  00000		 |$LN19@SPIPowerTi|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M45863|
  00004	e1a04000	 mov         r4, r0

; 202  :     DWORD nTimeout = INFINITE;

  00008	e3a03cff	 mov         r3, #0xFF, 24
  0000c	e38360ff	 orr         r6, r3, #0xFF
  00010	e3e05000	 mvn         r5, #0
  00014	e3a08004	 mov         r8, #4
  00018	e3a07001	 mov         r7, #1
  0001c		 |$LL7@SPIPowerTi|

; 203  :     SPI_DEVICE *pDevice = (SPI_DEVICE*)(pv);
; 204  : 	BOOL exp = TRUE;
; 205  : 
; 206  :     while (exp)
; 207  :         {
; 208  :         WaitForSingleObject(pDevice->hTimerEvent, nTimeout);

  0001c	e5940278	 ldr         r0, [r4, #0x278]
  00020	e1a01005	 mov         r1, r5
  00024	eb000000	 bl          WaitForSingleObject

; 209  : 
; 210  :         if (pDevice->bExitThread == TRUE) break;

  00028	e5943280	 ldr         r3, [r4, #0x280]
  0002c	e3530001	 cmp         r3, #1
  00030	0a000020	 beq         |$LN15@SPIPowerTi|

; 211  : 
; 212  :         // serialize access to power state changes
; 213  : 		WaitForSingleObject(pDevice->hControllerMutex, INFINITE);

  00034	e594001c	 ldr         r0, [r4, #0x1C]
  00038	e3e01000	 mvn         r1, #0
  0003c	eb000000	 bl          WaitForSingleObject

; 214  : 
; 215  :         // by the time this thread got the lock hTimerEvent may 
; 216  :         // have gotten resignaled.  Clear the event to  make
; 217  :         // sure the activity timer thread isn't awaken prematurely
; 218  :         //
; 219  :         ResetEvent(pDevice->hTimerEvent);

  00040	e5940278	 ldr         r0, [r4, #0x278]
  00044	e3a01002	 mov         r1, #2
  00048	eb000000	 bl          EventModify

; 220  : 
; 221  :         // check if we need to reset the timer
; 222  :         if (pDevice->nPowerCounter == 0)

  0004c	e5943284	 ldr         r3, [r4, #0x284]
  00050	e3530000	 cmp         r3, #0
  00054	1a000013	 bne         |$LN4@SPIPowerTi|

; 223  :             {
; 224  :             // We disable the power only when this thread
; 225  :             // wakes-up twice in a row with no power state
; 226  :             // change to D0.  This is achieved by using the
; 227  :             // bDisablePower flag to determine if power state
; 228  :             // changed since the last time this thread woke-up
; 229  :             //
; 230  :             if (pDevice->bDisablePower == TRUE)

  00058	e594327c	 ldr         r3, [r4, #0x27C]
  0005c	e3530001	 cmp         r3, #1
  00060	1a00000d	 bne         |$LN3@SPIPowerTi|

; 231  :                 {
; 232  :                 // force idle
; 233  :                 OUTREG32(&pDevice->pSPIRegs->MCSPI_SYSCONFIG,
; 234  :                        MCSPI_SYSCONFIG_ENAWAKEUP);

  00064	e5943018	 ldr         r3, [r4, #0x18]

; 235  : 
; 236  :                 // Clear interrupts.
; 237  :                 OUTREG32(&pDevice->pSPIRegs->MCSPI_IRQSTATUS, 0xFFFF);
; 238  :                 
; 239  :                 //EnableDeviceClocks(pDevice->deviceID, FALSE);
; 240  : 
; 241  :                 SetDevicePowerState(pDevice->hParentBus, D4, 0);                

  00068	e3a02000	 mov         r2, #0
  0006c	e3a01004	 mov         r1, #4
  00070	e5838010	 str         r8, [r3, #0x10]
  00074	e5943018	 ldr         r3, [r4, #0x18]
  00078	e5836018	 str         r6, [r3, #0x18]
  0007c	e5940014	 ldr         r0, [r4, #0x14]
  00080	eb000000	 bl          SetDevicePowerState

; 242  :                 pDevice->powerState = D4;
; 243  :                 nTimeout = INFINITE;
; 244  :                 SetEvent(pDevice->hDeviceOffEvent);

  00084	e594028c	 ldr         r0, [r4, #0x28C]
  00088	e3a01003	 mov         r1, #3
  0008c	e5848034	 str         r8, [r4, #0x34]
  00090	e3e05000	 mvn         r5, #0
  00094	eb000000	 bl          EventModify

; 245  :                 }
; 246  :             else

  00098	ea000003	 b           |$LN1@SPIPowerTi|
  0009c		 |$LN3@SPIPowerTi|

; 247  :                 {
; 248  :                 // wait for activity time-out before shutting off power.
; 249  :                 pDevice->bDisablePower = TRUE;
; 250  :                 nTimeout = pDevice->nActivityTimeout;

  0009c	e5945270	 ldr         r5, [r4, #0x270]
  000a0	e584727c	 str         r7, [r4, #0x27C]

; 251  :                 }
; 252  :             }
; 253  :         else

  000a4	ea000000	 b           |$LN1@SPIPowerTi|
  000a8		 |$LN4@SPIPowerTi|

; 254  :             {
; 255  :             // disable power and wait for timer to get restarted
; 256  :             nTimeout = INFINITE;

  000a8	e3e05000	 mvn         r5, #0
  000ac		 |$LN1@SPIPowerTi|

; 257  :             }
; 258  : 		ReleaseMutex(pDevice->hControllerMutex);

  000ac	e594001c	 ldr         r0, [r4, #0x1C]
  000b0	eb000000	 bl          ReleaseMutex
  000b4	eaffffd8	 b           |$LL7@SPIPowerTi|
  000b8		 |$LN15@SPIPowerTi|

; 259  :         }
; 260  : 
; 261  :     return 1;

  000b8	e3a00001	 mov         r0, #1

; 262  : }

  000bc	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000c0	e12fff1e	 bx          lr
  000c4		 |$M45864|

			 ENDP  ; |SPIPowerTimerThread|

	EXPORT	|SetSPIPower|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T45885| DCD	|$LN15@SetSPIPowe|
	DCD	0x40003b01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\spi\spi.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetSPIPower| PROC

; 276  : {

  00000		 |$LN15@SetSPIPowe|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45882|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 277  :     // enable power when the power state request is D0-D2
; 278  : 	WaitForSingleObject(pDevice->hControllerMutex, INFINITE);

  0000c	e595001c	 ldr         r0, [r5, #0x1C]
  00010	e3e01000	 mvn         r1, #0
  00014	eb000000	 bl          WaitForSingleObject

; 279  : 
; 280  :     if (state < D3)

  00018	e3540003	 cmp         r4, #3
  0001c	aa000010	 bge         |$LN6@SetSPIPowe|

; 281  :         {
; 282  :         if (pDevice->powerState >= D3)

  00020	e5953034	 ldr         r3, [r5, #0x34]
  00024	e3a04000	 mov         r4, #0
  00028	e3530003	 cmp         r3, #3
  0002c	ba000007	 blt         |$LN5@SetSPIPowe|

; 283  :             {
; 284  : 			//EnableDeviceClocks(pDevice->deviceID, TRUE);
; 285  :             SetDevicePowerState(pDevice->hParentBus, D0, NULL);

  00030	e5950014	 ldr         r0, [r5, #0x14]
  00034	e3a02000	 mov         r2, #0
  00038	e3a01000	 mov         r1, #0
  0003c	eb000000	 bl          SetDevicePowerState

; 286  :             pDevice->powerState = D0;            
; 287  : 
; 288  :             // smart idle
; 289  :             OUTREG32(&pDevice->pSPIRegs->MCSPI_SYSCONFIG,
; 290  :                 MCSPI_SYSCONFIG_AUTOIDLE |
; 291  :                 MCSPI_SYSCONFIG_SMARTIDLE |
; 292  :                 MCSPI_SYSCONFIG_ENAWAKEUP);

  00040	e5953018	 ldr         r3, [r5, #0x18]
  00044	e3a02015	 mov         r2, #0x15
  00048	e5854034	 str         r4, [r5, #0x34]
  0004c	e5832010	 str         r2, [r3, #0x10]
  00050		 |$LN5@SetSPIPowe|

; 293  :             }
; 294  :         pDevice->bDisablePower = FALSE;
; 295  :         pDevice->nPowerCounter++;

  00050	e5953284	 ldr         r3, [r5, #0x284]
  00054	e585427c	 str         r4, [r5, #0x27C]
  00058	e2833001	 add         r3, r3, #1
  0005c	e5853284	 str         r3, [r5, #0x284]

; 296  :         }
; 297  :     else

  00060	ea00001c	 b           |$LN1@SetSPIPowe|
  00064		 |$LN6@SetSPIPowe|

; 298  :         {
; 299  :         pDevice->nPowerCounter--;

  00064	e5953284	 ldr         r3, [r5, #0x284]
  00068	e2533001	 subs        r3, r3, #1
  0006c	e5853284	 str         r3, [r5, #0x284]

; 300  :         if (pDevice->nPowerCounter == 0)

  00070	1a000018	 bne         |$LN1@SetSPIPowe|

; 301  :             {
; 302  :             if ((pDevice->hTimerEvent != NULL) && (pDevice->systemState != D4))

  00074	e5953278	 ldr         r3, [r5, #0x278]
  00078	e3530000	 cmp         r3, #0
  0007c	0a000009	 beq         |$LN2@SetSPIPowe|
  00080	e5953290	 ldr         r3, [r5, #0x290]
  00084	e3530004	 cmp         r3, #4
  00088	0a000006	 beq         |$LN2@SetSPIPowe|

; 303  :                 {
; 304  :                 // Reset the device OFF event, set
; 305  :                 // after the device is put to D4 state
; 306  :                 ResetEvent(pDevice->hDeviceOffEvent);

  0008c	e595028c	 ldr         r0, [r5, #0x28C]
  00090	e3a01002	 mov         r1, #2
  00094	eb000000	 bl          EventModify

; 307  : 
; 308  :                 SetEvent(pDevice->hTimerEvent);

  00098	e5950278	 ldr         r0, [r5, #0x278]
  0009c	e3a01003	 mov         r1, #3
  000a0	eb000000	 bl          EventModify

; 309  :                 }
; 310  :             else

  000a4	ea00000b	 b           |$LN1@SetSPIPowe|
  000a8		 |$LN2@SetSPIPowe|

; 311  :                 {
; 312  :                 // force idle
; 313  :                 OUTREG32(&pDevice->pSPIRegs->MCSPI_SYSCONFIG,
; 314  :                        MCSPI_SYSCONFIG_ENAWAKEUP);

  000a8	e5953018	 ldr         r3, [r5, #0x18]
  000ac	e3a04004	 mov         r4, #4
  000b0	e3a02cff	 mov         r2, #0xFF, 24
  000b4	e5834010	 str         r4, [r3, #0x10]

; 315  : 
; 316  :                 // Clear interrupts.
; 317  :                 OUTREG32(&pDevice->pSPIRegs->MCSPI_IRQSTATUS, 0xFFFF);

  000b8	e5951018	 ldr         r1, [r5, #0x18]
  000bc	e38230ff	 orr         r3, r2, #0xFF

; 318  : 
; 319  :                 //EnableDeviceClocks(pDevice->deviceID, FALSE);
; 320  :                 SetDevicePowerState(pDevice->hParentBus, D4, NULL);

  000c0	e3a02000	 mov         r2, #0
  000c4	e5813018	 str         r3, [r1, #0x18]
  000c8	e5950014	 ldr         r0, [r5, #0x14]
  000cc	e3a01004	 mov         r1, #4
  000d0	eb000000	 bl          SetDevicePowerState

; 321  : 
; 322  :                 pDevice->powerState = D4;

  000d4	e5854034	 str         r4, [r5, #0x34]
  000d8		 |$LN1@SetSPIPowe|

; 323  :                 }
; 324  :             }
; 325  :         }
; 326  :     
; 327  : 	ReleaseMutex(pDevice->hControllerMutex);

  000d8	e595001c	 ldr         r0, [r5, #0x1C]
  000dc	eb000000	 bl          ReleaseMutex

; 328  :     return TRUE;

  000e0	e3a00001	 mov         r0, #1

; 329  : }

  000e4	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000e8	e12fff1e	 bx          lr
  000ec		 |$M45883|

			 ENDP  ; |SetSPIPower|

	EXPORT	|SPI_Deinit|
	EXPORT	|??_C@_1CO@OIJMHFHD@?$AA?9?$AAS?$AAP?$AAI?$AA_?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CM@HJBPCML@?$AA?$CL?$AAS?$AAP?$AAI?$AA_?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|LocalFree|
	IMPORT	|DeleteCriticalSection|
	IMPORT	|KernelIoControl|
	IMPORT	|InterruptDisable|
	IMPORT	|MmUnmapIoSpace|
	IMPORT	|CloseBusAccessHandle|
	IMPORT	|CloseHandle|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T45900| DCD	|$LN16@SPI_Deinit|
	DCD	0x40005202

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CO@OIJMHFHD@?$AA?9?$AAS?$AAP?$AAI?$AA_?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "-"
	DCB	0x0, "S", 0x0, "P", 0x0, "I", 0x0, "_", 0x0, "D", 0x0, "e"
	DCB	0x0, "i", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, "(", 0x0, "r"
	DCB	0x0, "c", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "%", 0x0, "d"
	DCB	0x0, ")", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CM@HJBPCML@?$AA?$CL?$AAS?$AAP?$AAI?$AA_?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "+"
	DCB	0x0, "S", 0x0, "P", 0x0, "I", 0x0, "_", 0x0, "D", 0x0, "e"
	DCB	0x0, "i", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, "(", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "0", 0x0, "8", 0x0, "x", 0x0, ")"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\spi\spi.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_Deinit| PROC

; 543  : {

  00000		 |$LN16@SPI_Deinit|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M45897|
  00008	e1a04000	 mov         r4, r0

; 544  :     BOOL rc = FALSE;
; 545  :     SPI_DEVICE *pDevice = (SPI_DEVICE*)context;
; 546  : 
; 547  :     //DEBUGMSG(ZONE_FUNCTION, (L"+SPI_Deinit(0x%08x)\r\n", context));
; 548  :     RETAILMSG(1, (L"+SPI_Deinit(0x%08x)\r\n", context));

  0000c	e59f0130	 ldr         r0, [pc, #0x130]
  00010	e1a01004	 mov         r1, r4
  00014	e3a05000	 mov         r5, #0
  00018	eb000000	 bl          NKDbgPrintfW

; 549  : 
; 550  :     // Check if we get correct context
; 551  :     if (pDevice == NULL || pDevice->cookie != SPI_DEVICE_COOKIE) {

  0001c	e3540000	 cmp         r4, #0
  00020	0a00003d	 beq         |$cleanUp$44709|
  00024	e5942000	 ldr         r2, [r4]
  00028	e59f3110	 ldr         r3, [pc, #0x110]
  0002c	e1520003	 cmp         r2, r3
  00030	1a000039	 bne         |$cleanUp$44709|

; 552  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_Deinit: "
; 553  :             L"Incorrect context paramer\r\n"
; 554  :         ));
; 555  :         goto cleanUp;
; 556  :     }
; 557  : 
; 558  :     // Check for open instances
; 559  :     if (pDevice->instances > 0) {

  00034	e5943010	 ldr         r3, [r4, #0x10]
  00038	e3530000	 cmp         r3, #0
  0003c	ca000036	 bgt         |$cleanUp$44709|

; 560  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_Deinit: "
; 561  :             L"Deinit with active instance (%d instances active)\r\n",
; 562  :             pDevice->instances
; 563  :         ));
; 564  :         goto cleanUp;
; 565  :     }
; 566  : 
; 567  :     // stop interrupt thread
; 568  :     if (pDevice->hTimerThread != NULL)

  00040	e5943274	 ldr         r3, [r4, #0x274]
  00044	e3a05000	 mov         r5, #0
  00048	e3530000	 cmp         r3, #0
  0004c	0a00000a	 beq         |$LN6@SPI_Deinit|

; 569  :         {
; 570  :         pDevice->bExitThread = TRUE;
; 571  :         SetEvent(pDevice->hTimerEvent);

  00050	e5940278	 ldr         r0, [r4, #0x278]
  00054	e3a03001	 mov         r3, #1
  00058	e3a01003	 mov         r1, #3
  0005c	e5843280	 str         r3, [r4, #0x280]
  00060	eb000000	 bl          EventModify

; 572  :         WaitForSingleObject(pDevice->hTimerThread, INFINITE);

  00064	e5940274	 ldr         r0, [r4, #0x274]
  00068	e3e01000	 mvn         r1, #0
  0006c	eb000000	 bl          WaitForSingleObject

; 573  :         CloseHandle(pDevice->hTimerThread);

  00070	e5940274	 ldr         r0, [r4, #0x274]
  00074	eb000000	 bl          CloseHandle

; 574  :         pDevice->hTimerThread = NULL;

  00078	e5845274	 str         r5, [r4, #0x274]
  0007c		 |$LN6@SPI_Deinit|

; 575  :         }
; 576  : 
; 577  :     // Set hardware to D4 and close parent bus driver
; 578  :     if (pDevice->hParentBus!= NULL) 

  0007c	e5943014	 ldr         r3, [r4, #0x14]
  00080	e3530000	 cmp         r3, #0
  00084	0a000004	 beq         |$LN5@SPI_Deinit|

; 579  :     {
; 580  :         SetSPIPower(pDevice,  D4);

  00088	e3a01004	 mov         r1, #4
  0008c	e1a00004	 mov         r0, r4
  00090	eb000000	 bl          SetSPIPower

; 581  :         CloseBusAccessHandle(pDevice->hParentBus);

  00094	e5940014	 ldr         r0, [r4, #0x14]
  00098	eb000000	 bl          CloseBusAccessHandle
  0009c		 |$LN5@SPI_Deinit|

; 582  :     }
; 583  : 
; 584  :     // Unmap SPI controller registers
; 585  :     if (pDevice->pSPIRegs != NULL)

  0009c	e5943018	 ldr         r3, [r4, #0x18]
  000a0	e3530000	 cmp         r3, #0

; 586  :     {
; 587  :         MmUnmapIoSpace((VOID*)pDevice->pSPIRegs, sizeof(OMAP_MCSPI_REGS));

  000a4	13a0107c	 movne       r1, #0x7C
  000a8	11a00003	 movne       r0, r3
  000ac	1b000000	 blne        MmUnmapIoSpace

; 588  :     }
; 589  : 
; 590  :     // Release SPI controller interrupt
; 591  :     if (pDevice->sysIntr != 0) 

  000b0	e5943020	 ldr         r3, [r4, #0x20]
  000b4	e3530000	 cmp         r3, #0
  000b8	0a000008	 beq         |$LN3@SPI_Deinit|

; 592  : 	{
; 593  :         InterruptDisable(pDevice->sysIntr);

  000bc	e1a00003	 mov         r0, r3
  000c0	eb000000	 bl          InterruptDisable

; 594  :         KernelIoControl(
; 595  :             IOCTL_HAL_RELEASE_SYSINTR, &pDevice->sysIntr,
; 596  :             sizeof(pDevice->sysIntr), NULL, 0, NULL
; 597  :         );

  000c4	e59f0070	 ldr         r0, [pc, #0x70]
  000c8	e3a03000	 mov         r3, #0
  000cc	e3a02004	 mov         r2, #4
  000d0	e2841020	 add         r1, r4, #0x20
  000d4	e58d5004	 str         r5, [sp, #4]
  000d8	e58d5000	 str         r5, [sp]
  000dc	eb000000	 bl          KernelIoControl
  000e0		 |$LN3@SPI_Deinit|

; 598  :     }
; 599  : 
; 600  :     // Close interrupt handler
; 601  :     if (pDevice->hIntrEvent != NULL) CloseHandle(pDevice->hIntrEvent);

  000e0	e5943024	 ldr         r3, [r4, #0x24]
  000e4	e3530000	 cmp         r3, #0
  000e8	11a00003	 movne       r0, r3
  000ec	1b000000	 blne        CloseHandle

; 602  : 
; 603  :     // release dvfs resources
; 604  :     if (pDevice->hDVFSAsyncEvent != NULL) CloseHandle(pDevice->hDVFSAsyncEvent);

  000f0	e5943050	 ldr         r3, [r4, #0x50]
  000f4	e3530000	 cmp         r3, #0
  000f8	11a00003	 movne       r0, r3
  000fc	1b000000	 blne        CloseHandle

; 605  : 
; 606  :     // Delete critical section
; 607  :     DeleteCriticalSection(&pDevice->csDVFS);

  00100	e2840f97	 add         r0, r4, #0x97, 30
  00104	eb000000	 bl          DeleteCriticalSection

; 608  : 	
; 609  : 	// Delete mutex
; 610  : 	CloseHandle(pDevice->hControllerMutex);

  00108	e594001c	 ldr         r0, [r4, #0x1C]
  0010c	eb000000	 bl          CloseHandle

; 611  : 
; 612  :     // Free device structure
; 613  :     LocalFree(pDevice);

  00110	e1a00004	 mov         r0, r4
  00114	eb000000	 bl          LocalFree

; 614  : 
; 615  :     // Done
; 616  :     rc = TRUE;

  00118	e3a05001	 mov         r5, #1
  0011c		 |$cleanUp$44709|

; 617  : 
; 618  : cleanUp:
; 619  :     RETAILMSG(1, (L"-SPI_Deinit(rc = %d)\r\n", rc));

  0011c	e59f0014	 ldr         r0, [pc, #0x14]
  00120	e1a01005	 mov         r1, r5
  00124	eb000000	 bl          NKDbgPrintfW

; 620  :     return rc;
; 621  : }

  00128	e1a00005	 mov         r0, r5
  0012c	e28dd008	 add         sp, sp, #8
  00130	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00134	e12fff1e	 bx          lr
  00138		 |$LN17@SPI_Deinit|
  00138		 |$LN18@SPI_Deinit|
  00138	00000000	 DCD         |??_C@_1CO@OIJMHFHD@?$AA?9?$AAS?$AAP?$AAI?$AA_?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  0013c		 |$LN19@SPI_Deinit|
  0013c	010100d8	 DCD         0x10100d8
  00140		 |$LN20@SPI_Deinit|
  00140	73706944	 DCD         0x73706944
  00144		 |$LN21@SPI_Deinit|
  00144	00000000	 DCD         |??_C@_1CM@HJBPCML@?$AA?$CL?$AAS?$AAP?$AAI?$AA_?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  00148		 |$M45898|

			 ENDP  ; |SPI_Deinit|

	EXPORT	|SPI_Open|
	EXPORT	|??_C@_1EG@CMDGJGNK@?$AA?$CL?$AAS?$AAP?$AAI?$AA_?$AAO?$AAp?$AAe?$AAn?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx@| [ DATA ] ; `string'
	IMPORT	|LocalAlloc|
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T45920| DCD	|$LN8@SPI_Open|
	DCD	0x40002201

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EG@CMDGJGNK@?$AA?$CL?$AAS?$AAP?$AAI?$AA_?$AAO?$AAp?$AAe?$AAn?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx@| DCB "+"
	DCB	0x0, "S", 0x0, "P", 0x0, "I", 0x0, "_", 0x0, "O", 0x0, "p"
	DCB	0x0, "e", 0x0, "n", 0x0, "(", 0x0, "0", 0x0, "x", 0x0, "%"
	DCB	0x0, "0", 0x0, "8", 0x0, "x", 0x0, ",", 0x0, " ", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "0", 0x0, "8", 0x0, "x", 0x0, ","
	DCB	0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%", 0x0, "0", 0x0, "8"
	DCB	0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_Open| PROC

; 630  : {

  00000		 |$LN8@SPI_Open|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45917|
  00004	e1a03002	 mov         r3, r2
  00008	e1a02001	 mov         r2, r1
  0000c	e1a05000	 mov         r5, r0

; 631  :     DWORD rc = (DWORD)NULL;
; 632  :     SPI_DEVICE *pDevice = (SPI_DEVICE*)context;
; 633  :     SPI_INSTANCE *pInstance = NULL;
; 634  : 
; 635  : 	UNREFERENCED_PARAMETER(accessCode);
; 636  : 	UNREFERENCED_PARAMETER(shareMode);
; 637  : 
; 638  :     RETAILMSG(1, (L"+SPI_Open(0x%08x, 0x%08x, 0x%08x\r\n", context, accessCode, shareMode));

  00010	e59f006c	 ldr         r0, [pc, #0x6C]
  00014	e1a01005	 mov         r1, r5
  00018	e3a06000	 mov         r6, #0
  0001c	eb000000	 bl          NKDbgPrintfW

; 639  : 
; 640  :     // Check if we get correct context
; 641  :     if (pDevice == NULL || pDevice->cookie != SPI_DEVICE_COOKIE) {

  00020	e3550000	 cmp         r5, #0
  00024	0a000011	 beq         |$cleanUp$44748|
  00028	e5952000	 ldr         r2, [r5]
  0002c	e59f304c	 ldr         r3, [pc, #0x4C]
  00030	e1520003	 cmp         r2, r3
  00034	1a00000d	 bne         |$cleanUp$44748|

; 642  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_Open: "
; 643  :             L"Incorrect context parameter\r\n"
; 644  :         ));
; 645  :         goto cleanUp;
; 646  :     }
; 647  : 
; 648  :     // Create device structure
; 649  :     pInstance = (SPI_INSTANCE*)LocalAlloc(LPTR, sizeof(SPI_INSTANCE));

  00038	e3a010c8	 mov         r1, #0xC8
  0003c	e3a00040	 mov         r0, #0x40
  00040	eb000000	 bl          LocalAlloc
  00044	e1b04000	 movs        r4, r0

; 650  :     if (pInstance == NULL) {

  00048	0a000008	 beq         |$cleanUp$44748|

; 651  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_Open: "
; 652  :             L"Failed allocate SPI instance structure\r\n"
; 653  :         ));
; 654  :         goto cleanUp;
; 655  :     }
; 656  : 	
; 657  :     memset(pInstance, 0, sizeof(SPI_INSTANCE));

  0004c	e3a020c8	 mov         r2, #0xC8
  00050	e3a01000	 mov         r1, #0
  00054	e1a00004	 mov         r0, r4
  00058	eb000000	 bl          memset

; 658  : 
; 659  :     // Set cookie
; 660  :     pInstance->cookie = SPI_INSTANCE_COOKIE;

  0005c	e59f3018	 ldr         r3, [pc, #0x18]

; 661  : 
; 662  :     // Save device reference
; 663  :     pInstance->pDevice = pDevice;
; 664  : 
; 665  :     // Increment number of open instances
; 666  :     InterlockedIncrement(&pDevice->instances);

  00060	e2850010	 add         r0, r5, #0x10
  00064	e8840028	 stmia       r4, {r3, r5}
  00068	eb000000	 bl          InterlockedIncrement

; 667  : 
; 668  :     // sanity check number of instances
; 669  :     ASSERT(pDevice->instances > 0);
; 670  : 
; 671  :     // Done...
; 672  :     rc = (DWORD)pInstance;

  0006c	e1a06004	 mov         r6, r4
  00070		 |$cleanUp$44748|

; 673  : 
; 674  : cleanUp:
; 675  :     //RETAILMSG(1, (L"-SPI_Open(rc = 0x%08x)\r\n", rc));
; 676  :     return rc;
; 677  : }

  00070	e1a00006	 mov         r0, r6
  00074	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00078	e12fff1e	 bx          lr
  0007c		 |$LN9@SPI_Open|
  0007c		 |$LN10@SPI_Open|
  0007c	73706949	 DCD         0x73706949
  00080		 |$LN11@SPI_Open|
  00080	73706944	 DCD         0x73706944
  00084		 |$LN12@SPI_Open|
  00084	00000000	 DCD         |??_C@_1EG@CMDGJGNK@?$AA?$CL?$AAS?$AAP?$AAI?$AA_?$AAO?$AAp?$AAe?$AAn?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx@|
  00088		 |$M45918|

			 ENDP  ; |SPI_Open|

	EXPORT	|SPI_Close|
	EXPORT	|??_C@_1CK@DADLMPLB@?$AA?$CL?$AAS?$AAP?$AAI?$AA_?$AAC?$AAl?$AAo?$AAs?$AAe?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|SpiDmaDeinit|

  00000			 AREA	 |.pdata|, PDATA
|$T45936| DCD	|$LN8@SPI_Close|
	DCD	0x40002a01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CK@DADLMPLB@?$AA?$CL?$AAS?$AAP?$AAI?$AA_?$AAC?$AAl?$AAo?$AAs?$AAe?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "+"
	DCB	0x0, "S", 0x0, "P", 0x0, "I", 0x0, "_", 0x0, "C", 0x0, "l"
	DCB	0x0, "o", 0x0, "s", 0x0, "e", 0x0, "(", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "x", 0x0, ")", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_Close| PROC

; 686  : {

  00000		 |$LN8@SPI_Close|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45933|
  00004	e1a04000	 mov         r4, r0

; 687  :     BOOL rc = FALSE;
; 688  :     SPI_DEVICE *pDevice;
; 689  :     SPI_INSTANCE *pInstance = (SPI_INSTANCE*)context;
; 690  : 
; 691  :     RETAILMSG(1, (L"+SPI_Close(0x%08x)\r\n", context));

  00008	e59f0094	 ldr         r0, [pc, #0x94]
  0000c	e1a01004	 mov         r1, r4
  00010	e3a05000	 mov         r5, #0
  00014	eb000000	 bl          NKDbgPrintfW

; 692  : 
; 693  :     // Check if we get correct context
; 694  :     if (pInstance == NULL || pInstance->cookie != SPI_INSTANCE_COOKIE) {

  00018	e3540000	 cmp         r4, #0
  0001c	0a00001c	 beq         |$cleanUp$44769|
  00020	e5942000	 ldr         r2, [r4]
  00024	e59f3074	 ldr         r3, [pc, #0x74]
  00028	e1520003	 cmp         r2, r3
  0002c	1a000018	 bne         |$cleanUp$44769|

; 695  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_Transfer: "
; 696  :             L"Incorrect context paramer\r\n"
; 697  :         ));
; 698  :         goto cleanUp;
; 699  :     }
; 700  : 
; 701  :     // Shutdown DMA channels
; 702  :     SpiDmaDeinit(pInstance);

  00030	e1a00004	 mov         r0, r4
  00034	eb000000	 bl          SpiDmaDeinit

; 703  : 
; 704  :     // Get device context
; 705  :     pDevice = pInstance->pDevice;

  00038	e5945004	 ldr         r5, [r4, #4]

; 706  : 
; 707  :     // sanity check number of instances
; 708  :     ASSERT(pDevice->instances > 0);
; 709  : 
; 710  :     // Decrement number of open instances
; 711  :     if (InterlockedDecrement(&pDevice->instances) == 0)

  0003c	e2850010	 add         r0, r5, #0x10
  00040	eb000000	 bl          InterlockedDecrement
  00044	e3500000	 cmp         r0, #0
  00048	1a00000e	 bne         |$LN1@SPI_Close|

; 712  :     {
; 713  :         // Get hardware
; 714  : 		WaitForSingleObject(pDevice->hControllerMutex, INFINITE);

  0004c	e595001c	 ldr         r0, [r5, #0x1C]
  00050	e3e01000	 mvn         r1, #0
  00054	eb000000	 bl          WaitForSingleObject

; 715  : 
; 716  :         // Set this driver to Active Mode
; 717  :         SetSPIPower(pDevice, D0);

  00058	e3a01000	 mov         r1, #0
  0005c	e1a00005	 mov         r0, r5
  00060	eb000000	 bl          SetSPIPower

; 718  : 
; 719  :         // If number of open instances is 0, reset the eSpiMode to unknown and 
; 720  :         // MCSPI_MODULCTRL to 0 so we can change it later.
; 721  :         pDevice->eSpiMode = UNKNOWN;
; 722  :         OUTREG32(&pDevice->pSPIRegs->MCSPI_MODULCTRL, 0);

  00064	e5953018	 ldr         r3, [r5, #0x18]
  00068	e3a02000	 mov         r2, #0
  0006c	e5852040	 str         r2, [r5, #0x40]

; 723  : 
; 724  :         // Set this driver to Suspend Mode
; 725  :         SetSPIPower(pDevice, D4);

  00070	e3a01004	 mov         r1, #4
  00074	e1a00005	 mov         r0, r5
  00078	e5832028	 str         r2, [r3, #0x28]
  0007c	eb000000	 bl          SetSPIPower

; 726  : 
; 727  :         // Release hardware
; 728  : 		ReleaseMutex(pDevice->hControllerMutex);

  00080	e595001c	 ldr         r0, [r5, #0x1C]
  00084	eb000000	 bl          ReleaseMutex
  00088		 |$LN1@SPI_Close|

; 729  :     }
; 730  : 
; 731  :     // Free instance structure
; 732  :     LocalFree(pInstance);

  00088	e1a00004	 mov         r0, r4
  0008c	eb000000	 bl          LocalFree

; 733  : 
; 734  :     // Done...
; 735  :     rc = TRUE;

  00090	e3a05001	 mov         r5, #1
  00094		 |$cleanUp$44769|

; 736  : 
; 737  : cleanUp:
; 738  :     //RETAILMSG(1, (L"-SPI_Close(rc = %d)\r\n", rc));
; 739  :     return rc;
; 740  : }

  00094	e1a00005	 mov         r0, r5
  00098	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$LN9@SPI_Close|
  000a0		 |$LN10@SPI_Close|
  000a0	73706949	 DCD         0x73706949
  000a4		 |$LN11@SPI_Close|
  000a4	00000000	 DCD         |??_C@_1CK@DADLMPLB@?$AA?$CL?$AAS?$AAP?$AAI?$AA_?$AAC?$AAl?$AAo?$AAs?$AAe?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  000a8		 |$M45934|

			 ENDP  ; |SPI_Close|

	EXPORT	|SPI_Configure|
	IMPORT	|SpiDmaInit|

  00000			 AREA	 |.pdata|, PDATA
|$T45954| DCD	|$LN24@SPI_Config|
	DCD	0x40004d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_Configure| PROC

; 749  : {

  00000		 |$LN24@SPI_Config|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M45951|
  00004	e1a07002	 mov         r7, r2
  00008	e1a06001	 mov         r6, r1
  0000c	e1b05000	 movs        r5, r0

; 750  :     BOOL rc = FALSE;

  00010	e3a08000	 mov         r8, #0

; 751  :     SPI_INSTANCE *pInstance = (SPI_INSTANCE*)context;
; 752  :     SPI_DEVICE *pDevice;
; 753  : 
; 754  :     //RETAILMSG(1, (L"SPI_Configure Addr = 0x%x  Config = 0x%x\r\n", address, config));
; 755  : 
; 756  :     // Check if we get correct context
; 757  :     if (pInstance == NULL || pInstance->cookie != SPI_INSTANCE_COOKIE) {

  00014	0a000042	 beq         |$cleanUp$44789|
  00018	e595e000	 ldr         lr, [r5]
  0001c	e59f310c	 ldr         r3, [pc, #0x10C]
  00020	e15e0003	 cmp         lr, r3
  00024	1a00003e	 bne         |$cleanUp$44789|

; 758  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_Configure: "
; 759  :             L"Incorrect context paramer\r\n"
; 760  :         ));
; 761  :         goto cleanUp;
; 762  :     }
; 763  : 
; 764  :     //  Check channel
; 765  :     if (address >= MCSPI_MAX_CHANNELS) {

  00028	e3560004	 cmp         r6, #4
  0002c	2a00003c	 bcs         |$cleanUp$44789|

; 766  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_Configure: "
; 767  :             L"Incorrect address paramer\r\n"
; 768  :         ));
; 769  :         goto cleanUp;
; 770  :     }
; 771  : 
; 772  :     // Get Device
; 773  :     pDevice = pInstance->pDevice;

  00030	e5954004	 ldr         r4, [r5, #4]

; 774  : 
; 775  :     if (address > 0)

  00034	e3560000	 cmp         r6, #0
  00038	0a000007	 beq         |$LN13@SPI_Config|

; 776  :     {
; 777  :         switch (pDevice->eSpiMode)

  0003c	e5943040	 ldr         r3, [r4, #0x40]
  00040	e3530000	 cmp         r3, #0
  00044	0a000002	 beq         |$LN11@SPI_Config|
  00048	e3530002	 cmp         r3, #2
  0004c	1a000002	 bne         |$LN13@SPI_Config|

; 778  :         {
; 779  :             case SLAVE:
; 780  :                 DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_Configure: "
; 781  :                     L"Incorrect address paramer for slave device\r\n"
; 782  :                 ));
; 783  :                 goto cleanUp;

  00050	ea000033	 b           |$cleanUp$44789|
  00054		 |$LN11@SPI_Config|

; 784  :                 break;
; 785  : 
; 786  :             case UNKNOWN:
; 787  :                 pDevice->eSpiMode = MASTER;

  00054	e3a03001	 mov         r3, #1
  00058	e5843040	 str         r3, [r4, #0x40]
  0005c		 |$LN13@SPI_Config|

; 788  :                 break;
; 789  : 
; 790  :             default:
; 791  :                 break;
; 792  :         }
; 793  : 
; 794  :     }
; 795  : 
; 796  :     // Set Address and config
; 797  :     pInstance->address = address;

  0005c	e5856008	 str         r6, [r5, #8]

; 798  :     pInstance->config  = config;

  00060	e585700c	 str         r7, [r5, #0xC]

; 799  : 
; 800  :     // Get hardware
; 801  : 	WaitForSingleObject(pDevice->hControllerMutex, INFINITE);

  00064	e594001c	 ldr         r0, [r4, #0x1C]
  00068	e3e01000	 mvn         r1, #0
  0006c	eb000000	 bl          WaitForSingleObject

; 802  : 
; 803  :     // Setting active instance which is needed for context restore
; 804  :     pDevice->pActiveInstance = (void*)pInstance;
; 805  : 
; 806  :     // Set this driver to Active Mode
; 807  :     SetSPIPower(pDevice, D0);

  00070	e3a01000	 mov         r1, #0
  00074	e1a00004	 mov         r0, r4
  00078	e5845288	 str         r5, [r4, #0x288]
  0007c	eb000000	 bl          SetSPIPower

; 808  :     
; 809  :     // Configure the channel
; 810  :     switch( address )

  00080	e3560000	 cmp         r6, #0
  00084	0a00000e	 beq         |$LN7@SPI_Config|
  00088	e3560001	 cmp         r6, #1
  0008c	0a000009	 beq         |$LN6@SPI_Config|
  00090	e3560002	 cmp         r6, #2
  00094	0a000004	 beq         |$LN5@SPI_Config|
  00098	e3560003	 cmp         r6, #3
  0009c	1a00000c	 bne         |$LN8@SPI_Config|

; 829  : 
; 830  :         case 3:
; 831  :             //  Channel 3 configuration
; 832  :             pInstance->pSPIChannelRegs = (OMAP_MCSPI_CHANNEL_REGS*)(&pDevice->pSPIRegs->MCSPI_CHCONF3);

  000a0	e5943018	 ldr         r3, [r4, #0x18]
  000a4	e2833068	 add         r3, r3, #0x68

; 833  :             OUTREG32(&pInstance->pSPIChannelRegs->MCSPI_CHCONF, config);
; 834  :             break;

  000a8	ea000007	 b           |$LN21@SPI_Config|
  000ac		 |$LN5@SPI_Config|

; 823  : 
; 824  :         case 2:
; 825  :             //  Channel 2 configuration
; 826  :             pInstance->pSPIChannelRegs = (OMAP_MCSPI_CHANNEL_REGS*)(&pDevice->pSPIRegs->MCSPI_CHCONF2);

  000ac	e5943018	 ldr         r3, [r4, #0x18]
  000b0	e2833054	 add         r3, r3, #0x54

; 827  :             OUTREG32(&pInstance->pSPIChannelRegs->MCSPI_CHCONF, config);
; 828  :             break;

  000b4	ea000004	 b           |$LN21@SPI_Config|
  000b8		 |$LN6@SPI_Config|

; 816  :             break;
; 817  : 
; 818  :         case 1:
; 819  :             //  Channel 1 configuration
; 820  :             pInstance->pSPIChannelRegs = (OMAP_MCSPI_CHANNEL_REGS*)(&pDevice->pSPIRegs->MCSPI_CHCONF1);

  000b8	e5943018	 ldr         r3, [r4, #0x18]
  000bc	e2833040	 add         r3, r3, #0x40

; 821  :             OUTREG32(&pInstance->pSPIChannelRegs->MCSPI_CHCONF, config);
; 822  :             break;

  000c0	ea000001	 b           |$LN21@SPI_Config|
  000c4		 |$LN7@SPI_Config|

; 811  :     {
; 812  :         case 0:
; 813  :             //  Channel 0 configuration
; 814  :             pInstance->pSPIChannelRegs = (OMAP_MCSPI_CHANNEL_REGS*)(&pDevice->pSPIRegs->MCSPI_CHCONF0);

  000c4	e5943018	 ldr         r3, [r4, #0x18]
  000c8	e283302c	 add         r3, r3, #0x2C
  000cc		 |$LN21@SPI_Config|
  000cc	e5853010	 str         r3, [r5, #0x10]

; 815  :             OUTREG32(&pInstance->pSPIChannelRegs->MCSPI_CHCONF, config);

  000d0	e5837000	 str         r7, [r3]
  000d4		 |$LN8@SPI_Config|

; 835  : 
; 836  :         default:
; 837  :             break;
; 838  :     }
; 839  : 
; 840  :     //  Clear out current DMA configuration
; 841  :     SpiDmaDeinit(pInstance);

  000d4	e1a00005	 mov         r0, r5
  000d8	eb000000	 bl          SpiDmaDeinit

; 842  : 
; 843  :     //  Configure DMA if needed
; 844  :     if( config & (MCSPI_CHCONF_DMAR_ENABLE|MCSPI_CHCONF_DMAW_ENABLE) )

  000dc	e3170903	 tst         r7, #3, 18
  000e0	0a000009	 beq         |$LN1@SPI_Config|

; 845  :     {
; 846  :         if( SpiDmaInit(pInstance) == FALSE ) 

  000e4	e1a00005	 mov         r0, r5
  000e8	eb000000	 bl          SpiDmaInit
  000ec	e3500000	 cmp         r0, #0
  000f0	1a000005	 bne         |$LN1@SPI_Config|

; 847  :         {
; 848  :             DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_Configure: "
; 849  :                 L"DMA initialization failed\r\n"
; 850  :             ));
; 851  : 
; 852  :             // Set this driver to Suspend Mode
; 853  :             SetSPIPower(pDevice, D4);

  000f4	e3a01004	 mov         r1, #4
  000f8	e1a00004	 mov         r0, r4
  000fc	eb000000	 bl          SetSPIPower

; 854  : 
; 855  :             // Release hardware
; 856  : 			ReleaseMutex(pDevice->hControllerMutex);

  00100	e594001c	 ldr         r0, [r4, #0x1C]
  00104	eb000000	 bl          ReleaseMutex

; 857  :             goto cleanUp;

  00108	ea000005	 b           |$cleanUp$44789|
  0010c		 |$LN1@SPI_Config|

; 858  :         }
; 859  :     }
; 860  : 
; 861  :     // Set this driver to Suspend Mode
; 862  :     SetSPIPower(pDevice, D4);

  0010c	e3a01004	 mov         r1, #4
  00110	e1a00004	 mov         r0, r4
  00114	eb000000	 bl          SetSPIPower

; 863  :     
; 864  :     // Release hardware
; 865  : 	ReleaseMutex(pDevice->hControllerMutex);

  00118	e594001c	 ldr         r0, [r4, #0x1C]
  0011c	eb000000	 bl          ReleaseMutex

; 866  : 
; 867  :     // Success
; 868  :     rc = TRUE;

  00120	e3a08001	 mov         r8, #1
  00124		 |$cleanUp$44789|

; 869  : 
; 870  : cleanUp:    
; 871  :     return rc;
; 872  : }

  00124	e1a00008	 mov         r0, r8
  00128	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0012c	e12fff1e	 bx          lr
  00130		 |$LN25@SPI_Config|
  00130		 |$LN26@SPI_Config|
  00130	73706949	 DCD         0x73706949
  00134		 |$M45952|

			 ENDP  ; |SPI_Configure|

	EXPORT	|SPI_SetSlaveMode|

  00000			 AREA	 |.pdata|, PDATA
|$T45968| DCD	|$LN9@SPI_SetSla|
	DCD	0x40002101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_SetSlaveMode| PROC

; 882  : {

  00000		 |$LN9@SPI_SetSla|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45965|
  00004	e1b04000	 movs        r4, r0

; 883  :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 884  :     SPI_INSTANCE *pInstance = (SPI_INSTANCE*)context;
; 885  :     SPI_DEVICE *pDevice;
; 886  : 
; 887  :     DEBUGMSG(ZONE_FUNCTION, (L"+SSPI_SetSlaveMode.\r\n"));
; 888  : 
; 889  :     // Check if we get correct context
; 890  :     if (pInstance == NULL || pInstance->cookie != SPI_INSTANCE_COOKIE) {

  0000c	0a000019	 beq         |$cleanUp$44838|
  00010	e5942000	 ldr         r2, [r4]
  00014	e59f3064	 ldr         r3, [pc, #0x64]
  00018	e1520003	 cmp         r2, r3
  0001c	1a000015	 bne         |$cleanUp$44838|

; 891  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_SetSlaveMode: "
; 892  :             L"Incorrect context paramer\r\n"
; 893  :         ));
; 894  :         goto cleanUp;
; 895  :     }
; 896  : 
; 897  :     // Get Device
; 898  :     pDevice = pInstance->pDevice;

  00020	e5945004	 ldr         r5, [r4, #4]

; 899  : 
; 900  :     // once we set eSpiMode to MASTER(someone configured channel 1 to N), we can't 
; 901  :     // change it back
; 902  :     if (pDevice->eSpiMode == MASTER)

  00024	e5953040	 ldr         r3, [r5, #0x40]
  00028	e3530001	 cmp         r3, #1
  0002c	0a000011	 beq         |$cleanUp$44838|

; 903  :     {
; 904  :         goto cleanUp;
; 905  :     }
; 906  :    
; 907  :     if (pDevice->eSpiMode == UNKNOWN)

  00030	e3530000	 cmp         r3, #0
  00034	1a00000e	 bne         |$LN1@SPI_SetSla|

; 908  :     {
; 909  :         // Get hardware
; 910  : 		WaitForSingleObject(pDevice->hControllerMutex, INFINITE);

  00038	e595001c	 ldr         r0, [r5, #0x1C]
  0003c	e3e01000	 mvn         r1, #0
  00040	eb000000	 bl          WaitForSingleObject

; 911  : 
; 912  :         // Setting active instance which is needed for context restore
; 913  :         pDevice->pActiveInstance = (void*)pInstance;
; 914  : 
; 915  : 
; 916  :         // Set this driver to Active Mode
; 917  :         SetSPIPower(pDevice, D0);

  00044	e3a01000	 mov         r1, #0
  00048	e1a00005	 mov         r0, r5
  0004c	e5854288	 str         r4, [r5, #0x288]
  00050	eb000000	 bl          SetSPIPower

; 918  : 
; 919  :         OUTREG32(&pDevice->pSPIRegs->MCSPI_MODULCTRL, MCSPI_MS_BIT);

  00054	e5953018	 ldr         r3, [r5, #0x18]
  00058	e3a02004	 mov         r2, #4

; 920  : 
; 921  :         // Set this driver to Suspend Mode
; 922  :         SetSPIPower(pDevice, D4);

  0005c	e3a01004	 mov         r1, #4
  00060	e1a00005	 mov         r0, r5
  00064	e5832028	 str         r2, [r3, #0x28]
  00068	eb000000	 bl          SetSPIPower

; 923  : 
; 924  :         // Release hardware
; 925  : 		ReleaseMutex(pDevice->hControllerMutex);

  0006c	e595001c	 ldr         r0, [r5, #0x1C]
  00070	eb000000	 bl          ReleaseMutex
  00074		 |$LN1@SPI_SetSla|

; 926  :     }
; 927  : 
; 928  :     // Success
; 929  :     rc = TRUE;

  00074	e3a00001	 mov         r0, #1
  00078		 |$cleanUp$44838|

; 930  : 
; 931  : cleanUp:
; 932  :     return rc;
; 933  : }

  00078	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$LN10@SPI_SetSla|
  00080		 |$LN11@SPI_SetSla|
  00080	73706949	 DCD         0x73706949
  00084		 |$M45966|

			 ENDP  ; |SPI_SetSlaveMode|

	EXPORT	|SPI_DmaRead|
	IMPORT	|DmaInterruptDone|
	IMPORT	|memcpy|
	IMPORT	|__rt_udiv|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\inc\omap_sdma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T46013| DCD	|$LN27@SPI_DmaRea|
	DCD	0x40006302
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\spi\spi.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_DmaRead| PROC

; 1067 : {

  00000		 |$LN27@SPI_DmaRea|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M46010|
  00008	e1a05002	 mov         r5, r2
  0000c	e58d1000	 str         r1, [sp]
  00010	e1a04000	 mov         r4, r0

; 1068 :     SPI_INSTANCE *pInstance = (SPI_INSTANCE*)context;
; 1069 :     SPI_DEVICE *pDevice;
; 1070 :     OMAP_MCSPI_CHANNEL_REGS *pSPIChannelRegs;
; 1071 :     UCHAR* pData = (UCHAR*)pBuffer;
; 1072 :     DWORD dwWordLen;
; 1073 :     DWORD dwWordSize;
; 1074 :     DWORD dwCount = 0;
; 1075 :     DWORD dwDmaSize;
; 1076 :     DWORD dwDmaStatus;
; 1077 : 
; 1078 :     //RETAILMSG(1, (L"+SPI_DmaRead(0x%08x, 0x%08x, 0x%08x)\r\n", context, pBuffer, size));
; 1079 : 
; 1080 :     // We don't need to check instance since it's already checked by caller    
; 1081 :     ASSERT(pInstance->cookie == SPI_INSTANCE_COOKIE);
; 1082 : 
; 1083 :     // Get pointers to registers
; 1084 :     pDevice = pInstance->pDevice;
; 1085 :     pSPIChannelRegs = pInstance->pSPIChannelRegs;
; 1086 : 
; 1087 : 
; 1088 :     // Get the word length of the data
; 1089 :     dwWordLen = MCSPI_CHCONF_GET_WL(pInstance->config);

  00014	e594300c	 ldr         r3, [r4, #0xC]
  00018	e5946004	 ldr         r6, [r4, #4]
  0001c	e5948010	 ldr         r8, [r4, #0x10]
  00020	e1a03a03	 mov         r3, r3, lsl #20
  00024	e1a03da3	 mov         r3, r3, lsr #27
  00028	e2833001	 add         r3, r3, #1

; 1090 : 
; 1091 :     //  Ensure that only SPI words elements are DMA'd
; 1092 :     //  Adjust the DMAsize
; 1093 :     if( dwWordLen > 16 )

  0002c	e3530010	 cmp         r3, #0x10

; 1094 :     {
; 1095 :         size = (size/sizeof(UINT32)) * sizeof(UINT32);

  00030	81a03125	 movhi       r3, r5, lsr #2
  00034	81a05103	 movhi       r5, r3, lsl #2

; 1096 :         dwWordSize = sizeof(UINT32);

  00038	83a07004	 movhi       r7, #4
  0003c	8a000004	 bhi         |$LN6@SPI_DmaRea|

; 1097 :     }
; 1098 :     else if( dwWordLen > 8 )

  00040	e3530008	 cmp         r3, #8

; 1099 :     {
; 1100 :         size = (size/sizeof(UINT16)) * sizeof(UINT16);

  00044	81a030a5	 movhi       r3, r5, lsr #1

; 1101 :         dwWordSize = sizeof(UINT16);

  00048	83a07002	 movhi       r7, #2
  0004c	81a05083	 movhi       r5, r3, lsl #1

; 1102 :     }
; 1103 :     else
; 1104 :     {
; 1105 :         dwWordSize = sizeof(UINT8);

  00050	93a07001	 movls       r7, #1
  00054		 |$LN6@SPI_DmaRea|

; 1106 :     }
; 1107 : 
; 1108 :     //  Get the length of how much can be DMA'd
; 1109 :     dwDmaSize = (size < pInstance->pDevice->dwRxBufferSize) ? size : pInstance->pDevice->dwRxBufferSize;

  00054	e5961030	 ldr         r1, [r6, #0x30]

; 1110 :     dwDmaSize /= dwWordSize;

  00058	e1a00007	 mov         r0, r7
  0005c	e1550001	 cmp         r5, r1
  00060	31a01005	 movcc       r1, r5
  00064	eb000000	 bl          __rt_udiv
  00068	e1a0a000	 mov         r10, r0

; 1111 : 
; 1112 :     // Get hardware
; 1113 : 	WaitForSingleObject(pDevice->hControllerMutex, INFINITE);

  0006c	e596001c	 ldr         r0, [r6, #0x1C]
  00070	e3e01000	 mvn         r1, #0
  00074	eb000000	 bl          WaitForSingleObject

; 1114 : 
; 1115 :     // Set this driver to Active Mode
; 1116 :     SetSPIPower(pDevice, D0);

  00078	e3a01000	 mov         r1, #0
  0007c	e1a00006	 mov         r0, r6
  00080	eb000000	 bl          SetSPIPower

; 1117 :     
; 1118 :     // Enable the channel
; 1119 : 	if (!pInstance->exclusiveAccess)

  00084	e5943014	 ldr         r3, [r4, #0x14]

; 1120 :     	SETREG32(&pSPIChannelRegs->MCSPI_CHCTRL, MCSPI_CHCONT_EN);
; 1121 : 
; 1122 : 
; 1123 :     //  Write out all the data; loop if necessary
; 1124 :     for( dwCount = 0; dwCount < size; )

  00088	e3a09000	 mov         r9, #0
  0008c	e3530000	 cmp         r3, #0
  00090	05983008	 ldreq       r3, [r8, #8]
  00094	03833001	 orreq       r3, r3, #1
  00098	05883008	 streq       r3, [r8, #8]
  0009c	e3550000	 cmp         r5, #0
  000a0	0a00002b	 beq         |$cleanUp$44943|
  000a4	e1a0b80a	 mov         r11, r10, lsl #16
  000a8	e1a0b82b	 mov         r11, r11, lsr #16
  000ac	e3a02001	 mov         r2, #1
  000b0		 |$LL4@SPI_DmaRea|

; 1125 :     {
; 1126 :         // Set the DMA transfer size
; 1127 :         DmaSetElementAndFrameCount(&pInstance->rxDmaInfo, (UINT16) dwDmaSize, 1);

  000b0	e59430b4	 ldr         r3, [r4, #0xB4]

; 1128 :     
; 1129 :         DEBUGMSG(ZONE_DMA, (L" SPI_DmaRead: DMA Start (# elements, elementSize) = %d, %d\r\n", dwDmaSize, dwWordSize));
; 1130 : 
; 1131 : 
; 1132 :         // Start the DMA
; 1133 :         PreDmaActivation(pInstance);

  000b4	e1a00004	 mov         r0, r4
  000b8	e583b014	 str         r11, [r3, #0x14]
  000bc	e59430b4	 ldr         r3, [r4, #0xB4]
  000c0	e5832018	 str         r2, [r3, #0x18]
  000c4	eb000000	 bl          PreDmaActivation

; 1134 :         DmaStart(&pInstance->rxDmaInfo);

  000c8	e59420b4	 ldr         r2, [r4, #0xB4]
  000cc	e5923000	 ldr         r3, [r2]
  000d0	e3833080	 orr         r3, r3, #0x80
  000d4	e5823000	 str         r3, [r2]

; 1135 : 
; 1136 :         //  Wait for DMA done interrupt or timeout
; 1137 :         if( WaitForSingleObject(pInstance->hRxDmaIntEvent, pInstance->pDevice->timeout) != WAIT_OBJECT_0)

  000d8	e5943004	 ldr         r3, [r4, #4]
  000dc	e5940024	 ldr         r0, [r4, #0x24]
  000e0	e5931028	 ldr         r1, [r3, #0x28]
  000e4	eb000000	 bl          WaitForSingleObject
  000e8	e3500000	 cmp         r0, #0
  000ec	1a000012	 bne         |$LN23@SPI_DmaRea|

; 1147 :             goto cleanUp;
; 1148 :         }
; 1149 : 
; 1150 :         // Get and clear the status
; 1151 :         dwDmaStatus = DmaGetStatus(&pInstance->rxDmaInfo);

  000f0	e59420b4	 ldr         r2, [r4, #0xB4]
  000f4	e592300c	 ldr         r3, [r2, #0xC]

; 1152 :         DmaClearStatus(&pInstance->rxDmaInfo, dwDmaStatus);

  000f8	e582300c	 str         r3, [r2, #0xC]

; 1153 : 
; 1154 :         DEBUGMSG(ZONE_DMA, (L" SPI_DmaRead: DMA Status = %x\r\n", dwDmaStatus));
; 1155 : 
; 1156 :         // Stop the DMA
; 1157 :         DmaInterruptDone(pInstance->hRxDmaChannel);

  000fc	e594001c	 ldr         r0, [r4, #0x1C]
  00100	eb000000	 bl          DmaInterruptDone

; 1158 :         DmaStop(&pInstance->rxDmaInfo);

  00104	e28400a0	 add         r0, r4, #0xA0
  00108	eb000000	 bl          DmaStop

; 1159 :         PostDmaDeactivation(pInstance);

  0010c	e1a00004	 mov         r0, r4
  00110	eb000000	 bl          PostDmaDeactivation

; 1160 : 
; 1161 : 
; 1162 :         // Copy the data from the DMA buffer
; 1163 :         memcpy(&pData[dwCount], pInstance->pRxDmaBuffer, dwDmaSize*dwWordSize);

  00114	e59d3000	 ldr         r3, [sp]
  00118	e59410c0	 ldr         r1, [r4, #0xC0]
  0011c	e002079a	 mul         r2, r10, r7
  00120	e0890003	 add         r0, r9, r3
  00124	eb000000	 bl          memcpy

; 1164 : 
; 1165 :         //  Update amount transferred
; 1166 :         dwCount += dwDmaSize*dwWordSize;

  00128	e029979a	 mla         r9, r10, r7, r9
  0012c	e3a02001	 mov         r2, #1
  00130	e1590005	 cmp         r9, r5
  00134	3affffdd	 bcc         |$LL4@SPI_DmaRea|

; 1135 : 
; 1136 :         //  Wait for DMA done interrupt or timeout
; 1137 :         if( WaitForSingleObject(pInstance->hRxDmaIntEvent, pInstance->pDevice->timeout) != WAIT_OBJECT_0)

  00138	ea000005	 b           |$cleanUp$44943|
  0013c		 |$LN23@SPI_DmaRea|

; 1138 :         {
; 1139 :             DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_DmaRead: "
; 1140 :                 L"DMA interrupt timeout\r\n"
; 1141 :             ));
; 1142 : 
; 1143 :             //  Cleanup
; 1144 :             DmaStop(&pInstance->rxDmaInfo);

  0013c	e28400a0	 add         r0, r4, #0xA0
  00140	eb000000	 bl          DmaStop

; 1145 :             DmaInterruptDone(pInstance->hRxDmaChannel);

  00144	e594001c	 ldr         r0, [r4, #0x1C]
  00148	eb000000	 bl          DmaInterruptDone

; 1146 :             PostDmaDeactivation(pInstance);

  0014c	e1a00004	 mov         r0, r4
  00150	eb000000	 bl          PostDmaDeactivation
  00154		 |$cleanUp$44943|

; 1167 :     }
; 1168 : 
; 1169 : cleanUp:
; 1170 :     // Disable the channel.
; 1171 : 	if (!pInstance->exclusiveAccess)

  00154	e5943014	 ldr         r3, [r4, #0x14]

; 1172 :     	CLRREG32(&pSPIChannelRegs->MCSPI_CHCTRL, MCSPI_CHCONT_EN);
; 1173 :     
; 1174 :     // Set this driver to Suspend Mode
; 1175 :     SetSPIPower(pDevice, D4);

  00158	e3a01004	 mov         r1, #4
  0015c	e1a00006	 mov         r0, r6
  00160	e3530000	 cmp         r3, #0
  00164	05983008	 ldreq       r3, [r8, #8]
  00168	03c33001	 biceq       r3, r3, #1
  0016c	05883008	 streq       r3, [r8, #8]
  00170	eb000000	 bl          SetSPIPower

; 1176 :     
; 1177 :     // Release hardware
; 1178 : 	ReleaseMutex(pDevice->hControllerMutex);

  00174	e596001c	 ldr         r0, [r6, #0x1C]
  00178	eb000000	 bl          ReleaseMutex

; 1179 : 
; 1180 : 
; 1181 :     //RETAILMSG(1, (L"-SPI_DmaRead(rc = %d)\r\n", dwCount));
; 1182 : 	return dwCount;
; 1183 : }

  0017c	e1a00009	 mov         r0, r9
  00180	e28dd004	 add         sp, sp, #4
  00184	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00188	e12fff1e	 bx          lr
  0018c		 |$M46011|

			 ENDP  ; |SPI_DmaRead|

	EXPORT	|SPI_DmaWrite|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\inc\omap_sdma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T46054| DCD	|$LN27@SPI_DmaWri|
	DCD	0x40006202
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\spi\spi.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_DmaWrite| PROC

; 1319 : {

  00000		 |$LN27@SPI_DmaWri|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M46051|
  00008	e1a05002	 mov         r5, r2
  0000c	e58d1000	 str         r1, [sp]
  00010	e1a04000	 mov         r4, r0

; 1320 :     SPI_INSTANCE *pInstance = (SPI_INSTANCE*)context;
; 1321 :     SPI_DEVICE *pDevice;
; 1322 :     OMAP_MCSPI_CHANNEL_REGS *pSPIChannelRegs;
; 1323 :     UCHAR* pData = (UCHAR*)pBuffer;
; 1324 :     DWORD dwWordLen;
; 1325 :     DWORD dwWordSize;
; 1326 :     DWORD dwCount = 0;
; 1327 :     DWORD dwDmaSize;
; 1328 :     DWORD dwDmaStatus;
; 1329 : 
; 1330 :     //RETAILMSG(1, (L"+SPI_DmaWrite(0x%08x, 0x%08x, 0x%08x)\r\n", context, pBuffer, size));
; 1331 : 
; 1332 :     // We don't need to check instance since it's already checked by caller    
; 1333 :     ASSERT(pInstance->cookie == SPI_INSTANCE_COOKIE);
; 1334 : 
; 1335 :     // Get pointers to registers
; 1336 :     pDevice = pInstance->pDevice;
; 1337 :     pSPIChannelRegs = pInstance->pSPIChannelRegs;
; 1338 : 
; 1339 : 
; 1340 :     // Get the word length of the data
; 1341 :     dwWordLen = MCSPI_CHCONF_GET_WL(pInstance->config);

  00014	e594300c	 ldr         r3, [r4, #0xC]
  00018	e5946004	 ldr         r6, [r4, #4]
  0001c	e5948010	 ldr         r8, [r4, #0x10]
  00020	e1a03a03	 mov         r3, r3, lsl #20
  00024	e1a03da3	 mov         r3, r3, lsr #27
  00028	e2833001	 add         r3, r3, #1

; 1342 : 
; 1343 :     //  Ensure that only SPI words elements are DMA'd
; 1344 :     //  Adjust the DMAsize
; 1345 :     if( dwWordLen > 16 )

  0002c	e3530010	 cmp         r3, #0x10

; 1346 :     {
; 1347 :         size = (size/sizeof(UINT32)) * sizeof(UINT32);

  00030	81a03125	 movhi       r3, r5, lsr #2
  00034	81a05103	 movhi       r5, r3, lsl #2

; 1348 :         dwWordSize = sizeof(UINT32);

  00038	83a07004	 movhi       r7, #4
  0003c	8a000004	 bhi         |$LN6@SPI_DmaWri|

; 1349 :     }
; 1350 :     else if( dwWordLen > 8 )

  00040	e3530008	 cmp         r3, #8

; 1351 :     {
; 1352 :         size = (size/sizeof(UINT16)) * sizeof(UINT16);

  00044	81a030a5	 movhi       r3, r5, lsr #1

; 1353 :         dwWordSize = sizeof(UINT16);

  00048	83a07002	 movhi       r7, #2
  0004c	81a05083	 movhi       r5, r3, lsl #1

; 1354 :     }
; 1355 :     else
; 1356 :     {
; 1357 :         dwWordSize = sizeof(UINT8);

  00050	93a07001	 movls       r7, #1
  00054		 |$LN6@SPI_DmaWri|

; 1358 :     }
; 1359 : 
; 1360 :     //  Get the length of how much can be DMA'd
; 1361 :     dwDmaSize = (size < pInstance->pDevice->dwTxBufferSize) ? size : pInstance->pDevice->dwTxBufferSize;

  00054	e596102c	 ldr         r1, [r6, #0x2C]

; 1362 :     dwDmaSize /= dwWordSize;

  00058	e1a00007	 mov         r0, r7
  0005c	e1550001	 cmp         r5, r1
  00060	31a01005	 movcc       r1, r5
  00064	eb000000	 bl          __rt_udiv
  00068	e1a0a000	 mov         r10, r0

; 1363 : 
; 1364 :     // Get hardware
; 1365 : 	WaitForSingleObject(pDevice->hControllerMutex, INFINITE);

  0006c	e596001c	 ldr         r0, [r6, #0x1C]
  00070	e3e01000	 mvn         r1, #0
  00074	eb000000	 bl          WaitForSingleObject

; 1366 : 
; 1367 :     // Set this driver to Active Mode
; 1368 :     SetSPIPower(pDevice, D0);

  00078	e3a01000	 mov         r1, #0
  0007c	e1a00006	 mov         r0, r6
  00080	eb000000	 bl          SetSPIPower

; 1369 :     
; 1370 :     // Enable the channel
; 1371 : 	if (!pInstance->exclusiveAccess)

  00084	e5943014	 ldr         r3, [r4, #0x14]

; 1372 :     	SETREG32(&pSPIChannelRegs->MCSPI_CHCTRL, MCSPI_CHCONT_EN);
; 1373 : 
; 1374 :     //  Write out all the data; loop if necessary
; 1375 :     for( dwCount = 0; dwCount < size; )

  00088	e3a09000	 mov         r9, #0
  0008c	e3530000	 cmp         r3, #0
  00090	05983008	 ldreq       r3, [r8, #8]
  00094	03833001	 orreq       r3, r3, #1
  00098	05883008	 streq       r3, [r8, #8]
  0009c	e3550000	 cmp         r5, #0
  000a0	0a00002a	 beq         |$cleanUp$45049|
  000a4	e1a0b80a	 mov         r11, r10, lsl #16
  000a8	e1a0b82b	 mov         r11, r11, lsr #16
  000ac		 |$LL4@SPI_DmaWri|

; 1376 :     {
; 1377 :         // Copy the data to the DMA buffer
; 1378 :         memcpy(pInstance->pTxDmaBuffer, &pData[dwCount], dwDmaSize*dwWordSize);

  000ac	e59d3000	 ldr         r3, [sp]
  000b0	e59400b8	 ldr         r0, [r4, #0xB8]
  000b4	e002079a	 mul         r2, r10, r7
  000b8	e0891003	 add         r1, r9, r3
  000bc	eb000000	 bl          memcpy

; 1379 : 
; 1380 :         // Set the DMA transfer size
; 1381 :         DmaSetElementAndFrameCount(&pInstance->txDmaInfo, (UINT16) dwDmaSize, 1);

  000c0	e594309c	 ldr         r3, [r4, #0x9C]

; 1382 :     
; 1383 :         DEBUGMSG(ZONE_DMA, (L" SPI_DmaWrite: DMA Start (# elements, elementSize) = %d, %d\r\n", dwDmaSize, dwWordSize));
; 1384 : 
; 1385 :         // Start the DMA
; 1386 :         PreDmaActivation(pInstance);

  000c4	e3a02001	 mov         r2, #1
  000c8	e1a00004	 mov         r0, r4
  000cc	e583b014	 str         r11, [r3, #0x14]
  000d0	e594309c	 ldr         r3, [r4, #0x9C]
  000d4	e5832018	 str         r2, [r3, #0x18]
  000d8	eb000000	 bl          PreDmaActivation

; 1387 :         DmaStart(&pInstance->txDmaInfo);

  000dc	e594209c	 ldr         r2, [r4, #0x9C]
  000e0	e5923000	 ldr         r3, [r2]
  000e4	e3833080	 orr         r3, r3, #0x80
  000e8	e5823000	 str         r3, [r2]

; 1388 : 
; 1389 :         //  Wait for DMA done interrupt or timeout
; 1390 :         if( WaitForSingleObject(pInstance->hTxDmaIntEvent, pInstance->pDevice->timeout) != WAIT_OBJECT_0)

  000ec	e5943004	 ldr         r3, [r4, #4]
  000f0	e5940020	 ldr         r0, [r4, #0x20]
  000f4	e5931028	 ldr         r1, [r3, #0x28]
  000f8	eb000000	 bl          WaitForSingleObject
  000fc	e3500000	 cmp         r0, #0
  00100	1a00000c	 bne         |$LN23@SPI_DmaWri|

; 1400 :             goto cleanUp;
; 1401 :         }
; 1402 : 
; 1403 :         // Get and clear the status
; 1404 :         dwDmaStatus = DmaGetStatus(&pInstance->txDmaInfo);

  00104	e594209c	 ldr         r2, [r4, #0x9C]
  00108	e592300c	 ldr         r3, [r2, #0xC]

; 1405 :         DmaClearStatus(&pInstance->txDmaInfo, dwDmaStatus);

  0010c	e582300c	 str         r3, [r2, #0xC]

; 1406 : 
; 1407 :         DEBUGMSG(ZONE_DMA, (L" SPI_DmaWrite: DMA Status = %x\r\n", dwDmaStatus));
; 1408 : 
; 1409 :         // Stop the DMA
; 1410 :         DmaInterruptDone(pInstance->hTxDmaChannel);

  00110	e5940018	 ldr         r0, [r4, #0x18]
  00114	eb000000	 bl          DmaInterruptDone

; 1411 :         DmaStop(&pInstance->txDmaInfo);

  00118	e2840088	 add         r0, r4, #0x88
  0011c	eb000000	 bl          DmaStop

; 1412 :         PostDmaDeactivation(pInstance);

  00120	e1a00004	 mov         r0, r4
  00124	eb000000	 bl          PostDmaDeactivation

; 1413 : 
; 1414 :         //  Update amount transferred
; 1415 :         dwCount += dwDmaSize*dwWordSize;

  00128	e029979a	 mla         r9, r10, r7, r9
  0012c	e1590005	 cmp         r9, r5
  00130	3affffdd	 bcc         |$LL4@SPI_DmaWri|

; 1388 : 
; 1389 :         //  Wait for DMA done interrupt or timeout
; 1390 :         if( WaitForSingleObject(pInstance->hTxDmaIntEvent, pInstance->pDevice->timeout) != WAIT_OBJECT_0)

  00134	ea000005	 b           |$cleanUp$45049|
  00138		 |$LN23@SPI_DmaWri|

; 1391 :         {
; 1392 :             DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_DmaWrite: "
; 1393 :                 L"DMA interrupt timeout, ABC\r\n"
; 1394 :             ));
; 1395 : 
; 1396 :             //  Cleanup
; 1397 :             DmaStop(&pInstance->txDmaInfo);

  00138	e2840088	 add         r0, r4, #0x88
  0013c	eb000000	 bl          DmaStop

; 1398 :             DmaInterruptDone(pInstance->hTxDmaChannel);

  00140	e5940018	 ldr         r0, [r4, #0x18]
  00144	eb000000	 bl          DmaInterruptDone

; 1399 :             PostDmaDeactivation(pInstance);

  00148	e1a00004	 mov         r0, r4
  0014c	eb000000	 bl          PostDmaDeactivation
  00150		 |$cleanUp$45049|

; 1416 :     }
; 1417 :     
; 1418 : cleanUp:
; 1419 :     // Disable the channel.
; 1420 : 	if (!pInstance->exclusiveAccess)

  00150	e5943014	 ldr         r3, [r4, #0x14]

; 1421 :     	CLRREG32(&pSPIChannelRegs->MCSPI_CHCTRL, MCSPI_CHCONT_EN);
; 1422 : 
; 1423 :     // Set this driver to Suspend Mode
; 1424 :     SetSPIPower(pDevice, D4);

  00154	e3a01004	 mov         r1, #4
  00158	e1a00006	 mov         r0, r6
  0015c	e3530000	 cmp         r3, #0
  00160	05983008	 ldreq       r3, [r8, #8]
  00164	03c33001	 biceq       r3, r3, #1
  00168	05883008	 streq       r3, [r8, #8]
  0016c	eb000000	 bl          SetSPIPower

; 1425 : 
; 1426 :     // Release hardware
; 1427 : 	ReleaseMutex(pDevice->hControllerMutex);

  00170	e596001c	 ldr         r0, [r6, #0x1C]
  00174	eb000000	 bl          ReleaseMutex

; 1428 : 
; 1429 :     //RETAILMSG(1, (L"-SPI_DmaWrite(rc = %d)\r\n", dwCount));
; 1430 :     return dwCount;
; 1431 : }

  00178	e1a00009	 mov         r0, r9
  0017c	e28dd004	 add         sp, sp, #4
  00180	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00184	e12fff1e	 bx          lr
  00188		 |$M46052|

			 ENDP  ; |SPI_DmaWrite|

	EXPORT	|SPI_AsyncWriteRead|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\inc\omap_sdma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T46110| DCD	|$LN31@SPI_AsyncW|
	DCD	0x40004d01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\spi\spi.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_AsyncWriteRead| PROC

; 1449 : {

  00000		 |$LN31@SPI_AsyncW|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M46107|
  00004	e1a0a002	 mov         r10, r2
  00008	e1a05001	 mov         r5, r1
  0000c	e1a06000	 mov         r6, r0

; 1450 :     SPI_INSTANCE *pInstance = (SPI_INSTANCE*)context;
; 1451 :     SPI_DEVICE *pDevice;
; 1452 :     OMAP_MCSPI_CHANNEL_REGS *pSPIChannelRegs;
; 1453 :     UCHAR* pOutData = (UCHAR*)pOutBuffer;
; 1454 :     DWORD dwWordLen;
; 1455 :     DWORD dwWordSize;
; 1456 :     DWORD dwDmaSize;
; 1457 : 
; 1458 :     //RETAILMSG(1, (L"+SPI_AsyncWriteRead(0x%08x, 0x%08x)\r\n", context, size));
; 1459 :   
; 1460 :     // We don't need to check instance since it's already checked by caller
; 1461 :     ASSERT(pInstance->cookie == SPI_INSTANCE_COOKIE);
; 1462 : 
; 1463 :     if ((SpiDmaTxEnabled(pInstance) == FALSE) || (SpiDmaRxEnabled(pInstance) == FALSE) ||
; 1464 :         (pInstance->pDevice->dwTxBufferSize < size) || (pInstance->pDevice->dwRxBufferSize < size))

  00010	e5963018	 ldr         r3, [r6, #0x18]
  00014	e3530000	 cmp         r3, #0
  00018	0a000041	 beq         |$LN5@SPI_AsyncW|
  0001c	e596301c	 ldr         r3, [r6, #0x1C]
  00020	e3530000	 cmp         r3, #0
  00024	0a00003e	 beq         |$LN5@SPI_AsyncW|
  00028	e5967004	 ldr         r7, [r6, #4]
  0002c	e597302c	 ldr         r3, [r7, #0x2C]
  00030	e1530005	 cmp         r3, r5
  00034	3a00003a	 bcc         |$LN5@SPI_AsyncW|
  00038	e5973030	 ldr         r3, [r7, #0x30]
  0003c	e1530005	 cmp         r3, r5
  00040	3a000037	 bcc         |$LN5@SPI_AsyncW|

; 1467 :     }
; 1468 : 
; 1469 :     // Get pointers to registers
; 1470 :     pDevice = pInstance->pDevice;
; 1471 :     pSPIChannelRegs = pInstance->pSPIChannelRegs;
; 1472 : 
; 1473 : 
; 1474 :     // Get the word length of the data
; 1475 :     dwWordLen = MCSPI_CHCONF_GET_WL(pInstance->config);

  00044	e596300c	 ldr         r3, [r6, #0xC]
  00048	e5969010	 ldr         r9, [r6, #0x10]
  0004c	e1a03a03	 mov         r3, r3, lsl #20
  00050	e1a03da3	 mov         r3, r3, lsr #27
  00054	e2833001	 add         r3, r3, #1

; 1476 : 
; 1477 :     //  Ensure that only SPI words elements are DMA'd
; 1478 :     //  Adjust the DMAsize
; 1479 :     if( dwWordLen > 16 )

  00058	e3530010	 cmp         r3, #0x10

; 1480 :     {
; 1481 :         size = (size/sizeof(UINT32)) * sizeof(UINT32);

  0005c	81a03125	 movhi       r3, r5, lsr #2
  00060	81a05103	 movhi       r5, r3, lsl #2

; 1482 :         dwWordSize = sizeof(UINT32);

  00064	83a08004	 movhi       r8, #4
  00068	8a000004	 bhi         |$LN1@SPI_AsyncW|

; 1483 :     }
; 1484 :     else if( dwWordLen > 8 )

  0006c	e3530008	 cmp         r3, #8

; 1485 :     {
; 1486 :         size = (size/sizeof(UINT16)) * sizeof(UINT16);

  00070	81a030a5	 movhi       r3, r5, lsr #1

; 1487 :         dwWordSize = sizeof(UINT16);

  00074	83a08002	 movhi       r8, #2
  00078	81a05083	 movhi       r5, r3, lsl #1

; 1488 :     }
; 1489 :     else
; 1490 :     {
; 1491 :         dwWordSize = sizeof(UINT8);

  0007c	93a08001	 movls       r8, #1
  00080		 |$LN1@SPI_AsyncW|

; 1492 :     }
; 1493 : 
; 1494 :     //  Get the length of how much can be DMA'd
; 1495 :     dwDmaSize = (size < pDevice->dwTxBufferSize) ? size : pDevice->dwTxBufferSize;

  00080	e597102c	 ldr         r1, [r7, #0x2C]

; 1496 :     dwDmaSize /= dwWordSize;

  00084	e1a00008	 mov         r0, r8
  00088	e1550001	 cmp         r5, r1
  0008c	31a01005	 movcc       r1, r5
  00090	eb000000	 bl          __rt_udiv
  00094	e1a04000	 mov         r4, r0

; 1497 : 
; 1498 :     // Get hardware
; 1499 : 	WaitForSingleObject(pDevice->hControllerMutex, INFINITE);

  00098	e597001c	 ldr         r0, [r7, #0x1C]
  0009c	e3e01000	 mvn         r1, #0
  000a0	eb000000	 bl          WaitForSingleObject

; 1500 : 
; 1501 :     // Set this driver to Active Mode
; 1502 :     SetSPIPower(pDevice, D0);

  000a4	e3a01000	 mov         r1, #0
  000a8	e1a00007	 mov         r0, r7
  000ac	eb000000	 bl          SetSPIPower

; 1503 : 
; 1504 :     // Enable the channel
; 1505 :     SETREG32(&pSPIChannelRegs->MCSPI_CHCTRL, MCSPI_CHCONT_EN);

  000b0	e5993008	 ldr         r3, [r9, #8]

; 1506 : 
; 1507 :    	// Setup transmit
; 1508 :     // Copy the data to the DMA buffer
; 1509 :     memcpy(pInstance->pTxDmaBuffer, pOutData, dwDmaSize*dwWordSize);

  000b4	e0020894	 mul         r2, r4, r8
  000b8	e3833001	 orr         r3, r3, #1
  000bc	e1a0100a	 mov         r1, r10
  000c0	e5893008	 str         r3, [r9, #8]
  000c4	e59600b8	 ldr         r0, [r6, #0xB8]
  000c8	eb000000	 bl          memcpy

; 1510 : 
; 1511 :     // Set the DMA transfer size
; 1512 :     DmaSetElementAndFrameCount(&pInstance->txDmaInfo, (UINT16) dwDmaSize, 1);

  000cc	e596309c	 ldr         r3, [r6, #0x9C]
  000d0	e1a02804	 mov         r2, r4, lsl #16
  000d4	e1a02822	 mov         r2, r2, lsr #16
  000d8	e5832014	 str         r2, [r3, #0x14]
  000dc	e596309c	 ldr         r3, [r6, #0x9C]
  000e0	e3a01001	 mov         r1, #1

; 1513 : 
; 1514 :     DEBUGMSG(ZONE_DMA, (L" SPI_DmaWrite: DMA Start (# elements, elementSize) = %d, %d\r\n", dwDmaSize, dwWordSize));
; 1515 : 
; 1516 : 	// Setup receive DMA
; 1517 :     DmaSetElementAndFrameCount(&pInstance->rxDmaInfo, (UINT16) dwDmaSize, 1);
; 1518 : 	
; 1519 :     // Start the DMA
; 1520 :     PreDmaActivation(pInstance);

  000e4	e1a00006	 mov         r0, r6
  000e8	e5831018	 str         r1, [r3, #0x18]
  000ec	e59630b4	 ldr         r3, [r6, #0xB4]
  000f0	e5832014	 str         r2, [r3, #0x14]
  000f4	e59630b4	 ldr         r3, [r6, #0xB4]
  000f8	e5831018	 str         r1, [r3, #0x18]
  000fc	eb000000	 bl          PreDmaActivation

; 1521 : 
; 1522 :     DmaStart(&pInstance->rxDmaInfo);

  00100	e59620b4	 ldr         r2, [r6, #0xB4]

; 1523 :     DmaStart(&pInstance->txDmaInfo);
; 1524 : 
; 1525 : UNREFERENCED_PARAMETER(pInBuffer);
; 1526 : 
; 1527 :     return size;

  00104	e5923000	 ldr         r3, [r2]
  00108	e3833080	 orr         r3, r3, #0x80
  0010c	e5823000	 str         r3, [r2]
  00110	e596209c	 ldr         r2, [r6, #0x9C]
  00114	e5923000	 ldr         r3, [r2]
  00118	e3833080	 orr         r3, r3, #0x80
  0011c	e5823000	 str         r3, [r2]
  00120	ea000000	 b           |$LN7@SPI_AsyncW|
  00124		 |$LN5@SPI_AsyncW|

; 1465 :     {
; 1466 :         return 0;

  00124	e3a05000	 mov         r5, #0
  00128		 |$LN7@SPI_AsyncW|

; 1528 : }

  00128	e1a00005	 mov         r0, r5
  0012c	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00130	e12fff1e	 bx          lr
  00134		 |$M46108|

			 ENDP  ; |SPI_AsyncWriteRead|

	EXPORT	|SPI_WaitForAsyncWriteReadComplete|
	EXPORT	|??_C@_1O@LGMIGBMA@?$AA?9?$AA?9?$AAT?$AAx?$AA?9?$AA?$DO?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1O@LLNGBBIH@?$AA?9?$AA?9?$AAR?$AAx?$AA?9?$AA?$DO?$AA?$AA@| [ DATA ] ; `string'
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\inc\omap_sdma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T46140| DCD	|$LN17@SPI_WaitFo|
	DCD	0x40004101

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1O@LGMIGBMA@?$AA?9?$AA?9?$AAT?$AAx?$AA?9?$AA?$DO?$AA?$AA@| DCB "-", 0x0
	DCB	"-", 0x0, "T", 0x0, "x", 0x0, "-", 0x0, ">", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1O@LLNGBBIH@?$AA?9?$AA?9?$AAR?$AAx?$AA?9?$AA?$DO?$AA?$AA@| DCB "-", 0x0
	DCB	"-", 0x0, "R", 0x0, "x", 0x0, "-", 0x0, ">", 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\spi\spi.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_WaitForAsyncWriteReadComplete| PROC

; 1543 : {

  00000		 |$LN17@SPI_WaitFo|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M46137|
  00004	e1a08002	 mov         r8, r2
  00008	e1a07001	 mov         r7, r1
  0000c	e1a04000	 mov         r4, r0

; 1544 :     SPI_INSTANCE *pInstance = (SPI_INSTANCE*)context;
; 1545 :     SPI_DEVICE *pDevice;
; 1546 :     OMAP_MCSPI_CHANNEL_REGS *pSPIChannelRegs;
; 1547 :     DWORD dwDmaStatus;
; 1548 : 
; 1549 :     //RETAILMSG(1, (L"+SPI_WaitForAsyncWriteReadComplete(0x%08x)\r\n", context));
; 1550 : 
; 1551 :     pDevice = pInstance->pDevice;

  00010	e5945004	 ldr         r5, [r4, #4]

; 1552 :     pSPIChannelRegs = pInstance->pSPIChannelRegs;
; 1553 : 
; 1554 :     //  Wait for DMA done interrupt or timeout
; 1555 :     if( WaitForSingleObject(pInstance->hRxDmaIntEvent, pDevice->timeout) != WAIT_OBJECT_0)

  00014	e5940024	 ldr         r0, [r4, #0x24]
  00018	e5946010	 ldr         r6, [r4, #0x10]
  0001c	e5951028	 ldr         r1, [r5, #0x28]
  00020	eb000000	 bl          WaitForSingleObject
  00024	e3500000	 cmp         r0, #0
  00028	0a000007	 beq         |$LN2@SPI_WaitFo|

; 1556 :     {
; 1557 :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_DmaRead: DMA interrupt timeout\r\n"));
; 1558 : 
; 1559 :         DUMP_DMA_REGS(pInstance->hRxDmaChannel, L"--Rx->");

  0002c	e59f10cc	 ldr         r1, [pc, #0xCC]
  00030	e594001c	 ldr         r0, [r4, #0x1C]
  00034	eb000000	 bl          DUMP_DMA_REGS

; 1560 : 
; 1561 :         //  Cleanup
; 1562 :         DmaStop(&pInstance->rxDmaInfo);

  00038	e28400a0	 add         r0, r4, #0xA0
  0003c	eb000000	 bl          DmaStop

; 1563 :         DmaInterruptDone(pInstance->hRxDmaChannel);

  00040	e594001c	 ldr         r0, [r4, #0x1C]
  00044	eb000000	 bl          DmaInterruptDone

; 1564 :         PostDmaDeactivation(pInstance);
; 1565 :         goto cleanUp;

  00048	ea00001e	 b           |$LN13@SPI_WaitFo|
  0004c		 |$LN2@SPI_WaitFo|

; 1566 :     }
; 1567 : 
; 1568 :     // Get and clear the status
; 1569 :     dwDmaStatus = DmaGetStatus(&pInstance->rxDmaInfo);

  0004c	e59420b4	 ldr         r2, [r4, #0xB4]
  00050	e592300c	 ldr         r3, [r2, #0xC]

; 1570 :     DmaClearStatus(&pInstance->rxDmaInfo, dwDmaStatus);

  00054	e582300c	 str         r3, [r2, #0xC]

; 1571 : 
; 1572 :     DEBUGMSG(ZONE_DMA, (L" SPI_DmaRead: DMA Status = %x\r\n", dwDmaStatus));
; 1573 : 
; 1574 :     // Stop the DMA
; 1575 :     DmaInterruptDone(pInstance->hRxDmaChannel);

  00058	e594001c	 ldr         r0, [r4, #0x1C]
  0005c	eb000000	 bl          DmaInterruptDone

; 1576 :     DmaStop(&pInstance->rxDmaInfo);

  00060	e28400a0	 add         r0, r4, #0xA0
  00064	eb000000	 bl          DmaStop

; 1577 : 
; 1578 :     //  Wait for DMA done interrupt or timeout
; 1579 :     if( WaitForSingleObject(pInstance->hTxDmaIntEvent, pDevice->timeout) != WAIT_OBJECT_0)

  00068	e5951028	 ldr         r1, [r5, #0x28]
  0006c	e5940020	 ldr         r0, [r4, #0x20]
  00070	eb000000	 bl          WaitForSingleObject
  00074	e3500000	 cmp         r0, #0
  00078	0a000007	 beq         |$LN1@SPI_WaitFo|

; 1580 :     {
; 1581 :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_DmaWrite: DMA interrupt timeout, ABC\r\n"));
; 1582 : 
; 1583 :         DUMP_DMA_REGS(pInstance->hTxDmaChannel, L"--Tx->");

  0007c	e59f1078	 ldr         r1, [pc, #0x78]
  00080	e5940018	 ldr         r0, [r4, #0x18]
  00084	eb000000	 bl          DUMP_DMA_REGS

; 1584 : 
; 1585 :         DmaStop(&pInstance->txDmaInfo);

  00088	e2840088	 add         r0, r4, #0x88
  0008c	eb000000	 bl          DmaStop

; 1586 :         DmaInterruptDone(pInstance->hTxDmaChannel);

  00090	e5940018	 ldr         r0, [r4, #0x18]
  00094	eb000000	 bl          DmaInterruptDone
  00098	ea00000a	 b           |$LN13@SPI_WaitFo|
  0009c		 |$LN1@SPI_WaitFo|

; 1587 :         PostDmaDeactivation(pInstance);
; 1588 :         goto cleanUp;
; 1589 :     }
; 1590 : 
; 1591 :     // Get and clear the status
; 1592 :     dwDmaStatus = DmaGetStatus(&pInstance->txDmaInfo);

  0009c	e594209c	 ldr         r2, [r4, #0x9C]
  000a0	e592300c	 ldr         r3, [r2, #0xC]

; 1593 :     DmaClearStatus(&pInstance->txDmaInfo, dwDmaStatus);

  000a4	e582300c	 str         r3, [r2, #0xC]

; 1594 : 
; 1595 :     DEBUGMSG(ZONE_DMA, (L" SPI_DmaWrite: DMA Status = %x\r\n", dwDmaStatus));
; 1596 : 
; 1597 :     // Stop the DMA
; 1598 :     DmaInterruptDone(pInstance->hTxDmaChannel);

  000a8	e5940018	 ldr         r0, [r4, #0x18]
  000ac	eb000000	 bl          DmaInterruptDone

; 1599 :     DmaStop(&pInstance->txDmaInfo);

  000b0	e2840088	 add         r0, r4, #0x88
  000b4	eb000000	 bl          DmaStop

; 1600 : 
; 1601 :     // Copy the data from the DMA buffer
; 1602 :     memcpy(pInBuffer, pInstance->pRxDmaBuffer, size);

  000b8	e59410c0	 ldr         r1, [r4, #0xC0]
  000bc	e1a02007	 mov         r2, r7
  000c0	e1a00008	 mov         r0, r8
  000c4	eb000000	 bl          memcpy
  000c8		 |$LN13@SPI_WaitFo|

; 1603 : 	
; 1604 :     PostDmaDeactivation(pInstance);

  000c8	e1a00004	 mov         r0, r4
  000cc	eb000000	 bl          PostDmaDeactivation

; 1605 : 
; 1606 : cleanUp:
; 1607 :     // Disable the channel.
; 1608 :     CLRREG32(&pSPIChannelRegs->MCSPI_CHCTRL, MCSPI_CHCONT_EN);

  000d0	e5963008	 ldr         r3, [r6, #8]

; 1609 : 
; 1610 :     // Set this driver to Suspend Mode
; 1611 :     SetSPIPower(pDevice, D4);

  000d4	e3a01004	 mov         r1, #4
  000d8	e1a00005	 mov         r0, r5
  000dc	e3c33001	 bic         r3, r3, #1
  000e0	e5863008	 str         r3, [r6, #8]
  000e4		 |$cleanUp$45108|
  000e4	eb000000	 bl          SetSPIPower

; 1612 : 
; 1613 :     // Release hardware
; 1614 : 	ReleaseMutex(pDevice->hControllerMutex);

  000e8	e595001c	 ldr         r0, [r5, #0x1C]
  000ec	eb000000	 bl          ReleaseMutex

; 1615 : 	
; 1616 :     DEBUGMSG(ZONE_FUNCTION, (L"-SPI_DmaWriteRead(rc = %d)\r\n", size));
; 1617 : 
; 1618 :     return size;
; 1619 : 	
; 1620 : }

  000f0	e1a00007	 mov         r0, r7
  000f4	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000f8	e12fff1e	 bx          lr
  000fc		 |$LN18@SPI_WaitFo|
  000fc		 |$LN19@SPI_WaitFo|
  000fc	00000000	 DCD         |??_C@_1O@LGMIGBMA@?$AA?9?$AA?9?$AAT?$AAx?$AA?9?$AA?$DO?$AA?$AA@|
  00100		 |$LN20@SPI_WaitFo|
  00100	00000000	 DCD         |??_C@_1O@LLNGBBIH@?$AA?9?$AA?9?$AAR?$AAx?$AA?9?$AA?$DO?$AA?$AA@|
  00104		 |$M46138|

			 ENDP  ; |SPI_WaitForAsyncWriteReadComplete|

	EXPORT	|SPI_DmaWriteRead|

  00000			 AREA	 |.pdata|, PDATA
|$T46157| DCD	|$LN6@SPI_DmaWri@2|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_DmaWriteRead| PROC

; 1638 : {

  00000		 |$LN6@SPI_DmaWri@2|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M46154|
  00004	e1a04003	 mov         r4, r3
  00008	e1a05001	 mov         r5, r1
  0000c	e1a06000	 mov         r6, r0

; 1639 :     DWORD   dwCount = 0;
; 1640 : 
; 1641 :     //RETAILMSG(1, (L"+SPI_DmaWriteRead(0x%08x, 0x%08x)\r\n", context, size));
; 1642 : 
; 1643 :     dwCount = SPI_AsyncWriteRead(context, size, pOutBuffer, pInBuffer);

  00010	eb000000	 bl          SPI_AsyncWriteRead
  00014	e3500000	 cmp         r0, #0

; 1644 :     if (dwCount != 0)
; 1645 :     {
; 1646 :         dwCount = SPI_WaitForAsyncWriteReadComplete(context, size, pInBuffer);

  00018	11a02004	 movne       r2, r4
  0001c	11a01005	 movne       r1, r5
  00020	11a00006	 movne       r0, r6
  00024	1b000000	 blne        SPI_WaitForAsyncWriteReadComplete

; 1647 :     }
; 1648 : 
; 1649 :     return dwCount;	
; 1650 : }

  00028	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$M46155|

			 ENDP  ; |SPI_DmaWriteRead|

	EXPORT	|SPI_WriteRead|
	IMPORT	|StallExecution|

  00000			 AREA	 |.pdata|, PDATA
|$T46207| DCD	|$LN50@SPI_WriteR|
	DCD	0x40006f02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_WriteRead| PROC

; 1668 : {

  00000		 |$LN50@SPI_WriteR|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M46204|
  00008	e1a0a003	 mov         r10, r3
  0000c	e1a0b002	 mov         r11, r2
  00010	e1a09001	 mov         r9, r1
  00014	e1b05000	 movs        r5, r0

; 1669 :     SPI_INSTANCE *pInstance = (SPI_INSTANCE*)context;
; 1670 :     SPI_DEVICE *pDevice;
; 1671 :     OMAP_MCSPI_CHANNEL_REGS *pSPIChannelRegs;
; 1672 :     UCHAR* pInData = (UCHAR*)pInBuffer;
; 1673 :     UCHAR* pOutData = (UCHAR*)pOutBuffer;
; 1674 :     DWORD dwWordLen;
; 1675 :     DWORD dwCount = 0;
; 1676 :     DWORD dwWait;
; 1677 : 
; 1678 :     //RETAILMSG(1, (L"+SPI_WriteRead(0x%08x, 0x%08x)\r\n", context, size));
; 1679 : 
; 1680 :     // Check if we get correct context
; 1681 :     if (pInstance == NULL || pInstance->cookie != SPI_INSTANCE_COOKIE) {

  00018	0a000061	 beq         |$LN22@SPI_WriteR|
  0001c	e5954000	 ldr         r4, [r5]
  00020	e59fe190	 ldr         lr, [pc, #0x190]
  00024	e154000e	 cmp         r4, lr
  00028	1a00005d	 bne         |$LN22@SPI_WriteR|

; 1686 :     }
; 1687 : 
; 1688 :     //  Call DMA function if DMA enabled
; 1689 :     if( SpiDmaTxEnabled(pInstance) && SpiDmaRxEnabled(pInstance))

  0002c	e595e018	 ldr         lr, [r5, #0x18]
  00030	e35e0000	 cmp         lr, #0
  00034	0a00000c	 beq         |$LN21@SPI_WriteR|
  00038	e595e01c	 ldr         lr, [r5, #0x1C]
  0003c	e35e0000	 cmp         lr, #0
  00040	0a000009	 beq         |$LN21@SPI_WriteR|

; 1690 :     {
; 1691 :         return SPI_DmaWriteRead(context, size, pOutBuffer, pInBuffer);

  00044	e1a00005	 mov         r0, r5
  00048	eb000000	 bl          SPI_AsyncWriteRead
  0004c	e1b06000	 movs        r6, r0
  00050	0a000054	 beq         |$LN24@SPI_WriteR|
  00054	e1a0200a	 mov         r2, r10
  00058	e1a01009	 mov         r1, r9
  0005c	e1a00005	 mov         r0, r5
  00060	eb000000	 bl          SPI_WaitForAsyncWriteReadComplete
  00064	e1a06000	 mov         r6, r0
  00068	ea00004e	 b           |$LN24@SPI_WriteR|
  0006c		 |$LN21@SPI_WriteR|

; 1692 :     }
; 1693 : 
; 1694 :     // Get pointers to registers
; 1695 :     pDevice = pInstance->pDevice;
; 1696 :     pSPIChannelRegs = pInstance->pSPIChannelRegs;
; 1697 : 
; 1698 : 
; 1699 :     // Get the word length of the data
; 1700 :     dwWordLen = MCSPI_CHCONF_GET_WL(pInstance->config);

  0006c	e595300c	 ldr         r3, [r5, #0xC]
  00070	e5957004	 ldr         r7, [r5, #4]

; 1701 :     
; 1702 :     // Get hardware
; 1703 : 	WaitForSingleObject(pDevice->hControllerMutex, INFINITE);

  00074	e5954010	 ldr         r4, [r5, #0x10]
  00078	e1a03a03	 mov         r3, r3, lsl #20
  0007c	e597001c	 ldr         r0, [r7, #0x1C]
  00080	e1a03da3	 mov         r3, r3, lsr #27
  00084	e2838001	 add         r8, r3, #1
  00088	e3e01000	 mvn         r1, #0
  0008c	e58d8000	 str         r8, [sp]
  00090	eb000000	 bl          WaitForSingleObject

; 1704 :     
; 1705 :     // Set this driver to Active Mode
; 1706 :     SetSPIPower(pDevice, D0);

  00094	e3a01000	 mov         r1, #0
  00098	e1a00007	 mov         r0, r7
  0009c	eb000000	 bl          SetSPIPower

; 1707 :     
; 1708 :     // Enable the channel
; 1709 : 	if (!pInstance->exclusiveAccess)

  000a0	e5953014	 ldr         r3, [r5, #0x14]

; 1710 :     	SETREG32(&pSPIChannelRegs->MCSPI_CHCTRL, MCSPI_CHCONT_EN);
; 1711 : 
; 1712 :     // Write out the data
; 1713 :     for( dwCount = 0; dwCount < size; )

  000a4	e3a06000	 mov         r6, #0
  000a8	e3530000	 cmp         r3, #0
  000ac	05943008	 ldreq       r3, [r4, #8]
  000b0	03833001	 orreq       r3, r3, #1
  000b4	05843008	 streq       r3, [r4, #8]
  000b8	e3590000	 cmp         r9, #0
  000bc	0a00002d	 beq         |$LN18@SPI_WriteR|
  000c0		 |$LL19@SPI_WriteR|

; 1714 :     {
; 1715 :         //  Write out data on byte/word/dword boundaries
; 1716 :         if( dwWordLen > 16 )

  000c0	e3580010	 cmp         r8, #0x10

; 1717 :         {
; 1718 :             OUTREG32(&pSPIChannelRegs->MCSPI_TX, *(UINT32*)(&pOutData[dwCount]));   

  000c4	8796300b	 ldrhi       r3, [r6, +r11]
  000c8	8a000002	 bhi         |$LN46@SPI_WriteR|

; 1719 :         }
; 1720 :         else if( dwWordLen > 8 )

  000cc	e3580008	 cmp         r8, #8

; 1721 :         {
; 1722 :             OUTREG32(&pSPIChannelRegs->MCSPI_TX, *(UINT16*)(&pOutData[dwCount]));   

  000d0	819630bb	 ldrhih      r3, [r6, +r11]

; 1723 :         }
; 1724 :         else
; 1725 :         {
; 1726 :             OUTREG32(&pSPIChannelRegs->MCSPI_TX, *(UINT8*)(&pOutData[dwCount]));   

  000d4	97d6300b	 ldrlsb      r3, [r6, +r11]
  000d8		 |$LN46@SPI_WriteR|
  000d8	e584300c	 str         r3, [r4, #0xC]

; 1727 :         }   
; 1728 : 
; 1729 :         //  Wait for TX register to empty out
; 1730 :         dwWait = pDevice->timeout;

  000dc	e5973028	 ldr         r3, [r7, #0x28]
  000e0	e1b08003	 movs        r8, r3

; 1731 :         while(dwWait && !(INREG32(&pSPIChannelRegs->MCSPI_CHSTATUS) & MCSPI_CHSTAT_TX_EMPTY))

  000e4	0a000023	 beq         |$LN18@SPI_WriteR|
  000e8		 |$LL13@SPI_WriteR|
  000e8	e5943004	 ldr         r3, [r4, #4]
  000ec	e3130002	 tst         r3, #2
  000f0	1a000003	 bne         |$LN12@SPI_WriteR|

; 1732 :         {
; 1733 :             StallExecution(1);

  000f4	e3a00001	 mov         r0, #1
  000f8	eb000000	 bl          StallExecution

; 1734 :             dwWait--;

  000fc	e2588001	 subs        r8, r8, #1
  00100	1afffff8	 bne         |$LL13@SPI_WriteR|
  00104		 |$LN12@SPI_WriteR|

; 1735 :         }
; 1736 : 
; 1737 :         //  Check if timeout occured
; 1738 :         if( dwWait == 0 )

  00104	e3580000	 cmp         r8, #0
  00108	0a00001a	 beq         |$LN18@SPI_WriteR|

; 1739 :         {
; 1740 :             DEBUGMSG(ZONE_ERROR, (L"SPI_WriteRead write timeout\r\n"));
; 1741 :             
; 1742 :             // Disable the channel.
; 1743 : 			if (!pInstance->exclusiveAccess)
; 1744 :         	    CLRREG32(&pSPIChannelRegs->MCSPI_CHCTRL, MCSPI_CHCONT_EN);
; 1745 : 
; 1746 :             // Set this driver to Suspend Mode
; 1747 :             SetSPIPower(pDevice, D4);
; 1748 : 
; 1749 :             // Release hardware
; 1750 : 			ReleaseMutex(pDevice->hControllerMutex);
; 1751 :             goto clean;
; 1752 :         }
; 1753 : 
; 1754 : 
; 1755 :         //  Wait for RX register to fill
; 1756 :         dwWait = pDevice->timeout;

  0010c	e5973028	 ldr         r3, [r7, #0x28]
  00110	e1b08003	 movs        r8, r3

; 1757 :         while(dwWait && !(INREG32(&pSPIChannelRegs->MCSPI_CHSTATUS) & MCSPI_CHSTAT_RX_FULL))

  00114	0a000017	 beq         |$LN18@SPI_WriteR|
  00118		 |$LL9@SPI_WriteR|
  00118	e5943004	 ldr         r3, [r4, #4]
  0011c	e3130001	 tst         r3, #1
  00120	1a000003	 bne         |$LN8@SPI_WriteR|

; 1758 :         {
; 1759 :             StallExecution(1);

  00124	e3a00001	 mov         r0, #1
  00128	eb000000	 bl          StallExecution

; 1760 :             dwWait--;

  0012c	e2588001	 subs        r8, r8, #1
  00130	1afffff8	 bne         |$LL9@SPI_WriteR|
  00134		 |$LN8@SPI_WriteR|

; 1761 :         }
; 1762 : 
; 1763 :         //  Check if timeout occured
; 1764 :         if( dwWait == 0 )

  00134	e3580000	 cmp         r8, #0
  00138	0a00000e	 beq         |$LN18@SPI_WriteR|

; 1765 :         {
; 1766 :             DEBUGMSG(ZONE_ERROR, (L"SPI_WriteRead read timeout\r\n"));
; 1767 :             
; 1768 :             // Disable the channel.
; 1769 : 			if (!pInstance->exclusiveAccess)
; 1770 :             	CLRREG32(&pSPIChannelRegs->MCSPI_CHCTRL, MCSPI_CHCONT_EN);
; 1771 : 
; 1772 :             // Set this driver to Suspend Mode
; 1773 :             SetSPIPower(pDevice, D4);
; 1774 : 
; 1775 :             // Release hardware
; 1776 : 			ReleaseMutex(pDevice->hControllerMutex);
; 1777 : 
; 1778 :             goto clean;
; 1779 :         }
; 1780 : 
; 1781 : 
; 1782 :         //  Read in data on byte/word/dword boundaries
; 1783 :         if( dwWordLen > 16 )

  0013c	e59d8000	 ldr         r8, [sp]
  00140	e3580010	 cmp         r8, #0x10

; 1784 :         {
; 1785 :             *(UINT32*)(&pInData[dwCount]) = INREG32(&pSPIChannelRegs->MCSPI_RX);   

  00144	85943010	 ldrhi       r3, [r4, #0x10]
  00148	8786300a	 strhi       r3, [r6, +r10]

; 1786 :             dwCount += sizeof(UINT32);

  0014c	82866004	 addhi       r6, r6, #4
  00150	8a000006	 bhi         |$LN2@SPI_WriteR|

; 1787 :         }
; 1788 :         else if( dwWordLen > 8 )

  00154	e3580008	 cmp         r8, #8

; 1789 :         {
; 1790 :             *(UINT16*)(&pInData[dwCount]) = (UINT16) INREG32(&pSPIChannelRegs->MCSPI_RX);   

  00158	85943010	 ldrhi       r3, [r4, #0x10]
  0015c	818630ba	 strhih      r3, [r6, +r10]

; 1791 :             dwCount += sizeof(UINT16);
; 1792 :         }
; 1793 :         else
; 1794 :         {
; 1795 :             *(UINT8*)(&pInData[dwCount]) = (UINT8) INREG32(&pSPIChannelRegs->MCSPI_RX);   

  00160	95943010	 ldrls       r3, [r4, #0x10]
  00164	82866002	 addhi       r6, r6, #2
  00168	97c6300a	 strlsb      r3, [r6, +r10]

; 1796 :             dwCount += sizeof(UINT8);

  0016c	92866001	 addls       r6, r6, #1
  00170		 |$LN2@SPI_WriteR|

; 1710 :     	SETREG32(&pSPIChannelRegs->MCSPI_CHCTRL, MCSPI_CHCONT_EN);
; 1711 : 
; 1712 :     // Write out the data
; 1713 :     for( dwCount = 0; dwCount < size; )

  00170	e1560009	 cmp         r6, r9
  00174	3affffd1	 bcc         |$LL19@SPI_WriteR|
  00178		 |$LN18@SPI_WriteR|

; 1797 :         }   
; 1798 :     }
; 1799 :     
; 1800 :     // Disable the channel.
; 1801 : 	if (!pInstance->exclusiveAccess)

  00178	e5953014	 ldr         r3, [r5, #0x14]

; 1802 :     	CLRREG32(&pSPIChannelRegs->MCSPI_CHCTRL, MCSPI_CHCONT_EN);
; 1803 : 
; 1804 : 
; 1805 :     // Set this driver to Suspend Mode
; 1806 :     SetSPIPower(pDevice, D4);

  0017c	e3a01004	 mov         r1, #4
  00180	e1a00007	 mov         r0, r7
  00184	e3530000	 cmp         r3, #0
  00188	05943008	 ldreq       r3, [r4, #8]
  0018c	03c33001	 biceq       r3, r3, #1
  00190	05843008	 streq       r3, [r4, #8]
  00194	eb000000	 bl          SetSPIPower

; 1807 : 
; 1808 :     // Release hardware
; 1809 : 	ReleaseMutex(pDevice->hControllerMutex);

  00198	e597001c	 ldr         r0, [r7, #0x1C]
  0019c	eb000000	 bl          ReleaseMutex
  001a0		 |$clean$45184|

; 1810 :     
; 1811 : clean:
; 1812 :     DEBUGMSG(ZONE_FUNCTION, (L"-SPI_WriteRead(rc = %d)\r\n", dwCount));
; 1813 :     return dwCount;

  001a0	ea000000	 b           |$LN24@SPI_WriteR|
  001a4		 |$LN22@SPI_WriteR|

; 1682 :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_Write: "
; 1683 :             L"Incorrect context paramer\r\n"
; 1684 :         ));
; 1685 :         return 0;

  001a4	e3a06000	 mov         r6, #0
  001a8		 |$LN24@SPI_WriteR|

; 1814 : }

  001a8	e1a00006	 mov         r0, r6
  001ac	e28dd004	 add         sp, sp, #4
  001b0	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001b4	e12fff1e	 bx          lr
  001b8		 |$LN51@SPI_WriteR|
  001b8		 |$LN52@SPI_WriteR|
  001b8	73706949	 DCD         0x73706949
  001bc		 |$M46205|

			 ENDP  ; |SPI_WriteRead|

	EXPORT	|ContextRestore|
	EXPORT	|??_C@_1IO@MLHBGINH@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DM@JFMOKFBI@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AAh?$AAo?$AAl?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAn?$AA?5?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?4?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|SpiDmaRestore|
	IMPORT	|Sleep|

  00000			 AREA	 |.pdata|, PDATA
|$T46228| DCD	|$LN23@ContextRes|
	DCD	0x40004f01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1IO@MLHBGINH@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| DCB "C"
	DCB	0x0, ":", 0x0, "\\", 0x0, "W", 0x0, "I", 0x0, "N", 0x0, "C"
	DCB	0x0, "E", 0x0, "6", 0x0, "0", 0x0, "0", 0x0, "\\", 0x0, "P"
	DCB	0x0, "L", 0x0, "A", 0x0, "T", 0x0, "F", 0x0, "O", 0x0, "R"
	DCB	0x0, "M", 0x0, "\\", 0x0, "C", 0x0, "O", 0x0, "M", 0x0, "M"
	DCB	0x0, "O", 0x0, "N", 0x0, "\\", 0x0, "S", 0x0, "R", 0x0, "C"
	DCB	0x0, "\\", 0x0, "S", 0x0, "O", 0x0, "C", 0x0, "\\", 0x0, "C"
	DCB	0x0, "O", 0x0, "M", 0x0, "M", 0x0, "O", 0x0, "N", 0x0, "_"
	DCB	0x0, "T", 0x0, "I", 0x0, "_", 0x0, "V", 0x0, "1", 0x0, "\\"
	DCB	0x0, "C", 0x0, "O", 0x0, "M", 0x0, "M", 0x0, "O", 0x0, "N"
	DCB	0x0, "_", 0x0, "T", 0x0, "I", 0x0, "\\", 0x0, "S", 0x0, "P"
	DCB	0x0, "I", 0x0, "\\", 0x0, ".", 0x0, "\\", 0x0, "s", 0x0, "p"
	DCB	0x0, "i", 0x0, ".", 0x0, "c", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "%", 0x0, "s", 0x0, " ", 0x0, "l", 0x0, "i", 0x0, "n"
	DCB	0x0, "e", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ":", 0x0, " "
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DM@JFMOKFBI@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AAh?$AAo?$AAl?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAn?$AA?5?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?4?$AA?6?$AA?$AA@| DCB "S"
	DCB	0x0, "P", 0x0, "I", 0x0, ":", 0x0, " ", 0x0, "E", 0x0, "R"
	DCB	0x0, "R", 0x0, "O", 0x0, "R", 0x0, " ", 0x0, "h", 0x0, "o"
	DCB	0x0, "l", 0x0, "d", 0x0, "i", 0x0, "n", 0x0, "g", 0x0, " "
	DCB	0x0, "i", 0x0, "n", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "s"
	DCB	0x0, "e", 0x0, "t", 0x0, ".", 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ContextRestore| PROC

; 1822 : {

  00000		 |$LN23@ContextRes|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M46225|
  00004	e1a04000	 mov         r4, r0

; 1823 :     SPI_DEVICE *pDevice = pInstance->pDevice;
; 1824 :     DWORD	dwCount=0;
; 1825 : 
; 1826 :     // Get Device
; 1827 :     pDevice = pInstance->pDevice;

  00008	e5945004	 ldr         r5, [r4, #4]
  0000c	e3a06000	 mov         r6, #0

; 1828 : 
; 1829 :     SETREG32(&pDevice->pSPIRegs->MCSPI_SYSCONFIG, MCSPI_SYSCONFIG_SOFTRESET);

  00010	e5952018	 ldr         r2, [r5, #0x18]
  00014	e5923010	 ldr         r3, [r2, #0x10]
  00018	e3833002	 orr         r3, r3, #2
  0001c	e5823010	 str         r3, [r2, #0x10]

; 1830 :     // Wait until resetting is done
; 1831 :     while ( !(INREG32(&pDevice->pSPIRegs->MCSPI_SYSSTATUS) & MCSPI_SYSSTATUS_RESETDONE))

  00020	ea000004	 b           |$LN19@ContextRes|
  00024		 |$LL11@ContextRes|

; 1832 :         {
; 1833 :         Sleep (1);

  00024	e3a00001	 mov         r0, #1
  00028	eb000000	 bl          Sleep

; 1834 :         if (dwCount++>0x100)

  0002c	e3560c01	 cmp         r6, #1, 24
  00030	e2866001	 add         r6, r6, #1
  00034	8a00000f	 bhi         |$LN17@ContextRes|
  00038		 |$LN19@ContextRes|
  00038	e5953018	 ldr         r3, [r5, #0x18]
  0003c	e5933014	 ldr         r3, [r3, #0x14]
  00040	e3130001	 tst         r3, #1
  00044	0afffff6	 beq         |$LL11@ContextRes|

; 1839 :             }
; 1840 :         }
; 1841 : 
; 1842 :     // Disable all interrupts.
; 1843 :     OUTREG32(&pDevice->pSPIRegs->MCSPI_IRQENABLE, 0);

  00048	e5953018	 ldr         r3, [r5, #0x18]
  0004c	e3a02000	 mov         r2, #0
  00050	e3a01cff	 mov         r1, #0xFF, 24
  00054	e583201c	 str         r2, [r3, #0x1C]

; 1844 :     // Clear interrupts.
; 1845 :     OUTREG32(&pDevice->pSPIRegs->MCSPI_IRQSTATUS, 0xFFFF);

  00058	e5952018	 ldr         r2, [r5, #0x18]
  0005c	e38130ff	 orr         r3, r1, #0xFF
  00060	e5823018	 str         r3, [r2, #0x18]

; 1846 :     // Setup Module Control as master or slave
; 1847 :     OUTREG32(&pDevice->pSPIRegs->MCSPI_MODULCTRL, (pDevice->eSpiMode==SLAVE) ? MCSPI_MS_BIT : 0);

  00064	e5953040	 ldr         r3, [r5, #0x40]
  00068	e3530002	 cmp         r3, #2
  0006c	1a00000b	 bne         |$LN14@ContextRes|
  00070	e3a02004	 mov         r2, #4
  00074	ea00000a	 b           |$LN15@ContextRes|
  00078		 |$LN17@ContextRes|

; 1835 :             {
; 1836 :             // Break out dead lock, something is wrong.
; 1837 :             ERRORMSG (TRUE, (TEXT("SPI: ERROR holding in reset.\n")));

  00078	e59f10b8	 ldr         r1, [pc, #0xB8]
  0007c	e59f00b0	 ldr         r0, [pc, #0xB0]
  00080	e3a03c07	 mov         r3, #7, 24
  00084	e383202d	 orr         r2, r3, #0x2D
  00088	eb000000	 bl          NKDbgPrintfW
  0008c	e59f009c	 ldr         r0, [pc, #0x9C]
  00090	eb000000	 bl          NKDbgPrintfW

; 1838 :             return FALSE;

  00094	e3a00000	 mov         r0, #0

; 1890 : }

  00098	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$LN14@ContextRes|

; 1846 :     // Setup Module Control as master or slave
; 1847 :     OUTREG32(&pDevice->pSPIRegs->MCSPI_MODULCTRL, (pDevice->eSpiMode==SLAVE) ? MCSPI_MS_BIT : 0);

  000a0	e3a02000	 mov         r2, #0
  000a4		 |$LN15@ContextRes|
  000a4	e5953018	 ldr         r3, [r5, #0x18]

; 1848 : 
; 1849 :     OUTREG32(&pDevice->pSPIRegs->MCSPI_SYSCONFIG, MCSPI_SYSCONFIG_AUTOIDLE |
; 1850 :         MCSPI_SYSCONFIG_SMARTIDLE | MCSPI_SYSCONFIG_ENAWAKEUP);

  000a8	e3a01015	 mov         r1, #0x15
  000ac	e5832028	 str         r2, [r3, #0x28]
  000b0	e5953018	 ldr         r3, [r5, #0x18]
  000b4	e5831010	 str         r1, [r3, #0x10]

; 1851 : 
; 1852 :     // Configure the channel
; 1853 :     switch( pInstance->address)

  000b8	e5943008	 ldr         r3, [r4, #8]
  000bc	e3530000	 cmp         r3, #0
  000c0	0a00000e	 beq         |$LN6@ContextRes|
  000c4	e3530001	 cmp         r3, #1
  000c8	0a000009	 beq         |$LN5@ContextRes|
  000cc	e3530002	 cmp         r3, #2
  000d0	0a000004	 beq         |$LN4@ContextRes|
  000d4	e3530003	 cmp         r3, #3
  000d8	1a00000d	 bne         |$LN7@ContextRes|

; 1872 : 
; 1873 :         case 3:
; 1874 :             //  Channel 3 configuration
; 1875 :             pInstance->pSPIChannelRegs = (OMAP_MCSPI_CHANNEL_REGS*)(&pDevice->pSPIRegs->MCSPI_CHCONF3);

  000dc	e5953018	 ldr         r3, [r5, #0x18]

; 1876 :             OUTREG32(&pInstance->pSPIChannelRegs->MCSPI_CHCONF, pInstance->config);

  000e0	e2833068	 add         r3, r3, #0x68

; 1877 :             break;

  000e4	ea000007	 b           |$LN20@ContextRes|
  000e8		 |$LN4@ContextRes|

; 1866 : 
; 1867 :         case 2:
; 1868 :             //  Channel 2 configuration
; 1869 :             pInstance->pSPIChannelRegs = (OMAP_MCSPI_CHANNEL_REGS*)(&pDevice->pSPIRegs->MCSPI_CHCONF2);

  000e8	e5953018	 ldr         r3, [r5, #0x18]

; 1870 :             OUTREG32(&pInstance->pSPIChannelRegs->MCSPI_CHCONF, pInstance->config);

  000ec	e2833054	 add         r3, r3, #0x54

; 1871 :             break;

  000f0	ea000004	 b           |$LN20@ContextRes|
  000f4		 |$LN5@ContextRes|

; 1859 :             break;
; 1860 : 
; 1861 :         case 1:
; 1862 :             //  Channel 1 configuration
; 1863 :             pInstance->pSPIChannelRegs = (OMAP_MCSPI_CHANNEL_REGS*)(&pDevice->pSPIRegs->MCSPI_CHCONF1);

  000f4	e5953018	 ldr         r3, [r5, #0x18]

; 1864 :             OUTREG32(&pInstance->pSPIChannelRegs->MCSPI_CHCONF, pInstance->config);

  000f8	e2833040	 add         r3, r3, #0x40

; 1865 :             break;

  000fc	ea000001	 b           |$LN20@ContextRes|
  00100		 |$LN6@ContextRes|

; 1854 :     {
; 1855 :         case 0:
; 1856 :             //  Channel 0 configuration
; 1857 :             pInstance->pSPIChannelRegs = (OMAP_MCSPI_CHANNEL_REGS*)(&pDevice->pSPIRegs->MCSPI_CHCONF0);

  00100	e5953018	 ldr         r3, [r5, #0x18]

; 1858 :             OUTREG32(&pInstance->pSPIChannelRegs->MCSPI_CHCONF, pInstance->config);

  00104	e283302c	 add         r3, r3, #0x2C
  00108		 |$LN20@ContextRes|
  00108	e594200c	 ldr         r2, [r4, #0xC]
  0010c	e5843010	 str         r3, [r4, #0x10]
  00110	e5832000	 str         r2, [r3]
  00114		 |$LN7@ContextRes|

; 1878 : 
; 1879 :         default:
; 1880 :             break;
; 1881 :     }
; 1882 : 
; 1883 :     //  Restore DMA if needed
; 1884 :     if (pInstance->config & (MCSPI_CHCONF_DMAR_ENABLE | MCSPI_CHCONF_DMAW_ENABLE))

  00114	e594300c	 ldr         r3, [r4, #0xC]
  00118	e3130903	 tst         r3, #3, 18

; 1885 :         {
; 1886 :         SpiDmaRestore(pInstance);

  0011c	11a00004	 movne       r0, r4
  00120	1b000000	 blne        SpiDmaRestore

; 1887 :         }
; 1888 : 
; 1889 :     return TRUE;

  00124	e3a00001	 mov         r0, #1

; 1890 : }

  00128	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0012c	e12fff1e	 bx          lr
  00130		 |$LN24@ContextRes|
  00130		 |$LN25@ContextRes|
  00130	00000000	 DCD         |??_C@_1DM@JFMOKFBI@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AAh?$AAo?$AAl?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAn?$AA?5?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?4?$AA?6?$AA?$AA@|
  00134		 |$LN26@ContextRes|
  00134	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  00138		 |$LN27@ContextRes|
  00138	00000000	 DCD         |??_C@_1IO@MLHBGINH@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  0013c		 |$M46226|

			 ENDP  ; |ContextRestore|

	EXPORT	|SPI_LockController|

  00000			 AREA	 |.pdata|, PDATA
|$T46245| DCD	|$LN8@SPI_LockCo|
	DCD	0x40001e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_LockController| PROC

; 1900 : {

  00000		 |$LN8@SPI_LockCo|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M46242|
  00004	e1b04000	 movs        r4, r0

; 1901 :     BOOL rc = FALSE;

  00008	e3a05000	 mov         r5, #0

; 1902 :     SPI_INSTANCE *pInstance = (SPI_INSTANCE*)context;
; 1903 :     SPI_DEVICE *pDevice;
; 1904 : 	UINT32 dwStatus;
; 1905 : 
; 1906 :     DEBUGMSG(ZONE_FUNCTION, (L"SPI_LockController\r\n"));
; 1907 : 	
; 1908 :     // Check if we get correct context
; 1909 :     if (pInstance == NULL || pInstance->cookie != SPI_INSTANCE_COOKIE) {

  0000c	0a000015	 beq         |$cleanUp$45274|
  00010	e5942000	 ldr         r2, [r4]
  00014	e59f3058	 ldr         r3, [pc, #0x58]
  00018	e1520003	 cmp         r2, r3
  0001c	1a000011	 bne         |$cleanUp$45274|

; 1910 :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_LockController: "
; 1911 :             L"Incorrect context paramer\r\n"
; 1912 :         ));
; 1913 :         goto cleanUp;
; 1914 :     }
; 1915 : 
; 1916 :     // Get Device
; 1917 :     pDevice = pInstance->pDevice;

  00020	e5946004	 ldr         r6, [r4, #4]

; 1918 : 	
; 1919 : 	// Get lock
; 1920 : 	dwStatus = WaitForSingleObject(pDevice->hControllerMutex, dwTimeout);

  00024	e596001c	 ldr         r0, [r6, #0x1C]
  00028	eb000000	 bl          WaitForSingleObject
  0002c	e3500000	 cmp         r0, #0

; 1921 : 	if (dwStatus != WAIT_OBJECT_0)

  00030	1a00000c	 bne         |$cleanUp$45274|

; 1922 : 	{
; 1923 :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_LockController: Failed getting the hardware lock!  Status 0x%x\r\n", dwStatus));
; 1924 : 		goto cleanUp;
; 1925 : 	}
; 1926 : 	
; 1927 :     // Set this driver to Active Mode
; 1928 :     SetSPIPower(pDevice, D0);

  00034	e3a01000	 mov         r1, #0
  00038	e1a00006	 mov         r0, r6
  0003c	eb000000	 bl          SetSPIPower

; 1929 : 	
; 1930 : 	// Set controller in single access mode
; 1931 :     SETREG32(&pDevice->pSPIRegs->MCSPI_MODULCTRL, MCSPI_SINGLE_BIT);

  00040	e5962018	 ldr         r2, [r6, #0x18]

; 1932 : 	
; 1933 :     // Set this driver to Suspend Mode
; 1934 :     SetSPIPower(pDevice, D4);

  00044	e3a01004	 mov         r1, #4
  00048	e1a00006	 mov         r0, r6
  0004c	e5923028	 ldr         r3, [r2, #0x28]
  00050	e3833001	 orr         r3, r3, #1
  00054	e5823028	 str         r3, [r2, #0x28]
  00058	eb000000	 bl          SetSPIPower

; 1935 : 	
; 1936 : 	// Set flag indicating we own the controller lock
; 1937 : 	pInstance->exclusiveAccess = TRUE;

  0005c	e3a03001	 mov         r3, #1
  00060	e5843014	 str         r3, [r4, #0x14]

; 1938 : 	
; 1939 :     // Done
; 1940 :     rc = TRUE;

  00064	e3a05001	 mov         r5, #1
  00068		 |$cleanUp$45274|

; 1941 : 	
; 1942 : cleanUp:
; 1943 :     DEBUGMSG(ZONE_FUNCTION, (L"-SPI_LockController\r\n"));
; 1944 : 	return rc;
; 1945 : }

  00068	e1a00005	 mov         r0, r5
  0006c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00070	e12fff1e	 bx          lr
  00074		 |$LN9@SPI_LockCo|
  00074		 |$LN10@SPI_LockCo|
  00074	73706949	 DCD         0x73706949
  00078		 |$M46243|

			 ENDP  ; |SPI_LockController|

	EXPORT	|SPI_UnlockController|

  00000			 AREA	 |.pdata|, PDATA
|$T46259| DCD	|$LN9@SPI_Unlock|
	DCD	0x40002001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_UnlockController| PROC

; 1954 : {

  00000		 |$LN9@SPI_Unlock|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M46256|
  00004	e1b06000	 movs        r6, r0

; 1955 :     BOOL rc = FALSE;

  00008	e3a05000	 mov         r5, #0

; 1956 :     SPI_INSTANCE *pInstance = (SPI_INSTANCE*)context;
; 1957 :     SPI_DEVICE *pDevice;
; 1958 : 
; 1959 :     DEBUGMSG(ZONE_FUNCTION, (L"SPI_UnlockController\r\n"));
; 1960 : 	
; 1961 :     // Check if we get correct context
; 1962 :     if (pInstance == NULL || pInstance->cookie != SPI_INSTANCE_COOKIE) {

  0000c	0a000017	 beq         |$cleanUp$45294|
  00010	e5962000	 ldr         r2, [r6]
  00014	e59f3060	 ldr         r3, [pc, #0x60]
  00018	e1520003	 cmp         r2, r3
  0001c	1a000013	 bne         |$cleanUp$45294|

; 1963 :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_UnlockController: "
; 1964 :             L"Incorrect context paramer\r\n"
; 1965 :         ));
; 1966 :         goto cleanUp;
; 1967 :     }
; 1968 : 	
; 1969 : 	// Check to see if we have exclusive access
; 1970 : 	if (!pInstance->exclusiveAccess)

  00020	e5963014	 ldr         r3, [r6, #0x14]
  00024	e3530000	 cmp         r3, #0
  00028	0a000010	 beq         |$cleanUp$45294|

; 1971 : 	{
; 1972 :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_UnlockController: Don't own SPI lock!\r\n"));
; 1973 : 		goto cleanUp;
; 1974 : 	}
; 1975 : 
; 1976 :     // Get Device
; 1977 :     pDevice = pInstance->pDevice;

  0002c	e5964004	 ldr         r4, [r6, #4]

; 1978 : 	
; 1979 :     // Set this driver to Active Mode
; 1980 :     SetSPIPower(pDevice, D0);

  00030	e3a01000	 mov         r1, #0
  00034	e1a00004	 mov         r0, r4
  00038	eb000000	 bl          SetSPIPower

; 1981 : 	
; 1982 : 	// Release single access mode
; 1983 :     CLRREG32(&pDevice->pSPIRegs->MCSPI_MODULCTRL, MCSPI_SINGLE_BIT);

  0003c	e5942018	 ldr         r2, [r4, #0x18]

; 1984 :     
; 1985 : 	// Set this driver to Suspend Mode
; 1986 :     SetSPIPower(pDevice, D4);

  00040	e3a01004	 mov         r1, #4
  00044	e1a00004	 mov         r0, r4
  00048	e5923028	 ldr         r3, [r2, #0x28]
  0004c	e3c33001	 bic         r3, r3, #1
  00050	e5823028	 str         r3, [r2, #0x28]
  00054	eb000000	 bl          SetSPIPower

; 1987 : 	
; 1988 : 	// Clear lock flag
; 1989 : 	pInstance->exclusiveAccess = FALSE;

  00058	e3a03000	 mov         r3, #0
  0005c	e5863014	 str         r3, [r6, #0x14]

; 1990 : 	
; 1991 : 	// Release lock
; 1992 : 	if (!ReleaseMutex(pDevice->hControllerMutex))

  00060	e594001c	 ldr         r0, [r4, #0x1C]
  00064	eb000000	 bl          ReleaseMutex
  00068	e3500000	 cmp         r0, #0

; 1993 : 	{
; 1994 :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_UnlockController: Error releasing lock!  Error code 0x%x\r\n", GetLastError()));
; 1995 : 		goto cleanUp;
; 1996 : 	}
; 1997 : 	
; 1998 :     // Done
; 1999 :     rc = TRUE;

  0006c	13a05001	 movne       r5, #1
  00070		 |$cleanUp$45294|

; 2000 : 	
; 2001 : cleanUp:
; 2002 :     DEBUGMSG(ZONE_FUNCTION, (L"-SPI_UnlockController\r\n"));
; 2003 : 	return rc;
; 2004 : }

  00070	e1a00005	 mov         r0, r5
  00074	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00078	e12fff1e	 bx          lr
  0007c		 |$LN10@SPI_Unlock|
  0007c		 |$LN11@SPI_Unlock|
  0007c	73706949	 DCD         0x73706949
  00080		 |$M46257|

			 ENDP  ; |SPI_UnlockController|

	EXPORT	|SPI_EnableChannel|

  00000			 AREA	 |.pdata|, PDATA
|$T46273| DCD	|$LN8@SPI_Enable|
	DCD	0x40001e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_EnableChannel| PROC

; 2015 : {

  00000		 |$LN8@SPI_Enable|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M46270|
  00004	e1b05000	 movs        r5, r0

; 2016 :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 2017 :     SPI_INSTANCE *pInstance = (SPI_INSTANCE*)context;
; 2018 :     SPI_DEVICE *pDevice;
; 2019 : 
; 2020 :     DEBUGMSG(ZONE_FUNCTION, (L"+SPI_EnableChannel\r\n"));
; 2021 : 	
; 2022 :     // Check if we get correct context
; 2023 :     if (pInstance == NULL || pInstance->cookie != SPI_INSTANCE_COOKIE) {

  0000c	0a000016	 beq         |$cleanUp$45316|
  00010	e5952000	 ldr         r2, [r5]
  00014	e59f3058	 ldr         r3, [pc, #0x58]
  00018	e1520003	 cmp         r2, r3
  0001c	1a000012	 bne         |$cleanUp$45316|

; 2024 :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_EnableChannel: "
; 2025 :             L"Incorrect context paramer\r\n"
; 2026 :         ));
; 2027 :         goto cleanUp;
; 2028 :     }
; 2029 : 	
; 2030 : 	// Check to see if we have exclusive access
; 2031 : 	if (!pInstance->exclusiveAccess)

  00020	e5953014	 ldr         r3, [r5, #0x14]
  00024	e3530000	 cmp         r3, #0
  00028	0a00000f	 beq         |$cleanUp$45316|

; 2032 : 	{
; 2033 :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_EnableChannel: Not in single access mode!!\r\n"));
; 2034 : 		goto cleanUp;
; 2035 : 	}
; 2036 : 
; 2037 :     // Get Device
; 2038 :     pDevice = pInstance->pDevice;

  0002c	e5954004	 ldr         r4, [r5, #4]

; 2039 :     
; 2040 : 	// Set this driver to Active Mode
; 2041 :     SetSPIPower(pDevice, D0);

  00030	e3a01000	 mov         r1, #0
  00034	e1a00004	 mov         r0, r4
  00038	eb000000	 bl          SetSPIPower

; 2042 : 	
; 2043 :     // Enable the channel
; 2044 :     SETREG32(&pInstance->pSPIChannelRegs->MCSPI_CHCTRL, MCSPI_CHCONT_EN);

  0003c	e5952010	 ldr         r2, [r5, #0x10]

; 2045 : 	// Assert the chip select
; 2046 :     SETREG32(&pInstance->pSPIChannelRegs->MCSPI_CHCONF, MCSPI_CHCONF_FORCE);
; 2047 :     
; 2048 : 	// Set this driver to Suspend Mode
; 2049 :     SetSPIPower(pDevice, D4);

  00040	e3a01004	 mov         r1, #4
  00044	e1a00004	 mov         r0, r4
  00048	e5923008	 ldr         r3, [r2, #8]
  0004c	e3833001	 orr         r3, r3, #1
  00050	e5823008	 str         r3, [r2, #8]
  00054	e5952010	 ldr         r2, [r5, #0x10]
  00058	e5923000	 ldr         r3, [r2]
  0005c	e3833601	 orr         r3, r3, #1, 12
  00060	e5823000	 str         r3, [r2]
  00064	eb000000	 bl          SetSPIPower

; 2050 : 	
; 2051 :     // Done
; 2052 :     rc = TRUE;

  00068	e3a00001	 mov         r0, #1
  0006c		 |$cleanUp$45316|

; 2053 : 	
; 2054 : cleanUp:
; 2055 :     DEBUGMSG(ZONE_FUNCTION, (L"-SPI_EnableChannel\r\n"));
; 2056 : 	return rc;	
; 2057 : }

  0006c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00070	e12fff1e	 bx          lr
  00074		 |$LN9@SPI_Enable|
  00074		 |$LN10@SPI_Enable|
  00074	73706949	 DCD         0x73706949
  00078		 |$M46271|

			 ENDP  ; |SPI_EnableChannel|

	EXPORT	|SPI_DisableChannel|

  00000			 AREA	 |.pdata|, PDATA
|$T46287| DCD	|$LN8@SPI_Disabl|
	DCD	0x40001e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_DisableChannel| PROC

; 2068 : {

  00000		 |$LN8@SPI_Disabl|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M46284|
  00004	e1b05000	 movs        r5, r0

; 2069 :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 2070 :     SPI_INSTANCE *pInstance = (SPI_INSTANCE*)context;
; 2071 :     SPI_DEVICE *pDevice;
; 2072 : 
; 2073 :     DEBUGMSG(ZONE_FUNCTION, (L"+SPI_DisableChannel\r\n"));
; 2074 : 	
; 2075 :     // Check if we get correct context
; 2076 :     if (pInstance == NULL || pInstance->cookie != SPI_INSTANCE_COOKIE) {

  0000c	0a000016	 beq         |$cleanUp$45339|
  00010	e5952000	 ldr         r2, [r5]
  00014	e59f3058	 ldr         r3, [pc, #0x58]
  00018	e1520003	 cmp         r2, r3
  0001c	1a000012	 bne         |$cleanUp$45339|

; 2077 :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_DisableChannel: "
; 2078 :             L"Incorrect context paramer\r\n"
; 2079 :         ));
; 2080 :         goto cleanUp;
; 2081 :     }
; 2082 : 	
; 2083 : 	// Check to see if we have exclusive access
; 2084 : 	if (!pInstance->exclusiveAccess)

  00020	e5953014	 ldr         r3, [r5, #0x14]
  00024	e3530000	 cmp         r3, #0
  00028	0a00000f	 beq         |$cleanUp$45339|

; 2085 : 	{
; 2086 :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_DisableChannel: Not in single access mode!!\r\n"));
; 2087 : 		goto cleanUp;
; 2088 : 	}
; 2089 : 
; 2090 :     // Get Device
; 2091 :     pDevice = pInstance->pDevice;

  0002c	e5954004	 ldr         r4, [r5, #4]

; 2092 : 	
; 2093 : 	// Set this driver to Active Mode
; 2094 :     SetSPIPower(pDevice, D0);

  00030	e3a01000	 mov         r1, #0
  00034	e1a00004	 mov         r0, r4
  00038	eb000000	 bl          SetSPIPower

; 2095 : 	
; 2096 : 	// De-assert the chip select
; 2097 :     CLRREG32(&pInstance->pSPIChannelRegs->MCSPI_CHCONF, MCSPI_CHCONF_FORCE);

  0003c	e5952010	 ldr         r2, [r5, #0x10]

; 2098 :     // Disable the channel
; 2099 :     CLRREG32(&pInstance->pSPIChannelRegs->MCSPI_CHCTRL, MCSPI_CHCONT_EN);
; 2100 : 
; 2101 : 	// Set this driver to Suspend Mode
; 2102 :     SetSPIPower(pDevice, D4);

  00040	e3a01004	 mov         r1, #4
  00044	e1a00004	 mov         r0, r4
  00048	e5923000	 ldr         r3, [r2]
  0004c	e3c33601	 bic         r3, r3, #1, 12
  00050	e5823000	 str         r3, [r2]
  00054	e5952010	 ldr         r2, [r5, #0x10]
  00058	e5923008	 ldr         r3, [r2, #8]
  0005c	e3c33001	 bic         r3, r3, #1
  00060	e5823008	 str         r3, [r2, #8]
  00064	eb000000	 bl          SetSPIPower

; 2103 : 	
; 2104 :     // Done
; 2105 :     rc = TRUE;

  00068	e3a00001	 mov         r0, #1
  0006c		 |$cleanUp$45339|

; 2106 : 	
; 2107 : cleanUp:
; 2108 :     DEBUGMSG(ZONE_FUNCTION, (L"-SPI_DisableChannel\r\n"));
; 2109 : 	return rc;	
; 2110 : }

  0006c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00070	e12fff1e	 bx          lr
  00074		 |$LN9@SPI_Disabl|
  00074		 |$LN10@SPI_Disabl|
  00074	73706949	 DCD         0x73706949
  00078		 |$M46285|

			 ENDP  ; |SPI_DisableChannel|

	EXPORT	|SPI_PowerUp|

  00000			 AREA	 |.pdata|, PDATA
|$T46296| DCD	|$LN5@SPI_PowerU|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_PowerUp| PROC

; 2409 : {

  00000		 |$LN5@SPI_PowerU|
  00000		 |$M46293|

; 2410 : 	UNREFERENCED_PARAMETER(context);
; 2411 : }

  00000	e12fff1e	 bx          lr
  00004		 |$M46294|

			 ENDP  ; |SPI_PowerUp|

	EXPORT	|SPI_PowerDown|

  00000			 AREA	 |.pdata|, PDATA
|$T46303| DCD	|$LN5@SPI_PowerD|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_PowerDown| PROC

; 2420 : {

  00000		 |$LN5@SPI_PowerD|
  00000		 |$M46300|

; 2421 : 	UNREFERENCED_PARAMETER(context);
; 2422 : }

  00000	e12fff1e	 bx          lr
  00004		 |$M46301|

			 ENDP  ; |SPI_PowerDown|

	EXPORT	|DllMain|
	IMPORT	|DisableThreadLibraryCalls|
	IMPORT	|RegisterDbgZones|

  00000			 AREA	 |.pdata|, PDATA
|$T46314| DCD	|$LN8@DllMain|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DllMain| PROC

; 2438 : {

  00000		 |$LN8@DllMain|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M46311|
  00004	e1a04000	 mov         r4, r0

; 2439 :     switch (reason)

  00008	e3510001	 cmp         r1, #1
  0000c	1a000003	 bne         |$LN2@DllMain|

; 2440 :         {
; 2441 :         case DLL_PROCESS_ATTACH:
; 2442 :             RETAILREGISTERZONES((HMODULE)hDLL);

  00010	e59f1014	 ldr         r1, [pc, #0x14]
  00014	eb000000	 bl          RegisterDbgZones

; 2443 :             DisableThreadLibraryCalls((HMODULE)hDLL);

  00018	e1a00004	 mov         r0, r4
  0001c	eb000000	 bl          DisableThreadLibraryCalls
  00020		 |$LN2@DllMain|

; 2444 :             break;
; 2445 :         }
; 2446 : 
; 2447 : UNREFERENCED_PARAMETER(pReserved);
; 2448 :     return TRUE;

  00020	e3a00001	 mov         r0, #1

; 2449 : }

  00024	e8bd4010	 ldmia       sp!, {r4, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$LN9@DllMain|
  0002c		 |$LN10@DllMain|
  0002c	00000000	 DCD         |dpCurSettings|
  00030		 |$M46312|

			 ENDP  ; |DllMain|

	EXPORT	|SPI_Init|
	EXPORT	|??_C@_1CK@HDDADMFP@?$AA?9?$AAS?$AAP?$AAI?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EA@JPGNEHHB@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAP?$AAa?$AAd?$AAs?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?4?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DG@HBJEBDML@?$AA?5?$AAS?$AAP?$AAI?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAd?$AAe?$AAv?$AAi?$AAc?$AAe?$AAI?$AAD?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CO@BLLGHNLJ@?$AA?5?$AAS?$AAP?$AAI?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAp?$AAo?$AAr?$AAt?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DA@OOBNOJJ@?$AA?$CL?$AAS?$AAP?$AAI?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CF?$AAs?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|RequestDevicePads|
	IMPORT	|InterruptInitialize|
	IMPORT	|MmMapIoSpace|
	IMPORT	|GetAddressByDevice|
	IMPORT	|GetIrqByDevice|
	IMPORT	|SOCGetMCSPIDeviceByBus|
	IMPORT	|CeSetThreadPriority|
	IMPORT	|CreateThread|
	IMPORT	|CreateBusAccessHandle|
	IMPORT	|CreateEventW|
	IMPORT	|GetDeviceRegistryParams|
	IMPORT	|CreateMutexW|
	IMPORT	|InitializeCriticalSection|
	IMPORT	|wcslen|

  00000			 AREA	 |.pdata|, PDATA
|$T46338| DCD	|$LN29@SPI_Init|
	DCD	0x4000da02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CK@HDDADMFP@?$AA?9?$AAS?$AAP?$AAI?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "-"
	DCB	0x0, "S", 0x0, "P", 0x0, "I", 0x0, "_", 0x0, "I", 0x0, "n"
	DCB	0x0, "i", 0x0, "t", 0x0, "(", 0x0, "r", 0x0, "c", 0x0, " "
	DCB	0x0, "=", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ")", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EA@JPGNEHHB@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAP?$AAa?$AAd?$AAs?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?4?$AA?6?$AA?$AA@| DCB "S"
	DCB	0x0, "P", 0x0, "I", 0x0, ":", 0x0, " ", 0x0, "R", 0x0, "e"
	DCB	0x0, "q", 0x0, "u", 0x0, "e", 0x0, "s", 0x0, "t", 0x0, "D"
	DCB	0x0, "e", 0x0, "v", 0x0, "i", 0x0, "c", 0x0, "e", 0x0, "P"
	DCB	0x0, "a", 0x0, "d", 0x0, "s", 0x0, " ", 0x0, "f", 0x0, "a"
	DCB	0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, ".", 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DG@HBJEBDML@?$AA?5?$AAS?$AAP?$AAI?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAd?$AAe?$AAv?$AAi?$AAc?$AAe?$AAI?$AAD?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| DCB " "
	DCB	0x0, "S", 0x0, "P", 0x0, "I", 0x0, "_", 0x0, "I", 0x0, "n"
	DCB	0x0, "i", 0x0, "t", 0x0, ":", 0x0, " ", 0x0, "d", 0x0, "e"
	DCB	0x0, "v", 0x0, "i", 0x0, "c", 0x0, "e", 0x0, "I", 0x0, "D"
	DCB	0x0, " ", 0x0, "=", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CO@BLLGHNLJ@?$AA?5?$AAS?$AAP?$AAI?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAp?$AAo?$AAr?$AAt?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| DCB " "
	DCB	0x0, "S", 0x0, "P", 0x0, "I", 0x0, "_", 0x0, "I", 0x0, "n"
	DCB	0x0, "i", 0x0, "t", 0x0, ":", 0x0, " ", 0x0, "p", 0x0, "o"
	DCB	0x0, "r", 0x0, "t", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "%"
	DCB	0x0, "d", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DA@OOBNOJJ@?$AA?$CL?$AAS?$AAP?$AAI?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CF?$AAs?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "+"
	DCB	0x0, "S", 0x0, "P", 0x0, "I", 0x0, "_", 0x0, "I", 0x0, "n"
	DCB	0x0, "i", 0x0, "t", 0x0, "(", 0x0, "%", 0x0, "s", 0x0, ","
	DCB	0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%", 0x0, "0", 0x0, "8"
	DCB	0x0, "x", 0x0, ")", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_Init| PROC

; 340  : {

  00000		 |$LN29@SPI_Init|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M46335|
  00008	e1a02001	 mov         r2, r1
  0000c	e1a07000	 mov         r7, r0

; 341  :     DWORD rc = (DWORD)NULL;
; 342  :     SPI_DEVICE *pDevice = NULL;
; 343  :     PHYSICAL_ADDRESS pa;
; 344  :     DWORD dwCount=0;
; 345  : 
; 346  : 	UNREFERENCED_PARAMETER(pBusContext);
; 347  : 
; 348  :     //DEBUGMSG(ZONE_FUNCTION, (L"+SPI_Init(%s, 0x%08x)\r\n", szContext, pBusContext));
; 349  : 	RETAILMSG(1, (L"+SPI_Init(%s, 0x%08x)\r\n", szContext, pBusContext));

  00010	e59f034c	 ldr         r0, [pc, #0x34C]
  00014	e1a01007	 mov         r1, r7
  00018	e3a05000	 mov         r5, #0
  0001c	e3a06000	 mov         r6, #0
  00020	eb000000	 bl          NKDbgPrintfW

; 350  :     // Create device structure
; 351  :     pDevice = (SPI_DEVICE *)LocalAlloc(LPTR, sizeof(SPI_DEVICE));

  00024	e3a01fa5	 mov         r1, #0xA5, 30
  00028	e3a00040	 mov         r0, #0x40
  0002c	eb000000	 bl          LocalAlloc
  00030	e1b04000	 movs        r4, r0

; 352  :     if (pDevice == NULL) {

  00034	0a0000b6	 beq         |$LN24@SPI_Init|

; 353  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_Init: "
; 354  :             L"Failed allocate SPI controller structure\r\n"));
; 355  :         goto cleanUp;
; 356  :     }
; 357  :     memset(pDevice, 0, sizeof(SPI_DEVICE));

  00038	e3a02fa5	 mov         r2, #0xA5, 30
  0003c	e3a01000	 mov         r1, #0
  00040	e1a00004	 mov         r0, r4
  00044	eb000000	 bl          memset

; 358  : 
; 359  :     // Set cookie
; 360  :     pDevice->cookie = SPI_DEVICE_COOKIE;

  00048	e59f3310	 ldr         r3, [pc, #0x310]

; 361  :     pDevice->powerState = D4;

  0004c	e3a09004	 mov         r9, #4

; 362  : 
; 363  :     // initialize dvfs variables
; 364  :     pDevice->bDVFSActive = FALSE;

  00050	e3a08000	 mov         r8, #0

; 365  :     pDevice->nActiveDmaCount = 0;
; 366  :     pDevice->hDVFSAsyncEvent = NULL;
; 367  :     pDevice->szDVFSAsyncEventName[0] = _T('\0');
; 368  : 
; 369  :     // Initalize DVFS critical section
; 370  :     InitializeCriticalSection(&pDevice->csDVFS);

  00054	e2840f97	 add         r0, r4, #0x97, 30
  00058	e5843000	 str         r3, [r4]
  0005c	e5849034	 str         r9, [r4, #0x34]
  00060	e5848044	 str         r8, [r4, #0x44]
  00064	e5848048	 str         r8, [r4, #0x48]
  00068	e5848050	 str         r8, [r4, #0x50]
  0006c	e1c485b4	 strh        r8, [r4, #0x54]
  00070	eb000000	 bl          InitializeCriticalSection

; 371  : 	// Initialize controller mutex (needs to be mutex to lock access for multiple transactions)
; 372  : 	pDevice->hControllerMutex = CreateMutex(NULL, FALSE, NULL);

  00074	e3a02000	 mov         r2, #0
  00078	e3a01000	 mov         r1, #0
  0007c	e3a00000	 mov         r0, #0
  00080	eb000000	 bl          CreateMutexW
  00084	e3500000	 cmp         r0, #0
  00088	e584001c	 str         r0, [r4, #0x1C]

; 373  : 	if (pDevice->hControllerMutex == NULL)

  0008c	0a0000a0	 beq         |$LN24@SPI_Init|

; 374  : 	{
; 375  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_Init: Error creating mutex!\r\n"));
; 376  : 		goto cleanUp;
; 377  : 	}
; 378  : 
; 379  :     // Read device parameters
; 380  :     if (GetDeviceRegistryParams(
; 381  :         szContext, pDevice, dimof(g_deviceRegParams), g_deviceRegParams) != ERROR_SUCCESS) 

  00090	e59f32c4	 ldr         r3, [pc, #0x2C4]
  00094	e3a02006	 mov         r2, #6
  00098	e1a01004	 mov         r1, r4
  0009c	e1a00007	 mov         r0, r7
  000a0	eb000000	 bl          GetDeviceRegistryParams
  000a4	e3500000	 cmp         r0, #0
  000a8	1a000099	 bne         |$LN24@SPI_Init|

; 382  : 	{
; 383  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_Init: "
; 384  :             L"Failed read SPI driver registry parameters\r\n"));
; 385  :         goto cleanUp;
; 386  :     }
; 387  :     RETAILMSG(1, (L" SPI_Init: port = %d\r\n", pDevice->dwPort));

  000ac	e5941038	 ldr         r1, [r4, #0x38]
  000b0	e59f02a0	 ldr         r0, [pc, #0x2A0]
  000b4	eb000000	 bl          NKDbgPrintfW

; 388  : 
; 389  :     // Create DVFS async dvfs handles if necessary
; 390  :     pDevice->hDVFSInactiveEvent = CreateEvent(NULL, TRUE, TRUE, NULL);

  000b8	e3a03000	 mov         r3, #0
  000bc	e3a02001	 mov         r2, #1
  000c0	e3a01001	 mov         r1, #1
  000c4	e3a00000	 mov         r0, #0
  000c8	eb000000	 bl          CreateEventW

; 391  :     if (_tcslen(pDevice->szDVFSAsyncEventName) > 0)

  000cc	e1a03000	 mov         r3, r0
  000d0	e2840054	 add         r0, r4, #0x54
  000d4	e584304c	 str         r3, [r4, #0x4C]
  000d8	eb000000	 bl          wcslen
  000dc	e3500000	 cmp         r0, #0
  000e0	0a000005	 beq         |$LN16@SPI_Init|

; 392  : 	{
; 393  :         pDevice->hDVFSAsyncEvent = CreateEvent(NULL, TRUE, FALSE, pDevice->szDVFSAsyncEventName);        

  000e4	e2843054	 add         r3, r4, #0x54
  000e8	e3a02000	 mov         r2, #0
  000ec	e3a01001	 mov         r1, #1
  000f0	e3a00000	 mov         r0, #0
  000f4	eb000000	 bl          CreateEventW
  000f8	e5840050	 str         r0, [r4, #0x50]
  000fc		 |$LN16@SPI_Init|

; 394  : 	}
; 395  : 
; 396  :     // Open parent bus
; 397  :     pDevice->hParentBus = CreateBusAccessHandle(szContext);

  000fc	e1a00007	 mov         r0, r7
  00100	eb000000	 bl          CreateBusAccessHandle
  00104	e3500000	 cmp         r0, #0
  00108	e5840014	 str         r0, [r4, #0x14]

; 398  :     if (pDevice->hParentBus == NULL) 

  0010c	0a000080	 beq         |$LN24@SPI_Init|

; 399  :     {
; 400  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_Init: "L"Failed open parent bus driver\r\n"));
; 401  :         goto cleanUp;
; 402  :     }
; 403  : 
; 404  :     // start timer thread
; 405  :     pDevice->hTimerEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  00110	e3a03000	 mov         r3, #0
  00114	e3a02000	 mov         r2, #0
  00118	e3a01000	 mov         r1, #0
  0011c	e3a00000	 mov         r0, #0
  00120	eb000000	 bl          CreateEventW
  00124	e3500000	 cmp         r0, #0
  00128	e5840278	 str         r0, [r4, #0x278]

; 406  :     if (pDevice->hTimerEvent != NULL)

  0012c	0a00000a	 beq         |$LN13@SPI_Init|

; 407  : 	{
; 408  :         pDevice->hTimerThread = CreateThread(NULL, 0, SPIPowerTimerThread, pDevice, 0, NULL);

  00130	e59f221c	 ldr         r2, [pc, #0x21C]
  00134	e1a03004	 mov         r3, r4
  00138	e3a01000	 mov         r1, #0
  0013c	e3a00000	 mov         r0, #0
  00140	e58d8004	 str         r8, [sp, #4]
  00144	e58d8000	 str         r8, [sp]
  00148	eb000000	 bl          CreateThread
  0014c	e3500000	 cmp         r0, #0

; 409  :         
; 410  :         if (pDevice->hTimerThread != NULL)
; 411  : 		{
; 412  :             CeSetThreadPriority(pDevice->hTimerThread, TIMERTHREAD_PRIORITY);

  00150	13a01098	 movne       r1, #0x98
  00154	e5840274	 str         r0, [r4, #0x274]
  00158	1b000000	 blne        CeSetThreadPriority
  0015c		 |$LN13@SPI_Init|

; 413  : 		}
; 414  : 	}
; 415  : 
; 416  :     // Create an Event to wait for Device OFF on Suspend
; 417  :     pDevice->hDeviceOffEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  0015c	e3a03000	 mov         r3, #0
  00160	e3a02000	 mov         r2, #0
  00164	e3a01000	 mov         r1, #0
  00168	e3a00000	 mov         r0, #0
  0016c	eb000000	 bl          CreateEventW
  00170	e1a03000	 mov         r3, r0

; 418  :     if (pDevice->hDeviceOffEvent == NULL)
; 419  :     {
; 420  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_Init: "
; 421  :             L"Failed to create Device Off Event\r\n"));        
; 422  : 	}
; 423  : 	
; 424  : 	// Retrieve device ID
; 425  : 	pDevice->deviceID = SOCGetMCSPIDeviceByBus(pDevice->dwPort);

  00174	e5940038	 ldr         r0, [r4, #0x38]
  00178	e584328c	 str         r3, [r4, #0x28C]
  0017c	eb000000	 bl          SOCGetMCSPIDeviceByBus
  00180	e1a03000	 mov         r3, r0

; 426  : 	RETAILMSG(1, (L" SPI_Init: deviceID = %d\r\n", pDevice->deviceID));

  00184	e59f01c4	 ldr         r0, [pc, #0x1C4]
  00188	e1a01003	 mov         r1, r3
  0018c	e584303c	 str         r3, [r4, #0x3C]
  00190	eb000000	 bl          NKDbgPrintfW

; 427  : 	if (pDevice->deviceID == OMAP_DEVICE_NONE)

  00194	e594003c	 ldr         r0, [r4, #0x3C]
  00198	e3700001	 cmn         r0, #1
  0019c	0a00005c	 beq         |$LN24@SPI_Init|

; 428  : 	{
; 429  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_Init: "
; 430  :             L"Failed to find device ID for this SPI controller\r\n"));
; 431  :         goto cleanUp;
; 432  : 	}
; 433  : 	
; 434  : 
; 435  :     
; 436  : 	// Retrieve IRQ from device
; 437  : 	pDevice->irq = GetIrqByDevice(pDevice->deviceID, NULL);

  001a0	e3a01000	 mov         r1, #0
  001a4	eb000000	 bl          GetIrqByDevice
  001a8	e584000c	 str         r0, [r4, #0xC]

; 438  : 	if (pDevice->irq == (DWORD)-1)

  001ac	e3700001	 cmn         r0, #1
  001b0	0a000057	 beq         |$LN24@SPI_Init|

; 439  : 	{
; 440  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_Init: "
; 441  :             L"Failed to find IRQ number for this SPI controller\r\n"
; 442  :         ));
; 443  :         goto cleanUp;
; 444  : 	}
; 445  : 
; 446  :     // Map SPI controller
; 447  : 	pa.QuadPart = GetAddressByDevice(pDevice->deviceID);

  001b4	e594003c	 ldr         r0, [r4, #0x3C]
  001b8	eb000000	 bl          GetAddressByDevice

; 448  :     pDevice->pSPIRegs = MmMapIoSpace(pa, sizeof(OMAP_MCSPI_REGS), FALSE);

  001bc	e3a01000	 mov         r1, #0
  001c0	e3a03000	 mov         r3, #0
  001c4	e3a0207c	 mov         r2, #0x7C
  001c8	eb000000	 bl          MmMapIoSpace
  001cc	e3500000	 cmp         r0, #0
  001d0	e5840018	 str         r0, [r4, #0x18]

; 449  :     if (pDevice->pSPIRegs == NULL) {

  001d4	0a00004e	 beq         |$LN24@SPI_Init|

; 450  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_Init: "
; 451  :             L"Failed map SPI controller registers\r\n"
; 452  :         ));
; 453  :         goto cleanUp;
; 454  :     }
; 455  : 
; 456  :     // Map SPI interrupt
; 457  :     if (!KernelIoControl(
; 458  :         IOCTL_HAL_REQUEST_SYSINTR, &pDevice->irq, sizeof(pDevice->irq), 
; 459  :         &pDevice->sysIntr, sizeof(pDevice->sysIntr), NULL
; 460  :     )) {

  001d8	e59f016c	 ldr         r0, [pc, #0x16C]
  001dc	e2843020	 add         r3, r4, #0x20
  001e0	e3a02004	 mov         r2, #4
  001e4	e284100c	 add         r1, r4, #0xC
  001e8	e58d8004	 str         r8, [sp, #4]
  001ec	e58d9000	 str         r9, [sp]
  001f0	eb000000	 bl          KernelIoControl
  001f4	e3500000	 cmp         r0, #0
  001f8	0a000045	 beq         |$LN24@SPI_Init|

; 461  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_Init: "
; 462  :             L"Failed map SPI controller interrupt\r\n"
; 463  :         ));
; 464  :         goto cleanUp;
; 465  :     }
; 466  :     
; 467  :     // Set hardware to full power    
; 468  :     SetSPIPower(pDevice, D0);

  001fc	e3a01000	 mov         r1, #0
  00200	e1a00004	 mov         r0, r4
  00204	eb000000	 bl          SetSPIPower

; 469  : 
; 470  :     // Create interrupt event
; 471  :     pDevice->hIntrEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  00208	e3a03000	 mov         r3, #0
  0020c	e3a02000	 mov         r2, #0
  00210	e3a01000	 mov         r1, #0
  00214	e3a00000	 mov         r0, #0
  00218	eb000000	 bl          CreateEventW
  0021c	e1b01000	 movs        r1, r0
  00220	e5841024	 str         r1, [r4, #0x24]

; 472  :     if (pDevice->hIntrEvent == NULL) {

  00224	0a00003a	 beq         |$LN24@SPI_Init|

; 473  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_Init: "
; 474  :             L"Failed create interrupt event\r\n"
; 475  :         ));
; 476  :         goto cleanUp;
; 477  :     }
; 478  : 
; 479  :     // Initialize interrupt
; 480  :     if (!InterruptInitialize(pDevice->sysIntr, pDevice->hIntrEvent, NULL, 0)) {

  00228	e5940020	 ldr         r0, [r4, #0x20]
  0022c	e3a03000	 mov         r3, #0
  00230	e3a02000	 mov         r2, #0
  00234	eb000000	 bl          InterruptInitialize
  00238	e3500000	 cmp         r0, #0
  0023c	0a000034	 beq         |$LN24@SPI_Init|

; 481  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_Init: "
; 482  :             L"InterruptInitialize failed\r\n"
; 483  :         ));
; 484  :         goto cleanUp;
; 485  :     }
; 486  : 	
; 487  :     // Reset the SPI controller
; 488  :     SETREG32(&pDevice->pSPIRegs->MCSPI_SYSCONFIG, MCSPI_SYSCONFIG_SOFTRESET);

  00240	e5942018	 ldr         r2, [r4, #0x18]
  00244	e5923010	 ldr         r3, [r2, #0x10]
  00248	e3833002	 orr         r3, r3, #2
  0024c	e5823010	 str         r3, [r2, #0x10]

; 489  : 
; 490  :     // Wait until resetting is done
; 491  :     while ( !(INREG32(&pDevice->pSPIRegs->MCSPI_SYSSTATUS) & MCSPI_SYSSTATUS_RESETDONE)) {

  00250	ea000004	 b           |$LN26@SPI_Init|
  00254		 |$LL5@SPI_Init|

; 492  :         Sleep (1);

  00254	e3a00001	 mov         r0, #1
  00258	eb000000	 bl          Sleep

; 493  : 
; 494  :         if (dwCount++>0x100)

  0025c	e3560c01	 cmp         r6, #1, 24
  00260	e2866001	 add         r6, r6, #1
  00264	8a00001f	 bhi         |$LN23@SPI_Init|
  00268		 |$LN26@SPI_Init|
  00268	e5943018	 ldr         r3, [r4, #0x18]
  0026c	e5933014	 ldr         r3, [r3, #0x14]
  00270	e3130001	 tst         r3, #1
  00274	0afffff6	 beq         |$LL5@SPI_Init|

; 499  :         }
; 500  :     }
; 501  : 
; 502  :     // Disable all interrupts.
; 503  :     OUTREG32(&pDevice->pSPIRegs->MCSPI_IRQENABLE, 0);

  00278	e5943018	 ldr         r3, [r4, #0x18]
  0027c	e3a02cff	 mov         r2, #0xFF, 24

; 504  : 
; 505  :     // Clear interrupts.
; 506  :     OUTREG32(&pDevice->pSPIRegs->MCSPI_IRQSTATUS, 0xFFFF);

  00280	e38220ff	 orr         r2, r2, #0xFF
  00284	e583801c	 str         r8, [r3, #0x1C]
  00288	e5943018	 ldr         r3, [r4, #0x18]

; 507  : 
; 508  : 
; 509  :     // Setup Module Control as master and eSpiMode to unknown so we can change it later.
; 510  :     pDevice->eSpiMode = UNKNOWN;
; 511  :     OUTREG32(&pDevice->pSPIRegs->MCSPI_MODULCTRL, 0);
; 512  : 
; 513  :     // Return non-null value
; 514  :     rc = (DWORD)pDevice;
; 515  : 
; 516  :     // Set this driver to internal suspend mode
; 517  :     OUTREG32(&pDevice->pSPIRegs->MCSPI_SYSCONFIG, MCSPI_SYSCONFIG_AUTOIDLE |
; 518  :         MCSPI_SYSCONFIG_SMARTIDLE | MCSPI_SYSCONFIG_ENAWAKEUP); 

  0028c	e3a0e015	 mov         lr, #0x15

; 519  :     SetSPIPower(pDevice, D4);

  00290	e3a01004	 mov         r1, #4
  00294	e5832018	 str         r2, [r3, #0x18]
  00298	e5943018	 ldr         r3, [r4, #0x18]
  0029c	e5848040	 str         r8, [r4, #0x40]
  002a0	e1a00004	 mov         r0, r4
  002a4	e5838028	 str         r8, [r3, #0x28]
  002a8	e5943018	 ldr         r3, [r4, #0x18]
  002ac	e1a05004	 mov         r5, r4
  002b0	e583e010	 str         lr, [r3, #0x10]
  002b4	eb000000	 bl          SetSPIPower

; 520  : 
; 521  :     if (!RequestDevicePads(pDevice->deviceID))

  002b8	e594003c	 ldr         r0, [r4, #0x3C]
  002bc	eb000000	 bl          RequestDevicePads
  002c0	e3500000	 cmp         r0, #0
  002c4	1a000010	 bne         |$LN2@SPI_Init|

; 522  :     {
; 523  :         ERRORMSG (TRUE, (TEXT("SPI: RequestDevicePads failed.\n")));

  002c8	e59f1074	 ldr         r1, [pc, #0x74]
  002cc	e59f006c	 ldr         r0, [pc, #0x6C]
  002d0	e3a03c02	 mov         r3, #2, 24
  002d4	e383200b	 orr         r2, r3, #0xB
  002d8	eb000000	 bl          NKDbgPrintfW
  002dc	e59f0064	 ldr         r0, [pc, #0x64]
  002e0	eb000000	 bl          NKDbgPrintfW

; 524  :         goto cleanUp;

  002e4	ea00000c	 b           |$LN1@SPI_Init|
  002e8		 |$LN23@SPI_Init|

; 495  :         {
; 496  :             // Break out dead lock, something is wrong.
; 497  :             ERRORMSG (TRUE, (TEXT("SPI: ERROR holding in reset.\n")));

  002e8	e59f1054	 ldr         r1, [pc, #0x54]
  002ec	e59f004c	 ldr         r0, [pc, #0x4C]
  002f0	e3a03c01	 mov         r3, #1, 24
  002f4	e38320f1	 orr         r2, r3, #0xF1
  002f8	eb000000	 bl          NKDbgPrintfW
  002fc	e59f0038	 ldr         r0, [pc, #0x38]
  00300	eb000000	 bl          NKDbgPrintfW

; 498  :             return FALSE;

  00304	e3a05000	 mov         r5, #0
  00308	ea000006	 b           |$LN20@SPI_Init|
  0030c		 |$LN2@SPI_Init|

; 525  :     }
; 526  : 
; 527  :     // Return non-null value
; 528  :     rc = (DWORD)pDevice;

  0030c	e1a05004	 mov         r5, r4
  00310		 |$cleanUp$44618|

; 529  : 
; 530  : cleanUp:
; 531  :     if (rc == 0) SPI_Deinit((DWORD)pDevice);

  00310	ea000001	 b           |$LN1@SPI_Init|
  00314		 |$LN24@SPI_Init|
  00314	e1a00004	 mov         r0, r4
  00318	eb000000	 bl          SPI_Deinit
  0031c		 |$LN1@SPI_Init|

; 532  :     RETAILMSG(1, (L"-SPI_Init(rc = %d)\r\n", rc));

  0031c	e59f0014	 ldr         r0, [pc, #0x14]
  00320	e1a01005	 mov         r1, r5
  00324	eb000000	 bl          NKDbgPrintfW

; 533  :     return rc;

  00328		 |$LN20@SPI_Init|

; 534  : }

  00328	e1a00005	 mov         r0, r5
  0032c	e28dd008	 add         sp, sp, #8
  00330	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00334	e12fff1e	 bx          lr
  00338		 |$LN30@SPI_Init|
  00338		 |$LN31@SPI_Init|
  00338	00000000	 DCD         |??_C@_1CK@HDDADMFP@?$AA?9?$AAS?$AAP?$AAI?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  0033c		 |$LN32@SPI_Init|
  0033c	00000000	 DCD         |??_C@_1DM@JFMOKFBI@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AAh?$AAo?$AAl?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAn?$AA?5?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?4?$AA?6?$AA?$AA@|
  00340		 |$LN33@SPI_Init|
  00340	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  00344		 |$LN34@SPI_Init|
  00344	00000000	 DCD         |??_C@_1IO@MLHBGINH@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  00348		 |$LN35@SPI_Init|
  00348	00000000	 DCD         |??_C@_1EA@JPGNEHHB@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAP?$AAa?$AAd?$AAs?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?4?$AA?6?$AA?$AA@|
  0034c		 |$LN36@SPI_Init|
  0034c	01010098	 DCD         0x1010098
  00350		 |$LN37@SPI_Init|
  00350	00000000	 DCD         |??_C@_1DG@HBJEBDML@?$AA?5?$AAS?$AAP?$AAI?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAd?$AAe?$AAv?$AAi?$AAc?$AAe?$AAI?$AAD?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@|
  00354		 |$LN38@SPI_Init|
  00354	00000000	 DCD         |SPIPowerTimerThread|
  00358		 |$LN39@SPI_Init|
  00358	00000000	 DCD         |??_C@_1CO@BLLGHNLJ@?$AA?5?$AAS?$AAP?$AAI?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAp?$AAo?$AAr?$AAt?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@|
  0035c		 |$LN40@SPI_Init|
  0035c	00000000	 DCD         |g_deviceRegParams|
  00360		 |$LN41@SPI_Init|
  00360	73706944	 DCD         0x73706944
  00364		 |$LN42@SPI_Init|
  00364	00000000	 DCD         |??_C@_1DA@OOBNOJJ@?$AA?$CL?$AAS?$AAP?$AAI?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CF?$AAs?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  00368		 |$M46336|

			 ENDP  ; |SPI_Init|

	EXPORT	|SPI_Read|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\spi\spi_priv.h

  00000			 AREA	 |.pdata|, PDATA
|$T46381| DCD	|$LN30@SPI_Read|
	DCD	0x40004e01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\spi\spi.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_Read| PROC

; 949  : {

  00000		 |$LN30@SPI_Read|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M46378|
  00004	e1a09002	 mov         r9, r2
  00008	e1a08001	 mov         r8, r1
  0000c	e1b06000	 movs        r6, r0

; 950  :     SPI_INSTANCE *pInstance = (SPI_INSTANCE*)context;
; 951  :     SPI_DEVICE *pDevice;
; 952  :     OMAP_MCSPI_CHANNEL_REGS *pSPIChannelRegs;
; 953  :     UCHAR* pData = (UCHAR*)pBuffer;
; 954  :     DWORD dwWordLen;
; 955  :     DWORD dwCount = 0;
; 956  :     DWORD dwWait;
; 957  : 
; 958  :     //RETAILMSG(1, (L"+SPI_Read(0x%08x, 0x%08x, 0x%08x)\r\n", context, pBuffer, size));
; 959  : 
; 960  :     // Check if we get correct context
; 961  :     if (pInstance == NULL || pInstance->cookie != SPI_INSTANCE_COOKIE) {

  00010	0a000043	 beq         |$LN14@SPI_Read|
  00014	e596e000	 ldr         lr, [r6]
  00018	e59f3114	 ldr         r3, [pc, #0x114]
  0001c	e15e0003	 cmp         lr, r3
  00020	1a00003f	 bne         |$LN14@SPI_Read|

; 966  :     }
; 967  : 
; 968  :     //  Call DMA function if DMA enabled
; 969  :     if( SpiDmaRxEnabled(pInstance) )

  00024	e596301c	 ldr         r3, [r6, #0x1C]
  00028	e3530000	 cmp         r3, #0
  0002c	0a000003	 beq         |$LN13@SPI_Read|

; 970  :     {
; 971  :         return SPI_DmaRead(context, pBuffer, size);

  00030	e1a00006	 mov         r0, r6
  00034	eb000000	 bl          SPI_DmaRead
  00038	e1a04000	 mov         r4, r0
  0003c	ea000039	 b           |$LN16@SPI_Read|
  00040		 |$LN13@SPI_Read|

; 972  :     }
; 973  : 
; 974  :     // Get pointers to registers
; 975  :     pDevice = pInstance->pDevice;
; 976  :     pSPIChannelRegs = pInstance->pSPIChannelRegs;
; 977  : 
; 978  :     // Get the word length of the data
; 979  :     dwWordLen = MCSPI_CHCONF_GET_WL(pInstance->config);

  00040	e596300c	 ldr         r3, [r6, #0xC]
  00044	e5967004	 ldr         r7, [r6, #4]

; 980  : 
; 981  :     // Get hardware
; 982  : 	WaitForSingleObject(pDevice->hControllerMutex, INFINITE);

  00048	e5965010	 ldr         r5, [r6, #0x10]
  0004c	e1a03a03	 mov         r3, r3, lsl #20
  00050	e597001c	 ldr         r0, [r7, #0x1C]
  00054	e1a03da3	 mov         r3, r3, lsr #27
  00058	e3e01000	 mvn         r1, #0
  0005c	e283b001	 add         r11, r3, #1
  00060	eb000000	 bl          WaitForSingleObject

; 983  :     
; 984  :     // Set this driver to Active Mode
; 985  :     SetSPIPower(pDevice, D0);

  00064	e3a01000	 mov         r1, #0
  00068	e1a00007	 mov         r0, r7
  0006c	eb000000	 bl          SetSPIPower

; 986  :     
; 987  :     // Enable the channel
; 988  : 	if (!pInstance->exclusiveAccess)

  00070	e5963014	 ldr         r3, [r6, #0x14]

; 989  :     	SETREG32(&pSPIChannelRegs->MCSPI_CHCTRL, MCSPI_CHCONT_EN);
; 990  : 
; 991  :     // Write out the data
; 992  :     for( dwCount = 0; dwCount < size; )

  00074	e3a04000	 mov         r4, #0
  00078	e3530000	 cmp         r3, #0
  0007c	05953008	 ldreq       r3, [r5, #8]
  00080	03833001	 orreq       r3, r3, #1
  00084	05853008	 streq       r3, [r5, #8]
  00088	e3590000	 cmp         r9, #0
  0008c	0a000019	 beq         |$LN10@SPI_Read|
  00090		 |$LL11@SPI_Read|

; 993  :     {
; 994  :         //  Wait for RX register to fill
; 995  :         dwWait = pDevice->timeout;

  00090	e5973028	 ldr         r3, [r7, #0x28]
  00094	e1b0a003	 movs        r10, r3

; 996  :         while(dwWait && !(INREG32(&pSPIChannelRegs->MCSPI_CHSTATUS) & MCSPI_CHSTAT_RX_FULL))

  00098	0a000016	 beq         |$LN10@SPI_Read|
  0009c		 |$LL9@SPI_Read|
  0009c	e5953004	 ldr         r3, [r5, #4]
  000a0	e3130001	 tst         r3, #1
  000a4	1a000003	 bne         |$LN8@SPI_Read|

; 997  :         {
; 998  :             StallExecution(1);

  000a8	e3a00001	 mov         r0, #1
  000ac	eb000000	 bl          StallExecution

; 999  :             dwWait--;

  000b0	e25aa001	 subs        r10, r10, #1
  000b4	1afffff8	 bne         |$LL9@SPI_Read|
  000b8		 |$LN8@SPI_Read|

; 1000 :         }
; 1001 : 
; 1002 :         //  Check if timeout occured
; 1003 :         if( dwWait == 0 )

  000b8	e35a0000	 cmp         r10, #0
  000bc	0a00000d	 beq         |$LN10@SPI_Read|

; 1004 :         {
; 1005 :             DEBUGMSG(ZONE_ERROR, (L"SPI_Read timeout\r\n"));
; 1006 : 
; 1007 : 	        // Disable the channel.
; 1008 : 			if (!pInstance->exclusiveAccess)
; 1009 : 	        	CLRREG32(&pSPIChannelRegs->MCSPI_CHCTRL, MCSPI_CHCONT_EN);
; 1010 : 
; 1011 :             // Set this driver to Suspend Mode
; 1012 :             SetSPIPower(pDevice, D4);
; 1013 : 
; 1014 :             // Release hardware
; 1015 : 			ReleaseMutex(pDevice->hControllerMutex);
; 1016 : 
; 1017 :             goto clean;
; 1018 :         }
; 1019 : 
; 1020 : 
; 1021 :         //  Read in data on byte/word/dword boundaries
; 1022 :         if( dwWordLen > 16 )

  000c0	e35b0010	 cmp         r11, #0x10

; 1023 :         {
; 1024 :             *(UINT32*)(&pData[dwCount]) = INREG32(&pSPIChannelRegs->MCSPI_RX);   

  000c4	85953010	 ldrhi       r3, [r5, #0x10]
  000c8	87843008	 strhi       r3, [r4, +r8]

; 1025 :             dwCount += sizeof(UINT32);

  000cc	82844004	 addhi       r4, r4, #4
  000d0	8a000006	 bhi         |$LN2@SPI_Read|

; 1026 :         }
; 1027 :         else if( dwWordLen > 8 )

  000d4	e35b0008	 cmp         r11, #8

; 1028 :         {
; 1029 :             *(UINT16*)(&pData[dwCount]) = (UINT16) INREG32(&pSPIChannelRegs->MCSPI_RX);   

  000d8	85953010	 ldrhi       r3, [r5, #0x10]
  000dc	818430b8	 strhih      r3, [r4, +r8]

; 1030 :             dwCount += sizeof(UINT16);
; 1031 :         }
; 1032 :         else
; 1033 :         {
; 1034 :             *(UINT8*)(&pData[dwCount]) = (UINT8) INREG32(&pSPIChannelRegs->MCSPI_RX);   

  000e0	95953010	 ldrls       r3, [r5, #0x10]
  000e4	82844002	 addhi       r4, r4, #2
  000e8	97c43008	 strlsb      r3, [r4, +r8]

; 1035 :             dwCount += sizeof(UINT8);

  000ec	92844001	 addls       r4, r4, #1
  000f0		 |$LN2@SPI_Read|

; 989  :     	SETREG32(&pSPIChannelRegs->MCSPI_CHCTRL, MCSPI_CHCONT_EN);
; 990  : 
; 991  :     // Write out the data
; 992  :     for( dwCount = 0; dwCount < size; )

  000f0	e1540009	 cmp         r4, r9
  000f4	3affffe5	 bcc         |$LL11@SPI_Read|
  000f8		 |$LN10@SPI_Read|

; 1036 :         }   
; 1037 :     }
; 1038 :     
; 1039 :     // Disable the channel.
; 1040 : 	if (!pInstance->exclusiveAccess)

  000f8	e5963014	 ldr         r3, [r6, #0x14]

; 1041 :     	CLRREG32(&pSPIChannelRegs->MCSPI_CHCTRL, MCSPI_CHCONT_EN);
; 1042 : 
; 1043 :     // Set this driver to Suspend Mode
; 1044 :     SetSPIPower(pDevice, D4);

  000fc	e3a01004	 mov         r1, #4
  00100	e1a00007	 mov         r0, r7
  00104	e3530000	 cmp         r3, #0
  00108	05953008	 ldreq       r3, [r5, #8]
  0010c	03c33001	 biceq       r3, r3, #1
  00110	05853008	 streq       r3, [r5, #8]
  00114	eb000000	 bl          SetSPIPower

; 1045 : 
; 1046 :     // Release hardware
; 1047 : 	ReleaseMutex(pDevice->hControllerMutex);

  00118	e597001c	 ldr         r0, [r7, #0x1C]
  0011c	eb000000	 bl          ReleaseMutex
  00120		 |$clean$44882|

; 1048 : 
; 1049 : clean:
; 1050 :     //RETAILMSG(1, (L"-SPI_Read(rc = %d)\r\n", dwCount));
; 1051 : 	return dwCount;

  00120	ea000000	 b           |$LN16@SPI_Read|
  00124		 |$LN14@SPI_Read|

; 962  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_Read: "
; 963  :             L"Incorrect context paramer\r\n"
; 964  :         ));
; 965  :         return 0;

  00124	e3a04000	 mov         r4, #0
  00128		 |$LN16@SPI_Read|

; 1052 : }

  00128	e1a00004	 mov         r0, r4
  0012c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00130	e12fff1e	 bx          lr
  00134		 |$LN31@SPI_Read|
  00134		 |$LN32@SPI_Read|
  00134	73706949	 DCD         0x73706949
  00138		 |$M46379|

			 ENDP  ; |SPI_Read|

	EXPORT	|SPI_Write|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\spi\spi_priv.h

  00000			 AREA	 |.pdata|, PDATA
|$T46414| DCD	|$LN31@SPI_Write|
	DCD	0x40004c01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\spi\spi.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_Write| PROC

; 1199 : {

  00000		 |$LN31@SPI_Write|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M46411|
  00004	e1a09002	 mov         r9, r2
  00008	e1a08001	 mov         r8, r1
  0000c	e1b06000	 movs        r6, r0

; 1200 :     SPI_INSTANCE *pInstance = (SPI_INSTANCE*)context;
; 1201 :     SPI_DEVICE *pDevice;
; 1202 :     OMAP_MCSPI_CHANNEL_REGS *pSPIChannelRegs;
; 1203 :     UCHAR* pData = (UCHAR*)pBuffer;
; 1204 :     DWORD dwWordLen;
; 1205 :     DWORD dwCount = 0;
; 1206 :     DWORD dwWait;
; 1207 : 
; 1208 :     //RETAILMSG(1, (L"+SPI_Write(0x%08x, 0x%08x, 0x%08x)\r\n", context, pBuffer, size));
; 1209 : 
; 1210 :     // Check if we get correct context
; 1211 :     if (pInstance == NULL || pInstance->cookie != SPI_INSTANCE_COOKIE) {

  00010	0a000041	 beq         |$LN14@SPI_Write|
  00014	e596e000	 ldr         lr, [r6]
  00018	e59f310c	 ldr         r3, [pc, #0x10C]
  0001c	e15e0003	 cmp         lr, r3
  00020	1a00003d	 bne         |$LN14@SPI_Write|

; 1216 :     }
; 1217 : 
; 1218 :     //  Call DMA function if DMA enabled
; 1219 :     if( SpiDmaTxEnabled(pInstance) )

  00024	e5963018	 ldr         r3, [r6, #0x18]
  00028	e3530000	 cmp         r3, #0
  0002c	0a000003	 beq         |$LN13@SPI_Write|

; 1220 :     {
; 1221 :         return SPI_DmaWrite(context, pBuffer, size);

  00030	e1a00006	 mov         r0, r6
  00034	eb000000	 bl          SPI_DmaWrite
  00038	e1a04000	 mov         r4, r0
  0003c	ea000037	 b           |$LN16@SPI_Write|
  00040		 |$LN13@SPI_Write|

; 1222 :     }
; 1223 : 
; 1224 :     // Get pointers to registers
; 1225 :     pDevice = pInstance->pDevice;
; 1226 :     pSPIChannelRegs = pInstance->pSPIChannelRegs;
; 1227 : 
; 1228 : 
; 1229 :     // Get the word length of the data
; 1230 :     dwWordLen = MCSPI_CHCONF_GET_WL(pInstance->config);

  00040	e596300c	 ldr         r3, [r6, #0xC]
  00044	e5967004	 ldr         r7, [r6, #4]

; 1231 : 
; 1232 :     // Get hardware
; 1233 : 	WaitForSingleObject(pDevice->hControllerMutex, INFINITE);

  00048	e5965010	 ldr         r5, [r6, #0x10]
  0004c	e1a03a03	 mov         r3, r3, lsl #20
  00050	e597001c	 ldr         r0, [r7, #0x1C]
  00054	e1a03da3	 mov         r3, r3, lsr #27
  00058	e3e01000	 mvn         r1, #0
  0005c	e283b001	 add         r11, r3, #1
  00060	eb000000	 bl          WaitForSingleObject

; 1234 :     
; 1235 :     // Set this driver to Active Mode
; 1236 :     SetSPIPower(pDevice, D0);

  00064	e3a01000	 mov         r1, #0
  00068	e1a00007	 mov         r0, r7
  0006c	eb000000	 bl          SetSPIPower

; 1237 :     
; 1238 :     // Enable the channel
; 1239 : 	if (!pInstance->exclusiveAccess)

  00070	e5963014	 ldr         r3, [r6, #0x14]

; 1240 :     	SETREG32(&pSPIChannelRegs->MCSPI_CHCTRL, MCSPI_CHCONT_EN);
; 1241 : 
; 1242 :     // Write out the data
; 1243 :     for( dwCount = 0; dwCount < size; )

  00074	e3a04000	 mov         r4, #0
  00078	e3530000	 cmp         r3, #0
  0007c	05953008	 ldreq       r3, [r5, #8]
  00080	03833001	 orreq       r3, r3, #1
  00084	05853008	 streq       r3, [r5, #8]
  00088	e3590000	 cmp         r9, #0
  0008c	0a000017	 beq         |$LN10@SPI_Write|
  00090		 |$LL11@SPI_Write|

; 1244 :     {
; 1245 :         //  Write out data on byte/word/dword boundaries
; 1246 :         if( dwWordLen > 16 )

  00090	e35b0010	 cmp         r11, #0x10

; 1247 :         {
; 1248 :             OUTREG32(&pSPIChannelRegs->MCSPI_TX, *(UINT32*)(&pData[dwCount]));   

  00094	87943008	 ldrhi       r3, [r4, +r8]

; 1249 :             dwCount += sizeof(UINT32);

  00098	82844004	 addhi       r4, r4, #4
  0009c	8a000004	 bhi         |$LN27@SPI_Write|

; 1250 :         }
; 1251 :         else if( dwWordLen > 8 )

  000a0	e35b0008	 cmp         r11, #8

; 1252 :         {
; 1253 :             OUTREG32(&pSPIChannelRegs->MCSPI_TX, *(UINT16*)(&pData[dwCount]));   

  000a4	819430b8	 ldrhih      r3, [r4, +r8]

; 1254 :             dwCount += sizeof(UINT16);

  000a8	82844002	 addhi       r4, r4, #2

; 1255 :         }
; 1256 :         else
; 1257 :         {
; 1258 :             OUTREG32(&pSPIChannelRegs->MCSPI_TX, *(UINT8*)(&pData[dwCount]));   

  000ac	97d43008	 ldrlsb      r3, [r4, +r8]

; 1259 :             dwCount += sizeof(UINT8);

  000b0	92844001	 addls       r4, r4, #1
  000b4		 |$LN27@SPI_Write|
  000b4	e585300c	 str         r3, [r5, #0xC]

; 1260 :         }   
; 1261 : 
; 1262 :         //  Wait for TX register to empty out
; 1263 :         dwWait = pDevice->timeout;

  000b8	e5973028	 ldr         r3, [r7, #0x28]
  000bc	e1b0a003	 movs        r10, r3

; 1264 :         while(dwWait && !(INREG32(&pSPIChannelRegs->MCSPI_CHSTATUS) & MCSPI_CHSTAT_TX_EMPTY))

  000c0	0a00000a	 beq         |$LN10@SPI_Write|
  000c4		 |$LL5@SPI_Write|
  000c4	e5953004	 ldr         r3, [r5, #4]
  000c8	e3130002	 tst         r3, #2
  000cc	1a000003	 bne         |$LN4@SPI_Write|

; 1265 :         {
; 1266 :             StallExecution(1);

  000d0	e3a00001	 mov         r0, #1
  000d4	eb000000	 bl          StallExecution

; 1267 :             dwWait--;

  000d8	e25aa001	 subs        r10, r10, #1
  000dc	1afffff8	 bne         |$LL5@SPI_Write|
  000e0		 |$LN4@SPI_Write|

; 1268 :         }
; 1269 : 
; 1270 :         //  Check if timeout occured
; 1271 :         if( dwWait == 0 )

  000e0	e35a0000	 cmp         r10, #0
  000e4	0a000001	 beq         |$LN10@SPI_Write|

; 1240 :     	SETREG32(&pSPIChannelRegs->MCSPI_CHCTRL, MCSPI_CHCONT_EN);
; 1241 : 
; 1242 :     // Write out the data
; 1243 :     for( dwCount = 0; dwCount < size; )

  000e8	e1540009	 cmp         r4, r9
  000ec	3affffe7	 bcc         |$LL11@SPI_Write|
  000f0		 |$LN10@SPI_Write|

; 1272 :         {
; 1273 :             DEBUGMSG(ZONE_ERROR, (L"SPI_Write timeout\r\n"));
; 1274 : 
; 1275 : 	        // Disable the channel.
; 1276 : 			if (!pInstance->exclusiveAccess)
; 1277 : 	        	CLRREG32(&pSPIChannelRegs->MCSPI_CHCTRL, MCSPI_CHCONT_EN);
; 1278 : 
; 1279 :             // Set this driver to Suspend Mode
; 1280 :             SetSPIPower(pDevice, D4);
; 1281 : 
; 1282 :             // Release hardware
; 1283 : 			ReleaseMutex(pDevice->hControllerMutex);
; 1284 : 
; 1285 :             goto clean;
; 1286 :         }
; 1287 :     }
; 1288 :     
; 1289 :     // Disable the channel.
; 1290 : 	if (!pInstance->exclusiveAccess)

  000f0	e5963014	 ldr         r3, [r6, #0x14]

; 1291 :     	CLRREG32(&pSPIChannelRegs->MCSPI_CHCTRL, MCSPI_CHCONT_EN);
; 1292 : 
; 1293 :     // Set this driver to Suspend Mode
; 1294 :     SetSPIPower(pDevice, D4);

  000f4	e3a01004	 mov         r1, #4
  000f8	e1a00007	 mov         r0, r7
  000fc	e3530000	 cmp         r3, #0
  00100	05953008	 ldreq       r3, [r5, #8]
  00104	03c33001	 biceq       r3, r3, #1
  00108	05853008	 streq       r3, [r5, #8]
  0010c	eb000000	 bl          SetSPIPower

; 1295 : 
; 1296 :     // Release hardware
; 1297 : 	ReleaseMutex(pDevice->hControllerMutex);

  00110	e597001c	 ldr         r0, [r7, #0x1C]
  00114	eb000000	 bl          ReleaseMutex
  00118		 |$clean$45003|

; 1298 : 
; 1299 : 
; 1300 : clean:
; 1301 :     //RETAILMSG(1, (L"-SPI_Write(rc = %d)\r\n", dwCount));
; 1302 : 	return dwCount;

  00118	ea000000	 b           |$LN16@SPI_Write|
  0011c		 |$LN14@SPI_Write|

; 1212 :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_Write: "
; 1213 :             L"Incorrect context paramer\r\n"
; 1214 :         ));
; 1215 :         return 0;

  0011c	e3a04000	 mov         r4, #0
  00120		 |$LN16@SPI_Write|

; 1303 : }

  00120	e1a00004	 mov         r0, r4
  00124	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00128	e12fff1e	 bx          lr
  0012c		 |$LN32@SPI_Write|
  0012c		 |$LN33@SPI_Write|
  0012c	73706949	 DCD         0x73706949
  00130		 |$M46412|

			 ENDP  ; |SPI_Write|

	EXPORT	|SPI_IOControl|
	EXPORT	|??_C@_1DC@IGLIIDFJ@?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAs?$AAp?$AAi?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DC@NKOBOHOD@?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAs?$AAp?$AAi?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EG@CDHLAJIG@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAx?$AAx?$AAx?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA?4?$AA8?$AAX?$AA?$CJ?$AA?5@| [ DATA ] ; `string'
	IMPORT	|CeSafeCopyMemory|
	IMPORT	|SetLastError|
	IMPORT	|GetCallerProcess|
	IMPORT	|__C_specific_handler|
	IMPORT	|memcmp|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T46529| DCD	|$LN130@SPI_IOCont|
	DCD	0xc0016404

  00000			 AREA	 |.pdata|, PDATA
|$T46531| DCD	|$LN74@SPI_IOCont|
	DCD	0x40000301

  00000			 AREA	 |.pdata|, PDATA
|$T46533| DCD	|$LN95@SPI_IOCont|
	DCD	0x40000301

  00000			 AREA	 |.pdata|, PDATA
|$T46535| DCD	|$LN88@SPI_IOCont|
	DCD	0x40000301

  00000			 AREA	 |.pdata|, PDATA
|$T46537| DCD	|$LN81@SPI_IOCont|
	DCD	0x40002001

  00000			 AREA	 |.xdata|, DATA
|$T46527| DCD	0x4
	DCD	|$LN78@SPI_IOCont|
	DCD	|$LN79@SPI_IOCont|
	DCD	|$LN74@SPI_IOCont|
	DCD	|$LN75@SPI_IOCont|
	DCD	|$LN99@SPI_IOCont|
	DCD	|$LN100@SPI_IOCont|
	DCD	|$LN95@SPI_IOCont|
	DCD	|$LN96@SPI_IOCont|
	DCD	|$LN92@SPI_IOCont|
	DCD	|$LN93@SPI_IOCont|
	DCD	|$LN88@SPI_IOCont|
	DCD	|$LN89@SPI_IOCont|
	DCD	|$LN85@SPI_IOCont|
	DCD	|$LN86@SPI_IOCont|
	DCD	|$LN81@SPI_IOCont|
	DCD	|$LN82@SPI_IOCont|

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DC@IGLIIDFJ@?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAs?$AAp?$AAi?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@| DCB "e"
	DCB	0x0, "x", 0x0, "c", 0x0, "e", 0x0, "p", 0x0, "t", 0x0, "i"
	DCB	0x0, "o", 0x0, "n", 0x0, " ", 0x0, "i", 0x0, "n", 0x0, " "
	DCB	0x0, "s", 0x0, "p", 0x0, "i", 0x0, " ", 0x0, "i", 0x0, "o"
	DCB	0x0, "c", 0x0, "t", 0x0, "l", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DC@NKOBOHOD@?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAs?$AAp?$AAi?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@| DCB "E"
	DCB	0x0, "x", 0x0, "c", 0x0, "e", 0x0, "p", 0x0, "t", 0x0, "i"
	DCB	0x0, "o", 0x0, "n", 0x0, " ", 0x0, "i", 0x0, "n", 0x0, " "
	DCB	0x0, "s", 0x0, "p", 0x0, "i", 0x0, " ", 0x0, "i", 0x0, "o"
	DCB	0x0, "c", 0x0, "t", 0x0, "l", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EG@CDHLAJIG@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAx?$AAx?$AAx?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA?4?$AA8?$AAX?$AA?$CJ?$AA?5@| DCB "S"
	DCB	0x0, "P", 0x0, "I", 0x0, ":", 0x0, " ", 0x0, "U", 0x0, "n"
	DCB	0x0, "k", 0x0, "n", 0x0, "o", 0x0, "w", 0x0, "n", 0x0, " "
	DCB	0x0, "I", 0x0, "O", 0x0, "C", 0x0, "T", 0x0, "L", 0x0, "_"
	DCB	0x0, "x", 0x0, "x", 0x0, "x", 0x0, "(", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, ".", 0x0, "8", 0x0, "X", 0x0, ")"
	DCB	0x0, " ", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\spi\spi.c

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T46527|

  00008		 |SPI_IOControl| PROC

; 2121 : ) {

  00008		 |$LN130@SPI_IOCont|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d5ff0	 stmdb       sp!, {r4 - r12, lr}
  00010	e28db028	 add         r11, sp, #0x28
  00014	e24dd038	 sub         sp, sp, #0x38
  00018		 |$LN128@SPI_IOCont|
  00018	e1a08003	 mov         r8, r3
  0001c	e1a06002	 mov         r6, r2
  00020	e1a05001	 mov         r5, r1
  00024	e1b07000	 movs        r7, r0
  00028	e50b705c	 str         r7, [r11, #-0x5C]

; 2122 :     BOOL bRetVal = FALSE;

  0002c	e3a02000	 mov         r2, #0
  00030	e50b2060	 str         r2, [r11, #-0x60]

; 2123 :     SPI_DEVICE *pDevice = NULL;
; 2124 :     SPI_INSTANCE *pInstance = (SPI_INSTANCE*)context;
; 2125 :     DEVICE_IFC_SPI ifc;
; 2126 :     IOCTL_SPI_CONFIGURE_IN *pConfig;
; 2127 : 
; 2128 :     DEBUGMSG(ZONE_FUNCTION, (
; 2129 :         L"+SPI_IOControl(0x%08x, 0x%08x, 0x%08x, %d, 0x%08x, %d, 0x%08x)\r\n",
; 2130 :         context, dwCode, pInBuffer, inSize, pOutBuffer, outSize, pOutSize
; 2131 :     ));
; 2132 : 
; 2133 :     // Check if we get correct context
; 2134 :     if (pInstance == NULL || pInstance->cookie != SPI_INSTANCE_COOKIE) {

  00034	0a000153	 beq         |$clean$45376|
  00038	e5974000	 ldr         r4, [r7]
  0003c	e59fe5f4	 ldr         lr, [pc, #0x5F4]
  00040	e154000e	 cmp         r4, lr
  00044	1a00014f	 bne         |$clean$45376|

; 2135 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_IOControl: "
; 2136 :             L"Incorrect context paramer\r\n"
; 2137 :         ));
; 2138 :         goto clean;
; 2139 :     }
; 2140 :     
; 2141 :     //Get Device
; 2142 :     pDevice = pInstance->pDevice;
; 2143 : 
; 2144 :     switch (dwCode) {

  00048	e59f35e4	 ldr         r3, [pc, #0x5E4]
  0004c	e1550003	 cmp         r5, r3
  00050	e5974004	 ldr         r4, [r7, #4]
  00054	8a0000a4	 bhi         |$LN71@SPI_IOCont|
  00058	0a0000a0	 beq         |$LN26@SPI_IOCont|
  0005c	e59f35cc	 ldr         r3, [pc, #0x5CC]
  00060	e1550003	 cmp         r5, r3
  00064	8a000085	 bhi         |$LN72@SPI_IOCont|
  00068	0a000078	 beq         |$LN35@SPI_IOCont|
  0006c	e3a03822	 mov         r3, #0x22, 16
  00070	e3833b01	 orr         r3, r3, #1, 22
  00074	e1550003	 cmp         r5, r3
  00078	0a000036	 beq         |$LN56@SPI_IOCont|
  0007c	e3a03822	 mov         r3, #0x22, 16
  00080	e3833b02	 orr         r3, r3, #2, 22
  00084	e1550003	 cmp         r5, r3
  00088	0a000025	 beq         |$LN47@SPI_IOCont|
  0008c	e59f3598	 ldr         r3, [pc, #0x598]
  00090	e1550003	 cmp         r5, r3
  00094	0a000012	 beq         |$LN43@SPI_IOCont|
  00098	e59f3588	 ldr         r3, [pc, #0x588]
  0009c	e1550003	 cmp         r5, r3
  000a0	1a0000a9	 bne         |$LN1@SPI_IOCont|

; 2210 : 
; 2211 :     case IOCTL_SPI_ASYNC_WRITEREAD:
; 2212 :         if (pOutSize != NULL) *pOutSize = inSize;

  000a4	e59b3008	 ldr         r3, [r11, #8]
  000a8	e3530000	 cmp         r3, #0
  000ac	15838000	 strne       r8, [r3]

; 2213 :         if (pInBuffer == NULL || pOutBuffer == NULL || inSize != outSize ) {

  000b0	e3560000	 cmp         r6, #0
  000b4	0a000063	 beq         |$LN53@SPI_IOCont|
  000b8	e59b3000	 ldr         r3, [r11]
  000bc	e3530000	 cmp         r3, #0
  000c0	0a000060	 beq         |$LN53@SPI_IOCont|
  000c4	e59b2004	 ldr         r2, [r11, #4]
  000c8	e1580002	 cmp         r8, r2
  000cc	1a00005d	 bne         |$LN53@SPI_IOCont|

; 2214 :             SetLastError(ERROR_INVALID_PARAMETER);
; 2215 :             break;
; 2216 :         }
; 2217 : 
; 2218 :         bRetVal = SPI_AsyncWriteRead(context, inSize, pInBuffer, pOutBuffer);

  000d0	e1a02006	 mov         r2, r6
  000d4	e1a01008	 mov         r1, r8
  000d8	e1a00007	 mov         r0, r7
  000dc	eb000000	 bl          SPI_AsyncWriteRead

; 2219 :         break;

  000e0	ea000127	 b           |$LN125@SPI_IOCont|
  000e4		 |$LN43@SPI_IOCont|

; 2200 :     
; 2201 :     case IOCTL_SPI_WRITEREAD:
; 2202 :         if (pOutSize != NULL) *pOutSize = inSize;

  000e4	e59b3008	 ldr         r3, [r11, #8]
  000e8	e3530000	 cmp         r3, #0
  000ec	15838000	 strne       r8, [r3]

; 2203 :         if (pInBuffer == NULL || pOutBuffer == NULL || inSize != outSize ) {

  000f0	e3560000	 cmp         r6, #0
  000f4	0a000053	 beq         |$LN53@SPI_IOCont|
  000f8	e59b2000	 ldr         r2, [r11]
  000fc	e3520000	 cmp         r2, #0
  00100	0a000050	 beq         |$LN53@SPI_IOCont|
  00104	e59b3004	 ldr         r3, [r11, #4]
  00108	e1580003	 cmp         r8, r3
  0010c	1a00004d	 bne         |$LN53@SPI_IOCont|

; 2204 :             SetLastError(ERROR_INVALID_PARAMETER);
; 2205 :             break;
; 2206 :         }
; 2207 : 
; 2208 :         bRetVal = SPI_WriteRead(context, inSize, pOutBuffer, pInBuffer);

  00110	e1a03006	 mov         r3, r6
  00114	e1a01008	 mov         r1, r8
  00118	e1a00007	 mov         r0, r7
  0011c	eb000000	 bl          SPI_WriteRead

; 2209 :         break;

  00120	ea000117	 b           |$LN125@SPI_IOCont|
  00124		 |$LN47@SPI_IOCont|

; 2184 :             break;
; 2185 :         }
; 2186 :         SetLastError(ERROR_INVALID_PARAMETER);
; 2187 :         break;
; 2188 :         
; 2189 :     case IOCTL_SPI_CONFIGURE:
; 2190 :         if (pOutSize != NULL) *pOutSize = sizeof(DWORD);

  00124	e59b3008	 ldr         r3, [r11, #8]
  00128	e3530000	 cmp         r3, #0
  0012c	13a02004	 movne       r2, #4
  00130	15832000	 strne       r2, [r3]

; 2191 :         if (pInBuffer == NULL || inSize < sizeof(IOCTL_SPI_CONFIGURE_IN)) {

  00134	e3560000	 cmp         r6, #0
  00138	0a000042	 beq         |$LN53@SPI_IOCont|
  0013c	e3580008	 cmp         r8, #8
  00140	3a000040	 bcc         |$LN53@SPI_IOCont|

; 2192 :             SetLastError(ERROR_INVALID_PARAMETER);
; 2193 :             break;
; 2194 :         }
; 2195 : 
; 2196 :         pConfig = (IOCTL_SPI_CONFIGURE_IN*) pInBuffer;
; 2197 : 
; 2198 :         bRetVal = SPI_Configure(context, pConfig->address, pConfig->config);

  00144	e5962004	 ldr         r2, [r6, #4]
  00148	e5961000	 ldr         r1, [r6]
  0014c	e1a00007	 mov         r0, r7
  00150	eb000000	 bl          SPI_Configure

; 2199 :         break;

  00154	ea00010a	 b           |$LN125@SPI_IOCont|
  00158		 |$LN56@SPI_IOCont|

; 2145 :     case IOCTL_DDK_GET_DRIVER_IFC:
; 2146 :         // We can give interface only to our peer in device process
; 2147 :         if (GetCurrentProcessId() != (DWORD)GetCallerProcess()) {

  00158	e3a0000c	 mov         r0, #0xC
  0015c	eb000000	 bl          __GetUserKData
  00160	e1a04000	 mov         r4, r0
  00164	eb000000	 bl          GetCallerProcess
  00168	e1540000	 cmp         r4, r0
  0016c	0a000003	 beq         |$LN55@SPI_IOCont|

; 2148 :             DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_IOControl: "
; 2149 :                 L"IOCTL_DDK_GET_DRIVER_IFC can be called only from "
; 2150 :                 L"device process (caller process id 0x%08x)\r\n",
; 2151 :                 GetCallerProcess()
; 2152 :             ));
; 2153 :             SetLastError(ERROR_ACCESS_DENIED);

  00170	e3a00005	 mov         r0, #5
  00174		 |$LN126@SPI_IOCont|
  00174	eb000000	 bl          SetLastError

; 2154 :             goto clean;

  00178	e3a02000	 mov         r2, #0
  0017c	ea000101	 b           |$clean$45376|
  00180		 |$LN55@SPI_IOCont|

; 2155 :         }
; 2156 :         // Check input parameters
; 2157 :         if (pInBuffer == NULL || inSize < sizeof(GUID)) {

  00180	e3560000	 cmp         r6, #0
  00184	0a00002f	 beq         |$LN53@SPI_IOCont|
  00188	e3580010	 cmp         r8, #0x10
  0018c	3a00002d	 bcc         |$LN53@SPI_IOCont|

; 2160 :         }
; 2161 :         if (IsEqualGUID(pInBuffer, &DEVICE_IFC_SPI_GUID)) {

  00190	e59f148c	 ldr         r1, [pc, #0x48C]
  00194	e3a02010	 mov         r2, #0x10
  00198	e1a00006	 mov         r0, r6
  0019c	eb000000	 bl          memcmp
  001a0	e3500000	 cmp         r0, #0
  001a4	1a000027	 bne         |$LN53@SPI_IOCont|

; 2162 :             if (pOutSize != NULL) *pOutSize = sizeof(DEVICE_IFC_SPI);

  001a8	e59b3008	 ldr         r3, [r11, #8]
  001ac	e3530000	 cmp         r3, #0
  001b0	13a02030	 movne       r2, #0x30
  001b4	15832000	 strne       r2, [r3]

; 2163 :             if (pOutBuffer == NULL || outSize < sizeof(DEVICE_IFC_SPI)) {

  001b8	e59b0000	 ldr         r0, [r11]
  001bc	e3500000	 cmp         r0, #0
  001c0	0a000020	 beq         |$LN53@SPI_IOCont|
  001c4	e59b3004	 ldr         r3, [r11, #4]
  001c8	e3530030	 cmp         r3, #0x30
  001cc	3a00001d	 bcc         |$LN53@SPI_IOCont|

; 2164 :                 SetLastError(ERROR_INVALID_PARAMETER);
; 2165 :                 break;
; 2166 :             }
; 2167 :             ifc.context = context;
; 2168 :             ifc.pfnConfigure = SPI_Configure;

  001d0	e59f3448	 ldr         r3, [pc, #0x448]

; 2169 :             ifc.pfnRead = SPI_Read;

  001d4	e59f2440	 ldr         r2, [pc, #0x440]

; 2170 :             ifc.pfnWrite = SPI_Write;

  001d8	e59f1438	 ldr         r1, [pc, #0x438]

; 2171 :             ifc.pfnWriteRead = SPI_WriteRead;

  001dc	e59fe430	 ldr         lr, [pc, #0x430]

; 2172 :             ifc.pfnAsyncWriteRead = SPI_AsyncWriteRead;

  001e0	e59f4428	 ldr         r4, [pc, #0x428]

; 2173 :             ifc.pfnWaitForAsyncWriteReadComplete = SPI_WaitForAsyncWriteReadComplete;

  001e4	e59f5420	 ldr         r5, [pc, #0x420]

; 2174 :             ifc.pfnSetSlaveMode = SPI_SetSlaveMode;

  001e8	e59f6418	 ldr         r6, [pc, #0x418]

; 2175 :             ifc.pfnLockController = SPI_LockController;

  001ec	e59f7410	 ldr         r7, [pc, #0x410]

; 2176 :             ifc.pfnUnlockController = SPI_UnlockController;

  001f0	e59f8408	 ldr         r8, [pc, #0x408]

; 2177 :             ifc.pfnEnableChannel = SPI_EnableChannel;

  001f4	e59f9400	 ldr         r9, [pc, #0x400]

; 2178 :             ifc.pfnDisableChannel = SPI_DisableChannel;

  001f8	e59fa3f8	 ldr         r10, [pc, #0x3F8]
  001fc	e50b3054	 str         r3, [r11, #-0x54]
  00200	e50b2050	 str         r2, [r11, #-0x50]
  00204	e50b104c	 str         r1, [r11, #-0x4C]
  00208	e50be048	 str         lr, [r11, #-0x48]
  0020c	e50b4034	 str         r4, [r11, #-0x34]
  00210	e50b5030	 str         r5, [r11, #-0x30]
  00214	e50b602c	 str         r6, [r11, #-0x2C]
  00218	e50b7044	 str         r7, [r11, #-0x44]
  0021c	e50b8040	 str         r8, [r11, #-0x40]
  00220	e50b903c	 str         r9, [r11, #-0x3C]
  00224	e50ba038	 str         r10, [r11, #-0x38]

; 2179 :             if (!CeSafeCopyMemory(pOutBuffer, &ifc, sizeof(DEVICE_IFC_SPI))) {

  00228	e3a02030	 mov         r2, #0x30
  0022c	e24b1058	 sub         r1, r11, #0x58
  00230	e51b305c	 ldr         r3, [r11, #-0x5C]
  00234	e50b3058	 str         r3, [r11, #-0x58]
  00238	eb000000	 bl          CeSafeCopyMemory
  0023c	e3500000	 cmp         r0, #0

; 2182 :             }
; 2183 :             bRetVal = TRUE;

  00240	13a02001	 movne       r2, #1

; 2180 :                 SetLastError(ERROR_INVALID_PARAMETER);
; 2181 :                 break;

  00244	1a0000cf	 bne         |$clean$45376|
  00248		 |$LN53@SPI_IOCont|

; 2158 :             SetLastError(ERROR_INVALID_PARAMETER);

  00248	e3a00057	 mov         r0, #0x57

; 2159 :             break;

  0024c	eaffffc8	 b           |$LN126@SPI_IOCont|
  00250		 |$LN35@SPI_IOCont|

; 2220 : 
; 2221 :     case IOCTL_SPI_ASYNC_WRITEREAD_COMPLETE:
; 2222 :         if (pOutSize != NULL) *pOutSize = inSize;

  00250	e59b3008	 ldr         r3, [r11, #8]
  00254	e3530000	 cmp         r3, #0
  00258	15838000	 strne       r8, [r3]

; 2223 :         if (pOutBuffer == NULL || outSize == 0) {

  0025c	e59b2000	 ldr         r2, [r11]
  00260	e3520000	 cmp         r2, #0
  00264	0afffff7	 beq         |$LN53@SPI_IOCont|
  00268	e59b1004	 ldr         r1, [r11, #4]
  0026c	e3510000	 cmp         r1, #0
  00270	0afffff4	 beq         |$LN53@SPI_IOCont|

; 2226 :         }
; 2227 : 
; 2228 :         bRetVal = SPI_WaitForAsyncWriteReadComplete(context, outSize, pOutBuffer);

  00274	e1a00007	 mov         r0, r7
  00278	eb000000	 bl          SPI_WaitForAsyncWriteReadComplete

; 2229 :         break;

  0027c	ea0000c0	 b           |$LN125@SPI_IOCont|
  00280		 |$LN72@SPI_IOCont|

; 2224 :             SetLastError(ERROR_INVALID_PARAMETER);
; 2225 :             break;

  00280	e3a03822	 mov         r3, #0x22, 16

; 2135 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_IOControl: "
; 2136 :             L"Incorrect context paramer\r\n"
; 2137 :         ));
; 2138 :         goto clean;
; 2139 :     }
; 2140 :     
; 2141 :     //Get Device
; 2142 :     pDevice = pInstance->pDevice;
; 2143 : 
; 2144 :     switch (dwCode) {

  00284	e3833e81	 orr         r3, r3, #0x81, 28
  00288	e1550003	 cmp         r5, r3
  0028c	0a000010	 beq         |$LN31@SPI_IOCont|
  00290	e59f335c	 ldr         r3, [pc, #0x35C]
  00294	e1550003	 cmp         r5, r3
  00298	0a000005	 beq         |$LN30@SPI_IOCont|
  0029c	e59f334c	 ldr         r3, [pc, #0x34C]
  002a0	e1550003	 cmp         r5, r3
  002a4	1a000028	 bne         |$LN1@SPI_IOCont|

; 2242 : 
; 2243 :     case IOCTL_SPI_UNLOCK_CTRL: 
; 2244 :         bRetVal = SPI_UnlockController(context);

  002a8	e1a00007	 mov         r0, r7
  002ac	eb000000	 bl          SPI_UnlockController

; 2245 :         break;

  002b0	ea0000b3	 b           |$LN125@SPI_IOCont|
  002b4		 |$LN30@SPI_IOCont|

; 2234 : 
; 2235 :     case IOCTL_SPI_LOCK_CTRL: 
; 2236 :         if (pInBuffer == NULL || inSize != sizeof(DWORD)) {

  002b4	e3560000	 cmp         r6, #0
  002b8	0affffe2	 beq         |$LN53@SPI_IOCont|
  002bc	e3580004	 cmp         r8, #4
  002c0	1affffe0	 bne         |$LN53@SPI_IOCont|

; 2237 :             SetLastError(ERROR_INVALID_PARAMETER);
; 2238 :             break;
; 2239 :         }
; 2240 :         bRetVal = SPI_LockController(context,*(DWORD*)pInBuffer);

  002c4	e5961000	 ldr         r1, [r6]
  002c8	e1a00007	 mov         r0, r7
  002cc	eb000000	 bl          SPI_LockController

; 2241 :         break;

  002d0	ea0000ab	 b           |$LN125@SPI_IOCont|
  002d4		 |$LN31@SPI_IOCont|

; 2230 : 
; 2231 :     case IOCTL_SPI_SET_SLAVEMODE:
; 2232 :         bRetVal = SPI_SetSlaveMode(context);

  002d4	e1a00007	 mov         r0, r7
  002d8	eb000000	 bl          SPI_SetSlaveMode

; 2233 :         break;

  002dc	ea0000a8	 b           |$LN125@SPI_IOCont|
  002e0		 |$LN26@SPI_IOCont|

; 2246 :     case IOCTL_SPI_ENABLE_CHANNEL: 
; 2247 :         bRetVal = SPI_EnableChannel(context);

  002e0	e1a00007	 mov         r0, r7
  002e4	eb000000	 bl          SPI_EnableChannel

; 2248 :         break;

  002e8	ea0000a5	 b           |$LN125@SPI_IOCont|
  002ec		 |$LN71@SPI_IOCont|
  002ec	e3a03822	 mov         r3, #0x22, 16

; 2135 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_IOControl: "
; 2136 :             L"Incorrect context paramer\r\n"
; 2137 :         ));
; 2138 :         goto clean;
; 2139 :     }
; 2140 :     
; 2141 :     //Get Device
; 2142 :     pDevice = pInstance->pDevice;
; 2143 : 
; 2144 :     switch (dwCode) {

  002f0	e3833e82	 orr         r3, r3, #0x82, 28
  002f4	e1550003	 cmp         r5, r3
  002f8	0a00009f	 beq         |$LN25@SPI_IOCont|
  002fc	e3a03832	 mov         r3, #0x32, 16
  00300	e3833a01	 orr         r3, r3, #1, 20
  00304	e1550003	 cmp         r5, r3
  00308	0a00007e	 beq         |$LN16@SPI_IOCont|
  0030c	e59f32d8	 ldr         r3, [pc, #0x2D8]
  00310	e1550003	 cmp         r5, r3
  00314	0a000069	 beq         |$LN4@SPI_IOCont|
  00318	e59f32c8	 ldr         r3, [pc, #0x2C8]
  0031c	e1550003	 cmp         r5, r3
  00320	0a00004d	 beq         |$LN9@SPI_IOCont|
  00324	e59f32b8	 ldr         r3, [pc, #0x2B8]
  00328	e1550003	 cmp         r5, r3
  0032c	0a000038	 beq         |$LN13@SPI_IOCont|
  00330	e3a03112	 mov         r3, #0x12, 2
  00334	e3833b82	 orr         r3, r3, #0x82, 22
  00338	e1550003	 cmp         r5, r3
  0033c	0a000013	 beq         |$LN24@SPI_IOCont|
  00340	e59f3298	 ldr         r3, [pc, #0x298]
  00344	e1550003	 cmp         r5, r3
  00348	0a000009	 beq         |$LN19@SPI_IOCont|
  0034c		 |$LN1@SPI_IOCont|

; 2388 :                 }
; 2389 :             }     
; 2390 :         break;
; 2391 :   
; 2392 :     default:
; 2393 :         ERRORMSG(1, (TEXT("SPI: Unknown IOCTL_xxx(0x%0.8X) \r\n"), dwCode));

  0034c	e59f1288	 ldr         r1, [pc, #0x288]
  00350	e59f0280	 ldr         r0, [pc, #0x280]
  00354	e3a03c09	 mov         r3, #9, 24
  00358	e3832059	 orr         r2, r3, #0x59
  0035c	eb000000	 bl          NKDbgPrintfW
  00360	e59f026c	 ldr         r0, [pc, #0x26C]
  00364	e1a01005	 mov         r1, r5
  00368	eb000000	 bl          NKDbgPrintfW

; 2154 :             goto clean;

  0036c	e3a02000	 mov         r2, #0
  00370	ea000084	 b           |$clean$45376|
  00374		 |$LN19@SPI_IOCont|

; 2288 :         }
; 2289 :         break;
; 2290 : 
; 2291 :     case IOCTL_CONTEXT_RESTORE:
; 2292 :         if (pDevice->pActiveInstance != NULL)

  00374	e5943288	 ldr         r3, [r4, #0x288]
  00378	e3530000	 cmp         r3, #0
  0037c	0a000081	 beq         |$clean$45376|

; 2293 :             {
; 2294 :             ContextRestore((SPI_INSTANCE*)pDevice->pActiveInstance);

  00380	e1a00003	 mov         r0, r3
  00384	eb000000	 bl          ContextRestore

; 2154 :             goto clean;

  00388	e3a02000	 mov         r2, #0
  0038c	ea00007d	 b           |$clean$45376|
  00390		 |$LN24@SPI_IOCont|

; 2251 :         break;
; 2252 :   
; 2253 : 
; 2254 :     case IOCTL_DVFS_OPPNOTIFY:
; 2255 :         {
; 2256 :             DWORD i = 0;
; 2257 :             IOCTL_DVFS_OPPNOTIFY_IN *pIn = (IOCTL_DVFS_OPPNOTIFY_IN*)pInBuffer;
; 2258 : 
; 2259 :             if (pIn->ffInfo & DVFS_CORE1_PRE_NOTICE)

  00390	e5963004	 ldr         r3, [r6, #4]
  00394	e3a05000	 mov         r5, #0
  00398	e3130001	 tst         r3, #1

; 2260 :             {
; 2261 :             pDevice->bDVFSActive = TRUE;
; 2262 :                 ResetEvent(pDevice->hDVFSInactiveEvent);                

  0039c	e594004c	 ldr         r0, [r4, #0x4C]

; 2251 :         break;
; 2252 :   
; 2253 : 
; 2254 :     case IOCTL_DVFS_OPPNOTIFY:
; 2255 :         {
; 2256 :             DWORD i = 0;
; 2257 :             IOCTL_DVFS_OPPNOTIFY_IN *pIn = (IOCTL_DVFS_OPPNOTIFY_IN*)pInBuffer;
; 2258 : 
; 2259 :             if (pIn->ffInfo & DVFS_CORE1_PRE_NOTICE)

  003a0	0a000007	 beq         |$LN23@SPI_IOCont|

; 2260 :             {
; 2261 :             pDevice->bDVFSActive = TRUE;
; 2262 :                 ResetEvent(pDevice->hDVFSInactiveEvent);                

  003a4	e3a03001	 mov         r3, #1
  003a8	e3a01002	 mov         r1, #2
  003ac	e5843044	 str         r3, [r4, #0x44]
  003b0	eb000000	 bl          EventModify

; 2263 :             CheckAndHaltAllDma(pInstance, TRUE);

  003b4	e3a01001	 mov         r1, #1
  003b8	e1a00007	 mov         r0, r7
  003bc	eb000000	 bl          CheckAndHaltAllDma

; 2264 :             }
; 2265 :             else

  003c0	ea000008	 b           |$LN110@SPI_IOCont|
  003c4		 |$LN23@SPI_IOCont|

; 2266 :             {
; 2267 :             pDevice->bDVFSActive = FALSE;
; 2268 :                 SetEvent(pDevice->hDVFSInactiveEvent);

  003c4	e3a03000	 mov         r3, #0
  003c8	e3a01003	 mov         r1, #3
  003cc	e5843044	 str         r3, [r4, #0x44]
  003d0	eb000000	 bl          EventModify

; 2269 :             CheckAndHaltAllDma(pInstance, FALSE);

  003d4	e5974004	 ldr         r4, [r7, #4]
  003d8	e2840f97	 add         r0, r4, #0x97, 30
  003dc	eb000000	 bl          EnterCriticalSection
  003e0	e2840f97	 add         r0, r4, #0x97, 30
  003e4	eb000000	 bl          LeaveCriticalSection
  003e8		 |$LN110@SPI_IOCont|

; 2270 :             }
; 2271 :         bRetVal = TRUE;
; 2272 : 
; 2273 :             
; 2274 :             DEBUGMSG( ZONE_ERROR, (L"SPI: DVFS Notification: ffInfo=0x%08X, dwCount=%d\r\n",
; 2275 :                 pIn->ffInfo, pIn->dwCount));
; 2276 : 
; 2277 :             while (i < pIn->dwCount)

  003e8	e5963008	 ldr         r3, [r6, #8]
  003ec	e3a02001	 mov         r2, #1
  003f0	e3530000	 cmp         r3, #0
  003f4	9a000063	 bls         |$clean$45376|
  003f8		 |$LL21@SPI_IOCont|

; 2278 :         {
; 2279 :                 pIn->dwCount--;

  003f8	e5963008	 ldr         r3, [r6, #8]

; 2280 :                 DEBUGMSG( ZONE_ERROR, (L"...SPI(new): voltDomain=%d, opp=%d\r\n",
; 2281 :                     pIn->rgOppInfo[i].domain, pIn->rgOppInfo[i].newOpp));
; 2282 : 
; 2283 :                 DEBUGMSG( ZONE_ERROR, (L"...SPI(old): voltDomain=%d, opp=%d\r\n",
; 2284 :                     pIn->rgOppInfo[i].domain, pIn->rgOppInfo[i].oldOpp));
; 2285 :                 ++i;

  003fc	e2855001	 add         r5, r5, #1
  00400	e2433001	 sub         r3, r3, #1
  00404	e5863008	 str         r3, [r6, #8]
  00408	e1550003	 cmp         r5, r3
  0040c	3afffff9	 bcc         |$LL21@SPI_IOCont|

; 2286 :             }
; 2287 :             break;

  00410	ea00005c	 b           |$clean$45376|
  00414		 |$LN13@SPI_IOCont|

; 2321 :                     }
; 2322 :             }
; 2323 :         break;
; 2324 : 
; 2325 :     case IOCTL_POWER_QUERY: 
; 2326 :         if (pOutBuffer && outSize >= sizeof(CEDEVICE_POWER_STATE)) 

  00414	e59b1000	 ldr         r1, [r11]
  00418	e3510000	 cmp         r1, #0
  0041c	0a000059	 beq         |$clean$45376|
  00420	e59b3004	 ldr         r3, [r11, #4]
  00424	e3530004	 cmp         r3, #4
  00428	3a000056	 bcc         |$clean$45376|
  0042c		 |$LN85@SPI_IOCont|

; 2327 :             {
; 2328 :             __try 
; 2329 :                 {
; 2330 :                 CEDEVICE_POWER_STATE ReqDx = *(PCEDEVICE_POWER_STATE)pOutBuffer;

  0042c	e5913000	 ldr         r3, [r1]

; 2331 : 
; 2332 :                 if (VALID_DX(ReqDx)) 

  00430	e3530004	 cmp         r3, #4

; 2333 :                     {
; 2334 :                     bRetVal = TRUE;

  00434	93a02001	 movls       r2, #1
  00438	950b2060	 strls       r2, [r11, #-0x60]
  0043c		 |$LN86@SPI_IOCont|

; 2335 :                     }
; 2336 : 
; 2337 :                 }

  0043c	ea000051	 b           |$clean$45376|
  00440		 |$LN82@SPI_IOCont|

; 2339 :                 {
; 2340 :                 RETAILMSG(ZONE_ERROR, (L"Exception in spi ioctl\r\n"));

  00440	e59f3184	 ldr         r3, [pc, #0x184]
  00444	e5933440	 ldr         r3, [r3, #0x440]
  00448	e3130001	 tst         r3, #1
  0044c	159f017c	 ldrne       r0, [pc, #0x17C]
  00450	1b000000	 blne        NKDbgPrintfW
  00454	e51b2060	 ldr         r2, [r11, #-0x60]
  00458	ea00004a	 b           |$clean$45376|
  0045c		 |$LN9@SPI_IOCont|

; 2341 :                 }
; 2342 :             }
; 2343 :         break;
; 2344 : 
; 2345 :     case IOCTL_POWER_SET: 
; 2346 :         if (pOutBuffer && outSize >= sizeof(CEDEVICE_POWER_STATE)) 

  0045c	e59b1000	 ldr         r1, [r11]
  00460	e3510000	 cmp         r1, #0
  00464	0a000047	 beq         |$clean$45376|
  00468	e59b3004	 ldr         r3, [r11, #4]
  0046c	e3530004	 cmp         r3, #4
  00470	3a000044	 bcc         |$clean$45376|
  00474		 |$LN92@SPI_IOCont|

; 2347 :             {
; 2348 :             __try 
; 2349 :                 {
; 2350 :                 CEDEVICE_POWER_STATE newPowerState = *(PCEDEVICE_POWER_STATE)pOutBuffer;

  00474	e5915000	 ldr         r5, [r1]

; 2351 : 
; 2352 :                 // SPI clocks are enabled during read/write and disabled after
; 2353 :                 // nActivityTimeout duration. 
; 2354 :                 // In D4 request wait untill the SPIPowerTimerThread puts the device 
; 2355 :                 // in D4 state
; 2356 :                 if (newPowerState == D4)

  00478	e3550004	 cmp         r5, #4
  0047c	1a000004	 bne         |$LN5@SPI_IOCont|

; 2357 :                     {
; 2358 :                     if (pDevice->powerState != D4)

  00480	e5943034	 ldr         r3, [r4, #0x34]
  00484	e3530004	 cmp         r3, #4

; 2359 :                         {
; 2360 :                         // Wait till the SPI device is put to OFF state
; 2361 :                         WaitForSingleObject(pDevice->hDeviceOffEvent, INFINITE);

  00488	1594028c	 ldrne       r0, [r4, #0x28C]
  0048c	13e01000	 mvnne       r1, #0
  00490	1b000000	 blne        WaitForSingleObject
  00494		 |$LN5@SPI_IOCont|

; 2362 :                         }
; 2363 :                     }
; 2364 :                 
; 2365 :                 pDevice->systemState = newPowerState;

  00494	e5845290	 str         r5, [r4, #0x290]

; 2366 :                 bRetVal = TRUE;

  00498	e3a02001	 mov         r2, #1
  0049c	e50b2060	 str         r2, [r11, #-0x60]
  004a0		 |$LN93@SPI_IOCont|

; 2367 :                 }

  004a0	ea000038	 b           |$clean$45376|
  004a4		 |$LN89@SPI_IOCont|

; 2369 :                 {
; 2370 :                 RETAILMSG(ZONE_ERROR, (L"Exception in spi ioctl\r\n"));

  004a4	e59f3120	 ldr         r3, [pc, #0x120]
  004a8	e5933440	 ldr         r3, [r3, #0x440]
  004ac	e3130001	 tst         r3, #1
  004b0	159f0118	 ldrne       r0, [pc, #0x118]
  004b4	1b000000	 blne        NKDbgPrintfW
  004b8	e51b2060	 ldr         r2, [r11, #-0x60]
  004bc	ea000031	 b           |$clean$45376|
  004c0		 |$LN4@SPI_IOCont|

; 2371 :                 }
; 2372 :         }
; 2373 :         break;
; 2374 : 
; 2375 :     // gets the current device power state
; 2376 :     case IOCTL_POWER_GET: 
; 2377 :         if (pOutBuffer != NULL && outSize >= sizeof(CEDEVICE_POWER_STATE)) 

  004c0	e59b1000	 ldr         r1, [r11]
  004c4	e3510000	 cmp         r1, #0
  004c8	0a00002e	 beq         |$clean$45376|
  004cc	e59b3004	 ldr         r3, [r11, #4]
  004d0	e3530004	 cmp         r3, #4
  004d4	3a00002b	 bcc         |$clean$45376|
  004d8		 |$LN99@SPI_IOCont|

; 2378 :             {
; 2379 :             __try 
; 2380 :                 {
; 2381 :                 *(PCEDEVICE_POWER_STATE)pOutBuffer = pDevice->powerState;

  004d8	e5943034	 ldr         r3, [r4, #0x34]
  004dc	e5813000	 str         r3, [r1]

; 2382 : 
; 2383 :                 bRetVal = TRUE;

  004e0	e3a02001	 mov         r2, #1
  004e4	e50b2060	 str         r2, [r11, #-0x60]
  004e8		 |$LN100@SPI_IOCont|

; 2384 :                 }

  004e8	ea000026	 b           |$clean$45376|
  004ec		 |$LN96@SPI_IOCont|

; 2386 :                 {
; 2387 :                 RETAILMSG(ZONE_ERROR, (L"Exception in spi ioctl\r\n"));

  004ec	e59f30d8	 ldr         r3, [pc, #0xD8]
  004f0	e5933440	 ldr         r3, [r3, #0x440]
  004f4	e3130001	 tst         r3, #1
  004f8	159f00d0	 ldrne       r0, [pc, #0xD0]
  004fc	1b000000	 blne        NKDbgPrintfW
  00500	e51b2060	 ldr         r2, [r11, #-0x60]
  00504	ea00001f	 b           |$clean$45376|
  00508		 |$LN16@SPI_IOCont|

; 2295 :             }
; 2296 :         else
; 2297 :             {
; 2298 :             DEBUGMSG( ZONE_ERROR, (L"SPI: IOCTL_CONTEXT_RESTORE_NOTIFY FAILED\r\n"));
; 2299 :             }
; 2300 :         break;
; 2301 : 
; 2302 :     case IOCTL_POWER_CAPABILITIES: 
; 2303 :         if (pOutBuffer && outSize >= sizeof (POWER_CAPABILITIES) && 
; 2304 :             pOutSize) 

  00508	e59b4000	 ldr         r4, [r11]
  0050c	e3540000	 cmp         r4, #0
  00510	0a00001c	 beq         |$clean$45376|
  00514	e59b3004	 ldr         r3, [r11, #4]
  00518	e3530030	 cmp         r3, #0x30
  0051c	3a000019	 bcc         |$clean$45376|
  00520	e59b5008	 ldr         r5, [r11, #8]
  00524	e3550000	 cmp         r5, #0
  00528	0a000016	 beq         |$clean$45376|
  0052c		 |$LN78@SPI_IOCont|

; 2305 :             {
; 2306 :                 __try 
; 2307 :                     {
; 2308 :                     PPOWER_CAPABILITIES pPowerCaps;
; 2309 :                     pPowerCaps = (PPOWER_CAPABILITIES)pOutBuffer;
; 2310 :      
; 2311 :                     // Only supports D0 and D4 states
; 2312 :                     memset(pPowerCaps, 0, sizeof(*pPowerCaps));

  0052c	e3a02030	 mov         r2, #0x30
  00530	e3a01000	 mov         r1, #0
  00534	e1a00004	 mov         r0, r4
  00538	eb000000	 bl          memset

; 2313 :                     pPowerCaps->DeviceDx = DX_MASK(D0)|DX_MASK(D4);;

  0053c	e3a03011	 mov         r3, #0x11
  00540	e5c43000	 strb        r3, [r4]

; 2314 :                     *pOutSize = sizeof(*pPowerCaps);

  00544	e3a03030	 mov         r3, #0x30
  00548	e5853000	 str         r3, [r5]

; 2315 :                     
; 2316 :                     bRetVal = TRUE;

  0054c	e3a02001	 mov         r2, #1
  00550	e50b2060	 str         r2, [r11, #-0x60]
  00554		 |$LN79@SPI_IOCont|

; 2317 :                     }

  00554	ea00000b	 b           |$clean$45376|
  00558		 |$LN75@SPI_IOCont|

; 2319 :                     {
; 2320 :                     RETAILMSG(ZONE_ERROR, (L"exception in spi ioctl\r\n"));

  00558	e59f306c	 ldr         r3, [pc, #0x6C]
  0055c	e5933440	 ldr         r3, [r3, #0x440]
  00560	e3130001	 tst         r3, #1
  00564	159f005c	 ldrne       r0, [pc, #0x5C]
  00568	1b000000	 blne        NKDbgPrintfW
  0056c	e51b2060	 ldr         r2, [r11, #-0x60]
  00570	ea000004	 b           |$clean$45376|
  00574		 |$LN124@SPI_IOCont|

; 2394 :         break;
; 2395 :     }
; 2396 : 
; 2397 : clean:
; 2398 :     DEBUGMSG(ZONE_FUNCTION, (L"-SPI_IOControl(rc = %d)\r\n", bRetVal));
; 2399 :     return bRetVal;

  00574	e51b205c	 ldr         r2, [r11, #-0x5C]
  00578	ea000002	 b           |$clean$45376|
  0057c		 |$LN25@SPI_IOCont|

; 2249 :     case IOCTL_SPI_DISABLE_CHANNEL: 
; 2250 :         bRetVal = SPI_DisableChannel(context);

  0057c	e1a00007	 mov         r0, r7
  00580	eb000000	 bl          SPI_DisableChannel
  00584		 |$LN125@SPI_IOCont|
  00584	e1a02000	 mov         r2, r0
  00588		 |$clean$45376|

; 2400 : }

  00588	e1a00002	 mov         r0, r2
  0058c	e24bd028	 sub         sp, r11, #0x28
  00590	e89d6ff0	 ldmia       sp, {r4 - r11, sp, lr}
  00594	e12fff1e	 bx          lr

			 ENDP  ; |SPI_IOControl|

  00598		 |$LN74@SPI_IOCont|
  00598		 |$LN129@SPI_IOCont|

; 2318 :                 __except(EXCEPTION_EXECUTE_HANDLER) 

  00598	e52de004	 str         lr, [sp, #-4]!
  0059c		 |$LN77@SPI_IOCont|
  0059c		 |$LN135@SPI_IOCont|
  0059c	e3a00001	 mov         r0, #1
  005a0		 |$LN76@SPI_IOCont|
  005a0	e49df004	 ldr         pc, [sp], #4
  005a4		 |$LN136@SPI_IOCont|
  005a4		 |$LN95@SPI_IOCont|
  005a4		 |$LN131@SPI_IOCont|

; 2385 :             __except(EXCEPTION_EXECUTE_HANDLER) 

  005a4	e52de004	 str         lr, [sp, #-4]!
  005a8		 |$LN98@SPI_IOCont|
  005a8		 |$LN137@SPI_IOCont|
  005a8	e3a00001	 mov         r0, #1
  005ac		 |$LN97@SPI_IOCont|
  005ac	e49df004	 ldr         pc, [sp], #4
  005b0		 |$LN138@SPI_IOCont|
  005b0		 |$LN88@SPI_IOCont|
  005b0		 |$LN132@SPI_IOCont|

; 2368 :             __except(EXCEPTION_EXECUTE_HANDLER) 

  005b0	e52de004	 str         lr, [sp, #-4]!
  005b4		 |$LN91@SPI_IOCont|
  005b4		 |$LN139@SPI_IOCont|
  005b4	e3a00001	 mov         r0, #1
  005b8		 |$LN90@SPI_IOCont|
  005b8	e49df004	 ldr         pc, [sp], #4
  005bc		 |$LN140@SPI_IOCont|
  005bc		 |$LN81@SPI_IOCont|
  005bc		 |$LN133@SPI_IOCont|

; 2338 :             __except(EXCEPTION_EXECUTE_HANDLER) 

  005bc	e52de004	 str         lr, [sp, #-4]!
  005c0		 |$LN84@SPI_IOCont|
  005c0		 |$LN141@SPI_IOCont|
  005c0	e3a00001	 mov         r0, #1
  005c4		 |$LN83@SPI_IOCont|
  005c4	e49df004	 ldr         pc, [sp], #4
  005c8		 |$LN143@SPI_IOCont|
  005c8		 |$LN144@SPI_IOCont|
  005c8	00000000	 DCD         |??_C@_1DC@IGLIIDFJ@?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAs?$AAp?$AAi?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@|
  005cc		 |$LN145@SPI_IOCont|
  005cc	00000000	 DCD         |dpCurSettings|
  005d0		 |$LN146@SPI_IOCont|
  005d0	00000000	 DCD         |??_C@_1DC@NKOBOHOD@?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAs?$AAp?$AAi?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@|
  005d4		 |$LN147@SPI_IOCont|
  005d4	00000000	 DCD         |??_C@_1EG@CDHLAJIG@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAx?$AAx?$AAx?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA?4?$AA8?$AAX?$AA?$CJ?$AA?5@|
  005d8		 |$LN148@SPI_IOCont|
  005d8	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  005dc		 |$LN149@SPI_IOCont|
  005dc	00000000	 DCD         |??_C@_1IO@MLHBGINH@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  005e0		 |$LN150@SPI_IOCont|
  005e0	80038140	 DCD         0x80038140
  005e4		 |$LN151@SPI_IOCont|
  005e4	0032100c	 DCD         0x32100c
  005e8		 |$LN152@SPI_IOCont|
  005e8	00321008	 DCD         0x321008
  005ec		 |$LN153@SPI_IOCont|
  005ec	00321004	 DCD         0x321004
  005f0		 |$LN154@SPI_IOCont|
  005f0	00220818	 DCD         0x220818
  005f4		 |$LN155@SPI_IOCont|
  005f4	00220814	 DCD         0x220814
  005f8		 |$LN156@SPI_IOCont|
  005f8	00000000	 DCD         |SPI_DisableChannel|
  005fc		 |$LN157@SPI_IOCont|
  005fc	00000000	 DCD         |SPI_EnableChannel|
  00600		 |$LN158@SPI_IOCont|
  00600	00000000	 DCD         |SPI_UnlockController|
  00604		 |$LN159@SPI_IOCont|
  00604	00000000	 DCD         |SPI_LockController|
  00608		 |$LN160@SPI_IOCont|
  00608	00000000	 DCD         |SPI_SetSlaveMode|
  0060c		 |$LN161@SPI_IOCont|
  0060c	00000000	 DCD         |SPI_WaitForAsyncWriteReadComplete|
  00610		 |$LN162@SPI_IOCont|
  00610	00000000	 DCD         |SPI_AsyncWriteRead|
  00614		 |$LN163@SPI_IOCont|
  00614	00000000	 DCD         |SPI_WriteRead|
  00618		 |$LN164@SPI_IOCont|
  00618	00000000	 DCD         |SPI_Write|
  0061c		 |$LN165@SPI_IOCont|
  0061c	00000000	 DCD         |SPI_Read|
  00620		 |$LN166@SPI_IOCont|
  00620	00000000	 DCD         |SPI_Configure|
  00624		 |$LN167@SPI_IOCont|
  00624	00000000	 DCD         |DEVICE_IFC_SPI_GUID|
  00628		 |$LN168@SPI_IOCont|
  00628	00220808	 DCD         0x220808
  0062c		 |$LN169@SPI_IOCont|
  0062c	00220804	 DCD         0x220804
  00630		 |$LN170@SPI_IOCont|
  00630	0022080c	 DCD         0x22080c
  00634		 |$LN171@SPI_IOCont|
  00634	0022081c	 DCD         0x22081c
  00638		 |$LN172@SPI_IOCont|
  00638	73706949	 DCD         0x73706949
  0063c		 |$LN142@SPI_IOCont|
  0063c		 |$LN134@SPI_IOCont|
	END
