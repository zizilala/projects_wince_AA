; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\SPI\dma_init.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|TxDmaSettings| [ DATA ]
	EXPORT	|RxDmaSettings| [ DATA ]
	EXPORT	|dwSyncMasksTX| [ DATA ]
	EXPORT	|dwSyncMasksRX| [ DATA ]

  00000			 AREA	 |.data|, DATA
|TxDmaSettings| DCD 0x0
	DCD	0x0
	DCD	0x0
	DCD	0x1000
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x4000040
	DCD	0x0
	DCD	0x0
	DCD	0x20
	%	4
|RxDmaSettings| DCD 0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x4000
	DCD	0x4000040
	DCD	0x1000000
	DCD	0x0
	DCD	0x20
	%	4
|dwSyncMasksTX| DCD 0x23
	DCD	0x25
	DCD	0x27
	DCD	0x29
	DCD	0x2b
	DCD	0x2d
	DCD	0x0
	DCD	0x0
	DCD	0xf
	DCD	0x17
	DCD	0x0
	DCD	0x0
	DCD	0x46
	DCD	0x0
	DCD	0x0
	DCD	0x0
|dwSyncMasksRX| DCD 0x24
	DCD	0x26
	DCD	0x28
	DCD	0x2a
	DCD	0x2c
	DCD	0x2e
	DCD	0x0
	DCD	0x0
	DCD	0x10
	DCD	0x18
	DCD	0x0
	DCD	0x0
	DCD	0x47
	DCD	0x0
	DCD	0x0
	DCD	0x0

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|DmaConfigure|
	IMPORT	|DmaGetLogicalChannel|
	IMPORT	|memset|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\inc\omap_sdma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T44123| DCD	|$LN8@DmaConfigu|
	DCD	0x40003901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaConfigure| PROC

; 166  : {

  00000		 |$LN8@DmaConfigu|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M44120|
  00004	e1a04003	 mov         r4, r3
  00008	e1a09002	 mov         r9, r2
  0000c	e1a06001	 mov         r6, r1
  00010	e1a05000	 mov         r5, r0

; 167  :     BOOL rc = FALSE;
; 168  :     OMAP_DMA_LC_REGS *pDmaLcReg = (OMAP_DMA_LC_REGS*)DmaGetLogicalChannel(hDmaChannel);

  00014	e3a08000	 mov         r8, #0
  00018	eb000000	 bl          DmaGetLogicalChannel
  0001c	e1b07000	 movs        r7, r0

; 169  :     if (pDmaLcReg == NULL || pConfigInfo == NULL)

  00020	0a00002c	 beq         |$cleanUp$43452|
  00024	e3560000	 cmp         r6, #0
  00028	0a00002a	 beq         |$cleanUp$43452|

; 170  :         {
; 171  :         goto cleanUp;
; 172  :         }
; 173  : 
; 174  :     // initialize dma DataInfo if necessary
; 175  :     if (pDataInfo != NULL)

  0002c	e3540000	 cmp         r4, #0
  00030	0a000005	 beq         |$LN1@DmaConfigu|

; 176  :         {
; 177  :         memset(pDataInfo, 0, sizeof(DmaDataInfo_t));

  00034	e3a02018	 mov         r2, #0x18
  00038	e3a01000	 mov         r1, #0
  0003c	e1a00004	 mov         r0, r4
  00040	eb000000	 bl          memset

; 178  :         pDataInfo->hDmaChannel = hDmaChannel;

  00044	e5845010	 str         r5, [r4, #0x10]

; 179  :         pDataInfo->pDmaLcReg = pDmaLcReg;

  00048	e5847014	 str         r7, [r4, #0x14]
  0004c		 |$LN1@DmaConfigu|

; 180  :         }
; 181  : 
; 182  :     // Disable the DMA in case it is running
; 183  :     CLRREG32(&pDmaLcReg->CCR, DMA_CCR_ENABLE);

  0004c	e5973000	 ldr         r3, [r7]

; 184  : 
; 185  :     // update syncmap
; 186  :     pConfigInfo->syncMap = syncMap;
; 187  : 
; 188  :     // Initialize logical channel registers
; 189  :     //
; 190  :     OUTREG32(&pDmaLcReg->CCR, 0);

  00050	e3a02000	 mov         r2, #0

; 191  :     OUTREG32(&pDmaLcReg->CLNK_CTRL, 0);
; 192  :     OUTREG32(&pDmaLcReg->COLOR, 0);
; 193  : 
; 194  :     // update CSDP
; 195  :     //  DATA_TYPE
; 196  :     //  DST
; 197  :     //  SRC
; 198  :     OUTREG32(&pDmaLcReg->CSDP, pConfigInfo->elemSize);
; 199  : 
; 200  :     // update CCR
; 201  :     //  DST_MODE
; 202  :     //  SRC_MODE
; 203  :     //  PRIO
; 204  :     //  SYNC
; 205  :     //
; 206  :     OUTREG32(&pDmaLcReg->CCR, pConfigInfo->srcAddrMode |
; 207  :         pConfigInfo->dstAddrMode | pConfigInfo->dmaPrio |
; 208  :         DMA_CCR_SYNC(syncMap) | pConfigInfo->synchTrigger |
; 209  :         pConfigInfo->synchMode
; 210  :         );

  00054	e2090060	 and         r0, r9, #0x60
  00058	e3c33080	 bic         r3, r3, #0x80
  0005c	e5873000	 str         r3, [r7]
  00060	e586902c	 str         r9, [r6, #0x2C]
  00064	e5872000	 str         r2, [r7]
  00068	e5872004	 str         r2, [r7, #4]
  0006c	e5872044	 str         r2, [r7, #0x44]
  00070	e5963000	 ldr         r3, [r6]

; 211  : 
; 212  :     // update CSEI
; 213  :     //
; 214  :     OUTREG32(&pDmaLcReg->CSEI, pConfigInfo->srcElemIndex);
; 215  : 
; 216  :     // update CDEI
; 217  :     //
; 218  :     OUTREG32(&pDmaLcReg->CDEI, pConfigInfo->dstElemIndex);
; 219  : 
; 220  :     // update CSFI
; 221  :     //
; 222  :     OUTREG32(&pDmaLcReg->CSFI, pConfigInfo->srcFrameIndex);
; 223  : 
; 224  :     // update CDFI
; 225  :     //
; 226  :     OUTREG32(&pDmaLcReg->CDFI, pConfigInfo->dstFrameIndex);
; 227  : 
; 228  :     // update CICR
; 229  :     //
; 230  :     OUTREG32(&pDmaLcReg->CICR , pConfigInfo->interrupts);
; 231  :     
; 232  :     rc = TRUE;

  00074	e3a08001	 mov         r8, #1
  00078	e5873010	 str         r3, [r7, #0x10]
  0007c	e5962024	 ldr         r2, [r6, #0x24]
  00080	e209301f	 and         r3, r9, #0x1F
  00084	e5961020	 ldr         r1, [r6, #0x20]
  00088	e1833700	 orr         r3, r3, r0, lsl #14
  0008c	e1833002	 orr         r3, r3, r2
  00090	e596201c	 ldr         r2, [r6, #0x1C]
  00094	e1833001	 orr         r3, r3, r1
  00098	e5961018	 ldr         r1, [r6, #0x18]
  0009c	e1833002	 orr         r3, r3, r2
  000a0	e596200c	 ldr         r2, [r6, #0xC]
  000a4	e1833001	 orr         r3, r3, r1
  000a8	e1833002	 orr         r3, r3, r2
  000ac	e5873000	 str         r3, [r7]
  000b0	e5963004	 ldr         r3, [r6, #4]
  000b4	e5873024	 str         r3, [r7, #0x24]
  000b8	e5963010	 ldr         r3, [r6, #0x10]
  000bc	e587302c	 str         r3, [r7, #0x2C]
  000c0	e5963008	 ldr         r3, [r6, #8]
  000c4	e5873028	 str         r3, [r7, #0x28]
  000c8	e5963014	 ldr         r3, [r6, #0x14]
  000cc	e5873030	 str         r3, [r7, #0x30]
  000d0	e5963028	 ldr         r3, [r6, #0x28]
  000d4	e5873008	 str         r3, [r7, #8]
  000d8		 |$cleanUp$43452|

; 233  : 
; 234  : cleanUp:
; 235  :     return rc;
; 236  : }

  000d8	e1a00008	 mov         r0, r8
  000dc	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000e0	e12fff1e	 bx          lr
  000e4		 |$M44121|

			 ENDP  ; |DmaConfigure|

	EXPORT	|DmaUpdate|

  00000			 AREA	 |.pdata|, PDATA
|$T44137| DCD	|$LN7@DmaUpdate|
	DCD	0x40002d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaUpdate| PROC

; 251  : {

  00000		 |$LN7@DmaUpdate|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44134|
  00004	e3520000	 cmp         r2, #0
  00008	e1a05000	 mov         r5, r0

; 252  :     BOOL rc = FALSE;

  0000c	e3a00000	 mov         r0, #0

; 253  :     OMAP_DMA_LC_REGS *pDmaLcReg;
; 254  : 
; 255  :     if (pDataInfo == NULL || pDataInfo->pDmaLcReg == NULL)

  00010	0a000025	 beq         |$cleanUp$43494|
  00014	e5923014	 ldr         r3, [r2, #0x14]
  00018	e1b04003	 movs        r4, r3
  0001c	0a000022	 beq         |$cleanUp$43494|

; 256  :         {
; 257  :         goto cleanUp;
; 258  :         }
; 259  :     pDmaLcReg = pDataInfo->pDmaLcReg;
; 260  : 
; 261  :     // Disable the DMA in case it is running
; 262  :     CLRREG32(&pDmaLcReg->CCR, DMA_CCR_ENABLE);

  00020	e5943000	 ldr         r3, [r4]

; 263  : 
; 264  :     // update syncmap
; 265  :     pConfigInfo->syncMap = syncMap;
; 266  : 
; 267  :     // Initialize logical channel registers
; 268  :     //
; 269  :     OUTREG32(&pDmaLcReg->CCR, 0);

  00024	e3a02000	 mov         r2, #0

; 270  :     OUTREG32(&pDmaLcReg->CLNK_CTRL, 0);
; 271  :     OUTREG32(&pDmaLcReg->COLOR, 0);
; 272  : 
; 273  :     // update CSDP
; 274  :     //  DATA_TYPE
; 275  :     //  DST
; 276  :     //  SRC
; 277  :     OUTREG32(&pDmaLcReg->CSDP, pConfigInfo->elemSize);
; 278  : 
; 279  :     // update CCR
; 280  :     //  DST_MODE
; 281  :     //  SRC_MODE
; 282  :     //  PRIO
; 283  :     //  SYNC
; 284  :     //
; 285  :     OUTREG32(&pDmaLcReg->CCR, pConfigInfo->srcAddrMode |
; 286  :         pConfigInfo->dstAddrMode | pConfigInfo->dmaPrio |
; 287  :         DMA_CCR_SYNC(syncMap) | pConfigInfo->synchTrigger |
; 288  :         pConfigInfo->synchMode
; 289  :         );

  00028	e201e060	 and         lr, r1, #0x60
  0002c	e3c33080	 bic         r3, r3, #0x80
  00030	e5843000	 str         r3, [r4]
  00034	e585102c	 str         r1, [r5, #0x2C]
  00038	e5842000	 str         r2, [r4]
  0003c	e5842004	 str         r2, [r4, #4]
  00040	e5842044	 str         r2, [r4, #0x44]
  00044	e5953000	 ldr         r3, [r5]

; 290  : 
; 291  :     // update CSEI
; 292  :     //
; 293  :     OUTREG32(&pDmaLcReg->CSEI, pConfigInfo->srcElemIndex);
; 294  : 
; 295  :     // update CDEI
; 296  :     //
; 297  :     OUTREG32(&pDmaLcReg->CDEI, pConfigInfo->dstElemIndex);
; 298  : 
; 299  :     // update CSFI
; 300  :     //
; 301  :     OUTREG32(&pDmaLcReg->CSFI, pConfigInfo->srcFrameIndex);
; 302  : 
; 303  :     // update CDFI
; 304  :     //
; 305  :     OUTREG32(&pDmaLcReg->CDFI, pConfigInfo->dstFrameIndex);
; 306  : 
; 307  :     // update CICR
; 308  :     //
; 309  :     OUTREG32(&pDmaLcReg->CICR , pConfigInfo->interrupts);
; 310  : 
; 311  :     rc = TRUE;

  00048	e3a00001	 mov         r0, #1
  0004c	e5843010	 str         r3, [r4, #0x10]
  00050	e5952024	 ldr         r2, [r5, #0x24]
  00054	e201301f	 and         r3, r1, #0x1F
  00058	e5951020	 ldr         r1, [r5, #0x20]
  0005c	e183370e	 orr         r3, r3, lr, lsl #14
  00060	e1833002	 orr         r3, r3, r2
  00064	e595201c	 ldr         r2, [r5, #0x1C]
  00068	e1833001	 orr         r3, r3, r1
  0006c	e5951018	 ldr         r1, [r5, #0x18]
  00070	e1833002	 orr         r3, r3, r2
  00074	e595200c	 ldr         r2, [r5, #0xC]
  00078	e1833001	 orr         r3, r3, r1
  0007c	e1833002	 orr         r3, r3, r2
  00080	e5843000	 str         r3, [r4]
  00084	e5953004	 ldr         r3, [r5, #4]
  00088	e5843024	 str         r3, [r4, #0x24]
  0008c	e5953010	 ldr         r3, [r5, #0x10]
  00090	e584302c	 str         r3, [r4, #0x2C]
  00094	e5953008	 ldr         r3, [r5, #8]
  00098	e5843028	 str         r3, [r4, #0x28]
  0009c	e5953014	 ldr         r3, [r5, #0x14]
  000a0	e5843030	 str         r3, [r4, #0x30]
  000a4	e5953028	 ldr         r3, [r5, #0x28]
  000a8	e5843008	 str         r3, [r4, #8]
  000ac		 |$cleanUp$43494|

; 312  : 
; 313  : cleanUp:
; 314  :     return rc;
; 315  : }

  000ac	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000b0	e12fff1e	 bx          lr
  000b4		 |$M44135|

			 ENDP  ; |DmaUpdate|

	EXPORT	|DmaSetDstBuffer|

  00000			 AREA	 |.pdata|, PDATA
|$T44147| DCD	|$LN6@DmaSetDstB|
	DCD	0x40000800
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaSetDstBuffer| PROC

; 330  : {

  00000		 |$LN6@DmaSetDstB|
  00000		 |$M44144|

; 331  :     // save values
; 332  :     //
; 333  :     pDataInfo->pDstBuffer = pBuffer;
; 334  :     pDataInfo->PhysAddrDstBuffer = PhysAddr;
; 335  : 
; 336  :     // set destination address
; 337  :     //
; 338  :     if (pDataInfo->pDmaLcReg != NULL)

  00000	e5903014	 ldr         r3, [r0, #0x14]
  00004	e5801004	 str         r1, [r0, #4]
  00008	e580200c	 str         r2, [r0, #0xC]
  0000c	e3530000	 cmp         r3, #0

; 339  :         {
; 340  :         OUTREG32(&pDataInfo->pDmaLcReg->CDSA, PhysAddr);

  00010	15832020	 strne       r2, [r3, #0x20]

; 341  :         OUTREG32(&pDataInfo->pDmaLcReg->CDAC, PhysAddr);

  00014	15903014	 ldrne       r3, [r0, #0x14]
  00018	15832038	 strne       r2, [r3, #0x38]

; 342  :         }
; 343  : }

  0001c	e12fff1e	 bx          lr
  00020		 |$M44145|

			 ENDP  ; |DmaSetDstBuffer|

	EXPORT	|DmaSetSrcBuffer|

  00000			 AREA	 |.pdata|, PDATA
|$T44157| DCD	|$LN6@DmaSetSrcB|
	DCD	0x40000800
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaSetSrcBuffer| PROC

; 358  : {

  00000		 |$LN6@DmaSetSrcB|
  00000		 |$M44154|

; 359  :     // save values
; 360  :     //
; 361  :     pDataInfo->pSrcBuffer = pBuffer;
; 362  :     pDataInfo->PhysAddrSrcBuffer = PhysAddr;
; 363  : 
; 364  :     // set source address
; 365  :     //
; 366  :     if (pDataInfo->pDmaLcReg != NULL)

  00000	e5903014	 ldr         r3, [r0, #0x14]
  00004	e5801000	 str         r1, [r0]
  00008	e5802008	 str         r2, [r0, #8]
  0000c	e3530000	 cmp         r3, #0

; 367  :         {
; 368  :         OUTREG32(&pDataInfo->pDmaLcReg->CSSA, PhysAddr);

  00010	1583201c	 strne       r2, [r3, #0x1C]

; 369  :         OUTREG32(&pDataInfo->pDmaLcReg->CSAC, PhysAddr);

  00014	15903014	 ldrne       r3, [r0, #0x14]
  00018	15832034	 strne       r2, [r3, #0x34]

; 370  :         }
; 371  : }

  0001c	e12fff1e	 bx          lr
  00020		 |$M44155|

			 ENDP  ; |DmaSetSrcBuffer|

	EXPORT	|DmaSetRepeatMode|
	IMPORT	|DmaGetLogicalChannelId|

  00000			 AREA	 |.pdata|, PDATA
|$T44171| DCD	|$LN8@DmaSetRepe|
	DCD	0x40001201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaSetRepeatMode| PROC

; 538  : {

  00000		 |$LN8@DmaSetRepe|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44168|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 539  :     DWORD dwMode = DmaGetLogicalChannelId(pDataInfo->hDmaChannel);

  0000c	e5950010	 ldr         r0, [r5, #0x10]
  00010	eb000000	 bl          DmaGetLogicalChannelId

; 540  :     if (dwMode == -1) return FALSE;

  00014	e3700001	 cmn         r0, #1
  00018	03a00000	 moveq       r0, #0

; 545  : }

  0001c	08bd4030	 ldmeqia     sp!, {r4, r5, lr}
  00020	012fff1e	 bxeq        lr

; 541  : 
; 542  :     dwMode |= (bEnable == TRUE) ? DMA_CLNK_CTRL_ENABLE_LINK : 0;

  00024	e3540001	 cmp         r4, #1
  00028	03a03902	 moveq       r3, #2, 18
  0002c	13a03000	 movne       r3, #0

; 543  :     OUTREG32(&pDataInfo->pDmaLcReg->CLNK_CTRL, dwMode);

  00030	e5952014	 ldr         r2, [r5, #0x14]
  00034	e1833000	 orr         r3, r3, r0

; 544  :     return TRUE;

  00038	e3a00001	 mov         r0, #1
  0003c	e5823004	 str         r3, [r2, #4]

; 545  : }

  00040	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$M44169|

			 ENDP  ; |DmaSetRepeatMode|

	EXPORT	|SpiDmaRestore|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\spi\dma_init.c

  00000			 AREA	 |.pdata|, PDATA
|$T44182| DCD	|$LN5@SpiDmaRest|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SpiDmaRestore| PROC

; 236  : {

  00000		 |$LN5@SpiDmaRest|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44179|

; 237  :     DWORD   dwSyncMask;
; 238  : 
; 239  :     dwSyncMask = dwSyncMasksTX[pInstance->pDevice->dwPort][pInstance->address];

  00004	e5903004	 ldr         r3, [r0, #4]
  00008	e5901008	 ldr         r1, [r0, #8]
  0000c	e59fe01c	 ldr         lr, [pc, #0x1C]
  00010	e5933038	 ldr         r3, [r3, #0x38]

; 240  : 
; 241  :     // Reconfigure the DMA channel
; 242  :     return DmaUpdate(&pInstance->txDmaConfig, dwSyncMask, &pInstance->txDmaInfo);

  00014	e2802088	 add         r2, r0, #0x88
  00018	e2800028	 add         r0, r0, #0x28
  0001c	e0813103	 add         r3, r1, r3, lsl #2
  00020	e79e1103	 ldr         r1, [lr, +r3, lsl #2]
  00024	eb000000	 bl          DmaUpdate

; 243  : }

  00028	e49de004	 ldr         lr, [sp], #4
  0002c	e12fff1e	 bx          lr
  00030		 |$LN6@SpiDmaRest|
  00030		 |$LN7@SpiDmaRest|
  00030	00000000	 DCD         |dwSyncMasksTX|
  00034		 |$M44180|

			 ENDP  ; |SpiDmaRestore|

	EXPORT	|SpiDmaDeinit|
	IMPORT	|FreePhysMem|
	IMPORT	|DmaFreeChannel|
	IMPORT	|CloseHandle|
	IMPORT	|DmaEnableInterrupts|

  00000			 AREA	 |.pdata|, PDATA
|$T44194| DCD	|$LN11@SpiDmaDein|
	DCD	0x40003001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SpiDmaDeinit| PROC

; 514  : {

  00000		 |$LN11@SpiDmaDein|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44191|
  00004	e1a04000	 mov         r4, r0

; 515  :     BOOL    bResult = FALSE;
; 516  : 
; 517  :     DEBUGMSG(ZONE_DMA, (
; 518  :         L"+SpiDmaDeinit(0x%08x)\r\n", pInstance
; 519  :     ));
; 520  : 
; 521  : 
; 522  :     //  Disable DMA interrupts
; 523  :     if( pInstance->hTxDmaIntEvent )

  00008	e5943020	 ldr         r3, [r4, #0x20]
  0000c	e3a05000	 mov         r5, #0
  00010	e3530000	 cmp         r3, #0
  00014	0a000005	 beq         |$LN6@SpiDmaDein|

; 524  :     {
; 525  :         DmaEnableInterrupts(pInstance->hTxDmaChannel, NULL);

  00018	e5940018	 ldr         r0, [r4, #0x18]
  0001c	e3a01000	 mov         r1, #0
  00020	eb000000	 bl          DmaEnableInterrupts

; 526  :         CloseHandle(pInstance->hTxDmaIntEvent);

  00024	e5940020	 ldr         r0, [r4, #0x20]
  00028	eb000000	 bl          CloseHandle

; 527  :         pInstance->hTxDmaIntEvent = NULL;

  0002c	e5845020	 str         r5, [r4, #0x20]
  00030		 |$LN6@SpiDmaDein|

; 528  :     }
; 529  : 
; 530  :     if( pInstance->hRxDmaIntEvent )

  00030	e5943024	 ldr         r3, [r4, #0x24]
  00034	e3530000	 cmp         r3, #0
  00038	0a000005	 beq         |$LN5@SpiDmaDein|

; 531  :     {
; 532  :         DmaEnableInterrupts(pInstance->hRxDmaChannel, NULL);

  0003c	e594001c	 ldr         r0, [r4, #0x1C]
  00040	e3a01000	 mov         r1, #0
  00044	eb000000	 bl          DmaEnableInterrupts

; 533  :         CloseHandle(pInstance->hRxDmaIntEvent);

  00048	e5940024	 ldr         r0, [r4, #0x24]
  0004c	eb000000	 bl          CloseHandle

; 534  :         pInstance->hRxDmaIntEvent = NULL;

  00050	e5845024	 str         r5, [r4, #0x24]
  00054		 |$LN5@SpiDmaDein|

; 535  :     }
; 536  : 
; 537  : 
; 538  :     //  Close DMA channel
; 539  :     if( pInstance->hTxDmaChannel )

  00054	e5943018	 ldr         r3, [r4, #0x18]
  00058	e3530000	 cmp         r3, #0
  0005c	0a000002	 beq         |$LN4@SpiDmaDein|

; 540  :     {
; 541  :         DmaFreeChannel(pInstance->hTxDmaChannel);

  00060	e1a00003	 mov         r0, r3
  00064	eb000000	 bl          DmaFreeChannel

; 542  :         pInstance->hTxDmaChannel = NULL;

  00068	e5845018	 str         r5, [r4, #0x18]
  0006c		 |$LN4@SpiDmaDein|

; 543  :     }
; 544  : 
; 545  :     if( pInstance->hRxDmaChannel )

  0006c	e594301c	 ldr         r3, [r4, #0x1C]
  00070	e3530000	 cmp         r3, #0
  00074	0a000002	 beq         |$LN3@SpiDmaDein|

; 546  :     {
; 547  :         DmaFreeChannel(pInstance->hRxDmaChannel);

  00078	e1a00003	 mov         r0, r3
  0007c	eb000000	 bl          DmaFreeChannel

; 548  :         pInstance->hRxDmaChannel = NULL;

  00080	e584501c	 str         r5, [r4, #0x1C]
  00084		 |$LN3@SpiDmaDein|

; 549  :     }
; 550  : 
; 551  :     //  Free DMA memory
; 552  :     if( pInstance->pTxDmaBuffer )

  00084	e59430b8	 ldr         r3, [r4, #0xB8]
  00088	e3530000	 cmp         r3, #0
  0008c	0a000002	 beq         |$LN2@SpiDmaDein|

; 553  :     {
; 554  :         FreePhysMem( pInstance->pTxDmaBuffer );

  00090	e1a00003	 mov         r0, r3
  00094	eb000000	 bl          FreePhysMem

; 555  :         pInstance->pTxDmaBuffer = NULL;

  00098	e58450b8	 str         r5, [r4, #0xB8]
  0009c		 |$LN2@SpiDmaDein|

; 556  :     }
; 557  : 
; 558  :     if( pInstance->pRxDmaBuffer )

  0009c	e59430c0	 ldr         r3, [r4, #0xC0]
  000a0	e3530000	 cmp         r3, #0
  000a4	0a000002	 beq         |$LN1@SpiDmaDein|

; 559  :     {
; 560  :         FreePhysMem( pInstance->pRxDmaBuffer );

  000a8	e1a00003	 mov         r0, r3
  000ac	eb000000	 bl          FreePhysMem

; 561  :         pInstance->pRxDmaBuffer = NULL;

  000b0	e58450c0	 str         r5, [r4, #0xC0]
  000b4		 |$LN1@SpiDmaDein|

; 562  :     }
; 563  : 
; 564  : 
; 565  :     DEBUGMSG(ZONE_DMA, (
; 566  :         L"-SpiDmaDeinit() rc = \r\n", bResult
; 567  :     ));
; 568  : 
; 569  :     //  Return result
; 570  :     return bResult;

  000b4	e3a00000	 mov         r0, #0

; 571  : }

  000b8	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000bc	e12fff1e	 bx          lr
  000c0		 |$M44192|

			 ENDP  ; |SpiDmaDeinit|

	EXPORT	|SpiDmaInit|
	IMPORT	|CreateEventW|
	IMPORT	|AllocPhysMem|
	IMPORT	|DmaAllocateChannel|
	IMPORT	|memcpy|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\inc\omap_sdma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T44271| DCD	|$LN63@SpiDmaInit|
	DCD	0x4000e202
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\spi\dma_init.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SpiDmaInit| PROC

; 252  : {

  00000		 |$LN63@SpiDmaInit|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M44268|
  00008	e1a04000	 mov         r4, r0

; 253  :     BOOL    bResult = FALSE;
; 254  :     DWORD   dwSyncMask;
; 255  :     DWORD   dwWordLen;
; 256  :     UINT8*  pRegAddr;
; 257  :     DWORD   paRegAddr;
; 258  : 
; 259  : 
; 260  :     DEBUGMSG(ZONE_DMA, (
; 261  :         L"+SpiDmaInit(0x%08x)\r\n", pInstance
; 262  :     ));
; 263  : 
; 264  :     //  Setup TX DMA channel if needed
; 265  :     if( pInstance->config & MCSPI_CHCONF_DMAW_ENABLE )

  0000c	e594300c	 ldr         r3, [r4, #0xC]
  00010	e59f836c	 ldr         r8, [pc, #0x36C]
  00014	e3a09000	 mov         r9, #0
  00018	e3130901	 tst         r3, #1, 18
  0001c	e3a0a002	 mov         r10, #2
  00020	e3a0b001	 mov         r11, #1
  00024	0a000065	 beq         |$LN18@SpiDmaInit|

; 266  :     {
; 267  :         //  Allocate DMA channel
; 268  :         pInstance->hTxDmaChannel = DmaAllocateChannel(DMA_TYPE_SYSTEM);

  00028	e3a00000	 mov         r0, #0
  0002c	eb000000	 bl          DmaAllocateChannel
  00030	e3500000	 cmp         r0, #0
  00034	e5840018	 str         r0, [r4, #0x18]

; 269  :         if (pInstance->hTxDmaChannel == NULL )

  00038	0a0000c9	 beq         |$LN58@SpiDmaInit|

; 270  :             {
; 271  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: SpiDmaInit: "
; 272  :                 L"DmaAllocateChannel Tx failed\r\n"
; 273  :             ));
; 274  :             goto cleanUp;
; 275  :             }
; 276  : 
; 277  :         // Allocate DMA buffer
; 278  :         pInstance->pTxDmaBuffer = AllocPhysMem(
; 279  :             pInstance->pDevice->dwTxBufferSize, PAGE_READWRITE | PAGE_NOCACHE, 0, 0,
; 280  :             &pInstance->paTxDmaBuffer
; 281  :             );

  0003c	e5942004	 ldr         r2, [r4, #4]
  00040	e284e0bc	 add         lr, r4, #0xBC
  00044	e3a03000	 mov         r3, #0
  00048	e592002c	 ldr         r0, [r2, #0x2C]
  0004c	e3a02000	 mov         r2, #0
  00050	e3a01f81	 mov         r1, #0x81, 30
  00054	e58de000	 str         lr, [sp]
  00058	eb000000	 bl          AllocPhysMem
  0005c	e3500000	 cmp         r0, #0
  00060	e58400b8	 str         r0, [r4, #0xB8]

; 282  :         if (pInstance->pTxDmaBuffer == NULL)

  00064	0a0000be	 beq         |$LN58@SpiDmaInit|

; 283  :             {
; 284  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: SpiDmaInit: "
; 285  :                 L"Failed allocate DMA Tx buffer (size %d)\r\n",
; 286  :                 pInstance->pDevice->dwTxBufferSize
; 287  :             ));
; 288  :             goto cleanUp;
; 289  :             }
; 290  : 
; 291  : 
; 292  :         // Determine the DMA settings for the SPI channel
; 293  :         switch( pInstance->address )

  00068	e594e008	 ldr         lr, [r4, #8]
  0006c	e1b0300e	 movs        r3, lr
  00070	0a000014	 beq         |$LN28@SpiDmaInit|
  00074	e3530001	 cmp         r3, #1
  00078	0a00000d	 beq         |$LN27@SpiDmaInit|
  0007c	e3530002	 cmp         r3, #2
  00080	0a000006	 beq         |$LN26@SpiDmaInit|
  00084	e3530003	 cmp         r3, #3
  00088	1a0000b5	 bne         |$LN58@SpiDmaInit|

; 315  : 
; 316  :             case 3:
; 317  :                 //  Channel 3 configuration
; 318  :                 dwSyncMask = dwSyncMasksTX[pInstance->pDevice->dwPort][pInstance->address];

  0008c	e5942004	 ldr         r2, [r4, #4]

; 319  :                 pRegAddr = (UINT8*) &pInstance->pSPIChannelRegs->MCSPI_TX;

  00090	e5923038	 ldr         r3, [r2, #0x38]

; 320  :                 paRegAddr = pInstance->pDevice->memBase[0] + offset(OMAP_MCSPI_REGS, MCSPI_TX3);

  00094	e5922004	 ldr         r2, [r2, #4]
  00098	e2825074	 add         r5, r2, #0x74

; 321  :                 break;

  0009c	ea00000d	 b           |$LN59@SpiDmaInit|
  000a0		 |$LN26@SpiDmaInit|

; 308  : 
; 309  :             case 2:
; 310  :                 //  Channel 2 configuration
; 311  :                 dwSyncMask = dwSyncMasksTX[pInstance->pDevice->dwPort][pInstance->address];

  000a0	e5942004	 ldr         r2, [r4, #4]

; 312  :                 pRegAddr = (UINT8*) &pInstance->pSPIChannelRegs->MCSPI_TX;

  000a4	e5923038	 ldr         r3, [r2, #0x38]

; 313  :                 paRegAddr = pInstance->pDevice->memBase[0] + offset(OMAP_MCSPI_REGS, MCSPI_TX2);

  000a8	e5922004	 ldr         r2, [r2, #4]
  000ac	e2825060	 add         r5, r2, #0x60

; 314  :                 break;

  000b0	ea000008	 b           |$LN59@SpiDmaInit|
  000b4		 |$LN27@SpiDmaInit|

; 300  :                 break;
; 301  : 
; 302  :             case 1:
; 303  :                 //  Channel 1 configuration
; 304  :                 dwSyncMask = dwSyncMasksTX[pInstance->pDevice->dwPort][pInstance->address];

  000b4	e5942004	 ldr         r2, [r4, #4]

; 305  :                 pRegAddr = (UINT8*) &pInstance->pSPIChannelRegs->MCSPI_TX;

  000b8	e5923038	 ldr         r3, [r2, #0x38]

; 306  :                 paRegAddr = pInstance->pDevice->memBase[0] + offset(OMAP_MCSPI_REGS, MCSPI_TX1);

  000bc	e5922004	 ldr         r2, [r2, #4]
  000c0	e282504c	 add         r5, r2, #0x4C

; 307  :                 break;

  000c4	ea000003	 b           |$LN59@SpiDmaInit|
  000c8		 |$LN28@SpiDmaInit|

; 294  :         {
; 295  :             case 0:
; 296  :                 //  Channel 0 configuration
; 297  :                 dwSyncMask = dwSyncMasksTX[pInstance->pDevice->dwPort][pInstance->address];

  000c8	e5942004	 ldr         r2, [r4, #4]

; 298  :                 pRegAddr = (UINT8*) &pInstance->pSPIChannelRegs->MCSPI_TX;

  000cc	e5923038	 ldr         r3, [r2, #0x38]

; 299  :                 paRegAddr = pInstance->pDevice->memBase[0] + offset(OMAP_MCSPI_REGS, MCSPI_TX0);

  000d0	e5922004	 ldr         r2, [r2, #4]
  000d4	e2825038	 add         r5, r2, #0x38
  000d8		 |$LN59@SpiDmaInit|
  000d8	e5941010	 ldr         r1, [r4, #0x10]
  000dc	e08e3103	 add         r3, lr, r3, lsl #2
  000e0	e2880060	 add         r0, r8, #0x60
  000e4	e7907103	 ldr         r7, [r0, +r3, lsl #2]
  000e8	e281600c	 add         r6, r1, #0xC

; 322  : 
; 323  :             default:
; 324  : 				goto cleanUp;
; 325  :                 break;
; 326  :         }
; 327  : 
; 328  :         // Copy the default DMA config settings
; 329  :         pInstance->txDmaConfig = TxDmaSettings;

  000ec	e1a01008	 mov         r1, r8
  000f0	e2840028	 add         r0, r4, #0x28
  000f4	e3a02030	 mov         r2, #0x30
  000f8	eb000000	 bl          memcpy

; 330  : 
; 331  : 
; 332  :         // Determine DMA datatype
; 333  :         dwWordLen = MCSPI_CHCONF_GET_WL(pInstance->config);

  000fc	e594300c	 ldr         r3, [r4, #0xC]
  00100	e1a03a03	 mov         r3, r3, lsl #20
  00104	e1a03da3	 mov         r3, r3, lsr #27
  00108	e2833001	 add         r3, r3, #1

; 334  :         if( dwWordLen > 16 )

  0010c	e3530010	 cmp         r3, #0x10

; 335  :         {
; 336  :             //  32 bit data type
; 337  :             pInstance->txDmaConfig.elemSize = DMA_CSDP_DATATYPE_S32;

  00110	8584a028	 strhi       r10, [r4, #0x28]
  00114	8a000003	 bhi         |$LN20@SpiDmaInit|

; 338  :         }
; 339  :         else if( dwWordLen > 8 )

  00118	e3530008	 cmp         r3, #8

; 340  :         {
; 341  :             //  16 bit data type
; 342  :             pInstance->txDmaConfig.elemSize = DMA_CSDP_DATATYPE_S16;
; 343  :         }
; 344  :         else
; 345  :         {
; 346  :             //  8 bit data type
; 347  :             pInstance->txDmaConfig.elemSize = DMA_CSDP_DATATYPE_S8;

  0011c	93a03000	 movls       r3, #0
  00120	8584b028	 strhi       r11, [r4, #0x28]
  00124	95843028	 strls       r3, [r4, #0x28]
  00128		 |$LN20@SpiDmaInit|

; 348  :         }
; 349  : 
; 350  :         // Configure the DMA channel
; 351  :         DmaConfigure(pInstance->hTxDmaChannel, &pInstance->txDmaConfig, dwSyncMask, &pInstance->txDmaInfo);

  00128	e5940018	 ldr         r0, [r4, #0x18]
  0012c	e2843088	 add         r3, r4, #0x88
  00130	e1a02007	 mov         r2, r7
  00134	e2841028	 add         r1, r4, #0x28
  00138	eb000000	 bl          DmaConfigure

; 352  :         DmaSetSrcBuffer(&pInstance->txDmaInfo, pInstance->pTxDmaBuffer, pInstance->paTxDmaBuffer);

  0013c	e594209c	 ldr         r2, [r4, #0x9C]
  00140	e59410bc	 ldr         r1, [r4, #0xBC]
  00144	e59430b8	 ldr         r3, [r4, #0xB8]
  00148	e3520000	 cmp         r2, #0
  0014c	e5841090	 str         r1, [r4, #0x90]
  00150	e5843088	 str         r3, [r4, #0x88]
  00154	1582101c	 strne       r1, [r2, #0x1C]
  00158	1594309c	 ldrne       r3, [r4, #0x9C]
  0015c	15831034	 strne       r1, [r3, #0x34]

; 353  :         DmaSetDstBuffer(&pInstance->txDmaInfo, pRegAddr, paRegAddr);

  00160	e594309c	 ldr         r3, [r4, #0x9C]
  00164	e584608c	 str         r6, [r4, #0x8C]
  00168	e5845094	 str         r5, [r4, #0x94]
  0016c	e3530000	 cmp         r3, #0
  00170	15835020	 strne       r5, [r3, #0x20]
  00174	1594309c	 ldrne       r3, [r4, #0x9C]
  00178	15835038	 strne       r5, [r3, #0x38]

; 354  :         DmaSetRepeatMode(&pInstance->txDmaInfo, FALSE);

  0017c	e5940098	 ldr         r0, [r4, #0x98]
  00180	eb000000	 bl          DmaGetLogicalChannelId
  00184	e3700001	 cmn         r0, #1
  00188	1594309c	 ldrne       r3, [r4, #0x9C]

; 355  : 
; 356  : 
; 357  :         // Create DMA interrupt event
; 358  :         pInstance->hTxDmaIntEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  0018c	e3a02000	 mov         r2, #0
  00190	e3a01000	 mov         r1, #0
  00194	15830004	 strne       r0, [r3, #4]
  00198	e3a03000	 mov         r3, #0
  0019c	e3a00000	 mov         r0, #0
  001a0	eb000000	 bl          CreateEventW
  001a4	e1b01000	 movs        r1, r0
  001a8	e5841020	 str         r1, [r4, #0x20]

; 359  :         if (pInstance->hTxDmaIntEvent == NULL) {

  001ac	0a00006c	 beq         |$LN58@SpiDmaInit|

; 360  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: SpiDmaInit: "
; 361  :                 L"Failed create TX DMA interrupt event\r\n"
; 362  :             ));
; 363  :             goto cleanUp;
; 364  :         }
; 365  : 
; 366  :         // Initialize interrupt
; 367  :         if (!DmaEnableInterrupts(pInstance->hTxDmaChannel, pInstance->hTxDmaIntEvent)) {

  001b0	e5940018	 ldr         r0, [r4, #0x18]
  001b4	eb000000	 bl          DmaEnableInterrupts
  001b8	e3500000	 cmp         r0, #0
  001bc	0a000068	 beq         |$LN58@SpiDmaInit|
  001c0		 |$LN18@SpiDmaInit|

; 368  :             DEBUGMSG (ZONE_ERROR, (L"ERROR: SpiDmaInit: "
; 369  :                 L"Failed to enable TX DMA interrupt\r\n"
; 370  :             ));
; 371  :             goto cleanUp;
; 372  :         }
; 373  :     }
; 374  : 
; 375  : 
; 376  : 
; 377  :     //  Setup RX DMA channel if needed
; 378  :     if( pInstance->config & MCSPI_CHCONF_DMAR_ENABLE )

  001c0	e594300c	 ldr         r3, [r4, #0xC]
  001c4	e3130902	 tst         r3, #2, 18
  001c8	0a000068	 beq         |$LN2@SpiDmaInit|

; 379  :     {
; 380  :         //  Allocate DMA channel
; 381  :         pInstance->hRxDmaChannel = DmaAllocateChannel(DMA_TYPE_SYSTEM);

  001cc	e3a00000	 mov         r0, #0
  001d0	eb000000	 bl          DmaAllocateChannel
  001d4	e3500000	 cmp         r0, #0
  001d8	e584001c	 str         r0, [r4, #0x1C]

; 382  :         if (pInstance->hRxDmaChannel == NULL )

  001dc	0a000060	 beq         |$LN58@SpiDmaInit|

; 383  :             {
; 384  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: SpiDmaInit: "
; 385  :                 L"DmaAllocateChannel Rx failed\r\n"
; 386  :             ));
; 387  :             goto cleanUp;
; 388  :             }
; 389  : 
; 390  :         // Allocate DMA buffer
; 391  :         pInstance->pRxDmaBuffer = AllocPhysMem(
; 392  :             pInstance->pDevice->dwRxBufferSize, PAGE_READWRITE | PAGE_NOCACHE, 0, 0,
; 393  :             &pInstance->paRxDmaBuffer
; 394  :             );

  001e0	e5942004	 ldr         r2, [r4, #4]
  001e4	e284e0c4	 add         lr, r4, #0xC4
  001e8	e3a03000	 mov         r3, #0
  001ec	e5920030	 ldr         r0, [r2, #0x30]
  001f0	e3a02000	 mov         r2, #0
  001f4	e3a01f81	 mov         r1, #0x81, 30
  001f8	e58de000	 str         lr, [sp]
  001fc	eb000000	 bl          AllocPhysMem
  00200	e3500000	 cmp         r0, #0
  00204	e58400c0	 str         r0, [r4, #0xC0]

; 395  :         if (pInstance->pRxDmaBuffer == NULL)

  00208	0a000055	 beq         |$LN58@SpiDmaInit|

; 396  :             {
; 397  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: SpiDmaInit: "
; 398  :                 L"Failed allocate DMA Rx buffer (size %d)\r\n",
; 399  :                 pInstance->pDevice->dwRxBufferSize
; 400  :             ));
; 401  :             goto cleanUp;
; 402  :             }
; 403  : 
; 404  : 
; 405  :         // Determine the DMA settings for the SPI channel
; 406  :         switch( pInstance->address )

  0020c	e594e008	 ldr         lr, [r4, #8]
  00210	e1b0300e	 movs        r3, lr
  00214	0a000014	 beq         |$LN12@SpiDmaInit|
  00218	e3530001	 cmp         r3, #1
  0021c	0a00000d	 beq         |$LN11@SpiDmaInit|
  00220	e3530002	 cmp         r3, #2
  00224	0a000006	 beq         |$LN10@SpiDmaInit|
  00228	e3530003	 cmp         r3, #3
  0022c	1a00004c	 bne         |$LN58@SpiDmaInit|

; 428  : 
; 429  :             case 3:
; 430  :                 //  Channel 3 configuration
; 431  :                 dwSyncMask = dwSyncMasksRX[pInstance->pDevice->dwPort][pInstance->address];

  00230	e5942004	 ldr         r2, [r4, #4]

; 432  :                 pRegAddr = (UINT8*) &pInstance->pSPIChannelRegs->MCSPI_RX;

  00234	e5923038	 ldr         r3, [r2, #0x38]

; 433  :                 paRegAddr = pInstance->pDevice->memBase[0] + offset(OMAP_MCSPI_REGS, MCSPI_RX3);

  00238	e5922004	 ldr         r2, [r2, #4]
  0023c	e2825078	 add         r5, r2, #0x78

; 434  :                 break;

  00240	ea00000d	 b           |$LN60@SpiDmaInit|
  00244		 |$LN10@SpiDmaInit|

; 421  : 
; 422  :             case 2:
; 423  :                 //  Channel 2 configuration
; 424  :                 dwSyncMask = dwSyncMasksRX[pInstance->pDevice->dwPort][pInstance->address];

  00244	e5942004	 ldr         r2, [r4, #4]

; 425  :                 pRegAddr = (UINT8*) &pInstance->pSPIChannelRegs->MCSPI_RX;

  00248	e5923038	 ldr         r3, [r2, #0x38]

; 426  :                 paRegAddr = pInstance->pDevice->memBase[0] + offset(OMAP_MCSPI_REGS, MCSPI_RX2);

  0024c	e5922004	 ldr         r2, [r2, #4]
  00250	e2825064	 add         r5, r2, #0x64

; 427  :                 break;

  00254	ea000008	 b           |$LN60@SpiDmaInit|
  00258		 |$LN11@SpiDmaInit|

; 413  :                 break;
; 414  : 
; 415  :             case 1:
; 416  :                 //  Channel 1 configuration
; 417  :                 dwSyncMask = dwSyncMasksRX[pInstance->pDevice->dwPort][pInstance->address];

  00258	e5942004	 ldr         r2, [r4, #4]

; 418  :                 pRegAddr = (UINT8*) &pInstance->pSPIChannelRegs->MCSPI_RX;

  0025c	e5923038	 ldr         r3, [r2, #0x38]

; 419  :                 paRegAddr = pInstance->pDevice->memBase[0] + offset(OMAP_MCSPI_REGS, MCSPI_RX1);

  00260	e5922004	 ldr         r2, [r2, #4]
  00264	e2825050	 add         r5, r2, #0x50

; 420  :                 break;

  00268	ea000003	 b           |$LN60@SpiDmaInit|
  0026c		 |$LN12@SpiDmaInit|

; 407  :         {
; 408  :             case 0:
; 409  :                 //  Channel 0 configuration
; 410  :                 dwSyncMask = dwSyncMasksRX[pInstance->pDevice->dwPort][pInstance->address];

  0026c	e5942004	 ldr         r2, [r4, #4]

; 411  :                 pRegAddr = (UINT8*) &pInstance->pSPIChannelRegs->MCSPI_RX;

  00270	e5923038	 ldr         r3, [r2, #0x38]

; 412  :                 paRegAddr = pInstance->pDevice->memBase[0] + offset(OMAP_MCSPI_REGS, MCSPI_RX0);

  00274	e5922004	 ldr         r2, [r2, #4]
  00278	e282503c	 add         r5, r2, #0x3C
  0027c		 |$LN60@SpiDmaInit|
  0027c	e5941010	 ldr         r1, [r4, #0x10]
  00280	e08e3103	 add         r3, lr, r3, lsl #2
  00284	e28800a0	 add         r0, r8, #0xA0
  00288	e7907103	 ldr         r7, [r0, +r3, lsl #2]
  0028c	e2816010	 add         r6, r1, #0x10

; 435  : 
; 436  :             default:
; 437  : 				goto cleanUp;
; 438  :                 break;
; 439  :         }
; 440  : 
; 441  :         // Copy the default DMA config settings
; 442  :         pInstance->rxDmaConfig = RxDmaSettings;

  00290	e2881030	 add         r1, r8, #0x30
  00294	e2840058	 add         r0, r4, #0x58
  00298	e3a02030	 mov         r2, #0x30
  0029c	eb000000	 bl          memcpy

; 443  : 
; 444  : 
; 445  :         // Determine DMA datatype
; 446  :         dwWordLen = MCSPI_CHCONF_GET_WL(pInstance->config);

  002a0	e594300c	 ldr         r3, [r4, #0xC]
  002a4	e1a03a03	 mov         r3, r3, lsl #20
  002a8	e1a03da3	 mov         r3, r3, lsr #27
  002ac	e2833001	 add         r3, r3, #1

; 447  :         if( dwWordLen > 16 )

  002b0	e3530010	 cmp         r3, #0x10

; 448  :         {
; 449  :             //  32 bit data type
; 450  :             pInstance->rxDmaConfig.elemSize = DMA_CSDP_DATATYPE_S32;

  002b4	8584a058	 strhi       r10, [r4, #0x58]
  002b8	8a000003	 bhi         |$LN4@SpiDmaInit|

; 451  :         }
; 452  :         else if( dwWordLen > 8 )

  002bc	e3530008	 cmp         r3, #8

; 453  :         {
; 454  :             //  16 bit data type
; 455  :             pInstance->rxDmaConfig.elemSize = DMA_CSDP_DATATYPE_S16;
; 456  :         }
; 457  :         else
; 458  :         {
; 459  :             //  8 bit data type
; 460  :             pInstance->rxDmaConfig.elemSize = DMA_CSDP_DATATYPE_S8;

  002c0	93a03000	 movls       r3, #0
  002c4	8584b058	 strhi       r11, [r4, #0x58]
  002c8	95843058	 strls       r3, [r4, #0x58]
  002cc		 |$LN4@SpiDmaInit|

; 461  :         }
; 462  : 
; 463  :         // Configure the DMA channel
; 464  :         DmaConfigure(pInstance->hRxDmaChannel, &pInstance->rxDmaConfig, dwSyncMask, &pInstance->rxDmaInfo);

  002cc	e594001c	 ldr         r0, [r4, #0x1C]
  002d0	e28430a0	 add         r3, r4, #0xA0
  002d4	e1a02007	 mov         r2, r7
  002d8	e2841058	 add         r1, r4, #0x58
  002dc	eb000000	 bl          DmaConfigure

; 465  :         DmaSetSrcBuffer(&pInstance->rxDmaInfo, pRegAddr, paRegAddr);

  002e0	e59430b4	 ldr         r3, [r4, #0xB4]
  002e4	e58460a0	 str         r6, [r4, #0xA0]
  002e8	e58450a8	 str         r5, [r4, #0xA8]
  002ec	e3530000	 cmp         r3, #0
  002f0	1583501c	 strne       r5, [r3, #0x1C]
  002f4	159430b4	 ldrne       r3, [r4, #0xB4]
  002f8	15835034	 strne       r5, [r3, #0x34]

; 466  :         DmaSetDstBuffer(&pInstance->rxDmaInfo, pInstance->pRxDmaBuffer, pInstance->paRxDmaBuffer);

  002fc	e59420b4	 ldr         r2, [r4, #0xB4]
  00300	e59410c4	 ldr         r1, [r4, #0xC4]
  00304	e59430c0	 ldr         r3, [r4, #0xC0]
  00308	e3520000	 cmp         r2, #0
  0030c	e58410ac	 str         r1, [r4, #0xAC]
  00310	e58430a4	 str         r3, [r4, #0xA4]
  00314	15821020	 strne       r1, [r2, #0x20]
  00318	159430b4	 ldrne       r3, [r4, #0xB4]
  0031c	15831038	 strne       r1, [r3, #0x38]

; 467  :         DmaSetRepeatMode(&pInstance->rxDmaInfo, FALSE);

  00320	e59400b0	 ldr         r0, [r4, #0xB0]
  00324	eb000000	 bl          DmaGetLogicalChannelId
  00328	e3700001	 cmn         r0, #1
  0032c	159430b4	 ldrne       r3, [r4, #0xB4]

; 468  : 
; 469  : 
; 470  :         // Create DMA interrupt event
; 471  :         pInstance->hRxDmaIntEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  00330	e3a02000	 mov         r2, #0
  00334	e3a01000	 mov         r1, #0
  00338	15830004	 strne       r0, [r3, #4]
  0033c	e3a03000	 mov         r3, #0
  00340	e3a00000	 mov         r0, #0
  00344	eb000000	 bl          CreateEventW
  00348	e1b01000	 movs        r1, r0
  0034c	e5841024	 str         r1, [r4, #0x24]

; 472  :         if (pInstance->hRxDmaIntEvent == NULL) {

  00350	0a000003	 beq         |$LN58@SpiDmaInit|

; 473  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: SpiDmaInit: "
; 474  :                 L"Failed create RX DMA interrupt event\r\n"
; 475  :             ));
; 476  :             goto cleanUp;
; 477  :         }
; 478  : 
; 479  :         // Initialize interrupt
; 480  :         if (!DmaEnableInterrupts(pInstance->hRxDmaChannel, pInstance->hRxDmaIntEvent)) {

  00354	e594001c	 ldr         r0, [r4, #0x1C]
  00358	eb000000	 bl          DmaEnableInterrupts
  0035c	e3500000	 cmp         r0, #0
  00360	1a000002	 bne         |$LN2@SpiDmaInit|
  00364		 |$LN58@SpiDmaInit|

; 490  : 
; 491  : cleanUp:
; 492  :     DEBUGMSG(ZONE_DMA, (
; 493  :         L"-SpiDmaInit() rc = \r\n", bResult
; 494  :     ));
; 495  : 
; 496  :     //  Cleanup DMA on failures
; 497  :     if( bResult == FALSE )
; 498  :     {
; 499  :         SpiDmaDeinit(pInstance);

  00364	e1a00004	 mov         r0, r4
  00368	eb000000	 bl          SpiDmaDeinit
  0036c	ea000000	 b           |$LN1@SpiDmaInit|
  00370		 |$LN2@SpiDmaInit|

; 481  :             DEBUGMSG (ZONE_ERROR, (L"ERROR: SpiDmaInit: "
; 482  :                 L"Failed to enable RX DMA interrupt\r\n"
; 483  :             ));
; 484  :             goto cleanUp;
; 485  :         }
; 486  :     }
; 487  : 
; 488  :     //  Success
; 489  :     bResult = TRUE;

  00370	e3a09001	 mov         r9, #1
  00374		 |$cleanUp$43953|

; 490  : 
; 491  : cleanUp:
; 492  :     DEBUGMSG(ZONE_DMA, (
; 493  :         L"-SpiDmaInit() rc = \r\n", bResult
; 494  :     ));
; 495  : 
; 496  :     //  Cleanup DMA on failures
; 497  :     if( bResult == FALSE )
; 498  :     {
; 499  :         SpiDmaDeinit(pInstance);

  00374		 |$LN1@SpiDmaInit|

; 500  :     }
; 501  : 
; 502  :     //  Return result
; 503  :     return bResult;
; 504  : }

  00374	e1a00009	 mov         r0, r9
  00378	e28dd004	 add         sp, sp, #4
  0037c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00380	e12fff1e	 bx          lr
  00384		 |$LN64@SpiDmaInit|
  00384		 |$LN65@SpiDmaInit|
  00384	00000000	 DCD         |TxDmaSettings|
  00388		 |$M44269|

			 ENDP  ; |SpiDmaInit|

	END
