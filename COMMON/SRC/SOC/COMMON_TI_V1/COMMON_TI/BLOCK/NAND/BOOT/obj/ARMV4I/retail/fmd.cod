; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\BLOCK\NAND\fmd.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.bss|, NOINIT
|s_hNand| %	0x4

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|SectorAccess|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\block\nand\fmd.c

  00000			 AREA	 |.pdata|, PDATA
|$T46613| DCD	|$LN5@SectorAcce|
	DCD	0x40001601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SectorAccess| PROC

; 217  : {

  00000		 |$LN5@SectorAcce|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M46610|

; 218  :     
; 219  :     // Offset is provided to this function in bytes; NAND device requires words
; 220  :     offset = offset / 2;
; 221  :     WRITE_NAND(pDevice->pNandAddress, (offset & 0xFF));

  00004	e590e020	 ldr         lr, [r0, #0x20]
  00008	e1a040a2	 mov         r4, r2, lsr #1
  0000c	e20430ff	 and         r3, r4, #0xFF
  00010	e1ce30b0	 strh        r3, [lr]

; 222  :     WRITE_NAND(pDevice->pNandAddress, ((offset >> 8) & 0xFF));

  00014	e5902020	 ldr         r2, [r0, #0x20]
  00018	e1a03804	 mov         r3, r4, lsl #16
  0001c	e1a03c23	 mov         r3, r3, lsr #24
  00020	e1c230b0	 strh        r3, [r2]

; 223  :     WRITE_NAND(pDevice->pNandAddress, (sector & 0xFF));

  00024	e5902020	 ldr         r2, [r0, #0x20]
  00028	e20130ff	 and         r3, r1, #0xFF

; 224  :     WRITE_NAND(pDevice->pNandAddress, ((sector >> 8) & 0xFF));

  0002c	e1a0e801	 mov         lr, r1, lsl #16
  00030	e1c230b0	 strh        r3, [r2]
  00034	e5902020	 ldr         r2, [r0, #0x20]
  00038	e1a03c2e	 mov         r3, lr, lsr #24

; 225  :     WRITE_NAND(pDevice->pNandAddress, ((sector >> 16) & 0xFF));

  0003c	e1a01401	 mov         r1, r1, lsl #8
  00040	e1c230b0	 strh        r3, [r2]
  00044	e5902020	 ldr         r2, [r0, #0x20]
  00048	e1a03c21	 mov         r3, r1, lsr #24
  0004c	e1c230b0	 strh        r3, [r2]

; 226  : }

  00050	e8bd4010	 ldmia       sp!, {r4, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M46611|

			 ENDP  ; |SectorAccess|

	EXPORT	|BlockAccess|

  00000			 AREA	 |.pdata|, PDATA
|$T46623| DCD	|$LN5@BlockAcces|
	DCD	0x40000e00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BlockAccess| PROC

; 235  : {

  00000		 |$LN5@BlockAcces|
  00000		 |$M46620|

; 236  :     blockId *= pDevice->nandInfo.sectorsPerBlock;

  00000	e590304c	 ldr         r3, [r0, #0x4C]

; 237  :     WRITE_NAND(pDevice->pNandAddress, (blockId & 0xFF));

  00004	e5902020	 ldr         r2, [r0, #0x20]
  00008	e0010193	 mul         r1, r3, r1
  0000c	e20130ff	 and         r3, r1, #0xFF
  00010	e1c230b0	 strh        r3, [r2]

; 238  :     WRITE_NAND(pDevice->pNandAddress, ((blockId >> 8) & 0xFF));

  00014	e5902020	 ldr         r2, [r0, #0x20]
  00018	e1a03801	 mov         r3, r1, lsl #16
  0001c	e1a03c23	 mov         r3, r3, lsr #24
  00020	e1c230b0	 strh        r3, [r2]

; 239  :     WRITE_NAND(pDevice->pNandAddress, ((blockId >> 16) & 0xFF));

  00024	e5902020	 ldr         r2, [r0, #0x20]
  00028	e1a03401	 mov         r3, r1, lsl #8
  0002c	e1a03c23	 mov         r3, r3, lsr #24
  00030	e1c230b0	 strh        r3, [r2]

; 240  : }

  00034	e12fff1e	 bx          lr
  00038		 |$M46621|

			 ENDP  ; |BlockAccess|

	EXPORT	|WaitOnEmptyWriteBufferStatus|

  00000			 AREA	 |.pdata|, PDATA
|$T46633| DCD	|$LN9@WaitOnEmpt|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |WaitOnEmptyWriteBufferStatus| PROC

; 249  : {

  00000		 |$LN9@WaitOnEmpt|
  00000		 |$M46630|
  00000	e590202c	 ldr         r2, [r0, #0x2C]
  00004		 |$LL3@WaitOnEmpt|

; 250  :     UINT status;
; 251  :     do
; 252  :     {
; 253  :         status = INREG32(&pDevice->pGpmcRegs->GPMC_STATUS);

  00004	e5923054	 ldr         r3, [r2, #0x54]

; 254  :     } while ((status & GPMC_STATUS_EMPTYWRITEBUFFER) == 0);

  00008	e3130001	 tst         r3, #1
  0000c	0afffffc	 beq         |$LL3@WaitOnEmpt|

; 255  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M46631|

			 ENDP  ; |WaitOnEmptyWriteBufferStatus|

	EXPORT	|InitializePointers|

  00000			 AREA	 |.pdata|, PDATA
|$T46642| DCD	|$LN5@Initialize|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |InitializePointers| PROC

; 263  : {

  00000		 |$LN5@Initialize|
  00000		 |$M46639|

; 264  : #ifdef BOOT_MODE
; 265  :     UNREFERENCED_PARAMETER(szContext);
; 266  :     UNREFERENCED_PARAMETER(pDevice);
; 267  : #else
; 268  :     PHYSICAL_ADDRESS pa;
; 269  :     InitializeCriticalSection(&pDevice->cs);
; 270  : 
; 271  :     // Read device parameters
; 272  :     if (GetDeviceRegistryParams(
; 273  :             szContext, pDevice, dimof(g_deviceRegParams), g_deviceRegParams
; 274  :             ) != ERROR_SUCCESS)
; 275  :         {
; 276  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: FMD_Init: "
; 277  :             L"Failed read FMD registry parameters\r\n"
; 278  :             ));
; 279  :         return FALSE;
; 280  :         }
; 281  : 
; 282  :     pa.QuadPart = pDevice->memBase[0];
; 283  :     pDevice->pGpmcRegs = MmMapIoSpace(pa, pDevice->memLen[0], FALSE);
; 284  :     if (pDevice->pGpmcRegs == NULL)
; 285  :         {
; 286  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: FMD_Init: "
; 287  :             L"Failed map FMD registers (0x%08x/0x%08x)\r\n",
; 288  :             pDevice->memBase[0], pDevice->memLen[0]
; 289  :             ));
; 290  :         return FALSE;
; 291  :         }
; 292  : 
; 293  :     pa.QuadPart = pDevice->memBase[1];
; 294  :     pDevice->pFifo = (NANDREG*)MmMapIoSpace(pa, pDevice->memLen[1], FALSE);
; 295  :     if (pDevice->pFifo == NULL)
; 296  :         {
; 297  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: FMD_Init: "
; 298  :             L"Failed map FMD registers (0x%08x/0x%08x)\r\n",
; 299  :             pDevice->memBase[0], pDevice->memLen[0]
; 300  :             ));
; 301  :         return FALSE;
; 302  :         }
; 303  : #endif
; 304  :      return TRUE;

  00000	e3a00001	 mov         r0, #1

; 305  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M46640|

			 ENDP  ; |InitializePointers|

	EXPORT	|NAND_GetGpmcRegs|

  00000			 AREA	 |.pdata|, PDATA
|$T46652| DCD	|$LN5@NAND_GetGp|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_GetGpmcRegs| PROC

; 313  : {

  00000		 |$LN5@NAND_GetGp|
  00000		 |$M46649|

; 314  :     return ((NandDevice_t*)hNand)->pGpmcRegs;

  00000	e590002c	 ldr         r0, [r0, #0x2C]

; 315  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M46650|

			 ENDP  ; |NAND_GetGpmcRegs|

	EXPORT	|NAND_GetGeometry|

  00000			 AREA	 |.pdata|, PDATA
|$T46662| DCD	|$LN5@NAND_GetGe|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_GetGeometry| PROC

; 324  : {

  00000		 |$LN5@NAND_GetGe|
  00000		 |$M46659|

; 325  :     return &(((NandDevice_t*)hNand)->nandInfo);

  00000	e2800044	 add         r0, r0, #0x44

; 326  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M46660|

			 ENDP  ; |NAND_GetGeometry|


  00000			 AREA	 |.pdata|, PDATA
|$T46675| DCD	|$LN9@NAND_LockB|
	DCD	0x40000b00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_LockBlocks| PROC

; 336  : {

  00000		 |$LN9@NAND_LockB|
  00000		 |$M46672|
  00000	e1b02000	 movs        r2, r0

; 337  :     BOOL rc = FALSE; 

  00004	e3a00000	 mov         r0, #0

; 338  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 339  : 
; 340  :     UNREFERENCED_PARAMETER(blockEnd);
; 341  :     UNREFERENCED_PARAMETER(blockStart);
; 342  : 
; 343  :     if (pDevice == NULL) goto cleanUp;

  00008	0a000006	 beq         |$cleanUp$46005|

; 344  : 
; 345  :     if (bLock)
; 346  :         {
; 347  :         CLRREG32(&pDevice->pGpmcRegs->GPMC_CONFIG, GPMC_CONFIG_WRITEPROTECT);        

  0000c	e592202c	 ldr         r2, [r2, #0x2C]
  00010	e3530000	 cmp         r3, #0

; 348  :         }
; 349  :     else
; 350  :         {
; 351  :         SETREG32(&pDevice->pGpmcRegs->GPMC_CONFIG, GPMC_CONFIG_WRITEPROTECT);
; 352  :         }
; 353  :     rc = TRUE;

  00014	e3a00001	 mov         r0, #1
  00018	e5923050	 ldr         r3, [r2, #0x50]
  0001c	13c33010	 bicne       r3, r3, #0x10
  00020	03833010	 orreq       r3, r3, #0x10
  00024	e5823050	 str         r3, [r2, #0x50]
  00028		 |$cleanUp$46005|

; 354  : 
; 355  : cleanUp:
; 356  :     return rc;
; 357  : }

  00028	e12fff1e	 bx          lr
  0002c		 |$M46673|

			 ENDP  ; |NAND_LockBlocks|


  00000			 AREA	 |.pdata|, PDATA
|$T46682| DCD	|$LN5@NAND_Unini|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_Uninitialize| PROC

; 364  : {

  00000		 |$LN5@NAND_Unini|
  00000		 |$M46679|

; 365  : #ifdef BOOT_MODE
; 366  :     UNREFERENCED_PARAMETER(hNand);
; 367  : #else
; 368  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 369  : 
; 370  :     if (pDevice->pGpmcRegs != NULL)
; 371  :         {
; 372  :         MmUnmapIoSpace((void*)pDevice->pGpmcRegs, pDevice->memLen[0]);
; 373  :         }
; 374  : 
; 375  :     if (pDevice->pFifo != NULL)
; 376  :         {
; 377  :         MmUnmapIoSpace((void*)pDevice->pFifo, pDevice->memLen[1]);
; 378  :         }
; 379  : #endif
; 380  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M46680|

			 ENDP  ; |NAND_Uninitialize|


  00000			 AREA	 |.pdata|, PDATA
|$T46699| DCD	|$LN7@NAND_Seek|
	DCD	0x40001701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_Seek| PROC

; 538  : {

  00000		 |$LN7@NAND_Seek|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M46696|

; 539  :     // seek to address
; 540  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 541  :     SectorAccess(pDevice, sector, offset);

  00004	e590e020	 ldr         lr, [r0, #0x20]
  00008	e1a040a2	 mov         r4, r2, lsr #1
  0000c	e20430ff	 and         r3, r4, #0xFF
  00010	e1ce30b0	 strh        r3, [lr]
  00014	e5902020	 ldr         r2, [r0, #0x20]
  00018	e1a03804	 mov         r3, r4, lsl #16
  0001c	e1a03c23	 mov         r3, r3, lsr #24
  00020	e1c230b0	 strh        r3, [r2]
  00024	e5902020	 ldr         r2, [r0, #0x20]
  00028	e20130ff	 and         r3, r1, #0xFF
  0002c	e1a0e801	 mov         lr, r1, lsl #16
  00030	e1c230b0	 strh        r3, [r2]
  00034	e5902020	 ldr         r2, [r0, #0x20]
  00038	e1a03c2e	 mov         r3, lr, lsr #24
  0003c	e1a01401	 mov         r1, r1, lsl #8
  00040	e1c230b0	 strh        r3, [r2]
  00044	e5902020	 ldr         r2, [r0, #0x20]
  00048	e1a03c21	 mov         r3, r1, lsr #24

; 542  :     return TRUE;

  0004c	e3a00001	 mov         r0, #1
  00050	e1c230b0	 strh        r3, [r2]

; 543  : }

  00054	e8bd4010	 ldmia       sp!, {r4, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$M46697|

			 ENDP  ; |NAND_Seek|

	IMPORT	|ECC_Result|
	IMPORT	|ECC_Reset|
	IMPORT	|ECC_Init|
	IMPORT	|memcpy|

  00000			 AREA	 |.pdata|, PDATA
|$T46720| DCD	|$LN25@NAND_Read|
	DCD	0x40004001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_Read| PROC

; 553  : {

  00000		 |$LN25@NAND_Read|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M46717|
  00004	e1b08003	 movs        r8, r3
  00008	e1a06002	 mov         r6, r2
  0000c	e1a07001	 mov         r7, r1
  00010	e1a05000	 mov         r5, r0

; 554  :     UINT32 fifoLevel;
; 555  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 556  : 
; 557  :     // Start ECC if a valid ECC buffer is passed in
; 558  :     if (pEcc != NULL)
; 559  :         {
; 560  :         ECC_Init(pDevice->pGpmcRegs, pDevice->ECCCfg, pDevice->ECCtype, NAND_ECC_READ);

  00014	15952060	 ldrne       r2, [r5, #0x60]
  00018	15951058	 ldrne       r1, [r5, #0x58]
  0001c	1595002c	 ldrne       r0, [r5, #0x2C]
  00020	13a03000	 movne       r3, #0
  00024	1b000000	 blne        ECC_Init

; 561  :         }
; 562  : 
; 563  :     // enable prefetch if it's been properly configured
; 564  :     if (pDevice->prefetchMode == kPrefetchRead )

  00028	e595e018	 ldr         lr, [r5, #0x18]
  0002c	e35e0001	 cmp         lr, #1
  00030	1a000025	 bne         |$LN22@NAND_Read|

; 565  :         {
; 566  :         SETREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONTROL, 
; 567  :             GPMC_PREFETCH_CONTROL_STARTENGINE
; 568  :             );

  00034	e595402c	 ldr         r4, [r5, #0x2C]

; 569  : 
; 570  :         // start copying data into passed in buffer
; 571  :         while (size > 0)

  00038	e3560000	 cmp         r6, #0
  0003c	e594e1ec	 ldr         lr, [r4, #0x1EC]
  00040	e38ee001	 orr         lr, lr, #1
  00044	e584e1ec	 str         lr, [r4, #0x1EC]
  00048	da00000e	 ble         |$LN11@NAND_Read|
  0004c	e2463001	 sub         r3, r6, #1
  00050	e1a03323	 mov         r3, r3, lsr #6
  00054	e2834001	 add         r4, r3, #1
  00058		 |$LL12@NAND_Read|
  00058	e595202c	 ldr         r2, [r5, #0x2C]
  0005c		 |$LL10@NAND_Read|

; 572  :             {
; 573  :             // wait for fifo threshold to be reached
; 574  :             fifoLevel = 0;
; 575  :             while (fifoLevel < FIFO_THRESHOLD)
; 576  :                 {
; 577  :                 fifoLevel = INREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_STATUS);

  0005c	e59231f0	 ldr         r3, [r2, #0x1F0]
  00060	e203347f	 and         r3, r3, #0x7F, 8
  00064	e3530101	 cmp         r3, #1, 2
  00068	3afffffb	 bcc         |$LL10@NAND_Read|

; 578  :                 fifoLevel &= GPMC_PREFETCH_STATUS_FIFOMASK;
; 579  :                 fifoLevel >>= GPMC_PREFETCH_STATUS_FIFOSHIFT;
; 580  :                 }
; 581  : 
; 582  :             // copy data to buffer
; 583  :             memcpy(pData, (BYTE*)pDevice->pFifo, FIFO_THRESHOLD);

  0006c	e5951028	 ldr         r1, [r5, #0x28]
  00070	e3a02040	 mov         r2, #0x40
  00074	e1a00007	 mov         r0, r7
  00078	eb000000	 bl          memcpy

; 584  :             pData += FIFO_THRESHOLD;

  0007c	e2877040	 add         r7, r7, #0x40
  00080	e2544001	 subs        r4, r4, #1
  00084	1afffff3	 bne         |$LL12@NAND_Read|
  00088		 |$LN11@NAND_Read|

; 585  :             size -= FIFO_THRESHOLD;        
; 586  :             }
; 587  : 
; 588  :         // NOTE:
; 589  :         //  Prefetch engine will automatically stop on the completion
; 590  :         // of data transfer
; 591  :         pDevice->prefetchMode = kPrefetchOff;

  00088	e3a03000	 mov         r3, #0
  0008c	e5853018	 str         r3, [r5, #0x18]

; 592  :         }
; 593  :     else

  00090	ea00000f	 b           |$LN6@NAND_Read|
  00094		 |$LL7@NAND_Read|

; 598  :             {
; 599  :             *(NANDREG*)pData = READ_NAND(pDevice->pNandData);

  00094	e5953024	 ldr         r3, [r5, #0x24]

; 600  :             pData += sizeof(NANDREG);
; 601  :             size -= sizeof(NANDREG);

  00098	e2466002	 sub         r6, r6, #2
  0009c	e1d330b0	 ldrh        r3, [r3]
  000a0	e0c730b2	 strh        r3, [r7], #2

; 602  : 
; 603  : 	     /* workaround for BCH engine when ECC is not put at the end of OOB area.  
; 604  : 		  the checking is based on puting ECC at the BootROM expected location -
; 605  : 		  with 2 bytes offset from the start of the OOB area */
; 606  :             if(pDevice->ECCtype == BCH4bit || pDevice->ECCtype == BCH8bit)

  000a4	e5953060	 ldr         r3, [r5, #0x60]
  000a8	e3530001	 cmp         r3, #1
  000ac	0a000001	 beq         |$LN4@NAND_Read|
  000b0	e3530002	 cmp         r3, #2
  000b4	1a000004	 bne         |$LN22@NAND_Read|
  000b8		 |$LN4@NAND_Read|

; 607  :                 if (size == (int)(sizeof(NAND_SPARE_AREA) - ECC_OFFSET - pDevice->ECCsize))

  000b8	e5953064	 ldr         r3, [r5, #0x64]
  000bc	e263303e	 rsb         r3, r3, #0x3E
  000c0	e1560003	 cmp         r6, r3

; 608  :         	         ECC_Reset(pDevice->pGpmcRegs);  

  000c4	0595002c	 ldreq       r0, [r5, #0x2C]
  000c8	0b000000	 bleq        ECC_Reset
  000cc		 |$LN22@NAND_Read|

; 594  :         {
; 595  :         // NOTE:
; 596  :         //  Code assumes the entire page is read at once
; 597  :         while (size >= sizeof(NANDREG))

  000cc	e3560002	 cmp         r6, #2
  000d0	2affffef	 bcs         |$LL7@NAND_Read|
  000d4		 |$LN6@NAND_Read|

; 609  :                 }
; 610  :         }
; 611  : 
; 612  :     // get ECC result
; 613  :     if (pEcc != NULL)
; 614  :         {
; 615  :         // UNDONE:
; 616  :         //  should pass in sector size???
; 617  :         ECC_Result(pDevice->pGpmcRegs, pEcc, pDevice->ECCsize);

  000d4	e595002c	 ldr         r0, [r5, #0x2C]
  000d8	e3580000	 cmp         r8, #0
  000dc	0a000003	 beq         |$LN2@NAND_Read|
  000e0	e5952064	 ldr         r2, [r5, #0x64]
  000e4	e1a01008	 mov         r1, r8
  000e8	eb000000	 bl          ECC_Result

; 618  :         }
; 619  :     else

  000ec	ea000000	 b           |$LN1@NAND_Read|
  000f0		 |$LN2@NAND_Read|

; 620  :     	{
; 621  :     	ECC_Reset(pDevice->pGpmcRegs);

  000f0	eb000000	 bl          ECC_Reset
  000f4		 |$LN1@NAND_Read|

; 622  :     	}
; 623  :     return TRUE;

  000f4	e3a00001	 mov         r0, #1

; 624  : }

  000f8	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000fc	e12fff1e	 bx          lr
  00100		 |$M46718|

			 ENDP  ; |NAND_Read|


  00000			 AREA	 |.pdata|, PDATA
|$T46749| DCD	|$LN28@NAND_Write|
	DCD	0x40004201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_Write| PROC

; 635  : {

  00000		 |$LN28@NAND_Write|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M46746|
  00004	e1b08003	 movs        r8, r3
  00008	e1a06002	 mov         r6, r2
  0000c	e1a07001	 mov         r7, r1
  00010	e1a05000	 mov         r5, r0

; 636  :     UINT32 fifoLevel;
; 637  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 638  : 
; 639  :     // Start ECC if a valid ECC buffer is passed in
; 640  :     if (pEcc != NULL)
; 641  :         {
; 642  :         ECC_Init(pDevice->pGpmcRegs, pDevice->ECCCfg, pDevice->ECCtype, NAND_ECC_WRITE);

  00014	15952060	 ldrne       r2, [r5, #0x60]
  00018	15951058	 ldrne       r1, [r5, #0x58]
  0001c	1595002c	 ldrne       r0, [r5, #0x2C]
  00020	13a03001	 movne       r3, #1
  00024	1b000000	 blne        ECC_Init

; 643  :         }
; 644  : 
; 645  :     // enable prefetch if it's been properly configured
; 646  :     if (pDevice->prefetchMode == kPrefetchWrite )

  00028	e595e018	 ldr         lr, [r5, #0x18]
  0002c	e35e0002	 cmp         lr, #2
  00030	1a000017	 bne         |$LN11@NAND_Write|

; 647  :         {
; 648  :         SETREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONTROL, 
; 649  :             GPMC_PREFETCH_CONTROL_STARTENGINE
; 650  :             );

  00034	e595402c	 ldr         r4, [r5, #0x2C]

; 651  :         // start copying data into passed in buffer
; 652  :         while (size > 0)

  00038	e3560000	 cmp         r6, #0
  0003c	e594e1ec	 ldr         lr, [r4, #0x1EC]
  00040	e38ee001	 orr         lr, lr, #1
  00044	e584e1ec	 str         lr, [r4, #0x1EC]
  00048	da00000e	 ble         |$LN9@NAND_Write|
  0004c	e2463001	 sub         r3, r6, #1
  00050	e1a03323	 mov         r3, r3, lsr #6
  00054	e2834001	 add         r4, r3, #1
  00058		 |$LL10@NAND_Write|

; 653  :             {
; 654  :             // copy data to buffer
; 655  :             memcpy((BYTE*)pDevice->pFifo, pData, FIFO_THRESHOLD);

  00058	e5950028	 ldr         r0, [r5, #0x28]
  0005c	e3a02040	 mov         r2, #0x40
  00060	e1a01007	 mov         r1, r7
  00064	eb000000	 bl          memcpy

; 656  :             pData += FIFO_THRESHOLD;

  00068	e595202c	 ldr         r2, [r5, #0x2C]
  0006c	e2877040	 add         r7, r7, #0x40
  00070		 |$LL8@NAND_Write|

; 657  :             size -= FIFO_THRESHOLD;  
; 658  :             
; 659  :             // wait for fifo threshold to be reached
; 660  :             fifoLevel = 0;
; 661  :             while (fifoLevel < FIFO_THRESHOLD)
; 662  :                 {
; 663  :                 fifoLevel = INREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_STATUS);

  00070	e59231f0	 ldr         r3, [r2, #0x1F0]
  00074	e203347f	 and         r3, r3, #0x7F, 8
  00078	e3530101	 cmp         r3, #1, 2
  0007c	3afffffb	 bcc         |$LL8@NAND_Write|

; 651  :         // start copying data into passed in buffer
; 652  :         while (size > 0)

  00080	e2544001	 subs        r4, r4, #1
  00084	1afffff3	 bne         |$LL10@NAND_Write|
  00088		 |$LN9@NAND_Write|

; 664  :                 fifoLevel &= GPMC_PREFETCH_STATUS_FIFOMASK;
; 665  :                 fifoLevel >>= GPMC_PREFETCH_STATUS_FIFOSHIFT;
; 666  :                 }
; 667  :             }
; 668  : 
; 669  :         // NOTE:
; 670  :         //  Prefetch engine will automatically stop on the completion
; 671  :         // of data transfer
; 672  :         pDevice->prefetchMode = kPrefetchOff;

  00088	e3a03000	 mov         r3, #0
  0008c	e5853018	 str         r3, [r5, #0x18]

; 673  :         }
; 674  :     else

  00090	ea000011	 b           |$LN4@NAND_Write|
  00094		 |$LN11@NAND_Write|

; 675  :         {
; 676  :         int writeCount = 0;

  00094	e3a01000	 mov         r1, #0

; 677  : 		
; 678  :         while (size >= sizeof(NANDREG))

  00098	e3560002	 cmp         r6, #2
  0009c	3a00000e	 bcc         |$LN4@NAND_Write|

; 675  :         {
; 676  :         int writeCount = 0;

  000a0	e1a000a6	 mov         r0, r6, lsr #1
  000a4		 |$LL5@NAND_Write|

; 679  :             {
; 680  :             WRITE_NAND(pDevice->pNandData, *(NANDREG*)pData);

  000a4	e5952024	 ldr         r2, [r5, #0x24]
  000a8	e1d730b0	 ldrh        r3, [r7]

; 681  : 
; 682  :             // Workaround Errata 1.53
; 683  :             // need to check on EMPTYWRITEBUFFERSTATUS on every
; 684  :             // 255 bytes
; 685  :             if (++writeCount >= 255)

  000ac	e2811001	 add         r1, r1, #1
  000b0	e35100ff	 cmp         r1, #0xFF
  000b4	e1c230b0	 strh        r3, [r2]
  000b8	ba000004	 blt         |$LN3@NAND_Write|
  000bc	e595202c	 ldr         r2, [r5, #0x2C]

; 686  :                 {
; 687  :                 WaitOnEmptyWriteBufferStatus(pDevice);

  000c0		 |$LL17@NAND_Write|
  000c0	e5923054	 ldr         r3, [r2, #0x54]
  000c4	e3130001	 tst         r3, #1
  000c8	0afffffc	 beq         |$LL17@NAND_Write|

; 688  :                 writeCount = 0;

  000cc	e3a01000	 mov         r1, #0
  000d0		 |$LN3@NAND_Write|

; 689  :                 }
; 690  :             
; 691  :             pData += sizeof(NANDREG);

  000d0	e2877002	 add         r7, r7, #2
  000d4	e2500001	 subs        r0, r0, #1
  000d8	1afffff1	 bne         |$LL5@NAND_Write|
  000dc		 |$LN4@NAND_Write|

; 692  :             size -= sizeof(NANDREG);
; 693  :             }
; 694  : 		
; 695  :         }
; 696  : 
; 697  :     // get ECC result
; 698  :     if (pEcc != NULL)
; 699  :         {
; 700  :         ECC_Result(pDevice->pGpmcRegs, pEcc, pDevice->ECCsize);

  000dc	e595002c	 ldr         r0, [r5, #0x2C]
  000e0	e3580000	 cmp         r8, #0
  000e4	0a000003	 beq         |$LN2@NAND_Write|
  000e8	e5952064	 ldr         r2, [r5, #0x64]
  000ec	e1a01008	 mov         r1, r8
  000f0	eb000000	 bl          ECC_Result

; 701  :         }
; 702  :     else

  000f4	ea000000	 b           |$LN1@NAND_Write|
  000f8		 |$LN2@NAND_Write|

; 703  :     	{
; 704  : 	 ECC_Reset(pDevice->pGpmcRegs);

  000f8	eb000000	 bl          ECC_Reset
  000fc		 |$LN1@NAND_Write|

; 705  :     	}
; 706  :     return TRUE;

  000fc	e3a00001	 mov         r0, #1

; 707  : }

  00100	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00104	e12fff1e	 bx          lr
  00108		 |$M46747|

			 ENDP  ; |NAND_Write|


  00000			 AREA	 |.pdata|, PDATA
|$T46759| DCD	|$LN5@NAND_GetSt|
	DCD	0x40000600
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_GetStatus| PROC

; 714  : {

  00000		 |$LN5@NAND_GetSt|
  00000		 |$M46756|

; 715  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 716  : 
; 717  :     // request status
; 718  :     WRITE_NAND(pDevice->pNandCmd, NAND_CMD_STATUS);

  00000	e590301c	 ldr         r3, [r0, #0x1C]
  00004	e3a02070	 mov         r2, #0x70
  00008	e1c320b0	 strh        r2, [r3]

; 719  :     return READ_NAND(pDevice->pNandData);

  0000c	e5903024	 ldr         r3, [r0, #0x24]
  00010	e1d300b0	 ldrh        r0, [r3]

; 720  : }

  00014	e12fff1e	 bx          lr
  00018		 |$M46757|

			 ENDP  ; |NAND_GetStatus|


  00000			 AREA	 |.pdata|, PDATA
|$T46770| DCD	|$LN8@NAND_Enabl|
	DCD	0x40001b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_Enable| PROC

; 745  : {

  00000		 |$LN8@NAND_Enabl|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46767|

; 746  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 747  : 
; 748  :     if (pDevice->IrqWait)

  00004	e590305c	 ldr         r3, [r0, #0x5C]
  00008	e1b0e003	 movs        lr, r3
  0000c	0a000013	 beq         |$LN1@NAND_Enabl|

; 749  :     {
; 750  :         if( bEnable )
; 751  :         {
; 752  :             // Enable GPMC wait-to-nowait edge detection mechanism on NAND R/B pin
; 753  :             SETREG32 (&pDevice->pGpmcRegs->GPMC_IRQENABLE, pDevice->IrqWait);

  00010	e590202c	 ldr         r2, [r0, #0x2C]
  00014	e3510000	 cmp         r1, #0
  00018	0a000008	 beq         |$LN2@NAND_Enabl|
  0001c	e592301c	 ldr         r3, [r2, #0x1C]
  00020	e183300e	 orr         r3, r3, lr
  00024	e582301c	 str         r3, [r2, #0x1C]

; 754  : 
; 755  :             //  Reset IRQ status
; 756  :             SETREG32 (&pDevice->pGpmcRegs->GPMC_IRQSTATUS, pDevice->IrqWait);

  00028	e590102c	 ldr         r1, [r0, #0x2C]
  0002c	e590205c	 ldr         r2, [r0, #0x5C]
  00030	e5913018	 ldr         r3, [r1, #0x18]
  00034	e1833002	 orr         r3, r3, r2
  00038	e5813018	 str         r3, [r1, #0x18]

; 757  :         }
; 758  :         else

  0003c	ea000007	 b           |$LN1@NAND_Enabl|
  00040		 |$LN2@NAND_Enabl|

; 759  :         {
; 760  :             //  Reset IRQ status
; 761  :             SETREG32 (&pDevice->pGpmcRegs->GPMC_IRQSTATUS, pDevice->IrqWait);

  00040	e5923018	 ldr         r3, [r2, #0x18]
  00044	e183300e	 orr         r3, r3, lr
  00048	e5823018	 str         r3, [r2, #0x18]

; 762  : 
; 763  :             // Disable GPMC wait-to-nowait edge detection mechanism on NAND R/B pin
; 764  :             CLRREG32 (&pDevice->pGpmcRegs->GPMC_IRQENABLE, pDevice->IrqWait);

  0004c	e590102c	 ldr         r1, [r0, #0x2C]
  00050	e590205c	 ldr         r2, [r0, #0x5C]
  00054	e591301c	 ldr         r3, [r1, #0x1C]
  00058	e1c33002	 bic         r3, r3, r2
  0005c	e581301c	 str         r3, [r1, #0x1C]
  00060		 |$LN1@NAND_Enabl|

; 765  :         }
; 766  :     }
; 767  :     return TRUE;

  00060	e3a00001	 mov         r0, #1

; 768  : }

  00064	e49de004	 ldr         lr, [sp], #4
  00068	e12fff1e	 bx          lr
  0006c		 |$M46768|

			 ENDP  ; |NAND_Enable|


  00000			 AREA	 |.pdata|, PDATA
|$T46779| DCD	|$LN5@NAND_Mutex|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_MutexEnter| PROC

; 775  : {   

  00000		 |$LN5@NAND_Mutex|
  00000		 |$M46776|

; 776  : #ifdef DEVICE_MODE
; 777  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 778  :     EnterCriticalSection(&pDevice->cs); 
; 779  :     return pDevice->cs.LockCount;
; 780  : #else
; 781  :     UNREFERENCED_PARAMETER(hNand);
; 782  :     return 0;

  00000	e3a00000	 mov         r0, #0

; 783  : #endif
; 784  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M46777|

			 ENDP  ; |NAND_MutexEnter|


  00000			 AREA	 |.pdata|, PDATA
|$T46788| DCD	|$LN5@NAND_Mutex@2|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_MutexExit| PROC

; 791  : {

  00000		 |$LN5@NAND_Mutex@2|
  00000		 |$M46785|

; 792  : #ifdef DEVICE_MODE
; 793  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 794  :     LeaveCriticalSection(&pDevice->cs); 
; 795  :     return pDevice->cs.LockCount;
; 796  : #else
; 797  :     UNREFERENCED_PARAMETER(hNand);
; 798  :     return 0;

  00000	e3a00000	 mov         r0, #0

; 799  : #endif
; 800  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M46786|

			 ENDP  ; |NAND_MutexExit|


  00000			 AREA	 |.pdata|, PDATA
|$T46799| DCD	|$LN5@NAND_SendC|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_SendCommand| PROC

; 808  : {

  00000		 |$LN5@NAND_SendC|
  00000		 |$M46796|
  00000	e1a02001	 mov         r2, r1

; 809  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 810  :     WRITE_NAND(pDevice->pNandCmd, cmd);

  00004	e590301c	 ldr         r3, [r0, #0x1C]

; 811  :     return TRUE;

  00008	e3a00001	 mov         r0, #1
  0000c	e1c320b0	 strh        r2, [r3]

; 812  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M46797|

			 ENDP  ; |NAND_SendCommand|

	IMPORT	|BSPGetNandCS|

  00000			 AREA	 |.pdata|, PDATA
|$T46813| DCD	|$LN8@NAND_Confi|
	DCD	0x40001d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_ConfigurePrefetch| PROC

; 820  : {

  00000		 |$LN8@NAND_Confi|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M46810|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 821  :     DWORD chipSelect = BSPGetNandCS();

  0000c	eb000000	 bl          BSPGetNandCS

; 822  :     UINT ffPrefetchMode = 0;
; 823  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 824  : 
; 825  :     // disable prefetch engine
; 826  :     pDevice->prefetchMode = kPrefetchOff;
; 827  :     
; 828  :     OUTREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONTROL, 0);
; 829  : 
; 830  :     // set prefetch mask
; 831  :     ffPrefetchMode = GPMC_PREFETCH_CONFIG_PFPWENROUNDROBIN |
; 832  :                      GPMC_PREFETCH_CONFIG_ENABLEOPTIMIZEDACCESS |
; 833  :                      GPMC_PREFETCH_CONFIG_WAITPINSELECTOR(chipSelect) |
; 834  :                      GPMC_PREFETCH_CONFIG_FIFOTHRESHOLD(FIFO_THRESHOLD) |
; 835  :                      GPMC_PREFETCH_CONFIG_ENGINECSSELECTOR(chipSelect);

  00010	e2002007	 and         r2, r0, #7
  00014	e2003003	 and         r3, r0, #3
  00018	e3a01722	 mov         r1, #0x22, 14
  0001c	e1832a02	 orr         r2, r3, r2, lsl #20
  00020	e3813b01	 orr         r3, r1, #1, 22
  00024	e595e02c	 ldr         lr, [r5, #0x2C]
  00028	e1823003	 orr         r3, r2, r3

; 836  : 
; 837  :     if (accessType == NAND_DATA_WRITE)

  0002c	e3540002	 cmp         r4, #2
  00030	e1a02203	 mov         r2, r3, lsl #4
  00034	e3a01000	 mov         r1, #0

; 838  :         {
; 839  :         pDevice->prefetchMode = kPrefetchWrite;

  00038	03a03002	 moveq       r3, #2

; 840  :         ffPrefetchMode |= GPMC_PREFETCH_CONFIG_WRITEPOST;
; 841  :         }
; 842  :     else
; 843  :         {
; 844  :         pDevice->prefetchMode = kPrefetchRead;

  0003c	13a03001	 movne       r3, #1
  00040	e5851018	 str         r1, [r5, #0x18]
  00044	e58e11ec	 str         r1, [lr, #0x1EC]
  00048	e5853018	 str         r3, [r5, #0x18]

; 845  :         }
; 846  :         
; 847  :     OUTREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONFIG1, ffPrefetchMode);

  0004c	e595302c	 ldr         r3, [r5, #0x2C]
  00050	03822001	 orreq       r2, r2, #1

; 848  : 
; 849  :     SETREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONFIG1, 
; 850  :         GPMC_PREFETCH_CONFIG_ENABLEENGINE
; 851  :         );
; 852  : 
; 853  :     return TRUE;

  00054	e3a00001	 mov         r0, #1
  00058	e58321e0	 str         r2, [r3, #0x1E0]
  0005c	e595202c	 ldr         r2, [r5, #0x2C]
  00060	e59231e0	 ldr         r3, [r2, #0x1E0]
  00064	e3833080	 orr         r3, r3, #0x80
  00068	e58231e0	 str         r3, [r2, #0x1E0]

; 854  : }

  0006c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00070	e12fff1e	 bx          lr
  00074		 |$M46811|

			 ENDP  ; |NAND_ConfigurePrefetch|

	EXPORT	|NAND_CorrectEccData|
	IMPORT	|ECC_CorrectData|
	IMPORT	|memcmp|

  00000			 AREA	 |.pdata|, PDATA
|$T46829| DCD	|$LN7@NAND_Corre|
	DCD	0x40001b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_CorrectEccData| PROC

; 866  : {

  00000		 |$LN7@NAND_Corre|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M46826|
  00008	e1a05003	 mov         r5, r3
  0000c	e1a08002	 mov         r8, r2
  00010	e1a09001	 mov         r9, r1
  00014	e1a06000	 mov         r6, r0

; 867  :     BOOL rc = FALSE;
; 868  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 869  :     
; 870  :     // this call assumes the array size of pEccOld and pEccNew are of the 
; 871  :     // correct size to hold all the parity bits of the given size    
; 872  :     if (memcmp(pEccOld, pEccNew, pDevice->ECCsize) != 0)

  00018	e59d7020	 ldr         r7, [sp, #0x20]
  0001c	e5962064	 ldr         r2, [r6, #0x64]
  00020	e1a00005	 mov         r0, r5
  00024	e1a01007	 mov         r1, r7
  00028	e3a04000	 mov         r4, #0
  0002c	eb000000	 bl          memcmp
  00030	e3500000	 cmp         r0, #0
  00034	0a000007	 beq         |$LN1@NAND_Corre|

; 873  :         {
; 874  :         
; 875  :         // check if data is correctable        
; 876  :         if (ECC_CorrectData(pDevice->pGpmcRegs, pData, size, pEccOld, pEccNew) == FALSE)

  00038	e596002c	 ldr         r0, [r6, #0x2C]
  0003c	e1a03005	 mov         r3, r5
  00040	e1a02008	 mov         r2, r8
  00044	e1a01009	 mov         r1, r9
  00048	e58d7000	 str         r7, [sp]
  0004c	eb000000	 bl          ECC_CorrectData
  00050	e3500000	 cmp         r0, #0
  00054	0a000000	 beq         |$cleanUp$46258|
  00058		 |$LN1@NAND_Corre|

; 877  :             {
; 878  :             goto cleanUp;
; 879  :             }
; 880  :         }    
; 881  : 
; 882  :     rc = TRUE;

  00058	e3a04001	 mov         r4, #1
  0005c		 |$cleanUp$46258|

; 883  :     
; 884  : cleanUp:
; 885  :     return rc;
; 886  : }

  0005c	e1a00004	 mov         r0, r4
  00060	e28dd004	 add         sp, sp, #4
  00064	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00068	e12fff1e	 bx          lr
  0006c		 |$M46827|

			 ENDP  ; |NAND_CorrectEccData|

	EXPORT	|WaitForReadyStatus|

  00000			 AREA	 |.pdata|, PDATA
|$T46842| DCD	|$LN10@WaitForRea|
	DCD	0x40000800
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |WaitForReadyStatus| PROC

; 897  : {

  00000		 |$LN10@WaitForRea|
  00000		 |$M46839|
  00000	e3a02070	 mov         r2, #0x70
  00004		 |$LL2@WaitForRea|

; 898  :     //  Wait for a Ready status
; 899  :     while ((NAND_GetStatus(hNand) & NAND_STATUS_READY) == 0); 

  00004	e590301c	 ldr         r3, [r0, #0x1C]
  00008	e1c320b0	 strh        r2, [r3]
  0000c	e5903024	 ldr         r3, [r0, #0x24]
  00010	e1d330b0	 ldrh        r3, [r3]
  00014	e3130040	 tst         r3, #0x40
  00018	0afffff9	 beq         |$LL2@WaitForRea|

; 900  : }

  0001c	e12fff1e	 bx          lr
  00020		 |$M46840|

			 ENDP  ; |WaitForReadyStatus|

	EXPORT	|FMD_Deinit|

  00000			 AREA	 |.pdata|, PDATA
|$T46888| DCD	|$LN24@FMD_Deinit|
	DCD	0x40002101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FMD_Deinit| PROC

; 939  : {

  00000		 |$LN24@FMD_Deinit|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M46885|

; 940  :     BOOL rc = FALSE;
; 941  :     if (pContext != s_hNand) goto cleanUp;

  00004	e59f5074	 ldr         r5, [pc, #0x74]
  00008	e5954000	 ldr         r4, [r5]
  0000c	e1500004	 cmp         r0, r4
  00010	1a000017	 bne         |$cleanUp$46283|

; 942  : 
; 943  :     //  Only enable during NAND read/write/erase operations
; 944  :     NAND_Enable(s_hNand, TRUE);

  00014	e3a01001	 mov         r1, #1
  00018	e1a00004	 mov         r0, r4
  0001c	eb000000	 bl          NAND_Enable
  00020	e3a01070	 mov         r1, #0x70

; 945  : 
; 946  :     // Wait for NAND    
; 947  :     // the next command may not work if you remove this wait on the status, 
; 948  :     // because if the R/B pin is asserted during the reset, its deassertion 
; 949  :     // isn't guaranteed to mean that the device is ready
; 950  :     WaitForReadyStatus(s_hNand);   

  00024		 |$LL5@FMD_Deinit|
  00024	e594301c	 ldr         r3, [r4, #0x1C]
  00028	e1c310b0	 strh        r1, [r3]
  0002c	e5943024	 ldr         r3, [r4, #0x24]
  00030	e1d330b0	 ldrh        r3, [r3]
  00034	e3130040	 tst         r3, #0x40
  00038	0afffff9	 beq         |$LL5@FMD_Deinit|

; 951  : 
; 952  :     // Write RESET command
; 953  :     // (a reset aborts any current READ, WRITE (PROGRAM) or ERASE operation)
; 954  :     NAND_SendCommand(s_hNand, NAND_CMD_RESET);

  0003c	e594301c	 ldr         r3, [r4, #0x1C]
  00040	e3a020ff	 mov         r2, #0xFF
  00044	e1c320b0	 strh        r2, [r3]

; 955  : 
; 956  :     // Wait for NAND
; 957  :     WaitForReadyStatus(s_hNand);

  00048		 |$LL13@FMD_Deinit|
  00048	e594301c	 ldr         r3, [r4, #0x1C]
  0004c	e1c310b0	 strh        r1, [r3]
  00050	e5943024	 ldr         r3, [r4, #0x24]
  00054	e1d330b0	 ldrh        r3, [r3]
  00058	e3130040	 tst         r3, #0x40
  0005c	0afffff9	 beq         |$LL13@FMD_Deinit|

; 958  : 
; 959  :     // Clear GPMC wait-to-nowait edge detection mechanism on NAND R/B pin
; 960  :     NAND_Enable(s_hNand, FALSE);

  00060	e3a01000	 mov         r1, #0
  00064	e1a00004	 mov         r0, r4
  00068	eb000000	 bl          NAND_Enable

; 961  : 
; 962  :     // uninitialize and release allocated resources
; 963  :     NAND_Uninitialize(s_hNand);
; 964  :     s_hNand = NULL;

  0006c	e3a03000	 mov         r3, #0
  00070	e5853000	 str         r3, [r5]
  00074		 |$cleanUp$46283|

; 965  :     
; 966  : cleanUp:
; 967  :     return rc;

  00074	e3a00000	 mov         r0, #0

; 968  : }

  00078	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$LN25@FMD_Deinit|
  00080		 |$LN26@FMD_Deinit|
  00080	00000000	 DCD         |s_hNand|
  00084		 |$M46886|

			 ENDP  ; |FMD_Deinit|

	EXPORT	|FMD_GetInfo|

  00000			 AREA	 |.pdata|, PDATA
|$T46916| DCD	|$LN16@FMD_GetInf|
	DCD	0x40001801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FMD_GetInfo| PROC

; 980  : {

  00000		 |$LN16@FMD_GetInf|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46913|
  00004	e1a0e000	 mov         lr, r0

; 981  :     BOOL rc = FALSE;
; 982  : 
; 983  :     // If we don't support NAND, fail...
; 984  :     if (s_hNand == NULL) goto cleanUp;

  00008	e59f304c	 ldr         r3, [pc, #0x4C]
  0000c	e3a00000	 mov         r0, #0
  00010	e5931000	 ldr         r1, [r3]
  00014	e3510000	 cmp         r1, #0
  00018	0a00000d	 beq         |$cleanUp$46291|

; 985  : 
; 986  :     // Memory type is NAND
; 987  :     pFlashInfo->flashType = NAND;

  0001c	e3a03000	 mov         r3, #0
  00020	e58e3000	 str         r3, [lr]

; 988  :     pFlashInfo->dwNumBlocks = NAND_GetGeometry(s_hNand)->blocks;

  00024	e5913048	 ldr         r3, [r1, #0x48]

; 989  :     pFlashInfo->wSectorsPerBlock = (WORD) NAND_GetGeometry(s_hNand)->sectorsPerBlock;
; 990  :     pFlashInfo->wDataBytesPerSector = (WORD) NAND_GetGeometry(s_hNand)->sectorSize;
; 991  :     pFlashInfo->dwBytesPerBlock = NAND_GetGeometry(s_hNand)->sectorSize;
; 992  :     pFlashInfo->dwBytesPerBlock *= NAND_GetGeometry(s_hNand)->sectorsPerBlock;
; 993  : 
; 994  :     // Done
; 995  :     rc = TRUE;

  00028	e3a00001	 mov         r0, #1
  0002c	e58e3004	 str         r3, [lr, #4]
  00030	e591304c	 ldr         r3, [r1, #0x4C]
  00034	e1ce30bc	 strh        r3, [lr, #0xC]
  00038	e5913050	 ldr         r3, [r1, #0x50]
  0003c	e1ce30be	 strh        r3, [lr, #0xE]
  00040	e5912050	 ldr         r2, [r1, #0x50]
  00044	e58e2008	 str         r2, [lr, #8]
  00048	e591304c	 ldr         r3, [r1, #0x4C]
  0004c	e0020293	 mul         r2, r3, r2
  00050	e58e2008	 str         r2, [lr, #8]
  00054		 |$cleanUp$46291|

; 996  : 
; 997  : cleanUp:
; 998  :     return rc;
; 999  : }

  00054	e49de004	 ldr         lr, [sp], #4
  00058	e12fff1e	 bx          lr
  0005c		 |$LN17@FMD_GetInf|
  0005c		 |$LN18@FMD_GetInf|
  0005c	00000000	 DCD         |s_hNand|
  00060		 |$M46914|

			 ENDP  ; |FMD_GetInfo|

	EXPORT	|FMD_ReadSectorOOB|

  00000			 AREA	 |.pdata|, PDATA
|$T47008| DCD	|$LN43@FMD_ReadSe|
	DCD	0x40004701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FMD_ReadSectorOOB| PROC

; 1012 : {

  00000		 |$LN43@FMD_ReadSe|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M47005|
  00004	e1a06001	 mov         r6, r1
  00008	e1a07000	 mov         r7, r0

; 1013 :     BOOL rc = FALSE;
; 1014 :     UINT32 oldIdleMode;
; 1015 :     UINT32 sectorSize;
; 1016 : 
; 1017 :     // Fail if FMD wasn't opened
; 1018 :     if (s_hNand == NULL) goto cleanUp;

  0000c	e59f5104	 ldr         r5, [pc, #0x104]
  00010	e3a00000	 mov         r0, #0
  00014	e5954000	 ldr         r4, [r5]
  00018	e3540000	 cmp         r4, #0
  0001c	0a00003b	 beq         |$cleanUp$46305|

; 1019 :     
; 1020 :     NAND_MutexEnter(s_hNand);
; 1021 : 
; 1022 :     //  Change idle mode to no-idle to ensure access to GPMC registers
; 1023 :     sectorSize = NAND_GetGeometry(s_hNand)->sectorSize;
; 1024 :     oldIdleMode = INREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG));

  00020	e594302c	 ldr         r3, [r4, #0x2C]

; 1025 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), SYSCONFIG_NOIDLE);

  00024	e5949050	 ldr         r9, [r4, #0x50]
  00028	e3a02008	 mov         r2, #8
  0002c	e5938010	 ldr         r8, [r3, #0x10]

; 1026 :     
; 1027 :         {
; 1028 :         //  Only enable during NAND read/write/erase operations
; 1029 :         NAND_Enable(s_hNand, TRUE);

  00030	e3a01001	 mov         r1, #1
  00034	e1a00004	 mov         r0, r4
  00038	e5832010	 str         r2, [r3, #0x10]
  0003c	eb000000	 bl          NAND_Enable
  00040	e3a00070	 mov         r0, #0x70

; 1030 : 
; 1031 :         // Make sure of the NAND status
; 1032 :         WaitForReadyStatus(s_hNand);

  00044		 |$LL14@FMD_ReadSe|
  00044	e594301c	 ldr         r3, [r4, #0x1C]
  00048	e1c300b0	 strh        r0, [r3]
  0004c	e5943024	 ldr         r3, [r4, #0x24]
  00050	e1d330b0	 ldrh        r3, [r3]
  00054	e3130040	 tst         r3, #0x40
  00058	0afffff9	 beq         |$LL14@FMD_ReadSe|

; 1033 : 
; 1034 :         // Send the command
; 1035 :         NAND_SendCommand(s_hNand, NAND_CMD_READ1);

  0005c	e594301c	 ldr         r3, [r4, #0x1C]
  00060	e3a0a000	 mov         r10, #0

; 1036 : 
; 1037 :         // Send the address
; 1038 :         NAND_Seek(s_hNand, sector, sectorSize);

  00064	e1a010a9	 mov         r1, r9, lsr #1
  00068	e1c3a0b0	 strh        r10, [r3]
  0006c	e5942020	 ldr         r2, [r4, #0x20]
  00070	e20130ff	 and         r3, r1, #0xFF
  00074	e1a01801	 mov         r1, r1, lsl #16
  00078	e1c230b0	 strh        r3, [r2]
  0007c	e5942020	 ldr         r2, [r4, #0x20]
  00080	e1a03c21	 mov         r3, r1, lsr #24
  00084	e20710ff	 and         r1, r7, #0xFF
  00088	e1c230b0	 strh        r3, [r2]
  0008c	e5942020	 ldr         r2, [r4, #0x20]
  00090	e1a03807	 mov         r3, r7, lsl #16
  00094	e1a0ec23	 mov         lr, r3, lsr #24
  00098	e1c210b0	 strh        r1, [r2]
  0009c	e5942020	 ldr         r2, [r4, #0x20]
  000a0	e1a03407	 mov         r3, r7, lsl #8
  000a4	e1a01c23	 mov         r1, r3, lsr #24
  000a8	e1c2e0b0	 strh        lr, [r2]
  000ac	e5943020	 ldr         r3, [r4, #0x20]

; 1039 : 
; 1040 :         // Send the command
; 1041 :         NAND_SendCommand(s_hNand, NAND_CMD_READ2);

  000b0	e3a02030	 mov         r2, #0x30
  000b4	e1c310b0	 strh        r1, [r3]
  000b8	e594301c	 ldr         r3, [r4, #0x1C]
  000bc	e1c320b0	 strh        r2, [r3]

; 1042 : 
; 1043 :         // Wait for the action to finish
; 1044 :         WaitForReadyStatus(s_hNand);

  000c0		 |$LL28@FMD_ReadSe|
  000c0	e594301c	 ldr         r3, [r4, #0x1C]
  000c4	e1c300b0	 strh        r0, [r3]
  000c8	e5943024	 ldr         r3, [r4, #0x24]
  000cc	e1d330b0	 ldrh        r3, [r3]
  000d0	e3130040	 tst         r3, #0x40
  000d4	0afffff9	 beq         |$LL28@FMD_ReadSe|

; 1045 : 
; 1046 :         //Force a read here, else we will read the status again
; 1047 :         NAND_SendCommand (s_hNand, NAND_CMD_READ1);

  000d8	e594101c	 ldr         r1, [r4, #0x1C]

; 1048 : 
; 1049 :         // read spare area
; 1050 :         NAND_Read(s_hNand, (BYTE*)pBuffer, 64, NULL);

  000dc	e3a03000	 mov         r3, #0
  000e0	e3a02040	 mov         r2, #0x40
  000e4	e1c1a0b0	 strh        r10, [r1]
  000e8	e1a01006	 mov         r1, r6
  000ec	e1a00004	 mov         r0, r4
  000f0	eb000000	 bl          NAND_Read

; 1051 :         
; 1052 :         //  Only enable during NAND read/write/erase operations
; 1053 :         NAND_Enable(s_hNand, FALSE);

  000f4	e5954000	 ldr         r4, [r5]
  000f8	e3a01000	 mov         r1, #0
  000fc	e1a00004	 mov         r0, r4
  00100	eb000000	 bl          NAND_Enable

; 1054 : 
; 1055 :         }
; 1056 : 
; 1057 :     //  Change idle mode back
; 1058 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), oldIdleMode);

  00104	e594302c	 ldr         r3, [r4, #0x2C]

; 1059 :     
; 1060 :     // Done
; 1061 :     rc = TRUE;

  00108	e3a00001	 mov         r0, #1
  0010c	e5838010	 str         r8, [r3, #0x10]
  00110		 |$cleanUp$46305|

; 1062 : 
; 1063 : cleanUp:
; 1064 :     // Release hardware lock
; 1065 :     if (s_hNand != NULL) NAND_MutexExit(s_hNand);
; 1066 :     
; 1067 :     ASSERT(rc);
; 1068 :     return rc;
; 1069 : }

  00110	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00114	e12fff1e	 bx          lr
  00118		 |$LN44@FMD_ReadSe|
  00118		 |$LN45@FMD_ReadSe|
  00118	00000000	 DCD         |s_hNand|
  0011c		 |$M47006|

			 ENDP  ; |FMD_ReadSectorOOB|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|FMD_ReadSector|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|__security_check_cookie|

  00000			 AREA	 |.pdata|, PDATA
|$T47235| DCD	|$LN129@FMD_ReadSe@2|
	DCD	0xc000fc02

  00000			 AREA	 |.xdata|, DATA
|$T47231| DCD	0xffffffd8
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T47231|

  00008		 |FMD_ReadSector| PROC

; 1084 : {

  00008		 |$LN129@FMD_ReadSe@2|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd08c	 sub         sp, sp, #0x8C
  00010		 |$M47232|
  00010	e1a05003	 mov         r5, r3
  00014	e1a06002	 mov         r6, r2
  00018	e58d5008	 str         r5, [sp, #8]
  0001c	e58d600c	 str         r6, [sp, #0xC]
  00020	e1a08001	 mov         r8, r1
  00024	e1a0b000	 mov         r11, r0
  00028	e59fe3c4	 ldr         lr, [pc, #0x3C4]
  0002c	e59ee000	 ldr         lr, [lr]
  00030	e58de088	 str         lr, [sp, #0x88]

; 1085 :     BOOL rc = FALSE;
; 1086 :     NAND_SPARE_AREA sa;
; 1087 :     UINT32 oldIdleMode;
; 1088 :     UINT32 sectorSize;
; 1089 :     BYTE rgEcc[ECC_BYTES];
; 1090 : 
; 1091 :     // Fail if FMD wasn't opened
; 1092 :     if (s_hNand == NULL) goto cleanUp;

  00034	e59fa3b4	 ldr         r10, [pc, #0x3B4]
  00038	e59a7000	 ldr         r7, [r10]
  0003c	e3570000	 cmp         r7, #0
  00040	0a0000e3	 beq         |$LN125@FMD_ReadSe@2|

; 1093 :     
; 1094 :     NAND_MutexEnter(s_hNand);
; 1095 : 
; 1096 :     //  Change idle mode to no-idle to ensure access to GPMC registers
; 1097 :     sectorSize = NAND_GetGeometry(s_hNand)->sectorSize;
; 1098 :     oldIdleMode = INREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG));

  00044	e597e02c	 ldr         lr, [r7, #0x2C]

; 1099 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), SYSCONFIG_NOIDLE);

  00048	e5979050	 ldr         r9, [r7, #0x50]
  0004c	e3a02008	 mov         r2, #8
  00050	e59e3010	 ldr         r3, [lr, #0x10]
  00054	e58e2010	 str         r2, [lr, #0x10]

; 1100 : 	
; 1101 :     while (sectors > 0)

  00058	e3550000	 cmp         r5, #0
  0005c	e58d3010	 str         r3, [sp, #0x10]
  00060	0a0000d6	 beq         |$LN16@FMD_ReadSe@2|
  00064	e1a020a9	 mov         r2, r9, lsr #1
  00068	e1a03802	 mov         r3, r2, lsl #16
  0006c	e1a04c23	 mov         r4, r3, lsr #24
  00070	e20230ff	 and         r3, r2, #0xFF
  00074	e1cd30b4	 strh        r3, [sp, #4]
  00078	e1cd40b6	 strh        r4, [sp, #6]
  0007c		 |$LL17@FMD_ReadSe@2|

; 1102 :         {
; 1103 :         //  Only enable during NAND read/write/erase operations
; 1104 :         NAND_Enable(s_hNand, TRUE);

  0007c	e3a01001	 mov         r1, #1
  00080	e1a00007	 mov         r0, r7
  00084	eb000000	 bl          NAND_Enable

; 1105 :         
; 1106 :         // Read sector from A
; 1107 :         if (pBuffer != NULL)

  00088	e3580000	 cmp         r8, #0
  0008c	e3a02070	 mov         r2, #0x70
  00090	0a000048	 beq         |$LL62@FMD_ReadSe@2|

; 1108 :             {
; 1109 :             // be sure to do this before sending the READ command and not after ! or the
; 1110 :             // status register would remain at status read mode, which would have to be changed
; 1111 :             // before retreiving the data
; 1112 :             WaitForReadyStatus(s_hNand);

  00094		 |$LL30@FMD_ReadSe@2|
  00094	e597301c	 ldr         r3, [r7, #0x1C]
  00098	e1c320b0	 strh        r2, [r3]
  0009c	e5973024	 ldr         r3, [r7, #0x24]
  000a0	e1d330b0	 ldrh        r3, [r3]
  000a4	e3130040	 tst         r3, #0x40
  000a8	0afffff9	 beq         |$LL30@FMD_ReadSe@2|

; 1113 : 
; 1114 : 			
; 1115 :             // configure prefetch engine for input and start it
; 1116 :             NAND_ConfigurePrefetch(s_hNand, NAND_DATA_READ);

  000ac	eb000000	 bl          BSPGetNandCS
  000b0	e597302c	 ldr         r3, [r7, #0x2C]
  000b4	e3a01000	 mov         r1, #0
  000b8	e2002007	 and         r2, r0, #7
  000bc	e58311ec	 str         r1, [r3, #0x1EC]
  000c0	e2003003	 and         r3, r0, #3
  000c4	e3a00722	 mov         r0, #0x22, 14
  000c8	e1833a02	 orr         r3, r3, r2, lsl #20
  000cc	e3802b01	 orr         r2, r0, #1, 22
  000d0	e597102c	 ldr         r1, [r7, #0x2C]
  000d4	e1833002	 orr         r3, r3, r2
  000d8	e3a02001	 mov         r2, #1
  000dc	e1a03203	 mov         r3, r3, lsl #4
  000e0	e5872018	 str         r2, [r7, #0x18]
  000e4	e58131e0	 str         r3, [r1, #0x1E0]
  000e8	e597102c	 ldr         r1, [r7, #0x2C]

; 1117 :            
; 1118 :             // Send the command
; 1119 :             NAND_SendCommand (s_hNand, NAND_CMD_READ1);

  000ec	e59a0000	 ldr         r0, [r10]

; 1120 : 
; 1121 :             // Send the address
; 1122 :             NAND_Seek(s_hNand, sector, 0);

  000f0	e1a0380b	 mov         r3, r11, lsl #16
  000f4	e59121e0	 ldr         r2, [r1, #0x1E0]
  000f8	e1a0ec23	 mov         lr, r3, lsr #24
  000fc	e3a07000	 mov         r7, #0
  00100	e3823080	 orr         r3, r2, #0x80
  00104	e58131e0	 str         r3, [r1, #0x1E0]
  00108	e590201c	 ldr         r2, [r0, #0x1C]
  0010c	e1a0340b	 mov         r3, r11, lsl #8
  00110	e1a01c23	 mov         r1, r3, lsr #24
  00114	e1c270b0	 strh        r7, [r2]
  00118	e5903020	 ldr         r3, [r0, #0x20]
  0011c	e20b40ff	 and         r4, r11, #0xFF

; 1123 : 
; 1124 :             // Send the command
; 1125 :             NAND_SendCommand(s_hNand, NAND_CMD_READ2);

  00120	e3a02030	 mov         r2, #0x30
  00124	e1c370b0	 strh        r7, [r3]
  00128	e5903020	 ldr         r3, [r0, #0x20]
  0012c	e1c370b0	 strh        r7, [r3]
  00130	e5903020	 ldr         r3, [r0, #0x20]
  00134	e1c340b0	 strh        r4, [r3]
  00138	e5903020	 ldr         r3, [r0, #0x20]
  0013c	e3a04070	 mov         r4, #0x70
  00140	e1c3e0b0	 strh        lr, [r3]
  00144	e5903020	 ldr         r3, [r0, #0x20]
  00148	e1c310b0	 strh        r1, [r3]
  0014c	e590301c	 ldr         r3, [r0, #0x1C]
  00150	e1c320b0	 strh        r2, [r3]

; 1126 : 
; 1127 :             // Wait for the action to finish
; 1128 :             WaitForReadyStatus(s_hNand);

  00154		 |$LL48@FMD_ReadSe@2|
  00154	e590301c	 ldr         r3, [r0, #0x1C]
  00158	e1c340b0	 strh        r4, [r3]
  0015c	e5903024	 ldr         r3, [r0, #0x24]
  00160	e1d330b0	 ldrh        r3, [r3]
  00164	e3130040	 tst         r3, #0x40
  00168	0afffff9	 beq         |$LL48@FMD_ReadSe@2|

; 1129 : 
; 1130 :             //Force a read here, else we will read the status again
; 1131 :             NAND_SendCommand (s_hNand, NAND_CMD_READ1);

  0016c	e590101c	 ldr         r1, [r0, #0x1C]

; 1132 : 
; 1133 : 	     // read data
; 1134 :             NAND_Read(s_hNand, pBuffer, sectorSize, rgEcc);

  00170	e28d3054	 add         r3, sp, #0x54
  00174	e1a02009	 mov         r2, r9
  00178	e1c170b0	 strh        r7, [r1]
  0017c	e1a01008	 mov         r1, r8
  00180	eb000000	 bl          NAND_Read

; 1135 : 			
; 1136 :             // read spare area
; 1137 :             NAND_Read(s_hNand, (BYTE*)&sa, sizeof(sa), NULL);

  00184	e59a0000	 ldr         r0, [r10]
  00188	e3a03000	 mov         r3, #0
  0018c	e3a02040	 mov         r2, #0x40
  00190	e28d1014	 add         r1, sp, #0x14
  00194	eb000000	 bl          NAND_Read
  00198	e59a7000	 ldr         r7, [r10]

; 1138 : 
; 1139 :             // Make sure of the NAND status
; 1140 :             WaitForReadyStatus(s_hNand);

  0019c		 |$LL56@FMD_ReadSe@2|
  0019c	e597301c	 ldr         r3, [r7, #0x1C]
  001a0	e1c340b0	 strh        r4, [r3]
  001a4	e5973024	 ldr         r3, [r7, #0x24]
  001a8	e1d330b0	 ldrh        r3, [r3]
  001ac	e3130040	 tst         r3, #0x40
  001b0	0afffff9	 beq         |$LL56@FMD_ReadSe@2|

; 1141 :             }
; 1142 :         else

  001b4	ea000031	 b           |$LN83@FMD_ReadSe@2|

; 1143 :          {
; 1144 :             // Make sure of the NAND status
; 1145 :             WaitForReadyStatus(s_hNand);

  001b8		 |$LL62@FMD_ReadSe@2|
  001b8	e597301c	 ldr         r3, [r7, #0x1C]
  001bc	e1c320b0	 strh        r2, [r3]
  001c0	e5973024	 ldr         r3, [r7, #0x24]
  001c4	e1d330b0	 ldrh        r3, [r3]
  001c8	e3130040	 tst         r3, #0x40
  001cc	0afffff9	 beq         |$LL62@FMD_ReadSe@2|

; 1146 :             // Send the command
; 1147 :             NAND_SendCommand(s_hNand, NAND_CMD_READ1);

  001d0	e597301c	 ldr         r3, [r7, #0x1C]

; 1148 :     
; 1149 :             // Send the address
; 1150 :             NAND_Seek(s_hNand, sector, sectorSize);

  001d4	e3a01000	 mov         r1, #0
  001d8	e1dd00b4	 ldrh        r0, [sp, #4]
  001dc	e1c310b0	 strh        r1, [r3]
  001e0	e5973020	 ldr         r3, [r7, #0x20]
  001e4	e20be0ff	 and         lr, r11, #0xFF
  001e8	e1a0280b	 mov         r2, r11, lsl #16
  001ec	e1c300b0	 strh        r0, [r3]
  001f0	e5973020	 ldr         r3, [r7, #0x20]
  001f4	e1a01c22	 mov         r1, r2, lsr #24
  001f8	e1a0240b	 mov         r2, r11, lsl #8
  001fc	e1c340b0	 strh        r4, [r3]
  00200	e5973020	 ldr         r3, [r7, #0x20]
  00204	e1a02c22	 mov         r2, r2, lsr #24
  00208	e3a04070	 mov         r4, #0x70
  0020c	e1c3e0b0	 strh        lr, [r3]
  00210	e5973020	 ldr         r3, [r7, #0x20]
  00214	e1c310b0	 strh        r1, [r3]
  00218	e5973020	 ldr         r3, [r7, #0x20]
  0021c	e1c320b0	 strh        r2, [r3]

; 1151 :     
; 1152 :             // Send the command
; 1153 :             NAND_SendCommand(s_hNand, NAND_CMD_READ2);

  00220	e597301c	 ldr         r3, [r7, #0x1C]
  00224	e3a02030	 mov         r2, #0x30
  00228	e1c320b0	 strh        r2, [r3]

; 1154 :     
; 1155 :             // Wait for the action to finish
; 1156 :             WaitForReadyStatus(s_hNand);

  0022c		 |$LL76@FMD_ReadSe@2|
  0022c	e597301c	 ldr         r3, [r7, #0x1C]
  00230	e1c340b0	 strh        r4, [r3]
  00234	e5973024	 ldr         r3, [r7, #0x24]
  00238	e1d330b0	 ldrh        r3, [r3]
  0023c	e3130040	 tst         r3, #0x40
  00240	0afffff9	 beq         |$LL76@FMD_ReadSe@2|

; 1157 :             //Force a read here, else we will read the status again
; 1158 :             NAND_SendCommand (s_hNand, NAND_CMD_READ1);

  00244	e597101c	 ldr         r1, [r7, #0x1C]

; 1159 :     
; 1160 :             // read spare area
; 1161 :             NAND_Read(s_hNand, (BYTE*)&sa, sizeof(sa), NULL);

  00248	e3a00000	 mov         r0, #0
  0024c	e3a03000	 mov         r3, #0
  00250	e1c100b0	 strh        r0, [r1]
  00254	e28d1014	 add         r1, sp, #0x14
  00258	e1a00007	 mov         r0, r7
  0025c	e3a02040	 mov         r2, #0x40
  00260	eb000000	 bl          NAND_Read
  00264	e59a7000	 ldr         r7, [r10]

; 1162 : 
; 1163 :             // Make sure of the NAND status
; 1164 :             WaitForReadyStatus(s_hNand);

  00268		 |$LL84@FMD_ReadSe@2|
  00268	e597301c	 ldr         r3, [r7, #0x1C]
  0026c	e1c340b0	 strh        r4, [r3]
  00270	e5973024	 ldr         r3, [r7, #0x24]
  00274	e1d330b0	 ldrh        r3, [r3]
  00278	e3130040	 tst         r3, #0x40
  0027c	0afffff9	 beq         |$LL84@FMD_ReadSe@2|
  00280		 |$LN83@FMD_ReadSe@2|

; 1165 :     
; 1166 :         }        // Copy sector info
; 1167 :         if (pSectorInfo != NULL)

  00280	e3560000	 cmp         r6, #0
  00284	0a00001e	 beq         |$LN13@FMD_ReadSe@2|

; 1168 :             {
; 1169 :             pSectorInfo->bBadBlock    = sa.hwBadBlock[0] & sa.hwBadBlock[1];    // HW bad block check
; 1170 :             pSectorInfo->bBadBlock    = pSectorInfo->bBadBlock & sa.swBadBlock; // SW bad block flag check
; 1171 :             pSectorInfo->bOEMReserved = sa.oemReserved;
; 1172 : 
; 1173 :             memcpy(
; 1174 :                 &pSectorInfo->dwReserved1, sa.reserved1,
; 1175 :                 sizeof(pSectorInfo->dwReserved1)
; 1176 :                 );

  00288	e5dd204d	 ldrb        r2, [sp, #0x4D]
  0028c	e5dd304c	 ldrb        r3, [sp, #0x4C]
  00290	e5dd104e	 ldrb        r1, [sp, #0x4E]
  00294	e5dd004f	 ldrb        r0, [sp, #0x4F]
  00298	e5dde049	 ldrb        lr, [sp, #0x49]
  0029c	e1833402	 orr         r3, r3, r2, lsl #8
  002a0	e5dd2048	 ldrb        r2, [sp, #0x48]
  002a4	e5dd404a	 ldrb        r4, [sp, #0x4A]
  002a8	e1833801	 orr         r3, r3, r1, lsl #16
  002ac	e5dd504b	 ldrb        r5, [sp, #0x4B]
  002b0	e1833c00	 orr         r3, r3, r0, lsl #24
  002b4	e5dd6050	 ldrb        r6, [sp, #0x50]
  002b8	e5dd0015	 ldrb        r0, [sp, #0x15]
  002bc	e182240e	 orr         r2, r2, lr, lsl #8
  002c0	e1a01803	 mov         r1, r3, lsl #16
  002c4	e1823804	 orr         r3, r2, r4, lsl #16
  002c8	e5dd4014	 ldrb        r4, [sp, #0x14]
  002cc	e1833c05	 orr         r3, r3, r5, lsl #24
  002d0	e5dd5051	 ldrb        r5, [sp, #0x51]
  002d4	e0062000	 and         r2, r6, r0

; 1177 : 
; 1178 :             memcpy(
; 1179 :                 &pSectorInfo->wReserved2, sa.reserved2,
; 1180 :                 sizeof(pSectorInfo->wReserved2)
; 1181 :                 );

  002d8	e59d600c	 ldr         r6, [sp, #0xC]
  002dc	e1a03823	 mov         r3, r3, lsr #16
  002e0	e1a0e821	 mov         lr, r1, lsr #16
  002e4	e1dd14be	 ldrh        r1, [sp, #0x4E]
  002e8	e183380e	 orr         r3, r3, lr, lsl #16
  002ec	e0022004	 and         r2, r2, r4
  002f0	e5863000	 str         r3, [r6]
  002f4	e5c62005	 strb        r2, [r6, #5]
  002f8	e5c65004	 strb        r5, [r6, #4]

; 1212 :         pSectorInfo++;
; 1213 :         sectors--;

  002fc	e59d5008	 ldr         r5, [sp, #8]
  00300	e1c610b6	 strh        r1, [r6, #6]
  00304		 |$LN13@FMD_ReadSe@2|
  00304	e3a01000	 mov         r1, #0
  00308	e1a00007	 mov         r0, r7
  0030c	eb000000	 bl          NAND_Enable
  00310	e3580000	 cmp         r8, #0
  00314	0a000020	 beq         |$LN4@FMD_ReadSe@2|
  00318	e28de054	 add         lr, sp, #0x54
  0031c	e28d3016	 add         r3, sp, #0x16
  00320	e1a02009	 mov         r2, r9
  00324	e1a01008	 mov         r1, r8
  00328	e1a00007	 mov         r0, r7
  0032c	e58de000	 str         lr, [sp]
  00330	eb000000	 bl          NAND_CorrectEccData
  00334	e3500000	 cmp         r0, #0
  00338	1a000016	 bne         |$LN112@FMD_ReadSe@2|
  0033c	e1a01008	 mov         r1, r8
  00340	e3a02000	 mov         r2, #0
  00344	e28d0051	 add         r0, sp, #0x51
  00348		 |$LL11@FMD_ReadSe@2|
  00348	e28d3014	 add         r3, sp, #0x14
  0034c	e0823003	 add         r3, r2, r3
  00350	e1530000	 cmp         r3, r0
  00354	0a000002	 beq         |$LN10@FMD_ReadSe@2|
  00358	e5d33000	 ldrb        r3, [r3]
  0035c	e35300ff	 cmp         r3, #0xFF
  00360	1a00001b	 bne         |$LN125@FMD_ReadSe@2|
  00364		 |$LN10@FMD_ReadSe@2|

; 1182 :             }
; 1183 :         
; 1184 :         //  Only enable during NAND read/write/erase operations
; 1185 :         NAND_Enable(s_hNand, FALSE);
; 1186 : 
; 1187 :         // perform ecc correction and correct data when possible
; 1188 :         if ((pBuffer != NULL) &&
; 1189 :             (NAND_CorrectEccData(s_hNand, pBuffer, sectorSize, sa.ecc, rgEcc) == FALSE))
; 1190 :             {
; 1191 :             UINT count;
; 1192 :             UCHAR *pData = pBuffer;
; 1193 :             DEBUGMSG (ZONE_ERROR, (L"NAND_CorrectEccData returns FALSE, sector=%d\r\n", sector));	
; 1194 : 
; 1195 :             for (count = 0; count < sizeof(sa); count++)

  00364	e2822001	 add         r2, r2, #1
  00368	e3520040	 cmp         r2, #0x40
  0036c	3afffff5	 bcc         |$LL11@FMD_ReadSe@2|

; 1196 :                 {
; 1197 :                 // Allow OEMReserved byte to be set to reserved/readonly
; 1198 :                 if (&(((UINT8*)&sa)[count]) == &sa.oemReserved) continue;
; 1199 :                 if (((UINT8*)&sa)[count] != 0xFF) goto cleanUp;
; 1200 :                 }
; 1201 : 
; 1202 :             for (count = 0; count < sectorSize; count++)

  00370	e3a02000	 mov         r2, #0
  00374	e3590000	 cmp         r9, #0
  00378	0a000006	 beq         |$LN112@FMD_ReadSe@2|
  0037c		 |$LL6@FMD_ReadSe@2|

; 1203 :                 {
; 1204 :                 if (*pData != 0xFF) goto cleanUp;

  0037c	e5d13000	 ldrb        r3, [r1]
  00380	e35300ff	 cmp         r3, #0xFF
  00384	1a000012	 bne         |$LN125@FMD_ReadSe@2|
  00388	e2822001	 add         r2, r2, #1
  0038c	e1520009	 cmp         r2, r9

; 1205 :                 ++pData;

  00390	e2811001	 add         r1, r1, #1
  00394	3afffff8	 bcc         |$LL6@FMD_ReadSe@2|
  00398		 |$LN112@FMD_ReadSe@2|

; 1196 :                 {
; 1197 :                 // Allow OEMReserved byte to be set to reserved/readonly
; 1198 :                 if (&(((UINT8*)&sa)[count]) == &sa.oemReserved) continue;
; 1199 :                 if (((UINT8*)&sa)[count] != 0xFF) goto cleanUp;
; 1200 :                 }
; 1201 : 
; 1202 :             for (count = 0; count < sectorSize; count++)

  00398	e59a7000	 ldr         r7, [r10]
  0039c		 |$LN4@FMD_ReadSe@2|

; 1206 :                 }
; 1207 :             }
; 1208 :         
; 1209 :         // Move to next sector
; 1210 :         sector++;
; 1211 :         if (pBuffer != NULL) pBuffer += sectorSize;

  0039c	e3580000	 cmp         r8, #0
  003a0	10888009	 addne       r8, r8, r9

; 1212 :         pSectorInfo++;
; 1213 :         sectors--;

  003a4	e2555001	 subs        r5, r5, #1
  003a8	e2866008	 add         r6, r6, #8
  003ac	e1dd40b6	 ldrh        r4, [sp, #6]
  003b0	e58d5008	 str         r5, [sp, #8]
  003b4	e28bb001	 add         r11, r11, #1
  003b8	e58d600c	 str         r6, [sp, #0xC]
  003bc	1affff2e	 bne         |$LL17@FMD_ReadSe@2|
  003c0		 |$LN16@FMD_ReadSe@2|

; 1214 :         }
; 1215 : 
; 1216 :     //  Change idle mode back
; 1217 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), oldIdleMode);

  003c0	e597302c	 ldr         r3, [r7, #0x2C]

; 1218 :     
; 1219 :     // Done
; 1220 :     rc = TRUE;

  003c4	e59d2010	 ldr         r2, [sp, #0x10]
  003c8	e3a04001	 mov         r4, #1
  003cc	e5832010	 str         r2, [r3, #0x10]
  003d0	ea000000	 b           |$cleanUp$46332|
  003d4		 |$LN125@FMD_ReadSe@2|
  003d4	e3a04000	 mov         r4, #0
  003d8		 |$cleanUp$46332|

; 1221 : 
; 1222 : cleanUp:
; 1223 :     // Release hardware lock
; 1224 :     if (s_hNand != NULL) NAND_MutexExit(s_hNand);
; 1225 :     
; 1226 :     ASSERT(rc);
; 1227 :     return rc;

  003d8	e59d0088	 ldr         r0, [sp, #0x88]
  003dc	eb000000	 bl          __security_check_cookie

; 1228 : }

  003e0	e1a00004	 mov         r0, r4
  003e4	e28dd08c	 add         sp, sp, #0x8C
  003e8	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  003ec	e12fff1e	 bx          lr
  003f0		 |$LN130@FMD_ReadSe@2|
  003f0		 |$LN131@FMD_ReadSe@2|
  003f0	00000000	 DCD         |s_hNand|
  003f4		 |$LN132@FMD_ReadSe@2|
  003f4	00000000	 DCD         |__security_cookie|
  003f8		 |$M47233|

			 ENDP  ; |FMD_ReadSector|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|FMD_WriteSector|
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T47421| DCD	|$LN89@FMD_WriteS|
	DCD	0xc000db02

  00000			 AREA	 |.xdata|, DATA
|$T47417| DCD	0xffffffd8
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T47417|

  00008		 |FMD_WriteSector| PROC

; 1241 : {

  00008		 |$LN89@FMD_WriteS|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd058	 sub         sp, sp, #0x58
  00010		 |$M47418|
  00010	e1a09003	 mov         r9, r3
  00014	e1a08002	 mov         r8, r2
  00018	e1a0a001	 mov         r10, r1
  0001c	e1a0b000	 mov         r11, r0
  00020	e59fe348	 ldr         lr, [pc, #0x348]
  00024	e59ee000	 ldr         lr, [lr]
  00028	e58de054	 str         lr, [sp, #0x54]

; 1242 :     BOOL rc = FALSE;
; 1243 :     NAND_SPARE_AREA sa;
; 1244 :     UINT32 oldIdleMode;
; 1245 :     UINT32 sectorSize;
; 1246 :     SECTOR_ADDR startSector = sector;
; 1247 :     SECTOR_ADDR endSector = sector + sectors;
; 1248 :     NandDevice_t *pDevice = (NandDevice_t*)s_hNand;

  0002c	e59f6338	 ldr         r6, [pc, #0x338]
  00030	e3a05000	 mov         r5, #0
  00034	e5964000	 ldr         r4, [r6]
  00038	e1a03004	 mov         r3, r4
  0003c	e58d3010	 str         r3, [sp, #0x10]

; 1249 : 
; 1250 :     // Fail if FMD wasn't opened
; 1251 :     if (s_hNand == NULL) goto cleanUp;

  00040	e3540000	 cmp         r4, #0
  00044	0a0000c1	 beq         |$cleanUp$46390|

; 1252 :     
; 1253 :     // Obtain hardware lock
; 1254 :     NAND_MutexEnter(s_hNand);
; 1255 : 
; 1256 :     //  Change idle mode to no-idle to ensure access to GPMC registers
; 1257 :     sectorSize = NAND_GetGeometry(s_hNand)->sectorSize;
; 1258 :     oldIdleMode = INREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG));

  00048	e594e02c	 ldr         lr, [r4, #0x2C]

; 1259 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), SYSCONFIG_NOIDLE);

  0004c	e5945050	 ldr         r5, [r4, #0x50]
  00050	e3a02008	 mov         r2, #8
  00054	e59e3010	 ldr         r3, [lr, #0x10]

; 1260 : 
; 1261 :     //  Only enable during NAND read/write/erase operations    
; 1262 :     NAND_Enable(s_hNand, TRUE);

  00058	e3a01001	 mov         r1, #1
  0005c	e1a00004	 mov         r0, r4
  00060	e58d300c	 str         r3, [sp, #0xC]
  00064	e58d5008	 str         r5, [sp, #8]
  00068	e58e2010	 str         r2, [lr, #0x10]
  0006c	eb000000	 bl          NAND_Enable

; 1263 :     NAND_LockBlocks(s_hNand, startSector, endSector, FALSE);

  00070	e594202c	 ldr         r2, [r4, #0x2C]
  00074		 |$cleanUp$47265|

; 1264 :     
; 1265 :     while (sectors > 0)

  00074	e3590000	 cmp         r9, #0
  00078	e5923050	 ldr         r3, [r2, #0x50]
  0007c	e3833010	 orr         r3, r3, #0x10
  00080	e5823050	 str         r3, [r2, #0x50]
  00084	0a0000a4	 beq         |$LN86@FMD_WriteS|
  00088	e1a020a5	 mov         r2, r5, lsr #1
  0008c	e1a03802	 mov         r3, r2, lsl #16
  00090	e1a03c23	 mov         r3, r3, lsr #24
  00094	e1cd30b4	 strh        r3, [sp, #4]
  00098	e20230ff	 and         r3, r2, #0xFF
  0009c	e59f72c4	 ldr         r7, [pc, #0x2C4]
  000a0	e1cd30b6	 strh        r3, [sp, #6]
  000a4		 |$LL9@FMD_WriteS|

; 1266 :         {
; 1267 :         // Clear out spare area struct
; 1268 :         memset(&sa, 0xFF, sizeof(NAND_SPARE_AREA));

  000a4	e3a02040	 mov         r2, #0x40
  000a8	e3a010ff	 mov         r1, #0xFF
  000ac	e28d0014	 add         r0, sp, #0x14
  000b0	eb000000	 bl          memset

; 1269 : 
; 1270 :         // When there is buffer write data
; 1271 :         if (pBuffer != NULL)

  000b4	e35a0000	 cmp         r10, #0
  000b8	0a00002c	 beq         |$LN7@FMD_WriteS|

; 1272 :             {
; 1273 :             // enable prefetch
; 1274 :             NAND_ConfigurePrefetch(s_hNand, NAND_DATA_WRITE);

  000bc	eb000000	 bl          BSPGetNandCS
  000c0	e594302c	 ldr         r3, [r4, #0x2C]
  000c4	e3a0e000	 mov         lr, #0
  000c8	e2002007	 and         r2, r0, #7
  000cc	e583e1ec	 str         lr, [r3, #0x1EC]
  000d0	e2003003	 and         r3, r0, #3
  000d4	e594102c	 ldr         r1, [r4, #0x2C]
  000d8	e1833a02	 orr         r3, r3, r2, lsl #20
  000dc	e3a02002	 mov         r2, #2
  000e0	e1873203	 orr         r3, r7, r3, lsl #4
  000e4	e5842018	 str         r2, [r4, #0x18]
  000e8	e58131e0	 str         r3, [r1, #0x1E0]
  000ec	e594102c	 ldr         r1, [r4, #0x2C]

; 1275 : 
; 1276 :             // send the write command
; 1277 :             NAND_SendCommand(s_hNand, NAND_CMD_WRITE1);
; 1278 : 
; 1279 :             // send the address to write to
; 1280 :             NAND_Seek(s_hNand, sector, 0);

  000f0	e1a0380b	 mov         r3, r11, lsl #16
  000f4	e5967000	 ldr         r7, [r6]
  000f8	e59121e0	 ldr         r2, [r1, #0x1E0]
  000fc	e1a05c23	 mov         r5, r3, lsr #24

; 1281 : 
; 1282 :             // send data to flash
; 1283 :             NAND_Write(s_hNand, pBuffer, sectorSize, sa.ecc);

  00100	e3a06000	 mov         r6, #0
  00104	e3823080	 orr         r3, r2, #0x80
  00108	e58131e0	 str         r3, [r1, #0x1E0]
  0010c	e597201c	 ldr         r2, [r7, #0x1C]
  00110	e1a0340b	 mov         r3, r11, lsl #8
  00114	e1a04c23	 mov         r4, r3, lsr #24
  00118	e3a03080	 mov         r3, #0x80
  0011c	e1c230b0	 strh        r3, [r2]
  00120	e5971020	 ldr         r1, [r7, #0x20]
  00124	e59d2008	 ldr         r2, [sp, #8]
  00128	e28d3016	 add         r3, sp, #0x16
  0012c	e1c1e0b0	 strh        lr, [r1]
  00130	e597e020	 ldr         lr, [r7, #0x20]
  00134	e1a0100a	 mov         r1, r10
  00138	e1a00007	 mov         r0, r7
  0013c	e1ce60b0	 strh        r6, [lr]
  00140	e597e020	 ldr         lr, [r7, #0x20]
  00144	e20b60ff	 and         r6, r11, #0xFF
  00148	e1ce60b0	 strh        r6, [lr]
  0014c	e597e020	 ldr         lr, [r7, #0x20]
  00150	e1ce50b0	 strh        r5, [lr]
  00154	e597e020	 ldr         lr, [r7, #0x20]
  00158	e1ce40b0	 strh        r4, [lr]
  0015c	eb000000	 bl          NAND_Write

; 1284 : 
; 1285 :             }
; 1286 :         else

  00160	e59f6204	 ldr         r6, [pc, #0x204]
  00164	e59d5008	 ldr         r5, [sp, #8]
  00168	e5960000	 ldr         r0, [r6]
  0016c	ea00003c	 b           |$LN60@FMD_WriteS|
  00170		 |$LN7@FMD_WriteS|

; 1287 :             {
; 1288 :             // Send the command
; 1289 :             NAND_SendCommand(s_hNand, NAND_CMD_READ1);

  00170	e594301c	 ldr         r3, [r4, #0x1C]

; 1290 : 
; 1291 :             // Send the address
; 1292 :             NAND_Seek(s_hNand, sector, NAND_GetGeometry(s_hNand)->sectorSize);

  00174	e3a01000	 mov         r1, #0
  00178	e1a0280b	 mov         r2, r11, lsl #16
  0017c	e1c310b0	 strh        r1, [r3]
  00180	e5943050	 ldr         r3, [r4, #0x50]
  00184	e5941020	 ldr         r1, [r4, #0x20]
  00188	e1a0ec22	 mov         lr, r2, lsr #24
  0018c	e1a000a3	 mov         r0, r3, lsr #1
  00190	e20030ff	 and         r3, r0, #0xFF
  00194	e1c130b0	 strh        r3, [r1]
  00198	e5942020	 ldr         r2, [r4, #0x20]
  0019c	e1a03800	 mov         r3, r0, lsl #16
  001a0	e1a03c23	 mov         r3, r3, lsr #24
  001a4	e1c230b0	 strh        r3, [r2]
  001a8	e5942020	 ldr         r2, [r4, #0x20]
  001ac	e20b70ff	 and         r7, r11, #0xFF
  001b0	e1a0340b	 mov         r3, r11, lsl #8
  001b4	e1c270b0	 strh        r7, [r2]
  001b8	e1a01c23	 mov         r1, r3, lsr #24
  001bc	e5943020	 ldr         r3, [r4, #0x20]

; 1293 : 
; 1294 :             // Send the command
; 1295 :             NAND_SendCommand(s_hNand, NAND_CMD_READ2);

  001c0	e3a02030	 mov         r2, #0x30
  001c4	e1cde0b2	 strh        lr, [sp, #2]
  001c8	e1c3e0b0	 strh        lr, [r3]
  001cc	e5943020	 ldr         r3, [r4, #0x20]
  001d0	e1cd10b0	 strh        r1, [sp]
  001d4	e1c310b0	 strh        r1, [r3]
  001d8	e594301c	 ldr         r3, [r4, #0x1C]
  001dc	e1c320b0	 strh        r2, [r3]
  001e0	e3a02070	 mov         r2, #0x70

; 1296 : 
; 1297 :             // Wait for the action to finish
; 1298 :             WaitForReadyStatus(s_hNand);

  001e4		 |$LL49@FMD_WriteS|
  001e4	e594301c	 ldr         r3, [r4, #0x1C]
  001e8	e1c320b0	 strh        r2, [r3]
  001ec	e5943024	 ldr         r3, [r4, #0x24]
  001f0	e1d330b0	 ldrh        r3, [r3]
  001f4	e3130040	 tst         r3, #0x40
  001f8	0afffff9	 beq         |$LL49@FMD_WriteS|

; 1299 : 
; 1300 :             //Force a read here, else we will read the status again
; 1301 :             NAND_SendCommand (s_hNand, NAND_CMD_READ1);

  001fc	e594101c	 ldr         r1, [r4, #0x1C]

; 1302 : 
; 1303 :             // read spare area
; 1304 :             NAND_Read(s_hNand, (BYTE*)&sa, sizeof(sa), NULL);

  00200	e3a00000	 mov         r0, #0
  00204	e3a03000	 mov         r3, #0
  00208	e1c100b0	 strh        r0, [r1]
  0020c	e28d1014	 add         r1, sp, #0x14
  00210	e1a00004	 mov         r0, r4
  00214	e3a02040	 mov         r2, #0x40
  00218	eb000000	 bl          NAND_Read

; 1305 : 
; 1306 : 
; 1307 :             // send the write command
; 1308 :             NAND_SendCommand(s_hNand, NAND_CMD_WRITE1);

  0021c	e5960000	 ldr         r0, [r6]
  00220	e3a02080	 mov         r2, #0x80
  00224	e590301c	 ldr         r3, [r0, #0x1C]
  00228	e1c320b0	 strh        r2, [r3]

; 1309 : 
; 1310 :             // send the address to write to
; 1311 :             NAND_Seek(s_hNand, sector, sectorSize);

  0022c	e5903020	 ldr         r3, [r0, #0x20]
  00230	e1dd20b6	 ldrh        r2, [sp, #6]
  00234	e1c320b0	 strh        r2, [r3]
  00238	e5903020	 ldr         r3, [r0, #0x20]
  0023c	e1dd20b4	 ldrh        r2, [sp, #4]
  00240	e1c320b0	 strh        r2, [r3]
  00244	e5903020	 ldr         r3, [r0, #0x20]
  00248	e1dd20b2	 ldrh        r2, [sp, #2]
  0024c	e1c370b0	 strh        r7, [r3]
  00250	e5903020	 ldr         r3, [r0, #0x20]
  00254	e1c320b0	 strh        r2, [r3]
  00258	e5903020	 ldr         r3, [r0, #0x20]
  0025c	e1dd20b0	 ldrh        r2, [sp]
  00260	e1c320b0	 strh        r2, [r3]
  00264		 |$LN60@FMD_WriteS|

; 1312 : 			
; 1313 :             }
; 1314 : 		
; 1315 :         /* used for test purpose */ 
; 1316 :         if((pSectorInfo != NULL) && (pSectorInfo->bOEMReserved == SKIP_ECC_WRITE_MAGIC_NUMBER) )

  00264	e3580000	 cmp         r8, #0
  00268	0a00000f	 beq         |$LN4@FMD_WriteS|
  0026c	e5d84004	 ldrb        r4, [r8, #4]
  00270	e354000f	 cmp         r4, #0xF
  00274	1a000003	 bne         |$LN5@FMD_WriteS|

; 1317 :         {
; 1318 :             /* skip updating ECC */
; 1319 :             ECC_Reset(pDevice->pGpmcRegs);			

  00278	e59d3010	 ldr         r3, [sp, #0x10]
  0027c	e593002c	 ldr         r0, [r3, #0x2C]
  00280	eb000000	 bl          ECC_Reset

; 1320 : 	     goto  skip_ecc; 	

  00284	ea00000c	 b           |$skip_ecc$46405|
  00288		 |$LN5@FMD_WriteS|

; 1321 :         }
; 1322 : 
; 1323 :         if (pSectorInfo != NULL)
; 1324 :             {
; 1325 :             // Fill in rest of spare area info (we already have ECC from above)
; 1326 :             sa.swBadBlock     = pSectorInfo->bBadBlock;
; 1327 :             sa.oemReserved  = pSectorInfo->bOEMReserved;
; 1328 :             memcpy(sa.reserved1, &pSectorInfo->dwReserved1, sizeof(sa.reserved1));

  00288	e598e000	 ldr         lr, [r8]
  0028c	e5d82005	 ldrb        r2, [r8, #5]

; 1329 :             memcpy(sa.reserved2, &pSectorInfo->wReserved2, sizeof(sa.reserved2));

  00290	e1d810b6	 ldrh        r1, [r8, #6]
  00294	e1a0382e	 mov         r3, lr, lsr #16
  00298	e1cd34bc	 strh        r3, [sp, #0x4C]
  0029c	e5cd2050	 strb        r2, [sp, #0x50]
  002a0	e5cd4051	 strb        r4, [sp, #0x51]
  002a4	e1cde4ba	 strh        lr, [sp, #0x4A]
  002a8	e1cd14be	 strh        r1, [sp, #0x4E]
  002ac		 |$LN4@FMD_WriteS|

; 1330 :             }
; 1331 : 
; 1332 :         // write new spare info
; 1333 :         NAND_Write(s_hNand, (BYTE*)&sa, sizeof(sa), NULL);

  002ac	e3a03000	 mov         r3, #0
  002b0	e3a02040	 mov         r2, #0x40
  002b4	e28d1014	 add         r1, sp, #0x14
  002b8	eb000000	 bl          NAND_Write
  002bc		 |$skip_ecc$46405|

; 1334 : 
; 1335 : skip_ecc:
; 1336 :         // initiate the data programming process :
; 1337 :         NAND_SendCommand(s_hNand, NAND_CMD_WRITE2);

  002bc	e5964000	 ldr         r4, [r6]
  002c0	e3a02010	 mov         r2, #0x10
  002c4	e594301c	 ldr         r3, [r4, #0x1C]
  002c8	e1c320b0	 strh        r2, [r3]
  002cc	e3a02070	 mov         r2, #0x70

; 1338 : 
; 1339 :         // wait until completion of the operation :
; 1340 :         WaitForReadyStatus(s_hNand);

  002d0		 |$LL65@FMD_WriteS|
  002d0	e594301c	 ldr         r3, [r4, #0x1C]
  002d4	e1c320b0	 strh        r2, [r3]
  002d8	e5943024	 ldr         r3, [r4, #0x24]
  002dc	e1d330b0	 ldrh        r3, [r3]
  002e0	e3130040	 tst         r3, #0x40
  002e4	0afffff9	 beq         |$LL65@FMD_WriteS|

; 1341 : 
; 1342 :         if ((NAND_GetStatus(s_hNand) & NAND_STATUS_ERROR) != 0)

  002e8	e594301c	 ldr         r3, [r4, #0x1C]
  002ec	e1c320b0	 strh        r2, [r3]
  002f0	e5943024	 ldr         r3, [r4, #0x24]
  002f4	e1d330b0	 ldrh        r3, [r3]
  002f8	e3130001	 tst         r3, #1
  002fc	1a000006	 bne         |$LN86@FMD_WriteS|

; 1343 :             {
; 1344 :             break;
; 1345 :             }
; 1346 :         // Move to next sector
; 1347 :         sector++;
; 1348 :         if (pBuffer != NULL) pBuffer += sectorSize;

  00300	e35a0000	 cmp         r10, #0

; 1349 :         pSectorInfo++;
; 1350 :         sectors--;

  00304	e59f705c	 ldr         r7, [pc, #0x5C]
  00308	108aa005	 addne       r10, r10, r5
  0030c	e2599001	 subs        r9, r9, #1
  00310	e28bb001	 add         r11, r11, #1
  00314	e2888008	 add         r8, r8, #8
  00318	1affff61	 bne         |$LL9@FMD_WriteS|
  0031c		 |$LN86@FMD_WriteS|

; 1351 :         }
; 1352 : 
; 1353 :     //  Only enable during NAND read/write/erase operations    
; 1354 :     NAND_LockBlocks(s_hNand, startSector, endSector, TRUE);

  0031c	e594202c	 ldr         r2, [r4, #0x2C]

; 1355 :     NAND_Enable(s_hNand, FALSE);

  00320	e3a01000	 mov         r1, #0
  00324	e1a00004	 mov         r0, r4
  00328	e5923050	 ldr         r3, [r2, #0x50]
  0032c		 |$cleanUp$47382|
  0032c	e3c33010	 bic         r3, r3, #0x10
  00330	e5823050	 str         r3, [r2, #0x50]
  00334	eb000000	 bl          NAND_Enable

; 1356 : 
; 1357 :     //  Change idle mode back
; 1358 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), oldIdleMode);

  00338	e594302c	 ldr         r3, [r4, #0x2C]

; 1359 : 
; 1360 :     // All is ok, when we read all sectors
; 1361 :     rc = (sectors == 0);

  0033c	e59d200c	 ldr         r2, [sp, #0xC]
  00340	e3590000	 cmp         r9, #0
  00344	03a05001	 moveq       r5, #1
  00348	e5832010	 str         r2, [r3, #0x10]
  0034c	13a05000	 movne       r5, #0
  00350		 |$cleanUp$46390|

; 1362 : 
; 1363 : cleanUp:
; 1364 :     // Release hardware lock
; 1365 :     if (s_hNand != NULL) NAND_MutexExit(s_hNand);
; 1366 :     
; 1367 :     ASSERT(rc);
; 1368 :     return rc;

  00350	e59d0054	 ldr         r0, [sp, #0x54]
  00354	eb000000	 bl          __security_check_cookie

; 1369 : }

  00358	e1a00005	 mov         r0, r5
  0035c	e28dd058	 add         sp, sp, #0x58
  00360	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00364	e12fff1e	 bx          lr
  00368		 |$LN90@FMD_WriteS|
  00368		 |$LN91@FMD_WriteS|
  00368	08804001	 DCD         0x8804001
  0036c		 |$LN92@FMD_WriteS|
  0036c	00000000	 DCD         |s_hNand|
  00370		 |$LN93@FMD_WriteS|
  00370	00000000	 DCD         |__security_cookie|
  00374		 |$M47419|

			 ENDP  ; |FMD_WriteSector|

	EXPORT	|FMD_GetBlockStatus|

  00000			 AREA	 |.pdata|, PDATA
|$T47441| DCD	|$LN13@FMD_GetBlo|
	DCD	0x40002102
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FMD_GetBlockStatus| PROC

; 1439 : {

  00000		 |$LN13@FMD_GetBlo|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M47438|

; 1440 :     DWORD rc = 0;
; 1441 :     SECTOR_ADDR sector;
; 1442 :     SectorInfo sectorInfo[2];
; 1443 : 
; 1444 : 
; 1445 :     // Check if we know flash geometry
; 1446 :     if (s_hNand == NULL) goto cleanUp;

  00008	e59f3070	 ldr         r3, [pc, #0x70]
  0000c	e3a04000	 mov         r4, #0
  00010	e5933000	 ldr         r3, [r3]
  00014	e3530000	 cmp         r3, #0
  00018	0a000014	 beq         |$cleanUp$46442|

; 1447 : 
; 1448 :     // Calculate sector
; 1449 :     sector = blockId * NAND_GetGeometry(s_hNand)->sectorsPerBlock;

  0001c	e593e04c	 ldr         lr, [r3, #0x4C]

; 1450 : 
; 1451 :     if (!FMD_ReadSector(sector, NULL, sectorInfo, 2))

  00020	e3a03002	 mov         r3, #2
  00024	e28d2000	 add         r2, sp, #0
  00028	e000009e	 mul         r0, lr, r0
  0002c	e3a01000	 mov         r1, #0
  00030	eb000000	 bl          FMD_ReadSector
  00034	e3500000	 cmp         r0, #0

; 1452 :         {
; 1453 :         rc = BLOCK_STATUS_UNKNOWN;

  00038	03a04001	 moveq       r4, #1
  0003c	0a00000b	 beq         |$cleanUp$46442|

; 1454 :         goto cleanUp;
; 1455 :         }
; 1456 : 
; 1457 :     if ((sectorInfo[0].bBadBlock != 0xFF) || (sectorInfo[1].bBadBlock != 0xFF))

  00040	e5dd3005	 ldrb        r3, [sp, #5]
  00044	e35300ff	 cmp         r3, #0xFF
  00048	1a000002	 bne         |$LN3@FMD_GetBlo|
  0004c	e5dd300d	 ldrb        r3, [sp, #0xD]
  00050	e35300ff	 cmp         r3, #0xFF
  00054	0a000000	 beq         |$LN4@FMD_GetBlo|
  00058		 |$LN3@FMD_GetBlo|

; 1458 :         {
; 1459 :         rc |= BLOCK_STATUS_BAD;

  00058	e3a04002	 mov         r4, #2
  0005c		 |$LN4@FMD_GetBlo|

; 1460 :         }
; 1461 : 
; 1462 :     if ((sectorInfo[0].bOEMReserved & OEM_BLOCK_READONLY) == 0)

  0005c	e5dd3004	 ldrb        r3, [sp, #4]
  00060	e3130002	 tst         r3, #2

; 1463 :         {
; 1464 :         rc |= BLOCK_STATUS_READONLY;

  00064	03844004	 orreq       r4, r4, #4

; 1465 :         }
; 1466 : 
; 1467 :     if ((sectorInfo[0].bOEMReserved & OEM_BLOCK_RESERVED) == 0)

  00068	e3130001	 tst         r3, #1

; 1468 :         {
; 1469 :         rc |= BLOCK_STATUS_RESERVED;

  0006c	03844008	 orreq       r4, r4, #8
  00070		 |$cleanUp$46442|

; 1470 :         }
; 1471 : 
; 1472 : cleanUp:
; 1473 :     return rc;
; 1474 : }

  00070	e1a00004	 mov         r0, r4
  00074	e28dd010	 add         sp, sp, #0x10
  00078	e8bd4010	 ldmia       sp!, {r4, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$LN14@FMD_GetBlo|
  00080		 |$LN15@FMD_GetBlo|
  00080	00000000	 DCD         |s_hNand|
  00084		 |$M47439|

			 ENDP  ; |FMD_GetBlockStatus|

	EXPORT	|FMD_SetBlockStatus|

  00000			 AREA	 |.pdata|, PDATA
|$T47465| DCD	|$LN19@FMD_SetBlo|
	DCD	0x40003e02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FMD_SetBlockStatus| PROC

; 1485 : {

  00000		 |$LN19@FMD_SetBlo|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M47462|
  00008	e1a04001	 mov         r4, r1
  0000c	e1a08000	 mov         r8, r0

; 1486 :     BOOL rc = FALSE;
; 1487 :     SECTOR_ADDR sector;
; 1488 :     SectorInfo sectorInfo;
; 1489 : 
; 1490 :     // Check if we know flash geometry
; 1491 :     if (s_hNand == NULL) goto cleanUp;

  00010	e59f30dc	 ldr         r3, [pc, #0xDC]
  00014	e3a05000	 mov         r5, #0
  00018	e5933000	 ldr         r3, [r3]
  0001c	e3530000	 cmp         r3, #0
  00020	0a00002f	 beq         |$cleanUp$46459|

; 1492 : 
; 1493 :     // Calculate sector
; 1494 :     sector = blockId * NAND_GetGeometry(s_hNand)->sectorsPerBlock;

  00024	e593704c	 ldr         r7, [r3, #0x4C]

; 1495 : 
; 1496 :     if ((status & BLOCK_STATUS_BAD) != 0)

  00028	e3140002	 tst         r4, #2
  0002c	0a00000f	 beq         |$LN5@FMD_SetBlo|

; 1497 :         {
; 1498 :         // Read the sector info
; 1499 :         if (!FMD_ReadSector(sector, NULL, &sectorInfo, 1)) goto cleanUp;

  00030	e0000897	 mul         r0, r7, r8
  00034	e3a03001	 mov         r3, #1
  00038	e28d2000	 add         r2, sp, #0
  0003c	e3a01000	 mov         r1, #0
  00040	eb000000	 bl          FMD_ReadSector
  00044	e3500000	 cmp         r0, #0
  00048	0a000025	 beq         |$cleanUp$46459|

; 1500 : 
; 1501 :         // Set the bad block marker
; 1502 :         sectorInfo.bBadBlock = 0;

  0004c	e3a03000	 mov         r3, #0

; 1503 : 
; 1504 :         // Complete the write (no erase, we changed 0xFF -> 0x00)
; 1505 :         if (!FMD_WriteSector(sector, NULL, &sectorInfo, 1)) goto cleanUp;

  00050	e0000897	 mul         r0, r7, r8
  00054	e5cd3005	 strb        r3, [sp, #5]
  00058	e3a03001	 mov         r3, #1
  0005c	e28d2000	 add         r2, sp, #0
  00060	e3a01000	 mov         r1, #0
  00064	eb000000	 bl          FMD_WriteSector
  00068	e3500000	 cmp         r0, #0
  0006c	0a00001c	 beq         |$cleanUp$46459|
  00070		 |$LN5@FMD_SetBlo|

; 1506 :         }
; 1507 : 
; 1508 : #ifdef BOOT_MODE
; 1509 :     if ( ((status & BLOCK_STATUS_READONLY) != 0) || ((status & BLOCK_STATUS_RESERVED) != 0) )

  00070	e2146004	 ands        r6, r4, #4
  00074	1a000001	 bne         |$LN3@FMD_SetBlo|
  00078	e3140008	 tst         r4, #8
  0007c	0a000017	 beq         |$LN1@FMD_SetBlo|
  00080		 |$LN3@FMD_SetBlo|

; 1510 :         {
; 1511 :         // Read the sector info
; 1512 :         if (!FMD_ReadSector(sector, NULL, &sectorInfo, 1)) goto cleanUp;

  00080	e0000897	 mul         r0, r7, r8
  00084	e3a03001	 mov         r3, #1
  00088	e28d2000	 add         r2, sp, #0
  0008c	e3a01000	 mov         r1, #0
  00090	eb000000	 bl          FMD_ReadSector
  00094	e3500000	 cmp         r0, #0
  00098	0a000011	 beq         |$cleanUp$46459|

; 1513 : 
; 1514 :         // Set the OEM field
; 1515 :         sectorInfo.bOEMReserved &= ((status & BLOCK_STATUS_READONLY) != 0) ? ~(OEM_BLOCK_READONLY) : 0xFF;

  0009c	e5dd3004	 ldrb        r3, [sp, #4]
  000a0	e3560000	 cmp         r6, #0
  000a4	13e02002	 mvnne       r2, #2
  000a8	03a020ff	 moveq       r2, #0xFF

; 1516 :         sectorInfo.bOEMReserved &= ((status & BLOCK_STATUS_RESERVED) != 0) ? ~(OEM_BLOCK_RESERVED) : 0xFF;

  000ac	e3140008	 tst         r4, #8
  000b0	e0032002	 and         r2, r3, r2
  000b4	13e03001	 mvnne       r3, #1
  000b8	03a030ff	 moveq       r3, #0xFF
  000bc	e0023003	 and         r3, r2, r3

; 1517 :         
; 1518 :         // Complete the write (no erase, changed bits from 1s to 0s)
; 1519 :         if (!FMD_WriteSector(sector, NULL, &sectorInfo, 1)) goto cleanUp;

  000c0	e0000897	 mul         r0, r7, r8
  000c4	e5cd3004	 strb        r3, [sp, #4]
  000c8	e3a03001	 mov         r3, #1
  000cc	e28d2000	 add         r2, sp, #0
  000d0	e3a01000	 mov         r1, #0
  000d4	eb000000	 bl          FMD_WriteSector
  000d8	e3500000	 cmp         r0, #0
  000dc	0a000000	 beq         |$cleanUp$46459|
  000e0		 |$LN1@FMD_SetBlo|

; 1520 :         }
; 1521 : #endif
; 1522 : 
; 1523 :     rc = TRUE;

  000e0	e3a05001	 mov         r5, #1
  000e4		 |$cleanUp$46459|

; 1524 : 
; 1525 : cleanUp:
; 1526 :     return rc;
; 1527 : }

  000e4	e1a00005	 mov         r0, r5
  000e8	e28dd008	 add         sp, sp, #8
  000ec	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000f0	e12fff1e	 bx          lr
  000f4		 |$LN20@FMD_SetBlo|
  000f4		 |$LN21@FMD_SetBlo|
  000f4	00000000	 DCD         |s_hNand|
  000f8		 |$M47463|

			 ENDP  ; |FMD_SetBlockStatus|

	EXPORT	|FMD_PowerUp|

  00000			 AREA	 |.pdata|, PDATA
|$T47513| DCD	|$LN26@FMD_PowerU|
	DCD	0x40001e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FMD_PowerUp| PROC

; 1536 : {

  00000		 |$LN26@FMD_PowerU|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M47510|

; 1537 :     // exit if FMD wasn't opened
; 1538 :     if (s_hNand == NULL) return;

  00004	e59f3068	 ldr         r3, [pc, #0x68]
  00008	e5934000	 ldr         r4, [r3]
  0000c	e3540000	 cmp         r4, #0
  00010	0a000015	 beq         |$LN20@FMD_PowerU|

; 1539 :     
; 1540 :     // Obtain hardware lock
; 1541 :     NAND_MutexEnter(s_hNand);
; 1542 : 
; 1543 :     //  Only enable during NAND read/write/erase operations
; 1544 :     NAND_Enable(s_hNand, TRUE);

  00014	e3a01001	 mov         r1, #1
  00018	e1a00004	 mov         r0, r4
  0001c	eb000000	 bl          NAND_Enable
  00020	e3a01070	 mov         r1, #0x70

; 1545 : 
; 1546 :     // Wait for NAND
; 1547 :     WaitForReadyStatus(s_hNand);   

  00024		 |$LL7@FMD_PowerU|
  00024	e594301c	 ldr         r3, [r4, #0x1C]
  00028	e1c310b0	 strh        r1, [r3]
  0002c	e5943024	 ldr         r3, [r4, #0x24]
  00030	e1d330b0	 ldrh        r3, [r3]
  00034	e3130040	 tst         r3, #0x40
  00038	0afffff9	 beq         |$LL7@FMD_PowerU|

; 1548 : 
; 1549 :     // Write the reset command
; 1550 :     NAND_SendCommand(s_hNand, NAND_CMD_RESET);

  0003c	e594301c	 ldr         r3, [r4, #0x1C]
  00040	e3a020ff	 mov         r2, #0xFF
  00044	e1c320b0	 strh        r2, [r3]

; 1551 : 
; 1552 :     // Wait for NAND
; 1553 :     WaitForReadyStatus(s_hNand);

  00048		 |$LL15@FMD_PowerU|
  00048	e594301c	 ldr         r3, [r4, #0x1C]
  0004c	e1c310b0	 strh        r1, [r3]
  00050	e5943024	 ldr         r3, [r4, #0x24]
  00054	e1d330b0	 ldrh        r3, [r3]
  00058	e3130040	 tst         r3, #0x40
  0005c	0afffff9	 beq         |$LL15@FMD_PowerU|

; 1554 : 
; 1555 :     //  Only enable during NAND read/write/erase operations
; 1556 :     NAND_Enable(s_hNand, FALSE);

  00060	e3a01000	 mov         r1, #0
  00064	e1a00004	 mov         r0, r4
  00068	eb000000	 bl          NAND_Enable

; 1557 : 
; 1558 :     // Release hardware lock
; 1559 :     NAND_MutexExit(s_hNand);

  0006c		 |$LN20@FMD_PowerU|

; 1560 : }

  0006c	e8bd4010	 ldmia       sp!, {r4, lr}
  00070	e12fff1e	 bx          lr
  00074		 |$LN27@FMD_PowerU|
  00074		 |$LN28@FMD_PowerU|
  00074	00000000	 DCD         |s_hNand|
  00078		 |$M47511|

			 ENDP  ; |FMD_PowerUp|

	EXPORT	|FMD_PowerDown|

  00000			 AREA	 |.pdata|, PDATA
|$T47561| DCD	|$LN26@FMD_PowerD|
	DCD	0x40001e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FMD_PowerDown| PROC

; 1569 : {

  00000		 |$LN26@FMD_PowerD|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M47558|

; 1570 :     // exit if FMD wasn't opened
; 1571 :     if (s_hNand == NULL) return;

  00004	e59f3068	 ldr         r3, [pc, #0x68]
  00008	e5934000	 ldr         r4, [r3]
  0000c	e3540000	 cmp         r4, #0
  00010	0a000015	 beq         |$LN20@FMD_PowerD|

; 1572 :     
; 1573 :     // Obtain hardware lock
; 1574 :     NAND_MutexEnter(s_hNand);
; 1575 : 
; 1576 :     //  Only enable during NAND read/write/erase operations
; 1577 :     NAND_Enable(s_hNand, TRUE);

  00014	e3a01001	 mov         r1, #1
  00018	e1a00004	 mov         r0, r4
  0001c	eb000000	 bl          NAND_Enable
  00020	e3a01070	 mov         r1, #0x70

; 1578 : 
; 1579 :     // Wait for NAND
; 1580 :     WaitForReadyStatus(s_hNand);   

  00024		 |$LL7@FMD_PowerD|
  00024	e594301c	 ldr         r3, [r4, #0x1C]
  00028	e1c310b0	 strh        r1, [r3]
  0002c	e5943024	 ldr         r3, [r4, #0x24]
  00030	e1d330b0	 ldrh        r3, [r3]
  00034	e3130040	 tst         r3, #0x40
  00038	0afffff9	 beq         |$LL7@FMD_PowerD|

; 1581 : 
; 1582 :     // Write the reset command
; 1583 :     NAND_SendCommand(s_hNand, NAND_CMD_RESET);

  0003c	e594301c	 ldr         r3, [r4, #0x1C]
  00040	e3a020ff	 mov         r2, #0xFF
  00044	e1c320b0	 strh        r2, [r3]

; 1584 : 
; 1585 :     // Wait for NAND
; 1586 :     WaitForReadyStatus(s_hNand);

  00048		 |$LL15@FMD_PowerD|
  00048	e594301c	 ldr         r3, [r4, #0x1C]
  0004c	e1c310b0	 strh        r1, [r3]
  00050	e5943024	 ldr         r3, [r4, #0x24]
  00054	e1d330b0	 ldrh        r3, [r3]
  00058	e3130040	 tst         r3, #0x40
  0005c	0afffff9	 beq         |$LL15@FMD_PowerD|

; 1587 : 
; 1588 :     //  Only enable during NAND read/write/erase operations
; 1589 :     NAND_Enable(s_hNand, FALSE);

  00060	e3a01000	 mov         r1, #0
  00064	e1a00004	 mov         r0, r4
  00068	eb000000	 bl          NAND_Enable

; 1590 : 
; 1591 :     // Release hardware lock
; 1592 :     NAND_MutexExit(s_hNand);

  0006c		 |$LN20@FMD_PowerD|

; 1593 : }

  0006c	e8bd4010	 ldmia       sp!, {r4, lr}
  00070	e12fff1e	 bx          lr
  00074		 |$LN27@FMD_PowerD|
  00074		 |$LN28@FMD_PowerD|
  00074	00000000	 DCD         |s_hNand|
  00078		 |$M47559|

			 ENDP  ; |FMD_PowerDown|

	EXPORT	|FMD_OEMIoControl|

  00000			 AREA	 |.pdata|, PDATA
|$T47572| DCD	|$LN5@FMD_OEMIoC|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FMD_OEMIoControl| PROC

; 1608 : {

  00000		 |$LN5@FMD_OEMIoC|
  00000		 |$M47569|

; 1609 : 
; 1610 :     UNREFERENCED_PARAMETER(code);
; 1611 : 
; 1612 :     UNREFERENCED_PARAMETER(pInBuffer);
; 1613 :     UNREFERENCED_PARAMETER(inSize);
; 1614 :     UNREFERENCED_PARAMETER(pOutBuffer);
; 1615 :     UNREFERENCED_PARAMETER(outSize);
; 1616 :     UNREFERENCED_PARAMETER(pOutSize);
; 1617 :     
; 1618 :     return FALSE;    

  00000	e3a00000	 mov         r0, #0

; 1619 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M47570|

			 ENDP  ; |FMD_OEMIoControl|

	EXPORT	|??_C@_1KI@MDFCMHMG@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HG@DCOIKHPB@?$AAF?$AAM?$AAD?$AA?5?$AAd?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?5?$AAs?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AAs?$AA?5?$AAo?$AAn?$AAl?$AAy?$AA?5?$AA1?$AA6?$AAb?$AAi?$AAt?$AAs?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DK@CAAJGKFH@?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt?$AA?5?$AAE?$AAC?$AAC?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?5?$AAs?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|BSPGetNandIrqWait|
	IMPORT	|BSPGetNandInfo|
	IMPORT	|NKDbgPrintfW|
	IMPORT	|g_ecctype|
	IMPORT	|OALPAtoVA|
	IMPORT	|SOCGetGPMCAddress|

  00004			 AREA	 |.bss|, NOINIT
|s_Device| %	0x68
|s_Device| %	0x68

  00000			 AREA	 |.pdata|, PDATA
|$T47604| DCD	|$LN22@NAND_Initi|
	DCD	0x40008401

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1KI@MDFCMHMG@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| DCB "C"
	DCB	0x0, ":", 0x0, "\\", 0x0, "W", 0x0, "I", 0x0, "N", 0x0, "C"
	DCB	0x0, "E", 0x0, "6", 0x0, "0", 0x0, "0", 0x0, "\\", 0x0, "P"
	DCB	0x0, "L", 0x0, "A", 0x0, "T", 0x0, "F", 0x0, "O", 0x0, "R"
	DCB	0x0, "M", 0x0, "\\", 0x0, "C", 0x0, "O", 0x0, "M", 0x0, "M"
	DCB	0x0, "O", 0x0, "N", 0x0, "\\", 0x0, "S", 0x0, "R", 0x0, "C"
	DCB	0x0, "\\", 0x0, "S", 0x0, "O", 0x0, "C", 0x0, "\\", 0x0, "C"
	DCB	0x0, "O", 0x0, "M", 0x0, "M", 0x0, "O", 0x0, "N", 0x0, "_"
	DCB	0x0, "T", 0x0, "I", 0x0, "_", 0x0, "V", 0x0, "1", 0x0, "\\"
	DCB	0x0, "C", 0x0, "O", 0x0, "M", 0x0, "M", 0x0, "O", 0x0, "N"
	DCB	0x0, "_", 0x0, "T", 0x0, "I", 0x0, "\\", 0x0, "B", 0x0, "L"
	DCB	0x0, "O", 0x0, "C", 0x0, "K", 0x0, "\\", 0x0, "N", 0x0, "A"
	DCB	0x0, "N", 0x0, "D", 0x0, "\\", 0x0, "B", 0x0, "O", 0x0, "O"
	DCB	0x0, "T", 0x0, "\\", 0x0, ".", 0x0, ".", 0x0, "\\", 0x0, "f"
	DCB	0x0, "m", 0x0, "d", 0x0, ".", 0x0, "c", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "%", 0x0, "s", 0x0, " ", 0x0, "l", 0x0, "i", 0x0, "n"
	DCB	0x0, "e", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ":", 0x0, " "
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HG@DCOIKHPB@?$AAF?$AAM?$AAD?$AA?5?$AAd?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?5?$AAs?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AAs?$AA?5?$AAo?$AAn?$AAl?$AAy?$AA?5?$AA1?$AA6?$AAb?$AAi?$AAt?$AAs?$AA?5@| DCB "F"
	DCB	0x0, "M", 0x0, "D", 0x0, " ", 0x0, "d", 0x0, "r", 0x0, "i"
	DCB	0x0, "v", 0x0, "e", 0x0, "r", 0x0, " ", 0x0, "s", 0x0, "u"
	DCB	0x0, "p", 0x0, "p", 0x0, "o", 0x0, "r", 0x0, "t", 0x0, "s"
	DCB	0x0, " ", 0x0, "o", 0x0, "n", 0x0, "l", 0x0, "y", 0x0, " "
	DCB	0x0, "1", 0x0, "6", 0x0, "b", 0x0, "i", 0x0, "t", 0x0, "s"
	DCB	0x0, " ", 0x0, "l", 0x0, "a", 0x0, "r", 0x0, "g", 0x0, "e"
	DCB	0x0, " ", 0x0, "p", 0x0, "a", 0x0, "g", 0x0, "e", 0x0, " "
	DCB	0x0, "(", 0x0, "2", 0x0, "K", 0x0, "B", 0x0, ")", 0x0, " "
	DCB	0x0, "d", 0x0, "e", 0x0, "v", 0x0, "i", 0x0, "c", 0x0, "e"
	DCB	0x0, "s", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DK@CAAJGKFH@?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt?$AA?5?$AAE?$AAC?$AAC?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?5?$AAs?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?$AN?$AA?6?$AA?$AA@| DCB "I"
	DCB	0x0, "n", 0x0, "c", 0x0, "o", 0x0, "r", 0x0, "r", 0x0, "e"
	DCB	0x0, "c", 0x0, "t", 0x0, " ", 0x0, "E", 0x0, "C", 0x0, "C"
	DCB	0x0, " ", 0x0, "t", 0x0, "y", 0x0, "p", 0x0, "e", 0x0, " "
	DCB	0x0, "s", 0x0, "e", 0x0, "t", 0x0, "t", 0x0, "i", 0x0, "n"
	DCB	0x0, "g", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_Initialize| PROC

; 389  : {

  00000		 |$LN22@NAND_Initi|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M47601|
  00004	e1a04001	 mov         r4, r1

; 390  :     DWORD chipSelect = BSPGetNandCS();

  00008	eb000000	 bl          BSPGetNandCS

; 391  :     const NAND_INFO *  pBSPNandInfo;
; 392  :     HANDLE hDevice = NULL;
; 393  :     UINT ffPrefetchMode = 0;
; 394  :     UINT8 manufacturer, device;
; 395  :     NandDevice_t *pDevice = &s_Device;
; 396  : #ifndef BOOT_MODE    
; 397  :     DWORD dwKernelRet;
; 398  : #endif
; 399  : 
; 400  :     UNREFERENCED_PARAMETER(pRegOut);
; 401  :     UNREFERENCED_PARAMETER(szContext);
; 402  :     // initialize structure
; 403  :     memset(pDevice, 0, sizeof(NandDevice_t));

  0000c	e59f51f8	 ldr         r5, [pc, #0x1F8]
  00010	e1a06000	 mov         r6, r0
  00014	e3a02068	 mov         r2, #0x68
  00018	e1a00005	 mov         r0, r5
  0001c	e3a01000	 mov         r1, #0
  00020	e3a07000	 mov         r7, #0
  00024	eb000000	 bl          memset

; 404  : 
; 405  : #ifdef BOOT_MODE    
; 406  :     pDevice->pGpmcRegs = (OMAP_GPMC_REGS*)OALPAtoUA(SOCGetGPMCAddress(0));

  00028	e3a00000	 mov         r0, #0
  0002c	eb000000	 bl          SOCGetGPMCAddress
  00030	e3a01000	 mov         r1, #0
  00034	eb000000	 bl          OALPAtoVA
  00038	e585002c	 str         r0, [r5, #0x2C]

; 407  :     pDevice->pFifo = (NANDREG*)OALPAtoUA(pRegIn->MemBase.Reg[0]);

  0003c	e5940310	 ldr         r0, [r4, #0x310]
  00040	e3a01000	 mov         r1, #0
  00044	eb000000	 bl          OALPAtoVA

; 408  : 
; 409  :     /* Get ECC mode from BootCfg */
; 410  :     pDevice->ECCtype = g_ecctype;

  00048	e59f31b8	 ldr         r3, [pc, #0x1B8]
  0004c	e5850028	 str         r0, [r5, #0x28]
  00050	e5d33000	 ldrb        r3, [r3]
  00054	e5853060	 str         r3, [r5, #0x60]

; 411  :     if((pDevice->ECCtype > BCH8bit) || (pDevice->ECCtype < Hamming1bit))

  00058	e3530002	 cmp         r3, #2
  0005c	ca000001	 bgt         |$LN5@NAND_Initi|
  00060	e3530000	 cmp         r3, #0
  00064	5a000003	 bpl         |$LN6@NAND_Initi|
  00068		 |$LN5@NAND_Initi|

; 412  :     	{
; 413  :             pDevice->ECCtype = Hamming1bit;
; 414  :             RETAILMSG(TRUE, (L"Incorrect ECC type setting\r\n"));			

  00068	e59f0194	 ldr         r0, [pc, #0x194]
  0006c	e3a03000	 mov         r3, #0
  00070	e5853060	 str         r3, [r5, #0x60]
  00074	eb000000	 bl          NKDbgPrintfW
  00078		 |$LN6@NAND_Initi|

; 415  :     	}
; 416  : #else    
; 417  :     if (szContext != NULL)
; 418  :         {
; 419  :         if (InitializePointers(szContext, pDevice) == FALSE) goto cleanUp;
; 420  :         }
; 421  :     else
; 422  :         {
; 423  :         PHYSICAL_ADDRESS pa;
; 424  :         
; 425  :         // if there's not context string then use global macros
; 426  : 
; 427  :         pa.QuadPart = pRegIn->MemBase.Reg[0];
; 428  :         pDevice->memLen[0] = pRegIn->MemLen.Reg[0];
; 429  :         pDevice->pGpmcRegs = MmMapIoSpace(pa, pDevice->memLen[0], FALSE);
; 430  :         if (pDevice->pGpmcRegs == NULL) goto cleanUp;
; 431  : 
; 432  :         pa.QuadPart = pRegIn->MemBase.Reg[1];
; 433  :         pDevice->memLen[1] = pRegIn->MemLen.Reg[1];
; 434  :         pDevice->pFifo = MmMapIoSpace(pa, pDevice->memLen[1], FALSE);
; 435  :         if (pDevice->pGpmcRegs == NULL) goto cleanUp;
; 436  : 
; 437  :         }
; 438  : 
; 439  : 
; 440  :         if (!KernelIoControl(IOCTL_HAL_GET_ECC_TYPE,
; 441  :                              NULL, 0, &pDevice->ECCtype, sizeof(DWORD), &dwKernelRet))
; 442  :         {
; 443  :             RETAILMSG( TRUE,(TEXT("Failed to read Ecc type\r\n")));
; 444  :             pDevice->ECCtype = Hamming1bit;
; 445  :         }   
; 446  : 	
; 447  :         RETAILMSG(TRUE, (L"ECC TYPE is %s\r\n", (pDevice->ECCtype==Hamming1bit)? L"Hamming 1 bit" :
; 448  : 			                                                    (pDevice->ECCtype==BCH4bit)? L"BCH 4 bit" : L"BCH 8 bit"));
; 449  : 	
; 450  : #endif
; 451  : 
; 452  :     pDevice->pNandCmd = (NANDREG*)((UINT32)pDevice->pGpmcRegs + offset(OMAP_GPMC_REGS, GPMC_NAND_COMMAND_0) + (0x30 * chipSelect));

  00078	e595202c	 ldr         r2, [r5, #0x2C]
  0007c	e0863086	 add         r3, r6, r6, lsl #1

; 453  :     pDevice->pNandAddress= (NANDREG*)((UINT32)pDevice->pGpmcRegs + offset(OMAP_GPMC_REGS, GPMC_NAND_ADDRESS_0) + (0x30 * chipSelect));
; 454  :     pDevice->pNandData= (NANDREG*)((UINT32)pDevice->pGpmcRegs + offset(OMAP_GPMC_REGS, GPMC_NAND_DATA_0) + (0x30 * chipSelect));
; 455  :     // Enable GPMC wait-to-nowait edge detection mechanism on NAND R/B pin
; 456  :     NAND_Enable(pDevice, TRUE);

  00080	e3a01001	 mov         r1, #1
  00084	e0822203	 add         r2, r2, r3, lsl #4
  00088	e282307c	 add         r3, r2, #0x7C
  0008c	e585301c	 str         r3, [r5, #0x1C]
  00090	e2823080	 add         r3, r2, #0x80
  00094	e5853020	 str         r3, [r5, #0x20]
  00098	e2823084	 add         r3, r2, #0x84
  0009c	e1a00005	 mov         r0, r5
  000a0	e5853024	 str         r3, [r5, #0x24]
  000a4	eb000000	 bl          NAND_Enable

; 457  : 
; 458  :     // Write RESET command
; 459  :     // (a reset aborts any current READ, WRITE (PROGRAM) or ERASE operation)
; 460  :     NAND_SendCommand(pDevice, NAND_CMD_RESET);

  000a8	e595301c	 ldr         r3, [r5, #0x1C]
  000ac	e3a020ff	 mov         r2, #0xFF
  000b0	e1c320b0	 strh        r2, [r3]
  000b4	e3a02070	 mov         r2, #0x70
  000b8		 |$LL4@NAND_Initi|

; 461  : 
; 462  :     // Wait for NAND
; 463  :     while ((NAND_GetStatus(pDevice) & NAND_STATUS_READY) == 0);

  000b8	e595301c	 ldr         r3, [r5, #0x1C]
  000bc	e1c320b0	 strh        r2, [r3]
  000c0	e5953024	 ldr         r3, [r5, #0x24]
  000c4	e1d330b0	 ldrh        r3, [r3]
  000c8	e3130040	 tst         r3, #0x40
  000cc	0afffff9	 beq         |$LL4@NAND_Initi|

; 464  : 
; 465  :     // Send Read ID Command
; 466  :     NAND_SendCommand(pDevice, NAND_CMD_READID);

  000d0	e595301c	 ldr         r3, [r5, #0x1C]
  000d4	e3a02090	 mov         r2, #0x90

; 467  : 
; 468  :     // Send Address 00h
; 469  :     WRITE_NAND(pDevice->pNandAddress, 0);

  000d8	e3a08000	 mov         r8, #0
  000dc	e1c320b0	 strh        r2, [r3]
  000e0	e5953020	 ldr         r3, [r5, #0x20]
  000e4	e1c380b0	 strh        r8, [r3]

; 470  : 
; 471  :     // Read the manufacturer ID & device code
; 472  :     manufacturer = (UINT8)READ_NAND(pDevice->pNandData);

  000e8	e5952024	 ldr         r2, [r5, #0x24]
  000ec	e5d20000	 ldrb        r0, [r2]

; 473  :     device = (UINT8)READ_NAND(pDevice->pNandData);

  000f0	e5d21000	 ldrb        r1, [r2]

; 474  : 
; 475  :  
; 476  :     if ((pBSPNandInfo = BSPGetNandInfo(manufacturer,device))==NULL)

  000f4	eb000000	 bl          BSPGetNandInfo
  000f8	e1b04000	 movs        r4, r0
  000fc	0a000039	 beq         |$cleanUp$46064|

; 477  :     {                
; 478  :         goto cleanUp;
; 479  :     }
; 480  :     if ((pBSPNandInfo->sectorSize != 2048) && (pBSPNandInfo->wordData != 2))

  00100	e594300c	 ldr         r3, [r4, #0xC]
  00104	e3530b02	 cmp         r3, #2, 22
  00108	0a00000a	 beq         |$LN1@NAND_Initi|
  0010c	e5943010	 ldr         r3, [r4, #0x10]
  00110	e3530002	 cmp         r3, #2
  00114	0a000007	 beq         |$LN1@NAND_Initi|

; 481  :     {
; 482  :         ERRORMSG(1,(TEXT("FMD driver supports only 16bits large page (2KB) devices\r\n")));

  00118	e59f10e0	 ldr         r1, [pc, #0xE0]
  0011c	e59f00d8	 ldr         r0, [pc, #0xD8]
  00120	e3a03c01	 mov         r3, #1, 24
  00124	e38320e2	 orr         r2, r3, #0xE2
  00128	eb000000	 bl          NKDbgPrintfW
  0012c	e59f00c4	 ldr         r0, [pc, #0xC4]
  00130	eb000000	 bl          NKDbgPrintfW

; 483  :         goto cleanUp;

  00134	ea00002b	 b           |$cleanUp$46064|
  00138		 |$LN1@NAND_Initi|

; 484  :     }
; 485  :     pDevice->nandInfo = *pBSPNandInfo;

  00138	e2850044	 add         r0, r5, #0x44
  0013c	e3a02014	 mov         r2, #0x14
  00140	e1a01004	 mov         r1, r4
  00144	eb000000	 bl          memcpy

; 486  : 
; 487  :     pDevice->IrqWait = BSPGetNandIrqWait();

  00148	eb000000	 bl          BSPGetNandIrqWait

; 488  : 
; 489  :     /* ECCCfg: 16bit bus width, cs0, 4 - 512 bytes blocks per page */
; 490  :     pDevice->ECCCfg = (GPMC_ECC_CONFIG_16BIT | (chipSelect << 1) | (0x3<<4)); 

  0014c	e3863058	 orr         r3, r6, #0x58
  00150	e1a01083	 mov         r1, r3, lsl #1
  00154	e585005c	 str         r0, [r5, #0x5C]
  00158	e5851058	 str         r1, [r5, #0x58]

; 491  :     pDevice->ECCsize = (pDevice->ECCtype == Hamming1bit ) ? ECC_BYTES_HAMMING : 
; 492  : 		                      (pDevice->ECCtype == BCH4bit ) ? ECC_BYTES_BCH4 : ECC_BYTES_BCH8; 

  0015c	e5952060	 ldr         r2, [r5, #0x60]
  00160	e3520000	 cmp         r2, #0
  00164	03a0300c	 moveq       r3, #0xC
  00168	0a000002	 beq         |$LN10@NAND_Initi|
  0016c	e3520001	 cmp         r2, #1
  00170	03a0301c	 moveq       r3, #0x1C
  00174	13a03034	 movne       r3, #0x34
  00178		 |$LN10@NAND_Initi|
  00178	e5853064	 str         r3, [r5, #0x64]

; 493  : 							  
; 494  :     //  Enable and reset ECC engine (workaround for engine giving 0s first time)
; 495  :     ECC_Init(pDevice->pGpmcRegs, pDevice->ECCCfg, pDevice->ECCtype, NAND_ECC_READ);

  0017c	e595002c	 ldr         r0, [r5, #0x2C]
  00180	e3a03000	 mov         r3, #0
  00184	eb000000	 bl          ECC_Init

; 496  :     ECC_Reset(pDevice->pGpmcRegs);

  00188	e595002c	 ldr         r0, [r5, #0x2C]
  0018c	eb000000	 bl          ECC_Reset

; 497  : 
; 498  :     //  Only enable during NAND read/write/erase operations
; 499  :     NAND_Enable(pDevice, FALSE);

  00190	e3a01000	 mov         r1, #0
  00194	e1a00005	 mov         r0, r5
  00198	eb000000	 bl          NAND_Enable

; 500  : 
; 501  :     // configure the prefetch engine
; 502  :     pDevice->prefetchMode = kPrefetchOff;

  0019c	e3a03000	 mov         r3, #0
  001a0	e5853018	 str         r3, [r5, #0x18]

; 503  :     OUTREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONTROL, 0);

  001a4	e595302c	 ldr         r3, [r5, #0x2C]

; 504  : 
; 505  :     // set prefetch mask
; 506  :     ffPrefetchMode = GPMC_PREFETCH_CONFIG_SYNCHROMODE |
; 507  :                      GPMC_PREFETCH_CONFIG_PFPWENROUNDROBIN |
; 508  :                      GPMC_PREFETCH_CONFIG_ENABLEOPTIMIZEDACCESS |
; 509  :                      GPMC_PREFETCH_CONFIG_WAITPINSELECTOR(chipSelect) |
; 510  :                      GPMC_PREFETCH_CONFIG_FIFOTHRESHOLD(FIFO_THRESHOLD) |
; 511  :                      GPMC_PREFETCH_CONFIG_ENGINECSSELECTOR(chipSelect);

  001a8	e59f0044	 ldr         r0, [pc, #0x44]

; 512  : 
; 513  :     OUTREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONFIG1, ffPrefetchMode);

  001ac	e2062007	 and         r2, r6, #7
  001b0	e58381ec	 str         r8, [r3, #0x1EC]
  001b4	e2063003	 and         r3, r6, #3
  001b8	e595102c	 ldr         r1, [r5, #0x2C]
  001bc	e1833a02	 orr         r3, r3, r2, lsl #20
  001c0	e1803203	 orr         r3, r0, r3, lsl #4
  001c4	e58131e0	 str         r3, [r1, #0x1E0]

; 514  : 
; 515  :     // configure prefetch engine
; 516  :     OUTREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONFIG2, 
; 517  :         pBSPNandInfo->sectorSize
; 518  :         );

  001c8	e595202c	 ldr         r2, [r5, #0x2C]
  001cc	e594300c	 ldr         r3, [r4, #0xC]

; 519  :         
; 520  :     SETREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONFIG1, 
; 521  :         GPMC_PREFETCH_CONFIG_ENABLEENGINE
; 522  :         );
; 523  : 
; 524  :     // We are done
; 525  :     hDevice = pDevice;

  001d0	e1a07005	 mov         r7, r5
  001d4	e58231e4	 str         r3, [r2, #0x1E4]
  001d8	e595202c	 ldr         r2, [r5, #0x2C]
  001dc	e59231e0	 ldr         r3, [r2, #0x1E0]
  001e0	e3833080	 orr         r3, r3, #0x80
  001e4	e58231e0	 str         r3, [r2, #0x1E0]
  001e8		 |$cleanUp$46064|

; 526  : 
; 527  : cleanUp:
; 528  :     return hDevice;
; 529  : }

  001e8	e1a00007	 mov         r0, r7
  001ec	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  001f0	e12fff1e	 bx          lr
  001f4		 |$LN23@NAND_Initi|
  001f4		 |$LN24@NAND_Initi|
  001f4	08804008	 DCD         0x8804008
  001f8		 |$LN25@NAND_Initi|
  001f8	00000000	 DCD         |??_C@_1HG@DCOIKHPB@?$AAF?$AAM?$AAD?$AA?5?$AAd?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?5?$AAs?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AAs?$AA?5?$AAo?$AAn?$AAl?$AAy?$AA?5?$AA1?$AA6?$AAb?$AAi?$AAt?$AAs?$AA?5@|
  001fc		 |$LN26@NAND_Initi|
  001fc	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  00200		 |$LN27@NAND_Initi|
  00200	00000000	 DCD         |??_C@_1KI@MDFCMHMG@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  00204		 |$LN28@NAND_Initi|
  00204	00000000	 DCD         |??_C@_1DK@CAAJGKFH@?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt?$AA?5?$AAE?$AAC?$AAC?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?5?$AAs?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?$AN?$AA?6?$AA?$AA@|
  00208		 |$LN29@NAND_Initi|
  00208	00000000	 DCD         |g_ecctype|
  0020c		 |$LN30@NAND_Initi|
  0020c	00000000	 DCD         |s_Device|
  00210		 |$M47602|

			 ENDP  ; |NAND_Initialize|


  00000			 AREA	 |.pdata|, PDATA
|$T47636| DCD	|$LN11@NAND_Erase|
	DCD	0x40001801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_EraseBlock| PROC

; 728  : {    

  00000		 |$LN11@NAND_Erase|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M47633|
  00004	e1a0e000	 mov         lr, r0

; 729  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 730  :     
; 731  :     // Calculate the sector number
; 732  :     NAND_SendCommand(hNand, NAND_CMD_ERASE_SETUP);    

  00008	e59e301c	 ldr         r3, [lr, #0x1C]
  0000c	e3a02060	 mov         r2, #0x60

; 733  :     BlockAccess(pDevice, blockId);
; 734  :     NAND_SendCommand(hNand, NAND_CMD_ERASE_CONFIRM);

  00010	e3a040d0	 mov         r4, #0xD0
  00014	e1c320b0	 strh        r2, [r3]
  00018	e59e304c	 ldr         r3, [lr, #0x4C]
  0001c	e59e2020	 ldr         r2, [lr, #0x20]

; 735  :     
; 736  :     return TRUE;

  00020	e3a00001	 mov         r0, #1
  00024	e0010193	 mul         r1, r3, r1
  00028	e20130ff	 and         r3, r1, #0xFF
  0002c	e1c230b0	 strh        r3, [r2]
  00030	e59e2020	 ldr         r2, [lr, #0x20]
  00034	e1a03801	 mov         r3, r1, lsl #16
  00038	e1a03c23	 mov         r3, r3, lsr #24
  0003c	e1c230b0	 strh        r3, [r2]
  00040	e59e2020	 ldr         r2, [lr, #0x20]
  00044	e1a03401	 mov         r3, r1, lsl #8
  00048	e1a03c23	 mov         r3, r3, lsr #24
  0004c	e1c230b0	 strh        r3, [r2]
  00050	e59e301c	 ldr         r3, [lr, #0x1C]
  00054	e1c340b0	 strh        r4, [r3]

; 737  : }

  00058	e8bd4010	 ldmia       sp!, {r4, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$M47634|

			 ENDP  ; |NAND_EraseBlock|

	EXPORT	|FMD_Init|

  00000			 AREA	 |.pdata|, PDATA
|$T47649| DCD	|$LN6@FMD_Init|
	DCD	0x40000b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FMD_Init| PROC

; 914  : {

  00000		 |$LN6@FMD_Init|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M47646|

; 915  :     HANDLE hRet = NULL;
; 916  : 
; 917  :     // Map NAND registers
; 918  :     s_hNand = NAND_Initialize(szContext, pRegIn, pRegOut);

  00004	e3a04000	 mov         r4, #0
  00008	eb000000	 bl          NAND_Initialize
  0000c	e59f3014	 ldr         r3, [pc, #0x14]
  00010	e3500000	 cmp         r0, #0

; 919  :     if (s_hNand == NULL)
; 920  :         {
; 921  :         goto cleanUp;
; 922  :         }
; 923  :         
; 924  :     // We are done
; 925  :     hRet = s_hNand;

  00014	11a04000	 movne       r4, r0
  00018	e5830000	 str         r0, [r3]
  0001c		 |$cleanUp$46277|

; 926  : 
; 927  : cleanUp:
; 928  :     return hRet;
; 929  : }

  0001c	e1a00004	 mov         r0, r4
  00020	e8bd4010	 ldmia       sp!, {r4, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$LN7@FMD_Init|
  00028		 |$LN8@FMD_Init|
  00028	00000000	 DCD         |s_hNand|
  0002c		 |$M47647|

			 ENDP  ; |FMD_Init|

	EXPORT	|FMD_EraseBlock|

  00000			 AREA	 |.pdata|, PDATA
|$T47746| DCD	|$LN45@FMD_EraseB|
	DCD	0x40004001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FMD_EraseBlock| PROC

; 1381 : {

  00000		 |$LN45@FMD_EraseB|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M47743|
  00004	e1a05000	 mov         r5, r0

; 1382 :     BOOL rc = FALSE;
; 1383 :     UINT32 oldIdleMode;
; 1384 : 
; 1385 :     // Check if we know flash geometry
; 1386 :     if (s_hNand == NULL) return rc;

  00008	e59f30ec	 ldr         r3, [pc, #0xEC]
  0000c	e5934000	 ldr         r4, [r3]
  00010	e3540000	 cmp         r4, #0
  00014	03a05000	 moveq       r5, #0
  00018	0a000034	 beq         |$LN4@FMD_EraseB|

; 1387 : 
; 1388 :     // Obtain hardware lock
; 1389 :     NAND_MutexEnter(s_hNand);
; 1390 : 
; 1391 :     //  Change idle mode to no-idle to ensure access to GPMC registers
; 1392 :     oldIdleMode = INREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG));

  0001c	e594302c	 ldr         r3, [r4, #0x2C]

; 1393 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), SYSCONFIG_NOIDLE);

  00020	e3a02008	 mov         r2, #8

; 1394 : 
; 1395 :     //  Only enable during NAND read/write/erase operations    
; 1396 :     NAND_Enable(s_hNand, TRUE);

  00024	e3a01001	 mov         r1, #1
  00028	e5936010	 ldr         r6, [r3, #0x10]
  0002c	e1a00004	 mov         r0, r4
  00030	e5832010	 str         r2, [r3, #0x10]
  00034	eb000000	 bl          NAND_Enable

; 1397 :     NAND_LockBlocks(s_hNand, blockId, blockId, FALSE);

  00038	e594202c	 ldr         r2, [r4, #0x2C]

; 1398 :     
; 1399 :     // send block id to erase
; 1400 :     NAND_EraseBlock(s_hNand, blockId);

  0003c	e3a01060	 mov         r1, #0x60
  00040	e3a000d0	 mov         r0, #0xD0
  00044	e5923050	 ldr         r3, [r2, #0x50]
  00048		 |$cleanUp$47672|
  00048	e3a0e070	 mov         lr, #0x70
  0004c	e3833010	 orr         r3, r3, #0x10
  00050	e5823050	 str         r3, [r2, #0x50]
  00054	e594301c	 ldr         r3, [r4, #0x1C]
  00058	e1c310b0	 strh        r1, [r3]
  0005c	e594304c	 ldr         r3, [r4, #0x4C]
  00060	e5942020	 ldr         r2, [r4, #0x20]
  00064	e0010593	 mul         r1, r3, r5
  00068	e20130ff	 and         r3, r1, #0xFF
  0006c	e1c230b0	 strh        r3, [r2]
  00070	e5942020	 ldr         r2, [r4, #0x20]
  00074	e1a03801	 mov         r3, r1, lsl #16
  00078	e1a03c23	 mov         r3, r3, lsr #24
  0007c	e1c230b0	 strh        r3, [r2]
  00080	e5942020	 ldr         r2, [r4, #0x20]
  00084	e1a03401	 mov         r3, r1, lsl #8
  00088	e1a03c23	 mov         r3, r3, lsr #24
  0008c	e1c230b0	 strh        r3, [r2]
  00090	e594301c	 ldr         r3, [r4, #0x1C]
  00094	e1c300b0	 strh        r0, [r3]

; 1401 : 
; 1402 :     // wait for completion    
; 1403 :     WaitForReadyStatus(s_hNand);

  00098		 |$LL26@FMD_EraseB|
  00098	e594301c	 ldr         r3, [r4, #0x1C]
  0009c	e1c3e0b0	 strh        lr, [r3]
  000a0	e5943024	 ldr         r3, [r4, #0x24]
  000a4	e1d330b0	 ldrh        r3, [r3]
  000a8	e3130040	 tst         r3, #0x40
  000ac	0afffff9	 beq         |$LL26@FMD_EraseB|

; 1404 : 
; 1405 :     //Verify there wasn't any error by checking the NAND status register :
; 1406 :     if ((NAND_GetStatus(s_hNand) & NAND_STATUS_ERROR) != 0)

  000b0	e594301c	 ldr         r3, [r4, #0x1C]
  000b4	e1c3e0b0	 strh        lr, [r3]
  000b8	e5943024	 ldr         r3, [r4, #0x24]
  000bc	e1d330b0	 ldrh        r3, [r3]
  000c0	e3130001	 tst         r3, #1

; 1407 :         {
; 1408 :         rc = FALSE;

  000c4	13a05000	 movne       r5, #0

; 1409 :         goto cleanUp;
; 1410 :         }
; 1411 : 
; 1412 :     // Done
; 1413 :     rc = TRUE;

  000c8	03a05001	 moveq       r5, #1
  000cc		 |$cleanUp$46429|

; 1414 : 
; 1415 : cleanUp:
; 1416 :     //  Only enable during NAND read/write/erase operations    
; 1417 :     NAND_LockBlocks(s_hNand, blockId, blockId, TRUE);

  000cc	e594202c	 ldr         r2, [r4, #0x2C]

; 1418 :     NAND_Enable(s_hNand, FALSE);

  000d0	e3a01000	 mov         r1, #0
  000d4	e1a00004	 mov         r0, r4
  000d8	e5923050	 ldr         r3, [r2, #0x50]
  000dc		 |$cleanUp$47725|
  000dc	e3c33010	 bic         r3, r3, #0x10
  000e0	e5823050	 str         r3, [r2, #0x50]
  000e4	eb000000	 bl          NAND_Enable

; 1419 :    
; 1420 : 
; 1421 :     //  Change idle mode back
; 1422 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), oldIdleMode);

  000e8	e594302c	 ldr         r3, [r4, #0x2C]

; 1423 : 
; 1424 :     // Release hardware lock
; 1425 :     if (s_hNand != NULL) NAND_MutexExit(s_hNand);
; 1426 : 
; 1427 :     return rc;

  000ec	e5836010	 str         r6, [r3, #0x10]
  000f0		 |$LN4@FMD_EraseB|

; 1428 : }

  000f0	e1a00005	 mov         r0, r5
  000f4	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000f8	e12fff1e	 bx          lr
  000fc		 |$LN46@FMD_EraseB|
  000fc		 |$LN47@FMD_EraseB|
  000fc	00000000	 DCD         |s_hNand|
  00100		 |$M47744|

			 ENDP  ; |FMD_EraseBlock|

	END
