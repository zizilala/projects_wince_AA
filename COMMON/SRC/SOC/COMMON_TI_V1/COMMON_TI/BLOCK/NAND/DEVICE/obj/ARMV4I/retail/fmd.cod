; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\BLOCK\NAND\fmd.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1BA@HGCBINMF@?$AAE?$AAC?$AAC?$AAt?$AAy?$AAp?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@BKONPLFM@?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1O@LBBNFMDB@?$AAM?$AAe?$AAm?$AAL?$AAe?$AAn?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@INLDIDEN@?$AAM?$AAe?$AAm?$AAB?$AAa?$AAs?$AAe?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.bss|, NOINIT
|s_hNand| %	0x4

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@HGCBINMF@?$AAE?$AAC?$AAC?$AAt?$AAy?$AAp?$AAe?$AA?$AA@| DCB "E", 0x0
	DCB	"C", 0x0, "C", 0x0, "t", 0x0, "y", 0x0, "p", 0x0, "e", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@BKONPLFM@?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB "T", 0x0
	DCB	"i", 0x0, "m", 0x0, "e", 0x0, "o", 0x0, "u", 0x0, "t", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1O@LBBNFMDB@?$AAM?$AAe?$AAm?$AAL?$AAe?$AAn?$AA?$AA@| DCB "M", 0x0, "e"
	DCB	0x0, "m", 0x0, "L", 0x0, "e", 0x0, "n", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@INLDIDEN@?$AAM?$AAe?$AAm?$AAB?$AAa?$AAs?$AAe?$AA?$AA@| DCB "M", 0x0
	DCB	"e", 0x0, "m", 0x0, "B", 0x0, "a", 0x0, "s", 0x0, "e", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
|g_deviceRegParams| DCD |??_C@_1BA@INLDIDEN@?$AAM?$AAe?$AAm?$AAB?$AAa?$AAs?$AAe?$AA?$AA@|
	DCD	0x3
	DCD	0x1
	DCD	0x30
	DCD	0x8
	DCD	0x0
	DCD	|??_C@_1O@LBBNFMDB@?$AAM?$AAe?$AAm?$AAL?$AAe?$AAn?$AA?$AA@|
	DCD	0x3
	DCD	0x1
	DCD	0x38
	DCD	0x8
	DCD	0x0
	DCD	|??_C@_1BA@BKONPLFM@?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x40
	DCD	0x4
	DCD	0x1388
	DCD	|??_C@_1BA@HGCBINMF@?$AAE?$AAC?$AAC?$AAt?$AAy?$AAp?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x60
	DCD	0x4
	DCD	0x0
	EXPORT	|SectorAccess|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\block\nand\fmd.c

  00000			 AREA	 |.pdata|, PDATA
|$T46675| DCD	|$LN5@SectorAcce|
	DCD	0x40001601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SectorAccess| PROC

; 217  : {

  00000		 |$LN5@SectorAcce|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M46672|

; 218  :     
; 219  :     // Offset is provided to this function in bytes; NAND device requires words
; 220  :     offset = offset / 2;
; 221  :     WRITE_NAND(pDevice->pNandAddress, (offset & 0xFF));

  00004	e590e020	 ldr         lr, [r0, #0x20]
  00008	e1a040a2	 mov         r4, r2, lsr #1
  0000c	e20430ff	 and         r3, r4, #0xFF
  00010	e1ce30b0	 strh        r3, [lr]

; 222  :     WRITE_NAND(pDevice->pNandAddress, ((offset >> 8) & 0xFF));

  00014	e5902020	 ldr         r2, [r0, #0x20]
  00018	e1a03804	 mov         r3, r4, lsl #16
  0001c	e1a03c23	 mov         r3, r3, lsr #24
  00020	e1c230b0	 strh        r3, [r2]

; 223  :     WRITE_NAND(pDevice->pNandAddress, (sector & 0xFF));

  00024	e5902020	 ldr         r2, [r0, #0x20]
  00028	e20130ff	 and         r3, r1, #0xFF

; 224  :     WRITE_NAND(pDevice->pNandAddress, ((sector >> 8) & 0xFF));

  0002c	e1a0e801	 mov         lr, r1, lsl #16
  00030	e1c230b0	 strh        r3, [r2]
  00034	e5902020	 ldr         r2, [r0, #0x20]
  00038	e1a03c2e	 mov         r3, lr, lsr #24

; 225  :     WRITE_NAND(pDevice->pNandAddress, ((sector >> 16) & 0xFF));

  0003c	e1a01401	 mov         r1, r1, lsl #8
  00040	e1c230b0	 strh        r3, [r2]
  00044	e5902020	 ldr         r2, [r0, #0x20]
  00048	e1a03c21	 mov         r3, r1, lsr #24
  0004c	e1c230b0	 strh        r3, [r2]

; 226  : }

  00050	e8bd4010	 ldmia       sp!, {r4, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M46673|

			 ENDP  ; |SectorAccess|

	EXPORT	|BlockAccess|

  00000			 AREA	 |.pdata|, PDATA
|$T46685| DCD	|$LN5@BlockAcces|
	DCD	0x40000e00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BlockAccess| PROC

; 235  : {

  00000		 |$LN5@BlockAcces|
  00000		 |$M46682|

; 236  :     blockId *= pDevice->nandInfo.sectorsPerBlock;

  00000	e590304c	 ldr         r3, [r0, #0x4C]

; 237  :     WRITE_NAND(pDevice->pNandAddress, (blockId & 0xFF));

  00004	e5902020	 ldr         r2, [r0, #0x20]
  00008	e0010193	 mul         r1, r3, r1
  0000c	e20130ff	 and         r3, r1, #0xFF
  00010	e1c230b0	 strh        r3, [r2]

; 238  :     WRITE_NAND(pDevice->pNandAddress, ((blockId >> 8) & 0xFF));

  00014	e5902020	 ldr         r2, [r0, #0x20]
  00018	e1a03801	 mov         r3, r1, lsl #16
  0001c	e1a03c23	 mov         r3, r3, lsr #24
  00020	e1c230b0	 strh        r3, [r2]

; 239  :     WRITE_NAND(pDevice->pNandAddress, ((blockId >> 16) & 0xFF));

  00024	e5902020	 ldr         r2, [r0, #0x20]
  00028	e1a03401	 mov         r3, r1, lsl #8
  0002c	e1a03c23	 mov         r3, r3, lsr #24
  00030	e1c230b0	 strh        r3, [r2]

; 240  : }

  00034	e12fff1e	 bx          lr
  00038		 |$M46683|

			 ENDP  ; |BlockAccess|

	EXPORT	|WaitOnEmptyWriteBufferStatus|

  00000			 AREA	 |.pdata|, PDATA
|$T46695| DCD	|$LN9@WaitOnEmpt|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |WaitOnEmptyWriteBufferStatus| PROC

; 249  : {

  00000		 |$LN9@WaitOnEmpt|
  00000		 |$M46692|
  00000	e590202c	 ldr         r2, [r0, #0x2C]
  00004		 |$LL3@WaitOnEmpt|

; 250  :     UINT status;
; 251  :     do
; 252  :     {
; 253  :         status = INREG32(&pDevice->pGpmcRegs->GPMC_STATUS);

  00004	e5923054	 ldr         r3, [r2, #0x54]

; 254  :     } while ((status & GPMC_STATUS_EMPTYWRITEBUFFER) == 0);

  00008	e3130001	 tst         r3, #1
  0000c	0afffffc	 beq         |$LL3@WaitOnEmpt|

; 255  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M46693|

			 ENDP  ; |WaitOnEmptyWriteBufferStatus|

	EXPORT	|InitializePointers|
	IMPORT	|MmMapIoSpace|
	IMPORT	|GetDeviceRegistryParams|
	IMPORT	|InitializeCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T46711| DCD	|$LN9@Initialize|
	DCD	0x40002301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |InitializePointers| PROC

; 263  : {

  00000		 |$LN9@Initialize|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M46708|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 264  : #ifdef BOOT_MODE
; 265  :     UNREFERENCED_PARAMETER(szContext);
; 266  :     UNREFERENCED_PARAMETER(pDevice);
; 267  : #else
; 268  :     PHYSICAL_ADDRESS pa;
; 269  :     InitializeCriticalSection(&pDevice->cs);

  0000c	e1a00005	 mov         r0, r5
  00010	eb000000	 bl          InitializeCriticalSection

; 270  : 
; 271  :     // Read device parameters
; 272  :     if (GetDeviceRegistryParams(
; 273  :             szContext, pDevice, dimof(g_deviceRegParams), g_deviceRegParams
; 274  :             ) != ERROR_SUCCESS)

  00014	e59f306c	 ldr         r3, [pc, #0x6C]
  00018	e3a02004	 mov         r2, #4
  0001c	e1a01005	 mov         r1, r5
  00020	e1a00004	 mov         r0, r4
  00024	eb000000	 bl          GetDeviceRegistryParams
  00028	e3500000	 cmp         r0, #0
  0002c	0a000002	 beq         |$LN3@Initialize|
  00030		 |$LN6@Initialize|

; 275  :         {
; 276  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: FMD_Init: "
; 277  :             L"Failed read FMD registry parameters\r\n"
; 278  :             ));
; 279  :         return FALSE;

  00030	e3a00000	 mov         r0, #0

; 305  : }

  00034	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$LN3@Initialize|

; 280  :         }
; 281  : 
; 282  :     pa.QuadPart = pDevice->memBase[0];

  0003c	e5950030	 ldr         r0, [r5, #0x30]

; 283  :     pDevice->pGpmcRegs = MmMapIoSpace(pa, pDevice->memLen[0], FALSE);

  00040	e5952038	 ldr         r2, [r5, #0x38]
  00044	e3a01000	 mov         r1, #0
  00048	e3a03000	 mov         r3, #0
  0004c	eb000000	 bl          MmMapIoSpace
  00050	e3500000	 cmp         r0, #0
  00054	e585002c	 str         r0, [r5, #0x2C]

; 284  :     if (pDevice->pGpmcRegs == NULL)
; 285  :         {
; 286  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: FMD_Init: "
; 287  :             L"Failed map FMD registers (0x%08x/0x%08x)\r\n",
; 288  :             pDevice->memBase[0], pDevice->memLen[0]
; 289  :             ));
; 290  :         return FALSE;

  00058	0afffff4	 beq         |$LN6@Initialize|

; 291  :         }
; 292  : 
; 293  :     pa.QuadPart = pDevice->memBase[1];

  0005c	e5950034	 ldr         r0, [r5, #0x34]

; 294  :     pDevice->pFifo = (NANDREG*)MmMapIoSpace(pa, pDevice->memLen[1], FALSE);

  00060	e595203c	 ldr         r2, [r5, #0x3C]
  00064	e3a01000	 mov         r1, #0
  00068	e3a03000	 mov         r3, #0
  0006c	eb000000	 bl          MmMapIoSpace
  00070	e3500000	 cmp         r0, #0
  00074	e5850028	 str         r0, [r5, #0x28]

; 295  :     if (pDevice->pFifo == NULL)
; 296  :         {
; 297  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: FMD_Init: "
; 298  :             L"Failed map FMD registers (0x%08x/0x%08x)\r\n",
; 299  :             pDevice->memBase[0], pDevice->memLen[0]
; 300  :             ));
; 301  :         return FALSE;

  00078	0affffec	 beq         |$LN6@Initialize|

; 302  :         }
; 303  : #endif
; 304  :      return TRUE;

  0007c	e3a00001	 mov         r0, #1

; 305  : }

  00080	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00084	e12fff1e	 bx          lr
  00088		 |$LN10@Initialize|
  00088		 |$LN11@Initialize|
  00088	00000000	 DCD         |g_deviceRegParams|
  0008c		 |$M46709|

			 ENDP  ; |InitializePointers|

	EXPORT	|NAND_GetGpmcRegs|

  00000			 AREA	 |.pdata|, PDATA
|$T46723| DCD	|$LN5@NAND_GetGp|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_GetGpmcRegs| PROC

; 313  : {

  00000		 |$LN5@NAND_GetGp|
  00000		 |$M46720|

; 314  :     return ((NandDevice_t*)hNand)->pGpmcRegs;

  00000	e590002c	 ldr         r0, [r0, #0x2C]

; 315  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M46721|

			 ENDP  ; |NAND_GetGpmcRegs|

	EXPORT	|NAND_GetGeometry|

  00000			 AREA	 |.pdata|, PDATA
|$T46733| DCD	|$LN5@NAND_GetGe|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_GetGeometry| PROC

; 324  : {

  00000		 |$LN5@NAND_GetGe|
  00000		 |$M46730|

; 325  :     return &(((NandDevice_t*)hNand)->nandInfo);

  00000	e2800044	 add         r0, r0, #0x44

; 326  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M46731|

			 ENDP  ; |NAND_GetGeometry|


  00000			 AREA	 |.pdata|, PDATA
|$T46746| DCD	|$LN9@NAND_LockB|
	DCD	0x40000b00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_LockBlocks| PROC

; 336  : {

  00000		 |$LN9@NAND_LockB|
  00000		 |$M46743|
  00000	e1b02000	 movs        r2, r0

; 337  :     BOOL rc = FALSE; 

  00004	e3a00000	 mov         r0, #0

; 338  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 339  : 
; 340  :     UNREFERENCED_PARAMETER(blockEnd);
; 341  :     UNREFERENCED_PARAMETER(blockStart);
; 342  : 
; 343  :     if (pDevice == NULL) goto cleanUp;

  00008	0a000006	 beq         |$cleanUp$46040|

; 344  : 
; 345  :     if (bLock)
; 346  :         {
; 347  :         CLRREG32(&pDevice->pGpmcRegs->GPMC_CONFIG, GPMC_CONFIG_WRITEPROTECT);        

  0000c	e592202c	 ldr         r2, [r2, #0x2C]
  00010	e3530000	 cmp         r3, #0

; 348  :         }
; 349  :     else
; 350  :         {
; 351  :         SETREG32(&pDevice->pGpmcRegs->GPMC_CONFIG, GPMC_CONFIG_WRITEPROTECT);
; 352  :         }
; 353  :     rc = TRUE;

  00014	e3a00001	 mov         r0, #1
  00018	e5923050	 ldr         r3, [r2, #0x50]
  0001c	13c33010	 bicne       r3, r3, #0x10
  00020	03833010	 orreq       r3, r3, #0x10
  00024	e5823050	 str         r3, [r2, #0x50]
  00028		 |$cleanUp$46040|

; 354  : 
; 355  : cleanUp:
; 356  :     return rc;
; 357  : }

  00028	e12fff1e	 bx          lr
  0002c		 |$M46744|

			 ENDP  ; |NAND_LockBlocks|

	IMPORT	|MmUnmapIoSpace|

  00000			 AREA	 |.pdata|, PDATA
|$T46754| DCD	|$LN7@NAND_Unini|
	DCD	0x40000e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_Uninitialize| PROC

; 364  : {

  00000		 |$LN7@NAND_Unini|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M46751|
  00004	e1a04000	 mov         r4, r0

; 365  : #ifdef BOOT_MODE
; 366  :     UNREFERENCED_PARAMETER(hNand);
; 367  : #else
; 368  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 369  : 
; 370  :     if (pDevice->pGpmcRegs != NULL)

  00008	e594302c	 ldr         r3, [r4, #0x2C]
  0000c	e3530000	 cmp         r3, #0

; 371  :         {
; 372  :         MmUnmapIoSpace((void*)pDevice->pGpmcRegs, pDevice->memLen[0]);

  00010	15941038	 ldrne       r1, [r4, #0x38]
  00014	11a00003	 movne       r0, r3
  00018	1b000000	 blne        MmUnmapIoSpace

; 373  :         }
; 374  : 
; 375  :     if (pDevice->pFifo != NULL)

  0001c	e5943028	 ldr         r3, [r4, #0x28]
  00020	e3530000	 cmp         r3, #0

; 376  :         {
; 377  :         MmUnmapIoSpace((void*)pDevice->pFifo, pDevice->memLen[1]);

  00024	1594103c	 ldrne       r1, [r4, #0x3C]
  00028	11a00003	 movne       r0, r3
  0002c	1b000000	 blne        MmUnmapIoSpace

; 378  :         }
; 379  : #endif
; 380  : }

  00030	e8bd4010	 ldmia       sp!, {r4, lr}
  00034	e12fff1e	 bx          lr
  00038		 |$M46752|

			 ENDP  ; |NAND_Uninitialize|


  00000			 AREA	 |.pdata|, PDATA
|$T46771| DCD	|$LN7@NAND_Seek|
	DCD	0x40001701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_Seek| PROC

; 538  : {

  00000		 |$LN7@NAND_Seek|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M46768|

; 539  :     // seek to address
; 540  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 541  :     SectorAccess(pDevice, sector, offset);

  00004	e590e020	 ldr         lr, [r0, #0x20]
  00008	e1a040a2	 mov         r4, r2, lsr #1
  0000c	e20430ff	 and         r3, r4, #0xFF
  00010	e1ce30b0	 strh        r3, [lr]
  00014	e5902020	 ldr         r2, [r0, #0x20]
  00018	e1a03804	 mov         r3, r4, lsl #16
  0001c	e1a03c23	 mov         r3, r3, lsr #24
  00020	e1c230b0	 strh        r3, [r2]
  00024	e5902020	 ldr         r2, [r0, #0x20]
  00028	e20130ff	 and         r3, r1, #0xFF
  0002c	e1a0e801	 mov         lr, r1, lsl #16
  00030	e1c230b0	 strh        r3, [r2]
  00034	e5902020	 ldr         r2, [r0, #0x20]
  00038	e1a03c2e	 mov         r3, lr, lsr #24
  0003c	e1a01401	 mov         r1, r1, lsl #8
  00040	e1c230b0	 strh        r3, [r2]
  00044	e5902020	 ldr         r2, [r0, #0x20]
  00048	e1a03c21	 mov         r3, r1, lsr #24

; 542  :     return TRUE;

  0004c	e3a00001	 mov         r0, #1
  00050	e1c230b0	 strh        r3, [r2]

; 543  : }

  00054	e8bd4010	 ldmia       sp!, {r4, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$M46769|

			 ENDP  ; |NAND_Seek|

	IMPORT	|ECC_Result|
	IMPORT	|ECC_Reset|
	IMPORT	|ECC_Init|
	IMPORT	|memcpy|

  00000			 AREA	 |.pdata|, PDATA
|$T46792| DCD	|$LN25@NAND_Read|
	DCD	0x40004001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_Read| PROC

; 553  : {

  00000		 |$LN25@NAND_Read|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M46789|
  00004	e1b08003	 movs        r8, r3
  00008	e1a06002	 mov         r6, r2
  0000c	e1a07001	 mov         r7, r1
  00010	e1a05000	 mov         r5, r0

; 554  :     UINT32 fifoLevel;
; 555  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 556  : 
; 557  :     // Start ECC if a valid ECC buffer is passed in
; 558  :     if (pEcc != NULL)
; 559  :         {
; 560  :         ECC_Init(pDevice->pGpmcRegs, pDevice->ECCCfg, pDevice->ECCtype, NAND_ECC_READ);

  00014	15952060	 ldrne       r2, [r5, #0x60]
  00018	15951058	 ldrne       r1, [r5, #0x58]
  0001c	1595002c	 ldrne       r0, [r5, #0x2C]
  00020	13a03000	 movne       r3, #0
  00024	1b000000	 blne        ECC_Init

; 561  :         }
; 562  : 
; 563  :     // enable prefetch if it's been properly configured
; 564  :     if (pDevice->prefetchMode == kPrefetchRead )

  00028	e595e018	 ldr         lr, [r5, #0x18]
  0002c	e35e0001	 cmp         lr, #1
  00030	1a000025	 bne         |$LN22@NAND_Read|

; 565  :         {
; 566  :         SETREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONTROL, 
; 567  :             GPMC_PREFETCH_CONTROL_STARTENGINE
; 568  :             );

  00034	e595402c	 ldr         r4, [r5, #0x2C]

; 569  : 
; 570  :         // start copying data into passed in buffer
; 571  :         while (size > 0)

  00038	e3560000	 cmp         r6, #0
  0003c	e594e1ec	 ldr         lr, [r4, #0x1EC]
  00040	e38ee001	 orr         lr, lr, #1
  00044	e584e1ec	 str         lr, [r4, #0x1EC]
  00048	da00000e	 ble         |$LN11@NAND_Read|
  0004c	e2463001	 sub         r3, r6, #1
  00050	e1a03323	 mov         r3, r3, lsr #6
  00054	e2834001	 add         r4, r3, #1
  00058		 |$LL12@NAND_Read|
  00058	e595202c	 ldr         r2, [r5, #0x2C]
  0005c		 |$LL10@NAND_Read|

; 572  :             {
; 573  :             // wait for fifo threshold to be reached
; 574  :             fifoLevel = 0;
; 575  :             while (fifoLevel < FIFO_THRESHOLD)
; 576  :                 {
; 577  :                 fifoLevel = INREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_STATUS);

  0005c	e59231f0	 ldr         r3, [r2, #0x1F0]
  00060	e203347f	 and         r3, r3, #0x7F, 8
  00064	e3530101	 cmp         r3, #1, 2
  00068	3afffffb	 bcc         |$LL10@NAND_Read|

; 578  :                 fifoLevel &= GPMC_PREFETCH_STATUS_FIFOMASK;
; 579  :                 fifoLevel >>= GPMC_PREFETCH_STATUS_FIFOSHIFT;
; 580  :                 }
; 581  : 
; 582  :             // copy data to buffer
; 583  :             memcpy(pData, (BYTE*)pDevice->pFifo, FIFO_THRESHOLD);

  0006c	e5951028	 ldr         r1, [r5, #0x28]
  00070	e3a02040	 mov         r2, #0x40
  00074	e1a00007	 mov         r0, r7
  00078	eb000000	 bl          memcpy

; 584  :             pData += FIFO_THRESHOLD;

  0007c	e2877040	 add         r7, r7, #0x40
  00080	e2544001	 subs        r4, r4, #1
  00084	1afffff3	 bne         |$LL12@NAND_Read|
  00088		 |$LN11@NAND_Read|

; 585  :             size -= FIFO_THRESHOLD;        
; 586  :             }
; 587  : 
; 588  :         // NOTE:
; 589  :         //  Prefetch engine will automatically stop on the completion
; 590  :         // of data transfer
; 591  :         pDevice->prefetchMode = kPrefetchOff;

  00088	e3a03000	 mov         r3, #0
  0008c	e5853018	 str         r3, [r5, #0x18]

; 592  :         }
; 593  :     else

  00090	ea00000f	 b           |$LN6@NAND_Read|
  00094		 |$LL7@NAND_Read|

; 598  :             {
; 599  :             *(NANDREG*)pData = READ_NAND(pDevice->pNandData);

  00094	e5953024	 ldr         r3, [r5, #0x24]

; 600  :             pData += sizeof(NANDREG);
; 601  :             size -= sizeof(NANDREG);

  00098	e2466002	 sub         r6, r6, #2
  0009c	e1d330b0	 ldrh        r3, [r3]
  000a0	e0c730b2	 strh        r3, [r7], #2

; 602  : 
; 603  : 	     /* workaround for BCH engine when ECC is not put at the end of OOB area.  
; 604  : 		  the checking is based on puting ECC at the BootROM expected location -
; 605  : 		  with 2 bytes offset from the start of the OOB area */
; 606  :             if(pDevice->ECCtype == BCH4bit || pDevice->ECCtype == BCH8bit)

  000a4	e5953060	 ldr         r3, [r5, #0x60]
  000a8	e3530001	 cmp         r3, #1
  000ac	0a000001	 beq         |$LN4@NAND_Read|
  000b0	e3530002	 cmp         r3, #2
  000b4	1a000004	 bne         |$LN22@NAND_Read|
  000b8		 |$LN4@NAND_Read|

; 607  :                 if (size == (int)(sizeof(NAND_SPARE_AREA) - ECC_OFFSET - pDevice->ECCsize))

  000b8	e5953064	 ldr         r3, [r5, #0x64]
  000bc	e263303e	 rsb         r3, r3, #0x3E
  000c0	e1560003	 cmp         r6, r3

; 608  :         	         ECC_Reset(pDevice->pGpmcRegs);  

  000c4	0595002c	 ldreq       r0, [r5, #0x2C]
  000c8	0b000000	 bleq        ECC_Reset
  000cc		 |$LN22@NAND_Read|

; 594  :         {
; 595  :         // NOTE:
; 596  :         //  Code assumes the entire page is read at once
; 597  :         while (size >= sizeof(NANDREG))

  000cc	e3560002	 cmp         r6, #2
  000d0	2affffef	 bcs         |$LL7@NAND_Read|
  000d4		 |$LN6@NAND_Read|

; 609  :                 }
; 610  :         }
; 611  : 
; 612  :     // get ECC result
; 613  :     if (pEcc != NULL)
; 614  :         {
; 615  :         // UNDONE:
; 616  :         //  should pass in sector size???
; 617  :         ECC_Result(pDevice->pGpmcRegs, pEcc, pDevice->ECCsize);

  000d4	e595002c	 ldr         r0, [r5, #0x2C]
  000d8	e3580000	 cmp         r8, #0
  000dc	0a000003	 beq         |$LN2@NAND_Read|
  000e0	e5952064	 ldr         r2, [r5, #0x64]
  000e4	e1a01008	 mov         r1, r8
  000e8	eb000000	 bl          ECC_Result

; 618  :         }
; 619  :     else

  000ec	ea000000	 b           |$LN1@NAND_Read|
  000f0		 |$LN2@NAND_Read|

; 620  :     	{
; 621  :     	ECC_Reset(pDevice->pGpmcRegs);

  000f0	eb000000	 bl          ECC_Reset
  000f4		 |$LN1@NAND_Read|

; 622  :     	}
; 623  :     return TRUE;

  000f4	e3a00001	 mov         r0, #1

; 624  : }

  000f8	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000fc	e12fff1e	 bx          lr
  00100		 |$M46790|

			 ENDP  ; |NAND_Read|


  00000			 AREA	 |.pdata|, PDATA
|$T46821| DCD	|$LN28@NAND_Write|
	DCD	0x40004201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_Write| PROC

; 635  : {

  00000		 |$LN28@NAND_Write|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M46818|
  00004	e1b08003	 movs        r8, r3
  00008	e1a06002	 mov         r6, r2
  0000c	e1a07001	 mov         r7, r1
  00010	e1a05000	 mov         r5, r0

; 636  :     UINT32 fifoLevel;
; 637  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 638  : 
; 639  :     // Start ECC if a valid ECC buffer is passed in
; 640  :     if (pEcc != NULL)
; 641  :         {
; 642  :         ECC_Init(pDevice->pGpmcRegs, pDevice->ECCCfg, pDevice->ECCtype, NAND_ECC_WRITE);

  00014	15952060	 ldrne       r2, [r5, #0x60]
  00018	15951058	 ldrne       r1, [r5, #0x58]
  0001c	1595002c	 ldrne       r0, [r5, #0x2C]
  00020	13a03001	 movne       r3, #1
  00024	1b000000	 blne        ECC_Init

; 643  :         }
; 644  : 
; 645  :     // enable prefetch if it's been properly configured
; 646  :     if (pDevice->prefetchMode == kPrefetchWrite )

  00028	e595e018	 ldr         lr, [r5, #0x18]
  0002c	e35e0002	 cmp         lr, #2
  00030	1a000017	 bne         |$LN11@NAND_Write|

; 647  :         {
; 648  :         SETREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONTROL, 
; 649  :             GPMC_PREFETCH_CONTROL_STARTENGINE
; 650  :             );

  00034	e595402c	 ldr         r4, [r5, #0x2C]

; 651  :         // start copying data into passed in buffer
; 652  :         while (size > 0)

  00038	e3560000	 cmp         r6, #0
  0003c	e594e1ec	 ldr         lr, [r4, #0x1EC]
  00040	e38ee001	 orr         lr, lr, #1
  00044	e584e1ec	 str         lr, [r4, #0x1EC]
  00048	da00000e	 ble         |$LN9@NAND_Write|
  0004c	e2463001	 sub         r3, r6, #1
  00050	e1a03323	 mov         r3, r3, lsr #6
  00054	e2834001	 add         r4, r3, #1
  00058		 |$LL10@NAND_Write|

; 653  :             {
; 654  :             // copy data to buffer
; 655  :             memcpy((BYTE*)pDevice->pFifo, pData, FIFO_THRESHOLD);

  00058	e5950028	 ldr         r0, [r5, #0x28]
  0005c	e3a02040	 mov         r2, #0x40
  00060	e1a01007	 mov         r1, r7
  00064	eb000000	 bl          memcpy

; 656  :             pData += FIFO_THRESHOLD;

  00068	e595202c	 ldr         r2, [r5, #0x2C]
  0006c	e2877040	 add         r7, r7, #0x40
  00070		 |$LL8@NAND_Write|

; 657  :             size -= FIFO_THRESHOLD;  
; 658  :             
; 659  :             // wait for fifo threshold to be reached
; 660  :             fifoLevel = 0;
; 661  :             while (fifoLevel < FIFO_THRESHOLD)
; 662  :                 {
; 663  :                 fifoLevel = INREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_STATUS);

  00070	e59231f0	 ldr         r3, [r2, #0x1F0]
  00074	e203347f	 and         r3, r3, #0x7F, 8
  00078	e3530101	 cmp         r3, #1, 2
  0007c	3afffffb	 bcc         |$LL8@NAND_Write|

; 651  :         // start copying data into passed in buffer
; 652  :         while (size > 0)

  00080	e2544001	 subs        r4, r4, #1
  00084	1afffff3	 bne         |$LL10@NAND_Write|
  00088		 |$LN9@NAND_Write|

; 664  :                 fifoLevel &= GPMC_PREFETCH_STATUS_FIFOMASK;
; 665  :                 fifoLevel >>= GPMC_PREFETCH_STATUS_FIFOSHIFT;
; 666  :                 }
; 667  :             }
; 668  : 
; 669  :         // NOTE:
; 670  :         //  Prefetch engine will automatically stop on the completion
; 671  :         // of data transfer
; 672  :         pDevice->prefetchMode = kPrefetchOff;

  00088	e3a03000	 mov         r3, #0
  0008c	e5853018	 str         r3, [r5, #0x18]

; 673  :         }
; 674  :     else

  00090	ea000011	 b           |$LN4@NAND_Write|
  00094		 |$LN11@NAND_Write|

; 675  :         {
; 676  :         int writeCount = 0;

  00094	e3a01000	 mov         r1, #0

; 677  : 		
; 678  :         while (size >= sizeof(NANDREG))

  00098	e3560002	 cmp         r6, #2
  0009c	3a00000e	 bcc         |$LN4@NAND_Write|

; 675  :         {
; 676  :         int writeCount = 0;

  000a0	e1a000a6	 mov         r0, r6, lsr #1
  000a4		 |$LL5@NAND_Write|

; 679  :             {
; 680  :             WRITE_NAND(pDevice->pNandData, *(NANDREG*)pData);

  000a4	e5952024	 ldr         r2, [r5, #0x24]
  000a8	e1d730b0	 ldrh        r3, [r7]

; 681  : 
; 682  :             // Workaround Errata 1.53
; 683  :             // need to check on EMPTYWRITEBUFFERSTATUS on every
; 684  :             // 255 bytes
; 685  :             if (++writeCount >= 255)

  000ac	e2811001	 add         r1, r1, #1
  000b0	e35100ff	 cmp         r1, #0xFF
  000b4	e1c230b0	 strh        r3, [r2]
  000b8	ba000004	 blt         |$LN3@NAND_Write|
  000bc	e595202c	 ldr         r2, [r5, #0x2C]

; 686  :                 {
; 687  :                 WaitOnEmptyWriteBufferStatus(pDevice);

  000c0		 |$LL17@NAND_Write|
  000c0	e5923054	 ldr         r3, [r2, #0x54]
  000c4	e3130001	 tst         r3, #1
  000c8	0afffffc	 beq         |$LL17@NAND_Write|

; 688  :                 writeCount = 0;

  000cc	e3a01000	 mov         r1, #0
  000d0		 |$LN3@NAND_Write|

; 689  :                 }
; 690  :             
; 691  :             pData += sizeof(NANDREG);

  000d0	e2877002	 add         r7, r7, #2
  000d4	e2500001	 subs        r0, r0, #1
  000d8	1afffff1	 bne         |$LL5@NAND_Write|
  000dc		 |$LN4@NAND_Write|

; 692  :             size -= sizeof(NANDREG);
; 693  :             }
; 694  : 		
; 695  :         }
; 696  : 
; 697  :     // get ECC result
; 698  :     if (pEcc != NULL)
; 699  :         {
; 700  :         ECC_Result(pDevice->pGpmcRegs, pEcc, pDevice->ECCsize);

  000dc	e595002c	 ldr         r0, [r5, #0x2C]
  000e0	e3580000	 cmp         r8, #0
  000e4	0a000003	 beq         |$LN2@NAND_Write|
  000e8	e5952064	 ldr         r2, [r5, #0x64]
  000ec	e1a01008	 mov         r1, r8
  000f0	eb000000	 bl          ECC_Result

; 701  :         }
; 702  :     else

  000f4	ea000000	 b           |$LN1@NAND_Write|
  000f8		 |$LN2@NAND_Write|

; 703  :     	{
; 704  : 	 ECC_Reset(pDevice->pGpmcRegs);

  000f8	eb000000	 bl          ECC_Reset
  000fc		 |$LN1@NAND_Write|

; 705  :     	}
; 706  :     return TRUE;

  000fc	e3a00001	 mov         r0, #1

; 707  : }

  00100	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00104	e12fff1e	 bx          lr
  00108		 |$M46819|

			 ENDP  ; |NAND_Write|


  00000			 AREA	 |.pdata|, PDATA
|$T46831| DCD	|$LN5@NAND_GetSt|
	DCD	0x40000600
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_GetStatus| PROC

; 714  : {

  00000		 |$LN5@NAND_GetSt|
  00000		 |$M46828|

; 715  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 716  : 
; 717  :     // request status
; 718  :     WRITE_NAND(pDevice->pNandCmd, NAND_CMD_STATUS);

  00000	e590301c	 ldr         r3, [r0, #0x1C]
  00004	e3a02070	 mov         r2, #0x70
  00008	e1c320b0	 strh        r2, [r3]

; 719  :     return READ_NAND(pDevice->pNandData);

  0000c	e5903024	 ldr         r3, [r0, #0x24]
  00010	e1d300b0	 ldrh        r0, [r3]

; 720  : }

  00014	e12fff1e	 bx          lr
  00018		 |$M46829|

			 ENDP  ; |NAND_GetStatus|


  00000			 AREA	 |.pdata|, PDATA
|$T46842| DCD	|$LN8@NAND_Enabl|
	DCD	0x40001b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_Enable| PROC

; 745  : {

  00000		 |$LN8@NAND_Enabl|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46839|

; 746  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 747  : 
; 748  :     if (pDevice->IrqWait)

  00004	e590305c	 ldr         r3, [r0, #0x5C]
  00008	e1b0e003	 movs        lr, r3
  0000c	0a000013	 beq         |$LN1@NAND_Enabl|

; 749  :     {
; 750  :         if( bEnable )
; 751  :         {
; 752  :             // Enable GPMC wait-to-nowait edge detection mechanism on NAND R/B pin
; 753  :             SETREG32 (&pDevice->pGpmcRegs->GPMC_IRQENABLE, pDevice->IrqWait);

  00010	e590202c	 ldr         r2, [r0, #0x2C]
  00014	e3510000	 cmp         r1, #0
  00018	0a000008	 beq         |$LN2@NAND_Enabl|
  0001c	e592301c	 ldr         r3, [r2, #0x1C]
  00020	e183300e	 orr         r3, r3, lr
  00024	e582301c	 str         r3, [r2, #0x1C]

; 754  : 
; 755  :             //  Reset IRQ status
; 756  :             SETREG32 (&pDevice->pGpmcRegs->GPMC_IRQSTATUS, pDevice->IrqWait);

  00028	e590102c	 ldr         r1, [r0, #0x2C]
  0002c	e590205c	 ldr         r2, [r0, #0x5C]
  00030	e5913018	 ldr         r3, [r1, #0x18]
  00034	e1833002	 orr         r3, r3, r2
  00038	e5813018	 str         r3, [r1, #0x18]

; 757  :         }
; 758  :         else

  0003c	ea000007	 b           |$LN1@NAND_Enabl|
  00040		 |$LN2@NAND_Enabl|

; 759  :         {
; 760  :             //  Reset IRQ status
; 761  :             SETREG32 (&pDevice->pGpmcRegs->GPMC_IRQSTATUS, pDevice->IrqWait);

  00040	e5923018	 ldr         r3, [r2, #0x18]
  00044	e183300e	 orr         r3, r3, lr
  00048	e5823018	 str         r3, [r2, #0x18]

; 762  : 
; 763  :             // Disable GPMC wait-to-nowait edge detection mechanism on NAND R/B pin
; 764  :             CLRREG32 (&pDevice->pGpmcRegs->GPMC_IRQENABLE, pDevice->IrqWait);

  0004c	e590102c	 ldr         r1, [r0, #0x2C]
  00050	e590205c	 ldr         r2, [r0, #0x5C]
  00054	e591301c	 ldr         r3, [r1, #0x1C]
  00058	e1c33002	 bic         r3, r3, r2
  0005c	e581301c	 str         r3, [r1, #0x1C]
  00060		 |$LN1@NAND_Enabl|

; 765  :         }
; 766  :     }
; 767  :     return TRUE;

  00060	e3a00001	 mov         r0, #1

; 768  : }

  00064	e49de004	 ldr         lr, [sp], #4
  00068	e12fff1e	 bx          lr
  0006c		 |$M46840|

			 ENDP  ; |NAND_Enable|

	IMPORT	|EnterCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T46852| DCD	|$LN5@NAND_Mutex|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_MutexEnter| PROC

; 775  : {   

  00000		 |$LN5@NAND_Mutex|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M46849|
  00004	e1a04000	 mov         r4, r0

; 776  : #ifdef DEVICE_MODE
; 777  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 778  :     EnterCriticalSection(&pDevice->cs); 

  00008	eb000000	 bl          EnterCriticalSection

; 779  :     return pDevice->cs.LockCount;

  0000c	e5940000	 ldr         r0, [r4]

; 780  : #else
; 781  :     UNREFERENCED_PARAMETER(hNand);
; 782  :     return 0;
; 783  : #endif
; 784  : }

  00010	e8bd4010	 ldmia       sp!, {r4, lr}
  00014	e12fff1e	 bx          lr
  00018		 |$M46850|

			 ENDP  ; |NAND_MutexEnter|

	IMPORT	|LeaveCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T46862| DCD	|$LN5@NAND_Mutex@2|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_MutexExit| PROC

; 791  : {

  00000		 |$LN5@NAND_Mutex@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M46859|
  00004	e1a04000	 mov         r4, r0

; 792  : #ifdef DEVICE_MODE
; 793  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 794  :     LeaveCriticalSection(&pDevice->cs); 

  00008	eb000000	 bl          LeaveCriticalSection

; 795  :     return pDevice->cs.LockCount;

  0000c	e5940000	 ldr         r0, [r4]

; 796  : #else
; 797  :     UNREFERENCED_PARAMETER(hNand);
; 798  :     return 0;
; 799  : #endif
; 800  : }

  00010	e8bd4010	 ldmia       sp!, {r4, lr}
  00014	e12fff1e	 bx          lr
  00018		 |$M46860|

			 ENDP  ; |NAND_MutexExit|


  00000			 AREA	 |.pdata|, PDATA
|$T46873| DCD	|$LN5@NAND_SendC|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_SendCommand| PROC

; 808  : {

  00000		 |$LN5@NAND_SendC|
  00000		 |$M46870|
  00000	e1a02001	 mov         r2, r1

; 809  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 810  :     WRITE_NAND(pDevice->pNandCmd, cmd);

  00004	e590301c	 ldr         r3, [r0, #0x1C]

; 811  :     return TRUE;

  00008	e3a00001	 mov         r0, #1
  0000c	e1c320b0	 strh        r2, [r3]

; 812  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M46871|

			 ENDP  ; |NAND_SendCommand|

	IMPORT	|BSPGetNandCS|

  00000			 AREA	 |.pdata|, PDATA
|$T46887| DCD	|$LN8@NAND_Confi|
	DCD	0x40001d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_ConfigurePrefetch| PROC

; 820  : {

  00000		 |$LN8@NAND_Confi|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M46884|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 821  :     DWORD chipSelect = BSPGetNandCS();

  0000c	eb000000	 bl          BSPGetNandCS

; 822  :     UINT ffPrefetchMode = 0;
; 823  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 824  : 
; 825  :     // disable prefetch engine
; 826  :     pDevice->prefetchMode = kPrefetchOff;
; 827  :     
; 828  :     OUTREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONTROL, 0);
; 829  : 
; 830  :     // set prefetch mask
; 831  :     ffPrefetchMode = GPMC_PREFETCH_CONFIG_PFPWENROUNDROBIN |
; 832  :                      GPMC_PREFETCH_CONFIG_ENABLEOPTIMIZEDACCESS |
; 833  :                      GPMC_PREFETCH_CONFIG_WAITPINSELECTOR(chipSelect) |
; 834  :                      GPMC_PREFETCH_CONFIG_FIFOTHRESHOLD(FIFO_THRESHOLD) |
; 835  :                      GPMC_PREFETCH_CONFIG_ENGINECSSELECTOR(chipSelect);

  00010	e2002007	 and         r2, r0, #7
  00014	e2003003	 and         r3, r0, #3
  00018	e3a01722	 mov         r1, #0x22, 14
  0001c	e1832a02	 orr         r2, r3, r2, lsl #20
  00020	e3813b01	 orr         r3, r1, #1, 22
  00024	e595e02c	 ldr         lr, [r5, #0x2C]
  00028	e1823003	 orr         r3, r2, r3

; 836  : 
; 837  :     if (accessType == NAND_DATA_WRITE)

  0002c	e3540002	 cmp         r4, #2
  00030	e1a02203	 mov         r2, r3, lsl #4
  00034	e3a01000	 mov         r1, #0

; 838  :         {
; 839  :         pDevice->prefetchMode = kPrefetchWrite;

  00038	03a03002	 moveq       r3, #2

; 840  :         ffPrefetchMode |= GPMC_PREFETCH_CONFIG_WRITEPOST;
; 841  :         }
; 842  :     else
; 843  :         {
; 844  :         pDevice->prefetchMode = kPrefetchRead;

  0003c	13a03001	 movne       r3, #1
  00040	e5851018	 str         r1, [r5, #0x18]
  00044	e58e11ec	 str         r1, [lr, #0x1EC]
  00048	e5853018	 str         r3, [r5, #0x18]

; 845  :         }
; 846  :         
; 847  :     OUTREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONFIG1, ffPrefetchMode);

  0004c	e595302c	 ldr         r3, [r5, #0x2C]
  00050	03822001	 orreq       r2, r2, #1

; 848  : 
; 849  :     SETREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONFIG1, 
; 850  :         GPMC_PREFETCH_CONFIG_ENABLEENGINE
; 851  :         );
; 852  : 
; 853  :     return TRUE;

  00054	e3a00001	 mov         r0, #1
  00058	e58321e0	 str         r2, [r3, #0x1E0]
  0005c	e595202c	 ldr         r2, [r5, #0x2C]
  00060	e59231e0	 ldr         r3, [r2, #0x1E0]
  00064	e3833080	 orr         r3, r3, #0x80
  00068	e58231e0	 str         r3, [r2, #0x1E0]

; 854  : }

  0006c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00070	e12fff1e	 bx          lr
  00074		 |$M46885|

			 ENDP  ; |NAND_ConfigurePrefetch|

	EXPORT	|NAND_CorrectEccData|
	IMPORT	|ECC_CorrectData|
	IMPORT	|memcmp|

  00000			 AREA	 |.pdata|, PDATA
|$T46903| DCD	|$LN7@NAND_Corre|
	DCD	0x40001b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_CorrectEccData| PROC

; 866  : {

  00000		 |$LN7@NAND_Corre|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M46900|
  00008	e1a05003	 mov         r5, r3
  0000c	e1a08002	 mov         r8, r2
  00010	e1a09001	 mov         r9, r1
  00014	e1a06000	 mov         r6, r0

; 867  :     BOOL rc = FALSE;
; 868  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 869  :     
; 870  :     // this call assumes the array size of pEccOld and pEccNew are of the 
; 871  :     // correct size to hold all the parity bits of the given size    
; 872  :     if (memcmp(pEccOld, pEccNew, pDevice->ECCsize) != 0)

  00018	e59d7020	 ldr         r7, [sp, #0x20]
  0001c	e5962064	 ldr         r2, [r6, #0x64]
  00020	e1a00005	 mov         r0, r5
  00024	e1a01007	 mov         r1, r7
  00028	e3a04000	 mov         r4, #0
  0002c	eb000000	 bl          memcmp
  00030	e3500000	 cmp         r0, #0
  00034	0a000007	 beq         |$LN1@NAND_Corre|

; 873  :         {
; 874  :         
; 875  :         // check if data is correctable        
; 876  :         if (ECC_CorrectData(pDevice->pGpmcRegs, pData, size, pEccOld, pEccNew) == FALSE)

  00038	e596002c	 ldr         r0, [r6, #0x2C]
  0003c	e1a03005	 mov         r3, r5
  00040	e1a02008	 mov         r2, r8
  00044	e1a01009	 mov         r1, r9
  00048	e58d7000	 str         r7, [sp]
  0004c	eb000000	 bl          ECC_CorrectData
  00050	e3500000	 cmp         r0, #0
  00054	0a000000	 beq         |$cleanUp$46318|
  00058		 |$LN1@NAND_Corre|

; 877  :             {
; 878  :             goto cleanUp;
; 879  :             }
; 880  :         }    
; 881  : 
; 882  :     rc = TRUE;

  00058	e3a04001	 mov         r4, #1
  0005c		 |$cleanUp$46318|

; 883  :     
; 884  : cleanUp:
; 885  :     return rc;
; 886  : }

  0005c	e1a00004	 mov         r0, r4
  00060	e28dd004	 add         sp, sp, #4
  00064	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00068	e12fff1e	 bx          lr
  0006c		 |$M46901|

			 ENDP  ; |NAND_CorrectEccData|

	EXPORT	|WaitForReadyStatus|

  00000			 AREA	 |.pdata|, PDATA
|$T46916| DCD	|$LN10@WaitForRea|
	DCD	0x40000800
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |WaitForReadyStatus| PROC

; 897  : {

  00000		 |$LN10@WaitForRea|
  00000		 |$M46913|
  00000	e3a02070	 mov         r2, #0x70
  00004		 |$LL2@WaitForRea|

; 898  :     //  Wait for a Ready status
; 899  :     while ((NAND_GetStatus(hNand) & NAND_STATUS_READY) == 0); 

  00004	e590301c	 ldr         r3, [r0, #0x1C]
  00008	e1c320b0	 strh        r2, [r3]
  0000c	e5903024	 ldr         r3, [r0, #0x24]
  00010	e1d330b0	 ldrh        r3, [r3]
  00014	e3130040	 tst         r3, #0x40
  00018	0afffff9	 beq         |$LL2@WaitForRea|

; 900  : }

  0001c	e12fff1e	 bx          lr
  00020		 |$M46914|

			 ENDP  ; |WaitForReadyStatus|

	EXPORT	|FMD_Deinit|

  00000			 AREA	 |.pdata|, PDATA
|$T46967| DCD	|$LN26@FMD_Deinit|
	DCD	0x40002b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FMD_Deinit| PROC

; 939  : {

  00000		 |$LN26@FMD_Deinit|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M46964|

; 940  :     BOOL rc = FALSE;
; 941  :     if (pContext != s_hNand) goto cleanUp;

  00004	e59f509c	 ldr         r5, [pc, #0x9C]
  00008	e5954000	 ldr         r4, [r5]
  0000c	e1500004	 cmp         r0, r4
  00010	1a000021	 bne         |$cleanUp$46343|

; 942  : 
; 943  :     //  Only enable during NAND read/write/erase operations
; 944  :     NAND_Enable(s_hNand, TRUE);

  00014	e3a01001	 mov         r1, #1
  00018	e1a00004	 mov         r0, r4
  0001c	eb000000	 bl          NAND_Enable
  00020	e3a01070	 mov         r1, #0x70

; 945  : 
; 946  :     // Wait for NAND    
; 947  :     // the next command may not work if you remove this wait on the status, 
; 948  :     // because if the R/B pin is asserted during the reset, its deassertion 
; 949  :     // isn't guaranteed to mean that the device is ready
; 950  :     WaitForReadyStatus(s_hNand);   

  00024		 |$LL5@FMD_Deinit|
  00024	e594301c	 ldr         r3, [r4, #0x1C]
  00028	e1c310b0	 strh        r1, [r3]
  0002c	e5943024	 ldr         r3, [r4, #0x24]
  00030	e1d330b0	 ldrh        r3, [r3]
  00034	e3130040	 tst         r3, #0x40
  00038	0afffff9	 beq         |$LL5@FMD_Deinit|

; 951  : 
; 952  :     // Write RESET command
; 953  :     // (a reset aborts any current READ, WRITE (PROGRAM) or ERASE operation)
; 954  :     NAND_SendCommand(s_hNand, NAND_CMD_RESET);

  0003c	e594301c	 ldr         r3, [r4, #0x1C]
  00040	e3a020ff	 mov         r2, #0xFF
  00044	e1c320b0	 strh        r2, [r3]

; 955  : 
; 956  :     // Wait for NAND
; 957  :     WaitForReadyStatus(s_hNand);

  00048		 |$LL13@FMD_Deinit|
  00048	e594301c	 ldr         r3, [r4, #0x1C]
  0004c	e1c310b0	 strh        r1, [r3]
  00050	e5943024	 ldr         r3, [r4, #0x24]
  00054	e1d330b0	 ldrh        r3, [r3]
  00058	e3130040	 tst         r3, #0x40
  0005c	0afffff9	 beq         |$LL13@FMD_Deinit|

; 958  : 
; 959  :     // Clear GPMC wait-to-nowait edge detection mechanism on NAND R/B pin
; 960  :     NAND_Enable(s_hNand, FALSE);

  00060	e3a01000	 mov         r1, #0
  00064	e1a00004	 mov         r0, r4
  00068	eb000000	 bl          NAND_Enable

; 961  : 
; 962  :     // uninitialize and release allocated resources
; 963  :     NAND_Uninitialize(s_hNand);

  0006c	e594302c	 ldr         r3, [r4, #0x2C]
  00070	e3530000	 cmp         r3, #0
  00074	15941038	 ldrne       r1, [r4, #0x38]
  00078	11a00003	 movne       r0, r3
  0007c	1b000000	 blne        MmUnmapIoSpace
  00080	e5943028	 ldr         r3, [r4, #0x28]
  00084	e3530000	 cmp         r3, #0
  00088	1594103c	 ldrne       r1, [r4, #0x3C]
  0008c	11a00003	 movne       r0, r3
  00090	1b000000	 blne        MmUnmapIoSpace

; 964  :     s_hNand = NULL;

  00094	e3a03000	 mov         r3, #0
  00098	e5853000	 str         r3, [r5]
  0009c		 |$cleanUp$46343|

; 965  :     
; 966  : cleanUp:
; 967  :     return rc;

  0009c	e3a00000	 mov         r0, #0

; 968  : }

  000a0	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000a4	e12fff1e	 bx          lr
  000a8		 |$LN27@FMD_Deinit|
  000a8		 |$LN28@FMD_Deinit|
  000a8	00000000	 DCD         |s_hNand|
  000ac		 |$M46965|

			 ENDP  ; |FMD_Deinit|

	EXPORT	|FMD_GetInfo|

  00000			 AREA	 |.pdata|, PDATA
|$T46995| DCD	|$LN16@FMD_GetInf|
	DCD	0x40001801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FMD_GetInfo| PROC

; 980  : {

  00000		 |$LN16@FMD_GetInf|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46992|
  00004	e1a0e000	 mov         lr, r0

; 981  :     BOOL rc = FALSE;
; 982  : 
; 983  :     // If we don't support NAND, fail...
; 984  :     if (s_hNand == NULL) goto cleanUp;

  00008	e59f304c	 ldr         r3, [pc, #0x4C]
  0000c	e3a00000	 mov         r0, #0
  00010	e5931000	 ldr         r1, [r3]
  00014	e3510000	 cmp         r1, #0
  00018	0a00000d	 beq         |$cleanUp$46351|

; 985  : 
; 986  :     // Memory type is NAND
; 987  :     pFlashInfo->flashType = NAND;

  0001c	e3a03000	 mov         r3, #0
  00020	e58e3000	 str         r3, [lr]

; 988  :     pFlashInfo->dwNumBlocks = NAND_GetGeometry(s_hNand)->blocks;

  00024	e5913048	 ldr         r3, [r1, #0x48]

; 989  :     pFlashInfo->wSectorsPerBlock = (WORD) NAND_GetGeometry(s_hNand)->sectorsPerBlock;
; 990  :     pFlashInfo->wDataBytesPerSector = (WORD) NAND_GetGeometry(s_hNand)->sectorSize;
; 991  :     pFlashInfo->dwBytesPerBlock = NAND_GetGeometry(s_hNand)->sectorSize;
; 992  :     pFlashInfo->dwBytesPerBlock *= NAND_GetGeometry(s_hNand)->sectorsPerBlock;
; 993  : 
; 994  :     // Done
; 995  :     rc = TRUE;

  00028	e3a00001	 mov         r0, #1
  0002c	e58e3004	 str         r3, [lr, #4]
  00030	e591304c	 ldr         r3, [r1, #0x4C]
  00034	e1ce30bc	 strh        r3, [lr, #0xC]
  00038	e5913050	 ldr         r3, [r1, #0x50]
  0003c	e1ce30be	 strh        r3, [lr, #0xE]
  00040	e5912050	 ldr         r2, [r1, #0x50]
  00044	e58e2008	 str         r2, [lr, #8]
  00048	e591304c	 ldr         r3, [r1, #0x4C]
  0004c	e0020293	 mul         r2, r3, r2
  00050	e58e2008	 str         r2, [lr, #8]
  00054		 |$cleanUp$46351|

; 996  : 
; 997  : cleanUp:
; 998  :     return rc;
; 999  : }

  00054	e49de004	 ldr         lr, [sp], #4
  00058	e12fff1e	 bx          lr
  0005c		 |$LN17@FMD_GetInf|
  0005c		 |$LN18@FMD_GetInf|
  0005c	00000000	 DCD         |s_hNand|
  00060		 |$M46993|

			 ENDP  ; |FMD_GetInfo|

	EXPORT	|FMD_ReadSectorOOB|

  00000			 AREA	 |.pdata|, PDATA
|$T47091| DCD	|$LN43@FMD_ReadSe|
	DCD	0x40004c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FMD_ReadSectorOOB| PROC

; 1012 : {

  00000		 |$LN43@FMD_ReadSe|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M47088|
  00004	e1a07001	 mov         r7, r1
  00008	e1a06000	 mov         r6, r0

; 1013 :     BOOL rc = FALSE;
; 1014 :     UINT32 oldIdleMode;
; 1015 :     UINT32 sectorSize;
; 1016 : 
; 1017 :     // Fail if FMD wasn't opened
; 1018 :     if (s_hNand == NULL) goto cleanUp;

  0000c	e59f5118	 ldr         r5, [pc, #0x118]
  00010	e3a04000	 mov         r4, #0
  00014	e5950000	 ldr         r0, [r5]
  00018	e3500000	 cmp         r0, #0
  0001c	0a00003f	 beq         |$LN37@FMD_ReadSe|

; 1019 :     
; 1020 :     NAND_MutexEnter(s_hNand);

  00020	eb000000	 bl          EnterCriticalSection

; 1021 : 
; 1022 :     //  Change idle mode to no-idle to ensure access to GPMC registers
; 1023 :     sectorSize = NAND_GetGeometry(s_hNand)->sectorSize;

  00024	e5954000	 ldr         r4, [r5]

; 1024 :     oldIdleMode = INREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG));
; 1025 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), SYSCONFIG_NOIDLE);

  00028	e3a02008	 mov         r2, #8

; 1026 :     
; 1027 :         {
; 1028 :         //  Only enable during NAND read/write/erase operations
; 1029 :         NAND_Enable(s_hNand, TRUE);

  0002c	e3a01001	 mov         r1, #1
  00030	e594302c	 ldr         r3, [r4, #0x2C]
  00034	e5949050	 ldr         r9, [r4, #0x50]
  00038	e1a00004	 mov         r0, r4
  0003c	e5938010	 ldr         r8, [r3, #0x10]
  00040	e5832010	 str         r2, [r3, #0x10]
  00044	eb000000	 bl          NAND_Enable
  00048	e3a00070	 mov         r0, #0x70

; 1030 : 
; 1031 :         // Make sure of the NAND status
; 1032 :         WaitForReadyStatus(s_hNand);

  0004c		 |$LL14@FMD_ReadSe|
  0004c	e594301c	 ldr         r3, [r4, #0x1C]
  00050	e1c300b0	 strh        r0, [r3]
  00054	e5943024	 ldr         r3, [r4, #0x24]
  00058	e1d330b0	 ldrh        r3, [r3]
  0005c	e3130040	 tst         r3, #0x40
  00060	0afffff9	 beq         |$LL14@FMD_ReadSe|

; 1033 : 
; 1034 :         // Send the command
; 1035 :         NAND_SendCommand(s_hNand, NAND_CMD_READ1);

  00064	e594301c	 ldr         r3, [r4, #0x1C]
  00068	e3a0a000	 mov         r10, #0

; 1036 : 
; 1037 :         // Send the address
; 1038 :         NAND_Seek(s_hNand, sector, sectorSize);

  0006c	e1a010a9	 mov         r1, r9, lsr #1
  00070	e1c3a0b0	 strh        r10, [r3]
  00074	e5942020	 ldr         r2, [r4, #0x20]
  00078	e20130ff	 and         r3, r1, #0xFF
  0007c	e1a01801	 mov         r1, r1, lsl #16
  00080	e1c230b0	 strh        r3, [r2]
  00084	e5942020	 ldr         r2, [r4, #0x20]
  00088	e1a03c21	 mov         r3, r1, lsr #24
  0008c	e20610ff	 and         r1, r6, #0xFF
  00090	e1c230b0	 strh        r3, [r2]
  00094	e5942020	 ldr         r2, [r4, #0x20]
  00098	e1a03806	 mov         r3, r6, lsl #16
  0009c	e1a0ec23	 mov         lr, r3, lsr #24
  000a0	e1c210b0	 strh        r1, [r2]
  000a4	e5942020	 ldr         r2, [r4, #0x20]
  000a8	e1a03406	 mov         r3, r6, lsl #8
  000ac	e1a01c23	 mov         r1, r3, lsr #24
  000b0	e1c2e0b0	 strh        lr, [r2]
  000b4	e5943020	 ldr         r3, [r4, #0x20]

; 1039 : 
; 1040 :         // Send the command
; 1041 :         NAND_SendCommand(s_hNand, NAND_CMD_READ2);

  000b8	e3a02030	 mov         r2, #0x30
  000bc	e1c310b0	 strh        r1, [r3]
  000c0	e594301c	 ldr         r3, [r4, #0x1C]
  000c4	e1c320b0	 strh        r2, [r3]

; 1042 : 
; 1043 :         // Wait for the action to finish
; 1044 :         WaitForReadyStatus(s_hNand);

  000c8		 |$LL28@FMD_ReadSe|
  000c8	e594301c	 ldr         r3, [r4, #0x1C]
  000cc	e1c300b0	 strh        r0, [r3]
  000d0	e5943024	 ldr         r3, [r4, #0x24]
  000d4	e1d330b0	 ldrh        r3, [r3]
  000d8	e3130040	 tst         r3, #0x40
  000dc	0afffff9	 beq         |$LL28@FMD_ReadSe|

; 1045 : 
; 1046 :         //Force a read here, else we will read the status again
; 1047 :         NAND_SendCommand (s_hNand, NAND_CMD_READ1);

  000e0	e594101c	 ldr         r1, [r4, #0x1C]

; 1048 : 
; 1049 :         // read spare area
; 1050 :         NAND_Read(s_hNand, (BYTE*)pBuffer, 64, NULL);

  000e4	e3a03000	 mov         r3, #0
  000e8	e3a02040	 mov         r2, #0x40
  000ec	e1c1a0b0	 strh        r10, [r1]
  000f0	e1a01007	 mov         r1, r7
  000f4	e1a00004	 mov         r0, r4
  000f8	eb000000	 bl          NAND_Read

; 1051 :         
; 1052 :         //  Only enable during NAND read/write/erase operations
; 1053 :         NAND_Enable(s_hNand, FALSE);

  000fc	e5954000	 ldr         r4, [r5]
  00100	e3a01000	 mov         r1, #0
  00104	e1a00004	 mov         r0, r4
  00108	eb000000	 bl          NAND_Enable

; 1054 : 
; 1055 :         }
; 1056 : 
; 1057 :     //  Change idle mode back
; 1058 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), oldIdleMode);

  0010c	e594302c	 ldr         r3, [r4, #0x2C]

; 1059 :     
; 1060 :     // Done
; 1061 :     rc = TRUE;
; 1062 : 
; 1063 : cleanUp:
; 1064 :     // Release hardware lock
; 1065 :     if (s_hNand != NULL) NAND_MutexExit(s_hNand);

  00110	e1a00004	 mov         r0, r4
  00114	e3a04001	 mov         r4, #1
  00118	e5838010	 str         r8, [r3, #0x10]
  0011c		 |$cleanUp$46365|
  0011c	eb000000	 bl          LeaveCriticalSection
  00120		 |$LN37@FMD_ReadSe|

; 1066 :     
; 1067 :     ASSERT(rc);
; 1068 :     return rc;
; 1069 : }

  00120	e1a00004	 mov         r0, r4
  00124	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00128	e12fff1e	 bx          lr
  0012c		 |$LN44@FMD_ReadSe|
  0012c		 |$LN45@FMD_ReadSe|
  0012c	00000000	 DCD         |s_hNand|
  00130		 |$M47089|

			 ENDP  ; |FMD_ReadSectorOOB|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|FMD_ReadSector|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|__security_check_cookie|

  00000			 AREA	 |.pdata|, PDATA
|$T47321| DCD	|$LN128@FMD_ReadSe@2|
	DCD	0xc0010602

  00000			 AREA	 |.xdata|, DATA
|$T47317| DCD	0xffffffd8
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T47317|

  00008		 |FMD_ReadSector| PROC

; 1084 : {

  00008		 |$LN128@FMD_ReadSe@2|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd08c	 sub         sp, sp, #0x8C
  00010		 |$M47318|
  00010	e1a05003	 mov         r5, r3
  00014	e1a06002	 mov         r6, r2
  00018	e58d5008	 str         r5, [sp, #8]
  0001c	e58d600c	 str         r6, [sp, #0xC]
  00020	e1a08001	 mov         r8, r1
  00024	e1a0b000	 mov         r11, r0
  00028	e59fe3ec	 ldr         lr, [pc, #0x3EC]
  0002c	e59ee000	 ldr         lr, [lr]
  00030	e58de088	 str         lr, [sp, #0x88]

; 1085 :     BOOL rc = FALSE;
; 1086 :     NAND_SPARE_AREA sa;
; 1087 :     UINT32 oldIdleMode;
; 1088 :     UINT32 sectorSize;
; 1089 :     BYTE rgEcc[ECC_BYTES];
; 1090 : 
; 1091 :     // Fail if FMD wasn't opened
; 1092 :     if (s_hNand == NULL) goto cleanUp;

  00034	e59f93dc	 ldr         r9, [pc, #0x3DC]
  00038	e5990000	 ldr         r0, [r9]
  0003c	e3500000	 cmp         r0, #0
  00040	0a0000ed	 beq         |$LN124@FMD_ReadSe@2|

; 1093 :     
; 1094 :     NAND_MutexEnter(s_hNand);

  00044	eb000000	 bl          EnterCriticalSection

; 1095 : 
; 1096 :     //  Change idle mode to no-idle to ensure access to GPMC registers
; 1097 :     sectorSize = NAND_GetGeometry(s_hNand)->sectorSize;

  00048	e5997000	 ldr         r7, [r9]

; 1098 :     oldIdleMode = INREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG));
; 1099 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), SYSCONFIG_NOIDLE);

  0004c	e3a01008	 mov         r1, #8

; 1100 : 	
; 1101 :     while (sectors > 0)

  00050	e3550000	 cmp         r5, #0
  00054	e597302c	 ldr         r3, [r7, #0x2C]
  00058	e597a050	 ldr         r10, [r7, #0x50]
  0005c	e5932010	 ldr         r2, [r3, #0x10]
  00060	e5831010	 str         r1, [r3, #0x10]
  00064	e58d2010	 str         r2, [sp, #0x10]
  00068	0a0000db	 beq         |$LN16@FMD_ReadSe@2|
  0006c	e1a020aa	 mov         r2, r10, lsr #1
  00070	e1a03802	 mov         r3, r2, lsl #16
  00074	e1a04c23	 mov         r4, r3, lsr #24
  00078	e20230ff	 and         r3, r2, #0xFF
  0007c	e1cd30b4	 strh        r3, [sp, #4]
  00080	e1cd40b6	 strh        r4, [sp, #6]
  00084		 |$LL17@FMD_ReadSe@2|

; 1102 :         {
; 1103 :         //  Only enable during NAND read/write/erase operations
; 1104 :         NAND_Enable(s_hNand, TRUE);

  00084	e3a01001	 mov         r1, #1
  00088	e1a00007	 mov         r0, r7
  0008c	eb000000	 bl          NAND_Enable

; 1105 :         
; 1106 :         // Read sector from A
; 1107 :         if (pBuffer != NULL)

  00090	e3580000	 cmp         r8, #0
  00094	e3a02070	 mov         r2, #0x70
  00098	0a000048	 beq         |$LL62@FMD_ReadSe@2|

; 1108 :             {
; 1109 :             // be sure to do this before sending the READ command and not after ! or the
; 1110 :             // status register would remain at status read mode, which would have to be changed
; 1111 :             // before retreiving the data
; 1112 :             WaitForReadyStatus(s_hNand);

  0009c		 |$LL30@FMD_ReadSe@2|
  0009c	e597301c	 ldr         r3, [r7, #0x1C]
  000a0	e1c320b0	 strh        r2, [r3]
  000a4	e5973024	 ldr         r3, [r7, #0x24]
  000a8	e1d330b0	 ldrh        r3, [r3]
  000ac	e3130040	 tst         r3, #0x40
  000b0	0afffff9	 beq         |$LL30@FMD_ReadSe@2|

; 1113 : 
; 1114 : 			
; 1115 :             // configure prefetch engine for input and start it
; 1116 :             NAND_ConfigurePrefetch(s_hNand, NAND_DATA_READ);

  000b4	eb000000	 bl          BSPGetNandCS
  000b8	e597302c	 ldr         r3, [r7, #0x2C]
  000bc	e3a01000	 mov         r1, #0
  000c0	e2002007	 and         r2, r0, #7
  000c4	e58311ec	 str         r1, [r3, #0x1EC]
  000c8	e2003003	 and         r3, r0, #3
  000cc	e3a00722	 mov         r0, #0x22, 14
  000d0	e1833a02	 orr         r3, r3, r2, lsl #20
  000d4	e3802b01	 orr         r2, r0, #1, 22
  000d8	e597102c	 ldr         r1, [r7, #0x2C]
  000dc	e1833002	 orr         r3, r3, r2
  000e0	e3a02001	 mov         r2, #1
  000e4	e1a03203	 mov         r3, r3, lsl #4
  000e8	e5872018	 str         r2, [r7, #0x18]
  000ec	e58131e0	 str         r3, [r1, #0x1E0]
  000f0	e597102c	 ldr         r1, [r7, #0x2C]

; 1117 :            
; 1118 :             // Send the command
; 1119 :             NAND_SendCommand (s_hNand, NAND_CMD_READ1);

  000f4	e5990000	 ldr         r0, [r9]

; 1120 : 
; 1121 :             // Send the address
; 1122 :             NAND_Seek(s_hNand, sector, 0);

  000f8	e1a0380b	 mov         r3, r11, lsl #16
  000fc	e59121e0	 ldr         r2, [r1, #0x1E0]
  00100	e1a0ec23	 mov         lr, r3, lsr #24
  00104	e3a07000	 mov         r7, #0
  00108	e3823080	 orr         r3, r2, #0x80
  0010c	e58131e0	 str         r3, [r1, #0x1E0]
  00110	e590201c	 ldr         r2, [r0, #0x1C]
  00114	e1a0340b	 mov         r3, r11, lsl #8
  00118	e1a01c23	 mov         r1, r3, lsr #24
  0011c	e1c270b0	 strh        r7, [r2]
  00120	e5903020	 ldr         r3, [r0, #0x20]
  00124	e20b40ff	 and         r4, r11, #0xFF

; 1123 : 
; 1124 :             // Send the command
; 1125 :             NAND_SendCommand(s_hNand, NAND_CMD_READ2);

  00128	e3a02030	 mov         r2, #0x30
  0012c	e1c370b0	 strh        r7, [r3]
  00130	e5903020	 ldr         r3, [r0, #0x20]
  00134	e1c370b0	 strh        r7, [r3]
  00138	e5903020	 ldr         r3, [r0, #0x20]
  0013c	e1c340b0	 strh        r4, [r3]
  00140	e5903020	 ldr         r3, [r0, #0x20]
  00144	e3a04070	 mov         r4, #0x70
  00148	e1c3e0b0	 strh        lr, [r3]
  0014c	e5903020	 ldr         r3, [r0, #0x20]
  00150	e1c310b0	 strh        r1, [r3]
  00154	e590301c	 ldr         r3, [r0, #0x1C]
  00158	e1c320b0	 strh        r2, [r3]

; 1126 : 
; 1127 :             // Wait for the action to finish
; 1128 :             WaitForReadyStatus(s_hNand);

  0015c		 |$LL48@FMD_ReadSe@2|
  0015c	e590301c	 ldr         r3, [r0, #0x1C]
  00160	e1c340b0	 strh        r4, [r3]
  00164	e5903024	 ldr         r3, [r0, #0x24]
  00168	e1d330b0	 ldrh        r3, [r3]
  0016c	e3130040	 tst         r3, #0x40
  00170	0afffff9	 beq         |$LL48@FMD_ReadSe@2|

; 1129 : 
; 1130 :             //Force a read here, else we will read the status again
; 1131 :             NAND_SendCommand (s_hNand, NAND_CMD_READ1);

  00174	e590101c	 ldr         r1, [r0, #0x1C]

; 1132 : 
; 1133 : 	     // read data
; 1134 :             NAND_Read(s_hNand, pBuffer, sectorSize, rgEcc);

  00178	e28d3054	 add         r3, sp, #0x54
  0017c	e1a0200a	 mov         r2, r10
  00180	e1c170b0	 strh        r7, [r1]
  00184	e1a01008	 mov         r1, r8
  00188	eb000000	 bl          NAND_Read

; 1135 : 			
; 1136 :             // read spare area
; 1137 :             NAND_Read(s_hNand, (BYTE*)&sa, sizeof(sa), NULL);

  0018c	e5990000	 ldr         r0, [r9]
  00190	e3a03000	 mov         r3, #0
  00194	e3a02040	 mov         r2, #0x40
  00198	e28d1014	 add         r1, sp, #0x14
  0019c	eb000000	 bl          NAND_Read
  001a0	e5997000	 ldr         r7, [r9]

; 1138 : 
; 1139 :             // Make sure of the NAND status
; 1140 :             WaitForReadyStatus(s_hNand);

  001a4		 |$LL56@FMD_ReadSe@2|
  001a4	e597301c	 ldr         r3, [r7, #0x1C]
  001a8	e1c340b0	 strh        r4, [r3]
  001ac	e5973024	 ldr         r3, [r7, #0x24]
  001b0	e1d330b0	 ldrh        r3, [r3]
  001b4	e3130040	 tst         r3, #0x40
  001b8	0afffff9	 beq         |$LL56@FMD_ReadSe@2|

; 1141 :             }
; 1142 :         else

  001bc	ea000031	 b           |$LN83@FMD_ReadSe@2|

; 1143 :          {
; 1144 :             // Make sure of the NAND status
; 1145 :             WaitForReadyStatus(s_hNand);

  001c0		 |$LL62@FMD_ReadSe@2|
  001c0	e597301c	 ldr         r3, [r7, #0x1C]
  001c4	e1c320b0	 strh        r2, [r3]
  001c8	e5973024	 ldr         r3, [r7, #0x24]
  001cc	e1d330b0	 ldrh        r3, [r3]
  001d0	e3130040	 tst         r3, #0x40
  001d4	0afffff9	 beq         |$LL62@FMD_ReadSe@2|

; 1146 :             // Send the command
; 1147 :             NAND_SendCommand(s_hNand, NAND_CMD_READ1);

  001d8	e597301c	 ldr         r3, [r7, #0x1C]

; 1148 :     
; 1149 :             // Send the address
; 1150 :             NAND_Seek(s_hNand, sector, sectorSize);

  001dc	e3a01000	 mov         r1, #0
  001e0	e1dd00b4	 ldrh        r0, [sp, #4]
  001e4	e1c310b0	 strh        r1, [r3]
  001e8	e5973020	 ldr         r3, [r7, #0x20]
  001ec	e20be0ff	 and         lr, r11, #0xFF
  001f0	e1a0280b	 mov         r2, r11, lsl #16
  001f4	e1c300b0	 strh        r0, [r3]
  001f8	e5973020	 ldr         r3, [r7, #0x20]
  001fc	e1a01c22	 mov         r1, r2, lsr #24
  00200	e1a0240b	 mov         r2, r11, lsl #8
  00204	e1c340b0	 strh        r4, [r3]
  00208	e5973020	 ldr         r3, [r7, #0x20]
  0020c	e1a02c22	 mov         r2, r2, lsr #24
  00210	e3a04070	 mov         r4, #0x70
  00214	e1c3e0b0	 strh        lr, [r3]
  00218	e5973020	 ldr         r3, [r7, #0x20]
  0021c	e1c310b0	 strh        r1, [r3]
  00220	e5973020	 ldr         r3, [r7, #0x20]
  00224	e1c320b0	 strh        r2, [r3]

; 1151 :     
; 1152 :             // Send the command
; 1153 :             NAND_SendCommand(s_hNand, NAND_CMD_READ2);

  00228	e597301c	 ldr         r3, [r7, #0x1C]
  0022c	e3a02030	 mov         r2, #0x30
  00230	e1c320b0	 strh        r2, [r3]

; 1154 :     
; 1155 :             // Wait for the action to finish
; 1156 :             WaitForReadyStatus(s_hNand);

  00234		 |$LL76@FMD_ReadSe@2|
  00234	e597301c	 ldr         r3, [r7, #0x1C]
  00238	e1c340b0	 strh        r4, [r3]
  0023c	e5973024	 ldr         r3, [r7, #0x24]
  00240	e1d330b0	 ldrh        r3, [r3]
  00244	e3130040	 tst         r3, #0x40
  00248	0afffff9	 beq         |$LL76@FMD_ReadSe@2|

; 1157 :             //Force a read here, else we will read the status again
; 1158 :             NAND_SendCommand (s_hNand, NAND_CMD_READ1);

  0024c	e597101c	 ldr         r1, [r7, #0x1C]

; 1159 :     
; 1160 :             // read spare area
; 1161 :             NAND_Read(s_hNand, (BYTE*)&sa, sizeof(sa), NULL);

  00250	e3a00000	 mov         r0, #0
  00254	e3a03000	 mov         r3, #0
  00258	e1c100b0	 strh        r0, [r1]
  0025c	e28d1014	 add         r1, sp, #0x14
  00260	e1a00007	 mov         r0, r7
  00264	e3a02040	 mov         r2, #0x40
  00268	eb000000	 bl          NAND_Read
  0026c	e5997000	 ldr         r7, [r9]

; 1162 : 
; 1163 :             // Make sure of the NAND status
; 1164 :             WaitForReadyStatus(s_hNand);

  00270		 |$LL84@FMD_ReadSe@2|
  00270	e597301c	 ldr         r3, [r7, #0x1C]
  00274	e1c340b0	 strh        r4, [r3]
  00278	e5973024	 ldr         r3, [r7, #0x24]
  0027c	e1d330b0	 ldrh        r3, [r3]
  00280	e3130040	 tst         r3, #0x40
  00284	0afffff9	 beq         |$LL84@FMD_ReadSe@2|
  00288		 |$LN83@FMD_ReadSe@2|

; 1165 :     
; 1166 :         }        // Copy sector info
; 1167 :         if (pSectorInfo != NULL)

  00288	e3560000	 cmp         r6, #0
  0028c	0a00001e	 beq         |$LN13@FMD_ReadSe@2|

; 1168 :             {
; 1169 :             pSectorInfo->bBadBlock    = sa.hwBadBlock[0] & sa.hwBadBlock[1];    // HW bad block check
; 1170 :             pSectorInfo->bBadBlock    = pSectorInfo->bBadBlock & sa.swBadBlock; // SW bad block flag check
; 1171 :             pSectorInfo->bOEMReserved = sa.oemReserved;
; 1172 : 
; 1173 :             memcpy(
; 1174 :                 &pSectorInfo->dwReserved1, sa.reserved1,
; 1175 :                 sizeof(pSectorInfo->dwReserved1)
; 1176 :                 );

  00290	e5dd204d	 ldrb        r2, [sp, #0x4D]
  00294	e5dd304c	 ldrb        r3, [sp, #0x4C]
  00298	e5dd104e	 ldrb        r1, [sp, #0x4E]
  0029c	e5dd004f	 ldrb        r0, [sp, #0x4F]
  002a0	e5dde049	 ldrb        lr, [sp, #0x49]
  002a4	e1833402	 orr         r3, r3, r2, lsl #8
  002a8	e5dd2048	 ldrb        r2, [sp, #0x48]
  002ac	e5dd404a	 ldrb        r4, [sp, #0x4A]
  002b0	e1833801	 orr         r3, r3, r1, lsl #16
  002b4	e5dd504b	 ldrb        r5, [sp, #0x4B]
  002b8	e1833c00	 orr         r3, r3, r0, lsl #24
  002bc	e5dd6050	 ldrb        r6, [sp, #0x50]
  002c0	e5dd0015	 ldrb        r0, [sp, #0x15]
  002c4	e182240e	 orr         r2, r2, lr, lsl #8
  002c8	e1a01803	 mov         r1, r3, lsl #16
  002cc	e1823804	 orr         r3, r2, r4, lsl #16
  002d0	e5dd4014	 ldrb        r4, [sp, #0x14]
  002d4	e1833c05	 orr         r3, r3, r5, lsl #24
  002d8	e5dd5051	 ldrb        r5, [sp, #0x51]
  002dc	e0062000	 and         r2, r6, r0

; 1177 : 
; 1178 :             memcpy(
; 1179 :                 &pSectorInfo->wReserved2, sa.reserved2,
; 1180 :                 sizeof(pSectorInfo->wReserved2)
; 1181 :                 );

  002e0	e59d600c	 ldr         r6, [sp, #0xC]
  002e4	e1a03823	 mov         r3, r3, lsr #16
  002e8	e1a0e821	 mov         lr, r1, lsr #16
  002ec	e1dd14be	 ldrh        r1, [sp, #0x4E]
  002f0	e183380e	 orr         r3, r3, lr, lsl #16
  002f4	e0022004	 and         r2, r2, r4
  002f8	e5863000	 str         r3, [r6]
  002fc	e5c62005	 strb        r2, [r6, #5]
  00300	e5c65004	 strb        r5, [r6, #4]

; 1212 :         pSectorInfo++;
; 1213 :         sectors--;

  00304	e59d5008	 ldr         r5, [sp, #8]
  00308	e1c610b6	 strh        r1, [r6, #6]
  0030c		 |$LN13@FMD_ReadSe@2|
  0030c	e3a01000	 mov         r1, #0
  00310	e1a00007	 mov         r0, r7
  00314	eb000000	 bl          NAND_Enable
  00318	e3580000	 cmp         r8, #0
  0031c	0a000020	 beq         |$LN4@FMD_ReadSe@2|
  00320	e28de054	 add         lr, sp, #0x54
  00324	e28d3016	 add         r3, sp, #0x16
  00328	e1a0200a	 mov         r2, r10
  0032c	e1a01008	 mov         r1, r8
  00330	e1a00007	 mov         r0, r7
  00334	e58de000	 str         lr, [sp]
  00338	eb000000	 bl          NAND_CorrectEccData
  0033c	e3500000	 cmp         r0, #0
  00340	1a000016	 bne         |$LN112@FMD_ReadSe@2|
  00344	e1a01008	 mov         r1, r8
  00348	e3a02000	 mov         r2, #0
  0034c	e28d0051	 add         r0, sp, #0x51
  00350		 |$LL11@FMD_ReadSe@2|
  00350	e28d3014	 add         r3, sp, #0x14
  00354	e0823003	 add         r3, r2, r3
  00358	e1530000	 cmp         r3, r0
  0035c	0a000002	 beq         |$LN10@FMD_ReadSe@2|
  00360	e5d33000	 ldrb        r3, [r3]
  00364	e35300ff	 cmp         r3, #0xFF
  00368	1a000017	 bne         |$LN113@FMD_ReadSe@2|
  0036c		 |$LN10@FMD_ReadSe@2|

; 1182 :             }
; 1183 :         
; 1184 :         //  Only enable during NAND read/write/erase operations
; 1185 :         NAND_Enable(s_hNand, FALSE);
; 1186 : 
; 1187 :         // perform ecc correction and correct data when possible
; 1188 :         if ((pBuffer != NULL) &&
; 1189 :             (NAND_CorrectEccData(s_hNand, pBuffer, sectorSize, sa.ecc, rgEcc) == FALSE))
; 1190 :             {
; 1191 :             UINT count;
; 1192 :             UCHAR *pData = pBuffer;
; 1193 :             DEBUGMSG (ZONE_ERROR, (L"NAND_CorrectEccData returns FALSE, sector=%d\r\n", sector));	
; 1194 : 
; 1195 :             for (count = 0; count < sizeof(sa); count++)

  0036c	e2822001	 add         r2, r2, #1
  00370	e3520040	 cmp         r2, #0x40
  00374	3afffff5	 bcc         |$LL11@FMD_ReadSe@2|

; 1196 :                 {
; 1197 :                 // Allow OEMReserved byte to be set to reserved/readonly
; 1198 :                 if (&(((UINT8*)&sa)[count]) == &sa.oemReserved) continue;
; 1199 :                 if (((UINT8*)&sa)[count] != 0xFF) goto cleanUp;
; 1200 :                 }
; 1201 : 
; 1202 :             for (count = 0; count < sectorSize; count++)

  00378	e3a02000	 mov         r2, #0
  0037c	e35a0000	 cmp         r10, #0
  00380	0a000006	 beq         |$LN112@FMD_ReadSe@2|
  00384		 |$LL6@FMD_ReadSe@2|

; 1203 :                 {
; 1204 :                 if (*pData != 0xFF) goto cleanUp;

  00384	e5d13000	 ldrb        r3, [r1]
  00388	e35300ff	 cmp         r3, #0xFF
  0038c	1a00000e	 bne         |$LN113@FMD_ReadSe@2|
  00390	e2822001	 add         r2, r2, #1
  00394	e152000a	 cmp         r2, r10

; 1205 :                 ++pData;

  00398	e2811001	 add         r1, r1, #1
  0039c	3afffff8	 bcc         |$LL6@FMD_ReadSe@2|
  003a0		 |$LN112@FMD_ReadSe@2|

; 1196 :                 {
; 1197 :                 // Allow OEMReserved byte to be set to reserved/readonly
; 1198 :                 if (&(((UINT8*)&sa)[count]) == &sa.oemReserved) continue;
; 1199 :                 if (((UINT8*)&sa)[count] != 0xFF) goto cleanUp;
; 1200 :                 }
; 1201 : 
; 1202 :             for (count = 0; count < sectorSize; count++)

  003a0	e5997000	 ldr         r7, [r9]
  003a4		 |$LN4@FMD_ReadSe@2|

; 1206 :                 }
; 1207 :             }
; 1208 :         
; 1209 :         // Move to next sector
; 1210 :         sector++;
; 1211 :         if (pBuffer != NULL) pBuffer += sectorSize;

  003a4	e3580000	 cmp         r8, #0
  003a8	1088800a	 addne       r8, r8, r10

; 1212 :         pSectorInfo++;
; 1213 :         sectors--;

  003ac	e2555001	 subs        r5, r5, #1
  003b0	e2866008	 add         r6, r6, #8
  003b4	e58d5008	 str         r5, [sp, #8]
  003b8	e28bb001	 add         r11, r11, #1
  003bc	e58d600c	 str         r6, [sp, #0xC]
  003c0	0a000004	 beq         |$LN125@FMD_ReadSe@2|
  003c4	e1dd40b6	 ldrh        r4, [sp, #6]
  003c8	eaffff2d	 b           |$LL17@FMD_ReadSe@2|
  003cc		 |$LN113@FMD_ReadSe@2|

; 1218 :     
; 1219 :     // Done
; 1220 :     rc = TRUE;

  003cc	e5997000	 ldr         r7, [r9]
  003d0	e3a04000	 mov         r4, #0
  003d4	ea000003	 b           |$cleanUp$46392|
  003d8		 |$LN125@FMD_ReadSe@2|

; 1100 : 	
; 1101 :     while (sectors > 0)

  003d8	e59d2010	 ldr         r2, [sp, #0x10]
  003dc		 |$LN16@FMD_ReadSe@2|

; 1214 :         }
; 1215 : 
; 1216 :     //  Change idle mode back
; 1217 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), oldIdleMode);

  003dc	e597302c	 ldr         r3, [r7, #0x2C]

; 1218 :     
; 1219 :     // Done
; 1220 :     rc = TRUE;

  003e0	e3a04001	 mov         r4, #1
  003e4	e5832010	 str         r2, [r3, #0x10]
  003e8		 |$cleanUp$46392|

; 1221 : 
; 1222 : cleanUp:
; 1223 :     // Release hardware lock
; 1224 :     if (s_hNand != NULL) NAND_MutexExit(s_hNand);

  003e8	e3570000	 cmp         r7, #0
  003ec	0a000003	 beq         |$LN91@FMD_ReadSe@2|
  003f0	e1a00007	 mov         r0, r7
  003f4	eb000000	 bl          LeaveCriticalSection
  003f8	ea000000	 b           |$LN91@FMD_ReadSe@2|
  003fc		 |$LN124@FMD_ReadSe@2|

; 1212 :         pSectorInfo++;
; 1213 :         sectors--;

  003fc	e3a04000	 mov         r4, #0

; 1221 : 
; 1222 : cleanUp:
; 1223 :     // Release hardware lock
; 1224 :     if (s_hNand != NULL) NAND_MutexExit(s_hNand);

  00400		 |$LN91@FMD_ReadSe@2|

; 1225 :     
; 1226 :     ASSERT(rc);
; 1227 :     return rc;

  00400	e59d0088	 ldr         r0, [sp, #0x88]
  00404	eb000000	 bl          __security_check_cookie

; 1228 : }

  00408	e1a00004	 mov         r0, r4
  0040c	e28dd08c	 add         sp, sp, #0x8C
  00410	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00414	e12fff1e	 bx          lr
  00418		 |$LN129@FMD_ReadSe@2|
  00418		 |$LN130@FMD_ReadSe@2|
  00418	00000000	 DCD         |s_hNand|
  0041c		 |$LN131@FMD_ReadSe@2|
  0041c	00000000	 DCD         |__security_cookie|
  00420		 |$M47319|

			 ENDP  ; |FMD_ReadSector|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|FMD_WriteSector|
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T47511| DCD	|$LN89@FMD_WriteS|
	DCD	0xc000e302

  00000			 AREA	 |.xdata|, DATA
|$T47507| DCD	0xffffffd8
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T47507|

  00008		 |FMD_WriteSector| PROC

; 1241 : {

  00008		 |$LN89@FMD_WriteS|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd05c	 sub         sp, sp, #0x5C
  00010		 |$M47508|
  00010	e1a06000	 mov         r6, r0
  00014	e58d6000	 str         r6, [sp]
  00018	e1a09003	 mov         r9, r3
  0001c	e1a08002	 mov         r8, r2
  00020	e1a0a001	 mov         r10, r1
  00024	e59fe364	 ldr         lr, [pc, #0x364]
  00028	e59ee000	 ldr         lr, [lr]
  0002c	e58de058	 str         lr, [sp, #0x58]

; 1242 :     BOOL rc = FALSE;
; 1243 :     NAND_SPARE_AREA sa;
; 1244 :     UINT32 oldIdleMode;
; 1245 :     UINT32 sectorSize;
; 1246 :     SECTOR_ADDR startSector = sector;
; 1247 :     SECTOR_ADDR endSector = sector + sectors;
; 1248 :     NandDevice_t *pDevice = (NandDevice_t*)s_hNand;

  00030	e59fb354	 ldr         r11, [pc, #0x354]
  00034	e3a05000	 mov         r5, #0
  00038	e59b7000	 ldr         r7, [r11]
  0003c	e58d7014	 str         r7, [sp, #0x14]

; 1249 : 
; 1250 :     // Fail if FMD wasn't opened
; 1251 :     if (s_hNand == NULL) goto cleanUp;

  00040	e3570000	 cmp         r7, #0
  00044	0a0000c9	 beq         |$LN79@FMD_WriteS|

; 1252 :     
; 1253 :     // Obtain hardware lock
; 1254 :     NAND_MutexEnter(s_hNand);

  00048	e1a00007	 mov         r0, r7
  0004c	eb000000	 bl          EnterCriticalSection

; 1255 : 
; 1256 :     //  Change idle mode to no-idle to ensure access to GPMC registers
; 1257 :     sectorSize = NAND_GetGeometry(s_hNand)->sectorSize;

  00050	e59b4000	 ldr         r4, [r11]

; 1258 :     oldIdleMode = INREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG));
; 1259 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), SYSCONFIG_NOIDLE);

  00054	e3a02008	 mov         r2, #8

; 1260 : 
; 1261 :     //  Only enable during NAND read/write/erase operations    
; 1262 :     NAND_Enable(s_hNand, TRUE);

  00058	e3a01001	 mov         r1, #1
  0005c	e594e02c	 ldr         lr, [r4, #0x2C]
  00060	e5945050	 ldr         r5, [r4, #0x50]
  00064	e1a00004	 mov         r0, r4
  00068	e59e3010	 ldr         r3, [lr, #0x10]
  0006c	e58d500c	 str         r5, [sp, #0xC]
  00070	e58e2010	 str         r2, [lr, #0x10]
  00074	e58d3010	 str         r3, [sp, #0x10]
  00078	eb000000	 bl          NAND_Enable

; 1263 :     NAND_LockBlocks(s_hNand, startSector, endSector, FALSE);

  0007c	e594202c	 ldr         r2, [r4, #0x2C]
  00080		 |$cleanUp$47353|

; 1264 :     
; 1265 :     while (sectors > 0)

  00080	e3590000	 cmp         r9, #0
  00084	e5923050	 ldr         r3, [r2, #0x50]
  00088	e3833010	 orr         r3, r3, #0x10
  0008c	e5823050	 str         r3, [r2, #0x50]
  00090	0a0000a7	 beq         |$LN86@FMD_WriteS|
  00094	e1a020a5	 mov         r2, r5, lsr #1
  00098	e1a03802	 mov         r3, r2, lsl #16
  0009c	e1a03c23	 mov         r3, r3, lsr #24
  000a0	e1cd30b6	 strh        r3, [sp, #6]
  000a4	e20230ff	 and         r3, r2, #0xFF
  000a8	e59f52d8	 ldr         r5, [pc, #0x2D8]
  000ac	e1cd30b8	 strh        r3, [sp, #8]
  000b0		 |$LL9@FMD_WriteS|

; 1266 :         {
; 1267 :         // Clear out spare area struct
; 1268 :         memset(&sa, 0xFF, sizeof(NAND_SPARE_AREA));

  000b0	e3a02040	 mov         r2, #0x40
  000b4	e3a010ff	 mov         r1, #0xFF
  000b8	e28d0018	 add         r0, sp, #0x18
  000bc	eb000000	 bl          memset

; 1269 : 
; 1270 :         // When there is buffer write data
; 1271 :         if (pBuffer != NULL)

  000c0	e35a0000	 cmp         r10, #0
  000c4	0a00002e	 beq         |$LN7@FMD_WriteS|

; 1272 :             {
; 1273 :             // enable prefetch
; 1274 :             NAND_ConfigurePrefetch(s_hNand, NAND_DATA_WRITE);

  000c8	eb000000	 bl          BSPGetNandCS
  000cc	e594302c	 ldr         r3, [r4, #0x2C]
  000d0	e3a0e000	 mov         lr, #0
  000d4	e2002007	 and         r2, r0, #7
  000d8	e583e1ec	 str         lr, [r3, #0x1EC]
  000dc	e2003003	 and         r3, r0, #3
  000e0	e594102c	 ldr         r1, [r4, #0x2C]
  000e4	e1833a02	 orr         r3, r3, r2, lsl #20
  000e8	e3a02002	 mov         r2, #2
  000ec	e1853203	 orr         r3, r5, r3, lsl #4
  000f0	e5842018	 str         r2, [r4, #0x18]
  000f4	e58131e0	 str         r3, [r1, #0x1E0]
  000f8	e594102c	 ldr         r1, [r4, #0x2C]

; 1275 : 
; 1276 :             // send the write command
; 1277 :             NAND_SendCommand(s_hNand, NAND_CMD_WRITE1);
; 1278 : 
; 1279 :             // send the address to write to
; 1280 :             NAND_Seek(s_hNand, sector, 0);

  000fc	e59d0000	 ldr         r0, [sp]
  00100	e59b7000	 ldr         r7, [r11]
  00104	e59121e0	 ldr         r2, [r1, #0x1E0]
  00108	e1a03800	 mov         r3, r0, lsl #16
  0010c	e1a05c23	 mov         r5, r3, lsr #24
  00110	e3823080	 orr         r3, r2, #0x80
  00114	e58131e0	 str         r3, [r1, #0x1E0]
  00118	e597201c	 ldr         r2, [r7, #0x1C]
  0011c	e1a03400	 mov         r3, r0, lsl #8
  00120	e1a04c23	 mov         r4, r3, lsr #24
  00124	e3a03080	 mov         r3, #0x80
  00128	e1c230b0	 strh        r3, [r2]
  0012c	e5971020	 ldr         r1, [r7, #0x20]

; 1281 : 
; 1282 :             // send data to flash
; 1283 :             NAND_Write(s_hNand, pBuffer, sectorSize, sa.ecc);

  00130	e3a0b000	 mov         r11, #0
  00134	e20660ff	 and         r6, r6, #0xFF
  00138	e1c1e0b0	 strh        lr, [r1]
  0013c	e597e020	 ldr         lr, [r7, #0x20]
  00140	e59d200c	 ldr         r2, [sp, #0xC]
  00144	e28d301a	 add         r3, sp, #0x1A
  00148	e1ceb0b0	 strh        r11, [lr]
  0014c	e597e020	 ldr         lr, [r7, #0x20]
  00150	e1a0100a	 mov         r1, r10
  00154	e1a00007	 mov         r0, r7
  00158	e1ce60b0	 strh        r6, [lr]
  0015c	e597e020	 ldr         lr, [r7, #0x20]
  00160	e1ce50b0	 strh        r5, [lr]
  00164	e597e020	 ldr         lr, [r7, #0x20]
  00168	e1ce40b0	 strh        r4, [lr]
  0016c	eb000000	 bl          NAND_Write

; 1284 : 
; 1285 :             }
; 1286 :         else

  00170	e59fb214	 ldr         r11, [pc, #0x214]
  00174	e59d6000	 ldr         r6, [sp]
  00178	e59d7014	 ldr         r7, [sp, #0x14]
  0017c	e59b0000	 ldr         r0, [r11]
  00180	ea00003c	 b           |$LN60@FMD_WriteS|
  00184		 |$LN7@FMD_WriteS|

; 1287 :             {
; 1288 :             // Send the command
; 1289 :             NAND_SendCommand(s_hNand, NAND_CMD_READ1);

  00184	e594301c	 ldr         r3, [r4, #0x1C]

; 1290 : 
; 1291 :             // Send the address
; 1292 :             NAND_Seek(s_hNand, sector, NAND_GetGeometry(s_hNand)->sectorSize);

  00188	e3a01000	 mov         r1, #0
  0018c	e1a02806	 mov         r2, r6, lsl #16
  00190	e1c310b0	 strh        r1, [r3]
  00194	e5943050	 ldr         r3, [r4, #0x50]
  00198	e5941020	 ldr         r1, [r4, #0x20]
  0019c	e1a0ec22	 mov         lr, r2, lsr #24
  001a0	e1a000a3	 mov         r0, r3, lsr #1
  001a4	e20030ff	 and         r3, r0, #0xFF
  001a8	e1c130b0	 strh        r3, [r1]
  001ac	e5942020	 ldr         r2, [r4, #0x20]
  001b0	e1a03800	 mov         r3, r0, lsl #16
  001b4	e1a03c23	 mov         r3, r3, lsr #24
  001b8	e1c230b0	 strh        r3, [r2]
  001bc	e5942020	 ldr         r2, [r4, #0x20]
  001c0	e20650ff	 and         r5, r6, #0xFF
  001c4	e1a03406	 mov         r3, r6, lsl #8
  001c8	e1c250b0	 strh        r5, [r2]
  001cc	e1a01c23	 mov         r1, r3, lsr #24
  001d0	e5943020	 ldr         r3, [r4, #0x20]

; 1293 : 
; 1294 :             // Send the command
; 1295 :             NAND_SendCommand(s_hNand, NAND_CMD_READ2);

  001d4	e3a02030	 mov         r2, #0x30
  001d8	e1cde0b4	 strh        lr, [sp, #4]
  001dc	e1c3e0b0	 strh        lr, [r3]
  001e0	e5943020	 ldr         r3, [r4, #0x20]
  001e4	e1cd10b0	 strh        r1, [sp]
  001e8	e1c310b0	 strh        r1, [r3]
  001ec	e594301c	 ldr         r3, [r4, #0x1C]
  001f0	e1c320b0	 strh        r2, [r3]
  001f4	e3a02070	 mov         r2, #0x70

; 1296 : 
; 1297 :             // Wait for the action to finish
; 1298 :             WaitForReadyStatus(s_hNand);

  001f8		 |$LL49@FMD_WriteS|
  001f8	e594301c	 ldr         r3, [r4, #0x1C]
  001fc	e1c320b0	 strh        r2, [r3]
  00200	e5943024	 ldr         r3, [r4, #0x24]
  00204	e1d330b0	 ldrh        r3, [r3]
  00208	e3130040	 tst         r3, #0x40
  0020c	0afffff9	 beq         |$LL49@FMD_WriteS|

; 1299 : 
; 1300 :             //Force a read here, else we will read the status again
; 1301 :             NAND_SendCommand (s_hNand, NAND_CMD_READ1);

  00210	e594101c	 ldr         r1, [r4, #0x1C]

; 1302 : 
; 1303 :             // read spare area
; 1304 :             NAND_Read(s_hNand, (BYTE*)&sa, sizeof(sa), NULL);

  00214	e3a00000	 mov         r0, #0
  00218	e3a03000	 mov         r3, #0
  0021c	e1c100b0	 strh        r0, [r1]
  00220	e28d1018	 add         r1, sp, #0x18
  00224	e1a00004	 mov         r0, r4
  00228	e3a02040	 mov         r2, #0x40
  0022c	eb000000	 bl          NAND_Read

; 1305 : 
; 1306 : 
; 1307 :             // send the write command
; 1308 :             NAND_SendCommand(s_hNand, NAND_CMD_WRITE1);

  00230	e59b0000	 ldr         r0, [r11]
  00234	e3a02080	 mov         r2, #0x80
  00238	e590301c	 ldr         r3, [r0, #0x1C]
  0023c	e1c320b0	 strh        r2, [r3]

; 1309 : 
; 1310 :             // send the address to write to
; 1311 :             NAND_Seek(s_hNand, sector, sectorSize);

  00240	e5903020	 ldr         r3, [r0, #0x20]
  00244	e1dd20b8	 ldrh        r2, [sp, #8]
  00248	e1c320b0	 strh        r2, [r3]
  0024c	e5903020	 ldr         r3, [r0, #0x20]
  00250	e1dd20b6	 ldrh        r2, [sp, #6]
  00254	e1c320b0	 strh        r2, [r3]
  00258	e5903020	 ldr         r3, [r0, #0x20]
  0025c	e1dd20b4	 ldrh        r2, [sp, #4]
  00260	e1c350b0	 strh        r5, [r3]
  00264	e5903020	 ldr         r3, [r0, #0x20]
  00268	e1c320b0	 strh        r2, [r3]
  0026c	e5903020	 ldr         r3, [r0, #0x20]
  00270	e1dd20b0	 ldrh        r2, [sp]
  00274	e1c320b0	 strh        r2, [r3]
  00278		 |$LN60@FMD_WriteS|

; 1312 : 			
; 1313 :             }
; 1314 : 		
; 1315 :         /* used for test purpose */ 
; 1316 :         if((pSectorInfo != NULL) && (pSectorInfo->bOEMReserved == SKIP_ECC_WRITE_MAGIC_NUMBER) )

  00278	e3580000	 cmp         r8, #0
  0027c	0a00000e	 beq         |$LN4@FMD_WriteS|
  00280	e5d84004	 ldrb        r4, [r8, #4]
  00284	e354000f	 cmp         r4, #0xF
  00288	1a000002	 bne         |$LN5@FMD_WriteS|

; 1317 :         {
; 1318 :             /* skip updating ECC */
; 1319 :             ECC_Reset(pDevice->pGpmcRegs);			

  0028c	e597002c	 ldr         r0, [r7, #0x2C]
  00290	eb000000	 bl          ECC_Reset

; 1320 : 	     goto  skip_ecc; 	

  00294	ea00000c	 b           |$skip_ecc$46465|
  00298		 |$LN5@FMD_WriteS|

; 1321 :         }
; 1322 : 
; 1323 :         if (pSectorInfo != NULL)
; 1324 :             {
; 1325 :             // Fill in rest of spare area info (we already have ECC from above)
; 1326 :             sa.swBadBlock     = pSectorInfo->bBadBlock;
; 1327 :             sa.oemReserved  = pSectorInfo->bOEMReserved;
; 1328 :             memcpy(sa.reserved1, &pSectorInfo->dwReserved1, sizeof(sa.reserved1));

  00298	e598e000	 ldr         lr, [r8]
  0029c	e5d82005	 ldrb        r2, [r8, #5]

; 1329 :             memcpy(sa.reserved2, &pSectorInfo->wReserved2, sizeof(sa.reserved2));

  002a0	e1d810b6	 ldrh        r1, [r8, #6]
  002a4	e1a0382e	 mov         r3, lr, lsr #16
  002a8	e1cd35b0	 strh        r3, [sp, #0x50]
  002ac	e5cd2054	 strb        r2, [sp, #0x54]
  002b0	e5cd4055	 strb        r4, [sp, #0x55]
  002b4	e1cde4be	 strh        lr, [sp, #0x4E]
  002b8	e1cd15b2	 strh        r1, [sp, #0x52]
  002bc		 |$LN4@FMD_WriteS|

; 1330 :             }
; 1331 : 
; 1332 :         // write new spare info
; 1333 :         NAND_Write(s_hNand, (BYTE*)&sa, sizeof(sa), NULL);

  002bc	e3a03000	 mov         r3, #0
  002c0	e3a02040	 mov         r2, #0x40
  002c4	e28d1018	 add         r1, sp, #0x18
  002c8	eb000000	 bl          NAND_Write
  002cc		 |$skip_ecc$46465|

; 1334 : 
; 1335 : skip_ecc:
; 1336 :         // initiate the data programming process :
; 1337 :         NAND_SendCommand(s_hNand, NAND_CMD_WRITE2);

  002cc	e59b4000	 ldr         r4, [r11]
  002d0	e3a02010	 mov         r2, #0x10
  002d4	e594301c	 ldr         r3, [r4, #0x1C]
  002d8	e1c320b0	 strh        r2, [r3]
  002dc	e3a02070	 mov         r2, #0x70

; 1338 : 
; 1339 :         // wait until completion of the operation :
; 1340 :         WaitForReadyStatus(s_hNand);

  002e0		 |$LL65@FMD_WriteS|
  002e0	e594301c	 ldr         r3, [r4, #0x1C]
  002e4	e1c320b0	 strh        r2, [r3]
  002e8	e5943024	 ldr         r3, [r4, #0x24]
  002ec	e1d330b0	 ldrh        r3, [r3]
  002f0	e3130040	 tst         r3, #0x40
  002f4	0afffff9	 beq         |$LL65@FMD_WriteS|

; 1341 : 
; 1342 :         if ((NAND_GetStatus(s_hNand) & NAND_STATUS_ERROR) != 0)

  002f8	e594301c	 ldr         r3, [r4, #0x1C]
  002fc	e1c320b0	 strh        r2, [r3]
  00300	e5943024	 ldr         r3, [r4, #0x24]
  00304	e1d330b0	 ldrh        r3, [r3]
  00308	e3130001	 tst         r3, #1
  0030c	1a000008	 bne         |$LN86@FMD_WriteS|

; 1343 :             {
; 1344 :             break;
; 1345 :             }
; 1346 :         // Move to next sector
; 1347 :         sector++;
; 1348 :         if (pBuffer != NULL) pBuffer += sectorSize;

  00310	e35a0000	 cmp         r10, #0
  00314	159d300c	 ldrne       r3, [sp, #0xC]
  00318	e2866001	 add         r6, r6, #1

; 1349 :         pSectorInfo++;
; 1350 :         sectors--;

  0031c	e59f5064	 ldr         r5, [pc, #0x64]
  00320	108aa003	 addne       r10, r10, r3
  00324	e2599001	 subs        r9, r9, #1
  00328	e58d6000	 str         r6, [sp]
  0032c	e2888008	 add         r8, r8, #8
  00330	1affff5e	 bne         |$LL9@FMD_WriteS|
  00334		 |$LN86@FMD_WriteS|

; 1351 :         }
; 1352 : 
; 1353 :     //  Only enable during NAND read/write/erase operations    
; 1354 :     NAND_LockBlocks(s_hNand, startSector, endSector, TRUE);

  00334	e594202c	 ldr         r2, [r4, #0x2C]

; 1355 :     NAND_Enable(s_hNand, FALSE);

  00338	e3a01000	 mov         r1, #0
  0033c	e1a00004	 mov         r0, r4
  00340	e5923050	 ldr         r3, [r2, #0x50]
  00344		 |$cleanUp$47470|
  00344	e3c33010	 bic         r3, r3, #0x10
  00348	e5823050	 str         r3, [r2, #0x50]
  0034c	eb000000	 bl          NAND_Enable

; 1356 : 
; 1357 :     //  Change idle mode back
; 1358 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), oldIdleMode);

  00350	e594302c	 ldr         r3, [r4, #0x2C]

; 1359 : 
; 1360 :     // All is ok, when we read all sectors
; 1361 :     rc = (sectors == 0);

  00354	e59d2010	 ldr         r2, [sp, #0x10]
  00358	e3590000	 cmp         r9, #0
  0035c	03a05001	 moveq       r5, #1
  00360	e5832010	 str         r2, [r3, #0x10]
  00364	13a05000	 movne       r5, #0
  00368		 |$cleanUp$46450|

; 1362 : 
; 1363 : cleanUp:
; 1364 :     // Release hardware lock
; 1365 :     if (s_hNand != NULL) NAND_MutexExit(s_hNand);

  00368	e1a00004	 mov         r0, r4
  0036c	eb000000	 bl          LeaveCriticalSection
  00370		 |$LN79@FMD_WriteS|

; 1366 :     
; 1367 :     ASSERT(rc);
; 1368 :     return rc;

  00370	e59d0058	 ldr         r0, [sp, #0x58]
  00374	eb000000	 bl          __security_check_cookie

; 1369 : }

  00378	e1a00005	 mov         r0, r5
  0037c	e28dd05c	 add         sp, sp, #0x5C
  00380	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00384	e12fff1e	 bx          lr
  00388		 |$LN90@FMD_WriteS|
  00388		 |$LN91@FMD_WriteS|
  00388	08804001	 DCD         0x8804001
  0038c		 |$LN92@FMD_WriteS|
  0038c	00000000	 DCD         |s_hNand|
  00390		 |$LN93@FMD_WriteS|
  00390	00000000	 DCD         |__security_cookie|
  00394		 |$M47509|

			 ENDP  ; |FMD_WriteSector|

	EXPORT	|FMD_GetBlockStatus|

  00000			 AREA	 |.pdata|, PDATA
|$T47531| DCD	|$LN13@FMD_GetBlo|
	DCD	0x40002102
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FMD_GetBlockStatus| PROC

; 1439 : {

  00000		 |$LN13@FMD_GetBlo|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M47528|

; 1440 :     DWORD rc = 0;
; 1441 :     SECTOR_ADDR sector;
; 1442 :     SectorInfo sectorInfo[2];
; 1443 : 
; 1444 : 
; 1445 :     // Check if we know flash geometry
; 1446 :     if (s_hNand == NULL) goto cleanUp;

  00008	e59f3070	 ldr         r3, [pc, #0x70]
  0000c	e3a04000	 mov         r4, #0
  00010	e5933000	 ldr         r3, [r3]
  00014	e3530000	 cmp         r3, #0
  00018	0a000014	 beq         |$cleanUp$46502|

; 1447 : 
; 1448 :     // Calculate sector
; 1449 :     sector = blockId * NAND_GetGeometry(s_hNand)->sectorsPerBlock;

  0001c	e593e04c	 ldr         lr, [r3, #0x4C]

; 1450 : 
; 1451 :     if (!FMD_ReadSector(sector, NULL, sectorInfo, 2))

  00020	e3a03002	 mov         r3, #2
  00024	e28d2000	 add         r2, sp, #0
  00028	e000009e	 mul         r0, lr, r0
  0002c	e3a01000	 mov         r1, #0
  00030	eb000000	 bl          FMD_ReadSector
  00034	e3500000	 cmp         r0, #0

; 1452 :         {
; 1453 :         rc = BLOCK_STATUS_UNKNOWN;

  00038	03a04001	 moveq       r4, #1
  0003c	0a00000b	 beq         |$cleanUp$46502|

; 1454 :         goto cleanUp;
; 1455 :         }
; 1456 : 
; 1457 :     if ((sectorInfo[0].bBadBlock != 0xFF) || (sectorInfo[1].bBadBlock != 0xFF))

  00040	e5dd3005	 ldrb        r3, [sp, #5]
  00044	e35300ff	 cmp         r3, #0xFF
  00048	1a000002	 bne         |$LN3@FMD_GetBlo|
  0004c	e5dd300d	 ldrb        r3, [sp, #0xD]
  00050	e35300ff	 cmp         r3, #0xFF
  00054	0a000000	 beq         |$LN4@FMD_GetBlo|
  00058		 |$LN3@FMD_GetBlo|

; 1458 :         {
; 1459 :         rc |= BLOCK_STATUS_BAD;

  00058	e3a04002	 mov         r4, #2
  0005c		 |$LN4@FMD_GetBlo|

; 1460 :         }
; 1461 : 
; 1462 :     if ((sectorInfo[0].bOEMReserved & OEM_BLOCK_READONLY) == 0)

  0005c	e5dd3004	 ldrb        r3, [sp, #4]
  00060	e3130002	 tst         r3, #2

; 1463 :         {
; 1464 :         rc |= BLOCK_STATUS_READONLY;

  00064	03844004	 orreq       r4, r4, #4

; 1465 :         }
; 1466 : 
; 1467 :     if ((sectorInfo[0].bOEMReserved & OEM_BLOCK_RESERVED) == 0)

  00068	e3130001	 tst         r3, #1

; 1468 :         {
; 1469 :         rc |= BLOCK_STATUS_RESERVED;

  0006c	03844008	 orreq       r4, r4, #8
  00070		 |$cleanUp$46502|

; 1470 :         }
; 1471 : 
; 1472 : cleanUp:
; 1473 :     return rc;
; 1474 : }

  00070	e1a00004	 mov         r0, r4
  00074	e28dd010	 add         sp, sp, #0x10
  00078	e8bd4010	 ldmia       sp!, {r4, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$LN14@FMD_GetBlo|
  00080		 |$LN15@FMD_GetBlo|
  00080	00000000	 DCD         |s_hNand|
  00084		 |$M47529|

			 ENDP  ; |FMD_GetBlockStatus|

	EXPORT	|FMD_SetBlockStatus|

  00000			 AREA	 |.pdata|, PDATA
|$T47549| DCD	|$LN11@FMD_SetBlo|
	DCD	0x40002102
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FMD_SetBlockStatus| PROC

; 1485 : {

  00000		 |$LN11@FMD_SetBlo|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M47546|
  00008	e1a06000	 mov         r6, r0

; 1486 :     BOOL rc = FALSE;
; 1487 :     SECTOR_ADDR sector;
; 1488 :     SectorInfo sectorInfo;
; 1489 : 
; 1490 :     // Check if we know flash geometry
; 1491 :     if (s_hNand == NULL) goto cleanUp;

  0000c	e59f306c	 ldr         r3, [pc, #0x6C]
  00010	e3a04000	 mov         r4, #0
  00014	e5933000	 ldr         r3, [r3]
  00018	e3530000	 cmp         r3, #0
  0001c	0a000013	 beq         |$cleanUp$46519|

; 1492 : 
; 1493 :     // Calculate sector
; 1494 :     sector = blockId * NAND_GetGeometry(s_hNand)->sectorsPerBlock;

  00020	e593504c	 ldr         r5, [r3, #0x4C]

; 1495 : 
; 1496 :     if ((status & BLOCK_STATUS_BAD) != 0)

  00024	e3110002	 tst         r1, #2
  00028	0a00000f	 beq         |$LN1@FMD_SetBlo|

; 1497 :         {
; 1498 :         // Read the sector info
; 1499 :         if (!FMD_ReadSector(sector, NULL, &sectorInfo, 1)) goto cleanUp;

  0002c	e0000695	 mul         r0, r5, r6
  00030	e3a03001	 mov         r3, #1
  00034	e28d2000	 add         r2, sp, #0
  00038	e3a01000	 mov         r1, #0
  0003c	eb000000	 bl          FMD_ReadSector
  00040	e3500000	 cmp         r0, #0
  00044	0a000009	 beq         |$cleanUp$46519|

; 1500 : 
; 1501 :         // Set the bad block marker
; 1502 :         sectorInfo.bBadBlock = 0;

  00048	e3a03000	 mov         r3, #0

; 1503 : 
; 1504 :         // Complete the write (no erase, we changed 0xFF -> 0x00)
; 1505 :         if (!FMD_WriteSector(sector, NULL, &sectorInfo, 1)) goto cleanUp;

  0004c	e0000695	 mul         r0, r5, r6
  00050	e5cd3005	 strb        r3, [sp, #5]
  00054	e3a03001	 mov         r3, #1
  00058	e28d2000	 add         r2, sp, #0
  0005c	e3a01000	 mov         r1, #0
  00060	eb000000	 bl          FMD_WriteSector
  00064	e3500000	 cmp         r0, #0
  00068	0a000000	 beq         |$cleanUp$46519|
  0006c		 |$LN1@FMD_SetBlo|

; 1506 :         }
; 1507 : 
; 1508 : #ifdef BOOT_MODE
; 1509 :     if ( ((status & BLOCK_STATUS_READONLY) != 0) || ((status & BLOCK_STATUS_RESERVED) != 0) )
; 1510 :         {
; 1511 :         // Read the sector info
; 1512 :         if (!FMD_ReadSector(sector, NULL, &sectorInfo, 1)) goto cleanUp;
; 1513 : 
; 1514 :         // Set the OEM field
; 1515 :         sectorInfo.bOEMReserved &= ((status & BLOCK_STATUS_READONLY) != 0) ? ~(OEM_BLOCK_READONLY) : 0xFF;
; 1516 :         sectorInfo.bOEMReserved &= ((status & BLOCK_STATUS_RESERVED) != 0) ? ~(OEM_BLOCK_RESERVED) : 0xFF;
; 1517 :         
; 1518 :         // Complete the write (no erase, changed bits from 1s to 0s)
; 1519 :         if (!FMD_WriteSector(sector, NULL, &sectorInfo, 1)) goto cleanUp;
; 1520 :         }
; 1521 : #endif
; 1522 : 
; 1523 :     rc = TRUE;

  0006c	e3a04001	 mov         r4, #1
  00070		 |$cleanUp$46519|

; 1524 : 
; 1525 : cleanUp:
; 1526 :     return rc;
; 1527 : }

  00070	e1a00004	 mov         r0, r4
  00074	e28dd008	 add         sp, sp, #8
  00078	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$LN12@FMD_SetBlo|
  00080		 |$LN13@FMD_SetBlo|
  00080	00000000	 DCD         |s_hNand|
  00084		 |$M47547|

			 ENDP  ; |FMD_SetBlockStatus|

	EXPORT	|FMD_PowerUp|

  00000			 AREA	 |.pdata|, PDATA
|$T47601| DCD	|$LN26@FMD_PowerU|
	DCD	0x40002201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FMD_PowerUp| PROC

; 1536 : {

  00000		 |$LN26@FMD_PowerU|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M47598|

; 1537 :     // exit if FMD wasn't opened
; 1538 :     if (s_hNand == NULL) return;

  00004	e59f4078	 ldr         r4, [pc, #0x78]
  00008	e5940000	 ldr         r0, [r4]
  0000c	e3500000	 cmp         r0, #0
  00010	0a000019	 beq         |$LN20@FMD_PowerU|

; 1539 :     
; 1540 :     // Obtain hardware lock
; 1541 :     NAND_MutexEnter(s_hNand);

  00014	eb000000	 bl          EnterCriticalSection

; 1542 : 
; 1543 :     //  Only enable during NAND read/write/erase operations
; 1544 :     NAND_Enable(s_hNand, TRUE);

  00018	e5944000	 ldr         r4, [r4]
  0001c	e3a01001	 mov         r1, #1
  00020	e1a00004	 mov         r0, r4
  00024	eb000000	 bl          NAND_Enable
  00028	e3a01070	 mov         r1, #0x70

; 1545 : 
; 1546 :     // Wait for NAND
; 1547 :     WaitForReadyStatus(s_hNand);   

  0002c		 |$LL7@FMD_PowerU|
  0002c	e594301c	 ldr         r3, [r4, #0x1C]
  00030	e1c310b0	 strh        r1, [r3]
  00034	e5943024	 ldr         r3, [r4, #0x24]
  00038	e1d330b0	 ldrh        r3, [r3]
  0003c	e3130040	 tst         r3, #0x40
  00040	0afffff9	 beq         |$LL7@FMD_PowerU|

; 1548 : 
; 1549 :     // Write the reset command
; 1550 :     NAND_SendCommand(s_hNand, NAND_CMD_RESET);

  00044	e594301c	 ldr         r3, [r4, #0x1C]
  00048	e3a020ff	 mov         r2, #0xFF
  0004c	e1c320b0	 strh        r2, [r3]

; 1551 : 
; 1552 :     // Wait for NAND
; 1553 :     WaitForReadyStatus(s_hNand);

  00050		 |$LL15@FMD_PowerU|
  00050	e594301c	 ldr         r3, [r4, #0x1C]
  00054	e1c310b0	 strh        r1, [r3]
  00058	e5943024	 ldr         r3, [r4, #0x24]
  0005c	e1d330b0	 ldrh        r3, [r3]
  00060	e3130040	 tst         r3, #0x40
  00064	0afffff9	 beq         |$LL15@FMD_PowerU|

; 1554 : 
; 1555 :     //  Only enable during NAND read/write/erase operations
; 1556 :     NAND_Enable(s_hNand, FALSE);

  00068	e3a01000	 mov         r1, #0
  0006c	e1a00004	 mov         r0, r4
  00070	eb000000	 bl          NAND_Enable

; 1557 : 
; 1558 :     // Release hardware lock
; 1559 :     NAND_MutexExit(s_hNand);

  00074	e1a00004	 mov         r0, r4
  00078	eb000000	 bl          LeaveCriticalSection
  0007c		 |$LN20@FMD_PowerU|

; 1560 : }

  0007c	e8bd4010	 ldmia       sp!, {r4, lr}
  00080	e12fff1e	 bx          lr
  00084		 |$LN27@FMD_PowerU|
  00084		 |$LN28@FMD_PowerU|
  00084	00000000	 DCD         |s_hNand|
  00088		 |$M47599|

			 ENDP  ; |FMD_PowerUp|

	EXPORT	|FMD_PowerDown|

  00000			 AREA	 |.pdata|, PDATA
|$T47653| DCD	|$LN26@FMD_PowerD|
	DCD	0x40002201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FMD_PowerDown| PROC

; 1569 : {

  00000		 |$LN26@FMD_PowerD|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M47650|

; 1570 :     // exit if FMD wasn't opened
; 1571 :     if (s_hNand == NULL) return;

  00004	e59f4078	 ldr         r4, [pc, #0x78]
  00008	e5940000	 ldr         r0, [r4]
  0000c	e3500000	 cmp         r0, #0
  00010	0a000019	 beq         |$LN20@FMD_PowerD|

; 1572 :     
; 1573 :     // Obtain hardware lock
; 1574 :     NAND_MutexEnter(s_hNand);

  00014	eb000000	 bl          EnterCriticalSection

; 1575 : 
; 1576 :     //  Only enable during NAND read/write/erase operations
; 1577 :     NAND_Enable(s_hNand, TRUE);

  00018	e5944000	 ldr         r4, [r4]
  0001c	e3a01001	 mov         r1, #1
  00020	e1a00004	 mov         r0, r4
  00024	eb000000	 bl          NAND_Enable
  00028	e3a01070	 mov         r1, #0x70

; 1578 : 
; 1579 :     // Wait for NAND
; 1580 :     WaitForReadyStatus(s_hNand);   

  0002c		 |$LL7@FMD_PowerD|
  0002c	e594301c	 ldr         r3, [r4, #0x1C]
  00030	e1c310b0	 strh        r1, [r3]
  00034	e5943024	 ldr         r3, [r4, #0x24]
  00038	e1d330b0	 ldrh        r3, [r3]
  0003c	e3130040	 tst         r3, #0x40
  00040	0afffff9	 beq         |$LL7@FMD_PowerD|

; 1581 : 
; 1582 :     // Write the reset command
; 1583 :     NAND_SendCommand(s_hNand, NAND_CMD_RESET);

  00044	e594301c	 ldr         r3, [r4, #0x1C]
  00048	e3a020ff	 mov         r2, #0xFF
  0004c	e1c320b0	 strh        r2, [r3]

; 1584 : 
; 1585 :     // Wait for NAND
; 1586 :     WaitForReadyStatus(s_hNand);

  00050		 |$LL15@FMD_PowerD|
  00050	e594301c	 ldr         r3, [r4, #0x1C]
  00054	e1c310b0	 strh        r1, [r3]
  00058	e5943024	 ldr         r3, [r4, #0x24]
  0005c	e1d330b0	 ldrh        r3, [r3]
  00060	e3130040	 tst         r3, #0x40
  00064	0afffff9	 beq         |$LL15@FMD_PowerD|

; 1587 : 
; 1588 :     //  Only enable during NAND read/write/erase operations
; 1589 :     NAND_Enable(s_hNand, FALSE);

  00068	e3a01000	 mov         r1, #0
  0006c	e1a00004	 mov         r0, r4
  00070	eb000000	 bl          NAND_Enable

; 1590 : 
; 1591 :     // Release hardware lock
; 1592 :     NAND_MutexExit(s_hNand);

  00074	e1a00004	 mov         r0, r4
  00078	eb000000	 bl          LeaveCriticalSection
  0007c		 |$LN20@FMD_PowerD|

; 1593 : }

  0007c	e8bd4010	 ldmia       sp!, {r4, lr}
  00080	e12fff1e	 bx          lr
  00084		 |$LN27@FMD_PowerD|
  00084		 |$LN28@FMD_PowerD|
  00084	00000000	 DCD         |s_hNand|
  00088		 |$M47651|

			 ENDP  ; |FMD_PowerDown|

	EXPORT	|FMD_OEMIoControl|

  00000			 AREA	 |.pdata|, PDATA
|$T47664| DCD	|$LN5@FMD_OEMIoC|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FMD_OEMIoControl| PROC

; 1608 : {

  00000		 |$LN5@FMD_OEMIoC|
  00000		 |$M47661|

; 1609 : 
; 1610 :     UNREFERENCED_PARAMETER(code);
; 1611 : 
; 1612 :     UNREFERENCED_PARAMETER(pInBuffer);
; 1613 :     UNREFERENCED_PARAMETER(inSize);
; 1614 :     UNREFERENCED_PARAMETER(pOutBuffer);
; 1615 :     UNREFERENCED_PARAMETER(outSize);
; 1616 :     UNREFERENCED_PARAMETER(pOutSize);
; 1617 :     
; 1618 :     return FALSE;    

  00000	e3a00000	 mov         r0, #0

; 1619 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M47662|

			 ENDP  ; |FMD_OEMIoControl|

	EXPORT	|??_C@_1KM@BKLPJHHD@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HG@DCOIKHPB@?$AAF?$AAM?$AAD?$AA?5?$AAd?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?5?$AAs?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AAs?$AA?5?$AAo?$AAn?$AAl?$AAy?$AA?5?$AA1?$AA6?$AAb?$AAi?$AAt?$AAs?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CC@BEPLJHBE@?$AAE?$AAC?$AAC?$AA?5?$AAT?$AAY?$AAP?$AAE?$AA?5?$AAi?$AAs?$AA?5?$AA?$CF?$AAs?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BE@MLAOIDDC@?$AAB?$AAC?$AAH?$AA?5?$AA8?$AA?5?$AAb?$AAi?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BE@MOAEMOLD@?$AAB?$AAC?$AAH?$AA?5?$AA4?$AA?5?$AAb?$AAi?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BM@FIEJIIEI@?$AAH?$AAa?$AAm?$AAm?$AAi?$AAn?$AAg?$AA?5?$AA1?$AA?5?$AAb?$AAi?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DE@HHCNAOKK@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAa?$AAd?$AA?5?$AAE?$AAc?$AAc?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|BSPGetNandIrqWait|
	IMPORT	|BSPGetNandInfo|
	IMPORT	|NKDbgPrintfW|
	IMPORT	|KernelIoControl|

  00004			 AREA	 |.bss|, NOINIT
|s_Device| %	0x68
|s_Device| %	0x68

  00000			 AREA	 |.pdata|, PDATA
|$T47707| DCD	|$LN32@NAND_Initi|
	DCD	0x4000ac02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1KM@BKLPJHHD@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| DCB "C"
	DCB	0x0, ":", 0x0, "\\", 0x0, "W", 0x0, "I", 0x0, "N", 0x0, "C"
	DCB	0x0, "E", 0x0, "6", 0x0, "0", 0x0, "0", 0x0, "\\", 0x0, "P"
	DCB	0x0, "L", 0x0, "A", 0x0, "T", 0x0, "F", 0x0, "O", 0x0, "R"
	DCB	0x0, "M", 0x0, "\\", 0x0, "C", 0x0, "O", 0x0, "M", 0x0, "M"
	DCB	0x0, "O", 0x0, "N", 0x0, "\\", 0x0, "S", 0x0, "R", 0x0, "C"
	DCB	0x0, "\\", 0x0, "S", 0x0, "O", 0x0, "C", 0x0, "\\", 0x0, "C"
	DCB	0x0, "O", 0x0, "M", 0x0, "M", 0x0, "O", 0x0, "N", 0x0, "_"
	DCB	0x0, "T", 0x0, "I", 0x0, "_", 0x0, "V", 0x0, "1", 0x0, "\\"
	DCB	0x0, "C", 0x0, "O", 0x0, "M", 0x0, "M", 0x0, "O", 0x0, "N"
	DCB	0x0, "_", 0x0, "T", 0x0, "I", 0x0, "\\", 0x0, "B", 0x0, "L"
	DCB	0x0, "O", 0x0, "C", 0x0, "K", 0x0, "\\", 0x0, "N", 0x0, "A"
	DCB	0x0, "N", 0x0, "D", 0x0, "\\", 0x0, "D", 0x0, "E", 0x0, "V"
	DCB	0x0, "I", 0x0, "C", 0x0, "E", 0x0, "\\", 0x0, ".", 0x0, "."
	DCB	0x0, "\\", 0x0, "f", 0x0, "m", 0x0, "d", 0x0, ".", 0x0, "c"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "%", 0x0, "s", 0x0, " ", 0x0, "l", 0x0, "i", 0x0, "n"
	DCB	0x0, "e", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ":", 0x0, " "
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HG@DCOIKHPB@?$AAF?$AAM?$AAD?$AA?5?$AAd?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?5?$AAs?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AAs?$AA?5?$AAo?$AAn?$AAl?$AAy?$AA?5?$AA1?$AA6?$AAb?$AAi?$AAt?$AAs?$AA?5@| DCB "F"
	DCB	0x0, "M", 0x0, "D", 0x0, " ", 0x0, "d", 0x0, "r", 0x0, "i"
	DCB	0x0, "v", 0x0, "e", 0x0, "r", 0x0, " ", 0x0, "s", 0x0, "u"
	DCB	0x0, "p", 0x0, "p", 0x0, "o", 0x0, "r", 0x0, "t", 0x0, "s"
	DCB	0x0, " ", 0x0, "o", 0x0, "n", 0x0, "l", 0x0, "y", 0x0, " "
	DCB	0x0, "1", 0x0, "6", 0x0, "b", 0x0, "i", 0x0, "t", 0x0, "s"
	DCB	0x0, " ", 0x0, "l", 0x0, "a", 0x0, "r", 0x0, "g", 0x0, "e"
	DCB	0x0, " ", 0x0, "p", 0x0, "a", 0x0, "g", 0x0, "e", 0x0, " "
	DCB	0x0, "(", 0x0, "2", 0x0, "K", 0x0, "B", 0x0, ")", 0x0, " "
	DCB	0x0, "d", 0x0, "e", 0x0, "v", 0x0, "i", 0x0, "c", 0x0, "e"
	DCB	0x0, "s", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@BEPLJHBE@?$AAE?$AAC?$AAC?$AA?5?$AAT?$AAY?$AAP?$AAE?$AA?5?$AAi?$AAs?$AA?5?$AA?$CF?$AAs?$AA?$AN?$AA?6?$AA?$AA@| DCB "E"
	DCB	0x0, "C", 0x0, "C", 0x0, " ", 0x0, "T", 0x0, "Y", 0x0, "P"
	DCB	0x0, "E", 0x0, " ", 0x0, "i", 0x0, "s", 0x0, " ", 0x0, "%"
	DCB	0x0, "s", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@MLAOIDDC@?$AAB?$AAC?$AAH?$AA?5?$AA8?$AA?5?$AAb?$AAi?$AAt?$AA?$AA@| DCB "B"
	DCB	0x0, "C", 0x0, "H", 0x0, " ", 0x0, "8", 0x0, " ", 0x0, "b"
	DCB	0x0, "i", 0x0, "t", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@MOAEMOLD@?$AAB?$AAC?$AAH?$AA?5?$AA4?$AA?5?$AAb?$AAi?$AAt?$AA?$AA@| DCB "B"
	DCB	0x0, "C", 0x0, "H", 0x0, " ", 0x0, "4", 0x0, " ", 0x0, "b"
	DCB	0x0, "i", 0x0, "t", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BM@FIEJIIEI@?$AAH?$AAa?$AAm?$AAm?$AAi?$AAn?$AAg?$AA?5?$AA1?$AA?5?$AAb?$AAi?$AAt?$AA?$AA@| DCB "H"
	DCB	0x0, "a", 0x0, "m", 0x0, "m", 0x0, "i", 0x0, "n", 0x0, "g"
	DCB	0x0, " ", 0x0, "1", 0x0, " ", 0x0, "b", 0x0, "i", 0x0, "t"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DE@HHCNAOKK@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAa?$AAd?$AA?5?$AAE?$AAc?$AAc?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?$AN?$AA?6?$AA?$AA@| DCB "F"
	DCB	0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, " "
	DCB	0x0, "t", 0x0, "o", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "a"
	DCB	0x0, "d", 0x0, " ", 0x0, "E", 0x0, "c", 0x0, "c", 0x0, " "
	DCB	0x0, "t", 0x0, "y", 0x0, "p", 0x0, "e", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_Initialize| PROC

; 389  : {

  00000		 |$LN32@NAND_Initi|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M47704|
  00008	e1a05001	 mov         r5, r1
  0000c	e1a06000	 mov         r6, r0

; 390  :     DWORD chipSelect = BSPGetNandCS();

  00010	eb000000	 bl          BSPGetNandCS

; 391  :     const NAND_INFO *  pBSPNandInfo;
; 392  :     HANDLE hDevice = NULL;
; 393  :     UINT ffPrefetchMode = 0;
; 394  :     UINT8 manufacturer, device;
; 395  :     NandDevice_t *pDevice = &s_Device;
; 396  : #ifndef BOOT_MODE    
; 397  :     DWORD dwKernelRet;
; 398  : #endif
; 399  : 
; 400  :     UNREFERENCED_PARAMETER(pRegOut);
; 401  :     UNREFERENCED_PARAMETER(szContext);
; 402  :     // initialize structure
; 403  :     memset(pDevice, 0, sizeof(NandDevice_t));

  00014	e59f4290	 ldr         r4, [pc, #0x290]
  00018	e1a07000	 mov         r7, r0
  0001c	e3a02068	 mov         r2, #0x68
  00020	e1a00004	 mov         r0, r4
  00024	e3a01000	 mov         r1, #0
  00028	e3a08000	 mov         r8, #0
  0002c	eb000000	 bl          memset

; 404  : 
; 405  : #ifdef BOOT_MODE    
; 406  :     pDevice->pGpmcRegs = (OMAP_GPMC_REGS*)OALPAtoUA(SOCGetGPMCAddress(0));
; 407  :     pDevice->pFifo = (NANDREG*)OALPAtoUA(pRegIn->MemBase.Reg[0]);
; 408  : 
; 409  :     /* Get ECC mode from BootCfg */
; 410  :     pDevice->ECCtype = g_ecctype;
; 411  :     if((pDevice->ECCtype > BCH8bit) || (pDevice->ECCtype < Hamming1bit))
; 412  :     	{
; 413  :             pDevice->ECCtype = Hamming1bit;
; 414  :             RETAILMSG(TRUE, (L"Incorrect ECC type setting\r\n"));			
; 415  :     	}
; 416  : #else    
; 417  :     if (szContext != NULL)

  00030	e3560000	 cmp         r6, #0
  00034	0a000004	 beq         |$LN10@NAND_Initi|

; 418  :         {
; 419  :         if (InitializePointers(szContext, pDevice) == FALSE) goto cleanUp;

  00038	e1a01004	 mov         r1, r4
  0003c	e1a00006	 mov         r0, r6
  00040	eb000000	 bl          InitializePointers
  00044	e3500000	 cmp         r0, #0

; 420  :         }
; 421  :     else

  00048	ea000013	 b           |$LN29@NAND_Initi|
  0004c		 |$LN10@NAND_Initi|

; 422  :         {
; 423  :         PHYSICAL_ADDRESS pa;
; 424  :         
; 425  :         // if there's not context string then use global macros
; 426  : 
; 427  :         pa.QuadPart = pRegIn->MemBase.Reg[0];
; 428  :         pDevice->memLen[0] = pRegIn->MemLen.Reg[0];

  0004c	e595e32c	 ldr         lr, [r5, #0x32C]
  00050	e5950310	 ldr         r0, [r5, #0x310]
  00054	e3a01000	 mov         r1, #0

; 429  :         pDevice->pGpmcRegs = MmMapIoSpace(pa, pDevice->memLen[0], FALSE);

  00058	e1a0200e	 mov         r2, lr
  0005c	e3a03000	 mov         r3, #0
  00060	e584e038	 str         lr, [r4, #0x38]
  00064	eb000000	 bl          MmMapIoSpace
  00068	e3500000	 cmp         r0, #0
  0006c	e584002c	 str         r0, [r4, #0x2C]

; 430  :         if (pDevice->pGpmcRegs == NULL) goto cleanUp;

  00070	0a00007f	 beq         |$cleanUp$46080|

; 431  : 
; 432  :         pa.QuadPart = pRegIn->MemBase.Reg[1];
; 433  :         pDevice->memLen[1] = pRegIn->MemLen.Reg[1];

  00074	e595e330	 ldr         lr, [r5, #0x330]
  00078	e5950314	 ldr         r0, [r5, #0x314]
  0007c	e3a01000	 mov         r1, #0

; 434  :         pDevice->pFifo = MmMapIoSpace(pa, pDevice->memLen[1], FALSE);

  00080	e1a0200e	 mov         r2, lr
  00084	e3a03000	 mov         r3, #0
  00088	e584e03c	 str         lr, [r4, #0x3C]
  0008c	eb000000	 bl          MmMapIoSpace
  00090	e5840028	 str         r0, [r4, #0x28]

; 435  :         if (pDevice->pGpmcRegs == NULL) goto cleanUp;

  00094	e594302c	 ldr         r3, [r4, #0x2C]
  00098	e3530000	 cmp         r3, #0
  0009c		 |$LN29@NAND_Initi|
  0009c	0a000074	 beq         |$cleanUp$46080|

; 436  : 
; 437  :         }
; 438  : 
; 439  : 
; 440  :         if (!KernelIoControl(IOCTL_HAL_GET_ECC_TYPE,
; 441  :                              NULL, 0, &pDevice->ECCtype, sizeof(DWORD), &dwKernelRet))

  000a0	e59f0200	 ldr         r0, [pc, #0x200]
  000a4	e28de008	 add         lr, sp, #8
  000a8	e3a05004	 mov         r5, #4
  000ac	e2843060	 add         r3, r4, #0x60
  000b0	e3a02000	 mov         r2, #0
  000b4	e3a01000	 mov         r1, #0
  000b8	e58de004	 str         lr, [sp, #4]
  000bc	e58d5000	 str         r5, [sp]
  000c0	eb000000	 bl          KernelIoControl
  000c4	e3500000	 cmp         r0, #0
  000c8	1a000004	 bne         |$LN28@NAND_Initi|

; 442  :         {
; 443  :             RETAILMSG( TRUE,(TEXT("Failed to read Ecc type\r\n")));

  000cc	e59f01d0	 ldr         r0, [pc, #0x1D0]
  000d0	eb000000	 bl          NKDbgPrintfW

; 444  :             pDevice->ECCtype = Hamming1bit;

  000d4	e3a03000	 mov         r3, #0
  000d8	e5843060	 str         r3, [r4, #0x60]
  000dc	ea000000	 b           |$LN5@NAND_Initi|
  000e0		 |$LN28@NAND_Initi|
  000e0	e5943060	 ldr         r3, [r4, #0x60]
  000e4		 |$LN5@NAND_Initi|

; 445  :         }   
; 446  : 	
; 447  :         RETAILMSG(TRUE, (L"ECC TYPE is %s\r\n", (pDevice->ECCtype==Hamming1bit)? L"Hamming 1 bit" :
; 448  : 			                                                    (pDevice->ECCtype==BCH4bit)? L"BCH 4 bit" : L"BCH 8 bit"));

  000e4	e3530000	 cmp         r3, #0
  000e8	059f11b0	 ldreq       r1, [pc, #0x1B0]
  000ec	0a000002	 beq         |$LN14@NAND_Initi|
  000f0	e3530001	 cmp         r3, #1
  000f4	059f11a0	 ldreq       r1, [pc, #0x1A0]
  000f8	159f1198	 ldrne       r1, [pc, #0x198]
  000fc		 |$LN14@NAND_Initi|
  000fc	e59f0190	 ldr         r0, [pc, #0x190]
  00100	eb000000	 bl          NKDbgPrintfW

; 449  : 	
; 450  : #endif
; 451  : 
; 452  :     pDevice->pNandCmd = (NANDREG*)((UINT32)pDevice->pGpmcRegs + offset(OMAP_GPMC_REGS, GPMC_NAND_COMMAND_0) + (0x30 * chipSelect));

  00104	e594202c	 ldr         r2, [r4, #0x2C]
  00108	e0873087	 add         r3, r7, r7, lsl #1

; 453  :     pDevice->pNandAddress= (NANDREG*)((UINT32)pDevice->pGpmcRegs + offset(OMAP_GPMC_REGS, GPMC_NAND_ADDRESS_0) + (0x30 * chipSelect));
; 454  :     pDevice->pNandData= (NANDREG*)((UINT32)pDevice->pGpmcRegs + offset(OMAP_GPMC_REGS, GPMC_NAND_DATA_0) + (0x30 * chipSelect));
; 455  :     // Enable GPMC wait-to-nowait edge detection mechanism on NAND R/B pin
; 456  :     NAND_Enable(pDevice, TRUE);

  0010c	e3a01001	 mov         r1, #1
  00110	e0822203	 add         r2, r2, r3, lsl #4
  00114	e282307c	 add         r3, r2, #0x7C
  00118	e584301c	 str         r3, [r4, #0x1C]
  0011c	e2823080	 add         r3, r2, #0x80
  00120	e5843020	 str         r3, [r4, #0x20]
  00124	e2823084	 add         r3, r2, #0x84
  00128	e1a00004	 mov         r0, r4
  0012c	e5843024	 str         r3, [r4, #0x24]
  00130	eb000000	 bl          NAND_Enable

; 457  : 
; 458  :     // Write RESET command
; 459  :     // (a reset aborts any current READ, WRITE (PROGRAM) or ERASE operation)
; 460  :     NAND_SendCommand(pDevice, NAND_CMD_RESET);

  00134	e594301c	 ldr         r3, [r4, #0x1C]
  00138	e3a020ff	 mov         r2, #0xFF
  0013c	e1c320b0	 strh        r2, [r3]
  00140	e3a02070	 mov         r2, #0x70
  00144		 |$LL4@NAND_Initi|

; 461  : 
; 462  :     // Wait for NAND
; 463  :     while ((NAND_GetStatus(pDevice) & NAND_STATUS_READY) == 0);

  00144	e594301c	 ldr         r3, [r4, #0x1C]
  00148	e1c320b0	 strh        r2, [r3]
  0014c	e5943024	 ldr         r3, [r4, #0x24]
  00150	e1d330b0	 ldrh        r3, [r3]
  00154	e3130040	 tst         r3, #0x40
  00158	0afffff9	 beq         |$LL4@NAND_Initi|

; 464  : 
; 465  :     // Send Read ID Command
; 466  :     NAND_SendCommand(pDevice, NAND_CMD_READID);

  0015c	e594301c	 ldr         r3, [r4, #0x1C]
  00160	e3a02090	 mov         r2, #0x90

; 467  : 
; 468  :     // Send Address 00h
; 469  :     WRITE_NAND(pDevice->pNandAddress, 0);

  00164	e3a06000	 mov         r6, #0
  00168	e1c320b0	 strh        r2, [r3]
  0016c	e5943020	 ldr         r3, [r4, #0x20]
  00170	e1c360b0	 strh        r6, [r3]

; 470  : 
; 471  :     // Read the manufacturer ID & device code
; 472  :     manufacturer = (UINT8)READ_NAND(pDevice->pNandData);

  00174	e5942024	 ldr         r2, [r4, #0x24]
  00178	e5d20000	 ldrb        r0, [r2]

; 473  :     device = (UINT8)READ_NAND(pDevice->pNandData);

  0017c	e5d21000	 ldrb        r1, [r2]

; 474  : 
; 475  :  
; 476  :     if ((pBSPNandInfo = BSPGetNandInfo(manufacturer,device))==NULL)

  00180	eb000000	 bl          BSPGetNandInfo
  00184	e1b05000	 movs        r5, r0
  00188	0a000039	 beq         |$cleanUp$46080|

; 477  :     {                
; 478  :         goto cleanUp;
; 479  :     }
; 480  :     if ((pBSPNandInfo->sectorSize != 2048) && (pBSPNandInfo->wordData != 2))

  0018c	e595300c	 ldr         r3, [r5, #0xC]
  00190	e3530b02	 cmp         r3, #2, 22
  00194	0a00000a	 beq         |$LN1@NAND_Initi|
  00198	e5953010	 ldr         r3, [r5, #0x10]
  0019c	e3530002	 cmp         r3, #2
  001a0	0a000007	 beq         |$LN1@NAND_Initi|

; 481  :     {
; 482  :         ERRORMSG(1,(TEXT("FMD driver supports only 16bits large page (2KB) devices\r\n")));

  001a4	e59f10e4	 ldr         r1, [pc, #0xE4]
  001a8	e59f00dc	 ldr         r0, [pc, #0xDC]
  001ac	e3a03c01	 mov         r3, #1, 24
  001b0	e38320e2	 orr         r2, r3, #0xE2
  001b4	eb000000	 bl          NKDbgPrintfW
  001b8	e59f00c8	 ldr         r0, [pc, #0xC8]
  001bc	eb000000	 bl          NKDbgPrintfW

; 483  :         goto cleanUp;

  001c0	ea00002b	 b           |$cleanUp$46080|
  001c4		 |$LN1@NAND_Initi|

; 484  :     }
; 485  :     pDevice->nandInfo = *pBSPNandInfo;

  001c4	e2840044	 add         r0, r4, #0x44
  001c8	e3a02014	 mov         r2, #0x14
  001cc	e1a01005	 mov         r1, r5
  001d0	eb000000	 bl          memcpy

; 486  : 
; 487  :     pDevice->IrqWait = BSPGetNandIrqWait();

  001d4	eb000000	 bl          BSPGetNandIrqWait

; 488  : 
; 489  :     /* ECCCfg: 16bit bus width, cs0, 4 - 512 bytes blocks per page */
; 490  :     pDevice->ECCCfg = (GPMC_ECC_CONFIG_16BIT | (chipSelect << 1) | (0x3<<4)); 

  001d8	e3873058	 orr         r3, r7, #0x58
  001dc	e1a01083	 mov         r1, r3, lsl #1
  001e0	e584005c	 str         r0, [r4, #0x5C]
  001e4	e5841058	 str         r1, [r4, #0x58]

; 491  :     pDevice->ECCsize = (pDevice->ECCtype == Hamming1bit ) ? ECC_BYTES_HAMMING : 
; 492  : 		                      (pDevice->ECCtype == BCH4bit ) ? ECC_BYTES_BCH4 : ECC_BYTES_BCH8; 

  001e8	e5942060	 ldr         r2, [r4, #0x60]
  001ec	e3520000	 cmp         r2, #0
  001f0	03a0300c	 moveq       r3, #0xC
  001f4	0a000002	 beq         |$LN18@NAND_Initi|
  001f8	e3520001	 cmp         r2, #1
  001fc	03a0301c	 moveq       r3, #0x1C
  00200	13a03034	 movne       r3, #0x34
  00204		 |$LN18@NAND_Initi|
  00204	e5843064	 str         r3, [r4, #0x64]

; 493  : 							  
; 494  :     //  Enable and reset ECC engine (workaround for engine giving 0s first time)
; 495  :     ECC_Init(pDevice->pGpmcRegs, pDevice->ECCCfg, pDevice->ECCtype, NAND_ECC_READ);

  00208	e594002c	 ldr         r0, [r4, #0x2C]
  0020c	e3a03000	 mov         r3, #0
  00210	eb000000	 bl          ECC_Init

; 496  :     ECC_Reset(pDevice->pGpmcRegs);

  00214	e594002c	 ldr         r0, [r4, #0x2C]
  00218	eb000000	 bl          ECC_Reset

; 497  : 
; 498  :     //  Only enable during NAND read/write/erase operations
; 499  :     NAND_Enable(pDevice, FALSE);

  0021c	e3a01000	 mov         r1, #0
  00220	e1a00004	 mov         r0, r4
  00224	eb000000	 bl          NAND_Enable

; 500  : 
; 501  :     // configure the prefetch engine
; 502  :     pDevice->prefetchMode = kPrefetchOff;

  00228	e3a03000	 mov         r3, #0
  0022c	e5843018	 str         r3, [r4, #0x18]

; 503  :     OUTREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONTROL, 0);

  00230	e594302c	 ldr         r3, [r4, #0x2C]

; 504  : 
; 505  :     // set prefetch mask
; 506  :     ffPrefetchMode = GPMC_PREFETCH_CONFIG_SYNCHROMODE |
; 507  :                      GPMC_PREFETCH_CONFIG_PFPWENROUNDROBIN |
; 508  :                      GPMC_PREFETCH_CONFIG_ENABLEOPTIMIZEDACCESS |
; 509  :                      GPMC_PREFETCH_CONFIG_WAITPINSELECTOR(chipSelect) |
; 510  :                      GPMC_PREFETCH_CONFIG_FIFOTHRESHOLD(FIFO_THRESHOLD) |
; 511  :                      GPMC_PREFETCH_CONFIG_ENGINECSSELECTOR(chipSelect);

  00234	e59f0048	 ldr         r0, [pc, #0x48]

; 512  : 
; 513  :     OUTREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONFIG1, ffPrefetchMode);

  00238	e2072007	 and         r2, r7, #7
  0023c	e58361ec	 str         r6, [r3, #0x1EC]
  00240	e2073003	 and         r3, r7, #3
  00244	e594102c	 ldr         r1, [r4, #0x2C]
  00248	e1833a02	 orr         r3, r3, r2, lsl #20
  0024c	e1803203	 orr         r3, r0, r3, lsl #4
  00250	e58131e0	 str         r3, [r1, #0x1E0]

; 514  : 
; 515  :     // configure prefetch engine
; 516  :     OUTREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONFIG2, 
; 517  :         pBSPNandInfo->sectorSize
; 518  :         );

  00254	e594202c	 ldr         r2, [r4, #0x2C]
  00258	e595300c	 ldr         r3, [r5, #0xC]

; 519  :         
; 520  :     SETREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONFIG1, 
; 521  :         GPMC_PREFETCH_CONFIG_ENABLEENGINE
; 522  :         );
; 523  : 
; 524  :     // We are done
; 525  :     hDevice = pDevice;

  0025c	e1a08004	 mov         r8, r4
  00260	e58231e4	 str         r3, [r2, #0x1E4]
  00264	e594202c	 ldr         r2, [r4, #0x2C]
  00268	e59231e0	 ldr         r3, [r2, #0x1E0]
  0026c	e3833080	 orr         r3, r3, #0x80
  00270	e58231e0	 str         r3, [r2, #0x1E0]
  00274		 |$cleanUp$46080|

; 526  : 
; 527  : cleanUp:
; 528  :     return hDevice;
; 529  : }

  00274	e1a00008	 mov         r0, r8
  00278	e28dd00c	 add         sp, sp, #0xC
  0027c	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00280	e12fff1e	 bx          lr
  00284		 |$LN33@NAND_Initi|
  00284		 |$LN34@NAND_Initi|
  00284	08804008	 DCD         0x8804008
  00288		 |$LN35@NAND_Initi|
  00288	00000000	 DCD         |??_C@_1HG@DCOIKHPB@?$AAF?$AAM?$AAD?$AA?5?$AAd?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?5?$AAs?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AAs?$AA?5?$AAo?$AAn?$AAl?$AAy?$AA?5?$AA1?$AA6?$AAb?$AAi?$AAt?$AAs?$AA?5@|
  0028c		 |$LN36@NAND_Initi|
  0028c	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  00290		 |$LN37@NAND_Initi|
  00290	00000000	 DCD         |??_C@_1KM@BKLPJHHD@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  00294		 |$LN38@NAND_Initi|
  00294	00000000	 DCD         |??_C@_1CC@BEPLJHBE@?$AAE?$AAC?$AAC?$AA?5?$AAT?$AAY?$AAP?$AAE?$AA?5?$AAi?$AAs?$AA?5?$AA?$CF?$AAs?$AA?$AN?$AA?6?$AA?$AA@|
  00298		 |$LN39@NAND_Initi|
  00298	00000000	 DCD         |??_C@_1BE@MLAOIDDC@?$AAB?$AAC?$AAH?$AA?5?$AA8?$AA?5?$AAb?$AAi?$AAt?$AA?$AA@|
  0029c		 |$LN40@NAND_Initi|
  0029c	00000000	 DCD         |??_C@_1BE@MOAEMOLD@?$AAB?$AAC?$AAH?$AA?5?$AA4?$AA?5?$AAb?$AAi?$AAt?$AA?$AA@|
  002a0		 |$LN41@NAND_Initi|
  002a0	00000000	 DCD         |??_C@_1BM@FIEJIIEI@?$AAH?$AAa?$AAm?$AAm?$AAi?$AAn?$AAg?$AA?5?$AA1?$AA?5?$AAb?$AAi?$AAt?$AA?$AA@|
  002a4		 |$LN42@NAND_Initi|
  002a4	00000000	 DCD         |??_C@_1DE@HHCNAOKK@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAa?$AAd?$AA?5?$AAE?$AAc?$AAc?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?$AN?$AA?6?$AA?$AA@|
  002a8		 |$LN43@NAND_Initi|
  002a8	01013098	 DCD         0x1013098
  002ac		 |$LN44@NAND_Initi|
  002ac	00000000	 DCD         |s_Device|
  002b0		 |$M47705|

			 ENDP  ; |NAND_Initialize|


  00000			 AREA	 |.pdata|, PDATA
|$T47743| DCD	|$LN11@NAND_Erase|
	DCD	0x40001801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_EraseBlock| PROC

; 728  : {    

  00000		 |$LN11@NAND_Erase|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M47740|
  00004	e1a0e000	 mov         lr, r0

; 729  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 730  :     
; 731  :     // Calculate the sector number
; 732  :     NAND_SendCommand(hNand, NAND_CMD_ERASE_SETUP);    

  00008	e59e301c	 ldr         r3, [lr, #0x1C]
  0000c	e3a02060	 mov         r2, #0x60

; 733  :     BlockAccess(pDevice, blockId);
; 734  :     NAND_SendCommand(hNand, NAND_CMD_ERASE_CONFIRM);

  00010	e3a040d0	 mov         r4, #0xD0
  00014	e1c320b0	 strh        r2, [r3]
  00018	e59e304c	 ldr         r3, [lr, #0x4C]
  0001c	e59e2020	 ldr         r2, [lr, #0x20]

; 735  :     
; 736  :     return TRUE;

  00020	e3a00001	 mov         r0, #1
  00024	e0010193	 mul         r1, r3, r1
  00028	e20130ff	 and         r3, r1, #0xFF
  0002c	e1c230b0	 strh        r3, [r2]
  00030	e59e2020	 ldr         r2, [lr, #0x20]
  00034	e1a03801	 mov         r3, r1, lsl #16
  00038	e1a03c23	 mov         r3, r3, lsr #24
  0003c	e1c230b0	 strh        r3, [r2]
  00040	e59e2020	 ldr         r2, [lr, #0x20]
  00044	e1a03401	 mov         r3, r1, lsl #8
  00048	e1a03c23	 mov         r3, r3, lsr #24
  0004c	e1c230b0	 strh        r3, [r2]
  00050	e59e301c	 ldr         r3, [lr, #0x1C]
  00054	e1c340b0	 strh        r4, [r3]

; 737  : }

  00058	e8bd4010	 ldmia       sp!, {r4, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$M47741|

			 ENDP  ; |NAND_EraseBlock|

	EXPORT	|FMD_Init|

  00000			 AREA	 |.pdata|, PDATA
|$T47756| DCD	|$LN6@FMD_Init|
	DCD	0x40000b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FMD_Init| PROC

; 914  : {

  00000		 |$LN6@FMD_Init|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M47753|

; 915  :     HANDLE hRet = NULL;
; 916  : 
; 917  :     // Map NAND registers
; 918  :     s_hNand = NAND_Initialize(szContext, pRegIn, pRegOut);

  00004	e3a04000	 mov         r4, #0
  00008	eb000000	 bl          NAND_Initialize
  0000c	e59f3014	 ldr         r3, [pc, #0x14]
  00010	e3500000	 cmp         r0, #0

; 919  :     if (s_hNand == NULL)
; 920  :         {
; 921  :         goto cleanUp;
; 922  :         }
; 923  :         
; 924  :     // We are done
; 925  :     hRet = s_hNand;

  00014	11a04000	 movne       r4, r0
  00018	e5830000	 str         r0, [r3]
  0001c		 |$cleanUp$46337|

; 926  : 
; 927  : cleanUp:
; 928  :     return hRet;
; 929  : }

  0001c	e1a00004	 mov         r0, r4
  00020	e8bd4010	 ldmia       sp!, {r4, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$LN7@FMD_Init|
  00028		 |$LN8@FMD_Init|
  00028	00000000	 DCD         |s_hNand|
  0002c		 |$M47754|

			 ENDP  ; |FMD_Init|

	EXPORT	|FMD_EraseBlock|

  00000			 AREA	 |.pdata|, PDATA
|$T47857| DCD	|$LN45@FMD_EraseB|
	DCD	0x40004401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FMD_EraseBlock| PROC

; 1381 : {

  00000		 |$LN45@FMD_EraseB|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M47854|
  00004	e1a05000	 mov         r5, r0

; 1382 :     BOOL rc = FALSE;
; 1383 :     UINT32 oldIdleMode;
; 1384 : 
; 1385 :     // Check if we know flash geometry
; 1386 :     if (s_hNand == NULL) return rc;

  00008	e59f40fc	 ldr         r4, [pc, #0xFC]
  0000c	e5940000	 ldr         r0, [r4]
  00010	e3500000	 cmp         r0, #0
  00014	03a05000	 moveq       r5, #0
  00018	0a000038	 beq         |$LN4@FMD_EraseB|

; 1387 : 
; 1388 :     // Obtain hardware lock
; 1389 :     NAND_MutexEnter(s_hNand);

  0001c	eb000000	 bl          EnterCriticalSection

; 1390 : 
; 1391 :     //  Change idle mode to no-idle to ensure access to GPMC registers
; 1392 :     oldIdleMode = INREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG));

  00020	e5944000	 ldr         r4, [r4]

; 1393 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), SYSCONFIG_NOIDLE);

  00024	e3a02008	 mov         r2, #8

; 1394 : 
; 1395 :     //  Only enable during NAND read/write/erase operations    
; 1396 :     NAND_Enable(s_hNand, TRUE);

  00028	e3a01001	 mov         r1, #1
  0002c	e594302c	 ldr         r3, [r4, #0x2C]
  00030	e1a00004	 mov         r0, r4
  00034	e5936010	 ldr         r6, [r3, #0x10]
  00038	e5832010	 str         r2, [r3, #0x10]
  0003c	eb000000	 bl          NAND_Enable

; 1397 :     NAND_LockBlocks(s_hNand, blockId, blockId, FALSE);

  00040	e594202c	 ldr         r2, [r4, #0x2C]

; 1398 :     
; 1399 :     // send block id to erase
; 1400 :     NAND_EraseBlock(s_hNand, blockId);

  00044	e3a01060	 mov         r1, #0x60
  00048	e3a000d0	 mov         r0, #0xD0
  0004c	e5923050	 ldr         r3, [r2, #0x50]
  00050		 |$cleanUp$47781|
  00050	e3a0e070	 mov         lr, #0x70
  00054	e3833010	 orr         r3, r3, #0x10
  00058	e5823050	 str         r3, [r2, #0x50]
  0005c	e594301c	 ldr         r3, [r4, #0x1C]
  00060	e1c310b0	 strh        r1, [r3]
  00064	e594304c	 ldr         r3, [r4, #0x4C]
  00068	e5942020	 ldr         r2, [r4, #0x20]
  0006c	e0010593	 mul         r1, r3, r5
  00070	e20130ff	 and         r3, r1, #0xFF
  00074	e1c230b0	 strh        r3, [r2]
  00078	e5942020	 ldr         r2, [r4, #0x20]
  0007c	e1a03801	 mov         r3, r1, lsl #16
  00080	e1a03c23	 mov         r3, r3, lsr #24
  00084	e1c230b0	 strh        r3, [r2]
  00088	e5942020	 ldr         r2, [r4, #0x20]
  0008c	e1a03401	 mov         r3, r1, lsl #8
  00090	e1a03c23	 mov         r3, r3, lsr #24
  00094	e1c230b0	 strh        r3, [r2]
  00098	e594301c	 ldr         r3, [r4, #0x1C]
  0009c	e1c300b0	 strh        r0, [r3]

; 1401 : 
; 1402 :     // wait for completion    
; 1403 :     WaitForReadyStatus(s_hNand);

  000a0		 |$LL26@FMD_EraseB|
  000a0	e594301c	 ldr         r3, [r4, #0x1C]
  000a4	e1c3e0b0	 strh        lr, [r3]
  000a8	e5943024	 ldr         r3, [r4, #0x24]
  000ac	e1d330b0	 ldrh        r3, [r3]
  000b0	e3130040	 tst         r3, #0x40
  000b4	0afffff9	 beq         |$LL26@FMD_EraseB|

; 1404 : 
; 1405 :     //Verify there wasn't any error by checking the NAND status register :
; 1406 :     if ((NAND_GetStatus(s_hNand) & NAND_STATUS_ERROR) != 0)

  000b8	e594301c	 ldr         r3, [r4, #0x1C]
  000bc	e1c3e0b0	 strh        lr, [r3]
  000c0	e5943024	 ldr         r3, [r4, #0x24]
  000c4	e1d330b0	 ldrh        r3, [r3]
  000c8	e3130001	 tst         r3, #1

; 1407 :         {
; 1408 :         rc = FALSE;

  000cc	13a05000	 movne       r5, #0

; 1409 :         goto cleanUp;
; 1410 :         }
; 1411 : 
; 1412 :     // Done
; 1413 :     rc = TRUE;

  000d0	03a05001	 moveq       r5, #1
  000d4		 |$cleanUp$46489|

; 1414 : 
; 1415 : cleanUp:
; 1416 :     //  Only enable during NAND read/write/erase operations    
; 1417 :     NAND_LockBlocks(s_hNand, blockId, blockId, TRUE);

  000d4	e594202c	 ldr         r2, [r4, #0x2C]

; 1418 :     NAND_Enable(s_hNand, FALSE);

  000d8	e3a01000	 mov         r1, #0
  000dc	e1a00004	 mov         r0, r4
  000e0	e5923050	 ldr         r3, [r2, #0x50]
  000e4		 |$cleanUp$47834|
  000e4	e3c33010	 bic         r3, r3, #0x10
  000e8	e5823050	 str         r3, [r2, #0x50]
  000ec	eb000000	 bl          NAND_Enable

; 1419 :    
; 1420 : 
; 1421 :     //  Change idle mode back
; 1422 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), oldIdleMode);

  000f0	e594302c	 ldr         r3, [r4, #0x2C]

; 1423 : 
; 1424 :     // Release hardware lock
; 1425 :     if (s_hNand != NULL) NAND_MutexExit(s_hNand);

  000f4	e1a00004	 mov         r0, r4
  000f8	e5836010	 str         r6, [r3, #0x10]
  000fc	eb000000	 bl          LeaveCriticalSection

; 1426 : 
; 1427 :     return rc;

  00100		 |$LN4@FMD_EraseB|

; 1428 : }

  00100	e1a00005	 mov         r0, r5
  00104	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00108	e12fff1e	 bx          lr
  0010c		 |$LN46@FMD_EraseB|
  0010c		 |$LN47@FMD_EraseB|
  0010c	00000000	 DCD         |s_hNand|
  00110		 |$M47855|

			 ENDP  ; |FMD_EraseBlock|

	END
