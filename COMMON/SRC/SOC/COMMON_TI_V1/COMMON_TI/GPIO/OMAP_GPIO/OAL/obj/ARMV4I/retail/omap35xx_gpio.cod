; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\GPIO\OMAP_GPIO\omap35xx_gpio.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|Omap_Gpio| [ DATA ]

  00000			 AREA	 |.data|, DATA
|Omap_Gpio| DCD	0x0
	DCD	|?OmapGpioInit@@YAHPBGPAPAXPAI@Z|
	DCD	|?OmapGpioPostInit@@YAHPAX@Z|
	DCD	|?OmapGpioDeinit@@YAHPAX@Z|
	DCD	|?OmapGpioSetBit@@YAHPAXI@Z|
	DCD	|?OmapGpioClrBit@@YAHPAXI@Z|
	DCD	|?OmapGpioGetBit@@YAKPAXI@Z|
	DCD	|?OmapGpioSetMode@@YAHPAXII@Z|
	DCD	|?OmapGpioGetMode@@YAKPAXI@Z|
	DCD	|?OmapGpioPullup@@YAHPAXII@Z|
	DCD	|?OmapGpioPulldown@@YAHPAXII@Z|
	DCD	|?OmapGpioIoControl@@YAHPAXIPAEI1IPAK@Z|
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	%	8
	EXPORT	|?InternalSetGpioBankPowerState@@YAXPAUOmapGpioDevice_t@@IW4_CEDEVICE_POWER_STATE@@@Z| ; InternalSetGpioBankPowerState
	IMPORT	|EnableDeviceClocks|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\gpio\omap_gpio\omap35xx_gpio.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T37386| DCD	|$LN9@InternalSe|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InternalSetGpioBankPowerState@@YAXPAUOmapGpioDevice_t@@IW4_CEDEVICE_POWER_STATE@@@Z| PROC ; InternalSetGpioBankPowerState

; 197  : {

  00000		 |$LN9@InternalSe|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37383|

; 198  :     // determine GPIO bank
; 199  :     UINT bank = GPIO_BANK(id);
; 200  : 
; 201  :     // check if power is enabled by client
; 202  :     if (pDevice->bank[bank].powerEnabled != 0) return;

  00004	e590000c	 ldr         r0, [r0, #0xC]
  00008	e1a032a1	 mov         r3, r1, lsr #5
  0000c	e7b03283	 ldr         r3, [r0, +r3, lsl #5]!
  00010	e3530000	 cmp         r3, #0
  00014	1a000004	 bne         |$LN1@InternalSe|

; 203  : 
; 204  :     if (state < D3)
; 205  :     {
; 206  :         EnableDeviceClocks( pDevice->bank[bank].DeviceID, TRUE );

  00018	e590001c	 ldr         r0, [r0, #0x1C]
  0001c	e3520003	 cmp         r2, #3
  00020	b3a01001	 movlt       r1, #1

; 207  :     }
; 208  :     else
; 209  :     {
; 210  : 		EnableDeviceClocks( pDevice->bank[bank].DeviceID, FALSE );

  00024	a3a01000	 movge       r1, #0
  00028	eb000000	 bl          EnableDeviceClocks
  0002c		 |$LN1@InternalSe|

; 211  :     }
; 212  : }

  0002c	e49de004	 ldr         lr, [sp], #4
  00030	e12fff1e	 bx          lr
  00034		 |$M37384|

			 ENDP  ; |?InternalSetGpioBankPowerState@@YAXPAUOmapGpioDevice_t@@IW4_CEDEVICE_POWER_STATE@@@Z|, InternalSetGpioBankPowerState

	IMPORT	|InitializeCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T37399| DCD	|$LN10@OmapGpioPo|
	DCD	0x40001601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioPostInit@@YAHPAX@Z| PROC	; OmapGpioPostInit

; 306  : {

  00000		 |$LN10@OmapGpioPo|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37396|
  00004	e1a04000	 mov         r4, r0

; 307  :     UINT8 i;
; 308  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)hContext;
; 309  : 
; 310  :     // Initialize critical sections
; 311  :     for (i = 0; i < pDevice->nbBanks; i++)

  00008	e5943004	 ldr         r3, [r4, #4]
  0000c	e3a01000	 mov         r1, #0
  00010	e3530000	 cmp         r3, #0
  00014	9a00000a	 bls         |$LN1@OmapGpioPo|
  00018	e3a05000	 mov         r5, #0
  0001c		 |$LL3@OmapGpioPo|

; 312  :     {
; 313  :         InitializeCriticalSection(&pDevice->bank[i].pCs);

  0001c	e594300c	 ldr         r3, [r4, #0xC]
  00020	e0833281	 add         r3, r3, r1, lsl #5
  00024	e2830004	 add         r0, r3, #4
  00028	eb000000	 bl          InitializeCriticalSection
  0002c	e5942004	 ldr         r2, [r4, #4]
  00030	e2853001	 add         r3, r5, #1
  00034	e20310ff	 and         r1, r3, #0xFF
  00038	e1a05001	 mov         r5, r1
  0003c	e1510002	 cmp         r1, r2
  00040	3afffff5	 bcc         |$LL3@OmapGpioPo|
  00044		 |$LN1@OmapGpioPo|

; 314  :     }
; 315  :     pDevice->fPostInit = TRUE;

  00044	e3a03001	 mov         r3, #1
  00048	e5843008	 str         r3, [r4, #8]

; 316  :     return TRUE;

  0004c	e3a00001	 mov         r0, #1

; 317  : }

  00050	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M37397|

			 ENDP  ; |?OmapGpioPostInit@@YAHPAX@Z|, OmapGpioPostInit

	IMPORT	|OALLocalFree|
	IMPORT	|MmUnmapIoSpace|
	IMPORT	|DeleteCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T37416| DCD	|$LN20@OmapGpioDe|
	DCD	0x40003401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioDeinit@@YAHPAX@Z| PROC	; OmapGpioDeinit

; 328  : {

  00000		 |$LN20@OmapGpioDe|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37413|
  00004	e1b04000	 movs        r4, r0

; 329  :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 330  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)context;
; 331  :     UINT8 i = 0;
; 332  : 
; 333  :     DEBUGMSG(ZONE_FUNCTION, (L"+OmapGpioDeinit(0x%08x)\r\n", context));
; 334  : 
; 335  :     // Check if we get correct context
; 336  :     if ((pDevice == NULL) || (pDevice->cookie != GPIO_DEVICE_COOKIE))

  0000c	0a00002c	 beq         |$cleanUp$37115|
  00010	e5942000	 ldr         r2, [r4]
  00014	e59f30b0	 ldr         r3, [pc, #0xB0]
  00018	e1520003	 cmp         r2, r3
  0001c	1a000028	 bne         |$cleanUp$37115|

; 337  :     {
; 338  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: OmapGpioDeinit: "
; 339  :             L"Incorrect context parameter\r\n"
; 340  :             ));
; 341  :         goto cleanUp;
; 342  :     }
; 343  : 
; 344  :     // Delete critical sections
; 345  :     if (pDevice->fPostInit)

  00020	e5943008	 ldr         r3, [r4, #8]
  00024	e3530000	 cmp         r3, #0
  00028	0a00000e	 beq         |$LN5@OmapGpioDe|

; 346  :     {
; 347  :         for (i = 0; i < pDevice->nbBanks; i++)

  0002c	e5943004	 ldr         r3, [r4, #4]
  00030	e3a01000	 mov         r1, #0
  00034	e3530000	 cmp         r3, #0
  00038	9a00000a	 bls         |$LN5@OmapGpioDe|
  0003c	e3a05000	 mov         r5, #0
  00040		 |$LL7@OmapGpioDe|

; 348  :             DeleteCriticalSection(&pDevice->bank[i].pCs);

  00040	e594300c	 ldr         r3, [r4, #0xC]
  00044	e0833281	 add         r3, r3, r1, lsl #5
  00048	e2830004	 add         r0, r3, #4
  0004c	eb000000	 bl          DeleteCriticalSection
  00050	e5942004	 ldr         r2, [r4, #4]
  00054	e2853001	 add         r3, r5, #1
  00058	e20310ff	 and         r1, r3, #0xFF
  0005c	e1a05001	 mov         r5, r1
  00060	e1510002	 cmp         r1, r2
  00064	3afffff5	 bcc         |$LL7@OmapGpioDe|
  00068		 |$LN5@OmapGpioDe|

; 349  :     }
; 350  :     // Unmap module registers
; 351  :     for (i = 0 ; i < pDevice->nbBanks; i++)

  00068	e5943004	 ldr         r3, [r4, #4]
  0006c	e3a01000	 mov         r1, #0
  00070	e3530000	 cmp         r3, #0
  00074	9a00000d	 bls         |$LN2@OmapGpioDe|
  00078	e3a05000	 mov         r5, #0
  0007c		 |$LL4@OmapGpioDe|

; 352  :     {
; 353  :         if (pDevice->bank[i].ppGpioRegs != NULL)

  0007c	e594300c	 ldr         r3, [r4, #0xC]
  00080	e0833281	 add         r3, r3, r1, lsl #5
  00084	e5933018	 ldr         r3, [r3, #0x18]
  00088	e3530000	 cmp         r3, #0

; 354  :         {
; 355  :             DWORD size = sizeof(OMAP_GPIO_REGS);
; 356  :             MmUnmapIoSpace((VOID*)pDevice->bank[i].ppGpioRegs, size);

  0008c	13a010a0	 movne       r1, #0xA0
  00090	11a00003	 movne       r0, r3
  00094	1b000000	 blne        MmUnmapIoSpace
  00098	e5942004	 ldr         r2, [r4, #4]
  0009c	e2853001	 add         r3, r5, #1
  000a0	e20310ff	 and         r1, r3, #0xFF
  000a4	e1a05001	 mov         r5, r1
  000a8	e1510002	 cmp         r1, r2
  000ac	3afffff2	 bcc         |$LL4@OmapGpioDe|
  000b0		 |$LN2@OmapGpioDe|

; 357  :         }
; 358  :     }
; 359  :     // Free banks structures    
; 360  :     LocalFree(pDevice->bank);

  000b0	e594000c	 ldr         r0, [r4, #0xC]
  000b4	eb000000	 bl          OALLocalFree

; 361  : 
; 362  :     // Free device structure
; 363  :     LocalFree(pDevice);

  000b8	e1a00004	 mov         r0, r4
  000bc	eb000000	 bl          OALLocalFree

; 364  : 
; 365  :     // Done
; 366  :     rc = TRUE;

  000c0	e3a00001	 mov         r0, #1
  000c4		 |$cleanUp$37115|

; 367  : 
; 368  : cleanUp:
; 369  :     DEBUGMSG(ZONE_FUNCTION, (L"-OmapGpioDeinit()\r\n"));
; 370  :     return rc;
; 371  : }

  000c4	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000c8	e12fff1e	 bx          lr
  000cc		 |$LN21@OmapGpioDe|
  000cc		 |$LN22@OmapGpioDe|
  000cc	11223344	 DCD         0x11223344
  000d0		 |$M37414|

			 ENDP  ; |?OmapGpioDeinit@@YAHPAX@Z|, OmapGpioDeinit

	IMPORT	|HalContextUpdateDirtyRegister|
	IMPORT	|LeaveCriticalSection|
	IMPORT	|EnterCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T37457| DCD	|$LN39@OmapGpioSe|
	DCD	0x40004a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioSetMode@@YAHPAXII@Z| PROC	; OmapGpioSetMode

; 384  : {

  00000		 |$LN39@OmapGpioSe|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M37454|
  00004	e1a06002	 mov         r6, r2
  00008	e1b07000	 movs        r7, r0

; 385  :     BOOL rc = FALSE;

  0000c	e3a00000	 mov         r0, #0

; 386  :     UINT bit = GPIO_BIT(id);
; 387  :     UINT bank = GPIO_BANK(id);

  00010	e1a092a1	 mov         r9, r1, lsr #5

; 388  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)context;
; 389  : 
; 390  :     // Check if we get correct context
; 391  :     if ((pDevice == NULL) || (pDevice->cookie != GPIO_DEVICE_COOKIE))

  00014	0a000040	 beq         |$cleanUp$37142|
  00018	e597e000	 ldr         lr, [r7]
  0001c	e59f3100	 ldr         r3, [pc, #0x100]
  00020	e15e0003	 cmp         lr, r3
  00024	1a00003c	 bne         |$cleanUp$37142|

; 392  :     {
; 393  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioSetMode: "
; 394  :             L"Incorrect context\r\n"
; 395  :             ));
; 396  :         goto cleanUp;
; 397  :     }
; 398  : 
; 399  :     if (id < pDevice->nbBanks*32)

  00028	e5973004	 ldr         r3, [r7, #4]
  0002c	e1510283	 cmp         r1, r3, lsl #5
  00030	2a000039	 bcs         |$cleanUp$37142|

; 400  :     {
; 401  :         UINT32 mask = 1 << (bit);
; 402  :         CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;

  00034	e597300c	 ldr         r3, [r7, #0xC]

; 403  :         OMAP_GPIO_REGS *pGpio = pDevice->bank[bank].ppGpioRegs;
; 404  : 
; 405  :         if (pDevice->fPostInit) EnterCriticalSection(pCs);

  00038	e597e008	 ldr         lr, [r7, #8]
  0003c	e201501f	 and         r5, r1, #0x1F
  00040	e0838289	 add         r8, r3, r9, lsl #5
  00044	e35e0000	 cmp         lr, #0
  00048	e5984018	 ldr         r4, [r8, #0x18]
  0004c	12880004	 addne       r0, r8, #4
  00050	e3a0a001	 mov         r10, #1
  00054	1b000000	 blne        EnterCriticalSection

; 406  :         InternalSetGpioBankPowerState(pDevice, id, D0);

  00058	e597200c	 ldr         r2, [r7, #0xC]
  0005c	e7b23289	 ldr         r3, [r2, +r9, lsl #5]!
  00060	e3530000	 cmp         r3, #0
  00064	0592001c	 ldreq       r0, [r2, #0x1C]
  00068	03a01001	 moveq       r1, #1
  0006c	0b000000	 bleq        EnableDeviceClocks

; 407  : 
; 408  :         // set gpio direction
; 409  :         if ((mode & GPIO_DIR_INPUT) != 0)
; 410  :         {
; 411  :             SETREG32(&pGpio->OE, mask);

  00070	e5943034	 ldr         r3, [r4, #0x34]
  00074	e3160001	 tst         r6, #1
  00078	1183351a	 orrne       r3, r3, r10, lsl r5

; 412  :         }
; 413  :         else
; 414  :         {
; 415  :             CLRREG32(&pGpio->OE, mask);

  0007c	01c3351a	 biceq       r3, r3, r10, lsl r5

; 416  :         }
; 417  : 
; 418  :         // set debounce mode
; 419  :         if ((mode & GPIO_DEBOUNCE_ENABLE) != 0)

  00080	e3160020	 tst         r6, #0x20
  00084	e5843034	 str         r3, [r4, #0x34]

; 420  :         {
; 421  :             SETREG32(&pGpio->DEBOUNCENABLE, mask);

  00088	e5943050	 ldr         r3, [r4, #0x50]
  0008c	1183351a	 orrne       r3, r3, r10, lsl r5

; 422  :         }
; 423  :         else
; 424  :         {
; 425  :             CLRREG32(&pGpio->DEBOUNCENABLE, mask);

  00090	01c3351a	 biceq       r3, r3, r10, lsl r5

; 426  :         }
; 427  : 
; 428  :         // set edge/level detect mode
; 429  :         if ((mode & GPIO_INT_LOW) != 0)

  00094	e3160008	 tst         r6, #8
  00098	e5843050	 str         r3, [r4, #0x50]

; 430  :         {
; 431  :             SETREG32(&pGpio->LEVELDETECT0, mask);

  0009c	e5943040	 ldr         r3, [r4, #0x40]
  000a0	1183351a	 orrne       r3, r3, r10, lsl r5

; 432  :         }
; 433  :         else
; 434  :         {
; 435  :             CLRREG32(&pGpio->LEVELDETECT0, mask);

  000a4	01c3351a	 biceq       r3, r3, r10, lsl r5

; 436  :         }
; 437  : 
; 438  :         if ((mode & GPIO_INT_HIGH) != 0)

  000a8	e3160010	 tst         r6, #0x10
  000ac	e5843040	 str         r3, [r4, #0x40]

; 439  :         {
; 440  :             SETREG32(&pGpio->LEVELDETECT1, mask);

  000b0	e5943044	 ldr         r3, [r4, #0x44]
  000b4	1183351a	 orrne       r3, r3, r10, lsl r5

; 441  :         }
; 442  :         else
; 443  :         {
; 444  :             CLRREG32(&pGpio->LEVELDETECT1, mask);

  000b8	01c3351a	 biceq       r3, r3, r10, lsl r5

; 445  :         }
; 446  : 
; 447  :         if ((mode & GPIO_INT_LOW_HIGH) != 0)

  000bc	e3160002	 tst         r6, #2
  000c0	e5843044	 str         r3, [r4, #0x44]

; 448  :         {
; 449  :             SETREG32(&pGpio->RISINGDETECT, mask);

  000c4	e5943048	 ldr         r3, [r4, #0x48]
  000c8	1183351a	 orrne       r3, r3, r10, lsl r5

; 450  :         }
; 451  :         else
; 452  :         {
; 453  :             CLRREG32(&pGpio->RISINGDETECT, mask);

  000cc	01c3351a	 biceq       r3, r3, r10, lsl r5

; 454  :         }
; 455  : 
; 456  :         if ((mode & GPIO_INT_HIGH_LOW) != 0)

  000d0	e3160004	 tst         r6, #4
  000d4	e5843048	 str         r3, [r4, #0x48]

; 457  :         {
; 458  :             SETREG32(&pGpio->FALLINGDETECT, mask);

  000d8	e594304c	 ldr         r3, [r4, #0x4C]
  000dc	1183351a	 orrne       r3, r3, r10, lsl r5

; 459  :         }
; 460  :         else
; 461  :         {
; 462  :             CLRREG32(&pGpio->FALLINGDETECT, mask);

  000e0	01c3351a	 biceq       r3, r3, r10, lsl r5
  000e4	e584304c	 str         r3, [r4, #0x4C]

; 463  :         }
; 464  : 
; 465  :         InternalSetGpioBankPowerState(pDevice, id, D4);

  000e8	e597200c	 ldr         r2, [r7, #0xC]
  000ec	e7b23289	 ldr         r3, [r2, +r9, lsl #5]!
  000f0	e3530000	 cmp         r3, #0
  000f4	0592001c	 ldreq       r0, [r2, #0x1C]
  000f8	03a01000	 moveq       r1, #0
  000fc	0b000000	 bleq        EnableDeviceClocks

; 466  :         if (pDevice->fPostInit)LeaveCriticalSection(pCs);

  00100	e5973008	 ldr         r3, [r7, #8]
  00104	e3530000	 cmp         r3, #0
  00108	12880004	 addne       r0, r8, #4
  0010c	1b000000	 blne        LeaveCriticalSection

; 467  : 
; 468  :         // indicate gpio registers need to be saved for OFF mode
; 469  :         HalContextUpdateDirtyRegister(HAL_CONTEXTSAVE_GPIO);

  00110	e3a00001	 mov         r0, #1
  00114	eb000000	 bl          HalContextUpdateDirtyRegister

; 470  : 
; 471  :         rc = TRUE;

  00118	e3a00001	 mov         r0, #1
  0011c		 |$cleanUp$37142|

; 472  :     }
; 473  : 
; 474  : cleanUp:
; 475  :     return rc;
; 476  : }

  0011c	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00120	e12fff1e	 bx          lr
  00124		 |$LN40@OmapGpioSe|
  00124		 |$LN41@OmapGpioSe|
  00124	11223344	 DCD         0x11223344
  00128		 |$M37455|

			 ENDP  ; |?OmapGpioSetMode@@YAHPAXII@Z|, OmapGpioSetMode


  00000			 AREA	 |.pdata|, PDATA
|$T37491| DCD	|$LN28@OmapGpioGe|
	DCD	0x40003d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioGetMode@@YAKPAXI@Z| PROC	; OmapGpioGetMode

; 487  : {

  00000		 |$LN28@OmapGpioGe|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M37488|
  00004	e1b05000	 movs        r5, r0

; 488  :     DWORD mode = (DWORD) -1;

  00008	e3e04000	 mvn         r4, #0

; 489  :     UINT bit = GPIO_BIT(id);
; 490  :     UINT bank = GPIO_BANK(id);

  0000c	e1a082a1	 mov         r8, r1, lsr #5

; 491  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)context;
; 492  : 
; 493  :     // Check if we get correct context
; 494  :     if ((pDevice == NULL) || (pDevice->cookie != GPIO_DEVICE_COOKIE))

  00010	0a000033	 beq         |$cleanUp$37211|
  00014	e5952000	 ldr         r2, [r5]
  00018	e59f30d0	 ldr         r3, [pc, #0xD0]
  0001c	e1520003	 cmp         r2, r3
  00020	1a00002f	 bne         |$cleanUp$37211|

; 495  :     {
; 496  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioGetMode: "
; 497  :             L"Incorrect context\r\n"
; 498  :             ));
; 499  :         goto cleanUp;
; 500  :     }
; 501  : 
; 502  :     if (id < pDevice->nbBanks*32)

  00024	e5953004	 ldr         r3, [r5, #4]
  00028	e1510283	 cmp         r1, r3, lsl #5
  0002c	2a00002c	 bcs         |$cleanUp$37211|

; 503  :     {
; 504  :         mode = 0;
; 505  :         OMAP_GPIO_REGS *pGpio = pDevice->bank[bank].ppGpioRegs;

  00030	e595300c	 ldr         r3, [r5, #0xC]

; 506  :         UINT32 mask = 1 << (bit);
; 507  :         CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;
; 508  : 
; 509  :         if (pDevice->fPostInit) EnterCriticalSection(pCs);

  00034	e595e008	 ldr         lr, [r5, #8]
  00038	e201201f	 and         r2, r1, #0x1F
  0003c	e0839288	 add         r9, r3, r8, lsl #5
  00040	e35e0000	 cmp         lr, #0
  00044	e3a03001	 mov         r3, #1
  00048	e5996018	 ldr         r6, [r9, #0x18]
  0004c	12890004	 addne       r0, r9, #4
  00050	e1a07213	 mov         r7, r3, lsl r2
  00054	e3a04000	 mov         r4, #0
  00058	1b000000	 blne        EnterCriticalSection

; 510  :         InternalSetGpioBankPowerState(pDevice, id, D0);

  0005c	e595200c	 ldr         r2, [r5, #0xC]
  00060	e7b23288	 ldr         r3, [r2, +r8, lsl #5]!
  00064	e3530000	 cmp         r3, #0
  00068	0592001c	 ldreq       r0, [r2, #0x1C]
  0006c	03a01001	 moveq       r1, #1
  00070	0b000000	 bleq        EnableDeviceClocks

; 511  : 
; 512  :         // get edge mode
; 513  :         if ((INREG32(&pGpio->OE) & mask) != 0)

  00074	e5963034	 ldr         r3, [r6, #0x34]

; 514  :         {
; 515  :             mode |= GPIO_DIR_INPUT;
; 516  :         }
; 517  :         else
; 518  :         {
; 519  :             mode |= GPIO_DIR_OUTPUT;
; 520  :         }
; 521  : 
; 522  :         // get debounce mode
; 523  :         if ((INREG32(&pGpio->DEBOUNCENABLE) & mask) != 0)
; 524  :         {
; 525  :             mode |= GPIO_DEBOUNCE_ENABLE;
; 526  :         }
; 527  : 
; 528  :         // get edge/level detect mode
; 529  :         if ((INREG32(&pGpio->LEVELDETECT0) & mask) != 0)
; 530  :         {
; 531  :             mode |= GPIO_INT_LOW;
; 532  :         }
; 533  : 
; 534  :         if ((INREG32(&pGpio->LEVELDETECT1) & mask) != 0)
; 535  :         {
; 536  :             mode |= GPIO_INT_HIGH;
; 537  :         }
; 538  : 
; 539  :         if ((INREG32(&pGpio->RISINGDETECT) & mask) != 0)
; 540  :         {
; 541  :             mode |= GPIO_INT_LOW_HIGH;
; 542  :         }
; 543  : 
; 544  :         if ((INREG32(&pGpio->FALLINGDETECT) & mask) != 0)
; 545  :         {
; 546  :             mode |= GPIO_INT_HIGH_LOW;
; 547  :         }
; 548  : 
; 549  :         InternalSetGpioBankPowerState(pDevice, id, D4);

  00078	e595200c	 ldr         r2, [r5, #0xC]
  0007c	e1130007	 tst         r3, r7
  00080	e5963050	 ldr         r3, [r6, #0x50]
  00084	13a04001	 movne       r4, #1
  00088	e1130007	 tst         r3, r7
  0008c	e5963040	 ldr         r3, [r6, #0x40]
  00090	13844020	 orrne       r4, r4, #0x20
  00094	e1130007	 tst         r3, r7
  00098	e5963044	 ldr         r3, [r6, #0x44]
  0009c	13844008	 orrne       r4, r4, #8
  000a0	e1130007	 tst         r3, r7
  000a4	e5963048	 ldr         r3, [r6, #0x48]
  000a8	13844010	 orrne       r4, r4, #0x10
  000ac	e1130007	 tst         r3, r7
  000b0	e596304c	 ldr         r3, [r6, #0x4C]
  000b4	13844002	 orrne       r4, r4, #2
  000b8	e1130007	 tst         r3, r7
  000bc	e7b23288	 ldr         r3, [r2, +r8, lsl #5]!
  000c0	13844004	 orrne       r4, r4, #4
  000c4	e3530000	 cmp         r3, #0
  000c8	0592001c	 ldreq       r0, [r2, #0x1C]
  000cc	03a01000	 moveq       r1, #0
  000d0	0b000000	 bleq        EnableDeviceClocks

; 550  :         if (pDevice->fPostInit) LeaveCriticalSection(pCs);

  000d4	e5953008	 ldr         r3, [r5, #8]
  000d8	e3530000	 cmp         r3, #0
  000dc	12890004	 addne       r0, r9, #4
  000e0	1b000000	 blne        LeaveCriticalSection
  000e4		 |$cleanUp$37211|

; 551  : 
; 552  :     }
; 553  : 
; 554  : cleanUp:
; 555  :     return mode;
; 556  : }

  000e4	e1a00004	 mov         r0, r4
  000e8	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000ec	e12fff1e	 bx          lr
  000f0		 |$LN29@OmapGpioGe|
  000f0		 |$LN30@OmapGpioGe|
  000f0	11223344	 DCD         0x11223344
  000f4		 |$M37489|

			 ENDP  ; |?OmapGpioGetMode@@YAKPAXI@Z|, OmapGpioGetMode


  00000			 AREA	 |.pdata|, PDATA
|$T37502| DCD	|$LN5@OmapGpioPu|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioPullup@@YAHPAXII@Z| PROC	; OmapGpioPullup

; 571  : {

  00000		 |$LN5@OmapGpioPu|
  00000		 |$M37499|

; 572  :     UNREFERENCED_PARAMETER(context);
; 573  :     UNREFERENCED_PARAMETER(id);
; 574  :     UNREFERENCED_PARAMETER(enable);
; 575  :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 576  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M37500|

			 ENDP  ; |?OmapGpioPullup@@YAHPAXII@Z|, OmapGpioPullup


  00000			 AREA	 |.pdata|, PDATA
|$T37511| DCD	|$LN5@OmapGpioPu@2|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioPulldown@@YAHPAXII@Z| PROC	; OmapGpioPulldown

; 589  : {

  00000		 |$LN5@OmapGpioPu@2|
  00000		 |$M37508|

; 590  :     UNREFERENCED_PARAMETER(context);
; 591  :     UNREFERENCED_PARAMETER(id);
; 592  :     UNREFERENCED_PARAMETER(enable);
; 593  :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 594  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M37509|

			 ENDP  ; |?OmapGpioPulldown@@YAHPAXII@Z|, OmapGpioPulldown


  00000			 AREA	 |.pdata|, PDATA
|$T37543| DCD	|$LN21@OmapGpioSe@2|
	DCD	0x40002e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioSetBit@@YAHPAXI@Z| PROC	; OmapGpioSetBit

; 716  : {

  00000		 |$LN21@OmapGpioSe@2|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M37540|
  00004	e1b04000	 movs        r4, r0

; 717  :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 718  :     UINT bit = GPIO_BIT(id);

  0000c	e201801f	 and         r8, r1, #0x1F

; 719  :     UINT bank = GPIO_BANK(id);

  00010	e1a062a1	 mov         r6, r1, lsr #5

; 720  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)context;
; 721  :     // Check if we get correct context & pin id
; 722  :     if ((pDevice == NULL) || (pDevice->cookie != GPIO_DEVICE_COOKIE))

  00014	0a000024	 beq         |$cleanUp$37254|
  00018	e5942000	 ldr         r2, [r4]
  0001c	e59f3090	 ldr         r3, [pc, #0x90]
  00020	e1520003	 cmp         r2, r3
  00024	1a000020	 bne         |$cleanUp$37254|

; 723  :     {
; 724  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioSetBit: Incorrect context\r\n"));
; 725  :         goto cleanUp;
; 726  :     }
; 727  : 
; 728  :     if (id < pDevice->nbBanks*32)

  00028	e5943004	 ldr         r3, [r4, #4]
  0002c	e1510283	 cmp         r1, r3, lsl #5
  00030	2a00001d	 bcs         |$cleanUp$37254|

; 729  :     {
; 730  :         volatile UINT *p = &pDevice->bank[bank].ppGpioRegs->DATAOUT;

  00034	e594300c	 ldr         r3, [r4, #0xC]

; 731  :         CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;
; 732  : 
; 733  :         if (pDevice->fPostInit) EnterCriticalSection(pCs);

  00038	e5942008	 ldr         r2, [r4, #8]
  0003c	e0835286	 add         r5, r3, r6, lsl #5
  00040	e3520000	 cmp         r2, #0
  00044	e5957018	 ldr         r7, [r5, #0x18]
  00048	12850004	 addne       r0, r5, #4
  0004c	1b000000	 blne        EnterCriticalSection

; 734  :         InternalSetGpioBankPowerState(pDevice, id, D0);

  00050	e594200c	 ldr         r2, [r4, #0xC]
  00054	e7b23286	 ldr         r3, [r2, +r6, lsl #5]!
  00058	e3530000	 cmp         r3, #0
  0005c	0592001c	 ldreq       r0, [r2, #0x1C]
  00060	03a01001	 moveq       r1, #1
  00064	0b000000	 bleq        EnableDeviceClocks

; 735  :         SETREG32(p, 1 << (bit));

  00068	e597303c	 ldr         r3, [r7, #0x3C]
  0006c	e3a02001	 mov         r2, #1
  00070	e1833812	 orr         r3, r3, r2, lsl r8
  00074	e587303c	 str         r3, [r7, #0x3C]

; 736  :         InternalSetGpioBankPowerState(pDevice, id, D4);

  00078	e594200c	 ldr         r2, [r4, #0xC]
  0007c	e7b23286	 ldr         r3, [r2, +r6, lsl #5]!
  00080	e3530000	 cmp         r3, #0
  00084	0592001c	 ldreq       r0, [r2, #0x1C]
  00088	03a01000	 moveq       r1, #0
  0008c	0b000000	 bleq        EnableDeviceClocks

; 737  :         if (pDevice->fPostInit) LeaveCriticalSection(pCs);

  00090	e5943008	 ldr         r3, [r4, #8]
  00094	e3530000	 cmp         r3, #0
  00098	12850004	 addne       r0, r5, #4
  0009c	1b000000	 blne        LeaveCriticalSection

; 738  : 
; 739  :         // indicate gpio registers need to be saved for OFF mode
; 740  :         HalContextUpdateDirtyRegister(HAL_CONTEXTSAVE_GPIO);

  000a0	e3a00001	 mov         r0, #1
  000a4	eb000000	 bl          HalContextUpdateDirtyRegister

; 741  : 
; 742  :         rc = TRUE;

  000a8	e3a00001	 mov         r0, #1
  000ac		 |$cleanUp$37254|

; 743  :     }
; 744  : 
; 745  : cleanUp:
; 746  :     return rc;
; 747  : }

  000ac	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000b0	e12fff1e	 bx          lr
  000b4		 |$LN22@OmapGpioSe@2|
  000b4		 |$LN23@OmapGpioSe@2|
  000b4	11223344	 DCD         0x11223344
  000b8		 |$M37541|

			 ENDP  ; |?OmapGpioSetBit@@YAHPAXI@Z|, OmapGpioSetBit


  00000			 AREA	 |.pdata|, PDATA
|$T37577| DCD	|$LN21@OmapGpioCl|
	DCD	0x40002e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioClrBit@@YAHPAXI@Z| PROC	; OmapGpioClrBit

; 758  : {

  00000		 |$LN21@OmapGpioCl|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M37574|
  00004	e1b04000	 movs        r4, r0

; 759  :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 760  :     UINT bit = GPIO_BIT(id);

  0000c	e201801f	 and         r8, r1, #0x1F

; 761  :     UINT bank = GPIO_BANK(id);

  00010	e1a062a1	 mov         r6, r1, lsr #5

; 762  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)context;
; 763  :     // Check if we get correct context & pin id
; 764  :     if ((pDevice == NULL) || (pDevice->cookie != GPIO_DEVICE_COOKIE))

  00014	0a000024	 beq         |$cleanUp$37276|
  00018	e5942000	 ldr         r2, [r4]
  0001c	e59f3090	 ldr         r3, [pc, #0x90]
  00020	e1520003	 cmp         r2, r3
  00024	1a000020	 bne         |$cleanUp$37276|

; 765  :     {
; 766  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioClrBit: Incorrect context\r\n"));
; 767  :         goto cleanUp;
; 768  :     }
; 769  :     if (id < pDevice->nbBanks*32)

  00028	e5943004	 ldr         r3, [r4, #4]
  0002c	e1510283	 cmp         r1, r3, lsl #5
  00030	2a00001d	 bcs         |$cleanUp$37276|

; 770  :     {
; 771  :         volatile UINT *p = &pDevice->bank[bank].ppGpioRegs->DATAOUT;

  00034	e594300c	 ldr         r3, [r4, #0xC]

; 772  :         CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;
; 773  : 
; 774  :         if (pDevice->fPostInit) EnterCriticalSection(pCs);

  00038	e5942008	 ldr         r2, [r4, #8]
  0003c	e0835286	 add         r5, r3, r6, lsl #5
  00040	e3520000	 cmp         r2, #0
  00044	e5957018	 ldr         r7, [r5, #0x18]
  00048	12850004	 addne       r0, r5, #4
  0004c	1b000000	 blne        EnterCriticalSection

; 775  :         InternalSetGpioBankPowerState(pDevice, id, D0);

  00050	e594200c	 ldr         r2, [r4, #0xC]
  00054	e7b23286	 ldr         r3, [r2, +r6, lsl #5]!
  00058	e3530000	 cmp         r3, #0
  0005c	0592001c	 ldreq       r0, [r2, #0x1C]
  00060	03a01001	 moveq       r1, #1
  00064	0b000000	 bleq        EnableDeviceClocks

; 776  :         CLRREG32(p, 1 << (bit));

  00068	e597303c	 ldr         r3, [r7, #0x3C]
  0006c	e3a02001	 mov         r2, #1
  00070	e1c33812	 bic         r3, r3, r2, lsl r8
  00074	e587303c	 str         r3, [r7, #0x3C]

; 777  :         InternalSetGpioBankPowerState(pDevice, id, D4);

  00078	e594200c	 ldr         r2, [r4, #0xC]
  0007c	e7b23286	 ldr         r3, [r2, +r6, lsl #5]!
  00080	e3530000	 cmp         r3, #0
  00084	0592001c	 ldreq       r0, [r2, #0x1C]
  00088	03a01000	 moveq       r1, #0
  0008c	0b000000	 bleq        EnableDeviceClocks

; 778  :         if (pDevice->fPostInit) LeaveCriticalSection(pCs);

  00090	e5943008	 ldr         r3, [r4, #8]
  00094	e3530000	 cmp         r3, #0
  00098	12850004	 addne       r0, r5, #4
  0009c	1b000000	 blne        LeaveCriticalSection

; 779  :         // indicate gpio registers need to be saved for OFF mode
; 780  :         HalContextUpdateDirtyRegister(HAL_CONTEXTSAVE_GPIO);

  000a0	e3a00001	 mov         r0, #1
  000a4	eb000000	 bl          HalContextUpdateDirtyRegister

; 781  :         rc = TRUE;

  000a8	e3a00001	 mov         r0, #1
  000ac		 |$cleanUp$37276|

; 782  :     }
; 783  : cleanUp:
; 784  :     return rc;
; 785  : }

  000ac	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000b0	e12fff1e	 bx          lr
  000b4		 |$LN22@OmapGpioCl|
  000b4		 |$LN23@OmapGpioCl|
  000b4	11223344	 DCD         0x11223344
  000b8		 |$M37575|

			 ENDP  ; |?OmapGpioClrBit@@YAHPAXI@Z|, OmapGpioClrBit


  00000			 AREA	 |.pdata|, PDATA
|$T37611| DCD	|$LN21@OmapGpioGe@2|
	DCD	0x40002b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioGetBit@@YAKPAXI@Z| PROC	; OmapGpioGetBit

; 796  : {

  00000		 |$LN21@OmapGpioGe@2|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M37608|
  00004	e1b04000	 movs        r4, r0

; 797  :     DWORD value = (DWORD) -1;

  00008	e3e06000	 mvn         r6, #0

; 798  :     UINT bit = GPIO_BIT(id);

  0000c	e201801f	 and         r8, r1, #0x1F

; 799  :     UINT bank = GPIO_BANK(id);

  00010	e1a072a1	 mov         r7, r1, lsr #5

; 800  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)context;
; 801  : 
; 802  :     // Check if we get correct context & pin id
; 803  :     if ((pDevice == NULL) || (pDevice->cookie != GPIO_DEVICE_COOKIE))

  00014	0a000020	 beq         |$cleanUp$37299|
  00018	e5942000	 ldr         r2, [r4]
  0001c	e59f3084	 ldr         r3, [pc, #0x84]
  00020	e1520003	 cmp         r2, r3
  00024	1a00001c	 bne         |$cleanUp$37299|

; 804  :     {
; 805  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioGetBit: Incorrect context\r\n"));
; 806  :         goto cleanUp;
; 807  :     }
; 808  : 
; 809  :     if (id < pDevice->nbBanks*32)

  00028	e5943004	 ldr         r3, [r4, #4]
  0002c	e1510283	 cmp         r1, r3, lsl #5
  00030	2a000019	 bcs         |$cleanUp$37299|

; 810  :     {
; 811  :         volatile UINT *p = &pDevice->bank[bank].ppGpioRegs->DATAIN;

  00034	e594300c	 ldr         r3, [r4, #0xC]

; 812  :         CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;
; 813  :         if (pDevice->fPostInit) EnterCriticalSection(pCs);

  00038	e5942008	 ldr         r2, [r4, #8]
  0003c	e0835287	 add         r5, r3, r7, lsl #5
  00040	e3520000	 cmp         r2, #0
  00044	e5956018	 ldr         r6, [r5, #0x18]
  00048	12850004	 addne       r0, r5, #4
  0004c	1b000000	 blne        EnterCriticalSection

; 814  :         InternalSetGpioBankPowerState(pDevice, id, D0);

  00050	e594200c	 ldr         r2, [r4, #0xC]
  00054	e7b23287	 ldr         r3, [r2, +r7, lsl #5]!
  00058	e3530000	 cmp         r3, #0
  0005c	0592001c	 ldreq       r0, [r2, #0x1C]
  00060	03a01001	 moveq       r1, #1
  00064	0b000000	 bleq        EnableDeviceClocks

; 815  :         value = (INREG32(p) >> (bit)) & 0x01;
; 816  :         InternalSetGpioBankPowerState(pDevice, id, D4);

  00068	e594100c	 ldr         r1, [r4, #0xC]
  0006c	e5963038	 ldr         r3, [r6, #0x38]
  00070	e7b12287	 ldr         r2, [r1, +r7, lsl #5]!
  00074	e1a03833	 mov         r3, r3, lsr r8
  00078	e2036001	 and         r6, r3, #1
  0007c	e3520000	 cmp         r2, #0
  00080	0591001c	 ldreq       r0, [r1, #0x1C]
  00084	03a01000	 moveq       r1, #0
  00088	0b000000	 bleq        EnableDeviceClocks

; 817  :         if (pDevice->fPostInit) LeaveCriticalSection(pCs);

  0008c	e5943008	 ldr         r3, [r4, #8]
  00090	e3530000	 cmp         r3, #0
  00094	12850004	 addne       r0, r5, #4
  00098	1b000000	 blne        LeaveCriticalSection
  0009c		 |$cleanUp$37299|

; 818  :     }
; 819  : 
; 820  : cleanUp:
; 821  :     return value;
; 822  : }

  0009c	e1a00006	 mov         r0, r6
  000a0	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000a4	e12fff1e	 bx          lr
  000a8		 |$LN22@OmapGpioGe@2|
  000a8		 |$LN23@OmapGpioGe@2|
  000a8	11223344	 DCD         0x11223344
  000ac		 |$M37609|

			 ENDP  ; |?OmapGpioGetBit@@YAKPAXI@Z|, OmapGpioGetBit


  00000			 AREA	 |.pdata|, PDATA
|$T37622| DCD	|$LN5@OmapGpioIo|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioIoControl@@YAHPAXIPAEI1IPAK@Z| PROC ; OmapGpioIoControl

; 840  : {

  00000		 |$LN5@OmapGpioIo|
  00000		 |$M37619|

; 841  : #ifdef DEVICE
; 842  :     UINT id;
; 843  :     DWORD value,mode;
; 844  :     DEVICE_IFC_GPIO ifc;
; 845  :     UINT bit;
; 846  :     UINT bank;
; 847  :     BOOL rc = FALSE;
; 848  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)context;
; 849  : 
; 850  :     UNREFERENCED_PARAMETER(pOutSize);
; 851  : 
; 852  :     DEBUGMSG(ZONE_FUNCTION, (
; 853  :         L"+OmapGpioIOControl(0x%08x, 0x%08x, 0x%08x, %d, 0x%08x, %d, 0x%08x)\r\n",
; 854  :         context, code, pInBuffer, inSize, pOutBuffer, outSize, pOutSize
; 855  :         ));
; 856  : 
; 857  :     // Check if we get correct context
; 858  :     if ((pDevice == NULL) || (pDevice->cookie != GPIO_DEVICE_COOKIE))
; 859  :     {
; 860  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioIOControl: "
; 861  :             L"Incorrect context parameter\r\n"
; 862  :             ));
; 863  :         goto cleanUp;
; 864  :     }
; 865  :     switch (code)
; 866  :     {
; 867  :     case IOCTL_DDK_GET_DRIVER_IFC:
; 868  :         // We can give interface only to our peer in device process
; 869  :         if (GetCurrentProcessId() != (DWORD)GetCallerProcess())
; 870  :         {
; 871  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: GIO_IOControl: "
; 872  :                 L"IOCTL_DDK_GET_DRIVER_IFC can be called only from "
; 873  :                 L"device process (caller process id 0x%08x)\r\n",
; 874  :                 GetCurrentProcessId()
; 875  :                 ));
; 876  :             SetLastError(ERROR_ACCESS_DENIED);
; 877  :             goto cleanUp;
; 878  :         }
; 879  :         if ((pInBuffer == NULL) || (inSize < sizeof(GUID)))
; 880  :         {
; 881  :             SetLastError(ERROR_INVALID_PARAMETER);
; 882  :             break;
; 883  :         }
; 884  :         if (IsEqualGUID(*(GUID*)pInBuffer, DEVICE_IFC_GPIO_GUID))
; 885  :         {
; 886  :             if (pOutSize != NULL) *pOutSize = sizeof(DEVICE_IFC_GPIO);
; 887  :             if ((pOutBuffer == NULL) || (outSize < sizeof(DEVICE_IFC_GPIO)))
; 888  :             {
; 889  :                 SetLastError(ERROR_INVALID_PARAMETER);
; 890  :                 break;
; 891  :             }
; 892  :             ifc.context                 = context;
; 893  :             ifc.pfnSetBit               = OmapGpioSetBit;
; 894  :             ifc.pfnClrBit               = OmapGpioClrBit;
; 895  :             ifc.pfnGetBit               = OmapGpioGetBit;
; 896  :             ifc.pfnSetMode              = OmapGpioSetMode;
; 897  :             ifc.pfnGetMode              = OmapGpioGetMode;
; 898  :             ifc.pfnPullup               = OmapGpioPullup;
; 899  :             ifc.pfnPulldown             = OmapGpioPulldown;
; 900  :             ifc.pfnInterruptInitialize  = OmapGpioInterruptInitialize;
; 901  :             ifc.pfnInterruptMask        = OmapGpioInterruptMask;
; 902  :             ifc.pfnInterruptDisable     = OmapGpioInterruptDisable;
; 903  :             ifc.pfnInterruptDone        = OmapGpioInterruptDone;
; 904  : 			ifc.pfnGetSystemIrq			= OmapGpioGetSystemIrq;
; 905  :             ifc.pfnInterruptWakeUp      = OmapGpioInterruptWakeUp;
; 906  :             ifc.pfnIoControl            = OmapGpioIoControl;
; 907  : 
; 908  :             if (!CeSafeCopyMemory(pOutBuffer, &ifc, sizeof(ifc))) break;
; 909  :             rc = TRUE;
; 910  :             break;
; 911  :         }
; 912  :         SetLastError(ERROR_INVALID_PARAMETER);
; 913  :         break;
; 914  : 
; 915  :     case IOCTL_GPIO_SETBIT:
; 916  :         if (pOutSize != 0) *pOutSize = 0;
; 917  :         if ((pInBuffer == NULL) || (inSize < sizeof(DWORD)) ||
; 918  :             !CeSafeCopyMemory(&id, pInBuffer, sizeof(DWORD)))
; 919  :         {
; 920  :             SetLastError(ERROR_INVALID_PARAMETER);
; 921  :             break;
; 922  :         }
; 923  :         OmapGpioSetBit(context, id);
; 924  :         rc = TRUE;
; 925  :         break;
; 926  : 
; 927  :     case IOCTL_GPIO_CLRBIT:
; 928  :         if (pOutSize != 0) *pOutSize = 0;
; 929  :         if ((pInBuffer == NULL) || (inSize < sizeof(DWORD)) ||
; 930  :             !CeSafeCopyMemory(&id, pInBuffer, sizeof(DWORD)))
; 931  :         {
; 932  :             SetLastError(ERROR_INVALID_PARAMETER);
; 933  :             break;
; 934  :         }
; 935  :         OmapGpioClrBit(context, id);
; 936  :         rc = TRUE;
; 937  :         break;
; 938  : 
; 939  :     case IOCTL_GPIO_GETBIT:
; 940  :         if (pOutSize != 0) *pOutSize = sizeof(DWORD);
; 941  :         if ((pInBuffer == NULL) || (inSize < sizeof(DWORD)) ||
; 942  :             !CeSafeCopyMemory(&id, pInBuffer, sizeof(DWORD)) ||
; 943  :             (pOutBuffer == NULL) || (outSize < sizeof(DWORD)))
; 944  :         {
; 945  :             SetLastError(ERROR_INVALID_PARAMETER);
; 946  :             break;
; 947  :         }
; 948  :         value = OmapGpioGetBit(context, id);
; 949  :         if (!CeSafeCopyMemory(pOutBuffer, &value, sizeof(value)))
; 950  :         {
; 951  :             SetLastError(ERROR_INVALID_PARAMETER);
; 952  :             break;
; 953  :         }
; 954  :         rc = TRUE;
; 955  :         break;
; 956  : 
; 957  :     case IOCTL_GPIO_SETMODE:
; 958  :         if (pOutSize != 0) *pOutSize = 0;
; 959  :         if ((pInBuffer == NULL) || (inSize < 2 * sizeof(DWORD)) ||
; 960  :             !CeSafeCopyMemory(
; 961  :             &id, &((DWORD*)pInBuffer)[0], sizeof(DWORD)
; 962  :             ) ||
; 963  :             !CeSafeCopyMemory(
; 964  :             &mode, &((DWORD*)pInBuffer)[1], sizeof(DWORD)
; 965  :             ))
; 966  :         {
; 967  :             SetLastError(ERROR_INVALID_PARAMETER);
; 968  :             break;
; 969  :         }
; 970  :         OmapGpioSetMode(context, id, mode);
; 971  :         rc = TRUE;
; 972  :         break;
; 973  : 
; 974  :     case IOCTL_GPIO_GETMODE:
; 975  :         if (pOutSize != 0) *pOutSize = sizeof(DWORD);
; 976  :         if ((pInBuffer == NULL) || (inSize < sizeof(DWORD)) ||
; 977  :             !CeSafeCopyMemory(&id, pInBuffer, sizeof(DWORD)) ||
; 978  :             (pOutBuffer == NULL) || (outSize < sizeof(DWORD)))
; 979  :         {
; 980  :             SetLastError(ERROR_INVALID_PARAMETER);
; 981  :             break;
; 982  :         }
; 983  :         mode = OmapGpioGetMode(context, id);
; 984  :         if (!CeSafeCopyMemory(pOutBuffer, &mode, sizeof(mode)))
; 985  :         {
; 986  :             SetLastError(ERROR_INVALID_PARAMETER);
; 987  :             break;
; 988  :         }
; 989  :         rc = TRUE;
; 990  :         break;
; 991  :         /*
; 992  :         case IOCTL_GPIO_GETIRQ:
; 993  :         if (pOutSize != 0) *pOutSize = sizeof(DWORD);
; 994  :         if ((pInBuffer == NULL) || (inSize < sizeof(DWORD)) ||
; 995  :         !CeSafeCopyMemory(&id, pInBuffer, sizeof(DWORD)) ||
; 996  :         (pOutBuffer == NULL) || (outSize < sizeof(DWORD)))
; 997  :         {
; 998  :         SetLastError(ERROR_INVALID_PARAMETER);
; 999  :         break;
; 1000 :         }
; 1001 :         value = OmapGpioGetSystemIrq(context, id);
; 1002 :         if (!CeSafeCopyMemory(pOutBuffer, &value, sizeof(value)))
; 1003 :         {
; 1004 :         SetLastError(ERROR_INVALID_PARAMETER);
; 1005 :         break;
; 1006 :         }
; 1007 :         rc = TRUE;
; 1008 :         break;
; 1009 : 
; 1010 :         case IOCTL_GPIO_INIT_INTERRUPT:
; 1011 :         if ((pInBuffer == NULL) || (inSize != sizeof(IOCTL_GPIO_INIT_INTERRUPT_INFO)))
; 1012 :         {
; 1013 :         SetLastError(ERROR_INVALID_PARAMETER);
; 1014 :         break;
; 1015 :         }
; 1016 :         else
; 1017 :         {
; 1018 :         HANDLE      hLocalEvent         = INVALID_HANDLE_VALUE;
; 1019 :         HANDLE      hCallerHandle       = GetCallerProcess();
; 1020 :         HANDLE      hCurrentProcHandle  = GetCurrentProcess();
; 1021 :         PIOCTL_GPIO_INIT_INTERRUPT_INFO pInitIntrInfo = (PIOCTL_GPIO_INIT_INTERRUPT_INFO)pInBuffer;
; 1022 : 
; 1023 :         if (hCurrentProcHandle != hCallerHandle)
; 1024 :         {
; 1025 :         BOOL    bStatus;
; 1026 : 
; 1027 :         bStatus = DuplicateHandle(hCallerHandle, pInitIntrInfo->hEvent,
; 1028 :         hCurrentProcHandle, &hLocalEvent,
; 1029 :         DUPLICATE_SAME_ACCESS,
; 1030 :         FALSE,
; 1031 :         DUPLICATE_SAME_ACCESS);
; 1032 : 
; 1033 :         if ((bStatus == FALSE) || (hLocalEvent == INVALID_HANDLE_VALUE))
; 1034 :         {
; 1035 :         RETAILMSG(1, (TEXT("GIO_IOControl: IOCTL_GPIO_INIT_INTERRUPT unable to duplicate event handle.\r\n")));
; 1036 :         break;
; 1037 :         }
; 1038 :         }
; 1039 :         else
; 1040 :         {
; 1041 :         hLocalEvent = pInitIntrInfo->hEvent;
; 1042 :         if (hLocalEvent == INVALID_HANDLE_VALUE)
; 1043 :         {
; 1044 :         SetLastError(ERROR_INVALID_PARAMETER);
; 1045 :         break;
; 1046 :         }
; 1047 :         }
; 1048 : 
; 1049 :         rc = InterruptInitialize(pInitIntrInfo->dwSysIntrID, hLocalEvent, NULL, 0);
; 1050 :         CloseHandle(hLocalEvent);
; 1051 :         }
; 1052 :         break;
; 1053 : 
; 1054 :         case IOCTL_GPIO_ACK_INTERRUPT:
; 1055 :         if ((pInBuffer == NULL) || (inSize != sizeof(IOCTL_GPIO_INTERRUPT_INFO)))
; 1056 :         {
; 1057 :         SetLastError(ERROR_INVALID_PARAMETER);
; 1058 :         break;
; 1059 :         }
; 1060 :         else
; 1061 :         {
; 1062 :         PIOCTL_GPIO_INTERRUPT_INFO pIntrInfo = (PIOCTL_GPIO_INTERRUPT_INFO)pInBuffer;
; 1063 : 
; 1064 :         rc = OmapGpioInterruptDone(context, pIntrInfo->uGpioID, pIntrInfo->dwSysIntrID);
; 1065 :         }
; 1066 :         break;
; 1067 : 
; 1068 :         case IOCTL_GPIO_DISABLE_INTERRUPT:
; 1069 :         if ((pInBuffer == NULL) || (inSize != sizeof(IOCTL_GPIO_INTERRUPT_INFO)))
; 1070 :         {
; 1071 :         SetLastError(ERROR_INVALID_PARAMETER);
; 1072 :         break;
; 1073 :         }
; 1074 :         else
; 1075 :         {
; 1076 :         PIOCTL_GPIO_INTERRUPT_INFO pIntrInfo = (PIOCTL_GPIO_INTERRUPT_INFO)pInBuffer;
; 1077 : 
; 1078 :         rc = OmapGpioInterruptDisable(context, pIntrInfo->uGpioID, pIntrInfo->dwSysIntrID);
; 1079 :         }
; 1080 :         break;
; 1081 :         }
; 1082 :         */
; 1083 :     case IOCTL_GPIO_SET_POWER_STATE:
; 1084 :         {
; 1085 :             if ((pInBuffer == NULL) || inSize != sizeof(IOCTL_GPIO_POWER_STATE_IN))
; 1086 :             {
; 1087 :                 SetLastError(ERROR_INVALID_PARAMETER);
; 1088 :                 ERRORMSG(ZONE_ERROR, (L"ERROR: OmapGpioIOControl: "
; 1089 :                     L"IOCTL_GPIO_SET_POWER_STATE - Invalid parameter\r\n"
; 1090 :                     ));
; 1091 :                 break;
; 1092 :             }
; 1093 : 
; 1094 :             IOCTL_GPIO_POWER_STATE_IN *pPowerIn;
; 1095 :             pPowerIn = (IOCTL_GPIO_POWER_STATE_IN*)pInBuffer;
; 1096 : 
; 1097 :             bank = GPIO_BANK(pPowerIn->gpioId);
; 1098 : 
; 1099 :             CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;
; 1100 :             if (pDevice->fPostInit) EnterCriticalSection(pCs);
; 1101 :             SetGpioBankPowerState(pDevice, pPowerIn->gpioId, pPowerIn->state);
; 1102 :             if (pDevice->fPostInit) LeaveCriticalSection(pCs);
; 1103 :             rc = TRUE;
; 1104 :         }
; 1105 :         break;
; 1106 : 
; 1107 :     case IOCTL_GPIO_GET_POWER_STATE:
; 1108 :         {
; 1109 :             if ((pInBuffer == NULL) || (pOutBuffer == NULL) ||
; 1110 :                 inSize != sizeof(IOCTL_GPIO_POWER_STATE_IN) ||
; 1111 :                 outSize != sizeof(IOCTL_GPIO_GET_POWER_STATE_OUT))
; 1112 :             {
; 1113 :                 SetLastError(ERROR_INVALID_PARAMETER);
; 1114 :                 ERRORMSG(ZONE_ERROR, (L"ERROR: OmapGpioIOControl: "
; 1115 :                     L"IOCTL_GPIO_SET_POWER_STATE - Invalid parameter\r\n"
; 1116 :                     ));
; 1117 :                 break;
; 1118 :             }
; 1119 : 
; 1120 :             IOCTL_GPIO_POWER_STATE_IN *pPowerIn;
; 1121 :             IOCTL_GPIO_GET_POWER_STATE_OUT *pPowerOut;
; 1122 : 
; 1123 :             pPowerIn = (IOCTL_GPIO_POWER_STATE_IN*)pInBuffer;
; 1124 :             pPowerOut = (IOCTL_GPIO_GET_POWER_STATE_OUT*)pOutBuffer;
; 1125 : 
; 1126 :             bit = GPIO_BIT(pPowerIn->gpioId);
; 1127 :             bank = GPIO_BANK(pPowerIn->gpioId);
; 1128 : 
; 1129 :             // get power state for gpio
; 1130 :             CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;
; 1131 :             if (pDevice->fPostInit) EnterCriticalSection(pCs);
; 1132 :             pPowerOut->gpioState = (pDevice->bank[bank].powerEnabled & (1 << bit)) ? D0 : D4;
; 1133 :             pPowerOut->bankState = (pDevice->bank[bank].powerEnabled) ? D0 : D4;
; 1134 :             if (pDevice->fPostInit) LeaveCriticalSection(pCs);
; 1135 : 
; 1136 :             rc = TRUE;
; 1137 :         }
; 1138 : 
; 1139 :     case IOCTL_GPIO_SET_DEBOUNCE_TIME:
; 1140 :         {
; 1141 :             if ((pInBuffer == NULL) ||
; 1142 :                 (inSize < sizeof(IOCTL_GPIO_SET_DEBOUNCE_TIME_IN)))
; 1143 :             {
; 1144 :                 SetLastError(ERROR_INVALID_PARAMETER);
; 1145 :                 break;
; 1146 :             }
; 1147 : 
; 1148 :             IOCTL_GPIO_SET_DEBOUNCE_TIME_IN *pDebounce;
; 1149 : 
; 1150 :             pDebounce = (IOCTL_GPIO_SET_DEBOUNCE_TIME_IN*)pInBuffer;
; 1151 : 
; 1152 :             if (pDebounce->gpioId < pDevice->nbBanks*32)
; 1153 :             {
; 1154 :                 CRITICAL_SECTION *pCs;
; 1155 :                 bank = GPIO_BANK(pDebounce->gpioId);
; 1156 :                 pCs = &pDevice->bank[bank].pCs;
; 1157 :                 if (pDevice->fPostInit) EnterCriticalSection(pCs);
; 1158 :                 InternalSetGpioBankPowerState(pDevice, pDebounce->gpioId, D0);
; 1159 :                 OUTREG32(&pDevice->bank[bank].ppGpioRegs->DEBOUNCINGTIME,
; 1160 :                     pDebounce->debounceTime);
; 1161 :                 InternalSetGpioBankPowerState(pDevice, pDebounce->gpioId, D4);
; 1162 :                 if (pDevice->fPostInit) LeaveCriticalSection(pCs);
; 1163 : 
; 1164 :                 // indicate gpio registers need to be saved for OFF mode
; 1165 :                 HalContextUpdateDirtyRegister(HAL_CONTEXTSAVE_GPIO);
; 1166 : 
; 1167 :                 rc = TRUE;
; 1168 :             }
; 1169 :         }
; 1170 :         break;
; 1171 : 
; 1172 :     case IOCTL_GPIO_GET_DEBOUNCE_TIME:
; 1173 :         {
; 1174 :             if ((pInBuffer == NULL) || (pOutBuffer == NULL) ||
; 1175 :                 (inSize < sizeof(UINT)) ||
; 1176 :                 (outSize < sizeof(UINT)))
; 1177 :             {
; 1178 :                 SetLastError(ERROR_INVALID_PARAMETER);
; 1179 :                 break;
; 1180 :             }
; 1181 : 
; 1182 :             UINT *pId;
; 1183 :             UINT *pOut;
; 1184 : 
; 1185 :             pId = (UINT*)pInBuffer;
; 1186 :             pOut = (UINT*)pOutBuffer;
; 1187 : 
; 1188 :             if (*pId < pDevice->nbBanks*32)
; 1189 :             {
; 1190 : 
; 1191 :                 bank = GPIO_BANK(*pId);
; 1192 : 
; 1193 :                 CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;
; 1194 :                 if (pDevice->fPostInit) EnterCriticalSection(pCs);
; 1195 :                 InternalSetGpioBankPowerState(pDevice, *pId, D0);
; 1196 :                 *pOut = INREG32(&pDevice->bank[bank].ppGpioRegs->DEBOUNCINGTIME);
; 1197 :                 InternalSetGpioBankPowerState(pDevice, *pId, D4);
; 1198 :                 if (pDevice->fPostInit) LeaveCriticalSection(pCs);
; 1199 : 
; 1200 :                 // indicate gpio registers need to be saved for OFF mode
; 1201 :                 HalContextUpdateDirtyRegister(HAL_CONTEXTSAVE_GPIO);
; 1202 : 
; 1203 :                 rc = TRUE;
; 1204 :             }
; 1205 :         }
; 1206 :         break;
; 1207 :     }
; 1208 : 
; 1209 : cleanUp:
; 1210 :     DEBUGMSG(ZONE_FUNCTION, (L"-OmapGpioIOControl(rc = %d)\r\n", rc));
; 1211 :     return rc;
; 1212 : #endif
; 1213 : 
; 1214 : #ifdef OAL
; 1215 :     UNREFERENCED_PARAMETER(context);
; 1216 :     UNREFERENCED_PARAMETER(code);
; 1217 :     UNREFERENCED_PARAMETER(pInBuffer);
; 1218 :     UNREFERENCED_PARAMETER(inSize);
; 1219 :     UNREFERENCED_PARAMETER(pOutBuffer);
; 1220 :     UNREFERENCED_PARAMETER(outSize);
; 1221 :     UNREFERENCED_PARAMETER(pOutSize);        
; 1222 :     return FALSE;

  00000	e3a00000	 mov         r0, #0

; 1223 : #endif
; 1224 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M37620|

			 ENDP  ; |?OmapGpioIoControl@@YAHPAXIPAEI1IPAK@Z|, OmapGpioIoControl

	EXPORT	|?OmapGpioPowerUp@@YAXPAX@Z|		; OmapGpioPowerUp

  00000			 AREA	 |.pdata|, PDATA
|$T37629| DCD	|$LN5@OmapGpioPo@2|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioPowerUp@@YAXPAX@Z| PROC	; OmapGpioPowerUp

; 1236 : {

  00000		 |$LN5@OmapGpioPo@2|
  00000		 |$M37626|

; 1237 :     UNREFERENCED_PARAMETER(hContext);
; 1238 : }

  00000	e12fff1e	 bx          lr
  00004		 |$M37627|

			 ENDP  ; |?OmapGpioPowerUp@@YAXPAX@Z|, OmapGpioPowerUp

	EXPORT	|?OmapGpioPowerDown@@YAXPAX@Z|		; OmapGpioPowerDown

  00000			 AREA	 |.pdata|, PDATA
|$T37636| DCD	|$LN5@OmapGpioPo@3|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioPowerDown@@YAXPAX@Z| PROC	; OmapGpioPowerDown

; 1250 : {

  00000		 |$LN5@OmapGpioPo@3|
  00000		 |$M37633|

; 1251 :     UNREFERENCED_PARAMETER(hContext);
; 1252 : }

  00000	e12fff1e	 bx          lr
  00004		 |$M37634|

			 ENDP  ; |?OmapGpioPowerDown@@YAXPAX@Z|, OmapGpioPowerDown

	IMPORT	|MmMapIoSpace|
	IMPORT	|GetAddressByDevice|
	IMPORT	|SOCGetGPIODeviceByBank|
	IMPORT	|OALLocalAlloc|
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T37661| DCD	|$LN24@OmapGpioIn|
	DCD	0x40005601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioInit@@YAHPBGPAPAXPAI@Z| PROC	; OmapGpioInit

; 227  : {

  00000		 |$LN24@OmapGpioIn|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M37658|
  00004	e1a07002	 mov         r7, r2
  00008	e1a08001	 mov         r8, r1

; 228  :     BOOL rc = FALSE;
; 229  :     OmapGpioDevice_t *pDevice = NULL;
; 230  :     PHYSICAL_ADDRESS pa;
; 231  :     DWORD size;
; 232  :     UINT8 i;
; 233  : 
; 234  : 	UNREFERENCED_PARAMETER(szContext);
; 235  : 
; 236  :     DEBUGMSG(ZONE_FUNCTION, (
; 237  :         L"+OmapGpioInit(%s)\r\n", szContext
; 238  :         ));
; 239  : 
; 240  :     // Create device structure
; 241  :     pDevice = (OmapGpioDevice_t *)LocalAlloc(LPTR, sizeof(OmapGpioDevice_t));

  0000c	e3a01010	 mov         r1, #0x10
  00010	e3a00040	 mov         r0, #0x40
  00014	e3a06000	 mov         r6, #0
  00018	eb000000	 bl          OALLocalAlloc
  0001c	e1b04000	 movs        r4, r0

; 242  :     if (pDevice == NULL)

  00020	0a000046	 beq         |$LN21@OmapGpioIn|

; 243  :     {
; 244  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioInit: "
; 245  :             L"Failed allocate GPIO driver structure\r\n"
; 246  :             ));
; 247  :         goto cleanUp;
; 248  :     }
; 249  :     memset(pDevice, 0, sizeof(OmapGpioDevice_t));

  00024	e3a02000	 mov         r2, #0

; 250  :     // Set cookie
; 251  :     pDevice->cookie = GPIO_DEVICE_COOKIE;

  00028	e59f3124	 ldr         r3, [pc, #0x124]
  0002c	e5842000	 str         r2, [r4]
  00030	e5842004	 str         r2, [r4, #4]
  00034	e5842008	 str         r2, [r4, #8]
  00038	e584200c	 str         r2, [r4, #0xC]

; 252  :     // Get the number of for this SOC
; 253  :     i=1;
; 254  :     while (SOCGetGPIODeviceByBank(i++) != OMAP_DEVICE_NONE)

  0003c	e3a00001	 mov         r0, #1
  00040	e5843000	 str         r3, [r4]
  00044	eb000000	 bl          SOCGetGPIODeviceByBank
  00048	e3700001	 cmn         r0, #1
  0004c	0a000009	 beq         |$LN18@OmapGpioIn|

; 257  :     }
; 258  :     // Allocate the bank structure
; 259  :     pDevice->bank = (OmapGpioBank_t*) LocalAlloc(LPTR,sizeof(OmapGpioBank_t)*pDevice->nbBanks);

  00050	e3a05001	 mov         r5, #1
  00054		 |$LL10@OmapGpioIn|

; 255  :     {
; 256  :         pDevice->nbBanks++;

  00054	e5942004	 ldr         r2, [r4, #4]
  00058	e2853001	 add         r3, r5, #1
  0005c	e20350ff	 and         r5, r3, #0xFF
  00060	e2823001	 add         r3, r2, #1
  00064	e1a00005	 mov         r0, r5
  00068	e5843004	 str         r3, [r4, #4]
  0006c	eb000000	 bl          SOCGetGPIODeviceByBank
  00070	e3700001	 cmn         r0, #1
  00074	1afffff6	 bne         |$LL10@OmapGpioIn|
  00078		 |$LN18@OmapGpioIn|

; 257  :     }
; 258  :     // Allocate the bank structure
; 259  :     pDevice->bank = (OmapGpioBank_t*) LocalAlloc(LPTR,sizeof(OmapGpioBank_t)*pDevice->nbBanks);

  00078	e5943004	 ldr         r3, [r4, #4]
  0007c	e3a00040	 mov         r0, #0x40
  00080	e1a01283	 mov         r1, r3, lsl #5
  00084	eb000000	 bl          OALLocalAlloc
  00088	e3500000	 cmp         r0, #0
  0008c	e584000c	 str         r0, [r4, #0xC]

; 260  :     if (pDevice->bank == NULL)

  00090	0a00002a	 beq         |$LN21@OmapGpioIn|

; 261  :     {
; 262  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioInit: "
; 263  :             L"Failed allocate GPIO driver bank structures\r\n"
; 264  :             ));
; 265  :         goto cleanUp;
; 266  :     }
; 267  :     memset(pDevice->bank, 0, sizeof(OmapGpioBank_t)*pDevice->nbBanks);

  00094	e5943004	 ldr         r3, [r4, #4]
  00098	e3a01000	 mov         r1, #0
  0009c	e1a02283	 mov         r2, r3, lsl #5
  000a0	eb000000	 bl          memset

; 268  : 
; 269  :     for (i = 0; i < pDevice->nbBanks; i++)

  000a4	e5943004	 ldr         r3, [r4, #4]
  000a8	e3a05000	 mov         r5, #0
  000ac	e3530000	 cmp         r3, #0
  000b0	9a00001b	 bls         |$LN4@OmapGpioIn|
  000b4	e3a02000	 mov         r2, #0
  000b8		 |$LL6@OmapGpioIn|

; 270  :     {
; 271  :         // Get device clock
; 272  :         pDevice->bank[i].DeviceID = SOCGetGPIODeviceByBank(i+1);

  000b8	e2829001	 add         r9, r2, #1
  000bc	e1a00009	 mov         r0, r9
  000c0	eb000000	 bl          SOCGetGPIODeviceByBank
  000c4	e594300c	 ldr         r3, [r4, #0xC]
  000c8	e0833285	 add         r3, r3, r5, lsl #5
  000cc	e583001c	 str         r0, [r3, #0x1C]

; 273  :         // Map GPIO registers  
; 274  :         pa.QuadPart = GetAddressByDevice(pDevice->bank[i].DeviceID);

  000d0	e594300c	 ldr         r3, [r4, #0xC]
  000d4	e0833285	 add         r3, r3, r5, lsl #5
  000d8	e593001c	 ldr         r0, [r3, #0x1C]
  000dc	eb000000	 bl          GetAddressByDevice

; 275  :         size = sizeof(OMAP_GPIO_REGS);
; 276  :         pDevice->bank[i].ppGpioRegs = (OMAP_GPIO_REGS*)MmMapIoSpace(pa, size, FALSE);

  000e0	e3a03000	 mov         r3, #0
  000e4	e3a020a0	 mov         r2, #0xA0
  000e8	e3a01000	 mov         r1, #0
  000ec	eb000000	 bl          MmMapIoSpace
  000f0	e594300c	 ldr         r3, [r4, #0xC]
  000f4	e0833285	 add         r3, r3, r5, lsl #5
  000f8	e5830018	 str         r0, [r3, #0x18]

; 277  :         if (pDevice->bank[i].ppGpioRegs == NULL)

  000fc	e594300c	 ldr         r3, [r4, #0xC]
  00100	e0833285	 add         r3, r3, r5, lsl #5
  00104	e5933018	 ldr         r3, [r3, #0x18]
  00108	e3530000	 cmp         r3, #0
  0010c	0a00000b	 beq         |$LN21@OmapGpioIn|
  00110	e5943004	 ldr         r3, [r4, #4]
  00114	e20950ff	 and         r5, r9, #0xFF
  00118	e1a02005	 mov         r2, r5
  0011c	e1550003	 cmp         r5, r3
  00120	3affffe4	 bcc         |$LL6@OmapGpioIn|
  00124		 |$LN4@OmapGpioIn|

; 278  :         {
; 279  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioInit: "
; 280  :                 L"Failed map GIO%d controller registers\r\n",i
; 281  :                 ));
; 282  :             goto cleanUp;
; 283  :         }
; 284  :     }
; 285  : 
; 286  :     // indicate gpio registers need to be saved for OFF mode
; 287  :     HalContextUpdateDirtyRegister(HAL_CONTEXTSAVE_GPIO);

  00124	e3a00001	 mov         r0, #1
  00128	eb000000	 bl          HalContextUpdateDirtyRegister

; 288  : 
; 289  :     // Return non-null value
; 290  :     rc = TRUE;
; 291  :     *phContext = (HANDLE)pDevice;

  0012c	e5884000	 str         r4, [r8]

; 292  :     *pGpioCount = pDevice->nbBanks;

  00130	e5943004	 ldr         r3, [r4, #4]
  00134	e3a06001	 mov         r6, #1
  00138		 |$cleanUp$37070|
  00138	e5873000	 str         r3, [r7]

; 293  : 
; 294  : cleanUp:
; 295  :     if (rc == FALSE) OmapGpioDeinit((HANDLE)pDevice);

  0013c	ea000001	 b           |$LN1@OmapGpioIn|
  00140		 |$LN21@OmapGpioIn|
  00140	e1a00004	 mov         r0, r4
  00144	eb000000	 bl          |?OmapGpioDeinit@@YAHPAX@Z|
  00148		 |$LN1@OmapGpioIn|

; 296  :     DEBUGMSG(ZONE_FUNCTION, (L"-OmapGpioInit()\r\n"));
; 297  :     return rc;
; 298  : }

  00148	e1a00006	 mov         r0, r6
  0014c	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00150	e12fff1e	 bx          lr
  00154		 |$LN25@OmapGpioIn|
  00154		 |$LN26@OmapGpioIn|
  00154	11223344	 DCD         0x11223344
  00158		 |$M37659|

			 ENDP  ; |?OmapGpioInit@@YAHPBGPAPAXPAI@Z|, OmapGpioInit

	END
