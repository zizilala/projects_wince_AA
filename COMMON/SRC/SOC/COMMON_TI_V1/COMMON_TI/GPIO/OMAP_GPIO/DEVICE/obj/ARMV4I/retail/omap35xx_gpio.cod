; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\GPIO\OMAP_GPIO\omap35xx_gpio.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|DEVICE_IFC_GPIO_GUID| [ DATA ]
	EXPORT	|dpCurSettings| [ DATA ]
	EXPORT	|Omap_Gpio| [ DATA ]

  00000			 AREA	 |.data|, DATA
|dpCurSettings| DCB "O", 0x0, "M", 0x0, "A", 0x0, "P", 0x0, " ", 0x0, "G", 0x0
	DCB	"P", 0x0, "I", 0x0, "O", 0x0, 0x0, 0x0
	%	44
	DCB	"E", 0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, "s", 0x0
	DCB	0x0, 0x0
	%	50
	DCB	"W", 0x0, "a", 0x0, "r", 0x0, "n", 0x0, "i", 0x0, "n", 0x0
	DCB	"g", 0x0, "s", 0x0, 0x0, 0x0
	%	46
	DCB	"F", 0x0, "u", 0x0, "n", 0x0, "c", 0x0, "t", 0x0, "i", 0x0
	DCB	"o", 0x0, "n", 0x0, 0x0, 0x0
	%	46
	DCB	"I", 0x0, "n", 0x0, "f", 0x0, "o", 0x0, 0x0, 0x0
	%	54
	DCB	"I", 0x0, "S", 0x0, "T", 0x0, 0x0, 0x0
	%	56
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCD	0x3
	%	4
|Omap_Gpio| DCD	0x0
	DCD	|?OmapGpioInit@@YAHPBGPAPAXPAI@Z|
	DCD	|?OmapGpioPostInit@@YAHPAX@Z|
	DCD	|?OmapGpioDeinit@@YAHPAX@Z|
	DCD	|?OmapGpioSetBit@@YAHPAXI@Z|
	DCD	|?OmapGpioClrBit@@YAHPAXI@Z|
	DCD	|?OmapGpioGetBit@@YAKPAXI@Z|
	DCD	|?OmapGpioSetMode@@YAHPAXII@Z|
	DCD	|?OmapGpioGetMode@@YAKPAXI@Z|
	DCD	|?OmapGpioPullup@@YAHPAXII@Z|
	DCD	|?OmapGpioPulldown@@YAHPAXII@Z|
	DCD	|?OmapGpioIoControl@@YAHPAXIPAEI1IPAK@Z|
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	%	8

  00000			 AREA	 |.rdata|, DATA, READONLY
|DEVICE_IFC_GPIO_GUID| DCD 0xa0272611
	DCW	0xdea0
	DCW	0x4678
	DCB	0xae
	DCB	0x62
	DCB	0x65
	DCB	0x61
	DCB	0x5b
	DCB	0x7d
	DCB	0x53
	DCB	0xaa
	EXPORT	|GetCurrentProcessId|
	IMPORT	|__GetUserKData|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T37652| DCD	|$LN5@GetCurrent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentProcessId| PROC

; 373  : _inline DWORD GetCurrentProcessId(void) {

  00000		 |$LN5@GetCurrent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37649|

; 374  :     return __GetUserKData (SYSHANDLE_OFFSET + (SH_CURPROC * sizeof(HANDLE)));

  00004	e3a0000c	 mov         r0, #0xC
  00008	eb000000	 bl          __GetUserKData

; 375  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M37650|

			 ENDP  ; |GetCurrentProcessId|

	EXPORT	|?IsEqualGUID@@YAHABU_GUID@@0@Z|	; IsEqualGUID
	IMPORT	|memcmp|
; File c:\wince600\public\common\sdk\inc\objbase.h

  00000			 AREA	 |.pdata|, PDATA
|$T37666| DCD	|$LN7@IsEqualGUI|
	DCD	0x40000901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsEqualGUID@@YAHABU_GUID@@0@Z| PROC	; IsEqualGUID

; 493  : {

  00000		 |$LN7@IsEqualGUI|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37663|

; 494  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00004	e3a02010	 mov         r2, #0x10
  00008	eb000000	 bl          memcmp
  0000c	e3500000	 cmp         r0, #0
  00010	03a00001	 moveq       r0, #1

; 495  : }

  00014	049de004	 ldreq       lr, [sp], #4

; 494  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00018	13a00000	 movne       r0, #0

; 495  : }

  0001c	149de004	 ldrne       lr, [sp], #4
  00020	e12fff1e	 bx          lr
  00024		 |$M37664|

			 ENDP  ; |?IsEqualGUID@@YAHABU_GUID@@0@Z|, IsEqualGUID

	IMPORT	|EnableDeviceClocks|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\gpio\omap_gpio\omap35xx_gpio.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T37685| DCD	|$LN16@SetGpioBan|
	DCD	0x40001c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetGpioBankPowerState@@YAXPAUOmapGpioDevice_t@@IW4_CEDEVICE_POWER_STATE@@@Z| PROC ; SetGpioBankPowerState

; 155  : {

  00000		 |$LN16@SetGpioBan|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37682|

; 156  :     // determine GPIO bank
; 157  :     UINT bit = GPIO_BIT(id);
; 158  :     UINT bank = GPIO_BANK(id);
; 159  :     UINT prevPowerState = pDevice->bank[bank].powerEnabled;

  00004	e590300c	 ldr         r3, [r0, #0xC]
  00008	e1a0e2a1	 mov         lr, r1, lsr #5

; 160  : 
; 161  :     if (state < D3)

  0000c	e3520003	 cmp         r2, #3
  00010	e793428e	 ldr         r4, [r3, +lr, lsl #5]

; 162  :     {
; 163  :         pDevice->bank[bank].powerEnabled |= bit;

  00014	e1a02003	 mov         r2, r3
  00018	e7b2328e	 ldr         r3, [r2, +lr, lsl #5]!
  0001c	e201101f	 and         r1, r1, #0x1F
  00020	b1833001	 orrlt       r3, r3, r1

; 164  :     }
; 165  :     else
; 166  :     {
; 167  :         pDevice->bank[bank].powerEnabled &= ~bit;

  00024	a1c33001	 bicge       r3, r3, r1
  00028	e5823000	 str         r3, [r2]

; 168  :     }
; 169  : 
; 170  :     // check if power needs to be enabled/disabled for the gpio bank
; 171  :     if (!prevPowerState != !pDevice->bank[bank].powerEnabled)

  0002c	e590200c	 ldr         r2, [r0, #0xC]
  00030	e3540000	 cmp         r4, #0
  00034	03a01001	 moveq       r1, #1
  00038	e7b2328e	 ldr         r3, [r2, +lr, lsl #5]!
  0003c	13a01000	 movne       r1, #0
  00040	e1b00003	 movs        r0, r3
  00044	03a03001	 moveq       r3, #1
  00048	13a03000	 movne       r3, #0
  0004c	e1510003	 cmp         r1, r3
  00050	0a000004	 beq         |$LN1@SetGpioBan|

; 172  :     {
; 173  :         if (pDevice->bank[bank].powerEnabled == 0)

  00054	e3500000	 cmp         r0, #0

; 174  :         {
; 175  :             EnableDeviceClocks(pDevice->bank[bank].DeviceID, FALSE);

  00058	e592001c	 ldr         r0, [r2, #0x1C]
  0005c	03a01000	 moveq       r1, #0

; 176  :         }
; 177  :         else
; 178  :         {
; 179  :             EnableDeviceClocks(pDevice->bank[bank].DeviceID, TRUE);

  00060	13a01001	 movne       r1, #1
  00064	eb000000	 bl          EnableDeviceClocks
  00068		 |$LN1@SetGpioBan|

; 180  :         }
; 181  :     }
; 182  : }

  00068	e8bd4010	 ldmia       sp!, {r4, lr}
  0006c	e12fff1e	 bx          lr
  00070		 |$M37683|

			 ENDP  ; |?SetGpioBankPowerState@@YAXPAUOmapGpioDevice_t@@IW4_CEDEVICE_POWER_STATE@@@Z|, SetGpioBankPowerState

	EXPORT	|?InternalSetGpioBankPowerState@@YAXPAUOmapGpioDevice_t@@IW4_CEDEVICE_POWER_STATE@@@Z| ; InternalSetGpioBankPowerState

  00000			 AREA	 |.pdata|, PDATA
|$T37697| DCD	|$LN9@InternalSe|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InternalSetGpioBankPowerState@@YAXPAUOmapGpioDevice_t@@IW4_CEDEVICE_POWER_STATE@@@Z| PROC ; InternalSetGpioBankPowerState

; 197  : {

  00000		 |$LN9@InternalSe|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37694|

; 198  :     // determine GPIO bank
; 199  :     UINT bank = GPIO_BANK(id);
; 200  : 
; 201  :     // check if power is enabled by client
; 202  :     if (pDevice->bank[bank].powerEnabled != 0) return;

  00004	e590000c	 ldr         r0, [r0, #0xC]
  00008	e1a032a1	 mov         r3, r1, lsr #5
  0000c	e7b03283	 ldr         r3, [r0, +r3, lsl #5]!
  00010	e3530000	 cmp         r3, #0
  00014	1a000004	 bne         |$LN1@InternalSe|

; 203  : 
; 204  :     if (state < D3)
; 205  :     {
; 206  :         EnableDeviceClocks( pDevice->bank[bank].DeviceID, TRUE );

  00018	e590001c	 ldr         r0, [r0, #0x1C]
  0001c	e3520003	 cmp         r2, #3
  00020	b3a01001	 movlt       r1, #1

; 207  :     }
; 208  :     else
; 209  :     {
; 210  : 		EnableDeviceClocks( pDevice->bank[bank].DeviceID, FALSE );

  00024	a3a01000	 movge       r1, #0
  00028	eb000000	 bl          EnableDeviceClocks
  0002c		 |$LN1@InternalSe|

; 211  :     }
; 212  : }

  0002c	e49de004	 ldr         lr, [sp], #4
  00030	e12fff1e	 bx          lr
  00034		 |$M37695|

			 ENDP  ; |?InternalSetGpioBankPowerState@@YAXPAUOmapGpioDevice_t@@IW4_CEDEVICE_POWER_STATE@@@Z|, InternalSetGpioBankPowerState

	IMPORT	|InitializeCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T37710| DCD	|$LN10@OmapGpioPo|
	DCD	0x40001601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioPostInit@@YAHPAX@Z| PROC	; OmapGpioPostInit

; 306  : {

  00000		 |$LN10@OmapGpioPo|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37707|
  00004	e1a04000	 mov         r4, r0

; 307  :     UINT8 i;
; 308  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)hContext;
; 309  : 
; 310  :     // Initialize critical sections
; 311  :     for (i = 0; i < pDevice->nbBanks; i++)

  00008	e5943004	 ldr         r3, [r4, #4]
  0000c	e3a01000	 mov         r1, #0
  00010	e3530000	 cmp         r3, #0
  00014	9a00000a	 bls         |$LN1@OmapGpioPo|
  00018	e3a05000	 mov         r5, #0
  0001c		 |$LL3@OmapGpioPo|

; 312  :     {
; 313  :         InitializeCriticalSection(&pDevice->bank[i].pCs);

  0001c	e594300c	 ldr         r3, [r4, #0xC]
  00020	e0833281	 add         r3, r3, r1, lsl #5
  00024	e2830004	 add         r0, r3, #4
  00028	eb000000	 bl          InitializeCriticalSection
  0002c	e5942004	 ldr         r2, [r4, #4]
  00030	e2853001	 add         r3, r5, #1
  00034	e20310ff	 and         r1, r3, #0xFF
  00038	e1a05001	 mov         r5, r1
  0003c	e1510002	 cmp         r1, r2
  00040	3afffff5	 bcc         |$LL3@OmapGpioPo|
  00044		 |$LN1@OmapGpioPo|

; 314  :     }
; 315  :     pDevice->fPostInit = TRUE;

  00044	e3a03001	 mov         r3, #1
  00048	e5843008	 str         r3, [r4, #8]

; 316  :     return TRUE;

  0004c	e3a00001	 mov         r0, #1

; 317  : }

  00050	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M37708|

			 ENDP  ; |?OmapGpioPostInit@@YAHPAX@Z|, OmapGpioPostInit

	IMPORT	|LocalFree|
	IMPORT	|MmUnmapIoSpace|
	IMPORT	|DeleteCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T37727| DCD	|$LN20@OmapGpioDe|
	DCD	0x40003401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioDeinit@@YAHPAX@Z| PROC	; OmapGpioDeinit

; 328  : {

  00000		 |$LN20@OmapGpioDe|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37724|
  00004	e1b04000	 movs        r4, r0

; 329  :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 330  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)context;
; 331  :     UINT8 i = 0;
; 332  : 
; 333  :     DEBUGMSG(ZONE_FUNCTION, (L"+OmapGpioDeinit(0x%08x)\r\n", context));
; 334  : 
; 335  :     // Check if we get correct context
; 336  :     if ((pDevice == NULL) || (pDevice->cookie != GPIO_DEVICE_COOKIE))

  0000c	0a00002c	 beq         |$cleanUp$37124|
  00010	e5942000	 ldr         r2, [r4]
  00014	e59f30b0	 ldr         r3, [pc, #0xB0]
  00018	e1520003	 cmp         r2, r3
  0001c	1a000028	 bne         |$cleanUp$37124|

; 337  :     {
; 338  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: OmapGpioDeinit: "
; 339  :             L"Incorrect context parameter\r\n"
; 340  :             ));
; 341  :         goto cleanUp;
; 342  :     }
; 343  : 
; 344  :     // Delete critical sections
; 345  :     if (pDevice->fPostInit)

  00020	e5943008	 ldr         r3, [r4, #8]
  00024	e3530000	 cmp         r3, #0
  00028	0a00000e	 beq         |$LN5@OmapGpioDe|

; 346  :     {
; 347  :         for (i = 0; i < pDevice->nbBanks; i++)

  0002c	e5943004	 ldr         r3, [r4, #4]
  00030	e3a01000	 mov         r1, #0
  00034	e3530000	 cmp         r3, #0
  00038	9a00000a	 bls         |$LN5@OmapGpioDe|
  0003c	e3a05000	 mov         r5, #0
  00040		 |$LL7@OmapGpioDe|

; 348  :             DeleteCriticalSection(&pDevice->bank[i].pCs);

  00040	e594300c	 ldr         r3, [r4, #0xC]
  00044	e0833281	 add         r3, r3, r1, lsl #5
  00048	e2830004	 add         r0, r3, #4
  0004c	eb000000	 bl          DeleteCriticalSection
  00050	e5942004	 ldr         r2, [r4, #4]
  00054	e2853001	 add         r3, r5, #1
  00058	e20310ff	 and         r1, r3, #0xFF
  0005c	e1a05001	 mov         r5, r1
  00060	e1510002	 cmp         r1, r2
  00064	3afffff5	 bcc         |$LL7@OmapGpioDe|
  00068		 |$LN5@OmapGpioDe|

; 349  :     }
; 350  :     // Unmap module registers
; 351  :     for (i = 0 ; i < pDevice->nbBanks; i++)

  00068	e5943004	 ldr         r3, [r4, #4]
  0006c	e3a01000	 mov         r1, #0
  00070	e3530000	 cmp         r3, #0
  00074	9a00000d	 bls         |$LN2@OmapGpioDe|
  00078	e3a05000	 mov         r5, #0
  0007c		 |$LL4@OmapGpioDe|

; 352  :     {
; 353  :         if (pDevice->bank[i].ppGpioRegs != NULL)

  0007c	e594300c	 ldr         r3, [r4, #0xC]
  00080	e0833281	 add         r3, r3, r1, lsl #5
  00084	e5933018	 ldr         r3, [r3, #0x18]
  00088	e3530000	 cmp         r3, #0

; 354  :         {
; 355  :             DWORD size = sizeof(OMAP_GPIO_REGS);
; 356  :             MmUnmapIoSpace((VOID*)pDevice->bank[i].ppGpioRegs, size);

  0008c	13a010a0	 movne       r1, #0xA0
  00090	11a00003	 movne       r0, r3
  00094	1b000000	 blne        MmUnmapIoSpace
  00098	e5942004	 ldr         r2, [r4, #4]
  0009c	e2853001	 add         r3, r5, #1
  000a0	e20310ff	 and         r1, r3, #0xFF
  000a4	e1a05001	 mov         r5, r1
  000a8	e1510002	 cmp         r1, r2
  000ac	3afffff2	 bcc         |$LL4@OmapGpioDe|
  000b0		 |$LN2@OmapGpioDe|

; 357  :         }
; 358  :     }
; 359  :     // Free banks structures    
; 360  :     LocalFree(pDevice->bank);

  000b0	e594000c	 ldr         r0, [r4, #0xC]
  000b4	eb000000	 bl          LocalFree

; 361  : 
; 362  :     // Free device structure
; 363  :     LocalFree(pDevice);

  000b8	e1a00004	 mov         r0, r4
  000bc	eb000000	 bl          LocalFree

; 364  : 
; 365  :     // Done
; 366  :     rc = TRUE;

  000c0	e3a00001	 mov         r0, #1
  000c4		 |$cleanUp$37124|

; 367  : 
; 368  : cleanUp:
; 369  :     DEBUGMSG(ZONE_FUNCTION, (L"-OmapGpioDeinit()\r\n"));
; 370  :     return rc;
; 371  : }

  000c4	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000c8	e12fff1e	 bx          lr
  000cc		 |$LN21@OmapGpioDe|
  000cc		 |$LN22@OmapGpioDe|
  000cc	11223344	 DCD         0x11223344
  000d0		 |$M37725|

			 ENDP  ; |?OmapGpioDeinit@@YAHPAX@Z|, OmapGpioDeinit

	IMPORT	|HalContextUpdateDirtyRegister|
	IMPORT	|LeaveCriticalSection|
	IMPORT	|EnterCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T37768| DCD	|$LN39@OmapGpioSe|
	DCD	0x40004a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioSetMode@@YAHPAXII@Z| PROC	; OmapGpioSetMode

; 384  : {

  00000		 |$LN39@OmapGpioSe|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M37765|
  00004	e1a06002	 mov         r6, r2
  00008	e1b07000	 movs        r7, r0

; 385  :     BOOL rc = FALSE;

  0000c	e3a00000	 mov         r0, #0

; 386  :     UINT bit = GPIO_BIT(id);
; 387  :     UINT bank = GPIO_BANK(id);

  00010	e1a092a1	 mov         r9, r1, lsr #5

; 388  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)context;
; 389  : 
; 390  :     // Check if we get correct context
; 391  :     if ((pDevice == NULL) || (pDevice->cookie != GPIO_DEVICE_COOKIE))

  00014	0a000040	 beq         |$cleanUp$37151|
  00018	e597e000	 ldr         lr, [r7]
  0001c	e59f3100	 ldr         r3, [pc, #0x100]
  00020	e15e0003	 cmp         lr, r3
  00024	1a00003c	 bne         |$cleanUp$37151|

; 392  :     {
; 393  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioSetMode: "
; 394  :             L"Incorrect context\r\n"
; 395  :             ));
; 396  :         goto cleanUp;
; 397  :     }
; 398  : 
; 399  :     if (id < pDevice->nbBanks*32)

  00028	e5973004	 ldr         r3, [r7, #4]
  0002c	e1510283	 cmp         r1, r3, lsl #5
  00030	2a000039	 bcs         |$cleanUp$37151|

; 400  :     {
; 401  :         UINT32 mask = 1 << (bit);
; 402  :         CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;

  00034	e597300c	 ldr         r3, [r7, #0xC]

; 403  :         OMAP_GPIO_REGS *pGpio = pDevice->bank[bank].ppGpioRegs;
; 404  : 
; 405  :         if (pDevice->fPostInit) EnterCriticalSection(pCs);

  00038	e597e008	 ldr         lr, [r7, #8]
  0003c	e201501f	 and         r5, r1, #0x1F
  00040	e0838289	 add         r8, r3, r9, lsl #5
  00044	e35e0000	 cmp         lr, #0
  00048	e5984018	 ldr         r4, [r8, #0x18]
  0004c	12880004	 addne       r0, r8, #4
  00050	e3a0a001	 mov         r10, #1
  00054	1b000000	 blne        EnterCriticalSection

; 406  :         InternalSetGpioBankPowerState(pDevice, id, D0);

  00058	e597200c	 ldr         r2, [r7, #0xC]
  0005c	e7b23289	 ldr         r3, [r2, +r9, lsl #5]!
  00060	e3530000	 cmp         r3, #0
  00064	0592001c	 ldreq       r0, [r2, #0x1C]
  00068	03a01001	 moveq       r1, #1
  0006c	0b000000	 bleq        EnableDeviceClocks

; 407  : 
; 408  :         // set gpio direction
; 409  :         if ((mode & GPIO_DIR_INPUT) != 0)
; 410  :         {
; 411  :             SETREG32(&pGpio->OE, mask);

  00070	e5943034	 ldr         r3, [r4, #0x34]
  00074	e3160001	 tst         r6, #1
  00078	1183351a	 orrne       r3, r3, r10, lsl r5

; 412  :         }
; 413  :         else
; 414  :         {
; 415  :             CLRREG32(&pGpio->OE, mask);

  0007c	01c3351a	 biceq       r3, r3, r10, lsl r5

; 416  :         }
; 417  : 
; 418  :         // set debounce mode
; 419  :         if ((mode & GPIO_DEBOUNCE_ENABLE) != 0)

  00080	e3160020	 tst         r6, #0x20
  00084	e5843034	 str         r3, [r4, #0x34]

; 420  :         {
; 421  :             SETREG32(&pGpio->DEBOUNCENABLE, mask);

  00088	e5943050	 ldr         r3, [r4, #0x50]
  0008c	1183351a	 orrne       r3, r3, r10, lsl r5

; 422  :         }
; 423  :         else
; 424  :         {
; 425  :             CLRREG32(&pGpio->DEBOUNCENABLE, mask);

  00090	01c3351a	 biceq       r3, r3, r10, lsl r5

; 426  :         }
; 427  : 
; 428  :         // set edge/level detect mode
; 429  :         if ((mode & GPIO_INT_LOW) != 0)

  00094	e3160008	 tst         r6, #8
  00098	e5843050	 str         r3, [r4, #0x50]

; 430  :         {
; 431  :             SETREG32(&pGpio->LEVELDETECT0, mask);

  0009c	e5943040	 ldr         r3, [r4, #0x40]
  000a0	1183351a	 orrne       r3, r3, r10, lsl r5

; 432  :         }
; 433  :         else
; 434  :         {
; 435  :             CLRREG32(&pGpio->LEVELDETECT0, mask);

  000a4	01c3351a	 biceq       r3, r3, r10, lsl r5

; 436  :         }
; 437  : 
; 438  :         if ((mode & GPIO_INT_HIGH) != 0)

  000a8	e3160010	 tst         r6, #0x10
  000ac	e5843040	 str         r3, [r4, #0x40]

; 439  :         {
; 440  :             SETREG32(&pGpio->LEVELDETECT1, mask);

  000b0	e5943044	 ldr         r3, [r4, #0x44]
  000b4	1183351a	 orrne       r3, r3, r10, lsl r5

; 441  :         }
; 442  :         else
; 443  :         {
; 444  :             CLRREG32(&pGpio->LEVELDETECT1, mask);

  000b8	01c3351a	 biceq       r3, r3, r10, lsl r5

; 445  :         }
; 446  : 
; 447  :         if ((mode & GPIO_INT_LOW_HIGH) != 0)

  000bc	e3160002	 tst         r6, #2
  000c0	e5843044	 str         r3, [r4, #0x44]

; 448  :         {
; 449  :             SETREG32(&pGpio->RISINGDETECT, mask);

  000c4	e5943048	 ldr         r3, [r4, #0x48]
  000c8	1183351a	 orrne       r3, r3, r10, lsl r5

; 450  :         }
; 451  :         else
; 452  :         {
; 453  :             CLRREG32(&pGpio->RISINGDETECT, mask);

  000cc	01c3351a	 biceq       r3, r3, r10, lsl r5

; 454  :         }
; 455  : 
; 456  :         if ((mode & GPIO_INT_HIGH_LOW) != 0)

  000d0	e3160004	 tst         r6, #4
  000d4	e5843048	 str         r3, [r4, #0x48]

; 457  :         {
; 458  :             SETREG32(&pGpio->FALLINGDETECT, mask);

  000d8	e594304c	 ldr         r3, [r4, #0x4C]
  000dc	1183351a	 orrne       r3, r3, r10, lsl r5

; 459  :         }
; 460  :         else
; 461  :         {
; 462  :             CLRREG32(&pGpio->FALLINGDETECT, mask);

  000e0	01c3351a	 biceq       r3, r3, r10, lsl r5
  000e4	e584304c	 str         r3, [r4, #0x4C]

; 463  :         }
; 464  : 
; 465  :         InternalSetGpioBankPowerState(pDevice, id, D4);

  000e8	e597200c	 ldr         r2, [r7, #0xC]
  000ec	e7b23289	 ldr         r3, [r2, +r9, lsl #5]!
  000f0	e3530000	 cmp         r3, #0
  000f4	0592001c	 ldreq       r0, [r2, #0x1C]
  000f8	03a01000	 moveq       r1, #0
  000fc	0b000000	 bleq        EnableDeviceClocks

; 466  :         if (pDevice->fPostInit)LeaveCriticalSection(pCs);

  00100	e5973008	 ldr         r3, [r7, #8]
  00104	e3530000	 cmp         r3, #0
  00108	12880004	 addne       r0, r8, #4
  0010c	1b000000	 blne        LeaveCriticalSection

; 467  : 
; 468  :         // indicate gpio registers need to be saved for OFF mode
; 469  :         HalContextUpdateDirtyRegister(HAL_CONTEXTSAVE_GPIO);

  00110	e3a00001	 mov         r0, #1
  00114	eb000000	 bl          HalContextUpdateDirtyRegister

; 470  : 
; 471  :         rc = TRUE;

  00118	e3a00001	 mov         r0, #1
  0011c		 |$cleanUp$37151|

; 472  :     }
; 473  : 
; 474  : cleanUp:
; 475  :     return rc;
; 476  : }

  0011c	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00120	e12fff1e	 bx          lr
  00124		 |$LN40@OmapGpioSe|
  00124		 |$LN41@OmapGpioSe|
  00124	11223344	 DCD         0x11223344
  00128		 |$M37766|

			 ENDP  ; |?OmapGpioSetMode@@YAHPAXII@Z|, OmapGpioSetMode


  00000			 AREA	 |.pdata|, PDATA
|$T37802| DCD	|$LN28@OmapGpioGe|
	DCD	0x40003d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioGetMode@@YAKPAXI@Z| PROC	; OmapGpioGetMode

; 487  : {

  00000		 |$LN28@OmapGpioGe|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M37799|
  00004	e1b05000	 movs        r5, r0

; 488  :     DWORD mode = (DWORD) -1;

  00008	e3e04000	 mvn         r4, #0

; 489  :     UINT bit = GPIO_BIT(id);
; 490  :     UINT bank = GPIO_BANK(id);

  0000c	e1a082a1	 mov         r8, r1, lsr #5

; 491  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)context;
; 492  : 
; 493  :     // Check if we get correct context
; 494  :     if ((pDevice == NULL) || (pDevice->cookie != GPIO_DEVICE_COOKIE))

  00010	0a000033	 beq         |$cleanUp$37220|
  00014	e5952000	 ldr         r2, [r5]
  00018	e59f30d0	 ldr         r3, [pc, #0xD0]
  0001c	e1520003	 cmp         r2, r3
  00020	1a00002f	 bne         |$cleanUp$37220|

; 495  :     {
; 496  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioGetMode: "
; 497  :             L"Incorrect context\r\n"
; 498  :             ));
; 499  :         goto cleanUp;
; 500  :     }
; 501  : 
; 502  :     if (id < pDevice->nbBanks*32)

  00024	e5953004	 ldr         r3, [r5, #4]
  00028	e1510283	 cmp         r1, r3, lsl #5
  0002c	2a00002c	 bcs         |$cleanUp$37220|

; 503  :     {
; 504  :         mode = 0;
; 505  :         OMAP_GPIO_REGS *pGpio = pDevice->bank[bank].ppGpioRegs;

  00030	e595300c	 ldr         r3, [r5, #0xC]

; 506  :         UINT32 mask = 1 << (bit);
; 507  :         CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;
; 508  : 
; 509  :         if (pDevice->fPostInit) EnterCriticalSection(pCs);

  00034	e595e008	 ldr         lr, [r5, #8]
  00038	e201201f	 and         r2, r1, #0x1F
  0003c	e0839288	 add         r9, r3, r8, lsl #5
  00040	e35e0000	 cmp         lr, #0
  00044	e3a03001	 mov         r3, #1
  00048	e5996018	 ldr         r6, [r9, #0x18]
  0004c	12890004	 addne       r0, r9, #4
  00050	e1a07213	 mov         r7, r3, lsl r2
  00054	e3a04000	 mov         r4, #0
  00058	1b000000	 blne        EnterCriticalSection

; 510  :         InternalSetGpioBankPowerState(pDevice, id, D0);

  0005c	e595200c	 ldr         r2, [r5, #0xC]
  00060	e7b23288	 ldr         r3, [r2, +r8, lsl #5]!
  00064	e3530000	 cmp         r3, #0
  00068	0592001c	 ldreq       r0, [r2, #0x1C]
  0006c	03a01001	 moveq       r1, #1
  00070	0b000000	 bleq        EnableDeviceClocks

; 511  : 
; 512  :         // get edge mode
; 513  :         if ((INREG32(&pGpio->OE) & mask) != 0)

  00074	e5963034	 ldr         r3, [r6, #0x34]

; 514  :         {
; 515  :             mode |= GPIO_DIR_INPUT;
; 516  :         }
; 517  :         else
; 518  :         {
; 519  :             mode |= GPIO_DIR_OUTPUT;
; 520  :         }
; 521  : 
; 522  :         // get debounce mode
; 523  :         if ((INREG32(&pGpio->DEBOUNCENABLE) & mask) != 0)
; 524  :         {
; 525  :             mode |= GPIO_DEBOUNCE_ENABLE;
; 526  :         }
; 527  : 
; 528  :         // get edge/level detect mode
; 529  :         if ((INREG32(&pGpio->LEVELDETECT0) & mask) != 0)
; 530  :         {
; 531  :             mode |= GPIO_INT_LOW;
; 532  :         }
; 533  : 
; 534  :         if ((INREG32(&pGpio->LEVELDETECT1) & mask) != 0)
; 535  :         {
; 536  :             mode |= GPIO_INT_HIGH;
; 537  :         }
; 538  : 
; 539  :         if ((INREG32(&pGpio->RISINGDETECT) & mask) != 0)
; 540  :         {
; 541  :             mode |= GPIO_INT_LOW_HIGH;
; 542  :         }
; 543  : 
; 544  :         if ((INREG32(&pGpio->FALLINGDETECT) & mask) != 0)
; 545  :         {
; 546  :             mode |= GPIO_INT_HIGH_LOW;
; 547  :         }
; 548  : 
; 549  :         InternalSetGpioBankPowerState(pDevice, id, D4);

  00078	e595200c	 ldr         r2, [r5, #0xC]
  0007c	e1130007	 tst         r3, r7
  00080	e5963050	 ldr         r3, [r6, #0x50]
  00084	13a04001	 movne       r4, #1
  00088	e1130007	 tst         r3, r7
  0008c	e5963040	 ldr         r3, [r6, #0x40]
  00090	13844020	 orrne       r4, r4, #0x20
  00094	e1130007	 tst         r3, r7
  00098	e5963044	 ldr         r3, [r6, #0x44]
  0009c	13844008	 orrne       r4, r4, #8
  000a0	e1130007	 tst         r3, r7
  000a4	e5963048	 ldr         r3, [r6, #0x48]
  000a8	13844010	 orrne       r4, r4, #0x10
  000ac	e1130007	 tst         r3, r7
  000b0	e596304c	 ldr         r3, [r6, #0x4C]
  000b4	13844002	 orrne       r4, r4, #2
  000b8	e1130007	 tst         r3, r7
  000bc	e7b23288	 ldr         r3, [r2, +r8, lsl #5]!
  000c0	13844004	 orrne       r4, r4, #4
  000c4	e3530000	 cmp         r3, #0
  000c8	0592001c	 ldreq       r0, [r2, #0x1C]
  000cc	03a01000	 moveq       r1, #0
  000d0	0b000000	 bleq        EnableDeviceClocks

; 550  :         if (pDevice->fPostInit) LeaveCriticalSection(pCs);

  000d4	e5953008	 ldr         r3, [r5, #8]
  000d8	e3530000	 cmp         r3, #0
  000dc	12890004	 addne       r0, r9, #4
  000e0	1b000000	 blne        LeaveCriticalSection
  000e4		 |$cleanUp$37220|

; 551  : 
; 552  :     }
; 553  : 
; 554  : cleanUp:
; 555  :     return mode;
; 556  : }

  000e4	e1a00004	 mov         r0, r4
  000e8	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000ec	e12fff1e	 bx          lr
  000f0		 |$LN29@OmapGpioGe|
  000f0		 |$LN30@OmapGpioGe|
  000f0	11223344	 DCD         0x11223344
  000f4		 |$M37800|

			 ENDP  ; |?OmapGpioGetMode@@YAKPAXI@Z|, OmapGpioGetMode


  00000			 AREA	 |.pdata|, PDATA
|$T37813| DCD	|$LN5@OmapGpioPu|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioPullup@@YAHPAXII@Z| PROC	; OmapGpioPullup

; 571  : {

  00000		 |$LN5@OmapGpioPu|
  00000		 |$M37810|

; 572  :     UNREFERENCED_PARAMETER(context);
; 573  :     UNREFERENCED_PARAMETER(id);
; 574  :     UNREFERENCED_PARAMETER(enable);
; 575  :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 576  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M37811|

			 ENDP  ; |?OmapGpioPullup@@YAHPAXII@Z|, OmapGpioPullup


  00000			 AREA	 |.pdata|, PDATA
|$T37822| DCD	|$LN5@OmapGpioPu@2|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioPulldown@@YAHPAXII@Z| PROC	; OmapGpioPulldown

; 589  : {

  00000		 |$LN5@OmapGpioPu@2|
  00000		 |$M37819|

; 590  :     UNREFERENCED_PARAMETER(context);
; 591  :     UNREFERENCED_PARAMETER(id);
; 592  :     UNREFERENCED_PARAMETER(enable);
; 593  :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 594  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M37820|

			 ENDP  ; |?OmapGpioPulldown@@YAHPAXII@Z|, OmapGpioPulldown


  00000			 AREA	 |.pdata|, PDATA
|$T37854| DCD	|$LN21@OmapGpioSe@2|
	DCD	0x40002e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioSetBit@@YAHPAXI@Z| PROC	; OmapGpioSetBit

; 716  : {

  00000		 |$LN21@OmapGpioSe@2|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M37851|
  00004	e1b04000	 movs        r4, r0

; 717  :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 718  :     UINT bit = GPIO_BIT(id);

  0000c	e201801f	 and         r8, r1, #0x1F

; 719  :     UINT bank = GPIO_BANK(id);

  00010	e1a062a1	 mov         r6, r1, lsr #5

; 720  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)context;
; 721  :     // Check if we get correct context & pin id
; 722  :     if ((pDevice == NULL) || (pDevice->cookie != GPIO_DEVICE_COOKIE))

  00014	0a000024	 beq         |$cleanUp$37263|
  00018	e5942000	 ldr         r2, [r4]
  0001c	e59f3090	 ldr         r3, [pc, #0x90]
  00020	e1520003	 cmp         r2, r3
  00024	1a000020	 bne         |$cleanUp$37263|

; 723  :     {
; 724  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioSetBit: Incorrect context\r\n"));
; 725  :         goto cleanUp;
; 726  :     }
; 727  : 
; 728  :     if (id < pDevice->nbBanks*32)

  00028	e5943004	 ldr         r3, [r4, #4]
  0002c	e1510283	 cmp         r1, r3, lsl #5
  00030	2a00001d	 bcs         |$cleanUp$37263|

; 729  :     {
; 730  :         volatile UINT *p = &pDevice->bank[bank].ppGpioRegs->DATAOUT;

  00034	e594300c	 ldr         r3, [r4, #0xC]

; 731  :         CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;
; 732  : 
; 733  :         if (pDevice->fPostInit) EnterCriticalSection(pCs);

  00038	e5942008	 ldr         r2, [r4, #8]
  0003c	e0835286	 add         r5, r3, r6, lsl #5
  00040	e3520000	 cmp         r2, #0
  00044	e5957018	 ldr         r7, [r5, #0x18]
  00048	12850004	 addne       r0, r5, #4
  0004c	1b000000	 blne        EnterCriticalSection

; 734  :         InternalSetGpioBankPowerState(pDevice, id, D0);

  00050	e594200c	 ldr         r2, [r4, #0xC]
  00054	e7b23286	 ldr         r3, [r2, +r6, lsl #5]!
  00058	e3530000	 cmp         r3, #0
  0005c	0592001c	 ldreq       r0, [r2, #0x1C]
  00060	03a01001	 moveq       r1, #1
  00064	0b000000	 bleq        EnableDeviceClocks

; 735  :         SETREG32(p, 1 << (bit));

  00068	e597303c	 ldr         r3, [r7, #0x3C]
  0006c	e3a02001	 mov         r2, #1
  00070	e1833812	 orr         r3, r3, r2, lsl r8
  00074	e587303c	 str         r3, [r7, #0x3C]

; 736  :         InternalSetGpioBankPowerState(pDevice, id, D4);

  00078	e594200c	 ldr         r2, [r4, #0xC]
  0007c	e7b23286	 ldr         r3, [r2, +r6, lsl #5]!
  00080	e3530000	 cmp         r3, #0
  00084	0592001c	 ldreq       r0, [r2, #0x1C]
  00088	03a01000	 moveq       r1, #0
  0008c	0b000000	 bleq        EnableDeviceClocks

; 737  :         if (pDevice->fPostInit) LeaveCriticalSection(pCs);

  00090	e5943008	 ldr         r3, [r4, #8]
  00094	e3530000	 cmp         r3, #0
  00098	12850004	 addne       r0, r5, #4
  0009c	1b000000	 blne        LeaveCriticalSection

; 738  : 
; 739  :         // indicate gpio registers need to be saved for OFF mode
; 740  :         HalContextUpdateDirtyRegister(HAL_CONTEXTSAVE_GPIO);

  000a0	e3a00001	 mov         r0, #1
  000a4	eb000000	 bl          HalContextUpdateDirtyRegister

; 741  : 
; 742  :         rc = TRUE;

  000a8	e3a00001	 mov         r0, #1
  000ac		 |$cleanUp$37263|

; 743  :     }
; 744  : 
; 745  : cleanUp:
; 746  :     return rc;
; 747  : }

  000ac	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000b0	e12fff1e	 bx          lr
  000b4		 |$LN22@OmapGpioSe@2|
  000b4		 |$LN23@OmapGpioSe@2|
  000b4	11223344	 DCD         0x11223344
  000b8		 |$M37852|

			 ENDP  ; |?OmapGpioSetBit@@YAHPAXI@Z|, OmapGpioSetBit


  00000			 AREA	 |.pdata|, PDATA
|$T37888| DCD	|$LN21@OmapGpioCl|
	DCD	0x40002e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioClrBit@@YAHPAXI@Z| PROC	; OmapGpioClrBit

; 758  : {

  00000		 |$LN21@OmapGpioCl|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M37885|
  00004	e1b04000	 movs        r4, r0

; 759  :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 760  :     UINT bit = GPIO_BIT(id);

  0000c	e201801f	 and         r8, r1, #0x1F

; 761  :     UINT bank = GPIO_BANK(id);

  00010	e1a062a1	 mov         r6, r1, lsr #5

; 762  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)context;
; 763  :     // Check if we get correct context & pin id
; 764  :     if ((pDevice == NULL) || (pDevice->cookie != GPIO_DEVICE_COOKIE))

  00014	0a000024	 beq         |$cleanUp$37285|
  00018	e5942000	 ldr         r2, [r4]
  0001c	e59f3090	 ldr         r3, [pc, #0x90]
  00020	e1520003	 cmp         r2, r3
  00024	1a000020	 bne         |$cleanUp$37285|

; 765  :     {
; 766  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioClrBit: Incorrect context\r\n"));
; 767  :         goto cleanUp;
; 768  :     }
; 769  :     if (id < pDevice->nbBanks*32)

  00028	e5943004	 ldr         r3, [r4, #4]
  0002c	e1510283	 cmp         r1, r3, lsl #5
  00030	2a00001d	 bcs         |$cleanUp$37285|

; 770  :     {
; 771  :         volatile UINT *p = &pDevice->bank[bank].ppGpioRegs->DATAOUT;

  00034	e594300c	 ldr         r3, [r4, #0xC]

; 772  :         CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;
; 773  : 
; 774  :         if (pDevice->fPostInit) EnterCriticalSection(pCs);

  00038	e5942008	 ldr         r2, [r4, #8]
  0003c	e0835286	 add         r5, r3, r6, lsl #5
  00040	e3520000	 cmp         r2, #0
  00044	e5957018	 ldr         r7, [r5, #0x18]
  00048	12850004	 addne       r0, r5, #4
  0004c	1b000000	 blne        EnterCriticalSection

; 775  :         InternalSetGpioBankPowerState(pDevice, id, D0);

  00050	e594200c	 ldr         r2, [r4, #0xC]
  00054	e7b23286	 ldr         r3, [r2, +r6, lsl #5]!
  00058	e3530000	 cmp         r3, #0
  0005c	0592001c	 ldreq       r0, [r2, #0x1C]
  00060	03a01001	 moveq       r1, #1
  00064	0b000000	 bleq        EnableDeviceClocks

; 776  :         CLRREG32(p, 1 << (bit));

  00068	e597303c	 ldr         r3, [r7, #0x3C]
  0006c	e3a02001	 mov         r2, #1
  00070	e1c33812	 bic         r3, r3, r2, lsl r8
  00074	e587303c	 str         r3, [r7, #0x3C]

; 777  :         InternalSetGpioBankPowerState(pDevice, id, D4);

  00078	e594200c	 ldr         r2, [r4, #0xC]
  0007c	e7b23286	 ldr         r3, [r2, +r6, lsl #5]!
  00080	e3530000	 cmp         r3, #0
  00084	0592001c	 ldreq       r0, [r2, #0x1C]
  00088	03a01000	 moveq       r1, #0
  0008c	0b000000	 bleq        EnableDeviceClocks

; 778  :         if (pDevice->fPostInit) LeaveCriticalSection(pCs);

  00090	e5943008	 ldr         r3, [r4, #8]
  00094	e3530000	 cmp         r3, #0
  00098	12850004	 addne       r0, r5, #4
  0009c	1b000000	 blne        LeaveCriticalSection

; 779  :         // indicate gpio registers need to be saved for OFF mode
; 780  :         HalContextUpdateDirtyRegister(HAL_CONTEXTSAVE_GPIO);

  000a0	e3a00001	 mov         r0, #1
  000a4	eb000000	 bl          HalContextUpdateDirtyRegister

; 781  :         rc = TRUE;

  000a8	e3a00001	 mov         r0, #1
  000ac		 |$cleanUp$37285|

; 782  :     }
; 783  : cleanUp:
; 784  :     return rc;
; 785  : }

  000ac	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000b0	e12fff1e	 bx          lr
  000b4		 |$LN22@OmapGpioCl|
  000b4		 |$LN23@OmapGpioCl|
  000b4	11223344	 DCD         0x11223344
  000b8		 |$M37886|

			 ENDP  ; |?OmapGpioClrBit@@YAHPAXI@Z|, OmapGpioClrBit


  00000			 AREA	 |.pdata|, PDATA
|$T37922| DCD	|$LN21@OmapGpioGe@2|
	DCD	0x40002b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioGetBit@@YAKPAXI@Z| PROC	; OmapGpioGetBit

; 796  : {

  00000		 |$LN21@OmapGpioGe@2|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M37919|
  00004	e1b04000	 movs        r4, r0

; 797  :     DWORD value = (DWORD) -1;

  00008	e3e06000	 mvn         r6, #0

; 798  :     UINT bit = GPIO_BIT(id);

  0000c	e201801f	 and         r8, r1, #0x1F

; 799  :     UINT bank = GPIO_BANK(id);

  00010	e1a072a1	 mov         r7, r1, lsr #5

; 800  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)context;
; 801  : 
; 802  :     // Check if we get correct context & pin id
; 803  :     if ((pDevice == NULL) || (pDevice->cookie != GPIO_DEVICE_COOKIE))

  00014	0a000020	 beq         |$cleanUp$37308|
  00018	e5942000	 ldr         r2, [r4]
  0001c	e59f3084	 ldr         r3, [pc, #0x84]
  00020	e1520003	 cmp         r2, r3
  00024	1a00001c	 bne         |$cleanUp$37308|

; 804  :     {
; 805  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioGetBit: Incorrect context\r\n"));
; 806  :         goto cleanUp;
; 807  :     }
; 808  : 
; 809  :     if (id < pDevice->nbBanks*32)

  00028	e5943004	 ldr         r3, [r4, #4]
  0002c	e1510283	 cmp         r1, r3, lsl #5
  00030	2a000019	 bcs         |$cleanUp$37308|

; 810  :     {
; 811  :         volatile UINT *p = &pDevice->bank[bank].ppGpioRegs->DATAIN;

  00034	e594300c	 ldr         r3, [r4, #0xC]

; 812  :         CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;
; 813  :         if (pDevice->fPostInit) EnterCriticalSection(pCs);

  00038	e5942008	 ldr         r2, [r4, #8]
  0003c	e0835287	 add         r5, r3, r7, lsl #5
  00040	e3520000	 cmp         r2, #0
  00044	e5956018	 ldr         r6, [r5, #0x18]
  00048	12850004	 addne       r0, r5, #4
  0004c	1b000000	 blne        EnterCriticalSection

; 814  :         InternalSetGpioBankPowerState(pDevice, id, D0);

  00050	e594200c	 ldr         r2, [r4, #0xC]
  00054	e7b23287	 ldr         r3, [r2, +r7, lsl #5]!
  00058	e3530000	 cmp         r3, #0
  0005c	0592001c	 ldreq       r0, [r2, #0x1C]
  00060	03a01001	 moveq       r1, #1
  00064	0b000000	 bleq        EnableDeviceClocks

; 815  :         value = (INREG32(p) >> (bit)) & 0x01;
; 816  :         InternalSetGpioBankPowerState(pDevice, id, D4);

  00068	e594100c	 ldr         r1, [r4, #0xC]
  0006c	e5963038	 ldr         r3, [r6, #0x38]
  00070	e7b12287	 ldr         r2, [r1, +r7, lsl #5]!
  00074	e1a03833	 mov         r3, r3, lsr r8
  00078	e2036001	 and         r6, r3, #1
  0007c	e3520000	 cmp         r2, #0
  00080	0591001c	 ldreq       r0, [r1, #0x1C]
  00084	03a01000	 moveq       r1, #0
  00088	0b000000	 bleq        EnableDeviceClocks

; 817  :         if (pDevice->fPostInit) LeaveCriticalSection(pCs);

  0008c	e5943008	 ldr         r3, [r4, #8]
  00090	e3530000	 cmp         r3, #0
  00094	12850004	 addne       r0, r5, #4
  00098	1b000000	 blne        LeaveCriticalSection
  0009c		 |$cleanUp$37308|

; 818  :     }
; 819  : 
; 820  : cleanUp:
; 821  :     return value;
; 822  : }

  0009c	e1a00006	 mov         r0, r6
  000a0	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000a4	e12fff1e	 bx          lr
  000a8		 |$LN22@OmapGpioGe@2|
  000a8		 |$LN23@OmapGpioGe@2|
  000a8	11223344	 DCD         0x11223344
  000ac		 |$M37920|

			 ENDP  ; |?OmapGpioGetBit@@YAKPAXI@Z|, OmapGpioGetBit


  00000			 AREA	 |.pdata|, PDATA
|$T37931| DCD	|$LN5@OmapGpioPo@2|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioPowerUp@@YAXPAX@Z| PROC	; OmapGpioPowerUp

; 1236 : {

  00000		 |$LN5@OmapGpioPo@2|
  00000		 |$M37928|

; 1237 :     UNREFERENCED_PARAMETER(hContext);
; 1238 : }

  00000	e12fff1e	 bx          lr
  00004		 |$M37929|

			 ENDP  ; |?OmapGpioPowerUp@@YAXPAX@Z|, OmapGpioPowerUp


  00000			 AREA	 |.pdata|, PDATA
|$T37938| DCD	|$LN5@OmapGpioPo@3|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioPowerDown@@YAXPAX@Z| PROC	; OmapGpioPowerDown

; 1250 : {

  00000		 |$LN5@OmapGpioPo@3|
  00000		 |$M37935|

; 1251 :     UNREFERENCED_PARAMETER(hContext);
; 1252 : }

  00000	e12fff1e	 bx          lr
  00004		 |$M37936|

			 ENDP  ; |?OmapGpioPowerDown@@YAXPAX@Z|, OmapGpioPowerDown

	IMPORT	|BSPGetGpioIrq|

  00000			 AREA	 |.pdata|, PDATA
|$T37948| DCD	|$LN5@OmapGpioGe@3|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioGetSystemIrq@@YAKPAXI@Z| PROC ; OmapGpioGetSystemIrq

; 1258 : {

  00000		 |$LN5@OmapGpioGe@3|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37945|

; 1259 :     UNREFERENCED_PARAMETER(hContext);
; 1260 : 	//get the interrupt number associated with this pin
; 1261 :     return BSPGetGpioIrq(id);

  00004	e1a00001	 mov         r0, r1
  00008	eb000000	 bl          BSPGetGpioIrq

; 1262 : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M37946|

			 ENDP  ; |?OmapGpioGetSystemIrq@@YAKPAXI@Z|, OmapGpioGetSystemIrq

	IMPORT	|InterruptInitialize|
	IMPORT	|KernelIoControl|

  00000			 AREA	 |.pdata|, PDATA
|$T37961| DCD	|$LN12@OmapGpioIn|
	DCD	0x40003502
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioInterruptInitialize@@YAHPAXKPAK0@Z| PROC ; OmapGpioInterruptInitialize

; 1270 : {

  00000		 |$LN12@OmapGpioIn|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M37958|
  00008	e1a05003	 mov         r5, r3
  0000c	e1a04002	 mov         r4, r2
  00010	e3500000	 cmp         r0, #0

; 1271 :     DWORD logintr;
; 1272 :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)hContext;
; 1273 : 
; 1274 :     if ((pDevice == NULL) || (sysintr == NULL) || (hEvent == NULL) || (id >= pDevice->nbBanks*32))

  00014	0a000028	 beq         |$LN6@OmapGpioIn|
  00018	e3540000	 cmp         r4, #0
  0001c	0a000026	 beq         |$LN6@OmapGpioIn|
  00020	e3550000	 cmp         r5, #0
  00024	0a000024	 beq         |$LN6@OmapGpioIn|
  00028	e5900004	 ldr         r0, [r0, #4]
  0002c	e1510280	 cmp         r1, r0, lsl #5
  00030	2a000021	 bcs         |$LN6@OmapGpioIn|

; 1277 :     }
; 1278 :     
; 1279 :     *sysintr = (DWORD) SYSINTR_UNDEFINED;

  00034	e3e03000	 mvn         r3, #0

; 1280 : 
; 1281 :     //get the interrupt number associated with this pin
; 1282 :     logintr = BSPGetGpioIrq(id);

  00038	e1a00001	 mov         r0, r1
  0003c	e5843000	 str         r3, [r4]
  00040	eb000000	 bl          BSPGetGpioIrq
  00044	e1a0e000	 mov         lr, r0

; 1283 : 
; 1284 :     //Get a valid sysintr for this interrupt
; 1285 :     if (!KernelIoControl(IOCTL_HAL_REQUEST_SYSINTR,&logintr,sizeof(logintr),sysintr,sizeof(*sysintr),NULL))

  00048	e59f0080	 ldr         r0, [pc, #0x80]
  0004c	e3a06004	 mov         r6, #4
  00050	e3a07000	 mov         r7, #0
  00054	e1a03004	 mov         r3, r4
  00058	e3a02004	 mov         r2, #4
  0005c	e28d1008	 add         r1, sp, #8
  00060	e58de008	 str         lr, [sp, #8]
  00064	e58d7004	 str         r7, [sp, #4]
  00068	e58d6000	 str         r6, [sp]
  0006c	eb000000	 bl          KernelIoControl
  00070	e3500000	 cmp         r0, #0
  00074	0a000007	 beq         |$failed$37473|

; 1286 :     {
; 1287 :         goto failed;
; 1288 :     }
; 1289 : 
; 1290 :     // Initialize the interrupt
; 1291 :     if (InterruptInitialize(*sysintr,hEvent,NULL,0) == FALSE)

  00078	e5940000	 ldr         r0, [r4]
  0007c	e3a03000	 mov         r3, #0
  00080	e3a02000	 mov         r2, #0
  00084	e1a01005	 mov         r1, r5
  00088	eb000000	 bl          InterruptInitialize
  0008c	e3500000	 cmp         r0, #0

; 1292 :     {
; 1293 :         goto failed;
; 1294 :     }
; 1295 :     return TRUE;

  00090	13a00001	 movne       r0, #1
  00094	1a000009	 bne         |$LN8@OmapGpioIn|
  00098		 |$failed$37473|

; 1296 : 
; 1297 : failed:
; 1298 :     if (*sysintr != SYSINTR_UNDEFINED)

  00098	e5943000	 ldr         r3, [r4]
  0009c	e3730001	 cmn         r3, #1

; 1299 :     {
; 1300 :         KernelIoControl(IOCTL_HAL_RELEASE_SYSINTR,sysintr,sizeof(*sysintr),NULL,0,NULL);

  000a0	159f0024	 ldrne       r0, [pc, #0x24]
  000a4	13a03000	 movne       r3, #0
  000a8	13a02004	 movne       r2, #4
  000ac	11a01004	 movne       r1, r4
  000b0	158d7004	 strne       r7, [sp, #4]
  000b4	158d7000	 strne       r7, [sp]
  000b8	1b000000	 blne        KernelIoControl
  000bc		 |$LN6@OmapGpioIn|

; 1275 :     {
; 1276 :         return FALSE;

  000bc	e3a00000	 mov         r0, #0
  000c0		 |$LN8@OmapGpioIn|

; 1301 :     }
; 1302 : 
; 1303 :     return FALSE;
; 1304 : }

  000c0	e28dd00c	 add         sp, sp, #0xC
  000c4	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000c8	e12fff1e	 bx          lr
  000cc		 |$LN13@OmapGpioIn|
  000cc		 |$LN14@OmapGpioIn|
  000cc	010100d8	 DCD         0x10100d8
  000d0		 |$LN15@OmapGpioIn|
  000d0	01010098	 DCD         0x1010098
  000d4		 |$M37959|

			 ENDP  ; |?OmapGpioInterruptInitialize@@YAHPAXKPAK0@Z|, OmapGpioInterruptInitialize

	IMPORT	|InterruptMask|

  00000			 AREA	 |.pdata|, PDATA
|$T37973| DCD	|$LN5@OmapGpioIn@2|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioInterruptMask@@YAXPAXKKH@Z| PROC ; OmapGpioInterruptMask

; 1312 : {

  00000		 |$LN5@OmapGpioIn@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37970|

; 1313 :     UNREFERENCED_PARAMETER(hContext);
; 1314 :     UNREFERENCED_PARAMETER(id);
; 1315 : 
; 1316 :     InterruptMask(sysintr,fDisable);

  00004	e1a01003	 mov         r1, r3
  00008	e1a00002	 mov         r0, r2
  0000c	eb000000	 bl          InterruptMask

; 1317 : }

  00010	e49de004	 ldr         lr, [sp], #4
  00014	e12fff1e	 bx          lr
  00018		 |$M37971|

			 ENDP  ; |?OmapGpioInterruptMask@@YAXPAXKKH@Z|, OmapGpioInterruptMask

	IMPORT	|InterruptDisable|

  00000			 AREA	 |.pdata|, PDATA
|$T37981| DCD	|$LN6@OmapGpioIn@3|
	DCD	0x40001504
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioInterruptDisable@@YAXPAXKK@Z| PROC ; OmapGpioInterruptDisable

; 1325 : {

  00000		 |$LN6@OmapGpioIn@3|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd008	 sub         sp, sp, #8
  00010		 |$M37978|
  00010	e58d2018	 str         r2, [sp, #0x18]

; 1326 :     UNREFERENCED_PARAMETER(hContext);
; 1327 :     UNREFERENCED_PARAMETER(id);
; 1328 : 
; 1329 :     InterruptDisable(sysintr);

  00014	e1a00002	 mov         r0, r2
  00018	eb000000	 bl          InterruptDisable

; 1330 : 
; 1331 :     if (sysintr != SYSINTR_UNDEFINED)

  0001c	e59d3018	 ldr         r3, [sp, #0x18]
  00020	e3730001	 cmn         r3, #1

; 1332 :     {
; 1333 :         KernelIoControl(IOCTL_HAL_RELEASE_SYSINTR,&sysintr,sizeof(sysintr),NULL,0,NULL);

  00024	159f0024	 ldrne       r0, [pc, #0x24]
  00028	13a0e000	 movne       lr, #0
  0002c	13a03000	 movne       r3, #0
  00030	13a02004	 movne       r2, #4
  00034	128d1018	 addne       r1, sp, #0x18
  00038	158de004	 strne       lr, [sp, #4]
  0003c	158de000	 strne       lr, [sp]
  00040	1b000000	 blne        KernelIoControl

; 1334 :     }
; 1335 : }

  00044	e28dd008	 add         sp, sp, #8
  00048	e89d6000	 ldmia       sp, {sp, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$LN7@OmapGpioIn@3|
  00050		 |$LN8@OmapGpioIn@3|
  00050	010100d8	 DCD         0x10100d8
  00054		 |$M37979|

			 ENDP  ; |?OmapGpioInterruptDisable@@YAXPAXKK@Z|, OmapGpioInterruptDisable

	IMPORT	|InterruptDone|

  00000			 AREA	 |.pdata|, PDATA
|$T37991| DCD	|$LN5@OmapGpioIn@4|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioInterruptDone@@YAXPAXKK@Z| PROC ; OmapGpioInterruptDone

; 1343 : {

  00000		 |$LN5@OmapGpioIn@4|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37988|

; 1344 :     UNREFERENCED_PARAMETER(hContext);
; 1345 :     UNREFERENCED_PARAMETER(id);
; 1346 :     InterruptDone(sysintr);

  00004	e1a00002	 mov         r0, r2
  00008	eb000000	 bl          InterruptDone

; 1347 : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M37989|

			 ENDP  ; |?OmapGpioInterruptDone@@YAXPAXKK@Z|, OmapGpioInterruptDone


  00000			 AREA	 |.pdata|, PDATA
|$T38003| DCD	|$LN7@OmapGpioIn@5|
	DCD	0x40001304
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioInterruptWakeUp@@YAHPAXKKH@Z| PROC ; OmapGpioInterruptWakeUp

; 1357 : {

  00000		 |$LN7@OmapGpioIn@5|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd008	 sub         sp, sp, #8
  00010		 |$M38000|
  00010	e3530000	 cmp         r3, #0

; 1358 :     UNREFERENCED_PARAMETER(hContext);
; 1359 :     UNREFERENCED_PARAMETER(id);
; 1360 :     return KernelIoControl(fEnabled ? IOCTL_HAL_ENABLE_WAKE : IOCTL_HAL_DISABLE_WAKE, 
; 1361 :         &sysintr,sizeof(sysintr), NULL, 0, NULL );

  00014	159f002c	 ldrne       r0, [pc, #0x2C]
  00018	059f0024	 ldreq       r0, [pc, #0x24]
  0001c	e3a0e000	 mov         lr, #0
  00020	e3a03000	 mov         r3, #0
  00024	e3a02004	 mov         r2, #4
  00028	e28d1018	 add         r1, sp, #0x18
  0002c	e58de004	 str         lr, [sp, #4]
  00030	e58de000	 str         lr, [sp]
  00034	eb000000	 bl          KernelIoControl

; 1362 : }

  00038	e28dd008	 add         sp, sp, #8
  0003c	e89d6000	 ldmia       sp, {sp, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$LN8@OmapGpioIn@5|
  00044		 |$LN9@OmapGpioIn@5|
  00044	010100a4	 DCD         0x10100a4
  00048		 |$LN10@OmapGpioIn@5|
  00048	010100a0	 DCD         0x10100a0
  0004c		 |$M38001|

			 ENDP  ; |?OmapGpioInterruptWakeUp@@YAHPAXKKH@Z|, OmapGpioInterruptWakeUp

	EXPORT	|?GIO_Deinit@@YAHK@Z|			; GIO_Deinit

  00000			 AREA	 |.pdata|, PDATA
|$T38016| DCD	|$LN5@GIO_Deinit|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GIO_Deinit@@YAHK@Z| PROC		; GIO_Deinit

; 1390 : {

  00000		 |$LN5@GIO_Deinit|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38013|

; 1391 :     return OmapGpioDeinit((HANDLE)hDeviceContext);

  00004	eb000000	 bl          |?OmapGpioDeinit@@YAHPAX@Z|

; 1392 : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M38014|

			 ENDP  ; |?GIO_Deinit@@YAHK@Z|, GIO_Deinit

	EXPORT	|?GIO_Open@@YAKKKK@Z|			; GIO_Open

  00000			 AREA	 |.pdata|, PDATA
|$T38026| DCD	|$LN5@GIO_Open|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GIO_Open@@YAKKKK@Z| PROC		; GIO_Open

; 1399 : {

  00000		 |$LN5@GIO_Open|
  00000		 |$M38023|

; 1400 :     UNREFERENCED_PARAMETER(AccessCode);
; 1401 :     UNREFERENCED_PARAMETER(ShareMode);
; 1402 :     return hDeviceContext;
; 1403 : }

  00000	e12fff1e	 bx          lr
  00004		 |$M38024|

			 ENDP  ; |?GIO_Open@@YAKKKK@Z|, GIO_Open

	EXPORT	|?GIO_Close@@YAHK@Z|			; GIO_Close

  00000			 AREA	 |.pdata|, PDATA
|$T38035| DCD	|$LN5@GIO_Close|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GIO_Close@@YAHK@Z| PROC		; GIO_Close

; 1408 : {

  00000		 |$LN5@GIO_Close|
  00000		 |$M38032|

; 1409 :     UNREFERENCED_PARAMETER(hOpenContext);
; 1410 :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 1411 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M38033|

			 ENDP  ; |?GIO_Close@@YAHK@Z|, GIO_Close

	EXPORT	|?GIO_PowerDown@@YAXK@Z|		; GIO_PowerDown

  00000			 AREA	 |.pdata|, PDATA
|$T38045| DCD	|$LN7@GIO_PowerD|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GIO_PowerDown@@YAXK@Z| PROC		; GIO_PowerDown

; 1416 : {

  00000		 |$LN7@GIO_PowerD|
  00000		 |$M38042|

; 1417 :     OmapGpioPowerDown((HANDLE) hDeviceContext);
; 1418 : }

  00000	e12fff1e	 bx          lr
  00004		 |$M38043|

			 ENDP  ; |?GIO_PowerDown@@YAXK@Z|, GIO_PowerDown

	EXPORT	|?GIO_PowerUp@@YAXK@Z|			; GIO_PowerUp

  00000			 AREA	 |.pdata|, PDATA
|$T38055| DCD	|$LN7@GIO_PowerU|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GIO_PowerUp@@YAXK@Z| PROC		; GIO_PowerUp

; 1422 : {

  00000		 |$LN7@GIO_PowerU|
  00000		 |$M38052|

; 1423 :     OmapGpioPowerUp((HANDLE) hDeviceContext);
; 1424 : }

  00000	e12fff1e	 bx          lr
  00004		 |$M38053|

			 ENDP  ; |?GIO_PowerUp@@YAXK@Z|, GIO_PowerUp

	IMPORT	|MmMapIoSpace|
	IMPORT	|GetAddressByDevice|
	IMPORT	|SOCGetGPIODeviceByBank|
	IMPORT	|LocalAlloc|
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T38080| DCD	|$LN24@OmapGpioIn@6|
	DCD	0x40005601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioInit@@YAHPBGPAPAXPAI@Z| PROC	; OmapGpioInit

; 227  : {

  00000		 |$LN24@OmapGpioIn@6|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M38077|
  00004	e1a07002	 mov         r7, r2
  00008	e1a08001	 mov         r8, r1

; 228  :     BOOL rc = FALSE;
; 229  :     OmapGpioDevice_t *pDevice = NULL;
; 230  :     PHYSICAL_ADDRESS pa;
; 231  :     DWORD size;
; 232  :     UINT8 i;
; 233  : 
; 234  : 	UNREFERENCED_PARAMETER(szContext);
; 235  : 
; 236  :     DEBUGMSG(ZONE_FUNCTION, (
; 237  :         L"+OmapGpioInit(%s)\r\n", szContext
; 238  :         ));
; 239  : 
; 240  :     // Create device structure
; 241  :     pDevice = (OmapGpioDevice_t *)LocalAlloc(LPTR, sizeof(OmapGpioDevice_t));

  0000c	e3a01010	 mov         r1, #0x10
  00010	e3a00040	 mov         r0, #0x40
  00014	e3a06000	 mov         r6, #0
  00018	eb000000	 bl          LocalAlloc
  0001c	e1b04000	 movs        r4, r0

; 242  :     if (pDevice == NULL)

  00020	0a000046	 beq         |$LN21@OmapGpioIn@6|

; 243  :     {
; 244  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioInit: "
; 245  :             L"Failed allocate GPIO driver structure\r\n"
; 246  :             ));
; 247  :         goto cleanUp;
; 248  :     }
; 249  :     memset(pDevice, 0, sizeof(OmapGpioDevice_t));

  00024	e3a02000	 mov         r2, #0

; 250  :     // Set cookie
; 251  :     pDevice->cookie = GPIO_DEVICE_COOKIE;

  00028	e59f3124	 ldr         r3, [pc, #0x124]
  0002c	e5842000	 str         r2, [r4]
  00030	e5842004	 str         r2, [r4, #4]
  00034	e5842008	 str         r2, [r4, #8]
  00038	e584200c	 str         r2, [r4, #0xC]

; 252  :     // Get the number of for this SOC
; 253  :     i=1;
; 254  :     while (SOCGetGPIODeviceByBank(i++) != OMAP_DEVICE_NONE)

  0003c	e3a00001	 mov         r0, #1
  00040	e5843000	 str         r3, [r4]
  00044	eb000000	 bl          SOCGetGPIODeviceByBank
  00048	e3700001	 cmn         r0, #1
  0004c	0a000009	 beq         |$LN18@OmapGpioIn@6|

; 257  :     }
; 258  :     // Allocate the bank structure
; 259  :     pDevice->bank = (OmapGpioBank_t*) LocalAlloc(LPTR,sizeof(OmapGpioBank_t)*pDevice->nbBanks);

  00050	e3a05001	 mov         r5, #1
  00054		 |$LL10@OmapGpioIn@6|

; 255  :     {
; 256  :         pDevice->nbBanks++;

  00054	e5942004	 ldr         r2, [r4, #4]
  00058	e2853001	 add         r3, r5, #1
  0005c	e20350ff	 and         r5, r3, #0xFF
  00060	e2823001	 add         r3, r2, #1
  00064	e1a00005	 mov         r0, r5
  00068	e5843004	 str         r3, [r4, #4]
  0006c	eb000000	 bl          SOCGetGPIODeviceByBank
  00070	e3700001	 cmn         r0, #1
  00074	1afffff6	 bne         |$LL10@OmapGpioIn@6|
  00078		 |$LN18@OmapGpioIn@6|

; 257  :     }
; 258  :     // Allocate the bank structure
; 259  :     pDevice->bank = (OmapGpioBank_t*) LocalAlloc(LPTR,sizeof(OmapGpioBank_t)*pDevice->nbBanks);

  00078	e5943004	 ldr         r3, [r4, #4]
  0007c	e3a00040	 mov         r0, #0x40
  00080	e1a01283	 mov         r1, r3, lsl #5
  00084	eb000000	 bl          LocalAlloc
  00088	e3500000	 cmp         r0, #0
  0008c	e584000c	 str         r0, [r4, #0xC]

; 260  :     if (pDevice->bank == NULL)

  00090	0a00002a	 beq         |$LN21@OmapGpioIn@6|

; 261  :     {
; 262  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioInit: "
; 263  :             L"Failed allocate GPIO driver bank structures\r\n"
; 264  :             ));
; 265  :         goto cleanUp;
; 266  :     }
; 267  :     memset(pDevice->bank, 0, sizeof(OmapGpioBank_t)*pDevice->nbBanks);

  00094	e5943004	 ldr         r3, [r4, #4]
  00098	e3a01000	 mov         r1, #0
  0009c	e1a02283	 mov         r2, r3, lsl #5
  000a0	eb000000	 bl          memset

; 268  : 
; 269  :     for (i = 0; i < pDevice->nbBanks; i++)

  000a4	e5943004	 ldr         r3, [r4, #4]
  000a8	e3a05000	 mov         r5, #0
  000ac	e3530000	 cmp         r3, #0
  000b0	9a00001b	 bls         |$LN4@OmapGpioIn@6|
  000b4	e3a02000	 mov         r2, #0
  000b8		 |$LL6@OmapGpioIn@6|

; 270  :     {
; 271  :         // Get device clock
; 272  :         pDevice->bank[i].DeviceID = SOCGetGPIODeviceByBank(i+1);

  000b8	e2829001	 add         r9, r2, #1
  000bc	e1a00009	 mov         r0, r9
  000c0	eb000000	 bl          SOCGetGPIODeviceByBank
  000c4	e594300c	 ldr         r3, [r4, #0xC]
  000c8	e0833285	 add         r3, r3, r5, lsl #5
  000cc	e583001c	 str         r0, [r3, #0x1C]

; 273  :         // Map GPIO registers  
; 274  :         pa.QuadPart = GetAddressByDevice(pDevice->bank[i].DeviceID);

  000d0	e594300c	 ldr         r3, [r4, #0xC]
  000d4	e0833285	 add         r3, r3, r5, lsl #5
  000d8	e593001c	 ldr         r0, [r3, #0x1C]
  000dc	eb000000	 bl          GetAddressByDevice

; 275  :         size = sizeof(OMAP_GPIO_REGS);
; 276  :         pDevice->bank[i].ppGpioRegs = (OMAP_GPIO_REGS*)MmMapIoSpace(pa, size, FALSE);

  000e0	e3a03000	 mov         r3, #0
  000e4	e3a020a0	 mov         r2, #0xA0
  000e8	e3a01000	 mov         r1, #0
  000ec	eb000000	 bl          MmMapIoSpace
  000f0	e594300c	 ldr         r3, [r4, #0xC]
  000f4	e0833285	 add         r3, r3, r5, lsl #5
  000f8	e5830018	 str         r0, [r3, #0x18]

; 277  :         if (pDevice->bank[i].ppGpioRegs == NULL)

  000fc	e594300c	 ldr         r3, [r4, #0xC]
  00100	e0833285	 add         r3, r3, r5, lsl #5
  00104	e5933018	 ldr         r3, [r3, #0x18]
  00108	e3530000	 cmp         r3, #0
  0010c	0a00000b	 beq         |$LN21@OmapGpioIn@6|
  00110	e5943004	 ldr         r3, [r4, #4]
  00114	e20950ff	 and         r5, r9, #0xFF
  00118	e1a02005	 mov         r2, r5
  0011c	e1550003	 cmp         r5, r3
  00120	3affffe4	 bcc         |$LL6@OmapGpioIn@6|
  00124		 |$LN4@OmapGpioIn@6|

; 278  :         {
; 279  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioInit: "
; 280  :                 L"Failed map GIO%d controller registers\r\n",i
; 281  :                 ));
; 282  :             goto cleanUp;
; 283  :         }
; 284  :     }
; 285  : 
; 286  :     // indicate gpio registers need to be saved for OFF mode
; 287  :     HalContextUpdateDirtyRegister(HAL_CONTEXTSAVE_GPIO);

  00124	e3a00001	 mov         r0, #1
  00128	eb000000	 bl          HalContextUpdateDirtyRegister

; 288  : 
; 289  :     // Return non-null value
; 290  :     rc = TRUE;
; 291  :     *phContext = (HANDLE)pDevice;

  0012c	e5884000	 str         r4, [r8]

; 292  :     *pGpioCount = pDevice->nbBanks;

  00130	e5943004	 ldr         r3, [r4, #4]
  00134	e3a06001	 mov         r6, #1
  00138		 |$cleanUp$37079|
  00138	e5873000	 str         r3, [r7]

; 293  : 
; 294  : cleanUp:
; 295  :     if (rc == FALSE) OmapGpioDeinit((HANDLE)pDevice);

  0013c	ea000001	 b           |$LN1@OmapGpioIn@6|
  00140		 |$LN21@OmapGpioIn@6|
  00140	e1a00004	 mov         r0, r4
  00144	eb000000	 bl          |?OmapGpioDeinit@@YAHPAX@Z|
  00148		 |$LN1@OmapGpioIn@6|

; 296  :     DEBUGMSG(ZONE_FUNCTION, (L"-OmapGpioInit()\r\n"));
; 297  :     return rc;
; 298  : }

  00148	e1a00006	 mov         r0, r6
  0014c	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00150	e12fff1e	 bx          lr
  00154		 |$LN25@OmapGpioIn@6|
  00154		 |$LN26@OmapGpioIn@6|
  00154	11223344	 DCD         0x11223344
  00158		 |$M38078|

			 ENDP  ; |?OmapGpioInit@@YAHPBGPAPAXPAI@Z|, OmapGpioInit

	EXPORT	|??_C@_1MM@BOONICNJ@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1JG@DHGGDOFN@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAI?$AAO?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AA?3?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_@| [ DATA ] ; `string'
	IMPORT	|NKDbgPrintfW|
	IMPORT	|GetCallerProcess|
	IMPORT	|SetLastError|
	IMPORT	|CeSafeCopyMemory|

  00000			 AREA	 |.pdata|, PDATA
|$T38215| DCD	|$LN130@OmapGpioIo|
	DCD	0x4001cb02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1MM@BOONICNJ@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| DCB "C"
	DCB	0x0, ":", 0x0, "\\", 0x0, "W", 0x0, "I", 0x0, "N", 0x0, "C"
	DCB	0x0, "E", 0x0, "6", 0x0, "0", 0x0, "0", 0x0, "\\", 0x0, "P"
	DCB	0x0, "L", 0x0, "A", 0x0, "T", 0x0, "F", 0x0, "O", 0x0, "R"
	DCB	0x0, "M", 0x0, "\\", 0x0, "C", 0x0, "O", 0x0, "M", 0x0, "M"
	DCB	0x0, "O", 0x0, "N", 0x0, "\\", 0x0, "S", 0x0, "R", 0x0, "C"
	DCB	0x0, "\\", 0x0, "S", 0x0, "O", 0x0, "C", 0x0, "\\", 0x0, "C"
	DCB	0x0, "O", 0x0, "M", 0x0, "M", 0x0, "O", 0x0, "N", 0x0, "_"
	DCB	0x0, "T", 0x0, "I", 0x0, "_", 0x0, "V", 0x0, "1", 0x0, "\\"
	DCB	0x0, "C", 0x0, "O", 0x0, "M", 0x0, "M", 0x0, "O", 0x0, "N"
	DCB	0x0, "_", 0x0, "T", 0x0, "I", 0x0, "\\", 0x0, "G", 0x0, "P"
	DCB	0x0, "I", 0x0, "O", 0x0, "\\", 0x0, "O", 0x0, "M", 0x0, "A"
	DCB	0x0, "P", 0x0, "_", 0x0, "G", 0x0, "P", 0x0, "I", 0x0, "O"
	DCB	0x0, "\\", 0x0, "D", 0x0, "E", 0x0, "V", 0x0, "I", 0x0, "C"
	DCB	0x0, "E", 0x0, "\\", 0x0, ".", 0x0, ".", 0x0, "\\", 0x0, "o"
	DCB	0x0, "m", 0x0, "a", 0x0, "p", 0x0, "3", 0x0, "5", 0x0, "x"
	DCB	0x0, "x", 0x0, "_", 0x0, "g", 0x0, "p", 0x0, "i", 0x0, "o"
	DCB	0x0, ".", 0x0, "c", 0x0, "p", 0x0, "p", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "%", 0x0, "s", 0x0, " ", 0x0, "l", 0x0, "i", 0x0, "n"
	DCB	0x0, "e", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ":", 0x0, " "
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1JG@DHGGDOFN@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAI?$AAO?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AA?3?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "O", 0x0, "m", 0x0, "a", 0x0, "p", 0x0, "G", 0x0, "p"
	DCB	0x0, "i", 0x0, "o", 0x0, "I", 0x0, "O", 0x0, "C", 0x0, "o"
	DCB	0x0, "n", 0x0, "t", 0x0, "r", 0x0, "o", 0x0, "l", 0x0, ":"
	DCB	0x0, " ", 0x0, "I", 0x0, "O", 0x0, "C", 0x0, "T", 0x0, "L"
	DCB	0x0, "_", 0x0, "G", 0x0, "P", 0x0, "I", 0x0, "O", 0x0, "_"
	DCB	0x0, "S", 0x0, "E", 0x0, "T", 0x0, "_", 0x0, "P", 0x0, "O"
	DCB	0x0, "W", 0x0, "E", 0x0, "R", 0x0, "_", 0x0, "S", 0x0, "T"
	DCB	0x0, "A", 0x0, "T", 0x0, "E", 0x0, " ", 0x0, "-", 0x0, " "
	DCB	0x0, "I", 0x0, "n", 0x0, "v", 0x0, "a", 0x0, "l", 0x0, "i"
	DCB	0x0, "d", 0x0, " ", 0x0, "p", 0x0, "a", 0x0, "r", 0x0, "a"
	DCB	0x0, "m", 0x0, "e", 0x0, "t", 0x0, "e", 0x0, "r", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapGpioIoControl@@YAHPAXIPAEI1IPAK@Z| PROC ; OmapGpioIoControl

; 840  : {

  00000		 |$LN130@OmapGpioIo|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd058	 sub         sp, sp, #0x58
  00008		 |$M38212|
  00008	e1b05000	 movs        r5, r0
  0000c	e58d500c	 str         r5, [sp, #0xC]
  00010	e1a07003	 mov         r7, r3
  00014	e1a06002	 mov         r6, r2

; 841  : #ifdef DEVICE
; 842  :     UINT id;
; 843  :     DWORD value,mode;
; 844  :     DEVICE_IFC_GPIO ifc;
; 845  :     UINT bit;
; 846  :     UINT bank;
; 847  :     BOOL rc = FALSE;
; 848  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)context;
; 849  : 
; 850  :     UNREFERENCED_PARAMETER(pOutSize);
; 851  : 
; 852  :     DEBUGMSG(ZONE_FUNCTION, (
; 853  :         L"+OmapGpioIOControl(0x%08x, 0x%08x, 0x%08x, %d, 0x%08x, %d, 0x%08x)\r\n",
; 854  :         context, code, pInBuffer, inSize, pOutBuffer, outSize, pOutSize
; 855  :         ));
; 856  : 
; 857  :     // Check if we get correct context
; 858  :     if ((pDevice == NULL) || (pDevice->cookie != GPIO_DEVICE_COOKIE))

  00018	0a0001a5	 beq         |$LN116@OmapGpioIo|
  0001c	e5954000	 ldr         r4, [r5]
  00020	e59fe700	 ldr         lr, [pc, #0x700]
  00024	e154000e	 cmp         r4, lr
  00028	1a0001a1	 bne         |$LN116@OmapGpioIo|

; 859  :     {
; 860  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioIOControl: "
; 861  :             L"Incorrect context parameter\r\n"
; 862  :             ));
; 863  :         goto cleanUp;
; 864  :     }
; 865  :     switch (code)

  0002c	e59f36f0	 ldr         r3, [pc, #0x6F0]
  00030	e1510003	 cmp         r1, r3
  00034	8a0000d3	 bhi         |$LN70@OmapGpioIo|
  00038	0a0000b7	 beq         |$LN27@OmapGpioIo|
  0003c	e3a03822	 mov         r3, #0x22, 16
  00040	e383eb01	 orr         lr, r3, #1, 22
  00044	e151000e	 cmp         r1, lr
  00048	0a000070	 beq         |$LN54@OmapGpioIo|
  0004c	e3a03822	 mov         r3, #0x22, 16
  00050	e3833b03	 orr         r3, r3, #3, 22
  00054	e1510003	 cmp         r1, r3
  00058	0a000059	 beq         |$LN44@OmapGpioIo|
  0005c	e59f36bc	 ldr         r3, [pc, #0x6BC]
  00060	e1510003	 cmp         r1, r3
  00064	0a000043	 beq         |$LN40@OmapGpioIo|
  00068	e59f36ac	 ldr         r3, [pc, #0x6AC]
  0006c	e1510003	 cmp         r1, r3
  00070	0a000020	 beq         |$LN36@OmapGpioIo|
  00074	e3a03822	 mov         r3, #0x22, 16
  00078	e3833ec1	 orr         r3, r3, #0xC1, 28
  0007c	e1510003	 cmp         r1, r3
  00080	1a00018b	 bne         |$LN116@OmapGpioIo|

; 953  :         }
; 954  :         rc = TRUE;
; 955  :         break;
; 956  : 
; 957  :     case IOCTL_GPIO_SETMODE:
; 958  :         if (pOutSize != 0) *pOutSize = 0;

  00084	e59d3084	 ldr         r3, [sp, #0x84]
  00088	e3530000	 cmp         r3, #0
  0008c	13a02000	 movne       r2, #0
  00090	15832000	 strne       r2, [r3]

; 959  :         if ((pInBuffer == NULL) || (inSize < 2 * sizeof(DWORD)) ||
; 960  :             !CeSafeCopyMemory(
; 961  :             &id, &((DWORD*)pInBuffer)[0], sizeof(DWORD)
; 962  :             ) ||
; 963  :             !CeSafeCopyMemory(
; 964  :             &mode, &((DWORD*)pInBuffer)[1], sizeof(DWORD)
; 965  :             ))

  00094	e3560000	 cmp         r6, #0
  00098	0a000013	 beq         |$LN28@OmapGpioIo|
  0009c	e3570008	 cmp         r7, #8
  000a0	3a000011	 bcc         |$LN28@OmapGpioIo|
  000a4	e3a02004	 mov         r2, #4
  000a8	e1a01006	 mov         r1, r6
  000ac	e28d0000	 add         r0, sp, #0
  000b0	eb000000	 bl          CeSafeCopyMemory
  000b4	e3500000	 cmp         r0, #0
  000b8	0a00000b	 beq         |$LN28@OmapGpioIo|
  000bc	e3a02004	 mov         r2, #4
  000c0	e2861004	 add         r1, r6, #4
  000c4	e28d0004	 add         r0, sp, #4
  000c8	eb000000	 bl          CeSafeCopyMemory
  000cc	e3500000	 cmp         r0, #0
  000d0	0a000005	 beq         |$LN28@OmapGpioIo|

; 969  :         }
; 970  :         OmapGpioSetMode(context, id, mode);

  000d4	e59d2004	 ldr         r2, [sp, #4]
  000d8	e59d1000	 ldr         r1, [sp]
  000dc	e1a00005	 mov         r0, r5
  000e0	eb000000	 bl          |?OmapGpioSetMode@@YAHPAXII@Z|
  000e4	e3a04001	 mov         r4, #1
  000e8	ea000172	 b           |$cleanUp$37338|
  000ec		 |$LN28@OmapGpioIo|

; 966  :         {
; 967  :             SetLastError(ERROR_INVALID_PARAMETER);

  000ec	e3a00057	 mov         r0, #0x57
  000f0	eb000000	 bl          SetLastError

; 968  :             break;

  000f4	ea00016e	 b           |$LN116@OmapGpioIo|
  000f8		 |$LN36@OmapGpioIo|

; 936  :         rc = TRUE;
; 937  :         break;
; 938  : 
; 939  :     case IOCTL_GPIO_GETBIT:
; 940  :         if (pOutSize != 0) *pOutSize = sizeof(DWORD);

  000f8	e59d3084	 ldr         r3, [sp, #0x84]
  000fc	e3530000	 cmp         r3, #0
  00100	13a02004	 movne       r2, #4
  00104	15832000	 strne       r2, [r3]

; 941  :         if ((pInBuffer == NULL) || (inSize < sizeof(DWORD)) ||
; 942  :             !CeSafeCopyMemory(&id, pInBuffer, sizeof(DWORD)) ||
; 943  :             (pOutBuffer == NULL) || (outSize < sizeof(DWORD)))

  00108	e3560000	 cmp         r6, #0
  0010c	0afffff6	 beq         |$LN28@OmapGpioIo|
  00110	e3570004	 cmp         r7, #4
  00114	3afffff4	 bcc         |$LN28@OmapGpioIo|
  00118	e3a02004	 mov         r2, #4
  0011c	e1a01006	 mov         r1, r6
  00120	e28d0000	 add         r0, sp, #0
  00124	eb000000	 bl          CeSafeCopyMemory
  00128	e3500000	 cmp         r0, #0
  0012c	0affffee	 beq         |$LN28@OmapGpioIo|
  00130	e59d407c	 ldr         r4, [sp, #0x7C]
  00134	e3540000	 cmp         r4, #0
  00138	0affffeb	 beq         |$LN28@OmapGpioIo|
  0013c	e59d3080	 ldr         r3, [sp, #0x80]
  00140	e3530004	 cmp         r3, #4
  00144	3affffe8	 bcc         |$LN28@OmapGpioIo|

; 944  :         {
; 945  :             SetLastError(ERROR_INVALID_PARAMETER);
; 946  :             break;
; 947  :         }
; 948  :         value = OmapGpioGetBit(context, id);

  00148	e59d1000	 ldr         r1, [sp]
  0014c	e1a00005	 mov         r0, r5
  00150	eb000000	 bl          |?OmapGpioGetBit@@YAKPAXI@Z|
  00154	e1a03000	 mov         r3, r0

; 949  :         if (!CeSafeCopyMemory(pOutBuffer, &value, sizeof(value)))

  00158	e58d3008	 str         r3, [sp, #8]
  0015c	e28d1008	 add         r1, sp, #8
  00160		 |$LN124@OmapGpioIo|
  00160	e3a02004	 mov         r2, #4
  00164	e1a00004	 mov         r0, r4
  00168	eb000000	 bl          CeSafeCopyMemory
  0016c	e3500000	 cmp         r0, #0
  00170	1a000067	 bne         |$LN121@OmapGpioIo|

; 950  :         {
; 951  :             SetLastError(ERROR_INVALID_PARAMETER);
; 952  :             break;

  00174	eaffffdc	 b           |$LN28@OmapGpioIo|
  00178		 |$LN40@OmapGpioIo|

; 924  :         rc = TRUE;
; 925  :         break;
; 926  : 
; 927  :     case IOCTL_GPIO_CLRBIT:
; 928  :         if (pOutSize != 0) *pOutSize = 0;

  00178	e59d3084	 ldr         r3, [sp, #0x84]
  0017c	e3530000	 cmp         r3, #0
  00180	13a02000	 movne       r2, #0
  00184	15832000	 strne       r2, [r3]

; 929  :         if ((pInBuffer == NULL) || (inSize < sizeof(DWORD)) ||
; 930  :             !CeSafeCopyMemory(&id, pInBuffer, sizeof(DWORD)))

  00188	e3560000	 cmp         r6, #0
  0018c	0affffd6	 beq         |$LN28@OmapGpioIo|
  00190	e3570004	 cmp         r7, #4
  00194	3affffd4	 bcc         |$LN28@OmapGpioIo|
  00198	e3a02004	 mov         r2, #4
  0019c	e1a01006	 mov         r1, r6
  001a0	e28d0000	 add         r0, sp, #0
  001a4	eb000000	 bl          CeSafeCopyMemory
  001a8	e3500000	 cmp         r0, #0
  001ac	0affffce	 beq         |$LN28@OmapGpioIo|

; 931  :         {
; 932  :             SetLastError(ERROR_INVALID_PARAMETER);
; 933  :             break;
; 934  :         }
; 935  :         OmapGpioClrBit(context, id);

  001b0	e59d1000	 ldr         r1, [sp]
  001b4	e1a00005	 mov         r0, r5
  001b8	eb000000	 bl          |?OmapGpioClrBit@@YAHPAXI@Z|
  001bc	e3a04001	 mov         r4, #1
  001c0	ea00013c	 b           |$cleanUp$37338|
  001c4		 |$LN44@OmapGpioIo|

; 911  :         }
; 912  :         SetLastError(ERROR_INVALID_PARAMETER);
; 913  :         break;
; 914  : 
; 915  :     case IOCTL_GPIO_SETBIT:
; 916  :         if (pOutSize != 0) *pOutSize = 0;

  001c4	e59d3084	 ldr         r3, [sp, #0x84]
  001c8	e3530000	 cmp         r3, #0
  001cc	13a02000	 movne       r2, #0
  001d0	15832000	 strne       r2, [r3]

; 917  :         if ((pInBuffer == NULL) || (inSize < sizeof(DWORD)) ||
; 918  :             !CeSafeCopyMemory(&id, pInBuffer, sizeof(DWORD)))

  001d4	e3560000	 cmp         r6, #0
  001d8	0affffc3	 beq         |$LN28@OmapGpioIo|
  001dc	e3570004	 cmp         r7, #4
  001e0	3affffc1	 bcc         |$LN28@OmapGpioIo|
  001e4	e3a02004	 mov         r2, #4
  001e8	e1a01006	 mov         r1, r6
  001ec	e28d0000	 add         r0, sp, #0
  001f0	eb000000	 bl          CeSafeCopyMemory
  001f4	e3500000	 cmp         r0, #0
  001f8	0affffbb	 beq         |$LN28@OmapGpioIo|

; 919  :         {
; 920  :             SetLastError(ERROR_INVALID_PARAMETER);
; 921  :             break;
; 922  :         }
; 923  :         OmapGpioSetBit(context, id);

  001fc	e59d1000	 ldr         r1, [sp]
  00200	e1a00005	 mov         r0, r5
  00204	eb000000	 bl          |?OmapGpioSetBit@@YAHPAXI@Z|
  00208	e3a04001	 mov         r4, #1
  0020c	ea000129	 b           |$cleanUp$37338|
  00210		 |$LN54@OmapGpioIo|

; 866  :     {
; 867  :     case IOCTL_DDK_GET_DRIVER_IFC:
; 868  :         // We can give interface only to our peer in device process
; 869  :         if (GetCurrentProcessId() != (DWORD)GetCallerProcess())

  00210	e3a0000c	 mov         r0, #0xC
  00214	eb000000	 bl          __GetUserKData
  00218	e1a04000	 mov         r4, r0
  0021c	eb000000	 bl          GetCallerProcess
  00220	e1540000	 cmp         r4, r0
  00224	0a000002	 beq         |$LN53@OmapGpioIo|

; 870  :         {
; 871  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: GIO_IOControl: "
; 872  :                 L"IOCTL_DDK_GET_DRIVER_IFC can be called only from "
; 873  :                 L"device process (caller process id 0x%08x)\r\n",
; 874  :                 GetCurrentProcessId()
; 875  :                 ));
; 876  :             SetLastError(ERROR_ACCESS_DENIED);

  00228	e3a00005	 mov         r0, #5

; 966  :         {
; 967  :             SetLastError(ERROR_INVALID_PARAMETER);

  0022c	eb000000	 bl          SetLastError

; 968  :             break;

  00230	ea00011f	 b           |$LN116@OmapGpioIo|
  00234		 |$LN53@OmapGpioIo|

; 877  :             goto cleanUp;
; 878  :         }
; 879  :         if ((pInBuffer == NULL) || (inSize < sizeof(GUID)))

  00234	e3560000	 cmp         r6, #0
  00238	0affffab	 beq         |$LN28@OmapGpioIo|
  0023c	e3570010	 cmp         r7, #0x10
  00240	3affffa9	 bcc         |$LN28@OmapGpioIo|

; 880  :         {
; 881  :             SetLastError(ERROR_INVALID_PARAMETER);
; 882  :             break;
; 883  :         }
; 884  :         if (IsEqualGUID(*(GUID*)pInBuffer, DEVICE_IFC_GPIO_GUID))

  00244	e59f14cc	 ldr         r1, [pc, #0x4CC]
  00248	e3a02010	 mov         r2, #0x10
  0024c	e1a00006	 mov         r0, r6
  00250	eb000000	 bl          memcmp
  00254	e3500000	 cmp         r0, #0
  00258	1affffa3	 bne         |$LN28@OmapGpioIo|

; 885  :         {
; 886  :             if (pOutSize != NULL) *pOutSize = sizeof(DEVICE_IFC_GPIO);

  0025c	e59d3084	 ldr         r3, [sp, #0x84]
  00260	e3530000	 cmp         r3, #0
  00264	13a02048	 movne       r2, #0x48
  00268	15832000	 strne       r2, [r3]

; 887  :             if ((pOutBuffer == NULL) || (outSize < sizeof(DEVICE_IFC_GPIO)))

  0026c	e59d307c	 ldr         r3, [sp, #0x7C]
  00270	e3530000	 cmp         r3, #0
  00274	0affff9c	 beq         |$LN28@OmapGpioIo|
  00278	e59d3080	 ldr         r3, [sp, #0x80]
  0027c	e3530048	 cmp         r3, #0x48
  00280	3affff99	 bcc         |$LN28@OmapGpioIo|

; 888  :             {
; 889  :                 SetLastError(ERROR_INVALID_PARAMETER);
; 890  :                 break;
; 891  :             }
; 892  :             ifc.context                 = context;
; 893  :             ifc.pfnSetBit               = OmapGpioSetBit;
; 894  :             ifc.pfnClrBit               = OmapGpioClrBit;
; 895  :             ifc.pfnGetBit               = OmapGpioGetBit;
; 896  :             ifc.pfnSetMode              = OmapGpioSetMode;
; 897  :             ifc.pfnGetMode              = OmapGpioGetMode;
; 898  :             ifc.pfnPullup               = OmapGpioPullup;
; 899  :             ifc.pfnPulldown             = OmapGpioPulldown;
; 900  :             ifc.pfnInterruptInitialize  = OmapGpioInterruptInitialize;
; 901  :             ifc.pfnInterruptMask        = OmapGpioInterruptMask;
; 902  :             ifc.pfnInterruptDisable     = OmapGpioInterruptDisable;
; 903  :             ifc.pfnInterruptDone        = OmapGpioInterruptDone;
; 904  : 			ifc.pfnGetSystemIrq			= OmapGpioGetSystemIrq;
; 905  :             ifc.pfnInterruptWakeUp      = OmapGpioInterruptWakeUp;
; 906  :             ifc.pfnIoControl            = OmapGpioIoControl;

  00284	e59f3488	 ldr         r3, [pc, #0x488]
  00288	e59f0480	 ldr         r0, [pc, #0x480]
  0028c	e59f2478	 ldr         r2, [pc, #0x478]
  00290	e58d3020	 str         r3, [sp, #0x20]
  00294	e59f346c	 ldr         r3, [pc, #0x46C]
  00298	e59f1464	 ldr         r1, [pc, #0x464]
  0029c	e59fe45c	 ldr         lr, [pc, #0x45C]
  002a0	e59f4454	 ldr         r4, [pc, #0x454]
  002a4	e59f544c	 ldr         r5, [pc, #0x44C]
  002a8	e59f6444	 ldr         r6, [pc, #0x444]
  002ac	e59f743c	 ldr         r7, [pc, #0x43C]
  002b0	e59f8434	 ldr         r8, [pc, #0x434]
  002b4	e59f942c	 ldr         r9, [pc, #0x42C]
  002b8	e59fa424	 ldr         r10, [pc, #0x424]
  002bc	e59fb41c	 ldr         r11, [pc, #0x41C]
  002c0	e58d303c	 str         r3, [sp, #0x3C]

; 907  : 
; 908  :             if (!CeSafeCopyMemory(pOutBuffer, &ifc, sizeof(ifc))) break;

  002c4	e59d300c	 ldr         r3, [sp, #0xC]
  002c8	e58d0054	 str         r0, [sp, #0x54]
  002cc	e59d007c	 ldr         r0, [sp, #0x7C]
  002d0	e58d2024	 str         r2, [sp, #0x24]
  002d4	e58d1028	 str         r1, [sp, #0x28]
  002d8	e3a02048	 mov         r2, #0x48
  002dc	e28d1010	 add         r1, sp, #0x10
  002e0	e58d3010	 str         r3, [sp, #0x10]
  002e4	e58de02c	 str         lr, [sp, #0x2C]
  002e8	e58d4030	 str         r4, [sp, #0x30]
  002ec	e58d5034	 str         r5, [sp, #0x34]
  002f0	e58d6038	 str         r6, [sp, #0x38]
  002f4	e58d7040	 str         r7, [sp, #0x40]
  002f8	e58d8044	 str         r8, [sp, #0x44]
  002fc	e58d9048	 str         r9, [sp, #0x48]
  00300	e58da04c	 str         r10, [sp, #0x4C]
  00304	e58db050	 str         r11, [sp, #0x50]
  00308	eb000000	 bl          CeSafeCopyMemory
  0030c	e3500000	 cmp         r0, #0
  00310	0a0000e7	 beq         |$LN116@OmapGpioIo|
  00314		 |$LN121@OmapGpioIo|

; 909  :             rc = TRUE;

  00314	e3a04001	 mov         r4, #1

; 910  :             break;

  00318	ea0000e6	 b           |$cleanUp$37338|
  0031c		 |$LN27@OmapGpioIo|

; 971  :         rc = TRUE;
; 972  :         break;
; 973  : 
; 974  :     case IOCTL_GPIO_GETMODE:
; 975  :         if (pOutSize != 0) *pOutSize = sizeof(DWORD);

  0031c	e59d3084	 ldr         r3, [sp, #0x84]
  00320	e3530000	 cmp         r3, #0
  00324	13a02004	 movne       r2, #4
  00328	15832000	 strne       r2, [r3]

; 976  :         if ((pInBuffer == NULL) || (inSize < sizeof(DWORD)) ||
; 977  :             !CeSafeCopyMemory(&id, pInBuffer, sizeof(DWORD)) ||
; 978  :             (pOutBuffer == NULL) || (outSize < sizeof(DWORD)))

  0032c	e3560000	 cmp         r6, #0
  00330	0affff6d	 beq         |$LN28@OmapGpioIo|
  00334	e3570004	 cmp         r7, #4
  00338	3affff6b	 bcc         |$LN28@OmapGpioIo|
  0033c	e3a02004	 mov         r2, #4
  00340	e1a01006	 mov         r1, r6
  00344	e28d0000	 add         r0, sp, #0
  00348	eb000000	 bl          CeSafeCopyMemory
  0034c	e3500000	 cmp         r0, #0
  00350	0affff65	 beq         |$LN28@OmapGpioIo|
  00354	e59d407c	 ldr         r4, [sp, #0x7C]
  00358	e3540000	 cmp         r4, #0
  0035c	0affff62	 beq         |$LN28@OmapGpioIo|
  00360	e59d3080	 ldr         r3, [sp, #0x80]
  00364	e3530004	 cmp         r3, #4
  00368	3affff5f	 bcc         |$LN28@OmapGpioIo|

; 979  :         {
; 980  :             SetLastError(ERROR_INVALID_PARAMETER);
; 981  :             break;
; 982  :         }
; 983  :         mode = OmapGpioGetMode(context, id);

  0036c	e59d1000	 ldr         r1, [sp]
  00370	e1a00005	 mov         r0, r5
  00374	eb000000	 bl          |?OmapGpioGetMode@@YAKPAXI@Z|
  00378	e1a03000	 mov         r3, r0

; 984  :         if (!CeSafeCopyMemory(pOutBuffer, &mode, sizeof(mode)))

  0037c	e58d3004	 str         r3, [sp, #4]
  00380	e28d1004	 add         r1, sp, #4

; 985  :         {
; 986  :             SetLastError(ERROR_INVALID_PARAMETER);
; 987  :             break;

  00384	eaffff75	 b           |$LN124@OmapGpioIo|
  00388		 |$LN70@OmapGpioIo|

; 859  :     {
; 860  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioIOControl: "
; 861  :             L"Incorrect context parameter\r\n"
; 862  :             ));
; 863  :         goto cleanUp;
; 864  :     }
; 865  :     switch (code)

  00388	e59f334c	 ldr         r3, [pc, #0x34C]
  0038c	e1510003	 cmp         r1, r3
  00390	0a00008c	 beq         |$LN22@OmapGpioIo|
  00394	e3a03822	 mov         r3, #0x22, 16
  00398	e3833ec2	 orr         r3, r3, #0xC2, 28
  0039c	e1510003	 cmp         r1, r3
  003a0	0a000029	 beq         |$LN17@OmapGpioIo|
  003a4	e59f332c	 ldr         r3, [pc, #0x32C]
  003a8	e1510003	 cmp         r1, r3
  003ac	0a00004c	 beq         |$LN117@OmapGpioIo|
  003b0	e3a03822	 mov         r3, #0x22, 16
  003b4	e3833d31	 orr         r3, r3, #0x31, 26
  003b8	e1510003	 cmp         r1, r3
  003bc	1a0000bc	 bne         |$LN116@OmapGpioIo|

; 1166 : 
; 1167 :                 rc = TRUE;
; 1168 :             }
; 1169 :         }
; 1170 :         break;
; 1171 : 
; 1172 :     case IOCTL_GPIO_GET_DEBOUNCE_TIME:
; 1173 :         {
; 1174 :             if ((pInBuffer == NULL) || (pOutBuffer == NULL) ||
; 1175 :                 (inSize < sizeof(UINT)) ||
; 1176 :                 (outSize < sizeof(UINT)))

  003c0	e3560000	 cmp         r6, #0
  003c4	0affff48	 beq         |$LN28@OmapGpioIo|
  003c8	e59d807c	 ldr         r8, [sp, #0x7C]
  003cc	e3580000	 cmp         r8, #0
  003d0	0affff45	 beq         |$LN28@OmapGpioIo|
  003d4	e3570004	 cmp         r7, #4
  003d8	3affff43	 bcc         |$LN28@OmapGpioIo|
  003dc	e59d3080	 ldr         r3, [sp, #0x80]
  003e0	e3530004	 cmp         r3, #4
  003e4	3affff40	 bcc         |$LN28@OmapGpioIo|

; 1177 :             {
; 1178 :                 SetLastError(ERROR_INVALID_PARAMETER);
; 1179 :                 break;
; 1180 :             }
; 1181 : 
; 1182 :             UINT *pId;
; 1183 :             UINT *pOut;
; 1184 : 
; 1185 :             pId = (UINT*)pInBuffer;
; 1186 :             pOut = (UINT*)pOutBuffer;
; 1187 : 
; 1188 :             if (*pId < pDevice->nbBanks*32)

  003e8	e5961000	 ldr         r1, [r6]
  003ec	e5953004	 ldr         r3, [r5, #4]
  003f0	e1510283	 cmp         r1, r3, lsl #5
  003f4	2a0000ae	 bcs         |$LN116@OmapGpioIo|

; 1189 :             {
; 1190 : 
; 1191 :                 bank = GPIO_BANK(*pId);
; 1192 : 
; 1193 :                 CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;

  003f8	e595200c	 ldr         r2, [r5, #0xC]

; 1194 :                 if (pDevice->fPostInit) EnterCriticalSection(pCs);

  003fc	e5953008	 ldr         r3, [r5, #8]
  00400	e1a072a1	 mov         r7, r1, lsr #5
  00404	e0824287	 add         r4, r2, r7, lsl #5
  00408	e3530000	 cmp         r3, #0
  0040c	12840004	 addne       r0, r4, #4
  00410	1b000000	 blne        EnterCriticalSection

; 1195 :                 InternalSetGpioBankPowerState(pDevice, *pId, D0);

  00414	e5963000	 ldr         r3, [r6]
  00418	e595200c	 ldr         r2, [r5, #0xC]
  0041c	e1a032a3	 mov         r3, r3, lsr #5
  00420	e7b23283	 ldr         r3, [r2, +r3, lsl #5]!
  00424	e3530000	 cmp         r3, #0
  00428	0592001c	 ldreq       r0, [r2, #0x1C]
  0042c	03a01001	 moveq       r1, #1
  00430	0b000000	 bleq        EnableDeviceClocks

; 1196 :                 *pOut = INREG32(&pDevice->bank[bank].ppGpioRegs->DEBOUNCINGTIME);

  00434	e595300c	 ldr         r3, [r5, #0xC]
  00438	e0833287	 add         r3, r3, r7, lsl #5
  0043c	e5933018	 ldr         r3, [r3, #0x18]
  00440	e5933054	 ldr         r3, [r3, #0x54]
  00444	e5883000	 str         r3, [r8]

; 1197 :                 InternalSetGpioBankPowerState(pDevice, *pId, D4);
; 1198 :                 if (pDevice->fPostInit) LeaveCriticalSection(pCs);
; 1199 : 
; 1200 :                 // indicate gpio registers need to be saved for OFF mode
; 1201 :                 HalContextUpdateDirtyRegister(HAL_CONTEXTSAVE_GPIO);
; 1202 : 
; 1203 :                 rc = TRUE;
; 1204 :             }
; 1205 :         }
; 1206 :         break;

  00448	ea000042	 b           |$LN126@OmapGpioIo|
  0044c		 |$LN17@OmapGpioIo|

; 1103 :             rc = TRUE;
; 1104 :         }
; 1105 :         break;
; 1106 : 
; 1107 :     case IOCTL_GPIO_GET_POWER_STATE:
; 1108 :         {
; 1109 :             if ((pInBuffer == NULL) || (pOutBuffer == NULL) ||
; 1110 :                 inSize != sizeof(IOCTL_GPIO_POWER_STATE_IN) ||
; 1111 :                 outSize != sizeof(IOCTL_GPIO_GET_POWER_STATE_OUT))

  0044c	e3560000	 cmp         r6, #0
  00450	0a000053	 beq         |$LN15@OmapGpioIo|
  00454	e59d407c	 ldr         r4, [sp, #0x7C]
  00458	e3540000	 cmp         r4, #0
  0045c	0a000050	 beq         |$LN15@OmapGpioIo|
  00460	e3570008	 cmp         r7, #8
  00464	1a00004e	 bne         |$LN15@OmapGpioIo|
  00468	e59d3080	 ldr         r3, [sp, #0x80]
  0046c	e3530008	 cmp         r3, #8
  00470	1a00004b	 bne         |$LN15@OmapGpioIo|

; 1118 :             }
; 1119 : 
; 1120 :             IOCTL_GPIO_POWER_STATE_IN *pPowerIn;
; 1121 :             IOCTL_GPIO_GET_POWER_STATE_OUT *pPowerOut;
; 1122 : 
; 1123 :             pPowerIn = (IOCTL_GPIO_POWER_STATE_IN*)pInBuffer;
; 1124 :             pPowerOut = (IOCTL_GPIO_GET_POWER_STATE_OUT*)pOutBuffer;
; 1125 : 
; 1126 :             bit = GPIO_BIT(pPowerIn->gpioId);

  00474	e5961000	 ldr         r1, [r6]

; 1127 :             bank = GPIO_BANK(pPowerIn->gpioId);
; 1128 : 
; 1129 :             // get power state for gpio
; 1130 :             CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;

  00478	e595300c	 ldr         r3, [r5, #0xC]

; 1131 :             if (pDevice->fPostInit) EnterCriticalSection(pCs);

  0047c	e5952008	 ldr         r2, [r5, #8]
  00480	e1a082a1	 mov         r8, r1, lsr #5
  00484	e0839288	 add         r9, r3, r8, lsl #5
  00488	e3520000	 cmp         r2, #0
  0048c	12890004	 addne       r0, r9, #4
  00490	e201a01f	 and         r10, r1, #0x1F
  00494	1b000000	 blne        EnterCriticalSection

; 1132 :             pPowerOut->gpioState = (pDevice->bank[bank].powerEnabled & (1 << bit)) ? D0 : D4;

  00498	e595300c	 ldr         r3, [r5, #0xC]
  0049c	e3a02001	 mov         r2, #1
  004a0	e7933288	 ldr         r3, [r3, +r8, lsl #5]
  004a4	e1130a12	 tst         r3, r2, lsl r10
  004a8	13a03000	 movne       r3, #0
  004ac	03a03004	 moveq       r3, #4
  004b0	e5843000	 str         r3, [r4]

; 1133 :             pPowerOut->bankState = (pDevice->bank[bank].powerEnabled) ? D0 : D4;

  004b4	e595300c	 ldr         r3, [r5, #0xC]
  004b8	e7933288	 ldr         r3, [r3, +r8, lsl #5]
  004bc	e3530000	 cmp         r3, #0
  004c0	13a03000	 movne       r3, #0
  004c4	03a03004	 moveq       r3, #4
  004c8	e5843004	 str         r3, [r4, #4]

; 1134 :             if (pDevice->fPostInit) LeaveCriticalSection(pCs);

  004cc	e5953008	 ldr         r3, [r5, #8]
  004d0	e3530000	 cmp         r3, #0
  004d4	12890004	 addne       r0, r9, #4
  004d8	1b000000	 blne        LeaveCriticalSection

; 1135 : 
; 1136 :             rc = TRUE;

  004dc	e3a04001	 mov         r4, #1
  004e0	ea000000	 b           |$LN12@OmapGpioIo|
  004e4		 |$LN117@OmapGpioIo|

; 840  : {

  004e4	e3a04000	 mov         r4, #0
  004e8		 |$LN12@OmapGpioIo|

; 1137 :         }
; 1138 : 
; 1139 :     case IOCTL_GPIO_SET_DEBOUNCE_TIME:
; 1140 :         {
; 1141 :             if ((pInBuffer == NULL) ||
; 1142 :                 (inSize < sizeof(IOCTL_GPIO_SET_DEBOUNCE_TIME_IN)))

  004e8	e3560000	 cmp         r6, #0
  004ec	0a000029	 beq         |$LN10@OmapGpioIo|
  004f0	e3570008	 cmp         r7, #8
  004f4	3a000027	 bcc         |$LN10@OmapGpioIo|

; 1146 :             }
; 1147 : 
; 1148 :             IOCTL_GPIO_SET_DEBOUNCE_TIME_IN *pDebounce;
; 1149 : 
; 1150 :             pDebounce = (IOCTL_GPIO_SET_DEBOUNCE_TIME_IN*)pInBuffer;
; 1151 : 
; 1152 :             if (pDebounce->gpioId < pDevice->nbBanks*32)

  004f8	e5961000	 ldr         r1, [r6]
  004fc	e5953004	 ldr         r3, [r5, #4]
  00500	e1510283	 cmp         r1, r3, lsl #5
  00504	2a00006b	 bcs         |$cleanUp$37338|

; 1153 :             {
; 1154 :                 CRITICAL_SECTION *pCs;
; 1155 :                 bank = GPIO_BANK(pDebounce->gpioId);
; 1156 :                 pCs = &pDevice->bank[bank].pCs;

  00508	e595200c	 ldr         r2, [r5, #0xC]

; 1157 :                 if (pDevice->fPostInit) EnterCriticalSection(pCs);

  0050c	e5953008	 ldr         r3, [r5, #8]
  00510	e1a072a1	 mov         r7, r1, lsr #5
  00514	e0824287	 add         r4, r2, r7, lsl #5
  00518	e3530000	 cmp         r3, #0
  0051c	12840004	 addne       r0, r4, #4
  00520	1b000000	 blne        EnterCriticalSection

; 1158 :                 InternalSetGpioBankPowerState(pDevice, pDebounce->gpioId, D0);

  00524	e5963000	 ldr         r3, [r6]
  00528	e595200c	 ldr         r2, [r5, #0xC]
  0052c	e1a032a3	 mov         r3, r3, lsr #5
  00530	e7b23283	 ldr         r3, [r2, +r3, lsl #5]!
  00534	e3530000	 cmp         r3, #0
  00538	0592001c	 ldreq       r0, [r2, #0x1C]
  0053c	03a01001	 moveq       r1, #1
  00540	0b000000	 bleq        EnableDeviceClocks

; 1159 :                 OUTREG32(&pDevice->bank[bank].ppGpioRegs->DEBOUNCINGTIME,
; 1160 :                     pDebounce->debounceTime);

  00544	e595300c	 ldr         r3, [r5, #0xC]
  00548	e5962004	 ldr         r2, [r6, #4]
  0054c	e0833287	 add         r3, r3, r7, lsl #5
  00550	e5933018	 ldr         r3, [r3, #0x18]
  00554	e5832054	 str         r2, [r3, #0x54]
  00558		 |$LN126@OmapGpioIo|

; 1161 :                 InternalSetGpioBankPowerState(pDevice, pDebounce->gpioId, D4);

  00558	e5963000	 ldr         r3, [r6]
  0055c	e595200c	 ldr         r2, [r5, #0xC]
  00560	e1a032a3	 mov         r3, r3, lsr #5
  00564	e7b23283	 ldr         r3, [r2, +r3, lsl #5]!
  00568	e3530000	 cmp         r3, #0
  0056c	0592001c	 ldreq       r0, [r2, #0x1C]
  00570	03a01000	 moveq       r1, #0
  00574	0b000000	 bleq        EnableDeviceClocks

; 1162 :                 if (pDevice->fPostInit) LeaveCriticalSection(pCs);

  00578	e5953008	 ldr         r3, [r5, #8]
  0057c	e3530000	 cmp         r3, #0
  00580	12840004	 addne       r0, r4, #4
  00584	1b000000	 blne        LeaveCriticalSection

; 1163 : 
; 1164 :                 // indicate gpio registers need to be saved for OFF mode
; 1165 :                 HalContextUpdateDirtyRegister(HAL_CONTEXTSAVE_GPIO);

  00588	e3a00001	 mov         r0, #1
  0058c	eb000000	 bl          HalContextUpdateDirtyRegister
  00590	e3a04001	 mov         r4, #1
  00594	ea000047	 b           |$cleanUp$37338|
  00598		 |$LN10@OmapGpioIo|

; 1143 :             {
; 1144 :                 SetLastError(ERROR_INVALID_PARAMETER);

  00598	e3a00057	 mov         r0, #0x57
  0059c	eb000000	 bl          SetLastError

; 1145 :                 break;

  005a0	ea000044	 b           |$cleanUp$37338|
  005a4		 |$LN15@OmapGpioIo|

; 1112 :             {
; 1113 :                 SetLastError(ERROR_INVALID_PARAMETER);

  005a4	e3a00057	 mov         r0, #0x57
  005a8	eb000000	 bl          SetLastError

; 1114 :                 ERRORMSG(ZONE_ERROR, (L"ERROR: OmapGpioIOControl: "
; 1115 :                     L"IOCTL_GPIO_SET_POWER_STATE - Invalid parameter\r\n"
; 1116 :                     ));

  005ac	e59f3120	 ldr         r3, [pc, #0x120]
  005b0	e5933440	 ldr         r3, [r3, #0x440]
  005b4	e3130001	 tst         r3, #1
  005b8	0a00003d	 beq         |$LN116@OmapGpioIo|
  005bc	e3a03b01	 mov         r3, #1, 22
  005c0	e383205c	 orr         r2, r3, #0x5C

; 1117 :                 break;

  005c4	ea000035	 b           |$LN127@OmapGpioIo|
  005c8		 |$LN22@OmapGpioIo|

; 988  :         }
; 989  :         rc = TRUE;
; 990  :         break;
; 991  :         /*
; 992  :         case IOCTL_GPIO_GETIRQ:
; 993  :         if (pOutSize != 0) *pOutSize = sizeof(DWORD);
; 994  :         if ((pInBuffer == NULL) || (inSize < sizeof(DWORD)) ||
; 995  :         !CeSafeCopyMemory(&id, pInBuffer, sizeof(DWORD)) ||
; 996  :         (pOutBuffer == NULL) || (outSize < sizeof(DWORD)))
; 997  :         {
; 998  :         SetLastError(ERROR_INVALID_PARAMETER);
; 999  :         break;
; 1000 :         }
; 1001 :         value = OmapGpioGetSystemIrq(context, id);
; 1002 :         if (!CeSafeCopyMemory(pOutBuffer, &value, sizeof(value)))
; 1003 :         {
; 1004 :         SetLastError(ERROR_INVALID_PARAMETER);
; 1005 :         break;
; 1006 :         }
; 1007 :         rc = TRUE;
; 1008 :         break;
; 1009 : 
; 1010 :         case IOCTL_GPIO_INIT_INTERRUPT:
; 1011 :         if ((pInBuffer == NULL) || (inSize != sizeof(IOCTL_GPIO_INIT_INTERRUPT_INFO)))
; 1012 :         {
; 1013 :         SetLastError(ERROR_INVALID_PARAMETER);
; 1014 :         break;
; 1015 :         }
; 1016 :         else
; 1017 :         {
; 1018 :         HANDLE      hLocalEvent         = INVALID_HANDLE_VALUE;
; 1019 :         HANDLE      hCallerHandle       = GetCallerProcess();
; 1020 :         HANDLE      hCurrentProcHandle  = GetCurrentProcess();
; 1021 :         PIOCTL_GPIO_INIT_INTERRUPT_INFO pInitIntrInfo = (PIOCTL_GPIO_INIT_INTERRUPT_INFO)pInBuffer;
; 1022 : 
; 1023 :         if (hCurrentProcHandle != hCallerHandle)
; 1024 :         {
; 1025 :         BOOL    bStatus;
; 1026 : 
; 1027 :         bStatus = DuplicateHandle(hCallerHandle, pInitIntrInfo->hEvent,
; 1028 :         hCurrentProcHandle, &hLocalEvent,
; 1029 :         DUPLICATE_SAME_ACCESS,
; 1030 :         FALSE,
; 1031 :         DUPLICATE_SAME_ACCESS);
; 1032 : 
; 1033 :         if ((bStatus == FALSE) || (hLocalEvent == INVALID_HANDLE_VALUE))
; 1034 :         {
; 1035 :         RETAILMSG(1, (TEXT("GIO_IOControl: IOCTL_GPIO_INIT_INTERRUPT unable to duplicate event handle.\r\n")));
; 1036 :         break;
; 1037 :         }
; 1038 :         }
; 1039 :         else
; 1040 :         {
; 1041 :         hLocalEvent = pInitIntrInfo->hEvent;
; 1042 :         if (hLocalEvent == INVALID_HANDLE_VALUE)
; 1043 :         {
; 1044 :         SetLastError(ERROR_INVALID_PARAMETER);
; 1045 :         break;
; 1046 :         }
; 1047 :         }
; 1048 : 
; 1049 :         rc = InterruptInitialize(pInitIntrInfo->dwSysIntrID, hLocalEvent, NULL, 0);
; 1050 :         CloseHandle(hLocalEvent);
; 1051 :         }
; 1052 :         break;
; 1053 : 
; 1054 :         case IOCTL_GPIO_ACK_INTERRUPT:
; 1055 :         if ((pInBuffer == NULL) || (inSize != sizeof(IOCTL_GPIO_INTERRUPT_INFO)))
; 1056 :         {
; 1057 :         SetLastError(ERROR_INVALID_PARAMETER);
; 1058 :         break;
; 1059 :         }
; 1060 :         else
; 1061 :         {
; 1062 :         PIOCTL_GPIO_INTERRUPT_INFO pIntrInfo = (PIOCTL_GPIO_INTERRUPT_INFO)pInBuffer;
; 1063 : 
; 1064 :         rc = OmapGpioInterruptDone(context, pIntrInfo->uGpioID, pIntrInfo->dwSysIntrID);
; 1065 :         }
; 1066 :         break;
; 1067 : 
; 1068 :         case IOCTL_GPIO_DISABLE_INTERRUPT:
; 1069 :         if ((pInBuffer == NULL) || (inSize != sizeof(IOCTL_GPIO_INTERRUPT_INFO)))
; 1070 :         {
; 1071 :         SetLastError(ERROR_INVALID_PARAMETER);
; 1072 :         break;
; 1073 :         }
; 1074 :         else
; 1075 :         {
; 1076 :         PIOCTL_GPIO_INTERRUPT_INFO pIntrInfo = (PIOCTL_GPIO_INTERRUPT_INFO)pInBuffer;
; 1077 : 
; 1078 :         rc = OmapGpioInterruptDisable(context, pIntrInfo->uGpioID, pIntrInfo->dwSysIntrID);
; 1079 :         }
; 1080 :         break;
; 1081 :         }
; 1082 :         */
; 1083 :     case IOCTL_GPIO_SET_POWER_STATE:
; 1084 :         {
; 1085 :             if ((pInBuffer == NULL) || inSize != sizeof(IOCTL_GPIO_POWER_STATE_IN))

  005c8	e3560000	 cmp         r6, #0
  005cc	0a00002b	 beq         |$LN20@OmapGpioIo|
  005d0	e3570008	 cmp         r7, #8
  005d4	1a000029	 bne         |$LN20@OmapGpioIo|

; 1091 :                 break;
; 1092 :             }
; 1093 : 
; 1094 :             IOCTL_GPIO_POWER_STATE_IN *pPowerIn;
; 1095 :             pPowerIn = (IOCTL_GPIO_POWER_STATE_IN*)pInBuffer;
; 1096 : 
; 1097 :             bank = GPIO_BANK(pPowerIn->gpioId);

  005d8	e5963000	 ldr         r3, [r6]

; 1098 : 
; 1099 :             CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;

  005dc	e595200c	 ldr         r2, [r5, #0xC]

; 1100 :             if (pDevice->fPostInit) EnterCriticalSection(pCs);

  005e0	e5951008	 ldr         r1, [r5, #8]
  005e4	e1a032a3	 mov         r3, r3, lsr #5
  005e8	e0824283	 add         r4, r2, r3, lsl #5
  005ec	e3510000	 cmp         r1, #0
  005f0	12840004	 addne       r0, r4, #4
  005f4	1b000000	 blne        EnterCriticalSection

; 1101 :             SetGpioBankPowerState(pDevice, pPowerIn->gpioId, pPowerIn->state);

  005f8	e5961000	 ldr         r1, [r6]
  005fc	e5962004	 ldr         r2, [r6, #4]
  00600	e595300c	 ldr         r3, [r5, #0xC]
  00604	e1a002a1	 mov         r0, r1, lsr #5
  00608	e3520003	 cmp         r2, #3
  0060c	e793e280	 ldr         lr, [r3, +r0, lsl #5]
  00610	e1a02003	 mov         r2, r3
  00614	e7b23280	 ldr         r3, [r2, +r0, lsl #5]!
  00618	e201101f	 and         r1, r1, #0x1F
  0061c	b1813003	 orrlt       r3, r1, r3
  00620	a1c33001	 bicge       r3, r3, r1
  00624	e5823000	 str         r3, [r2]
  00628	e595200c	 ldr         r2, [r5, #0xC]
  0062c	e35e0000	 cmp         lr, #0
  00630	03a01001	 moveq       r1, #1
  00634	e7b23280	 ldr         r3, [r2, +r0, lsl #5]!
  00638	13a01000	 movne       r1, #0
  0063c	e1b00003	 movs        r0, r3
  00640	03a03001	 moveq       r3, #1
  00644	13a03000	 movne       r3, #0
  00648	e1510003	 cmp         r1, r3
  0064c	0a000004	 beq         |$LN77@OmapGpioIo|
  00650	e3500000	 cmp         r0, #0
  00654	e592001c	 ldr         r0, [r2, #0x1C]
  00658	03a01000	 moveq       r1, #0
  0065c	13a01001	 movne       r1, #1
  00660	eb000000	 bl          EnableDeviceClocks
  00664		 |$LN77@OmapGpioIo|

; 1102 :             if (pDevice->fPostInit) LeaveCriticalSection(pCs);

  00664	e5953008	 ldr         r3, [r5, #8]
  00668	e3530000	 cmp         r3, #0
  0066c	0affff28	 beq         |$LN121@OmapGpioIo|
  00670	e2840004	 add         r0, r4, #4
  00674	eb000000	 bl          LeaveCriticalSection
  00678	e3a04001	 mov         r4, #1
  0067c	ea00000d	 b           |$cleanUp$37338|
  00680		 |$LN20@OmapGpioIo|

; 1086 :             {
; 1087 :                 SetLastError(ERROR_INVALID_PARAMETER);

  00680	e3a00057	 mov         r0, #0x57
  00684	eb000000	 bl          SetLastError

; 1088 :                 ERRORMSG(ZONE_ERROR, (L"ERROR: OmapGpioIOControl: "
; 1089 :                     L"IOCTL_GPIO_SET_POWER_STATE - Invalid parameter\r\n"
; 1090 :                     ));

  00688	e59f3044	 ldr         r3, [pc, #0x44]
  0068c	e5933440	 ldr         r3, [r3, #0x440]
  00690	e3130001	 tst         r3, #1
  00694	0a000006	 beq         |$LN116@OmapGpioIo|
  00698	e3a03b01	 mov         r3, #1, 22
  0069c	e3832042	 orr         r2, r3, #0x42
  006a0		 |$LN127@OmapGpioIo|
  006a0	e59f1028	 ldr         r1, [pc, #0x28]
  006a4	e59f0020	 ldr         r0, [pc, #0x20]
  006a8	eb000000	 bl          NKDbgPrintfW
  006ac	e59f0014	 ldr         r0, [pc, #0x14]
  006b0	eb000000	 bl          NKDbgPrintfW
  006b4		 |$LN116@OmapGpioIo|

; 840  : {

  006b4	e3a04000	 mov         r4, #0

; 1088 :                 ERRORMSG(ZONE_ERROR, (L"ERROR: OmapGpioIOControl: "
; 1089 :                     L"IOCTL_GPIO_SET_POWER_STATE - Invalid parameter\r\n"
; 1090 :                     ));

  006b8		 |$cleanUp$37338|

; 1207 :     }
; 1208 : 
; 1209 : cleanUp:
; 1210 :     DEBUGMSG(ZONE_FUNCTION, (L"-OmapGpioIOControl(rc = %d)\r\n", rc));
; 1211 :     return rc;
; 1212 : #endif
; 1213 : 
; 1214 : #ifdef OAL
; 1215 :     UNREFERENCED_PARAMETER(context);
; 1216 :     UNREFERENCED_PARAMETER(code);
; 1217 :     UNREFERENCED_PARAMETER(pInBuffer);
; 1218 :     UNREFERENCED_PARAMETER(inSize);
; 1219 :     UNREFERENCED_PARAMETER(pOutBuffer);
; 1220 :     UNREFERENCED_PARAMETER(outSize);
; 1221 :     UNREFERENCED_PARAMETER(pOutSize);        
; 1222 :     return FALSE;
; 1223 : #endif
; 1224 : }

  006b8	e1a00004	 mov         r0, r4
  006bc	e28dd058	 add         sp, sp, #0x58
  006c0	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  006c4	e12fff1e	 bx          lr
  006c8		 |$LN131@OmapGpioIo|
  006c8		 |$LN132@OmapGpioIo|
  006c8	00000000	 DCD         |??_C@_1JG@DHGGDOFN@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAI?$AAO?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AA?3?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_@|
  006cc		 |$LN133@OmapGpioIo|
  006cc	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  006d0		 |$LN134@OmapGpioIo|
  006d0	00000000	 DCD         |??_C@_1MM@BOONICNJ@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  006d4		 |$LN135@OmapGpioIo|
  006d4	00000000	 DCD         |dpCurSettings|
  006d8		 |$LN136@OmapGpioIo|
  006d8	00220c24	 DCD         0x220c24
  006dc		 |$LN137@OmapGpioIo|
  006dc	00220c1c	 DCD         0x220c1c
  006e0		 |$LN138@OmapGpioIo|
  006e0	00000000	 DCD         |?OmapGpioGetSystemIrq@@YAKPAXI@Z|
  006e4		 |$LN139@OmapGpioIo|
  006e4	00000000	 DCD         |?OmapGpioInterruptDone@@YAXPAXKK@Z|
  006e8		 |$LN140@OmapGpioIo|
  006e8	00000000	 DCD         |?OmapGpioInterruptDisable@@YAXPAXKK@Z|
  006ec		 |$LN141@OmapGpioIo|
  006ec	00000000	 DCD         |?OmapGpioInterruptMask@@YAXPAXKKH@Z|
  006f0		 |$LN142@OmapGpioIo|
  006f0	00000000	 DCD         |?OmapGpioInterruptInitialize@@YAHPAXKPAK0@Z|
  006f4		 |$LN143@OmapGpioIo|
  006f4	00000000	 DCD         |?OmapGpioPulldown@@YAHPAXII@Z|
  006f8		 |$LN144@OmapGpioIo|
  006f8	00000000	 DCD         |?OmapGpioPullup@@YAHPAXII@Z|
  006fc		 |$LN145@OmapGpioIo|
  006fc	00000000	 DCD         |?OmapGpioGetMode@@YAKPAXI@Z|
  00700		 |$LN146@OmapGpioIo|
  00700	00000000	 DCD         |?OmapGpioSetMode@@YAHPAXII@Z|
  00704		 |$LN147@OmapGpioIo|
  00704	00000000	 DCD         |?OmapGpioGetBit@@YAKPAXI@Z|
  00708		 |$LN148@OmapGpioIo|
  00708	00000000	 DCD         |?OmapGpioIoControl@@YAHPAXIPAEI1IPAK@Z|
  0070c		 |$LN149@OmapGpioIo|
  0070c	00000000	 DCD         |?OmapGpioClrBit@@YAHPAXI@Z|
  00710		 |$LN150@OmapGpioIo|
  00710	00000000	 DCD         |?OmapGpioInterruptWakeUp@@YAHPAXKKH@Z|
  00714		 |$LN151@OmapGpioIo|
  00714	00000000	 DCD         |?OmapGpioSetBit@@YAHPAXI@Z|
  00718		 |$LN152@OmapGpioIo|
  00718	00000000	 DCD         |DEVICE_IFC_GPIO_GUID|
  0071c		 |$LN153@OmapGpioIo|
  0071c	00220c0c	 DCD         0x220c0c
  00720		 |$LN154@OmapGpioIo|
  00720	00220c04	 DCD         0x220c04
  00724		 |$LN155@OmapGpioIo|
  00724	00220c14	 DCD         0x220c14
  00728		 |$LN156@OmapGpioIo|
  00728	11223344	 DCD         0x11223344
  0072c		 |$M38213|

			 ENDP  ; |?OmapGpioIoControl@@YAHPAXIPAEI1IPAK@Z|, OmapGpioIoControl

	EXPORT	|?GIO_Init@@YAKPBGK@Z|			; GIO_Init

  00000			 AREA	 |.pdata|, PDATA
|$T38252| DCD	|$LN7@GIO_Init|
	DCD	0x40001102
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GIO_Init@@YAKPBGK@Z| PROC		; GIO_Init

; 1371 : {

  00000		 |$LN7@GIO_Init|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M38249|

; 1372 :     HANDLE devCtxt;
; 1373 :     UINT count;
; 1374 : 
; 1375 :     UNREFERENCED_PARAMETER(dwBusContext);
; 1376 : 
; 1377 :     if (OmapGpioInit(pContext,&devCtxt,&count))

  00008	e28d2004	 add         r2, sp, #4
  0000c	e28d1000	 add         r1, sp, #0
  00010	eb000000	 bl          |?OmapGpioInit@@YAHPBGPAPAXPAI@Z|
  00014	e3500000	 cmp         r0, #0
  00018	0a000004	 beq         |$LN1@GIO_Init|

; 1378 :     {
; 1379 :         if (OmapGpioPostInit(devCtxt))

  0001c	e59d4000	 ldr         r4, [sp]
  00020	e1a00004	 mov         r0, r4
  00024	eb000000	 bl          |?OmapGpioPostInit@@YAHPAX@Z|
  00028	e3500000	 cmp         r0, #0

; 1380 :         {
; 1381 :             return (DWORD) devCtxt;

  0002c	1a000000	 bne         |$LN3@GIO_Init|
  00030		 |$LN1@GIO_Init|

; 1382 :         }
; 1383 :     }
; 1384 :     return NULL;

  00030	e3a04000	 mov         r4, #0
  00034		 |$LN3@GIO_Init|

; 1385 : }

  00034	e1a00004	 mov         r0, r4
  00038	e28dd008	 add         sp, sp, #8
  0003c	e8bd4010	 ldmia       sp!, {r4, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M38250|

			 ENDP  ; |?GIO_Init@@YAKPBGK@Z|, GIO_Init

	EXPORT	|?GIO_IOControl@@YAHKKPAEK0KPAK@Z|	; GIO_IOControl

  00000			 AREA	 |.pdata|, PDATA
|$T38265| DCD	|$LN5@GIO_IOCont|
	DCD	0x40000c02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GIO_IOControl@@YAHKKPAEK0KPAK@Z| PROC ; GIO_IOControl

; 1437 : {

  00000		 |$LN5@GIO_IOCont|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M38262|

; 1438 :     return OmapGpioIoControl(
; 1439 :         (HANDLE)hOpenContext,
; 1440 :         dwCode,
; 1441 :         pBufIn,
; 1442 :         dwLenIn,
; 1443 :         pBufOut,
; 1444 :         dwLenOut,
; 1445 :         pdwActualOut 
; 1446 :         );

  00008	e59de020	 ldr         lr, [sp, #0x20]
  0000c	e59d401c	 ldr         r4, [sp, #0x1C]
  00010	e59d5018	 ldr         r5, [sp, #0x18]
  00014	e58de008	 str         lr, [sp, #8]
  00018	e58d4004	 str         r4, [sp, #4]
  0001c	e58d5000	 str         r5, [sp]
  00020	eb000000	 bl          |?OmapGpioIoControl@@YAHPAXIPAEI1IPAK@Z|

; 1447 : }

  00024	e28dd00c	 add         sp, sp, #0xC
  00028	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$M38263|

			 ENDP  ; |?GIO_IOControl@@YAHKKPAEK0KPAK@Z|, GIO_IOControl

	END
