; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\WAVEDEV2\input.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|?Open@InputStreamContext@@UAAKPAVDeviceContext@@PAUwaveopendesc_tag@@K@Z| ; InputStreamContext::Open
	IMPORT	|?Open@WaveStreamContext@@UAAKPAVDeviceContext@@PAUwaveopendesc_tag@@K@Z| ; WaveStreamContext::Open
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\wavedev2\input.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T35352| DCD	|$LN5@Open|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Open@InputStreamContext@@UAAKPAVDeviceContext@@PAUwaveopendesc_tag@@K@Z| PROC ; InputStreamContext::Open

; 25   : {

  00000		 |$LN5@Open|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M35349|
  00004	e1a04000	 mov         r4, r0

; 26   :     DWORD mmRet;
; 27   : 
; 28   :     mmRet = WaveStreamContext::Open(pDeviceContext, lpWOD, dwFlags);

  00008	eb000000	 bl          |?Open@WaveStreamContext@@UAAKPAVDeviceContext@@PAUwaveopendesc_tag@@K@Z|

; 29   : 
; 30   :     // Init m_CurrPos to force us to read the first sample
; 31   :     m_CurrPos = -(LONG)m_ClientRate;

  0000c	e594308c	 ldr         r3, [r4, #0x8C]

; 32   : 
; 33   :     return mmRet;
; 34   : }

  00010	e2633000	 rsb         r3, r3, #0
  00014	e5843088	 str         r3, [r4, #0x88]
  00018	e8bd4010	 ldmia       sp!, {r4, lr}
  0001c	e12fff1e	 bx          lr
  00020		 |$M35350|

			 ENDP  ; |?Open@InputStreamContext@@UAAKPAVDeviceContext@@PAUwaveopendesc_tag@@K@Z|, InputStreamContext::Open

	EXPORT	|?DoCallbackReturnBuffer@InputStreamContext@@UAAXPAUwavehdr_tag@@@Z| ; InputStreamContext::DoCallbackReturnBuffer
	IMPORT	|?DoDriverCallback@StreamContext@@QAAXIKK@Z| ; StreamContext::DoDriverCallback

  00000			 AREA	 |.pdata|, PDATA
|$T35361| DCD	|$LN5@DoCallback|
	DCD	0x40000701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DoCallbackReturnBuffer@InputStreamContext@@UAAXPAUwavehdr_tag@@@Z| PROC ; InputStreamContext::DoCallbackReturnBuffer

; 37   : {

  00000		 |$LN5@DoCallback|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M35358|
  00004	e1a02001	 mov         r2, r1

; 38   :     DoDriverCallback(WIM_DATA,(DWORD)lpHdr,0);

  00008	e3a03000	 mov         r3, #0
  0000c	e3a01d0f	 mov         r1, #0xF, 26
  00010	eb000000	 bl          |?DoDriverCallback@StreamContext@@QAAXIKK@Z|

; 39   : }

  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$M35359|

			 ENDP  ; |?DoCallbackReturnBuffer@InputStreamContext@@UAAXPAUwavehdr_tag@@@Z|, InputStreamContext::DoCallbackReturnBuffer

	EXPORT	|?DoCallbackStreamOpened@InputStreamContext@@UAAXXZ| ; InputStreamContext::DoCallbackStreamOpened

  00000			 AREA	 |.pdata|, PDATA
|$T35369| DCD	|$LN5@DoCallback@2|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DoCallbackStreamOpened@InputStreamContext@@UAAXXZ| PROC ; InputStreamContext::DoCallbackStreamOpened

; 42   : {

  00000		 |$LN5@DoCallback@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M35366|
  00004	e3a03c03	 mov         r3, #3, 24

; 43   :     DoDriverCallback(WIM_OPEN,0,0);

  00008	e38310be	 orr         r1, r3, #0xBE
  0000c	e3a03000	 mov         r3, #0
  00010	e3a02000	 mov         r2, #0
  00014	eb000000	 bl          |?DoDriverCallback@StreamContext@@QAAXIKK@Z|

; 44   : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$M35367|

			 ENDP  ; |?DoCallbackStreamOpened@InputStreamContext@@UAAXXZ|, InputStreamContext::DoCallbackStreamOpened

	EXPORT	|?DoCallbackStreamClosed@InputStreamContext@@UAAXXZ| ; InputStreamContext::DoCallbackStreamClosed

  00000			 AREA	 |.pdata|, PDATA
|$T35377| DCD	|$LN5@DoCallback@3|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DoCallbackStreamClosed@InputStreamContext@@UAAXXZ| PROC ; InputStreamContext::DoCallbackStreamClosed

; 47   : {

  00000		 |$LN5@DoCallback@3|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M35374|
  00004	e3a03c03	 mov         r3, #3, 24

; 48   :     DoDriverCallback(WIM_CLOSE,0,0);

  00008	e38310bf	 orr         r1, r3, #0xBF
  0000c	e3a03000	 mov         r3, #0
  00010	e3a02000	 mov         r2, #0
  00014	eb000000	 bl          |?DoDriverCallback@StreamContext@@QAAXIKK@Z|

; 49   : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$M35375|

			 ENDP  ; |?DoCallbackStreamClosed@InputStreamContext@@UAAXXZ|, InputStreamContext::DoCallbackStreamClosed

	EXPORT	|?Stop@InputStreamContext@@UAAKXZ|	; InputStreamContext::Stop
	IMPORT	|?GetNextBuffer@StreamContext@@QAAPAEXZ| ; StreamContext::GetNextBuffer
	IMPORT	|?Stop@StreamContext@@UAAKXZ|		; StreamContext::Stop

  00000			 AREA	 |.pdata|, PDATA
|$T35387| DCD	|$LN6@Stop|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Stop@InputStreamContext@@UAAKXZ| PROC ; InputStreamContext::Stop

; 52   : {

  00000		 |$LN6@Stop|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M35384|
  00004	e1a04000	 mov         r4, r0

; 53   :     // Stop the stream
; 54   :     WaveStreamContext::Stop();

  00008	eb000000	 bl          |?Stop@StreamContext@@UAAKXZ|

; 55   : 
; 56   :     // Return any partially filled buffers to the client
; 57   :     if ((m_lpWaveHdrCurrent) && (m_lpWaveHdrCurrent->dwBytesRecorded>0))

  0000c	e594303c	 ldr         r3, [r4, #0x3C]
  00010	e3530000	 cmp         r3, #0
  00014	0a000003	 beq         |$LN1@Stop|
  00018	e5933008	 ldr         r3, [r3, #8]
  0001c	e3530000	 cmp         r3, #0

; 58   :     {
; 59   :         GetNextBuffer();

  00020	81a00004	 movhi       r0, r4
  00024	8b000000	 blhi        |?GetNextBuffer@StreamContext@@QAAPAEXZ|
  00028		 |$LN1@Stop|

; 60   :     }
; 61   : 
; 62   :     return MMSYSERR_NOERROR;

  00028	e3a00000	 mov         r0, #0

; 63   : }

  0002c	e8bd4010	 ldmia       sp!, {r4, lr}
  00030	e12fff1e	 bx          lr
  00034		 |$M35385|

			 ENDP  ; |?Stop@InputStreamContext@@UAAKXZ|, InputStreamContext::Stop

	EXPORT	|?Render2@InputStreamContext@@UAAPAEPAE00PAUTRANSFER_STATUS@@@Z| ; InputStreamContext::Render2
	IMPORT	|?GetBaseSampleRate@DeviceContext@@QAAKXZ| ; DeviceContext::GetBaseSampleRate

  00000			 AREA	 |.pdata|, PDATA
|$T35421| DCD	|$LN26@Render2|
	DCD	0x40006b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Render2@InputStreamContext@@UAAPAEPAE00PAUTRANSFER_STATUS@@@Z| PROC ; InputStreamContext::Render2

; 67   : {

  00000		 |$LN26@Render2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd01c	 sub         sp, sp, #0x1C
  00008		 |$M35418|
  00008	e58d2000	 str         r2, [sp]
  0000c	e1a06001	 mov         r6, r1
  00010	e1a04000	 mov         r4, r0

; 68   : 	UNREFERENCED_PARAMETER(pBufferLast);
; 69   : 	UNREFERENCED_PARAMETER(pTranferStatus);
; 70   : 
; 71   :     LONG CurrPos = m_CurrPos;
; 72   :     DWORD ClientRate = m_ClientRate;
; 73   :     DWORD ClientRateInv = m_ClientRateInv;
; 74   :     DWORD BaseRate = m_pDeviceContext->GetBaseSampleRate();

  00014	e594308c	 ldr         r3, [r4, #0x8C]
  00018	e5942090	 ldr         r2, [r4, #0x90]
  0001c	e5940050	 ldr         r0, [r4, #0x50]
  00020	e5947088	 ldr         r7, [r4, #0x88]
  00024	e58d3004	 str         r3, [sp, #4]
  00028	e58d2008	 str         r2, [sp, #8]
  0002c	eb000000	 bl          |?GetBaseSampleRate@DeviceContext@@QAAKXZ|

; 75   : 
; 76   :     PBYTE pCurrData = m_lpCurrData;
; 77   :     PBYTE pCurrDataEnd = m_lpCurrDataEnd;
; 78   : 
; 79   :     LONG fxpGain[2];
; 80   :     fxpGain[0] = m_fxpGain[0];

  00030	e5942060	 ldr         r2, [r4, #0x60]
  00034	e5945044	 ldr         r5, [r4, #0x44]
  00038	e5943048	 ldr         r3, [r4, #0x48]
  0003c	e58d200c	 str         r2, [sp, #0xC]

; 81   :     fxpGain[1] = m_fxpGain[1];

  00040	e5942064	 ldr         r2, [r4, #0x64]
  00044	e58d3018	 str         r3, [sp, #0x18]

; 82   : 
; 83   :     LONG CurrSamp0 = m_CurrSamp[0];
; 84   :     LONG PrevSamp0 = m_PrevSamp[0];
; 85   :     LONG CurrSamp1 = m_CurrSamp[1];
; 86   :     LONG PrevSamp1 = m_PrevSamp[1];
; 87   : 
; 88   :     for (;;)
; 89   :     {
; 90   :         // Make sure we have a place to put the data
; 91   :         if (pCurrData>=pCurrDataEnd)

  00048	e1550003	 cmp         r5, r3
  0004c	e5948080	 ldr         r8, [r4, #0x80]
  00050	e594a078	 ldr         r10, [r4, #0x78]
  00054	e5949084	 ldr         r9, [r4, #0x84]
  00058	e594b07c	 ldr         r11, [r4, #0x7C]
  0005c	e1a03000	 mov         r3, r0
  00060	e58d2010	 str         r2, [sp, #0x10]
  00064	e58d3014	 str         r3, [sp, #0x14]
  00068	2a00003a	 bcs         |$Exit$35278|
  0006c		 |$LL14@Render2|

; 92   :         {
; 93   :             goto Exit;
; 94   :         }
; 95   : 
; 96   :         // Get the next sample
; 97   :         while (CurrPos < 0)

  0006c	e3570000	 cmp         r7, #0
  00070	5a00000a	 bpl         |$LN9@Render2|
  00074	e59d3000	 ldr         r3, [sp]
  00078	e59d2004	 ldr         r2, [sp, #4]
  0007c		 |$LL10@Render2|

; 98   :         {
; 99   :             if (pBuffer>=pBufferEnd)

  0007c	e1560003	 cmp         r6, r3
  00080	2a000034	 bcs         |$Exit$35278|

; 100  :             {
; 101  :                 goto Exit;
; 102  :             }
; 103  : 
; 104  :             CurrPos += ClientRate;
; 105  : 
; 106  :             PrevSamp0 = CurrSamp0;

  00084	e1a0a008	 mov         r10, r8

; 107  :             PrevSamp1 = CurrSamp1;
; 108  : 
; 109  :             CurrSamp0 = ((HWSAMPLE *)pBuffer)[0];

  00088	e1d680f0	 ldrsh       r8, [r6]
  0008c	e1a0b009	 mov         r11, r9

; 110  :             CurrSamp1 = ((HWSAMPLE *)pBuffer)[1];

  00090	e1d690f2	 ldrsh       r9, [r6, #2]

; 111  :             pBuffer += 2*sizeof(HWSAMPLE);

  00094	e2866004	 add         r6, r6, #4
  00098	e0977002	 adds        r7, r7, r2
  0009c	4afffff6	 bmi         |$LL10@Render2|
  000a0		 |$LN9@Render2|

; 112  :         }
; 113  : 
; 114  :         // Calculate ratio between samples as a 17.15 fraction
; 115  :         // (Only use 15 bits to avoid overflow on next multiply)
; 116  :         LONG Ratio;
; 117  :         Ratio = (CurrPos * ClientRateInv)>>17;

  000a0	e59d2008	 ldr         r2, [sp, #8]

; 118  : 
; 119  :         CurrPos -= BaseRate;
; 120  : 
; 121  :         LONG InSamp0;
; 122  :         LONG InSamp1;
; 123  : 
; 124  :         // Calc difference between samples. Note InSamp0 is a 17-bit signed number now.
; 125  :         InSamp0 = PrevSamp0 - CurrSamp0;

  000a4	e04a1008	 sub         r1, r10, r8

; 126  :         InSamp1 = PrevSamp1- CurrSamp1;
; 127  : 
; 128  :         // Now interpolate
; 129  :         InSamp0 = (InSamp0 * Ratio) >> 15;
; 130  :         InSamp1 = (InSamp1 * Ratio) >> 15;
; 131  : 
; 132  :         // Add to previous sample
; 133  :         InSamp0 += CurrSamp0;
; 134  :         InSamp1 += CurrSamp1;
; 135  : 
; 136  :         // Apply input gain
; 137  :         InSamp0 = (InSamp0 * fxpGain[0]) >> 16;
; 138  :         InSamp1 = (InSamp1 * fxpGain[1]) >> 16;
; 139  : 
; 140  :         PPCM_SAMPLE pSampleDest = (PPCM_SAMPLE)pCurrData;
; 141  :         switch (m_SampleType)

  000a8	e594006c	 ldr         r0, [r4, #0x6C]
  000ac	e0030792	 mul         r3, r2, r7
  000b0	e3500001	 cmp         r0, #1
  000b4	e1a0e8a3	 mov         lr, r3, lsr #17
  000b8	e04b3009	 sub         r3, r11, r9
  000bc	e0020e91	 mul         r2, r1, lr
  000c0	e0010e93	 mul         r1, r3, lr
  000c4	e08837c2	 add         r3, r8, r2, asr #15
  000c8	e08927c1	 add         r2, r9, r1, asr #15
  000cc	e59d100c	 ldr         r1, [sp, #0xC]
  000d0	e0010193	 mul         r1, r3, r1
  000d4	e59d3010	 ldr         r3, [sp, #0x10]
  000d8	e0030392	 mul         r3, r2, r3
  000dc	e1a02841	 mov         r2, r1, asr #16
  000e0	e1a01843	 mov         r1, r3, asr #16
  000e4	e59d3014	 ldr         r3, [sp, #0x14]
  000e8	e0477003	 sub         r7, r7, r3
  000ec	0a000013	 beq         |$LN2@Render2|
  000f0	e3500002	 cmp         r0, #2
  000f4	0a000009	 beq         |$LN3@Render2|
  000f8	e3500003	 cmp         r0, #3

; 142  :         {
; 143  :         case PCM_TYPE_M8:
; 144  :         default:
; 145  :             pSampleDest->m8.sample = (UINT8)( ((InSamp0+InSamp1) >> 9) + 128);

  000fc	10813002	 addne       r3, r1, r2
  00100	11a034c3	 movne       r3, r3, asr #9
  00104	12833080	 addne       r3, r3, #0x80
  00108	14c53001	 strneb      r3, [r5], #1
  0010c	1a00000e	 bne         |$LN5@Render2|

; 157  :             pCurrData  += 2;
; 158  :             break;
; 159  : 
; 160  :         case PCM_TYPE_S16:
; 161  :             pSampleDest->s16.sample_left  = (INT16)InSamp0;

  00110	e1c520b0	 strh        r2, [r5]

; 162  :             pSampleDest->s16.sample_right = (INT16)InSamp1;

  00114	e1c510b2	 strh        r1, [r5, #2]

; 163  :             pCurrData  += 4;

  00118	e2855004	 add         r5, r5, #4

; 164  :             break;

  0011c	ea00000a	 b           |$LN5@Render2|
  00120		 |$LN3@Render2|

; 146  :             pCurrData  += 1;
; 147  :             break;
; 148  : 
; 149  :         case PCM_TYPE_S8:
; 150  :             pSampleDest->s8.sample_left  = (UINT8)((InSamp0 >> 8) + 128);

  00120	e1a03442	 mov         r3, r2, asr #8

; 151  :             pSampleDest->s8.sample_right = (UINT8)((InSamp1 >> 8) + 128);

  00124	e1a02441	 mov         r2, r1, asr #8
  00128	e2822080	 add         r2, r2, #0x80
  0012c	e2833080	 add         r3, r3, #0x80
  00130	e5c52001	 strb        r2, [r5, #1]
  00134	e5c53000	 strb        r3, [r5]

; 152  :             pCurrData  += 2;

  00138	e2855002	 add         r5, r5, #2

; 153  :             break;

  0013c	ea000002	 b           |$LN5@Render2|
  00140		 |$LN2@Render2|

; 154  : 
; 155  :         case PCM_TYPE_M16:
; 156  :             pSampleDest->m16.sample = (INT16)((InSamp0+InSamp1)>>1);

  00140	e0813002	 add         r3, r1, r2
  00144	e1a030c3	 mov         r3, r3, asr #1
  00148	e0c530b2	 strh        r3, [r5], #2
  0014c		 |$LN5@Render2|
  0014c	e59d3018	 ldr         r3, [sp, #0x18]
  00150	e1550003	 cmp         r5, r3
  00154	3affffc4	 bcc         |$LL14@Render2|
  00158		 |$Exit$35278|

; 165  :         }
; 166  :     }
; 167  : 
; 168  : Exit:
; 169  :     m_lpWaveHdrCurrent->dwBytesRecorded += (pCurrData-m_lpCurrData);

  00158	e594103c	 ldr         r1, [r4, #0x3C]
  0015c	e5943044	 ldr         r3, [r4, #0x44]

; 170  :     m_dwByteCount += (pCurrData-m_lpCurrData);
; 171  :     m_lpCurrData = pCurrData;
; 172  :     m_CurrPos = CurrPos;
; 173  :     m_PrevSamp[0] = PrevSamp0;
; 174  :     m_CurrSamp[0] = CurrSamp0;
; 175  :     m_PrevSamp[1] = PrevSamp1;
; 176  :     m_CurrSamp[1] = CurrSamp1;
; 177  :     return pBuffer;
; 178  : }

  00160	e1a00006	 mov         r0, r6
  00164	e5912008	 ldr         r2, [r1, #8]
  00168	e0453003	 sub         r3, r5, r3
  0016c	e0833002	 add         r3, r3, r2
  00170	e5813008	 str         r3, [r1, #8]
  00174	e594204c	 ldr         r2, [r4, #0x4C]
  00178	e5943044	 ldr         r3, [r4, #0x44]
  0017c	e5845044	 str         r5, [r4, #0x44]
  00180	e5847088	 str         r7, [r4, #0x88]
  00184	e0423003	 sub         r3, r2, r3
  00188	e0833005	 add         r3, r3, r5
  0018c	e584304c	 str         r3, [r4, #0x4C]
  00190	e584a078	 str         r10, [r4, #0x78]
  00194	e5848080	 str         r8, [r4, #0x80]
  00198	e584b07c	 str         r11, [r4, #0x7C]
  0019c	e5849084	 str         r9, [r4, #0x84]
  001a0	e28dd01c	 add         sp, sp, #0x1C
  001a4	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001a8	e12fff1e	 bx          lr
  001ac		 |$M35419|

			 ENDP  ; |?Render2@InputStreamContext@@UAAPAEPAE00PAUTRANSFER_STATUS@@@Z|, InputStreamContext::Render2

	EXPORT	|?ResetBaseInfo@InputStreamContext@@UAAXXZ| ; InputStreamContext::ResetBaseInfo

  00000			 AREA	 |.pdata|, PDATA
|$T35428| DCD	|$LN5@ResetBaseI|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResetBaseInfo@InputStreamContext@@UAAXXZ| PROC ; InputStreamContext::ResetBaseInfo

; 282  : {

  00000		 |$LN5@ResetBaseI|
  00000		 |$M35425|

; 283  :     return;
; 284  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M35426|

			 ENDP  ; |?ResetBaseInfo@InputStreamContext@@UAAXXZ|, InputStreamContext::ResetBaseInfo

	END
