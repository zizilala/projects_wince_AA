; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\WAVEDEV2\output.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|?Open@OutputStreamContext@@UAAKPAVDeviceContext@@PAUwaveopendesc_tag@@K@Z| ; OutputStreamContext::Open
	IMPORT	|?GetBaseSampleRate@DeviceContext@@QAAKXZ| ; DeviceContext::GetBaseSampleRate
	IMPORT	|?Open@WaveStreamContext@@UAAKPAVDeviceContext@@PAUwaveopendesc_tag@@K@Z| ; WaveStreamContext::Open
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\wavedev2\output.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T35572| DCD	|$LN6@Open|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Open@OutputStreamContext@@UAAKPAVDeviceContext@@PAUwaveopendesc_tag@@K@Z| PROC ; OutputStreamContext::Open

; 25   : {

  00000		 |$LN6@Open|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M35569|
  00004	e1a04000	 mov         r4, r0

; 26   :     DWORD mmRet;
; 27   : 
; 28   :     mmRet = WaveStreamContext::Open(pDeviceContext, lpWOD, dwFlags);

  00008	eb000000	 bl          |?Open@WaveStreamContext@@UAAKPAVDeviceContext@@PAUwaveopendesc_tag@@K@Z|
  0000c	e1a05000	 mov         r5, r0

; 29   : 
; 30   :     // Init m_CurrPos to force us to read the first sample
; 31   :     m_CurrPos = -(LONG)m_pDeviceContext->GetBaseSampleRate();

  00010	e5940050	 ldr         r0, [r4, #0x50]
  00014	eb000000	 bl          |?GetBaseSampleRate@DeviceContext@@QAAKXZ|
  00018	e2603000	 rsb         r3, r0, #0

; 32   : 
; 33   :     if (mmRet==MMSYSERR_NOERROR)

  0001c	e3550000	 cmp         r5, #0
  00020	e5843088	 str         r3, [r4, #0x88]

; 34   :     {
; 35   :         // Note: Output streams should be initialized in the run state.
; 36   :         Run();

  00024	05943000	 ldreq       r3, [r4]
  00028	01a00004	 moveq       r0, r4
  0002c	05933010	 ldreq       r3, [r3, #0x10]
  00030	01a0e00f	 moveq       lr, pc
  00034	012fff13	 bxeq        r3

; 37   :     }
; 38   : 
; 39   :     return mmRet;
; 40   : }

  00038	e1a00005	 mov         r0, r5
  0003c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M35570|

			 ENDP  ; |?Open@OutputStreamContext@@UAAKPAVDeviceContext@@PAUwaveopendesc_tag@@K@Z|, OutputStreamContext::Open

	EXPORT	|?Reset@OutputStreamContext@@UAAKXZ|	; OutputStreamContext::Reset
	IMPORT	|?Reset@StreamContext@@UAAKXZ|		; StreamContext::Reset

  00000			 AREA	 |.pdata|, PDATA
|$T35583| DCD	|$LN6@Reset|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Reset@OutputStreamContext@@UAAKXZ| PROC ; OutputStreamContext::Reset

; 43   : {

  00000		 |$LN6@Reset|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M35580|
  00004	e1a05000	 mov         r5, r0

; 44   :     HRESULT Result;
; 45   : 
; 46   :     Result = WaveStreamContext::Reset();

  00008	eb000000	 bl          |?Reset@StreamContext@@UAAKXZ|
  0000c	e1b04000	 movs        r4, r0

; 47   : 
; 48   :     if (Result==MMSYSERR_NOERROR)
; 49   :     {
; 50   :         // Note: Output streams should be reset to the run state.
; 51   :         Run();

  00010	05953000	 ldreq       r3, [r5]
  00014	01a00005	 moveq       r0, r5
  00018	05933010	 ldreq       r3, [r3, #0x10]
  0001c	01a0e00f	 moveq       lr, pc
  00020	012fff13	 bxeq        r3

; 52   :     }
; 53   : 
; 54   :     return Result;
; 55   : };

  00024	e1a00004	 mov         r0, r4
  00028	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$M35581|

			 ENDP  ; |?Reset@OutputStreamContext@@UAAKXZ|, OutputStreamContext::Reset

	EXPORT	|?ResetBaseInfo@OutputStreamContext@@UAAXXZ| ; OutputStreamContext::ResetBaseInfo

  00000			 AREA	 |.pdata|, PDATA
|$T35590| DCD	|$LN5@ResetBaseI|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResetBaseInfo@OutputStreamContext@@UAAXXZ| PROC ; OutputStreamContext::ResetBaseInfo

; 58   : {

  00000		 |$LN5@ResetBaseI|
  00000		 |$M35587|

; 59   :     return;
; 60   : }

  00000	e12fff1e	 bx          lr
  00004		 |$M35588|

			 ENDP  ; |?ResetBaseInfo@OutputStreamContext@@UAAXXZ|, OutputStreamContext::ResetBaseInfo

	EXPORT	|?Render2@OutputStreamContextM8@@UAAPAEPAE00PAUTRANSFER_STATUS@@@Z| ; OutputStreamContextM8::Render2
	IMPORT	|?GetBaseSampleRateInverse@DeviceContext@@QAAKXZ| ; DeviceContext::GetBaseSampleRateInverse

  00000			 AREA	 |.pdata|, PDATA
|$T35625| DCD	|$LN27@Render2|
	DCD	0x40006302
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Render2@OutputStreamContextM8@@UAAPAEPAE00PAUTRANSFER_STATUS@@@Z| PROC ; OutputStreamContextM8::Render2

; 64   : {

  00000		 |$LN27@Render2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd01c	 sub         sp, sp, #0x1C
  00008		 |$M35622|
  00008	e1a04000	 mov         r4, r0
  0000c	e58d4018	 str         r4, [sp, #0x18]
  00010	e58d3004	 str         r3, [sp, #4]
  00014	e58d2000	 str         r2, [sp]
  00018	e1a05001	 mov         r5, r1

; 65   :     LONG CurrPos = m_CurrPos;
; 66   :     DWORD ClientRate = m_ClientRate;
; 67   :     DWORD BaseRate = m_pDeviceContext->GetBaseSampleRate();

  0001c	e594308c	 ldr         r3, [r4, #0x8C]
  00020	e5940050	 ldr         r0, [r4, #0x50]
  00024	e5947088	 ldr         r7, [r4, #0x88]
  00028	e58d300c	 str         r3, [sp, #0xC]
  0002c	eb000000	 bl          |?GetBaseSampleRate@DeviceContext@@QAAKXZ|
  00030	e58d0008	 str         r0, [sp, #8]

; 68   :     DWORD BaseRateInv = m_pDeviceContext->GetBaseSampleRateInverse();

  00034	e5940050	 ldr         r0, [r4, #0x50]
  00038	eb000000	 bl          |?GetBaseSampleRateInverse@DeviceContext@@QAAKXZ|

; 69   : 
; 70   :     LONG CurrSamp0 = m_CurrSamp[0];
; 71   :     LONG PrevSamp0 = m_PrevSamp[0];
; 72   :     PBYTE pCurrData = m_lpCurrData;
; 73   :     PBYTE pCurrDataEnd = m_lpCurrDataEnd;
; 74   :     LONG fxpGain[2];
; 75   : 
; 76   :     if (pTransferStatus->Mute)

  0003c	e59de040	 ldr         lr, [sp, #0x40]
  00040	e5942048	 ldr         r2, [r4, #0x48]

; 77   :     {
; 78   :         fxpGain[0] = 0;
; 79   :         fxpGain[1] = 0;
; 80   :     }
; 81   :     else
; 82   :     {
; 83   :         fxpGain[0] = m_fxpGain[0];
; 84   :         fxpGain[1] = m_fxpGain[1];
; 85   :     }
; 86   : 
; 87   :     while (pBuffer < pBufferEnd)

  00044	e59d3000	 ldr         r3, [sp]
  00048	e59ee004	 ldr         lr, [lr, #4]
  0004c	e5948080	 ldr         r8, [r4, #0x80]
  00050	e5949078	 ldr         r9, [r4, #0x78]
  00054	e35e0000	 cmp         lr, #0
  00058	13a0a000	 movne       r10, #0
  0005c	0594a060	 ldreq       r10, [r4, #0x60]
  00060	13a0b000	 movne       r11, #0
  00064	0594b064	 ldreq       r11, [r4, #0x64]
  00068	e5946044	 ldr         r6, [r4, #0x44]
  0006c	e1550003	 cmp         r5, r3
  00070	e58d2010	 str         r2, [sp, #0x10]
  00074	e58d0014	 str         r0, [sp, #0x14]
  00078	2a000036	 bcs         |$Exit$35275|
  0007c	e3a03c7f	 mov         r3, #0x7F, 24
  00080	e59d4004	 ldr         r4, [sp, #4]
  00084	e383e0ff	 orr         lr, r3, #0xFF
  00088		 |$LL13@Render2|

; 88   :     {
; 89   :         while (CurrPos < 0)

  00088	e3570000	 cmp         r7, #0
  0008c	5a000008	 bpl         |$LN10@Render2|

; 150  :             }
; 151  : #endif
; 152  :         }
; 153  :         ((HWSAMPLE *)pBuffer)[0] = (HWSAMPLE)OutSamp0;
; 154  :         ((HWSAMPLE *)pBuffer)[1] = (HWSAMPLE)OutSamp1;
; 155  :         pBuffer += 2*sizeof(HWSAMPLE);

  00090	e59d1008	 ldr         r1, [sp, #8]
  00094		 |$LL11@Render2|

; 90   :         {
; 91   :             if (pCurrData>=pCurrDataEnd)

  00094	e1560002	 cmp         r6, r2
  00098	2a00002d	 bcs         |$LN23@Render2|

; 92   :             {
; 93   :                 goto Exit;
; 94   :             }
; 95   : 
; 96   :             CurrPos += BaseRate;
; 97   : 
; 98   :             PrevSamp0 = CurrSamp0;
; 99   : 
; 100  :             PPCM_SAMPLE pSampleSrc = (PPCM_SAMPLE)pCurrData;
; 101  :             CurrSamp0 = (LONG)pSampleSrc->m8.sample;
; 102  :             CurrSamp0 = (CurrSamp0 - 128) << 8;

  0009c	e4d63001	 ldrb        r3, [r6], #1
  000a0	e1a09008	 mov         r9, r8
  000a4	e0977001	 adds        r7, r7, r1
  000a8	e2433080	 sub         r3, r3, #0x80
  000ac	e1a08403	 mov         r8, r3, lsl #8
  000b0	4afffff7	 bmi         |$LL11@Render2|
  000b4		 |$LN10@Render2|

; 103  :             pCurrData+=1;
; 104  :         }
; 105  : 
; 106  :         // Calculate ratio between samples as a 17.15 fraction
; 107  :         // (Only use 15 bits to avoid overflow on next multiply)
; 108  :         LONG Ratio;
; 109  :         Ratio = (CurrPos * BaseRateInv)>>17;

  000b4	e0030790	 mul         r3, r0, r7

; 110  : 
; 111  :         CurrPos -= ClientRate;
; 112  : 
; 113  :         LONG OutSamp0;
; 114  : 
; 115  :         // Calc difference between samples. Note OutSamp0 is a 17-bit signed number now.
; 116  :         OutSamp0 = PrevSamp0 - CurrSamp0;

  000b8	e0492008	 sub         r2, r9, r8
  000bc	e1a038a3	 mov         r3, r3, lsr #17

; 117  : 
; 118  :         // Now interpolate
; 119  :         OutSamp0 = (OutSamp0 * Ratio) >> 15;

  000c0	e0030392	 mul         r3, r2, r3
  000c4	e59d200c	 ldr         r2, [sp, #0xC]

; 120  : 
; 121  :         // Add to previous number
; 122  :         OutSamp0 += CurrSamp0;
; 123  : 
; 124  : #if (OUTCHANNELS==2)
; 125  :         LONG OutSamp1;
; 126  :         OutSamp1 = OutSamp0;
; 127  :         OutSamp0 = (OutSamp0 * fxpGain[0]) >> VOLSHIFT;
; 128  :         OutSamp1 = (OutSamp1 * fxpGain[1]) >> VOLSHIFT;
; 129  :         if (pBuffer < pBufferLast)

  000c8	e1550004	 cmp         r5, r4
  000cc	e08817c3	 add         r1, r8, r3, asr #15
  000d0	e0477002	 sub         r7, r7, r2
  000d4	e0030b91	 mul         r3, r1, r11
  000d8	e0020a91	 mul         r2, r1, r10
  000dc	e1a01843	 mov         r1, r3, asr #16
  000e0	e1a00842	 mov         r0, r2, asr #16
  000e4	2a000012	 bcs         |$LN1@Render2|

; 130  :         {
; 131  :             OutSamp0 += ((HWSAMPLE *)pBuffer)[0];

  000e8	e1d530f0	 ldrsh       r3, [r5]

; 132  :             OutSamp1 += ((HWSAMPLE *)pBuffer)[1];

  000ec	e1d520f2	 ldrsh       r2, [r5, #2]
  000f0	e0800003	 add         r0, r0, r3

; 133  : #if USE_MIX_SATURATE
; 134  :             // Handle saturation
; 135  :             if (OutSamp0>AUDIO_SAMPLE_MAX)

  000f4	e150000e	 cmp         r0, lr
  000f8	e0811002	 add         r1, r1, r2
  000fc	da000005	 ble         |$LN6@Render2|

; 136  :             {
; 137  :                 OutSamp0=AUDIO_SAMPLE_MAX;

  00100	e1a0000e	 mov         r0, lr
  00104		 |$LN24@Render2|

; 150  :             }
; 151  : #endif
; 152  :         }
; 153  :         ((HWSAMPLE *)pBuffer)[0] = (HWSAMPLE)OutSamp0;
; 154  :         ((HWSAMPLE *)pBuffer)[1] = (HWSAMPLE)OutSamp1;
; 155  :         pBuffer += 2*sizeof(HWSAMPLE);

  00104	e3e030ff	 mvn         r3, #0xFF
  00108		 |$LN4@Render2|

; 142  :             }
; 143  :             if (OutSamp1>AUDIO_SAMPLE_MAX)

  00108	e151000e	 cmp         r1, lr
  0010c	da000006	 ble         |$LN3@Render2|

; 144  :             {
; 145  :                 OutSamp1=AUDIO_SAMPLE_MAX;

  00110	e1a0100e	 mov         r1, lr
  00114	ea000006	 b           |$LN1@Render2|
  00118		 |$LN6@Render2|

; 138  :             }
; 139  :             else if (OutSamp0<AUDIO_SAMPLE_MIN)

  00118	e3700902	 cmn         r0, #2, 18
  0011c	aafffff8	 bge         |$LN24@Render2|

; 140  :             {
; 141  :                 OutSamp0=AUDIO_SAMPLE_MIN;

  00120	e3e030ff	 mvn         r3, #0xFF
  00124	e1a00383	 mov         r0, r3, lsl #7
  00128	eafffff6	 b           |$LN4@Render2|
  0012c		 |$LN3@Render2|

; 146  :             }
; 147  :             else if (OutSamp1<AUDIO_SAMPLE_MIN)

  0012c	e3710902	 cmn         r1, #2, 18

; 148  :             {
; 149  :                 OutSamp1=AUDIO_SAMPLE_MIN;

  00130	b1a01383	 movlt       r1, r3, lsl #7
  00134		 |$LN1@Render2|

; 150  :             }
; 151  : #endif
; 152  :         }
; 153  :         ((HWSAMPLE *)pBuffer)[0] = (HWSAMPLE)OutSamp0;
; 154  :         ((HWSAMPLE *)pBuffer)[1] = (HWSAMPLE)OutSamp1;
; 155  :         pBuffer += 2*sizeof(HWSAMPLE);

  00134	e59d3000	 ldr         r3, [sp]
  00138	e1c500b0	 strh        r0, [r5]
  0013c	e1c510b2	 strh        r1, [r5, #2]
  00140	e2855004	 add         r5, r5, #4
  00144	e59d2010	 ldr         r2, [sp, #0x10]
  00148	e59d0014	 ldr         r0, [sp, #0x14]
  0014c	e1550003	 cmp         r5, r3
  00150	3affffcc	 bcc         |$LL13@Render2|
  00154		 |$LN23@Render2|

; 64   : {

  00154	e59d4018	 ldr         r4, [sp, #0x18]
  00158		 |$Exit$35275|

; 156  : #else
; 157  :         OutSamp0 = (OutSamp0 * fxpGain[0]) >> VOLSHIFT;
; 158  :         if (pBuffer < pBufferLast)
; 159  :         {
; 160  :             OutSamp0 += ((HWSAMPLE *)pBuffer)[0];
; 161  : #if USE_MIX_SATURATE
; 162  :             // Handle saturation
; 163  :             if (OutSamp0>AUDIO_SAMPLE_MAX)
; 164  :             {
; 165  :                 OutSamp0=AUDIO_SAMPLE_MAX;
; 166  :             }
; 167  :             else if (OutSamp0<AUDIO_SAMPLE_MIN)
; 168  :             {
; 169  :                 OutSamp0=AUDIO_SAMPLE_MIN;
; 170  :             }
; 171  : #endif
; 172  :         }
; 173  :         ((HWSAMPLE *)pBuffer)[0] = (HWSAMPLE)OutSamp0;
; 174  :         pBuffer += sizeof(HWSAMPLE);
; 175  : #endif
; 176  :     }
; 177  : 
; 178  :     Exit:
; 179  : 
; 180  :     m_dwByteCount += (pCurrData - m_lpCurrData);

  00158	e594204c	 ldr         r2, [r4, #0x4C]
  0015c	e5943044	 ldr         r3, [r4, #0x44]

; 181  :     m_lpCurrData = pCurrData;

  00160	e5846044	 str         r6, [r4, #0x44]

; 182  :     m_CurrPos = CurrPos;

  00164	e5847088	 str         r7, [r4, #0x88]
  00168	e0423003	 sub         r3, r2, r3
  0016c	e0833006	 add         r3, r3, r6
  00170	e584304c	 str         r3, [r4, #0x4C]

; 183  :     m_PrevSamp[0] = PrevSamp0;

  00174	e5849078	 str         r9, [r4, #0x78]

; 184  :     m_CurrSamp[0] = CurrSamp0;

  00178	e5848080	 str         r8, [r4, #0x80]

; 185  :     return pBuffer;
; 186  : }

  0017c	e1a00005	 mov         r0, r5
  00180	e28dd01c	 add         sp, sp, #0x1C
  00184	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00188	e12fff1e	 bx          lr
  0018c		 |$M35623|

			 ENDP  ; |?Render2@OutputStreamContextM8@@UAAPAEPAE00PAUTRANSFER_STATUS@@@Z|, OutputStreamContextM8::Render2

	EXPORT	|?Render2@OutputStreamContextM16@@UAAPAEPAE00PAUTRANSFER_STATUS@@@Z| ; OutputStreamContextM16::Render2

  00000			 AREA	 |.pdata|, PDATA
|$T35660| DCD	|$LN27@Render2@2|
	DCD	0x40006202
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Render2@OutputStreamContextM16@@UAAPAEPAE00PAUTRANSFER_STATUS@@@Z| PROC ; OutputStreamContextM16::Render2

; 189  : {

  00000		 |$LN27@Render2@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd01c	 sub         sp, sp, #0x1C
  00008		 |$M35657|
  00008	e1a04000	 mov         r4, r0
  0000c	e58d4018	 str         r4, [sp, #0x18]
  00010	e58d3004	 str         r3, [sp, #4]
  00014	e58d2000	 str         r2, [sp]
  00018	e1a05001	 mov         r5, r1

; 190  :     LONG CurrPos = m_CurrPos;
; 191  :     DWORD ClientRate = m_ClientRate;
; 192  :     DWORD BaseRate = m_pDeviceContext->GetBaseSampleRate();

  0001c	e594308c	 ldr         r3, [r4, #0x8C]
  00020	e5940050	 ldr         r0, [r4, #0x50]
  00024	e5947088	 ldr         r7, [r4, #0x88]
  00028	e58d300c	 str         r3, [sp, #0xC]
  0002c	eb000000	 bl          |?GetBaseSampleRate@DeviceContext@@QAAKXZ|
  00030	e58d0008	 str         r0, [sp, #8]

; 193  :     DWORD BaseRateInv = m_pDeviceContext->GetBaseSampleRateInverse();

  00034	e5940050	 ldr         r0, [r4, #0x50]
  00038	eb000000	 bl          |?GetBaseSampleRateInverse@DeviceContext@@QAAKXZ|

; 194  : 
; 195  :     LONG CurrSamp0 = m_CurrSamp[0];
; 196  :     LONG PrevSamp0 = m_PrevSamp[0];
; 197  :     PBYTE pCurrData = m_lpCurrData;
; 198  :     PBYTE pCurrDataEnd = m_lpCurrDataEnd;
; 199  :     LONG fxpGain[2];
; 200  : 
; 201  :     if (pTransferStatus->Mute)

  0003c	e59de040	 ldr         lr, [sp, #0x40]
  00040	e5942048	 ldr         r2, [r4, #0x48]

; 202  :     {
; 203  :         fxpGain[0] = 0;
; 204  :         fxpGain[1] = 0;
; 205  :     }
; 206  :     else
; 207  :     {
; 208  :         fxpGain[0] = m_fxpGain[0];
; 209  :         fxpGain[1] = m_fxpGain[1];
; 210  :     }
; 211  : 
; 212  :     while (pBuffer < pBufferEnd)

  00044	e59d3000	 ldr         r3, [sp]
  00048	e59ee004	 ldr         lr, [lr, #4]
  0004c	e5948080	 ldr         r8, [r4, #0x80]
  00050	e5949078	 ldr         r9, [r4, #0x78]
  00054	e35e0000	 cmp         lr, #0
  00058	13a0a000	 movne       r10, #0
  0005c	0594a060	 ldreq       r10, [r4, #0x60]
  00060	13a0b000	 movne       r11, #0
  00064	0594b064	 ldreq       r11, [r4, #0x64]
  00068	e5946044	 ldr         r6, [r4, #0x44]
  0006c	e1a01000	 mov         r1, r0
  00070	e1550003	 cmp         r5, r3
  00074	e58d2010	 str         r2, [sp, #0x10]
  00078	e58d1014	 str         r1, [sp, #0x14]
  0007c	2a000034	 bcs         |$Exit$35322|
  00080	e3a03c7f	 mov         r3, #0x7F, 24
  00084	e59d4004	 ldr         r4, [sp, #4]
  00088	e383e0ff	 orr         lr, r3, #0xFF
  0008c		 |$LL13@Render2@2|

; 213  :     {
; 214  :         while (CurrPos < 0)

  0008c	e3570000	 cmp         r7, #0
  00090	5a000006	 bpl         |$LN10@Render2@2|

; 274  :             }
; 275  : #endif
; 276  :         }
; 277  :         ((HWSAMPLE *)pBuffer)[0] = (HWSAMPLE)OutSamp0;
; 278  :         ((HWSAMPLE *)pBuffer)[1] = (HWSAMPLE)OutSamp1;
; 279  :         pBuffer += 2*sizeof(HWSAMPLE);

  00094	e59d3008	 ldr         r3, [sp, #8]
  00098		 |$LL11@Render2@2|

; 215  :         {
; 216  :             if (pCurrData>=pCurrDataEnd)

  00098	e1560002	 cmp         r6, r2
  0009c	2a00002b	 bcs         |$LN23@Render2@2|

; 217  :             {
; 218  :                 goto Exit;
; 219  :             }
; 220  : 
; 221  :             CurrPos += BaseRate;
; 222  : 
; 223  :             PrevSamp0 = CurrSamp0;

  000a0	e1a09008	 mov         r9, r8

; 224  : 
; 225  :             PPCM_SAMPLE pSampleSrc = (PPCM_SAMPLE)pCurrData;
; 226  :             CurrSamp0 = (LONG)pSampleSrc->m16.sample;

  000a4	e0d680f2	 ldrsh       r8, [r6], #2
  000a8	e0977003	 adds        r7, r7, r3
  000ac	4afffff9	 bmi         |$LL11@Render2@2|
  000b0		 |$LN10@Render2@2|

; 227  :             pCurrData+=2;
; 228  :         }
; 229  : 
; 230  :         // Calculate ratio between samples as a 17.15 fraction
; 231  :         // (Only use 15 bits to avoid overflow on next multiply)
; 232  :         LONG Ratio;
; 233  :         Ratio = (CurrPos * BaseRateInv)>>17;

  000b0	e0030791	 mul         r3, r1, r7

; 234  : 
; 235  :         CurrPos -= ClientRate;
; 236  : 
; 237  :         LONG OutSamp0;
; 238  : 
; 239  :         // Calc difference between samples. Note OutSamp0 is a 17-bit signed number now.
; 240  :         OutSamp0 = PrevSamp0 - CurrSamp0;

  000b4	e0492008	 sub         r2, r9, r8
  000b8	e1a038a3	 mov         r3, r3, lsr #17

; 241  : 
; 242  :         // Now interpolate
; 243  :         OutSamp0 = (OutSamp0 * Ratio) >> 15;

  000bc	e0030392	 mul         r3, r2, r3
  000c0	e59d200c	 ldr         r2, [sp, #0xC]

; 244  : 
; 245  :         // Add to previous number
; 246  :         OutSamp0 += CurrSamp0;
; 247  : 
; 248  : #if (OUTCHANNELS==2)
; 249  :         LONG OutSamp1;
; 250  :         OutSamp1=OutSamp0;
; 251  :         OutSamp0 = (OutSamp0 * fxpGain[0]) >> VOLSHIFT;
; 252  :         OutSamp1 = (OutSamp1 * fxpGain[1]) >> VOLSHIFT;
; 253  :         if (pBuffer < pBufferLast)

  000c4	e1550004	 cmp         r5, r4
  000c8	e08817c3	 add         r1, r8, r3, asr #15
  000cc	e0477002	 sub         r7, r7, r2
  000d0	e0030b91	 mul         r3, r1, r11
  000d4	e0020a91	 mul         r2, r1, r10
  000d8	e1a01843	 mov         r1, r3, asr #16
  000dc	e1a00842	 mov         r0, r2, asr #16
  000e0	2a000012	 bcs         |$LN1@Render2@2|

; 254  :         {
; 255  :             OutSamp0 += ((HWSAMPLE *)pBuffer)[0];

  000e4	e1d530f0	 ldrsh       r3, [r5]

; 256  :             OutSamp1 += ((HWSAMPLE *)pBuffer)[1];

  000e8	e1d520f2	 ldrsh       r2, [r5, #2]
  000ec	e0800003	 add         r0, r0, r3

; 257  : #if USE_MIX_SATURATE
; 258  :             // Handle saturation
; 259  :             if (OutSamp0>AUDIO_SAMPLE_MAX)

  000f0	e150000e	 cmp         r0, lr
  000f4	e0811002	 add         r1, r1, r2
  000f8	da000005	 ble         |$LN6@Render2@2|

; 260  :             {
; 261  :                 OutSamp0=AUDIO_SAMPLE_MAX;

  000fc	e1a0000e	 mov         r0, lr
  00100		 |$LN24@Render2@2|

; 274  :             }
; 275  : #endif
; 276  :         }
; 277  :         ((HWSAMPLE *)pBuffer)[0] = (HWSAMPLE)OutSamp0;
; 278  :         ((HWSAMPLE *)pBuffer)[1] = (HWSAMPLE)OutSamp1;
; 279  :         pBuffer += 2*sizeof(HWSAMPLE);

  00100	e3e030ff	 mvn         r3, #0xFF
  00104		 |$LN4@Render2@2|

; 266  :             }
; 267  :             if (OutSamp1>AUDIO_SAMPLE_MAX)

  00104	e151000e	 cmp         r1, lr
  00108	da000006	 ble         |$LN3@Render2@2|

; 268  :             {
; 269  :                 OutSamp1=AUDIO_SAMPLE_MAX;

  0010c	e1a0100e	 mov         r1, lr
  00110	ea000006	 b           |$LN1@Render2@2|
  00114		 |$LN6@Render2@2|

; 262  :             }
; 263  :             else if (OutSamp0<AUDIO_SAMPLE_MIN)

  00114	e3700902	 cmn         r0, #2, 18
  00118	aafffff8	 bge         |$LN24@Render2@2|

; 264  :             {
; 265  :                 OutSamp0=AUDIO_SAMPLE_MIN;

  0011c	e3e030ff	 mvn         r3, #0xFF
  00120	e1a00383	 mov         r0, r3, lsl #7
  00124	eafffff6	 b           |$LN4@Render2@2|
  00128		 |$LN3@Render2@2|

; 270  :             }
; 271  :             else if (OutSamp1<AUDIO_SAMPLE_MIN)

  00128	e3710902	 cmn         r1, #2, 18

; 272  :             {
; 273  :                 OutSamp1=AUDIO_SAMPLE_MIN;

  0012c	b1a01383	 movlt       r1, r3, lsl #7
  00130		 |$LN1@Render2@2|

; 274  :             }
; 275  : #endif
; 276  :         }
; 277  :         ((HWSAMPLE *)pBuffer)[0] = (HWSAMPLE)OutSamp0;
; 278  :         ((HWSAMPLE *)pBuffer)[1] = (HWSAMPLE)OutSamp1;
; 279  :         pBuffer += 2*sizeof(HWSAMPLE);

  00130	e59d3000	 ldr         r3, [sp]
  00134	e1c500b0	 strh        r0, [r5]
  00138	e1c510b2	 strh        r1, [r5, #2]
  0013c	e2855004	 add         r5, r5, #4
  00140	e59d2010	 ldr         r2, [sp, #0x10]
  00144	e59d1014	 ldr         r1, [sp, #0x14]
  00148	e1550003	 cmp         r5, r3
  0014c	3affffce	 bcc         |$LL13@Render2@2|
  00150		 |$LN23@Render2@2|

; 189  : {

  00150	e59d4018	 ldr         r4, [sp, #0x18]
  00154		 |$Exit$35322|

; 280  : #else
; 281  :         OutSamp0 = (OutSamp0 * fxpGain[0]) >> VOLSHIFT;
; 282  :         if (pBuffer < pBufferLast)
; 283  :         {
; 284  :             OutSamp0 += ((HWSAMPLE *)pBuffer)[0];
; 285  : #if USE_MIX_SATURATE
; 286  :             // Handle saturation
; 287  :             if (OutSamp0>AUDIO_SAMPLE_MAX)
; 288  :             {
; 289  :                 OutSamp0=AUDIO_SAMPLE_MAX;
; 290  :             }
; 291  :             else if (OutSamp0<AUDIO_SAMPLE_MIN)
; 292  :             {
; 293  :                 OutSamp0=AUDIO_SAMPLE_MIN;
; 294  :             }
; 295  : #endif
; 296  :         }
; 297  :         ((HWSAMPLE *)pBuffer)[0] = (HWSAMPLE)OutSamp0;
; 298  :         pBuffer += sizeof(HWSAMPLE);
; 299  : #endif
; 300  :     }
; 301  : 
; 302  :     Exit:
; 303  :     m_dwByteCount += (pCurrData - m_lpCurrData);

  00154	e594204c	 ldr         r2, [r4, #0x4C]
  00158	e5943044	 ldr         r3, [r4, #0x44]

; 304  :     m_lpCurrData = pCurrData;

  0015c	e5846044	 str         r6, [r4, #0x44]

; 305  :     m_CurrPos = CurrPos;

  00160	e5847088	 str         r7, [r4, #0x88]
  00164	e0423003	 sub         r3, r2, r3
  00168	e0833006	 add         r3, r3, r6
  0016c	e584304c	 str         r3, [r4, #0x4C]

; 306  :     m_PrevSamp[0] = PrevSamp0;

  00170	e5849078	 str         r9, [r4, #0x78]

; 307  :     m_CurrSamp[0] = CurrSamp0;

  00174	e5848080	 str         r8, [r4, #0x80]

; 308  :     return pBuffer;
; 309  : }

  00178	e1a00005	 mov         r0, r5
  0017c	e28dd01c	 add         sp, sp, #0x1C
  00180	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00184	e12fff1e	 bx          lr
  00188		 |$M35658|

			 ENDP  ; |?Render2@OutputStreamContextM16@@UAAPAEPAE00PAUTRANSFER_STATUS@@@Z|, OutputStreamContextM16::Render2

	EXPORT	|?Render2@OutputStreamContextS8@@UAAPAEPAE00PAUTRANSFER_STATUS@@@Z| ; OutputStreamContextS8::Render2

  00000			 AREA	 |.pdata|, PDATA
|$T35695| DCD	|$LN27@Render2@3|
	DCD	0x40007902
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Render2@OutputStreamContextS8@@UAAPAEPAE00PAUTRANSFER_STATUS@@@Z| PROC ; OutputStreamContextS8::Render2

; 313  : {

  00000		 |$LN27@Render2@3|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd024	 sub         sp, sp, #0x24
  00008		 |$M35692|
  00008	e1a06002	 mov         r6, r2
  0000c	e1a04000	 mov         r4, r0
  00010	e58d601c	 str         r6, [sp, #0x1C]
  00014	e58d4020	 str         r4, [sp, #0x20]
  00018	e58d3018	 str         r3, [sp, #0x18]
  0001c	e1a05001	 mov         r5, r1

; 314  :     LONG CurrPos = m_CurrPos;
; 315  :     DWORD ClientRate = m_ClientRate;
; 316  :     DWORD BaseRate = m_pDeviceContext->GetBaseSampleRate();

  00020	e594308c	 ldr         r3, [r4, #0x8C]
  00024	e5940050	 ldr         r0, [r4, #0x50]
  00028	e5947088	 ldr         r7, [r4, #0x88]
  0002c	e58d3014	 str         r3, [sp, #0x14]
  00030	eb000000	 bl          |?GetBaseSampleRate@DeviceContext@@QAAKXZ|
  00034	e58d0010	 str         r0, [sp, #0x10]

; 317  :     DWORD BaseRateInv = m_pDeviceContext->GetBaseSampleRateInverse();

  00038	e5940050	 ldr         r0, [r4, #0x50]
  0003c	eb000000	 bl          |?GetBaseSampleRateInverse@DeviceContext@@QAAKXZ|

; 318  : 
; 319  :     LONG CurrSamp0 = m_CurrSamp[0];
; 320  :     LONG CurrSamp1 = m_CurrSamp[1];
; 321  :     LONG PrevSamp0 = m_PrevSamp[0];
; 322  :     LONG PrevSamp1 = m_PrevSamp[1];
; 323  :     PBYTE pCurrData = m_lpCurrData;
; 324  :     PBYTE pCurrDataEnd = m_lpCurrDataEnd;
; 325  :     LONG fxpGain[2];
; 326  : 
; 327  :     if (pTransferStatus->Mute)

  00040	e59de048	 ldr         lr, [sp, #0x48]
  00044	e594307c	 ldr         r3, [r4, #0x7C]
  00048	e5941078	 ldr         r1, [r4, #0x78]
  0004c	e59ee004	 ldr         lr, [lr, #4]
  00050	e58d3000	 str         r3, [sp]
  00054	e5943048	 ldr         r3, [r4, #0x48]
  00058	e35e0000	 cmp         lr, #0

; 328  :     {
; 329  :         fxpGain[0] = 0;

  0005c	13a0a000	 movne       r10, #0

; 330  :         fxpGain[1] = 0;
; 331  :     }
; 332  :     else
; 333  :     {
; 334  :         fxpGain[0] = m_fxpGain[0];

  00060	0594a060	 ldreq       r10, [r4, #0x60]
  00064	13a0b000	 movne       r11, #0

; 335  :         fxpGain[1] = m_fxpGain[1];

  00068	0594b064	 ldreq       r11, [r4, #0x64]
  0006c	e5948080	 ldr         r8, [r4, #0x80]
  00070	e5949084	 ldr         r9, [r4, #0x84]
  00074	e594e044	 ldr         lr, [r4, #0x44]
  00078	e1a02000	 mov         r2, r0

; 336  :     }
; 337  : 
; 338  :     while (pBuffer < pBufferEnd)

  0007c	e1550006	 cmp         r5, r6
  00080	e58d1004	 str         r1, [sp, #4]
  00084	e58d3008	 str         r3, [sp, #8]
  00088	e58d200c	 str         r2, [sp, #0xC]
  0008c	2a000045	 bcs         |$Exit$35371|
  00090	e3a00c7f	 mov         r0, #0x7F, 24

; 407  :             }
; 408  : #endif
; 409  :         }
; 410  :         ((HWSAMPLE *)pBuffer)[0] = (HWSAMPLE)OutSamp0;
; 411  :         ((HWSAMPLE *)pBuffer)[1] = (HWSAMPLE)OutSamp1;
; 412  : 
; 413  :         pBuffer += 2*sizeof(HWSAMPLE);

  00094	e59d4000	 ldr         r4, [sp]
  00098	e38060ff	 orr         r6, r0, #0xFF
  0009c		 |$LL13@Render2@3|

; 339  :     {
; 340  :         while (CurrPos < 0)

  0009c	e3570000	 cmp         r7, #0
  000a0	5a000012	 bpl         |$LN10@Render2@3|
  000a4		 |$LL11@Render2@3|

; 341  :         {
; 342  :             if (pCurrData>=pCurrDataEnd)

  000a4	e15e0003	 cmp         lr, r3
  000a8	2a00003d	 bcs         |$LN23@Render2@3|

; 343  :             {
; 344  :                 goto Exit;
; 345  :             }
; 346  : 
; 347  :             CurrPos += BaseRate;
; 348  : 
; 349  :             PrevSamp0 = CurrSamp0;
; 350  :             PrevSamp1 = CurrSamp1;
; 351  : 
; 352  :             PPCM_SAMPLE pSampleSrc = (PPCM_SAMPLE)pCurrData;
; 353  :             CurrSamp0 =  (LONG)pSampleSrc->s8.sample_left;
; 354  :             CurrSamp0 = (CurrSamp0 - 128) << 8;

  000ac	e5de3000	 ldrb        r3, [lr]

; 355  :             CurrSamp1 = (LONG)pSampleSrc->s8.sample_right;
; 356  :             CurrSamp1 = (CurrSamp1 - 128) << 8;

  000b0	e5de2001	 ldrb        r2, [lr, #1]
  000b4	e1a01008	 mov         r1, r8
  000b8	e2433080	 sub         r3, r3, #0x80
  000bc	e1a08403	 mov         r8, r3, lsl #8
  000c0	e59d3010	 ldr         r3, [sp, #0x10]
  000c4	e2422080	 sub         r2, r2, #0x80
  000c8	e1a00009	 mov         r0, r9
  000cc	e0977003	 adds        r7, r7, r3

; 357  :             pCurrData+=2;

  000d0	e59d3008	 ldr         r3, [sp, #8]
  000d4	e58d1004	 str         r1, [sp, #4]
  000d8	e58d0000	 str         r0, [sp]
  000dc	e1a09402	 mov         r9, r2, lsl #8
  000e0	e28ee002	 add         lr, lr, #2
  000e4	4affffee	 bmi         |$LL11@Render2@3|
  000e8	e59d200c	 ldr         r2, [sp, #0xC]

; 407  :             }
; 408  : #endif
; 409  :         }
; 410  :         ((HWSAMPLE *)pBuffer)[0] = (HWSAMPLE)OutSamp0;
; 411  :         ((HWSAMPLE *)pBuffer)[1] = (HWSAMPLE)OutSamp1;
; 412  : 
; 413  :         pBuffer += 2*sizeof(HWSAMPLE);

  000ec	e1a04000	 mov         r4, r0
  000f0		 |$LN10@Render2@3|
  000f0	e0030792	 mul         r3, r2, r7
  000f4	e0411008	 sub         r1, r1, r8
  000f8	e1a008a3	 mov         r0, r3, lsr #17
  000fc	e0443009	 sub         r3, r4, r9
  00100	e0020091	 mul         r2, r1, r0
  00104	e0010093	 mul         r1, r3, r0
  00108	e08837c2	 add         r3, r8, r2, asr #15
  0010c	e08927c1	 add         r2, r9, r1, asr #15
  00110	e0010a93	 mul         r1, r3, r10
  00114	e0030b92	 mul         r3, r2, r11
  00118	e1a00841	 mov         r0, r1, asr #16
  0011c	e1a01843	 mov         r1, r3, asr #16
  00120	e59d3014	 ldr         r3, [sp, #0x14]
  00124	e0477003	 sub         r7, r7, r3
  00128	e59d3018	 ldr         r3, [sp, #0x18]
  0012c	e1550003	 cmp         r5, r3
  00130	2a000012	 bcs         |$LN1@Render2@3|
  00134	e1d530f0	 ldrsh       r3, [r5]
  00138	e1d520f2	 ldrsh       r2, [r5, #2]
  0013c	e0800003	 add         r0, r0, r3
  00140	e1500006	 cmp         r0, r6
  00144	e0811002	 add         r1, r1, r2
  00148	da000005	 ble         |$LN6@Render2@3|

; 358  :         }
; 359  : 
; 360  :         // Calculate ratio between samples as a 17.15 fraction
; 361  :         // (Only use 15 bits to avoid overflow on next multiply)
; 362  :         LONG Ratio;
; 363  :         Ratio = (CurrPos * BaseRateInv)>>17;
; 364  : 
; 365  :         CurrPos -= ClientRate;
; 366  : 
; 367  :         LONG OutSamp0;
; 368  :         LONG OutSamp1;
; 369  : 
; 370  :         // Calc difference between samples. Note OutSamp0 is a 17-bit signed number now.
; 371  :         OutSamp0 = PrevSamp0 - CurrSamp0;
; 372  :         OutSamp1 = PrevSamp1 - CurrSamp1;
; 373  : 
; 374  :         // Now interpolate
; 375  :         OutSamp0 = (OutSamp0 * Ratio) >> 15;
; 376  :         OutSamp1 = (OutSamp1 * Ratio) >> 15;
; 377  : 
; 378  :         // Add to previous number
; 379  :         OutSamp0 += CurrSamp0;
; 380  :         OutSamp1 += CurrSamp1;
; 381  : 
; 382  :         // Gain
; 383  :         OutSamp0 = (OutSamp0 * fxpGain[0]) >> VOLSHIFT;
; 384  :         OutSamp1 = (OutSamp1 * fxpGain[1]) >> VOLSHIFT;
; 385  : 
; 386  :         if (pBuffer < pBufferLast)
; 387  :         {
; 388  :             OutSamp0 += ((HWSAMPLE *)pBuffer)[0];
; 389  :             OutSamp1 += ((HWSAMPLE *)pBuffer)[1];
; 390  : #if USE_MIX_SATURATE
; 391  :             // Handle saturation
; 392  :             if (OutSamp0>AUDIO_SAMPLE_MAX)
; 393  :             {
; 394  :                 OutSamp0=AUDIO_SAMPLE_MAX;

  0014c	e1a00006	 mov         r0, r6
  00150		 |$LN24@Render2@3|

; 407  :             }
; 408  : #endif
; 409  :         }
; 410  :         ((HWSAMPLE *)pBuffer)[0] = (HWSAMPLE)OutSamp0;
; 411  :         ((HWSAMPLE *)pBuffer)[1] = (HWSAMPLE)OutSamp1;
; 412  : 
; 413  :         pBuffer += 2*sizeof(HWSAMPLE);

  00150	e3e030ff	 mvn         r3, #0xFF
  00154		 |$LN4@Render2@3|

; 399  :             }
; 400  :             if (OutSamp1>AUDIO_SAMPLE_MAX)

  00154	e1510006	 cmp         r1, r6
  00158	da000006	 ble         |$LN3@Render2@3|

; 401  :             {
; 402  :                 OutSamp1=AUDIO_SAMPLE_MAX;

  0015c	e1a01006	 mov         r1, r6
  00160	ea000006	 b           |$LN1@Render2@3|
  00164		 |$LN6@Render2@3|

; 395  :             }
; 396  :             else if (OutSamp0<AUDIO_SAMPLE_MIN)

  00164	e3700902	 cmn         r0, #2, 18
  00168	aafffff8	 bge         |$LN24@Render2@3|

; 397  :             {
; 398  :                 OutSamp0=AUDIO_SAMPLE_MIN;

  0016c	e3e030ff	 mvn         r3, #0xFF
  00170	e1a00383	 mov         r0, r3, lsl #7
  00174	eafffff6	 b           |$LN4@Render2@3|
  00178		 |$LN3@Render2@3|

; 403  :             }
; 404  :             else if (OutSamp1<AUDIO_SAMPLE_MIN)

  00178	e3710902	 cmn         r1, #2, 18

; 405  :             {
; 406  :                 OutSamp1=AUDIO_SAMPLE_MIN;

  0017c	b1a01383	 movlt       r1, r3, lsl #7
  00180		 |$LN1@Render2@3|

; 407  :             }
; 408  : #endif
; 409  :         }
; 410  :         ((HWSAMPLE *)pBuffer)[0] = (HWSAMPLE)OutSamp0;
; 411  :         ((HWSAMPLE *)pBuffer)[1] = (HWSAMPLE)OutSamp1;
; 412  : 
; 413  :         pBuffer += 2*sizeof(HWSAMPLE);

  00180	e59d301c	 ldr         r3, [sp, #0x1C]
  00184	e1c500b0	 strh        r0, [r5]
  00188	e1c510b2	 strh        r1, [r5, #2]
  0018c	e2855004	 add         r5, r5, #4
  00190	e59d1004	 ldr         r1, [sp, #4]
  00194	e59d200c	 ldr         r2, [sp, #0xC]
  00198	e1550003	 cmp         r5, r3
  0019c	e59d3008	 ldr         r3, [sp, #8]
  001a0	3affffbd	 bcc         |$LL13@Render2@3|
  001a4		 |$LN23@Render2@3|

; 313  : {

  001a4	e59d4020	 ldr         r4, [sp, #0x20]
  001a8		 |$Exit$35371|

; 414  : 
; 415  :     }
; 416  : 
; 417  :     Exit:
; 418  :     m_dwByteCount += (pCurrData - m_lpCurrData);

  001a8	e594204c	 ldr         r2, [r4, #0x4C]
  001ac	e5943044	 ldr         r3, [r4, #0x44]

; 419  :     m_lpCurrData = pCurrData;

  001b0	e584e044	 str         lr, [r4, #0x44]

; 420  :     m_CurrPos = CurrPos;

  001b4	e5847088	 str         r7, [r4, #0x88]
  001b8	e0423003	 sub         r3, r2, r3
  001bc	e083300e	 add         r3, r3, lr
  001c0	e584304c	 str         r3, [r4, #0x4C]

; 421  :     m_PrevSamp[0] = PrevSamp0;
; 422  :     m_PrevSamp[1] = PrevSamp1;

  001c4	e59d3000	 ldr         r3, [sp]
  001c8	e5841078	 str         r1, [r4, #0x78]

; 423  :     m_CurrSamp[0] = CurrSamp0;
; 424  :     m_CurrSamp[1] = CurrSamp1;
; 425  :     return pBuffer;
; 426  : }

  001cc	e1a00005	 mov         r0, r5
  001d0	e284c07c	 add         r12, r4, #0x7C
  001d4	e88c0308	 stmia       r12, {r3, r8, r9}
  001d8	e28dd024	 add         sp, sp, #0x24
  001dc	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001e0	e12fff1e	 bx          lr
  001e4		 |$M35693|

			 ENDP  ; |?Render2@OutputStreamContextS8@@UAAPAEPAE00PAUTRANSFER_STATUS@@@Z|, OutputStreamContextS8::Render2

	EXPORT	|?Render2@OutputStreamContextS16@@UAAPAEPAE00PAUTRANSFER_STATUS@@@Z| ; OutputStreamContextS16::Render2

  00000			 AREA	 |.pdata|, PDATA
|$T35731| DCD	|$LN28@Render2@4|
	DCD	0x40007102
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Render2@OutputStreamContextS16@@UAAPAEPAE00PAUTRANSFER_STATUS@@@Z| PROC ; OutputStreamContextS16::Render2

; 429  : {

  00000		 |$LN28@Render2@4|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd024	 sub         sp, sp, #0x24
  00008		 |$M35728|
  00008	e1a06002	 mov         r6, r2
  0000c	e1a04000	 mov         r4, r0
  00010	e58d6014	 str         r6, [sp, #0x14]
  00014	e58d4020	 str         r4, [sp, #0x20]
  00018	e58d3010	 str         r3, [sp, #0x10]
  0001c	e1a05001	 mov         r5, r1

; 430  :     LONG CurrPos = m_CurrPos;
; 431  :     DWORD ClientRate = m_ClientRate;
; 432  :     DWORD BaseRate = m_pDeviceContext->GetBaseSampleRate();

  00020	e594308c	 ldr         r3, [r4, #0x8C]
  00024	e5940050	 ldr         r0, [r4, #0x50]
  00028	e5947088	 ldr         r7, [r4, #0x88]
  0002c	e58d300c	 str         r3, [sp, #0xC]
  00030	eb000000	 bl          |?GetBaseSampleRate@DeviceContext@@QAAKXZ|
  00034	e58d0008	 str         r0, [sp, #8]

; 433  :     DWORD BaseRateInv = m_pDeviceContext->GetBaseSampleRateInverse();

  00038	e5940050	 ldr         r0, [r4, #0x50]
  0003c	eb000000	 bl          |?GetBaseSampleRateInverse@DeviceContext@@QAAKXZ|

; 434  : 
; 435  :     LONG CurrSamp0 = m_CurrSamp[0];
; 436  :     LONG CurrSamp1 = m_CurrSamp[1];
; 437  :     LONG PrevSamp0 = m_PrevSamp[0];
; 438  :     LONG PrevSamp1 = m_PrevSamp[1];
; 439  :     PBYTE pCurrData = m_lpCurrData;
; 440  :     PBYTE pCurrDataEnd = m_lpCurrDataEnd;
; 441  :     LONG fxpGain[2];
; 442  : 
; 443  :     if (pTransferStatus->Mute)

  00040	e59de048	 ldr         lr, [sp, #0x48]
  00044	e5942048	 ldr         r2, [r4, #0x48]
  00048	e5948080	 ldr         r8, [r4, #0x80]
  0004c	e59ee004	 ldr         lr, [lr, #4]
  00050	e5949084	 ldr         r9, [r4, #0x84]
  00054	e594a078	 ldr         r10, [r4, #0x78]
  00058	e35e0000	 cmp         lr, #0

; 444  :     {
; 445  :         fxpGain[0] = 0;

  0005c	13a03000	 movne       r3, #0
  00060	158d3000	 strne       r3, [sp]

; 446  :         fxpGain[1] = 0;

  00064	13a03000	 movne       r3, #0

; 447  :     }
; 448  :     else
; 449  :     {
; 450  :         fxpGain[0] = m_fxpGain[0];

  00068	05943060	 ldreq       r3, [r4, #0x60]
  0006c	e594b07c	 ldr         r11, [r4, #0x7C]
  00070	e594e044	 ldr         lr, [r4, #0x44]
  00074	058d3000	 streq       r3, [sp]

; 451  :         fxpGain[1] = m_fxpGain[1];

  00078	05943064	 ldreq       r3, [r4, #0x64]
  0007c	e1a01000	 mov         r1, r0
  00080	e58d2018	 str         r2, [sp, #0x18]
  00084	e58d3004	 str         r3, [sp, #4]
  00088	e58d101c	 str         r1, [sp, #0x1C]

; 452  :     }
; 453  : 
; 454  :     while (pBuffer < pBufferEnd)

  0008c	e1550006	 cmp         r5, r6
  00090	2a00003c	 bcs         |$Exit$35421|
  00094	e3a03c7f	 mov         r3, #0x7F, 24
  00098	e59d4000	 ldr         r4, [sp]
  0009c	e38360ff	 orr         r6, r3, #0xFF
  000a0		 |$LL13@Render2@4|

; 455  :     {
; 456  :         while (CurrPos < 0)

  000a0	e3570000	 cmp         r7, #0
  000a4	5a000009	 bpl         |$LN10@Render2@4|

; 521  :             }
; 522  : #endif
; 523  :         }
; 524  :         ((HWSAMPLE *)pBuffer)[0] = (HWSAMPLE)OutSamp0;
; 525  :         ((HWSAMPLE *)pBuffer)[1] = (HWSAMPLE)OutSamp1;
; 526  : 
; 527  :         pBuffer += 2*sizeof(HWSAMPLE);

  000a8	e59d3008	 ldr         r3, [sp, #8]
  000ac		 |$LL11@Render2@4|

; 457  :         {
; 458  :             if (pCurrData>=pCurrDataEnd)

  000ac	e15e0002	 cmp         lr, r2
  000b0	2a000033	 bcs         |$LN23@Render2@4|

; 459  :             {
; 460  :                 goto Exit;
; 461  :             }
; 462  : 
; 463  :             CurrPos += BaseRate;
; 464  : 
; 465  :             PrevSamp0 = CurrSamp0;

  000b4	e1a0a008	 mov         r10, r8

; 466  :             PrevSamp1 = CurrSamp1;
; 467  : 
; 468  :             PPCM_SAMPLE pSampleSrc = (PPCM_SAMPLE)pCurrData;
; 469  :             CurrSamp0 = (LONG)pSampleSrc->s16.sample_left;

  000b8	e1de80f0	 ldrsh       r8, [lr]
  000bc	e1a0b009	 mov         r11, r9

; 470  :             CurrSamp1 = (LONG)pSampleSrc->s16.sample_right;

  000c0	e1de90f2	 ldrsh       r9, [lr, #2]

; 471  :             pCurrData+=4;

  000c4	e28ee004	 add         lr, lr, #4
  000c8	e0977003	 adds        r7, r7, r3
  000cc	4afffff6	 bmi         |$LL11@Render2@4|
  000d0		 |$LN10@Render2@4|

; 472  :         }
; 473  : 
; 474  :         // Calculate ratio between samples as a 17.15 fraction
; 475  :         // (Only use 15 bits to avoid overflow on next multiply)
; 476  :         LONG Ratio;
; 477  :         Ratio = (CurrPos * BaseRateInv)>>17;

  000d0	e0030791	 mul         r3, r1, r7

; 478  : 
; 479  :         CurrPos -= ClientRate;
; 480  : 
; 481  :         LONG OutSamp0;
; 482  :         LONG OutSamp1;
; 483  : 
; 484  :         // Calc difference between samples. Note OutSamp0 is a 17-bit signed number now.
; 485  :         OutSamp0 = PrevSamp0 - CurrSamp0;

  000d4	e04a1008	 sub         r1, r10, r8
  000d8	e1a008a3	 mov         r0, r3, lsr #17

; 486  :         OutSamp1 = PrevSamp1 - CurrSamp1;

  000dc	e04b3009	 sub         r3, r11, r9

; 487  : 
; 488  :         // Now interpolate
; 489  :         OutSamp0 = (OutSamp0 * Ratio) >> 15;

  000e0	e0020091	 mul         r2, r1, r0

; 490  :         OutSamp1 = (OutSamp1 * Ratio) >> 15;

  000e4	e0010093	 mul         r1, r3, r0

; 491  : 
; 492  :         // Add to previous number
; 493  :         OutSamp0 += CurrSamp0;

  000e8	e08837c2	 add         r3, r8, r2, asr #15

; 494  :         OutSamp1 += CurrSamp1;

  000ec	e08927c1	 add         r2, r9, r1, asr #15

; 495  : 
; 496  :         // Gain
; 497  :         OutSamp0 = (OutSamp0 * fxpGain[0]) >> VOLSHIFT;

  000f0	e0010493	 mul         r1, r3, r4

; 498  :         OutSamp1 = (OutSamp1 * fxpGain[1]) >> VOLSHIFT;

  000f4	e59d3004	 ldr         r3, [sp, #4]
  000f8	e0030392	 mul         r3, r2, r3
  000fc	e1a00841	 mov         r0, r1, asr #16
  00100	e1a01843	 mov         r1, r3, asr #16
  00104	e59d300c	 ldr         r3, [sp, #0xC]
  00108	e0477003	 sub         r7, r7, r3

; 499  : 
; 500  :         if (pBuffer < pBufferLast)

  0010c	e59d3010	 ldr         r3, [sp, #0x10]
  00110	e1550003	 cmp         r5, r3
  00114	2a000012	 bcs         |$LN1@Render2@4|

; 501  :         {
; 502  :             OutSamp0 += ((HWSAMPLE *)pBuffer)[0];

  00118	e1d530f0	 ldrsh       r3, [r5]

; 503  :             OutSamp1 += ((HWSAMPLE *)pBuffer)[1];

  0011c	e1d520f2	 ldrsh       r2, [r5, #2]
  00120	e0800003	 add         r0, r0, r3

; 504  : #if USE_MIX_SATURATE
; 505  :             // Handle saturation
; 506  :             if (OutSamp0>AUDIO_SAMPLE_MAX)

  00124	e1500006	 cmp         r0, r6
  00128	e0811002	 add         r1, r1, r2
  0012c	da000005	 ble         |$LN6@Render2@4|

; 507  :             {
; 508  :                 OutSamp0=AUDIO_SAMPLE_MAX;

  00130	e1a00006	 mov         r0, r6
  00134		 |$LN24@Render2@4|

; 521  :             }
; 522  : #endif
; 523  :         }
; 524  :         ((HWSAMPLE *)pBuffer)[0] = (HWSAMPLE)OutSamp0;
; 525  :         ((HWSAMPLE *)pBuffer)[1] = (HWSAMPLE)OutSamp1;
; 526  : 
; 527  :         pBuffer += 2*sizeof(HWSAMPLE);

  00134	e3e030ff	 mvn         r3, #0xFF
  00138		 |$LN4@Render2@4|

; 513  :             }
; 514  :             if (OutSamp1>AUDIO_SAMPLE_MAX)

  00138	e1510006	 cmp         r1, r6
  0013c	da000006	 ble         |$LN3@Render2@4|

; 515  :             {
; 516  :                 OutSamp1=AUDIO_SAMPLE_MAX;

  00140	e1a01006	 mov         r1, r6
  00144	ea000006	 b           |$LN1@Render2@4|
  00148		 |$LN6@Render2@4|

; 509  :             }
; 510  :             else if (OutSamp0<AUDIO_SAMPLE_MIN)

  00148	e3700902	 cmn         r0, #2, 18
  0014c	aafffff8	 bge         |$LN24@Render2@4|

; 511  :             {
; 512  :                 OutSamp0=AUDIO_SAMPLE_MIN;

  00150	e3e030ff	 mvn         r3, #0xFF
  00154	e1a00383	 mov         r0, r3, lsl #7
  00158	eafffff6	 b           |$LN4@Render2@4|
  0015c		 |$LN3@Render2@4|

; 517  :             }
; 518  :             else if (OutSamp1<AUDIO_SAMPLE_MIN)

  0015c	e3710902	 cmn         r1, #2, 18

; 519  :             {
; 520  :                 OutSamp1=AUDIO_SAMPLE_MIN;

  00160	b1a01383	 movlt       r1, r3, lsl #7
  00164		 |$LN1@Render2@4|

; 521  :             }
; 522  : #endif
; 523  :         }
; 524  :         ((HWSAMPLE *)pBuffer)[0] = (HWSAMPLE)OutSamp0;
; 525  :         ((HWSAMPLE *)pBuffer)[1] = (HWSAMPLE)OutSamp1;
; 526  : 
; 527  :         pBuffer += 2*sizeof(HWSAMPLE);

  00164	e59d3014	 ldr         r3, [sp, #0x14]
  00168	e1c500b0	 strh        r0, [r5]
  0016c	e1c510b2	 strh        r1, [r5, #2]
  00170	e2855004	 add         r5, r5, #4
  00174	e59d2018	 ldr         r2, [sp, #0x18]
  00178	e59d101c	 ldr         r1, [sp, #0x1C]
  0017c	e1550003	 cmp         r5, r3
  00180	3affffc6	 bcc         |$LL13@Render2@4|
  00184		 |$LN23@Render2@4|

; 429  : {

  00184	e59d4020	 ldr         r4, [sp, #0x20]
  00188		 |$Exit$35421|

; 528  :     }
; 529  : 
; 530  :     Exit:
; 531  :     m_dwByteCount += (pCurrData - m_lpCurrData);

  00188	e594204c	 ldr         r2, [r4, #0x4C]
  0018c	e5943044	 ldr         r3, [r4, #0x44]

; 532  :     m_lpCurrData = pCurrData;

  00190	e584e044	 str         lr, [r4, #0x44]

; 533  :     m_CurrPos = CurrPos;

  00194	e5847088	 str         r7, [r4, #0x88]
  00198	e0423003	 sub         r3, r2, r3
  0019c	e083300e	 add         r3, r3, lr
  001a0	e584304c	 str         r3, [r4, #0x4C]

; 534  :     m_PrevSamp[0] = PrevSamp0;

  001a4	e584a078	 str         r10, [r4, #0x78]

; 535  :     m_PrevSamp[1] = PrevSamp1;

  001a8	e584b07c	 str         r11, [r4, #0x7C]

; 536  :     m_CurrSamp[0] = CurrSamp0;

  001ac	e5848080	 str         r8, [r4, #0x80]

; 537  :     m_CurrSamp[1] = CurrSamp1;

  001b0	e5849084	 str         r9, [r4, #0x84]

; 538  :     return pBuffer;
; 539  : }

  001b4	e1a00005	 mov         r0, r5
  001b8	e28dd024	 add         sp, sp, #0x24
  001bc	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001c0	e12fff1e	 bx          lr
  001c4		 |$M35729|

			 ENDP  ; |?Render2@OutputStreamContextS16@@UAAPAEPAE00PAUTRANSFER_STATUS@@@Z|, OutputStreamContextS16::Render2

	EXPORT	|?Render2@OutputStreamContextMC@@UAAPAEPAE00PAUTRANSFER_STATUS@@@Z| ; OutputStreamContextMC::Render2

  00000			 AREA	 |.pdata|, PDATA
|$T35772| DCD	|$LN51@Render2@5|
	DCD	0x4000aa02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Render2@OutputStreamContextMC@@UAAPAEPAE00PAUTRANSFER_STATUS@@@Z| PROC ; OutputStreamContextMC::Render2

; 729  : {

  00000		 |$LN51@Render2@5|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd04c	 sub         sp, sp, #0x4C
  00008		 |$M35769|
  00008	e1a0b002	 mov         r11, r2
  0000c	e1a06000	 mov         r6, r0
  00010	e58db020	 str         r11, [sp, #0x20]
  00014	e58d6028	 str         r6, [sp, #0x28]
  00018	e58d301c	 str         r3, [sp, #0x1C]
  0001c	e1a09001	 mov         r9, r1

; 730  :     LONG CurrPos = m_CurrPos;
; 731  :     DWORD ClientRate = m_ClientRate;
; 732  :     DWORD BaseRate = m_pDeviceContext->GetBaseSampleRate();

  00020	e5968088	 ldr         r8, [r6, #0x88]
  00024	e596308c	 ldr         r3, [r6, #0x8C]
  00028	e5960050	 ldr         r0, [r6, #0x50]
  0002c	e58d8000	 str         r8, [sp]
  00030	e58d3024	 str         r3, [sp, #0x24]
  00034	eb000000	 bl          |?GetBaseSampleRate@DeviceContext@@QAAKXZ|
  00038	e58d0014	 str         r0, [sp, #0x14]

; 733  :     DWORD BaseRateInv = m_pDeviceContext->GetBaseSampleRateInverse();

  0003c	e5960050	 ldr         r0, [r6, #0x50]
  00040	eb000000	 bl          |?GetBaseSampleRateInverse@DeviceContext@@QAAKXZ|

; 734  : 
; 735  :     LONG CurrSamp[2];
; 736  :     LONG PrevSamp[2];
; 737  :     LONG OutSamp[2];
; 738  :     LONG fxpGain[2];
; 739  : 
; 740  :     PBYTE pCurrData = m_lpCurrData;
; 741  :     PBYTE pCurrDataEnd = m_lpCurrDataEnd;
; 742  :     LONG nChannels = m_WaveFormat.nChannels;

  00044	e5d6e027	 ldrb        lr, [r6, #0x27]
  00048	e5d65026	 ldrb        r5, [r6, #0x26]
  0004c	e59d4070	 ldr         r4, [sp, #0x70]

; 743  : 
; 744  :     int i;
; 745  : 
; 746  :     for (i=0;i<2;i++)
; 747  :     {
; 748  :         CurrSamp[i] = m_CurrSamp[i];
; 749  :         PrevSamp[i] = m_PrevSamp[i];

  00050	e596a044	 ldr         r10, [r6, #0x44]
  00054	e185340e	 orr         r3, r5, lr, lsl #8
  00058	e58d300c	 str         r3, [sp, #0xC]
  0005c	e5963048	 ldr         r3, [r6, #0x48]
  00060	e5945004	 ldr         r5, [r4, #4]
  00064	e28d7034	 add         r7, sp, #0x34
  00068	e1a02000	 mov         r2, r0
  0006c	e58d3010	 str         r3, [sp, #0x10]
  00070	e58da008	 str         r10, [sp, #8]
  00074	e58d2018	 str         r2, [sp, #0x18]
  00078	e286e078	 add         lr, r6, #0x78
  0007c	e2874008	 add         r4, r7, #8
  00080		 |$LN44@Render2@5|
  00080	e49e3004	 ldr         r3, [lr], #4
  00084	e4873004	 str         r3, [r7], #4
  00088	e1570004	 cmp         r7, r4
  0008c	1afffffb	 bne         |$LN44@Render2@5|
  00090	e28d203c	 add         r2, sp, #0x3C
  00094	e282e008	 add         lr, r2, #8
  00098	e2861080	 add         r1, r6, #0x80
  0009c		 |$LN46@Render2@5|
  0009c	e4913004	 ldr         r3, [r1], #4
  000a0	e4823004	 str         r3, [r2], #4
  000a4	e152000e	 cmp         r2, lr
  000a8	1afffffb	 bne         |$LN46@Render2@5|
  000ac	e3a02000	 mov         r2, #0
  000b0	e3a04000	 mov         r4, #0
  000b4	e28d102c	 add         r1, sp, #0x2C
  000b8	e28d002c	 add         r0, sp, #0x2C
  000bc		 |$LL27@Render2@5|

; 750  : 
; 751  :         if (pTransferStatus->Mute)

  000bc	e3550000	 cmp         r5, #0

; 752  :         {
; 753  :             fxpGain[i] = 0;
; 754  :         }
; 755  :         else
; 756  :         {
; 757  :             fxpGain[i] = m_fxpGain[i];

  000c0	00823006	 addeq       r3, r2, r6
  000c4	05933060	 ldreq       r3, [r3, #0x60]
  000c8	17824001	 strne       r4, [r2, +r1]
  000cc	07823000	 streq       r3, [r2, +r0]
  000d0	e2822004	 add         r2, r2, #4
  000d4	e3520008	 cmp         r2, #8
  000d8	bafffff7	 blt         |$LL27@Render2@5|

; 758  :         }
; 759  :     }
; 760  : 
; 761  :     while (pBuffer < pBufferEnd)

  000dc	e159000b	 cmp         r9, r11
  000e0	2a00005a	 bcs         |$Exit$35475|
  000e4	e3a03c7f	 mov         r3, #0x7F, 24
  000e8	e383b0ff	 orr         r11, r3, #0xFF
  000ec	e3e030ff	 mvn         r3, #0xFF
  000f0	e1a03383	 mov         r3, r3, lsl #7
  000f4	e58d3004	 str         r3, [sp, #4]

; 776  :             }
; 777  : 
; 778  : 
; 779  :             for (i=0;i<nChannels;i++)

  000f8	e1a06003	 mov         r6, r3
  000fc	e28d0034	 add         r0, sp, #0x34
  00100	e28d202c	 add         r2, sp, #0x2C
  00104		 |$LL22@Render2@5|

; 762  :     {
; 763  :         while (CurrPos < 0)

  00104	e3580000	 cmp         r8, #0
  00108	5a000021	 bpl         |$LN19@Render2@5|

; 729  : {

  0010c	e59de00c	 ldr         lr, [sp, #0xC]
  00110		 |$LL20@Render2@5|

; 764  :         {
; 765  :             if (pCurrData>=pCurrDataEnd)

  00110	e59d3010	 ldr         r3, [sp, #0x10]
  00114	e15a0003	 cmp         r10, r3
  00118	2a00004b	 bcs         |$LN48@Render2@5|

; 766  :             {
; 767  :                 goto Exit;
; 768  :             }
; 769  : 
; 770  :             CurrPos += BaseRate;

  0011c	e59d3014	 ldr         r3, [sp, #0x14]

; 771  : 
; 772  :             for (i=0;i<2;i++)
; 773  :             {
; 774  :                 PrevSamp[i]=CurrSamp[i];

  00120	e3a01000	 mov         r1, #0
  00124	e28d603c	 add         r6, sp, #0x3C
  00128	e0888003	 add         r8, r8, r3
  0012c	e58d8000	 str         r8, [sp]
  00130		 |$LL16@Render2@5|
  00130	e1a02001	 mov         r2, r1
  00134	e7b23006	 ldr         r3, [r2, +r6]!
  00138	e7813000	 str         r3, [r1, +r0]
  0013c	e2811004	 add         r1, r1, #4
  00140	e3510008	 cmp         r1, #8

; 775  :                 CurrSamp[i]=0;

  00144	e5824000	 str         r4, [r2]
  00148	bafffff8	 blt         |$LL16@Render2@5|

; 776  :             }
; 777  : 
; 778  : 
; 779  :             for (i=0;i<nChannels;i++)

  0014c	e59d6004	 ldr         r6, [sp, #4]
  00150	e3a00000	 mov         r0, #0
  00154	e35e0000	 cmp         lr, #0
  00158	da000009	 ble         |$LN11@Render2@5|
  0015c		 |$LL13@Render2@5|

; 780  :             {
; 781  :                 PPCM_SAMPLE pSampleSrc = (PPCM_SAMPLE)pCurrData;
; 782  :                 CurrSamp[i&1] += (LONG)pSampleSrc->m16.sample;

  0015c	e2003001	 and         r3, r0, #1
  00160	e28d103c	 add         r1, sp, #0x3C
  00164	e7b12103	 ldr         r2, [r1, +r3, lsl #2]!
  00168	e0da30f2	 ldrsh       r3, [r10], #2
  0016c	e2800001	 add         r0, r0, #1
  00170	e150000e	 cmp         r0, lr
  00174	e0833002	 add         r3, r3, r2
  00178	e5813000	 str         r3, [r1]
  0017c	bafffff6	 blt         |$LL13@Render2@5|
  00180	e58da008	 str         r10, [sp, #8]
  00184		 |$LN11@Render2@5|

; 762  :     {
; 763  :         while (CurrPos < 0)

  00184	e3580000	 cmp         r8, #0
  00188	e28d0034	 add         r0, sp, #0x34
  0018c	4affffdf	 bmi         |$LL20@Render2@5|
  00190	e28d202c	 add         r2, sp, #0x2C
  00194		 |$LN19@Render2@5|

; 783  :                 pCurrData+=2;
; 784  :             }
; 785  :         }
; 786  : 
; 787  :         // Calculate ratio between samples as a 17.15 fraction
; 788  :         // (Only use 15 bits to avoid overflow on next multiply)
; 789  :         LONG Ratio;
; 790  :         Ratio = (CurrPos * BaseRateInv)>>17;

  00194	e59d1018	 ldr         r1, [sp, #0x18]
  00198	e1a05009	 mov         r5, r9

; 791  : 
; 792  :         for (i=0;i<2;i++)
; 793  :         {
; 794  :             // Calc difference between samples. Note OutSamp0 is a 17-bit signed number now.
; 795  :             OutSamp[i] = PrevSamp[i] - CurrSamp[i];
; 796  : 
; 797  :             // Now interpolate
; 798  :             OutSamp[i] = (OutSamp[i] * Ratio) >> 15;
; 799  : 
; 800  :             // Add to previous number
; 801  :             OutSamp[i] += CurrSamp[i];
; 802  : 
; 803  :             // Gain
; 804  :             OutSamp[i] = (OutSamp[i] * fxpGain[i]) >> VOLSHIFT;
; 805  :             // DEBUGMSG(1, (TEXT("PrevSamp0=0x%x, CurrSamp0=0x%x, CurrT=0x%x, OutSamp0=0x%x\r\n"), PrevSamp0,CurrSamp0,CurrT,OutSamp0));
; 806  : 
; 807  :             if (pBuffer < pBufferLast)
; 808  :             {
; 809  :                 OutSamp[i] += ((HWSAMPLE *)pBuffer)[i];
; 810  :     #if USE_MIX_SATURATE
; 811  :                 // Handle saturation
; 812  :                 if (OutSamp[i]>AUDIO_SAMPLE_MAX)
; 813  :                 {
; 814  :                     OutSamp[i]=AUDIO_SAMPLE_MAX;

  0019c	e3a04000	 mov         r4, #0
  001a0	e0030891	 mul         r3, r1, r8
  001a4	e28d803c	 add         r8, sp, #0x3C
  001a8	e1a078a3	 mov         r7, r3, lsr #17
  001ac	e28da034	 add         r10, sp, #0x34
  001b0		 |$LL10@Render2@5|
  001b0	e7940008	 ldr         r0, [r4, +r8]
  001b4	e794300a	 ldr         r3, [r4, +r10]
  001b8	e7941002	 ldr         r1, [r4, +r2]
  001bc	e1a0e004	 mov         lr, r4
  001c0	e0433000	 sub         r3, r3, r0
  001c4	e0020793	 mul         r2, r3, r7
  001c8	e59d301c	 ldr         r3, [sp, #0x1C]
  001cc	e1590003	 cmp         r9, r3
  001d0	e08037c2	 add         r3, r0, r2, asr #15
  001d4	e0020193	 mul         r2, r3, r1
  001d8	e28d3044	 add         r3, sp, #0x44
  001dc	e1a02842	 mov         r2, r2, asr #16
  001e0	e7ae2003	 str         r2, [lr, +r3]!
  001e4	2a000006	 bcs         |$LN4@Render2@5|
  001e8	e1d530f0	 ldrsh       r3, [r5]
  001ec	e0833002	 add         r3, r3, r2
  001f0	e153000b	 cmp         r3, r11
  001f4	e58e3000	 str         r3, [lr]
  001f8	c58eb000	 strgt       r11, [lr]

; 815  :                 }
; 816  :                 else if (OutSamp[i]<AUDIO_SAMPLE_MIN)

  001fc	d3730902	 cmnle       r3, #2, 18

; 817  :                 {
; 818  :                     OutSamp[i]=AUDIO_SAMPLE_MIN;

  00200	b58e6000	 strlt       r6, [lr]
  00204		 |$LN4@Render2@5|

; 819  :                 }
; 820  :     #endif
; 821  :             }
; 822  :             ((HWSAMPLE *)pBuffer)[i] = (HWSAMPLE)OutSamp[i];

  00204	e59e3000	 ldr         r3, [lr]
  00208	e2844004	 add         r4, r4, #4
  0020c	e3540008	 cmp         r4, #8
  00210	e0c530b2	 strh        r3, [r5], #2
  00214	e28d202c	 add         r2, sp, #0x2C
  00218	baffffe4	 blt         |$LL10@Render2@5|

; 823  :         }
; 824  : 
; 825  :         pBuffer += 2*sizeof(HWSAMPLE);

  0021c	e59d3020	 ldr         r3, [sp, #0x20]
  00220	e2899004	 add         r9, r9, #4

; 826  : 
; 827  :         CurrPos -= ClientRate;

  00224	e59d8000	 ldr         r8, [sp]
  00228	e1590003	 cmp         r9, r3
  0022c	e59d3024	 ldr         r3, [sp, #0x24]
  00230	e59da008	 ldr         r10, [sp, #8]
  00234	e28d0034	 add         r0, sp, #0x34
  00238	e0488003	 sub         r8, r8, r3
  0023c	e58d8000	 str         r8, [sp]
  00240	e28d202c	 add         r2, sp, #0x2C
  00244	e3a04000	 mov         r4, #0
  00248	3affffad	 bcc         |$LL22@Render2@5|
  0024c		 |$LN48@Render2@5|

; 729  : {

  0024c	e59d6028	 ldr         r6, [sp, #0x28]
  00250		 |$Exit$35475|

; 828  :     }
; 829  : 
; 830  :     Exit:
; 831  :     m_dwByteCount += (pCurrData - m_lpCurrData);

  00250	e596204c	 ldr         r2, [r6, #0x4C]
  00254	e5963044	 ldr         r3, [r6, #0x44]

; 832  :     m_lpCurrData = pCurrData;

  00258	e586a044	 str         r10, [r6, #0x44]

; 833  :     m_CurrPos = CurrPos;

  0025c	e5868088	 str         r8, [r6, #0x88]
  00260	e0423003	 sub         r3, r2, r3
  00264	e083300a	 add         r3, r3, r10
  00268	e586304c	 str         r3, [r6, #0x4C]

; 834  :     for (i=0;i<2;i++)
; 835  :     {
; 836  :         m_PrevSamp[i] = PrevSamp[i];

  0026c	e3a00000	 mov         r0, #0
  00270	e28de034	 add         lr, sp, #0x34
  00274	e28d403c	 add         r4, sp, #0x3C
  00278		 |$LL3@Render2@5|
  00278	e790200e	 ldr         r2, [r0, +lr]

; 837  :         m_CurrSamp[i] = CurrSamp[i];

  0027c	e7901004	 ldr         r1, [r0, +r4]
  00280	e0803006	 add         r3, r0, r6
  00284	e2800004	 add         r0, r0, #4
  00288	e5832078	 str         r2, [r3, #0x78]
  0028c	e5831080	 str         r1, [r3, #0x80]
  00290	e3500008	 cmp         r0, #8
  00294	bafffff7	 blt         |$LL3@Render2@5|

; 838  :     }
; 839  : 
; 840  :     return pBuffer;
; 841  : }

  00298	e1a00009	 mov         r0, r9
  0029c	e28dd04c	 add         sp, sp, #0x4C
  002a0	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  002a4	e12fff1e	 bx          lr
  002a8		 |$M35770|

			 ENDP  ; |?Render2@OutputStreamContextMC@@UAAPAEPAE00PAUTRANSFER_STATUS@@@Z|, OutputStreamContextMC::Render2

	EXPORT	|?Render2@OutputStreamContextEncodedSPDIF@@UAAPAEPAE00PAUTRANSFER_STATUS@@@Z| ; OutputStreamContextEncodedSPDIF::Render2
	IMPORT	|memcpy|

  00000			 AREA	 |.pdata|, PDATA
|$T35791| DCD	|$LN7@Render2@6|
	DCD	0x40001901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Render2@OutputStreamContextEncodedSPDIF@@UAAPAEPAE00PAUTRANSFER_STATUS@@@Z| PROC ; OutputStreamContextEncodedSPDIF::Render2

; 844  : {

  00000		 |$LN7@Render2@6|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M35788|
  00004	e1a06001	 mov         r6, r1
  00008	e1a05000	 mov         r5, r0

; 845  :     DWORD dwSrcBytes = m_lpCurrDataEnd - m_lpCurrData;

  0000c	e5951044	 ldr         r1, [r5, #0x44]
  00010	e5953048	 ldr         r3, [r5, #0x48]

; 846  :     DWORD dwDstBytes = pBufferEnd - pBuffer;

  00014	e0422006	 sub         r2, r2, r6

; 847  :     DWORD dwBytesToCopy = min(dwSrcBytes,dwDstBytes);
; 848  : 
; 849  :     memcpy(pBuffer,m_lpCurrData,dwBytesToCopy);

  00018	e1a00006	 mov         r0, r6
  0001c	e0434001	 sub         r4, r3, r1
  00020	e1540002	 cmp         r4, r2
  00024	21a04002	 movcs       r4, r2
  00028	e1a02004	 mov         r2, r4
  0002c	eb000000	 bl          memcpy

; 850  : 
; 851  :     m_dwByteCount += dwBytesToCopy;

  00030	e595304c	 ldr         r3, [r5, #0x4C]

; 852  :     m_lpCurrData += dwBytesToCopy;

  00034	e5952044	 ldr         r2, [r5, #0x44]

; 853  : 
; 854  :     pBufferLast = pBuffer+dwBytesToCopy;
; 855  : 
; 856  :     // Send a note to hardware that the current buffer has SPDIF compressed data
; 857  :     pTransferStatus->Encoded = TRUE;

  00038	e59d1010	 ldr         r1, [sp, #0x10]
  0003c	e0833004	 add         r3, r3, r4
  00040	e585304c	 str         r3, [r5, #0x4C]
  00044	e0822004	 add         r2, r2, r4
  00048	e3a03001	 mov         r3, #1
  0004c	e5852044	 str         r2, [r5, #0x44]
  00050	e5813008	 str         r3, [r1, #8]

; 858  : 
; 859  :     // Force other streams to mute their outputs for this DMA buffer
; 860  :     pTransferStatus->Mute = TRUE;

  00054	e5813004	 str         r3, [r1, #4]
  00058	e0840006	 add         r0, r4, r6

; 861  : 
; 862  :     return pBufferLast;
; 863  : }

  0005c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$M35789|

			 ENDP  ; |?Render2@OutputStreamContextEncodedSPDIF@@UAAPAEPAE00PAUTRANSFER_STATUS@@@Z|, OutputStreamContextEncodedSPDIF::Render2

	EXPORT	|?IsExclusive@OutputStreamContextEncodedSPDIF@@UAAHXZ| ; OutputStreamContextEncodedSPDIF::IsExclusive

  00000			 AREA	 |.pdata|, PDATA
|$T35800| DCD	|$LN5@IsExclusiv|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsExclusive@OutputStreamContextEncodedSPDIF@@UAAHXZ| PROC ; OutputStreamContextEncodedSPDIF::IsExclusive

; 866  : {

  00000		 |$LN5@IsExclusiv|
  00000		 |$M35797|

; 867  :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 868  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M35798|

			 ENDP  ; |?IsExclusive@OutputStreamContextEncodedSPDIF@@UAAHXZ|, OutputStreamContextEncodedSPDIF::IsExclusive

	EXPORT	|?SetRate@OutputStreamContextEncodedSPDIF@@UAAKK@Z| ; OutputStreamContextEncodedSPDIF::SetRate

  00000			 AREA	 |.pdata|, PDATA
|$T35812| DCD	|$LN7@SetRate|
	DCD	0x40000400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetRate@OutputStreamContextEncodedSPDIF@@UAAKK@Z| PROC ; OutputStreamContextEncodedSPDIF::SetRate

; 872  : {

  00000		 |$LN7@SetRate|
  00000		 |$M35809|

; 873  :     return (dwMultiplier == 0x10000) ? MMSYSERR_NOERROR : MMSYSERR_NOTSUPPORTED ;

  00000	e3510801	 cmp         r1, #1, 16
  00004	03a00000	 moveq       r0, #0
  00008	13a00008	 movne       r0, #8

; 874  : }

  0000c	e12fff1e	 bx          lr
  00010		 |$M35810|

			 ENDP  ; |?SetRate@OutputStreamContextEncodedSPDIF@@UAAKK@Z|, OutputStreamContextEncodedSPDIF::SetRate

	END
