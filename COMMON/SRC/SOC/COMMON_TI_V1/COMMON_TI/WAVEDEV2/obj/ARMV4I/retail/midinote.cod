; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\WAVEDEV2\midinote.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|?SineTable@CMidiNote@@0QBFB| [ DATA ]	; CMidiNote::SineTable

  00000			 AREA	 |.rdata|, DATA, READONLY
|?SineTable@CMidiNote@@0QBFB| DCW 0x0			; CMidiNote::SineTable
	DCW	0x324
	DCW	0x647
	DCW	0x96a
	DCW	0xc8b
	DCW	0xfab
	DCW	0x12c7
	DCW	0x15e1
	DCW	0x18f8
	DCW	0x1c0b
	DCW	0x1f19
	DCW	0x2223
	DCW	0x2527
	DCW	0x2826
	DCW	0x2b1e
	DCW	0x2e10
	DCW	0x30fb
	DCW	0x33de
	DCW	0x36b9
	DCW	0x398c
	DCW	0x3c56
	DCW	0x3f16
	DCW	0x41cd
	DCW	0x447a
	DCW	0x471c
	DCW	0x49b3
	DCW	0x4c3f
	DCW	0x4ebf
	DCW	0x5133
	DCW	0x539a
	DCW	0x55f4
	DCW	0x5842
	DCW	0x5a81
	DCW	0x5cb3
	DCW	0x5ed6
	DCW	0x60eb
	DCW	0x62f1
	DCW	0x64e7
	DCW	0x66ce
	DCW	0x68a5
	DCW	0x6a6c
	DCW	0x6c23
	DCW	0x6dc9
	DCW	0x6f5e
	DCW	0x70e1
	DCW	0x7254
	DCW	0x73b5
	DCW	0x7503
	DCW	0x7640
	DCW	0x776b
	DCW	0x7883
	DCW	0x7989
	DCW	0x7a7c
	DCW	0x7b5c
	DCW	0x7c29
	DCW	0x7ce2
	DCW	0x7d89
	DCW	0x7e1c
	DCW	0x7e9c
	DCW	0x7f08
	DCW	0x7f61
	DCW	0x7fa6
	DCW	0x7fd7
	DCW	0x7ff5
	DCW	0x7fff
	DCW	0x7ff5
	DCW	0x7fd7
	DCW	0x7fa6
	DCW	0x7f61
	DCW	0x7f08
	DCW	0x7e9c
	DCW	0x7e1c
	DCW	0x7d89
	DCW	0x7ce2
	DCW	0x7c29
	DCW	0x7b5c
	DCW	0x7a7c
	DCW	0x7989
	DCW	0x7883
	DCW	0x776b
	DCW	0x7640
	DCW	0x7503
	DCW	0x73b5
	DCW	0x7254
	DCW	0x70e1
	DCW	0x6f5e
	DCW	0x6dc9
	DCW	0x6c23
	DCW	0x6a6c
	DCW	0x68a5
	DCW	0x66ce
	DCW	0x64e7
	DCW	0x62f1
	DCW	0x60eb
	DCW	0x5ed6
	DCW	0x5cb3
	DCW	0x5a81
	DCW	0x5842
	DCW	0x55f4
	DCW	0x539a
	DCW	0x5133
	DCW	0x4ebf
	DCW	0x4c3f
	DCW	0x49b3
	DCW	0x471c
	DCW	0x447a
	DCW	0x41cd
	DCW	0x3f16
	DCW	0x3c56
	DCW	0x398c
	DCW	0x36b9
	DCW	0x33de
	DCW	0x30fb
	DCW	0x2e10
	DCW	0x2b1e
	DCW	0x2826
	DCW	0x2527
	DCW	0x2223
	DCW	0x1f19
	DCW	0x1c0b
	DCW	0x18f8
	DCW	0x15e1
	DCW	0x12c7
	DCW	0xfab
	DCW	0xc8b
	DCW	0x96a
	DCW	0x647
	DCW	0x324
	DCW	0x0
	DCW	0xfcdc
	DCW	0xf9b9
	DCW	0xf696
	DCW	0xf375
	DCW	0xf055
	DCW	0xed39
	DCW	0xea1f
	DCW	0xe708
	DCW	0xe3f5
	DCW	0xe0e7
	DCW	0xdddd
	DCW	0xdad9
	DCW	0xd7da
	DCW	0xd4e2
	DCW	0xd1f0
	DCW	0xcf05
	DCW	0xcc22
	DCW	0xc947
	DCW	0xc674
	DCW	0xc3aa
	DCW	0xc0ea
	DCW	0xbe33
	DCW	0xbb86
	DCW	0xb8e4
	DCW	0xb64d
	DCW	0xb3c1
	DCW	0xb141
	DCW	0xaecd
	DCW	0xac66
	DCW	0xaa0c
	DCW	0xa7be
	DCW	0xa57f
	DCW	0xa34d
	DCW	0xa12a
	DCW	0x9f15
	DCW	0x9d0f
	DCW	0x9b19
	DCW	0x9932
	DCW	0x975b
	DCW	0x9594
	DCW	0x93dd
	DCW	0x9237
	DCW	0x90a2
	DCW	0x8f1f
	DCW	0x8dac
	DCW	0x8c4b
	DCW	0x8afd
	DCW	0x89c0
	DCW	0x8895
	DCW	0x877d
	DCW	0x8677
	DCW	0x8584
	DCW	0x84a4
	DCW	0x83d7
	DCW	0x831e
	DCW	0x8277
	DCW	0x81e4
	DCW	0x8164
	DCW	0x80f8
	DCW	0x809f
	DCW	0x805a
	DCW	0x8029
	DCW	0x800b
	DCW	0x8001
	DCW	0x800b
	DCW	0x8029
	DCW	0x805a
	DCW	0x809f
	DCW	0x80f8
	DCW	0x8164
	DCW	0x81e4
	DCW	0x8277
	DCW	0x831e
	DCW	0x83d7
	DCW	0x84a4
	DCW	0x8584
	DCW	0x8677
	DCW	0x877d
	DCW	0x8895
	DCW	0x89c0
	DCW	0x8afd
	DCW	0x8c4b
	DCW	0x8dac
	DCW	0x8f1f
	DCW	0x90a2
	DCW	0x9237
	DCW	0x93dd
	DCW	0x9594
	DCW	0x975b
	DCW	0x9932
	DCW	0x9b19
	DCW	0x9d0f
	DCW	0x9f15
	DCW	0xa12a
	DCW	0xa34d
	DCW	0xa57f
	DCW	0xa7be
	DCW	0xaa0c
	DCW	0xac66
	DCW	0xaecd
	DCW	0xb141
	DCW	0xb3c1
	DCW	0xb64d
	DCW	0xb8e4
	DCW	0xbb86
	DCW	0xbe33
	DCW	0xc0ea
	DCW	0xc3aa
	DCW	0xc674
	DCW	0xc947
	DCW	0xcc22
	DCW	0xcf05
	DCW	0xd1f0
	DCW	0xd4e2
	DCW	0xd7da
	DCW	0xdad9
	DCW	0xdddd
	DCW	0xe0e7
	DCW	0xe3f5
	DCW	0xe708
	DCW	0xea1f
	DCW	0xed39
	DCW	0xf055
	DCW	0xf375
	DCW	0xf696
	DCW	0xf9b9
	DCW	0xfcdc
	DCW	0x0
	EXPORT	|?GainChange@CMidiNote@@QAAXXZ|		; CMidiNote::GainChange
	IMPORT	|?MapNoteGain@CMidiStream@@QAAKKK@Z|	; CMidiStream::MapNoteGain
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\wavedev2\midinote.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T35368| DCD	|$LN10@GainChange|
	DCD	0x40000f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GainChange@CMidiNote@@QAAXXZ| PROC	; CMidiNote::GainChange

; 293  : {

  00000		 |$LN10@GainChange|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M35365|
  00004	e1a04000	 mov         r4, r0

; 294  :     // We keep separate volumes for both channels
; 295  :     for (int i=0; i<2; i++)

  00008	e3a05000	 mov         r5, #0
  0000c	e1a06004	 mov         r6, r4
  00010		 |$LL3@GainChange|

; 296  :     {
; 297  : #if (MONO_GAIN)
; 298  :         m_fxpGain[i] = m_pMidiStream->MapNoteGain(m_dwGain,0);
; 299  : #else
; 300  :         m_fxpGain[i] = m_pMidiStream->MapNoteGain(m_dwGain,i);

  00010	e5941020	 ldr         r1, [r4, #0x20]
  00014	e5940008	 ldr         r0, [r4, #8]
  00018	e1a02005	 mov         r2, r5
  0001c	eb000000	 bl          |?MapNoteGain@CMidiStream@@QAAKKK@Z|
  00020	e2855001	 add         r5, r5, #1
  00024	e5860024	 str         r0, [r6, #0x24]
  00028	e2866004	 add         r6, r6, #4
  0002c	e3550002	 cmp         r5, #2
  00030	bafffff6	 blt         |$LL3@GainChange|

; 301  : #endif
; 302  :     }
; 303  : }

  00034	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$M35366|

			 ENDP  ; |?GainChange@CMidiNote@@QAAXXZ|, CMidiNote::GainChange

	EXPORT	|?ResetBaseInfo@CMidiNote@@QAAXXZ|	; CMidiNote::ResetBaseInfo
	IMPORT	|?GetDeltaFromNote@CMidiStream@@QAAKK@Z| ; CMidiStream::GetDeltaFromNote
	IMPORT	|?GetDeltaFromFreq@CMidiStream@@QAAKK@Z| ; CMidiStream::GetDeltaFromFreq

  00000			 AREA	 |.pdata|, PDATA
|$T35377| DCD	|$LN8@ResetBaseI|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResetBaseInfo@CMidiNote@@QAAXXZ| PROC ; CMidiNote::ResetBaseInfo

; 307  : {

  00000		 |$LN8@ResetBaseI|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M35374|
  00004	e1a04000	 mov         r4, r0

; 308  :     if (m_Channel==FREQCHANNEL)

  00008	e5943014	 ldr         r3, [r4, #0x14]

; 309  :     {
; 310  :         m_IndexDelta = m_pMidiStream->GetDeltaFromFreq(m_Note);

  0000c	e594100c	 ldr         r1, [r4, #0xC]
  00010	e5940008	 ldr         r0, [r4, #8]
  00014	e3530010	 cmp         r3, #0x10
  00018	1a000001	 bne         |$LN2@ResetBaseI|
  0001c	eb000000	 bl          |?GetDeltaFromFreq@CMidiStream@@QAAKK@Z|

; 311  :     }
; 312  :     else

  00020	ea000000	 b           |$LN5@ResetBaseI|
  00024		 |$LN2@ResetBaseI|

; 313  :     {
; 314  :         m_IndexDelta = m_pMidiStream->GetDeltaFromNote(m_Note);

  00024	eb000000	 bl          |?GetDeltaFromNote@CMidiStream@@QAAKK@Z|
  00028		 |$LN5@ResetBaseI|
  00028	e584001c	 str         r0, [r4, #0x1C]

; 315  :     }
; 316  : 
; 317  :     return;
; 318  : }

  0002c	e8bd4010	 ldmia       sp!, {r4, lr}
  00030	e12fff1e	 bx          lr
  00034		 |$M35375|

			 ENDP  ; |?ResetBaseInfo@CMidiNote@@QAAXXZ|, CMidiNote::ResetBaseInfo

	EXPORT	|?NoteOff@CMidiNote@@QAAJI@Z|		; CMidiNote::NoteOff
	IMPORT	|__rt_udiv|

  00000			 AREA	 |.pdata|, PDATA
|$T35389| DCD	|$LN7@NoteOff|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?NoteOff@CMidiNote@@QAAJI@Z| PROC	; CMidiNote::NoteOff

; 340  : {

  00000		 |$LN7@NoteOff|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M35386|
  00004	e1a04000	 mov         r4, r0

; 341  : 	UNREFERENCED_PARAMETER(Velocity);
; 342  : 
; 343  :     // Calculate the number of samples left before we cross a 0 boundary at the middle or end of the table
; 344  :     DWORD SamplesLeft;
; 345  :     if (m_IndexDelta)

  00008	e594301c	 ldr         r3, [r4, #0x1C]
  0000c	e1b00003	 movs        r0, r3
  00010	0a000005	 beq         |$LN2@NoteOff|

; 346  :         {
; 347  :         SamplesLeft = ( ((0-m_Index)&0x7FFFFFFF) /m_IndexDelta) + 1;

  00014	e5943018	 ldr         r3, [r4, #0x18]
  00018	e2633000	 rsb         r3, r3, #0
  0001c	e3c31102	 bic         r1, r3, #2, 2
  00020	eb000000	 bl          __rt_udiv
  00024	e2803001	 add         r3, r0, #1

; 348  :         }
; 349  :     else

  00028	ea000000	 b           |$LN1@NoteOff|
  0002c		 |$LN2@NoteOff|

; 350  :         {
; 351  :         SamplesLeft=0;

  0002c	e3a03000	 mov         r3, #0
  00030		 |$LN1@NoteOff|

; 352  :         }
; 353  : 
; 354  :     m_dwBytesLeft = SamplesLeft * sizeof(HWSAMPLE) * OUTCHANNELS;

  00030	e1a03103	 mov         r3, r3, lsl #2
  00034	e584302c	 str         r3, [r4, #0x2C]

; 355  :     DEBUGMSG(1, (TEXT("CMidiNote::NoteOff, m_Index = 0x%x, m_IndexDelta = 0x%x, m_dwBytesLeft = %d\r\n"),m_Index,m_IndexDelta,m_dwBytesLeft));
; 356  :     // m_pMidiStream->NoteDone(this);
; 357  :     return S_OK;

  00038	e3a00000	 mov         r0, #0

; 358  : }

  0003c	e8bd4010	 ldmia       sp!, {r4, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M35387|

			 ENDP  ; |?NoteOff@CMidiNote@@QAAJI@Z|, CMidiNote::NoteOff

	EXPORT	|?Render2@CMidiNote@@QAAPAEPAE00PAUTRANSFER_STATUS@@@Z| ; CMidiNote::Render2

  00000			 AREA	 |.pdata|, PDATA
|$T35413| DCD	|$LN19@Render2|
	DCD	0x40003f02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Render2@CMidiNote@@QAAPAEPAE00PAUTRANSFER_STATUS@@@Z| PROC ; CMidiNote::Render2

; 403  : {

  00000		 |$LN19@Render2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M35410|
  00008	e1a0b003	 mov         r11, r3
  0000c	e1a09002	 mov         r9, r2
  00010	e1a04001	 mov         r4, r1
  00014	e58d0004	 str         r0, [sp, #4]

; 404  :     // Cache values so compiler won't worry about aliasing
; 405  :     UINT32 Index            = m_Index;
; 406  :     UINT32 IndexDelta       = m_IndexDelta;
; 407  :     const INT16 * pSineTable = SineTable;
; 408  :     LONG fxpGain[2];
; 409  : 
; 410  :     if (pTransferStatus->Mute)

  00018	e59de02c	 ldr         lr, [sp, #0x2C]
  0001c	e590301c	 ldr         r3, [r0, #0x1C]
  00020	e5908018	 ldr         r8, [r0, #0x18]
  00024	e59ee004	 ldr         lr, [lr, #4]
  00028	e58d3000	 str         r3, [sp]
  0002c	e35e0000	 cmp         lr, #0

; 411  :     {
; 412  :         fxpGain[0] = 0;

  00030	13a06000	 movne       r6, #0

; 413  :         fxpGain[1] = 0;
; 414  :     }
; 415  :     else
; 416  :     {
; 417  :         fxpGain[0] = m_fxpGain[0];

  00034	05906024	 ldreq       r6, [r0, #0x24]
  00038	13a07000	 movne       r7, #0

; 418  :         fxpGain[1] = m_fxpGain[1];

  0003c	05907028	 ldreq       r7, [r0, #0x28]

; 419  :     }
; 420  : 
; 421  :     while (pBuffer < pBufferEnd)

  00040	e1540009	 cmp         r4, r9
  00044	2a000026	 bcs         |$LN8@Render2|
  00048	e3a03c7f	 mov         r3, #0x7F, 24
  0004c	e59fa0a4	 ldr         r10, [pc, #0xA4]
  00050	e59d0000	 ldr         r0, [sp]
  00054	e38350ff	 orr         r5, r3, #0xFF
  00058		 |$LL9@Render2|

; 422  :     {
; 423  :         // Index is in 8.24 format, where the top 8 bits index into the sine table and
; 424  :         // the lower 24 bits represent the fraction of where we sit between two adjacent
; 425  :         // samples, which we can use if we're doing linear interpolation
; 426  :         // I chose 8.24 format so that wrap around at the top of the table happens
; 427  :         // automatically without the need to do any ANDing.
; 428  : 
; 429  :         // Get an index into the sine table and look up the sample.
; 430  :         UINT32 TableIndex = Index>>24;

  00058	e1a03c28	 mov         r3, r8, lsr #24

; 431  :         INT32 OutSamp0 = pSineTable[TableIndex];

  0005c	e08a3083	 add         r3, r10, r3, lsl #1
  00060	e1d310f0	 ldrsh       r1, [r3]

; 432  : 
; 433  : #if MIDI_OPTIMIZE_LINEAR_INTERPOLATE
; 434  :         // If we're doing linear interpolation, get the next sample also. Note that I don't
; 435  :         // need to worry about wrap around at the top of the table because the sine table has
; 436  :         // an extra value tacked onto the end to handle this special case.
; 437  :         INT32 NextSamp = pSineTable[TableIndex+1];
; 438  : 
; 439  :         // Now do the interpolation, adjusting the index to be in 24.8 format and throwing away
; 440  :         // the integer part (e.g. interpolate 256 points between samples).
; 441  :         OutSamp0 += ( (NextSamp - OutSamp0) * ((Index>>16)&0x00FF) ) >> 8;
; 442  : #endif
; 443  : 
; 444  :         // Increment the index to move to the next sample
; 445  :         // and keep within the valid range
; 446  :         Index += IndexDelta;

  00064	e0888000	 add         r8, r8, r0

; 447  : 
; 448  : #if (OUTCHANNELS==2)
; 449  :         INT32 OutSamp1;
; 450  :         OutSamp1=OutSamp0;
; 451  : 
; 452  :         // Volume!
; 453  :         OutSamp0 = (OutSamp0 * fxpGain[0]) >> VOLSHIFT;
; 454  :         OutSamp1 = (OutSamp1 * fxpGain[1]) >> VOLSHIFT;
; 455  : 
; 456  :         if (pBuffer < pBufferLast)

  00068	e154000b	 cmp         r4, r11
  0006c	e0030791	 mul         r3, r1, r7
  00070	e0020691	 mul         r2, r1, r6
  00074	e1a01843	 mov         r1, r3, asr #16
  00078	e1a0e842	 mov         lr, r2, asr #16
  0007c	2a000012	 bcs         |$LN1@Render2|

; 457  :         {
; 458  :             OutSamp0 += ((HWSAMPLE *)pBuffer)[0];

  00080	e1d430f0	 ldrsh       r3, [r4]

; 459  :             OutSamp1 += ((HWSAMPLE *)pBuffer)[1];

  00084	e1d420f2	 ldrsh       r2, [r4, #2]
  00088	e08ee003	 add         lr, lr, r3

; 460  : 
; 461  : #if USE_MIX_SATURATE
; 462  :             // Handle saturation
; 463  :             if (OutSamp0>AUDIO_SAMPLE_MAX)

  0008c	e15e0005	 cmp         lr, r5
  00090	e0811002	 add         r1, r1, r2
  00094	da000005	 ble         |$LN6@Render2|

; 464  :             {
; 465  :                 OutSamp0=AUDIO_SAMPLE_MAX;

  00098	e1a0e005	 mov         lr, r5
  0009c		 |$LN16@Render2|

; 404  :     // Cache values so compiler won't worry about aliasing
; 405  :     UINT32 Index            = m_Index;
; 406  :     UINT32 IndexDelta       = m_IndexDelta;
; 407  :     const INT16 * pSineTable = SineTable;
; 408  :     LONG fxpGain[2];
; 409  : 
; 410  :     if (pTransferStatus->Mute)

  0009c	e3e030ff	 mvn         r3, #0xFF
  000a0		 |$LN4@Render2|

; 470  :             }
; 471  :             if (OutSamp1>AUDIO_SAMPLE_MAX)

  000a0	e1510005	 cmp         r1, r5
  000a4	da000006	 ble         |$LN3@Render2|

; 472  :             {
; 473  :                 OutSamp1=AUDIO_SAMPLE_MAX;

  000a8	e1a01005	 mov         r1, r5
  000ac	ea000006	 b           |$LN1@Render2|
  000b0		 |$LN6@Render2|

; 466  :             }
; 467  :             else if (OutSamp0<AUDIO_SAMPLE_MIN)

  000b0	e37e0902	 cmn         lr, #2, 18
  000b4	aafffff8	 bge         |$LN16@Render2|

; 468  :             {
; 469  :                 OutSamp0=AUDIO_SAMPLE_MIN;

  000b8	e3e030ff	 mvn         r3, #0xFF
  000bc	e1a0e383	 mov         lr, r3, lsl #7
  000c0	eafffff6	 b           |$LN4@Render2|
  000c4		 |$LN3@Render2|

; 474  :             }
; 475  :             else if (OutSamp1<AUDIO_SAMPLE_MIN)

  000c4	e3710902	 cmn         r1, #2, 18

; 476  :             {
; 477  :                 OutSamp1=AUDIO_SAMPLE_MIN;

  000c8	b1a01383	 movlt       r1, r3, lsl #7
  000cc		 |$LN1@Render2|

; 478  :             }
; 479  : #endif
; 480  :         }
; 481  :         ((HWSAMPLE *)pBuffer)[0] = (HWSAMPLE)OutSamp0;

  000cc	e1c4e0b0	 strh        lr, [r4]

; 482  :         ((HWSAMPLE *)pBuffer)[1] = (HWSAMPLE)OutSamp1;

  000d0	e1c410b2	 strh        r1, [r4, #2]

; 483  :         pBuffer += 2*sizeof(HWSAMPLE);

  000d4	e2844004	 add         r4, r4, #4
  000d8	e1540009	 cmp         r4, r9
  000dc	3affffdd	 bcc         |$LL9@Render2|

; 403  : {

  000e0	e59d0004	 ldr         r0, [sp, #4]
  000e4		 |$LN8@Render2|

; 484  : #else
; 485  :         // Volume!
; 486  :         OutSamp0 = (OutSamp0 * fxpGain[0]) >> VOLSHIFT;
; 487  : 
; 488  :         if (pBuffer<pBufferLast)
; 489  :         {
; 490  :             // Store/sum to the output buffer
; 491  :             OutSamp0 += *(HWSAMPLE *)pBuffer;
; 492  : 
; 493  : #if USE_MIX_SATURATE
; 494  :             // Handle saturation
; 495  :             if (OutSamp0>AUDIO_SAMPLE_MAX)
; 496  :             {
; 497  :                 OutSamp0=AUDIO_SAMPLE_MAX;
; 498  :             }
; 499  :             else if (OutSamp0<AUDIO_SAMPLE_MIN)
; 500  :             {
; 501  :                 OutSamp0=AUDIO_SAMPLE_MIN;
; 502  :             }
; 503  : #endif
; 504  :         }
; 505  :         ((HWSAMPLE *)pBuffer)[0] = (HWSAMPLE)OutSamp0;
; 506  :         pBuffer+=sizeof(HWSAMPLE);
; 507  : #endif
; 508  :     }
; 509  : 
; 510  :     // Save cached settings that might have changed in the inner loop
; 511  :     m_Index = Index;

  000e4	e5808018	 str         r8, [r0, #0x18]

; 512  : 
; 513  :     return pBuffer;
; 514  : }

  000e8	e1a00004	 mov         r0, r4
  000ec	e28dd008	 add         sp, sp, #8
  000f0	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  000f4	e12fff1e	 bx          lr
  000f8		 |$LN20@Render2|
  000f8		 |$LN21@Render2|
  000f8	00000000	 DCD         |?SineTable@CMidiNote@@0QBFB|
  000fc		 |$M35411|

			 ENDP  ; |?Render2@CMidiNote@@QAAPAEPAE00PAUTRANSFER_STATUS@@@Z|, CMidiNote::Render2

	EXPORT	|?NoteVal@CMidiNote@@QAAIXZ|		; CMidiNote::NoteVal

  00000			 AREA	 |.pdata|, PDATA
|$T35425| DCD	|$LN5@NoteVal|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?NoteVal@CMidiNote@@QAAIXZ| PROC	; CMidiNote::NoteVal

; 517  : {

  00000		 |$LN5@NoteVal|
  00000		 |$M35422|

; 518  :     return m_Note;

  00000	e590000c	 ldr         r0, [r0, #0xC]

; 519  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M35423|

			 ENDP  ; |?NoteVal@CMidiNote@@QAAIXZ|, CMidiNote::NoteVal

	EXPORT	|?NoteChannel@CMidiNote@@QAAIXZ|	; CMidiNote::NoteChannel

  00000			 AREA	 |.pdata|, PDATA
|$T35435| DCD	|$LN5@NoteChanne|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?NoteChannel@CMidiNote@@QAAIXZ| PROC	; CMidiNote::NoteChannel

; 522  : {

  00000		 |$LN5@NoteChanne|
  00000		 |$M35432|

; 523  :     return m_Channel;

  00000	e5900014	 ldr         r0, [r0, #0x14]

; 524  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M35433|

			 ENDP  ; |?NoteChannel@CMidiNote@@QAAIXZ|, CMidiNote::NoteChannel

	EXPORT	|?SetVelocity@CMidiNote@@QAAXI@Z|	; CMidiNote::SetVelocity

  00000			 AREA	 |.pdata|, PDATA
|$T35444| DCD	|$LN5@SetVelocit|
	DCD	0x40000b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetVelocity@CMidiNote@@QAAXI@Z| PROC	; CMidiNote::SetVelocity

; 527  : {

  00000		 |$LN5@SetVelocit|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M35441|
  00004	e1a02000	 mov         r2, r0

; 528  :     // Reset the bytes left value here. This ensures that if a note is going away we bring it back.
; 529  :     m_dwBytesLeft = (DWORD)-1;

  00008	e3e00000	 mvn         r0, #0

; 530  : 
; 531  :     // Velocity is a 7-bit value in MIDI
; 532  :     m_Velocity = Velocity;
; 533  : 
; 534  :     // Convert to a 16-bit value
; 535  :     m_dwGain   = (Velocity<<9);

  0000c	e582002c	 str         r0, [r2, #0x2C]
  00010	e1a03481	 mov         r3, r1, lsl #9

; 536  :     GainChange();

  00014	e1a00002	 mov         r0, r2
  00018	e5823020	 str         r3, [r2, #0x20]
  0001c	e5821010	 str         r1, [r2, #0x10]
  00020	eb000000	 bl          |?GainChange@CMidiNote@@QAAXXZ|

; 537  : }

  00024	e49de004	 ldr         lr, [sp], #4
  00028	e12fff1e	 bx          lr
  0002c		 |$M35442|

			 ENDP  ; |?SetVelocity@CMidiNote@@QAAXI@Z|, CMidiNote::SetVelocity

	EXPORT	|?NoteOn@CMidiNote@@QAAJPAVCMidiStream@@III@Z| ; CMidiNote::NoteOn

  00000			 AREA	 |.pdata|, PDATA
|$T35460| DCD	|$LN7@NoteOn|
	DCD	0x40001401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?NoteOn@CMidiNote@@QAAJPAVCMidiStream@@III@Z| PROC ; CMidiNote::NoteOn

; 321  : {

  00000		 |$LN7@NoteOn|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M35457|
  00004	e1a05003	 mov         r5, r3
  00008	e1a04000	 mov         r4, r0

; 322  :     // Save params
; 323  :     m_pMidiStream = pMidiStream;
; 324  :     m_Note     = Note;
; 325  :     m_Channel  = Channel;

  0000c	e59de00c	 ldr         lr, [sp, #0xC]

; 326  : 
; 327  :     // Init pitch
; 328  :     m_Index = 0;

  00010	e3a03000	 mov         r3, #0

; 329  : 
; 330  :     // Set sample rate
; 331  :     ResetBaseInfo();

  00014	e5841008	 str         r1, [r4, #8]
  00018	e584e014	 str         lr, [r4, #0x14]
  0001c	e584200c	 str         r2, [r4, #0xC]
  00020	e5843018	 str         r3, [r4, #0x18]
  00024	eb000000	 bl          |?ResetBaseInfo@CMidiNote@@QAAXXZ|

; 332  : 
; 333  :     // Set volume (velocity)
; 334  :     SetVelocity(Velocity);

  00028	e3e03000	 mvn         r3, #0
  0002c	e1a02485	 mov         r2, r5, lsl #9
  00030	e1a00004	 mov         r0, r4
  00034	e584302c	 str         r3, [r4, #0x2C]
  00038	e5842020	 str         r2, [r4, #0x20]
  0003c	e5845010	 str         r5, [r4, #0x10]
  00040	eb000000	 bl          |?GainChange@CMidiNote@@QAAXXZ|

; 335  : 
; 336  :     return S_OK;

  00044	e3a00000	 mov         r0, #0

; 337  : }

  00048	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M35458|

			 ENDP  ; |?NoteOn@CMidiNote@@QAAJPAVCMidiStream@@III@Z|, CMidiNote::NoteOn

	EXPORT	|?Render@CMidiNote@@QAAPAEPAE00PAUTRANSFER_STATUS@@@Z| ; CMidiNote::Render
	IMPORT	|?NoteDone@CMidiStream@@QAAXPAVCMidiNote@@@Z| ; CMidiStream::NoteDone

  00000			 AREA	 |.pdata|, PDATA
|$T35477| DCD	|$LN9@Render|
	DCD	0x40002302
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Render@CMidiNote@@QAAPAEPAE00PAUTRANSFER_STATUS@@@Z| PROC ; CMidiNote::Render

; 361  : {

  00000		 |$LN9@Render|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M35474|
  00008	e1a07003	 mov         r7, r3
  0000c	e1a05001	 mov         r5, r1
  00010	e1a04000	 mov         r4, r0

; 362  :     DWORD BytesLeft = m_dwBytesLeft;

  00014	e594002c	 ldr         r0, [r4, #0x2C]

; 363  : 
; 364  :     // Handle common case first
; 365  :     if (BytesLeft==(DWORD)-1)

  00018	e3700001	 cmn         r0, #1
  0001c	1a000005	 bne         |$LN4@Render|

; 366  :     {
; 367  :         // Call real inner loop
; 368  :         return Render2(pBuffer,pBufferEnd,pBufferLast,pTransferStatus);

  00020	e59de018	 ldr         lr, [sp, #0x18]
  00024	e1a00004	 mov         r0, r4
  00028	e58de000	 str         lr, [sp]
  0002c	eb000000	 bl          |?Render2@CMidiNote@@QAAPAEPAE00PAUTRANSFER_STATUS@@@Z|
  00030	e1a05000	 mov         r5, r0
  00034	ea000010	 b           |$LN1@Render|
  00038		 |$LN4@Render|

; 369  :     }
; 370  : 
; 371  :     DEBUGMSG(1, (TEXT("CMidiNote::Render, Note in release, m_dwBytesLeft = %d\r\n"),BytesLeft));
; 372  : 
; 373  :     DWORD BytesThisBuf = (pBufferEnd-pBuffer);
; 374  :     if (BytesLeft > BytesThisBuf)
; 375  :     {
; 376  :         // If we can't end during this buffer, just remember where we were
; 377  :         BytesLeft-=BytesThisBuf;
; 378  :     }
; 379  :     else
; 380  :     {
; 381  :         // Ok, we end during this buffer. Update pBufferEnd to force the renderer to stop on a 0 crossing.
; 382  :         pBufferEnd = pBuffer + BytesLeft;
; 383  :         BytesLeft=0;
; 384  :     }
; 385  : 
; 386  :     m_dwBytesLeft = BytesLeft;
; 387  : 
; 388  :     // Call real inner loop
; 389  :     pBufferLast = Render2(pBuffer,pBufferEnd,pBufferLast,pTransferStatus);

  00038	e59d1018	 ldr         r1, [sp, #0x18]
  0003c	e0423005	 sub         r3, r2, r5
  00040	e1500003	 cmp         r0, r3
  00044	80406003	 subhi       r6, r0, r3
  00048	93a06000	 movls       r6, #0
  0004c	90802005	 addls       r2, r0, r5
  00050	e58d1000	 str         r1, [sp]
  00054	e1a03007	 mov         r3, r7
  00058	e1a01005	 mov         r1, r5
  0005c	e1a00004	 mov         r0, r4
  00060	e584602c	 str         r6, [r4, #0x2C]
  00064	eb000000	 bl          |?Render2@CMidiNote@@QAAPAEPAE00PAUTRANSFER_STATUS@@@Z|

; 390  : 
; 391  :     if (BytesLeft==0)

  00068	e3560000	 cmp         r6, #0
  0006c	e1a05000	 mov         r5, r0

; 392  :     {
; 393  :         // Time to end the note.
; 394  :         DEBUGMSG(1, (TEXT("CMidiNote::Render, Last index after note done = 0x%x\r\n"),m_Index));
; 395  :         m_pMidiStream->NoteDone(this);

  00070	05940008	 ldreq       r0, [r4, #8]
  00074	01a01004	 moveq       r1, r4
  00078	0b000000	 bleq        |?NoteDone@CMidiStream@@QAAXPAVCMidiNote@@@Z|
  0007c		 |$LN1@Render|

; 396  :     }
; 397  : 
; 398  :     return pBufferLast;
; 399  : }

  0007c	e1a00005	 mov         r0, r5
  00080	e28dd004	 add         sp, sp, #4
  00084	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$M35475|

			 ENDP  ; |?Render@CMidiNote@@QAAPAEPAE00PAUTRANSFER_STATUS@@@Z|, CMidiNote::Render

	END
