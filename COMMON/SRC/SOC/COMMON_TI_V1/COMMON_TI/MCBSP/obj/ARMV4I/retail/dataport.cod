; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\MCBSP\dataport.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|DmaConfigure|
	IMPORT	|DmaGetLogicalChannel|
	IMPORT	|memset|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\mcbsp\dma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T37012| DCD	|$LN9@DmaConfigu|
	DCD	0x40003901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaConfigure| PROC

; 172  : {

  00000		 |$LN9@DmaConfigu|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M37009|
  00004	e1a04003	 mov         r4, r3
  00008	e1a09002	 mov         r9, r2
  0000c	e1a06001	 mov         r6, r1
  00010	e1a05000	 mov         r5, r0

; 173  :     BOOL rc = FALSE;
; 174  :     OMAP_DMA_LC_REGS *pDmaLcReg = (OMAP_DMA_LC_REGS*)DmaGetLogicalChannel(hDmaChannel);

  00014	e3a08000	 mov         r8, #0
  00018	eb000000	 bl          DmaGetLogicalChannel
  0001c	e1b07000	 movs        r7, r0

; 175  :     if (pDmaLcReg == NULL || pConfigInfo == NULL)

  00020	0a00002c	 beq         |$cleanUp$35970|
  00024	e3560000	 cmp         r6, #0
  00028	0a00002a	 beq         |$cleanUp$35970|

; 176  :         {
; 177  :         goto cleanUp;
; 178  :         }
; 179  : 
; 180  :     // initialize dma DataInfo if necessary
; 181  :     if (pDataInfo != NULL)

  0002c	e3540000	 cmp         r4, #0
  00030	0a000005	 beq         |$LN1@DmaConfigu|

; 182  :         {
; 183  :         memset(pDataInfo, 0, sizeof(DmaDataInfo_t));

  00034	e3a02018	 mov         r2, #0x18
  00038	e3a01000	 mov         r1, #0
  0003c	e1a00004	 mov         r0, r4
  00040	eb000000	 bl          memset

; 184  :         pDataInfo->hDmaChannel = hDmaChannel;

  00044	e5845010	 str         r5, [r4, #0x10]

; 185  :         pDataInfo->pDmaLcReg = pDmaLcReg;

  00048	e5847014	 str         r7, [r4, #0x14]
  0004c		 |$LN1@DmaConfigu|

; 186  :         }
; 187  : 
; 188  :     // Disable the DMA in case it is running
; 189  :     CLRREG32(&pDmaLcReg->CCR, DMA_CCR_ENABLE);

  0004c	e5973000	 ldr         r3, [r7]

; 190  : 
; 191  :     // update syncmap
; 192  :     pConfigInfo->syncMap = syncMap;
; 193  : 
; 194  :     // Initialize logical channel registers
; 195  :     //
; 196  :     OUTREG32(&pDmaLcReg->CCR, 0);

  00050	e3a02000	 mov         r2, #0

; 197  :     OUTREG32(&pDmaLcReg->CLNK_CTRL, 0);
; 198  :     OUTREG32(&pDmaLcReg->COLOR, 0);
; 199  : 
; 200  :     // update CSDP
; 201  :     //  DATA_TYPE
; 202  :     //  DST
; 203  :     //  SRC
; 204  :     OUTREG32(&pDmaLcReg->CSDP, pConfigInfo->elemSize);
; 205  : 
; 206  :     // update CCR
; 207  :     //  DST_MODE
; 208  :     //  SRC_MODE
; 209  :     //  PRIO
; 210  :     //  SYNC
; 211  :     //
; 212  :     OUTREG32(&pDmaLcReg->CCR, pConfigInfo->srcAddrMode |
; 213  :         pConfigInfo->dstAddrMode | pConfigInfo->dmaPrio |
; 214  :         DMA_CCR_SYNC(syncMap) | pConfigInfo->synchTrigger |
; 215  :         pConfigInfo->synchMode
; 216  :         );

  00054	e2090060	 and         r0, r9, #0x60
  00058	e3c33080	 bic         r3, r3, #0x80
  0005c	e5873000	 str         r3, [r7]
  00060	e586902c	 str         r9, [r6, #0x2C]
  00064	e5872000	 str         r2, [r7]
  00068	e5872004	 str         r2, [r7, #4]
  0006c	e5872044	 str         r2, [r7, #0x44]
  00070	e5963000	 ldr         r3, [r6]

; 217  : 
; 218  :     // update CSEI
; 219  :     //
; 220  :     OUTREG32(&pDmaLcReg->CSEI, pConfigInfo->srcElemIndex);
; 221  : 
; 222  :     // update CDEI
; 223  :     //
; 224  :     OUTREG32(&pDmaLcReg->CDEI, pConfigInfo->dstElemIndex);
; 225  : 
; 226  :     // update CSFI
; 227  :     //
; 228  :     OUTREG32(&pDmaLcReg->CSFI, pConfigInfo->srcFrameIndex);
; 229  : 
; 230  :     // update CDFI
; 231  :     //
; 232  :     OUTREG32(&pDmaLcReg->CDFI, pConfigInfo->dstFrameIndex);
; 233  : 
; 234  :     // update CICR
; 235  :     //
; 236  :     OUTREG32(&pDmaLcReg->CICR , pConfigInfo->interrupts);
; 237  :     
; 238  :     rc = TRUE;

  00074	e3a08001	 mov         r8, #1
  00078	e5873010	 str         r3, [r7, #0x10]
  0007c	e5962024	 ldr         r2, [r6, #0x24]
  00080	e209301f	 and         r3, r9, #0x1F
  00084	e5961020	 ldr         r1, [r6, #0x20]
  00088	e1833700	 orr         r3, r3, r0, lsl #14
  0008c	e1833002	 orr         r3, r3, r2
  00090	e596201c	 ldr         r2, [r6, #0x1C]
  00094	e1833001	 orr         r3, r3, r1
  00098	e5961018	 ldr         r1, [r6, #0x18]
  0009c	e1833002	 orr         r3, r3, r2
  000a0	e596200c	 ldr         r2, [r6, #0xC]
  000a4	e1833001	 orr         r3, r3, r1
  000a8	e1833002	 orr         r3, r3, r2
  000ac	e5873000	 str         r3, [r7]
  000b0	e5963004	 ldr         r3, [r6, #4]
  000b4	e5873024	 str         r3, [r7, #0x24]
  000b8	e5963010	 ldr         r3, [r6, #0x10]
  000bc	e587302c	 str         r3, [r7, #0x2C]
  000c0	e5963008	 ldr         r3, [r6, #8]
  000c4	e5873028	 str         r3, [r7, #0x28]
  000c8	e5963014	 ldr         r3, [r6, #0x14]
  000cc	e5873030	 str         r3, [r7, #0x30]
  000d0	e5963028	 ldr         r3, [r6, #0x28]
  000d4	e5873008	 str         r3, [r7, #8]
  000d8		 |$cleanUp$35970|

; 239  : 
; 240  : cleanUp:
; 241  :     return rc;
; 242  : }

  000d8	e1a00008	 mov         r0, r8
  000dc	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000e0	e12fff1e	 bx          lr
  000e4		 |$M37010|

			 ENDP  ; |DmaConfigure|

	EXPORT	|DmaUpdate|

  00000			 AREA	 |.pdata|, PDATA
|$T37026| DCD	|$LN8@DmaUpdate|
	DCD	0x40002d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaUpdate| PROC

; 257  : {

  00000		 |$LN8@DmaUpdate|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37023|
  00004	e3520000	 cmp         r2, #0
  00008	e1a05000	 mov         r5, r0

; 258  :     BOOL rc = FALSE;

  0000c	e3a00000	 mov         r0, #0

; 259  :     OMAP_DMA_LC_REGS *pDmaLcReg;
; 260  : 
; 261  :     if (pDataInfo == NULL || pDataInfo->pDmaLcReg == NULL)

  00010	0a000025	 beq         |$cleanUp$36007|
  00014	e5923014	 ldr         r3, [r2, #0x14]
  00018	e1b04003	 movs        r4, r3
  0001c	0a000022	 beq         |$cleanUp$36007|

; 262  :         {
; 263  :         goto cleanUp;
; 264  :         }
; 265  :     pDmaLcReg = pDataInfo->pDmaLcReg;
; 266  : 
; 267  :     // Disable the DMA in case it is running
; 268  :     CLRREG32(&pDmaLcReg->CCR, DMA_CCR_ENABLE);

  00020	e5943000	 ldr         r3, [r4]

; 269  : 
; 270  :     // update syncmap
; 271  :     pConfigInfo->syncMap = syncMap;
; 272  : 
; 273  :     // Initialize logical channel registers
; 274  :     //
; 275  :     OUTREG32(&pDmaLcReg->CCR, 0);

  00024	e3a02000	 mov         r2, #0

; 276  :     OUTREG32(&pDmaLcReg->CLNK_CTRL, 0);
; 277  :     OUTREG32(&pDmaLcReg->COLOR, 0);
; 278  : 
; 279  :     // update CSDP
; 280  :     //  DATA_TYPE
; 281  :     //  DST
; 282  :     //  SRC
; 283  :     OUTREG32(&pDmaLcReg->CSDP, pConfigInfo->elemSize);
; 284  : 
; 285  :     // update CCR
; 286  :     //  DST_MODE
; 287  :     //  SRC_MODE
; 288  :     //  PRIO
; 289  :     //  SYNC
; 290  :     //
; 291  :     OUTREG32(&pDmaLcReg->CCR, pConfigInfo->srcAddrMode |
; 292  :         pConfigInfo->dstAddrMode | pConfigInfo->dmaPrio |
; 293  :         DMA_CCR_SYNC(syncMap) | pConfigInfo->synchTrigger |
; 294  :         pConfigInfo->synchMode
; 295  :         );

  00028	e201e060	 and         lr, r1, #0x60
  0002c	e3c33080	 bic         r3, r3, #0x80
  00030	e5843000	 str         r3, [r4]
  00034	e585102c	 str         r1, [r5, #0x2C]
  00038	e5842000	 str         r2, [r4]
  0003c	e5842004	 str         r2, [r4, #4]
  00040	e5842044	 str         r2, [r4, #0x44]
  00044	e5953000	 ldr         r3, [r5]

; 296  : 
; 297  :     // update CSEI
; 298  :     //
; 299  :     OUTREG32(&pDmaLcReg->CSEI, pConfigInfo->srcElemIndex);
; 300  : 
; 301  :     // update CDEI
; 302  :     //
; 303  :     OUTREG32(&pDmaLcReg->CDEI, pConfigInfo->dstElemIndex);
; 304  : 
; 305  :     // update CSFI
; 306  :     //
; 307  :     OUTREG32(&pDmaLcReg->CSFI, pConfigInfo->srcFrameIndex);
; 308  : 
; 309  :     // update CDFI
; 310  :     //
; 311  :     OUTREG32(&pDmaLcReg->CDFI, pConfigInfo->dstFrameIndex);
; 312  : 
; 313  :     // update CICR
; 314  :     //
; 315  :     OUTREG32(&pDmaLcReg->CICR , pConfigInfo->interrupts);
; 316  : 
; 317  :     rc = TRUE;

  00048	e3a00001	 mov         r0, #1
  0004c	e5843010	 str         r3, [r4, #0x10]
  00050	e5952024	 ldr         r2, [r5, #0x24]
  00054	e201301f	 and         r3, r1, #0x1F
  00058	e5951020	 ldr         r1, [r5, #0x20]
  0005c	e183370e	 orr         r3, r3, lr, lsl #14
  00060	e1833002	 orr         r3, r3, r2
  00064	e595201c	 ldr         r2, [r5, #0x1C]
  00068	e1833001	 orr         r3, r3, r1
  0006c	e5951018	 ldr         r1, [r5, #0x18]
  00070	e1833002	 orr         r3, r3, r2
  00074	e595200c	 ldr         r2, [r5, #0xC]
  00078	e1833001	 orr         r3, r3, r1
  0007c	e1833002	 orr         r3, r3, r2
  00080	e5843000	 str         r3, [r4]
  00084	e5953004	 ldr         r3, [r5, #4]
  00088	e5843024	 str         r3, [r4, #0x24]
  0008c	e5953010	 ldr         r3, [r5, #0x10]
  00090	e584302c	 str         r3, [r4, #0x2C]
  00094	e5953008	 ldr         r3, [r5, #8]
  00098	e5843028	 str         r3, [r4, #0x28]
  0009c	e5953014	 ldr         r3, [r5, #0x14]
  000a0	e5843030	 str         r3, [r4, #0x30]
  000a4	e5953028	 ldr         r3, [r5, #0x28]
  000a8	e5843008	 str         r3, [r4, #8]
  000ac		 |$cleanUp$36007|

; 318  : 
; 319  : cleanUp:
; 320  :     return rc;
; 321  : }

  000ac	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000b0	e12fff1e	 bx          lr
  000b4		 |$M37024|

			 ENDP  ; |DmaUpdate|

	EXPORT	|DmaSetDstBuffer|

  00000			 AREA	 |.pdata|, PDATA
|$T37036| DCD	|$LN6@DmaSetDstB|
	DCD	0x40000800
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaSetDstBuffer| PROC

; 336  : {

  00000		 |$LN6@DmaSetDstB|
  00000		 |$M37033|

; 337  :     // save values
; 338  :     //
; 339  :     pDataInfo->pDstBuffer = pBuffer;
; 340  :     pDataInfo->PhysAddrDstBuffer = PhysAddr;
; 341  : 
; 342  :     // set destination address
; 343  :     //
; 344  :     if (pDataInfo->pDmaLcReg != NULL)

  00000	e5903014	 ldr         r3, [r0, #0x14]
  00004	e5801004	 str         r1, [r0, #4]
  00008	e580200c	 str         r2, [r0, #0xC]
  0000c	e3530000	 cmp         r3, #0

; 345  :         {
; 346  :         OUTREG32(&pDataInfo->pDmaLcReg->CDSA, PhysAddr);

  00010	15832020	 strne       r2, [r3, #0x20]

; 347  :         OUTREG32(&pDataInfo->pDmaLcReg->CDAC, PhysAddr);

  00014	15903014	 ldrne       r3, [r0, #0x14]
  00018	15832038	 strne       r2, [r3, #0x38]

; 348  :         }
; 349  : }

  0001c	e12fff1e	 bx          lr
  00020		 |$M37034|

			 ENDP  ; |DmaSetDstBuffer|

	EXPORT	|DmaSetSrcBuffer|

  00000			 AREA	 |.pdata|, PDATA
|$T37046| DCD	|$LN6@DmaSetSrcB|
	DCD	0x40000800
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaSetSrcBuffer| PROC

; 364  : {

  00000		 |$LN6@DmaSetSrcB|
  00000		 |$M37043|

; 365  :     // save values
; 366  :     //
; 367  :     pDataInfo->pSrcBuffer = pBuffer;
; 368  :     pDataInfo->PhysAddrSrcBuffer = PhysAddr;
; 369  : 
; 370  :     // set source address
; 371  :     //
; 372  :     if (pDataInfo->pDmaLcReg != NULL)

  00000	e5903014	 ldr         r3, [r0, #0x14]
  00004	e5801000	 str         r1, [r0]
  00008	e5802008	 str         r2, [r0, #8]
  0000c	e3530000	 cmp         r3, #0

; 373  :         {
; 374  :         OUTREG32(&pDataInfo->pDmaLcReg->CSSA, PhysAddr);

  00010	1583201c	 strne       r2, [r3, #0x1C]

; 375  :         OUTREG32(&pDataInfo->pDmaLcReg->CSAC, PhysAddr);

  00014	15903014	 ldrne       r3, [r0, #0x14]
  00018	15832034	 strne       r2, [r3, #0x34]

; 376  :         }
; 377  : }

  0001c	e12fff1e	 bx          lr
  00020		 |$M37044|

			 ENDP  ; |DmaSetSrcBuffer|

	EXPORT	|DmaSetElementAndFrameCount|

  00000			 AREA	 |.pdata|, PDATA
|$T37056| DCD	|$LN5@DmaSetElem|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaSetElementAndFrameCount| PROC

; 392  : {

  00000		 |$LN5@DmaSetElem|
  00000		 |$M37053|

; 393  :     // setup frame and element count for destination side
; 394  :     //
; 395  :     OUTREG32(&pDataInfo->pDmaLcReg->CEN , countElements);

  00000	e5903014	 ldr         r3, [r0, #0x14]
  00004	e5831014	 str         r1, [r3, #0x14]

; 396  :     OUTREG32(&pDataInfo->pDmaLcReg->CFN , countFrames);

  00008	e5903014	 ldr         r3, [r0, #0x14]
  0000c	e5832018	 str         r2, [r3, #0x18]

; 397  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M37054|

			 ENDP  ; |DmaSetElementAndFrameCount|

	EXPORT	|DmaStop|
	IMPORT	|DmaDisableStandby|

  00000			 AREA	 |.pdata|, PDATA
|$T37067| DCD	|$LN12@DmaStop|
	DCD	0x40001b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaStop| PROC

; 452  : {

  00000		 |$LN12@DmaStop|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M37064|
  00008	e1a05000	 mov         r5, r0

; 453  :     volatile ULONG ulCCR;
; 454  :     BOOL breakLoop = FALSE;
; 455  : 
; 456  :     // disable standby in dma controller
; 457  :     //
; 458  :     DmaDisableStandby(pDataInfo->hDmaChannel, TRUE);

  0000c	e5950010	 ldr         r0, [r5, #0x10]
  00010	e3a01001	 mov         r1, #1
  00014	e3a04000	 mov         r4, #0
  00018	eb000000	 bl          DmaDisableStandby

; 459  : 
; 460  :     // setup frame and element count for destination side
; 461  :     //
; 462  :     CLRREG32(&pDataInfo->pDmaLcReg->CCR , DMA_CCR_ENABLE);

  0001c	e5952014	 ldr         r2, [r5, #0x14]
  00020	e5923000	 ldr         r3, [r2]
  00024	e3c33080	 bic         r3, r3, #0x80
  00028	e5823000	 str         r3, [r2]
  0002c	e5952014	 ldr         r2, [r5, #0x14]
  00030		 |$LL5@DmaStop|

; 463  : 
; 464  :     // ensure DMA transfer is completed by polling the active bits
; 465  :     //
; 466  :     while (breakLoop == FALSE)
; 467  :         {
; 468  :         ulCCR = INREG32(&pDataInfo->pDmaLcReg->CCR);

  00030	e5923000	 ldr         r3, [r2]
  00034	e58d3000	 str         r3, [sp]

; 469  :         if ((ulCCR & DMA_CCR_WR_ACTIVE) || (ulCCR & DMA_CCR_RD_ACTIVE))

  00038	e59d3000	 ldr         r3, [sp]
  0003c	e3130b01	 tst         r3, #1, 22
  00040	059d3000	 ldreq       r3, [sp]
  00044	03130c02	 tsteq       r3, #2, 24

; 470  :             {
; 471  :             // fix this infinite loop
; 472  :             //
; 473  :             continue;
; 474  :             }
; 475  :         else
; 476  :             {
; 477  :             breakLoop = TRUE;

  00048	03a04001	 moveq       r4, #1
  0004c	e3540000	 cmp         r4, #0
  00050	0afffff6	 beq         |$LL5@DmaStop|

; 478  :             }
; 479  :         }
; 480  : 
; 481  :     // re-enable standby in dma controller
; 482  :     //
; 483  :     DmaDisableStandby(pDataInfo->hDmaChannel, FALSE);

  00054	e5950010	 ldr         r0, [r5, #0x10]
  00058	e3a01000	 mov         r1, #0
  0005c	eb000000	 bl          DmaDisableStandby

; 484  : 
; 485  : }

  00060	e28dd004	 add         sp, sp, #4
  00064	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00068	e12fff1e	 bx          lr
  0006c		 |$M37065|

			 ENDP  ; |DmaStop|

	EXPORT	|DmaStart|

  00000			 AREA	 |.pdata|, PDATA
|$T37075| DCD	|$LN5@DmaStart|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaStart| PROC

; 498  : {

  00000		 |$LN5@DmaStart|
  00000		 |$M37072|

; 499  :     // setup frame and element count for destination side
; 500  :     //
; 501  :     SETREG32(&pDataInfo->pDmaLcReg->CCR , DMA_CCR_ENABLE);

  00000	e5902014	 ldr         r2, [r0, #0x14]
  00004	e5923000	 ldr         r3, [r2]
  00008	e3833080	 orr         r3, r3, #0x80
  0000c	e5823000	 str         r3, [r2]

; 502  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M37073|

			 ENDP  ; |DmaStart|

	EXPORT	|DmaGetLastWritePos|

  00000			 AREA	 |.pdata|, PDATA
|$T37086| DCD	|$LN5@DmaGetLast|
	DCD	0x40000700
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaGetLastWritePos| PROC

; 515  : {

  00000		 |$LN5@DmaGetLast|
  00000		 |$M37083|

; 516  :     UINT32  offset;
; 517  :     offset = INREG32(&pDataInfo->pDmaLcReg->CDAC) - pDataInfo->PhysAddrDstBuffer;

  00000	e5903014	 ldr         r3, [r0, #0x14]
  00004	e590200c	 ldr         r2, [r0, #0xC]

; 518  :     return ((UINT8*)pDataInfo->pDstBuffer + offset);

  00008	e5901004	 ldr         r1, [r0, #4]
  0000c	e5933038	 ldr         r3, [r3, #0x38]
  00010	e0433002	 sub         r3, r3, r2
  00014	e0810003	 add         r0, r1, r3

; 519  : }

  00018	e12fff1e	 bx          lr
  0001c		 |$M37084|

			 ENDP  ; |DmaGetLastWritePos|

	EXPORT	|DmaGetLastReadPos|

  00000			 AREA	 |.pdata|, PDATA
|$T37097| DCD	|$LN5@DmaGetLast@2|
	DCD	0x40000700
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaGetLastReadPos| PROC

; 532  : {

  00000		 |$LN5@DmaGetLast@2|
  00000		 |$M37094|

; 533  :     UINT32  offset;
; 534  :     offset = INREG32(&pDataInfo->pDmaLcReg->CSAC) - pDataInfo->PhysAddrSrcBuffer;

  00000	e5903014	 ldr         r3, [r0, #0x14]
  00004	e5902008	 ldr         r2, [r0, #8]

; 535  :     return ((UINT8*)pDataInfo->pSrcBuffer + offset);

  00008	e5901000	 ldr         r1, [r0]
  0000c	e5933034	 ldr         r3, [r3, #0x34]
  00010	e0433002	 sub         r3, r3, r2
  00014	e0810003	 add         r0, r1, r3

; 536  : }

  00018	e12fff1e	 bx          lr
  0001c		 |$M37095|

			 ENDP  ; |DmaGetLastReadPos|

	EXPORT	|DmaSetRepeatMode|
	IMPORT	|DmaGetLogicalChannelId|

  00000			 AREA	 |.pdata|, PDATA
|$T37111| DCD	|$LN8@DmaSetRepe|
	DCD	0x40001201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaSetRepeatMode| PROC

; 549  : {

  00000		 |$LN8@DmaSetRepe|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37108|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 550  :     DWORD dwMode = DmaGetLogicalChannelId(pDataInfo->hDmaChannel);

  0000c	e5950010	 ldr         r0, [r5, #0x10]
  00010	eb000000	 bl          DmaGetLogicalChannelId

; 551  :     if (dwMode == -1) return FALSE;

  00014	e3700001	 cmn         r0, #1
  00018	03a00000	 moveq       r0, #0

; 556  : }

  0001c	08bd4030	 ldmeqia     sp!, {r4, r5, lr}
  00020	012fff1e	 bxeq        lr

; 552  : 
; 553  :     dwMode |= (bEnable == TRUE) ? DMA_CLNK_CTRL_ENABLE_LINK : 0;

  00024	e3540001	 cmp         r4, #1
  00028	03a03902	 moveq       r3, #2, 18
  0002c	13a03000	 movne       r3, #0

; 554  :     OUTREG32(&pDataInfo->pDmaLcReg->CLNK_CTRL, dwMode);

  00030	e5952014	 ldr         r2, [r5, #0x14]
  00034	e1833000	 orr         r3, r3, r0

; 555  :     return TRUE;

  00038	e3a00001	 mov         r0, #1
  0003c	e5823004	 str         r3, [r2, #4]

; 556  : }

  00040	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$M37109|

			 ENDP  ; |DmaSetRepeatMode|

	EXPORT	|?GetSamplesPerPage@DataPort_t@@QBAHXZ|	; DataPort_t::GetSamplesPerPage
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\mcbsp\dataport.h

  00000			 AREA	 |.pdata|, PDATA
|$T37121| DCD	|$LN5@GetSamples|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetSamplesPerPage@DataPort_t@@QBAHXZ| PROC ; DataPort_t::GetSamplesPerPage

; 89   :     {

  00000		 |$LN5@GetSamples|
  00000		 |$M37118|

; 90   :         return m_SamplesPerPage;

  00000	e5900050	 ldr         r0, [r0, #0x50]

; 91   :     }

  00004	e12fff1e	 bx          lr
  00008		 |$M37119|

			 ENDP  ; |?GetSamplesPerPage@DataPort_t@@QBAHXZ|, DataPort_t::GetSamplesPerPage

	EXPORT	|??0DataPort_t@@QAA@PAUMcBSPDevice_t@@@Z| ; DataPort_t::DataPort_t
	EXPORT	|??_7DataPort_t@@6B@| [ DATA ]		; DataPort_t::`vftable'
	EXPORT	|?GetDataBufferSize@DataPort_t@@UBAHXZ|	; DataPort_t::GetDataBufferSize
	EXPORT	|?ResetDataBuffer@DataPort_t@@UAAXXZ|	; DataPort_t::ResetDataBuffer
	EXPORT	|?UpdateSamplesPerPage@DataPort_t@@UAAXKK@Z| ; DataPort_t::UpdateSamplesPerPage
	EXPORT	|?StopDma@DataPort_t@@UAAHXZ|		; DataPort_t::StopDma
	EXPORT	|?StartDma@DataPort_t@@UAAHH@Z|		; DataPort_t::StartDma
	EXPORT	|?Initialize@DataPort_t@@UAAHPAUDmaConfigInfo_t@@KGP6AKPAX@Z@Z| ; DataPort_t::Initialize
	EXPORT	|?RestoreDMAcontext@DataPort_t@@UAAHPAUDmaConfigInfo_t@@KG@Z| ; DataPort_t::RestoreDMAcontext
	EXPORT	|?GetDataBuffer@DataPort_t@@UAAPAEW4BufferRequest_e@1@@Z| ; DataPort_t::GetDataBuffer
	EXPORT	|?SwapBuffer@DataPort_t@@UAAXH@Z|	; DataPort_t::SwapBuffer
	EXPORT	|?PreprocessDataForRender@DataPort_t@@UAAXW4BufferRequest_e@1@I@Z| ; DataPort_t::PreprocessDataForRender
	EXPORT	|?PostprocessDataForCapture@DataPort_t@@UAAXW4BufferRequest_e@1@I@Z| ; DataPort_t::PostprocessDataForCapture
	IMPORT	|InitializeCriticalSection|
	IMPORT	|??_EDataPort_t@@UAAPAXI@Z|, WEAK |??_GDataPort_t@@UAAPAXI@Z| ; DataPort_t::`vector deleting destructor', DataPort_t::`scalar deleting destructor'
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\mcbsp\dataport.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T37132| DCD	|$LN5@DataPort_t|
	DCD	0x40001a01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7DataPort_t@@6B@| DCD |??_EDataPort_t@@UAAPAXI@Z|	; DataPort_t::`vftable'
	DCD	|?GetDataBufferSize@DataPort_t@@UBAHXZ|
	DCD	|?ResetDataBuffer@DataPort_t@@UAAXXZ|
	DCD	|?UpdateSamplesPerPage@DataPort_t@@UAAXKK@Z|
	DCD	|?StopDma@DataPort_t@@UAAHXZ|
	DCD	|?StartDma@DataPort_t@@UAAHH@Z|
	DCD	|?Initialize@DataPort_t@@UAAHPAUDmaConfigInfo_t@@KGP6AKPAX@Z@Z|
	DCD	|?RestoreDMAcontext@DataPort_t@@UAAHPAUDmaConfigInfo_t@@KG@Z|
	DCD	|?GetDataBuffer@DataPort_t@@UAAPAEW4BufferRequest_e@1@@Z|
	DCD	|?SwapBuffer@DataPort_t@@UAAXH@Z|
	DCD	|?PreprocessDataForRender@DataPort_t@@UAAXW4BufferRequest_e@1@I@Z|
	DCD	|?PostprocessDataForCapture@DataPort_t@@UAAXW4BufferRequest_e@1@I@Z|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0DataPort_t@@QAA@PAUMcBSPDevice_t@@@Z| PROC ; DataPort_t::DataPort_t

; 40   : {

  00000		 |$LN5@DataPort_t|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37129|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	e59f3050	 ldr         r3, [pc, #0x50]

; 41   :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:+%S\r\n", __FUNCTION__));
; 42   : 
; 43   :     memset(&m_DmaInfo, 0, sizeof(DmaDataInfo_t));

  00010	e3a02018	 mov         r2, #0x18
  00014	e3a01000	 mov         r1, #0
  00018	e4803004	 str         r3, [r0], #4
  0001c	eb000000	 bl          memset

; 44   : 
; 45   :     m_pDevice           = pDevice;
; 46   :     m_DmaLoopCounter    = 0;

  00020	e3a03000	 mov         r3, #0

; 47   :     m_PortState         = kMCBSP_Port_Uninitialized;
; 48   :     m_DmaPhysAddr       = 0;
; 49   :     m_pActiveDmaBuffer  = NULL;
; 50   :     m_pDmaBufferStart   = NULL;
; 51   :     m_pDmaBufferMiddle  = NULL;
; 52   :     m_SamplesPerPage    = 0;
; 53   :     m_pActiveInstance   = NULL;
; 54   :     m_hEvent            = NULL;
; 55   :     m_hDmaChannel       = NULL;
; 56   : 
; 57   :     InitializeCriticalSection(&m_cs);

  00024	e2850028	 add         r0, r5, #0x28
  00028	e5853020	 str         r3, [r5, #0x20]
  0002c	e5853024	 str         r3, [r5, #0x24]
  00030	e585303c	 str         r3, [r5, #0x3C]
  00034	e5853040	 str         r3, [r5, #0x40]
  00038	e5853044	 str         r3, [r5, #0x44]
  0003c	e5853048	 str         r3, [r5, #0x48]
  00040	e5853050	 str         r3, [r5, #0x50]
  00044	e5853054	 str         r3, [r5, #0x54]
  00048	e5853058	 str         r3, [r5, #0x58]
  0004c	e585305c	 str         r3, [r5, #0x5C]
  00050	e585401c	 str         r4, [r5, #0x1C]
  00054	eb000000	 bl          InitializeCriticalSection

; 58   : 
; 59   :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:-%S\r\n", __FUNCTION__));
; 60   : }

  00058	e1a00005	 mov         r0, r5
  0005c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$LN6@DataPort_t|
  00064		 |$LN7@DataPort_t|
  00064	00000000	 DCD         |??_7DataPort_t@@6B@|
  00068		 |$M37130|

			 ENDP  ; |??0DataPort_t@@QAA@PAUMcBSPDevice_t@@@Z|, DataPort_t::DataPort_t

; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\mcbsp\dataport.h

  00000			 AREA	 |.pdata|, PDATA
|$T37144| DCD	|$LN5@GetDataBuf|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetDataBufferSize@DataPort_t@@UBAHXZ| PROC ; DataPort_t::GetDataBufferSize

; 112  :     {

  00000		 |$LN5@GetDataBuf|
  00000		 |$M37141|

; 113  :         return m_sizeDmaBuffer;

  00000	e590004c	 ldr         r0, [r0, #0x4C]

; 114  :     }

  00004	e12fff1e	 bx          lr
  00008		 |$M37142|

			 ENDP  ; |?GetDataBufferSize@DataPort_t@@UBAHXZ|, DataPort_t::GetDataBufferSize


  00000			 AREA	 |.pdata|, PDATA
|$T37152| DCD	|$LN5@ResetDataB|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResetDataBuffer@DataPort_t@@UAAXXZ| PROC ; DataPort_t::ResetDataBuffer

; 117  :     {

  00000		 |$LN5@ResetDataB|
  00000		 |$M37149|

; 118  :         m_pActiveDmaBuffer = m_pDmaBufferStart;

  00000	e5903044	 ldr         r3, [r0, #0x44]
  00004	e5803040	 str         r3, [r0, #0x40]

; 119  :     }

  00008	e12fff1e	 bx          lr
  0000c		 |$M37150|

			 ENDP  ; |?ResetDataBuffer@DataPort_t@@UAAXXZ|, DataPort_t::ResetDataBuffer


  00000			 AREA	 |.pdata|, PDATA
|$T37163| DCD	|$LN11@UpdateSamp|
	DCD	0x40000c00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdateSamplesPerPage@DataPort_t@@UAAXKK@Z| PROC ; DataPort_t::UpdateSamplesPerPage

; 137  :     {

  00000		 |$LN11@UpdateSamp|
  00000		 |$M37160|

; 138  :         if (datatype == DMA_CSDP_DATATYPE_S32)

  00000	e3520002	 cmp         r2, #2

; 139  :             {
; 140  :             m_SamplesPerPage = (nDmaBufferSize >> 1) / sizeof(DWORD);

  00004	01a031a1	 moveq       r3, r1, lsr #3

; 147  :             {
; 148  :             m_SamplesPerPage = nDmaBufferSize / sizeof(WORD);

  00008	05803050	 streq       r3, [r0, #0x50]

; 149  :             }
; 150  :     }

  0000c	012fff1e	 bxeq        lr

; 141  :             }
; 142  :         else if (datatype == DMA_CSDP_DATATYPE_S16)

  00010	e3520001	 cmp         r2, #1

; 143  :             {
; 144  :             m_SamplesPerPage = (nDmaBufferSize >> 1) / sizeof(WORD);

  00014	01a03121	 moveq       r3, r1, lsr #2

; 147  :             {
; 148  :             m_SamplesPerPage = nDmaBufferSize / sizeof(WORD);

  00018	05803050	 streq       r3, [r0, #0x50]

; 149  :             }
; 150  :     }

  0001c	012fff1e	 bxeq        lr

; 145  :             }
; 146  :         else if (datatype == DMA_CSDP_DATATYPE_S8)

  00020	e3520000	 cmp         r2, #0

; 147  :             {
; 148  :             m_SamplesPerPage = nDmaBufferSize / sizeof(WORD);

  00024	01a030a1	 moveq       r3, r1, lsr #1
  00028	05803050	 streq       r3, [r0, #0x50]

; 149  :             }
; 150  :     }

  0002c	e12fff1e	 bx          lr
  00030		 |$M37161|

			 ENDP  ; |?UpdateSamplesPerPage@DataPort_t@@UAAXKK@Z|, DataPort_t::UpdateSamplesPerPage


  00000			 AREA	 |.pdata|, PDATA
|$T37170| DCD	|$LN5@Preprocess|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PreprocessDataForRender@DataPort_t@@UAAXW4BufferRequest_e@1@I@Z| PROC ; DataPort_t::PreprocessDataForRender

; 174  :     virtual void PreprocessDataForRender(BufferRequest_e type, UINT count)  { UNREFERENCED_PARAMETER(type); UNREFERENCED_PARAMETER(count); };

  00000		 |$LN5@Preprocess|
  00000		 |$M37167|
  00000	e12fff1e	 bx          lr
  00004		 |$M37168|

			 ENDP  ; |?PreprocessDataForRender@DataPort_t@@UAAXW4BufferRequest_e@1@I@Z|, DataPort_t::PreprocessDataForRender


  00000			 AREA	 |.pdata|, PDATA
|$T37177| DCD	|$LN5@Postproces|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PostprocessDataForCapture@DataPort_t@@UAAXW4BufferRequest_e@1@I@Z| PROC ; DataPort_t::PostprocessDataForCapture

; 175  :     virtual void PostprocessDataForCapture(BufferRequest_e type, UINT count){ UNREFERENCED_PARAMETER(type); UNREFERENCED_PARAMETER(count); };

  00000		 |$LN5@Postproces|
  00000		 |$M37174|
  00000	e12fff1e	 bx          lr
  00004		 |$M37175|

			 ENDP  ; |?PostprocessDataForCapture@DataPort_t@@UAAXW4BufferRequest_e@1@I@Z|, DataPort_t::PostprocessDataForCapture

	EXPORT	|??1DataPort_t@@UAA@XZ|			; DataPort_t::~DataPort_t
	IMPORT	|CloseHandle|
	IMPORT	|FreePhysMem|
	IMPORT	|DeleteCriticalSection|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\mcbsp\dataport.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T37185| DCD	|$LN7@DataPort_t@2|
	DCD	0x40001001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1DataPort_t@@UAA@XZ| PROC		; DataPort_t::~DataPort_t

; 69   : {

  00000		 |$LN7@DataPort_t@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37182|
  00004	e1a04000	 mov         r4, r0
  00008	e59f302c	 ldr         r3, [pc, #0x2C]

; 70   :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:+%S\r\n", __FUNCTION__));
; 71   : 
; 72   :     // free allocated resources
; 73   :     //
; 74   :     DeleteCriticalSection(&m_cs);

  0000c	e4803028	 str         r3, [r0], #0x28
  00010	eb000000	 bl          DeleteCriticalSection

; 75   : 
; 76   :     if (m_pDmaBufferStart)

  00014	e5943044	 ldr         r3, [r4, #0x44]
  00018	e3530000	 cmp         r3, #0

; 77   :         {
; 78   :         FreePhysMem(m_pDmaBufferStart);

  0001c	11a00003	 movne       r0, r3
  00020	1b000000	 blne        FreePhysMem

; 79   :         }
; 80   : 
; 81   :      if (m_hEvent)

  00024	e5943058	 ldr         r3, [r4, #0x58]
  00028	e3530000	 cmp         r3, #0

; 82   :         {
; 83   :         CloseHandle(m_hEvent);

  0002c	11a00003	 movne       r0, r3
  00030	1b000000	 blne        CloseHandle

; 84   :         }
; 85   : 
; 86   :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:-%S\r\n", __FUNCTION__));
; 87   : }

  00034	e8bd4010	 ldmia       sp!, {r4, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$LN8@DataPort_t@2|
  0003c		 |$LN9@DataPort_t@2|
  0003c	00000000	 DCD         |??_7DataPort_t@@6B@|
  00040		 |$M37183|

			 ENDP  ; |??1DataPort_t@@UAA@XZ|, DataPort_t::~DataPort_t


  00000			 AREA	 |.pdata|, PDATA
|$T37203| DCD	|$LN16@GetDataBuf@2|
	DCD	0x40001800
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetDataBuffer@DataPort_t@@UAAPAEW4BufferRequest_e@1@@Z| PROC ; DataPort_t::GetDataBuffer

; 99   : {

  00000		 |$LN16@GetDataBuf@2|
  00000		 |$M37200|
  00000	e3510000	 cmp         r1, #0
  00004	e1a02000	 mov         r2, r0

; 100  :     BYTE* pBuffer;
; 101  : 
; 102  :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:+%S(type=%d)\r\n", __FUNCTION__, type));
; 103  : 
; 104  :     switch (type)

  00008	0a000012	 beq         |$LN5@GetDataBuf@2|
  0000c	e3510001	 cmp         r1, #1
  00010	0a00000e	 beq         |$LN4@GetDataBuf@2|
  00014	e3510002	 cmp         r1, #2
  00018	0a000008	 beq         |$LN3@GetDataBuf@2|
  0001c	e3510003	 cmp         r1, #3

; 122  :             break;
; 123  : 
; 124  :         default:
; 125  :             ASSERT(0);
; 126  :             return NULL;

  00020	13a00000	 movne       r0, #0

; 127  :             break;
; 128  :         }
; 129  : 
; 130  :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:+%S(pBuffer=%d)\r\n", __FUNCTION__,
; 131  :         pBuffer)
; 132  :         );
; 133  :     return pBuffer;
; 134  : }

  00024	112fff1e	 bxne        lr

; 117  :             break;
; 118  : 
; 119  :         case kBufferInactive:
; 120  :             pBuffer = (m_pActiveDmaBuffer == m_pDmaBufferStart) ?
; 121  :                         m_pDmaBufferMiddle : m_pDmaBufferStart;

  00028	e5920044	 ldr         r0, [r2, #0x44]
  0002c	e5923040	 ldr         r3, [r2, #0x40]
  00030	e1530000	 cmp         r3, r0
  00034	1a000008	 bne         |$LN6@GetDataBuf@2|

; 108  :             break;
; 109  : 
; 110  :         case kBufferMiddle:
; 111  :             pBuffer = m_pDmaBufferMiddle;

  00038	e5920048	 ldr         r0, [r2, #0x48]

; 127  :             break;
; 128  :         }
; 129  : 
; 130  :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:+%S(pBuffer=%d)\r\n", __FUNCTION__,
; 131  :         pBuffer)
; 132  :         );
; 133  :     return pBuffer;
; 134  : }

  0003c	e12fff1e	 bx          lr
  00040		 |$LN3@GetDataBuf@2|

; 112  :             break;
; 113  : 
; 114  :         case kBufferActive:
; 115  :             pBuffer = (m_pActiveDmaBuffer == m_pDmaBufferStart) ?
; 116  :                         m_pDmaBufferStart : m_pDmaBufferMiddle;

  00040	e5920044	 ldr         r0, [r2, #0x44]
  00044	e5923040	 ldr         r3, [r2, #0x40]
  00048	e1530000	 cmp         r3, r0
  0004c	0a000002	 beq         |$LN6@GetDataBuf@2|
  00050		 |$LN4@GetDataBuf@2|

; 108  :             break;
; 109  : 
; 110  :         case kBufferMiddle:
; 111  :             pBuffer = m_pDmaBufferMiddle;

  00050	e5920048	 ldr         r0, [r2, #0x48]

; 127  :             break;
; 128  :         }
; 129  : 
; 130  :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:+%S(pBuffer=%d)\r\n", __FUNCTION__,
; 131  :         pBuffer)
; 132  :         );
; 133  :     return pBuffer;
; 134  : }

  00054	e12fff1e	 bx          lr
  00058		 |$LN5@GetDataBuf@2|

; 105  :         {
; 106  :         case kBufferStart:
; 107  :             pBuffer = m_pDmaBufferStart;

  00058	e5920044	 ldr         r0, [r2, #0x44]
  0005c		 |$LN6@GetDataBuf@2|

; 127  :             break;
; 128  :         }
; 129  : 
; 130  :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:+%S(pBuffer=%d)\r\n", __FUNCTION__,
; 131  :         pBuffer)
; 132  :         );
; 133  :     return pBuffer;
; 134  : }

  0005c	e12fff1e	 bx          lr
  00060		 |$M37201|

			 ENDP  ; |?GetDataBuffer@DataPort_t@@UAAPAEW4BufferRequest_e@1@@Z|, DataPort_t::GetDataBuffer

	IMPORT	|CreateThread|
	IMPORT	|DmaEnableInterrupts|
	IMPORT	|DmaAllocateChannel|
	IMPORT	|CreateEventW|
	IMPORT	|AllocPhysMem|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\mcbsp\dma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T37240| DCD	|$LN49@Initialize|
	DCD	0x40008202
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\mcbsp\dataport.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Initialize@DataPort_t@@UAAHPAUDmaConfigInfo_t@@KGP6AKPAX@Z@Z| PROC ; DataPort_t::Initialize

; 148  : {

  00000		 |$LN49@Initialize|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M37237|
  00008	e1a07002	 mov         r7, r2
  0000c	e1a04001	 mov         r4, r1
  00010	e1a05000	 mov         r5, r0

; 149  :     BOOL bResult = FALSE;

  00014	e3a08000	 mov         r8, #0

; 150  : 
; 151  :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:+%S\r\n", __FUNCTION__));
; 152  : 
; 153  :     // verify mcbsp dma mapping
; 154  :     //
; 155  :     if (dmaSyncMap == NULL)

  00018	e1b06003	 movs        r6, r3
  0001c	0a000075	 beq         |$cleanUp$36773|

; 156  :         {
; 157  :         DEBUGMSG(ZONE_ERROR, (L"MCP: ERROR: DataPort_t::Initialize: "
; 158  :             L"mcbsp dma mapping not specified\r\n")
; 159  :             );
; 160  :         goto cleanUp;
; 161  :         }
; 162  : 
; 163  :     // TDM mode is sets DMA element size of 16bits.
; 164  :     // I2S mode supports  DMA element size from 8 bits to 32 bits
; 165  :     //
; 166  :     if ((m_pDevice->mcbspProfile == kMcBSPProfile_I2S_Slave) ||
; 167  :         (m_pDevice->mcbspProfile == kMcBSPProfile_I2S_Master))

  00020	e595101c	 ldr         r1, [r5, #0x1C]
  00024	e3a0b002	 mov         r11, #2
  00028	e3a0a000	 mov         r10, #0
  0002c	e591308c	 ldr         r3, [r1, #0x8C]
  00030	e3a09001	 mov         r9, #1
  00034	e3530000	 cmp         r3, #0
  00038	0a000005	 beq         |$LN30@Initialize|
  0003c	e3530001	 cmp         r3, #1
  00040	0a000003	 beq         |$LN30@Initialize|

; 185  :             }
; 186  :         }
; 187  :     else if (m_pDevice->mcbspProfile == kMcBSPProfile_TDM)

  00044	e3530002	 cmp         r3, #2
  00048	1a000008	 bne         |$LN26@Initialize|

; 177  :             {
; 178  :             //  16 bit data type
; 179  :             pDmaConfigInfo->elemSize = DMA_CSDP_DATATYPE_S16;

  0004c	e5849000	 str         r9, [r4]

; 180  :             }
; 181  :         else

  00050	ea000006	 b           |$LN26@Initialize|
  00054		 |$LN30@Initialize|

; 168  :         {
; 169  :         // Determine DMA datatype
; 170  :         //
; 171  :         if (m_pDevice->wordLength > 16)

  00054	e59130cc	 ldr         r3, [r1, #0xCC]
  00058	e3530010	 cmp         r3, #0x10

; 172  :             {
; 173  :             //  32 bit data type
; 174  :             pDmaConfigInfo->elemSize = DMA_CSDP_DATATYPE_S32;

  0005c	8584b000	 strhi       r11, [r4]
  00060	8a000002	 bhi         |$LN26@Initialize|

; 175  :             }
; 176  :         else if (m_pDevice->wordLength > 8)

  00064	e3530008	 cmp         r3, #8

; 177  :             {
; 178  :             //  16 bit data type
; 179  :             pDmaConfigInfo->elemSize = DMA_CSDP_DATATYPE_S16;

  00068	85849000	 strhi       r9, [r4]

; 182  :             {
; 183  :             //  8 bit data type
; 184  :             pDmaConfigInfo->elemSize = DMA_CSDP_DATATYPE_S8;

  0006c	9584a000	 strls       r10, [r4]
  00070		 |$LN26@Initialize|

; 188  :         {
; 189  :         //  16 bit data type
; 190  :         pDmaConfigInfo->elemSize = DMA_CSDP_DATATYPE_S16;
; 191  :         }
; 192  : 
; 193  :     // allocate contiguous physical memory to be used with DMA
; 194  :     //
; 195  :     PHYSICAL_ADDRESS pa;
; 196  :     pa.LowPart = 0;

  00070	e3a02000	 mov         r2, #0

; 197  :     m_pDmaBufferStart = (BYTE*)AllocPhysMem(nBufferSize,
; 198  :         PAGE_READWRITE | PAGE_NOCACHE, 0, 0, &pa.LowPart
; 199  :         );

  00074	e28d3008	 add         r3, sp, #8
  00078	e58d2008	 str         r2, [sp, #8]
  0007c	e58d3000	 str         r3, [sp]
  00080	e3a03000	 mov         r3, #0
  00084	e3a02000	 mov         r2, #0
  00088	e3a01f81	 mov         r1, #0x81, 30
  0008c	e1a00007	 mov         r0, r7
  00090	eb000000	 bl          AllocPhysMem
  00094	e3500000	 cmp         r0, #0
  00098	e5850044	 str         r0, [r5, #0x44]

; 200  :     if (m_pDmaBufferStart == NULL)

  0009c	0a000055	 beq         |$cleanUp$36773|

; 201  :         {
; 202  :         DEBUGMSG(ZONE_ERROR, (L"MCP: ERROR: DataPort_t::Initialize: "
; 203  :             L"Failed allocate dma buffer (size %u)\r\n", nBufferSize)
; 204  :             );
; 205  :         goto cleanUp;
; 206  :         }
; 207  : 
; 208  :     m_DmaPhysAddr = pa.LowPart;

  000a0	e59d2008	 ldr         r2, [sp, #8]

; 209  :     m_pDmaBufferMiddle = (BYTE*)((DWORD)m_pDmaBufferStart + (nBufferSize / 2));
; 210  :     m_sizeDmaBuffer = nBufferSize;
; 211  : 
; 212  :     UpdateSamplesPerPage(nBufferSize, pDmaConfigInfo->elemSize);

  000a4	e5951000	 ldr         r1, [r5]
  000a8	e08030a7	 add         r3, r0, r7, lsr #1
  000ac	e5853048	 str         r3, [r5, #0x48]
  000b0	e591300c	 ldr         r3, [r1, #0xC]
  000b4	e585203c	 str         r2, [r5, #0x3C]
  000b8	e585704c	 str         r7, [r5, #0x4C]
  000bc	e5942000	 ldr         r2, [r4]
  000c0	e1a01007	 mov         r1, r7
  000c4	e1a00005	 mov         r0, r5
  000c8	e1a0e00f	 mov         lr, pc
  000cc	e12fff13	 bx          r3

; 213  : 
; 214  :     // Packet burst mode for I2S mode only
; 215  :     //
; 216  :     if ((m_pDevice->mcbspProfile == kMcBSPProfile_I2S_Slave) ||
; 217  :         (m_pDevice->mcbspProfile == kMcBSPProfile_I2S_Master))

  000d0	e595201c	 ldr         r2, [r5, #0x1C]
  000d4	e592308c	 ldr         r3, [r2, #0x8C]
  000d8	e3530000	 cmp         r3, #0
  000dc	0a000003	 beq         |$LN20@Initialize|
  000e0	e3530001	 cmp         r3, #1
  000e4	0a000001	 beq         |$LN20@Initialize|

; 234  :             }
; 235  :         }
; 236  :     else if (m_pDevice->mcbspProfile == kMcBSPProfile_TDM)

  000e8	e3530002	 cmp         r3, #2
  000ec	1a00000a	 bne         |$LN17@Initialize|
  000f0		 |$LN20@Initialize|

; 237  :         {
; 238  :         // TX and RX CSDP settings for MCBSP FIFO packet burst
; 239  :         //
; 240  :         if (dmaSyncMap == m_pDevice->dmaTxSyncMap)

  000f0	e59230a8	 ldr         r3, [r2, #0xA8]
  000f4	e1560003	 cmp         r6, r3

; 241  :             {
; 242  :             // To make sure the TX CSDP configurations
; 243  :             //
; 244  :             pDmaConfigInfo->elemSize |= DMA_CSDP_DST_PACKED |
; 245  :                 DMA_CSDP_DST_BURST_64BYTES_16x32_8x64;

  000f8	05943000	 ldreq       r3, [r4]
  000fc	03833a0e	 orreq       r3, r3, #0xE, 20
  00100	0a000004	 beq         |$LN46@Initialize|
  00104	e59230ac	 ldr         r3, [r2, #0xAC]
  00108	e1560003	 cmp         r6, r3
  0010c	1a000002	 bne         |$LN17@Initialize|
  00110	e5943000	 ldr         r3, [r4]
  00114	e3833d07	 orr         r3, r3, #7, 26
  00118		 |$LN46@Initialize|

; 218  :         {
; 219  :         // TX and RX CSDP settings for MCBSP FIFO packet burst
; 220  :         //
; 221  :         if (dmaSyncMap == m_pDevice->dmaTxSyncMap)
; 222  :             {
; 223  :             // To make sure the TX CSDP configurations
; 224  :             //
; 225  :             pDmaConfigInfo->elemSize |= DMA_CSDP_DST_PACKED |
; 226  :                 DMA_CSDP_DST_BURST_64BYTES_16x32_8x64;
; 227  :             }
; 228  :         else if (dmaSyncMap == m_pDevice->dmaRxSyncMap)
; 229  :             {
; 230  :             // To make sure the RX CSDP configurations
; 231  :             //
; 232  :             pDmaConfigInfo->elemSize |=  DMA_CSDP_SRC_PACKED |
; 233  :                 DMA_CSDP_SRC_BURST_64BYTES_16x32_8x64;

  00118	e5843000	 str         r3, [r4]
  0011c		 |$LN17@Initialize|

; 246  :             }
; 247  :         else if (dmaSyncMap == m_pDevice->dmaRxSyncMap)
; 248  :             {
; 249  :             // To make sure the RX CSDP configurations
; 250  :             //
; 251  :             pDmaConfigInfo->elemSize |= DMA_CSDP_SRC_PACKED |
; 252  :                 DMA_CSDP_SRC_BURST_64BYTES_16x32_8x64;
; 253  :             }
; 254  :         }
; 255  : 
; 256  :     if (dmaSyncMap == m_pDevice->dmaTxSyncMap)

  0011c	e595201c	 ldr         r2, [r5, #0x1C]
  00120	e59230a8	 ldr         r3, [r2, #0xA8]
  00124	e1560003	 cmp         r6, r3

; 257  :         {
; 258  :         // DMA destination frame index must be equal to the TX threshold
; 259  :         // value of the McBSP
; 260  :         pDmaConfigInfo->dstFrameIndex = m_pDevice->fifoThresholdTx + 1;

  00128	059230f0	 ldreq       r3, [r2, #0xF0]
  0012c	02833001	 addeq       r3, r3, #1
  00130	05843014	 streq       r3, [r4, #0x14]
  00134	0a000004	 beq         |$LN9@Initialize|

; 261  :         }
; 262  :     else if (dmaSyncMap == m_pDevice->dmaRxSyncMap)

  00138	e59230ac	 ldr         r3, [r2, #0xAC]
  0013c	e1560003	 cmp         r6, r3

; 263  :         {
; 264  :         // DMA source frame index must be equal to the RX threshold
; 265  :         // value of the McBSP
; 266  :         pDmaConfigInfo->srcFrameIndex = m_pDevice->fifoThresholdRx + 1;

  00140	05923110	 ldreq       r3, [r2, #0x110]
  00144	02833001	 addeq       r3, r3, #1
  00148	05843008	 streq       r3, [r4, #8]
  0014c		 |$LN9@Initialize|

; 267  :         }
; 268  : 
; 269  :     m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  0014c	e3a03000	 mov         r3, #0
  00150	e3a02000	 mov         r2, #0
  00154	e3a01000	 mov         r1, #0
  00158	e3a00000	 mov         r0, #0
  0015c	eb000000	 bl          CreateEventW
  00160	e3500000	 cmp         r0, #0
  00164	e5850058	 str         r0, [r5, #0x58]

; 270  :     if (m_hEvent == NULL)

  00168	0a000022	 beq         |$cleanUp$36773|

; 271  :         {
; 272  :         DEBUGMSG(ZONE_ERROR, (L"MCP: ERROR: DataPort_t::Initialize: "
; 273  :             L"Event creation failed\r\n")
; 274  :             );
; 275  :         goto cleanUp;
; 276  :         }
; 277  : 
; 278  :     m_hDmaChannel = DmaAllocateChannel(DMA_TYPE_SYSTEM);

  0016c	e3a00000	 mov         r0, #0
  00170	eb000000	 bl          DmaAllocateChannel
  00174	e3500000	 cmp         r0, #0
  00178	e585005c	 str         r0, [r5, #0x5C]

; 279  :     if (m_hDmaChannel == NULL)

  0017c	0a00001d	 beq         |$cleanUp$36773|

; 280  :         {
; 281  :         DEBUGMSG(ZONE_ERROR, (L"MCP: ERROR: DataPort_t::Initialize: "
; 282  :             L"Failed DmaAllocateChannel\r\n")
; 283  :             );
; 284  :         goto cleanUp;
; 285  :         }
; 286  : 
; 287  :     // register dma for interrupts
; 288  :     if (DmaEnableInterrupts(m_hDmaChannel, m_hEvent) == FALSE)

  00180	e5951058	 ldr         r1, [r5, #0x58]
  00184	eb000000	 bl          DmaEnableInterrupts
  00188	e3500000	 cmp         r0, #0
  0018c	0a000019	 beq         |$cleanUp$36773|

; 289  :         {
; 290  :         DEBUGMSG(ZONE_ERROR, (L"MCP: ERROR: DataPort_t::Initialize: "
; 291  :             L"Failed to register for interrupts\r\n")
; 292  :             );
; 293  :         goto cleanUp;
; 294  :         }
; 295  : 
; 296  :     // configure dma
; 297  :     //
; 298  :     DmaConfigure(m_hDmaChannel, pDmaConfigInfo, dmaSyncMap, &m_DmaInfo);

  00190	e595005c	 ldr         r0, [r5, #0x5C]
  00194	e2853004	 add         r3, r5, #4
  00198	e1a02006	 mov         r2, r6
  0019c	e1a01004	 mov         r1, r4
  001a0	eb000000	 bl          DmaConfigure

; 299  :     DmaSetElementAndFrameCount(&m_DmaInfo, (WORD)GetSamplesPerPage(), 2);

  001a4	e1d535b0	 ldrh        r3, [r5, #0x50]
  001a8	e5952018	 ldr         r2, [r5, #0x18]
  001ac	e5823014	 str         r3, [r2, #0x14]
  001b0	e5953018	 ldr         r3, [r5, #0x18]
  001b4	e583b018	 str         r11, [r3, #0x18]

; 300  :     DmaSetRepeatMode(&m_DmaInfo, TRUE);

  001b8	e5950014	 ldr         r0, [r5, #0x14]
  001bc	eb000000	 bl          DmaGetLogicalChannelId
  001c0	e3700001	 cmn         r0, #1
  001c4	15952018	 ldrne       r2, [r5, #0x18]
  001c8	13803902	 orrne       r3, r0, #2, 18

; 301  : 
; 302  :     // spawn thread
; 303  :     //
; 304  :     if (NULL == CreateThread(NULL, 0, pIstDma, m_pDevice, 0, NULL))

  001cc	e3a01000	 mov         r1, #0
  001d0	15823004	 strne       r3, [r2, #4]
  001d4	e595301c	 ldr         r3, [r5, #0x1C]
  001d8	e59d2034	 ldr         r2, [sp, #0x34]
  001dc	e3a00000	 mov         r0, #0
  001e0	e58da004	 str         r10, [sp, #4]
  001e4	e58da000	 str         r10, [sp]
  001e8	eb000000	 bl          CreateThread
  001ec	e3500000	 cmp         r0, #0

; 305  :         {
; 306  :         DEBUGMSG(ZONE_ERROR, (L"MCP: ERROR: DataPort_t::Initialize: "
; 307  :             L"Failed to create Ist Thread\r\n")
; 308  :             );
; 309  :         goto cleanUp;
; 310  :         }
; 311  : 
; 312  :     m_PortState = kMcBSP_Port_Idle;

  001f0	15859024	 strne       r9, [r5, #0x24]

; 313  :     bResult = TRUE;

  001f4	13a08001	 movne       r8, #1
  001f8		 |$cleanUp$36773|

; 314  : 
; 315  : cleanUp:
; 316  : 
; 317  :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:-%S\r\n", __FUNCTION__));
; 318  :     return bResult;
; 319  : }

  001f8	e1a00008	 mov         r0, r8
  001fc	e28dd010	 add         sp, sp, #0x10
  00200	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00204	e12fff1e	 bx          lr
  00208		 |$M37238|

			 ENDP  ; |?Initialize@DataPort_t@@UAAHPAUDmaConfigInfo_t@@KGP6AKPAX@Z@Z|, DataPort_t::Initialize

; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\mcbsp\dma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T37276| DCD	|$LN37@RestoreDMA|
	DCD	0x40005201
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\mcbsp\dataport.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?RestoreDMAcontext@DataPort_t@@UAAHPAUDmaConfigInfo_t@@KG@Z| PROC ; DataPort_t::RestoreDMAcontext

; 332  : {

  00000		 |$LN37@RestoreDMA|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M37273|
  00004	e1a05003	 mov         r5, r3
  00008	e1a07002	 mov         r7, r2
  0000c	e1a04001	 mov         r4, r1
  00010	e1a06000	 mov         r6, r0

; 333  :     BOOL bResult = FALSE;
; 334  : 
; 335  :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:+%S\r\n", __FUNCTION__));
; 336  : 
; 337  :     // TDM mode is sets DMA element size of 16bits.
; 338  :     // I2S mode supports  DMA element size from 8 bits to 32 bits
; 339  :     //
; 340  :     if ((m_pDevice->mcbspProfile == kMcBSPProfile_I2S_Slave) ||
; 341  :         (m_pDevice->mcbspProfile == kMcBSPProfile_I2S_Master))

  00014	e596301c	 ldr         r3, [r6, #0x1C]
  00018	e3a09002	 mov         r9, #2
  0001c	e3a08001	 mov         r8, #1
  00020	e593e08c	 ldr         lr, [r3, #0x8C]
  00024	e35e0000	 cmp         lr, #0
  00028	0a000005	 beq         |$LN20@RestoreDMA|
  0002c	e35e0001	 cmp         lr, #1
  00030	0a000003	 beq         |$LN20@RestoreDMA|

; 359  :             }
; 360  :         }
; 361  :     else if (m_pDevice->mcbspProfile == kMcBSPProfile_TDM)

  00034	e35e0002	 cmp         lr, #2
  00038	1a000009	 bne         |$LN16@RestoreDMA|

; 351  :             {
; 352  :             //  16 bit data type
; 353  :             pDmaConfigInfo->elemSize = DMA_CSDP_DATATYPE_S16;

  0003c	e5848000	 str         r8, [r4]

; 354  :             }
; 355  :         else

  00040	ea000007	 b           |$LN16@RestoreDMA|
  00044		 |$LN20@RestoreDMA|

; 342  :         {
; 343  :         // Determine DMA datatype
; 344  :         //
; 345  :         if (m_pDevice->wordLength > 16)

  00044	e59330cc	 ldr         r3, [r3, #0xCC]
  00048	e3530010	 cmp         r3, #0x10

; 346  :             {
; 347  :             //  32 bit data type
; 348  :             pDmaConfigInfo->elemSize = DMA_CSDP_DATATYPE_S32;

  0004c	85849000	 strhi       r9, [r4]
  00050	8a000003	 bhi         |$LN16@RestoreDMA|

; 349  :             }
; 350  :         else if (m_pDevice->wordLength > 8)

  00054	e3530008	 cmp         r3, #8

; 356  :             {
; 357  :             //  8 bit data type
; 358  :             pDmaConfigInfo->elemSize = DMA_CSDP_DATATYPE_S8;

  00058	93a03000	 movls       r3, #0
  0005c	85848000	 strhi       r8, [r4]
  00060	95843000	 strls       r3, [r4]
  00064		 |$LN16@RestoreDMA|

; 362  :         {
; 363  :         //  16 bit data type
; 364  :         pDmaConfigInfo->elemSize = DMA_CSDP_DATATYPE_S16;
; 365  :         }
; 366  : 
; 367  :     UpdateSamplesPerPage(nBufferSize, pDmaConfigInfo->elemSize);

  00064	e5963000	 ldr         r3, [r6]
  00068	e5942000	 ldr         r2, [r4]
  0006c	e1a01007	 mov         r1, r7
  00070	e593300c	 ldr         r3, [r3, #0xC]
  00074	e1a00006	 mov         r0, r6
  00078	e1a0e00f	 mov         lr, pc
  0007c	e12fff13	 bx          r3

; 368  : 
; 369  :     // Packet burst mode for I2S mode only
; 370  :     //
; 371  :     if ((m_pDevice->mcbspProfile == kMcBSPProfile_I2S_Slave) ||
; 372  :         (m_pDevice->mcbspProfile == kMcBSPProfile_I2S_Master))

  00080	e596201c	 ldr         r2, [r6, #0x1C]
  00084	e592308c	 ldr         r3, [r2, #0x8C]
  00088	e3530000	 cmp         r3, #0
  0008c	0a000003	 beq         |$LN12@RestoreDMA|
  00090	e3530001	 cmp         r3, #1
  00094	0a000001	 beq         |$LN12@RestoreDMA|

; 389  :             }
; 390  :         }
; 391  :     else if (m_pDevice->mcbspProfile == kMcBSPProfile_TDM)

  00098	e3530002	 cmp         r3, #2
  0009c	1a00000a	 bne         |$LN9@RestoreDMA|
  000a0		 |$LN12@RestoreDMA|

; 392  :         {
; 393  :         // TX and RX CSDP settings for MCBSP FIFO packet burst
; 394  :         //
; 395  :         if (dmaSyncMap == m_pDevice->dmaTxSyncMap)

  000a0	e59230a8	 ldr         r3, [r2, #0xA8]
  000a4	e1550003	 cmp         r5, r3

; 396  :             {
; 397  :             // To make sure the TX CSDP configurations are not over written
; 398  :             //
; 399  :             pDmaConfigInfo->elemSize |= DMA_CSDP_DST_PACKED |
; 400  :                 DMA_CSDP_DST_BURST_64BYTES_16x32_8x64;

  000a8	05943000	 ldreq       r3, [r4]
  000ac	03833a0e	 orreq       r3, r3, #0xE, 20
  000b0	0a000004	 beq         |$LN34@RestoreDMA|
  000b4	e59230ac	 ldr         r3, [r2, #0xAC]
  000b8	e1550003	 cmp         r5, r3
  000bc	1a000002	 bne         |$LN9@RestoreDMA|
  000c0	e5943000	 ldr         r3, [r4]
  000c4	e3833d07	 orr         r3, r3, #7, 26
  000c8		 |$LN34@RestoreDMA|

; 373  :         {
; 374  :         // TX and RX CSDP settings for MCBSP FIFO packet burst
; 375  :         //
; 376  :         if (dmaSyncMap == m_pDevice->dmaTxSyncMap)
; 377  :             {
; 378  :             // To make sure the TX CSDP configurations are not over written
; 379  :             //
; 380  :             pDmaConfigInfo->elemSize |= DMA_CSDP_DST_PACKED |
; 381  :                 DMA_CSDP_DST_BURST_64BYTES_16x32_8x64;
; 382  :             }
; 383  :         else if (dmaSyncMap == m_pDevice->dmaRxSyncMap)
; 384  :             {
; 385  :             // To make sure the RX CSDP configurations are not over written
; 386  :             //
; 387  :             pDmaConfigInfo->elemSize |= DMA_CSDP_SRC_PACKED |
; 388  :                 DMA_CSDP_SRC_BURST_64BYTES_16x32_8x64;

  000c8	e5843000	 str         r3, [r4]
  000cc		 |$LN9@RestoreDMA|

; 401  :             }
; 402  :         else if (dmaSyncMap == m_pDevice->dmaRxSyncMap)
; 403  :             {
; 404  :             // To make sure the RX CSDP configurations are not over written
; 405  :             //
; 406  :             pDmaConfigInfo->elemSize |= DMA_CSDP_SRC_PACKED |
; 407  :                 DMA_CSDP_SRC_BURST_64BYTES_16x32_8x64;
; 408  :             }
; 409  :         }
; 410  : 
; 411  :     if (dmaSyncMap == m_pDevice->dmaTxSyncMap)

  000cc	e596201c	 ldr         r2, [r6, #0x1C]
  000d0	e59230a8	 ldr         r3, [r2, #0xA8]
  000d4	e1550003	 cmp         r5, r3

; 412  :         {
; 413  :         // DMA destination frame index must be equal to the TX threshold
; 414  :         // value of the McBSP
; 415  :         pDmaConfigInfo->dstFrameIndex = m_pDevice->fifoThresholdTx + 1;

  000d8	059230f0	 ldreq       r3, [r2, #0xF0]
  000dc	02833001	 addeq       r3, r3, #1
  000e0	05843014	 streq       r3, [r4, #0x14]
  000e4	0a000004	 beq         |$LN1@RestoreDMA|

; 416  :         }
; 417  :     else if (dmaSyncMap == m_pDevice->dmaRxSyncMap)

  000e8	e59230ac	 ldr         r3, [r2, #0xAC]
  000ec	e1550003	 cmp         r5, r3

; 418  :         {
; 419  :         // DMA source frame index must be equal to the RX threshold
; 420  :         // value of the McBSP
; 421  :         pDmaConfigInfo->srcFrameIndex = m_pDevice->fifoThresholdRx + 1;

  000f0	05923110	 ldreq       r3, [r2, #0x110]
  000f4	02833001	 addeq       r3, r3, #1
  000f8	05843008	 streq       r3, [r4, #8]
  000fc		 |$LN1@RestoreDMA|

; 422  :         }
; 423  :     // configure dma
; 424  :     //
; 425  :     DmaUpdate(pDmaConfigInfo, dmaSyncMap, &m_DmaInfo);

  000fc	e2862004	 add         r2, r6, #4
  00100	e1a01005	 mov         r1, r5
  00104	e1a00004	 mov         r0, r4
  00108	eb000000	 bl          DmaUpdate

; 426  :     DmaSetElementAndFrameCount(&m_DmaInfo, (WORD)GetSamplesPerPage(), 2);

  0010c	e1d635b0	 ldrh        r3, [r6, #0x50]
  00110	e5962018	 ldr         r2, [r6, #0x18]
  00114	e5823014	 str         r3, [r2, #0x14]
  00118	e5963018	 ldr         r3, [r6, #0x18]
  0011c	e5839018	 str         r9, [r3, #0x18]

; 427  :     DmaSetRepeatMode(&m_DmaInfo, TRUE);

  00120	e5960014	 ldr         r0, [r6, #0x14]
  00124	eb000000	 bl          DmaGetLogicalChannelId
  00128	e3700001	 cmn         r0, #1
  0012c	15962018	 ldrne       r2, [r6, #0x18]
  00130	13803902	 orrne       r3, r0, #2, 18

; 428  : 
; 429  :     m_PortState = kMcBSP_Port_Idle;
; 430  :     bResult = TRUE;
; 431  : 
; 432  :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:-%S\r\n", __FUNCTION__));
; 433  : 
; 434  :     return bResult;

  00134	e3a00001	 mov         r0, #1
  00138	15823004	 strne       r3, [r2, #4]
  0013c	e5868024	 str         r8, [r6, #0x24]

; 435  : }

  00140	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00144	e12fff1e	 bx          lr
  00148		 |$M37274|

			 ENDP  ; |?RestoreDMAcontext@DataPort_t@@UAAHPAUDmaConfigInfo_t@@KG@Z|, DataPort_t::RestoreDMAcontext

; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\mcbsp\dma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T37322| DCD	|$LN20@StartDma|
	DCD	0x40002501
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\mcbsp\dataport.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?StartDma@DataPort_t@@UAAHH@Z| PROC	; DataPort_t::StartDma

; 447  : {

  00000		 |$LN20@StartDma|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37319|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 448  :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:-%S(bTransmitMode=%d)\r\n", __FUNCTION__,
; 449  :         bTransmitMode)
; 450  :         );
; 451  : 
; 452  :     m_PortState = kMcBSP_Port_Active;

  0000c	e3a03002	 mov         r3, #2
  00010	e5843024	 str         r3, [r4, #0x24]

; 453  :     DmaSetRepeatMode(&m_DmaInfo, TRUE);

  00014	e5940014	 ldr         r0, [r4, #0x14]
  00018	eb000000	 bl          DmaGetLogicalChannelId
  0001c	e3700001	 cmn         r0, #1
  00020	15942018	 ldrne       r2, [r4, #0x18]
  00024	13803902	 orrne       r3, r0, #2, 18
  00028	15823004	 strne       r3, [r2, #4]

; 454  : 
; 455  :     if (bTransmitMode)
; 456  :         {
; 457  :         // the buffer is the source
; 458  :         //
; 459  :         DmaSetSrcBuffer(&m_DmaInfo, m_pDmaBufferStart, m_DmaPhysAddr);

  0002c	e594103c	 ldr         r1, [r4, #0x3C]
  00030	e5943044	 ldr         r3, [r4, #0x44]
  00034	e5942018	 ldr         r2, [r4, #0x18]
  00038	e3550000	 cmp         r5, #0
  0003c	0a000007	 beq         |$LN2@StartDma|
  00040	e584100c	 str         r1, [r4, #0xC]
  00044	e5843004	 str         r3, [r4, #4]
  00048	e3520000	 cmp         r2, #0
  0004c	0a000009	 beq         |$LN13@StartDma|
  00050	e582101c	 str         r1, [r2, #0x1C]
  00054	e5943018	 ldr         r3, [r4, #0x18]
  00058	e5831034	 str         r1, [r3, #0x34]

; 460  :         }
; 461  :     else

  0005c	ea000005	 b           |$LN13@StartDma|
  00060		 |$LN2@StartDma|

; 462  :         {
; 463  :         DmaSetDstBuffer(&m_DmaInfo, m_pDmaBufferStart, m_DmaPhysAddr);

  00060	e3520000	 cmp         r2, #0
  00064	e5841010	 str         r1, [r4, #0x10]
  00068	e5843008	 str         r3, [r4, #8]
  0006c	15821020	 strne       r1, [r2, #0x20]
  00070	15943018	 ldrne       r3, [r4, #0x18]
  00074	15831038	 strne       r1, [r3, #0x38]
  00078		 |$LN13@StartDma|

; 464  :         }
; 465  : 
; 466  :     DmaStart(&m_DmaInfo);

  00078	e5942018	 ldr         r2, [r4, #0x18]

; 467  : 
; 468  :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:-%S\r\n", __FUNCTION__));
; 469  : 
; 470  :     return TRUE;

  0007c	e3a00001	 mov         r0, #1
  00080	e5923000	 ldr         r3, [r2]
  00084	e3833080	 orr         r3, r3, #0x80
  00088	e5823000	 str         r3, [r2]

; 471  : }

  0008c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$M37320|

			 ENDP  ; |?StartDma@DataPort_t@@UAAHH@Z|, DataPort_t::StartDma


  00000			 AREA	 |.pdata|, PDATA
|$T37332| DCD	|$LN5@StopDma|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?StopDma@DataPort_t@@UAAHXZ| PROC	; DataPort_t::StopDma

; 481  : {

  00000		 |$LN5@StopDma|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37329|

; 482  :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:+%S\r\n", __FUNCTION__));
; 483  : 
; 484  :     m_DmaLoopCounter = 0;

  00004	e3a03000	 mov         r3, #0

; 485  :     m_PortState = kMcBSP_Port_Idle;

  00008	e3a02001	 mov         r2, #1
  0000c	e5803020	 str         r3, [r0, #0x20]
  00010	e5802024	 str         r2, [r0, #0x24]

; 486  :     DmaStop(&m_DmaInfo);

  00014	e2800004	 add         r0, r0, #4
  00018	eb000000	 bl          DmaStop

; 487  : 
; 488  :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:-%S\r\n", __FUNCTION__));
; 489  : 
; 490  :     return TRUE;

  0001c	e3a00001	 mov         r0, #1

; 491  : }

  00020	e49de004	 ldr         lr, [sp], #4
  00024	e12fff1e	 bx          lr
  00028		 |$M37330|

			 ENDP  ; |?StopDma@DataPort_t@@UAAHXZ|, DataPort_t::StopDma

	EXPORT	|?SetDstPhysAddr@DataPort_t@@QAAXK@Z|	; DataPort_t::SetDstPhysAddr
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\mcbsp\dma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T37347| DCD	|$LN8@SetDstPhys|
	DCD	0x40000900
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\mcbsp\dataport.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetDstPhysAddr@DataPort_t@@QAAXK@Z| PROC ; DataPort_t::SetDstPhysAddr

; 503  : {

  00000		 |$LN8@SetDstPhys|
  00000		 |$M37344|

; 504  :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:+%S(PhysAddr=0x%08X)\r\n", __FUNCTION__,
; 505  :         PhysAddr)
; 506  :         );
; 507  : 
; 508  :     DmaSetDstBuffer(&m_DmaInfo, NULL, PhysAddr);

  00000	e5903018	 ldr         r3, [r0, #0x18]
  00004	e3a02000	 mov         r2, #0
  00008	e5802008	 str         r2, [r0, #8]
  0000c	e3530000	 cmp         r3, #0
  00010	e5801010	 str         r1, [r0, #0x10]
  00014	15831020	 strne       r1, [r3, #0x20]
  00018	15903018	 ldrne       r3, [r0, #0x18]
  0001c	15831038	 strne       r1, [r3, #0x38]

; 509  : 
; 510  :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:-%S\r\n", __FUNCTION__));
; 511  : }

  00020	e12fff1e	 bx          lr
  00024		 |$M37345|

			 ENDP  ; |?SetDstPhysAddr@DataPort_t@@QAAXK@Z|, DataPort_t::SetDstPhysAddr

	EXPORT	|?SetSrcPhysAddr@DataPort_t@@QAAXK@Z|	; DataPort_t::SetSrcPhysAddr
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\mcbsp\dma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T37362| DCD	|$LN8@SetSrcPhys|
	DCD	0x40000900
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\mcbsp\dataport.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetSrcPhysAddr@DataPort_t@@QAAXK@Z| PROC ; DataPort_t::SetSrcPhysAddr

; 523  : {

  00000		 |$LN8@SetSrcPhys|
  00000		 |$M37359|

; 524  :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:+%S(PhysAddr=0x%08X)\r\n", __FUNCTION__,
; 525  :         PhysAddr)
; 526  :         );
; 527  : 
; 528  :     DmaSetSrcBuffer(&m_DmaInfo, NULL, PhysAddr);

  00000	e3a03000	 mov         r3, #0
  00004	e5a03004	 str         r3, [r0, #4]!
  00008	e5903014	 ldr         r3, [r0, #0x14]
  0000c	e5801008	 str         r1, [r0, #8]
  00010	e3530000	 cmp         r3, #0
  00014	1583101c	 strne       r1, [r3, #0x1C]
  00018	15903014	 ldrne       r3, [r0, #0x14]
  0001c	15831034	 strne       r1, [r3, #0x34]

; 529  : 
; 530  :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:-%S\r\n", __FUNCTION__));
; 531  : }

  00020	e12fff1e	 bx          lr
  00024		 |$M37360|

			 ENDP  ; |?SetSrcPhysAddr@DataPort_t@@QAAXK@Z|, DataPort_t::SetSrcPhysAddr

; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\mcbsp\dma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T37388| DCD	|$LN17@SwapBuffer|
	DCD	0x40001801
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\mcbsp\dataport.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SwapBuffer@DataPort_t@@UAAXH@Z| PROC	; DataPort_t::SwapBuffer

; 542  : {

  00000		 |$LN17@SwapBuffer|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37385|
  00004	e3510000	 cmp         r1, #0

; 543  :     UINT8 const * pPos;
; 544  : 
; 545  :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:+%S\r\n", __FUNCTION__));
; 546  : 
; 547  :     // it's insufficient to just check the active buffer since the
; 548  :     // dma interrupt may not get serviced in time and the next page is
; 549  :     // already being rendered.  Check for this and select the appropriate
; 550  :     // page to swap to.
; 551  :     //
; 552  : 
; 553  :     if (bTransmitMode)
; 554  :         {
; 555  :         pPos = DmaGetLastReadPos(&m_DmaInfo);

  00008	e5903018	 ldr         r3, [r0, #0x18]
  0000c	1590200c	 ldrne       r2, [r0, #0xC]

; 556  :         }
; 557  :     else
; 558  :         {
; 559  :         pPos = DmaGetLastWritePos(&m_DmaInfo);

  00010	05902010	 ldreq       r2, [r0, #0x10]
  00014	15933034	 ldrne       r3, [r3, #0x34]
  00018	15901004	 ldrne       r1, [r0, #4]
  0001c	05901008	 ldreq       r1, [r0, #8]
  00020	05933038	 ldreq       r3, [r3, #0x38]
  00024	e0433002	 sub         r3, r3, r2

; 560  :         }
; 561  : 
; 562  :     // assume circular buffer.  therefore we only need to keep active
; 563  :     // buffer pointer in sync with DMA
; 564  :     //
; 565  :     if (pPos ==
; 566  :         ((m_pDmaBufferMiddle - m_pDmaBufferStart) + (m_pDmaBufferMiddle)))

  00028	e5902044	 ldr         r2, [r0, #0x44]
  0002c	e081e003	 add         lr, r1, r3
  00030	e5901048	 ldr         r1, [r0, #0x48]
  00034	e0623081	 rsb         r3, r2, r1, lsl #1
  00038	e15e0003	 cmp         lr, r3

; 567  :         {
; 568  :         m_pActiveDmaBuffer = m_pDmaBufferStart;

  0003c	0a000001	 beq         |$LN14@SwapBuffer|

; 569  :         }
; 570  :     else if (pPos < m_pDmaBufferMiddle)

  00040	e15e0001	 cmp         lr, r1
  00044	2a000002	 bcs         |$LN2@SwapBuffer|
  00048		 |$LN14@SwapBuffer|

; 571  :         {
; 572  :         m_pActiveDmaBuffer = m_pDmaBufferStart;

  00048	e5802040	 str         r2, [r0, #0x40]

; 577  :         }
; 578  : 
; 579  :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:-%S\r\n", __FUNCTION__));
; 580  : }

  0004c	e49de004	 ldr         lr, [sp], #4
  00050	e12fff1e	 bx          lr
  00054		 |$LN2@SwapBuffer|

; 573  :         }
; 574  :     else
; 575  :         {
; 576  :         m_pActiveDmaBuffer = m_pDmaBufferMiddle;

  00054	e5801040	 str         r1, [r0, #0x40]

; 577  :         }
; 578  : 
; 579  :     DEBUGMSG(ZONE_FUNCTION, (L"MCP:-%S\r\n", __FUNCTION__));
; 580  : }

  00058	e49de004	 ldr         lr, [sp], #4
  0005c	e12fff1e	 bx          lr
  00060		 |$M37386|

			 ENDP  ; |?SwapBuffer@DataPort_t@@UAAXH@Z|, DataPort_t::SwapBuffer

	IMPORT	|??3@YAXPAX@Z|				; operator delete

  00000			 AREA	 |.pdata|, PDATA
|$T37399| DCD	|$LN6@scalar|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GDataPort_t@@UAAPAXI@Z| PROC	; DataPort_t::`scalar deleting destructor'
  00000		 |$LN6@scalar|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37396|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          |??1DataPort_t@@UAA@XZ|
  00010	e3140001	 tst         r4, #1
  00014	11a00005	 movne       r0, r5
  00018	1b000000	 blne        |??3@YAXPAX@Z|
  0001c	e1a00005	 mov         r0, r5
  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M37397|

			 ENDP  ; |??_GDataPort_t@@UAAPAXI@Z|, DataPort_t::`scalar deleting destructor'

	END
