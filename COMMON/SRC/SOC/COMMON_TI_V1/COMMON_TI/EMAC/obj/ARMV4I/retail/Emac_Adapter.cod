; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\EMAC\Emac_Adapter.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|NICMapAdapterRegs|
	IMPORT	|NdisMMapIoSpace|
	IMPORT	|g_EmacMemLayout|
	IMPORT	|GetAddressByDevice|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\emac\emac_adapter.c

  00000			 AREA	 |.pdata|, PDATA
|$T50571| DCD	|$LN6@NICMapAdap|
	DCD	0x40001f02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NICMapAdapterRegs| PROC

; 34   : {

  00000		 |$LN6@NICMapAdap|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M50568|
  00008	e1a04000	 mov         r4, r0

; 35   :     DWORD temp;
; 36   :     DWORD                   EmacIRamBase;
; 37   :     NDIS_STATUS             Status;
; 38   :     NDIS_PHYSICAL_ADDRESS   PhysicalAddress;
; 39   : 
; 40   :     DEBUGMSG(DBG_FUNC, (L"-->NICMapAdapterRegs\r\n"));
; 41   : 
; 42   :     temp = GetAddressByDevice(pAdapter->m_device);

  0000c	e5940094	 ldr         r0, [r4, #0x94]
  00010	eb000000	 bl          GetAddressByDevice

; 43   : 
; 44   :     NdisSetPhysicalAddressLow (PhysicalAddress, temp);
; 45   :     NdisSetPhysicalAddressHigh (PhysicalAddress, 0);
; 46   : 
; 47   :    /* Mapping the EMAC controller registers to process memory
; 48   :     * and initialising the individual register modules
; 49   :     */
; 50   :     Status = NdisMMapIoSpace((PVOID*)&EmacIRamBase,
; 51   :                             pAdapter->m_AdapterHandle,
; 52   :                             PhysicalAddress,
; 53   :                             g_EmacMemLayout.EMAC_TOTAL_MEMORY);

  00014	e59f505c	 ldr         r5, [pc, #0x5C]
  00018	e5941000	 ldr         r1, [r4]
  0001c	e1a02000	 mov         r2, r0
  00020	e595e010	 ldr         lr, [r5, #0x10]
  00024	e3a03000	 mov         r3, #0
  00028	e28d0004	 add         r0, sp, #4
  0002c	e58de000	 str         lr, [sp]
  00030	eb000000	 bl          NdisMMapIoSpace
  00034	e3500000	 cmp         r0, #0

; 54   : 
; 55   :     if(Status != NDIS_STATUS_SUCCESS)
; 56   :     {
; 57   :         DEBUGMSG(DBG_ERR, (L"NdisMMapIoSpace failed\r\n"));
; 58   :         return Status;

  00038	1a00000b	 bne         |$LN2@NICMapAdap|

; 59   :     }
; 60   : 
; 61   :    /* Since EMAC register modules are contiguos assigning
; 62   :     * mapped memory to our adapter structure elements
; 63   :     */
; 64   : 
; 65   :     pAdapter->m_EmacIRamBase    = EmacIRamBase;

  0003c	e59d2004	 ldr         r2, [sp, #4]

; 66   :     pAdapter->m_pEmacRegsBase   = (PEMACREGS)(EmacIRamBase + g_EmacMemLayout.EMAC_REG_OFFSET);
; 67   :     pAdapter->m_pEmacCtlRegs    = (PEMACCTRLREGS)(EmacIRamBase + g_EmacMemLayout.EMAC_CTRL_OFFSET);
; 68   :     pAdapter->m_pMdioRegsBase   = (PEMACMDIOREGS)(EmacIRamBase + g_EmacMemLayout.EMAC_MDIO_OFFSET);
; 69   : 
; 70   :     DEBUGMSG(DBG_FUNC, (L"<--NICMapAdapterRegs EmacRegs->TXREVID = %x\r\n", pAdapter->m_pEmacRegsBase->TXREVID));
; 71   : 
; 72   :     return Status;

  00040	e3a00000	 mov         r0, #0
  00044	e584200c	 str         r2, [r4, #0xC]
  00048	e595300c	 ldr         r3, [r5, #0xC]
  0004c	e0833002	 add         r3, r3, r2
  00050	e5843004	 str         r3, [r4, #4]
  00054	e5953000	 ldr         r3, [r5]
  00058	e0833002	 add         r3, r3, r2
  0005c	e5843008	 str         r3, [r4, #8]
  00060	e5953008	 ldr         r3, [r5, #8]
  00064	e0833002	 add         r3, r3, r2
  00068	e5843010	 str         r3, [r4, #0x10]
  0006c		 |$LN2@NICMapAdap|

; 73   : }

  0006c	e28dd008	 add         sp, sp, #8
  00070	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00074	e12fff1e	 bx          lr
  00078		 |$LN7@NICMapAdap|
  00078		 |$LN8@NICMapAdap|
  00078	00000000	 DCD         |g_EmacMemLayout|
  0007c		 |$M50569|

			 ENDP  ; |NICMapAdapterRegs|

	EXPORT	|NICInitSend|
	IMPORT	|NdisAllocateMemory|
	IMPORT	|g_HighestAcceptedMax|
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T50601| DCD	|$LN27@NICInitSen|
	DCD	0x40009a02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NICInitSend| PROC

; 87   : {

  00000		 |$LN27@NICInitSen|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M50598|
  00008	e1a04000	 mov         r4, r0

; 88   :     NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
; 89   :     USHORT          Count;
; 90   :     DWORD           EmacTxBufDesBase;
; 91   :     DWORD           EmacTxBufDesBasePa;
; 92   :     DWORD           EmacTxPhyBuf ;
; 93   :     DWORD           EmacTxPhyBufPa;
; 94   :     PEMAC_TXPKT     pCurPkt;
; 95   :     PEMAC_TXPKT     pNextPkt;
; 96   :     PEMAC_TXBUF     pCurBuf;
; 97   :     PEMAC_TXBUF     pNextBuf;
; 98   : 
; 99   : 
; 100  :     DEBUGMSG(DBG_FUNC, (L"--> NICInitSend, \r\n" ));
; 101  : 
; 102  :     if(pAdapter->m_HwStatus != NdisHardwareStatusReset)

  0000c	e59431a0	 ldr         r3, [r4, #0x1A0]
  00010	e3a02a5e	 mov         r2, #0x5E, 20
  00014	e3a05000	 mov         r5, #0
  00018	e3530002	 cmp         r3, #2
  0001c	e3827c0a	 orr         r7, r2, #0xA, 24
  00020	0a000021	 beq         |$LN13@NICInitSen|

; 103  :     {
; 104  : 		/* Setting up Transmit Packets data structures */
; 105  : 		Status = NdisAllocateMemory((PVOID *)&pAdapter->m_pBaseTxPkts,
; 106  : 							pAdapter->m_MaxPacketPerTransmit * sizeof(EMAC_TXPKT),
; 107  : 							0,
; 108  : 							g_HighestAcceptedMax);

  00024	e59f6238	 ldr         r6, [pc, #0x238]
  00028	e1d412b8	 ldrh        r1, [r4, #0x28]
  0002c	e3a02000	 mov         r2, #0
  00030	e596e004	 ldr         lr, [r6, #4]
  00034	e5963000	 ldr         r3, [r6]
  00038	e0811101	 add         r1, r1, r1, lsl #2
  0003c	e1a01101	 mov         r1, r1, lsl #2
  00040	e2840034	 add         r0, r4, #0x34
  00044	e58de000	 str         lr, [sp]
  00048	eb000000	 bl          NdisAllocateMemory
  0004c	e1b05000	 movs        r5, r0

; 109  : 
; 110  : 		if (Status != NDIS_STATUS_SUCCESS)
; 111  : 		{
; 112  : 			DEBUGMSG(DBG_ERR,(L" NdisAllocateMemory Unsucessful\r\n"));
; 113  : 			return Status;

  00050	1a00007e	 bne         |$LN18@NICInitSen|

; 114  : 		}
; 115  : 
; 116  : 		/* Setting up Transmit Buffers  data structures */
; 117  : 		Status = NdisAllocateMemory((PVOID *)&pAdapter->m_pBaseTxBufs,
; 118  : 								pAdapter->m_MaxTxEmacBufs * sizeof(EMAC_TXBUF),
; 119  : 								0,
; 120  : 								g_HighestAcceptedMax);

  00054	e1d422ba	 ldrh        r2, [r4, #0x2A]
  00058	e596e004	 ldr         lr, [r6, #4]
  0005c	e5963000	 ldr         r3, [r6]
  00060	e0822082	 add         r2, r2, r2, lsl #1
  00064	e1a01182	 mov         r1, r2, lsl #3
  00068	e3a02000	 mov         r2, #0
  0006c	e2840038	 add         r0, r4, #0x38
  00070	e58de000	 str         lr, [sp]
  00074	eb000000	 bl          NdisAllocateMemory
  00078	e1b05000	 movs        r5, r0

; 121  : 
; 122  : 		if (Status != NDIS_STATUS_SUCCESS)
; 123  : 		{
; 124  : 			DEBUGMSG(DBG_ERR,(L" NdisAllocateMemory Unsucessful\r\n"));
; 125  : 			return Status;

  0007c	1a000073	 bne         |$LN18@NICInitSen|

; 126  : 		}
; 127  : 
; 128  : 		/* Allocating reserved memory for Tx buffers */
; 129  : 		if(NULL == (VOID *)pAdapter->m_TxBufBase)

  00080	e5943048	 ldr         r3, [r4, #0x48]
  00084	e3530000	 cmp         r3, #0
  00088	1a000007	 bne         |$LN13@NICInitSen|

; 130  : 		{
; 131  : 			Status = NdisMMapIoSpace((PVOID*)&pAdapter->m_TxBufBase,
; 132  : 							pAdapter->m_AdapterHandle,
; 133  : 							pAdapter->m_TxBufBasePa,
; 134  : 							(EMAC_MAX_TX_BUFFERS * EMAC_MAX_ETHERNET_PKT_SIZE));

  0008c	e1a00004	 mov         r0, r4
  00090	e4901048	 ldr         r1, [r0], #0x48
  00094	e5942050	 ldr         r2, [r4, #0x50]
  00098	e5943054	 ldr         r3, [r4, #0x54]
  0009c	e58d7000	 str         r7, [sp]
  000a0	eb000000	 bl          NdisMMapIoSpace
  000a4	e1b05000	 movs        r5, r0

; 135  : 
; 136  : 			if(Status != NDIS_STATUS_SUCCESS)
; 137  : 			{
; 138  : 				DEBUGMSG(DBG_ERR, (L"NdisMMapIoSpace failed\r\n"));
; 139  : 				return Status;

  000a8	1a000068	 bne         |$LN18@NICInitSen|
  000ac		 |$LN13@NICInitSen|

; 140  : 			}
; 141  : 		}
; 142  : 	}
; 143  : 
; 144  :     NdisZeroMemory(pAdapter->m_pBaseTxPkts, pAdapter->m_MaxPacketPerTransmit * sizeof(EMAC_TXPKT));

  000ac	e1d432b8	 ldrh        r3, [r4, #0x28]
  000b0	e5940034	 ldr         r0, [r4, #0x34]
  000b4	e3a01000	 mov         r1, #0
  000b8	e0833103	 add         r3, r3, r3, lsl #2
  000bc	e1a02103	 mov         r2, r3, lsl #2
  000c0	eb000000	 bl          memset

; 145  :     NdisZeroMemory(pAdapter->m_pBaseTxBufs, pAdapter->m_MaxTxEmacBufs * sizeof(EMAC_TXBUF));

  000c4	e1d432ba	 ldrh        r3, [r4, #0x2A]
  000c8	e5940038	 ldr         r0, [r4, #0x38]
  000cc	e3a01000	 mov         r1, #0
  000d0	e0833083	 add         r3, r3, r3, lsl #1
  000d4	e1a02183	 mov         r2, r3, lsl #3
  000d8	eb000000	 bl          memset

; 146  : 
; 147  :     pNextPkt = pAdapter->m_pBaseTxPkts;
; 148  : 
; 149  :     QUEUE_INIT(&pAdapter->m_TxPktsInfoPool);
; 150  : 
; 151  :     for (Count = 0; Count < pAdapter->m_MaxPacketPerTransmit ; Count++)

  000dc	e1d432b8	 ldrh        r3, [r4, #0x28]
  000e0	e3a0a000	 mov         r10, #0
  000e4	e5941034	 ldr         r1, [r4, #0x34]
  000e8	e3530000	 cmp         r3, #0
  000ec	e584a1d4	 str         r10, [r4, #0x1D4]
  000f0	e584a1d8	 str         r10, [r4, #0x1D8]
  000f4	e584a1dc	 str         r10, [r4, #0x1DC]
  000f8	0a00001b	 beq         |$LN24@NICInitSen|
  000fc	e3a00000	 mov         r0, #0
  00100		 |$LL12@NICInitSen|

; 152  :     {
; 153  :         pCurPkt = pNextPkt;

  00100	e1a0e001	 mov         lr, r1

; 154  : 
; 155  :         /* Add to Free Transmit packets pool */
; 156  :         QUEUE_INSERT(&pAdapter->m_TxPktsInfoPool,pCurPkt);

  00104	e3740f75	 cmn         r4, #0x75, 30
  00108	0a00000b	 beq         |$LN9@NICInitSen|
  0010c	e3510000	 cmp         r1, #0
  00110	0a000009	 beq         |$LN9@NICInitSen|
  00114	e59431d4	 ldr         r3, [r4, #0x1D4]
  00118	e3530000	 cmp         r3, #0
  0011c	159431d8	 ldrne       r3, [r4, #0x1D8]
  00120	058411d4	 streq       r1, [r4, #0x1D4]
  00124	15831000	 strne       r1, [r3]
  00128	e59431dc	 ldr         r3, [r4, #0x1DC]
  0012c	e58411d8	 str         r1, [r4, #0x1D8]
  00130	e2833001	 add         r3, r3, #1
  00134	e58431dc	 str         r3, [r4, #0x1DC]
  00138	e581a000	 str         r10, [r1]
  0013c		 |$LN9@NICInitSen|

; 157  : 
; 158  :         /* Initialise per packet maintained Bufs List */
; 159  :         QUEUE_INIT(&pCurPkt->m_BufsList);

  0013c	e581a008	 str         r10, [r1, #8]
  00140	e581a00c	 str         r10, [r1, #0xC]
  00144	e581a010	 str         r10, [r1, #0x10]

; 160  : 
; 161  :         pNextPkt++;

  00148	e2811014	 add         r1, r1, #0x14

; 162  : 
; 163  :         pCurPkt->m_pNext  = pNextPkt;

  0014c	e2803001	 add         r3, r0, #1
  00150	e58e1000	 str         r1, [lr]
  00154	e1d422b8	 ldrh        r2, [r4, #0x28]
  00158	e1a00803	 mov         r0, r3, lsl #16
  0015c	e1a00820	 mov         r0, r0, lsr #16
  00160	e1500002	 cmp         r0, r2
  00164	3affffe5	 bcc         |$LL12@NICInitSen|

; 146  : 
; 147  :     pNextPkt = pAdapter->m_pBaseTxPkts;
; 148  : 
; 149  :     QUEUE_INIT(&pAdapter->m_TxPktsInfoPool);
; 150  : 
; 151  :     for (Count = 0; Count < pAdapter->m_MaxPacketPerTransmit ; Count++)

  00168	ea000000	 b           |$LN10@NICInitSen|
  0016c		 |$LN24@NICInitSen|
  0016c	e59de004	 ldr         lr, [sp, #4]
  00170		 |$LN10@NICInitSen|

; 164  :     }
; 165  : 
; 166  :     pCurPkt->m_pNext = 0;

  00170	e58ea000	 str         r10, [lr]

; 167  : 
; 168  :     DEBUGMSG(DBG_INFO, (L"AptHandle = %p NdisMMapIoSpace TxBuff(size=%d)(%p)=PA:%p\r\n", 
; 169  :         pAdapter->m_AdapterHandle, 
; 170  :         (EMAC_MAX_TX_BUFFERS * EMAC_MAX_ETHERNET_PKT_SIZE), 
; 171  :         pAdapter->m_TxBufBase, 
; 172  :         pAdapter->m_TxBufBasePa));
; 173  : 
; 174  :     NdisZeroMemory((PVOID)pAdapter->m_TxBufBase, (EMAC_MAX_TX_BUFFERS * EMAC_MAX_ETHERNET_PKT_SIZE));

  00174	e5940048	 ldr         r0, [r4, #0x48]
  00178	e1a02007	 mov         r2, r7
  0017c	e3a01000	 mov         r1, #0
  00180	eb000000	 bl          memset

; 175  : 
; 176  :     EmacTxBufDesBase = pAdapter->m_EmacIRamBase + EMAC_TX_DESC_BASE;

  00184	e59f30d4	 ldr         r3, [pc, #0xD4]
  00188	e594000c	 ldr         r0, [r4, #0xC]

; 177  :     EmacTxBufDesBasePa = (g_EmacMemLayout.EMAC_PERPECTIVE_RAM_ADDR + EMAC_TX_DESC_BASE);
; 178  : 
; 179  :     EmacTxPhyBuf   = pAdapter->m_TxBufBase;
; 180  :     EmacTxPhyBufPa = NdisGetPhysicalAddressLow(pAdapter->m_TxBufBasePa);
; 181  : 
; 182  :     pNextBuf = pAdapter->m_pBaseTxBufs;
; 183  : 
; 184  :     QUEUE_INIT(&pAdapter->m_TxBufInfoPool);
; 185  : 
; 186  :     for (Count = 0; Count < pAdapter->m_MaxTxEmacBufs ; Count++)

  0018c	e1d4e2ba	 ldrh        lr, [r4, #0x2A]
  00190	e5931004	 ldr         r1, [r3, #4]
  00194	e5932014	 ldr         r2, [r3, #0x14]
  00198	e5948048	 ldr         r8, [r4, #0x48]
  0019c	e0803001	 add         r3, r0, r1
  001a0	e0822001	 add         r2, r2, r1
  001a4	e5949050	 ldr         r9, [r4, #0x50]
  001a8	e5940038	 ldr         r0, [r4, #0x38]
  001ac	e2836a01	 add         r6, r3, #1, 20
  001b0	e2827a01	 add         r7, r2, #1, 20
  001b4	e584a1c8	 str         r10, [r4, #0x1C8]
  001b8	e584a1cc	 str         r10, [r4, #0x1CC]
  001bc	e584a1d0	 str         r10, [r4, #0x1D0]
  001c0	e35e0000	 cmp         lr, #0
  001c4	0a00001e	 beq         |$LN4@NICInitSen|
  001c8	e3a0e000	 mov         lr, #0
  001cc		 |$LL6@NICInitSen|

; 187  :     {
; 188  :         pCurBuf = pNextBuf;
; 189  : 
; 190  :         /* Assigning the EMAC buffer descriptors virtual and physical
; 191  :         * addressses as well
; 192  :         */
; 193  :         pCurBuf->m_EmacBufDes   = EmacTxBufDesBase;
; 194  :         pCurBuf->m_EmacBufDesPa = EmacTxBufDesBasePa;
; 195  : 
; 196  :         /* Assigning corresponding physical and logical addresses */
; 197  : 
; 198  :         pCurBuf->m_BufLogicalAddress    = EmacTxPhyBuf;
; 199  :         pCurBuf->m_BufPhysicalAddress   = EmacTxPhyBufPa;
; 200  : 
; 201  :         EmacTxBufDesBase   += sizeof(EMAC_DESC);
; 202  :         EmacTxBufDesBasePa += sizeof(EMAC_DESC);
; 203  : 
; 204  :         EmacTxPhyBuf   += EMAC_MAX_ETHERNET_PKT_SIZE;

  001cc	e2883c05	 add         r3, r8, #5, 24

; 205  :         EmacTxPhyBufPa += EMAC_MAX_ETHERNET_PKT_SIZE;

  001d0	e2892c05	 add         r2, r9, #5, 24
  001d4	e1a01000	 mov         r1, r0
  001d8	e5806010	 str         r6, [r0, #0x10]
  001dc	e5807014	 str         r7, [r0, #0x14]
  001e0	e5808008	 str         r8, [r0, #8]
  001e4	e580900c	 str         r9, [r0, #0xC]
  001e8	e28380ea	 add         r8, r3, #0xEA
  001ec	e28290ea	 add         r9, r2, #0xEA
  001f0	e2866010	 add         r6, r6, #0x10
  001f4	e2877010	 add         r7, r7, #0x10

; 206  : 
; 207  :         pNextBuf++;

  001f8	e2800018	 add         r0, r0, #0x18

; 208  : 
; 209  :         QUEUE_INSERT(&pAdapter->m_TxBufInfoPool,pCurBuf);

  001fc	e3740f72	 cmn         r4, #0x72, 30
  00200	0a000009	 beq         |$LN5@NICInitSen|
  00204	e59431c8	 ldr         r3, [r4, #0x1C8]
  00208	e3530000	 cmp         r3, #0
  0020c	159431cc	 ldrne       r3, [r4, #0x1CC]
  00210	058411c8	 streq       r1, [r4, #0x1C8]
  00214	15831000	 strne       r1, [r3]
  00218	e59431d0	 ldr         r3, [r4, #0x1D0]
  0021c	e58411cc	 str         r1, [r4, #0x1CC]
  00220	e2833001	 add         r3, r3, #1
  00224	e58431d0	 str         r3, [r4, #0x1D0]
  00228	e581a000	 str         r10, [r1]
  0022c		 |$LN5@NICInitSen|
  0022c	e28e3001	 add         r3, lr, #1
  00230	e1d422ba	 ldrh        r2, [r4, #0x2A]
  00234	e1a0e803	 mov         lr, r3, lsl #16
  00238	e1a0e82e	 mov         lr, lr, lsr #16
  0023c	e15e0002	 cmp         lr, r2
  00240	3affffe1	 bcc         |$LL6@NICInitSen|
  00244		 |$LN4@NICInitSen|

; 210  : 
; 211  :     }
; 212  : 
; 213  :     /* Initialise posted packets queue */
; 214  :     QUEUE_INIT(&pAdapter->m_TxPostedPktPool);

  00244	e584a1e0	 str         r10, [r4, #0x1E0]
  00248	e584a1e4	 str         r10, [r4, #0x1E4]
  0024c	e584a1e8	 str         r10, [r4, #0x1E8]

; 215  : 
; 216  :     DEBUGMSG(DBG_FUNC, (L"<-- NICInitSend, \r\n" ));
; 217  : 
; 218  :     return Status;

  00250		 |$LN18@NICInitSen|

; 219  : }

  00250	e1a00005	 mov         r0, r5
  00254	e28dd008	 add         sp, sp, #8
  00258	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  0025c	e12fff1e	 bx          lr
  00260		 |$LN28@NICInitSen|
  00260		 |$LN29@NICInitSen|
  00260	00000000	 DCD         |g_EmacMemLayout|
  00264		 |$LN30@NICInitSen|
  00264	00000000	 DCD         |g_HighestAcceptedMax|
  00268		 |$M50599|

			 ENDP  ; |NICInitSend|

	EXPORT	|NICInitRecv|
	IMPORT	|NdisAllocateBuffer|
	IMPORT	|NdisAllocateBufferPool|
	IMPORT	|NdisAllocatePacket|
	IMPORT	|NdisAllocatePacketPool|

  00000			 AREA	 |.pdata|, PDATA
|$T50638| DCD	|$LN37@NICInitRec|
	DCD	0x4000c602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NICInitRecv| PROC

; 234  : {

  00000		 |$LN37@NICInitRec|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M50635|
  00008	e1a05000	 mov         r5, r0

; 235  :     NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
; 236  :     USHORT          Count;
; 237  :     DWORD           EmacRcvBufDesBase;
; 238  :     DWORD           EmacRcvBufDesBasePa;
; 239  :     PEMAC_RXPKTS    pCurPkt;
; 240  :     PEMAC_RXPKTS    pNextPkt;
; 241  :     PEMAC_RXBUFS    pCurBuf;
; 242  :     PEMAC_RXBUFS    pNextBuf;
; 243  :     DWORD           RcvBufLogical;
; 244  :     DWORD           RcvBufPhysical;
; 245  : 
; 246  :     EmacRcvBufDesBase   = (pAdapter->m_EmacIRamBase +EMAC_RX_DESC_BASE);
; 247  :     EmacRcvBufDesBasePa = (g_EmacMemLayout.EMAC_PERPECTIVE_RAM_ADDR + EMAC_RX_DESC_BASE);

  0000c	e59f6300	 ldr         r6, [pc, #0x300]

; 248  : 
; 249  :     DEBUGMSG(DBG_FUNC, (L"---> NICInitRecv \r\n" ));
; 250  : 
; 251  :     if(pAdapter->m_HwStatus != NdisHardwareStatusReset)

  00010	e59511a0	 ldr         r1, [r5, #0x1A0]
  00014	e3a00000	 mov         r0, #0
  00018	e5962014	 ldr         r2, [r6, #0x14]
  0001c	e5963004	 ldr         r3, [r6, #4]
  00020	e58d0004	 str         r0, [sp, #4]
  00024	e3510002	 cmp         r1, #2
  00028	e082a003	 add         r10, r2, r3
  0002c	0a000027	 beq         |$LN19@NICInitRec|

; 252  :     {
; 253  : 		// Setting up Receive Packets data structures */
; 254  : 		Status = NdisAllocateMemory((PVOID *)&pAdapter->m_pBaseRxPkts,
; 255  : 									  pAdapter->m_NumRxIndicatePkts * sizeof(EMAC_RXPKTS),
; 256  : 									  0,
; 257  : 									  g_HighestAcceptedMax);

  00030	e59f42d8	 ldr         r4, [pc, #0x2D8]
  00034	e1d512b4	 ldrh        r1, [r5, #0x24]
  00038	e3a02000	 mov         r2, #0
  0003c	e594e004	 ldr         lr, [r4, #4]
  00040	e5943000	 ldr         r3, [r4]
  00044	e0811101	 add         r1, r1, r1, lsl #2
  00048	e1a01101	 mov         r1, r1, lsl #2
  0004c	e285002c	 add         r0, r5, #0x2C
  00050	e58de000	 str         lr, [sp]
  00054	eb000000	 bl          NdisAllocateMemory
  00058	e3500000	 cmp         r0, #0
  0005c	e58d0004	 str         r0, [sp, #4]

; 258  : 	                            
; 259  : 		if (Status != NDIS_STATUS_SUCCESS)
; 260  : 		{
; 261  : 			DEBUGMSG(DBG_ERR,(L" NdisAllocateMemory Unsucessful\r\n"));
; 262  : 			return Status;

  00060	1a0000a7	 bne         |$LN1@NICInitRec|

; 263  : 		}
; 264  : 	    
; 265  : 		/* Setting up Receive Buffers  data structures */
; 266  : 	    
; 267  : 		Status = NdisAllocateMemory((PVOID *)&pAdapter->m_pBaseRxBufs,
; 268  : 										pAdapter->m_NumEmacRxBufDesc * sizeof(EMAC_RXBUFS),
; 269  : 										0,
; 270  : 										g_HighestAcceptedMax);

  00064	e1d522b6	 ldrh        r2, [r5, #0x26]
  00068	e594e004	 ldr         lr, [r4, #4]
  0006c	e5943000	 ldr         r3, [r4]
  00070	e0822082	 add         r2, r2, r2, lsl #1
  00074	e1a01182	 mov         r1, r2, lsl #3
  00078	e3a02000	 mov         r2, #0
  0007c	e2850030	 add         r0, r5, #0x30
  00080	e58de000	 str         lr, [sp]
  00084	eb000000	 bl          NdisAllocateMemory
  00088	e3500000	 cmp         r0, #0
  0008c	e58d0004	 str         r0, [sp, #4]

; 271  : 	                            
; 272  : 		if (Status != NDIS_STATUS_SUCCESS)
; 273  : 		{
; 274  : 			DEBUGMSG(DBG_ERR,(L" NdisAllocateMemory Unsucessful\r\n"));
; 275  : 			return Status;

  00090	1a00009b	 bne         |$LN1@NICInitRec|

; 276  : 		}
; 277  : 
; 278  : 		if(NULL == (VOID *)pAdapter->m_RxBufsBase)

  00094	e595303c	 ldr         r3, [r5, #0x3C]
  00098	e3530000	 cmp         r3, #0
  0009c	1a00000b	 bne         |$LN19@NICInitRec|

; 279  : 		{
; 280  : 			Status = NdisMMapIoSpace((PVOID*)&pAdapter->m_RxBufsBase,
; 281  : 							pAdapter->m_AdapterHandle,
; 282  : 							pAdapter->m_RxBufsBasePa,
; 283  : 							(pAdapter->m_NumEmacRxBufDesc * EMAC_MAX_PKT_BUFFER_SIZE));

  000a0	e1d532b6	 ldrh        r3, [r5, #0x26]
  000a4	e1a00005	 mov         r0, r5
  000a8	e490103c	 ldr         r1, [r0], #0x3C
  000ac	e5952040	 ldr         r2, [r5, #0x40]
  000b0	e083e083	 add         lr, r3, r3, lsl #1
  000b4	e5953044	 ldr         r3, [r5, #0x44]
  000b8	e1a0e48e	 mov         lr, lr, lsl #9
  000bc	e58de000	 str         lr, [sp]
  000c0	eb000000	 bl          NdisMMapIoSpace
  000c4	e3500000	 cmp         r0, #0
  000c8	e58d0004	 str         r0, [sp, #4]

; 284  : 
; 285  : 			if(Status != NDIS_STATUS_SUCCESS)
; 286  : 			{
; 287  : 				DEBUGMSG(DBG_ERR, (L"NdisMMapIoSpace failed\r\n"));
; 288  : 				return Status;

  000cc	1a00008c	 bne         |$LN1@NICInitRec|
  000d0		 |$LN19@NICInitRec|

; 289  : 			}
; 290  : 		}
; 291  : 	}
; 292  : 
; 293  :     DEBUGMSG(DBG_INFO, (L"AptHandle = %p NdisMMapIoSpace RxBuff(size=%d)(%p)=PA:%p\r\n", 
; 294  :         pAdapter->m_AdapterHandle, 
; 295  :         (pAdapter->m_NumEmacRxBufDesc * EMAC_MAX_PKT_BUFFER_SIZE), 
; 296  :         pAdapter->m_RxBufsBase, 
; 297  :         pAdapter->m_RxBufsBasePa));
; 298  : 
; 299  :     NdisZeroMemory(pAdapter->m_pBaseRxPkts,
; 300  :                     pAdapter->m_NumRxIndicatePkts * sizeof(EMAC_RXPKTS));

  000d0	e1d532b4	 ldrh        r3, [r5, #0x24]
  000d4	e595002c	 ldr         r0, [r5, #0x2C]
  000d8	e3a01000	 mov         r1, #0
  000dc	e0833103	 add         r3, r3, r3, lsl #2
  000e0	e1a02103	 mov         r2, r3, lsl #2
  000e4	eb000000	 bl          memset

; 301  : 
; 302  :     NdisZeroMemory(pAdapter->m_pBaseRxBufs,
; 303  :                     pAdapter->m_NumEmacRxBufDesc * sizeof(EMAC_RXBUFS));

  000e8	e1d532b6	 ldrh        r3, [r5, #0x26]
  000ec	e5950030	 ldr         r0, [r5, #0x30]
  000f0	e3a01000	 mov         r1, #0
  000f4	e0833083	 add         r3, r3, r3, lsl #1
  000f8	e1a02183	 mov         r2, r3, lsl #3
  000fc	eb000000	 bl          memset

; 304  : 
; 305  :     EmacRcvBufDesBase = (pAdapter->m_EmacIRamBase + EMAC_RX_DESC_BASE);
; 306  : 
; 307  :     NdisZeroMemory((PVOID)pAdapter->m_RxBufsBase,
; 308  :                     pAdapter->m_NumEmacRxBufDesc * EMAC_MAX_PKT_BUFFER_SIZE);

  00100	e1d532b6	 ldrh        r3, [r5, #0x26]
  00104	e595400c	 ldr         r4, [r5, #0xC]
  00108	e596e004	 ldr         lr, [r6, #4]
  0010c	e595003c	 ldr         r0, [r5, #0x3C]
  00110	e0833083	 add         r3, r3, r3, lsl #1
  00114	e1a02483	 mov         r2, r3, lsl #9
  00118	e3a01000	 mov         r1, #0
  0011c	e084b00e	 add         r11, r4, lr
  00120	eb000000	 bl          memset

; 309  : 
; 310  :     /* Allocate Packet pool */
; 311  :     NdisAllocatePacketPool(&Status,
; 312  :                            &pAdapter->m_RecvPacketPool,
; 313  :                            pAdapter->m_NumRxIndicatePkts,
; 314  :                            MINIPORT_RESERVED_SIZE);

  00124	e1d522b4	 ldrh        r2, [r5, #0x24]
  00128	e3a03c01	 mov         r3, #1, 24
  0012c	e285101c	 add         r1, r5, #0x1C
  00130	e28d0004	 add         r0, sp, #4
  00134	eb000000	 bl          NdisAllocatePacketPool

; 315  : 
; 316  :     if (Status != NDIS_STATUS_SUCCESS)

  00138	e59d0004	 ldr         r0, [sp, #4]
  0013c	e3500000	 cmp         r0, #0

; 317  :     {
; 318  :         DEBUGMSG(DBG_ERR, (L"NdisAllocatePacketPool failed\r\n"));
; 319  :         return Status;

  00140	1a00006f	 bne         |$LN1@NICInitRec|

; 320  :     }
; 321  : 
; 322  : 
; 323  :     pNextPkt = pAdapter->m_pBaseRxPkts;
; 324  : 
; 325  :     QUEUE_INIT(&pAdapter->m_RxPktPool);
; 326  : 
; 327  :     for (Count = 0; Count < pAdapter->m_NumRxIndicatePkts ; Count++)

  00144	e1d532b4	 ldrh        r3, [r5, #0x24]
  00148	e3a09000	 mov         r9, #0
  0014c	e595402c	 ldr         r4, [r5, #0x2C]
  00150	e3530000	 cmp         r3, #0
  00154	e58591b0	 str         r9, [r5, #0x1B0]
  00158	e58591b4	 str         r9, [r5, #0x1B4]
  0015c	e58591b8	 str         r9, [r5, #0x1B8]
  00160	e3a06000	 mov         r6, #0
  00164	0a000023	 beq         |$LN32@NICInitRec|
  00168	e3a0800e	 mov         r8, #0xE
  0016c		 |$LL17@NICInitRec|

; 328  :     {
; 329  :         pCurPkt = pNextPkt;
; 330  : 
; 331  :         /* Allocating packet from packet pool */
; 332  :         NdisAllocatePacket( &Status,
; 333  :                             (PNDIS_PACKET *)&pCurPkt->m_PktHandle,
; 334  :                             pAdapter->m_RecvPacketPool);

  0016c	e595201c	 ldr         r2, [r5, #0x1C]
  00170	e2841004	 add         r1, r4, #4
  00174	e28d0004	 add         r0, sp, #4
  00178	e1a07004	 mov         r7, r4
  0017c	eb000000	 bl          NdisAllocatePacket

; 335  : 
; 336  :         if (Status != NDIS_STATUS_SUCCESS)

  00180	e59d3004	 ldr         r3, [sp, #4]
  00184	e3530000	 cmp         r3, #0
  00188	1a00001b	 bne         |$LN28@NICInitRec|

; 337  :         {
; 338  :             DEBUGMSG(DBG_ERR,(L" NdisAllocatePacket Unsucessful\r\n"));
; 339  :             break;
; 340  :         }
; 341  : 
; 342  :         QUEUE_INSERT(&pAdapter->m_RxPktPool, pCurPkt);

  0018c	e2953e1b	 adds        r3, r5, #0x1B, 28
  00190	0a00000b	 beq         |$LN13@NICInitRec|
  00194	e3540000	 cmp         r4, #0
  00198	0a000009	 beq         |$LN13@NICInitRec|
  0019c	e59531b0	 ldr         r3, [r5, #0x1B0]
  001a0	e3530000	 cmp         r3, #0
  001a4	159531b4	 ldrne       r3, [r5, #0x1B4]
  001a8	058541b0	 streq       r4, [r5, #0x1B0]
  001ac	15834000	 strne       r4, [r3]
  001b0	e59531b8	 ldr         r3, [r5, #0x1B8]
  001b4	e58541b4	 str         r4, [r5, #0x1B4]
  001b8	e2833001	 add         r3, r3, #1
  001bc	e58531b8	 str         r3, [r5, #0x1B8]
  001c0	e5849000	 str         r9, [r4]
  001c4		 |$LN13@NICInitRec|

; 343  : 
; 344  :         NDIS_SET_PACKET_HEADER_SIZE((PNDIS_PACKET)pCurPkt->m_PktHandle, EMAC_HEADER_SIZE);

  001c4	e5941004	 ldr         r1, [r4, #4]

; 345  : 
; 346  :         pNextPkt++;

  001c8	e2863001	 add         r3, r6, #1
  001cc	e1a06803	 mov         r6, r3, lsl #16
  001d0	e1d121be	 ldrh        r2, [r1, #0x1E]
  001d4	e2844014	 add         r4, r4, #0x14
  001d8	e1a06826	 mov         r6, r6, lsr #16
  001dc	e0823001	 add         r3, r2, r1
  001e0	e5838010	 str         r8, [r3, #0x10]

; 347  :         pCurPkt->m_pNext  = pNextPkt;

  001e4	e5874000	 str         r4, [r7]
  001e8	e1d532b4	 ldrh        r3, [r5, #0x24]
  001ec	e1560003	 cmp         r6, r3
  001f0	3affffdd	 bcc         |$LL17@NICInitRec|

; 320  :     }
; 321  : 
; 322  : 
; 323  :     pNextPkt = pAdapter->m_pBaseRxPkts;
; 324  : 
; 325  :     QUEUE_INIT(&pAdapter->m_RxPktPool);
; 326  : 
; 327  :     for (Count = 0; Count < pAdapter->m_NumRxIndicatePkts ; Count++)

  001f4	ea000000	 b           |$LN28@NICInitRec|
  001f8		 |$LN32@NICInitRec|
  001f8	e59d7004	 ldr         r7, [sp, #4]
  001fc		 |$LN28@NICInitRec|

; 348  :     }
; 349  : 
; 350  :     pCurPkt->m_pNext=0;

  001fc	e5879000	 str         r9, [r7]

; 351  : 
; 352  :     if(Count != pAdapter->m_NumRxIndicatePkts)

  00200	e1d532b4	 ldrh        r3, [r5, #0x24]
  00204	e1560003	 cmp         r6, r3

; 353  :     {
; 354  :         return Status;

  00208	1a00003c	 bne         |$LN34@NICInitRec|

; 355  :     }
; 356  : 
; 357  :     DEBUGMSG (DBG_INFO,(L"+pAdapter->m_RxPktPool.Head %x\r\npAdapter->m_RxPktPool.Tail %x\r\npAdapter->m_RxPktPool.Count %x \r\n",
; 358  :         pAdapter->m_RxPktPool.m_pHead,  pAdapter->m_RxPktPool.m_pTail,pAdapter->m_RxPktPool.m_Count));
; 359  : 
; 360  :     /* Allocate  the receive buffer pool */
; 361  :     NdisAllocateBufferPool( &Status,
; 362  :                             &pAdapter->m_RecvBufferPool,
; 363  :                             pAdapter->m_NumEmacRxBufDesc
; 364  :                           );

  0020c	e1d522b6	 ldrh        r2, [r5, #0x26]
  00210	e2851020	 add         r1, r5, #0x20
  00214	e28d0004	 add         r0, sp, #4
  00218	eb000000	 bl          NdisAllocateBufferPool

; 365  :     if (Status != NDIS_STATUS_SUCCESS)

  0021c	e59d0004	 ldr         r0, [sp, #4]
  00220	e3500000	 cmp         r0, #0

; 366  :     {
; 367  :         DEBUGMSG(DBG_ERR, (L"NdisAllocateBufferPool failed\r\n"));
; 368  :         return Status;

  00224	1a000036	 bne         |$LN1@NICInitRec|

; 369  :     }
; 370  :     pNextBuf = pAdapter->m_pBaseRxBufs;
; 371  : 
; 372  :     RcvBufLogical   = pAdapter->m_RxBufsBase;
; 373  :     RcvBufPhysical =  NdisGetPhysicalAddressLow(pAdapter->m_RxBufsBasePa);
; 374  : 
; 375  :     QUEUE_INIT(&pAdapter->m_RxBufsPool);
; 376  : 
; 377  : 
; 378  :     for (Count = 0; Count < pAdapter->m_NumEmacRxBufDesc ; Count++)

  00228	e1d532b6	 ldrh        r3, [r5, #0x26]
  0022c	e5956030	 ldr         r6, [r5, #0x30]
  00230	e595703c	 ldr         r7, [r5, #0x3C]
  00234	e5958040	 ldr         r8, [r5, #0x40]
  00238	e58591bc	 str         r9, [r5, #0x1BC]
  0023c	e58591c0	 str         r9, [r5, #0x1C0]
  00240	e58591c4	 str         r9, [r5, #0x1C4]
  00244	e3530000	 cmp         r3, #0
  00248	e3a09000	 mov         r9, #0
  0024c	0a000028	 beq         |$LN33@NICInitRec|
  00250	e3a0ec06	 mov         lr, #6, 24
  00254		 |$LL8@NICInitRec|

; 379  :     {
; 380  :         pCurBuf = pNextBuf;
; 381  : 
; 382  :         pCurBuf->m_BufLogicalAddress  = RcvBufLogical;

  00254	e5867008	 str         r7, [r6, #8]

; 383  :         pCurBuf->m_BufPhysicalAddress = RcvBufPhysical;

  00258	e586800c	 str         r8, [r6, #0xC]

; 384  : 
; 385  :         /* point our buffer for receives at this Rfd */
; 386  :         NdisAllocateBuffer(&Status,
; 387  :                             (PNDIS_BUFFER *)&pCurBuf->m_BufHandle,
; 388  :                             pAdapter->m_RecvBufferPool,
; 389  :                             (PVOID)pCurBuf->m_BufLogicalAddress,
; 390  :                             EMAC_MAX_PKT_BUFFER_SIZE);

  0025c	e5952020	 ldr         r2, [r5, #0x20]
  00260	e1a03007	 mov         r3, r7
  00264	e2861004	 add         r1, r6, #4
  00268	e28d0004	 add         r0, sp, #4
  0026c	e1a04006	 mov         r4, r6
  00270	e58de000	 str         lr, [sp]
  00274	eb000000	 bl          NdisAllocateBuffer

; 391  : 
; 392  :         if (Status != NDIS_STATUS_SUCCESS)

  00278	e59d3004	 ldr         r3, [sp, #4]
  0027c	e3530000	 cmp         r3, #0
  00280	1a00001c	 bne         |$LN29@NICInitRec|

; 393  :         {
; 394  : 
; 395  :             DEBUGMSG(DBG_ERR,(L" NdisAllocateBuffer Unsucessful\r\n"));
; 396  :             break;
; 397  :         }
; 398  :         /* Assigning the EMAC buffer descriptors virtual and physical
; 399  :         * addressses as well
; 400  :         */
; 401  :         pCurBuf->m_EmacBufDes   = EmacRcvBufDesBase;
; 402  :         pCurBuf->m_EmacBufDesPa = EmacRcvBufDesBasePa;
; 403  : 
; 404  :         /* we will also set up correspondinf EMAC buffer descriptors virtual as
; 405  :         * well as physical
; 406  :         */
; 407  : 
; 408  :         RcvBufLogical += EMAC_MAX_PKT_BUFFER_SIZE;
; 409  :         RcvBufPhysical += EMAC_MAX_PKT_BUFFER_SIZE;
; 410  : 
; 411  :         EmacRcvBufDesBase += sizeof(EMAC_DESC);
; 412  :         EmacRcvBufDesBasePa += sizeof(EMAC_DESC);
; 413  : 
; 414  :         pNextBuf++;
; 415  : 
; 416  :         QUEUE_INSERT(&pAdapter->m_RxBufsPool,pCurBuf);

  00284	e586b010	 str         r11, [r6, #0x10]
  00288	e586a014	 str         r10, [r6, #0x14]
  0028c	e28bb010	 add         r11, r11, #0x10
  00290	e28aa010	 add         r10, r10, #0x10
  00294	e2866018	 add         r6, r6, #0x18
  00298	e2953f6f	 adds        r3, r5, #0x6F, 30
  0029c	e2877c06	 add         r7, r7, #6, 24
  002a0	e2888c06	 add         r8, r8, #6, 24
  002a4	0a00000a	 beq         |$LN7@NICInitRec|
  002a8	e59531bc	 ldr         r3, [r5, #0x1BC]
  002ac	e3530000	 cmp         r3, #0
  002b0	159531c0	 ldrne       r3, [r5, #0x1C0]
  002b4	058541bc	 streq       r4, [r5, #0x1BC]
  002b8	15834000	 strne       r4, [r3]
  002bc	e59531c4	 ldr         r3, [r5, #0x1C4]
  002c0	e58541c0	 str         r4, [r5, #0x1C0]
  002c4	e2833001	 add         r3, r3, #1
  002c8	e58531c4	 str         r3, [r5, #0x1C4]
  002cc	e3a03000	 mov         r3, #0
  002d0	e5843000	 str         r3, [r4]
  002d4		 |$LN7@NICInitRec|
  002d4	e2893001	 add         r3, r9, #1
  002d8	e1d522b6	 ldrh        r2, [r5, #0x26]
  002dc	e1a09803	 mov         r9, r3, lsl #16
  002e0	e1a09829	 mov         r9, r9, lsr #16
  002e4	e1590002	 cmp         r9, r2
  002e8	e3a0ec06	 mov         lr, #6, 24
  002ec	3affffd8	 bcc         |$LL8@NICInitRec|

; 369  :     }
; 370  :     pNextBuf = pAdapter->m_pBaseRxBufs;
; 371  : 
; 372  :     RcvBufLogical   = pAdapter->m_RxBufsBase;
; 373  :     RcvBufPhysical =  NdisGetPhysicalAddressLow(pAdapter->m_RxBufsBasePa);
; 374  : 
; 375  :     QUEUE_INIT(&pAdapter->m_RxBufsPool);
; 376  : 
; 377  : 
; 378  :     for (Count = 0; Count < pAdapter->m_NumEmacRxBufDesc ; Count++)

  002f0	ea000000	 b           |$LN29@NICInitRec|
  002f4		 |$LN33@NICInitRec|
  002f4	e59d4004	 ldr         r4, [sp, #4]
  002f8		 |$LN29@NICInitRec|

; 417  : 
; 418  :      }
; 419  :         pCurBuf->m_pNext=0;

  002f8	e3a03000	 mov         r3, #0
  002fc	e5843000	 str         r3, [r4]
  00300		 |$LN34@NICInitRec|

; 420  : 
; 421  :     if(Count != pAdapter->m_NumEmacRxBufDesc)

  00300	e59d0004	 ldr         r0, [sp, #4]
  00304		 |$LN1@NICInitRec|

; 422  :     {
; 423  :         return Status;
; 424  :     }
; 425  :     DEBUGMSG(DBG_FUNC, (L"<-- NICInitRecv, Status=%x\r\n", Status));
; 426  : 
; 427  :     return Status;
; 428  : }

  00304	e28dd008	 add         sp, sp, #8
  00308	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0030c	e12fff1e	 bx          lr
  00310		 |$LN38@NICInitRec|
  00310		 |$LN39@NICInitRec|
  00310	00000000	 DCD         |g_HighestAcceptedMax|
  00314		 |$LN40@NICInitRec|
  00314	00000000	 DCD         |g_EmacMemLayout|
  00318		 |$M50636|

			 ENDP  ; |NICInitRecv|

	EXPORT	|EMACModStateChange|
	IMPORT	|EnableDeviceClocks|
	IMPORT	|SocResetEmac|

  00000			 AREA	 |.pdata|, PDATA
|$T50653| DCD	|$LN11@EMACModSta|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |EMACModStateChange| PROC

; 441  : {

  00000		 |$LN11@EMACModSta|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M50650|
  00004	e3510000	 cmp         r1, #0
  00008	e1a04000	 mov         r4, r0

; 442  :     DEBUGMSG(TRUE, (L"+EMACModStateChange\r\n"));
; 443  :  
; 444  :     switch (ModState)

  0000c	0a000005	 beq         |$LN3@EMACModSta|
  00010	e3510001	 cmp         r1, #1
  00014	0a000004	 beq         |$LN2@EMACModSta|
  00018	e3510002	 cmp         r1, #2
  0001c	1a000005	 bne         |$LN4@EMACModSta|

; 449  :         break;
; 450  :     case ENABLED:
; 451  :         EnableDeviceClocks(device,TRUE);
; 452  :         break;
; 453  :     case DISABLED:
; 454  :         EnableDeviceClocks(device,FALSE);

  00020	e3a01000	 mov         r1, #0

; 455  :         break;

  00024	ea000001	 b           |$LN8@EMACModSta|
  00028		 |$LN3@EMACModSta|

; 445  :     {   
; 446  :     case SYNCRST:
; 447  :         SocResetEmac();

  00028	eb000000	 bl          SocResetEmac
  0002c		 |$LN2@EMACModSta|

; 448  :         EnableDeviceClocks(device,TRUE);

  0002c	e3a01001	 mov         r1, #1
  00030		 |$LN8@EMACModSta|
  00030	e1a00004	 mov         r0, r4
  00034	eb000000	 bl          EnableDeviceClocks
  00038		 |$LN4@EMACModSta|

; 456  :     }
; 457  : 
; 458  :     DEBUGMSG(TRUE, ( L"-EMACModStateChange\r\n" ));
; 459  : 
; 460  :     return (TRUE);

  00038	e3a00001	 mov         r0, #1

; 461  : }

  0003c	e8bd4010	 ldmia       sp!, {r4, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M50651|

			 ENDP  ; |EMACModStateChange|

	EXPORT	|NICInitializeAdapter|
	IMPORT	|EmacEnableInterrupts|
	IMPORT	|PhyFindLink|
	IMPORT	|NdisMSleep|

  00000			 AREA	 |.pdata|, PDATA
|$T50713| DCD	|$LN65@NICInitial|
	DCD	0x4000d202
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NICInitializeAdapter| PROC

; 475  : {

  00000		 |$LN65@NICInitial|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M50710|
  00008	e1a05000	 mov         r5, r0

; 476  :     NDIS_STATUS             Status = NDIS_STATUS_FAILURE;
; 477  :     PEMACREGS               pEmacRegs;
; 478  :     PEMACMDIOREGS           pMdioRegs;
; 479  :     PEMACCTRLREGS           pEmacCtlRegs;
; 480  :     PEMAC_RXBUFS            pEmacRxCur;
; 481  :     PEMAC_RXBUFS            pEmacRxNext;
; 482  :     PEMAC_TXBUF             pEmacTxCur;
; 483  :     PEMAC_TXBUF             pEmacTxNext;
; 484  :     PEMACDESC               pRxDesc;
; 485  :     PEMACDESC               pTxDesc;
; 486  :     UINT32*                 pu32RegPtr = NULL;
; 487  :     USHORT                  Count = 0;
; 488  :     UINT32                  clkdiv;
; 489  :     UINT32                  RetVal = 0;
; 490  : 
; 491  :     DEBUGMSG(DBG_FUNC, (L"--> NICInitializeAdapter \r\n"));
; 492  : 
; 493  :     //Power ON EMAC
; 494  :     EMACModStateChange(pAdapter->m_device,ENABLED);

  0000c	e5950094	 ldr         r0, [r5, #0x94]
  00010	e3a01001	 mov         r1, #1
  00014	eb000000	 bl          EnableDeviceClocks

; 495  : 
; 496  :     pEmacRegs       = pAdapter->m_pEmacRegsBase;

  00018	e5954004	 ldr         r4, [r5, #4]

; 497  :     pMdioRegs       = pAdapter->m_pMdioRegsBase;

  0001c	e5956010	 ldr         r6, [r5, #0x10]

; 498  :     pEmacCtlRegs    = pAdapter->m_pEmacCtlRegs;

  00020	e5958008	 ldr         r8, [r5, #8]

; 499  : 
; 500  :     /*Issuing a reset to EMAC soft reset register and polling till we get 0. */
; 501  :     pEmacRegs->SOFTRESET = 1;

  00024	e3a0a001	 mov         r10, #1
  00028	e584a174	 str         r10, [r4, #0x174]
  0002c		 |$LL32@NICInitial|

; 502  :     while ( pEmacRegs->SOFTRESET != 0 )

  0002c	e5943174	 ldr         r3, [r4, #0x174]
  00030	e3530000	 cmp         r3, #0
  00034	1afffffc	 bne         |$LL32@NICInitial|

; 503  :     {
; 504  :     }
; 505  :     pEmacRegs->SOFTRESET = 1;

  00038	e584a174	 str         r10, [r4, #0x174]
  0003c		 |$LL30@NICInitial|

; 506  :     while ( pEmacRegs->SOFTRESET != 0 )

  0003c	e5943174	 ldr         r3, [r4, #0x174]
  00040	e3530000	 cmp         r3, #0
  00044	1afffffc	 bne         |$LL30@NICInitial|

; 507  :     {
; 508  :     }
; 509  : 
; 510  :     /* Clear MACCONTROL, RXCONTROL & TXCONTROL registers */
; 511  :     pEmacRegs->MACCONTROL = 0x0;

  00048	e3a09000	 mov         r9, #0
  0004c	e5849160	 str         r9, [r4, #0x160]

; 512  :     pEmacRegs->TXCONTROL  = 0x0;

  00050	e5849004	 str         r9, [r4, #4]

; 513  :     pEmacRegs->RXCONTROL  = 0x0;

  00054	e5849014	 str         r9, [r4, #0x14]

; 514  : 
; 515  :     /* Initialise the 8 Rx/Tx Header descriptor pointer registers */
; 516  :     pu32RegPtr  = (UINT32 *)&pEmacRegs->TX0HDP;

  00058	e2842c06	 add         r2, r4, #6, 24

; 517  :     for (Count = 0; Count < EMAC_MAX_CHAN; Count++)

  0005c	e3a03000	 mov         r3, #0
  00060		 |$LL28@NICInitial|
  00060	e2833001	 add         r3, r3, #1
  00064	e1a03803	 mov         r3, r3, lsl #16
  00068	e1a03823	 mov         r3, r3, lsr #16
  0006c	e3530008	 cmp         r3, #8

; 518  :     {
; 519  :         *pu32RegPtr ++ = 0;

  00070	e4829004	 str         r9, [r2], #4
  00074	3afffff9	 bcc         |$LL28@NICInitial|

; 520  :     }
; 521  :     pu32RegPtr  = (UINT32 *)&pEmacRegs->RX0HDP;

  00078	e2842e62	 add         r2, r4, #0x62, 28

; 522  :     for (Count = 0; Count < EMAC_MAX_CHAN; Count++)

  0007c	e3a03000	 mov         r3, #0
  00080		 |$LL25@NICInitial|
  00080	e2833001	 add         r3, r3, #1
  00084	e1a03803	 mov         r3, r3, lsl #16
  00088	e1a03823	 mov         r3, r3, lsr #16
  0008c	e3530008	 cmp         r3, #8

; 523  :     {
; 524  :         *pu32RegPtr ++ = 0;

  00090	e4829004	 str         r9, [r2], #4
  00094	3afffff9	 bcc         |$LL25@NICInitial|

; 525  :     }
; 526  :     /* Clear 36 Statics registers */
; 527  :     /* The statics registers start from RXGODFRAMES and continues for the next
; 528  :      * 36 DWORD locations.
; 529  :      */
; 530  :     pu32RegPtr  = (UINT32 *)&pEmacRegs->RXGOODFRAMES;

  00098	e2842c02	 add         r2, r4, #2, 24

; 531  :     for (Count=0; Count < EMAC_STATS_REGS; Count++)

  0009c	e3a03000	 mov         r3, #0
  000a0		 |$LL22@NICInitial|
  000a0	e2833001	 add         r3, r3, #1
  000a4	e1a03803	 mov         r3, r3, lsl #16
  000a8	e1a03823	 mov         r3, r3, lsr #16
  000ac	e3530024	 cmp         r3, #0x24

; 532  :     {
; 533  :         *pu32RegPtr ++ = 0;

  000b0	e4829004	 str         r9, [r2], #4
  000b4	3afffff9	 bcc         |$LL22@NICInitial|

; 534  :     }
; 535  : 
; 536  :     /* Setup the local MAC address for all 8 Rx Channels */
; 537  : 
; 538  :     for (Count=0; Count < EMAC_MAX_CHAN; Count++)

  000b8	e3a0e000	 mov         lr, #0
  000bc		 |$LL19@NICInitial|

; 539  :     {
; 540  :         pEmacRegs->MACINDEX = Count;
; 541  : 
; 542  :         /* Filling MACADDRHI registers only for first channel */
; 543  :         if (Count==0 )

  000bc	e35e0000	 cmp         lr, #0
  000c0	e584e508	 str         lr, [r4, #0x508]

; 544  :         {
; 545  :             pEmacRegs->MACADDRHI = (
; 546  :                                        (*(pAdapter->m_MACAddress + 3) << 24) |
; 547  :                                        (*(pAdapter->m_MACAddress + 2) << 16) |
; 548  :                                        (*(pAdapter->m_MACAddress + 1) << 8) |
; 549  :                                        (*(pAdapter->m_MACAddress + 0) << 0)
; 550  :                                        );

  000c4	05d50017	 ldreqb      r0, [r5, #0x17]
  000c8	05d53016	 ldreqb      r3, [r5, #0x16]
  000cc	05d52015	 ldreqb      r2, [r5, #0x15]
  000d0	05d51014	 ldreqb      r1, [r5, #0x14]
  000d4	01833400	 orreq       r3, r3, r0, lsl #8
  000d8	01823403	 orreq       r3, r2, r3, lsl #8
  000dc	01813403	 orreq       r3, r1, r3, lsl #8
  000e0	05843504	 streq       r3, [r4, #0x504]

; 551  :         }
; 552  :         pEmacRegs->MACADDRLO = (
; 553  :                                    (*(pAdapter->m_MACAddress + 5) << 8) |
; 554  :                                    (*(pAdapter->m_MACAddress + 4) << 0) | (0<<16)|(1<<19) |(1<<20)
; 555  :                                    );

  000e4	e5d53019	 ldrb        r3, [r5, #0x19]
  000e8	e5d52018	 ldrb        r2, [r5, #0x18]
  000ec	e28e1001	 add         r1, lr, #1
  000f0	e3833b06	 orr         r3, r3, #6, 22
  000f4	e1a0e801	 mov         lr, r1, lsl #16
  000f8	e1823403	 orr         r3, r2, r3, lsl #8
  000fc	e1a0e82e	 mov         lr, lr, lsr #16
  00100	e5843500	 str         r3, [r4, #0x500]
  00104	e35e0008	 cmp         lr, #8
  00108	3affffeb	 bcc         |$LL19@NICInitial|

; 556  :     }
; 557  : 
; 558  : 
; 559  :     /* clear the MAC address hash registers to 0 */
; 560  :     pEmacRegs->MACHASH1 = 0;

  0010c	e58491d8	 str         r9, [r4, #0x1D8]

; 561  :     pEmacRegs->MACHASH2 = 0;

  00110	e58491dc	 str         r9, [r4, #0x1DC]

; 562  : 
; 563  :     /* Setup the local MAC address for 0th Transmit channel */
; 564  :     pEmacRegs->MACINDEX = 0;

  00114	e5849508	 str         r9, [r4, #0x508]

; 565  :     pEmacRegs->MACSRCADDRHI = (
; 566  :                                   (*(pAdapter->m_MACAddress + 3) << 24) |
; 567  :                                   (*(pAdapter->m_MACAddress + 2) << 16) |
; 568  :                                   (*(pAdapter->m_MACAddress + 1) << 8) |
; 569  :                                   (*(pAdapter->m_MACAddress + 0) << 0)
; 570  :                                   );

  00118	e5d50017	 ldrb        r0, [r5, #0x17]
  0011c	e5d53016	 ldrb        r3, [r5, #0x16]
  00120	e5d52015	 ldrb        r2, [r5, #0x15]
  00124	e5d51014	 ldrb        r1, [r5, #0x14]
  00128	e1833400	 orr         r3, r3, r0, lsl #8
  0012c	e1823403	 orr         r3, r2, r3, lsl #8
  00130	e1813403	 orr         r3, r1, r3, lsl #8
  00134	e58431d4	 str         r3, [r4, #0x1D4]

; 571  : 
; 572  :     pEmacRegs->MACSRCADDRLO = (
; 573  :                                   (*(pAdapter->m_MACAddress + 5) << 8) |
; 574  :                                   (*(pAdapter->m_MACAddress + 4) << 0)
; 575  :                                   );

  00138	e5d52019	 ldrb        r2, [r5, #0x19]
  0013c	e5d53018	 ldrb        r3, [r5, #0x18]

; 576  : 
; 577  :     /* Initialize the receive channel free buffer register including the
; 578  :      * count, threshold, filter low priority frame threshold etc.
; 579  :      */
; 580  :     pEmacRegs->RX0FREEBUFFER = EMAC_MAX_RXBUF_DESCS;

  00140	e1833402	 orr         r3, r3, r2, lsl #8
  00144	e58431d0	 str         r3, [r4, #0x1D0]
  00148	e3a03c01	 mov         r3, #1, 24
  0014c	e5843140	 str         r3, [r4, #0x140]

; 581  :     pEmacRegs->RX0FLOWTHRESH = 0x1;

  00150	e584a120	 str         r10, [r4, #0x120]

; 582  :     pEmacRegs->MACCONTROL   |= (EMAC_MACCONTROL_RXBUFFERFLOW_ENABLE);

  00154	e5943160	 ldr         r3, [r4, #0x160]

; 583  : 
; 584  :     /* clear the MAC address hash registers to 0 */
; 585  :     pEmacRegs->MACHASH1 = 0;
; 586  :     pEmacRegs->MACHASH2 = 0;
; 587  : 
; 588  :     /* Zero the receive buffer offset register */
; 589  :     pEmacRegs->RXBUFFEROFFSET = 0;
; 590  : 
; 591  : 
; 592  :     /* Clear all the UniCast receive . This will effectively disalbe any packet
; 593  :      * reception.
; 594  :      */
; 595  :     pEmacRegs->RXUNICASTCLEAR = 0xFF;

  00158	e3a020ff	 mov         r2, #0xFF
  0015c	e3833008	 orr         r3, r3, #8
  00160	e5843160	 str         r3, [r4, #0x160]
  00164	e58491d8	 str         r9, [r4, #0x1D8]
  00168	e58491dc	 str         r9, [r4, #0x1DC]
  0016c	e5849110	 str         r9, [r4, #0x110]

; 596  : 
; 597  :     /* Setup receive multicast/broadcast/promiscous channel enable on channel 0.
; 598  :      * We don't need to enable the multicast/promiscous modes. However, we do
; 599  :      * need the broadcast receive capability.
; 600  :      */
; 601  :     pEmacRegs->RXMBPENABLE = EMAC_RXMBPENABLE_RXBROADEN; 

  00170	e3a03a02	 mov         r3, #2, 20
  00174	e5842108	 str         r2, [r4, #0x108]
  00178	e5843100	 str         r3, [r4, #0x100]

; 602  : 
; 603  :     /* Setup MACCONTROL register with apt value */
; 604  :     pEmacRegs->MACCONTROL = EMAC_MACCONTROL_FULLDUPLEX_ENABLE;

  0017c	e584a160	 str         r10, [r4, #0x160]

; 605  :     
; 606  :     /* Clear all unused Tx and RX channel interrupts */
; 607  :     pEmacRegs->TXINTMASKCLEAR = 0xFF;

  00180	e584208c	 str         r2, [r4, #0x8C]

; 608  :     pEmacRegs->RXINTMASKCLEAR = 0xFF;

  00184	e58420ac	 str         r2, [r4, #0xAC]

; 609  : 
; 610  :     /* Enable the Rx and Tx channel interrupt mask registers.
; 611  :      * Setting channel0   RX & TX channel interrupts
; 612  :      */
; 613  :     pEmacRegs->RXINTMASKSET = 0x1;

  00188	e584a0a8	 str         r10, [r4, #0xA8]

; 614  :     pEmacRegs->TXINTMASKSET = 0x1;

  0018c	e584a088	 str         r10, [r4, #0x88]

; 615  : 
; 616  :     /* Setting up Rx buffer descriptors */
; 617  :     pEmacRxNext = pAdapter->m_pBaseRxBufs;
; 618  :     for( Count = 0; Count < pAdapter->m_NumEmacRxBufDesc ; Count++)

  00190	e1d532b6	 ldrh        r3, [r5, #0x26]
  00194	e5957030	 ldr         r7, [r5, #0x30]
  00198	e3530000	 cmp         r3, #0
  0019c	0a000013	 beq         |$LN61@NICInitial|
  001a0	e3a0e000	 mov         lr, #0
  001a4	e3a0bc06	 mov         r11, #6, 24
  001a8	e3a0a202	 mov         r10, #2, 4
  001ac		 |$LL15@NICInitial|

; 619  :     {
; 620  :         pEmacRxCur            = pEmacRxNext;

  001ac	e1a01007	 mov         r1, r7

; 621  :         pEmacRxNext++;

  001b0	e2877018	 add         r7, r7, #0x18

; 622  :         pRxDesc               = (PEMACDESC)pEmacRxCur->m_EmacBufDes;
; 623  :         pRxDesc->pNext        = (PEMACDESC)(pEmacRxNext->m_EmacBufDesPa);

  001b4	e5972014	 ldr         r2, [r7, #0x14]
  001b8	e5910010	 ldr         r0, [r1, #0x10]
  001bc	e28e3001	 add         r3, lr, #1
  001c0	e1a0e803	 mov         lr, r3, lsl #16
  001c4	e5802000	 str         r2, [r0]

; 624  :         pRxDesc->pBuffer      = (UINT8 *)(pEmacRxCur->m_BufPhysicalAddress);

  001c8	e591300c	 ldr         r3, [r1, #0xC]

; 625  :         pRxDesc->BufOffLen    = EMAC_MAX_PKT_BUFFER_SIZE;

  001cc	e580b008	 str         r11, [r0, #8]

; 626  :         pRxDesc->PktFlgLen    = EMAC_DSC_FLAG_OWNER;

  001d0	e580a00c	 str         r10, [r0, #0xC]
  001d4	e5803004	 str         r3, [r0, #4]
  001d8	e1d532b6	 ldrh        r3, [r5, #0x26]
  001dc	e1a0e82e	 mov         lr, lr, lsr #16
  001e0	e15e0003	 cmp         lr, r3
  001e4	3afffff0	 bcc         |$LL15@NICInitial|

; 615  : 
; 616  :     /* Setting up Rx buffer descriptors */
; 617  :     pEmacRxNext = pAdapter->m_pBaseRxBufs;
; 618  :     for( Count = 0; Count < pAdapter->m_NumEmacRxBufDesc ; Count++)

  001e8	e3a0a001	 mov         r10, #1
  001ec	ea000000	 b           |$LN13@NICInitial|
  001f0		 |$LN61@NICInitial|
  001f0	e59d0000	 ldr         r0, [sp]
  001f4		 |$LN13@NICInitial|

; 627  :      }
; 628  : 
; 629  :      pRxDesc-> pNext = 0;

  001f4	e5809000	 str         r9, [r0]

; 630  : 
; 631  :     /* Setting up Tx buffer descriptors */
; 632  :     pEmacTxNext = pAdapter->m_pBaseTxBufs;
; 633  :     for( Count = 0; Count < pAdapter->m_MaxTxEmacBufs ; Count++)

  001f8	e1d532ba	 ldrh        r3, [r5, #0x2A]
  001fc	e5950038	 ldr         r0, [r5, #0x38]
  00200	e3530000	 cmp         r3, #0
  00204	0a000010	 beq         |$LN62@NICInitial|
  00208	e3a03c05	 mov         r3, #5, 24
  0020c	e38370ea	 orr         r7, r3, #0xEA
  00210	e3a0e000	 mov         lr, #0
  00214		 |$LL12@NICInitial|

; 634  :     {
; 635  :         pEmacTxCur            = pEmacTxNext;

  00214	e1a03000	 mov         r3, r0

; 636  :         pEmacTxNext++;

  00218	e2800018	 add         r0, r0, #0x18

; 637  :         pTxDesc               = (PEMACDESC)pEmacTxCur->m_EmacBufDes;
; 638  :         pTxDesc->pNext        = (PEMACDESC)(pEmacTxNext->m_EmacBufDesPa);

  0021c	e5902014	 ldr         r2, [r0, #0x14]
  00220	e5931010	 ldr         r1, [r3, #0x10]
  00224	e28e3001	 add         r3, lr, #1
  00228	e1a0e803	 mov         lr, r3, lsl #16
  0022c	e8810204	 stmia       r1, {r2, r9}

; 639  :         pTxDesc->pBuffer      = 0;
; 640  :         pTxDesc->BufOffLen    = EMAC_MAX_ETHERNET_PKT_SIZE;

  00230	e281c008	 add         r12, r1, #8
  00234	e88c0280	 stmia       r12, {r7, r9}

; 641  :         pTxDesc->PktFlgLen    = 0;

  00238	e1d532ba	 ldrh        r3, [r5, #0x2A]
  0023c	e1a0e82e	 mov         lr, lr, lsr #16
  00240	e15e0003	 cmp         lr, r3
  00244	3afffff2	 bcc         |$LL12@NICInitial|

; 630  : 
; 631  :     /* Setting up Tx buffer descriptors */
; 632  :     pEmacTxNext = pAdapter->m_pBaseTxBufs;
; 633  :     for( Count = 0; Count < pAdapter->m_MaxTxEmacBufs ; Count++)

  00248	ea000000	 b           |$LN10@NICInitial|
  0024c		 |$LN62@NICInitial|
  0024c	e59d1000	 ldr         r1, [sp]
  00250		 |$LN10@NICInitial|

; 642  :      }
; 643  : 
; 644  :     pTxDesc->pNext = 0;
; 645  : 
; 646  :     /* Adjust RX Length characteristics */
; 647  :     pEmacRegs->RXMAXLEN = EMAC_RX_MAX_LEN;
; 648  : 
; 649  :     // Todo : Get the clock value using the clock SDK
; 650  :     clkdiv = 166000000;
; 651  :     clkdiv = (clkdiv/(EMAC_MDIO_CLOCK_FREQ)) - 1;
; 652  : 
; 653  :     pMdioRegs->CONTROL = ((clkdiv & 0xFF) |
; 654  :                               (MDIO_CONTROL_ENABLE) |
; 655  :                               (MDIO_CONTROL_FAULTEN) |
; 656  :                               (MDIO_CONTROL_FAULT));

  00250	e59f30ec	 ldr         r3, [pc, #0xEC]
  00254	e3a02e5f	 mov         r2, #0x5F, 28
  00258	e5819000	 str         r9, [r1]
  0025c	e584210c	 str         r2, [r4, #0x10C]
  00260	e5863004	 str         r3, [r6, #4]

; 657  : 
; 658  :     // wait for MDIO to become active
; 659  :     while (pMdioRegs->CONTROL & MDIO_CONTROL_IDLE) {

  00264	e5963004	 ldr         r3, [r6, #4]
  00268	e3130102	 tst         r3, #2, 2
  0026c	0a000005	 beq         |$LN8@NICInitial|
  00270	e3a07c13	 mov         r7, #0x13, 24
  00274		 |$LL9@NICInitial|

; 660  :         //5ms sleep
; 661  :         NdisMSleep(1000*5);

  00274	e3870088	 orr         r0, r7, #0x88
  00278	eb000000	 bl          NdisMSleep
  0027c	e5963004	 ldr         r3, [r6, #4]
  00280	e3130102	 tst         r3, #2, 2
  00284	1afffffa	 bne         |$LL9@NICInitial|
  00288		 |$LN8@NICInitial|

; 662  :     };
; 663  : 
; 664  :     // wait for the phy(s) to indicate they are active
; 665  :     for(Count = 0;Count < 256; Count++)

  00288	e3a07000	 mov         r7, #0
  0028c	e3a0bc27	 mov         r11, #0x27, 24
  00290		 |$LL7@NICInitial|

; 666  :     {
; 667  :         DEBUGMSG(TRUE, (TEXT("NICInitializeAdapter: waiting for active phy... 0x%x\r\n"), pMdioRegs->ALIVE));
; 668  :         if(pMdioRegs->ALIVE)

  00290	e5963008	 ldr         r3, [r6, #8]
  00294	e3530000	 cmp         r3, #0
  00298	1a000006	 bne         |$LN52@NICInitial|

; 669  :             break;
; 670  :         NdisMSleep(1000* 10);

  0029c	e38b0010	 orr         r0, r11, #0x10
  002a0	eb000000	 bl          NdisMSleep
  002a4	e2873001	 add         r3, r7, #1
  002a8	e1a07803	 mov         r7, r3, lsl #16
  002ac	e1a07827	 mov         r7, r7, lsr #16
  002b0	e3570c01	 cmp         r7, #1, 24
  002b4	3afffff5	 bcc         |$LL7@NICInitial|
  002b8		 |$LN52@NICInitial|

; 666  :     {
; 667  :         DEBUGMSG(TRUE, (TEXT("NICInitializeAdapter: waiting for active phy... 0x%x\r\n"), pMdioRegs->ALIVE));
; 668  :         if(pMdioRegs->ALIVE)

  002b8	e5963008	 ldr         r3, [r6, #8]

; 671  :     }
; 672  : 
; 673  :     // print out the Phy(s) that are active
; 674  :     if(pMdioRegs->ALIVE)
; 675  :         DEBUGMSG(TRUE, (TEXT("NICInitializeAdapter: pMdioRegs->ALIVE = 0x%x\r\n"), pMdioRegs->ALIVE));
; 676  : 
; 677  : #ifdef SUPPORT_TWO_ETH_PORT
; 678  :     
; 679  :     RetVal = PhyFindLink(pAdapter);
; 680  :     while(0 == RetVal)
; 681  :     {
; 682  :         DEBUGMSG(DBG_WARN, (TEXT("WARN: NICInitializeAdapter --> Could not find the link!!!\r\n")));
; 683  :         //1sec
; 684  :         NdisMSleep(1000*1000);
; 685  : 
; 686  :         RetVal = PhyFindLink(pAdapter);
; 687  :     }
; 688  : 
; 689  :     /* Monitor the PHY address for any link change  */
; 690  :     pMdioRegs->USERPHYSEL0 |= pAdapter->m_ActivePhy;
; 691  :     /* Enabling Link change status interrupt for PHY address being monitored */
; 692  :     pMdioRegs->USERPHYSEL0 |= (BIT(6));
; 693  :     /* Indicate that link is UP */
; 694  :     pAdapter->m_LinkStatus = UP;
; 695  : 
; 696  : #else
; 697  :     /* Supporting only Ethernet Port1 only if ethernet cable is not plug in 
; 698  :      * while booting up
; 699  :     */
; 700  : 
; 701  :     if(0 != PhyFindLink(pAdapter))

  002bc	e1a00005	 mov         r0, r5
  002c0	eb000000	 bl          PhyFindLink
  002c4	e3500000	 cmp         r0, #0

; 702  :     {
; 703  :         /* Indicate that link is UP */
; 704  :         pAdapter->m_LinkStatus = UP;

  002c8	158591a4	 strne       r9, [r5, #0x1A4]

; 705  :     }
; 706  : 	else
; 707  : 	{
; 708  :         pAdapter->m_LinkStatus = DOWN;
; 709  : 	}
; 710  : 
; 711  :     /* Monitor the PHY address for any link change  */
; 712  :     pMdioRegs->USERPHYSEL0 |= pAdapter->m_ActivePhy;

  002cc	e59531a8	 ldr         r3, [r5, #0x1A8]
  002d0	0585a1a4	 streq       r10, [r5, #0x1A4]
  002d4	e5962084	 ldr         r2, [r6, #0x84]

; 713  :     /* Enabling Link change status interrupt for PHY address being monitored */
; 714  :     pMdioRegs->USERPHYSEL0 |= (BIT(6));
; 715  : 
; 716  : #endif
; 717  : 
; 718  :     /* Only coming here means complete initialisation is over */
; 719  :     Status = NDIS_STATUS_SUCCESS;
; 720  : 
; 721  :     /* Enable Tx & Rx for channel 0 only */
; 722  :     pEmacRegs->RXUNICASTSET = 0x01;

  002d8	e3a01902	 mov         r1, #2, 18

; 723  :     pEmacRegs->TXCONTROL = 0x1;
; 724  :     pEmacRegs->RXCONTROL = 0x1;
; 725  :     pEmacRegs->MACCONTROL |= (EMAC_MACCONTROL_MIIEN_ENABLE | EMAC_MACCONTROL_RMII_SPEED);
; 726  : 
; 727  :     /* Enabling statistics and Host error interrupts */
; 728  :     pEmacRegs->MACINTMASKSET = (BIT(1) | BIT(0));
; 729  : 
; 730  :     /* Start receive process */
; 731  :     pEmacRegs->RX0HDP = (pAdapter->m_pBaseRxBufs->m_EmacBufDesPa);
; 732  : 
; 733  :     /* Enable the interrupt */
; 734  :     //  pAdapter->m_EwrapRegsBase->m_Ewinttcnt = 0xFFFF;
; 735  :     EmacEnableInterrupts(pAdapter);

  002dc	e1a00005	 mov         r0, r5
  002e0	e1823003	 orr         r3, r2, r3
  002e4	e5863084	 str         r3, [r6, #0x84]
  002e8	e5963084	 ldr         r3, [r6, #0x84]
  002ec	e3812020	 orr         r2, r1, #0x20
  002f0	e3a01003	 mov         r1, #3
  002f4	e3833040	 orr         r3, r3, #0x40
  002f8	e5863084	 str         r3, [r6, #0x84]
  002fc	e584a104	 str         r10, [r4, #0x104]
  00300	e584a004	 str         r10, [r4, #4]
  00304	e584a014	 str         r10, [r4, #0x14]
  00308	e5943160	 ldr         r3, [r4, #0x160]
  0030c	e1833002	 orr         r3, r3, r2
  00310	e5843160	 str         r3, [r4, #0x160]
  00314	e58410b8	 str         r1, [r4, #0xB8]
  00318	e5953030	 ldr         r3, [r5, #0x30]
  0031c	e5933014	 ldr         r3, [r3, #0x14]
  00320	e5843620	 str         r3, [r4, #0x620]
  00324	eb000000	 bl          EmacEnableInterrupts

; 736  :     pEmacCtlRegs->INTCONTROL = 0x1;

  00328	e588a00c	 str         r10, [r8, #0xC]

; 737  : 
; 738  : 
; 739  :     /* Here we have enabled broadcast and unicast reception */
; 740  :     pAdapter->m_PacketFilter = (
; 741  :                                 NDIS_PACKET_TYPE_DIRECTED
; 742  :                               );

  0032c	e585a1ac	 str         r10, [r5, #0x1AC]

; 743  :     /* Clearing teardown events */
; 744  :     pAdapter->m_Events = 0x0;

  00330	e585939c	 str         r9, [r5, #0x39C]

; 745  : 
; 746  :     DEBUGMSG(DBG_FUNC, (L"<-- NICInitializeAdapter, Status=%x \r\n", Status));
; 747  : 
; 748  :     return Status;

  00334	e3a00000	 mov         r0, #0

; 749  : }

  00338	e28dd004	 add         sp, sp, #4
  0033c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00340	e12fff1e	 bx          lr
  00344		 |$LN66@NICInitial|
  00344		 |$LN67@NICInitial|
  00344	400c004b	 DCD         0x400c004b
  00348		 |$M50711|

			 ENDP  ; |NICInitializeAdapter|

	END
