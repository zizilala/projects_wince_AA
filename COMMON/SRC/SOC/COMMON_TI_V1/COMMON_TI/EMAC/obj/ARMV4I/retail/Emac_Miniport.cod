; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\EMAC\Emac_Miniport.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|VendorDriverVersion| [ DATA ]
	EXPORT	|NICSupportedOids| [ DATA ]

  00000			 AREA	 |.data|, DATA
|VendorDriverVersion| DCD 0x10000
	%	4
|NICSupportedOids| DCD 0x10101
	DCD	0x10102
	DCD	0x10103
	DCD	0x10104
	DCD	0x10105
	DCD	0x10106
	DCD	0x10107
	DCD	0x10108
	DCD	0x10109
	DCD	0x1010a
	DCD	0x1010b
	DCD	0x1010c
	DCD	0x1010d
	DCD	0x1010e
	DCD	0x1010f
	DCD	0x10110
	DCD	0x10111
	DCD	0x10113
	DCD	0x10114
	DCD	0x10115
	DCD	0x10116
	DCD	0x20101
	DCD	0x20102
	DCD	0x20103
	DCD	0x20104
	DCD	0x20105
	DCD	0x1010101
	DCD	0x1010102
	DCD	0x1010103
	DCD	0x1010104
	DCD	0x1020101
	DCD	0x1020102
	DCD	0x1020103
	DCD	0x1020201
	DCD	0x1020202
	DCD	0x1020203
	DCD	0xfd010100
	DCD	0xfd010102
	DCD	0xfd010101

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
|?VendorDescriptor@?1??Emac_MiniportQueryInformation@@9@9| DCB "TI- EMAC "
	DCB	"ADAPTER", 0x0				; `Emac_MiniportQueryInformation'::`2'::VendorDescriptor
	EXPORT	|Emac_MiniportHalt|
	IMPORT	|EmacFreeAdapter|
	IMPORT	|Emac_MiniportDisableInterrupt|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\emac\emac_miniport.c

  00000			 AREA	 |.pdata|, PDATA
|$T50629| DCD	|$LN8@Emac_Minip|
	DCD	0x40001201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Emac_MiniportHalt| PROC

; 89   : {

  00000		 |$LN8@Emac_Minip|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M50626|
  00004	e1a04000	 mov         r4, r0

; 90   :     PEMAC_ADAPTER       pAdapter;
; 91   :     
; 92   :     pAdapter = (PEMAC_ADAPTER) MiniportAdapterContext;
; 93   : 
; 94   :     DEBUGMSG(DBG_FUNC, (L"Emac_MiniportHalt \r\n"));
; 95   :     
; 96   :     /* Tear down receive and transmit channels so that Rx/Tx are completelly
; 97   :      * stopped immediately
; 98   :      */
; 99   :     pAdapter->m_pEmacRegsBase->RXTEARDOWN = 0x0;

  00008	e5943004	 ldr         r3, [r4, #4]
  0000c	e3a02000	 mov         r2, #0
  00010	e5832018	 str         r2, [r3, #0x18]

; 100  :     pAdapter->m_pEmacRegsBase->TXTEARDOWN = 0x0;

  00014	e5943004	 ldr         r3, [r4, #4]
  00018	e5832008	 str         r2, [r3, #8]
  0001c	e594339c	 ldr         r3, [r4, #0x39C]
  00020		 |$LL2@Emac_Minip|

; 101  :      
; 102  :     /* wait for teardowm completion */
; 103  :     while(0 != (pAdapter->m_Events & EMAC_RX_TEARDOWN_EVENT) &&
; 104  :           0 != (pAdapter->m_Events & EMAC_TX_TEARDOWN_EVENT))

  00020	e3130002	 tst         r3, #2
  00024	0a000001	 beq         |$LN1@Emac_Minip|
  00028	e3130001	 tst         r3, #1
  0002c	1afffffb	 bne         |$LL2@Emac_Minip|
  00030		 |$LN1@Emac_Minip|

; 105  :     {
; 106  :        ;
; 107  :     }
; 108  :     /*
; 109  :      * Disable the interrupts in the card, so that the interrupt routine would
; 110  :      * not be called.
; 111  :      */
; 112  :     Emac_MiniportDisableInterrupt(pAdapter);

  00030	e1a00004	 mov         r0, r4
  00034	eb000000	 bl          Emac_MiniportDisableInterrupt

; 113  : 
; 114  :     /* Free allocated memory and resources held */
; 115  :     EmacFreeAdapter(pAdapter);

  00038	e1a00004	 mov         r0, r4
  0003c	eb000000	 bl          EmacFreeAdapter

; 116  :     
; 117  :     return;
; 118  : }

  00040	e8bd4010	 ldmia       sp!, {r4, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$M50627|

			 ENDP  ; |Emac_MiniportHalt|

	EXPORT	|EmacUpdateStatistics|

  00000			 AREA	 |.pdata|, PDATA
|$T50638| DCD	|$LN5@EmacUpdate|
	DCD	0x40004101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |EmacUpdateStatistics| PROC

; 131  : {

  00000		 |$LN5@EmacUpdate|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M50635|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 132  :     /* Updating software statistics information from Network statistics registers
; 133  :      * from EMAC
; 134  :      */
; 135  :     EmacStatInfo->m_TxOKFrames          += EmacRegs->TXGOODFRAMES;

  0000c	e5942234	 ldr         r2, [r4, #0x234]
  00010	e5953000	 ldr         r3, [r5]

; 136  :     
; 137  :     EmacStatInfo->m_RxOKFrames          += EmacRegs->RXGOODFRAMES;

  00014	e595e004	 ldr         lr, [r5, #4]

; 138  :     
; 139  :     EmacStatInfo->m_TxErrorframes       += (
; 140  :                                             EmacRegs->TXEXCESSIVECOLL +
; 141  :                                             EmacRegs->TXLATECOLL +
; 142  :                                             EmacRegs->TXCARRIERSENSE
; 143  :                                             ); 
; 144  :     
; 145  :     EmacStatInfo->m_RxErrorframes       += (
; 146  :                                             EmacRegs->RXCRCERRORS +
; 147  :                                             EmacRegs->RXALIGNCODEERRORS +
; 148  :                                             EmacRegs->RXOVERSIZED +
; 149  :                                             EmacRegs->RXJABBER +
; 150  :                                             EmacRegs->RXUNDERSIZED
; 151  :                                             ); 
; 152  :     
; 153  :     EmacStatInfo->m_RxNoBufFrames       += EmacRegs->RXDMAOVERRUNS; //needtocheck
; 154  :     
; 155  :     EmacStatInfo->m_RxAlignErrorFrames  += EmacRegs->RXALIGNCODEERRORS;
; 156  :     
; 157  :     EmacStatInfo->m_TxOneColl           += EmacRegs->TXSINGLECOLL;
; 158  :     
; 159  :     EmacStatInfo->m_TxMoreColl          += EmacRegs->TXMULTICOLL;
; 160  :     
; 161  :     EmacStatInfo->m_TxDeferred          += EmacRegs->TXDEFERRED;
; 162  :     
; 163  :     EmacStatInfo->m_TxMaxColl           += EmacRegs->TXEXCESSIVECOLL;
; 164  :     
; 165  :     EmacStatInfo->m_RxOverRun           += (
; 166  :                                              EmacRegs->RXSOFOVERRUNS +
; 167  :                                              EmacRegs->RXMOFOVERRUNS +
; 168  :                                              EmacRegs->RXDMAOVERRUNS 
; 169  :                                            );

  00018	e5950028	 ldr         r0, [r5, #0x28]
  0001c	e0823003	 add         r3, r2, r3
  00020	e5853000	 str         r3, [r5]
  00024	e5943200	 ldr         r3, [r4, #0x200]
  00028	e083300e	 add         r3, r3, lr
  0002c	e5853004	 str         r3, [r5, #4]
  00030	e594e260	 ldr         lr, [r4, #0x260]
  00034	e5943258	 ldr         r3, [r4, #0x258]
  00038	e5942254	 ldr         r2, [r4, #0x254]
  0003c	e08e3003	 add         r3, lr, r3
  00040	e595e008	 ldr         lr, [r5, #8]
  00044	e0833002	 add         r3, r3, r2
  00048	e083300e	 add         r3, r3, lr
  0004c	e5853008	 str         r3, [r5, #8]
  00050	e5941220	 ldr         r1, [r4, #0x220]
  00054	e594321c	 ldr         r3, [r4, #0x21C]
  00058	e5942218	 ldr         r2, [r4, #0x218]
  0005c	e595e024	 ldr         lr, [r5, #0x24]
  00060	e0813003	 add         r3, r1, r3
  00064	e5941210	 ldr         r1, [r4, #0x210]
  00068	e0833002	 add         r3, r3, r2
  0006c	e5942214	 ldr         r2, [r4, #0x214]
  00070	e0833001	 add         r3, r3, r1
  00074	e595100c	 ldr         r1, [r5, #0xC]
  00078	e0833002	 add         r3, r3, r2
  0007c	e0833001	 add         r3, r3, r1
  00080	e585300c	 str         r3, [r5, #0xC]
  00084	e594228c	 ldr         r2, [r4, #0x28C]
  00088	e5953010	 ldr         r3, [r5, #0x10]
  0008c	e5951014	 ldr         r1, [r5, #0x14]
  00090	e0823003	 add         r3, r2, r3
  00094	e5853010	 str         r3, [r5, #0x10]
  00098	e5943214	 ldr         r3, [r4, #0x214]
  0009c	e5952018	 ldr         r2, [r5, #0x18]
  000a0	e0833001	 add         r3, r3, r1
  000a4	e5853014	 str         r3, [r5, #0x14]
  000a8	e594324c	 ldr         r3, [r4, #0x24C]
  000ac	e595101c	 ldr         r1, [r5, #0x1C]
  000b0	e0833002	 add         r3, r3, r2
  000b4	e5853018	 str         r3, [r5, #0x18]
  000b8	e5943250	 ldr         r3, [r4, #0x250]
  000bc	e5952020	 ldr         r2, [r5, #0x20]
  000c0	e0833001	 add         r3, r3, r1
  000c4	e585301c	 str         r3, [r5, #0x1C]
  000c8	e5943244	 ldr         r3, [r4, #0x244]
  000cc	e0833002	 add         r3, r3, r2
  000d0	e5853020	 str         r3, [r5, #0x20]
  000d4	e5943254	 ldr         r3, [r4, #0x254]
  000d8	e083300e	 add         r3, r3, lr
  000dc	e5853024	 str         r3, [r5, #0x24]
  000e0	e5941288	 ldr         r1, [r4, #0x288]
  000e4	e5943284	 ldr         r3, [r4, #0x284]
  000e8	e594228c	 ldr         r2, [r4, #0x28C]
  000ec	e0813003	 add         r3, r1, r3
  000f0	e0833002	 add         r3, r3, r2
  000f4	e0833000	 add         r3, r3, r0
  000f8	e5853028	 str         r3, [r5, #0x28]

; 170  :     
; 171  :     
; 172  :     
; 173  : }    

  000fc	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00100	e12fff1e	 bx          lr
  00104		 |$M50636|

			 ENDP  ; |EmacUpdateStatistics|

	EXPORT	|Emac_MiniportQueryInformation|
	IMPORT	|ReadPhyRegister|
	IMPORT	|memcpy|

  00000			 AREA	 |.pdata|, PDATA
|$T50690| DCD	|$LN90@Emac_Minip@2|
	DCD	0x40011d02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Emac_MiniportQueryInformation| PROC

; 209  : {

  00000		 |$LN90@Emac_Minip@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd01c	 sub         sp, sp, #0x1C
  00008		 |$M50687|
  00008	e1a0b003	 mov         r11, r3
  0000c	e1a0a002	 mov         r10, r2
  00010	e1a05001	 mov         r5, r1
  00014	e1a04000	 mov         r4, r0

; 210  :     NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;
; 211  :     NDIS_MEDIUM                 Medium = NIC_MEDIA_TYPE;
; 212  :     UCHAR                       VendorId[4];
; 213  :     static const UCHAR          VendorDescriptor[] = "TI- EMAC ADAPTER";
; 214  :     ULONG                       TempRegVal;
; 215  :     ULONG                       ulInfo = 0;
; 216  :     PVOID                       pInfo = (PVOID) &ulInfo;
; 217  :     ULONG                       ulInfoLen = sizeof(ulInfo);
; 218  :     ULONG                       ulBytesAvailable = ulInfoLen;
; 219  :     PEMAC_ADAPTER               pAdapter;
; 220  :     PEMAC_STATINFO              pEmacStatInfo;
; 221  :     NDIS_PNP_CAPABILITIES       Capabilites;
; 222  :     NDIS_DEVICE_POWER_STATE     PowerState;
; 223  :     
; 224  :     pAdapter = (PEMAC_ADAPTER) MiniportAdapterContext;
; 225  :     
; 226  :     DEBUGMSG(DBG_FUNC && DBG_OID, 
; 227  :             (L"---> Emac_MiniportQueryInformation 0x%08X \r\n",Oid));
; 228  :    
; 229  :     //
; 230  :     // Process different type of requests
; 231  :     //
; 232  :     switch(Oid)

  00018	e59fe450	 ldr         lr, [pc, #0x450]
  0001c	e3a03000	 mov         r3, #0
  00020	e3a02000	 mov         r2, #0
  00024	e155000e	 cmp         r5, lr
  00028	e3a09000	 mov         r9, #0
  0002c	e58d3008	 str         r3, [sp, #8]
  00030	e58d2000	 str         r2, [sp]
  00034	e28d8000	 add         r8, sp, #0
  00038	e3a06004	 mov         r6, #4
  0003c	e3a07004	 mov         r7, #4
  00040	8a000069	 bhi         |$LN59@Emac_Minip@2|
  00044	e59fe420	 ldr         lr, [pc, #0x420]
  00048	e155000e	 cmp         r5, lr
  0004c	2a000062	 bcs         |$LN31@Emac_Minip@2|
  00050	e59fe410	 ldr         lr, [pc, #0x410]
  00054	e045100e	 sub         r1, r5, lr
  00058	e3510015	 cmp         r1, #0x15
  0005c	8a00006e	 bhi         |$LN19@Emac_Minip@2|
  00060	e1a03081	 mov         r3, r1, lsl #1
  00064	e083300f	 add         r3, r3, pc
  00068	e1d330b4	 ldrh        r3, [r3, #4]
  0006c	e08ff003	 add         pc, pc, r3
  00070		 |$LN65@Emac_Minip@2|
  00070		 |$LN64@Emac_Minip@2|
  00070		 |$LN66@Emac_Minip@2|
  00070	0028		 DCW         0x28
  00072		 |$LN67@Emac_Minip@2|
  00072	003c		 DCW         0x3c
  00074		 |$LN68@Emac_Minip@2|
  00074	004c		 DCW         0x4c
  00076		 |$LN69@Emac_Minip@2|
  00076	004c		 DCW         0x4c
  00078		 |$LN70@Emac_Minip@2|
  00078	0064		 DCW         0x64
  0007a		 |$LN71@Emac_Minip@2|
  0007a	0064		 DCW         0x64
  0007c		 |$LN72@Emac_Minip@2|
  0007c	0118		 DCW         0x118
  0007e		 |$LN73@Emac_Minip@2|
  0007e	0074		 DCW         0x74
  00080		 |$LN74@Emac_Minip@2|
  00080	008c		 DCW         0x8c
  00082		 |$LN75@Emac_Minip@2|
  00082	0054		 DCW         0x54
  00084		 |$LN76@Emac_Minip@2|
  00084	0054		 DCW         0x54
  00086		 |$LN77@Emac_Minip@2|
  00086	00ac		 DCW         0xac
  00088		 |$LN78@Emac_Minip@2|
  00088	00cc		 DCW         0xcc
  0008a		 |$LN79@Emac_Minip@2|
  0008a	015c		 DCW         0x15c
  0008c		 |$LN80@Emac_Minip@2|
  0008c	0064		 DCW         0x64
  0008e		 |$LN81@Emac_Minip@2|
  0008e	00ec		 DCW         0xec
  00090		 |$LN82@Emac_Minip@2|
  00090	0054		 DCW         0x54
  00092		 |$LN83@Emac_Minip@2|
  00092	01a8		 DCW         0x1a8
  00094		 |$LN84@Emac_Minip@2|
  00094	00a0		 DCW         0xa0
  00096		 |$LN85@Emac_Minip@2|
  00096	00f8		 DCW         0xf8
  00098		 |$LN86@Emac_Minip@2|
  00098	0094		 DCW         0x94
  0009a		 |$LN87@Emac_Minip@2|
  0009a	00dc		 DCW         0xdc
  0009c		 |$LN53@Emac_Minip@2|

; 233  :     {
; 234  :         case OID_GEN_SUPPORTED_LIST:
; 235  :             pInfo = (PVOID) NICSupportedOids;

  0009c	e59f33bc	 ldr         r3, [pc, #0x3BC]

; 236  :             ulBytesAvailable = ulInfoLen = sizeof(NICSupportedOids);

  000a0	e3a0609c	 mov         r6, #0x9C
  000a4	e3a0709c	 mov         r7, #0x9C
  000a8	e2838008	 add         r8, r3, #8

; 237  :             break;

  000ac	ea0000c9	 b           |$LN17@Emac_Minip@2|
  000b0		 |$LN52@Emac_Minip@2|

; 238  :         
; 239  :         case OID_GEN_HARDWARE_STATUS:
; 240  :             pInfo = (PVOID) &pAdapter->m_HwStatus;

  000b0	e2848e1a	 add         r8, r4, #0x1A, 28
  000b4		 |$LN61@Emac_Minip@2|

; 241  :             ulBytesAvailable = ulInfoLen = sizeof(NDIS_HARDWARE_STATUS);

  000b4	e3a06004	 mov         r6, #4
  000b8	e3a07004	 mov         r7, #4

; 242  :             break;     

  000bc	ea0000c5	 b           |$LN17@Emac_Minip@2|
  000c0		 |$LN51@Emac_Minip@2|

; 243  :            
; 244  :         case OID_GEN_MEDIA_SUPPORTED:
; 245  :         case OID_GEN_MEDIA_IN_USE:
; 246  :             pInfo = (PVOID) &Medium;

  000c0	e28d8008	 add         r8, sp, #8

; 247  :             ulBytesAvailable = ulInfoLen = sizeof(NDIS_MEDIUM);
; 248  :             break;

  000c4	eafffffa	 b           |$LN61@Emac_Minip@2|
  000c8		 |$LN50@Emac_Minip@2|
  000c8	e3a03c05	 mov         r3, #5, 24

; 249  :             
; 250  :         case OID_GEN_MAXIMUM_TOTAL_SIZE:
; 251  :         case OID_GEN_TRANSMIT_BLOCK_SIZE:
; 252  :         case OID_GEN_RECEIVE_BLOCK_SIZE:
; 253  :             ulInfo = (ULONG) EMAC_MAX_ETHERNET_PKT_SIZE;

  000cc	e38330ea	 orr         r3, r3, #0xEA
  000d0	e58d3000	 str         r3, [sp]

; 254  :             break;

  000d4	ea0000bf	 b           |$LN17@Emac_Minip@2|
  000d8		 |$LN49@Emac_Minip@2|
  000d8	e3a03c05	 mov         r3, #5, 24

; 255  :         
; 256  :         case OID_GEN_MAXIMUM_LOOKAHEAD:
; 257  :         case OID_GEN_CURRENT_LOOKAHEAD:
; 258  :         case OID_GEN_MAXIMUM_FRAME_SIZE:
; 259  :             ulInfo = EMAC_MAX_ETHERNET_PKT_SIZE - EMAC_HEADER_SIZE;;

  000dc	e38330dc	 orr         r3, r3, #0xDC
  000e0	e58d3000	 str         r3, [sp]
  000e4	ea0000bb	 b           |$LN17@Emac_Minip@2|
  000e8		 |$LN48@Emac_Minip@2|

; 260  :             break;
; 261  :              
; 262  :        case OID_GEN_TRANSMIT_BUFFER_SPACE:
; 263  :             ulInfo = (ULONG) EMAC_MAX_ETHERNET_PKT_SIZE * pAdapter->m_MaxTxEmacBufs;

  000e8	e1d422ba	 ldrh        r2, [r4, #0x2A]
  000ec		 |$LN63@Emac_Minip@2|
  000ec	e3a03c05	 mov         r3, #5, 24
  000f0	e38330ea	 orr         r3, r3, #0xEA
  000f4	e0030392	 mul         r3, r2, r3
  000f8	e58d3000	 str         r3, [sp]
  000fc	ea0000b5	 b           |$LN17@Emac_Minip@2|
  00100		 |$LN47@Emac_Minip@2|

; 264  :             break;
; 265  : 
; 266  :         case OID_GEN_RECEIVE_BUFFER_SPACE:
; 267  :             ulInfo = (ULONG) EMAC_MAX_ETHERNET_PKT_SIZE * pAdapter->m_NumRxIndicatePkts;

  00100	e1d422b4	 ldrh        r2, [r4, #0x24]

; 268  :             break;

  00104	eafffff8	 b           |$LN63@Emac_Minip@2|
  00108		 |$LN46@Emac_Minip@2|

; 269  :             
; 270  :         case OID_GEN_MAXIMUM_SEND_PACKETS:
; 271  :             ulInfo = MAX_NUM_PACKETS_PER_SEND;

  00108	e3a03c01	 mov         r3, #1, 24
  0010c	e58d3000	 str         r3, [sp]
  00110	ea0000b0	 b           |$LN17@Emac_Minip@2|
  00114		 |$LN45@Emac_Minip@2|

; 272  :             break;
; 273  :             
; 274  :         case OID_GEN_MAC_OPTIONS:
; 275  :             // Notes: 
; 276  :             // The protocol driver is free to access indicated data by any means. 
; 277  :             // Some fast-copy functions have trouble accessing on-board device 
; 278  :             // memory. NIC drivers that indicate data out of mapped device memory 
; 279  :             // should never set this flag. If a NIC driver does set this flag, it 
; 280  :             // relaxes the restriction on fast-copy functions. 
; 281  : 
; 282  :             // This miniport indicates receive with NdisMIndicateReceivePacket 
; 283  :             // function. It has no MiniportTransferData function. Such a driver 
; 284  :             // should set this flag. 
; 285  : 
; 286  :             ulInfo = (
; 287  :                       NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA | 
; 288  :                       NDIS_MAC_OPTION_TRANSFERS_NOT_PEND  |
; 289  :                       NDIS_MAC_OPTION_NO_LOOPBACK 
; 290  :                      );

  00114	e3a0300d	 mov         r3, #0xD
  00118	e58d3000	 str         r3, [sp]
  0011c	ea0000ad	 b           |$LN17@Emac_Minip@2|
  00120		 |$LN44@Emac_Minip@2|

; 291  : #if 0
; 292  :             ulInfo |= NDIS_MAC_OPTION_FULL_DUPLEX    
; 293  : #endif
; 294  :             break;     
; 295  :         
; 296  :         case OID_GEN_VENDOR_ID:
; 297  :             /* A 3-byte IEEE vendor code, followed by a single byte the vendor
; 298  :              * assigns to identify a particular vendor-supplied network
; 299  :              * interface card driver. The IEEE code uniquely identifies the
; 300  :              * vendor and is the same as the three bytes appearing at the
; 301  :              * beginning of the NIC hardware address. 
; 302  :              */ 
; 303  :             NdisMoveMemory(VendorId, pAdapter->m_MACAddress, 3);

  00120	e1d431b4	 ldrh        r3, [r4, #0x14]
  00124	e5d42016	 ldrb        r2, [r4, #0x16]

; 304  :             VendorId[3] = 0x0;

  00128	e3a01000	 mov         r1, #0
  0012c	e1cd30b4	 strh        r3, [sp, #4]
  00130	e5cd2006	 strb        r2, [sp, #6]
  00134	e5cd1007	 strb        r1, [sp, #7]

; 305  :             pInfo = VendorId;

  00138	e28d8004	 add         r8, sp, #4

; 306  :             ulBytesAvailable = ulInfoLen = sizeof(VendorId);
; 307  :             break; 

  0013c	eaffffdc	 b           |$LN61@Emac_Minip@2|
  00140		 |$LN43@Emac_Minip@2|

; 308  :                    
; 309  :         case OID_GEN_VENDOR_DESCRIPTION:
; 310  : 
; 311  :             pInfo = (PVOID) &VendorDescriptor;

  00140	e59f831c	 ldr         r8, [pc, #0x31C]

; 312  :             ulBytesAvailable = ulInfoLen = sizeof(VendorDescriptor);

  00144	e3a06011	 mov         r6, #0x11
  00148	e3a07011	 mov         r7, #0x11

; 313  :             break;

  0014c	ea0000a1	 b           |$LN17@Emac_Minip@2|
  00150		 |$LN42@Emac_Minip@2|

; 314  :             
; 315  :         case OID_GEN_VENDOR_DRIVER_VERSION:
; 316  :             ulInfo = VendorDriverVersion;

  00150	e59f3308	 ldr         r3, [pc, #0x308]
  00154	e5933000	 ldr         r3, [r3]
  00158	e58d3000	 str         r3, [sp]
  0015c	ea00009d	 b           |$LN17@Emac_Minip@2|
  00160		 |$LN41@Emac_Minip@2|

; 317  :             break;
; 318  :         
; 319  :         case OID_GEN_DRIVER_VERSION:
; 320  : 
; 321  :             ulInfo  =  EMAC_NDIS_DRIVER_VERSION;

  00160	e3a03c05	 mov         r3, #5, 24
  00164	e58d3000	 str         r3, [sp]
  00168	ea00009a	 b           |$LN17@Emac_Minip@2|
  0016c		 |$LN40@Emac_Minip@2|

; 322  :             break;
; 323  :                 
; 324  :         case OID_GEN_MEDIA_CONNECT_STATUS:
; 325  :             
; 326  :             
; 327  :             if(UP == pAdapter->m_LinkStatus)

  0016c	e59431a4	 ldr         r3, [r4, #0x1A4]
  00170	e3530000	 cmp         r3, #0

; 328  :             {
; 329  :                 ulInfo = NdisMediaStateConnected;

  00174	03a03000	 moveq       r3, #0
  00178	058d3000	 streq       r3, [sp]
  0017c	0a000095	 beq         |$LN17@Emac_Minip@2|

; 330  :             }
; 331  :             else 
; 332  :             {
; 333  :                 ulInfo  = NdisMediaStateDisconnected; 

  00180	e3a03001	 mov         r3, #1
  00184	e58d3000	 str         r3, [sp]
  00188	ea000092	 b           |$LN17@Emac_Minip@2|
  0018c		 |$LN37@Emac_Minip@2|

; 334  :             }
; 335  :             DEBUGMSG (DBG_OID , (L"OID_GEN_MEDIA_CONNECT_STATUS is called %u \r\n",ulInfo));
; 336  :             break;
; 337  :        
; 338  :         case OID_GEN_LINK_SPEED:
; 339  :             
; 340  :             TempRegVal = ReadPhyRegister(pAdapter->m_ActivePhy, MII_CONTROL_REG);

  0018c	e59401a8	 ldr         r0, [r4, #0x1A8]
  00190	e3a01000	 mov         r1, #0
  00194	eb000000	 bl          ReadPhyRegister

; 341  :             if((0 == (TempRegVal & BIT(6))) && (0 == (TempRegVal & BIT(13))))

  00198	e2103040	 ands        r3, r0, #0x40
  0019c	03100a02	 tsteq       r0, #2, 20
  001a0	03a03b61	 moveq       r3, #0x61, 22

; 342  :             {
; 343  :                 ulInfo = 100000;

  001a4	03833e2a	 orreq       r3, r3, #0x2A, 28
  001a8	058d3000	 streq       r3, [sp]
  001ac	0a000089	 beq         |$LN17@Emac_Minip@2|

; 344  :             }
; 345  :             else if((0 == (TempRegVal & BIT(6))) && (0 != (TempRegVal & BIT(13))))

  001b0	e3530000	 cmp         r3, #0
  001b4	1a000087	 bne         |$LN17@Emac_Minip@2|
  001b8	e3100a02	 tst         r0, #2, 20
  001bc	0a000085	 beq         |$LN17@Emac_Minip@2|
  001c0	e3a0393d	 mov         r3, #0x3D, 18

; 346  :             {
; 347  :                 ulInfo = 1000000;

  001c4	e3833d09	 orr         r3, r3, #9, 26
  001c8	e58d3000	 str         r3, [sp]
  001cc	ea000081	 b           |$LN17@Emac_Minip@2|
  001d0		 |$LN32@Emac_Minip@2|

; 348  :             }
; 349  :             else
; 350  :             {
; 351  :                 DEBUGMSG(DBG_WARN,(L"WARN: Link is Down!!!!\r\n"));
; 352  :             }
; 353  : 
; 354  :             DEBUGMSG (DBG_OID, (L"OID_GEN_LINK_SPEED is called %u\r\n",ulInfo));
; 355  :             break;
; 356  :         
; 357  :         case OID_GEN_CURRENT_PACKET_FILTER:
; 358  :             ulInfo = pAdapter->m_PacketFilter;

  001d0	e59431ac	 ldr         r3, [r4, #0x1AC]
  001d4	e58d3000	 str         r3, [sp]
  001d8	ea00007e	 b           |$LN17@Emac_Minip@2|
  001dc		 |$LN31@Emac_Minip@2|

; 359  :             break;               
; 360  :             
; 361  :         case OID_802_3_PERMANENT_ADDRESS:
; 362  :         case OID_802_3_CURRENT_ADDRESS:
; 363  :             pInfo = pAdapter->m_MACAddress;

  001dc	e2848014	 add         r8, r4, #0x14

; 364  :             DEBUGMSG (DBG_OID, (L"Mac addr is %x:%x:%x:%x:%x:%x.\r\n",
; 365  :             pAdapter->m_MACAddress[0],pAdapter->m_MACAddress[1],pAdapter->m_MACAddress[2],
; 366  :             pAdapter->m_MACAddress[3],pAdapter->m_MACAddress[4],pAdapter->m_MACAddress[5]));
; 367  :             ulBytesAvailable = ulInfoLen = ETH_LENGTH_OF_ADDRESS;

  001e0	e3a06006	 mov         r6, #6
  001e4	e3a07006	 mov         r7, #6

; 368  :             break;

  001e8	ea00007a	 b           |$LN17@Emac_Minip@2|
  001ec		 |$LN59@Emac_Minip@2|

; 210  :     NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;
; 211  :     NDIS_MEDIUM                 Medium = NIC_MEDIA_TYPE;
; 212  :     UCHAR                       VendorId[4];
; 213  :     static const UCHAR          VendorDescriptor[] = "TI- EMAC ADAPTER";
; 214  :     ULONG                       TempRegVal;
; 215  :     ULONG                       ulInfo = 0;
; 216  :     PVOID                       pInfo = (PVOID) &ulInfo;
; 217  :     ULONG                       ulInfoLen = sizeof(ulInfo);
; 218  :     ULONG                       ulBytesAvailable = ulInfoLen;
; 219  :     PEMAC_ADAPTER               pAdapter;
; 220  :     PEMAC_STATINFO              pEmacStatInfo;
; 221  :     NDIS_PNP_CAPABILITIES       Capabilites;
; 222  :     NDIS_DEVICE_POWER_STATE     PowerState;
; 223  :     
; 224  :     pAdapter = (PEMAC_ADAPTER) MiniportAdapterContext;
; 225  :     
; 226  :     DEBUGMSG(DBG_FUNC && DBG_OID, 
; 227  :             (L"---> Emac_MiniportQueryInformation 0x%08X \r\n",Oid));
; 228  :    
; 229  :     //
; 230  :     // Process different type of requests
; 231  :     //
; 232  :     switch(Oid)

  001ec	e59f3268	 ldr         r3, [pc, #0x268]
  001f0	e1550003	 cmp         r5, r3
  001f4	0a000072	 beq         |$LN29@Emac_Minip@2|
  001f8	e59f3258	 ldr         r3, [pc, #0x258]
  001fc	e1550003	 cmp         r5, r3
  00200	0a00006c	 beq         |$LN30@Emac_Minip@2|
  00204	e59f3248	 ldr         r3, [pc, #0x248]
  00208	e1550003	 cmp         r5, r3
  0020c	0a000060	 beq         |$LN28@Emac_Minip@2|
  00210	e59f3238	 ldr         r3, [pc, #0x238]
  00214	e1550003	 cmp         r5, r3
  00218	0a000049	 beq         |$LN27@Emac_Minip@2|
  0021c		 |$LN19@Emac_Minip@2|

; 413  : 
; 414  :          default:
; 415  :                 /*
; 416  :                  * This is a query for statistics information from the NDIS
; 417  :                  * wrapper. Let us call EmacStatistics and retrieve the latest set
; 418  :                  * of statistical information retrieved by the EMAC.
; 419  :                  */
; 420  :                  pEmacStatInfo = &pAdapter->m_EmacStatInfo;
; 421  :                  
; 422  :                  EmacUpdateStatistics(pEmacStatInfo , pAdapter->m_pEmacRegsBase);

  0021c	e5941004	 ldr         r1, [r4, #4]
  00220	e2840e37	 add         r0, r4, #0x37, 28
  00224	eb000000	 bl          EmacUpdateStatistics

; 423  : 
; 424  :                 switch (Oid)

  00228	e59f321c	 ldr         r3, [pc, #0x21C]
  0022c	e1550003	 cmp         r5, r3
  00230	8a000022	 bhi         |$LN58@Emac_Minip@2|
  00234	0a00001e	 beq         |$LN11@Emac_Minip@2|
  00238	e59f3208	 ldr         r3, [pc, #0x208]
  0023c	e1550003	 cmp         r5, r3
  00240	0a000018	 beq         |$LN16@Emac_Minip@2|
  00244	e59f31f8	 ldr         r3, [pc, #0x1F8]
  00248	e1550003	 cmp         r5, r3
  0024c	0a000012	 beq         |$LN15@Emac_Minip@2|
  00250	e59f31e8	 ldr         r3, [pc, #0x1E8]
  00254	e1550003	 cmp         r5, r3
  00258	0a00000c	 beq         |$LN14@Emac_Minip@2|
  0025c	e3a03802	 mov         r3, #2, 16
  00260	e3833f41	 orr         r3, r3, #0x41, 30
  00264	e1550003	 cmp         r5, r3
  00268	0a000005	 beq         |$LN13@Emac_Minip@2|
  0026c	e59f31c8	 ldr         r3, [pc, #0x1C8]
  00270	e1550003	 cmp         r5, r3
  00274	1a000020	 bne         |$LN5@Emac_Minip@2|

; 444  :                         break;
; 445  :     
; 446  :                     case OID_GEN_RCV_NO_BUFFER:
; 447  :                         ulInfo = pEmacStatInfo->m_RxNoBufFrames;

  00278	e5943380	 ldr         r3, [r4, #0x380]
  0027c	e58d3000	 str         r3, [sp]
  00280	ea000054	 b           |$LN17@Emac_Minip@2|
  00284		 |$LN13@Emac_Minip@2|

; 440  :                         break;
; 441  :     
; 442  :                     case OID_GEN_RCV_ERROR:
; 443  :                         ulInfo = pEmacStatInfo->m_RxErrorframes;

  00284	e594337c	 ldr         r3, [r4, #0x37C]
  00288	e58d3000	 str         r3, [sp]
  0028c	ea000051	 b           |$LN17@Emac_Minip@2|
  00290		 |$LN14@Emac_Minip@2|

; 435  :                         break;
; 436  :     
; 437  :                     case OID_GEN_XMIT_ERROR:
; 438  :     
; 439  :                         ulInfo = pEmacStatInfo->m_TxErrorframes;

  00290	e5943378	 ldr         r3, [r4, #0x378]
  00294	e58d3000	 str         r3, [sp]
  00298	ea00004e	 b           |$LN17@Emac_Minip@2|
  0029c		 |$LN15@Emac_Minip@2|

; 430  :                         break;
; 431  :     
; 432  :                     case OID_GEN_RCV_OK:
; 433  :     
; 434  :                         ulInfo = pEmacStatInfo->m_RxOKFrames;

  0029c	e5943374	 ldr         r3, [r4, #0x374]
  002a0	e58d3000	 str         r3, [sp]
  002a4	ea00004b	 b           |$LN17@Emac_Minip@2|
  002a8		 |$LN16@Emac_Minip@2|

; 425  :                 {
; 426  :     
; 427  :                     case OID_GEN_XMIT_OK:
; 428  :     
; 429  :                         ulInfo = pEmacStatInfo->m_TxOKFrames;

  002a8	e5943370	 ldr         r3, [r4, #0x370]
  002ac	e58d3000	 str         r3, [sp]
  002b0	ea000048	 b           |$LN17@Emac_Minip@2|
  002b4		 |$LN11@Emac_Minip@2|

; 448  :                         break;
; 449  :     
; 450  :                   
; 451  :                     case OID_802_3_RCV_ERROR_ALIGNMENT:
; 452  :                         ulInfo = pEmacStatInfo->m_RxAlignErrorFrames;

  002b4	e5943384	 ldr         r3, [r4, #0x384]
  002b8	e58d3000	 str         r3, [sp]
  002bc	ea000045	 b           |$LN17@Emac_Minip@2|
  002c0		 |$LN58@Emac_Minip@2|

; 423  : 
; 424  :                 switch (Oid)

  002c0	e59f3170	 ldr         r3, [pc, #0x170]
  002c4	e1550003	 cmp         r5, r3
  002c8	0a00001a	 beq         |$LN10@Emac_Minip@2|
  002cc	e59f3160	 ldr         r3, [pc, #0x160]
  002d0	e1550003	 cmp         r5, r3
  002d4	0a000014	 beq         |$LN9@Emac_Minip@2|
  002d8	e59f3150	 ldr         r3, [pc, #0x150]
  002dc	e1550003	 cmp         r5, r3
  002e0	0a00000e	 beq         |$LN8@Emac_Minip@2|
  002e4	e59f3140	 ldr         r3, [pc, #0x140]
  002e8	e1550003	 cmp         r5, r3
  002ec	0a000008	 beq         |$LN7@Emac_Minip@2|
  002f0	e59f3130	 ldr         r3, [pc, #0x130]
  002f4	e1550003	 cmp         r5, r3
  002f8	0a000002	 beq         |$LN6@Emac_Minip@2|
  002fc		 |$LN5@Emac_Minip@2|
  002fc	e3a03103	 mov         r3, #3, 2

; 473  :                         break;
; 474  :     
; 475  :                   
; 476  :                     default:
; 477  :                         Status = NDIS_STATUS_NOT_SUPPORTED;

  00300	e38390bb	 orr         r9, r3, #0xBB

; 478  :                         break;

  00304	ea000043	 b           |$LN1@Emac_Minip@2|
  00308		 |$LN6@Emac_Minip@2|

; 469  :                         break;
; 470  :     
; 471  :                     case OID_802_3_RCV_OVERRUN:
; 472  :                         ulInfo = pEmacStatInfo->m_RxOverRun;

  00308	e5943398	 ldr         r3, [r4, #0x398]
  0030c	e58d3000	 str         r3, [sp]
  00310	ea000030	 b           |$LN17@Emac_Minip@2|
  00314		 |$LN7@Emac_Minip@2|

; 465  :                         break;
; 466  :     
; 467  :                     case OID_802_3_XMIT_MAX_COLLISIONS:
; 468  :                         ulInfo = pEmacStatInfo->m_TxMaxColl;

  00314	e5943394	 ldr         r3, [r4, #0x394]
  00318	e58d3000	 str         r3, [sp]
  0031c	ea00002d	 b           |$LN17@Emac_Minip@2|
  00320		 |$LN8@Emac_Minip@2|

; 461  :                         break;
; 462  :     
; 463  :                     case OID_802_3_XMIT_DEFERRED:
; 464  :                         ulInfo = pEmacStatInfo->m_TxDeferred;

  00320	e5943390	 ldr         r3, [r4, #0x390]
  00324	e58d3000	 str         r3, [sp]
  00328	ea00002a	 b           |$LN17@Emac_Minip@2|
  0032c		 |$LN9@Emac_Minip@2|

; 457  :                         break;
; 458  :     
; 459  :                     case OID_802_3_XMIT_MORE_COLLISIONS:
; 460  :                         ulInfo = pEmacStatInfo->m_TxMoreColl;

  0032c	e594338c	 ldr         r3, [r4, #0x38C]
  00330	e58d3000	 str         r3, [sp]
  00334	ea000027	 b           |$LN17@Emac_Minip@2|
  00338		 |$LN10@Emac_Minip@2|

; 453  :                         break;
; 454  :     
; 455  :                     case OID_802_3_XMIT_ONE_COLLISION:
; 456  :                         ulInfo = pEmacStatInfo->m_TxOneColl;

  00338	e5943388	 ldr         r3, [r4, #0x388]
  0033c	e58d3000	 str         r3, [sp]
  00340	ea000024	 b           |$LN17@Emac_Minip@2|
  00344		 |$LN27@Emac_Minip@2|

; 388  : 
; 389  :         case OID_PNP_QUERY_POWER:
; 390  :             DEBUGMSG(1, (TEXT ("Emac_Miniport: QueryInformation: Got OID_PNP_QUERY_POWER\r\n")));
; 391  :             if (!InformationBuffer || InformationBufferLength < sizeof(NDIS_DEVICE_POWER_STATE))

  00344	e35a0000	 cmp         r10, #0
  00348	0a00000e	 beq         |$LN25@Emac_Minip@2|
  0034c	e35b0004	 cmp         r11, #4
  00350	3a00000c	 bcc         |$LN25@Emac_Minip@2|

; 392  :             {
; 393  :                 // Buffer not big enough
; 394  :                 Status = NDIS_STATUS_INVALID_LENGTH;
; 395  :             }
; 396  :             else
; 397  :             {
; 398  :                 NdisMoveMemory((PVOID)&PowerState, InformationBuffer, sizeof(PowerState));

  00354	e5da0000	 ldrb        r0, [r10]
  00358	e5da3001	 ldrb        r3, [r10, #1]
  0035c	e5da2002	 ldrb        r2, [r10, #2]
  00360	e5da1003	 ldrb        r1, [r10, #3]
  00364	e1803403	 orr         r3, r0, r3, lsl #8
  00368	e1833802	 orr         r3, r3, r2, lsl #16
  0036c	e1833c01	 orr         r3, r3, r1, lsl #24

; 399  :                 ulBytesAvailable = 0;
; 400  :                 switch (PowerState)

  00370	e3530001	 cmp         r3, #1
  00374	e3a07000	 mov         r7, #0
  00378	0a000016	 beq         |$LN17@Emac_Minip@2|
  0037c	e3530004	 cmp         r3, #4
  00380	0a000014	 beq         |$LN17@Emac_Minip@2|

; 401  :                 {
; 402  :                 case NdisDeviceStateD0:
; 403  :                 case NdisDeviceStateD3:
; 404  :                     // Supported. Leave error code as success
; 405  :                     break;
; 406  :                 default:
; 407  :                     // Unsupported
; 408  :                     Status = NDIS_STATUS_NOT_SUPPORTED;
; 409  :                     break;

  00384	eaffffdc	 b           |$LN5@Emac_Minip@2|
  00388		 |$LN25@Emac_Minip@2|
  00388	e3a03153	 mov         r3, #0x53, 2
  0038c	e3839801	 orr         r9, r3, #1, 16

; 410  :                 };
; 411  :             }
; 412  :             break;

  00390	ea000020	 b           |$LN1@Emac_Minip@2|
  00394		 |$LN28@Emac_Minip@2|

; 378  :             break;     
; 379  :             
; 380  :         case OID_PNP_CAPABILITIES:
; 381  :             DEBUGMSG(1, (TEXT ("Emac_Miniport: QueryInformation: Got OID_PNP_CAPABILITIES\r\n")));
; 382  :             Capabilites.WakeUpCapabilities.MinMagicPacketWakeUp = 
; 383  :                 Capabilites.WakeUpCapabilities.MinPatternWakeUp =
; 384  :                 Capabilites.WakeUpCapabilities.MinLinkChangeWakeUp = NdisDeviceStateUnspecified;

  00394	e3a03000	 mov         r3, #0
  00398	e3a02000	 mov         r2, #0
  0039c	e3a01000	 mov         r1, #0
  003a0	e58d3018	 str         r3, [sp, #0x18]
  003a4	e58d2014	 str         r2, [sp, #0x14]
  003a8	e58d1010	 str         r1, [sp, #0x10]

; 385  :             pInfo = &Capabilites;

  003ac	e28d800c	 add         r8, sp, #0xC

; 386  :             ulBytesAvailable = sizeof(Capabilites);

  003b0	e3a07010	 mov         r7, #0x10

; 387  :             break;

  003b4	ea000007	 b           |$LN17@Emac_Minip@2|
  003b8		 |$LN30@Emac_Minip@2|

; 369  : 
; 370  :         case OID_802_3_MAXIMUM_LIST_SIZE:
; 371  :             ulInfo = EMAC_MAX_MCAST_ENTRIES;

  003b8	e3a03040	 mov         r3, #0x40
  003bc	e58d3000	 str         r3, [sp]
  003c0	ea000004	 b           |$LN17@Emac_Minip@2|
  003c4		 |$LN29@Emac_Minip@2|

; 372  :             break;
; 373  :             
; 374  :         case OID_802_3_MULTICAST_LIST:
; 375  :              pInfo = pAdapter->m_MulticastTable;
; 376  :              ulBytesAvailable = ulInfoLen = pAdapter->m_NumMulticastEntries *
; 377  :                                                      ETH_LENGTH_OF_ADDRESS;   

  003c4	e594336c	 ldr         r3, [r4, #0x36C]
  003c8	e2848f7b	 add         r8, r4, #0x7B, 30
  003cc	e0833083	 add         r3, r3, r3, lsl #1
  003d0	e1a06083	 mov         r6, r3, lsl #1
  003d4	e1a07006	 mov         r7, r6
  003d8		 |$LN17@Emac_Minip@2|

; 479  :                 }
; 480  :     }
; 481  : 
; 482  :    if (Status == NDIS_STATUS_SUCCESS)
; 483  :     {
; 484  :         *BytesNeeded = ulBytesAvailable;

  003d8	e59d3044	 ldr         r3, [sp, #0x44]

; 485  :         if (ulInfoLen <= InformationBufferLength)

  003dc	e156000b	 cmp         r6, r11
  003e0	e5837000	 str         r7, [r3]
  003e4	8a000008	 bhi         |$LN3@Emac_Minip@2|

; 486  :         {
; 487  :             //
; 488  :             // Copy result into InformationBuffer
; 489  :             //
; 490  :             *BytesWritten = ulInfoLen;

  003e8	e59d3040	 ldr         r3, [sp, #0x40]

; 491  :             if (ulInfoLen)

  003ec	e3560000	 cmp         r6, #0
  003f0	e5836000	 str         r6, [r3]
  003f4	0a000007	 beq         |$LN1@Emac_Minip@2|

; 492  :             {
; 493  :                 NdisMoveMemory(InformationBuffer, pInfo, ulInfoLen);

  003f8	e1a02006	 mov         r2, r6
  003fc	e1a01008	 mov         r1, r8
  00400	e1a0000a	 mov         r0, r10
  00404	eb000000	 bl          memcpy

; 494  :             }
; 495  :         }
; 496  :         else

  00408	ea000002	 b           |$LN1@Emac_Minip@2|
  0040c		 |$LN3@Emac_Minip@2|
  0040c	e3a02153	 mov         r2, #0x53, 2

; 497  :         {
; 498  :             //
; 499  :             // too short
; 500  :             //
; 501  :             *BytesNeeded = ulInfoLen;
; 502  :             Status = NDIS_STATUS_INVALID_LENGTH;

  00410	e3829801	 orr         r9, r2, #1, 16
  00414	e5836000	 str         r6, [r3]
  00418		 |$LN1@Emac_Minip@2|

; 503  :         }
; 504  :     }
; 505  : 
; 506  :     DEBUGMSG(DBG_FUNC && DBG_OID, 
; 507  :             (L"<--- Emac_MiniportQueryInformation status 0x%08X \r\n",Status));
; 508  :  
; 509  :     return(Status);
; 510  : }

  00418	e1a00009	 mov         r0, r9
  0041c	e28dd01c	 add         sp, sp, #0x1C
  00420	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00424	e12fff1e	 bx          lr
  00428		 |$LN91@Emac_Minip@2|
  00428		 |$LN92@Emac_Minip@2|
  00428	01020203	 DCD         0x1020203
  0042c		 |$LN93@Emac_Minip@2|
  0042c	01020202	 DCD         0x1020202
  00430		 |$LN94@Emac_Minip@2|
  00430	01020201	 DCD         0x1020201
  00434		 |$LN95@Emac_Minip@2|
  00434	01020103	 DCD         0x1020103
  00438		 |$LN96@Emac_Minip@2|
  00438	01020102	 DCD         0x1020102
  0043c		 |$LN97@Emac_Minip@2|
  0043c	00020105	 DCD         0x20105
  00440		 |$LN98@Emac_Minip@2|
  00440	00020103	 DCD         0x20103
  00444		 |$LN99@Emac_Minip@2|
  00444	00020102	 DCD         0x20102
  00448		 |$LN100@Emac_Minip@2|
  00448	00020101	 DCD         0x20101
  0044c		 |$LN101@Emac_Minip@2|
  0044c	01020101	 DCD         0x1020101
  00450		 |$LN102@Emac_Minip@2|
  00450	fd010102	 DCD         0xfd010102
  00454		 |$LN103@Emac_Minip@2|
  00454	fd010100	 DCD         0xfd010100
  00458		 |$LN104@Emac_Minip@2|
  00458	01010104	 DCD         0x1010104
  0045c		 |$LN105@Emac_Minip@2|
  0045c	01010103	 DCD         0x1010103
  00460		 |$LN106@Emac_Minip@2|
  00460	00000000	 DCD         |VendorDriverVersion|
  00464		 |$LN107@Emac_Minip@2|
  00464	00000000	 DCD         |?VendorDescriptor@?1??Emac_MiniportQueryInformation@@9@9|
  00468		 |$LN108@Emac_Minip@2|
  00468	00010101	 DCD         0x10101
  0046c		 |$LN109@Emac_Minip@2|
  0046c	01010101	 DCD         0x1010101
  00470		 |$LN110@Emac_Minip@2|
  00470	01010102	 DCD         0x1010102
  00474		 |$M50688|

			 ENDP  ; |Emac_MiniportQueryInformation|

	EXPORT	|CopyPacketToBuffer|

  00000			 AREA	 |.pdata|, PDATA
|$T50750| DCD	|$LN38@CopyPacket|
	DCD	0x40002501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |CopyPacketToBuffer| PROC

; 602  : {

  00000		 |$LN38@CopyPacket|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M50747|
  00004	e1b07003	 movs        r7, r3
  00008	e1a09002	 mov         r9, r2
  0000c	e1a05001	 mov         r5, r1

; 603  :     PNDIS_BUFFER        CurrBuffer;
; 604  :     PUCHAR              BufferVirtAddr;
; 605  :     ULONG               BufferLen;
; 606  :     ULONG               BytesOnThisCopy;
; 607  :     PUCHAR              DestAddr;
; 608  :     
; 609  :     
; 610  :     *BytesCopied = 0;

  00010	e59d801c	 ldr         r8, [sp, #0x1C]
  00014	e3a03000	 mov         r3, #0
  00018	e5883000	 str         r3, [r8]

; 611  : 
; 612  :     if(BytesToCopy == 0)

  0001c	0a00001a	 beq         |$LN5@CopyPacket|

; 613  :     {
; 614  :             return;
; 615  :     }
; 616  :         
; 617  :     DestAddr   = (PUCHAR) buffer;
; 618  :     CurrBuffer = FirstBuffer;
; 619  :     
; 620  :     NdisQueryBuffer( CurrBuffer, &BufferVirtAddr, &BufferLen);

  00020	e3550000	 cmp         r5, #0
  00024	03a06000	 moveq       r6, #0
  00028	15956004	 ldrne       r6, [r5, #4]
  0002c	03a04000	 moveq       r4, #0
  00030	15954008	 ldrne       r4, [r5, #8]
  00034		 |$LL7@CopyPacket|

; 621  : 
; 622  :     do
; 623  :     {
; 624  :         while(!BufferLen)

  00034	e3540000	 cmp         r4, #0
  00038	1a000006	 bne         |$LN3@CopyPacket|
  0003c		 |$LL4@CopyPacket|

; 625  :         {
; 626  :             NdisGetNextBuffer( CurrBuffer, &CurrBuffer);

  0003c	e5953000	 ldr         r3, [r5]
  00040	e1b05003	 movs        r5, r3

; 627  : 
; 628  :             /* Check if we have reached the end of packet, if so return. */
; 629  :             if (!CurrBuffer)

  00044	0a000010	 beq         |$LN5@CopyPacket|

; 630  :             {
; 631  :                 /* Assert BytesToCopy = 0 */
; 632  :                 ASSERT(BytesToCopy == 0);
; 633  :                 return;
; 634  :             }
; 635  :             NdisQueryBuffer(CurrBuffer, &BufferVirtAddr, &BufferLen);

  00048	e5953008	 ldr         r3, [r5, #8]
  0004c	e5956004	 ldr         r6, [r5, #4]
  00050	e1b04003	 movs        r4, r3
  00054	0afffff8	 beq         |$LL4@CopyPacket|
  00058		 |$LN3@CopyPacket|

; 636  :         }
; 637  : 
; 638  :         BytesOnThisCopy = MIN(BytesToCopy, BufferLen);

  00058	e1570004	 cmp         r7, r4
  0005c	31a04007	 movcc       r4, r7

; 639  :         NdisMoveMemory(DestAddr, BufferVirtAddr, BytesOnThisCopy);

  00060	e1a02004	 mov         r2, r4
  00064	e1a01006	 mov         r1, r6
  00068	e1a00009	 mov         r0, r9
  0006c	eb000000	 bl          memcpy

; 640  : 
; 641  :         (PUCHAR)DestAddr += BytesOnThisCopy;
; 642  : 
; 643  :         *BytesCopied += BytesOnThisCopy;

  00070	e5983000	 ldr         r3, [r8]
  00074	e0899004	 add         r9, r9, r4

; 644  :         BytesToCopy -= BytesOnThisCopy;

  00078	e0577004	 subs        r7, r7, r4
  0007c	e0833004	 add         r3, r3, r4
  00080	e5883000	 str         r3, [r8]

; 645  : 
; 646  :         BufferLen = 0;

  00084	e3a04000	 mov         r4, #0

; 647  : 
; 648  :     }while(BytesToCopy);

  00088	1affffe9	 bne         |$LL7@CopyPacket|
  0008c		 |$LN5@CopyPacket|

; 649  :     
; 650  :     return;
; 651  : }    

  0008c	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$M50748|

			 ENDP  ; |CopyPacketToBuffer|

	EXPORT	|Emac_MiniportSendPacketsHandler|
	IMPORT	|NdisReleaseSpinLock|
	IMPORT	|NdisQueryPacket|
	IMPORT	|NdisAcquireSpinLock|

  00000			 AREA	 |.pdata|, PDATA
|$T50775| DCD	|$LN35@Emac_Minip@3|
	DCD	0x4000bd02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Emac_MiniportSendPacketsHandler| PROC

; 671  : {  

  00000		 |$LN35@Emac_Minip@3|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd028	 sub         sp, sp, #0x28
  00008		 |$M50772|
  00008	e1a05002	 mov         r5, r2
  0000c	e1a0a001	 mov         r10, r1
  00010	e58d5014	 str         r5, [sp, #0x14]
  00014	e58da01c	 str         r10, [sp, #0x1C]
  00018	e1a04000	 mov         r4, r0

; 672  :     USHORT          Count;
; 673  :     PNDIS_PACKET    CurPacket;
; 674  :     PEMAC_ADAPTER   pAdapter;
; 675  :     UINT            PhysicalBufCount;
; 676  :     UINT            BufCount;
; 677  :     UINT            TotalPktLength;
; 678  :     UINT            CurBufAddress;
; 679  :     UINT            CurBufAddressPa;
; 680  :     PNDIS_BUFFER    FirstBuf;
; 681  :     PEMAC_TXPKT     pTxPktInfo = NULL;
; 682  :     PEMAC_TXBUF     TxHeadBuf;
; 683  :     PEMAC_TXBUF     TxNextHeadBuf;
; 684  :     PEMAC_TXBUF     TxPrevTailBuf;
; 685  :     PEMAC_TXBUF     TxTailBuf;  
; 686  :     PEMAC_TXBUF     pTxBufInfo;
; 687  :     QUEUE_T         TmpPerSendPktPool;    
; 688  : 
; 689  :     ULONG BytesCopied;
; 690  : 
; 691  :     pAdapter = (PEMAC_ADAPTER)MiniportAdapterContext;
; 692  : 
; 693  :     DEBUGMSG(DBG_FUNC && DBG_TX, (L"---> Emac_MiniportSendPacketsHandler %d \r\n",NumberOfPackets));
; 694  :   
; 695  :      /* Acquire the Send lock */
; 696  :     NdisAcquireSpinLock(&pAdapter->m_SendLock); 

  0001c	e284006c	 add         r0, r4, #0x6C
  00020	eb000000	 bl          NdisAcquireSpinLock

; 697  : 
; 698  :     if(DOWN == pAdapter->m_LinkStatus)

  00024	e59431a4	 ldr         r3, [r4, #0x1A4]
  00028	e3530001	 cmp         r3, #1
  0002c	0a0000ab	 beq         |$end$50363|

; 699  :     {
; 700  :         goto end;  
; 701  :     }
; 702  : 
; 703  : 
; 704  :     /* Initialise total packets maintained queue of bufs list */
; 705  :     QUEUE_INIT(&TmpPerSendPktPool);

  00030	e3a06000	 mov         r6, #0
  00034	e3a09000	 mov         r9, #0
  00038	e3a08000	 mov         r8, #0

; 706  :               
; 707  :     for( Count = 0 ; Count < NumberOfPackets ; Count++)

  0003c	e3a03000	 mov         r3, #0
  00040	e3550000	 cmp         r5, #0
  00044	0a0000a5	 beq         |$end$50363|
  00048	e3a02103	 mov         r2, #3, 2
  0004c	e382b09a	 orr         r11, r2, #0x9A
  00050	e3a07000	 mov         r7, #0
  00054	e58db018	 str         r11, [sp, #0x18]
  00058	e58d700c	 str         r7, [sp, #0xC]
  0005c	e28de004	 add         lr, sp, #4
  00060		 |$LL25@Emac_Minip@3|

; 708  :     {
; 709  :         /* Point to current packet */
; 710  :         CurPacket = PacketArray[Count];

  00060	e79aa103	 ldr         r10, [r10, +r3, lsl #2]

; 711  :         
; 712  :         /* Querying information about packet */
; 713  :         NdisQueryPacket(CurPacket,
; 714  :                        &PhysicalBufCount,
; 715  :                        &BufCount,
; 716  :                        &FirstBuf,
; 717  :                        &TotalPktLength);

  00064	e28d3010	 add         r3, sp, #0x10
  00068	e28d2020	 add         r2, sp, #0x20
  0006c	e1a0000a	 mov         r0, r10
  00070	e28d1008	 add         r1, sp, #8
  00074	e58de000	 str         lr, [sp]
  00078	eb000000	 bl          NdisQueryPacket

; 718  :         
; 719  :        /*  Number of Physical buffers, could be returned with invalid 
; 720  :         *  higher order bits.
; 721  :         */
; 722  :         PhysicalBufCount &= 0x0000FFFF;
; 723  :         
; 724  :         DEBUGMSG(DBG_TX, (L"PhysicalBufCount %d\r\npAdapter->TxBufInfoPool.Count %d\r\nBufCount %d\r\nTotalPktLength %d\r\n",
; 725  :             PhysicalBufCount,pAdapter->m_TxBufInfoPool.m_Count,BufCount,TotalPktLength)); 
; 726  :    
; 727  :         
; 728  :         if(0 == QUEUE_COUNT(&pAdapter->m_TxPktsInfoPool))

  0007c	e59d3008	 ldr         r3, [sp, #8]
  00080	e59421dc	 ldr         r2, [r4, #0x1DC]
  00084	e3a00cff	 mov         r0, #0xFF, 24
  00088	e38010ff	 orr         r1, r0, #0xFF
  0008c	e0033001	 and         r3, r3, r1
  00090	e1b01002	 movs        r1, r2
  00094	e58d3008	 str         r3, [sp, #8]

; 729  :         {
; 730  :             DEBUGMSG(DBG_WARN, (L"Unable to send packet %d \r\n",QUEUE_COUNT(&pAdapter->m_TxPktsInfoPool)));
; 731  :             /* Set status as resources */
; 732  :             NDIS_SET_PACKET_STATUS(CurPacket,NDIS_STATUS_RESOURCES );

  00098	01da31be	 ldreqh      r3, [r10, #0x1E]
  0009c	0083300a	 addeq       r3, r3, r10
  000a0	0583b01c	 streq       r11, [r3, #0x1C]
  000a4	0a000060	 beq         |$LN24@Emac_Minip@3|

; 733  :             
; 734  :             /* we will return to indicate NDIS to resubmit remaining packets */
; 735  :             continue;
; 736  :         }
; 737  : 
; 738  :         /* we can transmit this packet 
; 739  :          * Dequeue  from available packet pool a packet  
; 740  :          */
; 741  :         QUEUE_REMOVE(&pAdapter->m_TxPktsInfoPool, pTxPktInfo);

  000a8	e2943f75	 adds        r3, r4, #0x75, 30
  000ac	e3a05000	 mov         r5, #0
  000b0	0a00000d	 beq         |$LN32@Emac_Minip@3|
  000b4	e59431d4	 ldr         r3, [r4, #0x1D4]
  000b8	e1b02003	 movs        r2, r3
  000bc	0a00000a	 beq         |$LN32@Emac_Minip@3|
  000c0	e5923000	 ldr         r3, [r2]
  000c4	e1a05002	 mov         r5, r2
  000c8	e3530000	 cmp         r3, #0
  000cc	e58431d4	 str         r3, [r4, #0x1D4]
  000d0	03a03000	 moveq       r3, #0
  000d4	058431d8	 streq       r3, [r4, #0x1D8]
  000d8	e2413001	 sub         r3, r1, #1
  000dc	e3a01000	 mov         r1, #0
  000e0	e58431dc	 str         r3, [r4, #0x1DC]
  000e4	e5821000	 str         r1, [r2]
  000e8	ea000000	 b           |$LN21@Emac_Minip@3|
  000ec		 |$LN32@Emac_Minip@3|
  000ec	e3a01000	 mov         r1, #0
  000f0		 |$LN21@Emac_Minip@3|

; 742  :         
; 743  :         /* Initialise per packet maintained queue of bufs list */
; 744  :         QUEUE_INIT(&pTxPktInfo->m_BufsList);
; 745  :         
; 746  :         /* Pkt handle will be current packet */
; 747  :         pTxPktInfo->m_PktHandle = CurPacket;
; 748  :         
; 749  :         /*
; 750  :         * Dequeue a TxBufInfoPool structure, and assert that one is
; 751  :         * available.
; 752  :         */
; 753  :         QUEUE_REMOVE(&pAdapter->m_TxBufInfoPool, pTxBufInfo);

  000f0	e2943f72	 adds        r3, r4, #0x72, 30
  000f4	e5851008	 str         r1, [r5, #8]
  000f8	e585100c	 str         r1, [r5, #0xC]
  000fc	e5851010	 str         r1, [r5, #0x10]
  00100	e585a004	 str         r10, [r5, #4]
  00104	e3a07000	 mov         r7, #0
  00108	0a00000b	 beq         |$LN19@Emac_Minip@3|
  0010c	e59431c8	 ldr         r3, [r4, #0x1C8]
  00110	e1b02003	 movs        r2, r3
  00114	0a000008	 beq         |$LN19@Emac_Minip@3|
  00118	e5923000	 ldr         r3, [r2]
  0011c	e1a07002	 mov         r7, r2
  00120	e3530000	 cmp         r3, #0
  00124	e58431c8	 str         r3, [r4, #0x1C8]
  00128	e59431d0	 ldr         r3, [r4, #0x1D0]
  0012c	058411cc	 streq       r1, [r4, #0x1CC]
  00130	e2433001	 sub         r3, r3, #1
  00134	e58431d0	 str         r3, [r4, #0x1D0]
  00138	e5821000	 str         r1, [r2]
  0013c		 |$LN19@Emac_Minip@3|

; 754  :         
; 755  :         CurBufAddress  = pTxBufInfo->m_BufLogicalAddress;
; 756  :         CurBufAddressPa = pTxBufInfo->m_BufPhysicalAddress;
; 757  :         
; 758  :         CopyPacketToBuffer(CurPacket,FirstBuf,
; 759  :                     (PUCHAR)CurBufAddress,
; 760  :                     TotalPktLength,
; 761  :                     &BytesCopied);

  0013c	e59d3004	 ldr         r3, [sp, #4]
  00140	e5972008	 ldr         r2, [r7, #8]
  00144	e59d1010	 ldr         r1, [sp, #0x10]
  00148	e597b00c	 ldr         r11, [r7, #0xC]
  0014c	e28de024	 add         lr, sp, #0x24
  00150	e1a0000a	 mov         r0, r10
  00154	e58de000	 str         lr, [sp]
  00158	eb000000	 bl          CopyPacketToBuffer

; 762  :         
; 763  :         if(TotalPktLength < EMAC_MIN_ETHERNET_PKT_SIZE)

  0015c	e59d3004	 ldr         r3, [sp, #4]

; 764  :         {
; 765  :             TotalPktLength = EMAC_MIN_ETHERNET_PKT_SIZE;
; 766  :         }
; 767  :         
; 768  :         ((PEMACDESC)(pTxBufInfo->m_EmacBufDes))->pNext = 0;
; 769  :         
; 770  :         ((PEMACDESC)(pTxBufInfo->m_EmacBufDes))->PktFlgLen = (
; 771  :                                                                EMAC_DSC_FLAG_SOP |
; 772  :                                                                EMAC_DSC_FLAG_EOP | 
; 773  :                                                                EMAC_DSC_FLAG_OWNER |
; 774  :                                                                (TotalPktLength & 0xFFFF)
; 775  :                                                                );
; 776  :         ((PEMACDESC)(pTxBufInfo->m_EmacBufDes))->BufOffLen =  (TotalPktLength & 0xFFFF);
; 777  :         
; 778  :         ((PEMACDESC)(pTxBufInfo->m_EmacBufDes))->pBuffer = (UINT8 *)CurBufAddressPa;
; 779  :         
; 780  :         
; 781  :         /* Insert in to per packet maintained buffer pool */
; 782  :         QUEUE_INSERT(&pTxPktInfo->m_BufsList,pTxBufInfo);

  00160	e3a0e000	 mov         lr, #0
  00164	e3a00cff	 mov         r0, #0xFF, 24
  00168	e353003c	 cmp         r3, #0x3C
  0016c	33a0303c	 movcc       r3, #0x3C
  00170	358d3004	 strcc       r3, [sp, #4]
  00174	e5972010	 ldr         r2, [r7, #0x10]
  00178	e2953008	 adds        r3, r5, #8
  0017c	e38010ff	 orr         r1, r0, #0xFF
  00180	e582e000	 str         lr, [r2]
  00184	e59d3004	 ldr         r3, [sp, #4]
  00188	e5972010	 ldr         r2, [r7, #0x10]
  0018c	e0033001	 and         r3, r3, r1
  00190	e383320e	 orr         r3, r3, #0xE, 4
  00194	e582300c	 str         r3, [r2, #0xC]
  00198	e59d3004	 ldr         r3, [sp, #4]
  0019c	e5972010	 ldr         r2, [r7, #0x10]
  001a0	e0033001	 and         r3, r3, r1
  001a4	e5823008	 str         r3, [r2, #8]
  001a8	e5973010	 ldr         r3, [r7, #0x10]
  001ac	e583b004	 str         r11, [r3, #4]
  001b0	0a000009	 beq         |$LN16@Emac_Minip@3|
  001b4	e5953008	 ldr         r3, [r5, #8]
  001b8	e3530000	 cmp         r3, #0
  001bc	1595300c	 ldrne       r3, [r5, #0xC]
  001c0	05857008	 streq       r7, [r5, #8]
  001c4	15837000	 strne       r7, [r3]
  001c8	e5953010	 ldr         r3, [r5, #0x10]
  001cc	e585700c	 str         r7, [r5, #0xC]
  001d0	e2833001	 add         r3, r3, #1
  001d4	e5853010	 str         r3, [r5, #0x10]
  001d8	e587e000	 str         lr, [r7]
  001dc		 |$LN16@Emac_Minip@3|

; 783  :         
; 784  :         
; 785  :         if(0 != QUEUE_COUNT(&TmpPerSendPktPool))

  001dc	e3580000	 cmp         r8, #0

; 786  :         {
; 787  :             /* Since there are some other packets in to be posted send pkt pool
; 788  :              * we have to link the current head of the to be posted send packet pool 
; 789  :              * to the tail of temporary send packets pool
; 790  :              */
; 791  : 
; 792  :             /* First we will fetch the tail buffer of temp send pkts pool */
; 793  :             
; 794  :             TxPrevTailBuf = (PEMAC_TXBUF)(((PEMAC_TXPKT)(TmpPerSendPktPool.m_pTail))->m_BufsList).m_pTail;
; 795  :             TxNextHeadBuf = (PEMAC_TXBUF)((pTxPktInfo->m_BufsList).m_pHead);
; 796  :             
; 797  :             ((PEMACDESC)(TxPrevTailBuf->m_EmacBufDes))->pNext = (PEMACDESC)(TxNextHeadBuf->m_EmacBufDesPa);

  001e0	15953008	 ldrne       r3, [r5, #8]
  001e4	1599200c	 ldrne       r2, [r9, #0xC]

; 798  :          }
; 799  :         /* add it to the to be posted packet pool */
; 800  :        
; 801  :         QUEUE_INSERT(&TmpPerSendPktPool,pTxPktInfo);
; 802  :            
; 803  :         /* Set status as pending as we are indicating asynchronously */
; 804  :         
; 805  :         NDIS_SET_PACKET_STATUS(CurPacket,NDIS_STATUS_PENDING );

  001e8	e59d700c	 ldr         r7, [sp, #0xC]
  001ec	15931014	 ldrne       r1, [r3, #0x14]
  001f0	15923010	 ldrne       r3, [r2, #0x10]
  001f4	e59db018	 ldr         r11, [sp, #0x18]
  001f8	e2888001	 add         r8, r8, #1
  001fc	15831000	 strne       r1, [r3]
  00200	e3560000	 cmp         r6, #0
  00204	15895000	 strne       r5, [r9]
  00208	e585e000	 str         lr, [r5]
  0020c	e1da31be	 ldrh        r3, [r10, #0x1E]
  00210	e3a01c01	 mov         r1, #1, 24
  00214	e3812003	 orr         r2, r1, #3
  00218	e083300a	 add         r3, r3, r10
  0021c	01a06005	 moveq       r6, r5
  00220	e1a09005	 mov         r9, r5
  00224	e59d5014	 ldr         r5, [sp, #0x14]
  00228	e583201c	 str         r2, [r3, #0x1C]
  0022c		 |$LN24@Emac_Minip@3|
  0022c	e2873001	 add         r3, r7, #1
  00230	e1a03803	 mov         r3, r3, lsl #16
  00234	e1a03823	 mov         r3, r3, lsr #16
  00238	e1a07003	 mov         r7, r3
  0023c	e59da01c	 ldr         r10, [sp, #0x1C]
  00240	e58d700c	 str         r7, [sp, #0xC]
  00244	e1530005	 cmp         r3, r5
  00248	e28de004	 add         lr, sp, #4
  0024c	3affff83	 bcc         |$LL25@Emac_Minip@3|

; 806  :         
; 807  :     }/* end of for loop */
; 808  :     
; 809  :     if(0 == QUEUE_COUNT(&TmpPerSendPktPool))

  00250	e3580000	 cmp         r8, #0
  00254	0a000021	 beq         |$end$50363|

; 810  :     {
; 811  :         goto end;   
; 812  :     }
; 813  :   
; 814  :     if(0 == QUEUE_COUNT(&pAdapter->m_TxPostedPktPool))

  00258	e59431e8	 ldr         r3, [r4, #0x1E8]
  0025c	e3530000	 cmp         r3, #0
  00260	1a00000f	 bne         |$LN8@Emac_Minip@3|

; 815  :     {
; 816  :         /* Insert in to posted packets pool */
; 817  :         QUEUE_INSERT_QUEUE(&pAdapter->m_TxPostedPktPool,&TmpPerSendPktPool);

  00264	e2943e1e	 adds        r3, r4, #0x1E, 28
  00268	0a000007	 beq         |$LN7@Emac_Minip@3|
  0026c	e59431e4	 ldr         r3, [r4, #0x1E4]
  00270	e3530000	 cmp         r3, #0
  00274	15836000	 strne       r6, [r3]
  00278	e59431e8	 ldr         r3, [r4, #0x1E8]
  0027c	058461e0	 streq       r6, [r4, #0x1E0]
  00280	e58491e4	 str         r9, [r4, #0x1E4]
  00284	e0833008	 add         r3, r3, r8
  00288	e58431e8	 str         r3, [r4, #0x1E8]
  0028c		 |$LN7@Emac_Minip@3|

; 818  :         
; 819  :         TxHeadBuf = (PEMAC_TXBUF)(((PEMAC_TXPKT)(pAdapter->m_TxPostedPktPool.m_pHead))->m_BufsList).m_pHead;
; 820  :        
; 821  :         /* Submit formed TX buffers queue to EMAC TX DMA */  
; 822  :         pAdapter->m_pEmacRegsBase->TX0HDP = TxHeadBuf->m_EmacBufDesPa;

  0028c	e59431e0	 ldr         r3, [r4, #0x1E0]
  00290	e5942004	 ldr         r2, [r4, #4]
  00294	e5933008	 ldr         r3, [r3, #8]
  00298	e5933014	 ldr         r3, [r3, #0x14]
  0029c	e5823600	 str         r3, [r2, #0x600]

; 823  :         
; 824  :     }
; 825  :     else   /* Posted packets is non zero */

  002a0	ea00000e	 b           |$end$50363|
  002a4		 |$LN8@Emac_Minip@3|

; 826  :     {    
; 827  :         TxTailBuf = (PEMAC_TXBUF)(((PEMAC_TXPKT)(pAdapter->m_TxPostedPktPool.m_pTail))->m_BufsList).m_pTail;

  002a4	e59421e4	 ldr         r2, [r4, #0x1E4]

; 828  :         TxHeadBuf = (PEMAC_TXBUF)(((PEMAC_TXPKT)(TmpPerSendPktPool.m_pHead))->m_BufsList).m_pHead;
; 829  :          
; 830  :         /* Insert in to posted packets pool */
; 831  :         QUEUE_INSERT_QUEUE(&pAdapter->m_TxPostedPktPool,&TmpPerSendPktPool);

  002a8	e5961008	 ldr         r1, [r6, #8]
  002ac	e2943e1e	 adds        r3, r4, #0x1E, 28
  002b0	e592000c	 ldr         r0, [r2, #0xC]
  002b4	0a000006	 beq         |$LN3@Emac_Minip@3|
  002b8	e3520000	 cmp         r2, #0
  002bc	15826000	 strne       r6, [r2]
  002c0	e59431e8	 ldr         r3, [r4, #0x1E8]
  002c4	058461e0	 streq       r6, [r4, #0x1E0]
  002c8	e58491e4	 str         r9, [r4, #0x1E4]
  002cc	e0833008	 add         r3, r3, r8
  002d0	e58431e8	 str         r3, [r4, #0x1E8]
  002d4		 |$LN3@Emac_Minip@3|

; 832  :             
; 833  :         /* Insert in to posted packets pool */
; 834  :         ((PEMACDESC)(TxTailBuf->m_EmacBufDes))->pNext = ((PEMACDESC)(TxHeadBuf->m_EmacBufDesPa));

  002d4	e5902010	 ldr         r2, [r0, #0x10]
  002d8	e5913014	 ldr         r3, [r1, #0x14]
  002dc	e5823000	 str         r3, [r2]
  002e0		 |$end$50363|

; 835  :         
; 836  :     }
; 837  : 
; 838  : end:   
; 839  :     NdisReleaseSpinLock(&pAdapter->m_SendLock);

  002e0	e284006c	 add         r0, r4, #0x6C
  002e4	eb000000	 bl          NdisReleaseSpinLock

; 840  :     
; 841  :     DEBUGMSG(DBG_FUNC && DBG_TX, (L"<--- Emac_MiniportSendPacketsHandler \r\n"));
; 842  : }

  002e8	e28dd028	 add         sp, sp, #0x28
  002ec	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  002f0	e12fff1e	 bx          lr
  002f4		 |$M50773|

			 ENDP  ; |Emac_MiniportSendPacketsHandler|

	EXPORT	|Emac_MiniportReset|
	EXPORT	|??_C@_1GK@HEDBLALI@?$AAE?$AAm?$AAa?$AAc?$AA_?$AAM?$AAi?$AAn?$AAi?$AAp?$AAo?$AAr?$AAt?$AAR?$AAe?$AAs?$AAe?$AAt?$AA?3?$AAN?$AAI?$AAC?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FI@LDCCALIL@?$AAE?$AAm?$AAa?$AAc?$AA_?$AAM?$AAi?$AAn?$AAi?$AAp?$AAo?$AAr?$AAt?$AAR?$AAe?$AAs?$AAe?$AAt?$AA?3?$AAN?$AAI?$AAC?$AAI?$AAn?$AAi?$AAt?$AAR?$AAe?$AAc?$AAv?$AA?5?$AAi@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FI@ENDLAONI@?$AAE?$AAm?$AAa?$AAc?$AA_?$AAM?$AAi?$AAn?$AAi?$AAp?$AAo?$AAr?$AAt?$AAR?$AAe?$AAs?$AAe?$AAt?$AA?3?$AAN?$AAI?$AAC?$AAI?$AAn?$AAi?$AAt?$AAS?$AAe?$AAn?$AAd?$AA?5?$AAi@| [ DATA ] ; `string'
	IMPORT	|NICSelfTest|
	IMPORT	|NICInitializeAdapter|
	IMPORT	|EMACModStateChange|
	IMPORT	|NICInitRecv|
	IMPORT	|NKDbgPrintfW|
	IMPORT	|NICInitSend|

  00000			 AREA	 |.pdata|, PDATA
|$T50789| DCD	|$LN18@Emac_Minip@4|
	DCD	0x40003c01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GK@HEDBLALI@?$AAE?$AAm?$AAa?$AAc?$AA_?$AAM?$AAi?$AAn?$AAi?$AAp?$AAo?$AAr?$AAt?$AAR?$AAe?$AAs?$AAe?$AAt?$AA?3?$AAN?$AAI?$AAC?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe@| DCB "E"
	DCB	0x0, "m", 0x0, "a", 0x0, "c", 0x0, "_", 0x0, "M", 0x0, "i"
	DCB	0x0, "n", 0x0, "i", 0x0, "p", 0x0, "o", 0x0, "r", 0x0, "t"
	DCB	0x0, "R", 0x0, "e", 0x0, "s", 0x0, "e", 0x0, "t", 0x0, ":"
	DCB	0x0, "N", 0x0, "I", 0x0, "C", 0x0, "I", 0x0, "n", 0x0, "i"
	DCB	0x0, "t", 0x0, "i", 0x0, "a", 0x0, "l", 0x0, "i", 0x0, "z"
	DCB	0x0, "e", 0x0, "A", 0x0, "d", 0x0, "a", 0x0, "p", 0x0, "t"
	DCB	0x0, "e", 0x0, "r", 0x0, " ", 0x0, "i", 0x0, "s", 0x0, " "
	DCB	0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, ".", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FI@LDCCALIL@?$AAE?$AAm?$AAa?$AAc?$AA_?$AAM?$AAi?$AAn?$AAi?$AAp?$AAo?$AAr?$AAt?$AAR?$AAe?$AAs?$AAe?$AAt?$AA?3?$AAN?$AAI?$AAC?$AAI?$AAn?$AAi?$AAt?$AAR?$AAe?$AAc?$AAv?$AA?5?$AAi@| DCB "E"
	DCB	0x0, "m", 0x0, "a", 0x0, "c", 0x0, "_", 0x0, "M", 0x0, "i"
	DCB	0x0, "n", 0x0, "i", 0x0, "p", 0x0, "o", 0x0, "r", 0x0, "t"
	DCB	0x0, "R", 0x0, "e", 0x0, "s", 0x0, "e", 0x0, "t", 0x0, ":"
	DCB	0x0, "N", 0x0, "I", 0x0, "C", 0x0, "I", 0x0, "n", 0x0, "i"
	DCB	0x0, "t", 0x0, "R", 0x0, "e", 0x0, "c", 0x0, "v", 0x0, " "
	DCB	0x0, "i", 0x0, "s", 0x0, " ", 0x0, "f", 0x0, "a", 0x0, "i"
	DCB	0x0, "l", 0x0, "e", 0x0, "d", 0x0, ".", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FI@ENDLAONI@?$AAE?$AAm?$AAa?$AAc?$AA_?$AAM?$AAi?$AAn?$AAi?$AAp?$AAo?$AAr?$AAt?$AAR?$AAe?$AAs?$AAe?$AAt?$AA?3?$AAN?$AAI?$AAC?$AAI?$AAn?$AAi?$AAt?$AAS?$AAe?$AAn?$AAd?$AA?5?$AAi@| DCB "E"
	DCB	0x0, "m", 0x0, "a", 0x0, "c", 0x0, "_", 0x0, "M", 0x0, "i"
	DCB	0x0, "n", 0x0, "i", 0x0, "p", 0x0, "o", 0x0, "r", 0x0, "t"
	DCB	0x0, "R", 0x0, "e", 0x0, "s", 0x0, "e", 0x0, "t", 0x0, ":"
	DCB	0x0, "N", 0x0, "I", 0x0, "C", 0x0, "I", 0x0, "n", 0x0, "i"
	DCB	0x0, "t", 0x0, "S", 0x0, "e", 0x0, "n", 0x0, "d", 0x0, " "
	DCB	0x0, "i", 0x0, "s", 0x0, " ", 0x0, "f", 0x0, "a", 0x0, "i"
	DCB	0x0, "l", 0x0, "e", 0x0, "d", 0x0, ".", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Emac_MiniportReset| PROC

; 862  : {

  00000		 |$LN18@Emac_Minip@4|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M50786|
  00004	e1b05001	 movs        r5, r1

; 863  : 	NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
; 864  :     PEMAC_ADAPTER   pAdapter = (PEMAC_ADAPTER) MiniportAdapterContext;
; 865  :     
; 866  :     DEBUGMSG(DBG_CRITICAL || DBG_FUNC, (L"---> Emac_MiniportReset\r\n")); 
; 867  :   
; 868  :     /*
; 869  :      * Perform validity checks on the MiniportAdapterContext -> adapter
; 870  :      * pointer.
; 871  :      */
; 872  : 
; 873  :     do
; 874  :     {
; 875  :         if(pAdapter == (PEMAC_ADAPTER) NULL)
; 876  :         {
; 877  :             DEBUGMSG(DBG_ERR, (L"Emac_MiniportReset: Invalid Adapter pointer"));
; 878  :             return NDIS_STATUS_FAILURE;

  00008	03a04107	 moveq       r4, #7, 2
  0000c	0a00002b	 beq         |$LN9@Emac_Minip@4|

; 879  :         }
; 880  :                     
; 881  :         /* Test is successful , make a status transition */     
; 882  :         pAdapter->m_HwStatus = NdisHardwareStatusReset;

  00010	e3a03002	 mov         r3, #2

; 883  :         
; 884  :         *AddressingReset = TRUE;

  00014	e3a07001	 mov         r7, #1
  00018	e58531a0	 str         r3, [r5, #0x1A0]
  0001c	e5c07000	 strb        r7, [r0]

; 885  :       
; 886  :         /* Tear down receive and transmit channels so that Rx/Tx are completelly
; 887  :          * stopped immediately
; 888  :          */
; 889  :         pAdapter->m_pEmacRegsBase->RXTEARDOWN = 0x0;

  00020	e5953004	 ldr         r3, [r5, #4]
  00024	e3a06000	 mov         r6, #0
  00028	e5836018	 str         r6, [r3, #0x18]

; 890  :         pAdapter->m_pEmacRegsBase->TXTEARDOWN = 0x0;

  0002c	e5953004	 ldr         r3, [r5, #4]
  00030	e5836008	 str         r6, [r3, #8]
  00034	e595339c	 ldr         r3, [r5, #0x39C]
  00038		 |$LL7@Emac_Minip@4|

; 891  :          
; 892  :         /* wait for teardowm completion */
; 893  :         while(0 != (pAdapter->m_Events & EMAC_RX_TEARDOWN_EVENT) &&
; 894  :               0 != (pAdapter->m_Events & EMAC_TX_TEARDOWN_EVENT))

  00038	e3130002	 tst         r3, #2
  0003c	0a000001	 beq         |$LN6@Emac_Minip@4|
  00040	e3130001	 tst         r3, #1
  00044	1afffffb	 bne         |$LL7@Emac_Minip@4|
  00048		 |$LN6@Emac_Minip@4|

; 895  :         {
; 896  : 
; 897  :         }
; 898  : 
; 899  :         /*
; 900  :          * Disable the interrupts in the card, so that the interrupt routine would
; 901  :          * not be called.
; 902  :          */
; 903  :         Emac_MiniportDisableInterrupt(pAdapter);

  00048	e1a00005	 mov         r0, r5
  0004c	eb000000	 bl          Emac_MiniportDisableInterrupt

; 904  : 
; 905  :         /* Free allocated memory */
; 906  :         EmacFreeAdapter(pAdapter);

  00050	e1a00005	 mov         r0, r5
  00054	eb000000	 bl          EmacFreeAdapter

; 907  : 
; 908  :         /* Init send data structures */
; 909  :         Status = NICInitSend(pAdapter);

  00058	e1a00005	 mov         r0, r5
  0005c	eb000000	 bl          NICInitSend
  00060	e1b04000	 movs        r4, r0

; 910  :         if (Status != NDIS_STATUS_SUCCESS)

  00064	0a000002	 beq         |$LN5@Emac_Minip@4|

; 911  :         {
; 912  :             RETAILMSG(TRUE, (L"Emac_MiniportReset:NICInitSend is failed.\r\n"));

  00068	e59f007c	 ldr         r0, [pc, #0x7C]
  0006c	eb000000	 bl          NKDbgPrintfW

; 913  :             break;

  00070	ea000012	 b           |$LN9@Emac_Minip@4|
  00074		 |$LN5@Emac_Minip@4|

; 914  :         }   
; 915  : 
; 916  :         /* Init receive data structures */
; 917  :         Status = NICInitRecv(pAdapter);

  00074	e1a00005	 mov         r0, r5
  00078	eb000000	 bl          NICInitRecv
  0007c	e1b04000	 movs        r4, r0

; 918  :         if (Status != NDIS_STATUS_SUCCESS)

  00080	0a000002	 beq         |$LN4@Emac_Minip@4|

; 919  :         {
; 920  :             RETAILMSG(TRUE, (L"Emac_MiniportReset:NICInitRecv is failed.\r\n"));

  00084	e59f005c	 ldr         r0, [pc, #0x5C]
  00088	eb000000	 bl          NKDbgPrintfW
  0008c	ea00000b	 b           |$LN9@Emac_Minip@4|
  00090		 |$LN4@Emac_Minip@4|

; 921  :             break;
; 922  :         }   
; 923  : 
; 924  : 		/* Init the hardware and set up everything */
; 925  :         pAdapter->m_HwStatus = NdisHardwareStatusInitializing;
; 926  :         
; 927  :         /* Power on the EMAC subsystem */
; 928  :         EMACModStateChange(pAdapter->m_device,SYNCRST);

  00090	e5950094	 ldr         r0, [r5, #0x94]
  00094	e3a01000	 mov         r1, #0
  00098	e58571a0	 str         r7, [r5, #0x1A0]
  0009c	eb000000	 bl          EMACModStateChange

; 929  : 
; 930  :         Status = NICInitializeAdapter(pAdapter);

  000a0	e1a00005	 mov         r0, r5
  000a4	eb000000	 bl          NICInitializeAdapter
  000a8	e3500000	 cmp         r0, #0

; 931  :         if (Status != NDIS_STATUS_SUCCESS) 

  000ac	0a000006	 beq         |$LN3@Emac_Minip@4|

; 932  :         {
; 933  :             RETAILMSG(TRUE, (L"Emac_MiniportReset:NICInitializeAdapter is failed.\r\n"));

  000b0	e59f002c	 ldr         r0, [pc, #0x2C]
  000b4	eb000000	 bl          NKDbgPrintfW
  000b8		 |$LN2@Emac_Minip@4|

; 940  :         {
; 941  :             /* Test is successful , make a status transition */     
; 942  :             pAdapter->m_HwStatus = NdisHardwareStatusReady; 

  000b8	e3a03112	 mov         r3, #0x12, 2

; 943  :         }  
; 944  :         else
; 945  :         {
; 946  :             Status = NDIS_STATUS_HARD_ERRORS;

  000bc	e3834801	 orr         r4, r3, #1, 16
  000c0		 |$LN9@Emac_Minip@4|

; 947  :             break;
; 948  :         }
; 949  : 
; 950  :     }while(0);
; 951  : 
; 952  :     DEBUGMSG(DBG_CRITICAL || DBG_FUNC, (L"<--- Emac_MiniportReset Status = %X\r\n", Status));
; 953  :   
; 954  :     return(Status);
; 955  : }

  000c0	e1a00004	 mov         r0, r4
  000c4	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000c8	e12fff1e	 bx          lr
  000cc		 |$LN3@Emac_Minip@4|

; 934  :             Status = NDIS_STATUS_HARD_ERRORS;
; 935  :             break;
; 936  :         }
; 937  : 
; 938  :         Status = NICSelfTest(pAdapter);

  000cc	e1a00005	 mov         r0, r5
  000d0	eb000000	 bl          NICSelfTest
  000d4	e1b04000	 movs        r4, r0

; 939  :         if (Status == NDIS_STATUS_SUCCESS)

  000d8	1afffff6	 bne         |$LN2@Emac_Minip@4|

; 940  :         {
; 941  :             /* Test is successful , make a status transition */     
; 942  :             pAdapter->m_HwStatus = NdisHardwareStatusReady; 

  000dc	e58561a0	 str         r6, [r5, #0x1A0]
  000e0	eafffff6	 b           |$LN9@Emac_Minip@4|
  000e4		 |$LN19@Emac_Minip@4|
  000e4		 |$LN20@Emac_Minip@4|
  000e4	00000000	 DCD         |??_C@_1GK@HEDBLALI@?$AAE?$AAm?$AAa?$AAc?$AA_?$AAM?$AAi?$AAn?$AAi?$AAp?$AAo?$AAr?$AAt?$AAR?$AAe?$AAs?$AAe?$AAt?$AA?3?$AAN?$AAI?$AAC?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe@|
  000e8		 |$LN21@Emac_Minip@4|
  000e8	00000000	 DCD         |??_C@_1FI@LDCCALIL@?$AAE?$AAm?$AAa?$AAc?$AA_?$AAM?$AAi?$AAn?$AAi?$AAp?$AAo?$AAr?$AAt?$AAR?$AAe?$AAs?$AAe?$AAt?$AA?3?$AAN?$AAI?$AAC?$AAI?$AAn?$AAi?$AAt?$AAR?$AAe?$AAc?$AAv?$AA?5?$AAi@|
  000ec		 |$LN22@Emac_Minip@4|
  000ec	00000000	 DCD         |??_C@_1FI@ENDLAONI@?$AAE?$AAm?$AAa?$AAc?$AA_?$AAM?$AAi?$AAn?$AAi?$AAp?$AAo?$AAr?$AAt?$AAR?$AAe?$AAs?$AAe?$AAt?$AA?3?$AAN?$AAI?$AAC?$AAI?$AAn?$AAi?$AAt?$AAS?$AAe?$AAn?$AAd?$AA?5?$AAi@|
  000f0		 |$M50787|

			 ENDP  ; |Emac_MiniportReset|

	EXPORT	|Emac_MiniportCheckForHang|

  00000			 AREA	 |.pdata|, PDATA
|$T50802| DCD	|$LN5@Emac_Minip@5|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Emac_MiniportCheckForHang| PROC

; 971  : {

  00000		 |$LN5@Emac_Minip@5|
  00000		 |$M50799|

; 972  :     PEMAC_ADAPTER     pAdapter = (PEMAC_ADAPTER) MiniportAdapterContext;
; 973  :     
; 974  :     DEBUGMSG(DBG_FUNC && DBG_MSG, (L"---> Emac_MiniportCheckForHang\r\n"));
; 975  :     
; 976  :     /* We are indicating link change interrupt asynchonioulsly 
; 977  :      * No need to take care of link down state. Also host error events
; 978  :      * are interrupts here and reset will be done there also.
; 979  :      */
; 980  :      
; 981  :     /* Need to see any other way we can monitor hungups */
; 982  :      
; 983  :     return (FALSE);  

  00000	e3a00000	 mov         r0, #0

; 984  : }     

  00004	e12fff1e	 bx          lr
  00008		 |$M50800|

			 ENDP  ; |Emac_MiniportCheckForHang|

	END
