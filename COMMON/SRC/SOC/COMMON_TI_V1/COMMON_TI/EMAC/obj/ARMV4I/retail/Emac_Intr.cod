; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\EMAC\Emac_Intr.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|AddBufToRxQueue|
	IMPORT	|NdisReleaseSpinLock|
	IMPORT	|NdisAcquireSpinLock|
	IMPORT	|memset|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\emac\emac_intr.c

  00000			 AREA	 |.pdata|, PDATA
|$T50739| DCD	|$LN15@AddBufToRx|
	DCD	0x40003901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |AddBufToRxQueue| PROC

; 92   : {

  00000		 |$LN15@AddBufToRx|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M50736|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 93   :     PEMAC_ADAPTER   pAdapter;
; 94   :     PEMAC_RXBUFS    pEmacRxBufsList;
; 95   :     PEMACDESC       pRXDescPa;
; 96   :     PEMACDESC       pRXDescVa;
; 97   :     UINT32          RXTailDescPa;
; 98   :     UINT32          RXTailDescVa;
; 99   :     UINT32          TailPktStatus;
; 100  :     
; 101  :     pAdapter = (PEMAC_ADAPTER)MiniportAdapterContext;
; 102  :     
; 103  :     /* Acquire the Receive lock */
; 104  :     NdisAcquireSpinLock(&pAdapter->m_RcvLock);

  0000c	e2850080	 add         r0, r5, #0x80
  00010	eb000000	 bl          NdisAcquireSpinLock

; 105  : 
; 106  :     /* Fetch the current buffer to be added */
; 107  :     pEmacRxBufsList = (PEMAC_RXBUFS)pTmpRxPkt->m_BufsList.m_pHead;

  00014	e5943008	 ldr         r3, [r4, #8]
  00018	e1b04003	 movs        r4, r3

; 108  :     
; 109  :     while(pEmacRxBufsList != 0)

  0001c	0a00002c	 beq         |$LN7@AddBufToRx|
  00020	e3a06000	 mov         r6, #0
  00024	e3a07c06	 mov         r7, #6, 24
  00028	e3a08202	 mov         r8, #2, 4
  0002c	e3a09001	 mov         r9, #1
  00030		 |$LL8@AddBufToRx|

; 110  :     {
; 111  :         /* Get the current Rx bufs physical and virtual EMAC buffer descriptor */
; 112  :         pRXDescPa = (PEMACDESC)pEmacRxBufsList->m_EmacBufDesPa; 
; 113  :         pRXDescVa = (PEMACDESC)pEmacRxBufsList->m_EmacBufDes; 

  00030	e5943010	 ldr         r3, [r4, #0x10]
  00034	e5942014	 ldr         r2, [r4, #0x14]

; 114  :         
; 115  :         /* Terminating the present descriptor to NULL */
; 116  :         pRXDescVa->pNext = 0;

  00038	e5836000	 str         r6, [r3]

; 117  :         
; 118  :         /* Recylcling buffer length and ownership fields */
; 119  :         pRXDescVa->BufOffLen    = EMAC_MAX_PKT_BUFFER_SIZE;

  0003c	e5837008	 str         r7, [r3, #8]

; 120  :         pRXDescVa->PktFlgLen    = EMAC_DSC_FLAG_OWNER; 

  00040	e583800c	 str         r8, [r3, #0xC]

; 121  : 
; 122  :         if(0 != QUEUE_COUNT(&pAdapter->m_RxBufsPool))

  00044	e59531c4	 ldr         r3, [r5, #0x1C4]
  00048	e3530000	 cmp         r3, #0
  0004c	0a000007	 beq         |$LN6@AddBufToRx|

; 123  :         {
; 124  :             RXTailDescPa = ((PEMAC_RXBUFS)(pAdapter->m_RxBufsPool.m_pTail))->m_EmacBufDesPa;
; 125  :             RXTailDescVa = ((PEMAC_RXBUFS)(pAdapter->m_RxBufsPool.m_pTail))->m_EmacBufDes;

  00050	e59531c0	 ldr         r3, [r5, #0x1C0]
  00054	e5931010	 ldr         r1, [r3, #0x10]

; 126  : 
; 127  :             /* Attaching tail's EMAC buffer descriptor's next to got one */
; 128  :             ((PEMACDESC)(RXTailDescVa))->pNext = pRXDescPa;
; 129  :             
; 130  :              if(0 != (((PEMACDESC)(RXTailDescVa))->PktFlgLen & EMAC_DSC_FLAG_EOQ))

  00058	e591300c	 ldr         r3, [r1, #0xC]
  0005c	e5812000	 str         r2, [r1]
  00060	e3130201	 tst         r3, #1, 4
  00064	0a000003	 beq         |$LN4@AddBufToRx|

; 131  :             {
; 132  :                 TailPktStatus = ((PEMACDESC)(RXTailDescVa))->PktFlgLen;
; 133  :                 TailPktStatus &= ~(EMAC_DSC_FLAG_EOQ);

  00068	e3c33201	 bic         r3, r3, #1, 4

; 134  :                 ((PEMACDESC)(RXTailDescVa))->PktFlgLen = TailPktStatus;

  0006c	e581300c	 str         r3, [r1, #0xC]
  00070		 |$LN6@AddBufToRx|

; 135  :                 pAdapter->m_pEmacRegsBase->RX0HDP = (UINT32)pRXDescPa; 
; 136  :             }
; 137  :         }
; 138  :         else 
; 139  :         {
; 140  :             
; 141  :             pAdapter->m_pEmacRegsBase->RX0HDP = (UINT32)pRXDescPa;

  00070	e5953004	 ldr         r3, [r5, #4]
  00074	e5832620	 str         r2, [r3, #0x620]
  00078		 |$LN4@AddBufToRx|

; 142  :             
; 143  :            // pAdapter->m_RxQueueActive = TRUE;    
; 144  :         }
; 145  : 
; 146  :         /* Write to increment the register the buffer we got back for
; 147  :          * hardware flow control support
; 148  :          */
; 149  :         pAdapter->m_pEmacRegsBase->RX0FREEBUFFER = 0x1;

  00078	e5953004	 ldr         r3, [r5, #4]

; 150  :       
; 151  :         /* Clearing memory */
; 152  :         NdisZeroMemory((PVOID)pEmacRxBufsList->m_BufLogicalAddress,
; 153  :                                 EMAC_MAX_PKT_BUFFER_SIZE);

  0007c	e3a02c06	 mov         r2, #6, 24
  00080	e3a01000	 mov         r1, #0
  00084	e5839140	 str         r9, [r3, #0x140]
  00088	e5940008	 ldr         r0, [r4, #8]
  0008c	eb000000	 bl          memset

; 154  :    
; 155  :         /* Adjust the Buffer length */
; 156  :         NdisAdjustBufferLength((PNDIS_BUFFER)pEmacRxBufsList->m_BufHandle,
; 157  :                                    EMAC_MAX_PKT_BUFFER_SIZE);

  00090	e5943004	 ldr         r3, [r4, #4]

; 158  : 
; 159  :          /* Also adding to our Rx bufs pool */
; 160  :         QUEUE_INSERT(&pAdapter->m_RxBufsPool,pEmacRxBufsList);

  00094	e3750f6f	 cmn         r5, #0x6F, 30
  00098	e5837008	 str         r7, [r3, #8]
  0009c	0a000009	 beq         |$LN3@AddBufToRx|
  000a0	e59531bc	 ldr         r3, [r5, #0x1BC]
  000a4	e3530000	 cmp         r3, #0
  000a8	159531c0	 ldrne       r3, [r5, #0x1C0]
  000ac	058541bc	 streq       r4, [r5, #0x1BC]
  000b0	15834000	 strne       r4, [r3]
  000b4	e59531c4	 ldr         r3, [r5, #0x1C4]
  000b8	e58541c0	 str         r4, [r5, #0x1C0]
  000bc	e2833001	 add         r3, r3, #1
  000c0	e58531c4	 str         r3, [r5, #0x1C4]
  000c4	e5846000	 str         r6, [r4]
  000c8		 |$LN3@AddBufToRx|

; 161  :                 
; 162  :         /* Getting to next Rx buf if any */
; 163  :         pEmacRxBufsList = (PEMAC_RXBUFS)((PSLINK_T)pEmacRxBufsList)->m_pLink;

  000c8	e5943000	 ldr         r3, [r4]
  000cc	e1b04003	 movs        r4, r3
  000d0	1affffd6	 bne         |$LL8@AddBufToRx|
  000d4		 |$LN7@AddBufToRx|

; 164  :     }       
; 165  :     
; 166  :      NdisReleaseSpinLock(&pAdapter->m_RcvLock);

  000d4	e2850080	 add         r0, r5, #0x80
  000d8	eb000000	 bl          NdisReleaseSpinLock

; 167  : }

  000dc	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000e0	e12fff1e	 bx          lr
  000e4		 |$M50737|

			 ENDP  ; |AddBufToRxQueue|

	EXPORT	|RxIntrHandler|
	IMPORT	|NdisUnchainBufferAtFront|

  00000			 AREA	 |.pdata|, PDATA
|$T50779| DCD	|$LN59@RxIntrHand|
	DCD	0x4000dd03
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |RxIntrHandler| PROC

; 178  : {

  00000		 |$LN59@RxIntrHand|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004	e59fc364	 ldr         r12, [pc, #0x364]
  00008	e08dd00c	 add         sp, sp, r12
  0000c		 |$M50776|
  0000c	e1a04000	 mov         r4, r0

; 179  :     PEMAC_ADAPTER   pAdapter;
; 180  :     PEMAC_RXBUFS    pCurRxBuf;
; 181  :     PEMAC_RXBUFS    pNextRxBuf;
; 182  :     PNDIS_PACKET    NdisPktsArray[NDIS_INDICATE_PKTS];
; 183  :     UINT32          Status;
; 184  :     PEMACDESC       pCurDesc;
; 185  :     USHORT          PacketArrayCount = 0;
; 186  :     UINT16          BufLen;
; 187  :     UINT16          Index;
; 188  :     PEMAC_RXPKTS    pRxPkt;
; 189  :     PNDIS_BUFFER    NdisBuffer;
; 190  :     PEMAC_RXPKTS    *TempPtr;
; 191  :     PEMAC_RXPKTS    pTmpRxPkt;
; 192  :     BOOL            EOQPktGot = FALSE;
; 193  :     UINT32          RXTailDescVa;
; 194  :     
; 195  :     pAdapter = (PEMAC_ADAPTER)MiniportAdapterContext;      
; 196  : 
; 197  :     if(DOWN == pAdapter->m_LinkStatus)

  00010	e59431a4	 ldr         r3, [r4, #0x1A4]
  00014	e3a06000	 mov         r6, #0
  00018	e3530001	 cmp         r3, #1
  0001c	0a0000ce	 beq         |$LN4@RxIntrHand|

; 198  :     {
; 199  :         return;
; 200  :     }
; 201  : 
; 202  :     DEBUGMSG (DBG_FUNC,(L"-->RxIntrHandler\r\n"));
; 203  : 
; 204  :     pCurRxBuf =  pAdapter->m_pCurEmacRxBuf;
; 205  :     
; 206  :     /* Check if it is teardown interrupt then clear it 
; 207  :      * and return 
; 208  :      */
; 209  :      if(0xfffffffc == pAdapter->m_pEmacRegsBase->RX0CP)

  00020	e5942004	 ldr         r2, [r4, #4]
  00024	e5923660	 ldr         r3, [r2, #0x660]
  00028	e3730004	 cmn         r3, #4

; 210  :      {
; 211  :         pAdapter->m_Events |= EMAC_RX_TEARDOWN_EVENT;

  0002c	0594339c	 ldreq       r3, [r4, #0x39C]

; 212  :         pAdapter->m_pEmacRegsBase->RX0CP = 0xfffffffc;

  00030	03e01003	 mvneq       r1, #3
  00034	03833002	 orreq       r3, r3, #2
  00038	0584339c	 streq       r3, [r4, #0x39C]
  0003c	05821660	 streq       r1, [r2, #0x660]
  00040	0a0000c5	 beq         |$LN4@RxIntrHand|

; 213  :         return;

  00044	e3a03103	 mov         r3, #3, 2
  00048	e383809a	 orr         r8, r3, #0x9A
  0004c	e3a0a000	 mov         r10, #0
  00050	e3a0900e	 mov         r9, #0xE
  00054		 |$LL33@RxIntrHand|

; 214  :      }   
; 215  :                 
; 216  :     do
; 217  :     {
; 218  :       /* Dequeue buffer from available buffers pool */
; 219  :       QUEUE_REMOVE(&pAdapter->m_RxBufsPool, pCurRxBuf);

  00054	e3a0e000	 mov         lr, #0
  00058	e3740f6f	 cmn         r4, #0x6F, 30
  0005c	0a00000b	 beq         |$LN30@RxIntrHand|
  00060	e59431bc	 ldr         r3, [r4, #0x1BC]
  00064	e1b02003	 movs        r2, r3
  00068	0a000008	 beq         |$LN30@RxIntrHand|
  0006c	e5923000	 ldr         r3, [r2]
  00070	e1a0e002	 mov         lr, r2
  00074	e3530000	 cmp         r3, #0
  00078	e58431bc	 str         r3, [r4, #0x1BC]
  0007c	e59431c4	 ldr         r3, [r4, #0x1C4]
  00080	0584a1c0	 streq       r10, [r4, #0x1C0]
  00084	e2433001	 sub         r3, r3, #1
  00088	e58431c4	 str         r3, [r4, #0x1C4]
  0008c	e582a000	 str         r10, [r2]
  00090		 |$LN30@RxIntrHand|

; 220  :   
; 221  :         pNextRxBuf = (PEMAC_RXBUFS)(pAdapter->m_RxBufsPool.m_pHead);
; 222  : 
; 223  :       /* Extract the EMAC buffer descriptor information */
; 224  :       pCurDesc = (PEMACDESC)pCurRxBuf->m_EmacBufDes;

  00090	e59e3010	 ldr         r3, [lr, #0x10]
  00094	e59471bc	 ldr         r7, [r4, #0x1BC]

; 225  :       Status   = pCurDesc->PktFlgLen;

  00098	e593200c	 ldr         r2, [r3, #0xC]

; 226  :       BufLen   = pCurDesc->BufOffLen & 0xFFFF;

  0009c	e5933008	 ldr         r3, [r3, #8]

; 227  :       
; 228  :         /* Process for bad packet received  */
; 229  :         if ( 0 != (Status & EMAC_DSC_FLAG_SOP ))

  000a0	e2121102	 ands        r1, r2, #2, 2

; 230  :         {
; 231  :             /* Process if a error in packet */
; 232  :             if ( 0 != (Status & EMAC_DSC_RX_ERROR_FRAME ))
; 233  :             {
; 234  :                 DEBUGMSG (DBG_INFO,
; 235  :                     (L"Error in packet \r\n"));
; 236  :             }
; 237  :             /* Process if a teardown happened */
; 238  :             if ( 0 != (Status & EMAC_DSC_FLAG_TDOWNCMPLT ))

  000a4	13120302	 tstne       r2, #2, 6
  000a8	e1a05803	 mov         r5, r3, lsl #16

; 239  :             {
; 240  :                 DEBUGMSG (DBG_INFO,
; 241  :                     (L"Teardown in packet \r\n"));
; 242  :                     
; 243  :                 pAdapter->m_Events |= EMAC_RX_TEARDOWN_EVENT;

  000ac	1594339c	 ldrne       r3, [r4, #0x39C]
  000b0	e1a05825	 mov         r5, r5, lsr #16
  000b4	13833002	 orrne       r3, r3, #2
  000b8	1584339c	 strne       r3, [r4, #0x39C]

; 244  :             }
; 245  :             
; 246  :         }
; 247  :         /* Process for single buffer packets */
; 248  :       
; 249  :         if ( ( 0 != (Status & EMAC_DSC_FLAG_SOP )) &&
; 250  :              ( 0 != (Status & EMAC_DSC_FLAG_EOP )) )                            

  000bc	e3510000	 cmp         r1, #0
  000c0	0a00004b	 beq         |$LN32@RxIntrHand|
  000c4	e3120101	 tst         r2, #1, 2
  000c8	0a000049	 beq         |$LN32@RxIntrHand|

; 251  :         {
; 252  :             /* Deque from available packet pool a fresh packet  */
; 253  :             QUEUE_REMOVE(&pAdapter->m_RxPktPool, pRxPkt);

  000cc	e2943e1b	 adds        r3, r4, #0x1B, 28
  000d0	e3a00000	 mov         r0, #0
  000d4	0a00000b	 beq         |$LN24@RxIntrHand|
  000d8	e59431b0	 ldr         r3, [r4, #0x1B0]
  000dc	e1b02003	 movs        r2, r3
  000e0	0a000008	 beq         |$LN24@RxIntrHand|
  000e4	e5923000	 ldr         r3, [r2]
  000e8	e1a00002	 mov         r0, r2
  000ec	e3530000	 cmp         r3, #0
  000f0	e58431b0	 str         r3, [r4, #0x1B0]
  000f4	e59431b8	 ldr         r3, [r4, #0x1B8]
  000f8	0584a1b4	 streq       r10, [r4, #0x1B4]
  000fc	e2433001	 sub         r3, r3, #1
  00100	e58431b8	 str         r3, [r4, #0x1B8]
  00104	e582a000	 str         r10, [r2]
  00108		 |$LN24@RxIntrHand|

; 254  : 
; 255  :             /* Initialise per packet maintained queue of bufs list */
; 256  :             QUEUE_INIT(&pRxPkt->m_BufsList);

  00108	e580a008	 str         r10, [r0, #8]
  0010c	e580a00c	 str         r10, [r0, #0xC]
  00110	e580a010	 str         r10, [r0, #0x10]

; 257  :             
; 258  :             /* Getting the associated NDIS buffer from RxBuffer pool*/
; 259  :             NdisBuffer = (PNDIS_BUFFER)pCurRxBuf->m_BufHandle;

  00114	e59e3004	 ldr         r3, [lr, #4]
  00118	e58d3000	 str         r3, [sp]

; 260  : 
; 261  :             /* Adjust the buffer length in the NDIS_BUFFER */
; 262  :             NdisAdjustBufferLength( NdisBuffer, BufLen);

  0011c	e5835008	 str         r5, [r3, #8]

; 263  : 
; 264  :             /* Also setting header size */
; 265  :             NDIS_SET_PACKET_HEADER_SIZE((PNDIS_PACKET)pRxPkt->m_PktHandle,
; 266  :                             EMAC_HEADER_SIZE);

  00120	e5901004	 ldr         r1, [r0, #4]

; 267  :             
; 268  :             /* Add it to array of packets */                   
; 269  :             NdisPktsArray[PacketArrayCount] = (PNDIS_PACKET)pRxPkt->m_PktHandle;
; 270  :         
; 271  : 
; 272  :             /* Also insert in to per packet maintained Buffer queue */
; 273  :             QUEUE_INSERT(&pRxPkt->m_BufsList,pCurRxBuf);

  00124	e2903008	 adds        r3, r0, #8
  00128	e28d5004	 add         r5, sp, #4
  0012c	e1d121be	 ldrh        r2, [r1, #0x1E]
  00130	e0823001	 add         r3, r2, r1
  00134	e5839010	 str         r9, [r3, #0x10]
  00138	e5903004	 ldr         r3, [r0, #4]
  0013c	e7a53106	 str         r3, [r5, +r6, lsl #2]!
  00140	0a000009	 beq         |$LN22@RxIntrHand|
  00144	e5903008	 ldr         r3, [r0, #8]
  00148	e3530000	 cmp         r3, #0
  0014c	1590300c	 ldrne       r3, [r0, #0xC]
  00150	0580e008	 streq       lr, [r0, #8]
  00154	1583e000	 strne       lr, [r3]
  00158	e5903010	 ldr         r3, [r0, #0x10]
  0015c	e580e00c	 str         lr, [r0, #0xC]
  00160	e2833001	 add         r3, r3, #1
  00164	e5803010	 str         r3, [r0, #0x10]
  00168	e58ea000	 str         r10, [lr]
  0016c		 |$LN22@RxIntrHand|

; 274  :                   
; 275  :             /* Get the HALPacket associated with this packet */
; 276  :              TempPtr = (PEMAC_RXPKTS *)(((PNDIS_PACKET)pRxPkt->m_PktHandle)->MiniportReserved);
; 277  :              
; 278  :             /* 
; 279  :              * Assign back pointer from the NdisPacket to the
; 280  :              * HALPacket. This will be useful, when NDIS calls
; 281  :              * MiniportGetReturnedPackets function.
; 282  :              */
; 283  :              *TempPtr = pRxPkt;

  0016c	e5903004	 ldr         r3, [r0, #4]
  00170	e5830020	 str         r0, [r3, #0x20]

; 284  :             
; 285  :             /* Add it to packets buffer list */
; 286  :             NdisChainBufferAtFront(NdisPktsArray[PacketArrayCount],
; 287  :                                NdisBuffer);

  00174	e59d2000	 ldr         r2, [sp]
  00178	ea000000	 b           |$LN56@RxIntrHand|
  0017c		 |$LL19@RxIntrHand|
  0017c	e5922000	 ldr         r2, [r2]
  00180		 |$LN56@RxIntrHand|
  00180	e5923000	 ldr         r3, [r2]
  00184	e3530000	 cmp         r3, #0
  00188	1afffffb	 bne         |$LL19@RxIntrHand|
  0018c	e5951000	 ldr         r1, [r5]
  00190	e5913008	 ldr         r3, [r1, #8]
  00194	e3530000	 cmp         r3, #0
  00198	0581200c	 streq       r2, [r1, #0xC]
  0019c	e5953000	 ldr         r3, [r5]
  001a0	e5933008	 ldr         r3, [r3, #8]
  001a4	e5823000	 str         r3, [r2]
  001a8	e5952000	 ldr         r2, [r5]
  001ac	e59d3000	 ldr         r3, [sp]
  001b0	e5823008	 str         r3, [r2, #8]
  001b4	e5953000	 ldr         r3, [r5]
  001b8	e5c3a01c	 strb        r10, [r3, #0x1C]

; 288  :           
; 289  :         
; 290  :             if(PacketArrayCount >= (pAdapter->m_NumRxIndicatePkts -4))

  001bc	e1d432b4	 ldrh        r3, [r4, #0x24]

; 291  :             {
; 292  :                      /* Set status as resources */
; 293  :                     NDIS_SET_PACKET_STATUS(NdisPktsArray[PacketArrayCount],
; 294  :                                                          NDIS_STATUS_RESOURCES );

  001c0	e5952000	 ldr         r2, [r5]
  001c4	e2433004	 sub         r3, r3, #4
  001c8	e1560003	 cmp         r6, r3
  001cc	e1d231be	 ldrh        r3, [r2, #0x1E]
  001d0	e0833002	 add         r3, r3, r2
  001d4	a583801c	 strge       r8, [r3, #0x1C]

; 295  :                             
; 296  :             }       
; 297  :             else
; 298  :             {
; 299  :                 /* Set status as success */
; 300  :                 NDIS_SET_PACKET_STATUS(NdisPktsArray[PacketArrayCount],
; 301  :                                                          NDIS_STATUS_SUCCESS );

  001d8	b583a01c	 strlt       r10, [r3, #0x1C]

; 302  : 
; 303  :             }
; 304  :                  
; 305  :             PacketArrayCount++;
; 306  : 
; 307  :             /* Acknowledge to channel completion register our last processed buffer */
; 308  :             pAdapter->m_pEmacRegsBase->RX0CP = pCurRxBuf->m_EmacBufDesPa;

  001dc	e5941004	 ldr         r1, [r4, #4]
  001e0	e59e3014	 ldr         r3, [lr, #0x14]
  001e4	e2862001	 add         r2, r6, #1
  001e8	e1a06802	 mov         r6, r2, lsl #16
  001ec	e5813660	 str         r3, [r1, #0x660]
  001f0	e1a06826	 mov         r6, r6, lsr #16
  001f4		 |$LN32@RxIntrHand|

; 309  :          } 
; 310  :         
; 311  :     } while ((NULL != pNextRxBuf) &&
; 312  :             (0 ==(EMAC_DSC_FLAG_OWNER & ((PEMACDESC)(pNextRxBuf->m_EmacBufDes))->PktFlgLen)) &&
; 313  :              (PacketArrayCount < NDIS_INDICATE_PKTS));

  001f4	e3570000	 cmp         r7, #0
  001f8	0a000005	 beq         |$LN13@RxIntrHand|
  001fc	e5973010	 ldr         r3, [r7, #0x10]
  00200	e593300c	 ldr         r3, [r3, #0xC]
  00204	e3130202	 tst         r3, #2, 4
  00208	1a000001	 bne         |$LN13@RxIntrHand|
  0020c	e3560c01	 cmp         r6, #1, 24
  00210	3affff8f	 bcc         |$LL33@RxIntrHand|
  00214		 |$LN13@RxIntrHand|

; 314  :        
; 315  :     if (0 == PacketArrayCount)

  00214	e3560000	 cmp         r6, #0
  00218	0a00004f	 beq         |$LN4@RxIntrHand|

; 316  :     {
; 317  :         return;
; 318  :     }
; 319  :     
; 320  :     /* Indicate to NDIS */                        
; 321  :     NdisMIndicateReceivePacket(pAdapter->m_AdapterHandle , 
; 322  :                         NdisPktsArray,
; 323  :                         PacketArrayCount);

  0021c	e5940000	 ldr         r0, [r4]
  00220	e1a02006	 mov         r2, r6
  00224	e28d1004	 add         r1, sp, #4
  00228	e5903108	 ldr         r3, [r0, #0x108]
  0022c	e1a0e00f	 mov         lr, pc
  00230	e12fff13	 bx          r3

; 324  : 
; 325  :     /* Check if the NDIS has returned the ownership of any of
; 326  :      * the packets back to us.
; 327  :      */
; 328  :     for (Index = 0; Index < PacketArrayCount ; Index++ )

  00234	e3a03000	 mov         r3, #0
  00238	e3560000	 cmp         r6, #0
  0023c	0a00002e	 beq         |$LN9@RxIntrHand|
  00240	e3a02c01	 mov         r2, #1, 24
  00244	e3829003	 orr         r9, r2, #3
  00248	e3a08000	 mov         r8, #0
  0024c		 |$LL11@RxIntrHand|
  0024c	e28d7004	 add         r7, sp, #4

; 329  :     {
; 330  :         NDIS_STATUS ReturnStatus;
; 331  :         
; 332  :         ReturnStatus = NDIS_GET_PACKET_STATUS(NdisPktsArray[Index]);

  00250	e7b72103	 ldr         r2, [r7, +r3, lsl #2]!

; 333  :        
; 334  :         /* we can regain ownership of packets only for which pending status is
; 335  :          * not set
; 336  :          */
; 337  :         
; 338  :         if (ReturnStatus != NDIS_STATUS_PENDING)

  00254	e1d231be	 ldrh        r3, [r2, #0x1E]
  00258	e0833002	 add         r3, r3, r2
  0025c	e593301c	 ldr         r3, [r3, #0x1C]
  00260	e1530009	 cmp         r3, r9
  00264	0a00001e	 beq         |$LN10@RxIntrHand|

; 339  :         {
; 340  :             
; 341  :             /* Get the HALPacket associated with this packet */
; 342  :             TempPtr = (PEMAC_RXPKTS *)(NdisPktsArray[Index]->MiniportReserved);
; 343  :              
; 344  :             pTmpRxPkt = *TempPtr; 

  00268	e5925020	 ldr         r5, [r2, #0x20]

; 345  :                 
; 346  :             /* This has every information about packets information like
; 347  :              * buffers chained to it. This will be useful when we are adding
; 348  :              * associated buffers to EMAC buffer descriptor queue
; 349  :              */
; 350  :      
; 351  :             AddBufToRxQueue(pAdapter , pTmpRxPkt);

  0026c	e1a00004	 mov         r0, r4
  00270	e1a01005	 mov         r1, r5
  00274	eb000000	 bl          AddBufToRxQueue

; 352  :             
; 353  :             /* Unchain buffer attached preventing memory leak */
; 354  :             NdisUnchainBufferAtFront(NdisPktsArray[Index],
; 355  :                             &NdisBuffer);

  00278	e5970000	 ldr         r0, [r7]
  0027c	e28d1000	 add         r1, sp, #0
  00280	eb000000	 bl          NdisUnchainBufferAtFront

; 356  : 
; 357  :              /* 
; 358  :               * Reinitialize the NDIS packet for later use.
; 359  :               * This will remove the NdisBuffer Linkage from
; 360  :               * the NDIS Packet.
; 361  :               */
; 362  :             NdisReinitializePacket(NdisPktsArray[Index]);

  00284	e5973000	 ldr         r3, [r7]

; 363  :             
; 364  :             /* Also clearing OOB data */
; 365  :             NdisZeroMemory(NDIS_OOB_DATA_FROM_PACKET(NdisPktsArray[Index]),
; 366  :                            sizeof(NDIS_PACKET_OOB_DATA));

  00288	e3a02020	 mov         r2, #0x20
  0028c	e3a01000	 mov         r1, #0
  00290	e583a008	 str         r10, [r3, #8]
  00294	e5973000	 ldr         r3, [r7]
  00298	e5c3a01c	 strb        r10, [r3, #0x1C]
  0029c	e5970000	 ldr         r0, [r7]
  002a0	e1d031be	 ldrh        r3, [r0, #0x1E]
  002a4	e0830000	 add         r0, r3, r0
  002a8	eb000000	 bl          memset

; 367  :                 
; 368  :             /* Also insert in packet got in to packet pool */
; 369  :             QUEUE_INSERT(&pAdapter->m_RxPktPool,pTmpRxPkt);

  002ac	e2943e1b	 adds        r3, r4, #0x1B, 28
  002b0	0a00000b	 beq         |$LN10@RxIntrHand|
  002b4	e3550000	 cmp         r5, #0
  002b8	0a000009	 beq         |$LN10@RxIntrHand|
  002bc	e59431b0	 ldr         r3, [r4, #0x1B0]
  002c0	e3530000	 cmp         r3, #0
  002c4	159431b4	 ldrne       r3, [r4, #0x1B4]
  002c8	058451b0	 streq       r5, [r4, #0x1B0]
  002cc	15835000	 strne       r5, [r3]
  002d0	e59431b8	 ldr         r3, [r4, #0x1B8]
  002d4	e58451b4	 str         r5, [r4, #0x1B4]
  002d8	e2833001	 add         r3, r3, #1
  002dc	e58431b8	 str         r3, [r4, #0x1B8]
  002e0	e585a000	 str         r10, [r5]
  002e4		 |$LN10@RxIntrHand|
  002e4	e2883001	 add         r3, r8, #1
  002e8	e1a03803	 mov         r3, r3, lsl #16
  002ec	e1a03823	 mov         r3, r3, lsr #16
  002f0	e1a08003	 mov         r8, r3
  002f4	e1530006	 cmp         r3, r6
  002f8	3affffd3	 bcc         |$LL11@RxIntrHand|
  002fc		 |$LN9@RxIntrHand|

; 370  :         }
; 371  :     }  
; 372  : 
; 373  :     /* Check for race condition - null RX0HDP and no EOQ flagged.  This appears to arise 
; 374  :        when the EOQ flag is set on the tail BD some time after the null 'next' pointer
; 375  :        is read by the EMAC.  If our EOQ check occurs after the 'next' pointer is set but 
; 376  :        before the EOQ flag is set by the EMAC then RX0HDP does not get reset. */
; 377  :     RXTailDescVa = ((PEMAC_RXBUFS)(pAdapter->m_RxBufsPool.m_pTail))->m_EmacBufDes;
; 378  :     if (pAdapter->m_pEmacRegsBase->RX0HDP == 0 &&
; 379  :         (((PEMACDESC)(RXTailDescVa))->PktFlgLen & EMAC_DSC_FLAG_EOQ) == 0)

  002fc	e5940004	 ldr         r0, [r4, #4]
  00300	e5903620	 ldr         r3, [r0, #0x620]
  00304	e3530000	 cmp         r3, #0
  00308	1a000013	 bne         |$LN4@RxIntrHand|
  0030c	e59431c0	 ldr         r3, [r4, #0x1C0]
  00310	e5933010	 ldr         r3, [r3, #0x10]
  00314	e593300c	 ldr         r3, [r3, #0xC]
  00318	e3130201	 tst         r3, #1, 4
  0031c	1a00000e	 bne         |$LN4@RxIntrHand|

; 380  :     {
; 381  :         /* Find the first free packet in the queue */
; 382  :         pCurRxBuf = (PEMAC_RXBUFS)(pAdapter->m_RxBufsPool.m_pHead);

  00320	e59411bc	 ldr         r1, [r4, #0x1BC]
  00324	e1b02001	 movs        r2, r1

; 383  :         while (pCurRxBuf && 0 == (((PEMACDESC)pCurRxBuf->m_EmacBufDes)->PktFlgLen & EMAC_DSC_FLAG_OWNER))

  00328	0a000008	 beq         |$LN46@RxIntrHand|
  0032c		 |$LL3@RxIntrHand|
  0032c	e5923010	 ldr         r3, [r2, #0x10]
  00330	e593300c	 ldr         r3, [r3, #0xC]
  00334	e3130202	 tst         r3, #2, 4
  00338	1a000002	 bne         |$LN2@RxIntrHand|

; 384  :         {
; 385  :             pCurRxBuf = (PEMAC_RXBUFS)(pCurRxBuf->m_pNext);

  0033c	e5923000	 ldr         r3, [r2]
  00340	e1b02003	 movs        r2, r3
  00344	1afffff8	 bne         |$LL3@RxIntrHand|
  00348		 |$LN2@RxIntrHand|

; 386  :         }
; 387  :         if (!pCurRxBuf)

  00348	e3520000	 cmp         r2, #0
  0034c	1a000000	 bne         |$LN1@RxIntrHand|
  00350		 |$LN46@RxIntrHand|

; 388  :         {
; 389  :             pCurRxBuf = (PEMAC_RXBUFS)(pAdapter->m_RxBufsPool.m_pHead);

  00350	e1a02001	 mov         r2, r1
  00354		 |$LN1@RxIntrHand|

; 390  :         }
; 391  :         pAdapter->m_pEmacRegsBase->RX0HDP = pCurRxBuf->m_EmacBufDesPa;

  00354	e5923014	 ldr         r3, [r2, #0x14]
  00358	e5803620	 str         r3, [r0, #0x620]
  0035c		 |$LN4@RxIntrHand|

; 392  :     }
; 393  : 
; 394  :     DEBUGMSG(DBG_FUNC,(L"<--RxIntrHandler\r\n"));
; 395  : }

  0035c	e3a0cb01	 mov         r12, #1, 22
  00360	e38cc004	 orr         r12, r12, #4
  00364	e08dd00c	 add         sp, sp, r12
  00368	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  0036c	e12fff1e	 bx          lr
  00370		 |$LN60@RxIntrHand|
  00370		 |$LN61@RxIntrHand|
  00370	fffffbfc	 DCD         0xfffffbfc
  00374		 |$M50777|

			 ENDP  ; |RxIntrHandler|

	EXPORT	|TxIntrHandler|

  00000			 AREA	 |.pdata|, PDATA
|$T50810| DCD	|$LN38@TxIntrHand|
	DCD	0x40008502
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TxIntrHandler| PROC

; 407  : {

  00000		 |$LN38@TxIntrHand|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M50807|
  00008	e1a04000	 mov         r4, r0
  0000c	e58d4000	 str         r4, [sp]

; 408  :     PEMAC_ADAPTER       pAdapter;
; 409  :     PQUEUE_T            QBufsList; 
; 410  :     PEMACDESC           pHeadTxDescPa;
; 411  :     PEMACDESC           pTailTxDescPa;
; 412  :     PEMACDESC           pSOPTxDesc;
; 413  :     PEMACDESC           pEOPTxDesc;
; 414  :     PEMAC_TXPKT         pCurPktInfo;
; 415  :     PEMACDESC           pCurTxDescVa;
; 416  :     PEMACDESC           pBufTailDescVa;
; 417  :     PEMAC_TXBUF         pNextTxBuf;
; 418  :     PEMAC_TXBUF         pCurTxBuf;
; 419  :     PEMAC_TXBUF         TxHeadBuf;
; 420  :     ULONG               Count;
; 421  :     ULONG               Status;
; 422  : 
; 423  :     DEBUGMSG (DBG_FUNC,(L"-->TxIntrHandler\r\n"));
; 424  : 
; 425  :     pAdapter = (PEMAC_ADAPTER)MiniportAdapterContext;      
; 426  :     
; 427  :      /* Acquire the send lock */
; 428  :     NdisAcquireSpinLock(&pAdapter->m_SendLock); 

  00010	e284006c	 add         r0, r4, #0x6C
  00014	eb000000	 bl          NdisAcquireSpinLock

; 429  :     /* Check if it is teardown interrupt then clear it 
; 430  :      * and return 
; 431  :      */
; 432  :     if(0xfffffffc == pAdapter->m_pEmacRegsBase->TX0CP)

  00018	e5942004	 ldr         r2, [r4, #4]
  0001c	e5923640	 ldr         r3, [r2, #0x640]
  00020	e3730004	 cmn         r3, #4

; 433  :     {
; 434  :         pAdapter->m_Events |= EMAC_TX_TEARDOWN_EVENT;

  00024	0594339c	 ldreq       r3, [r4, #0x39C]

; 435  :         pAdapter->m_pEmacRegsBase->TX0CP = 0xfffffffc;

  00028	03e01003	 mvneq       r1, #3
  0002c	03833001	 orreq       r3, r3, #1
  00030	0584339c	 streq       r3, [r4, #0x39C]
  00034	05821640	 streq       r1, [r2, #0x640]
  00038	0a000070	 beq         |$end$50426|

; 436  :         goto end;

  0003c	e3a03c05	 mov         r3, #5, 24
  00040	e59d9000	 ldr         r9, [sp]
  00044	e383b0ea	 orr         r11, r3, #0xEA
  00048		 |$LN35@TxIntrHand|

; 437  :     } 
; 438  :                 
; 439  :     do
; 440  :     {
; 441  :         if(0 == QUEUE_COUNT(&pAdapter->m_TxPostedPktPool))

  00048	e59431e8	 ldr         r3, [r4, #0x1E8]
  0004c	e3a0e000	 mov         lr, #0
  00050	e1b01003	 movs        r1, r3
  00054	0a000069	 beq         |$end$50426|

; 442  :         {
; 443  :           DEBUGMSG (DBG_INFO,(L"Got Tx interrupt without packet posted \r\n"));  
; 444  :           goto end;
; 445  :         
; 446  :         }
; 447  :         /* Dequeue packet from already  posted packets  pool */
; 448  :         QUEUE_REMOVE(&pAdapter->m_TxPostedPktPool, pCurPktInfo);

  00058	e2943e1e	 adds        r3, r4, #0x1E, 28
  0005c	e3a05000	 mov         r5, #0
  00060	0a00000a	 beq         |$LN16@TxIntrHand|
  00064	e59431e0	 ldr         r3, [r4, #0x1E0]
  00068	e1b02003	 movs        r2, r3
  0006c	0a000007	 beq         |$LN16@TxIntrHand|
  00070	e5923000	 ldr         r3, [r2]
  00074	e1a05002	 mov         r5, r2
  00078	e3530000	 cmp         r3, #0
  0007c	e58431e0	 str         r3, [r4, #0x1E0]
  00080	e2413001	 sub         r3, r1, #1
  00084	e58431e8	 str         r3, [r4, #0x1E8]
  00088	0584e1e4	 streq       lr, [r4, #0x1E4]
  0008c	e582e000	 str         lr, [r2]
  00090		 |$LN16@TxIntrHand|

; 449  :             
; 450  :         /* Extract the EMAC buffer descriptor information */
; 451  :         QBufsList      = &pCurPktInfo->m_BufsList;

  00090	e1a06005	 mov         r6, r5

; 452  :         pHeadTxDescPa  = (PEMACDESC)((PEMAC_TXBUF)(QBufsList->m_pHead))->m_EmacBufDesPa;

  00094	e5b63008	 ldr         r3, [r6, #8]!

; 453  :         pTailTxDescPa  = (PEMACDESC)((PEMAC_TXBUF)(QBufsList->m_pTail))->m_EmacBufDesPa;
; 454  :         
; 455  :         pSOPTxDesc    = (PEMACDESC)((PEMAC_TXBUF)(QBufsList->m_pHead))->m_EmacBufDes;
; 456  :         pEOPTxDesc    = (PEMACDESC)((PEMAC_TXBUF)(QBufsList->m_pTail))->m_EmacBufDes; 
; 457  : 
; 458  :         Status   = pSOPTxDesc->PktFlgLen;

  00098	e5932010	 ldr         r2, [r3, #0x10]
  0009c	e593a014	 ldr         r10, [r3, #0x14]
  000a0	e5961004	 ldr         r1, [r6, #4]
  000a4	e592300c	 ldr         r3, [r2, #0xC]
  000a8	e5910014	 ldr         r0, [r1, #0x14]
  000ac	e5912010	 ldr         r2, [r1, #0x10]

; 459  :         /* Extract the flags and see if teardown has happened */
; 460  :         
; 461  :         if ( 0 != (Status & EMAC_DSC_FLAG_SOP ))

  000b0	e3130102	 tst         r3, #2, 2
  000b4	0a000001	 beq         |$LN13@TxIntrHand|

; 462  :         {
; 463  :             /* Process if a teardown happened */
; 464  :             if ( 0 != (Status & EMAC_DSC_FLAG_TDOWNCMPLT ))

  000b8	e3130302	 tst         r3, #2, 6
  000bc	1a00004c	 bne         |$LN27@TxIntrHand|
  000c0		 |$LN13@TxIntrHand|

; 469  :             goto end;
; 470  :             
; 471  :             }
; 472  :         }
; 473  : 
; 474  :         Status   = pEOPTxDesc->PktFlgLen;
; 475  : 
; 476  :         if ( 0 != (Status & EMAC_DSC_FLAG_EOQ ))

  000c0	e592300c	 ldr         r3, [r2, #0xC]
  000c4	e3130201	 tst         r3, #1, 4

; 477  :         {
; 478  :             /* Queue has been halted Let others can proceed if there is/are any */
; 479  :             if(0 != QUEUE_COUNT(&pAdapter->m_TxPostedPktPool))

  000c8	159431e8	 ldrne       r3, [r4, #0x1E8]
  000cc	13530000	 cmpne       r3, #0

; 480  :             {
; 481  :                 TxHeadBuf = (PEMAC_TXBUF)(((PEMAC_TXPKT)(pAdapter->m_TxPostedPktPool.m_pHead))->m_BufsList).m_pHead; 
; 482  :                 pAdapter->m_pEmacRegsBase->TX0HDP = TxHeadBuf->m_EmacBufDesPa;

  000d0	159431e0	 ldrne       r3, [r4, #0x1E0]
  000d4	15942004	 ldrne       r2, [r4, #4]
  000d8	15933008	 ldrne       r3, [r3, #8]
  000dc	15933014	 ldrne       r3, [r3, #0x14]
  000e0	15823600	 strne       r3, [r2, #0x600]

; 483  :             }
; 484  :          }
; 485  :         /* Acknowledge to channel completion register our last processed buffer */
; 486  :         
; 487  :         pAdapter->m_pEmacRegsBase->TX0CP = (UINT32)pTailTxDescPa;

  000e4	e5942004	 ldr         r2, [r4, #4]

; 488  : 
; 489  :         DEBUGMSG(DBG_INFO, (L"pCurPktInfo->m_PktHandle %08x TX0CP %08x \r\n",
; 490  :             pCurPktInfo->m_PktHandle,pTailTxDescPa));
; 491  :     
; 492  : 
; 493  :         /* We can reuse this  packet info structure */                       
; 494  :         QUEUE_INSERT(&pAdapter->m_TxPktsInfoPool,pCurPktInfo);

  000e8	e2943f75	 adds        r3, r4, #0x75, 30
  000ec	e5820640	 str         r0, [r2, #0x640]
  000f0	0a00000b	 beq         |$LN10@TxIntrHand|
  000f4	e3550000	 cmp         r5, #0
  000f8	0a000009	 beq         |$LN10@TxIntrHand|
  000fc	e59431d4	 ldr         r3, [r4, #0x1D4]
  00100	e3530000	 cmp         r3, #0
  00104	159431d8	 ldrne       r3, [r4, #0x1D8]
  00108	058451d4	 streq       r5, [r4, #0x1D4]
  0010c	15835000	 strne       r5, [r3]
  00110	e59431dc	 ldr         r3, [r4, #0x1DC]
  00114	e58451d8	 str         r5, [r4, #0x1D8]
  00118	e2833001	 add         r3, r3, #1
  0011c	e58431dc	 str         r3, [r4, #0x1DC]
  00120	e585e000	 str         lr, [r5]
  00124		 |$LN10@TxIntrHand|

; 495  :         
; 496  :         /* We can also reuse associated Tx buffers also 
; 497  :          * But before that we have to recycle the descriptor 
; 498  :          * information 
; 499  :          */
; 500  :         pNextTxBuf=(PEMAC_TXBUF)(QBufsList->m_pHead);
; 501  :         
; 502  :         for(Count = QBufsList->m_Count; Count != 0 ;Count--)

  00124	e5963008	 ldr         r3, [r6, #8]
  00128	e5967000	 ldr         r7, [r6]
  0012c	e1b08003	 movs        r8, r3
  00130	0a00000d	 beq         |$LN5@TxIntrHand|
  00134	e3a04000	 mov         r4, #0
  00138		 |$LL7@TxIntrHand|

; 503  :         {
; 504  :             pCurTxBuf                   = pNextTxBuf;
; 505  :             pCurTxDescVa                = (PEMACDESC)pCurTxBuf->m_EmacBufDes;

  00138	e5979010	 ldr         r9, [r7, #0x10]

; 506  :             pCurTxDescVa->pBuffer       = 0;
; 507  :             pCurTxDescVa->BufOffLen     = EMAC_MAX_ETHERNET_PKT_SIZE;
; 508  :             pCurTxDescVa->PktFlgLen     = 0;
; 509  : 
; 510  :             NdisZeroMemory((PVOID)(pCurTxBuf->m_BufLogicalAddress),
; 511  :                                 EMAC_MAX_ETHERNET_PKT_SIZE);

  0013c	e1a0200b	 mov         r2, r11
  00140	e3a01000	 mov         r1, #0
  00144	e5894004	 str         r4, [r9, #4]
  00148	e589b008	 str         r11, [r9, #8]
  0014c	e589400c	 str         r4, [r9, #0xC]
  00150	e5970008	 ldr         r0, [r7, #8]
  00154	eb000000	 bl          memset

; 512  :             pNextTxBuf = (PEMAC_TXBUF)((PSLINK_T)pCurTxBuf)->m_pLink;

  00158	e5977000	 ldr         r7, [r7]
  0015c	e2588001	 subs        r8, r8, #1
  00160	1afffff4	 bne         |$LL7@TxIntrHand|
  00164	e59d4000	 ldr         r4, [sp]
  00168	e3a0e000	 mov         lr, #0
  0016c		 |$LN5@TxIntrHand|

; 513  :             
; 514  :         }
; 515  :         pCurTxDescVa->pNext = 0;  

  0016c	e589e000	 str         lr, [r9]

; 516  :         /* Also relinking chain */
; 517  :         if(0 != QUEUE_COUNT(&pAdapter->m_TxBufInfoPool))

  00170	e59431d0	 ldr         r3, [r4, #0x1D0]
  00174	e3530000	 cmp         r3, #0

; 518  :         {
; 519  :             pBufTailDescVa =(PEMACDESC)((PEMAC_TXBUF)(pAdapter->m_TxBufInfoPool.m_pTail))->m_EmacBufDes;
; 520  :             pBufTailDescVa->pNext = pHeadTxDescPa;

  00178	159431cc	 ldrne       r3, [r4, #0x1CC]
  0017c	15933010	 ldrne       r3, [r3, #0x10]
  00180	1583a000	 strne       r10, [r3]

; 521  :         }
; 522  :         
; 523  :         QUEUE_INSERT_QUEUE(&pAdapter->m_TxBufInfoPool,QBufsList);

  00184	e2943f72	 adds        r3, r4, #0x72, 30
  00188	0a00000a	 beq         |$LN3@TxIntrHand|
  0018c	e59431cc	 ldr         r3, [r4, #0x1CC]
  00190	e1b02003	 movs        r2, r3
  00194	e5963000	 ldr         r3, [r6]
  00198	15823000	 strne       r3, [r2]
  0019c	058431c8	 streq       r3, [r4, #0x1C8]
  001a0	e5963004	 ldr         r3, [r6, #4]
  001a4	e59421d0	 ldr         r2, [r4, #0x1D0]
  001a8	e58431cc	 str         r3, [r4, #0x1CC]
  001ac	e5963008	 ldr         r3, [r6, #8]
  001b0	e0833002	 add         r3, r3, r2
  001b4	e58431d0	 str         r3, [r4, #0x1D0]
  001b8		 |$LN3@TxIntrHand|

; 524  :         NdisReleaseSpinLock(&pAdapter->m_SendLock);

  001b8	e284006c	 add         r0, r4, #0x6C
  001bc	eb000000	 bl          NdisReleaseSpinLock

; 525  : 
; 526  :         NdisMSendComplete(pAdapter->m_AdapterHandle, 
; 527  :                         pCurPktInfo->m_PktHandle,
; 528  :                         NDIS_STATUS_SUCCESS);

  001c0	e5940000	 ldr         r0, [r4]
  001c4	e5951004	 ldr         r1, [r5, #4]
  001c8	e3a02000	 mov         r2, #0
  001cc	e590310c	 ldr         r3, [r0, #0x10C]
  001d0	e1a0e00f	 mov         lr, pc
  001d4	e12fff13	 bx          r3

; 529  :                         
; 530  :         NdisAcquireSpinLock(&pAdapter->m_SendLock); 

  001d8	e284006c	 add         r0, r4, #0x6C
  001dc	eb000000	 bl          NdisAcquireSpinLock

; 531  :         
; 532  :     } while (0 != (BIT(0) & pAdapter->m_pEmacRegsBase->TXINTSTATMASKED));

  001e0	e5943004	 ldr         r3, [r4, #4]
  001e4	e5933084	 ldr         r3, [r3, #0x84]
  001e8	e3130001	 tst         r3, #1
  001ec	0a000003	 beq         |$end$50426|
  001f0	eaffff94	 b           |$LN35@TxIntrHand|
  001f4		 |$LN27@TxIntrHand|

; 465  :             {
; 466  :             DEBUGMSG (DBG_INFO,(L"Teardown in packet \r\n"));
; 467  :         
; 468  :             pAdapter->m_Events |= EMAC_TX_TEARDOWN_EVENT;

  001f4	e594339c	 ldr         r3, [r4, #0x39C]
  001f8	e3833001	 orr         r3, r3, #1
  001fc	e584339c	 str         r3, [r4, #0x39C]
  00200		 |$end$50426|

; 533  : 
; 534  : 
; 535  :     DEBUGMSG (DBG_FUNC,(L"<--TxIntrHandler\r\n"));
; 536  : 
; 537  : end:
; 538  :     NdisReleaseSpinLock(&pAdapter->m_SendLock);

  00200	e284006c	 add         r0, r4, #0x6C
  00204	eb000000	 bl          NdisReleaseSpinLock

; 539  : }

  00208	e28dd004	 add         sp, sp, #4
  0020c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00210	e12fff1e	 bx          lr
  00214		 |$M50808|

			 ENDP  ; |TxIntrHandler|

	EXPORT	|UpdateStatInfoByCount|

  00000			 AREA	 |.pdata|, PDATA
|$T50858| DCD	|$LN57@UpdateStat|
	DCD	0x40005e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UpdateStatInfoByCount| PROC

; 555  : {

  00000		 |$LN57@UpdateStat|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M50855|
  00004	e1a0e001	 mov         lr, r1

; 556  :     /* Updating only the driver required statistics info from EMAC statistics
; 557  :      * Register value using count
; 558  :      */
; 559  :       
; 560  :     
; 561  :     switch(StatReg)

  00008	e3520023	 cmp         r2, #0x23
  0000c	8a000057	 bhi         |$LN1@UpdateStat|
  00010	e1a03082	 mov         r3, r2, lsl #1
  00014	e083300f	 add         r3, r3, pc
  00018	e1d330b4	 ldrh        r3, [r3, #4]
  0001c	e08ff003	 add         pc, pc, r3
  00020		 |$LN18@UpdateStat|
  00020		 |$LN17@UpdateStat|
  00020		 |$LN19@UpdateStat|
  00020	0044		 DCW         0x44
  00022		 |$LN20@UpdateStat|
  00022	014c		 DCW         0x14c
  00024		 |$LN21@UpdateStat|
  00024	014c		 DCW         0x14c
  00026		 |$LN22@UpdateStat|
  00026	014c		 DCW         0x14c
  00028		 |$LN23@UpdateStat|
  00028	006c		 DCW         0x6c
  0002a		 |$LN24@UpdateStat|
  0002a	005c		 DCW         0x5c
  0002c		 |$LN25@UpdateStat|
  0002c	006c		 DCW         0x6c
  0002e		 |$LN26@UpdateStat|
  0002e	006c		 DCW         0x6c
  00030		 |$LN27@UpdateStat|
  00030	006c		 DCW         0x6c
  00032		 |$LN28@UpdateStat|
  00032	014c		 DCW         0x14c
  00034		 |$LN29@UpdateStat|
  00034	014c		 DCW         0x14c
  00036		 |$LN30@UpdateStat|
  00036	014c		 DCW         0x14c
  00038		 |$LN31@UpdateStat|
  00038	014c		 DCW         0x14c
  0003a		 |$LN32@UpdateStat|
  0003a	0084		 DCW         0x84
  0003c		 |$LN33@UpdateStat|
  0003c	014c		 DCW         0x14c
  0003e		 |$LN34@UpdateStat|
  0003e	014c		 DCW         0x14c
  00040		 |$LN35@UpdateStat|
  00040	014c		 DCW         0x14c
  00042		 |$LN36@UpdateStat|
  00042	009c		 DCW         0x9c
  00044		 |$LN37@UpdateStat|
  00044	014c		 DCW         0x14c
  00046		 |$LN38@UpdateStat|
  00046	00b4		 DCW         0xb4
  00048		 |$LN39@UpdateStat|
  00048	00cc		 DCW         0xcc
  0004a		 |$LN40@UpdateStat|
  0004a	00e4		 DCW         0xe4
  0004c		 |$LN41@UpdateStat|
  0004c	00fc		 DCW         0xfc
  0004e		 |$LN42@UpdateStat|
  0004e	014c		 DCW         0x14c
  00050		 |$LN43@UpdateStat|
  00050	00fc		 DCW         0xfc
  00052		 |$LN44@UpdateStat|
  00052	014c		 DCW         0x14c
  00054		 |$LN45@UpdateStat|
  00054	014c		 DCW         0x14c
  00056		 |$LN46@UpdateStat|
  00056	014c		 DCW         0x14c
  00058		 |$LN47@UpdateStat|
  00058	014c		 DCW         0x14c
  0005a		 |$LN48@UpdateStat|
  0005a	014c		 DCW         0x14c
  0005c		 |$LN49@UpdateStat|
  0005c	014c		 DCW         0x14c
  0005e		 |$LN50@UpdateStat|
  0005e	014c		 DCW         0x14c
  00060		 |$LN51@UpdateStat|
  00060	014c		 DCW         0x14c
  00062		 |$LN52@UpdateStat|
  00062	0114		 DCW         0x114
  00064		 |$LN53@UpdateStat|
  00064	0114		 DCW         0x114
  00066		 |$LN54@UpdateStat|
  00066	012c		 DCW         0x12c
  00068		 |$LN12@UpdateStat|

; 562  :     {
; 563  :         case 0:
; 564  :             EmacStatInfo->m_RxOKFrames += *StatRegVal;   

  00068	e5902004	 ldr         r2, [r0, #4]
  0006c	e59e3000	 ldr         r3, [lr]
  00070	e0823003	 add         r3, r2, r3
  00074	e5803004	 str         r3, [r0, #4]

; 607  :             break;  
; 608  :                    
; 609  :        default:
; 610  :            break;
; 611  :     }  
; 612  :         
; 613  : }    

  00078	e49de004	 ldr         lr, [sp], #4
  0007c	e12fff1e	 bx          lr
  00080		 |$LN11@UpdateStat|

; 565  :             break;
; 566  :         
; 567  :         case 5:
; 568  :             EmacStatInfo->m_RxAlignErrorFrames += *StatRegVal;   

  00080	e5902014	 ldr         r2, [r0, #0x14]
  00084	e59e3000	 ldr         r3, [lr]
  00088	e0823003	 add         r3, r2, r3
  0008c	e5803014	 str         r3, [r0, #0x14]
  00090		 |$LN10@UpdateStat|

; 569  :         case 4:
; 570  :         case 6:
; 571  :         case 7:
; 572  :         case 8:
; 573  :              EmacStatInfo->m_RxErrorframes += *StatRegVal;   

  00090	e590200c	 ldr         r2, [r0, #0xC]
  00094	e59e3000	 ldr         r3, [lr]
  00098	e0823003	 add         r3, r2, r3
  0009c	e580300c	 str         r3, [r0, #0xC]

; 607  :             break;  
; 608  :                    
; 609  :        default:
; 610  :            break;
; 611  :     }  
; 612  :         
; 613  : }    

  000a0	e49de004	 ldr         lr, [sp], #4
  000a4	e12fff1e	 bx          lr
  000a8		 |$LN9@UpdateStat|

; 574  :              break;
; 575  :         
; 576  :         case 13:
; 577  :             EmacStatInfo->m_TxOKFrames += *StatRegVal;   

  000a8	e5902000	 ldr         r2, [r0]
  000ac	e59e3000	 ldr         r3, [lr]
  000b0	e0823003	 add         r3, r2, r3
  000b4	e5803000	 str         r3, [r0]

; 607  :             break;  
; 608  :                    
; 609  :        default:
; 610  :            break;
; 611  :     }  
; 612  :         
; 613  : }    

  000b8	e49de004	 ldr         lr, [sp], #4
  000bc	e12fff1e	 bx          lr
  000c0		 |$LN8@UpdateStat|

; 578  :             break;
; 579  :         case 17:
; 580  :             EmacStatInfo->m_TxDeferred += *StatRegVal;   

  000c0	e5902020	 ldr         r2, [r0, #0x20]
  000c4	e59e3000	 ldr         r3, [lr]
  000c8	e0823003	 add         r3, r2, r3
  000cc	e5803020	 str         r3, [r0, #0x20]

; 607  :             break;  
; 608  :                    
; 609  :        default:
; 610  :            break;
; 611  :     }  
; 612  :         
; 613  : }    

  000d0	e49de004	 ldr         lr, [sp], #4
  000d4	e12fff1e	 bx          lr
  000d8		 |$LN7@UpdateStat|

; 581  :             break;
; 582  :         
; 583  :                 
; 584  :         case 19:
; 585  :             EmacStatInfo->m_TxOneColl += *StatRegVal;   

  000d8	e5902018	 ldr         r2, [r0, #0x18]
  000dc	e59e3000	 ldr         r3, [lr]
  000e0	e0823003	 add         r3, r2, r3
  000e4	e5803018	 str         r3, [r0, #0x18]

; 607  :             break;  
; 608  :                    
; 609  :        default:
; 610  :            break;
; 611  :     }  
; 612  :         
; 613  : }    

  000e8	e49de004	 ldr         lr, [sp], #4
  000ec	e12fff1e	 bx          lr
  000f0		 |$LN6@UpdateStat|

; 586  :             break;
; 587  :             
; 588  :         case 20:    
; 589  :             EmacStatInfo->m_TxMoreColl += *StatRegVal;   

  000f0	e590201c	 ldr         r2, [r0, #0x1C]
  000f4	e59e3000	 ldr         r3, [lr]
  000f8	e0823003	 add         r3, r2, r3
  000fc	e580301c	 str         r3, [r0, #0x1C]

; 607  :             break;  
; 608  :                    
; 609  :        default:
; 610  :            break;
; 611  :     }  
; 612  :         
; 613  : }    

  00100	e49de004	 ldr         lr, [sp], #4
  00104	e12fff1e	 bx          lr
  00108		 |$LN5@UpdateStat|

; 590  :             break;
; 591  :             
; 592  :         case 21:
; 593  :             EmacStatInfo->m_TxMaxColl += *StatRegVal;

  00108	e5902024	 ldr         r2, [r0, #0x24]
  0010c	e59e3000	 ldr         r3, [lr]
  00110	e0823003	 add         r3, r2, r3
  00114	e5803024	 str         r3, [r0, #0x24]

; 607  :             break;  
; 608  :                    
; 609  :        default:
; 610  :            break;
; 611  :     }  
; 612  :         
; 613  : }    

  00118	e49de004	 ldr         lr, [sp], #4
  0011c	e12fff1e	 bx          lr
  00120		 |$LN4@UpdateStat|

; 594  :             break;
; 595  :         case 22:
; 596  :         case 24:     
; 597  :             EmacStatInfo->m_TxErrorframes += *StatRegVal;   

  00120	e5902008	 ldr         r2, [r0, #8]
  00124	e59e3000	 ldr         r3, [lr]
  00128	e0823003	 add         r3, r2, r3
  0012c	e5803008	 str         r3, [r0, #8]

; 607  :             break;  
; 608  :                    
; 609  :        default:
; 610  :            break;
; 611  :     }  
; 612  :         
; 613  : }    

  00130	e49de004	 ldr         lr, [sp], #4
  00134	e12fff1e	 bx          lr
  00138		 |$LN3@UpdateStat|

; 598  :             break;  
; 599  :         case 33:
; 600  :         case 34:
; 601  :             EmacStatInfo->m_RxOverRun += *StatRegVal;

  00138	e5902028	 ldr         r2, [r0, #0x28]
  0013c	e59e3000	 ldr         r3, [lr]
  00140	e0823003	 add         r3, r2, r3
  00144	e5803028	 str         r3, [r0, #0x28]

; 607  :             break;  
; 608  :                    
; 609  :        default:
; 610  :            break;
; 611  :     }  
; 612  :         
; 613  : }    

  00148	e49de004	 ldr         lr, [sp], #4
  0014c	e12fff1e	 bx          lr
  00150		 |$LN2@UpdateStat|

; 602  :             break;
; 603  :                   
; 604  :         case 35:
; 605  :             EmacStatInfo->m_RxOverRun += *StatRegVal;     

  00150	e5902028	 ldr         r2, [r0, #0x28]
  00154	e59e3000	 ldr         r3, [lr]

; 606  :             EmacStatInfo->m_RxNoBufFrames += *StatRegVal;   

  00158	e5901010	 ldr         r1, [r0, #0x10]
  0015c	e0823003	 add         r3, r2, r3
  00160	e5803028	 str         r3, [r0, #0x28]
  00164	e59e3000	 ldr         r3, [lr]
  00168	e0813003	 add         r3, r1, r3
  0016c	e5803010	 str         r3, [r0, #0x10]
  00170		 |$LN1@UpdateStat|

; 607  :             break;  
; 608  :                    
; 609  :        default:
; 610  :            break;
; 611  :     }  
; 612  :         
; 613  : }    

  00170	e49de004	 ldr         lr, [sp], #4
  00174	e12fff1e	 bx          lr
  00178		 |$M50856|

			 ENDP  ; |UpdateStatInfoByCount|

	EXPORT	|StatIntrHandler|
	EXPORT	|??_C@_1CI@DPPLPAEF@?$AAS?$AAt?$AAa?$AAt?$AA?5?$AAr?$AAe?$AAg?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|NKDbgPrintfW|

  00000			 AREA	 |.pdata|, PDATA
|$T50872| DCD	|$LN15@StatIntrHa|
	DCD	0x40002001

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@DPPLPAEF@?$AAS?$AAt?$AAa?$AAt?$AA?5?$AAr?$AAe?$AAg?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "S"
	DCB	0x0, "t", 0x0, "a", 0x0, "t", 0x0, " ", 0x0, "r", 0x0, "e"
	DCB	0x0, "g", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ":", 0x0, " "
	DCB	0x0, "0", 0x0, "x", 0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |StatIntrHandler| PROC

; 626  : {

  00000		 |$LN15@StatIntrHa|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M50869|
  00004	e1a06000	 mov         r6, r0

; 627  :     PEMAC_ADAPTER   pAdapter;
; 628  :     PDWORD          TempStatReg;  
; 629  :     PDWORD          StatRegStart;
; 630  :     USHORT          Count;
; 631  :     
; 632  :     pAdapter = (PEMAC_ADAPTER)MiniportAdapterContext;
; 633  :     
; 634  :     StatRegStart = (PDWORD)&(pAdapter->m_pEmacRegsBase->RXGOODFRAMES);

  00008	e5963004	 ldr         r3, [r6, #4]

; 635  :     
; 636  :     TempStatReg = StatRegStart;
; 637  :      
; 638  :     for(Count = 0 ;Count < EMAC_STATS_REGS ; Count++)

  0000c	e3a05000	 mov         r5, #0
  00010	e2834c02	 add         r4, r3, #2, 24
  00014		 |$LL6@StatIntrHa|

; 639  :     {
; 640  :         if( 0x80000000 <= INREG32(TempStatReg))

  00014	e5943000	 ldr         r3, [r4]
  00018	e3530102	 cmp         r3, #2, 2
  0001c	2a000006	 bcs         |$LN10@StatIntrHa|
  00020	e2853001	 add         r3, r5, #1
  00024	e1a05803	 mov         r5, r3, lsl #16
  00028	e1a05825	 mov         r5, r5, lsr #16
  0002c	e3550024	 cmp         r5, #0x24

; 643  :             break;
; 644  :         }
; 645  :         
; 646  :         TempStatReg++;      

  00030	e2844004	 add         r4, r4, #4
  00034	3afffff6	 bcc         |$LL6@StatIntrHa|

; 639  :     {
; 640  :         if( 0x80000000 <= INREG32(TempStatReg))

  00038	ea000003	 b           |$LN4@StatIntrHa|
  0003c		 |$LN10@StatIntrHa|

; 641  :         {
; 642  :             RETAILMSG(1,(TEXT("Stat reg %d: 0x%x\r\n"),Count,INREG32(TempStatReg)));

  0003c	e5942000	 ldr         r2, [r4]
  00040	e59f0034	 ldr         r0, [pc, #0x34]
  00044	e1a01005	 mov         r1, r5
  00048	eb000000	 bl          NKDbgPrintfW
  0004c		 |$LN4@StatIntrHa|

; 647  :     }
; 648  :     
; 649  :     /* Updating driver maintained structures */
; 650  :     UpdateStatInfoByCount(&pAdapter->m_EmacStatInfo ,TempStatReg , Count);

  0004c	e1a02005	 mov         r2, r5
  00050	e1a01004	 mov         r1, r4
  00054	e2860e37	 add         r0, r6, #0x37, 28
  00058	eb000000	 bl          UpdateStatInfoByCount

; 651  :     
; 652  :     if(INREG32(&(pAdapter->m_pEmacRegsBase->MACCONTROL)) & EMAC_MACCONTROL_GMII_ENABLE)

  0005c	e5963004	 ldr         r3, [r6, #4]
  00060	e5933160	 ldr         r3, [r3, #0x160]
  00064	e3130020	 tst         r3, #0x20

; 653  :     {
; 654  :         /* Decrement the value to 0 (this a Write-to-decrement register)*/    
; 655  :          OUTREG32(TempStatReg,INREG32(TempStatReg));

  00068	15943000	 ldrne       r3, [r4]

; 656  :     }
; 657  :     else
; 658  :     {
; 659  :         /* Decrement the value to 0 (this a Read/Writeregister)*/    
; 660  :         OUTREG32(TempStatReg,0);

  0006c	03a03000	 moveq       r3, #0
  00070	e5843000	 str         r3, [r4]

; 661  :     }
; 662  :     
; 663  : }

  00074	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00078	e12fff1e	 bx          lr
  0007c		 |$LN16@StatIntrHa|
  0007c		 |$LN17@StatIntrHa|
  0007c	00000000	 DCD         |??_C@_1CI@DPPLPAEF@?$AAS?$AAt?$AAa?$AAt?$AA?5?$AAr?$AAe?$AAg?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  00080		 |$M50870|

			 ENDP  ; |StatIntrHandler|

	EXPORT	|HostErrorIntrHandler|
	IMPORT	|NICInitializeAdapter|
	IMPORT	|EMACModStateChange|

  00000			 AREA	 |.pdata|, PDATA
|$T50882| DCD	|$LN12@HostErrorI|
	DCD	0x40000b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HostErrorIntrHandler| PROC

; 676  : { 

  00000		 |$LN12@HostErrorI|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M50879|
  00004	e1a04000	 mov         r4, r0

; 677  :     PEMAC_ADAPTER   pAdapter;
; 678  :     DWORD           MacStatus;
; 679  :     DWORD           TxIntrMask;
; 680  :     DWORD           RXIntrMask;
; 681  :     DWORD           IntrVal;
; 682  :     
; 683  :     DEBUGMSG (DBG_FUNC,(L"-->HostErrorIntrHandler()\r\n"));
; 684  : 
; 685  :     pAdapter = (PEMAC_ADAPTER)MiniportAdapterContext; 
; 686  :     
; 687  :     MacStatus   = pAdapter->m_pEmacRegsBase->MACSTATUS;

  00008	e5943004	 ldr         r3, [r4, #4]

; 688  :     DEBUGMSG (DBG_FUNC,(L"status 0x%x\r\n",MacStatus));
; 689  :     TxIntrMask  = (BIT(23) | BIT(22) | BIT(21) | BIT(20));
; 690  :     RXIntrMask  = (BIT(15) | BIT(14) | BIT(13) | BIT(12));
; 691  :     
; 692  :     if(IntrVal =  ((MacStatus & TxIntrMask) >> 20)) 
; 693  :     {
; 694  :         if((0x1 == IntrVal) || 
; 695  :            (0x2 == IntrVal) ||
; 696  :            (0x3 == IntrVal) ||
; 697  :            (0x4 == IntrVal) ||
; 698  :            (0x5 == IntrVal) ||
; 699  :            (0x6 == IntrVal))
; 700  :         {   
; 701  :             DEBUGMSG (DBG_INFO,(L"Tx error() %d\r\n",IntrVal));  
; 702  :         }    
; 703  :     }       
; 704  :     else if(IntrVal =  ((MacStatus & RXIntrMask) >> 12)) 
; 705  :     {
; 706  :         if((0x2 == IntrVal) || 
; 707  :            (0x4 == IntrVal))
; 708  :         {
; 709  :             DEBUGMSG (DBG_INFO,(L"Rx error() %d\r\n",IntrVal));  
; 710  :         }   
; 711  :     }    
; 712  :     
; 713  :     /* Reset the EMAC modules */
; 714  :     EMACModStateChange(pAdapter->m_device,SYNCRST);

  0000c	e5940094	 ldr         r0, [r4, #0x94]
  00010	e3a01000	 mov         r1, #0
  00014	e5933164	 ldr         r3, [r3, #0x164]
  00018	eb000000	 bl          EMACModStateChange

; 715  : 
; 716  :     /* Initialise once again the EMAC */
; 717  :     NICInitializeAdapter(pAdapter);

  0001c	e1a00004	 mov         r0, r4
  00020	eb000000	 bl          NICInitializeAdapter

; 718  :     
; 719  : }    

  00024	e8bd4010	 ldmia       sp!, {r4, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$M50880|

			 ENDP  ; |HostErrorIntrHandler|

	EXPORT	|Emac_MiniportIsr|

  00000			 AREA	 |.pdata|, PDATA
|$T50891| DCD	|$LN5@Emac_Minip|
	DCD	0x40000400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Emac_MiniportIsr| PROC

; 746  : {

  00000		 |$LN5@Emac_Minip|
  00000		 |$M50888|

; 747  :     *InterruptRecognized = TRUE;

  00000	e3a03001	 mov         r3, #1
  00004	e5c03000	 strb        r3, [r0]

; 748  :     *QueueMiniportHandleInterrupt = TRUE;

  00008	e5c13000	 strb        r3, [r1]

; 749  : 
; 750  : //    DEBUGMSG (DBG_FUNC,(L"+Emac_MiniportIsr()\r\n"));
; 751  : 
; 752  :     return;
; 753  : }

  0000c	e12fff1e	 bx          lr
  00010		 |$M50889|

			 ENDP  ; |Emac_MiniportIsr|

	EXPORT	|EmacEnableInterrupts|

  00000			 AREA	 |.pdata|, PDATA
|$T50899| DCD	|$LN6@EmacEnable|
	DCD	0x40001901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |EmacEnableInterrupts| PROC

; 756  : {

  00000		 |$LN6@EmacEnable|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M50896|

; 757  :     if(pAdapter->m_pEmacCtlRegs)

  00004	e5903008	 ldr         r3, [r0, #8]
  00008	e3530000	 cmp         r3, #0
  0000c	0a000012	 beq         |$LN1@EmacEnable|

; 758  :     {
; 759  :         pAdapter->m_pEmacRegsBase->MACEOIVECTOR = 0x1;

  00010	e5903004	 ldr         r3, [r0, #4]
  00014	e3a04001	 mov         r4, #1

; 760  :         pAdapter->m_pEmacRegsBase->MACEOIVECTOR = 0x2;

  00018	e3a02002	 mov         r2, #2
  0001c	e5834094	 str         r4, [r3, #0x94]
  00020	e5903004	 ldr         r3, [r0, #4]

; 761  :         pAdapter->m_pEmacRegsBase->MACEOIVECTOR = 0x3;

  00024	e3a01003	 mov         r1, #3

; 762  :         pAdapter->m_pEmacCtlRegs->C0RXTHRESHEN=0xff;

  00028	e3a0e0ff	 mov         lr, #0xFF
  0002c	e5832094	 str         r2, [r3, #0x94]
  00030	e5903004	 ldr         r3, [r0, #4]

; 763  :         pAdapter->m_pEmacCtlRegs->C0RXEN=0x01;
; 764  :         pAdapter->m_pEmacCtlRegs->C0TXEN=0x01;
; 765  :         pAdapter->m_pEmacCtlRegs->C0MISCEN=0xf;

  00034	e3a0200f	 mov         r2, #0xF
  00038	e5831094	 str         r1, [r3, #0x94]
  0003c	e5903008	 ldr         r3, [r0, #8]
  00040	e583e010	 str         lr, [r3, #0x10]
  00044	e5903008	 ldr         r3, [r0, #8]
  00048	e5834014	 str         r4, [r3, #0x14]
  0004c	e5903008	 ldr         r3, [r0, #8]
  00050	e5834018	 str         r4, [r3, #0x18]
  00054	e5903008	 ldr         r3, [r0, #8]
  00058	e583201c	 str         r2, [r3, #0x1C]
  0005c		 |$LN1@EmacEnable|

; 766  :     }
; 767  : }

  0005c	e8bd4010	 ldmia       sp!, {r4, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$M50897|

			 ENDP  ; |EmacEnableInterrupts|

	EXPORT	|EmacDisableInterrupts|

  00000			 AREA	 |.pdata|, PDATA
|$T50907| DCD	|$LN6@EmacDisabl|
	DCD	0x40000b00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |EmacDisableInterrupts| PROC

; 770  : {

  00000		 |$LN6@EmacDisabl|
  00000		 |$M50904|

; 771  :     if(pAdapter->m_pEmacCtlRegs)

  00000	e5903008	 ldr         r3, [r0, #8]
  00004	e3530000	 cmp         r3, #0

; 772  :     {
; 773  :         pAdapter->m_pEmacCtlRegs->C0RXTHRESHEN=0x0;

  00008	13a02000	 movne       r2, #0
  0000c	15832010	 strne       r2, [r3, #0x10]

; 774  :         pAdapter->m_pEmacCtlRegs->C0RXEN=0x0;

  00010	15903008	 ldrne       r3, [r0, #8]
  00014	15832014	 strne       r2, [r3, #0x14]

; 775  :         pAdapter->m_pEmacCtlRegs->C0TXEN=0x0;

  00018	15903008	 ldrne       r3, [r0, #8]
  0001c	15832018	 strne       r2, [r3, #0x18]

; 776  :         pAdapter->m_pEmacCtlRegs->C0MISCEN=0x0;

  00020	15903008	 ldrne       r3, [r0, #8]
  00024	1583201c	 strne       r2, [r3, #0x1C]

; 777  :     }
; 778  : }

  00028	e12fff1e	 bx          lr
  0002c		 |$M50905|

			 ENDP  ; |EmacDisableInterrupts|

	EXPORT	|Emac_MiniportHandleInterrupt|
	IMPORT	|SocAckInterrupt|
	IMPORT	|LinkChangeIntrHandler|

  00000			 AREA	 |.pdata|, PDATA
|$T50931| DCD	|$LN19@Emac_Minip@2|
	DCD	0x40001e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Emac_MiniportHandleInterrupt| PROC

; 794  : {

  00000		 |$LN19@Emac_Minip@2|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M50928|
  00004	e1a04000	 mov         r4, r0

; 795  :     DWORD ack_flag = 0;
; 796  :     DWORD           MacStatus;
; 797  :     PEMAC_ADAPTER   pAdapter;
; 798  :     
; 799  :         
; 800  :     //DEBUGMSG(DBG_FUNC && DBG_INT,(L"-->Emac_MiniportHandleInterrupt()\r\n"));
; 801  :     
; 802  :     pAdapter = (PEMAC_ADAPTER)MiniportAdapterContext;
; 803  : 
; 804  :     /* Since always interrupts are processed by disabling,servicing and enabling 
; 805  :      * the interrupt in NDIS by calling Emac_MiniportDisableInterrupt and 
; 806  :      * Emac_MiniportEnableInterrupt we need not take care of them here 
; 807  :      */  
; 808  :       
; 809  :     MacStatus = pAdapter->m_pEmacRegsBase->MACINVECTOR;

  00008	e5943004	 ldr         r3, [r4, #4]
  0000c	e5935090	 ldr         r5, [r3, #0x90]

; 810  :     
; 811  : 	/* Receive interrupt */
; 812  :     if( MacStatus & BIT(0) )

  00010	e3150001	 tst         r5, #1

; 813  :     {
; 814  :         //DEBUGMSG (DBG_INFO,(L"+Receive Emac_MiniportHandleInterrupt()\r\n")); 
; 815  :         RxIntrHandler(pAdapter);

  00014	1b000000	 blne        RxIntrHandler

; 816  :         ack_flag |= ACK_RX;
; 817  :     } 
; 818  :     
; 819  :     /* Trasmit interrupt */
; 820  :     if( MacStatus & BIT(16) )

  00018	e3150801	 tst         r5, #1, 16

; 821  :     {
; 822  :         DEBUGMSG (DBG_INFO,(L"+ Trasmit Emac_MiniportHandleInterrupt()\r\n"));
; 823  :         TxIntrHandler(pAdapter);

  0001c	11a00004	 movne       r0, r4
  00020	1b000000	 blne        TxIntrHandler

; 824  :         ack_flag |= ACK_TX;
; 825  :     }      
; 826  :           
; 827  :     /* Host error interrupt */
; 828  :     if( MacStatus & BIT(26) )

  00024	e3150301	 tst         r5, #1, 6
  00028	0a000006	 beq         |$LN3@Emac_Minip@2|

; 829  :     {
; 830  :          DEBUGMSG (DBG_INFO,(L"+Host error Emac_MiniportHandleInterrupt()\r\n"));
; 831  :          HostErrorIntrHandler(pAdapter);

  0002c	e5943004	 ldr         r3, [r4, #4]
  00030	e5940094	 ldr         r0, [r4, #0x94]
  00034	e3a01000	 mov         r1, #0
  00038	e5933164	 ldr         r3, [r3, #0x164]
  0003c	eb000000	 bl          EMACModStateChange
  00040	e1a00004	 mov         r0, r4
  00044	eb000000	 bl          NICInitializeAdapter
  00048		 |$LN3@Emac_Minip@2|

; 832  :          ack_flag |= ACK_MISC;
; 833  :     }       
; 834  :     
; 835  :     /* Link change interrupt */
; 836  :     if( MacStatus & BIT(25) )

  00048	e3150402	 tst         r5, #2, 8

; 837  :     {
; 838  :         DEBUGMSG (DBG_INFO,(L"+Link change interrupt()\r\n"));
; 839  :         LinkChangeIntrHandler(pAdapter);

  0004c	11a00004	 movne       r0, r4
  00050	1b000000	 blne        LinkChangeIntrHandler

; 840  :         ack_flag |= ACK_MISC;
; 841  :     }
; 842  :     
; 843  :     /* Statistics interrupt */
; 844  :     if( MacStatus & BIT(27) )

  00054	e3150302	 tst         r5, #2, 6

; 845  :     {
; 846  :         DEBUGMSG (DBG_INFO,(L"+Statistics Emac_MiniportHandleInterrupt()\r\n")); 
; 847  :         StatIntrHandler(pAdapter);

  00058	11a00004	 movne       r0, r4
  0005c	1b000000	 blne        StatIntrHandler

; 848  :         ack_flag |= ACK_MISC;
; 849  :     }
; 850  :     
; 851  :     SocAckInterrupt(0xF);

  00060	e3a0000f	 mov         r0, #0xF
  00064	eb000000	 bl          SocAckInterrupt

; 852  :     EmacEnableInterrupts(pAdapter);

  00068	e1a00004	 mov         r0, r4
  0006c	eb000000	 bl          EmacEnableInterrupts

; 853  : 
; 854  :     //DEBUGMSG(DBG_FUNC && DBG_INT,(L"<--Emac_MiniportHandleInterrupt()\r\n"));
; 855  : 
; 856  :     return;
; 857  : }

  00070	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00074	e12fff1e	 bx          lr
  00078		 |$M50929|

			 ENDP  ; |Emac_MiniportHandleInterrupt|

	EXPORT	|Emac_MiniportDisableInterrupt|

  00000			 AREA	 |.pdata|, PDATA
|$T50943| DCD	|$LN8@Emac_Minip@3|
	DCD	0x40000b00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Emac_MiniportDisableInterrupt| PROC

; 875  : {

  00000		 |$LN8@Emac_Minip@3|
  00000		 |$M50940|

; 876  :     PEMAC_ADAPTER  pAdapter;
; 877  :     
; 878  : //    DEBUGMSG (DBG_FUNC && DBG_INT,(L"+Emac_MiniportDisableInterrupt()\r\n"));
; 879  :     
; 880  :     pAdapter = (PEMAC_ADAPTER)MiniportAdapterContext;
; 881  : 
; 882  :     EmacDisableInterrupts(pAdapter);

  00000	e5903008	 ldr         r3, [r0, #8]
  00004	e3530000	 cmp         r3, #0
  00008	13a02000	 movne       r2, #0
  0000c	15832010	 strne       r2, [r3, #0x10]
  00010	15903008	 ldrne       r3, [r0, #8]
  00014	15832014	 strne       r2, [r3, #0x14]
  00018	15903008	 ldrne       r3, [r0, #8]
  0001c	15832018	 strne       r2, [r3, #0x18]
  00020	15903008	 ldrne       r3, [r0, #8]
  00024	1583201c	 strne       r2, [r3, #0x1C]

; 883  : 
; 884  :     return;
; 885  : }

  00028	e12fff1e	 bx          lr
  0002c		 |$M50941|

			 ENDP  ; |Emac_MiniportDisableInterrupt|

	EXPORT	|Emac_MiniportReturnPacket|

  00000			 AREA	 |.pdata|, PDATA
|$T50953| DCD	|$LN8@Emac_Minip@4|
	DCD	0x40002602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Emac_MiniportReturnPacket| PROC

; 905  : {

  00000		 |$LN8@Emac_Minip@4|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M50950|
  00008	e1a04001	 mov         r4, r1
  0000c	e1a05000	 mov         r5, r0

; 906  :     PEMAC_RXPKTS    *TempPtr;
; 907  :     PEMAC_RXPKTS    pTmpRxPkt;
; 908  :     PNDIS_BUFFER    NdisBuffer = NULL;

  00010	e3a03000	 mov         r3, #0

; 909  :     PEMAC_ADAPTER   pAdapter;
; 910  :     
; 911  :     pAdapter = (PEMAC_ADAPTER) MiniportAdapterContext;
; 912  :     
; 913  :     DEBUGMSG(DBG_FUNC && DBG_RX, (L"---> Emac_MiniportReturnPacket\r\n"));
; 914  : 
; 915  :     /* Unchain buffer attached preventing memory leak */
; 916  :     NdisUnchainBufferAtFront(Packet,&NdisBuffer);

  00014	e28d1000	 add         r1, sp, #0
  00018	e1a00004	 mov         r0, r4
  0001c	e58d3000	 str         r3, [sp]
  00020	eb000000	 bl          NdisUnchainBufferAtFront

; 917  :     
; 918  :     /* Reinitialize the NDIS packet for later use.
; 919  :      * This will remove the NdisBuffer Linkage from
; 920  :      * the NDIS Packet.
; 921  :      */
; 922  :     NdisReinitializePacket(Packet);    

  00024	e3a07000	 mov         r7, #0
  00028	e5847008	 str         r7, [r4, #8]
  0002c	e5c4701c	 strb        r7, [r4, #0x1C]

; 923  :     
; 924  :     /* Get the HALPacket associated with this packet */
; 925  :     TempPtr = (PEMAC_RXPKTS *)(Packet->MiniportReserved);
; 926  :     
; 927  :     pTmpRxPkt = *TempPtr; 

  00030	e5946020	 ldr         r6, [r4, #0x20]

; 928  :     
; 929  :     DEBUGMSG (DBG_INFO,(L"+ Emac_MiniportReturnPacket 8.2 %X \r\n",pTmpRxPkt));
; 930  :     
; 931  :     /* This has every information about packets information like
; 932  :      * buffers chained to it. This will be useful when we are adding
; 933  :      * associated buffers to EMAC buffer descriptor queue
; 934  :      */
; 935  :     
; 936  :     AddBufToRxQueue(pAdapter, pTmpRxPkt);

  00034	e1a00005	 mov         r0, r5
  00038	e1a01006	 mov         r1, r6
  0003c	eb000000	 bl          AddBufToRxQueue

; 937  :     
; 938  :     /* Also clearing OOB data */
; 939  :     NdisZeroMemory(NDIS_OOB_DATA_FROM_PACKET(Packet),
; 940  :             sizeof(NDIS_PACKET_OOB_DATA));

  00040	e1d431be	 ldrh        r3, [r4, #0x1E]
  00044	e3a02020	 mov         r2, #0x20
  00048	e3a01000	 mov         r1, #0
  0004c	e0830004	 add         r0, r3, r4
  00050	eb000000	 bl          memset

; 941  :     
; 942  :     /* Also insert in packet got in to packet pool */
; 943  :     QUEUE_INSERT(&pAdapter->m_RxPktPool, pTmpRxPkt);

  00054	e2953e1b	 adds        r3, r5, #0x1B, 28
  00058	0a00000b	 beq         |$LN3@Emac_Minip@4|
  0005c	e3560000	 cmp         r6, #0
  00060	0a000009	 beq         |$LN3@Emac_Minip@4|
  00064	e59531b0	 ldr         r3, [r5, #0x1B0]
  00068	e3530000	 cmp         r3, #0
  0006c	159531b4	 ldrne       r3, [r5, #0x1B4]
  00070	058561b0	 streq       r6, [r5, #0x1B0]
  00074	15836000	 strne       r6, [r3]
  00078	e59531b8	 ldr         r3, [r5, #0x1B8]
  0007c	e58561b4	 str         r6, [r5, #0x1B4]
  00080	e2833001	 add         r3, r3, #1
  00084	e58531b8	 str         r3, [r5, #0x1B8]
  00088	e5867000	 str         r7, [r6]
  0008c		 |$LN3@Emac_Minip@4|

; 944  :     
; 945  :     DEBUGMSG(DBG_FUNC && DBG_RX, (L"<--- Emac_MiniportReturnPacket\r\n"));
; 946  : 
; 947  : }

  0008c	e28dd004	 add         sp, sp, #4
  00090	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00094	e12fff1e	 bx          lr
  00098		 |$M50951|

			 ENDP  ; |Emac_MiniportReturnPacket|

	END
