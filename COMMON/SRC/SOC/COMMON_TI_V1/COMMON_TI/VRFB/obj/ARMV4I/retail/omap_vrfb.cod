; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\VRFB\omap_vrfb.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1CG@HPFELENL@?$AAN?$AAu?$AAm?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AAC?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AAs?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|DEVICE_IFC_VRFB_GUID| [ DATA ]
	EXPORT	|dpCurSettings| [ DATA ]
	EXPORT	|g_VrfbContextList| [ DATA ]

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CG@HPFELENL@?$AAN?$AAu?$AAm?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AAC?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AAs?$AA?$AA@| DCB "N"
	DCB	0x0, "u", 0x0, "m", 0x0, "D", 0x0, "i", 0x0, "s", 0x0, "p"
	DCB	0x0, "l", 0x0, "a", 0x0, "y", 0x0, "C", 0x0, "o", 0x0, "n"
	DCB	0x0, "t", 0x0, "e", 0x0, "x", 0x0, "t", 0x0, "s", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.data|, DATA
|dpCurSettings| DCB "V", 0x0, "R", 0x0, "F", 0x0, "B", 0x0, 0x0, 0x0
	%	54
	DCB	"E", 0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, "s", 0x0
	DCB	0x0, 0x0
	%	50
	DCB	"W", 0x0, "a", 0x0, "r", 0x0, "n", 0x0, "i", 0x0, "n", 0x0
	DCB	"g", 0x0, "s", 0x0, 0x0, 0x0
	%	46
	DCB	"F", 0x0, "u", 0x0, "n", 0x0, "c", 0x0, "t", 0x0, "i", 0x0
	DCB	"o", 0x0, "n", 0x0, 0x0, 0x0
	%	46
	DCB	"I", 0x0, "n", 0x0, "f", 0x0, "o", 0x0, 0x0, 0x0
	%	54
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCD	0xf
	%	4
|g_VrfbContextList| DCD 0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x70000000
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x74000000
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x78000000
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x7c000000
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0xe0000000
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0xe4000000
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0xe8000000
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0xec000000
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0xf0000000
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0xf4000000
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0xf8000000
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0xfc000000
	DCD	0x0
	DCD	0x0
	DCD	0x0

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
|DEVICE_IFC_VRFB_GUID| DCD 0xede6bb10
	DCW	0xd844
	DCW	0x4639
	DCB	0xa7
	DCB	0xb6
	DCB	0xca
	DCB	0x19
	DCB	0x9c
	DCB	0xd9
	DCB	0xeb
	DCB	0x34
|s_deviceRegParams| DCD |??_C@_1CG@HPFELENL@?$AAN?$AAu?$AAm?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AAC?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AAs?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x4
	DCD	0x4
	DCD	0xc
	EXPORT	|CeSetMemoryAttributes|
	IMPORT	|KernelLibIoControl|
; File c:\wince600\public\common\oak\inc\pkfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T45712| DCD	|$LN5@CeSetMemor|
	DCD	0x40001002
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |CeSetMemoryAttributes| PROC

; 1422 : {

  00000		 |$LN5@CeSetMemor|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M45709|
  00008	e1a04003	 mov         r4, r3
  0000c	e1a03002	 mov         r3, r2
  00010	e1a02000	 mov         r2, r0
  00014	e1a0e001	 mov         lr, r1

; 1423 :     return KernelLibIoControl ((HANDLE) KMOD_CORE, IOCTL_KLIB_SETMEMORYATTR,
; 1424 :         pVirtualAddr, cbSize, pShiftedPhysAddr, dwAttributes, NULL);

  00018	e3a01000	 mov         r1, #0
  0001c	e58d1008	 str         r1, [sp, #8]
  00020	e3a0100c	 mov         r1, #0xC
  00024	e3a00001	 mov         r0, #1
  00028	e58d4004	 str         r4, [sp, #4]
  0002c	e58de000	 str         lr, [sp]
  00030	eb000000	 bl          KernelLibIoControl

; 1425 : }

  00034	e28dd00c	 add         sp, sp, #0xC
  00038	e8bd4010	 ldmia       sp!, {r4, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$M45710|

			 ENDP  ; |CeSetMemoryAttributes|

	EXPORT	|GetCurrentProcessId|
	IMPORT	|__GetUserKData|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T45721| DCD	|$LN5@GetCurrent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentProcessId| PROC

; 373  : _inline DWORD GetCurrentProcessId(void) {

  00000		 |$LN5@GetCurrent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45718|

; 374  :     return __GetUserKData (SYSHANDLE_OFFSET + (SH_CURPROC * sizeof(HANDLE)));

  00004	e3a0000c	 mov         r0, #0xC
  00008	eb000000	 bl          __GetUserKData

; 375  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M45719|

			 ENDP  ; |GetCurrentProcessId|

	EXPORT	|VRF_Deinit|
	IMPORT	|LocalFree|
	IMPORT	|DeleteCriticalSection|
	IMPORT	|MmUnmapIoSpace|
	IMPORT	|VirtualFree|
	IMPORT	|EnableDeviceClocks|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\vrfb\omap_vrfb.c

  00000			 AREA	 |.pdata|, PDATA
|$T45732| DCD	|$LN10@VRF_Deinit|
	DCD	0x40002601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |VRF_Deinit| PROC

; 364  : {

  00000		 |$LN10@VRF_Deinit|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M45729|
  00004	e1b04000	 movs        r4, r0

; 365  :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 366  :     Device_t *pDevice = (Device_t*)context;
; 367  : 
; 368  :     DEBUGMSG(ZONE_FUNCTION, (L"+VRF_Deinit(0x%08x)\r\n", context));
; 369  : 
; 370  :     // Check if we get correct context
; 371  :     if ((pDevice == NULL) || (pDevice->cookie != VRFB_DEVICE_COOKIE))

  0000c	0a00001e	 beq         |$cleanUp$45083|
  00010	e5942000	 ldr         r2, [r4]
  00014	e59f3078	 ldr         r3, [pc, #0x78]
  00018	e1520003	 cmp         r2, r3
  0001c	1a00001a	 bne         |$cleanUp$45083|

; 372  :         {
; 373  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: VRF_Deinit: "
; 374  :             L"Incorrect context param\r\n"
; 375  :             ));
; 376  :         goto cleanUp;
; 377  :         }
; 378  : 
; 379  :     // Check for open instances
; 380  :     if (pDevice->instances > 0)

  00020	e594301c	 ldr         r3, [r4, #0x1C]
  00024	e3530000	 cmp         r3, #0
  00028	ca000017	 bgt         |$cleanUp$45083|

; 381  :         {
; 382  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: VRF_Deinit: "
; 383  :             L"Deinit with active instance (%d instances active)\r\n",
; 384  :             pDevice->instances
; 385  :             ));
; 386  :         goto cleanUp;
; 387  :         }
; 388  :     
; 389  :     // Turn hardware off
; 390  :     EnableDeviceClocks(pDevice->device,FALSE);

  0002c	e5940020	 ldr         r0, [r4, #0x20]
  00030	e3a01000	 mov         r1, #0
  00034	eb000000	 bl          EnableDeviceClocks

; 391  :     
; 392  :     //  Release the display context memory
; 393  :     if (pDevice->pDisplayContextMem != NULL) 

  00038	e5943028	 ldr         r3, [r4, #0x28]
  0003c	e1b00003	 movs        r0, r3
  00040	0a000007	 beq         |$LN2@VRF_Deinit|

; 394  :     {
; 395  :         VirtualFree( pDevice->pDisplayContextMem, VRFB_VIEW_SIZE*pDevice->dwNumDisplayContexts, MEM_DECOMMIT );

  00044	e5943004	 ldr         r3, [r4, #4]
  00048	e3a02901	 mov         r2, #1, 18
  0004c	e1a01c03	 mov         r1, r3, lsl #24
  00050	eb000000	 bl          VirtualFree

; 396  :         VirtualFree( pDevice->pDisplayContextMem, 0, MEM_RELEASE );

  00054	e5940028	 ldr         r0, [r4, #0x28]
  00058	e3a02902	 mov         r2, #2, 18
  0005c	e3a01000	 mov         r1, #0
  00060	eb000000	 bl          VirtualFree
  00064		 |$LN2@VRF_Deinit|

; 397  :     }                    
; 398  : 
; 399  :     //  Unmap VRFB registers
; 400  :     if (pDevice->pVRFBRegs != NULL) 

  00064	e5943024	 ldr         r3, [r4, #0x24]
  00068	e3530000	 cmp         r3, #0

; 401  :     {
; 402  :         MmUnmapIoSpace((VOID*)pDevice->pVRFBRegs, sizeof(OMAP_VRFB_REGS));

  0006c	13a010dc	 movne       r1, #0xDC
  00070	11a00003	 movne       r0, r3
  00074	1b000000	 blne        MmUnmapIoSpace

; 403  :     }                    
; 404  : 
; 405  : 
; 406  :     // Delete critical section
; 407  :     DeleteCriticalSection(&pDevice->cs);

  00078	e2840008	 add         r0, r4, #8
  0007c	eb000000	 bl          DeleteCriticalSection

; 408  :  
; 409  :     // Free device structure
; 410  :     LocalFree(pDevice);

  00080	e1a00004	 mov         r0, r4
  00084	eb000000	 bl          LocalFree

; 411  : 
; 412  :     // Done
; 413  :     rc = TRUE;

  00088	e3a00001	 mov         r0, #1
  0008c		 |$cleanUp$45083|

; 414  : 
; 415  : cleanUp:
; 416  :     DEBUGMSG(ZONE_FUNCTION, (L"-VRF_Deinit(rc = %d)\r\n", rc));
; 417  :     return rc;
; 418  : }

  0008c	e8bd4010	 ldmia       sp!, {r4, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$LN11@VRF_Deinit|
  00094		 |$LN12@VRF_Deinit|
  00094	76726644	 DCD         0x76726644
  00098		 |$M45730|

			 ENDP  ; |VRF_Deinit|

	EXPORT	|VRF_Open|
	IMPORT	|InterlockedIncrement|
	IMPORT	|LocalAlloc|

  00000			 AREA	 |.pdata|, PDATA
|$T45746| DCD	|$LN8@VRF_Open|
	DCD	0x40001b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |VRF_Open| PROC

; 432  : {

  00000		 |$LN8@VRF_Open|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45743|
  00004	e1b06000	 movs        r6, r0

; 433  :     DWORD rc = (DWORD)NULL;

  00008	e3a05000	 mov         r5, #0

; 434  :     Device_t *pDevice = (Device_t*)context;
; 435  :     Instance_t *pInstance = NULL;
; 436  : 
; 437  :     UNREFERENCED_PARAMETER(accessCode);
; 438  :     UNREFERENCED_PARAMETER(shareMode);
; 439  : 
; 440  :     DEBUGMSG(ZONE_FUNCTION, (
; 441  :         L"+VRF_Open(0x%08x, 0x%08x, 0x%08x\r\n", context, accessCode, shareMode
; 442  :         ));
; 443  : 
; 444  :     // Check if we get correct context
; 445  :     if ((pDevice == NULL) || (pDevice->cookie != VRFB_DEVICE_COOKIE))

  0000c	0a000011	 beq         |$cleanUp$45114|
  00010	e5962000	 ldr         r2, [r6]
  00014	e59f304c	 ldr         r3, [pc, #0x4C]
  00018	e1520003	 cmp         r2, r3
  0001c	1a00000d	 bne         |$cleanUp$45114|

; 446  :         {
; 447  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: VRF_Open: "
; 448  :             L"Incorrect context parameter\r\n"
; 449  :             ));
; 450  :         goto cleanUp;
; 451  :         }
; 452  : 
; 453  :     // Create device structure
; 454  :     pInstance = (Instance_t*)LocalAlloc(LPTR, sizeof(Instance_t));

  00020	e3a01008	 mov         r1, #8
  00024	e3a00040	 mov         r0, #0x40
  00028	eb000000	 bl          LocalAlloc
  0002c	e1b04000	 movs        r4, r0

; 455  :     if (pInstance == NULL)

  00030	0a000008	 beq         |$cleanUp$45114|

; 456  :         {
; 457  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRF_Open: "
; 458  :             L"Failed allocate DMA instance structure\r\n"
; 459  :             ));
; 460  :         goto cleanUp;
; 461  :         }
; 462  : 
; 463  :     // Set cookie
; 464  :     memset(pInstance, 0, sizeof(Instance_t));
; 465  :     pInstance->cookie = VRFB_INSTANCE_COOKIE;

  00034	e59f3028	 ldr         r3, [pc, #0x28]
  00038	e3a02000	 mov         r2, #0
  0003c	e5842000	 str         r2, [r4]
  00040	e5842004	 str         r2, [r4, #4]

; 466  : 
; 467  :     // Save device reference
; 468  :     pInstance->pDevice = pDevice;
; 469  : 
; 470  :     // Increment number of open instances
; 471  :     InterlockedIncrement(&pDevice->instances);

  00044	e286001c	 add         r0, r6, #0x1C
  00048	e5843000	 str         r3, [r4]
  0004c	e5846004	 str         r6, [r4, #4]
  00050	eb000000	 bl          InterlockedIncrement

; 472  : 
; 473  :     // Sanity check number of instances
; 474  :     ASSERT(pDevice->instances > 0);
; 475  : 
; 476  :     // Done...
; 477  :     rc = (DWORD)pInstance;

  00054	e1a05004	 mov         r5, r4
  00058		 |$cleanUp$45114|

; 478  : 
; 479  : cleanUp:
; 480  :     DEBUGMSG(ZONE_FUNCTION, (L"-VRF_Open(rc = 0x%08x)\r\n", rc));
; 481  :     return rc;
; 482  : }

  00058	e1a00005	 mov         r0, r5
  0005c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$LN9@VRF_Open|
  00064		 |$LN10@VRF_Open|
  00064	76726649	 DCD         0x76726649
  00068		 |$LN11@VRF_Open|
  00068	76726644	 DCD         0x76726644
  0006c		 |$M45744|

			 ENDP  ; |VRF_Open|

	EXPORT	|VRF_Close|
	IMPORT	|InterlockedDecrement|

  00000			 AREA	 |.pdata|, PDATA
|$T45760| DCD	|$LN7@VRF_Close|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |VRF_Close| PROC

; 494  : {

  00000		 |$LN7@VRF_Close|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M45757|
  00004	e1b04000	 movs        r4, r0

; 495  :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 496  :     Device_t *pDevice;
; 497  :     Instance_t *pInstance = (Instance_t*)context;
; 498  : 
; 499  :     DEBUGMSG(ZONE_FUNCTION, (L"+VRF_Close(0x%08x)\r\n", context));
; 500  : 
; 501  :     // Check if we get correct context
; 502  :     if ((pInstance == NULL) || (pInstance->cookie != VRFB_INSTANCE_COOKIE))

  0000c	0a000009	 beq         |$cleanUp$45137|
  00010	e5942000	 ldr         r2, [r4]
  00014	e59f3024	 ldr         r3, [pc, #0x24]
  00018	e1520003	 cmp         r2, r3
  0001c	1a000005	 bne         |$cleanUp$45137|

; 503  :         {
; 504  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: VRF_Read: "
; 505  :             L"Incorrect context param\r\n"
; 506  :             ));
; 507  :         goto cleanUp;
; 508  :         }
; 509  : 
; 510  :     // Get device context
; 511  :     pDevice = pInstance->pDevice;
; 512  : 
; 513  :     // Sanity check number of instances
; 514  :     ASSERT(pDevice->instances > 0);
; 515  : 
; 516  :     // Decrement number of open instances
; 517  :     InterlockedDecrement(&pDevice->instances);

  00020	e5943004	 ldr         r3, [r4, #4]
  00024	e283001c	 add         r0, r3, #0x1C
  00028	eb000000	 bl          InterlockedDecrement

; 518  : 
; 519  :     // Free instance structure
; 520  :     LocalFree(pInstance);

  0002c	e1a00004	 mov         r0, r4
  00030	eb000000	 bl          LocalFree

; 521  : 
; 522  :     // Done...
; 523  :     rc = TRUE;

  00034	e3a00001	 mov         r0, #1
  00038		 |$cleanUp$45137|

; 524  : 
; 525  : cleanUp:
; 526  :     DEBUGMSG(ZONE_FUNCTION, (L"-VRF_Close(rc = %d)\r\n", rc));
; 527  :     return rc;
; 528  : }

  00038	e8bd4010	 ldmia       sp!, {r4, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$LN8@VRF_Close|
  00040		 |$LN9@VRF_Close|
  00040	76726649	 DCD         0x76726649
  00044		 |$M45758|

			 ENDP  ; |VRF_Close|

	EXPORT	|VRFB_ReleaseView|
	IMPORT	|FreePhysMem|

  00000			 AREA	 |.pdata|, PDATA
|$T45775| DCD	|$LN11@VRFB_Relea|
	DCD	0x40002e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |VRFB_ReleaseView| PROC

; 971  : {

  00000		 |$LN11@VRFB_Relea|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45772|
  00004	e1b0e000	 movs        lr, r0

; 972  :     BOOL        bResult = FALSE;

  00008	e3a00000	 mov         r0, #0

; 973  :     Instance_t *pInstance = (Instance_t*)hContext;
; 974  :     Device_t   *pDevice;
; 975  :     DWORD       index;
; 976  : 
; 977  : 
; 978  :     DEBUGMSG(ZONE_FUNCTION, (
; 979  :         L"+VRFB_ReleaseView(0x%08x, 0x%08x)\r\n", hContext, hView
; 980  :         ));
; 981  : 
; 982  :     // Check if we get correct context
; 983  :     if ((pInstance == NULL) || (pInstance->cookie != VRFB_INSTANCE_COOKIE))

  0000c	0a000025	 beq         |$cleanUp$45382|
  00010	e59e2000	 ldr         r2, [lr]
  00014	e59f3098	 ldr         r3, [pc, #0x98]
  00018	e1520003	 cmp         r2, r3
  0001c	1a000021	 bne         |$cleanUp$45382|

; 984  :         {
; 985  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_ReleaseView: "
; 986  :             L"Incorrect context param\r\n"
; 987  :             ));
; 988  :         goto cleanUp;
; 989  :         }
; 990  : 
; 991  :     //  Get Device
; 992  :     pDevice = pInstance->pDevice;
; 993  : 
; 994  :     //  Validate view handle
; 995  :     index = (DWORD)hView - VRFB_VIEW_HANDLE_BASE;
; 996  :     
; 997  :     if( index < pDevice->dwNumDisplayContexts )

  00020	e59e3004	 ldr         r3, [lr, #4]
  00024	e2412206	 sub         r2, r1, #6, 4
  00028	e5933004	 ldr         r3, [r3, #4]
  0002c	e1520003	 cmp         r2, r3
  00030	3a00001c	 bcc         |$cleanUp$45382|

; 998  :     {
; 999  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_ReleaseView: "
; 1000 :             L"Can't release display view # %d\r\n", index
; 1001 :             ));
; 1002 :         goto cleanUp;
; 1003 :     }
; 1004 : 
; 1005 :     
; 1006 :     //  Release the virtual memory associated with this view and free the context
; 1007 :     if( index < VRFB_ROTATION_CONTEXTS && g_VrfbContextList[index].bInUse )

  00034	e352000c	 cmp         r2, #0xC
  00038	2a00001a	 bcs         |$cleanUp$45382|
  0003c	e59f106c	 ldr         r1, [pc, #0x6C]
  00040	e1a05282	 mov         r5, r2, lsl #5
  00044	e7b53001	 ldr         r3, [r5, +r1]!
  00048	e3530000	 cmp         r3, #0
  0004c	0a000015	 beq         |$cleanUp$45382|

; 1008 :     {
; 1009 :         //  Release the mapping to the VRFB context
; 1010 :         VirtualFree( (VOID*)g_VrfbContextList[index].dwVirtualAddr, VRFB_VIEW_SIZE, MEM_DECOMMIT );

  00050	e0814282	 add         r4, r1, r2, lsl #5
  00054	e5940014	 ldr         r0, [r4, #0x14]
  00058	e3a02901	 mov         r2, #1, 18
  0005c	e3a01401	 mov         r1, #1, 8
  00060	eb000000	 bl          VirtualFree

; 1011 :         VirtualFree( (VOID*)g_VrfbContextList[index].dwVirtualAddr, 0, MEM_RELEASE );

  00064	e5940014	 ldr         r0, [r4, #0x14]
  00068	e3a02902	 mov         r2, #2, 18
  0006c	e3a01000	 mov         r1, #0
  00070	eb000000	 bl          VirtualFree

; 1012 : 
; 1013 :         //  Release any allocated physical memory for the VRFB view buffer
; 1014 :         if( g_VrfbContextList[index].dwBufferVirtAddr != 0 )

  00074	e594301c	 ldr         r3, [r4, #0x1C]
  00078	e3530000	 cmp         r3, #0

; 1015 :         {
; 1016 :             FreePhysMem( (VOID*)g_VrfbContextList[index].dwBufferVirtAddr );

  0007c	11a00003	 movne       r0, r3
  00080	1b000000	 blne        FreePhysMem

; 1017 :         }
; 1018 :         
; 1019 :         //  Clean up the context information
; 1020 :         g_VrfbContextList[index].bInUse = FALSE;

  00084	e3a03000	 mov         r3, #0
  00088	e5853000	 str         r3, [r5]

; 1021 :         g_VrfbContextList[index].dwWidth = 0;

  0008c	e5843004	 str         r3, [r4, #4]

; 1022 :         g_VrfbContextList[index].dwHeight = 0;

  00090	e5843008	 str         r3, [r4, #8]

; 1023 :         g_VrfbContextList[index].dwRotationAngle = 0;

  00094	e584300c	 str         r3, [r4, #0xC]

; 1024 :         g_VrfbContextList[index].dwVirtualAddr = 0;

  00098	e5843014	 str         r3, [r4, #0x14]

; 1025 :         g_VrfbContextList[index].dwBufferPhysAddr = 0;

  0009c	e5843018	 str         r3, [r4, #0x18]

; 1026 :         g_VrfbContextList[index].dwBufferVirtAddr = 0;

  000a0	e584301c	 str         r3, [r4, #0x1C]

; 1027 :         
; 1028 :         bResult = TRUE;

  000a4	e3a00001	 mov         r0, #1
  000a8		 |$cleanUp$45382|

; 1029 :     }
; 1030 :     else
; 1031 :     {
; 1032 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_ReleaseView: "
; 1033 :             L"Invalid view handle 0x%08X\r\n", hView
; 1034 :             ));
; 1035 :         goto cleanUp;
; 1036 :     }
; 1037 :     
; 1038 : cleanUp:    
; 1039 :     //  Return result
; 1040 :     DEBUGMSG(ZONE_FUNCTION, (L"-VRFB_ReleaseView(bResult = %d)\r\n", bResult));
; 1041 :     return bResult;
; 1042 : }

  000a8	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000ac	e12fff1e	 bx          lr
  000b0		 |$LN12@VRFB_Relea|
  000b0		 |$LN13@VRFB_Relea|
  000b0	00000000	 DCD         |g_VrfbContextList|
  000b4		 |$LN14@VRFB_Relea|
  000b4	76726649	 DCD         0x76726649
  000b8		 |$M45773|

			 ENDP  ; |VRFB_ReleaseView|

	EXPORT	|VRFB_GetViewInfo|
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T45799| DCD	|$LN19@VRFB_GetVi|
	DCD	0x40005b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |VRFB_GetViewInfo| PROC

; 1051 : {

  00000		 |$LN19@VRFB_GetVi|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M45796|
  00004	e1a06002	 mov         r6, r2
  00008	e1b02000	 movs        r2, r0
  0000c	e1a08001	 mov         r8, r1

; 1052 :     BOOL        bResult = FALSE;

  00010	e3a00000	 mov         r0, #0

; 1053 :     Instance_t *pInstance = (Instance_t*)hContext;
; 1054 :     Device_t   *pDevice;
; 1055 :     DWORD       index;
; 1056 : 
; 1057 :     // Check if we get correct context
; 1058 :     if ((pInstance == NULL) || (pInstance->cookie != VRFB_INSTANCE_COOKIE))

  00014	0a000050	 beq         |$cleanUp$45411|
  00018	e592e000	 ldr         lr, [r2]
  0001c	e59f3144	 ldr         r3, [pc, #0x144]
  00020	e15e0003	 cmp         lr, r3
  00024	1a00004c	 bne         |$cleanUp$45411|

; 1059 :         {
; 1060 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_GetViewInfo: "
; 1061 :             L"Incorrect context param\r\n"
; 1062 :             ));
; 1063 :         goto cleanUp;
; 1064 :         }
; 1065 : 
; 1066 :     //  Get Device
; 1067 :     pDevice = pInstance->pDevice;
; 1068 : 
; 1069 :     //  Validate view handle
; 1070 :     index = (DWORD)hView - VRFB_VIEW_HANDLE_BASE;

  00028	e2485206	 sub         r5, r8, #6, 4

; 1071 :     
; 1072 :     if( index < VRFB_ROTATION_CONTEXTS && g_VrfbContextList[index].bInUse )

  0002c	e5929004	 ldr         r9, [r2, #4]
  00030	e355000c	 cmp         r5, #0xC
  00034	2a000048	 bcs         |$cleanUp$45411|
  00038	e59f2124	 ldr         r2, [pc, #0x124]
  0003c	e7923285	 ldr         r3, [r2, +r5, lsl #5]
  00040	e3530000	 cmp         r3, #0
  00044	0a000044	 beq         |$cleanUp$45411|

; 1073 :     {
; 1074 :         DWORD   offset = 0;
; 1075 :         
; 1076 :         //  Get VRFB view rotation offset
; 1077 :         switch( g_VrfbContextList[index].dwRotationAngle )

  00048	e0827285	 add         r7, r2, r5, lsl #5
  0004c	e597000c	 ldr         r0, [r7, #0xC]
  00050	e3a04000	 mov         r4, #0
  00054	e350005a	 cmp         r0, #0x5A
  00058	0a000007	 beq         |$LN3@VRFB_GetVi|
  0005c	e35000b4	 cmp         r0, #0xB4
  00060	0a000004	 beq         |$LN4@VRFB_GetVi|
  00064	e3a03c01	 mov         r3, #1, 24
  00068	e383300e	 orr         r3, r3, #0xE
  0006c	e1500003	 cmp         r0, r3
  00070	1a000002	 bne         |$LN2@VRFB_GetVi|

; 1078 :         {
; 1079 :             //  Deliberate fall through on the case statements below
; 1080 :             case VRFB_ROTATE_ANGLE_270:
; 1081 :                 offset += VRFB_VIEW_SIZE;

  00074	e3a04401	 mov         r4, #1, 8
  00078		 |$LN4@VRFB_GetVi|

; 1082 :                 
; 1083 :             case VRFB_ROTATE_ANGLE_180:
; 1084 :                 offset += VRFB_VIEW_SIZE;

  00078	e2844401	 add         r4, r4, #1, 8
  0007c		 |$LN3@VRFB_GetVi|

; 1085 : 
; 1086 :             case VRFB_ROTATE_ANGLE_90:
; 1087 :                 offset += VRFB_VIEW_SIZE;

  0007c	e2844401	 add         r4, r4, #1, 8
  00080		 |$LN2@VRFB_GetVi|

; 1088 : 
; 1089 :             case VRFB_ROTATE_ANGLE_0:
; 1090 :             default:
; 1091 :                 break;
; 1092 :         }
; 1093 : 
; 1094 :         //  Fill in the view info structure
; 1095 :         memset( pInfo, 0, sizeof(VRFB_VIEW_INFO));

  00080	e3a02040	 mov         r2, #0x40
  00084	e3a01000	 mov         r1, #0
  00088	e1a00006	 mov         r0, r6
  0008c	eb000000	 bl          memset

; 1096 :         
; 1097 :         pInfo->hView = hView;

  00090	e5868000	 str         r8, [r6]

; 1098 :         pInfo->dwPixelSize = INREG32(&pDevice->pVRFBRegs->aVRFB_SMS_ROT_CTRL[index].VRFB_SMS_ROT_CONTROL) & 0x00000003;

  00094	e5993024	 ldr         r3, [r9, #0x24]

; 1099 :         pInfo->dwPixelSizeBytes = PIXEL_SIZE_TO_BYTES(pInfo->dwPixelSize);

  00098	e3a02001	 mov         r2, #1

; 1100 :         pInfo->dwWidth = g_VrfbContextList[index].dwWidth;
; 1101 :         pInfo->dwHeight = g_VrfbContextList[index].dwHeight;
; 1102 :         pInfo->dwPageWidth = DEFAULT_PAGE_WIDTH;

  0009c	e3a0e004	 mov         lr, #4
  000a0	e0833205	 add         r3, r3, r5, lsl #4
  000a4	e593301c	 ldr         r3, [r3, #0x1C]

; 1103 :         pInfo->dwPageHeight = DEFAULT_PAGE_HEIGHT;
; 1104 :         pInfo->dwImageWidth = INREG32(&pDevice->pVRFBRegs->aVRFB_SMS_ROT_CTRL[index].VRFB_SMS_ROT_SIZE) & 0x000007FF;

  000a8	e2850002	 add         r0, r5, #2
  000ac	e3a01c07	 mov         r1, #7, 24
  000b0	e2033003	 and         r3, r3, #3
  000b4	e1a02312	 mov         r2, r2, lsl r3
  000b8	e5863004	 str         r3, [r6, #4]
  000bc	e5862008	 str         r2, [r6, #8]
  000c0	e5973004	 ldr         r3, [r7, #4]
  000c4	e38110ff	 orr         r1, r1, #0xFF

; 1105 :         pInfo->dwImageHeight = (INREG32(&pDevice->pVRFBRegs->aVRFB_SMS_ROT_CTRL[index].VRFB_SMS_ROT_SIZE)>>16) & 0x000007FF;
; 1106 :         pInfo->dwImageStride = PIXEL_SIZE_TO_BYTES(pInfo->dwPixelSize) * VRFB_IMAGE_WIDTH_MAX;

  000c8	e1a02582	 mov         r2, r2, lsl #11
  000cc	e586300c	 str         r3, [r6, #0xC]
  000d0	e5973008	 ldr         r3, [r7, #8]
  000d4	e586e014	 str         lr, [r6, #0x14]
  000d8	e586e018	 str         lr, [r6, #0x18]
  000dc	e5863010	 str         r3, [r6, #0x10]
  000e0	e5993024	 ldr         r3, [r9, #0x24]

; 1107 :         pInfo->dwOriginOffset = 0;

  000e4	e3a0e000	 mov         lr, #0
  000e8	e0833200	 add         r3, r3, r0, lsl #4
  000ec	e5933000	 ldr         r3, [r3]
  000f0	e0131001	 ands        r1, r3, r1
  000f4	e586101c	 str         r1, [r6, #0x1C]
  000f8	e5993024	 ldr         r3, [r9, #0x24]

; 1108 :         pInfo->dwRotationAngle = g_VrfbContextList[index].dwRotationAngle;
; 1109 :         pInfo->dwVirtualAddr = g_VrfbContextList[index].dwVirtualAddr;
; 1110 :         pInfo->dwPhysicalAddrInput = g_VrfbContextList[index].dwPhysicalAddr + offset;
; 1111 :         pInfo->dwPhysicalAddrOutput = g_VrfbContextList[index].dwPhysicalAddr;
; 1112 :         pInfo->dwPhysicalBufferAddr = g_VrfbContextList[index].dwBufferPhysAddr;
; 1113 :         
; 1114 :         //  Adjust for VRFB limit on image width and height (0 indicates max of 2K pixels)
; 1115 :         pInfo->dwImageWidth = (pInfo->dwImageWidth == 0) ? VRFB_IMAGE_WIDTH_MAX : pInfo->dwImageWidth;

  000fc	03a01b02	 moveq       r1, #2, 22
  00100	e0833200	 add         r3, r3, r0, lsl #4
  00104	e5933000	 ldr         r3, [r3]
  00108	e5862024	 str         r2, [r6, #0x24]
  0010c	e586e028	 str         lr, [r6, #0x28]
  00110	e1a03283	 mov         r3, r3, lsl #5
  00114	e1a02aa3	 mov         r2, r3, lsr #21
  00118	e5862020	 str         r2, [r6, #0x20]
  0011c	e597300c	 ldr         r3, [r7, #0xC]

; 1116 :         pInfo->dwImageHeight = (pInfo->dwImageHeight == 0) ? VRFB_IMAGE_HEIGHT_MAX : pInfo->dwImageHeight;

  00120	e3520000	 cmp         r2, #0
  00124	03a02b02	 moveq       r2, #2, 22
  00128	e586302c	 str         r3, [r6, #0x2C]
  0012c	e5973014	 ldr         r3, [r7, #0x14]

; 1117 :         
; 1118 :         bResult = TRUE;

  00130	e3a00001	 mov         r0, #1
  00134	e5863030	 str         r3, [r6, #0x30]
  00138	e5973010	 ldr         r3, [r7, #0x10]
  0013c	e0833004	 add         r3, r3, r4
  00140	e5863034	 str         r3, [r6, #0x34]
  00144	e5973010	 ldr         r3, [r7, #0x10]
  00148	e5863038	 str         r3, [r6, #0x38]
  0014c	e5973018	 ldr         r3, [r7, #0x18]
  00150	e586101c	 str         r1, [r6, #0x1C]
  00154	e5862020	 str         r2, [r6, #0x20]
  00158	e586303c	 str         r3, [r6, #0x3C]
  0015c		 |$cleanUp$45411|

; 1119 :     }    
; 1120 :     else
; 1121 :     {
; 1122 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_GetViewInfo: "
; 1123 :             L"Invalid view handle 0x%08X\r\n", hView
; 1124 :             ));
; 1125 :         goto cleanUp;
; 1126 :     }
; 1127 : 
; 1128 : cleanUp:    
; 1129 :     //  Return result
; 1130 :     return bResult;
; 1131 : }

  0015c	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00160	e12fff1e	 bx          lr
  00164		 |$LN20@VRFB_GetVi|
  00164		 |$LN21@VRFB_GetVi|
  00164	00000000	 DCD         |g_VrfbContextList|
  00168		 |$LN22@VRFB_GetVi|
  00168	76726649	 DCD         0x76726649
  0016c		 |$M45797|

			 ENDP  ; |VRFB_GetViewInfo|

	EXPORT	|VRFB_RotateView|
	IMPORT	|VirtualCopy|
; File c:\wince600\public\common\oak\inc\pkfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T45824| DCD	|$LN20@VRFB_Rotat|
	DCD	0x40004502
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\vrfb\omap_vrfb.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |VRFB_RotateView| PROC

; 1140 : {

  00000		 |$LN20@VRFB_Rotat|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M45821|
  00008	e1a05002	 mov         r5, r2
  0000c	e3500000	 cmp         r0, #0

; 1141 :     BOOL        bResult = FALSE;

  00010	e3a0e000	 mov         lr, #0

; 1142 :     Instance_t *pInstance = (Instance_t*)hContext;
; 1143 :     Device_t   *pDevice;
; 1144 :     DWORD       index;
; 1145 :     DWORD       offset = 0;

  00014	e3a04000	 mov         r4, #0

; 1146 : 
; 1147 :  
; 1148 :     DEBUGMSG(ZONE_FUNCTION, (
; 1149 :         L"+VRFB_RotateView(0x%08x, 0x%08x, %d)\r\n", hContext, hView, dwRotateAngle
; 1150 :         ));
; 1151 : 
; 1152 :     // Check if we get correct context
; 1153 :     if ((pInstance == NULL) || (pInstance->cookie != VRFB_INSTANCE_COOKIE))

  00018	0a000037	 beq         |$cleanUp$45450|
  0001c	e5900000	 ldr         r0, [r0]
  00020	e59f30e8	 ldr         r3, [pc, #0xE8]
  00024	e1500003	 cmp         r0, r3
  00028	1a000033	 bne         |$cleanUp$45450|

; 1154 :         {
; 1155 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_RotateView: "
; 1156 :             L"Incorrect context param\r\n"
; 1157 :             ));
; 1158 :         goto cleanUp;
; 1159 :         }
; 1160 : 
; 1161 :     //  Get Device
; 1162 :     pDevice = pInstance->pDevice;
; 1163 : 
; 1164 : 
; 1165 :     //  Validate view handle
; 1166 :     index = (DWORD)hView - VRFB_VIEW_HANDLE_BASE;

  0002c	e2412206	 sub         r2, r1, #6, 4

; 1167 :     
; 1168 :     if( index < VRFB_ROTATION_CONTEXTS && g_VrfbContextList[index].bInUse )

  00030	e352000c	 cmp         r2, #0xC
  00034	2a000030	 bcs         |$cleanUp$45450|
  00038	e59f10cc	 ldr         r1, [pc, #0xCC]
  0003c	e7913282	 ldr         r3, [r1, +r2, lsl #5]
  00040	e3530000	 cmp         r3, #0
  00044	0a00002c	 beq         |$cleanUp$45450|

; 1169 :     {
; 1170 :         //  If the rotation angle is the same as currently set, do nothing
; 1171 :         if( dwRotateAngle == g_VrfbContextList[index].dwRotationAngle )

  00048	e0816282	 add         r6, r1, r2, lsl #5
  0004c	e596300c	 ldr         r3, [r6, #0xC]
  00050	e1550003	 cmp         r5, r3

; 1172 :         {
; 1173 :             bResult = TRUE;

  00054	03a0e001	 moveq       lr, #1
  00058	0a000027	 beq         |$cleanUp$45450|

; 1174 :             goto cleanUp;
; 1175 :         }
; 1176 :         
; 1177 :         //  Rotate the view by remapping underlying VRFB physical address into the virtual address for the view
; 1178 :         switch( dwRotateAngle )

  0005c	e355005a	 cmp         r5, #0x5A
  00060	0a000007	 beq         |$LN5@VRFB_Rotat|
  00064	e35500b4	 cmp         r5, #0xB4
  00068	0a000004	 beq         |$LN6@VRFB_Rotat|
  0006c	e3a03c01	 mov         r3, #1, 24
  00070	e383300e	 orr         r3, r3, #0xE
  00074	e1550003	 cmp         r5, r3
  00078	1a000002	 bne         |$LN4@VRFB_Rotat|

; 1179 :         {
; 1180 :             //  Deliberate fall through on the case statements below
; 1181 :             case VRFB_ROTATE_ANGLE_270:
; 1182 :                 offset += VRFB_VIEW_SIZE;

  0007c	e3a04401	 mov         r4, #1, 8
  00080		 |$LN6@VRFB_Rotat|

; 1183 :                 
; 1184 :             case VRFB_ROTATE_ANGLE_180:
; 1185 :                 offset += VRFB_VIEW_SIZE;

  00080	e2844401	 add         r4, r4, #1, 8
  00084		 |$LN5@VRFB_Rotat|

; 1186 : 
; 1187 :             case VRFB_ROTATE_ANGLE_90:
; 1188 :                 offset += VRFB_VIEW_SIZE;

  00084	e2844401	 add         r4, r4, #1, 8
  00088		 |$LN4@VRFB_Rotat|

; 1189 : 
; 1190 :             case VRFB_ROTATE_ANGLE_0:
; 1191 :             default:
; 1192 :                 break;
; 1193 :         }
; 1194 :         
; 1195 :         //  Decommit the existing mapping to VRFB 
; 1196 :         VirtualFree( (VOID*)g_VrfbContextList[index].dwVirtualAddr, VRFB_VIEW_SIZE, MEM_DECOMMIT );

  00088	e5960014	 ldr         r0, [r6, #0x14]
  0008c	e3a02901	 mov         r2, #1, 18
  00090	e3a01401	 mov         r1, #1, 8
  00094	eb000000	 bl          VirtualFree

; 1197 : 
; 1198 :         //  Associate to the selected rotation angle offset
; 1199 :         bResult = VirtualCopy( (VOID*)g_VrfbContextList[index].dwVirtualAddr, 
; 1200 :                                (VOID*)((g_VrfbContextList[index].dwPhysicalAddr + offset)/256), 
; 1201 :                                VRFB_VIEW_SIZE, 
; 1202 :                                PAGE_READWRITE | PAGE_PHYSICAL | PAGE_NOCACHE );

  00098	e5963010	 ldr         r3, [r6, #0x10]
  0009c	e5960014	 ldr         r0, [r6, #0x14]
  000a0	e3a02c06	 mov         r2, #6, 24
  000a4	e0833004	 add         r3, r3, r4
  000a8	e1a01423	 mov         r1, r3, lsr #8
  000ac	e3823004	 orr         r3, r2, #4
  000b0	e3a02401	 mov         r2, #1, 8
  000b4	eb000000	 bl          VirtualCopy
  000b8	e1b0e000	 movs        lr, r0

; 1203 : 
; 1204 :         if( bResult == FALSE )

  000bc	0a00000e	 beq         |$cleanUp$45450|

; 1205 :         {
; 1206 :             DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_RotateView: "
; 1207 :                  L"Failed map context memory for context # %d\r\n", index
; 1208 :                 ));
; 1209 :             goto cleanUp;
; 1210 :         }
; 1211 : 
; 1212 :         //  Change the attributes of the buffer for cache write thru
; 1213 :         bResult = CeSetMemoryAttributes( (VOID*)g_VrfbContextList[index].dwVirtualAddr, (VOID*)((g_VrfbContextList[index].dwPhysicalAddr + offset)/256), VRFB_VIEW_SIZE, PAGE_WRITECOMBINE );

  000c0	e5963010	 ldr         r3, [r6, #0x10]
  000c4	e5962014	 ldr         r2, [r6, #0x14]
  000c8	e3a07000	 mov         r7, #0
  000cc	e0833004	 add         r3, r3, r4
  000d0	e1a03423	 mov         r3, r3, lsr #8
  000d4	e58d3000	 str         r3, [sp]
  000d8	e3a0eb01	 mov         lr, #1, 22
  000dc	e3a03401	 mov         r3, #1, 8
  000e0	e3a0100c	 mov         r1, #0xC
  000e4	e3a00001	 mov         r0, #1
  000e8	e58d7008	 str         r7, [sp, #8]
  000ec	e58de004	 str         lr, [sp, #4]
  000f0	eb000000	 bl          KernelLibIoControl
  000f4	e1b0e000	 movs        lr, r0

; 1214 :         if( bResult == FALSE )
; 1215 :         {
; 1216 :             DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_RotateView: "
; 1217 :                  L"Failed CeSetMemoryAttributes for context # %d\r\n", index
; 1218 :                 ));
; 1219 :             goto cleanUp;
; 1220 :         }
; 1221 :         
; 1222 :         //  Set new rotation angle
; 1223 :         g_VrfbContextList[index].dwRotationAngle = dwRotateAngle;

  000f8	1586500c	 strne       r5, [r6, #0xC]
  000fc		 |$cleanUp$45450|

; 1224 :     }
; 1225 :     else
; 1226 :     {
; 1227 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_RotateView: "
; 1228 :             L"Invalid view handle 0x%08X\r\n", hView
; 1229 :             ));
; 1230 :         goto cleanUp;
; 1231 :     }
; 1232 :     
; 1233 : cleanUp:    
; 1234 :     //  Return result
; 1235 :     DEBUGMSG(ZONE_FUNCTION, (L"-VRFB_RotateView(bResult = %d)\r\n", bResult));
; 1236 :     return bResult;
; 1237 : }

  000fc	e1a0000e	 mov         r0, lr
  00100	e28dd00c	 add         sp, sp, #0xC
  00104	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00108	e12fff1e	 bx          lr
  0010c		 |$LN21@VRFB_Rotat|
  0010c		 |$LN22@VRFB_Rotat|
  0010c	00000000	 DCD         |g_VrfbContextList|
  00110		 |$LN23@VRFB_Rotat|
  00110	76726649	 DCD         0x76726649
  00114		 |$M45822|

			 ENDP  ; |VRFB_RotateView|

	EXPORT	|VRFB_NumDisplayViews|

  00000			 AREA	 |.pdata|, PDATA
|$T45838| DCD	|$LN7@VRFB_NumDi|
	DCD	0x40000a00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |VRFB_NumDisplayViews| PROC

; 1347 : {

  00000		 |$LN7@VRFB_NumDi|
  00000		 |$M45835|
  00000	e1b01000	 movs        r1, r0

; 1348 :     DWORD       dwResult = 0;

  00004	e3a00000	 mov         r0, #0

; 1349 :     Instance_t *pInstance = (Instance_t*)hContext;
; 1350 :     Device_t   *pDevice;
; 1351 : 
; 1352 :     // Check if we get correct context
; 1353 :     if ((pInstance == NULL) || (pInstance->cookie != VRFB_INSTANCE_COOKIE))

  00008	0a000004	 beq         |$cleanUp$45534|
  0000c	e5912000	 ldr         r2, [r1]
  00010	e59f300c	 ldr         r3, [pc, #0xC]
  00014	e1520003	 cmp         r2, r3

; 1354 :         {
; 1355 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_NumDisplayViews: "
; 1356 :             L"Incorrect context param\r\n"
; 1357 :             ));
; 1358 :         goto cleanUp;
; 1359 :         }
; 1360 : 
; 1361 :     //  Get Device
; 1362 :     pDevice = pInstance->pDevice;
; 1363 : 
; 1364 :     //  Get value
; 1365 :     dwResult = pDevice->dwNumDisplayContexts;

  00018	05913004	 ldreq       r3, [r1, #4]
  0001c	05930004	 ldreq       r0, [r3, #4]
  00020		 |$cleanUp$45534|

; 1366 :     
; 1367 : cleanUp:    
; 1368 :     //  Return result
; 1369 :     return dwResult;
; 1370 : }

  00020	e12fff1e	 bx          lr
  00024		 |$LN8@VRFB_NumDi|
  00024		 |$LN9@VRFB_NumDi|
  00024	76726649	 DCD         0x76726649
  00028		 |$M45836|

			 ENDP  ; |VRFB_NumDisplayViews|

	EXPORT	|VRFB_GetDisplayView|

  00000			 AREA	 |.pdata|, PDATA
|$T45852| DCD	|$LN8@VRFB_GetDi|
	DCD	0x40000f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |VRFB_GetDisplayView| PROC

; 1379 : {

  00000		 |$LN8@VRFB_GetDi|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45849|
  00004	e1b0e000	 movs        lr, r0

; 1380 :     HANDLE      hView = NULL;

  00008	e3a00000	 mov         r0, #0

; 1381 :     Instance_t *pInstance = (Instance_t*)hContext;
; 1382 :     Device_t   *pDevice;
; 1383 : 
; 1384 :     // Check if we get correct context
; 1385 :     if ((pInstance == NULL) || (pInstance->cookie != VRFB_INSTANCE_COOKIE))

  0000c	0a000007	 beq         |$cleanUp$45549|
  00010	e59e2000	 ldr         r2, [lr]
  00014	e59f301c	 ldr         r3, [pc, #0x1C]
  00018	e1520003	 cmp         r2, r3
  0001c	1a000003	 bne         |$cleanUp$45549|

; 1386 :         {
; 1387 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_GetDisplayView: "
; 1388 :             L"Incorrect context param\r\n"
; 1389 :             ));
; 1390 :         goto cleanUp;
; 1391 :         }
; 1392 : 
; 1393 :     //  Get Device
; 1394 :     pDevice = pInstance->pDevice;
; 1395 : 
; 1396 :     //  Check the index value
; 1397 :     if( dwIndex < pDevice->dwNumDisplayContexts )

  00020	e59e3004	 ldr         r3, [lr, #4]
  00024	e5933004	 ldr         r3, [r3, #4]
  00028	e1510003	 cmp         r1, r3

; 1398 :     {
; 1399 :         //  A view handle is just the index of the VRFB context
; 1400 :         hView = (HANDLE)(VRFB_VIEW_HANDLE_BASE + dwIndex);  

  0002c	32810206	 addcc       r0, r1, #6, 4
  00030		 |$cleanUp$45549|

; 1401 :     }
; 1402 :     
; 1403 : cleanUp:    
; 1404 :     //  Return result
; 1405 :     return hView;
; 1406 : }

  00030	e49de004	 ldr         lr, [sp], #4
  00034	e12fff1e	 bx          lr
  00038		 |$LN9@VRFB_GetDi|
  00038		 |$LN10@VRFB_GetDi|
  00038	76726649	 DCD         0x76726649
  0003c		 |$M45850|

			 ENDP  ; |VRFB_GetDisplayView|

	EXPORT	|VRFB_GetDisplayViewInfo|

  00000			 AREA	 |.pdata|, PDATA
|$T45884| DCD	|$LN42@VRFB_GetDi@2|
	DCD	0x40008801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |VRFB_GetDisplayViewInfo| PROC

; 1415 : {

  00000		 |$LN42@VRFB_GetDi@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M45881|
  00004	e1a0a003	 mov         r10, r3
  00008	e1a05002	 mov         r5, r2
  0000c	e1a08001	 mov         r8, r1
  00010	e3500000	 cmp         r0, #0

; 1416 :     BOOL        bResult = FALSE;

  00014	e3a03000	 mov         r3, #0

; 1417 :     Instance_t *pInstance = (Instance_t*)hContext;
; 1418 :     Device_t   *pDevice;
; 1419 :  
; 1420 : 
; 1421 :     // Check if we get correct context
; 1422 :     if ((pInstance == NULL) || (pInstance->cookie != VRFB_INSTANCE_COOKIE))

  00018	0a00007b	 beq         |$cleanUp$45571|
  0001c	e5904000	 ldr         r4, [r0]
  00020	e59fe1f4	 ldr         lr, [pc, #0x1F4]
  00024	e154000e	 cmp         r4, lr
  00028	1a000077	 bne         |$cleanUp$45571|

; 1423 :         {
; 1424 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_GetDisplayViewInfo: "
; 1425 :             L"Incorrect context param\r\n"
; 1426 :             ));
; 1427 :         goto cleanUp;
; 1428 :         }
; 1429 : 
; 1430 :     //  Get Device
; 1431 :     pDevice = pInstance->pDevice;

  0002c	e590b004	 ldr         r11, [r0, #4]

; 1432 : 
; 1433 :     //  Check the index value
; 1434 :     if( dwIndex < pDevice->dwNumDisplayContexts )

  00030	e59b0004	 ldr         r0, [r11, #4]
  00034	e1580000	 cmp         r8, r0
  00038	2a000073	 bcs         |$cleanUp$45571|

; 1435 :     {
; 1436 :         DWORD   dwRotationOffset;
; 1437 :         
; 1438 :         //  Get VRFB view rotation offset for requested output angle
; 1439 :         switch( dwRotateAngle )

  0003c	e3a03c01	 mov         r3, #1, 24
  00040	e383900e	 orr         r9, r3, #0xE
  00044	e355005a	 cmp         r5, #0x5A
  00048	0a00000d	 beq         |$LN17@VRFB_GetDi@2|
  0004c	e35500b4	 cmp         r5, #0xB4
  00050	0a000007	 beq         |$LN18@VRFB_GetDi@2|
  00054	e1550009	 cmp         r5, r9
  00058	0a000003	 beq         |$LN19@VRFB_GetDi@2|

; 1451 :                 break;
; 1452 : 
; 1453 :             case VRFB_ROTATE_ANGLE_0:
; 1454 :             default:
; 1455 :                 dwRotationOffset = (bMirror) ? 2*VRFB_VIEW_SIZE : 0;

  0005c	e35a0000	 cmp         r10, #0
  00060	1a000005	 bne         |$LN27@VRFB_GetDi@2|
  00064		 |$LN29@VRFB_GetDi@2|
  00064	e3a07000	 mov         r7, #0

; 1456 :                 break;

  00068	ea000006	 b           |$LN20@VRFB_GetDi@2|
  0006c		 |$LN19@VRFB_GetDi@2|

; 1440 :         {
; 1441 :             case VRFB_ROTATE_ANGLE_270:
; 1442 :                 dwRotationOffset = VRFB_VIEW_SIZE;

  0006c	e3a07401	 mov         r7, #1, 8

; 1443 :                 break;

  00070	ea000004	 b           |$LN20@VRFB_GetDi@2|
  00074		 |$LN18@VRFB_GetDi@2|

; 1444 :                 
; 1445 :             case VRFB_ROTATE_ANGLE_180:
; 1446 :                 dwRotationOffset = (bMirror) ? 0 : 2*VRFB_VIEW_SIZE;

  00074	e35a0000	 cmp         r10, #0
  00078	1afffff9	 bne         |$LN29@VRFB_GetDi@2|
  0007c		 |$LN27@VRFB_GetDi@2|
  0007c	e3a07402	 mov         r7, #2, 8

; 1447 :                 break;

  00080	ea000000	 b           |$LN20@VRFB_GetDi@2|
  00084		 |$LN17@VRFB_GetDi@2|

; 1448 : 
; 1449 :             case VRFB_ROTATE_ANGLE_90:
; 1450 :                 dwRotationOffset = 3*VRFB_VIEW_SIZE;

  00084	e3a07403	 mov         r7, #3, 8
  00088		 |$LN20@VRFB_GetDi@2|

; 1457 :         }
; 1458 : 
; 1459 : 
; 1460 :         //  Fill in the view info structure
; 1461 :         memset( pInfo, 0, sizeof(VRFB_VIEW_INFO));

  00088	e59d4024	 ldr         r4, [sp, #0x24]
  0008c	e3a02040	 mov         r2, #0x40
  00090	e3a01000	 mov         r1, #0
  00094	e1a00004	 mov         r0, r4
  00098	eb000000	 bl          memset

; 1462 :         
; 1463 :         pInfo->dwPixelSize = INREG32(&pDevice->pVRFBRegs->aVRFB_SMS_ROT_CTRL[dwIndex].VRFB_SMS_ROT_CONTROL) & 0x00000003;

  0009c	e59b3024	 ldr         r3, [r11, #0x24]

; 1464 :         pInfo->dwPixelSizeBytes = PIXEL_SIZE_TO_BYTES(pInfo->dwPixelSize);
; 1465 :         pInfo->dwWidth = g_VrfbContextList[dwIndex].dwWidth;

  000a0	e59f2170	 ldr         r2, [pc, #0x170]
  000a4	e3a01001	 mov         r1, #1
  000a8	e0833208	 add         r3, r3, r8, lsl #4
  000ac	e593301c	 ldr         r3, [r3, #0x1C]
  000b0	e082e288	 add         lr, r2, r8, lsl #5

; 1466 :         pInfo->dwHeight = g_VrfbContextList[dwIndex].dwHeight;
; 1467 :         pInfo->dwPageWidth = DEFAULT_PAGE_WIDTH;
; 1468 :         pInfo->dwPageHeight = DEFAULT_PAGE_HEIGHT;
; 1469 :         pInfo->dwImageWidth = INREG32(&pDevice->pVRFBRegs->aVRFB_SMS_ROT_CTRL[dwIndex].VRFB_SMS_ROT_SIZE) & 0x000007FF;

  000b4	e2880002	 add         r0, r8, #2
  000b8	e2033003	 and         r3, r3, #3
  000bc	e1a06311	 mov         r6, r1, lsl r3
  000c0	e5843004	 str         r3, [r4, #4]
  000c4	e5846008	 str         r6, [r4, #8]
  000c8	e59e3004	 ldr         r3, [lr, #4]
  000cc	e3a01004	 mov         r1, #4
  000d0	e3a02c07	 mov         r2, #7, 24
  000d4	e584300c	 str         r3, [r4, #0xC]
  000d8	e59e3008	 ldr         r3, [lr, #8]
  000dc	e5841014	 str         r1, [r4, #0x14]
  000e0	e5841018	 str         r1, [r4, #0x18]
  000e4	e5843010	 str         r3, [r4, #0x10]
  000e8	e59b3024	 ldr         r3, [r11, #0x24]
  000ec	e38220ff	 orr         r2, r2, #0xFF

; 1470 :         pInfo->dwImageHeight = (INREG32(&pDevice->pVRFBRegs->aVRFB_SMS_ROT_CTRL[dwIndex].VRFB_SMS_ROT_SIZE)>>16) & 0x000007FF;
; 1471 :         pInfo->dwImageStride = PIXEL_SIZE_TO_BYTES(pInfo->dwPixelSize) * VRFB_IMAGE_WIDTH_MAX;

  000f0	e1a01586	 mov         r1, r6, lsl #11
  000f4	e0833200	 add         r3, r3, r0, lsl #4
  000f8	e5933000	 ldr         r3, [r3]
  000fc	e0138002	 ands        r8, r3, r2
  00100	e584801c	 str         r8, [r4, #0x1C]
  00104	e59b3024	 ldr         r3, [r11, #0x24]

; 1472 :         pInfo->dwRotationAngle = dwRotateAngle;
; 1473 :         pInfo->dwVirtualAddr = g_VrfbContextList[dwIndex].dwVirtualAddr;
; 1474 :         pInfo->dwPhysicalAddrInput = g_VrfbContextList[dwIndex].dwPhysicalAddr;
; 1475 :         pInfo->dwPhysicalAddrOutput = g_VrfbContextList[dwIndex].dwPhysicalAddr + dwRotationOffset;
; 1476 :         pInfo->dwPhysicalBufferAddr = g_VrfbContextList[dwIndex].dwBufferPhysAddr;
; 1477 :         
; 1478 :         //  Adjust for VRFB limit on image width and height (0 indicates max of 2K pixels)
; 1479 :         pInfo->dwImageWidth = (pInfo->dwImageWidth == 0) ? VRFB_IMAGE_WIDTH_MAX : pInfo->dwImageWidth;

  00108	03a08b02	 moveq       r8, #2, 22
  0010c	e0833200	 add         r3, r3, r0, lsl #4
  00110	e5933000	 ldr         r3, [r3]
  00114	e5841024	 str         r1, [r4, #0x24]
  00118	e584502c	 str         r5, [r4, #0x2C]
  0011c	e1a03283	 mov         r3, r3, lsl #5
  00120	e1a01aa3	 mov         r1, r3, lsr #21
  00124	e5841020	 str         r1, [r4, #0x20]
  00128	e59e3014	 ldr         r3, [lr, #0x14]

; 1480 :         pInfo->dwImageHeight = (pInfo->dwImageHeight == 0) ? VRFB_IMAGE_HEIGHT_MAX : pInfo->dwImageHeight;

  0012c	e3510000	 cmp         r1, #0
  00130	03a01b02	 moveq       r1, #2, 22
  00134	e5843030	 str         r3, [r4, #0x30]
  00138	e59e3010	 ldr         r3, [lr, #0x10]

; 1481 : 
; 1482 :         //  Compute pixel origin offset
; 1483 :         if( bMirror )

  0013c	e35a0000	 cmp         r10, #0
  00140	e5843034	 str         r3, [r4, #0x34]
  00144	e59e3010	 ldr         r3, [lr, #0x10]
  00148	e0833007	 add         r3, r3, r7
  0014c	e5843038	 str         r3, [r4, #0x38]
  00150	e59e3018	 ldr         r3, [lr, #0x18]
  00154	e584801c	 str         r8, [r4, #0x1C]
  00158	e5841020	 str         r1, [r4, #0x20]
  0015c	e584303c	 str         r3, [r4, #0x3C]
  00160	0a000011	 beq         |$LN15@VRFB_GetDi@2|

; 1484 :         {
; 1485 :             //  Compute pixel origin offset (mirrored)
; 1486 :             switch( dwRotateAngle )

  00164	e355005a	 cmp         r5, #0x5A
  00168	0a00000d	 beq         |$LN10@VRFB_GetDi@2|
  0016c	e35500b4	 cmp         r5, #0xB4
  00170	0a000008	 beq         |$LN11@VRFB_GetDi@2|
  00174	e1550009	 cmp         r5, r9

; 1499 :                     break;
; 1500 : 
; 1501 :                 case VRFB_ROTATE_ANGLE_0:
; 1502 :                 default:
; 1503 :                     pInfo->dwOriginOffset  = VRFB_IMAGE_WIDTH_MAX * (pInfo->dwImageHeight - 1) * pInfo->dwPixelSizeBytes;
; 1504 :                     pInfo->dwOriginOffset += (pInfo->dwImageWidth - pInfo->dwWidth) * pInfo->dwPixelSizeBytes;

  00178	12413001	 subne       r3, r1, #1
  0017c	1a000018	 bne         |$LN39@VRFB_GetDi@2|
  00180	e594300c	 ldr         r3, [r4, #0xC]
  00184	e5942010	 ldr         r2, [r4, #0x10]
  00188	e2433001	 sub         r3, r3, #1
  0018c	e0623583	 rsb         r3, r2, r3, lsl #11
  00190	e0833001	 add         r3, r3, r1
  00194	ea00000d	 b           |$LN37@VRFB_GetDi@2|
  00198		 |$LN11@VRFB_GetDi@2|

; 1487 :             {
; 1488 :                 case VRFB_ROTATE_ANGLE_270:
; 1489 :                     pInfo->dwOriginOffset  = VRFB_IMAGE_WIDTH_MAX * (pInfo->dwWidth - 1) * pInfo->dwPixelSizeBytes;
; 1490 :                     pInfo->dwOriginOffset += (pInfo->dwImageHeight - pInfo->dwHeight) * pInfo->dwPixelSizeBytes;
; 1491 :                     break;
; 1492 :                     
; 1493 :                 case VRFB_ROTATE_ANGLE_180:
; 1494 :                     pInfo->dwOriginOffset  = VRFB_IMAGE_WIDTH_MAX * (pInfo->dwHeight - 1) * pInfo->dwPixelSizeBytes;

  00198	e5943010	 ldr         r3, [r4, #0x10]
  0019c	e2433001	 sub         r3, r3, #1

; 1495 :                     break;

  001a0	ea000015	 b           |$LN35@VRFB_GetDi@2|
  001a4		 |$LN10@VRFB_GetDi@2|

; 1496 : 
; 1497 :                 case VRFB_ROTATE_ANGLE_90:
; 1498 :                     pInfo->dwOriginOffset = VRFB_IMAGE_HEIGHT_MAX * (pInfo->dwImageWidth - 1) * pInfo->dwPixelSizeBytes;

  001a4	e2483001	 sub         r3, r8, #1

; 1505 :                     break;
; 1506 :             }
; 1507 :         }
; 1508 :         else

  001a8	ea000013	 b           |$LN35@VRFB_GetDi@2|
  001ac		 |$LN15@VRFB_GetDi@2|

; 1509 :         {
; 1510 :             //  Compute pixel origin offset (non-mirrored)
; 1511 :             switch( dwRotateAngle )

  001ac	e355005a	 cmp         r5, #0x5A
  001b0	0a00000f	 beq         |$LN3@VRFB_GetDi@2|
  001b4	e35500b4	 cmp         r5, #0xB4
  001b8	0a000007	 beq         |$LN4@VRFB_GetDi@2|
  001bc	e1550009	 cmp         r5, r9

; 1524 :                     break;
; 1525 : 
; 1526 :                 case VRFB_ROTATE_ANGLE_0:
; 1527 :                 default:
; 1528 :                     pInfo->dwOriginOffset = 0;

  001c0	13a03000	 movne       r3, #0
  001c4	1a00000e	 bne         |$LN36@VRFB_GetDi@2|
  001c8	e5943010	 ldr         r3, [r4, #0x10]
  001cc	e0413003	 sub         r3, r1, r3
  001d0		 |$LN37@VRFB_GetDi@2|
  001d0	e0020693	 mul         r2, r3, r6
  001d4	e5842028	 str         r2, [r4, #0x28]
  001d8	ea00000a	 b           |$LN6@VRFB_GetDi@2|
  001dc		 |$LN4@VRFB_GetDi@2|

; 1512 :             {
; 1513 :                 case VRFB_ROTATE_ANGLE_270:
; 1514 :                     pInfo->dwOriginOffset = (pInfo->dwImageHeight - pInfo->dwHeight) * pInfo->dwPixelSizeBytes;
; 1515 :                     break;
; 1516 :                     
; 1517 :                 case VRFB_ROTATE_ANGLE_180:
; 1518 :                     pInfo->dwOriginOffset  = VRFB_IMAGE_WIDTH_MAX * (pInfo->dwImageHeight - pInfo->dwHeight) * pInfo->dwPixelSizeBytes;

  001dc	e5943010	 ldr         r3, [r4, #0x10]

; 1519 :                     pInfo->dwOriginOffset += (pInfo->dwImageWidth - pInfo->dwWidth) * pInfo->dwPixelSizeBytes;

  001e0	e0413003	 sub         r3, r1, r3
  001e4		 |$LN39@VRFB_GetDi@2|
  001e4	e594200c	 ldr         r2, [r4, #0xC]
  001e8	e0623583	 rsb         r3, r2, r3, lsl #11
  001ec	e0833008	 add         r3, r3, r8

; 1520 :                     break;

  001f0	eafffff6	 b           |$LN37@VRFB_GetDi@2|
  001f4		 |$LN3@VRFB_GetDi@2|

; 1521 : 
; 1522 :                 case VRFB_ROTATE_ANGLE_90:
; 1523 :                     pInfo->dwOriginOffset = VRFB_IMAGE_HEIGHT_MAX * (pInfo->dwImageWidth - pInfo->dwWidth) * pInfo->dwPixelSizeBytes;

  001f4	e594300c	 ldr         r3, [r4, #0xC]
  001f8	e0483003	 sub         r3, r8, r3
  001fc		 |$LN35@VRFB_GetDi@2|
  001fc	e0020693	 mul         r2, r3, r6
  00200	e1a03582	 mov         r3, r2, lsl #11
  00204		 |$LN36@VRFB_GetDi@2|
  00204	e5843028	 str         r3, [r4, #0x28]
  00208		 |$LN6@VRFB_GetDi@2|

; 1529 :                     break;
; 1530 :             }
; 1531 :         }
; 1532 :         
; 1533 :         bResult = TRUE;

  00208	e3a03001	 mov         r3, #1
  0020c		 |$cleanUp$45571|

; 1534 :     }    
; 1535 :     else
; 1536 :     {
; 1537 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_GetDisplayViewInfo: "
; 1538 :             L"Invalid view index %d\r\n", dwIndex
; 1539 :             ));
; 1540 :         goto cleanUp;
; 1541 :     }
; 1542 : 
; 1543 : cleanUp:    
; 1544 :     //  Return result
; 1545 :     return bResult;
; 1546 : }

  0020c	e1a00003	 mov         r0, r3
  00210	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00214	e12fff1e	 bx          lr
  00218		 |$LN43@VRFB_GetDi@2|
  00218		 |$LN44@VRFB_GetDi@2|
  00218	00000000	 DCD         |g_VrfbContextList|
  0021c		 |$LN45@VRFB_GetDi@2|
  0021c	76726649	 DCD         0x76726649
  00220		 |$M45882|

			 ENDP  ; |VRFB_GetDisplayViewInfo|

	EXPORT	|DebugPrintRegs|

  00000			 AREA	 |.pdata|, PDATA
|$T45896| DCD	|$LN5@DebugPrint|
	DCD	0x40000901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DebugPrintRegs| PROC

; 1555 : {

  00000		 |$LN5@DebugPrint|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45893|

; 1556 :     DWORD   dwControl,
; 1557 :             dwSize,
; 1558 :             dwBuffer;
; 1559 :             
; 1560 :     dwControl = INREG32(&pVrfbRegs->aVRFB_SMS_ROT_CTRL[dwIndex].VRFB_SMS_ROT_CONTROL);
; 1561 :     dwSize =    INREG32(&pVrfbRegs->aVRFB_SMS_ROT_CTRL[dwIndex].VRFB_SMS_ROT_SIZE);

  00004	e2813002	 add         r3, r1, #2
  00008	e080e201	 add         lr, r0, r1, lsl #4
  0000c	e59e101c	 ldr         r1, [lr, #0x1C]
  00010	e0803203	 add         r3, r0, r3, lsl #4
  00014	e5932000	 ldr         r2, [r3]

; 1562 :     dwBuffer =  INREG32(&pVrfbRegs->aVRFB_SMS_ROT_CTRL[dwIndex].VRFB_SMS_ROT_PHYSICAL_BA);

  00018	e59e3024	 ldr         r3, [lr, #0x24]

; 1563 : 
; 1564 :     DEBUGMSG(ZONE_INFO, (L"DebugPrintRegs: VRFB Context #           = %d\r\n", dwIndex));
; 1565 :     DEBUGMSG(ZONE_INFO, (L"DebugPrintRegs: VRFB_SMS_ROT_CONTROL     = 0x%08x\r\n", dwControl));
; 1566 :     DEBUGMSG(ZONE_INFO, (L"DebugPrintRegs: VRFB_SMS_ROT_SIZE        = 0x%08x\r\n", dwSize));
; 1567 :     DEBUGMSG(ZONE_INFO, (L"DebugPrintRegs: VRFB_SMS_ROT_PHYSICAL_BA = 0x%08x\r\n", dwBuffer));
; 1568 : }

  0001c	e49de004	 ldr         lr, [sp], #4
  00020	e12fff1e	 bx          lr
  00024		 |$M45894|

			 ENDP  ; |DebugPrintRegs|

	EXPORT	|DllMain|
	IMPORT	|DisableThreadLibraryCalls|
	IMPORT	|RegisterDbgZones|

  00000			 AREA	 |.pdata|, PDATA
|$T45907| DCD	|$LN8@DllMain|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DllMain| PROC

; 1584 : {

  00000		 |$LN8@DllMain|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M45904|
  00004	e1a04000	 mov         r4, r0

; 1585 :     UNREFERENCED_PARAMETER(pReserved);
; 1586 :     switch (reason)

  00008	e3510001	 cmp         r1, #1
  0000c	1a000003	 bne         |$LN2@DllMain|

; 1587 :         {
; 1588 :         case DLL_PROCESS_ATTACH:
; 1589 :             RETAILREGISTERZONES((HMODULE)hDLL);

  00010	e59f1014	 ldr         r1, [pc, #0x14]
  00014	eb000000	 bl          RegisterDbgZones

; 1590 :             DisableThreadLibraryCalls((HMODULE)hDLL);

  00018	e1a00004	 mov         r0, r4
  0001c	eb000000	 bl          DisableThreadLibraryCalls
  00020		 |$LN2@DllMain|

; 1591 :             break;
; 1592 :         }
; 1593 :     return TRUE;

  00020	e3a00001	 mov         r0, #1

; 1594 : }

  00024	e8bd4010	 ldmia       sp!, {r4, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$LN9@DllMain|
  0002c		 |$LN10@DllMain|
  0002c	00000000	 DCD         |dpCurSettings|
  00030		 |$M45905|

			 ENDP  ; |DllMain|

	EXPORT	|VRF_Init|
	IMPORT	|VirtualAlloc|
	IMPORT	|MmMapIoSpace|
	IMPORT	|GetAddressByDevice|
	IMPORT	|SOCGetVRFBDevice|
	IMPORT	|GetDeviceRegistryParams|
	IMPORT	|InitializeCriticalSection|
; File c:\wince600\public\common\oak\inc\pkfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T45935| DCD	|$LN25@VRF_Init|
	DCD	0x40006b02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\vrfb\omap_vrfb.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |VRF_Init| PROC

; 209  : {

  00000		 |$LN25@VRF_Init|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M45932|
  00008	e1a05000	 mov         r5, r0

; 210  :     DWORD rc = (DWORD)NULL;
; 211  :     PHYSICAL_ADDRESS pa;    
; 212  :     Device_t *pDevice;
; 213  :     DWORD i;
; 214  : 
; 215  :     UNREFERENCED_PARAMETER(pBusContext);
; 216  : 
; 217  :     DEBUGMSG(ZONE_FUNCTION, (
; 218  :         L"+VRF_Init(%s, 0x%08x)\r\n", szContext, pBusContext
; 219  :         ));
; 220  : 
; 221  :     // Create device structure
; 222  :     pDevice = (Device_t *)LocalAlloc(LPTR, sizeof(Device_t));

  0000c	e3a0102c	 mov         r1, #0x2C
  00010	e3a00040	 mov         r0, #0x40
  00014	e3a07000	 mov         r7, #0
  00018	eb000000	 bl          LocalAlloc
  0001c	e1b04000	 movs        r4, r0

; 223  :     if (pDevice == NULL)

  00020	0a000058	 beq         |$LN22@VRF_Init|

; 224  :         {
; 225  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRF_Init: "
; 226  :             L"Failed allocate VRFB controller structure\r\n"
; 227  :             ));
; 228  :         goto cleanUp;
; 229  :         }
; 230  : 
; 231  :     // initialize memory
; 232  :     memset(pDevice, 0, sizeof(Device_t));

  00024	e3a0202c	 mov         r2, #0x2C
  00028	e3a01000	 mov         r1, #0
  0002c	e1a00004	 mov         r0, r4
  00030	eb000000	 bl          memset

; 233  : 
; 234  :     // Set cookie
; 235  :     pDevice->cookie = VRFB_DEVICE_COOKIE;

  00034	e59f316c	 ldr         r3, [pc, #0x16C]

; 236  : 
; 237  :     // Initalize critical section
; 238  :     InitializeCriticalSection(&pDevice->cs);

  00038	e1a00004	 mov         r0, r4
  0003c	e4803008	 str         r3, [r0], #8
  00040	eb000000	 bl          InitializeCriticalSection

; 239  : 
; 240  :     // Read device parameters
; 241  :     if (GetDeviceRegistryParams(
; 242  :             szContext, pDevice, dimof(s_deviceRegParams), s_deviceRegParams
; 243  :             ) != ERROR_SUCCESS)

  00044	e59f3158	 ldr         r3, [pc, #0x158]
  00048	e3a02001	 mov         r2, #1
  0004c	e1a01004	 mov         r1, r4
  00050	e1a00005	 mov         r0, r5
  00054	eb000000	 bl          GetDeviceRegistryParams
  00058	e3500000	 cmp         r0, #0
  0005c	1a000049	 bne         |$LN22@VRF_Init|

; 244  :         {
; 245  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRF_Init: "
; 246  :             L"Failed read VRFB driver registry parameters\r\n"
; 247  :             ));
; 248  :         goto cleanUp;
; 249  :         }
; 250  :     
; 251  :     pDevice->device = SOCGetVRFBDevice();

  00060	eb000000	 bl          SOCGetVRFBDevice
  00064	e5840020	 str         r0, [r4, #0x20]

; 252  :     if (pDevice->device == OMAP_DEVICE_NONE)

  00068	e3700001	 cmn         r0, #1
  0006c	0a000045	 beq         |$LN22@VRF_Init|

; 253  :     {
; 254  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRF_Init: "
; 255  :             L"Failed to get VRFB device\r\n"
; 256  :             ));
; 257  :         goto cleanUp;
; 258  :     }
; 259  :     
; 260  :     // Set hardware to full power (VRFB has no power states)
; 261  :     EnableDeviceClocks(pDevice->device,TRUE);

  00070	e3a01001	 mov         r1, #1
  00074	eb000000	 bl          EnableDeviceClocks

; 262  : 
; 263  :     
; 264  :     //  Map VRFB control registers
; 265  :     pa.QuadPart = GetAddressByDevice(pDevice->device);    

  00078	e5940020	 ldr         r0, [r4, #0x20]
  0007c	eb000000	 bl          GetAddressByDevice

; 266  :     pDevice->pVRFBRegs = (OMAP_VRFB_REGS*)MmMapIoSpace(pa, sizeof(OMAP_VRFB_REGS), FALSE);

  00080	e3a01000	 mov         r1, #0
  00084	e3a03000	 mov         r3, #0
  00088	e3a020dc	 mov         r2, #0xDC
  0008c	eb000000	 bl          MmMapIoSpace
  00090	e3500000	 cmp         r0, #0
  00094	e5840024	 str         r0, [r4, #0x24]

; 267  :     if (pDevice->pVRFBRegs == NULL)

  00098	0a00003a	 beq         |$LN22@VRF_Init|

; 268  :         {
; 269  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRF_Init: "
; 270  :              L"Failed map VRFB control registers\r\n"
; 271  :             ));
; 272  :         goto cleanUp;
; 273  :         }
; 274  : 
; 275  :     //  Validate the number of contexts reserved for display
; 276  :     if( pDevice->dwNumDisplayContexts > VRFB_ROTATION_CONTEXTS )

  0009c	e5943004	 ldr         r3, [r4, #4]
  000a0	e353000c	 cmp         r3, #0xC

; 277  :         pDevice->dwNumDisplayContexts = VRFB_ROTATION_CONTEXTS;

  000a4	83a0300c	 movhi       r3, #0xC
  000a8	85843004	 strhi       r3, [r4, #4]

; 278  :         
; 279  :     //  Reserve the contiguous vitual memory region for the display contexts
; 280  :     if( pDevice->dwNumDisplayContexts > 0 )

  000ac	e5943004	 ldr         r3, [r4, #4]
  000b0	e1b01003	 movs        r1, r3
  000b4	0a000031	 beq         |$LN4@VRF_Init|

; 281  :     {
; 282  :         //  Reserve virtual memory for the display driver views
; 283  :         //  Note that this memory is not allocated, but is required by DDraw to be contiguous
; 284  :         pDevice->pDisplayContextMem = VirtualAlloc( NULL, 
; 285  :                                                     pDevice->dwNumDisplayContexts * VRFB_VIEW_SIZE, 
; 286  :                                                     MEM_RESERVE, 
; 287  :                                                     PAGE_NOACCESS );

  000b8	e3a03001	 mov         r3, #1
  000bc	e3a02a02	 mov         r2, #2, 20
  000c0	e1a01c01	 mov         r1, r1, lsl #24
  000c4	e3a00000	 mov         r0, #0
  000c8	eb000000	 bl          VirtualAlloc
  000cc	e3500000	 cmp         r0, #0
  000d0	e5840028	 str         r0, [r4, #0x28]

; 288  :                                                     
; 289  :         if( pDevice->pDisplayContextMem == NULL )

  000d4	0a00002b	 beq         |$LN22@VRF_Init|

; 290  :             {
; 291  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: VRF_Init: "
; 292  :                  L"Failed reserve display context memory\r\n"
; 293  :                 ));
; 294  :             goto cleanUp;
; 295  :             }
; 296  : 
; 297  :         DEBUGMSG(ZONE_INFO, (L"INFO: VRF_Init: "
; 298  :              L"Reserved display memory - num contexts = %d, size = 0x%08X, va = 0x%08X\r\n", 
; 299  :              pDevice->dwNumDisplayContexts, pDevice->dwNumDisplayContexts * VRFB_VIEW_SIZE, pDevice->pDisplayContextMem
; 300  :             ));
; 301  :         
; 302  :         
; 303  :         //  Associate the VRFB context addresses with the context virtual memory
; 304  :         for( i = 0; i < pDevice->dwNumDisplayContexts; i++ )

  000d8	e5943004	 ldr         r3, [r4, #4]
  000dc	e3a06000	 mov         r6, #0
  000e0	e3530000	 cmp         r3, #0
  000e4	9a000025	 bls         |$LN4@VRF_Init|
  000e8	e59f50b0	 ldr         r5, [pc, #0xB0]
  000ec	e3a08000	 mov         r8, #0
  000f0	e3a0a000	 mov         r10, #0
  000f4	e3a03c06	 mov         r3, #6, 24
  000f8	e3a0b001	 mov         r11, #1
  000fc		 |$LL6@VRF_Init|
  000fc	e5942028	 ldr         r2, [r4, #0x28]

; 305  :         {
; 306  :             BOOL    bResult;
; 307  :             VOID*   pMem = (VOID*)((DWORD)pDevice->pDisplayContextMem + i*VRFB_VIEW_SIZE);
; 308  :             
; 309  :             //  Associate to the rotation angle 0 context by default
; 310  :             bResult = VirtualCopy( pMem, 
; 311  :                                    (VOID*)(g_VrfbContextList[i].dwPhysicalAddr/256), 
; 312  :                                    VRFB_VIEW_SIZE, 
; 313  :                                    PAGE_READWRITE | PAGE_PHYSICAL | PAGE_NOCACHE );

  00100	e5951010	 ldr         r1, [r5, #0x10]
  00104	e3833004	 orr         r3, r3, #4
  00108	e0829008	 add         r9, r2, r8
  0010c	e1a00009	 mov         r0, r9
  00110	e3a02401	 mov         r2, #1, 8
  00114	e1a01421	 mov         r1, r1, lsr #8
  00118	eb000000	 bl          VirtualCopy
  0011c	e3500000	 cmp         r0, #0

; 314  : 
; 315  :             if( bResult == FALSE )

  00120	0a000018	 beq         |$LN22@VRF_Init|

; 316  :             {
; 317  :                 DEBUGMSG(ZONE_ERROR, (L"ERROR: VRF_Init: "
; 318  :                      L"Failed map display context memory for context # %d\r\n", i
; 319  :                     ));
; 320  :                 goto cleanUp;
; 321  :             }
; 322  : 
; 323  :             //  Change the attributes of the buffer for cache write thru
; 324  :             bResult = CeSetMemoryAttributes( pMem, (VOID*)(g_VrfbContextList[i].dwPhysicalAddr/256), VRFB_VIEW_SIZE, PAGE_WRITECOMBINE );

  00124	e5951010	 ldr         r1, [r5, #0x10]
  00128	e3a0eb01	 mov         lr, #1, 22
  0012c	e3a03401	 mov         r3, #1, 8
  00130	e1a01421	 mov         r1, r1, lsr #8
  00134	e58d1000	 str         r1, [sp]
  00138	e3a0100c	 mov         r1, #0xC
  0013c	e1a02009	 mov         r2, r9
  00140	e3a00001	 mov         r0, #1
  00144	e58da008	 str         r10, [sp, #8]
  00148	e58de004	 str         lr, [sp, #4]
  0014c	eb000000	 bl          KernelLibIoControl
  00150	e3500000	 cmp         r0, #0

; 325  :             if( bResult == FALSE )

  00154	0a00000b	 beq         |$LN22@VRF_Init|

; 326  :             {
; 327  :                 DEBUGMSG(ZONE_ERROR, (L"ERROR: VRF_Init: "
; 328  :                      L"Failed CeSetMemoryAttributes for context # %d\r\n", i
; 329  :                     ));
; 330  :                 goto cleanUp;
; 331  :             }
; 332  : 
; 333  :             DEBUGMSG(ZONE_INFO, (L"INFO: VRF_Init: "
; 334  :                  L"Context # %d: va = 0x%08X, pa = 0x%08X", 
; 335  :                  i, pMem, g_VrfbContextList[i].dwPhysicalAddr
; 336  :                 ));
; 337  :             
; 338  :             //  Update the context table
; 339  :             g_VrfbContextList[i].bInUse = TRUE;                                               

  00158	e585b000	 str         r11, [r5]

; 340  :             g_VrfbContextList[i].dwRotationAngle = VRFB_ROTATE_ANGLE_0;                                               

  0015c	e585a00c	 str         r10, [r5, #0xC]

; 341  :             g_VrfbContextList[i].dwVirtualAddr = (DWORD) pMem;

  00160	e5859014	 str         r9, [r5, #0x14]
  00164	e5943004	 ldr         r3, [r4, #4]
  00168	e2866001	 add         r6, r6, #1
  0016c	e2888401	 add         r8, r8, #1, 8
  00170	e1560003	 cmp         r6, r3
  00174	e3a03c06	 mov         r3, #6, 24
  00178	e2855020	 add         r5, r5, #0x20
  0017c	3affffde	 bcc         |$LL6@VRF_Init|
  00180		 |$LN4@VRF_Init|

; 342  :         }   
; 343  :         
; 344  :     }
; 345  : 
; 346  :     rc = (DWORD)pDevice;

  00180	e1a07004	 mov         r7, r4
  00184		 |$cleanUp$45030|

; 347  :     
; 348  : cleanUp:
; 349  :     if (rc == 0) VRF_Deinit((DWORD)pDevice);

  00184	ea000001	 b           |$LN1@VRF_Init|
  00188		 |$LN22@VRF_Init|
  00188	e1a00004	 mov         r0, r4
  0018c	eb000000	 bl          VRF_Deinit
  00190		 |$LN1@VRF_Init|

; 350  :     DEBUGMSG(ZONE_FUNCTION, (L"-VRF_Init(rc = %d)\r\n", rc));
; 351  :     return rc;
; 352  : }

  00190	e1a00007	 mov         r0, r7
  00194	e28dd00c	 add         sp, sp, #0xC
  00198	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0019c	e12fff1e	 bx          lr
  001a0		 |$LN26@VRF_Init|
  001a0		 |$LN27@VRF_Init|
  001a0	00000000	 DCD         |g_VrfbContextList|
  001a4		 |$LN28@VRF_Init|
  001a4	00000000	 DCD         |s_deviceRegParams|
  001a8		 |$LN29@VRF_Init|
  001a8	76726644	 DCD         0x76726644
  001ac		 |$M45933|

			 ENDP  ; |VRF_Init|

	EXPORT	|VRFB_AllocateView|
	IMPORT	|HalContextUpdateDirtyRegister|
	IMPORT	|AllocPhysMem|

  00000			 AREA	 |.pdata|, PDATA
|$T45994| DCD	|$LN49@VRFB_Alloc|
	DCD	0x4000a104
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |VRFB_AllocateView| PROC

; 797  : {

  00000		 |$LN49@VRFB_Alloc|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5ff0	 stmdb       sp!, {r4 - r12, lr}
  0000c	e24dd018	 sub         sp, sp, #0x18
  00010		 |$M45991|
  00010	e1a09003	 mov         r9, r3
  00014	e1b03000	 movs        r3, r0
  00018	e1a08002	 mov         r8, r2
  0001c	e1a07001	 mov         r7, r1

; 798  :     HANDLE     hView = NULL;
; 799  :     Instance_t *pInstance = (Instance_t*)hContext;
; 800  :     Device_t   *pDevice;
; 801  :     DWORD       index;
; 802  :     DWORD       dwImageWidth,
; 803  :                 dwImageHeight;
; 804  :     VOID       *pMem = NULL;
; 805  :     DWORD       dwBufferVirtAddr = 0;

  00020	e3a00000	 mov         r0, #0
  00024	e58d0010	 str         r0, [sp, #0x10]

; 806  : 
; 807  :     DEBUGMSG(ZONE_FUNCTION, (
; 808  :         L"+VRFB_AllocateView(0x%08x, %d, %d, %d, 0x%08x)\r\n", hContext, dwPixelSize, dwWidth, dwHeight, dwBufferPhysAddr
; 809  :         ));
; 810  : 
; 811  :     // Check if we get correct context
; 812  :     if ((pInstance == NULL) || (pInstance->cookie != VRFB_INSTANCE_COOKIE))

  00028	0a000037	 beq         |$LN41@VRFB_Alloc|
  0002c	e5934000	 ldr         r4, [r3]
  00030	e59fe248	 ldr         lr, [pc, #0x248]
  00034	e154000e	 cmp         r4, lr
  00038	1a000033	 bne         |$LN41@VRFB_Alloc|

; 813  :         {
; 814  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_AllocateView: "
; 815  :             L"Incorrect context param\r\n"
; 816  :             ));
; 817  :         goto cleanUp;
; 818  :         }
; 819  : 
; 820  :     //  Get Device
; 821  :     pDevice = pInstance->pDevice;

  0003c	e5933004	 ldr         r3, [r3, #4]

; 822  : 
; 823  :     //  Validate parameters
; 824  :     if( (dwPixelSize != VRFB_PIXELSIZE_1B) && (dwPixelSize != VRFB_PIXELSIZE_2B) && (dwPixelSize != VRFB_PIXELSIZE_4B) )

  00040	e3570000	 cmp         r7, #0
  00044	e58d3014	 str         r3, [sp, #0x14]
  00048	0a000003	 beq         |$LN16@VRFB_Alloc|
  0004c	e3570001	 cmp         r7, #1
  00050	0a000001	 beq         |$LN16@VRFB_Alloc|
  00054	e3570002	 cmp         r7, #2
  00058	1a00002b	 bne         |$LN41@VRFB_Alloc|
  0005c		 |$LN16@VRFB_Alloc|

; 825  :         {
; 826  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_AllocateView: "
; 827  :             L"Invalid pixel size\r\n"
; 828  :             ));
; 829  :         goto cleanUp;
; 830  :         }
; 831  : 
; 832  :     //  Ensure image width and height are multiple of page size
; 833  :     dwImageWidth  = IMAGE_SIZE_ROUNDING(dwWidth, DEFAULT_PAGE_WIDTH);

  0005c	e318000f	 tst         r8, #0xF
  00060	11a03228	 movne       r3, r8, lsr #4
  00064	12833001	 addne       r3, r3, #1
  00068	01a0b008	 moveq       r11, r8
  0006c	11a0b203	 movne       r11, r3, lsl #4

; 834  :     dwImageHeight = IMAGE_SIZE_ROUNDING(dwHeight, DEFAULT_PAGE_HEIGHT);

  00070	e319000f	 tst         r9, #0xF
  00074	11a03229	 movne       r3, r9, lsr #4
  00078	12833001	 addne       r3, r3, #1
  0007c	01a0a009	 moveq       r10, r9
  00080	11a0a203	 movne       r10, r3, lsl #4

; 835  : 
; 836  :     if( (dwImageWidth < VRFB_IMAGE_WIDTH_MIN) || (dwImageWidth > VRFB_IMAGE_WIDTH_MAX) || 
; 837  :         (dwImageHeight < VRFB_IMAGE_HEIGHT_MIN) || (dwImageHeight > VRFB_IMAGE_HEIGHT_MAX) )

  00084	e24b3040	 sub         r3, r11, #0x40
  00088	e3530d1f	 cmp         r3, #0x1F, 26
  0008c	8a00001e	 bhi         |$LN41@VRFB_Alloc|
  00090	e24a3040	 sub         r3, r10, #0x40
  00094	e3530d1f	 cmp         r3, #0x1F, 26
  00098	8a00001b	 bhi         |$LN41@VRFB_Alloc|

; 838  :         {
; 839  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_AllocateView: "
; 840  :             L"Invalid image height or width\r\n"
; 841  :             ));
; 842  :         goto cleanUp;
; 843  :         }
; 844  : 
; 845  : 
; 846  :     //  Check for available context
; 847  :     for( index = 0; index < VRFB_ROTATION_CONTEXTS; index++ )

  0009c	e59f31d8	 ldr         r3, [pc, #0x1D8]
  000a0	e3a05000	 mov         r5, #0
  000a4	e1a02003	 mov         r2, r3
  000a8		 |$LL13@VRFB_Alloc|

; 848  :     {
; 849  :         //  See if slot is open
; 850  :         if( g_VrfbContextList[index].bInUse == FALSE )

  000a8	e5923000	 ldr         r3, [r2]
  000ac	e3530000	 cmp         r3, #0
  000b0	0a000003	 beq         |$LN30@VRFB_Alloc|
  000b4	e2855001	 add         r5, r5, #1
  000b8	e355000c	 cmp         r5, #0xC
  000bc	e2822020	 add         r2, r2, #0x20
  000c0	3afffff8	 bcc         |$LL13@VRFB_Alloc|
  000c4		 |$LN30@VRFB_Alloc|

; 851  :             break;
; 852  :     }
; 853  :     
; 854  :     //  Allocate a context view
; 855  :     if( index < VRFB_ROTATION_CONTEXTS )

  000c4	e355000c	 cmp         r5, #0xC
  000c8	2a00000f	 bcs         |$LN41@VRFB_Alloc|

; 856  :     {
; 857  :         BOOL    bResult;
; 858  : 
; 859  :         //  Check given buffer address; NULL indicates to alloc physical memory
; 860  :         if( dwBufferPhysAddr == 0 )

  000cc	e59d3050	 ldr         r3, [sp, #0x50]
  000d0	e3530000	 cmp         r3, #0
  000d4	1a000011	 bne         |$LN34@VRFB_Alloc|

; 861  :         {
; 862  :             //  Allocate physical memory for view
; 863  :             dwBufferVirtAddr = (DWORD) AllocPhysMem( dwImageWidth*dwImageHeight*PIXEL_SIZE_TO_BYTES(dwPixelSize),
; 864  :                                                      PAGE_READWRITE | PAGE_NOCACHE,
; 865  :                                                      0,
; 866  :                                                      0,
; 867  :                                                      &dwBufferPhysAddr );

  000d8	e3a03001	 mov         r3, #1
  000dc	e1a03713	 mov         r3, r3, lsl r7
  000e0	e28de050	 add         lr, sp, #0x50
  000e4	e0010a93	 mul         r1, r3, r10
  000e8	e3a03000	 mov         r3, #0
  000ec	e0000b91	 mul         r0, r1, r11
  000f0	e3a02000	 mov         r2, #0
  000f4	e3a01f81	 mov         r1, #0x81, 30
  000f8	e58de000	 str         lr, [sp]
  000fc	eb000000	 bl          AllocPhysMem
  00100	e1b04000	 movs        r4, r0
  00104	e58d4010	 str         r4, [sp, #0x10]

; 868  : 
; 869  :             if( dwBufferVirtAddr == 0 )

  00108	1a000005	 bne         |$LN7@VRFB_Alloc|
  0010c		 |$LN41@VRFB_Alloc|

; 957  :         VirtualFree( pMem, 0, MEM_RELEASE );

  0010c	e3a04000	 mov         r4, #0
  00110		 |$LN1@VRFB_Alloc|

; 958  :         
; 959  :     //  Return result
; 960  :     DEBUGMSG(ZONE_FUNCTION, (L"-VRFB_AllocateView(hView = 0x%08X)\r\n", hView));
; 961  :     return hView;
; 962  : }

  00110	e1a00004	 mov         r0, r4
  00114	e28dd018	 add         sp, sp, #0x18
  00118	e89d6ff0	 ldmia       sp, {r4 - r11, sp, lr}
  0011c	e12fff1e	 bx          lr
  00120		 |$LN34@VRFB_Alloc|

; 861  :         {
; 862  :             //  Allocate physical memory for view
; 863  :             dwBufferVirtAddr = (DWORD) AllocPhysMem( dwImageWidth*dwImageHeight*PIXEL_SIZE_TO_BYTES(dwPixelSize),
; 864  :                                                      PAGE_READWRITE | PAGE_NOCACHE,
; 865  :                                                      0,
; 866  :                                                      0,
; 867  :                                                      &dwBufferPhysAddr );

  00120	e3a04000	 mov         r4, #0
  00124		 |$LN7@VRFB_Alloc|

; 870  :             {
; 871  :                 DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_AllocateView: "
; 872  :                      L"Failed to allocate physical memory for view buffer\n"
; 873  :                     ));
; 874  :                 goto cleanUp;
; 875  :             }
; 876  :         } 
; 877  : 
; 878  :         //  Reserve virtual memory for the VRFB view
; 879  :         pMem = VirtualAlloc( NULL, 
; 880  :                              VRFB_VIEW_SIZE, 
; 881  :                              MEM_RESERVE, 
; 882  :                              PAGE_NOACCESS );

  00124	e3a03001	 mov         r3, #1
  00128	e3a02a02	 mov         r2, #2, 20
  0012c	e3a01401	 mov         r1, #1, 8
  00130	e3a00000	 mov         r0, #0
  00134	eb000000	 bl          VirtualAlloc
  00138	e1b06000	 movs        r6, r0

; 883  :                                                     
; 884  :         if( pMem == NULL )

  0013c	0a000043	 beq         |$LN44@VRFB_Alloc|
  00140	e59f3134	 ldr         r3, [pc, #0x134]

; 885  :         {
; 886  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_AllocateView: "
; 887  :                  L"Failed reserve view memory\r\n"
; 888  :                 ));
; 889  :             goto cleanUp;
; 890  :         }
; 891  : 
; 892  :         //  Associate to the rotation angle 0 context by default
; 893  :         bResult = VirtualCopy( pMem, 
; 894  :                                (VOID*)(g_VrfbContextList[index].dwPhysicalAddr/256), 
; 895  :                                VRFB_VIEW_SIZE, 
; 896  :                                PAGE_READWRITE | PAGE_PHYSICAL | PAGE_NOCACHE );

  00144	e1a00006	 mov         r0, r6
  00148	e0833285	 add         r3, r3, r5, lsl #5
  0014c	e5932010	 ldr         r2, [r3, #0x10]
  00150	e58d300c	 str         r3, [sp, #0xC]
  00154	e3a03c06	 mov         r3, #6, 24
  00158	e1a01422	 mov         r1, r2, lsr #8
  0015c	e3a02401	 mov         r2, #1, 8
  00160	e3833004	 orr         r3, r3, #4
  00164	eb000000	 bl          VirtualCopy
  00168	e3500000	 cmp         r0, #0

; 897  : 
; 898  :         if( bResult == FALSE )

  0016c	0a000037	 beq         |$LN44@VRFB_Alloc|

; 899  :         {
; 900  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_AllocateView: "
; 901  :                  L"Failed map context memory\r\n"
; 902  :                 ));
; 903  :             goto cleanUp;
; 904  :         }
; 905  : 
; 906  :         //  Change the attributes of the buffer for cache write thru
; 907  :         bResult = CeSetMemoryAttributes( pMem, (VOID*)(g_VrfbContextList[index].dwPhysicalAddr/256), VRFB_VIEW_SIZE, PAGE_WRITECOMBINE );

  00170	e59d300c	 ldr         r3, [sp, #0xC]
  00174	e3a0e000	 mov         lr, #0
  00178	e58de008	 str         lr, [sp, #8]
  0017c	e5933010	 ldr         r3, [r3, #0x10]
  00180	e3a0eb01	 mov         lr, #1, 22
  00184	e1a02006	 mov         r2, r6
  00188	e1a03423	 mov         r3, r3, lsr #8
  0018c	e58d3000	 str         r3, [sp]
  00190	e3a03401	 mov         r3, #1, 8
  00194	e3a0100c	 mov         r1, #0xC
  00198	e3a00001	 mov         r0, #1
  0019c	e58de004	 str         lr, [sp, #4]
  001a0	eb000000	 bl          KernelLibIoControl
  001a4	e3500000	 cmp         r0, #0

; 908  :         if( bResult == FALSE )

  001a8	0a000028	 beq         |$LN44@VRFB_Alloc|

; 909  :         {
; 910  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_AllocateView: "
; 911  :                  L"Failed CeSetMemoryAttributes for context # %d\r\n", index
; 912  :                 ));
; 913  :             goto cleanUp;
; 914  :         }
; 915  : 
; 916  :         DEBUGMSG(ZONE_INFO, (L"INFO: VRFB_AllocateView: "
; 917  :              L"Context # %d: va = 0x%08X, pa = 0x%08X, buffer va = 0x%08X, buffer pa = 0x%08X", 
; 918  :              index, pMem, g_VrfbContextList[index].dwPhysicalAddr, dwBufferVirtAddr, dwBufferPhysAddr
; 919  :             ));
; 920  :         
; 921  :         //  Update the context table
; 922  :         g_VrfbContextList[index].bInUse = TRUE;                                               
; 923  :         g_VrfbContextList[index].dwWidth = dwWidth;                                               
; 924  :         g_VrfbContextList[index].dwHeight = dwHeight;                                               
; 925  :         g_VrfbContextList[index].dwRotationAngle = VRFB_ROTATE_ANGLE_0;                                               
; 926  :         g_VrfbContextList[index].dwVirtualAddr = (DWORD) pMem;
; 927  :         g_VrfbContextList[index].dwBufferPhysAddr = (DWORD) dwBufferPhysAddr;

  001ac	e59f20c8	 ldr         r2, [pc, #0xC8]
  001b0	e3a01001	 mov         r1, #1
  001b4	e59d3050	 ldr         r3, [sp, #0x50]
  001b8	e7821285	 str         r1, [r2, +r5, lsl #5]
  001bc	e59d200c	 ldr         r2, [sp, #0xC]

; 928  :         g_VrfbContextList[index].dwBufferVirtAddr = (DWORD) dwBufferVirtAddr;
; 929  :         
; 930  :         //  Program the VRFB registers
; 931  :         OUTREG32(&pDevice->pVRFBRegs->aVRFB_SMS_ROT_CTRL[index].VRFB_SMS_ROT_CONTROL, dwPixelSize|SMS_ROT_CONTROL_PAGEWIDTH(DEFAULT_PAGE_WIDTH)|SMS_ROT_CONTROL_PAGEHEIGHT(DEFAULT_PAGE_HEIGHT));

  001c0	e59de014	 ldr         lr, [sp, #0x14]

; 932  :         OUTREG32(&pDevice->pVRFBRegs->aVRFB_SMS_ROT_CTRL[index].VRFB_SMS_ROT_SIZE, SMS_ROT_SIZE_WIDTH(dwImageWidth)|SMS_ROT_SIZE_HEIGHT(dwImageHeight));

  001c4	e3a01c07	 mov         r1, #7, 24
  001c8	e5823018	 str         r3, [r2, #0x18]
  001cc	e3a03000	 mov         r3, #0
  001d0	e582300c	 str         r3, [r2, #0xC]
  001d4	e5828004	 str         r8, [r2, #4]
  001d8	e5829008	 str         r9, [r2, #8]
  001dc	e5826014	 str         r6, [r2, #0x14]
  001e0	e582401c	 str         r4, [r2, #0x1C]
  001e4	e59e3024	 ldr         r3, [lr, #0x24]
  001e8	e3872d11	 orr         r2, r7, #0x11, 26
  001ec	e38100ff	 orr         r0, r1, #0xFF
  001f0	e0833205	 add         r3, r3, r5, lsl #4
  001f4	e583201c	 str         r2, [r3, #0x1C]
  001f8	e59e2024	 ldr         r2, [lr, #0x24]
  001fc	e2854002	 add         r4, r5, #2
  00200	e00a1000	 and         r1, r10, r0
  00204	e00b3000	 and         r3, r11, r0
  00208	e0822204	 add         r2, r2, r4, lsl #4
  0020c	e1833801	 orr         r3, r3, r1, lsl #16
  00210	e5823000	 str         r3, [r2]

; 933  :         OUTREG32(&pDevice->pVRFBRegs->aVRFB_SMS_ROT_CTRL[index].VRFB_SMS_ROT_PHYSICAL_BA, dwBufferPhysAddr);

  00214	e59e3024	 ldr         r3, [lr, #0x24]
  00218	e59d2050	 ldr         r2, [sp, #0x50]

; 934  :         
; 935  :         DebugPrintRegs(pDevice->pVRFBRegs, index);
; 936  : 
; 937  :         // mark VRFB registers dirty, to update backup copy in OAL
; 938  :         HalContextUpdateDirtyRegister(HAL_CONTEXTSAVE_VRFB);

  0021c	e3a00080	 mov         r0, #0x80
  00220	e0833205	 add         r3, r3, r5, lsl #4
  00224	e5832024	 str         r2, [r3, #0x24]
  00228	e59e3024	 ldr         r3, [lr, #0x24]
  0022c	e083e205	 add         lr, r3, r5, lsl #4
  00230	e59e101c	 ldr         r1, [lr, #0x1C]
  00234	e0833204	 add         r3, r3, r4, lsl #4
  00238	e5932000	 ldr         r2, [r3]
  0023c	e59e3024	 ldr         r3, [lr, #0x24]
  00240	eb000000	 bl          HalContextUpdateDirtyRegister

; 939  : 
; 940  :         //  A view handle is just the index of the VRFB context
; 941  :         hView = (HANDLE)(VRFB_VIEW_HANDLE_BASE + index);  

  00244	e2954206	 adds        r4, r5, #6, 4
  00248		 |$cleanUp$45318|

; 942  :     }
; 943  :     else
; 944  :     {
; 945  :         DEBUGMSG(ZONE_WARNING, (L"ERROR: VRFB_AllocateView: "
; 946  :             L"No available views\r\n"
; 947  :             ));
; 948  :         goto cleanUp;
; 949  :     }
; 950  :     
; 951  : cleanUp:    
; 952  :     //  Clean up failure conditions
; 953  :     if( hView == NULL && dwBufferVirtAddr != 0 )

  00248	1affffb0	 bne         |$LN1@VRFB_Alloc|

; 957  :         VirtualFree( pMem, 0, MEM_RELEASE );

  0024c	ea000000	 b           |$LN32@VRFB_Alloc|
  00250		 |$LN44@VRFB_Alloc|

; 942  :     }
; 943  :     else
; 944  :     {
; 945  :         DEBUGMSG(ZONE_WARNING, (L"ERROR: VRFB_AllocateView: "
; 946  :             L"No available views\r\n"
; 947  :             ));
; 948  :         goto cleanUp;
; 949  :     }
; 950  :     
; 951  : cleanUp:    
; 952  :     //  Clean up failure conditions
; 953  :     if( hView == NULL && dwBufferVirtAddr != 0 )

  00250	e3a04000	 mov         r4, #0
  00254		 |$LN32@VRFB_Alloc|
  00254	e59d0010	 ldr         r0, [sp, #0x10]
  00258	e3500000	 cmp         r0, #0

; 954  :         FreePhysMem( (VOID*)dwBufferVirtAddr );

  0025c	1b000000	 blne        FreePhysMem

; 955  : 
; 956  :     if( hView == NULL && pMem != NULL )

  00260	e3560000	 cmp         r6, #0
  00264	0affffa9	 beq         |$LN1@VRFB_Alloc|

; 957  :         VirtualFree( pMem, 0, MEM_RELEASE );

  00268	e3a02902	 mov         r2, #2, 18
  0026c	e3a01000	 mov         r1, #0
  00270	e1a00006	 mov         r0, r6
  00274	eb000000	 bl          VirtualFree
  00278	eaffffa4	 b           |$LN1@VRFB_Alloc|
  0027c		 |$LN50@VRFB_Alloc|
  0027c		 |$LN51@VRFB_Alloc|
  0027c	00000000	 DCD         |g_VrfbContextList|
  00280		 |$LN52@VRFB_Alloc|
  00280	76726649	 DCD         0x76726649
  00284		 |$M45992|

			 ENDP  ; |VRFB_AllocateView|

	EXPORT	|VRFB_UpdateView|

  00000			 AREA	 |.pdata|, PDATA
|$T46029| DCD	|$LN19@VRFB_Updat|
	DCD	0x40004b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |VRFB_UpdateView| PROC

; 1246 : {

  00000		 |$LN19@VRFB_Updat|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M46026|
  00004	e1a05003	 mov         r5, r3
  00008	e1a06001	 mov         r6, r1
  0000c	e3500000	 cmp         r0, #0

; 1247 :     BOOL        bResult = FALSE;

  00010	e3a08000	 mov         r8, #0

; 1248 :     Instance_t *pInstance = (Instance_t*)hContext;
; 1249 :     Device_t   *pDevice;
; 1250 :     DWORD       index;
; 1251 :     DWORD       dwImageWidth;
; 1252 :     DWORD       dwImageHeight;
; 1253 : 
; 1254 :  
; 1255 :     DEBUGMSG(ZONE_FUNCTION, (
; 1256 :         L"+VRFB_UpdateView(0x%08x, 0x%08x, %d, %d, %d, 0x%08x )\r\n", hContext, hView, dwPixelSize, dwWidth, dwHeight, dwBufferPhysAddr
; 1257 :         ));
; 1258 : 
; 1259 :     // Check if we get correct context
; 1260 :     if ((pInstance == NULL) || (pInstance->cookie != VRFB_INSTANCE_COOKIE))

  00014	0a00003f	 beq         |$cleanUp$45505|
  00018	e5904000	 ldr         r4, [r0]
  0001c	e59fe104	 ldr         lr, [pc, #0x104]
  00020	e154000e	 cmp         r4, lr
  00024	1a00003b	 bne         |$cleanUp$45505|

; 1261 :         {
; 1262 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_UpdateView: "
; 1263 :             L"Incorrect context param\r\n"
; 1264 :             ));
; 1265 :         goto cleanUp;
; 1266 :         }
; 1267 : 
; 1268 :     //  Get Device
; 1269 :     pDevice = pInstance->pDevice;

  00028	e590a004	 ldr         r10, [r0, #4]

; 1270 : 
; 1271 :     //  Validate parameters
; 1272 :     if( (dwPixelSize != VRFB_PIXELSIZE_1B) && (dwPixelSize != VRFB_PIXELSIZE_2B) && (dwPixelSize != VRFB_PIXELSIZE_4B) )

  0002c	e3520000	 cmp         r2, #0
  00030	0a000003	 beq         |$LN6@VRFB_Updat|
  00034	e3520001	 cmp         r2, #1
  00038	0a000001	 beq         |$LN6@VRFB_Updat|
  0003c	e3520002	 cmp         r2, #2
  00040	1a000034	 bne         |$cleanUp$45505|
  00044		 |$LN6@VRFB_Updat|

; 1273 :         {
; 1274 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_UpdateView: "
; 1275 :             L"Invalid pixel size\r\n"
; 1276 :             ));
; 1277 :         goto cleanUp;
; 1278 :         }
; 1279 : 
; 1280 :     //  Ensure image width and height are multiple of page size
; 1281 :     dwImageWidth  = IMAGE_SIZE_ROUNDING(dwWidth, DEFAULT_PAGE_WIDTH);

  00044	e315000f	 tst         r5, #0xF

; 1282 :     dwImageHeight = IMAGE_SIZE_ROUNDING(dwHeight, DEFAULT_PAGE_HEIGHT);

  00048	e59d1020	 ldr         r1, [sp, #0x20]
  0004c	11a03225	 movne       r3, r5, lsr #4
  00050	12833001	 addne       r3, r3, #1
  00054	01a07005	 moveq       r7, r5
  00058	11a07203	 movne       r7, r3, lsl #4
  0005c	e311000f	 tst         r1, #0xF
  00060	11a03221	 movne       r3, r1, lsr #4
  00064	12833001	 addne       r3, r3, #1
  00068	01a09001	 moveq       r9, r1

; 1283 : 
; 1284 : 
; 1285 :     //  Validate view handle
; 1286 :     index = (DWORD)hView - VRFB_VIEW_HANDLE_BASE;

  0006c	e2466206	 sub         r6, r6, #6, 4
  00070	11a09203	 movne       r9, r3, lsl #4

; 1287 :     
; 1288 :     if( index < VRFB_ROTATION_CONTEXTS && g_VrfbContextList[index].bInUse )

  00074	e356000c	 cmp         r6, #0xC
  00078	2a000026	 bcs         |$cleanUp$45505|
  0007c	e59f00a0	 ldr         r0, [pc, #0xA0]
  00080	e7903286	 ldr         r3, [r0, +r6, lsl #5]
  00084	e3530000	 cmp         r3, #0
  00088	0a000022	 beq         |$cleanUp$45505|

; 1289 :     {
; 1290 :         //  Can't update parameters for views with internally allocated buffer memory
; 1291 :         if( g_VrfbContextList[index].dwBufferVirtAddr != 0 )

  0008c	e0800286	 add         r0, r0, r6, lsl #5
  00090	e590301c	 ldr         r3, [r0, #0x1C]
  00094	e3530000	 cmp         r3, #0
  00098	1a00001e	 bne         |$cleanUp$45505|

; 1292 :         {
; 1293 :             DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_UpdateView: "
; 1294 :                  L"Can't update view\r\n"
; 1295 :                 ));
; 1296 :             goto cleanUp;
; 1297 :         }
; 1298 :         
; 1299 :         //  Re-use existing buffer address if given one is 0, otherwise cache the value
; 1300 :         if( dwBufferPhysAddr == 0 )

  0009c	e59de024	 ldr         lr, [sp, #0x24]

; 1301 :         {
; 1302 :             dwBufferPhysAddr = g_VrfbContextList[index].dwBufferPhysAddr;
; 1303 :         }
; 1304 :         else
; 1305 :         {
; 1306 :             g_VrfbContextList[index].dwBufferPhysAddr = dwBufferPhysAddr;
; 1307 :         }
; 1308 : 
; 1309 :         //  Update real width and heigth
; 1310 :         g_VrfbContextList[index].dwWidth = dwWidth;

  000a0	e5805004	 str         r5, [r0, #4]

; 1311 :         g_VrfbContextList[index].dwHeight = dwHeight;

  000a4	e5801008	 str         r1, [r0, #8]
  000a8	e35e0000	 cmp         lr, #0
  000ac	0590e018	 ldreq       lr, [r0, #0x18]

; 1312 : 
; 1313 : 
; 1314 :         //  Program the VRFB registers
; 1315 :         OUTREG32(&pDevice->pVRFBRegs->aVRFB_SMS_ROT_CTRL[index].VRFB_SMS_ROT_CONTROL, dwPixelSize|SMS_ROT_CONTROL_PAGEWIDTH(DEFAULT_PAGE_WIDTH)|SMS_ROT_CONTROL_PAGEHEIGHT(DEFAULT_PAGE_HEIGHT));

  000b0	e3822d11	 orr         r2, r2, #0x11, 26

; 1316 :         OUTREG32(&pDevice->pVRFBRegs->aVRFB_SMS_ROT_CTRL[index].VRFB_SMS_ROT_SIZE, SMS_ROT_SIZE_WIDTH(dwImageWidth)|SMS_ROT_SIZE_HEIGHT(dwImageHeight));

  000b4	e3a01c07	 mov         r1, #7, 24
  000b8	1580e018	 strne       lr, [r0, #0x18]
  000bc	e59a3024	 ldr         r3, [r10, #0x24]
  000c0	e38100ff	 orr         r0, r1, #0xFF
  000c4	e2864002	 add         r4, r6, #2
  000c8	e0833206	 add         r3, r3, r6, lsl #4
  000cc	e583201c	 str         r2, [r3, #0x1C]
  000d0	e59a2024	 ldr         r2, [r10, #0x24]
  000d4	e0091000	 and         r1, r9, r0
  000d8	e0073000	 and         r3, r7, r0
  000dc	e0822204	 add         r2, r2, r4, lsl #4
  000e0	e1833801	 orr         r3, r3, r1, lsl #16
  000e4	e5823000	 str         r3, [r2]

; 1317 :         OUTREG32(&pDevice->pVRFBRegs->aVRFB_SMS_ROT_CTRL[index].VRFB_SMS_ROT_PHYSICAL_BA, dwBufferPhysAddr);

  000e8	e59a3024	 ldr         r3, [r10, #0x24]

; 1318 :         
; 1319 :         DebugPrintRegs(pDevice->pVRFBRegs, index);
; 1320 : 
; 1321 :         // mark VRFB registers dirty, to update backup copy in OAL
; 1322 :         HalContextUpdateDirtyRegister(HAL_CONTEXTSAVE_VRFB);

  000ec	e3a00080	 mov         r0, #0x80
  000f0	e0833206	 add         r3, r3, r6, lsl #4
  000f4	e583e024	 str         lr, [r3, #0x24]
  000f8	e59a3024	 ldr         r3, [r10, #0x24]
  000fc	e083e206	 add         lr, r3, r6, lsl #4
  00100	e59e101c	 ldr         r1, [lr, #0x1C]
  00104	e0833204	 add         r3, r3, r4, lsl #4
  00108	e5932000	 ldr         r2, [r3]
  0010c	e59e3024	 ldr         r3, [lr, #0x24]
  00110	eb000000	 bl          HalContextUpdateDirtyRegister

; 1323 :         
; 1324 :         bResult = TRUE;

  00114	e3a08001	 mov         r8, #1
  00118		 |$cleanUp$45505|

; 1325 :     }
; 1326 :     else
; 1327 :     {
; 1328 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRFB_UpdateView: "
; 1329 :             L"Invalid view handle 0x%08X\r\n", hView
; 1330 :             ));
; 1331 :         goto cleanUp;
; 1332 :     }
; 1333 :     
; 1334 : cleanUp:    
; 1335 :     //  Return result
; 1336 :     DEBUGMSG(ZONE_FUNCTION, (L"-VRFB_UpdateView(bResult = %d)\r\n", bResult));
; 1337 :     return bResult;
; 1338 : }

  00118	e1a00008	 mov         r0, r8
  0011c	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00120	e12fff1e	 bx          lr
  00124		 |$LN20@VRFB_Updat|
  00124		 |$LN21@VRFB_Updat|
  00124	00000000	 DCD         |g_VrfbContextList|
  00128		 |$LN22@VRFB_Updat|
  00128	76726649	 DCD         0x76726649
  0012c		 |$M46027|

			 ENDP  ; |VRFB_UpdateView|

	EXPORT	|VRF_IOControl|
	IMPORT	|SetLastError|
	IMPORT	|CeSafeCopyMemory|
	IMPORT	|GetCallerProcess|
	IMPORT	|memcmp|

  00000			 AREA	 |.pdata|, PDATA
|$T46075| DCD	|$LN63@VRF_IOCont|
	DCD	0x4000e102
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |VRF_IOControl| PROC

; 547  : {

  00000		 |$LN63@VRF_IOCont|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd02c	 sub         sp, sp, #0x2C
  00008		 |$M46072|
  00008	e1a06003	 mov         r6, r3
  0000c	e1a05002	 mov         r5, r2
  00010	e1b09000	 movs        r9, r0

; 548  :     BOOL rc = FALSE;

  00014	e3a08000	 mov         r8, #0

; 549  :     Instance_t *pInstance = (Instance_t*)context;
; 550  :     Device_t *pDevice;
; 551  :     DEVICE_IFC_VRFB ifc;
; 552  : 
; 553  :     DEBUGMSG(ZONE_FUNCTION, (
; 554  :         L"+VRF_IOControl(0x%08x, 0x%08x, 0x%08x, %d, 0x%08x, %d, 0x%08x)\r\n",
; 555  :         context, code, pInBuffer, inSize, pOutBuffer, outSize, pOutSize
; 556  :         ));
; 557  : 
; 558  :     // Check if we get correct context
; 559  :     if ((pInstance == NULL) || (pInstance->cookie != VRFB_INSTANCE_COOKIE))

  00018	0a000074	 beq         |$cleanUp$45166|
  0001c	e5994000	 ldr         r4, [r9]
  00020	e59fe358	 ldr         lr, [pc, #0x358]
  00024	e154000e	 cmp         r4, lr
  00028	1a000070	 bne         |$cleanUp$45166|

; 560  :         {
; 561  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRF_IOControl: "
; 562  :             L"Incorrect context param\r\n"
; 563  :             ));
; 564  :         goto cleanUp;
; 565  :         }
; 566  : 
; 567  :     //  Get Device
; 568  :     pDevice = pInstance->pDevice;
; 569  : 
; 570  : 
; 571  :     switch (code)

  0002c	e59f3348	 ldr         r3, [pc, #0x348]
  00030	e1510003	 cmp         r1, r3
  00034	8a00007b	 bhi         |$LN49@VRF_IOCont|
  00038	0a000070	 beq         |$LN21@VRF_IOCont|
  0003c	e3a03822	 mov         r3, #0x22, 16
  00040	e383eb01	 orr         lr, r3, #1, 22
  00044	e151000e	 cmp         r1, lr
  00048	0a000035	 beq         |$LN42@VRF_IOCont|
  0004c	e3a03822	 mov         r3, #0x22, 16
  00050	e3833b07	 orr         r3, r3, #7, 22
  00054	e1510003	 cmp         r1, r3
  00058	0a00001d	 beq         |$LN33@VRF_IOCont|
  0005c	e59f3314	 ldr         r3, [pc, #0x314]
  00060	e1510003	 cmp         r1, r3
  00064	0a000011	 beq         |$LN29@VRF_IOCont|
  00068	e59f3304	 ldr         r3, [pc, #0x304]
  0006c	e1510003	 cmp         r1, r3
  00070	1a00005e	 bne         |$cleanUp$45166|

; 652  :                     }
; 653  :             }
; 654  :             break;
; 655  :  
; 656  :         case IOCTL_VRFB_GETVIEWINFO:
; 657  :             {
; 658  :                 if ((pInBuffer == NULL) || (pOutBuffer == NULL) ||
; 659  :                     (inSize < sizeof(HANDLE*)) ||
; 660  :                     (outSize < sizeof(VRFB_VIEW_INFO)))

  00074	e3550000	 cmp         r5, #0
  00078	0a00005a	 beq         |$LN15@VRF_IOCont|
  0007c	e59d2048	 ldr         r2, [sp, #0x48]
  00080	e3520000	 cmp         r2, #0
  00084	0a000057	 beq         |$LN15@VRF_IOCont|
  00088	e3560004	 cmp         r6, #4
  0008c	3a000055	 bcc         |$LN15@VRF_IOCont|
  00090	e59d304c	 ldr         r3, [sp, #0x4C]
  00094	e3530040	 cmp         r3, #0x40
  00098	3a000052	 bcc         |$LN15@VRF_IOCont|

; 661  :                     {
; 662  :                     SetLastError(ERROR_INVALID_PARAMETER);
; 663  :                     }
; 664  :                 else
; 665  :                     {
; 666  :                     HANDLE  hContext = (HANDLE) context;
; 667  :                     HANDLE  hView = *(HANDLE*)pInBuffer;

  0009c	e5951000	 ldr         r1, [r5]

; 668  :                     VRFB_VIEW_INFO *pViewInfo = (VRFB_VIEW_INFO*)pOutBuffer;
; 669  :                     
; 670  :                     rc = VRFB_GetViewInfo( hContext, hView, pViewInfo ); 

  000a0	e1a00009	 mov         r0, r9
  000a4	eb000000	 bl          VRFB_GetViewInfo

; 698  :                     }
; 699  :                 else
; 700  :                     {
; 701  :                     HANDLE          hContext = (HANDLE) context;
; 702  :                     VRFB_VIEW_INFO *pViewInfo = (VRFB_VIEW_INFO*)pInBuffer;
; 703  :                     
; 704  :                     rc = VRFB_UpdateView( hContext,
; 705  :                                           pViewInfo->hView,
; 706  :                                           pViewInfo->dwPixelSize, 
; 707  :                                           pViewInfo->dwWidth,
; 708  :                                           pViewInfo->dwHeight, 
; 709  :                                           pViewInfo->dwPhysicalBufferAddr );

  000a8	e1a08000	 mov         r8, r0
  000ac	ea00004f	 b           |$cleanUp$45166|
  000b0		 |$LN29@VRF_IOCont|

; 638  :  
; 639  :         case IOCTL_VRFB_RELEASEVIEW:
; 640  :             {
; 641  :                 if ((pInBuffer == NULL) ||
; 642  :                     (inSize < sizeof(HANDLE*)))

  000b0	e3550000	 cmp         r5, #0
  000b4	0a00004b	 beq         |$LN15@VRF_IOCont|
  000b8	e3560004	 cmp         r6, #4
  000bc	3a000049	 bcc         |$LN15@VRF_IOCont|

; 643  :                     {
; 644  :                     SetLastError(ERROR_INVALID_PARAMETER);
; 645  :                     }
; 646  :                 else
; 647  :                     {
; 648  :                     HANDLE  hContext = (HANDLE) context;
; 649  :                     HANDLE  hView = *(HANDLE*)pInBuffer;

  000c0	e5951000	 ldr         r1, [r5]

; 650  :                     
; 651  :                     rc = VRFB_ReleaseView( hContext, hView );

  000c4	e1a00009	 mov         r0, r9
  000c8	eb000000	 bl          VRFB_ReleaseView

; 698  :                     }
; 699  :                 else
; 700  :                     {
; 701  :                     HANDLE          hContext = (HANDLE) context;
; 702  :                     VRFB_VIEW_INFO *pViewInfo = (VRFB_VIEW_INFO*)pInBuffer;
; 703  :                     
; 704  :                     rc = VRFB_UpdateView( hContext,
; 705  :                                           pViewInfo->hView,
; 706  :                                           pViewInfo->dwPixelSize, 
; 707  :                                           pViewInfo->dwWidth,
; 708  :                                           pViewInfo->dwHeight, 
; 709  :                                           pViewInfo->dwPhysicalBufferAddr );

  000cc	e1a08000	 mov         r8, r0
  000d0	ea000046	 b           |$cleanUp$45166|
  000d4		 |$LN33@VRF_IOCont|

; 607  :                 }
; 608  :                 rc = TRUE;
; 609  :                 break;
; 610  :             }
; 611  :             SetLastError(ERROR_INVALID_PARAMETER);
; 612  :             break;
; 613  : 
; 614  :         case IOCTL_VRFB_ALLOCATEVIEW:
; 615  :             {
; 616  :                 if ((pInBuffer == NULL) || (pOutBuffer == NULL) ||
; 617  :                     (inSize < sizeof(VRFB_VIEW_INFO)) ||
; 618  :                     (outSize < sizeof(HANDLE)))

  000d4	e3550000	 cmp         r5, #0
  000d8	0a000042	 beq         |$LN15@VRF_IOCont|
  000dc	e59d4048	 ldr         r4, [sp, #0x48]
  000e0	e3540000	 cmp         r4, #0
  000e4	0a00003f	 beq         |$LN15@VRF_IOCont|
  000e8	e3560040	 cmp         r6, #0x40
  000ec	3a00003d	 bcc         |$LN15@VRF_IOCont|
  000f0	e59d304c	 ldr         r3, [sp, #0x4C]
  000f4	e3530004	 cmp         r3, #4
  000f8	3a00003a	 bcc         |$LN15@VRF_IOCont|

; 619  :                     {
; 620  :                     SetLastError(ERROR_INVALID_PARAMETER);
; 621  :                     }
; 622  :                 else
; 623  :                     {
; 624  :                     HANDLE          hContext = (HANDLE) context;
; 625  :                     VRFB_VIEW_INFO *pViewInfo = (VRFB_VIEW_INFO*)pInBuffer;
; 626  :                     HANDLE         *hView = (HANDLE*)pOutBuffer;
; 627  :                     
; 628  :                     *hView = VRFB_AllocateView( hContext, 
; 629  :                                                pViewInfo->dwPixelSize, 
; 630  :                                                pViewInfo->dwWidth,
; 631  :                                                pViewInfo->dwHeight, 
; 632  :                                                pViewInfo->dwPhysicalBufferAddr );

  000fc	e595003c	 ldr         r0, [r5, #0x3C]
  00100	e5953010	 ldr         r3, [r5, #0x10]
  00104	e595200c	 ldr         r2, [r5, #0xC]
  00108	e5951004	 ldr         r1, [r5, #4]
  0010c	e58d0000	 str         r0, [sp]
  00110	e1a00009	 mov         r0, r9
  00114	eb000000	 bl          VRFB_AllocateView
  00118		 |$LN60@VRF_IOCont|
  00118	e5840000	 str         r0, [r4]
  0011c		 |$LN59@VRF_IOCont|

; 633  : 
; 634  :                     rc = TRUE;

  0011c	e3a08001	 mov         r8, #1

; 635  :                     }
; 636  :             }
; 637  :             break;

  00120	ea000032	 b           |$cleanUp$45166|
  00124		 |$LN42@VRF_IOCont|

; 572  :         { 
; 573  :         case IOCTL_DDK_GET_DRIVER_IFC:
; 574  :             // We can give interface only to our peer in device process
; 575  :             if (GetCurrentProcessId() != (DWORD)GetCallerProcess()) {

  00124	e3a0000c	 mov         r0, #0xC
  00128	eb000000	 bl          __GetUserKData
  0012c	e1a04000	 mov         r4, r0
  00130	eb000000	 bl          GetCallerProcess
  00134	e1540000	 cmp         r4, r0

; 576  :                 DEBUGMSG(ZONE_ERROR, (L"ERROR: VRF_IOControl: "
; 577  :                     L"IOCTL_DDK_GET_DRIVER_IFC can be called only from "
; 578  :                     L"device process (caller process id 0x%08x)\r\n",
; 579  :                     GetCallerProcess()
; 580  :                 ));
; 581  :                 SetLastError(ERROR_ACCESS_DENIED);

  00138	13a00005	 movne       r0, #5
  0013c	1a00002a	 bne         |$LN58@VRF_IOCont|

; 582  :                 goto cleanUp;
; 583  :             }
; 584  :             // Check input parameters
; 585  :             if (pInBuffer == NULL || inSize < sizeof(GUID)) {

  00140	e3550000	 cmp         r5, #0
  00144	0a000027	 beq         |$LN15@VRF_IOCont|
  00148	e3560010	 cmp         r6, #0x10
  0014c	3a000025	 bcc         |$LN15@VRF_IOCont|

; 586  :                 SetLastError(ERROR_INVALID_PARAMETER);
; 587  :                 break;
; 588  :             }
; 589  :             if (IsEqualGUID((GUID*)pInBuffer, &DEVICE_IFC_VRFB_GUID)) {

  00150	e59f1218	 ldr         r1, [pc, #0x218]
  00154	e3a02010	 mov         r2, #0x10
  00158	e1a00005	 mov         r0, r5
  0015c	eb000000	 bl          memcmp
  00160	e3500000	 cmp         r0, #0
  00164	1a00001f	 bne         |$LN15@VRF_IOCont|

; 590  :                 if (pOutSize != NULL) *pOutSize = sizeof(DEVICE_IFC_VRFB);

  00168	e59d3050	 ldr         r3, [sp, #0x50]

; 591  :                 if (pOutBuffer == NULL || outSize < sizeof(DEVICE_IFC_VRFB)) {

  0016c	e59d0048	 ldr         r0, [sp, #0x48]
  00170	e3530000	 cmp         r3, #0
  00174	13a02024	 movne       r2, #0x24
  00178	15832000	 strne       r2, [r3]
  0017c	e3500000	 cmp         r0, #0
  00180	0a000018	 beq         |$LN15@VRF_IOCont|
  00184	e59d304c	 ldr         r3, [sp, #0x4C]
  00188	e3530024	 cmp         r3, #0x24
  0018c	3a000015	 bcc         |$LN15@VRF_IOCont|

; 592  :                     SetLastError(ERROR_INVALID_PARAMETER);
; 593  :                     break;
; 594  :                 }
; 595  :                 ifc.context = (HANDLE) context;
; 596  :                 ifc.pfnAllocateView = VRFB_AllocateView;
; 597  :                 ifc.pfnReleaseView = VRFB_ReleaseView;

  00190	e59f21d4	 ldr         r2, [pc, #0x1D4]

; 598  :                 ifc.pfnGetViewInfo = VRFB_GetViewInfo;

  00194	e59f11cc	 ldr         r1, [pc, #0x1CC]
  00198	e59f31c4	 ldr         r3, [pc, #0x1C4]

; 599  :                 ifc.pfnRotateView = VRFB_RotateView;

  0019c	e59fe1bc	 ldr         lr, [pc, #0x1BC]

; 600  :                 ifc.pfnUpdateView = VRFB_UpdateView;

  001a0	e59f41b4	 ldr         r4, [pc, #0x1B4]

; 601  :                 ifc.pfnNumDisplayViews = VRFB_NumDisplayViews;

  001a4	e59f51ac	 ldr         r5, [pc, #0x1AC]

; 602  :                 ifc.pfnGetDisplayView = VRFB_GetDisplayView;

  001a8	e59f61a4	 ldr         r6, [pc, #0x1A4]

; 603  :                 ifc.pfnGetDisplayViewInfo = VRFB_GetDisplayViewInfo;

  001ac	e59f719c	 ldr         r7, [pc, #0x19C]
  001b0	e58d2010	 str         r2, [sp, #0x10]
  001b4	e58d1014	 str         r1, [sp, #0x14]

; 604  :                 if (!CeSafeCopyMemory(pOutBuffer, &ifc, sizeof(DEVICE_IFC_VRFB))) {

  001b8	e3a02024	 mov         r2, #0x24
  001bc	e28d1008	 add         r1, sp, #8
  001c0	e58d300c	 str         r3, [sp, #0xC]
  001c4	e58de018	 str         lr, [sp, #0x18]
  001c8	e58d401c	 str         r4, [sp, #0x1C]
  001cc	e58d5020	 str         r5, [sp, #0x20]
  001d0	e58d6024	 str         r6, [sp, #0x24]
  001d4	e58d7028	 str         r7, [sp, #0x28]
  001d8	e58d9008	 str         r9, [sp, #8]
  001dc	eb000000	 bl          CeSafeCopyMemory
  001e0	e3500000	 cmp         r0, #0

; 605  :                     SetLastError(ERROR_INVALID_PARAMETER);
; 606  :                     break;

  001e4	1affffcc	 bne         |$LN59@VRF_IOCont|
  001e8		 |$LN15@VRF_IOCont|

; 696  :                     {
; 697  :                     SetLastError(ERROR_INVALID_PARAMETER);

  001e8	e3a00057	 mov         r0, #0x57
  001ec		 |$LN58@VRF_IOCont|
  001ec	eb000000	 bl          SetLastError
  001f0		 |$cleanUp$45166|

; 771  :                     }
; 772  :             }
; 773  :             break;
; 774  :  
; 775  :         default:
; 776  :             DEBUGMSG(ZONE_WARNING, (
; 777  :                 L"VRFB: Unknown IOControl = 0x%08x\r\n",
; 778  :                 code
; 779  :                 ));
; 780  :    
; 781  :         }
; 782  : 
; 783  : cleanUp:
; 784  :     DEBUGMSG(ZONE_FUNCTION, (L"-VRF_IOControl(rc = %d)\r\n", rc));
; 785  :     return rc;
; 786  : }

  001f0	e1a00008	 mov         r0, r8
  001f4	e28dd02c	 add         sp, sp, #0x2C
  001f8	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  001fc	e12fff1e	 bx          lr
  00200		 |$LN21@VRF_IOCont|

; 671  :                     }
; 672  :             }
; 673  :             break;
; 674  :  
; 675  :         case IOCTL_VRFB_ROTATEVIEW:
; 676  :             {
; 677  :                 if ((pInBuffer == NULL)||
; 678  :                     (inSize < sizeof(VRFB_VIEW_INFO)))

  00200	e3550000	 cmp         r5, #0
  00204	0afffff7	 beq         |$LN15@VRF_IOCont|
  00208	e3560040	 cmp         r6, #0x40
  0020c	3afffff5	 bcc         |$LN15@VRF_IOCont|

; 679  :                     {
; 680  :                     SetLastError(ERROR_INVALID_PARAMETER);
; 681  :                     }
; 682  :                 else
; 683  :                     {
; 684  :                     HANDLE          hContext = (HANDLE) context;
; 685  :                     VRFB_VIEW_INFO *pViewInfo = (VRFB_VIEW_INFO*)pInBuffer;
; 686  :                     
; 687  :                     rc = VRFB_RotateView( hContext, pViewInfo->hView, pViewInfo->dwRotationAngle ); 

  00210	e595202c	 ldr         r2, [r5, #0x2C]
  00214	e5951000	 ldr         r1, [r5]
  00218	e1a00009	 mov         r0, r9
  0021c	eb000000	 bl          VRFB_RotateView

; 698  :                     }
; 699  :                 else
; 700  :                     {
; 701  :                     HANDLE          hContext = (HANDLE) context;
; 702  :                     VRFB_VIEW_INFO *pViewInfo = (VRFB_VIEW_INFO*)pInBuffer;
; 703  :                     
; 704  :                     rc = VRFB_UpdateView( hContext,
; 705  :                                           pViewInfo->hView,
; 706  :                                           pViewInfo->dwPixelSize, 
; 707  :                                           pViewInfo->dwWidth,
; 708  :                                           pViewInfo->dwHeight, 
; 709  :                                           pViewInfo->dwPhysicalBufferAddr );

  00220	e1a08000	 mov         r8, r0
  00224	eafffff1	 b           |$cleanUp$45166|
  00228		 |$LN49@VRF_IOCont|

; 560  :         {
; 561  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: VRF_IOControl: "
; 562  :             L"Incorrect context param\r\n"
; 563  :             ));
; 564  :         goto cleanUp;
; 565  :         }
; 566  : 
; 567  :     //  Get Device
; 568  :     pDevice = pInstance->pDevice;
; 569  : 
; 570  : 
; 571  :     switch (code)

  00228	e59f311c	 ldr         r3, [pc, #0x11C]
  0022c	e1510003	 cmp         r1, r3
  00230	0a000033	 beq         |$LN17@VRF_IOCont|
  00234	e59f310c	 ldr         r3, [pc, #0x10C]
  00238	e1510003	 cmp         r1, r3
  0023c	0a000025	 beq         |$LN13@VRF_IOCont|
  00240	e59f30fc	 ldr         r3, [pc, #0xFC]
  00244	e1510003	 cmp         r1, r3
  00248	0a000014	 beq         |$LN9@VRF_IOCont|
  0024c	e59f30ec	 ldr         r3, [pc, #0xEC]
  00250	e1510003	 cmp         r1, r3
  00254	1affffe5	 bne         |$cleanUp$45166|

; 751  :  
; 752  :         case IOCTL_VRFB_GETDISPLAYVIEWINFO:
; 753  :             {
; 754  :                 if ((pInBuffer == NULL) || (pOutBuffer == NULL) ||
; 755  :                     (inSize < sizeof(IOCTL_VRFB_GETDISPLAYVIEWINFO_IN)) ||
; 756  :                     (outSize < sizeof(VRFB_VIEW_INFO)))

  00258	e3550000	 cmp         r5, #0
  0025c	0affffe1	 beq         |$LN15@VRF_IOCont|
  00260	e59de048	 ldr         lr, [sp, #0x48]
  00264	e35e0000	 cmp         lr, #0
  00268	0affffde	 beq         |$LN15@VRF_IOCont|
  0026c	e356000c	 cmp         r6, #0xC
  00270	3affffdc	 bcc         |$LN15@VRF_IOCont|
  00274	e59d304c	 ldr         r3, [sp, #0x4C]
  00278	e3530040	 cmp         r3, #0x40
  0027c	3affffd9	 bcc         |$LN15@VRF_IOCont|

; 757  :                     {
; 758  :                     SetLastError(ERROR_INVALID_PARAMETER);
; 759  :                     }
; 760  :                 else
; 761  :                     {
; 762  :                     HANDLE                            hContext = (HANDLE) context;
; 763  :                     IOCTL_VRFB_GETDISPLAYVIEWINFO_IN *pInfo = (IOCTL_VRFB_GETDISPLAYVIEWINFO_IN*)pInBuffer;
; 764  :                     VRFB_VIEW_INFO                   *pViewInfo = (VRFB_VIEW_INFO*)pOutBuffer;
; 765  :                     
; 766  :                     rc = VRFB_GetDisplayViewInfo( hContext, 
; 767  :                                                   pInfo->dwIndex,
; 768  :                                                   pInfo->dwRotateAngle,
; 769  :                                                   pInfo->bMirror,
; 770  :                                                   pViewInfo );

  00280	e5953008	 ldr         r3, [r5, #8]
  00284	e5952004	 ldr         r2, [r5, #4]
  00288	e5951000	 ldr         r1, [r5]
  0028c	e1a00009	 mov         r0, r9
  00290	e58de000	 str         lr, [sp]
  00294	eb000000	 bl          VRFB_GetDisplayViewInfo
  00298	e1a08000	 mov         r8, r0
  0029c	eaffffd3	 b           |$cleanUp$45166|
  002a0		 |$LN9@VRF_IOCont|

; 731  : 
; 732  :         case IOCTL_VRFB_GETDISPLAYVIEW:
; 733  :             {
; 734  :                 if ((pInBuffer == NULL) || (pOutBuffer == NULL) ||
; 735  :                     (inSize < sizeof(DWORD)) ||
; 736  :                     (outSize < sizeof(HANDLE)))

  002a0	e3550000	 cmp         r5, #0
  002a4	0affffcf	 beq         |$LN15@VRF_IOCont|
  002a8	e59d4048	 ldr         r4, [sp, #0x48]
  002ac	e3540000	 cmp         r4, #0
  002b0	0affffcc	 beq         |$LN15@VRF_IOCont|
  002b4	e3560004	 cmp         r6, #4
  002b8	3affffca	 bcc         |$LN15@VRF_IOCont|
  002bc	e59d304c	 ldr         r3, [sp, #0x4C]
  002c0	e3530004	 cmp         r3, #4
  002c4	3affffc7	 bcc         |$LN15@VRF_IOCont|

; 737  :                     {
; 738  :                     SetLastError(ERROR_INVALID_PARAMETER);
; 739  :                     }
; 740  :                 else
; 741  :                     {
; 742  :                     HANDLE  hContext = (HANDLE) context;
; 743  :                     DWORD  *dwIndex = (DWORD*)pInBuffer;
; 744  :                     HANDLE *hView = (HANDLE*)pOutBuffer;
; 745  :                     
; 746  :                     *hView = VRFB_GetDisplayView( hContext, *dwIndex );

  002c8	e5951000	 ldr         r1, [r5]
  002cc	e1a00009	 mov         r0, r9
  002d0	eb000000	 bl          VRFB_GetDisplayView

; 747  :                     rc = TRUE;
; 748  :                     }
; 749  :             }
; 750  :             break;

  002d4	eaffff8f	 b           |$LN60@VRF_IOCont|
  002d8		 |$LN13@VRF_IOCont|

; 710  :                     }
; 711  :             }
; 712  :             break;
; 713  :  
; 714  :         case IOCTL_VRFB_NUMDISPLAYVIEWS:
; 715  :             {
; 716  :                 if ((pOutBuffer == NULL) ||
; 717  :                     (outSize < sizeof(DWORD)))

  002d8	e59d2048	 ldr         r2, [sp, #0x48]
  002dc	e3520000	 cmp         r2, #0
  002e0	0affffc0	 beq         |$LN15@VRF_IOCont|
  002e4	e59d304c	 ldr         r3, [sp, #0x4C]
  002e8	e3530004	 cmp         r3, #4
  002ec	3affffbd	 bcc         |$LN15@VRF_IOCont|

; 718  :                     {
; 719  :                     SetLastError(ERROR_INVALID_PARAMETER);
; 720  :                     }
; 721  :                 else
; 722  :                     {
; 723  :                     HANDLE  hContext = (HANDLE) context;
; 724  :                     DWORD*  pNumViews = (DWORD*)pOutBuffer;
; 725  :                     
; 726  :                     *pNumViews = VRFB_NumDisplayViews( hContext ); 

  002f0	e5993004	 ldr         r3, [r9, #4]
  002f4		 |$cleanUp$46047|

; 727  :                     rc = TRUE;

  002f4	e3a08001	 mov         r8, #1
  002f8	e5933004	 ldr         r3, [r3, #4]
  002fc	e5823000	 str         r3, [r2]

; 728  :                     }
; 729  :             }
; 730  :             break;

  00300	eaffffba	 b           |$cleanUp$45166|
  00304		 |$LN17@VRF_IOCont|

; 688  :                     }
; 689  :             }
; 690  :             break;
; 691  :  
; 692  :         case IOCTL_VRFB_UPDATEVIEW:
; 693  :             {
; 694  :                 if ((pInBuffer == NULL)||
; 695  :                     (inSize < sizeof(VRFB_VIEW_INFO)))

  00304	e3550000	 cmp         r5, #0
  00308	0affffb6	 beq         |$LN15@VRF_IOCont|
  0030c	e3560040	 cmp         r6, #0x40
  00310	3affffb4	 bcc         |$LN15@VRF_IOCont|

; 698  :                     }
; 699  :                 else
; 700  :                     {
; 701  :                     HANDLE          hContext = (HANDLE) context;
; 702  :                     VRFB_VIEW_INFO *pViewInfo = (VRFB_VIEW_INFO*)pInBuffer;
; 703  :                     
; 704  :                     rc = VRFB_UpdateView( hContext,
; 705  :                                           pViewInfo->hView,
; 706  :                                           pViewInfo->dwPixelSize, 
; 707  :                                           pViewInfo->dwWidth,
; 708  :                                           pViewInfo->dwHeight, 
; 709  :                                           pViewInfo->dwPhysicalBufferAddr );

  00314	e595003c	 ldr         r0, [r5, #0x3C]
  00318	e595e010	 ldr         lr, [r5, #0x10]
  0031c	e595300c	 ldr         r3, [r5, #0xC]
  00320	e5952004	 ldr         r2, [r5, #4]
  00324	e5951000	 ldr         r1, [r5]
  00328	e58d0004	 str         r0, [sp, #4]
  0032c	e1a00009	 mov         r0, r9
  00330	e58de000	 str         lr, [sp]
  00334	eb000000	 bl          VRFB_UpdateView
  00338	e1a08000	 mov         r8, r0
  0033c	eaffffab	 b           |$cleanUp$45166|
  00340		 |$LN64@VRF_IOCont|
  00340		 |$LN65@VRF_IOCont|
  00340	00221c1c	 DCD         0x221c1c
  00344		 |$LN66@VRF_IOCont|
  00344	00221c18	 DCD         0x221c18
  00348		 |$LN67@VRF_IOCont|
  00348	00221c14	 DCD         0x221c14
  0034c		 |$LN68@VRF_IOCont|
  0034c	00221c10	 DCD         0x221c10
  00350		 |$LN69@VRF_IOCont|
  00350	00000000	 DCD         |VRFB_GetDisplayViewInfo|
  00354		 |$LN70@VRF_IOCont|
  00354	00000000	 DCD         |VRFB_GetDisplayView|
  00358		 |$LN71@VRF_IOCont|
  00358	00000000	 DCD         |VRFB_NumDisplayViews|
  0035c		 |$LN72@VRF_IOCont|
  0035c	00000000	 DCD         |VRFB_UpdateView|
  00360		 |$LN73@VRF_IOCont|
  00360	00000000	 DCD         |VRFB_RotateView|
  00364		 |$LN74@VRF_IOCont|
  00364	00000000	 DCD         |VRFB_AllocateView|
  00368		 |$LN75@VRF_IOCont|
  00368	00000000	 DCD         |VRFB_GetViewInfo|
  0036c		 |$LN76@VRF_IOCont|
  0036c	00000000	 DCD         |VRFB_ReleaseView|
  00370		 |$LN77@VRF_IOCont|
  00370	00000000	 DCD         |DEVICE_IFC_VRFB_GUID|
  00374		 |$LN78@VRF_IOCont|
  00374	00221c08	 DCD         0x221c08
  00378		 |$LN79@VRF_IOCont|
  00378	00221c04	 DCD         0x221c04
  0037c		 |$LN80@VRF_IOCont|
  0037c	00221c0c	 DCD         0x221c0c
  00380		 |$LN81@VRF_IOCont|
  00380	76726649	 DCD         0x76726649
  00384		 |$M46073|

			 ENDP  ; |VRF_IOControl|

	END
