; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\SERIAL\UART\pdd.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1BK@ECILAKDK@?$AAR?$AAt?$AAs?$AAC?$AAt?$AAs?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CG@DHJJPDED@?$AAR?$AAx?$AAF?$AAi?$AAf?$AAo?$AAT?$AAr?$AAi?$AAg?$AAg?$AAe?$AAr?$AAL?$AAe?$AAv?$AAe?$AAl?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CC@FIFIMOFA@?$AAX?$AAc?$AAv?$AAr?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAd?$AAL?$AAe?$AAv?$AAe?$AAl?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BO@NNHFJINL@?$AAX?$AAc?$AAv?$AAr?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAG?$AAp?$AAi?$AAo?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CA@JOFPGGEL@?$AAR?$AAx?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@EAHGCAAM@?$AAR?$AAx?$AAD?$AAm?$AAa?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BM@EBCLBMAF@?$AAT?$AAX?$AAP?$AAa?$AAu?$AAs?$AAe?$AAT?$AAi?$AAm?$AAe?$AAM?$AAs?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CA@NHBAHBHE@?$AAT?$AAx?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@HPKIPNLN@?$AAT?$AAx?$AAD?$AAm?$AAa?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BE@CEKAHLDM@?$AAH?$AAW?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BC@OKCHLFFC@?$AAR?$AAx?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BC@HNMEBGCB@?$AAW?$AAa?$AAk?$AAe?$AAC?$AAh?$AAa?$AAr?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BE@GPCELNGD@?$AAF?$AAr?$AAe?$AAq?$AAu?$AAe?$AAn?$AAc?$AAy?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1O@OJFFKIAG@?$AAH?$AAW?$AAM?$AAo?$AAd?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CC@KMPFMANC@?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.bss|, NOINIT
|GlobalSerialHeadNumber| % 0x4

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@ECILAKDK@?$AAR?$AAt?$AAs?$AAC?$AAt?$AAs?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?$AA@| DCB "R"
	DCB	0x0, "t", 0x0, "s", 0x0, "C", 0x0, "t", 0x0, "s", 0x0, "E"
	DCB	0x0, "n", 0x0, "a", 0x0, "b", 0x0, "l", 0x0, "e", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CG@DHJJPDED@?$AAR?$AAx?$AAF?$AAi?$AAf?$AAo?$AAT?$AAr?$AAi?$AAg?$AAg?$AAe?$AAr?$AAL?$AAe?$AAv?$AAe?$AAl?$AA?$AA@| DCB "R"
	DCB	0x0, "x", 0x0, "F", 0x0, "i", 0x0, "f", 0x0, "o", 0x0, "T"
	DCB	0x0, "r", 0x0, "i", 0x0, "g", 0x0, "g", 0x0, "e", 0x0, "r"
	DCB	0x0, "L", 0x0, "e", 0x0, "v", 0x0, "e", 0x0, "l", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@FIFIMOFA@?$AAX?$AAc?$AAv?$AAr?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAd?$AAL?$AAe?$AAv?$AAe?$AAl?$AA?$AA@| DCB "X"
	DCB	0x0, "c", 0x0, "v", 0x0, "r", 0x0, "E", 0x0, "n", 0x0, "a"
	DCB	0x0, "b", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, "L", 0x0, "e"
	DCB	0x0, "v", 0x0, "e", 0x0, "l", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BO@NNHFJINL@?$AAX?$AAc?$AAv?$AAr?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAG?$AAp?$AAi?$AAo?$AA?$AA@| DCB "X"
	DCB	0x0, "c", 0x0, "v", 0x0, "r", 0x0, "E", 0x0, "n", 0x0, "a"
	DCB	0x0, "b", 0x0, "l", 0x0, "e", 0x0, "G", 0x0, "p", 0x0, "i"
	DCB	0x0, "o", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CA@JOFPGGEL@?$AAR?$AAx?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?$AA@| DCB "R"
	DCB	0x0, "x", 0x0, "D", 0x0, "m", 0x0, "a", 0x0, "B", 0x0, "u"
	DCB	0x0, "f", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, "S", 0x0, "i"
	DCB	0x0, "z", 0x0, "e", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@EAHGCAAM@?$AAR?$AAx?$AAD?$AAm?$AAa?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?$AA@| DCB "R"
	DCB	0x0, "x", 0x0, "D", 0x0, "m", 0x0, "a", 0x0, "R", 0x0, "e"
	DCB	0x0, "q", 0x0, "u", 0x0, "e", 0x0, "s", 0x0, "t", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BM@EBCLBMAF@?$AAT?$AAX?$AAP?$AAa?$AAu?$AAs?$AAe?$AAT?$AAi?$AAm?$AAe?$AAM?$AAs?$AA?$AA@| DCB "T"
	DCB	0x0, "X", 0x0, "P", 0x0, "a", 0x0, "u", 0x0, "s", 0x0, "e"
	DCB	0x0, "T", 0x0, "i", 0x0, "m", 0x0, "e", 0x0, "M", 0x0, "s"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CA@NHBAHBHE@?$AAT?$AAx?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?$AA@| DCB "T"
	DCB	0x0, "x", 0x0, "D", 0x0, "m", 0x0, "a", 0x0, "B", 0x0, "u"
	DCB	0x0, "f", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, "S", 0x0, "i"
	DCB	0x0, "z", 0x0, "e", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@HPKIPNLN@?$AAT?$AAx?$AAD?$AAm?$AAa?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?$AA@| DCB "T"
	DCB	0x0, "x", 0x0, "D", 0x0, "m", 0x0, "a", 0x0, "R", 0x0, "e"
	DCB	0x0, "q", 0x0, "u", 0x0, "e", 0x0, "s", 0x0, "t", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@CEKAHLDM@?$AAH?$AAW?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB "H"
	DCB	0x0, "W", 0x0, "T", 0x0, "i", 0x0, "m", 0x0, "e", 0x0, "o"
	DCB	0x0, "u", 0x0, "t", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BC@OKCHLFFC@?$AAR?$AAx?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$AA@| DCB "R"
	DCB	0x0, "x", 0x0, "B", 0x0, "u", 0x0, "f", 0x0, "f", 0x0, "e"
	DCB	0x0, "r", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BC@HNMEBGCB@?$AAW?$AAa?$AAk?$AAe?$AAC?$AAh?$AAa?$AAr?$AA?$AA@| DCB "W"
	DCB	0x0, "a", 0x0, "k", 0x0, "e", 0x0, "C", 0x0, "h", 0x0, "a"
	DCB	0x0, "r", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@GPCELNGD@?$AAF?$AAr?$AAe?$AAq?$AAu?$AAe?$AAn?$AAc?$AAy?$AA?$AA@| DCB "F"
	DCB	0x0, "r", 0x0, "e", 0x0, "q", 0x0, "u", 0x0, "e", 0x0, "n"
	DCB	0x0, "c", 0x0, "y", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1O@OJFFKIAG@?$AAH?$AAW?$AAM?$AAo?$AAd?$AAe?$AA?$AA@| DCB "H", 0x0, "W"
	DCB	0x0, "M", 0x0, "o", 0x0, "d", 0x0, "e", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@KMPFMANC@?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$AA@| DCB "D"
	DCB	0x0, "e", 0x0, "v", 0x0, "i", 0x0, "c", 0x0, "e", 0x0, "A"
	DCB	0x0, "r", 0x0, "r", 0x0, "a", 0x0, "y", 0x0, "I", 0x0, "n"
	DCB	0x0, "d", 0x0, "e", 0x0, "x", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.data|, DATA
|g_pddVTbl| DCD	|HWInit|
	DCD	|HWPostInit|
	DCD	|HWDeinit|
	DCD	|HWOpen|
	DCD	|HWClose|
	DCD	|HWGetInterruptType|
	DCD	|HWRxIntr|
	DCD	|HWTxIntr|
	DCD	|HWModemIntr|
	DCD	|HWLineIntr|
	DCD	|HWGetRxBufferSize|
	DCD	|HWPowerOff|
	DCD	|HWPowerOn|
	DCD	|HWClearDTR|
	DCD	|HWSetDTR|
	DCD	|HWClearRTS|
	DCD	|HWSetRTS|
	DCD	|HWEnableIR|
	DCD	|HWDisableIR|
	DCD	|HWClearBreak|
	DCD	|HWSetBreak|
	DCD	|HWXmitComChar|
	DCD	|HWGetStatus|
	DCD	|HWReset|
	DCD	|HWGetModemStatus|
	DCD	|HWGetCommProperties|
	DCD	|HWPurgeComm|
	DCD	|HWSetDCB|
	DCD	|HWSetCommTimeouts|
	DCD	|HWIOCtl|

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
|s_deviceRegParams| DCD |??_C@_1CC@KMPFMANC@?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$AA@|
	DCD	0x1
	DCD	0x1
	DCD	0xc
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1O@OJFFKIAG@?$AAH?$AAW?$AAM?$AAo?$AAd?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x14
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BE@GPCELNGD@?$AAF?$AAr?$AAe?$AAq?$AAu?$AAe?$AAn?$AAc?$AAy?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x4c
	DCD	0x4
	DCD	0x2dc6c00
	DCD	|??_C@_1BC@HNMEBGCB@?$AAW?$AAa?$AAk?$AAe?$AAC?$AAh?$AAa?$AAr?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x1c
	DCD	0x4
	DCD	0x32
	DCD	|??_C@_1BC@OKCHLFFC@?$AAR?$AAx?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x18
	DCD	0x4
	DCD	0x2000
	DCD	|??_C@_1BE@CEKAHLDM@?$AAH?$AAW?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x20
	DCD	0x4
	DCD	0x3e8
	DCD	|??_C@_1BK@HPKIPNLN@?$AAT?$AAx?$AAD?$AAm?$AAa?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0xf0
	DCD	0x4
	DCD	0xffffffff
	DCD	|??_C@_1CA@NHBAHBHE@?$AAT?$AAx?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0xf4
	DCD	0x4
	DCD	0x2000
	DCD	|??_C@_1BM@EBCLBMAF@?$AAT?$AAX?$AAP?$AAa?$AAu?$AAs?$AAe?$AAT?$AAi?$AAm?$AAe?$AAM?$AAs?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0xec
	DCD	0x4
	DCD	0x25
	DCD	|??_C@_1BK@EAHGCAAM@?$AAR?$AAx?$AAD?$AAm?$AAa?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x10c
	DCD	0x4
	DCD	0xffffffff
	DCD	|??_C@_1CA@JOFPGGEL@?$AAR?$AAx?$AAD?$AAm?$AAa?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x110
	DCD	0x4
	DCD	0x2000
	DCD	|??_C@_1BO@NNHFJINL@?$AAX?$AAc?$AAv?$AAr?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAG?$AAp?$AAi?$AAo?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x170
	DCD	0x4
	DCD	0xffff
	DCD	|??_C@_1CC@FIFIMOFA@?$AAX?$AAc?$AAv?$AAr?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAd?$AAL?$AAe?$AAv?$AAe?$AAl?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x174
	DCD	0x4
	DCD	0xffff
	DCD	|??_C@_1CG@DHJJPDED@?$AAR?$AAx?$AAF?$AAi?$AAf?$AAo?$AAT?$AAr?$AAi?$AAg?$AAg?$AAe?$AAr?$AAL?$AAe?$AAv?$AAe?$AAl?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x154
	DCD	0x4
	DCD	0x20
	DCD	|??_C@_1BK@ECILAKDK@?$AAR?$AAt?$AAs?$AAC?$AAt?$AAs?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x158
	DCD	0x4
	DCD	0x0
	EXPORT	|PulseEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T46539| DCD	|$LN5@PulseEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PulseEvent| PROC

; 211  : _inline BOOL PulseEvent(HANDLE h) {

  00000		 |$LN5@PulseEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46536|

; 212  : 	return EventModify(h,EVENT_PULSE);

  00004	e3a01001	 mov         r1, #1
  00008	eb000000	 bl          EventModify

; 213  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M46537|

			 ENDP  ; |PulseEvent|

	EXPORT	|ResetEvent|

  00000			 AREA	 |.pdata|, PDATA
|$T46549| DCD	|$LN5@ResetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ResetEvent| PROC

; 223  : _inline BOOL ResetEvent(HANDLE h) {

  00000		 |$LN5@ResetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46546|

; 224  : 	return EventModify(h,EVENT_RESET);

  00004	e3a01002	 mov         r1, #2
  00008	eb000000	 bl          EventModify

; 225  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M46547|

			 ENDP  ; |ResetEvent|

	EXPORT	|SetEvent|

  00000			 AREA	 |.pdata|, PDATA
|$T46559| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46556|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M46557|

			 ENDP  ; |SetEvent|

	EXPORT	|GetCurrentThread|

  00000			 AREA	 |.pdata|, PDATA
|$T46568| DCD	|$LN5@GetCurrent|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentThread| PROC

; 351  : _inline HANDLE GetCurrentThread(void) {

  00000		 |$LN5@GetCurrent|
  00000		 |$M46565|

; 352  : 	return ((HANDLE)(SH_CURTHREAD+SYS_HANDLE_BASE));

  00000	e3a00041	 mov         r0, #0x41

; 353  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M46566|

			 ENDP  ; |GetCurrentThread|

	EXPORT	|DmaConfigure|
	IMPORT	|DmaGetLogicalChannel|
	IMPORT	|memset|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\inc\omap_sdma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T46584| DCD	|$LN8@DmaConfigu|
	DCD	0x40003901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaConfigure| PROC

; 166  : {

  00000		 |$LN8@DmaConfigu|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M46581|
  00004	e1a04003	 mov         r4, r3
  00008	e1a09002	 mov         r9, r2
  0000c	e1a06001	 mov         r6, r1
  00010	e1a05000	 mov         r5, r0

; 167  :     BOOL rc = FALSE;
; 168  :     OMAP_DMA_LC_REGS *pDmaLcReg = (OMAP_DMA_LC_REGS*)DmaGetLogicalChannel(hDmaChannel);

  00014	e3a08000	 mov         r8, #0
  00018	eb000000	 bl          DmaGetLogicalChannel
  0001c	e1b07000	 movs        r7, r0

; 169  :     if (pDmaLcReg == NULL || pConfigInfo == NULL)

  00020	0a00002c	 beq         |$cleanUp$43820|
  00024	e3560000	 cmp         r6, #0
  00028	0a00002a	 beq         |$cleanUp$43820|

; 170  :         {
; 171  :         goto cleanUp;
; 172  :         }
; 173  : 
; 174  :     // initialize dma DataInfo if necessary
; 175  :     if (pDataInfo != NULL)

  0002c	e3540000	 cmp         r4, #0
  00030	0a000005	 beq         |$LN1@DmaConfigu|

; 176  :         {
; 177  :         memset(pDataInfo, 0, sizeof(DmaDataInfo_t));

  00034	e3a02018	 mov         r2, #0x18
  00038	e3a01000	 mov         r1, #0
  0003c	e1a00004	 mov         r0, r4
  00040	eb000000	 bl          memset

; 178  :         pDataInfo->hDmaChannel = hDmaChannel;

  00044	e5845010	 str         r5, [r4, #0x10]

; 179  :         pDataInfo->pDmaLcReg = pDmaLcReg;

  00048	e5847014	 str         r7, [r4, #0x14]
  0004c		 |$LN1@DmaConfigu|

; 180  :         }
; 181  : 
; 182  :     // Disable the DMA in case it is running
; 183  :     CLRREG32(&pDmaLcReg->CCR, DMA_CCR_ENABLE);

  0004c	e5973000	 ldr         r3, [r7]

; 184  : 
; 185  :     // update syncmap
; 186  :     pConfigInfo->syncMap = syncMap;
; 187  : 
; 188  :     // Initialize logical channel registers
; 189  :     //
; 190  :     OUTREG32(&pDmaLcReg->CCR, 0);

  00050	e3a02000	 mov         r2, #0

; 191  :     OUTREG32(&pDmaLcReg->CLNK_CTRL, 0);
; 192  :     OUTREG32(&pDmaLcReg->COLOR, 0);
; 193  : 
; 194  :     // update CSDP
; 195  :     //  DATA_TYPE
; 196  :     //  DST
; 197  :     //  SRC
; 198  :     OUTREG32(&pDmaLcReg->CSDP, pConfigInfo->elemSize);
; 199  : 
; 200  :     // update CCR
; 201  :     //  DST_MODE
; 202  :     //  SRC_MODE
; 203  :     //  PRIO
; 204  :     //  SYNC
; 205  :     //
; 206  :     OUTREG32(&pDmaLcReg->CCR, pConfigInfo->srcAddrMode |
; 207  :         pConfigInfo->dstAddrMode | pConfigInfo->dmaPrio |
; 208  :         DMA_CCR_SYNC(syncMap) | pConfigInfo->synchTrigger |
; 209  :         pConfigInfo->synchMode
; 210  :         );

  00054	e2090060	 and         r0, r9, #0x60
  00058	e3c33080	 bic         r3, r3, #0x80
  0005c	e5873000	 str         r3, [r7]
  00060	e586902c	 str         r9, [r6, #0x2C]
  00064	e5872000	 str         r2, [r7]
  00068	e5872004	 str         r2, [r7, #4]
  0006c	e5872044	 str         r2, [r7, #0x44]
  00070	e5963000	 ldr         r3, [r6]

; 211  : 
; 212  :     // update CSEI
; 213  :     //
; 214  :     OUTREG32(&pDmaLcReg->CSEI, pConfigInfo->srcElemIndex);
; 215  : 
; 216  :     // update CDEI
; 217  :     //
; 218  :     OUTREG32(&pDmaLcReg->CDEI, pConfigInfo->dstElemIndex);
; 219  : 
; 220  :     // update CSFI
; 221  :     //
; 222  :     OUTREG32(&pDmaLcReg->CSFI, pConfigInfo->srcFrameIndex);
; 223  : 
; 224  :     // update CDFI
; 225  :     //
; 226  :     OUTREG32(&pDmaLcReg->CDFI, pConfigInfo->dstFrameIndex);
; 227  : 
; 228  :     // update CICR
; 229  :     //
; 230  :     OUTREG32(&pDmaLcReg->CICR , pConfigInfo->interrupts);
; 231  :     
; 232  :     rc = TRUE;

  00074	e3a08001	 mov         r8, #1
  00078	e5873010	 str         r3, [r7, #0x10]
  0007c	e5962024	 ldr         r2, [r6, #0x24]
  00080	e209301f	 and         r3, r9, #0x1F
  00084	e5961020	 ldr         r1, [r6, #0x20]
  00088	e1833700	 orr         r3, r3, r0, lsl #14
  0008c	e1833002	 orr         r3, r3, r2
  00090	e596201c	 ldr         r2, [r6, #0x1C]
  00094	e1833001	 orr         r3, r3, r1
  00098	e5961018	 ldr         r1, [r6, #0x18]
  0009c	e1833002	 orr         r3, r3, r2
  000a0	e596200c	 ldr         r2, [r6, #0xC]
  000a4	e1833001	 orr         r3, r3, r1
  000a8	e1833002	 orr         r3, r3, r2
  000ac	e5873000	 str         r3, [r7]
  000b0	e5963004	 ldr         r3, [r6, #4]
  000b4	e5873024	 str         r3, [r7, #0x24]
  000b8	e5963010	 ldr         r3, [r6, #0x10]
  000bc	e587302c	 str         r3, [r7, #0x2C]
  000c0	e5963008	 ldr         r3, [r6, #8]
  000c4	e5873028	 str         r3, [r7, #0x28]
  000c8	e5963014	 ldr         r3, [r6, #0x14]
  000cc	e5873030	 str         r3, [r7, #0x30]
  000d0	e5963028	 ldr         r3, [r6, #0x28]
  000d4	e5873008	 str         r3, [r7, #8]
  000d8		 |$cleanUp$43820|

; 233  : 
; 234  : cleanUp:
; 235  :     return rc;
; 236  : }

  000d8	e1a00008	 mov         r0, r8
  000dc	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000e0	e12fff1e	 bx          lr
  000e4		 |$M46582|

			 ENDP  ; |DmaConfigure|

	EXPORT	|DmaSetDstBuffer|

  00000			 AREA	 |.pdata|, PDATA
|$T46594| DCD	|$LN6@DmaSetDstB|
	DCD	0x40000800
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaSetDstBuffer| PROC

; 330  : {

  00000		 |$LN6@DmaSetDstB|
  00000		 |$M46591|

; 331  :     // save values
; 332  :     //
; 333  :     pDataInfo->pDstBuffer = pBuffer;
; 334  :     pDataInfo->PhysAddrDstBuffer = PhysAddr;
; 335  : 
; 336  :     // set destination address
; 337  :     //
; 338  :     if (pDataInfo->pDmaLcReg != NULL)

  00000	e5903014	 ldr         r3, [r0, #0x14]
  00004	e5801004	 str         r1, [r0, #4]
  00008	e580200c	 str         r2, [r0, #0xC]
  0000c	e3530000	 cmp         r3, #0

; 339  :         {
; 340  :         OUTREG32(&pDataInfo->pDmaLcReg->CDSA, PhysAddr);

  00010	15832020	 strne       r2, [r3, #0x20]

; 341  :         OUTREG32(&pDataInfo->pDmaLcReg->CDAC, PhysAddr);

  00014	15903014	 ldrne       r3, [r0, #0x14]
  00018	15832038	 strne       r2, [r3, #0x38]

; 342  :         }
; 343  : }

  0001c	e12fff1e	 bx          lr
  00020		 |$M46592|

			 ENDP  ; |DmaSetDstBuffer|

	EXPORT	|DmaSetSrcBuffer|

  00000			 AREA	 |.pdata|, PDATA
|$T46604| DCD	|$LN6@DmaSetSrcB|
	DCD	0x40000800
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaSetSrcBuffer| PROC

; 358  : {

  00000		 |$LN6@DmaSetSrcB|
  00000		 |$M46601|

; 359  :     // save values
; 360  :     //
; 361  :     pDataInfo->pSrcBuffer = pBuffer;
; 362  :     pDataInfo->PhysAddrSrcBuffer = PhysAddr;
; 363  : 
; 364  :     // set source address
; 365  :     //
; 366  :     if (pDataInfo->pDmaLcReg != NULL)

  00000	e5903014	 ldr         r3, [r0, #0x14]
  00004	e5801000	 str         r1, [r0]
  00008	e5802008	 str         r2, [r0, #8]
  0000c	e3530000	 cmp         r3, #0

; 367  :         {
; 368  :         OUTREG32(&pDataInfo->pDmaLcReg->CSSA, PhysAddr);

  00010	1583201c	 strne       r2, [r3, #0x1C]

; 369  :         OUTREG32(&pDataInfo->pDmaLcReg->CSAC, PhysAddr);

  00014	15903014	 ldrne       r3, [r0, #0x14]
  00018	15832034	 strne       r2, [r3, #0x34]

; 370  :         }
; 371  : }

  0001c	e12fff1e	 bx          lr
  00020		 |$M46602|

			 ENDP  ; |DmaSetSrcBuffer|

	EXPORT	|DmaSetElementAndFrameCount|

  00000			 AREA	 |.pdata|, PDATA
|$T46614| DCD	|$LN5@DmaSetElem|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaSetElementAndFrameCount| PROC

; 386  : {

  00000		 |$LN5@DmaSetElem|
  00000		 |$M46611|

; 387  :     // setup frame and element count for destination side
; 388  :     //
; 389  :     OUTREG32(&pDataInfo->pDmaLcReg->CEN , countElements);

  00000	e5903014	 ldr         r3, [r0, #0x14]
  00004	e5831014	 str         r1, [r3, #0x14]

; 390  :     OUTREG32(&pDataInfo->pDmaLcReg->CFN , countFrames);

  00008	e5903014	 ldr         r3, [r0, #0x14]
  0000c	e5832018	 str         r2, [r3, #0x18]

; 391  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M46612|

			 ENDP  ; |DmaSetElementAndFrameCount|

	EXPORT	|IsDmaEnable|

  00000			 AREA	 |.pdata|, PDATA
|$T46624| DCD	|$LN8@IsDmaEnabl|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |IsDmaEnable| PROC

; 404  : {

  00000		 |$LN8@IsDmaEnabl|
  00000	e24dd004	 sub         sp, sp, #4
  00004		 |$M46621|
  00004	e3500000	 cmp         r0, #0

; 405  :     volatile ULONG ulCCR;
; 406  : 
; 407  :     if (NULL == pDataInfo)
; 408  :        return FALSE;
; 409  : 
; 410  :     ulCCR = INREG32(&pDataInfo->pDmaLcReg->CCR);

  00008	15903014	 ldrne       r3, [r0, #0x14]
  0000c	15933000	 ldrne       r3, [r3]
  00010	158d3000	 strne       r3, [sp]

; 411  : 
; 412  :     if (ulCCR & DMA_CCR_ENABLE)

  00014	159d3000	 ldrne       r3, [sp]
  00018	13130080	 tstne       r3, #0x80

; 413  :         return TRUE;

  0001c	13a00001	 movne       r0, #1

; 416  : }

  00020	128dd004	 addne       sp, sp, #4

; 414  :     else
; 415  :         return FALSE;

  00024	03a00000	 moveq       r0, #0

; 416  : }

  00028	028dd004	 addeq       sp, sp, #4
  0002c	e12fff1e	 bx          lr
  00030		 |$M46622|

			 ENDP  ; |IsDmaEnable|

	EXPORT	|DmaStop|

  00000			 AREA	 |.pdata|, PDATA
|$T46635| DCD	|$LN12@DmaStop|
	DCD	0x40001201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaStop| PROC

; 449  : {

  00000		 |$LN12@DmaStop|
  00000	e24dd004	 sub         sp, sp, #4
  00004		 |$M46632|

; 450  :     volatile ULONG ulCCR;
; 451  :     BOOL breakLoop = FALSE;
; 452  : 
; 453  :     // disable standby in dma controller
; 454  :     //
; 455  :     CLRREG32(&pDataInfo->pDmaLcReg->CCR , DMA_CCR_ENABLE);

  00004	e5902014	 ldr         r2, [r0, #0x14]
  00008	e3a01000	 mov         r1, #0
  0000c	e5923000	 ldr         r3, [r2]
  00010	e3c33080	 bic         r3, r3, #0x80
  00014	e5823000	 str         r3, [r2]
  00018	e5902014	 ldr         r2, [r0, #0x14]
  0001c		 |$LL5@DmaStop|

; 456  : 
; 457  :     // ensure DMA transfer is completed by polling the active bits
; 458  :     //
; 459  :     while (breakLoop == FALSE)
; 460  :         {
; 461  :         ulCCR = INREG32(&pDataInfo->pDmaLcReg->CCR);

  0001c	e5923000	 ldr         r3, [r2]
  00020	e58d3000	 str         r3, [sp]

; 462  :         if ((ulCCR & DMA_CCR_WR_ACTIVE) || (ulCCR & DMA_CCR_RD_ACTIVE))

  00024	e59d3000	 ldr         r3, [sp]
  00028	e3130b01	 tst         r3, #1, 22
  0002c	059d3000	 ldreq       r3, [sp]
  00030	03130c02	 tsteq       r3, #2, 24

; 463  :             {
; 464  :             // fix this infinite loop
; 465  :             //
; 466  :             continue;
; 467  :             }
; 468  :         else
; 469  :             {
; 470  :             breakLoop = TRUE;

  00034	03a01001	 moveq       r1, #1
  00038	e3510000	 cmp         r1, #0
  0003c	0afffff6	 beq         |$LL5@DmaStop|

; 471  :             }
; 472  :         }
; 473  : 
; 474  : }

  00040	e28dd004	 add         sp, sp, #4
  00044	e12fff1e	 bx          lr
  00048		 |$M46633|

			 ENDP  ; |DmaStop|

	EXPORT	|DmaStart|

  00000			 AREA	 |.pdata|, PDATA
|$T46643| DCD	|$LN5@DmaStart|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaStart| PROC

; 487  : {

  00000		 |$LN5@DmaStart|
  00000		 |$M46640|

; 488  :     // enable the dma channel
; 489  :     //
; 490  :     SETREG32(&pDataInfo->pDmaLcReg->CCR , DMA_CCR_ENABLE);

  00000	e5902014	 ldr         r2, [r0, #0x14]
  00004	e5923000	 ldr         r3, [r2]
  00008	e3833080	 orr         r3, r3, #0x80
  0000c	e5823000	 str         r3, [r2]

; 491  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M46641|

			 ENDP  ; |DmaStart|

	EXPORT	|DmaGetLastWritePos|

  00000			 AREA	 |.pdata|, PDATA
|$T46654| DCD	|$LN5@DmaGetLast|
	DCD	0x40000700
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaGetLastWritePos| PROC

; 504  : {

  00000		 |$LN5@DmaGetLast|
  00000		 |$M46651|

; 505  :     UINT32  offset;
; 506  :     offset = INREG32(&pDataInfo->pDmaLcReg->CDAC) - pDataInfo->PhysAddrDstBuffer;

  00000	e5903014	 ldr         r3, [r0, #0x14]
  00004	e590200c	 ldr         r2, [r0, #0xC]

; 507  :     return ((UINT8*)pDataInfo->pDstBuffer + offset);

  00008	e5901004	 ldr         r1, [r0, #4]
  0000c	e5933038	 ldr         r3, [r3, #0x38]
  00010	e0433002	 sub         r3, r3, r2
  00014	e0810003	 add         r0, r1, r3

; 508  : }

  00018	e12fff1e	 bx          lr
  0001c		 |$M46652|

			 ENDP  ; |DmaGetLastWritePos|

	EXPORT	|DmaGetStatus|

  00000			 AREA	 |.pdata|, PDATA
|$T46664| DCD	|$LN5@DmaGetStat|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaGetStatus| PROC

; 559  : {

  00000		 |$LN5@DmaGetStat|
  00000		 |$M46661|

; 560  :     return INREG32(&pDataInfo->pDmaLcReg->CSR);

  00000	e5903014	 ldr         r3, [r0, #0x14]
  00004	e593000c	 ldr         r0, [r3, #0xC]

; 561  : }

  00008	e12fff1e	 bx          lr
  0000c		 |$M46662|

			 ENDP  ; |DmaGetStatus|

	EXPORT	|DmaClearStatus|

  00000			 AREA	 |.pdata|, PDATA
|$T46673| DCD	|$LN5@DmaClearSt|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaClearStatus| PROC

; 575  : {

  00000		 |$LN5@DmaClearSt|
  00000		 |$M46670|

; 576  :     OUTREG32(&pDataInfo->pDmaLcReg->CSR, dwStatus);

  00000	e5903014	 ldr         r3, [r0, #0x14]
  00004	e583100c	 str         r1, [r3, #0xC]

; 577  : }

  00008	e12fff1e	 bx          lr
  0000c		 |$M46671|

			 ENDP  ; |DmaClearStatus|

	EXPORT	|SetDeviceClockState|
	IMPORT	|EnableDeviceClocks|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\uart\pdd.c

  00000			 AREA	 |.pdata|, PDATA
|$T46683| DCD	|$LN11@SetDeviceC|
	DCD	0x40000e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetDeviceClockState| PROC

; 308  : {

  00000		 |$LN11@SetDeviceC|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46680|
  00004	e3510000	 cmp         r1, #0

; 309  : 	switch(dx)

  00008	4a000008	 bmi         |$LN1@SetDeviceC|
  0000c	e3510002	 cmp         r1, #2
  00010	da000003	 ble         |$LN3@SetDeviceC|
  00014	e3510004	 cmp         r1, #4
  00018	ca000004	 bgt         |$LN1@SetDeviceC|

; 315  : 		break;
; 316  : 	case D3:
; 317  : 	case D4:
; 318  : 		EnableDeviceClocks(pPdd->DeviceID, FALSE);

  0001c	e3a01000	 mov         r1, #0

; 319  : 		break;

  00020	ea000000	 b           |$LN8@SetDeviceC|
  00024		 |$LN3@SetDeviceC|

; 310  : 	{
; 311  : 	case D0:
; 312  : 	case D1:
; 313  : 	case D2:
; 314  : 		EnableDeviceClocks(pPdd->DeviceID, TRUE);

  00024	e3a01001	 mov         r1, #1
  00028		 |$LN8@SetDeviceC|
  00028	e5900010	 ldr         r0, [r0, #0x10]
  0002c	eb000000	 bl          EnableDeviceClocks
  00030		 |$LN1@SetDeviceC|

; 320  : 	default:
; 321  : 	break;
; 322  : 	}
; 323  : }

  00030	e49de004	 ldr         lr, [sp], #4
  00034	e12fff1e	 bx          lr
  00038		 |$M46681|

			 ENDP  ; |SetDeviceClockState|

	EXPORT	|UpdateDMARxPointer|
	IMPORT	|__rt_udiv|
	IMPORT	|memcpy|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\inc\omap_sdma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T46745| DCD	|$LN34@UpdateDMAR|
	DCD	0x40006502
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\uart\pdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UpdateDMARxPointer| PROC

; 339  : {

  00000		 |$LN34@UpdateDMAR|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M46742|
  00008	e1a0a002	 mov         r10, r2
  0000c	e1a05001	 mov         r5, r1
  00010	e1a08000	 mov         r8, r0

; 340  :     BOOL        bRet = FALSE;
; 341  :     UINT32      nStartPos = 0;
; 342  :     UINT32      nBufferSize = 0;
; 343  :     PHW_INDEP_INFO  pSerialHead = (PHW_INDEP_INFO)pPdd->pMdd;

  00014	e598e050	 ldr         lr, [r8, #0x50]

; 344  :     UINT32      nMddRxPosHead = (UINT32)RxBuffRead(pSerialHead);
; 345  :     UINT32      nMddRxPosTail = (UINT32)RxBuffWrite(pSerialHead);
; 346  :     UINT32      nRxDmaBuffer = (UINT32)pPdd->pRxDmaBuffer;
; 347  :     BOOL        bAllClear = (nMddRxPosHead == nMddRxPosTail);
; 348  :     BOOL        bConfig = FALSE;
; 349  : 
; 350  :     if(IsDmaEnable(pPdd->RxDmaInfo))

  00018	e5981124	 ldr         r1, [r8, #0x124]
  0001c	e5986114	 ldr         r6, [r8, #0x114]
  00020	e59e40ac	 ldr         r4, [lr, #0xAC]
  00024	e59e309c	 ldr         r3, [lr, #0x9C]
  00028	e59ee0a0	 ldr         lr, [lr, #0xA0]
  0002c	e3a09000	 mov         r9, #0
  00030	e0837004	 add         r7, r3, r4
  00034	e08e0004	 add         r0, lr, r4
  00038	e1570000	 cmp         r7, r0
  0003c	03a04001	 moveq       r4, #1
  00040	13a04000	 movne       r4, #0
  00044	e1b03001	 movs        r3, r1
  00048	0a000005	 beq         |$LN17@UpdateDMAR|
  0004c	e5933014	 ldr         r3, [r3, #0x14]
  00050	e5933000	 ldr         r3, [r3]
  00054	e58d3000	 str         r3, [sp]
  00058	e59d3000	 ldr         r3, [sp]
  0005c	e3130080	 tst         r3, #0x80
  00060	1a000047	 bne         |$LN3@UpdateDMAR|
  00064		 |$LN17@UpdateDMAR|

; 351  :     {
; 352  :         DEBUGMSG(TESTENABLE, (L"UpdateDMARxPointer: DMA Runing\r\n"));
; 353  :         goto cleanUp;
; 354  :     }
; 355  : 
; 356  :     // If we are purging we set the last read pos equal to the last write pos
; 357  :     if(bPurge)
; 358  :     {
; 359  :        nMddRxPosHead = nMddRxPosTail;
; 360  :        bAllClear = TRUE;
; 361  :     }
; 362  : 
; 363  :     nStartPos = (UINT32)DmaGetLastWritePos(pPdd->RxDmaInfo) + dwOffSet;

  00064	e5913014	 ldr         r3, [r1, #0x14]
  00068	e591200c	 ldr         r2, [r1, #0xC]
  0006c	e5911004	 ldr         r1, [r1, #4]
  00070	e5933038	 ldr         r3, [r3, #0x38]
  00074	e3550000	 cmp         r5, #0
  00078	11a07000	 movne       r7, r0

; 364  :     DEBUGMSG(TESTENABLE, (L"UpdateDMARxPointer: CurrentDMALocation = 0x%x"
; 365  :         L" nMddRxWIndex= 0x%x   nMddRxRIndex= 0x%x\r\n",
; 366  :         nStartPos, nMddRxPosTail, nMddRxPosHead));
; 367  : 
; 368  :     // Since we have to setup DMA to transfer multiple of frame size (or Rx Fifo's 
; 369  :     // trigger level) and we have to fill up the DMA buffer before wrap around, we 
; 370  :     // setup the DMA to fill few bytes more after the DMA buffer (yes, we did
; 371  :     // allocate that extra space, but just didn't tell MDD about that) at the end of
; 372  :     // this routine and we will have to copy the extra data to the beginning of the 
; 373  :     // DMA buffer when we are call to setup the DMA again.
; 374  :     if (nStartPos >= (nRxDmaBuffer + pPdd->RxDmaBufferSize))

  0007c	e5980110	 ldr         r0, [r8, #0x110]
  00080	e0433002	 sub         r3, r3, r2
  00084	e0813003	 add         r3, r1, r3
  00088	e083500a	 add         r5, r3, r10
  0008c	e0801006	 add         r1, r0, r6
  00090	13a04001	 movne       r4, #1
  00094	e1550001	 cmp         r5, r1
  00098	3a000007	 bcc         |$LN9@UpdateDMAR|

; 375  :     {
; 376  :         DWORD   dwCount = nStartPos - (nRxDmaBuffer + pPdd->RxDmaBufferSize);

  0009c	e0453000	 sub         r3, r5, r0
  000a0	e0535006	 subs        r5, r3, r6

; 377  :         DEBUGMSG(TESTENABLE,
; 378  :            (L"UpdateDMARxPointer: recv EndOfBlock DMA\r\n"));
; 379  :         if (dwCount > 0)
; 380  :         {
; 381  :             pPdd->bRxWrapped   = TRUE;

  000a4	13a03001	 movne       r3, #1

; 382  :             memcpy((BYTE*)nRxDmaBuffer, (BYTE*)(nRxDmaBuffer + pPdd->RxDmaBufferSize), dwCount);

  000a8	11a02005	 movne       r2, r5
  000ac	11a00006	 movne       r0, r6
  000b0	15883148	 strne       r3, [r8, #0x148]
  000b4	1b000000	 blne        memcpy

; 383  :     }
; 384  :         nStartPos = nRxDmaBuffer + dwCount;

  000b8	e0855006	 add         r5, r5, r6
  000bc		 |$LN9@UpdateDMAR|

; 385  :     }
; 386  : 
; 387  :     // check for start position if it is greater then MDD write position
; 388  :     if(/*(nStartPos >= nMddRxPosTail) && */
; 389  :         (nStartPos < (nRxDmaBuffer + pPdd->RxDmaBufferSize)) &&
; 390  :         (nStartPos > nMddRxPosHead))

  000bc	e5982110	 ldr         r2, [r8, #0x110]
  000c0	e0823006	 add         r3, r2, r6
  000c4	e1550003	 cmp         r5, r3
  000c8	2a000002	 bcs         |$LN7@UpdateDMAR|
  000cc	e1550007	 cmp         r5, r7
  000d0	9a000001	 bls         |$LN30@UpdateDMAR|

; 391  :     {
; 392  :         DEBUGMSG(TESTENABLE,
; 393  :             (L"(nStartPos < (nRxDmaBuffer + pPdd->RxDmaBufferSize))&&"
; 394  :             L"(nStartPos > nMddRxPosHead)\r\n"));
; 395  :         nStartPos = nStartPos;
; 396  :         nBufferSize = pPdd->RxDmaBufferSize - (nStartPos - nRxDmaBuffer);
; 397  :         bConfig = TRUE;
; 398  :         goto cleanUp;

  000d4	ea000007	 b           |$LN31@UpdateDMAR|
  000d8		 |$LN7@UpdateDMAR|

; 399  :     }
; 400  :     // check for start position if less then MDD read position
; 401  :     if (nStartPos < nMddRxPosHead)

  000d8	e1550007	 cmp         r5, r7
  000dc		 |$LN30@UpdateDMAR|

; 402  :     {
; 403  :         DEBUGMSG(TESTENABLE, (L"(nStartPos < nMddRxPosHead)\r\n"));
; 404  :         // adjust the buffer length to only extend to the last read
; 405  :         // position of the mdd
; 406  :         nStartPos = nStartPos;
; 407  :         nBufferSize = (nMddRxPosHead - nStartPos) -1;

  000dc	30473005	 subcc       r3, r7, r5
  000e0	32431001	 subcc       r1, r3, #1
  000e4	3a000005	 bcc         |$cleanUp$44806|

; 408  :         bConfig = TRUE;
; 409  :         goto cleanUp;
; 410  :     }
; 411  :     if((bAllClear == TRUE) && (nStartPos == nMddRxPosHead))

  000e8	e3540001	 cmp         r4, #1
  000ec	1a000024	 bne         |$LN3@UpdateDMAR|
  000f0	e1550007	 cmp         r5, r7
  000f4	1a000022	 bne         |$LN3@UpdateDMAR|
  000f8		 |$LN31@UpdateDMAR|

; 412  :     {
; 413  :         DEBUGMSG(TESTENABLE,
; 414  :             (L"(bAllClear == TRUE)&& (nMddRxPosHead = nRxDmaBuffer)\r\n"));
; 415  :         //check if it is not starting position then inc by 1
; 416  :         if(nStartPos != nRxDmaBuffer)
; 417  :             nStartPos =nStartPos;// + 1;
; 418  :         nBufferSize = pPdd->RxDmaBufferSize - (nStartPos - nRxDmaBuffer);

  000f8	e0423005	 sub         r3, r2, r5
  000fc	e0831006	 add         r1, r3, r6
  00100		 |$cleanUp$44806|

; 419  :         bConfig = TRUE;
; 420  :         goto cleanUp;
; 421  :     }
; 422  : 
; 423  : cleanUp:
; 424  :     if(bConfig)
; 425  :     {
; 426  :         if ((nBufferSize <= 0) || (nBufferSize > pPdd->RxDmaBufferSize))

  00100	e3510000	 cmp         r1, #0
  00104	0a00001d	 beq         |$LN1@UpdateDMAR|
  00108	e1510002	 cmp         r1, r2
  0010c	8a00001b	 bhi         |$LN1@UpdateDMAR|

; 430  :             }
; 431  :         RETAILMSG(0,
; 432  :             (L"nBufferSize = 0x%x  nStartPos = 0x%x\r\n",
; 433  :             nBufferSize,
; 434  :             nStartPos));
; 435  : 
; 436  :         // update registers
; 437  :         DmaSetDstBuffer(pPdd->RxDmaInfo,
; 438  :             (UINT8*)nStartPos,
; 439  :             pPdd->paRxDmaBuffer + (nStartPos - nRxDmaBuffer));

  00110	e5980124	 ldr         r0, [r8, #0x124]
  00114	e5983118	 ldr         r3, [r8, #0x118]
  00118	e5902014	 ldr         r2, [r0, #0x14]
  0011c	e0433006	 sub         r3, r3, r6
  00120	e083e005	 add         lr, r3, r5
  00124	e3520000	 cmp         r2, #0
  00128	e580e00c	 str         lr, [r0, #0xC]
  0012c	e5805004	 str         r5, [r0, #4]
  00130	1582e020	 strne       lr, [r2, #0x20]
  00134	15903014	 ldrne       r3, [r0, #0x14]
  00138	1583e038	 strne       lr, [r3, #0x38]

; 440  : 
; 441  :         // Since we have to setup DMA to transfer multiple of frame size (or Rx Fifo's 
; 442  :         // trigger level) and we have to fill up the DMA buffer before wrap around, we 
; 443  :         // will setup the DMA to fill few bytes more after the DMA buffer (yes, we did
; 444  :         // allocate that extra space, but just didn't tell MDD about that) here and we 
; 445  :         // will copy the extra data to the beginning of the DMA when we update the DMA 
; 446  :         // pointer next. See beginning of this routine.
; 447  :         nBufferSize += (pPdd->dwRxFifoTriggerLevel - 1);

  0013c	e5984154	 ldr         r4, [r8, #0x154]

; 448  :         DmaSetElementAndFrameCount(pPdd->RxDmaInfo,
; 449  :             (UINT16)pPdd->dwRxFifoTriggerLevel, 
; 450  :             ((UINT16)(nBufferSize / pPdd->dwRxFifoTriggerLevel)));

  00140	e0843001	 add         r3, r4, r1
  00144	e2431001	 sub         r1, r3, #1
  00148	e1a00004	 mov         r0, r4
  0014c	eb000000	 bl          __rt_udiv
  00150	e598e124	 ldr         lr, [r8, #0x124]
  00154	e1a02804	 mov         r2, r4, lsl #16
  00158	e1a02822	 mov         r2, r2, lsr #16
  0015c	e59e3014	 ldr         r3, [lr, #0x14]
  00160	e1a01800	 mov         r1, r0, lsl #16
  00164	e1a01821	 mov         r1, r1, lsr #16

; 451  : 
; 452  :         pPdd->pRxDMALastWrite = (VOID*)nStartPos;
; 453  : 
; 454  :         bRet = TRUE;

  00168	e5832014	 str         r2, [r3, #0x14]
  0016c	e59e3014	 ldr         r3, [lr, #0x14]
  00170	e3a09001	 mov         r9, #1
  00174	e5831018	 str         r1, [r3, #0x18]
  00178	e588514c	 str         r5, [r8, #0x14C]
  0017c	ea000000	 b           |$LN3@UpdateDMAR|
  00180		 |$LN1@UpdateDMAR|

; 427  :             {
; 428  :                 bRet = FALSE;
; 429  :                 return bRet;

  00180	e3a09000	 mov         r9, #0
  00184		 |$LN3@UpdateDMAR|

; 455  :     }
; 456  :     return bRet;
; 457  : }

  00184	e1a00009	 mov         r0, r9
  00188	e28dd004	 add         sp, sp, #4
  0018c	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00190	e12fff1e	 bx          lr
  00194		 |$M46743|

			 ENDP  ; |UpdateDMARxPointer|

; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\inc\omap_sdma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T46767| DCD	|$LN12@RxDmaStop|
	DCD	0x40001c01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\uart\pdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |RxDmaStop| PROC

; 469  : {

  00000		 |$LN12@RxDmaStop|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M46764|
  00004	e1a08001	 mov         r8, r1
  00008	e1a07000	 mov         r7, r0

; 470  :     DWORD   dwCount     = 0;
; 471  :     BYTE*   pbDataPtr   = NULL;
; 472  : 
; 473  :     DmaStop(pPdd->RxDmaInfo);

  0000c	e5970124	 ldr         r0, [r7, #0x124]
  00010	e3a06000	 mov         r6, #0
  00014	eb000000	 bl          DmaStop

; 474  : 
; 475  :     pbDataPtr = DmaGetLastWritePos(pPdd->RxDmaInfo);

  00018	e5973124	 ldr         r3, [r7, #0x124]
  0001c	e593e014	 ldr         lr, [r3, #0x14]
  00020	e593400c	 ldr         r4, [r3, #0xC]
  00024	e5935004	 ldr         r5, [r3, #4]
  00028	e59e3038	 ldr         r3, [lr, #0x38]
  0002c	e0433004	 sub         r3, r3, r4
  00030	e0850003	 add         r0, r5, r3
  00034		 |$LL3@RxDmaStop|

; 476  :     while ((dwCount < MAX_RX_SERIALDMA_FRAMESIZE) && ((INREG8(&pPdd->pUartRegs->LSR) & UART_LSR_RX_FIFO_E) != 0))

  00034	e5972024	 ldr         r2, [r7, #0x24]
  00038	e5d23014	 ldrb        r3, [r2, #0x14]
  0003c	e3130001	 tst         r3, #1
  00040	0a000004	 beq         |$LN2@RxDmaStop|

; 477  :     {
; 478  :         pbDataPtr[dwCount++] = INREG8(&pPdd->pUartRegs->RHR);

  00044	e5d23000	 ldrb        r3, [r2]
  00048	e7c03006	 strb        r3, [r0, +r6]
  0004c	e2866001	 add         r6, r6, #1
  00050	e356003f	 cmp         r6, #0x3F
  00054	3afffff6	 bcc         |$LL3@RxDmaStop|
  00058		 |$LN2@RxDmaStop|

; 479  :     }
; 480  :     
; 481  :     if (dwCount >= MAX_RX_SERIALDMA_FRAMESIZE)
; 482  :     {
; 483  :         DEBUGMSG(ZONE_ERROR, (L"+HWGetInterruptType Pulled %d bytes. Shouldn't be here!!!\r\n", dwCount));
; 484  :         //UART_RegDump(pPdd);
; 485  :     }
; 486  : 
; 487  :     return UpdateDMARxPointer(pPdd, bPurge, dwCount);

  00058	e1a02006	 mov         r2, r6
  0005c	e1a01008	 mov         r1, r8
  00060	e1a00007	 mov         r0, r7
  00064	eb000000	 bl          UpdateDMARxPointer

; 488  : }

  00068	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0006c	e12fff1e	 bx          lr
  00070		 |$M46765|

			 ENDP  ; |RxDmaStop|


  00000			 AREA	 |.pdata|, PDATA
|$T46775| DCD	|$LN5@SetDefault|
	DCD	0x40001501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetDefaultDCB| PROC

; 502  : {

  00000		 |$LN5@SetDefault|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M46772|

; 503  : 
; 504  :     // Initialize Default DCB
; 505  :     pPdd->dcb.DCBlength = sizeof(pPdd->dcb);
; 506  :     pPdd->dcb.BaudRate = 9600;
; 507  :     pPdd->dcb.fBinary = TRUE;
; 508  :     pPdd->dcb.fParity = FALSE;
; 509  :     pPdd->dcb.fOutxCtsFlow = FALSE;
; 510  :     pPdd->dcb.fOutxDsrFlow = FALSE;
; 511  :     pPdd->dcb.fDtrControl = DTR_CONTROL_ENABLE;
; 512  :     pPdd->dcb.fDsrSensitivity = FALSE;
; 513  :     pPdd->dcb.fRtsControl = RTS_CONTROL_ENABLE;

  00004	e5902060	 ldr         r2, [r0, #0x60]
  00008	e3e03a02	 mvn         r3, #2, 20
  0000c	e223306e	 eor         r3, r3, #0x6E
  00010	e3a01a01	 mov         r1, #1, 20
  00014	e0022003	 and         r2, r2, r3
  00018	e3813011	 orr         r3, r1, #0x11
  0001c	e1823003	 orr         r3, r2, r3
  00020	e3a0201c	 mov         r2, #0x1C
  00024	e3a01d96	 mov         r1, #0x96, 26

; 514  :     pPdd->dcb.ByteSize = 8;

  00028	e3a0e008	 mov         lr, #8

; 515  :     pPdd->dcb.Parity = 0;

  0002c	e3a04000	 mov         r4, #0

; 516  :     pPdd->dcb.StopBits = 1;

  00030	e3a05001	 mov         r5, #1
  00034	e5802058	 str         r2, [r0, #0x58]
  00038	e5803060	 str         r3, [r0, #0x60]
  0003c	e580105c	 str         r1, [r0, #0x5C]
  00040	e5c0e06a	 strb        lr, [r0, #0x6A]
  00044	e5c0406b	 strb        r4, [r0, #0x6B]
  00048	e5c0506c	 strb        r5, [r0, #0x6C]

; 517  : 
; 518  : }

  0004c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$M46773|

			 ENDP  ; |SetDefaultDCB|

	IMPORT	|LeaveCriticalSection|
	IMPORT	|InterlockedDecrement|
	IMPORT	|InterlockedIncrement|
	IMPORT	|EnterCriticalSection|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T46791| DCD	|$LN11@SetAutoIdl|
	DCD	0x40001d01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\uart\pdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetAutoIdle| PROC

; 532  : {

  00000		 |$LN11@SetAutoIdl|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M46788|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 533  :     OMAP_UART_REGS *pUartRegs = pPdd->pUartRegs;
; 534  : 
; 535  :     DEBUGMSG(ZONE_FUNCTION, (L"+SetAutoIdle(%d)\r\n", enable));
; 536  : 
; 537  :     EnterCriticalSection(&pPdd->hwCS);

  0000c	e5956024	 ldr         r6, [r5, #0x24]
  00010	e2850098	 add         r0, r5, #0x98
  00014	eb000000	 bl          EnterCriticalSection

; 538  : 
; 539  :     // Enable/disable hardware auto Idle
; 540  :     if (enable)

  00018	e3540000	 cmp         r4, #0
  0001c	0a000008	 beq         |$LN4@SetAutoIdl|

; 541  :     {
; 542  :         if(!pPdd->RxTxRefCount)

  00020	e5953140	 ldr         r3, [r5, #0x140]

; 543  :             {
; 544  :                 OUTREG8(
; 545  :                 &pUartRegs->SYSC,
; 546  :                 // Disable force idle, to avoid data corruption
; 547  :                 UART_SYSC_IDLE_DISABLED|UART_SYSC_WAKEUP_ENABLE
; 548  :                 );
; 549  :             }
; 550  :         pPdd->bDisableAutoIdle = FALSE;
; 551  :         InterlockedIncrement((LONG*) &pPdd->RxTxRefCount);

  00024	e2850d05	 add         r0, r5, #5, 26
  00028	e3530000	 cmp         r3, #0
  0002c	03a0300c	 moveq       r3, #0xC
  00030	05c63054	 streqb      r3, [r6, #0x54]
  00034	e3a03000	 mov         r3, #0
  00038	e5853168	 str         r3, [r5, #0x168]
  0003c	eb000000	 bl          InterlockedIncrement

; 552  :     }
; 553  :     else

  00040	ea000006	 b           |$LN7@SetAutoIdl|
  00044		 |$LN4@SetAutoIdl|

; 554  :     {
; 555  :         InterlockedDecrement((LONG*) &pPdd->RxTxRefCount);

  00044	e2850d05	 add         r0, r5, #5, 26
  00048	eb000000	 bl          InterlockedDecrement

; 556  :         if(!pPdd->RxTxRefCount) 

  0004c	e5953140	 ldr         r3, [r5, #0x140]
  00050	e3530000	 cmp         r3, #0

; 557  :             SetEvent(pPdd->hPowerEvent);

  00054	0595015c	 ldreq       r0, [r5, #0x15C]
  00058	03a01003	 moveq       r1, #3
  0005c	0b000000	 bleq        EventModify
  00060		 |$LN7@SetAutoIdl|

; 558  :     }
; 559  : 
; 560  :     LeaveCriticalSection(&pPdd->hwCS);

  00060	e2850098	 add         r0, r5, #0x98
  00064	eb000000	 bl          LeaveCriticalSection

; 561  : 
; 562  :     DEBUGMSG(ZONE_FUNCTION, (L"-SetAutoIdle()\r\n"));
; 563  :     return TRUE;

  00068	e3a00001	 mov         r0, #1

; 564  : }

  0006c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00070	e12fff1e	 bx          lr
  00074		 |$M46789|

			 ENDP  ; |SetAutoIdle|


  00000			 AREA	 |.pdata|, PDATA
|$T46805| DCD	|$LN8@SetAutoRTS|
	DCD	0x40001701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetAutoRTS| PROC

; 583  : {

  00000		 |$LN8@SetAutoRTS|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M46802|
  00004	e1a04001	 mov         r4, r1
  00008	e1a06000	 mov         r6, r0

; 584  :     OMAP_UART_REGS *pUartRegs = pPdd->pUartRegs;
; 585  :     UCHAR lcr;
; 586  : 
; 587  :     DEBUGMSG(ZONE_FUNCTION, (L"+SetAutoRTS()\r\n"));
; 588  : 
; 589  :     // Get UART lock
; 590  :     EnterCriticalSection(&pPdd->hwCS);

  0000c	e5965024	 ldr         r5, [r6, #0x24]
  00010	e2860098	 add         r0, r6, #0x98
  00014	eb000000	 bl          EnterCriticalSection

; 591  : 
; 592  :     // Save LCR value & enable EFR access
; 593  :     lcr = INREG8(&pUartRegs->LCR);

  00018	e5d5200c	 ldrb        r2, [r5, #0xC]

; 594  :     OUTREG8(&pUartRegs->LCR, UART_LCR_MODE_CONFIG_B);

  0001c	e3a030bf	 mov         r3, #0xBF
  00020	e5c5300c	 strb        r3, [r5, #0xC]

; 595  : 
; 596  :     // Enable/disable hardware auto RTS
; 597  :     if (enable)
; 598  :     {
; 599  :         SETREG8(&pUartRegs->EFR, UART_EFR_AUTO_RTS_EN);

  00024	e5d53008	 ldrb        r3, [r5, #8]
  00028	e3540000	 cmp         r4, #0

; 600  :         pPdd->autoRTS = TRUE;

  0002c	13a01001	 movne       r1, #1
  00030	13833040	 orrne       r3, r3, #0x40

; 601  :     }
; 602  :     else
; 603  :     {
; 604  :         // Disable hardware auto RTS
; 605  :         CLRREG8(&pUartRegs->EFR, UART_EFR_AUTO_RTS_EN);
; 606  :         pPdd->autoRTS = FALSE;

  00034	020330bf	 andeq       r3, r3, #0xBF
  00038	03a01000	 moveq       r1, #0
  0003c	e5c53008	 strb        r3, [r5, #8]
  00040	e586107c	 str         r1, [r6, #0x7C]

; 607  :     }
; 608  : 
; 609  :     // Restore LCR value
; 610  :     OUTREG8(&pUartRegs->LCR, lcr);
; 611  : 
; 612  :     // Free UART lock.
; 613  : 
; 614  :     LeaveCriticalSection(&pPdd->hwCS);

  00044	e2860098	 add         r0, r6, #0x98
  00048	e5c5200c	 strb        r2, [r5, #0xC]
  0004c	eb000000	 bl          LeaveCriticalSection

; 615  : 
; 616  :     DEBUGMSG(ZONE_FUNCTION, (L"-SetAutoRTS()\r\n"));
; 617  :     return TRUE;

  00050	e3a00001	 mov         r0, #1

; 618  : }

  00054	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$M46803|

			 ENDP  ; |SetAutoRTS|


  00000			 AREA	 |.pdata|, PDATA
|$T46819| DCD	|$LN8@SetAutoCTS|
	DCD	0x40001401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetAutoCTS| PROC

; 632  : {

  00000		 |$LN8@SetAutoCTS|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M46816|
  00004	e1a04001	 mov         r4, r1
  00008	e1a06000	 mov         r6, r0

; 633  :     OMAP_UART_REGS *pUartRegs = pPdd->pUartRegs;
; 634  :     UCHAR lcr;
; 635  : 
; 636  :     DEBUGMSG(ZONE_FUNCTION, (L"+SetAutoCTS()\r\n"));
; 637  : 
; 638  :     // Get UART lock
; 639  :     EnterCriticalSection(&pPdd->hwCS);

  0000c	e5965024	 ldr         r5, [r6, #0x24]
  00010	e2860098	 add         r0, r6, #0x98
  00014	eb000000	 bl          EnterCriticalSection

; 640  : 
; 641  :     // Save LCR value & enable EFR access
; 642  :     lcr = INREG8(&pUartRegs->LCR);

  00018	e5d5200c	 ldrb        r2, [r5, #0xC]

; 643  :     OUTREG8(&pUartRegs->LCR, UART_LCR_MODE_CONFIG_B);

  0001c	e3a030bf	 mov         r3, #0xBF
  00020	e5c5300c	 strb        r3, [r5, #0xC]

; 644  : 
; 645  :     // Enable/disable hardware auto CTS/RTS
; 646  :     if (enable)
; 647  :     {
; 648  :         SETREG8(&pUartRegs->EFR, UART_EFR_AUTO_CTS_EN);

  00024	e5d53008	 ldrb        r3, [r5, #8]
  00028	e3540000	 cmp         r4, #0

; 649  :     }
; 650  :     else
; 651  :     {
; 652  :         // Disable hardware auto CTS/RTS
; 653  :         CLRREG8(&pUartRegs->EFR, UART_EFR_AUTO_CTS_EN);
; 654  :     }
; 655  : 
; 656  :     // Restore LCR value
; 657  :     OUTREG8(&pUartRegs->LCR, lcr);
; 658  : 
; 659  :     // Free UART lock.
; 660  :     LeaveCriticalSection(&pPdd->hwCS);

  0002c	e2860098	 add         r0, r6, #0x98
  00030	13833080	 orrne       r3, r3, #0x80
  00034	0203307f	 andeq       r3, r3, #0x7F
  00038	e5c53008	 strb        r3, [r5, #8]
  0003c	e5c5200c	 strb        r2, [r5, #0xC]
  00040	eb000000	 bl          LeaveCriticalSection

; 661  : 
; 662  :     DEBUGMSG(ZONE_FUNCTION, (L"-SetAutoCTS()\r\n"));
; 663  :     return TRUE;

  00044	e3a00001	 mov         r0, #1

; 664  : }

  00048	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M46817|

			 ENDP  ; |SetAutoCTS|

	IMPORT	|EvaluateEventFlag|

  00000			 AREA	 |.pdata|, PDATA
|$T46832| DCD	|$LN12@ReadLineSt|
	DCD	0x40002f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ReadLineStat| PROC

; 679  : {

  00000		 |$LN12@ReadLineSt|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M46829|
  00004	e1a04000	 mov         r4, r0

; 680  :     OMAP_UART_REGS *pUartRegs = pPdd->pUartRegs;
; 681  :     ULONG events = 0;
; 682  :     UCHAR lineStat = 0;
; 683  : 
; 684  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("+ReadLineStat()\r\n")));
; 685  : 
; 686  :     if (pPdd->open == TRUE)

  00008	e5943054	 ldr         r3, [r4, #0x54]
  0000c	e5947024	 ldr         r7, [r4, #0x24]
  00010	e3a05000	 mov         r5, #0
  00014	e3530001	 cmp         r3, #1
  00018	e3a06000	 mov         r6, #0
  0001c	1a000023	 bne         |$LN1@ReadLineSt|

; 687  :     {
; 688  :         EnterCriticalSection(&pPdd->hwCS);

  00020	e2840098	 add         r0, r4, #0x98
  00024	eb000000	 bl          EnterCriticalSection

; 689  : 
; 690  :         lineStat = INREG8(&pUartRegs->LSR);

  00028	e5d76014	 ldrb        r6, [r7, #0x14]

; 691  :         if ((lineStat & UART_LSR_RX_FE) != 0)

  0002c	e3160008	 tst         r6, #8

; 692  :         {
; 693  :             pPdd->commErrors |= CE_FRAME;

  00030	15943074	 ldrne       r3, [r4, #0x74]

; 694  :             events |= EV_ERR;

  00034	13a05080	 movne       r5, #0x80
  00038	13833008	 orrne       r3, r3, #8
  0003c	15843074	 strne       r3, [r4, #0x74]

; 695  :         }
; 696  :         if ((lineStat & UART_LSR_RX_PE) != 0)

  00040	e3160004	 tst         r6, #4

; 697  :         {
; 698  :             pPdd->commErrors |= CE_RXPARITY;

  00044	15943074	 ldrne       r3, [r4, #0x74]

; 699  :             events |= EV_ERR;

  00048	13855080	 orrne       r5, r5, #0x80
  0004c	13833004	 orrne       r3, r3, #4
  00050	15843074	 strne       r3, [r4, #0x74]

; 700  :         }
; 701  :         if ((lineStat & UART_LSR_RX_OE) != 0)

  00054	e3160002	 tst         r6, #2
  00058	0a00000a	 beq         |$LN4@ReadLineSt|

; 702  :         {
; 703  :             pPdd->overrunCount++;

  0005c	e5943078	 ldr         r3, [r4, #0x78]

; 704  :             pPdd->commErrors |= CE_OVERRUN;

  00060	e5942074	 ldr         r2, [r4, #0x74]

; 705  :             events |= EV_ERR;
; 706  : 
; 707  :             // UART RX stops working after RX FIFO overrun, must clear RX FIFO and read RESUME register
; 708  :             OUTREG8(&pUartRegs->FCR, pPdd->CurrentFCR | UART_FCR_RX_FIFO_CLEAR);

  00064	e5d40089	 ldrb        r0, [r4, #0x89]
  00068	e2833001	 add         r3, r3, #1
  0006c	e5843078	 str         r3, [r4, #0x78]
  00070	e3822002	 orr         r2, r2, #2
  00074	e3803002	 orr         r3, r0, #2
  00078	e5842074	 str         r2, [r4, #0x74]
  0007c	e5c73008	 strb        r3, [r7, #8]

; 709  :             INREG8(&pUartRegs->RESUME);

  00080	e5d7302c	 ldrb        r3, [r7, #0x2C]
  00084	e3855080	 orr         r5, r5, #0x80
  00088		 |$LN4@ReadLineSt|

; 710  :         }
; 711  :         if ((lineStat & UART_LSR_RX_BI) != 0)

  00088	e3160010	 tst         r6, #0x10

; 712  :         {
; 713  :             events |= EV_BREAK;
; 714  :             pPdd->bRxBreak = TRUE;

  0008c	13a03001	 movne       r3, #1

; 715  :         }
; 716  : 
; 717  :         LeaveCriticalSection(&pPdd->hwCS);

  00090	e2840098	 add         r0, r4, #0x98
  00094	15843178	 strne       r3, [r4, #0x178]
  00098	13855040	 orrne       r5, r5, #0x40
  0009c	eb000000	 bl          LeaveCriticalSection

; 718  : 
; 719  :         if ((events & EV_ERR) != 0)
; 720  :         {
; 721  :             DEBUGMSG(ZONE_ERROR, (
; 722  :                 L"UART!ReadLineStat: Error detected, LSR: 0x%02x\r\n", lineStat
; 723  :                 ));
; 724  :         }
; 725  : 
; 726  :         // Let MDD know if something happen
; 727  :         if (events != 0) EvaluateEventFlag(pPdd->pMdd, events);

  000a0	e3550000	 cmp         r5, #0
  000a4	15940050	 ldrne       r0, [r4, #0x50]
  000a8	11a01005	 movne       r1, r5
  000ac	1b000000	 blne        EvaluateEventFlag
  000b0		 |$LN1@ReadLineSt|

; 728  :     }
; 729  : 
; 730  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("-ReadLineStat(%02x)\r\n"), lineStat));
; 731  :     return lineStat;
; 732  : }

  000b0	e1a00006	 mov         r0, r6
  000b4	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000b8	e12fff1e	 bx          lr
  000bc		 |$M46830|

			 ENDP  ; |ReadLineStat|


  00000			 AREA	 |.pdata|, PDATA
|$T46845| DCD	|$LN9@ReadModemS|
	DCD	0x40001001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ReadModemStat| PROC

; 747  : {

  00000		 |$LN9@ReadModemS|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M46842|

; 748  :     OMAP_UART_REGS *pUartRegs = pPdd->pUartRegs;

  00004	e5903024	 ldr         r3, [r0, #0x24]

; 749  :     UCHAR modemStat;
; 750  :     ULONG events;
; 751  : 
; 752  :     DEBUGMSG(ZONE_FUNCTION, (L"+ReadModemStat()\r\n"));
; 753  : 
; 754  :     // Nothing happen yet...
; 755  :     events = 0;

  00008	e3a01000	 mov         r1, #0

; 756  : 
; 757  :     // Read modem status register (it clear most bits)
; 758  :     modemStat = INREG8(&pUartRegs->MSR);

  0000c	e5d34018	 ldrb        r4, [r3, #0x18]

; 759  : 
; 760  :     // For changes, we use callback to evaluate the event
; 761  :     if ((modemStat & UART_MSR_CTS) != 0) events |= EV_CTS;

  00010	e3140001	 tst         r4, #1
  00014	13a01008	 movne       r1, #8

; 762  :     if ((modemStat & UART_MSR_DSR) != 0) events |= EV_DSR;

  00018	e3140002	 tst         r4, #2
  0001c	13811010	 orrne       r1, r1, #0x10

; 763  :     if ((modemStat & UART_MSR_DCD) != 0) events |= EV_RLSD;

  00020	e3140008	 tst         r4, #8
  00024	13811020	 orrne       r1, r1, #0x20

; 764  : 
; 765  :     // Let MDD know if something happen
; 766  :     if (events != 0) EvaluateEventFlag(pPdd->pMdd, events);

  00028	e3510000	 cmp         r1, #0
  0002c	15900050	 ldrne       r0, [r0, #0x50]
  00030	1b000000	 blne        EvaluateEventFlag

; 767  : 
; 768  :     DEBUGMSG(ZONE_FUNCTION, (L"-ReadModemStat(%02x)\r\n", modemStat));
; 769  : 
; 770  :     return modemStat;
; 771  : }

  00034	e1a00004	 mov         r0, r4
  00038	e8bd4010	 ldmia       sp!, {r4, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$M46843|

			 ENDP  ; |ReadModemStat|


  00000			 AREA	 |.pdata|, PDATA
|$T46861| DCD	|$LN13@SetBaudRat|
	DCD	0x40002c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetBaudRate| PROC

; 785  : {

  00000		 |$LN13@SetBaudRat|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M46858|
  00004	e1a02001	 mov         r2, r1
  00008	e1a04000	 mov         r4, r0

; 786  :     BOOL rc = FALSE;
; 787  :     OMAP_UART_REGS *pUartRegs = pPdd->pUartRegs;

  0000c	e5947024	 ldr         r7, [r4, #0x24]
  00010	e3a00000	 mov         r0, #0

; 788  :     USHORT divider;
; 789  :     UCHAR mdr1;
; 790  : 
; 791  :     DEBUGMSG(ZONE_FUNCTION, (L"+SetBaudRate(rate:%d,membase:0x%x)\r\n",baudRate, pPdd->memBase[0]));
; 792  : 
; 793  :     // Calculate mode and divider
; 794  :     if (baudRate < 300)

  00014	e3520f4b	 cmp         r2, #0x4B, 30
  00018	3a000022	 bcc         |$cleanUp$44960|

; 795  :     {
; 796  :         goto cleanUp;
; 797  :     }
; 798  :     else if  (baudRate <= 230400 || baudRate == 3000000)

  0001c	e3520be1	 cmp         r2, #0xE1, 22
  00020	9a000009	 bls         |$LN4@SetBaudRat|
  00024	e3a039b7	 mov         r3, #0xB7, 18
  00028	e3833d1b	 orr         r3, r3, #0x1B, 26
  0002c	e1520003	 cmp         r2, r3
  00030	0a000005	 beq         |$LN4@SetBaudRat|

; 802  :     }
; 803  :     else if (baudRate <= 3686400)

  00034	e35209e1	 cmp         r2, #0xE1, 18
  00038	8a00001a	 bhi         |$cleanUp$44960|

; 804  :     {
; 805  :         mdr1 = UART_MDR1_UART13;
; 806  :         divider = (USHORT)(pPdd->frequency/(baudRate * 13));

  0003c	e0823082	 add         r3, r2, r2, lsl #1
  00040	e0820103	 add         r0, r2, r3, lsl #2
  00044	e3a06003	 mov         r6, #3

; 807  :     }
; 808  :     else

  00048	ea000001	 b           |$LN10@SetBaudRat|
  0004c		 |$LN4@SetBaudRat|

; 799  :     {
; 800  :         mdr1 = UART_MDR1_UART16;
; 801  :         divider = (USHORT)(pPdd->frequency/(baudRate * 16));

  0004c	e1a00202	 mov         r0, r2, lsl #4
  00050	e3a06000	 mov         r6, #0
  00054		 |$LN10@SetBaudRat|
  00054	e594104c	 ldr         r1, [r4, #0x4C]
  00058	eb000000	 bl          __rt_udiv
  0005c	e1a05800	 mov         r5, r0, lsl #16

; 809  :     {
; 810  :         goto cleanUp;
; 811  :     }
; 812  : 
; 813  :     // Get UART lock
; 814  :     EnterCriticalSection(&pPdd->hwCS);

  00060	e2840098	 add         r0, r4, #0x98
  00064	e1a05825	 mov         r5, r5, lsr #16
  00068	eb000000	 bl          EnterCriticalSection

; 815  : 
; 816  : 
; 817  :     // Disable UART
; 818  :     OUTREG8(&pUartRegs->MDR1, UART_MDR1_DISABLE);

  0006c	e3a03007	 mov         r3, #7
  00070	e5c73020	 strb        r3, [r7, #0x20]

; 819  : 
; 820  :     // Set new divisor
; 821  :     SETREG8(&pUartRegs->LCR, UART_LCR_DIV_EN);

  00074	e5d7300c	 ldrb        r3, [r7, #0xC]

; 822  :     OUTREG8(&pUartRegs->DLL, (UCHAR)(divider >> 0));
; 823  :     OUTREG8(&pUartRegs->DLH, (UCHAR)(divider >> 8));

  00078	e1a02425	 mov         r2, r5, lsr #8

; 824  :     CLRREG8(&pUartRegs->LCR, UART_LCR_DIV_EN);
; 825  :     // Enable UART
; 826  :     OUTREG8(&pUartRegs->MDR1, mdr1);
; 827  : 
; 828  :     // Free UART lock
; 829  : 
; 830  :     LeaveCriticalSection(&pPdd->hwCS);

  0007c	e2840098	 add         r0, r4, #0x98
  00080	e3833080	 orr         r3, r3, #0x80
  00084	e5c7300c	 strb        r3, [r7, #0xC]
  00088	e5c75000	 strb        r5, [r7]
  0008c	e5c72004	 strb        r2, [r7, #4]
  00090	e5d7300c	 ldrb        r3, [r7, #0xC]
  00094	e203307f	 and         r3, r3, #0x7F
  00098	e5c7300c	 strb        r3, [r7, #0xC]
  0009c	e5c76020	 strb        r6, [r7, #0x20]
  000a0	eb000000	 bl          LeaveCriticalSection

; 831  : 
; 832  :     rc = TRUE;

  000a4	e3a00001	 mov         r0, #1
  000a8		 |$cleanUp$44960|

; 833  : 
; 834  : cleanUp:
; 835  :     DEBUGMSG(ZONE_FUNCTION, (L"-SetBaudRate()=%d\r\n",rc));
; 836  :     return rc;
; 837  : }

  000a8	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000ac	e12fff1e	 bx          lr
  000b0		 |$M46859|

			 ENDP  ; |SetBaudRate|


  00000			 AREA	 |.pdata|, PDATA
|$T46875| DCD	|$LN7@SetWordLen|
	DCD	0x40001501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetWordLength| PROC

; 851  : {

  00000		 |$LN7@SetWordLen|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M46872|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 852  :     BOOL rc = FALSE;
; 853  :     OMAP_UART_REGS *pUartRegs = pPdd->pUartRegs;

  0000c	e5956024	 ldr         r6, [r5, #0x24]
  00010	e3a00000	 mov         r0, #0

; 854  :     UCHAR lineCtrl;
; 855  : 
; 856  :     DEBUGMSG(ZONE_FUNCTION, (L"+SetWordLength(%d)\r\n",wordLength));
; 857  : 
; 858  :     if ((wordLength < 5) || (wordLength > 8)) goto cleanUp;

  00014	e3540005	 cmp         r4, #5
  00018	3a00000b	 bcc         |$cleanUp$44998|
  0001c	e3540008	 cmp         r4, #8
  00020	8a000009	 bhi         |$cleanUp$44998|

; 859  : 
; 860  :     EnterCriticalSection(&pPdd->hwCS);

  00024	e2850098	 add         r0, r5, #0x98
  00028	eb000000	 bl          EnterCriticalSection

; 861  : 
; 862  :     lineCtrl = INREG8(&pUartRegs->LCR);

  0002c	e5d6300c	 ldrb        r3, [r6, #0xC]

; 863  :     lineCtrl = (lineCtrl & ~0x03)|(wordLength - 5);

  00030	e28420fb	 add         r2, r4, #0xFB

; 864  :     OUTREG8(&pUartRegs->LCR, lineCtrl);
; 865  : 
; 866  :     LeaveCriticalSection(&pPdd->hwCS);

  00034	e2850098	 add         r0, r5, #0x98
  00038	e20330fc	 and         r3, r3, #0xFC
  0003c	e1833002	 orr         r3, r3, r2
  00040	e5c6300c	 strb        r3, [r6, #0xC]
  00044	eb000000	 bl          LeaveCriticalSection

; 867  : 
; 868  :     rc = TRUE;

  00048	e3a00001	 mov         r0, #1
  0004c		 |$cleanUp$44998|

; 869  : 
; 870  : cleanUp:
; 871  :     DEBUGMSG(ZONE_FUNCTION, (L"-SetWordLength()=%d\r\n",rc));
; 872  :     return rc;
; 873  : }

  0004c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$M46873|

			 ENDP  ; |SetWordLength|


  00000			 AREA	 |.pdata|, PDATA
|$T46890| DCD	|$LN13@SetParity|
	DCD	0x40002201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetParity| PROC

; 887  : {

  00000		 |$LN13@SetParity|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M46887|
  00004	e1a05000	 mov         r5, r0

; 888  :     BOOL rc = FALSE;
; 889  :     OMAP_UART_REGS *pUartRegs = pPdd->pUartRegs;

  00008	e5956024	 ldr         r6, [r5, #0x24]
  0000c	e3a00000	 mov         r0, #0

; 890  :     UCHAR lineCtrl;
; 891  :     UCHAR mask;
; 892  : 
; 893  :     DEBUGMSG(ZONE_FUNCTION, (L"+SetParity(%d)\r\n",parity));
; 894  : 
; 895  :     switch (parity)

  00010	e1b03001	 movs        r3, r1
  00014	0a00000f	 beq         |$LN6@SetParity|
  00018	e3530001	 cmp         r3, #1
  0001c	0a00000b	 beq         |$LN5@SetParity|
  00020	e3530002	 cmp         r3, #2
  00024	0a000007	 beq         |$LN4@SetParity|
  00028	e3530003	 cmp         r3, #3
  0002c	0a000003	 beq         |$LN3@SetParity|
  00030	e3530004	 cmp         r3, #4
  00034	1a000011	 bne         |$cleanUp$45024|

; 909  :     case SPACEPARITY:
; 910  :         mask = UART_LCR_PARITY_EN | (3 << 4);

  00038	e3a04038	 mov         r4, #0x38

; 911  :         break;

  0003c	ea000006	 b           |$LN7@SetParity|
  00040		 |$LN3@SetParity|

; 906  :     case MARKPARITY:
; 907  :         mask = UART_LCR_PARITY_EN | (2 << 4);

  00040	e3a04028	 mov         r4, #0x28

; 908  :         break;

  00044	ea000004	 b           |$LN7@SetParity|
  00048		 |$LN4@SetParity|

; 903  :     case EVENPARITY:
; 904  :         mask = UART_LCR_PARITY_EN | (1 << 4);

  00048	e3a04018	 mov         r4, #0x18

; 905  :         break;

  0004c	ea000002	 b           |$LN7@SetParity|
  00050		 |$LN5@SetParity|

; 899  :         break;
; 900  :     case ODDPARITY:
; 901  :         mask = UART_LCR_PARITY_EN | (0 << 4);

  00050	e3a04008	 mov         r4, #8

; 902  :         break;

  00054	ea000000	 b           |$LN7@SetParity|
  00058		 |$LN6@SetParity|

; 896  :     {
; 897  :     case NOPARITY:
; 898  :         mask = 0;

  00058	e3a04000	 mov         r4, #0
  0005c		 |$LN7@SetParity|

; 912  :     default:
; 913  :         goto cleanUp;
; 914  :     }
; 915  : 
; 916  :     EnterCriticalSection(&pPdd->hwCS);

  0005c	e2850098	 add         r0, r5, #0x98
  00060	eb000000	 bl          EnterCriticalSection

; 917  : 
; 918  :     lineCtrl = INREG8(&pUartRegs->LCR);

  00064	e5d6300c	 ldrb        r3, [r6, #0xC]

; 919  :     lineCtrl &= ~(UART_LCR_PARITY_EN);
; 920  :     lineCtrl &= ~(UART_LCR_PARITY_TYPE_1|UART_LCR_PARITY_TYPE_2);
; 921  :     lineCtrl |= mask;
; 922  :     OUTREG8(&pUartRegs->LCR, lineCtrl);
; 923  : 
; 924  :     LeaveCriticalSection(&pPdd->hwCS);

  00068	e2850098	 add         r0, r5, #0x98
  0006c	e20330c7	 and         r3, r3, #0xC7
  00070	e1833004	 orr         r3, r3, r4
  00074	e5c6300c	 strb        r3, [r6, #0xC]
  00078	eb000000	 bl          LeaveCriticalSection

; 925  : 
; 926  :     rc = TRUE;

  0007c	e3a00001	 mov         r0, #1
  00080		 |$cleanUp$45024|

; 927  : 
; 928  : cleanUp:
; 929  :     DEBUGMSG(ZONE_FUNCTION, (L"-SetParity()=%d\r\n",rc));
; 930  :     return rc;
; 931  : }

  00080	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00084	e12fff1e	 bx          lr
  00088		 |$M46888|

			 ENDP  ; |SetParity|


  00000			 AREA	 |.pdata|, PDATA
|$T46905| DCD	|$LN10@SetStopBit|
	DCD	0x40001701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetStopBits| PROC

; 945  : {

  00000		 |$LN10@SetStopBit|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M46902|
  00004	e1a05000	 mov         r5, r0

; 946  :     BOOL rc = FALSE;
; 947  :     OMAP_UART_REGS *pUartRegs = pPdd->pUartRegs;

  00008	e5956024	 ldr         r6, [r5, #0x24]
  0000c	e3a00000	 mov         r0, #0

; 948  :     UCHAR lineCtrl;
; 949  :     UCHAR mask;
; 950  : 
; 951  :     DEBUGMSG(ZONE_FUNCTION, (L"+SetStopBits(%d)\r\n",stopBits));
; 952  : 
; 953  :     switch (stopBits)

  00010	e1b03001	 movs        r3, r1
  00014	0a000004	 beq         |$LN3@SetStopBit|
  00018	e2433001	 sub         r3, r3, #1
  0001c	e3530001	 cmp         r3, #1
  00020	8a00000b	 bhi         |$cleanUp$45047|

; 957  :         break;
; 958  :     case ONE5STOPBITS:
; 959  :     case TWOSTOPBITS:
; 960  :         mask = UART_LCR_NB_STOP;

  00024	e3a04004	 mov         r4, #4

; 961  :         break;

  00028	ea000000	 b           |$LN4@SetStopBit|
  0002c		 |$LN3@SetStopBit|

; 954  :     {
; 955  :     case ONESTOPBIT:
; 956  :         mask = 0;

  0002c	e3a04000	 mov         r4, #0
  00030		 |$LN4@SetStopBit|

; 962  :     default:
; 963  :         goto cleanUp;
; 964  :     }
; 965  : 
; 966  :     EnterCriticalSection(&pPdd->hwCS);

  00030	e2850098	 add         r0, r5, #0x98
  00034	eb000000	 bl          EnterCriticalSection

; 967  : 
; 968  :     lineCtrl = INREG8(&pUartRegs->LCR);

  00038	e5d6300c	 ldrb        r3, [r6, #0xC]

; 969  :     lineCtrl = (lineCtrl & ~UART_LCR_NB_STOP)|mask;
; 970  :     OUTREG8(&pUartRegs->LCR, lineCtrl);
; 971  : 
; 972  :     LeaveCriticalSection(&pPdd->hwCS);

  0003c	e2850098	 add         r0, r5, #0x98
  00040	e20330fb	 and         r3, r3, #0xFB
  00044	e1833004	 orr         r3, r3, r4
  00048	e5c6300c	 strb        r3, [r6, #0xC]
  0004c	eb000000	 bl          LeaveCriticalSection

; 973  : 
; 974  :     rc = TRUE;

  00050	e3a00001	 mov         r0, #1
  00054		 |$cleanUp$45047|

; 975  : 
; 976  : cleanUp:
; 977  :     DEBUGMSG(ZONE_FUNCTION, (L"-SetStopBits()=%d\r\n",rc));
; 978  :     return rc;
; 979  : }

  00054	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$M46903|

			 ENDP  ; |SetStopBits|

	EXPORT	|SetPower|
	IMPORT	|SetDevicePowerState|
	IMPORT	|WaitForSingleObject|
	IMPORT	|Sleep|
	IMPORT	|GPIOSetBit|
	IMPORT	|GPIOClrBit|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\inc\omap_sdma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T46953| DCD	|$LN47@SetPower|
	DCD	0x4000a101
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\uart\pdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetPower| PROC

; 992  : {

  00000		 |$LN47@SetPower|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M46950|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 993  :     BOOL rc = FALSE;
; 994  :     int nTimeout = 1000;
; 995  :    
; 996  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("UART:SetPower: D%d (curDx=D%d)\r\n"), dx, pPdd->currentDX));
; 997  : 
; 998  :     EnterCriticalSection(&pPdd->powerCS);

  0000c	e2840038	 add         r0, r4, #0x38
  00010	e3a06000	 mov         r6, #0
  00014	e3a07ffa	 mov         r7, #0xFA, 30
  00018	eb000000	 bl          EnterCriticalSection

; 999  : 	
; 1000 :     // Device can't be set to lower power state than external
; 1001 :     if (dx < pPdd->externalDX) 

  0001c	e5943034	 ldr         r3, [r4, #0x34]
  00020	e1550003	 cmp         r5, r3

; 1002 :         dx = pPdd->externalDX;

  00024	b1a05003	 movlt       r5, r3

; 1003 : 
; 1004 :     // Update state only when it is different from actual
; 1005 :     if (pPdd->currentDX != dx)

  00028	e5943030	 ldr         r3, [r4, #0x30]
  0002c	e1530005	 cmp         r3, r5
  00030	0a00008e	 beq         |$LN25@SetPower|

; 1006 :     {
; 1007 :         if (pPdd->currentDX <= D2 && dx >= D3)

  00034	e3530002	 cmp         r3, #2
  00038	ca000057	 bgt         |$LN24@SetPower|
  0003c	e3550003	 cmp         r5, #3
  00040	ba000055	 blt         |$LN24@SetPower|

; 1008 :         {
; 1009 :             // going from D0/D1/D2 to D3/D4
; 1010 :             
; 1011 :             // turn off transceiver
; 1012 :             if (pPdd->hGpio != NULL)

  00044	e594316c	 ldr         r3, [r4, #0x16C]
  00048	e1b00003	 movs        r0, r3
  0004c	0a00000e	 beq         |$LN18@SetPower|

; 1013 :             {   
; 1014 :                 // turn off xcvr while UART is still in D0/D1/D2 state because xcvr state
; 1015 :                 // change can generate interrupts that need to be handled.
; 1016 :                 if (pPdd->XcvrEnabledLevel)

  00050	e5943174	 ldr         r3, [r4, #0x174]

; 1017 :                     GPIOClrBit(pPdd->hGpio, pPdd->XcvrEnableGpio);

  00054	e5941170	 ldr         r1, [r4, #0x170]
  00058	e3530000	 cmp         r3, #0
  0005c	0a000001	 beq         |$LN22@SetPower|
  00060	eb000000	 bl          GPIOClrBit

; 1018 :                 else

  00064	ea000000	 b           |$LN21@SetPower|
  00068		 |$LN22@SetPower|

; 1019 :                     GPIOSetBit(pPdd->hGpio, pPdd->XcvrEnableGpio);

  00068	eb000000	 bl          GPIOSetBit
  0006c		 |$LN21@SetPower|

; 1020 :                 // Delay to allow time for any interrupt processing due to change in xcvr state
; 1021 :                 Sleep(25);

  0006c	e3a00019	 mov         r0, #0x19
  00070	eb000000	 bl          Sleep

; 1022 :             }
; 1023 : 
; 1024 :             while((INREG8(&pPdd->pUartRegs->LSR) & UART_LSR_RX_FIFO_E) != 0) 

  00074	ea000004	 b           |$LN18@SetPower|
  00078		 |$LL20@SetPower|

; 1025 :             {
; 1026 :                 if(--nTimeout == 0) 

  00078	e2577001	 subs        r7, r7, #1

; 1027 :                 {
; 1028 :                     // Timedout so just empty the fifo
; 1029 :                     OUTREG8(&pPdd->pUartRegs->FCR, pPdd->CurrentFCR | UART_FCR_RX_FIFO_CLEAR);

  0007c	05d43089	 ldreqb      r3, [r4, #0x89]
  00080	05942024	 ldreq       r2, [r4, #0x24]
  00084	03833002	 orreq       r3, r3, #2
  00088	05c23008	 streqb      r3, [r2, #8]
  0008c		 |$LN18@SetPower|
  0008c	e5943024	 ldr         r3, [r4, #0x24]
  00090	e5d33014	 ldrb        r3, [r3, #0x14]
  00094	e3130001	 tst         r3, #1
  00098	1afffff6	 bne         |$LL20@SetPower|

; 1030 :                 }
; 1031 :             }
; 1032 : 
; 1033 :             //set event on power thread and put uart into force Idle
; 1034 : 
; 1035 :             if ( pPdd->RxTxRefCount )

  0009c	e5943140	 ldr         r3, [r4, #0x140]
  000a0	e3a08000	 mov         r8, #0

; 1036 :                 pPdd->RxTxRefCount = 0;
; 1037 : 
; 1038 :             pPdd->bDisableAutoIdle = TRUE;
; 1039 : 
; 1040 :             // Update current power state before triggering the power thread because
; 1041 :             // the power thread will set the UART's idle mode according to the 
; 1042 :             // current DX
; 1043 :             // We changed power state
; 1044 :             pPdd->currentDX = dx;
; 1045 : 
; 1046 :             if (pPdd->hPowerThread != NULL)

  000a4	e3a02001	 mov         r2, #1
  000a8	e3530000	 cmp         r3, #0
  000ac	e5943160	 ldr         r3, [r4, #0x160]
  000b0	15848140	 strne       r8, [r4, #0x140]
  000b4	e5842168	 str         r2, [r4, #0x168]
  000b8	e3530000	 cmp         r3, #0
  000bc	e5845030	 str         r5, [r4, #0x30]
  000c0	0a000011	 beq         |$LN16@SetPower|

; 1047 :             {
; 1048 :                 DWORD   dwCount = 0;
; 1049 : 
; 1050 :                 SetEvent(pPdd->hPowerEvent);

  000c4	e594015c	 ldr         r0, [r4, #0x15C]
  000c8	e3a01003	 mov         r1, #3
  000cc	e3a06000	 mov         r6, #0
  000d0	eb000000	 bl          EventModify
  000d4	e3a03c01	 mov         r3, #1, 24
  000d8	e3837002	 orr         r7, r3, #2
  000dc		 |$LL15@SetPower|

; 1051 : 
; 1052 :                 // Under some condition, the power thread wouldn't run until few
; 1053 :                 // hundreds of ms after the event is set in which case the we ended
; 1054 :                 // up turning off the UART before the power thread access the UART 
; 1055 :                 // registers and causing the power thread to crash. To avoid the problem,
; 1056 :                 // we wait until the power thread actually woke up from the event.
; 1057 :                 do
; 1058 :                 {
; 1059 :                     Sleep(5);

  000dc	e3a00005	 mov         r0, #5
  000e0	eb000000	 bl          Sleep

; 1060 :                 } while ((WaitForSingleObject(pPdd->hPowerEvent, 1) != WAIT_TIMEOUT) && (dwCount++ < 1000));

  000e4	e594015c	 ldr         r0, [r4, #0x15C]
  000e8	e3a01001	 mov         r1, #1
  000ec	eb000000	 bl          WaitForSingleObject
  000f0	e1500007	 cmp         r0, r7
  000f4	0a000002	 beq         |$LN12@SetPower|
  000f8	e3560ffa	 cmp         r6, #0xFA, 30
  000fc	e2866001	 add         r6, r6, #1
  00100	3afffff5	 bcc         |$LL15@SetPower|
  00104		 |$LN12@SetPower|

; 1061 : 
; 1062 :                 // Now the power woke up from the event, but we still need to give it
; 1063 :                 // a chance to set the UART idle mode before we can turn off the power
; 1064 :                 // to the UART module, otherwise we will generate exception in the 
; 1065 :                 // power thread.
; 1066 :                 Sleep(10);

  00104	e3a0000a	 mov         r0, #0xA
  00108	eb000000	 bl          Sleep
  0010c		 |$LN16@SetPower|

; 1067 :             }
; 1068 : 
; 1069 :             if (pPdd->bDmaInitialize == TRUE)

  0010c	e5943150	 ldr         r3, [r4, #0x150]
  00110	e3530001	 cmp         r3, #1
  00114	1a000016	 bne         |$LN34@SetPower|

; 1070 :             {
; 1071 :                 DEBUGMSG(ZONE_FUNCTION, (TEXT("UART:SetPower: stop DMA\r\n")));
; 1072 :                 RxDmaStop(pPdd, FALSE);

  00118	e5940124	 ldr         r0, [r4, #0x124]
  0011c	e3a06000	 mov         r6, #0
  00120	eb000000	 bl          DmaStop
  00124	e5943124	 ldr         r3, [r4, #0x124]
  00128	e5931014	 ldr         r1, [r3, #0x14]
  0012c	e593000c	 ldr         r0, [r3, #0xC]
  00130	e593e004	 ldr         lr, [r3, #4]
  00134	e5913038	 ldr         r3, [r1, #0x38]
  00138	e0433000	 sub         r3, r3, r0
  0013c	e08e1003	 add         r1, lr, r3
  00140		 |$LL33@SetPower|
  00140	e5942024	 ldr         r2, [r4, #0x24]
  00144	e5d23014	 ldrb        r3, [r2, #0x14]
  00148	e3130001	 tst         r3, #1
  0014c	0a000004	 beq         |$LN32@SetPower|
  00150	e5d23000	 ldrb        r3, [r2]
  00154	e7c13006	 strb        r3, [r1, +r6]
  00158	e2866001	 add         r6, r6, #1
  0015c	e356003f	 cmp         r6, #0x3F
  00160	3afffff6	 bcc         |$LL33@SetPower|
  00164		 |$LN32@SetPower|
  00164	e1a02006	 mov         r2, r6
  00168	e3a01000	 mov         r1, #0
  0016c	e1a00004	 mov         r0, r4
  00170	eb000000	 bl          UpdateDMARxPointer
  00174		 |$LN34@SetPower|

; 1073 :             }
; 1074 : 
; 1075 :             // If we are going to shut down the power (or clock?), we need to disable all 
; 1076 :             // interrupt before we do so otherwise the interrupt will keep kicking if there
; 1077 :             // is a pending interrupt because we wouldn't be able to mask the interrupt once
; 1078 :             // we turn off the power (or clock?).
; 1079 :             pPdd->savedIntrMask = pPdd->intrMask;
; 1080 :             pPdd->intrMask = 0;
; 1081 :             OUTREG8(&pPdd->pUartRegs->IER, pPdd->intrMask);

  00174	e5d43088	 ldrb        r3, [r4, #0x88]
  00178	e5942024	 ldr         r2, [r4, #0x24]
  0017c	e5c48088	 strb        r8, [r4, #0x88]
  00180	e5c4317c	 strb        r3, [r4, #0x17C]
  00184	e5c28004	 strb        r8, [r2, #4]

; 1082 : 
; 1083 :                 SetDevicePowerState(pPdd->hParentBus, dx, NULL);

  00188	e594002c	 ldr         r0, [r4, #0x2C]
  0018c	e3a02000	 mov         r2, #0
  00190	e1a01005	 mov         r1, r5
  00194	eb000000	 bl          SetDevicePowerState
  00198	ea000033	 b           |$LN1@SetPower|
  0019c		 |$LN24@SetPower|

; 1084 : 				
; 1085 :         }
; 1086 :         else if (pPdd->currentDX >= D3 && dx <= D2)

  0019c	e3530003	 cmp         r3, #3
  001a0	ba00002c	 blt         |$LN9@SetPower|
  001a4	e3550002	 cmp         r5, #2
  001a8	ca00002a	 bgt         |$LN9@SetPower|

; 1087 :         {
; 1088 :             // going from D3/D4 to D0/D1/D2
; 1089 :             /* force it to D0 so that we can program the registers and restore context */
; 1090 : 			/* once that is done, set the power state to requested level */
; 1091 :             SetDevicePowerState(pPdd->hParentBus, D0, NULL);

  001ac	e594002c	 ldr         r0, [r4, #0x2C]
  001b0	e3a02000	 mov         r2, #0
  001b4	e3a01000	 mov         r1, #0
  001b8	eb000000	 bl          SetDevicePowerState

; 1092 : 
; 1093 :             pPdd->intrMask = pPdd->savedIntrMask;
; 1094 :             OUTREG8(&pPdd->pUartRegs->IER, pPdd->intrMask);

  001bc	e5d4317c	 ldrb        r3, [r4, #0x17C]
  001c0	e5942024	 ldr         r2, [r4, #0x24]
  001c4	e5c43088	 strb        r3, [r4, #0x88]
  001c8	e5c23004	 strb        r3, [r2, #4]

; 1095 : 
; 1096 : 			/* dont know why we need the check dx != currentDX */
; 1097 :             if ((dx != pPdd->currentDX) && (pPdd->bDmaInitialize == TRUE))

  001cc	e5943030	 ldr         r3, [r4, #0x30]
  001d0	e1550003	 cmp         r5, r3
  001d4	0a00000e	 beq         |$LN38@SetPower|
  001d8	e5943150	 ldr         r3, [r4, #0x150]
  001dc	e3530001	 cmp         r3, #1
  001e0	1a00000b	 bne         |$LN38@SetPower|

; 1098 :             {
; 1099 :                 DEBUGMSG(ZONE_FUNCTION, (L"UART:SetPower: Starting DMA\r\n"));
; 1100 :                 UpdateDMARxPointer(pPdd, FALSE, 0);

  001e4	e3a02000	 mov         r2, #0
  001e8	e3a01000	 mov         r1, #0
  001ec	e1a00004	 mov         r0, r4
  001f0	eb000000	 bl          UpdateDMARxPointer

; 1101 : 
; 1102 :                 SetAutoIdle(pPdd, TRUE);

  001f4	e3a01001	 mov         r1, #1
  001f8	e1a00004	 mov         r0, r4
  001fc	eb000000	 bl          SetAutoIdle

; 1103 :                 DmaStart(pPdd->RxDmaInfo);

  00200	e5943124	 ldr         r3, [r4, #0x124]
  00204	e5932014	 ldr         r2, [r3, #0x14]
  00208	e5923000	 ldr         r3, [r2]
  0020c	e3833080	 orr         r3, r3, #0x80
  00210	e5823000	 str         r3, [r2]
  00214		 |$LN38@SetPower|

; 1104 :             }
; 1105 : 			if (dx != D0)

  00214	e3550000	 cmp         r5, #0

; 1106 : 				SetDevicePowerState(pPdd->hParentBus, dx, NULL);

  00218	1594002c	 ldrne       r0, [r4, #0x2C]
  0021c	13a02000	 movne       r2, #0
  00220	11a01005	 movne       r1, r5
  00224	1b000000	 blne        SetDevicePowerState

; 1107 : 
; 1108 :             pPdd->currentDX = dx;
; 1109 : 
; 1110 :             if (pPdd->hGpio != NULL)

  00228	e594316c	 ldr         r3, [r4, #0x16C]
  0022c	e5845030	 str         r5, [r4, #0x30]
  00230	e1b00003	 movs        r0, r3
  00234	0a00000c	 beq         |$LN1@SetPower|

; 1111 :             {   
; 1112 :                 // Xcvr is off, power it on
; 1113 :                 if (pPdd->XcvrEnabledLevel)

  00238	e5943174	 ldr         r3, [r4, #0x174]

; 1114 :                     GPIOSetBit(pPdd->hGpio, pPdd->XcvrEnableGpio);

  0023c	e5941170	 ldr         r1, [r4, #0x170]
  00240	e3530000	 cmp         r3, #0
  00244	0a000001	 beq         |$LN5@SetPower|
  00248	eb000000	 bl          GPIOSetBit

; 1115 :                 else

  0024c	ea000006	 b           |$LN1@SetPower|
  00250		 |$LN5@SetPower|

; 1116 :                     GPIOClrBit(pPdd->hGpio, pPdd->XcvrEnableGpio);

  00250	eb000000	 bl          GPIOClrBit

; 1117 :             }

  00254	ea000004	 b           |$LN1@SetPower|
  00258		 |$LN9@SetPower|

; 1118 :         }
; 1119 :         else if (pPdd->currentDX > dx)
; 1120 :         {
; 1121 :             // going from D4 to D3, D2 to D1, D1 to D0
; 1122 :             SetDevicePowerState(pPdd->hParentBus, dx, NULL);

  00258	e594002c	 ldr         r0, [r4, #0x2C]
  0025c	e3a02000	 mov         r2, #0
  00260	e1a01005	 mov         r1, r5

; 1123 :             pPdd->currentDX = dx;
; 1124 :         }
; 1125 :         else
; 1126 :         {
; 1127 :             // going from D3 to D4, D0 to D1, D1 to D2
; 1128 :             SetDevicePowerState(pPdd->hParentBus, dx, NULL);

  00264	eb000000	 bl          SetDevicePowerState

; 1129 :             pPdd->currentDX = dx;

  00268	e5845030	 str         r5, [r4, #0x30]
  0026c		 |$LN1@SetPower|

; 1130 :         }
; 1131 :         
; 1132 :         rc = TRUE;

  0026c	e3a06001	 mov         r6, #1
  00270		 |$LN25@SetPower|

; 1133 :     }
; 1134 : 
; 1135 :     //RETAILMSG(1,(L"UART: -SetPower Device Power state D%d\r\n", pPdd->currentDX));
; 1136 :     LeaveCriticalSection(&pPdd->powerCS);

  00270	e2840038	 add         r0, r4, #0x38
  00274	eb000000	 bl          LeaveCriticalSection

; 1137 :     return rc;
; 1138 : }

  00278	e1a00006	 mov         r0, r6
  0027c	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00280	e12fff1e	 bx          lr
  00284		 |$M46951|

			 ENDP  ; |SetPower|

	EXPORT	|GetSerialObject|
	IMPORT	|malloc|

  00000			 AREA	 |.pdata|, PDATA
|$T46963| DCD	|$LN6@GetSerialO|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetSerialObject| PROC

; 1152 : {

  00000		 |$LN6@GetSerialO|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46960|

; 1153 :     PHWOBJ pHWObj;
; 1154 : 
; 1155 :     UNREFERENCED_PARAMETER(index);
; 1156 :     DEBUGMSG(ZONE_FUNCTION, (L"+GetSerialObject(%d)\r\n", index));
; 1157 : 
; 1158 :     // Allocate space for the HWOBJ.
; 1159 :     pHWObj = malloc(sizeof(HWOBJ));

  00004	e3a0000c	 mov         r0, #0xC
  00008	eb000000	 bl          malloc
  0000c	e3500000	 cmp         r0, #0

; 1160 :     if (pHWObj == NULL) goto cleanUp;
; 1161 : 
; 1162 :     // Fill in the HWObj structure
; 1163 :     pHWObj->BindFlags = THREAD_AT_OPEN;
; 1164 :     pHWObj->dwIntID = 0;
; 1165 :     pHWObj->pFuncTbl = &g_pddVTbl;

  00010	159f3018	 ldrne       r3, [pc, #0x18]
  00014	13a02002	 movne       r2, #2
  00018	13a01000	 movne       r1, #0
  0001c	15803008	 strne       r3, [r0, #8]
  00020	15802000	 strne       r2, [r0]
  00024	15801004	 strne       r1, [r0, #4]
  00028		 |$cleanUp$45114|

; 1166 : 
; 1167 : cleanUp:
; 1168 :     DEBUGMSG(ZONE_FUNCTION, (L"-GetSerialObject()=0x%x\r\n", pHWObj));
; 1169 :     return pHWObj;
; 1170 : }

  00028	e49de004	 ldr         lr, [sp], #4
  0002c	e12fff1e	 bx          lr
  00030		 |$LN7@GetSerialO|
  00030		 |$LN8@GetSerialO|
  00030	00000000	 DCD         |g_pddVTbl|
  00034		 |$M46961|

			 ENDP  ; |GetSerialObject|

	EXPORT	|IST_RxDMA|
	IMPORT	|DmaInterruptDone|
	IMPORT	|DmaEnableInterrupts|
	IMPORT	|CeSetThreadPriority|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T47020| DCD	|$LN44@IST_RxDMA|
	DCD	0x40005902
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\uart\pdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |IST_RxDMA| PROC

; 1179 : {

  00000		 |$LN44@IST_RxDMA|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M47017|
  00008	e1a05000	 mov         r5, r0

; 1180 :     UINT32 status;
; 1181 :     UARTPDD *pPdd = (UARTPDD *)pParam;
; 1182 : 
; 1183 :     //SetProcPermissions(0xFFFFFFFF);
; 1184 :     CeSetThreadPriority(GetCurrentThread(), 100);

  0000c	e3a01064	 mov         r1, #0x64
  00010	e3a00041	 mov         r0, #0x41
  00014	eb000000	 bl          CeSetThreadPriority

; 1185 : 
; 1186 :     // register dma for interrupts
; 1187 :     if (DmaEnableInterrupts(pPdd->hRxDmaChannel, pPdd->hEventRxIstDma) == FALSE)

  00018	e5951128	 ldr         r1, [r5, #0x128]
  0001c	e595012c	 ldr         r0, [r5, #0x12C]
  00020	eb000000	 bl          DmaEnableInterrupts
  00024	e3500000	 cmp         r0, #0
  00028	0a000049	 beq         |$cleanUp$45125|
  0002c	e3a06001	 mov         r6, #1
  00030		 |$LL14@IST_RxDMA|

; 1188 :     {
; 1189 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: IST_RxDMA: "
; 1190 :             L"Failed to enable DMA RX interrupt\r\n"
; 1191 :             ));
; 1192 :         goto cleanUp;
; 1193 :     }
; 1194 :     for(;;)
; 1195 :     {
; 1196 :         if (WaitForSingleObject(pPdd->hEventRxIstDma, INFINITE) == WAIT_OBJECT_0)

  00030	e5950128	 ldr         r0, [r5, #0x128]
  00034	e3e01000	 mvn         r1, #0
  00038	eb000000	 bl          WaitForSingleObject
  0003c	e3500000	 cmp         r0, #0
  00040	1afffffa	 bne         |$LL14@IST_RxDMA|

; 1197 :         {
; 1198 :             // Check if this thread is to shutdown
; 1199 :             if (pPdd->bExitThread == TRUE) goto cleanUp;

  00044	e5953138	 ldr         r3, [r5, #0x138]
  00048	e3530001	 cmp         r3, #1
  0004c	0a000040	 beq         |$cleanUp$45125|

; 1200 :             // get cause of wake-up
; 1201 :             status = DmaGetStatus(pPdd->RxDmaInfo);

  00050	e5953124	 ldr         r3, [r5, #0x124]
  00054	e5932014	 ldr         r2, [r3, #0x14]
  00058	e592300c	 ldr         r3, [r2, #0xC]
  0005c	e1b04003	 movs        r4, r3

; 1202 :             if (status != 0)

  00060	0afffff2	 beq         |$LL14@IST_RxDMA|

; 1203 :             {
; 1204 :                 if (status & (DMA_CICR_BLOCK_IE | DMA_CICR_FRAME_IE))

  00064	e3140028	 tst         r4, #0x28
  00068	0afffff0	 beq         |$LL14@IST_RxDMA|

; 1205 :                 {
; 1206 :                     // clear dma interrupts
; 1207 :                     DmaClearStatus(pPdd->RxDmaInfo, status);

  0006c	e582400c	 str         r4, [r2, #0xC]

; 1208 :                     if (DmaInterruptDone(pPdd->hRxDmaChannel) == FALSE)

  00070	e595012c	 ldr         r0, [r5, #0x12C]
  00074	eb000000	 bl          DmaInterruptDone
  00078	e3500000	 cmp         r0, #0
  0007c	0a000034	 beq         |$cleanUp$45125|

; 1209 :                     {
; 1210 :                         DEBUGMSG(ZONE_ERROR, (L"ERROR: IST_RxDMA: "
; 1211 :                             L"Failed to Signal DMA RX interrupt completion\r\n"
; 1212 :                             ));
; 1213 :                         goto cleanUp;
; 1214 :                     }
; 1215 : 
; 1216 :                     if ((status & (DMA_CICR_BLOCK_IE | DMA_CICR_FRAME_IE)) == 0)
; 1217 :                     {
; 1218 :                         continue;
; 1219 :                     }
; 1220 : 
; 1221 :                     EnterCriticalSection(&pPdd->RxUpdatePtrCS);

  00080	e28500c0	 add         r0, r5, #0xC0
  00084	eb000000	 bl          EnterCriticalSection

; 1222 : 
; 1223 :                     if (status & DMA_CICR_BLOCK_IE )

  00088	e3140020	 tst         r4, #0x20
  0008c	0a00001c	 beq         |$LN6@IST_RxDMA|

; 1224 :                     {
; 1225 :                         SetAutoIdle(pPdd, FALSE);

  00090	e3a01000	 mov         r1, #0
  00094	e1a00005	 mov         r0, r5
  00098	eb000000	 bl          SetAutoIdle

; 1226 : 
; 1227 :                         if (IsDmaEnable(pPdd->RxDmaInfo))

  0009c	e5950124	 ldr         r0, [r5, #0x124]
  000a0	e1b03000	 movs        r3, r0
  000a4	15933014	 ldrne       r3, [r3, #0x14]
  000a8	15933000	 ldrne       r3, [r3]
  000ac	158d3000	 strne       r3, [sp]
  000b0	159d3000	 ldrne       r3, [sp]
  000b4	13130080	 tstne       r3, #0x80

; 1228 :                         {
; 1229 :                             DEBUGMSG(ZONE_FUNCTION, (L"IST_RxDMA: Got End of block Int stopping DMA\r\n"));
; 1230 :                             DmaStop(pPdd->RxDmaInfo);

  000b8	1b000000	 blne        DmaStop

; 1231 :                         }
; 1232 : 
; 1233 :                         if((UpdateDMARxPointer(pPdd, FALSE, 0) == TRUE) && (pPdd->open == TRUE))

  000bc	e3a02000	 mov         r2, #0
  000c0	e3a01000	 mov         r1, #0
  000c4	e1a00005	 mov         r0, r5
  000c8	eb000000	 bl          UpdateDMARxPointer
  000cc	e3500001	 cmp         r0, #1
  000d0	1a000017	 bne         |$LN1@IST_RxDMA|
  000d4	e5953054	 ldr         r3, [r5, #0x54]
  000d8	e3530001	 cmp         r3, #1
  000dc	1a000014	 bne         |$LN1@IST_RxDMA|

; 1234 :                         {
; 1235 :                             SetAutoIdle(pPdd, TRUE);

  000e0	e3a01001	 mov         r1, #1
  000e4	e1a00005	 mov         r0, r5
  000e8	eb000000	 bl          SetAutoIdle

; 1236 :                             DmaStart(pPdd->RxDmaInfo);

  000ec	e5953124	 ldr         r3, [r5, #0x124]
  000f0	e5932014	 ldr         r2, [r3, #0x14]
  000f4	e5923000	 ldr         r3, [r2]
  000f8	e3833080	 orr         r3, r3, #0x80
  000fc	e5823000	 str         r3, [r2]

; 1237 :                             DEBUGMSG(TESTENABLE, (L"IST_RxDMA: End of block DMA Start\r\n"));
; 1238 :                         }
; 1239 :                         else
; 1240 :                         {
; 1241 :                             DEBUGMSG(ZONE_ERROR, (L"Error: IST_RxDMA: Shouldn't get to here!!!\r\n"));
; 1242 :                         }
; 1243 :                     }
; 1244 :                     else

  00100	ea00000b	 b           |$LN1@IST_RxDMA|
  00104		 |$LN6@IST_RxDMA|

; 1245 :                     {
; 1246 :                         DWORD   dwLastDMAWrite = (DWORD)DmaGetLastWritePos(pPdd->RxDmaInfo);

  00104	e5952124	 ldr         r2, [r5, #0x124]

; 1247 : 
; 1248 :                         if (dwLastDMAWrite < ((DWORD)pPdd->pRxDmaBuffer + pPdd->RxDmaBufferSize))

  00108	e5954114	 ldr         r4, [r5, #0x114]
  0010c	e595e110	 ldr         lr, [r5, #0x110]
  00110	e5923014	 ldr         r3, [r2, #0x14]
  00114	e592100c	 ldr         r1, [r2, #0xC]
  00118	e5920004	 ldr         r0, [r2, #4]
  0011c	e5933038	 ldr         r3, [r3, #0x38]
  00120	e084200e	 add         r2, r4, lr
  00124	e0433001	 sub         r3, r3, r1
  00128	e0803003	 add         r3, r0, r3
  0012c	e1530002	 cmp         r3, r2

; 1249 :                         {
; 1250 :                             pPdd->pRxDMALastWrite = (VOID*)dwLastDMAWrite;

  00130	3585314c	 strcc       r3, [r5, #0x14C]
  00134		 |$LN1@IST_RxDMA|

; 1251 :                         }
; 1252 :                     }
; 1253 : 
; 1254 :                     pPdd->bRxDMASignaled = 1;
; 1255 :                     SetEvent( ((PHW_INDEP_INFO)pPdd->pMdd)->hSerialEvent);

  00134	e5953050	 ldr         r3, [r5, #0x50]
  00138	e5856144	 str         r6, [r5, #0x144]
  0013c	e3a01003	 mov         r1, #3
  00140	e5930030	 ldr         r0, [r3, #0x30]
  00144	eb000000	 bl          EventModify

; 1256 : 
; 1257 :                     LeaveCriticalSection(&pPdd->RxUpdatePtrCS);

  00148	e28500c0	 add         r0, r5, #0xC0
  0014c	eb000000	 bl          LeaveCriticalSection

; 1258 :                 }
; 1259 :             }
; 1260 :         }
; 1261 :     }

  00150	eaffffb6	 b           |$LL14@IST_RxDMA|
  00154		 |$cleanUp$45125|

; 1262 : 
; 1263 : cleanUp:
; 1264 :     DEBUGMSG(ZONE_FUNCTION, (L"-IST_RXDMA:\r\n"));
; 1265 :     return 1;

  00154	e3a00001	 mov         r0, #1

; 1266 : }

  00158	e28dd004	 add         sp, sp, #4
  0015c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00160	e12fff1e	 bx          lr
  00164		 |$M47018|

			 ENDP  ; |IST_RxDMA|


  00000			 AREA	 |.pdata|, PDATA
|$T47031| DCD	|$LN15@Initialize|
	DCD	0x40004b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |InitializeUART| PROC

; 1275 : {

  00000		 |$LN15@Initialize|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47028|

; 1276 :     OMAP_UART_REGS *pUartRegs = pPdd->pUartRegs;

  00004	e5901024	 ldr         r1, [r0, #0x24]

; 1277 : 
; 1278 :     // Reset UART & wait until it completes
; 1279 :     OUTREG8(&pUartRegs->SYSC, UART_SYSC_RST);

  00008	e3a03002	 mov         r3, #2
  0000c	e5c13054	 strb        r3, [r1, #0x54]
  00010		 |$LL8@Initialize|

; 1280 :     while ((INREG8(&pUartRegs->SYSS) & UART_SYSS_RST_DONE) == 0);

  00010	e5d13058	 ldrb        r3, [r1, #0x58]
  00014	e3130001	 tst         r3, #1
  00018	0afffffc	 beq         |$LL8@Initialize|

; 1281 : 
; 1282 :     // Enable wakeup
; 1283 :     // REG: turning off Auto Idle and turning on Smart Idle
; 1284 :     OUTREG8(
; 1285 :     &pUartRegs->SYSC,
; 1286 :     // Try turn on force idle, smart idle or turn on no idle
; 1287 :     // Lets configure force idle here we will change this in HWopen.
; 1288 :     UART_SYSC_IDLE_FORCE|UART_SYSC_WAKEUP_ENABLE|UART_SYSC_AUTOIDLE
; 1289 :     );

  0001c	e3a03005	 mov         r3, #5
  00020	e5c13054	 strb        r3, [r1, #0x54]

; 1290 : 
; 1291 :     // Ensure baud rate generator is off
; 1292 :     OUTREG8(&pUartRegs->LCR, UART_LCR_DLAB);

  00024	e3a03080	 mov         r3, #0x80

; 1293 :     OUTREG8(&pUartRegs->DLL, 0);

  00028	e3a04000	 mov         r4, #0
  0002c	e5c1300c	 strb        r3, [r1, #0xC]
  00030	e5c14000	 strb        r4, [r1]

; 1294 :     OUTREG8(&pUartRegs->DLH, 0);

  00034	e5c14004	 strb        r4, [r1, #4]

; 1295 : 
; 1296 :     // Select UART mode
; 1297 :     OUTREG8(&pUartRegs->MDR1, UART_MDR1_UART16);
; 1298 : 
; 1299 : 
; 1300 :     // Line control: configuration mode B
; 1301 :     OUTREG8(&pUartRegs->LCR, UART_LCR_MODE_CONFIG_B);

  00038	e3a050bf	 mov         r5, #0xBF
  0003c	e5c14020	 strb        r4, [r1, #0x20]
  00040	e5c1500c	 strb        r5, [r1, #0xC]

; 1302 :     // Enable access to IER bits 4-7, FCR bits 4-5 and MCR bits 5-7
; 1303 :     SETREG8(&pUartRegs->EFR, UART_EFR_ENHANCED_EN);

  00044	e5d13008	 ldrb        r3, [r1, #8]

; 1304 : 
; 1305 :     // Line control: operational mode
; 1306 :     OUTREG8(&pUartRegs->LCR, UART_LCR_MODE_OPERATIONAL);
; 1307 : 
; 1308 :     // Enable sleep mode
; 1309 :     // Do not enable sleep mode hardware flow control will have problem
; 1310 :    // OUTREG8(&pUartRegs->IER, UART_IER_SLEEP_MODE);
; 1311 : 
; 1312 :     // Enable access to TCR and TLR
; 1313 :     SETREG8(&pUartRegs->MCR, UART_MCR_TCR_TLR);
; 1314 :     // Start receive when 32 bytes in FIFO, halt when 60 byte in FIFO
; 1315 :     OUTREG8(
; 1316 :         &pUartRegs->TCR,
; 1317 :         UART_TCR_RX_FIFO_TRIG_START_24|UART_TCR_RX_FIFO_TRIG_HALT_40
; 1318 :         );

  00048	e3a0206a	 mov         r2, #0x6A
  0004c	e3833010	 orr         r3, r3, #0x10
  00050	e5c13008	 strb        r3, [r1, #8]
  00054	e5c1400c	 strb        r4, [r1, #0xC]
  00058	e5d13010	 ldrb        r3, [r1, #0x10]
  0005c	e3833040	 orr         r3, r3, #0x40
  00060	e5c13010	 strb        r3, [r1, #0x10]
  00064	e5c12018	 strb        r2, [r1, #0x18]

; 1319 : 
; 1320 :     // This will create a space of 60 bytes in the FIFO for TX
; 1321 :     // Later we set FCR[4:5] so that the space is 63 bytes
; 1322 :     // we adjusted the TX DMA frame size to be 63 so we don't overrun our fifo
; 1323 :     if(pPdd->RxDmaInfo)

  00068	e5903124	 ldr         r3, [r0, #0x124]

; 1324 :     {
; 1325 :         // if RxDMA is enabled, set up the MSBs of RX_FIFO_TRIG according
; 1326 :         // to the value in pPdd->dwRxFifoTriggerLevel
; 1327 :         BYTE    bRxTrigDMA = (BYTE)((pPdd->dwRxFifoTriggerLevel >> 2) << 4);
; 1328 : 
; 1329 :         OUTREG8(&pUartRegs->TLR, UART_TLR_TX_FIFO_TRIG_DMA_0 | bRxTrigDMA);
; 1330 :     }
; 1331 :     else
; 1332 :     {
; 1333 :         OUTREG8(&pUartRegs->TLR, UART_TLR_TX_FIFO_TRIG_DMA_0);
; 1334 :     }
; 1335 : 
; 1336 :     // Disable access to TCR and TLR
; 1337 :     CLRREG8(&pUartRegs->MCR, UART_MCR_TCR_TLR);
; 1338 : 
; 1339 :     pPdd->CurrentSCR = UART_SCR_TX_TRIG_GRANU1 | UART_SCR_RX_TRIG_GRANU1;

  0006c	e3a020c0	 mov         r2, #0xC0
  00070	e3530000	 cmp         r3, #0
  00074	15903154	 ldrne       r3, [r0, #0x154]
  00078	120330fc	 andne       r3, r3, #0xFC
  0007c	11a03103	 movne       r3, r3, lsl #2
  00080	15c1301c	 strneb      r3, [r1, #0x1C]
  00084	05c1401c	 streqb      r4, [r1, #0x1C]
  00088	e5d13010	 ldrb        r3, [r1, #0x10]
  0008c	e20330bf	 and         r3, r3, #0xBF
  00090	e5c13010	 strb        r3, [r1, #0x10]

; 1340 :     pPdd->CurrentFCR = 0;
; 1341 : 
; 1342 :     if(pPdd->RxDmaInfo || pPdd->TxDmaInfo)

  00094	e5903124	 ldr         r3, [r0, #0x124]
  00098	e5c0208a	 strb        r2, [r0, #0x8A]
  0009c	e5c04089	 strb        r4, [r0, #0x89]
  000a0	e3530000	 cmp         r3, #0
  000a4	1a000002	 bne         |$LN3@Initialize|
  000a8	e5903100	 ldr         r3, [r0, #0x100]
  000ac	e3530000	 cmp         r3, #0
  000b0	0a000003	 beq         |$LN4@Initialize|
  000b4		 |$LN3@Initialize|

; 1343 :     {
; 1344 :         //pPdd->CurrentSCR |= UART_SCR_DMA_MODE_CTL;
; 1345 :         pPdd->CurrentSCR |=
; 1346 :                             UART_SCR_DMA_MODE_CTL |
; 1347 :                             UART_SCR_DMA_MODE_2_MODE1 |
; 1348 :                             UART_SCR_TX_EMPTY_CTL;

  000b4	e3a030cb	 mov         r3, #0xCB

; 1349 :         pPdd->CurrentFCR |= UART_FCR_DMA_MODE;

  000b8	e3a02008	 mov         r2, #8
  000bc	e5c0308a	 strb        r3, [r0, #0x8A]
  000c0	e5c02089	 strb        r2, [r0, #0x89]
  000c4		 |$LN4@Initialize|

; 1350 :     }
; 1351 : 
; 1352 :     OUTREG8(&pPdd->pUartRegs->SCR, pPdd->CurrentSCR);

  000c4	e5902024	 ldr         r2, [r0, #0x24]
  000c8	e5d0308a	 ldrb        r3, [r0, #0x8A]

; 1353 : 
; 1354 :     pPdd->intrMask = UART_IER_RHR;

  000cc	e3a0e001	 mov         lr, #1
  000d0	e5c23040	 strb        r3, [r2, #0x40]

; 1355 :     pPdd->CurrentFCR |= 
; 1356 :                         UART_FCR_TX_FIFO_LSB_1 |
; 1357 :                         UART_FCR_FIFO_EN;

  000d4	e5d03089	 ldrb        r3, [r0, #0x89]

; 1358 :     if (pPdd->RxDmaInfo == NULL)

  000d8	e5902124	 ldr         r2, [r0, #0x124]
  000dc	e5c0e088	 strb        lr, [r0, #0x88]
  000e0	e383e011	 orr         lr, r3, #0x11
  000e4	e3520000	 cmp         r2, #0

; 1359 :     {
; 1360 :         pPdd->CurrentFCR |= UART_FCR_RX_FIFO_LSB_1;

  000e8	038e3040	 orreq       r3, lr, #0x40

; 1361 :     }
; 1362 :     else
; 1363 :     {
; 1364 :         // if RxDMA is enabled, set up the LSBs of RX_FIFO_TRG according
; 1365 :         // to the value in pPdd->dwRxFifoTriggerLevel
; 1366 :         pPdd->CurrentFCR |= ((pPdd->dwRxFifoTriggerLevel & 0x03) << 6);

  000ec	15903154	 ldrne       r3, [r0, #0x154]
  000f0	e5c0e089	 strb        lr, [r0, #0x89]
  000f4	118e3303	 orrne       r3, lr, r3, lsl #6
  000f8	e5c03089	 strb        r3, [r0, #0x89]

; 1367 :     }
; 1368 : 
; 1369 : 
; 1370 :     OUTREG8(&pUartRegs->FCR, pPdd->CurrentFCR);

  000fc	e20330ff	 and         r3, r3, #0xFF
  00100	e5c13008	 strb        r3, [r1, #8]

; 1371 : 
; 1372 :     // Line control: configuration mode B
; 1373 :     OUTREG8(&pUartRegs->LCR, UART_LCR_MODE_CONFIG_B);

  00104	e5c1500c	 strb        r5, [r1, #0xC]

; 1374 :     // Disable access to IER bits 4-7, FCR bits 4-5 and MCR bits 5-7
; 1375 :     CLRREG8(&pUartRegs->EFR, UART_EFR_ENHANCED_EN);

  00108	e5d13008	 ldrb        r3, [r1, #8]
  0010c	e20330ef	 and         r3, r3, #0xEF
  00110	e5c13008	 strb        r3, [r1, #8]

; 1376 :     // Line control: operational mode
; 1377 :     OUTREG8(&pUartRegs->LCR, UART_LCR_MODE_OPERATIONAL);

  00114	e5c1400c	 strb        r4, [r1, #0xC]

; 1378 : 
; 1379 :     // Set default LCR 8 bits, 1 stop, no parity
; 1380 :     SETREG8(&pUartRegs->LCR, UART_LCR_CHAR_LENGTH_8BIT);

  00118	e5d1300c	 ldrb        r3, [r1, #0xC]
  0011c	e3833003	 orr         r3, r3, #3
  00120	e5c1300c	 strb        r3, [r1, #0xC]

; 1381 : }

  00124	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00128	e12fff1e	 bx          lr
  0012c		 |$M47029|

			 ENDP  ; |InitializeUART|

	IMPORT	|TxDmaSettings|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\inc\omap_sdma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T47059| DCD	|$LN11@Initialize@2|
	DCD	0x40001f01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\uart\pdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |InitializeTxDMA| PROC

; 1390 : {

  00000		 |$LN11@Initialize@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M47056|
  00004	e1a04000	 mov         r4, r0

; 1391 :     BOOL rc = TRUE;
; 1392 : 
; 1393 :     // Tx DMA configuration settings
; 1394 :     DmaConfigure (pPdd->hTxDmaChannel,
; 1395 :         &TxDmaSettings, pPdd->TxDmaRequest, pPdd->TxDmaInfo);

  00008	e5943100	 ldr         r3, [r4, #0x100]
  0000c	e59420f0	 ldr         r2, [r4, #0xF0]
  00010	e59f1060	 ldr         r1, [pc, #0x60]
  00014	e5940104	 ldr         r0, [r4, #0x104]
  00018	eb000000	 bl          DmaConfigure

; 1396 : 
; 1397 :     DmaSetSrcBuffer (pPdd->TxDmaInfo,
; 1398 :         pPdd->pTxDmaBuffer,
; 1399 :         pPdd->paTxDmaBuffer);

  0001c	e5940100	 ldr         r0, [r4, #0x100]
  00020	e59410fc	 ldr         r1, [r4, #0xFC]
  00024	e59430f8	 ldr         r3, [r4, #0xF8]
  00028	e5902014	 ldr         r2, [r0, #0x14]
  0002c	e5801008	 str         r1, [r0, #8]
  00030	e5803000	 str         r3, [r0]
  00034	e3520000	 cmp         r2, #0
  00038	1582101c	 strne       r1, [r2, #0x1C]
  0003c	15903014	 ldrne       r3, [r0, #0x14]

; 1400 : 
; 1401 :     DmaSetDstBuffer(pPdd->TxDmaInfo,
; 1402 :         (UINT8 *)&(pPdd->pUartRegs->THR),
; 1403 :         pPdd->memBase[0] + offset(OMAP_UART_REGS, THR));
; 1404 : 
; 1405 :     return rc;

  00040	e3a00001	 mov         r0, #1
  00044	15831034	 strne       r1, [r3, #0x34]
  00048	e5941100	 ldr         r1, [r4, #0x100]
  0004c	e594e000	 ldr         lr, [r4]
  00050	e5943024	 ldr         r3, [r4, #0x24]
  00054	e5912014	 ldr         r2, [r1, #0x14]
  00058	e581e00c	 str         lr, [r1, #0xC]
  0005c	e5813004	 str         r3, [r1, #4]
  00060	e3520000	 cmp         r2, #0
  00064	1582e020	 strne       lr, [r2, #0x20]
  00068	15913014	 ldrne       r3, [r1, #0x14]
  0006c	1583e038	 strne       lr, [r3, #0x38]

; 1406 : }

  00070	e8bd4010	 ldmia       sp!, {r4, lr}
  00074	e12fff1e	 bx          lr
  00078		 |$LN12@Initialize@2|
  00078		 |$LN13@Initialize@2|
  00078	00000000	 DCD         |TxDmaSettings|
  0007c		 |$M47057|

			 ENDP  ; |InitializeTxDMA|

	IMPORT	|RxDmaSettings|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\inc\omap_sdma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T47098| DCD	|$LN13@Initialize@3|
	DCD	0x40003201
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\uart\pdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |InitializeRxDMA| PROC

; 1415 : {

  00000		 |$LN13@Initialize@3|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47095|
  00004	e1a05000	 mov         r5, r0

; 1416 :     OMAP_DMA_LC_REGS *pDmaLcReg;
; 1417 : 
; 1418 :     DmaConfigure (pPdd->hRxDmaChannel,
; 1419 :         &RxDmaSettings, pPdd->RxDmaRequest, pPdd->RxDmaInfo);

  00008	e5953124	 ldr         r3, [r5, #0x124]
  0000c	e595210c	 ldr         r2, [r5, #0x10C]
  00010	e59f10ac	 ldr         r1, [pc, #0xAC]
  00014	e595012c	 ldr         r0, [r5, #0x12C]
  00018	eb000000	 bl          DmaConfigure

; 1420 : 
; 1421 :     pDmaLcReg = (OMAP_DMA_LC_REGS*)DmaGetLogicalChannel(pPdd->hRxDmaChannel);

  0001c	e595012c	 ldr         r0, [r5, #0x12C]
  00020	eb000000	 bl          DmaGetLogicalChannel

; 1422 :     OUTREG32(&pDmaLcReg->CDAC, pPdd->paRxDmaBuffer);

  00024	e5953118	 ldr         r3, [r5, #0x118]
  00028	e5803038	 str         r3, [r0, #0x38]

; 1423 : 
; 1424 :     // set up for Rx buffer as single frame with Max DMA buffer. Must be multiple of
; 1425 :     // frame size
; 1426 :     DmaSetElementAndFrameCount (pPdd->RxDmaInfo,
; 1427 :         (UINT16)pPdd->dwRxFifoTriggerLevel, 
; 1428 :         (UINT16)((pPdd->RxDmaBufferSize + pPdd->dwRxFifoTriggerLevel - 1) / pPdd->dwRxFifoTriggerLevel));

  0002c	e5954154	 ldr         r4, [r5, #0x154]
  00030	e5953110	 ldr         r3, [r5, #0x110]
  00034	e1a00004	 mov         r0, r4
  00038	e0843003	 add         r3, r4, r3
  0003c	e2431001	 sub         r1, r3, #1
  00040	eb000000	 bl          __rt_udiv
  00044	e595e124	 ldr         lr, [r5, #0x124]
  00048	e1a02804	 mov         r2, r4, lsl #16
  0004c	e1a02822	 mov         r2, r2, lsr #16
  00050	e59e3014	 ldr         r3, [lr, #0x14]
  00054	e1a01800	 mov         r1, r0, lsl #16
  00058	e1a01821	 mov         r1, r1, lsr #16
  0005c	e5832014	 str         r2, [r3, #0x14]
  00060	e59e3014	 ldr         r3, [lr, #0x14]
  00064	e5831018	 str         r1, [r3, #0x18]

; 1429 :     DmaSetDstBuffer (pPdd->RxDmaInfo,
; 1430 :         pPdd->pRxDmaBuffer,
; 1431 :         pPdd->paRxDmaBuffer);

  00068	e5950124	 ldr         r0, [r5, #0x124]
  0006c	e5951118	 ldr         r1, [r5, #0x118]
  00070	e5953114	 ldr         r3, [r5, #0x114]
  00074	e5902014	 ldr         r2, [r0, #0x14]
  00078	e580100c	 str         r1, [r0, #0xC]
  0007c	e5803004	 str         r3, [r0, #4]
  00080	e3520000	 cmp         r2, #0
  00084	15821020	 strne       r1, [r2, #0x20]
  00088	15903014	 ldrne       r3, [r0, #0x14]
  0008c	15831038	 strne       r1, [r3, #0x38]

; 1432 :     DmaSetSrcBuffer(pPdd->RxDmaInfo,
; 1433 :         (UINT8 *)&(pPdd->pUartRegs->RHR),
; 1434 :         pPdd->memBase[0] + offset(OMAP_UART_REGS, RHR));

  00090	e5951124	 ldr         r1, [r5, #0x124]
  00094	e5950000	 ldr         r0, [r5]
  00098	e5953024	 ldr         r3, [r5, #0x24]
  0009c	e5912014	 ldr         r2, [r1, #0x14]
  000a0	e5810008	 str         r0, [r1, #8]
  000a4	e5813000	 str         r3, [r1]
  000a8	e3520000	 cmp         r2, #0
  000ac	1582001c	 strne       r0, [r2, #0x1C]
  000b0	15913014	 ldrne       r3, [r1, #0x14]
  000b4	15830034	 strne       r0, [r3, #0x34]

; 1435 : 
; 1436 :     return TRUE;

  000b8	e3a00001	 mov         r0, #1

; 1437 : }

  000bc	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000c0	e12fff1e	 bx          lr
  000c4		 |$LN14@Initialize@3|
  000c4		 |$LN15@Initialize@3|
  000c4	00000000	 DCD         |RxDmaSettings|
  000c8		 |$M47096|

			 ENDP  ; |InitializeRxDMA|


  00000			 AREA	 |.pdata|, PDATA
|$T47181| DCD	|$LN56@SetDCB|
	DCD	0x40008001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetDCB| PROC

; 1446 : {

  00000		 |$LN56@SetDCB|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M47178|
  00004	e1a04002	 mov         r4, r2
  00008	e1a06001	 mov         r6, r1
  0000c	e1a05000	 mov         r5, r0

; 1447 :     BOOL    bRC = FALSE;
; 1448 : 
; 1449 :     // If the device is open, scan for changes and do whatever
; 1450 :     // is needed for the changed fields.  if the device isn't
; 1451 :     // open yet, just save the DCB for later use by the open.
; 1452 : 
; 1453 :     if (pPdd->open)

  00010	e5953054	 ldr         r3, [r5, #0x54]
  00014	e3a08000	 mov         r8, #0
  00018	e3530000	 cmp         r3, #0
  0001c	0a000074	 beq         |$cleanUp$45250|

; 1454 :     {
; 1455 :         if ((force == TRUE) || (pDCB->BaudRate != pPdd->dcb.BaudRate))

  00020	e3540001	 cmp         r4, #1
  00024	0a000003	 beq         |$LN20@SetDCB|
  00028	e596e004	 ldr         lr, [r6, #4]
  0002c	e595305c	 ldr         r3, [r5, #0x5C]
  00030	e15e0003	 cmp         lr, r3
  00034	0a000004	 beq         |$LN19@SetDCB|
  00038		 |$LN20@SetDCB|

; 1456 :         {
; 1457 :             if (!SetBaudRate(pPdd, pDCB->BaudRate)) goto cleanUp;

  00038	e5961004	 ldr         r1, [r6, #4]
  0003c	e1a00005	 mov         r0, r5
  00040	eb000000	 bl          SetBaudRate
  00044	e3500000	 cmp         r0, #0
  00048	0a000069	 beq         |$cleanUp$45250|
  0004c		 |$LN19@SetDCB|

; 1458 :         }
; 1459 : 
; 1460 :         if ((force == TRUE) || (pDCB->ByteSize != pPdd->dcb.ByteSize))

  0004c	e3540001	 cmp         r4, #1
  00050	0a000003	 beq         |$LN17@SetDCB|
  00054	e5d5206a	 ldrb        r2, [r5, #0x6A]
  00058	e5d63012	 ldrb        r3, [r6, #0x12]
  0005c	e1530002	 cmp         r3, r2
  00060	0a00000e	 beq         |$cleanUp$47112|
  00064		 |$LN17@SetDCB|

; 1461 :         {
; 1462 :             if (!SetWordLength(pPdd, pDCB->ByteSize)) goto cleanUp;

  00064	e5d67012	 ldrb        r7, [r6, #0x12]
  00068	e5959024	 ldr         r9, [r5, #0x24]
  0006c	e3570005	 cmp         r7, #5
  00070	3a00005f	 bcc         |$cleanUp$45250|
  00074	e3570008	 cmp         r7, #8
  00078	8a00005d	 bhi         |$cleanUp$45250|
  0007c	e2850098	 add         r0, r5, #0x98
  00080	eb000000	 bl          EnterCriticalSection
  00084	e5d9300c	 ldrb        r3, [r9, #0xC]
  00088	e28720fb	 add         r2, r7, #0xFB
  0008c	e2850098	 add         r0, r5, #0x98
  00090	e20330fc	 and         r3, r3, #0xFC
  00094	e1833002	 orr         r3, r3, r2
  00098	e5c9300c	 strb        r3, [r9, #0xC]
  0009c	eb000000	 bl          LeaveCriticalSection
  000a0		 |$cleanUp$47112|

; 1463 :         }
; 1464 : 
; 1465 :         if ((force == TRUE) || (pDCB->Parity != pPdd->dcb.Parity))

  000a0	e3540001	 cmp         r4, #1
  000a4	0a000003	 beq         |$LN14@SetDCB|
  000a8	e5d5206b	 ldrb        r2, [r5, #0x6B]
  000ac	e5d63013	 ldrb        r3, [r6, #0x13]
  000b0	e1530002	 cmp         r3, r2
  000b4	0a000004	 beq         |$LN13@SetDCB|
  000b8		 |$LN14@SetDCB|

; 1466 :         {
; 1467 :             if (!SetParity(pPdd, pDCB->Parity)) goto cleanUp;

  000b8	e5d61013	 ldrb        r1, [r6, #0x13]
  000bc	e1a00005	 mov         r0, r5
  000c0	eb000000	 bl          SetParity
  000c4	e3500000	 cmp         r0, #0
  000c8	0a000049	 beq         |$cleanUp$45250|
  000cc		 |$LN13@SetDCB|

; 1468 :         }
; 1469 : 
; 1470 :         if ((force == TRUE) || (pDCB->StopBits != pPdd->dcb.StopBits))

  000cc	e3540001	 cmp         r4, #1
  000d0	0a000003	 beq         |$LN11@SetDCB|
  000d4	e5d5206c	 ldrb        r2, [r5, #0x6C]
  000d8	e5d63014	 ldrb        r3, [r6, #0x14]
  000dc	e1530002	 cmp         r3, r2
  000e0	0a000011	 beq         |$cleanUp$47126|
  000e4		 |$LN11@SetDCB|

; 1471 :         {
; 1472 :             if (!SetStopBits(pPdd, pDCB->StopBits)) goto cleanUp;

  000e4	e5d63014	 ldrb        r3, [r6, #0x14]
  000e8	e5957024	 ldr         r7, [r5, #0x24]
  000ec	e3530000	 cmp         r3, #0
  000f0	0a000004	 beq         |$LN31@SetDCB|
  000f4	e2433001	 sub         r3, r3, #1
  000f8	e3530001	 cmp         r3, #1
  000fc	8a00003c	 bhi         |$cleanUp$45250|
  00100	e3a04004	 mov         r4, #4
  00104	ea000000	 b           |$LN32@SetDCB|
  00108		 |$LN31@SetDCB|
  00108	e3a04000	 mov         r4, #0
  0010c		 |$LN32@SetDCB|
  0010c	e2850098	 add         r0, r5, #0x98
  00110	eb000000	 bl          EnterCriticalSection
  00114	e5d7300c	 ldrb        r3, [r7, #0xC]
  00118	e2850098	 add         r0, r5, #0x98
  0011c	e20330fb	 and         r3, r3, #0xFB
  00120	e1833004	 orr         r3, r3, r4
  00124	e5c7300c	 strb        r3, [r7, #0xC]
  00128	eb000000	 bl          LeaveCriticalSection
  0012c		 |$cleanUp$47126|

; 1473 :         }
; 1474 : 
; 1475 :         // Enable hardware auto RST/CTS modes...
; 1476 :         if (pPdd->hwMode)

  0012c	e5953014	 ldr         r3, [r5, #0x14]
  00130	e3530000	 cmp         r3, #0
  00134	0a00002d	 beq         |$LN1@SetDCB|

; 1477 :         {
; 1478 :             if (pDCB->fRtsControl == RTS_CONTROL_HANDSHAKE)

  00138	e5963008	 ldr         r3, [r6, #8]

; 1479 :             {
; 1480 :                 if (!SetAutoRTS(pPdd, TRUE)) goto cleanUp;

  0013c	e5954024	 ldr         r4, [r5, #0x24]
  00140	e2850098	 add         r0, r5, #0x98
  00144	e2033a03	 and         r3, r3, #3, 20
  00148	e3530a02	 cmp         r3, #2, 20
  0014c	1a000007	 bne         |$LN8@SetDCB|
  00150	eb000000	 bl          EnterCriticalSection
  00154	e5d4200c	 ldrb        r2, [r4, #0xC]
  00158	e3a070bf	 mov         r7, #0xBF
  0015c	e5c4700c	 strb        r7, [r4, #0xC]
  00160	e5d43008	 ldrb        r3, [r4, #8]
  00164	e3a01001	 mov         r1, #1
  00168	e3833040	 orr         r3, r3, #0x40

; 1481 :             }
; 1482 :             else

  0016c	ea000006	 b           |$LN52@SetDCB|
  00170		 |$LN8@SetDCB|

; 1483 :             {
; 1484 :                 if (!SetAutoRTS(pPdd, FALSE)) goto cleanUp;

  00170	eb000000	 bl          EnterCriticalSection
  00174	e5d4200c	 ldrb        r2, [r4, #0xC]
  00178	e3a070bf	 mov         r7, #0xBF
  0017c	e5c4700c	 strb        r7, [r4, #0xC]
  00180	e5d43008	 ldrb        r3, [r4, #8]
  00184	e3a01000	 mov         r1, #0
  00188	e20330bf	 and         r3, r3, #0xBF
  0018c		 |$LN52@SetDCB|
  0018c	e5c43008	 strb        r3, [r4, #8]
  00190	e585107c	 str         r1, [r5, #0x7C]
  00194	e2850098	 add         r0, r5, #0x98
  00198	e5c4200c	 strb        r2, [r4, #0xC]
  0019c	eb000000	 bl          LeaveCriticalSection

; 1485 :             }
; 1486 :             if (pDCB->fOutxCtsFlow)

  001a0	e5963008	 ldr         r3, [r6, #8]

; 1487 :             {
; 1488 :                 if (!SetAutoCTS(pPdd, TRUE)) goto cleanUp;

  001a4	e5954024	 ldr         r4, [r5, #0x24]
  001a8	e2850098	 add         r0, r5, #0x98
  001ac	e3130004	 tst         r3, #4
  001b0	0a000005	 beq         |$LN4@SetDCB|
  001b4	eb000000	 bl          EnterCriticalSection
  001b8	e5d4200c	 ldrb        r2, [r4, #0xC]
  001bc	e5c4700c	 strb        r7, [r4, #0xC]
  001c0	e5d43008	 ldrb        r3, [r4, #8]
  001c4	e3833080	 orr         r3, r3, #0x80

; 1489 :             }
; 1490 :             else

  001c8	ea000004	 b           |$LN53@SetDCB|
  001cc		 |$LN4@SetDCB|

; 1491 :             {
; 1492 :                 if (!SetAutoCTS(pPdd, FALSE)) goto cleanUp;

  001cc	eb000000	 bl          EnterCriticalSection
  001d0	e5d4200c	 ldrb        r2, [r4, #0xC]
  001d4	e5c4700c	 strb        r7, [r4, #0xC]
  001d8	e5d43008	 ldrb        r3, [r4, #8]
  001dc	e203307f	 and         r3, r3, #0x7F
  001e0		 |$LN53@SetDCB|
  001e0	e5c43008	 strb        r3, [r4, #8]
  001e4	e2850098	 add         r0, r5, #0x98
  001e8	e5c4200c	 strb        r2, [r4, #0xC]
  001ec	eb000000	 bl          LeaveCriticalSection
  001f0		 |$LN1@SetDCB|

; 1493 :             }
; 1494 : 
; 1495 :         }
; 1496 : 
; 1497 :         bRC = TRUE;

  001f0	e3a08001	 mov         r8, #1
  001f4		 |$cleanUp$45250|

; 1498 :     }
; 1499 : 
; 1500 : cleanUp:
; 1501 :     return bRC;
; 1502 : }

  001f4	e1a00008	 mov         r0, r8
  001f8	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  001fc	e12fff1e	 bx          lr
  00200		 |$M47179|

			 ENDP  ; |SetDCB|

; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T47194| DCD	|$LN13@RestoreUAR|
	DCD	0x40003c01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\uart\pdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |RestoreUARTContext| PROC

; 1511 : {

  00000		 |$LN13@RestoreUAR|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47191|
  00004	e1a05000	 mov         r5, r0

; 1512 :     DEBUGMSG(ZONE_FUNCTION, (L"+RestoreUARTContext\r\n"));
; 1513 :     //RETAILMSG(1, (L"+RestoreUARTContext\r\n"));
; 1514 : 
; 1515 :     // Set up Tx DMA Channel
; 1516 :     if (pPdd->hTxDmaChannel != NULL)

  00008	e5953104	 ldr         r3, [r5, #0x104]
  0000c	e3530000	 cmp         r3, #0

; 1517 :     {
; 1518 :         InitializeTxDMA(pPdd);

  00010	1b000000	 blne        InitializeTxDMA

; 1519 :     }
; 1520 : 
; 1521 :     // Set up Rx DMA Channel
; 1522 :     if (pPdd->hRxDmaChannel != NULL)

  00014	e595312c	 ldr         r3, [r5, #0x12C]
  00018	e3530000	 cmp         r3, #0
  0001c	0a00000a	 beq         |$LN5@RestoreUAR|

; 1523 :     {
; 1524 :         PHW_INDEP_INFO  pSerialHead = (PHW_INDEP_INFO)pPdd->pMdd;
; 1525 : 
; 1526 :         InitializeRxDMA(pPdd);

  00020	e5954050	 ldr         r4, [r5, #0x50]
  00024	e1a00005	 mov         r0, r5
  00028	eb000000	 bl          InitializeRxDMA

; 1527 : 
; 1528 :         // Adjust the DMA Rx buffer pointer to where the MDD currently points to.
; 1529 :         UpdateDMARxPointer(pPdd, TRUE, (UINT32)RxBuffRead(pSerialHead) - (UINT32)(pPdd->pRxDmaBuffer));

  0002c	e594e0ac	 ldr         lr, [r4, #0xAC]
  00030	e5953114	 ldr         r3, [r5, #0x114]
  00034	e594209c	 ldr         r2, [r4, #0x9C]
  00038	e3a01001	 mov         r1, #1
  0003c	e04e3003	 sub         r3, lr, r3
  00040	e0832002	 add         r2, r3, r2
  00044	e1a00005	 mov         r0, r5
  00048	eb000000	 bl          UpdateDMARxPointer
  0004c		 |$LN5@RestoreUAR|

; 1530 :     }
; 1531 : 
; 1532 :     if (pPdd->currentDX != D0) 

  0004c	e5953030	 ldr         r3, [r5, #0x30]
  00050	e3530000	 cmp         r3, #0

; 1533 :     {
; 1534 :         SetDevicePowerState(pPdd->hParentBus, D0, NULL);

  00054	1595002c	 ldrne       r0, [r5, #0x2C]
  00058	13a02000	 movne       r2, #0
  0005c	13a01000	 movne       r1, #0
  00060	1b000000	 blne        SetDevicePowerState

; 1535 :     }
; 1536 : 
; 1537 :     // Initialize the UART registers with default value. 
; 1538 :     InitializeUART(pPdd);

  00064	e1a00005	 mov         r0, r5
  00068	eb000000	 bl          InitializeUART

; 1539 : 
; 1540 :     // Update COMM port setting according DCB. SetDCB checks the flags in pPdd->pDCB
; 1541 :     // before updating the register value. Passing TRUE in the 3rd parameter to force
; 1542 :     // SetDCB to skip the checking.
; 1543 :     SetDCB(pPdd, &pPdd->dcb, TRUE);

  0006c	e3a02001	 mov         r2, #1
  00070	e2851058	 add         r1, r5, #0x58
  00074	e1a00005	 mov         r0, r5
  00078	eb000000	 bl          SetDCB

; 1544 : 
; 1545 :     // MCR wasn't part of DCB, so we need to restore it here.
; 1546 :     OUTREG8(&pPdd->pUartRegs->MCR, pPdd->currentMCR);

  0007c	e5952024	 ldr         r2, [r5, #0x24]
  00080	e5d5317d	 ldrb        r3, [r5, #0x17D]
  00084	e5c23010	 strb        r3, [r2, #0x10]

; 1547 : 
; 1548 :     /* Clear Modem and Line stats before enable IER */
; 1549 :     INREG8(&pPdd->pUartRegs->MSR);
; 1550 :     INREG8(&pPdd->pUartRegs->LSR);
; 1551 : 
; 1552 :     // Restore interrupt mask. Since we are restoring to UART to it initialize condition
; 1553 :     // and add the current COMM setting on top it, we will simply initialize the interrupt
; 1554 :     // mask according to if the COMM port is open or closed.
; 1555 :     if (pPdd->open == TRUE)

  00088	e5951054	 ldr         r1, [r5, #0x54]
  0008c	e5950024	 ldr         r0, [r5, #0x24]
  00090	e3510001	 cmp         r1, #1
  00094	e5d03018	 ldrb        r3, [r0, #0x18]

; 1556 :     {
; 1557 :         // Enable interrupts (no TX interrupt)
; 1558 :         pPdd->intrMask |= UART_IER_LINE|UART_IER_MODEM;

  00098	05d53088	 ldreqb      r3, [r5, #0x88]
  0009c	e5d02014	 ldrb        r2, [r0, #0x14]
  000a0	0383300c	 orreq       r3, r3, #0xC
  000a4	05c53088	 streqb      r3, [r5, #0x88]

; 1559 :     }
; 1560 :     OUTREG8(&pPdd->pUartRegs->IER, pPdd->intrMask);

  000a8	e5d53088	 ldrb        r3, [r5, #0x88]
  000ac	e5c03004	 strb        r3, [r0, #4]

; 1561 : 
; 1562 :     if (pPdd->currentDX != D0)

  000b0	e5953030	 ldr         r3, [r5, #0x30]
  000b4	e3530000	 cmp         r3, #0

; 1563 :     {
; 1564 : 		SetDevicePowerState(pPdd->hParentBus, pPdd->currentDX, NULL);        

  000b8	1595002c	 ldrne       r0, [r5, #0x2C]
  000bc	13a02000	 movne       r2, #0
  000c0	11a01003	 movne       r1, r3
  000c4	1b000000	 blne        SetDevicePowerState

; 1565 :     }
; 1566 : 
; 1567 :     // We need to give the Tx function a kick to restart the Tx operation.
; 1568 :     pPdd->addTxIntr = TRUE;
; 1569 :     if ((pPdd->hTxDmaChannel != NULL) && (pPdd->hEventTxIstDma != INVALID_HANDLE_VALUE))

  000c8	e5953104	 ldr         r3, [r5, #0x104]
  000cc	e3a02001	 mov         r2, #1
  000d0	e585208c	 str         r2, [r5, #0x8C]
  000d4	e3530000	 cmp         r3, #0
  000d8	15950108	 ldrne       r0, [r5, #0x108]
  000dc	13700001	 cmnne       r0, #1

; 1570 :     {
; 1571 :         SetEvent(pPdd->hEventTxIstDma);

  000e0	13a01003	 movne       r1, #3
  000e4	1b000000	 blne        EventModify

; 1572 :     }
; 1573 : 
; 1574 :     //RETAILMSG(1, (L"-RestoreUARTContext\r\n"));
; 1575 :     DEBUGMSG(ZONE_FUNCTION, (L"-RestoreUARTContext\r\n"));
; 1576 : }

  000e8	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000ec	e12fff1e	 bx          lr
  000f0		 |$M47192|

			 ENDP  ; |RestoreUARTContext|


  00000			 AREA	 |.pdata|, PDATA
|$T47205| DCD	|$LN6@HWPostInit|
	DCD	0x40000b00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWPostInit| PROC

; 1960 : {

  00000		 |$LN6@HWPostInit|
  00000		 |$M47202|

; 1961 :     UARTPDD *pPdd = (UARTPDD *)pvContext;
; 1962 :     PHW_INDEP_INFO  pSerialHead = (PHW_INDEP_INFO)pPdd->pMdd;
; 1963 : 
; 1964 :     // if Rx DMA is enabled override the mdd rxbuffer with DMA buffer
; 1965 :     if (pPdd->RxDmaInfo)

  00000	e5903124	 ldr         r3, [r0, #0x124]
  00004	e5902050	 ldr         r2, [r0, #0x50]
  00008	e3530000	 cmp         r3, #0

; 1966 :     {
; 1967 :         pSerialHead->RxBufferInfo.RxCharBuffer = pPdd->pRxDmaBuffer;

  0000c	15903114	 ldrne       r3, [r0, #0x114]
  00010	158230ac	 strne       r3, [r2, #0xAC]

; 1968 :         pSerialHead->RxBufferInfo.Length = pPdd->RxDmaBufferSize;

  00014	15903110	 ldrne       r3, [r0, #0x110]
  00018	158230a4	 strne       r3, [r2, #0xA4]

; 1969 :         pPdd->rxBufferSize = pPdd->RxDmaBufferSize;

  0001c	15903110	 ldrne       r3, [r0, #0x110]
  00020	15803018	 strne       r3, [r0, #0x18]

; 1970 : 
; 1971 :         DEBUGMSG(ZONE_OPEN||ZONE_FUNCTION,
; 1972 :             (TEXT("buffer %x %d "),pPdd->pRxDmaBuffer,pPdd->RxDmaBufferSize));
; 1973 : 
; 1974 :     }
; 1975 : 
; 1976 : 
; 1977 : 
; 1978 :     return TRUE;

  00024	e3a00001	 mov         r0, #1

; 1979 : }

  00028	e12fff1e	 bx          lr
  0002c		 |$M47203|

			 ENDP  ; |HWPostInit|

	EXPORT	|??_C@_1FG@LMAMANNM@?$AAU?$AAA?$AAR?$AAT?$AA?3?$AAH?$AAW?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AA?3?$AAD?$AAm?$AAa?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt@| [ DATA ] ; `string'
	IMPORT	|ReleaseDevicePads|
	IMPORT	|FreePhysMem|
	IMPORT	|LocalFree|
	IMPORT	|NKDbgPrintfW|
	IMPORT	|DeleteCriticalSection|
	IMPORT	|CloseBusAccessHandle|
	IMPORT	|KernelIoControl|
	IMPORT	|GPIOClose|
	IMPORT	|MmUnmapIoSpace|
	IMPORT	|CloseHandle|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T47219| DCD	|$LN19@HWDeinit|
	DCD	0x40006602

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FG@LMAMANNM@?$AAU?$AAA?$AAR?$AAT?$AA?3?$AAH?$AAW?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AA?3?$AAD?$AAm?$AAa?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt@| DCB "U"
	DCB	0x0, "A", 0x0, "R", 0x0, "T", 0x0, ":", 0x0, "H", 0x0, "W"
	DCB	0x0, "D", 0x0, "e", 0x0, "i", 0x0, "n", 0x0, "i", 0x0, "t"
	DCB	0x0, ":", 0x0, "D", 0x0, "m", 0x0, "a", 0x0, "E", 0x0, "n"
	DCB	0x0, "a", 0x0, "b", 0x0, "l", 0x0, "e", 0x0, "I", 0x0, "n"
	DCB	0x0, "t", 0x0, "e", 0x0, "r", 0x0, "r", 0x0, "u", 0x0, "p"
	DCB	0x0, "t", 0x0, "s", 0x0, " ", 0x0, "f", 0x0, "a", 0x0, "i"
	DCB	0x0, "l", 0x0, "e", 0x0, "d", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\uart\pdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWDeinit| PROC

; 1993 : {

  00000		 |$LN19@HWDeinit|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M47216|
  00008	e1a04000	 mov         r4, r0

; 1994 :     UARTPDD *pPdd = (UARTPDD*)pvContext;
; 1995 :     DEBUGMSG(ZONE_CLOSE||ZONE_FUNCTION, (L"+HWDeinit(0x%08x)\r\n", pvContext));
; 1996 : 
; 1997 :     // stop rx thread
; 1998 :     if (pPdd->hRxThread != NULL)

  0000c	e594313c	 ldr         r3, [r4, #0x13C]
  00010	e3a05000	 mov         r5, #0
  00014	e3530000	 cmp         r3, #0
  00018	0a00000a	 beq         |$LN12@HWDeinit|

; 1999 :     {
; 2000 :         pPdd->bExitThread = TRUE;

  0001c	e3a02001	 mov         r2, #1

; 2001 :         SetEvent(pPdd->hRxThread);

  00020	e3a01003	 mov         r1, #3
  00024	e1a00003	 mov         r0, r3
  00028	e5842138	 str         r2, [r4, #0x138]
  0002c	eb000000	 bl          EventModify

; 2002 :         WaitForSingleObject(pPdd->hRxThread, INFINITE);

  00030	e594013c	 ldr         r0, [r4, #0x13C]
  00034	e3e01000	 mvn         r1, #0
  00038	eb000000	 bl          WaitForSingleObject

; 2003 :         CloseHandle(pPdd->hRxThread);

  0003c	e594013c	 ldr         r0, [r4, #0x13C]
  00040	eb000000	 bl          CloseHandle

; 2004 :         pPdd->hRxThread = NULL;

  00044	e584513c	 str         r5, [r4, #0x13C]
  00048		 |$LN12@HWDeinit|

; 2005 :     }
; 2006 : 
; 2007 :     if (pPdd->hEventRxIstDma != NULL)

  00048	e5943128	 ldr         r3, [r4, #0x128]
  0004c	e3530000	 cmp         r3, #0
  00050	0a000002	 beq         |$LN11@HWDeinit|

; 2008 :     {
; 2009 :         CloseHandle(pPdd->hEventRxIstDma);

  00054	e1a00003	 mov         r0, r3
  00058	eb000000	 bl          CloseHandle

; 2010 :         pPdd->hEventRxIstDma = NULL;

  0005c	e5845128	 str         r5, [r4, #0x128]
  00060		 |$LN11@HWDeinit|

; 2011 :     }
; 2012 :     // Unmap UART registers
; 2013 :     if (pPdd->pUartRegs != NULL)

  00060	e5943024	 ldr         r3, [r4, #0x24]
  00064	e3530000	 cmp         r3, #0

; 2014 :     {
; 2015 :         MmUnmapIoSpace((VOID*)pPdd->pUartRegs, pPdd->memLen[0]);

  00068	15941004	 ldrne       r1, [r4, #4]
  0006c	11a00003	 movne       r0, r3
  00070	1b000000	 blne        MmUnmapIoSpace

; 2016 :     }
; 2017 : 
; 2018 :     if (pPdd->hGpio)

  00074	e594316c	 ldr         r3, [r4, #0x16C]
  00078	e3530000	 cmp         r3, #0
  0007c	0a000002	 beq         |$LN9@HWDeinit|

; 2019 :     {
; 2020 :         GPIOClose(pPdd->hGpio);

  00080	e1a00003	 mov         r0, r3
  00084	eb000000	 bl          GPIOClose

; 2021 :         pPdd->hGpio = NULL;

  00088	e584516c	 str         r5, [r4, #0x16C]
  0008c		 |$LN9@HWDeinit|

; 2022 :     }
; 2023 : 
; 2024 :     // Disconnect the interrupt
; 2025 :     if (pPdd->sysIntr != 0)

  0008c	e5943028	 ldr         r3, [r4, #0x28]
  00090	e3530000	 cmp         r3, #0

; 2026 :     {
; 2027 :         KernelIoControl(
; 2028 :             IOCTL_HAL_RELEASE_SYSINTR, &pPdd->sysIntr, sizeof(&pPdd->sysIntr),
; 2029 :             NULL, 0, NULL
; 2030 :             );

  00094	159f00f8	 ldrne       r0, [pc, #0xF8]
  00098	13a03000	 movne       r3, #0
  0009c	13a02004	 movne       r2, #4
  000a0	12841028	 addne       r1, r4, #0x28
  000a4	158d5004	 strne       r5, [sp, #4]
  000a8	158d5000	 strne       r5, [sp]
  000ac	1b000000	 blne        KernelIoControl

; 2031 :     }
; 2032 : 
; 2033 :     // Disable all clocks
; 2034 :     if (pPdd->hParentBus != NULL)

  000b0	e594302c	 ldr         r3, [r4, #0x2C]
  000b4	e3530000	 cmp         r3, #0
  000b8	0a000006	 beq         |$LN7@HWDeinit|

; 2035 :     {
; 2036 :         pPdd->externalDX = D3;

  000bc	e3a03003	 mov         r3, #3

; 2037 :         SetPower(pPdd, D3);

  000c0	e3a01003	 mov         r1, #3
  000c4	e1a00004	 mov         r0, r4
  000c8	e5843034	 str         r3, [r4, #0x34]
  000cc	eb000000	 bl          SetPower

; 2038 :         CloseBusAccessHandle(pPdd->hParentBus);

  000d0	e594002c	 ldr         r0, [r4, #0x2C]
  000d4	eb000000	 bl          CloseBusAccessHandle
  000d8		 |$LN7@HWDeinit|

; 2039 :     }
; 2040 : 
; 2041 :     // Delete sync objects
; 2042 :     DeleteCriticalSection(&pPdd->hwCS);

  000d8	e2840098	 add         r0, r4, #0x98
  000dc	eb000000	 bl          DeleteCriticalSection

; 2043 :     DeleteCriticalSection(&pPdd->txCS);

  000e0	e28400ac	 add         r0, r4, #0xAC
  000e4	eb000000	 bl          DeleteCriticalSection

; 2044 :     DeleteCriticalSection(&pPdd->RxUpdatePtrCS);

  000e8	e28400c0	 add         r0, r4, #0xC0
  000ec	eb000000	 bl          DeleteCriticalSection

; 2045 : 
; 2046 :     if (pPdd->txEvent != NULL) CloseHandle(pPdd->txEvent);

  000f0	e59430d4	 ldr         r3, [r4, #0xD4]
  000f4	e3530000	 cmp         r3, #0
  000f8	11a00003	 movne       r0, r3
  000fc	1b000000	 blne        CloseHandle

; 2047 : 
; 2048 :     if (pPdd->RxDmaInfo)

  00100	e5943124	 ldr         r3, [r4, #0x124]
  00104	e3530000	 cmp         r3, #0
  00108	0a000009	 beq         |$LN5@HWDeinit|

; 2049 :     {
; 2050 :         DmaStop(pPdd->RxDmaInfo);

  0010c	e1a00003	 mov         r0, r3
  00110	eb000000	 bl          DmaStop

; 2051 : 
; 2052 :         if(!DmaEnableInterrupts(pPdd->hRxDmaChannel, NULL))

  00114	e594012c	 ldr         r0, [r4, #0x12C]
  00118	e3a01000	 mov         r1, #0
  0011c	eb000000	 bl          DmaEnableInterrupts
  00120	e3500000	 cmp         r0, #0

; 2053 :         {
; 2054 :             RETAILMSG(1, (L"UART:HWDeinit:DmaEnableInterrupts failed\r\n"));

  00124	059f0064	 ldreq       r0, [pc, #0x64]
  00128	0b000000	 bleq        NKDbgPrintfW

; 2055 :         }
; 2056 :         LocalFree(pPdd->RxDmaInfo);

  0012c	e5940124	 ldr         r0, [r4, #0x124]
  00130	eb000000	 bl          LocalFree
  00134		 |$LN5@HWDeinit|

; 2057 :     }
; 2058 :     if (pPdd->TxDmaInfo)

  00134	e5943100	 ldr         r3, [r4, #0x100]
  00138	e3530000	 cmp         r3, #0
  0013c	0a000003	 beq         |$LN3@HWDeinit|

; 2059 :     {
; 2060 :         DmaStop(pPdd->TxDmaInfo);

  00140	e1a00003	 mov         r0, r3
  00144	eb000000	 bl          DmaStop

; 2061 :         LocalFree(pPdd->TxDmaInfo);

  00148	e5940100	 ldr         r0, [r4, #0x100]
  0014c	eb000000	 bl          LocalFree
  00150		 |$LN3@HWDeinit|

; 2062 :     }
; 2063 : 
; 2064 :     // Free any allocated physical memory
; 2065 :     if (pPdd->pTxDmaBuffer)

  00150	e59430f8	 ldr         r3, [r4, #0xF8]
  00154	e3530000	 cmp         r3, #0

; 2066 :     {
; 2067 :         FreePhysMem( pPdd->pTxDmaBuffer );

  00158	11a00003	 movne       r0, r3
  0015c	1b000000	 blne        FreePhysMem

; 2068 :     }
; 2069 :     if (pPdd->pRxDmaBuffer)

  00160	e5943114	 ldr         r3, [r4, #0x114]
  00164	e3530000	 cmp         r3, #0

; 2070 :     {
; 2071 :         FreePhysMem( pPdd->pRxDmaBuffer );

  00168	11a00003	 movne       r0, r3
  0016c	1b000000	 blne        FreePhysMem

; 2072 :     }
; 2073 : 
; 2074 : 	// Release pads
; 2075 : 	ReleaseDevicePads(pPdd->DeviceID);

  00170	e5940010	 ldr         r0, [r4, #0x10]
  00174	eb000000	 bl          ReleaseDevicePads

; 2076 : 
; 2077 :     // Free driver object
; 2078 :     LocalFree(pPdd);

  00178	e1a00004	 mov         r0, r4
  0017c	eb000000	 bl          LocalFree

; 2079 : 
; 2080 :     DEBUGMSG(ZONE_CLOSE||ZONE_FUNCTION, (L"-HWDeinit\r\n"));
; 2081 :     return TRUE;

  00180	e3a00001	 mov         r0, #1

; 2082 : }

  00184	e28dd008	 add         sp, sp, #8
  00188	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0018c	e12fff1e	 bx          lr
  00190		 |$LN20@HWDeinit|
  00190		 |$LN21@HWDeinit|
  00190	00000000	 DCD         |??_C@_1FG@LMAMANNM@?$AAU?$AAA?$AAR?$AAT?$AA?3?$AAH?$AAW?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AA?3?$AAD?$AAm?$AAa?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt@|
  00194		 |$LN22@HWDeinit|
  00194	010100d8	 DCD         0x10100d8
  00198		 |$M47217|

			 ENDP  ; |HWDeinit|

	EXPORT	|PowerThreadProc|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T47241| DCD	|$LN19@PowerThrea|
	DCD	0x40002801
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\uart\pdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PowerThreadProc| PROC

; 2094 : {

  00000		 |$LN19@PowerThrea|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M47238|
  00004	e1a04000	 mov         r4, r0

; 2095 :     DWORD nTimeout = INFINITE;
; 2096 :     UARTPDD *pPdd = (UARTPDD *)pParam;
; 2097 : 
; 2098 : 
; 2099 :     for(;;)
; 2100 :     {
; 2101 :         WaitForSingleObject(pPdd->hPowerEvent, nTimeout);

  00008	e594015c	 ldr         r0, [r4, #0x15C]
  0000c	e3e01000	 mvn         r1, #0
  00010	eb000000	 bl          WaitForSingleObject

; 2102 : 
; 2103 :         if (pPdd->bExitPowerThread == TRUE) break;

  00014	e5943164	 ldr         r3, [r4, #0x164]
  00018	e3530001	 cmp         r3, #1
  0001c	0a000019	 beq         |$LN15@PowerThrea|
  00020	e3a07005	 mov         r7, #5
  00024	e3a06001	 mov         r6, #1
  00028		 |$LL8@PowerThrea|

; 2104 :         // serialize access to power state changes
; 2105 :         EnterCriticalSection(&pPdd->hwCS);

  00028	e2840098	 add         r0, r4, #0x98
  0002c	eb000000	 bl          EnterCriticalSection

; 2106 : 
; 2107 :         // by the time this thread got the hwCS hPowerEvent may
; 2108 :         // have gotten resignaled.  Clear the event to  make
; 2109 :         // sure the Power thread isn't awaken prematurely
; 2110 :         //
; 2111 :         ResetEvent(pPdd->hPowerEvent);

  00030	e594015c	 ldr         r0, [r4, #0x15C]
  00034	e3a01002	 mov         r1, #2
  00038	eb000000	 bl          EventModify

; 2112 : 
; 2113 :         // check if we need to reset the timer
; 2114 :         if (pPdd->RxTxRefCount == 0)

  0003c	e5943140	 ldr         r3, [r4, #0x140]
  00040	e3530000	 cmp         r3, #0
  00044	1a000006	 bne         |$LN5@PowerThrea|

; 2115 :         {
; 2116 :             // We disable the AutoIdle and put Uart into power
; 2117 :             // force Idle mode only when this thread wakes-up
; 2118 :             // twice in a row with no RxTxRefCount = 0
; 2119 :             // This is achieved by using the bDisableAutoIdle
; 2120 :             // flag to determine if power state changed since
; 2121 :             // the last time this thread woke-up
; 2122 :             //
; 2123 :             if (pPdd->bDisableAutoIdle == TRUE)

  00048	e5943168	 ldr         r3, [r4, #0x168]
  0004c	e3530001	 cmp         r3, #1
  00050	1a00000f	 bne         |$LN4@PowerThrea|

; 2124 :             {
; 2125 :                 // check to make sure the uart clocks are on
; 2126 :                 if (pPdd->currentDX >= D3) 

  00054	e5943030	 ldr         r3, [r4, #0x30]
  00058	e3530003	 cmp         r3, #3

; 2127 :                 {
; 2128 :                 //RETAILMSG(1,(TEXT("UART:Switching to Force Idle \r")));
; 2129 :                 OUTREG8(
; 2130 :                         &pPdd->pUartRegs->SYSC,
; 2131 :                         // turn on force idle, to allow full retention
; 2132 :                         UART_SYSC_IDLE_FORCE|UART_SYSC_WAKEUP_ENABLE|UART_SYSC_AUTOIDLE
; 2133 :                         );

  0005c	a5943024	 ldrge       r3, [r4, #0x24]
  00060	a5c37054	 strgeb      r7, [r3, #0x54]
  00064		 |$LN5@PowerThrea|

; 2145 :         {
; 2146 :             nTimeout = INFINITE;

  00064	e3e05000	 mvn         r5, #0
  00068		 |$LN1@PowerThrea|

; 2147 :         }
; 2148 : 
; 2149 :         LeaveCriticalSection(&pPdd->hwCS);

  00068	e2840098	 add         r0, r4, #0x98
  0006c	eb000000	 bl          LeaveCriticalSection
  00070	e594015c	 ldr         r0, [r4, #0x15C]
  00074	e1a01005	 mov         r1, r5
  00078	eb000000	 bl          WaitForSingleObject
  0007c	e5943164	 ldr         r3, [r4, #0x164]
  00080	e3530001	 cmp         r3, #1
  00084	1affffe7	 bne         |$LL8@PowerThrea|
  00088		 |$LN15@PowerThrea|

; 2150 :     }
; 2151 :     return 1;

  00088	e3a00001	 mov         r0, #1

; 2152 : }

  0008c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$LN4@PowerThrea|

; 2134 :                 }
; 2135 :                 nTimeout = INFINITE;
; 2136 :             }
; 2137 :             else
; 2138 :             {
; 2139 :                 // wait for activity time-out before shutting off power.
; 2140 :                 pPdd->bDisableAutoIdle = TRUE;
; 2141 :                 nTimeout = pPdd->hwTimeout;

  00094	e5945020	 ldr         r5, [r4, #0x20]
  00098	e5846168	 str         r6, [r4, #0x168]

; 2142 :             }
; 2143 :         }
; 2144 :         else

  0009c	eafffff1	 b           |$LN1@PowerThrea|
  000a0		 |$M47239|

			 ENDP  ; |PowerThreadProc|

	IMPORT	|CreateThread|
	IMPORT	|CreateEventW|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\inc\omap_sdma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T47318| DCD	|$LN32@HWOpen|
	DCD	0x4000aa02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\uart\pdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWOpen| PROC

; 2161 : {

  00000		 |$LN32@HWOpen|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M47315|
  00008	e1a05000	 mov         r5, r0

; 2162 :     BOOL rc = FALSE;
; 2163 :     UARTPDD *pPdd = (UARTPDD*)pvContext;
; 2164 : 
; 2165 :     //Modem line testing
; 2166 :     DWORD dwStatus = 0;
; 2167 : 
; 2168 :     DEBUGMSG(ZONE_OPEN||ZONE_FUNCTION, (L"+HWOpen(0x%08x)\r\n", pvContext));
; 2169 :     DEBUGMSG(ZONE_FUNCTION, (L"HWOpen - Membase=0x%08x\r\n", pPdd->memBase[0]));
; 2170 : 
; 2171 :     if (pPdd->open) goto cleanUp;

  0000c	e5953054	 ldr         r3, [r5, #0x54]
  00010	e3a04000	 mov         r4, #0
  00014	e3530000	 cmp         r3, #0
  00018	1a00009d	 bne         |$cleanUp$45492|

; 2172 : 
; 2173 :     // We have set hardware to D0
; 2174 :     pPdd->externalDX = D0;

  0001c	e3a08000	 mov         r8, #0

; 2175 :     SetPower(pPdd, D0);

  00020	e3a01000	 mov         r1, #0
  00024	e5858034	 str         r8, [r5, #0x34]
  00028	eb000000	 bl          SetPower

; 2176 : 
; 2177 :     SetDefaultDCB(pPdd);

  0002c	e5952060	 ldr         r2, [r5, #0x60]
  00030	e3e03a02	 mvn         r3, #2, 20
  00034	e223306e	 eor         r3, r3, #0x6E
  00038	e3a01a01	 mov         r1, #1, 20
  0003c	e0022003	 and         r2, r2, r3
  00040	e3813011	 orr         r3, r1, #0x11
  00044	e1823003	 orr         r3, r2, r3
  00048	e5853060	 str         r3, [r5, #0x60]
  0004c	e3a0e01c	 mov         lr, #0x1C
  00050	e3a06d96	 mov         r6, #0x96, 26
  00054	e3a07008	 mov         r7, #8
  00058	e3a09001	 mov         r9, #1

; 2178 : 
; 2179 :     pPdd->commErrors    = 0;
; 2180 :     pPdd->overrunCount  = 0;
; 2181 :     pPdd->flowOffCTS    = FALSE;
; 2182 :     pPdd->flowOffDSR    = FALSE;
; 2183 :     pPdd->addTxIntr     = FALSE;
; 2184 :     pPdd->open          = TRUE;
; 2185 :     pPdd->wakeUpMode    = FALSE;
; 2186 :     pPdd->RxTxRefCount  = 0;
; 2187 :     pPdd->bExitPowerThread = FALSE;
; 2188 : 
; 2189 :     // Event for power thread to check Rx -Tx activity
; 2190 :     pPdd->hPowerEvent = CreateEvent(0,TRUE,FALSE,NULL);

  0005c	e3a03000	 mov         r3, #0
  00060	e3a02000	 mov         r2, #0
  00064	e3a01001	 mov         r1, #1
  00068	e3a00000	 mov         r0, #0
  0006c	e585e058	 str         lr, [r5, #0x58]
  00070	e585605c	 str         r6, [r5, #0x5C]
  00074	e5c5706a	 strb        r7, [r5, #0x6A]
  00078	e5c5806b	 strb        r8, [r5, #0x6B]
  0007c	e5c5906c	 strb        r9, [r5, #0x6C]
  00080	e5858074	 str         r8, [r5, #0x74]
  00084	e5858078	 str         r8, [r5, #0x78]
  00088	e5858090	 str         r8, [r5, #0x90]
  0008c	e5858094	 str         r8, [r5, #0x94]
  00090	e585808c	 str         r8, [r5, #0x8C]
  00094	e5859054	 str         r9, [r5, #0x54]
  00098	e5858080	 str         r8, [r5, #0x80]
  0009c	e5858140	 str         r8, [r5, #0x140]
  000a0	e5858164	 str         r8, [r5, #0x164]
  000a4	eb000000	 bl          CreateEventW

; 2191 : 
; 2192 :     // spawn power thread
; 2193 :     pPdd->hPowerThread = CreateThread(NULL, 0, PowerThreadProc, pPdd, 0, NULL);

  000a8	e59f21f4	 ldr         r2, [pc, #0x1F4]
  000ac	e1a03000	 mov         r3, r0
  000b0	e585315c	 str         r3, [r5, #0x15C]
  000b4	e1a03005	 mov         r3, r5
  000b8	e3a00000	 mov         r0, #0
  000bc	e3a01000	 mov         r1, #0
  000c0	e58d8004	 str         r8, [sp, #4]
  000c4	e58d8000	 str         r8, [sp]
  000c8	eb000000	 bl          CreateThread
  000cc	e3500000	 cmp         r0, #0
  000d0	e5850160	 str         r0, [r5, #0x160]

; 2194 : 
; 2195 :     if (pPdd->hPowerThread == NULL)

  000d4	0a00006e	 beq         |$cleanUp$45492|

; 2196 :     {
; 2197 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: HWOpen: "
; 2198 :             L"Failed to create Power Thread\r\n"
; 2199 :             ));
; 2200 :         goto cleanUp;
; 2201 :     }
; 2202 : 
; 2203 :     EnterCriticalSection(&pPdd->hwCS);

  000d8	e2850098	 add         r0, r5, #0x98
  000dc	eb000000	 bl          EnterCriticalSection

; 2204 : 
; 2205 :     // Set line control register
; 2206 :     SetWordLength(pPdd, pPdd->dcb.ByteSize);

  000e0	e5d5406a	 ldrb        r4, [r5, #0x6A]
  000e4	e5956024	 ldr         r6, [r5, #0x24]
  000e8	e3540005	 cmp         r4, #5
  000ec	3a00000a	 bcc         |$cleanUp$47256|
  000f0	e3540008	 cmp         r4, #8
  000f4	8a000008	 bhi         |$cleanUp$47256|
  000f8	e2850098	 add         r0, r5, #0x98
  000fc	eb000000	 bl          EnterCriticalSection
  00100	e5d6300c	 ldrb        r3, [r6, #0xC]
  00104	e28420fb	 add         r2, r4, #0xFB
  00108	e2850098	 add         r0, r5, #0x98
  0010c	e20330fc	 and         r3, r3, #0xFC
  00110	e1833002	 orr         r3, r3, r2
  00114	e5c6300c	 strb        r3, [r6, #0xC]
  00118	eb000000	 bl          LeaveCriticalSection
  0011c		 |$cleanUp$47256|

; 2207 :     SetStopBits(pPdd, pPdd->dcb.StopBits);

  0011c	e5d5306c	 ldrb        r3, [r5, #0x6C]
  00120	e5956024	 ldr         r6, [r5, #0x24]
  00124	e3530000	 cmp         r3, #0
  00128	0a000004	 beq         |$LN14@HWOpen|
  0012c	e2433001	 sub         r3, r3, #1
  00130	e3530001	 cmp         r3, #1
  00134	8a00000a	 bhi         |$cleanUp$47270|
  00138	e3a04004	 mov         r4, #4
  0013c	ea000000	 b           |$LN15@HWOpen|
  00140		 |$LN14@HWOpen|
  00140	e3a04000	 mov         r4, #0
  00144		 |$LN15@HWOpen|
  00144	e2850098	 add         r0, r5, #0x98
  00148	eb000000	 bl          EnterCriticalSection
  0014c	e5d6300c	 ldrb        r3, [r6, #0xC]
  00150	e2850098	 add         r0, r5, #0x98
  00154	e20330fb	 and         r3, r3, #0xFB
  00158	e1833004	 orr         r3, r3, r4
  0015c	e5c6300c	 strb        r3, [r6, #0xC]
  00160	eb000000	 bl          LeaveCriticalSection
  00164		 |$cleanUp$47270|

; 2208 :     SetParity(pPdd, pPdd->dcb.Parity);

  00164	e5d5106b	 ldrb        r1, [r5, #0x6B]
  00168	e1a00005	 mov         r0, r5
  0016c	eb000000	 bl          SetParity

; 2209 : 
; 2210 :     // Set modem control register
; 2211 :     pPdd->currentMCR = 0;
; 2212 :     OUTREG8(&pPdd->pUartRegs->MCR, 0);

  00170	e5953024	 ldr         r3, [r5, #0x24]
  00174	e5c5817d	 strb        r8, [r5, #0x17D]
  00178	e5c38010	 strb        r8, [r3, #0x10]

; 2213 :     //Clear Tx and Rx FIFO
; 2214 :     OUTREG8(&pPdd->pUartRegs->FCR, pPdd->CurrentFCR | UART_FCR_TX_FIFO_CLEAR | UART_FCR_RX_FIFO_CLEAR);

  0017c	e5d53089	 ldrb        r3, [r5, #0x89]
  00180	e5952024	 ldr         r2, [r5, #0x24]
  00184	e3833006	 orr         r3, r3, #6
  00188	e5c23008	 strb        r3, [r2, #8]

; 2215 : 
; 2216 :     // Do we need to read RESUME register in case there was an overrun error in the FIFO?
; 2217 :     INREG8(&pPdd->pUartRegs->RESUME);

  0018c	e5953024	 ldr         r3, [r5, #0x24]

; 2218 : 
; 2219 :     // Reset the RX dma info.
; 2220 :     if(pPdd->RxDmaInfo) {

  00190	e5952124	 ldr         r2, [r5, #0x124]
  00194	e5d3302c	 ldrb        r3, [r3, #0x2C]
  00198	e3520000	 cmp         r2, #0
  0019c	0a00002f	 beq         |$LN1@HWOpen|

; 2221 : 
; 2222 :         // Just to be safe we will make sure DMA is stopped and the status is clear
; 2223 :         DmaStop(pPdd->RxDmaInfo);

  001a0	e1a00002	 mov         r0, r2
  001a4	eb000000	 bl          DmaStop

; 2224 :         dwStatus = DmaGetStatus(pPdd->RxDmaInfo);

  001a8	e5953124	 ldr         r3, [r5, #0x124]
  001ac	e5932014	 ldr         r2, [r3, #0x14]
  001b0	e592300c	 ldr         r3, [r2, #0xC]

; 2225 :         DmaClearStatus(pPdd->RxDmaInfo, dwStatus);

  001b4	e582300c	 str         r3, [r2, #0xC]

; 2226 : 
; 2227 :         //We must do this since the MDD calls RXResetFifo
; 2228 :         DmaSetElementAndFrameCount (pPdd->RxDmaInfo,
; 2229 :             (UINT16)pPdd->dwRxFifoTriggerLevel,
; 2230 :             (UINT16)((pPdd->RxDmaBufferSize + pPdd->dwRxFifoTriggerLevel - 1) / pPdd->dwRxFifoTriggerLevel));

  001b8	e5954154	 ldr         r4, [r5, #0x154]
  001bc	e5953110	 ldr         r3, [r5, #0x110]
  001c0	e1a00004	 mov         r0, r4
  001c4	e0843003	 add         r3, r4, r3
  001c8	e2431001	 sub         r1, r3, #1
  001cc	eb000000	 bl          __rt_udiv
  001d0	e595e124	 ldr         lr, [r5, #0x124]
  001d4	e1a02804	 mov         r2, r4, lsl #16
  001d8	e1a02822	 mov         r2, r2, lsr #16
  001dc	e59e3014	 ldr         r3, [lr, #0x14]
  001e0	e1a01800	 mov         r1, r0, lsl #16
  001e4	e1a01821	 mov         r1, r1, lsr #16
  001e8	e5832014	 str         r2, [r3, #0x14]
  001ec	e59e3014	 ldr         r3, [lr, #0x14]
  001f0	e5831018	 str         r1, [r3, #0x18]

; 2231 :         DmaSetDstBuffer (pPdd->RxDmaInfo,
; 2232 :             pPdd->pRxDmaBuffer,
; 2233 :             pPdd->paRxDmaBuffer);

  001f4	e5950124	 ldr         r0, [r5, #0x124]
  001f8	e5951118	 ldr         r1, [r5, #0x118]
  001fc	e5953114	 ldr         r3, [r5, #0x114]
  00200	e5902014	 ldr         r2, [r0, #0x14]
  00204	e580100c	 str         r1, [r0, #0xC]
  00208	e5803004	 str         r3, [r0, #4]
  0020c	e3520000	 cmp         r2, #0
  00210	15821020	 strne       r1, [r2, #0x20]
  00214	15903014	 ldrne       r3, [r0, #0x14]

; 2234 : 
; 2235 :         pPdd->bRxDMASignaled = 0;
; 2236 :         pPdd->bRxWrapped     = FALSE;
; 2237 :         pPdd->pRxDMALastWrite = pPdd->pRxDmaBuffer;
; 2238 : 
; 2239 :         UpdateDMARxPointer(pPdd, FALSE, 0);

  00218	e3a02000	 mov         r2, #0
  0021c	e1a00005	 mov         r0, r5
  00220	15831038	 strne       r1, [r3, #0x38]
  00224	e5953114	 ldr         r3, [r5, #0x114]
  00228	e3a01000	 mov         r1, #0
  0022c	e5858144	 str         r8, [r5, #0x144]
  00230	e585314c	 str         r3, [r5, #0x14C]
  00234	e5858148	 str         r8, [r5, #0x148]
  00238	eb000000	 bl          UpdateDMARxPointer

; 2240 : 
; 2241 :         SetAutoIdle(pPdd, TRUE);

  0023c	e3a01001	 mov         r1, #1
  00240	e1a00005	 mov         r0, r5
  00244	eb000000	 bl          SetAutoIdle

; 2242 :         DmaStart(pPdd->RxDmaInfo);

  00248	e5953124	 ldr         r3, [r5, #0x124]
  0024c	e5932014	 ldr         r2, [r3, #0x14]
  00250	e5923000	 ldr         r3, [r2]
  00254	e3833080	 orr         r3, r3, #0x80
  00258	e5823000	 str         r3, [r2]

; 2243 :         pPdd->bDmaInitialize = TRUE;

  0025c	e5859150	 str         r9, [r5, #0x150]
  00260		 |$LN1@HWOpen|

; 2244 :     }
; 2245 : 
; 2246 :     // configure uart port with default settings
; 2247 :     SetBaudRate(pPdd, pPdd->dcb.BaudRate);

  00260	e595105c	 ldr         r1, [r5, #0x5C]
  00264	e1a00005	 mov         r0, r5
  00268	eb000000	 bl          SetBaudRate

; 2248 :     // Enable interrupts (no TX interrupt)
; 2249 :     pPdd->intrMask |= UART_IER_LINE|UART_IER_MODEM;

  0026c	e5d53088	 ldrb        r3, [r5, #0x88]

; 2250 :     OUTREG8(&pPdd->pUartRegs->IER, pPdd->intrMask);

  00270	e5952024	 ldr         r2, [r5, #0x24]

; 2251 :     // Update line & modem status
; 2252 :     ReadModemStat(pPdd);

  00274	e1a00005	 mov         r0, r5
  00278	e383300c	 orr         r3, r3, #0xC
  0027c	e5c53088	 strb        r3, [r5, #0x88]
  00280	e5c23004	 strb        r3, [r2, #4]
  00284	eb000000	 bl          ReadModemStat

; 2253 : 
; 2254 :     LeaveCriticalSection(&pPdd->hwCS);

  00288	e2850098	 add         r0, r5, #0x98
  0028c	eb000000	 bl          LeaveCriticalSection

; 2255 : 
; 2256 :     rc = TRUE;

  00290	e3a04001	 mov         r4, #1
  00294		 |$cleanUp$45492|

; 2257 : 
; 2258 : cleanUp:
; 2259 :     DEBUGMSG(ZONE_OPEN||ZONE_FUNCTION, (L"-HWOpen(rc = %d)\r\n", rc));
; 2260 : 
; 2261 :     return rc;
; 2262 : }

  00294	e1a00004	 mov         r0, r4
  00298	e28dd008	 add         sp, sp, #8
  0029c	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  002a0	e12fff1e	 bx          lr
  002a4		 |$LN33@HWOpen|
  002a4		 |$LN34@HWOpen|
  002a4	00000000	 DCD         |PowerThreadProc|
  002a8		 |$M47316|

			 ENDP  ; |HWOpen|

; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T47353| DCD	|$LN23@HWClose|
	DCD	0x40005e01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\uart\pdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWClose| PROC

; 2271 : {

  00000		 |$LN23@HWClose|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M47350|
  00004	e1a05000	 mov         r5, r0

; 2272 :     ULONG rc = (ULONG)-1;
; 2273 :     UARTPDD *pPdd = (UARTPDD*)pvContext;
; 2274 : 
; 2275 :     DEBUGMSG(ZONE_CLOSE||ZONE_FUNCTION, (L"+HWClose(0x%08x)\r\n", pvContext));
; 2276 : 
; 2277 :     if (!pPdd->open) goto cleanUp;

  00008	e5953054	 ldr         r3, [r5, #0x54]
  0000c	e3e06000	 mvn         r6, #0
  00010	e3530000	 cmp         r3, #0
  00014	0a000054	 beq         |$cleanUp$45519|

; 2278 : 
; 2279 :     //CETK test case put Device in D4 state. CETK called some API's which is not supported
; 2280 :     //Added check just to Make sure COM_Close is executed in D0 state.
; 2281 :     if(pPdd->externalDX != D0)

  00018	e5953034	 ldr         r3, [r5, #0x34]
  0001c	e3a07000	 mov         r7, #0
  00020	e3530000	 cmp         r3, #0

; 2282 :     {
; 2283 :         pPdd->externalDX = D0;
; 2284 :         SetPower(pPdd, D0);

  00024	13a01000	 movne       r1, #0
  00028	15857034	 strne       r7, [r5, #0x34]
  0002c	1b000000	 blne        SetPower

; 2285 :     }
; 2286 : 
; 2287 :     if (pPdd->hwMode)

  00030	e5953014	 ldr         r3, [r5, #0x14]
  00034	e3530000	 cmp         r3, #0
  00038	0a00001e	 beq         |$LN17@HWClose|

; 2288 :     {
; 2289 :         if (pPdd->dcb.fRtsControl == RTS_CONTROL_HANDSHAKE) SetAutoRTS(pPdd, FALSE);

  0003c	e5953060	 ldr         r3, [r5, #0x60]
  00040	e3a080bf	 mov         r8, #0xBF
  00044	e2033a03	 and         r3, r3, #3, 20
  00048	e3530a02	 cmp         r3, #2, 20
  0004c	1a00000b	 bne         |$LN13@HWClose|
  00050	e5954024	 ldr         r4, [r5, #0x24]
  00054	e2850098	 add         r0, r5, #0x98
  00058	eb000000	 bl          EnterCriticalSection
  0005c	e5d4200c	 ldrb        r2, [r4, #0xC]
  00060	e5c4800c	 strb        r8, [r4, #0xC]
  00064	e5d43008	 ldrb        r3, [r4, #8]
  00068	e2850098	 add         r0, r5, #0x98
  0006c	e20330bf	 and         r3, r3, #0xBF
  00070	e5c43008	 strb        r3, [r4, #8]
  00074	e585707c	 str         r7, [r5, #0x7C]
  00078	e5c4200c	 strb        r2, [r4, #0xC]
  0007c	eb000000	 bl          LeaveCriticalSection
  00080		 |$LN13@HWClose|

; 2290 :         if (pPdd->dcb.fOutxCtsFlow) SetAutoCTS(pPdd, FALSE);

  00080	e5953060	 ldr         r3, [r5, #0x60]
  00084	e3130004	 tst         r3, #4
  00088	0a00000a	 beq         |$LN17@HWClose|
  0008c	e5954024	 ldr         r4, [r5, #0x24]
  00090	e2850098	 add         r0, r5, #0x98
  00094	eb000000	 bl          EnterCriticalSection
  00098	e5d4200c	 ldrb        r2, [r4, #0xC]
  0009c	e5c4800c	 strb        r8, [r4, #0xC]
  000a0	e5d43008	 ldrb        r3, [r4, #8]
  000a4	e2850098	 add         r0, r5, #0x98
  000a8	e203307f	 and         r3, r3, #0x7F
  000ac	e5c43008	 strb        r3, [r4, #8]
  000b0	e5c4200c	 strb        r2, [r4, #0xC]
  000b4	eb000000	 bl          LeaveCriticalSection
  000b8		 |$LN17@HWClose|

; 2291 :     }
; 2292 : 
; 2293 :     EnterCriticalSection(&pPdd->hwCS);

  000b8	e2850098	 add         r0, r5, #0x98
  000bc	eb000000	 bl          EnterCriticalSection

; 2294 : 
; 2295 :     // Disable interrupts
; 2296 :     pPdd->intrMask &= ~(UART_IER_RHR|UART_IER_LINE|UART_IER_MODEM);

  000c0	e5d53088	 ldrb        r3, [r5, #0x88]

; 2297 :     OUTREG8(&pPdd->pUartRegs->IER, pPdd->intrMask);

  000c4	e5952024	 ldr         r2, [r5, #0x24]

; 2298 : 
; 2299 :     // Update line & modem status
; 2300 :     ReadModemStat(pPdd);

  000c8	e1a00005	 mov         r0, r5
  000cc	e20330f2	 and         r3, r3, #0xF2
  000d0	e5c53088	 strb        r3, [r5, #0x88]
  000d4	e5c23004	 strb        r3, [r2, #4]
  000d8	eb000000	 bl          ReadModemStat

; 2301 : 
; 2302 :     // Disable all interrupts and clear modem control register
; 2303 :     // The following line generates a data abort.
; 2304 :     // Unclear why (even if the above code is commented out too)
; 2305 :     //    OUTREG8(&pPdd->pUartRegs->IER, 0);
; 2306 :     //    OUTREG8(&pPdd->pUartRegs->MCR, 0);
; 2307 : 
; 2308 :     if (pPdd->RxDmaInfo)

  000dc	e5953124	 ldr         r3, [r5, #0x124]
  000e0	e3530000	 cmp         r3, #0
  000e4	0a000002	 beq         |$LN3@HWClose|

; 2309 :     {
; 2310 :         DmaStop(pPdd->RxDmaInfo);

  000e8	e1a00003	 mov         r0, r3
  000ec	eb000000	 bl          DmaStop

; 2311 :         pPdd->bDmaInitialize = FALSE;

  000f0	e5857150	 str         r7, [r5, #0x150]
  000f4		 |$LN3@HWClose|

; 2312 :     }
; 2313 : 
; 2314 :     LeaveCriticalSection(&pPdd->hwCS);

  000f4	e2850098	 add         r0, r5, #0x98
  000f8	eb000000	 bl          LeaveCriticalSection

; 2315 : 
; 2316 :     // We are closed
; 2317 :     pPdd->open = FALSE;
; 2318 :     // stop power thread
; 2319 :     if (pPdd->hPowerThread != NULL)

  000fc	e5953160	 ldr         r3, [r5, #0x160]
  00100	e5857054	 str         r7, [r5, #0x54]
  00104	e3530000	 cmp         r3, #0
  00108	0a00000a	 beq         |$LN2@HWClose|

; 2320 :     {
; 2321 :         pPdd->bExitPowerThread = TRUE;
; 2322 :         SetEvent(pPdd->hPowerEvent);

  0010c	e595015c	 ldr         r0, [r5, #0x15C]
  00110	e3a03001	 mov         r3, #1
  00114	e3a01003	 mov         r1, #3
  00118	e5853164	 str         r3, [r5, #0x164]
  0011c	eb000000	 bl          EventModify

; 2323 :         WaitForSingleObject(pPdd->hPowerThread, INFINITE);

  00120	e5950160	 ldr         r0, [r5, #0x160]
  00124	e1a01006	 mov         r1, r6
  00128	eb000000	 bl          WaitForSingleObject

; 2324 :         CloseHandle(pPdd->hPowerThread);

  0012c	e5950160	 ldr         r0, [r5, #0x160]
  00130	eb000000	 bl          CloseHandle

; 2325 :         pPdd->hPowerThread = NULL;

  00134	e5857160	 str         r7, [r5, #0x160]
  00138		 |$LN2@HWClose|

; 2326 :     }
; 2327 : 
; 2328 :     if (pPdd->hPowerEvent != NULL)

  00138	e595315c	 ldr         r3, [r5, #0x15C]
  0013c	e3530000	 cmp         r3, #0

; 2329 :     {
; 2330 :         CloseHandle(pPdd->hPowerEvent);

  00140	11a00003	 movne       r0, r3
  00144	1b000000	 blne        CloseHandle

; 2331 :     }
; 2332 :     // put uart in force Idle as power thread is exited.
; 2333 :     OUTREG8(
; 2334 :     &pPdd->pUartRegs->SYSC,
; 2335 :     // turn on force idle, to allow full retention
; 2336 :      UART_SYSC_IDLE_FORCE|UART_SYSC_WAKEUP_ENABLE|UART_SYSC_AUTOIDLE
; 2337 :     );

  00148	e5953024	 ldr         r3, [r5, #0x24]
  0014c	e3a02005	 mov         r2, #5

; 2338 : 
; 2339 :     // Set hardware to D3
; 2340 :     pPdd->externalDX = D3;

  00150	e3a01003	 mov         r1, #3
  00154	e5c32054	 strb        r2, [r3, #0x54]
  00158	e5851034	 str         r1, [r5, #0x34]

; 2341 :     SetPower(pPdd, D3);

  0015c	e3a01003	 mov         r1, #3
  00160	e1a00005	 mov         r0, r5
  00164	eb000000	 bl          SetPower

; 2342 : 
; 2343 : 
; 2344 :     rc = 0;

  00168	e3a06000	 mov         r6, #0
  0016c		 |$cleanUp$45519|

; 2345 : 
; 2346 : cleanUp:
; 2347 :     DEBUGMSG(ZONE_CLOSE||ZONE_FUNCTION, (L"-HWClose(%d)\r\n", rc));
; 2348 :     return rc;
; 2349 : 
; 2350 : }

  0016c	e1a00006	 mov         r0, r6
  00170	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00174	e12fff1e	 bx          lr
  00178		 |$M47351|

			 ENDP  ; |HWClose|

; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\inc\omap_sdma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T47417| DCD	|$LN57@HWGetInter|
	DCD	0x4000a502
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\uart\pdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWGetInterruptType| PROC

; 2365 : {

  00000		 |$LN57@HWGetInter|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M47414|
  00008	e1a04000	 mov         r4, r0

; 2366 :     UARTPDD *pPdd = (UARTPDD *)pvContext;
; 2367 :     INTERRUPT_TYPE type = INTR_NONE;
; 2368 :     UCHAR intCause = 0, mask = 0;
; 2369 : 
; 2370 :     RETAILMSG(FALSE, (
; 2371 :         L"+HWGetInterruptType(0x%08x)\r\n",
; 2372 :         pvContext
; 2373 :         ));
; 2374 : 
; 2375 :     // We must solve special wakeup mode
; 2376 :     if (pPdd->wakeUpMode)

  0000c	e5943080	 ldr         r3, [r4, #0x80]
  00010	e3a05000	 mov         r5, #0
  00014	e3530000	 cmp         r3, #0
  00018	0a000006	 beq         |$LN27@HWGetInter|

; 2377 :     {
; 2378 :         if (!pPdd->wakeUpSignaled)

  0001c	e5943084	 ldr         r3, [r4, #0x84]
  00020	e3530000	 cmp         r3, #0
  00024	1a000096	 bne         |$cleanUp$45545|

; 2379 :         {
; 2380 :             type = INTR_RX;
; 2381 :             pPdd->wakeUpSignaled = TRUE;

  00028	e3a03001	 mov         r3, #1
  0002c	e5843084	 str         r3, [r4, #0x84]
  00030	e3a05002	 mov         r5, #2

; 2382 :         }
; 2383 :         goto cleanUp;

  00034	ea000092	 b           |$cleanUp$45545|
  00038		 |$LN27@HWGetInter|

; 2384 :     }
; 2385 :     // if there is no open handle then power is in D3 state
; 2386 :     // avoid exceptions
; 2387 :     if (pPdd->open == FALSE){

  00038	e5943054	 ldr         r3, [r4, #0x54]
  0003c	e3530000	 cmp         r3, #0
  00040	0a00008f	 beq         |$cleanUp$45545|

; 2388 :         goto cleanUp;
; 2389 :     }
; 2390 : 
; 2391 :     EnterCriticalSection(&pPdd->hwCS);

  00044	e2840098	 add         r0, r4, #0x98
  00048	eb000000	 bl          EnterCriticalSection

; 2392 : 
; 2393 :     if ((pPdd->currentDX == D3) || (pPdd->currentDX == D4))

  0004c	e5943030	 ldr         r3, [r4, #0x30]
  00050	e3530003	 cmp         r3, #3
  00054	0a000088	 beq         |$LN23@HWGetInter|
  00058	e3530004	 cmp         r3, #4
  0005c	0a000086	 beq         |$LN23@HWGetInter|

; 2401 :     goto cleanUp;
; 2402 :     }
; 2403 : 
; 2404 :     // Get cause from hardware
; 2405 :     intCause = INREG8(&pPdd->pUartRegs->IIR);

  00060	e5943024	 ldr         r3, [r4, #0x24]
  00064	e5d36008	 ldrb        r6, [r3, #8]

; 2406 :     mask  = INREG8(&pPdd->pUartRegs->IER);

  00068	e5d33004	 ldrb        r3, [r3, #4]

; 2407 :     
; 2408 :     if ((intCause & UART_IIR_IT_PENDING) == 0) {

  0006c	e3160001	 tst         r6, #1
  00070	1a00000c	 bne         |$LN20@HWGetInter|

; 2409 :         switch (intCause & 0x3F)

  00074	e216303f	 ands        r3, r6, #0x3F
  00078	0a000009	 beq         |$LN16@HWGetInter|
  0007c	e3530002	 cmp         r3, #2
  00080	0a00004c	 beq         |$LN19@HWGetInter|
  00084	e3530004	 cmp         r3, #4
  00088	0a000048	 beq         |$LN18@HWGetInter|
  0008c	e3530006	 cmp         r3, #6
  00090	0a00003a	 beq         |$LN15@HWGetInter|
  00094	e353000c	 cmp         r3, #0xC
  00098	0a000044	 beq         |$LN18@HWGetInter|
  0009c	e3530014	 cmp         r3, #0x14
  000a0	1a000000	 bne         |$LN20@HWGetInter|
  000a4		 |$LN16@HWGetInter|

; 2417 :         case UART_IIR_TO:
; 2418 :             type = INTR_RX;
; 2419 :             break;
; 2420 :         case UART_IIR_MODEM:
; 2421 :         case UART_IIR_CTSRTS:
; 2422 :             type = INTR_MODEM;

  000a4	e3a05008	 mov         r5, #8
  000a8		 |$LN20@HWGetInter|

; 2431 :         }
; 2432 : 
; 2433 :     }
; 2434 : 
; 2435 :     LeaveCriticalSection(&pPdd->hwCS);

  000a8	e2840098	 add         r0, r4, #0x98
  000ac	eb000000	 bl          LeaveCriticalSection

; 2436 : 
; 2437 :     // Add software TX interrupt to resume send
; 2438 :     if (pPdd->addTxIntr)

  000b0	e594308c	 ldr         r3, [r4, #0x8C]
  000b4	e3a07000	 mov         r7, #0
  000b8	e3530000	 cmp         r3, #0

; 2439 :     {
; 2440 :         //RETAILMSG(1, (TEXT("Add software TX interrupt to resume send")));
; 2441 :         type |= INTR_TX;
; 2442 :         pPdd->addTxIntr = FALSE;
; 2443 :     }
; 2444 : 
; 2445 :     if (pPdd->RxDmaInfo == NULL)

  000bc	e5943124	 ldr         r3, [r4, #0x124]
  000c0	13855004	 orrne       r5, r5, #4
  000c4	1584708c	 strne       r7, [r4, #0x8C]
  000c8	e3530000	 cmp         r3, #0
  000cc	0a00006c	 beq         |$cleanUp$45545|

; 2446 :     {
; 2447 :         goto cleanUp;
; 2448 :     }
; 2449 : 
; 2450 :     //RX DMA processing
; 2451 :     if ((intCause & 0x3F) == UART_IIR_TO)

  000d0	e206303f	 and         r3, r6, #0x3F
  000d4	e353000c	 cmp         r3, #0xC
  000d8	1a000038	 bne         |$LN11@HWGetInter|

; 2452 :     {
; 2453 :         // UART_RegDump(pPdd);
; 2454 : 
; 2455 :         EnterCriticalSection(&pPdd->RxUpdatePtrCS);

  000dc	e28400c0	 add         r0, r4, #0xC0
  000e0	eb000000	 bl          EnterCriticalSection

; 2456 : 
; 2457 :         SetAutoIdle(pPdd, FALSE);

  000e4	e3a01000	 mov         r1, #0
  000e8	e1a00004	 mov         r0, r4
  000ec	eb000000	 bl          SetAutoIdle

; 2458 : 
; 2459 :         pPdd->bRxDMASignaled = FALSE;
; 2460 :         if (RxDmaStop(pPdd, FALSE) == TRUE)

  000f0	e5940124	 ldr         r0, [r4, #0x124]
  000f4	e5847144	 str         r7, [r4, #0x144]
  000f8	e3a06000	 mov         r6, #0
  000fc	eb000000	 bl          DmaStop
  00100	e5943124	 ldr         r3, [r4, #0x124]
  00104	e5931014	 ldr         r1, [r3, #0x14]
  00108	e593000c	 ldr         r0, [r3, #0xC]
  0010c	e593e004	 ldr         lr, [r3, #4]
  00110	e5913038	 ldr         r3, [r1, #0x38]
  00114	e0433000	 sub         r3, r3, r0
  00118	e08e1003	 add         r1, lr, r3
  0011c		 |$LL37@HWGetInter|
  0011c	e5942024	 ldr         r2, [r4, #0x24]
  00120	e5d23014	 ldrb        r3, [r2, #0x14]
  00124	e3130001	 tst         r3, #1
  00128	0a000004	 beq         |$LN36@HWGetInter|
  0012c	e5d23000	 ldrb        r3, [r2]
  00130	e7c13006	 strb        r3, [r1, +r6]
  00134	e2866001	 add         r6, r6, #1
  00138	e356003f	 cmp         r6, #0x3F
  0013c	3afffff6	 bcc         |$LL37@HWGetInter|
  00140		 |$LN36@HWGetInter|
  00140	e1a02006	 mov         r2, r6
  00144	e3a01000	 mov         r1, #0
  00148	e1a00004	 mov         r0, r4
  0014c	eb000000	 bl          UpdateDMARxPointer
  00150	e3500001	 cmp         r0, #1
  00154	1a000007	 bne         |$LN10@HWGetInter|

; 2461 :         {
; 2462 :             DEBUGMSG(TESTENABLE, (L"+HWGetInterruptType Starting DMA\r\n"));
; 2463 : 
; 2464 :             SetAutoIdle(pPdd, TRUE);

  00158	e3a01001	 mov         r1, #1
  0015c	e1a00004	 mov         r0, r4
  00160	eb000000	 bl          SetAutoIdle
  00164		 |$LN54@HWGetInter|

; 2465 :             DmaStart(pPdd->RxDmaInfo);

  00164	e5943124	 ldr         r3, [r4, #0x124]
  00168	e5932014	 ldr         r2, [r3, #0x14]
  0016c	e5923000	 ldr         r3, [r2]
  00170	e3833080	 orr         r3, r3, #0x80
  00174	e5823000	 str         r3, [r2]
  00178		 |$LN10@HWGetInter|

; 2466 :         }
; 2467 :         else
; 2468 :             {
; 2469 :             DEBUGMSG(ZONE_ERROR, (L"ERROR: HWGetInterruptType: UpdateDMARxPointer failed!!\r\n"));
; 2470 :             }
; 2471 :         LeaveCriticalSection(&pPdd->RxUpdatePtrCS);

  00178	e28400c0	 add         r0, r4, #0xC0

; 2472 :         }
; 2473 :         // check if we need to start dma
; 2474 :     else 

  0017c	ea00003f	 b           |$LN51@HWGetInter|
  00180		 |$LN15@HWGetInter|

; 2423 :             break;
; 2424 :         case UART_IIR_LINE:
; 2425 :             type = INTR_LINE;
; 2426 :         if (IsDmaEnable(pPdd->RxDmaInfo) == FALSE)

  00180	e5943124	 ldr         r3, [r4, #0x124]
  00184	e3a05001	 mov         r5, #1
  00188	e3530000	 cmp         r3, #0
  0018c	0a000005	 beq         |$LN31@HWGetInter|
  00190	e5933014	 ldr         r3, [r3, #0x14]
  00194	e5933000	 ldr         r3, [r3]
  00198	e58d3000	 str         r3, [sp]
  0019c	e59d3000	 ldr         r3, [sp]
  001a0	e3130080	 tst         r3, #0x80
  001a4	1affffbf	 bne         |$LN20@HWGetInter|
  001a8		 |$LN31@HWGetInter|

; 2427 :         {
; 2428 :             type |= INTR_RX;

  001a8	e3a05003	 mov         r5, #3

; 2429 :         }
; 2430 :             break;

  001ac	eaffffbd	 b           |$LN20@HWGetInter|
  001b0		 |$LN18@HWGetInter|

; 2414 :         case UART_IIR_RHR:
; 2415 :         type = INTR_RX;

  001b0	e3a05002	 mov         r5, #2

; 2416 :         break;

  001b4	eaffffbb	 b           |$LN20@HWGetInter|
  001b8		 |$LN19@HWGetInter|

; 2410 :         {
; 2411 :         case UART_IIR_THR:
; 2412 :             type = INTR_TX;

  001b8	e3a05004	 mov         r5, #4

; 2413 :             break;

  001bc	eaffffb9	 b           |$LN20@HWGetInter|
  001c0		 |$LN11@HWGetInter|

; 2475 :         {
; 2476 :         if (!pPdd->RxDmaInfo)
; 2477 :         {
; 2478 :             goto cleanUp;
; 2479 :         }
; 2480 : 
; 2481 :         if (pPdd->bRxDMASignaled == TRUE)

  001c0	e5943144	 ldr         r3, [r4, #0x144]
  001c4	e3530001	 cmp         r3, #1

; 2482 :         {
; 2483 :             pPdd->bRxDMASignaled = FALSE;

  001c8	05847144	 streq       r7, [r4, #0x144]
  001cc	03a05002	 moveq       r5, #2
  001d0	0a00002b	 beq         |$cleanUp$45545|

; 2484 :             type = INTR_RX;
; 2485 :             goto cleanUp;
; 2486 :         }
; 2487 : 
; 2488 :         if (pPdd->bRxWrapped == TRUE)

  001d4	e5943148	 ldr         r3, [r4, #0x148]
  001d8	e3530001	 cmp         r3, #1

; 2489 :         {
; 2490 :             pPdd->bRxWrapped = FALSE;

  001dc	05847148	 streq       r7, [r4, #0x148]
  001e0	03a05002	 moveq       r5, #2
  001e4	0a000026	 beq         |$cleanUp$45545|

; 2491 :             type = INTR_RX;
; 2492 :             goto cleanUp;
; 2493 :         }
; 2494 : 
; 2495 :         if ((type & INTR_RX) != 0)

  001e8	e3150002	 tst         r5, #2
  001ec	0a000013	 beq         |$LN4@HWGetInter|

; 2496 :         {
; 2497 :             DEBUGMSG(ZONE_FUNCTION, (L"+HWGetInterruptType Starting DMA(INTR_RX)\r\n"));
; 2498 : 
; 2499 :             EnterCriticalSection(&pPdd->RxUpdatePtrCS);

  001f0	e28400c0	 add         r0, r4, #0xC0
  001f4	eb000000	 bl          EnterCriticalSection

; 2500 :             if(UpdateDMARxPointer(pPdd, FALSE, 0)== TRUE)

  001f8	e3a02000	 mov         r2, #0
  001fc	e3a01000	 mov         r1, #0
  00200	e1a00004	 mov         r0, r4
  00204	eb000000	 bl          UpdateDMARxPointer
  00208	e3500001	 cmp         r0, #1
  0020c	1a000009	 bne         |$LN3@HWGetInter|

; 2501 :             {
; 2502 :                 DEBUGMSG(TESTENABLE, (L"+HWGetInterruptType Starting DMA\r\n"));
; 2503 :                 SetAutoIdle(pPdd, TRUE);

  00210	e3a01001	 mov         r1, #1
  00214	e1a00004	 mov         r0, r4
  00218	eb000000	 bl          SetAutoIdle

; 2504 :                 pPdd->bRxDMASignaled = FALSE;
; 2505 :                 DmaStart(pPdd->RxDmaInfo);

  0021c	e5943124	 ldr         r3, [r4, #0x124]
  00220	e5847144	 str         r7, [r4, #0x144]

; 2506 :                 type &= ~INTR_RX;

  00224	e3c55002	 bic         r5, r5, #2
  00228	e5932014	 ldr         r2, [r3, #0x14]
  0022c	e5923000	 ldr         r3, [r2]
  00230	e3833080	 orr         r3, r3, #0x80
  00234	e5823000	 str         r3, [r2]
  00238		 |$LN3@HWGetInter|

; 2507 :             }
; 2508 :             LeaveCriticalSection(&pPdd->RxUpdatePtrCS);

  00238	e28400c0	 add         r0, r4, #0xC0
  0023c	eb000000	 bl          LeaveCriticalSection
  00240		 |$LN4@HWGetInter|

; 2509 :         }
; 2510 : 
; 2511 :         if ((type & INTR_LINE) != 0)

  00240	e3150001	 tst         r5, #1
  00244	0a00000e	 beq         |$cleanUp$45545|

; 2512 :         {
; 2513 :             DEBUGMSG(ZONE_FUNCTION, (L"+HWGetInterruptType Starting DMA(INTR_LINE)\r\n"));
; 2514 :             // UNDONE: need to check if DMA has already be started
; 2515 :             // if so then don't start it again
; 2516 :             EnterCriticalSection(&pPdd->RxUpdatePtrCS);

  00248	e28400c0	 add         r0, r4, #0xC0
  0024c	eb000000	 bl          EnterCriticalSection

; 2517 :             if(UpdateDMARxPointer(pPdd, FALSE, 0)== TRUE)

  00250	e3a02000	 mov         r2, #0
  00254	e3a01000	 mov         r1, #0
  00258	e1a00004	 mov         r0, r4
  0025c	eb000000	 bl          UpdateDMARxPointer
  00260	e3500001	 cmp         r0, #1
  00264	1affffc3	 bne         |$LN10@HWGetInter|

; 2518 :             {
; 2519 :                 DEBUGMSG(TESTENABLE, (L"+HWGetInterruptType Starting DMA\r\n"));
; 2520 :                 SetAutoIdle(pPdd, TRUE);

  00268	e3a01001	 mov         r1, #1
  0026c	e1a00004	 mov         r0, r4
  00270	eb000000	 bl          SetAutoIdle

; 2521 :                 pPdd->bRxDMASignaled = FALSE;
; 2522 :                 DmaStart(pPdd->RxDmaInfo);

  00274	e5847144	 str         r7, [r4, #0x144]

; 2523 : 
; 2524 :             }
; 2525 :             LeaveCriticalSection(&pPdd->RxUpdatePtrCS);

  00278	eaffffb9	 b           |$LN54@HWGetInter|
  0027c		 |$LN23@HWGetInter|

; 2394 :     {
; 2395 :        RETAILMSG(FALSE, (
; 2396 :         L"+HWGetInterruptType D3 (0x%08x)\r\n",
; 2397 :         pvContext
; 2398 :         ));
; 2399 : 
; 2400 :        LeaveCriticalSection(&pPdd->hwCS);

  0027c	e2840098	 add         r0, r4, #0x98
  00280		 |$LN51@HWGetInter|
  00280	eb000000	 bl          LeaveCriticalSection
  00284		 |$cleanUp$45545|

; 2526 :         }
; 2527 :     }
; 2528 : 
; 2529 : cleanUp:
; 2530 :     DEBUGMSG(ZONE_THREAD, (
; 2531 :         L"-HWGetInterruptType(type = %d, cause = %02x)\r\n",
; 2532 :         type, intCause
; 2533 :         ));
; 2534 :     return type;
; 2535 : }

  00284	e1a00005	 mov         r0, r5
  00288	e28dd004	 add         sp, sp, #4
  0028c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00290	e12fff1e	 bx          lr
  00294		 |$M47415|

			 ENDP  ; |HWGetInterruptType|

	EXPORT	|HWRxDMAIntr|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\inc\omap_sdma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T47448| DCD	|$LN29@HWRxDMAInt|
	DCD	0x40005401
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\uart\pdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWRxDMAIntr| PROC

; 2549 : {

  00000		 |$LN29@HWRxDMAInt|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M47445|
  00004	e1a07002	 mov         r7, r2
  00008	e1a08001	 mov         r8, r1
  0000c	e1a06000	 mov         r6, r0

; 2550 :     UARTPDD *pPdd = (UARTPDD *)pvContext;
; 2551 :     //    OMAP_UART_REGS *pUartRegs = pPdd->pUartRegs;
; 2552 :     UCHAR lineStat = 0;
; 2553 :     ULONG count = *pLength;
; 2554 :     UCHAR *pCurrentDMAPos;
; 2555 :     ULONG i;
; 2556 :     //  PHW_INDEP_INFO  pSerialHead = (PHW_INDEP_INFO)pPdd->pMdd;
; 2557 : 
; 2558 :     RETAILMSG(FALSE,(TEXT("HWRxDMAIntr pRxBuffer=0x%x pLength=%d\r\n"),
; 2559 :                 pRxBuffer,
; 2560 :                 *pLength));
; 2561 : 
; 2562 :     pCurrentDMAPos = pPdd->pRxDMALastWrite; // DmaGetLastWritePos(pPdd->RxDmaInfo);
; 2563 : 
; 2564 :     if(pCurrentDMAPos >= ((UCHAR*)pPdd->pRxDmaBuffer + pPdd->RxDmaBufferSize))

  00010	e596e114	 ldr         lr, [r6, #0x114]
  00014	e5963110	 ldr         r3, [r6, #0x110]
  00018	e596014c	 ldr         r0, [r6, #0x14C]
  0001c	e3a09000	 mov         r9, #0
  00020	e08e3003	 add         r3, lr, r3
  00024	e1500003	 cmp         r0, r3
  00028	3a000008	 bcc         |$LN15@HWRxDMAInt|

; 2565 :     {
; 2566 :         Sleep(0);

  0002c	e3a00000	 mov         r0, #0
  00030	eb000000	 bl          Sleep

; 2567 :         pCurrentDMAPos = DmaGetLastWritePos(pPdd->RxDmaInfo);

  00034	e5963124	 ldr         r3, [r6, #0x124]
  00038	e593e014	 ldr         lr, [r3, #0x14]
  0003c	e593400c	 ldr         r4, [r3, #0xC]
  00040	e5935004	 ldr         r5, [r3, #4]
  00044	e59e3038	 ldr         r3, [lr, #0x38]
  00048	e0433004	 sub         r3, r3, r4
  0004c	e0850003	 add         r0, r5, r3
  00050		 |$LN15@HWRxDMAInt|

; 2568 :     }
; 2569 :     if (pCurrentDMAPos >= pRxBuffer)

  00050	e1500008	 cmp         r0, r8
  00054	3a000007	 bcc         |$LN14@HWRxDMAInt|

; 2570 :     {
; 2571 :         if (pCurrentDMAPos >= ((UCHAR*)pPdd->pRxDmaBuffer + pPdd->RxDmaBufferSize))

  00058	e5962114	 ldr         r2, [r6, #0x114]
  0005c	e5963110	 ldr         r3, [r6, #0x110]
  00060	e0823003	 add         r3, r2, r3
  00064	e1500003	 cmp         r0, r3

; 2572 :         {
; 2573 :             count = 0;

  00068	23a04000	 movcs       r4, #0
  0006c	2a00000a	 bcs         |$LN18@HWRxDMAInt|

; 2574 :         }
; 2575 :         else
; 2576 :         {
; 2577 :         count = pCurrentDMAPos - pRxBuffer;

  00070	e0404008	 sub         r4, r0, r8

; 2578 :     }
; 2579 :     }
; 2580 :     else

  00074	ea000005	 b           |$LN11@HWRxDMAInt|
  00078		 |$LN14@HWRxDMAInt|

; 2581 :     {
; 2582 :         pPdd->bSendSignal = TRUE;
; 2583 :         count = pPdd->RxDmaBufferSize - (pRxBuffer - (UCHAR*)pPdd->pRxDmaBuffer);

  00078	e5963114	 ldr         r3, [r6, #0x114]
  0007c	e5962110	 ldr         r2, [r6, #0x110]
  00080	e3a01001	 mov         r1, #1
  00084	e0433008	 sub         r3, r3, r8
  00088	e0834002	 add         r4, r3, r2
  0008c	e5861134	 str         r1, [r6, #0x134]
  00090		 |$LN11@HWRxDMAInt|

; 2584 :     }
; 2585 : 
; 2586 :     // the mdd will specify maximum space available.  Since we don't account for
; 2587 :     // the last read position at the MDD layer don't go beyond what is in pLength
; 2588 :     *pLength = min(*pLength, count);

  00090	e5973000	 ldr         r3, [r7]
  00094	e1530004	 cmp         r3, r4
  00098	3a000000	 bcc         |$LN19@HWRxDMAInt|
  0009c		 |$LN18@HWRxDMAInt|
  0009c	e1a03004	 mov         r3, r4
  000a0		 |$LN19@HWRxDMAInt|
  000a0	e5873000	 str         r3, [r7]

; 2589 :     DEBUGMSG(TESTENABLE, (L"+HWRxDMAIntr Count= %d\r\n",count));
; 2590 :     // With DMA we lose synchronization with UART error to an individual byte
; 2591 :     // Could apply disposition to all bytes in buffer?
; 2592 :     if(pPdd->open == TRUE)

  000a4	e5963054	 ldr         r3, [r6, #0x54]
  000a8	e3530001	 cmp         r3, #1
  000ac	1a000002	 bne         |$LN10@HWRxDMAInt|

; 2593 :     {
; 2594 :         lineStat = ReadLineStat(pPdd);

  000b0	e1a00006	 mov         r0, r6
  000b4	eb000000	 bl          ReadLineStat
  000b8	e1a09000	 mov         r9, r0
  000bc		 |$LN10@HWRxDMAInt|

; 2595 :     }
; 2596 :     // Replace char with parity error
; 2597 :     if ((pPdd->dcb.fErrorChar != '\0') &&
; 2598 :         pPdd->dcb.fParity &&
; 2599 :         ((lineStat & UART_LSR_RX_PE) != 0))

  000bc	e5963060	 ldr         r3, [r6, #0x60]
  000c0	e3130b01	 tst         r3, #1, 22
  000c4	0a00000e	 beq         |$LN9@HWRxDMAInt|
  000c8	e3130002	 tst         r3, #2
  000cc	0a00000c	 beq         |$LN9@HWRxDMAInt|
  000d0	e3190004	 tst         r9, #4
  000d4	0a00000a	 beq         |$LN9@HWRxDMAInt|

; 2600 :     {
; 2601 :         for (i=0; i < *pLength; i++)

  000d8	e5973000	 ldr         r3, [r7]
  000dc	e3a02000	 mov         r2, #0
  000e0	e3530000	 cmp         r3, #0
  000e4	9a000016	 bls         |$LN2@HWRxDMAInt|
  000e8		 |$LL8@HWRxDMAInt|

; 2602 :             *(pRxBuffer+i) = pPdd->dcb.ErrorChar;

  000e8	e1d636df	 ldrsb       r3, [r6, #0x6F]
  000ec	e7c23008	 strb        r3, [r2, +r8]
  000f0	e5973000	 ldr         r3, [r7]
  000f4	e2822001	 add         r2, r2, #1
  000f8	e1520003	 cmp         r2, r3
  000fc	3afffff9	 bcc         |$LL8@HWRxDMAInt|

; 2603 :     }
; 2604 :     else

  00100	ea00000f	 b           |$LN2@HWRxDMAInt|
  00104		 |$LN9@HWRxDMAInt|

; 2605 :     {
; 2606 :         for (i=0; i < *pLength; i++)

  00104	e5973000	 ldr         r3, [r7]
  00108	e3a02000	 mov         r2, #0
  0010c	e3530000	 cmp         r3, #0
  00110	9a00000b	 bls         |$LN2@HWRxDMAInt|
  00114	e1d617d1	 ldrsb       r1, [r6, #0x71]
  00118		 |$LL4@HWRxDMAInt|

; 2607 :         {
; 2608 :             // See if we need to generate an EV_RXFLAG
; 2609 :             if (*(pRxBuffer+i) == pPdd->dcb.EvtChar)

  00118	e7d23008	 ldrb        r3, [r2, +r8]
  0011c	e1530001	 cmp         r3, r1
  00120	0a000004	 beq         |$LN24@HWRxDMAInt|
  00124	e5973000	 ldr         r3, [r7]
  00128	e2822001	 add         r2, r2, #1
  0012c	e1520003	 cmp         r2, r3
  00130	3afffff8	 bcc         |$LL4@HWRxDMAInt|
  00134	ea000002	 b           |$LN2@HWRxDMAInt|
  00138		 |$LN24@HWRxDMAInt|

; 2610 :             {
; 2611 :                 EvaluateEventFlag(pPdd->pMdd, EV_RXFLAG);

  00138	e5960050	 ldr         r0, [r6, #0x50]
  0013c	e3a01002	 mov         r1, #2
  00140	eb000000	 bl          EvaluateEventFlag
  00144		 |$LN2@HWRxDMAInt|

; 2612 :                 break;
; 2613 :             }
; 2614 :         }
; 2615 : 
; 2616 :     }
; 2617 : 
; 2618 :     return count;
; 2619 : 
; 2620 : }

  00144	e1a00004	 mov         r0, r4
  00148	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  0014c	e12fff1e	 bx          lr
  00150		 |$M47446|

			 ENDP  ; |HWRxDMAIntr|

	EXPORT	|HWRxNoDMAIntr|

  00000			 AREA	 |.pdata|, PDATA
|$T47475| DCD	|$LN22@HWRxNoDMAI|
	DCD	0x40004002
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWRxNoDMAIntr| PROC

; 2625 : {

  00000		 |$LN22@HWRxNoDMAI|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M47472|
  00008	e1a0a002	 mov         r10, r2
  0000c	e1a0b001	 mov         r11, r1
  00010	e1a04000	 mov         r4, r0

; 2626 :     UARTPDD *pPdd = (UARTPDD *)pvContext;
; 2627 :     OMAP_UART_REGS *pUartRegs = pPdd->pUartRegs;
; 2628 :     ULONG count = *pLength;
; 2629 :     UCHAR lineStat, rxChar;
; 2630 :     BOOL rxFlag, replaceParityError;
; 2631 : 
; 2632 :     *pLength = 0;

  00014	e5946024	 ldr         r6, [r4, #0x24]
  00018	e59a5000	 ldr         r5, [r10]
  0001c	e3a03000	 mov         r3, #0
  00020	e58a3000	 str         r3, [r10]

; 2633 :     rxFlag = FALSE;
; 2634 :     replaceParityError = (pPdd->dcb.fErrorChar != '\0') && pPdd->dcb.fParity;

  00024	e5943060	 ldr         r3, [r4, #0x60]

; 2635 :     SetAutoIdle(pPdd, TRUE);

  00028	e3a01001	 mov         r1, #1
  0002c	e1a00004	 mov         r0, r4
  00030	e3130b01	 tst         r3, #1, 22
  00034	13130002	 tstne       r3, #2
  00038	13a08001	 movne       r8, #1
  0003c	03a08000	 moveq       r8, #0
  00040	e58d6000	 str         r6, [sp]
  00044	e3a09000	 mov         r9, #0
  00048	eb000000	 bl          SetAutoIdle
  0004c	ea00001e	 b           |$LN19@HWRxNoDMAI|
  00050		 |$LL8@HWRxNoDMAI|

; 2637 :     {
; 2638 :         // Get line status register
; 2639 :         lineStat = ReadLineStat(pPdd);

  00050	e1a00004	 mov         r0, r4
  00054	eb000000	 bl          ReadLineStat
  00058	e1a07000	 mov         r7, r0

; 2640 :         // If there isn't more chars exit loop
; 2641 :         if ((lineStat & UART_LSR_RX_FIFO_E) == 0) break;

  0005c	e3170001	 tst         r7, #1
  00060	0a00001b	 beq         |$LN18@HWRxNoDMAI|

; 2642 : 
; 2643 :         // Get received char
; 2644 :         rxChar = INREG8(&pUartRegs->RHR);
; 2645 :         // Ignore char in DSR is low and we care about it
; 2646 :         if (pPdd->dcb.fDsrSensitivity &&
; 2647 :             ((ReadModemStat(pPdd) & UART_MSR_NDSR) == 0))

  00064	e5943060	 ldr         r3, [r4, #0x60]
  00068	e5d66000	 ldrb        r6, [r6]
  0006c	e3130040	 tst         r3, #0x40
  00070	0a000003	 beq         |$LN5@HWRxNoDMAI|
  00074	e1a00004	 mov         r0, r4
  00078	eb000000	 bl          ReadModemStat
  0007c	e3100020	 tst         r0, #0x20
  00080	0a000010	 beq         |$LN17@HWRxNoDMAI|
  00084		 |$LN5@HWRxNoDMAI|

; 2648 :         {
; 2649 :             continue;
; 2650 :         }
; 2651 : 
; 2652 :         // Ignore NUL char if requested
; 2653 :         if ((rxChar == '\0') && pPdd->dcb.fNull) continue;

  00084	e3560000	 cmp         r6, #0
  00088	1a000002	 bne         |$LN4@HWRxNoDMAI|
  0008c	e5943060	 ldr         r3, [r4, #0x60]
  00090	e3130b02	 tst         r3, #2, 22
  00094	1a00000b	 bne         |$LN17@HWRxNoDMAI|
  00098		 |$LN4@HWRxNoDMAI|

; 2654 : 
; 2655 :         // Replace char with parity error
; 2656 :         if (replaceParityError && ((lineStat & UART_LSR_RX_PE) != 0))

  00098	e3580000	 cmp         r8, #0
  0009c	13170004	 tstne       r7, #4

; 2657 :         {
; 2658 :             rxChar = pPdd->dcb.ErrorChar;

  000a0	15d4306f	 ldrneb      r3, [r4, #0x6F]

; 2659 :         }
; 2660 :         // See if we need to generate an EV_RXFLAG
; 2661 :         if (rxChar == pPdd->dcb.EvtChar) rxFlag = TRUE;
; 2662 : 
; 2663 :         // Store it to buffer
; 2664 :         *pRxBuffer++ = rxChar;
; 2665 :         (*pLength)++;
; 2666 :         count--;

  000a4	e2455001	 sub         r5, r5, #1
  000a8	11a06003	 movne       r6, r3
  000ac	e1d437d1	 ldrsb       r3, [r4, #0x71]
  000b0	e4cb6001	 strb        r6, [r11], #1
  000b4	e1560003	 cmp         r6, r3
  000b8	e59a3000	 ldr         r3, [r10]
  000bc	03a09001	 moveq       r9, #1
  000c0	e2833001	 add         r3, r3, #1
  000c4	e58a3000	 str         r3, [r10]
  000c8		 |$LN17@HWRxNoDMAI|

; 2636 :     while (count > 0)

  000c8	e59d6000	 ldr         r6, [sp]
  000cc		 |$LN19@HWRxNoDMAI|
  000cc	e3550000	 cmp         r5, #0
  000d0	1affffde	 bne         |$LL8@HWRxNoDMAI|
  000d4		 |$LN18@HWRxNoDMAI|

; 2667 :     }
; 2668 :     SetAutoIdle(pPdd, FALSE);

  000d4	e3a01000	 mov         r1, #0
  000d8	e1a00004	 mov         r0, r4
  000dc	eb000000	 bl          SetAutoIdle

; 2669 : 
; 2670 :     // Send event to MDD
; 2671 :     if (rxFlag) EvaluateEventFlag(pPdd->pMdd, EV_RXFLAG);

  000e0	e3590000	 cmp         r9, #0
  000e4	15940050	 ldrne       r0, [r4, #0x50]
  000e8	13a01002	 movne       r1, #2
  000ec	1b000000	 blne        EvaluateEventFlag

; 2672 : 
; 2673 :     return count;
; 2674 : }

  000f0	e1a00005	 mov         r0, r5
  000f4	e28dd004	 add         sp, sp, #4
  000f8	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  000fc	e12fff1e	 bx          lr
  00100		 |$M47473|

			 ENDP  ; |HWRxNoDMAIntr|


  00000			 AREA	 |.pdata|, PDATA
|$T47488| DCD	|$LN9@HWRxIntr|
	DCD	0x40001e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWRxIntr| PROC

; 2688 : {

  00000		 |$LN9@HWRxIntr|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M47485|
  00004	e1a04000	 mov         r4, r0

; 2689 :     UARTPDD *pPdd = (UARTPDD *)pvContext;
; 2690 :     ULONG count;
; 2691 :     DEBUGMSG(ZONE_THREAD, (
; 2692 :         L"+HWRxIntr(0x%08x, 0x%08x, %d)\r\n", pvContext, pRxBuffer,
; 2693 :         *pLength
; 2694 :         ));
; 2695 : 
; 2696 : 
; 2697 :     // Somehow BT driver was trying to read data after setting the UART to D3 and causing
; 2698 :     // UART driver to crash in this routine. Check the power state before doing anything.
; 2699 :     if (pPdd->currentDX >= D3)

  00008	e5943030	 ldr         r3, [r4, #0x30]
  0000c	e3530003	 cmp         r3, #3

; 2700 :     {
; 2701 :         *pLength = 0;

  00010	a3a03000	 movge       r3, #0
  00014	a5823000	 strge       r3, [r2]

; 2702 :         count = 0;

  00018	a3a00000	 movge       r0, #0

; 2724 : 
; 2725 : cleanUp:
; 2726 :     DEBUGMSG(ZONE_THREAD, (
; 2727 :         L"-HWRxIntr(count = %d, length = %d)\r\n", count, *pLength
; 2728 :         ));
; 2729 :     return count;
; 2730 : }

  0001c	a8bd4010	 ldmgeia     sp!, {r4, lr}
  00020	a12fff1e	 bxge        lr

; 2703 :         goto cleanUp;
; 2704 :     }
; 2705 : 
; 2706 :     // Check to see if we are in wake up mode. If so we will
; 2707 :     // just report one character we have received a byte.
; 2708 :     if (pPdd->wakeUpMode)

  00024	e5943080	 ldr         r3, [r4, #0x80]
  00028	e3530000	 cmp         r3, #0

; 2709 :     {
; 2710 :         *pRxBuffer = (UCHAR)pPdd->wakeUpChar;

  0002c	1594301c	 ldrne       r3, [r4, #0x1C]

; 2711 :         *pLength = 1;

  00030	13a0e001	 movne       lr, #1

; 2712 :         count = 0;

  00034	13a00000	 movne       r0, #0
  00038	15c13000	 strneb      r3, [r1]
  0003c	1582e000	 strne       lr, [r2]

; 2724 : 
; 2725 : cleanUp:
; 2726 :     DEBUGMSG(ZONE_THREAD, (
; 2727 :         L"-HWRxIntr(count = %d, length = %d)\r\n", count, *pLength
; 2728 :         ));
; 2729 :     return count;
; 2730 : }

  00040	18bd4010	 ldmneia     sp!, {r4, lr}
  00044	112fff1e	 bxne        lr

; 2713 :         goto cleanUp;
; 2714 :     }
; 2715 : 
; 2716 :     if (pPdd->RxDmaInfo)

  00048	e5943124	 ldr         r3, [r4, #0x124]
  0004c	e3530000	 cmp         r3, #0

; 2717 :         HWRxDMAIntr(pvContext, pRxBuffer, pLength);

  00050	e1a00004	 mov         r0, r4

; 2713 :         goto cleanUp;
; 2714 :     }
; 2715 : 
; 2716 :     if (pPdd->RxDmaInfo)

  00054	0a000001	 beq         |$LN2@HWRxIntr|

; 2717 :         HWRxDMAIntr(pvContext, pRxBuffer, pLength);

  00058	eb000000	 bl          HWRxDMAIntr

; 2718 :     else

  0005c	ea000000	 b           |$LN1@HWRxIntr|
  00060		 |$LN2@HWRxIntr|

; 2719 :         HWRxNoDMAIntr(pvContext, pRxBuffer, pLength);

  00060	eb000000	 bl          HWRxNoDMAIntr
  00064		 |$LN1@HWRxIntr|

; 2720 : 
; 2721 :     // Clear overrun counter and use this value as return code
; 2722 :     count = pPdd->overrunCount;
; 2723 :     pPdd->overrunCount = 0;

  00064	e5940078	 ldr         r0, [r4, #0x78]
  00068	e3a03000	 mov         r3, #0
  0006c	e5843078	 str         r3, [r4, #0x78]
  00070		 |$cleanUp$45654|

; 2724 : 
; 2725 : cleanUp:
; 2726 :     DEBUGMSG(ZONE_THREAD, (
; 2727 :         L"-HWRxIntr(count = %d, length = %d)\r\n", count, *pLength
; 2728 :         ));
; 2729 :     return count;
; 2730 : }

  00070	e8bd4010	 ldmia       sp!, {r4, lr}
  00074	e12fff1e	 bx          lr
  00078		 |$M47486|

			 ENDP  ; |HWRxIntr|

	EXPORT	|??_C@_1DA@OODNCMGJ@?$AAT?$AAX?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?5?$AAi?$AAs?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1IC@MEFBLOON@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAI?$AAS?$AAT?$AA_?$AAT?$AAx?$AAD?$AAM?$AAA?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAS?$AAi?$AAg?$AAn@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CC@PKKAGKLP@?$AAT?$AAX?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CA@GNIAGCLB@?$AAT?$AAX?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DE@BIEHKFMC@?$AA?$CB?$AA?$CB?$AA?$CB?$AA?$CB?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?5?$AAi?$AAs?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GM@FFDJCNJM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAS?$AAi?$AAg?$AAn?$AAa?$AAl?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAT?$AAX?$AA?5?$AAi@| [ DATA ] ; `string'
	IMPORT	|CeSafeCopyMemory|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\inc\omap_sdma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T47576| DCD	|$LN72@HWTxIntr|
	DCD	0x4000dc02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DA@OODNCMGJ@?$AAT?$AAX?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?5?$AAi?$AAs?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "T"
	DCB	0x0, "X", 0x0, " ", 0x0, "D", 0x0, "M", 0x0, "A", 0x0, " "
	DCB	0x0, "S", 0x0, "t", 0x0, "a", 0x0, "t", 0x0, "u", 0x0, "s"
	DCB	0x0, " ", 0x0, "i", 0x0, "s", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1IC@MEFBLOON@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAI?$AAS?$AAT?$AA_?$AAT?$AAx?$AAD?$AAM?$AAA?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAS?$AAi?$AAg?$AAn@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "I", 0x0, "S", 0x0, "T", 0x0, "_", 0x0, "T", 0x0, "x"
	DCB	0x0, "D", 0x0, "M", 0x0, "A", 0x0, ":", 0x0, " ", 0x0, "F"
	DCB	0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, " "
	DCB	0x0, "t", 0x0, "o", 0x0, " ", 0x0, "S", 0x0, "i", 0x0, "g"
	DCB	0x0, "n", 0x0, "a", 0x0, "l", 0x0, " ", 0x0, "D", 0x0, "M"
	DCB	0x0, "A", 0x0, " ", 0x0, "T", 0x0, "X", 0x0, " ", 0x0, "i"
	DCB	0x0, "n", 0x0, "t", 0x0, "e", 0x0, "r", 0x0, "r", 0x0, "u"
	DCB	0x0, "p", 0x0, "t", 0x0, " ", 0x0, "c", 0x0, "o", 0x0, "m"
	DCB	0x0, "p", 0x0, "l", 0x0, "e", 0x0, "t", 0x0, "i", 0x0, "o"
	DCB	0x0, "n", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@PKKAGKLP@?$AAT?$AAX?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AN?$AA?6?$AA?$AA@| DCB "T"
	DCB	0x0, "X", 0x0, " ", 0x0, "D", 0x0, "M", 0x0, "A", 0x0, " "
	DCB	0x0, "t", 0x0, "i", 0x0, "m", 0x0, "e", 0x0, "o", 0x0, "u"
	DCB	0x0, "t", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CA@GNIAGCLB@?$AAT?$AAX?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AN?$AA?6?$AA?$AA@| DCB "T"
	DCB	0x0, "X", 0x0, " ", 0x0, "D", 0x0, "M", 0x0, "A", 0x0, " "
	DCB	0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DE@BIEHKFMC@?$AA?$CB?$AA?$CB?$AA?$CB?$AA?$CB?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?5?$AAi?$AAs?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "!"
	DCB	0x0, "!", 0x0, "!", 0x0, "!", 0x0, " ", 0x0, "D", 0x0, "M"
	DCB	0x0, "A", 0x0, " ", 0x0, "s", 0x0, "t", 0x0, "a", 0x0, "t"
	DCB	0x0, "u", 0x0, "s", 0x0, " ", 0x0, "i", 0x0, "s", 0x0, " "
	DCB	0x0, "0", 0x0, "x", 0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GM@FFDJCNJM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAS?$AAi?$AAg?$AAn?$AAa?$AAl?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAT?$AAX?$AA?5?$AAi@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "F", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "S", 0x0, "i"
	DCB	0x0, "g", 0x0, "n", 0x0, "a", 0x0, "l", 0x0, " ", 0x0, "D"
	DCB	0x0, "M", 0x0, "A", 0x0, " ", 0x0, "T", 0x0, "X", 0x0, " "
	DCB	0x0, "i", 0x0, "n", 0x0, "t", 0x0, "e", 0x0, "r", 0x0, "r"
	DCB	0x0, "u", 0x0, "p", 0x0, "t", 0x0, " ", 0x0, "c", 0x0, "o"
	DCB	0x0, "m", 0x0, "p", 0x0, "l", 0x0, "e", 0x0, "t", 0x0, "i"
	DCB	0x0, "o", 0x0, "n", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\uart\pdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWTxIntr| PROC

; 2746 : {

  00000		 |$LN72@HWTxIntr|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M47573|
  00008	e1a05002	 mov         r5, r2
  0000c	e58d5000	 str         r5, [sp]
  00010	e1a0a001	 mov         r10, r1
  00014	e1a04000	 mov         r4, r0

; 2747 :     UARTPDD *pPdd = (UARTPDD *)pvContext;
; 2748 :     OMAP_UART_REGS *pUartRegs = pPdd->pUartRegs;
; 2749 :     DWORD dwDmaStatus;          // DMA status
; 2750 :     DWORD dwStatus;             // Status
; 2751 :     ULONG BytesToTransfer;      // Actual byte to DMA'd
; 2752 :     UCHAR modemStat;            // Modem status
; 2753 :     DWORD dwCount = 0;          // Dma transfer count
; 2754 :     DWORD size = *pLength;      // Actual Buffer Length
; 2755 :     ULONG TotalTimeout;         // The Total Timeout
; 2756 :     ULONG Timeout;              // The Timeout value actually used
; 2757 : 
; 2758 : 
; 2759 :     DEBUGMSG(ZONE_THREAD, (
; 2760 :         L"+HWTxIntr(0x%08x, 0x%08x, %d)\r\n", pvContext, pTxBuffer,
; 2761 :         *pLength
; 2762 :         ));
; 2763 : 
; 2764 :     // Somehow BT driver was trying to send data after setting the UART to D3 and causing
; 2765 :     // UART driver to crash in this routine. Check the power state before doing anything.
; 2766 :     if (pPdd->currentDX >= D3)

  00018	e5943030	 ldr         r3, [r4, #0x30]
  0001c	e5946024	 ldr         r6, [r4, #0x24]
  00020	e5957000	 ldr         r7, [r5]
  00024	e3530003	 cmp         r3, #3
  00028	ba000002	 blt         |$LN25@HWTxIntr|
  0002c		 |$LN66@HWTxIntr|

; 2767 :     {
; 2768 :         *pLength = 0;

  0002c	e3a03000	 mov         r3, #0
  00030	e5853000	 str         r3, [r5]

; 2769 :         goto cleanUp;

  00034	ea0000c4	 b           |$cleanUp$45680|
  00038		 |$LN25@HWTxIntr|

; 2770 :     }
; 2771 : 
; 2772 :     SetAutoIdle(pPdd, TRUE);

  00038	e3a01001	 mov         r1, #1
  0003c	e1a00004	 mov         r0, r4
  00040	eb000000	 bl          SetAutoIdle

; 2773 : 
; 2774 :     EnterCriticalSection(&pPdd->hwCS);

  00044	e2840098	 add         r0, r4, #0x98
  00048	eb000000	 bl          EnterCriticalSection

; 2775 :     // If there is nothing to send then disable TX interrupt
; 2776 :     if (*pLength == 0)

  0004c	e5953000	 ldr         r3, [r5]
  00050	e3530000	 cmp         r3, #0
  00054	1a000006	 bne         |$LN24@HWTxIntr|

; 2777 :     {
; 2778 :         // Disable TX interrupt
; 2779 :         pPdd->intrMask &= ~UART_IER_THR;

  00058	e5d43088	 ldrb        r3, [r4, #0x88]

; 2780 :         OUTREG8(&pUartRegs->IER, pPdd->intrMask);
; 2781 :         LeaveCriticalSection(&pPdd->hwCS);

  0005c	e20330fd	 and         r3, r3, #0xFD
  00060		 |$LN69@HWTxIntr|
  00060	e2840098	 add         r0, r4, #0x98
  00064	e5c43088	 strb        r3, [r4, #0x88]
  00068	e5c63004	 strb        r3, [r6, #4]
  0006c	eb000000	 bl          LeaveCriticalSection

; 2782 :         SetAutoIdle(pPdd, FALSE);
; 2783 : 
; 2784 :         goto cleanUp;

  00070	ea0000b2	 b           |$LN53@HWTxIntr|
  00074		 |$LN24@HWTxIntr|

; 2785 :     }
; 2786 : 
; 2787 : 
; 2788 :     // Set event to fire HWXmitComChar
; 2789 :     PulseEvent(pPdd->txEvent);

  00074	e59400d4	 ldr         r0, [r4, #0xD4]
  00078	e3a01001	 mov         r1, #1
  0007c	eb000000	 bl          EventModify

; 2790 : 
; 2791 :     // If CTS flow control is desired, check it. If deasserted, don't send,
; 2792 :     // but loop.  When CTS is asserted again, the OtherInt routine will
; 2793 :     // detect this and re-enable TX interrupts (causing Flushdone).
; 2794 :     // For finest granularity, we would check this in the loop below,
; 2795 :     // but for speed, I check it here (up to 8 xmit characters before
; 2796 :     // we actually flow off.
; 2797 :     if (pPdd->dcb.fOutxCtsFlow)

  00080	e5943060	 ldr         r3, [r4, #0x60]
  00084	e3130004	 tst         r3, #4
  00088	0a00000f	 beq         |$LN22@HWTxIntr|

; 2798 :     {
; 2799 :         modemStat = ReadModemStat(pPdd);

  0008c	e1a00004	 mov         r0, r4
  00090	eb000000	 bl          ReadModemStat

; 2800 :         if ((modemStat & UART_MSR_NCTS) == 0)

  00094	e3100010	 tst         r0, #0x10
  00098	1a00000b	 bne         |$LN22@HWTxIntr|

; 2801 :         {
; 2802 :             // Set flag
; 2803 :             pPdd->flowOffCTS = TRUE;
; 2804 :             // Disable TX interrupt
; 2805 :             pPdd->intrMask &= ~UART_IER_THR;

  0009c	e3a02001	 mov         r2, #1

; 2806 :             OUTREG8(&pUartRegs->IER, pPdd->intrMask);

  000a0	e5842090	 str         r2, [r4, #0x90]
  000a4		 |$LN68@HWTxIntr|
  000a4	e5d43088	 ldrb        r3, [r4, #0x88]

; 2807 :             LeaveCriticalSection(&pPdd->hwCS);

  000a8	e2840098	 add         r0, r4, #0x98
  000ac	e20330fd	 and         r3, r3, #0xFD
  000b0	e5c43088	 strb        r3, [r4, #0x88]
  000b4	e5c63004	 strb        r3, [r6, #4]
  000b8	eb000000	 bl          LeaveCriticalSection

; 2808 :             SetAutoIdle(pPdd, FALSE);

  000bc	e3a01000	 mov         r1, #0
  000c0	e1a00004	 mov         r0, r4
  000c4	eb000000	 bl          SetAutoIdle

; 2809 :             *pLength = 0;
; 2810 :             goto cleanUp;

  000c8	eaffffd7	 b           |$LN66@HWTxIntr|
  000cc		 |$LN22@HWTxIntr|

; 2811 :         }
; 2812 :     }
; 2813 : 
; 2814 :     // Same thing applies for DSR
; 2815 :     if (pPdd->dcb.fOutxDsrFlow)

  000cc	e5943060	 ldr         r3, [r4, #0x60]
  000d0	e3130008	 tst         r3, #8
  000d4	0a000005	 beq         |$LN20@HWTxIntr|

; 2816 :     {
; 2817 :         modemStat = ReadModemStat(pPdd);

  000d8	e1a00004	 mov         r0, r4
  000dc	eb000000	 bl          ReadModemStat

; 2818 :         if ((modemStat & UART_MSR_NDSR) == 0)

  000e0	e3100020	 tst         r0, #0x20

; 2819 :         {
; 2820 :             // Set flag
; 2821 :             pPdd->flowOffDSR = TRUE;
; 2822 :             // Disable TX interrupt
; 2823 : 
; 2824 :             pPdd->intrMask &= ~UART_IER_THR;

  000e4	03a02001	 moveq       r2, #1

; 2825 :             OUTREG8(&pUartRegs->IER, pPdd->intrMask);

  000e8	05842094	 streq       r2, [r4, #0x94]
  000ec	0affffec	 beq         |$LN68@HWTxIntr|
  000f0		 |$LN20@HWTxIntr|

; 2826 :             LeaveCriticalSection(&pPdd->hwCS);
; 2827 :             SetAutoIdle(pPdd, FALSE);
; 2828 :             *pLength = 0;
; 2829 :             goto cleanUp;
; 2830 :         }
; 2831 :     }
; 2832 : 
; 2833 :     if ( pPdd->bHWXmitComCharWaiting )

  000f0	e5943130	 ldr         r3, [r4, #0x130]
  000f4	e3a08000	 mov         r8, #0
  000f8	e3530000	 cmp         r3, #0
  000fc	0a000006	 beq         |$LN19@HWTxIntr|

; 2834 :     {
; 2835 :         LeaveCriticalSection(&pPdd->hwCS);

  00100	e2840098	 add         r0, r4, #0x98
  00104	eb000000	 bl          LeaveCriticalSection

; 2836 : 
; 2837 :         // Give chance to HWXmitComChar there
; 2838 :         Sleep(pPdd->txPauseTimeMs);

  00108	e59400ec	 ldr         r0, [r4, #0xEC]
  0010c	eb000000	 bl          Sleep

; 2839 : 
; 2840 :         EnterCriticalSection(&pPdd->hwCS);

  00110	e2840098	 add         r0, r4, #0x98
  00114	eb000000	 bl          EnterCriticalSection

; 2841 : 
; 2842 :         pPdd->bHWXmitComCharWaiting = FALSE;

  00118	e5848130	 str         r8, [r4, #0x130]
  0011c		 |$LN19@HWTxIntr|

; 2843 :     }
; 2844 : 
; 2845 :     if( !pPdd->TxDmaInfo)

  0011c	e5943100	 ldr         r3, [r4, #0x100]
  00120	e3530000	 cmp         r3, #0
  00124	1a000010	 bne         |$LN18@HWTxIntr|

; 2846 :     {
; 2847 :         // 'NO DMA' transmit routine
; 2848 :         // While there are data and there is room in TX FIFO
; 2849 :         dwCount = *pLength;

  00128	e5953000	 ldr         r3, [r5]

; 2850 :         *pLength = 0;

  0012c	e5858000	 str         r8, [r5]
  00130	e1b02003	 movs        r2, r3

; 2851 :         while (dwCount > 0)

  00134	0a000009	 beq         |$LN63@HWTxIntr|
  00138		 |$LL17@HWTxIntr|

; 2852 :         {
; 2853 :             if ((INREG8(&pUartRegs->SSR) & UART_SSR_TX_FIFO_FULL) != 0) break;

  00138	e5d63044	 ldrb        r3, [r6, #0x44]
  0013c	e3130001	 tst         r3, #1
  00140	1a000006	 bne         |$LN63@HWTxIntr|

; 2854 :             OUTREG8(&pUartRegs->THR, *pTxBuffer++);

  00144	e4da3001	 ldrb        r3, [r10], #1

; 2855 :             (*pLength)++;
; 2856 :             dwCount--;

  00148	e2522001	 subs        r2, r2, #1
  0014c	e5c63000	 strb        r3, [r6]
  00150	e5953000	 ldr         r3, [r5]
  00154	e2833001	 add         r3, r3, #1
  00158	e5853000	 str         r3, [r5]
  0015c	1afffff5	 bne         |$LL17@HWTxIntr|
  00160		 |$LN63@HWTxIntr|

; 2857 :         }
; 2858 : 
; 2859 :         // enable TX interrupt
; 2860 :         pPdd->intrMask |= UART_IER_THR;

  00160	e5d43088	 ldrb        r3, [r4, #0x88]

; 2861 :         OUTREG8(&pUartRegs->IER, pPdd->intrMask);
; 2862 :         LeaveCriticalSection(&pPdd->hwCS);

  00164	e3833002	 orr         r3, r3, #2

; 2863 :         SetAutoIdle(pPdd, FALSE);
; 2864 : 
; 2865 :         goto cleanUp;

  00168	eaffffbc	 b           |$LN69@HWTxIntr|
  0016c		 |$LN18@HWTxIntr|

; 2866 :     }
; 2867 : 
; 2868 :     // clear any pending tx event
; 2869 :     WaitForSingleObject(pPdd->hEventTxIstDma, 0);

  0016c	e5940108	 ldr         r0, [r4, #0x108]
  00170	e3a01000	 mov         r1, #0
  00174	eb000000	 bl          WaitForSingleObject

; 2870 : 
; 2871 :     // Make sure an event isn't hanging around from a previous DMA time out.
; 2872 :     // The WaitForSingleObject above handles this...
; 2873 :     //ResetEvent(pPdd->hEventTxIstDma);
; 2874 : 
; 2875 :     //  Get the length of how much can be DMA'd
; 2876 :     BytesToTransfer = (size < pPdd->TxDmaBufferSize) ? size : pPdd->TxDmaBufferSize;

  00178	e59460f4	 ldr         r6, [r4, #0xF4]

; 2877 : 
; 2878 :     //  Write out all the data; loop if necessary
; 2879 :     for( dwCount = 0; dwCount < size; )

  0017c	e3a09000	 mov         r9, #0
  00180	e1570006	 cmp         r7, r6
  00184	31a06007	 movcc       r6, r7
  00188	e3570000	 cmp         r7, #0
  0018c	0a00005d	 beq         |$LN13@HWTxIntr|
  00190	e3a03c01	 mov         r3, #1, 24
  00194	e383b002	 orr         r11, r3, #2
  00198	e3a05000	 mov         r5, #0
  0019c		 |$LL14@HWTxIntr|

; 2880 :     {
; 2881 : 
; 2882 :         TotalTimeout = ((PHW_INDEP_INFO)pPdd->pMdd)->CommTimeouts.WriteTotalTimeoutMultiplier*BytesToTransfer +
; 2883 :                        ((PHW_INDEP_INFO)pPdd->pMdd)->CommTimeouts.WriteTotalTimeoutConstant;

  0019c	e5943050	 ldr         r3, [r4, #0x50]
  001a0	e5932088	 ldr         r2, [r3, #0x88]
  001a4	e593308c	 ldr         r3, [r3, #0x8C]
  001a8	e0383296	 mlas        r8, r6, r2, r3

; 2884 : 
; 2885 :         if ( !TotalTimeout )
; 2886 :             Timeout = INFINITE;
; 2887 :         else
; 2888 :             Timeout = TotalTimeout;
; 2889 : 
; 2890 :         dwDmaStatus = DmaGetStatus(pPdd->TxDmaInfo);

  001ac	e5943100	 ldr         r3, [r4, #0x100]
  001b0	03e08000	 mvneq       r8, #0
  001b4	e5932014	 ldr         r2, [r3, #0x14]
  001b8	e592300c	 ldr         r3, [r2, #0xC]

; 2891 :         // clear status
; 2892 :         DmaClearStatus(pPdd->TxDmaInfo, dwDmaStatus);

  001bc	e582300c	 str         r3, [r2, #0xC]

; 2893 : 
; 2894 :         if (DmaInterruptDone(pPdd->hTxDmaChannel) == FALSE)

  001c0	e5940104	 ldr         r0, [r4, #0x104]
  001c4	eb000000	 bl          DmaInterruptDone
  001c8	e3500000	 cmp         r0, #0

; 2895 :         {
; 2896 :             RETAILMSG(1,(TEXT("ERROR: Failed to Signal DMA TX interrupt completion\r\n")));

  001cc	059f0198	 ldreq       r0, [pc, #0x198]
  001d0	0b000000	 bleq        NKDbgPrintfW

; 2897 :         }
; 2898 : 
; 2899 :         DmaSetElementAndFrameCount( pPdd->TxDmaInfo,
; 2900 :             (UINT16)BytesToTransfer,1);

  001d4	e594e100	 ldr         lr, [r4, #0x100]
  001d8	e1a00806	 mov         r0, r6, lsl #16
  001dc	e1a00820	 mov         r0, r0, lsr #16

; 2901 : 
; 2902 :         CeSafeCopyMemory (pPdd->pTxDmaBuffer, pTxBuffer, BytesToTransfer);

  001e0	e59e3014	 ldr         r3, [lr, #0x14]
  001e4	e1a02006	 mov         r2, r6
  001e8	e1a0100a	 mov         r1, r10
  001ec	e5830014	 str         r0, [r3, #0x14]
  001f0	e59e3014	 ldr         r3, [lr, #0x14]
  001f4	e3a00001	 mov         r0, #1
  001f8	e5830018	 str         r0, [r3, #0x18]
  001fc	e59400f8	 ldr         r0, [r4, #0xF8]
  00200	eb000000	 bl          CeSafeCopyMemory

; 2903 : 
; 2904 :         dwDmaStatus = DmaGetStatus(pPdd->TxDmaInfo);

  00204	e5943100	 ldr         r3, [r4, #0x100]
  00208	e5933014	 ldr         r3, [r3, #0x14]
  0020c	e593300c	 ldr         r3, [r3, #0xC]
  00210	e3530000	 cmp         r3, #0

; 2905 : 
; 2906 :         if(dwDmaStatus) {
; 2907 :             RETAILMSG(1, (TEXT("!!!! DMA status is 0x%x\r\n"), dwDmaStatus));

  00214	159f014c	 ldrne       r0, [pc, #0x14C]
  00218	11a01003	 movne       r1, r3
  0021c	1b000000	 blne        NKDbgPrintfW

; 2908 :         }
; 2909 :     
; 2910 :         // Workaround, restart RXDMA to get TX working after break is received
; 2911 :         if (pPdd->bRxBreak)

  00220	e5943178	 ldr         r3, [r4, #0x178]
  00224	e3530000	 cmp         r3, #0
  00228	0a000006	 beq         |$LN8@HWTxIntr|

; 2912 :         {
; 2913 :             if (pPdd->RxDmaInfo)

  0022c	e5943124	 ldr         r3, [r4, #0x124]
  00230	e3530000	 cmp         r3, #0

; 2914 :                 DmaStart(pPdd->RxDmaInfo);

  00234	15932014	 ldrne       r2, [r3, #0x14]
  00238	15923000	 ldrne       r3, [r2]
  0023c	13833080	 orrne       r3, r3, #0x80
  00240	15823000	 strne       r3, [r2]

; 2915 :             pPdd->bRxBreak = FALSE;

  00244	e5845178	 str         r5, [r4, #0x178]
  00248		 |$LN8@HWTxIntr|

; 2916 :         }
; 2917 :                 
; 2918 :         DmaStart(pPdd->TxDmaInfo);

  00248	e5943100	 ldr         r3, [r4, #0x100]

; 2919 :         LeaveCriticalSection(&pPdd->hwCS);

  0024c	e2840098	 add         r0, r4, #0x98
  00250	e5932014	 ldr         r2, [r3, #0x14]
  00254	e5923000	 ldr         r3, [r2]
  00258	e3833080	 orr         r3, r3, #0x80
  0025c	e5823000	 str         r3, [r2]
  00260	eb000000	 bl          LeaveCriticalSection

; 2920 : 
; 2921 :         //The end of transfer is now signalled by the DMA TX IST
; 2922 :         //Adjust to be the correct timeout value
; 2923 :         // need to recalculate every iteration
; 2924 :         dwStatus = WaitForSingleObject(pPdd->hEventTxIstDma, Timeout);

  00264	e5940108	 ldr         r0, [r4, #0x108]
  00268	e1a01008	 mov         r1, r8
  0026c	eb000000	 bl          WaitForSingleObject

; 2925 : 
; 2926 :         if(dwStatus == WAIT_FAILED) {

  00270	e3700001	 cmn         r0, #1

; 2927 :             RETAILMSG(1, (TEXT("TX DMA failed\r\n")));

  00274	059f00e8	 ldreq       r0, [pc, #0xE8]
  00278	0a000002	 beq         |$LN64@HWTxIntr|

; 2928 :             DmaStop(pPdd->TxDmaInfo);
; 2929 :         }
; 2930 :         else if(dwStatus == WAIT_TIMEOUT) {

  0027c	e150000b	 cmp         r0, r11
  00280	1a000003	 bne         |$LN4@HWTxIntr|

; 2931 :             //EnterCriticalSection(&pPdd->hwCS);
; 2932 :             //UART_RegDump(pPdd);
; 2933 :             //LeaveCriticalSection(&pPdd->hwCS);
; 2934 :             RETAILMSG(1, (TEXT("TX DMA timeout\r\n")));

  00284	e59f00d4	 ldr         r0, [pc, #0xD4]
  00288		 |$LN64@HWTxIntr|
  00288	eb000000	 bl          NKDbgPrintfW

; 2935 :             DmaStop(pPdd->TxDmaInfo);

  0028c	e5940100	 ldr         r0, [r4, #0x100]
  00290	eb000000	 bl          DmaStop
  00294		 |$LN4@HWTxIntr|

; 2936 :         }
; 2937 : 
; 2938 :         dwDmaStatus = DmaGetStatus(pPdd->TxDmaInfo);

  00294	e5943100	 ldr         r3, [r4, #0x100]
  00298	e5933014	 ldr         r3, [r3, #0x14]
  0029c	e593800c	 ldr         r8, [r3, #0xC]

; 2939 :         // clear status
; 2940 :         DmaClearStatus(pPdd->TxDmaInfo, dwDmaStatus);

  002a0	e583800c	 str         r8, [r3, #0xC]

; 2941 : 
; 2942 :         if (DmaInterruptDone(pPdd->hTxDmaChannel) == FALSE)

  002a4	e5940104	 ldr         r0, [r4, #0x104]
  002a8	eb000000	 bl          DmaInterruptDone
  002ac	e3500000	 cmp         r0, #0
  002b0	1a000003	 bne         |$LN3@HWTxIntr|

; 2943 :         {
; 2944 :             RETAILMSG(1,(TEXT("ERROR: IST_TxDMA: Failed to Signal DMA TX interrupt completion\r\n")));

  002b4	e59f00a0	 ldr         r0, [pc, #0xA0]
  002b8	eb000000	 bl          NKDbgPrintfW

; 2945 :             DmaStop(pPdd->TxDmaInfo);

  002bc	e5940100	 ldr         r0, [r4, #0x100]
  002c0	eb000000	 bl          DmaStop
  002c4		 |$LN3@HWTxIntr|

; 2946 :         }
; 2947 : 
; 2948 :         if(!(dwDmaStatus & DMA_CSR_BLOCK)) {

  002c4	e3180020	 tst         r8, #0x20
  002c8	1a000004	 bne         |$LN2@HWTxIntr|

; 2949 :             RETAILMSG(1,(TEXT("TX DMA Status is 0x%x\r\n"), dwDmaStatus));

  002cc	e59f0084	 ldr         r0, [pc, #0x84]
  002d0	e1a01008	 mov         r1, r8
  002d4	eb000000	 bl          NKDbgPrintfW

; 2950 :             DmaStop(pPdd->TxDmaInfo);

  002d8	e5940100	 ldr         r0, [r4, #0x100]
  002dc	eb000000	 bl          DmaStop
  002e0		 |$LN2@HWTxIntr|

; 2951 :         }
; 2952 : 
; 2953 :         //  Update amount transferred
; 2954 :         dwCount += BytesToTransfer;
; 2955 : 
; 2956 :         //calculate remaining data size
; 2957 :         BytesToTransfer = ((size - dwCount)/pPdd->TxDmaBufferSize) ?
; 2958 :                           pPdd->TxDmaBufferSize : (size - dwCount);

  002e0	e0899006	 add         r9, r9, r6
  002e4	e59400f4	 ldr         r0, [r4, #0xF4]
  002e8	e0476009	 sub         r6, r7, r9
  002ec	e1a01006	 mov         r1, r6
  002f0	eb000000	 bl          __rt_udiv
  002f4	e3500000	 cmp         r0, #0
  002f8	159460f4	 ldrne       r6, [r4, #0xF4]
  002fc	e1590007	 cmp         r9, r7
  00300	3affffa5	 bcc         |$LL14@HWTxIntr|

; 2746 : {

  00304	e59d5000	 ldr         r5, [sp]
  00308		 |$LN13@HWTxIntr|

; 2959 :     }
; 2960 : 
; 2961 :     SetEvent(((PHW_INDEP_INFO)pPdd->pMdd)->hTransmitEvent);

  00308	e5943050	 ldr         r3, [r4, #0x50]
  0030c	e3a01003	 mov         r1, #3
  00310	e593003c	 ldr         r0, [r3, #0x3C]
  00314	eb000000	 bl          EventModify

; 2962 : 
; 2963 :     // Report to MDD total bytes transferred
; 2964 :     *pLength = dwCount;

  00318	e5859000	 str         r9, [r5]

; 2965 :     if(!IsDmaEnable (pPdd->TxDmaInfo)) SetAutoIdle(pPdd, FALSE);

  0031c	e5943100	 ldr         r3, [r4, #0x100]
  00320	e3530000	 cmp         r3, #0
  00324	0a000005	 beq         |$LN53@HWTxIntr|
  00328	e5933014	 ldr         r3, [r3, #0x14]
  0032c	e5933000	 ldr         r3, [r3]
  00330	e58d3000	 str         r3, [sp]
  00334	e59d3000	 ldr         r3, [sp]
  00338	e3130080	 tst         r3, #0x80
  0033c	1a000002	 bne         |$cleanUp$45680|
  00340		 |$LN53@HWTxIntr|
  00340	e3a01000	 mov         r1, #0
  00344	e1a00004	 mov         r0, r4
  00348	eb000000	 bl          SetAutoIdle
  0034c		 |$cleanUp$45680|

; 2966 : 
; 2967 : cleanUp:
; 2968 :     DEBUGMSG(ZONE_THREAD, (
; 2969 :         L"-HWTxIntr(*pLength = %d)\r\n", *pLength
; 2970 :         ));
; 2971 : }

  0034c	e28dd004	 add         sp, sp, #4
  00350	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00354	e12fff1e	 bx          lr
  00358		 |$LN73@HWTxIntr|
  00358		 |$LN74@HWTxIntr|
  00358	00000000	 DCD         |??_C@_1DA@OODNCMGJ@?$AAT?$AAX?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?5?$AAi?$AAs?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  0035c		 |$LN75@HWTxIntr|
  0035c	00000000	 DCD         |??_C@_1IC@MEFBLOON@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAI?$AAS?$AAT?$AA_?$AAT?$AAx?$AAD?$AAM?$AAA?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAS?$AAi?$AAg?$AAn@|
  00360		 |$LN76@HWTxIntr|
  00360	00000000	 DCD         |??_C@_1CC@PKKAGKLP@?$AAT?$AAX?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AN?$AA?6?$AA?$AA@|
  00364		 |$LN77@HWTxIntr|
  00364	00000000	 DCD         |??_C@_1CA@GNIAGCLB@?$AAT?$AAX?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AN?$AA?6?$AA?$AA@|
  00368		 |$LN78@HWTxIntr|
  00368	00000000	 DCD         |??_C@_1DE@BIEHKFMC@?$AA?$CB?$AA?$CB?$AA?$CB?$AA?$CB?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?5?$AAi?$AAs?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  0036c		 |$LN79@HWTxIntr|
  0036c	00000000	 DCD         |??_C@_1GM@FFDJCNJM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAS?$AAi?$AAg?$AAn?$AAa?$AAl?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAT?$AAX?$AA?5?$AAi@|
  00370		 |$M47574|

			 ENDP  ; |HWTxIntr|

; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T47600| DCD	|$LN11@HWModemInt|
	DCD	0x40002201
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\uart\pdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWModemIntr| PROC

; 2986 : {

  00000		 |$LN11@HWModemInt|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M47597|
  00004	e1a04000	 mov         r4, r0

; 2987 :     UARTPDD *pPdd = (UARTPDD*)pvContext;
; 2988 :     UCHAR modemStat;
; 2989 : 
; 2990 : 
; 2991 :     DEBUGMSG(ZONE_THREAD, (L"+HWModemIntr(0x%08x)\r\n", pvContext));
; 2992 : 
; 2993 :     // Get actual modem status
; 2994 :     modemStat = ReadModemStat(pPdd);

  00008	eb000000	 bl          ReadModemStat

; 2995 : 
; 2996 :     // If we are currently flowed off via CTS or DSR, then
; 2997 :     // we better signal the TX thread when one of them changes
; 2998 :     // so that TX can resume sending.
; 2999 : 
; 3000 :     EnterCriticalSection(&pPdd->hwCS);

  0000c	e1a05000	 mov         r5, r0
  00010	e2840098	 add         r0, r4, #0x98
  00014	eb000000	 bl          EnterCriticalSection

; 3001 : 
; 3002 : 
; 3003 :     if (pPdd->flowOffDSR && ((modemStat & UART_MSR_NDSR) != 0))

  00018	e5943094	 ldr         r3, [r4, #0x94]
  0001c	e3a06000	 mov         r6, #0
  00020	e3a07001	 mov         r7, #1
  00024	e3530000	 cmp         r3, #0
  00028	0a000007	 beq         |$LN2@HWModemInt|
  0002c	e3150020	 tst         r5, #0x20
  00030	0a000005	 beq         |$LN2@HWModemInt|

; 3004 :     {
; 3005 :         // Clear flag
; 3006 :         pPdd->flowOffDSR = FALSE;
; 3007 :         // DSR is set, so go ahead and resume sending
; 3008 :         SetEvent( ((PHW_INDEP_INFO)pPdd->pMdd)->hSerialEvent);

  00034	e5943050	 ldr         r3, [r4, #0x50]
  00038	e5846094	 str         r6, [r4, #0x94]
  0003c	e3a01003	 mov         r1, #3
  00040	e5930030	 ldr         r0, [r3, #0x30]
  00044	eb000000	 bl          EventModify

; 3009 : 
; 3010 :         // Then simulate a TX intr to get things moving
; 3011 :         pPdd->addTxIntr = TRUE;

  00048	e584708c	 str         r7, [r4, #0x8C]
  0004c		 |$LN2@HWModemInt|

; 3012 :     }
; 3013 : 
; 3014 :     if (pPdd->flowOffCTS && ((modemStat & UART_MSR_NCTS) != 0))

  0004c	e5943090	 ldr         r3, [r4, #0x90]
  00050	e3530000	 cmp         r3, #0
  00054	0a000007	 beq         |$LN1@HWModemInt|
  00058	e3150010	 tst         r5, #0x10
  0005c	0a000005	 beq         |$LN1@HWModemInt|

; 3015 :     {
; 3016 :         pPdd->flowOffCTS = FALSE;
; 3017 :         //CTS is set, so go ahead and resume sending
; 3018 :         //Need to simulate an interrupt
; 3019 :         SetEvent( ((PHW_INDEP_INFO)pPdd->pMdd)->hSerialEvent);

  00060	e5943050	 ldr         r3, [r4, #0x50]
  00064	e5846090	 str         r6, [r4, #0x90]
  00068	e3a01003	 mov         r1, #3
  0006c	e5930030	 ldr         r0, [r3, #0x30]
  00070	eb000000	 bl          EventModify

; 3020 : 
; 3021 :         // Then simulate a TX intr to get things moving
; 3022 :         pPdd->addTxIntr = TRUE;

  00074	e584708c	 str         r7, [r4, #0x8C]
  00078		 |$LN1@HWModemInt|

; 3023 :     }
; 3024 : 
; 3025 : 
; 3026 :     LeaveCriticalSection(&pPdd->hwCS);

  00078	e2840098	 add         r0, r4, #0x98
  0007c	eb000000	 bl          LeaveCriticalSection

; 3027 :     DEBUGMSG(ZONE_THREAD, (L"-HWModemIntr\r\n"));
; 3028 : }

  00080	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00084	e12fff1e	 bx          lr
  00088		 |$M47598|

			 ENDP  ; |HWModemIntr|


  00000			 AREA	 |.pdata|, PDATA
|$T47613| DCD	|$LN12@HWLineIntr|
	DCD	0x40001601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWLineIntr| PROC

; 3042 : {

  00000		 |$LN12@HWLineIntr|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47610|
  00004	e1a04000	 mov         r4, r0

; 3043 :     UARTPDD *pPdd = (UARTPDD *)pvContext;
; 3044 :     OMAP_UART_REGS *pUartRegs = pPdd->pUartRegs;
; 3045 : 
; 3046 :     DEBUGMSG(ZONE_THREAD, (L"+HWLineIntr(0x%08x)\r\n", pvContext));
; 3047 : 
; 3048 : 
; 3049 :     if (pPdd->open == TRUE)

  00008	e5943054	 ldr         r3, [r4, #0x54]
  0000c	e5945024	 ldr         r5, [r4, #0x24]
  00010	e3530001	 cmp         r3, #1
  00014	1a00000d	 bne         |$LN3@HWLineIntr|

; 3050 :     {
; 3051 :         ReadLineStat(pPdd);

  00018	eb000000	 bl          ReadLineStat

; 3052 : 
; 3053 :         EnterCriticalSection(&pPdd->hwCS);

  0001c	e2840098	 add         r0, r4, #0x98
  00020	eb000000	 bl          EnterCriticalSection

; 3054 : 
; 3055 :         // Reset receiver
; 3056 :         OUTREG8(&pUartRegs->FCR, pPdd->CurrentFCR | UART_FCR_RX_FIFO_CLEAR);

  00024	e5d43089	 ldrb        r3, [r4, #0x89]

; 3057 : 
; 3058 :         // Do we need to read RESUME register in case there was an overrun error in the FIFO?
; 3059 :         //INREG8(&pUartRegs->RESUME);
; 3060 : 
; 3061 :         // Did we not just clear the FIFO?       
; 3062 :         // Read all character in fifo
; 3063 :         while ((ReadLineStat(pPdd) & UART_LSR_RX_FIFO_E) != 0)

  00028	e3833002	 orr         r3, r3, #2
  0002c	e5c53008	 strb        r3, [r5, #8]
  00030	ea000000	 b           |$LN9@HWLineIntr|
  00034		 |$LL2@HWLineIntr|

; 3064 :         {
; 3065 :             INREG8(&pUartRegs->RHR);

  00034	e5d53000	 ldrb        r3, [r5]
  00038		 |$LN9@HWLineIntr|
  00038	e1a00004	 mov         r0, r4
  0003c	eb000000	 bl          ReadLineStat
  00040	e3100001	 tst         r0, #1
  00044	1afffffa	 bne         |$LL2@HWLineIntr|

; 3066 :         }
; 3067 : 
; 3068 :         LeaveCriticalSection(&pPdd->hwCS);

  00048	e2840098	 add         r0, r4, #0x98
  0004c	eb000000	 bl          LeaveCriticalSection
  00050		 |$LN3@HWLineIntr|

; 3069 :     }
; 3070 : 
; 3071 :     DEBUGMSG(ZONE_THREAD, (L"-HWLineIntr\r\n"));
; 3072 : }

  00050	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M47611|

			 ENDP  ; |HWLineIntr|


  00000			 AREA	 |.pdata|, PDATA
|$T47623| DCD	|$LN5@HWGetRxBuf|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWGetRxBufferSize| PROC

; 3086 : {

  00000		 |$LN5@HWGetRxBuf|
  00000		 |$M47620|

; 3087 :     UARTPDD *pPdd = (UARTPDD *)pvContext;
; 3088 : 
; 3089 :     DEBUGMSG(ZONE_FUNCTION, (TEXT("+HWGetRxBufferSize()\r\n")));
; 3090 :     DEBUGMSG(ZONE_FUNCTION, (TEXT("-HWGetRxBufferSize()\r\n")));
; 3091 :     return pPdd->rxBufferSize;

  00000	e5900018	 ldr         r0, [r0, #0x18]

; 3092 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M47621|

			 ENDP  ; |HWGetRxBufferSize|


  00000			 AREA	 |.pdata|, PDATA
|$T47632| DCD	|$LN5@HWPowerOff|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWPowerOff| PROC

; 3106 : {

  00000		 |$LN5@HWPowerOff|
  00000		 |$M47629|

; 3107 :     UNREFERENCED_PARAMETER(pvContext);
; 3108 :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 3109 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M47630|

			 ENDP  ; |HWPowerOff|


  00000			 AREA	 |.pdata|, PDATA
|$T47641| DCD	|$LN5@HWPowerOn|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWPowerOn| PROC

; 3123 : {

  00000		 |$LN5@HWPowerOn|
  00000		 |$M47638|

; 3124 :     UNREFERENCED_PARAMETER(pvContext);
; 3125 :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 3126 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M47639|

			 ENDP  ; |HWPowerOn|


  00000			 AREA	 |.pdata|, PDATA
|$T47650| DCD	|$LN5@HWClearDTR|
	DCD	0x40000f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWClearDTR| PROC

; 3139 : {

  00000		 |$LN5@HWClearDTR|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47647|
  00004	e1a05000	 mov         r5, r0

; 3140 :     UARTPDD *pPdd = (UARTPDD*)pvContext;
; 3141 :     OMAP_UART_REGS *pUartRegs = pPdd->pUartRegs;
; 3142 : 
; 3143 : 
; 3144 :     DEBUGMSG(ZONE_FUNCTION, (L"+HWClearDTR(0x%08x)\r\n", pvContext));
; 3145 : 
; 3146 :     EnterCriticalSection(&pPdd->hwCS);

  00008	e5954024	 ldr         r4, [r5, #0x24]
  0000c	e2850098	 add         r0, r5, #0x98
  00010	eb000000	 bl          EnterCriticalSection

; 3147 : 
; 3148 :     pPdd->currentMCR &= ~UART_MCR_DTR;

  00014	e5d5317d	 ldrb        r3, [r5, #0x17D]

; 3149 :     CLRREG8(&pUartRegs->MCR, UART_MCR_DTR);
; 3150 : 
; 3151 :     LeaveCriticalSection(&pPdd->hwCS);

  00018	e2850098	 add         r0, r5, #0x98
  0001c	e20330fe	 and         r3, r3, #0xFE
  00020	e5c5317d	 strb        r3, [r5, #0x17D]
  00024	e5d43010	 ldrb        r3, [r4, #0x10]
  00028	e20330fe	 and         r3, r3, #0xFE
  0002c	e5c43010	 strb        r3, [r4, #0x10]
  00030	eb000000	 bl          LeaveCriticalSection

; 3152 : 
; 3153 :     DEBUGMSG(ZONE_FUNCTION, (L"-HWClearDTR\r\n"));
; 3154 : }

  00034	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$M47648|

			 ENDP  ; |HWClearDTR|


  00000			 AREA	 |.pdata|, PDATA
|$T47659| DCD	|$LN5@HWSetDTR|
	DCD	0x40000f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWSetDTR| PROC

; 3168 : {

  00000		 |$LN5@HWSetDTR|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47656|
  00004	e1a05000	 mov         r5, r0

; 3169 :     UARTPDD *pPdd = (UARTPDD*)pvContext;
; 3170 :     OMAP_UART_REGS *pUartRegs = pPdd->pUartRegs;
; 3171 : 
; 3172 : 
; 3173 :     DEBUGMSG(ZONE_FUNCTION, (L"+HWSetDTR(0x%08x)\r\n", pvContext));
; 3174 : 
; 3175 :     EnterCriticalSection(&pPdd->hwCS);

  00008	e5954024	 ldr         r4, [r5, #0x24]
  0000c	e2850098	 add         r0, r5, #0x98
  00010	eb000000	 bl          EnterCriticalSection

; 3176 : 
; 3177 :     pPdd->currentMCR |= UART_MCR_DTR;

  00014	e5d5317d	 ldrb        r3, [r5, #0x17D]

; 3178 :     SETREG8(&pUartRegs->MCR, UART_MCR_DTR);
; 3179 : 
; 3180 :     LeaveCriticalSection(&pPdd->hwCS);

  00018	e2850098	 add         r0, r5, #0x98
  0001c	e3833001	 orr         r3, r3, #1
  00020	e5c5317d	 strb        r3, [r5, #0x17D]
  00024	e5d43010	 ldrb        r3, [r4, #0x10]
  00028	e3833001	 orr         r3, r3, #1
  0002c	e5c43010	 strb        r3, [r4, #0x10]
  00030	eb000000	 bl          LeaveCriticalSection

; 3181 : 
; 3182 :     DEBUGMSG(ZONE_FUNCTION, (L"-HWSetDTR\r\n"));
; 3183 : }

  00034	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$M47657|

			 ENDP  ; |HWSetDTR|


  00000			 AREA	 |.pdata|, PDATA
|$T47669| DCD	|$LN8@HWClearRTS|
	DCD	0x40001801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWClearRTS| PROC

; 3197 : {

  00000		 |$LN8@HWClearRTS|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47666|
  00004	e1a04000	 mov         r4, r0

; 3198 :     UARTPDD *pPdd = (UARTPDD*)pvContext;
; 3199 :     OMAP_UART_REGS *pUartRegs = pPdd->pUartRegs;
; 3200 : 
; 3201 :     DEBUGMSG(TRUE||ZONE_FUNCTION, (L"+HWClearRTS(0x%08x)\r\n", pvContext));
; 3202 : 
; 3203 :     if (pPdd->autoRTS)

  00008	e594307c	 ldr         r3, [r4, #0x7C]
  0000c	e5945024	 ldr         r5, [r4, #0x24]

; 3204 :     {
; 3205 :         EnterCriticalSection(&pPdd->hwCS);

  00010	e2840098	 add         r0, r4, #0x98
  00014	e3530000	 cmp         r3, #0
  00018	0a000005	 beq         |$LN2@HWClearRTS|
  0001c	eb000000	 bl          EnterCriticalSection

; 3206 : 
; 3207 :         // We should disable RX interrupt, this will result in auto RTS
; 3208 :         pPdd->intrMask &= ~UART_IER_RHR;

  00020	e5d43088	 ldrb        r3, [r4, #0x88]

; 3209 :         OUTREG8(&pUartRegs->IER, pPdd->intrMask);
; 3210 : 
; 3211 :         LeaveCriticalSection(&pPdd->hwCS);

  00024	e20330fe	 and         r3, r3, #0xFE
  00028	e5c43088	 strb        r3, [r4, #0x88]
  0002c	e5c53004	 strb        r3, [r5, #4]

; 3212 :     }
; 3213 :     else

  00030	ea000006	 b           |$LN5@HWClearRTS|
  00034		 |$LN2@HWClearRTS|

; 3214 :     {
; 3215 :         EnterCriticalSection(&pPdd->hwCS);

  00034	eb000000	 bl          EnterCriticalSection

; 3216 : 
; 3217 :         pPdd->currentMCR &= ~UART_MCR_RTS;

  00038	e5d4317d	 ldrb        r3, [r4, #0x17D]

; 3218 :         CLRREG8(&pUartRegs->MCR, UART_MCR_RTS);
; 3219 : 
; 3220 :         LeaveCriticalSection(&pPdd->hwCS);

  0003c	e20330fd	 and         r3, r3, #0xFD
  00040	e5c4317d	 strb        r3, [r4, #0x17D]
  00044	e5d53010	 ldrb        r3, [r5, #0x10]
  00048	e20330fd	 and         r3, r3, #0xFD
  0004c	e5c53010	 strb        r3, [r5, #0x10]
  00050		 |$LN5@HWClearRTS|
  00050	e2840098	 add         r0, r4, #0x98
  00054	eb000000	 bl          LeaveCriticalSection

; 3221 :     }
; 3222 : 
; 3223 :     DEBUGMSG(ZONE_FUNCTION, (L"-HWClearRTS\r\n"));
; 3224 : }

  00058	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$M47667|

			 ENDP  ; |HWClearRTS|


  00000			 AREA	 |.pdata|, PDATA
|$T47679| DCD	|$LN8@HWSetRTS|
	DCD	0x40001801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWSetRTS| PROC

; 3237 : {

  00000		 |$LN8@HWSetRTS|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47676|
  00004	e1a04000	 mov         r4, r0

; 3238 :     UARTPDD *pPdd = (UARTPDD*)pvContext;
; 3239 :     OMAP_UART_REGS *pUartRegs = pPdd->pUartRegs;
; 3240 : 
; 3241 :     DEBUGMSG(TRUE||ZONE_FUNCTION, (L"+HWSetRTS(0x%08x)\r\n", pvContext));
; 3242 : 
; 3243 :     if (pPdd->autoRTS)

  00008	e594307c	 ldr         r3, [r4, #0x7C]
  0000c	e5945024	 ldr         r5, [r4, #0x24]

; 3244 :     {
; 3245 :         EnterCriticalSection(&pPdd->hwCS);

  00010	e2840098	 add         r0, r4, #0x98
  00014	e3530000	 cmp         r3, #0
  00018	0a000005	 beq         |$LN2@HWSetRTS|
  0001c	eb000000	 bl          EnterCriticalSection

; 3246 : 
; 3247 :         // We should enable RX interrupt
; 3248 :         pPdd->intrMask |= UART_IER_RHR;

  00020	e5d43088	 ldrb        r3, [r4, #0x88]

; 3249 :         OUTREG8(&pUartRegs->IER, pPdd->intrMask);
; 3250 : 
; 3251 :         LeaveCriticalSection(&pPdd->hwCS);

  00024	e3833001	 orr         r3, r3, #1
  00028	e5c43088	 strb        r3, [r4, #0x88]
  0002c	e5c53004	 strb        r3, [r5, #4]

; 3252 :     }
; 3253 :     else

  00030	ea000006	 b           |$LN5@HWSetRTS|
  00034		 |$LN2@HWSetRTS|

; 3254 :     {
; 3255 :         EnterCriticalSection(&pPdd->hwCS);

  00034	eb000000	 bl          EnterCriticalSection

; 3256 : 
; 3257 :         pPdd->currentMCR |= UART_MCR_RTS;

  00038	e5d4317d	 ldrb        r3, [r4, #0x17D]

; 3258 :         SETREG8(&pUartRegs->MCR, UART_MCR_RTS);
; 3259 : 
; 3260 :         LeaveCriticalSection(&pPdd->hwCS);

  0003c	e3833002	 orr         r3, r3, #2
  00040	e5c4317d	 strb        r3, [r4, #0x17D]
  00044	e5d53010	 ldrb        r3, [r5, #0x10]
  00048	e3833002	 orr         r3, r3, #2
  0004c	e5c53010	 strb        r3, [r5, #0x10]
  00050		 |$LN5@HWSetRTS|
  00050	e2840098	 add         r0, r4, #0x98
  00054	eb000000	 bl          LeaveCriticalSection

; 3261 :     }
; 3262 : 
; 3263 :     DEBUGMSG(ZONE_FUNCTION, (L"-HWSetRTS\n"));
; 3264 : }

  00058	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$M47677|

			 ENDP  ; |HWSetRTS|


  00000			 AREA	 |.pdata|, PDATA
|$T47688| DCD	|$LN5@HWEnableIR|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWEnableIR| PROC

; 3274 : {

  00000		 |$LN5@HWEnableIR|
  00000		 |$M47685|

; 3275 :     UNREFERENCED_PARAMETER(pvContext);
; 3276 :     UNREFERENCED_PARAMETER(baudRate);
; 3277 :     DEBUGMSG(ZONE_FUNCTION, (TEXT("+HWEnableIR()\r\n")));
; 3278 :     DEBUGMSG(ZONE_FUNCTION, (TEXT("-HWEnableIR()\r\n")));
; 3279 :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 3280 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M47686|

			 ENDP  ; |HWEnableIR|


  00000			 AREA	 |.pdata|, PDATA
|$T47697| DCD	|$LN5@HWDisableI|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWDisableIR| PROC

; 3289 : {

  00000		 |$LN5@HWDisableI|
  00000		 |$M47694|

; 3290 : 
; 3291 :     UNREFERENCED_PARAMETER(pvContext);
; 3292 :     DEBUGMSG(ZONE_FUNCTION, (TEXT("+HWDisableIR()\r\n")));
; 3293 :     DEBUGMSG(ZONE_FUNCTION, (TEXT("-HWDisableIR()\r\n")));
; 3294 :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 3295 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M47695|

			 ENDP  ; |HWDisableIR|


  00000			 AREA	 |.pdata|, PDATA
|$T47706| DCD	|$LN5@HWClearBre|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWClearBreak| PROC

; 3308 : {

  00000		 |$LN5@HWClearBre|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47703|
  00004	e1a05000	 mov         r5, r0

; 3309 :     UARTPDD *pPdd = (UARTPDD*)pvContext;
; 3310 :     OMAP_UART_REGS *pUartRegs = pPdd->pUartRegs;
; 3311 : 
; 3312 :     DEBUGMSG(ZONE_FUNCTION, (
; 3313 :         L"+HWClearBreak(0x%08x)\r\n", pvContext
; 3314 :         ));
; 3315 : 
; 3316 :     EnterCriticalSection(&pPdd->hwCS);

  00008	e5954024	 ldr         r4, [r5, #0x24]
  0000c	e2850098	 add         r0, r5, #0x98
  00010	eb000000	 bl          EnterCriticalSection

; 3317 : 
; 3318 :     CLRREG8(&pUartRegs->LCR, UART_LCR_BREAK_EN);

  00014	e5d4300c	 ldrb        r3, [r4, #0xC]

; 3319 : 
; 3320 :     LeaveCriticalSection(&pPdd->hwCS);

  00018	e2850098	 add         r0, r5, #0x98
  0001c	e20330bf	 and         r3, r3, #0xBF
  00020	e5c4300c	 strb        r3, [r4, #0xC]
  00024	eb000000	 bl          LeaveCriticalSection

; 3321 : 
; 3322 :     DEBUGMSG(ZONE_FUNCTION, (L"-HWClearBreak\r\n"));
; 3323 : }

  00028	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$M47704|

			 ENDP  ; |HWClearBreak|


  00000			 AREA	 |.pdata|, PDATA
|$T47715| DCD	|$LN5@HWSetBreak|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWSetBreak| PROC

; 3336 : {

  00000		 |$LN5@HWSetBreak|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47712|
  00004	e1a05000	 mov         r5, r0

; 3337 :     UARTPDD *pPdd = (UARTPDD*)pvContext;
; 3338 :     OMAP_UART_REGS *pUartRegs = pPdd->pUartRegs;
; 3339 : 
; 3340 :     DEBUGMSG(ZONE_FUNCTION, (L"+HWSetBreak(0x%08x)\r\n", pvContext));
; 3341 : 
; 3342 :     EnterCriticalSection(&pPdd->hwCS);

  00008	e5954024	 ldr         r4, [r5, #0x24]
  0000c	e2850098	 add         r0, r5, #0x98
  00010	eb000000	 bl          EnterCriticalSection

; 3343 : 
; 3344 :     SETREG8(&pUartRegs->LCR, UART_LCR_BREAK_EN);

  00014	e5d4300c	 ldrb        r3, [r4, #0xC]

; 3345 : 
; 3346 :     LeaveCriticalSection(&pPdd->hwCS);

  00018	e2850098	 add         r0, r5, #0x98
  0001c	e3833040	 orr         r3, r3, #0x40
  00020	e5c4300c	 strb        r3, [r4, #0xC]
  00024	eb000000	 bl          LeaveCriticalSection

; 3347 : 
; 3348 :     DEBUGMSG(ZONE_FUNCTION, (L"-HWSetBreak\r\n"));
; 3349 : }

  00028	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$M47713|

			 ENDP  ; |HWSetBreak|


  00000			 AREA	 |.pdata|, PDATA
|$T47724| DCD	|$LN5@HWReset|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWReset| PROC

; 3362 : {

  00000		 |$LN5@HWReset|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47721|
  00004	e1a05000	 mov         r5, r0

; 3363 :     UARTPDD *pPdd = (UARTPDD*)pvContext;
; 3364 :     OMAP_UART_REGS *pUartRegs = pPdd->pUartRegs;
; 3365 : 
; 3366 : 
; 3367 :     DEBUGMSG(ZONE_FUNCTION, (L"+HWReset(0x%08x)\r\n", pvContext));
; 3368 : 
; 3369 :     EnterCriticalSection(&pPdd->hwCS);

  00008	e5954024	 ldr         r4, [r5, #0x24]
  0000c	e2850098	 add         r0, r5, #0x98
  00010	eb000000	 bl          EnterCriticalSection

; 3370 : 
; 3371 :     // Enable interrupts
; 3372 :     pPdd->intrMask = UART_IER_LINE|UART_IER_MODEM|UART_IER_RHR;

  00014	e3a0300d	 mov         r3, #0xD

; 3373 :     OUTREG8(&pUartRegs->IER, pPdd->intrMask);

  00018	e5c53088	 strb        r3, [r5, #0x88]

; 3374 : 
; 3375 :     LeaveCriticalSection(&pPdd->hwCS);

  0001c	e2850098	 add         r0, r5, #0x98
  00020	e5c43004	 strb        r3, [r4, #4]
  00024	eb000000	 bl          LeaveCriticalSection

; 3376 : 
; 3377 :     DEBUGMSG(ZONE_FUNCTION, (L"-HWReset\r\n"));
; 3378 : }

  00028	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$M47722|

			 ENDP  ; |HWReset|


  00000			 AREA	 |.pdata|, PDATA
|$T47734| DCD	|$LN8@HWGetModem|
	DCD	0x40001201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWGetModemStatus| PROC

; 3392 : {

  00000		 |$LN8@HWGetModem|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M47731|
  00004	e1a04001	 mov         r4, r1

; 3393 :     UARTPDD *pPdd = (UARTPDD*)pvContext;
; 3394 :     UCHAR modemStat;
; 3395 : 
; 3396 : 
; 3397 :     DEBUGMSG(ZONE_FUNCTION, (
; 3398 :         L"+HWGetModemStatus(0x%08x)\r\n", pvContext
; 3399 :         ));
; 3400 : 
; 3401 :     modemStat = ReadModemStat(pPdd);

  00008	eb000000	 bl          ReadModemStat

; 3402 : 
; 3403 :     *pModemStat = 0;

  0000c	e3a03000	 mov         r3, #0

; 3404 :     if ((modemStat & UART_MSR_NCTS) != 0) *pModemStat |= MS_CTS_ON;

  00010	e3100010	 tst         r0, #0x10
  00014	e5843000	 str         r3, [r4]
  00018	13a03010	 movne       r3, #0x10
  0001c	15843000	 strne       r3, [r4]

; 3405 :     if ((modemStat & UART_MSR_NDSR) != 0) *pModemStat |= MS_DSR_ON;

  00020	e3100020	 tst         r0, #0x20
  00024	15943000	 ldrne       r3, [r4]
  00028	13833020	 orrne       r3, r3, #0x20
  0002c	15843000	 strne       r3, [r4]

; 3406 :     if ((modemStat & UART_MSR_NCD) != 0) *pModemStat |= MS_RLSD_ON;

  00030	e3100080	 tst         r0, #0x80
  00034	15943000	 ldrne       r3, [r4]
  00038	13833080	 orrne       r3, r3, #0x80
  0003c	15843000	 strne       r3, [r4]

; 3407 : 
; 3408 :     DEBUGMSG(TRUE||ZONE_FUNCTION, (
; 3409 :         L"-HWGetModemStatus(0x%08x/%02x)\r\n", *pModemStat, modemStat
; 3410 :         ));
; 3411 : 
; 3412 : }

  00040	e8bd4010	 ldmia       sp!, {r4, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$M47732|

			 ENDP  ; |HWGetModemStatus|


  00000			 AREA	 |.pdata|, PDATA
|$T47751| DCD	|$LN14@HWXmitComC|
	DCD	0x40002501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWXmitComChar| PROC

; 3426 : {

  00000		 |$LN14@HWXmitComC|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47748|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 3427 :     UARTPDD *pPdd = (UARTPDD*)pvContext;
; 3428 : 
; 3429 :     DEBUGMSG(ZONE_FUNCTION, (L"+HWXmitComChar(0x%08x, %d)\r\n", pvContext, ch));
; 3430 : 
; 3431 :     //RETAILMSG(1,(TEXT("+HWXmitComChar(0x%08x, %d)\r\n"), pvContext, ch));
; 3432 : 
; 3433 :     EnterCriticalSection(&pPdd->txCS);

  0000c	e28400ac	 add         r0, r4, #0xAC
  00010	eb000000	 bl          EnterCriticalSection

; 3434 : 
; 3435 :     // We know THR will eventually empty
; 3436 :     for(;;)
; 3437 :     {
; 3438 :         EnterCriticalSection(&pPdd->hwCS);
; 3439 : 
; 3440 : 
; 3441 :         // Write the character if we can
; 3442 :         if ((ReadLineStat(pPdd) & UART_LSR_TX_FIFO_E) != 0)

  00014	ea000008	 b           |$LN11@HWXmitComC|
  00018		 |$LL3@HWXmitComC|

; 3443 :         {
; 3444 : 
; 3445 :             // Tell the tx interrupt handler that we are waiting for
; 3446 :             // a TX interrupt
; 3447 :             pPdd->bHWXmitComCharWaiting = TRUE;
; 3448 : 
; 3449 :             // FIFO is empty, send this character
; 3450 :             OUTREG8(&pPdd->pUartRegs->THR, ch);
; 3451 :             // Enable TX interrupt
; 3452 : 
; 3453 :             pPdd->intrMask |= UART_IER_THR;
; 3454 : 
; 3455 :             OUTREG8(&pPdd->pUartRegs->IER, pPdd->intrMask);
; 3456 : 
; 3457 :             LeaveCriticalSection(&pPdd->hwCS);
; 3458 :             break;
; 3459 :         }
; 3460 : 
; 3461 :         // If we couldn't write the data yet, then wait for a TX interrupt
; 3462 : 
; 3463 :         pPdd->intrMask |= UART_IER_THR;

  00018	e5d43088	 ldrb        r3, [r4, #0x88]

; 3464 :         OUTREG8(&pPdd->pUartRegs->IER, pPdd->intrMask);

  0001c	e5942024	 ldr         r2, [r4, #0x24]

; 3465 : 
; 3466 :         LeaveCriticalSection(&pPdd->hwCS);

  00020	e3833002	 orr         r3, r3, #2
  00024	e5c43088	 strb        r3, [r4, #0x88]
  00028	e5c23004	 strb        r3, [r2, #4]
  0002c	eb000000	 bl          LeaveCriticalSection

; 3467 : 
; 3468 :         // Wait until the TX interrupt has signalled
; 3469 :         WaitForSingleObject(pPdd->txEvent, 1000);

  00030	e59400d4	 ldr         r0, [r4, #0xD4]
  00034	e3a01ffa	 mov         r1, #0xFA, 30
  00038	eb000000	 bl          WaitForSingleObject
  0003c		 |$LN11@HWXmitComC|
  0003c	e2840098	 add         r0, r4, #0x98
  00040	eb000000	 bl          EnterCriticalSection
  00044	e1a00004	 mov         r0, r4
  00048	eb000000	 bl          ReadLineStat
  0004c	e3100020	 tst         r0, #0x20
  00050	e2840098	 add         r0, r4, #0x98
  00054	0affffef	 beq         |$LL3@HWXmitComC|
  00058	e5943024	 ldr         r3, [r4, #0x24]
  0005c	e3a02001	 mov         r2, #1
  00060	e5842130	 str         r2, [r4, #0x130]
  00064	e5c35000	 strb        r5, [r3]
  00068	e5d43088	 ldrb        r3, [r4, #0x88]
  0006c	e5942024	 ldr         r2, [r4, #0x24]
  00070	e3833002	 orr         r3, r3, #2
  00074	e5c43088	 strb        r3, [r4, #0x88]
  00078	e5c23004	 strb        r3, [r2, #4]
  0007c	eb000000	 bl          LeaveCriticalSection

; 3470 : 
; 3471 :     }
; 3472 :     LeaveCriticalSection(&pPdd->txCS);

  00080	e28400ac	 add         r0, r4, #0xAC
  00084	eb000000	 bl          LeaveCriticalSection

; 3473 : 
; 3474 :     DEBUGMSG(ZONE_FUNCTION, (L"-HWXmitComChar\r\n"));
; 3475 :     return TRUE;

  00088	e3a00001	 mov         r0, #1

; 3476 : }

  0008c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$M47749|

			 ENDP  ; |HWXmitComChar|


  00000			 AREA	 |.pdata|, PDATA
|$T47767| DCD	|$LN10@HWGetStatu|
	DCD	0x40001d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWGetStatus| PROC

; 3491 : {

  00000		 |$LN10@HWGetStatu|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M47764|
  00004	e3510000	 cmp         r1, #0
  00008	e1a0e000	 mov         lr, r0

; 3492 :     ULONG rc = (ULONG)-1;

  0000c	e3e00000	 mvn         r0, #0

; 3493 :     UARTPDD *pPdd = (UARTPDD*)pvContext;
; 3494 : 
; 3495 :     DEBUGMSG(ZONE_FUNCTION, (
; 3496 :         L"+HWGetStatus(0x%08x, 0x%08x)\r\n", pvContext, pComStat
; 3497 :         ));
; 3498 : 
; 3499 :     if (pComStat == NULL) goto cleanUp;

  00010	0a000015	 beq         |$cleanUp$45912|

; 3500 : 
; 3501 :     pComStat->fCtsHold = pPdd->flowOffCTS ? 1 : 0;

  00014	e59e3090	 ldr         r3, [lr, #0x90]
  00018	e3530000	 cmp         r3, #0
  0001c	e5913000	 ldr         r3, [r1]
  00020	13a02001	 movne       r2, #1
  00024	03a02000	 moveq       r2, #0
  00028	e2022001	 and         r2, r2, #1
  0002c	e3c33001	 bic         r3, r3, #1
  00030	e1832002	 orr         r2, r3, r2
  00034	e5812000	 str         r2, [r1]

; 3502 :     pComStat->fDsrHold = pPdd->flowOffDSR ? 1 : 0;

  00038	e59e3094	 ldr         r3, [lr, #0x94]
  0003c	e3530000	 cmp         r3, #0
  00040	13a03001	 movne       r3, #1
  00044	03a03000	 moveq       r3, #0
  00048	e0223083	 eor         r3, r2, r3, lsl #1
  0004c	e2033002	 and         r3, r3, #2
  00050	e0233002	 eor         r3, r3, r2
  00054	e5813000	 str         r3, [r1]

; 3503 :     pComStat->cbInQue  = 0;

  00058	e3a03000	 mov         r3, #0
  0005c	e5813004	 str         r3, [r1, #4]

; 3504 :     pComStat->cbOutQue = 0;

  00060	e5813008	 str         r3, [r1, #8]

; 3505 : 
; 3506 :     rc = pPdd->commErrors;

  00064	e59e0074	 ldr         r0, [lr, #0x74]

; 3507 :     pPdd->commErrors = 0;

  00068	e58e3074	 str         r3, [lr, #0x74]
  0006c		 |$cleanUp$45912|

; 3508 : 
; 3509 : cleanUp:
; 3510 :     DEBUGMSG(ZONE_FUNCTION, (L"-HWGetStatus(rc = %d)\r\n", rc));
; 3511 :     return rc;
; 3512 : }

  0006c	e49de004	 ldr         lr, [sp], #4
  00070	e12fff1e	 bx          lr
  00074		 |$M47765|

			 ENDP  ; |HWGetStatus|


  00000			 AREA	 |.pdata|, PDATA
|$T47776| DCD	|$LN6@HWGetCommP|
	DCD	0x40002601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWGetCommProperties| PROC

; 3524 : {

  00000		 |$LN6@HWGetCommP|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M47773|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 3525 :     UARTPDD *pPdd = (UARTPDD*)pvContext;
; 3526 : 
; 3527 :     DEBUGMSG(ZONE_FUNCTION, (
; 3528 :         L"+HWGetCommProperties(0x%08x, 0x%08x)\r\n", pvContext,
; 3529 :         pCommProp
; 3530 :         ));
; 3531 : 
; 3532 :     memset(pCommProp, 0, sizeof(COMMPROP));

  0000c	e3a02040	 mov         r2, #0x40
  00010	e3a01000	 mov         r1, #0
  00014	e1a00005	 mov         r0, r5
  00018	eb000000	 bl          memset

; 3533 :     pCommProp->wPacketLength = 0xffff;
; 3534 :     pCommProp->wPacketVersion = 0xffff;
; 3535 :     pCommProp->dwServiceMask = SP_SERIALCOMM;
; 3536 :     pCommProp->dwMaxTxQueue = 16;
; 3537 :     pCommProp->dwMaxRxQueue = 16;
; 3538 :     pCommProp->dwMaxBaud = BAUD_USER;
; 3539 :     pCommProp->dwProvSubType = PST_RS232;
; 3540 :     pCommProp->dwProvCapabilities =
; 3541 :         // On EVM DTR/DSR are connected together (but cannot be controlled) and RI/CD are not wired.
; 3542 :         // PCF_DTRDSR | PCF_RLSD |
; 3543 :         PCF_INTTIMEOUTS | PCF_PARITY_CHECK |
; 3544 :         PCF_SETXCHAR | PCF_SPECIALCHARS | PCF_TOTALTIMEOUTS |
; 3545 :         PCF_XONXOFF;
; 3546 :     pCommProp->dwSettableParams =
; 3547 :         // On GSample RI/CD are not wired
; 3548 :         // SP_RLSD |
; 3549 :         SP_BAUD | SP_DATABITS | SP_HANDSHAKING | SP_PARITY |
; 3550 :         SP_PARITY_CHECK | SP_STOPBITS;
; 3551 :     pCommProp->dwSettableBaud =
; 3552 :         /* not supported - BAUD_075 | BAUD_110 | BAUD_150 | */ BAUD_300 | BAUD_600 | BAUD_1200 |
; 3553 :         BAUD_1800 | BAUD_2400 | BAUD_4800 | BAUD_7200 | BAUD_9600 | BAUD_14400 |
; 3554 :         BAUD_19200 | BAUD_38400 | BAUD_57600 | BAUD_115200 | BAUD_USER;

  0001c	e3a03c1f	 mov         r3, #0x1F, 24
  00020	e59fe06c	 ldr         lr, [pc, #0x6C]

; 3555 :     pCommProp->wSettableData =
; 3556 :         DATABITS_5 | DATABITS_6 | DATABITS_7 | DATABITS_8;
; 3557 :     pCommProp->wSettableStopParity =
; 3558 :         STOPBITS_10 | STOPBITS_20 |
; 3559 :         PARITY_NONE | PARITY_ODD | PARITY_EVEN | PARITY_SPACE |
; 3560 :         PARITY_MARK;

  00024	e3832005	 orr         r2, r3, #5
  00028	e3a03cff	 mov         r3, #0xFF, 24
  0002c	e38330ff	 orr         r3, r3, #0xFF
  00030	e3a06201	 mov         r6, #1, 4
  00034	e3a07f7e	 mov         r7, #0x7E, 30
  00038	e3a0803f	 mov         r8, #0x3F
  0003c	e3a0900f	 mov         r9, #0xF
  00040	e3a00001	 mov         r0, #1
  00044	e3a01010	 mov         r1, #0x10
  00048	e1c530b0	 strh        r3, [r5]
  0004c	e1c530b2	 strh        r3, [r5, #2]
  00050	e585e024	 str         lr, [r5, #0x24]
  00054	e1c522ba	 strh        r2, [r5, #0x2A]
  00058	e5850004	 str         r0, [r5, #4]
  0005c	e585100c	 str         r1, [r5, #0xC]
  00060	e5851010	 str         r1, [r5, #0x10]
  00064	e5856014	 str         r6, [r5, #0x14]
  00068	e5850018	 str         r0, [r5, #0x18]
  0006c	e585701c	 str         r7, [r5, #0x1C]
  00070	e5858020	 str         r8, [r5, #0x20]
  00074	e1c592b8	 strh        r9, [r5, #0x28]

; 3561 : 
; 3562 :     if (pPdd->dwRtsCtsEnable)

  00078	e5943158	 ldr         r3, [r4, #0x158]
  0007c	e3530000	 cmp         r3, #0
  00080	13a03c01	 movne       r3, #1, 24

; 3563 :         pCommProp->dwProvCapabilities |= PCF_RTSCTS;

  00084	138330fa	 orrne       r3, r3, #0xFA
  00088	1585301c	 strne       r3, [r5, #0x1C]

; 3564 : 
; 3565 :     DEBUGMSG(ZONE_FUNCTION, (L"-HWGetCommProperties\r\n"));
; 3566 : }

  0008c	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$LN7@HWGetCommP|
  00094		 |$LN8@HWGetCommP|
  00094	10067ff0	 DCD         0x10067ff0
  00098		 |$M47774|

			 ENDP  ; |HWGetCommProperties|

; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\inc\omap_sdma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T47807| DCD	|$LN20@HWPurgeCom|
	DCD	0x40004f02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\uart\pdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWPurgeComm| PROC

; 3580 : {

  00000		 |$LN20@HWPurgeCom|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M47804|
  00008	e1a05001	 mov         r5, r1
  0000c	e1a04000	 mov         r4, r0

; 3581 :     UARTPDD *pPdd = (UARTPDD*)pvContext;
; 3582 :     UCHAR mdr1, nDll, nDlh;
; 3583 :     UCHAR fifoCtrl = 0;

  00010	e3a06000	 mov         r6, #0

; 3584 : 
; 3585 :     DEBUGMSG(ZONE_FUNCTION, (
; 3586 :         L"+HWPurgeComm(0x%08x 0x%08x)\r\n", pvContext, action
; 3587 :         ));
; 3588 :     if ((action & PURGE_TXCLEAR) || (action & PURGE_RXCLEAR))

  00014	e2158004	 ands        r8, r5, #4
  00018	1a000001	 bne         |$LN6@HWPurgeCom|
  0001c	e2157008	 ands        r7, r5, #8
  00020	0a000024	 beq         |$LN7@HWPurgeCom|
  00024		 |$LN6@HWPurgeCom|

; 3589 :     {
; 3590 :         EnterCriticalSection(&pPdd->hwCS);

  00024	e2840098	 add         r0, r4, #0x98
  00028	eb000000	 bl          EnterCriticalSection

; 3591 : 
; 3592 :         mdr1 = INREG8(&pPdd->pUartRegs->MDR1);

  0002c	e5943024	 ldr         r3, [r4, #0x24]

; 3593 : 
; 3594 :         // Disable UART
; 3595 :         OUTREG8(&pPdd->pUartRegs->MDR1, UART_MDR1_DISABLE);

  00030	e3a02007	 mov         r2, #7

; 3596 : 
; 3597 :         SETREG8(&pPdd->pUartRegs->LCR, UART_LCR_DIV_EN);
; 3598 : 
; 3599 :         // store baud clock
; 3600 :         nDll = INREG8(&pPdd->pUartRegs->DLL);
; 3601 :         nDlh = INREG8(&pPdd->pUartRegs->DLH);
; 3602 : 
; 3603 :         // Clear the baud clock
; 3604 :         OUTREG8(&pPdd->pUartRegs->DLL, 0);

  00034	e3a00000	 mov         r0, #0
  00038	e5d31020	 ldrb        r1, [r3, #0x20]
  0003c	e5c32020	 strb        r2, [r3, #0x20]
  00040	e5942024	 ldr         r2, [r4, #0x24]

; 3605 :         OUTREG8(&pPdd->pUartRegs->DLH, 0);
; 3606 : 
; 3607 :         // clear FIFOs as requested
; 3608 :         if ((action & PURGE_TXCLEAR) != 0) fifoCtrl |= UART_FCR_TX_FIFO_CLEAR;

  00044	e3580000	 cmp         r8, #0
  00048	13a06004	 movne       r6, #4
  0004c	e5d2300c	 ldrb        r3, [r2, #0xC]

; 3609 :         if ((action & PURGE_RXCLEAR) != 0) fifoCtrl |= UART_FCR_RX_FIFO_CLEAR;

  00050	e2157008	 ands        r7, r5, #8
  00054	13866002	 orrne       r6, r6, #2
  00058	e3833080	 orr         r3, r3, #0x80
  0005c	e5c2300c	 strb        r3, [r2, #0xC]
  00060	e5943024	 ldr         r3, [r4, #0x24]
  00064	e5d3e000	 ldrb        lr, [r3]
  00068	e5d39004	 ldrb        r9, [r3, #4]
  0006c	e5c30000	 strb        r0, [r3]
  00070	e5943024	 ldr         r3, [r4, #0x24]
  00074	e5c30004	 strb        r0, [r3, #4]

; 3610 :         OUTREG8(&pPdd->pUartRegs->FCR, pPdd->CurrentFCR | fifoCtrl);

  00078	e5d43089	 ldrb        r3, [r4, #0x89]
  0007c	e5942024	 ldr         r2, [r4, #0x24]

; 3611 : 
; 3612 :         // Do we need to read RESUME register in case there was an overrun error in the FIFO?
; 3613 :         //INREG8(&pPdd->pUartRegs->RESUME);
; 3614 : 
; 3615 :         // set baud clock
; 3616 :         OUTREG8(&pPdd->pUartRegs->DLL, nDll);
; 3617 :         OUTREG8(&pPdd->pUartRegs->DLH, nDlh);
; 3618 : 
; 3619 :         CLRREG8(&pPdd->pUartRegs->LCR, UART_LCR_DIV_EN);
; 3620 : 
; 3621 :         // Enable UART
; 3622 :         OUTREG8(&pPdd->pUartRegs->MDR1, mdr1);
; 3623 : 
; 3624 :         LeaveCriticalSection(&pPdd->hwCS);

  00080	e2840098	 add         r0, r4, #0x98
  00084	e1833006	 orr         r3, r3, r6
  00088	e5c23008	 strb        r3, [r2, #8]
  0008c	e5943024	 ldr         r3, [r4, #0x24]
  00090	e5c3e000	 strb        lr, [r3]
  00094	e5943024	 ldr         r3, [r4, #0x24]
  00098	e5c39004	 strb        r9, [r3, #4]
  0009c	e5942024	 ldr         r2, [r4, #0x24]
  000a0	e5d2300c	 ldrb        r3, [r2, #0xC]
  000a4	e203307f	 and         r3, r3, #0x7F
  000a8	e5c2300c	 strb        r3, [r2, #0xC]
  000ac	e5943024	 ldr         r3, [r4, #0x24]
  000b0	e5c31020	 strb        r1, [r3, #0x20]
  000b4	eb000000	 bl          LeaveCriticalSection
  000b8		 |$LN7@HWPurgeCom|

; 3625 :     }
; 3626 : 
; 3627 : 
; 3628 :     // Reset the RX dma pointers if we are using DMA for RX
; 3629 :     // the mdd pointers are reset by the mdd.
; 3630 :     if(pPdd->RxDmaInfo && (action & PURGE_RXCLEAR))

  000b8	e5943124	 ldr         r3, [r4, #0x124]
  000bc	e3530000	 cmp         r3, #0
  000c0	0a000010	 beq         |$LN3@HWPurgeCom|
  000c4	e3570000	 cmp         r7, #0
  000c8	0a00000e	 beq         |$LN3@HWPurgeCom|

; 3631 :     {
; 3632 :         DmaStop(pPdd->RxDmaInfo);

  000cc	e1a00003	 mov         r0, r3
  000d0	eb000000	 bl          DmaStop

; 3633 :         EnterCriticalSection(&pPdd->RxUpdatePtrCS);

  000d4	e28400c0	 add         r0, r4, #0xC0
  000d8	eb000000	 bl          EnterCriticalSection

; 3634 :         UpdateDMARxPointer(pPdd, TRUE, 0);

  000dc	e3a02000	 mov         r2, #0
  000e0	e3a01001	 mov         r1, #1
  000e4	e1a00004	 mov         r0, r4
  000e8	eb000000	 bl          UpdateDMARxPointer

; 3635 :         DmaStart(pPdd->RxDmaInfo);

  000ec	e5943124	 ldr         r3, [r4, #0x124]

; 3636 :         LeaveCriticalSection(&pPdd->RxUpdatePtrCS);

  000f0	e28400c0	 add         r0, r4, #0xC0
  000f4	e5932014	 ldr         r2, [r3, #0x14]
  000f8	e5923000	 ldr         r3, [r2]
  000fc	e3833080	 orr         r3, r3, #0x80
  00100	e5823000	 str         r3, [r2]
  00104	eb000000	 bl          LeaveCriticalSection
  00108		 |$LN3@HWPurgeCom|

; 3637 :         DEBUGMSG(ZONE_FUNCTION, (TEXT("PurgeComm: Last Write Pos: 0x%x"),
; 3638 :                 DmaGetLastWritePos(pPdd->RxDmaInfo)));
; 3639 :     }
; 3640 :     // purge on TX DMA if Application has not set the timeout value.
; 3641 :     if(pPdd->TxDmaInfo && (action & PURGE_TXCLEAR))

  00108	e5943100	 ldr         r3, [r4, #0x100]
  0010c	e1b00003	 movs        r0, r3
  00110	0a000006	 beq         |$LN1@HWPurgeCom|
  00114	e3580000	 cmp         r8, #0

; 3642 :     {
; 3643 :         if(IsDmaEnable(pPdd->TxDmaInfo)) DmaStop(pPdd->TxDmaInfo);

  00118	15903014	 ldrne       r3, [r0, #0x14]
  0011c	15933000	 ldrne       r3, [r3]
  00120	158d3000	 strne       r3, [sp]
  00124	159d3000	 ldrne       r3, [sp]
  00128	13130080	 tstne       r3, #0x80
  0012c	1b000000	 blne        DmaStop
  00130		 |$LN1@HWPurgeCom|

; 3644 :     }
; 3645 :     DEBUGMSG(ZONE_FUNCTION, (L"-HWPurgeComm\r\n"));
; 3646 : }

  00130	e28dd004	 add         sp, sp, #4
  00134	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00138	e12fff1e	 bx          lr
  0013c		 |$M47805|

			 ENDP  ; |HWPurgeComm|


  00000			 AREA	 |.pdata|, PDATA
|$T47819| DCD	|$LN8@HWSetDCB|
	DCD	0x40001a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWSetDCB| PROC

; 3662 : {

  00000		 |$LN8@HWSetDCB|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M47816|
  00004	e1a04001	 mov         r4, r1
  00008	e1a06000	 mov         r6, r0

; 3663 :     UARTPDD *pPdd = (UARTPDD*)pvContext;
; 3664 :     BOOL rc = FALSE;
; 3665 : 
; 3666 :     DEBUGMSG(ZONE_FUNCTION, (
; 3667 :         L"+HWSetDCB(0x%08x, 0x%08x\r\n", pvContext, pDCB
; 3668 :         ));
; 3669 :     // Check for same XON/XOFF characters...
; 3670 :     if (((pDCB->fOutX != 0) || (pDCB->fInX != 0)) &&
; 3671 :         (pDCB->XonChar == pDCB->XoffChar))

  0000c	e5943008	 ldr         r3, [r4, #8]
  00010	e3a05000	 mov         r5, #0
  00014	e3130c01	 tst         r3, #1, 24
  00018	1a000001	 bne         |$LN2@HWSetDCB|
  0001c	e3130c02	 tst         r3, #2, 24
  00020	0a000003	 beq         |$LN3@HWSetDCB|
  00024		 |$LN2@HWSetDCB|
  00024	e1d421d6	 ldrsb       r2, [r4, #0x16]
  00028	e1d431d5	 ldrsb       r3, [r4, #0x15]
  0002c	e1530002	 cmp         r3, r2
  00030	0a000009	 beq         |$cleanUp$46021|
  00034		 |$LN3@HWSetDCB|

; 3672 :     {
; 3673 :         goto cleanUp;
; 3674 :     }
; 3675 : 
; 3676 :     // Update COMM port setting according DCB. SetDCB checks the flags in pPdd->pDCB
; 3677 :     // before updating the register value if the 3rd parameter is FALSE.
; 3678 :     rc = SetDCB(pPdd, pDCB, FALSE);

  00034	e3a02000	 mov         r2, #0
  00038	e1a01004	 mov         r1, r4
  0003c	e1a00006	 mov         r0, r6
  00040	eb000000	 bl          SetDCB
  00044	e1a05000	 mov         r5, r0

; 3679 : 
; 3680 :     // Now that we have done the right thing, store this DCB
; 3681 :     if (rc == TRUE)

  00048	e3550001	 cmp         r5, #1

; 3682 :     {
; 3683 :         pPdd->dcb = *pDCB;

  0004c	02860058	 addeq       r0, r6, #0x58
  00050	03a0201c	 moveq       r2, #0x1C
  00054	01a01004	 moveq       r1, r4
  00058	0b000000	 bleq        memcpy
  0005c		 |$cleanUp$46021|

; 3684 :     }
; 3685 : 
; 3686 : 
; 3687 : cleanUp:
; 3688 :     DEBUGMSG(ZONE_FUNCTION, (L"-HWSetDCB(rc = %d)\r\n", rc));
; 3689 :     return rc;
; 3690 : }

  0005c	e1a00005	 mov         r0, r5
  00060	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00064	e12fff1e	 bx          lr
  00068		 |$M47817|

			 ENDP  ; |HWSetDCB|


  00000			 AREA	 |.pdata|, PDATA
|$T47830| DCD	|$LN5@HWSetCommT|
	DCD	0x40000701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWSetCommTimeouts| PROC

; 3704 : {

  00000		 |$LN5@HWSetCommT|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M47827|

; 3705 :     UARTPDD *pPdd = (UARTPDD*)pvContext;
; 3706 :     DEBUGMSG(ZONE_FUNCTION, (L"+HWSetCommTimeouts()\r\n"));
; 3707 :     pPdd->commTimeouts = *pCommTimeouts;

  00004	e28000d8	 add         r0, r0, #0xD8
  00008	e3a02014	 mov         r2, #0x14
  0000c	eb000000	 bl          memcpy

; 3708 :     DEBUGMSG(ZONE_FUNCTION, (L"-HWSetCommTimeouts()\r\n"));
; 3709 :     return TRUE;

  00010	e3a00001	 mov         r0, #1

; 3710 : }

  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$M47828|

			 ENDP  ; |HWSetCommTimeouts|

	IMPORT	|SetLastError|
	IMPORT	|__C_specific_handler|

  00000			 AREA	 |.pdata|, PDATA
|$T47897| DCD	|$LN74@HWIOCtl|
	DCD	0xc0008304

  00000			 AREA	 |.pdata|, PDATA
|$T47899| DCD	|$LN32@HWIOCtl|
	DCD	0x40000301

  00000			 AREA	 |.pdata|, PDATA
|$T47901| DCD	|$LN53@HWIOCtl|
	DCD	0x40000301

  00000			 AREA	 |.pdata|, PDATA
|$T47903| DCD	|$LN46@HWIOCtl|
	DCD	0x40000301

  00000			 AREA	 |.pdata|, PDATA
|$T47905| DCD	|$LN39@HWIOCtl|
	DCD	0x40000701

  00000			 AREA	 |.xdata|, DATA
|$T47895| DCD	0x4
	DCD	|$LN36@HWIOCtl|
	DCD	|$LN37@HWIOCtl|
	DCD	|$LN32@HWIOCtl|
	DCD	|$LN33@HWIOCtl|
	DCD	|$LN57@HWIOCtl|
	DCD	|$LN58@HWIOCtl|
	DCD	|$LN53@HWIOCtl|
	DCD	|$LN54@HWIOCtl|
	DCD	|$LN50@HWIOCtl|
	DCD	|$LN51@HWIOCtl|
	DCD	|$LN46@HWIOCtl|
	DCD	|$LN47@HWIOCtl|
	DCD	|$LN43@HWIOCtl|
	DCD	|$LN44@HWIOCtl|
	DCD	|$LN39@HWIOCtl|
	DCD	|$LN40@HWIOCtl|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T47895|

  00008		 |HWIOCtl| PROC

; 3727 : {

  00008		 |$LN74@HWIOCtl|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d5870	 stmdb       sp!, {r4 - r6, r11, r12, lr}
  00010	e28db018	 add         r11, sp, #0x18
  00014	e24dd008	 sub         sp, sp, #8
  00018		 |$LN72@HWIOCtl|
  00018	e1a06002	 mov         r6, r2
  0001c	e1a05000	 mov         r5, r0
  00020	e3a0281b	 mov         r2, #0x1B, 16

; 3728 :     BOOL rc = FALSE;
; 3729 :     UARTPDD *pPdd = (UARTPDD*)pvContext;
; 3730 : 
; 3731 :     DEBUGMSG(ZONE_FUNCTION, (TEXT("+HWIOCtl()\r\n")));
; 3732 : 
; 3733 :     switch (code)

  00024	e382e03c	 orr         lr, r2, #0x3C
  00028	e3a04000	 mov         r4, #0
  0002c	e151000e	 cmp         r1, lr
  00030	e50b4020	 str         r4, [r11, #-0x20]
  00034	0a000065	 beq         |$LN24@HWIOCtl|
  00038	e3a0281b	 mov         r2, #0x1B, 16
  0003c	e382e040	 orr         lr, r2, #0x40
  00040	e151000e	 cmp         r1, lr
  00044	0a00005a	 beq         |$LN21@HWIOCtl|
  00048	e3a03832	 mov         r3, #0x32, 16
  0004c	e3833a01	 orr         r3, r3, #1, 20
  00050	e1510003	 cmp         r1, r3
  00054	0a00003d	 beq         |$LN18@HWIOCtl|
  00058	e59f31f0	 ldr         r3, [pc, #0x1F0]
  0005c	e1510003	 cmp         r1, r3
  00060	0a00002d	 beq         |$LN5@HWIOCtl|
  00064	e59f31e0	 ldr         r3, [pc, #0x1E0]
  00068	e1510003	 cmp         r1, r3
  0006c	0a000015	 beq         |$LN9@HWIOCtl|
  00070	e59f31d0	 ldr         r3, [pc, #0x1D0]
  00074	e1510003	 cmp         r1, r3
  00078	0a000004	 beq         |$LN13@HWIOCtl|
  0007c	e59f31c0	 ldr         r3, [pc, #0x1C0]
  00080	e1510003	 cmp         r1, r3
  00084	1a00005e	 bne         |$LN25@HWIOCtl|

; 3843 :         {
; 3844 :             DEBUGMSG(ZONE_ERROR, (L"ERROR: UART::HWIOCtl: "
; 3845 :                 L"Exception in IOCTL_POWER_GET\r\n"
; 3846 :                 ));
; 3847 :         }
; 3848 :         break;
; 3849 : 
; 3850 :     case IOCTL_CONTEXT_RESTORE:
; 3851 :         RestoreUARTContext(pPdd);

  00088	eb000000	 bl          RestoreUARTContext

; 3852 :         break;

  0008c	ea00005c	 b           |$LN25@HWIOCtl|
  00090		 |$LN13@HWIOCtl|

; 3778 :         {
; 3779 :             DEBUGMSG(ZONE_ERROR, (L"ERROR: UART::HWIOCtl: "
; 3780 :                 L"Exception in IOCTL_POWER_CAPABILITIES\r\n"
; 3781 :                 ));
; 3782 :         }
; 3783 :         break;
; 3784 : 
; 3785 :     case IOCTL_POWER_QUERY:
; 3786 :         if ((pOutBuffer == NULL) ||
; 3787 :             (outSize < sizeof(CEDEVICE_POWER_STATE)))

  00090	e59b2000	 ldr         r2, [r11]
  00094	e3520000	 cmp         r2, #0
  00098	0a000057	 beq         |$LN22@HWIOCtl|
  0009c	e59b3004	 ldr         r3, [r11, #4]
  000a0	e3530004	 cmp         r3, #4
  000a4	3a000054	 bcc         |$LN22@HWIOCtl|
  000a8		 |$LN43@HWIOCtl|

; 3788 :         {
; 3789 :             SetLastError(ERROR_INVALID_PARAMETER);
; 3790 :             break;
; 3791 :         }
; 3792 :         __try
; 3793 :         {
; 3794 :             CEDEVICE_POWER_STATE dx = *(CEDEVICE_POWER_STATE*)pOutBuffer;

  000a8	e5923000	 ldr         r3, [r2]

; 3795 :             rc = VALID_DX(dx);

  000ac	e3530004	 cmp         r3, #4
  000b0	93a04001	 movls       r4, #1
  000b4	83a04000	 movhi       r4, #0
  000b8	e50b4020	 str         r4, [r11, #-0x20]
  000bc		 |$LN44@HWIOCtl|

; 3796 :         }

  000bc	ea000050	 b           |$LN25@HWIOCtl|
  000c0		 |$LN40@HWIOCtl|

; 3797 :         __except(EXCEPTION_EXECUTE_HANDLER)

  000c0	e51b4020	 ldr         r4, [r11, #-0x20]
  000c4	ea00004e	 b           |$LN25@HWIOCtl|
  000c8		 |$LN9@HWIOCtl|

; 3798 :         {
; 3799 :             DEBUGMSG(ZONE_ERROR, (L"ERROR: UART::HWIOCtl: "
; 3800 :                 L"Exception in IOCTL_POWER_QUERY\r\n"
; 3801 :                 ));
; 3802 :         }
; 3803 :         break;
; 3804 : 
; 3805 :     case IOCTL_POWER_SET:
; 3806 :         if ((pOutBuffer == NULL) ||
; 3807 :             (outSize < sizeof(CEDEVICE_POWER_STATE)))

  000c8	e59b6000	 ldr         r6, [r11]
  000cc	e3560000	 cmp         r6, #0
  000d0	0a000049	 beq         |$LN22@HWIOCtl|
  000d4	e59b3004	 ldr         r3, [r11, #4]
  000d8	e3530004	 cmp         r3, #4
  000dc	3a000046	 bcc         |$LN22@HWIOCtl|
  000e0		 |$LN50@HWIOCtl|

; 3808 :         {
; 3809 :             SetLastError(ERROR_INVALID_PARAMETER);
; 3810 :             break;
; 3811 :         }
; 3812 :         __try
; 3813 :         {
; 3814 :             CEDEVICE_POWER_STATE dx = *(CEDEVICE_POWER_STATE*)pOutBuffer;

  000e0	e5963000	 ldr         r3, [r6]

; 3815 :             pPdd->externalDX = dx;
; 3816 :             SetPower(pPdd, dx);

  000e4	e1a00005	 mov         r0, r5
  000e8	e1a01003	 mov         r1, r3
  000ec	e5853034	 str         r3, [r5, #0x34]
  000f0	eb000000	 bl          SetPower

; 3817 :             *(CEDEVICE_POWER_STATE*)pOutBuffer = pPdd->externalDX;

  000f4	e5953034	 ldr         r3, [r5, #0x34]

; 3818 :             *pOutSize = sizeof(CEDEVICE_POWER_STATE);

  000f8	e59b2008	 ldr         r2, [r11, #8]
  000fc	e3a01004	 mov         r1, #4
  00100	e5863000	 str         r3, [r6]
  00104	e5821000	 str         r1, [r2]

; 3819 :             
; 3820 :             rc = TRUE;

  00108	e3a04001	 mov         r4, #1
  0010c	e50b4020	 str         r4, [r11, #-0x20]
  00110		 |$LN51@HWIOCtl|

; 3821 :         }

  00110	ea00003b	 b           |$LN25@HWIOCtl|
  00114		 |$LN47@HWIOCtl|

; 3822 :         __except(EXCEPTION_EXECUTE_HANDLER)

  00114	e51b4020	 ldr         r4, [r11, #-0x20]
  00118	ea000039	 b           |$LN25@HWIOCtl|
  0011c		 |$LN5@HWIOCtl|

; 3823 :         {
; 3824 :             DEBUGMSG(ZONE_ERROR, (L"ERROR: UART::HWIOCtl: "
; 3825 :                 L"Exception in IOCTL_POWER_SET\r\n"
; 3826 :                 ));
; 3827 :         }
; 3828 :         break;
; 3829 : 
; 3830 :     case IOCTL_POWER_GET:
; 3831 :         if ((pOutBuffer == NULL) ||
; 3832 :             (outSize < sizeof(CEDEVICE_POWER_STATE)))

  0011c	e59b2000	 ldr         r2, [r11]
  00120	e3520000	 cmp         r2, #0
  00124	0a000034	 beq         |$LN22@HWIOCtl|
  00128	e59b3004	 ldr         r3, [r11, #4]
  0012c	e3530004	 cmp         r3, #4
  00130	3a000031	 bcc         |$LN22@HWIOCtl|
  00134		 |$LN57@HWIOCtl|

; 3833 :         {
; 3834 :             SetLastError(ERROR_INVALID_PARAMETER);
; 3835 :             break;
; 3836 :         }
; 3837 :         __try
; 3838 :         {
; 3839 :             *(CEDEVICE_POWER_STATE*)pOutBuffer = pPdd->externalDX;

  00134	e5953034	 ldr         r3, [r5, #0x34]
  00138	e5823000	 str         r3, [r2]

; 3840 :             rc = TRUE;

  0013c	e3a04001	 mov         r4, #1
  00140	e50b4020	 str         r4, [r11, #-0x20]
  00144		 |$LN58@HWIOCtl|

; 3841 :         }

  00144	ea00002e	 b           |$LN25@HWIOCtl|
  00148		 |$LN54@HWIOCtl|

; 3842 :         __except(EXCEPTION_EXECUTE_HANDLER)

  00148	e51b4020	 ldr         r4, [r11, #-0x20]
  0014c	ea00002c	 b           |$LN25@HWIOCtl|
  00150		 |$LN18@HWIOCtl|

; 3756 :         }
; 3757 :         rc = TRUE;
; 3758 :         break;
; 3759 : 
; 3760 :     case IOCTL_POWER_CAPABILITIES:
; 3761 :         if ((pOutBuffer == NULL) || (outSize < sizeof(POWER_CAPABILITIES)))

  00150	e59b5000	 ldr         r5, [r11]
  00154	e3550000	 cmp         r5, #0
  00158	0a000027	 beq         |$LN22@HWIOCtl|
  0015c	e59b6004	 ldr         r6, [r11, #4]
  00160	e3560030	 cmp         r6, #0x30
  00164	3a000024	 bcc         |$LN22@HWIOCtl|
  00168		 |$LN36@HWIOCtl|

; 3765 :         }
; 3766 :         __try
; 3767 :         {
; 3768 :             POWER_CAPABILITIES *pCaps = (POWER_CAPABILITIES*)pOutBuffer;
; 3769 :             memset(pCaps, 0, sizeof(POWER_CAPABILITIES));

  00168	e3a02030	 mov         r2, #0x30
  0016c	e3a01000	 mov         r1, #0
  00170	e1a00005	 mov         r0, r5
  00174	eb000000	 bl          memset

; 3770 :             pCaps->DeviceDx = DX_MASK(D0)|DX_MASK(D3)|DX_MASK(D4);

  00178	e3a03019	 mov         r3, #0x19
  0017c	e5c53000	 strb        r3, [r5]

; 3771 :             if ((outSize >= sizeof(DWORD)) && (pOutSize != NULL))

  00180	e3560004	 cmp         r6, #4
  00184	3a000003	 bcc         |$LN14@HWIOCtl|
  00188	e59b3008	 ldr         r3, [r11, #8]
  0018c	e3530000	 cmp         r3, #0

; 3772 :             {
; 3773 :                 *pOutSize = sizeof(POWER_CAPABILITIES);

  00190	13a02030	 movne       r2, #0x30
  00194	15832000	 strne       r2, [r3]
  00198		 |$LN14@HWIOCtl|

; 3774 :             }
; 3775 :             rc = TRUE;

  00198	e3a04001	 mov         r4, #1
  0019c	e50b4020	 str         r4, [r11, #-0x20]
  001a0		 |$LN37@HWIOCtl|

; 3776 :         }

  001a0	ea000017	 b           |$LN25@HWIOCtl|
  001a4		 |$LN33@HWIOCtl|

; 3777 :         __except(EXCEPTION_EXECUTE_HANDLER)

  001a4	e51b4020	 ldr         r4, [r11, #-0x20]
  001a8	ea000015	 b           |$LN25@HWIOCtl|
  001ac		 |$LN68@HWIOCtl|

; 3853 :    }
; 3854 : 
; 3855 :     DEBUGMSG(ZONE_FUNCTION, (TEXT("-HWIOCtl()\r\n")));
; 3856 :     return rc;

  001ac	e51b401c	 ldr         r4, [r11, #-0x1C]

; 3762 :         {
; 3763 :             SetLastError(ERROR_INVALID_PARAMETER);
; 3764 :             break;

  001b0	ea000013	 b           |$LN25@HWIOCtl|
  001b4		 |$LN21@HWIOCtl|

; 3746 :         break;
; 3747 : 
; 3748 :     case IOCTL_SERIAL_GET_TIMEOUTS:
; 3749 :         if ((pInBuffer == NULL) || (inSize < sizeof(COMMTIMEOUTS)) ||
; 3750 :             !CeSafeCopyMemory(
; 3751 :             pInBuffer, &pPdd->commTimeouts, sizeof(COMMTIMEOUTS)
; 3752 :             ))

  001b4	e3560000	 cmp         r6, #0
  001b8	0a00000f	 beq         |$LN22@HWIOCtl|
  001bc	e3530014	 cmp         r3, #0x14
  001c0	3a00000d	 bcc         |$LN22@HWIOCtl|
  001c4	e28510d8	 add         r1, r5, #0xD8
  001c8	e1a00006	 mov         r0, r6

; 3753 :         {
; 3754 :             SetLastError(ERROR_INVALID_PARAMETER);
; 3755 :             break;

  001cc	ea000005	 b           |$LN71@HWIOCtl|
  001d0		 |$LN24@HWIOCtl|

; 3734 :     {
; 3735 :     case IOCTL_SERIAL_SET_TIMEOUTS:
; 3736 :         // Check input parameters
; 3737 :         if ((pInBuffer == NULL) || (inSize < sizeof(COMMTIMEOUTS)) ||
; 3738 :             !CeSafeCopyMemory(
; 3739 :             &pPdd->commTimeouts, pInBuffer, sizeof(COMMTIMEOUTS)
; 3740 :             ))

  001d0	e3560000	 cmp         r6, #0
  001d4	0a000008	 beq         |$LN22@HWIOCtl|
  001d8	e3530014	 cmp         r3, #0x14
  001dc	3a000006	 bcc         |$LN22@HWIOCtl|
  001e0	e1a01006	 mov         r1, r6
  001e4	e28500d8	 add         r0, r5, #0xD8
  001e8		 |$LN71@HWIOCtl|
  001e8	e3a02014	 mov         r2, #0x14
  001ec	eb000000	 bl          CeSafeCopyMemory
  001f0	e3500000	 cmp         r0, #0

; 3743 :             break;
; 3744 :         }
; 3745 :         rc = TRUE;

  001f4	13a04001	 movne       r4, #1

; 3734 :     {
; 3735 :     case IOCTL_SERIAL_SET_TIMEOUTS:
; 3736 :         // Check input parameters
; 3737 :         if ((pInBuffer == NULL) || (inSize < sizeof(COMMTIMEOUTS)) ||
; 3738 :             !CeSafeCopyMemory(
; 3739 :             &pPdd->commTimeouts, pInBuffer, sizeof(COMMTIMEOUTS)
; 3740 :             ))

  001f8	1a000001	 bne         |$LN25@HWIOCtl|
  001fc		 |$LN22@HWIOCtl|

; 3741 :         {
; 3742 :             SetLastError(ERROR_INVALID_PARAMETER);

  001fc	e3a00057	 mov         r0, #0x57
  00200	eb000000	 bl          SetLastError
  00204		 |$LN25@HWIOCtl|

; 3857 : }

  00204	e1a00004	 mov         r0, r4
  00208	e24bd018	 sub         sp, r11, #0x18
  0020c	e89d6870	 ldmia       sp, {r4 - r6, r11, sp, lr}
  00210	e12fff1e	 bx          lr

			 ENDP  ; |HWIOCtl|

  00214		 |$LN32@HWIOCtl|
  00214		 |$LN73@HWIOCtl|

; 3777 :         __except(EXCEPTION_EXECUTE_HANDLER)

  00214	e52de004	 str         lr, [sp, #-4]!
  00218		 |$LN35@HWIOCtl|
  00218		 |$LN79@HWIOCtl|
  00218	e3a00001	 mov         r0, #1
  0021c		 |$LN34@HWIOCtl|
  0021c	e49df004	 ldr         pc, [sp], #4
  00220		 |$LN80@HWIOCtl|
  00220		 |$LN53@HWIOCtl|
  00220		 |$LN75@HWIOCtl|

; 3842 :         __except(EXCEPTION_EXECUTE_HANDLER)

  00220	e52de004	 str         lr, [sp, #-4]!
  00224		 |$LN56@HWIOCtl|
  00224		 |$LN81@HWIOCtl|
  00224	e3a00001	 mov         r0, #1
  00228		 |$LN55@HWIOCtl|
  00228	e49df004	 ldr         pc, [sp], #4
  0022c		 |$LN82@HWIOCtl|
  0022c		 |$LN46@HWIOCtl|
  0022c		 |$LN76@HWIOCtl|

; 3822 :         __except(EXCEPTION_EXECUTE_HANDLER)

  0022c	e52de004	 str         lr, [sp, #-4]!
  00230		 |$LN49@HWIOCtl|
  00230		 |$LN83@HWIOCtl|
  00230	e3a00001	 mov         r0, #1
  00234		 |$LN48@HWIOCtl|
  00234	e49df004	 ldr         pc, [sp], #4
  00238		 |$LN84@HWIOCtl|
  00238		 |$LN39@HWIOCtl|
  00238		 |$LN77@HWIOCtl|

; 3797 :         __except(EXCEPTION_EXECUTE_HANDLER)

  00238	e52de004	 str         lr, [sp, #-4]!
  0023c		 |$LN42@HWIOCtl|
  0023c		 |$LN85@HWIOCtl|
  0023c	e3a00001	 mov         r0, #1
  00240		 |$LN41@HWIOCtl|
  00240	e49df004	 ldr         pc, [sp], #4
  00244		 |$LN87@HWIOCtl|
  00244		 |$LN88@HWIOCtl|
  00244	80038140	 DCD         0x80038140
  00248		 |$LN89@HWIOCtl|
  00248	0032100c	 DCD         0x32100c
  0024c		 |$LN90@HWIOCtl|
  0024c	00321008	 DCD         0x321008
  00250		 |$LN91@HWIOCtl|
  00250	00321004	 DCD         0x321004
  00254		 |$LN86@HWIOCtl|
  00254		 |$LN78@HWIOCtl|
	EXPORT	|??_C@_1EG@OEGIILDN@?$AAH?$AAW?$AAI?$AAn?$AAi?$AAt?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$CB?$AA?$CB?$AA?5?$AAC?$AAa?$AAl?$AAl?$AAi?$AAn?$AAg?$AA?5?$AAH?$AAW?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FE@MELLBIFK@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAe?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAT?$AAX?$AA?5?$AAi?$AAn@| [ DATA ] ; `string'
	IMPORT	|InitializeCriticalSection|
	IMPORT	|AllocPhysMem|
	IMPORT	|DmaAllocateChannel|
	IMPORT	|GPIOOpen|
	IMPORT	|MmMapIoSpace|
	IMPORT	|GetIrqByDevice|
	IMPORT	|GetAddressByDevice|
	IMPORT	|RequestDevicePads|
	IMPORT	|SOCGetUartDeviceByIndex|
	IMPORT	|CreateBusAccessHandle|
	IMPORT	|GetDeviceRegistryParams|
	IMPORT	|LocalAlloc|

  00000			 AREA	 |.pdata|, PDATA
|$T47945| DCD	|$LN35@HWInit|
	DCD	0x40011202

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EG@OEGIILDN@?$AAH?$AAW?$AAI?$AAn?$AAi?$AAt?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$CB?$AA?$CB?$AA?5?$AAC?$AAa?$AAl?$AAl?$AAi?$AAn?$AAg?$AA?5?$AAH?$AAW?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt@| DCB "H"
	DCB	0x0, "W", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, " "
	DCB	0x0, "F", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, "!", 0x0, "!", 0x0, " ", 0x0, "C", 0x0, "a", 0x0, "l"
	DCB	0x0, "l", 0x0, "i", 0x0, "n", 0x0, "g", 0x0, " ", 0x0, "H"
	DCB	0x0, "W", 0x0, "D", 0x0, "e", 0x0, "i", 0x0, "n", 0x0, "i"
	DCB	0x0, "t", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FE@MELLBIFK@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAe?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAT?$AAX?$AA?5?$AAi?$AAn@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, "F"
	DCB	0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, " "
	DCB	0x0, "t", 0x0, "o", 0x0, " ", 0x0, "e", 0x0, "n", 0x0, "a"
	DCB	0x0, "b", 0x0, "l", 0x0, "e", 0x0, " ", 0x0, "D", 0x0, "M"
	DCB	0x0, "A", 0x0, " ", 0x0, "T", 0x0, "X", 0x0, " ", 0x0, "i"
	DCB	0x0, "n", 0x0, "t", 0x0, "e", 0x0, "r", 0x0, "r", 0x0, "u"
	DCB	0x0, "p", 0x0, "t", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HWInit| PROC

; 1614 : {

  00000		 |$LN35@HWInit|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M47942|
  00008	e1a06002	 mov         r6, r2
  0000c	e1a07001	 mov         r7, r1
  00010	e1a05000	 mov         r5, r0

; 1615 :     BOOL rc = FALSE;
; 1616 :     UARTPDD *pPdd = NULL;
; 1617 :     PHYSICAL_ADDRESS pa;
; 1618 :     OMAP_UART_REGS *pUartRegs;
; 1619 : 
; 1620 :     DEBUGMSG(ZONE_OPEN||ZONE_FUNCTION, (
; 1621 :         L"+HWInit(%s, 0x%08x, 0x%08x\r\n", context, pMdd, pHWObj
; 1622 :         ));
; 1623 : 
; 1624 : 
; 1625 :     // Allocate SER_INFO structure
; 1626 :     pPdd = LocalAlloc(LPTR, sizeof(UARTPDD));

  00014	e3a01d06	 mov         r1, #6, 26
  00018	e3a00040	 mov         r0, #0x40
  0001c	eb000000	 bl          LocalAlloc
  00020	e1b04000	 movs        r4, r0

; 1627 :     if (pPdd == NULL) goto cleanUp;

  00024	0a000040	 beq         |$LN1@HWInit|

; 1628 : 
; 1629 :     memset(pPdd, 0x00, sizeof(UARTPDD));

  00028	e3a02d06	 mov         r2, #6, 26
  0002c	e3a01000	 mov         r1, #0
  00030	e1a00004	 mov         r0, r4
  00034	eb000000	 bl          memset

; 1630 : 
; 1631 :     // Read device parameters
; 1632 :     if (GetDeviceRegistryParams(
; 1633 :         (LPCWSTR)context, pPdd, dimof(s_deviceRegParams), s_deviceRegParams
; 1634 :         ) != ERROR_SUCCESS)

  00038	e59f3404	 ldr         r3, [pc, #0x404]
  0003c	e3a0200f	 mov         r2, #0xF
  00040	e1a01004	 mov         r1, r4
  00044	e1a00005	 mov         r0, r5
  00048	eb000000	 bl          GetDeviceRegistryParams
  0004c	e3500000	 cmp         r0, #0
  00050	1a000030	 bne         |$LN30@HWInit|

; 1635 : 
; 1636 :     {
; 1637 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: HWInit: "
; 1638 :             L"Failed read driver registry parameters\r\n"
; 1639 :             ));
; 1640 :         goto cleanUp;
; 1641 :     }
; 1642 : 
; 1643 : 
; 1644 :     // Open parent bus
; 1645 :     pPdd->hParentBus = CreateBusAccessHandle((LPCWSTR)context);

  00054	e1a00005	 mov         r0, r5
  00058	eb000000	 bl          CreateBusAccessHandle
  0005c	e3500000	 cmp         r0, #0
  00060	e584002c	 str         r0, [r4, #0x2C]

; 1646 :     if (pPdd->hParentBus == NULL)

  00064	0a00002b	 beq         |$LN30@HWInit|

; 1647 :     {
; 1648 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: HWInit: "
; 1649 :             L"Failed open parent bus driver\r\n"
; 1650 :             ));
; 1651 :         goto cleanUp;
; 1652 :     }
; 1653 : 	// Retrieve device index
; 1654 : 	pPdd->DeviceID = SOCGetUartDeviceByIndex(pPdd->UARTIndex);

  00068	e594000c	 ldr         r0, [r4, #0xC]
  0006c	eb000000	 bl          SOCGetUartDeviceByIndex
  00070	e5840010	 str         r0, [r4, #0x10]

; 1655 : 
; 1656 : 	if (pPdd->DeviceID == OMAP_DEVICE_NONE)

  00074	e3700001	 cmn         r0, #1
  00078	0a000026	 beq         |$LN30@HWInit|

; 1657 : 	{
; 1658 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: HWInit: "
; 1659 :             L"Failed to retrieve valid device ID for this UART\r\n"
; 1660 :             ));
; 1661 :         goto cleanUp;
; 1662 : 	}
; 1663 : 
; 1664 : 	// Perform pads configuration
; 1665 : 	if (!RequestDevicePads(pPdd->DeviceID))

  0007c	eb000000	 bl          RequestDevicePads
  00080	e3500000	 cmp         r0, #0
  00084	0a000023	 beq         |$LN30@HWInit|

; 1666 : 	{
; 1667 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: HWInit: "
; 1668 :             L"Failed to request pads\r\n"
; 1669 :             ));
; 1670 :         goto cleanUp;
; 1671 : 	}
; 1672 : 
; 1673 :     // Map physical memory
; 1674 :     DEBUGMSG(ZONE_INIT, (L"HWInit: MmMapIoSpace: 0x%08x\n", pPdd->memBase[0]));
; 1675 :     
; 1676 :     pPdd->memBase[0] = GetAddressByDevice(pPdd->DeviceID);

  00088	e5940010	 ldr         r0, [r4, #0x10]
  0008c	eb000000	 bl          GetAddressByDevice
  00090	e1a03000	 mov         r3, r0

; 1677 :     pPdd->memLen[0] = sizeof(OMAP_UART_REGS);
; 1678 :     pPdd->irq = GetIrqByDevice(SOCGetUartDeviceByIndex(pPdd->UARTIndex),NULL);

  00094	e594000c	 ldr         r0, [r4, #0xC]
  00098	e3a02061	 mov         r2, #0x61
  0009c	e5843000	 str         r3, [r4]
  000a0	e5842004	 str         r2, [r4, #4]
  000a4	eb000000	 bl          SOCGetUartDeviceByIndex
  000a8	e3a01000	 mov         r1, #0
  000ac	eb000000	 bl          GetIrqByDevice

; 1679 :     // UART registers
; 1680 :     pa.QuadPart = pPdd->memBase[0];
; 1681 :     pUartRegs = MmMapIoSpace(pa, pPdd->memLen[0], FALSE);

  000b0	e5942004	 ldr         r2, [r4, #4]
  000b4	e1a0e000	 mov         lr, r0
  000b8	e5940000	 ldr         r0, [r4]
  000bc	e3a01000	 mov         r1, #0
  000c0	e3a03000	 mov         r3, #0
  000c4	e584e008	 str         lr, [r4, #8]
  000c8	eb000000	 bl          MmMapIoSpace
  000cc	e3500000	 cmp         r0, #0

; 1682 :     if (pUartRegs == NULL)

  000d0	0a000010	 beq         |$LN30@HWInit|

; 1683 :     {
; 1684 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: HWInit: "
; 1685 :             L"Failed map physical memory 0x%08x\r\n", pa.LowPart
; 1686 :             ));
; 1687 :         goto cleanUp;
; 1688 :     }
; 1689 :     pPdd->pUartRegs = pUartRegs;
; 1690 : 
; 1691 :     if ((pPdd->XcvrEnableGpio != 0xFFFF) && ((pPdd->XcvrEnabledLevel == 0) || (pPdd->XcvrEnabledLevel == 1)))

  000d4	e5942170	 ldr         r2, [r4, #0x170]
  000d8	e3a03cff	 mov         r3, #0xFF, 24
  000dc	e38330ff	 orr         r3, r3, #0xFF
  000e0	e1520003	 cmp         r2, r3
  000e4	e5840024	 str         r0, [r4, #0x24]
  000e8	0a000013	 beq         |$LN17@HWInit|
  000ec	e5943174	 ldr         r3, [r4, #0x174]
  000f0	e3530000	 cmp         r3, #0
  000f4	0a000001	 beq         |$LN18@HWInit|
  000f8	e3530001	 cmp         r3, #1
  000fc	1a00000e	 bne         |$LN17@HWInit|
  00100		 |$LN18@HWInit|

; 1692 :     {
; 1693 :         DEBUGMSG(ZONE_INIT, (L"HWInit: External transceiver controlled with gpio %d\n", pPdd->XcvrEnableGpio));
; 1694 :         // GPIO used to control external transceiver
; 1695 :         pPdd->hGpio = GPIOOpen();

  00100	eb000000	 bl          GPIOOpen
  00104	e584016c	 str         r0, [r4, #0x16C]

; 1696 :         if (pPdd->hGpio == INVALID_HANDLE_VALUE)

  00108	e3700001	 cmn         r0, #1
  0010c	1a00000a	 bne         |$LN17@HWInit|

; 1697 :         {
; 1698 :             pPdd->hGpio = NULL;

  00110	e3a03000	 mov         r3, #0
  00114	e584316c	 str         r3, [r4, #0x16C]
  00118		 |$LN30@HWInit|

; 1938 :     {
; 1939 :         RETAILMSG(1,(TEXT("HWInit Failed!! Calling HWDeinit\r\n")));

  00118	e59f0320	 ldr         r0, [pc, #0x320]
  0011c	eb000000	 bl          NKDbgPrintfW

; 1940 :         HWDeinit(pPdd);

  00120	e1a00004	 mov         r0, r4
  00124	eb000000	 bl          HWDeinit

; 1941 :         pPdd = NULL;

  00128	e3a04000	 mov         r4, #0
  0012c		 |$LN1@HWInit|

; 1942 :     }
; 1943 :     DEBUGMSG(ZONE_OPEN||ZONE_FUNCTION, (L"-HWInit(pPdd = 0x%08x)\r\n", pPdd));
; 1944 : 
; 1945 :     return pPdd;
; 1946 : }

  0012c	e1a00004	 mov         r0, r4
  00130	e28dd008	 add         sp, sp, #8
  00134	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00138	e12fff1e	 bx          lr
  0013c		 |$LN17@HWInit|

; 1699 :      
; 1700 :             DEBUGMSG(ZONE_ERROR, (L"ERROR: HWInit: "
; 1701 :                 L"Failed to open gpio driver!\r\n"
; 1702 :                 ));
; 1703 :             goto cleanUp;
; 1704 :         }
; 1705 :     }
; 1706 :             
; 1707 :         
; 1708 :     pPdd->bHWXmitComCharWaiting = FALSE;
; 1709 : 
; 1710 :     DEBUGMSG(ZONE_INIT, (L"HWInit: TxDmaRequest= %d\n", pPdd->TxDmaRequest));
; 1711 : 
; 1712 :     pPdd->TxDmaInfo = NULL;     // init TX DMA as not used
; 1713 : 
; 1714 :     // Should driver use DMA for TX?
; 1715 :     if (pPdd->TxDmaRequest == -1)

  0013c	e59430f0	 ldr         r3, [r4, #0xF0]
  00140	e3a08000	 mov         r8, #0
  00144	e5848130	 str         r8, [r4, #0x130]
  00148	e3730001	 cmn         r3, #1
  0014c	e5848100	 str         r8, [r4, #0x100]
  00150	0a00003b	 beq         |$skipTXDMA$45359|

; 1716 :         {
; 1717 :             RETAILMSG(FALSE, (L"TX - DMA Disabled \r\n"));
; 1718 :             goto skipTXDMA;         // use FIFO, not DMA for TX.
; 1719 :         }
; 1720 : 
; 1721 :     // allocate dma channel
; 1722 :     pPdd->hTxDmaChannel = DmaAllocateChannel(DMA_TYPE_SYSTEM);

  00154	e3a00000	 mov         r0, #0
  00158	eb000000	 bl          DmaAllocateChannel
  0015c	e3500000	 cmp         r0, #0
  00160	e5840104	 str         r0, [r4, #0x104]

; 1723 :     if (pPdd->hTxDmaChannel != NULL)

  00164	0a000036	 beq         |$skipTXDMA$45359|

; 1724 :     {
; 1725 :         DEBUGMSG(ZONE_INIT, (L"OMAP35XX TX DMA enabled\r\n"));
; 1726 : 
; 1727 :         pPdd->TxDmaInfo = LocalAlloc(LMEM_ZEROINIT,sizeof(DmaDataInfo_t));

  00168	e3a01018	 mov         r1, #0x18
  0016c	e3a00040	 mov         r0, #0x40
  00170	eb000000	 bl          LocalAlloc
  00174	e3500000	 cmp         r0, #0
  00178	e5840100	 str         r0, [r4, #0x100]

; 1728 :         if(!pPdd->TxDmaInfo)

  0017c	0a000030	 beq         |$skipTXDMA$45359|

; 1729 :         {
; 1730 :             DEBUGMSG(ZONE_ERROR, (L"ERROR: HWInit: "
; 1731 :                 L"Cannot allocate DMA on TX\r\n"
; 1732 :                 ));
; 1733 :             goto skipTXDMA;
; 1734 :         }
; 1735 :         if (pPdd->TxDmaBufferSize < MAX_TX_SERIALDMA_FRAMESIZE)

  00180	e594e0f4	 ldr         lr, [r4, #0xF4]
  00184	e35e003f	 cmp         lr, #0x3F
  00188	2a000002	 bcs         |$LN13@HWInit|
  0018c		 |$LN31@HWInit|

; 1736 :         {
; 1737 :             DEBUGMSG(ZONE_ERROR, (L"ERROR: HWInit: "
; 1738 :                 L"TxDmaBufferSize must be at least %u bytes\r\n",
; 1739 :                 MAX_TX_SERIALDMA_FRAMESIZE
; 1740 :                 ));
; 1741 : 
; 1742 :             LocalFree(pPdd->TxDmaInfo);

  0018c	eb000000	 bl          LocalFree

; 1743 :             pPdd->TxDmaInfo = NULL;

  00190	e5848100	 str         r8, [r4, #0x100]

; 1744 :             goto skipTXDMA;

  00194	ea00002a	 b           |$skipTXDMA$45359|
  00198		 |$LN13@HWInit|

; 1745 :         }
; 1746 : 
; 1747 :         // Allocate DMA transfer buffer
; 1748 :         pPdd->pTxDmaBuffer = AllocPhysMem(
; 1749 :             pPdd->TxDmaBufferSize, PAGE_READWRITE|PAGE_NOCACHE, 0, 0, &pPdd->paTxDmaBuffer
; 1750 :             );

  00198	e28430fc	 add         r3, r4, #0xFC
  0019c	e58d3000	 str         r3, [sp]
  001a0	e3a03000	 mov         r3, #0
  001a4	e3a02000	 mov         r2, #0
  001a8	e3a01f81	 mov         r1, #0x81, 30
  001ac	e1a0000e	 mov         r0, lr
  001b0	eb000000	 bl          AllocPhysMem
  001b4	e3500000	 cmp         r0, #0
  001b8	e58400f8	 str         r0, [r4, #0xF8]

; 1751 : 
; 1752 :         if (pPdd->pTxDmaBuffer == NULL)
; 1753 :         {
; 1754 :             DEBUGMSG(ZONE_ERROR, (L"ERROR: HWInit: "
; 1755 :                 L"Failed allocating TX buffer (size %u)\r\n", pPdd->TxDmaBufferSize
; 1756 :                 ));
; 1757 :             LocalFree(pPdd->TxDmaInfo);

  001bc	05940100	 ldreq       r0, [r4, #0x100]
  001c0	0afffff1	 beq         |$LN31@HWInit|

; 1758 :             pPdd->TxDmaInfo = NULL;
; 1759 :             goto skipTXDMA;
; 1760 :         }
; 1761 :         DEBUGMSG(ZONE_INIT, (L"OMAP35XX TX DMA buffer allocated\r\n"));
; 1762 : 
; 1763 :         pPdd->TxDmaInfo->pSrcBuffer = NULL;

  001c4	e5941100	 ldr         r1, [r4, #0x100]

; 1764 :         pPdd->TxDmaInfo->pDstBuffer = NULL;
; 1765 :         pPdd->TxDmaInfo->PhysAddrSrcBuffer = 0;
; 1766 :         pPdd->TxDmaInfo->PhysAddrDstBuffer = 0;
; 1767 :         pPdd->bExitThread = FALSE;
; 1768 :         pPdd->bSendSignal = FALSE;
; 1769 :         pPdd->bRxBreak = FALSE;
; 1770 :         
; 1771 :         //Event for Tx DMA Endofblock
; 1772 :         pPdd->hEventTxIstDma = CreateEvent(NULL, FALSE, FALSE, NULL);

  001c8	e3a03000	 mov         r3, #0
  001cc	e3a02000	 mov         r2, #0
  001d0	e5818000	 str         r8, [r1]
  001d4	e594e100	 ldr         lr, [r4, #0x100]
  001d8	e3a01000	 mov         r1, #0
  001dc	e3a00000	 mov         r0, #0
  001e0	e58e8004	 str         r8, [lr, #4]
  001e4	e594e100	 ldr         lr, [r4, #0x100]
  001e8	e58e8008	 str         r8, [lr, #8]
  001ec	e594e100	 ldr         lr, [r4, #0x100]
  001f0	e58e800c	 str         r8, [lr, #0xC]
  001f4	e5848138	 str         r8, [r4, #0x138]
  001f8	e5848134	 str         r8, [r4, #0x134]
  001fc	e5848178	 str         r8, [r4, #0x178]
  00200	eb000000	 bl          CreateEventW
  00204	e1a03000	 mov         r3, r0

; 1773 : 
; 1774 :         // register dma for interrupts
; 1775 :         if (DmaEnableInterrupts(pPdd->hTxDmaChannel, pPdd->hEventTxIstDma) == FALSE)

  00208	e5940104	 ldr         r0, [r4, #0x104]
  0020c	e1a01003	 mov         r1, r3
  00210	e5843108	 str         r3, [r4, #0x108]
  00214	eb000000	 bl          DmaEnableInterrupts
  00218	e3500000	 cmp         r0, #0
  0021c	1a000006	 bne         |$LN11@HWInit|

; 1776 :         {
; 1777 :             RETAILMSG(1,(TEXT("ERROR:Failed to enable DMA TX interrupt\r\n")));

  00220	e59f0214	 ldr         r0, [pc, #0x214]
  00224	eb000000	 bl          NKDbgPrintfW

; 1778 :             FreePhysMem( pPdd->pTxDmaBuffer );

  00228	e59400f8	 ldr         r0, [r4, #0xF8]
  0022c	eb000000	 bl          FreePhysMem

; 1779 :             pPdd->pTxDmaBuffer = NULL;
; 1780 :             LocalFree(pPdd->TxDmaInfo);

  00230	e5940100	 ldr         r0, [r4, #0x100]
  00234	e58480f8	 str         r8, [r4, #0xF8]

; 1781 :             pPdd->TxDmaInfo = NULL;
; 1782 :             goto skipTXDMA;

  00238	eaffffd3	 b           |$LN31@HWInit|
  0023c		 |$LN11@HWInit|

; 1783 :         }
; 1784 :         // Tx DMA configuration settings
; 1785 : 
; 1786 :         InitializeTxDMA(pPdd);

  0023c	e1a00004	 mov         r0, r4
  00240	eb000000	 bl          InitializeTxDMA
  00244		 |$skipTXDMA$45359|

; 1787 : 
; 1788 :         DEBUGMSG(ZONE_INIT, (L"OMAP35XX TX DMA init completed\r\n"));
; 1789 : 
; 1790 :     }
; 1791 : skipTXDMA:
; 1792 : 
; 1793 :     pPdd->RxDmaInfo = NULL; // init RX DMA not used
; 1794 :     pPdd->hRxDmaChannel = NULL;
; 1795 : 
; 1796 :     DEBUGMSG(ZONE_INIT, (L"HWInit: RxDmaRequest= %d\n", pPdd->RxDmaRequest));
; 1797 : 
; 1798 :     // Should driver use DMA for RX?
; 1799 :     if (pPdd->RxDmaRequest == -1)

  00244	e594310c	 ldr         r3, [r4, #0x10C]
  00248	e5848124	 str         r8, [r4, #0x124]
  0024c	e584812c	 str         r8, [r4, #0x12C]
  00250	e3730001	 cmn         r3, #1
  00254	0a000032	 beq         |$skipRXDMA$45387|

; 1800 :         {
; 1801 :             RETAILMSG(FALSE, (L"RX - DMA Disabled\r\n"));
; 1802 :             goto skipRXDMA; // use FIFO, not DMA for RX.
; 1803 :         }
; 1804 : 
; 1805 :     // allocate dma channel
; 1806 :     pPdd->hRxDmaChannel = DmaAllocateChannel(DMA_TYPE_SYSTEM);

  00258	e3a00000	 mov         r0, #0
  0025c	eb000000	 bl          DmaAllocateChannel
  00260	e3500000	 cmp         r0, #0
  00264	e584012c	 str         r0, [r4, #0x12C]

; 1807 :     if (pPdd->hRxDmaChannel != NULL)

  00268	0a00002d	 beq         |$skipRXDMA$45387|

; 1808 :     {
; 1809 : 
; 1810 :         pPdd->RxDmaInfo = LocalAlloc(LMEM_ZEROINIT,sizeof(DmaDataInfo_t));

  0026c	e3a01018	 mov         r1, #0x18
  00270	e3a00040	 mov         r0, #0x40
  00274	eb000000	 bl          LocalAlloc
  00278	e3500000	 cmp         r0, #0
  0027c	e5840124	 str         r0, [r4, #0x124]

; 1811 :         if(!pPdd->RxDmaInfo)

  00280	0a000027	 beq         |$skipRXDMA$45387|

; 1812 :         {
; 1813 :             DEBUGMSG(ZONE_ERROR, (L"ERROR: HWInit: "
; 1814 :                 L"Cannot allocate DMA on RX\r\n"
; 1815 :                 ));
; 1816 :             goto skipRXDMA;
; 1817 :         }
; 1818 : 
; 1819 :         if (pPdd->RxDmaBufferSize < MAX_RX_SERIALDMA_FRAMESIZE)

  00284	e594e110	 ldr         lr, [r4, #0x110]
  00288	e35e003f	 cmp         lr, #0x3F
  0028c	2a000002	 bcs         |$LN7@HWInit|
  00290		 |$LN32@HWInit|

; 1820 :         {
; 1821 :             DEBUGMSG(ZONE_ERROR, (L"ERROR: HWInit: "
; 1822 :                 L"RxDmaBufferSize must be at least %u bytes\r\n",
; 1823 :                 MAX_TX_SERIALDMA_FRAMESIZE
; 1824 :                 ));
; 1825 :             LocalFree(pPdd->RxDmaInfo);

  00290	eb000000	 bl          LocalFree

; 1826 :             pPdd->RxDmaInfo = NULL;

  00294	e5848124	 str         r8, [r4, #0x124]

; 1827 :             goto skipRXDMA;

  00298	ea000021	 b           |$skipRXDMA$45387|
  0029c		 |$LN7@HWInit|

; 1828 :         }
; 1829 : 
; 1830 :         if (pPdd->dwRxFifoTriggerLevel > UART_FIFO_SIZE)

  0029c	e5943154	 ldr         r3, [r4, #0x154]

; 1831 :         {
; 1832 :             DEBUGMSG(ZONE_INIT, (L"HWInit: "
; 1833 :                 L"RxFifoTriggerLevel must be less then FIFO size %d. Reset to default trigger level %d.\r\n",
; 1834 :                 UART_FIFO_SIZE, DEFAULT_RX_FIFO_TRIGGER_LEVEL
; 1835 :                 ));
; 1836 :             pPdd->dwRxFifoTriggerLevel = DEFAULT_RX_FIFO_TRIGGER_LEVEL;
; 1837 :         }
; 1838 : 
; 1839 :         // Allocate DMA receive buffer. We need to allocate a few bytes more than we should
; 1840 :         // because the total number of bytes in a DMA transfer must be equal to mutliple of
; 1841 :         // frame size. In our case, the frame size is never greater than the FIFO size, so 
; 1842 :         // we simply allocate extra 64 byte (FIFO size) for the DMA buffer.
; 1843 :         pPdd->pRxDmaBuffer = AllocPhysMem(
; 1844 :             pPdd->RxDmaBufferSize + UART_FIFO_SIZE, PAGE_READWRITE|PAGE_NOCACHE, 0, 0,
; 1845 :             &pPdd->paRxDmaBuffer
; 1846 :             );

  002a0	e3a02000	 mov         r2, #0
  002a4	e3a01f81	 mov         r1, #0x81, 30
  002a8	e3530040	 cmp         r3, #0x40
  002ac	83a03020	 movhi       r3, #0x20
  002b0	85843154	 strhi       r3, [r4, #0x154]
  002b4	e2843f46	 add         r3, r4, #0x46, 30
  002b8	e58d3000	 str         r3, [sp]
  002bc	e3a03000	 mov         r3, #0
  002c0	e28e0040	 add         r0, lr, #0x40
  002c4	eb000000	 bl          AllocPhysMem
  002c8	e3500000	 cmp         r0, #0
  002cc	e5840114	 str         r0, [r4, #0x114]

; 1847 : 
; 1848 :         if (pPdd->pRxDmaBuffer == NULL)
; 1849 :         {
; 1850 :             DEBUGMSG(ZONE_ERROR, (L"ERROR: HWInit: "
; 1851 :                 L"Failed allocating transfer buffer (size %u)\r\n",
; 1852 :                 pPdd->RxDmaBufferSize
; 1853 :                 ));
; 1854 :             LocalFree(pPdd->RxDmaInfo);

  002d0	05940124	 ldreq       r0, [r4, #0x124]
  002d4	0affffed	 beq         |$LN32@HWInit|

; 1855 :             pPdd->RxDmaInfo = NULL;
; 1856 :             goto skipRXDMA;
; 1857 :         }
; 1858 :         DEBUGMSG(ZONE_INIT, (L"OMAP35XX RX DMA buffer allocated\n"));
; 1859 :         //Rx Event to get End of Block/Frame
; 1860 :         pPdd->hEventRxIstDma = CreateEvent(NULL, FALSE, FALSE, NULL);

  002d8	e3a03000	 mov         r3, #0
  002dc	e3a02000	 mov         r2, #0
  002e0	e3a01000	 mov         r1, #0
  002e4	e3a00000	 mov         r0, #0
  002e8	eb000000	 bl          CreateEventW

; 1861 : 
; 1862 :         // registering for system interrupt is deferred to the IST thread
; 1863 :         // spawn thread
; 1864 :         pPdd->hRxThread = CreateThread(NULL, 0, IST_RxDMA, pPdd, 0, NULL);

  002ec	e59f2144	 ldr         r2, [pc, #0x144]
  002f0	e1a03000	 mov         r3, r0
  002f4	e5843128	 str         r3, [r4, #0x128]
  002f8	e1a03004	 mov         r3, r4
  002fc	e3a00000	 mov         r0, #0
  00300	e3a01000	 mov         r1, #0
  00304	e58d8004	 str         r8, [sp, #4]
  00308	e58d8000	 str         r8, [sp]
  0030c	eb000000	 bl          CreateThread
  00310	e3500000	 cmp         r0, #0
  00314	e584013c	 str         r0, [r4, #0x13C]

; 1865 :         if (pPdd->hRxThread == NULL)

  00318	0affff7e	 beq         |$LN30@HWInit|

; 1866 :         {
; 1867 :             DEBUGMSG(ZONE_ERROR, (L"ERROR: HWInit: "
; 1868 :                 L"Failed to create DMA RX thread\r\n"
; 1869 :                 ));
; 1870 :             goto cleanUp;
; 1871 :         }
; 1872 :         // Rx DMA configuration settings
; 1873 :         InitializeRxDMA(pPdd);

  0031c	e1a00004	 mov         r0, r4
  00320	eb000000	 bl          InitializeRxDMA
  00324		 |$skipRXDMA$45387|

; 1874 :     }
; 1875 : skipRXDMA:
; 1876 :     // Map interrupt
; 1877 :     if (!KernelIoControl(
; 1878 :         IOCTL_HAL_REQUEST_SYSINTR, &(pPdd->irq), sizeof(pPdd->irq), &pPdd->sysIntr,
; 1879 :         sizeof(pPdd->sysIntr), NULL
; 1880 :         )) {

  00324	e59f0108	 ldr         r0, [pc, #0x108]
  00328	e3a09004	 mov         r9, #4
  0032c	e2843028	 add         r3, r4, #0x28
  00330	e3a02004	 mov         r2, #4
  00334	e2841008	 add         r1, r4, #8
  00338	e58d8004	 str         r8, [sp, #4]
  0033c	e58d9000	 str         r9, [sp]
  00340	eb000000	 bl          KernelIoControl
  00344	e3500000	 cmp         r0, #0
  00348	0affff72	 beq         |$LN30@HWInit|

; 1881 :             DEBUGMSG(ZONE_ERROR, (L"ERROR: HWInit: "
; 1882 :                 L"Failed obtain SYSINTR for IRQ %d\r\n", pPdd->irq
; 1883 :                 ));
; 1884 :             goto cleanUp;
; 1885 :     }
; 1886 : 
; 1887 :     // Save it to HW object
; 1888 :     pHWObj->dwIntID = pPdd->sysIntr;

  0034c	e5943028	 ldr         r3, [r4, #0x28]

; 1889 : 
; 1890 :     // Create sync objects
; 1891 :     InitializeCriticalSection(&pPdd->hwCS);

  00350	e2840098	 add         r0, r4, #0x98
  00354	e5863004	 str         r3, [r6, #4]
  00358	eb000000	 bl          InitializeCriticalSection

; 1892 :     InitializeCriticalSection(&pPdd->txCS);

  0035c	e28400ac	 add         r0, r4, #0xAC
  00360	eb000000	 bl          InitializeCriticalSection

; 1893 :     InitializeCriticalSection(&pPdd->RxUpdatePtrCS);

  00364	e28400c0	 add         r0, r4, #0xC0
  00368	eb000000	 bl          InitializeCriticalSection

; 1894 :     InitializeCriticalSection(&pPdd->powerCS);

  0036c	e2840038	 add         r0, r4, #0x38
  00370	eb000000	 bl          InitializeCriticalSection

; 1895 :     
; 1896 :     pPdd->txEvent = CreateEvent(0, FALSE, FALSE, NULL);

  00374	e3a03000	 mov         r3, #0
  00378	e3a02000	 mov         r2, #0
  0037c	e3a01000	 mov         r1, #0
  00380	e3a00000	 mov         r0, #0
  00384	eb000000	 bl          CreateEventW
  00388	e3500000	 cmp         r0, #0
  0038c	e58400d4	 str         r0, [r4, #0xD4]

; 1897 :     if (pPdd->txEvent == NULL)

  00390	0affff60	 beq         |$LN30@HWInit|

; 1898 :     {
; 1899 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: HWInit: "
; 1900 :             L"Failed create event\r\n"
; 1901 :             ));
; 1902 :         goto cleanUp;
; 1903 :     }
; 1904 : 
; 1905 :     // Device is initially closed
; 1906 :     pPdd->open = FALSE;
; 1907 :     SetDefaultDCB(pPdd);

  00394	e5942060	 ldr         r2, [r4, #0x60]
  00398	e3e03a02	 mvn         r3, #2, 20
  0039c	e223306e	 eor         r3, r3, #0x6E
  003a0	e3a01a01	 mov         r1, #1, 20
  003a4	e0022003	 and         r2, r2, r3
  003a8	e3813011	 orr         r3, r1, #0x11
  003ac	e1823003	 orr         r3, r2, r3
  003b0	e3a0201c	 mov         r2, #0x1C
  003b4	e3a0ed96	 mov         lr, #0x96, 26
  003b8	e3a05008	 mov         r5, #8
  003bc	e3a06001	 mov         r6, #1

; 1908 : 
; 1909 :     // Initialize device power state
; 1910 :     pPdd->externalDX = D0;
; 1911 :     pPdd->currentDX = D4;
; 1912 :     SetPower(pPdd, D0);

  003c0	e3a01000	 mov         r1, #0
  003c4	e1a00004	 mov         r0, r4
  003c8	e5842058	 str         r2, [r4, #0x58]
  003cc	e5843060	 str         r3, [r4, #0x60]
  003d0	e5848054	 str         r8, [r4, #0x54]
  003d4	e584e05c	 str         lr, [r4, #0x5C]
  003d8	e5c4506a	 strb        r5, [r4, #0x6A]
  003dc	e5c4806b	 strb        r8, [r4, #0x6B]
  003e0	e5c4606c	 strb        r6, [r4, #0x6C]
  003e4	e5848034	 str         r8, [r4, #0x34]
  003e8	e5849030	 str         r9, [r4, #0x30]
  003ec	eb000000	 bl          SetPower

; 1913 : 
; 1914 :     EnterCriticalSection(&pPdd->hwCS);

  003f0	e2840098	 add         r0, r4, #0x98
  003f4	eb000000	 bl          EnterCriticalSection

; 1915 : 
; 1916 :     pPdd->bRxDMASignaled = 0;
; 1917 :     pPdd->bRxWrapped     = FALSE;
; 1918 :     pPdd->pRxDMALastWrite = 0;
; 1919 :     pPdd->bDmaInitialize = FALSE;
; 1920 : 
; 1921 :     InitializeUART(pPdd);

  003f8	e1a00004	 mov         r0, r4
  003fc	e5848144	 str         r8, [r4, #0x144]
  00400	e5848148	 str         r8, [r4, #0x148]
  00404	e584814c	 str         r8, [r4, #0x14C]
  00408	e5848150	 str         r8, [r4, #0x150]
  0040c	eb000000	 bl          InitializeUART

; 1922 : 
; 1923 :     LeaveCriticalSection(&pPdd->hwCS);

  00410	e2840098	 add         r0, r4, #0x98
  00414	eb000000	 bl          LeaveCriticalSection

; 1924 : 
; 1925 :     // Set device to D3
; 1926 :     pPdd->externalDX = D3;

  00418	e3a03003	 mov         r3, #3

; 1927 :     SetPower(pPdd, D3);

  0041c	e3a01003	 mov         r1, #3
  00420	e1a00004	 mov         r0, r4
  00424	e5843034	 str         r3, [r4, #0x34]
  00428	eb000000	 bl          SetPower

; 1928 : 
; 1929 :     // Save MDD context for callback
; 1930 :     pPdd->pMdd = pMdd;

  0042c	e5847050	 str         r7, [r4, #0x50]
  00430		 |$cleanUp$45329|

; 1931 : 
; 1932 :     // Initialization succeeded
; 1933 :     rc = TRUE;
; 1934 :     DEBUGMSG(ZONE_INIT, (L"HWInit: Initialization succeeded\r\n"));
; 1935 : 
; 1936 : cleanUp:
; 1937 :     if (!rc && (pPdd != NULL))

  00430	eaffff3d	 b           |$LN1@HWInit|
  00434		 |$LN36@HWInit|
  00434		 |$LN37@HWInit|
  00434	01010098	 DCD         0x1010098
  00438		 |$LN38@HWInit|
  00438	00000000	 DCD         |IST_RxDMA|
  0043c		 |$LN39@HWInit|
  0043c	00000000	 DCD         |??_C@_1FE@MELLBIFK@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAe?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAT?$AAX?$AA?5?$AAi?$AAn@|
  00440		 |$LN40@HWInit|
  00440	00000000	 DCD         |??_C@_1EG@OEGIILDN@?$AAH?$AAW?$AAI?$AAn?$AAi?$AAt?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$CB?$AA?$CB?$AA?5?$AAC?$AAa?$AAl?$AAl?$AAi?$AAn?$AAg?$AA?5?$AAH?$AAW?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt@|
  00444		 |$LN41@HWInit|
  00444	00000000	 DCD         |s_deviceRegParams|
  00448		 |$M47943|

			 ENDP  ; |HWInit|

	END
