; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\SERIAL\COM_MDD2\mdd.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.bss|, NOINIT
|GlobalSerialHeadNumber| % 0x4
	EXPORT	|PulseEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T41077| DCD	|$LN5@PulseEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PulseEvent| PROC

; 211  : _inline BOOL PulseEvent(HANDLE h) {

  00000		 |$LN5@PulseEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41074|

; 212  : 	return EventModify(h,EVENT_PULSE);

  00004	e3a01001	 mov         r1, #1
  00008	eb000000	 bl          EventModify

; 213  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M41075|

			 ENDP  ; |PulseEvent|

	EXPORT	|ResetEvent|

  00000			 AREA	 |.pdata|, PDATA
|$T41087| DCD	|$LN5@ResetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ResetEvent| PROC

; 223  : _inline BOOL ResetEvent(HANDLE h) {

  00000		 |$LN5@ResetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41084|

; 224  : 	return EventModify(h,EVENT_RESET);

  00004	e3a01002	 mov         r1, #2
  00008	eb000000	 bl          EventModify

; 225  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M41085|

			 ENDP  ; |ResetEvent|

	EXPORT	|SetEvent|

  00000			 AREA	 |.pdata|, PDATA
|$T41097| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41094|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M41095|

			 ENDP  ; |SetEvent|

	EXPORT	|GetCurrentThread|

  00000			 AREA	 |.pdata|, PDATA
|$T41106| DCD	|$LN5@GetCurrent|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentThread| PROC

; 351  : _inline HANDLE GetCurrentThread(void) {

  00000		 |$LN5@GetCurrent|
  00000		 |$M41103|

; 352  : 	return ((HANDLE)(SH_CURTHREAD+SYS_HANDLE_BASE));

  00000	e3a00041	 mov         r0, #0x41

; 353  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M41104|

			 ENDP  ; |GetCurrentThread|

	EXPORT	|RxBytesAvail|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\com_mdd2\serpriv.h

  00000			 AREA	 |.pdata|, PDATA
|$T41120| DCD	|$LN7@RxBytesAva|
	DCD	0x40000800
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |RxBytesAvail| PROC

; 143  : __inline  ULONG RxBytesAvail(PHW_INDEP_INFO  pSH) {

  00000		 |$LN7@RxBytesAva|
  00000		 |$M41117|

; 144  :     // Note: We have to copy RxRead and RxWrite index to local in order to make it atomic.
; 145  :     register DWORD RxWIndex=RxWrite(pSH), RxRIndex=RxRead(pSH);

  00000	e59020a0	 ldr         r2, [r0, #0xA0]
  00004	e590109c	 ldr         r1, [r0, #0x9C]

; 146  :     return (RxWIndex>=RxRIndex?RxWIndex- RxRIndex : RxLength(pSH) - RxRIndex + RxWIndex );

  00008	e1520001	 cmp         r2, r1
  0000c	20420001	 subcs       r0, r2, r1
  00010	359030a4	 ldrcc       r3, [r0, #0xA4]
  00014	30433001	 subcc       r3, r3, r1
  00018	30830002	 addcc       r0, r3, r2

; 147  : }

  0001c	e12fff1e	 bx          lr
  00020		 |$M41118|

			 ENDP  ; |RxBytesAvail|

	EXPORT	|DllEntry|
	IMPORT	|DisableThreadLibraryCalls|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\com_mdd2\mdd.c

  00000			 AREA	 |.pdata|, PDATA
|$T41131| DCD	|$LN7@DllEntry|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DllEntry| PROC

; 141  : {

  00000		 |$LN7@DllEntry|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41128|

; 142  :     if ( dwReason == DLL_PROCESS_ATTACH ) {

  00004	e3510001	 cmp         r1, #1

; 143  :         DEBUGREGISTER(hinstDll);
; 144  :         DEBUGMSG (ZONE_INIT, (TEXT("serial port process attach\r\n")));
; 145  :         DisableThreadLibraryCalls((HMODULE) hinstDll);

  00008	0b000000	 bleq        DisableThreadLibraryCalls

; 146  :     }
; 147  : 
; 148  :     if ( dwReason == DLL_PROCESS_DETACH ) {
; 149  :         DEBUGMSG (ZONE_INIT, (TEXT("process detach called\r\n")));
; 150  :     }
; 151  : 
; 152  :     return(TRUE);

  0000c	e3a00001	 mov         r0, #1

; 153  : }

  00010	e49de004	 ldr         lr, [sp], #4
  00014	e12fff1e	 bx          lr
  00018		 |$M41129|

			 ENDP  ; |DllEntry|

	EXPORT	|DoTxData|
	IMPORT	|LeaveCriticalSection|
	IMPORT	|EnterCriticalSection|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T41147| DCD	|$LN14@DoTxData|
	DCD	0x40004902
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\com_mdd2\mdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DoTxData| PROC

; 162  : {

  00000		 |$LN14@DoTxData|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M41144|
  00008	e1a05000	 mov         r5, r0

; 163  :     PHW_VTBL            pFuncTbl = pSerialHead->pHWObj->pFuncTbl;

  0000c	e5953028	 ldr         r3, [r5, #0x28]

; 164  :     PVOID               pHWHead = pSerialHead->pHWHead;
; 165  :     ULONG               Len;
; 166  : 
; 167  : 
; 168  : 
; 169  :     DEBUGMSG (ZONE_WRITE, (TEXT("DoPutBytes wait for CritSec %x.\r\n"),
; 170  :                            &(pSerialHead->TxBufferInfo.CS)));
; 171  :     TxEnterCS(pSerialHead);

  00010	e595602c	 ldr         r6, [r5, #0x2C]
  00014	e28500d0	 add         r0, r5, #0xD0
  00018	e5934008	 ldr         r4, [r3, #8]
  0001c	eb000000	 bl          EnterCriticalSection

; 172  :     DEBUGMSG (ZONE_WRITE, (TEXT("DoPutBytes got CritSec %x.\r\n"),
; 173  :                            &(pSerialHead->TxBufferInfo.CS)));
; 174  : 
; 175  :     // If device was closed from under us, stop transmitting
; 176  :     if ( !pSerialHead->OpenCnt ) {

  00020	e5953090	 ldr         r3, [r5, #0x90]
  00024	e3a07000	 mov         r7, #0
  00028	e3530000	 cmp         r3, #0

; 177  :         DEBUGMSG (ZONE_THREAD|ZONE_WRITE , (TEXT("Device closed! Quit transmission!\r\n")));
; 178  :         DEBUGMSG (ZONE_WRITE,
; 179  :                   (TEXT("SerialEventHandler: %d sent up-to-now.\n\r"),pSerialHead->TxBytesSent));
; 180  :         pSerialHead->TxBufferInfo.TxCharBuffer = NULL;

  0002c	058570cc	 streq       r7, [r5, #0xCC]

; 181  :         pSerialHead->TxBufferInfo.Length = 0;
; 182  :         TxRead(pSerialHead) = 0;
; 183  :     }
; 184  : 
; 185  :     // Check the flow control status, and if not flowed off, call the
; 186  :     // hw TX routine to actually transmit some data.
; 187  :     if ( pSerialHead->TxBufferInfo.TxCharBuffer && TxBytesAvail(pSerialHead) ) {

  00030	e59530cc	 ldr         r3, [r5, #0xCC]
  00034	058570c8	 streq       r7, [r5, #0xC8]
  00038	058570c4	 streq       r7, [r5, #0xC4]
  0003c	e3530000	 cmp         r3, #0
  00040	0a000024	 beq         |$LN5@DoTxData|
  00044	e59520c8	 ldr         r2, [r5, #0xC8]
  00048	e59530c4	 ldr         r3, [r5, #0xC4]
  0004c	e0523003	 subs        r3, r2, r3
  00050	0a000020	 beq         |$LN5@DoTxData|

; 188  :         if ( pSerialHead->DCB.fRtsControl == RTS_CONTROL_TOGGLE ) {

  00054	e5953068	 ldr         r3, [r5, #0x68]
  00058	e2033a03	 and         r3, r3, #3, 20
  0005c	e3530a03	 cmp         r3, #3, 20

; 189  :             DEBUGMSG (ZONE_THREAD|ZONE_WRITE , (TEXT("RTS set.\r\n")));
; 190  :             pFuncTbl->HWSetRTS(pHWHead);

  00060	05943040	 ldreq       r3, [r4, #0x40]
  00064	01a00006	 moveq       r0, r6
  00068	01a0e00f	 moveq       lr, pc
  0006c	012fff13	 bxeq        r3

; 191  :         }
; 192  : 
; 193  :         // Don't transmit anything if we are flowed off.
; 194  :         if ( pSerialHead->StopXmit ) {

  00070	e5953094	 ldr         r3, [r5, #0x94]

; 195  :             // But we still need to call TxIntrHandler so that the interrupt
; 196  :             // gets cleared.
; 197  :             DEBUGMSG (ZONE_FLOW|ZONE_WRITE , (TEXT("XOFF'ed, send nothing.\r\n")));
; 198  :             Len = 0;
; 199  :         } else {
; 200  :             DEBUGMSG (ZONE_WRITE,
; 201  :                       (TEXT("TxRead = %d, TxLength = %d, TxBytesAvail = %d.\r\n"),
; 202  :                        TxRead(pSerialHead), TxLength(pSerialHead),
; 203  :                        TxBytesAvail(pSerialHead)));
; 204  :             Len = TxBytesAvail(pSerialHead);
; 205  :         }
; 206  :         DEBUGMSG (ZONE_WRITE, (TEXT("About to copy %d bytes\r\n"), Len));
; 207  :         pFuncTbl->HWTxIntrHandler(pHWHead,
; 208  :                                   TxBuffRead(pSerialHead),
; 209  :                                   &Len);

  00074	e59510cc	 ldr         r1, [r5, #0xCC]
  00078	e1a00006	 mov         r0, r6
  0007c	e3130004	 tst         r3, #4
  00080	059520c8	 ldreq       r2, [r5, #0xC8]
  00084	13a03000	 movne       r3, #0
  00088	059530c4	 ldreq       r3, [r5, #0xC4]
  0008c	00423003	 subeq       r3, r2, r3
  00090	e58d3000	 str         r3, [sp]
  00094	e59530c4	 ldr         r3, [r5, #0xC4]
  00098	e594401c	 ldr         r4, [r4, #0x1C]
  0009c	e28d2000	 add         r2, sp, #0
  000a0	e0811003	 add         r1, r1, r3
  000a4	e1a0e00f	 mov         lr, pc
  000a8	e12fff14	 bx          r4

; 210  :         DEBUGMSG (ZONE_WRITE, (TEXT("%d bytes actually copied.\r\n"), Len));
; 211  :         // Update Fifo info
; 212  :         pSerialHead->TxBytes += Len;

  000ac	e5953054	 ldr         r3, [r5, #0x54]

; 213  :         pSerialHead->TxBytesSent += Len;

  000b0	e595205c	 ldr         r2, [r5, #0x5C]

; 214  :         TxRead(pSerialHead) += Len;

  000b4	e59d1000	 ldr         r1, [sp]
  000b8	e59500c4	 ldr         r0, [r5, #0xC4]
  000bc	e0833001	 add         r3, r3, r1
  000c0	e0822001	 add         r2, r2, r1
  000c4	e0801001	 add         r1, r0, r1
  000c8	e58510c4	 str         r1, [r5, #0xC4]
  000cc	e5853054	 str         r3, [r5, #0x54]
  000d0	e585205c	 str         r2, [r5, #0x5C]

; 215  : 
; 216  :         // Even if everything was Tx'ed, don't signal TX complete until
; 217  :         // we get transmit interrupt indicating that the data has
; 218  :         // actually been sent.  Since few/no UARTS have a way to tell
; 219  :         // how much data remains, we don't bother trying to adjust the
; 220  :         // return length to account for partially completed hardware buffer TX
; 221  :     } else {

  000d4	ea00000d	 b           |$LN9@DoTxData|
  000d8		 |$LN5@DoTxData|

; 222  :         // Even if there is nothing left to send, we need to call
; 223  :         // the interrupt handler so that it can clear the
; 224  :         // transmit interrupt
; 225  :         Len = 0;

  000d8	e3a03000	 mov         r3, #0
  000dc	e58d3000	 str         r3, [sp]

; 226  :         pFuncTbl->HWTxIntrHandler(pHWHead,
; 227  :                                   NULL,
; 228  :                                   &Len);

  000e0	e594301c	 ldr         r3, [r4, #0x1C]
  000e4	e28d2000	 add         r2, sp, #0
  000e8	e3a01000	 mov         r1, #0
  000ec	e1a00006	 mov         r0, r6
  000f0	e1a0e00f	 mov         lr, pc
  000f4	e12fff13	 bx          r3

; 229  :         DEBUGMSG (ZONE_WRITE, (TEXT("Transmission complete, %d bytes sent\r\n"), Len));
; 230  :         pSerialHead->TxBufferInfo.TxCharBuffer = NULL;
; 231  :         pSerialHead->TxBufferInfo.Length = 0;
; 232  :         TxRead(pSerialHead) = 0;
; 233  :         SetEvent(pSerialHead->hTransmitEvent);

  000f8	e595003c	 ldr         r0, [r5, #0x3C]
  000fc	e3a01003	 mov         r1, #3
  00100	e58570cc	 str         r7, [r5, #0xCC]
  00104	e58570c8	 str         r7, [r5, #0xC8]
  00108	e58570c4	 str         r7, [r5, #0xC4]
  0010c	eb000000	 bl          EventModify
  00110		 |$LN9@DoTxData|

; 234  :     }
; 235  : 
; 236  :     TxLeaveCS(pSerialHead);

  00110	e28500d0	 add         r0, r5, #0xD0
  00114	eb000000	 bl          LeaveCriticalSection

; 237  :     DEBUGMSG (ZONE_WRITE|ZONE_FUNCTION,
; 238  :               (TEXT("DoPutBytes released CritSec: %x.\r\n"),
; 239  :                &(pSerialHead->TxBufferInfo.CS)));
; 240  : 
; 241  : }

  00118	e28dd004	 add         sp, sp, #4
  0011c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00120	e12fff1e	 bx          lr
  00124		 |$M41145|

			 ENDP  ; |DoTxData|

	EXPORT	|StopDispatchThread|
	IMPORT	|InterruptDisable|
	IMPORT	|InterruptDone|
	IMPORT	|CloseHandle|
	IMPORT	|Sleep|
	IMPORT	|WaitForSingleObject|
	IMPORT	|CeSetThreadPriority|
	IMPORT	|CeGetThreadPriority|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T41165| DCD	|$LN11@StopDispat|
	DCD	0x40002501
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\com_mdd2\mdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |StopDispatchThread| PROC

; 568  : {

  00000		 |$LN11@StopDispat|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M41162|
  00004	e1a04000	 mov         r4, r0

; 569  :     HANDLE              pThisThread = GetCurrentThread();
; 570  :     ULONG               priority256;
; 571  : 
; 572  :     /* If we have an interrupt handler thread, kill it */
; 573  :     if ( pSerialHead->pDispatchThread ) {

  00008	e5943040	 ldr         r3, [r4, #0x40]
  0000c	e3530000	 cmp         r3, #0
  00010	0a000014	 beq         |$LN2@StopDispat|

; 574  :         DEBUGMSG (ZONE_INIT, (TEXT("\r\nTrying to close dispatch thread\r\n")));
; 575  : 
; 576  :         /* Set the priority of the dispatch thread to be equal to this one,
; 577  :          * so that it shuts down before we free its memory. If this routine
; 578  :          * has been called from SerialDllEntry then RxCharBuffer is set to
; 579  :          * NULL and the dispatch thread is already dead, so just skip the
; 580  :          * code which kills the thread.
; 581  :          */
; 582  :         priority256 = CeGetThreadPriority(pThisThread);

  00014	e3a00041	 mov         r0, #0x41
  00018	eb000000	 bl          CeGetThreadPriority
  0001c	e1a01000	 mov         r1, r0

; 583  :         CeSetThreadPriority(pSerialHead->pDispatchThread, priority256);

  00020	e5940040	 ldr         r0, [r4, #0x40]
  00024	eb000000	 bl          CeSetThreadPriority

; 584  : 
; 585  :         /* Signal the Dispatch thread to die.
; 586  :          */
; 587  :         pSerialHead->KillRxThread = 1;

  00028	e5943094	 ldr         r3, [r4, #0x94]

; 588  :         DEBUGMSG (ZONE_INIT, (TEXT("\r\nTrying to signal serial thread.\r\n")));
; 589  :         SetEvent(pSerialHead->hSerialEvent);

  0002c	e5940030	 ldr         r0, [r4, #0x30]
  00030	e3a01003	 mov         r1, #3
  00034	e3833001	 orr         r3, r3, #1
  00038	e5843094	 str         r3, [r4, #0x94]
  0003c	eb000000	 bl          EventModify

; 590  : 
; 591  :         WaitForSingleObject(pSerialHead->hKillDispatchThread, 3000);

  00040	e5940038	 ldr         r0, [r4, #0x38]
  00044	e3a03c0b	 mov         r3, #0xB, 24
  00048	e38310b8	 orr         r1, r3, #0xB8
  0004c	eb000000	 bl          WaitForSingleObject

; 592  :         Sleep(10);

  00050	e3a0000a	 mov         r0, #0xA
  00054	eb000000	 bl          Sleep

; 593  : 
; 594  :         DEBUGMSG (ZONE_INIT, (TEXT("\r\nTrying to call CloseHandle\r\n")));
; 595  : 
; 596  :         CloseHandle(pSerialHead->pDispatchThread);

  00058	e5940040	 ldr         r0, [r4, #0x40]
  0005c	eb000000	 bl          CloseHandle

; 597  :         pSerialHead->pDispatchThread = NULL;

  00060	e3a03000	 mov         r3, #0
  00064	e5843040	 str         r3, [r4, #0x40]
  00068		 |$LN2@StopDispat|

; 598  :         DEBUGMSG (ZONE_INIT, (TEXT("\r\nReturned from CloseHandle\r\n")));
; 599  :     }
; 600  : 
; 601  :     if ( pSerialHead->pHWObj ) {

  00068	e5943028	 ldr         r3, [r4, #0x28]
  0006c	e3530000	 cmp         r3, #0
  00070	0a000004	 beq         |$LN1@StopDispat|

; 602  :         /* Ack any remaining interrupts and unregister the event from the
; 603  :          * logical interrupt.
; 604  :          */
; 605  :         InterruptDone(pSerialHead->pHWObj->dwIntID);

  00074	e5930004	 ldr         r0, [r3, #4]
  00078	eb000000	 bl          InterruptDone

; 606  :         InterruptDisable(pSerialHead->pHWObj->dwIntID);

  0007c	e5943028	 ldr         r3, [r4, #0x28]
  00080	e5930004	 ldr         r0, [r3, #4]
  00084	eb000000	 bl          InterruptDisable
  00088		 |$LN1@StopDispat|

; 607  :     }
; 608  : 
; 609  :     return(TRUE);

  00088	e3a00001	 mov         r0, #1

; 610  : }

  0008c	e8bd4010	 ldmia       sp!, {r4, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$M41163|

			 ENDP  ; |StopDispatchThread|

	EXPORT	|ApplyDCB|
	IMPORT	|memcpy|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\com_mdd2\serpriv.h

  00000			 AREA	 |.pdata|, PDATA
|$T41225| DCD	|$LN47@ApplyDCB|
	DCD	0x4000ab01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\com_mdd2\mdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ApplyDCB| PROC

; 622  : {

  00000		 |$LN47@ApplyDCB|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M41222|
  00004	e1a07002	 mov         r7, r2
  00008	e1a05001	 mov         r5, r1
  0000c	e1a04000	 mov         r4, r0

; 623  :     PHWOBJ          pHWObj      = pSerialHead->pHWObj;
; 624  : 
; 625  :     if (!(pDCB->XoffLim< pSerialHead->RxBufferInfo.Length &&
; 626  :             pDCB->XonLim< pSerialHead->RxBufferInfo.Length - pDCB->XoffLim )) {

  00010	e1d531b0	 ldrh        r3, [r5, #0x10]
  00014	e59410a4	 ldr         r1, [r4, #0xA4]
  00018	e5946028	 ldr         r6, [r4, #0x28]
  0001c	e1530001	 cmp         r3, r1
  00020	2a00009e	 bcs         |$LN23@ApplyDCB|
  00024	e1d5e0be	 ldrh        lr, [r5, #0xE]
  00028	e0413003	 sub         r3, r1, r3
  0002c	e15e0003	 cmp         lr, r3
  00030	2a00009a	 bcs         |$LN23@ApplyDCB|

; 628  :     }
; 629  :     
; 630  :     if (pDCB->fOutX || pDCB->fInX ) {

  00034	e5953008	 ldr         r3, [r5, #8]
  00038	e3130c01	 tst         r3, #1, 24
  0003c	1a000001	 bne         |$LN21@ApplyDCB|
  00040	e3130c02	 tst         r3, #2, 24
  00044	0a000003	 beq         |$LN20@ApplyDCB|
  00048		 |$LN21@ApplyDCB|

; 631  :         if (pDCB->XonChar == pDCB->XoffChar)

  00048	e1d5e1d6	 ldrsb       lr, [r5, #0x16]
  0004c	e1d531d5	 ldrsb       r3, [r5, #0x15]
  00050	e153000e	 cmp         r3, lr

; 632  :             return FALSE;

  00054	0a000091	 beq         |$LN23@ApplyDCB|
  00058		 |$LN20@ApplyDCB|

; 633  :     } 
; 634  : 
; 635  :     if ( !pHWObj->pFuncTbl->HWSetDCB(pSerialHead->pHWHead,
; 636  :                                      pDCB) ) {

  00058	e5963008	 ldr         r3, [r6, #8]
  0005c	e594002c	 ldr         r0, [r4, #0x2C]
  00060	e1a01005	 mov         r1, r5
  00064	e593306c	 ldr         r3, [r3, #0x6C]
  00068	e1a0e00f	 mov         lr, pc
  0006c	e12fff13	 bx          r3
  00070	e3500000	 cmp         r0, #0

; 637  :         return(FALSE);

  00074	0a000089	 beq         |$LN23@ApplyDCB|

; 638  :     }
; 639  : 
; 640  :     if ( !fOpen ) {

  00078	e3570000	 cmp         r7, #0
  0007c	1a000002	 bne         |$LN18@ApplyDCB|
  00080		 |$LN44@ApplyDCB|

; 641  :         return(TRUE);

  00080	e3a00001	 mov         r0, #1

; 692  : }

  00084	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$LN18@ApplyDCB|

; 642  :     }
; 643  :         // If PDD SetDCB was successful, save the supplied DCB and
; 644  :         // configure port to match these settings.
; 645  :     memcpy(&(pSerialHead->DCB), pDCB, sizeof(DCB));

  0008c	e2840060	 add         r0, r4, #0x60
  00090	e3a0201c	 mov         r2, #0x1C
  00094	e1a01005	 mov         r1, r5
  00098	eb000000	 bl          memcpy

; 646  : 
; 647  :     if ( pSerialHead->DCB.fDtrControl == DTR_CONTROL_DISABLE ) {

  0009c	e5943068	 ldr         r3, [r4, #0x68]
  000a0	e1a03d03	 mov         r3, r3, lsl #26
  000a4	e1b03f23	 movs        r3, r3, lsr #30
  000a8	1a000005	 bne         |$LN17@ApplyDCB|

; 648  :         pHWObj->pFuncTbl->HWClearDTR(pSerialHead->pHWHead);

  000ac	e5963008	 ldr         r3, [r6, #8]
  000b0	e594002c	 ldr         r0, [r4, #0x2C]
  000b4	e5933034	 ldr         r3, [r3, #0x34]
  000b8	e1a0e00f	 mov         lr, pc
  000bc	e12fff13	 bx          r3
  000c0	ea000005	 b           |$LN15@ApplyDCB|
  000c4		 |$LN17@ApplyDCB|

; 649  :     } else if ( pSerialHead->DCB.fDtrControl == DTR_CONTROL_ENABLE ) {

  000c4	e3530001	 cmp         r3, #1

; 650  :         pHWObj->pFuncTbl->HWSetDTR(pSerialHead->pHWHead);

  000c8	05963008	 ldreq       r3, [r6, #8]
  000cc	0594002c	 ldreq       r0, [r4, #0x2C]
  000d0	05933038	 ldreq       r3, [r3, #0x38]
  000d4	01a0e00f	 moveq       lr, pc
  000d8	012fff13	 bxeq        r3
  000dc		 |$LN15@ApplyDCB|

; 651  :     }
; 652  : 
; 653  :     if ( pSerialHead->DCB.fRtsControl == RTS_CONTROL_DISABLE ) {

  000dc	e5943068	 ldr         r3, [r4, #0x68]
  000e0	e1a03903	 mov         r3, r3, lsl #18
  000e4	e1b03f23	 movs        r3, r3, lsr #30
  000e8	1a000005	 bne         |$LN14@ApplyDCB|

; 654  :         pHWObj->pFuncTbl->HWClearRTS(pSerialHead->pHWHead);

  000ec	e5963008	 ldr         r3, [r6, #8]
  000f0	e594002c	 ldr         r0, [r4, #0x2C]
  000f4	e593303c	 ldr         r3, [r3, #0x3C]
  000f8	e1a0e00f	 mov         lr, pc
  000fc	e12fff13	 bx          r3
  00100	ea000005	 b           |$LN12@ApplyDCB|
  00104		 |$LN14@ApplyDCB|

; 655  :     } else if ( pSerialHead->DCB.fRtsControl == RTS_CONTROL_ENABLE ) {

  00104	e3530001	 cmp         r3, #1

; 656  :         pHWObj->pFuncTbl->HWSetRTS(pSerialHead->pHWHead);

  00108	05963008	 ldreq       r3, [r6, #8]
  0010c	0594002c	 ldreq       r0, [r4, #0x2C]
  00110	05933040	 ldreq       r3, [r3, #0x40]
  00114	01a0e00f	 moveq       lr, pc
  00118	012fff13	 bxeq        r3
  0011c		 |$LN12@ApplyDCB|

; 657  :     }
; 658  : 
; 659  :     if ( pSerialHead->DCB.fDtrControl == DTR_CONTROL_HANDSHAKE ) {

  0011c	e5943068	 ldr         r3, [r4, #0x68]
  00120	e2033030	 and         r3, r3, #0x30
  00124	e3530020	 cmp         r3, #0x20
  00128	1a000026	 bne         |$LN8@ApplyDCB|

; 660  :         if ( (!pSerialHead->DtrFlow) && IsIncreasedToFlowOff(pSerialHead)) {

  0012c	e5940094	 ldr         r0, [r4, #0x94]
  00130	e3100010	 tst         r0, #0x10
  00134	1a000013	 bne         |$LN10@ApplyDCB|
  00138	e59420a0	 ldr         r2, [r4, #0xA0]
  0013c	e594109c	 ldr         r1, [r4, #0x9C]
  00140	e1520001	 cmp         r2, r1
  00144	359430a4	 ldrcc       r3, [r4, #0xA4]
  00148	20421001	 subcs       r1, r2, r1
  0014c	30433001	 subcc       r3, r3, r1
  00150	30831002	 addcc       r1, r3, r2
  00154	e59430a4	 ldr         r3, [r4, #0xA4]
  00158	e1d427b0	 ldrh        r2, [r4, #0x70]
  0015c	e0433001	 sub         r3, r3, r1
  00160	e1520003	 cmp         r2, r3
  00164	3a000007	 bcc         |$LN10@ApplyDCB|

; 661  :             DEBUGMSG (ZONE_READ|ZONE_FLOW,
; 662  :                       (TEXT("IOCTL:DTR_CONTROL_HANDSHAKE Clearing DTR\r\n")));
; 663  :             pSerialHead->DtrFlow = 1;

  00168	e3803010	 orr         r3, r0, #0x10
  0016c	e5843094	 str         r3, [r4, #0x94]

; 664  :             pHWObj->pFuncTbl->HWClearDTR(pSerialHead->pHWHead);

  00170	e5963008	 ldr         r3, [r6, #8]
  00174	e594002c	 ldr         r0, [r4, #0x2C]
  00178	e5933034	 ldr         r3, [r3, #0x34]
  0017c	e1a0e00f	 mov         lr, pc
  00180	e12fff13	 bx          r3
  00184	ea00000f	 b           |$LN8@ApplyDCB|
  00188		 |$LN10@ApplyDCB|

; 665  :         } else if (IsReducedToFlowOn(pSerialHead)){

  00188	e59420a0	 ldr         r2, [r4, #0xA0]
  0018c	e594109c	 ldr         r1, [r4, #0x9C]
  00190	e1520001	 cmp         r2, r1
  00194	359430a4	 ldrcc       r3, [r4, #0xA4]
  00198	20422001	 subcs       r2, r2, r1
  0019c	30433001	 subcc       r3, r3, r1
  001a0	30832002	 addcc       r2, r3, r2
  001a4	e1d436be	 ldrh        r3, [r4, #0x6E]
  001a8	e1530002	 cmp         r3, r2

; 666  :             DEBUGMSG (ZONE_READ|ZONE_FLOW,
; 667  :                       (TEXT("IOCTL:DTR_CONTROL_HANDSHAKE Setting DTR\r\n")));
; 668  :             pSerialHead->DtrFlow = 0;

  001ac	23c03010	 biccs       r3, r0, #0x10
  001b0	25843094	 strcs       r3, [r4, #0x94]

; 669  :             pHWObj->pFuncTbl->HWSetDTR(pSerialHead->pHWHead);

  001b4	25963008	 ldrcs       r3, [r6, #8]
  001b8	2594002c	 ldrcs       r0, [r4, #0x2C]
  001bc	25933038	 ldrcs       r3, [r3, #0x38]
  001c0	21a0e00f	 movcs       lr, pc
  001c4	212fff13	 bxcs        r3
  001c8		 |$LN8@ApplyDCB|

; 670  :         }
; 671  :     }
; 672  :     if ( pSerialHead->DCB.fRtsControl == RTS_CONTROL_HANDSHAKE ) {

  001c8	e5943068	 ldr         r3, [r4, #0x68]
  001cc	e2033a03	 and         r3, r3, #3, 20
  001d0	e3530a02	 cmp         r3, #2, 20
  001d4	1a000026	 bne         |$LN4@ApplyDCB|

; 673  :         if ( (!pSerialHead->RtsFlow) && IsIncreasedToFlowOff(pSerialHead)){

  001d8	e5940094	 ldr         r0, [r4, #0x94]
  001dc	e3100020	 tst         r0, #0x20
  001e0	1a000013	 bne         |$LN6@ApplyDCB|
  001e4	e59420a0	 ldr         r2, [r4, #0xA0]
  001e8	e594109c	 ldr         r1, [r4, #0x9C]
  001ec	e1520001	 cmp         r2, r1
  001f0	359430a4	 ldrcc       r3, [r4, #0xA4]
  001f4	20421001	 subcs       r1, r2, r1
  001f8	30433001	 subcc       r3, r3, r1
  001fc	30831002	 addcc       r1, r3, r2
  00200	e59430a4	 ldr         r3, [r4, #0xA4]
  00204	e1d427b0	 ldrh        r2, [r4, #0x70]
  00208	e0433001	 sub         r3, r3, r1
  0020c	e1520003	 cmp         r2, r3
  00210	3a000007	 bcc         |$LN6@ApplyDCB|

; 674  :             DEBUGMSG (ZONE_READ|ZONE_FLOW,
; 675  :                       (TEXT("IOCTL:RTS_CONTROL_HANDSHAKE Clearing RTS\r\n")));
; 676  :             pSerialHead->RtsFlow = 1;

  00214	e3803020	 orr         r3, r0, #0x20
  00218	e5843094	 str         r3, [r4, #0x94]

; 677  :             pHWObj->pFuncTbl->HWClearRTS(pSerialHead->pHWHead);

  0021c	e5963008	 ldr         r3, [r6, #8]
  00220	e594002c	 ldr         r0, [r4, #0x2C]
  00224	e593303c	 ldr         r3, [r3, #0x3C]
  00228	e1a0e00f	 mov         lr, pc
  0022c	e12fff13	 bx          r3
  00230	ea00000f	 b           |$LN4@ApplyDCB|
  00234		 |$LN6@ApplyDCB|

; 678  :         } else if (IsReducedToFlowOn(pSerialHead)) {

  00234	e59420a0	 ldr         r2, [r4, #0xA0]
  00238	e594109c	 ldr         r1, [r4, #0x9C]
  0023c	e1520001	 cmp         r2, r1
  00240	359430a4	 ldrcc       r3, [r4, #0xA4]
  00244	20422001	 subcs       r2, r2, r1
  00248	30433001	 subcc       r3, r3, r1
  0024c	30832002	 addcc       r2, r3, r2
  00250	e1d436be	 ldrh        r3, [r4, #0x6E]
  00254	e1530002	 cmp         r3, r2

; 679  :             DEBUGMSG (ZONE_READ|ZONE_FLOW,
; 680  :                       (TEXT("IOCTL:RTS_CONTROL_HANDSHAKE Setting RTS\r\n")));
; 681  :             pSerialHead->RtsFlow = 0;

  00258	23c03020	 biccs       r3, r0, #0x20
  0025c	25843094	 strcs       r3, [r4, #0x94]

; 682  :             pHWObj->pFuncTbl->HWSetRTS(pSerialHead->pHWHead);

  00260	25963008	 ldrcs       r3, [r6, #8]
  00264	2594002c	 ldrcs       r0, [r4, #0x2C]
  00268	25933040	 ldrcs       r3, [r3, #0x40]
  0026c	21a0e00f	 movcs       lr, pc
  00270	212fff13	 bxcs        r3
  00274		 |$LN4@ApplyDCB|

; 683  :         }
; 684  :     }
; 685  : 
; 686  :     if ( pSerialHead->DCB.fOutX || pSerialHead->DCB.fInX ) {

  00274	e5943068	 ldr         r3, [r4, #0x68]
  00278	e3130c01	 tst         r3, #1, 24
  0027c	03130c02	 tsteq       r3, #2, 24

; 687  :         pSerialHead->XFlow = 1;
; 688  :     } else {
; 689  :         pSerialHead->XFlow = 0;

  00280	05943094	 ldreq       r3, [r4, #0x94]
  00284	03c33002	 biceq       r3, r3, #2
  00288	05843094	 streq       r3, [r4, #0x94]
  0028c	0affff7b	 beq         |$LN44@ApplyDCB|
  00290	e5943094	 ldr         r3, [r4, #0x94]
  00294	e3833002	 orr         r3, r3, #2
  00298	e5843094	 str         r3, [r4, #0x94]

; 690  :     }
; 691  :     return(TRUE);

  0029c	eaffff77	 b           |$LN44@ApplyDCB|
  002a0		 |$LN23@ApplyDCB|

; 627  :         return FALSE;

  002a0	e3a00000	 mov         r0, #0

; 692  : }

  002a4	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  002a8	e12fff1e	 bx          lr
  002ac		 |$M41223|

			 ENDP  ; |ApplyDCB|

	EXPORT	|COM_PreClose|
	IMPORT	|SetLastError|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T41248| DCD	|$LN16@COM_PreClo|
	DCD	0x40003101
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\com_mdd2\mdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |COM_PreClose| PROC

; 1128 : {

  00000		 |$LN16@COM_PreClo|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M41245|
  00004	e1a05000	 mov         r5, r0

; 1129 :     PHW_INDEP_INFO  pSerialHead = pOpenHead->pSerialHead;

  00008	e5953000	 ldr         r3, [r5]
  0000c	e1b04003	 movs        r4, r3

; 1130 :     PHWOBJ          pHWObj;
; 1131 : 
; 1132 :     if ( !pSerialHead ) {
; 1133 :         DEBUGMSG (ZONE_ERROR, (TEXT("!!COM_PreClose: pSerialHead == NULL!!\r\n")));
; 1134 :         return FALSE;

  00010	03a00000	 moveq       r0, #0

; 1175 : }

  00014	08bd4030	 ldmeqia     sp!, {r4, r5, lr}
  00018	012fff1e	 bxeq        lr

; 1135 :     }
; 1136 :     pHWObj = (PHWOBJ)pSerialHead->pHWObj;
; 1137 : 
; 1138 :     // Use the OpenCS to make sure we don't collide with an in-progress open.
; 1139 :     EnterCriticalSection(&(pSerialHead->OpenCS));

  0001c	e28400ec	 add         r0, r4, #0xEC
  00020	eb000000	 bl          EnterCriticalSection

; 1140 :     if (!(pOpenHead->AccessCode & DEVACCESS_BUSNAMESPACE)) {

  00024	e5953004	 ldr         r3, [r5, #4]
  00028	e3130c01	 tst         r3, #1, 24
  0002c	1a00001f	 bne         |$LN1@COM_PreClo|

; 1141 :         if ( pSerialHead->OpenCnt ) {

  00030	e5943090	 ldr         r3, [r4, #0x90]
  00034	e3530000	 cmp         r3, #0
  00038	0a00001a	 beq         |$LN3@COM_PreClo|

; 1142 :             DEBUGMSG(ZONE_INIT|ZONE_CLOSE,
; 1143 :                      (TEXT("COM_PreClose: %d users in MDD functions\n\r"),pOpenHead->StructUsers));
; 1144 : 
; 1145 :             // For any open handle, we must free pending waitcommevents
; 1146 :             EnterCriticalSection(&(pOpenHead->CommEvents.EventCS));

  0003c	e2850020	 add         r0, r5, #0x20
  00040	eb000000	 bl          EnterCriticalSection

; 1147 :             pOpenHead->CommEvents.fEventMask = 0;
; 1148 :             pOpenHead->CommEvents.fAbort = 1;
; 1149 :             SetEvent(pOpenHead->CommEvents.hCommEvent);

  00044	e5950010	 ldr         r0, [r5, #0x10]
  00048	e3a03000	 mov         r3, #0
  0004c	e3a02001	 mov         r2, #1
  00050	e3a01003	 mov         r1, #3
  00054	e5853014	 str         r3, [r5, #0x14]
  00058	e585201c	 str         r2, [r5, #0x1C]
  0005c	eb000000	 bl          EventModify

; 1150 :             LeaveCriticalSection(&(pOpenHead->CommEvents.EventCS));

  00060	e2850020	 add         r0, r5, #0x20
  00064	eb000000	 bl          LeaveCriticalSection

; 1151 : 
; 1152 :             // And only for the handle with access permissions do we
; 1153 :             // have to worry about read, write, etc being blocked.
; 1154 :             if ( pOpenHead->AccessCode & (GENERIC_READ | GENERIC_WRITE) ) {

  00068	e5953004	 ldr         r3, [r5, #4]
  0006c	e3130103	 tst         r3, #3, 2
  00070	0a00000e	 beq         |$LN1@COM_PreClo|

; 1155 :                 pSerialHead->fAbortRead=1;

  00074	e5943094	 ldr         r3, [r4, #0x94]

; 1156 :                 SetEvent(pSerialHead->hReadEvent);

  00078	e5940034	 ldr         r0, [r4, #0x34]
  0007c	e3a01003	 mov         r1, #3
  00080	e3833040	 orr         r3, r3, #0x40
  00084	e5843094	 str         r3, [r4, #0x94]
  00088	eb000000	 bl          EventModify

; 1157 :                 pSerialHead->fAbortTransmit=1;

  0008c	e5943094	 ldr         r3, [r4, #0x94]

; 1158 :                 SetEvent(pSerialHead->hTransmitEvent);

  00090	e594003c	 ldr         r0, [r4, #0x3C]
  00094	e3a01003	 mov         r1, #3
  00098	e3833080	 orr         r3, r3, #0x80
  0009c	e5843094	 str         r3, [r4, #0x94]
  000a0	eb000000	 bl          EventModify

; 1159 :             }
; 1160 : 
; 1161 :             DEBUGMSG(ZONE_CLOSE|ZONE_INIT|ZONE_ERROR,
; 1162 :                      (TEXT("COM_PreClose: serial users to exit, %d left\n\r"),
; 1163 :                       pOpenHead->StructUsers));
; 1164 : 
; 1165 :         } else {

  000a4	ea000001	 b           |$LN1@COM_PreClo|
  000a8		 |$LN3@COM_PreClo|

; 1166 :             DEBUGMSG (ZONE_ERROR, (TEXT("!!PreClose of non-open serial port\r\n")));
; 1167 :             SetLastError(ERROR_INVALID_HANDLE);

  000a8	e3a00006	 mov         r0, #6
  000ac	eb000000	 bl          SetLastError
  000b0		 |$LN1@COM_PreClo|

; 1168 :         }
; 1169 :     }
; 1170 :     // OK, other inits/opens can go ahead.
; 1171 :     LeaveCriticalSection(&(pSerialHead->OpenCS));

  000b0	e28400ec	 add         r0, r4, #0xEC
  000b4	eb000000	 bl          LeaveCriticalSection

; 1172 : 
; 1173 :     DEBUGMSG (ZONE_CLOSE|ZONE_FUNCTION, (TEXT("-COM_PreClose\r\n")));
; 1174 :     return TRUE;

  000b8	e3a00001	 mov         r0, #1

; 1175 : }

  000bc	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000c0	e12fff1e	 bx          lr
  000c4		 |$M41246|

			 ENDP  ; |COM_PreClose|

	EXPORT	|COM_Close|
	IMPORT	|LocalFree|
	IMPORT	|DeleteCriticalSection|
	IMPORT	|SetThreadPriority|

  00000			 AREA	 |.pdata|, PDATA
|$T41264| DCD	|$LN24@COM_Close|
	DCD	0x40004901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |COM_Close| PROC

; 1193 : {

  00000		 |$LN24@COM_Close|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M41261|
  00004	e1a05000	 mov         r5, r0

; 1194 :     PHW_INDEP_INFO  pSerialHead = pOpenHead->pSerialHead;

  00008	e5953000	 ldr         r3, [r5]

; 1195 :     PHWOBJ          pHWObj;
; 1196 :     //int i;
; 1197 :     BOOL            RetCode = TRUE;

  0000c	e3a07001	 mov         r7, #1
  00010	e1b04003	 movs        r4, r3

; 1198 : 
; 1199 :     DEBUGMSG (ZONE_CLOSE|ZONE_FUNCTION, (TEXT("+COM_Close\r\n")));
; 1200 : 
; 1201 :     if ( !pSerialHead ) {

  00014	1a000003	 bne         |$LN18@COM_Close|

; 1202 :         DEBUGMSG (ZONE_ERROR, (TEXT("!!COM_Close: pSerialHead == NULL!!\r\n")));
; 1203 :         SetLastError(ERROR_INVALID_HANDLE);

  00018	e3a00006	 mov         r0, #6
  0001c	eb000000	 bl          SetLastError

; 1204 :         return(FALSE);

  00020	e3a07000	 mov         r7, #0
  00024	ea00003b	 b           |$LN19@COM_Close|
  00028		 |$LN18@COM_Close|

; 1205 :     }
; 1206 :     pHWObj = (PHWOBJ)pSerialHead->pHWObj;
; 1207 : 
; 1208 :     // Use the OpenCS to make sure we don't collide with an in-progress open.
; 1209 :     EnterCriticalSection(&(pSerialHead->OpenCS));

  00028	e5946028	 ldr         r6, [r4, #0x28]
  0002c	e28400ec	 add         r0, r4, #0xEC
  00030	eb000000	 bl          EnterCriticalSection

; 1210 :     // We do special for Power Manger and Device Manager.
; 1211 :     if (pOpenHead->AccessCode & DEVACCESS_BUSNAMESPACE) {

  00034	e5953004	 ldr         r3, [r5, #4]
  00038	e3130c01	 tst         r3, #1, 24

; 1212 : 
; 1213 : 
; 1214 :         // Remove the entry from the linked list
; 1215 :         RemoveEntryList(&pOpenHead->llist);
; 1216 : 
; 1217 :         // Free all data allocated in open
; 1218 :         DeleteCriticalSection(&(pOpenHead->CommEvents.EventCS));
; 1219 :         if ( pOpenHead->CommEvents.hCommEvent )
; 1220 :             CloseHandle(pOpenHead->CommEvents.hCommEvent);
; 1221 :         LocalFree( pOpenHead );
; 1222 :     }
; 1223 :     else

  0003c	1a000021	 bne         |$LN5@COM_Close|

; 1224 :     if ( pSerialHead->OpenCnt ) {

  00040	e5943090	 ldr         r3, [r4, #0x90]
  00044	e3530000	 cmp         r3, #0
  00048	0a00002d	 beq         |$LN11@COM_Close|

; 1225 :         --(pSerialHead->OpenCnt);

  0004c	e2433001	 sub         r3, r3, #1
  00050	e5843090	 str         r3, [r4, #0x90]

; 1226 : 
; 1227 :         DEBUGMSG (1,
; 1228 :                   (TEXT("COM_Close: (%d handles) total RX %d, total TX %d, dropped (mdd, pdd) %d,%d\r\n"),
; 1229 :                    pSerialHead->OpenCnt, pSerialHead->RxBytes, pSerialHead->TxBytes, pSerialHead->DroppedBytesMDD, pSerialHead->DroppedBytesPDD));
; 1230 : 
; 1231 :         // In multi open case, do we need to restore state later on or something???
; 1232 :         if ( pHWObj && pSerialHead->OpenCnt==0 && (pHWObj->BindFlags & THREAD_IN_MDD) &&
; 1233 :             pSerialHead->pDispatchThread ) {

  00054	e3560000	 cmp         r6, #0
  00058	0a000008	 beq         |$LN10@COM_Close|
  0005c	e3530000	 cmp         r3, #0
  00060	1a000014	 bne         |$LN7@COM_Close|
  00064	e5963000	 ldr         r3, [r6]
  00068	e3130003	 tst         r3, #3
  0006c	15943040	 ldrne       r3, [r4, #0x40]
  00070	13530000	 cmpne       r3, #0

; 1234 :             SetThreadPriority(pSerialHead->pDispatchThread,
; 1235 :                               THREAD_PRIORITY_NORMAL);

  00074	13a01003	 movne       r1, #3
  00078	11a00003	 movne       r0, r3
  0007c	1b000000	 blne        SetThreadPriority
  00080		 |$LN10@COM_Close|

; 1236 :         }
; 1237 : 
; 1238 :         // If we are closing the last open handle, then close PDD also
; 1239 :         if ( !pSerialHead->OpenCnt ) {

  00080	e5943090	 ldr         r3, [r4, #0x90]
  00084	e3530000	 cmp         r3, #0
  00088	1a00000a	 bne         |$LN7@COM_Close|

; 1240 :             DEBUGMSG (ZONE_CLOSE, (TEXT("About to call HWClose\r\n")));
; 1241 :             if ( pHWObj )

  0008c	e3560000	 cmp         r6, #0

; 1242 :                 pHWObj->pFuncTbl->HWClose(pSerialHead->pHWHead);

  00090	15963008	 ldrne       r3, [r6, #8]
  00094	1594002c	 ldrne       r0, [r4, #0x2C]
  00098	15933010	 ldrne       r3, [r3, #0x10]
  0009c	11a0e00f	 movne       lr, pc
  000a0	112fff13	 bxne        r3

; 1243 :             DEBUGMSG (ZONE_CLOSE, (TEXT("Returned from HWClose\r\n")));
; 1244 : 
; 1245 :             // And if thread was spun in open, kill it now.
; 1246 :             if ( pSerialHead->pHWObj->BindFlags & THREAD_AT_OPEN ) {

  000a4	e5943028	 ldr         r3, [r4, #0x28]
  000a8	e5933000	 ldr         r3, [r3]
  000ac	e3130002	 tst         r3, #2

; 1247 :                 DEBUGMSG (ZONE_CLOSE, (TEXT("COM_Close : Stopping Dispatch Thread\r\n")));
; 1248 :                 StopDispatchThread( pSerialHead );

  000b0	11a00004	 movne       r0, r4
  000b4	1b000000	 blne        StopDispatchThread
  000b8		 |$LN7@COM_Close|

; 1249 :             }
; 1250 :         }
; 1251 : 
; 1252 : 
; 1253 :         // If this was the handle with access permission, remove pointer
; 1254 :         if ( pOpenHead == pSerialHead->pAccessOwner ) {

  000b8	e5943100	 ldr         r3, [r4, #0x100]
  000bc	e1550003	 cmp         r5, r3

; 1255 :             DEBUGMSG(ZONE_INIT|ZONE_CLOSE,
; 1256 :                      (TEXT("COM_Close: Closed access owner handle\n\r"),
; 1257 :                       pOpenHead));
; 1258 : 
; 1259 :             pSerialHead->pAccessOwner = NULL;

  000c0	03a03000	 moveq       r3, #0
  000c4	05843100	 streq       r3, [r4, #0x100]
  000c8		 |$LN5@COM_Close|

; 1260 :         }
; 1261 : 
; 1262 :         // Remove the entry from the linked list
; 1263 :         RemoveEntryList(&pOpenHead->llist);

  000c8	e5952038	 ldr         r2, [r5, #0x38]
  000cc	e5953034	 ldr         r3, [r5, #0x34]

; 1264 : 
; 1265 :         // Free all data allocated in open
; 1266 :         DeleteCriticalSection(&(pOpenHead->CommEvents.EventCS));

  000d0	e2850020	 add         r0, r5, #0x20
  000d4	e5823000	 str         r3, [r2]
  000d8	e5952034	 ldr         r2, [r5, #0x34]
  000dc	e5953038	 ldr         r3, [r5, #0x38]
  000e0	e5823004	 str         r3, [r2, #4]
  000e4	eb000000	 bl          DeleteCriticalSection

; 1267 :         if ( pOpenHead->CommEvents.hCommEvent )

  000e8	e5953010	 ldr         r3, [r5, #0x10]
  000ec	e3530000	 cmp         r3, #0

; 1268 :             CloseHandle(pOpenHead->CommEvents.hCommEvent);

  000f0	11a00003	 movne       r0, r3
  000f4	1b000000	 blne        CloseHandle

; 1269 :         LocalFree( pOpenHead );

  000f8	e1a00005	 mov         r0, r5
  000fc	eb000000	 bl          LocalFree

; 1270 :     } else {

  00100	ea000002	 b           |$LN1@COM_Close|
  00104		 |$LN11@COM_Close|

; 1271 :         DEBUGMSG (ZONE_ERROR, (TEXT("!!Close of non-open serial port\r\n")));
; 1272 :         SetLastError(ERROR_INVALID_HANDLE);

  00104	e3a00006	 mov         r0, #6
  00108	eb000000	 bl          SetLastError

; 1273 :         RetCode = FALSE;

  0010c	e3a07000	 mov         r7, #0
  00110		 |$LN1@COM_Close|

; 1274 :     }
; 1275 : 
; 1276 :     // OK, other inits/opens can go ahead.
; 1277 :     LeaveCriticalSection(&(pSerialHead->OpenCS));

  00110	e28400ec	 add         r0, r4, #0xEC
  00114	eb000000	 bl          LeaveCriticalSection

; 1278 : 
; 1279 :     DEBUGMSG (ZONE_CLOSE|ZONE_FUNCTION, (TEXT("-COM_Close\r\n")));
; 1280 :     return(RetCode);

  00118		 |$LN19@COM_Close|

; 1281 : }

  00118	e1a00007	 mov         r0, r7
  0011c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00120	e12fff1e	 bx          lr
  00124		 |$M41262|

			 ENDP  ; |COM_Close|

	EXPORT	|ProcessExiting|

  00000			 AREA	 |.pdata|, PDATA
|$T41274| DCD	|$LN7@ProcessExi|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ProcessExiting| PROC

; 1288 : {

  00000		 |$LN7@ProcessExi|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41271|

; 1289 :     PHW_INDEP_INFO  pSerialHead = pOpenHead->pSerialHead;
; 1290 :     //PHWOBJ          pHWObj;
; 1291 :     //int i;
; 1292 :     BOOL            RetCode = TRUE;
; 1293 : 
; 1294 :     DEBUGMSG (ZONE_CLOSE|ZONE_FUNCTION, (TEXT("+ProcessExiting\r\n")));
; 1295 : 
; 1296 :     if ( !pSerialHead ) {

  00004	e5903000	 ldr         r3, [r0]
  00008	e3530000	 cmp         r3, #0
  0000c	1a000004	 bne         |$LN2@ProcessExi|

; 1297 :         DEBUGMSG (ZONE_ERROR, (TEXT("!!ProcessExiting: pSerialHead == NULL!!\r\n")));
; 1298 :         SetLastError(ERROR_INVALID_HANDLE);

  00010	e3a00006	 mov         r0, #6
  00014	eb000000	 bl          SetLastError

; 1299 :         return(FALSE);

  00018	e3a00000	 mov         r0, #0

; 1305 :     }
; 1306 : }

  0001c	e49de004	 ldr         lr, [sp], #4
  00020	e12fff1e	 bx          lr
  00024		 |$LN2@ProcessExi|

; 1300 :     }
; 1301 :     else {
; 1302 :         COM_PreClose(pOpenHead);

  00024	eb000000	 bl          COM_PreClose

; 1303 :         DEBUGMSG (ZONE_CLOSE|ZONE_FUNCTION, (TEXT("-ProcessExiting\r\n")));
; 1304 :         return(TRUE);

  00028	e3a00001	 mov         r0, #1

; 1305 :     }
; 1306 : }

  0002c	e49de004	 ldr         lr, [sp], #4
  00030	e12fff1e	 bx          lr
  00034		 |$M41272|

			 ENDP  ; |ProcessExiting|

	EXPORT	|COM_PreDeinit|

  00000			 AREA	 |.pdata|, PDATA
|$T41289| DCD	|$LN13@COM_PreDei|
	DCD	0x40002401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |COM_PreDeinit| PROC

; 1316 : {

  00000		 |$LN13@COM_PreDei|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M41286|
  00004	e1b04000	 movs        r4, r0

; 1317 :     DEBUGMSG (ZONE_INIT|ZONE_FUNCTION, (TEXT("+COM_PreDeinit\r\n")));
; 1318 : 
; 1319 :     if ( !pSerialHead ) {

  00008	1a000004	 bne         |$LN5@COM_PreDei|

; 1320 :         /* Can't do much without this */
; 1321 :         DEBUGMSG (ZONE_INIT|ZONE_ERROR,
; 1322 :                   (TEXT("COM_PreDeinit can't find pSerialHead\r\n")));
; 1323 :         SetLastError(ERROR_INVALID_HANDLE);

  0000c	e3a00006	 mov         r0, #6
  00010	eb000000	 bl          SetLastError

; 1324 :         return(FALSE);

  00014	e3a00000	 mov         r0, #0

; 1354 : }

  00018	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0001c	e12fff1e	 bx          lr
  00020		 |$LN5@COM_PreDei|

; 1325 :     }
; 1326 :     /*
; 1327 :     ** Call PreClose, if we have a user.  Note that this call will ensure that
; 1328 :     ** all users are out of the serial routines before it returns.
; 1329 :     */
; 1330 :     if ( pSerialHead->OpenCnt ) {

  00020	e5943090	 ldr         r3, [r4, #0x90]
  00024	e3530000	 cmp         r3, #0
  00028	0a00000b	 beq         |$LN4@COM_PreDei|

; 1331 :         PLIST_ENTRY     pEntry;
; 1332 :         PHW_OPEN_INFO   pOpenHead;
; 1333 :         EnterCriticalSection(&(pSerialHead->OpenCS));

  0002c	e28400ec	 add         r0, r4, #0xEC
  00030	eb000000	 bl          EnterCriticalSection

; 1334 :         pEntry = pSerialHead->OpenList.Flink;
; 1335 :         while ( pEntry != &pSerialHead->OpenList ) {

  00034	e1a06004	 mov         r6, r4
  00038	e5b650e4	 ldr         r5, [r6, #0xE4]!
  0003c	ea000002	 b           |$LN10@COM_PreDei|
  00040		 |$LL3@COM_PreDei|

; 1336 :             pOpenHead = CONTAINING_RECORD( pEntry, HW_OPEN_INFO, llist);

  00040	e2450034	 sub         r0, r5, #0x34

; 1337 :             pEntry = pEntry->Flink;  // advance to next

  00044	e5955000	 ldr         r5, [r5]

; 1338 : 
; 1339 :             DEBUGMSG (ZONE_INIT | ZONE_CLOSE, (TEXT(" PreDeinit -Pre Closing Handle 0x%X\r\n"),
; 1340 :                                                pOpenHead ));
; 1341 :             COM_PreClose(pOpenHead);

  00048	eb000000	 bl          COM_PreClose
  0004c		 |$LN10@COM_PreDei|
  0004c	e1550006	 cmp         r5, r6
  00050	1afffffa	 bne         |$LL3@COM_PreDei|

; 1342 :         }
; 1343 :         LeaveCriticalSection(&(pSerialHead->OpenCS));

  00054	e28400ec	 add         r0, r4, #0xEC
  00058	eb000000	 bl          LeaveCriticalSection
  0005c		 |$LN4@COM_PreDei|

; 1344 :     }
; 1345 :     /* Now, call HW specific predeinit function */
; 1346 :     if (pSerialHead->pHWHead && pSerialHead->pHWObj && pSerialHead->pHWObj->pFuncTbl ) {

  0005c	e594302c	 ldr         r3, [r4, #0x2C]
  00060	e1b00003	 movs        r0, r3
  00064	0a000006	 beq         |$LN1@COM_PreDei|
  00068	e5943028	 ldr         r3, [r4, #0x28]
  0006c	e3530000	 cmp         r3, #0
  00070	15933008	 ldrne       r3, [r3, #8]
  00074	13530000	 cmpne       r3, #0

; 1347 :         DEBUGMSG (ZONE_INIT, (TEXT("About to call HWPreDeinit\r\n")));
; 1348 :         pSerialHead->pHWObj->pFuncTbl->HWPreDeinit(pSerialHead->pHWHead);

  00078	1593305c	 ldrne       r3, [r3, #0x5C]
  0007c	11a0e00f	 movne       lr, pc
  00080	112fff13	 bxne        r3
  00084		 |$LN1@COM_PreDei|

; 1349 :         DEBUGMSG (ZONE_INIT, (TEXT("Returned from HWPreDeinit\r\n")));
; 1350 :     }
; 1351 : 
; 1352 :     DEBUGMSG (ZONE_INIT|ZONE_FUNCTION, (TEXT("-COM_PreDeinit\r\n")));
; 1353 :     return TRUE;

  00084	e3a00001	 mov         r0, #1

; 1354 : }

  00088	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0008c	e12fff1e	 bx          lr
  00090		 |$M41287|

			 ENDP  ; |COM_PreDeinit|

	EXPORT	|COM_Deinit|

  00000			 AREA	 |.pdata|, PDATA
|$T41304| DCD	|$LN19@COM_Deinit|
	DCD	0x40004a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |COM_Deinit| PROC

; 1364 : {

  00000		 |$LN19@COM_Deinit|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M41301|
  00004	e1b04000	 movs        r4, r0

; 1365 :     DEBUGMSG (ZONE_INIT|ZONE_FUNCTION, (TEXT("+COM_Deinit\r\n")));
; 1366 : 
; 1367 :     if ( !pSerialHead ) {

  00008	1a000004	 bne         |$LN11@COM_Deinit|

; 1368 :         /* Can't do much without this */
; 1369 :         DEBUGMSG (ZONE_INIT|ZONE_ERROR,
; 1370 :                   (TEXT("COM_Deinit can't find pSerialHead\r\n")));
; 1371 :         SetLastError(ERROR_INVALID_HANDLE);

  0000c	e3a00006	 mov         r0, #6
  00010	eb000000	 bl          SetLastError

; 1372 :         return(FALSE);

  00014	e3a00000	 mov         r0, #0

; 1432 : }

  00018	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0001c	e12fff1e	 bx          lr
  00020		 |$LN11@COM_Deinit|

; 1373 :     }
; 1374 : 
; 1375 :     // If we have an interrupt handler thread, kill it
; 1376 :     if (pSerialHead->pHWObj && (pSerialHead->pHWObj->BindFlags & THREAD_IN_MDD)!=0 ) {

  00020	e5943028	 ldr         r3, [r4, #0x28]
  00024	e3530000	 cmp         r3, #0
  00028	15933000	 ldrne       r3, [r3]
  0002c	13130003	 tstne       r3, #3

; 1377 :         StopDispatchThread( pSerialHead );

  00030	11a00004	 movne       r0, r4
  00034	1b000000	 blne        StopDispatchThread

; 1378 :     }
; 1379 : 
; 1380 :     /*
; 1381 :     ** Call close, if we have a user.  Note that this call will ensure that
; 1382 :     ** all users are out of the serial routines before it returns, so we can
; 1383 :     ** go ahead and free our internal memory.
; 1384 :     */
; 1385 :     EnterCriticalSection(&(pSerialHead->OpenCS));

  00038	e28400ec	 add         r0, r4, #0xEC
  0003c	eb000000	 bl          EnterCriticalSection

; 1386 :     if ( pSerialHead->OpenCnt ) {

  00040	e5943090	 ldr         r3, [r4, #0x90]
  00044	e3530000	 cmp         r3, #0
  00048	0a000007	 beq         |$LN7@COM_Deinit|

; 1387 :         PLIST_ENTRY     pEntry;
; 1388 :         PHW_OPEN_INFO   pOpenHead;
; 1389 : 
; 1390 :         pEntry = pSerialHead->OpenList.Flink;
; 1391 :         while ( pEntry != &pSerialHead->OpenList ) {

  0004c	e1a06004	 mov         r6, r4
  00050	e5b650e4	 ldr         r5, [r6, #0xE4]!
  00054	ea000002	 b           |$LN16@COM_Deinit|
  00058		 |$LL8@COM_Deinit|

; 1392 :             pOpenHead = CONTAINING_RECORD( pEntry, HW_OPEN_INFO, llist);

  00058	e2450034	 sub         r0, r5, #0x34

; 1393 :             pEntry = pEntry->Flink;  // advance to next

  0005c	e5955000	 ldr         r5, [r5]

; 1394 : 
; 1395 :             DEBUGMSG (ZONE_INIT | ZONE_CLOSE, (TEXT(" Deinit - Closing Handle 0x%X\r\n"),
; 1396 :                                                pOpenHead ));
; 1397 :             COM_Close(pOpenHead);

  00060	eb000000	 bl          COM_Close
  00064		 |$LN16@COM_Deinit|
  00064	e1550006	 cmp         r5, r6
  00068	1afffffa	 bne         |$LL8@COM_Deinit|
  0006c		 |$LN7@COM_Deinit|

; 1398 :         }
; 1399 :     }
; 1400 :     LeaveCriticalSection(&(pSerialHead->OpenCS));

  0006c	e28400ec	 add         r0, r4, #0xEC
  00070	eb000000	 bl          LeaveCriticalSection

; 1401 : 
; 1402 :     /* Free our resources */
; 1403 :     if ( pSerialHead->hSerialEvent )

  00074	e5943030	 ldr         r3, [r4, #0x30]
  00078	e3530000	 cmp         r3, #0

; 1404 :         CloseHandle(pSerialHead->hSerialEvent);

  0007c	11a00003	 movne       r0, r3
  00080	1b000000	 blne        CloseHandle

; 1405 :     if ( pSerialHead->hKillDispatchThread )

  00084	e5943038	 ldr         r3, [r4, #0x38]
  00088	e3530000	 cmp         r3, #0

; 1406 :         CloseHandle(pSerialHead->hKillDispatchThread);

  0008c	11a00003	 movne       r0, r3
  00090	1b000000	 blne        CloseHandle

; 1407 :     if ( pSerialHead->hTransmitEvent )

  00094	e594303c	 ldr         r3, [r4, #0x3C]
  00098	e3530000	 cmp         r3, #0

; 1408 :         CloseHandle(pSerialHead->hTransmitEvent);

  0009c	11a00003	 movne       r0, r3
  000a0	1b000000	 blne        CloseHandle

; 1409 :     if ( pSerialHead->hReadEvent )

  000a4	e5943034	 ldr         r3, [r4, #0x34]
  000a8	e3530000	 cmp         r3, #0

; 1410 :         CloseHandle(pSerialHead->hReadEvent);

  000ac	11a00003	 movne       r0, r3
  000b0	1b000000	 blne        CloseHandle

; 1411 : 
; 1412 :     DeleteCriticalSection(&(pSerialHead->ReceiveCritSec1));

  000b4	e2840014	 add         r0, r4, #0x14
  000b8	eb000000	 bl          DeleteCriticalSection

; 1413 :     DeleteCriticalSection(&(pSerialHead->TransmitCritSec1));

  000bc	e1a00004	 mov         r0, r4
  000c0	eb000000	 bl          DeleteCriticalSection

; 1414 :     DeleteCriticalSection(&(pSerialHead->RxBufferInfo.CS));

  000c4	e28400b0	 add         r0, r4, #0xB0
  000c8	eb000000	 bl          DeleteCriticalSection

; 1415 :     DeleteCriticalSection(&(pSerialHead->TxBufferInfo.CS));

  000cc	e28400d0	 add         r0, r4, #0xD0
  000d0	eb000000	 bl          DeleteCriticalSection

; 1416 :     DeleteCriticalSection(&(pSerialHead->OpenCS));

  000d4	e28400ec	 add         r0, r4, #0xEC
  000d8	eb000000	 bl          DeleteCriticalSection

; 1417 : 
; 1418 :     if ( pSerialHead->RxBufferInfo.RxCharBuffer )

  000dc	e59430ac	 ldr         r3, [r4, #0xAC]
  000e0	e3530000	 cmp         r3, #0

; 1419 :         LocalFree(pSerialHead->RxBufferInfo.RxCharBuffer);

  000e4	11a00003	 movne       r0, r3
  000e8	1b000000	 blne        LocalFree

; 1420 : 
; 1421 :     /* Now, call HW specific deinit function */
; 1422 :     if (pSerialHead->pHWHead && pSerialHead->pHWObj && pSerialHead->pHWObj->pFuncTbl ) {

  000ec	e594302c	 ldr         r3, [r4, #0x2C]
  000f0	e1b00003	 movs        r0, r3
  000f4	0a000006	 beq         |$LN1@COM_Deinit|
  000f8	e5943028	 ldr         r3, [r4, #0x28]
  000fc	e3530000	 cmp         r3, #0
  00100	15933008	 ldrne       r3, [r3, #8]
  00104	13530000	 cmpne       r3, #0

; 1423 :         DEBUGMSG (ZONE_INIT, (TEXT("About to call HWDeinit\r\n")));
; 1424 :         pSerialHead->pHWObj->pFuncTbl->HWDeinit(pSerialHead->pHWHead);

  00108	15933008	 ldrne       r3, [r3, #8]
  0010c	11a0e00f	 movne       lr, pc
  00110	112fff13	 bxne        r3
  00114		 |$LN1@COM_Deinit|

; 1425 :         DEBUGMSG (ZONE_INIT, (TEXT("Returned from HWDeinit\r\n")));
; 1426 :     }
; 1427 : 
; 1428 :     LocalFree(pSerialHead);

  00114	e1a00004	 mov         r0, r4
  00118	eb000000	 bl          LocalFree

; 1429 : 
; 1430 :     DEBUGMSG (ZONE_INIT|ZONE_FUNCTION, (TEXT("-COM_Deinit\r\n")));
; 1431 :     return(TRUE);

  0011c	e3a00001	 mov         r0, #1

; 1432 : }

  00120	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00124	e12fff1e	 bx          lr
  00128		 |$M41302|

			 ENDP  ; |COM_Deinit|

	EXPORT	|COM_Read|
	IMPORT	|InterlockedDecrement|
	IMPORT	|GetTickCount|
	IMPORT	|CeSafeCopyMemory|
	IMPORT	|InterlockedIncrement|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\com_mdd2\serpriv.h

  00000			 AREA	 |.pdata|, PDATA
|$T41398| DCD	|$LN73@COM_Read|
	DCD	0x4000d702
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\com_mdd2\mdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |COM_Read| PROC

; 1452 : {

  00000		 |$LN73@COM_Read|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M41395|
  00008	e1a07001	 mov         r7, r1
  0000c	e58d7004	 str         r7, [sp, #4]
  00010	e1a09002	 mov         r9, r2
  00014	e1b0a000	 movs        r10, r0

; 1453 :     PHW_OPEN_INFO   pOpenHead = (PHW_OPEN_INFO)pHead;
; 1454 :     PHW_INDEP_INFO  pSerialHead;// = pOpenHead->pSerialHead;
; 1455 :     PHW_VTBL        pFuncTbl;//       = pSerialHead->pHWObj->pFuncTbl;
; 1456 :     PVOID           pHWHead ;//       = pSerialHead->pHWHead;
; 1457 :     ULONG           Ticks;
; 1458 :     ULONG           Timeout;
; 1459 :     ULONG           BytesRead = 0;
; 1460 :     ULONG           IntervalTimeout;    // The interval timeout
; 1461 :     ULONG           AddIntervalTimeout;
; 1462 :     ULONG           TotalTimeout;       // The Total Timeout
; 1463 :     ULONG           TimeSpent = 0;      // How much time have we been waiting?

  00018	e3a05000	 mov         r5, #0
  0001c	e58d5000	 str         r5, [sp]
  00020	e3a06000	 mov         r6, #0

; 1464 :     ULONG           Len;
; 1465 : 
; 1466 :     DEBUGMSG (ZONE_USR_READ|ZONE_FUNCTION,
; 1467 :               (TEXT("+COM_READ(0x%X,0x%X,%d)\r\n"),
; 1468 :                pHead, pTargetBuffer, BufferLength));
; 1469 :     if (pOpenHead==NULL) {
; 1470 :         DEBUGMSG (ZONE_USR_READ|ZONE_ERROR, (TEXT("COM_READ, Wrong Handle\r\n") ));
; 1471 :         SetLastError (ERROR_INVALID_HANDLE);
; 1472 :         return(ULONG)-1;

  00024	0a0000c5	 beq         |$LN25@COM_Read|

; 1473 :     }
; 1474 :     pSerialHead = pOpenHead->pSerialHead;

  00028	e59a3000	 ldr         r3, [r10]
  0002c	e1b04003	 movs        r4, r3

; 1475 :     // Check to see that the call is valid.
; 1476 :     if ( !pSerialHead || !pSerialHead->OpenCnt ) {

  00030	0a0000c2	 beq         |$LN25@COM_Read|
  00034	e5943090	 ldr         r3, [r4, #0x90]
  00038	e3530000	 cmp         r3, #0
  0003c	0a0000bf	 beq         |$LN25@COM_Read|

; 1481 :     }
; 1482 :     pFuncTbl  = pSerialHead->pHWObj->pFuncTbl;

  00040	e5943028	 ldr         r3, [r4, #0x28]

; 1483 :     pHWHead   = pSerialHead->pHWHead;
; 1484 : 
; 1485 :     // Make sure the caller has access permissions
; 1486 :     if ( !(pOpenHead->AccessCode & GENERIC_READ) ) {

  00044	e59a2004	 ldr         r2, [r10, #4]
  00048	e594102c	 ldr         r1, [r4, #0x2C]
  0004c	e5933008	 ldr         r3, [r3, #8]
  00050	e3120102	 tst         r2, #2, 2
  00054	e58d100c	 str         r1, [sp, #0xC]
  00058	e58d3008	 str         r3, [sp, #8]

; 1487 :         DEBUGMSG(ZONE_USR_READ|ZONE_ERROR,
; 1488 :                  (TEXT("COM_Read: Access permission failure x%X\n\r"),
; 1489 :                   pOpenHead->AccessCode));
; 1490 :         SetLastError (ERROR_INVALID_ACCESS);

  0005c	03a0000c	 moveq       r0, #0xC
  00060	0a0000b7	 beq         |$LN70@COM_Read|

; 1491 :         return(ULONG)-1;
; 1492 :     }
; 1493 : 
; 1494 :     if ( pTargetBuffer == NULL || BufferLength == 0 ) {

  00064	e3570000	 cmp         r7, #0
  00068	0a0000b2	 beq         |$LN22@COM_Read|
  0006c	e3590000	 cmp         r9, #0
  00070	0a0000b0	 beq         |$LN22@COM_Read|

; 1500 :     }
; 1501 : 
; 1502 :     COM_INC_USAGE_CNT(pOpenHead);

  00074	e28a000c	 add         r0, r10, #0xC
  00078	eb000000	 bl          InterlockedIncrement

; 1503 : 
; 1504 :     /* Practice safe threading.
; 1505 :      */
; 1506 :     EnterCriticalSection(&(pSerialHead->ReceiveCritSec1));

  0007c	e2840014	 add         r0, r4, #0x14
  00080	eb000000	 bl          EnterCriticalSection

; 1507 :     pSerialHead->fAbortRead = 0;

  00084	e5943094	 ldr         r3, [r4, #0x94]

; 1508 : 
; 1509 :     /* Compute total time to wait. Take product and add constant.
; 1510 :      */
; 1511 :     if ( MAXDWORD != pSerialHead->CommTimeouts.ReadTotalTimeoutMultiplier ) {

  00088	e5941080	 ldr         r1, [r4, #0x80]

; 1512 :         TotalTimeout = pSerialHead->CommTimeouts.ReadTotalTimeoutMultiplier*BufferLength +
; 1513 :                        pSerialHead->CommTimeouts.ReadTotalTimeoutConstant;
; 1514 :         // Because we are using FIFO and water level is set to 8, we have to do following
; 1515 :         AddIntervalTimeout=pSerialHead->CommTimeouts.ReadTotalTimeoutMultiplier*8;
; 1516 :     } else {
; 1517 :         TotalTimeout = pSerialHead->CommTimeouts.ReadTotalTimeoutConstant;
; 1518 :         AddIntervalTimeout=0;
; 1519 :     }
; 1520 :     IntervalTimeout = pSerialHead->CommTimeouts.ReadIntervalTimeout;

  0008c	e594807c	 ldr         r8, [r4, #0x7C]
  00090	e3c33040	 bic         r3, r3, #0x40
  00094	e3710001	 cmn         r1, #1
  00098	e5843094	 str         r3, [r4, #0x94]
  0009c	15943084	 ldrne       r3, [r4, #0x84]
  000a0	11a02181	 movne       r2, r1, lsl #3
  000a4	03a02000	 moveq       r2, #0

; 1521 :     if ((IntervalTimeout < MAXDWORD  - AddIntervalTimeout) && (IntervalTimeout != 0)) {

  000a8	e3e00000	 mvn         r0, #0
  000ac	102b3991	 mlane       r11, r1, r9, r3
  000b0	0594b084	 ldreq       r11, [r4, #0x84]
  000b4	e0623000	 rsb         r3, r2, r0
  000b8	e1580003	 cmp         r8, r3
  000bc	2a000001	 bcs         |$LL18@COM_Read|
  000c0	e3580000	 cmp         r8, #0

; 1522 :         IntervalTimeout +=AddIntervalTimeout;

  000c4	10888002	 addne       r8, r8, r2
  000c8		 |$LL18@COM_Read|

; 1523 :     };
; 1524 : 
; 1525 :     DEBUGMSG (ZONE_USR_READ, (TEXT("TotalTimeout:%d\r\n"), TotalTimeout));
; 1526 : 
; 1527 :     while ( BufferLength ) {
; 1528 :         DEBUGMSG (ZONE_USR_READ,
; 1529 :                   (TEXT("Top of Loop Fifo(R=%d,W=%d,L=%d,BA=%d)\r\n"),
; 1530 :                    RxRead(pSerialHead), RxWrite(pSerialHead),
; 1531 :                    RxLength(pSerialHead),
; 1532 :                    RxBytesAvail(pSerialHead)));
; 1533 :         if ( RxBytesAvail(pSerialHead) ) {

  000c8	e59420a0	 ldr         r2, [r4, #0xA0]
  000cc	e594109c	 ldr         r1, [r4, #0x9C]
  000d0	e1520001	 cmp         r2, r1
  000d4	20423001	 subcs       r3, r2, r1
  000d8	359430a4	 ldrcc       r3, [r4, #0xA4]
  000dc	30433001	 subcc       r3, r3, r1
  000e0	30833002	 addcc       r3, r3, r2
  000e4	e3530000	 cmp         r3, #0
  000e8	0a000026	 beq         |$LN16@COM_Read|

; 1534 :             RxEnterCS(pSerialHead);

  000ec	e28400b0	 add         r0, r4, #0xB0
  000f0	eb000000	 bl          EnterCriticalSection

; 1535 :             // Copy the data over
; 1536 :             // This only copies the continous portion, This will cause a loop
; 1537 :             // if the receive data spans the end of the buffer.
; 1538 :             Len = MIN(RxBytesAvail(pSerialHead),
; 1539 :                       RxLength(pSerialHead)-RxRead(pSerialHead));

  000f4	e59420a0	 ldr         r2, [r4, #0xA0]
  000f8	e594109c	 ldr         r1, [r4, #0x9C]
  000fc	e59400a4	 ldr         r0, [r4, #0xA4]
  00100	e1520001	 cmp         r2, r1
  00104	20423001	 subcs       r3, r2, r1
  00108	359430a4	 ldrcc       r3, [r4, #0xA4]
  0010c	e0405001	 sub         r5, r0, r1
  00110	30433001	 subcc       r3, r3, r1
  00114	30833002	 addcc       r3, r3, r2
  00118	e1530005	 cmp         r3, r5
  0011c	2a000003	 bcs         |$LN30@COM_Read|
  00120	e1520001	 cmp         r2, r1
  00124	30403001	 subcc       r3, r0, r1
  00128	20425001	 subcs       r5, r2, r1
  0012c	30835002	 addcc       r5, r3, r2
  00130		 |$LN30@COM_Read|

; 1540 :             Len = MIN(Len, BufferLength);
; 1541 :             DEBUGMSG (ZONE_USR_READ, (TEXT("About to copy %d bytes\r\n"), Len));
; 1542 :             CeSafeCopyMemory (pTargetBuffer, RxBuffRead(pSerialHead), Len);

  00130	e59430ac	 ldr         r3, [r4, #0xAC]
  00134	e1550009	 cmp         r5, r9
  00138	21a05009	 movcs       r5, r9
  0013c	e1a02005	 mov         r2, r5
  00140	e0831001	 add         r1, r3, r1
  00144	e1a00007	 mov         r0, r7
  00148	eb000000	 bl          CeSafeCopyMemory

; 1543 :             // Update Fifo info
; 1544 :             RxRead(pSerialHead) =
; 1545 :                 (RxRead(pSerialHead)+ Len<RxLength(pSerialHead)? RxRead(pSerialHead)+Len: RxRead(pSerialHead)+Len-RxLength(pSerialHead));

  0014c	e594209c	 ldr         r2, [r4, #0x9C]
  00150	e59410a4	 ldr         r1, [r4, #0xA4]

; 1546 : 
; 1547 :             // Update all the pointers.
; 1548 :             BufferLength -= Len;
; 1549 :             pTargetBuffer += Len;
; 1550 :             BytesRead += Len;
; 1551 :             RxLeaveCS(pSerialHead);

  00154	e0877005	 add         r7, r7, r5
  00158	e0823005	 add         r3, r2, r5
  0015c	e1530001	 cmp         r3, r1
  00160	20423001	 subcs       r3, r2, r1
  00164	20833005	 addcs       r3, r3, r5
  00168	e28400b0	 add         r0, r4, #0xB0
  0016c	e584309c	 str         r3, [r4, #0x9C]
  00170	e0499005	 sub         r9, r9, r5
  00174	e58d7004	 str         r7, [sp, #4]
  00178	e0866005	 add         r6, r6, r5
  0017c	eb000000	 bl          LeaveCriticalSection

; 1552 :         } else {

  00180	e59d5000	 ldr         r5, [sp]
  00184	ea00002a	 b           |$LN6@COM_Read|
  00188		 |$LN16@COM_Read|

; 1553 :             // Wait for a serial event?
; 1554 :             if ( IntervalTimeout == MAXDWORD){  // Special Case see Remarks of COMMTIMEOUTS

  00188	e3780001	 cmn         r8, #1
  0018c	1a000003	 bne         |$LN11@COM_Read|

; 1555 :                 if (TotalTimeout == 0)

  00190	e35b0000	 cmp         r11, #0
  00194	0a000062	 beq         |$LN17@COM_Read|

; 1556 :                     // For some reason this means don't wait.
; 1557 :                     break;
; 1558 :                 else
; 1559 :                 if (BytesRead!=0) // There is data in the buffer or has been readed.

  00198	e3560000	 cmp         r6, #0
  0019c	1a000060	 bne         |$LN17@COM_Read|
  001a0		 |$LN11@COM_Read|

; 1560 :                     break;
; 1561 :             }
; 1562 :             Timeout=(TotalTimeout!=0?TotalTimeout:MAXDWORD);

  001a0	e35b0000	 cmp         r11, #0
  001a4	11a0300b	 movne       r3, r11
  001a8	01a03000	 moveq       r3, r0

; 1563 :             // Total timeout is valid
; 1564 :             if ( TimeSpent >= Timeout ) {

  001ac	e1550003	 cmp         r5, r3
  001b0	2a00005b	 bcs         |$LN17@COM_Read|

; 1565 :                 // Timed out.
; 1566 :                 break;
; 1567 :             }
; 1568 :             Timeout -= TimeSpent;

  001b4	e0435005	 sub         r5, r3, r5

; 1569 :             // On first byte we only use interval timeout
; 1570 :             // on subsequent we use minimum of Interval and Timeout
; 1571 :             if ( BytesRead) {

  001b8	e3560000	 cmp         r6, #0
  001bc	0a000007	 beq         |$LN41@COM_Read|

; 1572 :                 Timeout = MIN(Timeout, (IntervalTimeout!=0?IntervalTimeout:MAXDWORD));

  001c0	e3580000	 cmp         r8, #0
  001c4	11a03008	 movne       r3, r8
  001c8	01a03000	 moveq       r3, r0
  001cc	e1550003	 cmp         r5, r3
  001d0	3a000002	 bcc         |$LN41@COM_Read|
  001d4	e3580000	 cmp         r8, #0
  001d8	11a05008	 movne       r5, r8
  001dc	01a05000	 moveq       r5, r0
  001e0		 |$LN41@COM_Read|

; 1573 :             }
; 1574 :             Ticks = GetTickCount();

  001e0	eb000000	 bl          GetTickCount
  001e4	e1a07000	 mov         r7, r0

; 1575 :             DEBUGMSG (ZONE_USR_READ, (TEXT("About to wait %dms\r\n"), Timeout));
; 1576 : 
; 1577 :             if ( WAIT_TIMEOUT == WaitForSingleObject (pSerialHead->hReadEvent,
; 1578 :                                                       Timeout) ) {

  001e8	e5940034	 ldr         r0, [r4, #0x34]
  001ec	e1a01005	 mov         r1, r5
  001f0	eb000000	 bl          WaitForSingleObject
  001f4	e3a02c01	 mov         r2, #1, 24
  001f8	e3823002	 orr         r3, r2, #2
  001fc	e1500003	 cmp         r0, r3
  00200	0a000047	 beq         |$LN17@COM_Read|

; 1579 :                 // Timeout
; 1580 :                 break;
; 1581 :             }
; 1582 :             // Since ticks is a ULONG this handles wrap.
; 1583 :             Ticks = GetTickCount() - Ticks;

  00204	eb000000	 bl          GetTickCount

; 1584 :             TimeSpent += Ticks;
; 1585 : 
; 1586 :             // In the absense of WaitForMultipleObjects, we use flags to
; 1587 :             // handle errors/aborts. Check for aborts or asynchronous closes.
; 1588 :             if ( pSerialHead->fAbortRead ) {

  00208	e59d5000	 ldr         r5, [sp]
  0020c	e5942094	 ldr         r2, [r4, #0x94]
  00210	e0403007	 sub         r3, r0, r7
  00214	e0855003	 add         r5, r5, r3
  00218	e58d5000	 str         r5, [sp]
  0021c	e3120040	 tst         r2, #0x40
  00220	1a00003f	 bne         |$LN17@COM_Read|

; 1589 :                 DEBUGMSG(ZONE_USR_READ,(TEXT("COM_Read - Aborting read\r\n")));
; 1590 :                 break;
; 1591 :             }
; 1592 : 
; 1593 :             if ( !pSerialHead->OpenCnt ) {

  00224	e5943090	 ldr         r3, [r4, #0x90]
  00228	e3530000	 cmp         r3, #0
  0022c	0a00003a	 beq         |$LN66@COM_Read|

; 1546 : 
; 1547 :             // Update all the pointers.
; 1548 :             BufferLength -= Len;
; 1549 :             pTargetBuffer += Len;
; 1550 :             BytesRead += Len;
; 1551 :             RxLeaveCS(pSerialHead);

  00230	e59d7004	 ldr         r7, [sp, #4]
  00234		 |$LN6@COM_Read|

; 1597 :                 break;
; 1598 :             }
; 1599 :         }
; 1600 : 
; 1601 :         if (IsReducedToFlowOn(pSerialHead)) {

  00234	e59420a0	 ldr         r2, [r4, #0xA0]
  00238	e594109c	 ldr         r1, [r4, #0x9C]
  0023c	e1520001	 cmp         r2, r1
  00240	359430a4	 ldrcc       r3, [r4, #0xA4]
  00244	20422001	 subcs       r2, r2, r1
  00248	30433001	 subcc       r3, r3, r1
  0024c	30832002	 addcc       r2, r3, r2
  00250	e1d436be	 ldrh        r3, [r4, #0x6E]
  00254	e1530002	 cmp         r3, r2
  00258	3a00002b	 bcc         |$LN1@COM_Read|

; 1602 :             // Are we below the SW flow control limits?
; 1603 :             if ( pSerialHead->DCB.fInX && pSerialHead->SentXoff) {

  0025c	e5942068	 ldr         r2, [r4, #0x68]
  00260	e3120c02	 tst         r2, #2, 24
  00264	0a00000e	 beq         |$LN4@COM_Read|
  00268	e5943094	 ldr         r3, [r4, #0x94]
  0026c	e3130008	 tst         r3, #8
  00270	0a00000b	 beq         |$LN4@COM_Read|

; 1604 :                 PHWOBJ  pHWObj  = pSerialHead->pHWObj;
; 1605 :                 DEBUGMSG (ZONE_FLOW, (TEXT("Sending XON\r\n")));
; 1606 :                 pSerialHead->SentXoff = 0;

  00274	e3c33008	 bic         r3, r3, #8
  00278	e5941028	 ldr         r1, [r4, #0x28]

; 1607 :                 if ( !pSerialHead->DCB.fTXContinueOnXoff ) {

  0027c	e3120080	 tst         r2, #0x80
  00280	e5843094	 str         r3, [r4, #0x94]

; 1608 :                     pSerialHead->StopXmit = 0;

  00284	03c33004	 biceq       r3, r3, #4
  00288	05843094	 streq       r3, [r4, #0x94]

; 1609 :                 }
; 1610 :                 pHWObj->pFuncTbl->HWXmitComChar(pSerialHead->pHWHead,
; 1611 :                                                 pSerialHead->DCB.XonChar);

  0028c	e5913008	 ldr         r3, [r1, #8]
  00290	e5d41075	 ldrb        r1, [r4, #0x75]
  00294	e594002c	 ldr         r0, [r4, #0x2C]
  00298	e5933054	 ldr         r3, [r3, #0x54]
  0029c	e1a0e00f	 mov         lr, pc
  002a0	e12fff13	 bx          r3
  002a4		 |$LN4@COM_Read|

; 1612 :             }
; 1613 :             if ( pSerialHead->RtsFlow &&
; 1614 :                  (pSerialHead->DCB.fRtsControl == RTS_CONTROL_HANDSHAKE) ) {

  002a4	e5942094	 ldr         r2, [r4, #0x94]
  002a8	e3120020	 tst         r2, #0x20
  002ac	0a000009	 beq         |$LN2@COM_Read|
  002b0	e5943068	 ldr         r3, [r4, #0x68]
  002b4	e2033a03	 and         r3, r3, #3, 20
  002b8	e3530a02	 cmp         r3, #2, 20

; 1615 :                 DEBUGMSG (ZONE_USR_READ|ZONE_FLOW,
; 1616 :                           (TEXT("RTS_CONTROL_HANDSHAKE Setting RTS\r\n")));
; 1617 :                 pSerialHead->RtsFlow = 0;

  002bc	03c23020	 biceq       r3, r2, #0x20
  002c0	05843094	 streq       r3, [r4, #0x94]

; 1618 :                 pFuncTbl->HWSetRTS(pHWHead);

  002c4	059d3008	 ldreq       r3, [sp, #8]
  002c8	059d000c	 ldreq       r0, [sp, #0xC]
  002cc	05933040	 ldreq       r3, [r3, #0x40]
  002d0	01a0e00f	 moveq       lr, pc
  002d4	012fff13	 bxeq        r3
  002d8		 |$LN2@COM_Read|

; 1619 :             }
; 1620 :             if ( pSerialHead->DtrFlow &&
; 1621 :                  (pSerialHead->DCB.fDtrControl == DTR_CONTROL_HANDSHAKE) ) {

  002d8	e5942094	 ldr         r2, [r4, #0x94]
  002dc	e3120010	 tst         r2, #0x10
  002e0	0a000009	 beq         |$LN1@COM_Read|
  002e4	e5943068	 ldr         r3, [r4, #0x68]
  002e8	e2033030	 and         r3, r3, #0x30
  002ec	e3530020	 cmp         r3, #0x20

; 1622 :                 DEBUGMSG (ZONE_USR_READ|ZONE_FLOW,
; 1623 :                           (TEXT("DTR_CONTROL_HANDSHAKE Setting DTR\r\n")));
; 1624 :                 pSerialHead->DtrFlow = 0;

  002f0	03c23010	 biceq       r3, r2, #0x10
  002f4	05843094	 streq       r3, [r4, #0x94]

; 1625 :                 pFuncTbl->HWSetDTR(pHWHead);

  002f8	059d3008	 ldreq       r3, [sp, #8]
  002fc	059d000c	 ldreq       r0, [sp, #0xC]
  00300	05933038	 ldreq       r3, [r3, #0x38]
  00304	01a0e00f	 moveq       lr, pc
  00308	012fff13	 bxeq        r3
  0030c		 |$LN1@COM_Read|
  0030c	e3590000	 cmp         r9, #0
  00310	e3e00000	 mvn         r0, #0
  00314	1affff6b	 bne         |$LL18@COM_Read|

; 1589 :                 DEBUGMSG(ZONE_USR_READ,(TEXT("COM_Read - Aborting read\r\n")));
; 1590 :                 break;
; 1591 :             }
; 1592 : 
; 1593 :             if ( !pSerialHead->OpenCnt ) {

  00318	ea000001	 b           |$LN17@COM_Read|
  0031c		 |$LN66@COM_Read|

; 1594 :                 DEBUGMSG(ZONE_USR_READ|ZONE_ERROR,
; 1595 :                          (TEXT("COM_Read - device was closed\n\r")));
; 1596 :                 SetLastError(ERROR_INVALID_HANDLE);

  0031c	e3a00006	 mov         r0, #6
  00320	eb000000	 bl          SetLastError
  00324		 |$LN17@COM_Read|

; 1626 :             }
; 1627 :         }
; 1628 : 
; 1629 :     }
; 1630 : 
; 1631 :     DEBUGMSG (ZONE_USR_READ, (TEXT("ReceiveBytes exiting\r\n")));
; 1632 : 
; 1633 :     LeaveCriticalSection(&(pSerialHead->ReceiveCritSec1));

  00324	e2840014	 add         r0, r4, #0x14
  00328	eb000000	 bl          LeaveCriticalSection

; 1634 : 
; 1635 :     DEBUGMSG (ZONE_USR_READ|ZONE_FUNCTION,
; 1636 :               (TEXT("-COM_READ: returning %d (total %d, dropped %d,%d)\r\n"),
; 1637 :                BytesRead, pSerialHead->RxBytes, pSerialHead->DroppedBytesMDD,pSerialHead->DroppedBytesPDD));
; 1638 : 
; 1639 :     COM_DEC_USAGE_CNT(pOpenHead);

  0032c	e28a000c	 add         r0, r10, #0xC
  00330	eb000000	 bl          InterlockedDecrement

; 1640 : 
; 1641 :     return(BytesRead);

  00334	ea000004	 b           |$LN28@COM_Read|
  00338		 |$LN22@COM_Read|

; 1495 :         DEBUGMSG (ZONE_READ|ZONE_ERROR,
; 1496 :                   (TEXT("COM_READ, bad  pointer(0x%x) or length(0x%x)\r\n"),pTargetBuffer, BufferLength));
; 1497 :         BytesRead = (ULONG)-1;
; 1498 :         SetLastError(ERROR_INVALID_PARAMETER);

  00338	e3a00057	 mov         r0, #0x57

; 1499 :         return(ULONG)-1;

  0033c	ea000000	 b           |$LN70@COM_Read|
  00340		 |$LN25@COM_Read|

; 1477 :         DEBUGMSG (ZONE_USR_READ|ZONE_ERROR,
; 1478 :                   (TEXT("COM_READ, device not open\r\n") ));
; 1479 :         SetLastError (ERROR_INVALID_HANDLE);

  00340	e3a00006	 mov         r0, #6
  00344		 |$LN70@COM_Read|
  00344	eb000000	 bl          SetLastError

; 1480 :         return(ULONG)-1;

  00348	e3e06000	 mvn         r6, #0
  0034c		 |$LN28@COM_Read|

; 1642 : }

  0034c	e1a00006	 mov         r0, r6
  00350	e28dd010	 add         sp, sp, #0x10
  00354	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00358	e12fff1e	 bx          lr
  0035c		 |$M41396|

			 ENDP  ; |COM_Read|

	EXPORT	|COM_Seek|

  00000			 AREA	 |.pdata|, PDATA
|$T41407| DCD	|$LN5@COM_Seek|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |COM_Seek| PROC

; 1832 : {

  00000		 |$LN5@COM_Seek|
  00000		 |$M41404|

; 1833 :     return(ULONG)-1;

  00000	e3e00000	 mvn         r0, #0

; 1834 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M41405|

			 ENDP  ; |COM_Seek|

	EXPORT	|COM_PowerUp|

  00000			 AREA	 |.pdata|, PDATA
|$T41418| DCD	|$LN7@COM_PowerU|
	DCD	0x40001001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |COM_PowerUp| PROC

; 1846 : {

  00000		 |$LN7@COM_PowerU|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41415|
  00004	e3500000	 cmp         r0, #0

; 1847 :     PHW_INDEP_INFO  pHWIHead    = (PHW_INDEP_INFO)pHead;
; 1848 :     PHWOBJ          pHWObj;
; 1849 : 
; 1850 :     if (pHWIHead) {

  00008	0a000009	 beq         |$LN1@COM_PowerU|

; 1851 :         pHWObj = (PHWOBJ)pHWIHead->pHWObj;

  0000c	e5903028	 ldr         r3, [r0, #0x28]
  00010	e3530000	 cmp         r3, #0

; 1852 :         if (pHWObj)

  00014	0a000006	 beq         |$LN1@COM_PowerU|

; 1853 :             return(pHWObj->pFuncTbl->HWPowerOn(pHWIHead->pHWHead));

  00018	e5933008	 ldr         r3, [r3, #8]
  0001c	e590002c	 ldr         r0, [r0, #0x2C]
  00020	e5933030	 ldr         r3, [r3, #0x30]
  00024	e1a0e00f	 mov         lr, pc
  00028	e12fff13	 bx          r3

; 1856 : }

  0002c	e49de004	 ldr         lr, [sp], #4
  00030	e12fff1e	 bx          lr
  00034		 |$LN1@COM_PowerU|

; 1854 :     }
; 1855 :     return FALSE;

  00034	e3a00000	 mov         r0, #0

; 1856 : }

  00038	e49de004	 ldr         lr, [sp], #4
  0003c	e12fff1e	 bx          lr
  00040		 |$M41416|

			 ENDP  ; |COM_PowerUp|

	EXPORT	|COM_PowerDown|

  00000			 AREA	 |.pdata|, PDATA
|$T41429| DCD	|$LN7@COM_PowerD|
	DCD	0x40001001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |COM_PowerDown| PROC

; 1868 : {

  00000		 |$LN7@COM_PowerD|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41426|
  00004	e3500000	 cmp         r0, #0

; 1869 :     PHW_INDEP_INFO          pHWIHead    = (PHW_INDEP_INFO)pHead;
; 1870 : 
; 1871 :     if ( pHWIHead ) {

  00008	0a000009	 beq         |$LN1@COM_PowerD|

; 1872 :         PHWOBJ  pHWObj = (PHWOBJ)pHWIHead->pHWObj;

  0000c	e5903028	 ldr         r3, [r0, #0x28]
  00010	e3530000	 cmp         r3, #0

; 1873 :         if ( pHWObj)

  00014	0a000006	 beq         |$LN1@COM_PowerD|

; 1874 :             return(pHWObj->pFuncTbl->HWPowerOff(pHWIHead->pHWHead));

  00018	e5933008	 ldr         r3, [r3, #8]
  0001c	e590002c	 ldr         r0, [r0, #0x2C]
  00020	e593302c	 ldr         r3, [r3, #0x2C]
  00024	e1a0e00f	 mov         lr, pc
  00028	e12fff13	 bx          r3

; 1877 : }

  0002c	e49de004	 ldr         lr, [sp], #4
  00030	e12fff1e	 bx          lr
  00034		 |$LN1@COM_PowerD|

; 1875 :     }
; 1876 :     return FALSE;

  00034	e3a00000	 mov         r0, #0

; 1877 : }

  00038	e49de004	 ldr         lr, [sp], #4
  0003c	e12fff1e	 bx          lr
  00040		 |$M41427|

			 ENDP  ; |COM_PowerDown|

	EXPORT	|SerialGetDroppedByteNumber|

  00000			 AREA	 |.pdata|, PDATA
|$T41439| DCD	|$LN6@SerialGetD|
	DCD	0x40000600
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SerialGetDroppedByteNumber| PROC

; 1891 : {

  00000		 |$LN6@SerialGetD|
  00000		 |$M41436|
  00000	e3500000	 cmp         r0, #0

; 1892 :     PHW_INDEP_INFO          pHWIHead    = (PHW_INDEP_INFO)pHead;
; 1893 : 
; 1894 :     if ( !pHWIHead ) {
; 1895 :         return(0);

  00004	03a00000	 moveq       r0, #0

; 1896 :     }
; 1897 : 
; 1898 :     return(pHWIHead->DroppedBytesMDD+pHWIHead->DroppedBytesPDD);

  00008	1590204c	 ldrne       r2, [r0, #0x4C]
  0000c	15903048	 ldrne       r3, [r0, #0x48]
  00010	10820003	 addne       r0, r2, r3

; 1899 : }

  00014	e12fff1e	 bx          lr
  00018		 |$M41437|

			 ENDP  ; |SerialGetDroppedByteNumber|

	EXPORT	|WaitCommEvent_mdd|
	IMPORT	|InterlockedExchange|
	IMPORT	|__C_specific_handler|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T41477| DCD	|$LN37@WaitCommEv|
	DCD	0xc0005205

  00000			 AREA	 |.pdata|, PDATA
|$T41479| DCD	|$LN16@WaitCommEv|
	DCD	0x40000301

  00000			 AREA	 |.xdata|, DATA
|$T41475| DCD	0x1
	DCD	|$LN20@WaitCommEv|
	DCD	|$LN21@WaitCommEv|
	DCD	|$LN16@WaitCommEv|
	DCD	|$LN17@WaitCommEv|
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\com_mdd2\mdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T41475|

  00008		 |WaitCommEvent_mdd| PROC

; 1913 : {

  00008		 |$LN37@WaitCommEv|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d0007	 stmdb       sp!, {r0 - r2}
  00010	e92d58f0	 stmdb       sp!, {r4 - r7, r11, r12, lr}
  00014	e28db01c	 add         r11, sp, #0x1C
  00018	e24dd004	 sub         sp, sp, #4
  0001c		 |$LN35@WaitCommEv|
  0001c	e1a05001	 mov         r5, r1
  00020	e58b5004	 str         r5, [r11, #4]
  00024	e1a04000	 mov         r4, r0
  00028	e58b4000	 str         r4, [r11]

; 1914 :     PHW_INDEP_INFO  pHWIHead = pOpenHead->pSerialHead;

  0002c	e5943000	 ldr         r3, [r4]
  00030	e1b06003	 movs        r6, r3
  00034	e50b6020	 str         r6, [r11, #-0x20]

; 1915 :     DWORD           dwEventData;
; 1916 : 
; 1917 :     DEBUGMSG(ZONE_FUNCTION|ZONE_EVENTS,(TEXT("+WaitCommEvent x%X x%X, pMask x%X\n\r"),
; 1918 :                                         pOpenHead, pHWIHead , pfdwEventMask));
; 1919 : 
; 1920 :     if ( !pHWIHead || !pHWIHead->OpenCnt ) {

  00038	0a00003c	 beq         |$LN11@WaitCommEv|
  0003c	e5963090	 ldr         r3, [r6, #0x90]
  00040	e3530000	 cmp         r3, #0
  00044	0a000039	 beq         |$LN11@WaitCommEv|

; 1926 :     }
; 1927 : 
; 1928 :     // We should return immediately if mask is 0
; 1929 :     if ( !pOpenHead->CommEvents.fEventMask ) {

  00048	e5943014	 ldr         r3, [r4, #0x14]
  0004c	e3530000	 cmp         r3, #0

; 1930 :         DEBUGMSG (ZONE_ERROR|ZONE_EVENTS, (TEXT("-WaitCommEvent - Mask already clear\r\n")));
; 1931 :         *pfdwEventMask = 0;
; 1932 :         SetLastError(ERROR_INVALID_PARAMETER);

  00050	03a00057	 moveq       r0, #0x57

; 1926 :     }
; 1927 : 
; 1928 :     // We should return immediately if mask is 0
; 1929 :     if ( !pOpenHead->CommEvents.fEventMask ) {

  00054	0a000036	 beq         |$LN31@WaitCommEv|

; 1933 :         return(FALSE);
; 1934 :     }
; 1935 : 
; 1936 :     COM_INC_USAGE_CNT(pOpenHead);

  00058	e284000c	 add         r0, r4, #0xC
  0005c	eb000000	 bl          InterlockedIncrement

; 1937 : 
; 1938 :     // Abort should only affect us once we start waiting.  Ignore any old aborts
; 1939 :     pOpenHead->CommEvents.fAbort = 0;

  00060	e3a07000	 mov         r7, #0
  00064	e584701c	 str         r7, [r4, #0x1C]

; 1940 : 
; 1941 :     while ( pHWIHead->OpenCnt ) {

  00068	ea000014	 b           |$LN33@WaitCommEv|
  0006c		 |$LL9@WaitCommEv|

; 1942 :         // Read and clear any event bits
; 1943 :         EnterCriticalSection(&(pOpenHead->CommEvents.EventCS));

  0006c	e2840020	 add         r0, r4, #0x20
  00070	eb000000	 bl          EnterCriticalSection

; 1944 :         ResetEvent(pOpenHead->CommEvents.hCommEvent);

  00074	e5940010	 ldr         r0, [r4, #0x10]
  00078	e3a01002	 mov         r1, #2
  0007c	eb000000	 bl          EventModify

; 1945 :         dwEventData = InterlockedExchange( &(pOpenHead->CommEvents.fEventData), 0 );

  00080	e3a01000	 mov         r1, #0
  00084	e2840018	 add         r0, r4, #0x18
  00088	eb000000	 bl          InterlockedExchange

; 1946 :         DEBUGMSG (ZONE_EVENTS, (TEXT(" WaitCommEvent - Events 0x%X, Mask 0x%X, Abort %X\r\n"),
; 1947 :                                 dwEventData,
; 1948 :                                 pOpenHead->CommEvents.fEventMask,
; 1949 :                                 pOpenHead->CommEvents.fAbort ));
; 1950 : 
; 1951 :         // See if we got any events of interest or mask is reset to zero
; 1952 :         if ( (dwEventData & pOpenHead->CommEvents.fEventMask) != 0 ||
; 1953 :                 pOpenHead->CommEvents.fEventMask == 0 ) {

  0008c	e5943014	 ldr         r3, [r4, #0x14]
  00090	e1130000	 tst         r3, r0
  00094	1a000016	 bne         |$LN6@WaitCommEv|
  00098	e3530000	 cmp         r3, #0
  0009c	0a000014	 beq         |$LN6@WaitCommEv|

; 1960 :             break;
; 1961 :         }
; 1962 :         else
; 1963 :             LeaveCriticalSection(&(pOpenHead->CommEvents.EventCS));

  000a0	e2840020	 add         r0, r4, #0x20
  000a4	eb000000	 bl          LeaveCriticalSection

; 1964 : 
; 1965 :         // Wait for an event from PDD, or from SetCommMask
; 1966 :         WaitForSingleObject(pOpenHead->CommEvents.hCommEvent,
; 1967 :                             (ULONG)-1);

  000a8	e5940010	 ldr         r0, [r4, #0x10]
  000ac	e3e01000	 mvn         r1, #0
  000b0	eb000000	 bl          WaitForSingleObject

; 1968 : 
; 1969 :         // We should return immediately if mask was set via SetCommMask.
; 1970 :         if ( pOpenHead->CommEvents.fAbort ) {

  000b4	e594301c	 ldr         r3, [r4, #0x1C]
  000b8	e3530000	 cmp         r3, #0
  000bc	1a00000a	 bne         |$LN29@WaitCommEv|
  000c0		 |$LN33@WaitCommEv|
  000c0	e5963090	 ldr         r3, [r6, #0x90]
  000c4	e3530000	 cmp         r3, #0
  000c8	1affffe7	 bne         |$LL9@WaitCommEv|

; 1958 :             };
; 1959 :             LeaveCriticalSection(&(pOpenHead->CommEvents.EventCS));

  000cc		 |$LN8@WaitCommEv|

; 1976 :         }
; 1977 : 
; 1978 :     }
; 1979 : 
; 1980 :     COM_DEC_USAGE_CNT(pOpenHead);

  000cc	e284000c	 add         r0, r4, #0xC
  000d0	eb000000	 bl          InterlockedDecrement

; 1981 : 
; 1982 :     // Check and see if device was closed while we were waiting
; 1983 :     if ( !pHWIHead->OpenCnt ) {

  000d4	e5963090	 ldr         r3, [r6, #0x90]
  000d8	e3530000	 cmp         r3, #0
  000dc	1a000011	 bne         |$LN2@WaitCommEv|

; 1984 :         // Device was closed.  Get out of here.
; 1985 :         DEBUGMSG (ZONE_EVENTS|ZONE_ERROR,
; 1986 :                   (TEXT("-WaitCommEvent - device was closed\r\n")));
; 1987 :         *pfdwEventMask = 0;
; 1988 :         SetLastError (ERROR_INVALID_HANDLE);

  000e0	e3a00006	 mov         r0, #6
  000e4	e5857000	 str         r7, [r5]

; 1989 :         return(FALSE);

  000e8	ea000013	 b           |$LN34@WaitCommEv|
  000ec		 |$LN29@WaitCommEv|

; 1971 :             // We must have been terminated by SetCommMask()
; 1972 :             // Return TRUE with a mask of 0.
; 1973 :             DEBUGMSG (ZONE_ERROR|ZONE_EVENTS, (TEXT(" WaitCommEvent - Mask was cleared\r\n")));
; 1974 :             *pfdwEventMask = 0;

  000ec	e5857000	 str         r7, [r5]

; 1975 :             break;

  000f0	eafffff5	 b           |$LN8@WaitCommEv|
  000f4		 |$LN6@WaitCommEv|
  000f4		 |$LN20@WaitCommEv|

; 1954 :             __try {
; 1955 :                 *pfdwEventMask = dwEventData & pOpenHead->CommEvents.fEventMask;

  000f4	e5943014	 ldr         r3, [r4, #0x14]
  000f8	e0033000	 and         r3, r3, r0
  000fc	e5853000	 str         r3, [r5]
  00100		 |$LN21@WaitCommEv|

; 1956 :             }

  00100	ea000003	 b           |$LN22@WaitCommEv|
  00104		 |$LN17@WaitCommEv|

; 1957 :             __except(EXCEPTION_EXECUTE_HANDLER) {

  00104	e59b5004	 ldr         r5, [r11, #4]
  00108	e59b4000	 ldr         r4, [r11]
  0010c	e51b6020	 ldr         r6, [r11, #-0x20]
  00110	e3a07000	 mov         r7, #0
  00114		 |$LN22@WaitCommEv|

; 1958 :             };
; 1959 :             LeaveCriticalSection(&(pOpenHead->CommEvents.EventCS));

  00114	e2840020	 add         r0, r4, #0x20
  00118	eb000000	 bl          LeaveCriticalSection
  0011c	eaffffea	 b           |$LN8@WaitCommEv|
  00120		 |$LN30@WaitCommEv|

; 1925 :         return(FALSE);

  00120	e51b0020	 ldr         r0, [r11, #-0x20]
  00124	ea000006	 b           |$LN1@WaitCommEv|
  00128		 |$LN2@WaitCommEv|

; 1990 :     } else {
; 1991 :         // We either got an event or a SetCommMask 0.
; 1992 :         DEBUGMSG (ZONE_EVENTS,
; 1993 :                   (TEXT("-WaitCommEvent - *pfdwEventMask 0x%X\r\n"),
; 1994 :                    *pfdwEventMask));
; 1995 :         return(TRUE);

  00128	e3a00001	 mov         r0, #1
  0012c	ea000004	 b           |$LN1@WaitCommEv|
  00130		 |$LN11@WaitCommEv|

; 1924 :         SetLastError(ERROR_INVALID_HANDLE);

  00130	e3a00006	 mov         r0, #6
  00134		 |$LN31@WaitCommEv|

; 1921 :         DEBUGMSG (ZONE_ERROR|ZONE_EVENTS, (TEXT("-WaitCommEvent - device not open (x%X, %d) \r\n"),
; 1922 :                                            pHWIHead, (pHWIHead == NULL) ? 0 : pHWIHead->OpenCnt));
; 1923 :         *pfdwEventMask = 0;

  00134	e3a03000	 mov         r3, #0
  00138	e5853000	 str         r3, [r5]
  0013c		 |$LN34@WaitCommEv|

; 1924 :         SetLastError(ERROR_INVALID_HANDLE);

  0013c	eb000000	 bl          SetLastError

; 1925 :         return(FALSE);

  00140	e3a00000	 mov         r0, #0
  00144		 |$LN1@WaitCommEv|

; 1996 :     }
; 1997 : }

  00144	e24bd01c	 sub         sp, r11, #0x1C
  00148	e89d68f0	 ldmia       sp, {r4 - r7, r11, sp, lr}
  0014c	e12fff1e	 bx          lr

			 ENDP  ; |WaitCommEvent_mdd|

  00150		 |$LN16@WaitCommEv|
  00150		 |$LN36@WaitCommEv|

; 1957 :             __except(EXCEPTION_EXECUTE_HANDLER) {

  00150	e52de004	 str         lr, [sp, #-4]!
  00154		 |$LN19@WaitCommEv|
  00154		 |$LN39@WaitCommEv|
  00154	e3a00001	 mov         r0, #1
  00158		 |$LN18@WaitCommEv|
  00158	e49df004	 ldr         pc, [sp], #4
  0015c		 |$LN40@WaitCommEv|
  0015c		 |$LN38@WaitCommEv|
	EXPORT	|EvaluateEventFlag|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T41504| DCD	|$LN19@EvaluateEv|
	DCD	0x40002801
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\com_mdd2\mdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |EvaluateEventFlag| PROC

; 2023 : {

  00000		 |$LN19@EvaluateEv|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M41501|
  00004	e1a09001	 mov         r9, r1
  00008	e1a05000	 mov         r5, r0

; 2024 :     PHW_INDEP_INFO  pHWIHead = (PHW_INDEP_INFO)pHead;
; 2025 :     PLIST_ENTRY     pEntry;
; 2026 :     PHW_OPEN_INFO   pOpenHead;
; 2027 :     DWORD           dwTmpEvent, dwOrigEvent;
; 2028 :     BOOL            fRetCode;
; 2029 : 
; 2030 :     if ( !pHWIHead->OpenCnt ) {

  0000c	e5953090	 ldr         r3, [r5, #0x90]
  00010	e3530000	 cmp         r3, #0
  00014	1a000003	 bne         |$LN8@EvaluateEv|

; 2031 :         DEBUGMSG (ZONE_EVENTS|ZONE_ERROR,
; 2032 :                   (TEXT(" EvaluateEventFlag (eventMask = 0x%x) - device was closed\r\n"),fdwEventMask));
; 2033 :         SetLastError (ERROR_INVALID_HANDLE);

  00018	e3a00006	 mov         r0, #6
  0001c	eb000000	 bl          SetLastError

; 2073 :         }
; 2074 :     }
; 2075 : 
; 2076 :     return;
; 2077 : }

  00020	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$LN8@EvaluateEv|

; 2034 :         return;
; 2035 :     }
; 2036 : 
; 2037 :     DEBUGMSG (ZONE_EVENTS, (TEXT(" CommEvent - Event 0x%X, Global Mask 0x%X\r\n"),
; 2038 :                             fdwEventMask,
; 2039 :                             pHWIHead->fEventMask));
; 2040 : 
; 2041 :     // Now that we support multiple opens, we must check mask for each open handle
; 2042 :     // To keep this relatively painless, we keep a per-device mask which is the
; 2043 :     // bitwise or of each current open mask.  We can check this first before doing
; 2044 :     // all the linked list work to figure out who to notify
; 2045 :     if ( pHWIHead->fEventMask & fdwEventMask ) {

  00028	e5953098	 ldr         r3, [r5, #0x98]
  0002c	e1130009	 tst         r3, r9
  00030	0a000018	 beq         |$LN5@EvaluateEv|

; 2046 :         pEntry = pHWIHead->OpenList.Flink;
; 2047 :         while ( pEntry != &pHWIHead->OpenList ) {

  00034	e5b560e4	 ldr         r6, [r5, #0xE4]!
  00038	ea000014	 b           |$LN16@EvaluateEv|
  0003c		 |$LL6@EvaluateEv|

; 2048 :             pOpenHead = CONTAINING_RECORD( pEntry, HW_OPEN_INFO, llist);

  0003c	e2467034	 sub         r7, r6, #0x34

; 2049 :             pEntry = pEntry->Flink;  // advance to next
; 2050 : 
; 2051 :             EnterCriticalSection(&(pOpenHead->CommEvents.EventCS));

  00040	e5966000	 ldr         r6, [r6]
  00044	e2870020	 add         r0, r7, #0x20
  00048	eb000000	 bl          EnterCriticalSection

; 2052 :             // Don't do anything unless this event is of interest to the MDD.
; 2053 :             if ( pOpenHead->CommEvents.fEventMask & fdwEventMask ) {

  0004c	e5973014	 ldr         r3, [r7, #0x14]
  00050	e1130009	 tst         r3, r9
  00054	0a00000b	 beq         |$LN4@EvaluateEv|

; 2054 :                 // Store the event data
; 2055 :                 dwOrigEvent = pOpenHead->CommEvents.fEventData;

  00058	e1a08007	 mov         r8, r7
  0005c	e5b83018	 ldr         r3, [r8, #0x18]!
  00060		 |$LL3@EvaluateEv|

; 2056 :                 do {
; 2057 :                     dwTmpEvent = dwOrigEvent;
; 2058 :                     dwOrigEvent = InterlockedExchange(&(pOpenHead->CommEvents.fEventData),
; 2059 :                                                       dwTmpEvent | fdwEventMask) ;

  00060	e1831009	 orr         r1, r3, r9
  00064	e1a00008	 mov         r0, r8
  00068	e1a04003	 mov         r4, r3
  0006c	eb000000	 bl          InterlockedExchange
  00070	e1a03000	 mov         r3, r0

; 2060 : 
; 2061 :                 } while ( dwTmpEvent != dwOrigEvent );

  00074	e1540003	 cmp         r4, r3
  00078	1afffff8	 bne         |$LL3@EvaluateEv|

; 2062 : 
; 2063 :                 // Signal the MDD that new event data is available.
; 2064 :                 fRetCode = SetEvent(pOpenHead->CommEvents.hCommEvent);

  0007c	e5970010	 ldr         r0, [r7, #0x10]
  00080	e3a01003	 mov         r1, #3
  00084	eb000000	 bl          EventModify
  00088		 |$LN4@EvaluateEv|

; 2065 :                 DEBUGMSG (ZONE_EVENTS, (TEXT(" CommEvent - Event 0x%X, Handle 0x%X Mask 0x%X (%X)\r\n"),
; 2066 :                                         dwTmpEvent | fdwEventMask,
; 2067 :                                         pOpenHead,
; 2068 :                                         pOpenHead->CommEvents.fEventMask,
; 2069 :                                         fRetCode));
; 2070 : 
; 2071 :             }
; 2072 :             LeaveCriticalSection(&(pOpenHead->CommEvents.EventCS));

  00088	e2870020	 add         r0, r7, #0x20
  0008c	eb000000	 bl          LeaveCriticalSection
  00090		 |$LN16@EvaluateEv|
  00090	e1560005	 cmp         r6, r5
  00094	1affffe8	 bne         |$LL6@EvaluateEv|
  00098		 |$LN5@EvaluateEv|

; 2073 :         }
; 2074 :     }
; 2075 : 
; 2076 :     return;
; 2077 : }

  00098	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$M41502|

			 ENDP  ; |EvaluateEventFlag|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|COM_IOControl|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|memset|
	IMPORT	|__security_check_cookie|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T41588| DCD	|$LN127@COM_IOCont|
	DCD	0xc0027202

  00000			 AREA	 |.xdata|, DATA
|$T41584| DCD	0xffffffd8
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\com_mdd2\mdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T41584|

  00008		 |COM_IOControl| PROC

; 2100 : {

  00008		 |$LN127@COM_IOCont|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd074	 sub         sp, sp, #0x74
  00010		 |$M41585|
  00010	e58d3010	 str         r3, [sp, #0x10]
  00014	e1a0a002	 mov         r10, r2
  00018	e1a04001	 mov         r4, r1
  0001c	e59fe9a8	 ldr         lr, [pc, #0x9A8]
  00020	e59ee000	 ldr         lr, [lr]
  00024	e58de070	 str         lr, [sp, #0x70]
  00028	e59d7098	 ldr         r7, [sp, #0x98]
  0002c	e1b02000	 movs        r2, r0
  00030	e59d90a0	 ldr         r9, [sp, #0xA0]
  00034	e58d200c	 str         r2, [sp, #0xC]

; 2101 :     BOOL            RetVal           = TRUE;        // Initialize to success

  00038	e3a06001	 mov         r6, #1

; 2102 :     PHW_INDEP_INFO  pHWIHead; //= pOpenHead->pSerialHead;
; 2103 :     PLIST_ENTRY     pEntry;
; 2104 :     PHWOBJ          pHWObj   = NULL;
; 2105 :     PVOID           pHWHead  = NULL;
; 2106 :     PHW_VTBL        pFuncTbl = NULL;
; 2107 :     UCHAR           stopbits = 0;
; 2108 :     DWORD           dwFlags;
; 2109 : 
; 2110 :     if (pOpenHead==NULL) {
; 2111 :         SetLastError (ERROR_INVALID_HANDLE);
; 2112 :         return(FALSE);

  0003c	0a000253	 beq         |$LN92@COM_IOCont|

; 2113 :     }
; 2114 :     pHWIHead = pOpenHead->pSerialHead;

  00040	e5923000	 ldr         r3, [r2]
  00044	e1b05003	 movs        r5, r3

; 2115 :     if ( pHWIHead ) {

  00048	0a000250	 beq         |$LN92@COM_IOCont|

; 2116 :         pHWObj   = (PHWOBJ)pHWIHead->pHWObj;
; 2117 :         pFuncTbl = pHWObj->pFuncTbl;

  0004c	e5953028	 ldr         r3, [r5, #0x28]

; 2122 :     }
; 2123 : 
; 2124 :     if (((pOpenHead->AccessCode & DEVACCESS_BUSNAMESPACE)!=0) ||
; 2125 :         ((pOpenHead->ShareMode & DEVACCESS_PMEXT_MODE) != 0)){ // Special IOCTL

  00050	e5921004	 ldr         r1, [r2, #4]
  00054	e595b02c	 ldr         r11, [r5, #0x2C]
  00058	e5938008	 ldr         r8, [r3, #8]
  0005c	e3110c01	 tst         r1, #1, 24
  00060	1a000222	 bne         |$LN89@COM_IOCont|
  00064	e5923008	 ldr         r3, [r2, #8]
  00068	e3130102	 tst         r3, #2, 2
  0006c	1a00021f	 bne         |$LN89@COM_IOCont|

; 2145 :     }
; 2146 : 
; 2147 :     DEBUGMSG (ZONE_IOCTL|ZONE_FUNCTION,
; 2148 :               (TEXT("+COM_IOControl(0x%X, %d, 0x%X, %d, 0x%X, %d, 0x%X)\r\n"),
; 2149 :                pOpenHead, dwCode, pBufIn, dwLenIn, pBufOut,
; 2150 :                dwLenOut, pdwActualOut));
; 2151 : 
; 2152 :     if ( !pHWIHead->OpenCnt ) {

  00070	e5953090	 ldr         r3, [r5, #0x90]
  00074	e3530000	 cmp         r3, #0

; 2153 :         DEBUGMSG (ZONE_IOCTL|ZONE_ERROR,
; 2154 :                   (TEXT(" COM_IOControl - device was closed\r\n")));
; 2155 :         SetLastError (ERROR_INVALID_HANDLE);
; 2156 :         return(FALSE);

  00078	0a000244	 beq         |$LN92@COM_IOCont|

; 2157 :     }
; 2158 : 
; 2159 :     if ( dwCode == IOCTL_PSL_NOTIFY ) {

  0007c	e59f3944	 ldr         r3, [pc, #0x944]
  00080	e1540003	 cmp         r4, r3
  00084	1a000009	 bne         |$LN81@COM_IOCont|

; 2160 :         PDEVICE_PSL_NOTIFY pPslPacket = (PDEVICE_PSL_NOTIFY)pBufIn;
; 2161 :         if ( (pPslPacket->dwSize == sizeof(DEVICE_PSL_NOTIFY)) && (pPslPacket->dwFlags == DLL_PROCESS_EXITING) ) {

  00088	e59a3000	 ldr         r3, [r10]
  0008c	e3530010	 cmp         r3, #0x10
  00090	059a3004	 ldreq       r3, [r10, #4]
  00094	03530004	 cmpeq       r3, #4

; 2162 :             DEBUGMSG(ZONE_IOCTL, (TEXT("Process is exiting.\r\n")));
; 2163 :             ProcessExiting(pOpenHead);

  00098	01a00002	 moveq       r0, r2
  0009c	0b000000	 bleq        ProcessExiting

; 2164 :         }
; 2165 :         return (TRUE);

  000a0	e59d0070	 ldr         r0, [sp, #0x70]
  000a4	eb000000	 bl          __security_check_cookie
  000a8	e3a06001	 mov         r6, #1
  000ac	ea00023c	 b           |$LN94@COM_IOCont|
  000b0		 |$LN81@COM_IOCont|

; 2166 :     }
; 2167 :     // Make sure the caller has access permissions
; 2168 :     // NOTE : Pay attention here.  I hate to make this check repeatedly
; 2169 :     // below, so I'll optimize it here.  But as you add new ioctl's be
; 2170 :     // sure to account for them in this if check.
; 2171 :     if ( !( (dwCode == IOCTL_SERIAL_GET_WAIT_MASK) ||
; 2172 :             (dwCode == IOCTL_SERIAL_SET_WAIT_MASK) ||
; 2173 :             (dwCode == IOCTL_SERIAL_WAIT_ON_MASK) ||
; 2174 :             (dwCode == IOCTL_SERIAL_GET_MODEMSTATUS) ||
; 2175 :             (dwCode == IOCTL_SERIAL_GET_PROPERTIES) ||
; 2176 :             (dwCode == IOCTL_SERIAL_GET_TIMEOUTS) ||
; 2177 :             (dwCode == IOCTL_POWER_CAPABILITIES) ||
; 2178 :             (dwCode == IOCTL_POWER_QUERY) ||
; 2179 :             (dwCode == IOCTL_POWER_SET) ||
; 2180 :             (dwCode == IOCTL_CONTEXT_RESTORE) ) ) {

  000b0	e3a0e81b	 mov         lr, #0x1B, 16
  000b4	e38e3024	 orr         r3, lr, #0x24
  000b8	e1540003	 cmp         r4, r3
  000bc	e38e3034	 orr         r3, lr, #0x34
  000c0	e38e0038	 orr         r0, lr, #0x38
  000c4	e38ee040	 orr         lr, lr, #0x40
  000c8	0a000021	 beq         |$LN78@COM_IOCont|
  000cc	e3a0281b	 mov         r2, #0x1B, 16
  000d0	e3821028	 orr         r1, r2, #0x28
  000d4	e59d200c	 ldr         r2, [sp, #0xC]
  000d8	e1540001	 cmp         r4, r1
  000dc	e5921004	 ldr         r1, [r2, #4]
  000e0	0a00001b	 beq         |$LN78@COM_IOCont|
  000e4	e3a0181b	 mov         r1, #0x1B, 16
  000e8	e381202c	 orr         r2, r1, #0x2C
  000ec	e1540002	 cmp         r4, r2
  000f0	e59d200c	 ldr         r2, [sp, #0xC]
  000f4	e5921004	 ldr         r1, [r2, #4]
  000f8	0a000015	 beq         |$LN78@COM_IOCont|
  000fc	e1540003	 cmp         r4, r3
  00100	0a000013	 beq         |$LN78@COM_IOCont|
  00104	e1540000	 cmp         r4, r0
  00108	0a000011	 beq         |$LN78@COM_IOCont|
  0010c	e154000e	 cmp         r4, lr
  00110	0a00000f	 beq         |$LN78@COM_IOCont|
  00114	e3a03832	 mov         r3, #0x32, 16
  00118	e3833a01	 orr         r3, r3, #1, 20
  0011c	e1540003	 cmp         r4, r3
  00120	0a00000b	 beq         |$LN78@COM_IOCont|
  00124	e59f3890	 ldr         r3, [pc, #0x890]
  00128	e1540003	 cmp         r4, r3
  0012c	0a000008	 beq         |$LN78@COM_IOCont|
  00130	e59f3888	 ldr         r3, [pc, #0x888]
  00134	e1540003	 cmp         r4, r3
  00138	0a000005	 beq         |$LN78@COM_IOCont|
  0013c	e59f3870	 ldr         r3, [pc, #0x870]
  00140	e1540003	 cmp         r4, r3
  00144	0a000002	 beq         |$LN78@COM_IOCont|

; 2181 :         // If not one of the above operations, then read or write
; 2182 :         // access permissions are required.
; 2183 :         if ( !(pOpenHead->AccessCode & (GENERIC_READ | GENERIC_WRITE) ) ) {

  00148	e3110103	 tst         r1, #3, 2

; 2184 :             DEBUGMSG(ZONE_IOCTL|ZONE_ERROR,
; 2185 :                      (TEXT("COM_Ioctl: Ioctl %x access permission failure x%X\n\r"),
; 2186 :                       dwCode, pOpenHead->AccessCode));
; 2187 :             SetLastError (ERROR_INVALID_ACCESS);

  0014c	03a0000c	 moveq       r0, #0xC
  00150	0a00020f	 beq         |$LN117@COM_IOCont|
  00154		 |$LN78@COM_IOCont|

; 2188 :             return(FALSE);
; 2189 :         }
; 2190 : 
; 2191 :     }
; 2192 : 
; 2193 :     COM_INC_USAGE_CNT(pOpenHead);

  00154	e282000c	 add         r0, r2, #0xC
  00158	eb000000	 bl          InterlockedIncrement

; 2194 : 
; 2195 :     switch ( dwCode ) {

  0015c	e3a0381b	 mov         r3, #0x1B, 16
  00160	e3833030	 orr         r3, r3, #0x30
  00164	e1540003	 cmp         r4, r3
  00168	8a0000cd	 bhi         |$LN96@COM_IOCont|
  0016c	0a0000a1	 beq         |$LN43@COM_IOCont|
  00170	e3a0381b	 mov         r3, #0x1B, 16
  00174	e3833018	 orr         r3, r3, #0x18
  00178	e1540003	 cmp         r4, r3
  0017c	8a000042	 bhi         |$LN97@COM_IOCont|
  00180	0a000038	 beq         |$LN64@COM_IOCont|
  00184	e3a0381b	 mov         r3, #0x1B, 16
  00188	e3833004	 orr         r3, r3, #4
  0018c	e1540003	 cmp         r4, r3
  00190	0a00002f	 beq         |$LN75@COM_IOCont|
  00194	e3a0381b	 mov         r3, #0x1B, 16
  00198	e3833008	 orr         r3, r3, #8
  0019c	e1540003	 cmp         r4, r3
  001a0	0a000026	 beq         |$LN74@COM_IOCont|
  001a4	e3a0381b	 mov         r3, #0x1B, 16
  001a8	e383300c	 orr         r3, r3, #0xC
  001ac	e1540003	 cmp         r4, r3
  001b0	0a000019	 beq         |$LN73@COM_IOCont|
  001b4	e3a0381b	 mov         r3, #0x1B, 16
  001b8	e3833010	 orr         r3, r3, #0x10
  001bc	e1540003	 cmp         r4, r3
  001c0	0a00000c	 beq         |$LN70@COM_IOCont|
  001c4	e3a0381b	 mov         r3, #0x1B, 16
  001c8	e3833014	 orr         r3, r3, #0x14
  001cc	e1540003	 cmp         r4, r3
  001d0	1a00017a	 bne         |$LN3@COM_IOCont|

; 2301 :             SetLastError (ERROR_INVALID_PARAMETER);
; 2302 :             RetVal = FALSE;
; 2303 :         }
; 2304 :         break;
; 2305 : 
; 2306 :         // ****************************************************************
; 2307 :         //
; 2308 :         //      @func   BOOL | IOCTL_SERIAL_SET_RTS |
; 2309 :         //                              Device IO control routine to set RTS high.
; 2310 :         //
; 2311 :         //      @parm DWORD | dwOpenData | value returned from COM_Open call
; 2312 :         //      @parm DWORD | dwCode | IOCTL_SERIAL_SET_RTS
; 2313 :         //      @parm PBYTE | pBufIn | Ignored
; 2314 :         //      @parm DWORD | dwLenIn | Ignored
; 2315 :         //      @parm PBYTE | pBufOut | Ignored
; 2316 :         //      @parm DWORD | dwLenOut | Ignored
; 2317 :         //      @parm PDWORD | pdwActualOut | Ignored
; 2318 :         //
; 2319 :         //      @rdesc          Returns TRUE for success, FALSE for failure (and
; 2320 :         //                              sets thread error code)
; 2321 :         //
; 2322 :         //      @xref           <f IOCTL_SERIAL_CLR_RTS>
; 2323 :         //
; 2324 :     case IOCTL_SERIAL_SET_RTS :
; 2325 :         DEBUGMSG (ZONE_IOCTL, (TEXT(" IOCTL_SERIAL_SET_RTS\r\n")));
; 2326 :         /* It's an error to call this if DCB uses RTS_CONTROL_HANDSHAKE.
; 2327 :          */
; 2328 :         if ( pHWIHead->DCB.fRtsControl != RTS_CONTROL_HANDSHAKE ) {

  001d4	e5953068	 ldr         r3, [r5, #0x68]
  001d8	e2033a03	 and         r3, r3, #3, 20
  001dc	e3530a02	 cmp         r3, #2, 20
  001e0	0a000185	 beq         |$LN15@COM_IOCont|

; 2329 :             pFuncTbl->HWSetRTS(pHWHead);

  001e4	e5983040	 ldr         r3, [r8, #0x40]
  001e8	e1a0000b	 mov         r0, r11
  001ec	e1a0e00f	 mov         lr, pc
  001f0	e12fff13	 bx          r3

; 2330 :         } else {
; 2331 :             SetLastError (ERROR_INVALID_PARAMETER);
; 2332 :             RetVal = FALSE;
; 2333 :         }
; 2334 :         break;

  001f4	ea000183	 b           |$LN116@COM_IOCont|
  001f8		 |$LN70@COM_IOCont|

; 2271 :             SetLastError (ERROR_INVALID_PARAMETER);
; 2272 :             RetVal = FALSE;
; 2273 :         }
; 2274 :         break;
; 2275 : 
; 2276 :         // ****************************************************************
; 2277 :         //
; 2278 :         //      @func BOOL      | IOCTL_SERIAL_CLR_DTR |
; 2279 :         //                              Device IO control routine to set DTR low.
; 2280 :         //
; 2281 :         //      @parm DWORD | dwOpenData | value returned from COM_Open call
; 2282 :         //      @parm DWORD | dwCode | IOCTL_SERIAL_CLR_DTR
; 2283 :         //      @parm PBYTE | pBufIn | Ignored
; 2284 :         //      @parm DWORD | dwLenIn | Ignored
; 2285 :         //      @parm PBYTE | pBufOut | Ignored
; 2286 :         //      @parm DWORD | dwLenOut | Ignored
; 2287 :         //      @parm PDWORD | pdwActualOut | Ignored
; 2288 :         //
; 2289 :         //      @rdesc          Returns TRUE for success, FALSE for failure (and
; 2290 :         //                              sets thread error code)
; 2291 :         //
; 2292 :         //      @xref           <f IOCTL_SERIAL_SET_DTR>
; 2293 :         //
; 2294 :     case IOCTL_SERIAL_CLR_DTR :
; 2295 :         DEBUGMSG (ZONE_IOCTL, (TEXT(" IOCTL_SERIAL_CLR_DTR\r\n")));
; 2296 :         /* It's an error to call this if DCB uses DTR_CONTROL_HANDSHAKE.
; 2297 :          */
; 2298 :         if ( pHWIHead->DCB.fDtrControl != DTR_CONTROL_HANDSHAKE ) {

  001f8	e5953068	 ldr         r3, [r5, #0x68]
  001fc	e2033030	 and         r3, r3, #0x30
  00200	e3530020	 cmp         r3, #0x20
  00204	0a00017c	 beq         |$LN15@COM_IOCont|

; 2299 :             pFuncTbl->HWClearDTR(pHWHead);

  00208	e5983034	 ldr         r3, [r8, #0x34]
  0020c	e1a0000b	 mov         r0, r11
  00210	e1a0e00f	 mov         lr, pc
  00214	e12fff13	 bx          r3

; 2300 :         } else {

  00218	ea00017a	 b           |$LN116@COM_IOCont|
  0021c		 |$LN73@COM_IOCont|

; 2245 : 
; 2246 :         // ****************************************************************
; 2247 :         //
; 2248 :         //      @func BOOL      | IOCTL_SERIAL_SET_DTR |
; 2249 :         //                              Device IO control routine to set DTR high.
; 2250 :         //
; 2251 :         //      @parm DWORD | dwOpenData | value returned from COM_Open call
; 2252 :         //      @parm DWORD | dwCode | IOCTL_SERIAL_SET_DTR
; 2253 :         //      @parm PBYTE | pBufIn | Ignored
; 2254 :         //      @parm DWORD | dwLenIn | Ignored
; 2255 :         //      @parm PBYTE | pBufOut | Ignored
; 2256 :         //      @parm DWORD | dwLenOut | Ignored
; 2257 :         //      @parm PDWORD | pdwActualOut | Ignored
; 2258 :         //
; 2259 :         //      @rdesc          Returns TRUE for success, FALSE for failure (and
; 2260 :         //                              sets thread error code)
; 2261 :         //
; 2262 :         //      @xref           <f IOCTL_SERIAL_CLR_DTR>
; 2263 :         //
; 2264 :     case IOCTL_SERIAL_SET_DTR :
; 2265 :         DEBUGMSG (ZONE_IOCTL, (TEXT(" IOCTL_SERIAL_SET_DTR\r\n")));
; 2266 :         /* It's an error to call this if DCB uses DTR_CONTROL_HANDSHAKE.
; 2267 :          */
; 2268 :         if ( pHWIHead->DCB.fDtrControl != DTR_CONTROL_HANDSHAKE ) {

  0021c	e5953068	 ldr         r3, [r5, #0x68]
  00220	e2033030	 and         r3, r3, #0x30
  00224	e3530020	 cmp         r3, #0x20
  00228	0a000173	 beq         |$LN15@COM_IOCont|

; 2269 :             pFuncTbl->HWSetDTR(pHWHead);

  0022c	e5983038	 ldr         r3, [r8, #0x38]
  00230	e1a0000b	 mov         r0, r11
  00234	e1a0e00f	 mov         lr, pc
  00238	e12fff13	 bx          r3

; 2270 :         } else {

  0023c	ea000171	 b           |$LN116@COM_IOCont|
  00240		 |$LN74@COM_IOCont|

; 2220 : 
; 2221 :         // ****************************************************************
; 2222 :         //
; 2223 :         //      @func BOOL      | IOCTL_SERIAL_SET_BREAK_OFF |
; 2224 :         //                              Device IO control routine to clear the break state.
; 2225 :         //
; 2226 :         //      @parm DWORD | dwOpenData | value returned from COM_Open call
; 2227 :         //      @parm DWORD | dwCode | IOCTL_SERIAL_SET_BREAK_OFF
; 2228 :         //      @parm PBYTE | pBufIn | Ignored
; 2229 :         //      @parm DWORD | dwLenIn | Ignored
; 2230 :         //      @parm PBYTE | pBufOut | Ignored
; 2231 :         //      @parm DWORD | dwLenOut | Ignored
; 2232 :         //      @parm PDWORD | pdwActualOut | Ignored
; 2233 :         //
; 2234 :         //      @rdesc          Returns TRUE for success, FALSE for failure (and
; 2235 :         //                              sets thread error code)
; 2236 :         //
; 2237 :         //      @remark         Restores character transmission for the communications
; 2238 :         //                              device and places the transmission line in a nonbreak state
; 2239 :         //                              (called after <f IOCTL_SERIAL_SET_BREAK_ON>).
; 2240 :         //
; 2241 :     case IOCTL_SERIAL_SET_BREAK_OFF :
; 2242 :         DEBUGMSG (ZONE_IOCTL, (TEXT(" IOCTL_SERIAL_SET_BREAK_OFF\r\n")));
; 2243 :         pFuncTbl->HWClearBreak(pHWHead);

  00240	e598304c	 ldr         r3, [r8, #0x4C]
  00244	e1a0000b	 mov         r0, r11
  00248	e1a0e00f	 mov         lr, pc
  0024c	e12fff13	 bx          r3

; 2244 :         break;

  00250	ea00016c	 b           |$LN116@COM_IOCont|
  00254		 |$LN75@COM_IOCont|

; 2196 :     // ****************************************************************
; 2197 :     //
; 2198 :     //  @func BOOL      | IOCTL_SERIAL_SET_BREAK_ON |
; 2199 :     //                          Device IO control routine to set the break state.
; 2200 :     //
; 2201 :     //  @parm DWORD | dwOpenData | value returned from COM_Open call
; 2202 :     //  @parm DWORD | dwCode | IOCTL_SERIAL_SET_BREAK_ON
; 2203 :     //  @parm PBYTE | pBufIn | Ignored
; 2204 :     //  @parm DWORD | dwLenIn | Ignored
; 2205 :     //  @parm PBYTE | pBufOut | Ignored
; 2206 :     //  @parm DWORD | dwLenOut | Ignored
; 2207 :     //  @parm PDWORD | pdwActualOut | Ignored
; 2208 :     //
; 2209 :     //  @rdesc          Returns TRUE for success, FALSE for failure (and
; 2210 :     //                          sets thread error code)
; 2211 :     //
; 2212 :     //  @remark Sets the transmission line in a break state until
; 2213 :     //                          <f IOCTL_SERIAL_SET_BREAK_OFF> is called.
; 2214 :     //
; 2215 :     case IOCTL_SERIAL_SET_BREAK_ON :
; 2216 :         DEBUGMSG (ZONE_IOCTL,
; 2217 :                   (TEXT(" IOCTL_SERIAL_SET_BREAK_ON\r\n")));
; 2218 :         pFuncTbl->HWSetBreak(pHWHead);

  00254	e5983050	 ldr         r3, [r8, #0x50]
  00258	e1a0000b	 mov         r0, r11
  0025c	e1a0e00f	 mov         lr, pc
  00260	e12fff13	 bx          r3

; 2219 :         break;

  00264	ea000167	 b           |$LN116@COM_IOCont|
  00268		 |$LN64@COM_IOCont|

; 2335 : 
; 2336 :         // ****************************************************************
; 2337 :         //
; 2338 :         //      @func   BOOL | IOCTL_SERIAL_CLR_RTS |
; 2339 :         //                              Device IO control routine to set RTS low.
; 2340 :         //
; 2341 :         //      @parm DWORD | dwOpenData | value returned from COM_Open call
; 2342 :         //      @parm DWORD | dwCode | IOCTL_SERIAL_CLR_RTS
; 2343 :         //      @parm PBYTE | pBufIn | Ignored
; 2344 :         //      @parm DWORD | dwLenIn | Ignored
; 2345 :         //      @parm PBYTE | pBufOut | Ignored
; 2346 :         //      @parm DWORD | dwLenOut | Ignored
; 2347 :         //      @parm PDWORD | pdwActualOut | Ignored
; 2348 :         //
; 2349 :         //      @rdesc          Returns TRUE for success, FALSE for failure (and
; 2350 :         //                              sets thread error code)
; 2351 :         //
; 2352 :         //      @xref           <f IOCTL_SERIAL_SET_RTS>
; 2353 :         //
; 2354 :     case IOCTL_SERIAL_CLR_RTS :
; 2355 :         DEBUGMSG (ZONE_IOCTL, (TEXT(" IOCTL_SERIAL_CLR_RTS\r\n")));
; 2356 :         /* It's an error to call this if DCB uses RTS_CONTROL_HANDSHAKE.
; 2357 :          */
; 2358 :         if ( pHWIHead->DCB.fRtsControl != RTS_CONTROL_HANDSHAKE ) {

  00268	e5953068	 ldr         r3, [r5, #0x68]
  0026c	e2033a03	 and         r3, r3, #3, 20
  00270	e3530a02	 cmp         r3, #2, 20
  00274	0a000160	 beq         |$LN15@COM_IOCont|

; 2359 :             pFuncTbl->HWClearRTS(pHWHead);

  00278	e598303c	 ldr         r3, [r8, #0x3C]
  0027c	e1a0000b	 mov         r0, r11
  00280	e1a0e00f	 mov         lr, pc
  00284	e12fff13	 bx          r3

; 2360 :         } else {

  00288	ea00015e	 b           |$LN116@COM_IOCont|
  0028c		 |$LN97@COM_IOCont|

; 2361 :             SetLastError (ERROR_INVALID_PARAMETER);
; 2362 :             RetVal = FALSE;
; 2363 :         }
; 2364 :         break;

  0028c	e3a0381b	 mov         r3, #0x1B, 16
  00290	e383301c	 orr         r3, r3, #0x1C
  00294	e1540003	 cmp         r4, r3
  00298	0a00004f	 beq         |$LN61@COM_IOCont|
  0029c	e3a0381b	 mov         r3, #0x1B, 16
  002a0	e3833020	 orr         r3, r3, #0x20
  002a4	e1540003	 cmp         r4, r3
  002a8	0a000045	 beq         |$LN59@COM_IOCont|
  002ac	e3a0281b	 mov         r2, #0x1B, 16
  002b0	e3823024	 orr         r3, r2, #0x24
  002b4	e1540003	 cmp         r4, r3
  002b8	0a000034	 beq         |$LN57@COM_IOCont|
  002bc	e3823028	 orr         r3, r2, #0x28
  002c0	e1540003	 cmp         r4, r3
  002c4	0a000014	 beq         |$LN54@COM_IOCont|
  002c8	e382302c	 orr         r3, r2, #0x2C
  002cc	e1540003	 cmp         r4, r3
  002d0	1a00013a	 bne         |$LN3@COM_IOCont|

; 2520 : 
; 2521 :         // ****************************************************************
; 2522 :         //
; 2523 :         //      @func BOOL      | IOCTL_SERIAL_WAIT_ON_MASK |
; 2524 :         //                              Device IO control routine to wait for a communications
; 2525 :         //                              event that matches one in the event mask
; 2526 :         //
; 2527 :         //      @parm DWORD | dwOpenData | value returned from COM_Open call
; 2528 :         //      @parm DWORD | dwCode | IOCTL_SERIAL_WAIT_ON_MASK
; 2529 :         //      @parm PBYTE | pBufIn | Ignored
; 2530 :         //      @parm DWORD | dwLenIn | Ignored
; 2531 :         //      @parm PBYTE | pBufOut | Points to DWORD to place event mask.
; 2532 :         //                              The returned mask will show the event that terminated
; 2533 :         //                              the wait.  If a process attempts to change the device
; 2534 :         //                              handle's event mask by using the IOCTL_SERIAL_SET_WAIT_MASK
; 2535 :         //                              call the driver should return immediately with (DWORD)0 as
; 2536 :         //                              the returned event mask.
; 2537 :         //      @parm DWORD | dwLenOut | should be sizeof(DWORD) or larger
; 2538 :         //      @parm PDWORD | pdwActualOut | Points to DWORD to return length
; 2539 :         //                              of returned data (should be set to sizeof(DWORD) if no
; 2540 :         //                              error)
; 2541 :         //
; 2542 :         //      @rdesc          Returns TRUE for success, FALSE for failure (and
; 2543 :         //                              sets thread error code)
; 2544 :         //
; 2545 :         //      @xref           <f IOCTL_SERIAL_GET_WAIT_MASK>
; 2546 :         //                              <f IOCTL_SERIAL_SET_WAIT_MASK>
; 2547 :         //
; 2548 :     case IOCTL_SERIAL_WAIT_ON_MASK :
; 2549 :         DEBUGMSG (ZONE_IOCTL, (TEXT(" IOCTL_SERIAL_WAIT_ON_MASK\r\n")));
; 2550 :         if ( (dwLenOut < sizeof(DWORD)) || (NULL == pBufOut) ||
; 2551 :              (NULL == pdwActualOut) ) {

  002d4	e59d309c	 ldr         r3, [sp, #0x9C]
  002d8	e3530004	 cmp         r3, #4
  002dc	3a000146	 bcc         |$LN15@COM_IOCont|
  002e0	e3570000	 cmp         r7, #0
  002e4	0a000144	 beq         |$LN15@COM_IOCont|
  002e8	e3590000	 cmp         r9, #0
  002ec	0a000142	 beq         |$LN15@COM_IOCont|

; 2552 :             SetLastError (ERROR_INVALID_PARAMETER);
; 2553 :             RetVal = FALSE;
; 2554 :             DEBUGMSG (ZONE_IOCTL, (TEXT(" Invalid parameter\r\n")));
; 2555 :             break;
; 2556 :         }
; 2557 :         else {
; 2558 :             DWORD dwFlagEventMask = 0;
; 2559 :             if ( WaitCommEvent_mdd(pOpenHead, &dwFlagEventMask, NULL) == FALSE ) {

  002f0	e59d800c	 ldr         r8, [sp, #0xC]
  002f4	e3a03000	 mov         r3, #0
  002f8	e3a02000	 mov         r2, #0
  002fc	e1a00008	 mov         r0, r8
  00300	e28d1010	 add         r1, sp, #0x10
  00304	e58d3010	 str         r3, [sp, #0x10]
  00308	eb000000	 bl          WaitCommEvent_mdd
  0030c	e3500000	 cmp         r0, #0

; 2560 :                 // Device may have been closed or removed while we were waiting
; 2561 :                 DEBUGMSG (ZONE_IOCTL|ZONE_ERROR,
; 2562 :                           (TEXT(" COM_IOControl - Error in WaitCommEvent\r\n")));
; 2563 :                 RetVal = FALSE;
; 2564 :             }
; 2565 :             *((DWORD *)pBufOut)= dwFlagEventMask;

  00310	e59d3010	 ldr         r3, [sp, #0x10]
  00314	03a06000	 moveq       r6, #0

; 2566 :             // Return the size
; 2567 :             *pdwActualOut = sizeof(DWORD);
; 2568 : 
; 2569 :         }
; 2570 :         break;

  00318	ea000025	 b           |$LN121@COM_IOCont|
  0031c		 |$LN54@COM_IOCont|

; 2456 : 
; 2457 :         // ****************************************************************
; 2458 :         //
; 2459 :         //      @func BOOL      | IOCTL_SERIAL_SET_WAIT_MASK |
; 2460 :         //                              Device IO control routine to set the value
; 2461 :         //                              of the event mask.
; 2462 :         //
; 2463 :         //      @parm DWORD | dwOpenData | value returned from COM_Open call
; 2464 :         //      @parm DWORD | dwCode | IOCTL_SERIAL_SET_WAIT_MASK
; 2465 :         //      @parm PBYTE | pBufIn | Pointer to the DWORD mask value
; 2466 :         //      @parm DWORD | dwLenIn | should be sizeof(DWORD)
; 2467 :         //      @parm PBYTE | pBufOut | Ignored
; 2468 :         //      @parm DWORD | dwLenOut | Ignored
; 2469 :         //      @parm PDWORD | pdwActualOut | Ignored
; 2470 :         //
; 2471 :         //      @rdesc          Returns TRUE for success, FALSE for failure (and
; 2472 :         //                              sets thread error code)
; 2473 :         //
; 2474 :         //      @xref           <f IOCTL_SERIAL_GET_WAIT_MASK>
; 2475 :         //                              <f IOCTL_SERIAL_WAIT_ON_MASK>
; 2476 :         //
; 2477 :     case IOCTL_SERIAL_SET_WAIT_MASK :
; 2478 :         if ( (dwLenIn < sizeof(DWORD)) || (NULL == pBufIn) ) {

  0031c	e59d3010	 ldr         r3, [sp, #0x10]
  00320	e3530004	 cmp         r3, #4
  00324	3a000134	 bcc         |$LN15@COM_IOCont|
  00328	e35a0000	 cmp         r10, #0
  0032c	0a000132	 beq         |$LN15@COM_IOCont|

; 2479 :             SetLastError (ERROR_INVALID_PARAMETER);
; 2480 :             RetVal = FALSE;
; 2481 :             DEBUGMSG (ZONE_IOCTL, (TEXT(" Invalid parameter\r\n")));
; 2482 :             break;
; 2483 :         }
; 2484 :         else {
; 2485 :             DWORD dwFlagEventMask = 0;
; 2486 :             dwFlagEventMask = *(DWORD *)pBufIn;
; 2487 :             DEBUGMSG (ZONE_IOCTL, (TEXT(" IOCTL_SERIAL_SET_WAIT_MASK 0x%X\r\n"),dwFlagEventMask));
; 2488 :             EnterCriticalSection(&(pOpenHead->CommEvents.EventCS));

  00330	e59d800c	 ldr         r8, [sp, #0xC]
  00334	e59a4000	 ldr         r4, [r10]
  00338	e2880020	 add         r0, r8, #0x20
  0033c	eb000000	 bl          EnterCriticalSection

; 2489 :             // OK, now we can actually set the mask
; 2490 :             pOpenHead->CommEvents.fEventMask = dwFlagEventMask;
; 2491 : 
; 2492 :             // NOTE: If there is an outstanding WaitCommEvent, it should
; 2493 :             // return an error when SET_WAIT_MASK is called.  We accomplish
; 2494 :             // this by generating an hCommEvent which will wake the WaitComm
; 2495 :             // and subsequently return error (since no event bits will be set )
; 2496 :             pOpenHead->CommEvents.fAbort = 1;
; 2497 :             SetEvent(pOpenHead->CommEvents.hCommEvent);

  00340	e5980010	 ldr         r0, [r8, #0x10]
  00344	e3a03001	 mov         r3, #1
  00348	e3a01003	 mov         r1, #3
  0034c	e5884014	 str         r4, [r8, #0x14]
  00350	e588301c	 str         r3, [r8, #0x1C]
  00354	eb000000	 bl          EventModify

; 2498 : 
; 2499 :             // And calculate the OR of all masks for this port.  Use a temp
; 2500 :             // variable so that the other threads don't see a partial mask
; 2501 :             dwFlags = 0;
; 2502 :             pEntry = pHWIHead->OpenList.Flink;
; 2503 :             while ( pEntry != &pHWIHead->OpenList ) {

  00358	e1a00005	 mov         r0, r5
  0035c	e5b020e4	 ldr         r2, [r0, #0xE4]!
  00360	e3a01000	 mov         r1, #0
  00364	ea000003	 b           |$LN118@COM_IOCont|
  00368		 |$LL50@COM_IOCont|

; 2504 :                 PHW_OPEN_INFO   pTmpOpenHead;
; 2505 : 
; 2506 :                 pTmpOpenHead = CONTAINING_RECORD( pEntry, HW_OPEN_INFO, llist);

  00368	e2423034	 sub         r3, r2, #0x34

; 2507 :                 pEntry = pEntry->Flink;    // advance to next
; 2508 : 
; 2509 :                 DEBUGMSG (ZONE_EVENTS, (TEXT(" SetWaitMask - handle x%X mask x%X\r\n"),
; 2510 :                                         pTmpOpenHead, pTmpOpenHead->CommEvents.fEventMask));
; 2511 :                 dwFlags |= pTmpOpenHead->CommEvents.fEventMask;

  0036c	e5933014	 ldr         r3, [r3, #0x14]
  00370	e5922000	 ldr         r2, [r2]
  00374	e1831001	 orr         r1, r3, r1
  00378		 |$LN118@COM_IOCont|
  00378	e1520000	 cmp         r2, r0
  0037c	1afffff9	 bne         |$LL50@COM_IOCont|

; 2512 :             }
; 2513 :             pHWIHead->fEventMask = dwFlags;
; 2514 :             LeaveCriticalSection(&(pOpenHead->CommEvents.EventCS));

  00380	e2880020	 add         r0, r8, #0x20
  00384	e5851098	 str         r1, [r5, #0x98]
  00388	eb000000	 bl          LeaveCriticalSection

; 2515 :             DEBUGMSG (ZONE_EVENTS, (TEXT(" SetWaitMask - mask x%X, global mask x%X\r\n"),
; 2516 :                                     pOpenHead->CommEvents.fEventMask, pHWIHead->fEventMask));
; 2517 : 
; 2518 :         }
; 2519 :         break;

  0038c	ea00011e	 b           |$LN76@COM_IOCont|
  00390		 |$LN57@COM_IOCont|

; 2419 : 
; 2420 :         // ****************************************************************
; 2421 :         //
; 2422 :         //      @func           BOOL | IOCTL_SERIAL_GET_WAIT_MASK |
; 2423 :         //                              Device IO control routine to retrieve the value
; 2424 :         //                              of the event mask.
; 2425 :         //
; 2426 :         //      @parm DWORD | dwOpenData | value returned from COM_Open call
; 2427 :         //      @parm DWORD | dwCode | IOCTL_SERIAL_GET_WAIT_MASK
; 2428 :         //      @parm PBYTE | pBufIn | Ignored
; 2429 :         //      @parm DWORD | dwLenIn | Ignored
; 2430 :         //      @parm PBYTE | pBufOut | Points to DWORD to place event mask
; 2431 :         //      @parm DWORD | dwLenOut | should be sizeof(DWORD) or larger
; 2432 :         //      @parm PDWORD | pdwActualOut | Points to DWORD to return length
; 2433 :         //                              of returned data (should be set to sizeof(DWORD) if no
; 2434 :         //                              error)
; 2435 :         //
; 2436 :         //      @rdesc          Returns TRUE for success, FALSE for failure (and
; 2437 :         //                              sets thread error code)
; 2438 :         //
; 2439 :         //      @xref           <f IOCTL_SERIAL_SET_WAIT_MASK>
; 2440 :         //                              <f IOCTL_SERIAL_WAIT_ON_MASK>
; 2441 :         //
; 2442 :     case IOCTL_SERIAL_GET_WAIT_MASK :
; 2443 :         DEBUGMSG (ZONE_IOCTL, (TEXT(" IOCTL_SERIAL_GET_WAIT_MASK\r\n")));
; 2444 :         if ( (dwLenOut < sizeof(DWORD)) || (NULL == pBufOut) ||
; 2445 :              (NULL == pdwActualOut) ) {

  00390	e59d309c	 ldr         r3, [sp, #0x9C]
  00394	e3530004	 cmp         r3, #4
  00398	3a000117	 bcc         |$LN15@COM_IOCont|
  0039c	e3570000	 cmp         r7, #0
  003a0	0a000115	 beq         |$LN15@COM_IOCont|
  003a4	e3590000	 cmp         r9, #0
  003a8	0a000113	 beq         |$LN15@COM_IOCont|

; 2446 :             SetLastError (ERROR_INVALID_PARAMETER);
; 2447 :             RetVal = FALSE;
; 2448 :             DEBUGMSG (ZONE_IOCTL, (TEXT(" Invalid parameter\r\n")));
; 2449 :             break;
; 2450 :         }
; 2451 :         // Set The Wait Mask
; 2452 :         *(DWORD *)pBufOut = pOpenHead->CommEvents.fEventMask;

  003ac	e59d800c	 ldr         r8, [sp, #0xC]
  003b0	e5983014	 ldr         r3, [r8, #0x14]
  003b4		 |$LN121@COM_IOCont|

; 2453 :         // Return the size
; 2454 :         *pdwActualOut = sizeof(DWORD);

  003b4	e3a02004	 mov         r2, #4
  003b8	e5873000	 str         r3, [r7]
  003bc	e5892000	 str         r2, [r9]

; 2455 :         break;

  003c0	ea000111	 b           |$LN76@COM_IOCont|
  003c4		 |$LN59@COM_IOCont|

; 2392 : 
; 2393 :         // ****************************************************************
; 2394 :         //
; 2395 :         //      @func BOOL      | IOCTL_SERIAL_SET_XON |
; 2396 :         //                              Device IO control routine to cause transmission
; 2397 :         //                              to act as if an XON character has been received.
; 2398 :         //
; 2399 :         //      @parm DWORD | dwOpenData | value returned from COM_Open call
; 2400 :         //      @parm DWORD | dwCode | IOCTL_SERIAL_SET_XON
; 2401 :         //      @parm PBYTE | pBufIn | Ignored
; 2402 :         //      @parm DWORD | dwLenIn | Ignored
; 2403 :         //      @parm PBYTE | pBufOut | Ignored
; 2404 :         //      @parm DWORD | dwLenOut | Ignored
; 2405 :         //      @parm PDWORD | pdwActualOut | Ignored
; 2406 :         //
; 2407 :         //      @rdesc          Returns TRUE for success, FALSE for failure (and
; 2408 :         //                              sets thread error code)
; 2409 :         //
; 2410 :         //      @xref           <f IOCTL_SERIAL_SET_XOFF>
; 2411 :         //
; 2412 :     case IOCTL_SERIAL_SET_XON :
; 2413 :         DEBUGMSG (ZONE_IOCTL|ZONE_FLOW, (TEXT(" IOCTL_SERIAL_SET_XON\r\n")));
; 2414 :         if ( pHWIHead->XFlow ) {

  003c4	e5953094	 ldr         r3, [r5, #0x94]
  003c8	e3130002	 tst         r3, #2
  003cc	0a00010d	 beq         |$LN116@COM_IOCont|

; 2415 :             pHWIHead->StopXmit = 0;
; 2416 :             pHWIHead->SentXoff = 0;

  003d0	e3c3300c	 bic         r3, r3, #0xC
  003d4	e5853094	 str         r3, [r5, #0x94]

; 2417 :         }
; 2418 :         break;

  003d8	ea00010a	 b           |$LN116@COM_IOCont|
  003dc		 |$LN61@COM_IOCont|

; 2365 : 
; 2366 :         // ****************************************************************
; 2367 :         //
; 2368 :         //      @func BOOL      | IOCTL_SERIAL_SET_XOFF |
; 2369 :         //                              Device IO control routine to cause transmission
; 2370 :         //                              to act as if an XOFF character has been received.
; 2371 :         //
; 2372 :         //      @parm DWORD | dwOpenData | value returned from COM_Open call
; 2373 :         //      @parm DWORD | dwCode | IOCTL_SERIAL_SET_XOFF
; 2374 :         //      @parm PBYTE | pBufIn | Ignored
; 2375 :         //      @parm DWORD | dwLenIn | Ignored
; 2376 :         //      @parm PBYTE | pBufOut | Ignored
; 2377 :         //      @parm DWORD | dwLenOut | Ignored
; 2378 :         //      @parm PDWORD | pdwActualOut | Ignored
; 2379 :         //
; 2380 :         //      @rdesc          Returns TRUE for success, FALSE for failure (and
; 2381 :         //                              sets thread error code)
; 2382 :         //
; 2383 :         //      @xref           <f IOCTL_SERIAL_SET_XON>
; 2384 :         //
; 2385 :     case IOCTL_SERIAL_SET_XOFF :
; 2386 :         DEBUGMSG (ZONE_IOCTL|ZONE_FLOW, (TEXT(" IOCTL_SERIAL_SET_XOFF\r\n")));
; 2387 :         if ( pHWIHead->XFlow ) {

  003dc	e5953094	 ldr         r3, [r5, #0x94]

; 2388 :             pHWIHead->StopXmit = 1;
; 2389 :             pHWIHead->SentXoff = 1;
; 2390 :         }
; 2391 :         break;

  003e0	e59d800c	 ldr         r8, [sp, #0xC]
  003e4	e3130002	 tst         r3, #2
  003e8	0a000107	 beq         |$LN76@COM_IOCont|
  003ec	e383300c	 orr         r3, r3, #0xC
  003f0	e5853094	 str         r3, [r5, #0x94]
  003f4	ea000104	 b           |$LN76@COM_IOCont|
  003f8		 |$LN43@COM_IOCont|

; 2571 : 
; 2572 :         // ****************************************************************
; 2573 :         //
; 2574 :         //      @func BOOL      | IOCTL_SERIAL_GET_COMMSTATUS |
; 2575 :         //                              Device IO control routine to clear any pending
; 2576 :         //                              communications errors and return the current communication
; 2577 :         //                              status.
; 2578 :         //
; 2579 :         //      @parm DWORD | dwOpenData | value returned from COM_Open call
; 2580 :         //      @parm DWORD | dwCode | IOCTL_SERIAL_GET_COMMSTATUS
; 2581 :         //      @parm PBYTE | pBufIn | Ignored
; 2582 :         //      @parm DWORD | dwLenIn | Ignored
; 2583 :         //      @parm PBYTE | pBufOut | Points to a <f SERIAL_DEV_STATUS>
; 2584 :         //                              structure for the returned status information
; 2585 :         //      @parm DWORD | dwLenOut | should be sizeof(SERIAL_DEV_STATUS)
; 2586 :         //                              or larger
; 2587 :         //      @parm PDWORD | pdwActualOut | Points to DWORD to return length
; 2588 :         //                              of returned data (should be set to
; 2589 :         //                              sizeof(SERIAL_DEV_STATUS) if no error)
; 2590 :         //
; 2591 :         //      @rdesc          Returns TRUE for success, FALSE for failure (and
; 2592 :         //                              sets thread error code)
; 2593 :         //
; 2594 :         //
; 2595 :     case IOCTL_SERIAL_GET_COMMSTATUS :
; 2596 :         {
; 2597 :             SERIAL_DEV_STATUS SerialDevStat;
; 2598 : 
; 2599 :             DEBUGMSG (ZONE_IOCTL, (TEXT(" IOCTL_SERIAL_GET_COMMSTATUS\r\n")));
; 2600 :             if ( (dwLenOut < sizeof(SERIAL_DEV_STATUS)) || (NULL == pBufOut) ||
; 2601 :                  (NULL == pdwActualOut) ) {

  003f8	e59d309c	 ldr         r3, [sp, #0x9C]
  003fc	e3530010	 cmp         r3, #0x10
  00400	3a0000fd	 bcc         |$LN15@COM_IOCont|
  00404	e3570000	 cmp         r7, #0
  00408	0a0000fb	 beq         |$LN15@COM_IOCont|
  0040c	e3590000	 cmp         r9, #0
  00410	0a0000f9	 beq         |$LN15@COM_IOCont|

; 2602 :                 SetLastError (ERROR_INVALID_PARAMETER);
; 2603 :                 RetVal = FALSE;
; 2604 :                 DEBUGMSG (ZONE_IOCTL, (TEXT(" Invalid parameter\r\n")));
; 2605 :                 break;
; 2606 :             }
; 2607 :             // Clear the ComStat structure & get PDD related status
; 2608 :             memset ((char *) &(SerialDevStat.ComStat), 0, sizeof(COMSTAT));

  00414	e3a0200c	 mov         r2, #0xC
  00418	e3a01000	 mov         r1, #0
  0041c	e28d0018	 add         r0, sp, #0x18
  00420	eb000000	 bl          memset

; 2609 :             
; 2610 :             // Set The Error Mask
; 2611 :             SerialDevStat.Errors = InterlockedExchange((LPLONG)&pHWIHead->dwMddErrors,0);

  00424	e3a01000	 mov         r1, #0
  00428	e2850f41	 add         r0, r5, #0x41, 30
  0042c	eb000000	 bl          InterlockedExchange

; 2612 :             SerialDevStat.Errors |= pFuncTbl->HWGetStatus(pHWHead, &(SerialDevStat.ComStat));

  00430	e1a03000	 mov         r3, r0
  00434	e5982058	 ldr         r2, [r8, #0x58]
  00438	e58d3014	 str         r3, [sp, #0x14]
  0043c	e1a0000b	 mov         r0, r11
  00440	e28d1018	 add         r1, sp, #0x18
  00444	e1a0e00f	 mov         lr, pc
  00448	e12fff12	 bx          r2

; 2613 : 
; 2614 :             // PDD set fCtsHold, fDsrHold, fRLSDHold, and fTXim.  The MDD then
; 2615 :             // needs to set fXoffHold, fXoffSent, cbInQue, and cbOutQue.
; 2616 :             SerialDevStat.ComStat.cbInQue = RxBytesAvail(pHWIHead);

  0044c	e59520a0	 ldr         r2, [r5, #0xA0]
  00450	e595109c	 ldr         r1, [r5, #0x9C]
  00454	e59d3014	 ldr         r3, [sp, #0x14]
  00458	e1520001	 cmp         r2, r1
  0045c	e180e003	 orr         lr, r0, r3
  00460	359530a4	 ldrcc       r3, [r5, #0xA4]
  00464	20420001	 subcs       r0, r2, r1
  00468	30433001	 subcc       r3, r3, r1
  0046c	30830002	 addcc       r0, r3, r2

; 2617 :             SerialDevStat.ComStat.cbOutQue =  pHWIHead->TxBytesPending;
; 2618 :             SerialDevStat.ComStat.fXoffHold = pHWIHead->StopXmit;
; 2619 :             SerialDevStat.ComStat.fXoffSent = pHWIHead->SentXoff;

  00470	e5953094	 ldr         r3, [r5, #0x94]
  00474	e59d2018	 ldr         r2, [sp, #0x18]
  00478	e5951058	 ldr         r1, [r5, #0x58]

; 2620 : 
; 2621 :             *((PSERIAL_DEV_STATUS)pBufOut) = SerialDevStat;
; 2622 :             *pdwActualOut = sizeof(SERIAL_DEV_STATUS);

  0047c	e587e000	 str         lr, [r7]
  00480	e0223083	 eor         r3, r2, r3, lsl #1
  00484	e2033018	 and         r3, r3, #0x18
  00488	e0233002	 eor         r3, r3, r2
  0048c	e5873004	 str         r3, [r7, #4]
  00490	e3a03010	 mov         r3, #0x10
  00494	e5870008	 str         r0, [r7, #8]
  00498	e587100c	 str         r1, [r7, #0xC]
  0049c	e5893000	 str         r3, [r9]

; 2623 : 
; 2624 :         }
; 2625 : 
; 2626 :         break;

  004a0	ea0000d8	 b           |$LN116@COM_IOCont|
  004a4		 |$LN96@COM_IOCont|

; 2194 : 
; 2195 :     switch ( dwCode ) {

  004a4	e3a0381b	 mov         r3, #0x1B, 16
  004a8	e3833048	 orr         r3, r3, #0x48
  004ac	e1540003	 cmp         r4, r3
  004b0	8a0000ae	 bhi         |$LN98@COM_IOCont|
  004b4	0a0000ab	 beq         |$LN18@COM_IOCont|
  004b8	e3a0281b	 mov         r2, #0x1B, 16
  004bc	e3823034	 orr         r3, r2, #0x34
  004c0	e1540003	 cmp         r4, r3
  004c4	0a000094	 beq         |$LN40@COM_IOCont|
  004c8	e3823038	 orr         r3, r2, #0x38
  004cc	e1540003	 cmp         r4, r3
  004d0	0a00007a	 beq         |$LN37@COM_IOCont|
  004d4	e3a0381b	 mov         r3, #0x1B, 16
  004d8	e383303c	 orr         r3, r3, #0x3C
  004dc	e1540003	 cmp         r4, r3
  004e0	0a000067	 beq         |$LN34@COM_IOCont|
  004e4	e3823040	 orr         r3, r2, #0x40
  004e8	e1540003	 cmp         r4, r3
  004ec	0a000052	 beq         |$LN31@COM_IOCont|
  004f0	e3a0381b	 mov         r3, #0x1B, 16
  004f4	e3833044	 orr         r3, r3, #0x44
  004f8	e1540003	 cmp         r4, r3
  004fc	1a0000af	 bne         |$LN3@COM_IOCont|

; 2791 :         break;
; 2792 : 
; 2793 :         // ****************************************************************
; 2794 :         //
; 2795 :         //      @func BOOL      | IOCTL_SERIAL_PURGE |
; 2796 :         //                              Device IO control routine to discard characters from the
; 2797 :         //                              output or input buffer of a specified communications
; 2798 :         //                              resource.  It can also terminate pending read or write
; 2799 :         //                              operations on the resource
; 2800 :         //
; 2801 :         //      @parm DWORD | dwOpenData | value returned from COM_Open call
; 2802 :         //      @parm DWORD | dwCode | IOCTL_SERIAL_PURGE
; 2803 :         //      @parm PBYTE | pBufIn | Pointer to a DWORD containing the action
; 2804 :         //      @parm DWORD | dwLenIn | Should be sizeof(DWORD)
; 2805 :         //      @parm PBYTE | pBufOut | Ignored
; 2806 :         //      @parm DWORD | dwLenOut | Ignored
; 2807 :         //      @parm PDWORD | pdwActualOut | Ignored
; 2808 :         //
; 2809 :         //      @rdesc          Returns TRUE for success, FALSE for failure (and
; 2810 :         //                              sets thread error code)
; 2811 :         //
; 2812 :         //
; 2813 :     case IOCTL_SERIAL_PURGE :
; 2814 :         if ( (dwLenIn < sizeof(DWORD)) || (NULL == pBufIn) ) {

  00500	e59d3010	 ldr         r3, [sp, #0x10]
  00504	e3530004	 cmp         r3, #4
  00508	3a0000bb	 bcc         |$LN15@COM_IOCont|
  0050c	e35a0000	 cmp         r10, #0
  00510	0a0000b9	 beq         |$LN15@COM_IOCont|

; 2815 :             SetLastError (ERROR_INVALID_PARAMETER);
; 2816 :             RetVal = FALSE;
; 2817 :             DEBUGMSG (ZONE_IOCTL, (TEXT(" Invalid parameter\r\n")));
; 2818 :             break;
; 2819 :         }
; 2820 :         dwFlags = *((PDWORD) pBufIn);

  00514	e59a4000	 ldr         r4, [r10]

; 2821 : 
; 2822 :         DEBUGMSG (ZONE_IOCTL, (TEXT(" IOCTL_SERIAL_PURGE 0x%X\r\n"),dwFlags));
; 2823 : 
; 2824 :         pFuncTbl->HWPurgeComm(pHWHead,dwFlags);

  00518	e5983068	 ldr         r3, [r8, #0x68]
  0051c	e1a0000b	 mov         r0, r11
  00520	e1a01004	 mov         r1, r4
  00524	e1a0e00f	 mov         lr, pc
  00528	e12fff13	 bx          r3

; 2825 :         if ( dwFlags & PURGE_RXCLEAR ) {

  0052c	e3140008	 tst         r4, #8
  00530	0a000031	 beq         |$LN21@COM_IOCont|

; 2826 :             RxEnterCS(pHWIHead);

  00534	e28500b0	 add         r0, r5, #0xB0
  00538	eb000000	 bl          EnterCriticalSection

; 2827 :             DEBUGMSG(ZONE_IOCTL|ZONE_USR_READ,
; 2828 :                      (TEXT(" Flushing %d bytes from the read buffer\r\n"),RxBytesAvail(pHWIHead)));
; 2829 :             pHWIHead->RxBufferInfo.Read = pHWIHead->RxBufferInfo.Write;

  0053c	e59530a0	 ldr         r3, [r5, #0xA0]

; 2830 :             memset(pHWIHead->RxBufferInfo.RxCharBuffer, 0, pHWIHead->RxBufferInfo.Length);

  00540	e59520a4	 ldr         r2, [r5, #0xA4]
  00544	e59500ac	 ldr         r0, [r5, #0xAC]
  00548	e3a01000	 mov         r1, #0
  0054c	e585309c	 str         r3, [r5, #0x9C]
  00550	eb000000	 bl          memset

; 2831 :             RxLeaveCS(pHWIHead);

  00554	e28500b0	 add         r0, r5, #0xB0
  00558	eb000000	 bl          LeaveCriticalSection

; 2832 :             // Clear any flow control state
; 2833 :             if ( pHWIHead->DCB.fInX && pHWIHead->SentXoff ) {

  0055c	e5952068	 ldr         r2, [r5, #0x68]
  00560	e3120c02	 tst         r2, #2, 24
  00564	0a00000c	 beq         |$LN24@COM_IOCont|
  00568	e5953094	 ldr         r3, [r5, #0x94]
  0056c	e3130008	 tst         r3, #8
  00570	0a000009	 beq         |$LN24@COM_IOCont|

; 2834 :                 DEBUGMSG (ZONE_IOCTL|ZONE_FLOW, (TEXT("Sending XON\r\n")));
; 2835 :                 pHWIHead->SentXoff = 0;

  00574	e3c33008	 bic         r3, r3, #8

; 2836 :                 if ( !pHWIHead->DCB.fTXContinueOnXoff ) {

  00578	e3120080	 tst         r2, #0x80
  0057c	e5853094	 str         r3, [r5, #0x94]

; 2837 :                     pHWIHead->StopXmit = 0;

  00580	03c33004	 biceq       r3, r3, #4

; 2838 :                 }
; 2839 :                 pFuncTbl->HWXmitComChar(pHWIHead->pHWHead,pHWIHead->DCB.XonChar);

  00584	e5d51075	 ldrb        r1, [r5, #0x75]
  00588	e595002c	 ldr         r0, [r5, #0x2C]
  0058c	05853094	 streq       r3, [r5, #0x94]
  00590	e5982054	 ldr         r2, [r8, #0x54]
  00594	e1a0e00f	 mov         lr, pc
  00598	e12fff12	 bx          r2
  0059c		 |$LN24@COM_IOCont|

; 2840 :             }
; 2841 :             if ( pHWIHead->RtsFlow &&
; 2842 :                  (pHWIHead->DCB.fRtsControl == RTS_CONTROL_HANDSHAKE) ) {

  0059c	e5952094	 ldr         r2, [r5, #0x94]
  005a0	e3120020	 tst         r2, #0x20
  005a4	0a000008	 beq         |$LN22@COM_IOCont|
  005a8	e5953068	 ldr         r3, [r5, #0x68]
  005ac	e2033a03	 and         r3, r3, #3, 20
  005b0	e3530a02	 cmp         r3, #2, 20

; 2843 :                 DEBUGMSG (ZONE_IOCTL|ZONE_USR_READ|ZONE_FLOW,
; 2844 :                           (TEXT("RTS_CONTROL_HANDSHAKE Setting RTS\r\n")));
; 2845 :                 pHWIHead->RtsFlow = 0;

  005b4	03c23020	 biceq       r3, r2, #0x20

; 2846 :                 pFuncTbl->HWSetRTS(pHWIHead->pHWHead);

  005b8	0595002c	 ldreq       r0, [r5, #0x2C]
  005bc	05853094	 streq       r3, [r5, #0x94]
  005c0	05983040	 ldreq       r3, [r8, #0x40]
  005c4	01a0e00f	 moveq       lr, pc
  005c8	012fff13	 bxeq        r3
  005cc		 |$LN22@COM_IOCont|

; 2847 :             }
; 2848 :             if ( pHWIHead->DtrFlow &&
; 2849 :                  (pHWIHead->DCB.fDtrControl == DTR_CONTROL_HANDSHAKE) ) {

  005cc	e5952094	 ldr         r2, [r5, #0x94]
  005d0	e3120010	 tst         r2, #0x10
  005d4	0a000008	 beq         |$LN21@COM_IOCont|
  005d8	e5953068	 ldr         r3, [r5, #0x68]
  005dc	e2033030	 and         r3, r3, #0x30
  005e0	e3530020	 cmp         r3, #0x20

; 2850 :                 DEBUGMSG (ZONE_IOCTL|ZONE_USR_READ|ZONE_FLOW,
; 2851 :                           (TEXT("DTR_CONTROL_HANDSHAKE Setting DTR\r\n")));
; 2852 :                 pHWIHead->DtrFlow = 0;

  005e4	03c23010	 biceq       r3, r2, #0x10
  005e8	05853094	 streq       r3, [r5, #0x94]

; 2853 :                 pFuncTbl->HWSetDTR(pHWHead);

  005ec	05983038	 ldreq       r3, [r8, #0x38]
  005f0	01a0000b	 moveq       r0, r11
  005f4	01a0e00f	 moveq       lr, pc
  005f8	012fff13	 bxeq        r3
  005fc		 |$LN21@COM_IOCont|

; 2854 :             }
; 2855 :         }
; 2856 : 
; 2857 :         // Now, free up any threads blocked in MDD. Reads and writes are in
; 2858 :         // loops, so they also need a flag to tell them to abort.
; 2859 :         if ( dwFlags & PURGE_RXABORT ) {

  005fc	e3140002	 tst         r4, #2

; 2860 :             pHWIHead->fAbortRead = 1;

  00600	15953094	 ldrne       r3, [r5, #0x94]

; 2861 :             PulseEvent(pHWIHead->hReadEvent);

  00604	15950034	 ldrne       r0, [r5, #0x34]
  00608	13a01001	 movne       r1, #1
  0060c	13833040	 orrne       r3, r3, #0x40
  00610	15853094	 strne       r3, [r5, #0x94]
  00614	1b000000	 blne        EventModify

; 2862 :         }
; 2863 :         if ( dwFlags & PURGE_TXABORT ) {

  00618	e3140001	 tst         r4, #1
  0061c	0a000079	 beq         |$LN116@COM_IOCont|

; 2864 :             pHWIHead->fAbortTransmit      = 1;

  00620	e5953094	 ldr         r3, [r5, #0x94]

; 2865 :             // COM_Write() clears event upon entry, so we can use SetEvent
; 2866 :             SetEvent(pHWIHead->hTransmitEvent);

  00624	e595003c	 ldr         r0, [r5, #0x3C]
  00628	e3a01003	 mov         r1, #3
  0062c	e3833080	 orr         r3, r3, #0x80
  00630	e5853094	 str         r3, [r5, #0x94]
  00634	eb000000	 bl          EventModify

; 2867 :         }
; 2868 : 
; 2869 :         break;

  00638	ea000072	 b           |$LN116@COM_IOCont|
  0063c		 |$LN31@COM_IOCont|

; 2750 : 
; 2751 :         // ****************************************************************
; 2752 :         //
; 2753 :         //      @func BOOL      | IOCTL_SERIAL_GET_TIMEOUTS |
; 2754 :         //                              Device IO control routine to get the time-out parameters
; 2755 :         //                              for all read and write operations on a specified
; 2756 :         //                              communications device
; 2757 :         //
; 2758 :         //      @parm DWORD | dwOpenData | value returned from COM_Open call
; 2759 :         //      @parm DWORD | dwCode | IOCTL_SERIAL_GET_TIMEOUTS
; 2760 :         //      @parm PBYTE | pBufIn | Ignored
; 2761 :         //      @parm DWORD | dwLenIn | Ignored
; 2762 :         //      @parm PBYTE | pBufOut | Pointer to a <f COMMTIMEOUTS> structure
; 2763 :         //                              for the returned data
; 2764 :         //      @parm DWORD | dwLenOut | should be sizeof(COMMTIMEOUTS)
; 2765 :         //      @parm PDWORD | pdwActualOut | Points to DWORD to return length
; 2766 :         //                              of returned data (should be set to sizeof(COMMTIMEOUTS)
; 2767 :         //                              if no error)
; 2768 :         //
; 2769 :         //      @rdesc          Returns TRUE for success, FALSE for failure (and
; 2770 :         //                              sets thread error code)
; 2771 :         //
; 2772 :         //      @xref           <f IOCTL_SERIAL_GET_TIMEOUTS>
; 2773 :         //
; 2774 :     case IOCTL_SERIAL_GET_TIMEOUTS :
; 2775 :         DEBUGMSG (ZONE_IOCTL, (TEXT(" IOCTL_SERIAL_GET_TIMEOUTS\r\n")));
; 2776 :         if ( (dwLenOut < sizeof(COMMTIMEOUTS)) || (NULL == pBufOut) ||
; 2777 :              (NULL == pdwActualOut) ) {

  0063c	e59d309c	 ldr         r3, [sp, #0x9C]
  00640	e3530014	 cmp         r3, #0x14
  00644	3a00006c	 bcc         |$LN15@COM_IOCont|
  00648	e3570000	 cmp         r7, #0
  0064c	0a00006a	 beq         |$LN15@COM_IOCont|
  00650	e3590000	 cmp         r9, #0
  00654	0a000068	 beq         |$LN15@COM_IOCont|

; 2778 :             SetLastError (ERROR_INVALID_PARAMETER);
; 2779 :             RetVal = FALSE;
; 2780 :             DEBUGMSG (ZONE_IOCTL, (TEXT(" Invalid parameter\r\n")));
; 2781 :             break;
; 2782 :         }
; 2783 : 
; 2784 :             // Clear the structure
; 2785 :         memset ((char *) ((COMMTIMEOUTS *)pBufOut), 0,
; 2786 :                 sizeof(COMMTIMEOUTS));

  00658	e3a02014	 mov         r2, #0x14
  0065c	e3a01000	 mov         r1, #0
  00660	e1a00007	 mov         r0, r7
  00664	eb000000	 bl          memset

; 2787 :         memcpy((LPCOMMTIMEOUTS)pBufOut, &(pHWIHead->CommTimeouts),
; 2788 :                sizeof(COMMTIMEOUTS));

  00668	e285107c	 add         r1, r5, #0x7C
  0066c	e3a02014	 mov         r2, #0x14
  00670	e1a00007	 mov         r0, r7
  00674	eb000000	 bl          memcpy

; 2789 :         // Return the size
; 2790 :         *pdwActualOut = sizeof(COMMTIMEOUTS);

  00678	e3a03014	 mov         r3, #0x14
  0067c	e5893000	 str         r3, [r9]
  00680	ea000060	 b           |$LN116@COM_IOCont|
  00684		 |$LN34@COM_IOCont|

; 2709 :     }
; 2710 :         break;
; 2711 : 
; 2712 :         // ****************************************************************
; 2713 :         //
; 2714 :         //      @func BOOL      | IOCTL_SERIAL_SET_TIMEOUTS |
; 2715 :         //                              Device IO control routine to set the time-out parameters
; 2716 :         //                              for all read and write operations on a specified
; 2717 :         //                              communications device
; 2718 :         //
; 2719 :         //      @parm DWORD | dwOpenData | value returned from COM_Open call
; 2720 :         //      @parm DWORD | dwCode | IOCTL_SERIAL_SET_TIMEOUTS
; 2721 :         //      @parm PBYTE | pBufIn | Pointer to the <f COMMTIMEOUTS> structure
; 2722 :         //      @parm DWORD | dwLenIn | should be sizeof(COMMTIMEOUTS)
; 2723 :         //      @parm PBYTE | pBufOut | Ignored
; 2724 :         //      @parm DWORD | dwLenOut | Ignored
; 2725 :         //      @parm PDWORD | pdwActualOut | Ignored
; 2726 :         //
; 2727 :         //      @rdesc          Returns TRUE for success, FALSE for failure (and
; 2728 :         //                              sets thread error code)
; 2729 :         //
; 2730 :         //      @xref           <f IOCTL_SERIAL_GET_TIMEOUTS>
; 2731 :         //
; 2732 :     case IOCTL_SERIAL_SET_TIMEOUTS :
; 2733 :         if ( (dwLenIn < sizeof(COMMTIMEOUTS)) || (NULL == pBufIn) ) {

  00684	e59d3010	 ldr         r3, [sp, #0x10]
  00688	e3530014	 cmp         r3, #0x14
  0068c	3a00005a	 bcc         |$LN15@COM_IOCont|
  00690	e35a0000	 cmp         r10, #0
  00694	0a000058	 beq         |$LN15@COM_IOCont|

; 2734 :             SetLastError (ERROR_INVALID_PARAMETER);
; 2735 :             RetVal = FALSE;
; 2736 :             DEBUGMSG (ZONE_IOCTL, (TEXT(" Invalid parameter\r\n")));
; 2737 :             break;
; 2738 :         }
; 2739 :         pHWIHead->CommTimeouts = *((COMMTIMEOUTS *)pBufIn) ;

  00698	e285007c	 add         r0, r5, #0x7C
  0069c	e3a02014	 mov         r2, #0x14
  006a0	e1a0100a	 mov         r1, r10
  006a4	eb000000	 bl          memcpy

; 2740 :         DEBUGMSG (ZONE_IOCTL,
; 2741 :                   (TEXT(" IOCTL_SERIAL_SET_COMMTIMEOUTS (%d,%d,%d,%d,%d)\r\n"),
; 2742 :                    pHWIHead->CommTimeouts.ReadIntervalTimeout,
; 2743 :                    pHWIHead->CommTimeouts.ReadTotalTimeoutMultiplier,
; 2744 :                    pHWIHead->CommTimeouts.ReadTotalTimeoutConstant,
; 2745 :                    pHWIHead->CommTimeouts.WriteTotalTimeoutMultiplier,
; 2746 :                    pHWIHead->CommTimeouts.WriteTotalTimeoutConstant));
; 2747 : 
; 2748 :         pFuncTbl->HWSetCommTimeouts(pHWHead,&pHWIHead->CommTimeouts);

  006a8	e5983070	 ldr         r3, [r8, #0x70]
  006ac	e285107c	 add         r1, r5, #0x7C
  006b0	e1a0000b	 mov         r0, r11
  006b4	e1a0e00f	 mov         lr, pc
  006b8	e12fff13	 bx          r3

; 2749 :         break;

  006bc	ea000051	 b           |$LN116@COM_IOCont|
  006c0		 |$LN37@COM_IOCont|

; 2668 : 
; 2669 :         // ****************************************************************
; 2670 :         //
; 2671 :         //      @func BOOL      | IOCTL_SERIAL_GET_PROPERTIES |
; 2672 :         //                              Device IO control routine to retrieve information
; 2673 :         //                              about the communications properties for the device.
; 2674 :         //
; 2675 :         //      @parm DWORD | dwOpenData | value returned from COM_Open call
; 2676 :         //      @parm DWORD | dwCode | IOCTL_SERIAL_GET_PROPERTIES
; 2677 :         //      @parm PBYTE | pBufIn | Ignored
; 2678 :         //      @parm DWORD | dwLenIn | Ignored
; 2679 :         //      @parm PBYTE | pBufOut | Points to a <f COMMPROP> structure
; 2680 :         //                              for the returned information.
; 2681 :         //      @parm DWORD | dwLenOut | should be sizeof(COMMPROP)
; 2682 :         //                              or larger
; 2683 :         //      @parm PDWORD | pdwActualOut | Points to DWORD to return length
; 2684 :         //                              of returned data (should be set to sizeof(COMMPROP)
; 2685 :         //                              if no error)
; 2686 :         //
; 2687 :         //      @rdesc          Returns TRUE for success, FALSE for failure (and
; 2688 :         //                              sets thread error code)
; 2689 :         //
; 2690 :         //
; 2691 :     case IOCTL_SERIAL_GET_PROPERTIES :{
; 2692 :         COMMPROP commProp;
; 2693 :         DEBUGMSG (ZONE_IOCTL, (TEXT(" IOCTL_SERIAL_GET_PROPERTIES\r\n")));
; 2694 :         if ( (dwLenOut < sizeof(COMMPROP)) || (NULL == pBufOut) ||
; 2695 :              (NULL == pdwActualOut) ) {

  006c0	e59d309c	 ldr         r3, [sp, #0x9C]
  006c4	e3530040	 cmp         r3, #0x40
  006c8	3a00004b	 bcc         |$LN15@COM_IOCont|
  006cc	e3570000	 cmp         r7, #0
  006d0	0a000049	 beq         |$LN15@COM_IOCont|
  006d4	e3590000	 cmp         r9, #0
  006d8	0a000047	 beq         |$LN15@COM_IOCont|

; 2696 :             SetLastError (ERROR_INVALID_PARAMETER);
; 2697 :             RetVal = FALSE;
; 2698 :             DEBUGMSG (ZONE_IOCTL, (TEXT(" Invalid parameter\r\n")));
; 2699 :             break;
; 2700 :         }
; 2701 : 
; 2702 :         // Clear the ComMProp structure
; 2703 :         memset ((char *) &commProp, 0, sizeof(COMMPROP));

  006dc	e3a02040	 mov         r2, #0x40
  006e0	e3a01000	 mov         r1, #0
  006e4	e28d0030	 add         r0, sp, #0x30
  006e8	eb000000	 bl          memset

; 2704 : 
; 2705 :         pFuncTbl->HWGetCommProperties(pHWHead, &commProp);

  006ec	e5983064	 ldr         r3, [r8, #0x64]
  006f0	e28d1030	 add         r1, sp, #0x30
  006f4	e1a0000b	 mov         r0, r11
  006f8	e1a0e00f	 mov         lr, pc
  006fc	e12fff13	 bx          r3

; 2706 : 
; 2707 :         *((LPCOMMPROP)pBufOut) = commProp;

  00700	e28d1030	 add         r1, sp, #0x30
  00704	e3a02040	 mov         r2, #0x40
  00708	e1a00007	 mov         r0, r7
  0070c	eb000000	 bl          memcpy

; 2708 :         *pdwActualOut = sizeof(COMMPROP);

  00710	e3a03040	 mov         r3, #0x40
  00714	e5893000	 str         r3, [r9]
  00718	ea00003a	 b           |$LN116@COM_IOCont|
  0071c		 |$LN40@COM_IOCont|

; 2627 : 
; 2628 :         // ****************************************************************
; 2629 :         //
; 2630 :         //      @func BOOL      | IOCTL_SERIAL_GET_MODEMSTATUS |
; 2631 :         //                              Device IO control routine to retrieve current
; 2632 :         //                              modem control-register values
; 2633 :         //
; 2634 :         //      @parm DWORD | dwOpenData | value returned from COM_Open call
; 2635 :         //      @parm DWORD | dwCode | IOCTL_SERIAL_GET_MODEMSTATUS
; 2636 :         //      @parm PBYTE | pBufIn | Ignored
; 2637 :         //      @parm DWORD | dwLenIn | Ignored
; 2638 :         //      @parm PBYTE | pBufOut | Points to a DWORD for the returned
; 2639 :         //                              modem status information
; 2640 :         //      @parm DWORD | dwLenOut | should be sizeof(DWORD)
; 2641 :         //                              or larger
; 2642 :         //      @parm PDWORD | pdwActualOut | Points to DWORD to return length
; 2643 :         //                              of returned data (should be set to sizeof(DWORD)
; 2644 :         //                              if no error)
; 2645 :         //
; 2646 :         //      @rdesc          Returns TRUE for success, FALSE for failure (and
; 2647 :         //                              sets thread error code)
; 2648 :         //
; 2649 :         //
; 2650 :     case IOCTL_SERIAL_GET_MODEMSTATUS :  {
; 2651 :         DWORD dwModemStatus = 0 ;
; 2652 :         DEBUGMSG (ZONE_IOCTL, (TEXT(" IOCTL_SERIAL_GET_MODEMSTATUS\r\n")));
; 2653 :         if ( (dwLenOut < sizeof(DWORD)) || (NULL == pBufOut) ||
; 2654 :              (NULL == pdwActualOut) ) {

  0071c	e59d309c	 ldr         r3, [sp, #0x9C]
  00720	e3a02000	 mov         r2, #0
  00724	e58d2010	 str         r2, [sp, #0x10]
  00728	e3530004	 cmp         r3, #4
  0072c	3a000032	 bcc         |$LN15@COM_IOCont|
  00730	e3570000	 cmp         r7, #0
  00734	0a000030	 beq         |$LN15@COM_IOCont|
  00738	e3590000	 cmp         r9, #0
  0073c	0a00002e	 beq         |$LN15@COM_IOCont|

; 2655 :             SetLastError (ERROR_INVALID_PARAMETER);
; 2656 :             RetVal = FALSE;
; 2657 :             DEBUGMSG (ZONE_IOCTL, (TEXT(" Invalid parameter\r\n")));
; 2658 :             break;
; 2659 :         }
; 2660 : 
; 2661 :         // Set the Modem Status dword
; 2662 :         pFuncTbl->HWGetModemStatus(pHWHead, &dwModemStatus);

  00740	e5983060	 ldr         r3, [r8, #0x60]
  00744	e28d1010	 add         r1, sp, #0x10
  00748	e1a0000b	 mov         r0, r11
  0074c	e1a0e00f	 mov         lr, pc
  00750	e12fff13	 bx          r3

; 2663 :         // Return the size
; 2664 :         *pdwActualOut = sizeof(DWORD);
; 2665 :         *((PULONG)pBufOut) = dwModemStatus;

  00754	e59d3010	 ldr         r3, [sp, #0x10]
  00758	e3a02004	 mov         r2, #4
  0075c	e5892000	 str         r2, [r9]
  00760	e5873000	 str         r3, [r7]

; 2666 :     }
; 2667 :         break;

  00764	ea000027	 b           |$LN116@COM_IOCont|
  00768		 |$LN18@COM_IOCont|

; 2870 : 
; 2871 :         // ****************************************************************
; 2872 :         //
; 2873 :         //      @func BOOL      | IOCTL_SERIAL_SET_QUEUE_SIZE |
; 2874 :         //                              Device IO control routine to set the queue sizes of of a
; 2875 :         //                              communications device
; 2876 :         //
; 2877 :         //      @parm DWORD | dwOpenData | value returned from COM_Open call
; 2878 :         //      @parm DWORD | dwCode | IOCTL_SERIAL_SET_QUEUE_SIZE
; 2879 :         //      @parm PBYTE | pBufIn | Pointer to a <f SERIAL_QUEUE_SIZES>
; 2880 :         //                              structure
; 2881 :         //      @parm DWORD | dwLenIn | should be sizeof(<f SERIAL_QUEUE_SIZES>)
; 2882 :         //      @parm PBYTE | pBufOut | Ignored
; 2883 :         //      @parm DWORD | dwLenOut | Ignored
; 2884 :         //      @parm PDWORD | pdwActualOut | Ignored
; 2885 :         //
; 2886 :         //      @rdesc          Returns TRUE for success, FALSE for failure (and
; 2887 :         //                              sets thread error code)
; 2888 :         //
; 2889 :         //
; 2890 :     case IOCTL_SERIAL_SET_QUEUE_SIZE :
; 2891 :         SetLastError(ERROR_NOT_SUPPORTED);

  00768	e3a00032	 mov         r0, #0x32

; 2892 :         RetVal = FALSE;
; 2893 :         // NOTE: Normally we would do something with the passed in parameter.
; 2894 :         // But we don't think the user has a better idea of queue sizes
; 2895 :         // compared to our infinite knowledge.
; 2896 : 
; 2897 :         break;

  0076c	ea000023	 b           |$LN119@COM_IOCont|
  00770		 |$LN98@COM_IOCont|
  00770	e3a0381b	 mov         r3, #0x1B, 16
  00774	e383304c	 orr         r3, r3, #0x4C
  00778	e1540003	 cmp         r4, r3
  0077c	0a000050	 beq         |$LN17@COM_IOCont|
  00780	e3a0381b	 mov         r3, #0x1B, 16
  00784	e3833050	 orr         r3, r3, #0x50
  00788	e1540003	 cmp         r4, r3
  0078c	0a00003e	 beq         |$LN14@COM_IOCont|
  00790	e3a0381b	 mov         r3, #0x1B, 16
  00794	e3833054	 orr         r3, r3, #0x54
  00798	e1540003	 cmp         r4, r3
  0079c	0a00002c	 beq         |$LN11@COM_IOCont|
  007a0	e3a0381b	 mov         r3, #0x1B, 16
  007a4	e3833058	 orr         r3, r3, #0x58
  007a8	e1540003	 cmp         r4, r3
  007ac	0a00001e	 beq         |$LN6@COM_IOCont|
  007b0	e3a0381b	 mov         r3, #0x1B, 16
  007b4	e383305c	 orr         r3, r3, #0x5C
  007b8	e1540003	 cmp         r4, r3
  007bc	0a000015	 beq         |$LN4@COM_IOCont|
  007c0		 |$LN3@COM_IOCont|

; 3058 :     default :
; 3059 :         // Pass IOCTL through to PDD if hook is provided
; 3060 :         if ( (pFuncTbl->HWIoctl == NULL) ||
; 3061 :              (pFuncTbl->HWIoctl(pHWHead,dwCode,pBufIn,dwLenIn,pBufOut,dwLenOut,
; 3062 :                                 pdwActualOut) == FALSE) ) {

  007c0	e5983074	 ldr         r3, [r8, #0x74]
  007c4	e1b05003	 movs        r5, r3
  007c8	0a00000b	 beq         |$LN15@COM_IOCont|
  007cc	e59d109c	 ldr         r1, [sp, #0x9C]
  007d0	e59d3010	 ldr         r3, [sp, #0x10]
  007d4	e1a0200a	 mov         r2, r10
  007d8	e58d1004	 str         r1, [sp, #4]
  007dc	e1a01004	 mov         r1, r4
  007e0	e1a0000b	 mov         r0, r11
  007e4	e58d9008	 str         r9, [sp, #8]
  007e8	e58d7000	 str         r7, [sp]
  007ec	e1a0e00f	 mov         lr, pc
  007f0	e12fff15	 bx          r5
  007f4		 |$LN123@COM_IOCont|
  007f4	e3500000	 cmp         r0, #0
  007f8	1a000002	 bne         |$LN116@COM_IOCont|
  007fc		 |$LN15@COM_IOCont|

; 2920 :             SetLastError (ERROR_INVALID_PARAMETER);

  007fc	e3a00057	 mov         r0, #0x57
  00800		 |$LN119@COM_IOCont|
  00800	eb000000	 bl          SetLastError

; 2921 :             RetVal = FALSE;

  00804	e3a06000	 mov         r6, #0
  00808		 |$LN116@COM_IOCont|
  00808	e59d800c	 ldr         r8, [sp, #0xC]
  0080c		 |$LN76@COM_IOCont|

; 3063 :             SetLastError (ERROR_INVALID_PARAMETER);
; 3064 :             RetVal = FALSE;
; 3065 :             DEBUGMSG (ZONE_IOCTL, (TEXT(" Invalid ioctl 0x%X\r\n"), dwCode));
; 3066 :         }
; 3067 :         break;
; 3068 :     }
; 3069 : 
; 3070 :     COM_DEC_USAGE_CNT(pOpenHead);

  0080c	e288000c	 add         r0, r8, #0xC
  00810	eb000000	 bl          InterlockedDecrement

; 3071 : 
; 3072 :     DEBUGMSG (ZONE_IOCTL|ZONE_FUNCTION|(RetVal == FALSE?ZONE_ERROR:0),
; 3073 :               (TEXT("-COM_IOControl %s Ecode=%d (len=%d)\r\n"),
; 3074 :                (RetVal == TRUE) ? TEXT("Success") : TEXT("Error"),
; 3075 :                GetLastError(), (NULL == pdwActualOut) ? 0 : *pdwActualOut));
; 3076 : 
; 3077 :     return(RetVal);

  00814	ea00005a	 b           |$LN85@COM_IOCont|
  00818		 |$LN4@COM_IOCont|

; 3034 : 
; 3035 :         // ****************************************************************
; 3036 :         //
; 3037 :         //      @func BOOL      | IOCTL_SERIAL_DISABLE_IR |
; 3038 :         //                              Device IO control routine to set the device-control
; 3039 :         //                              block on a specified communications device
; 3040 :         //
; 3041 :         //      @parm DWORD | dwOpenData | value returned from COM_Open call
; 3042 :         //      @parm DWORD | dwCode | IOCTL_SERIAL_DISABLE_IR
; 3043 :         //      @parm PBYTE | pBufIn | Ignored
; 3044 :         //      @parm DWORD | dwLenIn | Ignored
; 3045 :         //      @parm PBYTE | pBufOut | Ignored
; 3046 :         //      @parm DWORD | dwLenOut | Ignored
; 3047 :         //      @parm PDWORD | pdwActualOut | Ignored
; 3048 :         //
; 3049 :         //      @rdesc          Returns TRUE for success, FALSE for failure (and
; 3050 :         //                              sets thread error code)
; 3051 :         //
; 3052 :         //
; 3053 :     case IOCTL_SERIAL_DISABLE_IR :
; 3054 :         DEBUGMSG (ZONE_IR,
; 3055 :                   (TEXT("IOCTL Disable IR\r\n")));
; 3056 :         pFuncTbl->HWDisableIR(pHWHead);

  00818	e5983048	 ldr         r3, [r8, #0x48]
  0081c	e1a0000b	 mov         r0, r11
  00820	e1a0e00f	 mov         lr, pc
  00824	e12fff13	 bx          r3

; 3057 :         break;

  00828	eafffff6	 b           |$LN116@COM_IOCont|
  0082c		 |$LN6@COM_IOCont|

; 3001 :             }
; 3002 :         }
; 3003 :         break;
; 3004 : 
; 3005 :         // ****************************************************************
; 3006 :         //
; 3007 :         //      @func BOOL      | IOCTL_SERIAL_ENABLE_IR |
; 3008 :         //                              Device IO control routine to set the device-control
; 3009 :         //                              block on a specified communications device
; 3010 :         //
; 3011 :         //      @parm DWORD | dwOpenData | value returned from COM_Open call
; 3012 :         //      @parm DWORD | dwCode | IOCTL_SERIAL_ENABLE_IR
; 3013 :         //      @parm PBYTE | pBufIn | Ignored
; 3014 :         //      @parm DWORD | dwLenIn | Ignored
; 3015 :         //      @parm PBYTE | pBufOut | Ignored
; 3016 :         //      @parm DWORD | dwLenOut | Ignored
; 3017 :         //      @parm PDWORD | pdwActualOut | Ignored
; 3018 :         //
; 3019 :         //      @rdesc          Returns TRUE for success, FALSE for failure (and
; 3020 :         //                              sets thread error code)
; 3021 :         //
; 3022 :         //
; 3023 :     case IOCTL_SERIAL_ENABLE_IR :
; 3024 :         DEBUGMSG (ZONE_IR,
; 3025 :                   (TEXT("IOCTL Enable IR\r\n")));
; 3026 :         if ( !pFuncTbl->HWEnableIR(pHWHead, pHWIHead->DCB.BaudRate) ) {

  0082c	e5951064	 ldr         r1, [r5, #0x64]
  00830	e5983044	 ldr         r3, [r8, #0x44]
  00834	e1a0000b	 mov         r0, r11
  00838	e1a0e00f	 mov         lr, pc
  0083c	e12fff13	 bx          r3

; 3028 : 
; 3029 :             DEBUGMSG (ZONE_IOCTL|ZONE_ERROR|ZONE_IR,
; 3030 :                       (TEXT("IR mode failed\r\n")));
; 3031 :         }
; 3032 : 
; 3033 :         break;

  00840	e59d800c	 ldr         r8, [sp, #0xC]
  00844	e3500000	 cmp         r0, #0
  00848	1affffef	 bne         |$LN76@COM_IOCont|

; 3027 :             RetVal = FALSE;

  0084c	e3a06000	 mov         r6, #0

; 3028 : 
; 3029 :             DEBUGMSG (ZONE_IOCTL|ZONE_ERROR|ZONE_IR,
; 3030 :                       (TEXT("IR mode failed\r\n")));
; 3031 :         }
; 3032 : 
; 3033 :         break;

  00850	eaffffed	 b           |$LN76@COM_IOCont|
  00854		 |$LN11@COM_IOCont|

; 2962 :         break;
; 2963 : 
; 2964 :         // ****************************************************************
; 2965 :         //
; 2966 :         //      @func BOOL      | IOCTL_SERIAL_SET_DCB |
; 2967 :         //                              Device IO control routine to set the device-control
; 2968 :         //                              block on a specified communications device
; 2969 :         //
; 2970 :         //      @parm DWORD | dwOpenData | value returned from COM_Open call
; 2971 :         //      @parm DWORD | dwCode | IOCTL_SERIAL_SET_DCB
; 2972 :         //      @parm PBYTE | pBufIn | Pointer to a <f DCB> structure
; 2973 :         //      @parm DWORD | dwLenIn | should be sizeof(<f DCB>)
; 2974 :         //      @parm PBYTE | pBufOut | Ignored
; 2975 :         //      @parm DWORD | dwLenOut | Ignored
; 2976 :         //      @parm PDWORD | pdwActualOut | Ignored
; 2977 :         //
; 2978 :         //      @rdesc          Returns TRUE for success, FALSE for failure (and
; 2979 :         //                              sets thread error code)
; 2980 :         //
; 2981 :         //
; 2982 :     case IOCTL_SERIAL_SET_DCB :
; 2983 :         if ( (dwLenIn < sizeof(DCB)) || (NULL == pBufIn) ) {

  00854	e59d3010	 ldr         r3, [sp, #0x10]
  00858	e353001c	 cmp         r3, #0x1C
  0085c	3affffe6	 bcc         |$LN15@COM_IOCont|
  00860	e35a0000	 cmp         r10, #0
  00864	0affffe4	 beq         |$LN15@COM_IOCont|

; 2984 :             SetLastError (ERROR_INVALID_PARAMETER);
; 2985 :             RetVal = FALSE;
; 2986 :             DEBUGMSG (ZONE_IOCTL, (TEXT(" Invalid parameter\r\n")));
; 2987 :             break;
; 2988 :         }
; 2989 :         else {
; 2990 :             DCB localDCB;
; 2991 :             DEBUGMSG (ZONE_IOCTL, (TEXT(" IOCTL_SERIAL_SET_DCB\r\n")));
; 2992 :             localDCB = *((DCB *)pBufIn);

  00868	e28d0014	 add         r0, sp, #0x14
  0086c	e3a0201c	 mov         r2, #0x1C
  00870	e1a0100a	 mov         r1, r10
  00874	eb000000	 bl          memcpy

; 2993 :             if ( !ApplyDCB (pHWIHead, &localDCB, TRUE) ) {

  00878	e3a02001	 mov         r2, #1
  0087c	e28d1014	 add         r1, sp, #0x14
  00880	e1a00005	 mov         r0, r5
  00884	eb000000	 bl          ApplyDCB

; 2994 :                 //
; 2995 :                 // Most likely an unsupported baud rate was specified
; 2996 :                 //
; 2997 :                 SetLastError (ERROR_INVALID_PARAMETER);
; 2998 :                 RetVal = FALSE;
; 2999 :                 DEBUGMSG (ZONE_IOCTL, (TEXT(" ApplyDCB failed\r\n")));
; 3000 :                 break;

  00888	eaffffd9	 b           |$LN123@COM_IOCont|
  0088c		 |$LN14@COM_IOCont|

; 2929 : 
; 2930 :         // ****************************************************************
; 2931 :         //
; 2932 :         //      @func BOOL      | IOCTL_SERIAL_GET_DCB |
; 2933 :         //                              Device IO control routine to get the device-control
; 2934 :         //                              block from a specified communications device
; 2935 :         //
; 2936 :         //      @parm DWORD | dwOpenData | value returned from COM_Open call
; 2937 :         //      @parm DWORD | dwCode | IOCTL_SERIAL_GET_DCB
; 2938 :         //      @parm PBYTE | pBufIn | Ignored
; 2939 :         //      @parm DWORD | dwLenIn | Ignored
; 2940 :         //      @parm PBYTE | pBufOut | Pointer to a <f DCB> structure
; 2941 :         //      @parm DWORD | dwLenOut | Should be sizeof(<f DCB>)
; 2942 :         //      @parm PDWORD | pdwActualOut | Pointer to DWORD to return length
; 2943 :         //                              of returned data (should be set to sizeof(<f DCB>) if
; 2944 :         //                              no error)
; 2945 :         //
; 2946 :         //      @rdesc          Returns TRUE for success, FALSE for failure (and
; 2947 :         //                              sets thread error code)
; 2948 :         //
; 2949 :         //
; 2950 :     case IOCTL_SERIAL_GET_DCB :
; 2951 :         DEBUGMSG (ZONE_IOCTL, (TEXT(" IOCTL_SERIAL_GET_DCB\r\n")));
; 2952 :         if ( (dwLenOut < sizeof(DCB)) || (NULL == pBufOut) ||
; 2953 :              (NULL == pdwActualOut) ) {

  0088c	e59d309c	 ldr         r3, [sp, #0x9C]
  00890	e353001c	 cmp         r3, #0x1C
  00894	3affffd8	 bcc         |$LN15@COM_IOCont|
  00898	e3570000	 cmp         r7, #0
  0089c	0affffd6	 beq         |$LN15@COM_IOCont|
  008a0	e3590000	 cmp         r9, #0
  008a4	0affffd4	 beq         |$LN15@COM_IOCont|

; 2954 :             SetLastError (ERROR_INVALID_PARAMETER);
; 2955 :             RetVal = FALSE;
; 2956 :             DEBUGMSG (ZONE_IOCTL, (TEXT(" Invalid parameter\r\n")));
; 2957 :             break;
; 2958 :         }
; 2959 :         memcpy((char *)pBufOut, (char *)&(pHWIHead->DCB), sizeof(DCB));

  008a8	e2851060	 add         r1, r5, #0x60
  008ac	e3a0201c	 mov         r2, #0x1C
  008b0	e1a00007	 mov         r0, r7
  008b4	eb000000	 bl          memcpy

; 2960 :         // Return the size
; 2961 :         *pdwActualOut = sizeof(DCB);

  008b8	e3a0301c	 mov         r3, #0x1C
  008bc	e5893000	 str         r3, [r9]
  008c0	eaffffd0	 b           |$LN116@COM_IOCont|
  008c4		 |$LN17@COM_IOCont|

; 2898 : 
; 2899 :         // ****************************************************************
; 2900 :         //
; 2901 :         //      @func BOOL      | IOCTL_SERIAL_IMMEDIATE_CHAR |
; 2902 :         //                              Device IO control routine to transmit a specified character
; 2903 :         //                              ahead of any pending data in the output buffer of the
; 2904 :         //                              communications device
; 2905 :         //
; 2906 :         //      @parm DWORD | dwOpenData | value returned from COM_Open call
; 2907 :         //      @parm DWORD | dwCode | IOCTL_SERIAL_IMMEDIATE_CHAR
; 2908 :         //      @parm PBYTE | pBufIn | Pointer to a UCHAR to send
; 2909 :         //      @parm DWORD | dwLenIn | should be sizeof(UCHAR)
; 2910 :         //      @parm PBYTE | pBufOut | Ignored
; 2911 :         //      @parm DWORD | dwLenOut | Ignored
; 2912 :         //      @parm PDWORD | pdwActualOut | Ignored
; 2913 :         //
; 2914 :         //      @rdesc          Returns TRUE for success, FALSE for failure (and
; 2915 :         //                              sets thread error code)
; 2916 :         //
; 2917 :         //
; 2918 :     case IOCTL_SERIAL_IMMEDIATE_CHAR :
; 2919 :         if ( (dwLenIn < sizeof(UCHAR)) || (NULL == pBufIn) ) {

  008c4	e59d3010	 ldr         r3, [sp, #0x10]
  008c8	e3530001	 cmp         r3, #1
  008cc	3affffca	 bcc         |$LN15@COM_IOCont|
  008d0	e35a0000	 cmp         r10, #0
  008d4	0affffc8	 beq         |$LN15@COM_IOCont|

; 2922 :             DEBUGMSG (ZONE_IOCTL, (TEXT(" Invalid parameter\r\n")));
; 2923 :             break;
; 2924 :         }
; 2925 :         DEBUGMSG (ZONE_IOCTL, (TEXT(" IOCTL_SERIAL_IMMEDIATE_CHAR 0x%X\r\n"),
; 2926 :                                (UCHAR *)pBufIn));
; 2927 :         pFuncTbl->HWXmitComChar(pHWHead, *pBufIn);

  008d8	e5da1000	 ldrb        r1, [r10]
  008dc	e5983054	 ldr         r3, [r8, #0x54]
  008e0	e1a0000b	 mov         r0, r11
  008e4	e1a0e00f	 mov         lr, pc
  008e8	e12fff13	 bx          r3

; 2928 :         break;

  008ec	eaffffc5	 b           |$LN116@COM_IOCont|
  008f0		 |$LN89@COM_IOCont|

; 3071 : 
; 3072 :     DEBUGMSG (ZONE_IOCTL|ZONE_FUNCTION|(RetVal == FALSE?ZONE_ERROR:0),
; 3073 :               (TEXT("-COM_IOControl %s Ecode=%d (len=%d)\r\n"),
; 3074 :                (RetVal == TRUE) ? TEXT("Success") : TEXT("Error"),
; 3075 :                GetLastError(), (NULL == pdwActualOut) ? 0 : *pdwActualOut));
; 3076 : 
; 3077 :     return(RetVal);

  008f0	e3a03832	 mov         r3, #0x32, 16
  008f4	e3833a01	 orr         r3, r3, #1, 20
  008f8	e1540003	 cmp         r4, r3
  008fc	0a00000e	 beq         |$LN86@COM_IOCont|
  00900	e59f30bc	 ldr         r3, [pc, #0xBC]
  00904	e1540003	 cmp         r4, r3
  00908	0a00000b	 beq         |$LN86@COM_IOCont|
  0090c	e59f30ac	 ldr         r3, [pc, #0xAC]
  00910	e1540003	 cmp         r4, r3
  00914	0a000008	 beq         |$LN86@COM_IOCont|
  00918	e59f309c	 ldr         r3, [pc, #0x9C]
  0091c	e1540003	 cmp         r4, r3
  00920	0a000005	 beq         |$LN86@COM_IOCont|
  00924	e59f308c	 ldr         r3, [pc, #0x8C]
  00928	e1540003	 cmp         r4, r3
  0092c	159f3080	 ldrne       r3, [pc, #0x80]
  00930	11540003	 cmpne       r4, r3
  00934	13a00006	 movne       r0, #6
  00938	1a00000f	 bne         |$LN122@COM_IOCont|
  0093c		 |$LN86@COM_IOCont|

; 2126 :         switch (dwCode) {
; 2127 :         case IOCTL_POWER_CAPABILITIES:case IOCTL_POWER_SET:case IOCTL_POWER_GET:
; 2128 :         case IOCTL_POWER_QUERY:case IOCTL_REGISTER_POWER_RELATIONSHIP:
; 2129 :         case IOCTL_CONTEXT_RESTORE:
; 2130 :             // Power is Handle by PDD.
; 2131 :             // Pass IOCTL through to PDD if hook is provided
; 2132 :             if ( (pFuncTbl->HWIoctl == NULL) ||
; 2133 :                  (pFuncTbl->HWIoctl(pHWHead,dwCode,pBufIn,dwLenIn,pBufOut,dwLenOut, pdwActualOut) == FALSE)) {

  0093c	e5983074	 ldr         r3, [r8, #0x74]
  00940	e1b05003	 movs        r5, r3
  00944	0a00000b	 beq         |$LN84@COM_IOCont|
  00948	e59d109c	 ldr         r1, [sp, #0x9C]
  0094c	e59d3010	 ldr         r3, [sp, #0x10]
  00950	e1a0200a	 mov         r2, r10
  00954	e58d1004	 str         r1, [sp, #4]
  00958	e1a01004	 mov         r1, r4
  0095c	e1a0000b	 mov         r0, r11
  00960	e58d9008	 str         r9, [sp, #8]
  00964	e58d7000	 str         r7, [sp]
  00968	e1a0e00f	 mov         lr, pc
  0096c	e12fff15	 bx          r5
  00970	e3500000	 cmp         r0, #0
  00974	1a000002	 bne         |$LN85@COM_IOCont|
  00978		 |$LN84@COM_IOCont|

; 2134 :                 SetLastError (ERROR_INVALID_PARAMETER);

  00978	e3a00057	 mov         r0, #0x57
  0097c		 |$LN122@COM_IOCont|
  0097c	eb000000	 bl          SetLastError

; 2135 :                 RetVal = FALSE;

  00980	e3a06000	 mov         r6, #0
  00984		 |$LN85@COM_IOCont|

; 2136 :                 DEBUGMSG (ZONE_IOCTL, (TEXT(" Invalid ioctl 0x%X\r\n"), dwCode));
; 2137 :             }
; 2138 :             break;
; 2139 :         default:
; 2140 :             SetLastError (ERROR_INVALID_HANDLE);
; 2141 :             RetVal = FALSE;
; 2142 :             break;
; 2143 :         }
; 2144 :         return RetVal;

  00984	e59d0070	 ldr         r0, [sp, #0x70]
  00988	eb000000	 bl          __security_check_cookie
  0098c	ea000004	 b           |$LN94@COM_IOCont|
  00990		 |$LN92@COM_IOCont|

; 2118 :         pHWHead  = pHWIHead->pHWHead;
; 2119 :     } else {
; 2120 :         SetLastError (ERROR_INVALID_HANDLE);

  00990	e3a00006	 mov         r0, #6
  00994		 |$LN117@COM_IOCont|
  00994	eb000000	 bl          SetLastError

; 2121 :         return(FALSE);

  00998	e59d0070	 ldr         r0, [sp, #0x70]
  0099c	eb000000	 bl          __security_check_cookie
  009a0	e3a06000	 mov         r6, #0
  009a4		 |$LN94@COM_IOCont|

; 3078 : }

  009a4	e1a00006	 mov         r0, r6
  009a8	e28dd074	 add         sp, sp, #0x74
  009ac	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  009b0	e12fff1e	 bx          lr
  009b4		 |$LN128@COM_IOCont|
  009b4		 |$LN129@COM_IOCont|
  009b4	80038140	 DCD         0x80038140
  009b8		 |$LN130@COM_IOCont|
  009b8	00321018	 DCD         0x321018
  009bc		 |$LN131@COM_IOCont|
  009bc	0032100c	 DCD         0x32100c
  009c0		 |$LN132@COM_IOCont|
  009c0	00321008	 DCD         0x321008
  009c4		 |$LN133@COM_IOCont|
  009c4	00321004	 DCD         0x321004
  009c8		 |$LN134@COM_IOCont|
  009c8	010303ff	 DCD         0x10303ff
  009cc		 |$LN135@COM_IOCont|
  009cc	00000000	 DCD         |__security_cookie|
  009d0		 |$M41586|

			 ENDP  ; |COM_IOControl|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|SerialEventHandler|
	IMPORT	|memmove|
	IMPORT	|InterlockedCompareExchange|
	IMPORT	|ExitThread|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T41652| DCD	|$LN57@SerialEven|
	DCD	0xc000da02

  00000			 AREA	 |.xdata|, DATA
|$T41648| DCD	0xffffffd8
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\com_mdd2\mdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T41648|

  00008		 |SerialEventHandler| PROC

; 245  : {

  00008		 |$LN57@SerialEven|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd018	 sub         sp, sp, #0x18
  00010		 |$M41649|
  00010	e1a05000	 mov         r5, r0
  00014	e59f3350	 ldr         r3, [pc, #0x350]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3014	 str         r3, [sp, #0x14]

; 246  :     PHW_VTBL            pFuncTbl = pSerialHead->pHWObj->pFuncTbl;

  00020	e5953028	 ldr         r3, [r5, #0x28]

; 247  :     PVOID               pHWHead = pSerialHead->pHWHead;
; 248  :     ULONG               CharIndex;
; 249  :     ULONG               RoomLeft = 0;
; 250  :     ULONG               TotalLeft = 0;
; 251  :     INTERRUPT_TYPE      it = INTR_NONE;
; 252  :     BOOL                RxDataAvail = FALSE;
; 253  : 
; 254  :     DEBUGMSG (ZONE_THREAD, (TEXT("+SerialEventHandler, pHead 0x%X\r\n"),
; 255  :                             pSerialHead));
; 256  : 
; 257  :     if ( pSerialHead->KillRxThread ||
; 258  :          !pSerialHead->hSerialEvent ) {

  00024	e5952094	 ldr         r2, [r5, #0x94]
  00028	e3a01000	 mov         r1, #0
  0002c	e5936008	 ldr         r6, [r3, #8]
  00030	e595702c	 ldr         r7, [r5, #0x2C]
  00034	e58d1000	 str         r1, [sp]
  00038	e3a09000	 mov         r9, #0
  0003c	e3120001	 tst         r2, #1
  00040	1a000002	 bne         |$LN31@SerialEven|
  00044	e5953030	 ldr         r3, [r5, #0x30]
  00048	e3530000	 cmp         r3, #0
  0004c	1a000004	 bne         |$LN32@SerialEven|
  00050		 |$LN31@SerialEven|

; 259  :         DEBUGMSG (ZONE_THREAD, (TEXT("Exitting thread\r\n")));
; 260  :         SetEvent(pSerialHead->hKillDispatchThread);

  00050	e5950038	 ldr         r0, [r5, #0x38]
  00054	e3a01003	 mov         r1, #3
  00058	eb000000	 bl          EventModify

; 261  :         ExitThread(0);

  0005c	e3a00000	 mov         r0, #0
  00060	eb000000	 bl          ExitThread
  00064		 |$LN32@SerialEven|

; 262  :     }
; 263  : 
; 264  : // NOTE - This one is a little tricky.  If the only owner is a monitoring task
; 265  : // then I don't have an owner for read/write, yet I might be in this routine
; 266  : // due to a change in line status.  Lets just do the best we can and increment
; 267  : // the count for the access owner if available.
; 268  :     if ( pSerialHead->pAccessOwner )

  00064	e5953100	 ldr         r3, [r5, #0x100]
  00068	e3530000	 cmp         r3, #0

; 269  :         COM_INC_USAGE_CNT(pSerialHead->pAccessOwner);

  0006c	1283000c	 addne       r0, r3, #0xC
  00070	1b000000	 blne        InterlockedIncrement

; 270  : 
; 271  :     while ( 1 ) {
; 272  : 
; 273  :         if ( !(it = pFuncTbl->HWGetIntrType(pHWHead)) ) {

  00074	e5963014	 ldr         r3, [r6, #0x14]
  00078	e1a00007	 mov         r0, r7
  0007c	e1a0e00f	 mov         lr, pc
  00080	e12fff13	 bx          r3
  00084	e1b08000	 movs        r8, r0
  00088	0a0000ae	 beq         |$LN2@SerialEven|
  0008c	e3a0a010	 mov         r10, #0x10
  00090	e3a0b000	 mov         r11, #0
  00094		 |$LL29@SerialEven|

; 274  :             DEBUGMSG (ZONE_THREAD,
; 275  :                       (TEXT("SerialEventHandler, No Interrupt.\r\n")));
; 276  :             break;
; 277  :         }
; 278  : 
; 279  :         DEBUGMSG (ZONE_THREAD,
; 280  :                   (TEXT("SerialEventHandler, Interrupts 0x%X\r\n"), it));
; 281  :         if ( it & INTR_RX ) {

  00094	e3180002	 tst         r8, #2
  00098	0a00008f	 beq         |$LN6@SerialEven|

; 282  :             // It's read data event. Optimize the read by reading chunks
; 283  :             // if the user has not specified using xflow control
; 284  :             // or event/error/eof characters. Ack the receive,
; 285  :             // unmask the interrupt, get the current data pointer
; 286  :             // and see if data is available.
; 287  :             // Note: We have to copy RxRead and RxWrite index to local in order to make it atomic.
; 288  :             register DWORD RxWIndex=RxWrite(pSerialHead), RxRIndex=RxRead(pSerialHead);

  0009c	e595309c	 ldr         r3, [r5, #0x9C]
  000a0	e59510a0	 ldr         r1, [r5, #0xA0]
  000a4	e1b02003	 movs        r2, r3

; 289  : 
; 290  :             DEBUGMSG (ZONE_THREAD|ZONE_READ , (TEXT("Rx Event\r\n")));
; 291  : 
; 292  :             if ( RxRIndex == 0 ) {
; 293  :                 // have to leave one byte free.
; 294  :                 RoomLeft = RxLength(pSerialHead) - RxWIndex - 1;

  000a8	e59530a4	 ldr         r3, [r5, #0xA4]
  000ac	e0433001	 sub         r3, r3, r1

; 295  :             } else {

  000b0	0a000003	 beq         |$LN54@SerialEven|

; 296  :                 RoomLeft = RxLength(pSerialHead) - RxWIndex;
; 297  :             }
; 298  :             if ( RxRIndex > RxWIndex ) {

  000b4	e1520001	 cmp         r2, r1
  000b8	e58d3000	 str         r3, [sp]
  000bc	9a000002	 bls         |$LN23@SerialEven|

; 299  :                 RoomLeft = RxRIndex - RxWIndex - 1;

  000c0	e0423001	 sub         r3, r2, r1
  000c4		 |$LN54@SerialEven|
  000c4	e2433001	 sub         r3, r3, #1
  000c8	e58d3000	 str         r3, [sp]
  000cc		 |$LN23@SerialEven|

; 300  :             }
; 301  :             if ( RoomLeft ) {

  000cc	e3530000	 cmp         r3, #0

; 302  :                 pSerialHead->DroppedBytesPDD +=
; 303  :                 pFuncTbl->HWRxIntrHandler(pHWHead,
; 304  :                                           RxBuffWrite(pSerialHead),
; 305  :                                           &RoomLeft);

  000d0	e28d2000	 add         r2, sp, #0
  000d4	e1a00007	 mov         r0, r7
  000d8	0a000008	 beq         |$LN22@SerialEven|
  000dc	e59530ac	 ldr         r3, [r5, #0xAC]
  000e0	e5964018	 ldr         r4, [r6, #0x18]
  000e4	e0811003	 add         r1, r1, r3
  000e8	e1a0e00f	 mov         lr, pc
  000ec	e12fff14	 bx          r4
  000f0	e595304c	 ldr         r3, [r5, #0x4C]
  000f4	e0803003	 add         r3, r0, r3
  000f8	e585304c	 str         r3, [r5, #0x4C]

; 306  :             } else {

  000fc	ea000010	 b           |$LN18@SerialEven|
  00100		 |$LN22@SerialEven|

; 307  :                 BYTE    TempBuf[16];
; 308  :                 RoomLeft = 16;

  00100	e58da000	 str         r10, [sp]

; 309  :                 pFuncTbl->HWRxIntrHandler(pHWHead,
; 310  :                                           TempBuf,
; 311  :                                           &RoomLeft);

  00104	e5963018	 ldr         r3, [r6, #0x18]
  00108	e28d1004	 add         r1, sp, #4
  0010c	e1a0e00f	 mov         lr, pc
  00110	e12fff13	 bx          r3

; 312  : 
; 313  :                 pSerialHead->DroppedBytesMDD += RoomLeft;

  00114	e5952048	 ldr         r2, [r5, #0x48]
  00118	e59d3000	 ldr         r3, [sp]

; 314  :                 DEBUGMSG (ZONE_WARN|ZONE_READ, (TEXT("Tossed %d bytes\r\n"),
; 315  :                                                 RoomLeft));
; 316  :                 RoomLeft = 0;

  0011c	e58db000	 str         r11, [sp]
  00120	e0823003	 add         r3, r2, r3
  00124	e5853048	 str         r3, [r5, #0x48]
  00128		 |$LL20@SerialEven|

; 317  :                 //InterlockedOR.
; 318  :                 {
; 319  :                     DWORD originalValue ;
; 320  :                     do {
; 321  :                         originalValue  =  pSerialHead->dwMddErrors ;                        

  00128	e5954104	 ldr         r4, [r5, #0x104]

; 322  :                     } while(originalValue != InterlockedCompareExchange((LPLONG)&pSerialHead->dwMddErrors, (LONG)(originalValue|CE_RXOVER),(LONG)originalValue));

  0012c	e2850f41	 add         r0, r5, #0x41, 30
  00130	e1a02004	 mov         r2, r4
  00134	e3841001	 orr         r1, r4, #1
  00138	eb000000	 bl          InterlockedCompareExchange
  0013c	e1540000	 cmp         r4, r0
  00140	1afffff8	 bne         |$LL20@SerialEven|
  00144		 |$LN18@SerialEven|

; 323  :                 }
; 324  :                 
; 325  :             }
; 326  : 
; 327  :             DEBUGMSG (ZONE_READ ,
; 328  :                       (TEXT("After HWGetBytes, Fifo(R=%d,W=%d,BA=%d,L=%d) ByteRead=%d\r\n"),
; 329  :                        RxRead(pSerialHead), RxWrite(pSerialHead),
; 330  :                        RxBytesAvail(pSerialHead), RxLength(pSerialHead),
; 331  :                        RoomLeft));
; 332  : 
; 333  : 
; 334  :             // If flow control enabled then we need to scan for XON/XOFF
; 335  :             // characters
; 336  :             if ( pSerialHead->XFlow ) {

  00144	e5953094	 ldr         r3, [r5, #0x94]

; 337  :                 for ( CharIndex=0; CharIndex < RoomLeft; ) {

  00148	e59de000	 ldr         lr, [sp]
  0014c	e3130002	 tst         r3, #2
  00150	0a000024	 beq         |$LN15@SerialEven|
  00154	e35e0000	 cmp         lr, #0
  00158	e3a04000	 mov         r4, #0
  0015c	0a000021	 beq         |$LN15@SerialEven|
  00160		 |$LL16@SerialEven|

; 338  :                     if ( RxBuffWrite(pSerialHead)[CharIndex] ==
; 339  :                          pSerialHead->DCB.XoffChar ) {

  00160	e59520ac	 ldr         r2, [r5, #0xAC]
  00164	e59530a0	 ldr         r3, [r5, #0xA0]
  00168	e1d517d6	 ldrsb       r1, [r5, #0x76]
  0016c	e0820003	 add         r0, r2, r3
  00170	e7f02004	 ldrb        r2, [r0, +r4]!
  00174	e1520001	 cmp         r2, r1
  00178	1a000009	 bne         |$LN14@SerialEven|

; 340  :                         DEBUGMSG (ZONE_FLOW, (TEXT("Received XOFF\r\n")));
; 341  : 
; 342  :                         pSerialHead->StopXmit = 1;

  0017c	e5953094	 ldr         r3, [r5, #0x94]

; 343  :                         memmove (RxBuffWrite(pSerialHead)+CharIndex,
; 344  :                                  RxBuffWrite(pSerialHead)+CharIndex+1,
; 345  :                                  RoomLeft - CharIndex);

  00180	e04e2004	 sub         r2, lr, r4
  00184	e2801001	 add         r1, r0, #1
  00188	e3833004	 orr         r3, r3, #4
  0018c	e5853094	 str         r3, [r5, #0x94]
  00190	eb000000	 bl          memmove

; 346  :                         RoomLeft--;

  00194	e59d3000	 ldr         r3, [sp]
  00198	e243e001	 sub         lr, r3, #1
  0019c	e58de000	 str         lr, [sp]

; 347  :                         continue;

  001a0	ea00000e	 b           |$LN52@SerialEven|
  001a4		 |$LN14@SerialEven|

; 348  :                     } else if ( RxBuffWrite(pSerialHead)[CharIndex] ==
; 349  :                                 pSerialHead->DCB.XonChar ) {

  001a4	e1d537d5	 ldrsb       r3, [r5, #0x75]
  001a8	e1520003	 cmp         r2, r3
  001ac	1a00000a	 bne         |$LN12@SerialEven|

; 350  :                         pSerialHead->StopXmit = 0;

  001b0	e5953094	 ldr         r3, [r5, #0x94]

; 351  :                         DEBUGMSG (ZONE_FLOW, (TEXT("Received XON\r\n")));
; 352  :                         memmove (RxBuffWrite(pSerialHead)+CharIndex,
; 353  :                                  RxBuffWrite(pSerialHead)+CharIndex+1,
; 354  :                                  RoomLeft - CharIndex);

  001b4	e04e2004	 sub         r2, lr, r4
  001b8	e2801001	 add         r1, r0, #1
  001bc	e3c33004	 bic         r3, r3, #4
  001c0	e5853094	 str         r3, [r5, #0x94]
  001c4	eb000000	 bl          memmove

; 355  :                         RoomLeft--;

  001c8	e59d3000	 ldr         r3, [sp]

; 356  :                         // We disabled TX on XOFF, so now we need to start sending
; 357  :                         // again. Easiest way is to pretend we saw a TX interrupt
; 358  :                         it |= INTR_TX;

  001cc	e3888004	 orr         r8, r8, #4
  001d0	e243e001	 sub         lr, r3, #1
  001d4	e58de000	 str         lr, [sp]

; 359  :                         continue;

  001d8	ea000000	 b           |$LN52@SerialEven|
  001dc		 |$LN12@SerialEven|

; 360  :                     }
; 361  :                     CharIndex++;

  001dc	e2844001	 add         r4, r4, #1
  001e0		 |$LN52@SerialEven|

; 337  :                 for ( CharIndex=0; CharIndex < RoomLeft; ) {

  001e0	e154000e	 cmp         r4, lr
  001e4	3affffdd	 bcc         |$LL16@SerialEven|
  001e8		 |$LN15@SerialEven|

; 362  :                 }
; 363  :             }
; 364  : 
; 365  :             pSerialHead->RxBytes += RoomLeft;
; 366  :             RxWrite(pSerialHead) =
; 367  :                 (RxWrite(pSerialHead)+RoomLeft<RxLength(pSerialHead)? RxWrite(pSerialHead)+RoomLeft: RxWrite(pSerialHead)+RoomLeft-RxLength(pSerialHead));

  001e8	e59500a0	 ldr         r0, [r5, #0xA0]
  001ec	e5953050	 ldr         r3, [r5, #0x50]
  001f0	e59510a4	 ldr         r1, [r5, #0xA4]
  001f4	e080200e	 add         r2, r0, lr
  001f8	e083300e	 add         r3, r3, lr
  001fc	e1520001	 cmp         r2, r1
  00200	e5853050	 str         r3, [r5, #0x50]
  00204	20403001	 subcs       r3, r0, r1
  00208	2083200e	 addcs       r2, r3, lr

; 368  :             if ( RoomLeft ) {
; 369  :                 RxDataAvail = TRUE;
; 370  :             }
; 371  : 
; 372  :             if ( IsIncreasedToFlowOff(pSerialHead)) {

  0020c	e595309c	 ldr         r3, [r5, #0x9C]
  00210	e35e0000	 cmp         lr, #0
  00214	13a09001	 movne       r9, #1
  00218	e1520003	 cmp         r2, r3
  0021c	20423003	 subcs       r3, r2, r3
  00220	30413003	 subcc       r3, r1, r3
  00224	30833002	 addcc       r3, r3, r2
  00228	e58520a0	 str         r2, [r5, #0xA0]
  0022c	e1d527b0	 ldrh        r2, [r5, #0x70]
  00230	e0413003	 sub         r3, r1, r3
  00234	e1520003	 cmp         r2, r3
  00238	3a000027	 bcc         |$LN6@SerialEven|

; 373  :                 if ( (pSerialHead->DCB.fDtrControl == DTR_CONTROL_HANDSHAKE) && (!pSerialHead->DtrFlow)) {

  0023c	e5953068	 ldr         r3, [r5, #0x68]
  00240	e2033030	 and         r3, r3, #0x30
  00244	e3530020	 cmp         r3, #0x20
  00248	05953094	 ldreq       r3, [r5, #0x94]
  0024c	03130010	 tsteq       r3, #0x10

; 374  :                     DEBUGMSG (ZONE_READ|ZONE_FLOW,
; 375  :                               (TEXT("DTR_CONTROL_HANDSHAKE Clearing DTR\r\n")));
; 376  :                     pSerialHead->DtrFlow = 1;

  00250	03833010	 orreq       r3, r3, #0x10
  00254	05853094	 streq       r3, [r5, #0x94]

; 377  :                     pFuncTbl->HWClearDTR(pHWHead);

  00258	05963034	 ldreq       r3, [r6, #0x34]
  0025c	01a00007	 moveq       r0, r7
  00260	01a0e00f	 moveq       lr, pc
  00264	012fff13	 bxeq        r3

; 378  :                 }
; 379  :                 if ( (pSerialHead->DCB.fRtsControl == RTS_CONTROL_HANDSHAKE) && (!pSerialHead->RtsFlow)) {

  00268	e5953068	 ldr         r3, [r5, #0x68]
  0026c	e2033a03	 and         r3, r3, #3, 20
  00270	e3530a02	 cmp         r3, #2, 20
  00274	05953094	 ldreq       r3, [r5, #0x94]
  00278	03130020	 tsteq       r3, #0x20

; 380  :                     DEBUGMSG (ZONE_READ|ZONE_FLOW,
; 381  :                               (TEXT("RTS_CONTROL_HANDSHAKE Clearing RTS\r\n")));
; 382  :                     pSerialHead->RtsFlow = 1;

  0027c	03833020	 orreq       r3, r3, #0x20
  00280	05853094	 streq       r3, [r5, #0x94]

; 383  :                     pFuncTbl->HWClearRTS(pHWHead);

  00284	0596303c	 ldreq       r3, [r6, #0x3C]
  00288	01a00007	 moveq       r0, r7
  0028c	01a0e00f	 moveq       lr, pc
  00290	012fff13	 bxeq        r3

; 384  :                 }
; 385  : 
; 386  :                 /* If Xon/Xoff flow control is desired. check the limit against
; 387  :                  * the remaining room and act accordingly.
; 388  :                  */
; 389  :                 if ( pSerialHead->DCB.fInX && !(pSerialHead->SentXoff)) {

  00294	e5953068	 ldr         r3, [r5, #0x68]
  00298	e3130c02	 tst         r3, #2, 24
  0029c	0a00000e	 beq         |$LN6@SerialEven|
  002a0	e5953094	 ldr         r3, [r5, #0x94]
  002a4	e3130008	 tst         r3, #8
  002a8	1a00000b	 bne         |$LN6@SerialEven|

; 390  :                     DEBUGMSG (ZONE_FLOW, (TEXT("Sending XOFF\r\n")));
; 391  :                     pFuncTbl->HWXmitComChar(pHWHead, pSerialHead->DCB.XoffChar);

  002ac	e5d51076	 ldrb        r1, [r5, #0x76]
  002b0	e5962054	 ldr         r2, [r6, #0x54]
  002b4	e1a00007	 mov         r0, r7
  002b8	e1a0e00f	 mov         lr, pc
  002bc	e12fff12	 bx          r2

; 392  : 
; 393  :                     pSerialHead->SentXoff = 1;

  002c0	e5953094	 ldr         r3, [r5, #0x94]

; 394  :                     if ( !pSerialHead->DCB.fTXContinueOnXoff ) {

  002c4	e5952068	 ldr         r2, [r5, #0x68]
  002c8	e3833008	 orr         r3, r3, #8
  002cc	e3120080	 tst         r2, #0x80
  002d0	e5853094	 str         r3, [r5, #0x94]

; 395  :                         pSerialHead->StopXmit = 1;

  002d4	03833004	 orreq       r3, r3, #4
  002d8	05853094	 streq       r3, [r5, #0x94]
  002dc		 |$LN6@SerialEven|

; 396  :                     }
; 397  :                 }
; 398  :             }
; 399  :         }
; 400  : 
; 401  :         if ( it & INTR_TX ) {

  002dc	e3180004	 tst         r8, #4

; 402  :             DEBUGMSG (ZONE_THREAD|ZONE_WRITE , (TEXT("Tx Event\r\n")));
; 403  :             DoTxData( pSerialHead );

  002e0	11a00005	 movne       r0, r5
  002e4	1b000000	 blne        DoTxData

; 404  :         }
; 405  : 
; 406  :         if ( (it & INTR_MODEM) ) {

  002e8	e3180008	 tst         r8, #8

; 407  :             DEBUGMSG (ZONE_THREAD, (TEXT("Other Event, it:%x\r\n"), it));
; 408  : 
; 409  :             /* Call low level status clean up code.
; 410  :              */
; 411  :             pFuncTbl->HWModemIntrHandler(pHWHead);

  002ec	15963020	 ldrne       r3, [r6, #0x20]
  002f0	11a00007	 movne       r0, r7
  002f4	11a0e00f	 movne       lr, pc
  002f8	112fff13	 bxne        r3

; 412  :         }
; 413  : 
; 414  :         if ( it & INTR_LINE ) {

  002fc	e3180001	 tst         r8, #1

; 415  :             DEBUGMSG (ZONE_THREAD, (TEXT("Line Event, it:%x\r\n"), it));
; 416  : 
; 417  :             /* Call low level line status clean up code.
; 418  :              * Then unmask the interrupt
; 419  :              */
; 420  :             pFuncTbl->HWLineIntrHandler(pHWHead);

  00300	15963024	 ldrne       r3, [r6, #0x24]
  00304	11a00007	 movne       r0, r7
  00308	11a0e00f	 movne       lr, pc
  0030c	112fff13	 bxne        r3
  00310	e5963014	 ldr         r3, [r6, #0x14]
  00314	e1a00007	 mov         r0, r7
  00318	e1a0e00f	 mov         lr, pc
  0031c	e12fff13	 bx          r3
  00320	e1b08000	 movs        r8, r0
  00324	1affff5a	 bne         |$LL29@SerialEven|

; 421  :         }
; 422  :     }
; 423  : 
; 424  :     // We kept this till the end to optimize the above loop
; 425  :     if ( RxDataAvail ) {

  00328	e3590000	 cmp         r9, #0
  0032c	0a000005	 beq         |$LN2@SerialEven|

; 426  :         // Signal COM_Read that bytes are available.
; 427  :         SetEvent(pSerialHead->hReadEvent);

  00330	e5950034	 ldr         r0, [r5, #0x34]
  00334	e3a01003	 mov         r1, #3
  00338	eb000000	 bl          EventModify

; 428  :         EvaluateEventFlag(pSerialHead, EV_RXCHAR);

  0033c	e3a01001	 mov         r1, #1
  00340	e1a00005	 mov         r0, r5
  00344	eb000000	 bl          EvaluateEventFlag
  00348		 |$LN2@SerialEven|

; 429  :     }
; 430  : 
; 431  :     DEBUGMSG (ZONE_THREAD ,
; 432  :               (TEXT("-SerialEventHandler, Fifo(R=%d,W=%d,L=%d)\r\n"),
; 433  :                RxRead(pSerialHead), RxWrite(pSerialHead),
; 434  :                RxLength(pSerialHead)));
; 435  : 
; 436  :     if ( pSerialHead->pAccessOwner )

  00348	e5953100	 ldr         r3, [r5, #0x100]
  0034c	e3530000	 cmp         r3, #0

; 437  :         COM_DEC_USAGE_CNT(pSerialHead->pAccessOwner);

  00350	1283000c	 addne       r0, r3, #0xC
  00354	1b000000	 blne        InterlockedDecrement
  00358	e59d0014	 ldr         r0, [sp, #0x14]
  0035c	eb000000	 bl          __security_check_cookie

; 438  :     return;
; 439  : }

  00360	e28dd018	 add         sp, sp, #0x18
  00364	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00368	e12fff1e	 bx          lr
  0036c		 |$LN58@SerialEven|
  0036c		 |$LN59@SerialEven|
  0036c	00000000	 DCD         |__security_cookie|
  00370		 |$M41650|

			 ENDP  ; |SerialEventHandler|


  00000			 AREA	 |.pdata|, PDATA
|$T41672| DCD	|$LN17@SerialDisp|
	DCD	0x40001b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SerialDispatchThread| PROC

; 464  : {

  00000		 |$LN17@SerialDisp|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M41669|
  00004	e1a04000	 mov         r4, r0

; 465  :     PHW_INDEP_INFO      pSerialHead    = (PHW_INDEP_INFO)pContext;
; 466  :     ULONG               WaitReturn;
; 467  : 
; 468  :     DEBUGMSG (ZONE_THREAD, (TEXT("Entered SerialDispatchThread %X\r\n"),
; 469  :                             pSerialHead));
; 470  : 
; 471  :     // It is possible for a PDD to use this routine in its private thread, so
; 472  :     // don't just assume that the MDD synchronization mechanism is in place.
; 473  :     if ( pSerialHead->pHWObj->BindFlags & THREAD_IN_MDD ) {

  00008	e5943028	 ldr         r3, [r4, #0x28]
  0000c	e5933000	 ldr         r3, [r3]
  00010	e3130003	 tst         r3, #3
  00014	0a00000e	 beq         |$LN9@SerialDisp|

; 474  :         DEBUGMSG(ZONE_INIT,
; 475  :                  (TEXT("Spinning in dispatch thread %X %X\n\r"), pSerialHead, pSerialHead->pHWObj));
; 476  :         while ( !pSerialHead->pDispatchThread ) {

  00018	ea000001	 b           |$LN13@SerialDisp|
  0001c		 |$LL4@SerialDisp|

; 477  :             Sleep(20);

  0001c	e3a00014	 mov         r0, #0x14
  00020	eb000000	 bl          Sleep
  00024		 |$LN13@SerialDisp|
  00024	e5943040	 ldr         r3, [r4, #0x40]
  00028	e3530000	 cmp         r3, #0
  0002c	0afffffa	 beq         |$LL4@SerialDisp|

; 478  :         }
; 479  :     }
; 480  : 
; 481  :     /* Wait for the event that any serial port action creates.
; 482  :      */
; 483  :     while ( !pSerialHead->KillRxThread ) {

  00030	ea000007	 b           |$LN9@SerialDisp|
  00034		 |$LL2@SerialDisp|

; 484  :         DEBUGMSG (ZONE_THREAD, (TEXT("Event %X, %d\r\n"),
; 485  :                                 pSerialHead->hSerialEvent,
; 486  :                                 pSerialHead->pHWObj->dwIntID ));
; 487  :         WaitReturn = WaitForSingleObject(pSerialHead->hSerialEvent, INFINITE);

  00034	e5940030	 ldr         r0, [r4, #0x30]
  00038	e3e01000	 mvn         r1, #0
  0003c	eb000000	 bl          WaitForSingleObject

; 488  : 
; 489  :         SerialEventHandler(pSerialHead);

  00040	e1a00004	 mov         r0, r4
  00044	eb000000	 bl          SerialEventHandler

; 490  :         InterruptDone(pSerialHead->pHWObj->dwIntID);

  00048	e5943028	 ldr         r3, [r4, #0x28]
  0004c	e5930004	 ldr         r0, [r3, #4]
  00050	eb000000	 bl          InterruptDone
  00054		 |$LN9@SerialDisp|
  00054	e5943094	 ldr         r3, [r4, #0x94]
  00058	e3130001	 tst         r3, #1
  0005c	0afffff4	 beq         |$LL2@SerialDisp|

; 491  :     }
; 492  : 
; 493  :     DEBUGMSG (ZONE_THREAD, (TEXT("SerialDispatchThread %x exiting\r\n"),
; 494  :                             pSerialHead));
; 495  :     return(0);

  00060	e3a00000	 mov         r0, #0

; 496  : }

  00064	e8bd4010	 ldmia       sp!, {r4, lr}
  00068	e12fff1e	 bx          lr
  0006c		 |$M41670|

			 ENDP  ; |SerialDispatchThread|

	EXPORT	|StartDispatchThread|
	IMPORT	|CreateThread|
	IMPORT	|InterruptInitialize|

  00000			 AREA	 |.pdata|, PDATA
|$T41683| DCD	|$LN8@StartDispa|
	DCD	0x40002402
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |StartDispatchThread| PROC

; 511  : {

  00000		 |$LN8@StartDispa|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M41680|
  00008	e1a04000	 mov         r4, r0

; 512  :     // Initialize the interrupt to be associated with the hSerialEvent
; 513  :     // event. GetByte waits on this event and acts as a second
; 514  :     // level decoder determining the type of serial event. If this return
; 515  :     // fails, then another process has registered for the interrupt, so
; 516  :     // fail the init and set the hSerialEvent to NULL.
; 517  :     DEBUGMSG(ZONE_INIT,
; 518  :              (TEXT("Initializing interrupt 0x%X, 0x%X\n\r"),
; 519  :               pSerialHead->pHWObj->dwIntID, pSerialHead->hSerialEvent));
; 520  : 
; 521  :     if ( !InterruptInitialize(pSerialHead->pHWObj->dwIntID,
; 522  :                               pSerialHead->hSerialEvent,
; 523  :                               NULL,
; 524  :                               0) ) {

  0000c	e5942028	 ldr         r2, [r4, #0x28]
  00010	e5941030	 ldr         r1, [r4, #0x30]
  00014	e3a03000	 mov         r3, #0
  00018	e5920004	 ldr         r0, [r2, #4]
  0001c	e3a02000	 mov         r2, #0
  00020	eb000000	 bl          InterruptInitialize
  00024	e3500000	 cmp         r0, #0
  00028	1a000001	 bne         |$LN2@StartDispa|
  0002c		 |$LN5@StartDispa|

; 525  :         DEBUGMSG(ZONE_INIT | ZONE_ERROR,
; 526  :                  (TEXT("Error initializing interrupt\n\r")));
; 527  :         return(FALSE);

  0002c	e3a00000	 mov         r0, #0
  00030	ea000012	 b           |$LN3@StartDispa|
  00034		 |$LN2@StartDispa|

; 528  :     }
; 529  : 
; 530  :     InterruptDone(pSerialHead->pHWObj->dwIntID);

  00034	e5943028	 ldr         r3, [r4, #0x28]
  00038	e5930004	 ldr         r0, [r3, #4]
  0003c	eb000000	 bl          InterruptDone

; 531  : 
; 532  :     // Set up the dispatch thread and it's kill flag. Note that the thread
; 533  :     // fills in its own handle in pSerialHead.
; 534  :     pSerialHead->KillRxThread = 0;

  00040	e5943094	 ldr         r3, [r4, #0x94]

; 535  :     pSerialHead->pDispatchThread = NULL;
; 536  : 
; 537  :     DEBUGMSG(ZONE_INIT,
; 538  :              (TEXT("Spinning thread%X\n\r"), pSerialHead));
; 539  : 
; 540  :     pSerialHead->pDispatchThread = CreateThread(NULL,0, SerialDispatchThread,
; 541  :                                                 pSerialHead, 0,NULL);

  00044	e59f2040	 ldr         r2, [pc, #0x40]
  00048	e3a0e000	 mov         lr, #0
  0004c	e3c33001	 bic         r3, r3, #1
  00050	e5843094	 str         r3, [r4, #0x94]
  00054	e1a03004	 mov         r3, r4
  00058	e3a01000	 mov         r1, #0
  0005c	e3a00000	 mov         r0, #0
  00060	e584e040	 str         lr, [r4, #0x40]
  00064	e58de004	 str         lr, [sp, #4]
  00068	e58de000	 str         lr, [sp]
  0006c	eb000000	 bl          CreateThread
  00070	e3500000	 cmp         r0, #0
  00074	e5840040	 str         r0, [r4, #0x40]

; 542  :     if ( pSerialHead->pDispatchThread == NULL ) {
; 543  :         DEBUGMSG(ZONE_INIT|ZONE_ERROR,
; 544  :                  (TEXT("Error creating dispatch thread (%d)\n\r"),
; 545  :                   GetLastError()));
; 546  :         return(FALSE);

  00078	0affffeb	 beq         |$LN5@StartDispa|

; 547  :     }
; 548  : 
; 549  :     DEBUGMSG (ZONE_INIT, (TEXT("Created receive thread %X\r\n"),
; 550  :                           pSerialHead->pDispatchThread));
; 551  :     return(TRUE);

  0007c	e3a00001	 mov         r0, #1
  00080		 |$LN3@StartDispa|

; 552  : }

  00080	e28dd008	 add         sp, sp, #8
  00084	e8bd4010	 ldmia       sp!, {r4, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$LN9@StartDispa|
  0008c		 |$LN10@StartDispa|
  0008c	00000000	 DCD         |SerialDispatchThread|
  00090		 |$M41681|

			 ENDP  ; |StartDispatchThread|

	EXPORT	|COM_Init|
	EXPORT	|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CC@KMPFMANC@?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|GetSerialObject|
	IMPORT	|RegCloseKey|
	IMPORT	|RegQueryValueExW|
	IMPORT	|OpenDeviceKey|
	IMPORT	|CreateEventW|
	IMPORT	|InitializeCriticalSection|
	IMPORT	|LocalAlloc|

  00000			 AREA	 |.pdata|, PDATA
|$T41702| DCD	|$LN19@COM_Init|
	DCD	0x4000a702

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@| DCB "P"
	DCB	0x0, "r", 0x0, "i", 0x0, "o", 0x0, "r", 0x0, "i", 0x0, "t"
	DCB	0x0, "y", 0x0, "2", 0x0, "5", 0x0, "6", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@KMPFMANC@?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$AA@| DCB "D"
	DCB	0x0, "e", 0x0, "v", 0x0, "i", 0x0, "c", 0x0, "e", 0x0, "A"
	DCB	0x0, "r", 0x0, "r", 0x0, "a", 0x0, "y", 0x0, "I", 0x0, "n"
	DCB	0x0, "d", 0x0, "e", 0x0, "x", 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |COM_Init| PROC

; 715  : {

  00000		 |$LN19@COM_Init|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M41699|
  00008	e1a07000	 mov         r7, r0

; 716  :     PVOID           pHWHead     = NULL;
; 717  :     PHW_INDEP_INFO  pSerialHead = NULL;
; 718  :     ULONG           HWBufferSize;
; 719  :     DWORD           DevIndex;
; 720  :     HKEY            hKey;
; 721  :     ULONG           kreserved = 0, kvaluetype;
; 722  :     ULONG           datasize = sizeof(ULONG);

  0000c	e3a03004	 mov         r3, #4

; 723  : 
; 724  :     /*
; 725  :      *  INTERNAL: this routine initializes the hardware abstraction interface
; 726  :      *  via HWInit(). It allocates a data structure representing this
; 727  :      *  instantiation of the device. It also creates an event and initializes
; 728  :      *  a critical section for receiving as well as registering the logical
; 729  :      *  interrupt dwIntID with NK via InterruptInitialize. This call
; 730  :      *  requires that the hardware dependent portion export apis that return
; 731  :      *  the physical address of the receive buffer and the size of that buffer.
; 732  :      *  Finally, it creates a buffer to act as an intermediate
; 733  :      *  buffer when receiving.
; 734  :      */
; 735  :     DEBUGMSG (ZONE_INIT | ZONE_FUNCTION, (TEXT("+COM_Init\r\n")));
; 736  : 
; 737  :     // Allocate our control structure.
; 738  :     pSerialHead  =  (PHW_INDEP_INFO)LocalAlloc(LPTR, sizeof(HW_INDEP_INFO));

  00010	e3a01f42	 mov         r1, #0x42, 30
  00014	e3a00040	 mov         r0, #0x40
  00018	e58d3008	 str         r3, [sp, #8]
  0001c	eb000000	 bl          LocalAlloc
  00020	e1b05000	 movs        r5, r0

; 739  : 
; 740  :     // Check that LocalAlloc did stuff ok too.
; 741  :     if ( !pSerialHead ) {
; 742  :         DEBUGMSG(ZONE_INIT | ZONE_ERROR,
; 743  :                  (TEXT("Error allocating memory for pSerialHead, COM_Init failed\n\r")));
; 744  :         return(NULL);

  00024	0a000056	 beq         |$LN16@COM_Init|

; 745  :     }
; 746  :     memset(pSerialHead,0,sizeof(HW_INDEP_INFO));

  00028	e3a02f42	 mov         r2, #0x42, 30
  0002c	e3a01000	 mov         r1, #0
  00030	e1a00005	 mov         r0, r5
  00034	eb000000	 bl          memset

; 747  : 
; 748  :     // Initially, open list is empty.
; 749  :     InitializeListHead( &pSerialHead->OpenList );

  00038	e28530e4	 add         r3, r5, #0xE4

; 750  :     InitializeCriticalSection(&(pSerialHead->OpenCS));

  0003c	e28500ec	 add         r0, r5, #0xEC
  00040	e58530e8	 str         r3, [r5, #0xE8]
  00044	e58530e4	 str         r3, [r5, #0xE4]
  00048	eb000000	 bl          InitializeCriticalSection

; 751  : 
; 752  :     /* Initialize the critical sections that will guard the parts of
; 753  :      * the receive and transmit buffers.
; 754  :      */
; 755  :     InitializeCriticalSection(&(pSerialHead->ReceiveCritSec1));

  0004c	e2850014	 add         r0, r5, #0x14
  00050	eb000000	 bl          InitializeCriticalSection

; 756  :     InitializeCriticalSection(&(pSerialHead->TransmitCritSec1));

  00054	e1a00005	 mov         r0, r5
  00058	eb000000	 bl          InitializeCriticalSection

; 757  :     
; 758  :     /* Initialize the critical section that guard the receive and Xmit buffer
; 759  :     */
; 760  :     InitializeCriticalSection(&(pSerialHead->RxBufferInfo.CS));

  0005c	e28500b0	 add         r0, r5, #0xB0
  00060	eb000000	 bl          InitializeCriticalSection

; 761  :     InitializeCriticalSection(&(pSerialHead->TxBufferInfo.CS));

  00064	e28500d0	 add         r0, r5, #0xD0
  00068	eb000000	 bl          InitializeCriticalSection

; 762  :     
; 763  :     pSerialHead->pAccessOwner = NULL;
; 764  :     pSerialHead->fEventMask = 0;
; 765  : 
; 766  :     // Init CommTimeouts.
; 767  :     pSerialHead->CommTimeouts.ReadIntervalTimeout = READ_TIMEOUT;

  0006c	e3a030fa	 mov         r3, #0xFA

; 768  :     pSerialHead->CommTimeouts.ReadTotalTimeoutMultiplier =
; 769  :     READ_TIMEOUT_MULTIPLIER;

  00070	e3a0200a	 mov         r2, #0xA

; 770  :     pSerialHead->CommTimeouts.ReadTotalTimeoutConstant =
; 771  :     READ_TIMEOUT_CONSTANT;

  00074	e3a01064	 mov         r1, #0x64
  00078	e585307c	 str         r3, [r5, #0x7C]
  0007c	e5852080	 str         r2, [r5, #0x80]
  00080	e5851084	 str         r1, [r5, #0x84]
  00084	e3a09000	 mov         r9, #0

; 772  :     pSerialHead->CommTimeouts.WriteTotalTimeoutMultiplier=  0;
; 773  :     pSerialHead->CommTimeouts.WriteTotalTimeoutConstant =   0;
; 774  : 
; 775  :     /* Create tx and rx events and stash in global struct field. Check return.
; 776  :      */
; 777  :     pSerialHead->hSerialEvent = CreateEvent(0,FALSE,FALSE,NULL);

  00088	e3a03000	 mov         r3, #0
  0008c	e3a02000	 mov         r2, #0
  00090	e3a01000	 mov         r1, #0
  00094	e3a00000	 mov         r0, #0
  00098	e5859100	 str         r9, [r5, #0x100]
  0009c	e5859098	 str         r9, [r5, #0x98]
  000a0	e5859088	 str         r9, [r5, #0x88]
  000a4	e585908c	 str         r9, [r5, #0x8C]
  000a8	eb000000	 bl          CreateEventW
  000ac	e1a03000	 mov         r3, r0

; 778  :     pSerialHead->hKillDispatchThread = CreateEvent(0, FALSE, FALSE, NULL);

  000b0	e5853030	 str         r3, [r5, #0x30]
  000b4	e3a03000	 mov         r3, #0
  000b8	e3a00000	 mov         r0, #0
  000bc	e3a02000	 mov         r2, #0
  000c0	e3a01000	 mov         r1, #0
  000c4	eb000000	 bl          CreateEventW
  000c8	e1a03000	 mov         r3, r0

; 779  :     pSerialHead->hTransmitEvent = CreateEvent(0, FALSE, FALSE, NULL);

  000cc	e5853038	 str         r3, [r5, #0x38]
  000d0	e3a03000	 mov         r3, #0
  000d4	e3a00000	 mov         r0, #0
  000d8	e3a02000	 mov         r2, #0
  000dc	e3a01000	 mov         r1, #0
  000e0	eb000000	 bl          CreateEventW
  000e4	e1a03000	 mov         r3, r0

; 780  :     pSerialHead->hReadEvent = CreateEvent(0, FALSE, FALSE, NULL);

  000e8	e585303c	 str         r3, [r5, #0x3C]
  000ec	e3a03000	 mov         r3, #0
  000f0	e3a00000	 mov         r0, #0
  000f4	e3a02000	 mov         r2, #0
  000f8	e3a01000	 mov         r1, #0
  000fc	eb000000	 bl          CreateEventW

; 781  : 
; 782  :     if ( !pSerialHead->hSerialEvent || !pSerialHead->hKillDispatchThread ||
; 783  :          !pSerialHead->hTransmitEvent || !pSerialHead->hReadEvent ) {

  00100	e5953030	 ldr         r3, [r5, #0x30]
  00104	e5850034	 str         r0, [r5, #0x34]
  00108	e3530000	 cmp         r3, #0
  0010c	0a00001a	 beq         |$LN9@COM_Init|
  00110	e5953038	 ldr         r3, [r5, #0x38]
  00114	e3530000	 cmp         r3, #0
  00118	0a000017	 beq         |$LN9@COM_Init|
  0011c	e595303c	 ldr         r3, [r5, #0x3C]
  00120	e3530000	 cmp         r3, #0
  00124	0a000014	 beq         |$LN9@COM_Init|
  00128	e3500000	 cmp         r0, #0
  0012c	0a000012	 beq         |$LN9@COM_Init|

; 788  :     }
; 789  : 
; 790  :     /* Want to use the Identifier to do RegOpenKey and RegQueryValue (?)
; 791  :      * to get the index to be passed to GetHWObj.
; 792  :      * The HWObj will also have a flag denoting whether to start the
; 793  :      * listening thread or provide the callback.
; 794  :      */
; 795  :     DEBUGMSG (ZONE_INIT,(TEXT("Try to open %s\r\n"), (LPCTSTR)Identifier));
; 796  :     hKey = OpenDeviceKey((LPCTSTR)Identifier);

  00130	e1a00007	 mov         r0, r7
  00134	eb000000	 bl          OpenDeviceKey
  00138	e1b06000	 movs        r6, r0

; 797  :     if ( !hKey ) {
; 798  :         DEBUGMSG (ZONE_INIT | ZONE_ERROR,
; 799  :                   (TEXT("Failed to open devkeypath, COM_Init failed\r\n")));
; 800  :         COM_Deinit(pSerialHead);
; 801  :         return(NULL);

  0013c	0a00000e	 beq         |$LN9@COM_Init|

; 802  :     }
; 803  : 
; 804  :     datasize = sizeof(DWORD);
; 805  : 
; 806  :     if ( RegQueryValueEx(hKey, L"DeviceArrayIndex", NULL, &kvaluetype,
; 807  :                          (LPBYTE)&DevIndex, &datasize) ) {

  00140	e59f1150	 ldr         r1, [pc, #0x150]
  00144	e3a08004	 mov         r8, #4
  00148	e28de008	 add         lr, sp, #8
  0014c	e28d4010	 add         r4, sp, #0x10
  00150	e28d300c	 add         r3, sp, #0xC
  00154	e3a02000	 mov         r2, #0
  00158	e1a00006	 mov         r0, r6
  0015c	e58d8008	 str         r8, [sp, #8]
  00160	e58de004	 str         lr, [sp, #4]
  00164	e58d4000	 str         r4, [sp]
  00168	eb000000	 bl          RegQueryValueExW
  0016c	e3500000	 cmp         r0, #0

; 808  :         DEBUGMSG (ZONE_INIT | ZONE_ERROR,
; 809  :                   (TEXT("Failed to get DeviceArrayIndex value, COM_Init failed\r\n")));
; 810  :         RegCloseKey (hKey);

  00170	e1a00006	 mov         r0, r6
  00174	0a000007	 beq         |$LN7@COM_Init|
  00178	eb000000	 bl          RegCloseKey
  0017c		 |$LN9@COM_Init|

; 784  :         DEBUGMSG(ZONE_ERROR | ZONE_INIT,
; 785  :                  (TEXT("Error creating event, COM_Init failed\n\r")));
; 786  :         COM_Deinit(pSerialHead);

  0017c	e1a00005	 mov         r0, r5
  00180	eb000000	 bl          COM_Deinit
  00184		 |$LN16@COM_Init|

; 787  :         return(NULL);

  00184	e3a05000	 mov         r5, #0
  00188		 |$LN12@COM_Init|

; 894  : }

  00188	e1a00005	 mov         r0, r5
  0018c	e28dd014	 add         sp, sp, #0x14
  00190	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00194	e12fff1e	 bx          lr
  00198		 |$LN7@COM_Init|

; 811  :         COM_Deinit(pSerialHead);
; 812  :         return(NULL);
; 813  :     }
; 814  : 
; 815  :     datasize = sizeof(DWORD);
; 816  :     if ( RegQueryValueEx(hKey, L"Priority256", NULL, &kvaluetype,
; 817  :                          (LPBYTE)&pSerialHead->Priority256, &datasize) ) {

  00198	e59f10f4	 ldr         r1, [pc, #0xF4]
  0019c	e3a08004	 mov         r8, #4
  001a0	e28de008	 add         lr, sp, #8
  001a4	e2854044	 add         r4, r5, #0x44
  001a8	e28d300c	 add         r3, sp, #0xC
  001ac	e3a02000	 mov         r2, #0
  001b0	e58d8008	 str         r8, [sp, #8]
  001b4	e58de004	 str         lr, [sp, #4]
  001b8	e58d4000	 str         r4, [sp]
  001bc	eb000000	 bl          RegQueryValueExW
  001c0	e3500000	 cmp         r0, #0

; 818  :         pSerialHead->Priority256 = DEFAULT_CE_THREAD_PRIORITY;

  001c4	13a03067	 movne       r3, #0x67

; 819  :         DEBUGMSG (ZONE_INIT | ZONE_WARN,
; 820  :                   (TEXT("Failed to get Priority256 value, defaulting to %d\r\n"), pSerialHead->Priority256));
; 821  :     }
; 822  : 
; 823  :     RegCloseKey (hKey);

  001c8	e1a00006	 mov         r0, r6
  001cc	15853044	 strne       r3, [r5, #0x44]
  001d0	eb000000	 bl          RegCloseKey

; 824  : 
; 825  :     DEBUGMSG (ZONE_INIT,
; 826  :               (TEXT("DevIndex %X\r\n"), DevIndex));
; 827  : 
; 828  :     // Initialize hardware dependent data.
; 829  :     pSerialHead->pHWObj = GetSerialObject( DevIndex );

  001d4	e59d0010	 ldr         r0, [sp, #0x10]
  001d8	eb000000	 bl          GetSerialObject
  001dc	e3500000	 cmp         r0, #0
  001e0	e5850028	 str         r0, [r5, #0x28]

; 830  :     if ( !pSerialHead->pHWObj ) {
; 831  :         DEBUGMSG(ZONE_ERROR | ZONE_INIT,
; 832  :                  (TEXT("Error in GetSerialObject, COM_Init failed\n\r")));
; 833  :         COM_Deinit(pSerialHead);
; 834  :         return(NULL);

  001e4	0affffe4	 beq         |$LN9@COM_Init|

; 835  :     }
; 836  : 
; 837  :     DEBUGMSG (ZONE_INIT, (TEXT("About to call HWInit(%s,0x%X)\r\n"),
; 838  :                           Identifier, pSerialHead));
; 839  :     pHWHead = pSerialHead->pHWObj->pFuncTbl->HWInit(Identifier, pSerialHead, pSerialHead->pHWObj);

  001e8	e5903008	 ldr         r3, [r0, #8]
  001ec	e1a02000	 mov         r2, r0
  001f0	e1a01005	 mov         r1, r5
  001f4	e5933000	 ldr         r3, [r3]
  001f8	e1a00007	 mov         r0, r7
  001fc	e1a0e00f	 mov         lr, pc
  00200	e12fff13	 bx          r3
  00204	e1b04000	 movs        r4, r0

; 840  :     pSerialHead->pHWHead = pHWHead;

  00208	e585402c	 str         r4, [r5, #0x2C]

; 841  : 
; 842  :     /* Check that HWInit did stuff ok.  From here on out, call Deinit function
; 843  :      * when things fail.
; 844  :      */
; 845  :     if ( !pHWHead ) {
; 846  :         DEBUGMSG (ZONE_INIT | ZONE_ERROR,
; 847  :                   (TEXT("Hardware doesn't init correctly, COM_Init failed\r\n")));
; 848  :         COM_Deinit(pSerialHead);
; 849  :         return(NULL);

  0020c	0affffda	 beq         |$LN9@COM_Init|

; 850  :     }
; 851  :     DEBUGMSG (ZONE_INIT,
; 852  :               (TEXT("Back from hardware init\r\n")));
; 853  : 
; 854  :     // Allocate at least twice the hardware buffer size so we have headroom
; 855  :     HWBufferSize        = 2 * pSerialHead->pHWObj->pFuncTbl->HWGetRxBufferSize(pHWHead);

  00210	e5953028	 ldr         r3, [r5, #0x28]
  00214	e1a00004	 mov         r0, r4
  00218	e5933008	 ldr         r3, [r3, #8]
  0021c	e5933028	 ldr         r3, [r3, #0x28]
  00220	e1a0e00f	 mov         lr, pc
  00224	e12fff13	 bx          r3
  00228	e1a03080	 mov         r3, r0, lsl #1

; 856  : 
; 857  :     // Init rx buffer and buffer length here.
; 858  :     pSerialHead->RxBufferInfo.Length =
; 859  :     HWBufferSize > RX_BUFFER_SIZE ? HWBufferSize:RX_BUFFER_SIZE;

  0022c	e3530b02	 cmp         r3, #2, 22
  00230	93a03b02	 movls       r3, #2, 22

; 860  : 
; 861  :     pSerialHead->RxBufferInfo.RxCharBuffer =
; 862  :     LocalAlloc(LPTR, pSerialHead->RxBufferInfo.Length);

  00234	e1a01003	 mov         r1, r3
  00238	e3a00040	 mov         r0, #0x40
  0023c	e58530a4	 str         r3, [r5, #0xA4]
  00240	eb000000	 bl          LocalAlloc
  00244	e3500000	 cmp         r0, #0
  00248	e58500ac	 str         r0, [r5, #0xAC]

; 863  : 
; 864  :     if ( !pSerialHead->RxBufferInfo.RxCharBuffer ) {
; 865  :         DEBUGMSG(ZONE_INIT|ZONE_ERROR,
; 866  :                  (TEXT("Error allocating receive buffer, COM_Init failed\n\r")));
; 867  :         COM_Deinit(pSerialHead);
; 868  :         return(NULL);

  0024c	0affffca	 beq         |$LN9@COM_Init|

; 869  :     }
; 870  : 
; 871  :     DEBUGMSG (ZONE_INIT, (TEXT("RxHead init'ed\r\n")));
; 872  : 
; 873  :     RxResetFifo(pSerialHead);
; 874  : 
; 875  :     DEBUGMSG (ZONE_INIT, (TEXT("RxBuffer init'ed with start at %x\r\n"),
; 876  :                           pSerialHead->RxBufferInfo.RxCharBuffer));
; 877  : 
; 878  :     if ( pSerialHead->pHWObj->BindFlags & THREAD_AT_INIT ) {

  00250	e5953028	 ldr         r3, [r5, #0x28]
  00254	e585909c	 str         r9, [r5, #0x9C]
  00258	e58590a0	 str         r9, [r5, #0xA0]
  0025c	e5933000	 ldr         r3, [r3]
  00260	e3130001	 tst         r3, #1
  00264	0a000003	 beq         |$LN1@COM_Init|

; 879  :         // Hook the interrupt and start the associated thread.
; 880  :         if ( ! StartDispatchThread( pSerialHead ) ) {

  00268	e1a00005	 mov         r0, r5
  0026c	eb000000	 bl          StartDispatchThread
  00270	e3500000	 cmp         r0, #0

; 881  :             // Failed on InterruptInitialize or CreateThread.  Bail.
; 882  :             COM_Deinit(pSerialHead);
; 883  :             return(NULL);

  00274	0affffc0	 beq         |$LN9@COM_Init|
  00278		 |$LN1@COM_Init|

; 884  :         }
; 885  : 
; 886  :     }
; 887  : 
; 888  :     // OK, now that everything is ready on our end, give the PDD
; 889  :     // one last chance to init interrupts, etc.
; 890  :     (void) pSerialHead->pHWObj->pFuncTbl->HWPostInit( pHWHead );

  00278	e5953028	 ldr         r3, [r5, #0x28]
  0027c	e1a00004	 mov         r0, r4
  00280	e5933008	 ldr         r3, [r3, #8]
  00284	e5933004	 ldr         r3, [r3, #4]
  00288	e1a0e00f	 mov         lr, pc
  0028c	e12fff13	 bx          r3

; 891  : 
; 892  :     DEBUGMSG (ZONE_INIT | ZONE_FUNCTION, (TEXT("-COM_Init\r\n")));
; 893  :     return(pSerialHead);

  00290	eaffffbc	 b           |$LN12@COM_Init|
  00294		 |$LN20@COM_Init|
  00294		 |$LN21@COM_Init|
  00294	00000000	 DCD         |??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@|
  00298		 |$LN22@COM_Init|
  00298	00000000	 DCD         |??_C@_1CC@KMPFMANC@?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$AA@|
  0029c		 |$M41700|

			 ENDP  ; |COM_Init|

	EXPORT	|COM_Open|

  00000			 AREA	 |.pdata|, PDATA
|$T41723| DCD	|$LN27@COM_Open|
	DCD	0x4000ad01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |COM_Open| PROC

; 913  : {

  00000		 |$LN27@COM_Open|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M41720|
  00004	e1a07002	 mov         r7, r2
  00008	e1a06001	 mov         r6, r1
  0000c	e1a04000	 mov         r4, r0

; 914  :     PHW_INDEP_INFO  pSerialHead = (PHW_INDEP_INFO)pHead;
; 915  :     PHW_OPEN_INFO   pOpenHead;
; 916  :     PHWOBJ          pHWObj      = pSerialHead->pHWObj;
; 917  : 
; 918  :     DEBUGMSG (ZONE_OPEN|ZONE_FUNCTION, (TEXT("+COM_Open handle x%X, access x%X, share x%X\r\n"),
; 919  :                                         pHead, AccessCode, ShareMode));
; 920  : 
; 921  :     // Return NULL if SerialInit failed.
; 922  :     if ( !pSerialHead ) {
; 923  :         DEBUGMSG (ZONE_OPEN|ZONE_ERROR,
; 924  :                   (TEXT("Open attempted on uninited device!\r\n")));
; 925  :         SetLastError(ERROR_INVALID_HANDLE);
; 926  :         return(NULL);
; 927  :     }
; 928  : 
; 929  :     if (AccessCode & DEVACCESS_BUSNAMESPACE ) {

  00010	e3160c01	 tst         r6, #1, 24

; 930  :         AccessCode &=~(GENERIC_READ |GENERIC_WRITE|GENERIC_EXECUTE|GENERIC_ALL);

  00014	13c6620f	 bicne       r6, r6, #0xF, 4
  00018	e5948028	 ldr         r8, [r4, #0x28]

; 931  :     }
; 932  : 
; 933  :     // Return NULL if opening with access & someone else already has
; 934  :     if ( (AccessCode & (GENERIC_READ | GENERIC_WRITE)) &&
; 935  :          pSerialHead->pAccessOwner ) {

  0001c	e2169103	 ands        r9, r6, #3, 2
  00020	0a000006	 beq         |$LN19@COM_Open|
  00024	e5943100	 ldr         r3, [r4, #0x100]
  00028	e3530000	 cmp         r3, #0
  0002c	0a000003	 beq         |$LN19@COM_Open|

; 936  :         DEBUGMSG (ZONE_OPEN|ZONE_ERROR,
; 937  :                   (TEXT("Open requested access %x, handle x%X already has x%X!\r\n"),
; 938  :                    AccessCode, pSerialHead->pAccessOwner,
; 939  :                    pSerialHead->pAccessOwner->AccessCode));
; 940  :         SetLastError(ERROR_INVALID_ACCESS);

  00030	e3a0000c	 mov         r0, #0xC
  00034	eb000000	 bl          SetLastError
  00038		 |$LN24@COM_Open|

; 941  :         return(NULL);

  00038	e3a05000	 mov         r5, #0
  0003c	ea000099	 b           |$LN22@COM_Open|
  00040		 |$LN19@COM_Open|

; 942  :     }
; 943  : 
; 944  :     // OK, lets allocate an open structure
; 945  :     pOpenHead    =  (PHW_OPEN_INFO)LocalAlloc(LPTR, sizeof(HW_OPEN_INFO));

  00040	e3a0103c	 mov         r1, #0x3C
  00044	e3a00040	 mov         r0, #0x40
  00048	eb000000	 bl          LocalAlloc
  0004c	e1b05000	 movs        r5, r0

; 946  :     if ( !pOpenHead ) {
; 947  :         DEBUGMSG(ZONE_INIT | ZONE_ERROR,
; 948  :                  (TEXT("Error allocating memory for pOpenHead, COM_Open failed\n\r")));
; 949  :         return(NULL);

  00050	0afffff8	 beq         |$LN24@COM_Open|

; 950  :     }
; 951  : 
; 952  :     // Init the structure
; 953  :     pOpenHead->pSerialHead = pSerialHead;  // pointer back to our parent
; 954  :     pOpenHead->StructUsers = 0;

  00054	e3a0b000	 mov         r11, #0

; 955  :     pOpenHead->AccessCode = AccessCode;
; 956  :     pOpenHead->ShareMode = ShareMode;
; 957  :     pOpenHead->CommEvents.hCommEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  00058	e3a03000	 mov         r3, #0
  0005c	e3a02000	 mov         r2, #0
  00060	e3a01000	 mov         r1, #0
  00064	e3a00000	 mov         r0, #0
  00068	e88508d0	 stmia       r5, {r4, r6, r7, r11}
  0006c	eb000000	 bl          CreateEventW

; 958  :     pOpenHead->CommEvents.fEventMask = 0;
; 959  :     pOpenHead->CommEvents.fEventData = 0;
; 960  :     pOpenHead->CommEvents.fAbort = 0;
; 961  :     InitializeCriticalSection(&(pOpenHead->CommEvents.EventCS));

  00070	e1a03000	 mov         r3, r0
  00074	e2850020	 add         r0, r5, #0x20
  00078	e285c010	 add         r12, r5, #0x10
  0007c	e88c0808	 stmia       r12, {r3, r11}
  00080	e585b018	 str         r11, [r5, #0x18]
  00084	e585b01c	 str         r11, [r5, #0x1C]
  00088	eb000000	 bl          InitializeCriticalSection

; 962  : 
; 963  :     // if we have access permissions, note it in pSerialhead
; 964  :     if ( AccessCode & (GENERIC_READ | GENERIC_WRITE) ) {

  0008c	e3590000	 cmp         r9, #0

; 965  :         DEBUGMSG(ZONE_INIT|ZONE_CLOSE,
; 966  :                  (TEXT("COM_Open: Access permission handle granted x%X\n\r"),
; 967  :                   pOpenHead));
; 968  :         pSerialHead->pAccessOwner = pOpenHead;
; 969  :     }
; 970  : 
; 971  :     // add this open entry to list of open entries.
; 972  :     // Note that we hold the open CS for the duration of the routine since
; 973  :     // all of our state info is in flux during this time.  In particular,
; 974  :     // without the CS is would be possible for an open & close to be going on
; 975  :     // simultaneously and have bad things happen like spinning a new event
; 976  :     // thread before the old one was gone, etc.
; 977  :     EnterCriticalSection(&(pSerialHead->OpenCS));

  00090	e28400ec	 add         r0, r4, #0xEC
  00094	15845100	 strne       r5, [r4, #0x100]
  00098	eb000000	 bl          EnterCriticalSection

; 978  :     InsertHeadList(&pSerialHead->OpenList,
; 979  :                    &pOpenHead->llist);

  0009c	e1a02004	 mov         r2, r4
  000a0	e5b230e4	 ldr         r3, [r2, #0xE4]!
  000a4	e2856034	 add         r6, r5, #0x34
  000a8	e5853034	 str         r3, [r5, #0x34]
  000ac	e5852038	 str         r2, [r5, #0x38]
  000b0	e5836004	 str         r6, [r3, #4]
  000b4	e5826000	 str         r6, [r2]

; 980  : 
; 981  :     // We do special for Power Manger and Device Manager.
; 982  :     if ((pOpenHead->AccessCode &  DEVACCESS_BUSNAMESPACE) || (ShareMode & DEVACCESS_PMEXT_MODE) ) {

  000b8	e5953004	 ldr         r3, [r5, #4]
  000bc	e3130c01	 tst         r3, #1, 24
  000c0	1a000076	 bne         |$LN12@COM_Open|
  000c4	e3170102	 tst         r7, #2, 2
  000c8	1a000074	 bne         |$LN12@COM_Open|

; 983  :         // OK, We do not need initialize pSerailHead and start any thread. return the handle now.
; 984  :         LeaveCriticalSection(&(pSerialHead->OpenCS));
; 985  :         DEBUGMSG (ZONE_OPEN|ZONE_FUNCTION, (TEXT("-COM_Open handle x%X, x%X, Ref x%X\r\n"),
; 986  :                                         pOpenHead, pOpenHead->pSerialHead, pSerialHead->OpenCnt));
; 987  :         return(pOpenHead);
; 988  : 
; 989  :     }
; 990  :     //
; 991  : 
; 992  :     // If port not yet opened, we need to do some init
; 993  :     if ( ! pSerialHead->OpenCnt ) {

  000cc	e5943090	 ldr         r3, [r4, #0x90]
  000d0	e3530000	 cmp         r3, #0
  000d4	1a00006e	 bne         |$LN11@COM_Open|

; 994  :         DEBUGMSG(ZONE_INIT|ZONE_OPEN,
; 995  :                  (TEXT("COM_Open: First open : Do Init x%X\n\r"),
; 996  :                   pOpenHead));
; 997  : 
; 998  :         if ( pSerialHead->pHWObj->BindFlags & THREAD_AT_OPEN ) {

  000d8	e5943028	 ldr         r3, [r4, #0x28]
  000dc	e5933000	 ldr         r3, [r3]
  000e0	e3130002	 tst         r3, #2
  000e4	0a000003	 beq         |$LN9@COM_Open|

; 999  :             DEBUGMSG(ZONE_INIT|ZONE_OPEN,
; 1000 :                      (TEXT("COM_Open: Starting DispatchThread x%X\n\r"),
; 1001 :                       pOpenHead));
; 1002 :             // Hook the interrupt and start the associated thread.
; 1003 :             if ( ! StartDispatchThread( pSerialHead ) ) {

  000e8	e1a00004	 mov         r0, r4
  000ec	eb000000	 bl          StartDispatchThread
  000f0	e3500000	 cmp         r0, #0
  000f4	0a00003e	 beq         |$OpenFail$40353|
  000f8		 |$LN9@COM_Open|

; 1004 :                 // Failed on InterruptInitialize or CreateThread.  Bail.
; 1005 :                 DEBUGMSG(ZONE_INIT|ZONE_OPEN,
; 1006 :                          (TEXT("COM_Open: Failed StartDispatchThread x%X\n\r"),
; 1007 :                           pOpenHead));
; 1008 :                 goto OpenFail;
; 1009 :             }
; 1010 :         }
; 1011 : 
; 1012 :         pSerialHead->RxBytes = 0;
; 1013 :         pSerialHead->TxBytes = 0;
; 1014 :         pSerialHead->TxBytesPending = 0;
; 1015 :         pSerialHead->DroppedBytesMDD = 0;
; 1016 :         pSerialHead->DroppedBytesPDD = 0;
; 1017 : 
; 1018 :         pSerialHead->DCB.DCBlength  = sizeof(DCB);
; 1019 :         pSerialHead->DCB.BaudRate   = 9600;
; 1020 :         pSerialHead->DCB.fBinary    = TRUE;
; 1021 :         pSerialHead->DCB.fParity    = FALSE;
; 1022 : 
; 1023 :         pSerialHead->DCB.fOutxCtsFlow = FALSE;
; 1024 :         pSerialHead->DCB.fOutxDsrFlow = FALSE;
; 1025 :         pSerialHead->DCB.fDtrControl = DTR_CONTROL_ENABLE;
; 1026 :         pSerialHead->DCB.fDsrSensitivity = FALSE;
; 1027 :         pSerialHead->DCB.fTXContinueOnXoff = FALSE;
; 1028 :         pSerialHead->DCB.fOutX      = FALSE;
; 1029 :         pSerialHead->DCB.fInX       = FALSE;
; 1030 :         pSerialHead->DCB.fErrorChar = FALSE; //NOTE: ignored
; 1031 :         pSerialHead->DCB.fNull      = FALSE; //NOTE: ignored
; 1032 :         pSerialHead->DCB.fRtsControl = RTS_CONTROL_ENABLE;
; 1033 :         pSerialHead->DCB.fAbortOnError = FALSE; //NOTE: ignored
; 1034 : 
; 1035 :         pSerialHead->DCB.XonLim     = (WORD)((pSerialHead->RxBufferInfo.Length) >> 1) ; // Line up with XP code.

  000f8	e59400a4	 ldr         r0, [r4, #0xA4]
  000fc	e5941068	 ldr         r1, [r4, #0x68]
  00100	e3e02c7f	 mvn         r2, #0x7F, 24

; 1036 :         pSerialHead->DCB.XoffLim    = (WORD)((pSerialHead->RxBufferInfo.Length) >> 3) ;

  00104	e22220ff	 eor         r2, r2, #0xFF
  00108	e1a031a0	 mov         r3, r0, lsr #3
  0010c	e0011002	 and         r1, r1, r2
  00110	e1a0e803	 mov         lr, r3, lsl #16
  00114	e1a020a0	 mov         r2, r0, lsr #1
  00118	e3a07a01	 mov         r7, #1, 20
  0011c	e1a0e82e	 mov         lr, lr, lsr #16

; 1037 :         if ( pSerialHead->RxBufferInfo.Length - pSerialHead->DCB.XoffLim <= pSerialHead->DCB.XonLim ) { // Checking for illgle value

  00120	e1a02802	 mov         r2, r2, lsl #16
  00124	e3873011	 orr         r3, r7, #0x11
  00128	e040000e	 sub         r0, r0, lr
  0012c	e1a02822	 mov         r2, r2, lsr #16
  00130	e1813003	 orr         r3, r1, r3
  00134	e1500002	 cmp         r0, r2
  00138	e5843068	 str         r3, [r4, #0x68]

; 1038 :             pSerialHead->DCB.XonLim  = (WORD)(pSerialHead->RxBufferInfo.Length - pSerialHead->DCB.XoffLim -1)  ;

  0013c	92803cff	 addls       r3, r0, #0xFF, 24
  00140	928330ff	 addls       r3, r3, #0xFF
  00144	e1c426be	 strh        r2, [r4, #0x6E]
  00148	91c436be	 strlsh      r3, [r4, #0x6E]

; 1039 :         }
; 1040 : 
; 1041 :         pSerialHead->DCB.ByteSize   = 8;
; 1042 :         pSerialHead->DCB.Parity     = NOPARITY;
; 1043 :         pSerialHead->DCB.StopBits   = ONESTOPBIT;
; 1044 : 
; 1045 :         pSerialHead->DCB.XonChar    = X_ON_CHAR;
; 1046 :         pSerialHead->DCB.XoffChar   = X_OFF_CHAR;
; 1047 :         pSerialHead->DCB.ErrorChar  = ERROR_CHAR;
; 1048 :         pSerialHead->DCB.EofChar    = E_OF_CHAR;
; 1049 :         pSerialHead->DCB.EvtChar    = EVENT_CHAR;
; 1050 : 
; 1051 :         pSerialHead->StopXmit = 0;
; 1052 :         pSerialHead->SentXoff = 0;
; 1053 :         pSerialHead->DtrFlow = 0;
; 1054 :         pSerialHead->RtsFlow = 0;

  0014c	e5943094	 ldr         r3, [r4, #0x94]
  00150	e3a0701c	 mov         r7, #0x1C
  00154	e3a09d96	 mov         r9, #0x96, 26
  00158	e5847060	 str         r7, [r4, #0x60]
  0015c	e5849064	 str         r9, [r4, #0x64]
  00160	e1c4e7b0	 strh        lr, [r4, #0x70]
  00164	e3c3303c	 bic         r3, r3, #0x3C
  00168	e3a0e008	 mov         lr, #8
  0016c	e3a07011	 mov         r7, #0x11
  00170	e3a09013	 mov         r9, #0x13
  00174	e3a0a00d	 mov         r10, #0xD

; 1055 : 
; 1056 :         ApplyDCB (pSerialHead, &(pSerialHead->DCB), FALSE);

  00178	e3a02000	 mov         r2, #0
  0017c	e2841060	 add         r1, r4, #0x60
  00180	e1a00004	 mov         r0, r4
  00184	e5843094	 str         r3, [r4, #0x94]
  00188	e584b050	 str         r11, [r4, #0x50]
  0018c	e584b054	 str         r11, [r4, #0x54]
  00190	e584b058	 str         r11, [r4, #0x58]
  00194	e584b048	 str         r11, [r4, #0x48]
  00198	e584b04c	 str         r11, [r4, #0x4C]
  0019c	e5c4e072	 strb        lr, [r4, #0x72]
  001a0	e5c4b073	 strb        r11, [r4, #0x73]
  001a4	e5c4b074	 strb        r11, [r4, #0x74]
  001a8	e5c47075	 strb        r7, [r4, #0x75]
  001ac	e5c49076	 strb        r9, [r4, #0x76]
  001b0	e5c4a077	 strb        r10, [r4, #0x77]
  001b4	e5c4a078	 strb        r10, [r4, #0x78]
  001b8	e5c4a079	 strb        r10, [r4, #0x79]
  001bc	eb000000	 bl          ApplyDCB

; 1057 : 
; 1058 :         pHWObj->pFuncTbl->HWSetCommTimeouts(pSerialHead->pHWHead,
; 1059 :                                             &(pSerialHead->CommTimeouts));

  001c0	e5983008	 ldr         r3, [r8, #8]
  001c4	e594002c	 ldr         r0, [r4, #0x2C]
  001c8	e284107c	 add         r1, r4, #0x7C
  001cc	e5933070	 ldr         r3, [r3, #0x70]
  001d0	e1a0e00f	 mov         lr, pc
  001d4	e12fff13	 bx          r3

; 1060 : 
; 1061 :         if ( !pHWObj->pFuncTbl->HWOpen(pSerialHead->pHWHead) ) {

  001d8	e5983008	 ldr         r3, [r8, #8]
  001dc	e594002c	 ldr         r0, [r4, #0x2C]
  001e0	e593300c	 ldr         r3, [r3, #0xC]
  001e4	e1a0e00f	 mov         lr, pc
  001e8	e12fff13	 bx          r3
  001ec	e3500000	 cmp         r0, #0
  001f0	1a000016	 bne         |$LN7@COM_Open|
  001f4		 |$OpenFail$40353|

; 1081 : 
; 1082 :     DEBUGMSG (ZONE_OPEN|ZONE_FUNCTION, (TEXT("-COM_Open handle x%X, x%X, Ref x%X\r\n"),
; 1083 :                                         pOpenHead, pOpenHead->pSerialHead, pSerialHead->OpenCnt));
; 1084 : 
; 1085 :     return(pOpenHead);
; 1086 : 
; 1087 :     OpenFail :
; 1088 :     DEBUGMSG (ZONE_OPEN|ZONE_FUNCTION, (TEXT("-COM_Open handle x%X, x%X, Ref x%X\r\n"),
; 1089 :                                         NULL, pOpenHead->pSerialHead, pSerialHead->OpenCnt));
; 1090 : 
; 1091 :     SetLastError(ERROR_OPEN_FAILED);

  001f4	e3a0006e	 mov         r0, #0x6E
  001f8	eb000000	 bl          SetLastError

; 1092 : 
; 1093 :     // If this was the handle with access permission, remove pointer
; 1094 :     if ( pOpenHead == pSerialHead->pAccessOwner )

  001fc	e5943100	 ldr         r3, [r4, #0x100]

; 1095 :         pSerialHead->pAccessOwner = NULL;
; 1096 : 
; 1097 :     // Remove the Open entry from the linked list
; 1098 :     RemoveEntryList(&pOpenHead->llist);
; 1099 : 
; 1100 :     // OK, everything is stable so release the critical section
; 1101 :     LeaveCriticalSection(&(pSerialHead->OpenCS));

  00200	e28400ec	 add         r0, r4, #0xEC
  00204	e1550003	 cmp         r5, r3
  00208	0584b100	 streq       r11, [r4, #0x100]
  0020c	e5962004	 ldr         r2, [r6, #4]
  00210	e5963000	 ldr         r3, [r6]
  00214	e5823000	 str         r3, [r2]
  00218	e5962000	 ldr         r2, [r6]
  0021c	e5963004	 ldr         r3, [r6, #4]
  00220	e5823004	 str         r3, [r2, #4]
  00224	eb000000	 bl          LeaveCriticalSection

; 1102 : 
; 1103 :     // Free all data allocated in open
; 1104 :     if ( pOpenHead->CommEvents.hCommEvent )

  00228	e5953010	 ldr         r3, [r5, #0x10]
  0022c	e3530000	 cmp         r3, #0

; 1105 :         CloseHandle(pOpenHead->CommEvents.hCommEvent);

  00230	11a00003	 movne       r0, r3
  00234	1b000000	 blne        CloseHandle

; 1106 :     DeleteCriticalSection(&(pOpenHead->CommEvents.EventCS));

  00238	e2850020	 add         r0, r5, #0x20
  0023c	eb000000	 bl          DeleteCriticalSection

; 1107 :     LocalFree( pOpenHead );

  00240	e1a00005	 mov         r0, r5
  00244	eb000000	 bl          LocalFree
  00248	e3a05000	 mov         r5, #0
  0024c	ea000015	 b           |$LN22@COM_Open|
  00250		 |$LN7@COM_Open|

; 1062 :             DEBUGMSG (ZONE_OPEN|ZONE_ERROR, (TEXT("HW Open failed.\r\n")));
; 1063 :             goto OpenFail;
; 1064 :         }
; 1065 : 
; 1066 :         pHWObj->pFuncTbl->HWPurgeComm(pSerialHead->pHWHead, PURGE_RXCLEAR);

  00250	e5983008	 ldr         r3, [r8, #8]
  00254	e594002c	 ldr         r0, [r4, #0x2C]
  00258	e3a01008	 mov         r1, #8
  0025c	e5933068	 ldr         r3, [r3, #0x68]
  00260	e1a0e00f	 mov         lr, pc
  00264	e12fff13	 bx          r3

; 1067 :         memset(pSerialHead->RxBufferInfo.RxCharBuffer, 0, pSerialHead->RxBufferInfo.Length);

  00268	e59420a4	 ldr         r2, [r4, #0xA4]
  0026c	e59400ac	 ldr         r0, [r4, #0xAC]
  00270	e3a01000	 mov         r1, #0
  00274	eb000000	 bl          memset

; 1068 : 
; 1069 :         if ( pHWObj->BindFlags & THREAD_IN_MDD ) {

  00278	e5983000	 ldr         r3, [r8]
  0027c	e3130003	 tst         r3, #3

; 1070 :             CeSetThreadPriority(pSerialHead->pDispatchThread,
; 1071 :                                 pSerialHead->Priority256);

  00280	15941044	 ldrne       r1, [r4, #0x44]
  00284	15940040	 ldrne       r0, [r4, #0x40]
  00288	1b000000	 blne        CeSetThreadPriority

; 1072 :         }
; 1073 : 
; 1074 :         RxResetFifo (pSerialHead);

  0028c	e584b09c	 str         r11, [r4, #0x9C]
  00290	e584b0a0	 str         r11, [r4, #0xA0]
  00294		 |$LN11@COM_Open|

; 1075 :     }
; 1076 : 
; 1077 :     ++(pSerialHead->OpenCnt);

  00294	e5943090	 ldr         r3, [r4, #0x90]

; 1078 : 
; 1079 :     // OK, we are finally back in a stable state.  Release the CS.
; 1080 :     LeaveCriticalSection(&(pSerialHead->OpenCS));

  00298	e2833001	 add         r3, r3, #1
  0029c	e5843090	 str         r3, [r4, #0x90]
  002a0		 |$LN12@COM_Open|
  002a0	e28400ec	 add         r0, r4, #0xEC
  002a4	eb000000	 bl          LeaveCriticalSection
  002a8		 |$LN22@COM_Open|

; 1108 : 
; 1109 :     return(NULL);
; 1110 : 
; 1111 : 
; 1112 : }

  002a8	e1a00005	 mov         r0, r5
  002ac	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  002b0	e12fff1e	 bx          lr
  002b4		 |$M41721|

			 ENDP  ; |COM_Open|

	EXPORT	|COM_Write|
	IMPORT	|CeFreeAsynchronousBuffer|
	IMPORT	|CeAllocAsynchronousBuffer|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T41746| DCD	|$LN21@COM_Write|
	DCD	0x40006e02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\serial\com_mdd2\mdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |COM_Write| PROC

; 1657 : {

  00000		 |$LN21@COM_Write|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M41743|
  00008	e1a05002	 mov         r5, r2
  0000c	e1a07001	 mov         r7, r1
  00010	e1a06000	 mov         r6, r0

; 1658 :     PHW_OPEN_INFO   pOpenHead = (PHW_OPEN_INFO)pHead;
; 1659 :     PHW_INDEP_INFO  pSerialHead = pOpenHead->pSerialHead;

  00014	e5963000	 ldr         r3, [r6]

; 1660 :     ULONG               BytesWritten   = 0;
; 1661 :     ULONG               TotalWritten   = 0;
; 1662 :     PHWOBJ              pHWObj         = NULL;
; 1663 :     PVOID               pHWHead        = NULL;
; 1664 :     PHW_VTBL            pFuncTbl       = NULL;
; 1665 :     ULONG               TotalTimeout;   // The Total Timeout
; 1666 :     ULONG               Timeout;        // The Timeout value actually used
; 1667 :     ULONG               WaitReturn;
; 1668 :     PUCHAR              pvMapped = NULL;

  00018	e3a02000	 mov         r2, #0
  0001c	e58d2000	 str         r2, [sp]
  00020	e1b04003	 movs        r4, r3

; 1669 :     
; 1670 :     DEBUGMSG (ZONE_WRITE|ZONE_FUNCTION,
; 1671 :               (TEXT("+COM_WRITE(0x%X, 0x%X, %d)\r\n"), pHead,
; 1672 :                pSourceBytes, NumberOfBytes));
; 1673 : 
; 1674 : 
; 1675 :     // Check validity of handle
; 1676 :     if ( !pSerialHead || !pSerialHead->OpenCnt ) {

  00024	0a00005d	 beq         |$LN12@COM_Write|
  00028	e5943090	 ldr         r3, [r4, #0x90]
  0002c	e3530000	 cmp         r3, #0
  00030	0a00005a	 beq         |$LN12@COM_Write|

; 1681 :     }
; 1682 : 
; 1683 :     // Make sure the caller has access permissions
; 1684 :     if ( !(pOpenHead->AccessCode & GENERIC_WRITE) ) {

  00034	e5963004	 ldr         r3, [r6, #4]
  00038	e3130101	 tst         r3, #1, 2

; 1685 :         DEBUGMSG(ZONE_USR_READ|ZONE_ERROR,
; 1686 :                  (TEXT("COM_Write: Access permission failure x%X\n\r"),
; 1687 :                   pOpenHead->AccessCode));
; 1688 :         SetLastError (ERROR_INVALID_ACCESS);

  0003c	03a0000c	 moveq       r0, #0xC
  00040	0a000057	 beq         |$LN18@COM_Write|

; 1689 :         return(ULONG)-1;
; 1690 :     }
; 1691 : 
; 1692 :     if ( pSourceBytes == NULL ||  NumberOfBytes == 0 ) {

  00044	e3570000	 cmp         r7, #0
  00048	0a000052	 beq         |$LN9@COM_Write|
  0004c	e3550000	 cmp         r5, #0
  00050	0a000050	 beq         |$LN9@COM_Write|

; 1697 :     }
; 1698 :     // Mapping Memory Because IST access it.
; 1699 :     if (!SUCCEEDED(CeAllocAsynchronousBuffer(&pvMapped, pSourceBytes, NumberOfBytes, ARG_I_PTR )) || pvMapped == NULL) {

  00054	e3a03004	 mov         r3, #4
  00058	e1a02005	 mov         r2, r5
  0005c	e1a01007	 mov         r1, r7
  00060	e28d0000	 add         r0, sp, #0
  00064	eb000000	 bl          CeAllocAsynchronousBuffer
  00068	e3500000	 cmp         r0, #0
  0006c	4a00004d	 bmi         |$LN7@COM_Write|
  00070	e59d3000	 ldr         r3, [sp]
  00074	e3530000	 cmp         r3, #0
  00078	0a00004a	 beq         |$LN7@COM_Write|

; 1700 :         DEBUGMSG (ZONE_WRITE|ZONE_ERROR,
; 1701 :             (TEXT("COM_Write CeAllocAsynchronousBuffer Error (%d)\r\n"),GetLastError()));
; 1702 :         ASSERT(FALSE);
; 1703 :         return (ULONG) -1;
; 1704 :     }
; 1705 : 
; 1706 :     COM_INC_USAGE_CNT(pOpenHead);

  0007c	e286000c	 add         r0, r6, #0xC
  00080	eb000000	 bl          InterlockedIncrement

; 1707 : 
; 1708 :     pHWObj   = pSerialHead->pHWObj;
; 1709 :     pHWHead  = pSerialHead->pHWHead;
; 1710 :     pFuncTbl = pHWObj->pFuncTbl;

  00084	e5943028	 ldr         r3, [r4, #0x28]

; 1711 : 
; 1712 :     /* Lock out other threads from messing with these pointers.
; 1713 :      */
; 1714 :     DEBUGMSG (ZONE_WRITE, (TEXT("COM_Write wait for CritSec %x.\r\n"),
; 1715 :                            &(pSerialHead->TransmitCritSec1)));
; 1716 :     EnterCriticalSection(&(pSerialHead->TransmitCritSec1));

  00088	e594802c	 ldr         r8, [r4, #0x2C]
  0008c	e1a00004	 mov         r0, r4
  00090	e5939008	 ldr         r9, [r3, #8]
  00094	eb000000	 bl          EnterCriticalSection

; 1717 :     DEBUGMSG (ZONE_WRITE, (TEXT("COM_Write Got CritSec %x.\r\n"),
; 1718 :                            &(pSerialHead->TransmitCritSec1)));
; 1719 : 
; 1720 :     DEBUGMSG (ZONE_WRITE, (TEXT("COM_Write wait for CritSec %x.\r\n"),
; 1721 :                            &(pSerialHead->TxBufferInfo.CS)));
; 1722 :     TxEnterCS(pSerialHead);

  00098	e28400d0	 add         r0, r4, #0xD0
  0009c	eb000000	 bl          EnterCriticalSection

; 1723 :     DEBUGMSG (ZONE_WRITE, (TEXT("COM_Write got CritSec %x.\r\n"),
; 1724 :                            &(pSerialHead->TxBufferInfo.CS)));
; 1725 : 
; 1726 :     pSerialHead->fAbortTransmit = 0;

  000a0	e5943094	 ldr         r3, [r4, #0x94]

; 1727 :     // Clear any pending event
; 1728 :     WaitForSingleObject(pSerialHead->hTransmitEvent,0);

  000a4	e594003c	 ldr         r0, [r4, #0x3C]
  000a8	e3a01000	 mov         r1, #0
  000ac	e3c33080	 bic         r3, r3, #0x80
  000b0	e5843094	 str         r3, [r4, #0x94]
  000b4	eb000000	 bl          WaitForSingleObject

; 1729 :     pSerialHead->TxBufferInfo.TxCharBuffer = pvMapped ;

  000b8	e59d3000	 ldr         r3, [sp]

; 1730 :     pSerialHead->TxBufferInfo.Length = NumberOfBytes;
; 1731 :     TxRead(pSerialHead) = 0;
; 1732 :     pSerialHead->TxBytesSent = 0;
; 1733 :     pSerialHead->TxBytesPending = NumberOfBytes;
; 1734 : 
; 1735 :     // Make sure an event isn't hanging around from a previous write time out.
; 1736 :     ResetEvent( pSerialHead->hTransmitEvent );

  000bc	e594003c	 ldr         r0, [r4, #0x3C]
  000c0	e3a0a000	 mov         r10, #0
  000c4	e3a01002	 mov         r1, #2
  000c8	e58430cc	 str         r3, [r4, #0xCC]
  000cc	e58450c8	 str         r5, [r4, #0xC8]
  000d0	e584a0c4	 str         r10, [r4, #0xC4]
  000d4	e584a05c	 str         r10, [r4, #0x5C]
  000d8	e5845058	 str         r5, [r4, #0x58]
  000dc	eb000000	 bl          EventModify

; 1737 : 
; 1738 :     TxLeaveCS(pSerialHead);

  000e0	e28400d0	 add         r0, r4, #0xD0
  000e4	eb000000	 bl          LeaveCriticalSection

; 1739 :     DEBUGMSG (ZONE_WRITE|ZONE_FUNCTION,
; 1740 :               (TEXT("COM_Write released CritSec: %x.\r\n"),
; 1741 :                &(pSerialHead->TxBufferInfo.CS)));
; 1742 : 
; 1743 :     // We call the same write routine that a TX_INTR does.  It queus as
; 1744 :     // much data as possible, then returns.  From then on, the normal
; 1745 :     // interrupt mechanism kicks in.
; 1746 :     DoTxData( pSerialHead );

  000e8	e1a00004	 mov         r0, r4
  000ec	eb000000	 bl          DoTxData

; 1747 : 
; 1748 :     TotalTimeout = pSerialHead->CommTimeouts.WriteTotalTimeoutMultiplier*NumberOfBytes +
; 1749 :                    pSerialHead->CommTimeouts.WriteTotalTimeoutConstant;

  000f0	e5942088	 ldr         r2, [r4, #0x88]
  000f4	e594308c	 ldr         r3, [r4, #0x8C]

; 1750 : 
; 1751 :     if ( !TotalTimeout )
; 1752 :         Timeout = INFINITE;
; 1753 :     else
; 1754 :         Timeout = TotalTimeout;
; 1755 : 
; 1756 :     DEBUGMSG (ZONE_WRITE, (TEXT("COM_Write wait for transmission complete event %x.\r\n"),
; 1757 :                            pSerialHead->hTransmitEvent));
; 1758 : 
; 1759 :     WaitReturn = WaitForSingleObject (pSerialHead->hTransmitEvent, Timeout);

  000f8	e594003c	 ldr         r0, [r4, #0x3C]
  000fc	e0313592	 mlas        r1, r2, r5, r3
  00100	03e01000	 mvneq       r1, #0
  00104	eb000000	 bl          WaitForSingleObject

; 1760 : 
; 1761 :     // In the absense of WaitForMultipleObjects, we use flags to
; 1762 :     // handle errors/aborts. Check for aborts or asynchronous closes.
; 1763 :     if ( pSerialHead->fAbortTransmit ) {

  00108	e5943094	 ldr         r3, [r4, #0x94]
  0010c	e3130080	 tst         r3, #0x80

; 1764 :         DEBUGMSG(ZONE_USR_READ,(TEXT("COM_Write - Aborting write\r\n")));
; 1765 :         goto LEAVEWRITE;
; 1766 :     }
; 1767 : 
; 1768 :     if ( !pSerialHead->OpenCnt ) {

  00110	05943090	 ldreq       r3, [r4, #0x90]
  00114	03530000	 cmpeq       r3, #0

; 1769 :         DEBUGMSG(ZONE_WRITE|ZONE_ERROR,
; 1770 :                  (TEXT("COM_Write - device was closed\n\r")));
; 1771 :         SetLastError(ERROR_INVALID_HANDLE);

  00118	03a00006	 moveq       r0, #6
  0011c	0b000000	 bleq        SetLastError
  00120		 |$LEAVEWRITE$40613|

; 1772 :         goto LEAVEWRITE;
; 1773 :     }
; 1774 : 
; 1775 : #ifdef DEBUG
; 1776 :     if ( WAIT_TIMEOUT == WaitReturn ) {
; 1777 :         // Timeout
; 1778 :         DEBUGMSG (ZONE_WARN, (TEXT("Write timeout %d, %d\r\n"), NumberOfBytes, pSerialHead->TxBytesPending));
; 1779 :     } else {
; 1780 :         DEBUGMSG (ZONE_WRITE, (TEXT("COM_Write completed normally.\r\n")));
; 1781 :     }
; 1782 : #endif
; 1783 : 
; 1784 :     LEAVEWRITE:
; 1785 :     // Regardless of timeout, we need to clear the TxBufferInfo
; 1786 :     // to prevent ISR from possibly coming around and trying to use
; 1787 :     // the buffer after we have returned to the caller.
; 1788 :     DEBUGMSG (ZONE_WRITE, (TEXT("COM_Write wait for CritSec %x.\r\n"),
; 1789 :                            &(pSerialHead->TxBufferInfo.CS)));
; 1790 :     TxEnterCS(pSerialHead);

  00120	e28400d0	 add         r0, r4, #0xD0
  00124	eb000000	 bl          EnterCriticalSection

; 1791 :     DEBUGMSG (ZONE_WRITE, (TEXT("COM_Write got CritSec %x.\r\n"),
; 1792 :                            &(pSerialHead->TxBufferInfo.CS)));
; 1793 :     pSerialHead->TxBufferInfo.TxCharBuffer = NULL;
; 1794 :     pSerialHead->TxBufferInfo.Length = 0;
; 1795 :     pSerialHead->TxBytesPending = 0;
; 1796 :     TxRead(pSerialHead) = 0;
; 1797 :     TxLeaveCS(pSerialHead);

  00128	e28400d0	 add         r0, r4, #0xD0
  0012c	e584a0cc	 str         r10, [r4, #0xCC]
  00130	e584a0c8	 str         r10, [r4, #0xC8]
  00134	e584a058	 str         r10, [r4, #0x58]
  00138	e584a0c4	 str         r10, [r4, #0xC4]
  0013c	eb000000	 bl          LeaveCriticalSection

; 1798 :     DEBUGMSG (ZONE_WRITE|ZONE_FUNCTION,
; 1799 :               (TEXT("COM_Write released CritSec: %x.\r\n"),
; 1800 :                &(pSerialHead->TxBufferInfo.CS)));
; 1801 : 
; 1802 : 
; 1803 :     LeaveCriticalSection(&(pSerialHead->TransmitCritSec1));

  00140	e1a00004	 mov         r0, r4
  00144	eb000000	 bl          LeaveCriticalSection

; 1804 :     DEBUGMSG (ZONE_WRITE|ZONE_FUNCTION,
; 1805 :               (TEXT("COM_Write released CritSec: %x. Exiting\r\n"),
; 1806 :                &(pSerialHead->TransmitCritSec1)));
; 1807 : 
; 1808 :     /* OK, the Transmitter has gone empty.
; 1809 :      */
; 1810 :     EvaluateEventFlag(pSerialHead, EV_TXEMPTY);

  00148	e3a01004	 mov         r1, #4
  0014c	e1a00004	 mov         r0, r4
  00150	eb000000	 bl          EvaluateEventFlag

; 1811 : 
; 1812 :     if ( pSerialHead->DCB.fRtsControl == RTS_CONTROL_TOGGLE ) {

  00154	e5943068	 ldr         r3, [r4, #0x68]
  00158	e2033a03	 and         r3, r3, #3, 20
  0015c	e3530a03	 cmp         r3, #3, 20

; 1813 :         pFuncTbl->HWClearRTS(pHWHead);

  00160	0599303c	 ldreq       r3, [r9, #0x3C]
  00164	01a00008	 moveq       r0, r8
  00168	01a0e00f	 moveq       lr, pc
  0016c	012fff13	 bxeq        r3

; 1814 :     }
; 1815 : 
; 1816 :     COM_DEC_USAGE_CNT(pOpenHead);

  00170	e286000c	 add         r0, r6, #0xC
  00174	eb000000	 bl          InterlockedDecrement

; 1817 :     if (pvMapped) {

  00178	e59d0000	 ldr         r0, [sp]
  0017c	e3500000	 cmp         r0, #0

; 1818 :         HRESULT hResult= CeFreeAsynchronousBuffer(pvMapped,pSourceBytes,NumberOfBytes,ARG_I_PTR) ;

  00180	13a03004	 movne       r3, #4
  00184	11a02005	 movne       r2, r5
  00188	11a01007	 movne       r1, r7
  0018c	1b000000	 blne        CeFreeAsynchronousBuffer

; 1819 :         ASSERT(SUCCEEDED(hResult));
; 1820 :     }
; 1821 :     DEBUGMSG (ZONE_WRITE|ZONE_FUNCTION,
; 1822 :               (TEXT("-COM_WRITE, returning %d\n\r"),pSerialHead->TxBytesSent));
; 1823 :     return(pSerialHead->TxBytesSent);

  00190	e594005c	 ldr         r0, [r4, #0x5C]
  00194	ea000004	 b           |$LN14@COM_Write|
  00198		 |$LN9@COM_Write|

; 1693 :         DEBUGMSG (ZONE_WRITE|ZONE_ERROR,
; 1694 :                   (TEXT("COM_WRITE, bad  pointer(0x%x) or length(0x%x)\r\n"), pSourceBytes, NumberOfBytes));
; 1695 :         SetLastError(ERROR_INVALID_PARAMETER);

  00198	e3a00057	 mov         r0, #0x57

; 1696 :         return(ULONG)-1;

  0019c	ea000000	 b           |$LN18@COM_Write|
  001a0		 |$LN12@COM_Write|

; 1677 :         DEBUGMSG (ZONE_WRITE|ZONE_ERROR,
; 1678 :                   (TEXT("COM_WRITE, device not open\r\n") ));
; 1679 :         SetLastError (ERROR_INVALID_HANDLE);

  001a0	e3a00006	 mov         r0, #6
  001a4		 |$LN18@COM_Write|
  001a4	eb000000	 bl          SetLastError
  001a8		 |$LN7@COM_Write|

; 1680 :         return(ULONG)-1;

  001a8	e3e00000	 mvn         r0, #0
  001ac		 |$LN14@COM_Write|

; 1824 : }

  001ac	e28dd004	 add         sp, sp, #4
  001b0	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  001b4	e12fff1e	 bx          lr
  001b8		 |$M41744|

			 ENDP  ; |COM_Write|

	END
