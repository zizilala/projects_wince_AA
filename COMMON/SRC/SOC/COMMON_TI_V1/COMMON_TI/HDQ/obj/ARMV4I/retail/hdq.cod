; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\HDQ\hdq.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1CA@CCIKILKA@?$AAA?$AAc?$AAt?$AAi?$AAv?$AAi?$AAt?$AAy?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BE@DIEKGMHP@?$AAR?$AAx?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BE@LMGJPBKK@?$AAT?$AAx?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@KPFHKDCL@?$AAB?$AAr?$AAe?$AAa?$AAk?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BC@NEHLNCLJ@?$AAB?$AAu?$AAs?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|DEVICE_IFC_HDQ_GUID| [ DATA ]
	EXPORT	|dpCurSettings| [ DATA ]

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CA@CCIKILKA@?$AAA?$AAc?$AAt?$AAi?$AAv?$AAi?$AAt?$AAy?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB "A"
	DCB	0x0, "c", 0x0, "t", 0x0, "i", 0x0, "v", 0x0, "i", 0x0, "t"
	DCB	0x0, "y", 0x0, "T", 0x0, "i", 0x0, "m", 0x0, "e", 0x0, "o"
	DCB	0x0, "u", 0x0, "t", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@DIEKGMHP@?$AAR?$AAx?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB "R"
	DCB	0x0, "x", 0x0, "T", 0x0, "i", 0x0, "m", 0x0, "e", 0x0, "o"
	DCB	0x0, "u", 0x0, "t", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@LMGJPBKK@?$AAT?$AAx?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB "T"
	DCB	0x0, "x", 0x0, "T", 0x0, "i", 0x0, "m", 0x0, "e", 0x0, "o"
	DCB	0x0, "u", 0x0, "t", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@KPFHKDCL@?$AAB?$AAr?$AAe?$AAa?$AAk?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB "B"
	DCB	0x0, "r", 0x0, "e", 0x0, "a", 0x0, "k", 0x0, "T", 0x0, "i"
	DCB	0x0, "m", 0x0, "e", 0x0, "o", 0x0, "u", 0x0, "t", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BC@NEHLNCLJ@?$AAB?$AAu?$AAs?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$AA@| DCB "B"
	DCB	0x0, "u", 0x0, "s", 0x0, "I", 0x0, "n", 0x0, "d", 0x0, "e"
	DCB	0x0, "x", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.data|, DATA
|dpCurSettings| DCB "H", 0x0, "D", 0x0, "Q", 0x0, 0x0, 0x0
	%	56
	DCB	"I", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, 0x0, 0x0
	%	54
	DCB	"E", 0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, "s", 0x0
	DCB	0x0, 0x0
	%	50
	DCB	"W", 0x0, "a", 0x0, "r", 0x0, "n", 0x0, "i", 0x0, "n", 0x0
	DCB	"g", 0x0, "s", 0x0, 0x0, 0x0
	%	46
	DCB	"F", 0x0, "u", 0x0, "n", 0x0, "c", 0x0, "t", 0x0, "i", 0x0
	DCB	"o", 0x0, "n", 0x0, 0x0, 0x0
	%	46
	DCB	"I", 0x0, "n", 0x0, "f", 0x0, "o", 0x0, 0x0, 0x0
	%	54
	DCB	"I", 0x0, "S", 0x0, "T", 0x0, 0x0, 0x0
	%	56
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"H", 0x0, "D", 0x0, "Q", 0x0, "_", 0x0, "l", 0x0, "o", 0x0
	DCB	"g", 0x0, 0x0, 0x0
	%	48
	DCD	0x3

  00000			 AREA	 |.rdata|, DATA, READONLY
|DEVICE_IFC_HDQ_GUID| DCD 0x8d6ec8e0
	DCW	0xa631
	DCW	0x4bdc
	DCB	0xbc
	DCB	0xb3
	DCB	0xcc
	DCB	0x5b
	DCB	0xbb
	DCB	0x9b
	DCB	0x62
	DCB	0x4a
|g_deviceRegParams| DCD |??_C@_1BC@NEHLNCLJ@?$AAB?$AAu?$AAs?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x4
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BK@KPFHKDCL@?$AAB?$AAr?$AAe?$AAa?$AAk?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0xc
	DCD	0x4
	DCD	0x3e8
	DCD	|??_C@_1BE@LMGJPBKK@?$AAT?$AAx?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x10
	DCD	0x4
	DCD	0x3e8
	DCD	|??_C@_1BE@DIEKGMHP@?$AAR?$AAx?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x14
	DCD	0x4
	DCD	0x3e8
	DCD	|??_C@_1CA@CCIKILKA@?$AAA?$AAc?$AAt?$AAi?$AAv?$AAi?$AAt?$AAy?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x44
	DCD	0x4
	DCD	0x1
	EXPORT	|ResetEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T36568| DCD	|$LN5@ResetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ResetEvent| PROC

; 223  : _inline BOOL ResetEvent(HANDLE h) {

  00000		 |$LN5@ResetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36565|

; 224  : 	return EventModify(h,EVENT_RESET);

  00004	e3a01002	 mov         r1, #2
  00008	eb000000	 bl          EventModify

; 225  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M36566|

			 ENDP  ; |ResetEvent|

	EXPORT	|SetEvent|

  00000			 AREA	 |.pdata|, PDATA
|$T36578| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36575|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M36576|

			 ENDP  ; |SetEvent|

	EXPORT	|GetCurrentProcessId|
	IMPORT	|__GetUserKData|

  00000			 AREA	 |.pdata|, PDATA
|$T36587| DCD	|$LN5@GetCurrent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentProcessId| PROC

; 373  : _inline DWORD GetCurrentProcessId(void) {

  00000		 |$LN5@GetCurrent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36584|

; 374  :     return __GetUserKData (SYSHANDLE_OFFSET + (SH_CURPROC * sizeof(HANDLE)));

  00004	e3a0000c	 mov         r0, #0xC
  00008	eb000000	 bl          __GetUserKData

; 375  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M36585|

			 ENDP  ; |GetCurrentProcessId|

	EXPORT	|?IsEqualGUID@@YAHABU_GUID@@0@Z|	; IsEqualGUID
	IMPORT	|memcmp|
; File c:\wince600\public\common\sdk\inc\objbase.h

  00000			 AREA	 |.pdata|, PDATA
|$T36601| DCD	|$LN7@IsEqualGUI|
	DCD	0x40000901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsEqualGUID@@YAHABU_GUID@@0@Z| PROC	; IsEqualGUID

; 493  : {

  00000		 |$LN7@IsEqualGUI|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36598|

; 494  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00004	e3a02010	 mov         r2, #0x10
  00008	eb000000	 bl          memcmp
  0000c	e3500000	 cmp         r0, #0
  00010	03a00001	 moveq       r0, #1

; 495  : }

  00014	049de004	 ldreq       lr, [sp], #4

; 494  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00018	13a00000	 movne       r0, #0

; 495  : }

  0001c	149de004	 ldrne       lr, [sp], #4
  00020	e12fff1e	 bx          lr
  00024		 |$M36599|

			 ENDP  ; |?IsEqualGUID@@YAHABU_GUID@@0@Z|, IsEqualGUID

	EXPORT	|?HDQPowerTimerThread@@YAKPAX@Z|	; HDQPowerTimerThread
	IMPORT	|LeaveCriticalSection|
	IMPORT	|EnableDeviceClocks|
	IMPORT	|EnterCriticalSection|
	IMPORT	|WaitForSingleObject|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T36620| DCD	|$LN18@HDQPowerTi|
	DCD	0x40002801
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\hdq\hdq.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HDQPowerTimerThread@@YAKPAX@Z| PROC	; HDQPowerTimerThread

; 157  : {

  00000		 |$LN18@HDQPowerTi|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M36617|
  00004	e1a04000	 mov         r4, r0

; 158  :     DWORD nTimeout = INFINITE;
; 159  :     Device_t *pDevice = (Device_t*)(pv);
; 160  : 
; 161  :     for(;;)
; 162  :         {
; 163  :         WaitForSingleObject(pDevice->hTimerEvent, nTimeout);

  00008	e594004c	 ldr         r0, [r4, #0x4C]
  0000c	e3e01000	 mvn         r1, #0
  00010	eb000000	 bl          WaitForSingleObject

; 164  : 
; 165  :         if (pDevice->bExitThread == TRUE) break;

  00014	e5943054	 ldr         r3, [r4, #0x54]
  00018	e3530001	 cmp         r3, #1
  0001c	0a000019	 beq         |$LN14@HDQPowerTi|
  00020	e3a07004	 mov         r7, #4
  00024	e3a06001	 mov         r6, #1
  00028		 |$LL7@HDQPowerTi|

; 166  : 
; 167  :         // serialize access to power state changes
; 168  :         EnterCriticalSection(&pDevice->cs);

  00028	e2840024	 add         r0, r4, #0x24
  0002c	eb000000	 bl          EnterCriticalSection

; 169  : 
; 170  :         // by the time this thread got the cs hTimerEvent may 
; 171  :         // have gotten resignaled.  Clear the event to  make
; 172  :         // sure the activity timer thread isn't awaken prematurely
; 173  :         //
; 174  :         ResetEvent(pDevice->hTimerEvent);

  00030	e594004c	 ldr         r0, [r4, #0x4C]
  00034	e3a01002	 mov         r1, #2
  00038	eb000000	 bl          EventModify

; 175  : 
; 176  :         // check if we need to reset the timer
; 177  :         if (pDevice->nPowerCounter == 0)

  0003c	e5943058	 ldr         r3, [r4, #0x58]
  00040	e3530000	 cmp         r3, #0
  00044	1a000006	 bne         |$LN4@HDQPowerTi|

; 178  :             {
; 179  :             // We disable the power only when this thread
; 180  :             // wakes-up twice in a row with no power state
; 181  :             // change to D0.  This is achieved by using the
; 182  :             // bDisablePower flag to determine if power state
; 183  :             // changed since the last time this thread woke-up
; 184  :             //
; 185  :             if (pDevice->bDisablePower == TRUE)

  00048	e5943050	 ldr         r3, [r4, #0x50]
  0004c	e3530001	 cmp         r3, #1
  00050	1a00000f	 bne         |$LN3@HDQPowerTi|

; 186  :                 {
; 187  :                 //SetDevicePowerState(pDevice->hParent, D4, 0);
; 188  :                 EnableDeviceClocks(pDevice->dwDeviceId,FALSE);

  00054	e5940008	 ldr         r0, [r4, #8]
  00058	e3a01000	 mov         r1, #0
  0005c	eb000000	 bl          EnableDeviceClocks

; 189  :                 pDevice->nPowerState = D4;

  00060	e5847040	 str         r7, [r4, #0x40]
  00064		 |$LN4@HDQPowerTi|

; 201  :             {
; 202  :             nTimeout = INFINITE;

  00064	e3e05000	 mvn         r5, #0
  00068		 |$LN1@HDQPowerTi|

; 203  :             }
; 204  :         LeaveCriticalSection(&pDevice->cs);

  00068	e2840024	 add         r0, r4, #0x24
  0006c	eb000000	 bl          LeaveCriticalSection
  00070	e594004c	 ldr         r0, [r4, #0x4C]
  00074	e1a01005	 mov         r1, r5
  00078	eb000000	 bl          WaitForSingleObject
  0007c	e5943054	 ldr         r3, [r4, #0x54]
  00080	e3530001	 cmp         r3, #1
  00084	1affffe7	 bne         |$LL7@HDQPowerTi|
  00088		 |$LN14@HDQPowerTi|

; 205  :         }
; 206  : 
; 207  :     return 1;

  00088	e3a00001	 mov         r0, #1

; 208  : }

  0008c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$LN3@HDQPowerTi|

; 190  :                 DEBUGMSG(ZONE_FUNCTION, (L"HDQ SetDevicePowerState(pDevice->hParent, D4, NULL) in the Thread\r\n"));
; 191  :                 nTimeout = INFINITE;
; 192  :                 }
; 193  :             else
; 194  :                 {
; 195  :                 // wait for activity time-out before shutting off power.
; 196  :                 pDevice->bDisablePower = TRUE;
; 197  :                 nTimeout = pDevice->nActivityTimeout;

  00094	e5945044	 ldr         r5, [r4, #0x44]
  00098	e5846050	 str         r6, [r4, #0x50]

; 198  :                 }
; 199  :             }
; 200  :         else

  0009c	eafffff1	 b           |$LN1@HDQPowerTi|
  000a0		 |$M36618|

			 ENDP  ; |?HDQPowerTimerThread@@YAKPAX@Z|, HDQPowerTimerThread

	EXPORT	|?SetHDQPower@@YAHPAUDevice_t@@W4_CEDEVICE_POWER_STATE@@@Z| ; SetHDQPower
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T36635| DCD	|$LN13@SetHDQPowe|
	DCD	0x40002901
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\hdq\hdq.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetHDQPower@@YAHPAUDevice_t@@W4_CEDEVICE_POWER_STATE@@@Z| PROC ; SetHDQPower

; 221  : {

  00000		 |$LN13@SetHDQPowe|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M36632|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 222  :     // enable power when the power state request is D0-D2
; 223  :     EnterCriticalSection(&pDevice->cs);

  0000c	e2850024	 add         r0, r5, #0x24
  00010	eb000000	 bl          EnterCriticalSection

; 224  : 
; 225  :     if (state < D3)

  00014	e3540003	 cmp         r4, #3
  00018	aa00000c	 bge         |$LN6@SetHDQPowe|

; 226  :         {
; 227  :         if (pDevice->nPowerState >= D3)

  0001c	e5953040	 ldr         r3, [r5, #0x40]
  00020	e3a04000	 mov         r4, #0
  00024	e3530003	 cmp         r3, #3
  00028	3a000003	 bcc         |$LN5@SetHDQPowe|

; 228  :             {
; 229  :                 //SetDevicePowerState(pDevice->hParent, D0, NULL);
; 230  :                 EnableDeviceClocks(pDevice->dwDeviceId,TRUE);

  0002c	e5950008	 ldr         r0, [r5, #8]
  00030	e3a01001	 mov         r1, #1
  00034	eb000000	 bl          EnableDeviceClocks

; 231  :                 pDevice->nPowerState = D0;

  00038	e5854040	 str         r4, [r5, #0x40]
  0003c		 |$LN5@SetHDQPowe|

; 232  :             }
; 233  :         pDevice->bDisablePower = FALSE;
; 234  :         pDevice->nPowerCounter++;

  0003c	e5953058	 ldr         r3, [r5, #0x58]
  00040	e5854050	 str         r4, [r5, #0x50]
  00044	e2833001	 add         r3, r3, #1
  00048	e5853058	 str         r3, [r5, #0x58]

; 235  :         }
; 236  :     else 

  0004c	ea00000f	 b           |$LN1@SetHDQPowe|
  00050		 |$LN6@SetHDQPowe|

; 237  :         {
; 238  :         pDevice->nPowerCounter--;

  00050	e5953058	 ldr         r3, [r5, #0x58]
  00054	e2533001	 subs        r3, r3, #1
  00058	e5853058	 str         r3, [r5, #0x58]

; 239  :         if (pDevice->nPowerCounter == 0)

  0005c	1a00000b	 bne         |$LN1@SetHDQPowe|

; 240  :             {
; 241  :             if (pDevice->hTimerEvent != NULL)

  00060	e595304c	 ldr         r3, [r5, #0x4C]
  00064	e3530000	 cmp         r3, #0
  00068	0a000003	 beq         |$LN2@SetHDQPowe|

; 242  :                 {
; 243  :                 SetEvent(pDevice->hTimerEvent);

  0006c	e3a01003	 mov         r1, #3
  00070	e1a00003	 mov         r0, r3
  00074	eb000000	 bl          EventModify

; 244  :                 }
; 245  :             else

  00078	ea000004	 b           |$LN1@SetHDQPowe|
  0007c		 |$LN2@SetHDQPowe|

; 246  :                 {
; 247  :                 //SetDevicePowerState(pDevice->hParent, D4, NULL);
; 248  :                 EnableDeviceClocks(pDevice->dwDeviceId,FALSE);

  0007c	e5950008	 ldr         r0, [r5, #8]
  00080	e3a01000	 mov         r1, #0
  00084	eb000000	 bl          EnableDeviceClocks

; 249  :                 pDevice->nPowerState = D4;

  00088	e3a03004	 mov         r3, #4
  0008c	e5853040	 str         r3, [r5, #0x40]
  00090		 |$LN1@SetHDQPowe|

; 250  :                 DEBUGMSG(ZONE_FUNCTION, (L"HDQ SetDevicePowerState(pDevice->hParent, D4, NULL)\r\n"));
; 251  :                 }
; 252  :             }
; 253  :         }
; 254  :     
; 255  :     LeaveCriticalSection(&pDevice->cs);

  00090	e2850024	 add         r0, r5, #0x24
  00094	eb000000	 bl          LeaveCriticalSection

; 256  :     return TRUE;

  00098	e3a00001	 mov         r0, #1

; 257  : }

  0009c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000a0	e12fff1e	 bx          lr
  000a4		 |$M36633|

			 ENDP  ; |?SetHDQPower@@YAHPAUDevice_t@@W4_CEDEVICE_POWER_STATE@@@Z|, SetHDQPower

	EXPORT	|?TransmitBreak@@YAXPAUInstance_t@@@Z|	; TransmitBreak
	IMPORT	|InterruptDone|

  00000			 AREA	 |.pdata|, PDATA
|$T36644| DCD	|$LN5@TransmitBr|
	DCD	0x40001301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TransmitBreak@@YAXPAUInstance_t@@@Z| PROC ; TransmitBreak

; 269  : {

  00000		 |$LN5@TransmitBr|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M36641|
  00004	e1a05000	 mov         r5, r0

; 270  :     DWORD status;
; 271  :     
; 272  :     DEBUGMSG(ZONE_FUNCTION, (L"+TransmitBreak(x%08x)\r\n", pInstance));
; 273  : 
; 274  :     // set break command to slave
; 275  :     Device_t *pDevice = pInstance->pDevice;

  00008	e5954008	 ldr         r4, [r5, #8]

; 276  :     OUTREG32(&pDevice->pHDQRegs->CTRL_STATUS, 
; 277  :         HDQ_CTRL_INITIALIZE | HDQ_CTRL_GO | HDQ_CTRL_CLOCK_ENABLE | 
; 278  :         pInstance->mode);

  0000c	e5953004	 ldr         r3, [r5, #4]
  00010	e5942018	 ldr         r2, [r4, #0x18]
  00014	e3833034	 orr         r3, r3, #0x34
  00018	e582300c	 str         r3, [r2, #0xC]

; 279  : 
; 280  :     // wait for timeout
; 281  :     WaitForSingleObject(pDevice->hIntrEvent, pDevice->breakTimeout);

  0001c	e594100c	 ldr         r1, [r4, #0xC]
  00020	e594003c	 ldr         r0, [r4, #0x3C]
  00024	eb000000	 bl          WaitForSingleObject

; 282  :         
; 283  :     // Clear interrupt.
; 284  :     status = INREG32(&pDevice->pHDQRegs->INT_STATUS);

  00028	e5943018	 ldr         r3, [r4, #0x18]

; 285  :     InterruptDone(pDevice->sysIntr);

  0002c	e5940038	 ldr         r0, [r4, #0x38]
  00030	e5933010	 ldr         r3, [r3, #0x10]
  00034	eb000000	 bl          InterruptDone

; 286  : 
; 287  :     DEBUGMSG(ZONE_INFO, (L"TransmitBreak: status = 0x%02X\r\n", status));
; 288  : 
; 289  :     // disable clock and reset to mode
; 290  :     OUTREG32(&pDevice->pHDQRegs->CTRL_STATUS, pInstance->mode);

  00038	e5942018	 ldr         r2, [r4, #0x18]
  0003c	e5953004	 ldr         r3, [r5, #4]
  00040	e582300c	 str         r3, [r2, #0xC]

; 291  : 
; 292  :     DEBUGMSG(ZONE_FUNCTION, (L"-TransmitBreak()\r\n"));
; 293  : }

  00044	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00048	e12fff1e	 bx          lr
  0004c		 |$M36642|

			 ENDP  ; |?TransmitBreak@@YAXPAUInstance_t@@@Z|, TransmitBreak

	EXPORT	|?TransmitCommand@@YAHPAUInstance_t@@EPAK@Z| ; TransmitCommand

  00000			 AREA	 |.pdata|, PDATA
|$T36661| DCD	|$LN10@TransmitCo|
	DCD	0x40001f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TransmitCommand@@YAHPAUInstance_t@@EPAK@Z| PROC ; TransmitCommand

; 308  : {

  00000		 |$LN10@TransmitCo|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M36658|
  00004	e1a06002	 mov         r6, r2
  00008	e1a05000	 mov         r5, r0

; 309  :     DWORD mask;
; 310  :     BOOL rc = FALSE;
; 311  :     Device_t *pDevice = pInstance->pDevice;

  0000c	e5957008	 ldr         r7, [r5, #8]

; 312  :     OMAP_HDQ_1WIRE_REGS *pHDQRegs = pDevice->pHDQRegs;
; 313  : 
; 314  :     DEBUGMSG(ZONE_FUNCTION, (L"+TransmitCommand(cmd=0x%02X)\r\n", cmd));
; 315  : 
; 316  :     // setup mask
; 317  :     mask = HDQ_CTRL_GO | HDQ_CTRL_WRITE | 
; 318  :            HDQ_CTRL_CLOCK_ENABLE | pInstance->mode;

  00010	e5953004	 ldr         r3, [r5, #4]
  00014	e3a04000	 mov         r4, #0
  00018	e5978018	 ldr         r8, [r7, #0x18]
  0001c	e3833030	 orr         r3, r3, #0x30

; 319  :     
; 320  :     // write the command
; 321  :     OUTREG32(&pHDQRegs->TX_DATA, cmd);

  00020	e5881004	 str         r1, [r8, #4]

; 322  : 
; 323  :     // send signal to write
; 324  :     OUTREG32(&pHDQRegs->CTRL_STATUS, mask);

  00024	e588300c	 str         r3, [r8, #0xC]

; 325  :             
; 326  :     // Wait on TX complete interrupt.
; 327  :     if (WaitForSingleObject(pDevice->hIntrEvent, 
; 328  :         pDevice->txTimeout) == WAIT_TIMEOUT) 

  00028	e5971010	 ldr         r1, [r7, #0x10]
  0002c	e597003c	 ldr         r0, [r7, #0x3C]
  00030	eb000000	 bl          WaitForSingleObject
  00034	e3a03c01	 mov         r3, #1, 24
  00038	e3833002	 orr         r3, r3, #2
  0003c	e1500003	 cmp         r0, r3

; 329  :         {
; 330  :         DEBUGMSG(ZONE_ERROR && ZONE_HDQ, (L"ERROR: TransmitCommand: "
; 331  :             L"Timeout in Tx\r\n"
; 332  :             ));
; 333  :         TransmitBreak(pInstance);

  00040	0a000006	 beq         |$LN7@TransmitCo|

; 334  :         goto cleanUp;
; 335  :         }
; 336  :     
; 337  :     // Clear interrupt.
; 338  :     *pStatus = INREG32(&pHDQRegs->INT_STATUS);

  00044	e5983010	 ldr         r3, [r8, #0x10]
  00048	e5863000	 str         r3, [r6]

; 339  :     InterruptDone(pDevice->sysIntr);

  0004c	e5970038	 ldr         r0, [r7, #0x38]
  00050	eb000000	 bl          InterruptDone

; 340  : 
; 341  :     DEBUGMSG(ZONE_INFO, (L"TransmitCommand: *pStatus = 0x%02X\r\n", *pStatus));
; 342  :     
; 343  :     // Verify interrupt source
; 344  :     if ((*pStatus & HDQ_INT_TX_COMPLETE) == 0) 

  00054	e5963000	 ldr         r3, [r6]
  00058	e3130004	 tst         r3, #4
  0005c	1a000002	 bne         |$LN2@TransmitCo|
  00060		 |$LN7@TransmitCo|

; 345  :         {
; 346  :         DEBUGMSG(ZONE_ERROR && ZONE_HDQ, (L"ERROR: TransmitCommand: "
; 347  :             L"TX complete expected (0x%x)\r\n", *pStatus
; 348  :             ));
; 349  :         TransmitBreak(pInstance);

  00060	e1a00005	 mov         r0, r5
  00064	eb000000	 bl          |?TransmitBreak@@YAXPAUInstance_t@@@Z|

; 353  :     
; 354  : cleanUp:

  00068	ea000000	 b           |$cleanUp$36168|
  0006c		 |$LN2@TransmitCo|

; 350  :         goto cleanUp;
; 351  :         }
; 352  :     rc = TRUE;

  0006c	e3a04001	 mov         r4, #1
  00070		 |$cleanUp$36168|

; 355  :     DEBUGMSG(ZONE_FUNCTION, (L"-TransmitCommand(cmd=0x%02X)\r\n", cmd));
; 356  :     return rc;
; 357  : }

  00070	e1a00004	 mov         r0, r4
  00074	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00078	e12fff1e	 bx          lr
  0007c		 |$M36659|

			 ENDP  ; |?TransmitCommand@@YAHPAUInstance_t@@EPAK@Z|, TransmitCommand

	EXPORT	|?HDQ_Deinit@@YAHK@Z|			; HDQ_Deinit
	IMPORT	|LocalFree|
	IMPORT	|InterruptDisable|
	IMPORT	|MmUnmapIoSpace|
	IMPORT	|DeleteCriticalSection|
	IMPORT	|CloseBusAccessHandle|
	IMPORT	|CloseHandle|
	IMPORT	|InterlockedDecrement|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T36676| DCD	|$LN16@HDQ_Deinit|
	DCD	0x40004001
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\hdq\hdq.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HDQ_Deinit@@YAHK@Z| PROC		; HDQ_Deinit

; 520  : {

  00000		 |$LN16@HDQ_Deinit|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M36673|
  00004	e1b04000	 movs        r4, r0

; 521  :     DEBUGMSG(ZONE_FUNCTION, (L"+HDQ_Deinit(0x%08x)\r\n", context));
; 522  :     
; 523  :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 524  :     Device_t *pDevice = (Device_t*)context;
; 525  : 
; 526  :     // Check if we get correct context
; 527  :     if (pDevice == NULL || pDevice->cookie != HDQ_DEVICE_COOKIE) 

  0000c	0a000038	 beq         |$cleanUp$36240|
  00010	e5942000	 ldr         r2, [r4]
  00014	e59f30e0	 ldr         r3, [pc, #0xE0]
  00018	e1520003	 cmp         r2, r3
  0001c	1a000034	 bne         |$cleanUp$36240|

; 528  :         {
; 529  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: HDQ_Deinit: "
; 530  :             L"Incorrect context paramer\r\n"
; 531  :             ));
; 532  :         goto cleanUp;
; 533  :         }
; 534  : 
; 535  :     InterlockedDecrement(&pDevice->instances);

  00020	e2840020	 add         r0, r4, #0x20
  00024	eb000000	 bl          InterlockedDecrement

; 536  :     ASSERT(pDevice->instances == 0);
; 537  : 
; 538  :     // Disable interrupt.
; 539  :     CLRREG32(&pDevice->pHDQRegs->CTRL_STATUS, HDQ_CTRL_INTERRUPT_MASK);

  00028	e5942018	 ldr         r2, [r4, #0x18]
  0002c	e592300c	 ldr         r3, [r2, #0xC]
  00030	e3c33040	 bic         r3, r3, #0x40
  00034	e582300c	 str         r3, [r2, #0xC]

; 540  : 
; 541  :     // Clear the interrupt.
; 542  :     INREG32(&pDevice->pHDQRegs->INT_STATUS);

  00038	e5943018	 ldr         r3, [r4, #0x18]

; 543  : 
; 544  :     // stop interrupt thread
; 545  :     if (pDevice->hTimerThread != NULL)

  0003c	e5942048	 ldr         r2, [r4, #0x48]
  00040	e5933010	 ldr         r3, [r3, #0x10]
  00044	e3520000	 cmp         r2, #0
  00048	0a00000b	 beq         |$LN6@HDQ_Deinit|

; 546  :         {
; 547  :         pDevice->bExitThread = TRUE;
; 548  :         SetEvent(pDevice->hTimerEvent);

  0004c	e594004c	 ldr         r0, [r4, #0x4C]
  00050	e3a03001	 mov         r3, #1
  00054	e3a01003	 mov         r1, #3
  00058	e5843054	 str         r3, [r4, #0x54]
  0005c	eb000000	 bl          EventModify

; 549  :         WaitForSingleObject(pDevice->hTimerThread, INFINITE);

  00060	e5940048	 ldr         r0, [r4, #0x48]
  00064	e3e01000	 mvn         r1, #0
  00068	eb000000	 bl          WaitForSingleObject

; 550  :         CloseHandle(pDevice->hTimerThread);

  0006c	e5940048	 ldr         r0, [r4, #0x48]
  00070	eb000000	 bl          CloseHandle

; 551  :         pDevice->hTimerThread = NULL;

  00074	e3a03000	 mov         r3, #0
  00078	e5843048	 str         r3, [r4, #0x48]
  0007c		 |$LN6@HDQ_Deinit|

; 552  :         }
; 553  : 
; 554  :     if (pDevice->hTimerEvent != NULL)

  0007c	e594304c	 ldr         r3, [r4, #0x4C]
  00080	e3530000	 cmp         r3, #0

; 555  :         {
; 556  :         CloseHandle(pDevice->hTimerEvent);

  00084	11a00003	 movne       r0, r3
  00088	1b000000	 blne        CloseHandle

; 557  :         }
; 558  : 
; 559  :     // Set hardware to D4 and close parent bus driver
; 560  :     if (pDevice->hParent != NULL) 

  0008c	e594301c	 ldr         r3, [r4, #0x1C]
  00090	e3530000	 cmp         r3, #0
  00094	0a000004	 beq         |$LN4@HDQ_Deinit|

; 561  :         {
; 562  :         SetHDQPower(pDevice, D4);

  00098	e3a01004	 mov         r1, #4
  0009c	e1a00004	 mov         r0, r4
  000a0	eb000000	 bl          |?SetHDQPower@@YAHPAUDevice_t@@W4_CEDEVICE_POWER_STATE@@@Z|

; 563  :         CloseBusAccessHandle(pDevice->hParent);

  000a4	e594001c	 ldr         r0, [r4, #0x1C]
  000a8	eb000000	 bl          CloseBusAccessHandle
  000ac		 |$LN4@HDQ_Deinit|

; 564  :         }
; 565  : 
; 566  :     // Delete critical section
; 567  :     DeleteCriticalSection(&pDevice->cs);

  000ac	e2840024	 add         r0, r4, #0x24
  000b0	eb000000	 bl          DeleteCriticalSection

; 568  : 
; 569  :     // Unmap HDQ_1Wire controller registers
; 570  :     if (pDevice->pHDQRegs != NULL) 

  000b4	e5943018	 ldr         r3, [r4, #0x18]
  000b8	e3530000	 cmp         r3, #0

; 571  :         {
; 572  :         MmUnmapIoSpace((VOID*)pDevice->pHDQRegs, sizeof(OMAP_HDQ_1WIRE_REGS));

  000bc	13a0101c	 movne       r1, #0x1C
  000c0	11a00003	 movne       r0, r3
  000c4	1b000000	 blne        MmUnmapIoSpace

; 573  :         }
; 574  : 
; 575  :     // Release HDQ_1Wire controller interrupt
; 576  :     if (pDevice->sysIntr != 0) 

  000c8	e5943038	 ldr         r3, [r4, #0x38]
  000cc	e3530000	 cmp         r3, #0

; 577  :         {
; 578  :         InterruptDisable(pDevice->sysIntr);

  000d0	11a00003	 movne       r0, r3
  000d4	1b000000	 blne        InterruptDisable

; 579  :         }
; 580  : 
; 581  :     // Close interrupt handler
; 582  :     if (pDevice->hIntrEvent != NULL) CloseHandle(pDevice->hIntrEvent);

  000d8	e594303c	 ldr         r3, [r4, #0x3C]
  000dc	e3530000	 cmp         r3, #0
  000e0	11a00003	 movne       r0, r3
  000e4	1b000000	 blne        CloseHandle

; 583  : 
; 584  :     // Free device structure
; 585  :     LocalFree(pDevice);

  000e8	e1a00004	 mov         r0, r4
  000ec	eb000000	 bl          LocalFree

; 586  : 
; 587  :     // Done
; 588  :     rc = TRUE;

  000f0	e3a00001	 mov         r0, #1
  000f4		 |$cleanUp$36240|

; 589  : 
; 590  : cleanUp:
; 591  :     DEBUGMSG(ZONE_FUNCTION, (L"-HDQ_Deinit(rc = %d)\r\n", rc));
; 592  :     return rc;
; 593  : }

  000f4	e8bd4010	 ldmia       sp!, {r4, lr}
  000f8	e12fff1e	 bx          lr
  000fc		 |$LN17@HDQ_Deinit|
  000fc		 |$LN18@HDQ_Deinit|
  000fc	68647144	 DCD         0x68647144
  00100		 |$M36674|

			 ENDP  ; |?HDQ_Deinit@@YAHK@Z|, HDQ_Deinit

	EXPORT	|?HDQ_Open@@YAKKKK@Z|			; HDQ_Open
	IMPORT	|InterlockedIncrement|
	IMPORT	|LocalAlloc|

  00000			 AREA	 |.pdata|, PDATA
|$T36689| DCD	|$LN10@HDQ_Open|
	DCD	0x40001801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HDQ_Open@@YAKKKK@Z| PROC		; HDQ_Open

; 608  : {

  00000		 |$LN10@HDQ_Open|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M36686|
  00004	e1b05000	 movs        r5, r0

; 609  :     Instance_t *pInstance = NULL;

  00008	e3a04000	 mov         r4, #0

; 610  :     Device_t *pDevice = (Device_t *)context;
; 611  : 
; 612  :     UNREFERENCED_PARAMETER(shareMode);
; 613  :     UNREFERENCED_PARAMETER(accessCode);
; 614  : 
; 615  :     DEBUGMSG(ZONE_FUNCTION, (L"+HDQ_Open(0x%08x, 0x%08x, 0x%08x)\r\n", 
; 616  :         context, accessCode, shareMode
; 617  :         ));
; 618  : 
; 619  :     // Check if we get correct context
; 620  :     if (pDevice == NULL || pDevice->cookie != HDQ_DEVICE_COOKIE) 

  0000c	0a00000e	 beq         |$cleanUp$36268|
  00010	e5952000	 ldr         r2, [r5]
  00014	e59f3040	 ldr         r3, [pc, #0x40]
  00018	e1520003	 cmp         r2, r3
  0001c	1a00000a	 bne         |$cleanUp$36268|

; 621  :         {
; 622  :         DEBUGMSG(ZONE_ERROR && ZONE_HDQ, (L"ERROR! HDQ_Open: "
; 623  :             L"Incorrect context paramer\r\n"
; 624  :             ));
; 625  :         goto cleanUp;
; 626  :         }
; 627  : 
; 628  :     pInstance = (Instance_t*)LocalAlloc(LPTR, sizeof(Instance_t));

  00020	e3a0100c	 mov         r1, #0xC
  00024	e3a00040	 mov         r0, #0x40
  00028	eb000000	 bl          LocalAlloc
  0002c	e1b04000	 movs        r4, r0

; 629  :     if (pInstance == NULL)
; 630  :         {
; 631  :         DEBUGMSG(ZONE_ERROR && ZONE_HDQ, (L"ERROR! HDQ_Open: "
; 632  :             L"Unable to allocate instance (err=0x%08X)",
; 633  :             GetLastError()
; 634  :             ));
; 635  :         goto cleanUp;
; 636  :         }
; 637  : 
; 638  :     // initialize variable
; 639  :     pInstance->cookie = HDQ_INSTANCE_COOKIE;

  00030	159f3020	 ldrne       r3, [pc, #0x20]

; 640  :     pInstance->mode = HDQ_CTRL_INTERRUPT_MASK;

  00034	13a02040	 movne       r2, #0x40

; 641  :     pInstance->pDevice = pDevice;
; 642  : 
; 643  :     // increment reference count
; 644  :     InterlockedIncrement(&pDevice->instances);

  00038	12850020	 addne       r0, r5, #0x20
  0003c	15843000	 strne       r3, [r4]
  00040	15842004	 strne       r2, [r4, #4]
  00044	15845008	 strne       r5, [r4, #8]
  00048	1b000000	 blne        InterlockedIncrement
  0004c		 |$cleanUp$36268|

; 645  : 
; 646  : cleanUp:
; 647  :     DEBUGMSG(ZONE_FUNCTION, (L"-HDQ_Open(context=0x%08X)\r\n", context));
; 648  :     return (DWORD)pInstance;
; 649  : }

  0004c	e1a00004	 mov         r0, r4
  00050	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$LN11@HDQ_Open|
  00058		 |$LN12@HDQ_Open|
  00058	68647149	 DCD         0x68647149
  0005c		 |$LN13@HDQ_Open|
  0005c	68647144	 DCD         0x68647144
  00060		 |$M36687|

			 ENDP  ; |?HDQ_Open@@YAKKKK@Z|, HDQ_Open

	EXPORT	|?ContextRestore@@YAXPAUDevice_t@@@Z|	; ContextRestore

  00000			 AREA	 |.pdata|, PDATA
|$T36700| DCD	|$LN5@ContextRes|
	DCD	0x40000e00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ContextRestore@@YAXPAUDevice_t@@@Z| PROC ; ContextRestore

; 653  : {

  00000		 |$LN5@ContextRes|
  00000		 |$M36697|

; 654  :     // Enable the clock.
; 655  :     SETREG32(&pDevice->pHDQRegs->CTRL_STATUS, HDQ_CTRL_CLOCK_ENABLE);

  00000	e5902018	 ldr         r2, [r0, #0x18]

; 656  :     
; 657  :     // Set to HDQ mode as default
; 658  :     CLRREG32(&pDevice->pHDQRegs->CTRL_STATUS, HDQ_MODE_1WIRE);

  00004	e592300c	 ldr         r3, [r2, #0xC]
  00008	e3833020	 orr         r3, r3, #0x20
  0000c	e582300c	 str         r3, [r2, #0xC]
  00010	e5902018	 ldr         r2, [r0, #0x18]
  00014	e592300c	 ldr         r3, [r2, #0xC]
  00018	e3c33001	 bic         r3, r3, #1
  0001c	e582300c	 str         r3, [r2, #0xC]

; 659  :     
; 660  :     // Clear the interrupt
; 661  :     INREG32(&pDevice->pHDQRegs->INT_STATUS);

  00020	e5901018	 ldr         r1, [r0, #0x18]
  00024	e5912010	 ldr         r2, [r1, #0x10]

; 662  :     
; 663  :     // Enable interrupt
; 664  :     SETREG32(&pDevice->pHDQRegs->CTRL_STATUS, HDQ_CTRL_INTERRUPT_MASK);

  00028	e591300c	 ldr         r3, [r1, #0xC]
  0002c	e3833040	 orr         r3, r3, #0x40
  00030	e581300c	 str         r3, [r1, #0xC]

; 665  : }

  00034	e12fff1e	 bx          lr
  00038		 |$M36698|

			 ENDP  ; |?ContextRestore@@YAXPAUDevice_t@@@Z|, ContextRestore

	EXPORT	|?HDQ_Close@@YAHK@Z|			; HDQ_Close

  00000			 AREA	 |.pdata|, PDATA
|$T36712| DCD	|$LN11@HDQ_Close|
	DCD	0x40001801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HDQ_Close@@YAHK@Z| PROC		; HDQ_Close

; 677  : {

  00000		 |$LN11@HDQ_Close|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M36709|
  00004	e1b04000	 movs        r4, r0

; 678  :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 679  :     Device_t *pDevice;
; 680  :     Instance_t *pInstance = (Instance_t*)context;
; 681  :     
; 682  :     DEBUGMSG(ZONE_FUNCTION, (L"+HDQ_Close(0x%08x)\r\n", context));
; 683  : 
; 684  :     // Check if we get correct context
; 685  :     if (pInstance == NULL || pInstance->cookie != HDQ_INSTANCE_COOKIE) 

  0000c	0a00000f	 beq         |$cleanUp$36301|
  00010	e5942000	 ldr         r2, [r4]
  00014	e59f3040	 ldr         r3, [pc, #0x40]
  00018	e1520003	 cmp         r2, r3
  0001c	1a00000b	 bne         |$cleanUp$36301|

; 686  :         {
; 687  :         DEBUGMSG(ZONE_ERROR && ZONE_HDQ, (L"ERROR! HDQ_Close: "
; 688  :             L"Incorrect context paramer\r\n"
; 689  :         ));
; 690  :         goto cleanUp;
; 691  :         }
; 692  : 
; 693  :     pDevice = pInstance->pDevice;

  00020	e5943008	 ldr         r3, [r4, #8]
  00024	e1b01003	 movs        r1, r3

; 694  :     if (pDevice == NULL || pDevice->cookie != HDQ_DEVICE_COOKIE) 

  00028	0a000008	 beq         |$cleanUp$36301|
  0002c	e5912000	 ldr         r2, [r1]
  00030	e59f3020	 ldr         r3, [pc, #0x20]
  00034	e1520003	 cmp         r2, r3
  00038	1a000004	 bne         |$cleanUp$36301|

; 695  :         {
; 696  :         DEBUGMSG(ZONE_ERROR && ZONE_HDQ, (L"ERROR! HDQ_Close: "
; 697  :             L"Incorrect context paramer\r\n"
; 698  :         ));
; 699  :         goto cleanUp;
; 700  :         }
; 701  : 
; 702  :     InterlockedDecrement(&pDevice->instances);

  0003c	e2810020	 add         r0, r1, #0x20
  00040	eb000000	 bl          InterlockedDecrement

; 703  :     ASSERT(pDevice->instances > 0);
; 704  :     LocalFree(pInstance);

  00044	e1a00004	 mov         r0, r4
  00048	eb000000	 bl          LocalFree

; 705  : 
; 706  :     // Done
; 707  :     rc = TRUE;

  0004c	e3a00001	 mov         r0, #1
  00050		 |$cleanUp$36301|

; 708  : 
; 709  : cleanUp:
; 710  :     DEBUGMSG(ZONE_FUNCTION, (L"-HDQ_Close(rc = %d)\r\n", rc));
; 711  :     return rc;
; 712  : }

  00050	e8bd4010	 ldmia       sp!, {r4, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$LN12@HDQ_Close|
  00058		 |$LN13@HDQ_Close|
  00058	68647144	 DCD         0x68647144
  0005c		 |$LN14@HDQ_Close|
  0005c	68647149	 DCD         0x68647149
  00060		 |$M36710|

			 ENDP  ; |?HDQ_Close@@YAHK@Z|, HDQ_Close

	EXPORT	|?HDQ_PowerDown@@YAXK@Z|		; HDQ_PowerDown

  00000			 AREA	 |.pdata|, PDATA
|$T36723| DCD	|$LN6@HDQ_PowerD|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HDQ_PowerDown@@YAXK@Z| PROC		; HDQ_PowerDown

; 725  : {

  00000		 |$LN6@HDQ_PowerD|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36720|

; 726  :     Device_t *pDevice = (Device_t*)dwContext;
; 727  :     if (pDevice->nPowerState == D0)

  00004	e5903040	 ldr         r3, [r0, #0x40]
  00008	e3530000	 cmp         r3, #0

; 728  :         {
; 729  :         //SetDevicePowerState(pDevice->hParent, D4, NULL);
; 730  :         EnableDeviceClocks(pDevice->dwDeviceId,FALSE);

  0000c	05900008	 ldreq       r0, [r0, #8]
  00010	03a01000	 moveq       r1, #0
  00014	0b000000	 bleq        EnableDeviceClocks

; 731  :         }
; 732  : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$M36721|

			 ENDP  ; |?HDQ_PowerDown@@YAXK@Z|, HDQ_PowerDown

	EXPORT	|?HDQ_PowerUp@@YAXK@Z|			; HDQ_PowerUp

  00000			 AREA	 |.pdata|, PDATA
|$T36731| DCD	|$LN6@HDQ_PowerU|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HDQ_PowerUp@@YAXK@Z| PROC		; HDQ_PowerUp

; 745  : {

  00000		 |$LN6@HDQ_PowerU|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36728|

; 746  :     Device_t *pDevice = (Device_t*)dwContext;
; 747  :     if (pDevice->nPowerState == D0)

  00004	e5903040	 ldr         r3, [r0, #0x40]
  00008	e3530000	 cmp         r3, #0

; 748  :         {
; 749  :         //SetDevicePowerState(pDevice->hParent, D0, NULL);
; 750  :         EnableDeviceClocks(pDevice->dwDeviceId,TRUE);

  0000c	05900008	 ldreq       r0, [r0, #8]
  00010	03a01001	 moveq       r1, #1
  00014	0b000000	 bleq        EnableDeviceClocks

; 751  :         }
; 752  : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$M36729|

			 ENDP  ; |?HDQ_PowerUp@@YAXK@Z|, HDQ_PowerUp

	EXPORT	|HDQ_Write|

  00000			 AREA	 |.pdata|, PDATA
|$T36756| DCD	|$LN28@HDQ_Write|
	DCD	0x40005c02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HDQ_Write| PROC

; 877  : {

  00000		 |$LN28@HDQ_Write|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M36753|
  00008	e1a07002	 mov         r7, r2
  0000c	e1a0b001	 mov         r11, r1
  00010	e1b05000	 movs        r5, r0

; 878  :     DWORD mask;
; 879  :     DWORD status, i;
; 880  :     BOOL rc = FALSE;

  00014	e3a09000	 mov         r9, #0

; 881  :     Device_t *pDevice=NULL;
; 882  :     BOOL bLocked = FALSE;

  00018	e3a04000	 mov         r4, #0

; 883  :     OMAP_HDQ_1WIRE_REGS *pHDQRegs;
; 884  :     UINT8 *pData = (UINT8*)pBuffer;
; 885  :     Instance_t *pInstance = (Instance_t*)context;
; 886  : 
; 887  :     DEBUGMSG(ZONE_FUNCTION, (L"+HDQ_Write(0x%08x, 0x%02x, 0x%x)\r\n",
; 888  :         context, pBuffer, size
; 889  :         ));
; 890  : 
; 891  :     // Check if we get correct context
; 892  :     if (pInstance == NULL || pInstance->cookie != HDQ_INSTANCE_COOKIE || 
; 893  :         pBuffer == NULL || size <= 1) 

  0001c	0a00004d	 beq         |$LN1@HDQ_Write|
  00020	e595e000	 ldr         lr, [r5]
  00024	e59f3140	 ldr         r3, [pc, #0x140]
  00028	e15e0003	 cmp         lr, r3
  0002c	1a000049	 bne         |$LN1@HDQ_Write|
  00030	e35b0000	 cmp         r11, #0
  00034	0a000047	 beq         |$LN1@HDQ_Write|
  00038	e3570001	 cmp         r7, #1
  0003c	9a000045	 bls         |$LN1@HDQ_Write|

; 894  :         {
; 895  :         DEBUGMSG(ZONE_ERROR && ZONE_HDQ, (L"ERROR! HDQ_Write: "
; 896  :             L"Incorrect context paramer\r\n"
; 897  :             ));
; 898  :         goto cleanUp;
; 899  :         }
; 900  : 
; 901  :     // Check if we get correct context
; 902  :     pDevice = pInstance->pDevice;

  00040	e5953008	 ldr         r3, [r5, #8]
  00044	e1b06003	 movs        r6, r3

; 903  :     if (pDevice == NULL || pDevice->cookie != HDQ_DEVICE_COOKIE) 

  00048	0a000042	 beq         |$LN1@HDQ_Write|
  0004c	e596e000	 ldr         lr, [r6]
  00050	e59f3110	 ldr         r3, [pc, #0x110]
  00054	e15e0003	 cmp         lr, r3
  00058	1a000038	 bne         |$cleanUp$36391|

; 904  :         {
; 905  :         DEBUGMSG(ZONE_ERROR && ZONE_HDQ, (L"ERROR: HDQ_Write: "
; 906  :             L"Incorrect context parameter\r\n"
; 907  :             ));
; 908  :         goto cleanUp;
; 909  :         }
; 910  : 
; 911  :     // Get hardware
; 912  :     pHDQRegs = pDevice->pHDQRegs;
; 913  :     EnterCriticalSection(&pDevice->cs);

  0005c	e596a018	 ldr         r10, [r6, #0x18]
  00060	e2860024	 add         r0, r6, #0x24
  00064	eb000000	 bl          EnterCriticalSection

; 914  : 
; 915  :     // set flag so we properly release critical section
; 916  :     bLocked = TRUE;
; 917  : 
; 918  :     // Make sure that clock is present
; 919  :     SetHDQPower(pDevice, D0);

  00068	e3a03001	 mov         r3, #1
  0006c	e3a01000	 mov         r1, #0
  00070	e1a00006	 mov         r0, r6
  00074	e58d3000	 str         r3, [sp]
  00078	eb000000	 bl          |?SetHDQPower@@YAHPAUDevice_t@@W4_CEDEVICE_POWER_STATE@@@Z|

; 920  : 
; 921  :     // Clear the interrupt.
; 922  :     status = INREG32(&pHDQRegs->INT_STATUS);

  0007c	e59a3010	 ldr         r3, [r10, #0x10]

; 923  :     InterruptDone(pDevice->sysIntr);

  00080	e5960038	 ldr         r0, [r6, #0x38]
  00084	e58d3004	 str         r3, [sp, #4]
  00088	eb000000	 bl          InterruptDone

; 924  :     DEBUGMSG(ZONE_INFO, (L"HDQ_Write: "
; 925  :         L"Interrupt status (1) was 0x%02x\r\n", status
; 926  :         ));
; 927  : 
; 928  :     // send command to slave device
; 929  :     TransmitBreak(pInstance);

  0008c	e1a00005	 mov         r0, r5
  00090	eb000000	 bl          |?TransmitBreak@@YAXPAUInstance_t@@@Z|

; 930  :     if (TransmitCommand(pInstance, pData[0] | HDQ_WRITE_CMD, &status) == FALSE)

  00094	e5db1000	 ldrb        r1, [r11]
  00098	e28d2004	 add         r2, sp, #4
  0009c	e1a00005	 mov         r0, r5
  000a0	eb000000	 bl          |?TransmitCommand@@YAHPAUInstance_t@@EPAK@Z|
  000a4	e3500000	 cmp         r0, #0
  000a8	0a000023	 beq         |$LN24@HDQ_Write|

; 931  :         {
; 932  :         goto cleanUp;
; 933  :         }
; 934  : 
; 935  :     // setup mask for read
; 936  :     mask = HDQ_CTRL_GO | HDQ_CTRL_WRITE | 
; 937  :            HDQ_CTRL_CLOCK_ENABLE | pInstance->mode; 

  000ac	e5953004	 ldr         r3, [r5, #4]

; 938  : 
; 939  :     // Two write cycles required
; 940  :     for (i = 1; i < size; ++i) 

  000b0	e3a08001	 mov         r8, #1
  000b4	e3570001	 cmp         r7, #1
  000b8	e3832030	 orr         r2, r3, #0x30
  000bc	e58d2004	 str         r2, [sp, #4]
  000c0	9a000014	 bls         |$LN7@HDQ_Write|
  000c4	e3a03c01	 mov         r3, #1, 24
  000c8	e3834002	 orr         r4, r3, #2
  000cc	e58d4008	 str         r4, [sp, #8]
  000d0		 |$LL9@HDQ_Write|

; 941  :         {
; 942  :         // Write address or data to TX write register
; 943  :         OUTREG32(&pHDQRegs->TX_DATA, pData[i]);

  000d0	e7d8300b	 ldrb        r3, [r8, +r11]
  000d4	e58a3004	 str         r3, [r10, #4]

; 944  : 
; 945  :         // send signal to write
; 946  :         OUTREG32(&pHDQRegs->CTRL_STATUS, mask);

  000d8	e58a200c	 str         r2, [r10, #0xC]

; 947  :                 
; 948  :         // Wait on TX complete interrupt.
; 949  :         if (WaitForSingleObject(pDevice->hIntrEvent, 
; 950  :             pDevice->txTimeout) == WAIT_TIMEOUT) 

  000dc	e5961010	 ldr         r1, [r6, #0x10]
  000e0	e596003c	 ldr         r0, [r6, #0x3C]
  000e4	eb000000	 bl          WaitForSingleObject
  000e8	e1500004	 cmp         r0, r4
  000ec	0a00000e	 beq         |$LN22@HDQ_Write|

; 951  :             {
; 952  :             DEBUGMSG(ZONE_ERROR && ZONE_HDQ, (L"ERROR: HDQ_Write: "
; 953  :                 L"Timeout in Tx\r\n"
; 954  :                 ));
; 955  :             
; 956  :             TransmitBreak(pInstance);
; 957  :             goto cleanUp;
; 958  :             }
; 959  :         
; 960  :         // Clear interrupt.
; 961  :         status = INREG32(&pHDQRegs->INT_STATUS);
; 962  :         InterruptDone(pDevice->sysIntr);

  000f0	e5960038	 ldr         r0, [r6, #0x38]
  000f4	e59a4010	 ldr         r4, [r10, #0x10]
  000f8	eb000000	 bl          InterruptDone

; 963  :         DEBUGMSG(ZONE_INFO, (L"HDQ_Write: "
; 964  :             L"Interrupt status (%d) was 0x%x\r\n", 3 + i, status
; 965  :             ));
; 966  :         
; 967  :         // Verify interrupt source
; 968  :         if ((status & HDQ_INT_TX_COMPLETE) == 0) 

  000fc	e3140004	 tst         r4, #4
  00100	0a000009	 beq         |$LN22@HDQ_Write|
  00104	e2888001	 add         r8, r8, #1
  00108	e59d2004	 ldr         r2, [sp, #4]
  0010c	e59d4008	 ldr         r4, [sp, #8]
  00110	e1580007	 cmp         r8, r7
  00114	3affffed	 bcc         |$LL9@HDQ_Write|
  00118		 |$LN7@HDQ_Write|

; 975  :             goto cleanUp;
; 976  :             }
; 977  :         }
; 978  : 
; 979  :     // disable clock
; 980  :     OUTREG32(&pHDQRegs->CTRL_STATUS, pInstance->mode);

  00118	e5953004	 ldr         r3, [r5, #4]

; 981  : 
; 982  :     // Done
; 983  :     rc = TRUE;

  0011c	e59d4000	 ldr         r4, [sp]
  00120	e3a09001	 mov         r9, #1
  00124	e58a300c	 str         r3, [r10, #0xC]
  00128	ea000004	 b           |$cleanUp$36391|
  0012c		 |$LN22@HDQ_Write|

; 969  :             {
; 970  :             DEBUGMSG(ZONE_ERROR && ZONE_HDQ, (L"ERROR: HDQ_Write: "
; 971  :                 L"TX complete expected (0x%x)\r\n", status
; 972  :                 ));
; 973  :             
; 974  :             TransmitBreak(pInstance);

  0012c	e1a00005	 mov         r0, r5
  00130	eb000000	 bl          |?TransmitBreak@@YAXPAUInstance_t@@@Z|

; 981  : 
; 982  :     // Done
; 983  :     rc = TRUE;

  00134	e59d4000	 ldr         r4, [sp]
  00138	ea000000	 b           |$cleanUp$36391|
  0013c		 |$LN24@HDQ_Write|
  0013c	e3a04001	 mov         r4, #1
  00140		 |$cleanUp$36391|

; 984  : 
; 985  : cleanUp:
; 986  :     if(pDevice != NULL) 
; 987  :     {
; 988  :        SetHDQPower(pDevice, D4);   

  00140	e3a01004	 mov         r1, #4
  00144	e1a00006	 mov         r0, r6
  00148	eb000000	 bl          |?SetHDQPower@@YAHPAUDevice_t@@W4_CEDEVICE_POWER_STATE@@@Z|

; 989  :     
; 990  :        if (bLocked == TRUE) LeaveCriticalSection(&pDevice->cs);

  0014c	e3540001	 cmp         r4, #1
  00150	02860024	 addeq       r0, r6, #0x24
  00154	0b000000	 bleq        LeaveCriticalSection
  00158		 |$LN1@HDQ_Write|

; 991  :        DEBUGMSG(ZONE_FUNCTION, (L"-HDQ_Write(rc = %d)\r\n", rc));
; 992  :     }   
; 993  :     return rc;
; 994  : }

  00158	e1a00009	 mov         r0, r9
  0015c	e28dd00c	 add         sp, sp, #0xC
  00160	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00164	e12fff1e	 bx          lr
  00168		 |$LN29@HDQ_Write|
  00168		 |$LN30@HDQ_Write|
  00168	68647144	 DCD         0x68647144
  0016c		 |$LN31@HDQ_Write|
  0016c	68647149	 DCD         0x68647149
  00170		 |$M36754|

			 ENDP  ; |HDQ_Write|

	EXPORT	|HDQ_Read|

  00000			 AREA	 |.pdata|, PDATA
|$T36785| DCD	|$LN30@HDQ_Read|
	DCD	0x40005f02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HDQ_Read| PROC

; 1009 : {

  00000		 |$LN30@HDQ_Read|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M36782|
  00008	e1a07002	 mov         r7, r2
  0000c	e1a0b001	 mov         r11, r1
  00010	e1b04000	 movs        r4, r0

; 1010 :     DWORD mask;
; 1011 :     DWORD status, i;
; 1012 :     BOOL rc = FALSE;

  00014	e3a09000	 mov         r9, #0

; 1013 :     Device_t *pDevice = NULL;
; 1014 :     BOOL bLocked = FALSE;

  00018	e3a06000	 mov         r6, #0

; 1015 :     OMAP_HDQ_1WIRE_REGS *pHDQRegs;
; 1016 :     UINT8 *pData = (UINT8*)pBuffer;
; 1017 :     Instance_t *pInstance = (Instance_t*)context;
; 1018 : 
; 1019 :     DEBUGMSG(ZONE_FUNCTION, (L"+HDQ_Read"
; 1020 :         L"(0x%08x, 0x%02x, 0x%08x)\r\n", context, pBuffer, size
; 1021 :         ));
; 1022 : 
; 1023 :     // Check if we get correct context
; 1024 :     if (pInstance == NULL || pInstance->cookie != HDQ_INSTANCE_COOKIE || 
; 1025 :         pBuffer == NULL || size <= 1) 

  0001c	0a000050	 beq         |$LN1@HDQ_Read|
  00020	e594e000	 ldr         lr, [r4]
  00024	e59f314c	 ldr         r3, [pc, #0x14C]
  00028	e15e0003	 cmp         lr, r3
  0002c	1a00004c	 bne         |$LN1@HDQ_Read|
  00030	e35b0000	 cmp         r11, #0
  00034	0a00004a	 beq         |$LN1@HDQ_Read|
  00038	e3570001	 cmp         r7, #1
  0003c	9a000048	 bls         |$LN1@HDQ_Read|

; 1026 :         {
; 1027 :         DEBUGMSG(ZONE_ERROR && ZONE_HDQ, (L"ERROR! HDQ_Read: "
; 1028 :             L"Incorrect context paramer\r\n"
; 1029 :             ));
; 1030 :         goto cleanUp;
; 1031 :         }
; 1032 : 
; 1033 :     // Check if we get correct context
; 1034 :     pDevice = pInstance->pDevice;

  00040	e5943008	 ldr         r3, [r4, #8]
  00044	e1b05003	 movs        r5, r3

; 1035 :     if (pDevice == NULL || pDevice->cookie != HDQ_DEVICE_COOKIE) 

  00048	0a000045	 beq         |$LN1@HDQ_Read|
  0004c	e595e000	 ldr         lr, [r5]
  00050	e59f311c	 ldr         r3, [pc, #0x11C]
  00054	e15e0003	 cmp         lr, r3
  00058	1a00003b	 bne         |$cleanUp$36441|

; 1036 :         {
; 1037 :         DEBUGMSG(ZONE_ERROR && ZONE_HDQ, (L"ERROR: HDQ_Read: "
; 1038 :             L"Incorrect context parameter\r\n"
; 1039 :             ));
; 1040 :         goto cleanUp;
; 1041 :         }
; 1042 : 
; 1043 :     // Get hardware
; 1044 :     pHDQRegs = pDevice->pHDQRegs;
; 1045 :     EnterCriticalSection(&pDevice->cs);

  0005c	e5958018	 ldr         r8, [r5, #0x18]
  00060	e2850024	 add         r0, r5, #0x24
  00064	eb000000	 bl          EnterCriticalSection

; 1046 :     bLocked = TRUE;
; 1047 : 
; 1048 :     // Make sure that clock is present
; 1049 :     SetHDQPower(pDevice, D0);

  00068	e3a03001	 mov         r3, #1
  0006c	e3a01000	 mov         r1, #0
  00070	e1a00005	 mov         r0, r5
  00074	e58d3000	 str         r3, [sp]
  00078	eb000000	 bl          |?SetHDQPower@@YAHPAUDevice_t@@W4_CEDEVICE_POWER_STATE@@@Z|

; 1050 : 
; 1051 :     // Clear the interrupt.
; 1052 :     status = INREG32(&pHDQRegs->INT_STATUS);

  0007c	e5983010	 ldr         r3, [r8, #0x10]

; 1053 :     InterruptDone(pDevice->sysIntr);

  00080	e5950038	 ldr         r0, [r5, #0x38]
  00084	e58d3004	 str         r3, [sp, #4]
  00088	eb000000	 bl          InterruptDone

; 1054 :     DEBUGMSG(ZONE_INFO, (L"HDQ_Read: "
; 1055 :         L"Interrupt status (1) was 0x%02x\r\n", status
; 1056 :         ));
; 1057 : 
; 1058 :     // send command to slave device
; 1059 :     TransmitBreak(pInstance);

  0008c	e1a00004	 mov         r0, r4
  00090	eb000000	 bl          |?TransmitBreak@@YAXPAUInstance_t@@@Z|

; 1060 :     if (TransmitCommand(pInstance, pData[0], &status) == FALSE)

  00094	e5db1000	 ldrb        r1, [r11]
  00098	e28d2004	 add         r2, sp, #4
  0009c	e1a00004	 mov         r0, r4
  000a0	eb000000	 bl          |?TransmitCommand@@YAHPAUInstance_t@@EPAK@Z|
  000a4	e3500000	 cmp         r0, #0
  000a8	0a000026	 beq         |$LN26@HDQ_Read|

; 1061 :         {
; 1062 :         goto cleanUp;
; 1063 :         }
; 1064 : 
; 1065 :     // setup mask for read
; 1066 :     mask = HDQ_CTRL_GO | HDQ_CTRL_READ | 
; 1067 :            HDQ_CTRL_CLOCK_ENABLE | pInstance->mode; 

  000ac	e5943004	 ldr         r3, [r4, #4]

; 1068 : 
; 1069 :     for (i = 1; i < size; ++i)

  000b0	e3a0a001	 mov         r10, #1
  000b4	e3570001	 cmp         r7, #1
  000b8	e3833032	 orr         r3, r3, #0x32
  000bc	e58d3008	 str         r3, [sp, #8]
  000c0	9a00001b	 bls         |$LN8@HDQ_Read|
  000c4	e59d6004	 ldr         r6, [sp, #4]
  000c8		 |$LL10@HDQ_Read|

; 1070 :         {
; 1071 :         // it's possible to receive data soon after transmit resulting
; 1072 :         // in both receive and transmit flags being set.  So need to
; 1073 :         // check if data was recieved.
; 1074 :         if ((status & HDQ_INT_RX_COMPLETE) == 0)

  000c8	e3160002	 tst         r6, #2
  000cc	1a00000a	 bne         |$LN7@HDQ_Read|

; 1075 :             {
; 1076 :             // initiate receive
; 1077 :             OUTREG32(&pHDQRegs->CTRL_STATUS, mask);

  000d0	e588300c	 str         r3, [r8, #0xC]

; 1078 :             if (WaitForSingleObject(pDevice->hIntrEvent, 
; 1079 :                 pDevice->rxTimeout) == WAIT_TIMEOUT)

  000d4	e5951014	 ldr         r1, [r5, #0x14]
  000d8	e595003c	 ldr         r0, [r5, #0x3C]
  000dc	eb000000	 bl          WaitForSingleObject
  000e0	e3a02c01	 mov         r2, #1, 24
  000e4	e3823002	 orr         r3, r2, #2
  000e8	e1500003	 cmp         r0, r3
  000ec	0a00000c	 beq         |$LN23@HDQ_Read|

; 1080 :                 {
; 1081 :                 DEBUGMSG(ZONE_ERROR && ZONE_HDQ, (L"ERROR: HDQ_Read: "
; 1082 :                     L"Timeout in Rx\r\n"
; 1083 :                     ));
; 1084 : 
; 1085 :                 TransmitBreak(pInstance);
; 1086 :                 goto cleanUp;
; 1087 :                 
; 1088 :                 }
; 1089 : 
; 1090 :             // Clear interrupt
; 1091 :             status = INREG32(&pHDQRegs->INT_STATUS);
; 1092 :             InterruptDone(pDevice->sysIntr);

  000f0	e5950038	 ldr         r0, [r5, #0x38]
  000f4	e5986010	 ldr         r6, [r8, #0x10]
  000f8	eb000000	 bl          InterruptDone
  000fc		 |$LN7@HDQ_Read|

; 1093 :             }
; 1094 :         
; 1095 :         // Verify interrupt source
; 1096 :         if ((status & HDQ_INT_RX_COMPLETE) == 0) 

  000fc	e3160002	 tst         r6, #2
  00100	0a000007	 beq         |$LN23@HDQ_Read|

; 1103 :             goto cleanUp;
; 1104 :             }
; 1105 :             
; 1106 :         DEBUGMSG(ZONE_INFO, (L"INFO: HDQ_Read: "
; 1107 :             L"Read status = 0x%02X\r\n", status
; 1108 :             ));
; 1109 :         
; 1110 :         // read data
; 1111 :         pData[i] = (UINT8)INREG32(&pHDQRegs->RX_DATA);

  00104	e5983008	 ldr         r3, [r8, #8]

; 1112 :         DEBUGMSG(ZONE_INFO, (L"INFO: HDQ_Read: "
; 1113 :             L"Read data[i] = 0x%02X\r\n", i, pData[i]
; 1114 :             ));
; 1115 :         
; 1116 :         // reset status to force read request
; 1117 :         status = 0;

  00108	e3a06000	 mov         r6, #0
  0010c	e7ca300b	 strb        r3, [r10, +r11]
  00110	e28aa001	 add         r10, r10, #1
  00114	e15a0007	 cmp         r10, r7
  00118	2a000005	 bcs         |$LN8@HDQ_Read|
  0011c	e59d3008	 ldr         r3, [sp, #8]
  00120	eaffffe8	 b           |$LL10@HDQ_Read|
  00124		 |$LN23@HDQ_Read|

; 1097 :             {
; 1098 :             DEBUGMSG(ZONE_ERROR && ZONE_HDQ, (L"ERROR: HDQ_Read: "
; 1099 :                 L"RX complete expected (0x%02x)\r\n", status
; 1100 :                 ));
; 1101 : 
; 1102 :             TransmitBreak(pInstance);

  00124	e1a00004	 mov         r0, r4
  00128	eb000000	 bl          |?TransmitBreak@@YAXPAUInstance_t@@@Z|

; 1122 :     
; 1123 :     // Done
; 1124 :     rc = TRUE;

  0012c	e59d6000	 ldr         r6, [sp]
  00130	ea000005	 b           |$cleanUp$36441|
  00134		 |$LN8@HDQ_Read|

; 1118 :         }
; 1119 : 
; 1120 :     // disable clock
; 1121 :     OUTREG32(&pHDQRegs->CTRL_STATUS, pInstance->mode);

  00134	e5943004	 ldr         r3, [r4, #4]

; 1122 :     
; 1123 :     // Done
; 1124 :     rc = TRUE;

  00138	e59d6000	 ldr         r6, [sp]
  0013c	e3a09001	 mov         r9, #1
  00140	e588300c	 str         r3, [r8, #0xC]
  00144	ea000000	 b           |$cleanUp$36441|
  00148		 |$LN26@HDQ_Read|
  00148	e3a06001	 mov         r6, #1
  0014c		 |$cleanUp$36441|

; 1125 : 
; 1126 : cleanUp:
; 1127 :     if(pDevice != NULL) 
; 1128 :     {
; 1129 :        SetHDQPower(pDevice, D4);

  0014c	e3a01004	 mov         r1, #4
  00150	e1a00005	 mov         r0, r5
  00154	eb000000	 bl          |?SetHDQPower@@YAHPAUDevice_t@@W4_CEDEVICE_POWER_STATE@@@Z|

; 1130 :     
; 1131 :        if (bLocked == TRUE) LeaveCriticalSection(&pDevice->cs);

  00158	e3560001	 cmp         r6, #1
  0015c	02850024	 addeq       r0, r5, #0x24
  00160	0b000000	 bleq        LeaveCriticalSection
  00164		 |$LN1@HDQ_Read|

; 1132 :        DEBUGMSG(ZONE_FUNCTION, (L"-HDQ_Read(rc = %d)\r\n", rc));
; 1133 :     }
; 1134 :     return rc;
; 1135 : }

  00164	e1a00009	 mov         r0, r9
  00168	e28dd00c	 add         sp, sp, #0xC
  0016c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00170	e12fff1e	 bx          lr
  00174		 |$LN31@HDQ_Read|
  00174		 |$LN32@HDQ_Read|
  00174	68647144	 DCD         0x68647144
  00178		 |$LN33@HDQ_Read|
  00178	68647149	 DCD         0x68647149
  0017c		 |$M36783|

			 ENDP  ; |HDQ_Read|

	EXPORT	|DllMain|
	IMPORT	|DisableThreadLibraryCalls|
	IMPORT	|RegisterDbgZones|

  00000			 AREA	 |.pdata|, PDATA
|$T36799| DCD	|$LN8@DllMain|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DllMain| PROC

; 1151 : {

  00000		 |$LN8@DllMain|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M36796|
  00004	e1a04000	 mov         r4, r0

; 1152 :     
; 1153 :     UNREFERENCED_PARAMETER(pReserved);
; 1154 : 
; 1155 :     switch (reason)

  00008	e3510001	 cmp         r1, #1
  0000c	1a000003	 bne         |$LN2@DllMain|

; 1156 :         {
; 1157 :         case DLL_PROCESS_ATTACH:
; 1158 :             RETAILREGISTERZONES((HMODULE)hDLL);

  00010	e59f1014	 ldr         r1, [pc, #0x14]
  00014	eb000000	 bl          RegisterDbgZones

; 1159 :             DisableThreadLibraryCalls((HMODULE)hDLL);

  00018	e1a00004	 mov         r0, r4
  0001c	eb000000	 bl          DisableThreadLibraryCalls
  00020		 |$LN2@DllMain|

; 1160 :             break;
; 1161 :         }
; 1162 :     return TRUE;

  00020	e3a00001	 mov         r0, #1

; 1163 : }

  00024	e8bd4010	 ldmia       sp!, {r4, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$LN9@DllMain|
  0002c		 |$LN10@DllMain|
  0002c	00000000	 DCD         |dpCurSettings|
  00030		 |$M36797|

			 ENDP  ; |DllMain|

	EXPORT	|?HDQ_Init@@YAKPBGPBX@Z|		; HDQ_Init
	IMPORT	|InterruptInitialize|
	IMPORT	|KernelIoControl|
	IMPORT	|GetIrqByDevice|
	IMPORT	|MmMapIoSpace|
	IMPORT	|GetAddressByDevice|
	IMPORT	|SOCGetHDQDevice|
	IMPORT	|CeSetThreadPriority|
	IMPORT	|CreateThread|
	IMPORT	|CreateEventW|
	IMPORT	|CreateBusAccessHandle|
	IMPORT	|GetDeviceRegistryParams|
	IMPORT	|InitializeCriticalSection|
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T36817| DCD	|$LN24@HDQ_Init|
	DCD	0x40007e02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HDQ_Init@@YAKPBGPBX@Z| PROC		; HDQ_Init

; 371  : {

  00000		 |$LN24@HDQ_Init|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M36814|
  00008	e1a06000	 mov         r6, r0

; 372  :     DEBUGMSG(ZONE_FUNCTION, (L"+HDQ_Init(%s, 0x%08x)\r\n", 
; 373  :         szContext, pBusContext
; 374  :         ));
; 375  : 
; 376  :     UNREFERENCED_PARAMETER(pBusContext);    
; 377  :     
; 378  :     DWORD rc = (DWORD)NULL;
; 379  :     Device_t *pDevice = NULL;
; 380  :     PHYSICAL_ADDRESS pa;
; 381  : 
; 382  :     // Create device structure
; 383  :     pDevice = (Device_t *)LocalAlloc(LPTR, sizeof(Device_t));

  0000c	e3a01060	 mov         r1, #0x60
  00010	e3a00040	 mov         r0, #0x40
  00014	e3a05000	 mov         r5, #0
  00018	eb000000	 bl          LocalAlloc
  0001c	e1b04000	 movs        r4, r0

; 384  :     if (pDevice == NULL) 

  00020	0a00006a	 beq         |$LN21@HDQ_Init|

; 385  :         {
; 386  :         DEBUGMSG(ZONE_ERROR && ZONE_HDQ, (L"ERROR: HDQ_Init: "
; 387  :             L"Failed allocate HDQ controller structure\r\n"
; 388  :             ));
; 389  :         goto cleanUp;
; 390  :         }
; 391  :     memset(pDevice, 0, sizeof(Device_t));

  00024	e3a02060	 mov         r2, #0x60
  00028	e3a01000	 mov         r1, #0
  0002c	e1a00004	 mov         r0, r4
  00030	eb000000	 bl          memset

; 392  : 
; 393  :     // Set cookie
; 394  :     pDevice->cookie = HDQ_DEVICE_COOKIE;

  00034	e59f31b8	 ldr         r3, [pc, #0x1B8]

; 395  :     pDevice->nPowerState = D4;

  00038	e3a07004	 mov         r7, #4

; 396  : 
; 397  :     // set device reference count to 1
; 398  :     InterlockedIncrement(&pDevice->instances);

  0003c	e2840020	 add         r0, r4, #0x20
  00040	e5843000	 str         r3, [r4]
  00044	e5847040	 str         r7, [r4, #0x40]
  00048	eb000000	 bl          InterlockedIncrement

; 399  : 
; 400  :     // Initalize critical section
; 401  :     InitializeCriticalSection(&pDevice->cs);

  0004c	e2840024	 add         r0, r4, #0x24
  00050	eb000000	 bl          InitializeCriticalSection

; 402  : 
; 403  :     // Read device parameters
; 404  :     if (GetDeviceRegistryParams(szContext, pDevice, dimof(g_deviceRegParams), 
; 405  :         g_deviceRegParams) != ERROR_SUCCESS) 

  00054	e59f3194	 ldr         r3, [pc, #0x194]
  00058	e3a02005	 mov         r2, #5
  0005c	e1a01004	 mov         r1, r4
  00060	e1a00006	 mov         r0, r6
  00064	eb000000	 bl          GetDeviceRegistryParams
  00068	e3500000	 cmp         r0, #0
  0006c	1a000052	 bne         |$cleanUp$36189|

; 406  :         {
; 407  :         DEBUGMSG(ZONE_ERROR && ZONE_HDQ, (L"ERROR: HDQ_Init: "
; 408  :             L"Failed read HDQ driver registry parameters\r\n"
; 409  :             ));
; 410  :         goto cleanUp;
; 411  :         }
; 412  : 
; 413  :     // Open parent bus
; 414  :     pDevice->hParent = CreateBusAccessHandle(szContext);

  00070	e1a00006	 mov         r0, r6
  00074	eb000000	 bl          CreateBusAccessHandle
  00078	e3500000	 cmp         r0, #0
  0007c	e584001c	 str         r0, [r4, #0x1C]

; 415  :     if (pDevice->hParent == NULL) 

  00080	0a00004d	 beq         |$cleanUp$36189|

; 416  :         {
; 417  :         DEBUGMSG(ZONE_ERROR && ZONE_HDQ, (L"ERROR: HDQ_Init: "
; 418  :             L"Failed open parent bus driver\r\n"
; 419  :             ));
; 420  :         goto cleanUp;
; 421  :         }
; 422  :     
; 423  :     // start timer thread
; 424  :     pDevice->hTimerEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  00084	e3a03000	 mov         r3, #0
  00088	e3a02000	 mov         r2, #0
  0008c	e3a01000	 mov         r1, #0
  00090	e3a00000	 mov         r0, #0
  00094	eb000000	 bl          CreateEventW
  00098	e3500000	 cmp         r0, #0
  0009c	e584004c	 str         r0, [r4, #0x4C]
  000a0	e3a06000	 mov         r6, #0

; 425  :     if (pDevice->hTimerEvent != NULL)

  000a4	0a00000a	 beq         |$LN11@HDQ_Init|

; 426  :         {
; 427  :         pDevice->hTimerThread = CreateThread(NULL, 0, HDQPowerTimerThread, 
; 428  :             pDevice, 0, NULL
; 429  :             );

  000a8	e59f213c	 ldr         r2, [pc, #0x13C]
  000ac	e1a03004	 mov         r3, r4
  000b0	e3a01000	 mov         r1, #0
  000b4	e3a00000	 mov         r0, #0
  000b8	e58d6004	 str         r6, [sp, #4]
  000bc	e58d6000	 str         r6, [sp]
  000c0	eb000000	 bl          CreateThread
  000c4	e3500000	 cmp         r0, #0

; 430  :         
; 431  :         if (pDevice->hTimerThread != NULL)
; 432  :             {
; 433  :             CeSetThreadPriority(pDevice->hTimerThread, TIMERTHREAD_PRIORITY);

  000c8	13a01098	 movne       r1, #0x98
  000cc	e5840048	 str         r0, [r4, #0x48]
  000d0	1b000000	 blne        CeSetThreadPriority
  000d4		 |$LN11@HDQ_Init|

; 434  :             }
; 435  :         }
; 436  : 
; 437  :     pDevice->dwDeviceId = SOCGetHDQDevice(pDevice->dwHDQBusIndex);

  000d4	e5940004	 ldr         r0, [r4, #4]
  000d8	eb000000	 bl          SOCGetHDQDevice
  000dc	e1a03000	 mov         r3, r0

; 438  : 
; 439  :     // Set hardware to full power
; 440  :     SetHDQPower(pDevice, D0);

  000e0	e1a00004	 mov         r0, r4
  000e4	e3a01000	 mov         r1, #0
  000e8	e5843008	 str         r3, [r4, #8]
  000ec	eb000000	 bl          |?SetHDQPower@@YAHPAUDevice_t@@W4_CEDEVICE_POWER_STATE@@@Z|

; 441  : 
; 442  :     // Map HDQ_1WIRE controller
; 443  :     pa.QuadPart = GetAddressByDevice(pDevice->dwDeviceId);

  000f0	e5940008	 ldr         r0, [r4, #8]
  000f4	eb000000	 bl          GetAddressByDevice

; 444  :     pDevice->pHDQRegs = (OMAP_HDQ_1WIRE_REGS*)MmMapIoSpace(pa, 
; 445  :                             sizeof(OMAP_HDQ_1WIRE_REGS), FALSE
; 446  :                             );

  000f8	e3a01000	 mov         r1, #0
  000fc	e3a03000	 mov         r3, #0
  00100	e3a0201c	 mov         r2, #0x1C
  00104	eb000000	 bl          MmMapIoSpace
  00108	e3500000	 cmp         r0, #0
  0010c	e5840018	 str         r0, [r4, #0x18]

; 447  :     
; 448  :     if (pDevice->pHDQRegs == NULL) 

  00110	0a000029	 beq         |$cleanUp$36189|

; 449  :         {
; 450  :         DEBUGMSG(ZONE_ERROR && ZONE_HDQ, (L"ERROR: HDQ_Init: "
; 451  :             L"Failed map HDQ controller registers\r\n"
; 452  :             ));
; 453  :         goto cleanUp;
; 454  :         }
; 455  : 
; 456  :     DWORD irq = GetIrqByDevice(pDevice->dwDeviceId,NULL);

  00114	e5940008	 ldr         r0, [r4, #8]
  00118	e3a01000	 mov         r1, #0
  0011c	eb000000	 bl          GetIrqByDevice
  00120	e1a0e000	 mov         lr, r0

; 457  :     // Map HDQ_1WIRE interrupt
; 458  :     if (!KernelIoControl(IOCTL_HAL_REQUEST_SYSINTR, &irq, 
; 459  :         sizeof(irq), &pDevice->sysIntr, 
; 460  :         sizeof(pDevice->sysIntr), NULL
; 461  :         )) 

  00124	e59f00bc	 ldr         r0, [pc, #0xBC]
  00128	e2843038	 add         r3, r4, #0x38
  0012c	e3a02004	 mov         r2, #4
  00130	e28d1008	 add         r1, sp, #8
  00134	e58de008	 str         lr, [sp, #8]
  00138	e58d6004	 str         r6, [sp, #4]
  0013c	e58d7000	 str         r7, [sp]
  00140	eb000000	 bl          KernelIoControl
  00144	e3500000	 cmp         r0, #0
  00148	0a00001b	 beq         |$cleanUp$36189|

; 462  :         {
; 463  :         DEBUGMSG(ZONE_ERROR && ZONE_HDQ, (L"ERROR: HDQ_Init: "
; 464  :             L"Failed map HDQ/1WIRE controller interrupt\r\n"
; 465  :             ));
; 466  :         goto cleanUp;
; 467  :         }
; 468  : 
; 469  :     // Create interrupt event
; 470  :     pDevice->hIntrEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  0014c	e3a03000	 mov         r3, #0
  00150	e3a02000	 mov         r2, #0
  00154	e3a01000	 mov         r1, #0
  00158	e3a00000	 mov         r0, #0
  0015c	eb000000	 bl          CreateEventW
  00160	e1b01000	 movs        r1, r0
  00164	e584103c	 str         r1, [r4, #0x3C]

; 471  :     if (pDevice->hIntrEvent == NULL) 

  00168	0a000013	 beq         |$cleanUp$36189|

; 472  :         {
; 473  :         DEBUGMSG(ZONE_ERROR && ZONE_HDQ, (L"ERROR: HDQ_Init: "
; 474  :             L"Failed create interrupt event\r\n"
; 475  :             ));
; 476  :         goto cleanUp;
; 477  :         }
; 478  :     
; 479  :     if (InterruptInitialize(pDevice->sysIntr, pDevice->hIntrEvent, NULL, 0) == FALSE)

  0016c	e5940038	 ldr         r0, [r4, #0x38]
  00170	e3a03000	 mov         r3, #0
  00174	e3a02000	 mov         r2, #0
  00178	eb000000	 bl          InterruptInitialize
  0017c	e3500000	 cmp         r0, #0
  00180	0a00000d	 beq         |$cleanUp$36189|

; 480  :         {
; 481  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: HDQ_Init: "
; 482  :             L"InterruptInitialize failed\r\n"
; 483  :             ));
; 484  :         goto cleanUp;
; 485  :         }
; 486  : 
; 487  :     // Enable the clock.
; 488  :     SETREG32(&pDevice->pHDQRegs->CTRL_STATUS, HDQ_CTRL_CLOCK_ENABLE);

  00184	e5942018	 ldr         r2, [r4, #0x18]

; 489  :     
; 490  :     // Set to HDQ mode as default
; 491  :     CLRREG32(&pDevice->pHDQRegs->CTRL_STATUS, HDQ_MODE_1WIRE);
; 492  :     
; 493  :     // Clear the interrupt
; 494  :     INREG32(&pDevice->pHDQRegs->INT_STATUS);
; 495  :     
; 496  :     // Enable interrupt
; 497  :     SETREG32(&pDevice->pHDQRegs->CTRL_STATUS, HDQ_CTRL_INTERRUPT_MASK);
; 498  : 
; 499  :     // Return non-null value
; 500  :     rc = (DWORD)pDevice;

  00188	e1a05004	 mov         r5, r4
  0018c	e592300c	 ldr         r3, [r2, #0xC]
  00190	e3833020	 orr         r3, r3, #0x20
  00194	e582300c	 str         r3, [r2, #0xC]
  00198	e5942018	 ldr         r2, [r4, #0x18]
  0019c	e592300c	 ldr         r3, [r2, #0xC]
  001a0	e3c33001	 bic         r3, r3, #1
  001a4	e582300c	 str         r3, [r2, #0xC]
  001a8	e5941018	 ldr         r1, [r4, #0x18]
  001ac	e5912010	 ldr         r2, [r1, #0x10]
  001b0	e591300c	 ldr         r3, [r1, #0xC]
  001b4	e3833040	 orr         r3, r3, #0x40
  001b8	e581300c	 str         r3, [r1, #0xC]
  001bc		 |$cleanUp$36189|

; 501  : 
; 502  : cleanUp:
; 503  :     if (pDevice != NULL) SetHDQPower(pDevice, D4);

  001bc	e3a01004	 mov         r1, #4
  001c0	e1a00004	 mov         r0, r4
  001c4	eb000000	 bl          |?SetHDQPower@@YAHPAUDevice_t@@W4_CEDEVICE_POWER_STATE@@@Z|

; 504  :     if (rc == 0) HDQ_Deinit((DWORD)pDevice);

  001c8	e3550000	 cmp         r5, #0
  001cc	1a000001	 bne         |$LN1@HDQ_Init|
  001d0		 |$LN21@HDQ_Init|
  001d0	e1a00004	 mov         r0, r4
  001d4	eb000000	 bl          |?HDQ_Deinit@@YAHK@Z|
  001d8		 |$LN1@HDQ_Init|

; 505  :     DEBUGMSG(ZONE_FUNCTION, (L"-HDQ_Init(rc = 0x%x)\r\n", rc));
; 506  :     return rc;
; 507  : }

  001d8	e1a00005	 mov         r0, r5
  001dc	e28dd00c	 add         sp, sp, #0xC
  001e0	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  001e4	e12fff1e	 bx          lr
  001e8		 |$LN25@HDQ_Init|
  001e8		 |$LN26@HDQ_Init|
  001e8	01010098	 DCD         0x1010098
  001ec		 |$LN27@HDQ_Init|
  001ec	00000000	 DCD         |?HDQPowerTimerThread@@YAKPAX@Z|
  001f0		 |$LN28@HDQ_Init|
  001f0	00000000	 DCD         |g_deviceRegParams|
  001f4		 |$LN29@HDQ_Init|
  001f4	68647144	 DCD         0x68647144
  001f8		 |$M36815|

			 ENDP  ; |?HDQ_Init@@YAKPBGPBX@Z|, HDQ_Init

	EXPORT	|?HDQ_IOControl@@YAHKKPAEK0KPAK@Z|	; HDQ_IOControl
	IMPORT	|SetLastError|
	IMPORT	|CeSafeCopyMemory|
	IMPORT	|GetCallerProcess|

  00000			 AREA	 |.pdata|, PDATA
|$T36855| DCD	|$LN35@HDQ_IOCont|
	DCD	0x40005902
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HDQ_IOControl@@YAHKKPAEK0KPAK@Z| PROC ; HDQ_IOControl

; 771  : {

  00000		 |$LN35@HDQ_IOCont|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M36852|
  00008	e1a08003	 mov         r8, r3
  0000c	e1a07002	 mov         r7, r2
  00010	e1b05000	 movs        r5, r0

; 772  :     BOOL rc = FALSE;

  00014	e3a06000	 mov         r6, #0

; 773  :     Device_t *pDevice;
; 774  :     DEVICE_IFC_HDQ ifc;
; 775  :     Instance_t *pInstance = (Instance_t*)context;
; 776  :     
; 777  :     DEBUGMSG(ZONE_FUNCTION, (L"+HDQ_IOControl"
; 778  :         L"(0x%08x, 0x%08x, 0x%08x, %d, 0x%08x, %d, 0x%08x)\r\n",
; 779  :         context, code, pInBuffer, inSize, pOutBuffer, outSize, pOutSize
; 780  :         ));
; 781  : 
; 782  :     // Check if we get correct context
; 783  :     if (pInstance == NULL || pInstance->cookie != HDQ_INSTANCE_COOKIE) 

  00018	0a000047	 beq         |$cleanUp$36339|
  0001c	e5954000	 ldr         r4, [r5]
  00020	e59fe138	 ldr         lr, [pc, #0x138]
  00024	e154000e	 cmp         r4, lr
  00028	1a000043	 bne         |$cleanUp$36339|

; 784  :         {
; 785  :         DEBUGMSG(ZONE_ERROR && ZONE_HDQ, (L"ERROR! HDQ_IOControl: "
; 786  :             L"Incorrect context paramer\r\n"
; 787  :             ));
; 788  :         goto cleanUp;
; 789  :         }
; 790  : 
; 791  :     // Check if we get correct context
; 792  :     pDevice = pInstance->pDevice;

  0002c	e595e008	 ldr         lr, [r5, #8]
  00030	e1b0000e	 movs        r0, lr

; 793  :     if (pDevice == NULL || pDevice->cookie != HDQ_DEVICE_COOKIE) 

  00034	0a000040	 beq         |$cleanUp$36339|
  00038	e5904000	 ldr         r4, [r0]
  0003c	e59fe118	 ldr         lr, [pc, #0x118]
  00040	e154000e	 cmp         r4, lr
  00044	1a00003c	 bne         |$cleanUp$36339|
  00048	e3a03822	 mov         r3, #0x22, 16

; 794  :         {
; 795  :         DEBUGMSG(ZONE_ERROR && ZONE_HDQ, (L"ERROR: HDQ_IOControl: "
; 796  :             L"Incorrect context paramer\r\n"
; 797  :             ));
; 798  :         goto cleanUp;
; 799  :         }
; 800  : 
; 801  :     switch (code) 

  0004c	e383eb01	 orr         lr, r3, #1, 22
  00050	e151000e	 cmp         r1, lr
  00054	0a000010	 beq         |$LN11@HDQ_IOCont|
  00058	e59f30f8	 ldr         r3, [pc, #0xF8]
  0005c	e1510003	 cmp         r1, r3

; 840  :                 break;
; 841  :                 }
; 842  :             
; 843  :             SetLastError(ERROR_INVALID_PARAMETER);
; 844  :             break;
; 845  : 
; 846  :     case IOCTL_CONTEXT_RESTORE:
; 847  :             DEBUGMSG(ZONE_FUNCTION, (L"HDQ_IOControl: IOCTL_CONTEXT_RESTORE_NOTIFY\r\n"));
; 848  :             ContextRestore(pDevice);
; 849  :             break;
; 850  :       
; 851  :     default:
; 852  :             DEBUGMSG(ZONE_WARN, (L"WARN: HDQ_IOControl: "
; 853  :                 L"Unsupported code 0x%08x\r\n", code
; 854  :                 ));
; 855  :             SetLastError(ERROR_INVALID_PARAMETER);
; 856  :             break;

  00060	1a000033	 bne         |$LN8@HDQ_IOCont|
  00064	e5902018	 ldr         r2, [r0, #0x18]
  00068	e592300c	 ldr         r3, [r2, #0xC]
  0006c	e3833020	 orr         r3, r3, #0x20
  00070	e582300c	 str         r3, [r2, #0xC]
  00074	e5902018	 ldr         r2, [r0, #0x18]
  00078	e592300c	 ldr         r3, [r2, #0xC]
  0007c	e3c33001	 bic         r3, r3, #1
  00080	e582300c	 str         r3, [r2, #0xC]
  00084	e5901018	 ldr         r1, [r0, #0x18]
  00088	e5912010	 ldr         r2, [r1, #0x10]
  0008c	e591300c	 ldr         r3, [r1, #0xC]
  00090	e3833040	 orr         r3, r3, #0x40
  00094	e581300c	 str         r3, [r1, #0xC]
  00098	ea000027	 b           |$cleanUp$36339|
  0009c		 |$LN11@HDQ_IOCont|

; 802  :         {
; 803  :         case IOCTL_DDK_GET_DRIVER_IFC:
; 804  :             // We can give interface only to our peer in device process
; 805  :             if (GetCurrentProcessId() != (DWORD)GetCallerProcess()) 

  0009c	e3a0000c	 mov         r0, #0xC
  000a0	eb000000	 bl          __GetUserKData
  000a4	e1a04000	 mov         r4, r0
  000a8	eb000000	 bl          GetCallerProcess
  000ac	e1540000	 cmp         r4, r0

; 806  :                 {
; 807  :                 DEBUGMSG(ZONE_ERROR && ZONE_HDQ, (L"ERROR: HDQ_IOControl: "
; 808  :                     L"IOCTL_DDK_GET_DRIVER_IFC can be called only from "
; 809  :                     L"device process (caller process id 0x%08x)\r\n",
; 810  :                     GetCallerProcess()
; 811  :                 ));
; 812  :                 SetLastError(ERROR_ACCESS_DENIED);

  000b0	13a00005	 movne       r0, #5
  000b4	1a00001f	 bne         |$LN31@HDQ_IOCont|

; 813  :                 break;
; 814  :                 }
; 815  :             
; 816  :             if (pInBuffer == NULL || inSize < sizeof(GUID)) 

  000b8	e3570000	 cmp         r7, #0
  000bc	0a00001c	 beq         |$LN8@HDQ_IOCont|
  000c0	e3580010	 cmp         r8, #0x10
  000c4	3a00001a	 bcc         |$LN8@HDQ_IOCont|

; 819  :                 break;
; 820  :                 }
; 821  :             
; 822  :             if (IsEqualGUID(*(GUID*)pInBuffer, DEVICE_IFC_HDQ_GUID)) 

  000c8	e59f1084	 ldr         r1, [pc, #0x84]
  000cc	e3a02010	 mov         r2, #0x10
  000d0	e1a00007	 mov         r0, r7
  000d4	eb000000	 bl          memcmp
  000d8	e3500000	 cmp         r0, #0
  000dc	1a000014	 bne         |$LN8@HDQ_IOCont|

; 823  :                 {
; 824  :                 if (pOutSize != NULL) *pOutSize = sizeof(DEVICE_IFC_HDQ);

  000e0	e59d302c	 ldr         r3, [sp, #0x2C]

; 825  :                 if (pOutBuffer == NULL || outSize < sizeof(DEVICE_IFC_HDQ)) 

  000e4	e59d0024	 ldr         r0, [sp, #0x24]
  000e8	e3530000	 cmp         r3, #0
  000ec	13a0200c	 movne       r2, #0xC
  000f0	15832000	 strne       r2, [r3]
  000f4	e3500000	 cmp         r0, #0
  000f8	0a00000d	 beq         |$LN8@HDQ_IOCont|
  000fc	e59d3028	 ldr         r3, [sp, #0x28]
  00100	e353000c	 cmp         r3, #0xC
  00104	3a00000a	 bcc         |$LN8@HDQ_IOCont|

; 826  :                     {
; 827  :                     SetLastError(ERROR_INVALID_PARAMETER);
; 828  :                     break;
; 829  :                     }
; 830  :                 
; 831  :                 ifc.context = context;
; 832  :                 ifc.pfnRead = HDQ_Read;
; 833  :                 ifc.pfnWrite = HDQ_Write;           

  00108	e59f1040	 ldr         r1, [pc, #0x40]
  0010c	e59f3038	 ldr         r3, [pc, #0x38]

; 834  :                 if (!CeSafeCopyMemory(pOutBuffer, &ifc, sizeof(DEVICE_IFC_HDQ))) 

  00110	e3a0200c	 mov         r2, #0xC
  00114	e58d1004	 str         r1, [sp, #4]
  00118	e28d1000	 add         r1, sp, #0
  0011c	e58d3008	 str         r3, [sp, #8]
  00120	e58d5000	 str         r5, [sp]
  00124	eb000000	 bl          CeSafeCopyMemory
  00128	e3500000	 cmp         r0, #0

; 835  :                     {
; 836  :                     SetLastError(ERROR_INVALID_PARAMETER);
; 837  :                     break;
; 838  :                     }
; 839  :                 rc = TRUE;

  0012c	13a06001	 movne       r6, #1
  00130	1a000001	 bne         |$cleanUp$36339|
  00134		 |$LN8@HDQ_IOCont|

; 817  :                 {
; 818  :                 SetLastError(ERROR_INVALID_PARAMETER);

  00134	e3a00057	 mov         r0, #0x57
  00138		 |$LN31@HDQ_IOCont|
  00138	eb000000	 bl          SetLastError
  0013c		 |$cleanUp$36339|

; 857  :     }
; 858  : 
; 859  : cleanUp:
; 860  :     DEBUGMSG(ZONE_FUNCTION, (L"-HDQ_IOControl(rc = %d)\r\n", rc));
; 861  :     return rc;
; 862  : }

  0013c	e1a00006	 mov         r0, r6
  00140	e28dd00c	 add         sp, sp, #0xC
  00144	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00148	e12fff1e	 bx          lr
  0014c		 |$LN36@HDQ_IOCont|
  0014c		 |$LN37@HDQ_IOCont|
  0014c	00000000	 DCD         |HDQ_Read|
  00150		 |$LN38@HDQ_IOCont|
  00150	00000000	 DCD         |HDQ_Write|
  00154		 |$LN39@HDQ_IOCont|
  00154	00000000	 DCD         |DEVICE_IFC_HDQ_GUID|
  00158		 |$LN40@HDQ_IOCont|
  00158	80038140	 DCD         0x80038140
  0015c		 |$LN41@HDQ_IOCont|
  0015c	68647144	 DCD         0x68647144
  00160		 |$LN42@HDQ_IOCont|
  00160	68647149	 DCD         0x68647149
  00164		 |$M36853|

			 ENDP  ; |?HDQ_IOControl@@YAHKKPAEK0KPAK@Z|, HDQ_IOControl

	END
