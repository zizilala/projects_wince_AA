; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\DSS\DDGPE\omap_dmablt.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|?g_csDmaLock@@3UCRITICAL_SECTION@@A| [ DATA ] ; g_csDmaLock
	EXPORT	|?g_tDmaDataInfo2@@3UDmaDataInfo_t@@A| [ DATA ] ; g_tDmaDataInfo2
	EXPORT	|?g_tDmaDataInfo1@@3UDmaDataInfo_t@@A| [ DATA ] ; g_tDmaDataInfo1
	EXPORT	|?g_hDmaChannel1@@3PAXA| [ DATA ]	; g_hDmaChannel1
	EXPORT	|?g_hDmaChannel2@@3PAXA| [ DATA ]	; g_hDmaChannel2

  00000			 AREA	 |.bss|, NOINIT
|?g_csDmaLock@@3UCRITICAL_SECTION@@A| % 0x14		; g_csDmaLock
|?g_tDmaDataInfo2@@3UDmaDataInfo_t@@A| % 0x18		; g_tDmaDataInfo2
|?g_tDmaDataInfo1@@3UDmaDataInfo_t@@A| % 0x18		; g_tDmaDataInfo1
|?g_hDmaChannel1@@3PAXA| % 0x4				; g_hDmaChannel1
|?g_hDmaChannel2@@3PAXA| % 0x4				; g_hDmaChannel2

  00000			 AREA	 |.rdata|, DATA, READONLY
|FourCCDescriptionTable| DCD 0x32595559
	DCD	0x10
	DCD	0xff00ff
	DCD	0xff00
	DCD	0xff000000
	DCD	0x56595559
	DCD	0x10
	DCD	0xff00ff
	DCD	0xff00
	DCD	0xff000000
	DCD	0x55595659
	DCD	0x10
	DCD	0xff00ff00
	DCD	0xff
	DCD	0xff0000
	DCD	0x59565955
	DCD	0x10
	DCD	0xff00ff00
	DCD	0xff
	DCD	0xff0000
	DCD	0x36315659
	DCD	0x10
	DCD	0xffffffff
	DCD	0xffffffff
	DCD	0xffffffff
	DCD	0x32315659
	DCD	0xc
	DCD	0xffffffff
	DCD	0xffffffff
	DCD	0xffffffff
	DCD	0x3231564e
	DCD	0xc
	DCD	0xffffffff
	DCD	0xffffffff
	DCD	0xffffffff
	DCD	0x30323449
	DCD	0xc
	DCD	0xffffffff
	DCD	0xffffffff
	DCD	0xffffffff
	DCD	0x56555949
	DCD	0xc
	DCD	0xffffffff
	DCD	0xffffffff
	DCD	0xffffffff
	EXPORT	|?Stride@GPESurf@@QAAHXZ|		; GPESurf::Stride
; File c:\wince600\public\common\oak\inc\gpe.h

  00000			 AREA	 |.pdata|, PDATA
|$T42570| DCD	|$LN5@Stride|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Stride@GPESurf@@QAAHXZ| PROC		; GPESurf::Stride

; 177  :     {

  00000		 |$LN5@Stride|
  00000		 |$M42567|

; 178  :         return m_nStrideBytes;

  00000	e5900008	 ldr         r0, [r0, #8]

; 179  :     }

  00004	e12fff1e	 bx          lr
  00008		 |$M42568|

			 ENDP  ; |?Stride@GPESurf@@QAAHXZ|, GPESurf::Stride

	EXPORT	|?BytesPerPixel@GPESurf@@QAAHXZ|	; GPESurf::BytesPerPixel

  00000			 AREA	 |.pdata|, PDATA
|$T42580| DCD	|$LN5@BytesPerPi|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?BytesPerPixel@GPESurf@@QAAHXZ| PROC	; GPESurf::BytesPerPixel

; 183  :     {

  00000		 |$LN5@BytesPerPi|
  00000		 |$M42577|

; 184  :         return m_BytesPixel;

  00000	e5900044	 ldr         r0, [r0, #0x44]

; 185  :     }

  00004	e12fff1e	 bx          lr
  00008		 |$M42578|

			 ENDP  ; |?BytesPerPixel@GPESurf@@QAAHXZ|, GPESurf::BytesPerPixel

	EXPORT	|?OmapSurface@OMAPDDGPESurface@@QAAPAVOMAPSurface@@XZ| ; OMAPDDGPESurface::OmapSurface
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\inc\omap_ddgpe.h

  00000			 AREA	 |.pdata|, PDATA
|$T42590| DCD	|$LN5@OmapSurfac|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapSurface@OMAPDDGPESurface@@QAAPAVOMAPSurface@@XZ| PROC ; OMAPDDGPESurface::OmapSurface

; 102  :     OMAPSurface*        OmapSurface() { return m_pSurface; }

  00000		 |$LN5@OmapSurfac|
  00000		 |$M42587|
  00000	e590007c	 ldr         r0, [r0, #0x7C]
  00004	e12fff1e	 bx          lr
  00008		 |$M42588|

			 ENDP  ; |?OmapSurface@OMAPDDGPESurface@@QAAPAVOMAPSurface@@XZ|, OMAPDDGPESurface::OmapSurface

	EXPORT	|DmaConfigure|
	IMPORT	|DmaGetLogicalChannel|
	IMPORT	|memset|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\inc\omap_sdma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T42606| DCD	|$LN9@DmaConfigu|
	DCD	0x40003901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaConfigure| PROC

; 166  : {

  00000		 |$LN9@DmaConfigu|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M42603|
  00004	e1a04003	 mov         r4, r3
  00008	e1a09002	 mov         r9, r2
  0000c	e1a06001	 mov         r6, r1
  00010	e1a05000	 mov         r5, r0

; 167  :     BOOL rc = FALSE;
; 168  :     OMAP_DMA_LC_REGS *pDmaLcReg = (OMAP_DMA_LC_REGS*)DmaGetLogicalChannel(hDmaChannel);

  00014	e3a08000	 mov         r8, #0
  00018	eb000000	 bl          DmaGetLogicalChannel
  0001c	e1b07000	 movs        r7, r0

; 169  :     if (pDmaLcReg == NULL || pConfigInfo == NULL)

  00020	0a00002c	 beq         |$cleanUp$42100|
  00024	e3560000	 cmp         r6, #0
  00028	0a00002a	 beq         |$cleanUp$42100|

; 170  :         {
; 171  :         goto cleanUp;
; 172  :         }
; 173  : 
; 174  :     // initialize dma DataInfo if necessary
; 175  :     if (pDataInfo != NULL)

  0002c	e3540000	 cmp         r4, #0
  00030	0a000005	 beq         |$LN1@DmaConfigu|

; 176  :         {
; 177  :         memset(pDataInfo, 0, sizeof(DmaDataInfo_t));

  00034	e3a02018	 mov         r2, #0x18
  00038	e3a01000	 mov         r1, #0
  0003c	e1a00004	 mov         r0, r4
  00040	eb000000	 bl          memset

; 178  :         pDataInfo->hDmaChannel = hDmaChannel;

  00044	e5845010	 str         r5, [r4, #0x10]

; 179  :         pDataInfo->pDmaLcReg = pDmaLcReg;

  00048	e5847014	 str         r7, [r4, #0x14]
  0004c		 |$LN1@DmaConfigu|

; 180  :         }
; 181  : 
; 182  :     // Disable the DMA in case it is running
; 183  :     CLRREG32(&pDmaLcReg->CCR, DMA_CCR_ENABLE);

  0004c	e5973000	 ldr         r3, [r7]

; 184  : 
; 185  :     // update syncmap
; 186  :     pConfigInfo->syncMap = syncMap;
; 187  : 
; 188  :     // Initialize logical channel registers
; 189  :     //
; 190  :     OUTREG32(&pDmaLcReg->CCR, 0);

  00050	e3a02000	 mov         r2, #0

; 191  :     OUTREG32(&pDmaLcReg->CLNK_CTRL, 0);
; 192  :     OUTREG32(&pDmaLcReg->COLOR, 0);
; 193  : 
; 194  :     // update CSDP
; 195  :     //  DATA_TYPE
; 196  :     //  DST
; 197  :     //  SRC
; 198  :     OUTREG32(&pDmaLcReg->CSDP, pConfigInfo->elemSize);
; 199  : 
; 200  :     // update CCR
; 201  :     //  DST_MODE
; 202  :     //  SRC_MODE
; 203  :     //  PRIO
; 204  :     //  SYNC
; 205  :     //
; 206  :     OUTREG32(&pDmaLcReg->CCR, pConfigInfo->srcAddrMode |
; 207  :         pConfigInfo->dstAddrMode | pConfigInfo->dmaPrio |
; 208  :         DMA_CCR_SYNC(syncMap) | pConfigInfo->synchTrigger |
; 209  :         pConfigInfo->synchMode
; 210  :         );

  00054	e2090060	 and         r0, r9, #0x60
  00058	e3c33080	 bic         r3, r3, #0x80
  0005c	e5873000	 str         r3, [r7]
  00060	e586902c	 str         r9, [r6, #0x2C]
  00064	e5872000	 str         r2, [r7]
  00068	e5872004	 str         r2, [r7, #4]
  0006c	e5872044	 str         r2, [r7, #0x44]
  00070	e5963000	 ldr         r3, [r6]

; 211  : 
; 212  :     // update CSEI
; 213  :     //
; 214  :     OUTREG32(&pDmaLcReg->CSEI, pConfigInfo->srcElemIndex);
; 215  : 
; 216  :     // update CDEI
; 217  :     //
; 218  :     OUTREG32(&pDmaLcReg->CDEI, pConfigInfo->dstElemIndex);
; 219  : 
; 220  :     // update CSFI
; 221  :     //
; 222  :     OUTREG32(&pDmaLcReg->CSFI, pConfigInfo->srcFrameIndex);
; 223  : 
; 224  :     // update CDFI
; 225  :     //
; 226  :     OUTREG32(&pDmaLcReg->CDFI, pConfigInfo->dstFrameIndex);
; 227  : 
; 228  :     // update CICR
; 229  :     //
; 230  :     OUTREG32(&pDmaLcReg->CICR , pConfigInfo->interrupts);
; 231  :     
; 232  :     rc = TRUE;

  00074	e3a08001	 mov         r8, #1
  00078	e5873010	 str         r3, [r7, #0x10]
  0007c	e5962024	 ldr         r2, [r6, #0x24]
  00080	e209301f	 and         r3, r9, #0x1F
  00084	e5961020	 ldr         r1, [r6, #0x20]
  00088	e1833700	 orr         r3, r3, r0, lsl #14
  0008c	e1833002	 orr         r3, r3, r2
  00090	e596201c	 ldr         r2, [r6, #0x1C]
  00094	e1833001	 orr         r3, r3, r1
  00098	e5961018	 ldr         r1, [r6, #0x18]
  0009c	e1833002	 orr         r3, r3, r2
  000a0	e596200c	 ldr         r2, [r6, #0xC]
  000a4	e1833001	 orr         r3, r3, r1
  000a8	e1833002	 orr         r3, r3, r2
  000ac	e5873000	 str         r3, [r7]
  000b0	e5963004	 ldr         r3, [r6, #4]
  000b4	e5873024	 str         r3, [r7, #0x24]
  000b8	e5963010	 ldr         r3, [r6, #0x10]
  000bc	e587302c	 str         r3, [r7, #0x2C]
  000c0	e5963008	 ldr         r3, [r6, #8]
  000c4	e5873028	 str         r3, [r7, #0x28]
  000c8	e5963014	 ldr         r3, [r6, #0x14]
  000cc	e5873030	 str         r3, [r7, #0x30]
  000d0	e5963028	 ldr         r3, [r6, #0x28]
  000d4	e5873008	 str         r3, [r7, #8]
  000d8		 |$cleanUp$42100|

; 233  : 
; 234  : cleanUp:
; 235  :     return rc;
; 236  : }

  000d8	e1a00008	 mov         r0, r8
  000dc	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000e0	e12fff1e	 bx          lr
  000e4		 |$M42604|

			 ENDP  ; |DmaConfigure|

	EXPORT	|DmaSetDstBuffer|

  00000			 AREA	 |.pdata|, PDATA
|$T42616| DCD	|$LN6@DmaSetDstB|
	DCD	0x40000800
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaSetDstBuffer| PROC

; 330  : {

  00000		 |$LN6@DmaSetDstB|
  00000		 |$M42613|

; 331  :     // save values
; 332  :     //
; 333  :     pDataInfo->pDstBuffer = pBuffer;
; 334  :     pDataInfo->PhysAddrDstBuffer = PhysAddr;
; 335  : 
; 336  :     // set destination address
; 337  :     //
; 338  :     if (pDataInfo->pDmaLcReg != NULL)

  00000	e5903014	 ldr         r3, [r0, #0x14]
  00004	e5801004	 str         r1, [r0, #4]
  00008	e580200c	 str         r2, [r0, #0xC]
  0000c	e3530000	 cmp         r3, #0

; 339  :         {
; 340  :         OUTREG32(&pDataInfo->pDmaLcReg->CDSA, PhysAddr);

  00010	15832020	 strne       r2, [r3, #0x20]

; 341  :         OUTREG32(&pDataInfo->pDmaLcReg->CDAC, PhysAddr);

  00014	15903014	 ldrne       r3, [r0, #0x14]
  00018	15832038	 strne       r2, [r3, #0x38]

; 342  :         }
; 343  : }

  0001c	e12fff1e	 bx          lr
  00020		 |$M42614|

			 ENDP  ; |DmaSetDstBuffer|

	EXPORT	|DmaSetSrcBuffer|

  00000			 AREA	 |.pdata|, PDATA
|$T42626| DCD	|$LN6@DmaSetSrcB|
	DCD	0x40000800
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaSetSrcBuffer| PROC

; 358  : {

  00000		 |$LN6@DmaSetSrcB|
  00000		 |$M42623|

; 359  :     // save values
; 360  :     //
; 361  :     pDataInfo->pSrcBuffer = pBuffer;
; 362  :     pDataInfo->PhysAddrSrcBuffer = PhysAddr;
; 363  : 
; 364  :     // set source address
; 365  :     //
; 366  :     if (pDataInfo->pDmaLcReg != NULL)

  00000	e5903014	 ldr         r3, [r0, #0x14]
  00004	e5801000	 str         r1, [r0]
  00008	e5802008	 str         r2, [r0, #8]
  0000c	e3530000	 cmp         r3, #0

; 367  :         {
; 368  :         OUTREG32(&pDataInfo->pDmaLcReg->CSSA, PhysAddr);

  00010	1583201c	 strne       r2, [r3, #0x1C]

; 369  :         OUTREG32(&pDataInfo->pDmaLcReg->CSAC, PhysAddr);

  00014	15903014	 ldrne       r3, [r0, #0x14]
  00018	15832034	 strne       r2, [r3, #0x34]

; 370  :         }
; 371  : }

  0001c	e12fff1e	 bx          lr
  00020		 |$M42624|

			 ENDP  ; |DmaSetSrcBuffer|

	EXPORT	|DmaSetElementAndFrameCount|

  00000			 AREA	 |.pdata|, PDATA
|$T42636| DCD	|$LN5@DmaSetElem|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaSetElementAndFrameCount| PROC

; 386  : {

  00000		 |$LN5@DmaSetElem|
  00000		 |$M42633|

; 387  :     // setup frame and element count for destination side
; 388  :     //
; 389  :     OUTREG32(&pDataInfo->pDmaLcReg->CEN , countElements);

  00000	e5903014	 ldr         r3, [r0, #0x14]
  00004	e5831014	 str         r1, [r3, #0x14]

; 390  :     OUTREG32(&pDataInfo->pDmaLcReg->CFN , countFrames);

  00008	e5903014	 ldr         r3, [r0, #0x14]
  0000c	e5832018	 str         r2, [r3, #0x18]

; 391  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M42634|

			 ENDP  ; |DmaSetElementAndFrameCount|

	EXPORT	|IsDmaEnable|

  00000			 AREA	 |.pdata|, PDATA
|$T42646| DCD	|$LN8@IsDmaEnabl|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |IsDmaEnable| PROC

; 404  : {

  00000		 |$LN8@IsDmaEnabl|
  00000	e24dd004	 sub         sp, sp, #4
  00004		 |$M42643|
  00004	e3500000	 cmp         r0, #0

; 405  :     volatile ULONG ulCCR;
; 406  : 
; 407  :     if (NULL == pDataInfo)
; 408  :        return FALSE;
; 409  : 
; 410  :     ulCCR = INREG32(&pDataInfo->pDmaLcReg->CCR);

  00008	15903014	 ldrne       r3, [r0, #0x14]
  0000c	15933000	 ldrne       r3, [r3]
  00010	158d3000	 strne       r3, [sp]

; 411  : 
; 412  :     if (ulCCR & DMA_CCR_ENABLE)

  00014	159d3000	 ldrne       r3, [sp]
  00018	13130080	 tstne       r3, #0x80

; 413  :         return TRUE;

  0001c	13a00001	 movne       r0, #1

; 416  : }

  00020	128dd004	 addne       sp, sp, #4

; 414  :     else
; 415  :         return FALSE;

  00024	03a00000	 moveq       r0, #0

; 416  : }

  00028	028dd004	 addeq       sp, sp, #4
  0002c	e12fff1e	 bx          lr
  00030		 |$M42644|

			 ENDP  ; |IsDmaEnable|

	EXPORT	|IsDmaActive|

  00000			 AREA	 |.pdata|, PDATA
|$T42656| DCD	|$LN8@IsDmaActiv|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |IsDmaActive| PROC

; 428  : {

  00000		 |$LN8@IsDmaActiv|
  00000	e24dd004	 sub         sp, sp, #4
  00004		 |$M42653|

; 429  :     volatile ULONG ulCCR;
; 430  : 
; 431  :     ulCCR = INREG32(&pDataInfo->pDmaLcReg->CCR);

  00004	e5903014	 ldr         r3, [r0, #0x14]
  00008	e5933000	 ldr         r3, [r3]
  0000c	e58d3000	 str         r3, [sp]

; 432  : 
; 433  :     if ((ulCCR & DMA_CCR_WR_ACTIVE) || (ulCCR & DMA_CCR_RD_ACTIVE))

  00010	e59d3000	 ldr         r3, [sp]
  00014	e3130b01	 tst         r3, #1, 22
  00018	059d3000	 ldreq       r3, [sp]
  0001c	03130c02	 tsteq       r3, #2, 24

; 435  :     else
; 436  :         return FALSE;

  00020	03a00000	 moveq       r0, #0

; 437  : }

  00024	028dd004	 addeq       sp, sp, #4

; 434  :         return TRUE;

  00028	13a00001	 movne       r0, #1

; 437  : }

  0002c	128dd004	 addne       sp, sp, #4
  00030	e12fff1e	 bx          lr
  00034		 |$M42654|

			 ENDP  ; |IsDmaActive|

	EXPORT	|DmaStart|

  00000			 AREA	 |.pdata|, PDATA
|$T42664| DCD	|$LN5@DmaStart|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaStart| PROC

; 487  : {

  00000		 |$LN5@DmaStart|
  00000		 |$M42661|

; 488  :     // enable the dma channel
; 489  :     //
; 490  :     SETREG32(&pDataInfo->pDmaLcReg->CCR , DMA_CCR_ENABLE);

  00000	e5902014	 ldr         r2, [r0, #0x14]
  00004	e5923000	 ldr         r3, [r2]
  00008	e3833080	 orr         r3, r3, #0x80
  0000c	e5823000	 str         r3, [r2]

; 491  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M42662|

			 ENDP  ; |DmaStart|

	EXPORT	|DmaSetColor|

  00000			 AREA	 |.pdata|, PDATA
|$T42674| DCD	|$LN5@DmaSetColo|
	DCD	0x40000901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DmaSetColor| PROC

; 665  : {

  00000		 |$LN5@DmaSetColo|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42671|

; 666  :     SETREG32(&pDataInfo->pDmaLcReg->CCR, dwFlag);

  00004	e590e014	 ldr         lr, [r0, #0x14]
  00008	e59e3000	 ldr         r3, [lr]
  0000c	e1833001	 orr         r3, r3, r1
  00010	e58e3000	 str         r3, [lr]

; 667  :     OUTREG32(&pDataInfo->pDmaLcReg->COLOR, dwColor);

  00014	e5903014	 ldr         r3, [r0, #0x14]
  00018	e5832044	 str         r2, [r3, #0x44]

; 668  : }

  0001c	e49de004	 ldr         lr, [sp], #4
  00020	e12fff1e	 bx          lr
  00024		 |$M42672|

			 ENDP  ; |DmaSetColor|

	EXPORT	|?IsBusy@OMAPDDGPE@@UAAHXZ|		; OMAPDDGPE::IsBusy

  00000			 AREA	 |.pdata|, PDATA
|$T42718| DCD	|$LN31@IsBusy|
	DCD	0x40003201
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\ddgpe\omap_dmablt.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsBusy@OMAPDDGPE@@UAAHXZ| PROC	; OMAPDDGPE::IsBusy

; 44   : { 

  00000		 |$LN31@IsBusy|
  00000	e24dd004	 sub         sp, sp, #4
  00004		 |$M42715|

; 45   :     int result = 0;
; 46   :     
; 47   :     //  Check for a HW BLT in progress
; 48   :     if( g_hDmaChannel1 && g_tDmaDataInfo1.pDmaLcReg )

  00004	e59f20b8	 ldr         r2, [pc, #0xB8]
  00008	e3a00000	 mov         r0, #0
  0000c	e5923044	 ldr         r3, [r2, #0x44]
  00010	e3530000	 cmp         r3, #0
  00014	0a000012	 beq         |$LN3@IsBusy|
  00018	e5921014	 ldr         r1, [r2, #0x14]
  0001c	e3510000	 cmp         r1, #0
  00020	0a00000f	 beq         |$LN3@IsBusy|

; 49   :     {
; 50   :         if( IsDmaEnable(&g_tDmaDataInfo1) && IsDmaActive(&g_tDmaDataInfo1) )

  00024	e3520000	 cmp         r2, #0
  00028	0a00000d	 beq         |$LN3@IsBusy|
  0002c	e5913000	 ldr         r3, [r1]
  00030	e58d3000	 str         r3, [sp]
  00034	e59d3000	 ldr         r3, [sp]
  00038	e3130080	 tst         r3, #0x80
  0003c	0a000008	 beq         |$LN3@IsBusy|
  00040	e5913000	 ldr         r3, [r1]
  00044	e58d3000	 str         r3, [sp]
  00048	e59d3000	 ldr         r3, [sp]
  0004c	e3130b01	 tst         r3, #1, 22
  00050	1a000002	 bne         |$LN13@IsBusy|
  00054	e59d3000	 ldr         r3, [sp]
  00058	e3130c02	 tst         r3, #2, 24
  0005c	0a000000	 beq         |$LN3@IsBusy|
  00060		 |$LN13@IsBusy|

; 51   :             result = 1;

  00060	e3a00001	 mov         r0, #1
  00064		 |$LN3@IsBusy|

; 52   :     }
; 53   : 
; 54   :     if( g_hDmaChannel2 && g_tDmaDataInfo2.pDmaLcReg )

  00064	e5923048	 ldr         r3, [r2, #0x48]
  00068	e3530000	 cmp         r3, #0
  0006c	0a000012	 beq         |$LN1@IsBusy|
  00070	e592102c	 ldr         r1, [r2, #0x2C]
  00074	e3510000	 cmp         r1, #0
  00078	0a00000f	 beq         |$LN1@IsBusy|

; 55   :     {
; 56   :         if( IsDmaEnable(&g_tDmaDataInfo2) && IsDmaActive(&g_tDmaDataInfo2) )

  0007c	e2923018	 adds        r3, r2, #0x18

; 58   :     }
; 59   :     
; 60   :     //  Return result
; 61   :     return result; 
; 62   : }

  00080	0a00000d	 beq         |$LN1@IsBusy|
  00084	e5913000	 ldr         r3, [r1]
  00088	e58d3000	 str         r3, [sp]
  0008c	e59d3000	 ldr         r3, [sp]
  00090	e3130080	 tst         r3, #0x80
  00094	0a000008	 beq         |$LN1@IsBusy|
  00098	e5913000	 ldr         r3, [r1]
  0009c	e58d3000	 str         r3, [sp]
  000a0	e59d3000	 ldr         r3, [sp]
  000a4	e3130b01	 tst         r3, #1, 22
  000a8	1a000002	 bne         |$LN23@IsBusy|
  000ac	e59d3000	 ldr         r3, [sp]
  000b0	e3130c02	 tst         r3, #2, 24
  000b4	0a000000	 beq         |$LN1@IsBusy|

; 55   :     {
; 56   :         if( IsDmaEnable(&g_tDmaDataInfo2) && IsDmaActive(&g_tDmaDataInfo2) )

  000b8		 |$LN23@IsBusy|

; 57   :             result = 1;

  000b8	e3a00001	 mov         r0, #1
  000bc		 |$LN1@IsBusy|

; 58   :     }
; 59   :     
; 60   :     //  Return result
; 61   :     return result; 
; 62   : }

  000bc	e28dd004	 add         sp, sp, #4
  000c0	e12fff1e	 bx          lr
  000c4		 |$LN32@IsBusy|
  000c4		 |$LN33@IsBusy|
  000c4	00000000	 DCD         |?g_tDmaDataInfo1@@3UDmaDataInfo_t@@A|
  000c8		 |$M42716|

			 ENDP  ; |?IsBusy@OMAPDDGPE@@UAAHXZ|, OMAPDDGPE::IsBusy

	EXPORT	|?WaitForNotBusy@OMAPDDGPE@@UAAXXZ|	; OMAPDDGPE::WaitForNotBusy

  00000			 AREA	 |.pdata|, PDATA
|$T42729| DCD	|$LN8@WaitForNot|
	DCD	0x40000b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?WaitForNotBusy@OMAPDDGPE@@UAAXXZ| PROC ; OMAPDDGPE::WaitForNotBusy

; 67   : {

  00000		 |$LN8@WaitForNot|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M42726|
  00004	e1a04000	 mov         r4, r0
  00008		 |$LL2@WaitForNot|

; 68   :     //  Wait for any active DMA operation to complete
; 69   :     while( IsBusy() );

  00008	e5943000	 ldr         r3, [r4]
  0000c	e1a00004	 mov         r0, r4
  00010	e593305c	 ldr         r3, [r3, #0x5C]
  00014	e1a0e00f	 mov         lr, pc
  00018	e12fff13	 bx          r3
  0001c	e3500000	 cmp         r0, #0
  00020	1afffff8	 bne         |$LL2@WaitForNot|

; 70   :     return; 
; 71   : }

  00024	e8bd4010	 ldmia       sp!, {r4, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$M42727|

			 ENDP  ; |?WaitForNotBusy@OMAPDDGPE@@UAAXXZ|, OMAPDDGPE::WaitForNotBusy

	EXPORT	|?DMAFill@OMAPDDGPE@@QAAJPAUGPEBltParms@@@Z| ; OMAPDDGPE::DMAFill
	IMPORT	|?EmulatedBlt@GPE@@QAAJPAUGPEBltParms@@@Z| ; GPE::EmulatedBlt
	IMPORT	|?DesignateBlt@OMAPDDGPE@@QAAJPAUGPEBltParms@@@Z| ; OMAPDDGPE::DesignateBlt
	IMPORT	|?g_Globals@@3VOMAPDDGPEGlobals@@A|	; g_Globals
	IMPORT	|LeaveCriticalSection|
	IMPORT	|EnterCriticalSection|
	IMPORT	|InitializeCriticalSection|
	IMPORT	|DmaAllocateChannel|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\inc\omap_sdma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T42785| DCD	|$LN36@DMAFill|
	DCD	0x4000ab02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\ddgpe\omap_dmablt.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DMAFill@OMAPDDGPE@@QAAJPAUGPEBltParms@@@Z| PROC ; OMAPDDGPE::DMAFill

; 79   : {

  00000		 |$LN36@DMAFill|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd038	 sub         sp, sp, #0x38
  00008		 |$M42782|
  00008	e1a07001	 mov         r7, r1
  0000c	e1a0a000	 mov         r10, r0

; 80   :     SCODE   result = S_OK;
; 81   :     RECTL*  prclDst = pParms->prclDst;

  00010	e5976014	 ldr         r6, [r7, #0x14]

; 82   :     DWORD   dwWidth  = prclDst->right - prclDst->left;
; 83   :     DWORD   dwHeight = prclDst->bottom - prclDst->top;
; 84   :     DWORD   dwStride = pParms->pDst->Stride();

  00014	e5971004	 ldr         r1, [r7, #4]

; 85   :     DWORD   dwOffset = 0;
; 86   :     
; 87   :     OMAPDDGPESurface*   pOmapSurf = (OMAPDDGPESurface*) pParms->pDst;
; 88   :      
; 89   :     DmaConfigInfo_t DmaSettings = {
; 90   :         0,                          // elemSize
; 91   :         1,                          // srcElemIndex
; 92   :         1,                          // srcFrameIndex
; 93   :         DMA_CCR_SRC_AMODE_CONST,    // srcAddrMode

  00018	e3a00000	 mov         r0, #0
  0001c	e5962008	 ldr         r2, [r6, #8]
  00020	e5963000	 ldr         r3, [r6]
  00024	e596400c	 ldr         r4, [r6, #0xC]
  00028	e596e004	 ldr         lr, [r6, #4]
  0002c	e0429003	 sub         r9, r2, r3
  00030	e3a02001	 mov         r2, #1

; 94   :         1,                          // dstElemIndex
; 95   :         1,                          // dstFrameIndex
; 96   :         DMA_CCR_DST_AMODE_DOUBLE,   // dstAddrMode
; 97   :         FALSE,                      // dmaPrio
; 98   :         DMA_SYNCH_TRIGGER_NONE,     // synchTrigger
; 99   :         DMA_SYNCH_NONE,             // synchMode
; 100  :         0,                          // interrupts
; 101  :         0                           // syncMap
; 102  :     };
; 103  : 
; 104  :     //  Check that a DMA Blt is worth doing
; 105  :     if( dwWidth < MIN_DMA_WIDTH || dwHeight < MIN_DMA_HEIGHT )

  00034	e58d2010	 str         r2, [sp, #0x10]
  00038	e3a02001	 mov         r2, #1
  0003c	e58d201c	 str         r2, [sp, #0x1C]
  00040	e3a02903	 mov         r2, #3, 18
  00044	e58d2020	 str         r2, [sp, #0x20]
  00048	e3a02000	 mov         r2, #0
  0004c	e58d2024	 str         r2, [sp, #0x24]
  00050	e3a02000	 mov         r2, #0
  00054	e58d2028	 str         r2, [sp, #0x28]
  00058	e3a02000	 mov         r2, #0
  0005c	e58d202c	 str         r2, [sp, #0x2C]
  00060	e3a02000	 mov         r2, #0
  00064	e5918008	 ldr         r8, [r1, #8]
  00068	e58d2030	 str         r2, [sp, #0x30]
  0006c	e58d1000	 str         r1, [sp]
  00070	e3a02000	 mov         r2, #0
  00074	e3a05001	 mov         r5, #1
  00078	e044300e	 sub         r3, r4, lr
  0007c	e3a01001	 mov         r1, #1
  00080	e58d2034	 str         r2, [sp, #0x34]
  00084	e3590020	 cmp         r9, #0x20
  00088	e58d3004	 str         r3, [sp, #4]
  0008c	e3a0b000	 mov         r11, #0
  00090	e3a04000	 mov         r4, #0
  00094	e58d100c	 str         r1, [sp, #0xC]
  00098	e58d0014	 str         r0, [sp, #0x14]
  0009c	e58d5018	 str         r5, [sp, #0x18]
  000a0	3a00006d	 bcc         |$LN9@DMAFill|
  000a4	e3530020	 cmp         r3, #0x20
  000a8	3a00006b	 bcc         |$LN9@DMAFill|

; 116  : 		}
; 117  :     }
; 118  : 
; 119  :     //  Allocate DMA channel
; 120  :     if( g_hDmaChannel1 == NULL )

  000ac	e59f51f4	 ldr         r5, [pc, #0x1F4]
  000b0	e5953044	 ldr         r3, [r5, #0x44]
  000b4	e3530000	 cmp         r3, #0
  000b8	1a000005	 bne         |$LN6@DMAFill|

; 121  :     {
; 122  :         g_hDmaChannel1 = DmaAllocateChannel(DMA_TYPE_SYSTEM);

  000bc	e3a00000	 mov         r0, #0
  000c0	eb000000	 bl          DmaAllocateChannel
  000c4	e1a03000	 mov         r3, r0

; 123  :         InitializeCriticalSection( &g_csDmaLock );

  000c8	e2850030	 add         r0, r5, #0x30
  000cc	e5853044	 str         r3, [r5, #0x44]
  000d0	eb000000	 bl          InitializeCriticalSection
  000d4		 |$LN6@DMAFill|

; 124  :     }
; 125  : 
; 126  :     //  Lock access to DMA registers
; 127  :     EnterCriticalSection( &g_csDmaLock );

  000d4	e2850030	 add         r0, r5, #0x30
  000d8	eb000000	 bl          EnterCriticalSection

; 128  : 
; 129  :     //  Wait for any pending operations to complete
; 130  :     WaitForNotBusy();

  000dc	e59a3000	 ldr         r3, [r10]
  000e0	e1a0000a	 mov         r0, r10
  000e4	e5933060	 ldr         r3, [r3, #0x60]
  000e8	e1a0e00f	 mov         lr, pc
  000ec	e12fff13	 bx          r3

; 131  : 
; 132  :     //  Configure DMA channel for FILL operation
; 133  :     switch( pParms->pDst->BytesPerPixel() )

  000f0	e5973004	 ldr         r3, [r7, #4]
  000f4	e5933044	 ldr         r3, [r3, #0x44]
  000f8	e3530001	 cmp         r3, #1
  000fc	0a000011	 beq         |$LN3@DMAFill|
  00100	e3530002	 cmp         r3, #2
  00104	0a000008	 beq         |$LN2@DMAFill|
  00108	e3530004	 cmp         r3, #4
  0010c	1a000014	 bne         |$LN4@DMAFill|

; 146  : 
; 147  :         case 4:
; 148  :             DmaSettings.elemSize = DMA_CSDP_DATATYPE_S32;
; 149  :             DmaSettings.dstFrameIndex = 1 + dwStride - 4*dwWidth;
; 150  :             dwOffset = prclDst->top * dwStride + 4 * prclDst->left;

  00110	e5961004	 ldr         r1, [r6, #4]
  00114	e5960000	 ldr         r0, [r6]
  00118	e0483109	 sub         r3, r8, r9, lsl #2
  0011c	e0020891	 mul         r2, r1, r8
  00120	e3a04002	 mov         r4, #2
  00124	e082b100	 add         r11, r2, r0, lsl #2

; 151  :             break;

  00128	ea00000b	 b           |$LN33@DMAFill|
  0012c		 |$LN2@DMAFill|

; 139  :             break;
; 140  : 
; 141  :         case 2:
; 142  :             DmaSettings.elemSize = DMA_CSDP_DATATYPE_S16;
; 143  :             DmaSettings.dstFrameIndex = 1 + dwStride - 2*dwWidth;
; 144  :             dwOffset = prclDst->top * dwStride + 2 * prclDst->left;

  0012c	e5961004	 ldr         r1, [r6, #4]
  00130	e5960000	 ldr         r0, [r6]
  00134	e0483089	 sub         r3, r8, r9, lsl #1
  00138	e0020891	 mul         r2, r1, r8
  0013c	e3a04001	 mov         r4, #1
  00140	e082b080	 add         r11, r2, r0, lsl #1

; 145  :             break;

  00144	ea000004	 b           |$LN33@DMAFill|
  00148		 |$LN3@DMAFill|

; 134  :     {
; 135  :         case 1:
; 136  :             DmaSettings.elemSize = DMA_CSDP_DATATYPE_S8;
; 137  :             DmaSettings.dstFrameIndex = 1 + dwStride - dwWidth;
; 138  :             dwOffset = prclDst->top * dwStride + prclDst->left;

  00148	e5961004	 ldr         r1, [r6, #4]
  0014c	e5962000	 ldr         r2, [r6]
  00150	e0483009	 sub         r3, r8, r9
  00154	e3a04000	 mov         r4, #0
  00158	e02b2891	 mla         r11, r1, r8, r2
  0015c		 |$LN33@DMAFill|
  0015c	e2833001	 add         r3, r3, #1
  00160	e58d301c	 str         r3, [sp, #0x1C]
  00164		 |$LN4@DMAFill|

; 152  :     }
; 153  :     
; 154  :     //  Clear any clipping rect for the operation
; 155  :     pOmapSurf->OmapSurface()->SetClipping( NULL );

  00164	e59d6000	 ldr         r6, [sp]
  00168	e3a01000	 mov         r1, #0
  0016c	e596007c	 ldr         r0, [r6, #0x7C]
  00170	e5903000	 ldr         r3, [r0]
  00174	e5933020	 ldr         r3, [r3, #0x20]
  00178	e1a0e00f	 mov         lr, pc
  0017c	e12fff13	 bx          r3

; 156  : 
; 157  :     //  Enable bursting for improved memory performance
; 158  :     DmaSettings.elemSize |= DMA_CSDP_DST_BURST_64BYTES_16x32_8x64 | DMA_CSDP_DST_PACKED;
; 159  :     
; 160  :     
; 161  :     //  Configure the DMA channel
; 162  :     DmaConfigure( g_hDmaChannel1, &DmaSettings, 0, &g_tDmaDataInfo1 );

  00180	e5950044	 ldr         r0, [r5, #0x44]
  00184	e384ea0e	 orr         lr, r4, #0xE, 20
  00188	e1a03005	 mov         r3, r5
  0018c	e3a02000	 mov         r2, #0
  00190	e28d1008	 add         r1, sp, #8
  00194	e58de008	 str         lr, [sp, #8]
  00198	eb000000	 bl          DmaConfigure

; 163  : 
; 164  :     DmaSetColor( &g_tDmaDataInfo1, DMA_CCR_CONST_FILL_ENABLE, (DWORD)pParms->solidColor );

  0019c	e5952014	 ldr         r2, [r5, #0x14]
  001a0	e5970020	 ldr         r0, [r7, #0x20]

; 165  :     DmaSetSrcBuffer( &g_tDmaDataInfo1, NULL, 0 );

  001a4	e3a04000	 mov         r4, #0
  001a8	e5923000	 ldr         r3, [r2]
  001ac	e3a0e000	 mov         lr, #0
  001b0	e3a07000	 mov         r7, #0
  001b4	e3833801	 orr         r3, r3, #1, 16
  001b8	e5823000	 str         r3, [r2]
  001bc	e5951014	 ldr         r1, [r5, #0x14]

; 166  :     DmaSetDstBuffer( &g_tDmaDataInfo1, NULL, pOmapSurf->OmapSurface()->PhysicalAddr() + dwOffset );

  001c0	e3a03000	 mov         r3, #0
  001c4	e3a02000	 mov         r2, #0
  001c8	e5810044	 str         r0, [r1, #0x44]
  001cc	e5854000	 str         r4, [r5]
  001d0	e585e008	 str         lr, [r5, #8]
  001d4	e5950014	 ldr         r0, [r5, #0x14]
  001d8	e3a01000	 mov         r1, #0
  001dc	e580701c	 str         r7, [r0, #0x1C]
  001e0	e5950014	 ldr         r0, [r5, #0x14]
  001e4	e5807034	 str         r7, [r0, #0x34]
  001e8	e596007c	 ldr         r0, [r6, #0x7C]
  001ec	e5904000	 ldr         r4, [r0]
  001f0	e5944014	 ldr         r4, [r4, #0x14]
  001f4	e1a0e00f	 mov         lr, pc
  001f8	e12fff14	 bx          r4
  001fc	e3a03000	 mov         r3, #0
  00200	e080200b	 add         r2, r0, r11
  00204	e5853004	 str         r3, [r5, #4]
  00208	e585200c	 str         r2, [r5, #0xC]
  0020c	e5953014	 ldr         r3, [r5, #0x14]

; 167  :     DmaSetElementAndFrameCount( &g_tDmaDataInfo1, dwWidth, (UINT16) dwHeight );
; 168  : 
; 169  :     //  Start the DMA operation
; 170  :     DmaStart( &g_tDmaDataInfo1 );
; 171  : 	
; 172  :     //  Unlock access to DMA registers
; 173  :     LeaveCriticalSection( &g_csDmaLock );

  00210	e2850030	 add         r0, r5, #0x30
  00214	e3530000	 cmp         r3, #0
  00218	15832020	 strne       r2, [r3, #0x20]
  0021c	15953014	 ldrne       r3, [r5, #0x14]
  00220	15832038	 strne       r2, [r3, #0x38]
  00224	15953014	 ldrne       r3, [r5, #0x14]
  00228	e5839014	 str         r9, [r3, #0x14]
  0022c	e59d3004	 ldr         r3, [sp, #4]
  00230	e5952014	 ldr         r2, [r5, #0x14]
  00234	e1a03803	 mov         r3, r3, lsl #16
  00238	e1a03823	 mov         r3, r3, lsr #16
  0023c	e5823018	 str         r3, [r2, #0x18]
  00240	e5952014	 ldr         r2, [r5, #0x14]
  00244	e5923000	 ldr         r3, [r2]
  00248	e3833080	 orr         r3, r3, #0x80
  0024c	e5823000	 str         r3, [r2]
  00250	eb000000	 bl          LeaveCriticalSection

; 174  : 
; 175  :     return result;    

  00254	e3a00000	 mov         r0, #0
  00258	ea00000c	 b           |$LN11@DMAFill|
  0025c		 |$LN9@DMAFill|

; 106  :     {
; 107  :         if (g_Globals.m_dwEnableNeonBlts)

  0025c	e59f3040	 ldr         r3, [pc, #0x40]

; 108  :         {
; 109  :         pParms->pBlt = (SCODE (GPE::*)(struct GPEBltParms *)) &OMAPDDGPE::DesignateBlt;
; 110  :         return OMAPDDGPE::DesignateBlt(pParms);

  00260	e1a01007	 mov         r1, r7
  00264	e1a0000a	 mov         r0, r10
  00268	e5933248	 ldr         r3, [r3, #0x248]
  0026c	e3530000	 cmp         r3, #0
  00270	0a000003	 beq         |$LN8@DMAFill|
  00274	e59f3024	 ldr         r3, [pc, #0x24]
  00278	e5873000	 str         r3, [r7]
  0027c	eb000000	 bl          |?DesignateBlt@OMAPDDGPE@@QAAJPAUGPEBltParms@@@Z|
  00280	ea000002	 b           |$LN11@DMAFill|
  00284		 |$LN8@DMAFill|

; 111  :     }
; 112  : 		else
; 113  : 		{
; 114  :             pParms->pBlt = &GPE::EmulatedBlt;

  00284	e59f3010	 ldr         r3, [pc, #0x10]

; 115  :             return GPE::EmulatedBlt(pParms);

  00288	e5873000	 str         r3, [r7]
  0028c	eb000000	 bl          |?EmulatedBlt@GPE@@QAAJPAUGPEBltParms@@@Z|
  00290		 |$LN11@DMAFill|

; 176  : }

  00290	e28dd038	 add         sp, sp, #0x38
  00294	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00298	e12fff1e	 bx          lr
  0029c		 |$LN37@DMAFill|
  0029c		 |$LN38@DMAFill|
  0029c	00000000	 DCD         |?EmulatedBlt@GPE@@QAAJPAUGPEBltParms@@@Z|
  002a0		 |$LN39@DMAFill|
  002a0	00000000	 DCD         |?DesignateBlt@OMAPDDGPE@@QAAJPAUGPEBltParms@@@Z|
  002a4		 |$LN40@DMAFill|
  002a4	00000000	 DCD         |?g_Globals@@3VOMAPDDGPEGlobals@@A|
  002a8		 |$LN41@DMAFill|
  002a8	00000000	 DCD         |?g_tDmaDataInfo1@@3UDmaDataInfo_t@@A|
  002ac		 |$M42783|

			 ENDP  ; |?DMAFill@OMAPDDGPE@@QAAJPAUGPEBltParms@@@Z|, OMAPDDGPE::DMAFill

	EXPORT	|?DMASrcCopy@OMAPDDGPE@@QAAJPAUGPEBltParms@@@Z| ; OMAPDDGPE::DMASrcCopy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\inc\omap_sdma_utility.h

  00000			 AREA	 |.pdata|, PDATA
|$T42922| DCD	|$LN83@DMASrcCopy|
	DCD	0x40015a02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\ddgpe\omap_dmablt.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DMASrcCopy@OMAPDDGPE@@QAAJPAUGPEBltParms@@@Z| PROC ; OMAPDDGPE::DMASrcCopy

; 184  : {

  00000		 |$LN83@DMASrcCopy|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd058	 sub         sp, sp, #0x58
  00008		 |$M42919|
  00008	e1a06001	 mov         r6, r1
  0000c	e1a09000	 mov         r9, r0

; 185  :     SCODE   result = S_OK;
; 186  :     BOOL    bDualDMA = FALSE;
; 187  :     RECTL*  prclSrc = pParms->prclSrc;
; 188  :     RECTL*  prclDst = pParms->prclDst;

  00010	e5962014	 ldr         r2, [r6, #0x14]

; 189  :     DWORD   dwPixelSize = pParms->pDst->BytesPerPixel();

  00014	e5961004	 ldr         r1, [r6, #4]

; 190  :     DWORD   dwWidth  = prclDst->right - prclDst->left;
; 191  :     DWORD   dwHeight = prclDst->bottom - prclDst->top;
; 192  :     DWORD   dwSrcStride = pParms->pSrc->Stride();

  00018	e5960008	 ldr         r0, [r6, #8]
  0001c	e592e008	 ldr         lr, [r2, #8]
  00020	e5923000	 ldr         r3, [r2]
  00024	e592400c	 ldr         r4, [r2, #0xC]
  00028	e58d2008	 str         r2, [sp, #8]
  0002c	e5922004	 ldr         r2, [r2, #4]
  00030	e04e8003	 sub         r8, lr, r3

; 193  :     DWORD   dwDstStride = pParms->pDst->Stride();
; 194  :     DWORD   dwSrcOffset = 0;
; 195  :     DWORD   dwDstOffset = 0;
; 196  :     DWORD   dwSrcMidpoint = 0;
; 197  :     DWORD   dwDstMidpoint = 0;
; 198  :     DWORD   dwWidth1 = dwWidth, 
; 199  :             dwWidth2 = dwWidth;
; 200  :     DWORD   dwHeight1 = dwHeight, 
; 201  :             dwHeight2 = dwHeight;
; 202  :     
; 203  :     OMAPDDGPESurface*   pOmapSrcSurf = (OMAPDDGPESurface*) pParms->pSrc;
; 204  :     OMAPDDGPESurface*   pOmapDstSurf = (OMAPDDGPESurface*) pParms->pDst;
; 205  :      
; 206  :     DmaConfigInfo_t DmaSettings = {
; 207  :         0,                          // elemSize
; 208  :         1,                          // srcElemIndex
; 209  :         1,                          // srcFrameIndex

  00034	e3a0e001	 mov         lr, #1
  00038	e0443002	 sub         r3, r4, r2

; 210  :         DMA_CCR_SRC_AMODE_DOUBLE,   // srcAddrMode
; 211  :         1,                          // dstElemIndex
; 212  :         1,                          // dstFrameIndex
; 213  :         DMA_CCR_DST_AMODE_DOUBLE,   // dstAddrMode
; 214  :         FALSE,                      // dmaPrio
; 215  :         DMA_SYNCH_TRIGGER_NONE,     // synchTrigger
; 216  :         DMA_SYNCH_NONE,             // synchMode
; 217  :         0,                          // interrupts
; 218  :         0                           // syncMap
; 219  :     };
; 220  : 
; 221  : 
; 222  :     //  Check that a DMA Blt is worth doing
; 223  :     if( dwWidth < MIN_DMA_WIDTH || dwHeight < MIN_DMA_HEIGHT )

  0003c	e5962018	 ldr         r2, [r6, #0x18]
  00040	e3a05a03	 mov         r5, #3, 20
  00044	e5914044	 ldr         r4, [r1, #0x44]
  00048	e58d2000	 str         r2, [sp]
  0004c	e3a02000	 mov         r2, #0
  00050	e58d200c	 str         r2, [sp, #0xC]
  00054	e3a02000	 mov         r2, #0
  00058	e58d2010	 str         r2, [sp, #0x10]
  0005c	e3a02000	 mov         r2, #0
  00060	e58d2004	 str         r2, [sp, #4]
  00064	e3a02001	 mov         r2, #1
  00068	e58d202c	 str         r2, [sp, #0x2C]
  0006c	e3a02001	 mov         r2, #1
  00070	e58d2038	 str         r2, [sp, #0x38]
  00074	e3a02001	 mov         r2, #1
  00078	e58d203c	 str         r2, [sp, #0x3C]
  0007c	e3a02903	 mov         r2, #3, 18
  00080	e58d2040	 str         r2, [sp, #0x40]
  00084	e3a02000	 mov         r2, #0
  00088	e58d2044	 str         r2, [sp, #0x44]
  0008c	e3a02000	 mov         r2, #0
  00090	e58d2048	 str         r2, [sp, #0x48]
  00094	e3a02000	 mov         r2, #0
  00098	e58d204c	 str         r2, [sp, #0x4C]
  0009c	e3a02000	 mov         r2, #0
  000a0	e58d2050	 str         r2, [sp, #0x50]
  000a4	e3a02000	 mov         r2, #0
  000a8	e590a008	 ldr         r10, [r0, #8]
  000ac	e591b008	 ldr         r11, [r1, #8]
  000b0	e58d2054	 str         r2, [sp, #0x54]
  000b4	e58d101c	 str         r1, [sp, #0x1C]
  000b8	e58d0020	 str         r0, [sp, #0x20]
  000bc	e58d3014	 str         r3, [sp, #0x14]
  000c0	e1a07003	 mov         r7, r3
  000c4	e3580020	 cmp         r8, #0x20
  000c8	e58de030	 str         lr, [sp, #0x30]
  000cc	e58d5034	 str         r5, [sp, #0x34]
  000d0	3a000110	 bcc         |$LN23@DMASrcCopy|
  000d4	e3530020	 cmp         r3, #0x20
  000d8	3a00010e	 bcc         |$LN23@DMASrcCopy|

; 234  : 		}
; 235  :     }
; 236  : 
; 237  :     //  Allocate DMA channels
; 238  :     if( g_hDmaChannel1 == NULL )

  000dc	e59f5480	 ldr         r5, [pc, #0x480]
  000e0	e5953044	 ldr         r3, [r5, #0x44]
  000e4	e3530000	 cmp         r3, #0
  000e8	1a000005	 bne         |$LN20@DMASrcCopy|

; 239  :     {
; 240  :         g_hDmaChannel1 = DmaAllocateChannel(DMA_TYPE_SYSTEM);

  000ec	e3a00000	 mov         r0, #0
  000f0	eb000000	 bl          DmaAllocateChannel
  000f4	e1a03000	 mov         r3, r0

; 241  :         InitializeCriticalSection( &g_csDmaLock );

  000f8	e2850030	 add         r0, r5, #0x30
  000fc	e5853044	 str         r3, [r5, #0x44]
  00100	eb000000	 bl          InitializeCriticalSection
  00104		 |$LN20@DMASrcCopy|

; 242  :     }
; 243  : 
; 244  :     if( g_hDmaChannel2 == NULL )

  00104	e5953048	 ldr         r3, [r5, #0x48]
  00108	e3530000	 cmp         r3, #0
  0010c	1a000002	 bne         |$LN19@DMASrcCopy|

; 245  :     {
; 246  :         g_hDmaChannel2 = DmaAllocateChannel(DMA_TYPE_SYSTEM);

  00110	e3a00000	 mov         r0, #0
  00114	eb000000	 bl          DmaAllocateChannel
  00118	e5850048	 str         r0, [r5, #0x48]
  0011c		 |$LN19@DMASrcCopy|

; 247  :     }
; 248  : 
; 249  : 
; 250  :     //  Lock access to DMA registers
; 251  :     EnterCriticalSection( &g_csDmaLock );

  0011c	e2850030	 add         r0, r5, #0x30
  00120	eb000000	 bl          EnterCriticalSection

; 252  : 
; 253  :     //  Wait for any pending operations to complete
; 254  :     WaitForNotBusy();

  00124	e5993000	 ldr         r3, [r9]
  00128	e1a00009	 mov         r0, r9
  0012c	e5933060	 ldr         r3, [r3, #0x60]
  00130	e1a0e00f	 mov         lr, pc
  00134	e12fff13	 bx          r3

; 255  :         
; 256  :     //  Configure DMA channel for SRCCPY operation
; 257  :     switch( pParms->pDst->BytesPerPixel() )

  00138	e5963004	 ldr         r3, [r6, #4]
  0013c	e5933044	 ldr         r3, [r3, #0x44]
  00140	e3530001	 cmp         r3, #1
  00144	0a000009	 beq         |$LN16@DMASrcCopy|
  00148	e3530002	 cmp         r3, #2
  0014c	0a000004	 beq         |$LN15@DMASrcCopy|
  00150	e3530004	 cmp         r3, #4
  00154	1a000007	 bne         |$LN17@DMASrcCopy|

; 266  : 
; 267  :         case 4:
; 268  :             DmaSettings.elemSize = DMA_CSDP_DATATYPE_S32;

  00158	e3a02002	 mov         r2, #2
  0015c	e58d2004	 str         r2, [sp, #4]
  00160	ea000004	 b           |$LN17@DMASrcCopy|
  00164		 |$LN15@DMASrcCopy|

; 261  :             break;
; 262  : 
; 263  :         case 2:
; 264  :             DmaSettings.elemSize = DMA_CSDP_DATATYPE_S16;

  00164	e3a02001	 mov         r2, #1
  00168	e58d2004	 str         r2, [sp, #4]

; 265  :             break;

  0016c	ea000001	 b           |$LN17@DMASrcCopy|
  00170		 |$LN16@DMASrcCopy|

; 258  :     {
; 259  :         case 1:
; 260  :             DmaSettings.elemSize = DMA_CSDP_DATATYPE_S8;

  00170	e3a03000	 mov         r3, #0
  00174	e58d3004	 str         r3, [sp, #4]
  00178		 |$LN17@DMASrcCopy|

; 269  :             break;
; 270  :     }
; 271  : 
; 272  : 
; 273  :     //  Compute element indexing, frame indexing and starting offset for both surfaces
; 274  :     //  Note that both xPos and yPos will never be both < 0
; 275  :     //  Also note that xPos !=1 prevents bursting and actually slows DMA down below memcpy speeds
; 276  :     if( pParms->xPositive )

  00178	e5963034	 ldr         r3, [r6, #0x34]

; 277  :     {
; 278  :         //  Index x axis in positive direction (left to right)
; 279  :         DmaSettings.srcElemIndex = 1;
; 280  :         DmaSettings.dstElemIndex = 1;
; 281  :         
; 282  :         //  Offset from left side of surface
; 283  :         dwSrcOffset = dwPixelSize * prclSrc->left;
; 284  :         dwDstOffset = dwPixelSize * prclDst->left;

  0017c	e59de008	 ldr         lr, [sp, #8]
  00180	e3530000	 cmp         r3, #0
  00184	e58d3018	 str         r3, [sp, #0x18]
  00188	e59d3000	 ldr         r3, [sp]
  0018c	159e2000	 ldrne       r2, [lr]
  00190	13a01001	 movne       r1, #1
  00194	15933000	 ldrne       r3, [r3]
  00198	158d1038	 strne       r1, [sp, #0x38]

; 285  :     }
; 286  :     else
; 287  :     {
; 288  :         //  Index x axis in negative direction (right to left)
; 289  :         DmaSettings.srcElemIndex = 1 - 2*dwPixelSize;
; 290  :         DmaSettings.dstElemIndex = 1 - 2*dwPixelSize;
; 291  : 
; 292  :         //  Offset from right side of surface
; 293  :         dwSrcOffset = dwPixelSize * (prclSrc->right - 1);
; 294  :         dwDstOffset = dwPixelSize * (prclDst->right - 1);

  0019c	059e1008	 ldreq       r1, [lr, #8]
  001a0	05932008	 ldreq       r2, [r3, #8]
  001a4	01a03084	 moveq       r3, r4, lsl #1
  001a8	13a00001	 movne       r0, #1
  001ac	02630001	 rsbeq       r0, r3, #1
  001b0	02423001	 subeq       r3, r2, #1
  001b4	02412001	 subeq       r2, r1, #1
  001b8	e0090493	 mul         r9, r3, r4
  001bc	e0030492	 mul         r3, r2, r4
  001c0	01a01000	 moveq       r1, r0
  001c4	058d0038	 streq       r0, [sp, #0x38]
  001c8	e58d002c	 str         r0, [sp, #0x2C]
  001cc	e58d3008	 str         r3, [sp, #8]

; 295  :     }
; 296  : 
; 297  :     if( pParms->yPositive )

  001d0	e5963038	 ldr         r3, [r6, #0x38]
  001d4	e3530000	 cmp         r3, #0
  001d8	e58d3024	 str         r3, [sp, #0x24]

; 298  :     {
; 299  :         //  Index y axis in positive direction (top to bottom)
; 300  :         DmaSettings.srcFrameIndex = DmaSettings.srcElemIndex + dwSrcStride;
; 301  :         DmaSettings.dstFrameIndex = DmaSettings.dstElemIndex + dwDstStride;
; 302  :         
; 303  :         if( pParms->xPositive )

  001dc	e59d3018	 ldr         r3, [sp, #0x18]
  001e0	0a00000f	 beq         |$LN11@DMASrcCopy|
  001e4	e3530000	 cmp         r3, #0

; 304  :         {
; 305  :             DmaSettings.srcFrameIndex -= dwWidth*dwPixelSize;

  001e8	10030498	 mulne       r3, r8, r4
  001ec	e080200a	 add         r2, r0, r10
  001f0	e081100b	 add         r1, r1, r11
  001f4	10422003	 subne       r2, r2, r3

; 306  :             DmaSettings.dstFrameIndex -= dwWidth*dwPixelSize;

  001f8	10413003	 subne       r3, r1, r3
  001fc	158d2030	 strne       r2, [sp, #0x30]
  00200	158d303c	 strne       r3, [sp, #0x3C]

; 307  :         }
; 308  :         else
; 309  :         {
; 310  :             DmaSettings.srcFrameIndex += dwWidth*dwPixelSize;

  00204	00232498	 mlaeq       r3, r8, r4, r2

; 311  :             DmaSettings.dstFrameIndex += dwWidth*dwPixelSize;

  00208	00221498	 mlaeq       r2, r8, r4, r1
  0020c	058d3030	 streq       r3, [sp, #0x30]

; 312  :         }
; 313  : 
; 314  :         //  Offset from top side of surface
; 315  :         dwSrcOffset = dwSrcOffset + prclSrc->top * dwSrcStride;

  00210	e59d3000	 ldr         r3, [sp]
  00214	058d203c	 streq       r2, [sp, #0x3C]

; 316  :         dwDstOffset = dwDstOffset + prclDst->top * dwDstStride;

  00218	e59e2004	 ldr         r2, [lr, #4]
  0021c	e5933004	 ldr         r3, [r3, #4]

; 317  :     }
; 318  :     else

  00220	ea000010	 b           |$LN78@DMASrcCopy|
  00224		 |$LN11@DMASrcCopy|

; 319  :     {
; 320  :         //  Index y axis in negative direction (bottom to top)
; 321  :         DmaSettings.srcFrameIndex = DmaSettings.srcElemIndex - dwSrcStride;
; 322  :         DmaSettings.dstFrameIndex = DmaSettings.dstElemIndex - dwDstStride;
; 323  : 
; 324  :         if( pParms->xPositive )

  00224	e3530000	 cmp         r3, #0

; 325  :         {
; 326  :             DmaSettings.srcFrameIndex -= dwWidth*dwPixelSize;

  00228	10030498	 mulne       r3, r8, r4
  0022c	e040200a	 sub         r2, r0, r10
  00230	e041100b	 sub         r1, r1, r11
  00234	10422003	 subne       r2, r2, r3

; 327  :             DmaSettings.dstFrameIndex -= dwWidth*dwPixelSize;

  00238	10413003	 subne       r3, r1, r3
  0023c	158d2030	 strne       r2, [sp, #0x30]
  00240	158d303c	 strne       r3, [sp, #0x3C]

; 328  :         }
; 329  :         else
; 330  :         {
; 331  :             DmaSettings.srcFrameIndex += dwWidth*dwPixelSize;

  00244	00232498	 mlaeq       r3, r8, r4, r2

; 332  :             DmaSettings.dstFrameIndex += dwWidth*dwPixelSize;

  00248	00221498	 mlaeq       r2, r8, r4, r1
  0024c	058d3030	 streq       r3, [sp, #0x30]

; 333  :         }
; 334  : 
; 335  :         //  Offset from bottom side of surface
; 336  :         dwSrcOffset = dwSrcOffset + (prclSrc->bottom - 1) * dwSrcStride;

  00250	e59d3000	 ldr         r3, [sp]
  00254	058d203c	 streq       r2, [sp, #0x3C]

; 337  :         dwDstOffset = dwDstOffset + (prclDst->bottom - 1) * dwDstStride;

  00258	e59e200c	 ldr         r2, [lr, #0xC]
  0025c	e593300c	 ldr         r3, [r3, #0xC]
  00260	e2422001	 sub         r2, r2, #1
  00264	e2433001	 sub         r3, r3, #1
  00268		 |$LN78@DMASrcCopy|
  00268	e0219a93	 mla         r1, r3, r10, r9
  0026c	e59d3008	 ldr         r3, [sp, #8]

; 338  :     }
; 339  :  
; 340  :     //
; 341  :     //  Check for fast dual DMA cases
; 342  :     //
; 343  :     
; 344  :     //  Different src and dst surfaces can use dual DMA
; 345  :     if( pOmapSrcSurf != pOmapDstSurf )

  00270	e59d4020	 ldr         r4, [sp, #0x20]
  00274	e58d1018	 str         r1, [sp, #0x18]
  00278	e0293b92	 mla         r9, r2, r11, r3
  0027c	e59d301c	 ldr         r3, [sp, #0x1C]
  00280	e1540003	 cmp         r4, r3
  00284	0a000010	 beq         |$LN75@DMASrcCopy|

; 346  :     {
; 347  :         //  Split work in half vertically
; 348  :         dwHeight1 = dwHeight/2;  

  00288	e59d3014	 ldr         r3, [sp, #0x14]

; 349  :         dwHeight2 = dwHeight - dwHeight1;
; 350  :         
; 351  :         dwSrcMidpoint = (pParms->yPositive) ? dwSrcOffset + dwHeight1*dwSrcStride : dwSrcOffset - dwHeight1*dwSrcStride;  

  0028c	e59d2024	 ldr         r2, [sp, #0x24]
  00290	e1a070a3	 mov         r7, r3, lsr #1
  00294	e0433007	 sub         r3, r3, r7
  00298	e3520000	 cmp         r2, #0
  0029c	e58d3014	 str         r3, [sp, #0x14]
  002a0	10231a97	 mlane       r3, r7, r10, r1
  002a4	00030a97	 muleq       r3, r7, r10

; 352  :         dwDstMidpoint = (pParms->yPositive) ? dwDstOffset + dwHeight1*dwDstStride : dwDstOffset - dwHeight1*dwDstStride;  
; 353  : 
; 354  :         bDualDMA = TRUE;     

  002a8	e3a0a001	 mov         r10, #1
  002ac	00413003	 subeq       r3, r1, r3
  002b0	e3520000	 cmp         r2, #0
  002b4	e58d300c	 str         r3, [sp, #0xC]
  002b8	10239b97	 mlane       r3, r7, r11, r9
  002bc	00030b97	 muleq       r3, r7, r11
  002c0	00493003	 subeq       r3, r9, r3
  002c4	e58d3010	 str         r3, [sp, #0x10]
  002c8	ea000000	 b           |$LN5@DMASrcCopy|
  002cc		 |$LN75@DMASrcCopy|

; 285  :     }
; 286  :     else
; 287  :     {
; 288  :         //  Index x axis in negative direction (right to left)
; 289  :         DmaSettings.srcElemIndex = 1 - 2*dwPixelSize;
; 290  :         DmaSettings.dstElemIndex = 1 - 2*dwPixelSize;
; 291  : 
; 292  :         //  Offset from right side of surface
; 293  :         dwSrcOffset = dwPixelSize * (prclSrc->right - 1);
; 294  :         dwDstOffset = dwPixelSize * (prclDst->right - 1);

  002cc	e3a0a000	 mov         r10, #0
  002d0		 |$LN5@DMASrcCopy|

; 355  :     }
; 356  :  
; 357  :     
; 358  :     //  Clear any clipping rect for the operation
; 359  :     pOmapSrcSurf->OmapSurface()->SetClipping( NULL );

  002d0	e594007c	 ldr         r0, [r4, #0x7C]
  002d4	e3a01000	 mov         r1, #0
  002d8	e5903000	 ldr         r3, [r0]
  002dc	e5933020	 ldr         r3, [r3, #0x20]
  002e0	e1a0e00f	 mov         lr, pc
  002e4	e12fff13	 bx          r3

; 360  :     pOmapDstSurf->OmapSurface()->SetClipping( NULL );

  002e8	e59db01c	 ldr         r11, [sp, #0x1C]
  002ec	e3a01000	 mov         r1, #0
  002f0	e59b007c	 ldr         r0, [r11, #0x7C]
  002f4	e5903000	 ldr         r3, [r0]
  002f8	e5933020	 ldr         r3, [r3, #0x20]
  002fc	e1a0e00f	 mov         lr, pc
  00300	e12fff13	 bx          r3

; 361  : 
; 362  : 
; 363  :     //  Enable bursting for improved memory performance
; 364  :     DmaSettings.elemSize |= DMA_CSDP_SRC_BURST_64BYTES_16x32_8x64 | DMA_CSDP_SRC_PACKED;
; 365  :     DmaSettings.elemSize |= DMA_CSDP_DST_BURST_64BYTES_16x32_8x64 | DMA_CSDP_DST_PACKED;
; 366  :     
; 367  :     
; 368  :     //  Configure the DMA channel
; 369  :     DmaConfigure( g_hDmaChannel1, &DmaSettings, 0, &g_tDmaDataInfo1 );

  00304	e59d2004	 ldr         r2, [sp, #4]
  00308	e3a03ce1	 mov         r3, #0xE1, 24
  0030c	e38330c0	 orr         r3, r3, #0xC0
  00310	e5950044	 ldr         r0, [r5, #0x44]
  00314	e1823003	 orr         r3, r2, r3
  00318	e58d3028	 str         r3, [sp, #0x28]
  0031c	e1a03005	 mov         r3, r5
  00320	e3a02000	 mov         r2, #0
  00324	e28d1028	 add         r1, sp, #0x28
  00328	eb000000	 bl          DmaConfigure

; 370  : 
; 371  :     DmaSetSrcBuffer( &g_tDmaDataInfo1, NULL, pOmapSrcSurf->OmapSurface()->PhysicalAddr() + dwSrcOffset );

  0032c	e594007c	 ldr         r0, [r4, #0x7C]
  00330	e3a03000	 mov         r3, #0
  00334	e3a02000	 mov         r2, #0
  00338	e590e000	 ldr         lr, [r0]
  0033c	e3a01000	 mov         r1, #0
  00340	e59e4014	 ldr         r4, [lr, #0x14]
  00344	e1a0e00f	 mov         lr, pc
  00348	e12fff14	 bx          r4
  0034c	e59d3018	 ldr         r3, [sp, #0x18]

; 372  :     DmaSetDstBuffer( &g_tDmaDataInfo1, NULL, pOmapDstSurf->OmapSurface()->PhysicalAddr() + dwDstOffset );

  00350	e3a01000	 mov         r1, #0
  00354	e0802003	 add         r2, r0, r3
  00358	e3a03000	 mov         r3, #0
  0035c	e5853000	 str         r3, [r5]
  00360	e5852008	 str         r2, [r5, #8]
  00364	e5953014	 ldr         r3, [r5, #0x14]
  00368	e3530000	 cmp         r3, #0
  0036c	1583201c	 strne       r2, [r3, #0x1C]
  00370	15953014	 ldrne       r3, [r5, #0x14]
  00374	15832034	 strne       r2, [r3, #0x34]
  00378	e59b007c	 ldr         r0, [r11, #0x7C]
  0037c	e3a03000	 mov         r3, #0
  00380	e3a02000	 mov         r2, #0
  00384	e590e000	 ldr         lr, [r0]
  00388	e59e4014	 ldr         r4, [lr, #0x14]
  0038c	e1a0e00f	 mov         lr, pc
  00390	e12fff14	 bx          r4
  00394	e3a03000	 mov         r3, #0
  00398	e0802009	 add         r2, r0, r9
  0039c	e5853004	 str         r3, [r5, #4]
  003a0	e585200c	 str         r2, [r5, #0xC]
  003a4	e5953014	 ldr         r3, [r5, #0x14]
  003a8	e3530000	 cmp         r3, #0
  003ac	15832020	 strne       r2, [r3, #0x20]
  003b0	15953014	 ldrne       r3, [r5, #0x14]
  003b4	15832038	 strne       r2, [r3, #0x38]
  003b8	15953014	 ldrne       r3, [r5, #0x14]

; 373  :     DmaSetElementAndFrameCount( &g_tDmaDataInfo1, dwWidth1, (UINT16) dwHeight1);
; 374  : 
; 375  :     if( bDualDMA )

  003bc	e35a0000	 cmp         r10, #0
  003c0	e5838014	 str         r8, [r3, #0x14]
  003c4	e5952014	 ldr         r2, [r5, #0x14]
  003c8	e1a03807	 mov         r3, r7, lsl #16
  003cc	e1a03823	 mov         r3, r3, lsr #16
  003d0	e5823018	 str         r3, [r2, #0x18]
  003d4	0a000030	 beq         |$LN65@DMASrcCopy|

; 376  : 	{
; 377  :         DmaConfigure( g_hDmaChannel2, &DmaSettings, 0, &g_tDmaDataInfo2 );

  003d8	e5950048	 ldr         r0, [r5, #0x48]
  003dc	e2853018	 add         r3, r5, #0x18
  003e0	e3a02000	 mov         r2, #0
  003e4	e28d1028	 add         r1, sp, #0x28
  003e8	eb000000	 bl          DmaConfigure

; 378  : 
; 379  :         DmaSetSrcBuffer( &g_tDmaDataInfo2, NULL, pOmapSrcSurf->OmapSurface()->PhysicalAddr() + dwSrcMidpoint );

  003ec	e59d3020	 ldr         r3, [sp, #0x20]
  003f0	e3a02000	 mov         r2, #0
  003f4	e3a01000	 mov         r1, #0
  003f8	e593007c	 ldr         r0, [r3, #0x7C]
  003fc	e3a03000	 mov         r3, #0
  00400	e590e000	 ldr         lr, [r0]
  00404	e59e4014	 ldr         r4, [lr, #0x14]
  00408	e1a0e00f	 mov         lr, pc
  0040c	e12fff14	 bx          r4
  00410	e59d300c	 ldr         r3, [sp, #0xC]

; 380  :         DmaSetDstBuffer( &g_tDmaDataInfo2, NULL, pOmapDstSurf->OmapSurface()->PhysicalAddr() + dwDstMidpoint );

  00414	e3a01000	 mov         r1, #0
  00418	e0802003	 add         r2, r0, r3
  0041c	e3a03000	 mov         r3, #0
  00420	e5853018	 str         r3, [r5, #0x18]
  00424	e5852020	 str         r2, [r5, #0x20]
  00428	e595302c	 ldr         r3, [r5, #0x2C]
  0042c	e3530000	 cmp         r3, #0
  00430	1583201c	 strne       r2, [r3, #0x1C]
  00434	1595302c	 ldrne       r3, [r5, #0x2C]
  00438	15832034	 strne       r2, [r3, #0x34]
  0043c	e59b007c	 ldr         r0, [r11, #0x7C]
  00440	e3a03000	 mov         r3, #0
  00444	e3a02000	 mov         r2, #0
  00448	e590e000	 ldr         lr, [r0]
  0044c	e59e4014	 ldr         r4, [lr, #0x14]
  00450	e1a0e00f	 mov         lr, pc
  00454	e12fff14	 bx          r4
  00458	e59d3010	 ldr         r3, [sp, #0x10]
  0045c	e0802003	 add         r2, r0, r3
  00460	e3a03000	 mov         r3, #0
  00464	e585301c	 str         r3, [r5, #0x1C]
  00468	e5852024	 str         r2, [r5, #0x24]
  0046c	e595302c	 ldr         r3, [r5, #0x2C]
  00470	e3530000	 cmp         r3, #0
  00474	15832020	 strne       r2, [r3, #0x20]
  00478	1595302c	 ldrne       r3, [r5, #0x2C]
  0047c	15832038	 strne       r2, [r3, #0x38]
  00480	1595302c	 ldrne       r3, [r5, #0x2C]

; 381  :         DmaSetElementAndFrameCount( &g_tDmaDataInfo2, dwWidth2, (UINT16) dwHeight2 );

  00484	e5838014	 str         r8, [r3, #0x14]
  00488	e59d3014	 ldr         r3, [sp, #0x14]
  0048c	e595202c	 ldr         r2, [r5, #0x2C]
  00490	e1a03803	 mov         r3, r3, lsl #16
  00494	e1a03823	 mov         r3, r3, lsr #16
  00498	e5823018	 str         r3, [r2, #0x18]
  0049c		 |$LN65@DMASrcCopy|

; 382  : 	}
; 383  : 
; 384  :     //  Configure for transparent copy if requested
; 385  :     if( pParms->bltFlags & BLT_TRANSPARENT )

  0049c	e5963024	 ldr         r3, [r6, #0x24]
  004a0	e3130004	 tst         r3, #4
  004a4	0a00000e	 beq         |$LN69@DMASrcCopy|

; 386  :     {
; 387  :         DmaSetColor( &g_tDmaDataInfo1, DMA_CCR_TRANSPARENT_COPY_ENABLE, (DWORD)pParms->solidColor );

  004a8	e5952014	 ldr         r2, [r5, #0x14]
  004ac	e5961020	 ldr         r1, [r6, #0x20]

; 388  :         if( bDualDMA )

  004b0	e35a0000	 cmp         r10, #0
  004b4	e5923000	 ldr         r3, [r2]
  004b8	e3833802	 orr         r3, r3, #2, 16
  004bc	e5823000	 str         r3, [r2]
  004c0	e5953014	 ldr         r3, [r5, #0x14]
  004c4	e5831044	 str         r1, [r3, #0x44]

; 389  :             DmaSetColor( &g_tDmaDataInfo2, DMA_CCR_TRANSPARENT_COPY_ENABLE, (DWORD)pParms->solidColor );

  004c8	1595202c	 ldrne       r2, [r5, #0x2C]
  004cc	15961020	 ldrne       r1, [r6, #0x20]
  004d0	15923000	 ldrne       r3, [r2]
  004d4	13833802	 orrne       r3, r3, #2, 16
  004d8	15823000	 strne       r3, [r2]
  004dc	1595302c	 ldrne       r3, [r5, #0x2C]
  004e0	15831044	 strne       r1, [r3, #0x44]
  004e4		 |$LN69@DMASrcCopy|

; 390  :     }
; 391  :        
; 392  :        
; 393  :     //  Start the DMA operation(s)
; 394  :     DmaStart( &g_tDmaDataInfo1 );

  004e4	e5952014	 ldr         r2, [r5, #0x14]

; 395  :     
; 396  :     if( bDualDMA )

  004e8	e35a0000	 cmp         r10, #0

; 397  :         DmaStart( &g_tDmaDataInfo2 );
; 398  : 
; 399  :     //  Unlock access to DMA registers
; 400  :     LeaveCriticalSection( &g_csDmaLock );

  004ec	e2850030	 add         r0, r5, #0x30
  004f0	e5923000	 ldr         r3, [r2]
  004f4	e3833080	 orr         r3, r3, #0x80
  004f8	e5823000	 str         r3, [r2]
  004fc	1595202c	 ldrne       r2, [r5, #0x2C]
  00500	15923000	 ldrne       r3, [r2]
  00504	13833080	 orrne       r3, r3, #0x80
  00508	15823000	 strne       r3, [r2]
  0050c	eb000000	 bl          LeaveCriticalSection

; 401  : 
; 402  :     return result;    

  00510	e3a00000	 mov         r0, #0
  00514	ea00000c	 b           |$LN25@DMASrcCopy|
  00518		 |$LN23@DMASrcCopy|

; 224  :     {
; 225  :         if (g_Globals.m_dwEnableNeonBlts)

  00518	e59f3040	 ldr         r3, [pc, #0x40]

; 226  :         {
; 227  :         pParms->pBlt = (SCODE (GPE::*)(struct GPEBltParms *)) &OMAPDDGPE::DesignateBlt;
; 228  :         return OMAPDDGPE::DesignateBlt(pParms);

  0051c	e1a01006	 mov         r1, r6
  00520	e1a00009	 mov         r0, r9
  00524	e5933248	 ldr         r3, [r3, #0x248]
  00528	e3530000	 cmp         r3, #0
  0052c	0a000003	 beq         |$LN22@DMASrcCopy|
  00530	e59f3024	 ldr         r3, [pc, #0x24]
  00534	e5863000	 str         r3, [r6]
  00538	eb000000	 bl          |?DesignateBlt@OMAPDDGPE@@QAAJPAUGPEBltParms@@@Z|
  0053c	ea000002	 b           |$LN25@DMASrcCopy|
  00540		 |$LN22@DMASrcCopy|

; 229  : 		}
; 230  : 		else
; 231  : 		{
; 232  :             pParms->pBlt = &GPE::EmulatedBlt;

  00540	e59f3010	 ldr         r3, [pc, #0x10]

; 233  :             return GPE::EmulatedBlt(pParms);

  00544	e5863000	 str         r3, [r6]
  00548	eb000000	 bl          |?EmulatedBlt@GPE@@QAAJPAUGPEBltParms@@@Z|
  0054c		 |$LN25@DMASrcCopy|

; 403  : }

  0054c	e28dd058	 add         sp, sp, #0x58
  00550	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00554	e12fff1e	 bx          lr
  00558		 |$LN84@DMASrcCopy|
  00558		 |$LN85@DMASrcCopy|
  00558	00000000	 DCD         |?EmulatedBlt@GPE@@QAAJPAUGPEBltParms@@@Z|
  0055c		 |$LN86@DMASrcCopy|
  0055c	00000000	 DCD         |?DesignateBlt@OMAPDDGPE@@QAAJPAUGPEBltParms@@@Z|
  00560		 |$LN87@DMASrcCopy|
  00560	00000000	 DCD         |?g_Globals@@3VOMAPDDGPEGlobals@@A|
  00564		 |$LN88@DMASrcCopy|
  00564	00000000	 DCD         |?g_tDmaDataInfo1@@3UDmaDataInfo_t@@A|
  00568		 |$M42920|

			 ENDP  ; |?DMASrcCopy@OMAPDDGPE@@QAAJPAUGPEBltParms@@@Z|, OMAPDDGPE::DMASrcCopy

	END
