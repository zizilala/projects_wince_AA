; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\DSS\DSSAI\surfmgr_vrfb.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|DEVICE_IFC_VRFB_GUID| [ DATA ]
	EXPORT	|?g_bVRFBViewReserved@@3PAHA| [ DATA ]	; g_bVRFBViewReserved

  00000			 AREA	 |.bss|, NOINIT
|?g_bVRFBViewReserved@@3PAHA| % 0x30			; g_bVRFBViewReserved

  00000			 AREA	 |.rdata|, DATA, READONLY
|DEVICE_IFC_VRFB_GUID| DCD 0xede6bb10
	DCW	0xd844
	DCW	0x4639
	DCB	0xa7
	DCB	0xb6
	DCB	0xca
	DCB	0x19
	DCB	0x9c
	DCB	0xd9
	DCB	0xeb
	DCB	0x34
	EXPORT	|CeSetMemoryAttributes|
	IMPORT	|KernelLibIoControl|
; File c:\wince600\public\common\oak\inc\pkfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T37784| DCD	|$LN5@CeSetMemor|
	DCD	0x40001002
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |CeSetMemoryAttributes| PROC

; 1422 : {

  00000		 |$LN5@CeSetMemor|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M37781|
  00008	e1a04003	 mov         r4, r3
  0000c	e1a03002	 mov         r3, r2
  00010	e1a02000	 mov         r2, r0
  00014	e1a0e001	 mov         lr, r1

; 1423 :     return KernelLibIoControl ((HANDLE) KMOD_CORE, IOCTL_KLIB_SETMEMORYATTR,
; 1424 :         pVirtualAddr, cbSize, pShiftedPhysAddr, dwAttributes, NULL);

  00018	e3a01000	 mov         r1, #0
  0001c	e58d1008	 str         r1, [sp, #8]
  00020	e3a0100c	 mov         r1, #0xC
  00024	e3a00001	 mov         r0, #1
  00028	e58d4004	 str         r4, [sp, #4]
  0002c	e58de000	 str         lr, [sp]
  00030	eb000000	 bl          KernelLibIoControl

; 1425 : }

  00034	e28dd00c	 add         sp, sp, #0xC
  00038	e8bd4010	 ldmia       sp!, {r4, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$M37782|

			 ENDP  ; |CeSetMemoryAttributes|

	EXPORT	|??0OMAPSurface@@QAA@XZ|		; OMAPSurface::OMAPSurface
	EXPORT	|??_7OMAPSurface@@6B@| [ DATA ]		; OMAPSurface::`vftable'
	IMPORT	|??_EOMAPSurface@@UAAPAXI@Z|, WEAK |??_GOMAPSurface@@UAAPAXI@Z| ; OMAPSurface::`vector deleting destructor', OMAPSurface::`scalar deleting destructor'
	IMPORT	|_purecall|
	IMPORT	|?SetClipping@OMAPSurface@@UAAHPAUtagRECT@@@Z| ; OMAPSurface::SetClipping
	IMPORT	|?UpdateClipping@OMAPSurface@@UAAHPAUtagRECT@@@Z| ; OMAPSurface::UpdateClipping
	IMPORT	|?GetClipping@OMAPSurface@@UAA?AUtagRECT@@XZ| ; OMAPSurface::GetClipping
	IMPORT	|?AdjustClippingRect@OMAPSurface@@UAAHPAUtagRECT@@EE@Z| ; OMAPSurface::AdjustClippingRect
	IMPORT	|?SetHorizontalScaling@OMAPSurface@@UAAHK@Z| ; OMAPSurface::SetHorizontalScaling
	IMPORT	|?SetVerticalScaling@OMAPSurface@@UAAHK@Z| ; OMAPSurface::SetVerticalScaling
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\inc\dssai.h

  00000			 AREA	 |.pdata|, PDATA
|$T37794| DCD	|$LN5@OMAPSurfac|
	DCD	0x40000500

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7OMAPSurface@@6B@| DCD |??_EOMAPSurface@@UAAPAXI@Z|	; OMAPSurface::`vftable'
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|?SetClipping@OMAPSurface@@UAAHPAUtagRECT@@@Z|
	DCD	|?UpdateClipping@OMAPSurface@@UAAHPAUtagRECT@@@Z|
	DCD	|?GetClipping@OMAPSurface@@UAA?AUtagRECT@@XZ|
	DCD	|?AdjustClippingRect@OMAPSurface@@UAAHPAUtagRECT@@EE@Z|
	DCD	|?SetHorizontalScaling@OMAPSurface@@UAAHK@Z|
	DCD	|?SetVerticalScaling@OMAPSurface@@UAAHK@Z|
	DCD	|_purecall|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0OMAPSurface@@QAA@XZ| PROC		; OMAPSurface::OMAPSurface

; 739  :     OMAPSurface() {};

  00000		 |$LN5@OMAPSurfac|
  00000		 |$M37791|
  00000	e1a02000	 mov         r2, r0
  00004	e59f3004	 ldr         r3, [pc, #4]
  00008	e5823000	 str         r3, [r2]
  0000c	e12fff1e	 bx          lr
  00010		 |$LN6@OMAPSurfac|
  00010		 |$LN7@OMAPSurfac|
  00010	00000000	 DCD         |??_7OMAPSurface@@6B@|
  00014		 |$M37792|

			 ENDP  ; |??0OMAPSurface@@QAA@XZ|, OMAPSurface::OMAPSurface

	EXPORT	|??1OMAPSurface@@UAA@XZ|		; OMAPSurface::~OMAPSurface

  00000			 AREA	 |.pdata|, PDATA
|$T37804| DCD	|$LN5@OMAPSurfac@2|
	DCD	0x40000400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1OMAPSurface@@UAA@XZ| PROC		; OMAPSurface::~OMAPSurface

; 746  :     ~OMAPSurface() {};

  00000		 |$LN5@OMAPSurfac@2|
  00000		 |$M37801|
  00000	e59f3004	 ldr         r3, [pc, #4]
  00004	e5803000	 str         r3, [r0]
  00008	e12fff1e	 bx          lr
  0000c		 |$LN6@OMAPSurfac@2|
  0000c		 |$LN7@OMAPSurfac@2|
  0000c	00000000	 DCD         |??_7OMAPSurface@@6B@|
  00010		 |$M37802|

			 ENDP  ; |??1OMAPSurface@@UAA@XZ|, OMAPSurface::~OMAPSurface

	IMPORT	|??3@YAXPAX@Z|				; operator delete

  00000			 AREA	 |.pdata|, PDATA
|$T37820| DCD	|$LN8@scalar|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GOMAPSurface@@UAAPAXI@Z| PROC	; OMAPSurface::`scalar deleting destructor'
  00000		 |$LN8@scalar|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37817|
  00004	e1a04000	 mov         r4, r0
  00008	e59f3014	 ldr         r3, [pc, #0x14]
  0000c	e3110001	 tst         r1, #1
  00010	e5843000	 str         r3, [r4]
  00014	1b000000	 blne        |??3@YAXPAX@Z|
  00018	e1a00004	 mov         r0, r4
  0001c	e8bd4010	 ldmia       sp!, {r4, lr}
  00020	e12fff1e	 bx          lr
  00024		 |$LN9@scalar|
  00024		 |$LN10@scalar|
  00024	00000000	 DCD         |??_7OMAPSurface@@6B@|
  00028		 |$M37818|

			 ENDP  ; |??_GOMAPSurface@@UAAPAXI@Z|, OMAPSurface::`scalar deleting destructor'

	EXPORT	|??0OMAPSurfaceManager@@QAA@XZ|		; OMAPSurfaceManager::OMAPSurfaceManager
	EXPORT	|??_7OMAPSurfaceManager@@6B@| [ DATA ]	; OMAPSurfaceManager::`vftable'
	IMPORT	|??_EOMAPSurfaceManager@@UAAPAXI@Z|, WEAK |??_GOMAPSurfaceManager@@UAAPAXI@Z| ; OMAPSurfaceManager::`vector deleting destructor', OMAPSurfaceManager::`scalar deleting destructor'

  00000			 AREA	 |.pdata|, PDATA
|$T37832| DCD	|$LN5@OMAPSurfac@3|
	DCD	0x40000500

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7OMAPSurfaceManager@@6B@| DCD |??_EOMAPSurfaceManager@@UAAPAXI@Z| ; OMAPSurfaceManager::`vftable'
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0OMAPSurfaceManager@@QAA@XZ| PROC	; OMAPSurfaceManager::OMAPSurfaceManager

; 956  :     OMAPSurfaceManager() {};

  00000		 |$LN5@OMAPSurfac@3|
  00000		 |$M37829|
  00000	e1a02000	 mov         r2, r0
  00004	e59f3004	 ldr         r3, [pc, #4]
  00008	e5823000	 str         r3, [r2]
  0000c	e12fff1e	 bx          lr
  00010		 |$LN6@OMAPSurfac@3|
  00010		 |$LN7@OMAPSurfac@3|
  00010	00000000	 DCD         |??_7OMAPSurfaceManager@@6B@|
  00014		 |$M37830|

			 ENDP  ; |??0OMAPSurfaceManager@@QAA@XZ|, OMAPSurfaceManager::OMAPSurfaceManager

	EXPORT	|??1OMAPSurfaceManager@@UAA@XZ|		; OMAPSurfaceManager::~OMAPSurfaceManager

  00000			 AREA	 |.pdata|, PDATA
|$T37842| DCD	|$LN5@OMAPSurfac@4|
	DCD	0x40000400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1OMAPSurfaceManager@@UAA@XZ| PROC	; OMAPSurfaceManager::~OMAPSurfaceManager

; 963  :     ~OMAPSurfaceManager() {};

  00000		 |$LN5@OMAPSurfac@4|
  00000		 |$M37839|
  00000	e59f3004	 ldr         r3, [pc, #4]
  00004	e5803000	 str         r3, [r0]
  00008	e12fff1e	 bx          lr
  0000c		 |$LN6@OMAPSurfac@4|
  0000c		 |$LN7@OMAPSurfac@4|
  0000c	00000000	 DCD         |??_7OMAPSurfaceManager@@6B@|
  00010		 |$M37840|

			 ENDP  ; |??1OMAPSurfaceManager@@UAA@XZ|, OMAPSurfaceManager::~OMAPSurfaceManager


  00000			 AREA	 |.pdata|, PDATA
|$T37858| DCD	|$LN8@scalar@2|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GOMAPSurfaceManager@@UAAPAXI@Z| PROC ; OMAPSurfaceManager::`scalar deleting destructor'
  00000		 |$LN8@scalar@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37855|
  00004	e1a04000	 mov         r4, r0
  00008	e59f3014	 ldr         r3, [pc, #0x14]
  0000c	e3110001	 tst         r1, #1
  00010	e5843000	 str         r3, [r4]
  00014	1b000000	 blne        |??3@YAXPAX@Z|
  00018	e1a00004	 mov         r0, r4
  0001c	e8bd4010	 ldmia       sp!, {r4, lr}
  00020	e12fff1e	 bx          lr
  00024		 |$LN9@scalar@2|
  00024		 |$LN10@scalar@2|
  00024	00000000	 DCD         |??_7OMAPSurfaceManager@@6B@|
  00028		 |$M37856|

			 ENDP  ; |??_GOMAPSurfaceManager@@UAAPAXI@Z|, OMAPSurfaceManager::`scalar deleting destructor'

	EXPORT	|?Address@Heap@@QAAKXZ|			; Heap::Address
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\heap.h

  00000			 AREA	 |.pdata|, PDATA
|$T37870| DCD	|$LN5@Address|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Address@Heap@@QAAKXZ| PROC		; Heap::Address

; 76   :     DWORD       Address() { return m_pStart; }

  00000		 |$LN5@Address|
  00000		 |$M37867|
  00000	e5900008	 ldr         r0, [r0, #8]
  00004	e12fff1e	 bx          lr
  00008		 |$M37868|

			 ENDP  ; |?Address@Heap@@QAAKXZ|, Heap::Address

	EXPORT	|VRFBOpen|
	EXPORT	|??_C@_1M@FFMPJHKO@?$AAV?$AAR?$AAF?$AA1?$AA?3?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|DeviceIoControl|
	IMPORT	|CloseHandle|
	IMPORT	|LocalAlloc|
	IMPORT	|CreateFileW|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\inc\vrfb.h

  00000			 AREA	 |.pdata|, PDATA
|$T37881| DCD	|$LN10@VRFBOpen|
	DCD	0x40002a02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1M@FFMPJHKO@?$AAV?$AAR?$AAF?$AA1?$AA?3?$AA?$AA@| DCB "V", 0x0, "R", 0x0
	DCB	"F", 0x0, "1", 0x0, ":", 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |VRFBOpen| PROC

; 146  : {

  00000		 |$LN10@VRFBOpen|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M37878|

; 147  :     HANDLE hDevice;
; 148  :     DEVICE_CONTEXT_VRFB *pContext = NULL;
; 149  : 
; 150  :     hDevice = CreateFile(VRFB_DEVICE_NAME, 0, 0, NULL, 0, 0, NULL);

  00008	e59f0094	 ldr         r0, [pc, #0x94]
  0000c	e3a06000	 mov         r6, #0
  00010	e3a03000	 mov         r3, #0
  00014	e3a02000	 mov         r2, #0
  00018	e3a01000	 mov         r1, #0
  0001c	e3a04000	 mov         r4, #0
  00020	e58d6008	 str         r6, [sp, #8]
  00024	e58d6004	 str         r6, [sp, #4]
  00028	e58d6000	 str         r6, [sp]
  0002c	eb000000	 bl          CreateFileW
  00030	e1a05000	 mov         r5, r0

; 151  :     if (hDevice == INVALID_HANDLE_VALUE) goto clean;

  00034	e3750001	 cmn         r5, #1
  00038	0a000014	 beq         |$clean$37105|

; 152  : 
; 153  :     // Allocate memory for our handler...
; 154  :     if ((pContext = (DEVICE_CONTEXT_VRFB *)LocalAlloc(
; 155  :         LPTR, sizeof(DEVICE_CONTEXT_VRFB)
; 156  :     )) == NULL) {

  0003c	e3a01028	 mov         r1, #0x28
  00040	e3a00040	 mov         r0, #0x40
  00044	eb000000	 bl          LocalAlloc
  00048	e1b04000	 movs        r4, r0

; 157  :         CloseHandle(hDevice);

  0004c	e1a00005	 mov         r0, r5
  00050	1a000001	 bne         |$LN3@VRFBOpen|
  00054	eb000000	 bl          CloseHandle

; 173  : 
; 174  : clean:

  00058	ea00000c	 b           |$clean$37105|
  0005c		 |$LN3@VRFBOpen|

; 158  :         goto clean;
; 159  :     }
; 160  : 
; 161  :     // Get function pointers.  If not possible (b/c of cross process calls), use IOCTLs instead
; 162  :     if (!DeviceIoControl(
; 163  :         hDevice, IOCTL_DDK_GET_DRIVER_IFC, (VOID*)&DEVICE_IFC_VRFB_GUID,
; 164  :         sizeof(DEVICE_IFC_VRFB_GUID), &pContext->ifc, sizeof(DEVICE_IFC_VRFB),
; 165  :         NULL, NULL
; 166  :     )) {

  0005c	e59f203c	 ldr         r2, [pc, #0x3C]
  00060	e3a03822	 mov         r3, #0x22, 16
  00064	e3831b01	 orr         r1, r3, #1, 22
  00068	e3a0e024	 mov         lr, #0x24
  0006c	e3a03010	 mov         r3, #0x10
  00070	e58d600c	 str         r6, [sp, #0xC]
  00074	e58d6008	 str         r6, [sp, #8]
  00078	e58de004	 str         lr, [sp, #4]
  0007c	e58d4000	 str         r4, [sp]
  00080	eb000000	 bl          DeviceIoControl
  00084	e3500000	 cmp         r0, #0

; 167  :         //  Need to use IOCTLs instead of direct function ptrs
; 168  :         pContext->ifc.context = 0;

  00088	05846000	 streq       r6, [r4]

; 169  :     }
; 170  : 
; 171  :     // Save device handle
; 172  :     pContext->hDevice = hDevice;

  0008c	e5845024	 str         r5, [r4, #0x24]
  00090		 |$clean$37105|

; 175  :     return pContext;
; 176  : }

  00090	e1a00004	 mov         r0, r4
  00094	e28dd010	 add         sp, sp, #0x10
  00098	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$LN11@VRFBOpen|
  000a0		 |$LN12@VRFBOpen|
  000a0	00000000	 DCD         |DEVICE_IFC_VRFB_GUID|
  000a4		 |$LN13@VRFBOpen|
  000a4	00000000	 DCD         |??_C@_1M@FFMPJHKO@?$AAV?$AAR?$AAF?$AA1?$AA?3?$AA?$AA@|
  000a8		 |$M37879|

			 ENDP  ; |VRFBOpen|

	EXPORT	|VRFBClose|
	IMPORT	|LocalFree|

  00000			 AREA	 |.pdata|, PDATA
|$T37892| DCD	|$LN5@VRFBClose|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |VRFBClose| PROC

; 179  : {

  00000		 |$LN5@VRFBClose|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37889|
  00004	e1a04000	 mov         r4, r0

; 180  :     DEVICE_CONTEXT_VRFB *pContext = (DEVICE_CONTEXT_VRFB *)hContext;
; 181  :     CloseHandle(pContext->hDevice);

  00008	e5940024	 ldr         r0, [r4, #0x24]
  0000c	eb000000	 bl          CloseHandle

; 182  :     LocalFree(pContext);

  00010	e1a00004	 mov         r0, r4
  00014	eb000000	 bl          LocalFree

; 183  : }

  00018	e8bd4010	 ldmia       sp!, {r4, lr}
  0001c	e12fff1e	 bx          lr
  00020		 |$M37890|

			 ENDP  ; |VRFBClose|

	EXPORT	|VRFBGetViewInfo|

  00000			 AREA	 |.pdata|, PDATA
|$T37905| DCD	|$LN7@VRFBGetVie|
	DCD	0x40001d04
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |VRFBGetViewInfo| PROC

; 241  : {

  00000		 |$LN7@VRFBGetVie|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5030	 stmdb       sp!, {r4, r5, r12, lr}
  0000c	e24dd010	 sub         sp, sp, #0x10
  00010		 |$M37902|
  00010	e1a0e002	 mov         lr, r2
  00014	e58d1024	 str         r1, [sp, #0x24]

; 242  :     DEVICE_CONTEXT_VRFB *pContext = (DEVICE_CONTEXT_VRFB *)hContext;
; 243  :     BOOL                bResult = FALSE;
; 244  : 
; 245  :     if( pContext->ifc.context )

  00018	e5903000	 ldr         r3, [r0]
  0001c	e1b04003	 movs        r4, r3
  00020	0a000004	 beq         |$LN2@VRFBGetVie|

; 246  :     {
; 247  :         bResult = pContext->ifc.pfnGetViewInfo(pContext->ifc.context, hView, pInfo);

  00024	e590300c	 ldr         r3, [r0, #0xC]
  00028	e1a00004	 mov         r0, r4
  0002c	e1a0e00f	 mov         lr, pc
  00030	e12fff13	 bx          r3

; 248  :     }
; 249  :     else

  00034	ea00000a	 b           |$LN1@VRFBGetVie|
  00038		 |$LN2@VRFBGetVie|

; 250  :     {
; 251  :         bResult = DeviceIoControl(pContext->hDevice, 
; 252  :                         IOCTL_VRFB_GETVIEWINFO, 
; 253  :                         &hView,
; 254  :                         sizeof(HANDLE*),
; 255  :                         pInfo,
; 256  :                         sizeof(VRFB_VIEW_INFO),
; 257  :                         NULL,
; 258  :                         NULL );

  00038	e59f1030	 ldr         r1, [pc, #0x30]
  0003c	e5900024	 ldr         r0, [r0, #0x24]
  00040	e3a05040	 mov         r5, #0x40
  00044	e3a04000	 mov         r4, #0
  00048	e3a03004	 mov         r3, #4
  0004c	e28d2024	 add         r2, sp, #0x24
  00050	e58d400c	 str         r4, [sp, #0xC]
  00054	e58d4008	 str         r4, [sp, #8]
  00058	e58d5004	 str         r5, [sp, #4]
  0005c	e58de000	 str         lr, [sp]
  00060	eb000000	 bl          DeviceIoControl
  00064		 |$LN1@VRFBGetVie|

; 259  :     }
; 260  :     
; 261  :     return bResult; 
; 262  : }

  00064	e28dd010	 add         sp, sp, #0x10
  00068	e89d6030	 ldmia       sp, {r4, r5, sp, lr}
  0006c	e12fff1e	 bx          lr
  00070		 |$LN8@VRFBGetVie|
  00070		 |$LN9@VRFBGetVie|
  00070	00221c08	 DCD         0x221c08
  00074		 |$M37903|

			 ENDP  ; |VRFBGetViewInfo|

	EXPORT	|VRFBUpdateView|

  00000			 AREA	 |.pdata|, PDATA
|$T37921| DCD	|$LN7@VRFBUpdate|
	DCD	0x40002602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |VRFBUpdateView| PROC

; 294  : {

  00000		 |$LN7@VRFBUpdate|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd050	 sub         sp, sp, #0x50
  00008		 |$M37918|
  00008	e1a06003	 mov         r6, r3
  0000c	e1a07002	 mov         r7, r2
  00010	e1a08001	 mov         r8, r1

; 295  :     DEVICE_CONTEXT_VRFB *pContext = (DEVICE_CONTEXT_VRFB *)hContext;
; 296  :     BOOL                bResult = FALSE;
; 297  : 
; 298  :     if( pContext->ifc.context )

  00014	e590e000	 ldr         lr, [r0]
  00018	e1b0900e	 movs        r9, lr
  0001c	0a000008	 beq         |$LN2@VRFBUpdate|

; 299  :     {
; 300  :         bResult = pContext->ifc.pfnUpdateView(pContext->ifc.context, hView, dwPixelSize, dwWidth, dwHeight, dwBufferPhysAddr);

  00020	e59de070	 ldr         lr, [sp, #0x70]
  00024	e59d406c	 ldr         r4, [sp, #0x6C]
  00028	e5905014	 ldr         r5, [r0, #0x14]
  0002c	e58de004	 str         lr, [sp, #4]
  00030	e58d4000	 str         r4, [sp]
  00034	e1a00009	 mov         r0, r9
  00038	e1a0e00f	 mov         lr, pc
  0003c	e12fff15	 bx          r5

; 301  :     }
; 302  :     else

  00040	ea000010	 b           |$LN1@VRFBUpdate|
  00044		 |$LN2@VRFBUpdate|

; 303  :     {
; 304  :         VRFB_VIEW_INFO  viewInfo;
; 305  :         
; 306  :         viewInfo.hView                = hView;
; 307  :         viewInfo.dwPixelSize          = dwPixelSize;
; 308  :         viewInfo.dwWidth              = dwWidth;
; 309  :         viewInfo.dwHeight             = dwHeight;

  00044	e59d306c	 ldr         r3, [sp, #0x6C]

; 310  :         viewInfo.dwPhysicalBufferAddr = dwBufferPhysAddr;

  00048	e59d2070	 ldr         r2, [sp, #0x70]

; 311  : 
; 312  :         bResult = DeviceIoControl(pContext->hDevice, 
; 313  :                         IOCTL_VRFB_UPDATEVIEW, 
; 314  :                         &viewInfo,
; 315  :                         sizeof(VRFB_VIEW_INFO),
; 316  :                         NULL,
; 317  :                         0,
; 318  :                         NULL,
; 319  :                         NULL );

  0004c	e59f1040	 ldr         r1, [pc, #0x40]
  00050	e5900024	 ldr         r0, [r0, #0x24]
  00054	e58d3020	 str         r3, [sp, #0x20]
  00058	e58d204c	 str         r2, [sp, #0x4C]
  0005c	e3a0e000	 mov         lr, #0
  00060	e3a03040	 mov         r3, #0x40
  00064	e28d2010	 add         r2, sp, #0x10
  00068	e58d8010	 str         r8, [sp, #0x10]
  0006c	e58d7014	 str         r7, [sp, #0x14]
  00070	e58d601c	 str         r6, [sp, #0x1C]
  00074	e58de00c	 str         lr, [sp, #0xC]
  00078	e58de008	 str         lr, [sp, #8]
  0007c	e58de004	 str         lr, [sp, #4]
  00080	e58de000	 str         lr, [sp]
  00084	eb000000	 bl          DeviceIoControl
  00088		 |$LN1@VRFBUpdate|

; 320  :     }
; 321  :     
; 322  :     return bResult; 
; 323  : }

  00088	e28dd050	 add         sp, sp, #0x50
  0008c	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$LN8@VRFBUpdate|
  00094		 |$LN9@VRFBUpdate|
  00094	00221c10	 DCD         0x221c10
  00098		 |$M37919|

			 ENDP  ; |VRFBUpdateView|

	EXPORT	|VRFBNumDisplayViews|

  00000			 AREA	 |.pdata|, PDATA
|$T37934| DCD	|$LN7@VRFBNumDis|
	DCD	0x40001d02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |VRFBNumDisplayViews| PROC

; 326  : {

  00000		 |$LN7@VRFBNumDis|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M37931|

; 327  :     DEVICE_CONTEXT_VRFB *pContext = (DEVICE_CONTEXT_VRFB *)hContext;
; 328  :     DWORD                dwResult = 0;
; 329  : 
; 330  :     if( pContext->ifc.context )

  00008	e5903000	 ldr         r3, [r0]
  0000c	e3a02000	 mov         r2, #0
  00010	e58d2010	 str         r2, [sp, #0x10]
  00014	e1b02003	 movs        r2, r3
  00018	0a000004	 beq         |$LN2@VRFBNumDis|

; 331  :     {
; 332  :         dwResult = pContext->ifc.pfnNumDisplayViews(pContext->ifc.context);

  0001c	e5903018	 ldr         r3, [r0, #0x18]
  00020	e1a00002	 mov         r0, r2
  00024	e1a0e00f	 mov         lr, pc
  00028	e12fff13	 bx          r3

; 333  :     }
; 334  :     else

  0002c	ea00000c	 b           |$LN1@VRFBNumDis|
  00030		 |$LN2@VRFBNumDis|

; 335  :     {
; 336  :         DeviceIoControl(pContext->hDevice, 
; 337  :                         IOCTL_VRFB_NUMDISPLAYVIEWS, 
; 338  :                         NULL,
; 339  :                         0,
; 340  :                         &dwResult,
; 341  :                         sizeof(dwResult),
; 342  :                         NULL,
; 343  :                         NULL );

  00030	e59f1038	 ldr         r1, [pc, #0x38]
  00034	e5900024	 ldr         r0, [r0, #0x24]
  00038	e3a05004	 mov         r5, #4
  0003c	e28de010	 add         lr, sp, #0x10
  00040	e3a04000	 mov         r4, #0
  00044	e3a03000	 mov         r3, #0
  00048	e3a02000	 mov         r2, #0
  0004c	e58d400c	 str         r4, [sp, #0xC]
  00050	e58d4008	 str         r4, [sp, #8]
  00054	e58d5004	 str         r5, [sp, #4]
  00058	e58de000	 str         lr, [sp]
  0005c	eb000000	 bl          DeviceIoControl
  00060	e59d0010	 ldr         r0, [sp, #0x10]
  00064		 |$LN1@VRFBNumDis|

; 344  :     }
; 345  :     
; 346  :     return dwResult; 
; 347  : }

  00064	e28dd014	 add         sp, sp, #0x14
  00068	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0006c	e12fff1e	 bx          lr
  00070		 |$LN8@VRFBNumDis|
  00070		 |$LN9@VRFBNumDis|
  00070	00221c14	 DCD         0x221c14
  00074		 |$M37932|

			 ENDP  ; |VRFBNumDisplayViews|

	EXPORT	|VRFBGetDisplayView|

  00000			 AREA	 |.pdata|, PDATA
|$T37948| DCD	|$LN7@VRFBGetDis|
	DCD	0x40002004
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |VRFBGetDisplayView| PROC

; 350  : {

  00000		 |$LN7@VRFBGetDis|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5030	 stmdb       sp!, {r4, r5, r12, lr}
  0000c	e24dd014	 sub         sp, sp, #0x14
  00010		 |$M37945|
  00010	e58d1028	 str         r1, [sp, #0x28]

; 351  :     DEVICE_CONTEXT_VRFB *pContext = (DEVICE_CONTEXT_VRFB *)hContext;
; 352  :     HANDLE              hHandle = NULL;
; 353  : 
; 354  :     if( pContext->ifc.context )

  00014	e5903000	 ldr         r3, [r0]
  00018	e3a02000	 mov         r2, #0
  0001c	e58d2010	 str         r2, [sp, #0x10]
  00020	e1b02003	 movs        r2, r3
  00024	0a000004	 beq         |$LN2@VRFBGetDis|

; 355  :     {
; 356  :         hHandle = pContext->ifc.pfnGetDisplayView(pContext->ifc.context, dwIndex);

  00028	e590301c	 ldr         r3, [r0, #0x1C]
  0002c	e1a00002	 mov         r0, r2
  00030	e1a0e00f	 mov         lr, pc
  00034	e12fff13	 bx          r3

; 357  :     }
; 358  :     else

  00038	ea00000c	 b           |$LN1@VRFBGetDis|
  0003c		 |$LN2@VRFBGetDis|

; 359  :     {
; 360  :         DeviceIoControl(pContext->hDevice, 
; 361  :                         IOCTL_VRFB_GETDISPLAYVIEW, 
; 362  :                         &dwIndex,
; 363  :                         sizeof(DWORD*),
; 364  :                         &hHandle,
; 365  :                         sizeof(hHandle),
; 366  :                         NULL,
; 367  :                         NULL );

  0003c	e59f1038	 ldr         r1, [pc, #0x38]
  00040	e5900024	 ldr         r0, [r0, #0x24]
  00044	e3a05004	 mov         r5, #4
  00048	e28de010	 add         lr, sp, #0x10
  0004c	e3a04000	 mov         r4, #0
  00050	e3a03004	 mov         r3, #4
  00054	e28d2028	 add         r2, sp, #0x28
  00058	e58d400c	 str         r4, [sp, #0xC]
  0005c	e58d4008	 str         r4, [sp, #8]
  00060	e58d5004	 str         r5, [sp, #4]
  00064	e58de000	 str         lr, [sp]
  00068	eb000000	 bl          DeviceIoControl
  0006c	e59d0010	 ldr         r0, [sp, #0x10]
  00070		 |$LN1@VRFBGetDis|

; 368  :     }
; 369  :     
; 370  :     return hHandle; 
; 371  : }

  00070	e28dd014	 add         sp, sp, #0x14
  00074	e89d6030	 ldmia       sp, {r4, r5, sp, lr}
  00078	e12fff1e	 bx          lr
  0007c		 |$LN8@VRFBGetDis|
  0007c		 |$LN9@VRFBGetDis|
  0007c	00221c18	 DCD         0x221c18
  00080		 |$M37946|

			 ENDP  ; |VRFBGetDisplayView|

	EXPORT	|VRFBGetDisplayViewInfo|

  00000			 AREA	 |.pdata|, PDATA
|$T37964| DCD	|$LN7@VRFBGetDis@2|
	DCD	0x40002202
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |VRFBGetDisplayViewInfo| PROC

; 374  : {

  00000		 |$LN7@VRFBGetDis@2|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd01c	 sub         sp, sp, #0x1C
  00008		 |$M37961|
  00008	e1a05003	 mov         r5, r3
  0000c	e1a06002	 mov         r6, r2
  00010	e1a07001	 mov         r7, r1

; 375  :     DEVICE_CONTEXT_VRFB *pContext = (DEVICE_CONTEXT_VRFB *)hContext;
; 376  :     BOOL                bResult = FALSE;
; 377  : 
; 378  :     if( pContext->ifc.context )

  00014	e590e000	 ldr         lr, [r0]
  00018	e1b0800e	 movs        r8, lr
  0001c	0a000006	 beq         |$LN2@VRFBGetDis@2|

; 379  :     {
; 380  :         bResult = pContext->ifc.pfnGetDisplayViewInfo(pContext->ifc.context, dwIndex, dwRotateAngle, bMirror, pInfo);

  00020	e59de034	 ldr         lr, [sp, #0x34]
  00024	e5904020	 ldr         r4, [r0, #0x20]
  00028	e1a00008	 mov         r0, r8
  0002c	e58de000	 str         lr, [sp]
  00030	e1a0e00f	 mov         lr, pc
  00034	e12fff14	 bx          r4

; 381  :     }
; 382  :     else

  00038	ea00000e	 b           |$LN1@VRFBGetDis@2|
  0003c		 |$LN2@VRFBGetDis@2|

; 383  :     {
; 384  :         IOCTL_VRFB_GETDISPLAYVIEWINFO_IN    infoIn;
; 385  :         
; 386  :         infoIn.dwIndex          = dwIndex;
; 387  :         infoIn.dwRotateAngle    = dwRotateAngle;
; 388  :         infoIn.bMirror          = bMirror;
; 389  :             
; 390  :         bResult = DeviceIoControl(pContext->hDevice, 
; 391  :                         IOCTL_VRFB_GETDISPLAYVIEWINFO, 
; 392  :                         &infoIn,
; 393  :                         sizeof(infoIn),
; 394  :                         pInfo,
; 395  :                         sizeof(VRFB_VIEW_INFO),
; 396  :                         NULL,
; 397  :                         NULL );

  0003c	e59d3034	 ldr         r3, [sp, #0x34]
  00040	e59f103c	 ldr         r1, [pc, #0x3C]
  00044	e5900024	 ldr         r0, [r0, #0x24]
  00048	e58d3000	 str         r3, [sp]
  0004c	e3a04040	 mov         r4, #0x40
  00050	e3a0e000	 mov         lr, #0
  00054	e3a0300c	 mov         r3, #0xC
  00058	e28d2010	 add         r2, sp, #0x10
  0005c	e58d7010	 str         r7, [sp, #0x10]
  00060	e58d6014	 str         r6, [sp, #0x14]
  00064	e58d5018	 str         r5, [sp, #0x18]
  00068	e58de00c	 str         lr, [sp, #0xC]
  0006c	e58de008	 str         lr, [sp, #8]
  00070	e58d4004	 str         r4, [sp, #4]
  00074	eb000000	 bl          DeviceIoControl
  00078		 |$LN1@VRFBGetDis@2|

; 398  :     }
; 399  :     
; 400  :     return bResult; 
; 401  : }

  00078	e28dd01c	 add         sp, sp, #0x1C
  0007c	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00080	e12fff1e	 bx          lr
  00084		 |$LN8@VRFBGetDis@2|
  00084		 |$LN9@VRFBGetDis@2|
  00084	00221c1c	 DCD         0x221c1c
  00088		 |$M37962|

			 ENDP  ; |VRFBGetDisplayViewInfo|

	EXPORT	|??0OMAPVrfbSurface@@QAA@XZ|		; OMAPVrfbSurface::OMAPVrfbSurface
	EXPORT	|??_7OMAPVrfbSurface@@6B@| [ DATA ]	; OMAPVrfbSurface::`vftable'
	EXPORT	|?VirtualAddr@OMAPVrfbSurface@@UAAPAXXZ| ; OMAPVrfbSurface::VirtualAddr
	EXPORT	|?Width@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z| ; OMAPVrfbSurface::Width
	EXPORT	|?Height@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z| ; OMAPVrfbSurface::Height
	EXPORT	|?Stride@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z| ; OMAPVrfbSurface::Stride
	EXPORT	|?PhysicalAddr@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@HW4OMAP_ASSOC_SURF_USAGE@@@Z| ; OMAPVrfbSurface::PhysicalAddr
	EXPORT	|?PixelIncr@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@H@Z| ; OMAPVrfbSurface::PixelIncr
	EXPORT	|?RowIncr@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@H@Z| ; OMAPVrfbSurface::RowIncr
	EXPORT	|?SetOrientation@OMAPVrfbSurface@@UAAHW4OMAP_SURF_ORIENTATION@@@Z| ; OMAPVrfbSurface::SetOrientation
	IMPORT	|??_EOMAPVrfbSurface@@UAAPAXI@Z|, WEAK |??_GOMAPVrfbSurface@@UAAPAXI@Z| ; OMAPVrfbSurface::`vector deleting destructor', OMAPVrfbSurface::`scalar deleting destructor'
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\inc\dssai.h

  00000			 AREA	 |.pdata|, PDATA
|$T37979| DCD	|$LN7@OMAPVrfbSu|
	DCD	0x40001000

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7OMAPVrfbSurface@@6B@| DCD |??_EOMAPVrfbSurface@@UAAPAXI@Z| ; OMAPVrfbSurface::`vftable'
	DCD	|?VirtualAddr@OMAPVrfbSurface@@UAAPAXXZ|
	DCD	|?Width@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z|
	DCD	|?Height@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z|
	DCD	|?Stride@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z|
	DCD	|?PhysicalAddr@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@HW4OMAP_ASSOC_SURF_USAGE@@@Z|
	DCD	|?PixelIncr@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@H@Z|
	DCD	|?RowIncr@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@H@Z|
	DCD	|?SetClipping@OMAPSurface@@UAAHPAUtagRECT@@@Z|
	DCD	|?UpdateClipping@OMAPSurface@@UAAHPAUtagRECT@@@Z|
	DCD	|?GetClipping@OMAPSurface@@UAA?AUtagRECT@@XZ|
	DCD	|?AdjustClippingRect@OMAPSurface@@UAAHPAUtagRECT@@EE@Z|
	DCD	|?SetHorizontalScaling@OMAPSurface@@UAAHK@Z|
	DCD	|?SetVerticalScaling@OMAPSurface@@UAAHK@Z|
	DCD	|?SetOrientation@OMAPVrfbSurface@@UAAHW4OMAP_SURF_ORIENTATION@@@Z|
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\surfmgr_vrfb.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0OMAPVrfbSurface@@QAA@XZ| PROC	; OMAPVrfbSurface::OMAPVrfbSurface

; 51   : {

  00000		 |$LN7@OMAPVrfbSu|
  00000		 |$M37976|
  00000	e59f3034	 ldr         r3, [pc, #0x34]

; 52   :     m_hHeap = NULL;
; 53   :     m_hVRFB = NULL;
; 54   :     m_hVRFBView = NULL;
; 55   :     m_dwViewIndex = (DWORD) -1;

  00004	e3e02000	 mvn         r2, #0
  00008	e3a01000	 mov         r1, #0
  0000c	e5803000	 str         r3, [r0]

; 56   :     m_dwWidthFactor = 1;

  00010	e3a03001	 mov         r3, #1
  00014	e280c0ac	 add         r12, r0, #0xAC
  00018	e88c000e	 stmia       r12, {r1 - r3}

; 57   :     m_dwHorizScale = 1;

  0001c	e5803028	 str         r3, [r0, #0x28]

; 58   :     m_dwVertScale = 1;

  00020	e580302c	 str         r3, [r0, #0x2C]
  00024	e58010a4	 str         r1, [r0, #0xA4]
  00028	e58010a8	 str         r1, [r0, #0xA8]

; 59   :     m_bUseResizer = FALSE;

  0002c	e5801030	 str         r1, [r0, #0x30]

; 60   :     m_pAssocSurface = NULL;

  00030	e58010a0	 str         r1, [r0, #0xA0]

; 61   :     m_eSurfaceType = OMAP_SURFACE_NORMAL;

  00034	e580109c	 str         r1, [r0, #0x9C]

; 62   : }

  00038	e12fff1e	 bx          lr
  0003c		 |$LN8@OMAPVrfbSu|
  0003c		 |$LN9@OMAPVrfbSu|
  0003c	00000000	 DCD         |??_7OMAPVrfbSurface@@6B@|
  00040		 |$M37977|

			 ENDP  ; |??0OMAPVrfbSurface@@QAA@XZ|, OMAPVrfbSurface::OMAPVrfbSurface

	EXPORT	|??1OMAPVrfbSurface@@UAA@XZ|		; OMAPVrfbSurface::~OMAPVrfbSurface
	IMPORT	|?Free@Heap@@QAAXXZ|			; Heap::Free
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\inc\dssai.h

  00000			 AREA	 |.pdata|, PDATA
|$T37993| DCD	|$LN9@OMAPVrfbSu@2|
	DCD	0x40001601
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\surfmgr_vrfb.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1OMAPVrfbSurface@@UAA@XZ| PROC	; OMAPVrfbSurface::~OMAPVrfbSurface

; 66   : {

  00000		 |$LN9@OMAPVrfbSu@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37990|
  00004	e1a04000	 mov         r4, r0

; 67   :     Heap    *pHeap = (Heap*) m_hHeap;

  00008	e59420a4	 ldr         r2, [r4, #0xA4]
  0000c	e59f3040	 ldr         r3, [pc, #0x40]
  00010	e3520000	 cmp         r2, #0

; 68   :     
; 69   :     //  Free the underlying surface memory
; 70   :     if( pHeap )
; 71   :         pHeap->Free();

  00014	11a00002	 movne       r0, r2
  00018	e5843000	 str         r3, [r4]
  0001c	1b000000	 blne        |?Free@Heap@@QAAXXZ|

; 72   :         
; 73   :     //  Free the VRFB view
; 74   :     if( m_dwViewIndex != -1 && m_dwViewIndex < VRFB_ROTATION_CONTEXTS)

  00020	e59420b0	 ldr         r2, [r4, #0xB0]
  00024	e3720001	 cmn         r2, #1
  00028	0a000003	 beq         |$LN1@OMAPVrfbSu@2|
  0002c	e352000c	 cmp         r2, #0xC

; 75   :     {
; 76   :         g_bVRFBViewReserved[m_dwViewIndex] = FALSE;        

  00030	359f3018	 ldrcc       r3, [pc, #0x18]
  00034	33a01000	 movcc       r1, #0
  00038	37831102	 strcc       r1, [r3, +r2, lsl #2]
  0003c		 |$LN1@OMAPVrfbSu@2|

; 77   : 
; 78   :         DEBUGMSG(ZONE_WARNING, (L"INFO: OMAPVrfbSurface::~OMAPVrfbSurface() - Freeing VRFB View # %d\r\n", m_dwViewIndex));
; 79   :     }
; 80   : }

  0003c	e59f3008	 ldr         r3, [pc, #8]
  00040	e5843000	 str         r3, [r4]
  00044	e8bd4010	 ldmia       sp!, {r4, lr}
  00048	e12fff1e	 bx          lr
  0004c		 |$LN10@OMAPVrfbSu@2|
  0004c		 |$LN11@OMAPVrfbSu@2|
  0004c	00000000	 DCD         |??_7OMAPSurface@@6B@|
  00050		 |$LN12@OMAPVrfbSu@2|
  00050	00000000	 DCD         |?g_bVRFBViewReserved@@3PAHA|
  00054		 |$LN13@OMAPVrfbSu@2|
  00054	00000000	 DCD         |??_7OMAPVrfbSurface@@6B@|
  00058		 |$M37991|

			 ENDP  ; |??1OMAPVrfbSurface@@UAA@XZ|, OMAPVrfbSurface::~OMAPVrfbSurface

	EXPORT	|?Allocate@OMAPVrfbSurface@@QAAHW4OMAP_DSS_PIXELFORMAT@@KKPAX1@Z| ; OMAPVrfbSurface::Allocate
	IMPORT	|?Allocate@Heap@@QAAPAV1@K@Z|		; Heap::Allocate
	IMPORT	|memset|
	IMPORT	|__rt_udiv|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\heap.h

  00000			 AREA	 |.pdata|, PDATA
|$T38033| DCD	|$LN36@Allocate|
	DCD	0x40009a02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\surfmgr_vrfb.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Allocate@OMAPVrfbSurface@@QAAHW4OMAP_DSS_PIXELFORMAT@@KKPAX1@Z| PROC ; OMAPVrfbSurface::Allocate

; 91   : {

  00000		 |$LN36@Allocate|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd058	 sub         sp, sp, #0x58
  00008		 |$M38030|
  00008	e58d3008	 str         r3, [sp, #8]
  0000c	e1a03002	 mov         r3, r2
  00010	e58d300c	 str         r3, [sp, #0xC]
  00014	e1a04001	 mov         r4, r1
  00018	e1a05000	 mov         r5, r0

; 92   :     BOOL            bResult;
; 93   :     Heap            *pMainHeap = (Heap*) hHeap,
; 94   :                     *pSurfHeap = NULL;
; 95   :     DWORD           dwVrfbPixelSize;
; 96   :     DWORD           dwWidthFactor = 1;

  0001c	e3a0a001	 mov         r10, #1

; 97   :     DWORD           i;
; 98   :     HANDLE          hVRFBView;
; 99   :     VRFB_VIEW_INFO  info;
; 100  :     VOID            *ptr;       
; 101  :     DWORD           dwStride;         
; 102  :             
; 103  :             
; 104  :     //  Set surface properties based on pixel format
; 105  :     switch( ePixelFormat )

  00020	e3540005	 cmp         r4, #5
  00024	ba000009	 blt         |$LN16@Allocate|
  00028	e3540006	 cmp         r4, #6
  0002c	da000010	 ble         |$LN19@Allocate|
  00030	e3540008	 cmp         r4, #8
  00034	0a00000c	 beq         |$LN18@Allocate|
  00038	e3540009	 cmp         r4, #9
  0003c	da000003	 ble         |$LN16@Allocate|
  00040	e354000b	 cmp         r4, #0xB
  00044	da000005	 ble         |$LN17@Allocate|
  00048	e354000d	 cmp         r4, #0xD
  0004c	da000006	 ble         |$LN18@Allocate|
  00050		 |$LN16@Allocate|

; 127  : 
; 128  :         default:
; 129  :             ASSERT(0);
; 130  :             return FALSE;

  00050	e3a00000	 mov         r0, #0
  00054		 |$LN22@Allocate|

; 221  : }

  00054	e28dd058	 add         sp, sp, #0x58
  00058	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$LN17@Allocate|

; 119  : 
; 120  :         case OMAP_DSS_PIXELFORMAT_YUV2:
; 121  :         case OMAP_DSS_PIXELFORMAT_UYVY:
; 122  :             //  2 bytes per pixel, but treated as 4 bytes and half the width
; 123  :             //  to support VRFB rotation for YUV formats
; 124  :             dwVrfbPixelSize = VRFB_PIXELSIZE_4B;

  00060	e3a09002	 mov         r9, #2

; 125  :             dwWidthFactor = 2;

  00064	e3a0a002	 mov         r10, #2

; 126  :             break;

  00068	ea000002	 b           |$LN20@Allocate|
  0006c		 |$LN18@Allocate|

; 111  :             break;
; 112  : 
; 113  :         case OMAP_DSS_PIXELFORMAT_RGB32:
; 114  :         case OMAP_DSS_PIXELFORMAT_ARGB32:
; 115  :         case OMAP_DSS_PIXELFORMAT_RGBA32:
; 116  :             //  4 bytes per pixel
; 117  :             dwVrfbPixelSize = VRFB_PIXELSIZE_4B;

  0006c	e3a09002	 mov         r9, #2

; 118  :             break;

  00070	ea000000	 b           |$LN20@Allocate|
  00074		 |$LN19@Allocate|

; 106  :     {
; 107  :         case OMAP_DSS_PIXELFORMAT_RGB16:
; 108  :         case OMAP_DSS_PIXELFORMAT_ARGB16:
; 109  :             //  2 bytes per pixel
; 110  :             dwVrfbPixelSize = VRFB_PIXELSIZE_2B;

  00074	e3a09001	 mov         r9, #1
  00078		 |$LN20@Allocate|

; 131  :     }
; 132  : 
; 133  : 
; 134  :     //  Find a free VRFB view to use
; 135  :     for( i = 0; i < VRFBNumDisplayViews(hVRFB); i++ )

  00078	e59d6080	 ldr         r6, [sp, #0x80]
  0007c	e3a07000	 mov         r7, #0
  00080	e1a00006	 mov         r0, r6
  00084	eb000000	 bl          VRFBNumDisplayViews
  00088	e59fb1d4	 ldr         r11, [pc, #0x1D4]
  0008c	e3500000	 cmp         r0, #0
  00090	0a000009	 beq         |$LN33@Allocate|
  00094	e1a0800b	 mov         r8, r11
  00098		 |$LL15@Allocate|

; 136  :     {
; 137  :         if( g_bVRFBViewReserved[i] == FALSE )

  00098	e5983000	 ldr         r3, [r8]
  0009c	e3530000	 cmp         r3, #0
  000a0	0a000005	 beq         |$LN33@Allocate|
  000a4	e1a00006	 mov         r0, r6
  000a8	e2877001	 add         r7, r7, #1
  000ac	e2888004	 add         r8, r8, #4
  000b0	eb000000	 bl          VRFBNumDisplayViews
  000b4	e1570000	 cmp         r7, r0
  000b8	3afffff6	 bcc         |$LL15@Allocate|
  000bc		 |$LN33@Allocate|

; 138  :             break;
; 139  :     }
; 140  : 
; 141  :     //  Check result
; 142  :     if( i == VRFBNumDisplayViews(hVRFB) )

  000bc	e1a00006	 mov         r0, r6
  000c0	eb000000	 bl          VRFBNumDisplayViews
  000c4	e1570000	 cmp         r7, r0
  000c8	0affffe0	 beq         |$LN16@Allocate|

; 143  :     {
; 144  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: All VRFB views are allocated\n"));
; 145  :         goto cleanUp;
; 146  :     }
; 147  : 
; 148  : 
; 149  :     //  Get the free display view
; 150  :     hVRFBView = VRFBGetDisplayView( hVRFB, i );

  000cc	e1a01007	 mov         r1, r7
  000d0	e1a00006	 mov         r0, r6
  000d4	eb000000	 bl          VRFBGetDisplayView

; 151  :     
; 152  :     //  Update the view with the surface parameters         
; 153  :     bResult = VRFBUpdateView( hVRFB, hVRFBView, dwVrfbPixelSize, dwWidth/dwWidthFactor, dwHeight, 0 );

  000d8	e59d100c	 ldr         r1, [sp, #0xC]
  000dc	e1a08000	 mov         r8, r0
  000e0	e1a0000a	 mov         r0, r10
  000e4	eb000000	 bl          __rt_udiv
  000e8	e3a0e000	 mov         lr, #0
  000ec	e58de004	 str         lr, [sp, #4]
  000f0	e59de008	 ldr         lr, [sp, #8]
  000f4	e1a03000	 mov         r3, r0
  000f8	e1a02009	 mov         r2, r9
  000fc	e1a01008	 mov         r1, r8
  00100	e1a00006	 mov         r0, r6
  00104	e58de000	 str         lr, [sp]
  00108	e58d3010	 str         r3, [sp, #0x10]
  0010c	eb000000	 bl          VRFBUpdateView
  00110	e3500000	 cmp         r0, #0

; 154  :     if(  bResult == FALSE )

  00114	0affffcd	 beq         |$LN16@Allocate|

; 155  :     {
; 156  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to update VRFB view parameters\n"));
; 157  :         goto cleanUp;
; 158  :     }
; 159  : 
; 160  :     //  Get the view information to allocate the underlying memory
; 161  :     bResult = VRFBGetViewInfo( hVRFB, hVRFBView, &info );

  00118	e28d2018	 add         r2, sp, #0x18
  0011c	e1a01008	 mov         r1, r8
  00120	e1a00006	 mov         r0, r6
  00124	eb000000	 bl          VRFBGetViewInfo
  00128	e3500000	 cmp         r0, #0

; 162  :     if(  bResult == FALSE )

  0012c	0affffc7	 beq         |$LN16@Allocate|

; 163  :     {
; 164  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to get VRFB view info\n"));
; 165  :         goto cleanUp;
; 166  :     }
; 167  :         
; 168  : 
; 169  : 
; 170  :     //  Allocate the VRFB memory from the given video memory heap using the VRFB adjusted
; 171  :     //  image width and height which are a multiple of the VRFB page size
; 172  :     pSurfHeap = pMainHeap->Allocate( info.dwPixelSizeBytes * info.dwImageWidth * info.dwImageHeight );

  00130	e59d1038	 ldr         r1, [sp, #0x38]
  00134	e59d3034	 ldr         r3, [sp, #0x34]
  00138	e59de020	 ldr         lr, [sp, #0x20]
  0013c	e59d007c	 ldr         r0, [sp, #0x7C]
  00140	e0030391	 mul         r3, r1, r3
  00144	e0010e93	 mul         r1, r3, lr
  00148	eb000000	 bl          |?Allocate@Heap@@QAAPAV1@K@Z|
  0014c	e1b03000	 movs        r3, r0
  00150	e58d3014	 str         r3, [sp, #0x14]

; 173  :     if( pSurfHeap == NULL )

  00154	0affffbd	 beq         |$LN16@Allocate|

; 174  :     {
; 175  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to allocate heap memory\n"));
; 176  :         goto cleanUp;
; 177  :     }
; 178  : 
; 179  :     //  Update the VRFB view with the surface parameters and allocated display memory         
; 180  :     VRFBUpdateView( hVRFB, hVRFBView, dwVrfbPixelSize, dwWidth/dwWidthFactor, dwHeight, pSurfHeap->Address() );

  00158	e5931008	 ldr         r1, [r3, #8]
  0015c	e59d3010	 ldr         r3, [sp, #0x10]
  00160	e1a02009	 mov         r2, r9
  00164	e59d9008	 ldr         r9, [sp, #8]
  00168	e58d1004	 str         r1, [sp, #4]
  0016c	e1a01008	 mov         r1, r8
  00170	e1a00006	 mov         r0, r6
  00174	e58d9000	 str         r9, [sp]
  00178	eb000000	 bl          VRFBUpdateView

; 181  : 
; 182  : 
; 183  :     //  Initialize the surface properties for this surface type
; 184  :     m_ePixelFormat   = ePixelFormat;
; 185  :     m_dwPixelSize    = info.dwPixelSizeBytes;
; 186  :     m_eOrientation   = OMAP_SURF_ORIENTATION_STANDARD;
; 187  :     m_dwWidth        = dwWidth;
; 188  :     m_dwHeight       = dwHeight;
; 189  : 
; 190  :     //  Set clipping region to be entire surface
; 191  :     SetClipping( NULL );

  0017c	e59d2020	 ldr         r2, [sp, #0x20]
  00180	e5953000	 ldr         r3, [r5]
  00184	e3a01000	 mov         r1, #0
  00188	e5852008	 str         r2, [r5, #8]
  0018c	e3a02000	 mov         r2, #0
  00190	e585200c	 str         r2, [r5, #0xC]
  00194	e59d200c	 ldr         r2, [sp, #0xC]
  00198	e5933020	 ldr         r3, [r3, #0x20]
  0019c	e1a00005	 mov         r0, r5
  001a0	e5852010	 str         r2, [r5, #0x10]
  001a4	e5854004	 str         r4, [r5, #4]
  001a8	e5859014	 str         r9, [r5, #0x14]
  001ac	e1a0e00f	 mov         lr, pc
  001b0	e12fff13	 bx          r3

; 192  : 
; 193  :     //  Set surface specific properties
; 194  :     m_hHeap     = (HANDLE) pSurfHeap;
; 195  :     m_hVRFB     = hVRFB;
; 196  :     m_hVRFBView = hVRFBView;
; 197  :     
; 198  :     g_bVRFBViewReserved[i] = TRUE;

  001b4	e59d3014	 ldr         r3, [sp, #0x14]
  001b8	e3a02001	 mov         r2, #1
  001bc	e58560a8	 str         r6, [r5, #0xA8]
  001c0	e58530a4	 str         r3, [r5, #0xA4]
  001c4	e58580ac	 str         r8, [r5, #0xAC]
  001c8	e78b2107	 str         r2, [r11, +r7, lsl #2]

; 199  :     m_dwViewIndex          = i;
; 200  :     m_dwWidthFactor        = dwWidthFactor;
; 201  : 
; 202  :     //  Clear out the memory
; 203  :     ptr = VirtualAddr();

  001cc	e5953000	 ldr         r3, [r5]
  001d0	e1a00005	 mov         r0, r5
  001d4	e58570b0	 str         r7, [r5, #0xB0]
  001d8	e5933004	 ldr         r3, [r3, #4]
  001dc	e585a0b4	 str         r10, [r5, #0xB4]
  001e0	e1a0e00f	 mov         lr, pc
  001e4	e12fff13	 bx          r3

; 204  :     dwStride = Stride();

  001e8	e5953000	 ldr         r3, [r5]
  001ec	e1a04000	 mov         r4, r0
  001f0	e3a01000	 mov         r1, #0
  001f4	e5933010	 ldr         r3, [r3, #0x10]
  001f8	e1a00005	 mov         r0, r5
  001fc	e1a0e00f	 mov         lr, pc
  00200	e12fff13	 bx          r3

; 205  :     
; 206  :     for( i = 0; i < m_dwHeight; i++ )

  00204	e5953014	 ldr         r3, [r5, #0x14]
  00208	e1a07000	 mov         r7, r0
  0020c	e3a06000	 mov         r6, #0
  00210	e3530000	 cmp         r3, #0
  00214	9a00000a	 bls         |$LN1@Allocate|
  00218		 |$LL3@Allocate|

; 207  :     {
; 208  :         memset( ptr, 0, m_dwPixelSize*m_dwWidth);

  00218	e595e010	 ldr         lr, [r5, #0x10]
  0021c	e5953008	 ldr         r3, [r5, #8]
  00220	e3a01000	 mov         r1, #0
  00224	e1a00004	 mov         r0, r4
  00228	e002039e	 mul         r2, lr, r3
  0022c	eb000000	 bl          memset
  00230	e5953014	 ldr         r3, [r5, #0x14]
  00234	e2866001	 add         r6, r6, #1

; 209  :         ptr = (VOID*)((DWORD)ptr + dwStride);

  00238	e0844007	 add         r4, r4, r7
  0023c	e1560003	 cmp         r6, r3
  00240	3afffff4	 bcc         |$LL3@Allocate|
  00244		 |$LN1@Allocate|

; 210  :     }
; 211  : 
; 212  :     // Initialize variables
; 213  :     m_hRSZHandle = NULL;
; 214  :     memset(&m_sRSZParams,0,sizeof(RSZParams_t));      

  00244	e3a03000	 mov         r3, #0
  00248	e3a02064	 mov         r2, #0x64
  0024c	e3a01000	 mov         r1, #0
  00250	e2850038	 add         r0, r5, #0x38
  00254	e5853034	 str         r3, [r5, #0x34]
  00258	eb000000	 bl          memset

; 215  : 
; 216  :     DEBUGMSG(ZONE_WARNING, (L"INFO: OMAPVrfbSurface::Allocate() - Allocating VRFB View # %d\r\n", m_dwViewIndex));
; 217  :     
; 218  : cleanUp:        
; 219  :     //  Return
; 220  :     return (pSurfHeap != NULL);

  0025c	e3a00001	 mov         r0, #1
  00260		 |$cleanUp$37265|
  00260	eaffff7b	 b           |$LN22@Allocate|
  00264		 |$LN37@Allocate|
  00264		 |$LN38@Allocate|
  00264	00000000	 DCD         |?g_bVRFBViewReserved@@3PAHA|
  00268		 |$M38031|

			 ENDP  ; |?Allocate@OMAPVrfbSurface@@QAAHW4OMAP_DSS_PIXELFORMAT@@KKPAX1@Z|, OMAPVrfbSurface::Allocate


  00000			 AREA	 |.pdata|, PDATA
|$T38045| DCD	|$LN7@VirtualAdd|
	DCD	0x40001902
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?VirtualAddr@OMAPVrfbSurface@@UAAPAXXZ| PROC ; OMAPVrfbSurface::VirtualAddr

; 227  : {

  00000		 |$LN7@VirtualAdd|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd040	 sub         sp, sp, #0x40
  00008		 |$M38042|

; 228  :     VRFB_VIEW_INFO  info;      
; 229  : 
; 230  :     if ((m_bUseResizer) && (m_eSurfaceType == OMAP_SURFACE_NORMAL) && (m_pAssocSurface))

  00008	e5903030	 ldr         r3, [r0, #0x30]
  0000c	e3530000	 cmp         r3, #0
  00010	0a00000b	 beq         |$LN2@VirtualAdd|
  00014	e590309c	 ldr         r3, [r0, #0x9C]
  00018	e3530000	 cmp         r3, #0
  0001c	1a000008	 bne         |$LN2@VirtualAdd|
  00020	e59030a0	 ldr         r3, [r0, #0xA0]
  00024	e3530000	 cmp         r3, #0
  00028	0a000005	 beq         |$LN2@VirtualAdd|

; 231  :         return m_pAssocSurface->VirtualAddr();

  0002c	e1a00003	 mov         r0, r3
  00030	e5903000	 ldr         r3, [r0]
  00034	e5933004	 ldr         r3, [r3, #4]
  00038	e1a0e00f	 mov         lr, pc
  0003c	e12fff13	 bx          r3
  00040	ea000004	 b           |$LN1@VirtualAdd|
  00044		 |$LN2@VirtualAdd|

; 232  :     else
; 233  :     {
; 234  :         //  Get virtual address of VRFB view
; 235  :         VRFBGetViewInfo( m_hVRFB, m_hVRFBView, &info );

  00044	e59010ac	 ldr         r1, [r0, #0xAC]
  00048	e59000a8	 ldr         r0, [r0, #0xA8]
  0004c	e28d2000	 add         r2, sp, #0
  00050	eb000000	 bl          VRFBGetViewInfo

; 236  :         return (VOID*) info.dwVirtualAddr;

  00054	e59d0030	 ldr         r0, [sp, #0x30]
  00058		 |$LN1@VirtualAdd|

; 237  :     }
; 238  : }

  00058	e28dd040	 add         sp, sp, #0x40
  0005c	e49de004	 ldr         lr, [sp], #4
  00060	e12fff1e	 bx          lr
  00064		 |$M38043|

			 ENDP  ; |?VirtualAddr@OMAPVrfbSurface@@UAAPAXXZ|, OMAPVrfbSurface::VirtualAddr


  00000			 AREA	 |.pdata|, PDATA
|$T38058| DCD	|$LN11@Width|
	DCD	0x40001501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Width@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z| PROC ; OMAPVrfbSurface::Width

; 246  : {

  00000		 |$LN11@Width|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38055|
  00004	e3510000	 cmp         r1, #0

; 247  :     DWORD   dwWidth;
; 248  :     
; 249  :     //  Return the surface width depending on the rotation angle
; 250  :     switch( eRotation )

  00008	0a00000c	 beq         |$LN3@Width|
  0000c	e351005a	 cmp         r1, #0x5A
  00010	0a000007	 beq         |$LN2@Width|
  00014	e35100b4	 cmp         r1, #0xB4
  00018	0a000008	 beq         |$LN3@Width|
  0001c	e3a03c01	 mov         r3, #1, 24
  00020	e383300e	 orr         r3, r3, #0xE
  00024	e1510003	 cmp         r1, r3

; 263  : 
; 264  :         default:
; 265  :             ASSERT(0);
; 266  :             return 0;

  00028	13a00000	 movne       r0, #0

; 267  :     }
; 268  :     
; 269  :     //  Return value
; 270  :     return dwWidth;
; 271  : }

  0002c	149de004	 ldrne       lr, [sp], #4
  00030	112fff1e	 bxne        lr
  00034		 |$LN2@Width|

; 256  :             break;
; 257  :             
; 258  :         case OMAP_DSS_ROTATION_90:
; 259  :         case OMAP_DSS_ROTATION_270:
; 260  :             //  Rotated
; 261  :             dwWidth = m_dwHeight/m_dwVertScale;

  00034	e5901014	 ldr         r1, [r0, #0x14]
  00038	e590002c	 ldr         r0, [r0, #0x2C]

; 262  :             break;

  0003c	ea000001	 b           |$LN8@Width|
  00040		 |$LN3@Width|

; 251  :     {
; 252  :         case OMAP_DSS_ROTATION_0:
; 253  :         case OMAP_DSS_ROTATION_180:
; 254  :             //  Normal
; 255  :             dwWidth = m_dwWidth/m_dwHorizScale;

  00040	e5901010	 ldr         r1, [r0, #0x10]
  00044	e5900028	 ldr         r0, [r0, #0x28]
  00048		 |$LN8@Width|
  00048	eb000000	 bl          __rt_udiv

; 267  :     }
; 268  :     
; 269  :     //  Return value
; 270  :     return dwWidth;
; 271  : }

  0004c	e49de004	 ldr         lr, [sp], #4
  00050	e12fff1e	 bx          lr
  00054		 |$M38056|

			 ENDP  ; |?Width@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z|, OMAPVrfbSurface::Width


  00000			 AREA	 |.pdata|, PDATA
|$T38071| DCD	|$LN11@Height|
	DCD	0x40001501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Height@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z| PROC ; OMAPVrfbSurface::Height

; 278  : {

  00000		 |$LN11@Height|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38068|
  00004	e3510000	 cmp         r1, #0

; 279  :     DWORD   dwHeight;
; 280  :     
; 281  :     //  Return the surface height depending on the rotation angle
; 282  :     switch( eRotation )

  00008	0a00000c	 beq         |$LN3@Height|
  0000c	e351005a	 cmp         r1, #0x5A
  00010	0a000007	 beq         |$LN2@Height|
  00014	e35100b4	 cmp         r1, #0xB4
  00018	0a000008	 beq         |$LN3@Height|
  0001c	e3a03c01	 mov         r3, #1, 24
  00020	e383300e	 orr         r3, r3, #0xE
  00024	e1510003	 cmp         r1, r3

; 295  : 
; 296  :         default:
; 297  :             ASSERT(0);
; 298  :             return 0;

  00028	13a00000	 movne       r0, #0

; 299  :     }
; 300  :     
; 301  :     //  Return value
; 302  :     return dwHeight;
; 303  : }

  0002c	149de004	 ldrne       lr, [sp], #4
  00030	112fff1e	 bxne        lr
  00034		 |$LN2@Height|

; 288  :             break;
; 289  :             
; 290  :         case OMAP_DSS_ROTATION_90:
; 291  :         case OMAP_DSS_ROTATION_270:
; 292  :             //  Rotated
; 293  :             dwHeight = m_dwWidth/m_dwHorizScale;

  00034	e5901010	 ldr         r1, [r0, #0x10]
  00038	e5900028	 ldr         r0, [r0, #0x28]

; 294  :             break;

  0003c	ea000001	 b           |$LN8@Height|
  00040		 |$LN3@Height|

; 283  :     {
; 284  :         case OMAP_DSS_ROTATION_0:
; 285  :         case OMAP_DSS_ROTATION_180:
; 286  :             //  Normal
; 287  :             dwHeight = m_dwHeight/m_dwVertScale;

  00040	e5901014	 ldr         r1, [r0, #0x14]
  00044	e590002c	 ldr         r0, [r0, #0x2C]
  00048		 |$LN8@Height|
  00048	eb000000	 bl          __rt_udiv

; 299  :     }
; 300  :     
; 301  :     //  Return value
; 302  :     return dwHeight;
; 303  : }

  0004c	e49de004	 ldr         lr, [sp], #4
  00050	e12fff1e	 bx          lr
  00054		 |$M38069|

			 ENDP  ; |?Height@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z|, OMAPVrfbSurface::Height


  00000			 AREA	 |.pdata|, PDATA
|$T38085| DCD	|$LN13@Stride|
	DCD	0x40002102
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Stride@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z| PROC ; OMAPVrfbSurface::Stride

; 310  : {

  00000		 |$LN13@Stride|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd044	 sub         sp, sp, #0x44
  00008		 |$M38082|
  00008	e3510000	 cmp         r1, #0

; 311  :     DWORD           dwRotation;
; 312  :     VRFB_VIEW_INFO  info;        
; 313  :     DWORD           dwScaleFactor;        
; 314  : 
; 315  :     //  Translate DSS rotation enum to VRFB enum
; 316  :     switch( eRotation )

  0000c	0a00000f	 beq         |$LN5@Stride|
  00010	e351005a	 cmp         r1, #0x5A
  00014	0a00000a	 beq         |$LN4@Stride|
  00018	e35100b4	 cmp         r1, #0xB4
  0001c	0a000006	 beq         |$LN3@Stride|
  00020	e3a03c01	 mov         r3, #1, 24
  00024	e383200e	 orr         r2, r3, #0xE
  00028	e1510002	 cmp         r1, r2

; 337  : 
; 338  :         default:
; 339  :             ASSERT(0);
; 340  :             return 0;

  0002c	13a00000	 movne       r0, #0
  00030	1a000010	 bne         |$LN8@Stride|

; 332  :             
; 333  :         case OMAP_DSS_ROTATION_270:
; 334  :             dwRotation = VRFB_ROTATE_ANGLE_270;
; 335  :             dwScaleFactor = m_dwVertScale;

  00034	e590402c	 ldr         r4, [r0, #0x2C]

; 336  :             break;

  00038	ea000006	 b           |$LN6@Stride|
  0003c		 |$LN3@Stride|

; 327  : 
; 328  :         case OMAP_DSS_ROTATION_180:
; 329  :             dwRotation = VRFB_ROTATE_ANGLE_180;
; 330  :             dwScaleFactor = m_dwHorizScale;

  0003c	e3a020b4	 mov         r2, #0xB4

; 331  :             break;

  00040	ea000003	 b           |$LN10@Stride|
  00044		 |$LN4@Stride|

; 321  :             break;
; 322  : 
; 323  :         case OMAP_DSS_ROTATION_90:
; 324  :             dwRotation = VRFB_ROTATE_ANGLE_90;
; 325  :             dwScaleFactor = m_dwVertScale;

  00044	e590402c	 ldr         r4, [r0, #0x2C]
  00048	e3a0205a	 mov         r2, #0x5A

; 326  :             break;

  0004c	ea000001	 b           |$LN6@Stride|
  00050		 |$LN5@Stride|

; 317  :     {   
; 318  :         case OMAP_DSS_ROTATION_0:
; 319  :             dwRotation = VRFB_ROTATE_ANGLE_0;
; 320  :             dwScaleFactor = m_dwHorizScale;

  00050	e3a02000	 mov         r2, #0
  00054		 |$LN10@Stride|
  00054	e5904028	 ldr         r4, [r0, #0x28]
  00058		 |$LN6@Stride|

; 341  :     }
; 342  :     
; 343  :     //  Get stride of VRFB display view
; 344  :     VRFBGetDisplayViewInfo( m_hVRFB, m_dwViewIndex, dwRotation, FALSE, &info );

  00058	e59010b0	 ldr         r1, [r0, #0xB0]
  0005c	e59000a8	 ldr         r0, [r0, #0xA8]
  00060	e28de004	 add         lr, sp, #4
  00064	e3a03000	 mov         r3, #0
  00068	e58de000	 str         lr, [sp]
  0006c	eb000000	 bl          VRFBGetDisplayViewInfo

; 345  :     return (info.dwImageStride * dwScaleFactor);

  00070	e59d3028	 ldr         r3, [sp, #0x28]
  00074	e0000493	 mul         r0, r3, r4
  00078		 |$LN8@Stride|

; 346  : }

  00078	e28dd044	 add         sp, sp, #0x44
  0007c	e8bd4010	 ldmia       sp!, {r4, lr}
  00080	e12fff1e	 bx          lr
  00084		 |$M38083|

			 ENDP  ; |?Stride@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z|, OMAPVrfbSurface::Stride


  00000			 AREA	 |.pdata|, PDATA
|$T38106| DCD	|$LN34@PhysicalAd|
	DCD	0x40009802
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PhysicalAddr@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@HW4OMAP_ASSOC_SURF_USAGE@@@Z| PROC ; OMAPVrfbSurface::PhysicalAddr

; 355  : {

  00000		 |$LN34@PhysicalAd|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd044	 sub         sp, sp, #0x44
  00008		 |$M38103|
  00008	e3530000	 cmp         r3, #0
  0000c	e1a06002	 mov         r6, r2
  00010	e1a04001	 mov         r4, r1
  00014	e1a05000	 mov         r5, r0

; 356  :     DWORD           dwRotation;
; 357  :     VRFB_VIEW_INFO  info;                
; 358  :     INT             iClipOffsetX = 0,

  00018	e3a07000	 mov         r7, #0

; 359  :                     iClipOffsetY = 0;

  0001c	e3a08000	 mov         r8, #0

; 360  : 
; 361  :      if ((((eUseAssocSurface==OMAP_ASSOC_SURF_DEFAULT) && (m_bUseResizer)) ||
; 362  :           ( eUseAssocSurface==OMAP_ASSOC_SURF_FORCE_ON )                     ) &&
; 363  :         (m_pAssocSurface))

  00020	1a000002	 bne         |$LN22@PhysicalAd|
  00024	e595e030	 ldr         lr, [r5, #0x30]
  00028	e35e0000	 cmp         lr, #0
  0002c	1a000001	 bne         |$LN23@PhysicalAd|
  00030		 |$LN22@PhysicalAd|
  00030	e3530002	 cmp         r3, #2
  00034	1a00000b	 bne         |$LN24@PhysicalAd|
  00038		 |$LN23@PhysicalAd|
  00038	e59530a0	 ldr         r3, [r5, #0xA0]
  0003c	e3530000	 cmp         r3, #0
  00040	0a000008	 beq         |$LN24@PhysicalAd|

; 364  :         
; 365  :         return m_pAssocSurface->PhysicalAddr(eRotation,bMirror,OMAP_ASSOC_SURF_FORCE_OFF);        

  00044	e1a00003	 mov         r0, r3
  00048	e590e000	 ldr         lr, [r0]
  0004c	e1a01004	 mov         r1, r4
  00050	e3a03001	 mov         r3, #1
  00054	e59e4014	 ldr         r4, [lr, #0x14]
  00058	e1a02006	 mov         r2, r6
  0005c	e1a0e00f	 mov         lr, pc
  00060	e12fff14	 bx          r4
  00064	ea00007a	 b           |$LN25@PhysicalAd|
  00068		 |$LN24@PhysicalAd|

; 366  : 
; 367  : 
; 368  :     //  Translate DSS rotation enum to VRFB enum
; 369  :     switch( eRotation )

  00068	e3a03c01	 mov         r3, #1, 24
  0006c	e383900e	 orr         r9, r3, #0xE
  00070	e3540000	 cmp         r4, #0
  00074	0a00000c	 beq         |$LN19@PhysicalAd|
  00078	e354005a	 cmp         r4, #0x5A
  0007c	0a000008	 beq         |$LN18@PhysicalAd|
  00080	e35400b4	 cmp         r4, #0xB4
  00084	0a000004	 beq         |$LN17@PhysicalAd|
  00088	e1540009	 cmp         r4, r9

; 386  : 
; 387  :         default:
; 388  :             ASSERT(0);
; 389  :             return 0;

  0008c	13a00000	 movne       r0, #0
  00090	1a00006f	 bne         |$LN25@PhysicalAd|

; 382  :             
; 383  :         case OMAP_DSS_ROTATION_270:
; 384  :             dwRotation = VRFB_ROTATE_ANGLE_270;

  00094	e1a02009	 mov         r2, r9

; 385  :             break;

  00098	ea000004	 b           |$LN20@PhysicalAd|
  0009c		 |$LN17@PhysicalAd|

; 378  : 
; 379  :         case OMAP_DSS_ROTATION_180:
; 380  :             dwRotation = VRFB_ROTATE_ANGLE_180;

  0009c	e3a020b4	 mov         r2, #0xB4

; 381  :             break;

  000a0	ea000002	 b           |$LN20@PhysicalAd|
  000a4		 |$LN18@PhysicalAd|

; 373  :             break;
; 374  : 
; 375  :         case OMAP_DSS_ROTATION_90:
; 376  :             dwRotation = VRFB_ROTATE_ANGLE_90;

  000a4	e3a0205a	 mov         r2, #0x5A

; 377  :             break;

  000a8	ea000000	 b           |$LN20@PhysicalAd|
  000ac		 |$LN19@PhysicalAd|

; 370  :     {   
; 371  :         case OMAP_DSS_ROTATION_0:
; 372  :             dwRotation = VRFB_ROTATE_ANGLE_0;

  000ac	e3a02000	 mov         r2, #0
  000b0		 |$LN20@PhysicalAd|

; 390  :     }
; 391  :     
; 392  :     //  Get virtual address of VRFB display view
; 393  :     VRFBGetDisplayViewInfo( m_hVRFB, m_dwViewIndex, dwRotation, bMirror, &info );

  000b0	e59510b0	 ldr         r1, [r5, #0xB0]
  000b4	e59500a8	 ldr         r0, [r5, #0xA8]
  000b8	e28de004	 add         lr, sp, #4
  000bc	e1a03006	 mov         r3, r6
  000c0	e58de000	 str         lr, [sp]
  000c4	eb000000	 bl          VRFBGetDisplayViewInfo

; 394  : 
; 395  : 
; 396  :     //  Compute clip offset
; 397  :     switch( eRotation )

  000c8	e3540000	 cmp         r4, #0
  000cc	0a000047	 beq         |$LN12@PhysicalAd|
  000d0	e354005a	 cmp         r4, #0x5A
  000d4	0a000032	 beq         |$LN9@PhysicalAd|
  000d8	e35400b4	 cmp         r4, #0xB4
  000dc	0a000016	 beq         |$LN6@PhysicalAd|
  000e0	e1540009	 cmp         r4, r9
  000e4	1a000055	 bne         |$LN10@PhysicalAd|

; 437  :             
; 438  :         case OMAP_DSS_ROTATION_270:
; 439  :             if( bMirror )
; 440  :             {
; 441  :                 iClipOffsetX = -1 * ((m_dwWidth - m_rcClip.right) / m_dwWidthFactor) * info.dwImageStride;

  000e8	e59500b4	 ldr         r0, [r5, #0xB4]
  000ec	e3560000	 cmp         r6, #0
  000f0	0a00000c	 beq         |$LN2@PhysicalAd|
  000f4	e5952010	 ldr         r2, [r5, #0x10]
  000f8	e5953020	 ldr         r3, [r5, #0x20]
  000fc	e0421003	 sub         r1, r2, r3
  00100	eb000000	 bl          __rt_udiv
  00104	e59d3028	 ldr         r3, [sp, #0x28]

; 442  :                 iClipOffsetY = (m_dwHeight - m_rcClip.bottom) * info.dwPixelSizeBytes;

  00108	e5954014	 ldr         r4, [r5, #0x14]
  0010c	e595e024	 ldr         lr, [r5, #0x24]
  00110	e59d100c	 ldr         r1, [sp, #0xC]
  00114	e0020390	 mul         r2, r0, r3
  00118	e044300e	 sub         r3, r4, lr
  0011c	e2627000	 rsb         r7, r2, #0
  00120	e0080193	 mul         r8, r3, r1

; 443  :             }
; 444  :             else

  00124	ea000045	 b           |$LN10@PhysicalAd|
  00128		 |$LN2@PhysicalAd|

; 445  :             {
; 446  :                 iClipOffsetX = (m_rcClip.left / m_dwWidthFactor) * info.dwImageStride;

  00128	e5951018	 ldr         r1, [r5, #0x18]
  0012c	eb000000	 bl          __rt_udiv

; 447  :                 iClipOffsetY = (m_dwHeight - m_rcClip.bottom) * info.dwPixelSizeBytes;

  00130	e59de028	 ldr         lr, [sp, #0x28]
  00134	e59d200c	 ldr         r2, [sp, #0xC]

; 448  :             }
; 449  :             break;

  00138	ea000013	 b           |$LN31@PhysicalAd|
  0013c		 |$LN6@PhysicalAd|

; 424  : 
; 425  :         case OMAP_DSS_ROTATION_180:
; 426  :             if( bMirror )
; 427  :             {
; 428  :                 iClipOffsetX = (m_rcClip.left / m_dwWidthFactor) * info.dwPixelSizeBytes;

  0013c	e59500b4	 ldr         r0, [r5, #0xB4]
  00140	e3560000	 cmp         r6, #0
  00144	0a00000a	 beq         |$LN5@PhysicalAd|
  00148	e5951018	 ldr         r1, [r5, #0x18]
  0014c	eb000000	 bl          __rt_udiv

; 429  :                 iClipOffsetY = -1 * ((m_dwHeight - m_rcClip.bottom) * info.dwImageStride);

  00150	e5951014	 ldr         r1, [r5, #0x14]
  00154	e5953024	 ldr         r3, [r5, #0x24]
  00158	e59d2028	 ldr         r2, [sp, #0x28]
  0015c	e59de00c	 ldr         lr, [sp, #0xC]
  00160	e0413003	 sub         r3, r1, r3
  00164	e0020293	 mul         r2, r3, r2

; 434  :                 iClipOffsetY = (m_dwHeight - m_rcClip.bottom) * info.dwImageStride;

  00168	e0070e90	 mul         r7, r0, lr
  0016c	e2628000	 rsb         r8, r2, #0

; 435  :             }
; 436  :             break;

  00170	ea000032	 b           |$LN10@PhysicalAd|
  00174		 |$LN5@PhysicalAd|

; 430  :             }
; 431  :             else
; 432  :             {
; 433  :                 iClipOffsetX = ((m_dwWidth - m_rcClip.right) / m_dwWidthFactor) * info.dwPixelSizeBytes;

  00174	e5952010	 ldr         r2, [r5, #0x10]
  00178	e5953020	 ldr         r3, [r5, #0x20]
  0017c	e0421003	 sub         r1, r2, r3
  00180	eb000000	 bl          __rt_udiv

; 434  :                 iClipOffsetY = (m_dwHeight - m_rcClip.bottom) * info.dwImageStride;

  00184	e59de00c	 ldr         lr, [sp, #0xC]
  00188	e59d2028	 ldr         r2, [sp, #0x28]
  0018c		 |$LN31@PhysicalAd|
  0018c	e5953024	 ldr         r3, [r5, #0x24]
  00190	e5951014	 ldr         r1, [r5, #0x14]
  00194	e0070e90	 mul         r7, r0, lr
  00198	e0413003	 sub         r3, r1, r3
  0019c	e0080293	 mul         r8, r3, r2

; 435  :             }
; 436  :             break;

  001a0	ea000026	 b           |$LN10@PhysicalAd|
  001a4		 |$LN9@PhysicalAd|

; 409  :             }
; 410  :             break;
; 411  : 
; 412  :         case OMAP_DSS_ROTATION_90:
; 413  :             if( bMirror )
; 414  :             {
; 415  :                 iClipOffsetX = -1 * (m_rcClip.left / m_dwWidthFactor) * info.dwImageStride;

  001a4	e59500b4	 ldr         r0, [r5, #0xB4]
  001a8	e3560000	 cmp         r6, #0
  001ac	0a000008	 beq         |$LN8@PhysicalAd|
  001b0	e5951018	 ldr         r1, [r5, #0x18]
  001b4	eb000000	 bl          __rt_udiv
  001b8	e59d3028	 ldr         r3, [sp, #0x28]

; 416  :                 iClipOffsetY = m_rcClip.top * info.dwPixelSizeBytes;

  001bc	e595101c	 ldr         r1, [r5, #0x1C]
  001c0	e59d200c	 ldr         r2, [sp, #0xC]
  001c4	e0030390	 mul         r3, r0, r3
  001c8	e0080291	 mul         r8, r1, r2
  001cc	e2637000	 rsb         r7, r3, #0

; 417  :             }
; 418  :             else

  001d0	ea00001a	 b           |$LN10@PhysicalAd|
  001d4		 |$LN8@PhysicalAd|

; 419  :             {
; 420  :                 iClipOffsetX = ((m_dwWidth - m_rcClip.right) / m_dwWidthFactor) * info.dwImageStride;

  001d4	e5952010	 ldr         r2, [r5, #0x10]
  001d8	e5953020	 ldr         r3, [r5, #0x20]
  001dc	e0421003	 sub         r1, r2, r3
  001e0	eb000000	 bl          __rt_udiv
  001e4	e59d2028	 ldr         r2, [sp, #0x28]

; 421  :                 iClipOffsetY = m_rcClip.top * info.dwPixelSizeBytes;

  001e8	e59d300c	 ldr         r3, [sp, #0xC]

; 422  :             }
; 423  :             break;

  001ec	ea000010	 b           |$LN27@PhysicalAd|
  001f0		 |$LN12@PhysicalAd|

; 398  :     {   
; 399  :         case OMAP_DSS_ROTATION_0:
; 400  :             if( bMirror )
; 401  :             {
; 402  :                 iClipOffsetX = ((m_dwWidth - m_rcClip.right) / m_dwWidthFactor) * info.dwPixelSizeBytes;

  001f0	e59500b4	 ldr         r0, [r5, #0xB4]
  001f4	e3560000	 cmp         r6, #0
  001f8	0a000009	 beq         |$LN11@PhysicalAd|
  001fc	e5952010	 ldr         r2, [r5, #0x10]
  00200	e5953020	 ldr         r3, [r5, #0x20]
  00204	e0421003	 sub         r1, r2, r3
  00208	eb000000	 bl          __rt_udiv

; 403  :                 iClipOffsetY = -1 * (m_rcClip.top * info.dwImageStride);

  0020c	e595101c	 ldr         r1, [r5, #0x1C]
  00210	e59d3028	 ldr         r3, [sp, #0x28]
  00214	e59d200c	 ldr         r2, [sp, #0xC]
  00218	e0030391	 mul         r3, r1, r3
  0021c	e2638000	 rsb         r8, r3, #0

; 404  :             }
; 405  :             else

  00220	ea000005	 b           |$LN28@PhysicalAd|
  00224		 |$LN11@PhysicalAd|

; 406  :             {
; 407  :                 iClipOffsetX = (m_rcClip.left / m_dwWidthFactor) * info.dwPixelSizeBytes;

  00224	e5951018	 ldr         r1, [r5, #0x18]
  00228	eb000000	 bl          __rt_udiv
  0022c	e59d200c	 ldr         r2, [sp, #0xC]

; 408  :                 iClipOffsetY = m_rcClip.top * info.dwImageStride;

  00230	e59d3028	 ldr         r3, [sp, #0x28]
  00234		 |$LN27@PhysicalAd|
  00234	e595101c	 ldr         r1, [r5, #0x1C]
  00238	e0080391	 mul         r8, r1, r3
  0023c		 |$LN28@PhysicalAd|
  0023c	e0070290	 mul         r7, r0, r2
  00240		 |$LN10@PhysicalAd|

; 450  :     }
; 451  : 
; 452  :     return info.dwPhysicalAddrOutput + info.dwOriginOffset + iClipOffsetX + iClipOffsetY;

  00240	e59d203c	 ldr         r2, [sp, #0x3C]
  00244	e59d302c	 ldr         r3, [sp, #0x2C]
  00248	e0833002	 add         r3, r3, r2
  0024c	e0833008	 add         r3, r3, r8
  00250	e0830007	 add         r0, r3, r7
  00254		 |$LN25@PhysicalAd|

; 453  : }

  00254	e28dd044	 add         sp, sp, #0x44
  00258	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  0025c	e12fff1e	 bx          lr
  00260		 |$M38104|

			 ENDP  ; |?PhysicalAddr@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@HW4OMAP_ASSOC_SURF_USAGE@@@Z|, OMAPVrfbSurface::PhysicalAddr


  00000			 AREA	 |.pdata|, PDATA
|$T38119| DCD	|$LN11@PixelIncr|
	DCD	0x40001300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PixelIncr@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@H@Z| PROC ; OMAPVrfbSurface::PixelIncr

; 462  : {

  00000		 |$LN11@PixelIncr|
  00000		 |$M38116|
  00000	e3510000	 cmp         r1, #0

; 463  :     DWORD   dwIncr = 1;
; 464  :     
; 465  :     UNREFERENCED_PARAMETER(bMirror);
; 466  :     //  Pixel increment is always 1 for VRFB surfaces (mirror setting has no impact)
; 467  :     
; 468  :     //  Scale factor is dependent on rotation angle
; 469  :     switch( eRotation )

  00004	0a00000a	 beq         |$LN3@PixelIncr|
  00008	e351005a	 cmp         r1, #0x5A
  0000c	0a000006	 beq         |$LN2@PixelIncr|
  00010	e35100b4	 cmp         r1, #0xB4
  00014	0a000006	 beq         |$LN3@PixelIncr|
  00018	e3a03c01	 mov         r3, #1, 24
  0001c	e383300e	 orr         r3, r3, #0xE
  00020	e1510003	 cmp         r1, r3

; 482  : 
; 483  :         default:
; 484  :             ASSERT(0);
; 485  :             return 0;

  00024	13a00000	 movne       r0, #0

; 486  :     }            
; 487  :     
; 488  :     //  Return pixel increment
; 489  :     return dwIncr;
; 490  : }

  00028	112fff1e	 bxne        lr
  0002c		 |$LN2@PixelIncr|

; 475  :             break;
; 476  : 
; 477  :         case OMAP_DSS_ROTATION_90:
; 478  :         case OMAP_DSS_ROTATION_270:
; 479  :             //  (+ horizontal_scale_factor*pixel_size)
; 480  :             dwIncr += ((m_dwVertScale - 1) * m_dwPixelSize);

  0002c	e590302c	 ldr         r3, [r0, #0x2C]

; 481  :             break;

  00030	ea000000	 b           |$LN8@PixelIncr|
  00034		 |$LN3@PixelIncr|

; 470  :     {
; 471  :         case OMAP_DSS_ROTATION_0:
; 472  :         case OMAP_DSS_ROTATION_180:
; 473  :             //  (+ horizontal_scale_factor*pixel_size)
; 474  :             dwIncr += ((m_dwHorizScale - 1) * m_dwPixelSize);

  00034	e5903028	 ldr         r3, [r0, #0x28]
  00038		 |$LN8@PixelIncr|
  00038	e5902008	 ldr         r2, [r0, #8]
  0003c	e2433001	 sub         r3, r3, #1
  00040	e0020293	 mul         r2, r3, r2
  00044	e2820001	 add         r0, r2, #1

; 486  :     }            
; 487  :     
; 488  :     //  Return pixel increment
; 489  :     return dwIncr;
; 490  : }

  00048	e12fff1e	 bx          lr
  0004c		 |$M38117|

			 ENDP  ; |?PixelIncr@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@H@Z|, OMAPVrfbSurface::PixelIncr


  00000			 AREA	 |.pdata|, PDATA
|$T38137| DCD	|$LN18@RowIncr|
	DCD	0x40005b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?RowIncr@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@H@Z| PROC ; OMAPVrfbSurface::RowIncr

; 498  : {

  00000		 |$LN18@RowIncr|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd040	 sub         sp, sp, #0x40
  00008		 |$M38134|
  00008	e1a06002	 mov         r6, r2
  0000c	e1a05001	 mov         r5, r1
  00010	e1a04000	 mov         r4, r0

; 499  :     VRFB_VIEW_INFO  info;
; 500  :     DWORD           dwRowIncr;     
; 501  :     DWORD           dwClipOffsetX,
; 502  :                     dwClipOffsetY;
; 503  : 
; 504  :     if ((m_bUseResizer) && (m_eSurfaceType == OMAP_SURFACE_NORMAL) && (m_pAssocSurface))

  00014	e5943030	 ldr         r3, [r4, #0x30]
  00018	e3530000	 cmp         r3, #0
  0001c	0a00000b	 beq         |$LN10@RowIncr|
  00020	e594309c	 ldr         r3, [r4, #0x9C]
  00024	e3530000	 cmp         r3, #0
  00028	1a000008	 bne         |$LN10@RowIncr|
  0002c	e59430a0	 ldr         r3, [r4, #0xA0]
  00030	e3530000	 cmp         r3, #0
  00034	0a000005	 beq         |$LN10@RowIncr|

; 505  :         return m_pAssocSurface->RowIncr(eRotation,bMirror);

  00038	e1a00003	 mov         r0, r3
  0003c	e5903000	 ldr         r3, [r0]
  00040	e593301c	 ldr         r3, [r3, #0x1C]
  00044	e1a0e00f	 mov         lr, pc
  00048	e12fff13	 bx          r3
  0004c	ea000043	 b           |$LN5@RowIncr|
  00050		 |$LN10@RowIncr|

; 506  : 
; 507  :     //  Compute the VRFB row increment
; 508  :     VRFBGetViewInfo( m_hVRFB, m_hVRFBView, &info );

  00050	e59410ac	 ldr         r1, [r4, #0xAC]
  00054	e59400a8	 ldr         r0, [r4, #0xA8]
  00058	e28d2000	 add         r2, sp, #0
  0005c	eb000000	 bl          VRFBGetViewInfo

; 509  : 
; 510  :     //  Compute clipping offsets
; 511  :     dwClipOffsetX = m_dwWidth - (m_rcClip.right - m_rcClip.left);
; 512  :     dwClipOffsetY = m_dwHeight - (m_rcClip.bottom - m_rcClip.top);

  00060	e594e014	 ldr         lr, [r4, #0x14]
  00064	e5947010	 ldr         r7, [r4, #0x10]
  00068	e5943020	 ldr         r3, [r4, #0x20]
  0006c	e5942024	 ldr         r2, [r4, #0x24]
  00070	e5941018	 ldr         r1, [r4, #0x18]
  00074	e594001c	 ldr         r0, [r4, #0x1C]
  00078	e04e2002	 sub         r2, lr, r2
  0007c	e0473003	 sub         r3, r7, r3
  00080	e0820000	 add         r0, r2, r0
  00084	e0833001	 add         r3, r3, r1

; 513  :     
; 514  :     //  Row increment depends on angle, mirror and clipping region
; 515  :     switch( eRotation )

  00088	e3550000	 cmp         r5, #0
  0008c	0a00001a	 beq         |$LN7@RowIncr|
  00090	e355005a	 cmp         r5, #0x5A
  00094	0a000006	 beq         |$LN4@RowIncr|
  00098	e35500b4	 cmp         r5, #0xB4
  0009c	0a000016	 beq         |$LN7@RowIncr|
  000a0	e3a03c01	 mov         r3, #1, 24
  000a4	e383300e	 orr         r3, r3, #0xE
  000a8	e1550003	 cmp         r5, r3

; 560  : 
; 561  :         default:
; 562  :             ASSERT(0);
; 563  :             return 0;

  000ac	13a00000	 movne       r0, #0
  000b0	1a00002a	 bne         |$LN5@RowIncr|
  000b4		 |$LN4@RowIncr|

; 536  :             }
; 537  :             break;
; 538  : 
; 539  :         case OMAP_DSS_ROTATION_90:
; 540  :         case OMAP_DSS_ROTATION_270:
; 541  :             //  Computation changes depending on mirror setting
; 542  :             if( !bMirror )
; 543  :             {
; 544  :                 dwRowIncr = (VRFB_IMAGE_HEIGHT_MAX - (m_dwHeight - dwClipOffsetY)) * info.dwPixelSizeBytes + 1;
; 545  : 
; 546  :                 //  (+ horizontal_scale_factor*stride + vertical_scale_factor*pixel_size) 
; 547  :                 dwRowIncr += ((m_dwHorizScale - 1) * VRFB_IMAGE_HEIGHT_MAX * info.dwPixelSizeBytes);

  000b4	e5943028	 ldr         r3, [r4, #0x28]

; 548  :                 dwRowIncr += ((m_dwVertScale - 1) * info.dwPixelSizeBytes);

  000b8	e594202c	 ldr         r2, [r4, #0x2C]

; 549  :             }
; 550  :             else

  000bc	e59d1008	 ldr         r1, [sp, #8]
  000c0	e2433001	 sub         r3, r3, #1
  000c4	e3560000	 cmp         r6, #0
  000c8	1a000005	 bne         |$LN3@RowIncr|
  000cc	e06e3583	 rsb         r3, lr, r3, lsl #11
  000d0	e0833002	 add         r3, r3, r2
  000d4	e0833000	 add         r3, r3, r0
  000d8		 |$LN15@RowIncr|
  000d8	e2833c07	 add         r3, r3, #7, 24
  000dc	e28330ff	 add         r3, r3, #0xFF
  000e0	ea00001c	 b           |$LN13@RowIncr|
  000e4		 |$LN3@RowIncr|

; 551  :             {
; 552  :                 dwRowIncr = (VRFB_IMAGE_HEIGHT_MAX + (m_dwHeight - dwClipOffsetY)) * info.dwPixelSizeBytes;
; 553  :                 dwRowIncr = 1 - dwRowIncr;
; 554  : 
; 555  :                 //  (- horizontal_scale_factor*stride + vertical_scale_factor*pixel_size) 
; 556  :                 dwRowIncr -= ((m_dwHorizScale - 1) * VRFB_IMAGE_HEIGHT_MAX * info.dwPixelSizeBytes);
; 557  :                 dwRowIncr += ((m_dwVertScale - 1) * info.dwPixelSizeBytes);

  000e4	e0423583	 sub         r3, r2, r3, lsl #11
  000e8	e043300e	 sub         r3, r3, lr
  000ec	e3a04b02	 mov         r4, #2, 22
  000f0	e0832000	 add         r2, r3, r0
  000f4	e3843001	 orr         r3, r4, #1

; 558  :             }
; 559  :             break;

  000f8	ea000015	 b           |$LN14@RowIncr|
  000fc		 |$LN7@RowIncr|

; 516  :     {
; 517  :         case OMAP_DSS_ROTATION_0:
; 518  :         case OMAP_DSS_ROTATION_180:
; 519  :             //  Computation changes depending on mirror setting
; 520  :             if( !bMirror )
; 521  :             {
; 522  :                 dwRowIncr = (VRFB_IMAGE_WIDTH_MAX - (m_dwWidth - dwClipOffsetX)/m_dwWidthFactor) * info.dwPixelSizeBytes + 1;

  000fc	e59400b4	 ldr         r0, [r4, #0xB4]
  00100	e3560000	 cmp         r6, #0
  00104	e0471003	 sub         r1, r7, r3
  00108	1a000007	 bne         |$LN6@RowIncr|
  0010c	eb000000	 bl          __rt_udiv

; 523  : 
; 524  :                 //  (+ vertical_scale_factor*stride + horizontal_scale_factor*pixel_size) 
; 525  :                 dwRowIncr += ((m_dwVertScale - 1) * VRFB_IMAGE_WIDTH_MAX * info.dwPixelSizeBytes);

  00110	e594302c	 ldr         r3, [r4, #0x2C]

; 526  :                 dwRowIncr += ((m_dwHorizScale - 1) * info.dwPixelSizeBytes);

  00114	e5942028	 ldr         r2, [r4, #0x28]

; 527  :             }
; 528  :             else

  00118	e59d1008	 ldr         r1, [sp, #8]
  0011c	e2433001	 sub         r3, r3, #1
  00120	e0603583	 rsb         r3, r0, r3, lsl #11
  00124	e0833002	 add         r3, r3, r2
  00128	eaffffea	 b           |$LN15@RowIncr|
  0012c		 |$LN6@RowIncr|

; 529  :             {
; 530  :                 dwRowIncr = (VRFB_IMAGE_WIDTH_MAX + (m_dwWidth - dwClipOffsetX)/m_dwWidthFactor) * info.dwPixelSizeBytes;

  0012c	eb000000	 bl          __rt_udiv

; 531  :                 dwRowIncr = 1 - dwRowIncr;
; 532  : 
; 533  :                 //  (- vertical_scale_factor*stride + horizontal_scale_factor*pixel_size) 
; 534  :                 dwRowIncr -= ((m_dwVertScale - 1) * VRFB_IMAGE_WIDTH_MAX * info.dwPixelSizeBytes);

  00130	e594302c	 ldr         r3, [r4, #0x2C]

; 535  :                 dwRowIncr += ((m_dwHorizScale - 1) * info.dwPixelSizeBytes);

  00134	e5942028	 ldr         r2, [r4, #0x28]
  00138	e3a0eb02	 mov         lr, #2, 22
  0013c	e2433001	 sub         r3, r3, #1
  00140	e2633000	 rsb         r3, r3, #0
  00144	e0603583	 rsb         r3, r0, r3, lsl #11
  00148	e59d1008	 ldr         r1, [sp, #8]
  0014c	e0832002	 add         r2, r3, r2
  00150	e38e3001	 orr         r3, lr, #1
  00154		 |$LN14@RowIncr|
  00154	e0423003	 sub         r3, r2, r3
  00158		 |$LN13@RowIncr|
  00158	e0020193	 mul         r2, r3, r1
  0015c	e2820001	 add         r0, r2, #1
  00160		 |$LN5@RowIncr|

; 564  :     }
; 565  :     
; 566  :     return dwRowIncr;
; 567  : }

  00160	e28dd040	 add         sp, sp, #0x40
  00164	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00168	e12fff1e	 bx          lr
  0016c		 |$M38135|

			 ENDP  ; |?RowIncr@OMAPVrfbSurface@@UAAKW4OMAP_DSS_ROTATION@@H@Z|, OMAPVrfbSurface::RowIncr


  00000			 AREA	 |.pdata|, PDATA
|$T38148| DCD	|$LN7@SetOrienta|
	DCD	0x40003102
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetOrientation@OMAPVrfbSurface@@UAAHW4OMAP_SURF_ORIENTATION@@@Z| PROC ; OMAPVrfbSurface::SetOrientation

; 575  : {

  00000		 |$LN7@SetOrienta|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd048	 sub         sp, sp, #0x48
  00008		 |$M38145|
  00008	e1a06001	 mov         r6, r1
  0000c	e1a05000	 mov         r5, r0

; 576  :     VRFB_VIEW_INFO  info;                
; 577  : 
; 578  :     //  Do nothing if orientation is the same
; 579  :     if( eOrientation == m_eOrientation )

  00010	e595300c	 ldr         r3, [r5, #0xC]
  00014	e1560003	 cmp         r6, r3

; 580  :         return TRUE;

  00018	0a000025	 beq         |$LN1@SetOrienta|

; 581  : 
; 582  : 
; 583  :     //  Get the current configuration
; 584  :     VRFBGetViewInfo( m_hVRFB, m_hVRFBView, &info );

  0001c	e59510ac	 ldr         r1, [r5, #0xAC]
  00020	e59500a8	 ldr         r0, [r5, #0xA8]
  00024	e28d2008	 add         r2, sp, #8
  00028	eb000000	 bl          VRFBGetViewInfo

; 585  :     
; 586  :     //  Reconfigure the VRFB view for the new orientation
; 587  :     //  by swapping width and height values
; 588  :     VRFBUpdateView( m_hVRFB, m_hVRFBView, info.dwPixelSize, info.dwHeight, info.dwWidth, 0 );

  0002c	e59de014	 ldr         lr, [sp, #0x14]
  00030	e59d3018	 ldr         r3, [sp, #0x18]
  00034	e59d200c	 ldr         r2, [sp, #0xC]
  00038	e59510ac	 ldr         r1, [r5, #0xAC]
  0003c	e59500a8	 ldr         r0, [r5, #0xA8]
  00040	e3a04000	 mov         r4, #0
  00044	e58de000	 str         lr, [sp]
  00048	e58d4004	 str         r4, [sp, #4]
  0004c	eb000000	 bl          VRFBUpdateView

; 589  : 
; 590  :     //  Get the new VRFB configuration
; 591  :     VRFBGetViewInfo( m_hVRFB, m_hVRFBView, &info );

  00050	e59510ac	 ldr         r1, [r5, #0xAC]
  00054	e59500a8	 ldr         r0, [r5, #0xA8]
  00058	e28d2008	 add         r2, sp, #8
  0005c	eb000000	 bl          VRFBGetViewInfo

; 592  :     
; 593  :         
; 594  :     //  Update surface parameters
; 595  :     m_eOrientation   = eOrientation;
; 596  :     m_dwWidth        = info.dwWidth;
; 597  :     m_dwHeight       = info.dwHeight;
; 598  : 
; 599  :     //  Reset clipping rect
; 600  :     SetClipping( NULL );

  00060	e5953000	 ldr         r3, [r5]
  00064	e59d2014	 ldr         r2, [sp, #0x14]
  00068	e59d4018	 ldr         r4, [sp, #0x18]
  0006c	e5933020	 ldr         r3, [r3, #0x20]
  00070	e5852010	 str         r2, [r5, #0x10]
  00074	e5854014	 str         r4, [r5, #0x14]
  00078	e3a01000	 mov         r1, #0
  0007c	e1a00005	 mov         r0, r5
  00080	e585600c	 str         r6, [r5, #0xC]
  00084	e1a0e00f	 mov         lr, pc
  00088	e12fff13	 bx          r3

; 601  : 
; 602  :     if ((m_pAssocSurface) && (m_eSurfaceType==OMAP_SURFACE_NORMAL))

  0008c	e59530a0	 ldr         r3, [r5, #0xA0]
  00090	e1b00003	 movs        r0, r3
  00094	0a000006	 beq         |$LN1@SetOrienta|
  00098	e595309c	 ldr         r3, [r5, #0x9C]
  0009c	e3530000	 cmp         r3, #0

; 603  :         m_pAssocSurface->SetOrientation(eOrientation);

  000a0	05903000	 ldreq       r3, [r0]
  000a4	01a01006	 moveq       r1, r6
  000a8	05933038	 ldreq       r3, [r3, #0x38]
  000ac	01a0e00f	 moveq       lr, pc
  000b0	012fff13	 bxeq        r3
  000b4		 |$LN1@SetOrienta|

; 604  :     
; 605  :     return TRUE;

  000b4	e3a00001	 mov         r0, #1

; 606  : }

  000b8	e28dd048	 add         sp, sp, #0x48
  000bc	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000c0	e12fff1e	 bx          lr
  000c4		 |$M38146|

			 ENDP  ; |?SetOrientation@OMAPVrfbSurface@@UAAHW4OMAP_SURF_ORIENTATION@@@Z|, OMAPVrfbSurface::SetOrientation

	EXPORT	|??0OMAPVrfbSurfaceManager@@QAA@XZ|	; OMAPVrfbSurfaceManager::OMAPVrfbSurfaceManager
	EXPORT	|??_7OMAPVrfbSurfaceManager@@6B@| [ DATA ] ; OMAPVrfbSurfaceManager::`vftable'
	EXPORT	|?Initialize@OMAPVrfbSurfaceManager@@UAAHK@Z| ; OMAPVrfbSurfaceManager::Initialize
	EXPORT	|?TotalMemorySize@OMAPVrfbSurfaceManager@@UAAKXZ| ; OMAPVrfbSurfaceManager::TotalMemorySize
	EXPORT	|?FreeMemorySize@OMAPVrfbSurfaceManager@@UAAKXZ| ; OMAPVrfbSurfaceManager::FreeMemorySize
	EXPORT	|?VirtualBaseAddr@OMAPVrfbSurfaceManager@@UAAPAXXZ| ; OMAPVrfbSurfaceManager::VirtualBaseAddr
	EXPORT	|?NumPhysicalAddr@OMAPVrfbSurfaceManager@@UAAKXZ| ; OMAPVrfbSurfaceManager::NumPhysicalAddr
	EXPORT	|?PhysicalLen@OMAPVrfbSurfaceManager@@UAAKK@Z| ; OMAPVrfbSurfaceManager::PhysicalLen
	EXPORT	|?PhysicalAddr@OMAPVrfbSurfaceManager@@UAAKK@Z| ; OMAPVrfbSurfaceManager::PhysicalAddr
	EXPORT	|?SupportsRotation@OMAPVrfbSurfaceManager@@UAAHXZ| ; OMAPVrfbSurfaceManager::SupportsRotation
	EXPORT	|?SupportsOffscreenSurfaces@OMAPVrfbSurfaceManager@@UAAHXZ| ; OMAPVrfbSurfaceManager::SupportsOffscreenSurfaces
	EXPORT	|?Allocate@OMAPVrfbSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@PAV3@@Z| ; OMAPVrfbSurfaceManager::Allocate
	EXPORT	|?Allocate@OMAPVrfbSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@@Z| ; OMAPVrfbSurfaceManager::Allocate
	EXPORT	|?AllocateGDI@OMAPVrfbSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@@Z| ; OMAPVrfbSurfaceManager::AllocateGDI
	IMPORT	|??_EOMAPVrfbSurfaceManager@@UAAPAXI@Z|, WEAK |??_GOMAPVrfbSurfaceManager@@UAAPAXI@Z| ; OMAPVrfbSurfaceManager::`vector deleting destructor', OMAPVrfbSurfaceManager::`scalar deleting destructor'
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\inc\dssai.h

  00000			 AREA	 |.pdata|, PDATA
|$T38161| DCD	|$LN7@OMAPVrfbSu@3|
	DCD	0x40000d00

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7OMAPVrfbSurfaceManager@@6B@| DCD |??_EOMAPVrfbSurfaceManager@@UAAPAXI@Z| ; OMAPVrfbSurfaceManager::`vftable'
	DCD	|?Initialize@OMAPVrfbSurfaceManager@@UAAHK@Z|
	DCD	|?TotalMemorySize@OMAPVrfbSurfaceManager@@UAAKXZ|
	DCD	|?FreeMemorySize@OMAPVrfbSurfaceManager@@UAAKXZ|
	DCD	|?VirtualBaseAddr@OMAPVrfbSurfaceManager@@UAAPAXXZ|
	DCD	|?NumPhysicalAddr@OMAPVrfbSurfaceManager@@UAAKXZ|
	DCD	|?PhysicalLen@OMAPVrfbSurfaceManager@@UAAKK@Z|
	DCD	|?PhysicalAddr@OMAPVrfbSurfaceManager@@UAAKK@Z|
	DCD	|?SupportsRotation@OMAPVrfbSurfaceManager@@UAAHXZ|
	DCD	|?SupportsOffscreenSurfaces@OMAPVrfbSurfaceManager@@UAAHXZ|
	DCD	|?Allocate@OMAPVrfbSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@PAV3@@Z|
	DCD	|?Allocate@OMAPVrfbSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@@Z|
	DCD	|?AllocateGDI@OMAPVrfbSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@@Z|
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\surfmgr_vrfb.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0OMAPVrfbSurfaceManager@@QAA@XZ| PROC ; OMAPVrfbSurfaceManager::OMAPVrfbSurfaceManager

; 610  : {

  00000		 |$LN7@OMAPVrfbSu@3|
  00000		 |$M38158|
  00000	e59f3028	 ldr         r3, [pc, #0x28]

; 611  :     //  Initialize properties
; 612  :     m_hHeap = NULL;

  00004	e3a02000	 mov         r2, #0
  00008	e5802004	 str         r2, [r0, #4]
  0000c	e5803000	 str         r3, [r0]

; 613  :     m_dwDisplayBufferSize = 0;

  00010	e5802008	 str         r2, [r0, #8]

; 614  :     m_dwPhysicalDisplayAddr = 0;

  00014	e580200c	 str         r2, [r0, #0xC]

; 615  :     
; 616  :     m_hVRFB = NULL;

  00018	e5802010	 str         r2, [r0, #0x10]

; 617  : 
; 618  :     m_hOffscreenHeapPA = NULL;

  0001c	e5802014	 str         r2, [r0, #0x14]

; 619  :     m_hOffscreenHeapVA = NULL;

  00020	e5802018	 str         r2, [r0, #0x18]

; 620  :     m_pOffscreenBuffer = NULL;

  00024	e580201c	 str         r2, [r0, #0x1C]

; 621  :     m_dwOffscreenPhysical = 0;

  00028	e5802020	 str         r2, [r0, #0x20]

; 622  : }

  0002c	e12fff1e	 bx          lr
  00030		 |$LN8@OMAPVrfbSu@3|
  00030		 |$LN9@OMAPVrfbSu@3|
  00030	00000000	 DCD         |??_7OMAPVrfbSurfaceManager@@6B@|
  00034		 |$M38159|

			 ENDP  ; |??0OMAPVrfbSurfaceManager@@QAA@XZ|, OMAPVrfbSurfaceManager::OMAPVrfbSurfaceManager

; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\inc\dssai.h

  00000			 AREA	 |.pdata|, PDATA
|$T38172| DCD	|$LN5@SupportsRo|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SupportsRotation@OMAPVrfbSurfaceManager@@UAAHXZ| PROC ; OMAPVrfbSurfaceManager::SupportsRotation

; 1450 :     BOOL        SupportsRotation() { return TRUE; }

  00000		 |$LN5@SupportsRo|
  00000		 |$M38169|
  00000	e3a00001	 mov         r0, #1
  00004	e12fff1e	 bx          lr
  00008		 |$M38170|

			 ENDP  ; |?SupportsRotation@OMAPVrfbSurfaceManager@@UAAHXZ|, OMAPVrfbSurfaceManager::SupportsRotation

	EXPORT	|??1OMAPVrfbSurfaceManager@@UAA@XZ|	; OMAPVrfbSurfaceManager::~OMAPVrfbSurfaceManager
	IMPORT	|VirtualFree|

  00000			 AREA	 |.pdata|, PDATA
|$T38192| DCD	|$LN14@OMAPVrfbSu@4|
	DCD	0x40002301
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\surfmgr_vrfb.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1OMAPVrfbSurfaceManager@@UAA@XZ| PROC ; OMAPVrfbSurfaceManager::~OMAPVrfbSurfaceManager

; 626  : {

  00000		 |$LN14@OMAPVrfbSu@4|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M38189|
  00004	e1a04000	 mov         r4, r0
  00008	e59f3078	 ldr         r3, [pc, #0x78]

; 627  :     Heap*   pHeap = (Heap*) m_hHeap;
; 628  :     Heap*   pOffscreenHeapVA = (Heap*) m_hOffscreenHeapVA;
; 629  :     Heap*   pOffscreenHeapPA = (Heap*) m_hOffscreenHeapPA;
; 630  :     
; 631  :     //  Free the VRFB manager
; 632  :     if( m_hVRFB )

  0000c	e5942010	 ldr         r2, [r4, #0x10]
  00010	e5947004	 ldr         r7, [r4, #4]
  00014	e5945018	 ldr         r5, [r4, #0x18]
  00018	e5946014	 ldr         r6, [r4, #0x14]
  0001c	e5843000	 str         r3, [r4]
  00020	e1b08002	 movs        r8, r2
  00024	0a000003	 beq         |$LN8@OMAPVrfbSu@4|

; 633  :         VRFBClose( m_hVRFB );

  00028	e5980024	 ldr         r0, [r8, #0x24]
  0002c	eb000000	 bl          CloseHandle
  00030	e1a00008	 mov         r0, r8
  00034	eb000000	 bl          LocalFree
  00038		 |$LN8@OMAPVrfbSu@4|

; 634  :         
; 635  :     //  Free the heap manager
; 636  :     if( pHeap )

  00038	e3570000	 cmp         r7, #0

; 637  :         pHeap->Free();

  0003c	11a00007	 movne       r0, r7
  00040	1b000000	 blne        |?Free@Heap@@QAAXXZ|

; 638  : 
; 639  :     //  Free the offscreen virtual address heap manager
; 640  :     if( pOffscreenHeapVA )

  00044	e3550000	 cmp         r5, #0

; 641  :         pOffscreenHeapVA->Free();

  00048	11a00005	 movne       r0, r5
  0004c	1b000000	 blne        |?Free@Heap@@QAAXXZ|

; 642  :         
; 643  :     //  Free offscreen memory
; 644  :     if( m_pOffscreenBuffer ) 

  00050	e594301c	 ldr         r3, [r4, #0x1C]
  00054	e3530000	 cmp         r3, #0

; 645  :         VirtualFree( m_pOffscreenBuffer, 0, MEM_RELEASE );

  00058	13a02902	 movne       r2, #2, 18
  0005c	13a01000	 movne       r1, #0
  00060	11a00003	 movne       r0, r3
  00064	1b000000	 blne        VirtualFree

; 646  : 
; 647  :     //  Free the offscreen physical address heap manager
; 648  :     if( pOffscreenHeapPA )

  00068	e3560000	 cmp         r6, #0

; 649  :         pOffscreenHeapPA->Free();

  0006c	11a00006	 movne       r0, r6
  00070	1b000000	 blne        |?Free@Heap@@QAAXXZ|

; 650  :        
; 651  : }

  00074	e59f3008	 ldr         r3, [pc, #8]
  00078	e5843000	 str         r3, [r4]
  0007c	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00080	e12fff1e	 bx          lr
  00084		 |$LN15@OMAPVrfbSu@4|
  00084		 |$LN16@OMAPVrfbSu@4|
  00084	00000000	 DCD         |??_7OMAPSurfaceManager@@6B@|
  00088		 |$LN17@OMAPVrfbSu@4|
  00088	00000000	 DCD         |??_7OMAPVrfbSurfaceManager@@6B@|
  0008c		 |$M38190|

			 ENDP  ; |??1OMAPVrfbSurfaceManager@@UAA@XZ|, OMAPVrfbSurfaceManager::~OMAPVrfbSurfaceManager

	EXPORT	|??_GHeap@@QAAPAXI@Z|			; Heap::`scalar deleting destructor'
	IMPORT	|??1Heap@@QAA@XZ|			; Heap::~Heap

  00000			 AREA	 |.pdata|, PDATA
|$T38206| DCD	|$LN6@scalar@3|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GHeap@@QAAPAXI@Z| PROC		; Heap::`scalar deleting destructor'
  00000		 |$LN6@scalar@3|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M38203|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          |??1Heap@@QAA@XZ|
  00010	e3140001	 tst         r4, #1
  00014	11a00005	 movne       r0, r5
  00018	1b000000	 blne        |??3@YAXPAX@Z|
  0001c	e1a00005	 mov         r0, r5
  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M38204|

			 ENDP  ; |??_GHeap@@QAAPAXI@Z|, Heap::`scalar deleting destructor'


  00000			 AREA	 |.pdata|, PDATA
|$T38216| DCD	|$LN5@TotalMemor|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TotalMemorySize@OMAPVrfbSurfaceManager@@UAAKXZ| PROC ; OMAPVrfbSurfaceManager::TotalMemorySize

; 779  : {

  00000		 |$LN5@TotalMemor|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38213|

; 780  :     DWORD   dwSize;
; 781  :     
; 782  :     //  Return total display virtual memory size
; 783  :     //  This will be the number of VRFB views times the size of each view
; 784  : 
; 785  :     dwSize = VRFBNumDisplayViews(m_hVRFB) * VRFB_VIEW_SIZE; 

  00004	e5900010	 ldr         r0, [r0, #0x10]
  00008	eb000000	 bl          VRFBNumDisplayViews
  0000c	e1a00c00	 mov         r0, r0, lsl #24

; 786  :     
; 787  :     return dwSize;
; 788  : }

  00010	e49de004	 ldr         lr, [sp], #4
  00014	e12fff1e	 bx          lr
  00018		 |$M38214|

			 ENDP  ; |?TotalMemorySize@OMAPVrfbSurfaceManager@@UAAKXZ|, OMAPVrfbSurfaceManager::TotalMemorySize

	IMPORT	|?TotalFree@Heap@@QAAKXZ|		; Heap::TotalFree

  00000			 AREA	 |.pdata|, PDATA
|$T38227| DCD	|$LN5@FreeMemory|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FreeMemorySize@OMAPVrfbSurfaceManager@@UAAKXZ| PROC ; OMAPVrfbSurfaceManager::FreeMemorySize

; 793  : {

  00000		 |$LN5@FreeMemory|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38224|

; 794  :     Heap*   pHeap = (Heap*) m_hHeap;

  00004	e5900004	 ldr         r0, [r0, #4]

; 795  : 
; 796  :     //  Return free memory of heap
; 797  :     return pHeap->TotalFree();

  00008	eb000000	 bl          |?TotalFree@Heap@@QAAKXZ|

; 798  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M38225|

			 ENDP  ; |?FreeMemorySize@OMAPVrfbSurfaceManager@@UAAKXZ|, OMAPVrfbSurfaceManager::FreeMemorySize


  00000			 AREA	 |.pdata|, PDATA
|$T38239| DCD	|$LN9@VirtualBas|
	DCD	0x40001202
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?VirtualBaseAddr@OMAPVrfbSurfaceManager@@UAAPAXXZ| PROC ; OMAPVrfbSurfaceManager::VirtualBaseAddr

; 803  : {

  00000		 |$LN9@VirtualBas|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd040	 sub         sp, sp, #0x40
  00008		 |$M38236|
  00008	e1a05000	 mov         r5, r0

; 804  :     VOID*           pAddr = NULL;
; 805  :     HANDLE          hView;
; 806  :     BOOL            bResult;    
; 807  :     VRFB_VIEW_INFO  info;
; 808  : 
; 809  : 
; 810  :     //  Get the base address of the primary display view
; 811  :     hView = VRFBGetDisplayView( m_hVRFB, 0 );

  0000c	e5950010	 ldr         r0, [r5, #0x10]
  00010	e3a01000	 mov         r1, #0
  00014	e3a04000	 mov         r4, #0
  00018	eb000000	 bl          VRFBGetDisplayView
  0001c	e1b01000	 movs        r1, r0

; 812  :     if( hView == NULL )

  00020	0a000004	 beq         |$cleanUp$37519|

; 813  :     {
; 814  :         goto cleanUp;
; 815  :     }
; 816  :     
; 817  :     //  Get the view info
; 818  :     bResult = VRFBGetViewInfo( m_hVRFB, hView, &info);

  00024	e5950010	 ldr         r0, [r5, #0x10]
  00028	e28d2000	 add         r2, sp, #0
  0002c	eb000000	 bl          VRFBGetViewInfo
  00030	e3500000	 cmp         r0, #0

; 819  :     if( bResult == FALSE )
; 820  :     {
; 821  :         goto cleanUp;
; 822  :     }
; 823  :     
; 824  :     //  Get the virtual address of the primary view
; 825  :     pAddr = (VOID*) info.dwVirtualAddr;

  00034	159d4030	 ldrne       r4, [sp, #0x30]
  00038		 |$cleanUp$37519|

; 826  :     
; 827  :     
; 828  : cleanUp:    
; 829  :     //  Return base address of display memory
; 830  :     return pAddr;
; 831  : }

  00038	e1a00004	 mov         r0, r4
  0003c	e28dd040	 add         sp, sp, #0x40
  00040	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$M38237|

			 ENDP  ; |?VirtualBaseAddr@OMAPVrfbSurfaceManager@@UAAPAXXZ|, OMAPVrfbSurfaceManager::VirtualBaseAddr


  00000			 AREA	 |.pdata|, PDATA
|$T38249| DCD	|$LN5@NumPhysica|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?NumPhysicalAddr@OMAPVrfbSurfaceManager@@UAAKXZ| PROC ; OMAPVrfbSurfaceManager::NumPhysicalAddr

; 836  : {

  00000		 |$LN5@NumPhysica|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38246|

; 837  :     //  Each view maps to a VRFB physical address
; 838  :     return VRFBNumDisplayViews( m_hVRFB );

  00004	e5900010	 ldr         r0, [r0, #0x10]
  00008	eb000000	 bl          VRFBNumDisplayViews

; 839  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M38247|

			 ENDP  ; |?NumPhysicalAddr@OMAPVrfbSurfaceManager@@UAAKXZ|, OMAPVrfbSurfaceManager::NumPhysicalAddr


  00000			 AREA	 |.pdata|, PDATA
|$T38260| DCD	|$LN6@PhysicalLe|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PhysicalLen@OMAPVrfbSurfaceManager@@UAAKK@Z| PROC ; OMAPVrfbSurfaceManager::PhysicalLen

; 844  : {

  00000		 |$LN6@PhysicalLe|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M38257|
  00004	e1a04001	 mov         r4, r1

; 845  :     //  Check index
; 846  :     if( dwIndex < VRFBNumDisplayViews(m_hVRFB))

  00008	e5900010	 ldr         r0, [r0, #0x10]
  0000c	eb000000	 bl          VRFBNumDisplayViews
  00010	e1540000	 cmp         r4, r0

; 847  :     {
; 848  :         //  All VRFB views are the same length in physical memory
; 849  :         return VRFB_VIEW_SIZE;

  00014	33a00401	 movcc       r0, #1, 8

; 854  : }

  00018	38bd4010	 ldmccia     sp!, {r4, lr}

; 850  :     }
; 851  :     
; 852  :     //  Invalid index
; 853  :     return 0;

  0001c	23a00000	 movcs       r0, #0

; 854  : }

  00020	28bd4010	 ldmcsia     sp!, {r4, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M38258|

			 ENDP  ; |?PhysicalLen@OMAPVrfbSurfaceManager@@UAAKK@Z|, OMAPVrfbSurfaceManager::PhysicalLen


  00000			 AREA	 |.pdata|, PDATA
|$T38273| DCD	|$LN9@PhysicalAd@2|
	DCD	0x40001102
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PhysicalAddr@OMAPVrfbSurfaceManager@@UAAKK@Z| PROC ; OMAPVrfbSurfaceManager::PhysicalAddr

; 859  : {

  00000		 |$LN9@PhysicalAd@2|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd040	 sub         sp, sp, #0x40
  00008		 |$M38270|
  00008	e1a05000	 mov         r5, r0

; 860  :     DWORD           dwAddr = 0;
; 861  :     HANDLE          hView;
; 862  :     BOOL            bResult;    
; 863  :     VRFB_VIEW_INFO  info;
; 864  : 
; 865  : 
; 866  :     //  Get the selected display view
; 867  :     hView = VRFBGetDisplayView( m_hVRFB, dwIndex );

  0000c	e5950010	 ldr         r0, [r5, #0x10]
  00010	e3a04000	 mov         r4, #0
  00014	eb000000	 bl          VRFBGetDisplayView
  00018	e1b01000	 movs        r1, r0

; 868  :     if( hView == NULL )

  0001c	0a000004	 beq         |$cleanUp$37542|

; 869  :     {
; 870  :         goto cleanUp;
; 871  :     }
; 872  :     
; 873  :     //  Get the view info
; 874  :     bResult = VRFBGetViewInfo( m_hVRFB, hView, &info);

  00020	e5950010	 ldr         r0, [r5, #0x10]
  00024	e28d2000	 add         r2, sp, #0
  00028	eb000000	 bl          VRFBGetViewInfo
  0002c	e3500000	 cmp         r0, #0

; 875  :     if( bResult == FALSE )
; 876  :     {
; 877  :         goto cleanUp;
; 878  :     }
; 879  :     
; 880  :     //  Get the physical address of the view
; 881  :     dwAddr = info.dwPhysicalAddrInput;

  00030	159d4034	 ldrne       r4, [sp, #0x34]
  00034		 |$cleanUp$37542|

; 882  :     
; 883  :     
; 884  : cleanUp:    
; 885  :     //  Return physical address of VRFB view
; 886  :     return dwAddr;
; 887  : }

  00034	e1a00004	 mov         r0, r4
  00038	e28dd040	 add         sp, sp, #0x40
  0003c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M38271|

			 ENDP  ; |?PhysicalAddr@OMAPVrfbSurfaceManager@@UAAKK@Z|, OMAPVrfbSurfaceManager::PhysicalAddr


  00000			 AREA	 |.pdata|, PDATA
|$T38285| DCD	|$LN7@SupportsOf|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SupportsOffscreenSurfaces@OMAPVrfbSurfaceManager@@UAAHXZ| PROC ; OMAPVrfbSurfaceManager::SupportsOffscreenSurfaces

; 892  : {

  00000		 |$LN7@SupportsOf|
  00000		 |$M38282|

; 893  :     //  If offscreen heap allocated, return TRUE
; 894  :     return( m_hOffscreenHeapVA != NULL );

  00000	e5903018	 ldr         r3, [r0, #0x18]
  00004	e3530000	 cmp         r3, #0
  00008	13a00001	 movne       r0, #1
  0000c	03a00000	 moveq       r0, #0

; 895  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M38283|

			 ENDP  ; |?SupportsOffscreenSurfaces@OMAPVrfbSurfaceManager@@UAAHXZ|, OMAPVrfbSurfaceManager::SupportsOffscreenSurfaces

	IMPORT	|??2@YAPAXI@Z|				; operator new
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\inc\dssai.h

  00000			 AREA	 |.pdata|, PDATA
|$T38322| DCD	|$LN24@Allocate@2|
	DCD	0x40003d02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\surfmgr_vrfb.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Allocate@OMAPVrfbSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@@Z| PROC ; OMAPVrfbSurfaceManager::Allocate

; 905  : {

  00000		 |$LN24@Allocate@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M38319|
  00008	e1a07003	 mov         r7, r3
  0000c	e1a08002	 mov         r8, r2
  00010	e1a09001	 mov         r9, r1
  00014	e1a06000	 mov         r6, r0

; 906  :     BOOL            bResult;
; 907  :     OMAPVrfbSurface *pVrfbSurface;
; 908  :     Heap*           pHeap = (Heap*) m_hHeap;
; 909  :     
; 910  :     //  Check return pointer
; 911  :     if( ppSurface == NULL )

  00018	e59d502c	 ldr         r5, [sp, #0x2C]
  0001c	e596a004	 ldr         r10, [r6, #4]
  00020	e3550000	 cmp         r5, #0
  00024	0a00002d	 beq         |$LN21@Allocate@2|

; 912  :         goto cleanUp;    
; 913  :     
; 914  :     //  Initialize return pointer
; 915  :     *ppSurface = NULL;

  00028	e3a0b000	 mov         r11, #0

; 916  : 
; 917  :     //  Allocate a new flat surface object
; 918  :     pVrfbSurface = new OMAPVrfbSurface;

  0002c	e3a000b8	 mov         r0, #0xB8
  00030	e585b000	 str         r11, [r5]
  00034	eb000000	 bl          |??2@YAPAXI@Z|
  00038	e1b04000	 movs        r4, r0
  0003c	0a00000e	 beq         |$LN9@Allocate@2|
  00040	e59fe0a8	 ldr         lr, [pc, #0xA8]
  00044	e3e03000	 mvn         r3, #0
  00048	e3a02001	 mov         r2, #1
  0004c	e584e000	 str         lr, [r4]
  00050	e584b0a4	 str         r11, [r4, #0xA4]
  00054	e584b0a8	 str         r11, [r4, #0xA8]
  00058	e584b0ac	 str         r11, [r4, #0xAC]
  0005c	e58430b0	 str         r3, [r4, #0xB0]
  00060	e58420b4	 str         r2, [r4, #0xB4]
  00064	e5842028	 str         r2, [r4, #0x28]
  00068	e584202c	 str         r2, [r4, #0x2C]
  0006c	e584b030	 str         r11, [r4, #0x30]
  00070	e584b0a0	 str         r11, [r4, #0xA0]
  00074	e584b09c	 str         r11, [r4, #0x9C]
  00078	ea000000	 b           |$LN10@Allocate@2|
  0007c		 |$LN9@Allocate@2|
  0007c	e3a04000	 mov         r4, #0
  00080		 |$LN10@Allocate@2|

; 919  :     if( pVrfbSurface == NULL )

  00080	e3540000	 cmp         r4, #0
  00084	0a000011	 beq         |$LN15@Allocate@2|

; 920  :     {
; 921  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to create OMAPVrfbSurface\n"));
; 922  :         goto cleanUp;
; 923  :     }
; 924  : 
; 925  :     //  Allocate the memory for the surface
; 926  :     bResult = pVrfbSurface->Allocate(
; 927  :                                 ePixelFormat,
; 928  :                                 dwWidth,
; 929  :                                 dwHeight,
; 930  :                                 pHeap,
; 931  :                                 m_hVRFB );

  00088	e5961010	 ldr         r1, [r6, #0x10]
  0008c	e1a03007	 mov         r3, r7
  00090	e1a02008	 mov         r2, r8
  00094	e58d1004	 str         r1, [sp, #4]
  00098	e1a01009	 mov         r1, r9
  0009c	e1a00004	 mov         r0, r4
  000a0	e58da000	 str         r10, [sp]
  000a4	eb000000	 bl          |?Allocate@OMAPVrfbSurface@@QAAHW4OMAP_DSS_PIXELFORMAT@@KKPAX1@Z|
  000a8	e3500000	 cmp         r0, #0

; 932  :     if( bResult == FALSE )

  000ac	1a000006	 bne         |$LN2@Allocate@2|

; 933  :     {
; 934  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to allocate OMAPVrfbSurface memory\n"));
; 935  :         delete pVrfbSurface;

  000b0	e5943000	 ldr         r3, [r4]
  000b4	e3a01001	 mov         r1, #1
  000b8	e1a00004	 mov         r0, r4
  000bc	e5933000	 ldr         r3, [r3]
  000c0	e1a0e00f	 mov         lr, pc
  000c4	e12fff13	 bx          r3

; 936  :         goto cleanUp;

  000c8	ea000000	 b           |$LN15@Allocate@2|
  000cc		 |$LN2@Allocate@2|

; 937  :     }
; 938  : 
; 939  :     //  Return the new surface
; 940  :     *ppSurface = pVrfbSurface;            

  000cc	e5854000	 str         r4, [r5]
  000d0		 |$cleanUp$37561|
  000d0		 |$LN15@Allocate@2|

; 941  :     
; 942  : cleanUp:    
; 943  :     //  Return result
; 944  :     return (ppSurface == NULL) ? FALSE : (*ppSurface != NULL);

  000d0	e5953000	 ldr         r3, [r5]
  000d4	e3530000	 cmp         r3, #0
  000d8	13a00001	 movne       r0, #1
  000dc	1a000000	 bne         |$LN14@Allocate@2|
  000e0		 |$LN21@Allocate@2|
  000e0	e3a00000	 mov         r0, #0
  000e4		 |$LN14@Allocate@2|

; 945  : }

  000e4	e28dd008	 add         sp, sp, #8
  000e8	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  000ec	e12fff1e	 bx          lr
  000f0		 |$LN25@Allocate@2|
  000f0		 |$LN26@Allocate@2|
  000f0	00000000	 DCD         |??_7OMAPVrfbSurface@@6B@|
  000f4		 |$M38320|

			 ENDP  ; |?Allocate@OMAPVrfbSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@@Z|, OMAPVrfbSurfaceManager::Allocate

	IMPORT	|?SetAssocSurface@OMAPSurface@@QAAHPAV1@@Z| ; OMAPSurface::SetAssocSurface
	IMPORT	|?SetSurfaceType@OMAPSurface@@QAAHW4OMAP_SURFACE_TYPE@@@Z| ; OMAPSurface::SetSurfaceType
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\inc\dssai.h

  00000			 AREA	 |.pdata|, PDATA
|$T38362| DCD	|$LN24@Allocate@3|
	DCD	0x40004402
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\surfmgr_vrfb.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Allocate@OMAPVrfbSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@PAV3@@Z| PROC ; OMAPVrfbSurfaceManager::Allocate

; 955  : {

  00000		 |$LN24@Allocate@3|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M38359|
  00008	e1a07003	 mov         r7, r3
  0000c	e1a08002	 mov         r8, r2
  00010	e1a09001	 mov         r9, r1
  00014	e1a06000	 mov         r6, r0

; 956  : 	BOOL            bResult;
; 957  :     OMAPVrfbSurface *pVrfbSurface;
; 958  :     Heap*           pHeap = (Heap*) m_hHeap;
; 959  :     
; 960  :     //  Check return pointer
; 961  :     if( ppAssocSurface == NULL )

  00018	e59d502c	 ldr         r5, [sp, #0x2C]
  0001c	e596a004	 ldr         r10, [r6, #4]
  00020	e3550000	 cmp         r5, #0
  00024	0a000034	 beq         |$LN21@Allocate@3|

; 962  :         goto cleanUp;    
; 963  :     
; 964  :     //  Initialize return pointer
; 965  :     *ppAssocSurface = NULL;

  00028	e3a0b000	 mov         r11, #0

; 966  : 
; 967  :     //  Allocate a new flat surface object
; 968  :     pVrfbSurface = new OMAPVrfbSurface;

  0002c	e3a000b8	 mov         r0, #0xB8
  00030	e585b000	 str         r11, [r5]
  00034	eb000000	 bl          |??2@YAPAXI@Z|
  00038	e1b04000	 movs        r4, r0
  0003c	0a00000e	 beq         |$LN9@Allocate@3|
  00040	e59fe0c4	 ldr         lr, [pc, #0xC4]
  00044	e3e03000	 mvn         r3, #0
  00048	e3a02001	 mov         r2, #1
  0004c	e584e000	 str         lr, [r4]
  00050	e584b0a4	 str         r11, [r4, #0xA4]
  00054	e584b0a8	 str         r11, [r4, #0xA8]
  00058	e584b0ac	 str         r11, [r4, #0xAC]
  0005c	e58430b0	 str         r3, [r4, #0xB0]
  00060	e58420b4	 str         r2, [r4, #0xB4]
  00064	e5842028	 str         r2, [r4, #0x28]
  00068	e584202c	 str         r2, [r4, #0x2C]
  0006c	e584b030	 str         r11, [r4, #0x30]
  00070	e584b0a0	 str         r11, [r4, #0xA0]
  00074	e584b09c	 str         r11, [r4, #0x9C]
  00078	ea000000	 b           |$LN10@Allocate@3|
  0007c		 |$LN9@Allocate@3|
  0007c	e3a04000	 mov         r4, #0
  00080		 |$LN10@Allocate@3|

; 969  :     if( pVrfbSurface == NULL )

  00080	e3540000	 cmp         r4, #0
  00084	0a000018	 beq         |$LN15@Allocate@3|

; 970  :     {
; 971  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to create OMAPVrfbSurface\n"));
; 972  :         goto cleanUp;
; 973  :     }
; 974  : 
; 975  :     //  Allocate the memory for the surface
; 976  :     bResult = pVrfbSurface->Allocate(
; 977  :                                 ePixelFormat,
; 978  :                                 dwWidth,
; 979  :                                 dwHeight,
; 980  :                                 pHeap,
; 981  :                                 m_hVRFB );

  00088	e5961010	 ldr         r1, [r6, #0x10]
  0008c	e1a03007	 mov         r3, r7
  00090	e1a02008	 mov         r2, r8
  00094	e58d1004	 str         r1, [sp, #4]
  00098	e1a01009	 mov         r1, r9
  0009c	e1a00004	 mov         r0, r4
  000a0	e58da000	 str         r10, [sp]
  000a4	eb000000	 bl          |?Allocate@OMAPVrfbSurface@@QAAHW4OMAP_DSS_PIXELFORMAT@@KKPAX1@Z|
  000a8	e3500000	 cmp         r0, #0

; 982  :     if( bResult == FALSE )
; 983  :     {
; 984  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to allocate OMAPVrfbSurface memory\n"));
; 985  :         delete pVrfbSurface;

  000ac	e1a00004	 mov         r0, r4
  000b0	e3a01001	 mov         r1, #1
  000b4	1a000004	 bne         |$LN2@Allocate@3|
  000b8	e5943000	 ldr         r3, [r4]
  000bc	e5933000	 ldr         r3, [r3]
  000c0	e1a0e00f	 mov         lr, pc
  000c4	e12fff13	 bx          r3

; 986  :         goto cleanUp;

  000c8	ea000007	 b           |$LN15@Allocate@3|
  000cc		 |$LN2@Allocate@3|

; 987  :     }
; 988  : 
; 989  :     pVrfbSurface->SetSurfaceType(OMAP_SURFACE_RESIZER);

  000cc	eb000000	 bl          |?SetSurfaceType@OMAPSurface@@QAAHW4OMAP_SURFACE_TYPE@@@Z|

; 990  :     pVrfbSurface->SetAssocSurface(pSurface);

  000d0	e59d1030	 ldr         r1, [sp, #0x30]
  000d4	e1a00004	 mov         r0, r4
  000d8	eb000000	 bl          |?SetAssocSurface@OMAPSurface@@QAAHPAV1@@Z|

; 991  :     pSurface->SetAssocSurface(pVrfbSurface);    

  000dc	e59d0030	 ldr         r0, [sp, #0x30]
  000e0	e1a01004	 mov         r1, r4
  000e4	eb000000	 bl          |?SetAssocSurface@OMAPSurface@@QAAHPAV1@@Z|

; 992  : 
; 993  :     //  Return the new surface
; 994  :     *ppAssocSurface = pVrfbSurface;            

  000e8	e5854000	 str         r4, [r5]
  000ec		 |$cleanUp$37587|
  000ec		 |$LN15@Allocate@3|

; 995  :     
; 996  : cleanUp:    
; 997  :     //  Return result
; 998  :     return (ppAssocSurface == NULL) ? FALSE : (*ppAssocSurface != NULL);

  000ec	e5953000	 ldr         r3, [r5]
  000f0	e3530000	 cmp         r3, #0
  000f4	13a00001	 movne       r0, #1
  000f8	1a000000	 bne         |$LN14@Allocate@3|
  000fc		 |$LN21@Allocate@3|
  000fc	e3a00000	 mov         r0, #0
  00100		 |$LN14@Allocate@3|

; 999  : }

  00100	e28dd008	 add         sp, sp, #8
  00104	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00108	e12fff1e	 bx          lr
  0010c		 |$LN25@Allocate@3|
  0010c		 |$LN26@Allocate@3|
  0010c	00000000	 DCD         |??_7OMAPVrfbSurface@@6B@|
  00110		 |$M38360|

			 ENDP  ; |?Allocate@OMAPVrfbSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@PAV3@@Z|, OMAPVrfbSurfaceManager::Allocate

	IMPORT	|?Allocate@OMAPFlatSurface@@QAAHW4OMAP_DSS_PIXELFORMAT@@KKPAXK@Z| ; OMAPFlatSurface::Allocate
	IMPORT	|??0OMAPFlatSurface@@QAA@XZ|		; OMAPFlatSurface::OMAPFlatSurface

  00000			 AREA	 |.pdata|, PDATA
|$T38393| DCD	|$LN22@AllocateGD|
	DCD	0x40003202
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AllocateGDI@OMAPVrfbSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@@Z| PROC ; OMAPVrfbSurfaceManager::AllocateGDI

; 1009 : {

  00000		 |$LN22@AllocateGD|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M38390|
  00008	e1a08003	 mov         r8, r3
  0000c	e1a09002	 mov         r9, r2
  00010	e1a0a001	 mov         r10, r1
  00014	e1a07000	 mov         r7, r0

; 1010 :     BOOL            bResult;
; 1011 :     OMAPFlatSurface *pFlatSurface;
; 1012 :     Heap*           pHeap = (Heap*) m_hOffscreenHeapVA;
; 1013 :     
; 1014 :     //  Check return pointer
; 1015 :     if( ppSurface == NULL )

  00018	e59d5028	 ldr         r5, [sp, #0x28]
  0001c	e5976018	 ldr         r6, [r7, #0x18]
  00020	e3550000	 cmp         r5, #0
  00024	0a000023	 beq         |$LN19@AllocateGD|

; 1016 :         goto cleanUp;    
; 1017 :     
; 1018 :     //  Initialize return pointer
; 1019 :     *ppSurface = NULL;

  00028	e3a03000	 mov         r3, #0
  0002c	e5853000	 str         r3, [r5]

; 1020 : 
; 1021 :     //  Check for offscreen heap
; 1022 :     if( pHeap == NULL )

  00030	e3560000	 cmp         r6, #0
  00034	0a00001f	 beq         |$LN19@AllocateGD|

; 1023 :         goto cleanUp;
; 1024 :         
; 1025 :         
; 1026 :     //  Allocate a new flat surface object
; 1027 :     pFlatSurface = new OMAPFlatSurface;

  00038	e3a000b8	 mov         r0, #0xB8
  0003c	eb000000	 bl          |??2@YAPAXI@Z|
  00040	e3500000	 cmp         r0, #0
  00044	0a000002	 beq         |$LN11@AllocateGD|
  00048	eb000000	 bl          |??0OMAPFlatSurface@@QAA@XZ|
  0004c	e1a04000	 mov         r4, r0
  00050	ea000000	 b           |$LN12@AllocateGD|
  00054		 |$LN11@AllocateGD|
  00054	e3a04000	 mov         r4, #0
  00058		 |$LN12@AllocateGD|

; 1028 :     if( pFlatSurface == NULL )

  00058	e3540000	 cmp         r4, #0
  0005c	0a000011	 beq         |$LN17@AllocateGD|

; 1029 :     {
; 1030 :         DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to create offscreen OMAPFlatSurface\n"));
; 1031 :         goto cleanUp;
; 1032 :     }
; 1033 : 
; 1034 :     //  Allocate the memory for the offscreen surface
; 1035 :     bResult = pFlatSurface->Allocate(
; 1036 :                                 ePixelFormat,
; 1037 :                                 dwWidth,
; 1038 :                                 dwHeight,
; 1039 :                                 pHeap,
; 1040 :                                 m_dwOffscreenPhysical );

  00060	e5971020	 ldr         r1, [r7, #0x20]
  00064	e1a03008	 mov         r3, r8
  00068	e1a02009	 mov         r2, r9
  0006c	e58d1004	 str         r1, [sp, #4]
  00070	e1a0100a	 mov         r1, r10
  00074	e1a00004	 mov         r0, r4
  00078	e58d6000	 str         r6, [sp]
  0007c	eb000000	 bl          |?Allocate@OMAPFlatSurface@@QAAHW4OMAP_DSS_PIXELFORMAT@@KKPAXK@Z|
  00080	e3500000	 cmp         r0, #0

; 1041 :     if( bResult == FALSE )

  00084	1a000006	 bne         |$LN2@AllocateGD|

; 1042 :     {
; 1043 :         DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to allocate offscreen OMAPFlatSurface memory\n"));
; 1044 :         delete pFlatSurface;

  00088	e5943000	 ldr         r3, [r4]
  0008c	e3a01001	 mov         r1, #1
  00090	e1a00004	 mov         r0, r4
  00094	e5933000	 ldr         r3, [r3]
  00098	e1a0e00f	 mov         lr, pc
  0009c	e12fff13	 bx          r3

; 1051 :     
; 1052 : cleanUp:    

  000a0	ea000000	 b           |$LN17@AllocateGD|
  000a4		 |$LN2@AllocateGD|

; 1045 :         goto cleanUp;
; 1046 :     }
; 1047 : 
; 1048 :     
; 1049 :     //  Return the new surface
; 1050 :     *ppSurface = pFlatSurface;            

  000a4	e5854000	 str         r4, [r5]
  000a8		 |$cleanUp$37612|
  000a8		 |$LN17@AllocateGD|

; 1053 :     //  Return result
; 1054 :     return (ppSurface == NULL) ? FALSE : (*ppSurface != NULL);

  000a8	e5953000	 ldr         r3, [r5]
  000ac	e3530000	 cmp         r3, #0
  000b0	13a00001	 movne       r0, #1
  000b4	1a000000	 bne         |$LN16@AllocateGD|
  000b8		 |$LN19@AllocateGD|
  000b8	e3a00000	 mov         r0, #0
  000bc		 |$LN16@AllocateGD|

; 1055 : }

  000bc	e28dd008	 add         sp, sp, #8
  000c0	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  000c4	e12fff1e	 bx          lr
  000c8		 |$M38391|

			 ENDP  ; |?AllocateGDI@OMAPVrfbSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@@Z|, OMAPVrfbSurfaceManager::AllocateGDI


  00000			 AREA	 |.pdata|, PDATA
|$T38404| DCD	|$LN6@scalar@4|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GOMAPVrfbSurface@@UAAPAXI@Z| PROC	; OMAPVrfbSurface::`scalar deleting destructor'
  00000		 |$LN6@scalar@4|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M38401|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          |??1OMAPVrfbSurface@@UAA@XZ|
  00010	e3140001	 tst         r4, #1
  00014	11a00005	 movne       r0, r5
  00018	1b000000	 blne        |??3@YAXPAX@Z|
  0001c	e1a00005	 mov         r0, r5
  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M38402|

			 ENDP  ; |??_GOMAPVrfbSurface@@UAAPAXI@Z|, OMAPVrfbSurface::`scalar deleting destructor'


  00000			 AREA	 |.pdata|, PDATA
|$T38415| DCD	|$LN6@scalar@5|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GOMAPVrfbSurfaceManager@@UAAPAXI@Z| PROC ; OMAPVrfbSurfaceManager::`scalar deleting destructor'
  00000		 |$LN6@scalar@5|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M38412|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          |??1OMAPVrfbSurfaceManager@@UAA@XZ|
  00010	e3140001	 tst         r4, #1
  00014	11a00005	 movne       r0, r5
  00018	1b000000	 blne        |??3@YAXPAX@Z|
  0001c	e1a00005	 mov         r0, r5
  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M38413|

			 ENDP  ; |??_GOMAPVrfbSurfaceManager@@UAAPAXI@Z|, OMAPVrfbSurfaceManager::`scalar deleting destructor'

	IMPORT	|VirtualCopy|
	IMPORT	|VirtualAlloc|
	IMPORT	|??0Heap@@QAA@KKPAV0@0@Z|		; Heap::Heap
	IMPORT	|LcdPdd_GetMemory|

  00000			 AREA	 |.pdata|, PDATA
|$T38490| DCD	|$LN59@Initialize|
	DCD	0x40006c02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Initialize@OMAPVrfbSurfaceManager@@UAAHK@Z| PROC ; OMAPVrfbSurfaceManager::Initialize

; 658  : {

  00000		 |$LN59@Initialize|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M38487|
  00008	e1a06001	 mov         r6, r1
  0000c	e1a04000	 mov         r4, r0

; 659  :     BOOL    bResult = FALSE;
; 660  :     Heap*   pHeap;
; 661  :     DWORD   dwNumDisplayViews;
; 662  :     
; 663  :     
; 664  :     //  Get video memory attributes from LCD PDD
; 665  :     bResult = LcdPdd_GetMemory( &m_dwDisplayBufferSize, &m_dwPhysicalDisplayAddr );

  00010	e284100c	 add         r1, r4, #0xC
  00014	e2840008	 add         r0, r4, #8
  00018	eb000000	 bl          LcdPdd_GetMemory
  0001c	e1b07000	 movs        r7, r0

; 666  :     if( !bResult )

  00020	0a00005e	 beq         |$cleanUp$37446|

; 667  :     {
; 668  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to get video memory attributes\n"));
; 669  :         goto cleanUp;
; 670  :     }
; 671  : 
; 672  : 
; 673  :     //  Check that offscreen reserve is not greater that all of display memory
; 674  :     if( dwOffscreenMemory >= m_dwDisplayBufferSize )

  00024	e5943008	 ldr         r3, [r4, #8]

; 675  :         dwOffscreenMemory = 0;
; 676  : 
; 677  : 
; 678  :     //  Initialize the heap manager for the display physical memory
; 679  :     pHeap = new Heap(m_dwDisplayBufferSize, (DWORD) m_dwPhysicalDisplayAddr);

  00028	e3a00014	 mov         r0, #0x14
  0002c	e1560003	 cmp         r6, r3
  00030	23a06000	 movcs       r6, #0
  00034	eb000000	 bl          |??2@YAPAXI@Z|
  00038	e3500000	 cmp         r0, #0
  0003c	e3a08000	 mov         r8, #0
  00040	0a000005	 beq         |$LN23@Initialize|
  00044	e594200c	 ldr         r2, [r4, #0xC]
  00048	e5941008	 ldr         r1, [r4, #8]
  0004c	e3a03000	 mov         r3, #0
  00050	e58d8000	 str         r8, [sp]
  00054	eb000000	 bl          |??0Heap@@QAA@KKPAV0@0@Z|
  00058	ea000000	 b           |$LN24@Initialize|
  0005c		 |$LN23@Initialize|
  0005c	e3a00000	 mov         r0, #0
  00060		 |$LN24@Initialize|

; 680  :     if( pHeap == NULL )

  00060	e3500000	 cmp         r0, #0
  00064	0a00004d	 beq         |$cleanUp$37446|

; 681  :     {
; 682  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to create heap manager\n"));
; 683  :         goto cleanUp;
; 684  :     }
; 685  :     
; 686  :     m_hHeap = (HANDLE) pHeap;

  00068	e5840004	 str         r0, [r4, #4]

; 687  : 
; 688  : 
; 689  :     //  Open handle to VRFB manager
; 690  :     m_hVRFB = VRFBOpen();

  0006c	eb000000	 bl          VRFBOpen
  00070	e3500000	 cmp         r0, #0
  00074	e5840010	 str         r0, [r4, #0x10]

; 691  :     if( m_hVRFB == NULL )

  00078	0a000048	 beq         |$cleanUp$37446|

; 692  :     {
; 693  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: VRFBOpen() failed\r\n"));
; 694  :         goto cleanUp;
; 695  :     }
; 696  : 
; 697  :     
; 698  :     //  Get number of display views
; 699  :     dwNumDisplayViews = VRFBNumDisplayViews( m_hVRFB );

  0007c	eb000000	 bl          VRFBNumDisplayViews

; 700  :     if( dwNumDisplayViews < MIN_NUM_VIEWS )

  00080	e3500004	 cmp         r0, #4
  00084	3a000045	 bcc         |$cleanUp$37446|

; 701  :     {
; 702  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: Too few VRFB display views %d - should be %d\r\n", dwNumDisplayViews, MIN_NUM_VIEWS));
; 703  :         goto cleanUp;
; 704  :     }
; 705  : 
; 706  :     //  Success for main memory.  If the following offscreen surface allocation fails, the driver can still continue to operate
; 707  :     //  without those surfaces
; 708  :     bResult = TRUE;

  00088	e3a07001	 mov         r7, #1

; 709  : 
; 710  :     
; 711  :     //  Allocate physical memory for offscreen surfaces
; 712  :     if( dwOffscreenMemory > 0 )

  0008c	e3560000	 cmp         r6, #0
  00090	0a000042	 beq         |$cleanUp$37446|

; 713  :     {
; 714  :         Heap*   pHeapPA = (Heap *) m_hHeap;

  00094	e5940004	 ldr         r0, [r4, #4]

; 715  :         
; 716  :         //  Carve out from the VRFB physical memory heap a block for offscreen surfaces 
; 717  :         pHeap = pHeapPA->Allocate( dwOffscreenMemory );

  00098	e1a01006	 mov         r1, r6
  0009c	eb000000	 bl          |?Allocate@Heap@@QAAPAV1@K@Z|
  000a0	e1b05000	 movs        r5, r0

; 718  :         if( pHeap == NULL )

  000a4	0a00003d	 beq         |$cleanUp$37446|

; 719  :         {
; 720  :             DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to allocate offscreen heap memory\n"));
; 721  :             goto cleanUp;
; 722  :         }
; 723  : 
; 724  :         //  Map physical memory to VM for offscreen buffers
; 725  :         m_pOffscreenBuffer = VirtualAlloc(0, dwOffscreenMemory, MEM_RESERVE, PAGE_NOACCESS);

  000a8	e3a03001	 mov         r3, #1
  000ac	e3a02a02	 mov         r2, #2, 20
  000b0	e1a01006	 mov         r1, r6
  000b4	e3a00000	 mov         r0, #0
  000b8	eb000000	 bl          VirtualAlloc
  000bc	e3500000	 cmp         r0, #0
  000c0	e584001c	 str         r0, [r4, #0x1C]

; 768  :     }
; 769  : 
; 770  :     
; 771  : cleanUp:

  000c4	0a000018	 beq         |$LN56@Initialize|
  000c8	e5952008	 ldr         r2, [r5, #8]
  000cc	e3a03c06	 mov         r3, #6, 24
  000d0	e3833004	 orr         r3, r3, #4
  000d4	e1a01422	 mov         r1, r2, lsr #8
  000d8	e1a02006	 mov         r2, r6
  000dc	eb000000	 bl          VirtualCopy
  000e0	e3500000	 cmp         r0, #0
  000e4	0a000010	 beq         |$LN56@Initialize|
  000e8	e5953008	 ldr         r3, [r5, #8]
  000ec	e594201c	 ldr         r2, [r4, #0x1C]
  000f0	e3a0eb01	 mov         lr, #1, 22
  000f4	e1a03423	 mov         r3, r3, lsr #8
  000f8	e58d3000	 str         r3, [sp]
  000fc	e1a03006	 mov         r3, r6
  00100	e3a0100c	 mov         r1, #0xC
  00104	e3a00001	 mov         r0, #1
  00108	e58d8008	 str         r8, [sp, #8]
  0010c	e58de004	 str         lr, [sp, #4]
  00110	eb000000	 bl          KernelLibIoControl
  00114	e3500000	 cmp         r0, #0
  00118	1a000009	 bne         |$LN4@Initialize|
  0011c	e594001c	 ldr         r0, [r4, #0x1C]
  00120	e3a02902	 mov         r2, #2, 18
  00124	e3a01000	 mov         r1, #0
  00128	eb000000	 bl          VirtualFree
  0012c		 |$LN56@Initialize|
  0012c	e1a00005	 mov         r0, r5
  00130	eb000000	 bl          |??1Heap@@QAA@XZ|
  00134	e1a00005	 mov         r0, r5
  00138	eb000000	 bl          |??3@YAXPAX@Z|
  0013c	e584801c	 str         r8, [r4, #0x1C]
  00140	ea000016	 b           |$cleanUp$37446|
  00144		 |$LN4@Initialize|

; 726  :         if( !m_pOffscreenBuffer )
; 727  :         {
; 728  :             DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to allocate offscreen buffer\n"));
; 729  :             delete pHeap;
; 730  :             m_pOffscreenBuffer = NULL;
; 731  :             goto cleanUp;
; 732  :         }
; 733  : 
; 734  :         //  VirtualCopy offscreen memory region
; 735  :         if( !VirtualCopy(m_pOffscreenBuffer, (void *)(pHeap->Address() >> 8), dwOffscreenMemory, PAGE_READWRITE | PAGE_NOCACHE | PAGE_PHYSICAL))
; 736  :         {
; 737  :             DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to map offscreen buffer physical memory\n"));
; 738  :             delete pHeap;
; 739  :             m_pOffscreenBuffer = NULL;
; 740  :             goto cleanUp;
; 741  :         }
; 742  : 
; 743  :         //  Change the attributes of the buffer for cache write combine
; 744  :         if( !CeSetMemoryAttributes(m_pOffscreenBuffer, (void *)(pHeap->Address() >> 8), dwOffscreenMemory, PAGE_WRITECOMBINE))
; 745  :         {
; 746  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: Failed CeSetMemoryAttributes for offscreen buffer\r\n"));
; 747  :             VirtualFree( m_pOffscreenBuffer, 0, MEM_RELEASE );
; 748  :             delete pHeap;
; 749  :             m_pOffscreenBuffer = NULL;
; 750  :             goto cleanUp;
; 751  :         }
; 752  : 
; 753  :         m_hOffscreenHeapPA = (HANDLE) pHeap;

  00144	e5845014	 str         r5, [r4, #0x14]

; 754  :         m_dwOffscreenPhysical = pHeap->Address();

  00148	e5953008	 ldr         r3, [r5, #8]

; 755  : 
; 756  :         //  Allocate new heap for the virtual memory for the offscreen surfaces
; 757  :         pHeap = new Heap(dwOffscreenMemory, (DWORD) m_pOffscreenBuffer);

  0014c	e3a00014	 mov         r0, #0x14
  00150	e5843020	 str         r3, [r4, #0x20]
  00154	eb000000	 bl          |??2@YAPAXI@Z|
  00158	e3500000	 cmp         r0, #0
  0015c	0a000005	 beq         |$LN31@Initialize|
  00160	e594201c	 ldr         r2, [r4, #0x1C]
  00164	e3a03000	 mov         r3, #0
  00168	e1a01006	 mov         r1, r6
  0016c	e58d8000	 str         r8, [sp]
  00170	eb000000	 bl          |??0Heap@@QAA@KKPAV0@0@Z|
  00174	ea000000	 b           |$LN32@Initialize|
  00178		 |$LN31@Initialize|
  00178	e3a00000	 mov         r0, #0
  0017c		 |$LN32@Initialize|

; 758  :         if( pHeap == NULL )

  0017c	e3500000	 cmp         r0, #0
  00180	1a000005	 bne         |$LN2@Initialize|

; 759  :         {
; 760  :             DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to create offscreen heap manager\n"));
; 761  :             VirtualFree( m_pOffscreenBuffer, 0, MEM_RELEASE );

  00184	e594001c	 ldr         r0, [r4, #0x1C]
  00188	e3a02902	 mov         r2, #2, 18
  0018c	e3a01000	 mov         r1, #0
  00190	eb000000	 bl          VirtualFree

; 762  :             delete pHeap;
; 763  :             m_pOffscreenBuffer = NULL;

  00194	e584801c	 str         r8, [r4, #0x1C]

; 768  :     }
; 769  : 
; 770  :     
; 771  : cleanUp:

  00198	ea000000	 b           |$cleanUp$37446|
  0019c		 |$LN2@Initialize|

; 764  :             goto cleanUp;
; 765  :         }
; 766  : 
; 767  :         m_hOffscreenHeapVA = (HANDLE) pHeap;

  0019c	e5840018	 str         r0, [r4, #0x18]
  001a0		 |$cleanUp$37446|

; 772  :     //  Retrun result
; 773  :     return bResult;
; 774  : }

  001a0	e1a00007	 mov         r0, r7
  001a4	e28dd00c	 add         sp, sp, #0xC
  001a8	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  001ac	e12fff1e	 bx          lr
  001b0		 |$M38488|

			 ENDP  ; |?Initialize@OMAPVrfbSurfaceManager@@UAAHK@Z|, OMAPVrfbSurfaceManager::Initialize

	END
