; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\DSS\DSSAI\surfmgr_flat.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|CeSetMemoryAttributes|
	IMPORT	|KernelLibIoControl|
; File c:\wince600\public\common\oak\inc\pkfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T37252| DCD	|$LN5@CeSetMemor|
	DCD	0x40001002
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |CeSetMemoryAttributes| PROC

; 1422 : {

  00000		 |$LN5@CeSetMemor|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M37249|
  00008	e1a04003	 mov         r4, r3
  0000c	e1a03002	 mov         r3, r2
  00010	e1a02000	 mov         r2, r0
  00014	e1a0e001	 mov         lr, r1

; 1423 :     return KernelLibIoControl ((HANDLE) KMOD_CORE, IOCTL_KLIB_SETMEMORYATTR,
; 1424 :         pVirtualAddr, cbSize, pShiftedPhysAddr, dwAttributes, NULL);

  00018	e3a01000	 mov         r1, #0
  0001c	e58d1008	 str         r1, [sp, #8]
  00020	e3a0100c	 mov         r1, #0xC
  00024	e3a00001	 mov         r0, #1
  00028	e58d4004	 str         r4, [sp, #4]
  0002c	e58de000	 str         lr, [sp]
  00030	eb000000	 bl          KernelLibIoControl

; 1425 : }

  00034	e28dd00c	 add         sp, sp, #0xC
  00038	e8bd4010	 ldmia       sp!, {r4, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$M37250|

			 ENDP  ; |CeSetMemoryAttributes|

	EXPORT	|??0OMAPSurface@@QAA@XZ|		; OMAPSurface::OMAPSurface
	EXPORT	|??_7OMAPSurface@@6B@| [ DATA ]		; OMAPSurface::`vftable'
	IMPORT	|??_EOMAPSurface@@UAAPAXI@Z|, WEAK |??_GOMAPSurface@@UAAPAXI@Z| ; OMAPSurface::`vector deleting destructor', OMAPSurface::`scalar deleting destructor'
	IMPORT	|_purecall|
	IMPORT	|?SetClipping@OMAPSurface@@UAAHPAUtagRECT@@@Z| ; OMAPSurface::SetClipping
	IMPORT	|?UpdateClipping@OMAPSurface@@UAAHPAUtagRECT@@@Z| ; OMAPSurface::UpdateClipping
	IMPORT	|?GetClipping@OMAPSurface@@UAA?AUtagRECT@@XZ| ; OMAPSurface::GetClipping
	IMPORT	|?AdjustClippingRect@OMAPSurface@@UAAHPAUtagRECT@@EE@Z| ; OMAPSurface::AdjustClippingRect
	IMPORT	|?SetHorizontalScaling@OMAPSurface@@UAAHK@Z| ; OMAPSurface::SetHorizontalScaling
	IMPORT	|?SetVerticalScaling@OMAPSurface@@UAAHK@Z| ; OMAPSurface::SetVerticalScaling
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\inc\dssai.h

  00000			 AREA	 |.pdata|, PDATA
|$T37262| DCD	|$LN5@OMAPSurfac|
	DCD	0x40000500

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7OMAPSurface@@6B@| DCD |??_EOMAPSurface@@UAAPAXI@Z|	; OMAPSurface::`vftable'
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|?SetClipping@OMAPSurface@@UAAHPAUtagRECT@@@Z|
	DCD	|?UpdateClipping@OMAPSurface@@UAAHPAUtagRECT@@@Z|
	DCD	|?GetClipping@OMAPSurface@@UAA?AUtagRECT@@XZ|
	DCD	|?AdjustClippingRect@OMAPSurface@@UAAHPAUtagRECT@@EE@Z|
	DCD	|?SetHorizontalScaling@OMAPSurface@@UAAHK@Z|
	DCD	|?SetVerticalScaling@OMAPSurface@@UAAHK@Z|
	DCD	|_purecall|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0OMAPSurface@@QAA@XZ| PROC		; OMAPSurface::OMAPSurface

; 739  :     OMAPSurface() {};

  00000		 |$LN5@OMAPSurfac|
  00000		 |$M37259|
  00000	e1a02000	 mov         r2, r0
  00004	e59f3004	 ldr         r3, [pc, #4]
  00008	e5823000	 str         r3, [r2]
  0000c	e12fff1e	 bx          lr
  00010		 |$LN6@OMAPSurfac|
  00010		 |$LN7@OMAPSurfac|
  00010	00000000	 DCD         |??_7OMAPSurface@@6B@|
  00014		 |$M37260|

			 ENDP  ; |??0OMAPSurface@@QAA@XZ|, OMAPSurface::OMAPSurface

	EXPORT	|??1OMAPSurface@@UAA@XZ|		; OMAPSurface::~OMAPSurface

  00000			 AREA	 |.pdata|, PDATA
|$T37272| DCD	|$LN5@OMAPSurfac@2|
	DCD	0x40000400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1OMAPSurface@@UAA@XZ| PROC		; OMAPSurface::~OMAPSurface

; 746  :     ~OMAPSurface() {};

  00000		 |$LN5@OMAPSurfac@2|
  00000		 |$M37269|
  00000	e59f3004	 ldr         r3, [pc, #4]
  00004	e5803000	 str         r3, [r0]
  00008	e12fff1e	 bx          lr
  0000c		 |$LN6@OMAPSurfac@2|
  0000c		 |$LN7@OMAPSurfac@2|
  0000c	00000000	 DCD         |??_7OMAPSurface@@6B@|
  00010		 |$M37270|

			 ENDP  ; |??1OMAPSurface@@UAA@XZ|, OMAPSurface::~OMAPSurface

	IMPORT	|??3@YAXPAX@Z|				; operator delete

  00000			 AREA	 |.pdata|, PDATA
|$T37288| DCD	|$LN8@scalar|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GOMAPSurface@@UAAPAXI@Z| PROC	; OMAPSurface::`scalar deleting destructor'
  00000		 |$LN8@scalar|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37285|
  00004	e1a04000	 mov         r4, r0
  00008	e59f3014	 ldr         r3, [pc, #0x14]
  0000c	e3110001	 tst         r1, #1
  00010	e5843000	 str         r3, [r4]
  00014	1b000000	 blne        |??3@YAXPAX@Z|
  00018	e1a00004	 mov         r0, r4
  0001c	e8bd4010	 ldmia       sp!, {r4, lr}
  00020	e12fff1e	 bx          lr
  00024		 |$LN9@scalar|
  00024		 |$LN10@scalar|
  00024	00000000	 DCD         |??_7OMAPSurface@@6B@|
  00028		 |$M37286|

			 ENDP  ; |??_GOMAPSurface@@UAAPAXI@Z|, OMAPSurface::`scalar deleting destructor'

	EXPORT	|??0OMAPSurfaceManager@@QAA@XZ|		; OMAPSurfaceManager::OMAPSurfaceManager
	EXPORT	|??_7OMAPSurfaceManager@@6B@| [ DATA ]	; OMAPSurfaceManager::`vftable'
	IMPORT	|??_EOMAPSurfaceManager@@UAAPAXI@Z|, WEAK |??_GOMAPSurfaceManager@@UAAPAXI@Z| ; OMAPSurfaceManager::`vector deleting destructor', OMAPSurfaceManager::`scalar deleting destructor'

  00000			 AREA	 |.pdata|, PDATA
|$T37300| DCD	|$LN5@OMAPSurfac@3|
	DCD	0x40000500

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7OMAPSurfaceManager@@6B@| DCD |??_EOMAPSurfaceManager@@UAAPAXI@Z| ; OMAPSurfaceManager::`vftable'
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0OMAPSurfaceManager@@QAA@XZ| PROC	; OMAPSurfaceManager::OMAPSurfaceManager

; 956  :     OMAPSurfaceManager() {};

  00000		 |$LN5@OMAPSurfac@3|
  00000		 |$M37297|
  00000	e1a02000	 mov         r2, r0
  00004	e59f3004	 ldr         r3, [pc, #4]
  00008	e5823000	 str         r3, [r2]
  0000c	e12fff1e	 bx          lr
  00010		 |$LN6@OMAPSurfac@3|
  00010		 |$LN7@OMAPSurfac@3|
  00010	00000000	 DCD         |??_7OMAPSurfaceManager@@6B@|
  00014		 |$M37298|

			 ENDP  ; |??0OMAPSurfaceManager@@QAA@XZ|, OMAPSurfaceManager::OMAPSurfaceManager

	EXPORT	|??1OMAPSurfaceManager@@UAA@XZ|		; OMAPSurfaceManager::~OMAPSurfaceManager

  00000			 AREA	 |.pdata|, PDATA
|$T37310| DCD	|$LN5@OMAPSurfac@4|
	DCD	0x40000400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1OMAPSurfaceManager@@UAA@XZ| PROC	; OMAPSurfaceManager::~OMAPSurfaceManager

; 963  :     ~OMAPSurfaceManager() {};

  00000		 |$LN5@OMAPSurfac@4|
  00000		 |$M37307|
  00000	e59f3004	 ldr         r3, [pc, #4]
  00004	e5803000	 str         r3, [r0]
  00008	e12fff1e	 bx          lr
  0000c		 |$LN6@OMAPSurfac@4|
  0000c		 |$LN7@OMAPSurfac@4|
  0000c	00000000	 DCD         |??_7OMAPSurfaceManager@@6B@|
  00010		 |$M37308|

			 ENDP  ; |??1OMAPSurfaceManager@@UAA@XZ|, OMAPSurfaceManager::~OMAPSurfaceManager


  00000			 AREA	 |.pdata|, PDATA
|$T37326| DCD	|$LN8@scalar@2|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GOMAPSurfaceManager@@UAAPAXI@Z| PROC ; OMAPSurfaceManager::`scalar deleting destructor'
  00000		 |$LN8@scalar@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37323|
  00004	e1a04000	 mov         r4, r0
  00008	e59f3014	 ldr         r3, [pc, #0x14]
  0000c	e3110001	 tst         r1, #1
  00010	e5843000	 str         r3, [r4]
  00014	1b000000	 blne        |??3@YAXPAX@Z|
  00018	e1a00004	 mov         r0, r4
  0001c	e8bd4010	 ldmia       sp!, {r4, lr}
  00020	e12fff1e	 bx          lr
  00024		 |$LN9@scalar@2|
  00024		 |$LN10@scalar@2|
  00024	00000000	 DCD         |??_7OMAPSurfaceManager@@6B@|
  00028		 |$M37324|

			 ENDP  ; |??_GOMAPSurfaceManager@@UAAPAXI@Z|, OMAPSurfaceManager::`scalar deleting destructor'

	EXPORT	|?NodeSize@Heap@@QAAKXZ|		; Heap::NodeSize
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\heap.h

  00000			 AREA	 |.pdata|, PDATA
|$T37338| DCD	|$LN5@NodeSize|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?NodeSize@Heap@@QAAKXZ| PROC		; Heap::NodeSize

; 75   :     DWORD       NodeSize(){ return m_nSize; }

  00000		 |$LN5@NodeSize|
  00000		 |$M37335|
  00000	e590000c	 ldr         r0, [r0, #0xC]
  00004	e12fff1e	 bx          lr
  00008		 |$M37336|

			 ENDP  ; |?NodeSize@Heap@@QAAKXZ|, Heap::NodeSize

	EXPORT	|?Address@Heap@@QAAKXZ|			; Heap::Address

  00000			 AREA	 |.pdata|, PDATA
|$T37348| DCD	|$LN5@Address|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Address@Heap@@QAAKXZ| PROC		; Heap::Address

; 76   :     DWORD       Address() { return m_pStart; }

  00000		 |$LN5@Address|
  00000		 |$M37345|
  00000	e5900008	 ldr         r0, [r0, #8]
  00004	e12fff1e	 bx          lr
  00008		 |$M37346|

			 ENDP  ; |?Address@Heap@@QAAKXZ|, Heap::Address

	EXPORT	|??0OMAPFlatSurface@@QAA@XZ|		; OMAPFlatSurface::OMAPFlatSurface
	EXPORT	|??_7OMAPFlatSurface@@6B@| [ DATA ]	; OMAPFlatSurface::`vftable'
	EXPORT	|?VirtualAddr@OMAPFlatSurface@@UAAPAXXZ| ; OMAPFlatSurface::VirtualAddr
	EXPORT	|?Width@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z| ; OMAPFlatSurface::Width
	EXPORT	|?Height@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z| ; OMAPFlatSurface::Height
	EXPORT	|?Stride@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z| ; OMAPFlatSurface::Stride
	EXPORT	|?PhysicalAddr@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@HW4OMAP_ASSOC_SURF_USAGE@@@Z| ; OMAPFlatSurface::PhysicalAddr
	EXPORT	|?PixelIncr@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@H@Z| ; OMAPFlatSurface::PixelIncr
	EXPORT	|?RowIncr@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@H@Z| ; OMAPFlatSurface::RowIncr
	EXPORT	|?SetOrientation@OMAPFlatSurface@@UAAHW4OMAP_SURF_ORIENTATION@@@Z| ; OMAPFlatSurface::SetOrientation
	IMPORT	|??_EOMAPFlatSurface@@UAAPAXI@Z|, WEAK |??_GOMAPFlatSurface@@UAAPAXI@Z| ; OMAPFlatSurface::`vector deleting destructor', OMAPFlatSurface::`scalar deleting destructor'
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\inc\dssai.h

  00000			 AREA	 |.pdata|, PDATA
|$T37361| DCD	|$LN7@OMAPFlatSu|
	DCD	0x40000d00

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7OMAPFlatSurface@@6B@| DCD |??_EOMAPFlatSurface@@UAAPAXI@Z| ; OMAPFlatSurface::`vftable'
	DCD	|?VirtualAddr@OMAPFlatSurface@@UAAPAXXZ|
	DCD	|?Width@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z|
	DCD	|?Height@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z|
	DCD	|?Stride@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z|
	DCD	|?PhysicalAddr@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@HW4OMAP_ASSOC_SURF_USAGE@@@Z|
	DCD	|?PixelIncr@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@H@Z|
	DCD	|?RowIncr@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@H@Z|
	DCD	|?SetClipping@OMAPSurface@@UAAHPAUtagRECT@@@Z|
	DCD	|?UpdateClipping@OMAPSurface@@UAAHPAUtagRECT@@@Z|
	DCD	|?GetClipping@OMAPSurface@@UAA?AUtagRECT@@XZ|
	DCD	|?AdjustClippingRect@OMAPSurface@@UAAHPAUtagRECT@@EE@Z|
	DCD	|?SetHorizontalScaling@OMAPSurface@@UAAHK@Z|
	DCD	|?SetVerticalScaling@OMAPSurface@@UAAHK@Z|
	DCD	|?SetOrientation@OMAPFlatSurface@@UAAHW4OMAP_SURF_ORIENTATION@@@Z|
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\surfmgr_flat.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0OMAPFlatSurface@@QAA@XZ| PROC	; OMAPFlatSurface::OMAPFlatSurface

; 41   : {

  00000		 |$LN7@OMAPFlatSu|
  00000		 |$M37358|
  00000	e59f3028	 ldr         r3, [pc, #0x28]

; 42   :     m_hHeap = NULL;    

  00004	e3a01000	 mov         r1, #0

; 43   :     m_dwHorizScale = 1;

  00008	e3a02001	 mov         r2, #1
  0000c	e5803000	 str         r3, [r0]
  00010	e58010a4	 str         r1, [r0, #0xA4]
  00014	e5802028	 str         r2, [r0, #0x28]

; 44   :     m_dwVertScale = 1;

  00018	e580202c	 str         r2, [r0, #0x2C]

; 45   :     m_dwWidthFactor = 1;

  0001c	e58020b4	 str         r2, [r0, #0xB4]

; 46   :     m_bUseResizer = FALSE;

  00020	e5801030	 str         r1, [r0, #0x30]

; 47   :     m_pAssocSurface = NULL;

  00024	e58010a0	 str         r1, [r0, #0xA0]

; 48   :     m_eSurfaceType = OMAP_SURFACE_NORMAL;

  00028	e580109c	 str         r1, [r0, #0x9C]

; 49   : }

  0002c	e12fff1e	 bx          lr
  00030		 |$LN8@OMAPFlatSu|
  00030		 |$LN9@OMAPFlatSu|
  00030	00000000	 DCD         |??_7OMAPFlatSurface@@6B@|
  00034		 |$M37359|

			 ENDP  ; |??0OMAPFlatSurface@@QAA@XZ|, OMAPFlatSurface::OMAPFlatSurface

	EXPORT	|??1OMAPFlatSurface@@UAA@XZ|		; OMAPFlatSurface::~OMAPFlatSurface
	IMPORT	|?Free@Heap@@QAAXXZ|			; Heap::Free
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\inc\dssai.h

  00000			 AREA	 |.pdata|, PDATA
|$T37375| DCD	|$LN8@OMAPFlatSu@2|
	DCD	0x40000e01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\surfmgr_flat.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1OMAPFlatSurface@@UAA@XZ| PROC	; OMAPFlatSurface::~OMAPFlatSurface

; 53   : {

  00000		 |$LN8@OMAPFlatSu@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37372|
  00004	e1a04000	 mov         r4, r0

; 54   :     Heap    *pHeap = (Heap*) m_hHeap;

  00008	e59420a4	 ldr         r2, [r4, #0xA4]
  0000c	e59f3020	 ldr         r3, [pc, #0x20]
  00010	e3520000	 cmp         r2, #0

; 55   :     
; 56   :     //  Free the underlying surface memory
; 57   :     if( pHeap )
; 58   :         pHeap->Free();

  00014	11a00002	 movne       r0, r2
  00018	e5843000	 str         r3, [r4]
  0001c	1b000000	 blne        |?Free@Heap@@QAAXXZ|

; 59   : }

  00020	e59f3008	 ldr         r3, [pc, #8]
  00024	e5843000	 str         r3, [r4]
  00028	e8bd4010	 ldmia       sp!, {r4, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$LN9@OMAPFlatSu@2|
  00030		 |$LN10@OMAPFlatSu@2|
  00030	00000000	 DCD         |??_7OMAPSurface@@6B@|
  00034		 |$LN11@OMAPFlatSu@2|
  00034	00000000	 DCD         |??_7OMAPFlatSurface@@6B@|
  00038		 |$M37373|

			 ENDP  ; |??1OMAPFlatSurface@@UAA@XZ|, OMAPFlatSurface::~OMAPFlatSurface

	EXPORT	|?Allocate@OMAPFlatSurface@@QAAHW4OMAP_DSS_PIXELFORMAT@@KKPAXK@Z| ; OMAPFlatSurface::Allocate
	IMPORT	|?Allocate@Heap@@QAAPAV1@K@Z|		; Heap::Allocate
	IMPORT	|?PixelFormatToPixelSize@OMAPDisplayController@@SAKW4OMAP_DSS_PIXELFORMAT@@@Z| ; OMAPDisplayController::PixelFormatToPixelSize
	IMPORT	|memset|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\heap.h

  00000			 AREA	 |.pdata|, PDATA
|$T37414| DCD	|$LN21@Allocate|
	DCD	0x40004601
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\surfmgr_flat.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Allocate@OMAPFlatSurface@@QAAHW4OMAP_DSS_PIXELFORMAT@@KKPAXK@Z| PROC ; OMAPFlatSurface::Allocate

; 70   : {

  00000		 |$LN21@Allocate|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M37411|
  00004	e1a07003	 mov         r7, r3
  00008	e1a08002	 mov         r8, r2
  0000c	e1a06000	 mov         r6, r0

; 71   :     Heap    *pMainHeap = (Heap*) hHeap,
; 72   :             *pSurfHeap = NULL;
; 73   :     DWORD   dwMinStride;
; 74   :     DWORD    allocateSize=0;
; 75   :     
; 76   :     //  Determine min stride for surface based on pixel type
; 77   :     if( (ePixelFormat == OMAP_DSS_PIXELFORMAT_YUV2) || (ePixelFormat == OMAP_DSS_PIXELFORMAT_UYVY) )

  00010	e351000a	 cmp         r1, #0xA
  00014	1351000b	 cmpne       r1, #0xB

; 78   :     {
; 79   :         dwMinStride = MIN_STRIDE_YUV;
; 80   :         m_dwWidthFactor = 2;
; 81   :     }
; 82   :     else
; 83   :     {
; 84   :         dwMinStride = MIN_STRIDE_RGB;
; 85   :         m_dwWidthFactor = 1;

  00018	13a03001	 movne       r3, #1
  0001c	03a03002	 moveq       r3, #2

; 86   :     }
; 87   :                 
; 88   :     //  Initialize the surface properties for this surface type
; 89   :     m_ePixelFormat   = ePixelFormat;
; 90   :     m_dwPixelSize    = OMAPDisplayController::PixelFormatToPixelSize(m_ePixelFormat);

  00020	e1a00001	 mov         r0, r1
  00024	e58630b4	 str         r3, [r6, #0xB4]
  00028	e5861004	 str         r1, [r6, #4]
  0002c	eb000000	 bl          |?PixelFormatToPixelSize@OMAPDisplayController@@SAKW4OMAP_DSS_PIXELFORMAT@@@Z|

; 91   :     m_eOrientation   = OMAP_SURF_ORIENTATION_STANDARD;
; 92   :     m_dwWidth        = dwWidth;
; 93   :     m_dwHeight       = dwHeight;
; 94   :     m_dwActualWidth  = ((dwWidth  + dwMinStride -1)/dwMinStride) * dwMinStride;
; 95   :     m_dwActualHeight = ((dwHeight + dwMinStride -1)/dwMinStride) * dwMinStride;
; 96   :     
; 97   :     //  Set clipping region to be entire surface
; 98   :     SetClipping( NULL );

  00030	e5963000	 ldr         r3, [r6]
  00034	e288201f	 add         r2, r8, #0x1F
  00038	e287101f	 add         r1, r7, #0x1F
  0003c	e5935020	 ldr         r5, [r3, #0x20]
  00040	e1a032a2	 mov         r3, r2, lsr #5
  00044	e1a022a1	 mov         r2, r1, lsr #5
  00048	e1a02282	 mov         r2, r2, lsl #5
  0004c	e1a04000	 mov         r4, r0
  00050	e1a03283	 mov         r3, r3, lsl #5
  00054	e3a09000	 mov         r9, #0
  00058	e58620b0	 str         r2, [r6, #0xB0]
  0005c	e3a01000	 mov         r1, #0
  00060	e1a00006	 mov         r0, r6
  00064	e5864008	 str         r4, [r6, #8]
  00068	e586900c	 str         r9, [r6, #0xC]
  0006c	e5868010	 str         r8, [r6, #0x10]
  00070	e5867014	 str         r7, [r6, #0x14]
  00074	e58630ac	 str         r3, [r6, #0xAC]
  00078	e1a0e00f	 mov         lr, pc
  0007c	e12fff15	 bx          r5

; 99   :     
; 100  :     // Aligning the size to PAGE_SIZE since some applications (ex: graphics) require a page aligned buffer    
; 101  :     allocateSize = m_dwPixelSize * m_dwActualWidth * m_dwActualHeight;
; 102  :     allocateSize = (allocateSize + PAGE_SIZE -1) & ~(PAGE_SIZE -1);

  00080	e59610b0	 ldr         r1, [r6, #0xB0]
  00084	e59620ac	 ldr         r2, [r6, #0xAC]
  00088	e3e03b0d	 mvn         r3, #0xD, 22
  0008c	e22330fb	 eor         r3, r3, #0xFB
  00090	e593e000	 ldr         lr, [r3]
  00094	e5963008	 ldr         r3, [r6, #8]
  00098	e0000291	 mul         r0, r1, r2

; 103  :     //  Allocate the surface memory from the given video memory heap
; 104  :     pSurfHeap = pMainHeap->Allocate( allocateSize);    

  0009c	e59d501c	 ldr         r5, [sp, #0x1C]
  000a0	e24e2001	 sub         r2, lr, #1
  000a4	e023e390	 mla         r3, r0, r3, lr
  000a8	e1a00005	 mov         r0, r5
  000ac	e2433001	 sub         r3, r3, #1
  000b0	e1c31002	 bic         r1, r3, r2
  000b4	eb000000	 bl          |?Allocate@Heap@@QAAPAV1@K@Z|
  000b8	e1b04000	 movs        r4, r0

; 105  :     if( pSurfHeap == NULL )

  000bc	0a000012	 beq         |$LN8@Allocate|

; 106  :     {
; 107  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to allocate heap memory\n"));
; 108  :         goto cleanUp;
; 109  :     }
; 110  : 
; 111  :     //  Clear out the surface memory
; 112  :     memset( (VOID*) pSurfHeap->Address(), 0, pSurfHeap->NodeSize() );

  000c0	e594200c	 ldr         r2, [r4, #0xC]
  000c4	e5940008	 ldr         r0, [r4, #8]
  000c8	e3a01000	 mov         r1, #0
  000cc	eb000000	 bl          memset

; 113  : 
; 114  :     //  Set surface specific properties
; 115  :     m_hHeap = (HANDLE) pSurfHeap;
; 116  :     m_dwPhysicalAddr = dwBasePhysicalAddr +(DWORD)(pSurfHeap->Address() - pMainHeap->Address());

  000d0	e59d3020	 ldr         r3, [sp, #0x20]
  000d4	e58640a4	 str         r4, [r6, #0xA4]
  000d8	e595e008	 ldr         lr, [r5, #8]
  000dc	e5941008	 ldr         r1, [r4, #8]

; 117  : 
; 118  :     
; 119  :     // Initialize variables
; 120  :     m_hRSZHandle = NULL;
; 121  :     memset(&m_sRSZParams,0,sizeof(RSZParams_t));      

  000e0	e3a02064	 mov         r2, #0x64
  000e4	e043300e	 sub         r3, r3, lr
  000e8	e0833001	 add         r3, r3, r1
  000ec	e3a01000	 mov         r1, #0
  000f0	e2860038	 add         r0, r6, #0x38
  000f4	e58630a8	 str         r3, [r6, #0xA8]
  000f8	e5869034	 str         r9, [r6, #0x34]
  000fc	eb000000	 bl          memset

; 122  :     
; 123  : cleanUp:        
; 124  :     //  Return
; 125  :     return (pSurfHeap != NULL);

  00100	e3a00001	 mov         r0, #1
  00104		 |$cleanUp$36786|

; 126  : }

  00104	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00108	e12fff1e	 bx          lr
  0010c		 |$LN8@Allocate|

; 122  :     
; 123  : cleanUp:        
; 124  :     //  Return
; 125  :     return (pSurfHeap != NULL);

  0010c	e3a00000	 mov         r0, #0

; 126  : }

  00110	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00114	e12fff1e	 bx          lr
  00118		 |$M37412|

			 ENDP  ; |?Allocate@OMAPFlatSurface@@QAAHW4OMAP_DSS_PIXELFORMAT@@KKPAXK@Z|, OMAPFlatSurface::Allocate

; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\heap.h

  00000			 AREA	 |.pdata|, PDATA
|$T37428| DCD	|$LN9@VirtualAdd|
	DCD	0x40001501
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\surfmgr_flat.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?VirtualAddr@OMAPFlatSurface@@UAAPAXXZ| PROC ; OMAPFlatSurface::VirtualAddr

; 131  : {

  00000		 |$LN9@VirtualAdd|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37425|

; 132  :     Heap*   pHeap;
; 133  :     if ((m_bUseResizer) && (m_eSurfaceType == OMAP_SURFACE_NORMAL) && (m_pAssocSurface))

  00004	e5903030	 ldr         r3, [r0, #0x30]
  00008	e3530000	 cmp         r3, #0
  0000c	0a00000c	 beq         |$LN2@VirtualAdd|
  00010	e590309c	 ldr         r3, [r0, #0x9C]
  00014	e3530000	 cmp         r3, #0
  00018	1a000009	 bne         |$LN2@VirtualAdd|
  0001c	e59030a0	 ldr         r3, [r0, #0xA0]
  00020	e3530000	 cmp         r3, #0
  00024	0a000006	 beq         |$LN2@VirtualAdd|

; 134  :         return m_pAssocSurface->VirtualAddr();

  00028	e1a00003	 mov         r0, r3
  0002c	e5903000	 ldr         r3, [r0]
  00030	e5933004	 ldr         r3, [r3, #4]
  00034	e1a0e00f	 mov         lr, pc
  00038	e12fff13	 bx          r3

; 140  :     }
; 141  : }

  0003c	e49de004	 ldr         lr, [sp], #4
  00040	e12fff1e	 bx          lr
  00044		 |$LN2@VirtualAdd|

; 135  :     else
; 136  :     {
; 137  :         pHeap = (Heap*) m_hHeap;    

  00044	e59030a4	 ldr         r3, [r0, #0xA4]

; 138  :         //  For flat surfaces, always same virtual memory value        
; 139  :         return (VOID*) pHeap->Address();

  00048	e5930008	 ldr         r0, [r3, #8]

; 140  :     }
; 141  : }

  0004c	e49de004	 ldr         lr, [sp], #4
  00050	e12fff1e	 bx          lr
  00054		 |$M37426|

			 ENDP  ; |?VirtualAddr@OMAPFlatSurface@@UAAPAXXZ|, OMAPFlatSurface::VirtualAddr

	IMPORT	|__rt_udiv|

  00000			 AREA	 |.pdata|, PDATA
|$T37442| DCD	|$LN11@Width|
	DCD	0x40001501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Width@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z| PROC ; OMAPFlatSurface::Width

; 149  : {

  00000		 |$LN11@Width|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37439|
  00004	e3510000	 cmp         r1, #0

; 150  :     DWORD   dwWidth;
; 151  :     
; 152  :     //  Return the surface width depending on the rotation angle
; 153  :     switch( eRotation )

  00008	0a00000c	 beq         |$LN3@Width|
  0000c	e351005a	 cmp         r1, #0x5A
  00010	0a000007	 beq         |$LN2@Width|
  00014	e35100b4	 cmp         r1, #0xB4
  00018	0a000008	 beq         |$LN3@Width|
  0001c	e3a03c01	 mov         r3, #1, 24
  00020	e383300e	 orr         r3, r3, #0xE
  00024	e1510003	 cmp         r1, r3

; 166  : 
; 167  :         default:
; 168  :             ASSERT(0);
; 169  :             return 0;

  00028	13a00000	 movne       r0, #0

; 170  :     }
; 171  :     
; 172  :     //  Return value
; 173  :     return dwWidth;
; 174  : }

  0002c	149de004	 ldrne       lr, [sp], #4
  00030	112fff1e	 bxne        lr
  00034		 |$LN2@Width|

; 159  :             break;
; 160  :             
; 161  :         case OMAP_DSS_ROTATION_90:
; 162  :         case OMAP_DSS_ROTATION_270:
; 163  :             //  Rotated
; 164  :             dwWidth = m_dwHeight/m_dwVertScale;

  00034	e5901014	 ldr         r1, [r0, #0x14]
  00038	e590002c	 ldr         r0, [r0, #0x2C]

; 165  :             break;

  0003c	ea000001	 b           |$LN8@Width|
  00040		 |$LN3@Width|

; 154  :     {
; 155  :         case OMAP_DSS_ROTATION_0:
; 156  :         case OMAP_DSS_ROTATION_180:
; 157  :             //  Normal
; 158  :             dwWidth = m_dwWidth/m_dwHorizScale;

  00040	e5901010	 ldr         r1, [r0, #0x10]
  00044	e5900028	 ldr         r0, [r0, #0x28]
  00048		 |$LN8@Width|
  00048	eb000000	 bl          __rt_udiv

; 170  :     }
; 171  :     
; 172  :     //  Return value
; 173  :     return dwWidth;
; 174  : }

  0004c	e49de004	 ldr         lr, [sp], #4
  00050	e12fff1e	 bx          lr
  00054		 |$M37440|

			 ENDP  ; |?Width@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z|, OMAPFlatSurface::Width


  00000			 AREA	 |.pdata|, PDATA
|$T37455| DCD	|$LN11@Height|
	DCD	0x40001501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Height@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z| PROC ; OMAPFlatSurface::Height

; 181  : {

  00000		 |$LN11@Height|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37452|
  00004	e3510000	 cmp         r1, #0

; 182  :     DWORD   dwHeight;
; 183  :     
; 184  :     //  Return the surface height depending on the rotation angle
; 185  :     switch( eRotation )

  00008	0a00000c	 beq         |$LN3@Height|
  0000c	e351005a	 cmp         r1, #0x5A
  00010	0a000007	 beq         |$LN2@Height|
  00014	e35100b4	 cmp         r1, #0xB4
  00018	0a000008	 beq         |$LN3@Height|
  0001c	e3a03c01	 mov         r3, #1, 24
  00020	e383300e	 orr         r3, r3, #0xE
  00024	e1510003	 cmp         r1, r3

; 198  : 
; 199  :         default:
; 200  :             ASSERT(0);
; 201  :             return 0;

  00028	13a00000	 movne       r0, #0

; 202  :     }
; 203  :     
; 204  :     //  Return value
; 205  :     return dwHeight;
; 206  : }

  0002c	149de004	 ldrne       lr, [sp], #4
  00030	112fff1e	 bxne        lr
  00034		 |$LN2@Height|

; 191  :             break;
; 192  :             
; 193  :         case OMAP_DSS_ROTATION_90:
; 194  :         case OMAP_DSS_ROTATION_270:
; 195  :             //  Rotated
; 196  :             dwHeight = m_dwWidth/m_dwHorizScale;

  00034	e5901010	 ldr         r1, [r0, #0x10]
  00038	e5900028	 ldr         r0, [r0, #0x28]

; 197  :             break;

  0003c	ea000001	 b           |$LN8@Height|
  00040		 |$LN3@Height|

; 186  :     {
; 187  :         case OMAP_DSS_ROTATION_0:
; 188  :         case OMAP_DSS_ROTATION_180:
; 189  :             //  Normal
; 190  :             dwHeight = m_dwHeight/m_dwVertScale;

  00040	e5901014	 ldr         r1, [r0, #0x14]
  00044	e590002c	 ldr         r0, [r0, #0x2C]
  00048		 |$LN8@Height|
  00048	eb000000	 bl          __rt_udiv

; 202  :     }
; 203  :     
; 204  :     //  Return value
; 205  :     return dwHeight;
; 206  : }

  0004c	e49de004	 ldr         lr, [sp], #4
  00050	e12fff1e	 bx          lr
  00054		 |$M37453|

			 ENDP  ; |?Height@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z|, OMAPFlatSurface::Height


  00000			 AREA	 |.pdata|, PDATA
|$T37468| DCD	|$LN11@Stride|
	DCD	0x40001400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Stride@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z| PROC ; OMAPFlatSurface::Stride

; 213  : {

  00000		 |$LN11@Stride|
  00000		 |$M37465|
  00000	e3510000	 cmp         r1, #0

; 214  :     DWORD   dwStride;
; 215  :     
; 216  :     //  Return the surface stride depending on the rotation angle
; 217  :     switch( eRotation )

  00004	0a00000b	 beq         |$LN3@Stride|
  00008	e351005a	 cmp         r1, #0x5A
  0000c	0a000006	 beq         |$LN2@Stride|
  00010	e35100b4	 cmp         r1, #0xB4
  00014	0a000007	 beq         |$LN3@Stride|
  00018	e3a03c01	 mov         r3, #1, 24
  0001c	e383300e	 orr         r3, r3, #0xE
  00020	e1510003	 cmp         r1, r3

; 230  : 
; 231  :         default:
; 232  :             ASSERT(0);
; 233  :             return 0;

  00024	13a00000	 movne       r0, #0

; 234  :     }
; 235  : 
; 236  :     //  Return the surface stride
; 237  :     return dwStride;
; 238  : }

  00028	112fff1e	 bxne        lr
  0002c		 |$LN2@Stride|

; 223  :             break;
; 224  :             
; 225  :         case OMAP_DSS_ROTATION_90:
; 226  :         case OMAP_DSS_ROTATION_270:
; 227  :             //  Rotated
; 228  :             dwStride = m_dwPixelSize * m_dwActualHeight * m_dwVertScale;

  0002c	e59010b0	 ldr         r1, [r0, #0xB0]
  00030	e590302c	 ldr         r3, [r0, #0x2C]

; 229  :             break;

  00034	ea000001	 b           |$LN8@Stride|
  00038		 |$LN3@Stride|

; 218  :     {
; 219  :         case OMAP_DSS_ROTATION_0:
; 220  :         case OMAP_DSS_ROTATION_180:
; 221  :             //  Normal
; 222  :             dwStride = m_dwPixelSize * m_dwActualWidth * m_dwHorizScale;

  00038	e59010ac	 ldr         r1, [r0, #0xAC]
  0003c	e5903028	 ldr         r3, [r0, #0x28]
  00040		 |$LN8@Stride|
  00040	e5902008	 ldr         r2, [r0, #8]
  00044	e0030391	 mul         r3, r1, r3
  00048	e0000293	 mul         r0, r3, r2

; 234  :     }
; 235  : 
; 236  :     //  Return the surface stride
; 237  :     return dwStride;
; 238  : }

  0004c	e12fff1e	 bx          lr
  00050		 |$M37466|

			 ENDP  ; |?Stride@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@@Z|, OMAPFlatSurface::Stride


  00000			 AREA	 |.pdata|, PDATA
|$T37486| DCD	|$LN28@PhysicalAd|
	DCD	0x40005401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PhysicalAddr@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@HW4OMAP_ASSOC_SURF_USAGE@@@Z| PROC ; OMAPFlatSurface::PhysicalAddr

; 247  : {

  00000		 |$LN28@PhysicalAd|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37483|
  00004	e3530000	 cmp         r3, #0
  00008	e1a04000	 mov         r4, r0

; 248  :     DWORD   dwAddr;
; 249  :     DWORD   dwClipOffsetX,
; 250  :             dwClipOffsetY;
; 251  : 
; 252  :     if ((((eUseAssocSurface==OMAP_ASSOC_SURF_DEFAULT) && (m_bUseResizer)) ||
; 253  :           ( eUseAssocSurface==OMAP_ASSOC_SURF_FORCE_ON )                     ) &&
; 254  :         (m_pAssocSurface))

  0000c	1a000002	 bne         |$LN17@PhysicalAd|
  00010	e594e030	 ldr         lr, [r4, #0x30]
  00014	e35e0000	 cmp         lr, #0
  00018	1a000001	 bne         |$LN18@PhysicalAd|
  0001c		 |$LN17@PhysicalAd|
  0001c	e3530002	 cmp         r3, #2
  00020	1a00000a	 bne         |$LN19@PhysicalAd|
  00024		 |$LN18@PhysicalAd|
  00024	e59430a0	 ldr         r3, [r4, #0xA0]
  00028	e3530000	 cmp         r3, #0
  0002c	0a000007	 beq         |$LN19@PhysicalAd|

; 255  :         
; 256  :         return m_pAssocSurface->PhysicalAddr(eRotation,bMirror,OMAP_ASSOC_SURF_FORCE_OFF);                 

  00030	e1a00003	 mov         r0, r3
  00034	e590e000	 ldr         lr, [r0]
  00038	e3a03001	 mov         r3, #1
  0003c	e59e4014	 ldr         r4, [lr, #0x14]
  00040	e1a0e00f	 mov         lr, pc
  00044	e12fff14	 bx          r4

; 351  :         }
; 352  :     }
; 353  :         
; 354  :     //  Return address
; 355  :     return dwAddr;
; 356  : }

  00048	e8bd4010	 ldmia       sp!, {r4, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$LN19@PhysicalAd|

; 257  :     
; 258  :     
; 259  :     if( bMirror )

  00050	e3520000	 cmp         r2, #0
  00054	0a000016	 beq         |$LN16@PhysicalAd|

; 260  :     {
; 261  :         //  Compute the base address for DMA based rotation (mirrored)    
; 262  :         switch( eRotation )

  00058	e3510000	 cmp         r1, #0
  0005c	0a000028	 beq         |$LN4@PhysicalAd|
  00060	e351005a	 cmp         r1, #0x5A
  00064	0a000030	 beq         |$LN5@PhysicalAd|
  00068	e35100b4	 cmp         r1, #0xB4
  0006c	0a00001a	 beq         |$LN2@PhysicalAd|
  00070	e3a03c01	 mov         r3, #1, 24
  00074	e383300e	 orr         r3, r3, #0xE
  00078	e1510003	 cmp         r1, r3
  0007c	0a000002	 beq         |$LN10@PhysicalAd|
  00080		 |$LN24@PhysicalAd|

; 300  :     
; 301  :             default:
; 302  :                 ASSERT(0);
; 303  :                 return 0;

  00080	e3a00000	 mov         r0, #0

; 351  :         }
; 352  :     }
; 353  :         
; 354  :     //  Return address
; 355  :     return dwAddr;
; 356  : }

  00084	e8bd4010	 ldmia       sp!, {r4, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$LN10@PhysicalAd|

; 263  :         {
; 264  :             case OMAP_DSS_ROTATION_0:
; 265  :                 //  Compute clip offset
; 266  :                 dwClipOffsetX = m_dwWidth - m_rcClip.right;
; 267  :                 dwClipOffsetY = m_rcClip.top * m_dwActualWidth;
; 268  : 
; 269  :                 //  Offset to the upper right corner
; 270  :                 dwAddr = m_dwPhysicalAddr + (m_dwWidth - dwClipOffsetX - 1)*m_dwPixelSize + dwClipOffsetY*m_dwPixelSize;
; 271  :                 break;
; 272  :                 
; 273  :             case OMAP_DSS_ROTATION_90:
; 274  :                 //  Compute clip offset
; 275  :                 dwClipOffsetX = m_rcClip.left;
; 276  :                 dwClipOffsetY = m_rcClip.top * m_dwActualWidth;
; 277  : 
; 278  :                 //  Same as set physical address
; 279  :                 dwAddr = m_dwPhysicalAddr + dwClipOffsetX*m_dwPixelSize + dwClipOffsetY*m_dwPixelSize;
; 280  :                 break;
; 281  : 
; 282  :             case OMAP_DSS_ROTATION_180:
; 283  :                 //  Compute clip offset
; 284  :                 dwClipOffsetX = m_rcClip.left;
; 285  :                 dwClipOffsetY = m_dwHeight - m_rcClip.bottom;
; 286  : 
; 287  :                 //  Offset to the lower left corner
; 288  :                 dwAddr = m_dwPhysicalAddr + (m_dwActualWidth * (m_dwHeight - dwClipOffsetY - 1))*m_dwPixelSize + dwClipOffsetX*m_dwPixelSize;
; 289  :                 break;
; 290  : 
; 291  :             case OMAP_DSS_ROTATION_270:
; 292  :                 //  Compute clip offset
; 293  :                 dwClipOffsetX = m_dwWidth - m_rcClip.right;
; 294  :                 dwClipOffsetY = (m_dwHeight - m_rcClip.bottom)*m_dwActualWidth;

  0008c	e5941014	 ldr         r1, [r4, #0x14]
  00090	e5943024	 ldr         r3, [r4, #0x24]
  00094	e59400ac	 ldr         r0, [r4, #0xAC]

; 295  : 
; 296  :                 //  Offset to the lower right corner
; 297  :                 dwAddr = m_dwPhysicalAddr + (m_dwActualWidth * m_dwHeight - 1)*m_dwPixelSize - (m_dwActualWidth - m_dwWidth)*m_dwPixelSize;
; 298  :                 dwAddr = dwAddr - dwClipOffsetX*m_dwPixelSize - dwClipOffsetY*m_dwPixelSize;

  00098	e5942020	 ldr         r2, [r4, #0x20]
  0009c	e0413003	 sub         r3, r1, r3
  000a0	e0413003	 sub         r3, r1, r3
  000a4	e2433001	 sub         r3, r3, #1
  000a8	e0212093	 mla         r1, r3, r0, r2
  000ac	e2413001	 sub         r3, r1, #1

; 299  :                 break;

  000b0	ea000018	 b           |$LN25@PhysicalAd|
  000b4		 |$LN16@PhysicalAd|

; 304  :         }
; 305  :     }
; 306  :     else
; 307  :     {
; 308  :         //  Compute the base address for DMA based rotation (non-mirrored)    
; 309  :         switch( eRotation )

  000b4	e3510000	 cmp         r1, #0
  000b8	0a00001b	 beq         |$LN5@PhysicalAd|
  000bc	e351005a	 cmp         r1, #0x5A
  000c0	0a00000f	 beq         |$LN4@PhysicalAd|
  000c4	e35100b4	 cmp         r1, #0xB4
  000c8	0affffef	 beq         |$LN10@PhysicalAd|
  000cc	e3a03c01	 mov         r3, #1, 24
  000d0	e383300e	 orr         r3, r3, #0xE
  000d4	e1510003	 cmp         r1, r3

; 346  :                 break;
; 347  : 
; 348  :             default:
; 349  :                 ASSERT(0);
; 350  :                 return 0;

  000d8	1affffe8	 bne         |$LN24@PhysicalAd|
  000dc		 |$LN2@PhysicalAd|

; 327  :                 break;
; 328  : 
; 329  :             case OMAP_DSS_ROTATION_180:
; 330  :                 //  Compute clip offset
; 331  :                 dwClipOffsetX = m_dwWidth - m_rcClip.right;
; 332  :                 dwClipOffsetY = (m_dwHeight - m_rcClip.bottom)*m_dwActualWidth;
; 333  : 
; 334  :                 //  Offset to the lower right corner
; 335  :                 dwAddr = m_dwPhysicalAddr + (m_dwActualWidth * m_dwHeight - 1)*m_dwPixelSize - (m_dwActualWidth - m_dwWidth)*m_dwPixelSize;
; 336  :                 dwAddr = dwAddr - dwClipOffsetX*m_dwPixelSize - dwClipOffsetY*m_dwPixelSize;
; 337  :                 break;
; 338  : 
; 339  :             case OMAP_DSS_ROTATION_270:
; 340  :                 //  Compute clip offset
; 341  :                 dwClipOffsetX = m_rcClip.left;
; 342  :                 dwClipOffsetY = m_dwHeight - m_rcClip.bottom;
; 343  : 
; 344  :                 //  Offset to the lower left corner
; 345  :                 dwAddr = m_dwPhysicalAddr + (m_dwActualWidth * (m_dwHeight - dwClipOffsetY - 1))*m_dwPixelSize + dwClipOffsetX*m_dwPixelSize;

  000dc	e5943024	 ldr         r3, [r4, #0x24]
  000e0	e59400ac	 ldr         r0, [r4, #0xAC]
  000e4	e5942018	 ldr         r2, [r4, #0x18]
  000e8	e2433001	 sub         r3, r3, #1
  000ec	e5941008	 ldr         r1, [r4, #8]
  000f0	e0222093	 mla         r2, r3, r0, r2
  000f4	e59430a8	 ldr         r3, [r4, #0xA8]
  000f8	e0203192	 mla         r0, r2, r1, r3

; 351  :         }
; 352  :     }
; 353  :         
; 354  :     //  Return address
; 355  :     return dwAddr;
; 356  : }

  000fc	e8bd4010	 ldmia       sp!, {r4, lr}
  00100	e12fff1e	 bx          lr
  00104		 |$LN4@PhysicalAd|

; 318  :                 break;
; 319  :                 
; 320  :             case OMAP_DSS_ROTATION_90:
; 321  :                 //  Compute clip offset
; 322  :                 dwClipOffsetX = m_dwWidth - m_rcClip.right;
; 323  :                 dwClipOffsetY = m_rcClip.top * m_dwActualWidth;

  00104	e594e0ac	 ldr         lr, [r4, #0xAC]
  00108	e594101c	 ldr         r1, [r4, #0x1C]

; 324  : 
; 325  :                 //  Offset to the upper right corner
; 326  :                 dwAddr = m_dwPhysicalAddr + (m_dwWidth - dwClipOffsetX - 1)*m_dwPixelSize + dwClipOffsetY*m_dwPixelSize;

  0010c	e5943020	 ldr         r3, [r4, #0x20]
  00110	e023319e	 mla         r3, lr, r1, r3
  00114	e2433001	 sub         r3, r3, #1
  00118		 |$LN25@PhysicalAd|
  00118	e5940008	 ldr         r0, [r4, #8]
  0011c	e59420a8	 ldr         r2, [r4, #0xA8]
  00120	e0202093	 mla         r0, r3, r0, r2

; 351  :         }
; 352  :     }
; 353  :         
; 354  :     //  Return address
; 355  :     return dwAddr;
; 356  : }

  00124	e8bd4010	 ldmia       sp!, {r4, lr}
  00128	e12fff1e	 bx          lr
  0012c		 |$LN5@PhysicalAd|

; 310  :         {
; 311  :             case OMAP_DSS_ROTATION_0:
; 312  :                 //  Compute clip offset
; 313  :                 dwClipOffsetX = m_rcClip.left;
; 314  :                 dwClipOffsetY = m_rcClip.top * m_dwActualWidth;
; 315  : 
; 316  :                 //  Same as set physical address
; 317  :                 dwAddr = m_dwPhysicalAddr + dwClipOffsetX*m_dwPixelSize + dwClipOffsetY*m_dwPixelSize;

  0012c	e5943018	 ldr         r3, [r4, #0x18]
  00130	e594001c	 ldr         r0, [r4, #0x1C]
  00134	e594e0ac	 ldr         lr, [r4, #0xAC]
  00138	e59420a8	 ldr         r2, [r4, #0xA8]
  0013c	e5941008	 ldr         r1, [r4, #8]
  00140	e023309e	 mla         r3, lr, r0, r3
  00144	e0202193	 mla         r0, r3, r1, r2

; 351  :         }
; 352  :     }
; 353  :         
; 354  :     //  Return address
; 355  :     return dwAddr;
; 356  : }

  00148	e8bd4010	 ldmia       sp!, {r4, lr}
  0014c	e12fff1e	 bx          lr
  00150		 |$M37484|

			 ENDP  ; |?PhysicalAddr@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@HW4OMAP_ASSOC_SURF_USAGE@@@Z|, OMAPFlatSurface::PhysicalAddr


  00000			 AREA	 |.pdata|, PDATA
|$T37505| DCD	|$LN27@PixelIncr|
	DCD	0x40003300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PixelIncr@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@H@Z| PROC ; OMAPFlatSurface::PixelIncr

; 364  : {

  00000		 |$LN27@PixelIncr|
  00000		 |$M37502|
  00000	e3520000	 cmp         r2, #0

; 365  :     DWORD   dwIncr;
; 366  :    
; 367  :     if( bMirror )

  00004	0a000014	 beq         |$LN16@PixelIncr|

; 368  :     {
; 369  :         //  Compute the pixel increment for DMA based rotation (mirrored)
; 370  :         switch( eRotation )

  00008	e3510000	 cmp         r1, #0
  0000c	0a00001d	 beq         |$LN3@PixelIncr|
  00010	e351005a	 cmp         r1, #0x5A
  00014	0a000024	 beq         |$LN4@PixelIncr|
  00018	e35100b4	 cmp         r1, #0xB4
  0001c	1a000014	 bne         |$LN24@PixelIncr|
  00020		 |$LN5@PixelIncr|

; 405  :         {
; 406  :             case OMAP_DSS_ROTATION_0:
; 407  :                 //  Forward 1 pixel (+ horizontal_scale_factor*pixel_size)
; 408  :                 dwIncr = 1;
; 409  :                 dwIncr += ((m_dwHorizScale - 1) * m_dwPixelSize * m_dwWidthFactor);

  00020	e5903028	 ldr         r3, [r0, #0x28]
  00024	e59020b4	 ldr         r2, [r0, #0xB4]
  00028	e5901008	 ldr         r1, [r0, #8]
  0002c	e2433001	 sub         r3, r3, #1
  00030	e0020293	 mul         r2, r3, r2
  00034	e0030192	 mul         r3, r2, r1
  00038	e2830001	 add         r0, r3, #1

; 433  :         }
; 434  :     }
; 435  :         
; 436  :     //  Return increment
; 437  :     return dwIncr;
; 438  : }

  0003c	e12fff1e	 bx          lr
  00040		 |$LN21@PixelIncr|

; 394  :                 break;
; 395  : 
; 396  :             default:
; 397  :                 ASSERT(0);
; 398  :                 return 0;

  00040	e3a00000	 mov         r0, #0

; 433  :         }
; 434  :     }
; 435  :         
; 436  :     //  Return increment
; 437  :     return dwIncr;
; 438  : }

  00044	e12fff1e	 bx          lr
  00048		 |$LN10@PixelIncr|

; 371  :         {
; 372  :             case OMAP_DSS_ROTATION_0:
; 373  :                 //  Backward 1 pixel (- horizontal_scale_factor*pixel_size)
; 374  :                 dwIncr = 1 - 2 * m_dwPixelSize;
; 375  :                 dwIncr -= ((m_dwHorizScale - 1) * m_dwPixelSize * m_dwWidthFactor);
; 376  :                 break;
; 377  :                 
; 378  :             case OMAP_DSS_ROTATION_90:
; 379  :                 //  Forward 1 row - 1 pixel (+ vertical_scale_factor*stride)
; 380  :                 dwIncr = 1 + m_dwActualWidth * m_dwPixelSize - m_dwPixelSize;
; 381  :                 dwIncr += ((m_dwVertScale - 1) * m_dwActualWidth * m_dwPixelSize);
; 382  :                 break;
; 383  : 
; 384  :             case OMAP_DSS_ROTATION_180:
; 385  :                 //  Forward 1 pixel (+ horizontal_scale_factor*pixel_size)
; 386  :                 dwIncr = 1;
; 387  :                 dwIncr += ((m_dwHorizScale - 1) * m_dwPixelSize * m_dwWidthFactor);
; 388  :                 break;
; 389  : 
; 390  :             case OMAP_DSS_ROTATION_270:
; 391  :                 //  Backward 1 row and 1 pixel (- vertical_scale_factor*stride)
; 392  :                 dwIncr = 1 - m_dwActualWidth * m_dwPixelSize - m_dwPixelSize;
; 393  :                 dwIncr -= ((m_dwVertScale - 1) * m_dwActualWidth * m_dwPixelSize);

  00048	e59020ac	 ldr         r2, [r0, #0xAC]
  0004c	e590302c	 ldr         r3, [r0, #0x2C]
  00050	e0030392	 mul         r3, r2, r3
  00054	e2833001	 add         r3, r3, #1
  00058	ea00000f	 b           |$LN22@PixelIncr|
  0005c		 |$LN16@PixelIncr|

; 399  :         }
; 400  :     }
; 401  :     else
; 402  :     {
; 403  :         //  Compute the pixel increment for DMA based rotation (non-mirrored)
; 404  :         switch( eRotation )

  0005c	e3510000	 cmp         r1, #0
  00060	0affffee	 beq         |$LN5@PixelIncr|
  00064	e351005a	 cmp         r1, #0x5A
  00068	0a00000f	 beq         |$LN4@PixelIncr|
  0006c	e35100b4	 cmp         r1, #0xB4
  00070	0a000004	 beq         |$LN3@PixelIncr|
  00074		 |$LN24@PixelIncr|
  00074	e3a03c01	 mov         r3, #1, 24
  00078	e383300e	 orr         r3, r3, #0xE
  0007c	e1510003	 cmp         r1, r3

; 429  : 
; 430  :             default:
; 431  :                 ASSERT(0);
; 432  :                 return 0;

  00080	1affffee	 bne         |$LN21@PixelIncr|

; 423  : 
; 424  :             case OMAP_DSS_ROTATION_270:
; 425  :                 //  Backward 1 row and 1 pixel (- vertical_scale_factor*stride)
; 426  :                 dwIncr = 1 - m_dwActualWidth * m_dwPixelSize - m_dwPixelSize;
; 427  :                 dwIncr -= ((m_dwVertScale - 1) * m_dwActualWidth * m_dwPixelSize);
; 428  :                 break;

  00084	eaffffef	 b           |$LN10@PixelIncr|
  00088		 |$LN3@PixelIncr|

; 410  :                 break;
; 411  :                 
; 412  :             case OMAP_DSS_ROTATION_90:
; 413  :                 //  Forward 1 row - 1 pixel (+ vertical_scale_factor*stride)
; 414  :                 dwIncr = 1 + m_dwActualWidth * m_dwPixelSize - m_dwPixelSize;
; 415  :                 dwIncr += ((m_dwVertScale - 1) * m_dwActualWidth * m_dwPixelSize);
; 416  :                 break;
; 417  : 
; 418  :             case OMAP_DSS_ROTATION_180:
; 419  :                 //  Backward 1 pixel (- horizontal_scale_factor*pixel_size)
; 420  :                 dwIncr = 1 - 2 * m_dwPixelSize;
; 421  :                 dwIncr -= ((m_dwHorizScale - 1) * m_dwPixelSize * m_dwWidthFactor);

  00088	e5903028	 ldr         r3, [r0, #0x28]
  0008c	e59020b4	 ldr         r2, [r0, #0xB4]
  00090	e2433001	 sub         r3, r3, #1
  00094	e0020293	 mul         r2, r3, r2
  00098	e2823002	 add         r3, r2, #2
  0009c		 |$LN22@PixelIncr|
  0009c	e5901008	 ldr         r1, [r0, #8]
  000a0	e0020193	 mul         r2, r3, r1
  000a4	e2620001	 rsb         r0, r2, #1

; 433  :         }
; 434  :     }
; 435  :         
; 436  :     //  Return increment
; 437  :     return dwIncr;
; 438  : }

  000a8	e12fff1e	 bx          lr
  000ac		 |$LN4@PixelIncr|

; 422  :                 break;

  000ac	e59020ac	 ldr         r2, [r0, #0xAC]
  000b0	e590302c	 ldr         r3, [r0, #0x2C]
  000b4	e5901008	 ldr         r1, [r0, #8]
  000b8	e0030392	 mul         r3, r2, r3
  000bc	e2433001	 sub         r3, r3, #1
  000c0	e0020193	 mul         r2, r3, r1
  000c4	e2820001	 add         r0, r2, #1

; 433  :         }
; 434  :     }
; 435  :         
; 436  :     //  Return increment
; 437  :     return dwIncr;
; 438  : }

  000c8	e12fff1e	 bx          lr
  000cc		 |$M37503|

			 ENDP  ; |?PixelIncr@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@H@Z|, OMAPFlatSurface::PixelIncr


  00000			 AREA	 |.pdata|, PDATA
|$T37527| DCD	|$LN31@RowIncr|
	DCD	0x40009301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?RowIncr@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@H@Z| PROC ; OMAPFlatSurface::RowIncr

; 446  : {

  00000		 |$LN31@RowIncr|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37524|
  00004	e1a05000	 mov         r5, r0

; 447  :     DWORD   dwIncr;
; 448  :     DWORD   dwClipOffsetX,
; 449  :             dwClipOffsetY;
; 450  : 
; 451  :     if ((m_bUseResizer) && (m_eSurfaceType == OMAP_SURFACE_NORMAL) && (m_pAssocSurface))

  00008	e5953030	 ldr         r3, [r5, #0x30]
  0000c	e3530000	 cmp         r3, #0
  00010	0a00000c	 beq         |$LN17@RowIncr|
  00014	e595309c	 ldr         r3, [r5, #0x9C]
  00018	e3530000	 cmp         r3, #0
  0001c	1a000009	 bne         |$LN17@RowIncr|
  00020	e59530a0	 ldr         r3, [r5, #0xA0]
  00024	e3530000	 cmp         r3, #0
  00028	0a000006	 beq         |$LN17@RowIncr|

; 452  :         return m_pAssocSurface->RowIncr(eRotation,bMirror);

  0002c	e1a00003	 mov         r0, r3
  00030	e5903000	 ldr         r3, [r0]
  00034	e593301c	 ldr         r3, [r3, #0x1C]
  00038	e1a0e00f	 mov         lr, pc
  0003c	e12fff13	 bx          r3

; 572  :         }
; 573  :     }
; 574  :         
; 575  :     //  Return increment
; 576  :     return dwIncr;
; 577  : }

  00040	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$LN17@RowIncr|

; 453  :     
; 454  :     if( bMirror )

  00048	e3520000	 cmp         r2, #0
  0004c	0a000047	 beq         |$LN16@RowIncr|

; 455  :     {
; 456  :         //  Compute the row increment for DMA based rotation (mirrored)
; 457  :         switch( eRotation )

  00050	e3510000	 cmp         r1, #0
  00054	0a000037	 beq         |$LN13@RowIncr|
  00058	e351005a	 cmp         r1, #0x5A
  0005c	0a000027	 beq         |$LN12@RowIncr|
  00060	e35100b4	 cmp         r1, #0xB4
  00064	0a000014	 beq         |$LN11@RowIncr|
  00068	e3a03c01	 mov         r3, #1, 24
  0006c	e383300e	 orr         r3, r3, #0xE
  00070	e1510003	 cmp         r1, r3
  00074	0a000002	 beq         |$LN10@RowIncr|
  00078		 |$LN25@RowIncr|

; 508  : 
; 509  :             default:
; 510  :                 ASSERT(0);
; 511  :                 return 0;

  00078	e3a00000	 mov         r0, #0

; 572  :         }
; 573  :     }
; 574  :         
; 575  :     //  Return increment
; 576  :     return dwIncr;
; 577  : }

  0007c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00080	e12fff1e	 bx          lr
  00084		 |$LN10@RowIncr|

; 495  : 
; 496  :             case OMAP_DSS_ROTATION_270:
; 497  :                 //  Compute clip offset
; 498  :                 dwClipOffsetY = m_dwHeight - (m_rcClip.bottom - m_rcClip.top);
; 499  : 
; 500  :                 //  Forward 1 frame - 1 row - 1 pixel
; 501  :                 dwIncr = 1 + (m_dwActualWidth * m_dwHeight * m_dwPixelSize) - (m_dwActualWidth * m_dwPixelSize) - (2 * m_dwPixelSize);
; 502  :                 dwIncr = dwIncr - (dwClipOffsetY * m_dwActualWidth * m_dwPixelSize);
; 503  : 
; 504  :                 //  (- vertical_scale_factor*stride - horizontal_scale_factor*pixel_size)
; 505  :                 dwIncr -= ((m_dwVertScale - 1) * m_dwActualWidth * m_dwPixelSize);
; 506  :                 dwIncr -= ((m_dwHorizScale - 1) * m_dwPixelSize * m_dwWidthFactor);                

  00084	e5952024	 ldr         r2, [r5, #0x24]
  00088	e595302c	 ldr         r3, [r5, #0x2C]
  0008c	e595e01c	 ldr         lr, [r5, #0x1C]
  00090	e0423003	 sub         r3, r2, r3
  00094	e043300e	 sub         r3, r3, lr
  00098		 |$LN28@RowIncr|
  00098	e5954028	 ldr         r4, [r5, #0x28]
  0009c	e59510ac	 ldr         r1, [r5, #0xAC]
  000a0	e59500b4	 ldr         r0, [r5, #0xB4]
  000a4	e2442001	 sub         r2, r4, #1
  000a8	e0010193	 mul         r1, r3, r1
  000ac	e0030092	 mul         r3, r2, r0
  000b0	e0413003	 sub         r3, r1, r3
  000b4	e2433002	 sub         r3, r3, #2

; 507  :                 break;

  000b8	ea00005e	 b           |$LN20@RowIncr|
  000bc		 |$LN11@RowIncr|

; 483  : 
; 484  :             case OMAP_DSS_ROTATION_180:
; 485  :                 //  Compute clip offset
; 486  :                 dwClipOffsetX = m_dwWidth - (m_rcClip.right - m_rcClip.left);
; 487  : 
; 488  :                 //  Backward 2 rows
; 489  :                 dwIncr = 1 - (m_dwActualWidth * m_dwPixelSize) - ((m_dwWidth - dwClipOffsetX) * m_dwPixelSize);
; 490  : 
; 491  :                 //  (- vertical_scale_factor*stride + horizontal_scale_factor*pixel_size)
; 492  :                 dwIncr -= ((m_dwVertScale - 1) * m_dwActualWidth * m_dwPixelSize);

  000bc	e595302c	 ldr         r3, [r5, #0x2C]

; 493  :                 dwIncr += ((m_dwHorizScale - 1) * m_dwPixelSize * m_dwWidthFactor);

  000c0	e5952028	 ldr         r2, [r5, #0x28]
  000c4	e59500ac	 ldr         r0, [r5, #0xAC]
  000c8	e59510b4	 ldr         r1, [r5, #0xB4]
  000cc	e2433001	 sub         r3, r3, #1
  000d0	e2833001	 add         r3, r3, #1
  000d4	e2422001	 sub         r2, r2, #1
  000d8	e00e0093	 mul         lr, r3, r0
  000dc	e0030192	 mul         r3, r2, r1
  000e0	e5952020	 ldr         r2, [r5, #0x20]
  000e4	e5951018	 ldr         r1, [r5, #0x18]
  000e8	e043300e	 sub         r3, r3, lr
  000ec	e0433002	 sub         r3, r3, r2
  000f0	e0833001	 add         r3, r3, r1
  000f4		 |$LN26@RowIncr|
  000f4	e5950008	 ldr         r0, [r5, #8]
  000f8	e0020093	 mul         r2, r3, r0

; 494  :                 break;

  000fc	ea00004f	 b           |$LN21@RowIncr|
  00100		 |$LN12@RowIncr|

; 469  :                 break;
; 470  :                 
; 471  :             case OMAP_DSS_ROTATION_90:
; 472  :                 //  Compute clip offset
; 473  :                 dwClipOffsetY = m_dwHeight - (m_rcClip.bottom - m_rcClip.top);
; 474  : 
; 475  :                 //  Backward 1 frame + 1 row
; 476  :                 dwIncr = 1 - (m_dwActualWidth * m_dwHeight * m_dwPixelSize) + (m_dwActualWidth * m_dwPixelSize);
; 477  :                 dwIncr = dwIncr + (dwClipOffsetY * m_dwActualWidth * m_dwPixelSize);
; 478  : 
; 479  :                 //  (+ vertical_scale_factor*stride + horizontal_scale_factor*pixel_size)
; 480  :                 dwIncr += ((m_dwVertScale - 1) * m_dwActualWidth * m_dwPixelSize);
; 481  :                 dwIncr += ((m_dwHorizScale - 1) * m_dwPixelSize * m_dwWidthFactor);

  00100	e595102c	 ldr         r1, [r5, #0x2C]
  00104	e5953024	 ldr         r3, [r5, #0x24]
  00108	e595201c	 ldr         r2, [r5, #0x1C]
  0010c	e0413003	 sub         r3, r1, r3
  00110	e0833002	 add         r3, r3, r2
  00114		 |$LN27@RowIncr|
  00114	e59500ac	 ldr         r0, [r5, #0xAC]
  00118	e5952028	 ldr         r2, [r5, #0x28]
  0011c	e5951008	 ldr         r1, [r5, #8]
  00120	e0000093	 mul         r0, r3, r0
  00124	e59530b4	 ldr         r3, [r5, #0xB4]
  00128	e2422001	 sub         r2, r2, #1
  0012c	e0230392	 mla         r3, r2, r3, r0
  00130	e0020193	 mul         r2, r3, r1

; 482  :                 break;

  00134	ea000041	 b           |$LN21@RowIncr|
  00138		 |$LN13@RowIncr|

; 458  :         {
; 459  :             case OMAP_DSS_ROTATION_0:
; 460  :                 //  Compute clip offset
; 461  :                 dwClipOffsetX = m_dwWidth - (m_rcClip.right - m_rcClip.left);
; 462  : 
; 463  :                 //  Forward 2 rows - 1 pixel
; 464  :                 dwIncr = 1 + (m_dwActualWidth * m_dwPixelSize) + ((m_dwWidth - dwClipOffsetX) * m_dwPixelSize) - (2 * m_dwPixelSize);
; 465  : 
; 466  :                 //  (+ vertical_scale_factor*stride - horizontal_scale_factor*pixel_size) 
; 467  :                 dwIncr += ((m_dwVertScale - 1) * m_dwActualWidth * m_dwPixelSize);
; 468  :                 dwIncr -= ((m_dwHorizScale - 1) * m_dwPixelSize * m_dwWidthFactor);

  00138	e5953028	 ldr         r3, [r5, #0x28]
  0013c	e59510b4	 ldr         r1, [r5, #0xB4]
  00140	e59500ac	 ldr         r0, [r5, #0xAC]
  00144	e595202c	 ldr         r2, [r5, #0x2C]
  00148	e2433001	 sub         r3, r3, #1
  0014c	e00e0193	 mul         lr, r3, r1
  00150	e0030290	 mul         r3, r0, r2
  00154	e5952018	 ldr         r2, [r5, #0x18]
  00158	e5951020	 ldr         r1, [r5, #0x20]
  0015c	e043300e	 sub         r3, r3, lr
  00160	e0433002	 sub         r3, r3, r2
  00164	e0833001	 add         r3, r3, r1
  00168	e2433002	 sub         r3, r3, #2

; 512  :         }
; 513  :     }
; 514  :     else

  0016c	eaffffe0	 b           |$LN26@RowIncr|
  00170		 |$LN16@RowIncr|

; 515  :     {
; 516  :         //  Compute the row increment for DMA based rotation (non-mirrored)
; 517  :         switch( eRotation )

  00170	e3510000	 cmp         r1, #0
  00174	0a000024	 beq         |$LN5@RowIncr|
  00178	e351005a	 cmp         r1, #0x5A
  0017c	0a00001c	 beq         |$LN4@RowIncr|
  00180	e35100b4	 cmp         r1, #0xB4
  00184	0a000009	 beq         |$LN3@RowIncr|
  00188	e3a03c01	 mov         r3, #1, 24
  0018c	e383300e	 orr         r3, r3, #0xE
  00190	e1510003	 cmp         r1, r3

; 554  :                 break;
; 555  : 
; 556  :             case OMAP_DSS_ROTATION_270:
; 557  :                 //  Compute clip offset
; 558  :                 dwClipOffsetY = m_dwHeight - (m_rcClip.bottom - m_rcClip.top);
; 559  : 
; 560  :                 //  Forward 1 frame - 1 row + 1 pixel
; 561  :                 dwIncr = 1 + (m_dwActualWidth * m_dwHeight * m_dwPixelSize) - (m_dwActualWidth * m_dwPixelSize);
; 562  :                 dwIncr = dwIncr - (dwClipOffsetY * m_dwActualWidth * m_dwPixelSize);
; 563  : 
; 564  :                 //  (- vertical_scale_factor*stride + horizontal_scale_factor*pixel_size)
; 565  :                 dwIncr -= ((m_dwVertScale - 1) * m_dwActualWidth * m_dwPixelSize);
; 566  :                 dwIncr += ((m_dwHorizScale - 1) * m_dwPixelSize * m_dwWidthFactor);                
; 567  :                 break;
; 568  : 
; 569  :             default:
; 570  :                 ASSERT(0);
; 571  :                 return 0;

  00194	1affffb7	 bne         |$LN25@RowIncr|
  00198	e5951024	 ldr         r1, [r5, #0x24]
  0019c	e595302c	 ldr         r3, [r5, #0x2C]
  001a0	e595201c	 ldr         r2, [r5, #0x1C]
  001a4	e0413003	 sub         r3, r1, r3
  001a8	e0433002	 sub         r3, r3, r2
  001ac	eaffffd8	 b           |$LN27@RowIncr|
  001b0		 |$LN3@RowIncr|

; 543  : 
; 544  :             case OMAP_DSS_ROTATION_180:
; 545  :                 //  Compute clip offset
; 546  :                 dwClipOffsetX = m_dwWidth - (m_rcClip.right - m_rcClip.left);
; 547  : 
; 548  :                 //  Backward 1 pixel on previous row
; 549  :                 dwIncr = 1 - 2 * m_dwPixelSize - (m_dwActualWidth - m_dwWidth + dwClipOffsetX) * m_dwPixelSize;
; 550  : 
; 551  :                 //  (- vertical_scale_factor*stride - horizontal_scale_factor*pixel_size)
; 552  :                 dwIncr -= ((m_dwVertScale - 1) * m_dwActualWidth * m_dwPixelSize);
; 553  :                 dwIncr -= ((m_dwHorizScale - 1) * m_dwPixelSize * m_dwWidthFactor);

  001b0	e5953028	 ldr         r3, [r5, #0x28]
  001b4	e59520b4	 ldr         r2, [r5, #0xB4]
  001b8	e595e0ac	 ldr         lr, [r5, #0xAC]
  001bc	e2433001	 sub         r3, r3, #1
  001c0	e0020293	 mul         r2, r3, r2
  001c4	e595302c	 ldr         r3, [r5, #0x2C]
  001c8	e5951020	 ldr         r1, [r5, #0x20]
  001cc	e5950018	 ldr         r0, [r5, #0x18]
  001d0	e023239e	 mla         r3, lr, r3, r2
  001d4	e5952008	 ldr         r2, [r5, #8]
  001d8	e0433001	 sub         r3, r3, r1
  001dc	e0833000	 add         r3, r3, r0
  001e0	e2833002	 add         r3, r3, #2
  001e4	e0020293	 mul         r2, r3, r2
  001e8	e2620001	 rsb         r0, r2, #1

; 572  :         }
; 573  :     }
; 574  :         
; 575  :     //  Return increment
; 576  :     return dwIncr;
; 577  : }

  001ec	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  001f0	e12fff1e	 bx          lr
  001f4		 |$LN4@RowIncr|

; 529  :                 break;
; 530  :                 
; 531  :             case OMAP_DSS_ROTATION_90:
; 532  :                 //  Compute clip offset
; 533  :                 dwClipOffsetY = m_dwHeight - (m_rcClip.bottom - m_rcClip.top);
; 534  : 
; 535  :                 //  Backward 1 frame + 1 row - 1 pixel
; 536  :                 dwIncr = 1 - (m_dwActualWidth * m_dwHeight * m_dwPixelSize) + (m_dwActualWidth * m_dwPixelSize) - (2 * m_dwPixelSize);
; 537  :                 dwIncr = dwIncr + (dwClipOffsetY * m_dwActualWidth * m_dwPixelSize);
; 538  :                 
; 539  :                 //  (+ vertical_scale_factor*stride - horizontal_scale_factor*pixel_size)
; 540  :                 dwIncr += ((m_dwVertScale - 1) * m_dwActualWidth * m_dwPixelSize);
; 541  :                 dwIncr -= ((m_dwHorizScale - 1) * m_dwPixelSize * m_dwWidthFactor);

  001f4	e595202c	 ldr         r2, [r5, #0x2C]
  001f8	e5953024	 ldr         r3, [r5, #0x24]
  001fc	e595e01c	 ldr         lr, [r5, #0x1C]
  00200	e0423003	 sub         r3, r2, r3
  00204	e083300e	 add         r3, r3, lr

; 542  :                 break;

  00208	eaffffa2	 b           |$LN28@RowIncr|
  0020c		 |$LN5@RowIncr|

; 518  :         {
; 519  :             case OMAP_DSS_ROTATION_0:
; 520  :                 //  Compute clip offset
; 521  :                 dwClipOffsetX = m_dwWidth - (m_rcClip.right - m_rcClip.left);
; 522  : 
; 523  :                 //  Forward 1 pixel on next row
; 524  :                 dwIncr = 1 + (m_dwActualWidth - m_dwWidth + dwClipOffsetX) * m_dwPixelSize;
; 525  :                 
; 526  :                 //  (+ vertical_scale_factor*stride + horizontal_scale_factor*pixel_size) 
; 527  :                 dwIncr += ((m_dwVertScale - 1) * m_dwActualWidth * m_dwPixelSize);
; 528  :                 dwIncr += ((m_dwHorizScale - 1) * m_dwPixelSize * m_dwWidthFactor);

  0020c	e5953028	 ldr         r3, [r5, #0x28]
  00210	e59520b4	 ldr         r2, [r5, #0xB4]
  00214	e595e0ac	 ldr         lr, [r5, #0xAC]
  00218	e2433001	 sub         r3, r3, #1
  0021c	e0020293	 mul         r2, r3, r2
  00220	e595302c	 ldr         r3, [r5, #0x2C]
  00224	e5951020	 ldr         r1, [r5, #0x20]
  00228	e5950018	 ldr         r0, [r5, #0x18]
  0022c	e023239e	 mla         r3, lr, r3, r2
  00230	e0433001	 sub         r3, r3, r1
  00234	e0833000	 add         r3, r3, r0
  00238		 |$LN20@RowIncr|
  00238	e5952008	 ldr         r2, [r5, #8]
  0023c	e0020293	 mul         r2, r3, r2
  00240		 |$LN21@RowIncr|
  00240	e2820001	 add         r0, r2, #1

; 572  :         }
; 573  :     }
; 574  :         
; 575  :     //  Return increment
; 576  :     return dwIncr;
; 577  : }

  00244	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00248	e12fff1e	 bx          lr
  0024c		 |$M37525|

			 ENDP  ; |?RowIncr@OMAPFlatSurface@@UAAKW4OMAP_DSS_ROTATION@@H@Z|, OMAPFlatSurface::RowIncr


  00000			 AREA	 |.pdata|, PDATA
|$T37540| DCD	|$LN7@SetOrienta|
	DCD	0x40002101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetOrientation@OMAPFlatSurface@@UAAHW4OMAP_SURF_ORIENTATION@@@Z| PROC ; OMAPFlatSurface::SetOrientation

; 585  : {

  00000		 |$LN7@SetOrienta|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M37537|
  00004	e1a06001	 mov         r6, r1
  00008	e1a05000	 mov         r5, r0

; 586  :     DWORD   oldWidth = m_dwWidth,
; 587  :             oldHeight = m_dwHeight,
; 588  :             oldActualWidth = m_dwActualWidth,
; 589  :             oldActualHeight = m_dwActualHeight;
; 590  :     
; 591  :     //  Do nothing if orientation is the same
; 592  :     if( eOrientation == m_eOrientation )

  0000c	e595300c	 ldr         r3, [r5, #0xC]
  00010	e5957010	 ldr         r7, [r5, #0x10]
  00014	e59580ac	 ldr         r8, [r5, #0xAC]
  00018	e1560003	 cmp         r6, r3

; 593  :         return TRUE;

  0001c	0a000015	 beq         |$LN1@SetOrienta|

; 594  : 
; 595  :     //  Swap width and height parameters
; 596  :     m_eOrientation   = eOrientation;
; 597  :     m_dwWidth        = oldHeight;
; 598  :     m_dwHeight       = oldWidth;
; 599  :     m_dwActualWidth  = oldActualHeight;
; 600  :     m_dwActualHeight = oldActualWidth;
; 601  :     
; 602  :     //  Reset clipping rect
; 603  :     SetClipping( NULL );

  00020	e5953000	 ldr         r3, [r5]
  00024	e5952014	 ldr         r2, [r5, #0x14]
  00028	e59540b0	 ldr         r4, [r5, #0xB0]
  0002c	e5933020	 ldr         r3, [r3, #0x20]
  00030	e5852010	 str         r2, [r5, #0x10]
  00034	e58540ac	 str         r4, [r5, #0xAC]
  00038	e3a01000	 mov         r1, #0
  0003c	e585600c	 str         r6, [r5, #0xC]
  00040	e5857014	 str         r7, [r5, #0x14]
  00044	e58580b0	 str         r8, [r5, #0xB0]
  00048	e1a0e00f	 mov         lr, pc
  0004c	e12fff13	 bx          r3

; 604  : 
; 605  :     if ((m_pAssocSurface) && (m_eSurfaceType==OMAP_SURFACE_NORMAL))

  00050	e59530a0	 ldr         r3, [r5, #0xA0]
  00054	e1b00003	 movs        r0, r3
  00058	0a000006	 beq         |$LN1@SetOrienta|
  0005c	e595309c	 ldr         r3, [r5, #0x9C]
  00060	e3530000	 cmp         r3, #0

; 606  :         m_pAssocSurface->SetOrientation(eOrientation);

  00064	05903000	 ldreq       r3, [r0]
  00068	01a01006	 moveq       r1, r6
  0006c	05933038	 ldreq       r3, [r3, #0x38]
  00070	01a0e00f	 moveq       lr, pc
  00074	012fff13	 bxeq        r3
  00078		 |$LN1@SetOrienta|

; 607  :     
; 608  :     return TRUE;

  00078	e3a00001	 mov         r0, #1

; 609  : }

  0007c	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00080	e12fff1e	 bx          lr
  00084		 |$M37538|

			 ENDP  ; |?SetOrientation@OMAPFlatSurface@@UAAHW4OMAP_SURF_ORIENTATION@@@Z|, OMAPFlatSurface::SetOrientation

	EXPORT	|??0OMAPFlatSurfaceManager@@QAA@XZ|	; OMAPFlatSurfaceManager::OMAPFlatSurfaceManager
	EXPORT	|??_7OMAPFlatSurfaceManager@@6B@| [ DATA ] ; OMAPFlatSurfaceManager::`vftable'
	EXPORT	|?Initialize@OMAPFlatSurfaceManager@@UAAHK@Z| ; OMAPFlatSurfaceManager::Initialize
	EXPORT	|?TotalMemorySize@OMAPFlatSurfaceManager@@UAAKXZ| ; OMAPFlatSurfaceManager::TotalMemorySize
	EXPORT	|?FreeMemorySize@OMAPFlatSurfaceManager@@UAAKXZ| ; OMAPFlatSurfaceManager::FreeMemorySize
	EXPORT	|?VirtualBaseAddr@OMAPFlatSurfaceManager@@UAAPAXXZ| ; OMAPFlatSurfaceManager::VirtualBaseAddr
	EXPORT	|?NumPhysicalAddr@OMAPFlatSurfaceManager@@UAAKXZ| ; OMAPFlatSurfaceManager::NumPhysicalAddr
	EXPORT	|?PhysicalLen@OMAPFlatSurfaceManager@@UAAKK@Z| ; OMAPFlatSurfaceManager::PhysicalLen
	EXPORT	|?PhysicalAddr@OMAPFlatSurfaceManager@@UAAKK@Z| ; OMAPFlatSurfaceManager::PhysicalAddr
	EXPORT	|?SupportsRotation@OMAPFlatSurfaceManager@@UAAHXZ| ; OMAPFlatSurfaceManager::SupportsRotation
	EXPORT	|?SupportsOffscreenSurfaces@OMAPFlatSurfaceManager@@UAAHXZ| ; OMAPFlatSurfaceManager::SupportsOffscreenSurfaces
	EXPORT	|?Allocate@OMAPFlatSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@PAV3@@Z| ; OMAPFlatSurfaceManager::Allocate
	EXPORT	|?Allocate@OMAPFlatSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@@Z| ; OMAPFlatSurfaceManager::Allocate
	EXPORT	|?AllocateGDI@OMAPFlatSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@@Z| ; OMAPFlatSurfaceManager::AllocateGDI
	IMPORT	|??_EOMAPFlatSurfaceManager@@UAAPAXI@Z|, WEAK |??_GOMAPFlatSurfaceManager@@UAAPAXI@Z| ; OMAPFlatSurfaceManager::`vector deleting destructor', OMAPFlatSurfaceManager::`scalar deleting destructor'
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\inc\dssai.h

  00000			 AREA	 |.pdata|, PDATA
|$T37553| DCD	|$LN7@OMAPFlatSu@3|
	DCD	0x40000c00

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7OMAPFlatSurfaceManager@@6B@| DCD |??_EOMAPFlatSurfaceManager@@UAAPAXI@Z| ; OMAPFlatSurfaceManager::`vftable'
	DCD	|?Initialize@OMAPFlatSurfaceManager@@UAAHK@Z|
	DCD	|?TotalMemorySize@OMAPFlatSurfaceManager@@UAAKXZ|
	DCD	|?FreeMemorySize@OMAPFlatSurfaceManager@@UAAKXZ|
	DCD	|?VirtualBaseAddr@OMAPFlatSurfaceManager@@UAAPAXXZ|
	DCD	|?NumPhysicalAddr@OMAPFlatSurfaceManager@@UAAKXZ|
	DCD	|?PhysicalLen@OMAPFlatSurfaceManager@@UAAKK@Z|
	DCD	|?PhysicalAddr@OMAPFlatSurfaceManager@@UAAKK@Z|
	DCD	|?SupportsRotation@OMAPFlatSurfaceManager@@UAAHXZ|
	DCD	|?SupportsOffscreenSurfaces@OMAPFlatSurfaceManager@@UAAHXZ|
	DCD	|?Allocate@OMAPFlatSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@PAV3@@Z|
	DCD	|?Allocate@OMAPFlatSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@@Z|
	DCD	|?AllocateGDI@OMAPFlatSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@@Z|
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\surfmgr_flat.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0OMAPFlatSurfaceManager@@QAA@XZ| PROC ; OMAPFlatSurfaceManager::OMAPFlatSurfaceManager

; 614  : {

  00000		 |$LN7@OMAPFlatSu@3|
  00000		 |$M37550|
  00000	e59f3024	 ldr         r3, [pc, #0x24]

; 615  :     //  Initialize properties
; 616  :     m_pVirtualDisplayBuffer = NULL;

  00004	e3a02000	 mov         r2, #0
  00008	e5802010	 str         r2, [r0, #0x10]
  0000c	e5803000	 str         r3, [r0]

; 617  :     m_hHeap = NULL;

  00010	e5802004	 str         r2, [r0, #4]

; 618  :     m_dwDisplayBufferSize = 0;

  00014	e5802008	 str         r2, [r0, #8]

; 619  :     m_dwPhysicalDisplayAddr = 0;

  00018	e580200c	 str         r2, [r0, #0xC]

; 620  : 
; 621  :     m_hOffscreenHeap = NULL;

  0001c	e5802014	 str         r2, [r0, #0x14]

; 622  :     m_pOffscreenBuffer = NULL;

  00020	e5802018	 str         r2, [r0, #0x18]

; 623  :     m_dwOffscreenPhysical = 0;

  00024	e580201c	 str         r2, [r0, #0x1C]

; 624  : }

  00028	e12fff1e	 bx          lr
  0002c		 |$LN8@OMAPFlatSu@3|
  0002c		 |$LN9@OMAPFlatSu@3|
  0002c	00000000	 DCD         |??_7OMAPFlatSurfaceManager@@6B@|
  00030		 |$M37551|

			 ENDP  ; |??0OMAPFlatSurfaceManager@@QAA@XZ|, OMAPFlatSurfaceManager::OMAPFlatSurfaceManager

; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\inc\dssai.h

  00000			 AREA	 |.pdata|, PDATA
|$T37564| DCD	|$LN5@SupportsRo|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SupportsRotation@OMAPFlatSurfaceManager@@UAAHXZ| PROC ; OMAPFlatSurfaceManager::SupportsRotation

; 1227 :     BOOL        SupportsRotation() { return TRUE; }

  00000		 |$LN5@SupportsRo|
  00000		 |$M37561|
  00000	e3a00001	 mov         r0, #1
  00004	e12fff1e	 bx          lr
  00008		 |$M37562|

			 ENDP  ; |?SupportsRotation@OMAPFlatSurfaceManager@@UAAHXZ|, OMAPFlatSurfaceManager::SupportsRotation

	EXPORT	|??1OMAPFlatSurfaceManager@@UAA@XZ|	; OMAPFlatSurfaceManager::~OMAPFlatSurfaceManager
	IMPORT	|VirtualFree|

  00000			 AREA	 |.pdata|, PDATA
|$T37577| DCD	|$LN11@OMAPFlatSu@4|
	DCD	0x40001e01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\surfmgr_flat.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1OMAPFlatSurfaceManager@@UAA@XZ| PROC ; OMAPFlatSurfaceManager::~OMAPFlatSurfaceManager

; 628  : {

  00000		 |$LN11@OMAPFlatSu@4|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37574|
  00004	e1a04000	 mov         r4, r0

; 629  :     Heap*   pHeap = (Heap*) m_hHeap;

  00008	e5942004	 ldr         r2, [r4, #4]
  0000c	e59f3060	 ldr         r3, [pc, #0x60]

; 630  :     Heap*   pOffscreenHeap = (Heap*) m_hOffscreenHeap;

  00010	e5945014	 ldr         r5, [r4, #0x14]
  00014	e3520000	 cmp         r2, #0

; 631  :     
; 632  :     //  Free the heap manager
; 633  :     if( pHeap )
; 634  :         pHeap->Free();

  00018	11a00002	 movne       r0, r2
  0001c	e5843000	 str         r3, [r4]
  00020	1b000000	 blne        |?Free@Heap@@QAAXXZ|

; 635  :         
; 636  :     //  Free memory
; 637  :     if( m_pVirtualDisplayBuffer ) 

  00024	e5943010	 ldr         r3, [r4, #0x10]
  00028	e3530000	 cmp         r3, #0

; 638  :         VirtualFree( m_pVirtualDisplayBuffer, 0, MEM_RELEASE );

  0002c	13a02902	 movne       r2, #2, 18
  00030	13a01000	 movne       r1, #0
  00034	11a00003	 movne       r0, r3
  00038	1b000000	 blne        VirtualFree

; 639  :         
; 640  :     //  Free the offscreen heap manager
; 641  :     if( pOffscreenHeap )

  0003c	e3550000	 cmp         r5, #0

; 642  :         pOffscreenHeap->Free();

  00040	11a00005	 movne       r0, r5
  00044	1b000000	 blne        |?Free@Heap@@QAAXXZ|

; 643  :         
; 644  :     //  Free offscreen memory
; 645  :     if( m_pOffscreenBuffer ) 

  00048	e5943018	 ldr         r3, [r4, #0x18]
  0004c	e3530000	 cmp         r3, #0

; 646  :         VirtualFree( m_pOffscreenBuffer, 0, MEM_RELEASE );

  00050	13a02902	 movne       r2, #2, 18
  00054	13a01000	 movne       r1, #0
  00058	11a00003	 movne       r0, r3
  0005c	1b000000	 blne        VirtualFree

; 647  : }

  00060	e59f3008	 ldr         r3, [pc, #8]
  00064	e5843000	 str         r3, [r4]
  00068	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0006c	e12fff1e	 bx          lr
  00070		 |$LN12@OMAPFlatSu@4|
  00070		 |$LN13@OMAPFlatSu@4|
  00070	00000000	 DCD         |??_7OMAPSurfaceManager@@6B@|
  00074		 |$LN14@OMAPFlatSu@4|
  00074	00000000	 DCD         |??_7OMAPFlatSurfaceManager@@6B@|
  00078		 |$M37575|

			 ENDP  ; |??1OMAPFlatSurfaceManager@@UAA@XZ|, OMAPFlatSurfaceManager::~OMAPFlatSurfaceManager

	IMPORT	|??0Heap@@QAA@KKPAV0@0@Z|		; Heap::Heap
	IMPORT	|??2@YAPAXI@Z|				; operator new
	IMPORT	|VirtualCopy|
	IMPORT	|VirtualAlloc|
	IMPORT	|LcdPdd_GetMemory|
; File c:\wince600\public\common\oak\inc\pkfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T37621| DCD	|$LN34@Initialize|
	DCD	0x40007d02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\surfmgr_flat.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Initialize@OMAPFlatSurfaceManager@@UAAHK@Z| PROC ; OMAPFlatSurfaceManager::Initialize

; 654  : {

  00000		 |$LN34@Initialize|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M37618|
  00008	e1a06001	 mov         r6, r1
  0000c	e1a05000	 mov         r5, r0

; 655  :     BOOL    bResult;
; 656  :     Heap*   pHeap;
; 657  :     
; 658  :     
; 659  :     //  Get video memory attributes from LCD PDD
; 660  :     bResult = LcdPdd_GetMemory( &m_dwDisplayBufferSize, &m_dwPhysicalDisplayAddr );

  00010	e285100c	 add         r1, r5, #0xC
  00014	e2850008	 add         r0, r5, #8
  00018	eb000000	 bl          LcdPdd_GetMemory
  0001c	e1b07000	 movs        r7, r0

; 661  :     if( !bResult )

  00020	0a00006f	 beq         |$cleanUp$36968|

; 662  :     {
; 663  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to get video memory attributes\n"));
; 664  :         goto cleanUp;
; 665  :     }
; 666  :     
; 667  :     //  Check that offscreen reserve is not greater that all of display memory
; 668  :     if( dwOffscreenMemory >= m_dwDisplayBufferSize )

  00024	e5951008	 ldr         r1, [r5, #8]

; 669  :         dwOffscreenMemory = 0;
; 670  :         
; 671  :         
; 672  :     //  Map physical memory to VM
; 673  :     m_pVirtualDisplayBuffer = VirtualAlloc(0, m_dwDisplayBufferSize, MEM_RESERVE, PAGE_NOACCESS);

  00028	e3a03001	 mov         r3, #1
  0002c	e3a02a02	 mov         r2, #2, 20
  00030	e1560001	 cmp         r6, r1
  00034	e3a00000	 mov         r0, #0
  00038	23a06000	 movcs       r6, #0
  0003c	eb000000	 bl          VirtualAlloc
  00040	e3500000	 cmp         r0, #0
  00044	e5850010	 str         r0, [r5, #0x10]

; 674  :     if( !m_pVirtualDisplayBuffer )

  00048	0a000065	 beq         |$cleanUp$36968|

; 675  :     {
; 676  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to allocate display buffer\n"));
; 677  :         goto cleanUp;
; 678  :     }
; 679  : 
; 680  :     if( !VirtualCopy(m_pVirtualDisplayBuffer, (void *)(m_dwPhysicalDisplayAddr >> 8), m_dwDisplayBufferSize-dwOffscreenMemory, PAGE_READWRITE | PAGE_NOCACHE | PAGE_PHYSICAL))

  0004c	e5953008	 ldr         r3, [r5, #8]
  00050	e595100c	 ldr         r1, [r5, #0xC]
  00054	e3a0ac06	 mov         r10, #6, 24
  00058	e0432006	 sub         r2, r3, r6
  0005c	e38a3004	 orr         r3, r10, #4
  00060	e1a01421	 mov         r1, r1, lsr #8
  00064	eb000000	 bl          VirtualCopy
  00068	e3500000	 cmp         r0, #0
  0006c	1a000006	 bne         |$LN13@Initialize|

; 681  :     {
; 682  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to map display buffer physical memory\n"));
; 683  :         VirtualFree( m_pVirtualDisplayBuffer, 0, MEM_RELEASE );

  00070	e5950010	 ldr         r0, [r5, #0x10]
  00074	e3a02902	 mov         r2, #2, 18
  00078	e3a01000	 mov         r1, #0
  0007c	eb000000	 bl          VirtualFree

; 684  :         m_pVirtualDisplayBuffer = NULL;

  00080	e3a03000	 mov         r3, #0
  00084	e5853010	 str         r3, [r5, #0x10]

; 749  :     }
; 750  : 
; 751  : cleanUp:

  00088	ea000055	 b           |$cleanUp$36968|
  0008c		 |$LN13@Initialize|

; 685  :         goto cleanUp;
; 686  :     }
; 687  : 
; 688  :     //  Change the attributes of the buffer for cache write combine
; 689  :     if( !CeSetMemoryAttributes(m_pVirtualDisplayBuffer, (void *)(m_dwPhysicalDisplayAddr >> 8), m_dwDisplayBufferSize-dwOffscreenMemory, PAGE_WRITECOMBINE))

  0008c	e595300c	 ldr         r3, [r5, #0xC]
  00090	e5951008	 ldr         r1, [r5, #8]
  00094	e5952010	 ldr         r2, [r5, #0x10]
  00098	e1a00423	 mov         r0, r3, lsr #8
  0009c	e58d0000	 str         r0, [sp]
  000a0	e0413006	 sub         r3, r1, r6
  000a4	e3a08000	 mov         r8, #0
  000a8	e3a09b01	 mov         r9, #1, 22
  000ac	e3a00001	 mov         r0, #1
  000b0	e3a0100c	 mov         r1, #0xC
  000b4	e58d8008	 str         r8, [sp, #8]
  000b8	e58d9004	 str         r9, [sp, #4]
  000bc	eb000000	 bl          KernelLibIoControl
  000c0	e3500000	 cmp         r0, #0

; 749  :     }
; 750  : 
; 751  : cleanUp:

  000c4	0a00000d	 beq         |$LN31@Initialize|
  000c8	e3a00014	 mov         r0, #0x14
  000cc	eb000000	 bl          |??2@YAPAXI@Z|
  000d0	e3500000	 cmp         r0, #0
  000d4	0a000006	 beq         |$LN21@Initialize|
  000d8	e5951008	 ldr         r1, [r5, #8]
  000dc	e5952010	 ldr         r2, [r5, #0x10]
  000e0	e3a03000	 mov         r3, #0
  000e4	e0411006	 sub         r1, r1, r6
  000e8	e58d8000	 str         r8, [sp]
  000ec	eb000000	 bl          |??0Heap@@QAA@KKPAV0@0@Z|
  000f0	ea000000	 b           |$LN22@Initialize|
  000f4		 |$LN21@Initialize|

; 690  :     {
; 691  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: Failed CeSetMemoryAttributes for display buffer\r\n"));
; 692  :         VirtualFree( m_pVirtualDisplayBuffer, 0, MEM_RELEASE );
; 693  :         m_pVirtualDisplayBuffer = NULL;
; 694  :         goto cleanUp;
; 695  :     }
; 696  :     
; 697  :     //  Initialize the heap manager for the display memory
; 698  :     pHeap = new Heap(m_dwDisplayBufferSize-dwOffscreenMemory, (DWORD) m_pVirtualDisplayBuffer);

  000f4	e3a00000	 mov         r0, #0
  000f8		 |$LN22@Initialize|

; 699  :     if( pHeap == NULL )

  000f8	e3500000	 cmp         r0, #0
  000fc	1a000005	 bne         |$LN9@Initialize|
  00100		 |$LN31@Initialize|

; 700  :     {
; 701  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to create heap manager\n"));
; 702  :         VirtualFree( m_pVirtualDisplayBuffer, 0, MEM_RELEASE );

  00100	e5950010	 ldr         r0, [r5, #0x10]
  00104	e3a02902	 mov         r2, #2, 18
  00108	e3a01000	 mov         r1, #0
  0010c	eb000000	 bl          VirtualFree

; 703  :         m_pVirtualDisplayBuffer = NULL;

  00110	e5858010	 str         r8, [r5, #0x10]

; 749  :     }
; 750  : 
; 751  : cleanUp:

  00114	ea000032	 b           |$cleanUp$36968|
  00118		 |$LN9@Initialize|

; 704  :         goto cleanUp;
; 705  :     }
; 706  :     
; 707  :     m_hHeap = (HANDLE) pHeap;

  00118	e5850004	 str         r0, [r5, #4]

; 708  : 
; 709  : 
; 710  :     //  Allocate physical memory for offscreen surfaces
; 711  :     if( dwOffscreenMemory > 0 )

  0011c	e3560000	 cmp         r6, #0
  00120	0a00002f	 beq         |$cleanUp$36968|

; 712  :     {
; 713  :         BYTE*   pOffscreenPtr = (BYTE*) m_pVirtualDisplayBuffer;
; 714  : 
; 715  :         
; 716  :         //  Offset to where offscreen buffer is
; 717  :         pOffscreenPtr += m_dwDisplayBufferSize - dwOffscreenMemory;

  00124	e5952008	 ldr         r2, [r5, #8]
  00128	e5951010	 ldr         r1, [r5, #0x10]

; 718  :         m_pOffscreenBuffer = (VOID*) pOffscreenPtr;
; 719  :         m_dwOffscreenPhysical = m_dwPhysicalDisplayAddr + m_dwDisplayBufferSize - dwOffscreenMemory;

  0012c	e595000c	 ldr         r0, [r5, #0xC]
  00130	e0423006	 sub         r3, r2, r6
  00134	e0422006	 sub         r2, r2, r6
  00138	e0824000	 add         r4, r2, r0
  0013c	e083e001	 add         lr, r3, r1

; 720  :         
; 721  :         //  VirtualCopy offscreen memory region to follow m_pVirtualDisplayBuffer
; 722  :         if( !VirtualCopy(m_pOffscreenBuffer, (void *)(m_dwOffscreenPhysical >> 8), dwOffscreenMemory, PAGE_READWRITE | PAGE_NOCACHE | PAGE_PHYSICAL))

  00140	e1a01424	 mov         r1, r4, lsr #8
  00144	e1a0000e	 mov         r0, lr
  00148	e38a3004	 orr         r3, r10, #4
  0014c	e1a02006	 mov         r2, r6
  00150	e585e018	 str         lr, [r5, #0x18]
  00154	e585401c	 str         r4, [r5, #0x1C]
  00158	eb000000	 bl          VirtualCopy
  0015c	e3500000	 cmp         r0, #0

; 749  :     }
; 750  : 
; 751  : cleanUp:

  00160	0a00001c	 beq         |$LN30@Initialize|
  00164	e595101c	 ldr         r1, [r5, #0x1C]
  00168	e5952018	 ldr         r2, [r5, #0x18]
  0016c	e1a03006	 mov         r3, r6
  00170	e1a01421	 mov         r1, r1, lsr #8
  00174	e58d1000	 str         r1, [sp]
  00178	e3a0100c	 mov         r1, #0xC
  0017c	e3a00001	 mov         r0, #1
  00180	e58d8008	 str         r8, [sp, #8]
  00184	e58d9004	 str         r9, [sp, #4]
  00188	eb000000	 bl          KernelLibIoControl
  0018c	e3500000	 cmp         r0, #0
  00190	0a00000c	 beq         |$LN29@Initialize|
  00194	e3a00014	 mov         r0, #0x14
  00198	eb000000	 bl          |??2@YAPAXI@Z|
  0019c	e3500000	 cmp         r0, #0
  001a0	0a000005	 beq         |$LN23@Initialize|
  001a4	e5952018	 ldr         r2, [r5, #0x18]
  001a8	e3a03000	 mov         r3, #0
  001ac	e1a01006	 mov         r1, r6
  001b0	e58d8000	 str         r8, [sp]
  001b4	eb000000	 bl          |??0Heap@@QAA@KKPAV0@0@Z|
  001b8	ea000000	 b           |$LN24@Initialize|
  001bc		 |$LN23@Initialize|

; 723  :         {
; 724  :             DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to map offscreen buffer physical memory\n"));
; 725  :             m_pOffscreenBuffer = NULL;
; 726  :             goto cleanUp;
; 727  :         }
; 728  : 
; 729  :         //  Change the attributes of the buffer for cache write combine
; 730  :         if( !CeSetMemoryAttributes(m_pOffscreenBuffer, (void *)(m_dwOffscreenPhysical >> 8), dwOffscreenMemory, PAGE_WRITECOMBINE))
; 731  :         {
; 732  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: Failed CeSetMemoryAttributes for offscreen buffer\r\n"));
; 733  :             VirtualFree( m_pOffscreenBuffer, 0, MEM_RELEASE );
; 734  :             m_pOffscreenBuffer = NULL;
; 735  :             goto cleanUp;
; 736  :         }
; 737  : 
; 738  :         //  Initialize the heap manager for the offscreen memory
; 739  :         pHeap = new Heap(dwOffscreenMemory, (DWORD) m_pOffscreenBuffer);

  001bc	e3a00000	 mov         r0, #0
  001c0		 |$LN24@Initialize|

; 740  :         if( pHeap == NULL )

  001c0	e3500000	 cmp         r0, #0
  001c4	1a000005	 bne         |$LN2@Initialize|
  001c8		 |$LN29@Initialize|

; 741  :         {
; 742  :             DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to create offscreen heap manager\n"));
; 743  :             VirtualFree( m_pOffscreenBuffer, 0, MEM_RELEASE );

  001c8	e5950018	 ldr         r0, [r5, #0x18]
  001cc	e3a02902	 mov         r2, #2, 18
  001d0	e3a01000	 mov         r1, #0
  001d4	eb000000	 bl          VirtualFree
  001d8		 |$LN30@Initialize|

; 744  :             m_pOffscreenBuffer = NULL;

  001d8	e5858018	 str         r8, [r5, #0x18]

; 749  :     }
; 750  : 
; 751  : cleanUp:

  001dc	ea000000	 b           |$cleanUp$36968|
  001e0		 |$LN2@Initialize|

; 745  :             goto cleanUp;
; 746  :         }
; 747  :         
; 748  :         m_hOffscreenHeap = (HANDLE) pHeap;

  001e0	e5850014	 str         r0, [r5, #0x14]
  001e4		 |$cleanUp$36968|

; 752  :     //  Retrun result
; 753  :     return bResult;
; 754  : }

  001e4	e1a00007	 mov         r0, r7
  001e8	e28dd00c	 add         sp, sp, #0xC
  001ec	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  001f0	e12fff1e	 bx          lr
  001f4		 |$M37619|

			 ENDP  ; |?Initialize@OMAPFlatSurfaceManager@@UAAHK@Z|, OMAPFlatSurfaceManager::Initialize


  00000			 AREA	 |.pdata|, PDATA
|$T37631| DCD	|$LN5@TotalMemor|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TotalMemorySize@OMAPFlatSurfaceManager@@UAAKXZ| PROC ; OMAPFlatSurfaceManager::TotalMemorySize

; 759  : {

  00000		 |$LN5@TotalMemor|
  00000		 |$M37628|

; 760  :     //  Return total display memory size
; 761  :     return m_dwDisplayBufferSize;

  00000	e5900008	 ldr         r0, [r0, #8]

; 762  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M37629|

			 ENDP  ; |?TotalMemorySize@OMAPFlatSurfaceManager@@UAAKXZ|, OMAPFlatSurfaceManager::TotalMemorySize

	IMPORT	|?TotalFree@Heap@@QAAKXZ|		; Heap::TotalFree

  00000			 AREA	 |.pdata|, PDATA
|$T37642| DCD	|$LN5@FreeMemory|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FreeMemorySize@OMAPFlatSurfaceManager@@UAAKXZ| PROC ; OMAPFlatSurfaceManager::FreeMemorySize

; 767  : {

  00000		 |$LN5@FreeMemory|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37639|

; 768  :     Heap*   pHeap = (Heap*) m_hHeap;

  00004	e5900004	 ldr         r0, [r0, #4]

; 769  : 
; 770  :     //  Return free memory of heap
; 771  :     return pHeap->TotalFree();

  00008	eb000000	 bl          |?TotalFree@Heap@@QAAKXZ|

; 772  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M37640|

			 ENDP  ; |?FreeMemorySize@OMAPFlatSurfaceManager@@UAAKXZ|, OMAPFlatSurfaceManager::FreeMemorySize


  00000			 AREA	 |.pdata|, PDATA
|$T37652| DCD	|$LN5@VirtualBas|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?VirtualBaseAddr@OMAPFlatSurfaceManager@@UAAPAXXZ| PROC ; OMAPFlatSurfaceManager::VirtualBaseAddr

; 777  : {

  00000		 |$LN5@VirtualBas|
  00000		 |$M37649|

; 778  :     //  Return base address of display memory
; 779  :     return m_pVirtualDisplayBuffer;

  00000	e5900010	 ldr         r0, [r0, #0x10]

; 780  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M37650|

			 ENDP  ; |?VirtualBaseAddr@OMAPFlatSurfaceManager@@UAAPAXXZ|, OMAPFlatSurfaceManager::VirtualBaseAddr


  00000			 AREA	 |.pdata|, PDATA
|$T37661| DCD	|$LN5@NumPhysica|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?NumPhysicalAddr@OMAPFlatSurfaceManager@@UAAKXZ| PROC ; OMAPFlatSurfaceManager::NumPhysicalAddr

; 785  : {

  00000		 |$LN5@NumPhysica|
  00000		 |$M37658|

; 786  :     //  Flat memory manager has only a single physical memory segment
; 787  :     return 1;

  00000	e3a00001	 mov         r0, #1

; 788  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M37659|

			 ENDP  ; |?NumPhysicalAddr@OMAPFlatSurfaceManager@@UAAKXZ|, OMAPFlatSurfaceManager::NumPhysicalAddr


  00000			 AREA	 |.pdata|, PDATA
|$T37673| DCD	|$LN6@PhysicalLe|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PhysicalLen@OMAPFlatSurfaceManager@@UAAKK@Z| PROC ; OMAPFlatSurfaceManager::PhysicalLen

; 793  : {

  00000		 |$LN6@PhysicalLe|
  00000		 |$M37670|
  00000	e3510000	 cmp         r1, #0
  00004	e1a03000	 mov         r3, r0

; 794  :     DWORD   dwLen = 0;        

  00008	e3a00000	 mov         r0, #0

; 795  : 
; 796  :     //  Flat memory manager has only a single physical memory segment
; 797  :     if( dwIndex == 0 )
; 798  :         dwLen = m_dwDisplayBufferSize;

  0000c	05930008	 ldreq       r0, [r3, #8]

; 799  :     
; 800  :     //  Return length of segment
; 801  :     return dwLen;
; 802  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M37671|

			 ENDP  ; |?PhysicalLen@OMAPFlatSurfaceManager@@UAAKK@Z|, OMAPFlatSurfaceManager::PhysicalLen


  00000			 AREA	 |.pdata|, PDATA
|$T37685| DCD	|$LN6@PhysicalAd@2|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PhysicalAddr@OMAPFlatSurfaceManager@@UAAKK@Z| PROC ; OMAPFlatSurfaceManager::PhysicalAddr

; 807  : {

  00000		 |$LN6@PhysicalAd@2|
  00000		 |$M37682|
  00000	e3510000	 cmp         r1, #0
  00004	e1a03000	 mov         r3, r0

; 808  :     DWORD   dwAddr = 0;        

  00008	e3a00000	 mov         r0, #0

; 809  : 
; 810  :     //  Flat memory manager has only a single physical memory segment
; 811  :     if( dwIndex == 0 )
; 812  :         dwAddr = m_dwPhysicalDisplayAddr;

  0000c	0593000c	 ldreq       r0, [r3, #0xC]

; 813  :     
; 814  :     //  Return physical address of segment
; 815  :     return dwAddr;
; 816  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M37683|

			 ENDP  ; |?PhysicalAddr@OMAPFlatSurfaceManager@@UAAKK@Z|, OMAPFlatSurfaceManager::PhysicalAddr


  00000			 AREA	 |.pdata|, PDATA
|$T37697| DCD	|$LN7@SupportsOf|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SupportsOffscreenSurfaces@OMAPFlatSurfaceManager@@UAAHXZ| PROC ; OMAPFlatSurfaceManager::SupportsOffscreenSurfaces

; 821  : {

  00000		 |$LN7@SupportsOf|
  00000		 |$M37694|

; 822  :     //  If offscreen heap allocated, return TRUE
; 823  :     return( m_hOffscreenHeap != NULL );

  00000	e5903014	 ldr         r3, [r0, #0x14]
  00004	e3530000	 cmp         r3, #0
  00008	13a00001	 movne       r0, #1
  0000c	03a00000	 moveq       r0, #0

; 824  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M37695|

			 ENDP  ; |?SupportsOffscreenSurfaces@OMAPFlatSurfaceManager@@UAAHXZ|, OMAPFlatSurfaceManager::SupportsOffscreenSurfaces

; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\inc\dssai.h

  00000			 AREA	 |.pdata|, PDATA
|$T37734| DCD	|$LN24@Allocate@2|
	DCD	0x40003902
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\surfmgr_flat.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Allocate@OMAPFlatSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@@Z| PROC ; OMAPFlatSurfaceManager::Allocate

; 834  : {

  00000		 |$LN24@Allocate@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M37731|
  00008	e1a07003	 mov         r7, r3
  0000c	e1a08002	 mov         r8, r2
  00010	e1a09001	 mov         r9, r1
  00014	e1a06000	 mov         r6, r0

; 835  :     BOOL            bResult;
; 836  :     OMAPFlatSurface *pFlatSurface;
; 837  :     Heap*           pHeap = (Heap*) m_hHeap;
; 838  :     
; 839  :     //  Check return pointer
; 840  :     if( ppSurface == NULL )

  00018	e59d502c	 ldr         r5, [sp, #0x2C]
  0001c	e596a004	 ldr         r10, [r6, #4]
  00020	e3550000	 cmp         r5, #0
  00024	0a000029	 beq         |$LN21@Allocate@2|

; 841  :         goto cleanUp;    
; 842  :     
; 843  :     //  Initialize return pointer
; 844  :     *ppSurface = NULL;

  00028	e3a0b000	 mov         r11, #0

; 845  : 
; 846  :     //  Allocate a new flat surface object
; 847  :     pFlatSurface = new OMAPFlatSurface;

  0002c	e3a000b8	 mov         r0, #0xB8
  00030	e585b000	 str         r11, [r5]
  00034	eb000000	 bl          |??2@YAPAXI@Z|
  00038	e1b04000	 movs        r4, r0
  0003c	0a00000a	 beq         |$LN9@Allocate@2|
  00040	e59fe098	 ldr         lr, [pc, #0x98]
  00044	e3a03001	 mov         r3, #1
  00048	e584b0a4	 str         r11, [r4, #0xA4]
  0004c	e584e000	 str         lr, [r4]
  00050	e5843028	 str         r3, [r4, #0x28]
  00054	e584302c	 str         r3, [r4, #0x2C]
  00058	e58430b4	 str         r3, [r4, #0xB4]
  0005c	e584b030	 str         r11, [r4, #0x30]
  00060	e584b0a0	 str         r11, [r4, #0xA0]
  00064	e584b09c	 str         r11, [r4, #0x9C]
  00068	ea000000	 b           |$LN10@Allocate@2|
  0006c		 |$LN9@Allocate@2|
  0006c	e3a04000	 mov         r4, #0
  00070		 |$LN10@Allocate@2|

; 848  :     if( pFlatSurface == NULL )

  00070	e3540000	 cmp         r4, #0
  00074	0a000011	 beq         |$LN15@Allocate@2|

; 849  :     {
; 850  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to create OMAPFlatSurface\n"));
; 851  :         goto cleanUp;
; 852  :     }
; 853  : 
; 854  :     //  Allocate the memory for the surface
; 855  :     bResult = pFlatSurface->Allocate(
; 856  :                                 ePixelFormat,
; 857  :                                 dwWidth,
; 858  :                                 dwHeight,
; 859  :                                 pHeap,
; 860  :                                 m_dwPhysicalDisplayAddr );

  00078	e596100c	 ldr         r1, [r6, #0xC]
  0007c	e1a03007	 mov         r3, r7
  00080	e1a02008	 mov         r2, r8
  00084	e58d1004	 str         r1, [sp, #4]
  00088	e1a01009	 mov         r1, r9
  0008c	e1a00004	 mov         r0, r4
  00090	e58da000	 str         r10, [sp]
  00094	eb000000	 bl          |?Allocate@OMAPFlatSurface@@QAAHW4OMAP_DSS_PIXELFORMAT@@KKPAXK@Z|
  00098	e3500000	 cmp         r0, #0

; 861  :     if( bResult == FALSE )

  0009c	1a000006	 bne         |$LN2@Allocate@2|

; 862  :     {
; 863  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to allocate OMAPFlatSurface memory\n"));
; 864  :         delete pFlatSurface;

  000a0	e5943000	 ldr         r3, [r4]
  000a4	e3a01001	 mov         r1, #1
  000a8	e1a00004	 mov         r0, r4
  000ac	e5933000	 ldr         r3, [r3]
  000b0	e1a0e00f	 mov         lr, pc
  000b4	e12fff13	 bx          r3

; 865  :         goto cleanUp;

  000b8	ea000000	 b           |$LN15@Allocate@2|
  000bc		 |$LN2@Allocate@2|

; 866  :     }    
; 867  : 
; 868  :     //  Return the new surface
; 869  :     *ppSurface = pFlatSurface;            

  000bc	e5854000	 str         r4, [r5]
  000c0		 |$cleanUp$37051|
  000c0		 |$LN15@Allocate@2|

; 870  :     
; 871  : cleanUp:    
; 872  :     //  Return result
; 873  :     return (ppSurface == NULL) ? FALSE : (*ppSurface != NULL);

  000c0	e5953000	 ldr         r3, [r5]
  000c4	e3530000	 cmp         r3, #0
  000c8	13a00001	 movne       r0, #1
  000cc	1a000000	 bne         |$LN14@Allocate@2|
  000d0		 |$LN21@Allocate@2|
  000d0	e3a00000	 mov         r0, #0
  000d4		 |$LN14@Allocate@2|

; 874  : }

  000d4	e28dd008	 add         sp, sp, #8
  000d8	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  000dc	e12fff1e	 bx          lr
  000e0		 |$LN25@Allocate@2|
  000e0		 |$LN26@Allocate@2|
  000e0	00000000	 DCD         |??_7OMAPFlatSurface@@6B@|
  000e4		 |$M37732|

			 ENDP  ; |?Allocate@OMAPFlatSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@@Z|, OMAPFlatSurfaceManager::Allocate

	IMPORT	|?SetAssocSurface@OMAPSurface@@QAAHPAV1@@Z| ; OMAPSurface::SetAssocSurface
	IMPORT	|?SetSurfaceType@OMAPSurface@@QAAHW4OMAP_SURFACE_TYPE@@@Z| ; OMAPSurface::SetSurfaceType
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\inc\dssai.h

  00000			 AREA	 |.pdata|, PDATA
|$T37774| DCD	|$LN24@Allocate@3|
	DCD	0x40004002
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\surfmgr_flat.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Allocate@OMAPFlatSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@PAV3@@Z| PROC ; OMAPFlatSurfaceManager::Allocate

; 885  : {

  00000		 |$LN24@Allocate@3|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M37771|
  00008	e1a07003	 mov         r7, r3
  0000c	e1a08002	 mov         r8, r2
  00010	e1a09001	 mov         r9, r1
  00014	e1a06000	 mov         r6, r0

; 886  :     BOOL            bResult;
; 887  :     OMAPFlatSurface *pFlatSurface;
; 888  :     Heap*           pHeap = (Heap*) m_hHeap;
; 889  : 
; 890  : 
; 891  :     //  Check return pointer
; 892  :     if( ppAssocSurface == NULL )

  00018	e59d502c	 ldr         r5, [sp, #0x2C]
  0001c	e596a004	 ldr         r10, [r6, #4]
  00020	e3550000	 cmp         r5, #0
  00024	0a000030	 beq         |$LN21@Allocate@3|

; 893  :         goto cleanUp;    
; 894  :     
; 895  :     //  Initialize return pointer
; 896  :     *ppAssocSurface = NULL;

  00028	e3a0b000	 mov         r11, #0

; 897  : 
; 898  :     //  Allocate a new flat surface object
; 899  :     pFlatSurface = new OMAPFlatSurface;

  0002c	e3a000b8	 mov         r0, #0xB8
  00030	e585b000	 str         r11, [r5]
  00034	eb000000	 bl          |??2@YAPAXI@Z|
  00038	e1b04000	 movs        r4, r0
  0003c	0a00000a	 beq         |$LN9@Allocate@3|
  00040	e59fe0b4	 ldr         lr, [pc, #0xB4]
  00044	e3a03001	 mov         r3, #1
  00048	e584b0a4	 str         r11, [r4, #0xA4]
  0004c	e584e000	 str         lr, [r4]
  00050	e5843028	 str         r3, [r4, #0x28]
  00054	e584302c	 str         r3, [r4, #0x2C]
  00058	e58430b4	 str         r3, [r4, #0xB4]
  0005c	e584b030	 str         r11, [r4, #0x30]
  00060	e584b0a0	 str         r11, [r4, #0xA0]
  00064	e584b09c	 str         r11, [r4, #0x9C]
  00068	ea000000	 b           |$LN10@Allocate@3|
  0006c		 |$LN9@Allocate@3|
  0006c	e3a04000	 mov         r4, #0
  00070		 |$LN10@Allocate@3|

; 900  :     if( pFlatSurface == NULL )

  00070	e3540000	 cmp         r4, #0
  00074	0a000018	 beq         |$LN15@Allocate@3|

; 901  :     {
; 902  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to create OMAPFlatSurface\n"));
; 903  :         goto cleanUp;
; 904  :     }
; 905  : 
; 906  :     //  Allocate the memory for the surface
; 907  :     bResult = pFlatSurface->Allocate(
; 908  :                                 ePixelFormat,
; 909  :                                 dwWidth,
; 910  :                                 dwHeight,
; 911  :                                 pHeap,
; 912  :                                 m_dwPhysicalDisplayAddr );

  00078	e596100c	 ldr         r1, [r6, #0xC]
  0007c	e1a03007	 mov         r3, r7
  00080	e1a02008	 mov         r2, r8
  00084	e58d1004	 str         r1, [sp, #4]
  00088	e1a01009	 mov         r1, r9
  0008c	e1a00004	 mov         r0, r4
  00090	e58da000	 str         r10, [sp]
  00094	eb000000	 bl          |?Allocate@OMAPFlatSurface@@QAAHW4OMAP_DSS_PIXELFORMAT@@KKPAXK@Z|
  00098	e3500000	 cmp         r0, #0

; 913  :     if( bResult == FALSE )
; 914  :     {
; 915  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to allocate OMAPFlatSurface memory\n"));
; 916  :         delete pFlatSurface;

  0009c	e1a00004	 mov         r0, r4
  000a0	e3a01001	 mov         r1, #1
  000a4	1a000004	 bne         |$LN2@Allocate@3|
  000a8	e5943000	 ldr         r3, [r4]
  000ac	e5933000	 ldr         r3, [r3]
  000b0	e1a0e00f	 mov         lr, pc
  000b4	e12fff13	 bx          r3

; 917  :         goto cleanUp;

  000b8	ea000007	 b           |$LN15@Allocate@3|
  000bc		 |$LN2@Allocate@3|

; 918  :     }
; 919  : 
; 920  :     pFlatSurface->SetSurfaceType(OMAP_SURFACE_RESIZER);

  000bc	eb000000	 bl          |?SetSurfaceType@OMAPSurface@@QAAHW4OMAP_SURFACE_TYPE@@@Z|

; 921  :     pFlatSurface->SetAssocSurface(pSurface);

  000c0	e59d1030	 ldr         r1, [sp, #0x30]
  000c4	e1a00004	 mov         r0, r4
  000c8	eb000000	 bl          |?SetAssocSurface@OMAPSurface@@QAAHPAV1@@Z|

; 922  :     pSurface->SetAssocSurface(pFlatSurface);    

  000cc	e59d0030	 ldr         r0, [sp, #0x30]
  000d0	e1a01004	 mov         r1, r4
  000d4	eb000000	 bl          |?SetAssocSurface@OMAPSurface@@QAAHPAV1@@Z|

; 923  :     
; 924  : 
; 925  :     //  Return the new surface
; 926  :     *ppAssocSurface = pFlatSurface; 

  000d8	e5854000	 str         r4, [r5]
  000dc		 |$cleanUp$37077|
  000dc		 |$LN15@Allocate@3|

; 927  :     
; 928  : cleanUp:        
; 929  :     //  Return result
; 930  :     return (ppAssocSurface == NULL) ? FALSE : (*ppAssocSurface != NULL);

  000dc	e5953000	 ldr         r3, [r5]
  000e0	e3530000	 cmp         r3, #0
  000e4	13a00001	 movne       r0, #1
  000e8	1a000000	 bne         |$LN14@Allocate@3|
  000ec		 |$LN21@Allocate@3|
  000ec	e3a00000	 mov         r0, #0
  000f0		 |$LN14@Allocate@3|

; 931  : }

  000f0	e28dd008	 add         sp, sp, #8
  000f4	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  000f8	e12fff1e	 bx          lr
  000fc		 |$LN25@Allocate@3|
  000fc		 |$LN26@Allocate@3|
  000fc	00000000	 DCD         |??_7OMAPFlatSurface@@6B@|
  00100		 |$M37772|

			 ENDP  ; |?Allocate@OMAPFlatSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@PAV3@@Z|, OMAPFlatSurfaceManager::Allocate

; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\inc\dssai.h

  00000			 AREA	 |.pdata|, PDATA
|$T37813| DCD	|$LN26@AllocateGD|
	DCD	0x40003b02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\surfmgr_flat.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AllocateGDI@OMAPFlatSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@@Z| PROC ; OMAPFlatSurfaceManager::AllocateGDI

; 941  : {

  00000		 |$LN26@AllocateGD|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M37810|
  00008	e1a08003	 mov         r8, r3
  0000c	e1a09002	 mov         r9, r2
  00010	e1a0a001	 mov         r10, r1
  00014	e1a07000	 mov         r7, r0

; 942  : //    return Allocate(ePixelFormat, dwWidth, dwHeight, ppSurface);
; 943  : 
; 944  :     BOOL            bResult;
; 945  :     OMAPFlatSurface *pFlatSurface;
; 946  :     Heap*           pHeap = (Heap*) m_hOffscreenHeap;
; 947  :     
; 948  :     //  Check return pointer
; 949  :     if( ppSurface == NULL )

  00018	e59d502c	 ldr         r5, [sp, #0x2C]
  0001c	e5976014	 ldr         r6, [r7, #0x14]
  00020	e3550000	 cmp         r5, #0
  00024	0a00002b	 beq         |$LN23@AllocateGD|

; 950  :         goto cleanUp;    
; 951  :     
; 952  :     //  Initialize return pointer
; 953  :     *ppSurface = NULL;

  00028	e3a0b000	 mov         r11, #0
  0002c	e585b000	 str         r11, [r5]

; 954  : 
; 955  :     //  Check for offscreen heap
; 956  :     if( pHeap == NULL )

  00030	e3560000	 cmp         r6, #0
  00034	0a000027	 beq         |$LN23@AllocateGD|

; 957  :         goto cleanUp;
; 958  :         
; 959  :         
; 960  :     //  Allocate a new flat surface object
; 961  :     pFlatSurface = new OMAPFlatSurface;

  00038	e3a000b8	 mov         r0, #0xB8
  0003c	eb000000	 bl          |??2@YAPAXI@Z|
  00040	e1b04000	 movs        r4, r0
  00044	0a00000a	 beq         |$LN11@AllocateGD|
  00048	e59fe098	 ldr         lr, [pc, #0x98]
  0004c	e3a03001	 mov         r3, #1
  00050	e584b0a4	 str         r11, [r4, #0xA4]
  00054	e584e000	 str         lr, [r4]
  00058	e5843028	 str         r3, [r4, #0x28]
  0005c	e584302c	 str         r3, [r4, #0x2C]
  00060	e58430b4	 str         r3, [r4, #0xB4]
  00064	e584b030	 str         r11, [r4, #0x30]
  00068	e584b0a0	 str         r11, [r4, #0xA0]
  0006c	e584b09c	 str         r11, [r4, #0x9C]
  00070	ea000000	 b           |$LN12@AllocateGD|
  00074		 |$LN11@AllocateGD|
  00074	e3a04000	 mov         r4, #0
  00078		 |$LN12@AllocateGD|

; 962  :     if( pFlatSurface == NULL )

  00078	e3540000	 cmp         r4, #0
  0007c	0a000011	 beq         |$LN17@AllocateGD|

; 963  :     {
; 964  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to create offscreen OMAPFlatSurface\n"));
; 965  :         goto cleanUp;
; 966  :     }
; 967  : 
; 968  :     //  Allocate the memory for the offscreen surface
; 969  :     bResult = pFlatSurface->Allocate(
; 970  :                                 ePixelFormat,
; 971  :                                 dwWidth,
; 972  :                                 dwHeight,
; 973  :                                 pHeap,
; 974  :                                 m_dwOffscreenPhysical );

  00080	e597101c	 ldr         r1, [r7, #0x1C]
  00084	e1a03008	 mov         r3, r8
  00088	e1a02009	 mov         r2, r9
  0008c	e58d1004	 str         r1, [sp, #4]
  00090	e1a0100a	 mov         r1, r10
  00094	e1a00004	 mov         r0, r4
  00098	e58d6000	 str         r6, [sp]
  0009c	eb000000	 bl          |?Allocate@OMAPFlatSurface@@QAAHW4OMAP_DSS_PIXELFORMAT@@KKPAXK@Z|
  000a0	e3500000	 cmp         r0, #0

; 975  :     if( bResult == FALSE )

  000a4	1a000006	 bne         |$LN2@AllocateGD|

; 976  :     {
; 977  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: Unable to allocate offscreen OMAPFlatSurface memory\n"));
; 978  :         delete pFlatSurface;

  000a8	e5943000	 ldr         r3, [r4]
  000ac	e3a01001	 mov         r1, #1
  000b0	e1a00004	 mov         r0, r4
  000b4	e5933000	 ldr         r3, [r3]
  000b8	e1a0e00f	 mov         lr, pc
  000bc	e12fff13	 bx          r3

; 979  :         goto cleanUp;

  000c0	ea000000	 b           |$LN17@AllocateGD|
  000c4		 |$LN2@AllocateGD|

; 980  :     }
; 981  : 
; 982  :     //  Return the new surface
; 983  :     *ppSurface = pFlatSurface;            

  000c4	e5854000	 str         r4, [r5]
  000c8		 |$cleanUp$37102|
  000c8		 |$LN17@AllocateGD|

; 984  :     
; 985  : cleanUp:    
; 986  :     //  Return result
; 987  :     return (ppSurface == NULL) ? FALSE : (*ppSurface != NULL);

  000c8	e5953000	 ldr         r3, [r5]
  000cc	e3530000	 cmp         r3, #0
  000d0	13a00001	 movne       r0, #1
  000d4	1a000000	 bne         |$LN16@AllocateGD|
  000d8		 |$LN23@AllocateGD|
  000d8	e3a00000	 mov         r0, #0
  000dc		 |$LN16@AllocateGD|

; 988  : }

  000dc	e28dd008	 add         sp, sp, #8
  000e0	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  000e4	e12fff1e	 bx          lr
  000e8		 |$LN27@AllocateGD|
  000e8		 |$LN28@AllocateGD|
  000e8	00000000	 DCD         |??_7OMAPFlatSurface@@6B@|
  000ec		 |$M37811|

			 ENDP  ; |?AllocateGDI@OMAPFlatSurfaceManager@@UAAHW4OMAP_DSS_PIXELFORMAT@@KKPAPAVOMAPSurface@@@Z|, OMAPFlatSurfaceManager::AllocateGDI


  00000			 AREA	 |.pdata|, PDATA
|$T37826| DCD	|$LN6@scalar@3|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GOMAPFlatSurface@@UAAPAXI@Z| PROC	; OMAPFlatSurface::`scalar deleting destructor'
  00000		 |$LN6@scalar@3|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37823|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          |??1OMAPFlatSurface@@UAA@XZ|
  00010	e3140001	 tst         r4, #1
  00014	11a00005	 movne       r0, r5
  00018	1b000000	 blne        |??3@YAXPAX@Z|
  0001c	e1a00005	 mov         r0, r5
  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M37824|

			 ENDP  ; |??_GOMAPFlatSurface@@UAAPAXI@Z|, OMAPFlatSurface::`scalar deleting destructor'


  00000			 AREA	 |.pdata|, PDATA
|$T37837| DCD	|$LN6@scalar@4|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GOMAPFlatSurfaceManager@@UAAPAXI@Z| PROC ; OMAPFlatSurfaceManager::`scalar deleting destructor'
  00000		 |$LN6@scalar@4|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37834|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          |??1OMAPFlatSurfaceManager@@UAA@XZ|
  00010	e3140001	 tst         r4, #1
  00014	11a00005	 movne       r0, r5
  00018	1b000000	 blne        |??3@YAXPAX@Z|
  0001c	e1a00005	 mov         r0, r5
  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M37835|

			 ENDP  ; |??_GOMAPFlatSurfaceManager@@UAAPAXI@Z|, OMAPFlatSurfaceManager::`scalar deleting destructor'

	END
