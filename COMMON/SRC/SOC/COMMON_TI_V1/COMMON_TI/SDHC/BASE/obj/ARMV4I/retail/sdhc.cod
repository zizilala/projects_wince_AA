; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\SDHC\BASE\sdhc.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1BG@PCNFFOOE@?$AAS?$AAl?$AAo?$AAt?$AAN?$AAu?$AAm?$AAb?$AAe?$AAr?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BI@EJNOAJAN@?$AAS?$AAD?$AAC?$AAl?$AAo?$AAc?$AAk?$AAM?$AAo?$AAd?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CG@CNGMEHNJ@?$AAS?$AAD?$AAH?$AAi?$AAg?$AAh?$AAS?$AAp?$AAe?$AAe?$AAd?$AAS?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BM@JHFMHONC@?$AAD?$AAM?$AAA?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DA@KLIJNKLI@?$AAC?$AAa?$AAr?$AAd?$AAW?$AAr?$AAi?$AAt?$AAe?$AAP?$AAr?$AAo?$AAt?$AAe?$AAc?$AAt?$AAe?$AAd?$AAS?$AAt?$AAa?$AAt?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BG@HDJCPCIJ@?$AAC?$AAa?$AAr?$AAd?$AAW?$AAP?$AAG?$AAP?$AAI?$AAO?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CE@MKPLCKIN@?$AAC?$AAa?$AAr?$AAd?$AAI?$AAn?$AAs?$AAe?$AAr?$AAt?$AAe?$AAd?$AAS?$AAt?$AAa?$AAt?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BO@LKNMDJEA@?$AAC?$AAa?$AAr?$AAd?$AAD?$AAe?$AAt?$AAe?$AAc?$AAt?$AAG?$AAP?$AAI?$AAO?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BM@NNIPIGOJ@?$AAW?$AAa?$AAk?$AAe?$AAu?$AAp?$AAS?$AAo?$AAu?$AAr?$AAc?$AAe?$AAs?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CC@LMBBBPNF@?$AAR?$AAe?$AAa?$AAd?$AAW?$AAr?$AAi?$AAt?$AAe?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CG@OOJEOPHC@?$AAB?$AAa?$AAs?$AAe?$AAC?$AAl?$AAo?$AAc?$AAk?$AAF?$AAr?$AAe?$AAq?$AAu?$AAe?$AAn?$AAc?$AAy?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BG@NAMMPMDB@?$AAC?$AAD?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@KBGNDCFC@?$AAS?$AAD?$AAI?$AAO?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BG@BPLBIFEM@?$AAD?$AAT?$AAO?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BG@HKGILLAM@?$AAC?$AAT?$AAO?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CC@HBIKPBAC@?$AAS?$AAd?$AAM?$AAe?$AAm?$AA4?$AAB?$AAi?$AAt?$AAD?$AAi?$AAs?$AAa?$AAb?$AAl?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CA@JDJLDHKA@?$AAS?$AAd?$AAi?$AAo?$AA4?$AAB?$AAi?$AAt?$AAD?$AAi?$AAs?$AAa?$AAb?$AAl?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BO@KFEHNIN@?$AAL?$AAo?$AAw?$AAV?$AAo?$AAl?$AAt?$AAa?$AAg?$AAe?$AAS?$AAl?$AAo?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BM@MAOJDGGP@?$AAF?$AAa?$AAs?$AAt?$AAP?$AAa?$AAt?$AAh?$AA_?$AAS?$AAD?$AAI?$AAO?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BO@GBHAIPGE@?$AAF?$AAa?$AAs?$AAt?$AAP?$AAa?$AAt?$AAh?$AA_?$AAS?$AAD?$AAM?$AAE?$AAM?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@MJKCNHDK@?$AAS?$AAD?$AAI?$AAO?$AAA?$AAc?$AAt?$AAi?$AAv?$AAi?$AAt?$AAy?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CO@BIPPPOIB@?$AAN?$AAo?$AAn?$AAS?$AAD?$AAI?$AAO?$AAA?$AAc?$AAt?$AAi?$AAv?$AAi?$AAt?$AAy?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|?m_cmdArrSize@CSDIOControllerBase@@2KB| [ DATA ] ; CSDIOControllerBase::m_cmdArrSize
	EXPORT	|?gwaCMD@@3PAUCMD@@A| [ DATA ]		; gwaCMD
	EXPORT	|?gwaCMD60_HS@@3UCMD@@A| [ DATA ]	; gwaCMD60_HS

  00000			 AREA	 |.data|, DATA
|?gwaCMD@@3PAUCMD@@A| DCB 0x1				; gwaCMD
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x0
	DCB	0x0
	DCB	0x1
	%	1
	DCD	0x120000
	DCB	0x1
	DCB	0x0
	DCB	0x1
	%	1
	DCD	0x90000
	DCB	0x1
	DCB	0x0
	DCB	0x1
	%	1
	DCD	0x20000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x2
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x20000
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x30000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x20000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x20000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x10000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x10000
	DCB	0x0
	DCB	0x0
	DCB	0x1
	%	1
	DCD	0x220010
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0xc30000
	DCB	0x1
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x20000
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x1a0000
	DCB	0x1
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x220032
	DCB	0x1
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x220032
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x0
	DCB	0x1
	DCB	0x1
	%	1
	DCD	0x230000
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x20010
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x1
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x220022
	DCB	0x1
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x220022
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x20000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x20000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x30000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x30000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x20010
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x20000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x20000
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x1
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x30000
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x20000
	DCB	0x1
	DCB	0x1
	DCB	0x1
	%	1
	DCD	0x20000
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x20000
	DCB	0x1
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x20000
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCD	0x220000
	DCB	0x2
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x20000
	DCB	0x2
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x220000
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x20000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x20000
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x0
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x0
|?gwaCMD60_HS@@3UCMD@@A| DCB 0x1			; gwaCMD60_HS
	DCB	0x0
	DCB	0x0
	%	1
	DCD	0x220032

  00000			 AREA	 |.rdata|, DATA, READONLY
|s_deviceRegParams| DCD |??_C@_1CO@BIPPPOIB@?$AAN?$AAo?$AAn?$AAS?$AAD?$AAI?$AAO?$AAA?$AAc?$AAt?$AAi?$AAv?$AAi?$AAt?$AAy?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x1b0
	DCD	0x4
	DCD	0x1
	DCD	|??_C@_1CI@MJKCNHDK@?$AAS?$AAD?$AAI?$AAO?$AAA?$AAc?$AAt?$AAi?$AAv?$AAi?$AAt?$AAy?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x1b4
	DCD	0x4
	DCD	0x7d0
	DCD	|??_C@_1BO@GBHAIPGE@?$AAF?$AAa?$AAs?$AAt?$AAP?$AAa?$AAt?$AAh?$AA_?$AAS?$AAD?$AAM?$AAE?$AAM?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x184
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BM@MAOJDGGP@?$AAF?$AAa?$AAs?$AAt?$AAP?$AAa?$AAt?$AAh?$AA_?$AAS?$AAD?$AAI?$AAO?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x180
	DCD	0x4
	DCD	0x1
	DCD	|??_C@_1BO@KFEHNIN@?$AAL?$AAo?$AAw?$AAV?$AAo?$AAl?$AAt?$AAa?$AAg?$AAe?$AAS?$AAl?$AAo?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x18c
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1CA@JDJLDHKA@?$AAS?$AAd?$AAi?$AAo?$AA4?$AAB?$AAi?$AAt?$AAD?$AAi?$AAs?$AAa?$AAb?$AAl?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x190
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1CC@HBIKPBAC@?$AAS?$AAd?$AAM?$AAe?$AAm?$AA4?$AAB?$AAi?$AAt?$AAD?$AAi?$AAs?$AAa?$AAb?$AAl?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x194
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BG@HKGILLAM@?$AAC?$AAT?$AAO?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x140
	DCD	0x4
	DCD	0x5
	DCD	|??_C@_1BG@BPLBIFEM@?$AAD?$AAT?$AAO?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x144
	DCD	0x4
	DCD	0x200
	DCD	|??_C@_1BK@KBGNDCFC@?$AAS?$AAD?$AAI?$AAO?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x128
	DCD	0x4
	DCD	0x97
	DCD	|??_C@_1BG@NAMMPMDB@?$AAC?$AAD?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x12c
	DCD	0x4
	DCD	0x98
	DCD	|??_C@_1CG@OOJEOPHC@?$AAB?$AAa?$AAs?$AAe?$AAC?$AAl?$AAo?$AAc?$AAk?$AAF?$AAr?$AAe?$AAq?$AAu?$AAe?$AAn?$AAc?$AAy?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x148
	DCD	0x4
	DCD	0x2dc6c00
	DCD	|??_C@_1CC@LMBBBPNF@?$AAR?$AAe?$AAa?$AAd?$AAW?$AAr?$AAi?$AAt?$AAe?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x150
	DCD	0x4
	DCD	0x2710
	DCD	|??_C@_1BM@NNIPIGOJ@?$AAW?$AAa?$AAk?$AAe?$AAu?$AAp?$AAS?$AAo?$AAu?$AAr?$AAc?$AAe?$AAs?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0xe8
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BO@LKNMDJEA@?$AAC?$AAa?$AAr?$AAd?$AAD?$AAe?$AAt?$AAe?$AAc?$AAt?$AAG?$AAP?$AAI?$AAO?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x1e4
	DCD	0x4
	DCD	0xffffffff
	DCD	|??_C@_1CE@MKPLCKIN@?$AAC?$AAa?$AAr?$AAd?$AAI?$AAn?$AAs?$AAe?$AAr?$AAt?$AAe?$AAd?$AAS?$AAt?$AAa?$AAt?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x1dc
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BG@HDJCPCIJ@?$AAC?$AAa?$AAr?$AAd?$AAW?$AAP?$AAG?$AAP?$AAI?$AAO?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x1e8
	DCD	0x4
	DCD	0xffffffff
	DCD	|??_C@_1DA@KLIJNKLI@?$AAC?$AAa?$AAr?$AAd?$AAW?$AAr?$AAi?$AAt?$AAe?$AAP?$AAr?$AAo?$AAt?$AAe?$AAc?$AAt?$AAe?$AAd?$AAS?$AAt?$AAa?$AAt?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x1e0
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BM@JHFMHONC@?$AAD?$AAM?$AAA?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x1fc
	DCD	0x4
	DCD	0x20000
	DCD	|??_C@_1CG@CNGMEHNJ@?$AAS?$AAD?$AAH?$AAi?$AAg?$AAh?$AAS?$AAp?$AAe?$AAe?$AAd?$AAS?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x198
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BI@EJNOAJAN@?$AAS?$AAD?$AAC?$AAl?$AAo?$AAc?$AAk?$AAM?$AAo?$AAd?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x19c
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BG@PCNFFOOE@?$AAS?$AAl?$AAo?$AAt?$AAN?$AAu?$AAm?$AAb?$AAe?$AAr?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x170
	DCD	0x4
	DCD	0x1

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BG@PCNFFOOE@?$AAS?$AAl?$AAo?$AAt?$AAN?$AAu?$AAm?$AAb?$AAe?$AAr?$AA?$AA@| DCB "S"
	DCB	0x0, "l", 0x0, "o", 0x0, "t", 0x0, "N", 0x0, "u", 0x0, "m"
	DCB	0x0, "b", 0x0, "e", 0x0, "r", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BI@EJNOAJAN@?$AAS?$AAD?$AAC?$AAl?$AAo?$AAc?$AAk?$AAM?$AAo?$AAd?$AAe?$AA?$AA@| DCB "S"
	DCB	0x0, "D", 0x0, "C", 0x0, "l", 0x0, "o", 0x0, "c", 0x0, "k"
	DCB	0x0, "M", 0x0, "o", 0x0, "d", 0x0, "e", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CG@CNGMEHNJ@?$AAS?$AAD?$AAH?$AAi?$AAg?$AAh?$AAS?$AAp?$AAe?$AAe?$AAd?$AAS?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AA?$AA@| DCB "S"
	DCB	0x0, "D", 0x0, "H", 0x0, "i", 0x0, "g", 0x0, "h", 0x0, "S"
	DCB	0x0, "p", 0x0, "e", 0x0, "e", 0x0, "d", 0x0, "S", 0x0, "u"
	DCB	0x0, "p", 0x0, "p", 0x0, "o", 0x0, "r", 0x0, "t", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BM@JHFMHONC@?$AAD?$AAM?$AAA?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?$AA@| DCB "D"
	DCB	0x0, "M", 0x0, "A", 0x0, "B", 0x0, "u", 0x0, "f", 0x0, "f"
	DCB	0x0, "e", 0x0, "r", 0x0, "S", 0x0, "i", 0x0, "z", 0x0, "e"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DA@KLIJNKLI@?$AAC?$AAa?$AAr?$AAd?$AAW?$AAr?$AAi?$AAt?$AAe?$AAP?$AAr?$AAo?$AAt?$AAe?$AAc?$AAt?$AAe?$AAd?$AAS?$AAt?$AAa?$AAt?$AAe?$AA?$AA@| DCB "C"
	DCB	0x0, "a", 0x0, "r", 0x0, "d", 0x0, "W", 0x0, "r", 0x0, "i"
	DCB	0x0, "t", 0x0, "e", 0x0, "P", 0x0, "r", 0x0, "o", 0x0, "t"
	DCB	0x0, "e", 0x0, "c", 0x0, "t", 0x0, "e", 0x0, "d", 0x0, "S"
	DCB	0x0, "t", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BG@HDJCPCIJ@?$AAC?$AAa?$AAr?$AAd?$AAW?$AAP?$AAG?$AAP?$AAI?$AAO?$AA?$AA@| DCB "C"
	DCB	0x0, "a", 0x0, "r", 0x0, "d", 0x0, "W", 0x0, "P", 0x0, "G"
	DCB	0x0, "P", 0x0, "I", 0x0, "O", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CE@MKPLCKIN@?$AAC?$AAa?$AAr?$AAd?$AAI?$AAn?$AAs?$AAe?$AAr?$AAt?$AAe?$AAd?$AAS?$AAt?$AAa?$AAt?$AAe?$AA?$AA@| DCB "C"
	DCB	0x0, "a", 0x0, "r", 0x0, "d", 0x0, "I", 0x0, "n", 0x0, "s"
	DCB	0x0, "e", 0x0, "r", 0x0, "t", 0x0, "e", 0x0, "d", 0x0, "S"
	DCB	0x0, "t", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BO@LKNMDJEA@?$AAC?$AAa?$AAr?$AAd?$AAD?$AAe?$AAt?$AAe?$AAc?$AAt?$AAG?$AAP?$AAI?$AAO?$AA?$AA@| DCB "C"
	DCB	0x0, "a", 0x0, "r", 0x0, "d", 0x0, "D", 0x0, "e", 0x0, "t"
	DCB	0x0, "e", 0x0, "c", 0x0, "t", 0x0, "G", 0x0, "P", 0x0, "I"
	DCB	0x0, "O", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BM@NNIPIGOJ@?$AAW?$AAa?$AAk?$AAe?$AAu?$AAp?$AAS?$AAo?$AAu?$AAr?$AAc?$AAe?$AAs?$AA?$AA@| DCB "W"
	DCB	0x0, "a", 0x0, "k", 0x0, "e", 0x0, "u", 0x0, "p", 0x0, "S"
	DCB	0x0, "o", 0x0, "u", 0x0, "r", 0x0, "c", 0x0, "e", 0x0, "s"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@LMBBBPNF@?$AAR?$AAe?$AAa?$AAd?$AAW?$AAr?$AAi?$AAt?$AAe?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB "R"
	DCB	0x0, "e", 0x0, "a", 0x0, "d", 0x0, "W", 0x0, "r", 0x0, "i"
	DCB	0x0, "t", 0x0, "e", 0x0, "T", 0x0, "i", 0x0, "m", 0x0, "e"
	DCB	0x0, "o", 0x0, "u", 0x0, "t", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CG@OOJEOPHC@?$AAB?$AAa?$AAs?$AAe?$AAC?$AAl?$AAo?$AAc?$AAk?$AAF?$AAr?$AAe?$AAq?$AAu?$AAe?$AAn?$AAc?$AAy?$AA?$AA@| DCB "B"
	DCB	0x0, "a", 0x0, "s", 0x0, "e", 0x0, "C", 0x0, "l", 0x0, "o"
	DCB	0x0, "c", 0x0, "k", 0x0, "F", 0x0, "r", 0x0, "e", 0x0, "q"
	DCB	0x0, "u", 0x0, "e", 0x0, "n", 0x0, "c", 0x0, "y", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BG@NAMMPMDB@?$AAC?$AAD?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?$AA@| DCB "C"
	DCB	0x0, "D", 0x0, "P", 0x0, "r", 0x0, "i", 0x0, "o", 0x0, "r"
	DCB	0x0, "i", 0x0, "t", 0x0, "y", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@KBGNDCFC@?$AAS?$AAD?$AAI?$AAO?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?$AA@| DCB "S"
	DCB	0x0, "D", 0x0, "I", 0x0, "O", 0x0, "P", 0x0, "r", 0x0, "i"
	DCB	0x0, "o", 0x0, "r", 0x0, "i", 0x0, "t", 0x0, "y", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BG@BPLBIFEM@?$AAD?$AAT?$AAO?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB "D"
	DCB	0x0, "T", 0x0, "O", 0x0, "T", 0x0, "i", 0x0, "m", 0x0, "e"
	DCB	0x0, "o", 0x0, "u", 0x0, "t", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BG@HKGILLAM@?$AAC?$AAT?$AAO?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB "C"
	DCB	0x0, "T", 0x0, "O", 0x0, "T", 0x0, "i", 0x0, "m", 0x0, "e"
	DCB	0x0, "o", 0x0, "u", 0x0, "t", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@HBIKPBAC@?$AAS?$AAd?$AAM?$AAe?$AAm?$AA4?$AAB?$AAi?$AAt?$AAD?$AAi?$AAs?$AAa?$AAb?$AAl?$AAe?$AA?$AA@| DCB "S"
	DCB	0x0, "d", 0x0, "M", 0x0, "e", 0x0, "m", 0x0, "4", 0x0, "B"
	DCB	0x0, "i", 0x0, "t", 0x0, "D", 0x0, "i", 0x0, "s", 0x0, "a"
	DCB	0x0, "b", 0x0, "l", 0x0, "e", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CA@JDJLDHKA@?$AAS?$AAd?$AAi?$AAo?$AA4?$AAB?$AAi?$AAt?$AAD?$AAi?$AAs?$AAa?$AAb?$AAl?$AAe?$AA?$AA@| DCB "S"
	DCB	0x0, "d", 0x0, "i", 0x0, "o", 0x0, "4", 0x0, "B", 0x0, "i"
	DCB	0x0, "t", 0x0, "D", 0x0, "i", 0x0, "s", 0x0, "a", 0x0, "b"
	DCB	0x0, "l", 0x0, "e", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BO@KFEHNIN@?$AAL?$AAo?$AAw?$AAV?$AAo?$AAl?$AAt?$AAa?$AAg?$AAe?$AAS?$AAl?$AAo?$AAt?$AA?$AA@| DCB "L"
	DCB	0x0, "o", 0x0, "w", 0x0, "V", 0x0, "o", 0x0, "l", 0x0, "t"
	DCB	0x0, "a", 0x0, "g", 0x0, "e", 0x0, "S", 0x0, "l", 0x0, "o"
	DCB	0x0, "t", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BM@MAOJDGGP@?$AAF?$AAa?$AAs?$AAt?$AAP?$AAa?$AAt?$AAh?$AA_?$AAS?$AAD?$AAI?$AAO?$AA?$AA@| DCB "F"
	DCB	0x0, "a", 0x0, "s", 0x0, "t", 0x0, "P", 0x0, "a", 0x0, "t"
	DCB	0x0, "h", 0x0, "_", 0x0, "S", 0x0, "D", 0x0, "I", 0x0, "O"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BO@GBHAIPGE@?$AAF?$AAa?$AAs?$AAt?$AAP?$AAa?$AAt?$AAh?$AA_?$AAS?$AAD?$AAM?$AAE?$AAM?$AA?$AA@| DCB "F"
	DCB	0x0, "a", 0x0, "s", 0x0, "t", 0x0, "P", 0x0, "a", 0x0, "t"
	DCB	0x0, "h", 0x0, "_", 0x0, "S", 0x0, "D", 0x0, "M", 0x0, "E"
	DCB	0x0, "M", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@MJKCNHDK@?$AAS?$AAD?$AAI?$AAO?$AAA?$AAc?$AAt?$AAi?$AAv?$AAi?$AAt?$AAy?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB "S"
	DCB	0x0, "D", 0x0, "I", 0x0, "O", 0x0, "A", 0x0, "c", 0x0, "t"
	DCB	0x0, "i", 0x0, "v", 0x0, "i", 0x0, "t", 0x0, "y", 0x0, "T"
	DCB	0x0, "i", 0x0, "m", 0x0, "e", 0x0, "o", 0x0, "u", 0x0, "t"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CO@BIPPPOIB@?$AAN?$AAo?$AAn?$AAS?$AAD?$AAI?$AAO?$AAA?$AAc?$AAt?$AAi?$AAv?$AAi?$AAt?$AAy?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB "N"
	DCB	0x0, "o", 0x0, "n", 0x0, "S", 0x0, "D", 0x0, "I", 0x0, "O"
	DCB	0x0, "A", 0x0, "c", 0x0, "t", 0x0, "i", 0x0, "v", 0x0, "i"
	DCB	0x0, "t", 0x0, "y", 0x0, "T", 0x0, "i", 0x0, "m", 0x0, "e"
	DCB	0x0, "o", 0x0, "u", 0x0, "t", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|?m_cmdArrSize@CSDIOControllerBase@@2KB| DCD 0x20	; CSDIOControllerBase::m_cmdArrSize
	EXPORT	|CeSetMemoryAttributes|
	IMPORT	|KernelLibIoControl|
; File c:\wince600\public\common\oak\inc\pkfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T44713| DCD	|$LN5@CeSetMemor|
	DCD	0x40001002
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |CeSetMemoryAttributes| PROC

; 1422 : {

  00000		 |$LN5@CeSetMemor|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M44710|
  00008	e1a04003	 mov         r4, r3
  0000c	e1a03002	 mov         r3, r2
  00010	e1a02000	 mov         r2, r0
  00014	e1a0e001	 mov         lr, r1

; 1423 :     return KernelLibIoControl ((HANDLE) KMOD_CORE, IOCTL_KLIB_SETMEMORYATTR,
; 1424 :         pVirtualAddr, cbSize, pShiftedPhysAddr, dwAttributes, NULL);

  00018	e3a01000	 mov         r1, #0
  0001c	e58d1008	 str         r1, [sp, #8]
  00020	e3a0100c	 mov         r1, #0xC
  00024	e3a00001	 mov         r0, #1
  00028	e58d4004	 str         r4, [sp, #4]
  0002c	e58de000	 str         lr, [sp]
  00030	eb000000	 bl          KernelLibIoControl

; 1425 : }

  00034	e28dd00c	 add         sp, sp, #0xC
  00038	e8bd4010	 ldmia       sp!, {r4, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$M44711|

			 ENDP  ; |CeSetMemoryAttributes|

	EXPORT	|ResetEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T44723| DCD	|$LN5@ResetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ResetEvent| PROC

; 223  : _inline BOOL ResetEvent(HANDLE h) {

  00000		 |$LN5@ResetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44720|

; 224  : 	return EventModify(h,EVENT_RESET);

  00004	e3a01002	 mov         r1, #2
  00008	eb000000	 bl          EventModify

; 225  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M44721|

			 ENDP  ; |ResetEvent|

	EXPORT	|SetEvent|

  00000			 AREA	 |.pdata|, PDATA
|$T44733| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44730|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M44731|

			 ENDP  ; |SetEvent|

	EXPORT	|GetCurrentThread|

  00000			 AREA	 |.pdata|, PDATA
|$T44742| DCD	|$LN5@GetCurrent|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentThread| PROC

; 351  : _inline HANDLE GetCurrentThread(void) {

  00000		 |$LN5@GetCurrent|
  00000		 |$M44739|

; 352  : 	return ((HANDLE)(SH_CURTHREAD+SYS_HANDLE_BASE));

  00000	e3a00041	 mov         r0, #0x41

; 353  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M44740|

			 ENDP  ; |GetCurrentThread|

	EXPORT	|?ZeroEntries@CReg@@AAAXXZ|		; CReg::ZeroEntries
; File c:\wince600\public\common\sdk\inc\creg.hxx

  00000			 AREA	 |.pdata|, PDATA
|$T44750| DCD	|$LN5@ZeroEntrie|
	DCD	0x40000600
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ZeroEntries@CReg@@AAAXXZ| PROC	; CReg::ZeroEntries

; 35   : 	void ZeroEntries() {

  00000		 |$LN5@ZeroEntrie|
  00000		 |$M44747|

; 36   : 		m_hKey      = NULL;

  00000	e3a03000	 mov         r3, #0
  00004	e5803000	 str         r3, [r0]

; 37   : 		m_Index     = 0;

  00008	e5803004	 str         r3, [r0, #4]

; 38   : 		m_lpbValue  = NULL;

  0000c	e5803008	 str         r3, [r0, #8]

; 39   : 		m_iValueLen = 0;

  00010	e580300c	 str         r3, [r0, #0xC]

; 40   : 	}

  00014	e12fff1e	 bx          lr
  00018		 |$M44748|

			 ENDP  ; |?ZeroEntries@CReg@@AAAXXZ|, CReg::ZeroEntries

	EXPORT	|??0CReg@@QAA@XZ|			; CReg::CReg

  00000			 AREA	 |.pdata|, PDATA
|$T44763| DCD	|$LN7@CReg|
	DCD	0x40000600
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CReg@@QAA@XZ| PROC			; CReg::CReg

; 63   : 	CReg() {

  00000		 |$LN7@CReg|
  00000		 |$M44760|

; 64   : 		ZeroEntries();

  00000	e3a03000	 mov         r3, #0
  00004	e5803000	 str         r3, [r0]
  00008	e5803004	 str         r3, [r0, #4]
  0000c	e5803008	 str         r3, [r0, #8]
  00010	e580300c	 str         r3, [r0, #0xC]

; 65   : 	}

  00014	e12fff1e	 bx          lr
  00018		 |$M44761|

			 ENDP  ; |??0CReg@@QAA@XZ|, CReg::CReg

	EXPORT	|??1CReg@@QAA@XZ|			; CReg::~CReg
	IMPORT	|LocalFree|
	IMPORT	|RegCloseKey|

  00000			 AREA	 |.pdata|, PDATA
|$T44771| DCD	|$LN7@CReg@2|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CReg@@QAA@XZ| PROC			; CReg::~CReg

; 67   : 	~CReg() { 

  00000		 |$LN7@CReg@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M44768|
  00004	e1a04000	 mov         r4, r0

; 68   : 		if(m_hKey) RegCloseKey(m_hKey); 

  00008	e5943000	 ldr         r3, [r4]
  0000c	e3530000	 cmp         r3, #0
  00010	11a00003	 movne       r0, r3
  00014	1b000000	 blne        RegCloseKey

; 69   : 		if (m_lpbValue) {

  00018	e5943008	 ldr         r3, [r4, #8]
  0001c	e3530000	 cmp         r3, #0

; 70   : 			ASSERT(m_iValueLen != 0);
; 71   : 			LocalFree(m_lpbValue);

  00020	11a00003	 movne       r0, r3
  00024	1b000000	 blne        LocalFree

; 72   : 		}
; 73   : 	}

  00028	e8bd4010	 ldmia       sp!, {r4, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$M44769|

			 ENDP  ; |??1CReg@@QAA@XZ|, CReg::~CReg

	EXPORT	|??0CSDIOControllerBase@@QAA@XZ|	; CSDIOControllerBase::CSDIOControllerBase
	EXPORT	|??_7CSDIOControllerBase@@6B@| [ DATA ]	; CSDIOControllerBase::`vftable'
	EXPORT	|?InterpretCapabilities@CSDIOControllerBase@@UAAHXZ| ; CSDIOControllerBase::InterpretCapabilities
	IMPORT	|InitializeCriticalSection|
	IMPORT	|_purecall|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\sdhc\base\sdhc.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T44781| DCD	|$LN5@CSDIOContr|
	DCD	0x40004101

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7CSDIOControllerBase@@6B@| DCD |_purecall|		; CSDIOControllerBase::`vftable'
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|?InterpretCapabilities@CSDIOControllerBase@@UAAHXZ|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CSDIOControllerBase@@QAA@XZ| PROC	; CSDIOControllerBase::CSDIOControllerBase

; 267  : {

  00000		 |$LN5@CSDIOContr|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M44778|
  00004	e1a04000	 mov         r4, r0
  00008	e59f30f0	 ldr         r3, [pc, #0xF0]

; 268  :     InitializeCriticalSection( &m_critSec );

  0000c	e48030b0	 str         r3, [r0], #0xB0
  00010	eb000000	 bl          InitializeCriticalSection

; 269  :     InitializeCriticalSection( &m_powerCS );

  00014	e28400c4	 add         r0, r4, #0xC4
  00018	eb000000	 bl          InitializeCriticalSection
  0001c	e3a03c27	 mov         r3, #0x27, 24

; 270  :     m_fSDIOInterruptInService = FALSE;
; 271  :     m_fFirstTime = TRUE;
; 272  :     m_hControllerISTEvent = NULL;
; 273  :     m_htControllerIST = NULL;
; 274  :     m_dwControllerSysIntr = SYSINTR_UNDEFINED;
; 275  :     m_hCardDetectEvent = NULL;
; 276  :     m_htCardDetectIST = NULL;
; 277  :     m_fAppCmdMode = FALSE;
; 278  : 
; 279  :     m_pbRegisters = NULL;
; 280  :     m_fCardPresent = FALSE;
; 281  :     m_fSDIOInterruptsEnabled = FALSE;
; 282  :     m_pDmaBuffer = NULL;
; 283  :     m_pCachedDmaBuffer = NULL;
; 284  :     m_pDmaBufferPhys.QuadPart = 0;
; 285  : 
; 286  :     m_dwMaxTimeout = DEFAULT_TIMEOUT_VALUE;

  00020	e3833010	 orr         r3, r3, #0x10
  00024	e3a02a61	 mov         r2, #0x61, 20

; 287  :     m_bReinsertTheCard = FALSE;
; 288  :     m_dwWakeupSources = 0;
; 289  :     m_dwCurrentWakeupSources = 0;
; 290  :     m_fMMCMode = FALSE;
; 291  : 
; 292  :     m_InternPowerState = D4;
; 293  :     m_ActualPowerState = D4;
; 294  :     m_hParentBus = NULL;
; 295  :     m_hGPIO = NULL;
; 296  : 
; 297  :     m_dwSlot = MMCSLOT_1;
; 298  : 	m_dwDeviceID = OMAP_DEVICE_NONE;
; 299  :     m_dwSDIOCard = 0;
; 300  :     m_fDriverShutdown = FALSE;
; 301  : 
; 302  :     bRxDmaActive = FALSE;
; 303  :     bTxDmaActive = FALSE;
; 304  :     m_dwClockCnt = 0;
; 305  :     m_fCardInitialized = FALSE;
; 306  :     m_bExitThread = FALSE;
; 307  : 	m_hTimerThreadIST = NULL;
; 308  : 	m_hTimerEvent = NULL;
; 309  :     //m_TransferClass = NULL;
; 310  : 
; 311  :     m_pCurrentRecieveBuffer = NULL;
; 312  :     m_dwCurrentRecieveBufferLength = 0;
; 313  :     m_CardDetectInterruptStatus = 0;
; 314  :     m_bCommandPending = FALSE;
; 315  : 
; 316  :     m_sContext.dwClockRate = MMCSD_CLOCK_INIT;

  00028	e5843150	 str         r3, [r4, #0x150]
  0002c	e3e00000	 mvn         r0, #0
  00030	e3a0e000	 mov         lr, #0
  00034	e3a03004	 mov         r3, #4
  00038	e3822d2a	 orr         r2, r2, #0x2A, 26
  0003c	e3a01001	 mov         r1, #1
  00040	e5840134	 str         r0, [r4, #0x134]
  00044	e5840174	 str         r0, [r4, #0x174]
  00048	e58430dc	 str         r3, [r4, #0xDC]
  0004c	e58430e0	 str         r3, [r4, #0xE0]
  00050	e5842200	 str         r2, [r4, #0x200]
  00054	e584e0d8	 str         lr, [r4, #0xD8]
  00058	e5841154	 str         r1, [r4, #0x154]
  0005c	e584e118	 str         lr, [r4, #0x118]
  00060	e584e11c	 str         lr, [r4, #0x11C]
  00064	e584e120	 str         lr, [r4, #0x120]
  00068	e584e124	 str         lr, [r4, #0x124]
  0006c	e584e114	 str         lr, [r4, #0x114]
  00070	e584e15c	 str         lr, [r4, #0x15C]
  00074	e584e0f0	 str         lr, [r4, #0xF0]
  00078	e584e0f4	 str         lr, [r4, #0xF4]
  0007c	e584e0fc	 str         lr, [r4, #0xFC]
  00080	e584e100	 str         lr, [r4, #0x100]
  00084	e584e108	 str         lr, [r4, #0x108]
  00088	e584e10c	 str         lr, [r4, #0x10C]
  0008c	e584e0e4	 str         lr, [r4, #0xE4]
  00090	e584e0e8	 str         lr, [r4, #0xE8]
  00094	e584e0ec	 str         lr, [r4, #0xEC]
  00098	e584e0f8	 str         lr, [r4, #0xF8]
  0009c	e584e0ac	 str         lr, [r4, #0xAC]
  000a0	e584e164	 str         lr, [r4, #0x164]
  000a4	e5841170	 str         r1, [r4, #0x170]
  000a8	e584e178	 str         lr, [r4, #0x178]
  000ac	e584e130	 str         lr, [r4, #0x130]
  000b0	e584e1d0	 str         lr, [r4, #0x1D0]
  000b4	e584e1d4	 str         lr, [r4, #0x1D4]
  000b8	e584e1a0	 str         lr, [r4, #0x1A0]
  000bc	e584e13c	 str         lr, [r4, #0x13C]
  000c0	e584e1a4	 str         lr, [r4, #0x1A4]
  000c4	e584e1ac	 str         lr, [r4, #0x1AC]
  000c8	e584e1a8	 str         lr, [r4, #0x1A8]
  000cc	e584e1ec	 str         lr, [r4, #0x1EC]
  000d0	e584e1f0	 str         lr, [r4, #0x1F0]
  000d4	e584e1f4	 str         lr, [r4, #0x1F4]
  000d8	e584e1f8	 str         lr, [r4, #0x1F8]

; 317  :     m_sContext.eSDHCIntr = SDHC_INTR_DISABLED;

  000dc	e584e204	 str         lr, [r4, #0x204]

; 318  :     m_sContext.eInterfaceMode = SD_INTERFACE_SD_MMC_1BIT;

  000e0	e584e208	 str         lr, [r4, #0x208]

; 319  : 
; 320  : #ifdef SDIO_DMA_ENABLED
; 321  : 	m_TxDmaInfo = NULL;

  000e4	e584e098	 str         lr, [r4, #0x98]

; 322  :     m_RxDmaInfo = NULL;

  000e8	e584e0a0	 str         lr, [r4, #0xA0]

; 323  :     m_hTxDmaChannel = NULL;

  000ec	e584e09c	 str         lr, [r4, #0x9C]

; 324  :     m_hRxDmaChannel = NULL;

  000f0	e584e0a4	 str         lr, [r4, #0xA4]

; 325  : #endif
; 326  : }

  000f4	e1a00004	 mov         r0, r4
  000f8	e8bd4010	 ldmia       sp!, {r4, lr}
  000fc	e12fff1e	 bx          lr
  00100		 |$LN6@CSDIOContr|
  00100		 |$LN7@CSDIOContr|
  00100	00000000	 DCD         |??_7CSDIOControllerBase@@6B@|
  00104		 |$M44779|

			 ENDP  ; |??0CSDIOControllerBase@@QAA@XZ|, CSDIOControllerBase::CSDIOControllerBase

	EXPORT	|?Read_MMC_STAT@CSDIOControllerBase@@QAAKXZ| ; CSDIOControllerBase::Read_MMC_STAT
	IMPORT	|LeaveCriticalSection|
	IMPORT	|EnterCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T44794| DCD	|$LN5@Read_MMC_S|
	DCD	0x40000b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Read_MMC_STAT@CSDIOControllerBase@@QAAKXZ| PROC ; CSDIOControllerBase::Read_MMC_STAT

; 330  : {

  00000		 |$LN5@Read_MMC_S|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M44791|
  00004	e1a04000	 mov         r4, r0

; 331  :     DWORD dwVal;
; 332  :     EnterCriticalSection( &m_critSec );

  00008	e28400b0	 add         r0, r4, #0xB0
  0000c	eb000000	 bl          EnterCriticalSection

; 333  :     dwVal = INREG32(&m_pbRegisters->MMCHS_STAT);

  00010	e594315c	 ldr         r3, [r4, #0x15C]

; 334  :     LeaveCriticalSection( &m_critSec );

  00014	e28400b0	 add         r0, r4, #0xB0
  00018	e5934130	 ldr         r4, [r3, #0x130]
  0001c	eb000000	 bl          LeaveCriticalSection

; 335  :     return dwVal;
; 336  : }

  00020	e1a00004	 mov         r0, r4
  00024	e8bd4010	 ldmia       sp!, {r4, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$M44792|

			 ENDP  ; |?Read_MMC_STAT@CSDIOControllerBase@@QAAKXZ|, CSDIOControllerBase::Read_MMC_STAT

	EXPORT	|?Write_MMC_STAT@CSDIOControllerBase@@QAAXK@Z| ; CSDIOControllerBase::Write_MMC_STAT

  00000			 AREA	 |.pdata|, PDATA
|$T44803| DCD	|$LN5@Write_MMC_|
	DCD	0x40000b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Write_MMC_STAT@CSDIOControllerBase@@QAAXK@Z| PROC ; CSDIOControllerBase::Write_MMC_STAT

; 340  : {

  00000		 |$LN5@Write_MMC_|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44800|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 341  :     EnterCriticalSection( &m_critSec );

  0000c	e28400b0	 add         r0, r4, #0xB0
  00010	eb000000	 bl          EnterCriticalSection

; 342  :     OUTREG32(&m_pbRegisters->MMCHS_STAT, dwVal);

  00014	e594315c	 ldr         r3, [r4, #0x15C]

; 343  :     LeaveCriticalSection( &m_critSec );

  00018	e28400b0	 add         r0, r4, #0xB0
  0001c	e5835130	 str         r5, [r3, #0x130]
  00020	eb000000	 bl          LeaveCriticalSection

; 344  : }

  00024	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$M44801|

			 ENDP  ; |?Write_MMC_STAT@CSDIOControllerBase@@QAAXK@Z|, CSDIOControllerBase::Write_MMC_STAT

	EXPORT	|?Set_MMC_STAT@CSDIOControllerBase@@QAAXK@Z| ; CSDIOControllerBase::Set_MMC_STAT

  00000			 AREA	 |.pdata|, PDATA
|$T44812| DCD	|$LN5@Set_MMC_ST|
	DCD	0x40000b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Set_MMC_STAT@CSDIOControllerBase@@QAAXK@Z| PROC ; CSDIOControllerBase::Set_MMC_STAT

; 348  : {

  00000		 |$LN5@Set_MMC_ST|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44809|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 349  :     EnterCriticalSection( &m_critSec );

  0000c	e28400b0	 add         r0, r4, #0xB0
  00010	eb000000	 bl          EnterCriticalSection

; 350  :     OUTREG32(&m_pbRegisters->MMCHS_STAT, dwVal);

  00014	e594315c	 ldr         r3, [r4, #0x15C]

; 351  :     LeaveCriticalSection( &m_critSec );

  00018	e28400b0	 add         r0, r4, #0xB0
  0001c	e5835130	 str         r5, [r3, #0x130]
  00020	eb000000	 bl          LeaveCriticalSection

; 352  : }

  00024	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$M44810|

			 ENDP  ; |?Set_MMC_STAT@CSDIOControllerBase@@QAAXK@Z|, CSDIOControllerBase::Set_MMC_STAT

	EXPORT	|?SoftwareReset@CSDIOControllerBase@@QAAXK@Z| ; CSDIOControllerBase::SoftwareReset
	IMPORT	|Sleep|
	IMPORT	|GetTickCount|

  00000			 AREA	 |.pdata|, PDATA
|$T44829| DCD	|$LN14@SoftwareRe|
	DCD	0x40001701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SoftwareReset@CSDIOControllerBase@@QAAXK@Z| PROC ; CSDIOControllerBase::SoftwareReset

; 357  : {

  00000		 |$LN14@SoftwareRe|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M44826|
  00004	e1a04000	 mov         r4, r0

; 358  :     DWORD               dwCountStart;
; 359  : 
; 360  :     DEBUGCHK(sizeof(OMAP_MMCHS_REGS) % sizeof(DWORD) == 0);
; 361  : 
; 362  :     dwResetBits &= (MMCHS_SYSCTL_SRA | MMCHS_SYSCTL_SRC | MMCHS_SYSCTL_SRD);
; 363  : 
; 364  :     // Reset the controller
; 365  :     SETREG32(&m_pbRegisters->MMCHS_SYSCTL, dwResetBits);

  00008	e594215c	 ldr         r2, [r4, #0x15C]
  0000c	e2015407	 and         r5, r1, #7, 8
  00010	e592312c	 ldr         r3, [r2, #0x12C]
  00014	e1833005	 orr         r3, r3, r5
  00018	e582312c	 str         r3, [r2, #0x12C]

; 366  : 
; 367  :     // get starting tick count for timeout
; 368  :     dwCountStart = GetTickCount();

  0001c	eb000000	 bl          GetTickCount

; 369  : 
; 370  :     // Verify that reset has completed.
; 371  :     while ((INREG32(&m_pbRegisters->MMCHS_SYSCTL) & dwResetBits))

  00020	e1a06000	 mov         r6, r0
  00024	ea000006	 b           |$LN11@SoftwareRe|
  00028		 |$LL3@SoftwareRe|

; 372  :     {
; 373  :         // check for timeout (see CE Help to understand how this calculation works)
; 374  :         if (GetTickCount() - dwCountStart > m_dwMaxTimeout)

  00028	eb000000	 bl          GetTickCount
  0002c	e5942150	 ldr         r2, [r4, #0x150]
  00030	e0403006	 sub         r3, r0, r6
  00034	e1530002	 cmp         r3, r2
  00038	8a000005	 bhi         |$LN9@SoftwareRe|

; 375  :         {
; 376  :             DEBUGMSG(ZONE_ENABLE_ERROR, (TEXT("SoftwareReset() - exit: TIMEOUT.\r\n")));
; 377  :             break;
; 378  :         }
; 379  : 
; 380  :         Sleep(0);

  0003c	e3a00000	 mov         r0, #0
  00040	eb000000	 bl          Sleep
  00044		 |$LN11@SoftwareRe|
  00044	e594315c	 ldr         r3, [r4, #0x15C]
  00048	e593312c	 ldr         r3, [r3, #0x12C]
  0004c	e1130005	 tst         r3, r5
  00050	1afffff4	 bne         |$LL3@SoftwareRe|
  00054		 |$LN9@SoftwareRe|

; 381  :     }
; 382  : }

  00054	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$M44827|

			 ENDP  ; |?SoftwareReset@CSDIOControllerBase@@QAAXK@Z|, CSDIOControllerBase::SoftwareReset

	EXPORT	|?SetSDInterfaceMode@CSDIOControllerBase@@IAAXW4SD_INTERFACE_MODE@@@Z| ; CSDIOControllerBase::SetSDInterfaceMode
	EXPORT	|??_C@_1FG@KBLCJKOK@?$AAS?$AAD?$AAH?$AAC?$AA?$CB?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?9?$AA?5?$AAU?$AAn?$AAe?$AAx?$AAp?$AAe?$AAc?$AAt?$AAe?$AAd?$AA?5?$AAS?$AAD?$AA?5?$AAi?$AAn?$AAt?$AAe?$AAr@| [ DATA ] ; `string'
	IMPORT	|NKDbgPrintfW|
	IMPORT	|dpCurSettings|

  00000			 AREA	 |.pdata|, PDATA
|$T44841| DCD	|$LN12@SetSDInter|
	DCD	0x40001801

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FG@KBLCJKOK@?$AAS?$AAD?$AAH?$AAC?$AA?$CB?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?9?$AA?5?$AAU?$AAn?$AAe?$AAx?$AAp?$AAe?$AAc?$AAt?$AAe?$AAd?$AA?5?$AAS?$AAD?$AA?5?$AAi?$AAn?$AAt?$AAe?$AAr@| DCB "S"
	DCB	0x0, "D", 0x0, "H", 0x0, "C", 0x0, "!", 0x0, "E", 0x0, "R"
	DCB	0x0, "R", 0x0, "O", 0x0, "R", 0x0, " ", 0x0, "-", 0x0, " "
	DCB	0x0, "U", 0x0, "n", 0x0, "e", 0x0, "x", 0x0, "p", 0x0, "e"
	DCB	0x0, "c", 0x0, "t", 0x0, "e", 0x0, "d", 0x0, " ", 0x0, "S"
	DCB	0x0, "D", 0x0, " ", 0x0, "i", 0x0, "n", 0x0, "t", 0x0, "e"
	DCB	0x0, "r", 0x0, "f", 0x0, "a", 0x0, "c", 0x0, "e", 0x0, "("
	DCB	0x0, "%", 0x0, "d", 0x0, ")", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetSDInterfaceMode@CSDIOControllerBase@@IAAXW4SD_INTERFACE_MODE@@@Z| PROC ; CSDIOControllerBase::SetSDInterfaceMode

; 387  : {

  00000		 |$LN12@SetSDInter|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44838|
  00004	e3510000	 cmp         r1, #0

; 388  :     if (SD_INTERFACE_SD_MMC_1BIT == eSDInterfaceMode)
; 389  :     {
; 390  :         CLRREG32(&m_pbRegisters->MMCHS_HCTL, MMCHS_HCTL_DTW);

  00008	0590215c	 ldreq       r2, [r0, #0x15C]
  0000c	05923128	 ldreq       r3, [r2, #0x128]
  00010	03c33002	 biceq       r3, r3, #2

; 394  :     {
; 395  :         SETREG32(&m_pbRegisters->MMCHS_HCTL, MMCHS_HCTL_DTW);

  00014	05823128	 streq       r3, [r2, #0x128]

; 404  :         }
; 405  :     }

  00018	049de004	 ldreq       lr, [sp], #4
  0001c	012fff1e	 bxeq        lr

; 391  :         DEBUGMSG(SDCARD_ZONE_INIT,(TEXT("SetInterface MMCHS_HCTL value = %X\r\n"), m_pbRegisters->MMCHS_HCTL ));
; 392  :     }
; 393  :     else if (SD_INTERFACE_SD_4BIT == eSDInterfaceMode)

  00020	e3510001	 cmp         r1, #1

; 394  :     {
; 395  :         SETREG32(&m_pbRegisters->MMCHS_HCTL, MMCHS_HCTL_DTW);

  00024	0590215c	 ldreq       r2, [r0, #0x15C]
  00028	05923128	 ldreq       r3, [r2, #0x128]
  0002c	03833002	 orreq       r3, r3, #2
  00030	05823128	 streq       r3, [r2, #0x128]

; 404  :         }
; 405  :     }

  00034	049de004	 ldreq       lr, [sp], #4
  00038	012fff1e	 bxeq        lr

; 396  :         DEBUGMSG(SDCARD_ZONE_INIT,(TEXT("SetInterface MMCHS_HCTL value = %X\r\n"), m_pbRegisters->MMCHS_HCTL ));
; 397  :     }
; 398  :     else
; 399  :     {
; 400  :         RETAILMSG(SDCARD_ZONE_ERROR, 
; 401  :             (L"SDHC!ERROR - Unexpected SD interface(%d)\r\n",
; 402  :             eSDInterfaceMode)
; 403  :             );

  0003c	e59f3018	 ldr         r3, [pc, #0x18]
  00040	e5933440	 ldr         r3, [r3, #0x440]
  00044	e3130902	 tst         r3, #2, 18
  00048	159f0008	 ldrne       r0, [pc, #8]
  0004c	1b000000	 blne        NKDbgPrintfW

; 404  :         }
; 405  :     }

  00050	e49de004	 ldr         lr, [sp], #4
  00054	e12fff1e	 bx          lr
  00058		 |$LN13@SetSDInter|
  00058		 |$LN14@SetSDInter|
  00058	00000000	 DCD         |??_C@_1FG@KBLCJKOK@?$AAS?$AAD?$AAH?$AAC?$AA?$CB?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?9?$AA?5?$AAU?$AAn?$AAe?$AAx?$AAp?$AAe?$AAc?$AAt?$AAe?$AAd?$AA?5?$AAS?$AAD?$AA?5?$AAi?$AAn?$AAt?$AAe?$AAr@|
  0005c		 |$LN15@SetSDInter|
  0005c	00000000	 DCD         |dpCurSettings|
  00060		 |$M44839|

			 ENDP  ; |?SetSDInterfaceMode@CSDIOControllerBase@@IAAXW4SD_INTERFACE_MODE@@@Z|, CSDIOControllerBase::SetSDInterfaceMode

	EXPORT	|?EnableSDHCInterrupts@CSDIOControllerBase@@QAAXXZ| ; CSDIOControllerBase::EnableSDHCInterrupts

  00000			 AREA	 |.pdata|, PDATA
|$T44852| DCD	|$LN5@EnableSDHC|
	DCD	0x40001001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?EnableSDHCInterrupts@CSDIOControllerBase@@QAAXXZ| PROC ; CSDIOControllerBase::EnableSDHCInterrupts

; 427  : {

  00000		 |$LN5@EnableSDHC|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M44849|
  00004	e1a04000	 mov         r4, r0

; 428  :     EnterCriticalSection( &m_critSec );

  00008	e28400b0	 add         r0, r4, #0xB0
  0000c	eb000000	 bl          EnterCriticalSection

; 429  :     OUTREG32(&m_pbRegisters->MMCHS_ISE, MMC_INT_EN_MASK);

  00010	e594315c	 ldr         r3, [r4, #0x15C]
  00014	e3a02833	 mov         r2, #0x33, 16
  00018	e3822033	 orr         r2, r2, #0x33

; 430  :     OUTREG32(&m_pbRegisters->MMCHS_IE,  MMC_INT_EN_MASK);
; 431  :     m_sContext.eSDHCIntr = SDHC_MMC_INTR_ENABLED;

  0001c	e5832138	 str         r2, [r3, #0x138]
  00020	e594315c	 ldr         r3, [r4, #0x15C]
  00024	e3a01001	 mov         r1, #1

; 432  :     LeaveCriticalSection( &m_critSec );

  00028	e28400b0	 add         r0, r4, #0xB0
  0002c	e5832134	 str         r2, [r3, #0x134]
  00030	e5841204	 str         r1, [r4, #0x204]
  00034	eb000000	 bl          LeaveCriticalSection

; 433  : }

  00038	e8bd4010	 ldmia       sp!, {r4, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$M44850|

			 ENDP  ; |?EnableSDHCInterrupts@CSDIOControllerBase@@QAAXXZ|, CSDIOControllerBase::EnableSDHCInterrupts

	EXPORT	|?DisableSDHCInterrupts@CSDIOControllerBase@@QAAXXZ| ; CSDIOControllerBase::DisableSDHCInterrupts

  00000			 AREA	 |.pdata|, PDATA
|$T44860| DCD	|$LN5@DisableSDH|
	DCD	0x40000e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DisableSDHCInterrupts@CSDIOControllerBase@@QAAXXZ| PROC ; CSDIOControllerBase::DisableSDHCInterrupts

; 438  : {

  00000		 |$LN5@DisableSDH|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M44857|
  00004	e1a04000	 mov         r4, r0

; 439  :     EnterCriticalSection( &m_critSec );

  00008	e28400b0	 add         r0, r4, #0xB0
  0000c	eb000000	 bl          EnterCriticalSection

; 440  :     OUTREG32(&m_pbRegisters->MMCHS_ISE, 0);

  00010	e594315c	 ldr         r3, [r4, #0x15C]
  00014	e3a02000	 mov         r2, #0

; 441  :     OUTREG32(&m_pbRegisters->MMCHS_IE,  0);
; 442  :     m_sContext.eSDHCIntr = SDHC_INTR_DISABLED;
; 443  :     LeaveCriticalSection( &m_critSec );

  00018	e28400b0	 add         r0, r4, #0xB0
  0001c	e5832138	 str         r2, [r3, #0x138]
  00020	e594315c	 ldr         r3, [r4, #0x15C]
  00024	e5832134	 str         r2, [r3, #0x134]
  00028	e5842204	 str         r2, [r4, #0x204]
  0002c	eb000000	 bl          LeaveCriticalSection

; 444  : }

  00030	e8bd4010	 ldmia       sp!, {r4, lr}
  00034	e12fff1e	 bx          lr
  00038		 |$M44858|

			 ENDP  ; |?DisableSDHCInterrupts@CSDIOControllerBase@@QAAXXZ|, CSDIOControllerBase::DisableSDHCInterrupts

	EXPORT	|?EnableSDIOInterrupts@CSDIOControllerBase@@QAAXXZ| ; CSDIOControllerBase::EnableSDIOInterrupts

  00000			 AREA	 |.pdata|, PDATA
|$T44868| DCD	|$LN6@EnableSDIO|
	DCD	0x40002001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?EnableSDIOInterrupts@CSDIOControllerBase@@QAAXXZ| PROC ; CSDIOControllerBase::EnableSDIOInterrupts

; 449  : {

  00000		 |$LN6@EnableSDIO|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M44865|
  00004	e1a04000	 mov         r4, r0

; 450  :     ASSERT( !m_fSDIOInterruptsEnabled );
; 451  :     m_fSDIOInterruptsEnabled = TRUE;
; 452  : 
; 453  :     DEBUGMSG(SHC_INTERRUPT_ZONE, (TEXT("CSDHCSlot::EnableSDIOInterrupts\r\n")));
; 454  : #ifdef ENABLE_RETAIL_OUTPUT
; 455  :         RETAILMSG(1, (TEXT("CSDHCSlot::EnableSDIOInterrupts\r\n")));
; 456  : #endif
; 457  :     EnterCriticalSection( &m_critSec );

  00008	e3a03001	 mov         r3, #1
  0000c	e28400b0	 add         r0, r4, #0xB0
  00010	e58430f4	 str         r3, [r4, #0xF4]
  00014	eb000000	 bl          EnterCriticalSection

; 458  :     SETREG32(&m_pbRegisters->MMCHS_CON, MMCHS_CON_CTPL);

  00018	e594215c	 ldr         r2, [r4, #0x15C]

; 459  :     if (!m_Sdio4BitDisable && (m_sContext.eInterfaceMode == SD_INTERFACE_SD_4BIT))
; 460  :     {
; 461  :         SETREG32(&m_pbRegisters->MMCHS_CON, MMCHS_CON_CLKEXTFREE);
; 462  :     }
; 463  : 
; 464  :     // enable exit from smart idle mode on SD/SDIO card interrupt
; 465  :     SETREG32(&m_pbRegisters->MMCHS_ISE, MMCHS_ISE_CIRQ);
; 466  :     // enable SD/SDIO card interrupt
; 467  :     SETREG32(&m_pbRegisters->MMCHS_IE, MMCHS_IE_CIRQ);
; 468  : 
; 469  :     m_sContext.eSDHCIntr = SDHC_SDIO_INTR_ENABLED;

  0001c	e3a01002	 mov         r1, #2

; 470  :     LeaveCriticalSection( &m_critSec );

  00020	e28400b0	 add         r0, r4, #0xB0
  00024	e592302c	 ldr         r3, [r2, #0x2C]
  00028	e3833b02	 orr         r3, r3, #2, 22
  0002c	e582302c	 str         r3, [r2, #0x2C]
  00030	e5943190	 ldr         r3, [r4, #0x190]
  00034	e3530000	 cmp         r3, #0
  00038	05943208	 ldreq       r3, [r4, #0x208]
  0003c	03530001	 cmpeq       r3, #1
  00040	0594215c	 ldreq       r2, [r4, #0x15C]
  00044	0592302c	 ldreq       r3, [r2, #0x2C]
  00048	03833801	 orreq       r3, r3, #1, 16
  0004c	0582302c	 streq       r3, [r2, #0x2C]
  00050	e594215c	 ldr         r2, [r4, #0x15C]
  00054	e5923138	 ldr         r3, [r2, #0x138]
  00058	e3833c01	 orr         r3, r3, #1, 24
  0005c	e5823138	 str         r3, [r2, #0x138]
  00060	e594215c	 ldr         r2, [r4, #0x15C]
  00064	e5923134	 ldr         r3, [r2, #0x134]
  00068	e3833c01	 orr         r3, r3, #1, 24
  0006c	e5823134	 str         r3, [r2, #0x134]
  00070	e5841204	 str         r1, [r4, #0x204]
  00074	eb000000	 bl          LeaveCriticalSection

; 471  : }

  00078	e8bd4010	 ldmia       sp!, {r4, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$M44866|

			 ENDP  ; |?EnableSDIOInterrupts@CSDIOControllerBase@@QAAXXZ|, CSDIOControllerBase::EnableSDIOInterrupts

	EXPORT	|?AckSDIOInterrupt@CSDIOControllerBase@@QAAXXZ| ; CSDIOControllerBase::AckSDIOInterrupt
	IMPORT	|SDHCDIndicateSlotStateChange|

  00000			 AREA	 |.pdata|, PDATA
|$T44884| DCD	|$LN11@AckSDIOInt|
	DCD	0x40002201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AckSDIOInterrupt@CSDIOControllerBase@@QAAXXZ| PROC ; CSDIOControllerBase::AckSDIOInterrupt

; 477  : {

  00000		 |$LN11@AckSDIOInt|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44881|
  00004	e1a05000	 mov         r5, r0

; 478  :     ASSERT( m_fSDIOInterruptsEnabled );
; 479  :     DEBUGMSG(SHC_INTERRUPT_ZONE, (TEXT("CSDHCSlot::AckSDIOInterrupt\r\n")));
; 480  : #ifdef ENABLE_RETAIL_OUTPUT
; 481  :         RETAILMSG(1, (TEXT("CSDHCSlot::AckSDIOInterrupt\r\n")));
; 482  : #endif
; 483  :     DWORD dwRegValue = Read_MMC_STAT();

  00008	e28500b0	 add         r0, r5, #0xB0
  0000c	eb000000	 bl          EnterCriticalSection
  00010	e595315c	 ldr         r3, [r5, #0x15C]
  00014	e28500b0	 add         r0, r5, #0xB0
  00018	e5934130	 ldr         r4, [r3, #0x130]
  0001c	eb000000	 bl          LeaveCriticalSection

; 484  :     if( dwRegValue & MMCHS_STAT_CIRQ )

  00020	e3140c01	 tst         r4, #1, 24

; 485  :     {
; 486  :         Set_MMC_STAT(MMCHS_STAT_CIRQ);

  00024	e28500b0	 add         r0, r5, #0xB0
  00028	0a00000b	 beq         |$LN2@AckSDIOInt|
  0002c	eb000000	 bl          EnterCriticalSection
  00030	e595315c	 ldr         r3, [r5, #0x15C]
  00034	e3a02c01	 mov         r2, #1, 24
  00038	e28500b0	 add         r0, r5, #0xB0
  0003c	e5832130	 str         r2, [r3, #0x130]
  00040	eb000000	 bl          LeaveCriticalSection

; 487  :         SDHCDIndicateSlotStateChange(m_pHCContext, 0, DeviceInterrupting);

  00044	e59500a8	 ldr         r0, [r5, #0xA8]
  00048	e3a02003	 mov         r2, #3
  0004c	e3a01000	 mov         r1, #0
  00050	eb000000	 bl          SDHCDIndicateSlotStateChange

; 495  :     }
; 496  : }

  00054	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$LN2@AckSDIOInt|

; 488  :     }
; 489  :     else
; 490  :     {
; 491  :         EnterCriticalSection( &m_critSec );

  0005c	eb000000	 bl          EnterCriticalSection

; 492  :         SETREG32(&m_pbRegisters->MMCHS_IE,  MMCHS_IE_CIRQ);

  00060	e595215c	 ldr         r2, [r5, #0x15C]

; 493  :         LeaveCriticalSection( &m_critSec );

  00064	e28500b0	 add         r0, r5, #0xB0
  00068	e5923134	 ldr         r3, [r2, #0x134]
  0006c	e3833c01	 orr         r3, r3, #1, 24
  00070	e5823134	 str         r3, [r2, #0x134]
  00074	eb000000	 bl          LeaveCriticalSection

; 494  :         m_fSDIOInterruptInService = FALSE;

  00078	e3a03000	 mov         r3, #0
  0007c	e58530d8	 str         r3, [r5, #0xD8]

; 495  :     }
; 496  : }

  00080	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00084	e12fff1e	 bx          lr
  00088		 |$M44882|

			 ENDP  ; |?AckSDIOInterrupt@CSDIOControllerBase@@QAAXXZ|, CSDIOControllerBase::AckSDIOInterrupt

	EXPORT	|?DisableSDIOInterrupts@CSDIOControllerBase@@QAAXXZ| ; CSDIOControllerBase::DisableSDIOInterrupts

  00000			 AREA	 |.pdata|, PDATA
|$T44892| DCD	|$LN5@DisableSDI|
	DCD	0x40001301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DisableSDIOInterrupts@CSDIOControllerBase@@QAAXXZ| PROC ; CSDIOControllerBase::DisableSDIOInterrupts

; 501  : {

  00000		 |$LN5@DisableSDI|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44889|
  00004	e1a04000	 mov         r4, r0

; 502  :     ASSERT( m_fSDIOInterruptsEnabled );
; 503  :     m_fSDIOInterruptsEnabled = FALSE;
; 504  : 
; 505  :     DEBUGMSG(SHC_INTERRUPT_ZONE, (TEXT("CSDHCSlot::DisableSDIOInterrupts\r\n")));
; 506  : #ifdef ENABLE_RETAIL_OUTPUT
; 507  :         RETAILMSG(1, (TEXT("CSDHCSlot::DisableSDIOInterrupts\r\n")));
; 508  : #endif
; 509  :     EnterCriticalSection( &m_critSec );

  00008	e3a05000	 mov         r5, #0
  0000c	e28400b0	 add         r0, r4, #0xB0
  00010	e58450f4	 str         r5, [r4, #0xF4]
  00014	eb000000	 bl          EnterCriticalSection

; 510  :     CLRREG32(&m_pbRegisters->MMCHS_ISE, MMCHS_ISE_CIRQ);

  00018	e594215c	 ldr         r2, [r4, #0x15C]

; 511  :     CLRREG32(&m_pbRegisters->MMCHS_IE,  MMCHS_IE_CIRQ);
; 512  :     m_sContext.eSDHCIntr = SDHC_INTR_DISABLED;
; 513  :     LeaveCriticalSection( &m_critSec );

  0001c	e28400b0	 add         r0, r4, #0xB0
  00020	e5923138	 ldr         r3, [r2, #0x138]
  00024	e3c33c01	 bic         r3, r3, #1, 24
  00028	e5823138	 str         r3, [r2, #0x138]
  0002c	e594215c	 ldr         r2, [r4, #0x15C]
  00030	e5923134	 ldr         r3, [r2, #0x134]
  00034	e3c33c01	 bic         r3, r3, #1, 24
  00038	e5823134	 str         r3, [r2, #0x134]
  0003c	e5845204	 str         r5, [r4, #0x204]
  00040	eb000000	 bl          LeaveCriticalSection

; 514  : }

  00044	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00048	e12fff1e	 bx          lr
  0004c		 |$M44890|

			 ENDP  ; |?DisableSDIOInterrupts@CSDIOControllerBase@@QAAXXZ|, CSDIOControllerBase::DisableSDIOInterrupts

	EXPORT	|?SetClockRate@CSDIOControllerBase@@QAAXPAK@Z| ; CSDIOControllerBase::SetClockRate
	IMPORT	|__rt_udiv|

  00000			 AREA	 |.pdata|, PDATA
|$T44917| DCD	|$LN21@SetClockRa|
	DCD	0x40004701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetClockRate@CSDIOControllerBase@@QAAXPAK@Z| PROC ; CSDIOControllerBase::SetClockRate

; 519  : {

  00000		 |$LN21@SetClockRa|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44914|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 520  :     DWORD dwClockRate = *pdwRate;

  0000c	e5952000	 ldr         r2, [r5]

; 521  : 
; 522  :     if(dwClockRate > m_dwMaxClockRate) dwClockRate = m_dwMaxClockRate;

  00010	e5943148	 ldr         r3, [r4, #0x148]
  00014	e1520003	 cmp         r2, r3
  00018	81a02003	 movhi       r2, r3

; 523  : 
; 524  :     // calculate the register value
; 525  :     DWORD dwDiv = (DWORD)((MMCSD_CLOCK_INPUT + dwClockRate - 1) / dwClockRate);

  0001c	e59f30f4	 ldr         r3, [pc, #0xF4]
  00020	e1a00002	 mov         r0, r2
  00024	e0821003	 add         r1, r2, r3
  00028	eb000000	 bl          __rt_udiv

; 526  : 
; 527  :     DEBUGMSG(SHC_CLOCK_ZONE, (TEXT("actual wDiv = 0x%x  requested:0x%x"), dwDiv, *pdwRate));
; 528  :     // Only 10 bits available for the divider, so mmc base clock / 1024 is minimum.
; 529  :     if ( dwDiv > 0x03FF )

  0002c	e3a03c03	 mov         r3, #3, 24

; 530  :         dwDiv = 0x03FF;
; 531  : 
; 532  :     DEBUGMSG(SHC_CLOCK_ZONE, (TEXT("dwDiv = 0x%x 0x%x"), dwDiv, *pdwRate));
; 533  : 
; 534  :     // Program the divisor, but leave the rest of the register alone.
; 535  :     INT32 dwRegValue = INREG32(&m_pbRegisters->MMCHS_SYSCTL);

  00030	e594e15c	 ldr         lr, [r4, #0x15C]
  00034	e38330ff	 orr         r3, r3, #0xFF
  00038	e1500003	 cmp         r0, r3

; 536  : 
; 537  :     dwRegValue = (dwRegValue & ~MMCHS_SYSCTL_CLKD_MASK) | MMCHS_SYSCTL_CLKD(dwDiv);
; 538  :     dwRegValue = (dwRegValue & ~MMCHS_SYSCTL_DTO_MASK) | MMCHS_SYSCTL_DTO(0x0e); // DTO
; 539  :     dwRegValue &= ~MMCHS_SYSCTL_CEN;
; 540  :     dwRegValue &= ~MMCHS_SYSCTL_ICE;
; 541  : 
; 542  :     CLRREG32(&m_pbRegisters->MMCHS_SYSCTL, MMCHS_SYSCTL_CEN);

  0003c	e59e212c	 ldr         r2, [lr, #0x12C]
  00040	81a00003	 movhi       r0, r3
  00044	e59e112c	 ldr         r1, [lr, #0x12C]
  00048	e3e03cff	 mvn         r3, #0xFF, 24

; 543  : 
; 544  :     OUTREG32(&m_pbRegisters->MMCHS_SYSCTL, dwRegValue);

  0004c	e22330c0	 eor         r3, r3, #0xC0
  00050	e0022003	 and         r2, r2, r3
  00054	e3c13004	 bic         r3, r1, #4
  00058	e58e312c	 str         r3, [lr, #0x12C]
  0005c	e3e03801	 mvn         r3, #1, 16
  00060	e2233005	 eor         r3, r3, #5
  00064	e594115c	 ldr         r1, [r4, #0x15C]
  00068	e1822300	 orr         r2, r2, r0, lsl #6
  0006c	e0023003	 and         r3, r2, r3
  00070	e383380e	 orr         r3, r3, #0xE, 16
  00074	e581312c	 str         r3, [r1, #0x12C]

; 545  : 
; 546  :     SETREG32(&m_pbRegisters->MMCHS_SYSCTL, MMCHS_SYSCTL_ICE); // enable internal clock

  00078	e594215c	 ldr         r2, [r4, #0x15C]

; 547  : 
; 548  :     DWORD dwTimeout = 500;

  0007c	e3a01f7d	 mov         r1, #0x7D, 30
  00080	e592312c	 ldr         r3, [r2, #0x12C]
  00084	e3833001	 orr         r3, r3, #1
  00088	e582312c	 str         r3, [r2, #0x12C]

; 549  :     while(((INREG32(&m_pbRegisters->MMCHS_SYSCTL) & MMCHS_SYSCTL_ICS) != MMCHS_SYSCTL_ICS) && (dwTimeout>0))

  0008c	e594215c	 ldr         r2, [r4, #0x15C]
  00090	e592312c	 ldr         r3, [r2, #0x12C]
  00094	ea000004	 b           |$LN16@SetClockRa|
  00098		 |$LL4@SetClockRa|
  00098	e3510000	 cmp         r1, #0
  0009c	0a000005	 beq         |$LN13@SetClockRa|
  000a0	e594315c	 ldr         r3, [r4, #0x15C]

; 550  :     {
; 551  :         dwTimeout--;

  000a4	e2411001	 sub         r1, r1, #1
  000a8	e593312c	 ldr         r3, [r3, #0x12C]
  000ac		 |$LN16@SetClockRa|
  000ac	e2033002	 and         r3, r3, #2
  000b0	e3530002	 cmp         r3, #2
  000b4	1afffff7	 bne         |$LL4@SetClockRa|
  000b8		 |$LN13@SetClockRa|

; 552  :     }
; 553  : 
; 554  :     SETREG32(&m_pbRegisters->MMCHS_SYSCTL, MMCHS_SYSCTL_CEN);

  000b8	e592312c	 ldr         r3, [r2, #0x12C]

; 555  :     SETREG32(&m_pbRegisters->MMCHS_HCTL, MMCHS_HCTL_SDBP); // power up the card
; 556  : 
; 557  :     dwTimeout = 500;

  000bc	e3a01f7d	 mov         r1, #0x7D, 30
  000c0	e3833004	 orr         r3, r3, #4
  000c4	e582312c	 str         r3, [r2, #0x12C]
  000c8	e594215c	 ldr         r2, [r4, #0x15C]
  000cc	e5923128	 ldr         r3, [r2, #0x128]
  000d0	e3833c01	 orr         r3, r3, #1, 24
  000d4	e5823128	 str         r3, [r2, #0x128]

; 558  :     while(((INREG32(&m_pbRegisters->MMCHS_SYSCTL) & MMCHS_SYSCTL_CEN) != MMCHS_SYSCTL_CEN) && (dwTimeout>0))

  000d8	ea000002	 b           |$LN18@SetClockRa|
  000dc		 |$LL2@SetClockRa|
  000dc	e3510000	 cmp         r1, #0
  000e0	0a000005	 beq         |$LN14@SetClockRa|

; 559  :     {
; 560  :         dwTimeout--;

  000e4	e2411001	 sub         r1, r1, #1
  000e8		 |$LN18@SetClockRa|

; 558  :     while(((INREG32(&m_pbRegisters->MMCHS_SYSCTL) & MMCHS_SYSCTL_CEN) != MMCHS_SYSCTL_CEN) && (dwTimeout>0))

  000e8	e594315c	 ldr         r3, [r4, #0x15C]

; 559  :     {
; 560  :         dwTimeout--;

  000ec	e593312c	 ldr         r3, [r3, #0x12C]
  000f0	e2033004	 and         r3, r3, #4
  000f4	e3530004	 cmp         r3, #4
  000f8	1afffff7	 bne         |$LL2@SetClockRa|
  000fc		 |$LN14@SetClockRa|

; 561  :     }
; 562  : 
; 563  :     *pdwRate = MMCSD_CLOCK_INPUT / dwDiv;

  000fc	e59f1010	 ldr         r1, [pc, #0x10]
  00100	eb000000	 bl          __rt_udiv
  00104	e5850000	 str         r0, [r5]

; 564  :     m_sContext.dwClockRate = MMCSD_CLOCK_INPUT / dwDiv;

  00108	e5840200	 str         r0, [r4, #0x200]

; 565  : 
; 566  :     DEBUGMSG(SHC_CLOCK_ZONE,(TEXT("SDHCSetRate - Actual clock rate = 0x%x, MMCHS_SYSCTL = 0x%x\r\n"), *pdwRate, INREG32(&m_pbRegisters->MMCHS_SYSCTL)));
; 567  :     //RETAILMSG(1,(TEXT("SDHCSetRate - Actual clock rate = %d, MMCHS_SYSCTL = 0x%x\r\n"), *pdwRate, INREG32(&m_pbRegisters->MMCHS_SYSCTL)));
; 568  : }

  0010c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00110	e12fff1e	 bx          lr
  00114		 |$LN22@SetClockRa|
  00114		 |$LN23@SetClockRa|
  00114	05b8d800	 DCD         0x5b8d800
  00118		 |$LN24@SetClockRa|
  00118	05b8d7ff	 DCD         0x5b8d7ff
  0011c		 |$M44915|

			 ENDP  ; |?SetClockRate@CSDIOControllerBase@@QAAXPAK@Z|, CSDIOControllerBase::SetClockRate

	EXPORT	|?IsMultipleBlockReadSupported@CSDIOControllerBase@@IAAHXZ| ; CSDIOControllerBase::IsMultipleBlockReadSupported

  00000			 AREA	 |.pdata|, PDATA
|$T44929| DCD	|$LN6@IsMultiple|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsMultipleBlockReadSupported@CSDIOControllerBase@@IAAHXZ| PROC ; CSDIOControllerBase::IsMultipleBlockReadSupported

; 571  : {

  00000		 |$LN6@IsMultiple|
  00000		 |$M44926|

; 572  :     BOOL bVal = FALSE;//TRUE;
; 573  :     // work around for a OMAP35XX silicon issue (data CRC error on READ_MULTIPLE_BLOCK command)
; 574  :     // This is present in earley processor revisions
; 575  :     if(m_dwCPURev <= CPU_FAMILY_35XX_REVISION_ES_3_0)
; 576  :     {
; 577  :         bVal = FALSE;
; 578  :     }
; 579  :     return bVal;

  00000	e3a00000	 mov         r0, #0

; 580  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M44927|

			 ENDP  ; |?IsMultipleBlockReadSupported@CSDIOControllerBase@@IAAHXZ|, CSDIOControllerBase::IsMultipleBlockReadSupported

	EXPORT	|?SetSDVSVoltage@CSDIOControllerBase@@QAAXXZ| ; CSDIOControllerBase::SetSDVSVoltage
	EXPORT	|??_C@_1DO@OCDBIGLO@?$AAM?$AAM?$AAC?$AA?5?$AAS?$AAl?$AAo?$AAt?$AA?5?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AA?5?$AAi?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAV?$AAa?$AAl?$AAi?$AAd?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T44945| DCD	|$LN29@SetSDVSVol|
	DCD	0x40003001

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DO@OCDBIGLO@?$AAM?$AAM?$AAC?$AA?5?$AAS?$AAl?$AAo?$AAt?$AA?5?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AA?5?$AAi?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAV?$AAa?$AAl?$AAi?$AAd?$AA?$AN?$AA?6?$AA?$AA@| DCB "M"
	DCB	0x0, "M", 0x0, "C", 0x0, " ", 0x0, "S", 0x0, "l", 0x0, "o"
	DCB	0x0, "t", 0x0, " ", 0x0, "n", 0x0, "u", 0x0, "m", 0x0, "b"
	DCB	0x0, "e", 0x0, "r", 0x0, " ", 0x0, "i", 0x0, "s", 0x0, " "
	DCB	0x0, "n", 0x0, "o", 0x0, "t", 0x0, " ", 0x0, "V", 0x0, "a"
	DCB	0x0, "l", 0x0, "i", 0x0, "d", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetSDVSVoltage@CSDIOControllerBase@@QAAXXZ| PROC ; CSDIOControllerBase::SetSDVSVoltage

; 585  : {

  00000		 |$LN29@SetSDVSVol|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44942|

; 586  :     UINT32 val1, val2;
; 587  : 
; 588  :     if ( m_dwSlot == MMCSLOT_1 )

  00004	e5903170	 ldr         r3, [r0, #0x170]
  00008	e3530001	 cmp         r3, #1
  0000c	1a000007	 bne         |$LN20@SetSDVSVol|

; 589  :     {
; 590  :         if(m_dwCPURev == CPU_FAMILY_35XX_REVISION_ES_1_0) // ES 1.0

  00010	e590317c	 ldr         r3, [r0, #0x17C]
  00014	e3530000	 cmp         r3, #0

; 591  :         {
; 592  :           val1 = MMCHS_CAPA_VS30;
; 593  :           val2 = MMCHS_HCTL_SDVS_3V0;

  00018	0a000010	 beq         |$LN15@SetSDVSVol|

; 594  :         }
; 595  :         else if(m_dwCPURev == CPU_FAMILY_35XX_REVISION_ES_2_0) // ES 2.0

  0001c	e3530001	 cmp         r3, #1

; 596  :         {
; 597  :           val1 = MMCHS_CAPA_VS18;
; 598  :           val2 = MMCHS_HCTL_SDVS_1V8;

  00020	0a000011	 beq         |$LN5@SetSDVSVol|

; 599  :         }
; 600  :         else if(m_dwCPURev == CPU_FAMILY_35XX_REVISION_ES_2_1) // ES 2.1

  00024	e3530002	 cmp         r3, #2
  00028	1a00000c	 bne         |$LN15@SetSDVSVol|

; 601  :         {
; 602  :             if (m_LowVoltageSlot)
; 603  :             {
; 604  :                 val1 = MMCHS_CAPA_VS18;
; 605  :                 val2 = MMCHS_HCTL_SDVS_1V8;
; 606  :             }
; 607  :             else
; 608  :             {
; 609  :                 val1 = MMCHS_CAPA_VS30;
; 610  :                 val2 = MMCHS_HCTL_SDVS_3V0;
; 611  :             }
; 612  :         }
; 613  :         else // ES3.x and later
; 614  :         {
; 615  :           val1 = MMCHS_CAPA_VS30;
; 616  :           val2 = MMCHS_HCTL_SDVS_3V0;
; 617  :         }
; 618  : 
; 619  :         SETREG32(&m_pbRegisters->MMCHS_CAPA, val1);
; 620  :         SETREG32(&m_pbRegisters->MMCHS_HCTL, val2);

  0002c	ea000008	 b           |$LN26@SetSDVSVol|
  00030		 |$LN20@SetSDVSVol|

; 621  :     }
; 622  :     else if (m_dwSlot == MMCSLOT_2)

  00030	e3530002	 cmp         r3, #2
  00034	1a000018	 bne         |$LN10@SetSDVSVol|

; 623  :     {
; 624  :         if(m_dwCPURev == CPU_FAMILY_35XX_REVISION_ES_1_0) // ES 1.0

  00038	e590317c	 ldr         r3, [r0, #0x17C]
  0003c	e3530000	 cmp         r3, #0

; 625  :         {
; 626  :           val1 = MMCHS_CAPA_VS18;
; 627  :           val2 = MMCHS_HCTL_SDVS_1V8;

  00040	0a000009	 beq         |$LN5@SetSDVSVol|

; 628  :         }
; 629  :         else if(m_dwCPURev == CPU_FAMILY_35XX_REVISION_ES_2_0) // ES 2.0

  00044	e3530001	 cmp         r3, #1

; 630  :         {
; 631  :           val1 = MMCHS_CAPA_VS18;
; 632  :           val2 = MMCHS_HCTL_SDVS_1V8;

  00048	0a000007	 beq         |$LN5@SetSDVSVol|

; 633  :         }
; 634  :         else if(m_dwCPURev == CPU_FAMILY_35XX_REVISION_ES_2_1) // ES 2.1

  0004c	e3530002	 cmp         r3, #2
  00050	1a000005	 bne         |$LN5@SetSDVSVol|
  00054		 |$LN26@SetSDVSVol|

; 635  :         {
; 636  :             if (m_LowVoltageSlot)

  00054	e590318c	 ldr         r3, [r0, #0x18C]
  00058	e3530000	 cmp         r3, #0

; 637  :             {
; 638  :                 val1 = MMCHS_CAPA_VS18;
; 639  :                 val2 = MMCHS_HCTL_SDVS_1V8;
; 640  :             }
; 641  :             else

  0005c	1a000002	 bne         |$LN5@SetSDVSVol|
  00060		 |$LN15@SetSDVSVol|

; 642  :             {
; 643  :                 val1 = MMCHS_CAPA_VS30;

  00060	e3a01402	 mov         r1, #2, 8

; 644  :                 val2 = MMCHS_HCTL_SDVS_3V0;

  00064	e3a0eb03	 mov         lr, #3, 22

; 645  :             }
; 646  :         }
; 647  :         else // ES 3.x and later

  00068	ea000001	 b           |$LN2@SetSDVSVol|
  0006c		 |$LN5@SetSDVSVol|

; 648  :         {
; 649  :           val1 = MMCHS_CAPA_VS18;

  0006c	e3a01301	 mov         r1, #1, 6

; 650  :           val2 = MMCHS_HCTL_SDVS_1V8;

  00070	e3a0ec0a	 mov         lr, #0xA, 24
  00074		 |$LN2@SetSDVSVol|

; 651  :         }
; 652  :         SETREG32(&m_pbRegisters->MMCHS_CAPA, val1);

  00074	e590215c	 ldr         r2, [r0, #0x15C]
  00078	e5923140	 ldr         r3, [r2, #0x140]
  0007c	e1833001	 orr         r3, r3, r1
  00080	e5823140	 str         r3, [r2, #0x140]

; 653  :         SETREG32(&m_pbRegisters->MMCHS_HCTL, val2);

  00084	e590215c	 ldr         r2, [r0, #0x15C]
  00088	e5923128	 ldr         r3, [r2, #0x128]
  0008c	e183300e	 orr         r3, r3, lr
  00090	e5823128	 str         r3, [r2, #0x128]

; 658  :         return;
; 659  :     }
; 660  : }

  00094	e49de004	 ldr         lr, [sp], #4
  00098	e12fff1e	 bx          lr
  0009c		 |$LN10@SetSDVSVol|

; 654  :     }
; 655  :     else
; 656  :     {
; 657  :         RETAILMSG(SDCARD_ZONE_WARN, (L"MMC Slot number is not Valid\r\n"));

  0009c	e59f3018	 ldr         r3, [pc, #0x18]
  000a0	e5933440	 ldr         r3, [r3, #0x440]
  000a4	e3130901	 tst         r3, #1, 18
  000a8	159f0008	 ldrne       r0, [pc, #8]
  000ac	1b000000	 blne        NKDbgPrintfW

; 658  :         return;
; 659  :     }
; 660  : }

  000b0	e49de004	 ldr         lr, [sp], #4
  000b4	e12fff1e	 bx          lr
  000b8		 |$LN30@SetSDVSVol|
  000b8		 |$LN31@SetSDVSVol|
  000b8	00000000	 DCD         |??_C@_1DO@OCDBIGLO@?$AAM?$AAM?$AAC?$AA?5?$AAS?$AAl?$AAo?$AAt?$AA?5?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AA?5?$AAi?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAV?$AAa?$AAl?$AAi?$AAd?$AA?$AN?$AA?6?$AA?$AA@|
  000bc		 |$LN32@SetSDVSVol|
  000bc	00000000	 DCD         |dpCurSettings|
  000c0		 |$M44943|

			 ENDP  ; |?SetSDVSVoltage@CSDIOControllerBase@@QAAXXZ|, CSDIOControllerBase::SetSDVSVoltage

	EXPORT	|?UpdateDevicePowerState@CSDIOControllerBase@@QAAXH@Z| ; CSDIOControllerBase::UpdateDevicePowerState
	IMPORT	|SetDevicePowerState|

  00000			 AREA	 |.pdata|, PDATA
|$T44962| DCD	|$LN16@UpdateDevi|
	DCD	0x40003101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdateDevicePowerState@CSDIOControllerBase@@QAAXH@Z| PROC ; CSDIOControllerBase::UpdateDevicePowerState

; 841  : {

  00000		 |$LN16@UpdateDevi|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M44959|
  00004	e1a06001	 mov         r6, r1
  00008	e1a05000	 mov         r5, r0

; 842  :     CEDEVICE_POWER_STATE curPowerState = D4;
; 843  : 
; 844  :     // if card is present then lowest power state is D3
; 845  :     if (m_fCardPresent)

  0000c	e59530f0	 ldr         r3, [r5, #0xF0]
  00010	e3a04004	 mov         r4, #4
  00014	e3530000	 cmp         r3, #0

; 846  :         curPowerState = D3;
; 847  : 
; 848  :     curPowerState = min(curPowerState, m_InternPowerState);

  00018	e59530dc	 ldr         r3, [r5, #0xDC]
  0001c	13a04003	 movne       r4, #3
  00020	e1540003	 cmp         r4, r3
  00024	a1a04003	 movge       r4, r3

; 849  : 
; 850  :     if((m_ActualPowerState == D4 && curPowerState < D4 ) || (m_ActualPowerState < D4 && curPowerState == D4 ))

  00028	e59530e0	 ldr         r3, [r5, #0xE0]
  0002c	e3530004	 cmp         r3, #4
  00030	1a000002	 bne         |$LN12@UpdateDevi|
  00034	e3540004	 cmp         r4, #4
  00038	ba000003	 blt         |$LN5@UpdateDevi|
  0003c	e3530004	 cmp         r3, #4
  00040		 |$LN12@UpdateDevi|
  00040	aa000008	 bge         |$LN6@UpdateDevi|
  00044	e3540004	 cmp         r4, #4
  00048	1a000006	 bne         |$LN6@UpdateDevi|
  0004c		 |$LN5@UpdateDevi|

; 851  :         PreparePowerChange(curPowerState, bInPowerHandler);

  0004c	e5953000	 ldr         r3, [r5]
  00050	e1a02006	 mov         r2, r6
  00054	e1a01004	 mov         r1, r4
  00058	e593301c	 ldr         r3, [r3, #0x1C]
  0005c	e1a00005	 mov         r0, r5
  00060	e1a0e00f	 mov         lr, pc
  00064	e12fff13	 bx          r3
  00068		 |$LN6@UpdateDevi|

; 852  : 
; 853  :     SetDevicePowerState( m_hParentBus, curPowerState, NULL );

  00068	e59500ac	 ldr         r0, [r5, #0xAC]
  0006c	e3a02000	 mov         r2, #0
  00070	e1a01004	 mov         r1, r4
  00074	eb000000	 bl          SetDevicePowerState

; 854  : 
; 855  :     if((m_ActualPowerState == D4 && curPowerState < D4 ) || (m_ActualPowerState < D4 && curPowerState == D4 ))

  00078	e59530e0	 ldr         r3, [r5, #0xE0]
  0007c	e3530004	 cmp         r3, #4
  00080	1a000002	 bne         |$LN13@UpdateDevi|
  00084	e3540004	 cmp         r4, #4
  00088	ba000003	 blt         |$LN2@UpdateDevi|
  0008c	e3530004	 cmp         r3, #4
  00090		 |$LN13@UpdateDevi|
  00090	aa000008	 bge         |$LN3@UpdateDevi|
  00094	e3540004	 cmp         r4, #4
  00098	1a000006	 bne         |$LN3@UpdateDevi|
  0009c		 |$LN2@UpdateDevi|

; 856  :         PostPowerChange(curPowerState, bInPowerHandler);

  0009c	e5953000	 ldr         r3, [r5]
  000a0	e1a02006	 mov         r2, r6
  000a4	e1a01004	 mov         r1, r4
  000a8	e5933020	 ldr         r3, [r3, #0x20]
  000ac	e1a00005	 mov         r0, r5
  000b0	e1a0e00f	 mov         lr, pc
  000b4	e12fff13	 bx          r3
  000b8		 |$LN3@UpdateDevi|

; 857  : 
; 858  :     m_ActualPowerState = curPowerState;

  000b8	e58540e0	 str         r4, [r5, #0xE0]

; 859  : }

  000bc	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000c0	e12fff1e	 bx          lr
  000c4		 |$M44960|

			 ENDP  ; |?UpdateDevicePowerState@CSDIOControllerBase@@QAAXH@Z|, CSDIOControllerBase::UpdateDevicePowerState

	EXPORT	|?SendCmdNoResp@CSDIOControllerBase@@QAAJKK@Z| ; CSDIOControllerBase::SendCmdNoResp

  00000			 AREA	 |.pdata|, PDATA
|$T44991| DCD	|$LN19@SendCmdNoR|
	DCD	0x40002d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SendCmdNoResp@CSDIOControllerBase@@QAAJKK@Z| PROC ; CSDIOControllerBase::SendCmdNoResp

; 864  : {

  00000		 |$LN19@SendCmdNoR|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44988|

; 865  :     DWORD MMC_CMD;
; 866  :     DWORD dwTimeout;
; 867  : 
; 868  :     OUTREG32(&m_pbRegisters->MMCHS_STAT, 0xFFFFFFFF);

  00004	e590315c	 ldr         r3, [r0, #0x15C]
  00008	e3e0e000	 mvn         lr, #0
  0000c	e3a05b4e	 mov         r5, #0x4E, 22
  00010	e583e130	 str         lr, [r3, #0x130]

; 869  :     dwTimeout = 80000;
; 870  :     while(((INREG32(&m_pbRegisters->MMCHS_PSTATE) & MMCHS_PSTAT_CMDI)) && (dwTimeout>0))

  00014	e590415c	 ldr         r4, [r0, #0x15C]
  00018	e385e080	 orr         lr, r5, #0x80
  0001c	ea000002	 b           |$LN16@SendCmdNoR|
  00020		 |$LL5@SendCmdNoR|
  00020	e35e0000	 cmp         lr, #0
  00024	0a000003	 beq         |$LN14@SendCmdNoR|

; 871  :     {
; 872  :         dwTimeout--;

  00028	e24ee001	 sub         lr, lr, #1
  0002c		 |$LN16@SendCmdNoR|

; 869  :     dwTimeout = 80000;
; 870  :     while(((INREG32(&m_pbRegisters->MMCHS_PSTATE) & MMCHS_PSTAT_CMDI)) && (dwTimeout>0))

  0002c	e5943124	 ldr         r3, [r4, #0x124]

; 871  :     {
; 872  :         dwTimeout--;

  00030	e3130001	 tst         r3, #1
  00034	1afffff9	 bne         |$LL5@SendCmdNoR|
  00038		 |$LN14@SendCmdNoR|

; 873  :     }
; 874  : 
; 875  :     MMC_CMD = MMCHS_INDX(cmd);
; 876  :     MMC_CMD |= LOOKUP_CMD(cmd).flags;

  00038	e351003c	 cmp         r1, #0x3C
  0003c	1a000004	 bne         |$LN8@SendCmdNoR|
  00040	e5903198	 ldr         r3, [r0, #0x198]
  00044	e3530000	 cmp         r3, #0
  00048	159f3060	 ldrne       r3, [pc, #0x60]
  0004c	12833c02	 addne       r3, r3, #2, 24
  00050	1a000001	 bne         |$LN9@SendCmdNoR|
  00054		 |$LN8@SendCmdNoR|
  00054	e59f3054	 ldr         r3, [pc, #0x54]
  00058	e0833181	 add         r3, r3, r1, lsl #3
  0005c		 |$LN9@SendCmdNoR|

; 877  : 
; 878  :     // Program the argument into the argument registers
; 879  :     OUTREG32(&m_pbRegisters->MMCHS_ARG, arg);

  0005c	e5933004	 ldr         r3, [r3, #4]
  00060	e5842108	 str         r2, [r4, #0x108]

; 880  :     // Issue the command.
; 881  :     OUTREG32(&m_pbRegisters->MMCHS_CMD, MMC_CMD);

  00064	e590215c	 ldr         r2, [r0, #0x15C]
  00068	e1833c01	 orr         r3, r3, r1, lsl #24
  0006c	e3a01c13	 mov         r1, #0x13, 24
  00070	e582310c	 str         r3, [r2, #0x10C]

; 882  : 
; 883  :     dwTimeout = 5000;

  00074	e590215c	 ldr         r2, [r0, #0x15C]
  00078	e3a03211	 mov         r3, #0x11, 4
  0007c	e3830801	 orr         r0, r3, #1, 16
  00080	e3811088	 orr         r1, r1, #0x88
  00084		 |$LL3@SendCmdNoR|

; 886  :     {
; 887  :         dwTimeout --;
; 888  :         dwVal = INREG32(&m_pbRegisters->MMCHS_STAT);

  00084	e5923130	 ldr         r3, [r2, #0x130]
  00088	e2411001	 sub         r1, r1, #1

; 889  :         if(dwVal & (MMCHS_STAT_CC | MMCHS_STAT_CTO | MMCHS_STAT_CERR)) break;

  0008c	e1130000	 tst         r3, r0
  00090	1a000001	 bne         |$LN12@SendCmdNoR|

; 884  :     DWORD dwVal;
; 885  :     while(dwTimeout > 0)

  00094	e3510000	 cmp         r1, #0
  00098	1afffff9	 bne         |$LL3@SendCmdNoR|
  0009c		 |$LN12@SendCmdNoR|

; 890  :     }
; 891  : 
; 892  :     dwVal = INREG32(&m_pbRegisters->MMCHS_STAT);

  0009c	e5923130	 ldr         r3, [r2, #0x130]

; 893  :     OUTREG32(&m_pbRegisters->MMCHS_STAT, dwVal);
; 894  : 
; 895  :     // always return 0 if no response needed
; 896  :     return SD_API_STATUS_SUCCESS;

  000a0	e3a00000	 mov         r0, #0
  000a4	e5823130	 str         r3, [r2, #0x130]

; 897  : }

  000a8	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000ac	e12fff1e	 bx          lr
  000b0		 |$LN20@SendCmdNoR|
  000b0		 |$LN21@SendCmdNoR|
  000b0	00000000	 DCD         |?gwaCMD@@3PAUCMD@@A|
  000b4		 |$M44989|

			 ENDP  ; |?SendCmdNoResp@CSDIOControllerBase@@QAAJKK@Z|, CSDIOControllerBase::SendCmdNoResp

	EXPORT	|?SendInitSequence@CSDIOControllerBase@@QAAXXZ| ; CSDIOControllerBase::SendInitSequence

  00000			 AREA	 |.pdata|, PDATA
|$T45003| DCD	|$LN10@SendInitSe|
	DCD	0x40001d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SendInitSequence@CSDIOControllerBase@@QAAXXZ| PROC ; CSDIOControllerBase::SendInitSequence

; 902  : {

  00000		 |$LN10@SendInitSe|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45000|
  00004	e1a04000	 mov         r4, r0

; 903  :     EnterCriticalSection( &m_critSec );

  00008	e28400b0	 add         r0, r4, #0xB0
  0000c	eb000000	 bl          EnterCriticalSection

; 904  :     OUTREG32(&m_pbRegisters->MMCHS_IE,  0xFFFFFEFF);

  00010	e594315c	 ldr         r3, [r4, #0x15C]
  00014	e3e02c01	 mvn         r2, #1, 24
  00018	e3a0500a	 mov         r5, #0xA
  0001c	e5832134	 str         r2, [r3, #0x134]

; 905  :     SETREG32(&m_pbRegisters->MMCHS_CON, MMCHS_CON_INIT);

  00020	e594215c	 ldr         r2, [r4, #0x15C]
  00024	e3e06000	 mvn         r6, #0
  00028	e592302c	 ldr         r3, [r2, #0x2C]
  0002c	e3833002	 orr         r3, r3, #2
  00030	e582302c	 str         r3, [r2, #0x2C]
  00034		 |$LL3@SendInitSe|

; 906  : 
; 907  :     DWORD dwCount;
; 908  :     for(dwCount = 0; dwCount < 10; dwCount ++)
; 909  :     {
; 910  :         SendCmdNoResp(SD_CMD_GO_IDLE_STATE, 0xFFFFFFFF);

  00034	e1a02006	 mov         r2, r6
  00038	e3a01000	 mov         r1, #0
  0003c	e1a00004	 mov         r0, r4
  00040	eb000000	 bl          |?SendCmdNoResp@CSDIOControllerBase@@QAAJKK@Z|
  00044	e2555001	 subs        r5, r5, #1
  00048	1afffff9	 bne         |$LL3@SendInitSe|

; 911  :     }
; 912  :     OUTREG32(&m_pbRegisters->MMCHS_STAT, 0xFFFFFFFF);

  0004c	e594315c	 ldr         r3, [r4, #0x15C]

; 913  :     CLRREG32(&m_pbRegisters->MMCHS_CON, MMCHS_CON_INIT);
; 914  :     LeaveCriticalSection( &m_critSec );

  00050	e28400b0	 add         r0, r4, #0xB0
  00054	e5836130	 str         r6, [r3, #0x130]
  00058	e594215c	 ldr         r2, [r4, #0x15C]
  0005c	e592302c	 ldr         r3, [r2, #0x2C]
  00060	e3c33002	 bic         r3, r3, #2
  00064	e582302c	 str         r3, [r2, #0x2C]
  00068	eb000000	 bl          LeaveCriticalSection

; 915  : }

  0006c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00070	e12fff1e	 bx          lr
  00074		 |$M45001|

			 ENDP  ; |?SendInitSequence@CSDIOControllerBase@@QAAXXZ|, CSDIOControllerBase::SendInitSequence

	EXPORT	|?SendCommand@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z| ; CSDIOControllerBase::SendCommand
	IMPORT	|?SDIO_InitOutputDMA@CSDIOControllerBase@@QAAXKK@Z| ; CSDIOControllerBase::SDIO_InitOutputDMA
	IMPORT	|?SDIO_InitInputDMA@CSDIOControllerBase@@QAAXKK@Z| ; CSDIOControllerBase::SDIO_InitInputDMA

  00000			 AREA	 |.pdata|, PDATA
|$T45039| DCD	|$LN44@SendComman|
	DCD	0x4000a901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SendCommand@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z| PROC ; CSDIOControllerBase::SendCommand

; 920  : {

  00000		 |$LN44@SendComman|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M45036|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 921  :     DWORD MMC_CMD;
; 922  :     DWORD dwTimeout;
; 923  :     DWORD Cmd = pRequest->CommandCode;
; 924  :     DWORD Arg = pRequest->CommandArgument;
; 925  :     UINT16 respType = (UINT16)pRequest->CommandResponse.ResponseType;

  0000c	e595301c	 ldr         r3, [r5, #0x1C]
  00010	e5d56014	 ldrb        r6, [r5, #0x14]

; 926  :     DWORD dwRegVal;
; 927  : 
; 928  :     m_TransferClass = pRequest->TransferClass;

  00014	e5952010	 ldr         r2, [r5, #0x10]
  00018	e5958018	 ldr         r8, [r5, #0x18]
  0001c	e1a07803	 mov         r7, r3, lsl #16
  00020	e1a07827	 mov         r7, r7, lsr #16
  00024	e58421d8	 str         r2, [r4, #0x1D8]

; 929  : 
; 930  :     DEBUGMSG(SHC_SEND_ZONE, (TEXT("SendCommand() - Cmd = 0x%x Arg = 0x%x respType = 0x%x m_TransferClass = 0x%x\r\n"),
; 931  :         Cmd, Arg, respType, m_TransferClass));
; 932  : 
; 933  :     if ((Cmd == SD_CMD_IO_RW_EXTENDED) || (Cmd == SD_CMD_IO_RW_DIRECT))

  00028	e3560035	 cmp         r6, #0x35
  0002c	e3a09000	 mov         r9, #0
  00030	e3a0a001	 mov         r10, #1
  00034	0a000007	 beq         |$LN24@SendComman|
  00038	e3560034	 cmp         r6, #0x34
  0003c	0a000005	 beq         |$LN24@SendComman|

; 936  :     } else
; 937  :     if ((Cmd == SD_CMD_MMC_SEND_OPCOND) || (Cmd == SD_CMD_GO_IDLE_STATE))

  00040	e3560001	 cmp         r6, #1
  00044	0a000001	 beq         |$LN21@SendComman|
  00048	e3560000	 cmp         r6, #0
  0004c	1a000002	 bne         |$LN22@SendComman|
  00050		 |$LN21@SendComman|

; 938  :     {
; 939  :         m_dwSDIOCard = 0;

  00050	e5849178	 str         r9, [r4, #0x178]
  00054	ea000000	 b           |$LN22@SendComman|
  00058		 |$LN24@SendComman|

; 934  :     {
; 935  :         m_dwSDIOCard = 1;

  00058	e584a178	 str         r10, [r4, #0x178]
  0005c		 |$LN22@SendComman|

; 940  :     }
; 941  : 
; 942  :     if( m_TransferClass == SD_READ || m_TransferClass == SD_WRITE )
; 943  :     {
; 944  :         DEBUGMSG(SHC_SDBUS_INTERACT_ZONE, (TEXT("SendCommand (Cmd=0x%08X, Arg=0x%08x, RespType=0x%08X, Data=0x%x <%dx%d>) starts\r\n"),
; 945  :             Cmd, Arg, respType, (m_TransferClass==SD_COMMAND)?FALSE:TRUE, pRequest->NumBlocks, pRequest->BlockSize ) );
; 946  : #ifdef ENABLE_RETAIL_OUTPUT
; 947  :         RETAILMSG(1, (TEXT("SendCommand (Cmd=0x%08X, Arg=0x%08x, RespType=0x%08X, Data=0x%x <%dx%d>) starts\r\n"),
; 948  :             Cmd, Arg, respType, (m_TransferClass==SD_COMMAND)?FALSE:TRUE, pRequest->NumBlocks, pRequest->BlockSize ) );
; 949  : #endif
; 950  :     }
; 951  :     else
; 952  :     {
; 953  :         DEBUGMSG(SHC_SDBUS_INTERACT_ZONE, (TEXT("SendCommand (Cmd=0x%08X, Arg=0x%08x, RespType=0x%08X, Data=0x%x) starts\r\n"),
; 954  :             Cmd, Arg, respType, (m_TransferClass==SD_COMMAND)?FALSE:TRUE) );
; 955  : #ifdef ENABLE_RETAIL_OUTPUT
; 956  :         RETAILMSG(1, (TEXT("SendCommand (Cmd=0x%08X, Arg=0x%08x, RespType=0x%08X, Data=0x%x) starts\r\n"),
; 957  :             Cmd, Arg, respType, (m_TransferClass==SD_COMMAND)?FALSE:TRUE) );
; 958  : #endif
; 959  :     }
; 960  : 
; 961  :     // turn the clock on
; 962  :     //if(!(pRequest->SystemFlags & SD_FAST_PATH_AVAILABLE))
; 963  :     //   UpdateSystemClock(TRUE);
; 964  : 
; 965  :     Write_MMC_STAT(0xFFFFFFFF);

  0005c	e28400b0	 add         r0, r4, #0xB0
  00060	eb000000	 bl          EnterCriticalSection
  00064	e594315c	 ldr         r3, [r4, #0x15C]
  00068	e3e02000	 mvn         r2, #0
  0006c	e28400b0	 add         r0, r4, #0xB0
  00070	e5832130	 str         r2, [r3, #0x130]
  00074	eb000000	 bl          LeaveCriticalSection

; 966  :     dwTimeout = 2000;
; 967  :     while(((INREG32(&m_pbRegisters->MMCHS_PSTATE) & MMCHS_PSTAT_CMDI)) && (dwTimeout>0))

  00078	e3a02e7d	 mov         r2, #0x7D, 28
  0007c	ea000002	 b           |$LN41@SendComman|
  00080		 |$LL17@SendComman|
  00080	e3520000	 cmp         r2, #0
  00084	0a000004	 beq         |$LN39@SendComman|

; 968  :     {
; 969  :         dwTimeout--;

  00088	e2422001	 sub         r2, r2, #1
  0008c		 |$LN41@SendComman|

; 966  :     dwTimeout = 2000;
; 967  :     while(((INREG32(&m_pbRegisters->MMCHS_PSTATE) & MMCHS_PSTAT_CMDI)) && (dwTimeout>0))

  0008c	e594315c	 ldr         r3, [r4, #0x15C]

; 968  :     {
; 969  :         dwTimeout--;

  00090	e5933124	 ldr         r3, [r3, #0x124]
  00094	e3130001	 tst         r3, #1
  00098	1afffff8	 bne         |$LL17@SendComman|
  0009c		 |$LN39@SendComman|

; 970  :     }
; 971  :     MMC_CMD = MMCHS_INDX(Cmd);
; 972  : 
; 973  :     // CMD6 is defined differently in MMC and SD specifications, try to identify them here 
; 974  :     // and use appropriate controller settings. 
; 975  :     if (IS_SDHC_SWITCH_COMMAND(pRequest,Cmd))

  0009c	e5943198	 ldr         r3, [r4, #0x198]
  000a0	e1b02003	 movs        r2, r3
  000a4	0a000006	 beq         |$LN15@SendComman|
  000a8	e5953010	 ldr         r3, [r5, #0x10]
  000ac	e3530000	 cmp         r3, #0
  000b0	03560006	 cmpeq       r6, #6

; 976  :     	{
; 977  :         DEBUGMSG(SHC_SDBUS_INTERACT_ZONE,(TEXT("SendCommand:: branch for switch command\r\n")));
; 978  :         MMC_CMD |= ADJUST_FOR_SDHC_SWITCH_CMD(Cmd);

  000b4	059f31e4	 ldreq       r3, [pc, #0x1E4]
  000b8	05933204	 ldreq       r3, [r3, #0x204]
  000bc	01833c06	 orreq       r3, r3, r6, lsl #24
  000c0	0a00000c	 beq         |$LN13@SendComman|
  000c4		 |$LN15@SendComman|

; 979  :     	}
; 980  :     else
; 981  :         MMC_CMD |= LOOKUP_CMD(Cmd).flags;

  000c4	e356003c	 cmp         r6, #0x3C
  000c8	1a000003	 bne         |$LN32@SendComman|
  000cc	e3520000	 cmp         r2, #0
  000d0	159f31c8	 ldrne       r3, [pc, #0x1C8]
  000d4	12833c02	 addne       r3, r3, #2, 24
  000d8	1a000001	 bne         |$LN33@SendComman|
  000dc		 |$LN32@SendComman|
  000dc	e59f31bc	 ldr         r3, [pc, #0x1BC]
  000e0	e0833186	 add         r3, r3, r6, lsl #3
  000e4		 |$LN33@SendComman|
  000e4	e5933004	 ldr         r3, [r3, #4]

; 982  : 	
; 983  :     if ((Cmd == SD_CMD_SELECT_DESELECT_CARD) && (respType == NoResponse))

  000e8	e3560007	 cmp         r6, #7
  000ec	03570000	 cmpeq       r7, #0
  000f0	e1833c06	 orr         r3, r3, r6, lsl #24

; 984  :     {
; 985  :         MMC_CMD &= ~MMCHS_RSP_MASK;

  000f4	03c33803	 biceq       r3, r3, #3, 16
  000f8		 |$LN13@SendComman|

; 986  :         MMC_CMD |= MMCHS_RSP_NONE;
; 987  :     }
; 988  : 
; 989  :     m_fDMATransfer = FALSE;
; 990  :     MMC_CMD &= ~MMCHS_CMD_DE;

  000f8	e3c37001	 bic         r7, r3, #1
  000fc	e5849110	 str         r9, [r4, #0x110]

; 991  : 
; 992  :     if (Cmd == SD_CMD_IO_RW_EXTENDED)

  00100	e3560035	 cmp         r6, #0x35
  00104	1a000002	 bne         |$LN11@SendComman|

; 993  :     {
; 994  :         if(pRequest->NumBlocks > 1)

  00108	e595303c	 ldr         r3, [r5, #0x3C]
  0010c	e3530001	 cmp         r3, #1

; 995  :         {
; 996  :            MMC_CMD |= MMCHS_CMD_MSBS | MMCHS_CMD_BCE;

  00110	83877022	 orrhi       r7, r7, #0x22
  00114		 |$LN11@SendComman|

; 997  :         }
; 998  :     }
; 999  : 
; 1000 :     if( m_TransferClass == SD_READ )

  00114	e59431d8	 ldr         r3, [r4, #0x1D8]
  00118	e3530000	 cmp         r3, #0
  0011c	1a000025	 bne         |$LN10@SendComman|

; 1001 :     {
; 1002 :         MMC_CMD |= MMCHS_CMD_DDIR;
; 1003 : 
; 1004 : #ifdef SDIO_DMA_READ_ENABLED
; 1005 :        // if we can use the DMA for transfer...
; 1006 :        if( ((( pRequest->NumBlocks > 1) && !(pRequest->SystemFlags & SD_FAST_PATH_AVAILABLE)) || 
; 1007 :        (( pRequest->NumBlocks > 0) && (pRequest->SystemFlags & SD_FAST_PATH_AVAILABLE))) &&
; 1008 :             ( TRANSFER_SIZE(pRequest) % MIN_MMC_BLOCK_SIZE == 0 ) &&
; 1009 :             ( TRANSFER_SIZE(pRequest) <= m_dwDMABufferSize ) )

  00120	e595203c	 ldr         r2, [r5, #0x3C]
  00124	e3877010	 orr         r7, r7, #0x10
  00128	e3520001	 cmp         r2, #1
  0012c	9a000002	 bls         |$LN7@SendComman|
  00130	e595300c	 ldr         r3, [r5, #0xC]
  00134	e3130102	 tst         r3, #2, 2
  00138	0a000004	 beq         |$LN8@SendComman|
  0013c		 |$LN7@SendComman|
  0013c	e3520000	 cmp         r2, #0
  00140	0a000043	 beq         |$LN4@SendComman|
  00144	e595300c	 ldr         r3, [r5, #0xC]
  00148	e3130102	 tst         r3, #2, 2
  0014c	0a000040	 beq         |$LN4@SendComman|
  00150		 |$LN8@SendComman|
  00150	e5953040	 ldr         r3, [r5, #0x40]
  00154	e0010392	 mul         r1, r2, r3
  00158	e3110003	 tst         r1, #3
  0015c	1a00003c	 bne         |$LN4@SendComman|
  00160	e59431fc	 ldr         r3, [r4, #0x1FC]
  00164	e1510003	 cmp         r1, r3
  00168	8a000039	 bhi         |$LN4@SendComman|

; 1010 :         {
; 1011 :             MMC_CMD |= MMCHS_CMD_DE;
; 1012 :             m_fDMATransfer = TRUE;
; 1013 :             // program the DMA controller
; 1014 :             EnterCriticalSection( &m_critSec );

  0016c	e28400b0	 add         r0, r4, #0xB0
  00170	e3877001	 orr         r7, r7, #1
  00174	e584a110	 str         r10, [r4, #0x110]
  00178	eb000000	 bl          EnterCriticalSection

; 1015 :             SETREG32(&m_pbRegisters->MMCHS_IE, MMCHS_IE_BRR);

  0017c	e594215c	 ldr         r2, [r4, #0x15C]

; 1016 :             SETREG32(&m_pbRegisters->MMCHS_ISE, MMCHS_IE_BRR);
; 1017 :             LeaveCriticalSection( &m_critSec );

  00180	e28400b0	 add         r0, r4, #0xB0
  00184	e5923134	 ldr         r3, [r2, #0x134]
  00188	e3833020	 orr         r3, r3, #0x20
  0018c	e5823134	 str         r3, [r2, #0x134]
  00190	e594215c	 ldr         r2, [r4, #0x15C]
  00194	e5923138	 ldr         r3, [r2, #0x138]
  00198	e3833020	 orr         r3, r3, #0x20
  0019c	e5823138	 str         r3, [r2, #0x138]
  001a0	eb000000	 bl          LeaveCriticalSection

; 1018 :             SDIO_InitInputDMA( pRequest->NumBlocks,  pRequest->BlockSize);

  001a4	e5952040	 ldr         r2, [r5, #0x40]
  001a8	e595103c	 ldr         r1, [r5, #0x3C]
  001ac	e1a00004	 mov         r0, r4
  001b0	eb000000	 bl          |?SDIO_InitInputDMA@CSDIOControllerBase@@QAAXKK@Z|

; 1019 :         }
; 1020 : #endif
; 1021 :         dwRegVal = (DWORD)(pRequest->BlockSize & 0xFFFF);
; 1022 :         dwRegVal += ((DWORD)(pRequest->NumBlocks & 0xFFFF)) << 16;
; 1023 :         OUTREG32(&m_pbRegisters->MMCHS_BLK, dwRegVal);

  001b4	ea000026	 b           |$LN4@SendComman|
  001b8		 |$LN10@SendComman|

; 1024 :     }
; 1025 :     else if( m_TransferClass == SD_WRITE )

  001b8	e3530001	 cmp         r3, #1
  001bc	1a00002c	 bne         |$LN5@SendComman|

; 1026 :     {
; 1027 :         MMC_CMD &= ~MMCHS_CMD_DDIR;
; 1028 : 
; 1029 : #ifdef SDIO_DMA_WRITE_ENABLED
; 1030 :         // if we can use the DMA for transfer...
; 1031 :        if( ((( pRequest->NumBlocks > 1) && !(pRequest->SystemFlags & SD_FAST_PATH_AVAILABLE)) || 
; 1032 :        (( pRequest->NumBlocks > 0) && (pRequest->SystemFlags & SD_FAST_PATH_AVAILABLE))) &&
; 1033 :             ( TRANSFER_SIZE(pRequest) % MIN_MMC_BLOCK_SIZE == 0 ) &&
; 1034 :             ( TRANSFER_SIZE(pRequest) <= m_dwDMABufferSize ) )

  001c0	e595203c	 ldr         r2, [r5, #0x3C]
  001c4	e3c77010	 bic         r7, r7, #0x10
  001c8	e3520001	 cmp         r2, #1
  001cc	9a000002	 bls         |$LN2@SendComman|
  001d0	e595300c	 ldr         r3, [r5, #0xC]
  001d4	e3130102	 tst         r3, #2, 2
  001d8	0a000004	 beq         |$LN3@SendComman|
  001dc		 |$LN2@SendComman|
  001dc	e3520000	 cmp         r2, #0
  001e0	0a00001b	 beq         |$LN4@SendComman|
  001e4	e595300c	 ldr         r3, [r5, #0xC]
  001e8	e3130102	 tst         r3, #2, 2
  001ec	0a000018	 beq         |$LN4@SendComman|
  001f0		 |$LN3@SendComman|
  001f0	e5953040	 ldr         r3, [r5, #0x40]
  001f4	e0010392	 mul         r1, r2, r3
  001f8	e3110003	 tst         r1, #3
  001fc	1a000014	 bne         |$LN4@SendComman|
  00200	e59431fc	 ldr         r3, [r4, #0x1FC]
  00204	e1510003	 cmp         r1, r3
  00208	8a000011	 bhi         |$LN4@SendComman|

; 1035 :         {
; 1036 :             MMC_CMD |= MMCHS_CMD_DE;
; 1037 :             m_fDMATransfer = TRUE;
; 1038 :             // program the DMA controller
; 1039 :             EnterCriticalSection( &m_critSec );

  0020c	e28400b0	 add         r0, r4, #0xB0
  00210	e3877001	 orr         r7, r7, #1
  00214	e584a110	 str         r10, [r4, #0x110]
  00218	eb000000	 bl          EnterCriticalSection

; 1040 :             SETREG32(&m_pbRegisters->MMCHS_IE, MMCHS_IE_BWR);

  0021c	e594215c	 ldr         r2, [r4, #0x15C]

; 1041 :             SETREG32(&m_pbRegisters->MMCHS_ISE, MMCHS_ISE_BWR);
; 1042 :             LeaveCriticalSection( &m_critSec );

  00220	e28400b0	 add         r0, r4, #0xB0
  00224	e5923134	 ldr         r3, [r2, #0x134]
  00228	e3833010	 orr         r3, r3, #0x10
  0022c	e5823134	 str         r3, [r2, #0x134]
  00230	e594215c	 ldr         r2, [r4, #0x15C]
  00234	e5923138	 ldr         r3, [r2, #0x138]
  00238	e3833010	 orr         r3, r3, #0x10
  0023c	e5823138	 str         r3, [r2, #0x138]
  00240	eb000000	 bl          LeaveCriticalSection

; 1043 :             SDIO_InitOutputDMA( pRequest->NumBlocks,  pRequest->BlockSize );

  00244	e5952040	 ldr         r2, [r5, #0x40]
  00248	e595103c	 ldr         r1, [r5, #0x3C]
  0024c	e1a00004	 mov         r0, r4
  00250	eb000000	 bl          |?SDIO_InitOutputDMA@CSDIOControllerBase@@QAAXKK@Z|
  00254		 |$LN4@SendComman|

; 1044 :         }
; 1045 : #endif
; 1046 :         dwRegVal = (DWORD)(pRequest->BlockSize & 0xFFFF);

  00254	e5950040	 ldr         r0, [r5, #0x40]
  00258	e3a03cff	 mov         r3, #0xFF, 24

; 1047 :         dwRegVal += ((DWORD)(pRequest->NumBlocks & 0xFFFF)) << 16;

  0025c	e595203c	 ldr         r2, [r5, #0x3C]
  00260	e38330ff	 orr         r3, r3, #0xFF

; 1048 :         OUTREG32(&m_pbRegisters->MMCHS_BLK, dwRegVal);

  00264	e594115c	 ldr         r1, [r4, #0x15C]
  00268	e0003003	 and         r3, r0, r3
  0026c	e0833802	 add         r3, r3, r2, lsl #16
  00270	e5813104	 str         r3, [r1, #0x104]
  00274		 |$LN5@SendComman|

; 1049 :     }
; 1050 :     //check for card initialization is done.
; 1051 :     if(!m_fCardInitialized && (Cmd == SD_CMD_READ_SINGLE_BLOCK))

  00274	e594313c	 ldr         r3, [r4, #0x13C]

; 1052 :         m_fCardInitialized = TRUE;
; 1053 : 
; 1054 :     // Program the argument into the argument registers
; 1055 :     OUTREG32(&m_pbRegisters->MMCHS_ARG, Arg);
; 1056 : 
; 1057 :     DEBUGMSG(SHC_SEND_ZONE, (TEXT("SendCommand() - registers:Command = 0x%x, MMCHS_ARG = 0x%x%x\r\n"), MMC_CMD, INREG32(&m_pbRegisters->MMCHS_ARG)));
; 1058 : 
; 1059 :     // Issue the command.
; 1060 :     OUTREG32(&m_pbRegisters->MMCHS_CMD, MMC_CMD);
; 1061 : 
; 1062 :     return SD_API_STATUS_SUCCESS;

  00278	e3a00000	 mov         r0, #0
  0027c	e3530000	 cmp         r3, #0
  00280	e594315c	 ldr         r3, [r4, #0x15C]
  00284	03560011	 cmpeq       r6, #0x11
  00288	0584a13c	 streq       r10, [r4, #0x13C]
  0028c	e5838108	 str         r8, [r3, #0x108]
  00290	e594315c	 ldr         r3, [r4, #0x15C]
  00294	e583710c	 str         r7, [r3, #0x10C]

; 1063 : }

  00298	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  0029c	e12fff1e	 bx          lr
  002a0		 |$LN45@SendComman|
  002a0		 |$LN46@SendComman|
  002a0	00000000	 DCD         |?gwaCMD@@3PAUCMD@@A|
  002a4		 |$M45037|

			 ENDP  ; |?SendCommand@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z|, CSDIOControllerBase::SendCommand

	EXPORT	|?CardInterrupt@CSDIOControllerBase@@QAAXH@Z| ; CSDIOControllerBase::CardInterrupt
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T45056| DCD	|$LN9@CardInterr|
	DCD	0x40001201
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\sdhc\base\sdhc.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CardInterrupt@CSDIOControllerBase@@QAAXH@Z| PROC ; CSDIOControllerBase::CardInterrupt

; 1070 : {

  00000		 |$LN9@CardInterr|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45053|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 1071 :     DEBUGMSG(SDCARD_ZONE_INIT, (TEXT("CardInterrupt(%d)\r\n"), bInsert));
; 1072 : 
; 1073 :     EnterCriticalSection( &m_critSec );

  0000c	e28500b0	 add         r0, r5, #0xB0
  00010	eb000000	 bl          EnterCriticalSection

; 1074 :     m_CardDetectInterruptStatus |= (bInsert ? EXT_MMCHS_STAT_CD_INSERT_INTR : EXT_MMCHS_STAT_CD_REMOVE_INTR);

  00014	e59531f4	 ldr         r3, [r5, #0x1F4]
  00018	e3540000	 cmp         r4, #0
  0001c	13a02102	 movne       r2, #2, 2
  00020	03a02101	 moveq       r2, #1, 2

; 1075 :     LeaveCriticalSection( &m_critSec );

  00024	e1833002	 orr         r3, r3, r2
  00028	e28500b0	 add         r0, r5, #0xB0
  0002c	e58531f4	 str         r3, [r5, #0x1F4]
  00030	eb000000	 bl          LeaveCriticalSection

; 1076 : 
; 1077 :     SetEvent(m_hControllerISTEvent);

  00034	e5950118	 ldr         r0, [r5, #0x118]
  00038	e3a01003	 mov         r1, #3
  0003c	eb000000	 bl          EventModify

; 1078 : }

  00040	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$M45054|

			 ENDP  ; |?CardInterrupt@CSDIOControllerBase@@QAAXH@Z|, CSDIOControllerBase::CardInterrupt

	EXPORT	|?HandleInsertion@CSDIOControllerBase@@QAAXXZ| ; CSDIOControllerBase::HandleInsertion

  00000			 AREA	 |.pdata|, PDATA
|$T45070| DCD	|$LN13@HandleInse|
	DCD	0x40003c02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HandleInsertion@CSDIOControllerBase@@QAAXXZ| PROC ; CSDIOControllerBase::HandleInsertion

; 1197 : {

  00000		 |$LN13@HandleInse|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M45067|
  00008	e1a04000	 mov         r4, r0

; 1198 :     DWORD dwClockRate = SD_DEFAULT_CARD_ID_CLOCK_RATE;
; 1199 : 
; 1200 :     DEBUGMSG(SDCARD_ZONE_INIT, (TEXT("HandleInsertion\r\n")));
; 1201 : 
; 1202 :     m_fCardPresent = TRUE;
; 1203 :     m_dwSDIOCard = 0;
; 1204 : 
; 1205 :     // turn power to the card on
; 1206 :     TurnCardPowerOn();

  0000c	e5943000	 ldr         r3, [r4]
  00010	e3a02b61	 mov         r2, #0x61, 22
  00014	e3822e2a	 orr         r2, r2, #0x2A, 28
  00018	e5933014	 ldr         r3, [r3, #0x14]
  0001c	e3a01001	 mov         r1, #1
  00020	e3a05000	 mov         r5, #0
  00024	e58d2000	 str         r2, [sp]
  00028	e58410f0	 str         r1, [r4, #0xF0]
  0002c	e5845178	 str         r5, [r4, #0x178]
  00030	e1a0e00f	 mov         lr, pc
  00034	e12fff13	 bx          r3

; 1207 : 
; 1208 :     SoftwareReset(SOFT_RESET_ALL);

  00038	e3a01401	 mov         r1, #1, 8
  0003c	e1a00004	 mov         r0, r4
  00040	eb000000	 bl          |?SoftwareReset@CSDIOControllerBase@@QAAXK@Z|

; 1209 : 
; 1210 :     // Check for debounce stable
; 1211 :     DWORD dwTimeout = 5000;
; 1212 :     while(((INREG32(&m_pbRegisters->MMCHS_PSTATE) & 0x00020000)!= 0x00020000) && (dwTimeout>0))

  00044	e594115c	 ldr         r1, [r4, #0x15C]
  00048	e3a03c13	 mov         r3, #0x13, 24
  0004c	e3832088	 orr         r2, r3, #0x88
  00050	e5913124	 ldr         r3, [r1, #0x124]
  00054	ea000004	 b           |$LN10@HandleInse|
  00058		 |$LL3@HandleInse|
  00058	e3520000	 cmp         r2, #0
  0005c	0a000005	 beq         |$LN8@HandleInse|
  00060	e594315c	 ldr         r3, [r4, #0x15C]

; 1213 :     {
; 1214 :         dwTimeout--;

  00064	e2422001	 sub         r2, r2, #1
  00068	e5933124	 ldr         r3, [r3, #0x124]
  0006c		 |$LN10@HandleInse|
  0006c	e2033802	 and         r3, r3, #2, 16
  00070	e3530802	 cmp         r3, #2, 16
  00074	1afffff7	 bne         |$LL3@HandleInse|
  00078		 |$LN8@HandleInse|

; 1215 :     }
; 1216 : 
; 1217 :     OUTREG32(&m_pbRegisters->MMCHS_CON, 0x01 << 7); // CDP

  00078	e3a03080	 mov         r3, #0x80

; 1218 : 
; 1219 :     SetSDVSVoltage();

  0007c	e1a00004	 mov         r0, r4
  00080	e581302c	 str         r3, [r1, #0x2C]
  00084	eb000000	 bl          |?SetSDVSVoltage@CSDIOControllerBase@@QAAXXZ|

; 1220 : 
; 1221 :     SetClockRate(&dwClockRate);

  00088	e28d1000	 add         r1, sp, #0
  0008c	e1a00004	 mov         r0, r4
  00090	eb000000	 bl          |?SetClockRate@CSDIOControllerBase@@QAAXPAK@Z|

; 1222 :     if (m_LowVoltageSlot && m_dwSlot == MMCSLOT_1 && m_dwCPURev == CPU_FAMILY_35XX_REVISION_ES_2_1)

  00094	e594318c	 ldr         r3, [r4, #0x18C]
  00098	e3530000	 cmp         r3, #0
  0009c	0a000005	 beq         |$LN1@HandleInse|
  000a0	e5943170	 ldr         r3, [r4, #0x170]
  000a4	e3530001	 cmp         r3, #1
  000a8	0594317c	 ldreq       r3, [r4, #0x17C]
  000ac	03530002	 cmpeq       r3, #2

; 1223 :     {
; 1224 :         SendInitSequence();

  000b0	01a00004	 moveq       r0, r4
  000b4	0b000000	 bleq        |?SendInitSequence@CSDIOControllerBase@@QAAXXZ|
  000b8		 |$LN1@HandleInse|

; 1225 :     }
; 1226 :     EnableSDHCInterrupts();

  000b8	e1a00004	 mov         r0, r4
  000bc	eb000000	 bl          |?EnableSDHCInterrupts@CSDIOControllerBase@@QAAXXZ|

; 1227 : 
; 1228 :     // indicate device arrival
; 1229 :     IndicateSlotStateChange(DeviceInserted);

  000c0	e59400a8	 ldr         r0, [r4, #0xA8]
  000c4	e3a02002	 mov         r2, #2
  000c8	e3a01000	 mov         r1, #0
  000cc	eb000000	 bl          SDHCDIndicateSlotStateChange

; 1230 : 
; 1231 :     TurnCardPowerOff();

  000d0	e5943000	 ldr         r3, [r4]
  000d4	e1a00004	 mov         r0, r4
  000d8	e5933018	 ldr         r3, [r3, #0x18]
  000dc	e1a0e00f	 mov         lr, pc
  000e0	e12fff13	 bx          r3

; 1232 : }

  000e4	e28dd004	 add         sp, sp, #4
  000e8	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000ec	e12fff1e	 bx          lr
  000f0		 |$M45068|

			 ENDP  ; |?HandleInsertion@CSDIOControllerBase@@QAAXXZ|, CSDIOControllerBase::HandleInsertion

	EXPORT	|??1CSDIOControllerBase@@QAA@XZ|	; CSDIOControllerBase::~CSDIOControllerBase
	IMPORT	|DeleteCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T45078| DCD	|$LN5@CSDIOContr@2|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CSDIOControllerBase@@QAA@XZ| PROC	; CSDIOControllerBase::~CSDIOControllerBase

; 1236 : {

  00000		 |$LN5@CSDIOContr@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M45075|
  00004	e1a04000	 mov         r4, r0
  00008	e59f3014	 ldr         r3, [pc, #0x14]

; 1237 :     DeleteCriticalSection( &m_critSec );

  0000c	e48030b0	 str         r3, [r0], #0xB0
  00010	eb000000	 bl          DeleteCriticalSection

; 1238 :     DeleteCriticalSection( &m_powerCS );

  00014	e28400c4	 add         r0, r4, #0xC4
  00018	eb000000	 bl          DeleteCriticalSection

; 1239 : }

  0001c	e8bd4010	 ldmia       sp!, {r4, lr}
  00020	e12fff1e	 bx          lr
  00024		 |$LN6@CSDIOContr@2|
  00024		 |$LN7@CSDIOContr@2|
  00024	00000000	 DCD         |??_7CSDIOControllerBase@@6B@|
  00028		 |$M45076|

			 ENDP  ; |??1CSDIOControllerBase@@QAA@XZ|, CSDIOControllerBase::~CSDIOControllerBase

	EXPORT	|?FreeHostContext@CSDIOControllerBase@@QAAXHH@Z| ; CSDIOControllerBase::FreeHostContext
	IMPORT	|SDHCDDeleteContext|
	IMPORT	|GPIOClose|
	IMPORT	|CloseBusAccessHandle|
	IMPORT	|MmUnmapIoSpace|
	IMPORT	|SDHCDDeregisterHostController|

  00000			 AREA	 |.pdata|, PDATA
|$T45089| DCD	|$LN9@FreeHostCo|
	DCD	0x40002501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FreeHostContext@CSDIOControllerBase@@QAAXHH@Z| PROC ; CSDIOControllerBase::FreeHostContext

; 1391 : {

  00000		 |$LN9@FreeHostCo|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45086|
  00004	e3510000	 cmp         r1, #0
  00008	e1a04000	 mov         r4, r0

; 1392 :     UNREFERENCED_PARAMETER(fHardwareInitialized);
; 1393 :     DEBUGCHK(m_pHCContext);
; 1394 : 
; 1395 :     if (fRegisteredWithBusDriver)
; 1396 :     {
; 1397 :         // deregister the host controller
; 1398 :         SDHCDDeregisterHostController(m_pHCContext);

  0000c	159400a8	 ldrne       r0, [r4, #0xA8]
  00010	1b000000	 blne        SDHCDDeregisterHostController

; 1399 :     }
; 1400 : 
; 1401 :     // unmap hardware memory space
; 1402 : 
; 1403 :     DeinitializeHardware();

  00014	e5943000	 ldr         r3, [r4]
  00018	e1a00004	 mov         r0, r4
  0001c	e5933004	 ldr         r3, [r3, #4]
  00020	e1a0e00f	 mov         lr, pc
  00024	e12fff13	 bx          r3

; 1404 :     if (m_pbRegisters)  

  00028	e594315c	 ldr         r3, [r4, #0x15C]
  0002c	e3530000	 cmp         r3, #0

; 1405 : 	    MmUnmapIoSpace((PVOID)m_pbRegisters, sizeof(OMAP_MMCHS_REGS));

  00030	13a01c02	 movne       r1, #2, 24
  00034	11a00003	 movne       r0, r3
  00038	1b000000	 blne        MmUnmapIoSpace

; 1406 : 
; 1407 :     if( m_hParentBus != NULL )

  0003c	e59430ac	 ldr         r3, [r4, #0xAC]
  00040	e3a05000	 mov         r5, #0
  00044	e3530000	 cmp         r3, #0
  00048	0a000007	 beq         |$LN2@FreeHostCo|

; 1408 :     {
; 1409 :         TurnCardPowerOff();

  0004c	e5943000	 ldr         r3, [r4]
  00050	e1a00004	 mov         r0, r4
  00054	e5933018	 ldr         r3, [r3, #0x18]
  00058	e1a0e00f	 mov         lr, pc
  0005c	e12fff13	 bx          r3

; 1410 :         CloseBusAccessHandle( m_hParentBus );

  00060	e59400ac	 ldr         r0, [r4, #0xAC]
  00064	eb000000	 bl          CloseBusAccessHandle

; 1411 :         m_hParentBus = NULL;

  00068	e58450ac	 str         r5, [r4, #0xAC]
  0006c		 |$LN2@FreeHostCo|

; 1412 :     }
; 1413 : 
; 1414 :     if( m_hGPIO != NULL )

  0006c	e5943164	 ldr         r3, [r4, #0x164]
  00070	e3530000	 cmp         r3, #0
  00074	0a000002	 beq         |$LN1@FreeHostCo|

; 1415 :     {
; 1416 :         GPIOClose( m_hGPIO );

  00078	e1a00003	 mov         r0, r3
  0007c	eb000000	 bl          GPIOClose

; 1417 :         m_hGPIO = NULL;

  00080	e5845164	 str         r5, [r4, #0x164]
  00084		 |$LN1@FreeHostCo|

; 1418 :     }
; 1419 : 
; 1420 :     // cleanup the host context
; 1421 :     SDHCDDeleteContext(m_pHCContext);

  00084	e59400a8	 ldr         r0, [r4, #0xA8]
  00088	eb000000	 bl          SDHCDDeleteContext

; 1422 : }

  0008c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$M45087|

			 ENDP  ; |?FreeHostContext@CSDIOControllerBase@@QAAXHH@Z|, CSDIOControllerBase::FreeHostContext

	EXPORT	|?CheckIntrStatus@CSDIOControllerBase@@QAAJKPAK@Z| ; CSDIOControllerBase::CheckIntrStatus

  00000			 AREA	 |.pdata|, PDATA
|$T45106| DCD	|$LN13@CheckIntrS|
	DCD	0x40001e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CheckIntrStatus@CSDIOControllerBase@@QAAJKPAK@Z| PROC ; CSDIOControllerBase::CheckIntrStatus

; 1631 : {

  00000		 |$LN13@CheckIntrS|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M45103|
  00004	e1a06002	 mov         r6, r2
  00008	e1a07000	 mov         r7, r0

; 1632 :     SD_API_STATUS status        = SD_API_STATUS_PENDING;  
; 1633 :     DWORD         dwOverwrite   = 0;
; 1634 : 
; 1635 :     if( dwIntrStatus & MMCHS_STAT_CCRC ) // command CRC error

  0000c	e3110802	 tst         r1, #2, 16
  00010	e3a05001	 mov         r5, #1
  00014	e3a04000	 mov         r4, #0

; 1636 :         {
; 1637 :         status = SD_API_STATUS_CRC_ERROR;

  00018	13a05137	 movne       r5, #0x37, 2

; 1638 :         dwOverwrite |= MMCHS_STAT_CCRC;

  0001c	13a04802	 movne       r4, #2, 16

; 1639 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDHControllerIstThread() - Got command CRC error!\r\n")));
; 1640 :         }
; 1641 :     if( dwIntrStatus & MMCHS_STAT_CTO ) // command response timeout

  00020	e3110801	 tst         r1, #1, 16

; 1642 :     {
; 1643 :         status = SD_API_STATUS_RESPONSE_TIMEOUT;

  00024	13a05153	 movne       r5, #0x53, 2

; 1644 :         dwOverwrite |= MMCHS_STAT_CTO;

  00028	13844801	 orrne       r4, r4, #1, 16

; 1645 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDHControllerIstThread() - Got command response timeout!\r\n")));
; 1646 :         }
; 1647 :     if( dwIntrStatus & MMCHS_STAT_DTO ) // data timeout

  0002c	e3110601	 tst         r1, #1, 12

; 1648 :         {
; 1649 :         status = SD_API_STATUS_RESPONSE_TIMEOUT;

  00030	13a05153	 movne       r5, #0x53, 2

; 1650 :         dwOverwrite |= MMCHS_STAT_DTO;

  00034	13844601	 orrne       r4, r4, #1, 12

; 1651 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDHControllerIstThread() - Got command response timeout!\r\n")));
; 1652 :         }
; 1653 :     if( dwIntrStatus & MMCHS_STAT_DCRC ) // data CRC error

  00038	e3110602	 tst         r1, #2, 12

; 1654 :         {
; 1655 :         status = SD_API_STATUS_RESPONSE_TIMEOUT;
; 1656 :         dwOverwrite |= MMCHS_STAT_DCRC;

  0003c	13844602	 orrne       r4, r4, #2, 12
  00040	13a05153	 movne       r5, #0x53, 2

; 1657 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDHControllerIstThread() - Got command response timeout!\r\n")));
; 1658 :         }
; 1659 :     if( dwOverwrite ) // clear the status error bits

  00044	e3540000	 cmp         r4, #0
  00048	0a000005	 beq         |$LN9@CheckIntrS|

; 1660 :         {
; 1661 :         Write_MMC_STAT(dwOverwrite);

  0004c	e28700b0	 add         r0, r7, #0xB0
  00050	eb000000	 bl          EnterCriticalSection
  00054	e597315c	 ldr         r3, [r7, #0x15C]
  00058	e28700b0	 add         r0, r7, #0xB0
  0005c	e5834130	 str         r4, [r3, #0x130]
  00060	eb000000	 bl          LeaveCriticalSection
  00064		 |$LN9@CheckIntrS|

; 1662 :         }
; 1663 : 
; 1664 :     if (pOverwrite != NULL)

  00064	e3560000	 cmp         r6, #0

; 1665 :         {
; 1666 :         *pOverwrite = dwOverwrite;

  00068	15864000	 strne       r4, [r6]

; 1667 :         }
; 1668 : 
; 1669 :     return status;
; 1670 : }

  0006c	e1a00005	 mov         r0, r5
  00070	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00074	e12fff1e	 bx          lr
  00078		 |$M45104|

			 ENDP  ; |?CheckIntrStatus@CSDIOControllerBase@@QAAJKPAK@Z|, CSDIOControllerBase::CheckIntrStatus

	EXPORT	|?ProcessCommandTransferStatus@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@JK@Z| ; CSDIOControllerBase::ProcessCommandTransferStatus
	IMPORT	|SDHCDIndicateBusRequestComplete|

  00000			 AREA	 |.pdata|, PDATA
|$T45126| DCD	|$LN17@ProcessCom|
	DCD	0x40002a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ProcessCommandTransferStatus@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@JK@Z| PROC ; CSDIOControllerBase::ProcessCommandTransferStatus

; 1943 : {

  00000		 |$LN17@ProcessCom|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45123|
  00004	e1b06002	 movs        r6, r2
  00008	e1a05000	 mov         r5, r0

; 1944 :     UNREFERENCED_PARAMETER(dwStatusOverwrite);
; 1945 : 
; 1946 :     if( status == SD_API_STATUS_SUCCESS )

  0000c	1a00000d	 bne         |$LN4@ProcessCom|

; 1947 :         {
; 1948 :         if( m_fAppCmdMode )

  00010	e5953114	 ldr         r3, [r5, #0x114]
  00014	e3a02001	 mov         r2, #1
  00018	e3530000	 cmp         r3, #0

; 1949 :             {
; 1950 :             m_fAppCmdMode = FALSE;

  0001c	13a03000	 movne       r3, #0
  00020	15853114	 strne       r3, [r5, #0x114]
  00024	1a000004	 bne         |$LN5@ProcessCom|

; 1951 :             DEBUGMSG(SHC_SEND_ZONE, (TEXT("CSDIOControllerBase::ProcessCommandTransferStatus - Switched to Standard Command Mode\r\n")));
; 1952 :             }
; 1953 :         else if( pRequest && pRequest->CommandCode == 55 )

  00028	e3510000	 cmp         r1, #0
  0002c	0a000002	 beq         |$LN5@ProcessCom|
  00030	e5d13014	 ldrb        r3, [r1, #0x14]
  00034	e3530037	 cmp         r3, #0x37

; 1954 :             {
; 1955 :             m_fAppCmdMode = TRUE;

  00038	05852114	 streq       r2, [r5, #0x114]
  0003c		 |$LN5@ProcessCom|

; 1956 :             DEBUGMSG(SHC_SEND_ZONE, (TEXT("CSDIOControllerBase::ProcessCommandTransferStatus - Switched to Application Specific Command Mode\r\n")));
; 1957 :             }
; 1958 : 
; 1959 :         if( pRequest->CommandCode == SD_CMD_MMC_SEND_OPCOND )

  0003c	e5d13014	 ldrb        r3, [r1, #0x14]
  00040	e3530001	 cmp         r3, #1

; 1960 :             {
; 1961 :             DEBUGMSG(SHC_SDBUS_INTERACT_ZONE, (TEXT("CSDIOControllerBase::ProcessCommandTransferStatus Card is recognized as a MMC\r\n") ) );
; 1962 :             m_fMMCMode = TRUE;

  00044	058520f8	 streq       r2, [r5, #0xF8]
  00048		 |$LN4@ProcessCom|

; 1963 :             }
; 1964 :         }
; 1965 : 
; 1966 :     if(m_ActualPowerState == D4)

  00048	e59530e0	 ldr         r3, [r5, #0xE0]
  0004c	e3530004	 cmp         r3, #4
  00050	1a000005	 bne         |$LN3@ProcessCom|

; 1967 :         {
; 1968 :         if( pRequest != NULL )

  00054	e3510000	 cmp         r1, #0

; 1969 :             SDHCDIndicateBusRequestComplete(m_pHCContext, pRequest, status);

  00058	159500a8	 ldrne       r0, [r5, #0xA8]
  0005c	11a02006	 movne       r2, r6
  00060	1b000000	 blne        SDHCDIndicateBusRequestComplete

; 1970 :         return TRUE;

  00064	e3a06001	 mov         r6, #1
  00068	ea00000b	 b           |$LN9@ProcessCom|
  0006c		 |$LN3@ProcessCom|

; 1971 :         }
; 1972 : 
; 1973 : 
; 1974 :     // Clear the MMC_STAT register
; 1975 :     DWORD MMC_STAT = Read_MMC_STAT();

  0006c	e28500b0	 add         r0, r5, #0xB0
  00070	eb000000	 bl          EnterCriticalSection
  00074	e595315c	 ldr         r3, [r5, #0x15C]
  00078	e28500b0	 add         r0, r5, #0xB0
  0007c	e5934130	 ldr         r4, [r3, #0x130]
  00080	eb000000	 bl          LeaveCriticalSection

; 1976 :     Write_MMC_STAT(MMC_STAT);

  00084	e28500b0	 add         r0, r5, #0xB0
  00088	eb000000	 bl          EnterCriticalSection
  0008c	e595315c	 ldr         r3, [r5, #0x15C]
  00090	e28500b0	 add         r0, r5, #0xB0
  00094	e5834130	 str         r4, [r3, #0x130]
  00098	eb000000	 bl          LeaveCriticalSection

; 1977 : 
; 1978 :     if (MMC_STAT)
; 1979 :         {
; 1980 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("+CSDIOControllerBase::ProcessCommandTransferStatus: status = %x\r\n"), MMC_STAT));
; 1981 :         }
; 1982 : 
; 1983 :     return status;

  0009c		 |$LN9@ProcessCom|

; 1984 : }

  0009c	e1a00006	 mov         r0, r6
  000a0	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000a4	e12fff1e	 bx          lr
  000a8		 |$M45124|

			 ENDP  ; |?ProcessCommandTransferStatus@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@JK@Z|, CSDIOControllerBase::ProcessCommandTransferStatus

	EXPORT	|?StartDMAReceive@CSDIOControllerBase@@QAAHPAEK@Z| ; CSDIOControllerBase::StartDMAReceive
	IMPORT	|CacheRangeFlush|
	IMPORT	|?SDIO_StartInputDMA@CSDIOControllerBase@@QAAXXZ| ; CSDIOControllerBase::SDIO_StartInputDMA

  00000			 AREA	 |.pdata|, PDATA
|$T45147| DCD	|$LN12@StartDMARe|
	DCD	0x40002801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?StartDMAReceive@CSDIOControllerBase@@QAAHPAEK@Z| PROC ; CSDIOControllerBase::StartDMAReceive

; 1997 : {

  00000		 |$LN12@StartDMARe|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M45144|
  00004	e1a07002	 mov         r7, r2
  00008	e1a08001	 mov         r8, r1
  0000c	e1a05000	 mov         r5, r0

; 1998 :     BOOL    bRet = TRUE;
; 1999 : 
; 2000 :     DWORD MMC_STAT = Read_MMC_STAT();

  00010	e28500b0	 add         r0, r5, #0xB0
  00014	e3a06001	 mov         r6, #1
  00018	eb000000	 bl          EnterCriticalSection
  0001c	e595315c	 ldr         r3, [r5, #0x15C]
  00020	e28500b0	 add         r0, r5, #0xB0
  00024	e5934130	 ldr         r4, [r3, #0x130]
  00028	eb000000	 bl          LeaveCriticalSection

; 2001 : 
; 2002 :     Write_MMC_STAT(MMC_STAT);

  0002c	e28500b0	 add         r0, r5, #0xB0
  00030	eb000000	 bl          EnterCriticalSection
  00034	e595315c	 ldr         r3, [r5, #0x15C]
  00038	e28500b0	 add         r0, r5, #0xB0
  0003c	e5834130	 str         r4, [r3, #0x130]
  00040	eb000000	 bl          LeaveCriticalSection

; 2003 : 
; 2004 :     if( MMC_STAT & (MMCHS_STAT_DTO | MMCHS_STAT_DCRC))

  00044	e3140603	 tst         r4, #3, 12

; 2005 :         {
; 2006 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDIDMAReceive() - exit: STAT register indicates MMC_STAT_DTO or MMC_STAT_DCRC error (%x).\r\n"), MMC_STAT));
; 2007 :         bRet = FALSE;

  00048	13a06000	 movne       r6, #0
  0004c	1a000010	 bne         |$LN1@StartDMARe|

; 2008 :         }
; 2009 :     else
; 2010 :         {
; 2011 :         EnterCriticalSection( &m_critSec );

  00050	e28500b0	 add         r0, r5, #0xB0
  00054	eb000000	 bl          EnterCriticalSection

; 2012 :         OUTREG32(&m_pbRegisters->MMCHS_STAT, 0xFFFFFFFF);

  00058	e595315c	 ldr         r3, [r5, #0x15C]
  0005c	e3e02000	 mvn         r2, #0

; 2013 :         LeaveCriticalSection( &m_critSec );

  00060	e28500b0	 add         r0, r5, #0xB0
  00064	e5832130	 str         r2, [r3, #0x130]
  00068	eb000000	 bl          LeaveCriticalSection

; 2014 : 
; 2015 :         m_pCurrentRecieveBuffer = pBuff;
; 2016 :         m_dwCurrentRecieveBufferLength = dwLen;
; 2017 : 
; 2018 :         // start the DMA
; 2019 :         SDIO_StartInputDMA();

  0006c	e1a00005	 mov         r0, r5
  00070	e58581ec	 str         r8, [r5, #0x1EC]
  00074	e58571f0	 str         r7, [r5, #0x1F0]
  00078	eb000000	 bl          |?SDIO_StartInputDMA@CSDIOControllerBase@@QAAXXZ|

; 2020 : 
; 2021 :         if (m_pCachedDmaBuffer != NULL)

  0007c	e5953100	 ldr         r3, [r5, #0x100]
  00080	e3530000	 cmp         r3, #0

; 2022 :             {
; 2023 :             CacheRangeFlush(m_pCachedDmaBuffer, m_dwCurrentRecieveBufferLength, TI_CACHE_SYNC_INVALIDATE);

  00084	159511f0	 ldrne       r1, [r5, #0x1F0]
  00088	13a02102	 movne       r2, #2, 2
  0008c	11a00003	 movne       r0, r3
  00090	1b000000	 blne        CacheRangeFlush
  00094		 |$LN1@StartDMARe|

; 2024 :             }
; 2025 :         }
; 2026 : 
; 2027 :     return bRet;
; 2028 : }

  00094	e1a00006	 mov         r0, r6
  00098	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$M45145|

			 ENDP  ; |?StartDMAReceive@CSDIOControllerBase@@QAAHPAEK@Z|, CSDIOControllerBase::StartDMAReceive

	EXPORT	|?StartDMATransmit@CSDIOControllerBase@@QAAHPAEK@Z| ; CSDIOControllerBase::StartDMATransmit
	IMPORT	|?SDIO_StartOutputDMA@CSDIOControllerBase@@QAAXXZ| ; CSDIOControllerBase::SDIO_StartOutputDMA
	IMPORT	|SDPerformSafeCopy|

  00000			 AREA	 |.pdata|, PDATA
|$T45168| DCD	|$LN13@StartDMATr|
	DCD	0x40002901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?StartDMATransmit@CSDIOControllerBase@@QAAHPAEK@Z| PROC ; CSDIOControllerBase::StartDMATransmit

; 2040 : {

  00000		 |$LN13@StartDMATr|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45165|
  00004	e1a05000	 mov         r5, r0

; 2041 :     BOOL    bRet;
; 2042 : 
; 2043 :     // first copy the data to the DMA buffer, then to the user buffer, which maybe SG buffer,
; 2044 : #if 1
; 2045 :     // We use uncached DMA buffer instead of cached DMA for write operation because it give
; 2046 :     // better performance. 
; 2047 :     bRet = SDPerformSafeCopy( m_pDmaBuffer, pBuff, dwLen );

  00008	e59500fc	 ldr         r0, [r5, #0xFC]
  0000c	eb000000	 bl          SDPerformSafeCopy
  00010	e1b06000	 movs        r6, r0

; 2048 : #else
; 2049 :     if (m_pCachedDmaBuffer == NULL)
; 2050 :         {
; 2051 :         bRet = SDPerformSafeCopy( m_pDmaBuffer, pBuff, dwLen );
; 2052 :         }
; 2053 :     else
; 2054 :         {
; 2055 :         bRet = SDPerformSafeCopy( m_pCachedDmaBuffer, pBuff, dwLen );
; 2056 :         CacheRangeFlush(m_pCachedDmaBuffer, dwLen, CACHE_SYNC_WRITEBACK);
; 2057 :         }
; 2058 : #endif
; 2059 : 
; 2060 :     if( bRet == FALSE)

  00014	0a00001f	 beq         |$cleanUp$42951|

; 2061 :         {
; 2062 :         goto cleanUp;
; 2063 :         }
; 2064 : 
; 2065 :     DWORD MMC_STAT = Read_MMC_STAT();

  00018	e28500b0	 add         r0, r5, #0xB0
  0001c	eb000000	 bl          EnterCriticalSection
  00020	e595315c	 ldr         r3, [r5, #0x15C]
  00024	e28500b0	 add         r0, r5, #0xB0
  00028	e5934130	 ldr         r4, [r3, #0x130]
  0002c	eb000000	 bl          LeaveCriticalSection

; 2066 : 
; 2067 :     Write_MMC_STAT(MMC_STAT);

  00030	e28500b0	 add         r0, r5, #0xB0
  00034	eb000000	 bl          EnterCriticalSection
  00038	e595315c	 ldr         r3, [r5, #0x15C]
  0003c	e28500b0	 add         r0, r5, #0xB0
  00040	e5834130	 str         r4, [r3, #0x130]
  00044	eb000000	 bl          LeaveCriticalSection

; 2068 : 
; 2069 :     if( MMC_STAT & (MMCHS_STAT_DTO | MMCHS_STAT_DCRC))

  00048	e3140603	 tst         r4, #3, 12

; 2070 :         {
; 2071 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDIDMATransmit() - exit: STAT register indicates MMC_STAT_DTO or MMC_STAT_DCRC error(%x).\r\n"), MMC_STAT));
; 2072 :         bRet = FALSE;

  0004c	13a06000	 movne       r6, #0
  00050	1a000010	 bne         |$cleanUp$42951|

; 2073 :         }
; 2074 :     else
; 2075 :         {
; 2076 :         // start the DMA
; 2077 :         EnterCriticalSection( &m_critSec );

  00054	e28500b0	 add         r0, r5, #0xB0
  00058	eb000000	 bl          EnterCriticalSection

; 2078 :         SETREG32(&m_pbRegisters->MMCHS_IE, MMCHS_IE_TC);

  0005c	e595215c	 ldr         r2, [r5, #0x15C]

; 2079 :         SETREG32(&m_pbRegisters->MMCHS_ISE, MMCHS_ISE_TC);
; 2080 :         OUTREG32(&m_pbRegisters->MMCHS_STAT, 0xFFFFFFFF);

  00060	e3e01000	 mvn         r1, #0

; 2081 :         LeaveCriticalSection( &m_critSec );

  00064	e28500b0	 add         r0, r5, #0xB0
  00068	e5923134	 ldr         r3, [r2, #0x134]
  0006c	e3833002	 orr         r3, r3, #2
  00070	e5823134	 str         r3, [r2, #0x134]
  00074	e595215c	 ldr         r2, [r5, #0x15C]
  00078	e5923138	 ldr         r3, [r2, #0x138]
  0007c	e3833002	 orr         r3, r3, #2
  00080	e5823138	 str         r3, [r2, #0x138]
  00084	e595315c	 ldr         r3, [r5, #0x15C]
  00088	e5831130	 str         r1, [r3, #0x130]
  0008c	eb000000	 bl          LeaveCriticalSection

; 2082 : 
; 2083 :         SDIO_StartOutputDMA();

  00090	e1a00005	 mov         r0, r5
  00094	eb000000	 bl          |?SDIO_StartOutputDMA@CSDIOControllerBase@@QAAXXZ|
  00098		 |$cleanUp$42951|

; 2084 :         }
; 2085 : 
; 2086 : cleanUp:
; 2087 : 
; 2088 :     return bRet;
; 2089 : }

  00098	e1a00006	 mov         r0, r6
  0009c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000a0	e12fff1e	 bx          lr
  000a4		 |$M45166|

			 ENDP  ; |?StartDMATransmit@CSDIOControllerBase@@QAAHPAEK@Z|, CSDIOControllerBase::StartDMATransmit

	EXPORT	|?DataReceiveCompletedHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@KPAW4SDHCCONTROLLERIST_STATE@@@Z| ; CSDIOControllerBase::DataReceiveCompletedHandler
	IMPORT	|?SDIO_StopInputDMA@CSDIOControllerBase@@QAAXXZ| ; CSDIOControllerBase::SDIO_StopInputDMA

  00000			 AREA	 |.pdata|, PDATA
|$T45190| DCD	|$LN17@DataReceiv|
	DCD	0x40002e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DataReceiveCompletedHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@KPAW4SDHCCONTROLLERIST_STATE@@@Z| PROC ; CSDIOControllerBase::DataReceiveCompletedHandler

; 2106 : {

  00000		 |$LN17@DataReceiv|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45187|
  00004	e1a06003	 mov         r6, r3
  00008	e1a04000	 mov         r4, r0

; 2107 :     SD_API_STATUS   status      = SD_API_STATUS_SUCCESS;

  0000c	e3a05000	 mov         r5, #0

; 2108 : 
; 2109 :     UNREFERENCED_PARAMETER(pRequest);
; 2110 : 
; 2111 :     static DWORD           dwSize      = 0;
; 2112 : 
; 2113 :     if(dwIntrStatus & (MMCHS_STAT_BRR | MMCHS_STAT_TC))

  00010	e3120022	 tst         r2, #0x22
  00014	0a00001d	 beq         |$LN6@DataReceiv|

; 2114 :         {
; 2115 :         Read_MMC_STAT();

  00018	e28400b0	 add         r0, r4, #0xB0
  0001c	eb000000	 bl          EnterCriticalSection
  00020	e594215c	 ldr         r2, [r4, #0x15C]
  00024	e28400b0	 add         r0, r4, #0xB0
  00028	e5922130	 ldr         r2, [r2, #0x130]
  0002c	eb000000	 bl          LeaveCriticalSection

; 2116 :    
; 2117 :         // stop DMA
; 2118 :         SDIO_StopInputDMA();

  00030	e1a00004	 mov         r0, r4
  00034	eb000000	 bl          |?SDIO_StopInputDMA@CSDIOControllerBase@@QAAXXZ|

; 2119 : 
; 2120 :         Set_MMC_STAT(MMCHS_STAT_TC);

  00038	e28400b0	 add         r0, r4, #0xB0
  0003c	eb000000	 bl          EnterCriticalSection
  00040	e594215c	 ldr         r2, [r4, #0x15C]
  00044	e3a03002	 mov         r3, #2
  00048	e28400b0	 add         r0, r4, #0xB0
  0004c	e5823130	 str         r3, [r2, #0x130]
  00050	eb000000	 bl          LeaveCriticalSection

; 2121 : 
; 2122 :         if ((m_pCurrentRecieveBuffer != NULL) && (m_dwCurrentRecieveBufferLength != 0))

  00054	e59431ec	 ldr         r3, [r4, #0x1EC]
  00058	e1b00003	 movs        r0, r3
  0005c	0a00000f	 beq         |$LN2@DataReceiv|
  00060	e59431f0	 ldr         r3, [r4, #0x1F0]
  00064	e1b02003	 movs        r2, r3
  00068	0a00000c	 beq         |$LN2@DataReceiv|

; 2123 :             {
; 2124 :             // finally, copy the data from DMA buffer to the user buffer, which maybe SG buffer,
; 2125 :             SDPerformSafeCopy(m_pCurrentRecieveBuffer, (m_pCachedDmaBuffer!=NULL) ? m_pCachedDmaBuffer : m_pDmaBuffer, m_dwCurrentRecieveBufferLength);

  0006c	e5943100	 ldr         r3, [r4, #0x100]
  00070	e3530000	 cmp         r3, #0
  00074	059430fc	 ldreq       r3, [r4, #0xFC]
  00078	e1a01003	 mov         r1, r3
  0007c	eb000000	 bl          SDPerformSafeCopy

; 2126 : 
; 2127 :             m_pCurrentRecieveBuffer = NULL;

  00080	e3a03000	 mov         r3, #0
  00084	e58431ec	 str         r3, [r4, #0x1EC]

; 2128 :             m_dwCurrentRecieveBufferLength = 0;

  00088	e58431f0	 str         r3, [r4, #0x1F0]

; 2129 :             }
; 2130 :         }
; 2131 :     else

  0008c	ea000003	 b           |$LN2@DataReceiv|
  00090		 |$LN6@DataReceiv|

; 2132 :         {
; 2133 :         if( dwIntrStatus & MMCHS_STAT_DTO )

  00090	e3120601	 tst         r2, #1, 12

; 2134 :             {
; 2135 :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDIDMAReceive() - exit: STAT register indicates MMC_STAT_DTO error.\r\n")));
; 2136 :             status = SD_API_STATUS_RESPONSE_TIMEOUT;

  00094	13a05153	 movne       r5, #0x53, 2

; 2137 :             }
; 2138 :         if( dwIntrStatus & MMCHS_STAT_DCRC ) // DATA CRC Error

  00098	e3120602	 tst         r2, #2, 12

; 2139 :             {
; 2140 :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDIDMAReceive() - exit: STAT register indicates MMC_STAT_DCRC error.\r\n")));
; 2141 :             status = SD_API_STATUS_RESPONSE_TIMEOUT;

  0009c	13a05153	 movne       r5, #0x53, 2
  000a0		 |$LN2@DataReceiv|

; 2142 :             }
; 2143 :         }
; 2144 : 
; 2145 :     if (pNextState != NULL)

  000a0	e3560000	 cmp         r6, #0

; 2146 :         {
; 2147 :         *pNextState = COMMAND_TRANSFER_STATE;

  000a4	13a03001	 movne       r3, #1
  000a8	15863000	 strne       r3, [r6]

; 2148 :         }
; 2149 : 
; 2150 :     return status;
; 2151 : }

  000ac	e1a00005	 mov         r0, r5
  000b0	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000b4	e12fff1e	 bx          lr
  000b8		 |$M45188|

			 ENDP  ; |?DataReceiveCompletedHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@KPAW4SDHCCONTROLLERIST_STATE@@@Z|, CSDIOControllerBase::DataReceiveCompletedHandler

	EXPORT	|?DataTransmitCompletedHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@KPAW4SDHCCONTROLLERIST_STATE@@@Z| ; CSDIOControllerBase::DataTransmitCompletedHandler
	IMPORT	|?SDIO_StopOutputDMA@CSDIOControllerBase@@QAAXXZ| ; CSDIOControllerBase::SDIO_StopOutputDMA

  00000			 AREA	 |.pdata|, PDATA
|$T45210| DCD	|$LN14@DataTransm|
	DCD	0x40002301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DataTransmitCompletedHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@KPAW4SDHCCONTROLLERIST_STATE@@@Z| PROC ; CSDIOControllerBase::DataTransmitCompletedHandler

; 2167 : {

  00000		 |$LN14@DataTransm|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M45207|
  00004	e1a06003	 mov         r6, r3
  00008	e1a05002	 mov         r5, r2
  0000c	e1a07000	 mov         r7, r0

; 2168 :     SD_API_STATUS   status = SD_API_STATUS_SUCCESS;

  00010	e3a04000	 mov         r4, #0

; 2169 : 
; 2170 :     UNREFERENCED_PARAMETER(pRequest);
; 2171 : 
; 2172 :     if (dwIntrStatus & MMCHS_STAT_TC)

  00014	e3150002	 tst         r5, #2
  00018	0a00000f	 beq         |$LN5@DataTransm|

; 2173 :         {
; 2174 :         Read_MMC_STAT();

  0001c	e28700b0	 add         r0, r7, #0xB0
  00020	eb000000	 bl          EnterCriticalSection
  00024	e597215c	 ldr         r2, [r7, #0x15C]
  00028	e28700b0	 add         r0, r7, #0xB0
  0002c	e5922130	 ldr         r2, [r2, #0x130]
  00030	eb000000	 bl          LeaveCriticalSection

; 2175 : 
; 2176 :         // stop DMA
; 2177 :         SDIO_StopOutputDMA();

  00034	e1a00007	 mov         r0, r7
  00038	eb000000	 bl          |?SDIO_StopOutputDMA@CSDIOControllerBase@@QAAXXZ|

; 2178 : 
; 2179 :         Set_MMC_STAT(MMCHS_STAT_TC);

  0003c	e28700b0	 add         r0, r7, #0xB0
  00040	eb000000	 bl          EnterCriticalSection
  00044	e597215c	 ldr         r2, [r7, #0x15C]
  00048	e3a03002	 mov         r3, #2
  0004c	e28700b0	 add         r0, r7, #0xB0
  00050	e5823130	 str         r3, [r2, #0x130]
  00054	eb000000	 bl          LeaveCriticalSection

; 2180 :         }
; 2181 :     else

  00058	ea000005	 b           |$LN2@DataTransm|
  0005c		 |$LN5@DataTransm|

; 2182 :         {
; 2183 :         // stop DMA
; 2184 :         SDIO_StopOutputDMA();

  0005c	e1a00007	 mov         r0, r7
  00060	eb000000	 bl          |?SDIO_StopOutputDMA@CSDIOControllerBase@@QAAXXZ|

; 2185 : 
; 2186 :         if( dwIntrStatus & MMCHS_STAT_DTO )

  00064	e3150601	 tst         r5, #1, 12

; 2187 :             {
; 2188 :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("DataTransmitCompletedHandler() - exit: STAT register indicates MMC_STAT_DTO error.\r\n")));
; 2189 :             status = SD_API_STATUS_RESPONSE_TIMEOUT;

  00068	13a04153	 movne       r4, #0x53, 2

; 2190 :             }
; 2191 :         if( dwIntrStatus & MMCHS_STAT_DCRC ) // DATA CRC Error

  0006c	e3150602	 tst         r5, #2, 12

; 2192 :             {
; 2193 :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("DataTransmitCompletedHandler() - exit: STAT register indicates MMC_CRC_ERROR_RCVD error.\r\n")));
; 2194 :             status = SD_API_STATUS_RESPONSE_TIMEOUT;

  00070	13a04153	 movne       r4, #0x53, 2
  00074		 |$LN2@DataTransm|

; 2195 :             }
; 2196 :         }
; 2197 : 
; 2198 :     if (pNextState != NULL)

  00074	e3560000	 cmp         r6, #0

; 2199 :         {
; 2200 :         *pNextState = COMMAND_TRANSFER_STATE;

  00078	13a03001	 movne       r3, #1
  0007c	15863000	 strne       r3, [r6]

; 2201 :         }
; 2202 : 
; 2203 :     return status;
; 2204 : }

  00080	e1a00004	 mov         r0, r4
  00084	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$M45208|

			 ENDP  ; |?DataTransmitCompletedHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@KPAW4SDHCCONTROLLERIST_STATE@@@Z|, CSDIOControllerBase::DataTransmitCompletedHandler

	EXPORT	|?SDHCCardDetectIstThread@CSDIOControllerBase@@SAKPAX@Z| ; CSDIOControllerBase::SDHCCardDetectIstThread

  00000			 AREA	 |.pdata|, PDATA
|$T45220| DCD	|$LN5@SDHCCardDe|
	DCD	0x40000701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCCardDetectIstThread@CSDIOControllerBase@@SAKPAX@Z| PROC ; CSDIOControllerBase::SDHCCardDetectIstThread

; 2233 : {

  00000		 |$LN5@SDHCCardDe|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45217|

; 2234 :     CSDIOControllerBase *pController = (CSDIOControllerBase*)lpParameter;
; 2235 :     return pController->SDHCCardDetectIstThreadImpl();

  00004	e5903000	 ldr         r3, [r0]
  00008	e5933010	 ldr         r3, [r3, #0x10]
  0000c	e1a0e00f	 mov         lr, pc
  00010	e12fff13	 bx          r3

; 2236 : }

  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$M45218|

			 ENDP  ; |?SDHCCardDetectIstThread@CSDIOControllerBase@@SAKPAX@Z|, CSDIOControllerBase::SDHCCardDetectIstThread

	EXPORT	|?SDHCCancelIoHandlerImpl@CSDIOControllerBase@@QAAEEPAU_SD_BUS_REQUEST@@@Z| ; CSDIOControllerBase::SDHCCancelIoHandlerImpl

  00000			 AREA	 |.pdata|, PDATA
|$T45229| DCD	|$LN5@SDHCCancel|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCCancelIoHandlerImpl@CSDIOControllerBase@@QAAEEPAU_SD_BUS_REQUEST@@@Z| PROC ; CSDIOControllerBase::SDHCCancelIoHandlerImpl

; 2545 : {

  00000		 |$LN5@SDHCCancel|
  00000		 |$M45226|

; 2546 :     // for now, we should never get here because all requests are non-cancelable
; 2547 :     // the hardware supports timeouts so it is impossible for the controller to get stuck
; 2548 :     DEBUGCHK(FALSE);
; 2549 : 
; 2550 :     UNREFERENCED_PARAMETER(Slot);
; 2551 :     UNREFERENCED_PARAMETER(pRequest);
; 2552 : 
; 2553 :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 2554 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M45227|

			 ENDP  ; |?SDHCCancelIoHandlerImpl@CSDIOControllerBase@@QAAEEPAU_SD_BUS_REQUEST@@@Z|, CSDIOControllerBase::SDHCCancelIoHandlerImpl

	EXPORT	|?SetSlotPowerState@CSDIOControllerBase@@QAAXW4_CEDEVICE_POWER_STATE@@@Z| ; CSDIOControllerBase::SetSlotPowerState

  00000			 AREA	 |.pdata|, PDATA
|$T45236| DCD	|$LN5@SetSlotPow|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetSlotPowerState@CSDIOControllerBase@@QAAXW4_CEDEVICE_POWER_STATE@@@Z| PROC ; CSDIOControllerBase::SetSlotPowerState

; 3039 : {

  00000		 |$LN5@SetSlotPow|
  00000		 |$M45233|

; 3040 :     UNREFERENCED_PARAMETER(state);
; 3041 : }

  00000	e12fff1e	 bx          lr
  00004		 |$M45234|

			 ENDP  ; |?SetSlotPowerState@CSDIOControllerBase@@QAAXW4_CEDEVICE_POWER_STATE@@@Z|, CSDIOControllerBase::SetSlotPowerState

	EXPORT	|?GetSlotPowerState@CSDIOControllerBase@@QAA?AW4_CEDEVICE_POWER_STATE@@XZ| ; CSDIOControllerBase::GetSlotPowerState

  00000			 AREA	 |.pdata|, PDATA
|$T45245| DCD	|$LN5@GetSlotPow|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetSlotPowerState@CSDIOControllerBase@@QAA?AW4_CEDEVICE_POWER_STATE@@XZ| PROC ; CSDIOControllerBase::GetSlotPowerState

; 3045 : {

  00000		 |$LN5@GetSlotPow|
  00000		 |$M45242|

; 3046 :     return D3;

  00000	e3a00003	 mov         r0, #3

; 3047 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M45243|

			 ENDP  ; |?GetSlotPowerState@CSDIOControllerBase@@QAA?AW4_CEDEVICE_POWER_STATE@@XZ|, CSDIOControllerBase::GetSlotPowerState

	EXPORT	|?SDHCCancelIoHandler@CSDIOControllerBase@@SAEPAU_SDCARD_HC_CONTEXT@@KPAU_SD_BUS_REQUEST@@@Z| ; CSDIOControllerBase::SDHCCancelIoHandler

  00000			 AREA	 |.pdata|, PDATA
|$T45257| DCD	|$LN7@SDHCCancel@2|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCCancelIoHandler@CSDIOControllerBase@@SAEPAU_SDCARD_HC_CONTEXT@@KPAU_SD_BUS_REQUEST@@@Z| PROC ; CSDIOControllerBase::SDHCCancelIoHandler

; 3390 : {

  00000		 |$LN7@SDHCCancel@2|
  00000		 |$M45254|

; 3391 :     // get our extension
; 3392 :     CSDIOControllerBase *pController = GET_PCONTROLLER_FROM_HCD(pHCContext);
; 3393 :     return pController->SDHCCancelIoHandlerImpl((UCHAR)Slot, pRequest);

  00000	e3a00001	 mov         r0, #1

; 3394 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M45255|

			 ENDP  ; |?SDHCCancelIoHandler@CSDIOControllerBase@@SAEPAU_SDCARD_HC_CONTEXT@@KPAU_SD_BUS_REQUEST@@@Z|, CSDIOControllerBase::SDHCCancelIoHandler

	EXPORT	|?SetPower@CSDIOControllerBase@@QAAHW4_CEDEVICE_POWER_STATE@@@Z| ; CSDIOControllerBase::SetPower
	IMPORT	|EnableDeviceClocks|
	IMPORT	|SDHCDPowerUpDown|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T45273| DCD	|$LN13@SetPower|
	DCD	0x40002901
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\sdhc\base\sdhc.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetPower@CSDIOControllerBase@@QAAHW4_CEDEVICE_POWER_STATE@@@Z| PROC ; CSDIOControllerBase::SetPower

; 3445 : {

  00000		 |$LN13@SetPower|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45270|
  00004	e1a06001	 mov         r6, r1
  00008	e1a04000	 mov         r4, r0

; 3446 :     BOOL rc = FALSE;
; 3447 : 
; 3448 :     EnterCriticalSection(&m_powerCS);

  0000c	e28400c4	 add         r0, r4, #0xC4
  00010	e3a05000	 mov         r5, #0
  00014	eb000000	 bl          EnterCriticalSection

; 3449 :     if(m_ActualPowerState != dx)

  00018	e59430e0	 ldr         r3, [r4, #0xE0]
  0001c	e1530006	 cmp         r3, r6
  00020	0a00001a	 beq         |$LN4@SetPower|

; 3450 : 	{ 
; 3451 : 	    switch(dx)

  00024	e3560000	 cmp         r6, #0
  00028	0a00000a	 beq         |$LN3@SetPower|
  0002c	e3560004	 cmp         r6, #4
  00030	1a000016	 bne         |$LN4@SetPower|

; 3461 :         break;
; 3462 : 
; 3463 :       case D4:
; 3464 :         // Notify the SD Bus driver of the PowerDown event
; 3465 :         SDHCDPowerUpDown(m_pHCContext, FALSE, FALSE, 0);

  00034	e59400a8	 ldr         r0, [r4, #0xA8]
  00038	e3a03000	 mov         r3, #0
  0003c	e3a02000	 mov         r2, #0
  00040	e3a01000	 mov         r1, #0
  00044	eb000000	 bl          SDHCDPowerUpDown

; 3466 : 		EnableDeviceClocks(m_dwDeviceID, FALSE);

  00048	e5940174	 ldr         r0, [r4, #0x174]
  0004c	e3a01000	 mov         r1, #0
  00050	eb000000	 bl          EnableDeviceClocks

; 3467 : 
; 3468 :         rc = TRUE;
; 3469 :         break;

  00054	ea00000c	 b           |$LN9@SetPower|
  00058		 |$LN3@SetPower|

; 3452 :     {
; 3453 :       case D0:
; 3454 : 		EnableDeviceClocks(m_dwDeviceID, TRUE);

  00058	e5940174	 ldr         r0, [r4, #0x174]
  0005c	e3a01001	 mov         r1, #1
  00060	eb000000	 bl          EnableDeviceClocks

; 3455 : 		// Notify the SD Bus driver of the PowerUp event
; 3456 :         SDHCDPowerUpDown(m_pHCContext, TRUE, FALSE, 0);

  00064	e59400a8	 ldr         r0, [r4, #0xA8]
  00068	e3a03000	 mov         r3, #0
  0006c	e3a02000	 mov         r2, #0
  00070	e3a01001	 mov         r1, #1
  00074	eb000000	 bl          SDHCDPowerUpDown

; 3457 :         if(!m_fCardPresent)

  00078	e59430f0	 ldr         r3, [r4, #0xF0]
  0007c	e3530000	 cmp         r3, #0

; 3458 :             SetEvent(m_hCardDetectEvent);

  00080	05940120	 ldreq       r0, [r4, #0x120]
  00084	03a01003	 moveq       r1, #3
  00088	0b000000	 bleq        EventModify
  0008c		 |$LN9@SetPower|

; 3459 : 
; 3460 :         rc = TRUE;

  0008c	e3a05001	 mov         r5, #1
  00090		 |$LN4@SetPower|

; 3470 :     }
; 3471 :     }
; 3472 :     LeaveCriticalSection(&m_powerCS);

  00090	e28400c4	 add         r0, r4, #0xC4
  00094	eb000000	 bl          LeaveCriticalSection

; 3473 :     return rc;
; 3474 : }

  00098	e1a00005	 mov         r0, r5
  0009c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000a0	e12fff1e	 bx          lr
  000a4		 |$M45271|

			 ENDP  ; |?SetPower@CSDIOControllerBase@@QAAHW4_CEDEVICE_POWER_STATE@@@Z|, CSDIOControllerBase::SetPower

	EXPORT	|?PowerUp@CSDIOControllerBase@@QAAXXZ|	; CSDIOControllerBase::PowerUp

  00000			 AREA	 |.pdata|, PDATA
|$T45280| DCD	|$LN5@PowerUp|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PowerUp@CSDIOControllerBase@@QAAXXZ| PROC ; CSDIOControllerBase::PowerUp

; 3516 : {

  00000		 |$LN5@PowerUp|
  00000		 |$M45277|

; 3517 : }

  00000	e12fff1e	 bx          lr
  00004		 |$M45278|

			 ENDP  ; |?PowerUp@CSDIOControllerBase@@QAAXXZ|, CSDIOControllerBase::PowerUp

	EXPORT	|?ContextRestore@CSDIOControllerBase@@QAAHXZ| ; CSDIOControllerBase::ContextRestore
	IMPORT	|StallExecution|
	IMPORT	|SocSdhcDevconf|

  00000			 AREA	 |.pdata|, PDATA
|$T45292| DCD	|$LN13@ContextRes|
	DCD	0x40003602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ContextRestore@CSDIOControllerBase@@QAAHXZ| PROC ; CSDIOControllerBase::ContextRestore

; 3527 : {

  00000		 |$LN13@ContextRes|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M45289|
  00008	e1a04000	 mov         r4, r0

; 3528 :     SD_API_STATUS      status;              // SD status
; 3529 :     BOOL               fRegisteredWithBusDriver = FALSE;
; 3530 :     BOOL               fHardwareInitialized = FALSE;
; 3531 :     BOOL               bRet = FALSE;
; 3532 :     DWORD              dwClockRate;
; 3533 : 
; 3534 :     DEBUGMSG(SHC_RESPONSE_ZONE, (L"CSDIOControllerBase:+ContextRestore\r\n"));
; 3535 : 	
; 3536 : 	if( !InitializeHardware() )

  0000c	e5943000	 ldr         r3, [r4]
  00010	e3a05000	 mov         r5, #0
  00014	e5933000	 ldr         r3, [r3]
  00018	e1a0e00f	 mov         lr, pc
  0001c	e12fff13	 bx          r3
  00020	e3500000	 cmp         r0, #0
  00024	0a000021	 beq         |$LN10@ContextRes|

; 3537 :     {
; 3538 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("InitializeHardware:: Error allocating CD/RW GPIO registers\r\n")));
; 3539 :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;
; 3540 :         goto cleanUp;
; 3541 :     }
; 3542 : 
; 3543 : 	// Perform SOC-specific configuration
; 3544 : 	SocSdhcDevconf(m_dwSlot);

  00028	e5940170	 ldr         r0, [r4, #0x170]
  0002c	eb000000	 bl          SocSdhcDevconf

; 3545 : 
; 3546 :     fHardwareInitialized = TRUE;
; 3547 : 
; 3548 :     // Initialize the slot
; 3549 :     SoftwareReset(SOFT_RESET_ALL);

  00030	e3a01401	 mov         r1, #1, 8
  00034	e1a00004	 mov         r0, r4
  00038	eb000000	 bl          |?SoftwareReset@CSDIOControllerBase@@QAAXK@Z|
  0003c	e3a03c27	 mov         r3, #0x27, 24

; 3550 : 
; 3551 : 	// Allow time for card to power down after a device reset
; 3552 :     StallExecution(10000);

  00040	e3830010	 orr         r0, r3, #0x10
  00044	eb000000	 bl          StallExecution

; 3553 : 
; 3554 :     dwClockRate = m_sContext.dwClockRate;
; 3555 : 
; 3556 :     OUTREG32(&m_pbRegisters->MMCHS_CON, 0x01 << 7); // CDP

  00048	e594315c	 ldr         r3, [r4, #0x15C]
  0004c	e5942200	 ldr         r2, [r4, #0x200]
  00050	e3a01080	 mov         r1, #0x80

; 3557 :     SetSDVSVoltage();

  00054	e1a00004	 mov         r0, r4
  00058	e583102c	 str         r1, [r3, #0x2C]
  0005c	e58d2000	 str         r2, [sp]
  00060	eb000000	 bl          |?SetSDVSVoltage@CSDIOControllerBase@@QAAXXZ|

; 3558 :     SetSDInterfaceMode(m_sContext.eInterfaceMode);

  00064	e5941208	 ldr         r1, [r4, #0x208]
  00068	e1a00004	 mov         r0, r4
  0006c	eb000000	 bl          |?SetSDInterfaceMode@CSDIOControllerBase@@IAAXW4SD_INTERFACE_MODE@@@Z|

; 3559 :     SetClockRate(&dwClockRate);

  00070	e28d1000	 add         r1, sp, #0
  00074	e1a00004	 mov         r0, r4
  00078	eb000000	 bl          |?SetClockRate@CSDIOControllerBase@@QAAXPAK@Z|

; 3560 : 
; 3561 :     switch (m_sContext.eSDHCIntr)

  0007c	e5943204	 ldr         r3, [r4, #0x204]
  00080	e3530001	 cmp         r3, #1
  00084	0a000005	 beq         |$LN3@ContextRes|
  00088	e3530002	 cmp         r3, #2
  0008c	1a000005	 bne         |$LN4@ContextRes|

; 3565 :             break;
; 3566 : 
; 3567 :         case SDHC_SDIO_INTR_ENABLED:
; 3568 :             EnableSDIOInterrupts();

  00090	e1a00004	 mov         r0, r4
  00094	eb000000	 bl          |?EnableSDIOInterrupts@CSDIOControllerBase@@QAAXXZ|

; 3569 :             break;
; 3570 :         }
; 3571 : 
; 3572 :     fRegisteredWithBusDriver = TRUE;
; 3573 : 
; 3574 :     bRet = TRUE;

  00098	e3a05001	 mov         r5, #1
  0009c		 |$cleanUp$43441|

; 3575 : 
; 3576 : cleanUp:
; 3577 :     if ( (bRet == FALSE) && (m_pHCContext) )

  0009c	ea000009	 b           |$LN1@ContextRes|
  000a0		 |$LN3@ContextRes|

; 3562 :         {
; 3563 :         case SDHC_MMC_INTR_ENABLED:
; 3564 :             EnableSDHCInterrupts();

  000a0	e1a00004	 mov         r0, r4
  000a4	eb000000	 bl          |?EnableSDHCInterrupts@CSDIOControllerBase@@QAAXXZ|
  000a8		 |$LN4@ContextRes|

; 3569 :             break;
; 3570 :         }
; 3571 : 
; 3572 :     fRegisteredWithBusDriver = TRUE;
; 3573 : 
; 3574 :     bRet = TRUE;

  000a8	e3a05001	 mov         r5, #1
  000ac		 |$cleanUp_1$43441|

; 3575 : 
; 3576 : cleanUp:
; 3577 :     if ( (bRet == FALSE) && (m_pHCContext) )

  000ac	ea000005	 b           |$LN1@ContextRes|
  000b0		 |$LN10@ContextRes|
  000b0	e59430a8	 ldr         r3, [r4, #0xA8]
  000b4	e3530000	 cmp         r3, #0

; 3578 :     {
; 3579 :         FreeHostContext( fRegisteredWithBusDriver, fHardwareInitialized );

  000b8	13a02000	 movne       r2, #0
  000bc	13a01000	 movne       r1, #0
  000c0	11a00004	 movne       r0, r4
  000c4	1b000000	 blne        |?FreeHostContext@CSDIOControllerBase@@QAAXHH@Z|
  000c8		 |$LN1@ContextRes|

; 3580 :     }
; 3581 :     DEBUGMSG(SHC_RESPONSE_ZONE, (L"CSDIOControllerBase:-ContextRestore\r\n"));
; 3582 : 
; 3583 :     return bRet;
; 3584 : }

  000c8	e1a00005	 mov         r0, r5
  000cc	e28dd004	 add         sp, sp, #4
  000d0	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000d4	e12fff1e	 bx          lr
  000d8		 |$M45290|

			 ENDP  ; |?ContextRestore@CSDIOControllerBase@@QAAHXZ|, CSDIOControllerBase::ContextRestore

	EXPORT	|?GetCommandResponse@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z| ; CSDIOControllerBase::GetCommandResponse

  00000			 AREA	 |.pdata|, PDATA
|$T45329| DCD	|$LN29@GetCommand|
	DCD	0x40005001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetCommandResponse@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z| PROC ; CSDIOControllerBase::GetCommandResponse

; 3593 : {

  00000		 |$LN29@GetCommand|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45326|
  00004	e1a05001	 mov         r5, r1
  00008	e1a06000	 mov         r6, r0

; 3594 :     DWORD  dwRegVal;
; 3595 :     PUCHAR  respBuff;       // response buffer
; 3596 :     DWORD dwRSP;
; 3597 : 
; 3598 :     dwRegVal = Read_MMC_STAT();

  0000c	e28600b0	 add         r0, r6, #0xB0
  00010	eb000000	 bl          EnterCriticalSection
  00014	e596315c	 ldr         r3, [r6, #0x15C]
  00018	e28600b0	 add         r0, r6, #0xB0
  0001c	e5934130	 ldr         r4, [r3, #0x130]
  00020	eb000000	 bl          LeaveCriticalSection
  00024	e3a03211	 mov         r3, #0x11, 4

; 3599 : 
; 3600 :     DEBUGMSG(SHC_RESPONSE_ZONE, (TEXT("GetCommandResponse() - MMC_STAT = 0x%08X.\r\n"), dwRegVal));
; 3601 : 
; 3602 : 
; 3603 :     if ( dwRegVal & (MMCHS_STAT_CC | MMCHS_STAT_CERR | MMCHS_STAT_CCRC))

  00028	e3833802	 orr         r3, r3, #2, 16
  0002c	e1140003	 tst         r4, r3
  00030	0a00003f	 beq         |$LN1@GetCommand|

; 3604 :     {
; 3605 :         respBuff = pRequest->CommandResponse.ResponseBuffer;
; 3606 : 
; 3607 :         switch(pRequest->CommandResponse.ResponseType)

  00034	e595301c	 ldr         r3, [r5, #0x1C]
  00038	e2432001	 sub         r2, r3, #1
  0003c	e3520007	 cmp         r2, #7
  00040	8a00003b	 bhi         |$LN1@GetCommand|
  00044	e28f3004	 add         r3, pc, #4
  00048	e7d33002	 ldrb        r3, [r3, +r2]
  0004c	e08ff003	 add         pc, pc, r3
  00050		 |$LN18@GetCommand|
  00050		 |$LN17@GetCommand|
  00050		 |$LN19@GetCommand|
  00050	04ed		 DCB         0x4
  00051		 |$LN20@GetCommand|
  00051	04ed		 DCB         0x4
  00052		 |$LN21@GetCommand|
  00052	50ed		 DCB         0x50
  00053		 |$LN22@GetCommand|
  00053	3ced		 DCB         0x3c
  00054		 |$LN23@GetCommand|
  00054	3ced		 DCB         0x3c
  00055		 |$LN24@GetCommand|
  00055	44ed		 DCB         0x44
  00056		 |$LN25@GetCommand|
  00056	44ed		 DCB         0x44
  00057		 |$LN26@GetCommand|
  00057	3ced		 DCB         0x3c
  00058		 |$LN5@GetCommand|

; 3608 :         {
; 3609 :         case NoResponse:
; 3610 :             break;
; 3611 : 
; 3612 :         case ResponseR1:
; 3613 :         case ResponseR1b:
; 3614 :             //--- SHORT RESPONSE (48 bits total)---
; 3615 :             // Format: { START_BIT(1) | TRANSMISSION_BIT(1) | COMMAND_INDEX(6) | CARD_STATUS(32) | CRC7(7) | END_BIT(1) }
; 3616 :             // NOTE: START_BIT and TRANSMISSION_BIT = 0, END_BIT = 1
; 3617 :             //
; 3618 :             // Dummy byte needed by calling function.
; 3619 :             *respBuff = (BYTE)(START_BIT | TRANSMISSION_BIT | pRequest->CommandCode);

  00058	e5d53014	 ldrb        r3, [r5, #0x14]
  0005c		 |$LN16@GetCommand|

; 3620 : 
; 3621 :             dwRSP = INREG32(&m_pbRegisters->MMCHS_RSP10);
; 3622 : 
; 3623 :             *(respBuff + 1) = (BYTE)(dwRSP & 0xFF);
; 3624 :             *(respBuff + 2) = (BYTE)(dwRSP >> 8);
; 3625 :             *(respBuff + 3) = (BYTE)(dwRSP >> 16);
; 3626 :             *(respBuff + 4) = (BYTE)(dwRSP >> 24);
; 3627 : 
; 3628 : 
; 3629 :             *(respBuff + 5) = (BYTE)(END_RESERVED | END_BIT);

  0005c	e3a020ff	 mov         r2, #0xFF
  00060		 |$LN15@GetCommand|
  00060	e5c53020	 strb        r3, [r5, #0x20]
  00064	e596315c	 ldr         r3, [r6, #0x15C]
  00068	e5930110	 ldr         r0, [r3, #0x110]
  0006c	e5c52025	 strb        r2, [r5, #0x25]
  00070	e1a03420	 mov         r3, r0, lsr #8
  00074	e1a02820	 mov         r2, r0, lsr #16
  00078	e1a01c20	 mov         r1, r0, lsr #24
  0007c	e5c53022	 strb        r3, [r5, #0x22]
  00080	e5c52023	 strb        r2, [r5, #0x23]
  00084	e5c51024	 strb        r1, [r5, #0x24]
  00088	e5c50021	 strb        r0, [r5, #0x21]

; 3630 : 
; 3631 :             DEBUGMSG(SHC_RESPONSE_ZONE, (TEXT("GetCommandResponse() - R1 R1b : 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x \r\n"), *(respBuff + 0),
; 3632 :                 *(respBuff + 1), *(respBuff + 2), *(respBuff + 3), *(respBuff + 4), *(respBuff + 5)));
; 3633 :             DEBUGMSG (SHC_SDBUS_INTERACT_ZONE,(TEXT("GetCmdResponse returned [%02x%02x%02x%02x%02x]\r\n"),
; 3634 :                 respBuff[0], respBuff[1], respBuff[2], respBuff[3], respBuff[4], respBuff[5] ));
; 3635 : #ifdef ENABLE_RETAIL_OUTPUT
; 3636 :             RETAILMSG (1,(TEXT("GetCmdResponse returned [%02x%02x%02x%02x%02x]\r\n"),
; 3637 :                 respBuff[0], respBuff[1], respBuff[2], respBuff[3], respBuff[4], respBuff[5] ));
; 3638 : #endif
; 3639 :             break;

  0008c	ea000028	 b           |$LN1@GetCommand|
  00090		 |$LN4@GetCommand|

; 3640 : 
; 3641 :         case ResponseR3:
; 3642 :         case ResponseR4:
; 3643 :         case ResponseR7:
; 3644 :             DEBUGMSG(SHC_RESPONSE_ZONE, (TEXT("ResponseR3 ResponseR4\r\n")));
; 3645 :             //--- SHORT RESPONSE (48 bits total)---
; 3646 :             // Format: { START_BIT(1) | TRANSMISSION_BIT(1) | RESERVED(6) | CARD_STATUS(32) | RESERVED(7) | END_BIT(1) }
; 3647 :             //
; 3648 :             *respBuff = (BYTE)(START_BIT | TRANSMISSION_BIT | START_RESERVED);

  00090	e3a0303f	 mov         r3, #0x3F

; 3649 : 
; 3650 :             dwRSP = INREG32(&m_pbRegisters->MMCHS_RSP10);
; 3651 : 
; 3652 :             *(respBuff + 1) = (BYTE)(dwRSP & 0xFF);
; 3653 :             *(respBuff + 2) = (BYTE)(dwRSP >> 8);
; 3654 :             *(respBuff + 3) = (BYTE)(dwRSP >> 16);
; 3655 :             *(respBuff + 4) = (BYTE)(dwRSP >> 24);
; 3656 : 
; 3657 :             *(respBuff + 5) = (BYTE)(END_RESERVED | END_BIT);
; 3658 : 
; 3659 :             DEBUGMSG (SHC_SDBUS_INTERACT_ZONE,(TEXT("GetCmdResponse returned [%02x%02x%02x%02x%02x]\r\n"),
; 3660 :                 respBuff[0], respBuff[1], respBuff[2], respBuff[3], respBuff[4], respBuff[5] ));
; 3661 : #ifdef ENABLE_RETAIL_OUTPUT
; 3662 :             RETAILMSG (1,(TEXT("GetCmdResponse returned [%02x%02x%02x%02x%02x]\r\n"),
; 3663 :                 respBuff[0], respBuff[1], respBuff[2], respBuff[3], respBuff[4], respBuff[5] ));
; 3664 : #endif
; 3665 :             break;

  00094	eafffff0	 b           |$LN16@GetCommand|
  00098		 |$LN3@GetCommand|

; 3666 : 
; 3667 :         case ResponseR5:
; 3668 :         case ResponseR6:
; 3669 :             DEBUGMSG(SHC_RESPONSE_ZONE, (TEXT("ResponseR5 ResponseR6\r\n")));
; 3670 :             //--- SHORT RESPONSE (48 bits total)---
; 3671 :             // Format: { START_BIT(1) | TRANSMISSION_BIT(1) | COMMAND_INDEX(6) | RCA(16) | CARD_STATUS(16) | CRC7(7) | END_BIT(1) }
; 3672 :             //
; 3673 :             *respBuff = (BYTE)(START_BIT | TRANSMISSION_BIT | pRequest->CommandCode);

  00098	e5d53014	 ldrb        r3, [r5, #0x14]

; 3674 : 
; 3675 :             dwRSP = INREG32(&m_pbRegisters->MMCHS_RSP10);
; 3676 : 
; 3677 :             *(respBuff + 1) = (BYTE)(dwRSP & 0xFF);
; 3678 :             *(respBuff + 2) = (BYTE)(dwRSP >> 8);
; 3679 :             *(respBuff + 3) = (BYTE)(dwRSP >> 16);
; 3680 :             *(respBuff + 4) = (BYTE)(dwRSP >> 24);
; 3681 : 
; 3682 :             *(respBuff + 5) = (BYTE)(END_BIT);

  0009c	e3a02001	 mov         r2, #1

; 3683 : 
; 3684 :             DEBUGMSG(SHC_RESPONSE_ZONE, (TEXT("GetCommandResponse() - R5 R6 : 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n"), *(respBuff + 0),
; 3685 :                 *(respBuff + 1), *(respBuff + 2), *(respBuff + 3), *(respBuff + 4), *(respBuff + 5)));
; 3686 : 
; 3687 :             DEBUGMSG (SHC_SDBUS_INTERACT_ZONE,(TEXT("GetCmdResponse returned [%02x%02x%02x%02x%02x]\r\n"),
; 3688 :                 respBuff[0], respBuff[1], respBuff[2], respBuff[3], respBuff[4], respBuff[5] ));
; 3689 : #ifdef ENABLE_RETAIL_OUTPUT
; 3690 :             RETAILMSG (1,(TEXT("GetCmdResponse returned [%02x%02x%02x%02x%02x]\r\n"),
; 3691 :                 respBuff[0], respBuff[1], respBuff[2], respBuff[3], respBuff[4], respBuff[5] ));
; 3692 : #endif
; 3693 :             break;

  000a0	eaffffee	 b           |$LN15@GetCommand|
  000a4		 |$LN2@GetCommand|

; 3694 : 
; 3695 :         case ResponseR2:
; 3696 : 
; 3697 :             dwRSP = INREG32(&m_pbRegisters->MMCHS_RSP10);

  000a4	e596315c	 ldr         r3, [r6, #0x15C]
  000a8	e5930110	 ldr         r0, [r3, #0x110]

; 3698 : 
; 3699 :             *(respBuff + 0) = (BYTE)(dwRSP & 0xFF);
; 3700 :             *(respBuff + 1) = (BYTE)(dwRSP >> 8);

  000ac	e1a03420	 mov         r3, r0, lsr #8

; 3701 :             *(respBuff + 2) = (BYTE)(dwRSP >> 16);

  000b0	e1a02820	 mov         r2, r0, lsr #16

; 3702 :             *(respBuff + 3) = (BYTE)(dwRSP >> 24);

  000b4	e1a01c20	 mov         r1, r0, lsr #24
  000b8	e5c53021	 strb        r3, [r5, #0x21]
  000bc	e5c52022	 strb        r2, [r5, #0x22]
  000c0	e5c51023	 strb        r1, [r5, #0x23]
  000c4	e5c50020	 strb        r0, [r5, #0x20]

; 3703 : 
; 3704 :             dwRSP = INREG32(&m_pbRegisters->MMCHS_RSP32);

  000c8	e596315c	 ldr         r3, [r6, #0x15C]
  000cc	e5930114	 ldr         r0, [r3, #0x114]

; 3705 : 
; 3706 :             *(respBuff + 4) = (BYTE)(dwRSP & 0xFF);
; 3707 :             *(respBuff + 5) = (BYTE)(dwRSP >> 8);

  000d0	e1a03420	 mov         r3, r0, lsr #8

; 3708 :             *(respBuff + 6) = (BYTE)(dwRSP >> 16);

  000d4	e1a02820	 mov         r2, r0, lsr #16

; 3709 :             *(respBuff + 7) = (BYTE)(dwRSP >> 24);

  000d8	e1a01c20	 mov         r1, r0, lsr #24
  000dc	e5c53025	 strb        r3, [r5, #0x25]
  000e0	e5c52026	 strb        r2, [r5, #0x26]
  000e4	e5c51027	 strb        r1, [r5, #0x27]
  000e8	e5c50024	 strb        r0, [r5, #0x24]

; 3710 : 
; 3711 :             dwRSP = INREG32(&m_pbRegisters->MMCHS_RSP54);

  000ec	e596315c	 ldr         r3, [r6, #0x15C]
  000f0	e5930118	 ldr         r0, [r3, #0x118]

; 3712 : 
; 3713 :             *(respBuff + 8) = (BYTE)(dwRSP & 0xFF);
; 3714 :             *(respBuff + 9) = (BYTE)(dwRSP >> 8);

  000f4	e1a03420	 mov         r3, r0, lsr #8

; 3715 :             *(respBuff + 10) = (BYTE)(dwRSP >> 16);

  000f8	e1a02820	 mov         r2, r0, lsr #16

; 3716 :             *(respBuff + 11) = (BYTE)(dwRSP >> 24);

  000fc	e1a01c20	 mov         r1, r0, lsr #24
  00100	e5c53029	 strb        r3, [r5, #0x29]
  00104	e5c5202a	 strb        r2, [r5, #0x2A]
  00108	e5c5102b	 strb        r1, [r5, #0x2B]
  0010c	e5c50028	 strb        r0, [r5, #0x28]

; 3717 : 
; 3718 : 
; 3719 :             dwRSP = INREG32(&m_pbRegisters->MMCHS_RSP76);

  00110	e596315c	 ldr         r3, [r6, #0x15C]
  00114	e593011c	 ldr         r0, [r3, #0x11C]

; 3720 : 
; 3721 :             *(respBuff + 12) = (BYTE)(dwRSP & 0xFF);
; 3722 :             *(respBuff + 13) = (BYTE)(dwRSP >> 8);

  00118	e1a03420	 mov         r3, r0, lsr #8

; 3723 :             *(respBuff + 14) = (BYTE)(dwRSP >> 16);

  0011c	e1a02820	 mov         r2, r0, lsr #16

; 3724 :             *(respBuff + 15) = (BYTE)(dwRSP >> 24);

  00120	e1a01c20	 mov         r1, r0, lsr #24
  00124	e5c5302d	 strb        r3, [r5, #0x2D]
  00128	e5c5202e	 strb        r2, [r5, #0x2E]
  0012c	e5c5102f	 strb        r1, [r5, #0x2F]
  00130	e5c5002c	 strb        r0, [r5, #0x2C]
  00134		 |$LN1@GetCommand|

; 3725 : 
; 3726 :             DEBUGMSG (SHC_SDBUS_INTERACT_ZONE,(TEXT("GetCmdResponse returned [%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x%02x%02x %02x%02x%02x%02x]\r\n"),
; 3727 :                 respBuff[0], respBuff[1], respBuff[2], respBuff[3], respBuff[4], respBuff[5], respBuff[6], respBuff[7],
; 3728 :                 respBuff[8], respBuff[9], respBuff[10], respBuff[11], respBuff[12], respBuff[13], respBuff[14], respBuff[15]));
; 3729 : 
; 3730 : #ifdef ENABLE_RETAIL_OUTPUT
; 3731 :             RETAILMSG (1, (TEXT("GetCmdResponse returned [%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x%02x%02x %02x%02x%02x%02x]\r\n"),
; 3732 :                 respBuff[0], respBuff[1], respBuff[2], respBuff[3], respBuff[4], respBuff[5], respBuff[6], respBuff[7],
; 3733 :                 respBuff[8], respBuff[9], respBuff[10], respBuff[11], respBuff[12], respBuff[13], respBuff[14], respBuff[15]));
; 3734 : #endif
; 3735 :             break;
; 3736 : 
; 3737 :         default:
; 3738 :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("GetCommandResponse() - Unrecognized response type!\r\n")));
; 3739 :             break;
; 3740 :         }
; 3741 :     }
; 3742 :     return SD_API_STATUS_SUCCESS;

  00134	e3a00000	 mov         r0, #0

; 3743 : }

  00138	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0013c	e12fff1e	 bx          lr
  00140		 |$M45327|

			 ENDP  ; |?GetCommandResponse@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z|, CSDIOControllerBase::GetCommandResponse

	EXPORT	|?SDIDMAReceive@CSDIOControllerBase@@QAAHPAEKH@Z| ; CSDIOControllerBase::SDIDMAReceive
	EXPORT	|??_C@_1GE@EMGJJJMP@?$AAA?$AA?4?$AAS?$AA?4?$AA?5?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?5?$AAw?$AAh?$AAi?$AAl?$AAe?$AA?5?$AAp?$AAo?$AAl?$AAl?$AAi?$AAn?$AAg?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAR@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T45383| DCD	|$LN52@SDIDMARece|
	DCD	0x40006801

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GE@EMGJJJMP@?$AAA?$AA?4?$AAS?$AA?4?$AA?5?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?5?$AAw?$AAh?$AAi?$AAl?$AAe?$AA?5?$AAp?$AAo?$AAl?$AAl?$AAi?$AAn?$AAg?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAR@| DCB "A"
	DCB	0x0, ".", 0x0, "S", 0x0, ".", 0x0, " ", 0x0, "T", 0x0, "i"
	DCB	0x0, "m", 0x0, "e", 0x0, "o", 0x0, "u", 0x0, "t", 0x0, " "
	DCB	0x0, "w", 0x0, "h", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, " "
	DCB	0x0, "p", 0x0, "o", 0x0, "l", 0x0, "l", 0x0, "i", 0x0, "n"
	DCB	0x0, "g", 0x0, " ", 0x0, "D", 0x0, "M", 0x0, "A", 0x0, " "
	DCB	0x0, "R", 0x0, "e", 0x0, "c", 0x0, "e", 0x0, "i", 0x0, "v"
	DCB	0x0, "e", 0x0, " ", 0x0, "c", 0x0, "o", 0x0, "m", 0x0, "p"
	DCB	0x0, "l", 0x0, "e", 0x0, "t", 0x0, "e", 0x0, ".", 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDIDMAReceive@CSDIOControllerBase@@QAAHPAEKH@Z| PROC ; CSDIOControllerBase::SDIDMAReceive

; 3779 : {

  00000		 |$LN52@SDIDMARece|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M45380|
  00004	e1a08002	 mov         r8, r2
  00008	e1a09001	 mov         r9, r1
  0000c	e1a05000	 mov         r5, r0

; 3780 :     DWORD dwCountStart;
; 3781 :     DWORD __unaligned *pbuf2 = (DWORD *) pBuff;
; 3782 : 
; 3783 :     DWORD MMC_STAT = Read_MMC_STAT(); 

  00010	e28500b0	 add         r0, r5, #0xB0
  00014	eb000000	 bl          EnterCriticalSection
  00018	e595315c	 ldr         r3, [r5, #0x15C]
  0001c	e28500b0	 add         r0, r5, #0xB0
  00020	e5934130	 ldr         r4, [r3, #0x130]
  00024	eb000000	 bl          LeaveCriticalSection

; 3784 : 
; 3785 :     UNREFERENCED_PARAMETER(FastPathMode);
; 3786 : 
; 3787 :     if( MMC_STAT & MMCHS_STAT_DTO )

  00028	e3140601	 tst         r4, #1, 12
  0002c	1a00003f	 bne         |$cleanUp$43551|

; 3788 :     {
; 3789 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDIDMAReceive() - exit: STAT register indicates MMC_STAT_DTO error.\n")));
; 3790 :         goto cleanUp;
; 3791 :     }
; 3792 :     if( MMC_STAT & MMCHS_STAT_DCRC ) // DATA CRC Error

  00030	e3140602	 tst         r4, #2, 12
  00034	1a00003d	 bne         |$cleanUp$43551|

; 3793 :     {
; 3794 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDIDMAReceive() - exit: STAT register indicates MMC_CRC_ERROR_RCVD error.\n")));
; 3795 :         goto cleanUp;
; 3796 :     }
; 3797 : 
; 3798 :     // Clear interrupt status
; 3799 :         EnterCriticalSection( &m_critSec );

  00038	e28500b0	 add         r0, r5, #0xB0
  0003c	eb000000	 bl          EnterCriticalSection

; 3800 :         SETREG32(&m_pbRegisters->MMCHS_IE, MMCHS_IE_TC);

  00040	e595e15c	 ldr         lr, [r5, #0x15C]

; 3801 :         CLRREG32(&m_pbRegisters->MMCHS_ISE, MMCHS_ISE_TC);
; 3802 :         OUTREG32(&m_pbRegisters->MMCHS_STAT, 0xFFFFFFFF);

  00044	e3e01000	 mvn         r1, #0

; 3803 :         LeaveCriticalSection( &m_critSec );

  00048	e28500b0	 add         r0, r5, #0xB0
  0004c	e59e3134	 ldr         r3, [lr, #0x134]
  00050	e3833002	 orr         r3, r3, #2
  00054	e58e3134	 str         r3, [lr, #0x134]
  00058	e595215c	 ldr         r2, [r5, #0x15C]
  0005c	e5923138	 ldr         r3, [r2, #0x138]
  00060	e3c33002	 bic         r3, r3, #2
  00064	e5823138	 str         r3, [r2, #0x138]
  00068	e595315c	 ldr         r3, [r5, #0x15C]
  0006c	e5831130	 str         r1, [r3, #0x130]
  00070	eb000000	 bl          LeaveCriticalSection

; 3804 : 
; 3805 :     SDIO_StartInputDMA();

  00074	e1a00005	 mov         r0, r5
  00078	eb000000	 bl          |?SDIO_StartInputDMA@CSDIOControllerBase@@QAAXXZ|

; 3806 : 
; 3807 :     StallExecution(1);

  0007c	e3a00001	 mov         r0, #1
  00080	eb000000	 bl          StallExecution

; 3808 : 
; 3809 :     // calculate timeout conditions
; 3810 :     dwCountStart = GetTickCount();

  00084	eb000000	 bl          GetTickCount
  00088	e1a07000	 mov         r7, r0

; 3811 : 
; 3812 :     // wait for the SDIO/controller interrupt
; 3813 :     for(;;)
; 3814 :     {
; 3815 :         // check for a timeout
; 3816 :         if (GetTickCount() - dwCountStart > m_dwMaxTimeout)

  0008c	ea000020	 b           |$LN47@SDIDMARece|
  00090		 |$LL16@SDIDMARece|

; 3821 :             goto cleanUp;
; 3822 :         }
; 3823 : 
; 3824 :            DWORD retries = 0;
; 3825 :            // polling end-of-command
; 3826 :            while (!(Read_MMC_STAT() & MMCHS_STAT_TC)) {

  00090	e3a06000	 mov         r6, #0
  00094	ea000002	 b           |$LN49@SDIDMARece|
  00098		 |$LL12@SDIDMARece|

; 3827 :                if (retries > SDIO_MAX_LOOP) {

  00098	e3560702	 cmp         r6, #2, 14
  0009c	8a000009	 bhi         |$LN38@SDIDMARece|

; 3829 :                    break;      
; 3830 :                }
; 3831 :                retries++;

  000a0	e2866001	 add         r6, r6, #1
  000a4		 |$LN49@SDIDMARece|

; 3827 :                if (retries > SDIO_MAX_LOOP) {

  000a4	e28500b0	 add         r0, r5, #0xB0

; 3829 :                    break;      
; 3830 :                }
; 3831 :                retries++;

  000a8	eb000000	 bl          EnterCriticalSection
  000ac	e595315c	 ldr         r3, [r5, #0x15C]
  000b0	e28500b0	 add         r0, r5, #0xB0
  000b4	e5934130	 ldr         r4, [r3, #0x130]
  000b8	eb000000	 bl          LeaveCriticalSection
  000bc	e3140002	 tst         r4, #2
  000c0	0afffff4	 beq         |$LL12@SDIDMARece|

; 3852 :         {
; 3853 :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDIDMAReceive() - exit: STAT register indicates MMC_STAT_DTO error.\n")));
; 3854 :             // stop DMA
; 3855 :             SDIO_StopInputDMA();
; 3856 :             goto cleanUp;
; 3857 :         }
; 3858 :         if( MMC_STAT & MMCHS_STAT_DCRC ) // DATA CRC Error

  000c4	ea000001	 b           |$LN24@SDIDMARece|
  000c8		 |$LN38@SDIDMARece|

; 3828 :                    RETAILMSG(1, (TEXT("A.S. Timeout while polling DMA Receive complete.\n")));

  000c8	e59f00cc	 ldr         r0, [pc, #0xCC]
  000cc	eb000000	 bl          NKDbgPrintfW
  000d0		 |$LN24@SDIDMARece|

; 3832 :            }
; 3833 : 
; 3834 :         if(!m_fCardPresent)

  000d0	e59530f0	 ldr         r3, [r5, #0xF0]
  000d4	e3530000	 cmp         r3, #0
  000d8	0a000017	 beq         |$LN40@SDIDMARece|

; 3835 :         {
; 3836 : #ifdef ENABLE_RETAIL_OUTPUT
; 3837 :            RETAILMSG(1, (L"Card has been Removed stopping Input DMA\r\n"));
; 3838 : #endif
; 3839 :            break;
; 3840 :         }
; 3841 : 
; 3842 :         MMC_STAT = Read_MMC_STAT(); 

  000dc	e28500b0	 add         r0, r5, #0xB0
  000e0	eb000000	 bl          EnterCriticalSection
  000e4	e595315c	 ldr         r3, [r5, #0x15C]
  000e8	e28500b0	 add         r0, r5, #0xB0
  000ec	e5934130	 ldr         r4, [r3, #0x130]
  000f0	eb000000	 bl          LeaveCriticalSection

; 3843 :         if(MMC_STAT & MMCHS_STAT_BRR)

  000f4	e3140020	 tst         r4, #0x20
  000f8	1a00000f	 bne         |$LN40@SDIDMARece|

; 3844 :         {
; 3845 :             break;
; 3846 :         }
; 3847 :         if(MMC_STAT & MMCHS_STAT_TC)

  000fc	e3140002	 tst         r4, #2
  00100	1a00000d	 bne         |$LN40@SDIDMARece|

; 3848 :         {
; 3849 :             break;
; 3850 :         }
; 3851 :         if( MMC_STAT & MMCHS_STAT_DTO )

  00104	e3140601	 tst         r4, #1, 12
  00108	1a000006	 bne         |$LN39@SDIDMARece|

; 3852 :         {
; 3853 :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDIDMAReceive() - exit: STAT register indicates MMC_STAT_DTO error.\n")));
; 3854 :             // stop DMA
; 3855 :             SDIO_StopInputDMA();
; 3856 :             goto cleanUp;
; 3857 :         }
; 3858 :         if( MMC_STAT & MMCHS_STAT_DCRC ) // DATA CRC Error

  0010c	e3140602	 tst         r4, #2, 12
  00110	1a000004	 bne         |$LN39@SDIDMARece|
  00114		 |$LN47@SDIDMARece|
  00114	eb000000	 bl          GetTickCount
  00118	e5952150	 ldr         r2, [r5, #0x150]
  0011c	e0403007	 sub         r3, r0, r7
  00120	e1530002	 cmp         r3, r2
  00124	9affffd9	 bls         |$LL16@SDIDMARece|
  00128		 |$LN39@SDIDMARece|

; 3817 :         {
; 3818 :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDIDMAReceive() - exit: TIMEOUT.\n")));
; 3819 :             // stop DMA
; 3820 :             SDIO_StopInputDMA();

  00128	e1a00005	 mov         r0, r5
  0012c	eb000000	 bl          |?SDIO_StopInputDMA@CSDIOControllerBase@@QAAXXZ|

; 3859 :         {
; 3860 :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDIDMAReceive() - exit: STAT register indicates MMC_STAT_DCRC error.\n")));
; 3861 :             // stop DMA
; 3862 :             SDIO_StopInputDMA();

  00130		 |$cleanUp$43551|

; 3886 : 
; 3887 : cleanUp:
; 3888 : #ifdef ENABLE_RETAIL_OUTPUT
; 3889 :     RETAILMSG(1, (L"SDIDMAReceive(%08X, %08X, %08X)-\r\n", INREG32(&m_pbRegisters->MMCHS_STAT), INREG32(&m_pbRegisters->MMCHS_PSTATE), INREG32(&m_pbRegisters->MMCHS_DATA)));
; 3890 : #endif
; 3891 :     return FALSE;

  00130	e3a00000	 mov         r0, #0

; 3892 : }

  00134	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00138	e12fff1e	 bx          lr
  0013c		 |$LN40@SDIDMARece|

; 3863 :             goto cleanUp;
; 3864 :         }
; 3865 : 
; 3866 :     }
; 3867 : 
; 3868 :     MMC_STAT = Read_MMC_STAT(); 

  0013c	e28500b0	 add         r0, r5, #0xB0
  00140	eb000000	 bl          EnterCriticalSection
  00144	e595315c	 ldr         r3, [r5, #0x15C]
  00148	e28500b0	 add         r0, r5, #0xB0
  0014c	e5933130	 ldr         r3, [r3, #0x130]
  00150	eb000000	 bl          LeaveCriticalSection

; 3869 : 
; 3870 :     // stop DMA
; 3871 :     SDIO_StopInputDMA();

  00154	e1a00005	 mov         r0, r5
  00158	eb000000	 bl          |?SDIO_StopInputDMA@CSDIOControllerBase@@QAAXXZ|

; 3872 : 
; 3873 :     Set_MMC_STAT(MMCHS_STAT_TC);

  0015c	e28500b0	 add         r0, r5, #0xB0
  00160	eb000000	 bl          EnterCriticalSection
  00164	e595315c	 ldr         r3, [r5, #0x15C]
  00168	e3a02002	 mov         r2, #2
  0016c	e28500b0	 add         r0, r5, #0xB0
  00170	e5832130	 str         r2, [r3, #0x130]
  00174	eb000000	 bl          LeaveCriticalSection

; 3874 : 
; 3875 :     // finally, copy the data from DMA buffer to the user buffer, which maybe SG buffer, 
; 3876 :     if( !SDPerformSafeCopy( pbuf2, m_pDmaBuffer, dwLen ) )

  00178	e59510fc	 ldr         r1, [r5, #0xFC]
  0017c	e1a02008	 mov         r2, r8
  00180	e1a00009	 mov         r0, r9
  00184	eb000000	 bl          SDPerformSafeCopy
  00188	e3500000	 cmp         r0, #0
  0018c	0affffe7	 beq         |$cleanUp$43551|

; 3877 :     {
; 3878 :         goto cleanUp;
; 3879 :     }
; 3880 : 
; 3881 : #ifdef ENABLE_RETAIL_OUTPUT
; 3882 :     RETAILMSG(1, (L"SDIDMAReceive(dwLen 0x%x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x)+\r\n", 
; 3883 :       dwLen, pbuf2[0], pbuf2[1], pbuf2[2], pbuf2[3], pbuf2[4], pbuf2[5], pbuf2[6], pbuf2[7])); 
; 3884 : #endif      
; 3885 :     return TRUE;  

  00190	e3a00001	 mov         r0, #1

; 3892 : }

  00194	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00198	e12fff1e	 bx          lr
  0019c		 |$LN53@SDIDMARece|
  0019c		 |$LN54@SDIDMARece|
  0019c	00000000	 DCD         |??_C@_1GE@EMGJJJMP@?$AAA?$AA?4?$AAS?$AA?4?$AA?5?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?5?$AAw?$AAh?$AAi?$AAl?$AAe?$AA?5?$AAp?$AAo?$AAl?$AAl?$AAi?$AAn?$AAg?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAR@|
  001a0		 |$M45381|

			 ENDP  ; |?SDIDMAReceive@CSDIOControllerBase@@QAAHPAEKH@Z|, CSDIOControllerBase::SDIDMAReceive

	EXPORT	|?SDIDMATransmit@CSDIOControllerBase@@QAAHPAEKH@Z| ; CSDIOControllerBase::SDIDMATransmit
	EXPORT	|??_C@_1GG@GOJDNFHN@?$AAA?$AA?4?$AAS?$AA?4?$AA?5?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?5?$AAw?$AAh?$AAi?$AAl?$AAe?$AA?5?$AAp?$AAo?$AAl?$AAl?$AAi?$AAn?$AAg?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAT@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T45438| DCD	|$LN50@SDIDMATran|
	DCD	0x40006301

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GG@GOJDNFHN@?$AAA?$AA?4?$AAS?$AA?4?$AA?5?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?5?$AAw?$AAh?$AAi?$AAl?$AAe?$AA?5?$AAp?$AAo?$AAl?$AAl?$AAi?$AAn?$AAg?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAT@| DCB "A"
	DCB	0x0, ".", 0x0, "S", 0x0, ".", 0x0, " ", 0x0, "T", 0x0, "i"
	DCB	0x0, "m", 0x0, "e", 0x0, "o", 0x0, "u", 0x0, "t", 0x0, " "
	DCB	0x0, "w", 0x0, "h", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, " "
	DCB	0x0, "p", 0x0, "o", 0x0, "l", 0x0, "l", 0x0, "i", 0x0, "n"
	DCB	0x0, "g", 0x0, " ", 0x0, "D", 0x0, "M", 0x0, "A", 0x0, " "
	DCB	0x0, "T", 0x0, "r", 0x0, "a", 0x0, "n", 0x0, "s", 0x0, "m"
	DCB	0x0, "i", 0x0, "t", 0x0, " ", 0x0, "c", 0x0, "o", 0x0, "m"
	DCB	0x0, "p", 0x0, "l", 0x0, "e", 0x0, "t", 0x0, "e", 0x0, "."
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDIDMATransmit@CSDIOControllerBase@@QAAHPAEKH@Z| PROC ; CSDIOControllerBase::SDIDMATransmit

; 3896 : {

  00000		 |$LN50@SDIDMATran|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M45435|
  00004	e1a05000	 mov         r5, r0

; 3897 :     DWORD dwCountStart;
; 3898 :     DWORD __unaligned *pbuf2 = (DWORD *) pBuff;
; 3899 : 
; 3900 :     UNREFERENCED_PARAMETER(FastPathMode);
; 3901 : 
; 3902 :     // first copy the data to the DMA buffer, then to the user buffer, which maybe SG buffer,
; 3903 :     if( !SDPerformSafeCopy( m_pDmaBuffer, pbuf2, dwLen ) )

  00008	e59500fc	 ldr         r0, [r5, #0xFC]
  0000c	eb000000	 bl          SDPerformSafeCopy
  00010	e3500000	 cmp         r0, #0
  00014	0a000043	 beq         |$cleanUp$43597|

; 3904 :     {
; 3905 :         goto cleanUp;
; 3906 :     }
; 3907 : 
; 3908 :     DWORD MMC_STAT = Read_MMC_STAT(); 

  00018	e28500b0	 add         r0, r5, #0xB0
  0001c	eb000000	 bl          EnterCriticalSection
  00020	e595315c	 ldr         r3, [r5, #0x15C]
  00024	e28500b0	 add         r0, r5, #0xB0
  00028	e5934130	 ldr         r4, [r3, #0x130]
  0002c	eb000000	 bl          LeaveCriticalSection

; 3909 : #ifdef ENABLE_RETAIL_OUTPUT
; 3910 :     RETAILMSG(1, (L"SDIDMATransmit(dwLen 0x%x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x)+\r\n", 
; 3911 :       dwLen, pbuf2[0], pbuf2[1], pbuf2[2], pbuf2[3], pbuf2[4], pbuf2[5], pbuf2[6], pbuf2[7])); 
; 3912 : #endif      
; 3913 :     if( MMC_STAT & MMCHS_STAT_DTO )

  00030	e3140601	 tst         r4, #1, 12
  00034	1a00003b	 bne         |$cleanUp$43597|

; 3914 :     {
; 3915 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDIDMATransmit() - exit: STAT register indicates MMC_STAT_DTO error.\n")));
; 3916 :         goto cleanUp;
; 3917 :     }
; 3918 :     if( MMC_STAT & MMCHS_STAT_DCRC ) // DATA CRC Error

  00038	e3140602	 tst         r4, #2, 12
  0003c	1a000039	 bne         |$cleanUp$43597|

; 3919 :     {
; 3920 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDIDMATransmit() - exit: STAT register indicates MMC_STAT_DCRC error.\n")));
; 3921 :         goto cleanUp;
; 3922 :     }
; 3923 : 
; 3924 :     // Clear interrupt status
; 3925 :         EnterCriticalSection( &m_critSec );

  00040	e28500b0	 add         r0, r5, #0xB0
  00044	eb000000	 bl          EnterCriticalSection

; 3926 :         SETREG32(&m_pbRegisters->MMCHS_IE, MMCHS_IE_TC);

  00048	e595215c	 ldr         r2, [r5, #0x15C]

; 3927 :         CLRREG32(&m_pbRegisters->MMCHS_ISE, MMCHS_ISE_TC);
; 3928 :         OUTREG32(&m_pbRegisters->MMCHS_STAT, 0xFFFFFFFF);

  0004c	e3e01000	 mvn         r1, #0

; 3929 :         LeaveCriticalSection( &m_critSec );

  00050	e28500b0	 add         r0, r5, #0xB0
  00054	e5923134	 ldr         r3, [r2, #0x134]
  00058	e3833002	 orr         r3, r3, #2
  0005c	e5823134	 str         r3, [r2, #0x134]
  00060	e595215c	 ldr         r2, [r5, #0x15C]
  00064	e5923138	 ldr         r3, [r2, #0x138]
  00068	e3c33002	 bic         r3, r3, #2
  0006c	e5823138	 str         r3, [r2, #0x138]
  00070	e595315c	 ldr         r3, [r5, #0x15C]
  00074	e5831130	 str         r1, [r3, #0x130]
  00078	eb000000	 bl          LeaveCriticalSection

; 3930 : 
; 3931 :     SDIO_StartOutputDMA();

  0007c	e1a00005	 mov         r0, r5
  00080	eb000000	 bl          |?SDIO_StartOutputDMA@CSDIOControllerBase@@QAAXXZ|

; 3932 : 
; 3933 :     StallExecution(1);

  00084	e3a00001	 mov         r0, #1
  00088	eb000000	 bl          StallExecution

; 3934 : 
; 3935 :     // calculate timeout conditions
; 3936 :     dwCountStart = GetTickCount();

  0008c	eb000000	 bl          GetTickCount
  00090	e1a07000	 mov         r7, r0

; 3937 : 
; 3938 :     // wait for the SDIO/controller interrupt
; 3939 :     for(;;)
; 3940 :     {
; 3941 :         // check for a timeout
; 3942 :         if (GetTickCount() - dwCountStart > m_dwMaxTimeout)

  00094	ea00001e	 b           |$LN45@SDIDMATran|
  00098		 |$LL13@SDIDMATran|

; 3943 :         {
; 3944 :             DEBUGMSG(ZONE_ENABLE_ERROR, (TEXT("SDIDMATransmit() - exit: TIMEOUT.\n")));
; 3945 : #ifdef ENABLE_RETAIL_OUTPUT
; 3946 :             RETAILMSG(1, (TEXT("SDIDMATransmit() - exit: TIMEOUT.\n")));
; 3947 : #endif            
; 3948 :             goto cleanUp;
; 3949 :         }
; 3950 : 
; 3951 :             DWORD retries = 0;
; 3952 :             // polling end-of-command
; 3953 :             while (!(Read_MMC_STAT() & MMCHS_STAT_TC)) {

  00098	e3a06000	 mov         r6, #0
  0009c	ea000002	 b           |$LN47@SDIDMATran|
  000a0		 |$LL9@SDIDMATran|

; 3954 :                 if (retries > SDIO_MAX_LOOP) {

  000a0	e3560702	 cmp         r6, #2, 14
  000a4	8a000009	 bhi         |$LN37@SDIDMATran|

; 3956 :                     break;      
; 3957 :                 }
; 3958 :                 retries++;

  000a8	e2866001	 add         r6, r6, #1
  000ac		 |$LN47@SDIDMATran|

; 3954 :                 if (retries > SDIO_MAX_LOOP) {

  000ac	e28500b0	 add         r0, r5, #0xB0

; 3956 :                     break;      
; 3957 :                 }
; 3958 :                 retries++;

  000b0	eb000000	 bl          EnterCriticalSection
  000b4	e595315c	 ldr         r3, [r5, #0x15C]
  000b8	e28500b0	 add         r0, r5, #0xB0
  000bc	e5934130	 ldr         r4, [r3, #0x130]
  000c0	eb000000	 bl          LeaveCriticalSection
  000c4	e3140002	 tst         r4, #2
  000c8	0afffff4	 beq         |$LL9@SDIDMATran|

; 3983 :             goto cleanUp;
; 3984 :         }
; 3985 :         if( MMC_STAT & MMCHS_STAT_DCRC ) // DATA CRC Error

  000cc	ea000001	 b           |$LN23@SDIDMATran|
  000d0		 |$LN37@SDIDMATran|

; 3955 :                     RETAILMSG(1, (TEXT("A.S. Timeout while polling DMA Transmit complete.\n")));

  000d0	e59f00b0	 ldr         r0, [pc, #0xB0]
  000d4	eb000000	 bl          NKDbgPrintfW
  000d8		 |$LN23@SDIDMATran|

; 3959 :             }
; 3960 : 
; 3961 : 
; 3962 :         if(!m_fCardPresent)

  000d8	e59530f0	 ldr         r3, [r5, #0xF0]
  000dc	e3530000	 cmp         r3, #0
  000e0	0a000016	 beq         |$LN39@SDIDMATran|

; 3963 :         {
; 3964 : #ifdef ENABLE_RETAIL_OUTPUT
; 3965 :            RETAILMSG(1, (L"Card has been Removed stopping Output DMA\r\n"));
; 3966 : #endif
; 3967 :            break;
; 3968 :         }
; 3969 : 
; 3970 :         MMC_STAT = Read_MMC_STAT(); 

  000e4	e28500b0	 add         r0, r5, #0xB0
  000e8	eb000000	 bl          EnterCriticalSection
  000ec	e595315c	 ldr         r3, [r5, #0x15C]
  000f0	e28500b0	 add         r0, r5, #0xB0
  000f4	e5934130	 ldr         r4, [r3, #0x130]
  000f8	eb000000	 bl          LeaveCriticalSection

; 3971 :         if(MMC_STAT & MMCHS_STAT_TC)

  000fc	e3140002	 tst         r4, #2
  00100	1a00000e	 bne         |$LN39@SDIDMATran|

; 3972 :         {
; 3973 :             break;
; 3974 :         }
; 3975 :         if( MMC_STAT & MMCHS_STAT_DTO )

  00104	e3140601	 tst         r4, #1, 12
  00108	1a000009	 bne         |$LN41@SDIDMATran|

; 3983 :             goto cleanUp;
; 3984 :         }
; 3985 :         if( MMC_STAT & MMCHS_STAT_DCRC ) // DATA CRC Error

  0010c	e3140602	 tst         r4, #2, 12
  00110	1a000007	 bne         |$LN41@SDIDMATran|
  00114		 |$LN45@SDIDMATran|
  00114	eb000000	 bl          GetTickCount
  00118	e5952150	 ldr         r2, [r5, #0x150]
  0011c	e0403007	 sub         r3, r0, r7
  00120	e1530002	 cmp         r3, r2
  00124	9affffdb	 bls         |$LL13@SDIDMATran|

; 3986 :         {
; 3987 :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDIDMATransmit() - exit: STAT register indicates MMC_CRC_ERROR_RCVD error.\n")));
; 3988 : #ifdef ENABLE_RETAIL_OUTPUT
; 3989 :             RETAILMSG(1, (TEXT("SDIDMATransmit() - exit: STAT register indicates MMC_CRC_ERROR_RCVD error.\n")));
; 3990 : #endif
; 3991 :             // stop DMA
; 3992 :             SDIO_StopInputDMA();

  00128		 |$cleanUp$43597|

; 4003 : 
; 4004 : cleanUp:
; 4005 : #ifdef ENABLE_RETAIL_OUTPUT
; 4006 :     RETAILMSG(1, (L"CSDIOControllerBase::SDIDMATransmit(%08X, %08X)-\r\n", INREG32(&m_pbRegisters->MMCHS_STAT), INREG32(&m_pbRegisters->MMCHS_PSTATE)));
; 4007 : #endif
; 4008 :     return FALSE;

  00128	e3a00000	 mov         r0, #0

; 4009 : }

  0012c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00130	e12fff1e	 bx          lr
  00134		 |$LN41@SDIDMATran|

; 3976 :         {
; 3977 :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDIDMATransmit() - exit: STAT register indicates MMC_STAT_DTO error.\n")));
; 3978 : #ifdef ENABLE_RETAIL_OUTPUT
; 3979 :             RETAILMSG(1, (TEXT("SDIDMATransmit() - exit: STAT register indicates MMC_STAT_DTO error.\n")));
; 3980 : #endif            
; 3981 :             // stop DMA
; 3982 :             SDIO_StopInputDMA();

  00134	e1a00005	 mov         r0, r5
  00138	eb000000	 bl          |?SDIO_StopInputDMA@CSDIOControllerBase@@QAAXXZ|

; 4001 : 
; 4002 :     return TRUE;

  0013c	eafffff9	 b           |$cleanUp$43597|
  00140		 |$LN39@SDIDMATran|

; 3993 :             goto cleanUp;
; 3994 :         }
; 3995 :     }
; 3996 :     MMC_STAT = Read_MMC_STAT();

  00140	e28500b0	 add         r0, r5, #0xB0
  00144	eb000000	 bl          EnterCriticalSection
  00148	e595315c	 ldr         r3, [r5, #0x15C]
  0014c	e28500b0	 add         r0, r5, #0xB0
  00150	e5933130	 ldr         r3, [r3, #0x130]
  00154	eb000000	 bl          LeaveCriticalSection

; 3997 : 
; 3998 :     // stop DMA
; 3999 :     SDIO_StopOutputDMA();

  00158	e1a00005	 mov         r0, r5
  0015c	eb000000	 bl          |?SDIO_StopOutputDMA@CSDIOControllerBase@@QAAXXZ|

; 4000 :     Set_MMC_STAT(MMCHS_STAT_TC);

  00160	e28500b0	 add         r0, r5, #0xB0
  00164	eb000000	 bl          EnterCriticalSection
  00168	e595315c	 ldr         r3, [r5, #0x15C]
  0016c	e3a02002	 mov         r2, #2
  00170	e28500b0	 add         r0, r5, #0xB0
  00174	e5832130	 str         r2, [r3, #0x130]
  00178	eb000000	 bl          LeaveCriticalSection

; 4001 : 
; 4002 :     return TRUE;

  0017c	e3a00001	 mov         r0, #1

; 4009 : }

  00180	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00184	e12fff1e	 bx          lr
  00188		 |$LN51@SDIDMATran|
  00188		 |$LN52@SDIDMATran|
  00188	00000000	 DCD         |??_C@_1GG@GOJDNFHN@?$AAA?$AA?4?$AAS?$AA?4?$AA?5?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?5?$AAw?$AAh?$AAi?$AAl?$AAe?$AA?5?$AAp?$AAo?$AAl?$AAl?$AAi?$AAn?$AAg?$AA?5?$AAD?$AAM?$AAA?$AA?5?$AAT@|
  0018c		 |$M45436|

			 ENDP  ; |?SDIDMATransmit@CSDIOControllerBase@@QAAHPAEKH@Z|, CSDIOControllerBase::SDIDMATransmit

	EXPORT	|?SDIPollingReceive@CSDIOControllerBase@@QAAHPAEK@Z| ; CSDIOControllerBase::SDIPollingReceive

  00000			 AREA	 |.pdata|, PDATA
|$T45528| DCD	|$LN72@SDIPolling|
	DCD	0x4000a401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDIPollingReceive@CSDIOControllerBase@@QAAHPAEK@Z| PROC ; CSDIOControllerBase::SDIPollingReceive

; 4020 : {

  00000		 |$LN72@SDIPolling|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M45525|
  00004	e1a07002	 mov         r7, r2
  00008	e1a06001	 mov         r6, r1
  0000c	e1a05000	 mov         r5, r0

; 4021 :     DWORD fifoSizeW, blockLengthW; // Almost Full level and block length
; 4022 :     DWORD dwCount1, dwCount2;
; 4023 : 
; 4024 :     DWORD *pbuf = (DWORD *) pBuff;
; 4025 :     DWORD __unaligned *pbuf2 = (DWORD *) pBuff;
; 4026 : #ifdef ENABLE_RETAIL_OUTPUT
; 4027 :     UINT16 __unaligned *pbuf3 = (UINT16 *) pBuff;
; 4028 : #endif
; 4029 :     DWORD dwCountStart;
; 4030 : 
; 4031 :     DEBUGMSG(SHC_RECEIVE_ZONE, (TEXT("R(0x%x)\n"), dwLen));
; 4032 :     //check the parameters
; 4033 : 
; 4034 :     DWORD MMC_STAT = Read_MMC_STAT();

  00010	e28500b0	 add         r0, r5, #0xB0
  00014	eb000000	 bl          EnterCriticalSection
  00018	e595315c	 ldr         r3, [r5, #0x15C]
  0001c	e28500b0	 add         r0, r5, #0xB0
  00020	e5933130	 ldr         r3, [r3, #0x130]
  00024	eb000000	 bl          LeaveCriticalSection

; 4035 :     INREG32(&m_pbRegisters->MMCHS_PSTATE);

  00028	e595315c	 ldr         r3, [r5, #0x15C]
  0002c	e5933124	 ldr         r3, [r3, #0x124]

; 4036 : 
; 4037 :     // calculate timeout conditions
; 4038 :     dwCountStart = GetTickCount();

  00030	eb000000	 bl          GetTickCount
  00034	e3a03c01	 mov         r3, #1, 24

; 4039 : 
; 4040 : 
; 4041 :     if(dwLen % MMC_BLOCK_SIZE || m_dwSDIOCard)

  00038	e38330ff	 orr         r3, r3, #0xFF
  0003c	e1170003	 tst         r7, r3
  00040	e1a0a000	 mov         r10, r0
  00044	1a000033	 bne         |$LN57@SDIPolling|
  00048	e5953178	 ldr         r3, [r5, #0x178]
  0004c	e3530000	 cmp         r3, #0
  00050	1a000030	 bne         |$LN57@SDIPolling|

; 4060 :            }
; 4061 :     } else
; 4062 :     {
; 4063 :       fifoSizeW = INREG32(&m_pbRegisters->MMCHS_BLK) & 0xFFFF;

  00054	e595315c	 ldr         r3, [r5, #0x15C]
  00058	e3a02cff	 mov         r2, #0xFF, 24
  0005c	e38220ff	 orr         r2, r2, #0xFF
  00060	e5933104	 ldr         r3, [r3, #0x104]

; 4064 :       blockLengthW = dwLen / fifoSizeW;

  00064	e1a01007	 mov         r1, r7
  00068	e0038002	 and         r8, r3, r2
  0006c	e1a00008	 mov         r0, r8
  00070	eb000000	 bl          __rt_udiv
  00074	e1b09000	 movs        r9, r0

; 4065 :       for (dwCount1 = 0; dwCount1 < blockLengthW; dwCount1++)

  00078	e3a07000	 mov         r7, #0
  0007c	0a000046	 beq         |$LN18@SDIPolling|
  00080	e3a0b020	 mov         r11, #0x20

; 4066 :       {
; 4067 :         // Wait for Block ready for read
; 4068 :         while((Read_MMC_STAT() & MMCHS_STAT_BRR) != MMCHS_STAT_BRR)

  00084	ea000004	 b           |$LL16@SDIPolling|
  00088		 |$LL13@SDIPolling|

; 4069 :         {
; 4070 :           // check for a timeout
; 4071 :           if (GetTickCount() - dwCountStart > m_dwMaxTimeout)

  00088	eb000000	 bl          GetTickCount
  0008c	e5952150	 ldr         r2, [r5, #0x150]
  00090	e040300a	 sub         r3, r0, r10
  00094	e1530002	 cmp         r3, r2
  00098	8a000079	 bhi         |$READ_ERROR$43658|
  0009c		 |$LL16@SDIPolling|
  0009c	e28500b0	 add         r0, r5, #0xB0
  000a0	eb000000	 bl          EnterCriticalSection
  000a4	e595315c	 ldr         r3, [r5, #0x15C]
  000a8	e28500b0	 add         r0, r5, #0xB0
  000ac	e5934130	 ldr         r4, [r3, #0x130]
  000b0	eb000000	 bl          LeaveCriticalSection
  000b4	e2043020	 and         r3, r4, #0x20
  000b8	e3530020	 cmp         r3, #0x20
  000bc	1afffff1	 bne         |$LL13@SDIPolling|

; 4072 :           {
; 4073 :             DEBUGMSG(ZONE_ENABLE_ERROR, (TEXT("SDIPollingReceive() - exit: TIMEOUT.\n")));
; 4074 :             goto READ_ERROR;
; 4075 :           }
; 4076 :         }
; 4077 :         Set_MMC_STAT(MMCHS_STAT_BRR);

  000c0	e28500b0	 add         r0, r5, #0xB0
  000c4	eb000000	 bl          EnterCriticalSection
  000c8	e595315c	 ldr         r3, [r5, #0x15C]
  000cc	e28500b0	 add         r0, r5, #0xB0
  000d0	e583b130	 str         r11, [r3, #0x130]
  000d4	eb000000	 bl          LeaveCriticalSection

; 4078 : 
; 4079 :         // Get all data from DATA register and write in user buffer
; 4080 :         for (dwCount2 = 0; dwCount2 < (fifoSizeW / sizeof(DWORD)); dwCount2++)

  000d8	e1b02128	 movs        r2, r8, lsr #2
  000dc	0a000004	 beq         |$LN15@SDIPolling|
  000e0		 |$LL9@SDIPolling|

; 4081 :         {
; 4082 :             *pbuf = INREG32(&m_pbRegisters->MMCHS_DATA) ;

  000e0	e595315c	 ldr         r3, [r5, #0x15C]
  000e4	e2522001	 subs        r2, r2, #1
  000e8	e5933120	 ldr         r3, [r3, #0x120]
  000ec	e4863004	 str         r3, [r6], #4
  000f0	1afffffa	 bne         |$LL9@SDIPolling|
  000f4		 |$LN15@SDIPolling|

; 4065 :       for (dwCount1 = 0; dwCount1 < blockLengthW; dwCount1++)

  000f4	e2877001	 add         r7, r7, #1
  000f8	e1570009	 cmp         r7, r9
  000fc	3affffe6	 bcc         |$LL16@SDIPolling|

; 4091 :     {
; 4092 :         // check for a timeout
; 4093 :         if (GetTickCount() - dwCountStart > m_dwMaxTimeout)

  00100	ea000025	 b           |$LN18@SDIPolling|
  00104		 |$LL25@SDIPolling|

; 4042 :         {
; 4043 :           while ((Read_MMC_STAT() & MMCHS_STAT_BRR) != MMCHS_STAT_BRR)
; 4044 :           {
; 4045 :            // check for a timeout
; 4046 :             if (GetTickCount() - dwCountStart > m_dwMaxTimeout)

  00104	eb000000	 bl          GetTickCount
  00108	e5952150	 ldr         r2, [r5, #0x150]
  0010c	e040300a	 sub         r3, r0, r10
  00110	e1530002	 cmp         r3, r2
  00114	8a00005a	 bhi         |$READ_ERROR$43658|
  00118		 |$LN57@SDIPolling|
  00118	e28500b0	 add         r0, r5, #0xB0
  0011c	eb000000	 bl          EnterCriticalSection
  00120	e595315c	 ldr         r3, [r5, #0x15C]
  00124	e28500b0	 add         r0, r5, #0xB0
  00128	e5934130	 ldr         r4, [r3, #0x130]
  0012c	eb000000	 bl          LeaveCriticalSection
  00130	e2043020	 and         r3, r4, #0x20
  00134	e3530020	 cmp         r3, #0x20
  00138	1afffff1	 bne         |$LL25@SDIPolling|

; 4047 :             {
; 4048 :               DEBUGMSG(ZONE_ENABLE_ERROR, (TEXT("SDIPollingReceive() - exit: TIMEOUT.\n")));
; 4049 :               goto READ_ERROR;
; 4050 :             }
; 4051 :           }
; 4052 : 
; 4053 :            Set_MMC_STAT(MMCHS_STAT_BRR);

  0013c	e28500b0	 add         r0, r5, #0xB0
  00140	eb000000	 bl          EnterCriticalSection
  00144	e595315c	 ldr         r3, [r5, #0x15C]
  00148	e3a02020	 mov         r2, #0x20
  0014c	e28500b0	 add         r0, r5, #0xB0
  00150	e5832130	 str         r2, [r3, #0x130]
  00154	eb000000	 bl          LeaveCriticalSection

; 4054 :         fifoSizeW = dwLen / sizeof(DWORD);

  00158	e1a0e127	 mov         lr, r7, lsr #2

; 4055 :         if(dwLen % sizeof(DWORD)) fifoSizeW++;

  0015c	e3170003	 tst         r7, #3
  00160	128ee001	 addne       lr, lr, #1

; 4056 :            for (dwCount2 = 0; dwCount2 < fifoSizeW; dwCount2++)

  00164	e35e0000	 cmp         lr, #0
  00168	0a00000b	 beq         |$LN18@SDIPolling|
  0016c		 |$LL20@SDIPolling|

; 4057 :            {
; 4058 :                *pbuf2 = INREG32(&m_pbRegisters->MMCHS_DATA) ;

  0016c	e595315c	 ldr         r3, [r5, #0x15C]
  00170	e25ee001	 subs        lr, lr, #1
  00174	e5930120	 ldr         r0, [r3, #0x120]
  00178	e1a03420	 mov         r3, r0, lsr #8
  0017c	e1a02820	 mov         r2, r0, lsr #16
  00180	e1a01c20	 mov         r1, r0, lsr #24
  00184	e5c63001	 strb        r3, [r6, #1]
  00188	e5c62002	 strb        r2, [r6, #2]
  0018c	e5c61003	 strb        r1, [r6, #3]
  00190	e5c60000	 strb        r0, [r6]

; 4059 :                pbuf2++;

  00194	e2866004	 add         r6, r6, #4
  00198	1afffff3	 bne         |$LL20@SDIPolling|
  0019c		 |$LN18@SDIPolling|

; 4083 :             pbuf++;
; 4084 :         }
; 4085 :       }
; 4086 :     }
; 4087 :     // recalculate timeout conditions
; 4088 :     dwCountStart = GetTickCount();

  0019c	eb000000	 bl          GetTickCount
  001a0	e1a06000	 mov         r6, r0

; 4089 : 
; 4090 :     while (((Read_MMC_STAT()&MMCHS_STAT_TC) != MMCHS_STAT_TC))

  001a4	ea000004	 b           |$LN69@SDIPolling|
  001a8		 |$LL6@SDIPolling|

; 4091 :     {
; 4092 :         // check for a timeout
; 4093 :         if (GetTickCount() - dwCountStart > m_dwMaxTimeout)

  001a8	eb000000	 bl          GetTickCount
  001ac	e5952150	 ldr         r2, [r5, #0x150]
  001b0	e0403006	 sub         r3, r0, r6
  001b4	e1530002	 cmp         r3, r2
  001b8	8a000031	 bhi         |$READ_ERROR$43658|
  001bc		 |$LN69@SDIPolling|
  001bc	e28500b0	 add         r0, r5, #0xB0
  001c0	eb000000	 bl          EnterCriticalSection
  001c4	e595315c	 ldr         r3, [r5, #0x15C]
  001c8	e28500b0	 add         r0, r5, #0xB0
  001cc	e5934130	 ldr         r4, [r3, #0x130]
  001d0	eb000000	 bl          LeaveCriticalSection
  001d4	e2043002	 and         r3, r4, #2
  001d8	e3530002	 cmp         r3, #2
  001dc	1afffff1	 bne         |$LL6@SDIPolling|

; 4094 :         {
; 4095 :             DEBUGMSG(ZONE_ENABLE_ERROR, (TEXT("SDIPollingReceive() - exit: TIMEOUT.\n")));
; 4096 :             goto READ_ERROR;
; 4097 :         }
; 4098 :     }
; 4099 : 
; 4100 :     Set_MMC_STAT(MMCHS_STAT_TC);

  001e0	e28500b0	 add         r0, r5, #0xB0
  001e4	eb000000	 bl          EnterCriticalSection
  001e8	e595315c	 ldr         r3, [r5, #0x15C]
  001ec	e3a02002	 mov         r2, #2
  001f0	e28500b0	 add         r0, r5, #0xB0
  001f4	e5832130	 str         r2, [r3, #0x130]
  001f8	eb000000	 bl          LeaveCriticalSection

; 4101 :     // Check if there is no CRC error
; 4102 :     if (!(Read_MMC_STAT() & MMCHS_STAT_DCRC))

  001fc	e28500b0	 add         r0, r5, #0xB0
  00200	eb000000	 bl          EnterCriticalSection
  00204	e595315c	 ldr         r3, [r5, #0x15C]
  00208	e28500b0	 add         r0, r5, #0xB0
  0020c	e5934130	 ldr         r4, [r3, #0x130]
  00210	eb000000	 bl          LeaveCriticalSection
  00214	e3140602	 tst         r4, #2, 12

; 4103 :     {
; 4104 :         MMC_STAT = Read_MMC_STAT();

  00218	e28500b0	 add         r0, r5, #0xB0
  0021c	1a00000d	 bne         |$LN2@SDIPolling|
  00220	eb000000	 bl          EnterCriticalSection
  00224	e595315c	 ldr         r3, [r5, #0x15C]
  00228	e28500b0	 add         r0, r5, #0xB0
  0022c	e5934130	 ldr         r4, [r3, #0x130]
  00230	eb000000	 bl          LeaveCriticalSection

; 4105 :         Write_MMC_STAT(MMC_STAT);

  00234	e28500b0	 add         r0, r5, #0xB0
  00238	eb000000	 bl          EnterCriticalSection
  0023c	e595315c	 ldr         r3, [r5, #0x15C]
  00240	e28500b0	 add         r0, r5, #0xB0
  00244	e5834130	 str         r4, [r3, #0x130]
  00248	eb000000	 bl          LeaveCriticalSection

; 4106 :         return TRUE;

  0024c	e3a00001	 mov         r0, #1

; 4116 :     }
; 4117 : #ifdef ENABLE_RETAIL_OUTPUT
; 4118 :     if (dwLen == 2)
; 4119 :       RETAILMSG(1, (TEXT("SDIPollingReceive([%d: %04x])\n"), dwLen, pbuf3[0]));
; 4120 :     else
; 4121 :       RETAILMSG(1, (TEXT("SDIPollingReceive([%d: %08x,%08x])\n"), dwLen, pbuf2[0], pbuf2[1]));
; 4122 : #endif
; 4123 : 
; 4124 : READ_ERROR:
; 4125 : 
; 4126 : #ifdef ENABLE_RETAIL_OUTPUT
; 4127 :     RETAILMSG(1, (L"CSDIOControllerBase::SDIPollingReceive(BUSY:%08X)\r\n", INREG32(&m_pbRegisters->MMCHS_STAT)));
; 4128 : #endif
; 4129 :     return FALSE;
; 4130 : }

  00250	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00254	e12fff1e	 bx          lr
  00258		 |$LN2@SDIPolling|

; 4107 :     }
; 4108 :     else
; 4109 :     {
; 4110 : #ifdef ENABLE_RETAIL_OUTPUT
; 4111 :         RETAILMSG(1, (L"CSDIOControllerBase::SDIPollingReceive(ERROR:%08X)\r\n", INREG32(&m_pbRegisters->MMCHS_STAT)));
; 4112 : #endif
; 4113 :         MMC_STAT = Read_MMC_STAT();

  00258	eb000000	 bl          EnterCriticalSection
  0025c	e595315c	 ldr         r3, [r5, #0x15C]
  00260	e28500b0	 add         r0, r5, #0xB0
  00264	e5934130	 ldr         r4, [r3, #0x130]
  00268	eb000000	 bl          LeaveCriticalSection

; 4114 :         Write_MMC_STAT(MMC_STAT);

  0026c	e28500b0	 add         r0, r5, #0xB0
  00270	eb000000	 bl          EnterCriticalSection
  00274	e595315c	 ldr         r3, [r5, #0x15C]
  00278	e28500b0	 add         r0, r5, #0xB0
  0027c	e5834130	 str         r4, [r3, #0x130]
  00280	eb000000	 bl          LeaveCriticalSection
  00284		 |$READ_ERROR$43658|

; 4115 :         return FALSE;

  00284	e3a00000	 mov         r0, #0

; 4116 :     }
; 4117 : #ifdef ENABLE_RETAIL_OUTPUT
; 4118 :     if (dwLen == 2)
; 4119 :       RETAILMSG(1, (TEXT("SDIPollingReceive([%d: %04x])\n"), dwLen, pbuf3[0]));
; 4120 :     else
; 4121 :       RETAILMSG(1, (TEXT("SDIPollingReceive([%d: %08x,%08x])\n"), dwLen, pbuf2[0], pbuf2[1]));
; 4122 : #endif
; 4123 : 
; 4124 : READ_ERROR:
; 4125 : 
; 4126 : #ifdef ENABLE_RETAIL_OUTPUT
; 4127 :     RETAILMSG(1, (L"CSDIOControllerBase::SDIPollingReceive(BUSY:%08X)\r\n", INREG32(&m_pbRegisters->MMCHS_STAT)));
; 4128 : #endif
; 4129 :     return FALSE;
; 4130 : }

  00288	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0028c	e12fff1e	 bx          lr
  00290		 |$M45526|

			 ENDP  ; |?SDIPollingReceive@CSDIOControllerBase@@QAAHPAEK@Z|, CSDIOControllerBase::SDIPollingReceive

	EXPORT	|?SDIPollingTransmit@CSDIOControllerBase@@QAAHPAEK@Z| ; CSDIOControllerBase::SDIPollingTransmit

  00000			 AREA	 |.pdata|, PDATA
|$T45593| DCD	|$LN60@SDIPolling@2|
	DCD	0x40007d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDIPollingTransmit@CSDIOControllerBase@@QAAHPAEK@Z| PROC ; CSDIOControllerBase::SDIPollingTransmit

; 4134 : {

  00000		 |$LN60@SDIPolling@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M45590|
  00004	e1a06002	 mov         r6, r2
  00008	e1a07001	 mov         r7, r1
  0000c	e1a05000	 mov         r5, r0

; 4135 :     DWORD fifoSizeW, blockLengthW; // Almost Full level and block length
; 4136 :     DWORD dwCount1, dwCount2;
; 4137 :     DWORD *pbuf = (DWORD *) pBuff; // short* of buffer
; 4138 :     DWORD __unaligned *pbuf2 = (DWORD *) pBuff;
; 4139 : #ifdef ENABLE_RETAIL_OUTPUT
; 4140 :     UINT16 __unaligned *pbuf3 = (UINT16 *) pBuff;
; 4141 : #endif
; 4142 :     DWORD dwCountStart;
; 4143 : 
; 4144 : #ifdef ENABLE_RETAIL_OUTPUT
; 4145 :     if (dwLen == 2)
; 4146 :       RETAILMSG(1, (TEXT("SDIPollingTransmit([%d: %04x])\n"), dwLen, pbuf3[0]));
; 4147 :     else
; 4148 :       RETAILMSG(1, (TEXT("SDIPollingTransmit([%d: %08x,%08x])\n"), dwLen, pbuf2[0], pbuf2[1]));
; 4149 : #endif
; 4150 : 
; 4151 :     // calculate timeout conditions
; 4152 :     dwCountStart = GetTickCount();

  00010	eb000000	 bl          GetTickCount
  00014	e3a03c01	 mov         r3, #1, 24

; 4153 : 
; 4154 :     if(dwLen % MMC_BLOCK_SIZE || m_dwSDIOCard)

  00018	e38330ff	 orr         r3, r3, #0xFF
  0001c	e1160003	 tst         r6, r3
  00020	e1a08000	 mov         r8, r0
  00024	1a000033	 bne         |$LN45@SDIPolling@2|
  00028	e5953178	 ldr         r3, [r5, #0x178]
  0002c	e3530000	 cmp         r3, #0
  00030	1a000030	 bne         |$LN45@SDIPolling@2|

; 4171 :           }
; 4172 :     } else
; 4173 :     {
; 4174 :       fifoSizeW = INREG32(&m_pbRegisters->MMCHS_BLK) & 0xFFFF;

  00034	e595315c	 ldr         r3, [r5, #0x15C]
  00038	e3a02cff	 mov         r2, #0xFF, 24
  0003c	e382e0ff	 orr         lr, r2, #0xFF
  00040	e5933104	 ldr         r3, [r3, #0x104]

; 4175 :       blockLengthW = dwLen / fifoSizeW;

  00044	e1a01006	 mov         r1, r6
  00048	e003a00e	 and         r10, r3, lr
  0004c	e1a0000a	 mov         r0, r10
  00050	eb000000	 bl          __rt_udiv
  00054	e1b09000	 movs        r9, r0

; 4176 :       for (dwCount1 = 0; dwCount1 < blockLengthW; dwCount1++)

  00058	e3a06000	 mov         r6, #0
  0005c	0a000046	 beq         |$LN18@SDIPolling@2|
  00060	e3a0b010	 mov         r11, #0x10

; 4177 :       {
; 4178 :         // poll on write ready here
; 4179 :         while((Read_MMC_STAT() & MMCHS_STAT_BWR) != MMCHS_STAT_BWR)

  00064	ea000004	 b           |$LL16@SDIPolling@2|
  00068		 |$LL13@SDIPolling@2|

; 4180 :         {
; 4181 :           if (GetTickCount() - dwCountStart > m_dwMaxTimeout)

  00068	eb000000	 bl          GetTickCount
  0006c	e5952150	 ldr         r2, [r5, #0x150]
  00070	e0403008	 sub         r3, r0, r8
  00074	e1530002	 cmp         r3, r2
  00078	8a00005a	 bhi         |$LN2@SDIPolling@2|

; 4176 :       for (dwCount1 = 0; dwCount1 < blockLengthW; dwCount1++)

  0007c		 |$LL16@SDIPolling@2|

; 4180 :         {
; 4181 :           if (GetTickCount() - dwCountStart > m_dwMaxTimeout)

  0007c	e28500b0	 add         r0, r5, #0xB0
  00080	eb000000	 bl          EnterCriticalSection
  00084	e595315c	 ldr         r3, [r5, #0x15C]
  00088	e28500b0	 add         r0, r5, #0xB0
  0008c	e5934130	 ldr         r4, [r3, #0x130]
  00090	eb000000	 bl          LeaveCriticalSection
  00094	e2043010	 and         r3, r4, #0x10
  00098	e3530010	 cmp         r3, #0x10
  0009c	1afffff1	 bne         |$LL13@SDIPolling@2|

; 4182 :           {
; 4183 :             DEBUGMSG(ZONE_ENABLE_ERROR, (TEXT("SDIPollingTransmit() - exit: TIMEOUT.\n")));
; 4184 :             goto WRITE_ERROR;
; 4185 :           }
; 4186 :         }
; 4187 :         Set_MMC_STAT(MMCHS_STAT_BWR);

  000a0	e28500b0	 add         r0, r5, #0xB0
  000a4	eb000000	 bl          EnterCriticalSection
  000a8	e595315c	 ldr         r3, [r5, #0x15C]
  000ac	e28500b0	 add         r0, r5, #0xB0
  000b0	e583b130	 str         r11, [r3, #0x130]
  000b4	eb000000	 bl          LeaveCriticalSection

; 4188 : 
; 4189 :         for (dwCount2 = 0; dwCount2 < (fifoSizeW /sizeof(DWORD)); dwCount2++) // write data to DATA buffer

  000b8	e1b0112a	 movs        r1, r10, lsr #2
  000bc	0a000004	 beq         |$LN15@SDIPolling@2|
  000c0		 |$LL9@SDIPolling@2|

; 4190 :         {
; 4191 :           OUTREG32(&m_pbRegisters->MMCHS_DATA, *pbuf++);

  000c0	e4973004	 ldr         r3, [r7], #4
  000c4	e595215c	 ldr         r2, [r5, #0x15C]
  000c8	e2511001	 subs        r1, r1, #1
  000cc	e5823120	 str         r3, [r2, #0x120]
  000d0	1afffffa	 bne         |$LL9@SDIPolling@2|
  000d4		 |$LN15@SDIPolling@2|

; 4176 :       for (dwCount1 = 0; dwCount1 < blockLengthW; dwCount1++)

  000d4	e2866001	 add         r6, r6, #1
  000d8	e1560009	 cmp         r6, r9
  000dc	3affffe6	 bcc         |$LL16@SDIPolling@2|

; 4200 :     {
; 4201 :         // check for a timeout
; 4202 :         if (GetTickCount() - dwCountStart > m_dwMaxTimeout)

  000e0	ea000025	 b           |$LN18@SDIPolling@2|
  000e4		 |$LL25@SDIPolling@2|

; 4155 :         {
; 4156 :           while((Read_MMC_STAT() & MMCHS_STAT_BWR) != MMCHS_STAT_BWR)
; 4157 :           {
; 4158 :             if (GetTickCount() - dwCountStart > m_dwMaxTimeout)

  000e4	eb000000	 bl          GetTickCount
  000e8	e5952150	 ldr         r2, [r5, #0x150]
  000ec	e0403008	 sub         r3, r0, r8
  000f0	e1530002	 cmp         r3, r2
  000f4	8a00003b	 bhi         |$LN2@SDIPolling@2|
  000f8		 |$LN45@SDIPolling@2|
  000f8	e28500b0	 add         r0, r5, #0xB0
  000fc	eb000000	 bl          EnterCriticalSection
  00100	e595315c	 ldr         r3, [r5, #0x15C]
  00104	e28500b0	 add         r0, r5, #0xB0
  00108	e5934130	 ldr         r4, [r3, #0x130]
  0010c	eb000000	 bl          LeaveCriticalSection
  00110	e2043010	 and         r3, r4, #0x10
  00114	e3530010	 cmp         r3, #0x10
  00118	1afffff1	 bne         |$LL25@SDIPolling@2|

; 4159 :             {
; 4160 :             DEBUGMSG(ZONE_ENABLE_ERROR, (TEXT("SDIPollingTransmit() - exit: TIMEOUT.\n")));
; 4161 :               goto WRITE_ERROR;
; 4162 :             }
; 4163 :           }
; 4164 :           Set_MMC_STAT(MMCHS_STAT_BWR);

  0011c	e28500b0	 add         r0, r5, #0xB0
  00120	eb000000	 bl          EnterCriticalSection
  00124	e595315c	 ldr         r3, [r5, #0x15C]
  00128	e3a02010	 mov         r2, #0x10
  0012c	e28500b0	 add         r0, r5, #0xB0
  00130	e5832130	 str         r2, [r3, #0x130]
  00134	eb000000	 bl          LeaveCriticalSection

; 4165 : 
; 4166 :         fifoSizeW = dwLen / sizeof(DWORD);

  00138	e1a0e126	 mov         lr, r6, lsr #2

; 4167 :         if(dwLen % sizeof(DWORD)) fifoSizeW++;

  0013c	e3160003	 tst         r6, #3
  00140	128ee001	 addne       lr, lr, #1

; 4168 :           for (dwCount1 = 0; dwCount1 < fifoSizeW; dwCount1++)

  00144	e35e0000	 cmp         lr, #0
  00148	0a00000b	 beq         |$LN18@SDIPolling@2|
  0014c		 |$LL20@SDIPolling@2|

; 4169 :           {
; 4170 :               OUTREG32(&m_pbRegisters->MMCHS_DATA, *pbuf2++) ;

  0014c	e5d72000	 ldrb        r2, [r7]
  00150	e5d73001	 ldrb        r3, [r7, #1]
  00154	e5d71002	 ldrb        r1, [r7, #2]
  00158	e5d70003	 ldrb        r0, [r7, #3]
  0015c	e1823403	 orr         r3, r2, r3, lsl #8
  00160	e595215c	 ldr         r2, [r5, #0x15C]
  00164	e1833801	 orr         r3, r3, r1, lsl #16
  00168	e1833c00	 orr         r3, r3, r0, lsl #24
  0016c	e5823120	 str         r3, [r2, #0x120]
  00170	e2877004	 add         r7, r7, #4
  00174	e25ee001	 subs        lr, lr, #1
  00178	1afffff3	 bne         |$LL20@SDIPolling@2|
  0017c		 |$LN18@SDIPolling@2|

; 4192 :         }
; 4193 :       }
; 4194 :     }
; 4195 : 
; 4196 :     // recalculate timeout conditions
; 4197 :     dwCountStart = GetTickCount();

  0017c	eb000000	 bl          GetTickCount

; 4198 : 
; 4199 :     while (((Read_MMC_STAT()&MMCHS_STAT_TC) != MMCHS_STAT_TC))

  00180	e1a06000	 mov         r6, r0
  00184	ea000004	 b           |$LN57@SDIPolling@2|
  00188		 |$LL6@SDIPolling@2|

; 4200 :     {
; 4201 :         // check for a timeout
; 4202 :         if (GetTickCount() - dwCountStart > m_dwMaxTimeout)

  00188	eb000000	 bl          GetTickCount
  0018c	e5952150	 ldr         r2, [r5, #0x150]
  00190	e0403006	 sub         r3, r0, r6
  00194	e1530002	 cmp         r3, r2
  00198	8a000012	 bhi         |$LN2@SDIPolling@2|
  0019c		 |$LN57@SDIPolling@2|
  0019c	e28500b0	 add         r0, r5, #0xB0
  001a0	eb000000	 bl          EnterCriticalSection
  001a4	e595315c	 ldr         r3, [r5, #0x15C]
  001a8	e28500b0	 add         r0, r5, #0xB0
  001ac	e5934130	 ldr         r4, [r3, #0x130]
  001b0	eb000000	 bl          LeaveCriticalSection
  001b4	e2043002	 and         r3, r4, #2
  001b8	e3530002	 cmp         r3, #2
  001bc	1afffff1	 bne         |$LL6@SDIPolling@2|

; 4203 :         {
; 4204 :             DEBUGMSG(ZONE_ENABLE_ERROR, (TEXT("SDIPollingTransmit() - exit: TIMEOUT.\n")));
; 4205 :             goto WRITE_ERROR;
; 4206 :         }
; 4207 :     }
; 4208 : 
; 4209 :     // Check if there is no CRC error
; 4210 :     if (!(Read_MMC_STAT() & MMCHS_STAT_DCRC))

  001c0	e28500b0	 add         r0, r5, #0xB0
  001c4	eb000000	 bl          EnterCriticalSection
  001c8	e595315c	 ldr         r3, [r5, #0x15C]
  001cc	e28500b0	 add         r0, r5, #0xB0
  001d0	e5934130	 ldr         r4, [r3, #0x130]
  001d4	eb000000	 bl          LeaveCriticalSection
  001d8	e3140602	 tst         r4, #2, 12

; 4211 :     {
; 4212 :         return TRUE;

  001dc	03a00001	 moveq       r0, #1

; 4220 :     }
; 4221 : 
; 4222 : WRITE_ERROR:
; 4223 : #ifdef ENABLE_RETAIL_OUTPUT
; 4224 :     RETAILMSG(1, (L"CSDIOControllerBase::SDIPollingTransmit(BUSY:%08X)\r\n", INREG32(&m_pbRegisters->MMCHS_STAT)));
; 4225 : #endif
; 4226 :     return FALSE;
; 4227 : }

  001e0	08bd4ff0	 ldmeqia     sp!, {r4 - r11, lr}
  001e4	012fff1e	 bxeq        lr
  001e8		 |$LN2@SDIPolling@2|
  001e8		 |$WRITE_ERROR$43712|

; 4213 :     }
; 4214 :     else
; 4215 :     {
; 4216 : #ifdef ENABLE_RETAIL_OUTPUT
; 4217 :         RETAILMSG(1, (L"CSDIOControllerBase::SDIPollingTransmit(ERROR:%08X)\r\n", INREG32(&m_pbRegisters->MMCHS_STAT)));
; 4218 : #endif
; 4219 :         return FALSE;

  001e8	e3a00000	 mov         r0, #0

; 4220 :     }
; 4221 : 
; 4222 : WRITE_ERROR:
; 4223 : #ifdef ENABLE_RETAIL_OUTPUT
; 4224 :     RETAILMSG(1, (L"CSDIOControllerBase::SDIPollingTransmit(BUSY:%08X)\r\n", INREG32(&m_pbRegisters->MMCHS_STAT)));
; 4225 : #endif
; 4226 :     return FALSE;
; 4227 : }

  001ec	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001f0	e12fff1e	 bx          lr
  001f4		 |$M45591|

			 ENDP  ; |?SDIPollingTransmit@CSDIOControllerBase@@QAAHPAEK@Z|, CSDIOControllerBase::SDIPollingTransmit

	EXPORT	|?SystemClockOn@CSDIOControllerBase@@QAAXH@Z| ; CSDIOControllerBase::SystemClockOn
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\inc\sdhc.h

  00000			 AREA	 |.pdata|, PDATA
|$T45602| DCD	|$LN5@SystemCloc|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SystemClockOn@CSDIOControllerBase@@QAAXH@Z| PROC ; CSDIOControllerBase::SystemClockOn

; 194  :     VOID SystemClockOn(BOOL bInPowerHandler) {

  00000		 |$LN5@SystemCloc|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45599|

; 195  :         m_InternPowerState = D0;

  00004	e3a03000	 mov         r3, #0
  00008	e58030dc	 str         r3, [r0, #0xDC]

; 196  :         UpdateDevicePowerState(bInPowerHandler);

  0000c	eb000000	 bl          |?UpdateDevicePowerState@CSDIOControllerBase@@QAAXH@Z|

; 197  :     }

  00010	e49de004	 ldr         lr, [sp], #4
  00014	e12fff1e	 bx          lr
  00018		 |$M45600|

			 ENDP  ; |?SystemClockOn@CSDIOControllerBase@@QAAXH@Z|, CSDIOControllerBase::SystemClockOn

	EXPORT	|?SDHCPowerTimerThreadImpl@CSDIOControllerBase@@QAAKXZ| ; CSDIOControllerBase::SDHCPowerTimerThreadImpl
	IMPORT	|WaitForSingleObject|
	IMPORT	|CeSetThreadPriority|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T45628| DCD	|$LN29@SDHCPowerT|
	DCD	0x40003f01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\sdhc\base\sdhc.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCPowerTimerThreadImpl@CSDIOControllerBase@@QAAKXZ| PROC ; CSDIOControllerBase::SDHCPowerTimerThreadImpl

; 684  : {

  00000		 |$LN29@SDHCPowerT|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M45625|
  00004	e1a04000	 mov         r4, r0

; 685  :     DWORD nTimeout = INFINITE;
; 686  :     RETAILMSG(0, (TEXT("*** start SDHCPowerTimerThreadImpl()\r\n")));
; 687  : 
; 688  :     CeSetThreadPriority(GetCurrentThread(), TIMERTHREAD_PRIORITY);

  00008	e3a010fc	 mov         r1, #0xFC
  0000c	e3a00041	 mov         r0, #0x41
  00010	eb000000	 bl          CeSetThreadPriority

; 689  : 
; 690  :     for(;;)
; 691  :     {
; 692  :         WaitForSingleObject(m_hTimerEvent, nTimeout);

  00014	e59401a8	 ldr         r0, [r4, #0x1A8]
  00018	e3e01000	 mvn         r1, #0
  0001c	eb000000	 bl          WaitForSingleObject

; 693  : 
; 694  :         if (m_bExitThread == TRUE) 

  00020	e59431a4	 ldr         r3, [r4, #0x1A4]
  00024	e3530001	 cmp         r3, #1
  00028	0a000030	 beq         |$LN25@SDHCPowerT|
  0002c	e3a06001	 mov         r6, #1
  00030	e3a07fc2	 mov         r7, #0xC2, 30
  00034		 |$LL12@SDHCPowerT|

; 695  : 		    break;
; 696  : 
; 697  :         // serialize access to power state changes
; 698  :         EnterCriticalSection(&m_critSec);

  00034	e28400b0	 add         r0, r4, #0xB0
  00038	eb000000	 bl          EnterCriticalSection

; 699  : 
; 700  :         // by the time this thread got the cs hTimerEvent may
; 701  :         // have gotten resignaled.  Clear the event to  make
; 702  :         // sure the activity timer thread isn't awaken prematurely
; 703  :         //
; 704  :         ResetEvent(m_hTimerEvent);

  0003c	e59401a8	 ldr         r0, [r4, #0x1A8]
  00040	e3a01002	 mov         r1, #2
  00044	eb000000	 bl          EventModify

; 705  : 
; 706  :         // check if we need to reset the timer
; 707  :         if (m_dwClockCnt == 0)

  00048	e59431a0	 ldr         r3, [r4, #0x1A0]
  0004c	e3530000	 cmp         r3, #0
  00050	1a00001d	 bne         |$LN9@SDHCPowerT|

; 708  :         {
; 709  :             // We disable the clocks only when this thread
; 710  :             // wakes-up twice in a row with no power state
; 711  :             // change to D0.  This is achieved by using the
; 712  :             // bDisablePower flag to determine if power state
; 713  :             // changed since the last time this thread woke-up
; 714  :             //
; 715  :             if ((m_bDisablePower == TRUE) || (m_fCardPresent == FALSE))

  00054	e59431cc	 ldr         r3, [r4, #0x1CC]
  00058	e3530001	 cmp         r3, #1
  0005c	0a00000c	 beq         |$LN7@SDHCPowerT|
  00060	e59430f0	 ldr         r3, [r4, #0xF0]
  00064	e3530000	 cmp         r3, #0
  00068	0a000009	 beq         |$LN7@SDHCPowerT|

; 736  :                  }
; 737  :                 nTimeout = INFINITE;
; 738  :             }
; 739  :             else
; 740  :             {
; 741  :                 // wait for activity time-out before shutting off power.
; 742  :                 m_bDisablePower = TRUE;
; 743  :                 nTimeout = (m_fCardInitialized && !m_dwSDIOCard) ? m_nNonSDIOActivityTimeout : m_nSDIOActivityTimeout;

  0006c	e594313c	 ldr         r3, [r4, #0x13C]
  00070	e58461cc	 str         r6, [r4, #0x1CC]
  00074	e3530000	 cmp         r3, #0
  00078	0a000003	 beq         |$LN17@SDHCPowerT|
  0007c	e5943178	 ldr         r3, [r4, #0x178]
  00080	e3530000	 cmp         r3, #0
  00084	059451b0	 ldreq       r5, [r4, #0x1B0]
  00088	0a000010	 beq         |$LN1@SDHCPowerT|
  0008c		 |$LN17@SDHCPowerT|
  0008c	e59451b4	 ldr         r5, [r4, #0x1B4]
  00090	ea00000e	 b           |$LN1@SDHCPowerT|
  00094		 |$LN7@SDHCPowerT|

; 716  :             {
; 717  :                 if (m_ActualPowerState < D3)

  00094	e59430e0	 ldr         r3, [r4, #0xE0]
  00098	e3530003	 cmp         r3, #3
  0009c	aa00000a	 bge         |$LN9@SDHCPowerT|

; 718  :                 {
; 719  :                     // update clock control
; 720  :                     if (!m_dwSDClockMode || !m_fCardPresent /*|| !(m_dwWakeupSources & WAKEUP_SDIO)*/)

  000a0	e594319c	 ldr         r3, [r4, #0x19C]

; 721  : 					{
; 722  :                         OUTREG32(&m_pbRegisters->MMCHS_SYSCONFIG, 
; 723  :                             MMCHS_SYSCONFIG_CLOCKACTIVITY(0) | 
; 724  :                             MMCHS_SYSCONFIG_SIDLEMODE(SIDLE_FORCE) |
; 725  :                             MMCHS_SYSCONFIG_AUTOIDLE 
; 726  :                             );
; 727  :                     }
; 728  : 					else
; 729  : 					{
; 730  :     	                OUTREG32(&m_pbRegisters->MMCHS_SYSCONFIG, 
; 731  : 	    				    MMCHS_SYSCONFIG_SIDLEMODE(SIDLE_IGNORE) | 
; 732  : 		    				MMCHS_SYSCONFIG_CLOCKACTIVITY(3)
; 733  : 			    			);
; 734  :                     }
; 735  :                     UpdateDevicePowerState(FALSE);

  000a4	e3a01000	 mov         r1, #0
  000a8	e1a00004	 mov         r0, r4
  000ac	e3530000	 cmp         r3, #0
  000b0	159430f0	 ldrne       r3, [r4, #0xF0]
  000b4	13530000	 cmpne       r3, #0
  000b8	1594315c	 ldrne       r3, [r4, #0x15C]
  000bc	15837010	 strne       r7, [r3, #0x10]
  000c0	0594315c	 ldreq       r3, [r4, #0x15C]
  000c4	05836010	 streq       r6, [r3, #0x10]
  000c8	eb000000	 bl          |?UpdateDevicePowerState@CSDIOControllerBase@@QAAXH@Z|
  000cc		 |$LN9@SDHCPowerT|

; 744  :             }
; 745  :         }
; 746  :         else
; 747  :         {
; 748  :             nTimeout = INFINITE;

  000cc	e3e05000	 mvn         r5, #0
  000d0		 |$LN1@SDHCPowerT|

; 749  :         }
; 750  :         LeaveCriticalSection(&m_critSec);

  000d0	e28400b0	 add         r0, r4, #0xB0
  000d4	eb000000	 bl          LeaveCriticalSection
  000d8	e59401a8	 ldr         r0, [r4, #0x1A8]
  000dc	e1a01005	 mov         r1, r5
  000e0	eb000000	 bl          WaitForSingleObject
  000e4	e59431a4	 ldr         r3, [r4, #0x1A4]
  000e8	e3530001	 cmp         r3, #1
  000ec	1affffd0	 bne         |$LL12@SDHCPowerT|
  000f0		 |$LN25@SDHCPowerT|

; 751  :     }
; 752  : 
; 753  :     return 1;

  000f0	e3a00001	 mov         r0, #1

; 754  : }

  000f4	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000f8	e12fff1e	 bx          lr
  000fc		 |$M45626|

			 ENDP  ; |?SDHCPowerTimerThreadImpl@CSDIOControllerBase@@QAAKXZ|, CSDIOControllerBase::SDHCPowerTimerThreadImpl

	EXPORT	|?UpdateSystemClock@CSDIOControllerBase@@QAAHH@Z| ; CSDIOControllerBase::UpdateSystemClock
	IMPORT	|InterlockedDecrement|
	IMPORT	|InterlockedIncrement|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T45647| DCD	|$LN22@UpdateSyst|
	DCD	0x40003801
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\sdhc\base\sdhc.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdateSystemClock@CSDIOControllerBase@@QAAHH@Z| PROC ; CSDIOControllerBase::UpdateSystemClock

; 765  : {

  00000		 |$LN22@UpdateSyst|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45644|
  00004	e3510000	 cmp         r1, #0
  00008	e1a05000	 mov         r5, r0

; 766  :     LONG   lClockCount;
; 767  : 
; 768  :     DEBUGMSG(SDCARD_ZONE_FUNC, (L"+UpdateSystemClock()\r\n"));
; 769  : 
; 770  :     if (enable)
; 771  :     {
; 772  :         lClockCount = InterlockedIncrement(&m_dwClockCnt);

  0000c	e2850e1a	 add         r0, r5, #0x1A, 28
  00010	0a000017	 beq         |$LN13@UpdateSyst|
  00014	eb000000	 bl          InterlockedIncrement

; 773  : 
; 774  :         EnterCriticalSection( &m_critSec );

  00018	e1a04000	 mov         r4, r0
  0001c	e28500b0	 add         r0, r5, #0xB0
  00020	eb000000	 bl          EnterCriticalSection

; 775  :         m_InternPowerState = D0;

  00024	e3a06000	 mov         r6, #0
  00028	e58560dc	 str         r6, [r5, #0xDC]

; 776  :         if(lClockCount == 1)

  0002c	e3540001	 cmp         r4, #1
  00030	1a00000b	 bne         |$LN9@UpdateSyst|

; 777  :         {
; 778  :             if (m_ActualPowerState >= D3)

  00034	e59530e0	 ldr         r3, [r5, #0xE0]
  00038	e3530003	 cmp         r3, #3
  0003c	ba000008	 blt         |$LN9@UpdateSyst|

; 779  :             {
; 780  :                 UpdateDevicePowerState(FALSE);

  00040	e3a01000	 mov         r1, #0
  00044	e1a00005	 mov         r0, r5
  00048	eb000000	 bl          |?UpdateDevicePowerState@CSDIOControllerBase@@QAAXH@Z|

; 781  :                 
; 782  :                 if (m_dwSDClockMode)

  0004c	e595319c	 ldr         r3, [r5, #0x19C]
  00050	e3530000	 cmp         r3, #0

; 783  : 				{
; 784  :                     OUTREG32(&m_pbRegisters->MMCHS_SYSCONFIG, 
; 785  :                         MMCHS_SYSCONFIG_SIDLEMODE(SIDLE_IGNORE) | 
; 786  :                         MMCHS_SYSCONFIG_CLOCKACTIVITY(3)
; 787  :                         );

  00054	e595315c	 ldr         r3, [r5, #0x15C]
  00058	13a02fc2	 movne       r2, #0xC2, 30

; 788  :                 }
; 789  : 				else
; 790  : 				{
; 791  :                     // update clock control
; 792  :                     OUTREG32(&m_pbRegisters->MMCHS_SYSCONFIG, 
; 793  :                         MMCHS_SYSCONFIG_CLOCKACTIVITY(0) | 
; 794  :                         MMCHS_SYSCONFIG_SIDLEMODE(SIDLE_SMART) |
; 795  :                         MMCHS_SYSCONFIG_ENAWAKEUP |
; 796  :                         MMCHS_SYSCONFIG_AUTOIDLE 
; 797  :                         );

  0005c	03a02015	 moveq       r2, #0x15
  00060	e5832010	 str         r2, [r3, #0x10]
  00064		 |$LN9@UpdateSyst|

; 798  :                 }
; 799  :             }
; 800  :         }
; 801  :         m_bDisablePower = FALSE;
; 802  :         LeaveCriticalSection( &m_critSec );

  00064	e28500b0	 add         r0, r5, #0xB0
  00068	e58561cc	 str         r6, [r5, #0x1CC]
  0006c	eb000000	 bl          LeaveCriticalSection

; 803  :     }
; 804  :     else

  00070	ea000017	 b           |$LN4@UpdateSyst|
  00074		 |$LN13@UpdateSyst|

; 805  :     {
; 806  :         lClockCount = InterlockedDecrement(&m_dwClockCnt);

  00074	eb000000	 bl          InterlockedDecrement
  00078	e3500000	 cmp         r0, #0

; 807  :         if(lClockCount < 0)

  0007c	5a000002	 bpl         |$LN19@UpdateSyst|

; 808  :             m_dwClockCnt = 0;

  00080	e3a03000	 mov         r3, #0
  00084	e58531a0	 str         r3, [r5, #0x1A0]

; 809  : 
; 810  :         if(lClockCount <= 0)

  00088	e3500000	 cmp         r0, #0
  0008c		 |$LN19@UpdateSyst|
  0008c	ca000010	 bgt         |$LN4@UpdateSyst|

; 811  :         {
; 812  :             m_InternPowerState = D4;
; 813  :             if (m_hTimerEvent != NULL)

  00090	e59531a8	 ldr         r3, [r5, #0x1A8]
  00094	e3a02004	 mov         r2, #4
  00098	e58520dc	 str         r2, [r5, #0xDC]
  0009c	e3530000	 cmp         r3, #0
  000a0	0a000003	 beq         |$LN5@UpdateSyst|

; 814  :             {
; 815  :                 SetEvent(m_hTimerEvent);

  000a4	e3a01003	 mov         r1, #3
  000a8	e1a00003	 mov         r0, r3
  000ac	eb000000	 bl          EventModify

; 816  :             }
; 817  :             else

  000b0	ea000007	 b           |$LN4@UpdateSyst|
  000b4		 |$LN5@UpdateSyst|

; 818  :             {
; 819  :                 if (m_ActualPowerState < D3)

  000b4	e59530e0	 ldr         r3, [r5, #0xE0]

; 820  :                 {
; 821  :                     // update clock control
; 822  :                     if (!m_dwSDClockMode || m_InternPowerState == D4)
; 823  : 		    		{
; 824  :                         OUTREG32(&m_pbRegisters->MMCHS_SYSCONFIG, 
; 825  :                             MMCHS_SYSCONFIG_AUTOIDLE | 
; 826  :                             MMCHS_SYSCONFIG_CLOCKACTIVITY(0) | 
; 827  :                             MMCHS_SYSCONFIG_SIDLEMODE(SIDLE_FORCE)
; 828  :                             );
; 829  : 					}
; 830  :                 }
; 831  :                 UpdateDevicePowerState(FALSE);

  000b8	e3a01000	 mov         r1, #0
  000bc	e1a00005	 mov         r0, r5
  000c0	e3530003	 cmp         r3, #3
  000c4	b595315c	 ldrlt       r3, [r5, #0x15C]
  000c8	b3a02001	 movlt       r2, #1
  000cc	b5832010	 strlt       r2, [r3, #0x10]
  000d0	eb000000	 bl          |?UpdateDevicePowerState@CSDIOControllerBase@@QAAXH@Z|
  000d4		 |$LN4@UpdateSyst|

; 832  :             }
; 833  :         }
; 834  :     }
; 835  : 
; 836  :     return TRUE;

  000d4	e3a00001	 mov         r0, #1

; 837  : }

  000d8	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000dc	e12fff1e	 bx          lr
  000e0		 |$M45645|

			 ENDP  ; |?UpdateSystemClock@CSDIOControllerBase@@QAAHH@Z|, CSDIOControllerBase::UpdateSystemClock

	EXPORT	|?HandleRemoval@CSDIOControllerBase@@QAAXH@Z| ; CSDIOControllerBase::HandleRemoval
	IMPORT	|SDHCDGetAndLockCurrentRequest|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T45669| DCD	|$LN20@HandleRemo|
	DCD	0x40004601
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\sdhc\base\sdhc.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HandleRemoval@CSDIOControllerBase@@QAAXH@Z| PROC ; CSDIOControllerBase::HandleRemoval

; 1126 : {

  00000		 |$LN20@HandleRemo|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45666|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 1127 :     PSD_BUS_REQUEST pRequest = NULL;
; 1128 : 
; 1129 :     m_fCardPresent = FALSE;
; 1130 :     m_fMMCMode = FALSE;
; 1131 : 
; 1132 :     DEBUGMSG(SDCARD_ZONE_INIT, (TEXT("HandleRemoval\r\n")));
; 1133 : 
; 1134 :     TurnCardPowerOn();  // try to turn slot power on

  0000c	e5943000	 ldr         r3, [r4]
  00010	e3a06000	 mov         r6, #0
  00014	e58460f0	 str         r6, [r4, #0xF0]
  00018	e5933014	 ldr         r3, [r3, #0x14]
  0001c	e58460f8	 str         r6, [r4, #0xF8]
  00020	e1a0e00f	 mov         lr, pc
  00024	e12fff13	 bx          r3

; 1135 : 
; 1136 :     IndicateSlotStateChange(DeviceEjected);

  00028	e59400a8	 ldr         r0, [r4, #0xA8]
  0002c	e3a02001	 mov         r2, #1
  00030	e3a01000	 mov         r1, #0
  00034	eb000000	 bl          SDHCDIndicateSlotStateChange

; 1137 :     SystemClockOn(FALSE);

  00038	e3a01000	 mov         r1, #0
  0003c	e1a00004	 mov         r0, r4
  00040	e58460dc	 str         r6, [r4, #0xDC]
  00044	eb000000	 bl          |?UpdateDevicePowerState@CSDIOControllerBase@@QAAXH@Z|

; 1138 : 
; 1139 :     // turn off SDIO interrupts
; 1140 :     if( m_fSDIOInterruptsEnabled )

  00048	e59430f4	 ldr         r3, [r4, #0xF4]
  0004c	e3530000	 cmp         r3, #0

; 1141 :         {
; 1142 :     DisableSDIOInterrupts();

  00050	11a00004	 movne       r0, r4
  00054	1b000000	 blne        |?DisableSDIOInterrupts@CSDIOControllerBase@@QAAXXZ|

; 1143 :         }
; 1144 : 
; 1145 :     if (fCancelRequest)

  00058	e3550000	 cmp         r5, #0
  0005c	0a000006	 beq         |$LN5@HandleRemo|

; 1146 :     {
; 1147 :         // get the current request
; 1148 :         pRequest = GetAndLockCurrentRequest();

  00060	e59400a8	 ldr         r0, [r4, #0xA8]
  00064	e3a01000	 mov         r1, #0
  00068	eb000000	 bl          SDHCDGetAndLockCurrentRequest
  0006c	e1b01000	 movs        r1, r0

; 1149 : 
; 1150 :         if (pRequest != NULL)
; 1151 :         {
; 1152 :             DEBUGMSG(SDCARD_ZONE_WARN,
; 1153 :                 (TEXT("Card Removal Detected - Canceling current request: 0x%08X, command: %d\r\n"),
; 1154 :                 pRequest, pRequest->CommandCode));
; 1155 :             DumpRequest(pRequest);
; 1156 :             IndicateBusRequestComplete(pRequest, SD_API_STATUS_DEVICE_REMOVED);

  00070	159400a8	 ldrne       r0, [r4, #0xA8]
  00074	13a02147	 movne       r2, #0x47, 2
  00078	1b000000	 blne        SDHCDIndicateBusRequestComplete
  0007c		 |$LN5@HandleRemo|

; 1157 :         }
; 1158 :     }
; 1159 :     
; 1160 :     if(m_ActualPowerState == D4) return;

  0007c	e59430e0	 ldr         r3, [r4, #0xE0]
  00080	e3530004	 cmp         r3, #4
  00084	0a000021	 beq         |$LN8@HandleRemo|

; 1161 :     SoftwareReset(SOFT_RESET_ALL);

  00088	e3a01401	 mov         r1, #1, 8
  0008c	e1a00004	 mov         r0, r4
  00090	eb000000	 bl          |?SoftwareReset@CSDIOControllerBase@@QAAXK@Z|

; 1162 :     DisableSDHCInterrupts();

  00094	e1a00004	 mov         r0, r4
  00098	eb000000	 bl          |?DisableSDHCInterrupts@CSDIOControllerBase@@QAAXXZ|

; 1163 : 
; 1164 :     if (m_dwSDClockMode)

  0009c	e594319c	 ldr         r3, [r4, #0x19C]

; 1165 :     {
; 1166 :     // turn clock off and remove power from the slot
; 1167 :     OUTREG32(&m_pbRegisters->MMCHS_SYSCONFIG, MMCHS_SYSCONFIG_AUTOIDLE | MMCHS_SYSCONFIG_SIDLEMODE(SIDLE_FORCE));
; 1168 :     }
; 1169 :     
; 1170 :     ResetEvent(m_hControllerISTEvent);

  000a0	e3a01002	 mov         r1, #2
  000a4	e3530000	 cmp         r3, #0
  000a8	1594315c	 ldrne       r3, [r4, #0x15C]
  000ac	13a02001	 movne       r2, #1
  000b0	15832010	 strne       r2, [r3, #0x10]
  000b4	e5940118	 ldr         r0, [r4, #0x118]
  000b8	eb000000	 bl          EventModify

; 1171 :     Sleep(100);

  000bc	e3a00064	 mov         r0, #0x64
  000c0	eb000000	 bl          Sleep

; 1172 : 
; 1173 :     m_fCardInitialized = FALSE;
; 1174 : 
; 1175 :     CLRREG32(&m_pbRegisters->MMCHS_CON, MMCHS_CON_CLKEXTFREE);

  000c4	e594215c	 ldr         r2, [r4, #0x15C]
  000c8	e584613c	 str         r6, [r4, #0x13C]
  000cc	e592302c	 ldr         r3, [r2, #0x2C]

; 1176 : 
; 1177 : #if 0
; 1178 :     // get and lock the current bus request
; 1179 :     while(SDHCDGetAndLockCurrentRequest(m_pHCContext, 0) != NULL)
; 1180 :     {
; 1181 :         CommandCompleteHandler();
; 1182 :     }
; 1183 : #else
; 1184 :     // get and lock the current bus request
; 1185 :     while((pRequest = SDHCDGetAndLockCurrentRequest(m_pHCContext, 0)) != NULL)

  000d0	e3c33801	 bic         r3, r3, #1, 16
  000d4	e582302c	 str         r3, [r2, #0x2C]
  000d8	ea000002	 b           |$LN17@HandleRemo|
  000dc		 |$LL2@HandleRemo|

; 1186 :     {
; 1187 :         IndicateBusRequestComplete(pRequest, SD_API_STATUS_DEVICE_REMOVED);

  000dc	e59400a8	 ldr         r0, [r4, #0xA8]
  000e0	e3a02147	 mov         r2, #0x47, 2
  000e4	eb000000	 bl          SDHCDIndicateBusRequestComplete
  000e8		 |$LN17@HandleRemo|
  000e8	e59400a8	 ldr         r0, [r4, #0xA8]
  000ec	e3a01000	 mov         r1, #0
  000f0	eb000000	 bl          SDHCDGetAndLockCurrentRequest
  000f4	e1b01000	 movs        r1, r0
  000f8	1afffff7	 bne         |$LL2@HandleRemo|

; 1188 :     }
; 1189 : #endif
; 1190 : 
; 1191 :     TurnCardPowerOff();  // try to turn slot power off

  000fc	e5943000	 ldr         r3, [r4]
  00100	e1a00004	 mov         r0, r4
  00104	e5933018	 ldr         r3, [r3, #0x18]
  00108	e1a0e00f	 mov         lr, pc
  0010c	e12fff13	 bx          r3
  00110		 |$LN8@HandleRemo|

; 1192 : }

  00110	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00114	e12fff1e	 bx          lr
  00118		 |$M45667|

			 ENDP  ; |?HandleRemoval@CSDIOControllerBase@@QAAXH@Z|, CSDIOControllerBase::HandleRemoval

	EXPORT	|?Init@CSDIOControllerBase@@QAAHPBG@Z|	; CSDIOControllerBase::Init
	EXPORT	|??_C@_1HK@NAJMOFNG@?$AAS?$AAD?$AAH?$AAC?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?3?$AA?3?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAn@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GE@HPCKCMKC@?$AAS?$AAD?$AAH?$AAC?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?3?$AA?3?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAo?$AAp?$AAe?$AAn?$AAi?$AAn?$AAg?$AA?5?$AAt@| [ DATA ] ; `string'
	EXPORT	|??_C@_1KA@CLLCPJCJ@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FC@JCPNFEIG@?$AAS?$AAD?$AAH?$AAC?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?3?$AA?3?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAi?$AAn@| [ DATA ] ; `string'
	EXPORT	|??_C@_1JA@BHKFNOIC@?$AAS?$AAD?$AAH?$AAC?$AA?5?$AAh?$AAo?$AAs?$AAt?$AA?5?$AAc?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAl?$AAe?$AAr?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?3@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DE@PNOEBOJA@?$AAS?$AAD?$AAH?$AAC?$AA?3?$AA?5?$AAC?$AAP?$AAU?$AA?5?$AAr?$AAe?$AAv?$AAi?$AAs?$AAi?$AAo?$AAn?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|CreateThread|
	IMPORT	|SDHCDRegisterHostController|
	IMPORT	|MmMapIoSpace|
	IMPORT	|GetAddressByDevice|
	IMPORT	|GPIOOpen|
	IMPORT	|BSPGetSDHCCardDetect|
	IMPORT	|RequestDevicePads|
	IMPORT	|SOCGetSDHCDeviceBySlot|
	IMPORT	|GetDeviceRegistryParams|
	IMPORT	|SDHCDAllocateContext|
	IMPORT	|CreateBusAccessHandle|
	IMPORT	|KernelIoControl|
	IMPORT	|CalibrateStallCounter|
; File c:\wince600\public\common\sdk\inc\creg.hxx

  00000			 AREA	 |.pdata|, PDATA
|$T45717| DCD	|$LN55@Init|
	DCD	0x4000c502

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HK@NAJMOFNG@?$AAS?$AAD?$AAH?$AAC?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?3?$AA?3?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAn@| DCB "S"
	DCB	0x0, "D", 0x0, "H", 0x0, "C", 0x0, "I", 0x0, "n", 0x0, "i"
	DCB	0x0, "t", 0x0, "i", 0x0, "a", 0x0, "l", 0x0, "i", 0x0, "z"
	DCB	0x0, "e", 0x0, ":", 0x0, ":", 0x0, " ", 0x0, "E", 0x0, "r"
	DCB	0x0, "r", 0x0, "o", 0x0, "r", 0x0, " ", 0x0, "a", 0x0, "l"
	DCB	0x0, "l", 0x0, "o", 0x0, "c", 0x0, "a", 0x0, "t", 0x0, "i"
	DCB	0x0, "n", 0x0, "g", 0x0, " ", 0x0, "S", 0x0, "D", 0x0, "H"
	DCB	0x0, "C", 0x0, " ", 0x0, "c", 0x0, "o", 0x0, "n", 0x0, "t"
	DCB	0x0, "r", 0x0, "o", 0x0, "l", 0x0, "l", 0x0, "e", 0x0, "r"
	DCB	0x0, " ", 0x0, "r", 0x0, "e", 0x0, "g", 0x0, "i", 0x0, "s"
	DCB	0x0, "t", 0x0, "e", 0x0, "r", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GE@HPCKCMKC@?$AAS?$AAD?$AAH?$AAC?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?3?$AA?3?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAo?$AAp?$AAe?$AAn?$AAi?$AAn?$AAg?$AA?5?$AAt@| DCB "S"
	DCB	0x0, "D", 0x0, "H", 0x0, "C", 0x0, "I", 0x0, "n", 0x0, "i"
	DCB	0x0, "t", 0x0, "i", 0x0, "a", 0x0, "l", 0x0, "i", 0x0, "z"
	DCB	0x0, "e", 0x0, ":", 0x0, ":", 0x0, " ", 0x0, "E", 0x0, "r"
	DCB	0x0, "r", 0x0, "o", 0x0, "r", 0x0, " ", 0x0, "o", 0x0, "p"
	DCB	0x0, "e", 0x0, "n", 0x0, "i", 0x0, "n", 0x0, "g", 0x0, " "
	DCB	0x0, "t", 0x0, "h", 0x0, "e", 0x0, " ", 0x0, "G", 0x0, "P"
	DCB	0x0, "I", 0x0, "O", 0x0, " ", 0x0, "d", 0x0, "r", 0x0, "i"
	DCB	0x0, "v", 0x0, "e", 0x0, "r", 0x0, "!", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1KA@CLLCPJCJ@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| DCB "C"
	DCB	0x0, ":", 0x0, "\\", 0x0, "W", 0x0, "I", 0x0, "N", 0x0, "C"
	DCB	0x0, "E", 0x0, "6", 0x0, "0", 0x0, "0", 0x0, "\\", 0x0, "P"
	DCB	0x0, "L", 0x0, "A", 0x0, "T", 0x0, "F", 0x0, "O", 0x0, "R"
	DCB	0x0, "M", 0x0, "\\", 0x0, "C", 0x0, "O", 0x0, "M", 0x0, "M"
	DCB	0x0, "O", 0x0, "N", 0x0, "\\", 0x0, "S", 0x0, "R", 0x0, "C"
	DCB	0x0, "\\", 0x0, "S", 0x0, "O", 0x0, "C", 0x0, "\\", 0x0, "C"
	DCB	0x0, "O", 0x0, "M", 0x0, "M", 0x0, "O", 0x0, "N", 0x0, "_"
	DCB	0x0, "T", 0x0, "I", 0x0, "_", 0x0, "V", 0x0, "1", 0x0, "\\"
	DCB	0x0, "C", 0x0, "O", 0x0, "M", 0x0, "M", 0x0, "O", 0x0, "N"
	DCB	0x0, "_", 0x0, "T", 0x0, "I", 0x0, "\\", 0x0, "S", 0x0, "D"
	DCB	0x0, "H", 0x0, "C", 0x0, "\\", 0x0, "B", 0x0, "A", 0x0, "S"
	DCB	0x0, "E", 0x0, "\\", 0x0, ".", 0x0, "\\", 0x0, "s", 0x0, "d"
	DCB	0x0, "h", 0x0, "c", 0x0, ".", 0x0, "c", 0x0, "p", 0x0, "p"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "%", 0x0, "s", 0x0, " ", 0x0, "l", 0x0, "i", 0x0, "n"
	DCB	0x0, "e", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ":", 0x0, " "
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FC@JCPNFEIG@?$AAS?$AAD?$AAH?$AAC?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?3?$AA?3?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAi?$AAn@| DCB "S"
	DCB	0x0, "D", 0x0, "H", 0x0, "C", 0x0, "I", 0x0, "n", 0x0, "i"
	DCB	0x0, "t", 0x0, "i", 0x0, "a", 0x0, "l", 0x0, "i", 0x0, "z"
	DCB	0x0, "e", 0x0, ":", 0x0, ":", 0x0, " ", 0x0, "E", 0x0, "r"
	DCB	0x0, "r", 0x0, "o", 0x0, "r", 0x0, " ", 0x0, "r", 0x0, "e"
	DCB	0x0, "q", 0x0, "u", 0x0, "e", 0x0, "s", 0x0, "t", 0x0, "i"
	DCB	0x0, "n", 0x0, "g", 0x0, " ", 0x0, "p", 0x0, "a", 0x0, "d"
	DCB	0x0, "s", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1JA@BHKFNOIC@?$AAS?$AAD?$AAH?$AAC?$AA?5?$AAh?$AAo?$AAs?$AAt?$AA?5?$AAc?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAl?$AAe?$AAr?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?3@| DCB "S"
	DCB	0x0, "D", 0x0, "H", 0x0, "C", 0x0, " ", 0x0, "h", 0x0, "o"
	DCB	0x0, "s", 0x0, "t", 0x0, " ", 0x0, "c", 0x0, "o", 0x0, "n"
	DCB	0x0, "t", 0x0, "r", 0x0, "o", 0x0, "l", 0x0, "l", 0x0, "e"
	DCB	0x0, "r", 0x0, " ", 0x0, "i", 0x0, "n", 0x0, "i", 0x0, "t"
	DCB	0x0, "i", 0x0, "a", 0x0, "l", 0x0, "i", 0x0, "z", 0x0, "e"
	DCB	0x0, ":", 0x0, " ", 0x0, "m", 0x0, "_", 0x0, "f", 0x0, "a"
	DCB	0x0, "s", 0x0, "t", 0x0, "P", 0x0, "a", 0x0, "t", 0x0, "h"
	DCB	0x0, "S", 0x0, "D", 0x0, "I", 0x0, "O", 0x0, ":", 0x0, "%"
	DCB	0x0, "d", 0x0, " ", 0x0, "m", 0x0, "_", 0x0, "f", 0x0, "a"
	DCB	0x0, "s", 0x0, "t", 0x0, "P", 0x0, "a", 0x0, "t", 0x0, "h"
	DCB	0x0, "S", 0x0, "D", 0x0, "M", 0x0, "E", 0x0, "M", 0x0, ":"
	DCB	0x0, "%", 0x0, "d", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DE@PNOEBOJA@?$AAS?$AAD?$AAH?$AAC?$AA?3?$AA?5?$AAC?$AAP?$AAU?$AA?5?$AAr?$AAe?$AAv?$AAi?$AAs?$AAi?$AAo?$AAn?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "S"
	DCB	0x0, "D", 0x0, "H", 0x0, "C", 0x0, ":", 0x0, " ", 0x0, "C"
	DCB	0x0, "P", 0x0, "U", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "v"
	DCB	0x0, "i", 0x0, "s", 0x0, "i", 0x0, "o", 0x0, "n", 0x0, " "
	DCB	0x0, "0", 0x0, "x", 0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\sdhc\base\sdhc.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Init@CSDIOControllerBase@@QAAHPBG@Z| PROC ; CSDIOControllerBase::Init

; 1243 : {

  00000		 |$LN55@Init|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M45714|
  00008	e1a05001	 mov         r5, r1
  0000c	e1a04000	 mov         r4, r0

; 1244 :     SD_API_STATUS      status;              // SD status
; 1245 :     CReg               regDevice;           // encapsulated device key
; 1246 :     DWORD              dwRet = 0;           // return value

  00010	e3a06000	 mov         r6, #0

; 1247 : 
; 1248 :     PHYSICAL_ADDRESS PortAddress;
; 1249 : 
; 1250 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"SDHC +Init\r\n"));
; 1251 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"SDHC Active RegPath: %s \r\n",pszActiveKey));
; 1252 : 
; 1253 :     CalibrateStallCounter();

  00014	eb000000	 bl          CalibrateStallCounter

; 1254 : 
; 1255 :     m_dwCPURev = (DWORD)CPU_REVISION_UNKNOWN;

  00018	e3e02000	 mvn         r2, #0

; 1256 :     KernelIoControl(IOCTL_HAL_GET_CPUREVISION, NULL, 0, &m_dwCPURev, sizeof(m_dwCPURev), NULL);

  0001c	e1a03004	 mov         r3, r4
  00020	e59f02e8	 ldr         r0, [pc, #0x2E8]
  00024	e5a3217c	 str         r2, [r3, #0x17C]!
  00028	e3a0e004	 mov         lr, #4
  0002c	e3a07000	 mov         r7, #0
  00030	e3a02000	 mov         r2, #0
  00034	e3a01000	 mov         r1, #0
  00038	e58d7004	 str         r7, [sp, #4]
  0003c	e58de000	 str         lr, [sp]
  00040	eb000000	 bl          KernelIoControl

; 1257 :     RETAILMSG(1, (L"SDHC: CPU revision 0x%x\r\n", m_dwCPURev));

  00044	e594117c	 ldr         r1, [r4, #0x17C]
  00048	e59f02bc	 ldr         r0, [pc, #0x2BC]
  0004c	eb000000	 bl          NKDbgPrintfW

; 1258 : 
; 1259 :     // open the parent bus driver handle
; 1260 :     m_hParentBus = CreateBusAccessHandle(pszActiveKey);

  00050	e1a00005	 mov         r0, r5
  00054	eb000000	 bl          CreateBusAccessHandle
  00058	e3500000	 cmp         r0, #0
  0005c	e58400ac	 str         r0, [r4, #0xAC]

; 1261 :     if ( m_hParentBus == NULL )

  00060	0a000038	 beq         |$LN51@Init|

; 1262 :     {
; 1263 :         DEBUGMSG(SDCARD_ZONE_ERROR, 
; 1264 :             (L"SDHC: Failed to obtain parent bus handle\r\n")
; 1265 :             );
; 1266 :         goto cleanUp;
; 1267 :     }
; 1268 : 
; 1269 :     // allocate the context - we only support one slot
; 1270 :     status = SDHCDAllocateContext(1, &m_pHCContext);

  00064	e28410a8	 add         r1, r4, #0xA8
  00068	e3a00001	 mov         r0, #1
  0006c	eb000000	 bl          SDHCDAllocateContext
  00070	e3500000	 cmp         r0, #0

; 1271 :     if (!SD_API_SUCCESS(status))

  00074	4a000033	 bmi         |$LN51@Init|

; 1272 :     {
; 1273 :         DEBUGMSG(SDCARD_ZONE_ERROR, (L"SDHC Failed to allocate context: 0x%08X \r\n", status));
; 1274 :         goto cleanUp;
; 1275 :     }
; 1276 : 
; 1277 :     // Set our extension
; 1278 :     m_pHCContext->pHCSpecificContext = this;

  00078	e59410a8	 ldr         r1, [r4, #0xA8]

; 1279 :     if (GetDeviceRegistryParams(pszActiveKey, this, dimof(s_deviceRegParams), 
; 1280 :         s_deviceRegParams) != ERROR_SUCCESS)

  0007c	e59f3284	 ldr         r3, [pc, #0x284]
  00080	e3a02016	 mov         r2, #0x16
  00084	e581404c	 str         r4, [r1, #0x4C]
  00088	e1a01004	 mov         r1, r4
  0008c	e1a00005	 mov         r0, r5
  00090	eb000000	 bl          GetDeviceRegistryParams
  00094	e3500000	 cmp         r0, #0
  00098	1a00002a	 bne         |$LN51@Init|

; 1281 :     {
; 1282 :         DEBUGMSG(SDCARD_ZONE_ERROR, (L"ERROR: CSDIOControllerBase:Init: "
; 1283 :             L"Failed read SDHC driver registry parameters\r\n"
; 1284 :             ));
; 1285 :         goto cleanUp;
; 1286 :     }
; 1287 : 
; 1288 :     // get the Command and Data timeouts
; 1289 :     m_dwCurrentWakeupSources = m_dwWakeupSources & (~WAKEUP_SDIO);

  0009c	e59430e8	 ldr         r3, [r4, #0xE8]

; 1290 :     m_wCTOTimeout = min(m_wCTOTimeout, MMC_CTO_CONTROL_MAX);

  000a0	e5942140	 ldr         r2, [r4, #0x140]

; 1291 :     m_wDTOTimeout = min(m_wDTOTimeout, MMC_DTO_CONTROL_MAX);

  000a4	e5941144	 ldr         r1, [r4, #0x144]
  000a8	e3c33001	 bic         r3, r3, #1
  000ac	e58430ec	 str         r3, [r4, #0xEC]
  000b0	e3a03cff	 mov         r3, #0xFF, 24
  000b4	e35200fd	 cmp         r2, #0xFD
  000b8	e38330fd	 orr         r3, r3, #0xFD
  000bc	23a020fd	 movcs       r2, #0xFD
  000c0	e1510003	 cmp         r1, r3
  000c4	21a01003	 movcs       r1, r3

; 1292 :     m_dwMaxClockRate = m_dwMaxClockRate == 0 ? STD_HC_MAX_CLOCK_FREQUENCY : 
; 1293 :                                                min(m_dwMaxClockRate, STD_HC_MAX_CLOCK_FREQUENCY);

  000c8	e5943148	 ldr         r3, [r4, #0x148]
  000cc	e5842140	 str         r2, [r4, #0x140]
  000d0	e5841144	 str         r1, [r4, #0x144]
  000d4	e1b02003	 movs        r2, r3
  000d8	e3a037b7	 mov         r3, #0xB7, 14
  000dc	03832b1b	 orreq       r2, r3, #0x1B, 22
  000e0	0a000002	 beq         |$LN32@Init|
  000e4	e3833b1b	 orr         r3, r3, #0x1B, 22
  000e8	e1520003	 cmp         r2, r3
  000ec	21a02003	 movcs       r2, r3
  000f0		 |$LN32@Init|

; 1294 : 
; 1295 : 
; 1296 :     RETAILMSG(SDCARD_ZONE_INFO, 
; 1297 :         (L"SDHC host controller initialize: m_fastPathSDIO:%d m_fastPathSDMEM:%d\r\n",
; 1298 :         m_fastPathSDIO, m_fastPathSDMEM)
; 1299 :         );

  000f0	e59f320c	 ldr         r3, [pc, #0x20C]
  000f4	e5842148	 str         r2, [r4, #0x148]
  000f8	e5933440	 ldr         r3, [r3, #0x440]
  000fc	e3130a01	 tst         r3, #1, 20
  00100	15942184	 ldrne       r2, [r4, #0x184]
  00104	15941180	 ldrne       r1, [r4, #0x180]
  00108	159f01f0	 ldrne       r0, [pc, #0x1F0]
  0010c	1b000000	 blne        NKDbgPrintfW

; 1300 :     
; 1301 : 	m_dwDeviceID = SOCGetSDHCDeviceBySlot(m_dwSlot);

  00110	e5940170	 ldr         r0, [r4, #0x170]
  00114	eb000000	 bl          SOCGetSDHCDeviceBySlot
  00118	e1a03000	 mov         r3, r0

; 1302 : 
; 1303 :     if (!RequestDevicePads(m_dwDeviceID))

  0011c	e5843174	 str         r3, [r4, #0x174]
  00120	eb000000	 bl          RequestDevicePads
  00124	e3500000	 cmp         r0, #0
  00128	1a000010	 bne         |$LN16@Init|

; 1304 : 	{
; 1305 : 	    ERRORMSG(1, (_T("SDHCInitialize:: Error requesting pads\r\n")));

  0012c	e59f11c0	 ldr         r1, [pc, #0x1C0]
  00130	e59f01b8	 ldr         r0, [pc, #0x1B8]
  00134	e3a03c05	 mov         r3, #5, 24
  00138	e3832019	 orr         r2, r3, #0x19
  0013c	eb000000	 bl          NKDbgPrintfW
  00140	e59f01b4	 ldr         r0, [pc, #0x1B4]
  00144		 |$LN52@Init|
  00144	eb000000	 bl          NKDbgPrintfW
  00148		 |$LN51@Init|

; 1377 : 
; 1378 : cleanUp:
; 1379 :     if ( (dwRet == 0) && m_pHCContext )

  00148	e59430a8	 ldr         r3, [r4, #0xA8]
  0014c	e3530000	 cmp         r3, #0

; 1380 :     {
; 1381 :         FreeHostContext(FALSE, TRUE);

  00150	13a02001	 movne       r2, #1
  00154	13a01000	 movne       r1, #0
  00158	11a00004	 movne       r0, r4
  0015c	1b000000	 blne        |?FreeHostContext@CSDIOControllerBase@@QAAXHH@Z|
  00160		 |$LN1@Init|

; 1382 :     }
; 1383 : 
; 1384 :     DEBUGMSG(SDCARD_ZONE_INIT, (TEXT("SDHC -Init\r\n")));
; 1385 :     return dwRet;
; 1386 : }

  00160	e1a00006	 mov         r0, r6
  00164	e28dd008	 add         sp, sp, #8
  00168	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0016c	e12fff1e	 bx          lr
  00170		 |$LN16@Init|

; 1306 :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;
; 1307 :         goto cleanUp;
; 1308 : 	}
; 1309 : 
; 1310 :     if (m_dwCardDetectGPIO == -1)

  00170	e59431e4	 ldr         r3, [r4, #0x1E4]
  00174	e3730001	 cmn         r3, #1
  00178	1a000002	 bne         |$LN14@Init|

; 1311 :     {
; 1312 :         m_dwCardDetectGPIO = BSPGetSDHCCardDetect(m_dwSlot);

  0017c	e5940170	 ldr         r0, [r4, #0x170]
  00180	eb000000	 bl          BSPGetSDHCCardDetect
  00184	e58401e4	 str         r0, [r4, #0x1E4]
  00188		 |$LN14@Init|

; 1313 :     }
; 1314 : 
; 1315 :     // Open the GPIO driver
; 1316 :     m_hGPIO = GPIOOpen();

  00188	eb000000	 bl          GPIOOpen
  0018c	e3500000	 cmp         r0, #0
  00190	e5840164	 str         r0, [r4, #0x164]

; 1317 :     if( m_hGPIO == NULL )

  00194	1a000006	 bne         |$LN13@Init|

; 1318 :     {
; 1319 :         ERRORMSG(1, (_T("SDHCInitialize:: Error opening the GPIO driver!\r\n")));

  00198	e59f1154	 ldr         r1, [pc, #0x154]
  0019c	e59f014c	 ldr         r0, [pc, #0x14C]
  001a0	e3a03c05	 mov         r3, #5, 24
  001a4	e3832027	 orr         r2, r3, #0x27
  001a8	eb000000	 bl          NKDbgPrintfW
  001ac	e59f0144	 ldr         r0, [pc, #0x144]

; 1320 :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;
; 1321 :         goto cleanUp;

  001b0	eaffffe3	 b           |$LN52@Init|
  001b4		 |$LN13@Init|

; 1322 :     }
; 1323 : 
; 1324 :     // map hardware memory space
; 1325 :     PortAddress.QuadPart = GetAddressByDevice(m_dwDeviceID);

  001b4	e5940174	 ldr         r0, [r4, #0x174]
  001b8	eb000000	 bl          GetAddressByDevice

; 1326 :     m_pbRegisters = (OMAP_MMCHS_REGS *)MmMapIoSpace(PortAddress, sizeof(OMAP_MMCHS_REGS), FALSE );

  001bc	e3a01000	 mov         r1, #0
  001c0	e3a03000	 mov         r3, #0
  001c4	e3a02c02	 mov         r2, #2, 24
  001c8	eb000000	 bl          MmMapIoSpace
  001cc	e3500000	 cmp         r0, #0
  001d0	e584015c	 str         r0, [r4, #0x15C]

; 1327 :     if ( !m_pbRegisters )

  001d4	1a000006	 bne         |$LN11@Init|

; 1328 :     {
; 1329 :         ERRORMSG(1, (_T("SDHCInitialize:: Error allocating SDHC controller register\r\n")));

  001d8	e59f1114	 ldr         r1, [pc, #0x114]
  001dc	e59f010c	 ldr         r0, [pc, #0x10C]
  001e0	e3a03c05	 mov         r3, #5, 24
  001e4	e3832031	 orr         r2, r3, #0x31
  001e8	eb000000	 bl          NKDbgPrintfW
  001ec	e59f00f8	 ldr         r0, [pc, #0xF8]

; 1330 :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;
; 1331 :         goto cleanUp;

  001f0	eaffffd3	 b           |$LN52@Init|
  001f4		 |$LN11@Init|

; 1332 :     }
; 1333 : 
; 1334 :     // turn power and system clocks on
; 1335 :     TurnCardPowerOn();

  001f4	e5943000	 ldr         r3, [r4]
  001f8	e1a00004	 mov         r0, r4
  001fc	e5933014	 ldr         r3, [r3, #0x14]
  00200	e1a0e00f	 mov         lr, pc
  00204	e12fff13	 bx          r3

; 1336 :     if( !InitializeHardware() )

  00208	e5943000	 ldr         r3, [r4]
  0020c	e1a00004	 mov         r0, r4
  00210	e5933000	 ldr         r3, [r3]
  00214	e1a0e00f	 mov         lr, pc
  00218	e12fff13	 bx          r3
  0021c	e3500000	 cmp         r0, #0
  00220	1a000005	 bne         |$LN9@Init|

; 1337 :     {
; 1338 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("InitializeHardware:: Error configuring SDHC hardware\r\n")));
; 1339 :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;
; 1340 :         TurnCardPowerOff();

  00224	e5943000	 ldr         r3, [r4]
  00228	e1a00004	 mov         r0, r4
  0022c	e5933018	 ldr         r3, [r3, #0x18]
  00230	e1a0e00f	 mov         lr, pc
  00234	e12fff13	 bx          r3

; 1341 :         goto cleanUp;

  00238	eaffffc2	 b           |$LN51@Init|
  0023c		 |$LN9@Init|

; 1342 :     }
; 1343 : 
; 1344 : 	// Perform SOC-specific configuration
; 1345 : 	SocSdhcDevconf(m_dwSlot);

  0023c	e5940170	 ldr         r0, [r4, #0x170]
  00240	eb000000	 bl          SocSdhcDevconf

; 1346 : 
; 1347 :     // Read SD Host Controller Info from register.
; 1348 :     if (!InterpretCapabilities())

  00244	e5943000	 ldr         r3, [r4]
  00248	e1a00004	 mov         r0, r4
  0024c	e5933024	 ldr         r3, [r3, #0x24]
  00250	e1a0e00f	 mov         lr, pc
  00254	e12fff13	 bx          r3
  00258	e3500000	 cmp         r0, #0
  0025c	1a000005	 bne         |$LN7@Init|

; 1349 :     {
; 1350 :         TurnCardPowerOff();

  00260	e5943000	 ldr         r3, [r4]
  00264	e1a00004	 mov         r0, r4
  00268	e5933018	 ldr         r3, [r3, #0x18]
  0026c	e1a0e00f	 mov         lr, pc
  00270	e12fff13	 bx          r3

; 1351 :         goto cleanUp;

  00274	eaffffb3	 b           |$LN51@Init|
  00278		 |$LN7@Init|

; 1352 :     }
; 1353 : 
; 1354 :     // now register the host controller
; 1355 :     status = SDHCDRegisterHostController(m_pHCContext);

  00278	e59400a8	 ldr         r0, [r4, #0xA8]
  0027c	eb000000	 bl          SDHCDRegisterHostController
  00280	e3500000	 cmp         r0, #0

; 1356 :     if (!SD_API_SUCCESS(status))
; 1357 :     {
; 1358 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDHC Failed to register host controller: %0x08X \r\n"),status));
; 1359 :         TurnCardPowerOff();

  00284	e1a00004	 mov         r0, r4
  00288	5a000004	 bpl         |$LN5@Init|
  0028c	e5943000	 ldr         r3, [r4]
  00290	e5933018	 ldr         r3, [r3, #0x18]
  00294	e1a0e00f	 mov         lr, pc
  00298	e12fff13	 bx          r3

; 1360 :         goto cleanUp;

  0029c	eaffffa9	 b           |$LN51@Init|
  002a0		 |$LN5@Init|

; 1361 :     }
; 1362 : 
; 1363 :     EnableSDHCInterrupts();

  002a0	eb000000	 bl          |?EnableSDHCInterrupts@CSDIOControllerBase@@QAAXXZ|

; 1364 :     TurnCardPowerOff();

  002a4	e5943000	 ldr         r3, [r4]
  002a8	e1a00004	 mov         r0, r4
  002ac	e5933018	 ldr         r3, [r3, #0x18]
  002b0	e1a0e00f	 mov         lr, pc
  002b4	e12fff13	 bx          r3

; 1365 : 
; 1366 :     // create the card detect IST thread
; 1367 :     m_htCardDetectIST = CreateThread(NULL, 0, SDHCCardDetectIstThread, this, 0, NULL);

  002b8	e59f2028	 ldr         r2, [pc, #0x28]
  002bc	e1a03004	 mov         r3, r4
  002c0	e3a01000	 mov         r1, #0
  002c4	e3a00000	 mov         r0, #0
  002c8	e58d7004	 str         r7, [sp, #4]
  002cc	e58d7000	 str         r7, [sp]
  002d0	eb000000	 bl          CreateThread
  002d4	e3500000	 cmp         r0, #0
  002d8	e5840124	 str         r0, [r4, #0x124]

; 1368 : 
; 1369 :     if (NULL == m_htCardDetectIST)

  002dc	0affff99	 beq         |$LN51@Init|

; 1370 :         {
; 1371 :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;
; 1372 :         goto cleanUp;
; 1373 :         }
; 1374 : 
; 1375 :     // return the controller context
; 1376 :     dwRet = (DWORD) this;

  002e0	e1a06004	 mov         r6, r4
  002e4		 |$cleanUp$42676|

; 1377 : 
; 1378 : cleanUp:
; 1379 :     if ( (dwRet == 0) && m_pHCContext )

  002e4	eaffff9d	 b           |$LN1@Init|
  002e8		 |$LN56@Init|
  002e8		 |$LN57@Init|
  002e8	00000000	 DCD         |?SDHCCardDetectIstThread@CSDIOControllerBase@@SAKPAX@Z|
  002ec		 |$LN58@Init|
  002ec	00000000	 DCD         |??_C@_1HK@NAJMOFNG@?$AAS?$AAD?$AAH?$AAC?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?3?$AA?3?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAn@|
  002f0		 |$LN59@Init|
  002f0	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  002f4		 |$LN60@Init|
  002f4	00000000	 DCD         |??_C@_1KA@CLLCPJCJ@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  002f8		 |$LN61@Init|
  002f8	00000000	 DCD         |??_C@_1GE@HPCKCMKC@?$AAS?$AAD?$AAH?$AAC?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?3?$AA?3?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAo?$AAp?$AAe?$AAn?$AAi?$AAn?$AAg?$AA?5?$AAt@|
  002fc		 |$LN62@Init|
  002fc	00000000	 DCD         |??_C@_1FC@JCPNFEIG@?$AAS?$AAD?$AAH?$AAC?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?3?$AA?3?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAi?$AAn@|
  00300		 |$LN63@Init|
  00300	00000000	 DCD         |??_C@_1JA@BHKFNOIC@?$AAS?$AAD?$AAH?$AAC?$AA?5?$AAh?$AAo?$AAs?$AAt?$AA?5?$AAc?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAl?$AAe?$AAr?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?3@|
  00304		 |$LN64@Init|
  00304	00000000	 DCD         |dpCurSettings|
  00308		 |$LN65@Init|
  00308	00000000	 DCD         |s_deviceRegParams|
  0030c		 |$LN66@Init|
  0030c	00000000	 DCD         |??_C@_1DE@PNOEBOJA@?$AAS?$AAD?$AAH?$AAC?$AA?3?$AA?5?$AAC?$AAP?$AAU?$AA?5?$AAr?$AAe?$AAv?$AAi?$AAs?$AAi?$AAo?$AAn?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  00310		 |$LN67@Init|
  00310	01012010	 DCD         0x1012010
  00314		 |$M45715|

			 ENDP  ; |?Init@CSDIOControllerBase@@QAAHPBG@Z|, CSDIOControllerBase::Init

	EXPORT	|?SDHCDeinitializeImpl@CSDIOControllerBase@@QAAJXZ| ; CSDIOControllerBase::SDHCDeinitializeImpl
	IMPORT	|ReleaseDevicePads|
	IMPORT	|?SDIO_DeinitDMA@CSDIOControllerBase@@QAAXXZ| ; CSDIOControllerBase::SDIO_DeinitDMA
	IMPORT	|CloseHandle|
	IMPORT	|InterruptDisable|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T45751| DCD	|$LN21@SDHCDeinit|
	DCD	0x40006602
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\sdhc\base\sdhc.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCDeinitializeImpl@CSDIOControllerBase@@QAAJXZ| PROC ; CSDIOControllerBase::SDHCDeinitializeImpl

; 2249 : {

  00000		 |$LN21@SDHCDeinit|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M45748|
  00008	e1a05000	 mov         r5, r0

; 2250 :     DEBUGMSG(SDCARD_ZONE_INFO, (L"CSDIOControllerBase::SDHCDeinitializeImpl++\r\n"));
; 2251 :     
; 2252 :     // mark for shutdown
; 2253 :     m_fDriverShutdown = TRUE;
; 2254 : 
; 2255 :     if (m_fInitialized)

  0000c	e5953138	 ldr         r3, [r5, #0x138]
  00010	e3a08001	 mov         r8, #1
  00014	e5858130	 str         r8, [r5, #0x130]
  00018	e3530000	 cmp         r3, #0
  0001c	e3a06000	 mov         r6, #0
  00020	e3e07000	 mvn         r7, #0
  00024	0a00001b	 beq         |$LN7@SDHCDeinit|

; 2256 :     {
; 2257 :         if( m_dwControllerSysIntr != SYSINTR_UNDEFINED )

  00028	e5953134	 ldr         r3, [r5, #0x134]
  0002c	e3730001	 cmn         r3, #1
  00030	0a000013	 beq         |$LN9@SDHCDeinit|

; 2258 :         {
; 2259 :             // disable wakeup on SDIO interrupt
; 2260 :             if ( m_dwCurrentWakeupSources & WAKEUP_SDIO )

  00034	e59530ec	 ldr         r3, [r5, #0xEC]
  00038	e3130001	 tst         r3, #1

; 2261 :             {
; 2262 :                 KernelIoControl( IOCTL_HAL_DISABLE_WAKE,
; 2263 :                     &m_dwControllerSysIntr,
; 2264 :                     sizeof( m_dwControllerSysIntr ),
; 2265 :                     NULL,
; 2266 :                     0,
; 2267 :                     NULL );

  0003c	159f0150	 ldrne       r0, [pc, #0x150]
  00040	13a03000	 movne       r3, #0
  00044	13a02004	 movne       r2, #4
  00048	12851f4d	 addne       r1, r5, #0x4D, 30
  0004c	158d6004	 strne       r6, [sp, #4]
  00050	158d6000	 strne       r6, [sp]
  00054	1b000000	 blne        KernelIoControl

; 2268 :             }
; 2269 : 
; 2270 :             // disable controller interrupt
; 2271 :             InterruptDisable(m_dwControllerSysIntr);
; 2272 : 
; 2273 :             // release the SYSINTR value
; 2274 :             KernelIoControl(IOCTL_HAL_RELEASE_SYSINTR, &m_dwControllerSysIntr, sizeof(DWORD), NULL, 0, NULL);

  00058	e1a04005	 mov         r4, r5
  0005c	e5b40134	 ldr         r0, [r4, #0x134]!
  00060	eb000000	 bl          InterruptDisable
  00064	e59f0124	 ldr         r0, [pc, #0x124]
  00068	e3a03000	 mov         r3, #0
  0006c	e3a02004	 mov         r2, #4
  00070	e1a01004	 mov         r1, r4
  00074	e58d6004	 str         r6, [sp, #4]
  00078	e58d6000	 str         r6, [sp]
  0007c	eb000000	 bl          KernelIoControl

; 2275 :             m_dwControllerSysIntr = SYSINTR_UNDEFINED;

  00080	e5857134	 str         r7, [r5, #0x134]
  00084		 |$LN9@SDHCDeinit|

; 2276 :         }
; 2277 : 
; 2278 : 
; 2279 :         if (m_fCardPresent)

  00084	e59530f0	 ldr         r3, [r5, #0xF0]
  00088	e3530000	 cmp         r3, #0

; 2280 :         {
; 2281 :            // remove device
; 2282 :            HandleRemoval(FALSE);

  0008c	13a01000	 movne       r1, #0
  00090	11a00005	 movne       r0, r5
  00094	1b000000	 blne        |?HandleRemoval@CSDIOControllerBase@@QAAXH@Z|
  00098		 |$LN7@SDHCDeinit|

; 2283 :         }
; 2284 :     }
; 2285 : 
; 2286 :     // clean up controller IST
; 2287 :     if (NULL != m_htControllerIST)

  00098	e595311c	 ldr         r3, [r5, #0x11C]
  0009c	e3530000	 cmp         r3, #0
  000a0	0a000008	 beq         |$LN6@SDHCDeinit|

; 2288 :     {
; 2289 :         // wake up the IST
; 2290 :         SetEvent(m_hControllerISTEvent);

  000a4	e5950118	 ldr         r0, [r5, #0x118]
  000a8	e3a01003	 mov         r1, #3
  000ac	eb000000	 bl          EventModify

; 2291 :         // wait for the thread to exit
; 2292 :         WaitForSingleObject(m_htControllerIST, INFINITE);

  000b0	e595011c	 ldr         r0, [r5, #0x11C]
  000b4	e1a01007	 mov         r1, r7
  000b8	eb000000	 bl          WaitForSingleObject

; 2293 :         CloseHandle(m_htControllerIST);

  000bc	e595011c	 ldr         r0, [r5, #0x11C]
  000c0	eb000000	 bl          CloseHandle

; 2294 :         m_htControllerIST = NULL;

  000c4	e585611c	 str         r6, [r5, #0x11C]
  000c8		 |$LN6@SDHCDeinit|

; 2295 :     }
; 2296 : 
; 2297 :     // free controller interrupt event
; 2298 :     if (NULL != m_hControllerISTEvent)

  000c8	e5953118	 ldr         r3, [r5, #0x118]
  000cc	e3530000	 cmp         r3, #0
  000d0	0a000002	 beq         |$LN5@SDHCDeinit|

; 2299 :     {
; 2300 :         CloseHandle(m_hControllerISTEvent);

  000d4	e1a00003	 mov         r0, r3
  000d8	eb000000	 bl          CloseHandle

; 2301 :         m_hControllerISTEvent = NULL;

  000dc	e5856118	 str         r6, [r5, #0x118]
  000e0		 |$LN5@SDHCDeinit|

; 2302 :     }
; 2303 : 
; 2304 :     // clean up card detect IST
; 2305 :     if (NULL != m_htCardDetectIST)

  000e0	e5953124	 ldr         r3, [r5, #0x124]
  000e4	e3530000	 cmp         r3, #0
  000e8	0a000008	 beq         |$LN4@SDHCDeinit|

; 2306 :     {
; 2307 :         // wake up the IST
; 2308 :         SetEvent(m_hCardDetectEvent);

  000ec	e5950120	 ldr         r0, [r5, #0x120]
  000f0	e3a01003	 mov         r1, #3
  000f4	eb000000	 bl          EventModify

; 2309 :         // wait for the thread to exit
; 2310 :         WaitForSingleObject(m_htCardDetectIST, INFINITE);

  000f8	e5950124	 ldr         r0, [r5, #0x124]
  000fc	e1a01007	 mov         r1, r7
  00100	eb000000	 bl          WaitForSingleObject

; 2311 :         CloseHandle(m_htCardDetectIST);

  00104	e5950124	 ldr         r0, [r5, #0x124]
  00108	eb000000	 bl          CloseHandle

; 2312 :         m_htCardDetectIST = NULL;

  0010c	e5856124	 str         r6, [r5, #0x124]
  00110		 |$LN4@SDHCDeinit|

; 2313 :     }
; 2314 : 
; 2315 :     // free card detect interrupt event
; 2316 :     if (NULL != m_hCardDetectEvent)

  00110	e5953120	 ldr         r3, [r5, #0x120]
  00114	e3530000	 cmp         r3, #0
  00118	0a000002	 beq         |$LN3@SDHCDeinit|

; 2317 :     {
; 2318 :         CloseHandle(m_hCardDetectEvent);

  0011c	e1a00003	 mov         r0, r3
  00120	eb000000	 bl          CloseHandle

; 2319 :         m_hCardDetectEvent = NULL;

  00124	e5856120	 str         r6, [r5, #0x120]
  00128		 |$LN3@SDHCDeinit|

; 2320 :     }
; 2321 :     // clean up power thread
; 2322 :     if (NULL != m_hTimerThreadIST)

  00128	e59531ac	 ldr         r3, [r5, #0x1AC]
  0012c	e3530000	 cmp         r3, #0
  00130	0a000009	 beq         |$LN2@SDHCDeinit|

; 2323 :         {
; 2324 :         m_bExitThread = TRUE;
; 2325 :         SetEvent(m_hTimerEvent);

  00134	e59501a8	 ldr         r0, [r5, #0x1A8]
  00138	e3a01003	 mov         r1, #3
  0013c	e58581a4	 str         r8, [r5, #0x1A4]
  00140	eb000000	 bl          EventModify

; 2326 :         WaitForSingleObject(m_hTimerThreadIST, INFINITE);

  00144	e59501ac	 ldr         r0, [r5, #0x1AC]
  00148	e1a01007	 mov         r1, r7
  0014c	eb000000	 bl          WaitForSingleObject

; 2327 :         CloseHandle(m_hTimerThreadIST);

  00150	e59501ac	 ldr         r0, [r5, #0x1AC]
  00154	eb000000	 bl          CloseHandle

; 2328 :         m_hTimerThreadIST = NULL;

  00158	e58561ac	 str         r6, [r5, #0x1AC]
  0015c		 |$LN2@SDHCDeinit|

; 2329 :         }
; 2330 : 
; 2331 :     if (m_hTimerEvent != NULL)

  0015c	e59531a8	 ldr         r3, [r5, #0x1A8]
  00160	e3530000	 cmp         r3, #0

; 2332 :         {
; 2333 :         CloseHandle(m_hTimerEvent);

  00164	11a00003	 movne       r0, r3
  00168	1b000000	 blne        CloseHandle

; 2334 :         }
; 2335 : 
; 2336 : #ifdef SDIO_DMA_ENABLED
; 2337 :     SDIO_DeinitDMA();

  0016c	e1a00005	 mov         r0, r5
  00170	eb000000	 bl          |?SDIO_DeinitDMA@CSDIOControllerBase@@QAAXXZ|

; 2338 : #endif
; 2339 : 
; 2340 : 	// Release pads
; 2341 : 	ReleaseDevicePads(SOCGetSDHCDeviceBySlot(m_dwSlot));

  00174	e5950170	 ldr         r0, [r5, #0x170]
  00178	eb000000	 bl          SOCGetSDHCDeviceBySlot
  0017c	eb000000	 bl          ReleaseDevicePads

; 2342 : 
; 2343 :     return SD_API_STATUS_SUCCESS;

  00180	e3a00000	 mov         r0, #0

; 2344 : }

  00184	e28dd008	 add         sp, sp, #8
  00188	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0018c	e12fff1e	 bx          lr
  00190		 |$LN22@SDHCDeinit|
  00190		 |$LN23@SDHCDeinit|
  00190	010100d8	 DCD         0x10100d8
  00194		 |$LN24@SDHCDeinit|
  00194	010100a4	 DCD         0x10100a4
  00198		 |$M45749|

			 ENDP  ; |?SDHCDeinitializeImpl@CSDIOControllerBase@@QAAJXZ|, CSDIOControllerBase::SDHCDeinitializeImpl

	EXPORT	|?SDHCBusRequestHandlerImpl_NormalPath@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z| ; CSDIOControllerBase::SDHCBusRequestHandlerImpl_NormalPath

  00000			 AREA	 |.pdata|, PDATA
|$T45767| DCD	|$LN10@SDHCBusReq|
	DCD	0x40001e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCBusRequestHandlerImpl_NormalPath@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z| PROC ; CSDIOControllerBase::SDHCBusRequestHandlerImpl_NormalPath

; 2636 :             {

  00000		 |$LN10@SDHCBusReq|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45764|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 2637 :     DEBUGCHK(pRequest);
; 2638 : 
; 2639 :     SD_API_STATUS   status = SD_API_STATUS_FAST_PATH_SUCCESS;
; 2640 :     DEBUGCHK(pRequest);
; 2641 : 
; 2642 :     if (m_fCardPresent == FALSE)

  0000c	e59430f0	 ldr         r3, [r4, #0xF0]
  00010	e3530000	 cmp         r3, #0

; 2643 :             {
; 2644 :              status = SD_API_STATUS_DEVICE_REMOVED;
; 2645 :              return status;

  00014	03a05147	 moveq       r5, #0x47, 2
  00018	0a000013	 beq         |$LN1@SDHCBusReq|

; 2646 :             }
; 2647 : 
; 2648 :     UpdateSystemClock(TRUE);

  0001c	e3a01001	 mov         r1, #1
  00020	e1a00004	 mov         r0, r4
  00024	eb000000	 bl          |?UpdateSystemClock@CSDIOControllerBase@@QAAHH@Z|

; 2649 : 
; 2650 :     SDHCDAcquireHCLock(m_pHCContext);

  00028	e59430a8	 ldr         r3, [r4, #0xA8]
  0002c	e2830024	 add         r0, r3, #0x24
  00030	eb000000	 bl          EnterCriticalSection

; 2651 : 
; 2652 :     status = SendCommand(pRequest);

  00034	e1a01005	 mov         r1, r5
  00038	e1a00004	 mov         r0, r4
  0003c	eb000000	 bl          |?SendCommand@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z|

; 2653 :     m_bCommandPending = TRUE;

  00040	e3a03001	 mov         r3, #1
  00044	e58431f8	 str         r3, [r4, #0x1F8]

; 2654 : 
; 2655 :     if(!SD_API_SUCCESS(status))
; 2656 :     {
; 2657 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDHCDBusRequestHandler() - Error sending command:0x%02x\r\n"), pRequest->CommandCode));
; 2658 :         SDHCDReleaseHCLock(m_pHCContext);

  00048	e59430a8	 ldr         r3, [r4, #0xA8]
  0004c	e1b05000	 movs        r5, r0

; 2659 :         goto cleanUp;      
; 2660 :         }
; 2661 :     // we will handle the command response interrupt on another thread
; 2662 :     status = SD_API_STATUS_PENDING;
; 2663 :     SDHCDReleaseHCLock(m_pHCContext);   // really needed?

  00050	53a05001	 movpl       r5, #1
  00054	e2830024	 add         r0, r3, #0x24
  00058	eb000000	 bl          LeaveCriticalSection

; 2664 : 
; 2665 : cleanUp:
; 2666 : 
; 2667 :     // No, we don't call UpdateSystemClock(FALSE) here because we don't want to cause
; 2668 :     // the timer thread to timeout while the SDHC controller is processing command,
; 2669 :     // or transferring data. The Controller IST will call the UpdateSystemClock(FALSE) 
; 2670 :     // when the process is is completed or the data transfer is complete.
; 2671 :     if (status != SD_API_STATUS_PENDING)

  0005c	e3550001	 cmp         r5, #1

; 2672 :         {
; 2673 :         UpdateSystemClock(FALSE);

  00060	13a01000	 movne       r1, #0
  00064	11a00004	 movne       r0, r4
  00068		 |$cleanUp$43155|
  00068	1b000000	 blne        |?UpdateSystemClock@CSDIOControllerBase@@QAAHH@Z|
  0006c		 |$LN1@SDHCBusReq|

; 2674 :         }
; 2675 : 
; 2676 :     return status;
; 2677 :     }

  0006c	e1a00005	 mov         r0, r5
  00070	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00074	e12fff1e	 bx          lr
  00078		 |$M45765|

			 ENDP  ; |?SDHCBusRequestHandlerImpl_NormalPath@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z|, CSDIOControllerBase::SDHCBusRequestHandlerImpl_NormalPath

	EXPORT	|?SDHCDeinitialize@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@@Z| ; CSDIOControllerBase::SDHCDeinitialize

  00000			 AREA	 |.pdata|, PDATA
|$T45778| DCD	|$LN5@SDHCDeinit@2|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCDeinitialize@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@@Z| PROC ; CSDIOControllerBase::SDHCDeinitialize

; 3428 : {

  00000		 |$LN5@SDHCDeinit@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45775|

; 3429 :     // get our extension
; 3430 :     CSDIOControllerBase *pController = GET_PCONTROLLER_FROM_HCD(pHCContext);

  00004	e590004c	 ldr         r0, [r0, #0x4C]

; 3431 :     return pController->SDHCDeinitializeImpl();

  00008	eb000000	 bl          |?SDHCDeinitializeImpl@CSDIOControllerBase@@QAAJXZ|

; 3432 : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M45776|

			 ENDP  ; |?SDHCDeinitialize@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@@Z|, CSDIOControllerBase::SDHCDeinitialize

	EXPORT	|?PowerDown@CSDIOControllerBase@@QAAXXZ| ; CSDIOControllerBase::PowerDown
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T45794| DCD	|$LN11@PowerDown|
	DCD	0x40002701
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\sdhc\base\sdhc.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PowerDown@CSDIOControllerBase@@QAAXXZ| PROC ; CSDIOControllerBase::PowerDown

; 3478 : {

  00000		 |$LN11@PowerDown|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45791|
  00004	e1a04000	 mov         r4, r0

; 3479 :     // Notify bus driver
; 3480 :     IndicateSlotStateChange(DeviceEjected);

  00008	e59400a8	 ldr         r0, [r4, #0xA8]
  0000c	e3a02001	 mov         r2, #1
  00010	e3a01000	 mov         r1, #0
  00014	eb000000	 bl          SDHCDIndicateSlotStateChange

; 3481 : 
; 3482 :     SystemClockOn(TRUE);

  00018	e3a06000	 mov         r6, #0
  0001c	e3a01001	 mov         r1, #1
  00020	e1a00004	 mov         r0, r4
  00024	e58460dc	 str         r6, [r4, #0xDC]
  00028	eb000000	 bl          |?UpdateDevicePowerState@CSDIOControllerBase@@QAAXH@Z|

; 3483 : 
; 3484 :     // Simulate Device removal for Suspend/Resume
; 3485 :     m_fCardPresent = FALSE;
; 3486 :     // get the current request
; 3487 :     PSD_BUS_REQUEST pRequest = GetAndLockCurrentRequest();

  0002c	e59400a8	 ldr         r0, [r4, #0xA8]
  00030	e3a01000	 mov         r1, #0
  00034	e58460f0	 str         r6, [r4, #0xF0]
  00038	eb000000	 bl          SDHCDGetAndLockCurrentRequest
  0003c	e1b01000	 movs        r1, r0

; 3488 : 
; 3489 :     if (pRequest != NULL)
; 3490 :     {
; 3491 :         DEBUGMSG(SDCARD_ZONE_WARN,
; 3492 :             (TEXT("PowerDown - Canceling current request: 0x%08X, command: %d\n"),
; 3493 :              pRequest, pRequest->CommandCode));
; 3494 :         DumpRequest(pRequest);
; 3495 :         IndicateBusRequestComplete(pRequest, SD_API_STATUS_DEVICE_REMOVED);

  00040	159400a8	 ldrne       r0, [r4, #0xA8]
  00044	13a02147	 movne       r2, #0x47, 2
  00048	1b000000	 blne        SDHCDIndicateBusRequestComplete

; 3496 :     }
; 3497 : 
; 3498 :     if (m_dwSDClockMode)

  0004c	e594319c	 ldr         r3, [r4, #0x19C]
  00050	e3a05001	 mov         r5, #1

; 3499 :     {
; 3500 :         // turn clock off and remove power from the slot
; 3501 :         OUTREG32(&m_pbRegisters->MMCHS_SYSCONFIG, MMCHS_SYSCONFIG_AUTOIDLE | MMCHS_SYSCONFIG_SIDLEMODE(SIDLE_FORCE));
; 3502 :     }
; 3503 : 
; 3504 :     SetPower(D4);

  00054	e3a01004	 mov         r1, #4
  00058	e3530000	 cmp         r3, #0
  0005c	1594315c	 ldrne       r3, [r4, #0x15C]
  00060	e1a00004	 mov         r0, r4
  00064	15835010	 strne       r5, [r3, #0x10]
  00068	eb000000	 bl          |?SetPower@CSDIOControllerBase@@QAAHW4_CEDEVICE_POWER_STATE@@@Z|

; 3505 : 
; 3506 :     // go to D4 right away
; 3507 :     ResetEvent(m_hTimerEvent);

  0006c	e59401a8	 ldr         r0, [r4, #0x1A8]
  00070	e3a01002	 mov         r1, #2
  00074	eb000000	 bl          EventModify

; 3508 :     m_dwClockCnt = 0;
; 3509 :     m_bDisablePower = TRUE;
; 3510 :     m_InternPowerState = D4;

  00078	e3a03004	 mov         r3, #4

; 3511 :     UpdateDevicePowerState(TRUE);

  0007c	e3a01001	 mov         r1, #1
  00080	e1a00004	 mov         r0, r4
  00084	e58430dc	 str         r3, [r4, #0xDC]
  00088	e58461a0	 str         r6, [r4, #0x1A0]
  0008c	e58451cc	 str         r5, [r4, #0x1CC]
  00090	eb000000	 bl          |?UpdateDevicePowerState@CSDIOControllerBase@@QAAXH@Z|

; 3512 : }

  00094	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00098	e12fff1e	 bx          lr
  0009c		 |$M45792|

			 ENDP  ; |?PowerDown@CSDIOControllerBase@@QAAXXZ|, CSDIOControllerBase::PowerDown

	EXPORT	|?SDIReceive@CSDIOControllerBase@@QAAHPAEKH@Z| ; CSDIOControllerBase::SDIReceive

  00000			 AREA	 |.pdata|, PDATA
|$T45807| DCD	|$LN7@SDIReceive|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDIReceive@CSDIOControllerBase@@QAAHPAEKH@Z| PROC ; CSDIOControllerBase::SDIReceive

; 3747 : {

  00000		 |$LN7@SDIReceive|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45804|

; 3748 : #ifdef SDIO_DMA_ENABLED
; 3749 :     if( m_fDMATransfer )

  00004	e590e110	 ldr         lr, [r0, #0x110]
  00008	e35e0000	 cmp         lr, #0
  0000c	0a000002	 beq         |$LN2@SDIReceive|

; 3750 :     {
; 3751 :         return SDIDMAReceive( pBuff, dwLen, FastPathMode );

  00010	eb000000	 bl          |?SDIDMAReceive@CSDIOControllerBase@@QAAHPAEKH@Z|

; 3757 :     }
; 3758 : }

  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$LN2@SDIReceive|

; 3752 :     }
; 3753 :     else
; 3754 : #endif        
; 3755 :     {
; 3756 :         return SDIPollingReceive( pBuff, dwLen );

  0001c	eb000000	 bl          |?SDIPollingReceive@CSDIOControllerBase@@QAAHPAEK@Z|

; 3757 :     }
; 3758 : }

  00020	e49de004	 ldr         lr, [sp], #4
  00024	e12fff1e	 bx          lr
  00028		 |$M45805|

			 ENDP  ; |?SDIReceive@CSDIOControllerBase@@QAAHPAEKH@Z|, CSDIOControllerBase::SDIReceive

	EXPORT	|?SDITransmit@CSDIOControllerBase@@QAAHPAEKH@Z| ; CSDIOControllerBase::SDITransmit

  00000			 AREA	 |.pdata|, PDATA
|$T45820| DCD	|$LN7@SDITransmi|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDITransmit@CSDIOControllerBase@@QAAHPAEKH@Z| PROC ; CSDIOControllerBase::SDITransmit

; 3763 : {

  00000		 |$LN7@SDITransmi|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45817|

; 3764 : #ifdef SDIO_DMA_ENABLED
; 3765 :     if( m_fDMATransfer )

  00004	e590e110	 ldr         lr, [r0, #0x110]
  00008	e35e0000	 cmp         lr, #0
  0000c	0a000002	 beq         |$LN2@SDITransmi|

; 3766 :     {
; 3767 :         return SDIDMATransmit( pBuff, dwLen, FastPathMode );

  00010	eb000000	 bl          |?SDIDMATransmit@CSDIOControllerBase@@QAAHPAEKH@Z|

; 3773 :     }
; 3774 : }

  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$LN2@SDITransmi|

; 3768 :     }
; 3769 :     else
; 3770 : #endif      
; 3771 :     {
; 3772 :         return SDIPollingTransmit( pBuff, dwLen );

  0001c	eb000000	 bl          |?SDIPollingTransmit@CSDIOControllerBase@@QAAHPAEK@Z|

; 3773 :     }
; 3774 : }

  00020	e49de004	 ldr         lr, [sp], #4
  00024	e12fff1e	 bx          lr
  00028		 |$M45818|

			 ENDP  ; |?SDITransmit@CSDIOControllerBase@@QAAHPAEKH@Z|, CSDIOControllerBase::SDITransmit

	EXPORT	|?SetInterface@CSDIOControllerBase@@QAAXPAU_SD_CARD_INTERFACE_EX@@@Z| ; CSDIOControllerBase::SetInterface

  00000			 AREA	 |.pdata|, PDATA
|$T45831| DCD	|$LN8@SetInterfa|
	DCD	0x40001a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetInterface@CSDIOControllerBase@@QAAXPAU_SD_CARD_INTERFACE_EX@@@Z| PROC ; CSDIOControllerBase::SetInterface

; 410  : {

  00000		 |$LN8@SetInterfa|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45828|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 411  :     if(m_ActualPowerState == D4) return;

  0000c	e59430e0	 ldr         r3, [r4, #0xE0]
  00010	e3530004	 cmp         r3, #4
  00014	0a000011	 beq         |$LN2@SetInterfa|

; 412  : 
; 413  :     UpdateSystemClock(TRUE);

  00018	e3a01001	 mov         r1, #1
  0001c	eb000000	 bl          |?UpdateSystemClock@CSDIOControllerBase@@QAAHH@Z|

; 414  : 
; 415  :     Sleep(2);

  00020	e3a00002	 mov         r0, #2
  00024	eb000000	 bl          Sleep

; 416  : 
; 417  :     m_sContext.eInterfaceMode = (pInterface->InterfaceModeEx.bit.sd4Bit) ? SD_INTERFACE_SD_4BIT : SD_INTERFACE_SD_MMC_1BIT;

  00028	e5953000	 ldr         r3, [r5]

; 418  :     SetSDInterfaceMode(m_sContext.eInterfaceMode);

  0002c	e1a00004	 mov         r0, r4
  00030	e3130001	 tst         r3, #1
  00034	13a03001	 movne       r3, #1
  00038	03a03000	 moveq       r3, #0
  0003c	e1a01003	 mov         r1, r3
  00040	e5843208	 str         r3, [r4, #0x208]
  00044	eb000000	 bl          |?SetSDInterfaceMode@CSDIOControllerBase@@IAAXW4SD_INTERFACE_MODE@@@Z|

; 419  : 
; 420  :     SetClockRate(&pInterface->ClockRate);

  00048	e2851004	 add         r1, r5, #4
  0004c	e1a00004	 mov         r0, r4
  00050	eb000000	 bl          |?SetClockRate@CSDIOControllerBase@@QAAXPAK@Z|

; 421  :     UpdateSystemClock(FALSE);

  00054	e3a01000	 mov         r1, #0
  00058	e1a00004	 mov         r0, r4
  0005c	eb000000	 bl          |?UpdateSystemClock@CSDIOControllerBase@@QAAHH@Z|
  00060		 |$LN2@SetInterfa|

; 422  : }

  00060	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00064	e12fff1e	 bx          lr
  00068		 |$M45829|

			 ENDP  ; |?SetInterface@CSDIOControllerBase@@QAAXPAU_SD_CARD_INTERFACE_EX@@@Z|, CSDIOControllerBase::SetInterface

	EXPORT	|?SDHCPowerTimerThread@CSDIOControllerBase@@SAKPAX@Z| ; CSDIOControllerBase::SDHCPowerTimerThread

  00000			 AREA	 |.pdata|, PDATA
|$T45841| DCD	|$LN5@SDHCPowerT@2|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCPowerTimerThread@CSDIOControllerBase@@SAKPAX@Z| PROC ; CSDIOControllerBase::SDHCPowerTimerThread

; 672  : {

  00000		 |$LN5@SDHCPowerT@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45838|

; 673  :     CSDIOControllerBase *pController = (CSDIOControllerBase*)lpParameter;
; 674  :     return pController->SDHCPowerTimerThreadImpl();

  00004	eb000000	 bl          |?SDHCPowerTimerThreadImpl@CSDIOControllerBase@@QAAKXZ|

; 675  : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M45839|

			 ENDP  ; |?SDHCPowerTimerThread@CSDIOControllerBase@@SAKPAX@Z|, CSDIOControllerBase::SDHCPowerTimerThread

	EXPORT	|?HandleCardDetectInterrupt@CSDIOControllerBase@@QAAHK@Z| ; CSDIOControllerBase::HandleCardDetectInterrupt

  00000			 AREA	 |.pdata|, PDATA
|$T45853| DCD	|$LN7@HandleCard|
	DCD	0x40001f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HandleCardDetectInterrupt@CSDIOControllerBase@@QAAHK@Z| PROC ; CSDIOControllerBase::HandleCardDetectInterrupt

; 1083 : {

  00000		 |$LN7@HandleCard|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45850|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 1084 :     BOOL    bRetValue = FALSE;

  0000c	e3a00000	 mov         r0, #0

; 1085 : 
; 1086 :     #ifdef ENABLE_RETAIL_OUTPUT
; 1087 :         DEBUGMSG(SDCARD_ZONE_INIT, (TEXT("CardDetectInterrupt\r\n")));
; 1088 :     #endif
; 1089 : 		
; 1090 :     if (dwStatus & EXT_MMCHS_STAT_CD_REMOVE_INTR)

  00010	e3150101	 tst         r5, #1, 2
  00014	0a00000a	 beq         |$LN2@HandleCard|

; 1091 :     {
; 1092 :         #ifdef ENABLE_RETAIL_OUTPUT
; 1093 :             RETAILMSG(1, (TEXT("CardDetectInterrupt: Card removed!\r\n")));
; 1094 :         #endif
; 1095 : 
; 1096 :         HandleRemoval(TRUE);

  00018	e3a01001	 mov         r1, #1
  0001c	e1a00004	 mov         r0, r4
  00020	eb000000	 bl          |?HandleRemoval@CSDIOControllerBase@@QAAXH@Z|

; 1097 : 
; 1098 :         EnterCriticalSection( &m_critSec );

  00024	e28400b0	 add         r0, r4, #0xB0
  00028	eb000000	 bl          EnterCriticalSection

; 1099 :         m_CardDetectInterruptStatus &= ~EXT_MMCHS_STAT_CD_REMOVE_INTR;

  0002c	e59431f4	 ldr         r3, [r4, #0x1F4]

; 1100 :         LeaveCriticalSection( &m_critSec );

  00030	e28400b0	 add         r0, r4, #0xB0
  00034	e3c33101	 bic         r3, r3, #1, 2
  00038	e58431f4	 str         r3, [r4, #0x1F4]
  0003c	eb000000	 bl          LeaveCriticalSection

; 1101 : 
; 1102 :         bRetValue = FALSE;

  00040	e3a00000	 mov         r0, #0
  00044		 |$LN2@HandleCard|

; 1103 :     }
; 1104 : 
; 1105 :     if (dwStatus & EXT_MMCHS_STAT_CD_INSERT_INTR)

  00044	e3150102	 tst         r5, #2, 2
  00048	0a000009	 beq         |$LN1@HandleCard|

; 1106 :     {
; 1107 :         EnterCriticalSection( &m_critSec );

  0004c	e28400b0	 add         r0, r4, #0xB0
  00050	eb000000	 bl          EnterCriticalSection

; 1108 :         m_CardDetectInterruptStatus &= ~EXT_MMCHS_STAT_CD_INSERT_INTR;

  00054	e59431f4	 ldr         r3, [r4, #0x1F4]

; 1109 :         LeaveCriticalSection( &m_critSec );

  00058	e28400b0	 add         r0, r4, #0xB0
  0005c	e3c33102	 bic         r3, r3, #2, 2
  00060	e58431f4	 str         r3, [r4, #0x1F4]
  00064	eb000000	 bl          LeaveCriticalSection

; 1110 : 
; 1111 :         #ifdef ENABLE_RETAIL_OUTPUT
; 1112 :             RETAILMSG(1, (TEXT("CardDetectInterrupt: Card inserted!\r\n")));
; 1113 :         #endif
; 1114 : 			
; 1115 :         HandleInsertion();

  00068	e1a00004	 mov         r0, r4
  0006c	eb000000	 bl          |?HandleInsertion@CSDIOControllerBase@@QAAXXZ|

; 1116 : 
; 1117 :         bRetValue = TRUE;

  00070	e3a00001	 mov         r0, #1
  00074		 |$LN1@HandleCard|

; 1118 :     }
; 1119 : 
; 1120 :     return bRetValue;
; 1121 : }

  00074	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00078	e12fff1e	 bx          lr
  0007c		 |$M45851|

			 ENDP  ; |?HandleCardDetectInterrupt@CSDIOControllerBase@@QAAHK@Z|, CSDIOControllerBase::HandleCardDetectInterrupt

	EXPORT	|?ReceiveHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@PAW4SDHCCONTROLLERIST_STATE@@@Z| ; CSDIOControllerBase::ReceiveHandler
	IMPORT	|SDProcessException|
	IMPORT	|__C_specific_handler|

  00000			 AREA	 |.pdata|, PDATA
|$T45897| DCD	|$LN32@ReceiveHan|
	DCD	0xc0003404

  00000			 AREA	 |.pdata|, PDATA
|$T45899| DCD	|$LN16@ReceiveHan|
	DCD	0x40000301

  00000			 AREA	 |.xdata|, DATA
|$T45895| DCD	0x1
	DCD	|$LN20@ReceiveHan|
	DCD	|$LN21@ReceiveHan|
	DCD	|$LN16@ReceiveHan|
	DCD	|$LN17@ReceiveHan|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T45895|

  00008		 |?ReceiveHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@PAW4SDHCCONTROLLERIST_STATE@@@Z| PROC ; CSDIOControllerBase::ReceiveHandler

; 1796 : {

  00008		 |$LN32@ReceiveHan|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d5870	 stmdb       sp!, {r4 - r6, r11, r12, lr}
  00010	e28db018	 add         r11, sp, #0x18
  00014	e24dd00c	 sub         sp, sp, #0xC
  00018		 |$LN30@ReceiveHan|
  00018	e1a05002	 mov         r5, r2

; 1797 :     SD_API_STATUS   status          = SD_API_STATUS_SUCCESS ;
; 1798 :     BOOL            FastPathMode    = FALSE;
; 1799 :     BOOL            fRet;
; 1800 : 
; 1801 :     FastPathMode = ((pRequest->SystemFlags & SD_FAST_PATH_AVAILABLE)) ? TRUE : FALSE;

  0001c	e591300c	 ldr         r3, [r1, #0xC]
  00020	e3a04000	 mov         r4, #0
  00024	e50b4020	 str         r4, [r11, #-0x20]
  00028	e3130102	 tst         r3, #2, 2
  0002c	13a03001	 movne       r3, #1
  00030	03a03000	 moveq       r3, #0
  00034		 |$LN20@ReceiveHan|

; 1802 : 
; 1803 :     __try
; 1804 :         {
; 1805 :         DWORD cbTransfer = TRANSFER_SIZE(pRequest);

  00034	e591e040	 ldr         lr, [r1, #0x40]
  00038	e591603c	 ldr         r6, [r1, #0x3C]

; 1806 : 
; 1807 :         RETAILMSG (0, (TEXT("CSDIOControllerBase::ReceiveHandler: cbTransfer=%d\r\n"),cbTransfer));
; 1808 :         if(FastPathMode)

  0003c	e3530000	 cmp         r3, #0

; 1809 :             {
; 1810 :             DEBUGMSG (SHC_SDBUS_INTERACT_ZONE, (TEXT("CSDIOControllerBase::ReceiveHandler: calling SDIReceive\r\n")));
; 1811 :             fRet = SDIReceive(pRequest->pBlockBuffer, cbTransfer, FastPathMode);

  00040	e5911048	 ldr         r1, [r1, #0x48]

; 1806 : 
; 1807 :         RETAILMSG (0, (TEXT("CSDIOControllerBase::ReceiveHandler: cbTransfer=%d\r\n"),cbTransfer));
; 1808 :         if(FastPathMode)

  00044	0a000005	 beq         |$LN7@ReceiveHan|

; 1809 :             {
; 1810 :             DEBUGMSG (SHC_SDBUS_INTERACT_ZONE, (TEXT("CSDIOControllerBase::ReceiveHandler: calling SDIReceive\r\n")));
; 1811 :             fRet = SDIReceive(pRequest->pBlockBuffer, cbTransfer, FastPathMode);

  00048	e5902110	 ldr         r2, [r0, #0x110]
  0004c	e3520000	 cmp         r2, #0
  00050	e002069e	 mul         r2, lr, r6
  00054	0a000010	 beq         |$LN24@ReceiveHan|
  00058	eb000000	 bl          |?SDIDMAReceive@CSDIOControllerBase@@QAAHPAEKH@Z|
  0005c	ea00000f	 b           |$LN23@ReceiveHan|
  00060		 |$LN7@ReceiveHan|

; 1812 :             }
; 1813 :         else
; 1814 :             {
; 1815 : #ifdef SDIO_DMA_ENABLED
; 1816 :             if( m_fDMATransfer )

  00060	e5903110	 ldr         r3, [r0, #0x110]
  00064	e3530000	 cmp         r3, #0

; 1817 :                 {
; 1818 :                 fRet = StartDMAReceive(pRequest->pBlockBuffer, cbTransfer);

  00068	e002069e	 mul         r2, lr, r6

; 1812 :             }
; 1813 :         else
; 1814 :             {
; 1815 : #ifdef SDIO_DMA_ENABLED
; 1816 :             if( m_fDMATransfer )

  0006c	0a00000a	 beq         |$LN24@ReceiveHan|

; 1817 :                 {
; 1818 :                 fRet = StartDMAReceive(pRequest->pBlockBuffer, cbTransfer);

  00070	eb000000	 bl          |?StartDMAReceive@CSDIOControllerBase@@QAAHPAEK@Z|
  00074	e50b0024	 str         r0, [r11, #-0x24]

; 1819 :                 DEBUGMSG (SHC_SDBUS_INTERACT_ZONE, (TEXT("CSDIOControllerBase::ReceiveHandler: StartDMAReceive returns %d\r\n"), fRet));
; 1820 :                 if (fRet == TRUE)

  00078	e3500001	 cmp         r0, #1
  0007c	1a000008	 bne         |$LN21@ReceiveHan|

; 1821 :                     {
; 1822 :                     status = SD_API_STATUS_PENDING;

  00080	e3a04001	 mov         r4, #1
  00084	e50b4020	 str         r4, [r11, #-0x20]

; 1823 :                     if (peNextState != NULL)

  00088	e3550000	 cmp         r5, #0
  0008c	0a000004	 beq         |$LN21@ReceiveHan|

; 1824 :                         {
; 1825 :                         *peNextState = DATA_RECEIVE_STATE;

  00090	e3a03002	 mov         r3, #2
  00094	e5853000	 str         r3, [r5]

; 1826 :                         }
; 1827 :                     }
; 1828 :                 }
; 1829 :             else

  00098	ea000001	 b           |$LN21@ReceiveHan|

; 1809 :             {
; 1810 :             DEBUGMSG (SHC_SDBUS_INTERACT_ZONE, (TEXT("CSDIOControllerBase::ReceiveHandler: calling SDIReceive\r\n")));
; 1811 :             fRet = SDIReceive(pRequest->pBlockBuffer, cbTransfer, FastPathMode);

  0009c		 |$LN24@ReceiveHan|

; 1830 : #endif
; 1831 :                 {
; 1832 :                 DEBUGMSG (SHC_SDBUS_INTERACT_ZONE, (TEXT("CSDIOControllerBase::ReceiveHandler: calling SDIPollingReceive\r\n")));
; 1833 :                 fRet = SDIPollingReceive(pRequest->pBlockBuffer, cbTransfer);

  0009c	eb000000	 bl          |?SDIPollingReceive@CSDIOControllerBase@@QAAHPAEK@Z|

; 1809 :             {
; 1810 :             DEBUGMSG (SHC_SDBUS_INTERACT_ZONE, (TEXT("CSDIOControllerBase::ReceiveHandler: calling SDIReceive\r\n")));
; 1811 :             fRet = SDIReceive(pRequest->pBlockBuffer, cbTransfer, FastPathMode);

  000a0		 |$LN23@ReceiveHan|

; 1830 : #endif
; 1831 :                 {
; 1832 :                 DEBUGMSG (SHC_SDBUS_INTERACT_ZONE, (TEXT("CSDIOControllerBase::ReceiveHandler: calling SDIPollingReceive\r\n")));
; 1833 :                 fRet = SDIPollingReceive(pRequest->pBlockBuffer, cbTransfer);

  000a0	e50b0024	 str         r0, [r11, #-0x24]
  000a4		 |$LN21@ReceiveHan|

; 1834 :                 }
; 1835 :             }
; 1836 :         }

  000a4	ea000002	 b           |$LN22@ReceiveHan|
  000a8		 |$LN17@ReceiveHan|

; 1838 :         {
; 1839 :         fRet = FALSE;

  000a8	e3a00000	 mov         r0, #0
  000ac	e50b0024	 str         r0, [r11, #-0x24]
  000b0	e51b4020	 ldr         r4, [r11, #-0x20]
  000b4		 |$LN22@ReceiveHan|

; 1840 :         }
; 1841 : 
; 1842 :     if (!fRet)

  000b4	e3500000	 cmp         r0, #0
  000b8	1a000002	 bne         |$LN9@ReceiveHan|

; 1843 :         {
; 1844 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("CSDIOControllerBase::ReceiveHandler - SDIPollingReceive() failed\r\n")));
; 1845 :         status = SD_API_STATUS_DATA_ERROR;

  000bc	e3a04133	 mov         r4, #0x33, 2

; 1846 :         }
; 1847 : 
; 1848 :     return status;

  000c0	ea000000	 b           |$LN9@ReceiveHan|
  000c4		 |$LN29@ReceiveHan|
  000c4	e51b401c	 ldr         r4, [r11, #-0x1C]
  000c8		 |$LN9@ReceiveHan|

; 1849 : }

  000c8	e1a00004	 mov         r0, r4
  000cc	e24bd018	 sub         sp, r11, #0x18
  000d0	e89d6870	 ldmia       sp, {r4 - r6, r11, sp, lr}
  000d4	e12fff1e	 bx          lr

			 ENDP  ; |?ReceiveHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@PAW4SDHCCONTROLLERIST_STATE@@@Z|, CSDIOControllerBase::ReceiveHandler

  000d8		 |$LN16@ReceiveHan|
  000d8		 |$LN31@ReceiveHan|

; 1837 :     __except(SDProcessException(GetExceptionInformation())) 

  000d8	e52de004	 str         lr, [sp, #-4]!
  000dc		 |$LN19@ReceiveHan|
  000dc		 |$LN34@ReceiveHan|
  000dc	eb000000	 bl          SDProcessException
  000e0		 |$LN18@ReceiveHan|
  000e0	e49df004	 ldr         pc, [sp], #4
  000e4		 |$LN35@ReceiveHan|
  000e4		 |$LN33@ReceiveHan|
	EXPORT	|?TransmitHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@PAW4SDHCCONTROLLERIST_STATE@@@Z| ; CSDIOControllerBase::TransmitHandler

  00000			 AREA	 |.pdata|, PDATA
|$T45945| DCD	|$LN33@TransmitHa|
	DCD	0xc0003804

  00000			 AREA	 |.pdata|, PDATA
|$T45947| DCD	|$LN16@TransmitHa|
	DCD	0x40000301

  00000			 AREA	 |.xdata|, DATA
|$T45943| DCD	0x1
	DCD	|$LN20@TransmitHa|
	DCD	|$LN21@TransmitHa|
	DCD	|$LN16@TransmitHa|
	DCD	|$LN17@TransmitHa|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T45943|

  00008		 |?TransmitHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@PAW4SDHCCONTROLLERIST_STATE@@@Z| PROC ; CSDIOControllerBase::TransmitHandler

; 1864 : {

  00008		 |$LN33@TransmitHa|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d5870	 stmdb       sp!, {r4 - r6, r11, r12, lr}
  00010	e28db018	 add         r11, sp, #0x18
  00014	e24dd00c	 sub         sp, sp, #0xC
  00018		 |$LN31@TransmitHa|
  00018	e1a05002	 mov         r5, r2

; 1865 :     SD_API_STATUS   status            = SD_API_STATUS_PENDING;
; 1866 :     DWORD cbTransfer = TRANSFER_SIZE(pRequest);

  0001c	e591e040	 ldr         lr, [r1, #0x40]
  00020	e591603c	 ldr         r6, [r1, #0x3C]

; 1867 : 
; 1868 :     BOOL            FastPathMode    = FALSE;
; 1869 :     BOOL            fRet;
; 1870 : 
; 1871 :     FastPathMode = ((pRequest->SystemFlags & SD_FAST_PATH_AVAILABLE)) ? TRUE : FALSE;

  00024	e591300c	 ldr         r3, [r1, #0xC]
  00028	e3a04001	 mov         r4, #1
  0002c	e3130102	 tst         r3, #2, 2
  00030	e50b4020	 str         r4, [r11, #-0x20]
  00034	13a03001	 movne       r3, #1
  00038	03a03000	 moveq       r3, #0
  0003c		 |$LN20@TransmitHa|

; 1872 : 
; 1873 :     __try 
; 1874 :         {
; 1875 :         if(FastPathMode)

  0003c	e3530000	 cmp         r3, #0

; 1876 :             {
; 1877 :             fRet = SDITransmit(pRequest->pBlockBuffer, cbTransfer, FastPathMode);

  00040	e5911048	 ldr         r1, [r1, #0x48]

; 1872 : 
; 1873 :     __try 
; 1874 :         {
; 1875 :         if(FastPathMode)

  00044	0a000009	 beq         |$LN9@TransmitHa|

; 1876 :             {
; 1877 :             fRet = SDITransmit(pRequest->pBlockBuffer, cbTransfer, FastPathMode);

  00048	e5902110	 ldr         r2, [r0, #0x110]
  0004c	e3520000	 cmp         r2, #0
  00050	e002069e	 mul         r2, lr, r6
  00054	0a000002	 beq         |$LN24@TransmitHa|
  00058	eb000000	 bl          |?SDIDMATransmit@CSDIOControllerBase@@QAAHPAEKH@Z|
  0005c	e50b0024	 str         r0, [r11, #-0x24]

; 1878 :             DEBUGMSG (SHC_SDBUS_INTERACT_ZONE, (TEXT("CSDIOControllerBase::TransmitHandler: SDITransmit returns %d\r\n"), fRet));
; 1879 :             status = SD_API_STATUS_PENDING;
; 1880 :             if (peNextState != NULL)
; 1881 :                 {
; 1882 :                 *peNextState = DATA_TRANSMIT_STATE;
; 1883 :                 }
; 1884 :             }
; 1885 :         else

  00060	ea00000a	 b           |$LN30@TransmitHa|

; 1876 :             {
; 1877 :             fRet = SDITransmit(pRequest->pBlockBuffer, cbTransfer, FastPathMode);

  00064		 |$LN24@TransmitHa|
  00064	eb000000	 bl          |?SDIPollingTransmit@CSDIOControllerBase@@QAAHPAEK@Z|
  00068	e50b0024	 str         r0, [r11, #-0x24]

; 1878 :             DEBUGMSG (SHC_SDBUS_INTERACT_ZONE, (TEXT("CSDIOControllerBase::TransmitHandler: SDITransmit returns %d\r\n"), fRet));
; 1879 :             status = SD_API_STATUS_PENDING;
; 1880 :             if (peNextState != NULL)
; 1881 :                 {
; 1882 :                 *peNextState = DATA_TRANSMIT_STATE;
; 1883 :                 }
; 1884 :             }
; 1885 :         else

  0006c	ea000007	 b           |$LN30@TransmitHa|
  00070		 |$LN9@TransmitHa|

; 1886 :             {
; 1887 : #ifdef SDIO_DMA_ENABLED
; 1888 :             if( m_fDMATransfer )

  00070	e5903110	 ldr         r3, [r0, #0x110]
  00074	e3530000	 cmp         r3, #0

; 1889 :                 {
; 1890 :                 fRet = StartDMATransmit(pRequest->pBlockBuffer, cbTransfer);

  00078	e002069e	 mul         r2, lr, r6

; 1886 :             {
; 1887 : #ifdef SDIO_DMA_ENABLED
; 1888 :             if( m_fDMATransfer )

  0007c	0a00000a	 beq         |$LN6@TransmitHa|

; 1889 :                 {
; 1890 :                 fRet = StartDMATransmit(pRequest->pBlockBuffer, cbTransfer);

  00080	eb000000	 bl          |?StartDMATransmit@CSDIOControllerBase@@QAAHPAEK@Z|
  00084	e50b0024	 str         r0, [r11, #-0x24]

; 1891 :                 DEBUGMSG (SHC_SDBUS_INTERACT_ZONE, (TEXT("CSDIOControllerBase::TransmitHandler: StartDMATransmit returns %d\r\n"), fRet));
; 1892 :                 if (fRet == TRUE)

  00088	e3500001	 cmp         r0, #1
  0008c	1a000008	 bne         |$LN21@TransmitHa|
  00090		 |$LN30@TransmitHa|

; 1893 :                     {
; 1894 :                     status = SD_API_STATUS_PENDING;

  00090	e3a04001	 mov         r4, #1
  00094	e50b4020	 str         r4, [r11, #-0x20]

; 1895 :                     if (peNextState != NULL)

  00098	e3550000	 cmp         r5, #0
  0009c	0a000004	 beq         |$LN21@TransmitHa|

; 1896 :                         {
; 1897 :                         *peNextState = DATA_TRANSMIT_STATE;

  000a0	e3a03003	 mov         r3, #3
  000a4	e5853000	 str         r3, [r5]

; 1898 :                         }
; 1899 :                     }
; 1900 :                 }
; 1901 :             else

  000a8	ea000001	 b           |$LN21@TransmitHa|
  000ac		 |$LN6@TransmitHa|

; 1902 : #endif
; 1903 :                 {
; 1904 :                 fRet = SDIPollingTransmit(pRequest->pBlockBuffer, cbTransfer);

  000ac	eb000000	 bl          |?SDIPollingTransmit@CSDIOControllerBase@@QAAHPAEK@Z|
  000b0	e50b0024	 str         r0, [r11, #-0x24]
  000b4		 |$LN21@TransmitHa|

; 1905 :                 DEBUGMSG (SHC_SDBUS_INTERACT_ZONE, (TEXT("CSDIOControllerBase::TransmitHandler: SDIPollingTransmit returns %d\r\n"), fRet));
; 1906 :                 }
; 1907 :             }
; 1908 :         }

  000b4	ea000002	 b           |$LN22@TransmitHa|
  000b8		 |$LN17@TransmitHa|

; 1910 :         {
; 1911 :         fRet = FALSE;

  000b8	e3a00000	 mov         r0, #0
  000bc	e50b0024	 str         r0, [r11, #-0x24]
  000c0	e51b4020	 ldr         r4, [r11, #-0x20]
  000c4		 |$LN22@TransmitHa|

; 1912 :         }
; 1913 : 
; 1914 :     if( !fRet )

  000c4	e3500000	 cmp         r0, #0
  000c8	1a000002	 bne         |$LN11@TransmitHa|

; 1915 :         {
; 1916 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("CSDIOControllerBase::TransmitHandler - SDIPollingTransmit() failed\r\n")));
; 1917 :         DEBUGMSG (SHC_SDBUS_INTERACT_ZONE,(TEXT("PollingTransmit failed to send %d bytes\r\n"), cbTransfer));
; 1918 :         status = SD_API_STATUS_DATA_ERROR;

  000cc	e3a04133	 mov         r4, #0x33, 2

; 1919 :         }
; 1920 :     else
; 1921 :         {
; 1922 :         DEBUGMSG (SHC_SDBUS_INTERACT_ZONE,(TEXT("PollingTransmit succesfully sent %d bytes\r\n"), cbTransfer));
; 1923 :         }
; 1924 : 
; 1925 :     return status;

  000d0	ea000000	 b           |$LN11@TransmitHa|
  000d4		 |$LN29@TransmitHa|
  000d4	e51b401c	 ldr         r4, [r11, #-0x1C]
  000d8		 |$LN11@TransmitHa|

; 1926 : }

  000d8	e1a00004	 mov         r0, r4
  000dc	e24bd018	 sub         sp, r11, #0x18
  000e0	e89d6870	 ldmia       sp, {r4 - r6, r11, sp, lr}
  000e4	e12fff1e	 bx          lr

			 ENDP  ; |?TransmitHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@PAW4SDHCCONTROLLERIST_STATE@@@Z|, CSDIOControllerBase::TransmitHandler

  000e8		 |$LN16@TransmitHa|
  000e8		 |$LN32@TransmitHa|

; 1909 :     __except(SDProcessException(GetExceptionInformation())) 

  000e8	e52de004	 str         lr, [sp, #-4]!
  000ec		 |$LN19@TransmitHa|
  000ec		 |$LN35@TransmitHa|
  000ec	eb000000	 bl          SDProcessException
  000f0		 |$LN18@TransmitHa|
  000f0	e49df004	 ldr         pc, [sp], #4
  000f4		 |$LN36@TransmitHa|
  000f4		 |$LN34@TransmitHa|
	EXPORT	|?CommandCompleteHandler_FastPath@CSDIOControllerBase@@QAAHPAU_SD_BUS_REQUEST@@@Z| ; CSDIOControllerBase::CommandCompleteHandler_FastPath
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T46048| DCD	|$LN98@CommandCom|
	DCD	0xc000c205

  00000			 AREA	 |.pdata|, PDATA
|$T46050| DCD	|$LN51@CommandCom|
	DCD	0x40000301

  00000			 AREA	 |.pdata|, PDATA
|$T46052| DCD	|$LN58@CommandCom|
	DCD	0x40000301

  00000			 AREA	 |.xdata|, DATA
|$T46046| DCD	0x2
	DCD	|$LN55@CommandCom|
	DCD	|$LN56@CommandCom|
	DCD	|$LN51@CommandCom|
	DCD	|$LN52@CommandCom|
	DCD	|$LN62@CommandCom|
	DCD	|$LN63@CommandCom|
	DCD	|$LN58@CommandCom|
	DCD	|$LN59@CommandCom|
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\sdhc\base\sdhc.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T46046|

  00008		 |?CommandCompleteHandler_FastPath@CSDIOControllerBase@@QAAHPAU_SD_BUS_REQUEST@@@Z| PROC ; CSDIOControllerBase::CommandCompleteHandler_FastPath

; 2742 : {

  00008		 |$LN98@CommandCom|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d0003	 stmdb       sp!, {r0, r1}
  00010	e92d5ff0	 stmdb       sp!, {r4 - r12, lr}
  00014	e28db028	 add         r11, sp, #0x28
  00018	e24dd008	 sub         sp, sp, #8
  0001c		 |$LN96@CommandCom|
  0001c	e1a07001	 mov         r7, r1
  00020	e58b7004	 str         r7, [r11, #4]
  00024	e1a05000	 mov         r5, r0
  00028	e58b5000	 str         r5, [r11]

; 2743 :     DWORD               dwCountStart;
; 2744 : //    PSD_BUS_REQUEST     pRequest = NULL;       // the request to complete
; 2745 :     SD_API_STATUS       status = SD_API_STATUS_PENDING;
; 2746 :     DWORD MMC_STAT_OVERWRITE = 0;
; 2747 : 
; 2748 :     DEBUGMSG(SDCARD_ZONE_FUNC, 
; 2749 :         (L"CSDIOControllerBase::CommandCompleteHandler_FastPath-"
; 2750 :          L"hDevice=0x%08X, SystemFlags=0x%08X, TransferClass=0x%08X, CommandCode=0x%08X, "
; 2751 :          L"CommandArgument=0x%08X, ResponseType=0x%08X, RequestParam=0x%08X, Status=0x%08X, "
; 2752 :          L"NumBlocks=0x%08X, BlockSize=0x%08X, HCParam=0x%08X, pBlockBuffer=0x%08X, "
; 2753 :          L"DataAccessClocks=0x%08X, Flags=0x%08X\r\n",
; 2754 :          pRequest->hDevice,
; 2755 :          pRequest->SystemFlags,
; 2756 :          pRequest->TransferClass,
; 2757 :          pRequest->CommandCode,
; 2758 :          pRequest->CommandArgument,
; 2759 :          pRequest->CommandResponse.ResponseType,
; 2760 :          pRequest->RequestParam,
; 2761 :          pRequest->Status,
; 2762 :          pRequest->NumBlocks,
; 2763 :          pRequest->BlockSize,
; 2764 :          pRequest->HCParam,
; 2765 :          pRequest->pBlockBuffer,
; 2766 :          pRequest->DataAccessClocks,
; 2767 :          pRequest->Flags)
; 2768 :          );
; 2769 : 
; 2770 :     DWORD MMC_STAT = Read_MMC_STAT();

  0002c	e3a06000	 mov         r6, #0
  00030	e28500b0	 add         r0, r5, #0xB0
  00034	e3a04001	 mov         r4, #1
  00038	e50b6030	 str         r6, [r11, #-0x30]
  0003c	eb000000	 bl          EnterCriticalSection
  00040	e595315c	 ldr         r3, [r5, #0x15C]
  00044	e28500b0	 add         r0, r5, #0xB0
  00048	e5938130	 ldr         r8, [r3, #0x130]
  0004c	eb000000	 bl          LeaveCriticalSection

; 2771 :     DWORD MMC_PSTAT = INREG32(&m_pbRegisters->MMCHS_PSTATE);

  00050	e595315c	 ldr         r3, [r5, #0x15C]
  00054	e5933124	 ldr         r3, [r3, #0x124]

; 2772 : 
; 2773 :     if( MMC_PSTAT & MMCHS_PSTAT_DATI )

  00058	e3130002	 tst         r3, #2
  0005c	0a00001c	 beq         |$LN41@CommandCom|

; 2774 :     {
; 2775 :         if( pRequest->CommandResponse.ResponseType == ResponseR1b )

  00060	e597301c	 ldr         r3, [r7, #0x1C]
  00064	e3530002	 cmp         r3, #2
  00068	1a000019	 bne         |$LN41@CommandCom|

; 2776 :         {
; 2777 :             DEBUGMSG(SHC_BUSY_STATE_ZONE, (TEXT("Card in busy state after command!  Delaying...\r\n")));
; 2778 :             // get starting tick count for timeout
; 2779 :             dwCountStart = GetTickCount();

  0006c	eb000000	 bl          GetTickCount
  00070	e1a09000	 mov         r9, r0
  00074		 |$LL43@CommandCom|

; 2780 : 
; 2781 :             do 
; 2782 :             {
; 2783 :                 MMC_STAT = Read_MMC_STAT();

  00074	e28500b0	 add         r0, r5, #0xB0
  00078	eb000000	 bl          EnterCriticalSection
  0007c	e595315c	 ldr         r3, [r5, #0x15C]
  00080	e28500b0	 add         r0, r5, #0xB0
  00084	e5938130	 ldr         r8, [r3, #0x130]
  00088	eb000000	 bl          LeaveCriticalSection

; 2784 :                 MMC_PSTAT = INREG32(&m_pbRegisters->MMCHS_PSTATE);
; 2785 : 
; 2786 :                 // check for card ejection
; 2787 :                 if( !SDCardDetect() )

  0008c	e5953000	 ldr         r3, [r5]
  00090	e595215c	 ldr         r2, [r5, #0x15C]
  00094	e1a00005	 mov         r0, r5
  00098	e593300c	 ldr         r3, [r3, #0xC]
  0009c	e592a124	 ldr         r10, [r2, #0x124]
  000a0	e1a0e00f	 mov         lr, pc
  000a4	e12fff13	 bx          r3
  000a8	e3500000	 cmp         r0, #0
  000ac	0a00002b	 beq         |$LN5@CommandCom|

; 2788 :                 {
; 2789 :                     DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDHControllerIstThread() - Card removed!\r\n")));
; 2790 :                     status = SD_API_STATUS_DEVICE_REMOVED;
; 2791 :                     goto TRANSFER_DONE;
; 2792 :                 }
; 2793 : 
; 2794 :                 // check for timeout
; 2795 :                 if (GetTickCount() - dwCountStart > m_dwMaxTimeout)

  000b0	eb000000	 bl          GetTickCount
  000b4	e5952150	 ldr         r2, [r5, #0x150]
  000b8	e0403009	 sub         r3, r0, r9
  000bc	e1530002	 cmp         r3, r2
  000c0	8a000026	 bhi         |$LN5@CommandCom|

; 2796 :                 {
; 2797 :                     DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDHControllerIstThread() - Card BUSY timeout!\r\n")));
; 2798 :                     status = SD_API_STATUS_RESPONSE_TIMEOUT;
; 2799 :                     goto TRANSFER_DONE;
; 2800 :                 }
; 2801 :             } while( (MMC_PSTAT & MMCHS_PSTAT_DATI) && !( MMC_STAT & ( MMCHS_STAT_CCRC | MMCHS_STAT_CTO | MMCHS_STAT_DCRC | MMCHS_STAT_DTO )) );

  000c4	e31a0002	 tst         r10, #2
  000c8	0a000001	 beq         |$LN41@CommandCom|
  000cc	e3180833	 tst         r8, #0x33, 16
  000d0	0affffe7	 beq         |$LL43@CommandCom|
  000d4		 |$LN41@CommandCom|

; 2802 : 
; 2803 :             DEBUGMSG(SHC_BUSY_STATE_ZONE, (TEXT("Card exited busy state.\r\n")));
; 2804 :         }
; 2805 :     }
; 2806 :     //    }
; 2807 : 
; 2808 :     if( MMC_STAT & MMCHS_STAT_CCRC ) // command CRC error

  000d4	e3180802	 tst         r8, #2, 16

; 2809 :     {
; 2810 :         status = SD_API_STATUS_CRC_ERROR;
; 2811 :         MMC_STAT_OVERWRITE |= MMCHS_STAT_CCRC;

  000d8	13a06802	 movne       r6, #2, 16
  000dc	150b6030	 strne       r6, [r11, #-0x30]
  000e0	13a04137	 movne       r4, #0x37, 2

; 2812 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDHControllerIstThread() - Got command CRC error!\r\n")));
; 2813 :     }
; 2814 :     
; 2815 :     if( MMC_STAT & MMCHS_STAT_CTO ) // command response timeout

  000e4	e3180801	 tst         r8, #1, 16

; 2816 :     {
; 2817 :         status = SD_API_STATUS_RESPONSE_TIMEOUT;
; 2818 :         MMC_STAT_OVERWRITE |= MMCHS_STAT_CTO;

  000e8	13866801	 orrne       r6, r6, #1, 16
  000ec	150b6030	 strne       r6, [r11, #-0x30]
  000f0	13a04153	 movne       r4, #0x53, 2

; 2819 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDHControllerIstThread() - Got command response timeout!\r\n")));
; 2820 :         #ifdef ENABLE_RETAIL_OUTPUT
; 2821 :             RETAILMSG(1, (L"CSDIOControllerBase::CommandCompleteHandler(MMCHS_STAT_CTO)\r\n"));
; 2822 :         #endif        
; 2823 :     }
; 2824 :     
; 2825 :     if( MMC_STAT & MMCHS_STAT_DTO ) // data timeout

  000f4	e3180601	 tst         r8, #1, 12

; 2826 :     {
; 2827 :         status = SD_API_STATUS_RESPONSE_TIMEOUT;
; 2828 :         MMC_STAT_OVERWRITE |= MMCHS_STAT_DTO;

  000f8	13866601	 orrne       r6, r6, #1, 12
  000fc	150b6030	 strne       r6, [r11, #-0x30]
  00100	13a04153	 movne       r4, #0x53, 2

; 2829 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDHControllerIstThread() - Got command response timeout!\r\n")));
; 2830 : #ifdef ENABLE_RETAIL_OUTPUT
; 2831 :         RETAILMSG(1, (L"CSDIOControllerBase::CommandCompleteHandler(MMCHS_STAT_DTO)\r\n"));
; 2832 : #endif        
; 2833 :     }
; 2834 :     
; 2835 :     if( MMC_STAT & MMCHS_STAT_DCRC ) // data CRC error

  00104	e3180602	 tst         r8, #2, 12

; 2836 :     {
; 2837 :         status = SD_API_STATUS_RESPONSE_TIMEOUT;
; 2838 :         MMC_STAT_OVERWRITE |= MMCHS_STAT_DCRC;

  00108	13866602	 orrne       r6, r6, #2, 12
  0010c	150b6030	 strne       r6, [r11, #-0x30]
  00110	13a04153	 movne       r4, #0x53, 2

; 2839 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDHControllerIstThread() - Got command response timeout!\r\n")));
; 2840 : #ifdef ENABLE_RETAIL_OUTPUT
; 2841 :         RETAILMSG(1, (L"CSDIOControllerBase::CommandCompleteHandler(MMCHS_STAT_DCRC)\r\n"));
; 2842 : #endif        
; 2843 :     }
; 2844 :     
; 2845 :     if( MMC_STAT_OVERWRITE ) // clear the status error bits

  00114	e3560000	 cmp         r6, #0
  00118	0a00002d	 beq         |$LN31@CommandCom|

; 2846 :     {
; 2847 : #ifdef ENABLE_RETAIL_OUTPUT
; 2848 :         RETAILMSG(1, (L"CSDIOControllerBase::CommandCompleteHandler(MMC_STAT_OVERWRITE)\r\n"));
; 2849 : #endif        
; 2850 :         Write_MMC_STAT(MMC_STAT_OVERWRITE);

  0011c	e28500b0	 add         r0, r5, #0xB0
  00120	eb000000	 bl          EnterCriticalSection
  00124	e595315c	 ldr         r3, [r5, #0x15C]
  00128	e28500b0	 add         r0, r5, #0xB0
  0012c	e5836130	 str         r6, [r3, #0x130]
  00130	eb000000	 bl          LeaveCriticalSection
  00134		 |$LN93@CommandCom|

; 2851 :         goto TRANSFER_DONE;

  00134	e3a02000	 mov         r2, #0
  00138		 |$TRANSFER_DONE$43196|

; 2985 :     }
; 2986 : 
; 2987 : TRANSFER_DONE:
; 2988 : 
; 2989 :     if( status == SD_API_STATUS_SUCCESS )

  00138	e3540000	 cmp         r4, #0
  0013c	1a000007	 bne         |$LN5@CommandCom|

; 2990 :     {
; 2991 :         if( m_fAppCmdMode )

  00140	e5953114	 ldr         r3, [r5, #0x114]
  00144	e3530000	 cmp         r3, #0
  00148	0a000068	 beq         |$LN8@CommandCom|

; 2992 :         {
; 2993 :             m_fAppCmdMode = FALSE;

  0014c	e5852114	 str         r2, [r5, #0x114]
  00150		 |$LN94@CommandCom|

; 2997 :         {
; 2998 :             m_fAppCmdMode = TRUE;

  00150	e3a02001	 mov         r2, #1
  00154		 |$LN6@CommandCom|

; 2999 :             DEBUGMSG(SHC_SEND_ZONE, (TEXT("SDHCBusRequestHandler - Switched to Application Specific Command Mode\n")));
; 3000 :         }
; 3001 : 
; 3002 :         if( pRequest->CommandCode == SD_CMD_MMC_SEND_OPCOND )

  00154	e5d73014	 ldrb        r3, [r7, #0x14]
  00158	e3530001	 cmp         r3, #1

; 3003 :         {
; 3004 :             DEBUGMSG(SHC_SDBUS_INTERACT_ZONE, (TEXT("SendCommand: Card is recognized as a MMC\r\n") ) );
; 3005 :             m_fMMCMode = TRUE;

  0015c	058520f8	 streq       r2, [r5, #0xF8]
  00160		 |$LN5@CommandCom|

; 3006 :         }
; 3007 :     }
; 3008 : 
; 3009 :     // Clear the MMC_STAT register
; 3010 :     MMC_STAT = Read_MMC_STAT();

  00160	e28500b0	 add         r0, r5, #0xB0
  00164	eb000000	 bl          EnterCriticalSection
  00168	e595315c	 ldr         r3, [r5, #0x15C]
  0016c	e28500b0	 add         r0, r5, #0xB0
  00170	e5934130	 ldr         r4, [r3, #0x130]
  00174	eb000000	 bl          LeaveCriticalSection

; 3011 :     Write_MMC_STAT(MMC_STAT); 

  00178	e28500b0	 add         r0, r5, #0xB0
  0017c	eb000000	 bl          EnterCriticalSection
  00180	e595315c	 ldr         r3, [r5, #0x15C]
  00184	e28500b0	 add         r0, r5, #0xB0
  00188	e5834130	 str         r4, [r3, #0x130]
  0018c	eb000000	 bl          LeaveCriticalSection

; 3012 : 
; 3013 :     if( pRequest != NULL )

  00190	e3570000	 cmp         r7, #0
  00194	0a00000a	 beq         |$LN1@CommandCom|

; 3014 :     {
; 3015 :         if( MMC_STAT_OVERWRITE ) // clear the status error bits

  00198	e3560000	 cmp         r6, #0
  0019c	0a000008	 beq         |$LN1@CommandCom|

; 3016 :       {
; 3017 :         if( !SDCardDetect() )

  001a0	e5953000	 ldr         r3, [r5]
  001a4	e1a00005	 mov         r0, r5
  001a8	e593300c	 ldr         r3, [r3, #0xC]
  001ac	e1a0e00f	 mov         lr, pc
  001b0	e12fff13	 bx          r3
  001b4	e3500000	 cmp         r0, #0

; 3018 :         {
; 3019 :           SetEvent( m_hCardDetectEvent );

  001b8	05950120	 ldreq       r0, [r5, #0x120]
  001bc	03a01003	 moveq       r1, #3
  001c0	0b000000	 bleq        EventModify
  001c4		 |$LN1@CommandCom|

; 3020 : #ifdef ENABLE_RETAIL_OUTPUT
; 3021 :           RETAILMSG(1, (L"CSDIOControllerBase::SDHCDIndicateBusRequestComplete(%x)\r\n", status));
; 3022 : #endif          
; 3023 :           // Update status according to the request type
; 3024 :                 if((status == SD_API_STATUS_SUCCESS) && (pRequest->SystemFlags & SD_FAST_PATH_AVAILABLE)) 
; 3025 :                 {
; 3026 :               status = SD_API_STATUS_FAST_PATH_SUCCESS;
; 3027 :           }
; 3028 :         }
; 3029 :       }
; 3030 :         //SDHCDIndicateBusRequestComplete(m_pHCContext, pRequest, status);
; 3031 :     }
; 3032 : 
; 3033 :     return TRUE;

  001c4	e3a00001	 mov         r0, #1
  001c8		 |$LN46@CommandCom|

; 3034 : }

  001c8	e24bd028	 sub         sp, r11, #0x28
  001cc	e89d6ff0	 ldmia       sp, {r4 - r11, sp, lr}
  001d0	e12fff1e	 bx          lr
  001d4		 |$LN31@CommandCom|

; 2852 :     }
; 2853 : 
; 2854 :     // get the response information
; 2855 :     if(pRequest->CommandResponse.ResponseType == NoResponse)

  001d4	e597301c	 ldr         r3, [r7, #0x1C]
  001d8	e3530000	 cmp         r3, #0
  001dc	0affffd4	 beq         |$LN93@CommandCom|

; 2856 :     {
; 2857 :         DEBUGMSG (SHC_SDBUS_INTERACT_ZONE,(TEXT("GetCmdResponse returned no response (no response expected)\r\n")));
; 2858 :         goto TRANSFER_DONE;
; 2859 :     }
; 2860 :     else
; 2861 :     {
; 2862 :         status =  GetCommandResponse(pRequest);

  001e0	e1a01007	 mov         r1, r7
  001e4	e1a00005	 mov         r0, r5
  001e8	eb000000	 bl          |?GetCommandResponse@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z|
  001ec	e1b04000	 movs        r4, r0

; 2863 :         if(!SD_API_SUCCESS(status))

  001f0	4affffcf	 bmi         |$LN93@CommandCom|

; 2864 :         {
; 2865 :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDHCDBusRequestHandler() - Error getting response for command:0x%02x\r\n"), pRequest->CommandCode));
; 2866 :             goto TRANSFER_DONE;     
; 2867 :         }
; 2868 :     }
; 2869 : 
; 2870 :     if (SD_COMMAND != pRequest->TransferClass) // data transfer

  001f4	e5972010	 ldr         r2, [r7, #0x10]
  001f8	e3520002	 cmp         r2, #2
  001fc	0affffcc	 beq         |$LN93@CommandCom|

; 2871 :     {
; 2872 :         DWORD cbTransfer = TRANSFER_SIZE(pRequest);

  00200	e5971040	 ldr         r1, [r7, #0x40]
  00204	e597003c	 ldr         r0, [r7, #0x3C]

; 2873 :         BOOL     fRet;
; 2874 :         BOOL     FastPathMode = FALSE;
; 2875 : 
; 2876 :         FastPathMode = (pRequest->SystemFlags & SD_FAST_PATH_AVAILABLE) ? TRUE : FALSE; 

  00208	e597300c	 ldr         r3, [r7, #0xC]
  0020c	e3130102	 tst         r3, #2, 2
  00210	13a0e001	 movne       lr, #1
  00214	03a0e000	 moveq       lr, #0

; 2877 : 
; 2878 :         switch(pRequest->TransferClass)

  00218	e3520000	 cmp         r2, #0
  0021c	0a000017	 beq         |$LN21@CommandCom|
  00220	e3520001	 cmp         r2, #1
  00224	1a000013	 bne         |$LN92@CommandCom|
  00228		 |$LN62@CommandCom|

; 2892 :             }
; 2893 :             else
; 2894 :             {
; 2895 : #ifdef DEBUG
; 2896 :                 DWORD dwTemp = 0;
; 2897 :                 while( dwTemp < cbTransfer && (dwTemp < (HEXBUFSIZE / 2 - 1) ) )
; 2898 :                 {
; 2899 :                     szHexBuf[dwTemp*2] = pRequest->pBlockBuffer[dwTemp] / 16;
; 2900 :                     szHexBuf[dwTemp*2+1] = pRequest->pBlockBuffer[dwTemp] % 16;
; 2901 : 
; 2902 :                     if( szHexBuf[dwTemp*2] < 10 )
; 2903 :                         szHexBuf[dwTemp*2] += '0';
; 2904 :                     else
; 2905 :                         szHexBuf[dwTemp*2] += 'a' - 10;
; 2906 : 
; 2907 :                     if( szHexBuf[dwTemp*2+1] < 10 )
; 2908 :                         szHexBuf[dwTemp*2+1] += '0';
; 2909 :                     else
; 2910 :                         szHexBuf[dwTemp*2+1] += 'a' - 10;
; 2911 : 
; 2912 :                     dwTemp++;
; 2913 :                 }
; 2914 :                 szHexBuf[dwTemp*2] = 0;
; 2915 :                 DEBUGMSG (SHC_SDBUS_INTERACT_ZONE,(TEXT("PollingReceive succesfully received %d bytes\r\n                                     {%S}\r\n"),
; 2916 :                     cbTransfer, szHexBuf ));
; 2917 : #ifdef ENABLE_RETAIL_OUTPUT
; 2918 :                 RETAILMSG (1,(TEXT("PollingReceive succesfully received %d bytes\r\n                                     {%S}\r\n"),
; 2919 :                     cbTransfer, szHexBuf ));
; 2920 : #endif
; 2921 : #endif
; 2922 :             }
; 2923 :             break;
; 2924 : 
; 2925 :         case SD_WRITE:
; 2926 :             {
; 2927 : #ifdef DEBUG
; 2928 :                 DWORD dwTemp = 0;
; 2929 :                 while( dwTemp < cbTransfer && (dwTemp < (HEXBUFSIZE / 2 - 1) ) )
; 2930 :                 {
; 2931 :                     szHexBuf[dwTemp*2] = pRequest->pBlockBuffer[dwTemp] / 16;
; 2932 :                     szHexBuf[dwTemp*2+1] = pRequest->pBlockBuffer[dwTemp] % 16;
; 2933 : 
; 2934 :                     if( szHexBuf[dwTemp*2] < 10 )
; 2935 :                         szHexBuf[dwTemp*2] += '0';
; 2936 :                     else
; 2937 :                         szHexBuf[dwTemp*2] += 'a' - 10;
; 2938 : 
; 2939 :                     if( szHexBuf[dwTemp*2+1] < 10 )
; 2940 :                         szHexBuf[dwTemp*2+1] += '0';
; 2941 :                     else
; 2942 :                         szHexBuf[dwTemp*2+1] += 'a' - 10;
; 2943 : 
; 2944 :                     dwTemp++;
; 2945 :                 }
; 2946 :                 szHexBuf[dwTemp*2] = 0;
; 2947 : #endif
; 2948 :             }
; 2949 : 
; 2950 :                 __try {
; 2951 :                        fRet = SDITransmit(pRequest->pBlockBuffer, cbTransfer, FastPathMode);

  00228	e5952110	 ldr         r2, [r5, #0x110]
  0022c	e3520000	 cmp         r2, #0
  00230	e0020091	 mul         r2, r1, r0
  00234	e5971048	 ldr         r1, [r7, #0x48]
  00238	e1a00005	 mov         r0, r5
  0023c	0a000002	 beq         |$LN76@CommandCom|
  00240	e1a0300e	 mov         r3, lr
  00244	eb000000	 bl          |?SDIDMATransmit@CSDIOControllerBase@@QAAHPAEKH@Z|
  00248	ea000000	 b           |$LN75@CommandCom|
  0024c		 |$LN76@CommandCom|
  0024c	eb000000	 bl          |?SDIPollingTransmit@CSDIOControllerBase@@QAAHPAEK@Z|
  00250		 |$LN75@CommandCom|
  00250	e50b002c	 str         r0, [r11, #-0x2C]
  00254		 |$LN63@CommandCom|

; 2952 :                     }

  00254	e3a02000	 mov         r2, #0
  00258	ea00001b	 b           |$LN57@CommandCom|
  0025c		 |$LN59@CommandCom|

; 2954 :                     fRet = FALSE;

  0025c	e3a02000	 mov         r2, #0
  00260	e1a00002	 mov         r0, r2
  00264	e50b202c	 str         r2, [r11, #-0x2C]
  00268	e59b5000	 ldr         r5, [r11]
  0026c	e59b7004	 ldr         r7, [r11, #4]
  00270	e51b6030	 ldr         r6, [r11, #-0x30]
  00274	ea000014	 b           |$LN57@CommandCom|
  00278		 |$LN92@CommandCom|

; 2888 :             {
; 2889 :                 DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDHCBusRequestHandler() - SDIPollingReceive() failed\r\n")));
; 2890 :                 status = SD_API_STATUS_DATA_ERROR;
; 2891 :                 goto TRANSFER_DONE;

  00278	e3a02000	 mov         r2, #0
  0027c	ea000014	 b           |$LN19@CommandCom|
  00280		 |$LN21@CommandCom|
  00280		 |$LN55@CommandCom|

; 2879 :         {
; 2880 :         case SD_READ:
; 2881 :                 __try {
; 2882 :                        fRet = SDIReceive(pRequest->pBlockBuffer, cbTransfer, FastPathMode);

  00280	e5953110	 ldr         r3, [r5, #0x110]
  00284	e3530000	 cmp         r3, #0
  00288	e0020091	 mul         r2, r1, r0
  0028c	e5971048	 ldr         r1, [r7, #0x48]
  00290	e1a00005	 mov         r0, r5
  00294	0a000002	 beq         |$LN72@CommandCom|
  00298	e1a0300e	 mov         r3, lr
  0029c	eb000000	 bl          |?SDIDMAReceive@CSDIOControllerBase@@QAAHPAEKH@Z|
  002a0	ea000000	 b           |$LN71@CommandCom|
  002a4		 |$LN72@CommandCom|
  002a4	eb000000	 bl          |?SDIPollingReceive@CSDIOControllerBase@@QAAHPAEK@Z|
  002a8		 |$LN71@CommandCom|
  002a8	e50b002c	 str         r0, [r11, #-0x2C]
  002ac		 |$LN56@CommandCom|

; 2883 :                     }

  002ac	e3a02000	 mov         r2, #0
  002b0	ea000005	 b           |$LN57@CommandCom|
  002b4		 |$LN52@CommandCom|

; 2885 :                     fRet = FALSE;

  002b4	e3a02000	 mov         r2, #0
  002b8	e1a00002	 mov         r0, r2
  002bc	e50b202c	 str         r2, [r11, #-0x2C]
  002c0	e59b5000	 ldr         r5, [r11]
  002c4	e59b7004	 ldr         r7, [r11, #4]
  002c8	e51b6030	 ldr         r6, [r11, #-0x30]
  002cc		 |$LN57@CommandCom|

; 2886 :                 }
; 2887 :             if(!fRet)

  002cc	e3500000	 cmp         r0, #0

; 2888 :             {
; 2889 :                 DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDHCBusRequestHandler() - SDIPollingReceive() failed\r\n")));
; 2890 :                 status = SD_API_STATUS_DATA_ERROR;
; 2891 :                 goto TRANSFER_DONE;

  002d0	0affffa2	 beq         |$LN5@CommandCom|
  002d4		 |$LN19@CommandCom|

; 2955 :                 }
; 2956 : 
; 2957 :             if( !fRet )
; 2958 :             {
; 2959 :                 DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDHCBusRequestHandler() - SDIPollingTransmit() failed\r\n")));
; 2960 :                 DEBUGMSG (SHC_SDBUS_INTERACT_ZONE,(TEXT("PollingTransmit failed to send %d bytes\r\n                                     {%S}\r\n"),
; 2961 :                     cbTransfer, szHexBuf ));
; 2962 : #ifdef ENABLE_RETAIL_OUTPUT
; 2963 :                 RETAILMSG (1,(TEXT("PollingTransmit failed to send %d bytes\r\n                                     {%S}\r\n"),
; 2964 :                     cbTransfer, szHexBuf ));
; 2965 : #endif
; 2966 :                 status = SD_API_STATUS_DATA_ERROR;
; 2967 :                 goto TRANSFER_DONE;
; 2968 :             }
; 2969 :             else
; 2970 :             {
; 2971 :                 DEBUGMSG (SHC_SDBUS_INTERACT_ZONE,(TEXT("PollingTransmit succesfully sent %d bytes\r\n                                     {%S}\r\n"),
; 2972 :                     cbTransfer, szHexBuf ));
; 2973 : #ifdef ENABLE_RETAIL_OUTPUT
; 2974 :                 RETAILMSG (1,(TEXT("PollingTransmit succesfully sent %d bytes\r\n                                     {%S}\r\n"),
; 2975 :                     cbTransfer, szHexBuf ));
; 2976 : #endif
; 2977 :             }
; 2978 : 
; 2979 :             break;
; 2980 :         }
; 2981 :         if(!m_fCardPresent)

  002d4	e59530f0	 ldr         r3, [r5, #0xF0]
  002d8	e3530000	 cmp         r3, #0

; 2982 :             status = SD_API_STATUS_DEVICE_REMOVED;
; 2983 :         else

  002dc	0affff9f	 beq         |$LN5@CommandCom|

; 2984 :             status = SD_API_STATUS_SUCCESS;

  002e0	e3a04000	 mov         r4, #0
  002e4	eaffff93	 b           |$TRANSFER_DONE$43196|
  002e8		 |$LN95@CommandCom|

; 3020 : #ifdef ENABLE_RETAIL_OUTPUT
; 3021 :           RETAILMSG(1, (L"CSDIOControllerBase::SDHCDIndicateBusRequestComplete(%x)\r\n", status));
; 3022 : #endif          
; 3023 :           // Update status according to the request type
; 3024 :                 if((status == SD_API_STATUS_SUCCESS) && (pRequest->SystemFlags & SD_FAST_PATH_AVAILABLE)) 
; 3025 :                 {
; 3026 :               status = SD_API_STATUS_FAST_PATH_SUCCESS;
; 3027 :           }
; 3028 :         }
; 3029 :       }
; 3030 :         //SDHCDIndicateBusRequestComplete(m_pHCContext, pRequest, status);
; 3031 :     }
; 3032 : 
; 3033 :     return TRUE;

  002e8	e51b0030	 ldr         r0, [r11, #-0x30]
  002ec	eaffffb5	 b           |$LN46@CommandCom|
  002f0		 |$LN8@CommandCom|

; 2994 :             DEBUGMSG(SHC_SEND_ZONE, (TEXT("SDHCBusRequestHandler - Switched to Standard Command Mode\n")));
; 2995 :         }
; 2996 :         else if( pRequest && pRequest->CommandCode == 55 )

  002f0	e3570000	 cmp         r7, #0
  002f4	0affff95	 beq         |$LN94@CommandCom|
  002f8	e5d73014	 ldrb        r3, [r7, #0x14]
  002fc	e3530037	 cmp         r3, #0x37
  00300	1affff92	 bne         |$LN94@CommandCom|

; 2997 :         {
; 2998 :             m_fAppCmdMode = TRUE;

  00304	e3a02001	 mov         r2, #1
  00308	e5852114	 str         r2, [r5, #0x114]
  0030c	eaffff90	 b           |$LN6@CommandCom|

			 ENDP  ; |?CommandCompleteHandler_FastPath@CSDIOControllerBase@@QAAHPAU_SD_BUS_REQUEST@@@Z|, CSDIOControllerBase::CommandCompleteHandler_FastPath

  00310		 |$LN51@CommandCom|
  00310		 |$LN97@CommandCom|

; 2884 :                 __except(SDProcessException(GetExceptionInformation())) {

  00310	e52de004	 str         lr, [sp, #-4]!
  00314		 |$LN54@CommandCom|
  00314		 |$LN101@CommandCom|
  00314	eb000000	 bl          SDProcessException
  00318		 |$LN53@CommandCom|
  00318	e49df004	 ldr         pc, [sp], #4
  0031c		 |$LN102@CommandCom|
  0031c		 |$LN58@CommandCom|
  0031c		 |$LN99@CommandCom|

; 2953 :                 __except(SDProcessException(GetExceptionInformation())) {

  0031c	e52de004	 str         lr, [sp, #-4]!
  00320		 |$LN61@CommandCom|
  00320		 |$LN103@CommandCom|
  00320	eb000000	 bl          SDProcessException
  00324		 |$LN60@CommandCom|
  00324	e49df004	 ldr         pc, [sp], #4
  00328		 |$LN104@CommandCom|
  00328		 |$LN100@CommandCom|
	EXPORT	|?SDHCSlotOptionHandlerImpl@CSDIOControllerBase@@QAAJEW4_SD_SLOT_OPTION_CODE@@PAXK@Z| ; CSDIOControllerBase::SDHCSlotOptionHandlerImpl
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T46112| DCD	|$LN70@SDHCSlotOp|
	DCD	0x4000b002
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCSlotOptionHandlerImpl@CSDIOControllerBase@@QAAJEW4_SD_SLOT_OPTION_CODE@@PAXK@Z| PROC ; CSDIOControllerBase::SDHCSlotOptionHandlerImpl

; 3063 : {

  00000		 |$LN70@SDHCSlotOp|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd028	 sub         sp, sp, #0x28
  00008		 |$M46109|
  00008	e1a04003	 mov         r4, r3
  0000c	e1a07002	 mov         r7, r2
  00010	e1a05000	 mov         r5, r0

; 3064 :     SD_API_STATUS status = SD_API_STATUS_SUCCESS;   // status
; 3065 : 
; 3066 :     UNREFERENCED_PARAMETER(SlotNumber);
; 3067 : 
; 3068 :     SDHCDAcquireHCLock(m_pHCContext);

  00014	e59510a8	 ldr         r1, [r5, #0xA8]
  00018	e3a06000	 mov         r6, #0
  0001c	e2810024	 add         r0, r1, #0x24
  00020	eb000000	 bl          EnterCriticalSection

; 3069 : 
; 3070 :     switch (Option)

  00024	e357000c	 cmp         r7, #0xC
  00028	8a00003a	 bhi         |$LN1@SDHCSlotOp|
  0002c	e1a01087	 mov         r1, r7, lsl #1
  00030	e081100f	 add         r1, r1, pc
  00034	e1d110b4	 ldrh        r1, [r1, #4]
  00038	e08ff001	 add         pc, pc, r1
  0003c		 |$LN54@SDHCSlotOp|
  0003c		 |$LN53@SDHCSlotOp|
  0003c		 |$LN55@SDHCSlotOp|
  0003c	00dc		 DCW         0xdc
  0003e		 |$LN56@SDHCSlotOp|
  0003e	0018		 DCW         0x18
  00040		 |$LN57@SDHCSlotOp|
  00040	019c		 DCW         0x19c
  00042		 |$LN58@SDHCSlotOp|
  00042	00dc		 DCW         0xdc
  00044		 |$LN59@SDHCSlotOp|
  00044	0190		 DCW         0x190
  00046		 |$LN60@SDHCSlotOp|
  00046	01a8		 DCW         0x1a8
  00048		 |$LN61@SDHCSlotOp|
  00048	01c4		 DCW         0x1c4
  0004a		 |$LN62@SDHCSlotOp|
  0004a	00d8		 DCW         0xd8
  0004c		 |$LN63@SDHCSlotOp|
  0004c	00c4		 DCW         0xc4
  0004e		 |$LN64@SDHCSlotOp|
  0004e	00f8		 DCW         0xf8
  00050		 |$LN65@SDHCSlotOp|
  00050	0118		 DCW         0x118
  00052		 |$LN66@SDHCSlotOp|
  00052	0210		 DCW         0x210
  00054		 |$LN67@SDHCSlotOp|
  00054	00b4		 DCW         0xb4
  00056		 |$LN74@SDHCSlotOp|

; 3360 :    
; 3361 :             DEBUGMSG(SDCARD_ZONE_INFO, 
; 3362 :                 (L"SHCSDSlotOptionHandler-SDHCDGetSlotInfo[out](slot=%d, "
; 3363 :                  L"Capabilities=%d, VoltageWindowMask=0x%08X, "
; 3364 :                  L"DesiredVoltageMask=0x%08X, MaxClockRate=0x%08X, "
; 3365 :                  L"PowerUpDelay=%d)\r\n",
; 3366 :                  SlotNumber, 
; 3367 :                  pSlotInfo->Capabilities,
; 3368 :                  pSlotInfo->VoltageWindowMask,
; 3369 :                  pSlotInfo->DesiredVoltageMask,
; 3370 :                  pSlotInfo->MaxClockRate,
; 3371 :                  pSlotInfo->PowerUpDelay)
; 3372 :                 ); 
; 3373 :         }
; 3374 :         break;

  00056	00b4		 DCW         0xb4
  00058		 |$LN32@SDHCSlotOp|

; 3071 :     {
; 3072 :       case SDHCDSetSlotInterface:
; 3073 :         {
; 3074 :             PSD_CARD_INTERFACE pInterface = (PSD_CARD_INTERFACE) pData;
; 3075 : 
; 3076 :             DEBUGMSG(SDCARD_ZONE_INFO, 
; 3077 :                 (L"SHCSDSlotOptionHandler-SDHCDSetSlotInterface(slot=%d, "
; 3078 :                  L"interface=0x%08X, clockrate=%d, writeprotect=%d)\r\n",
; 3079 :                  SlotNumber, pInterface->InterfaceMode, 
; 3080 :                  pInterface->ClockRate, pInterface->WriteProtected)
; 3081 :                 );
; 3082 :             
; 3083 :             // set/get internal capabilities
; 3084 :             SD_CARD_INTERFACE_EX sdCardInterfaceEx;
; 3085 :             memset(&sdCardInterfaceEx,0, sizeof(sdCardInterfaceEx));

  00058	e3a02020	 mov         r2, #0x20
  0005c	e3a01000	 mov         r1, #0
  00060	e28d0008	 add         r0, sp, #8
  00064	eb000000	 bl          memset

; 3086 :             sdCardInterfaceEx.InterfaceModeEx.bit.sd4Bit = (pInterface->InterfaceMode == SD_INTERFACE_SD_4BIT? 1: 0);

  00068	e5942000	 ldr         r2, [r4]
  0006c	e59d3008	 ldr         r3, [sp, #8]

; 3087 :             sdCardInterfaceEx.ClockRate = pInterface->ClockRate;
; 3088 :             sdCardInterfaceEx.InterfaceModeEx.bit.sdWriteProtected = (pInterface->WriteProtected?1:0);

  00070	e5940008	 ldr         r0, [r4, #8]
  00074	e3520001	 cmp         r2, #1
  00078	03a0e001	 moveq       lr, #1
  0007c	13a0e000	 movne       lr, #0
  00080	e3c32001	 bic         r2, r3, #1
  00084	e20e3001	 and         r3, lr, #1
  00088	e3500000	 cmp         r0, #0
  0008c	e1822003	 orr         r2, r2, r3
  00090	13a03001	 movne       r3, #1
  00094	03a03000	 moveq       r3, #0
  00098	e5941004	 ldr         r1, [r4, #4]
  0009c	e0223f03	 eor         r3, r2, r3, lsl #30
  000a0	e2033101	 and         r3, r3, #1, 2
  000a4	e0233002	 eor         r3, r3, r2
  000a8	e58d100c	 str         r1, [sp, #0xC]

; 3089 :             SetInterface(&sdCardInterfaceEx);

  000ac	e28d1008	 add         r1, sp, #8
  000b0	e1a00005	 mov         r0, r5
  000b4	e58d3008	 str         r3, [sp, #8]
  000b8	eb000000	 bl          |?SetInterface@CSDIOControllerBase@@QAAXPAU_SD_CARD_INTERFACE_EX@@@Z|

; 3090 : 
; 3091 :             // return internal capabilities
; 3092 :             pInterface->InterfaceMode = (sdCardInterfaceEx.InterfaceModeEx.bit.sd4Bit!=0?SD_INTERFACE_SD_4BIT:SD_INTERFACE_SD_MMC_1BIT);

  000bc	e59d1008	 ldr         r1, [sp, #8]

; 3093 :             pInterface->ClockRate =  sdCardInterfaceEx.ClockRate;

  000c0	e59d300c	 ldr         r3, [sp, #0xC]
  000c4	e3110001	 tst         r1, #1
  000c8	13a02001	 movne       r2, #1
  000cc	03a02000	 moveq       r2, #0

; 3094 :             pInterface->WriteProtected = (sdCardInterfaceEx.InterfaceModeEx.bit.sdWriteProtected!=0?TRUE:FALSE);

  000d0	e3110101	 tst         r1, #1, 2
  000d4	e5843004	 str         r3, [r4, #4]
  000d8	13a03001	 movne       r3, #1
  000dc	15843008	 strne       r3, [r4, #8]
  000e0	e5842000	 str         r2, [r4]
  000e4	1a00000c	 bne         |$LN33@SDHCSlotOp|
  000e8	e3a03000	 mov         r3, #0
  000ec	e5843008	 str         r3, [r4, #8]

; 3095 : 
; 3096 :             DEBUGMSG(SDCARD_ZONE_INFO, 
; 3097 :                 (L"SHCSDSlotOptionHandler-SDHCDSetSlotInterface(out)(slot=%d, "
; 3098 :                  L"interface=0x%08X, clockrate=%d, writeprotect=%d)\r\n",
; 3099 :                  SlotNumber, pInterface->InterfaceMode, 
; 3100 :                  pInterface->ClockRate, pInterface->WriteProtected)
; 3101 :                 );
; 3102 :         }
; 3103 :         break;

  000f0	ea000009	 b           |$LN33@SDHCSlotOp|
  000f4		 |$LN31@SDHCSlotOp|

; 3104 : 
; 3105 :         case SDHCDSetSlotInterfaceEx: 
; 3106 :             {
; 3107 :             PSD_CARD_INTERFACE_EX pInterface = (PSD_CARD_INTERFACE_EX) pData;
; 3108 : 
; 3109 :             DEBUGMSG(SDCARD_ZONE_INFO,
; 3110 :                 (L"SHCSDSlotOptionHandler-SDHCDSetSlotInterfaceEx(slot=%d, "
; 3111 :                  L"clockrate=%d, 4bit=%d, highspeed=%d, writeprotect=%d, "
; 3112 :                  L"highcapacity=%d)\r\n",
; 3113 :                  SlotNumber, pInterface->ClockRate, 
; 3114 :                  pInterface->InterfaceModeEx.bit.sd4Bit,
; 3115 :                  pInterface->InterfaceModeEx.bit.sdHighSpeed,
; 3116 :                  pInterface->InterfaceModeEx.bit.sdWriteProtected,
; 3117 :                  pInterface->InterfaceModeEx.bit.sdHighCapacity)
; 3118 :                 );
; 3119 : 
; 3120 :             // set/get internal capabilities
; 3121 :             SetInterface((PSD_CARD_INTERFACE_EX)pInterface);

  000f4	e1a01004	 mov         r1, r4
  000f8	e1a00005	 mov         r0, r5
  000fc	eb000000	 bl          |?SetInterface@CSDIOControllerBase@@QAAXPAU_SD_CARD_INTERFACE_EX@@@Z|

; 3122 : 
; 3123 :             DEBUGMSG(SDCARD_ZONE_INFO, 
; 3124 :                 (L"SHCSDSlotOptionHandler-SDHCDSetSlotInterfaceEx(out)(slot=%d, "
; 3125 :                  L"clockrate=%d, 4bit=%d, highspeed=%d, writeprotect=%d, "
; 3126 :                  L"highcapacity=%d)\r\n",
; 3127 :                  SlotNumber, pInterface->ClockRate, 
; 3128 :                  pInterface->InterfaceModeEx.bit.sd4Bit,
; 3129 :                  pInterface->InterfaceModeEx.bit.sdHighSpeed,
; 3130 :                  pInterface->InterfaceModeEx.bit.sdWriteProtected,
; 3131 :                  pInterface->InterfaceModeEx.bit.sdHighCapacity)
; 3132 :                 );
; 3133 :         }
; 3134 :         break;

  00100	ea000005	 b           |$LN33@SDHCSlotOp|
  00104		 |$LN29@SDHCSlotOp|

; 3135 : 
; 3136 :         case SDHCDSetSlotPower:
; 3137 :             {            
; 3138 :             DEBUGMSG(SDCARD_ZONE_INFO, 
; 3139 :                 (L"SHCSDSlotOptionHandler-SDHCDSetSlotPower(slot=%d, power=0x%08X)\r\n",
; 3140 :                 SlotNumber, *(DWORD*)pData)
; 3141 :                 );
; 3142 : 
; 3143 :             // this platform has 3.2V tied directly to the slot
; 3144 :             // UNDONE:
; 3145 :             //  We should save this value and propogate to subclass.
; 3146 :             }
; 3147 :         break;
; 3148 : 
; 3149 :       case SDHCDSetSlotPowerState:
; 3150 :             {
; 3151 :             // validate parameters
; 3152 :             PCEDEVICE_POWER_STATE pcps = (PCEDEVICE_POWER_STATE) pData;
; 3153 :         if( pData == NULL || OptionSize != sizeof(CEDEVICE_POWER_STATE) )

  00104	e3540000	 cmp         r4, #0
  00108	0a000002	 beq         |$LN1@SDHCSlotOp|
  0010c	e59d303c	 ldr         r3, [sp, #0x3C]
  00110	e3530004	 cmp         r3, #4
  00114	0a000000	 beq         |$LN33@SDHCSlotOp|
  00118		 |$LN1@SDHCSlotOp|

; 3375 : 
; 3376 :       default:
; 3377 :         status = SD_API_STATUS_INVALID_PARAMETER;

  00118	e3a0611f	 mov         r6, #0x1F, 2
  0011c		 |$LN33@SDHCSlotOp|

; 3378 :         break;
; 3379 :     }
; 3380 : 
; 3381 :     SDHCDReleaseHCLock(m_pHCContext);

  0011c	e59530a8	 ldr         r3, [r5, #0xA8]
  00120	e2830024	 add         r0, r3, #0x24
  00124	eb000000	 bl          LeaveCriticalSection

; 3382 :     return status;
; 3383 : }

  00128	e1a00006	 mov         r0, r6
  0012c	e28dd028	 add         sp, sp, #0x28
  00130	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00134	e12fff1e	 bx          lr
  00138		 |$LN26@SDHCSlotOp|

; 3154 :         {
; 3155 :           status = SD_API_STATUS_INVALID_PARAMETER;
; 3156 :                 break;
; 3157 :         }
; 3158 :             
; 3159 :             DEBUGMSG(SDCARD_ZONE_INFO, 
; 3160 :                 (L"SHCSDSlotOptionHandler-SDHCDSetSlotPowerState(slot=%d, powestate=0x%08X)\r\n",
; 3161 :                 SlotNumber, *pcps)
; 3162 :                 );
; 3163 :             
; 3164 :           SetSlotPowerState( *pcps );
; 3165 :         }
; 3166 :         break;
; 3167 : 
; 3168 :       case SDHCDGetSlotPowerState:
; 3169 :             {
; 3170 :             // validate parameters
; 3171 :             PCEDEVICE_POWER_STATE pcps = (PCEDEVICE_POWER_STATE) pData;
; 3172 :         if( pData == NULL || OptionSize != sizeof(CEDEVICE_POWER_STATE) )

  00138	e3540000	 cmp         r4, #0
  0013c	0afffff5	 beq         |$LN1@SDHCSlotOp|
  00140	e59d303c	 ldr         r3, [sp, #0x3C]
  00144	e3530004	 cmp         r3, #4
  00148	1afffff2	 bne         |$LN1@SDHCSlotOp|

; 3173 :         {
; 3174 :           status = SD_API_STATUS_INVALID_PARAMETER;
; 3175 :                 break;
; 3176 :         }
; 3177 :             
; 3178 :             DEBUGMSG(SDCARD_ZONE_INFO, 
; 3179 :                 (L"SHCSDSlotOptionHandler-SDHCDGetSlotPowerState(slot=%d, powestate=0x%08X)\r\n",
; 3180 :                 SlotNumber, GetSlotPowerState())
; 3181 :                 );
; 3182 :             
; 3183 :           *pcps = GetSlotPowerState();

  0014c	e3a03003	 mov         r3, #3
  00150	e5843000	 str         r3, [r4]
  00154	eafffff0	 b           |$LN33@SDHCSlotOp|
  00158		 |$LN23@SDHCSlotOp|

; 3184 :         }
; 3185 :         break;
; 3186 : 
; 3187 :       case SDHCDWakeOnSDIOInterrupts:
; 3188 :         {
; 3189 :             DEBUGMSG(SDCARD_ZONE_INFO, 
; 3190 :                 (L"SHCSDSlotOptionHandler-SDHCDWakeOnSDIOInterrupts(slot=%d, enable=0x%08X)\r\n",
; 3191 :                 SlotNumber, *(BOOL*)pData)
; 3192 :                 );
; 3193 : 
; 3194 :             // only enable SDIO wake interrupt if controller is able to
; 3195 :             BOOL bEnable = *(BOOL*)pData;
; 3196 :           if ( m_dwWakeupSources & WAKEUP_SDIO )

  00158	e59520e8	 ldr         r2, [r5, #0xE8]
  0015c	e3120001	 tst         r2, #1
  00160	0a000018	 beq         |$LN22@SDHCSlotOp|

; 3197 :           {
; 3198 :                 DWORD dwCurrentWakeupSources = m_dwWakeupSources & ~WAKEUP_SDIO;
; 3199 :                 if (bEnable) 

  00164	e5943000	 ldr         r3, [r4]
  00168	e3c24001	 bic         r4, r2, #1

; 3200 :                     {
; 3201 :               m_dwCurrentWakeupSources |= WAKEUP_SDIO;
; 3202 :             }
; 3203 : 
; 3204 :             if( m_dwCurrentWakeupSources != dwCurrentWakeupSources )
; 3205 :             {
; 3206 :                 KernelIoControl( IOCTL_HAL_ENABLE_WAKE,
; 3207 :                     &m_dwControllerSysIntr,
; 3208 :                     sizeof( m_dwControllerSysIntr ),
; 3209 :                     NULL,
; 3210 :                     0,
; 3211 :                     NULL );

  0016c	e3a0e000	 mov         lr, #0
  00170	e3530000	 cmp         r3, #0
  00174	159530ec	 ldrne       r3, [r5, #0xEC]
  00178	e3a02004	 mov         r2, #4
  0017c	e2851f4d	 add         r1, r5, #0x4D, 30
  00180	13833001	 orrne       r3, r3, #1
  00184	158530ec	 strne       r3, [r5, #0xEC]
  00188	e59530ec	 ldr         r3, [r5, #0xEC]
  0018c	e1530004	 cmp         r3, r4
  00190	e3a03000	 mov         r3, #0
  00194	0a000005	 beq         |$LN20@SDHCSlotOp|
  00198	e59f011c	 ldr         r0, [pc, #0x11C]
  0019c	e58de004	 str         lr, [sp, #4]
  001a0	e58de000	 str         lr, [sp]
  001a4	eb000000	 bl          KernelIoControl

; 3221 :             }
; 3222 : 
; 3223 :             m_dwCurrentWakeupSources = dwCurrentWakeupSources;

  001a8	e58540ec	 str         r4, [r5, #0xEC]

; 3224 :           }
; 3225 :           else

  001ac	eaffffda	 b           |$LN33@SDHCSlotOp|
  001b0		 |$LN20@SDHCSlotOp|

; 3212 :             }
; 3213 :             else
; 3214 :             {
; 3215 :                 KernelIoControl( IOCTL_HAL_DISABLE_WAKE,
; 3216 :                     &m_dwControllerSysIntr,
; 3217 :                     sizeof( m_dwControllerSysIntr ),
; 3218 :                     NULL,
; 3219 :                     0,
; 3220 :                     NULL );

  001b0	e59f0100	 ldr         r0, [pc, #0x100]
  001b4	e58de004	 str         lr, [sp, #4]
  001b8	e58de000	 str         lr, [sp]
  001bc	eb000000	 bl          KernelIoControl

; 3221 :             }
; 3222 : 
; 3223 :             m_dwCurrentWakeupSources = dwCurrentWakeupSources;

  001c0	e58540ec	 str         r4, [r5, #0xEC]

; 3224 :           }
; 3225 :           else

  001c4	eaffffd4	 b           |$LN33@SDHCSlotOp|
  001c8		 |$LN22@SDHCSlotOp|

; 3226 :           {
; 3227 :             status = SD_API_STATUS_UNSUCCESSFUL;

  001c8	e3a0610f	 mov         r6, #0xF, 2

; 3228 :           }
; 3229 :         }
; 3230 :         break;

  001cc	eaffffd2	 b           |$LN33@SDHCSlotOp|
  001d0		 |$LN17@SDHCSlotOp|

; 3231 : 
; 3232 :       case SDHCDAckSDIOInterrupt:
; 3233 :             {
; 3234 :             DEBUGMSG(SDCARD_ZONE_INFO, 
; 3235 :                     (L"SHCSDSlotOptionHandler-SDHCDAckSDIOInterrupt(slot=%d)\r\n",
; 3236 :                     SlotNumber)
; 3237 :                     );
; 3238 :             
; 3239 :         AckSDIOInterrupt();

  001d0	e1a00005	 mov         r0, r5
  001d4	eb000000	 bl          |?AckSDIOInterrupt@CSDIOControllerBase@@QAAXXZ|

; 3240 :             }
; 3241 :             break;

  001d8	eaffffcf	 b           |$LN33@SDHCSlotOp|
  001dc		 |$LN16@SDHCSlotOp|

; 3242 : 
; 3243 :         case SDHCDEnableSDIOInterrupts:
; 3244 :             {
; 3245 :             // this platform has 3.2V tied directly to the slot
; 3246 :             DEBUGMSG(SDCARD_ZONE_INFO, 
; 3247 :                 (L"SHCSDSlotOptionHandler-SDHCDEnableSDIOInterrupts(slot=%d)\r\n",
; 3248 :                 SlotNumber)
; 3249 :                 );
; 3250 :             
; 3251 :             EnableSDIOInterrupts();

  001dc	e1a00005	 mov         r0, r5
  001e0	eb000000	 bl          |?EnableSDIOInterrupts@CSDIOControllerBase@@QAAXXZ|

; 3252 :             }
; 3253 :         break;

  001e4	eaffffcc	 b           |$LN33@SDHCSlotOp|
  001e8		 |$LN14@SDHCSlotOp|

; 3254 : 
; 3255 :       case SDHCDDisableSDIOInterrupts:
; 3256 :             {
; 3257 :             DEBUGMSG(SDCARD_ZONE_INFO, 
; 3258 :                 (L"SHCSDSlotOptionHandler-SDHCDDisableSDIOInterrupts(slot=%d)\r\n",
; 3259 :                 SlotNumber)
; 3260 :                 );
; 3261 : 
; 3262 :             // UNDONE: should we disable SDIO interrupts???
; 3263 :             }
; 3264 :         break;
; 3265 : 
; 3266 :       case SDHCDGetWriteProtectStatus:
; 3267 :         {
; 3268 :           PSD_CARD_INTERFACE pInterface = (PSD_CARD_INTERFACE) pData;
; 3269 :                 
; 3270 :             DEBUGMSG(SDCARD_ZONE_INFO, 
; 3271 :                 (L"SHCSDSlotOptionHandler-SDHCDGetWriteProtectStatus(slot=%d, protected=%d)\r\n",
; 3272 :                 SlotNumber, IsWriteProtected())
; 3273 :                 );
; 3274 :             
; 3275 :           pInterface->WriteProtected = IsWriteProtected();

  001e8	e5953000	 ldr         r3, [r5]
  001ec	e1a00005	 mov         r0, r5
  001f0	e5933008	 ldr         r3, [r3, #8]
  001f4	e1a0e00f	 mov         lr, pc
  001f8	e12fff13	 bx          r3
  001fc	e5840008	 str         r0, [r4, #8]

; 3276 :         }
; 3277 :         break;

  00200	eaffffc5	 b           |$LN33@SDHCSlotOp|
  00204		 |$LN13@SDHCSlotOp|

; 3278 : 
; 3279 :       case SDHCDQueryBlockCapability:
; 3280 :         {
; 3281 :             PSD_HOST_BLOCK_CAPABILITY pBlockCaps = (PSD_HOST_BLOCK_CAPABILITY)pData;
; 3282 : 
; 3283 :           DEBUGMSG(SDCARD_ZONE_INFO,
; 3284 :                 (L"SHCSDSlotOptionHandler-SDHCDQueryBlockCapability(slot=%d, "
; 3285 :                  L"readlength=%d, readblocks=%d, writelength=%d, writeblocks=%d)\r\n",
; 3286 :                  SlotNumber, 
; 3287 :             pBlockCaps->ReadBlockSize,
; 3288 :                  pBlockCaps->ReadBlocks,
; 3289 :             pBlockCaps->WriteBlockSize,
; 3290 :                  pBlockCaps->WriteBlocks)
; 3291 :                 );            
; 3292 : 
; 3293 :             if (pBlockCaps->ReadBlockSize < STD_HC_MIN_BLOCK_LENGTH) 

  00204	e1d430b0	 ldrh        r3, [r4]
  00208	e3a01001	 mov         r1, #1
  0020c	e3530001	 cmp         r3, #1

; 3294 :                 {
; 3295 :             pBlockCaps->ReadBlockSize = STD_HC_MIN_BLOCK_LENGTH;
; 3296 :           }
; 3297 : 
; 3298 :             if (pBlockCaps->ReadBlockSize > m_usMaxBlockLen) 

  00210	e2853c01	 add         r3, r5, #1, 24
  00214	31c410b0	 strcch      r1, [r4]
  00218	e1d324bc	 ldrh        r2, [r3, #0x4C]
  0021c	e1d430b0	 ldrh        r3, [r4]
  00220	e1530002	 cmp         r3, r2

; 3299 :                 {
; 3300 :             pBlockCaps->ReadBlockSize = m_usMaxBlockLen;
; 3301 :           }
; 3302 : 
; 3303 :             if (pBlockCaps->WriteBlockSize < STD_HC_MIN_BLOCK_LENGTH) 

  00224	e1d430b2	 ldrh        r3, [r4, #2]
  00228	81c420b0	 strhih      r2, [r4]
  0022c	e3530001	 cmp         r3, #1

; 3304 :                 {
; 3305 :             pBlockCaps->WriteBlockSize = STD_HC_MIN_BLOCK_LENGTH;
; 3306 :           }
; 3307 : 
; 3308 :             if (pBlockCaps->WriteBlockSize > m_usMaxBlockLen) 

  00230	e2853c01	 add         r3, r5, #1, 24
  00234	31c410b2	 strcch      r1, [r4, #2]
  00238	e1d324bc	 ldrh        r2, [r3, #0x4C]
  0023c	e1d430b2	 ldrh        r3, [r4, #2]
  00240	e1530002	 cmp         r3, r2
  00244	9affffb4	 bls         |$LN33@SDHCSlotOp|

; 3309 :                 {
; 3310 :             pBlockCaps->WriteBlockSize = m_usMaxBlockLen;

  00248	e1c420b2	 strh        r2, [r4, #2]

; 3311 :           }
; 3312 :         }
; 3313 :         break;

  0024c	eaffffb2	 b           |$LN33@SDHCSlotOp|
  00250		 |$LN8@SDHCSlotOp|

; 3314 : 
; 3315 :       case SDHCDGetSlotInfo:
; 3316 :             {
; 3317 :             DWORD dwSlotCapabilities = SD_SLOT_SD_1BIT_CAPABLE | SD_SLOT_SDIO_CAPABLE;
; 3318 :             PSDCARD_HC_SLOT_INFO pSlotInfo = (PSDCARD_HC_SLOT_INFO)pData;
; 3319 : 
; 3320 :             // validate parameters
; 3321 :         if( OptionSize != sizeof(SDCARD_HC_SLOT_INFO) || pData == NULL )

  00250	e59d303c	 ldr         r3, [sp, #0x3C]
  00254	e3a02024	 mov         r2, #0x24
  00258	e3530014	 cmp         r3, #0x14
  0025c	1affffad	 bne         |$LN1@SDHCSlotOp|
  00260	e3540000	 cmp         r4, #0
  00264	0affffab	 beq         |$LN1@SDHCSlotOp|

; 3322 :         {
; 3323 :           status = SD_API_STATUS_INVALID_PARAMETER;
; 3324 :                 break;                  
; 3325 :         }
; 3326 : 
; 3327 :             DEBUGMSG(SDCARD_ZONE_INFO, 
; 3328 :                 (L"SHCSDSlotOptionHandler-SDHCDGetSlotInfo(slot=%d)\r\n",
; 3329 :                  SlotNumber)
; 3330 :                 ); 
; 3331 : 
; 3332 :             // SDIO 1 bit or 4 bit.
; 3333 :           if (!m_Sdio4BitDisable)

  00268	e5953190	 ldr         r3, [r5, #0x190]

; 3334 :               dwSlotCapabilities |= SD_SLOT_SD_4BIT_CAPABLE;
; 3335 : 
; 3336 :           if (!m_SdMem4BitDisable)
; 3337 :               dwSlotCapabilities |= SD_SLOT_SDMEM_4BIT_CAPABLE;
; 3338 : 
; 3339 :           if (m_dwSDHighSpeedSupport)
; 3340 :                 dwSlotCapabilities |= SD_SLOT_HIGH_SPEED_CAPABLE;
; 3341 : 
; 3342 :           if (!IsMultipleBlockReadSupported())
; 3343 :               dwSlotCapabilities |= SD_SLOT_USE_SOFT_BLOCK_CMD53_READ;
; 3344 : 
; 3345 :           SDHCDSetSlotCapabilities( pSlotInfo,dwSlotCapabilities);
; 3346 : 
; 3347 :           SDHCDSetVoltageWindowMask(pSlotInfo,(SD_VDD_WINDOW_3_1_TO_3_2 |
; 3348 :                                                SD_VDD_WINDOW_3_2_TO_3_3 |
; 3349 :                                                SD_VDD_WINDOW_3_3_TO_3_4 |
; 3350 :                                                SD_VDD_WINDOW_3_4_TO_3_5 |
; 3351 :                                                SD_VDD_WINDOW_3_5_TO_3_6));
; 3352 :           // Set optimal voltage
; 3353 :           SDHCDSetDesiredSlotVoltage(pSlotInfo, SD_VDD_WINDOW_2_9_TO_3_0);

  0026c	e3a01802	 mov         r1, #2, 16
  00270	e3530000	 cmp         r3, #0
  00274	e5953194	 ldr         r3, [r5, #0x194]
  00278	03a0202c	 moveq       r2, #0x2C
  0027c	e3530000	 cmp         r3, #0
  00280	e5953198	 ldr         r3, [r5, #0x198]
  00284	03822040	 orreq       r2, r2, #0x40
  00288	e5841008	 str         r1, [r4, #8]
  0028c	e3530000	 cmp         r3, #0
  00290	13822010	 orrne       r2, r2, #0x10
  00294	e3823b02	 orr         r3, r2, #2, 22
  00298	e3a0273e	 mov         r2, #0x3E, 14
  0029c	e5842004	 str         r2, [r4, #4]
  002a0	e5843000	 str         r3, [r4]

; 3354 : 
; 3355 :           // Set maximum supported clock rate
; 3356 :           SDHCDSetMaxClockRate(pSlotInfo, m_dwMaxClockRate);

  002a4	e5953148	 ldr         r3, [r5, #0x148]

; 3357 : 
; 3358 :           // set power up delay
; 3359 :           SDHCDSetPowerUpDelay(pSlotInfo, 100);

  002a8	e3a02064	 mov         r2, #0x64
  002ac	e5842010	 str         r2, [r4, #0x10]
  002b0	e584300c	 str         r3, [r4, #0xC]

; 3360 :    
; 3361 :             DEBUGMSG(SDCARD_ZONE_INFO, 
; 3362 :                 (L"SHCSDSlotOptionHandler-SDHCDGetSlotInfo[out](slot=%d, "
; 3363 :                  L"Capabilities=%d, VoltageWindowMask=0x%08X, "
; 3364 :                  L"DesiredVoltageMask=0x%08X, MaxClockRate=0x%08X, "
; 3365 :                  L"PowerUpDelay=%d)\r\n",
; 3366 :                  SlotNumber, 
; 3367 :                  pSlotInfo->Capabilities,
; 3368 :                  pSlotInfo->VoltageWindowMask,
; 3369 :                  pSlotInfo->DesiredVoltageMask,
; 3370 :                  pSlotInfo->MaxClockRate,
; 3371 :                  pSlotInfo->PowerUpDelay)
; 3372 :                 ); 
; 3373 :         }
; 3374 :         break;

  002b4	eaffff98	 b           |$LN33@SDHCSlotOp|
  002b8		 |$LN71@SDHCSlotOp|
  002b8		 |$LN72@SDHCSlotOp|
  002b8	010100a4	 DCD         0x10100a4
  002bc		 |$LN73@SDHCSlotOp|
  002bc	010100a0	 DCD         0x10100a0
  002c0		 |$M46110|

			 ENDP  ; |?SDHCSlotOptionHandlerImpl@CSDIOControllerBase@@QAAJEW4_SD_SLOT_OPTION_CODE@@PAXK@Z|, CSDIOControllerBase::SDHCSlotOptionHandlerImpl

	EXPORT	|?SDHCSlotOptionHandler@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@KW4_SD_SLOT_OPTION_CODE@@PAXK@Z| ; CSDIOControllerBase::SDHCSlotOptionHandler

  00000			 AREA	 |.pdata|, PDATA
|$T46130| DCD	|$LN5@SDHCSlotOp@2|
	DCD	0x40000a02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCSlotOptionHandler@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@KW4_SD_SLOT_OPTION_CODE@@PAXK@Z| PROC ; CSDIOControllerBase::SDHCSlotOptionHandler

; 3416 : {

  00000		 |$LN5@SDHCSlotOp@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M46127|

; 3417 :     // get our extension
; 3418 :     CSDIOControllerBase *pController = GET_PCONTROLLER_FROM_HCD(pHCContext);
; 3419 :     return pController->SDHCSlotOptionHandlerImpl((UCHAR)SlotNumber,
; 3420 :         Option,
; 3421 :         pData,
; 3422 :         OptionSize );

  00008	e59de008	 ldr         lr, [sp, #8]
  0000c	e590004c	 ldr         r0, [r0, #0x4C]
  00010	e20110ff	 and         r1, r1, #0xFF
  00014	e58de000	 str         lr, [sp]
  00018	eb000000	 bl          |?SDHCSlotOptionHandlerImpl@CSDIOControllerBase@@QAAJEW4_SD_SLOT_OPTION_CODE@@PAXK@Z|

; 3423 : }

  0001c	e28dd004	 add         sp, sp, #4
  00020	e49de004	 ldr         lr, [sp], #4
  00024	e12fff1e	 bx          lr
  00028		 |$M46128|

			 ENDP  ; |?SDHCSlotOptionHandler@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@KW4_SD_SLOT_OPTION_CODE@@PAXK@Z|, CSDIOControllerBase::SDHCSlotOptionHandler

	EXPORT	|?CommandTransferCompleteHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@KPAW4SDHCCONTROLLERIST_STATE@@@Z| ; CSDIOControllerBase::CommandTransferCompleteHandler

  00000			 AREA	 |.pdata|, PDATA
|$T46167| DCD	|$LN37@CommandTra|
	DCD	0x40006802
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CommandTransferCompleteHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@KPAW4SDHCCONTROLLERIST_STATE@@@Z| PROC ; CSDIOControllerBase::CommandTransferCompleteHandler

; 1687 : {

  00000		 |$LN37@CommandTra|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M46164|
  00008	e1a09003	 mov         r9, r3
  0000c	e1a07001	 mov         r7, r1
  00010	e1a05000	 mov         r5, r0

; 1688 :     SDHCCONTROLLERIST_STATE eNextControllerState = COMMAND_TRANSFER_STATE;
; 1689 :     DWORD           dwStatusOverwrite = 0;
; 1690 :     SD_API_STATUS   status            = SD_API_STATUS_PENDING;
; 1691 :     DWORD           MMC_STAT          = Read_MMC_STAT();

  00014	e3a08001	 mov         r8, #1
  00018	e3a0a000	 mov         r10, #0
  0001c	e28500b0	 add         r0, r5, #0xB0
  00020	e58d8000	 str         r8, [sp]
  00024	e58da004	 str         r10, [sp, #4]
  00028	e3a06001	 mov         r6, #1
  0002c	eb000000	 bl          EnterCriticalSection
  00030	e595215c	 ldr         r2, [r5, #0x15C]
  00034	e28500b0	 add         r0, r5, #0xB0
  00038	e5924130	 ldr         r4, [r2, #0x130]
  0003c	eb000000	 bl          LeaveCriticalSection

; 1692 : 
; 1693 :     UNREFERENCED_PARAMETER(dwIntrStatus);
; 1694 : 
; 1695 :     DEBUGMSG(SHC_SDBUS_INTERACT_ZONE, (TEXT("+CSDIOControllerBase::CommandTransferCompleteHandler\r\n")));
; 1696 : 
; 1697 :     // get and lock the current bus request
; 1698 :     if (pRequest == NULL)

  00040	e3570000	 cmp         r7, #0
  00044	1a000007	 bne         |$LN20@CommandTra|

; 1699 :         {
; 1700 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("CSDIOControllerBase::CommandTransferCompleteHandler - Unable to get/lock current request!\r\n")));
; 1701 :         status = SD_API_STATUS_INVALID_DEVICE_REQUEST;
; 1702 : 
; 1703 :         Write_MMC_STAT(MMC_STAT);

  00048	e28500b0	 add         r0, r5, #0xB0
  0004c	e3a06127	 mov         r6, #0x27, 2
  00050	eb000000	 bl          EnterCriticalSection
  00054	e595315c	 ldr         r3, [r5, #0x15C]
  00058	e28500b0	 add         r0, r5, #0xB0
  0005c	e5834130	 str         r4, [r3, #0x130]
  00060	eb000000	 bl          LeaveCriticalSection
  00064	ea000042	 b           |$LN33@CommandTra|
  00068		 |$LN20@CommandTra|

; 1704 : 
; 1705 :         goto TRANSFER_DONE;
; 1706 :         }
; 1707 : 
; 1708 :     DWORD MMC_PSTAT = INREG32(&m_pbRegisters->MMCHS_PSTATE);

  00068	e595315c	 ldr         r3, [r5, #0x15C]
  0006c	e5933124	 ldr         r3, [r3, #0x124]

; 1709 :  
; 1710 :     if ((MMC_PSTAT & MMCHS_PSTAT_DATI) && (pRequest->CommandResponse.ResponseType == ResponseR1b))

  00070	e3130002	 tst         r3, #2
  00074	0a00000c	 beq         |$LN17@CommandTra|
  00078	e597301c	 ldr         r3, [r7, #0x1C]
  0007c	e3530002	 cmp         r3, #2
  00080	1a000009	 bne         |$LN17@CommandTra|

; 1711 :         {
; 1712 :         if (!( MMC_STAT & ( MMCHS_STAT_CCRC | MMCHS_STAT_CTO | MMCHS_STAT_DCRC | MMCHS_STAT_DTO) ))

  00084	e3140833	 tst         r4, #0x33, 16
  00088	1a000007	 bne         |$LN17@CommandTra|

; 1713 :             {
; 1714 :             eNextControllerState = CARDBUSY_STATE;
; 1715 : 
; 1716 :             Write_MMC_STAT(MMC_STAT);

  0008c	e28500b0	 add         r0, r5, #0xB0
  00090	e3a08004	 mov         r8, #4
  00094	eb000000	 bl          EnterCriticalSection
  00098	e595315c	 ldr         r3, [r5, #0x15C]
  0009c	e28500b0	 add         r0, r5, #0xB0
  000a0	e5834130	 str         r4, [r3, #0x130]
  000a4	eb000000	 bl          LeaveCriticalSection
  000a8	ea000036	 b           |$cleanUp$42829|
  000ac		 |$LN17@CommandTra|

; 1717 : 
; 1718 :             goto cleanUp;
; 1719 :             }
; 1720 :         }
; 1721 : 
; 1722 :     status = CheckIntrStatus(MMC_STAT, &dwStatusOverwrite);

  000ac	e28d2004	 add         r2, sp, #4
  000b0	e1a01004	 mov         r1, r4
  000b4	e1a00005	 mov         r0, r5
  000b8	eb000000	 bl          |?CheckIntrStatus@CSDIOControllerBase@@QAAJKPAK@Z|

; 1723 : 
; 1724 :     if (dwStatusOverwrite != 0)

  000bc	e59da004	 ldr         r10, [sp, #4]
  000c0	e1a06000	 mov         r6, r0
  000c4	e35a0000	 cmp         r10, #0
  000c8	1a000029	 bne         |$LN33@CommandTra|

; 1725 :         {
; 1726 :         goto TRANSFER_DONE;
; 1727 :         }
; 1728 : 
; 1729 :     // get the response information
; 1730 :     if(pRequest->CommandResponse.ResponseType == NoResponse)

  000cc	e597301c	 ldr         r3, [r7, #0x1C]
  000d0	e3530000	 cmp         r3, #0
  000d4	0a000026	 beq         |$LN33@CommandTra|

; 1731 :         {
; 1732 :         DEBUGMSG (SHC_SDBUS_INTERACT_ZONE,(TEXT("GetCmdResponse returned no response (no response expected)\r\n")));
; 1733 :         goto TRANSFER_DONE;
; 1734 :         }
; 1735 :     else
; 1736 :         {
; 1737 :         status =  GetCommandResponse(pRequest);

  000d8	e1a01007	 mov         r1, r7
  000dc	e1a00005	 mov         r0, r5
  000e0	eb000000	 bl          |?GetCommandResponse@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z|
  000e4	e1b06000	 movs        r6, r0

; 1738 :         if(!SD_API_SUCCESS(status))

  000e8	4a000021	 bmi         |$LN33@CommandTra|

; 1739 :             {
; 1740 :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDHCDBusRequestHandler() - Error getting response for command:0x%02x\r\n"), pRequest->CommandCode));
; 1741 :             goto TRANSFER_DONE;
; 1742 :             }
; 1743 :         }
; 1744 : 
; 1745 :     switch(pRequest->TransferClass)

  000ec	e5973010	 ldr         r3, [r7, #0x10]
  000f0	e3530000	 cmp         r3, #0
  000f4	0a000013	 beq         |$LN6@CommandTra|
  000f8	e3530001	 cmp         r3, #1
  000fc	0a00000c	 beq         |$LN5@CommandTra|

; 1755 :         default:
; 1756 :             MMC_STAT = Read_MMC_STAT();

  00100	e28500b0	 add         r0, r5, #0xB0
  00104	eb000000	 bl          EnterCriticalSection
  00108	e595315c	 ldr         r3, [r5, #0x15C]
  0010c	e28500b0	 add         r0, r5, #0xB0
  00110	e5934130	 ldr         r4, [r3, #0x130]
  00114	eb000000	 bl          LeaveCriticalSection

; 1757 :             Write_MMC_STAT(MMC_STAT);

  00118	e28500b0	 add         r0, r5, #0xB0
  0011c	eb000000	 bl          EnterCriticalSection
  00120	e595315c	 ldr         r3, [r5, #0x15C]
  00124	e28500b0	 add         r0, r5, #0xB0
  00128	e5834130	 str         r4, [r3, #0x130]
  0012c	eb000000	 bl          LeaveCriticalSection

; 1758 :             DEBUGMSG (SHC_SDBUS_INTERACT_ZONE, (TEXT("+CSDIOControllerBase::CommandTransferCompleteHandler: command completed.\r\n")));
; 1759 :             break;

  00130	ea00000a	 b           |$LN7@CommandTra|
  00134		 |$LN5@CommandTra|

; 1749 :             DEBUGMSG (SHC_SDBUS_INTERACT_ZONE, (TEXT("+CSDIOControllerBase::CommandTransferCompleteHandler ReceiveHandler returns %d, %d\r\n"), status, eNextControllerState));
; 1750 :             break;
; 1751 :         case SD_WRITE:
; 1752 :             status = TransmitHandler(pRequest, &eNextControllerState);

  00134	e28d2000	 add         r2, sp, #0
  00138	e1a01007	 mov         r1, r7
  0013c	e1a00005	 mov         r0, r5
  00140	eb000000	 bl          |?TransmitHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@PAW4SDHCCONTROLLERIST_STATE@@@Z|

; 1753 :             DEBUGMSG (SHC_SDBUS_INTERACT_ZONE, (TEXT("+CSDIOControllerBase::CommandTransferCompleteHandler calling TransmitHandler returns %d, %d\r\n"), status, eNextControllerState));
; 1754 :             break;

  00144	ea000003	 b           |$LN34@CommandTra|
  00148		 |$LN6@CommandTra|

; 1746 :         {
; 1747 :         case SD_READ:
; 1748 :             status = ReceiveHandler(pRequest, &eNextControllerState);

  00148	e28d2000	 add         r2, sp, #0
  0014c	e1a01007	 mov         r1, r7
  00150	e1a00005	 mov         r0, r5
  00154	eb000000	 bl          |?ReceiveHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@PAW4SDHCCONTROLLERIST_STATE@@@Z|
  00158		 |$LN34@CommandTra|
  00158	e59d8000	 ldr         r8, [sp]
  0015c	e1a06000	 mov         r6, r0
  00160		 |$LN7@CommandTra|

; 1760 :         }
; 1761 : 
; 1762 :     if(!m_fCardPresent)

  00160	e59520f0	 ldr         r2, [r5, #0xF0]
  00164	e3520000	 cmp         r2, #0

; 1763 :         {
; 1764 :         status = SD_API_STATUS_DEVICE_REMOVED;

  00168	03a06147	 moveq       r6, #0x47, 2
  0016c		 |$TRANSFER_DONE$42823|

; 1765 :         }
; 1766 : 
; 1767 : TRANSFER_DONE:
; 1768 : 
; 1769 :     if (eNextControllerState == COMMAND_TRANSFER_STATE)

  0016c	e3580001	 cmp         r8, #1
  00170	1a000004	 bne         |$cleanUp$42829|
  00174		 |$LN33@CommandTra|

; 1770 :         {
; 1771 :         ProcessCommandTransferStatus(pRequest, status, dwStatusOverwrite);

  00174	e1a0300a	 mov         r3, r10
  00178	e1a02006	 mov         r2, r6
  0017c	e1a01007	 mov         r1, r7
  00180	e1a00005	 mov         r0, r5
  00184	eb000000	 bl          |?ProcessCommandTransferStatus@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@JK@Z|
  00188		 |$cleanUp$42829|

; 1772 :         }
; 1773 : 
; 1774 : cleanUp:
; 1775 : 
; 1776 :     if (pNextState != NULL)

  00188	e3590000	 cmp         r9, #0

; 1777 :         {
; 1778 :         *pNextState = eNextControllerState;

  0018c	15898000	 strne       r8, [r9]

; 1779 :         }
; 1780 :     
; 1781 :     return status;
; 1782 : }

  00190	e1a00006	 mov         r0, r6
  00194	e28dd008	 add         sp, sp, #8
  00198	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  0019c	e12fff1e	 bx          lr
  001a0		 |$M46165|

			 ENDP  ; |?CommandTransferCompleteHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@KPAW4SDHCCONTROLLERIST_STATE@@@Z|, CSDIOControllerBase::CommandTransferCompleteHandler

	EXPORT	|?CardBusyCompletedHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@KPAW4SDHCCONTROLLERIST_STATE@@@Z| ; CSDIOControllerBase::CardBusyCompletedHandler

  00000			 AREA	 |.pdata|, PDATA
|$T46180| DCD	|$LN5@CardBusyCo|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CardBusyCompletedHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@KPAW4SDHCCONTROLLERIST_STATE@@@Z| PROC ; CSDIOControllerBase::CardBusyCompletedHandler

; 2220 : {

  00000		 |$LN5@CardBusyCo|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46177|

; 2221 :     // when card busy is complete, process it as a normal command complete interrupt.
; 2222 :     return CommandTransferCompleteHandler(pRequest, dwIntrStatus, pNextState);

  00004	eb000000	 bl          |?CommandTransferCompleteHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@KPAW4SDHCCONTROLLERIST_STATE@@@Z|

; 2223 : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M46178|

			 ENDP  ; |?CardBusyCompletedHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@KPAW4SDHCCONTROLLERIST_STATE@@@Z|, CSDIOControllerBase::CardBusyCompletedHandler

	EXPORT	|?SDHCBusRequestHandlerImpl_FastPath@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z| ; CSDIOControllerBase::SDHCBusRequestHandlerImpl_FastPath

  00000			 AREA	 |.pdata|, PDATA
|$T46211| DCD	|$LN22@SDHCBusReq@2|
	DCD	0x40006701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCBusRequestHandlerImpl_FastPath@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z| PROC ; CSDIOControllerBase::SDHCBusRequestHandlerImpl_FastPath

; 2558 : {

  00000		 |$LN22@SDHCBusReq@2|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M46208|
  00004	e1a08001	 mov         r8, r1
  00008	e1a05000	 mov         r5, r0

; 2559 :     DEBUGCHK(pRequest);
; 2560 : 
; 2561 :     SD_API_STATUS   status = SD_API_STATUS_FAST_PATH_SUCCESS;
; 2562 :     WORD            wIe;
; 2563 :     m_fastPathReq = 1;

  0000c	e3a03001	 mov         r3, #1

; 2564 : 
; 2565 :     // turn the clock on
; 2566 :     UpdateSystemClock(TRUE);

  00010	e3a01001	 mov         r1, #1
  00014	e5853188	 str         r3, [r5, #0x188]
  00018	eb000000	 bl          |?UpdateSystemClock@CSDIOControllerBase@@QAAHH@Z|

; 2567 : 
; 2568 :     // acquire the device lock to protect from device removal
; 2569 :     SDHCDAcquireHCLock(m_pHCContext);

  0001c	e59530a8	 ldr         r3, [r5, #0xA8]
  00020	e2830024	 add         r0, r3, #0x24
  00024	eb000000	 bl          EnterCriticalSection

; 2570 :     //m_fastPathSDMEM = 1;
; 2571 : 
; 2572 :     // ??? check register handling, seems odd
; 2573 :     // Disable SDIO interrupt for Fast path
; 2574 :     wIe = (WORD)INREG32(&(m_pbRegisters->MMCHS_IE));

  00028	e595315c	 ldr         r3, [r5, #0x15C]

; 2575 :     EnterCriticalSection( &m_critSec );

  0002c	e28500b0	 add         r0, r5, #0xB0
  00030	e5933134	 ldr         r3, [r3, #0x134]
  00034	e1a09803	 mov         r9, r3, lsl #16
  00038	e1a09829	 mov         r9, r9, lsr #16
  0003c	eb000000	 bl          EnterCriticalSection

; 2576 :     SETREG32(&m_pbRegisters->MMCHS_CON, MMCHS_CON_CTPL);

  00040	e595215c	 ldr         r2, [r5, #0x15C]

; 2577 : 
; 2578 :     SETREG32(&(m_pbRegisters->MMCHS_IE) , (/* MMCHS_IE_CIRQ | */ MMCHS_IE_CC | MMCHS_IE_TC));
; 2579 :     CLRREG32(&(m_pbRegisters->MMCHS_ISE) , (/*MMCHS_ISE_CIRQ |*/ MMCHS_ISE_CC | MMCHS_ISE_TC));
; 2580 :     OUTREG32(&m_pbRegisters->MMCHS_STAT, 0xFFFFFFFF);

  00044	e3e0a000	 mvn         r10, #0

; 2581 :     LeaveCriticalSection( &m_critSec );

  00048	e28500b0	 add         r0, r5, #0xB0
  0004c	e592302c	 ldr         r3, [r2, #0x2C]
  00050	e3833b02	 orr         r3, r3, #2, 22
  00054	e582302c	 str         r3, [r2, #0x2C]
  00058	e595215c	 ldr         r2, [r5, #0x15C]
  0005c	e5923134	 ldr         r3, [r2, #0x134]
  00060	e3833003	 orr         r3, r3, #3
  00064	e5823134	 str         r3, [r2, #0x134]
  00068	e595215c	 ldr         r2, [r5, #0x15C]
  0006c	e5923138	 ldr         r3, [r2, #0x138]
  00070	e3c33003	 bic         r3, r3, #3
  00074	e5823138	 str         r3, [r2, #0x138]
  00078	e595315c	 ldr         r3, [r5, #0x15C]
  0007c	e583a130	 str         r10, [r3, #0x130]
  00080	eb000000	 bl          LeaveCriticalSection

; 2582 : 
; 2583 :     status = SendCommand(pRequest);

  00084	e1a01008	 mov         r1, r8
  00088	e1a00005	 mov         r0, r5
  0008c	eb000000	 bl          |?SendCommand@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z|
  00090	e1b07000	 movs        r7, r0

; 2584 :     if (!SD_API_SUCCESS(status))
; 2585 :     {
; 2586 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDHCDBusRequestHandler() - Error sending command:0x%02x\r\n"), pRequest->CommandCode));
; 2587 :         SDHCDReleaseHCLock(m_pHCContext);

  00094	459530a8	 ldrmi       r3, [r5, #0xA8]
  00098	42830024	 addmi       r0, r3, #0x24
  0009c	4a00002a	 bmi         |$LN17@SDHCBusReq@2|

; 2588 :         goto cleanUp;      
; 2589 :     }
; 2590 : 
; 2591 :     {
; 2592 :        DWORD retries = 0;
; 2593 :        status = SD_API_STATUS_DEVICE_RESPONSE_ERROR;
; 2594 :  
; 2595 :        // polling end-of-command
; 2596 :        while (!(Read_MMC_STAT() & MMCHS_STAT_CC)) {

  000a0	e3a06000	 mov         r6, #0
  000a4	e3a0715b	 mov         r7, #0x5B, 2
  000a8	ea000002	 b           |$LN19@SDHCBusReq@2|
  000ac		 |$LL5@SDHCBusReq@2|

; 2597 :            if (retries > SDIO_MAX_LOOP) {

  000ac	e3560702	 cmp         r6, #2, 14
  000b0	8a00002c	 bhi         |$LN15@SDHCBusReq@2|

; 2602 :                     DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDHCBusRequestHandler() - MMCHS_STAT_CTO\r\n")));
; 2603 :                 }
; 2604 :                 DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDHCBusRequestHandler() - Timeout waiting for MMCHS_STAT_CC\r\n")));
; 2605 :                 goto cleanUp;      
; 2606 :            }
; 2607 :            retries++;

  000b4	e2866001	 add         r6, r6, #1
  000b8		 |$LN19@SDHCBusReq@2|

; 2597 :            if (retries > SDIO_MAX_LOOP) {

  000b8	e28500b0	 add         r0, r5, #0xB0

; 2602 :                     DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDHCBusRequestHandler() - MMCHS_STAT_CTO\r\n")));
; 2603 :                 }
; 2604 :                 DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDHCBusRequestHandler() - Timeout waiting for MMCHS_STAT_CC\r\n")));
; 2605 :                 goto cleanUp;      
; 2606 :            }
; 2607 :            retries++;

  000bc	eb000000	 bl          EnterCriticalSection
  000c0	e595315c	 ldr         r3, [r5, #0x15C]
  000c4	e28500b0	 add         r0, r5, #0xB0
  000c8	e5934130	 ldr         r4, [r3, #0x130]
  000cc	eb000000	 bl          LeaveCriticalSection
  000d0	e3140001	 tst         r4, #1
  000d4	0afffff4	 beq         |$LL5@SDHCBusReq@2|

; 2608 :        }
; 2609 : 
; 2610 :        CommandCompleteHandler_FastPath(pRequest);

  000d8	e1a01008	 mov         r1, r8
  000dc	e1a00005	 mov         r0, r5
  000e0	eb000000	 bl          |?CommandCompleteHandler_FastPath@CSDIOControllerBase@@QAAHPAU_SD_BUS_REQUEST@@@Z|

; 2611 : 
; 2612 :        SDHCDReleaseHCLock(m_pHCContext);

  000e4	e59530a8	 ldr         r3, [r5, #0xA8]
  000e8	e2830024	 add         r0, r3, #0x24
  000ec	eb000000	 bl          LeaveCriticalSection

; 2613 : 
; 2614 :        status = SD_API_STATUS_FAST_PATH_SUCCESS;
; 2615 :             }
; 2616 : 
; 2617 :     // Restore SDIO interrupts
; 2618 :     EnterCriticalSection( &m_critSec );

  000f0	e28500b0	 add         r0, r5, #0xB0
  000f4	e3a07002	 mov         r7, #2
  000f8	eb000000	 bl          EnterCriticalSection

; 2619 :     // ??? check register handling, seems odd...
; 2620 :     CLRREG32(&(m_pbRegisters->MMCHS_IE) , (MMCHS_IE_CIRQ | MMCHS_IE_CC | MMCHS_IE_TC));

  000fc	e595015c	 ldr         r0, [r5, #0x15C]
  00100	e3e03c01	 mvn         r3, #1, 24
  00104	e2231003	 eor         r1, r3, #3
  00108	e5903134	 ldr         r3, [r0, #0x134]
  0010c	e3a02c01	 mov         r2, #1, 24

; 2621 :     SETREG32(&(m_pbRegisters->MMCHS_IE), (wIe & (MMCHS_IE_CIRQ | MMCHS_IE_CC | MMCHS_IE_TC)));

  00110	e3822003	 orr         r2, r2, #3
  00114	e0033001	 and         r3, r3, r1
  00118	e5803134	 str         r3, [r0, #0x134]
  0011c	e595115c	 ldr         r1, [r5, #0x15C]
  00120	e009e002	 and         lr, r9, r2

; 2622 :     SETREG32(&(m_pbRegisters->MMCHS_ISE), (wIe & (MMCHS_ISE_CIRQ | MMCHS_ISE_CC | MMCHS_ISE_TC)));
; 2623 :     OUTREG32(&m_pbRegisters->MMCHS_STAT, 0xFFFFFFFF);
; 2624 :     LeaveCriticalSection( &m_critSec );

  00124	e28500b0	 add         r0, r5, #0xB0
  00128	e5913134	 ldr         r3, [r1, #0x134]
  0012c	e183300e	 orr         r3, r3, lr
  00130	e5813134	 str         r3, [r1, #0x134]
  00134	e595215c	 ldr         r2, [r5, #0x15C]
  00138	e5923138	 ldr         r3, [r2, #0x138]
  0013c	e183300e	 orr         r3, r3, lr
  00140	e5823138	 str         r3, [r2, #0x138]
  00144	e595315c	 ldr         r3, [r5, #0x15C]
  00148	e583a130	 str         r10, [r3, #0x130]
  0014c		 |$LN17@SDHCBusReq@2|
  0014c	eb000000	 bl          LeaveCriticalSection
  00150		 |$cleanUp$43117|

; 2627 : 
; 2628 :     UpdateSystemClock(FALSE);

  00150	e3a01000	 mov         r1, #0
  00154	e1a00005	 mov         r0, r5
  00158	eb000000	 bl          |?UpdateSystemClock@CSDIOControllerBase@@QAAHH@Z|

; 2629 : 
; 2630 :     return status;
; 2631 : 
; 2632 :                 }

  0015c	e1a00007	 mov         r0, r7
  00160	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00164	e12fff1e	 bx          lr
  00168		 |$LN15@SDHCBusReq@2|

; 2598 :                 SDHCDReleaseHCLock(m_pHCContext);

  00168	e59530a8	 ldr         r3, [r5, #0xA8]
  0016c	e2830024	 add         r0, r3, #0x24
  00170	eb000000	 bl          LeaveCriticalSection

; 2599 :                 if(Read_MMC_STAT() & MMCHS_STAT_CTO)

  00174	e28500b0	 add         r0, r5, #0xB0
  00178	eb000000	 bl          EnterCriticalSection
  0017c	e595315c	 ldr         r3, [r5, #0x15C]
  00180	e28500b0	 add         r0, r5, #0xB0
  00184	e5934130	 ldr         r4, [r3, #0x130]
  00188	eb000000	 bl          LeaveCriticalSection
  0018c	e3140801	 tst         r4, #1, 16
  00190	0affffee	 beq         |$cleanUp$43117|

; 2600 :                 {
; 2601 :                     status = SD_API_STATUS_RESPONSE_TIMEOUT;

  00194	e3a07153	 mov         r7, #0x53, 2

; 2625 : 
; 2626 : cleanUp:

  00198	eaffffec	 b           |$cleanUp$43117|
  0019c		 |$M46209|

			 ENDP  ; |?SDHCBusRequestHandlerImpl_FastPath@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z|, CSDIOControllerBase::SDHCBusRequestHandlerImpl_FastPath

	EXPORT	|?SDHCBusRequestHandlerImpl@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z| ; CSDIOControllerBase::SDHCBusRequestHandlerImpl

  00000			 AREA	 |.pdata|, PDATA
|$T46223| DCD	|$LN11@SDHCBusReq@3|
	DCD	0x40001f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCBusRequestHandlerImpl@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z| PROC ; CSDIOControllerBase::SDHCBusRequestHandlerImpl

; 2691 : {

  00000		 |$LN11@SDHCBusReq@3|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46220|

; 2692 :     DEBUGCHK(pRequest);
; 2693 :     
; 2694 :     DEBUGMSG(SDCARD_ZONE_FUNC, 
; 2695 :         (L"CSDIOControllerBase::SDHCBusRequestHandlerImpl-"
; 2696 :          L"hDevice=0x%08X, SystemFlags=0x%08X, TransferClass=0x%08X, CommandCode=0x%08X, "
; 2697 :          L"CommandArgument=0x%08X, ResponseType=0x%08X, RequestParam=0x%08X, Status=0x%08X, "
; 2698 :          L"NumBlocks=0x%08X, BlockSize=0x%08X, HCParam=0x%08X, pBlockBuffer=0x%08X, "
; 2699 :          L"DataAccessClocks=0x%08X, Flags=0x%08X\r\n",
; 2700 :          pRequest->hDevice,
; 2701 :          pRequest->SystemFlags,
; 2702 :          pRequest->TransferClass,
; 2703 :          pRequest->CommandCode,
; 2704 :          pRequest->CommandArgument,
; 2705 :          pRequest->CommandResponse.ResponseType,
; 2706 :          pRequest->RequestParam,
; 2707 :          pRequest->Status,
; 2708 :          pRequest->NumBlocks,
; 2709 :          pRequest->BlockSize,
; 2710 :          pRequest->HCParam,
; 2711 :          pRequest->pBlockBuffer,
; 2712 :          pRequest->DataAccessClocks,
; 2713 :          pRequest->Flags)
; 2714 :          );
; 2715 : 
; 2716 :     SD_API_STATUS   status = SD_API_STATUS_FAST_PATH_SUCCESS;
; 2717 : 
; 2718 :     if(pRequest->SystemFlags & SD_FAST_PATH_AVAILABLE)

  00004	e591300c	 ldr         r3, [r1, #0xC]
  00008	e3130102	 tst         r3, #2, 2

; 2719 :        m_fastPathReq = 1;

  0000c	13a03001	 movne       r3, #1
  00010	15803188	 strne       r3, [r0, #0x188]

; 2720 : 
; 2721 :     /* Choose fastpath or not based on registry settings for SDIO and SD memory cards */
; 2722 :     if ((pRequest->SystemFlags & SD_FAST_PATH_AVAILABLE) && 
; 2723 :         ((!m_fastPathSDIO && m_dwSDIOCard) || (!m_fastPathSDMEM && !m_dwSDIOCard)))

  00014	e591200c	 ldr         r2, [r1, #0xC]
  00018	e3120102	 tst         r2, #2, 2
  0001c	0a00000d	 beq         |$LN5@SDHCBusReq@3|
  00020	e5903180	 ldr         r3, [r0, #0x180]
  00024	e3530000	 cmp         r3, #0
  00028	1a000002	 bne         |$LN3@SDHCBusReq@3|
  0002c	e5903178	 ldr         r3, [r0, #0x178]
  00030	e3530000	 cmp         r3, #0
  00034	1a000005	 bne         |$LN4@SDHCBusReq@3|
  00038		 |$LN3@SDHCBusReq@3|
  00038	e5903184	 ldr         r3, [r0, #0x184]
  0003c	e3530000	 cmp         r3, #0
  00040	1a000004	 bne         |$LN5@SDHCBusReq@3|
  00044	e5903178	 ldr         r3, [r0, #0x178]
  00048	e3530000	 cmp         r3, #0
  0004c	1a000001	 bne         |$LN5@SDHCBusReq@3|
  00050		 |$LN4@SDHCBusReq@3|

; 2724 :     {
; 2725 :        pRequest->SystemFlags &= ~SD_FAST_PATH_AVAILABLE;

  00050	e3c23102	 bic         r3, r2, #2, 2
  00054	e581300c	 str         r3, [r1, #0xC]
  00058		 |$LN5@SDHCBusReq@3|

; 2726 :     }
; 2727 : 
; 2728 :     if(pRequest->SystemFlags & SD_FAST_PATH_AVAILABLE)

  00058	e591300c	 ldr         r3, [r1, #0xC]
  0005c	e3130102	 tst         r3, #2, 2
  00060	0a000002	 beq         |$LN2@SDHCBusReq@3|

; 2729 :        status = SDHCBusRequestHandlerImpl_FastPath(pRequest);

  00064	eb000000	 bl          |?SDHCBusRequestHandlerImpl_FastPath@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z|

; 2732 : 
; 2733 :     return status;
; 2734 : }

  00068	e49de004	 ldr         lr, [sp], #4
  0006c	e12fff1e	 bx          lr
  00070		 |$LN2@SDHCBusReq@3|

; 2730 :     else
; 2731 :        status = SDHCBusRequestHandlerImpl_NormalPath(pRequest);

  00070	eb000000	 bl          |?SDHCBusRequestHandlerImpl_NormalPath@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z|

; 2732 : 
; 2733 :     return status;
; 2734 : }

  00074	e49de004	 ldr         lr, [sp], #4
  00078	e12fff1e	 bx          lr
  0007c		 |$M46221|

			 ENDP  ; |?SDHCBusRequestHandlerImpl@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z|, CSDIOControllerBase::SDHCBusRequestHandlerImpl

	EXPORT	|?SDHCBusRequestHandler@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@KPAU_SD_BUS_REQUEST@@@Z| ; CSDIOControllerBase::SDHCBusRequestHandler

  00000			 AREA	 |.pdata|, PDATA
|$T46235| DCD	|$LN5@SDHCBusReq@4|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCBusRequestHandler@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@KPAU_SD_BUS_REQUEST@@@Z| PROC ; CSDIOControllerBase::SDHCBusRequestHandler

; 3401 : {

  00000		 |$LN5@SDHCBusReq@4|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46232|

; 3402 :     UNREFERENCED_PARAMETER(Slot);
; 3403 : 
; 3404 :     // get our extension
; 3405 :     CSDIOControllerBase *pController = GET_PCONTROLLER_FROM_HCD(pHCContext);

  00004	e590004c	 ldr         r0, [r0, #0x4C]

; 3406 :     return pController->SDHCBusRequestHandlerImpl(pRequest);

  00008	e1a01002	 mov         r1, r2
  0000c	eb000000	 bl          |?SDHCBusRequestHandlerImpl@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z|

; 3407 : }

  00010	e49de004	 ldr         lr, [sp], #4
  00014	e12fff1e	 bx          lr
  00018		 |$M46233|

			 ENDP  ; |?SDHCBusRequestHandler@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@KPAU_SD_BUS_REQUEST@@@Z|, CSDIOControllerBase::SDHCBusRequestHandler

	EXPORT	|?SDHCControllerIstThreadImpl@CSDIOControllerBase@@QAAKXZ| ; CSDIOControllerBase::SDHCControllerIstThreadImpl
	EXPORT	|??_C@_1LK@CIILNCON@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAC?$AAS?$AAD?$AAI?$AAO?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAl?$AAe?$AAr?$AAB?$AAa?$AAs?$AAe?$AA?3?$AA?3?$AAS?$AAD?$AAH?$AAC@| [ DATA ] ; `string'
	IMPORT	|InterruptDone|

  00000			 AREA	 |.pdata|, PDATA
|$T46279| DCD	|$LN47@SDHCContro|
	DCD	0x40009e02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1LK@CIILNCON@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAC?$AAS?$AAD?$AAI?$AAO?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAl?$AAe?$AAr?$AAB?$AAa?$AAs?$AAe?$AA?3?$AA?3?$AAS?$AAD?$AAH?$AAC@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "C", 0x0, "S", 0x0, "D", 0x0, "I", 0x0, "O", 0x0, "C"
	DCB	0x0, "o", 0x0, "n", 0x0, "t", 0x0, "r", 0x0, "o", 0x0, "l"
	DCB	0x0, "l", 0x0, "e", 0x0, "r", 0x0, "B", 0x0, "a", 0x0, "s"
	DCB	0x0, "e", 0x0, ":", 0x0, ":", 0x0, "S", 0x0, "D", 0x0, "H"
	DCB	0x0, "C", 0x0, "C", 0x0, "o", 0x0, "n", 0x0, "t", 0x0, "r"
	DCB	0x0, "o", 0x0, "l", 0x0, "l", 0x0, "e", 0x0, "r", 0x0, "I"
	DCB	0x0, "s", 0x0, "t", 0x0, "T", 0x0, "h", 0x0, "r", 0x0, "e"
	DCB	0x0, "a", 0x0, "d", 0x0, ":", 0x0, " ", 0x0, "I", 0x0, "n"
	DCB	0x0, "t", 0x0, "e", 0x0, "r", 0x0, "n", 0x0, "a", 0x0, "l"
	DCB	0x0, " ", 0x0, "e", 0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r"
	DCB	0x0, ".", 0x0, " ", 0x0, "S", 0x0, "h", 0x0, "o", 0x0, "u"
	DCB	0x0, "l", 0x0, "d", 0x0, " ", 0x0, "g", 0x0, "e", 0x0, "t"
	DCB	0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "h", 0x0, "e"
	DCB	0x0, "r", 0x0, "e", 0x0, "!", 0x0, "!", 0x0, "!", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCControllerIstThreadImpl@CSDIOControllerBase@@QAAKXZ| PROC ; CSDIOControllerBase::SDHCControllerIstThreadImpl

; 1478 : {

  00000		 |$LN47@SDHCContro|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M46276|
  00008	e1a05000	 mov         r5, r0

; 1479 :     DWORD code;
; 1480 :     DWORD dwStat;
; 1481 : 
; 1482 :     SDHCCONTROLLERIST_STATE eCurrentState   = CARD_REMOVED_STATE; // COMMAND_TRANSFER_STATE;
; 1483 :     PSD_BUS_REQUEST         pRequest = NULL;
; 1484 :     SDHCCONTROLLERIST_STATE eNextState = CARD_REMOVED_STATE;
; 1485 :     SD_API_STATUS           status = 0;
; 1486 : 
; 1487 :     if (!CeSetThreadPriority(GetCurrentThread(), m_dwSDIOPriority))

  0000c	e5951128	 ldr         r1, [r5, #0x128]
  00010	e3a07000	 mov         r7, #0
  00014	e3a00041	 mov         r0, #0x41
  00018	e3a06000	 mov         r6, #0
  0001c	e3a08000	 mov         r8, #0
  00020	e58d7000	 str         r7, [sp]
  00024	e3a09000	 mov         r9, #0
  00028	eb000000	 bl          CeSetThreadPriority

; 1488 :     {
; 1489 :         DEBUGMSG(SDCARD_ZONE_ERROR, 
; 1490 :             (L"CSDIOControllerBase::SDHCControllerIstThreadImpl!ERROR - "
; 1491 :              L"failed to set CEThreadPriority\r\n")
; 1492 :             );
; 1493 :     }
; 1494 : 
; 1495 :     for(;;)
; 1496 :     {
; 1497 : 
; 1498 :         // wait for the SDIO/controller interrupt
; 1499 :         code = WaitForSingleObject(m_hControllerISTEvent, INFINITE);

  0002c	e5950118	 ldr         r0, [r5, #0x118]
  00030	e3e01000	 mvn         r1, #0
  00034	eb000000	 bl          WaitForSingleObject

; 1500 : 
; 1501 :         // check for shutdown
; 1502 :         if (m_fDriverShutdown) break;

  00038	e5953130	 ldr         r3, [r5, #0x130]
  0003c	e3530000	 cmp         r3, #0
  00040	1a000086	 bne         |$LN39@SDHCContro|
  00044	e59fa228	 ldr         r10, [pc, #0x228]
  00048	e3a0b000	 mov         r11, #0
  0004c		 |$LL17@SDHCContro|

; 1503 : 
; 1504 :         DEBUGMSG(SHC_INTERRUPT_ZONE, 
; 1505 :             (L"CSDIOControllerBase::SDHCControllerIstThreadImpl(): IST\r\n")
; 1506 :             );       
; 1507 : 
; 1508 :         // request clocks        
; 1509 :         UpdateSystemClock(TRUE);

  0004c	e3a01001	 mov         r1, #1
  00050	e1a00005	 mov         r0, r5
  00054	eb000000	 bl          |?UpdateSystemClock@CSDIOControllerBase@@QAAHH@Z|

; 1510 : 
; 1511 :         EnterCriticalSection( &m_critSec );

  00058	e28500b0	 add         r0, r5, #0xB0
  0005c	eb000000	 bl          EnterCriticalSection

; 1512 :         dwStat = READ_EXT_MMC_STATUS();

  00060	e59531f4	 ldr         r3, [r5, #0x1F4]
  00064	e1b04003	 movs        r4, r3
  00068	1a00000d	 bne         |$LN22@SDHCContro|
  0006c	e59530e0	 ldr         r3, [r5, #0xE0]
  00070	e3530003	 cmp         r3, #3
  00074	aa000009	 bge         |$LN21@SDHCContro|
  00078	e28500b0	 add         r0, r5, #0xB0
  0007c	eb000000	 bl          EnterCriticalSection
  00080	e595315c	 ldr         r3, [r5, #0x15C]
  00084	e28500b0	 add         r0, r5, #0xB0
  00088	e5934130	 ldr         r4, [r3, #0x130]
  0008c	eb000000	 bl          LeaveCriticalSection
  00090	e595315c	 ldr         r3, [r5, #0x15C]
  00094	e5933134	 ldr         r3, [r3, #0x134]
  00098	e0034004	 and         r4, r3, r4
  0009c	ea000000	 b           |$LN22@SDHCContro|
  000a0		 |$LN21@SDHCContro|
  000a0	e3a04000	 mov         r4, #0
  000a4		 |$LN22@SDHCContro|

; 1513 :         LeaveCriticalSection( &m_critSec );

  000a4	e28500b0	 add         r0, r5, #0xB0
  000a8	eb000000	 bl          LeaveCriticalSection

; 1514 : 
; 1515 :         DEBUGMSG(SHC_INTERRUPT_ZONE, 
; 1516 :             (L"CSDIOControllerBase::SDHCControllerIstThreadImpl(): dwStat=0x%08X\r\n", 
; 1517 :             dwStat)
; 1518 :             );
; 1519 : 
; 1520 :         if (dwStat & EXT_MMCHS_STAT_CD_INTR)

  000ac	e3140103	 tst         r4, #3, 2
  000b0	0a000012	 beq         |$LN14@SDHCContro|

; 1521 :     {
; 1522 :             eCurrentState = (HandleCardDetectInterrupt(dwStat) ? COMMAND_TRANSFER_STATE : CARD_REMOVED_STATE);

  000b4	e1a01004	 mov         r1, r4
  000b8	e1a00005	 mov         r0, r5
  000bc	eb000000	 bl          |?HandleCardDetectInterrupt@CSDIOControllerBase@@QAAHK@Z|
  000c0	e3500000	 cmp         r0, #0
  000c4	13a06001	 movne       r6, #1

; 1523 :             UpdateSystemClock(FALSE);

  000c8	e3a01000	 mov         r1, #0
  000cc	e1a00005	 mov         r0, r5
  000d0	03a06000	 moveq       r6, #0
  000d4	eb000000	 bl          |?UpdateSystemClock@CSDIOControllerBase@@QAAHH@Z|

; 1524 :             if (m_bCommandPending == TRUE)

  000d8	e59531f8	 ldr         r3, [r5, #0x1F8]
  000dc	e3530001	 cmp         r3, #1
  000e0	1a000003	 bne         |$LN13@SDHCContro|

; 1525 :         {
; 1526 :                 m_bCommandPending = FALSE;
; 1527 :                 UpdateSystemClock(FALSE);

  000e4	e585b1f8	 str         r11, [r5, #0x1F8]
  000e8		 |$LN44@SDHCContro|
  000e8	e1a00005	 mov         r0, r5
  000ec	e3a01000	 mov         r1, #0
  000f0	eb000000	 bl          |?UpdateSystemClock@CSDIOControllerBase@@QAAHH@Z|
  000f4		 |$LN13@SDHCContro|

; 1528 :         }
; 1529 :             InterruptDone( m_dwControllerSysIntr );

  000f4	e5950134	 ldr         r0, [r5, #0x134]
  000f8	eb000000	 bl          InterruptDone

; 1530 :             continue;

  000fc	ea000051	 b           |$LN40@SDHCContro|
  00100		 |$LN14@SDHCContro|

; 1531 :         }
; 1532 : 
; 1533 :         if(m_ActualPowerState == D4)

  00100	e59530e0	 ldr         r3, [r5, #0xE0]
  00104	e3530004	 cmp         r3, #4

; 1534 :         {
; 1535 :             DEBUGMSG(SHC_INTERRUPT_ZONE, 
; 1536 :                 (L"SDHCControllerIstThreadImpl: Register access at D4\r\n")
; 1537 :                 );
; 1538 :             
; 1539 :             UpdateSystemClock(FALSE);
; 1540 :             InterruptDone( m_dwControllerSysIntr );
; 1541 :             continue;

  00108	0afffff6	 beq         |$LN44@SDHCContro|

; 1542 :         }
; 1543 : 
; 1544 :         switch (eCurrentState)

  0010c	e3560000	 cmp         r6, #0
  00110	0a000025	 beq         |$LN9@SDHCContro|
  00114	e3560001	 cmp         r6, #1
  00118	0a000017	 beq         |$LN8@SDHCContro|
  0011c	e3560002	 cmp         r6, #2
  00120	0a00000f	 beq         |$LN7@SDHCContro|
  00124	e3560003	 cmp         r6, #3
  00128	0a000007	 beq         |$LN6@SDHCContro|
  0012c	e3560004	 cmp         r6, #4
  00130	0a000015	 beq         |$LN5@SDHCContro|

; 1563 :             case CARDBUSY_STATE:
; 1564 :                 status = CardBusyCompletedHandler(pRequest, dwStat, &eNextState);
; 1565 :                 break;
; 1566 :             default:
; 1567 :                 RETAILMSG(SDCARD_ZONE_WARN, 
; 1568 :                     (TEXT("ERROR: CSDIOControllerBase::SDHCControllerIstThread: Internal error. Should get to here!!!\r\n"))
; 1569 :                     );

  00134	e59a3440	 ldr         r3, [r10, #0x440]
  00138	e3130901	 tst         r3, #1, 18
  0013c	0a00001c	 beq         |$LN10@SDHCContro|
  00140	e59f0128	 ldr         r0, [pc, #0x128]
  00144	eb000000	 bl          NKDbgPrintfW

; 1570 :                 break;

  00148	ea000019	 b           |$LN10@SDHCContro|
  0014c		 |$LN6@SDHCContro|

; 1560 :             case DATA_TRANSMIT_STATE:
; 1561 :                 status = DataTransmitCompletedHandler(pRequest, dwStat, &eNextState);

  0014c	e28d3000	 add         r3, sp, #0
  00150	e1a02004	 mov         r2, r4
  00154	e1a01008	 mov         r1, r8
  00158	e1a00005	 mov         r0, r5
  0015c	eb000000	 bl          |?DataTransmitCompletedHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@KPAW4SDHCCONTROLLERIST_STATE@@@Z|

; 1562 :                 break;

  00160	ea00000e	 b           |$LN41@SDHCContro|
  00164		 |$LN7@SDHCContro|

; 1557 :             case DATA_RECEIVE_STATE:
; 1558 :                 status = DataReceiveCompletedHandler(pRequest, dwStat, &eNextState);

  00164	e28d3000	 add         r3, sp, #0
  00168	e1a02004	 mov         r2, r4
  0016c	e1a01008	 mov         r1, r8
  00170	e1a00005	 mov         r0, r5
  00174	eb000000	 bl          |?DataReceiveCompletedHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@KPAW4SDHCCONTROLLERIST_STATE@@@Z|

; 1559 :                 break;

  00178	ea000008	 b           |$LN41@SDHCContro|
  0017c		 |$LN8@SDHCContro|

; 1551 :                 break;
; 1552 :             case COMMAND_TRANSFER_STATE:
; 1553 :                 // get and lock the current bus request
; 1554 :                 pRequest = SDHCDGetAndLockCurrentRequest(m_pHCContext, 0);

  0017c	e59500a8	 ldr         r0, [r5, #0xA8]
  00180	e3a01000	 mov         r1, #0
  00184	eb000000	 bl          SDHCDGetAndLockCurrentRequest
  00188	e1a08000	 mov         r8, r0
  0018c		 |$LN5@SDHCContro|

; 1555 :                 status = CommandTransferCompleteHandler(pRequest, dwStat, &eNextState);

  0018c	e1a02004	 mov         r2, r4
  00190	e28d3000	 add         r3, sp, #0
  00194	e1a01008	 mov         r1, r8
  00198	e1a00005	 mov         r0, r5
  0019c	eb000000	 bl          |?CommandTransferCompleteHandler@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@KPAW4SDHCCONTROLLERIST_STATE@@@Z|
  001a0		 |$LN41@SDHCContro|

; 1556 :                 break;

  001a0	e59d7000	 ldr         r7, [sp]
  001a4	e1a09000	 mov         r9, r0
  001a8	ea000001	 b           |$LN10@SDHCContro|
  001ac		 |$LN9@SDHCContro|

; 1545 :         {
; 1546 :             case CARD_REMOVED_STATE:
; 1547 :                 DEBUGMSG(SHC_INTERRUPT_ZONE, 
; 1548 :                     (TEXT("ERROR: CSDIOControllerBase::SDHCControllerIstThread: Internal error. No SD card in the slot!!!\r\n"))
; 1549 :                     );
; 1550 :                 eNextState = CARD_REMOVED_STATE;

  001ac	e3a07000	 mov         r7, #0
  001b0	e58d7000	 str         r7, [sp]
  001b4		 |$LN10@SDHCContro|

; 1571 :         }
; 1572 : 
; 1573 :         if( ((eNextState == COMMAND_TRANSFER_STATE)) && (dwStat & MMCHS_STAT_CIRQ))

  001b4	e3570001	 cmp         r7, #1
  001b8	1a00000f	 bne         |$LN3@SDHCContro|
  001bc	e3140c01	 tst         r4, #1, 24
  001c0	0a00000d	 beq         |$LN3@SDHCContro|

; 1574 :         {
; 1575 : 
; 1576 :             ASSERT( m_fSDIOInterruptsEnabled );
; 1577 :             // indicate that the card is interrupting
; 1578 :             DEBUGMSG(SHC_INTERRUPT_ZONE, (TEXT("CSDIOControllerBase::SDHCControllerIstThread: got SDIO interrupt!\r\n")));
; 1579 :             DEBUGMSG(SHC_SDBUS_INTERACT_ZONE, (TEXT("Received SDIO interrupt\r\n")));
; 1580 : 
; 1581 :             // disable the SDIO interrupt
; 1582 :             EnterCriticalSection( &m_critSec );

  001c4	e28500b0	 add         r0, r5, #0xB0
  001c8	eb000000	 bl          EnterCriticalSection

; 1583 :             CLRREG32(&m_pbRegisters->MMCHS_IE, MMCHS_IE_CIRQ);

  001cc	e595215c	 ldr         r2, [r5, #0x15C]

; 1584 :             LeaveCriticalSection( &m_critSec );

  001d0	e28500b0	 add         r0, r5, #0xB0
  001d4	e5923134	 ldr         r3, [r2, #0x134]
  001d8	e3c33c01	 bic         r3, r3, #1, 24
  001dc	e5823134	 str         r3, [r2, #0x134]
  001e0	eb000000	 bl          LeaveCriticalSection

; 1585 : 
; 1586 :             // notify the SDBusDriver of the SDIO interrupt
; 1587 :             m_fSDIOInterruptInService = TRUE;
; 1588 :             SDHCDIndicateSlotStateChange(m_pHCContext, 0, DeviceInterrupting);

  001e4	e59500a8	 ldr         r0, [r5, #0xA8]
  001e8	e3a03001	 mov         r3, #1
  001ec	e3a02003	 mov         r2, #3
  001f0	e3a01000	 mov         r1, #0
  001f4	e58530d8	 str         r3, [r5, #0xD8]
  001f8	eb000000	 bl          SDHCDIndicateSlotStateChange
  001fc		 |$LN3@SDHCContro|

; 1589 :             }
; 1590 : 
; 1591 :         UpdateSystemClock(FALSE);

  001fc	e3a01000	 mov         r1, #0
  00200	e1a00005	 mov         r0, r5
  00204	eb000000	 bl          |?UpdateSystemClock@CSDIOControllerBase@@QAAHH@Z|

; 1592 :         InterruptDone( m_dwControllerSysIntr );

  00208	e5950134	 ldr         r0, [r5, #0x134]
  0020c	eb000000	 bl          InterruptDone

; 1593 : 
; 1594 :         if (eNextState == COMMAND_TRANSFER_STATE)

  00210	e3570001	 cmp         r7, #1
  00214	1a00000a	 bne         |$LN1@SDHCContro|

; 1595 :             {
; 1596 :             // We need to release the clock once more when a command is completed because the 
; 1597 :             // we requested the clock before sending out a command the via normal path and didn't 
; 1598 :             // release the clock there. We also request the clock again when interrupt occurs, to make
; 1599 :             // sure the clock is on to avoid crash, so we need to release the clock twice when
; 1600 :             // a command is completed.
; 1601 :             //RETAILMSG(1, (TEXT("=2===========> %d %d\r\n"), eNextState, m_dwClockCnt ));
; 1602 :         UpdateSystemClock(FALSE);

  00218	e3a01000	 mov         r1, #0
  0021c	e1a00005	 mov         r0, r5
  00220	eb000000	 bl          |?UpdateSystemClock@CSDIOControllerBase@@QAAHH@Z|

; 1603 :             m_bCommandPending = FALSE;

  00224	e585b1f8	 str         r11, [r5, #0x1F8]

; 1604 :             if (pRequest != NULL) 

  00228	e3580000	 cmp         r8, #0
  0022c	0a000004	 beq         |$LN1@SDHCContro|

; 1605 :                 {
; 1606 :                 SDHCDIndicateBusRequestComplete(m_pHCContext, pRequest, status);

  00230	e59500a8	 ldr         r0, [r5, #0xA8]
  00234	e1a02009	 mov         r2, r9
  00238	e1a01008	 mov         r1, r8
  0023c	eb000000	 bl          SDHCDIndicateBusRequestComplete

; 1607 :                 pRequest = NULL;

  00240	e3a08000	 mov         r8, #0
  00244		 |$LN1@SDHCContro|

; 1608 :                 }
; 1609 :             }
; 1610 : 
; 1611 :         eCurrentState = eNextState;

  00244	e1a06007	 mov         r6, r7
  00248		 |$LN40@SDHCContro|

; 1488 :     {
; 1489 :         DEBUGMSG(SDCARD_ZONE_ERROR, 
; 1490 :             (L"CSDIOControllerBase::SDHCControllerIstThreadImpl!ERROR - "
; 1491 :              L"failed to set CEThreadPriority\r\n")
; 1492 :             );
; 1493 :     }
; 1494 : 
; 1495 :     for(;;)
; 1496 :     {
; 1497 : 
; 1498 :         // wait for the SDIO/controller interrupt
; 1499 :         code = WaitForSingleObject(m_hControllerISTEvent, INFINITE);

  00248	e5950118	 ldr         r0, [r5, #0x118]
  0024c	e3e01000	 mvn         r1, #0
  00250	eb000000	 bl          WaitForSingleObject

; 1500 : 
; 1501 :         // check for shutdown
; 1502 :         if (m_fDriverShutdown) break;

  00254	e5953130	 ldr         r3, [r5, #0x130]
  00258	e3530000	 cmp         r3, #0
  0025c	0affff7a	 beq         |$LL17@SDHCContro|
  00260		 |$LN39@SDHCContro|

; 1612 :     }
; 1613 : 
; 1614 :     DEBUGMSG(SDCARD_ZONE_INIT, (TEXT("SDHCCardDetectIstThread: Thread Exiting\r\n")));
; 1615 :     return 0;

  00260	e3a00000	 mov         r0, #0

; 1616 : }

  00264	e28dd004	 add         sp, sp, #4
  00268	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0026c	e12fff1e	 bx          lr
  00270		 |$LN48@SDHCContro|
  00270		 |$LN49@SDHCContro|
  00270	00000000	 DCD         |??_C@_1LK@CIILNCON@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAC?$AAS?$AAD?$AAI?$AAO?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAl?$AAe?$AAr?$AAB?$AAa?$AAs?$AAe?$AA?3?$AA?3?$AAS?$AAD?$AAH?$AAC@|
  00274		 |$LN50@SDHCContro|
  00274	00000000	 DCD         |dpCurSettings|
  00278		 |$M46277|

			 ENDP  ; |?SDHCControllerIstThreadImpl@CSDIOControllerBase@@QAAKXZ|, CSDIOControllerBase::SDHCControllerIstThreadImpl

	EXPORT	|?SDHCControllerIstThread@CSDIOControllerBase@@SAKPAX@Z| ; CSDIOControllerBase::SDHCControllerIstThread

  00000			 AREA	 |.pdata|, PDATA
|$T46292| DCD	|$LN5@SDHCContro@2|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCControllerIstThread@CSDIOControllerBase@@SAKPAX@Z| PROC ; CSDIOControllerBase::SDHCControllerIstThread

; 1463 : {

  00000		 |$LN5@SDHCContro@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46289|

; 1464 :     CSDIOControllerBase *pController = (CSDIOControllerBase*)lpParameter;
; 1465 :     return pController->SDHCControllerIstThreadImpl();

  00004	eb000000	 bl          |?SDHCControllerIstThreadImpl@CSDIOControllerBase@@QAAKXZ|

; 1466 : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M46290|

			 ENDP  ; |?SDHCControllerIstThread@CSDIOControllerBase@@SAKPAX@Z|, CSDIOControllerBase::SDHCControllerIstThread

	EXPORT	|?SDHCInitializeImpl@CSDIOControllerBase@@QAAJXZ| ; CSDIOControllerBase::SDHCInitializeImpl
	IMPORT	|?SDIO_InitDMA@CSDIOControllerBase@@QAAXXZ| ; CSDIOControllerBase::SDIO_InitDMA
	IMPORT	|InterruptInitialize|
	IMPORT	|CreateEventW|
	IMPORT	|GetIrqByDevice|
	IMPORT	|VirtualFree|
	IMPORT	|VirtualCopy|
	IMPORT	|VirtualAlloc|
	IMPORT	|HalAllocateCommonBuffer|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T46319| DCD	|$LN34@SDHCInitia|
	DCD	0x4000a202
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\sdhc\base\sdhc.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCInitializeImpl@CSDIOControllerBase@@QAAJXZ| PROC ; CSDIOControllerBase::SDHCInitializeImpl

; 2354 : {

  00000		 |$LN34@SDHCInitia|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd028	 sub         sp, sp, #0x28
  00008		 |$M46316|
  00008	e1a04000	 mov         r4, r0

; 2355 :     SD_API_STATUS status = SD_API_STATUS_INSUFFICIENT_RESOURCES; // intermediate status
; 2356 :     DMA_ADAPTER_OBJECT dmaAdapter;
; 2357 :     DWORD         threadID;
; 2358 :     DWORD *pdwSDIOIrq;
; 2359 :     DWORD dwSDIOIrqLen;
; 2360 :     DWORD dwClockRate;
; 2361 : 
; 2362 :     DEBUGMSG(SDCARD_ZONE_INFO, (L"CSDIOControllerBase::SDHCInitializeImpl++\r\n"));
; 2363 : 
; 2364 :     // allocate the DMA buffer
; 2365 :     dmaAdapter.ObjectSize = sizeof(dmaAdapter);
; 2366 :     dmaAdapter.InterfaceType = Internal;
; 2367 :     dmaAdapter.BusNumber = 0;
; 2368 :     m_pDmaBuffer = (PBYTE)HalAllocateCommonBuffer( &dmaAdapter, m_dwDMABufferSize, &m_pDmaBufferPhys, FALSE );

  0000c	e59411fc	 ldr         r1, [r4, #0x1FC]
  00010	e3a0e00c	 mov         lr, #0xC
  00014	e3a05000	 mov         r5, #0
  00018	e3a06000	 mov         r6, #0
  0001c	e3a03000	 mov         r3, #0
  00020	e2842f42	 add         r2, r4, #0x42, 30
  00024	e28d001c	 add         r0, sp, #0x1C
  00028	e1cde1bc	 strh        lr, [sp, #0x1C]
  0002c	e58d5020	 str         r5, [sp, #0x20]
  00030	e58d6024	 str         r6, [sp, #0x24]
  00034	eb000000	 bl          HalAllocateCommonBuffer
  00038	e3500000	 cmp         r0, #0
  0003c	e58400fc	 str         r0, [r4, #0xFC]

; 2369 :     ASSERT(m_pDmaBuffer);
; 2370 : 
; 2371 :     if( m_pDmaBuffer == NULL )
; 2372 :     {
; 2373 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("InitializeInstance:: Error allocating DMA buffer!\r\n")));
; 2374 :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;

  00040	0a00007d	 beq         |$LN31@SDHCInitia|

; 2375 :         goto cleanUp;
; 2376 :     }
; 2377 : 
; 2378 :     //  Change the attributes of the buffer for cache write combine to improve write performance.
; 2379 :     if( !CeSetMemoryAttributes(m_pDmaBuffer, (void *)(m_pDmaBufferPhys.LowPart >> 8), m_dwDMABufferSize, PAGE_WRITECOMBINE))

  00044	e5942108	 ldr         r2, [r4, #0x108]
  00048	e59431fc	 ldr         r3, [r4, #0x1FC]
  0004c	e3a0eb01	 mov         lr, #1, 22
  00050	e1a02422	 mov         r2, r2, lsr #8
  00054	e58d2000	 str         r2, [sp]
  00058	e1a02000	 mov         r2, r0
  0005c	e3a05000	 mov         r5, #0
  00060	e3a00001	 mov         r0, #1
  00064	e3a0100c	 mov         r1, #0xC
  00068	e58d5008	 str         r5, [sp, #8]
  0006c	e58de004	 str         lr, [sp, #4]
  00070	eb000000	 bl          KernelLibIoControl
  00074	e3500000	 cmp         r0, #0

; 2523 : 
; 2524 : cleanUp:

  00078	0a00006f	 beq         |$LN31@SDHCInitia|
  0007c	e59411fc	 ldr         r1, [r4, #0x1FC]
  00080	e3a03004	 mov         r3, #4
  00084	e3a02a02	 mov         r2, #2, 20
  00088	e3a00000	 mov         r0, #0
  0008c	eb000000	 bl          VirtualAlloc
  00090	e3500000	 cmp         r0, #0
  00094	e5840100	 str         r0, [r4, #0x100]
  00098	0a00000c	 beq         |$LN17@SDHCInitia|
  0009c	e5943108	 ldr         r3, [r4, #0x108]
  000a0	e59421fc	 ldr         r2, [r4, #0x1FC]
  000a4	e3a0eb01	 mov         lr, #1, 22
  000a8	e1a01423	 mov         r1, r3, lsr #8
  000ac	e38e3004	 orr         r3, lr, #4
  000b0	eb000000	 bl          VirtualCopy
  000b4	e3500000	 cmp         r0, #0
  000b8	1a000004	 bne         |$LN17@SDHCInitia|
  000bc	e59411fc	 ldr         r1, [r4, #0x1FC]
  000c0	e5940100	 ldr         r0, [r4, #0x100]
  000c4	e3a02902	 mov         r2, #2, 18
  000c8	eb000000	 bl          VirtualFree
  000cc	e5845100	 str         r5, [r4, #0x100]
  000d0		 |$LN17@SDHCInitia|
  000d0	e3a01401	 mov         r1, #1, 8
  000d4	e1a00004	 mov         r0, r4
  000d8	eb000000	 bl          |?SoftwareReset@CSDIOControllerBase@@QAAXK@Z|
  000dc	e3a03a61	 mov         r3, #0x61, 20
  000e0	e3833d2a	 orr         r3, r3, #0x2A, 26
  000e4	e28d100c	 add         r1, sp, #0xC
  000e8	e1a00004	 mov         r0, r4
  000ec	e58d300c	 str         r3, [sp, #0xC]
  000f0	eb000000	 bl          |?SetClockRate@CSDIOControllerBase@@QAAXPAK@Z|
  000f4	e3a00001	 mov         r0, #1
  000f8	eb000000	 bl          SOCGetSDHCDeviceBySlot
  000fc	e3a01000	 mov         r1, #0
  00100	eb000000	 bl          GetIrqByDevice
  00104	e1a03000	 mov         r3, r0
  00108	e3a00002	 mov         r0, #2
  0010c	e58d3014	 str         r3, [sp, #0x14]
  00110	eb000000	 bl          SOCGetSDHCDeviceBySlot
  00114	e3a01000	 mov         r1, #0
  00118	eb000000	 bl          GetIrqByDevice
  0011c	e5943170	 ldr         r3, [r4, #0x170]
  00120	e58d0018	 str         r0, [sp, #0x18]
  00124	e59f0158	 ldr         r0, [pc, #0x158]
  00128	e3530001	 cmp         r3, #1
  0012c	028d1014	 addeq       r1, sp, #0x14
  00130	e3a0e004	 mov         lr, #4
  00134	128d1018	 addne       r1, sp, #0x18
  00138	e2843f4d	 add         r3, r4, #0x4D, 30
  0013c	e3a02004	 mov         r2, #4
  00140	e58d5004	 str         r5, [sp, #4]
  00144	e58de000	 str         lr, [sp]
  00148	eb000000	 bl          KernelIoControl
  0014c	e3500000	 cmp         r0, #0
  00150	03e03000	 mvneq       r3, #0
  00154	05843134	 streq       r3, [r4, #0x134]
  00158	03a0510f	 moveq       r5, #0xF, 2
  0015c	0a000037	 beq         |$LN30@SDHCInitia|
  00160	e3a03000	 mov         r3, #0
  00164	e3a02000	 mov         r2, #0
  00168	e3a01000	 mov         r1, #0
  0016c	e3a00000	 mov         r0, #0
  00170	eb000000	 bl          CreateEventW
  00174	e1b01000	 movs        r1, r0
  00178	e5841118	 str         r1, [r4, #0x118]
  0017c	0a00002e	 beq         |$LN31@SDHCInitia|
  00180	e5940134	 ldr         r0, [r4, #0x134]
  00184	e3a03000	 mov         r3, #0
  00188	e3a02000	 mov         r2, #0
  0018c	eb000000	 bl          InterruptInitialize
  00190	e3500000	 cmp         r0, #0
  00194	0a000028	 beq         |$LN31@SDHCInitia|
  00198	e3a03000	 mov         r3, #0
  0019c	e3a02000	 mov         r2, #0
  001a0	e3a01000	 mov         r1, #0
  001a4	e3a00000	 mov         r0, #0
  001a8	eb000000	 bl          CreateEventW
  001ac	e3500000	 cmp         r0, #0
  001b0	e5840120	 str         r0, [r4, #0x120]
  001b4	0a000020	 beq         |$LN31@SDHCInitia|
  001b8	e59f20c0	 ldr         r2, [pc, #0xC0]
  001bc	e28de010	 add         lr, sp, #0x10
  001c0	e1a03004	 mov         r3, r4
  001c4	e3a01000	 mov         r1, #0
  001c8	e3a00000	 mov         r0, #0
  001cc	e58de004	 str         lr, [sp, #4]
  001d0	e58d5000	 str         r5, [sp]
  001d4	eb000000	 bl          CreateThread
  001d8	e3500000	 cmp         r0, #0
  001dc	e584011c	 str         r0, [r4, #0x11C]
  001e0	0a000015	 beq         |$LN31@SDHCInitia|
  001e4	e3a03000	 mov         r3, #0
  001e8	e3a02000	 mov         r2, #0
  001ec	e3a01000	 mov         r1, #0
  001f0	e3a00000	 mov         r0, #0
  001f4	e58451cc	 str         r5, [r4, #0x1CC]
  001f8	e58451ac	 str         r5, [r4, #0x1AC]
  001fc	eb000000	 bl          CreateEventW
  00200	e3500000	 cmp         r0, #0
  00204	e58401a8	 str         r0, [r4, #0x1A8]
  00208	0a000008	 beq         |$LN4@SDHCInitia|
  0020c	e59f2068	 ldr         r2, [pc, #0x68]
  00210	e28de010	 add         lr, sp, #0x10
  00214	e1a03004	 mov         r3, r4
  00218	e3a01000	 mov         r1, #0
  0021c	e3a00000	 mov         r0, #0
  00220	e58de004	 str         lr, [sp, #4]
  00224	e58d5000	 str         r5, [sp]
  00228	eb000000	 bl          CreateThread
  0022c	e58401ac	 str         r0, [r4, #0x1AC]
  00230		 |$LN4@SDHCInitia|
  00230	e59431ac	 ldr         r3, [r4, #0x1AC]
  00234	e3530000	 cmp         r3, #0
  00238	1a000003	 bne         |$LN3@SDHCInitia|
  0023c		 |$LN31@SDHCInitia|

; 2380 :     {
; 2381 :         DEBUGMSG(SDCARD_ZONE_ERROR, (L"InitializeInstance:: Error failed CeSetMemoryAttributes for SDHC DMA buffer\r\n"));
; 2382 :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;
; 2383 :         goto cleanUp;
; 2384 :     }
; 2385 : 
; 2386 :     // map DMA buffer to cached memory so we can get better performance in the read operations. The will need to invalidate 
; 2387 :     // (not writeback) the cahced memory before copying data from the cached DMA to the MDD buffer!!!  
; 2388 :     m_pCachedDmaBuffer = (PBYTE)VirtualAlloc(NULL, m_dwDMABufferSize, MEM_RESERVE, PAGE_READWRITE);
; 2389 : 
; 2390 :     if (m_pCachedDmaBuffer == NULL)
; 2391 :         {
; 2392 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("InitializeInstance:: Error allocating DMA cached buffer!\r\n")));
; 2393 :         }
; 2394 :     else
; 2395 :         {
; 2396 :         if (!VirtualCopy(m_pCachedDmaBuffer, (PVOID)(m_pDmaBufferPhys.LowPart>>8), m_dwDMABufferSize, PAGE_READWRITE | PAGE_PHYSICAL))
; 2397 :             {
; 2398 :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("InitializeInstance:: Error mapping DMA cached buffer!\r\n")));
; 2399 :             VirtualFree(m_pCachedDmaBuffer, m_dwDMABufferSize, MEM_RELEASE);
; 2400 :             m_pCachedDmaBuffer = NULL;
; 2401 :             }
; 2402 :         }
; 2403 : 
; 2404 :     SoftwareReset(SOFT_RESET_ALL);
; 2405 : 
; 2406 :     dwClockRate = MMCSD_CLOCK_INIT;
; 2407 :     SetClockRate(&dwClockRate);
; 2408 : 
; 2409 :     // convert the SDIO hardware IRQ into a logical SYSINTR value
; 2410 :     DWORD rgdwSDIOIrq[] = {
; 2411 :         GetIrqByDevice(SOCGetSDHCDeviceBySlot(MMCSLOT_1), NULL),
; 2412 :         GetIrqByDevice(SOCGetSDHCDeviceBySlot(MMCSLOT_2), NULL)
; 2413 :         };
; 2414 :     if(m_dwSlot == MMCSLOT_1)
; 2415 :       pdwSDIOIrq = &rgdwSDIOIrq[0];
; 2416 :     else
; 2417 :       pdwSDIOIrq = &rgdwSDIOIrq[1];
; 2418 :     dwSDIOIrqLen = sizeof(DWORD);
; 2419 : 
; 2420 :     if (!KernelIoControl(IOCTL_HAL_REQUEST_SYSINTR, pdwSDIOIrq, dwSDIOIrqLen, &m_dwControllerSysIntr, sizeof(DWORD), NULL))
; 2421 :     {
; 2422 :         // invalid SDIO SYSINTR value!
; 2423 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("Error obtaining SDIO SYSINTR value!\r\n")));
; 2424 :         m_dwControllerSysIntr = SYSINTR_UNDEFINED;
; 2425 :         status = SD_API_STATUS_UNSUCCESSFUL;
; 2426 :         goto cleanUp;
; 2427 :     }
; 2428 : 
; 2429 :     // allocate the interrupt event for the SDIO/controller interrupt
; 2430 :     m_hControllerISTEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
; 2431 : 
; 2432 :     if (NULL == m_hControllerISTEvent)
; 2433 :     {
; 2434 :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;
; 2435 :         goto cleanUp;
; 2436 :     }
; 2437 : 
; 2438 :     if ( !InterruptInitialize( m_dwControllerSysIntr, m_hControllerISTEvent, NULL, 0 ) )
; 2439 :     {
; 2440 :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;
; 2441 :         goto cleanUp;
; 2442 :     }
; 2443 : 
; 2444 :     // allocate the interrupt event for card detection
; 2445 :     m_hCardDetectEvent = CreateEvent(NULL, FALSE, FALSE,NULL);
; 2446 : 
; 2447 :     if (NULL == m_hCardDetectEvent)
; 2448 :     {
; 2449 :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;
; 2450 :         goto cleanUp;
; 2451 :     }
; 2452 : 
; 2453 :     // create the Controller IST thread
; 2454 :     m_htControllerIST = CreateThread(NULL,
; 2455 :         0,
; 2456 :         CSDIOControllerBase::SDHCControllerIstThread,
; 2457 :         this,
; 2458 :         0,
; 2459 :         &threadID);
; 2460 : 
; 2461 :     if (NULL == m_htControllerIST) 
; 2462 :     {
; 2463 :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;
; 2464 :         goto cleanUp;
; 2465 :     }
; 2466 : 
; 2467 : #ifdef SDIO_PRINT_THREAD
; 2468 : 
; 2469 :         m_cmdRdIndex = m_cmdWrIndex = 0;
; 2470 :     m_hPrintEvent = CreateEvent(NULL, FALSE, FALSE,NULL);
; 2471 : 
; 2472 :     if (NULL == m_hPrintEvent)
; 2473 :     {
; 2474 :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;
; 2475 :         goto cleanUp;
; 2476 :     }
; 2477 : 
; 2478 :     m_hPrintIST = CreateThread(NULL,
; 2479 :         0,
; 2480 :         CSDIOControllerBase::SDHCPrintThread,
; 2481 :         this,
; 2482 :         0,
; 2483 :         &threadID);
; 2484 : 
; 2485 :     if (NULL == m_hPrintIST)
; 2486 :     {
; 2487 :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;
; 2488 :         goto cleanUp;
; 2489 :     }
; 2490 : 
; 2491 : #endif
; 2492 : 
; 2493 :     // start timer thread
; 2494 :     m_bDisablePower = FALSE;
; 2495 :     m_hTimerThreadIST = NULL;
; 2496 :     m_hTimerEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
; 2497 :     if (m_hTimerEvent != NULL)
; 2498 :         {
; 2499 :         m_hTimerThreadIST = CreateThread(NULL,
; 2500 :             0,
; 2501 :             CSDIOControllerBase::SDHCPowerTimerThread,
; 2502 :             this,
; 2503 :             0,
; 2504 :             &threadID);
; 2505 :         }
; 2506 : 
; 2507 :     if (NULL == m_hTimerThreadIST)
; 2508 :     {
; 2509 :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;

  0023c	e3a0513b	 mov         r5, #0x3B, 2
  00240		 |$LN30@SDHCInitia|

; 2525 : 
; 2526 :     if (!SD_API_SUCCESS(status))
; 2527 :     {
; 2528 :         // just call the deinit handler directly to cleanup
; 2529 :         SDHCDeinitializeImpl();

  00240	e1a00004	 mov         r0, r4
  00244	eb000000	 bl          |?SDHCDeinitializeImpl@CSDIOControllerBase@@QAAJXZ|
  00248	ea000007	 b           |$LN1@SDHCInitia|
  0024c		 |$LN3@SDHCInitia|

; 2510 :         goto cleanUp;
; 2511 :     }
; 2512 : 
; 2513 :     m_fInitialized = TRUE;
; 2514 : 
; 2515 :     // on start we need the IST to check the slot for a card
; 2516 :     SetEvent(m_hCardDetectEvent);

  0024c	e5940120	 ldr         r0, [r4, #0x120]
  00250	e3a03001	 mov         r3, #1
  00254	e3a01003	 mov         r1, #3
  00258	e5843138	 str         r3, [r4, #0x138]
  0025c	eb000000	 bl          EventModify

; 2517 : 
; 2518 : #ifdef SDIO_DMA_ENABLED
; 2519 :     SDIO_InitDMA();

  00260	e1a00004	 mov         r0, r4
  00264	eb000000	 bl          |?SDIO_InitDMA@CSDIOControllerBase@@QAAXXZ|

; 2520 : #endif
; 2521 : 
; 2522 :     status = SD_API_STATUS_SUCCESS;

  00268	e3a05000	 mov         r5, #0
  0026c		 |$cleanUp$43045|

; 2525 : 
; 2526 :     if (!SD_API_SUCCESS(status))
; 2527 :     {
; 2528 :         // just call the deinit handler directly to cleanup
; 2529 :         SDHCDeinitializeImpl();

  0026c		 |$LN1@SDHCInitia|

; 2530 :     }
; 2531 :     return status;
; 2532 : }

  0026c	e1a00005	 mov         r0, r5
  00270	e28dd028	 add         sp, sp, #0x28
  00274	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00278	e12fff1e	 bx          lr
  0027c		 |$LN35@SDHCInitia|
  0027c		 |$LN36@SDHCInitia|
  0027c	00000000	 DCD         |?SDHCPowerTimerThread@CSDIOControllerBase@@SAKPAX@Z|
  00280		 |$LN37@SDHCInitia|
  00280	00000000	 DCD         |?SDHCControllerIstThread@CSDIOControllerBase@@SAKPAX@Z|
  00284		 |$LN38@SDHCInitia|
  00284	01010098	 DCD         0x1010098
  00288		 |$M46317|

			 ENDP  ; |?SDHCInitializeImpl@CSDIOControllerBase@@QAAJXZ|, CSDIOControllerBase::SDHCInitializeImpl

	EXPORT	|?SDHCInitialize@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@@Z| ; CSDIOControllerBase::SDHCInitialize

  00000			 AREA	 |.pdata|, PDATA
|$T46334| DCD	|$LN5@SDHCInitia@2|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCInitialize@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@@Z| PROC ; CSDIOControllerBase::SDHCInitialize

; 3437 : {

  00000		 |$LN5@SDHCInitia@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46331|

; 3438 :     // get our extension
; 3439 :     CSDIOControllerBase *pController = GET_PCONTROLLER_FROM_HCD(pHCContext);

  00004	e590004c	 ldr         r0, [r0, #0x4C]

; 3440 :     return pController->SDHCInitializeImpl();

  00008	eb000000	 bl          |?SDHCInitializeImpl@CSDIOControllerBase@@QAAJXZ|

; 3441 : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M46332|

			 ENDP  ; |?SDHCInitialize@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@@Z|, CSDIOControllerBase::SDHCInitialize

	EXPORT	|??_C@_19IJCLBJAH@?$AAS?$AAD?$AAH?$AAC?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|wcsncpy|

  00000			 AREA	 |.pdata|, PDATA
|$T46345| DCD	|$LN5@InterpretC|
	DCD	0x40002201

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_19IJCLBJAH@?$AAS?$AAD?$AAH?$AAC?$AA?$AA@| DCB "S", 0x0, "D", 0x0, "H"
	DCB	0x0, "C", 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InterpretCapabilities@CSDIOControllerBase@@UAAHXZ| PROC ; CSDIOControllerBase::InterpretCapabilities

; 1427 : {

  00000		 |$LN5@InterpretC|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M46342|
  00004	e1a06000	 mov         r6, r0

; 1428 :     BOOL fRet = TRUE;
; 1429 : 
; 1430 :     // set the host controller name
; 1431 :     SDHCDSetHCName(m_pHCContext, TEXT("SDHC"));

  00008	e59630a8	 ldr         r3, [r6, #0xA8]
  0000c	e59f1070	 ldr         r1, [pc, #0x70]
  00010	e3a0200f	 mov         r2, #0xF
  00014	e2830004	 add         r0, r3, #4
  00018	eb000000	 bl          wcsncpy

; 1432 : 
; 1433 :     // set init handler
; 1434 :     SDHCDSetControllerInitHandler(m_pHCContext, CSDIOControllerBase::SDHCInitialize);

  0001c	e59620a8	 ldr         r2, [r6, #0xA8]
  00020	e59f3058	 ldr         r3, [pc, #0x58]

; 1435 : 
; 1436 :     // set deinit handler
; 1437 :     SDHCDSetControllerDeinitHandler(m_pHCContext, CSDIOControllerBase::SDHCDeinitialize);

  00024	e59f1050	 ldr         r1, [pc, #0x50]

; 1438 : 
; 1439 :     // set the Send packet handler
; 1440 :     SDHCDSetBusRequestHandler(m_pHCContext, CSDIOControllerBase::SDHCBusRequestHandler);

  00028	e59fe048	 ldr         lr, [pc, #0x48]
  0002c	e5823044	 str         r3, [r2, #0x44]
  00030	e59630a8	 ldr         r3, [r6, #0xA8]

; 1441 : 
; 1442 :     // set the cancel I/O handler
; 1443 :     SDHCDSetCancelIOHandler(m_pHCContext, CSDIOControllerBase::SDHCCancelIoHandler);

  00034	e59f4038	 ldr         r4, [pc, #0x38]

; 1444 : 
; 1445 :     // set the slot option handler
; 1446 :     SDHCDSetSlotOptionHandler(m_pHCContext, CSDIOControllerBase::SDHCSlotOptionHandler);

  00038	e59f5030	 ldr         r5, [pc, #0x30]
  0003c	e5831048	 str         r1, [r3, #0x48]
  00040	e59630a8	 ldr         r3, [r6, #0xA8]

; 1447 : 
; 1448 :     // set maximum block length
; 1449 :     m_usMaxBlockLen = STD_HC_MAX_BLOCK_LENGTH;

  00044	e2862c01	 add         r2, r6, #1, 24
  00048	e3a01b02	 mov         r1, #2, 22
  0004c	e583e038	 str         lr, [r3, #0x38]
  00050	e59630a8	 ldr         r3, [r6, #0xA8]

; 1450 : 
; 1451 :     return fRet;

  00054	e3a00001	 mov         r0, #1
  00058	e5834040	 str         r4, [r3, #0x40]
  0005c	e59630a8	 ldr         r3, [r6, #0xA8]
  00060	e583503c	 str         r5, [r3, #0x3C]
  00064	e1c214bc	 strh        r1, [r2, #0x4C]

; 1452 : }

  00068	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0006c	e12fff1e	 bx          lr
  00070		 |$LN6@InterpretC|
  00070		 |$LN7@InterpretC|
  00070	00000000	 DCD         |?SDHCSlotOptionHandler@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@KW4_SD_SLOT_OPTION_CODE@@PAXK@Z|
  00074		 |$LN8@InterpretC|
  00074	00000000	 DCD         |?SDHCCancelIoHandler@CSDIOControllerBase@@SAEPAU_SDCARD_HC_CONTEXT@@KPAU_SD_BUS_REQUEST@@@Z|
  00078		 |$LN9@InterpretC|
  00078	00000000	 DCD         |?SDHCBusRequestHandler@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@KPAU_SD_BUS_REQUEST@@@Z|
  0007c		 |$LN10@InterpretC|
  0007c	00000000	 DCD         |?SDHCDeinitialize@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@@Z|
  00080		 |$LN11@InterpretC|
  00080	00000000	 DCD         |?SDHCInitialize@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@@Z|
  00084		 |$LN12@InterpretC|
  00084	00000000	 DCD         |??_C@_19IJCLBJAH@?$AAS?$AAD?$AAH?$AAC?$AA?$AA@|
  00088		 |$M46343|

			 ENDP  ; |?InterpretCapabilities@CSDIOControllerBase@@UAAHXZ|, CSDIOControllerBase::InterpretCapabilities

	END
