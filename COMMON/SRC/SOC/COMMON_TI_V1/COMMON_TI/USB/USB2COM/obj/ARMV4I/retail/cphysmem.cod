; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\USB\USB2COM\cphysmem.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|PulseEvent|
	IMPORT	|EventModify|
; File c:\wince600\osdesigns\z2170p\z2170p\wince600\z2170p_armv4i\cesysgen\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T33869| DCD	|$LN5@PulseEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PulseEvent| PROC

; 211  : _inline BOOL PulseEvent(HANDLE h) {

  00000		 |$LN5@PulseEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M33866|

; 212  : 	return EventModify(h,EVENT_PULSE);

  00004	e3a01001	 mov         r1, #1
  00008	eb000000	 bl          EventModify

; 213  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M33867|

			 ENDP  ; |PulseEvent|

	EXPORT	|?InitializeListHead@@YAXPAUtMEMLIST@@@Z| ; InitializeListHead
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cphysmem.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T33877| DCD	|$LN5@Initialize|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InitializeListHead@@YAXPAUtMEMLIST@@@Z| PROC ; InitializeListHead

; 210  : {

  00000		 |$LN5@Initialize|
  00000		 |$M33874|

; 211  :     _ListHead->next = _ListHead->prev = _ListHead;

  00000	e5800010	 str         r0, [r0, #0x10]
  00004	e580000c	 str         r0, [r0, #0xC]

; 212  : }

  00008	e12fff1e	 bx          lr
  0000c		 |$M33875|

			 ENDP  ; |?InitializeListHead@@YAXPAUtMEMLIST@@@Z|, InitializeListHead

	EXPORT	|?FirstNode@@YAPAUtMEMLIST@@PAU1@@Z|	; FirstNode

  00000			 AREA	 |.pdata|, PDATA
|$T33887| DCD	|$LN5@FirstNode|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FirstNode@@YAPAUtMEMLIST@@PAU1@@Z| PROC ; FirstNode

; 219  : { 

  00000		 |$LN5@FirstNode|
  00000		 |$M33884|

; 220  :     return(_ListHead->next); 

  00000	e590000c	 ldr         r0, [r0, #0xC]

; 221  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M33885|

			 ENDP  ; |?FirstNode@@YAPAUtMEMLIST@@PAU1@@Z|, FirstNode

	EXPORT	|?RemoveNode@@YAXPAUtMEMLIST@@@Z|	; RemoveNode

  00000			 AREA	 |.pdata|, PDATA
|$T33895| DCD	|$LN5@RemoveNode|
	DCD	0x40000a00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?RemoveNode@@YAXPAUtMEMLIST@@@Z| PROC	; RemoveNode

; 228  : {

  00000		 |$LN5@RemoveNode|
  00000		 |$M33892|

; 229  :     pNode->prev->next = pNode->next;

  00000	e5902010	 ldr         r2, [r0, #0x10]
  00004	e590300c	 ldr         r3, [r0, #0xC]

; 230  :     pNode->next->prev = pNode->prev;
; 231  :     pNode->next = NULL;

  00008	e3a01000	 mov         r1, #0
  0000c	e582300c	 str         r3, [r2, #0xC]
  00010	e590200c	 ldr         r2, [r0, #0xC]
  00014	e5903010	 ldr         r3, [r0, #0x10]
  00018	e5823010	 str         r3, [r2, #0x10]
  0001c	e580100c	 str         r1, [r0, #0xC]

; 232  :     pNode->prev = NULL;

  00020	e5801010	 str         r1, [r0, #0x10]

; 233  : }

  00024	e12fff1e	 bx          lr
  00028		 |$M33893|

			 ENDP  ; |?RemoveNode@@YAXPAUtMEMLIST@@@Z|, RemoveNode

	EXPORT	|?InsertNodeBefore@@YAXPAUtMEMLIST@@0@Z| ; InsertNodeBefore

  00000			 AREA	 |.pdata|, PDATA
|$T33904| DCD	|$LN5@InsertNode|
	DCD	0x40000700
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InsertNodeBefore@@YAXPAUtMEMLIST@@0@Z| PROC ; InsertNodeBefore

; 241  : {

  00000		 |$LN5@InsertNode|
  00000		 |$M33901|

; 242  :     pNodeExisting->prev->next = pNodeNew;

  00000	e5913010	 ldr         r3, [r1, #0x10]
  00004	e583000c	 str         r0, [r3, #0xC]

; 243  :     pNodeNew->prev = pNodeExisting->prev;

  00008	e5913010	 ldr         r3, [r1, #0x10]

; 244  :     pNodeNew->next = pNodeExisting;

  0000c	e580100c	 str         r1, [r0, #0xC]
  00010	e5803010	 str         r3, [r0, #0x10]

; 245  :     pNodeExisting->prev = pNodeNew;

  00014	e5810010	 str         r0, [r1, #0x10]

; 246  : }

  00018	e12fff1e	 bx          lr
  0001c		 |$M33902|

			 ENDP  ; |?InsertNodeBefore@@YAXPAUtMEMLIST@@0@Z|, InsertNodeBefore

	EXPORT	|?CreateNewNode@CPhysMem@@AAAPAUtMEMLIST@@KKK@Z| ; CPhysMem::CreateNewNode
	IMPORT	|LocalAlloc|

  00000			 AREA	 |.pdata|, PDATA
|$T33927| DCD	|$LN15@CreateNewN|
	DCD	0x40002001
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cphysmem.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CreateNewNode@CPhysMem@@AAAPAUtMEMLIST@@KKK@Z| PROC ; CPhysMem::CreateNewNode

; 352  : {

  00000		 |$LN15@CreateNewN|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M33924|
  00004	e1a05003	 mov         r5, r3
  00008	e1a06002	 mov         r6, r2
  0000c	e1b07001	 movs        r7, r1

; 353  : #ifdef DEBUG
; 354  :     if ( dwSize == 0 ) {
; 355  :         DEBUGCHK( dwVirtAddr == 0 &&
; 356  :                   dwPhysAddr == 0 );
; 357  :     } else {
; 358  :         DEBUGCHK( dwSize % CPHYSMEM_MEMORY_ALIGNMENT == 0 &&
; 359  :                   dwPhysAddr % CPHYSMEM_MEMORY_ALIGNMENT == 0 &&
; 360  :                   PUCHAR(dwVirtAddr) == PaToVa( dwPhysAddr ) );
; 361  :     }
; 362  : #endif // DEBUG
; 363  : 
; 364  :     PMEMLIST pNode;
; 365  :     //
; 366  :     // If we already have a node allocated and sitting around, use it.
; 367  :     //
; 368  :     if ((dwSize == 0) || IsListEmpty(m_pNodeFreeListHead)) {

  00010	e3a08000	 mov         r8, #0
  00014	0a00000d	 beq         |$LN3@CreateNewN|
  00018	e590e040	 ldr         lr, [r0, #0x40]
  0001c	e59e000c	 ldr         r0, [lr, #0xC]
  00020	e150000e	 cmp         r0, lr
  00024	0a000009	 beq         |$LN3@CreateNewN|

; 370  :     } else {
; 371  :         pNode = FirstNode(m_pNodeFreeListHead);

  00028	e1a04000	 mov         r4, r0

; 372  :         RemoveNode(pNode);

  0002c	e594e010	 ldr         lr, [r4, #0x10]
  00030	e594000c	 ldr         r0, [r4, #0xC]
  00034	e58e000c	 str         r0, [lr, #0xC]
  00038	e594e00c	 ldr         lr, [r4, #0xC]
  0003c	e5940010	 ldr         r0, [r4, #0x10]
  00040	e58e0010	 str         r0, [lr, #0x10]
  00044	e584800c	 str         r8, [r4, #0xC]
  00048	e5848010	 str         r8, [r4, #0x10]
  0004c	ea000003	 b           |$LN11@CreateNewN|
  00050		 |$LN3@CreateNewN|

; 369  :         pNode = (PMEMLIST) CPhysMem_Alloc(LPTR, sizeof(MEMLIST));

  00050	e3a01014	 mov         r1, #0x14
  00054	e3a00040	 mov         r0, #0x40
  00058	eb000000	 bl          LocalAlloc
  0005c	e1a04000	 mov         r4, r0

; 372  :         RemoveNode(pNode);

  00060		 |$LN11@CreateNewN|

; 373  :     }
; 374  : 
; 375  :     if (pNode != NULL) {

  00060	e3540000	 cmp         r4, #0

; 376  :         pNode->dwVirtAddr = dwVirtAddr;

  00064	15846000	 strne       r6, [r4]

; 377  :         pNode->dwPhysAddr = dwPhysAddr;

  00068	1284c004	 addne       r12, r4, #4
  0006c	188c01a0	 stmneia     r12, {r5, r7, r8}

; 378  :         pNode->dwSize = dwSize;
; 379  :         pNode->next = NULL;
; 380  :         pNode->prev = NULL;

  00070	15848010	 strne       r8, [r4, #0x10]

; 381  :     #ifdef DEBUG
; 382  :         _tcscpy( pNode->szDescription, TEXT("Default Desc") );
; 383  :     #endif // DEBUG
; 384  :     }
; 385  :     
; 386  :     return (pNode);
; 387  : }

  00074	e1a00004	 mov         r0, r4
  00078	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$M33925|

			 ENDP  ; |?CreateNewNode@CPhysMem@@AAAPAUtMEMLIST@@KKK@Z|, CPhysMem::CreateNewNode

	EXPORT	|?DeleteNode@CPhysMem@@AAAHPAUtMEMLIST@@@Z| ; CPhysMem::DeleteNode
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cphysmem.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T33947| DCD	|$LN9@DeleteNode|
	DCD	0x40000a00
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cphysmem.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DeleteNode@CPhysMem@@AAAHPAUtMEMLIST@@@Z| PROC ; CPhysMem::DeleteNode

; 397  : {

  00000		 |$LN9@DeleteNode|
  00000		 |$M33944|

; 398  :     //
; 399  :     // We don't actually delete any of the nodes. We just keep them on our
; 400  :     // free list to use later. Keeps us from thrashing on the heap.
; 401  :     //
; 402  : #ifdef DEBUG
; 403  :     pNode->dwSize = 0xdeadbeef;
; 404  :     pNode->dwPhysAddr = 0xdeadbeef;
; 405  :     pNode->dwVirtAddr = 0xdeadbeef;
; 406  :     _tcscpy( pNode->szDescription, TEXT("Deleted Node") );
; 407  : #endif // DEBUG
; 408  :     InsertNodeBefore(pNode, FirstNode(m_pNodeFreeListHead));

  00000	e5903040	 ldr         r3, [r0, #0x40]

; 409  :     return(TRUE);

  00004	e3a00001	 mov         r0, #1
  00008	e593200c	 ldr         r2, [r3, #0xC]
  0000c	e5923010	 ldr         r3, [r2, #0x10]
  00010	e583100c	 str         r1, [r3, #0xC]
  00014	e5923010	 ldr         r3, [r2, #0x10]
  00018	e581200c	 str         r2, [r1, #0xC]
  0001c	e5813010	 str         r3, [r1, #0x10]
  00020	e5821010	 str         r1, [r2, #0x10]

; 410  : }

  00024	e12fff1e	 bx          lr
  00028		 |$M33945|

			 ENDP  ; |?DeleteNode@CPhysMem@@AAAHPAUtMEMLIST@@@Z|, CPhysMem::DeleteNode

	EXPORT	|?FindFreeBlock@CPhysMem@@AAAPAUtMEMLIST@@KH@Z| ; CPhysMem::FindFreeBlock
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cphysmem.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T33978| DCD	|$LN21@FindFreeBl|
	DCD	0x40001d01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cphysmem.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FindFreeBlock@CPhysMem@@AAAPAUtMEMLIST@@KH@Z| PROC ; CPhysMem::FindFreeBlock

; 421  : {

  00000		 |$LN21@FindFreeBl|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M33975|
  00004	e3520000	 cmp         r2, #0
  00008	e1a0e000	 mov         lr, r0

; 422  :     DEBUGCHK( dwSize >= CPHYSMEM_MEMORY_ALIGNMENT &&
; 423  :               dwSize % CPHYSMEM_MEMORY_ALIGNMENT == 0 );
; 424  :     //
; 425  :     // The free list is sorted by increasing block sizes, so just find the 
; 426  :     // first block that's at least "dwSize" big.
; 427  :     //
; 428  :     PMEMLIST pNode = FirstNode(FREELIST(fHighPri));

  0000c	159e3074	 ldrne       r3, [lr, #0x74]
  00010	059e305c	 ldreq       r3, [lr, #0x5C]
  00014	e593000c	 ldr         r0, [r3, #0xC]
  00018		 |$LL3@FindFreeBl|

; 429  :     
; 430  :     while (!EndOfList(FREELIST(fHighPri), pNode)) {

  00018	e3520000	 cmp         r2, #0
  0001c	159e3074	 ldrne       r3, [lr, #0x74]
  00020	059e305c	 ldreq       r3, [lr, #0x5C]
  00024	e1530000	 cmp         r3, r0
  00028	0a00000e	 beq         |$LN2@FindFreeBl|

; 431  :         if (dwSize <= pNode->dwSize) {

  0002c	e5903008	 ldr         r3, [r0, #8]
  00030	e1510003	 cmp         r1, r3

; 432  :             RemoveNode(pNode);
; 433  :             return (pNode);
; 434  :         }
; 435  :         pNode = pNode->next;

  00034	8590000c	 ldrhi       r0, [r0, #0xC]
  00038	8afffff6	 bhi         |$LL3@FindFreeBl|
  0003c	e5902010	 ldr         r2, [r0, #0x10]
  00040	e590300c	 ldr         r3, [r0, #0xC]
  00044	e3a01000	 mov         r1, #0
  00048	e582300c	 str         r3, [r2, #0xC]
  0004c	e590200c	 ldr         r2, [r0, #0xC]
  00050	e5903010	 ldr         r3, [r0, #0x10]
  00054	e5823010	 str         r3, [r2, #0x10]
  00058	e580100c	 str         r1, [r0, #0xC]
  0005c	e5801010	 str         r1, [r0, #0x10]

; 439  : }

  00060	e49de004	 ldr         lr, [sp], #4
  00064	e12fff1e	 bx          lr
  00068		 |$LN2@FindFreeBl|

; 436  :     }
; 437  :     
; 438  :     return (NULL);

  00068	e3a00000	 mov         r0, #0

; 439  : }

  0006c	e49de004	 ldr         lr, [sp], #4
  00070	e12fff1e	 bx          lr
  00074		 |$M33976|

			 ENDP  ; |?FindFreeBlock@CPhysMem@@AAAPAUtMEMLIST@@KH@Z|, CPhysMem::FindFreeBlock

	EXPORT	|?AddNodeToFreeList@CPhysMem@@AAAHPAUtMEMLIST@@H@Z| ; CPhysMem::AddNodeToFreeList
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cphysmem.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T34066| DCD	|$LN57@AddNodeToF|
	DCD	0x40006601
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cphysmem.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AddNodeToFreeList@CPhysMem@@AAAHPAUtMEMLIST@@H@Z| PROC ; CPhysMem::AddNodeToFreeList

; 450  : {

  00000		 |$LN57@AddNodeToF|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M34063|
  00004	e1b05002	 movs        r5, r2
  00008	e1a0e001	 mov         lr, r1

; 451  :     //
; 452  :     // The free list is sorted by increasing block sizes, not by increasing
; 453  :     // address so we must scan the list for any possible connecting free blocks,
; 454  :     // and then coalesce them into a single free block. There will be at most
; 455  :     // two blocks to find (one on either end) so scan for both of them.
; 456  :     //
; 457  :     PMEMLIST pNodeTraverse = FirstNode(FREELIST(fHighPri));

  0000c	15901074	 ldrne       r1, [r0, #0x74]
  00010	0590105c	 ldreq       r1, [r0, #0x5C]

; 458  :     
; 459  :     PMEMLIST pNodePrevious = NULL; // Points to the previous connecting free block
; 460  :     PMEMLIST pNodeNext = NULL;     // Points to the next connecting free block
; 461  :     //
; 462  :     // The endpoints that we are trying to match up to.
; 463  :     //
; 464  :     DWORD dwThisPA = pNode->dwPhysAddr;

  00014	e59e7004	 ldr         r7, [lr, #4]

; 465  :     DWORD dwNextPA = MEMLIST_NEXT_PA(pNode);

  00018	e59e3008	 ldr         r3, [lr, #8]
  0001c	e591200c	 ldr         r2, [r1, #0xC]
  00020	e3a01000	 mov         r1, #0
  00024	e3a04000	 mov         r4, #0
  00028	e0838007	 add         r8, r3, r7
  0002c		 |$LL13@AddNodeToF|

; 466  : 
; 467  :     //
; 468  :     // Walk the list looking for blocks that are next to this one.
; 469  :     //
; 470  :     while (!EndOfList(FREELIST(fHighPri), pNodeTraverse)) {

  0002c	e3550000	 cmp         r5, #0
  00030	15903074	 ldrne       r3, [r0, #0x74]
  00034	0590305c	 ldreq       r3, [r0, #0x5C]
  00038	e1530002	 cmp         r3, r2
  0003c	0a00000d	 beq         |$LN53@AddNodeToF|

; 471  : 
; 472  :         if (dwThisPA == MEMLIST_NEXT_PA(pNodeTraverse)) {

  00040	e5926004	 ldr         r6, [r2, #4]
  00044	e5923008	 ldr         r3, [r2, #8]
  00048	e0833006	 add         r3, r3, r6
  0004c	e1570003	 cmp         r7, r3

; 473  :             //
; 474  :             // We've found the block just ahead of this one. Remember it.
; 475  :             //
; 476  :             pNodePrevious = pNodeTraverse;

  00050	01a04002	 moveq       r4, r2
  00054	0a000001	 beq         |$LN9@AddNodeToF|

; 477  : 
; 478  :         } else if (dwNextPA == pNodeTraverse->dwPhysAddr) {

  00058	e1580006	 cmp         r8, r6

; 479  :             //
; 480  :             // We've found the block just after of this one.
; 481  :             //
; 482  :             pNodeNext = pNodeTraverse;

  0005c	01a01002	 moveq       r1, r2
  00060		 |$LN9@AddNodeToF|

; 483  :         }
; 484  : 
; 485  :         if ((pNodePrevious == NULL) || (pNodeNext == NULL)) {

  00060	e3540000	 cmp         r4, #0
  00064	0a000001	 beq         |$LN7@AddNodeToF|
  00068	e3510000	 cmp         r1, #0
  0006c	1a000001	 bne         |$LN53@AddNodeToF|
  00070		 |$LN7@AddNodeToF|

; 486  :             //
; 487  :             // We haven't connected both ends, so keep on looking...
; 488  :             //
; 489  :             pNodeTraverse = pNodeTraverse->next;

  00070	e592200c	 ldr         r2, [r2, #0xC]

; 490  :         } else {
; 491  :             //
; 492  :             // We've found blocks to connect on both ends, let's get on with it.
; 493  :             //
; 494  :             break;
; 495  :         }
; 496  :     }

  00074	eaffffec	 b           |$LL13@AddNodeToF|
  00078		 |$LN53@AddNodeToF|

; 497  :     
; 498  : 
; 499  :     if (pNodePrevious != NULL) {

  00078	e3a06000	 mov         r6, #0
  0007c	e3540000	 cmp         r4, #0
  00080	0a000017	 beq         |$LN36@AddNodeToF|

; 500  :         //
; 501  :         // Combine with the previous block.
; 502  :         //
; 503  :         RemoveNode(pNodePrevious);

  00084	e5942010	 ldr         r2, [r4, #0x10]
  00088	e594300c	 ldr         r3, [r4, #0xC]
  0008c	e582300c	 str         r3, [r2, #0xC]
  00090	e594200c	 ldr         r2, [r4, #0xC]
  00094	e5943010	 ldr         r3, [r4, #0x10]
  00098	e5823010	 str         r3, [r2, #0x10]

; 504  :         //
; 505  :         // Grow pNode to hold both.
; 506  :         //
; 507  :         pNode->dwSize = pNode->dwSize + pNodePrevious->dwSize;

  0009c	e5943008	 ldr         r3, [r4, #8]
  000a0	e584600c	 str         r6, [r4, #0xC]
  000a4	e5846010	 str         r6, [r4, #0x10]
  000a8	e59e2008	 ldr         r2, [lr, #8]
  000ac	e0833002	 add         r3, r3, r2
  000b0	e58e3008	 str         r3, [lr, #8]

; 508  :         pNode->dwVirtAddr = pNodePrevious->dwVirtAddr;

  000b4	e5943000	 ldr         r3, [r4]
  000b8	e58e3000	 str         r3, [lr]

; 509  :         pNode->dwPhysAddr = pNodePrevious->dwPhysAddr;

  000bc	e5943004	 ldr         r3, [r4, #4]
  000c0	e58e3004	 str         r3, [lr, #4]

; 510  :         DeleteNode(pNodePrevious);

  000c4	e5903040	 ldr         r3, [r0, #0x40]
  000c8	e593200c	 ldr         r2, [r3, #0xC]
  000cc	e5923010	 ldr         r3, [r2, #0x10]
  000d0	e583400c	 str         r4, [r3, #0xC]
  000d4	e5923010	 ldr         r3, [r2, #0x10]
  000d8	e584200c	 str         r2, [r4, #0xC]
  000dc	e5843010	 str         r3, [r4, #0x10]
  000e0	e5824010	 str         r4, [r2, #0x10]
  000e4		 |$LN36@AddNodeToF|

; 511  :     }
; 512  : 
; 513  :     if (pNodeNext != NULL) {

  000e4	e3510000	 cmp         r1, #0
  000e8	0a000013	 beq         |$LN44@AddNodeToF|

; 514  :         //
; 515  :         // Combine with the next block.
; 516  :         //
; 517  :         RemoveNode(pNodeNext);

  000ec	e5912010	 ldr         r2, [r1, #0x10]
  000f0	e591300c	 ldr         r3, [r1, #0xC]
  000f4	e582300c	 str         r3, [r2, #0xC]
  000f8	e591200c	 ldr         r2, [r1, #0xC]
  000fc	e5913010	 ldr         r3, [r1, #0x10]
  00100	e5823010	 str         r3, [r2, #0x10]

; 518  :         //
; 519  :         // Grow pNode to hold both.
; 520  :         //
; 521  :         pNode->dwSize = pNode->dwSize + pNodeNext->dwSize;

  00104	e5913008	 ldr         r3, [r1, #8]
  00108	e581600c	 str         r6, [r1, #0xC]
  0010c	e5816010	 str         r6, [r1, #0x10]
  00110	e59e2008	 ldr         r2, [lr, #8]
  00114	e0833002	 add         r3, r3, r2
  00118	e58e3008	 str         r3, [lr, #8]

; 522  :     #ifdef DEBUG
; 523  :         // take description of the largest block
; 524  :         _tcscpy( pNode->szDescription, pNodeNext->szDescription );
; 525  :     #endif // DEBUG
; 526  :         DeleteNode(pNodeNext);

  0011c	e5903040	 ldr         r3, [r0, #0x40]
  00120	e593200c	 ldr         r2, [r3, #0xC]
  00124	e5923010	 ldr         r3, [r2, #0x10]
  00128	e583100c	 str         r1, [r3, #0xC]
  0012c	e5923010	 ldr         r3, [r2, #0x10]
  00130	e581200c	 str         r2, [r1, #0xC]
  00134	e5813010	 str         r3, [r1, #0x10]
  00138	e5821010	 str         r1, [r2, #0x10]
  0013c		 |$LN44@AddNodeToF|

; 527  :     }
; 528  : 
; 529  :     //
; 530  :     // Add pNode to the free list in sorted size order.
; 531  :     //
; 532  :     pNodeTraverse = FirstNode(FREELIST(fHighPri));

  0013c	e3550000	 cmp         r5, #0
  00140	15903074	 ldrne       r3, [r0, #0x74]
  00144	0590305c	 ldreq       r3, [r0, #0x5C]
  00148	e593100c	 ldr         r1, [r3, #0xC]
  0014c		 |$LL3@AddNodeToF|

; 533  :     
; 534  :     while (!EndOfList(FREELIST(fHighPri), pNodeTraverse)) {

  0014c	e3550000	 cmp         r5, #0
  00150	15903074	 ldrne       r3, [r0, #0x74]
  00154	0590305c	 ldreq       r3, [r0, #0x5C]
  00158	e1530001	 cmp         r3, r1
  0015c	0a000004	 beq         |$LN54@AddNodeToF|

; 535  : 
; 536  :         if (pNode->dwSize <= pNodeTraverse->dwSize) {

  00160	e59e2008	 ldr         r2, [lr, #8]
  00164	e5913008	 ldr         r3, [r1, #8]
  00168	e1520003	 cmp         r2, r3

; 537  :             break;
; 538  :         }
; 539  :         pNodeTraverse = pNodeTraverse->next;

  0016c	8591100c	 ldrhi       r1, [r1, #0xC]
  00170	8afffff5	 bhi         |$LL3@AddNodeToF|
  00174		 |$LN54@AddNodeToF|

; 540  :     }
; 541  : 
; 542  :     //
; 543  :     // Insert this node before the traverse node.
; 544  :     //
; 545  :     InsertNodeBefore(pNode, pNodeTraverse);

  00174	e5913010	 ldr         r3, [r1, #0x10]

; 546  : 
; 547  :     return TRUE;

  00178	e3a00001	 mov         r0, #1
  0017c	e583e00c	 str         lr, [r3, #0xC]
  00180	e5913010	 ldr         r3, [r1, #0x10]
  00184	e58e100c	 str         r1, [lr, #0xC]
  00188	e58e3010	 str         r3, [lr, #0x10]
  0018c	e581e010	 str         lr, [r1, #0x10]

; 548  : }

  00190	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00194	e12fff1e	 bx          lr
  00198		 |$M34064|

			 ENDP  ; |?AddNodeToFreeList@CPhysMem@@AAAHPAUtMEMLIST@@H@Z|, CPhysMem::AddNodeToFreeList

	EXPORT	|?FreeList@CPhysMem@@AAAHPAPAUtMEMLIST@@@Z| ; CPhysMem::FreeList
	IMPORT	|LocalFree|

  00000			 AREA	 |.pdata|, PDATA
|$T34081| DCD	|$LN11@FreeList|
	DCD	0x40001401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FreeList@CPhysMem@@AAAHPAPAUtMEMLIST@@@Z| PROC ; CPhysMem::FreeList

; 575  : {

  00000		 |$LN11@FreeList|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M34078|
  00004	e1a04001	 mov         r4, r1

; 576  :     PMEMLIST pCurrent;
; 577  :     PMEMLIST pNext;
; 578  : 
; 579  :     if ( *ppHead != NULL ) {

  00008	e5943000	 ldr         r3, [r4]
  0000c	e3530000	 cmp         r3, #0
  00010	0a00000b	 beq         |$LN3@FreeList|

; 580  :         pCurrent = (*ppHead)->next;

  00014	e593500c	 ldr         r5, [r3, #0xC]
  00018	ea000003	 b           |$LN8@FreeList|
  0001c		 |$LL2@FreeList|

; 581  :         while ( pCurrent != *ppHead ) {
; 582  :             DEBUGCHK( pCurrent != NULL );
; 583  :             pNext = pCurrent->next;
; 584  :             CPhysMem_Free( pCurrent );

  0001c	e1a00005	 mov         r0, r5
  00020	e595500c	 ldr         r5, [r5, #0xC]
  00024	eb000000	 bl          LocalFree
  00028	e5943000	 ldr         r3, [r4]
  0002c		 |$LN8@FreeList|

; 585  :             pCurrent = pNext;

  0002c	e1550003	 cmp         r5, r3
  00030	1afffff9	 bne         |$LL2@FreeList|

; 586  :         }
; 587  :         CPhysMem_Free( *ppHead );

  00034	e5940000	 ldr         r0, [r4]
  00038	eb000000	 bl          LocalFree

; 588  :         *ppHead = NULL;

  0003c	e3a03000	 mov         r3, #0
  00040	e5843000	 str         r3, [r4]
  00044		 |$LN3@FreeList|

; 589  :     }
; 590  : 
; 591  :     return(TRUE);

  00044	e3a00001	 mov         r0, #1

; 592  : }

  00048	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M34079|

			 ENDP  ; |?FreeList@CPhysMem@@AAAHPAPAUtMEMLIST@@@Z|, CPhysMem::FreeList

	EXPORT	|?AllocateSpecialMemory@CPhysMem@@QAAHKQAPAE@Z| ; CPhysMem::AllocateSpecialMemory

  00000			 AREA	 |.pdata|, PDATA
|$T34092| DCD	|$LN6@AllocateSp|
	DCD	0x40000800
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AllocateSpecialMemory@CPhysMem@@QAAHKQAPAE@Z| PROC ; CPhysMem::AllocateSpecialMemory

; 603  : {

  00000		 |$LN6@AllocateSp|
  00000		 |$M34089|

; 604  :     DEBUGCHK( dwSize <= USBPAGESIZE );
; 605  :     PREFAST_DEBUGCHK( pVirtAddr != NULL );
; 606  : 
; 607  :     // during suspend/resume this routine will be called again; we can safely
; 608  :     // leave the special memory set aside since we will always need the same amount.
; 609  :     if(!m_bSpecialTaken) {

  00000	e590304c	 ldr         r3, [r0, #0x4C]
  00004	e3530000	 cmp         r3, #0

; 610  :         m_bSpecialTaken = TRUE;

  00008	03a03001	 moveq       r3, #1
  0000c	0580304c	 streq       r3, [r0, #0x4C]

; 611  :         DEBUGCHK( m_dwSpecialPA == VaToPa( PUCHAR(m_dwSpecialVA) ) );
; 612  :         DEBUGCHK( m_dwSpecialPA % CPHYSMEM_MEMORY_ALIGNMENT == 0 );
; 613  :     }
; 614  : 
; 615  :     *pVirtAddr = (PUCHAR) m_dwSpecialVA;

  00010	e5903048	 ldr         r3, [r0, #0x48]

; 616  : 
; 617  :     DEBUGMSG(ZONE_CPHYSMEM && ZONE_VERBOSE,(TEXT("CPhysMem AllocateMemory : bSpecial allocated\r\n")));
; 618  :     return(TRUE);

  00014	e3a00001	 mov         r0, #1
  00018	e5823000	 str         r3, [r2]

; 619  : }

  0001c	e12fff1e	 bx          lr
  00020		 |$M34090|

			 ENDP  ; |?AllocateSpecialMemory@CPhysMem@@QAAHKQAPAE@Z|, CPhysMem::AllocateSpecialMemory

	EXPORT	|?FreeSpecialMemory@CPhysMem@@QAAXQAE@Z| ; CPhysMem::FreeSpecialMemory

  00000			 AREA	 |.pdata|, PDATA
|$T34100| DCD	|$LN5@FreeSpecia|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FreeSpecialMemory@CPhysMem@@QAAXQAE@Z| PROC ; CPhysMem::FreeSpecialMemory

; 624  : {

  00000		 |$LN5@FreeSpecia|
  00000		 |$M34097|

; 625  : 
; 626  :     DEBUGCHK( m_dwSpecialVA == (DWORD) virtAddr );
; 627  :     DEBUGCHK( m_bSpecialTaken );
; 628  : 
; 629  :     m_bSpecialTaken = FALSE;

  00000	e3a03000	 mov         r3, #0
  00004	e580304c	 str         r3, [r0, #0x4C]

; 630  : }

  00008	e12fff1e	 bx          lr
  0000c		 |$M34098|

			 ENDP  ; |?FreeSpecialMemory@CPhysMem@@QAAXQAE@Z|, CPhysMem::FreeSpecialMemory

	EXPORT	|?AllocateMemory@CPhysMem@@QAAHKQAPAEKPAH@Z| ; CPhysMem::AllocateMemory
	IMPORT	|WaitForSingleObject|
	IMPORT	|LeaveCriticalSection|
	IMPORT	|EnterCriticalSection|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cphysmem.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T34142| DCD	|$LN32@AllocateMe|
	DCD	0x40005b01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cphysmem.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AllocateMemory@CPhysMem@@QAAHKQAPAEKPAH@Z| PROC ; CPhysMem::AllocateMemory

; 640  : {

  00000		 |$LN32@AllocateMe|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M34139|
  00004	e1a08002	 mov         r8, r2
  00008	e1a04000	 mov         r4, r0
  0000c	e2411001	 sub         r1, r1, #1
  00010	e3c1101f	 bic         r1, r1, #0x1F
  00014	e2819020	 add         r9, r1, #0x20
  00018		 |$LL24@AllocateMe|

; 641  : #ifdef DEBUG
; 642  :     PREFAST_DEBUGCHK( pszMemDescription != NULL );
; 643  :     DEBUGCHK( dwPassedInSize > 0 );
; 644  :     // for now, only the following sets of flags should be passed in
; 645  :     DEBUGCHK( dwFlags == 0 || // low priority, allow blocking
; 646  :               dwFlags == CPHYSMEM_FLAG_NOBLOCK || // low priority, no blocking
; 647  :               dwFlags == (CPHYSMEM_FLAG_HIGHPRIORITY | CPHYSMEM_FLAG_NOBLOCK) ); // high pri, no blocking
; 648  : 
; 649  :     if ( dwFlags & CPHYSMEM_FLAG_NOBLOCK ) {
; 650  :         // pfRequestingAbort will be ignored for NO_BLOCK transfers,
; 651  :         // so why is caller passing it in? Note that nothing
; 652  :         // bad will happen if pfRequestingAbort != NULL, so
; 653  :         // this check can be removed in the future if need be.
; 654  :         DEBUGCHK( pfRequestingAbort == NULL );
; 655  :     } else {
; 656  :         // blocking transfers must pass in a pointer
; 657  :         // for allowing the transfer to abort, and
; 658  :         // the original state of this abort request
; 659  :         // should be FALSE. If not, the blocking
; 660  :         // request is ignored.
; 661  :         DEBUGCHK( pfRequestingAbort != NULL &&
; 662  :                   *pfRequestingAbort == FALSE );
; 663  :     }
; 664  : #endif // DEBUG
; 665  : 
; 666  :     PMEMLIST    pNode = NULL;
; 667  :     const BOOL  fHighPri = !!(dwFlags & CPHYSMEM_FLAG_HIGHPRIORITY);

  00018	e3130001	 tst         r3, #1
  0001c	13a06001	 movne       r6, #1
  00020	03a06000	 moveq       r6, #0

; 668  :     const BOOL  fNoBlock = !!(dwFlags & CPHYSMEM_FLAG_NOBLOCK);

  00024	e3130002	 tst         r3, #2
  00028	13a07001	 movne       r7, #1

; 669  :     // We keep our block sizes in multiples of CPHYSMEM_MEMORY_ALIGNMENT
; 670  :     DWORD       dwSize = ( (dwPassedInSize - 1) & ~(CPHYSMEM_MEMORY_ALIGNMENT - 1) )
; 671  :                                  + CPHYSMEM_MEMORY_ALIGNMENT;
; 672  : 
; 673  :     PREFAST_DEBUGCHK( pVirtAddr != NULL );
; 674  :     DEBUGCHK( dwSize % CPHYSMEM_MEMORY_ALIGNMENT == 0 );
; 675  :     DEBUGCHK( dwSize - dwPassedInSize < CPHYSMEM_MEMORY_ALIGNMENT );
; 676  :     DEBUGMSG(ZONE_CPHYSMEM && ZONE_VERBOSE && (dwSize != dwPassedInSize),
; 677  :              (TEXT("AllocateMemory Desc = %s: (roundup %d->%d)\r\n"), pszMemDescription, dwPassedInSize, dwSize ));
; 678  : 
; 679  :     EnterCriticalSection( &m_csLock );

  0002c	e2840010	 add         r0, r4, #0x10
  00030	03a07000	 moveq       r7, #0
  00034	eb000000	 bl          EnterCriticalSection

; 680  : 
; 681  :     DEBUGMSG( ZONE_CPHYSMEM && ZONE_VERBOSE, (TEXT("CPhysMem: Heap pri = %d before allocation of %d bytes:\n"), fHighPri, dwSize ) );
; 682  :     VALIDATE_HEAPS(fHighPri);
; 683  : 
; 684  :     //
; 685  :     // Scan the free list for the first chunk that's just big enough to satisfy
; 686  :     // this request. Remove from the free list. Chop it up (unless the result 
; 687  :     // is less than CPHYSMEM_MEMORY_ALIGNMENT bytes). Then re-sort the remaining
; 688  :     // free chunk back into the free list and place the newly allocated chunk on
; 689  :     // the IN USE list.
; 690  :     //
; 691  :     pNode = FindFreeBlock(dwSize, fHighPri);

  00038	e1a02006	 mov         r2, r6
  0003c	e1a01009	 mov         r1, r9
  00040	e1a00004	 mov         r0, r4
  00044	eb000000	 bl          |?FindFreeBlock@CPhysMem@@AAAPAUtMEMLIST@@KH@Z|
  00048	e1b05000	 movs        r5, r0

; 692  :     if ( pNode == NULL ) {

  0004c	1a00001f	 bne         |$LN2@AllocateMe|

; 693  :         if ( fHighPri ) {

  00050	e3560000	 cmp         r6, #0
  00054	0a000003	 beq         |$LN10@AllocateMe|

; 694  :             //
; 695  :             // Not available from High Priority region, try allocating from Normal region.
; 696  :             //
; 697  :             LeaveCriticalSection(&m_csLock);

  00058	e2840010	 add         r0, r4, #0x10
  0005c	eb000000	 bl          LeaveCriticalSection

; 698  : 
; 699  :             DEBUGCHK( dwFlags == (CPHYSMEM_FLAG_HIGHPRIORITY | CPHYSMEM_FLAG_NOBLOCK) );
; 700  :             return AllocateMemory( DEBUG_PARAM( pszMemDescription )
; 701  :                                    dwPassedInSize,
; 702  :                                    pVirtAddr,
; 703  :                                    CPHYSMEM_FLAG_NOBLOCK, // dwFlags & ~CPHYSMEM_FLAG_HIGHPRIORITY,
; 704  :                                    pfRequestingAbort );

  00060	e3a03002	 mov         r3, #2
  00064	eaffffeb	 b           |$LL24@AllocateMe|
  00068		 |$LN10@AllocateMe|

; 705  : 
; 706  :         } else if ( !fNoBlock &&
; 707  :                     pfRequestingAbort != NULL ) {

  00068	e3570000	 cmp         r7, #0
  0006c	1a00002a	 bne         |$LN8@AllocateMe|
  00070	e59d7020	 ldr         r7, [sp, #0x20]
  00074	e3570000	 cmp         r7, #0
  00078	0a000027	 beq         |$LN8@AllocateMe|
  0007c	e3a0a001	 mov         r10, #1
  00080		 |$LL7@AllocateMe|

; 708  :             //
; 709  :             // Caller requested block for memory 
; 710  :             //
; 711  :         #ifdef DEBUG
; 712  :             DWORD dwStartBlockTickCount = GetTickCount();
; 713  :         #endif // DEBUG
; 714  :             do {
; 715  :                 LeaveCriticalSection(&m_csLock);

  00080	e2840010	 add         r0, r4, #0x10
  00084	eb000000	 bl          LeaveCriticalSection

; 716  : 
; 717  :                 if ( *pfRequestingAbort == FALSE ) {

  00088	e5973000	 ldr         r3, [r7]
  0008c	e3530000	 cmp         r3, #0
  00090	1a000006	 bne         |$LN3@AllocateMe|

; 718  :                     m_fHasBlocked = TRUE;
; 719  :                     WaitForSingleObject(m_hFreeMemEvent, CPHYSMEM_BLOCK_FOR_MEM_INTERVAL );

  00094	e594002c	 ldr         r0, [r4, #0x2C]
  00098	e3e01000	 mvn         r1, #0
  0009c	e584a030	 str         r10, [r4, #0x30]
  000a0	eb000000	 bl          WaitForSingleObject

; 720  : 
; 721  :                     if ( *pfRequestingAbort ) {

  000a4	e5973000	 ldr         r3, [r7]
  000a8	e3530000	 cmp         r3, #0
  000ac	1a00001c	 bne         |$LN27@AllocateMe|
  000b0		 |$LN3@AllocateMe|

; 722  :                         *pVirtAddr = NULL;
; 723  :                         return FALSE;
; 724  :                     }
; 725  : 
; 726  :                     // if this fails, we've been waiting for memory too long
; 727  :                     DEBUGCHK( GetTickCount() - dwStartBlockTickCount < CPHYSMEM_DEBUG_MAXIMUM_BLOCK_TIME );
; 728  :                 }
; 729  : 
; 730  :                 EnterCriticalSection(&m_csLock);

  000b0	e2840010	 add         r0, r4, #0x10
  000b4	eb000000	 bl          EnterCriticalSection

; 731  : 
; 732  :                 pNode = FindFreeBlock(dwSize, fHighPri);

  000b8	e3a02000	 mov         r2, #0
  000bc	e1a01009	 mov         r1, r9
  000c0	e1a00004	 mov         r0, r4
  000c4	eb000000	 bl          |?FindFreeBlock@CPhysMem@@AAAPAUtMEMLIST@@KH@Z|
  000c8	e1b05000	 movs        r5, r0

; 733  :             } while ( pNode == NULL );

  000cc	0affffeb	 beq         |$LL7@AllocateMe|
  000d0		 |$LN2@AllocateMe|

; 738  :             *pVirtAddr = NULL;
; 739  :             return FALSE;
; 740  :         }
; 741  :     }
; 742  : 
; 743  :     // case pNode == NULL should have been handled above
; 744  : 
; 745  :     if ( pNode->dwSize - dwSize >= CPHYSMEM_MEMORY_ALIGNMENT) {

  000d0	e5953008	 ldr         r3, [r5, #8]
  000d4	e0431009	 sub         r1, r3, r9
  000d8	e3510020	 cmp         r1, #0x20
  000dc	3a00000a	 bcc         |$LN1@AllocateMe|

; 746  :         // There's enough left over to create a new block.
; 747  :         PMEMLIST pNodeNew = CreateNewNode(pNode->dwSize - dwSize,
; 748  :                                           pNode->dwVirtAddr + dwSize, 
; 749  :                                           pNode->dwPhysAddr + dwSize);

  000e0	e5953004	 ldr         r3, [r5, #4]
  000e4	e5952000	 ldr         r2, [r5]
  000e8	e1a00004	 mov         r0, r4
  000ec	e0833009	 add         r3, r3, r9
  000f0	e0822009	 add         r2, r2, r9
  000f4	eb000000	 bl          |?CreateNewNode@CPhysMem@@AAAPAUtMEMLIST@@KKK@Z|
  000f8	e1a01000	 mov         r1, r0

; 750  :     #ifdef DEBUG
; 751  :         _tcscpy( pNodeNew->szDescription, pNode->szDescription );
; 752  :     #endif // DEBUG
; 753  :         AddNodeToFreeList(pNodeNew, fHighPri);

  000fc	e1a00004	 mov         r0, r4
  00100	e1a02006	 mov         r2, r6
  00104	eb000000	 bl          |?AddNodeToFreeList@CPhysMem@@AAAHPAUtMEMLIST@@H@Z|

; 754  : 
; 755  :         pNode->dwSize = dwSize; // remember to resize old block

  00108	e5859008	 str         r9, [r5, #8]
  0010c		 |$LN1@AllocateMe|

; 756  :     }
; 757  : 
; 758  : #ifdef DEBUG
; 759  :     // add description to block
; 760  :     DEBUGCHK( _tcslen( pszMemDescription ) < CPHYSMEM_MAX_DEBUG_NODE_DESCRIPTION_LENGTH );
; 761  :     _tcscpy( pNode->szDescription, pszMemDescription );
; 762  :     // trash the memory before we return it to caller
; 763  :     memset( PUCHAR( pNode->dwVirtAddr ), GARBAGE, pNode->dwSize );
; 764  : #endif // DEBUG
; 765  : 
; 766  :     DEBUGMSG(ZONE_CPHYSMEM, (TEXT("CPhysMem AllocateMemory : PA = 0x%08X, VA = 0x%08X, Size = %d, Desc = %s\r\n"),
; 767  :                           pNode->dwPhysAddr, pNode->dwVirtAddr, pNode->dwSize, pNode->szDescription ) );
; 768  : 
; 769  :     // mark this node used
; 770  :     InsertNodeBefore(pNode, FirstNode(INUSELIST(fHighPri)));

  0010c	e3560000	 cmp         r6, #0
  00110	0a000006	 beq         |$LN18@AllocateMe|
  00114	e5943070	 ldr         r3, [r4, #0x70]
  00118	ea000005	 b           |$LN19@AllocateMe|
  0011c		 |$LN8@AllocateMe|

; 734  :             // rest of processing done below
; 735  :         } else {
; 736  :             DEBUGMSG( ZONE_WARNING, (TEXT("CPhysMem AllocateMemory : No memory available") ));
; 737  :             LeaveCriticalSection(&m_csLock);

  0011c	e2840010	 add         r0, r4, #0x10
  00120	eb000000	 bl          LeaveCriticalSection
  00124		 |$LN27@AllocateMe|
  00124	e3a03000	 mov         r3, #0
  00128	e3a00000	 mov         r0, #0
  0012c	ea00000b	 b           |$LN29@AllocateMe|
  00130		 |$LN18@AllocateMe|

; 756  :     }
; 757  : 
; 758  : #ifdef DEBUG
; 759  :     // add description to block
; 760  :     DEBUGCHK( _tcslen( pszMemDescription ) < CPHYSMEM_MAX_DEBUG_NODE_DESCRIPTION_LENGTH );
; 761  :     _tcscpy( pNode->szDescription, pszMemDescription );
; 762  :     // trash the memory before we return it to caller
; 763  :     memset( PUCHAR( pNode->dwVirtAddr ), GARBAGE, pNode->dwSize );
; 764  : #endif // DEBUG
; 765  : 
; 766  :     DEBUGMSG(ZONE_CPHYSMEM, (TEXT("CPhysMem AllocateMemory : PA = 0x%08X, VA = 0x%08X, Size = %d, Desc = %s\r\n"),
; 767  :                           pNode->dwPhysAddr, pNode->dwVirtAddr, pNode->dwSize, pNode->szDescription ) );
; 768  : 
; 769  :     // mark this node used
; 770  :     InsertNodeBefore(pNode, FirstNode(INUSELIST(fHighPri)));

  00130	e5943060	 ldr         r3, [r4, #0x60]
  00134		 |$LN19@AllocateMe|
  00134	e593200c	 ldr         r2, [r3, #0xC]

; 771  : 
; 772  :     VALIDATE_HEAPS(fHighPri);
; 773  : 
; 774  :     LeaveCriticalSection(&m_csLock);

  00138	e2840010	 add         r0, r4, #0x10
  0013c	e5923010	 ldr         r3, [r2, #0x10]
  00140	e583500c	 str         r5, [r3, #0xC]
  00144	e5923010	 ldr         r3, [r2, #0x10]
  00148	e585200c	 str         r2, [r5, #0xC]
  0014c	e5853010	 str         r3, [r5, #0x10]
  00150	e5825010	 str         r5, [r2, #0x10]
  00154	eb000000	 bl          LeaveCriticalSection

; 775  : 
; 776  :     DEBUGCHK( pNode->dwPhysAddr % CPHYSMEM_MEMORY_ALIGNMENT == 0 );
; 777  :     *pVirtAddr = PUCHAR( pNode->dwVirtAddr );

  00158	e5953000	 ldr         r3, [r5]

; 778  :     return TRUE;

  0015c	e3a00001	 mov         r0, #1
  00160		 |$LN29@AllocateMe|
  00160	e5883000	 str         r3, [r8]

; 779  : }

  00164	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00168	e12fff1e	 bx          lr
  0016c		 |$M34140|

			 ENDP  ; |?AllocateMemory@CPhysMem@@QAAHKQAPAEKPAH@Z|, CPhysMem::AllocateMemory

	EXPORT	|?FreeMemory@CPhysMem@@QAAXQAEKK@Z|	; CPhysMem::FreeMemory
; File c:\wince600\osdesigns\z2170p\z2170p\wince600\z2170p_armv4i\cesysgen\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T34182| DCD	|$LN29@FreeMemory|
	DCD	0x40003a01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cphysmem.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FreeMemory@CPhysMem@@QAAXQAEKK@Z| PROC ; CPhysMem::FreeMemory

; 789  : {

  00000		 |$LN29@FreeMemory|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M34179|
  00004	e1a08002	 mov         r8, r2
  00008	e1a09001	 mov         r9, r1
  0000c	e1a04000	 mov         r4, r0
  00010	e3a0a000	 mov         r10, #0
  00014		 |$LL22@FreeMemory|

; 790  :     // for now, only the following sets of flags should be passed in
; 791  :     DEBUGCHK( dwFlags == 0 || // low priority, allow blocking
; 792  :               dwFlags == CPHYSMEM_FLAG_NOBLOCK || // low priority, no blocking
; 793  :               dwFlags == (CPHYSMEM_FLAG_HIGHPRIORITY | CPHYSMEM_FLAG_NOBLOCK) ); // high pri, no blocking
; 794  : 
; 795  :     BOOL fRemoved = FALSE;
; 796  :     BOOL fHighPri = !!(dwFlags & CPHYSMEM_FLAG_HIGHPRIORITY);

  00014	e3130001	 tst         r3, #1
  00018	13a06001	 movne       r6, #1

; 797  : 
; 798  :     // caller of FreeMemory is capable of calling
; 799  :     // PaToVa or VaToPa if they need to. Also, 
; 800  :     // we shouldn't be called to free NULL memory.
; 801  :     DEBUGCHK( virtAddr != NULL && physAddr != 0 ); 
; 802  :     DEBUGCHK( virtAddr == PaToVa( physAddr ) );
; 803  :     DEBUGCHK( physAddr % CPHYSMEM_MEMORY_ALIGNMENT == 0 );
; 804  : 
; 805  :     EnterCriticalSection(&m_csLock);

  0001c	e2840010	 add         r0, r4, #0x10
  00020	03a06000	 moveq       r6, #0
  00024	e3a07000	 mov         r7, #0
  00028	eb000000	 bl          EnterCriticalSection

; 806  : 
; 807  :     PMEMLIST pNode = FirstNode(INUSELIST(fHighPri));

  0002c	e3560000	 cmp         r6, #0
  00030	15943070	 ldrne       r3, [r4, #0x70]
  00034	05943060	 ldreq       r3, [r4, #0x60]
  00038	e593500c	 ldr         r5, [r3, #0xC]
  0003c		 |$LL5@FreeMemory|

; 808  :     
; 809  :     DEBUGMSG( ZONE_CPHYSMEM && ZONE_VERBOSE, (TEXT("CPhysMem: Heap pri = %d before free VA = 0x%08x:\n"), fHighPri, virtAddr ) );
; 810  :     VALIDATE_HEAPS(fHighPri);
; 811  : 
; 812  :     //
; 813  :     // Walk the list looking for this block
; 814  :     //
; 815  :     while (!EndOfList(INUSELIST(fHighPri), pNode)) {

  0003c	e3560000	 cmp         r6, #0
  00040	15943070	 ldrne       r3, [r4, #0x70]
  00044	05943060	 ldreq       r3, [r4, #0x60]
  00048	e1530005	 cmp         r3, r5
  0004c	0a000014	 beq         |$LN4@FreeMemory|

; 816  : 
; 817  :         if ((pNode->dwVirtAddr == (DWORD) virtAddr) &&
; 818  :             (pNode->dwPhysAddr == (DWORD) physAddr)) {

  00050	e5953000	 ldr         r3, [r5]
  00054	e1530009	 cmp         r3, r9
  00058	1a000002	 bne         |$LN3@FreeMemory|
  0005c	e5953004	 ldr         r3, [r5, #4]
  00060	e1530008	 cmp         r3, r8
  00064	0a000001	 beq         |$LN25@FreeMemory|
  00068		 |$LN3@FreeMemory|

; 835  :             break;
; 836  :         }
; 837  :         pNode = pNode->next;

  00068	e595500c	 ldr         r5, [r5, #0xC]

; 838  :     }

  0006c	eafffff2	 b           |$LL5@FreeMemory|
  00070		 |$LN25@FreeMemory|

; 819  :             
; 820  :         #ifdef DEBUG
; 821  :             // trash this memory
; 822  :             DEBUGCHK( pNode->dwSize > 0 ); // otherwise, why are we calling FreeMemory??
; 823  :             memset( PUCHAR( pNode->dwVirtAddr ), GARBAGE, pNode->dwSize );
; 824  : 
; 825  :             DEBUGMSG(ZONE_CPHYSMEM, 
; 826  :                      (TEXT("CPhysMem FreeMemory : PA = 0x%08X, VA = 0x%08X, Size = %d, Desc = %s\r\n"),
; 827  :                      pNode->dwPhysAddr, pNode->dwVirtAddr, pNode->dwSize, pNode->szDescription ));
; 828  : 
; 829  :             // change description
; 830  :             _tcscpy( pNode->szDescription, TEXT("Freed Memory") );
; 831  :         #endif // DEBUG
; 832  :             RemoveNode(pNode);

  00070	e5950010	 ldr         r0, [r5, #0x10]
  00074	e595300c	 ldr         r3, [r5, #0xC]

; 833  :             AddNodeToFreeList(pNode, fHighPri);

  00078	e1a02006	 mov         r2, r6
  0007c	e1a01005	 mov         r1, r5
  00080	e580300c	 str         r3, [r0, #0xC]
  00084	e595e00c	 ldr         lr, [r5, #0xC]
  00088	e5953010	 ldr         r3, [r5, #0x10]
  0008c	e1a00004	 mov         r0, r4
  00090	e58e3010	 str         r3, [lr, #0x10]
  00094	e585a00c	 str         r10, [r5, #0xC]
  00098	e585a010	 str         r10, [r5, #0x10]
  0009c	eb000000	 bl          |?AddNodeToFreeList@CPhysMem@@AAAHPAUtMEMLIST@@H@Z|

; 834  :             fRemoved = TRUE;

  000a0	e3a07001	 mov         r7, #1
  000a4		 |$LN4@FreeMemory|

; 839  :     
; 840  :     if (fHighPri && !fRemoved) {

  000a4	e3560000	 cmp         r6, #0
  000a8	0a000005	 beq         |$LN2@FreeMemory|
  000ac	e3570000	 cmp         r7, #0
  000b0	1a000003	 bne         |$LN2@FreeMemory|

; 841  :         LeaveCriticalSection(&m_csLock);

  000b4	e2840010	 add         r0, r4, #0x10
  000b8	eb000000	 bl          LeaveCriticalSection

; 842  : 
; 843  :         //
; 844  :         // Try removing from normal region.
; 845  :         //
; 846  :         DEBUGCHK( dwFlags == ( CPHYSMEM_FLAG_HIGHPRIORITY | CPHYSMEM_FLAG_NOBLOCK ) );
; 847  :         FreeMemory( virtAddr,
; 848  :                     physAddr,
; 849  :                     CPHYSMEM_FLAG_NOBLOCK ); // dwFlags & ~CPHYSMEM_FLAG_HIGHPRIORITY

  000bc	e3a03002	 mov         r3, #2
  000c0	eaffffd3	 b           |$LL22@FreeMemory|
  000c4		 |$LN2@FreeMemory|

; 850  :         return;
; 851  :     }
; 852  :     DEBUGCHK( fRemoved );
; 853  :     
; 854  :     DEBUGMSG( ZONE_CPHYSMEM && ZONE_VERBOSE, (TEXT("CPhysMem: Heap pri = %d after free VA = 0x%08x:\n"), fHighPri, virtAddr ) );
; 855  :     VALIDATE_HEAPS(fHighPri);
; 856  : 
; 857  :     LeaveCriticalSection(&m_csLock);

  000c4	e2840010	 add         r0, r4, #0x10
  000c8	eb000000	 bl          LeaveCriticalSection

; 858  : 
; 859  :     //
; 860  :     // Signal everyone waiting for memory that some just became available.
; 861  :     //
; 862  :     if (m_fHasBlocked)

  000cc	e5943030	 ldr         r3, [r4, #0x30]
  000d0	e3530000	 cmp         r3, #0

; 863  :         PulseEvent(m_hFreeMemEvent);

  000d4	1594002c	 ldrne       r0, [r4, #0x2C]
  000d8	13a01001	 movne       r1, #1
  000dc	1b000000	 blne        EventModify

; 864  : }

  000e0	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  000e4	e12fff1e	 bx          lr
  000e8		 |$M34180|

			 ENDP  ; |?FreeMemory@CPhysMem@@QAAXQAEKK@Z|, CPhysMem::FreeMemory

	EXPORT	|?ReleaseBlockedCalls@CPhysMem@@QAAHXZ|	; CPhysMem::ReleaseBlockedCalls
; File c:\wince600\osdesigns\z2170p\z2170p\wince600\z2170p_armv4i\cesysgen\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T34196| DCD	|$LN8@ReleaseBlo|
	DCD	0x40000901
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cphysmem.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ReleaseBlockedCalls@CPhysMem@@QAAHXZ| PROC ; CPhysMem::ReleaseBlockedCalls

; 872  : {

  00000		 |$LN8@ReleaseBlo|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M34193|

; 873  :     //
; 874  :     // Signal everyone waiting for memory to check if they have been aborted.
; 875  :     //
; 876  :     if (m_fHasBlocked)

  00004	e5903030	 ldr         r3, [r0, #0x30]
  00008	e3530000	 cmp         r3, #0

; 877  :         PulseEvent(m_hFreeMemEvent);

  0000c	1590002c	 ldrne       r0, [r0, #0x2C]
  00010	13a01001	 movne       r1, #1
  00014	1b000000	 blne        EventModify

; 878  :     
; 879  :     return(TRUE);

  00018	e3a00001	 mov         r0, #1

; 880  : }

  0001c	e49de004	 ldr         lr, [sp], #4
  00020	e12fff1e	 bx          lr
  00024		 |$M34194|

			 ENDP  ; |?ReleaseBlockedCalls@CPhysMem@@QAAHXZ|, CPhysMem::ReleaseBlockedCalls

	EXPORT	|?ReInit@CPhysMem@@QAAXXZ|		; CPhysMem::ReInit
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cphysmem.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T34251| DCD	|$LN34@ReInit|
	DCD	0x40007801
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cphysmem.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ReInit@CPhysMem@@QAAXXZ| PROC	; CPhysMem::ReInit

; 156  : {

  00000		 |$LN34@ReInit|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M34248|
  00004	e1a04000	 mov         r4, r0

; 157  :     PMEMLIST pNode;
; 158  :     EnterCriticalSection(&m_csLock);

  00008	e2840010	 add         r0, r4, #0x10
  0000c	eb000000	 bl          EnterCriticalSection

; 159  :     //
; 160  :     // Create dummy entries for the list head (simpler linked list code)
; 161  :     //
; 162  :     FreeList(&m_pInUseListHead);

  00010	e2841060	 add         r1, r4, #0x60
  00014	e1a00004	 mov         r0, r4
  00018	eb000000	 bl          |?FreeList@CPhysMem@@AAAHPAPAUtMEMLIST@@@Z|

; 163  :     FreeList(&m_pFreeListHead);

  0001c	e284105c	 add         r1, r4, #0x5C
  00020	e1a00004	 mov         r0, r4
  00024	eb000000	 bl          |?FreeList@CPhysMem@@AAAHPAPAUtMEMLIST@@@Z|

; 164  :     FreeList(&m_pHighPriorityInUseListHead);

  00028	e2841070	 add         r1, r4, #0x70
  0002c	e1a00004	 mov         r0, r4
  00030	eb000000	 bl          |?FreeList@CPhysMem@@AAAHPAPAUtMEMLIST@@@Z|

; 165  :     FreeList(&m_pHighPriorityFreeListHead);

  00034	e2841074	 add         r1, r4, #0x74
  00038	e1a00004	 mov         r0, r4
  0003c	eb000000	 bl          |?FreeList@CPhysMem@@AAAHPAPAUtMEMLIST@@@Z|

; 166  :     FreeList(&m_pNodeFreeListHead);

  00040	e2841040	 add         r1, r4, #0x40
  00044	e1a00004	 mov         r0, r4
  00048	eb000000	 bl          |?FreeList@CPhysMem@@AAAHPAPAUtMEMLIST@@@Z|

; 167  :     
; 168  :     m_pNodeFreeListHead = CreateNewNode(0, 0, 0);

  0004c	e3a03000	 mov         r3, #0
  00050	e3a02000	 mov         r2, #0
  00054	e3a01000	 mov         r1, #0
  00058	e1a00004	 mov         r0, r4
  0005c	eb000000	 bl          |?CreateNewNode@CPhysMem@@AAAPAUtMEMLIST@@KKK@Z|
  00060	e3500000	 cmp         r0, #0
  00064	e5840040	 str         r0, [r4, #0x40]

; 169  :     if (m_pNodeFreeListHead) InitializeListHead(m_pNodeFreeListHead);

  00068	15800010	 strne       r0, [r0, #0x10]
  0006c	1580000c	 strne       r0, [r0, #0xC]

; 170  : 
; 171  :     DEBUGMSG(ZONE_CPHYSMEM && ZONE_VERBOSE, (TEXT("CPhysMem Init : NodeFreeListHead = 0x%08X\r\n"),
; 172  :                           m_pNodeFreeListHead));
; 173  :     
; 174  :     m_pFreeListHead = CreateNewNode(0, 0, 0);

  00070	e1a00004	 mov         r0, r4
  00074	e3a03000	 mov         r3, #0
  00078	e3a02000	 mov         r2, #0
  0007c	e3a01000	 mov         r1, #0
  00080	eb000000	 bl          |?CreateNewNode@CPhysMem@@AAAPAUtMEMLIST@@KKK@Z|
  00084	e3500000	 cmp         r0, #0
  00088	e584005c	 str         r0, [r4, #0x5C]

; 175  :     if (m_pFreeListHead) InitializeListHead(m_pFreeListHead);

  0008c	15800010	 strne       r0, [r0, #0x10]
  00090	1580000c	 strne       r0, [r0, #0xC]

; 176  : 
; 177  :     m_pInUseListHead = CreateNewNode(0, 0, 0);

  00094	e1a00004	 mov         r0, r4
  00098	e3a03000	 mov         r3, #0
  0009c	e3a02000	 mov         r2, #0
  000a0	e3a01000	 mov         r1, #0
  000a4	eb000000	 bl          |?CreateNewNode@CPhysMem@@AAAPAUtMEMLIST@@KKK@Z|
  000a8	e3500000	 cmp         r0, #0
  000ac	e5840060	 str         r0, [r4, #0x60]

; 178  :     if (m_pInUseListHead) InitializeListHead(m_pInUseListHead);

  000b0	15800010	 strne       r0, [r0, #0x10]
  000b4	1580000c	 strne       r0, [r0, #0xC]

; 179  :     
; 180  : 
; 181  :     DEBUGMSG(ZONE_CPHYSMEM && ZONE_VERBOSE, (TEXT("CPhysMem Init : FreeListHead = 0x%08X, InUseListHead = 0x%08X\r\n"), m_pFreeListHead, m_pInUseListHead));
; 182  : 
; 183  :     m_pHighPriorityFreeListHead = CreateNewNode(0, 0, 0);

  000b8	e1a00004	 mov         r0, r4
  000bc	e3a03000	 mov         r3, #0
  000c0	e3a02000	 mov         r2, #0
  000c4	e3a01000	 mov         r1, #0
  000c8	eb000000	 bl          |?CreateNewNode@CPhysMem@@AAAPAUtMEMLIST@@KKK@Z|
  000cc	e3500000	 cmp         r0, #0
  000d0	e5840074	 str         r0, [r4, #0x74]

; 184  :     if (m_pHighPriorityFreeListHead) InitializeListHead(m_pHighPriorityFreeListHead);

  000d4	15800010	 strne       r0, [r0, #0x10]
  000d8	1580000c	 strne       r0, [r0, #0xC]

; 185  : 
; 186  :     m_pHighPriorityInUseListHead = CreateNewNode(0, 0, 0);

  000dc	e1a00004	 mov         r0, r4
  000e0	e3a03000	 mov         r3, #0
  000e4	e3a02000	 mov         r2, #0
  000e8	e3a01000	 mov         r1, #0
  000ec	eb000000	 bl          |?CreateNewNode@CPhysMem@@AAAPAUtMEMLIST@@KKK@Z|
  000f0	e3500000	 cmp         r0, #0
  000f4	e5840070	 str         r0, [r4, #0x70]

; 187  :     if (m_pHighPriorityInUseListHead) InitializeListHead(m_pHighPriorityInUseListHead);

  000f8	15800010	 strne       r0, [r0, #0x10]
  000fc	1580000c	 strne       r0, [r0, #0xC]

; 188  : 
; 189  :     DEBUGMSG(ZONE_CPHYSMEM && ZONE_VERBOSE, (TEXT("CPhysMem Init : HighPriFreeListHead = 0x%08X, HighPriInUseListHead = 0x%08X\r\n"),
; 190  :                           m_pHighPriorityFreeListHead, m_pHighPriorityInUseListHead));
; 191  : 
; 192  :     // Send an alert if we're being constructed under OOM conditions.
; 193  :     m_fInitted =
; 194  :         (m_pNodeFreeListHead && m_pFreeListHead && m_pInUseListHead &&
; 195  :          m_pHighPriorityFreeListHead && m_pHighPriorityInUseListHead);

  00100	e5943040	 ldr         r3, [r4, #0x40]
  00104	e3530000	 cmp         r3, #0
  00108	0a00000b	 beq         |$LN12@ReInit|
  0010c	e594305c	 ldr         r3, [r4, #0x5C]
  00110	e3530000	 cmp         r3, #0
  00114	0a000008	 beq         |$LN12@ReInit|
  00118	e5943060	 ldr         r3, [r4, #0x60]
  0011c	e3530000	 cmp         r3, #0
  00120	0a000005	 beq         |$LN12@ReInit|
  00124	e5943074	 ldr         r3, [r4, #0x74]
  00128	e3530000	 cmp         r3, #0
  0012c	15943070	 ldrne       r3, [r4, #0x70]
  00130	13530000	 cmpne       r3, #0
  00134	13a0e001	 movne       lr, #1
  00138	1a000000	 bne         |$LN13@ReInit|
  0013c		 |$LN12@ReInit|
  0013c	e3a0e000	 mov         lr, #0
  00140		 |$LN13@ReInit|

; 196  : 
; 197  :     //
; 198  :     // One big chunk on the free list to start things off.
; 199  :     //
; 200  :     pNode = CreateNewNode(m_dwNormalSize, m_dwNormalVA, m_dwNormalPA);

  00140	e5943050	 ldr         r3, [r4, #0x50]
  00144	e5942054	 ldr         r2, [r4, #0x54]
  00148	e5941058	 ldr         r1, [r4, #0x58]
  0014c	e1a00004	 mov         r0, r4
  00150	e584e024	 str         lr, [r4, #0x24]
  00154	eb000000	 bl          |?CreateNewNode@CPhysMem@@AAAPAUtMEMLIST@@KKK@Z|
  00158	e3500000	 cmp         r0, #0
  0015c	e3a05000	 mov         r5, #0

; 201  :     if (pNode) {

  00160	0a000008	 beq         |$LN4@ReInit|

; 202  : #ifdef DEBUG
; 203  :         _tcscpy( pNode->szDescription, TEXT("Free Low Pri Mem") );
; 204  : #endif // DEBUG
; 205  :     
; 206  :         DEBUGMSG(ZONE_CPHYSMEM && ZONE_VERBOSE, (TEXT("CPhysMem Init : Main Free Heap Node = 0x%08X\r\n"), pNode));
; 207  :     
; 208  :         InsertNodeBefore(pNode, FirstNode(m_pFreeListHead));

  00164	e594305c	 ldr         r3, [r4, #0x5C]
  00168	e593200c	 ldr         r2, [r3, #0xC]
  0016c	e5923010	 ldr         r3, [r2, #0x10]
  00170	e583000c	 str         r0, [r3, #0xC]
  00174	e5923010	 ldr         r3, [r2, #0x10]
  00178	e580200c	 str         r2, [r0, #0xC]
  0017c	e5803010	 str         r3, [r0, #0x10]
  00180	e5820010	 str         r0, [r2, #0x10]

; 209  : 
; 210  :         VALIDATE_HEAPS(FALSE);
; 211  :     } else

  00184	ea000000	 b           |$LN3@ReInit|
  00188		 |$LN4@ReInit|

; 212  :         m_fInitted = FALSE;

  00188	e5845024	 str         r5, [r4, #0x24]
  0018c		 |$LN3@ReInit|

; 213  :     
; 214  :     //
; 215  :     // Same thing for High Priority Region
; 216  :     //
; 217  :     pNode = CreateNewNode(m_dwHighPrioritySize, m_dwHighPriorityVA, m_dwHighPriorityPA);

  0018c	e5943064	 ldr         r3, [r4, #0x64]
  00190	e5942068	 ldr         r2, [r4, #0x68]
  00194	e594106c	 ldr         r1, [r4, #0x6C]
  00198	e1a00004	 mov         r0, r4
  0019c	eb000000	 bl          |?CreateNewNode@CPhysMem@@AAAPAUtMEMLIST@@KKK@Z|
  001a0	e3500000	 cmp         r0, #0

; 218  :     if (pNode) {

  001a4	0a000008	 beq         |$LN2@ReInit|

; 219  : #ifdef DEBUG
; 220  :         _tcscpy( pNode->szDescription, TEXT("Free High Pri Mem") );
; 221  : #endif // DEBUG
; 222  :     
; 223  :         DEBUGMSG(ZONE_CPHYSMEM && ZONE_VERBOSE, (TEXT("CPhysMem Init : HighPri Free Heap Node = 0x%08X\r\n"),
; 224  :                                                  pNode));
; 225  :     
; 226  :         InsertNodeBefore(pNode, FirstNode(m_pHighPriorityFreeListHead));

  001a8	e5943074	 ldr         r3, [r4, #0x74]
  001ac	e593200c	 ldr         r2, [r3, #0xC]
  001b0	e5923010	 ldr         r3, [r2, #0x10]
  001b4	e583000c	 str         r0, [r3, #0xC]
  001b8	e5923010	 ldr         r3, [r2, #0x10]
  001bc	e580200c	 str         r2, [r0, #0xC]
  001c0	e5803010	 str         r3, [r0, #0x10]
  001c4	e5820010	 str         r0, [r2, #0x10]

; 227  :     
; 228  :         VALIDATE_HEAPS(TRUE);
; 229  :     } else

  001c8	ea000000	 b           |$LN1@ReInit|
  001cc		 |$LN2@ReInit|

; 230  :         m_fInitted = FALSE;

  001cc	e5845024	 str         r5, [r4, #0x24]
  001d0		 |$LN1@ReInit|

; 231  : 
; 232  :     LeaveCriticalSection(&m_csLock);

  001d0	e2840010	 add         r0, r4, #0x10
  001d4	eb000000	 bl          LeaveCriticalSection

; 233  : }

  001d8	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  001dc	e12fff1e	 bx          lr
  001e0		 |$M34249|

			 ENDP  ; |?ReInit@CPhysMem@@QAAXXZ|, CPhysMem::ReInit

	EXPORT	|??1CPhysMem@@QAA@XZ|			; CPhysMem::~CPhysMem
	IMPORT	|FreePhysMem|
	IMPORT	|CloseHandle|
	IMPORT	|DeleteCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T34259| DCD	|$LN6@CPhysMem|
	DCD	0x40001b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CPhysMem@@QAA@XZ| PROC		; CPhysMem::~CPhysMem

; 555  : {

  00000		 |$LN6@CPhysMem|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M34256|
  00004	e1a04000	 mov         r4, r0

; 556  :     DeleteCriticalSection(&m_csLock);

  00008	e2840010	 add         r0, r4, #0x10
  0000c	eb000000	 bl          DeleteCriticalSection

; 557  :     CloseHandle(m_hFreeMemEvent);

  00010	e594002c	 ldr         r0, [r4, #0x2C]
  00014	eb000000	 bl          CloseHandle

; 558  : 
; 559  :     FreeList(&m_pInUseListHead);

  00018	e2841060	 add         r1, r4, #0x60
  0001c	e1a00004	 mov         r0, r4
  00020	eb000000	 bl          |?FreeList@CPhysMem@@AAAHPAPAUtMEMLIST@@@Z|

; 560  :     FreeList(&m_pFreeListHead);

  00024	e284105c	 add         r1, r4, #0x5C
  00028	e1a00004	 mov         r0, r4
  0002c	eb000000	 bl          |?FreeList@CPhysMem@@AAAHPAPAUtMEMLIST@@@Z|

; 561  :     FreeList(&m_pHighPriorityInUseListHead);

  00030	e2841070	 add         r1, r4, #0x70
  00034	e1a00004	 mov         r0, r4
  00038	eb000000	 bl          |?FreeList@CPhysMem@@AAAHPAPAUtMEMLIST@@@Z|

; 562  :     FreeList(&m_pHighPriorityFreeListHead);

  0003c	e2841074	 add         r1, r4, #0x74
  00040	e1a00004	 mov         r0, r4
  00044	eb000000	 bl          |?FreeList@CPhysMem@@AAAHPAPAUtMEMLIST@@@Z|

; 563  : 
; 564  :     FreeList(&m_pNodeFreeListHead);

  00048	e2841040	 add         r1, r4, #0x40
  0004c	e1a00004	 mov         r0, r4
  00050	eb000000	 bl          |?FreeList@CPhysMem@@AAAHPAPAUtMEMLIST@@@Z|

; 565  : 
; 566  :     if (!m_fPhysFromPlat)

  00054	e5943028	 ldr         r3, [r4, #0x28]
  00058	e3530000	 cmp         r3, #0

; 567  :         FreePhysMem(m_pPhysicalBufferAddr);

  0005c	0594003c	 ldreq       r0, [r4, #0x3C]
  00060	0b000000	 bleq        FreePhysMem

; 568  : }

  00064	e8bd4010	 ldmia       sp!, {r4, lr}
  00068	e12fff1e	 bx          lr
  0006c		 |$M34257|

			 ENDP  ; |??1CPhysMem@@QAA@XZ|, CPhysMem::~CPhysMem

	EXPORT	|??0CPhysMem@@QAA@KKPAE0@Z|		; CPhysMem::CPhysMem
	IMPORT	|InitializeCriticalSection|
	IMPORT	|CreateEventW|
	IMPORT	|AllocPhysMem|
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T34275| DCD	|$LN8@CPhysMem@2|
	DCD	0x40006102
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CPhysMem@@QAA@KKPAE0@Z| PROC	; CPhysMem::CPhysMem

; 45   : {

  00000		 |$LN8@CPhysMem@2|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M34272|
  00008	e3530000	 cmp         r3, #0
  0000c	e1a08002	 mov         r8, r2
  00010	e1a07001	 mov         r7, r1
  00014	e1a06000	 mov         r6, r0
  00018	e59d1020	 ldr         r1, [sp, #0x20]
  0001c	e8860180	 stmia       r6, {r7, r8}
  00020	e586100c	 str         r1, [r6, #0xC]

; 46   : 
; 47   :     ASSERT(cbSize > 0 && cbHighPrioritySize > 0); // must be so or the driver cannot work.
; 48   : 
; 49   :     //
; 50   :     // The PDD can pass in a physical buffer, or we'll try to allocate one from 
; 51   :     // system RAM.
; 52   :     //
; 53   :     if (pVirtAddr && pPhysAddr) {

  00024	13510000	 cmpne       r1, #0

; 54   :         DEBUGMSG(ZONE_INIT,(TEXT("DMA buffer passed in from PDD\r\n")));
; 55   :         m_pPhysicalBufferAddr = pVirtAddr;
; 56   :         m_dwNormalVA = (DWORD) pVirtAddr;
; 57   :         m_dwNormalPA = (DWORD) pPhysAddr;
; 58   :         m_fPhysFromPlat = TRUE;

  00028	13a02001	 movne       r2, #1
  0002c	15862028	 strne       r2, [r6, #0x28]
  00030	e5863008	 str         r3, [r6, #8]
  00034	e3a09000	 mov         r9, #0
  00038	1586303c	 strne       r3, [r6, #0x3C]
  0003c	15863054	 strne       r3, [r6, #0x54]
  00040	15861050	 strne       r1, [r6, #0x50]
  00044	1a000009	 bne         |$LN2@CPhysMem@2|

; 59   :     }
; 60   :     else {
; 61   :         DEBUGMSG(ZONE_INIT,(TEXT("Allocating DMA buffer from system RAM\r\n")));
; 62   : 
; 63   :         m_pPhysicalBufferAddr = (PUCHAR)AllocPhysMem(cbSize,
; 64   :                                              PAGE_READWRITE|PAGE_NOCACHE,
; 65   :                                              0,    // Default alignment
; 66   :                                              0,    // Reserved
; 67   :                                              &m_dwNormalPA);

  00048	e2863050	 add         r3, r6, #0x50
  0004c	e58d3000	 str         r3, [sp]
  00050	e3a03000	 mov         r3, #0
  00054	e3a02000	 mov         r2, #0
  00058	e3a01f81	 mov         r1, #0x81, 30
  0005c	e1a00007	 mov         r0, r7
  00060	eb000000	 bl          AllocPhysMem
  00064	e586003c	 str         r0, [r6, #0x3C]

; 68   :         
; 69   :         m_dwNormalVA = (DWORD) m_pPhysicalBufferAddr;

  00068	e5860054	 str         r0, [r6, #0x54]

; 70   :         m_fPhysFromPlat = FALSE;

  0006c	e5869028	 str         r9, [r6, #0x28]
  00070		 |$LN2@CPhysMem@2|

; 71   :     }
; 72   :     {   // we want all blocks to have their Phys Addr divisible by
; 73   :         // CPHYSMEM_MEMORY_ALIGNMENT. To achieve this, we start off
; 74   :         // having the physical memory block aligned properly, and
; 75   :         // then allocate memory only in blocks divisible by 
; 76   :         // CPHYSMEM_MEMORY_ALIGNMENT
; 77   :         const DWORD dwOffset = m_dwNormalPA & (CPHYSMEM_MEMORY_ALIGNMENT - 1);

  00070	e5963050	 ldr         r3, [r6, #0x50]
  00074	e213001f	 ands        r0, r3, #0x1F

; 78   :         DEBUGCHK( dwOffset == m_dwNormalPA % CPHYSMEM_MEMORY_ALIGNMENT );
; 79   :         DEBUGCHK( cbSize > CPHYSMEM_MEMORY_ALIGNMENT );
; 80   :         if ( dwOffset != 0 ) {

  00078	0a000008	 beq         |$LN1@CPhysMem@2|

; 81   :             // skip over the first few bytes of memory, as it is not
; 82   :             // aligned properly. This shouldn't happen though, because
; 83   :             // the new memory should have been aligned on a page boundary
; 84   :             DEBUGCHK( 0 );
; 85   :             // we can't code -= dwOffset because then we'll enter
; 86   :             // memory that we don't own.
; 87   :             m_dwNormalVA += CPHYSMEM_MEMORY_ALIGNMENT - dwOffset;

  0007c	e5962054	 ldr         r2, [r6, #0x54]

; 88   :             m_dwNormalPA += CPHYSMEM_MEMORY_ALIGNMENT - dwOffset;

  00080	e0433000	 sub         r3, r3, r0
  00084	e2831020	 add         r1, r3, #0x20
  00088	e0423000	 sub         r3, r2, r0
  0008c	e2833020	 add         r3, r3, #0x20

; 89   :             cbSize -= CPHYSMEM_MEMORY_ALIGNMENT - dwOffset;

  00090	e0802007	 add         r2, r0, r7
  00094	e5863054	 str         r3, [r6, #0x54]
  00098	e5861050	 str         r1, [r6, #0x50]
  0009c	e2427020	 sub         r7, r2, #0x20
  000a0		 |$LN1@CPhysMem@2|

; 90   :         }
; 91   :     }
; 92   :     
; 93   :     m_dwTotalPhysMemSize = cbSize;
; 94   :     m_PaVaConversion = m_dwNormalPA - m_dwNormalVA;

  000a0	e5961054	 ldr         r1, [r6, #0x54]
  000a4	e5965050	 ldr         r5, [r6, #0x50]

; 95   :     
; 96   :     DEBUGMSG(ZONE_INIT,
; 97   :         (TEXT("CPhysMem   Total Alloc Region PhysAddr = 0x%08X, VirtAddr = 0x%08X, size = %d\r\n"),
; 98   :         m_dwNormalPA, m_dwNormalVA, m_dwTotalPhysMemSize));
; 99   : 
; 100  :     //
; 101  :     // Set aside a page for the special request.
; 102  :     //
; 103  :     m_dwSpecialVA = (DWORD) m_dwNormalVA;
; 104  :     m_dwSpecialPA = (DWORD) m_dwNormalPA;
; 105  :     m_dwNormalVA += USBPAGESIZE;
; 106  :     m_dwNormalPA += USBPAGESIZE;
; 107  :     cbSize -= USBPAGESIZE;
; 108  :     m_bSpecialTaken = FALSE;
; 109  :     memset((PVOID) m_dwSpecialVA, 0x00, USBPAGESIZE);

  000a8	e3a02a01	 mov         r2, #1, 20
  000ac	e286c048	 add         r12, r6, #0x48
  000b0	e88c0202	 stmia       r12, {r1, r9}
  000b4	e5960048	 ldr         r0, [r6, #0x48]
  000b8	e0453001	 sub         r3, r5, r1
  000bc	e281ea01	 add         lr, r1, #1, 20
  000c0	e2854a01	 add         r4, r5, #1, 20
  000c4	e3a01000	 mov         r1, #0
  000c8	e286c034	 add         r12, r6, #0x34
  000cc	e88c0088	 stmia       r12, {r3, r7}
  000d0	e5865044	 str         r5, [r6, #0x44]
  000d4	e286c050	 add         r12, r6, #0x50
  000d8	e88c4010	 stmia       r12, {r4, lr}
  000dc	eb000000	 bl          memset

; 110  : 
; 111  :     DEBUGMSG(ZONE_INIT,
; 112  :         (TEXT("CPhysMem Special Alloc Region PhysAddr = 0x%08X, VirtAddr = 0x%08X, size = %d\r\n"),
; 113  :         m_dwSpecialPA, m_dwSpecialVA, USBPAGESIZE));
; 114  : 
; 115  :     //
; 116  :     // Set aside the High Priority region.
; 117  :     //
; 118  :     m_dwHighPriorityVA = (DWORD) m_dwNormalVA;
; 119  :     m_dwHighPriorityPA = (DWORD) m_dwNormalPA;
; 120  :     m_dwNormalVA += cbHighPrioritySize;
; 121  :     m_dwNormalPA += cbHighPrioritySize;
; 122  :     cbSize -= cbHighPrioritySize;
; 123  :     m_dwHighPrioritySize = cbHighPrioritySize;
; 124  :     memset((PVOID) m_dwHighPriorityVA, 0x00, m_dwHighPrioritySize);

  000e0	e1a02008	 mov         r2, r8
  000e4	e3a01000	 mov         r1, #0
  000e8	e5963054	 ldr         r3, [r6, #0x54]
  000ec	e5964050	 ldr         r4, [r6, #0x50]
  000f0	e286c068	 add         r12, r6, #0x68
  000f4	e88c0108	 stmia       r12, {r3, r8}
  000f8	e0833008	 add         r3, r3, r8
  000fc	e084e008	 add         lr, r4, r8
  00100	e5960068	 ldr         r0, [r6, #0x68]
  00104	e5864064	 str         r4, [r6, #0x64]
  00108	e5863054	 str         r3, [r6, #0x54]
  0010c	e586e050	 str         lr, [r6, #0x50]
  00110	eb000000	 bl          memset
  00114	e0473008	 sub         r3, r7, r8

; 125  : 
; 126  :     DEBUGMSG(ZONE_INIT,
; 127  :         (TEXT("CPhysMem HighPri Alloc Region PhysAddr = 0x%08X, VirtAddr = 0x%08X, size = %d\r\n"),
; 128  :         m_dwHighPriorityPA, m_dwHighPriorityVA, m_dwHighPrioritySize));
; 129  : 
; 130  :     //
; 131  :     // And the rest is for normal allocations.
; 132  :     //
; 133  :     m_dwNormalSize = cbSize;
; 134  :     memset((PVOID) m_dwNormalVA, 0x00, m_dwNormalSize);

  00118	e5960054	 ldr         r0, [r6, #0x54]
  0011c	e2433a01	 sub         r3, r3, #1, 20
  00120	e1a02003	 mov         r2, r3
  00124	e3a01000	 mov         r1, #0
  00128	e5863058	 str         r3, [r6, #0x58]
  0012c	eb000000	 bl          memset

; 135  :     
; 136  :     DEBUGMSG(ZONE_INIT,
; 137  :         (TEXT("CPhysMem  Normal Alloc Region PhysAddr = 0x%08X, VirtAddr = 0x%08X, size = %d\r\n"),
; 138  :         m_dwNormalPA, m_dwNormalVA, m_dwNormalSize));
; 139  : 
; 140  : 
; 141  : 
; 142  :     m_hFreeMemEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

  00130	e3a03000	 mov         r3, #0
  00134	e3a02000	 mov         r2, #0
  00138	e3a01001	 mov         r1, #1
  0013c	e3a00000	 mov         r0, #0
  00140	eb000000	 bl          CreateEventW
  00144	e1a03000	 mov         r3, r0

; 143  :     m_fHasBlocked = FALSE;
; 144  :     InitializeCriticalSection(&m_csLock);

  00148	e2860010	 add         r0, r6, #0x10
  0014c	e286c02c	 add         r12, r6, #0x2C
  00150	e88c0208	 stmia       r12, {r3, r9}
  00154	eb000000	 bl          InitializeCriticalSection

; 145  : 
; 146  :     m_pInUseListHead = NULL;
; 147  :     m_pFreeListHead = NULL;
; 148  :     m_pHighPriorityInUseListHead = NULL;
; 149  :     m_pHighPriorityFreeListHead = NULL;
; 150  :     m_pNodeFreeListHead = NULL;
; 151  : 
; 152  :     ReInit();

  00158	e1a00006	 mov         r0, r6
  0015c	e5869060	 str         r9, [r6, #0x60]
  00160	e586905c	 str         r9, [r6, #0x5C]
  00164	e5869070	 str         r9, [r6, #0x70]
  00168	e5869074	 str         r9, [r6, #0x74]
  0016c	e5869040	 str         r9, [r6, #0x40]
  00170	eb000000	 bl          |?ReInit@CPhysMem@@QAAXXZ|

; 153  : 
; 154  : }

  00174	e1a00006	 mov         r0, r6
  00178	e28dd004	 add         sp, sp, #4
  0017c	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00180	e12fff1e	 bx          lr
  00184		 |$M34273|

			 ENDP  ; |??0CPhysMem@@QAA@KKPAE0@Z|, CPhysMem::CPhysMem

	END
