; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\USB\USB2COM\cdevice.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|ResetEvent|
	IMPORT	|EventModify|
; File c:\wince600\osdesigns\z2170p\z2170p\wince600\z2170p_armv4i\cesysgen\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T36215| DCD	|$LN5@ResetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ResetEvent| PROC

; 223  : _inline BOOL ResetEvent(HANDLE h) {

  00000		 |$LN5@ResetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36212|

; 224  : 	return EventModify(h,EVENT_RESET);

  00004	e3a01002	 mov         r1, #2
  00008	eb000000	 bl          EventModify

; 225  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M36213|

			 ENDP  ; |ResetEvent|

	EXPORT	|SetEvent|

  00000			 AREA	 |.pdata|, PDATA
|$T36225| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36222|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M36223|

			 ENDP  ; |SetEvent|

	EXPORT	|GetCurrentThread|

  00000			 AREA	 |.pdata|, PDATA
|$T36234| DCD	|$LN5@GetCurrent|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentThread| PROC

; 351  : _inline HANDLE GetCurrentThread(void) {

  00000		 |$LN5@GetCurrent|
  00000		 |$M36231|

; 352  : 	return ((HANDLE)(SH_CURTHREAD+SYS_HANDLE_BASE));

  00000	e3a00041	 mov         r0, #0x41

; 353  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M36232|

			 ENDP  ; |GetCurrentThread|

	EXPORT	|?UnlockCountdown@Countdown@@QAAXXZ|	; Countdown::UnlockCountdown
	IMPORT	|LeaveCriticalSection|
	IMPORT	|EnterCriticalSection|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T36242| DCD	|$LN5@UnlockCoun|
	DCD	0x40000901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UnlockCountdown@Countdown@@QAAXXZ| PROC ; Countdown::UnlockCountdown

; 62   :     void UnlockCountdown () {

  00000		 |$LN5@UnlockCoun|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M36239|
  00004	e1a04000	 mov         r4, r0

; 63   :         EnterCriticalSection(&cs);

  00008	eb000000	 bl          EnterCriticalSection

; 64   :         lock = FALSE;

  0000c	e3a03000	 mov         r3, #0

; 65   :         LeaveCriticalSection(&cs);

  00010	e1a00004	 mov         r0, r4
  00014	e5843018	 str         r3, [r4, #0x18]
  00018	eb000000	 bl          LeaveCriticalSection

; 66   :     }

  0001c	e8bd4010	 ldmia       sp!, {r4, lr}
  00020	e12fff1e	 bx          lr
  00024		 |$M36240|

			 ENDP  ; |?UnlockCountdown@Countdown@@QAAXXZ|, Countdown::UnlockCountdown

	EXPORT	|?Addr0LockEntry@CDeviceGlobal@@QAA?AW4e_CritSec_Status@@K@Z| ; CDeviceGlobal::Addr0LockEntry
	IMPORT	|?EnterCritSec_Ex@CritSec_Ex@@QAA?AW4e_CritSec_Status@@K@Z| ; CritSec_Ex::EnterCritSec_Ex
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T36253| DCD	|$LN5@Addr0LockE|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Addr0LockEntry@CDeviceGlobal@@QAA?AW4e_CritSec_Status@@K@Z| PROC ; CDeviceGlobal::Addr0LockEntry

; 60   :     CritSec_Status Addr0LockEntry(ULONG ulTimeout) { return m_csAddress0Lock.EnterCritSec_Ex(ulTimeout); };

  00000		 |$LN5@Addr0LockE|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36250|
  00004	e280002c	 add         r0, r0, #0x2C
  00008	eb000000	 bl          |?EnterCritSec_Ex@CritSec_Ex@@QAA?AW4e_CritSec_Status@@K@Z|
  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M36251|

			 ENDP  ; |?Addr0LockEntry@CDeviceGlobal@@QAA?AW4e_CritSec_Status@@K@Z|, CDeviceGlobal::Addr0LockEntry

	EXPORT	|?Addr0LockPrepareDelete@CDeviceGlobal@@QAAXXZ| ; CDeviceGlobal::Addr0LockPrepareDelete
	IMPORT	|?PrepareDeleteCritSec_Ex@CritSec_Ex@@QAAXXZ| ; CritSec_Ex::PrepareDeleteCritSec_Ex

  00000			 AREA	 |.pdata|, PDATA
|$T36261| DCD	|$LN5@Addr0LockP|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Addr0LockPrepareDelete@CDeviceGlobal@@QAAXXZ| PROC ; CDeviceGlobal::Addr0LockPrepareDelete

; 61   :     void Addr0LockPrepareDelete() { m_csAddress0Lock.PrepareDeleteCritSec_Ex ();};

  00000		 |$LN5@Addr0LockP|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36258|
  00004	e280002c	 add         r0, r0, #0x2C
  00008	eb000000	 bl          |?PrepareDeleteCritSec_Ex@CritSec_Ex@@QAAXXZ|
  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M36259|

			 ENDP  ; |?Addr0LockPrepareDelete@CDeviceGlobal@@QAAXXZ|, CDeviceGlobal::Addr0LockPrepareDelete

	EXPORT	|?Addr0LockLeave@CDeviceGlobal@@QAAXXZ|	; CDeviceGlobal::Addr0LockLeave
	IMPORT	|?LeaveCritSec_Ex@CritSec_Ex@@QAAXXZ|	; CritSec_Ex::LeaveCritSec_Ex

  00000			 AREA	 |.pdata|, PDATA
|$T36269| DCD	|$LN5@Addr0LockL|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Addr0LockLeave@CDeviceGlobal@@QAAXXZ| PROC ; CDeviceGlobal::Addr0LockLeave

; 62   :     void Addr0LockLeave() { m_csAddress0Lock.LeaveCritSec_Ex ();};

  00000		 |$LN5@Addr0LockL|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36266|
  00004	e280002c	 add         r0, r0, #0x2C
  00008	eb000000	 bl          |?LeaveCritSec_Ex@CritSec_Ex@@QAAXXZ|
  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M36267|

			 ENDP  ; |?Addr0LockLeave@CDeviceGlobal@@QAAXXZ|, CDeviceGlobal::Addr0LockLeave

	EXPORT	|?ObjCountdownInc@CDeviceGlobal@@QAAHXZ| ; CDeviceGlobal::ObjCountdownInc
	IMPORT	|?IncrCountdown@Countdown@@QAAHXZ|	; Countdown::IncrCountdown

  00000			 AREA	 |.pdata|, PDATA
|$T36279| DCD	|$LN5@ObjCountdo|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ObjCountdownInc@CDeviceGlobal@@QAAHXZ| PROC ; CDeviceGlobal::ObjCountdownInc

; 64   :     BOOL ObjCountdownInc () {return  m_objCountdown.IncrCountdown (); };

  00000		 |$LN5@ObjCountdo|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36276|
  00004	e2800054	 add         r0, r0, #0x54
  00008	eb000000	 bl          |?IncrCountdown@Countdown@@QAAHXZ|
  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M36277|

			 ENDP  ; |?ObjCountdownInc@CDeviceGlobal@@QAAHXZ|, CDeviceGlobal::ObjCountdownInc

	EXPORT	|?ObjCountdownDec@CDeviceGlobal@@QAAXXZ| ; CDeviceGlobal::ObjCountdownDec
	IMPORT	|?DecrCountdown@Countdown@@QAAXXZ|	; Countdown::DecrCountdown

  00000			 AREA	 |.pdata|, PDATA
|$T36287| DCD	|$LN5@ObjCountdo@2|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ObjCountdownDec@CDeviceGlobal@@QAAXXZ| PROC ; CDeviceGlobal::ObjCountdownDec

; 65   :     void ObjCountdownDec () { m_objCountdown.DecrCountdown ();};

  00000		 |$LN5@ObjCountdo@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36284|
  00004	e2800054	 add         r0, r0, #0x54
  00008	eb000000	 bl          |?DecrCountdown@Countdown@@QAAXXZ|
  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M36285|

			 ENDP  ; |?ObjCountdownDec@CDeviceGlobal@@QAAXXZ|, CDeviceGlobal::ObjCountdownDec

	EXPORT	|?GetpUSBDSelectConfigurationProc@CDeviceGlobal@@QAAP6AHPBU_USB_DEVICE@@PAE@ZXZ| ; CDeviceGlobal::GetpUSBDSelectConfigurationProc

  00000			 AREA	 |.pdata|, PDATA
|$T36297| DCD	|$LN5@GetpUSBDSe|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetpUSBDSelectConfigurationProc@CDeviceGlobal@@QAAP6AHPBU_USB_DEVICE@@PAE@ZXZ| PROC ; CDeviceGlobal::GetpUSBDSelectConfigurationProc

; 70   :     LPUSBD_SELECT_CONFIGURATION_PROC GetpUSBDSelectConfigurationProc() { return m_pUSBDSelectConfigurationProc; };

  00000		 |$LN5@GetpUSBDSe|
  00000		 |$M36294|
  00000	e5900078	 ldr         r0, [r0, #0x78]
  00004	e12fff1e	 bx          lr
  00008		 |$M36295|

			 ENDP  ; |?GetpUSBDSelectConfigurationProc@CDeviceGlobal@@QAAP6AHPBU_USB_DEVICE@@PAE@ZXZ|, CDeviceGlobal::GetpUSBDSelectConfigurationProc

	EXPORT	|?GetpUSBDSuspendedResumed@CDeviceGlobal@@QAAP6AHPAXH@ZXZ| ; CDeviceGlobal::GetpUSBDSuspendedResumed

  00000			 AREA	 |.pdata|, PDATA
|$T36307| DCD	|$LN5@GetpUSBDSu|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetpUSBDSuspendedResumed@CDeviceGlobal@@QAAP6AHPAXH@ZXZ| PROC ; CDeviceGlobal::GetpUSBDSuspendedResumed

; 71   :     LPUSBD_SUSPEND_RESUME_PROC GetpUSBDSuspendedResumed() { return m_pUSBDSuspendResumed; };

  00000		 |$LN5@GetpUSBDSu|
  00000		 |$M36304|
  00000	e5900084	 ldr         r0, [r0, #0x84]
  00004	e12fff1e	 bx          lr
  00008		 |$M36305|

			 ENDP  ; |?GetpUSBDSuspendedResumed@CDeviceGlobal@@QAAP6AHPAXH@ZXZ|, CDeviceGlobal::GetpUSBDSuspendedResumed

	EXPORT	|?GetpUSBDAttachProc@CDeviceGlobal@@QAAP6AHPAXIIPBU_USB_DEVICE@@PAPAX@ZXZ| ; CDeviceGlobal::GetpUSBDAttachProc

  00000			 AREA	 |.pdata|, PDATA
|$T36317| DCD	|$LN5@GetpUSBDAt|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetpUSBDAttachProc@CDeviceGlobal@@QAAP6AHPAXIIPBU_USB_DEVICE@@PAPAX@ZXZ| PROC ; CDeviceGlobal::GetpUSBDAttachProc

; 72   :     LPUSBD_ATTACH_PROC GetpUSBDAttachProc() { return m_pUSBDAttachProc; };

  00000		 |$LN5@GetpUSBDAt|
  00000		 |$M36314|
  00000	e590007c	 ldr         r0, [r0, #0x7C]
  00004	e12fff1e	 bx          lr
  00008		 |$M36315|

			 ENDP  ; |?GetpUSBDAttachProc@CDeviceGlobal@@QAAP6AHPAXIIPBU_USB_DEVICE@@PAPAX@ZXZ|, CDeviceGlobal::GetpUSBDAttachProc

	EXPORT	|?GetpUSBDDetachProc@CDeviceGlobal@@QAAP6AHPAX@ZXZ| ; CDeviceGlobal::GetpUSBDDetachProc

  00000			 AREA	 |.pdata|, PDATA
|$T36327| DCD	|$LN5@GetpUSBDDe|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetpUSBDDetachProc@CDeviceGlobal@@QAAP6AHPAX@ZXZ| PROC ; CDeviceGlobal::GetpUSBDDetachProc

; 73   :     LPUSBD_DETACH_PROC GetpUSBDDetachProc() { return m_pUSBDDetachProc; };

  00000		 |$LN5@GetpUSBDDe|
  00000		 |$M36324|
  00000	e5900080	 ldr         r0, [r0, #0x80]
  00004	e12fff1e	 bx          lr
  00008		 |$M36325|

			 ENDP  ; |?GetpUSBDDetachProc@CDeviceGlobal@@QAAP6AHPAX@ZXZ|, CDeviceGlobal::GetpUSBDDetachProc

	EXPORT	|?GetpHcdContext@CDeviceGlobal@@QAAPAXXZ| ; CDeviceGlobal::GetpHcdContext

  00000			 AREA	 |.pdata|, PDATA
|$T36337| DCD	|$LN5@GetpHcdCon|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetpHcdContext@CDeviceGlobal@@QAAPAXXZ| PROC ; CDeviceGlobal::GetpHcdContext

; 74   :     LPVOID             GetpHcdContext() { return m_pvHcdContext ;};

  00000		 |$LN5@GetpHcdCon|
  00000		 |$M36334|
  00000	e5900088	 ldr         r0, [r0, #0x88]
  00004	e12fff1e	 bx          lr
  00008		 |$M36335|

			 ENDP  ; |?GetpHcdContext@CDeviceGlobal@@QAAPAXXZ|, CDeviceGlobal::GetpHcdContext

	EXPORT	|?GetDeviceAddress@CDevice@@QAAEXZ|	; CDevice::GetDeviceAddress

  00000			 AREA	 |.pdata|, PDATA
|$T36347| DCD	|$LN5@GetDeviceA|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetDeviceAddress@CDevice@@QAAEXZ| PROC ; CDevice::GetDeviceAddress

; 225  :     UCHAR GetDeviceAddress() { return m_address; };

  00000		 |$LN5@GetDeviceA|
  00000		 |$M36344|
  00000	e5d00020	 ldrb        r0, [r0, #0x20]
  00004	e12fff1e	 bx          lr
  00008		 |$M36345|

			 ENDP  ; |?GetDeviceAddress@CDevice@@QAAEXZ|, CDevice::GetDeviceAddress

	EXPORT	|??0CDeviceGlobal@@QAA@XZ|		; CDeviceGlobal::CDeviceGlobal
	EXPORT	|??_7CDeviceGlobal@@6B@| [ DATA ]	; CDeviceGlobal::`vftable'
	IMPORT	|InitializeCriticalSection|
	IMPORT	|??0Countdown@@QAA@K@Z|			; Countdown::Countdown
	IMPORT	|??0CritSec_Ex@@QAA@XZ|			; CritSec_Ex::CritSec_Ex
	IMPORT	|_purecall|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T36357| DCD	|$LN5@CDeviceGlo|
	DCD	0x40001901

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7CDeviceGlobal@@6B@| DCD |_purecall|		; CDeviceGlobal::`vftable'
	DCD	|_purecall|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CDeviceGlobal@@QAA@XZ| PROC	; CDeviceGlobal::CDeviceGlobal

; 49   : {

  00000		 |$LN5@CDeviceGlo|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M36354|
  00004	e1a04000	 mov         r4, r0
  00008	e59f3050	 ldr         r3, [pc, #0x50]
  0000c	e480302c	 str         r3, [r0], #0x2C
  00010	eb000000	 bl          |??0CritSec_Ex@@QAA@XZ|
  00014	e3a01000	 mov         r1, #0
  00018	e2840054	 add         r0, r4, #0x54
  0001c	eb000000	 bl          |??0Countdown@@QAA@K@Z|

; 50   : 
; 51   :     m_dwFreeAddressArray[0]=0x00000001;

  00020	e3a03001	 mov         r3, #1
  00024	e584301c	 str         r3, [r4, #0x1C]

; 52   :     m_dwFreeAddressArray[1] = m_dwFreeAddressArray[2] = m_dwFreeAddressArray[3] = 0x00000000;

  00028	e3a03000	 mov         r3, #0

; 53   :     
; 54   :     m_hUSBDInstance = NULL;
; 55   :     m_pUSBDAttachProc = NULL;
; 56   :     m_pUSBDDetachProc = NULL;
; 57   :     m_pvHcdContext = NULL;
; 58   :     m_pUSBDSelectConfigurationProc = NULL;
; 59   : #ifdef DEBUG
; 60   :     g_fAlreadyCalled = FALSE;
; 61   : #endif // DEBUG
; 62   :     //InitCritSec_Ex( &m_csAddress0Lock );
; 63   :     InitializeCriticalSection( &m_csFreeAddressArrayLock );

  0002c	e2840008	 add         r0, r4, #8
  00030	e5843028	 str         r3, [r4, #0x28]
  00034	e5843024	 str         r3, [r4, #0x24]
  00038	e5843020	 str         r3, [r4, #0x20]
  0003c	e5843074	 str         r3, [r4, #0x74]
  00040	e584307c	 str         r3, [r4, #0x7C]
  00044	e5843080	 str         r3, [r4, #0x80]
  00048	e5843088	 str         r3, [r4, #0x88]
  0004c	e5843078	 str         r3, [r4, #0x78]
  00050	eb000000	 bl          InitializeCriticalSection

; 64   : };

  00054	e1a00004	 mov         r0, r4
  00058	e8bd4010	 ldmia       sp!, {r4, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$LN6@CDeviceGlo|
  00060		 |$LN7@CDeviceGlo|
  00060	00000000	 DCD         |??_7CDeviceGlobal@@6B@|
  00064		 |$M36355|

			 ENDP  ; |??0CDeviceGlobal@@QAA@XZ|, CDeviceGlobal::CDeviceGlobal

	EXPORT	|?Initialize@CDeviceGlobal@@QAAHPAX@Z|	; CDeviceGlobal::Initialize
	EXPORT	|??_C@_1BE@NANPENDH@?$AAH?$AAc?$AAd?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CE@MBINLHH@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AAe?$AAd?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CE@KAKNBFJP@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAD?$AAe?$AAt?$AAa?$AAc?$AAh?$AAe?$AAd?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CO@MCCAIHAO@?$AAH?$AAc?$AAd?$AAS?$AAe?$AAl?$AAe?$AAc?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DC@HKGGOMPG@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAS?$AAu?$AAs?$AAp?$AAe?$AAn?$AAd?$AAe?$AAR?$AAe?$AAs?$AAu?$AAm?$AAe?$AAd?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BC@MPAIGMIO@?$AAU?$AAS?$AAB?$AAD?$AA?4?$AAD?$AAL?$AAL?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|GetProcAddressW|
	IMPORT	|LoadDriver|
	IMPORT	|?Initialize@CritSec_Ex@@QAAXXZ|	; CritSec_Ex::Initialize
	IMPORT	|?gc_HcdFuncs@@3U_HCD_FUNCS@@A|		; gc_HcdFuncs
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T36376| DCD	|$LN10@Initialize|
	DCD	0x40004101

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@NANPENDH@?$AAH?$AAc?$AAd?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AA?$AA@| DCB "H"
	DCB	0x0, "c", 0x0, "d", 0x0, "A", 0x0, "t", 0x0, "t", 0x0, "a"
	DCB	0x0, "c", 0x0, "h", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CE@MBINLHH@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AAe?$AAd?$AA?$AA@| DCB "H"
	DCB	0x0, "c", 0x0, "d", 0x0, "D", 0x0, "e", 0x0, "v", 0x0, "i"
	DCB	0x0, "c", 0x0, "e", 0x0, "A", 0x0, "t", 0x0, "t", 0x0, "a"
	DCB	0x0, "c", 0x0, "h", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CE@KAKNBFJP@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAD?$AAe?$AAt?$AAa?$AAc?$AAh?$AAe?$AAd?$AA?$AA@| DCB "H"
	DCB	0x0, "c", 0x0, "d", 0x0, "D", 0x0, "e", 0x0, "v", 0x0, "i"
	DCB	0x0, "c", 0x0, "e", 0x0, "D", 0x0, "e", 0x0, "t", 0x0, "a"
	DCB	0x0, "c", 0x0, "h", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CO@MCCAIHAO@?$AAH?$AAc?$AAd?$AAS?$AAe?$AAl?$AAe?$AAc?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@| DCB "H"
	DCB	0x0, "c", 0x0, "d", 0x0, "S", 0x0, "e", 0x0, "l", 0x0, "e"
	DCB	0x0, "c", 0x0, "t", 0x0, "C", 0x0, "o", 0x0, "n", 0x0, "f"
	DCB	0x0, "i", 0x0, "g", 0x0, "u", 0x0, "r", 0x0, "a", 0x0, "t"
	DCB	0x0, "i", 0x0, "o", 0x0, "n", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DC@HKGGOMPG@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAS?$AAu?$AAs?$AAp?$AAe?$AAn?$AAd?$AAe?$AAR?$AAe?$AAs?$AAu?$AAm?$AAe?$AAd?$AA?$AA@| DCB "H"
	DCB	0x0, "c", 0x0, "d", 0x0, "D", 0x0, "e", 0x0, "v", 0x0, "i"
	DCB	0x0, "c", 0x0, "e", 0x0, "S", 0x0, "u", 0x0, "s", 0x0, "p"
	DCB	0x0, "e", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "R", 0x0, "e"
	DCB	0x0, "s", 0x0, "u", 0x0, "m", 0x0, "e", 0x0, "d", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BC@MPAIGMIO@?$AAU?$AAS?$AAB?$AAD?$AA?4?$AAD?$AAL?$AAL?$AA?$AA@| DCB "U"
	DCB	0x0, "S", 0x0, "B", 0x0, "D", 0x0, ".", 0x0, "D", 0x0, "L"
	DCB	0x0, "L", 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Initialize@CDeviceGlobal@@QAAHPAX@Z| PROC ; CDeviceGlobal::Initialize

; 85   : {

  00000		 |$LN10@Initialize|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M36373|
  00004	e1a04000	 mov         r4, r0

; 86   :     DEBUGMSG( ZONE_INIT, (TEXT("+CDeviceGlobal::Initialize\n")));
; 87   :     m_pHcd=pHcd;
; 88   : #ifdef DEBUG
; 89   :     DEBUGCHK( !g_fAlreadyCalled );
; 90   :     g_fAlreadyCalled = TRUE;
; 91   : #endif // DEBUG
; 92   : 
; 93   :     DEBUGCHK( DWORD(8 * sizeof( m_dwFreeAddressArray )) == DWORD(USB_MAX_ADDRESS + 1) &&
; 94   :               8 * sizeof( m_dwFreeAddressArray[0] ) == 32 &&
; 95   :               m_dwFreeAddressArray[ 0 ] == 0x00000001 &&
; 96   :               m_dwFreeAddressArray[ 1 ] == 0x00000000 &&
; 97   :               m_dwFreeAddressArray[ 2 ] == 0x00000000 &&
; 98   :               m_dwFreeAddressArray[ 3 ] == 0x00000000 );
; 99   : 
; 100  :     m_csAddress0Lock.Initialize();

  00008	e284002c	 add         r0, r4, #0x2C
  0000c	e5841004	 str         r1, [r4, #4]
  00010	eb000000	 bl          |?Initialize@CritSec_Ex@@QAAXXZ|

; 101  :     m_objCountdown.UnlockCountdown ();

  00014	e2840054	 add         r0, r4, #0x54
  00018	eb000000	 bl          EnterCriticalSection
  0001c	e3a03000	 mov         r3, #0
  00020	e2840054	 add         r0, r4, #0x54
  00024	e584306c	 str         r3, [r4, #0x6C]
  00028	eb000000	 bl          LeaveCriticalSection

; 102  :     // establish links to USBD.dll
; 103  :     {
; 104  :         // this procedure is called to establish a link to USBD
; 105  :         LPUSBD_HCD_ATTACH_PROC  lpHcdAttachProc = NULL;
; 106  :         // this is defined in uhcddrv.cpp
; 107  :         extern HCD_FUNCS gc_HcdFuncs;
; 108  : 
; 109  :         DEBUGCHK( m_pHcd != NULL &&
; 110  :                   m_hUSBDInstance == NULL &&
; 111  :                   m_pUSBDDetachProc == NULL &&
; 112  :                   m_pUSBDAttachProc == NULL &&
; 113  :                   m_pvHcdContext == NULL );
; 114  : 
; 115  :         m_hUSBDInstance = LoadDriver(TEXT("USBD.DLL"));

  0002c	e59f00cc	 ldr         r0, [pc, #0xCC]
  00030	eb000000	 bl          LoadDriver
  00034	e3500000	 cmp         r0, #0
  00038	e5840074	 str         r0, [r4, #0x74]

; 116  :         if ( m_hUSBDInstance == NULL ) {
; 117  :             DEBUGMSG(ZONE_ERROR,(TEXT("-CDevice::Initialize - Could not load USBD.DLL\r\n")));
; 118  :             return FALSE;

  0003c	0a000026	 beq         |$LN1@Initialize|

; 119  :         }
; 120  :         lpHcdAttachProc = (LPUSBD_HCD_ATTACH_PROC) GetProcAddress(m_hUSBDInstance, TEXT("HcdAttach"));

  00040	e59f10b4	 ldr         r1, [pc, #0xB4]
  00044	eb000000	 bl          GetProcAddressW

; 121  :         m_pUSBDAttachProc = (LPUSBD_ATTACH_PROC) GetProcAddress(m_hUSBDInstance, TEXT("HcdDeviceAttached"));

  00048	e59f10a8	 ldr         r1, [pc, #0xA8]
  0004c	e1a05000	 mov         r5, r0
  00050	e5940074	 ldr         r0, [r4, #0x74]
  00054	eb000000	 bl          GetProcAddressW

; 122  :         m_pUSBDDetachProc = (LPUSBD_DETACH_PROC) GetProcAddress(m_hUSBDInstance, TEXT("HcdDeviceDetached"));

  00058	e59f1094	 ldr         r1, [pc, #0x94]
  0005c	e1a03000	 mov         r3, r0
  00060	e5940074	 ldr         r0, [r4, #0x74]
  00064	e584307c	 str         r3, [r4, #0x7C]
  00068	eb000000	 bl          GetProcAddressW

; 123  :         m_pUSBDSelectConfigurationProc = (LPUSBD_SELECT_CONFIGURATION_PROC)GetProcAddress(m_hUSBDInstance, TEXT("HcdSelectConfiguration"));// Optional

  0006c	e59f107c	 ldr         r1, [pc, #0x7C]
  00070	e1a03000	 mov         r3, r0
  00074	e5940074	 ldr         r0, [r4, #0x74]
  00078	e5843080	 str         r3, [r4, #0x80]
  0007c	eb000000	 bl          GetProcAddressW

; 124  :         m_pUSBDSuspendResumed = (LPUSBD_SUSPEND_RESUME_PROC) GetProcAddress(m_hUSBDInstance, TEXT("HcdDeviceSuspendeResumed"));

  00080	e59f1064	 ldr         r1, [pc, #0x64]
  00084	e1a03000	 mov         r3, r0
  00088	e5940074	 ldr         r0, [r4, #0x74]
  0008c	e5843078	 str         r3, [r4, #0x78]
  00090	eb000000	 bl          GetProcAddressW

; 125  :         if ( m_pUSBDAttachProc == NULL ||
; 126  :              m_pUSBDDetachProc == NULL ||
; 127  :              lpHcdAttachProc == NULL ||
; 128  :              (*lpHcdAttachProc)(m_pHcd, &gc_HcdFuncs,  &m_pvHcdContext) == FALSE ) {

  00094	e594307c	 ldr         r3, [r4, #0x7C]
  00098	e5840084	 str         r0, [r4, #0x84]
  0009c	e3530000	 cmp         r3, #0
  000a0	0a00000d	 beq         |$LN1@Initialize|
  000a4	e5943080	 ldr         r3, [r4, #0x80]
  000a8	e3530000	 cmp         r3, #0
  000ac	0a00000a	 beq         |$LN1@Initialize|
  000b0	e3550000	 cmp         r5, #0
  000b4	0a000008	 beq         |$LN1@Initialize|
  000b8	e59f1028	 ldr         r1, [pc, #0x28]
  000bc	e5940004	 ldr         r0, [r4, #4]
  000c0	e2842088	 add         r2, r4, #0x88
  000c4	e1a0e00f	 mov         lr, pc
  000c8	e12fff15	 bx          r5
  000cc	e3500000	 cmp         r0, #0

; 132  :         }
; 133  :         DEBUGCHK( m_pvHcdContext != NULL );
; 134  :     }
; 135  : 
; 136  : 
; 137  :     DEBUGMSG( ZONE_INIT, (TEXT("-CDevice::Initialize, success!\n")));
; 138  :     return TRUE;

  000d0	13a00001	 movne       r0, #1

; 139  : }

  000d4	18bd4030	 ldmneia     sp!, {r4, r5, lr}
  000d8	112fff1e	 bxne        lr
  000dc		 |$LN1@Initialize|

; 129  : 
; 130  :             DEBUGMSG(ZONE_ERROR, (TEXT("-CDevice::Initialize - Could not establish USBD links\n")));
; 131  :             return FALSE;

  000dc	e3a00000	 mov         r0, #0

; 139  : }

  000e0	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000e4	e12fff1e	 bx          lr
  000e8		 |$LN11@Initialize|
  000e8		 |$LN12@Initialize|
  000e8	00000000	 DCD         |?gc_HcdFuncs@@3U_HCD_FUNCS@@A|
  000ec		 |$LN13@Initialize|
  000ec	00000000	 DCD         |??_C@_1DC@HKGGOMPG@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAS?$AAu?$AAs?$AAp?$AAe?$AAn?$AAd?$AAe?$AAR?$AAe?$AAs?$AAu?$AAm?$AAe?$AAd?$AA?$AA@|
  000f0		 |$LN14@Initialize|
  000f0	00000000	 DCD         |??_C@_1CO@MCCAIHAO@?$AAH?$AAc?$AAd?$AAS?$AAe?$AAl?$AAe?$AAc?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@|
  000f4		 |$LN15@Initialize|
  000f4	00000000	 DCD         |??_C@_1CE@KAKNBFJP@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAD?$AAe?$AAt?$AAa?$AAc?$AAh?$AAe?$AAd?$AA?$AA@|
  000f8		 |$LN16@Initialize|
  000f8	00000000	 DCD         |??_C@_1CE@MBINLHH@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AAe?$AAd?$AA?$AA@|
  000fc		 |$LN17@Initialize|
  000fc	00000000	 DCD         |??_C@_1BE@NANPENDH@?$AAH?$AAc?$AAd?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AA?$AA@|
  00100		 |$LN18@Initialize|
  00100	00000000	 DCD         |??_C@_1BC@MPAIGMIO@?$AAU?$AAS?$AAB?$AAD?$AA?4?$AAD?$AAL?$AAL?$AA?$AA@|
  00104		 |$M36374|

			 ENDP  ; |?Initialize@CDeviceGlobal@@QAAHPAX@Z|, CDeviceGlobal::Initialize

	EXPORT	|?DeInitialize@CDeviceGlobal@@QAAXXZ|	; CDeviceGlobal::DeInitialize
	EXPORT	|??_C@_1BE@MDMBICMJ@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAt?$AAa?$AAc?$AAh?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|FreeLibrary|
	IMPORT	|?WaitForCountdown@Countdown@@QAAXH@Z|	; Countdown::WaitForCountdown

  00000			 AREA	 |.pdata|, PDATA
|$T36393| DCD	|$LN7@DeInitiali|
	DCD	0x40001e01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@MDMBICMJ@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAt?$AAa?$AAc?$AAh?$AA?$AA@| DCB "H"
	DCB	0x0, "c", 0x0, "d", 0x0, "D", 0x0, "e", 0x0, "t", 0x0, "a"
	DCB	0x0, "c", 0x0, "h", 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DeInitialize@CDeviceGlobal@@QAAXXZ| PROC ; CDeviceGlobal::DeInitialize

; 152  : {

  00000		 |$LN7@DeInitiali|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M36390|
  00004	e1a04000	 mov         r4, r0

; 153  :     DEBUGMSG( ZONE_INIT, (TEXT("+CDevice::DeInitialize\n")));
; 154  : 
; 155  : #ifdef DEBUG
; 156  :     DEBUGCHK(g_fAlreadyCalled == TRUE);
; 157  :     g_fAlreadyCalled = FALSE;
; 158  : #endif // DEBUG
; 159  : 
; 160  :     // wait for any stray detach threads
; 161  :     // This can block waiting for a callback into a client driver to return.
; 162  :     // Since callbacks aren't supposed to block this oughtn't cause deadlock,
; 163  :     // but a misbehaving client driver can cause us serious grief.
; 164  :     // Nonetheless, not waiting means we might free USBD.DLL while it's still in use.
; 165  :     //DeleteCountdown(&m_objCountdown);
; 166  :     m_objCountdown.WaitForCountdown( TRUE);

  00008	e3a01001	 mov         r1, #1
  0000c	e2840054	 add         r0, r4, #0x54
  00010	eb000000	 bl          |?WaitForCountdown@Countdown@@QAAXH@Z|

; 167  : 
; 168  :     // unload USBD.dll
; 169  :     if ( m_hUSBDInstance ) {

  00014	e5943074	 ldr         r3, [r4, #0x74]
  00018	e3a05000	 mov         r5, #0
  0001c	e3530000	 cmp         r3, #0
  00020	0a000009	 beq         |$LN2@DeInitiali|

; 170  :         LPUSBD_HCD_DETACH_PROC lpHcdDetachProc;
; 171  :         lpHcdDetachProc = (LPUSBD_HCD_DETACH_PROC) GetProcAddress(m_hUSBDInstance, TEXT("HcdDetach"));

  00024	e59f1048	 ldr         r1, [pc, #0x48]
  00028	e1a00003	 mov         r0, r3
  0002c	eb000000	 bl          GetProcAddressW
  00030	e1b03000	 movs        r3, r0

; 172  :         if ( lpHcdDetachProc != NULL ) {
; 173  :             (*lpHcdDetachProc)(m_pvHcdContext);

  00034	15940088	 ldrne       r0, [r4, #0x88]
  00038	11a0e00f	 movne       lr, pc
  0003c	112fff13	 bxne        r3

; 174  :         }
; 175  :         FreeLibrary( m_hUSBDInstance );

  00040	e5940074	 ldr         r0, [r4, #0x74]
  00044	eb000000	 bl          FreeLibrary

; 176  :         m_hUSBDInstance = NULL;

  00048	e5845074	 str         r5, [r4, #0x74]
  0004c		 |$LN2@DeInitiali|

; 177  :     }
; 178  :     m_pUSBDAttachProc = NULL;
; 179  :     m_pUSBDDetachProc = NULL;
; 180  :     m_pvHcdContext = NULL;
; 181  : 
; 182  :     m_dwFreeAddressArray[0] = 0x00000001;

  0004c	e3a03001	 mov         r3, #1
  00050	e584301c	 str         r3, [r4, #0x1C]
  00054	e584507c	 str         r5, [r4, #0x7C]
  00058	e5845080	 str         r5, [r4, #0x80]
  0005c	e5845088	 str         r5, [r4, #0x88]

; 183  :     m_dwFreeAddressArray[1] = m_dwFreeAddressArray[2] = m_dwFreeAddressArray[3] = 0x00000000;

  00060	e5845028	 str         r5, [r4, #0x28]
  00064	e5845024	 str         r5, [r4, #0x24]
  00068	e5845020	 str         r5, [r4, #0x20]

; 184  : 
; 185  : 
; 186  :     DEBUGMSG( ZONE_INIT, (TEXT("-CDevice::DeInitialize\n")));
; 187  : }

  0006c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00070	e12fff1e	 bx          lr
  00074		 |$LN8@DeInitiali|
  00074		 |$LN9@DeInitiali|
  00074	00000000	 DCD         |??_C@_1BE@MDMBICMJ@?$AAH?$AAc?$AAd?$AAD?$AAe?$AAt?$AAa?$AAc?$AAh?$AA?$AA@|
  00078		 |$M36391|

			 ENDP  ; |?DeInitialize@CDeviceGlobal@@QAAXXZ|, CDeviceGlobal::DeInitialize

	EXPORT	|?ReserveAddress@CDeviceGlobal@@QAAHAAE@Z| ; CDeviceGlobal::ReserveAddress

  00000			 AREA	 |.pdata|, PDATA
|$T36413| DCD	|$LN12@ReserveAdd|
	DCD	0x40002201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ReserveAddress@CDeviceGlobal@@QAAHAAE@Z| PROC ; CDeviceGlobal::ReserveAddress

; 202  : {

  00000		 |$LN12@ReserveAdd|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M36410|
  00004	e1a07001	 mov         r7, r1
  00008	e1a04000	 mov         r4, r0

; 203  :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("+CDeviceGlobal::ReserveAddress\n")) );
; 204  : 
; 205  :     BOOL fSuccess = FALSE;
; 206  : 
; 207  :     EnterCriticalSection( &m_csFreeAddressArrayLock );

  0000c	e2840008	 add         r0, r4, #8
  00010	e3a05000	 mov         r5, #0
  00014	eb000000	 bl          EnterCriticalSection

; 208  : 
; 209  :     // the address has 7 bits:
; 210  :     //
; 211  :     // xxyyyyyb
; 212  :     //
; 213  :     // xxb is the index into the m_dwFreeAddressArray (0-3)
; 214  :     // yyyyyb is the bit of the m_dwFreeAddressArray[xxb] DWORD
; 215  :     // that the address corresponds to
; 216  : 
; 217  :     // address 0 should always be marked used
; 218  :     DEBUGCHK(m_dwFreeAddressArray[0] & 1 );
; 219  : 
; 220  :     for ( UCHAR address = 1; address <= USB_MAX_ADDRESS; address++ ) {

  00018	e3a00001	 mov         r0, #1
  0001c	e3a02001	 mov         r2, #1
  00020	e3a01001	 mov         r1, #1
  00024		 |$LL4@ReserveAdd|

; 221  :         const UCHAR index = (address >> 5); // 5 == log base 2 of 32

  00024	e1a032a0	 mov         r3, r0, lsr #5
  00028	e203e0ff	 and         lr, r3, #0xFF

; 222  :         const UCHAR bit = address & (32 - 1); // 32 == # of bits in DWORD
; 223  :         if ( (m_dwFreeAddressArray[ index ] & (1 << bit)) == 0 ) {

  0002c	e084310e	 add         r3, r4, lr, lsl #2
  00030	e593301c	 ldr         r3, [r3, #0x1C]
  00034	e202601f	 and         r6, r2, #0x1F
  00038	e1130611	 tst         r3, r1, lsl r6
  0003c	0a000005	 beq         |$LN8@ReserveAdd|
  00040	e2823001	 add         r3, r2, #1
  00044	e20300ff	 and         r0, r3, #0xFF
  00048	e1a02000	 mov         r2, r0
  0004c	e350007f	 cmp         r0, #0x7F
  00050	9afffff3	 bls         |$LL4@ReserveAdd|
  00054	ea000006	 b           |$LN2@ReserveAdd|
  00058		 |$LN8@ReserveAdd|

; 224  :             // this address is free
; 225  :             fSuccess = TRUE;
; 226  :             rAddress = address;
; 227  :             // mark address as used
; 228  :             m_dwFreeAddressArray[ index ] |= (1 << bit);

  00058	e084210e	 add         r2, r4, lr, lsl #2
  0005c	e5c70000	 strb        r0, [r7]
  00060	e592301c	 ldr         r3, [r2, #0x1C]
  00064	e3a01001	 mov         r1, #1
  00068	e3a05001	 mov         r5, #1
  0006c	e1833611	 orr         r3, r3, r1, lsl r6
  00070	e582301c	 str         r3, [r2, #0x1C]
  00074		 |$LN2@ReserveAdd|

; 229  :             break;
; 230  :         }
; 231  :     }
; 232  :     LeaveCriticalSection( &m_csFreeAddressArrayLock );

  00074	e2840008	 add         r0, r4, #8
  00078	eb000000	 bl          LeaveCriticalSection

; 233  : 
; 234  :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("-CDevice::ReserveAddress, returning rAddress %d, success = %d\n"), rAddress, fSuccess ) );
; 235  :     return fSuccess;
; 236  : }

  0007c	e1a00005	 mov         r0, r5
  00080	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00084	e12fff1e	 bx          lr
  00088		 |$M36411|

			 ENDP  ; |?ReserveAddress@CDeviceGlobal@@QAAHAAE@Z|, CDeviceGlobal::ReserveAddress

	EXPORT	|?FreeAddress@CDeviceGlobal@@QAAXE@Z|	; CDeviceGlobal::FreeAddress

  00000			 AREA	 |.pdata|, PDATA
|$T36423| DCD	|$LN5@FreeAddres|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FreeAddress@CDeviceGlobal@@QAAXE@Z| PROC ; CDeviceGlobal::FreeAddress

; 248  : {

  00000		 |$LN5@FreeAddres|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M36420|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 249  :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("+CDeviceGlobal::FreeAddress - address = %d\n"), address) );
; 250  : 
; 251  :     EnterCriticalSection( &m_csFreeAddressArrayLock );

  0000c	e2850008	 add         r0, r5, #8
  00010	eb000000	 bl          EnterCriticalSection

; 252  : 
; 253  :     // the address has 7 bits:
; 254  :     //
; 255  :     // xxyyyyyb
; 256  :     //
; 257  :     // xxb is the index into the m_dwFreeAddressArray (0-3)
; 258  :     // yyyyyb is the bit of the m_dwFreeAddressArray[xxb] DWORD
; 259  :     // that the address corresponds to
; 260  : 
; 261  :     const UCHAR index = (address >> 5); // 5 == log base 2 of 32

  00014	e1a032a4	 mov         r3, r4, lsr #5
  00018	e20330ff	 and         r3, r3, #0xFF
  0001c	e085e103	 add         lr, r5, r3, lsl #2

; 262  :     const UCHAR bit = address & (32 - 1); // 32 == # of bits in DWORD
; 263  : 
; 264  :     // make sure this address is marked as used
; 265  :     DEBUGCHK( index < 4 &&
; 266  :               (m_dwFreeAddressArray[ index ] & ( 1 << bit )) );
; 267  : 
; 268  :     // free this address
; 269  :     m_dwFreeAddressArray[ index ] &= ~(1 << bit);

  00020	e59e201c	 ldr         r2, [lr, #0x1C]
  00024	e204301f	 and         r3, r4, #0x1F
  00028	e3a01001	 mov         r1, #1

; 270  : 
; 271  :     LeaveCriticalSection( &m_csFreeAddressArrayLock );

  0002c	e1c23311	 bic         r3, r2, r1, lsl r3
  00030	e2850008	 add         r0, r5, #8
  00034	e58e301c	 str         r3, [lr, #0x1C]
  00038	eb000000	 bl          LeaveCriticalSection

; 272  : 
; 273  :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("-CDevice::FreeAddress - address = %d\n"), address) );
; 274  : }

  0003c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M36421|

			 ENDP  ; |?FreeAddress@CDeviceGlobal@@QAAXE@Z|, CDeviceGlobal::FreeAddress

	EXPORT	|?TransferDoneCallbackSetEvent@CDevice@@KAKPAX@Z| ; CDevice::TransferDoneCallbackSetEvent
; File c:\wince600\osdesigns\z2170p\z2170p\wince600\z2170p_armv4i\cesysgen\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T36436| DCD	|$LN7@TransferDo|
	DCD	0x40000601
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TransferDoneCallbackSetEvent@CDevice@@KAKPAX@Z| PROC ; CDevice::TransferDoneCallbackSetEvent

; 291  : {

  00000		 |$LN7@TransferDo|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36433|

; 292  :     DEBUGCHK( context );
; 293  :     SetEvent( (HANDLE) context );

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 294  :     return 0;

  0000c	e3a00000	 mov         r0, #0

; 295  : }

  00010	e49de004	 ldr         lr, [sp], #4
  00014	e12fff1e	 bx          lr
  00018		 |$M36434|

			 ENDP  ; |?TransferDoneCallbackSetEvent@CDevice@@KAKPAX@Z|, CDevice::TransferDoneCallbackSetEvent

	EXPORT	|??0CDevice@@QAA@EABU_USB_DEVICE_INFO@@HHEQAVCDeviceGlobal@@QAVCHub@@E@Z| ; CDevice::CDevice
	EXPORT	|??_7CDevice@@6B@| [ DATA ]		; CDevice::`vftable'
	EXPORT	|?DisableDevice@CDevice@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z| ; CDevice::DisableDevice
	EXPORT	|?SuspendResume@CDevice@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z| ; CDevice::SuspendResume
	EXPORT	|?ResumeNotification@CDevice@@UAAHXZ|	; CDevice::ResumeNotification
	EXPORT	|?NotifyOnSuspendedResumed@CDevice@@UAAHH@Z| ; CDevice::NotifyOnSuspendedResumed
	EXPORT	|?GetUSB2TT@CDevice@@UAAPAVCHub@@PAE0@Z| ; CDevice::GetUSB2TT
	IMPORT	|memcpy|
	IMPORT	|??_ECDevice@@UAAPAXI@Z|, WEAK |??_GCDevice@@UAAPAXI@Z| ; CDevice::`vector deleting destructor', CDevice::`scalar deleting destructor'

  00000			 AREA	 |.pdata|, PDATA
|$T36450| DCD	|$LN5@CDevice|
	DCD	0x40002101

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7CDevice@@6B@| DCD |??_ECDevice@@UAAPAXI@Z|		; CDevice::`vftable'
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|?DisableDevice@CDevice@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|
	DCD	|?SuspendResume@CDevice@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|
	DCD	|?ResumeNotification@CDevice@@UAAHXZ|
	DCD	|?NotifyOnSuspendedResumed@CDevice@@UAAHH@Z|
	DCD	|_purecall|
	DCD	|?GetUSB2TT@CDevice@@UAAPAVCHub@@PAE0@Z|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CDevice@@QAA@EABU_USB_DEVICE_INFO@@HHEQAVCDeviceGlobal@@QAVCHub@@E@Z| PROC ; CDevice::CDevice

; 333  : {

  00000		 |$LN5@CDevice|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M36447|
  00004	e1a08003	 mov         r8, r3
  00008	e1a06002	 mov         r6, r2
  0000c	e1a07001	 mov         r7, r1
  00010	e1a09000	 mov         r9, r0
  00014	e59fe064	 ldr         lr, [pc, #0x64]
  00018	e59d4028	 ldr         r4, [sp, #0x28]
  0001c	e5dd502c	 ldrb        r5, [sp, #0x2C]
  00020	e2890024	 add         r0, r9, #0x24
  00024	e3a02020	 mov         r2, #0x20
  00028	e1a01006	 mov         r1, r6
  0002c	e589e000	 str         lr, [r9]
  00030	e5894004	 str         r4, [r9, #4]
  00034	e5c95008	 strb        r5, [r9, #8]
  00038	e5c97020	 strb        r7, [r9, #0x20]
  0003c	eb000000	 bl          memcpy
  00040	e59de024	 ldr         lr, [sp, #0x24]
  00044	e59d201c	 ldr         r2, [sp, #0x1C]
  00048	e5dd1020	 ldrb        r1, [sp, #0x20]
  0004c	e3a03000	 mov         r3, #0

; 334  :     DEBUGMSG( ZONE_DEVICE && ZONE_VERBOSE, (TEXT("+CDevice::CDevice\n")) );
; 335  :     m_fIsSuspend = FALSE;
; 336  :     DEBUGCHK( m_deviceInfo.dwCount == sizeof( USB_DEVICE ) &&
; 337  :               m_deviceInfo.Descriptor.bDescriptorType == USB_DEVICE_DESCRIPTOR_TYPE &&
; 338  :               m_deviceInfo.Descriptor.bLength == sizeof( USB_DEVICE_DESCRIPTOR ) &&
; 339  :               address <= USB_MAX_ADDRESS &&
; 340  :               tierNumber <= USB_MAXIMUM_HUB_TIER + 1 );
; 341  : 
; 342  :     InitializeCriticalSection( &m_csDeviceLock );

  00050	e289000c	 add         r0, r9, #0xC
  00054	e589e050	 str         lr, [r9, #0x50]
  00058	e5892048	 str         r2, [r9, #0x48]
  0005c	e5c9104c	 strb        r1, [r9, #0x4C]
  00060	e5898044	 str         r8, [r9, #0x44]
  00064	e5c93054	 strb        r3, [r9, #0x54]
  00068	e589305c	 str         r3, [r9, #0x5C]
  0006c	e5893058	 str         r3, [r9, #0x58]
  00070	eb000000	 bl          InitializeCriticalSection

; 343  :     DEBUGMSG( ZONE_DEVICE && ZONE_VERBOSE, (TEXT("-CDevice::CDevice\n")) );
; 344  : }

  00074	e1a00009	 mov         r0, r9
  00078	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$LN6@CDevice|
  00080		 |$LN7@CDevice|
  00080	00000000	 DCD         |??_7CDevice@@6B@|
  00084		 |$M36448|

			 ENDP  ; |??0CDevice@@QAA@EABU_USB_DEVICE_INFO@@HHEQAVCDeviceGlobal@@QAVCHub@@E@Z|, CDevice::CDevice

; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T36461| DCD	|$LN5@ResumeNoti|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResumeNotification@CDevice@@UAAHXZ| PROC ; CDevice::ResumeNotification

; 159  :     virtual BOOL ResumeNotification() { return FALSE; };

  00000		 |$LN5@ResumeNoti|
  00000		 |$M36458|
  00000	e3a00000	 mov         r0, #0
  00004	e12fff1e	 bx          lr
  00008		 |$M36459|

			 ENDP  ; |?ResumeNotification@CDevice@@UAAHXZ|, CDevice::ResumeNotification


  00000			 AREA	 |.pdata|, PDATA
|$T36470| DCD	|$LN5@NotifyOnSu|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?NotifyOnSuspendedResumed@CDevice@@UAAHH@Z| PROC ; CDevice::NotifyOnSuspendedResumed

; 160  :     virtual BOOL NotifyOnSuspendedResumed(BOOL /*fResumed*/) { return FALSE; };

  00000		 |$LN5@NotifyOnSu|
  00000		 |$M36467|
  00000	e3a00000	 mov         r0, #0
  00004	e12fff1e	 bx          lr
  00008		 |$M36468|

			 ENDP  ; |?NotifyOnSuspendedResumed@CDevice@@UAAHH@Z|, CDevice::NotifyOnSuspendedResumed

; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T36486| DCD	|$LN13@GetUSB2TT|
	DCD	0x40001c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetUSB2TT@CDevice@@UAAPAVCHub@@PAE0@Z| PROC ; CDevice::GetUSB2TT

; 407  : {

  00000		 |$LN13@GetUSB2TT|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36483|

; 408  :     if (!m_fIsHighSpeed) {

  00004	e5903048	 ldr         r3, [r0, #0x48]
  00008	e3530000	 cmp         r3, #0
  0000c	1a000014	 bne         |$LN6@GetUSB2TT|

; 409  :         CHub *  pHub = m_pAttachedHub;

  00010	e5903004	 ldr         r3, [r0, #4]

; 410  :         UCHAR  sAttachedPort = m_sAttachedPort;

  00014	e5d0e008	 ldrb        lr, [r0, #8]
  00018	e1b00003	 movs        r0, r3

; 411  :         while (pHub!=NULL && pHub->m_fIsHighSpeed!=TRUE) {

  0001c	0a000011	 beq         |$LN7@GetUSB2TT|
  00020		 |$LL5@GetUSB2TT|
  00020	e5903048	 ldr         r3, [r0, #0x48]
  00024	e3530001	 cmp         r3, #1
  00028	0a000003	 beq         |$LN4@GetUSB2TT|

; 412  :             sAttachedPort = pHub->m_sAttachedPort;
; 413  :             pHub =  pHub->m_pAttachedHub;

  0002c	e5903004	 ldr         r3, [r0, #4]
  00030	e5d0e008	 ldrb        lr, [r0, #8]
  00034	e1b00003	 movs        r0, r3
  00038	1afffff8	 bne         |$LL5@GetUSB2TT|
  0003c		 |$LN4@GetUSB2TT|

; 414  :         }
; 415  :         if (pHub) {

  0003c	e3500000	 cmp         r0, #0
  00040	0a000008	 beq         |$LN7@GetUSB2TT|

; 416  :             if (pTTAddr)

  00044	e3510000	 cmp         r1, #0

; 417  :                 *pTTAddr = pHub->m_address;

  00048	15d03020	 ldrneb      r3, [r0, #0x20]
  0004c	15c13000	 strneb      r3, [r1]

; 418  :             if (pTTPort)

  00050	e3520000	 cmp         r2, #0
  00054	0a000003	 beq         |$LN7@GetUSB2TT|

; 419  :                 *pTTPort = sAttachedPort;

  00058	e5c2e000	 strb        lr, [r2]

; 424  : }

  0005c	e49de004	 ldr         lr, [sp], #4
  00060	e12fff1e	 bx          lr
  00064		 |$LN6@GetUSB2TT|

; 420  :         }
; 421  :         return pHub;
; 422  :     }
; 423  :     return NULL;

  00064	e3a00000	 mov         r0, #0
  00068		 |$LN7@GetUSB2TT|

; 424  : }

  00068	e49de004	 ldr         lr, [sp], #4
  0006c	e12fff1e	 bx          lr
  00070		 |$M36484|

			 ENDP  ; |?GetUSB2TT@CDevice@@UAAPAVCHub@@PAE0@Z|, CDevice::GetUSB2TT

	EXPORT	|?DeleteUsbConfigurationStructure@CDevice@@QBAXAAU_NON_CONST_USB_CONFIGURATION@@@Z| ; CDevice::DeleteUsbConfigurationStructure
	IMPORT	|??3@YAXPAX@Z|				; operator delete

  00000			 AREA	 |.pdata|, PDATA
|$T36507| DCD	|$LN17@DeleteUsbC|
	DCD	0x40002c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DeleteUsbConfigurationStructure@CDevice@@QBAXAAU_NON_CONST_USB_CONFIGURATION@@@Z| PROC ; CDevice::DeleteUsbConfigurationStructure

; 662  : {

  00000		 |$LN17@DeleteUsbC|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M36504|
  00004	e1a04001	 mov         r4, r1

; 663  :     DEBUGMSG( ZONE_DEVICE && ZONE_VERBOSE, (TEXT("+CDevice::DeleteUsbConfigurationStructure\n")));
; 664  : 
; 665  :     // this code is right out of the destructor of OHCD.cpp
; 666  :     if ( rConfig.lpInterfaces ) {

  00008	e5943018	 ldr         r3, [r4, #0x18]
  0000c	e3a09000	 mov         r9, #0
  00010	e1b05003	 movs        r5, r3
  00014	0a000020	 beq         |$LN8@DeleteUsbC|

; 667  :         DEBUGCHK( rConfig.Descriptor.bDescriptorType == USB_CONFIGURATION_DESCRIPTOR_TYPE &&
; 668  :                   rConfig.Descriptor.bLength == sizeof( USB_CONFIGURATION_DESCRIPTOR ) &&
; 669  :                   rConfig.dwNumInterfaces >= rConfig.Descriptor.bNumInterfaces );
; 670  :         LPNON_CONST_USB_INTERFACE lpInterface = rConfig.lpInterfaces;
; 671  :         for ( UINT iInterface = 0; iInterface < rConfig.dwNumInterfaces; ++iInterface, ++lpInterface ) {

  00018	e5943014	 ldr         r3, [r4, #0x14]
  0001c	e3a06000	 mov         r6, #0
  00020	e3530000	 cmp         r3, #0
  00024	9a000019	 bls         |$LN5@DeleteUsbC|
  00028		 |$LL7@DeleteUsbC|

; 672  :             if ( lpInterface->lpEndpoints ) {

  00028	e5953014	 ldr         r3, [r5, #0x14]
  0002c	e1b07003	 movs        r7, r3
  00030	0a00000e	 beq         |$LN4@DeleteUsbC|

; 673  :                 DEBUGCHK( lpInterface->Descriptor.bDescriptorType == USB_INTERFACE_DESCRIPTOR_TYPE );
; 674  :                 LPNON_CONST_USB_ENDPOINT lpEndpoint = lpInterface->lpEndpoints;
; 675  :                 for ( UINT iEndpoint = 0; iEndpoint < lpInterface->Descriptor.bNumEndpoints; ++iEndpoint, ++lpEndpoint ) {

  00034	e5d53008	 ldrb        r3, [r5, #8]
  00038	e3a08000	 mov         r8, #0
  0003c	e3530000	 cmp         r3, #0
  00040	0a000007	 beq         |$LN1@DeleteUsbC|
  00044		 |$LL3@DeleteUsbC|

; 676  :                     delete [] lpEndpoint->lpbExtended;

  00044	e597000c	 ldr         r0, [r7, #0xC]
  00048	eb000000	 bl          |??3@YAXPAX@Z|

; 677  :                     lpEndpoint->lpbExtended = NULL;

  0004c	e587900c	 str         r9, [r7, #0xC]
  00050	e5d53008	 ldrb        r3, [r5, #8]
  00054	e2888001	 add         r8, r8, #1
  00058	e2877014	 add         r7, r7, #0x14
  0005c	e1580003	 cmp         r8, r3
  00060	3afffff7	 bcc         |$LL3@DeleteUsbC|
  00064		 |$LN1@DeleteUsbC|

; 678  :                 }
; 679  :                 delete [] lpInterface->lpEndpoints;

  00064	e5950014	 ldr         r0, [r5, #0x14]
  00068	eb000000	 bl          |??3@YAXPAX@Z|

; 680  :                 lpInterface->lpEndpoints = NULL;

  0006c	e5859014	 str         r9, [r5, #0x14]
  00070		 |$LN4@DeleteUsbC|

; 681  :             }
; 682  :             delete [] lpInterface->lpbExtended;

  00070	e5950010	 ldr         r0, [r5, #0x10]
  00074	eb000000	 bl          |??3@YAXPAX@Z|

; 683  :             lpInterface->lpbExtended = NULL;

  00078	e5859010	 str         r9, [r5, #0x10]
  0007c	e5943014	 ldr         r3, [r4, #0x14]
  00080	e2866001	 add         r6, r6, #1
  00084	e285501c	 add         r5, r5, #0x1C
  00088	e1560003	 cmp         r6, r3
  0008c	3affffe5	 bcc         |$LL7@DeleteUsbC|
  00090		 |$LN5@DeleteUsbC|

; 684  :         }
; 685  :         delete [] rConfig.lpInterfaces;

  00090	e5940018	 ldr         r0, [r4, #0x18]
  00094	eb000000	 bl          |??3@YAXPAX@Z|

; 686  :         rConfig.lpInterfaces = NULL;

  00098	e5849018	 str         r9, [r4, #0x18]
  0009c		 |$LN8@DeleteUsbC|

; 687  :     }
; 688  :     delete [] rConfig.lpbExtended;

  0009c	e5940010	 ldr         r0, [r4, #0x10]
  000a0	eb000000	 bl          |??3@YAXPAX@Z|

; 689  :     rConfig.lpbExtended = NULL;

  000a4	e5849010	 str         r9, [r4, #0x10]

; 690  : 
; 691  :     DEBUGMSG( ZONE_DEVICE && ZONE_VERBOSE, (TEXT("-CDevice::DeleteUsbConfigurationStructure\n")));
; 692  : }

  000a8	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000ac	e12fff1e	 bx          lr
  000b0		 |$M36505|

			 ENDP  ; |?DeleteUsbConfigurationStructure@CDevice@@QBAXAAU_NON_CONST_USB_CONFIGURATION@@@Z|, CDevice::DeleteUsbConfigurationStructure

	EXPORT	|?AllocatePipeArray@CDevice@@IAAHXZ|	; CDevice::AllocatePipeArray
	IMPORT	|??2@YAPAXI@Z|				; operator new
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T36529| DCD	|$LN16@AllocatePi|
	DCD	0x40003301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AllocatePipeArray@CDevice@@IAAHXZ| PROC ; CDevice::AllocatePipeArray

; 706  : {

  00000		 |$LN16@AllocatePi|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M36526|
  00004	e1a05000	 mov         r5, r0

; 707  :     DEBUGMSG( ZONE_DEVICE && ZONE_VERBOSE, (TEXT("+CDevice(%s tier %d)::AllocatePipeArray\n"), GetDeviceType(), m_tierNumber ) );
; 708  : 
; 709  :     BOOL fSuccess = FALSE;
; 710  : 
; 711  :     EnterCriticalSection( &m_csDeviceLock );

  00008	e285000c	 add         r0, r5, #0xC
  0000c	e3a06000	 mov         r6, #0
  00010	eb000000	 bl          EnterCriticalSection

; 712  : 
; 713  :     DEBUGCHK( m_ppCPipe == NULL && // shouldn't be allocated yet
; 714  :               m_maxNumPipes == 0 && // shouldn't be allocated yet
; 715  :               m_deviceInfo.lpActiveConfig != NULL &&
; 716  :               m_deviceInfo.lpActiveConfig->lpInterfaces != NULL &&
; 717  :               m_deviceInfo.lpActiveConfig->lpInterfaces[0].Descriptor.bNumEndpoints <= 15 );
; 718  : 
; 719  :     // number of endpoints does not include the endpoint 0
; 720  :     int numPipes = 1;
; 721  : 
; 722  :     int bNumberEndpoints = 0;
; 723  :     int bInterfaceNumber = m_deviceInfo.lpActiveConfig->lpInterfaces[0].Descriptor.bInterfaceNumber;

  00014	e5957040	 ldr         r7, [r5, #0x40]
  00018	e3a0e001	 mov         lr, #1
  0001c	e3a02000	 mov         r2, #0
  00020	e5979018	 ldr         r9, [r7, #0x18]

; 724  :     int bCurNumEndpoints;
; 725  :     for(DWORD i = 0; i < m_deviceInfo.lpActiveConfig->dwNumInterfaces; ++i){

  00024	e5973014	 ldr         r3, [r7, #0x14]
  00028	e5d98006	 ldrb        r8, [r9, #6]
  0002c	e3530000	 cmp         r3, #0
  00030	9a000013	 bls         |$LN5@AllocatePi|
  00034	e1a03007	 mov         r3, r7
  00038	e5934014	 ldr         r4, [r3, #0x14]
  0003c	e3a01000	 mov         r1, #0
  00040		 |$LL7@AllocatePi|

; 726  :         if(bInterfaceNumber == m_deviceInfo.lpActiveConfig->lpInterfaces[i].Descriptor.bInterfaceNumber){

  00040	e0810009	 add         r0, r1, r9
  00044	e5d03006	 ldrb        r3, [r0, #6]
  00048	e1580003	 cmp         r8, r3
  0004c	1a000004	 bne         |$LN4@AllocatePi|

; 727  :             bCurNumEndpoints = m_deviceInfo.lpActiveConfig->lpInterfaces[i].Descriptor.bNumEndpoints;

  00050	e5d03008	 ldrb        r3, [r0, #8]

; 728  :             if(bNumberEndpoints < bCurNumEndpoints)

  00054	e1520003	 cmp         r2, r3
  00058	aa000006	 bge         |$LN6@AllocatePi|

; 729  :                 bNumberEndpoints = bCurNumEndpoints;

  0005c	e1a02003	 mov         r2, r3

; 730  :         } else {

  00060	ea000004	 b           |$LN6@AllocatePi|
  00064		 |$LN4@AllocatePi|

; 731  :             bInterfaceNumber = m_deviceInfo.lpActiveConfig->lpInterfaces[i].Descriptor.bInterfaceNumber;

  00064	e5973018	 ldr         r3, [r7, #0x18]

; 732  :             numPipes += bNumberEndpoints;

  00068	e08ee002	 add         lr, lr, r2
  0006c	e0833001	 add         r3, r3, r1
  00070	e5d38006	 ldrb        r8, [r3, #6]

; 733  :             bNumberEndpoints = m_deviceInfo.lpActiveConfig->lpInterfaces[i].Descriptor.bNumEndpoints;

  00074	e5d32008	 ldrb        r2, [r3, #8]
  00078		 |$LN6@AllocatePi|
  00078	e281101c	 add         r1, r1, #0x1C
  0007c	e2544001	 subs        r4, r4, #1
  00080	1affffee	 bne         |$LL7@AllocatePi|
  00084		 |$LN5@AllocatePi|

; 734  :         }
; 735  :     }
; 736  :     numPipes += bNumberEndpoints;

  00084	e08e4002	 add         r4, lr, r2

; 737  : 
; 738  :     DEBUGMSG( ZONE_DEVICE && ZONE_VERBOSE, (TEXT("CDevice(%s tier %d)::AllocatePipeArray - attempting to allocate %d pipes\n"), GetDeviceType(), m_tierNumber, numPipes) );
; 739  :     m_ppCPipe = new CPipeAbs* [ numPipes ];

  00088	e3740107	 cmn         r4, #7, 2
  0008c	91a00104	 movls       r0, r4, lsl #2
  00090	83e00000	 mvnhi       r0, #0
  00094	eb000000	 bl          |??2@YAPAXI@Z|
  00098	e3500000	 cmp         r0, #0
  0009c	e585005c	 str         r0, [r5, #0x5C]

; 740  :     if ( m_ppCPipe != NULL ) {

  000a0	0a000004	 beq         |$LN1@AllocatePi|

; 741  :         memset( m_ppCPipe, 0, numPipes * sizeof( CPipeAbs * ) );

  000a4	e1a02104	 mov         r2, r4, lsl #2
  000a8	e3a01000	 mov         r1, #0
  000ac	eb000000	 bl          memset

; 742  :         m_maxNumPipes = numPipes;

  000b0	e5c54054	 strb        r4, [r5, #0x54]

; 743  :         fSuccess = TRUE;

  000b4	e3a06001	 mov         r6, #1
  000b8		 |$LN1@AllocatePi|

; 744  :     }
; 745  :     DEBUGMSG( ZONE_ERROR && !m_ppCPipe, (TEXT("CDevice(%s tier %d)::AllocatePipeArray - no memory!\n"), GetDeviceType(), m_tierNumber ) );
; 746  : 
; 747  :     LeaveCriticalSection( &m_csDeviceLock );

  000b8	e285000c	 add         r0, r5, #0xC
  000bc	eb000000	 bl          LeaveCriticalSection

; 748  : 
; 749  :     DEBUGMSG( ZONE_DEVICE && ZONE_VERBOSE, (TEXT("-CDevice(%s tier %d)::AllocatePipeArray, returning BOOL %d\n"), GetDeviceType(), m_tierNumber, fSuccess) );
; 750  :     return fSuccess;
; 751  : }

  000c0	e1a00006	 mov         r0, r6
  000c4	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000c8	e12fff1e	 bx          lr
  000cc		 |$M36527|

			 ENDP  ; |?AllocatePipeArray@CDevice@@IAAHXZ|, CDevice::AllocatePipeArray


  00000			 AREA	 |.pdata|, PDATA
|$T36542| DCD	|$LN6@DisableDev|
	DCD	0x40000e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DisableDevice@CDevice@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z| PROC ; CDevice::DisableDevice

; 1251 : {

  00000		 |$LN6@DisableDev|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36539|
  00004	e1a0e000	 mov         lr, r0

; 1252 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("CHub(%s tier %d)::DisableDevice - address = %d, pipeIndex = %d\n"), GetDeviceType(), m_tierNumber, address, fReset) );
; 1253 :     HCD_REQUEST_STATUS status = requestIgnored;
; 1254 :     if (address == m_address ) { // If it is this device

  00008	e5de3020	 ldrb        r3, [lr, #0x20]
  0000c	e3a00002	 mov         r0, #2
  00010	e1510003	 cmp         r1, r3
  00014	1a000005	 bne         |$LN1@DisableDev|

; 1255 :         m_pAttachedHub->DisableOffStreamDevice( address, fReset);

  00018	e59e0004	 ldr         r0, [lr, #4]
  0001c	e5903000	 ldr         r3, [r0]
  00020	e5933038	 ldr         r3, [r3, #0x38]
  00024	e1a0e00f	 mov         lr, pc
  00028	e12fff13	 bx          r3

; 1256 :         status = requestOK;

  0002c	e3a00001	 mov         r0, #1
  00030		 |$LN1@DisableDev|

; 1257 :     }
; 1258 :     return status;
; 1259 : }

  00030	e49de004	 ldr         lr, [sp], #4
  00034	e12fff1e	 bx          lr
  00038		 |$M36540|

			 ENDP  ; |?DisableDevice@CDevice@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|, CDevice::DisableDevice


  00000			 AREA	 |.pdata|, PDATA
|$T36555| DCD	|$LN8@SuspendRes|
	DCD	0x40001a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SuspendResume@CDevice@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z| PROC ; CDevice::SuspendResume

; 1277 : {

  00000		 |$LN8@SuspendRes|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M36552|
  00004	e1a06002	 mov         r6, r2
  00008	e1a07001	 mov         r7, r1
  0000c	e1a05000	 mov         r5, r0

; 1278 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CHub(%s tier %d)::SuspendResume - address = %d, fSuspend = %d\n"), GetDeviceType(), m_tierNumber, address, fSuspend) );
; 1279 : 
; 1280 :     HCD_REQUEST_STATUS status = requestIgnored;
; 1281 : 
; 1282 :     EnterCriticalSection( &m_csDeviceLock );

  00010	e285000c	 add         r0, r5, #0xC
  00014	e3a04002	 mov         r4, #2
  00018	eb000000	 bl          EnterCriticalSection

; 1283 :     if ( address == m_address ) {

  0001c	e5d53020	 ldrb        r3, [r5, #0x20]
  00020	e1570003	 cmp         r7, r3
  00024	1a00000a	 bne         |$LN1@SuspendRes|

; 1284 :         if (m_pAttachedHub->SuspendResumeOffStreamDevice(address, fSuspend)) {

  00028	e5950004	 ldr         r0, [r5, #4]
  0002c	e1a02006	 mov         r2, r6
  00030	e1a01007	 mov         r1, r7
  00034	e5903000	 ldr         r3, [r0]
  00038	e593303c	 ldr         r3, [r3, #0x3C]
  0003c	e1a0e00f	 mov         lr, pc
  00040	e12fff13	 bx          r3
  00044	e3500000	 cmp         r0, #0

; 1285 :             m_fIsSuspend=fSuspend;
; 1286 :             status = requestOK;

  00048	13a04001	 movne       r4, #1

; 1287 :         }
; 1288 :         else
; 1289 :             status = requestFailed;

  0004c	03a04000	 moveq       r4, #0
  00050	15856058	 strne       r6, [r5, #0x58]
  00054		 |$LN1@SuspendRes|

; 1290 :     }
; 1291 :     LeaveCriticalSection( &m_csDeviceLock );

  00054	e285000c	 add         r0, r5, #0xC
  00058	eb000000	 bl          LeaveCriticalSection

; 1292 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CHub(%s tier %d)::SuspendResume - address = %d, returing HCD_REQUEST_STATUS %d\n"), GetDeviceType(), m_tierNumber, address, status) );
; 1293 :     return status;
; 1294 : }

  0005c	e1a00004	 mov         r0, r4
  00060	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00064	e12fff1e	 bx          lr
  00068		 |$M36553|

			 ENDP  ; |?SuspendResume@CDevice@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|, CDevice::SuspendResume

	EXPORT	|?GetDescriptor@CHub@@IAAHQAVCPipeAbs@@EEEGPAX@Z| ; CHub::GetDescriptor
	IMPORT	|WaitForSingleObject|
; File c:\wince600\osdesigns\z2170p\z2170p\wince600\z2170p_armv4i\cesysgen\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T36587| DCD	|$LN22@GetDescrip|
	DCD	0x40006e02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetDescriptor@CHub@@IAAHQAVCPipeAbs@@EEEGPAX@Z| PROC ; CHub::GetDescriptor

; 1975 : {

  00000		 |$LN22@GetDescrip|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd054	 sub         sp, sp, #0x54
  00008		 |$M36584|
  00008	e1a0b003	 mov         r11, r3
  0000c	e5cd2038	 strb        r2, [sp, #0x38]
  00010	e58d1048	 str         r1, [sp, #0x48]
  00014	e1a09000	 mov         r9, r0
  00018	e3a03c01	 mov         r3, #1, 24

; 1976 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("+CHub(%s tier %d)::GetDescriptor - address = %d, Type = %d, Index = %d, Size = %d\n"), GetDeviceType(), m_tierNumber, address, descriptorType, descriptorIndex, wDescriptorSize) );
; 1977 : 
; 1978 :     PREFAST_DEBUGCHK( pControlPipe != NULL );
; 1979 :     PREFAST_DEBUGCHK( pBuffer != NULL );
; 1980 :     DEBUGCHK( m_hHubStatusChangeEvent != NULL );
; 1981 : 
; 1982 :     BOOL                fTransferDone = FALSE;
; 1983 :     DWORD               dwBytesTransferred = 0;
; 1984 :     DWORD               dwErrorFlags = USB_NOT_COMPLETE_ERROR;
; 1985 :     HCD_REQUEST_STATUS  status = requestFailed;
; 1986 :     USB_DEVICE_REQUEST  usbRequest;
; 1987 : 
; 1988 :     if ( descriptorType == USB_HUB_DESCRIPTOR_TYPE ) {

  0001c	e35b0029	 cmp         r11, #0x29
  00020	e3834003	 orr         r4, r3, #3

; 1989 :         DEBUGCHK( descriptorIndex == 0 &&
; 1990 :                   wDescriptorSize >= USB_HUB_DESCRIPTOR_MINIMUM_SIZE );
; 1991 :         usbRequest.bmRequestType = USB_REQUEST_DEVICE_TO_HOST | USB_REQUEST_CLASS | USB_REQUEST_FOR_DEVICE;

  00024	03a030a0	 moveq       r3, #0xA0

; 1992 :     } else {
; 1993 :         DEBUGCHK( (descriptorType == USB_DEVICE_DESCRIPTOR_TYPE && descriptorIndex == 0 && (wDescriptorSize == ENDPOINT_ZERO_MIN_MAXPACKET_SIZE || wDescriptorSize == sizeof( USB_DEVICE_DESCRIPTOR ) ) ) ||
; 1994 :                   (descriptorType == USB_CONFIGURATION_DESCRIPTOR_TYPE && wDescriptorSize >= sizeof( USB_CONFIGURATION_DESCRIPTOR ) ) );
; 1995 :         usbRequest.bmRequestType = USB_REQUEST_DEVICE_TO_HOST | USB_REQUEST_STANDARD | USB_REQUEST_FOR_DEVICE;

  00028	13a03080	 movne       r3, #0x80
  0002c	e5cd304c	 strb        r3, [sp, #0x4C]

; 1996 :     }
; 1997 :     usbRequest.bRequest = USB_REQUEST_GET_DESCRIPTOR;
; 1998 :     usbRequest.wValue = USB_DESCRIPTOR_MAKE_TYPE_AND_INDEX(descriptorType, descriptorIndex);

  00030	e5dd3078	 ldrb        r3, [sp, #0x78]

; 1999 :     usbRequest.wIndex = 0;
; 2000 :     usbRequest.wLength = wDescriptorSize;

  00034	e1dd07bc	 ldrh        r0, [sp, #0x7C]

; 2001 : 
; 2002 :     if ( !m_fHubThreadClosing ) {

  00038	e59920b8	 ldr         r2, [r9, #0xB8]
  0003c	e183340b	 orr         r3, r3, r11, lsl #8
  00040	e3a0e000	 mov         lr, #0
  00044	e3a05000	 mov         r5, #0
  00048	e3a07006	 mov         r7, #6
  0004c	e3a08000	 mov         r8, #0
  00050	e59da080	 ldr         r10, [sp, #0x80]
  00054	e1cd34be	 strh        r3, [sp, #0x4E]
  00058	e58d4044	 str         r4, [sp, #0x44]
  0005c	e58de03c	 str         lr, [sp, #0x3C]
  00060	e58d5040	 str         r5, [sp, #0x40]
  00064	e3a06000	 mov         r6, #0
  00068	e5cd704d	 strb        r7, [sp, #0x4D]
  0006c	e1cd85b0	 strh        r8, [sp, #0x50]
  00070	e1cd05b2	 strh        r0, [sp, #0x52]
  00074	e3520000	 cmp         r2, #0
  00078	1a00003b	 bne         |$LN13@GetDescrip|

; 2003 :         status = pControlPipe->IssueTransfer(
; 2004 :                                  address, // address of device
; 2005 :                                  TransferDoneCallbackSetEvent, // callback routine
; 2006 :                                  m_hHubStatusChangeEvent, // callback param
; 2007 :                                  USB_IN_TRANSFER | USB_SEND_TO_DEVICE, // transfer flags
; 2008 :                                  &usbRequest, // control request
; 2009 :                                  0, // dwStartingFrame (not used)
; 2010 :                                  0, // dwFrames (not used)
; 2011 :                                  NULL, // aLengths (not used)
; 2012 :                                  wDescriptorSize, // buffer size
; 2013 :                                  pBuffer, // buffer
; 2014 :                                  0, // phys addr of buffer (not used)
; 2015 :                                  this, // cancel ID
; 2016 :                                  NULL, // adwIsochErrors (not used)
; 2017 :                                  NULL, // adwIsochLengths (not used)
; 2018 :                                  &fTransferDone, // OUT status param
; 2019 :                                  &dwBytesTransferred, // OUT status param
; 2020 :                                  &dwErrorFlags ); // OUT status param

  0007c	e28d4044	 add         r4, sp, #0x44
  00080	e58d4034	 str         r4, [sp, #0x34]
  00084	e1dd47bc	 ldrh        r4, [sp, #0x7C]
  00088	e5911000	 ldr         r1, [r1]
  0008c	e28d5040	 add         r5, sp, #0x40
  00090	e58d4014	 str         r4, [sp, #0x14]
  00094	e591800c	 ldr         r8, [r1, #0xC]
  00098	e58d5030	 str         r5, [sp, #0x30]
  0009c	e3a04d42	 mov         r4, #0x42, 26
  000a0	e59930bc	 ldr         r3, [r9, #0xBC]
  000a4	e59f2108	 ldr         r2, [pc, #0x108]
  000a8	e28d603c	 add         r6, sp, #0x3C
  000ac	e28d704c	 add         r7, sp, #0x4C
  000b0	e5dd1038	 ldrb        r1, [sp, #0x38]
  000b4	e59d0048	 ldr         r0, [sp, #0x48]
  000b8	e3a05000	 mov         r5, #0
  000bc	e58d4000	 str         r4, [sp]
  000c0	e58d602c	 str         r6, [sp, #0x2C]
  000c4	e58d5028	 str         r5, [sp, #0x28]
  000c8	e58d5024	 str         r5, [sp, #0x24]
  000cc	e58d9020	 str         r9, [sp, #0x20]
  000d0	e58d501c	 str         r5, [sp, #0x1C]
  000d4	e58da018	 str         r10, [sp, #0x18]
  000d8	e58d5010	 str         r5, [sp, #0x10]
  000dc	e58d500c	 str         r5, [sp, #0xC]
  000e0	e58d5008	 str         r5, [sp, #8]
  000e4	e58d7004	 str         r7, [sp, #4]
  000e8	e1a0e00f	 mov         lr, pc
  000ec	e12fff18	 bx          r8
  000f0	e1a06000	 mov         r6, r0

; 2021 : 
; 2022 :         if ( status == requestOK ) {

  000f4	e3560001	 cmp         r6, #1
  000f8	1a000017	 bne         |$LN17@GetDescrip|

; 2023 :             DWORD dwResult = WaitForSingleObject( m_hHubStatusChangeEvent, STANDARD_REQUEST_TIMEOUT );

  000fc	e59900bc	 ldr         r0, [r9, #0xBC]
  00100	e3a01ffa	 mov         r1, #0xFA, 30
  00104	eb000000	 bl          WaitForSingleObject

; 2024 :             if (!fTransferDone || dwResult!= WAIT_OBJECT_0) {

  00108	e59de03c	 ldr         lr, [sp, #0x3C]
  0010c	e35e0000	 cmp         lr, #0
  00110	0a000001	 beq         |$LN3@GetDescrip|
  00114	e3500000	 cmp         r0, #0

; 2029 :                     ResetEvent(m_hHubStatusChangeEvent);

  00118	0a000010	 beq         |$LN19@GetDescrip|
  0011c		 |$LN3@GetDescrip|

; 2025 :                 pControlPipe->AbortTransfer( NULL, // callback function
; 2026 :                                              NULL, // callback parameter
; 2027 :                                              this ); // cancel ID

  0011c	e59d0048	 ldr         r0, [sp, #0x48]
  00120	e1a03009	 mov         r3, r9
  00124	e3a02000	 mov         r2, #0
  00128	e5901000	 ldr         r1, [r0]
  0012c	e5914010	 ldr         r4, [r1, #0x10]
  00130	e3a01000	 mov         r1, #0
  00134	e1a0e00f	 mov         lr, pc
  00138	e12fff14	 bx          r4

; 2028 :                 if ( !m_fHubThreadClosing && m_hHubStatusChangeEvent!=NULL ) {

  0013c	e59930b8	 ldr         r3, [r9, #0xB8]
  00140	e3530000	 cmp         r3, #0
  00144	1a000004	 bne         |$LN17@GetDescrip|
  00148	e59930bc	 ldr         r3, [r9, #0xBC]
  0014c	e3530000	 cmp         r3, #0

; 2029 :                     ResetEvent(m_hHubStatusChangeEvent);

  00150	13a01002	 movne       r1, #2
  00154	11a00003	 movne       r0, r3
  00158	1b000000	 blne        EventModify
  0015c		 |$LN17@GetDescrip|
  0015c	e59de03c	 ldr         lr, [sp, #0x3C]
  00160		 |$LN19@GetDescrip|
  00160	e1dd07bc	 ldrh        r0, [sp, #0x7C]
  00164	e59d4044	 ldr         r4, [sp, #0x44]
  00168	e59d5040	 ldr         r5, [sp, #0x40]
  0016c		 |$LN13@GetDescrip|

; 2030 :                 }
; 2031 :             }
; 2032 :         }
; 2033 :         DEBUGCHK( fTransferDone );
; 2034 :     }
; 2035 : 
; 2036 : #ifndef USB_STRICT_ENFORCEMENT
; 2037 :     // Some IHVs have lazy firmware writers who didn't bother to set the
; 2038 :     // descriptor type field in all of their descriptors. Sigh.
; 2039 :     if ( PUSB_COMMON_DESCRIPTOR(pBuffer)->bDescriptorType == 0 ) {

  0016c	e5da3001	 ldrb        r3, [r10, #1]
  00170	e3530000	 cmp         r3, #0

; 2040 :         DEBUGMSG(1, (TEXT("CHub::GetDescriptor - forcing descr type 0x%x to 0x%x\n"), PUSB_COMMON_DESCRIPTOR(pBuffer)->bDescriptorType, descriptorType));
; 2041 :         PUSB_COMMON_DESCRIPTOR(pBuffer)->bDescriptorType = descriptorType;

  00174	05cab001	 streqb      r11, [r10, #1]

; 2042 :     }
; 2043 : #endif
; 2044 : 
; 2045 :     BOOL fSuccess = (status == requestOK &&
; 2046 :                     fTransferDone &&
; 2047 :                     dwBytesTransferred == wDescriptorSize &&
; 2048 :                     dwErrorFlags == USB_NO_ERROR &&
; 2049 :                     PUSB_COMMON_DESCRIPTOR(pBuffer)->bDescriptorType == descriptorType);

  00178	e3560001	 cmp         r6, #1
  0017c	1a000008	 bne         |$LN11@GetDescrip|
  00180	e35e0000	 cmp         lr, #0
  00184	0a000006	 beq         |$LN11@GetDescrip|
  00188	e1550000	 cmp         r5, r0
  0018c	1a000004	 bne         |$LN11@GetDescrip|
  00190	e3540000	 cmp         r4, #0
  00194	05da3001	 ldreqb      r3, [r10, #1]
  00198	0153000b	 cmpeq       r3, r11
  0019c	03a00001	 moveq       r0, #1
  001a0	0a000000	 beq         |$LN12@GetDescrip|
  001a4		 |$LN11@GetDescrip|
  001a4	e3a00000	 mov         r0, #0
  001a8		 |$LN12@GetDescrip|

; 2050 :     // note, don't check length since some descriptors can be variable
; 2051 :     // length (i.e. configuration descriptor bLength field will read
; 2052 :     // sizeof( USB_CONFIGURATION_DESCRIPTOR ), but we may have requested
; 2053 :     // more than this. Or, we may only have requested USB_HUB_DESCRIPTOR_MINIMUM_SIZE
; 2054 :     // but the hub descriptor can be longer.
; 2055 : 
; 2056 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("-CHub(%s tier %d)::GetDescriptor - address = %d, Type = %d, Index = %d, Size = %d, returning %d\n"), GetDeviceType(), m_tierNumber, address, descriptorType, descriptorIndex, wDescriptorSize, fSuccess) );
; 2057 :     return fSuccess;
; 2058 : }

  001a8	e28dd054	 add         sp, sp, #0x54
  001ac	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001b0	e12fff1e	 bx          lr
  001b4		 |$LN23@GetDescrip|
  001b4		 |$LN24@GetDescrip|
  001b4	00000000	 DCD         |?TransferDoneCallbackSetEvent@CDevice@@KAKPAX@Z|
  001b8		 |$M36585|

			 ENDP  ; |?GetDescriptor@CHub@@IAAHQAVCPipeAbs@@EEEGPAX@Z|, CHub::GetDescriptor

	EXPORT	|?DetachDownstreamDeviceThread@CHub@@IAAKXZ| ; CHub::DetachDownstreamDeviceThread
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T36612| DCD	|$LN11@DetachDown|
	DCD	0x40001901
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DetachDownstreamDeviceThread@CHub@@IAAKXZ| PROC ; CHub::DetachDownstreamDeviceThread

; 2083 : {

  00000		 |$LN11@DetachDown|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M36609|
  00004	e1a05000	 mov         r5, r0

; 2084 :     DEBUGMSG( ZONE_ATTACH, (TEXT("+CHub::DetachDownstreamDeviceThread\n")) );
; 2085 : 
; 2086 :     CDevice* pDeviceToDetach = m_pDetachedDevice;//(CDevice*) context;
; 2087 :     m_pDetachedDevice=NULL;
; 2088 :     SetEvent(m_pDetachedDeviceHandled);

  00008	e5950064	 ldr         r0, [r5, #0x64]
  0000c	e5954060	 ldr         r4, [r5, #0x60]
  00010	e3a03000	 mov         r3, #0
  00014	e3a01003	 mov         r1, #3
  00018	e5853060	 str         r3, [r5, #0x60]
  0001c	eb000000	 bl          EventModify

; 2089 :     PREFAST_DEBUGCHK( pDeviceToDetach != NULL );
; 2090 : 
; 2091 :     pDeviceToDetach->HandleDetach();

  00020	e5943000	 ldr         r3, [r4]
  00024	e1a00004	 mov         r0, r4
  00028	e5933030	 ldr         r3, [r3, #0x30]
  0002c	e1a0e00f	 mov         lr, pc
  00030	e12fff13	 bx          r3

; 2092 :     delete pDeviceToDetach;

  00034	e5943000	 ldr         r3, [r4]
  00038	e3a01001	 mov         r1, #1
  0003c	e1a00004	 mov         r0, r4
  00040	e5933000	 ldr         r3, [r3]
  00044	e1a0e00f	 mov         lr, pc
  00048	e12fff13	 bx          r3

; 2093 : 
; 2094 :     //DecrCountdown(&m_objCountdown);
; 2095 :     m_pDeviceGlobal->ObjCountdownDec();

  0004c	e5953050	 ldr         r3, [r5, #0x50]
  00050	e2830054	 add         r0, r3, #0x54
  00054	eb000000	 bl          |?DecrCountdown@Countdown@@QAAXXZ|

; 2096 : 
; 2097 :     DEBUGMSG( ZONE_ATTACH, (TEXT("-CHub::DetachDownstreamDeviceThread\n")) );
; 2098 : 
; 2099 :     return 0;

  00058	e3a00000	 mov         r0, #0

; 2100 : }

  0005c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$M36610|

			 ENDP  ; |?DetachDownstreamDeviceThread@CHub@@IAAKXZ|, CHub::DetachDownstreamDeviceThread

	EXPORT	|?AllocateDeviceArray@CHub@@IAAHXZ|	; CHub::AllocateDeviceArray

  00000			 AREA	 |.pdata|, PDATA
|$T36628| DCD	|$LN11@AllocateDe|
	DCD	0x40002801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AllocateDeviceArray@CHub@@IAAHXZ| PROC ; CHub::AllocateDeviceArray

; 2191 : {

  00000		 |$LN11@AllocateDe|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M36625|
  00004	e1a04000	 mov         r4, r0

; 2192 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CHub(%s tier %d)::AllocateDeviceArray\n"), GetDeviceType(), m_tierNumber) );
; 2193 : 
; 2194 :     BOOL fSuccess = FALSE;
; 2195 : 
; 2196 :     EnterCriticalSection( &m_csDeviceLock  );

  00008	e284000c	 add         r0, r4, #0xC
  0000c	e3a05000	 mov         r5, #0
  00010	eb000000	 bl          EnterCriticalSection

; 2197 : 
; 2198 :     DEBUGCHK( m_ppCDeviceOnPort == NULL &&
; 2199 :               m_usbHubDescriptor.bNumberOfPorts > 0 );
; 2200 : 
; 2201 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("CHub(%s tier %d)::AllocateDeviceArray - attempting to allocate %d devices\n"), GetDeviceType(), m_tierNumber, m_usbHubDescriptor.bNumberOfPorts ) );
; 2202 :     m_ppCDeviceOnPort = new CDevice* [ m_usbHubDescriptor.bNumberOfPorts ];

  00014	e5d4306a	 ldrb        r3, [r4, #0x6A]
  00018	e1a00103	 mov         r0, r3, lsl #2
  0001c	eb000000	 bl          |??2@YAPAXI@Z|

; 2203 :     m_pAddedTT = new BOOL [m_usbHubDescriptor.bNumberOfPorts ];

  00020	e5d4306a	 ldrb        r3, [r4, #0x6A]
  00024	e58400b0	 str         r0, [r4, #0xB0]
  00028	e1a00103	 mov         r0, r3, lsl #2
  0002c	eb000000	 bl          |??2@YAPAXI@Z|

; 2204 :     if ( m_ppCDeviceOnPort != NULL && m_pAddedTT!=NULL ) {

  00030	e59430b0	 ldr         r3, [r4, #0xB0]
  00034	e58400b4	 str         r0, [r4, #0xB4]
  00038	e1b02003	 movs        r2, r3
  0003c	0a000012	 beq         |$LN4@AllocateDe|
  00040	e3500000	 cmp         r0, #0
  00044	0a000010	 beq         |$LN4@AllocateDe|

; 2205 :         memset( m_ppCDeviceOnPort, 0, m_usbHubDescriptor.bNumberOfPorts * sizeof( CDevice* ) );

  00048	e5d4306a	 ldrb        r3, [r4, #0x6A]
  0004c	e1a00002	 mov         r0, r2
  00050	e3a01000	 mov         r1, #0
  00054	e1a02103	 mov         r2, r3, lsl #2
  00058	eb000000	 bl          memset

; 2206 :         for (DWORD dwIndex=0;dwIndex<m_usbHubDescriptor.bNumberOfPorts; dwIndex++)

  0005c	e5d4306a	 ldrb        r3, [r4, #0x6A]
  00060	e3a02000	 mov         r2, #0
  00064	e3530000	 cmp         r3, #0
  00068	0a000006	 beq         |$LN1@AllocateDe|
  0006c	e3a01000	 mov         r1, #0
  00070		 |$LL3@AllocateDe|

; 2207 :             m_pAddedTT[dwIndex] = FALSE;

  00070	e59430b4	 ldr         r3, [r4, #0xB4]
  00074	e7831102	 str         r1, [r3, +r2, lsl #2]
  00078	e5d4306a	 ldrb        r3, [r4, #0x6A]
  0007c	e2822001	 add         r2, r2, #1
  00080	e1520003	 cmp         r2, r3
  00084	3afffff9	 bcc         |$LL3@AllocateDe|
  00088		 |$LN1@AllocateDe|

; 2208 :         fSuccess = TRUE;

  00088	e3a05001	 mov         r5, #1
  0008c		 |$LN4@AllocateDe|

; 2209 :     }
; 2210 :     DEBUGMSG( ZONE_HUB && ZONE_ERROR && !m_ppCDeviceOnPort, (TEXT("CHub(%s tier %d)::AllocateDeviceArray - no memory!\n"), GetDeviceType(), m_tierNumber ) );
; 2211 : 
; 2212 :     LeaveCriticalSection( &m_csDeviceLock );

  0008c	e284000c	 add         r0, r4, #0xC
  00090	eb000000	 bl          LeaveCriticalSection

; 2213 : 
; 2214 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CHub(%s tier %d)::AllocateDeviceArray, returning BOOL %d\n"), GetDeviceType(), m_tierNumber, fSuccess) );
; 2215 :     return fSuccess;
; 2216 : }

  00094	e1a00005	 mov         r0, r5
  00098	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$M36626|

			 ENDP  ; |?AllocateDeviceArray@CHub@@IAAHXZ|, CHub::AllocateDeviceArray

	EXPORT	|?HandleDetach@CHub@@UAAXXZ|		; CHub::HandleDetach
	IMPORT	|CloseHandle|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T36680| DCD	|$LN46@HandleDeta|
	DCD	0x40005d01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HandleDetach@CHub@@UAAXXZ| PROC	; CHub::HandleDetach

; 2229 : {

  00000		 |$LN46@HandleDeta|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M36677|
  00004	e1a04000	 mov         r4, r0

; 2230 :     DEBUGMSG( ZONE_HUB || ZONE_ATTACH, (TEXT("+CHub(%s tier %d)::HandleDetach\n"), GetDeviceType(), m_tierNumber) );
; 2231 : 
; 2232 :     // close our hub thread
; 2233 :     DEBUGCHK( m_hHubStatusChangeEvent && m_hHubStatusChangeThread );
; 2234 :     // tell the thread to abort port status change processing.
; 2235 :     // ***DO NOT*** enter m_csDeviceLock here, otherwise we will
; 2236 :     // block the thread trying to close
; 2237 :     m_fHubThreadClosing = TRUE;
; 2238 :     SetEvent( m_hHubStatusChangeEvent );

  00008	e59400bc	 ldr         r0, [r4, #0xBC]
  0000c	e3a03001	 mov         r3, #1
  00010	e3a01003	 mov         r1, #3
  00014	e58430b8	 str         r3, [r4, #0xB8]
  00018	eb000000	 bl          EventModify

; 2239 :     SetEvent( m_hHubSuspendBlockEvent );

  0001c	e59400c4	 ldr         r0, [r4, #0xC4]
  00020	e3a01003	 mov         r1, #3
  00024	eb000000	 bl          EventModify

; 2240 : 
; 2241 :     // If we are the root hub then this is a total shutdown rather than a detach,
; 2242 :     // so we force anybody in the middle of address assignment to give up.
; 2243 :     if (m_tierNumber == 0)

  00028	e5d4304c	 ldrb        r3, [r4, #0x4C]
  0002c	e3530000	 cmp         r3, #0

; 2244 :         //PrepareDeleteCritSec_Ex( &m_csAddress0Lock );
; 2245 :         m_pDeviceGlobal->Addr0LockPrepareDelete();

  00030	05943050	 ldreq       r3, [r4, #0x50]
  00034	0283002c	 addeq       r0, r3, #0x2C
  00038	0b000000	 bleq        |?PrepareDeleteCritSec_Ex@CritSec_Ex@@QAAXXZ|
  0003c		 |$LL10@HandleDeta|

; 2246 : 
; 2247 :     // In the case where the hub was detached right when a new function was
; 2248 :     // being attached on one of its ports, the hub thread can be at
; 2249 :     // AttachDevice - DEVICE_CONFIG_STATUS_SIGNAL_NEW_DEVICE_ENTER_OPERATIONAL_STATE.
; 2250 :     // At this point, the thread is somewhere in USBD.DLL, and not in UHCI.DLL, and we
; 2251 :     // need to wait until USBD is finished. USBD can have a dialog up asking the
; 2252 :     // user for the driver's DLL name. So, we don't want to just blindly call
; 2253 :     // TerminateThread if the wait fails.
; 2254 :     DWORD dwWaitReturn = WAIT_FAILED;
; 2255 : #ifdef DEBUG
; 2256 :     DWORD dwTickCountStart = GetTickCount();
; 2257 : #endif // DEBUG
; 2258 :     do {
; 2259 :         dwWaitReturn = WaitForSingleObject( m_hHubStatusChangeThread, 1000 );

  0003c	e59400c0	 ldr         r0, [r4, #0xC0]
  00040	e3a01ffa	 mov         r1, #0xFA, 30
  00044	eb000000	 bl          WaitForSingleObject
  00048	e3500000	 cmp         r0, #0

; 2260 :         DEBUGMSG( ZONE_WARNING && dwWaitReturn != WAIT_OBJECT_0, (TEXT("CHub(%s tier %d)::HandleDetach - hub thread blocked - could be waiting for user input\n"), GetDeviceType(), m_tierNumber) );
; 2261 :     } while ( dwWaitReturn != WAIT_OBJECT_0 );

  0004c	1afffffa	 bne         |$LL10@HandleDeta|

; 2262 :     DEBUGMSG( ZONE_ATTACH, (TEXT("CHub(%s tier %d)::HandleDetach - status change thread closed in %d ms\n"), GetDeviceType(), m_tierNumber, GetTickCount() - dwTickCountStart ) );
; 2263 : 
; 2264 :     EnterCriticalSection( &m_csDeviceLock );

  00050	e284000c	 add         r0, r4, #0xC
  00054	eb000000	 bl          EnterCriticalSection

; 2265 : 
; 2266 : #ifdef DEBUG
; 2267 :     if ( m_address == 0 ) {
; 2268 :         // root hub - no pipes
; 2269 :         DEBUGCHK( m_ppCPipe == NULL &&
; 2270 :                   m_maxNumPipes == 0 );
; 2271 :     } else {
; 2272 :         // external hub - should have two pipes
; 2273 :         DEBUGCHK( m_ppCPipe != NULL &&
; 2274 :                   m_maxNumPipes == 2 &&
; 2275 :                   m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ] != NULL &&
; 2276 :                   m_ppCPipe[ STATUS_CHANGE_INTERRUPT_PIPE ] != NULL );
; 2277 :     }
; 2278 : #endif // DEBUG
; 2279 :     for ( UCHAR pipe = 0; m_ppCPipe!=NULL && pipe < m_maxNumPipes; pipe++ ) {

  00058	e3a05000	 mov         r5, #0
  0005c	e3a07000	 mov         r7, #0
  00060	ea000015	 b           |$LN43@HandleDeta|
  00064		 |$LL7@HandleDeta|
  00064	e5d43054	 ldrb        r3, [r4, #0x54]
  00068	e1550003	 cmp         r5, r3
  0006c	2a000015	 bcs         |$LN41@HandleDeta|

; 2280 :         m_ppCPipe[ pipe ]->ClosePipe();

  00070	e594305c	 ldr         r3, [r4, #0x5C]
  00074	e1a06105	 mov         r6, r5, lsl #2
  00078	e7960003	 ldr         r0, [r6, +r3]
  0007c	e5903000	 ldr         r3, [r0]
  00080	e5933008	 ldr         r3, [r3, #8]
  00084	e1a0e00f	 mov         lr, pc
  00088	e12fff13	 bx          r3

; 2281 :         delete m_ppCPipe[ pipe ];

  0008c	e594305c	 ldr         r3, [r4, #0x5C]
  00090	e7963003	 ldr         r3, [r6, +r3]
  00094	e1b00003	 movs        r0, r3
  00098	15903000	 ldrne       r3, [r0]
  0009c	13a01001	 movne       r1, #1
  000a0	15933000	 ldrne       r3, [r3]
  000a4	11a0e00f	 movne       lr, pc
  000a8	112fff13	 bxne        r3

; 2282 :         m_ppCPipe[ pipe ] = NULL;

  000ac	e594205c	 ldr         r2, [r4, #0x5C]
  000b0	e2853001	 add         r3, r5, #1
  000b4	e20350ff	 and         r5, r3, #0xFF
  000b8	e7867002	 str         r7, [r6, +r2]
  000bc		 |$LN43@HandleDeta|
  000bc	e594305c	 ldr         r3, [r4, #0x5C]
  000c0	e3530000	 cmp         r3, #0
  000c4	1affffe6	 bne         |$LL7@HandleDeta|
  000c8		 |$LN41@HandleDeta|

; 2283 :     }
; 2284 :     // m_ppCPipe[] will be freed in ~CDevice
; 2285 : 
; 2286 :     // if m_ppCDeviceOnPort was not allocated ok, EnterOperationalState
; 2287 :     // would have failed, and we should never be at HandleDetach stage.
; 2288 :     PREFAST_DEBUGCHK( m_ppCDeviceOnPort != NULL );
; 2289 :     // we need to detach all the devices on our ports
; 2290 :     for ( UCHAR port = 1; port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  000c8	e5d4306a	 ldrb        r3, [r4, #0x6A]
  000cc	e3a05001	 mov         r5, #1
  000d0	e3530001	 cmp         r3, #1
  000d4	3a00001c	 bcc         |$LN2@HandleDeta|
  000d8	e3a06001	 mov         r6, #1
  000dc		 |$LL4@HandleDeta|

; 2291 :         // Don't call DetachDevice, because that function is intended for
; 2292 :         // when this hub is active. It has the extra overhead of spinning off
; 2293 :         // a thread to do the detach work. Instead, just call the HandleDetach
; 2294 :         // procedure directly
; 2295 :         if ( m_ppCDeviceOnPort[ port - 1 ] != NULL ) {

  000dc	e59430b0	 ldr         r3, [r4, #0xB0]
  000e0	e0832105	 add         r2, r3, r5, lsl #2
  000e4	e5123004	 ldr         r3, [r2, #-4]
  000e8	e3530000	 cmp         r3, #0
  000ec	0a000010	 beq         |$LN3@HandleDeta|

; 2296 :             m_ppCDeviceOnPort[ port - 1 ]->HandleDetach();

  000f0	e1a00003	 mov         r0, r3
  000f4	e5903000	 ldr         r3, [r0]
  000f8	e5933030	 ldr         r3, [r3, #0x30]
  000fc	e1a0e00f	 mov         lr, pc
  00100	e12fff13	 bx          r3

; 2297 :             delete m_ppCDeviceOnPort[ port - 1 ];

  00104	e59430b0	 ldr         r3, [r4, #0xB0]
  00108	e0833105	 add         r3, r3, r5, lsl #2
  0010c	e5133004	 ldr         r3, [r3, #-4]
  00110	e1b00003	 movs        r0, r3
  00114	15903000	 ldrne       r3, [r0]
  00118	13a01001	 movne       r1, #1
  0011c	15933000	 ldrne       r3, [r3]
  00120	11a0e00f	 movne       lr, pc
  00124	112fff13	 bxne        r3

; 2298 :             m_ppCDeviceOnPort[ port - 1 ] = NULL;

  00128	e59430b0	 ldr         r3, [r4, #0xB0]
  0012c	e0833105	 add         r3, r3, r5, lsl #2
  00130	e5037004	 str         r7, [r3, #-4]
  00134		 |$LN3@HandleDeta|
  00134	e5d4206a	 ldrb        r2, [r4, #0x6A]
  00138	e2863001	 add         r3, r6, #1
  0013c	e20350ff	 and         r5, r3, #0xFF
  00140	e1a06005	 mov         r6, r5
  00144	e1550002	 cmp         r5, r2
  00148	9affffe3	 bls         |$LL4@HandleDeta|
  0014c		 |$LN2@HandleDeta|

; 2299 :         }
; 2300 :     }
; 2301 :     // m_ppCDeviceOnPort[] will be freed in ~CHub
; 2302 : 
; 2303 :     // Now that all pipes are closed, we can close our thread/event handles.
; 2304 :     // If we did this earlier, we would risk having a callback from an
; 2305 :     // active pipe, and having TransferDoneCallbackSetEvent accidentally
; 2306 :     // set a dead m_hHubStatusChangeEvent
; 2307 :     CloseHandle( m_hHubStatusChangeThread );

  0014c	e59400c0	 ldr         r0, [r4, #0xC0]
  00150	eb000000	 bl          CloseHandle

; 2308 :     m_hHubStatusChangeThread = NULL;
; 2309 : 
; 2310 :     CloseHandle( m_hHubStatusChangeEvent );

  00154	e59400bc	 ldr         r0, [r4, #0xBC]
  00158	e58470c0	 str         r7, [r4, #0xC0]
  0015c	eb000000	 bl          CloseHandle

; 2311 :     m_hHubStatusChangeEvent = NULL;
; 2312 : 
; 2313 :     LeaveCriticalSection( &m_csDeviceLock );

  00160	e284000c	 add         r0, r4, #0xC
  00164	e58470bc	 str         r7, [r4, #0xBC]
  00168	eb000000	 bl          LeaveCriticalSection

; 2314 : 
; 2315 :     DEBUGMSG( ZONE_HUB || ZONE_ATTACH, (TEXT("-CHub(%s tier %d)::HandleDetach\n"), GetDeviceType(), m_tierNumber ) );
; 2316 : }

  0016c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00170	e12fff1e	 bx          lr
  00174		 |$M36678|

			 ENDP  ; |?HandleDetach@CHub@@UAAXXZ|, CHub::HandleDetach

	EXPORT	|?OpenPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IQBU_USB_ENDPOINT_DESCRIPTOR@@QAI@Z| ; CHub::OpenPipe

  00000			 AREA	 |.pdata|, PDATA
|$T36697| DCD	|$LN11@OpenPipe|
	DCD	0x40002501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OpenPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IQBU_USB_ENDPOINT_DESCRIPTOR@@QAI@Z| PROC ; CHub::OpenPipe

; 2340 : {

  00000		 |$LN11@OpenPipe|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M36694|
  00004	e1a07003	 mov         r7, r3
  00008	e1a08002	 mov         r8, r2
  0000c	e1a09001	 mov         r9, r1
  00010	e1a05000	 mov         r5, r0

; 2341 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CHub(%s tier %d)::OpenPipe - address = %d\n"), GetDeviceType(), m_tierNumber, address) );
; 2342 : 
; 2343 :     HCD_REQUEST_STATUS status = requestIgnored;
; 2344 : 
; 2345 :     EnterCriticalSection( &m_csDeviceLock );

  00014	e285000c	 add         r0, r5, #0xC
  00018	e3a04002	 mov         r4, #2
  0001c	eb000000	 bl          EnterCriticalSection

; 2346 : 
; 2347 :     // no one should be calling OpenPipe on hubs, since we handle
; 2348 :     // hubs internally.
; 2349 :     DEBUGCHK( address != m_address );
; 2350 : 
; 2351 :     PREFAST_DEBUGCHK( m_ppCDeviceOnPort != NULL );
; 2352 :     for ( UCHAR port = 1; status == requestIgnored && port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  00020	e3a06001	 mov         r6, #1
  00024		 |$LL4@OpenPipe|
  00024	e5d5e06a	 ldrb        lr, [r5, #0x6A]
  00028	e156000e	 cmp         r6, lr
  0002c	8a000013	 bhi         |$LN2@OpenPipe|

; 2353 :         if ( m_ppCDeviceOnPort[ port - 1 ] != NULL ) {

  00030	e595e0b0	 ldr         lr, [r5, #0xB0]
  00034	e08ee106	 add         lr, lr, r6, lsl #2
  00038	e51ee004	 ldr         lr, [lr, #-4]
  0003c	e35e0000	 cmp         lr, #0
  00040	0a00000a	 beq         |$LN3@OpenPipe|

; 2354 :             status = m_ppCDeviceOnPort[ port - 1 ]->OpenPipe( address,
; 2355 :                                                               lpEndpointDescriptor,
; 2356 :                                                               lpiEndpointIndex );

  00044	e595e0b0	 ldr         lr, [r5, #0xB0]
  00048	e1a03007	 mov         r3, r7
  0004c	e1a02008	 mov         r2, r8
  00050	e08e1106	 add         r1, lr, r6, lsl #2
  00054	e5110004	 ldr         r0, [r1, #-4]
  00058	e1a01009	 mov         r1, r9
  0005c	e5904000	 ldr         r4, [r0]
  00060	e5944008	 ldr         r4, [r4, #8]
  00064	e1a0e00f	 mov         lr, pc
  00068	e12fff14	 bx          r4
  0006c	e1a04000	 mov         r4, r0
  00070		 |$LN3@OpenPipe|
  00070	e2863001	 add         r3, r6, #1
  00074	e20360ff	 and         r6, r3, #0xFF
  00078	e3540002	 cmp         r4, #2
  0007c	0affffe8	 beq         |$LL4@OpenPipe|
  00080		 |$LN2@OpenPipe|

; 2357 :         }
; 2358 :     }
; 2359 : 
; 2360 :     LeaveCriticalSection( &m_csDeviceLock );

  00080	e285000c	 add         r0, r5, #0xC
  00084	eb000000	 bl          LeaveCriticalSection

; 2361 : 
; 2362 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CHub(%s tier %d)::OpenPipe - address = %d, returing HCD_REQUEST_STATUS %d\n"), GetDeviceType(), m_tierNumber, address, status) );
; 2363 :     return status;
; 2364 : }

  00088	e1a00004	 mov         r0, r4
  0008c	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$M36695|

			 ENDP  ; |?OpenPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IQBU_USB_ENDPOINT_DESCRIPTOR@@QAI@Z|, CHub::OpenPipe

	EXPORT	|?ClosePipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z| ; CHub::ClosePipe

  00000			 AREA	 |.pdata|, PDATA
|$T36713| DCD	|$LN11@ClosePipe|
	DCD	0x40002301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ClosePipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z| PROC ; CHub::ClosePipe

; 2382 : {

  00000		 |$LN11@ClosePipe|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M36710|
  00004	e1a07002	 mov         r7, r2
  00008	e1a08001	 mov         r8, r1
  0000c	e1a04000	 mov         r4, r0

; 2383 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CHub(%s tier %d)::ClosePipe - address = %d, pipeIndex = %d\n"), GetDeviceType(), m_tierNumber, address, pipeIndex) );
; 2384 : 
; 2385 :     HCD_REQUEST_STATUS status = requestIgnored;
; 2386 : 
; 2387 :     EnterCriticalSection( &m_csDeviceLock );

  00010	e284000c	 add         r0, r4, #0xC
  00014	e3a06002	 mov         r6, #2
  00018	eb000000	 bl          EnterCriticalSection

; 2388 : 
; 2389 :     // no one should be calling ClosePipe on hubs, since we handle
; 2390 :     // hubs internally.
; 2391 :     DEBUGCHK( address != m_address );
; 2392 : 
; 2393 :     PREFAST_DEBUGCHK( m_ppCDeviceOnPort != NULL );
; 2394 :     for ( UCHAR port = 1; status == requestIgnored && port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  0001c	e3a05001	 mov         r5, #1
  00020		 |$LL4@ClosePipe|
  00020	e5d4306a	 ldrb        r3, [r4, #0x6A]
  00024	e1550003	 cmp         r5, r3
  00028	8a000012	 bhi         |$LN2@ClosePipe|

; 2395 :         if ( m_ppCDeviceOnPort[ port - 1 ] != NULL ) {

  0002c	e59430b0	 ldr         r3, [r4, #0xB0]
  00030	e0833105	 add         r3, r3, r5, lsl #2
  00034	e5133004	 ldr         r3, [r3, #-4]
  00038	e3530000	 cmp         r3, #0
  0003c	0a000009	 beq         |$LN3@ClosePipe|

; 2396 :             status = m_ppCDeviceOnPort[ port - 1 ]->ClosePipe( address,
; 2397 :                                                                pipeIndex );

  00040	e59430b0	 ldr         r3, [r4, #0xB0]
  00044	e1a02007	 mov         r2, r7
  00048	e1a01008	 mov         r1, r8
  0004c	e0833105	 add         r3, r3, r5, lsl #2
  00050	e5130004	 ldr         r0, [r3, #-4]
  00054	e5903000	 ldr         r3, [r0]
  00058	e593300c	 ldr         r3, [r3, #0xC]
  0005c	e1a0e00f	 mov         lr, pc
  00060	e12fff13	 bx          r3
  00064	e1a06000	 mov         r6, r0
  00068		 |$LN3@ClosePipe|
  00068	e2853001	 add         r3, r5, #1
  0006c	e20350ff	 and         r5, r3, #0xFF
  00070	e3560002	 cmp         r6, #2
  00074	0affffe9	 beq         |$LL4@ClosePipe|
  00078		 |$LN2@ClosePipe|

; 2398 :         }
; 2399 :     }
; 2400 : 
; 2401 :     LeaveCriticalSection( &m_csDeviceLock );

  00078	e284000c	 add         r0, r4, #0xC
  0007c	eb000000	 bl          LeaveCriticalSection

; 2402 : 
; 2403 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CHub(%s tier %d)::ClosePipe - address = %d, pipeIndex = %d, returing HCD_REQUEST_STATUS %d\n"), GetDeviceType(), m_tierNumber, address, pipeIndex, status) );
; 2404 :     return status;
; 2405 : }

  00080	e1a00006	 mov         r0, r6
  00084	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$M36711|

			 ENDP  ; |?ClosePipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|, CHub::ClosePipe

	EXPORT	|?IssueTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z| ; CHub::IssueTransfer

  00000			 AREA	 |.pdata|, PDATA
|$T36745| DCD	|$LN11@IssueTrans|
	DCD	0x40004602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IssueTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z| PROC ; CHub::IssueTransfer

; 2442 : {

  00000		 |$LN11@IssueTrans|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd03c	 sub         sp, sp, #0x3C
  00008		 |$M36742|
  00008	e1a07003	 mov         r7, r3
  0000c	e1a08002	 mov         r8, r2
  00010	e1a09001	 mov         r9, r1
  00014	e1a05000	 mov         r5, r0

; 2443 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CHub(%s tier %d)::IssueTransfer, address = %d, pipe = %d\n"), GetDeviceType(), m_tierNumber, address, pipeIndex));
; 2444 : 
; 2445 :     HCD_REQUEST_STATUS status = requestIgnored;
; 2446 : 
; 2447 :     EnterCriticalSection( &m_csDeviceLock );

  00018	e285000c	 add         r0, r5, #0xC
  0001c	e3a04002	 mov         r4, #2
  00020	eb000000	 bl          EnterCriticalSection

; 2448 : 
; 2449 :     // no one should be calling IssueTransfer on hubs, since we handle
; 2450 :     // hubs internally.
; 2451 :     DEBUGCHK( address != m_address );
; 2452 : 
; 2453 :     PREFAST_DEBUGCHK( m_ppCDeviceOnPort != NULL );
; 2454 :     for ( UCHAR port = 1; status == requestIgnored && port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  00024	e59da098	 ldr         r10, [sp, #0x98]
  00028	e59db094	 ldr         r11, [sp, #0x94]
  0002c	e3a06001	 mov         r6, #1
  00030		 |$LL4@IssueTrans|
  00030	e5d5306a	 ldrb        r3, [r5, #0x6A]
  00034	e1560003	 cmp         r6, r3
  00038	8a000030	 bhi         |$LN2@IssueTrans|

; 2455 :         if ( m_ppCDeviceOnPort[ port - 1 ] != NULL ) {

  0003c	e59530b0	 ldr         r3, [r5, #0xB0]
  00040	e0833106	 add         r3, r3, r6, lsl #2
  00044	e5133004	 ldr         r3, [r3, #-4]
  00048	e3530000	 cmp         r3, #0
  0004c	0a000027	 beq         |$LN3@IssueTrans|

; 2456 :             status = m_ppCDeviceOnPort[ port - 1 ]->IssueTransfer(
; 2457 :                                                         address,
; 2458 :                                                         pipeIndex,
; 2459 :                                                         lpStartAddress,
; 2460 :                                                         lpvNotifyParameter,
; 2461 :                                                         dwFlags,
; 2462 :                                                         lpvControlHeader,
; 2463 :                                                         dwStartingFrame,
; 2464 :                                                         dwFrames,
; 2465 :                                                         aLengths,
; 2466 :                                                         dwBufferSize,
; 2467 :                                                         lpvBuffer,
; 2468 :                                                         paBuffer,
; 2469 :                                                         lpvCancelId,
; 2470 :                                                         adwIsochErrors,
; 2471 :                                                         adwIsochLengths,
; 2472 :                                                         lpfComplete,
; 2473 :                                                         lpdwBytesTransfered,
; 2474 :                                                         lpdwError );

  00050	e58da038	 str         r10, [sp, #0x38]
  00054	e59da090	 ldr         r10, [sp, #0x90]
  00058	e59510b0	 ldr         r1, [r5, #0xB0]
  0005c	e1a03007	 mov         r3, r7
  00060	e58da030	 str         r10, [sp, #0x30]
  00064	e59da08c	 ldr         r10, [sp, #0x8C]
  00068	e0811106	 add         r1, r1, r6, lsl #2
  0006c	e5110004	 ldr         r0, [r1, #-4]
  00070	e58da02c	 str         r10, [sp, #0x2C]
  00074	e59da088	 ldr         r10, [sp, #0x88]
  00078	e5904000	 ldr         r4, [r0]
  0007c	e1a02008	 mov         r2, r8
  00080	e58da028	 str         r10, [sp, #0x28]
  00084	e59da084	 ldr         r10, [sp, #0x84]
  00088	e5944010	 ldr         r4, [r4, #0x10]
  0008c	e1a01009	 mov         r1, r9
  00090	e58da024	 str         r10, [sp, #0x24]
  00094	e59da080	 ldr         r10, [sp, #0x80]
  00098	e58db034	 str         r11, [sp, #0x34]
  0009c	e58da020	 str         r10, [sp, #0x20]
  000a0	e59da07c	 ldr         r10, [sp, #0x7C]
  000a4	e58da01c	 str         r10, [sp, #0x1C]
  000a8	e59da078	 ldr         r10, [sp, #0x78]
  000ac	e58da018	 str         r10, [sp, #0x18]
  000b0	e59da074	 ldr         r10, [sp, #0x74]
  000b4	e58da014	 str         r10, [sp, #0x14]
  000b8	e59da070	 ldr         r10, [sp, #0x70]
  000bc	e58da010	 str         r10, [sp, #0x10]
  000c0	e59da06c	 ldr         r10, [sp, #0x6C]
  000c4	e58da00c	 str         r10, [sp, #0xC]
  000c8	e59da068	 ldr         r10, [sp, #0x68]
  000cc	e58da008	 str         r10, [sp, #8]
  000d0	e59da064	 ldr         r10, [sp, #0x64]
  000d4	e58da004	 str         r10, [sp, #4]
  000d8	e59da060	 ldr         r10, [sp, #0x60]
  000dc	e58da000	 str         r10, [sp]
  000e0	e1a0e00f	 mov         lr, pc
  000e4	e12fff14	 bx          r4
  000e8	e59da098	 ldr         r10, [sp, #0x98]
  000ec	e1a04000	 mov         r4, r0
  000f0		 |$LN3@IssueTrans|
  000f0	e2863001	 add         r3, r6, #1
  000f4	e20360ff	 and         r6, r3, #0xFF
  000f8	e3540002	 cmp         r4, #2
  000fc	0affffcb	 beq         |$LL4@IssueTrans|
  00100		 |$LN2@IssueTrans|

; 2475 :         }
; 2476 :     }
; 2477 : 
; 2478 :     LeaveCriticalSection( &m_csDeviceLock );

  00100	e285000c	 add         r0, r5, #0xC
  00104	eb000000	 bl          LeaveCriticalSection

; 2479 : 
; 2480 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CHub(%s tier %d)::IssueTransfer address = %d, pipe = %d, returing HCD_REQUEST_STATUS %d\n"), GetDeviceType(), m_tierNumber, address, pipeIndex, status ) );
; 2481 :     return status;
; 2482 : }

  00108	e1a00004	 mov         r0, r4
  0010c	e28dd03c	 add         sp, sp, #0x3C
  00110	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00114	e12fff1e	 bx          lr
  00118		 |$M36743|

			 ENDP  ; |?IssueTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z|, CHub::IssueTransfer

	EXPORT	|?AbortTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXQBX@Z| ; CHub::AbortTransfer

  00000			 AREA	 |.pdata|, PDATA
|$T36764| DCD	|$LN11@AbortTrans|
	DCD	0x40002b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AbortTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXQBX@Z| PROC ; CHub::AbortTransfer

; 2505 : {

  00000		 |$LN11@AbortTrans|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M36761|
  00008	e1a07003	 mov         r7, r3
  0000c	e1a08002	 mov         r8, r2
  00010	e1a09001	 mov         r9, r1
  00014	e1a05000	 mov         r5, r0

; 2506 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CHub(%s tier %d)::AbortTransfer - address = %d, pipeIndex = %d\n"), GetDeviceType(), m_tierNumber, address, pipeIndex) );
; 2507 : 
; 2508 :     HCD_REQUEST_STATUS status = requestIgnored;
; 2509 : 
; 2510 :     EnterCriticalSection( &m_csDeviceLock );

  00018	e285000c	 add         r0, r5, #0xC
  0001c	e3a04002	 mov         r4, #2
  00020	eb000000	 bl          EnterCriticalSection

; 2511 : 
; 2512 :     // no one should be calling AbortTransfer on hubs, since we handle
; 2513 :     // hubs internally.
; 2514 :     DEBUGCHK( address != m_address );
; 2515 : 
; 2516 :     PREFAST_DEBUGCHK( m_ppCDeviceOnPort != NULL );
; 2517 :     for ( UCHAR port = 1; status == requestIgnored && port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  00024	e59da030	 ldr         r10, [sp, #0x30]
  00028	e59db02c	 ldr         r11, [sp, #0x2C]
  0002c	e3a06001	 mov         r6, #1
  00030		 |$LL4@AbortTrans|
  00030	e5d5e06a	 ldrb        lr, [r5, #0x6A]
  00034	e156000e	 cmp         r6, lr
  00038	8a000015	 bhi         |$LN2@AbortTrans|

; 2518 :         if ( m_ppCDeviceOnPort[ port - 1 ] != NULL ) {

  0003c	e595e0b0	 ldr         lr, [r5, #0xB0]
  00040	e08ee106	 add         lr, lr, r6, lsl #2
  00044	e51ee004	 ldr         lr, [lr, #-4]
  00048	e35e0000	 cmp         lr, #0
  0004c	0a00000c	 beq         |$LN3@AbortTrans|

; 2519 :             status = m_ppCDeviceOnPort[ port - 1 ]->AbortTransfer( address,
; 2520 :                                                                    pipeIndex,
; 2521 :                                                                    lpCancelAddress,
; 2522 :                                                                    lpvNotifyParameter,
; 2523 :                                                                    lpvCancelId );

  00050	e59510b0	 ldr         r1, [r5, #0xB0]
  00054	e1a03007	 mov         r3, r7
  00058	e1a02008	 mov         r2, r8
  0005c	e0811106	 add         r1, r1, r6, lsl #2
  00060	e5110004	 ldr         r0, [r1, #-4]
  00064	e1a01009	 mov         r1, r9
  00068	e58da004	 str         r10, [sp, #4]
  0006c	e5904000	 ldr         r4, [r0]
  00070	e58db000	 str         r11, [sp]
  00074	e5944014	 ldr         r4, [r4, #0x14]
  00078	e1a0e00f	 mov         lr, pc
  0007c	e12fff14	 bx          r4
  00080	e1a04000	 mov         r4, r0
  00084		 |$LN3@AbortTrans|
  00084	e2863001	 add         r3, r6, #1
  00088	e20360ff	 and         r6, r3, #0xFF
  0008c	e3540002	 cmp         r4, #2
  00090	0affffe6	 beq         |$LL4@AbortTrans|
  00094		 |$LN2@AbortTrans|

; 2524 :         }
; 2525 :     }
; 2526 : 
; 2527 :     LeaveCriticalSection( &m_csDeviceLock );

  00094	e285000c	 add         r0, r5, #0xC
  00098	eb000000	 bl          LeaveCriticalSection

; 2528 : 
; 2529 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CHub(%s tier %d)::AbortTransfer - address = %d, pipeIndex = %d, returing HCD_REQUEST_STATUS %d\n"), GetDeviceType(), m_tierNumber, address, pipeIndex, status) );
; 2530 :     return status;
; 2531 : }

  0009c	e1a00004	 mov         r0, r4
  000a0	e28dd008	 add         sp, sp, #8
  000a4	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  000a8	e12fff1e	 bx          lr
  000ac		 |$M36762|

			 ENDP  ; |?AbortTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXQBX@Z|, CHub::AbortTransfer

	EXPORT	|?IsPipeHalted@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQAH@Z| ; CHub::IsPipeHalted

  00000			 AREA	 |.pdata|, PDATA
|$T36781| DCD	|$LN11@IsPipeHalt|
	DCD	0x40002501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsPipeHalted@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQAH@Z| PROC ; CHub::IsPipeHalted

; 2552 : {

  00000		 |$LN11@IsPipeHalt|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M36778|
  00004	e1a07003	 mov         r7, r3
  00008	e1a08002	 mov         r8, r2
  0000c	e1a09001	 mov         r9, r1
  00010	e1a05000	 mov         r5, r0

; 2553 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CHub(%s tier %d)::IsPipeHalted - address = %d, pipeIndex = %d\n"), GetDeviceType(), m_tierNumber, address, pipeIndex) );
; 2554 : 
; 2555 :     HCD_REQUEST_STATUS status = requestIgnored;
; 2556 : 
; 2557 :     EnterCriticalSection( &m_csDeviceLock );

  00014	e285000c	 add         r0, r5, #0xC
  00018	e3a04002	 mov         r4, #2
  0001c	eb000000	 bl          EnterCriticalSection

; 2558 : 
; 2559 :     // no one should be calling IsPipeHalted on hubs, since we handle
; 2560 :     // hubs internally.
; 2561 :     DEBUGCHK( address != m_address );
; 2562 : 
; 2563 :     PREFAST_DEBUGCHK( m_ppCDeviceOnPort != NULL );
; 2564 :     for ( UCHAR port = 1; status == requestIgnored && port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  00020	e3a06001	 mov         r6, #1
  00024		 |$LL4@IsPipeHalt|
  00024	e5d5e06a	 ldrb        lr, [r5, #0x6A]
  00028	e156000e	 cmp         r6, lr
  0002c	8a000013	 bhi         |$LN2@IsPipeHalt|

; 2565 :         if ( m_ppCDeviceOnPort[ port - 1 ] != NULL ) {

  00030	e595e0b0	 ldr         lr, [r5, #0xB0]
  00034	e08ee106	 add         lr, lr, r6, lsl #2
  00038	e51ee004	 ldr         lr, [lr, #-4]
  0003c	e35e0000	 cmp         lr, #0
  00040	0a00000a	 beq         |$LN3@IsPipeHalt|

; 2566 :             status = m_ppCDeviceOnPort[ port - 1 ]->IsPipeHalted( address,
; 2567 :                                                                   pipeIndex,
; 2568 :                                                                   lpbHalted );

  00044	e595e0b0	 ldr         lr, [r5, #0xB0]
  00048	e1a03007	 mov         r3, r7
  0004c	e1a02008	 mov         r2, r8
  00050	e08e1106	 add         r1, lr, r6, lsl #2
  00054	e5110004	 ldr         r0, [r1, #-4]
  00058	e1a01009	 mov         r1, r9
  0005c	e5904000	 ldr         r4, [r0]
  00060	e5944018	 ldr         r4, [r4, #0x18]
  00064	e1a0e00f	 mov         lr, pc
  00068	e12fff14	 bx          r4
  0006c	e1a04000	 mov         r4, r0
  00070		 |$LN3@IsPipeHalt|
  00070	e2863001	 add         r3, r6, #1
  00074	e20360ff	 and         r6, r3, #0xFF
  00078	e3540002	 cmp         r4, #2
  0007c	0affffe8	 beq         |$LL4@IsPipeHalt|
  00080		 |$LN2@IsPipeHalt|

; 2569 :         }
; 2570 :     }
; 2571 : 
; 2572 :     LeaveCriticalSection( &m_csDeviceLock );

  00080	e285000c	 add         r0, r5, #0xC
  00084	eb000000	 bl          LeaveCriticalSection

; 2573 : 
; 2574 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CHub(%s tier %d)::IsPipeHalted - address = %d, pipe = %d, returing HCD_REQUEST_STATUS %d\n"), GetDeviceType(), m_tierNumber, address, pipeIndex, status) );
; 2575 :     return status;
; 2576 : }

  00088	e1a00004	 mov         r0, r4
  0008c	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$M36779|

			 ENDP  ; |?IsPipeHalted@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQAH@Z|, CHub::IsPipeHalted

	EXPORT	|?ResetPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z| ; CHub::ResetPipe

  00000			 AREA	 |.pdata|, PDATA
|$T36797| DCD	|$LN11@ResetPipe|
	DCD	0x40002301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResetPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z| PROC ; CHub::ResetPipe

; 2594 : {

  00000		 |$LN11@ResetPipe|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M36794|
  00004	e1a07002	 mov         r7, r2
  00008	e1a08001	 mov         r8, r1
  0000c	e1a04000	 mov         r4, r0

; 2595 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CHub(%s tier %d)::ResetPipe - address = %d, pipeIndex = %d\n"), GetDeviceType(), m_tierNumber, address, pipeIndex) );
; 2596 : 
; 2597 :     HCD_REQUEST_STATUS status = requestIgnored;
; 2598 : 
; 2599 :     EnterCriticalSection( &m_csDeviceLock );

  00010	e284000c	 add         r0, r4, #0xC
  00014	e3a06002	 mov         r6, #2
  00018	eb000000	 bl          EnterCriticalSection

; 2600 : 
; 2601 :     // no one should be calling ResetPipe on hubs, since we handle
; 2602 :     // hubs internally.
; 2603 :     DEBUGCHK( address != m_address );
; 2604 :     PREFAST_DEBUGCHK( m_ppCDeviceOnPort!=NULL );
; 2605 :     
; 2606 :     DEBUGCHK( m_ppCDeviceOnPort != NULL );
; 2607 :     for ( UCHAR port = 1; status == requestIgnored && port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  0001c	e3a05001	 mov         r5, #1
  00020		 |$LL4@ResetPipe|
  00020	e5d4306a	 ldrb        r3, [r4, #0x6A]
  00024	e1550003	 cmp         r5, r3
  00028	8a000012	 bhi         |$LN2@ResetPipe|

; 2608 :         if ( m_ppCDeviceOnPort[ port - 1 ] != NULL ) {

  0002c	e59430b0	 ldr         r3, [r4, #0xB0]
  00030	e0833105	 add         r3, r3, r5, lsl #2
  00034	e5133004	 ldr         r3, [r3, #-4]
  00038	e3530000	 cmp         r3, #0
  0003c	0a000009	 beq         |$LN3@ResetPipe|

; 2609 :             status = m_ppCDeviceOnPort[ port - 1 ]->ResetPipe( address,
; 2610 :                                                                pipeIndex );

  00040	e59430b0	 ldr         r3, [r4, #0xB0]
  00044	e1a02007	 mov         r2, r7
  00048	e1a01008	 mov         r1, r8
  0004c	e0833105	 add         r3, r3, r5, lsl #2
  00050	e5130004	 ldr         r0, [r3, #-4]
  00054	e5903000	 ldr         r3, [r0]
  00058	e593301c	 ldr         r3, [r3, #0x1C]
  0005c	e1a0e00f	 mov         lr, pc
  00060	e12fff13	 bx          r3
  00064	e1a06000	 mov         r6, r0
  00068		 |$LN3@ResetPipe|
  00068	e2853001	 add         r3, r5, #1
  0006c	e20350ff	 and         r5, r3, #0xFF
  00070	e3560002	 cmp         r6, #2
  00074	0affffe9	 beq         |$LL4@ResetPipe|
  00078		 |$LN2@ResetPipe|

; 2611 :         }
; 2612 :     }
; 2613 : 
; 2614 :     LeaveCriticalSection( &m_csDeviceLock );

  00078	e284000c	 add         r0, r4, #0xC
  0007c	eb000000	 bl          LeaveCriticalSection

; 2615 : 
; 2616 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CHub(%s tier %d)::ResetPipe - address = %d, pipeIndex = %d, returing HCD_REQUEST_STATUS %d\n"), GetDeviceType(), m_tierNumber, address, pipeIndex, status) );
; 2617 :     return status;
; 2618 : }

  00080	e1a00006	 mov         r0, r6
  00084	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$M36795|

			 ENDP  ; |?ResetPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|, CHub::ResetPipe

	EXPORT	|?DisableDevice@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z| ; CHub::DisableDevice

  00000			 AREA	 |.pdata|, PDATA
|$T36813| DCD	|$LN13@DisableDev@2|
	DCD	0x40002801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DisableDevice@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z| PROC ; CHub::DisableDevice

; 2635 : {

  00000		 |$LN13@DisableDev@2|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M36810|
  00004	e1a08002	 mov         r8, r2
  00008	e1a07001	 mov         r7, r1
  0000c	e1a04000	 mov         r4, r0

; 2636 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CHub(%s tier %d)::DisableDevice - address = %d, pipeIndex = %d\n"), GetDeviceType(), m_tierNumber, address, fReset) );
; 2637 : 
; 2638 :     HCD_REQUEST_STATUS status = requestIgnored;
; 2639 : 
; 2640 :     EnterCriticalSection( &m_csDeviceLock );

  00010	e284000c	 add         r0, r4, #0xC
  00014	e3a06002	 mov         r6, #2
  00018	eb000000	 bl          EnterCriticalSection

; 2641 :     if ( address != m_address ) {

  0001c	e5d43020	 ldrb        r3, [r4, #0x20]
  00020	e1570003	 cmp         r7, r3
  00024	0a000017	 beq         |$LN6@DisableDev@2|

; 2642 :         PREFAST_DEBUGCHK( m_ppCDeviceOnPort != NULL );
; 2643 :         for ( UCHAR port = 1; status == requestIgnored && port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  00028	e3a05001	 mov         r5, #1
  0002c		 |$LL5@DisableDev@2|
  0002c	e5d4306a	 ldrb        r3, [r4, #0x6A]
  00030	e1550003	 cmp         r5, r3
  00034	8a000014	 bhi         |$LN1@DisableDev@2|

; 2644 :             if ( m_ppCDeviceOnPort[ port - 1 ] != NULL ) {

  00038	e59430b0	 ldr         r3, [r4, #0xB0]
  0003c	e0833105	 add         r3, r3, r5, lsl #2
  00040	e5133004	 ldr         r3, [r3, #-4]
  00044	e3530000	 cmp         r3, #0
  00048	0a000009	 beq         |$LN4@DisableDev@2|

; 2645 :                 status =  m_ppCDeviceOnPort[ port - 1 ]-> DisableDevice(address, fReset);

  0004c	e59430b0	 ldr         r3, [r4, #0xB0]
  00050	e1a02008	 mov         r2, r8
  00054	e1a01007	 mov         r1, r7
  00058	e0833105	 add         r3, r3, r5, lsl #2
  0005c	e5130004	 ldr         r0, [r3, #-4]
  00060	e5903000	 ldr         r3, [r0]
  00064	e5933020	 ldr         r3, [r3, #0x20]
  00068	e1a0e00f	 mov         lr, pc
  0006c	e12fff13	 bx          r3
  00070	e1a06000	 mov         r6, r0
  00074		 |$LN4@DisableDev@2|
  00074	e2853001	 add         r3, r5, #1
  00078	e20350ff	 and         r5, r3, #0xFF
  0007c	e3560002	 cmp         r6, #2
  00080	0affffe9	 beq         |$LL5@DisableDev@2|

; 2646 :             }
; 2647 :         }
; 2648 :     }
; 2649 :     else { // It should not happens

  00084	ea000000	 b           |$LN1@DisableDev@2|
  00088		 |$LN6@DisableDev@2|

; 2650 :         ASSERT(FALSE);
; 2651 :         status = requestFailed;

  00088	e3a06000	 mov         r6, #0
  0008c		 |$LN1@DisableDev@2|

; 2652 :     }
; 2653 :     LeaveCriticalSection( &m_csDeviceLock );

  0008c	e284000c	 add         r0, r4, #0xC
  00090	eb000000	 bl          LeaveCriticalSection

; 2654 : 
; 2655 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CHub(%s tier %d)::DisableDevice - address = %d, returing HCD_REQUEST_STATUS %d\n"), GetDeviceType(), m_tierNumber, address, status) );
; 2656 :     return status;
; 2657 : }

  00094	e1a00006	 mov         r0, r6
  00098	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$M36811|

			 ENDP  ; |?DisableDevice@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|, CHub::DisableDevice

	EXPORT	|?NotifyOnSuspendedResumed@CHub@@UAAHH@Z| ; CHub::NotifyOnSuspendedResumed

  00000			 AREA	 |.pdata|, PDATA
|$T36828| DCD	|$LN12@NotifyOnSu@2|
	DCD	0x40001d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?NotifyOnSuspendedResumed@CHub@@UAAHH@Z| PROC ; CHub::NotifyOnSuspendedResumed

; 2660 : {

  00000		 |$LN12@NotifyOnSu@2|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M36825|
  00004	e1a06001	 mov         r6, r1
  00008	e1a05000	 mov         r5, r0

; 2661 :     for ( UCHAR port = 1; m_ppCDeviceOnPort != NULL && port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  0000c	e59530b0	 ldr         r3, [r5, #0xB0]
  00010	e3a04001	 mov         r4, #1
  00014	e1b02003	 movs        r2, r3
  00018	0a000012	 beq         |$LN9@NotifyOnSu@2|
  0001c		 |$LL4@NotifyOnSu@2|
  0001c	e5d5306a	 ldrb        r3, [r5, #0x6A]
  00020	e1540003	 cmp         r4, r3
  00024	8a00000f	 bhi         |$LN9@NotifyOnSu@2|

; 2662 :         if ( m_ppCDeviceOnPort[ port - 1 ] != NULL ) { // Notify all down stream device.

  00028	e0823104	 add         r3, r2, r4, lsl #2
  0002c	e5133004	 ldr         r3, [r3, #-4]
  00030	e3530000	 cmp         r3, #0

; 2663 :             m_ppCDeviceOnPort[ port - 1 ]-> NotifyOnSuspendedResumed(fResumed);

  00034	159530b0	 ldrne       r3, [r5, #0xB0]
  00038	11a01006	 movne       r1, r6
  0003c	10833104	 addne       r3, r3, r4, lsl #2
  00040	15130004	 ldrne       r0, [r3, #-4]
  00044	15903000	 ldrne       r3, [r0]
  00048	1593302c	 ldrne       r3, [r3, #0x2C]
  0004c	11a0e00f	 movne       lr, pc
  00050	112fff13	 bxne        r3
  00054	e59520b0	 ldr         r2, [r5, #0xB0]
  00058	e2843001	 add         r3, r4, #1
  0005c	e20340ff	 and         r4, r3, #0xFF
  00060	e3520000	 cmp         r2, #0
  00064	1affffec	 bne         |$LL4@NotifyOnSu@2|
  00068		 |$LN9@NotifyOnSu@2|

; 2664 :         }
; 2665 :     }
; 2666 :     return TRUE;

  00068	e3a00001	 mov         r0, #1

; 2667 : }

  0006c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00070	e12fff1e	 bx          lr
  00074		 |$M36826|

			 ENDP  ; |?NotifyOnSuspendedResumed@CHub@@UAAHH@Z|, CHub::NotifyOnSuspendedResumed

	EXPORT	|?SuspendResume@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z| ; CHub::SuspendResume

  00000			 AREA	 |.pdata|, PDATA
|$T36844| DCD	|$LN13@SuspendRes@2|
	DCD	0x40002801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SuspendResume@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z| PROC ; CHub::SuspendResume

; 2685 : {

  00000		 |$LN13@SuspendRes@2|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M36841|
  00004	e1a08002	 mov         r8, r2
  00008	e1a07001	 mov         r7, r1
  0000c	e1a04000	 mov         r4, r0

; 2686 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CHub(%s tier %d)::SuspendResume - address = %d, fSuspend = %d\n"), GetDeviceType(), m_tierNumber, address, fSuspend) );
; 2687 : 
; 2688 :     HCD_REQUEST_STATUS status = requestIgnored;
; 2689 : 
; 2690 :     EnterCriticalSection( &m_csDeviceLock );

  00010	e284000c	 add         r0, r4, #0xC
  00014	e3a06002	 mov         r6, #2
  00018	eb000000	 bl          EnterCriticalSection

; 2691 :     if ( address != m_address ) {

  0001c	e5d43020	 ldrb        r3, [r4, #0x20]
  00020	e1570003	 cmp         r7, r3
  00024	0a000017	 beq         |$LN6@SuspendRes@2|

; 2692 :         PREFAST_DEBUGCHK( m_ppCDeviceOnPort != NULL );
; 2693 :         for ( UCHAR port = 1; status == requestIgnored && port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  00028	e3a05001	 mov         r5, #1
  0002c		 |$LL5@SuspendRes@2|
  0002c	e5d4306a	 ldrb        r3, [r4, #0x6A]
  00030	e1550003	 cmp         r5, r3
  00034	8a000014	 bhi         |$LN1@SuspendRes@2|

; 2694 :             if ( m_ppCDeviceOnPort[ port - 1 ] != NULL ) {

  00038	e59430b0	 ldr         r3, [r4, #0xB0]
  0003c	e0833105	 add         r3, r3, r5, lsl #2
  00040	e5133004	 ldr         r3, [r3, #-4]
  00044	e3530000	 cmp         r3, #0
  00048	0a000009	 beq         |$LN4@SuspendRes@2|

; 2695 :                 status = m_ppCDeviceOnPort[ port - 1 ] ->SuspendResume(address, fSuspend) ;

  0004c	e59430b0	 ldr         r3, [r4, #0xB0]
  00050	e1a02008	 mov         r2, r8
  00054	e1a01007	 mov         r1, r7
  00058	e0833105	 add         r3, r3, r5, lsl #2
  0005c	e5130004	 ldr         r0, [r3, #-4]
  00060	e5903000	 ldr         r3, [r0]
  00064	e5933024	 ldr         r3, [r3, #0x24]
  00068	e1a0e00f	 mov         lr, pc
  0006c	e12fff13	 bx          r3
  00070	e1a06000	 mov         r6, r0
  00074		 |$LN4@SuspendRes@2|
  00074	e2853001	 add         r3, r5, #1
  00078	e20350ff	 and         r5, r3, #0xFF
  0007c	e3560002	 cmp         r6, #2
  00080	0affffe9	 beq         |$LL5@SuspendRes@2|

; 2696 :             }
; 2697 :         }
; 2698 :     }
; 2699 :     else { // It should not happens

  00084	ea000000	 b           |$LN1@SuspendRes@2|
  00088		 |$LN6@SuspendRes@2|

; 2700 :         ASSERT(FALSE);
; 2701 :         status = requestFailed;

  00088	e3a06000	 mov         r6, #0
  0008c		 |$LN1@SuspendRes@2|

; 2702 :     }
; 2703 :     LeaveCriticalSection( &m_csDeviceLock );

  0008c	e284000c	 add         r0, r4, #0xC
  00090	eb000000	 bl          LeaveCriticalSection

; 2704 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CHub(%s tier %d)::SuspendResume - address = %d, returing HCD_REQUEST_STATUS %d\n"), GetDeviceType(), m_tierNumber, address, status) );
; 2705 :     return status;
; 2706 : }

  00094	e1a00006	 mov         r0, r6
  00098	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$M36842|

			 ENDP  ; |?SuspendResume@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|, CHub::SuspendResume

	EXPORT	|?SuspendResumeOffStreamDevice@CHub@@UAAHIH@Z| ; CHub::SuspendResumeOffStreamDevice
	IMPORT	|Sleep|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T36870| DCD	|$LN21@SuspendRes@3|
	DCD	0x40003b01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SuspendResumeOffStreamDevice@CHub@@UAAHIH@Z| PROC ; CHub::SuspendResumeOffStreamDevice

; 2734 : {

  00000		 |$LN21@SuspendRes@3|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M36867|
  00004	e1a07002	 mov         r7, r2
  00008	e1a06000	 mov         r6, r0

; 2735 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CHub(%s tier %d)::SuspendResume - address = %d, fSuspend = %d\n"), GetDeviceType(), m_tierNumber, address, fSuspend) );
; 2736 :     BOOL fReturn = FALSE;
; 2737 :     for ( UCHAR port = 1; port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  0000c	e5d6006a	 ldrb        r0, [r6, #0x6A]
  00010	e3a08000	 mov         r8, #0
  00014	e3a05001	 mov         r5, #1
  00018	e3500001	 cmp         r0, #1
  0001c	3a00002f	 bcc         |$LN18@SuspendRes@3|
  00020	e596e0b0	 ldr         lr, [r6, #0xB0]
  00024		 |$LL6@SuspendRes@3|

; 2738 :         if (m_ppCDeviceOnPort[ port - 1 ]!= NULL && m_ppCDeviceOnPort[ port - 1 ]->GetDeviceAddress()== address) { // Found.

  00024	e08e2105	 add         r2, lr, r5, lsl #2
  00028	e5123004	 ldr         r3, [r2, #-4]
  0002c	e3530000	 cmp         r3, #0
  00030	0a000002	 beq         |$LN5@SuspendRes@3|
  00034	e5d33020	 ldrb        r3, [r3, #0x20]
  00038	e1530001	 cmp         r3, r1
  0003c	0a000004	 beq         |$LN16@SuspendRes@3|
  00040		 |$LN5@SuspendRes@3|

; 2735 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CHub(%s tier %d)::SuspendResume - address = %d, fSuspend = %d\n"), GetDeviceType(), m_tierNumber, address, fSuspend) );
; 2736 :     BOOL fReturn = FALSE;
; 2737 :     for ( UCHAR port = 1; port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  00040	e2853001	 add         r3, r5, #1
  00044	e20350ff	 and         r5, r3, #0xFF
  00048	e1550000	 cmp         r5, r0
  0004c	9afffff4	 bls         |$LL6@SuspendRes@3|
  00050	ea000022	 b           |$LN18@SuspendRes@3|
  00054		 |$LN16@SuspendRes@3|

; 2739 :             if (SetOrClearFeature( port,
; 2740 :                    fSuspend? USB_REQUEST_SET_FEATURE: USB_REQUEST_CLEAR_FEATURE,
; 2741 :                    USB_HUB_FEATURE_PORT_SUSPEND)) {

  00054	e5961000	 ldr         r1, [r6]
  00058	e3570000	 cmp         r7, #0
  0005c	13a02003	 movne       r2, #3
  00060	e5914048	 ldr         r4, [r1, #0x48]
  00064	03a02001	 moveq       r2, #1
  00068	e20220ff	 and         r2, r2, #0xFF
  0006c	e1a01005	 mov         r1, r5
  00070	e3a03002	 mov         r3, #2
  00074	e1a00006	 mov         r0, r6
  00078	e1a0e00f	 mov         lr, pc
  0007c	e12fff14	 bx          r4
  00080	e3500000	 cmp         r0, #0
  00084	0a000015	 beq         |$LN18@SuspendRes@3|

; 2742 :                 fReturn = TRUE;

  00088	e3a08001	 mov         r8, #1

; 2743 :                 if ( !fSuspend) { // If it is resume.

  0008c	e3570000	 cmp         r7, #0
  00090	1a00000a	 bne         |$LN11@SuspendRes@3|

; 2744 :                     Sleep(20);

  00094	e3a00014	 mov         r0, #0x14
  00098	eb000000	 bl          Sleep

; 2745 :                     m_ppCDeviceOnPort[ port-1 ]-> ResumeNotification();

  0009c	e59630b0	 ldr         r3, [r6, #0xB0]
  000a0	e0833105	 add         r3, r3, r5, lsl #2
  000a4	e5130004	 ldr         r0, [r3, #-4]
  000a8	e5903000	 ldr         r3, [r0]
  000ac	e5933028	 ldr         r3, [r3, #0x28]
  000b0	e1a0e00f	 mov         lr, pc
  000b4	e12fff13	 bx          r3

; 2746 :                 }
; 2747 :                 m_ppCDeviceOnPort[ port-1 ]-> NotifyOnSuspendedResumed(!fSuspend);

  000b8	e3a01001	 mov         r1, #1
  000bc	ea000000	 b           |$LN12@SuspendRes@3|
  000c0		 |$LN11@SuspendRes@3|
  000c0	e3a01000	 mov         r1, #0
  000c4		 |$LN12@SuspendRes@3|
  000c4	e59630b0	 ldr         r3, [r6, #0xB0]
  000c8	e0833105	 add         r3, r3, r5, lsl #2
  000cc	e5130004	 ldr         r0, [r3, #-4]
  000d0	e5903000	 ldr         r3, [r0]
  000d4	e593302c	 ldr         r3, [r3, #0x2C]
  000d8	e1a0e00f	 mov         lr, pc
  000dc	e12fff13	 bx          r3
  000e0		 |$LN18@SuspendRes@3|

; 2748 :             }
; 2749 :             break;
; 2750 :         }
; 2751 :     }
; 2752 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CHub(%s tier %d)::SuspendResume - address = %d, returing HCD_REQUEST_STATUS %d\n"), GetDeviceType(), m_tierNumber, address, fReturn) );
; 2753 :     return fReturn;
; 2754 : }

  000e0	e1a00008	 mov         r0, r8
  000e4	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000e8	e12fff1e	 bx          lr
  000ec		 |$M36868|

			 ENDP  ; |?SuspendResumeOffStreamDevice@CHub@@UAAHIH@Z|, CHub::SuspendResumeOffStreamDevice

	EXPORT	|?PowerAllHubPorts@CRootHub@@EAAHXZ|	; CRootHub::PowerAllHubPorts

  00000			 AREA	 |.pdata|, PDATA
|$T36879| DCD	|$LN5@PowerAllHu|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PowerAllHubPorts@CRootHub@@EAAHXZ| PROC ; CRootHub::PowerAllHubPorts

; 2873 : {

  00000		 |$LN5@PowerAllHu|
  00000		 |$M36876|

; 2874 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("+CRootHub::PowerAllHubPorts\n")) );
; 2875 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("-CRootHub::PowerAllHubPorts\n")) );
; 2876 :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 2877 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M36877|

			 ENDP  ; |?PowerAllHubPorts@CRootHub@@EAAHXZ|, CRootHub::PowerAllHubPorts

	EXPORT	|?WaitForPortStatusChange@CRootHub@@EAAHAAEAAU_USB_HUB_AND_PORT_STATUS@@@Z| ; CRootHub::WaitForPortStatusChange

  00000			 AREA	 |.pdata|, PDATA
|$T36901| DCD	|$LN25@WaitForPor|
	DCD	0x40005701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?WaitForPortStatusChange@CRootHub@@EAAHAAEAAU_USB_HUB_AND_PORT_STATUS@@@Z| PROC ; CRootHub::WaitForPortStatusChange

; 2895 : {

  00000		 |$LN25@WaitForPor|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M36898|
  00004	e1a08002	 mov         r8, r2
  00008	e1a09001	 mov         r9, r1
  0000c	e1a05000	 mov         r5, r0

; 2896 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("+CRootHub::WaitForPortStatusChange\n")) );
; 2897 : 
; 2898 :     BOOL fSuccess = FALSE;
; 2899 :     // root hub - we need to poll for status changes.
; 2900 :     while ( !m_fHubThreadClosing && !fSuccess ) {

  00010	e59530b8	 ldr         r3, [r5, #0xB8]
  00014	e3a06000	 mov         r6, #0
  00018	e3530000	 cmp         r3, #0
  0001c	1a00004b	 bne         |$LN2@WaitForPor|
  00020		 |$LL13@WaitForPor|
  00020	e3560000	 cmp         r6, #0
  00024	1a000033	 bne         |$LN22@WaitForPor|

; 2901 :         for ( UCHAR port = 1; !fSuccess && port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  00028	e3a04001	 mov         r4, #1
  0002c		 |$LL11@WaitForPor|
  0002c	e5d5306a	 ldrb        r3, [r5, #0x6A]
  00030	e1540003	 cmp         r4, r3
  00034	8a000014	 bhi         |$LN9@WaitForPor|

; 2902 :             if ( m_pCHcd->DidPortStatusChange( port ) ) {

  00038	e59500c8	 ldr         r0, [r5, #0xC8]
  0003c	e1a01004	 mov         r1, r4
  00040	e5903000	 ldr         r3, [r0]
  00044	e5933030	 ldr         r3, [r3, #0x30]
  00048	e1a0e00f	 mov         lr, pc
  0004c	e12fff13	 bx          r3
  00050	e3500000	 cmp         r0, #0
  00054	0a000008	 beq         |$LN10@WaitForPor|

; 2903 :                 // port status changed on this port
; 2904 :                 rPort = port;

  00058	e5c94000	 strb        r4, [r9]

; 2905 :                 // we could just call CHW::GetPortStatus, but it is
; 2906 :                 // better to call CRootHub::GetStatus which is
; 2907 :                 // designed to implement the virtual CHub::GetStatus function.
; 2908 :                 fSuccess = GetStatus( port, rStatus );

  0005c	e5953000	 ldr         r3, [r5]
  00060	e1a02008	 mov         r2, r8
  00064	e1a01004	 mov         r1, r4
  00068	e5933050	 ldr         r3, [r3, #0x50]
  0006c	e1a00005	 mov         r0, r5
  00070	e1a0e00f	 mov         lr, pc
  00074	e12fff13	 bx          r3
  00078	e1a06000	 mov         r6, r0
  0007c		 |$LN10@WaitForPor|
  0007c	e2843001	 add         r3, r4, #1
  00080	e20340ff	 and         r4, r3, #0xFF
  00084	e3560000	 cmp         r6, #0
  00088	0affffe7	 beq         |$LL11@WaitForPor|
  0008c		 |$LN9@WaitForPor|

; 2909 :             }
; 2910 :         }
; 2911 :         if (!m_fHubThreadClosing && !fSuccess && !m_pCHcd->WaitForPortStatusChange(m_hHubStatusChangeEvent)) {

  0008c	e59530b8	 ldr         r3, [r5, #0xB8]
  00090	e3530000	 cmp         r3, #0
  00094	1a00000b	 bne         |$LN7@WaitForPor|
  00098	e3560000	 cmp         r6, #0
  0009c	1a000009	 bne         |$LN7@WaitForPor|
  000a0	e59500c8	 ldr         r0, [r5, #0xC8]
  000a4	e59510bc	 ldr         r1, [r5, #0xBC]
  000a8	e5903000	 ldr         r3, [r0]
  000ac	e5933044	 ldr         r3, [r3, #0x44]
  000b0	e1a0e00f	 mov         lr, pc
  000b4	e12fff13	 bx          r3
  000b8	e3500000	 cmp         r0, #0

; 2912 :             // If HCD does not support Root Hub Status Change. We do follows
; 2913 :             WaitForSingleObject( m_hHubStatusChangeEvent, 100 );

  000bc	059500bc	 ldreq       r0, [r5, #0xBC]
  000c0	03a01064	 moveq       r1, #0x64
  000c4	0b000000	 bleq        WaitForSingleObject
  000c8		 |$LN7@WaitForPor|

; 2914 :         }
; 2915 :         if ((m_pCHcd->GetCapability() & HCD_SUSPEND_ON_REQUEST)!=0) {

  000c8	e59500c8	 ldr         r0, [r5, #0xC8]
  000cc	e5903000	 ldr         r3, [r0]
  000d0	e593304c	 ldr         r3, [r3, #0x4C]
  000d4	e1a0e00f	 mov         lr, pc
  000d8	e12fff13	 bx          r3
  000dc	e3100004	 tst         r0, #4
  000e0	1a000002	 bne         |$LN19@WaitForPor|
  000e4	e59530b8	 ldr         r3, [r5, #0xB8]
  000e8	e3530000	 cmp         r3, #0
  000ec	0affffcb	 beq         |$LL13@WaitForPor|
  000f0		 |$LN19@WaitForPor|

; 2916 :             break;
; 2917 :         }
; 2918 :     }
; 2919 :     if (fSuccess) {

  000f0	e3560000	 cmp         r6, #0
  000f4	0a000015	 beq         |$LN2@WaitForPor|
  000f8		 |$LN22@WaitForPor|

; 2920 :         // acknowledge the change bits
; 2921 :         for (USHORT bit = 0; bit < 16; ++bit) {

  000f8	e3a02000	 mov         r2, #0
  000fc	e3a07000	 mov         r7, #0
  00100	e3a0a001	 mov         r10, #1
  00104		 |$LL4@WaitForPor|

; 2922 :             if (rStatus.change.word & (1 << bit))

  00104	e1d830b2	 ldrh        r3, [r8, #2]
  00108	e113021a	 tst         r3, r10, lsl r2
  0010c	0a000009	 beq         |$LN3@WaitForPor|

; 2923 :                 SetOrClearFeature( rPort, USB_REQUEST_CLEAR_FEATURE, bit | 0x10 );

  00110	e5952000	 ldr         r2, [r5]
  00114	e3873010	 orr         r3, r7, #0x10
  00118	e5d91000	 ldrb        r1, [r9]
  0011c	e5924048	 ldr         r4, [r2, #0x48]
  00120	e1a03803	 mov         r3, r3, lsl #16
  00124	e3a02001	 mov         r2, #1
  00128	e1a03823	 mov         r3, r3, lsr #16
  0012c	e1a00005	 mov         r0, r5
  00130	e1a0e00f	 mov         lr, pc
  00134	e12fff14	 bx          r4
  00138		 |$LN3@WaitForPor|
  00138	e2873001	 add         r3, r7, #1
  0013c	e1a02803	 mov         r2, r3, lsl #16
  00140	e1a02822	 mov         r2, r2, lsr #16
  00144	e1a07002	 mov         r7, r2
  00148	e3520010	 cmp         r2, #0x10
  0014c	3affffec	 bcc         |$LL4@WaitForPor|
  00150		 |$LN2@WaitForPor|

; 2924 :         }
; 2925 :     }
; 2926 : 
; 2927 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("-CRootHub::WaitForPortStatusChange, rPort = %d, fSuccess = %d\n"), rPort, fSuccess) );
; 2928 :     return fSuccess;
; 2929 : }

  00150	e1a00006	 mov         r0, r6
  00154	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00158	e12fff1e	 bx          lr
  0015c		 |$M36899|

			 ENDP  ; |?WaitForPortStatusChange@CRootHub@@EAAHAAEAAU_USB_HUB_AND_PORT_STATUS@@@Z|, CRootHub::WaitForPortStatusChange

	EXPORT	|?GetStatus@CRootHub@@EAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z| ; CRootHub::GetStatus

  00000			 AREA	 |.pdata|, PDATA
|$T36913| DCD	|$LN5@GetStatus|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetStatus@CRootHub@@EAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z| PROC ; CRootHub::GetStatus

; 2946 : {

  00000		 |$LN5@GetStatus|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36910|

; 2947 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CRootHub::GetStatus - port = %d\n"), port ));
; 2948 : 
; 2949 :     DEBUGCHK( port <= m_usbHubDescriptor.bNumberOfPorts );
; 2950 : 
; 2951 :     // CHW::GetPortStatus will not clear the change bits
; 2952 :     BOOL fSuccess = m_pCHcd->GetPortStatus( port, rStatus );

  00004	e59000c8	 ldr         r0, [r0, #0xC8]

; 2953 : 
; 2954 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CRootHub::GetStatus - port = %d, returing BOOL %d\n"), port, fSuccess ) );
; 2955 :     return fSuccess;

  00008	e5903000	 ldr         r3, [r0]
  0000c	e5933034	 ldr         r3, [r3, #0x34]
  00010	e1a0e00f	 mov         lr, pc
  00014	e12fff13	 bx          r3

; 2956 : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$M36911|

			 ENDP  ; |?GetStatus@CRootHub@@EAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z|, CRootHub::GetStatus

	EXPORT	|?ResetAndEnablePort@CRootHub@@EAAHE@Z|	; CRootHub::ResetAndEnablePort

  00000			 AREA	 |.pdata|, PDATA
|$T36924| DCD	|$LN5@ResetAndEn|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResetAndEnablePort@CRootHub@@EAAHE@Z| PROC ; CRootHub::ResetAndEnablePort

; 2970 : {

  00000		 |$LN5@ResetAndEn|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36921|

; 2971 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("+CRootHub::ResetAndEnablePort - port = %d\n"), port) );
; 2972 : 
; 2973 :     DEBUGCHK( port >= 1 && port <= m_usbHubDescriptor.bNumberOfPorts );
; 2974 : 
; 2975 :     BOOL fSuccess = m_pCHcd->ResetAndEnablePort( port );

  00004	e59000c8	 ldr         r0, [r0, #0xC8]

; 2976 : 
; 2977 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("-CRootHub::ResetAndEnablePort - port = %d, returning %d\n"), port, fSuccess ) );
; 2978 :     return fSuccess;

  00008	e5903000	 ldr         r3, [r0]
  0000c	e593303c	 ldr         r3, [r3, #0x3C]
  00010	e1a0e00f	 mov         lr, pc
  00014	e12fff13	 bx          r3

; 2979 : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$M36922|

			 ENDP  ; |?ResetAndEnablePort@CRootHub@@EAAHE@Z|, CRootHub::ResetAndEnablePort

	EXPORT	|?DisablePort@CRootHub@@EAAXE@Z|	; CRootHub::DisablePort

  00000			 AREA	 |.pdata|, PDATA
|$T36933| DCD	|$LN5@DisablePor|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DisablePort@CRootHub@@EAAXE@Z| PROC	; CRootHub::DisablePort

; 2992 : {

  00000		 |$LN5@DisablePor|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36930|

; 2993 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("+CRootHub::DisablePort - port = %d\n"), port) );
; 2994 : 
; 2995 :     DEBUGCHK( port >= 1 && port <= m_usbHubDescriptor.bNumberOfPorts );
; 2996 : 
; 2997 :     m_pCHcd->DisablePort( port );

  00004	e59000c8	 ldr         r0, [r0, #0xC8]
  00008	e5903000	 ldr         r3, [r0]
  0000c	e5933040	 ldr         r3, [r3, #0x40]
  00010	e1a0e00f	 mov         lr, pc
  00014	e12fff13	 bx          r3

; 2998 : 
; 2999 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("-CRootHub::DisablePort - port = %d\n"), port) );
; 3000 : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$M36931|

			 ENDP  ; |?DisablePort@CRootHub@@EAAXE@Z|, CRootHub::DisablePort

	EXPORT	|?SetOrClearFeature@CRootHub@@EAAHGEG@Z| ; CRootHub::SetOrClearFeature

  00000			 AREA	 |.pdata|, PDATA
|$T36946| DCD	|$LN5@SetOrClear|
	DCD	0x40000901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetOrClearFeature@CRootHub@@EAAHGEG@Z| PROC ; CRootHub::SetOrClearFeature

; 3023 : {

  00000		 |$LN5@SetOrClear|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M36943|

; 3024 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CRootHub::SetOrClearFeature - port = %d, set/clear = 0x%x, feature = 0x%x\n"), port, setOrClearFeature, feature) );
; 3025 : 
; 3026 : #ifdef DEBUG
; 3027 : {
; 3028 :     if ( setOrClearFeature == USB_REQUEST_CLEAR_FEATURE ) {
; 3029 :         if ( port == 0 ) {
; 3030 :             // USB spec 1.1, 11.16.2.2 - these are the only
; 3031 :             // features which should be cleared for ports
; 3032 :             DEBUGCHK( feature == USB_HUB_FEATURE_C_HUB_LOCAL_POWER ||
; 3033 :                       feature == USB_HUB_FEATURE_C_HUB_OVER_CURRENT ||
; 3034 :                       feature == USB_FEATURE_ENDPOINT_STALL );
; 3035 :         } else {
; 3036 :             // USB spec 1.1, 11.16.2.2 - these are the only
; 3037 :             // features which should be cleared for ports
; 3038 :             DEBUGCHK( feature == USB_HUB_FEATURE_PORT_ENABLE ||
; 3039 :                       feature == USB_HUB_FEATURE_PORT_SUSPEND ||
; 3040 :                       feature == USB_HUB_FEATURE_PORT_POWER ||
; 3041 :                       feature == USB_HUB_FEATURE_C_PORT_CONNECTION ||
; 3042 :                       feature == USB_HUB_FEATURE_C_PORT_RESET ||
; 3043 :                       feature == USB_HUB_FEATURE_C_PORT_ENABLE ||
; 3044 :                       feature == USB_HUB_FEATURE_C_PORT_SUSPEND ||
; 3045 :                       feature == USB_HUB_FEATURE_C_PORT_OVER_CURRENT );
; 3046 :         }
; 3047 :     } else if ( setOrClearFeature == USB_REQUEST_SET_FEATURE ) {
; 3048 :         // should only be setting port features
; 3049 :         DEBUGCHK( port > 0 &&
; 3050 :                   (feature == USB_HUB_FEATURE_PORT_RESET ||
; 3051 :                    feature == USB_HUB_FEATURE_PORT_SUSPEND ||
; 3052 :                    feature == USB_HUB_FEATURE_PORT_INDICATOR ||
; 3053 :                    feature == USB_HUB_FEATURE_PORT_POWER) );
; 3054 :     } else {
; 3055 :         // shouldn't be here
; 3056 :         DebugBreak();
; 3057 :     }
; 3058 :     DEBUGCHK( port <= m_usbHubDescriptor.bNumberOfPorts );
; 3059 : }
; 3060 : #endif // DEBUG
; 3061 : 
; 3062 :     BOOL fSuccess = m_pCHcd->RootHubFeature((UCHAR)port, setOrClearFeature, feature);

  00004	e59000c8	 ldr         r0, [r0, #0xC8]

; 3063 : 
; 3064 :     DEBUGMSG( ZONE_ERROR && !fSuccess, (TEXT("CRootHub::SetOrClearFeature - port = %d, set/clear = 0x%x, feature = 0x%x, FAILED\n"), port, setOrClearFeature, feature ) );
; 3065 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CRootHub::SetOrClearFeature - port = %d, set/clear = 0x%x, feature = 0x%x, returing BOOL %d\n"), port, setOrClearFeature, feature, fSuccess) );
; 3066 :     return fSuccess;

  00008	e20110ff	 and         r1, r1, #0xFF
  0000c	e590e000	 ldr         lr, [r0]
  00010	e59e4038	 ldr         r4, [lr, #0x38]
  00014	e1a0e00f	 mov         lr, pc
  00018	e12fff14	 bx          r4

; 3067 : }

  0001c	e8bd4010	 ldmia       sp!, {r4, lr}
  00020	e12fff1e	 bx          lr
  00024		 |$M36944|

			 ENDP  ; |?SetOrClearFeature@CRootHub@@EAAHGEG@Z|, CRootHub::SetOrClearFeature

	EXPORT	|?SetOrClearRemoteWakup@CRootHub@@EAAHH@Z| ; CRootHub::SetOrClearRemoteWakup

  00000			 AREA	 |.pdata|, PDATA
|$T36955| DCD	|$LN5@SetOrClear@2|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetOrClearRemoteWakup@CRootHub@@EAAHH@Z| PROC ; CRootHub::SetOrClearRemoteWakup

; 3079 : {

  00000		 |$LN5@SetOrClear@2|
  00000		 |$M36952|

; 3080 :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 3081 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M36953|

			 ENDP  ; |?SetOrClearRemoteWakup@CRootHub@@EAAHH@Z|, CRootHub::SetOrClearRemoteWakup

	EXPORT	|?PowerAllHubPorts@CExternalHub@@EAAHXZ| ; CExternalHub::PowerAllHubPorts

  00000			 AREA	 |.pdata|, PDATA
|$T36973| DCD	|$LN15@PowerAllHu@2|
	DCD	0x40002501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PowerAllHubPorts@CExternalHub@@EAAHXZ| PROC ; CExternalHub::PowerAllHubPorts

; 3243 : {

  00000		 |$LN15@PowerAllHu@2|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M36970|
  00004	e1a07000	 mov         r7, r0

; 3244 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("+CExternalHub::PowerAllHubPorts\n")) );
; 3245 : 
; 3246 :     BOOL fFailed = FALSE;

  00008	e3a05000	 mov         r5, #0

; 3247 : 
; 3248 :     for ( UCHAR port = 1; !fFailed && port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  0000c	e3a06001	 mov         r6, #1
  00010		 |$LL4@PowerAllHu@2|
  00010	e5d7306a	 ldrb        r3, [r7, #0x6A]
  00014	e1560003	 cmp         r6, r3
  00018	8a000017	 bhi         |$LN2@PowerAllHu@2|

; 3249 :         fFailed = !SetOrClearFeature( port,
; 3250 :                                       USB_REQUEST_SET_FEATURE,
; 3251 :                                       USB_HUB_FEATURE_PORT_POWER );

  0001c	e5971000	 ldr         r1, [r7]
  00020	e3a03008	 mov         r3, #8
  00024	e3a02003	 mov         r2, #3
  00028	e5914048	 ldr         r4, [r1, #0x48]
  0002c	e1a01006	 mov         r1, r6
  00030	e1a00007	 mov         r0, r7
  00034	e1a0e00f	 mov         lr, pc
  00038	e12fff14	 bx          r4
  0003c	e3500000	 cmp         r0, #0
  00040	03a05001	 moveq       r5, #1
  00044	0a000008	 beq         |$LN3@PowerAllHu@2|

; 3252 :         if (!fFailed)
; 3253 :             SetOrClearFeature(port,
; 3254 :                                       USB_REQUEST_SET_FEATURE,
; 3255 :                                       USB_HUB_FEATURE_PORT_INDICATOR); // Set to the Auto Indicator.

  00048	e5971000	 ldr         r1, [r7]
  0004c	e3a03016	 mov         r3, #0x16
  00050	e3a02003	 mov         r2, #3
  00054	e5914048	 ldr         r4, [r1, #0x48]
  00058	e1a01006	 mov         r1, r6
  0005c	e1a00007	 mov         r0, r7
  00060	e3a05000	 mov         r5, #0
  00064	e1a0e00f	 mov         lr, pc
  00068	e12fff14	 bx          r4
  0006c		 |$LN3@PowerAllHu@2|
  0006c	e2863001	 add         r3, r6, #1
  00070	e20360ff	 and         r6, r3, #0xFF
  00074	e3550000	 cmp         r5, #0
  00078	0affffe4	 beq         |$LL4@PowerAllHu@2|
  0007c		 |$LN2@PowerAllHu@2|

; 3256 :     }
; 3257 : 
; 3258 :     DEBUGMSG( ZONE_ERROR && fFailed, (TEXT("CExternalHub::PowerAllHubPorts - failed!\n")) );
; 3259 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("-CExternalHub::PowerAllHubPorts, returing %d\n"), !fFailed) );
; 3260 :     return !fFailed;

  0007c	e3550000	 cmp         r5, #0
  00080	03a00001	 moveq       r0, #1

; 3261 : }

  00084	08bd40f0	 ldmeqia     sp!, {r4 - r7, lr}

; 3256 :     }
; 3257 : 
; 3258 :     DEBUGMSG( ZONE_ERROR && fFailed, (TEXT("CExternalHub::PowerAllHubPorts - failed!\n")) );
; 3259 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("-CExternalHub::PowerAllHubPorts, returing %d\n"), !fFailed) );
; 3260 :     return !fFailed;

  00088	13a00000	 movne       r0, #0

; 3261 : }

  0008c	18bd40f0	 ldmneia     sp!, {r4 - r7, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$M36971|

			 ENDP  ; |?PowerAllHubPorts@CExternalHub@@EAAHXZ|, CExternalHub::PowerAllHubPorts

	EXPORT	|?GetStatusChangeBitmap@CExternalHub@@AAAHAAK@Z| ; CExternalHub::GetStatusChangeBitmap
; File c:\wince600\osdesigns\z2170p\z2170p\wince600\z2170p_armv4i\cesysgen\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T36999| DCD	|$LN19@GetStatusC|
	DCD	0x40006402
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetStatusChangeBitmap@CExternalHub@@AAAHAAK@Z| PROC ; CExternalHub::GetStatusChangeBitmap

; 3276 : {

  00000		 |$LN19@GetStatusC|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd044	 sub         sp, sp, #0x44
  00008		 |$M36996|
  00008	e1a09001	 mov         r9, r1
  0000c	e1a08000	 mov         r8, r0

; 3277 : #define HUB_INTERRUPT_TRANFER_TIMEOUT (10*1000)
; 3278 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("+CExternalHub::GetStatusChangeBitmap\n")) );
; 3279 : 
; 3280 :     // for 1-7 ports,  the bitmap will be 1 byte,
; 3281 :     // for 8-15 ports, the bitmap will be 2 bytes,
; 3282 :     // etc. We only support up to 31 ports since
; 3283 :     // DWORD is 4 bytes.
; 3284 :     DEBUGCHK( m_usbHubDescriptor.bNumberOfPorts <= 31 );
; 3285 :     const DWORD         dwBitmapSize = 1 + (m_usbHubDescriptor.bNumberOfPorts >> 3);

  00010	e5d8306a	 ldrb        r3, [r8, #0x6A]

; 3286 :     BOOL                fSuccess = FALSE;
; 3287 :     BOOL                fTransferDone = FALSE;
; 3288 :     DWORD               dwBytesTransferred = 0;
; 3289 :     DWORD               dwErrorFlags = USB_NOT_COMPLETE_ERROR;
; 3290 :     HCD_REQUEST_STATUS  status = requestFailed;
; 3291 : 
; 3292 :     rdwHubBitmap = 0;

  00014	e3a02000	 mov         r2, #0
  00018	e5892000	 str         r2, [r9]

; 3293 : 
; 3294 :     // pipe 1 = status change endpoint pipe
; 3295 :     if ( !m_fHubThreadClosing) {

  0001c	e598e0b8	 ldr         lr, [r8, #0xB8]
  00020	e3a02c01	 mov         r2, #1, 24
  00024	e3822003	 orr         r2, r2, #3
  00028	e1a031a3	 mov         r3, r3, lsr #3
  0002c	e3a01000	 mov         r1, #0
  00030	e3a00000	 mov         r0, #0
  00034	e35e0000	 cmp         lr, #0
  00038	e58d2040	 str         r2, [sp, #0x40]
  0003c	e283a001	 add         r10, r3, #1
  00040	e58d1038	 str         r1, [sp, #0x38]
  00044	e58d003c	 str         r0, [sp, #0x3C]
  00048	1a00004b	 bne         |$LN11@GetStatusC|

; 3296 :         DEBUGCHK( m_maxNumPipes == 2 );
; 3297 :         PREFAST_DEBUGCHK( m_ppCPipe != NULL );
; 3298 :         PREFAST_DEBUGCHK( m_ppCPipe[ STATUS_CHANGE_INTERRUPT_PIPE ] != NULL );
; 3299 : 
; 3300 :         status = m_ppCPipe[ STATUS_CHANGE_INTERRUPT_PIPE ]->IssueTransfer(
; 3301 :                                     m_address, // hub address,
; 3302 :                                     TransferDoneCallbackSetEvent, // callback func
; 3303 :                                     m_hHubStatusChangeEvent, // callback param
; 3304 :                                     USB_IN_TRANSFER | USB_SEND_TO_DEVICE, // transfer flags
; 3305 :                                     NULL, // lpvControlHeader (not used)
; 3306 :                                     0, // dwStartingFrame (not used)
; 3307 :                                     0, // dwFrames (not used)
; 3308 :                                     NULL, // aLengths (not used)
; 3309 :                                     dwBitmapSize, // bitmap size to read
; 3310 :                                     &rdwHubBitmap, // data buffer
; 3311 :                                     0, // physical address of buffer (not used)
; 3312 :                                     this, // cancel id
; 3313 :                                     NULL, // adwIsochErrors (not used)
; 3314 :                                     NULL, // adwIsochLengths (not used)
; 3315 :                                     &fTransferDone, // OUT status param
; 3316 :                                     &dwBytesTransferred, // OUT status param
; 3317 :                                     &dwErrorFlags ); // OUT status param

  0004c	e598e05c	 ldr         lr, [r8, #0x5C]
  00050	e28d403c	 add         r4, sp, #0x3C
  00054	e58d4030	 str         r4, [sp, #0x30]
  00058	e59e0004	 ldr         r0, [lr, #4]
  0005c	e59830bc	 ldr         r3, [r8, #0xBC]
  00060	e59f2124	 ldr         r2, [pc, #0x124]
  00064	e590e000	 ldr         lr, [r0]
  00068	e5d81020	 ldrb        r1, [r8, #0x20]
  0006c	e28d6040	 add         r6, sp, #0x40
  00070	e59e700c	 ldr         r7, [lr, #0xC]
  00074	e28d5038	 add         r5, sp, #0x38
  00078	e3a0bd42	 mov         r11, #0x42, 26
  0007c	e3a04000	 mov         r4, #0
  00080	e58d6034	 str         r6, [sp, #0x34]
  00084	e58d502c	 str         r5, [sp, #0x2C]
  00088	e58d4028	 str         r4, [sp, #0x28]
  0008c	e58d4024	 str         r4, [sp, #0x24]
  00090	e58d8020	 str         r8, [sp, #0x20]
  00094	e58d401c	 str         r4, [sp, #0x1C]
  00098	e58d9018	 str         r9, [sp, #0x18]
  0009c	e58da014	 str         r10, [sp, #0x14]
  000a0	e58d4010	 str         r4, [sp, #0x10]
  000a4	e58d400c	 str         r4, [sp, #0xC]
  000a8	e58d4008	 str         r4, [sp, #8]
  000ac	e58d4004	 str         r4, [sp, #4]
  000b0	e58db000	 str         r11, [sp]
  000b4	e1a0e00f	 mov         lr, pc
  000b8	e12fff17	 bx          r7

; 3318 :         DEBUGMSG( ZONE_ERROR && status != requestOK, (TEXT("CExternalHub::GetStatusChangeBitmap - error issuing transfer!\n")));
; 3319 :         if ( status == requestOK ) {

  000bc	e3500001	 cmp         r0, #1
  000c0	1a00002d	 bne         |$LN11@GetStatusC|

; 3320 :             DWORD dwReturn = WaitForSingleObject( m_hHubStatusChangeEvent, 
; 3321 :                     ((m_pCHcd->GetCapability() & HCD_SUSPEND_ON_REQUEST)!=0)? HUB_INTERRUPT_TRANFER_TIMEOUT : INFINITE );

  000c4	e59800c8	 ldr         r0, [r8, #0xC8]
  000c8	e5903000	 ldr         r3, [r0]
  000cc	e593304c	 ldr         r3, [r3, #0x4C]
  000d0	e1a0e00f	 mov         lr, pc
  000d4	e12fff13	 bx          r3
  000d8	e3100004	 tst         r0, #4
  000dc	e59800bc	 ldr         r0, [r8, #0xBC]
  000e0	13a03c27	 movne       r3, #0x27, 24
  000e4	13831010	 orrne       r1, r3, #0x10
  000e8	03e01000	 mvneq       r1, #0
  000ec	eb000000	 bl          WaitForSingleObject

; 3322 :             if (!fTransferDone || dwReturn!= WAIT_OBJECT_0) {

  000f0	e59d3038	 ldr         r3, [sp, #0x38]
  000f4	e3530000	 cmp         r3, #0
  000f8	0a000001	 beq         |$LN3@GetStatusC|
  000fc	e3500000	 cmp         r0, #0
  00100	0a000011	 beq         |$LN13@GetStatusC|
  00104		 |$LN3@GetStatusC|

; 3323 :                 m_ppCPipe[ STATUS_CHANGE_INTERRUPT_PIPE ]->AbortTransfer(
; 3324 :                                                NULL, // callback function
; 3325 :                                                NULL, // callback parameter
; 3326 :                                                this ); // cancel ID

  00104	e598105c	 ldr         r1, [r8, #0x5C]
  00108	e1a03008	 mov         r3, r8
  0010c	e3a02000	 mov         r2, #0
  00110	e5910004	 ldr         r0, [r1, #4]
  00114	e3a01000	 mov         r1, #0
  00118	e5904000	 ldr         r4, [r0]
  0011c	e5944010	 ldr         r4, [r4, #0x10]
  00120	e1a0e00f	 mov         lr, pc
  00124	e12fff14	 bx          r4

; 3327 :                 // After Abort the has been called. So reset the event.
; 3328 :                 if (!m_fHubThreadClosing && m_hHubStatusChangeEvent)

  00128	e59830b8	 ldr         r3, [r8, #0xB8]
  0012c	e3530000	 cmp         r3, #0
  00130	1a000004	 bne         |$LN16@GetStatusC|
  00134	e59830bc	 ldr         r3, [r8, #0xBC]
  00138	e3530000	 cmp         r3, #0

; 3329 :                     ResetEvent( m_hHubStatusChangeEvent );

  0013c	13a01002	 movne       r1, #2
  00140	11a00003	 movne       r0, r3
  00144	1b000000	 blne        EventModify
  00148		 |$LN16@GetStatusC|
  00148	e59d3038	 ldr         r3, [sp, #0x38]
  0014c		 |$LN13@GetStatusC|

; 3330 :             }
; 3331 :             else
; 3332 :                 DEBUGCHK( fTransferDone );
; 3333 :         }
; 3334 :     }
; 3335 :     fSuccess = ( status == requestOK &&
; 3336 :                  fTransferDone &&
; 3337 :                  dwBytesTransferred == dwBitmapSize &&
; 3338 :                  dwErrorFlags == USB_NO_ERROR &&
; 3339 :                  rdwHubBitmap != 0 );

  0014c	e3530000	 cmp         r3, #0
  00150	0a000009	 beq         |$LN11@GetStatusC|
  00154	e59d303c	 ldr         r3, [sp, #0x3C]
  00158	e153000a	 cmp         r3, r10
  0015c	1a000006	 bne         |$LN11@GetStatusC|
  00160	e59d3040	 ldr         r3, [sp, #0x40]
  00164	e3530000	 cmp         r3, #0
  00168	1a000003	 bne         |$LN11@GetStatusC|
  0016c	e5993000	 ldr         r3, [r9]
  00170	e3530000	 cmp         r3, #0
  00174	13a00001	 movne       r0, #1
  00178	1a000000	 bne         |$LN12@GetStatusC|
  0017c		 |$LN11@GetStatusC|
  0017c	e3a00000	 mov         r0, #0
  00180		 |$LN12@GetStatusC|

; 3340 : 
; 3341 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("-CExternal::GetStatusChangeBitmap, bitmap = 0x%08x, returing fSuccess = %d\n"), rdwHubBitmap, fSuccess) );
; 3342 :     return fSuccess;
; 3343 : }

  00180	e28dd044	 add         sp, sp, #0x44
  00184	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00188	e12fff1e	 bx          lr
  0018c		 |$LN20@GetStatusC|
  0018c		 |$LN21@GetStatusC|
  0018c	00000000	 DCD         |?TransferDoneCallbackSetEvent@CDevice@@KAKPAX@Z|
  00190		 |$M36997|

			 ENDP  ; |?GetStatusChangeBitmap@CExternalHub@@AAAHAAK@Z|, CExternalHub::GetStatusChangeBitmap

	EXPORT	|?WaitForPortStatusChange@CExternalHub@@EAAHAAEAAU_USB_HUB_AND_PORT_STATUS@@@Z| ; CExternalHub::WaitForPortStatusChange

  00000			 AREA	 |.pdata|, PDATA
|$T37024| DCD	|$LN24@WaitForPor@2|
	DCD	0x40004a02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?WaitForPortStatusChange@CExternalHub@@EAAHAAEAAU_USB_HUB_AND_PORT_STATUS@@@Z| PROC ; CExternalHub::WaitForPortStatusChange

; 3361 : {

  00000		 |$LN24@WaitForPor@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M37021|
  00008	e1a0a002	 mov         r10, r2
  0000c	e1a05001	 mov         r5, r1
  00010	e1a06000	 mov         r6, r0

; 3362 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("+CExternalHub::WaitForPortStatusChange\n")) );
; 3363 : 
; 3364 :     DWORD dwStatusChangeBitmap = 0;

  00014	e3a03000	 mov         r3, #0

; 3365 :     BOOL  fSuccess = FALSE;
; 3366 : 
; 3367 :     if ( GetStatusChangeBitmap( dwStatusChangeBitmap ) ) {

  00018	e28d1000	 add         r1, sp, #0
  0001c	e58d3000	 str         r3, [sp]
  00020	e3a04000	 mov         r4, #0
  00024	eb000000	 bl          |?GetStatusChangeBitmap@CExternalHub@@AAAHAAK@Z|
  00028	e3500000	 cmp         r0, #0
  0002c	0a000039	 beq         |$LN1@WaitForPor@2|

; 3368 :         DEBUGCHK( dwStatusChangeBitmap != 0 );
; 3369 :         // see which port changed
; 3370 :         for ( rPort = 0; rPort <= m_usbHubDescriptor.bNumberOfPorts; rPort++ ) {

  00030	e3a03000	 mov         r3, #0
  00034	e59d1000	 ldr         r1, [sp]
  00038	e5c53000	 strb        r3, [r5]
  0003c	e3a00001	 mov         r0, #1
  00040		 |$LL12@WaitForPor@2|

; 3371 :             if ( dwStatusChangeBitmap & (1 << rPort) ) {

  00040	e5d53000	 ldrb        r3, [r5]
  00044	e1110310	 tst         r1, r0, lsl r3
  00048	1a000005	 bne         |$LN18@WaitForPor@2|
  0004c	e2833001	 add         r3, r3, #1
  00050	e5c53000	 strb        r3, [r5]
  00054	e20320ff	 and         r2, r3, #0xFF
  00058	e5d6306a	 ldrb        r3, [r6, #0x6A]
  0005c	e1520003	 cmp         r2, r3
  00060	9afffff6	 bls         |$LL12@WaitForPor@2|
  00064		 |$LN18@WaitForPor@2|

; 3372 :                 // deal with this port change, and report others next time around
; 3373 :                 break;
; 3374 :             }
; 3375 :         }
; 3376 :         DEBUGCHK( rPort <= m_usbHubDescriptor.bNumberOfPorts );
; 3377 : //        if (m_fIsHighSpeed) { //USB2.0 11.24.2.7 This will cause Reset squence and get speed correctly.
; 3378 : //            BOOL bResult=SetOrClearFeature(rPort,USB_REQUEST_SET_FEATURE,USB_HUB_FEATURE_PORT_RESET);
; 3379 : //            ASSERT(bResult==TRUE);
; 3380 : //        }
; 3381 :         // now we need to get the actual status change
; 3382 :         if ( GetStatus( rPort, rStatus ) ) {

  00064	e5963000	 ldr         r3, [r6]
  00068	e5d51000	 ldrb        r1, [r5]
  0006c	e1a0200a	 mov         r2, r10
  00070	e5933050	 ldr         r3, [r3, #0x50]
  00074	e1a00006	 mov         r0, r6
  00078	e1a0e00f	 mov         lr, pc
  0007c	e12fff13	 bx          r3
  00080	e3500000	 cmp         r0, #0
  00084	0a000023	 beq         |$LN1@WaitForPor@2|

; 3383 :             // we need to clear each of the changed feature flags
; 3384 :             // otherwise we will get the change notification
; 3385 :             // forever.
; 3386 :             //
; 3387 :             // For ports, each changeBit corresponds to the change
; 3388 :             // feature "changeBit | 0x10". This happens due to the
; 3389 :             // way features are numbered.
; 3390 : 
; 3391 :             UCHAR maxChangeBit = USB_HUB_FEATURE_PORT_RESET;
; 3392 :             UCHAR changeBitToClearFeature = 0x10;
; 3393 :             if ( rPort == 0 ) { // change was on the hub itself

  00088	e5d53000	 ldrb        r3, [r5]
  0008c	e3a08004	 mov         r8, #4
  00090	e3a09010	 mov         r9, #0x10
  00094	e3530000	 cmp         r3, #0

; 3394 :                 // For hubs, each changeBit corresponds directly to
; 3395 :                 // the feature "changeBit", so we | with 0.
; 3396 :                 maxChangeBit = USB_HUB_FEATURE_C_HUB_OVER_CURRENT;
; 3397 :                 changeBitToClearFeature = 0;
; 3398 :             }
; 3399 :             for ( UCHAR changeBit = 0; !m_fHubThreadClosing && changeBit <= maxChangeBit; changeBit++ ) {

  00098	e59630b8	 ldr         r3, [r6, #0xB8]
  0009c	03a08001	 moveq       r8, #1
  000a0	03a09000	 moveq       r9, #0
  000a4	e3530000	 cmp         r3, #0
  000a8	e3a07000	 mov         r7, #0
  000ac	1a000014	 bne         |$LN21@WaitForPor@2|
  000b0	e3a0b001	 mov         r11, #1
  000b4		 |$LL6@WaitForPor@2|
  000b4	e1570008	 cmp         r7, r8
  000b8	8a000011	 bhi         |$LN21@WaitForPor@2|

; 3400 :                 if ( rStatus.change.word & (1 << changeBit) ) {

  000bc	e1da30b2	 ldrh        r3, [r10, #2]
  000c0	e113071b	 tst         r3, r11, lsl r7
  000c4	0a000009	 beq         |$LN5@WaitForPor@2|

; 3401 :                     SetOrClearFeature( rPort,
; 3402 :                                        USB_REQUEST_CLEAR_FEATURE,
; 3403 :                                        changeBit | changeBitToClearFeature );

  000c8	e5962000	 ldr         r2, [r6]
  000cc	e1893007	 orr         r3, r9, r7
  000d0	e5d51000	 ldrb        r1, [r5]
  000d4	e5924048	 ldr         r4, [r2, #0x48]
  000d8	e1a03803	 mov         r3, r3, lsl #16
  000dc	e3a02001	 mov         r2, #1
  000e0	e1a03823	 mov         r3, r3, lsr #16
  000e4	e1a00006	 mov         r0, r6
  000e8	e1a0e00f	 mov         lr, pc
  000ec	e12fff14	 bx          r4
  000f0		 |$LN5@WaitForPor@2|
  000f0	e59620b8	 ldr         r2, [r6, #0xB8]
  000f4	e2873001	 add         r3, r7, #1
  000f8	e20370ff	 and         r7, r3, #0xFF
  000fc	e3520000	 cmp         r2, #0
  00100	0affffeb	 beq         |$LL6@WaitForPor@2|
  00104		 |$LN21@WaitForPor@2|

; 3404 :                     // todo - what if this fails??
; 3405 :                 }
; 3406 :             }
; 3407 : 
; 3408 :             if(rPort > m_usbHubDescriptor.bNumberOfPorts)

  00104	e5d52000	 ldrb        r2, [r5]
  00108	e5d6306a	 ldrb        r3, [r6, #0x6A]
  0010c	e1520003	 cmp         r2, r3

; 3409 :                 fSuccess = FALSE; //Otherwise an access violation will occur.

  00110	83a04000	 movhi       r4, #0

; 3410 :             else
; 3411 :                 fSuccess = TRUE;

  00114	93a04001	 movls       r4, #1
  00118		 |$LN1@WaitForPor@2|

; 3412 :         }
; 3413 :     }
; 3414 : 
; 3415 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("-CExternal::WaitForPortStatusChange, returing rPort = %d, fSuccess = %d\n"), rPort, fSuccess) );
; 3416 :     return fSuccess;
; 3417 : }

  00118	e1a00004	 mov         r0, r4
  0011c	e28dd004	 add         sp, sp, #4
  00120	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00124	e12fff1e	 bx          lr
  00128		 |$M37022|

			 ENDP  ; |?WaitForPortStatusChange@CExternalHub@@EAAHAAEAAU_USB_HUB_AND_PORT_STATUS@@@Z|, CExternalHub::WaitForPortStatusChange

	EXPORT	|?GetStatus@CExternalHub@@EAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z| ; CExternalHub::GetStatus

  00000			 AREA	 |.pdata|, PDATA
|$T37042| DCD	|$LN14@GetStatus@2|
	DCD	0x40005602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetStatus@CExternalHub@@EAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z| PROC ; CExternalHub::GetStatus

; 3434 : {

  00000		 |$LN14@GetStatus@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd04c	 sub         sp, sp, #0x4C
  00008		 |$M37039|
  00008	e1a0a002	 mov         r10, r2
  0000c	e3510000	 cmp         r1, #0
  00010	e1a09000	 mov         r9, r0
  00014	e3a03c01	 mov         r3, #1, 24

; 3435 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CExternalHub::GetStatus - port = %d\n"), port ));
; 3436 : 
; 3437 :     PREFAST_DEBUGCHK( m_ppCPipe != NULL);
; 3438 :     DEBUGCHK( m_maxNumPipes == 2 &&
; 3439 :               m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ] != NULL &&
; 3440 :               port <= m_usbHubDescriptor.bNumberOfPorts );
; 3441 : 
; 3442 :     BOOL                fTransferDone = FALSE;
; 3443 :     DWORD               dwBytesTransferred = 0;
; 3444 :     DWORD               dwErrorFlags = USB_NOT_COMPLETE_ERROR;

  00018	e3833003	 orr         r3, r3, #3
  0001c	e58d3040	 str         r3, [sp, #0x40]

; 3445 :     HCD_REQUEST_STATUS  status = requestFailed;
; 3446 :     USB_DEVICE_REQUEST  usbRequest;
; 3447 : 
; 3448 :     if ( port == 0 ) {
; 3449 :         // requst is to the hub iteself
; 3450 :         usbRequest.bmRequestType = USB_REQUEST_DEVICE_TO_HOST | USB_REQUEST_CLASS | USB_REQUEST_FOR_DEVICE;

  00020	03a030a0	 moveq       r3, #0xA0

; 3451 :     } else {
; 3452 :         // request is to an actual port
; 3453 :         usbRequest.bmRequestType = USB_REQUEST_DEVICE_TO_HOST | USB_REQUEST_CLASS | USB_REQUEST_FOR_OTHER;

  00024	13a030a3	 movne       r3, #0xA3
  00028	e5cd3044	 strb        r3, [sp, #0x44]

; 3454 :     }
; 3455 :     usbRequest.bRequest = USB_REQUEST_GET_STATUS;
; 3456 :     usbRequest.wValue = 0;
; 3457 :     usbRequest.wIndex = port;
; 3458 :     usbRequest.wLength = sizeof( USB_HUB_AND_PORT_STATUS );
; 3459 :     // wLength should be 4, according to USB spec 1.1 11.16.2.5/11.16.2.6
; 3460 :     DEBUGCHK( sizeof( USB_HUB_AND_PORT_STATUS ) == 4 );
; 3461 : 
; 3462 :     if ( !m_fHubThreadClosing ) {

  0002c	e59930b8	 ldr         r3, [r9, #0xB8]
  00030	e3a02000	 mov         r2, #0
  00034	e3a00000	 mov         r0, #0
  00038	e58d2038	 str         r2, [sp, #0x38]
  0003c	e58d003c	 str         r0, [sp, #0x3C]
  00040	e3a02000	 mov         r2, #0
  00044	e3a00000	 mov         r0, #0
  00048	e3a0e004	 mov         lr, #4
  0004c	e3530000	 cmp         r3, #0
  00050	e5cd2045	 strb        r2, [sp, #0x45]
  00054	e1cd04b6	 strh        r0, [sp, #0x46]
  00058	e1cd14b8	 strh        r1, [sp, #0x48]
  0005c	e1cde4ba	 strh        lr, [sp, #0x4A]
  00060	1a000037	 bne         |$LN8@GetStatus@2|

; 3463 :         status = m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ]->IssueTransfer(
; 3464 :                          m_address, // address of this hub
; 3465 :                          TransferDoneCallbackSetEvent, // callback func
; 3466 :                          m_hHubStatusChangeEvent, // callback param
; 3467 :                          USB_IN_TRANSFER | USB_SEND_TO_DEVICE, // transfer flags
; 3468 :                          &usbRequest, // control request
; 3469 :                          0, // dwStartingFrame (not used)
; 3470 :                          0, // dwFrames (not used)
; 3471 :                          NULL, // aLengths (not used)
; 3472 :                          sizeof( USB_HUB_AND_PORT_STATUS ), // buffer size
; 3473 :                          &rStatus, // buffer
; 3474 :                          0, // phys addr of buffer (not used)
; 3475 :                          this, // cancel id
; 3476 :                          NULL, // adwIsochErrors (not used)
; 3477 :                          NULL, // adwIsochLengths (not used)
; 3478 :                          &fTransferDone, // OUT param for transfer
; 3479 :                          &dwBytesTransferred, // OUT param for transfer
; 3480 :                          &dwErrorFlags ); // OUT param for transfer

  00064	e599105c	 ldr         r1, [r9, #0x5C]
  00068	e28d403c	 add         r4, sp, #0x3C
  0006c	e58d4030	 str         r4, [sp, #0x30]
  00070	e5910000	 ldr         r0, [r1]
  00074	e3a04000	 mov         r4, #0
  00078	e58d4028	 str         r4, [sp, #0x28]
  0007c	e590e000	 ldr         lr, [r0]
  00080	e58d4024	 str         r4, [sp, #0x24]
  00084	e58d401c	 str         r4, [sp, #0x1C]
  00088	e58d4010	 str         r4, [sp, #0x10]
  0008c	e58d400c	 str         r4, [sp, #0xC]
  00090	e58d4008	 str         r4, [sp, #8]
  00094	e59e800c	 ldr         r8, [lr, #0xC]
  00098	e59930bc	 ldr         r3, [r9, #0xBC]
  0009c	e59f20b0	 ldr         r2, [pc, #0xB0]
  000a0	e5d91020	 ldrb        r1, [r9, #0x20]
  000a4	e28d6040	 add         r6, sp, #0x40
  000a8	e28d5038	 add         r5, sp, #0x38
  000ac	e3a0b004	 mov         r11, #4
  000b0	e28d7044	 add         r7, sp, #0x44
  000b4	e3a04d42	 mov         r4, #0x42, 26
  000b8	e58d6034	 str         r6, [sp, #0x34]
  000bc	e58d502c	 str         r5, [sp, #0x2C]
  000c0	e58d9020	 str         r9, [sp, #0x20]
  000c4	e58da018	 str         r10, [sp, #0x18]
  000c8	e58db014	 str         r11, [sp, #0x14]
  000cc	e58d7004	 str         r7, [sp, #4]
  000d0	e58d4000	 str         r4, [sp]
  000d4	e1a0e00f	 mov         lr, pc
  000d8	e12fff18	 bx          r8

; 3481 :         if ( status == requestOK ) {

  000dc	e3500001	 cmp         r0, #1
  000e0	1a000017	 bne         |$LN8@GetStatus@2|

; 3482 :             WaitForSingleObject( m_hHubStatusChangeEvent, INFINITE );

  000e4	e59900bc	 ldr         r0, [r9, #0xBC]
  000e8	e3e01000	 mvn         r1, #0
  000ec	eb000000	 bl          WaitForSingleObject

; 3483 :             if ( m_fHubThreadClosing ) {

  000f0	e59930b8	 ldr         r3, [r9, #0xB8]
  000f4	e3530000	 cmp         r3, #0
  000f8	0a000008	 beq         |$LN1@GetStatus@2|

; 3484 :                 m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ]->AbortTransfer(
; 3485 :                                              NULL, // callback function
; 3486 :                                              NULL, // callback parameter
; 3487 :                                              this ); // cancel ID

  000fc	e599105c	 ldr         r1, [r9, #0x5C]
  00100	e1a03009	 mov         r3, r9
  00104	e3a02000	 mov         r2, #0
  00108	e5910000	 ldr         r0, [r1]
  0010c	e3a01000	 mov         r1, #0
  00110	e5904000	 ldr         r4, [r0]
  00114	e5944010	 ldr         r4, [r4, #0x10]
  00118	e1a0e00f	 mov         lr, pc
  0011c	e12fff14	 bx          r4
  00120		 |$LN1@GetStatus@2|

; 3488 :             }
; 3489 :         }
; 3490 :         DEBUGCHK( fTransferDone );
; 3491 :     }
; 3492 :     BOOL fSuccess = (status == requestOK &&
; 3493 :                      fTransferDone &&
; 3494 :                      dwBytesTransferred == sizeof( USB_HUB_AND_PORT_STATUS ) &&
; 3495 :                      dwErrorFlags == USB_NO_ERROR);

  00120	e59d3038	 ldr         r3, [sp, #0x38]
  00124	e3530000	 cmp         r3, #0
  00128	0a000005	 beq         |$LN8@GetStatus@2|
  0012c	e59d303c	 ldr         r3, [sp, #0x3C]
  00130	e3530004	 cmp         r3, #4
  00134	059d3040	 ldreq       r3, [sp, #0x40]
  00138	03530000	 cmpeq       r3, #0
  0013c	03a00001	 moveq       r0, #1
  00140	0a000000	 beq         |$LN9@GetStatus@2|
  00144		 |$LN8@GetStatus@2|
  00144	e3a00000	 mov         r0, #0
  00148		 |$LN9@GetStatus@2|

; 3496 : 
; 3497 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CExternalHub::GetStatus - port = %d, returing BOOL %d\n"), port, fSuccess) );
; 3498 :     return fSuccess;
; 3499 : }

  00148	e28dd04c	 add         sp, sp, #0x4C
  0014c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00150	e12fff1e	 bx          lr
  00154		 |$LN15@GetStatus@2|
  00154		 |$LN16@GetStatus@2|
  00154	00000000	 DCD         |?TransferDoneCallbackSetEvent@CDevice@@KAKPAX@Z|
  00158		 |$M37040|

			 ENDP  ; |?GetStatus@CExternalHub@@EAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z|, CExternalHub::GetStatus

	EXPORT	|?ResetAndEnablePort@CExternalHub@@EAAHE@Z| ; CExternalHub::ResetAndEnablePort

  00000			 AREA	 |.pdata|, PDATA
|$T37064| DCD	|$LN18@ResetAndEn@2|
	DCD	0x40004e02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResetAndEnablePort@CExternalHub@@EAAHE@Z| PROC ; CExternalHub::ResetAndEnablePort

; 3513 : {

  00000		 |$LN18@ResetAndEn@2|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M37061|
  00008	e1a07001	 mov         r7, r1
  0000c	e1a06000	 mov         r6, r0

; 3514 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("+CExternalHub::ResetAndEnablePort - port = %d\n"), port) );
; 3515 : 
; 3516 :     DEBUGCHK( port >= 1 && port <= m_usbHubDescriptor.bNumberOfPorts );
; 3517 : 
; 3518 :     BOOL fSuccess = FALSE;
; 3519 : 
; 3520 :     if ( !SetOrClearFeature( port,
; 3521 :                             USB_REQUEST_SET_FEATURE,
; 3522 :                             USB_HUB_FEATURE_PORT_RESET ) ) {

  00010	e596e000	 ldr         lr, [r6]
  00014	e3a03004	 mov         r3, #4
  00018	e3a02003	 mov         r2, #3
  0001c	e59e4048	 ldr         r4, [lr, #0x48]
  00020	e3a05000	 mov         r5, #0
  00024	e1a0e00f	 mov         lr, pc
  00028	e12fff14	 bx          r4
  0002c	e3500000	 cmp         r0, #0

; 3523 :         DEBUGMSG( ZONE_ERROR, (TEXT("-CExternalHub::ResetAndEnablePort - could set reset feature for port %d\n"), port) );
; 3524 :         return FALSE;

  00030	0a00003b	 beq         |$LN9@ResetAndEn@2|

; 3525 :     }
; 3526 :     for ( UCHAR attempt = 0; !m_fHubThreadClosing && attempt < 5; attempt++ ) {

  00034	e59630b8	 ldr         r3, [r6, #0xB8]
  00038	e3a04000	 mov         r4, #0
  0003c	e3530000	 cmp         r3, #0
  00040	1a000038	 bne         |$LN15@ResetAndEn@2|
  00044	e3a09000	 mov         r9, #0
  00048	e3a08001	 mov         r8, #1
  0004c		 |$LL5@ResetAndEn@2|
  0004c	e3540005	 cmp         r4, #5
  00050	2a000034	 bcs         |$LN15@ResetAndEn@2|

; 3527 :         DWORD   dwStatusChangeBitmap = 0;
; 3528 :         // USB2.0 11.5.1.5 20 ms resetting period.
; 3529 :         Sleep(20);

  00054	e3a00014	 mov         r0, #0x14
  00058	e58d9000	 str         r9, [sp]
  0005c	eb000000	 bl          Sleep

; 3530 :         if ( GetStatusChangeBitmap( dwStatusChangeBitmap ) &&
; 3531 :              (dwStatusChangeBitmap & (1 << port)) ) {

  00060	e28d1000	 add         r1, sp, #0
  00064	e1a00006	 mov         r0, r6
  00068	eb000000	 bl          |?GetStatusChangeBitmap@CExternalHub@@AAAHAAK@Z|
  0006c	e3500000	 cmp         r0, #0
  00070	0a000002	 beq         |$LN4@ResetAndEn@2|
  00074	e59d3000	 ldr         r3, [sp]
  00078	e1130718	 tst         r3, r8, lsl r7
  0007c	1a000005	 bne         |$LN12@ResetAndEn@2|
  00080		 |$LN4@ResetAndEn@2|

; 3525 :     }
; 3526 :     for ( UCHAR attempt = 0; !m_fHubThreadClosing && attempt < 5; attempt++ ) {

  00080	e59620b8	 ldr         r2, [r6, #0xB8]
  00084	e2843001	 add         r3, r4, #1
  00088	e20340ff	 and         r4, r3, #0xFF
  0008c	e3520000	 cmp         r2, #0
  00090	0affffed	 beq         |$LL5@ResetAndEn@2|
  00094	ea000023	 b           |$LN15@ResetAndEn@2|
  00098		 |$LN12@ResetAndEn@2|

; 3532 :             USB_HUB_AND_PORT_STATUS portStatus;
; 3533 :             fSuccess = ( GetStatus( port, portStatus ) &&
; 3534 :                          portStatus.change.port.ResetChange && // port has reset
; 3535 :                          !portStatus.status.port.PortReset && // reset no longer asserted
; 3536 :                          portStatus.status.port.PortEnabled && // port enabled
; 3537 :                          SetOrClearFeature( port, // clear reset change flag
; 3538 :                                             USB_REQUEST_CLEAR_FEATURE,
; 3539 :                                             USB_HUB_FEATURE_C_PORT_RESET ) );

  00098	e5963000	 ldr         r3, [r6]
  0009c	e28d2004	 add         r2, sp, #4
  000a0	e1a01007	 mov         r1, r7
  000a4	e5933050	 ldr         r3, [r3, #0x50]
  000a8	e1a00006	 mov         r0, r6
  000ac	e1a0e00f	 mov         lr, pc
  000b0	e12fff13	 bx          r3
  000b4	e3500000	 cmp         r0, #0
  000b8	0a000019	 beq         |$LN9@ResetAndEn@2|
  000bc	e1dd30b6	 ldrh        r3, [sp, #6]
  000c0	e3130010	 tst         r3, #0x10
  000c4	0a000016	 beq         |$LN9@ResetAndEn@2|
  000c8	e1dd20b4	 ldrh        r2, [sp, #4]
  000cc	e1a03802	 mov         r3, r2, lsl #16
  000d0	e1a03823	 mov         r3, r3, lsr #16
  000d4	e3130010	 tst         r3, #0x10
  000d8	1a000011	 bne         |$LN9@ResetAndEn@2|
  000dc	e1a03802	 mov         r3, r2, lsl #16
  000e0	e1a03823	 mov         r3, r3, lsr #16
  000e4	e3130002	 tst         r3, #2
  000e8	0a00000d	 beq         |$LN9@ResetAndEn@2|
  000ec	e5961000	 ldr         r1, [r6]
  000f0	e3a03014	 mov         r3, #0x14
  000f4	e3a02001	 mov         r2, #1
  000f8	e5914048	 ldr         r4, [r1, #0x48]
  000fc	e1a01007	 mov         r1, r7
  00100	e1a00006	 mov         r0, r6
  00104	e1a0e00f	 mov         lr, pc
  00108	e12fff14	 bx          r4
  0010c	e3500000	 cmp         r0, #0
  00110	0a000003	 beq         |$LN9@ResetAndEn@2|

; 3540 :             if (fSuccess) { // According Specification. 50 ms delay after this.
; 3541 :                 Sleep(50);

  00114	e3a00032	 mov         r0, #0x32
  00118	e3a05001	 mov         r5, #1
  0011c	eb000000	 bl          Sleep
  00120	ea000000	 b           |$LN15@ResetAndEn@2|
  00124		 |$LN9@ResetAndEn@2|

; 3532 :             USB_HUB_AND_PORT_STATUS portStatus;
; 3533 :             fSuccess = ( GetStatus( port, portStatus ) &&
; 3534 :                          portStatus.change.port.ResetChange && // port has reset
; 3535 :                          !portStatus.status.port.PortReset && // reset no longer asserted
; 3536 :                          portStatus.status.port.PortEnabled && // port enabled
; 3537 :                          SetOrClearFeature( port, // clear reset change flag
; 3538 :                                             USB_REQUEST_CLEAR_FEATURE,
; 3539 :                                             USB_HUB_FEATURE_C_PORT_RESET ) );

  00124	e3a05000	 mov         r5, #0
  00128		 |$LN15@ResetAndEn@2|

; 3542 :             }
; 3543 :             break;
; 3544 :         }
; 3545 :     }
; 3546 : #if 0
; 3547 :     while ( fSuccess && !m_fHubThreadClosing ) {
; 3548 :         // make sure reset is signalled for at least 10ms
; 3549 :         Sleep( 10 );
; 3550 :         fSuccess = !m_fHubThreadClosing && GetStatus( port, portStatus );
; 3551 :         if ( fSuccess &&
; 3552 :              portStatus.change.port.ResetChange && // port has reset
; 3553 :              !portStatus.status.port.PortReset && // reset no longer asserted
; 3554 :              portStatus.status.port.PortEnabled ) { // port enabled
; 3555 : 
; 3556 :             DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("CExternalHub::ResetAndEnablePort - status.change = 0x%x, status.word = 0x%x\n"), portStatus.change.word, portStatus.status.word) );
; 3557 :             Sleep( 10 ); // give reset 10 ms to take hold
; 3558 :             break;
; 3559 :         }
; 3560 :     }
; 3561 : #endif
; 3562 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("-CExternalHub::ResetAndEnablePort - port = %d, returning %d\n"), port, fSuccess ) );
; 3563 :     return fSuccess;
; 3564 : }

  00128	e1a00005	 mov         r0, r5
  0012c	e28dd008	 add         sp, sp, #8
  00130	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00134	e12fff1e	 bx          lr
  00138		 |$M37062|

			 ENDP  ; |?ResetAndEnablePort@CExternalHub@@EAAHE@Z|, CExternalHub::ResetAndEnablePort

	EXPORT	|?DisablePort@CExternalHub@@EAAXE@Z|	; CExternalHub::DisablePort

  00000			 AREA	 |.pdata|, PDATA
|$T37073| DCD	|$LN6@DisablePor@2|
	DCD	0x40000e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DisablePort@CExternalHub@@EAAXE@Z| PROC ; CExternalHub::DisablePort

; 3577 : {

  00000		 |$LN6@DisablePor@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37070|

; 3578 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("+CExternalHub::DisablePort - port = %d\n"), port) );
; 3579 : 
; 3580 :     if ( !m_fHubThreadClosing ) {

  00004	e59030b8	 ldr         r3, [r0, #0xB8]
  00008	e3530000	 cmp         r3, #0
  0000c	1a000007	 bne         |$LN1@DisablePor@2|

; 3581 :         SetOrClearFeature( port,
; 3582 :                            USB_REQUEST_CLEAR_FEATURE,
; 3583 :                            USB_HUB_FEATURE_PORT_ENABLE );

  00010	e590e000	 ldr         lr, [r0]
  00014	e3a03001	 mov         r3, #1
  00018	e3a02001	 mov         r2, #1
  0001c	e59e4048	 ldr         r4, [lr, #0x48]
  00020	e1a0e00f	 mov         lr, pc
  00024	e12fff14	 bx          r4

; 3584 :         // disable port can take time to act
; 3585 :         Sleep( 10 );

  00028	e3a0000a	 mov         r0, #0xA
  0002c	eb000000	 bl          Sleep
  00030		 |$LN1@DisablePor@2|

; 3586 :     }
; 3587 : 
; 3588 :     DEBUGMSG( ZONE_ATTACH && ZONE_VERBOSE, (TEXT("-CExternalHub::DisablePort - port = %d\n"), port) );
; 3589 : }

  00030	e8bd4010	 ldmia       sp!, {r4, lr}
  00034	e12fff1e	 bx          lr
  00038		 |$M37071|

			 ENDP  ; |?DisablePort@CExternalHub@@EAAXE@Z|, CExternalHub::DisablePort

	EXPORT	|?SetOrClearFeature@CExternalHub@@EAAHGEG@Z| ; CExternalHub::SetOrClearFeature

  00000			 AREA	 |.pdata|, PDATA
|$T37092| DCD	|$LN14@SetOrClear@3|
	DCD	0x40005302
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetOrClearFeature@CExternalHub@@EAAHGEG@Z| PROC ; CExternalHub::SetOrClearFeature

; 3611 : {

  00000		 |$LN14@SetOrClear@3|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd04c	 sub         sp, sp, #0x4C
  00008		 |$M37089|
  00008	e1a04003	 mov         r4, r3
  0000c	e3510000	 cmp         r1, #0
  00010	e1a09000	 mov         r9, r0
  00014	e3a03c01	 mov         r3, #1, 24

; 3612 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CExternalHub::SetOrClearFeature - port = %d, set/clear = 0x%x, feature = 0x%x\n"), port, setOrClearFeature, feature) );
; 3613 : 
; 3614 : #ifdef DEBUG
; 3615 : {
; 3616 :     if ( setOrClearFeature == USB_REQUEST_CLEAR_FEATURE ) {
; 3617 :         if ( port == 0 ) {
; 3618 :             // USB spec 1.1, 11.16.2.2 - these are the only
; 3619 :             // features which should be cleared for ports
; 3620 :             DEBUGCHK( feature == USB_HUB_FEATURE_C_HUB_LOCAL_POWER ||
; 3621 :                       feature == USB_HUB_FEATURE_C_HUB_OVER_CURRENT ||
; 3622 :                       feature == USB_FEATURE_ENDPOINT_STALL );
; 3623 :         } else {
; 3624 :             // USB spec 1.1, 11.16.2.2 - these are the only
; 3625 :             // features which should be cleared for ports
; 3626 :             DEBUGCHK( feature == USB_HUB_FEATURE_PORT_ENABLE ||
; 3627 :                       feature == USB_HUB_FEATURE_PORT_SUSPEND ||
; 3628 :                       feature == USB_HUB_FEATURE_PORT_POWER ||
; 3629 :                       feature == USB_HUB_FEATURE_C_PORT_CONNECTION ||
; 3630 :                       feature == USB_HUB_FEATURE_C_PORT_RESET ||
; 3631 :                       feature == USB_HUB_FEATURE_C_PORT_ENABLE ||
; 3632 :                       feature == USB_HUB_FEATURE_C_PORT_SUSPEND ||
; 3633 :                       feature == USB_HUB_FEATURE_C_PORT_OVER_CURRENT );
; 3634 :         }
; 3635 :     } else if ( setOrClearFeature == USB_REQUEST_SET_FEATURE ) {
; 3636 :         // should only be setting port features
; 3637 :         DEBUGCHK( port > 0 &&
; 3638 :                   (feature == USB_HUB_FEATURE_PORT_RESET ||
; 3639 :                    feature == USB_HUB_FEATURE_PORT_SUSPEND ||
; 3640 :                    feature == USB_HUB_FEATURE_PORT_INDICATOR ||
; 3641 :                    feature == USB_HUB_FEATURE_PORT_POWER) );
; 3642 :     } else {
; 3643 :         // shouldn't be here
; 3644 :         DebugBreak();
; 3645 :     }
; 3646 :     DEBUGCHK( m_maxNumPipes == 2 && // control and status change
; 3647 :               m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ] != NULL &&
; 3648 :               port <= m_usbHubDescriptor.bNumberOfPorts );
; 3649 : }
; 3650 : #endif // DEBUG
; 3651 : 
; 3652 :     BOOL                fTransferDone = FALSE;
; 3653 :     DWORD               dwBytesTransferred = 0;
; 3654 :     DWORD               dwErrorFlags = USB_NOT_COMPLETE_ERROR;

  00018	e383e003	 orr         lr, r3, #3
  0001c	e3a03000	 mov         r3, #0
  00020	e58d3038	 str         r3, [sp, #0x38]

; 3655 :     HCD_REQUEST_STATUS  status = requestFailed;
; 3656 :     USB_DEVICE_REQUEST  usbRequest;
; 3657 :     if ( port == 0 ) {
; 3658 :         usbRequest.bmRequestType = USB_REQUEST_HOST_TO_DEVICE | USB_REQUEST_CLASS | USB_REQUEST_FOR_DEVICE;

  00024	03a03020	 moveq       r3, #0x20

; 3659 :     } else {
; 3660 :         usbRequest.bmRequestType = USB_REQUEST_HOST_TO_DEVICE | USB_REQUEST_CLASS | USB_REQUEST_FOR_OTHER;

  00028	13a03023	 movne       r3, #0x23
  0002c	e5cd3044	 strb        r3, [sp, #0x44]

; 3661 :     }
; 3662 :     usbRequest.bRequest = setOrClearFeature;
; 3663 :     usbRequest.wValue = feature;
; 3664 :     usbRequest.wIndex = port;
; 3665 :     usbRequest.wLength = 0;
; 3666 :     PREFAST_DEBUGCHK(m_ppCPipe != NULL);
; 3667 :     
; 3668 :     if ( !m_fHubThreadClosing ) {

  00030	e59930b8	 ldr         r3, [r9, #0xB8]
  00034	e3a00000	 mov         r0, #0
  00038	e58d003c	 str         r0, [sp, #0x3C]
  0003c	e3a00000	 mov         r0, #0
  00040	e3530000	 cmp         r3, #0
  00044	e58de040	 str         lr, [sp, #0x40]
  00048	e5cd2045	 strb        r2, [sp, #0x45]
  0004c	e1cd44b6	 strh        r4, [sp, #0x46]
  00050	e1cd14b8	 strh        r1, [sp, #0x48]
  00054	e1cd04ba	 strh        r0, [sp, #0x4A]
  00058	1a000036	 bne         |$LN8@SetOrClear@3|

; 3669 :         status = m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ]->IssueTransfer(
; 3670 :                          m_address, // address of this hub
; 3671 :                          TransferDoneCallbackSetEvent, // callback func
; 3672 :                          m_hHubStatusChangeEvent, // callback param
; 3673 :                          USB_OUT_TRANSFER | USB_SEND_TO_DEVICE, // transfer flags
; 3674 :                          &usbRequest, // control request
; 3675 :                          0, // dwStartingFrame (not used)
; 3676 :                          0, // dwFrames (not used)
; 3677 :                          NULL, // aLengths (not used)
; 3678 :                          0, // buffer size
; 3679 :                          NULL, // buffer
; 3680 :                          0, // phys addr of buffer (not used)
; 3681 :                          this, // cancel id
; 3682 :                          NULL, // adwIsochErrors (not used)
; 3683 :                          NULL, // adwIsochLengths (not used)
; 3684 :                          &fTransferDone, // OUT param for transfer
; 3685 :                          &dwBytesTransferred, // OUT param for transfer
; 3686 :                          &dwErrorFlags ); // OUT param for transfer

  0005c	e599105c	 ldr         r1, [r9, #0x5C]
  00060	e59930bc	 ldr         r3, [r9, #0xBC]
  00064	e59f20dc	 ldr         r2, [pc, #0xDC]
  00068	e5910000	 ldr         r0, [r1]
  0006c	e5d91020	 ldrb        r1, [r9, #0x20]
  00070	e28d6040	 add         r6, sp, #0x40
  00074	e590e000	 ldr         lr, [r0]
  00078	e28d403c	 add         r4, sp, #0x3C
  0007c	e28d5038	 add         r5, sp, #0x38
  00080	e59e800c	 ldr         r8, [lr, #0xC]
  00084	e28d7044	 add         r7, sp, #0x44
  00088	e3a0ba01	 mov         r11, #1, 20
  0008c	e3a0a000	 mov         r10, #0
  00090	e58d6034	 str         r6, [sp, #0x34]
  00094	e58d4030	 str         r4, [sp, #0x30]
  00098	e58d502c	 str         r5, [sp, #0x2C]
  0009c	e58da028	 str         r10, [sp, #0x28]
  000a0	e58da024	 str         r10, [sp, #0x24]
  000a4	e58d9020	 str         r9, [sp, #0x20]
  000a8	e58da01c	 str         r10, [sp, #0x1C]
  000ac	e58da018	 str         r10, [sp, #0x18]
  000b0	e58da014	 str         r10, [sp, #0x14]
  000b4	e58da010	 str         r10, [sp, #0x10]
  000b8	e58da00c	 str         r10, [sp, #0xC]
  000bc	e58da008	 str         r10, [sp, #8]
  000c0	e58d7004	 str         r7, [sp, #4]
  000c4	e58db000	 str         r11, [sp]
  000c8	e1a0e00f	 mov         lr, pc
  000cc	e12fff18	 bx          r8

; 3687 :         if ( status == requestOK ) {

  000d0	e3500001	 cmp         r0, #1
  000d4	1a000017	 bne         |$LN8@SetOrClear@3|

; 3688 :             WaitForSingleObject( m_hHubStatusChangeEvent,STANDARD_REQUEST_TIMEOUT);

  000d8	e59900bc	 ldr         r0, [r9, #0xBC]
  000dc	e3a01ffa	 mov         r1, #0xFA, 30
  000e0	eb000000	 bl          WaitForSingleObject

; 3689 :             if ( m_fHubThreadClosing ) {

  000e4	e59930b8	 ldr         r3, [r9, #0xB8]
  000e8	e3530000	 cmp         r3, #0
  000ec	0a000008	 beq         |$LN1@SetOrClear@3|

; 3690 :                 m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ]->AbortTransfer(
; 3691 :                                                NULL, // callback function
; 3692 :                                                NULL, // callback parameter
; 3693 :                                                this ); // cancel ID

  000f0	e599105c	 ldr         r1, [r9, #0x5C]
  000f4	e1a03009	 mov         r3, r9
  000f8	e3a02000	 mov         r2, #0
  000fc	e5910000	 ldr         r0, [r1]
  00100	e3a01000	 mov         r1, #0
  00104	e5904000	 ldr         r4, [r0]
  00108	e5944010	 ldr         r4, [r4, #0x10]
  0010c	e1a0e00f	 mov         lr, pc
  00110	e12fff14	 bx          r4
  00114		 |$LN1@SetOrClear@3|

; 3694 :             }
; 3695 :         }
; 3696 :         DEBUGCHK( fTransferDone );
; 3697 :     }
; 3698 :     BOOL fSuccess = (status == requestOK &&
; 3699 :                      fTransferDone &&
; 3700 :                      dwBytesTransferred == 0 &&
; 3701 :                      dwErrorFlags == USB_NO_ERROR);

  00114	e59d3038	 ldr         r3, [sp, #0x38]
  00118	e3530000	 cmp         r3, #0
  0011c	0a000005	 beq         |$LN8@SetOrClear@3|
  00120	e59d303c	 ldr         r3, [sp, #0x3C]
  00124	e3530000	 cmp         r3, #0
  00128	059d3040	 ldreq       r3, [sp, #0x40]
  0012c	03530000	 cmpeq       r3, #0
  00130	03a00001	 moveq       r0, #1
  00134	0a000000	 beq         |$LN9@SetOrClear@3|
  00138		 |$LN8@SetOrClear@3|
  00138	e3a00000	 mov         r0, #0
  0013c		 |$LN9@SetOrClear@3|

; 3702 : 
; 3703 :     DEBUGMSG( ZONE_ERROR && !fSuccess, (TEXT("CExternalHub::SetOrClearFeature - port = %d, set/clear = 0x%x, feature = 0x%x, FAILED\n"), port, setOrClearFeature, feature ) );
; 3704 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CExternalHub::SetOrClearFeature - port = %d, set/clear = 0x%x, feature = 0x%x, returing BOOL %d\n"), port, setOrClearFeature, feature, fSuccess) );
; 3705 :     return fSuccess;
; 3706 : }

  0013c	e28dd04c	 add         sp, sp, #0x4C
  00140	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00144	e12fff1e	 bx          lr
  00148		 |$LN15@SetOrClear@3|
  00148		 |$LN16@SetOrClear@3|
  00148	00000000	 DCD         |?TransferDoneCallbackSetEvent@CDevice@@KAKPAX@Z|
  0014c		 |$M37090|

			 ENDP  ; |?SetOrClearFeature@CExternalHub@@EAAHGEG@Z|, CExternalHub::SetOrClearFeature

	EXPORT	|?SetOrClearRemoteWakup@CExternalHub@@EAAHH@Z| ; CExternalHub::SetOrClearRemoteWakup

  00000			 AREA	 |.pdata|, PDATA
|$T37112| DCD	|$LN13@SetOrClear@4|
	DCD	0x40005502
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetOrClearRemoteWakup@CExternalHub@@EAAHH@Z| PROC ; CExternalHub::SetOrClearRemoteWakup

; 3718 : {

  00000		 |$LN13@SetOrClear@4|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd04c	 sub         sp, sp, #0x4C
  00008		 |$M37109|
  00008	e3510000	 cmp         r1, #0
  0000c	e1a09000	 mov         r9, r0
  00010	e3a03c01	 mov         r3, #1, 24

; 3719 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CExternalHub::SetOrClearRemoteWakup - bSet = %d\r\n"), bSet) );
; 3720 : 
; 3721 :     BOOL                fTransferDone = FALSE;
; 3722 :     DWORD               dwBytesTransferred = 0;
; 3723 :     DWORD               dwErrorFlags = USB_NOT_COMPLETE_ERROR;

  00014	e3833003	 orr         r3, r3, #3
  00018	e3a02000	 mov         r2, #0

; 3724 :     HCD_REQUEST_STATUS  status = requestFailed;
; 3725 :     USB_DEVICE_REQUEST  usbRequest;
; 3726 :     
; 3727 :     usbRequest.bmRequestType = USB_REQUEST_HOST_TO_DEVICE | USB_REQUEST_FOR_DEVICE;

  0001c	e58d3040	 str         r3, [sp, #0x40]

; 3728 :     usbRequest.bRequest = (bSet? USB_REQUEST_SET_FEATURE : USB_REQUEST_CLEAR_FEATURE);
; 3729 :     usbRequest.wValue = USB_FEATURE_REMOTE_WAKEUP;
; 3730 :     usbRequest.wIndex = 0;
; 3731 :     usbRequest.wLength = 0;
; 3732 : 
; 3733 :     if ( !m_fHubThreadClosing ) {

  00020	e59930b8	 ldr         r3, [r9, #0xB8]
  00024	e3a01000	 mov         r1, #0
  00028	e3a00000	 mov         r0, #0
  0002c	e58d2038	 str         r2, [sp, #0x38]
  00030	e58d103c	 str         r1, [sp, #0x3C]
  00034	e5cd0044	 strb        r0, [sp, #0x44]
  00038	13a02003	 movne       r2, #3
  0003c	03a02001	 moveq       r2, #1
  00040	e3a01001	 mov         r1, #1
  00044	e3a00000	 mov         r0, #0
  00048	e3a0e000	 mov         lr, #0
  0004c	e3530000	 cmp         r3, #0
  00050	e5cd2045	 strb        r2, [sp, #0x45]
  00054	e1cd14b6	 strh        r1, [sp, #0x46]
  00058	e1cd04b8	 strh        r0, [sp, #0x48]
  0005c	e1cde4ba	 strh        lr, [sp, #0x4A]
  00060	1a000036	 bne         |$LN8@SetOrClear@4|

; 3734 :         status = m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ]->IssueTransfer(
; 3735 :                          m_address, // address of this hub
; 3736 :                          TransferDoneCallbackSetEvent, // callback func
; 3737 :                          m_hHubStatusChangeEvent, // callback param
; 3738 :                          USB_OUT_TRANSFER | USB_SEND_TO_DEVICE, // transfer flags
; 3739 :                          &usbRequest, // control request
; 3740 :                          0, // dwStartingFrame (not used)
; 3741 :                          0, // dwFrames (not used)
; 3742 :                          NULL, // aLengths (not used)
; 3743 :                          0, // buffer size
; 3744 :                          NULL, // buffer
; 3745 :                          0, // phys addr of buffer (not used)
; 3746 :                          this, // cancel id
; 3747 :                          NULL, // adwIsochErrors (not used)
; 3748 :                          NULL, // adwIsochLengths (not used)
; 3749 :                          &fTransferDone, // OUT param for transfer
; 3750 :                          &dwBytesTransferred, // OUT param for transfer
; 3751 :                          &dwErrorFlags ); // OUT param for transfer

  00064	e599105c	 ldr         r1, [r9, #0x5C]
  00068	e59930bc	 ldr         r3, [r9, #0xBC]
  0006c	e59f20dc	 ldr         r2, [pc, #0xDC]
  00070	e5910000	 ldr         r0, [r1]
  00074	e5d91020	 ldrb        r1, [r9, #0x20]
  00078	e28d6040	 add         r6, sp, #0x40
  0007c	e590e000	 ldr         lr, [r0]
  00080	e28d403c	 add         r4, sp, #0x3C
  00084	e28d5038	 add         r5, sp, #0x38
  00088	e59e800c	 ldr         r8, [lr, #0xC]
  0008c	e28d7044	 add         r7, sp, #0x44
  00090	e3a0ba01	 mov         r11, #1, 20
  00094	e3a0a000	 mov         r10, #0
  00098	e58d6034	 str         r6, [sp, #0x34]
  0009c	e58d4030	 str         r4, [sp, #0x30]
  000a0	e58d502c	 str         r5, [sp, #0x2C]
  000a4	e58da028	 str         r10, [sp, #0x28]
  000a8	e58da024	 str         r10, [sp, #0x24]
  000ac	e58d9020	 str         r9, [sp, #0x20]
  000b0	e58da01c	 str         r10, [sp, #0x1C]
  000b4	e58da018	 str         r10, [sp, #0x18]
  000b8	e58da014	 str         r10, [sp, #0x14]
  000bc	e58da010	 str         r10, [sp, #0x10]
  000c0	e58da00c	 str         r10, [sp, #0xC]
  000c4	e58da008	 str         r10, [sp, #8]
  000c8	e58d7004	 str         r7, [sp, #4]
  000cc	e58db000	 str         r11, [sp]
  000d0	e1a0e00f	 mov         lr, pc
  000d4	e12fff18	 bx          r8

; 3752 :         if ( status == requestOK ) {

  000d8	e3500001	 cmp         r0, #1
  000dc	1a000017	 bne         |$LN8@SetOrClear@4|

; 3753 :             WaitForSingleObject( m_hHubStatusChangeEvent, INFINITE );

  000e0	e59900bc	 ldr         r0, [r9, #0xBC]
  000e4	e3e01000	 mvn         r1, #0
  000e8	eb000000	 bl          WaitForSingleObject

; 3754 :             if ( m_fHubThreadClosing ) {

  000ec	e59930b8	 ldr         r3, [r9, #0xB8]
  000f0	e3530000	 cmp         r3, #0
  000f4	0a000008	 beq         |$LN1@SetOrClear@4|

; 3755 :                 m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ]->AbortTransfer(
; 3756 :                                                NULL, // callback function
; 3757 :                                                NULL, // callback parameter
; 3758 :                                                this ); // cancel ID

  000f8	e599105c	 ldr         r1, [r9, #0x5C]
  000fc	e1a03009	 mov         r3, r9
  00100	e3a02000	 mov         r2, #0
  00104	e5910000	 ldr         r0, [r1]
  00108	e3a01000	 mov         r1, #0
  0010c	e5904000	 ldr         r4, [r0]
  00110	e5944010	 ldr         r4, [r4, #0x10]
  00114	e1a0e00f	 mov         lr, pc
  00118	e12fff14	 bx          r4
  0011c		 |$LN1@SetOrClear@4|

; 3759 :             }
; 3760 :         }
; 3761 :         DEBUGCHK( fTransferDone );
; 3762 :     }
; 3763 :     BOOL fSuccess = (status == requestOK &&
; 3764 :                      fTransferDone &&
; 3765 :                      dwBytesTransferred == 0 &&
; 3766 :                      dwErrorFlags == USB_NO_ERROR);

  0011c	e59d3038	 ldr         r3, [sp, #0x38]
  00120	e3530000	 cmp         r3, #0
  00124	0a000005	 beq         |$LN8@SetOrClear@4|
  00128	e59d303c	 ldr         r3, [sp, #0x3C]
  0012c	e3530000	 cmp         r3, #0
  00130	059d3040	 ldreq       r3, [sp, #0x40]
  00134	03530000	 cmpeq       r3, #0
  00138	03a00001	 moveq       r0, #1
  0013c	0a000000	 beq         |$LN9@SetOrClear@4|
  00140		 |$LN8@SetOrClear@4|
  00140	e3a00000	 mov         r0, #0
  00144		 |$LN9@SetOrClear@4|

; 3767 : 
; 3768 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CExternalHub::SetOrClearRemoteWakup -  returing BOOL %d\n"),fSuccess));
; 3769 :     return fSuccess;
; 3770 :     
; 3771 : }

  00144	e28dd04c	 add         sp, sp, #0x4C
  00148	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0014c	e12fff1e	 bx          lr
  00150		 |$LN14@SetOrClear@4|
  00150		 |$LN15@SetOrClear@4|
  00150	00000000	 DCD         |?TransferDoneCallbackSetEvent@CDevice@@KAKPAX@Z|
  00154		 |$M37110|

			 ENDP  ; |?SetOrClearRemoteWakup@CExternalHub@@EAAHH@Z|, CExternalHub::SetOrClearRemoteWakup

	EXPORT	|?EnterOperationalState@CFunction@@UAAHQAVCPipeAbs@@@Z| ; CFunction::EnterOperationalState
	IMPORT	|CreateEventW|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T37136| DCD	|$LN12@EnterOpera|
	DCD	0x40003102
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?EnterOperationalState@CFunction@@UAAHQAVCPipeAbs@@@Z| PROC ; CFunction::EnterOperationalState

; 3838 : {

  00000		 |$LN12@EnterOpera|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M37133|
  00008	e1a05001	 mov         r5, r1
  0000c	e1a06000	 mov         r6, r0

; 3839 :     DEBUGMSG( ZONE_FUNCTION, (TEXT("+CFunction(tier %d)::EnterOperationalState\n"), m_tierNumber) );
; 3840 : 
; 3841 :     BOOL fSuccess = FALSE;
; 3842 : 
; 3843 :     EnterCriticalSection( &m_csDeviceLock );

  00010	e286000c	 add         r0, r6, #0xC
  00014	e3a04000	 mov         r4, #0
  00018	eb000000	 bl          EnterCriticalSection

; 3844 : 
; 3845 :     DEBUGCHK( m_pCHcd->GetpUSBDAttachProc() != NULL &&
; 3846 :               m_pCHcd->GetpHcdContext() != NULL &&
; 3847 :               m_lpvDetachId == NULL &&  // device not attached yet
; 3848 :               m_ppCPipe == NULL && // not allocated yet
; 3849 :               m_maxNumPipes == 0 && // refers to m_ppCPipe, which is not allocated
; 3850 :               m_address > 0 &&
; 3851 :               m_address <= USB_MAX_ADDRESS &&
; 3852 :               pEndpoint0Pipe != NULL ); // control pipe to endpoint 0
; 3853 : 
; 3854 :     DEBUGCHK(m_hFunctionFeatureEvent == NULL);
; 3855 :     // m_hFunctionFeatureEvent - Auto Reset, and Initial State = non-signaled
; 3856 :     m_hFunctionFeatureEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

  0001c	e3a03000	 mov         r3, #0
  00020	e3a02000	 mov         r2, #0
  00024	e3a01000	 mov         r1, #0
  00028	e3a00000	 mov         r0, #0
  0002c	eb000000	 bl          CreateEventW
  00030	e1a03000	 mov         r3, r0

; 3857 : 
; 3858 :     if ( AllocatePipeArray() ) {

  00034	e1a00006	 mov         r0, r6
  00038	e5863064	 str         r3, [r6, #0x64]
  0003c	eb000000	 bl          |?AllocatePipeArray@CDevice@@IAAHXZ|
  00040	e3500000	 cmp         r0, #0
  00044	0a000012	 beq         |$LN9@EnterOpera|

; 3859 :         m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ] = pEndpoint0Pipe;

  00048	e596305c	 ldr         r3, [r6, #0x5C]

; 3860 :         LeaveCriticalSection( &m_csDeviceLock );

  0004c	e286000c	 add         r0, r6, #0xC
  00050	e5835000	 str         r5, [r3]
  00054	eb000000	 bl          LeaveCriticalSection

; 3861 :         fSuccess = (*m_pCHcd->GetpUSBDAttachProc())(m_pCHcd->GetpHcdContext(), // context for Host Controller Driver
; 3862 :                                         m_address, // used to indicate this specific device
; 3863 :                                         ENDPOINT0_CONTROL_PIPE, // index of endpoint 0 pipe
; 3864 :                                         LPCUSB_DEVICE( &m_deviceInfo ), // USB descriptors
; 3865 :                                         &m_lpvDetachId ); // used to tell USBD this device is being detached

  00058	e5963068	 ldr         r3, [r6, #0x68]
  0005c	e5d61020	 ldrb        r1, [r6, #0x20]
  00060	e2865060	 add         r5, r6, #0x60
  00064	e5930088	 ldr         r0, [r3, #0x88]
  00068	e593407c	 ldr         r4, [r3, #0x7C]
  0006c	e2863024	 add         r3, r6, #0x24
  00070	e3a02000	 mov         r2, #0
  00074	e58d5000	 str         r5, [sp]
  00078	e1a0e00f	 mov         lr, pc
  0007c	e12fff14	 bx          r4
  00080	e1a04000	 mov         r4, r0

; 3866 :         DEBUGCHK( !fSuccess || m_lpvDetachId != NULL );
; 3867 :         EnterCriticalSection( &m_csDeviceLock );

  00084	e286000c	 add         r0, r6, #0xC
  00088	eb000000	 bl          EnterCriticalSection

; 3868 :     }
; 3869 :     if ( !fSuccess ) {

  0008c	e3540000	 cmp         r4, #0
  00090	1a000005	 bne         |$LN1@EnterOpera|
  00094		 |$LN9@EnterOpera|

; 3870 :         DEBUGMSG( ZONE_ERROR, (TEXT("CFunction(tier %d)::EnterOperationalState - failed\n"), m_tierNumber) );
; 3871 :         // caller will handle pEndpoint0Pipe
; 3872 :         delete [] m_ppCPipe;

  00094	e596005c	 ldr         r0, [r6, #0x5C]
  00098	eb000000	 bl          |??3@YAXPAX@Z|

; 3873 :         m_ppCPipe = NULL;

  0009c	e3a03000	 mov         r3, #0
  000a0	e586305c	 str         r3, [r6, #0x5C]

; 3874 :         m_maxNumPipes = 0;

  000a4	e5c63054	 strb        r3, [r6, #0x54]

; 3875 : 
; 3876 :         m_lpvDetachId = NULL;

  000a8	e5863060	 str         r3, [r6, #0x60]
  000ac		 |$LN1@EnterOpera|

; 3877 :     }
; 3878 :     LeaveCriticalSection( &m_csDeviceLock );

  000ac	e286000c	 add         r0, r6, #0xC
  000b0	eb000000	 bl          LeaveCriticalSection

; 3879 : 
; 3880 :     DEBUGMSG( ZONE_FUNCTION, (TEXT("-CFunction(tier %d)::EnterOperationalState, returning BOOL %d\n"), m_tierNumber, fSuccess) );
; 3881 :     return fSuccess;
; 3882 : }

  000b4	e1a00004	 mov         r0, r4
  000b8	e28dd004	 add         sp, sp, #4
  000bc	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000c0	e12fff1e	 bx          lr
  000c4		 |$M37134|

			 ENDP  ; |?EnterOperationalState@CFunction@@UAAHQAVCPipeAbs@@@Z|, CFunction::EnterOperationalState

	EXPORT	|?NotifyOnSuspendedResumed@CFunction@@UAAHH@Z| ; CFunction::NotifyOnSuspendedResumed
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T37153| DCD	|$LN8@NotifyOnSu@3|
	DCD	0x40001701
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?NotifyOnSuspendedResumed@CFunction@@UAAHH@Z| PROC ; CFunction::NotifyOnSuspendedResumed

; 3885 : {

  00000		 |$LN8@NotifyOnSu@3|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M37150|
  00004	e1a06001	 mov         r6, r1
  00008	e1a04000	 mov         r4, r0

; 3886 :     EnterCriticalSection( &m_csDeviceLock );

  0000c	e284000c	 add         r0, r4, #0xC
  00010	eb000000	 bl          EnterCriticalSection

; 3887 :     LPUSBD_SUSPEND_RESUME_PROC pProc= m_pCHcd->GetpUSBDSuspendedResumed();

  00014	e5943068	 ldr         r3, [r4, #0x68]

; 3888 :     BOOL fSuccess = FALSE;

  00018	e3a05000	 mov         r5, #0
  0001c	e5933084	 ldr         r3, [r3, #0x84]
  00020	e1b02003	 movs        r2, r3

; 3889 :     if (pProc && m_lpvDetachId ) {

  00024	0a000007	 beq         |$LN1@NotifyOnSu@3|
  00028	e5943060	 ldr         r3, [r4, #0x60]
  0002c	e3530000	 cmp         r3, #0
  00030	0a000004	 beq         |$LN1@NotifyOnSu@3|

; 3890 :         fSuccess = (*pProc)(m_lpvDetachId, fResumed);

  00034	e1a01006	 mov         r1, r6
  00038	e1a00003	 mov         r0, r3
  0003c	e1a0e00f	 mov         lr, pc
  00040	e12fff12	 bx          r2
  00044	e1a05000	 mov         r5, r0
  00048		 |$LN1@NotifyOnSu@3|

; 3891 :     }
; 3892 :     LeaveCriticalSection( &m_csDeviceLock );

  00048	e284000c	 add         r0, r4, #0xC
  0004c	eb000000	 bl          LeaveCriticalSection

; 3893 :     return fSuccess;
; 3894 : }

  00050	e1a00005	 mov         r0, r5
  00054	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$M37151|

			 ENDP  ; |?NotifyOnSuspendedResumed@CFunction@@UAAHH@Z|, CFunction::NotifyOnSuspendedResumed

	EXPORT	|?OpenPipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IQBU_USB_ENDPOINT_DESCRIPTOR@@QAI@Z| ; CFunction::OpenPipe
	IMPORT	|?CreateControlPipe@@YAPAVCPipeAbs@@QBU_USB_ENDPOINT_DESCRIPTOR@@HHEEEQAVCHcd@@@Z| ; CreateControlPipe
	IMPORT	|?CreateIsochronousPipe@@YAPAVCPipeAbs@@QBU_USB_ENDPOINT_DESCRIPTOR@@HHEEEQAVCHcd@@@Z| ; CreateIsochronousPipe
	IMPORT	|?CreateBulkPipe@@YAPAVCPipeAbs@@QBU_USB_ENDPOINT_DESCRIPTOR@@HHEEEQAVCHcd@@@Z| ; CreateBulkPipe
	IMPORT	|?CreateInterruptPipe@@YAPAVCPipeAbs@@QBU_USB_ENDPOINT_DESCRIPTOR@@HHEEEQAVCHcd@@@Z| ; CreateInterruptPipe
	IMPORT	|memcmp|

  00000			 AREA	 |.pdata|, PDATA
|$T37190| DCD	|$LN40@OpenPipe@2|
	DCD	0x4000be02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OpenPipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IQBU_USB_ENDPOINT_DESCRIPTOR@@QAI@Z| PROC ; CFunction::OpenPipe

; 3919 : {

  00000		 |$LN40@OpenPipe@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd028	 sub         sp, sp, #0x28
  00008		 |$M37187|
  00008	e1a0b002	 mov         r11, r2
  0000c	e1a05000	 mov         r5, r0
  00010	e58db014	 str         r11, [sp, #0x14]
  00014	e58d5020	 str         r5, [sp, #0x20]
  00018	e58d3018	 str         r3, [sp, #0x18]

; 3920 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("+CFunction(tier %d)::OpenPipe - address = %d\n"), m_tierNumber, address) );
; 3921 : 
; 3922 :     HCD_REQUEST_STATUS status = requestIgnored;
; 3923 :     UCHAR pipe, bNumEndpoints, bEndpoint, bMaxEndpoints;
; 3924 :     int cInterfaces;
; 3925 :     BOOL fFound;
; 3926 : 
; 3927 :     // don't have to enter critical section until after checking
; 3928 :     // m_address (since m_address is const). That ensures we
; 3929 :     // won't wait for the critical section unless we actually
; 3930 :     // have something to do
; 3931 :     if ( address == m_address ) {

  0001c	e5d5e020	 ldrb        lr, [r5, #0x20]
  00020	e3a07002	 mov         r7, #2
  00024	e151000e	 cmp         r1, lr
  00028	1a0000ae	 bne         |$LN24@OpenPipe@2|

; 3932 :         EnterCriticalSection( &m_csDeviceLock );

  0002c	e285000c	 add         r0, r5, #0xC
  00030	eb000000	 bl          EnterCriticalSection

; 3933 :         // OpenPipe is referring to this device. Must return
; 3934 :         // something other than requestIgnored.
; 3935 :         status = requestFailed;
; 3936 : 
; 3937 :         PREFAST_DEBUGCHK( m_ppCPipe != NULL);
; 3938 :         DEBUGCHK( m_maxNumPipes > 0 &&
; 3939 :                   m_deviceInfo.lpActiveConfig != NULL &&
; 3940 :                   m_deviceInfo.lpActiveConfig->lpInterfaces != NULL);// &&
; 3941 : //                  m_maxNumPipes == m_deviceInfo.lpActiveConfig->lpInterfaces[0].Descriptor.bNumEndpoints + 1 );
; 3942 : 
; 3943 : //        DEBUGCHK( m_deviceInfo.lpActiveConfig->lpInterfaces[0].lpEndpoints != NULL );
; 3944 :         // There are m_maxNumPipes, but the endpoint descriptor for
; 3945 :         // the control pipe to endpoint 0 is not stored in our array of
; 3946 :         // endpoint descriptors. Thus, we only need to check
; 3947 :         // m_maxNumPipes - 1 pipes. The pipe needs to be indexed from 1,
; 3948 :         // since 0 already refers to the endpoint0 control pipe.
; 3949 : //        DEBUGCHK( m_maxNumPipes - 1 == m_deviceInfo.lpActiveConfig->lpInterfaces[0].Descriptor.bNumEndpoints );
; 3950 :         DEBUGCHK( m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ] != NULL );
; 3951 :         pipe = 0;
; 3952 :         fFound = FALSE;
; 3953 :         bMaxEndpoints = 0;
; 3954 :         cInterfaces = m_deviceInfo.lpActiveConfig->dwNumInterfaces;

  00034	e5953040	 ldr         r3, [r5, #0x40]
  00038	e3a01000	 mov         r1, #0
  0003c	e3a07000	 mov         r7, #0
  00040	e593a014	 ldr         r10, [r3, #0x14]
  00044	e5cd100d	 strb        r1, [sp, #0xD]
  00048	e3a04000	 mov         r4, #0

; 3955 :         if (cInterfaces < 1) {

  0004c	e35a0001	 cmp         r10, #1

; 3956 :             DEBUGCHK(0); // shouldn't be possible - test is here to make prefast happy.
; 3957 :             return status;

  00050	b3a07000	 movlt       r7, #0
  00054	e58da024	 str         r10, [sp, #0x24]
  00058	e3a09000	 mov         r9, #0
  0005c	ba0000a1	 blt         |$LN24@OpenPipe@2|

; 3958 :         }
; 3959 :         for ( UCHAR bInterface = 0; bInterface < cInterfaces && !fFound; bInterface++ ){

  00060	e3a08000	 mov         r8, #0
  00064	e35a0000	 cmp         r10, #0
  00068	da00009c	 ble         |$LN1@OpenPipe@2|
  0006c	e5dd600d	 ldrb        r6, [sp, #0xD]
  00070		 |$LL22@OpenPipe@2|
  00070	e3540000	 cmp         r4, #0
  00074	1a00002f	 bne         |$LN33@OpenPipe@2|

; 3960 :             bNumEndpoints = m_deviceInfo.lpActiveConfig->lpInterfaces[bInterface].Descriptor.bNumEndpoints;

  00078	e5932018	 ldr         r2, [r3, #0x18]
  0007c	e0683188	 rsb         r3, r8, r8, lsl #3

; 3961 :             for(bEndpoint = 0; bEndpoint < bNumEndpoints && !fFound; bEndpoint++ ){

  00080	e3a06000	 mov         r6, #0
  00084	e0823103	 add         r3, r2, r3, lsl #2
  00088	e5d3b008	 ldrb        r11, [r3, #8]
  0008c	e58d3010	 str         r3, [sp, #0x10]
  00090	e1b0200b	 movs        r2, r11
  00094	e58d201c	 str         r2, [sp, #0x1C]
  00098	0a000015	 beq         |$LN17@OpenPipe@2|
  0009c	e59d5014	 ldr         r5, [sp, #0x14]
  000a0	e1a0a003	 mov         r10, r3
  000a4		 |$LL19@OpenPipe@2|
  000a4	e3540000	 cmp         r4, #0
  000a8	1a00000d	 bne         |$LN34@OpenPipe@2|

; 3962 :                 if ( memcmp( &m_deviceInfo.lpActiveConfig->lpInterfaces[bInterface].lpEndpoints[ bEndpoint ].Descriptor, lpEndpointDescriptor, sizeof( USB_ENDPOINT_DESCRIPTOR ) ) == 0 ) {

  000ac	e59a1014	 ldr         r1, [r10, #0x14]
  000b0	e0863106	 add         r3, r6, r6, lsl #2
  000b4	e3a02007	 mov         r2, #7
  000b8	e0813103	 add         r3, r1, r3, lsl #2
  000bc	e2830004	 add         r0, r3, #4
  000c0	e1a01005	 mov         r1, r5
  000c4	eb000000	 bl          memcmp
  000c8	e59d201c	 ldr         r2, [sp, #0x1C]
  000cc	e2863001	 add         r3, r6, #1
  000d0	e3500000	 cmp         r0, #0
  000d4	e20360ff	 and         r6, r3, #0xFF

; 3963 :                     fFound = TRUE;

  000d8	03a04001	 moveq       r4, #1
  000dc	e1560002	 cmp         r6, r2
  000e0	3affffef	 bcc         |$LL19@OpenPipe@2|
  000e4		 |$LN34@OpenPipe@2|

; 3919 : {

  000e4	e59d5020	 ldr         r5, [sp, #0x20]

; 3933 :         // OpenPipe is referring to this device. Must return
; 3934 :         // something other than requestIgnored.
; 3935 :         status = requestFailed;
; 3936 : 
; 3937 :         PREFAST_DEBUGCHK( m_ppCPipe != NULL);
; 3938 :         DEBUGCHK( m_maxNumPipes > 0 &&
; 3939 :                   m_deviceInfo.lpActiveConfig != NULL &&
; 3940 :                   m_deviceInfo.lpActiveConfig->lpInterfaces != NULL);// &&
; 3941 : //                  m_maxNumPipes == m_deviceInfo.lpActiveConfig->lpInterfaces[0].Descriptor.bNumEndpoints + 1 );
; 3942 : 
; 3943 : //        DEBUGCHK( m_deviceInfo.lpActiveConfig->lpInterfaces[0].lpEndpoints != NULL );
; 3944 :         // There are m_maxNumPipes, but the endpoint descriptor for
; 3945 :         // the control pipe to endpoint 0 is not stored in our array of
; 3946 :         // endpoint descriptors. Thus, we only need to check
; 3947 :         // m_maxNumPipes - 1 pipes. The pipe needs to be indexed from 1,
; 3948 :         // since 0 already refers to the endpoint0 control pipe.
; 3949 : //        DEBUGCHK( m_maxNumPipes - 1 == m_deviceInfo.lpActiveConfig->lpInterfaces[0].Descriptor.bNumEndpoints );
; 3950 :         DEBUGCHK( m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ] != NULL );
; 3951 :         pipe = 0;
; 3952 :         fFound = FALSE;
; 3953 :         bMaxEndpoints = 0;
; 3954 :         cInterfaces = m_deviceInfo.lpActiveConfig->dwNumInterfaces;

  000e8	e59da024	 ldr         r10, [sp, #0x24]

; 3961 :             for(bEndpoint = 0; bEndpoint < bNumEndpoints && !fFound; bEndpoint++ ){

  000ec	e59d3010	 ldr         r3, [sp, #0x10]

; 3971 :                 pipe += bMaxEndpoints;

  000f0	e5dd100d	 ldrb        r1, [sp, #0xD]
  000f4		 |$LN17@OpenPipe@2|
  000f4	e5d33007	 ldrb        r3, [r3, #7]
  000f8	e3530000	 cmp         r3, #0
  000fc	0a000002	 beq         |$LN15@OpenPipe@2|

; 3964 :                 }
; 3965 :             }
; 3966 :             if(m_deviceInfo.lpActiveConfig->lpInterfaces[bInterface].Descriptor.bAlternateSetting != 0){
; 3967 :                 if(bMaxEndpoints < bNumEndpoints)

  00100	e1590002	 cmp         r9, r2
  00104	2a000004	 bcs         |$LN21@OpenPipe@2|

; 3968 :                     bMaxEndpoints = bNumEndpoints;
; 3969 :             }
; 3970 :             else {

  00108	ea000002	 b           |$LN35@OpenPipe@2|
  0010c		 |$LN15@OpenPipe@2|

; 3971 :                 pipe += bMaxEndpoints;

  0010c	e0893001	 add         r3, r9, r1
  00110	e20310ff	 and         r1, r3, #0xFF
  00114	e5cd100d	 strb        r1, [sp, #0xD]
  00118		 |$LN35@OpenPipe@2|

; 3972 :                 bMaxEndpoints = bNumEndpoints;

  00118	e1a0900b	 mov         r9, r11
  0011c		 |$LN21@OpenPipe@2|
  0011c	e2883001	 add         r3, r8, #1
  00120	e20380ff	 and         r8, r3, #0xFF
  00124	e5953040	 ldr         r3, [r5, #0x40]
  00128	e158000a	 cmp         r8, r10
  0012c	baffffcf	 blt         |$LL22@OpenPipe@2|

; 3973 :             }
; 3974 : 
; 3975 :         }
; 3976 : 
; 3977 :         DEBUGCHK(fFound);
; 3978 : 
; 3979 :         if(fFound){

  00130	e3540000	 cmp         r4, #0
  00134	0a000069	 beq         |$LN1@OpenPipe@2|
  00138		 |$LN33@OpenPipe@2|

; 3980 :             pipe += bEndpoint;
; 3981 : 
; 3982 :             DEBUGMSG( ZONE_ERROR && pipe == m_maxNumPipes, (TEXT("CFunction(tier %d)::OpenPipe - endpoint descriptor doesn't match any of this device's endpoints!\n"), m_tierNumber) );
; 3983 :             if ( pipe < m_maxNumPipes ) {

  00138	e5d52054	 ldrb        r2, [r5, #0x54]
  0013c	e0863001	 add         r3, r6, r1
  00140	e20360ff	 and         r6, r3, #0xFF
  00144	e1560002	 cmp         r6, r2
  00148	2a000064	 bcs         |$LN1@OpenPipe@2|

; 3984 :                 if ( m_ppCPipe[ pipe ] != NULL ) {

  0014c	e595305c	 ldr         r3, [r5, #0x5C]
  00150	e7933106	 ldr         r3, [r3, +r6, lsl #2]
  00154	e3530000	 cmp         r3, #0

; 3985 :                     DEBUGMSG( ZONE_WARNING, (TEXT("CFunction(tier %d)::OpenPipe - address %d pipe %d appears to have been opened before\n"), m_tierNumber, address, pipe) );
; 3986 :                     status = requestOK;
; 3987 :                     *lpiEndpointIndex = pipe;
; 3988 :                 } else {

  00158	1a000051	 bne         |$LN37@OpenPipe@2|

; 3989 :                     UCHAR uTTAddress=0;
; 3990 :                     UCHAR uTTPort=0;
; 3991 :                     GetUSB2TT(&uTTAddress, &uTTPort);

  0015c	e5953000	 ldr         r3, [r5]
  00160	e3a04000	 mov         r4, #0
  00164	e3a08000	 mov         r8, #0
  00168	e5933034	 ldr         r3, [r3, #0x34]
  0016c	e28d200c	 add         r2, sp, #0xC
  00170	e28d100d	 add         r1, sp, #0xD
  00174	e1a00005	 mov         r0, r5
  00178	e5cd400d	 strb        r4, [sp, #0xD]
  0017c	e5cd800c	 strb        r8, [sp, #0xC]
  00180	e1a0e00f	 mov         lr, pc
  00184	e12fff13	 bx          r3

; 3992 :                     switch ( lpEndpointDescriptor->bmAttributes & USB_ENDPOINT_TYPE_MASK ) {

  00188	e59db014	 ldr         r11, [sp, #0x14]
  0018c	e5db3003	 ldrb        r3, [r11, #3]
  00190	e2133003	 ands        r3, r3, #3
  00194	0a000029	 beq         |$LN5@OpenPipe@2|
  00198	e3530001	 cmp         r3, #1
  0019c	0a00001b	 beq         |$LN3@OpenPipe@2|
  001a0	e3530002	 cmp         r3, #2
  001a4	0a00000d	 beq         |$LN6@OpenPipe@2|
  001a8	e3530003	 cmp         r3, #3
  001ac	1a000030	 bne         |$LN7@OpenPipe@2|

; 4004 :                         break;
; 4005 :                       case USB_ENDPOINT_TYPE_INTERRUPT:
; 4006 :                         m_ppCPipe[ pipe ] = CreateInterruptPipe( lpEndpointDescriptor,
; 4007 :                                                                 m_fIsLowSpeed,m_fIsHighSpeed,m_address,
; 4008 :                                                                 uTTAddress,uTTPort,
; 4009 :                                                                 m_pCHcd);

  001b0	e5950068	 ldr         r0, [r5, #0x68]
  001b4	e5dde00c	 ldrb        lr, [sp, #0xC]
  001b8	e5dd400d	 ldrb        r4, [sp, #0xD]
  001bc	e5d53020	 ldrb        r3, [r5, #0x20]
  001c0	e5952048	 ldr         r2, [r5, #0x48]
  001c4	e5951044	 ldr         r1, [r5, #0x44]
  001c8	e58d0008	 str         r0, [sp, #8]
  001cc	e1a0000b	 mov         r0, r11
  001d0	e58de004	 str         lr, [sp, #4]
  001d4	e58d4000	 str         r4, [sp]
  001d8	eb000000	 bl          |?CreateInterruptPipe@@YAPAVCPipeAbs@@QBU_USB_ENDPOINT_DESCRIPTOR@@HHEEEQAVCHcd@@@Z|

; 4010 :                         break;

  001dc	ea000022	 b           |$LN36@OpenPipe@2|
  001e0		 |$LN6@OpenPipe@2|

; 3993 :                       case USB_ENDPOINT_TYPE_BULK:
; 3994 :                         m_ppCPipe[ pipe ] = CreateBulkPipe( lpEndpointDescriptor,
; 3995 :                                                            m_fIsLowSpeed,m_fIsHighSpeed,m_address,
; 3996 :                                                            uTTAddress,uTTPort,
; 3997 :                                                            m_pCHcd);

  001e0	e5950068	 ldr         r0, [r5, #0x68]
  001e4	e5dde00c	 ldrb        lr, [sp, #0xC]
  001e8	e5dd400d	 ldrb        r4, [sp, #0xD]
  001ec	e5d53020	 ldrb        r3, [r5, #0x20]
  001f0	e5952048	 ldr         r2, [r5, #0x48]
  001f4	e5951044	 ldr         r1, [r5, #0x44]
  001f8	e58d0008	 str         r0, [sp, #8]
  001fc	e1a0000b	 mov         r0, r11
  00200	e58de004	 str         lr, [sp, #4]
  00204	e58d4000	 str         r4, [sp]
  00208	eb000000	 bl          |?CreateBulkPipe@@YAPAVCPipeAbs@@QBU_USB_ENDPOINT_DESCRIPTOR@@HHEEEQAVCHcd@@@Z|

; 3998 :                         break;

  0020c	ea000016	 b           |$LN36@OpenPipe@2|
  00210		 |$LN3@OpenPipe@2|

; 4011 :                       case USB_ENDPOINT_TYPE_ISOCHRONOUS:
; 4012 :                         m_ppCPipe[ pipe ] = CreateIsochronousPipe( lpEndpointDescriptor,
; 4013 :                                                                   m_fIsLowSpeed,m_fIsHighSpeed,m_address,
; 4014 :                                                                   uTTAddress,uTTPort,
; 4015 :                                                                   m_pCHcd);

  00210	e5950068	 ldr         r0, [r5, #0x68]
  00214	e5dde00c	 ldrb        lr, [sp, #0xC]
  00218	e5dd400d	 ldrb        r4, [sp, #0xD]
  0021c	e5d53020	 ldrb        r3, [r5, #0x20]
  00220	e5952048	 ldr         r2, [r5, #0x48]
  00224	e5951044	 ldr         r1, [r5, #0x44]
  00228	e58d0008	 str         r0, [sp, #8]
  0022c	e1a0000b	 mov         r0, r11
  00230	e58de004	 str         lr, [sp, #4]
  00234	e58d4000	 str         r4, [sp]
  00238	eb000000	 bl          |?CreateIsochronousPipe@@YAPAVCPipeAbs@@QBU_USB_ENDPOINT_DESCRIPTOR@@HHEEEQAVCHcd@@@Z|

; 4016 :                         break;

  0023c	ea00000a	 b           |$LN36@OpenPipe@2|
  00240		 |$LN5@OpenPipe@2|

; 3999 :                       case USB_ENDPOINT_TYPE_CONTROL:
; 4000 :                         m_ppCPipe[ pipe ] = CreateControlPipe( lpEndpointDescriptor,
; 4001 :                                                               m_fIsLowSpeed,m_fIsHighSpeed,m_address,
; 4002 :                                                               uTTAddress,uTTPort,
; 4003 :                                                               m_pCHcd);

  00240	e5950068	 ldr         r0, [r5, #0x68]
  00244	e5dde00c	 ldrb        lr, [sp, #0xC]
  00248	e5dd400d	 ldrb        r4, [sp, #0xD]
  0024c	e5d53020	 ldrb        r3, [r5, #0x20]
  00250	e5952048	 ldr         r2, [r5, #0x48]
  00254	e5951044	 ldr         r1, [r5, #0x44]
  00258	e58d0008	 str         r0, [sp, #8]
  0025c	e1a0000b	 mov         r0, r11
  00260	e58de004	 str         lr, [sp, #4]
  00264	e58d4000	 str         r4, [sp]
  00268	eb000000	 bl          |?CreateControlPipe@@YAPAVCPipeAbs@@QBU_USB_ENDPOINT_DESCRIPTOR@@HHEEEQAVCHcd@@@Z|
  0026c		 |$LN36@OpenPipe@2|
  0026c	e595305c	 ldr         r3, [r5, #0x5C]
  00270	e7830106	 str         r0, [r3, +r6, lsl #2]
  00274		 |$LN7@OpenPipe@2|

; 4017 : #ifdef DEBUG
; 4018 :                       default:
; 4019 :                         DebugBreak(); // shouldn't be here
; 4020 :                             break;
; 4021 : #endif // DEBUG
; 4022 :                     }
; 4023 :                     if ( m_ppCPipe[ pipe ] != NULL &&
; 4024 :                          m_ppCPipe[ pipe ]->OpenPipe() == requestOK ) {

  00274	e595305c	 ldr         r3, [r5, #0x5C]
  00278	e7933106	 ldr         r3, [r3, +r6, lsl #2]
  0027c	e3530000	 cmp         r3, #0
  00280	0a00000b	 beq         |$LN2@OpenPipe@2|
  00284	e595305c	 ldr         r3, [r5, #0x5C]
  00288	e7930106	 ldr         r0, [r3, +r6, lsl #2]
  0028c	e5903000	 ldr         r3, [r0]
  00290	e5933004	 ldr         r3, [r3, #4]
  00294	e1a0e00f	 mov         lr, pc
  00298	e12fff13	 bx          r3
  0029c	e3500001	 cmp         r0, #1
  002a0	1a000003	 bne         |$LN2@OpenPipe@2|
  002a4		 |$LN37@OpenPipe@2|

; 4025 :                         DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("CFunction(tier %d)::OpenPipe - opened new pipe, address %d, pipe %d\n"), m_tierNumber, address, pipe ) );
; 4026 :                         status = requestOK;
; 4027 :                         *lpiEndpointIndex = pipe;

  002a4	e59d3018	 ldr         r3, [sp, #0x18]
  002a8	e3a07001	 mov         r7, #1
  002ac	e5836000	 str         r6, [r3]

; 4028 :                     } else {

  002b0	ea00000a	 b           |$LN1@OpenPipe@2|
  002b4		 |$LN2@OpenPipe@2|

; 4029 :                         delete m_ppCPipe[ pipe ];

  002b4	e595305c	 ldr         r3, [r5, #0x5C]
  002b8	e7933106	 ldr         r3, [r3, +r6, lsl #2]
  002bc	e1b00003	 movs        r0, r3
  002c0	15903000	 ldrne       r3, [r0]
  002c4	13a01001	 movne       r1, #1
  002c8	15933000	 ldrne       r3, [r3]
  002cc	11a0e00f	 movne       lr, pc
  002d0	112fff13	 bxne        r3

; 4030 :                         m_ppCPipe[ pipe ] = NULL;

  002d4	e595305c	 ldr         r3, [r5, #0x5C]
  002d8	e3a02000	 mov         r2, #0
  002dc	e7832106	 str         r2, [r3, +r6, lsl #2]
  002e0		 |$LN1@OpenPipe@2|

; 4031 :                     }
; 4032 :                 }
; 4033 :             }
; 4034 :         }
; 4035 :         LeaveCriticalSection( &m_csDeviceLock );

  002e0	e285000c	 add         r0, r5, #0xC
  002e4	eb000000	 bl          LeaveCriticalSection
  002e8		 |$LN24@OpenPipe@2|

; 4036 :     }
; 4037 : 
; 4038 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("-CFunction(tier %d)::OpenPipe - address = %d, returing HCD_REQUEST_STATUS %d\n"), m_tierNumber, address, status) );
; 4039 :     return status;
; 4040 : }

  002e8	e1a00007	 mov         r0, r7
  002ec	e28dd028	 add         sp, sp, #0x28
  002f0	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  002f4	e12fff1e	 bx          lr
  002f8		 |$M37188|

			 ENDP  ; |?OpenPipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IQBU_USB_ENDPOINT_DESCRIPTOR@@QAI@Z|, CFunction::OpenPipe

	EXPORT	|?ClosePipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@II@Z| ; CFunction::ClosePipe

  00000			 AREA	 |.pdata|, PDATA
|$T37208| DCD	|$LN9@ClosePipe@2|
	DCD	0x40002801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ClosePipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@II@Z| PROC ; CFunction::ClosePipe

; 4059 : {

  00000		 |$LN9@ClosePipe@2|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M37205|
  00004	e1a05002	 mov         r5, r2
  00008	e1a04000	 mov         r4, r0

; 4060 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("+CFunction(tier %d)::ClosePipe - address = %d, pipe = %d\n"), m_tierNumber, address, pipeIndex) );
; 4061 : 
; 4062 :     HCD_REQUEST_STATUS status = requestIgnored;
; 4063 : 
; 4064 : 
; 4065 :     // don't have to enter critical section until after checking
; 4066 :     // m_address (since m_address is const). That ensures we
; 4067 :     // won't wait for the critical section unless we actually
; 4068 :     // have something to do
; 4069 :     if ( address == m_address ) {

  0000c	e5d43020	 ldrb        r3, [r4, #0x20]
  00010	e3a06002	 mov         r6, #2
  00014	e1510003	 cmp         r1, r3
  00018	1a00001d	 bne         |$LN2@ClosePipe@2|

; 4070 :         EnterCriticalSection( &m_csDeviceLock );

  0001c	e284000c	 add         r0, r4, #0xC
  00020	eb000000	 bl          EnterCriticalSection

; 4071 :         status = requestOK; // if the pipe doesn't exists, we can return
; 4072 :                             // that ClosePipe worked
; 4073 :         if ( pipeIndex < m_maxNumPipes && m_ppCPipe[ pipeIndex ] != NULL ) {

  00024	e5d43054	 ldrb        r3, [r4, #0x54]
  00028	e3a06001	 mov         r6, #1
  0002c	e1550003	 cmp         r5, r3
  00030	2a000015	 bcs         |$LN1@ClosePipe@2|
  00034	e594305c	 ldr         r3, [r4, #0x5C]
  00038	e7933105	 ldr         r3, [r3, +r5, lsl #2]
  0003c	e3530000	 cmp         r3, #0
  00040	0a000011	 beq         |$LN1@ClosePipe@2|

; 4074 :             status = m_ppCPipe[ pipeIndex ]->ClosePipe( );

  00044	e594305c	 ldr         r3, [r4, #0x5C]
  00048	e7930105	 ldr         r0, [r3, +r5, lsl #2]
  0004c	e5903000	 ldr         r3, [r0]
  00050	e5933008	 ldr         r3, [r3, #8]
  00054	e1a0e00f	 mov         lr, pc
  00058	e12fff13	 bx          r3

; 4075 :             DEBUGMSG( ZONE_FUNCTION, (TEXT("CFunction(tier %d)::ClosePipe - address = %d, deleting pipe %d\n"), m_tierNumber, address, pipeIndex) );
; 4076 :             delete m_ppCPipe[ pipeIndex ];

  0005c	e594305c	 ldr         r3, [r4, #0x5C]
  00060	e1a06000	 mov         r6, r0
  00064	e7933105	 ldr         r3, [r3, +r5, lsl #2]
  00068	e1b00003	 movs        r0, r3
  0006c	15903000	 ldrne       r3, [r0]
  00070	13a01001	 movne       r1, #1
  00074	15933000	 ldrne       r3, [r3]
  00078	11a0e00f	 movne       lr, pc
  0007c	112fff13	 bxne        r3

; 4077 :             m_ppCPipe[ pipeIndex ] = NULL;

  00080	e594305c	 ldr         r3, [r4, #0x5C]
  00084	e3a02000	 mov         r2, #0
  00088	e7832105	 str         r2, [r3, +r5, lsl #2]
  0008c		 |$LN1@ClosePipe@2|

; 4078 :         }
; 4079 :     #ifdef DEBUG
; 4080 :         else {
; 4081 :             DEBUGMSG( ZONE_WARNING, (TEXT("CFunction(tier %d)::ClosePipe - warning, pipe does not exist. Returning requestOK\n"), m_tierNumber) );
; 4082 :         }
; 4083 :     #endif // DEBUG
; 4084 :         LeaveCriticalSection( &m_csDeviceLock );

  0008c	e284000c	 add         r0, r4, #0xC
  00090	eb000000	 bl          LeaveCriticalSection
  00094		 |$LN2@ClosePipe@2|

; 4085 :     }
; 4086 : 
; 4087 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("-CFunction(tier %d)::ClosePipe - address = %d, pipe = %d, returing HCD_REQUEST_STATUS %d\n"), m_tierNumber, address, pipeIndex, status) );
; 4088 :     return status;
; 4089 : }

  00094	e1a00006	 mov         r0, r6
  00098	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$M37206|

			 ENDP  ; |?ClosePipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|, CFunction::ClosePipe

	EXPORT	|?IssueTransfer@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z| ; CFunction::IssueTransfer
	EXPORT	|??_C@_1LG@HEEINJNP@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAI?$AAs?$AAs?$AAu?$AAe?$AAT?$AAr?$AAa@| [ DATA ] ; `string'
	IMPORT	|NKDbgPrintfW|
	IMPORT	|g_fOmapEhciSuspended|

  00000			 AREA	 |.pdata|, PDATA
|$T37224| DCD	|$LN11@IssueTrans@2|
	DCD	0x40005302

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1LG@HEEINJNP@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAI?$AAs?$AAs?$AAu?$AAe?$AAT?$AAr?$AAa@| DCB "!"
	DCB	0x0, "!", 0x0, "!", 0x0, "C", 0x0, "F", 0x0, "u", 0x0, "n"
	DCB	0x0, "c", 0x0, "t", 0x0, "i", 0x0, "o", 0x0, "n", 0x0, "("
	DCB	0x0, " ", 0x0, "t", 0x0, "i", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, ")", 0x0, ":", 0x0, ":", 0x0, "I"
	DCB	0x0, "s", 0x0, "s", 0x0, "u", 0x0, "e", 0x0, "T", 0x0, "r"
	DCB	0x0, "a", 0x0, "n", 0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r"
	DCB	0x0, " ", 0x0, "o", 0x0, "n", 0x0, " ", 0x0, "s", 0x0, "u"
	DCB	0x0, "s", 0x0, "p", 0x0, "e", 0x0, "n", 0x0, "d", 0x0, " "
	DCB	0x0, "s", 0x0, "t", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, " "
	DCB	0x0, "i", 0x0, "s", 0x0, " ", 0x0, "i", 0x0, "l", 0x0, "l"
	DCB	0x0, "g", 0x0, "l", 0x0, "e", 0x0, ",", 0x0, " ", 0x0, "a"
	DCB	0x0, "d", 0x0, "d", 0x0, "r", 0x0, "e", 0x0, "s", 0x0, "s"
	DCB	0x0, " ", 0x0, "=", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ","
	DCB	0x0, " ", 0x0, "p", 0x0, "i", 0x0, "p", 0x0, "e", 0x0, " "
	DCB	0x0, "=", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IssueTransfer@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z| PROC ; CFunction::IssueTransfer

; 4126 : {

  00000		 |$LN11@IssueTrans@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd048	 sub         sp, sp, #0x48
  00008		 |$M37221|
  00008	e1a08001	 mov         r8, r1
  0000c	e1a05000	 mov         r5, r0
  00010	e58d803c	 str         r8, [sp, #0x3C]
  00014	e58d5044	 str         r5, [sp, #0x44]
  00018	e58d3038	 str         r3, [sp, #0x38]
  0001c	e1a06002	 mov         r6, r2

; 4127 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("+CFunction(tier %d)::IssueTransfer\n"), m_tierNumber));
; 4128 : 
; 4129 :     HCD_REQUEST_STATUS status = requestIgnored;
; 4130 : 
; 4131 :     // don't have to enter critical section until after checking
; 4132 :     // m_address (since m_address is const). That ensures we
; 4133 :     // won't wait for the critical section unless we actually
; 4134 :     // have something to do
; 4135 :     if ( address == m_address ) {

  00020	e5d5e020	 ldrb        lr, [r5, #0x20]
  00024	e3a07002	 mov         r7, #2
  00028	e158000e	 cmp         r8, lr
  0002c	1a000040	 bne         |$LN4@IssueTrans@2|

; 4136 :         EnterCriticalSection( &m_csDeviceLock );

  00030	e285000c	 add         r0, r5, #0xC
  00034	eb000000	 bl          EnterCriticalSection

; 4137 :         status = requestFailed;
; 4138 :         if (m_fIsSuspend | g_fOmapEhciSuspended) {

  00038	e59fe108	 ldr         lr, [pc, #0x108]
  0003c	e5954058	 ldr         r4, [r5, #0x58]
  00040	e3a07000	 mov         r7, #0
  00044	e59ee000	 ldr         lr, [lr]
  00048	e194e00e	 orrs        lr, r4, lr
  0004c	0a000005	 beq         |$LN3@IssueTrans@2|

; 4139 :             RETAILMSG(1,(TEXT("!!!CFunction( tier %d)::IssueTransfer on suspend state is illgle, address = %d, pipe = %d\n"), m_tierNumber, address, pipeIndex));

  00050	e5d5104c	 ldrb        r1, [r5, #0x4C]
  00054	e59f00e8	 ldr         r0, [pc, #0xE8]
  00058	e1a03006	 mov         r3, r6
  0005c	e1a02008	 mov         r2, r8
  00060	eb000000	 bl          NKDbgPrintfW

; 4140 :             ASSERT(FALSE);
; 4141 :         }
; 4142 :         else

  00064	ea000030	 b           |$LN1@IssueTrans@2|
  00068		 |$LN3@IssueTrans@2|

; 4143 :         if ( pipeIndex < m_maxNumPipes && m_ppCPipe[ pipeIndex ] != NULL ) {

  00068	e5d53054	 ldrb        r3, [r5, #0x54]
  0006c	e1560003	 cmp         r6, r3
  00070	2a00002d	 bcs         |$LN1@IssueTrans@2|
  00074	e595305c	 ldr         r3, [r5, #0x5C]
  00078	e7933106	 ldr         r3, [r3, +r6, lsl #2]
  0007c	e3530000	 cmp         r3, #0
  00080	0a000029	 beq         |$LN1@IssueTrans@2|

; 4144 :             status = m_ppCPipe[ pipeIndex ]->IssueTransfer(
; 4145 :                                                         address,
; 4146 :                                                         lpStartAddress,
; 4147 :                                                         lpvNotifyParameter,
; 4148 :                                                         dwFlags,
; 4149 :                                                         lpvControlHeader,
; 4150 :                                                         dwStartingFrame,
; 4151 :                                                         dwFrames,
; 4152 :                                                         aLengths,
; 4153 :                                                         dwBufferSize,
; 4154 :                                                         lpvBuffer,
; 4155 :                                                         paBuffer,
; 4156 :                                                         lpvCancelId,
; 4157 :                                                         adwIsochErrors,
; 4158 :                                                         adwIsochLengths,
; 4159 :                                                         lpfComplete,
; 4160 :                                                         lpdwBytesTransfered,
; 4161 :                                                         lpdwError );

  00084	e59d40a4	 ldr         r4, [sp, #0xA4]
  00088	e595305c	 ldr         r3, [r5, #0x5C]
  0008c	e59d5090	 ldr         r5, [sp, #0x90]
  00090	e58d4034	 str         r4, [sp, #0x34]
  00094	e59d40a0	 ldr         r4, [sp, #0xA0]
  00098	e7930106	 ldr         r0, [r3, +r6, lsl #2]
  0009c	e59d608c	 ldr         r6, [sp, #0x8C]
  000a0	e58d4030	 str         r4, [sp, #0x30]
  000a4	e59d409c	 ldr         r4, [sp, #0x9C]
  000a8	e5903000	 ldr         r3, [r0]
  000ac	e59d7088	 ldr         r7, [sp, #0x88]
  000b0	e58d402c	 str         r4, [sp, #0x2C]
  000b4	e59d4098	 ldr         r4, [sp, #0x98]
  000b8	e593300c	 ldr         r3, [r3, #0xC]
  000bc	e59d8084	 ldr         r8, [sp, #0x84]
  000c0	e58d4028	 str         r4, [sp, #0x28]
  000c4	e59d4094	 ldr         r4, [sp, #0x94]
  000c8	e58d3040	 str         r3, [sp, #0x40]
  000cc	e59d9080	 ldr         r9, [sp, #0x80]
  000d0	e58d4024	 str         r4, [sp, #0x24]
  000d4	e59d4074	 ldr         r4, [sp, #0x74]
  000d8	e59da07c	 ldr         r10, [sp, #0x7C]
  000dc	e59db078	 ldr         r11, [sp, #0x78]
  000e0	e58d4004	 str         r4, [sp, #4]
  000e4	e59d4070	 ldr         r4, [sp, #0x70]
  000e8	e59d103c	 ldr         r1, [sp, #0x3C]
  000ec	e59d306c	 ldr         r3, [sp, #0x6C]
  000f0	e59d2038	 ldr         r2, [sp, #0x38]
  000f4	e58d4000	 str         r4, [sp]
  000f8	e59d4040	 ldr         r4, [sp, #0x40]
  000fc	e20110ff	 and         r1, r1, #0xFF
  00100	e58d5020	 str         r5, [sp, #0x20]
  00104	e58d601c	 str         r6, [sp, #0x1C]
  00108	e58d7018	 str         r7, [sp, #0x18]
  0010c	e58d8014	 str         r8, [sp, #0x14]
  00110	e58d9010	 str         r9, [sp, #0x10]
  00114	e58da00c	 str         r10, [sp, #0xC]
  00118	e58db008	 str         r11, [sp, #8]
  0011c	e1a0e00f	 mov         lr, pc
  00120	e12fff14	 bx          r4
  00124	e59d5044	 ldr         r5, [sp, #0x44]
  00128	e1a07000	 mov         r7, r0
  0012c		 |$LN1@IssueTrans@2|

; 4162 :         }
; 4163 :         LeaveCriticalSection( &m_csDeviceLock );

  0012c	e285000c	 add         r0, r5, #0xC
  00130	eb000000	 bl          LeaveCriticalSection
  00134		 |$LN4@IssueTrans@2|

; 4164 :     }
; 4165 : 
; 4166 : 
; 4167 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("-CFunction(tier %d)::IssueTransfer - returing HCD_REQUEST_STATUS %d\n"), m_tierNumber, status ) );
; 4168 :     return status;
; 4169 : }

  00134	e1a00007	 mov         r0, r7
  00138	e28dd048	 add         sp, sp, #0x48
  0013c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00140	e12fff1e	 bx          lr
  00144		 |$LN12@IssueTrans@2|
  00144		 |$LN13@IssueTrans@2|
  00144	00000000	 DCD         |??_C@_1LG@HEEINJNP@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAI?$AAs?$AAs?$AAu?$AAe?$AAT?$AAr?$AAa@|
  00148		 |$LN14@IssueTrans@2|
  00148	00000000	 DCD         |g_fOmapEhciSuspended|
  0014c		 |$M37222|

			 ENDP  ; |?IssueTransfer@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z|, CFunction::IssueTransfer

	EXPORT	|?AbortTransfer@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXQBX@Z| ; CFunction::AbortTransfer
	EXPORT	|??_C@_1LG@NLPKKFJ@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAA?$AAb?$AAo?$AAr?$AAt?$AAT?$AAr?$AAa@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T37243| DCD	|$LN11@AbortTrans@2|
	DCD	0x40002f01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1LG@NLPKKFJ@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAA?$AAb?$AAo?$AAr?$AAt?$AAT?$AAr?$AAa@| DCB "!"
	DCB	0x0, "!", 0x0, "!", 0x0, "C", 0x0, "F", 0x0, "u", 0x0, "n"
	DCB	0x0, "c", 0x0, "t", 0x0, "i", 0x0, "o", 0x0, "n", 0x0, "("
	DCB	0x0, " ", 0x0, "t", 0x0, "i", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, ")", 0x0, ":", 0x0, ":", 0x0, "A"
	DCB	0x0, "b", 0x0, "o", 0x0, "r", 0x0, "t", 0x0, "T", 0x0, "r"
	DCB	0x0, "a", 0x0, "n", 0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r"
	DCB	0x0, " ", 0x0, "o", 0x0, "n", 0x0, " ", 0x0, "s", 0x0, "u"
	DCB	0x0, "s", 0x0, "p", 0x0, "e", 0x0, "n", 0x0, "d", 0x0, " "
	DCB	0x0, "s", 0x0, "t", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, " "
	DCB	0x0, "i", 0x0, "s", 0x0, " ", 0x0, "i", 0x0, "l", 0x0, "l"
	DCB	0x0, "g", 0x0, "l", 0x0, "e", 0x0, ",", 0x0, " ", 0x0, "a"
	DCB	0x0, "d", 0x0, "d", 0x0, "r", 0x0, "e", 0x0, "s", 0x0, "s"
	DCB	0x0, " ", 0x0, "=", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ","
	DCB	0x0, " ", 0x0, "p", 0x0, "i", 0x0, "p", 0x0, "e", 0x0, " "
	DCB	0x0, "=", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AbortTransfer@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXQBX@Z| PROC ; CFunction::AbortTransfer

; 4192 : {

  00000		 |$LN11@AbortTrans@2|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M37240|
  00004	e1a09003	 mov         r9, r3
  00008	e1a06002	 mov         r6, r2
  0000c	e1a08001	 mov         r8, r1
  00010	e1a05000	 mov         r5, r0

; 4193 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("+CFunction(tier %d)::AbortTransfer - address = %d, pipe = %d\n"), m_tierNumber, address, pipeIndex) );
; 4194 : 
; 4195 :     HCD_REQUEST_STATUS status = requestIgnored;
; 4196 : 
; 4197 :     // don't have to enter critical section until after checking
; 4198 :     // m_address (since m_address is const). That ensures we
; 4199 :     // won't wait for the critical section unless we actually
; 4200 :     // have something to do
; 4201 :     if ( address == m_address ) {

  00014	e5d5e020	 ldrb        lr, [r5, #0x20]
  00018	e3a07002	 mov         r7, #2
  0001c	e158000e	 cmp         r8, lr
  00020	1a000020	 bne         |$LN4@AbortTrans@2|

; 4202 :         EnterCriticalSection( &m_csDeviceLock );

  00024	e285000c	 add         r0, r5, #0xC
  00028	eb000000	 bl          EnterCriticalSection

; 4203 :         status = requestFailed;
; 4204 :         if (m_fIsSuspend | g_fOmapEhciSuspended) {

  0002c	e59fe084	 ldr         lr, [pc, #0x84]
  00030	e5954058	 ldr         r4, [r5, #0x58]
  00034	e3a07000	 mov         r7, #0
  00038	e59ee000	 ldr         lr, [lr]
  0003c	e194e00e	 orrs        lr, r4, lr
  00040	0a000005	 beq         |$LN3@AbortTrans@2|

; 4205 :             RETAILMSG(1,(TEXT("!!!CFunction( tier %d)::AbortTransfer on suspend state is illgle, address = %d, pipe = %d\n"), m_tierNumber, address, pipeIndex));

  00044	e5d5104c	 ldrb        r1, [r5, #0x4C]
  00048	e59f0064	 ldr         r0, [pc, #0x64]
  0004c	e1a03006	 mov         r3, r6
  00050	e1a02008	 mov         r2, r8
  00054	eb000000	 bl          NKDbgPrintfW

; 4206 :             ASSERT(FALSE);
; 4207 :             }
; 4208 :         else {

  00058	ea000010	 b           |$LN1@AbortTrans@2|
  0005c		 |$LN3@AbortTrans@2|

; 4209 :             if( pipeIndex < m_maxNumPipes && m_ppCPipe[ pipeIndex ] != NULL )

  0005c	e5d53054	 ldrb        r3, [r5, #0x54]
  00060	e1560003	 cmp         r6, r3
  00064	2a00000d	 bcs         |$LN1@AbortTrans@2|
  00068	e595305c	 ldr         r3, [r5, #0x5C]
  0006c	e7933106	 ldr         r3, [r3, +r6, lsl #2]
  00070	e3530000	 cmp         r3, #0
  00074	0a000009	 beq         |$LN1@AbortTrans@2|

; 4210 :             status = m_ppCPipe[ pipeIndex ]->AbortTransfer( lpCancelAddress,
; 4211 :                                                             lpvNotifyParameter,
; 4212 :                                                             lpvCancelId );

  00078	e595105c	 ldr         r1, [r5, #0x5C]
  0007c	e59d3020	 ldr         r3, [sp, #0x20]
  00080	e59d201c	 ldr         r2, [sp, #0x1C]
  00084	e7910106	 ldr         r0, [r1, +r6, lsl #2]
  00088	e1a01009	 mov         r1, r9
  0008c	e5904000	 ldr         r4, [r0]
  00090	e5944010	 ldr         r4, [r4, #0x10]
  00094	e1a0e00f	 mov         lr, pc
  00098	e12fff14	 bx          r4
  0009c	e1a07000	 mov         r7, r0
  000a0		 |$LN1@AbortTrans@2|

; 4213 :         }
; 4214 :         LeaveCriticalSection( &m_csDeviceLock );

  000a0	e285000c	 add         r0, r5, #0xC
  000a4	eb000000	 bl          LeaveCriticalSection
  000a8		 |$LN4@AbortTrans@2|

; 4215 :     }
; 4216 : 
; 4217 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("-CFunction(tier %d)::AbortTransfer - address = %d, pipe = %d, returing HCD_REQUEST_STATUS %d\n"), m_tierNumber, address, pipeIndex, status) );
; 4218 :     return status;
; 4219 : }

  000a8	e1a00007	 mov         r0, r7
  000ac	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000b0	e12fff1e	 bx          lr
  000b4		 |$LN12@AbortTrans@2|
  000b4		 |$LN13@AbortTrans@2|
  000b4	00000000	 DCD         |??_C@_1LG@NLPKKFJ@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAA?$AAb?$AAo?$AAr?$AAt?$AAT?$AAr?$AAa@|
  000b8		 |$LN14@AbortTrans@2|
  000b8	00000000	 DCD         |g_fOmapEhciSuspended|
  000bc		 |$M37241|

			 ENDP  ; |?AbortTransfer@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXQBX@Z|, CFunction::AbortTransfer

	EXPORT	|?IsPipeHalted@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQAH@Z| ; CFunction::IsPipeHalted
	EXPORT	|??_C@_1LE@DHENCBPM@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAI?$AAs?$AAP?$AAi?$AAp?$AAe?$AAH?$AAa@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T37262| DCD	|$LN11@IsPipeHalt@2|
	DCD	0x40002d01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1LE@DHENCBPM@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAI?$AAs?$AAP?$AAi?$AAp?$AAe?$AAH?$AAa@| DCB "!"
	DCB	0x0, "!", 0x0, "!", 0x0, "C", 0x0, "F", 0x0, "u", 0x0, "n"
	DCB	0x0, "c", 0x0, "t", 0x0, "i", 0x0, "o", 0x0, "n", 0x0, "("
	DCB	0x0, " ", 0x0, "t", 0x0, "i", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, ")", 0x0, ":", 0x0, ":", 0x0, "I"
	DCB	0x0, "s", 0x0, "P", 0x0, "i", 0x0, "p", 0x0, "e", 0x0, "H"
	DCB	0x0, "a", 0x0, "l", 0x0, "t", 0x0, "e", 0x0, "d", 0x0, " "
	DCB	0x0, "o", 0x0, "n", 0x0, " ", 0x0, "s", 0x0, "u", 0x0, "s"
	DCB	0x0, "p", 0x0, "e", 0x0, "n", 0x0, "d", 0x0, " ", 0x0, "s"
	DCB	0x0, "t", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, " ", 0x0, "i"
	DCB	0x0, "s", 0x0, " ", 0x0, "i", 0x0, "l", 0x0, "l", 0x0, "g"
	DCB	0x0, "l", 0x0, "e", 0x0, ",", 0x0, " ", 0x0, "a", 0x0, "d"
	DCB	0x0, "d", 0x0, "r", 0x0, "e", 0x0, "s", 0x0, "s", 0x0, " "
	DCB	0x0, "=", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ",", 0x0, " "
	DCB	0x0, "p", 0x0, "i", 0x0, "p", 0x0, "e", 0x0, " ", 0x0, "="
	DCB	0x0, " ", 0x0, "%", 0x0, "d", 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsPipeHalted@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQAH@Z| PROC ; CFunction::IsPipeHalted

; 4240 : {

  00000		 |$LN11@IsPipeHalt@2|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M37259|
  00004	e1a09003	 mov         r9, r3
  00008	e1a06002	 mov         r6, r2
  0000c	e1a08001	 mov         r8, r1
  00010	e1a05000	 mov         r5, r0

; 4241 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("+CFunction(tier %d)::IsPipeHalted - address = %d, pipe = %d\n"), m_tierNumber, address, pipeIndex) );
; 4242 : 
; 4243 :     HCD_REQUEST_STATUS status = requestIgnored;
; 4244 : 
; 4245 :     // don't have to enter critical section until after checking
; 4246 :     // m_address (since m_address is const). That ensures we
; 4247 :     // won't wait for the critical section unless we actually
; 4248 :     // have something to do
; 4249 :     if ( address == m_address ) {

  00014	e5d5e020	 ldrb        lr, [r5, #0x20]
  00018	e3a07002	 mov         r7, #2
  0001c	e158000e	 cmp         r8, lr
  00020	1a00001e	 bne         |$LN4@IsPipeHalt@2|

; 4250 :         EnterCriticalSection( &m_csDeviceLock );

  00024	e285000c	 add         r0, r5, #0xC
  00028	eb000000	 bl          EnterCriticalSection

; 4251 :         status = requestFailed;
; 4252 :         if (m_fIsSuspend | g_fOmapEhciSuspended) {

  0002c	e59fe07c	 ldr         lr, [pc, #0x7C]
  00030	e5954058	 ldr         r4, [r5, #0x58]
  00034	e3a07000	 mov         r7, #0
  00038	e59ee000	 ldr         lr, [lr]
  0003c	e194e00e	 orrs        lr, r4, lr
  00040	0a000005	 beq         |$LN3@IsPipeHalt@2|

; 4253 :             RETAILMSG(1,(TEXT("!!!CFunction( tier %d)::IsPipeHalted on suspend state is illgle, address = %d, pipe = %d\n"), m_tierNumber, address, pipeIndex));

  00044	e5d5104c	 ldrb        r1, [r5, #0x4C]
  00048	e59f005c	 ldr         r0, [pc, #0x5C]
  0004c	e1a03006	 mov         r3, r6
  00050	e1a02008	 mov         r2, r8
  00054	eb000000	 bl          NKDbgPrintfW

; 4254 :             ASSERT(FALSE);
; 4255 :         }
; 4256 :         else

  00058	ea00000e	 b           |$LN1@IsPipeHalt@2|
  0005c		 |$LN3@IsPipeHalt@2|

; 4257 :         if ( pipeIndex < m_maxNumPipes && m_ppCPipe[ pipeIndex ] != NULL ) {

  0005c	e5d53054	 ldrb        r3, [r5, #0x54]
  00060	e1560003	 cmp         r6, r3
  00064	2a00000b	 bcs         |$LN1@IsPipeHalt@2|
  00068	e595305c	 ldr         r3, [r5, #0x5C]
  0006c	e7933106	 ldr         r3, [r3, +r6, lsl #2]
  00070	e3530000	 cmp         r3, #0
  00074	0a000007	 beq         |$LN1@IsPipeHalt@2|

; 4258 :             status = m_ppCPipe[ pipeIndex ]->IsPipeHalted( lpbHalted );

  00078	e595305c	 ldr         r3, [r5, #0x5C]
  0007c	e1a01009	 mov         r1, r9
  00080	e7930106	 ldr         r0, [r3, +r6, lsl #2]
  00084	e5903000	 ldr         r3, [r0]
  00088	e5933014	 ldr         r3, [r3, #0x14]
  0008c	e1a0e00f	 mov         lr, pc
  00090	e12fff13	 bx          r3
  00094	e1a07000	 mov         r7, r0
  00098		 |$LN1@IsPipeHalt@2|

; 4259 :         }
; 4260 :         LeaveCriticalSection( &m_csDeviceLock );

  00098	e285000c	 add         r0, r5, #0xC
  0009c	eb000000	 bl          LeaveCriticalSection
  000a0		 |$LN4@IsPipeHalt@2|

; 4261 :     }
; 4262 : 
; 4263 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("-CFunction(tier %d)::IsPipeHalted - address = %d, pipe = %d, returing HCD_REQUEST_STATUS %d\n"), m_tierNumber, address, pipeIndex, status) );
; 4264 :     return status;
; 4265 : }

  000a0	e1a00007	 mov         r0, r7
  000a4	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000a8	e12fff1e	 bx          lr
  000ac		 |$LN12@IsPipeHalt@2|
  000ac		 |$LN13@IsPipeHalt@2|
  000ac	00000000	 DCD         |??_C@_1LE@DHENCBPM@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAI?$AAs?$AAP?$AAi?$AAp?$AAe?$AAH?$AAa@|
  000b0		 |$LN14@IsPipeHalt@2|
  000b0	00000000	 DCD         |g_fOmapEhciSuspended|
  000b4		 |$M37260|

			 ENDP  ; |?IsPipeHalted@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQAH@Z|, CFunction::IsPipeHalted

	EXPORT	|?HandleDetach@CFunction@@EAAXXZ|	; CFunction::HandleDetach
	IMPORT	|__C_specific_handler|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T37304| DCD	|$LN30@HandleDeta@2|
	DCD	0xc0003c03

  00000			 AREA	 |.pdata|, PDATA
|$T37306| DCD	|$LN12@HandleDeta@2|
	DCD	0x40000301

  00000			 AREA	 |.xdata|, DATA
|$T37302| DCD	0x1
	DCD	|$LN16@HandleDeta@2|
	DCD	|$LN17@HandleDeta@2|
	DCD	|$LN12@HandleDeta@2|
	DCD	|$LN13@HandleDeta@2|
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T37302|

  00008		 |?HandleDetach@CFunction@@EAAXXZ| PROC	; CFunction::HandleDetach

; 4337 : {

  00008		 |$LN30@HandleDeta@2|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d58f0	 stmdb       sp!, {r4 - r7, r11, r12, lr}
  00010	e28db01c	 add         r11, sp, #0x1C
  00014		 |$LN28@HandleDeta@2|
  00014	e1a04000	 mov         r4, r0

; 4338 :     DEBUGMSG( ZONE_ATTACH || ZONE_FUNCTION, (TEXT("+CFunction(tier %d)::HandleDetach\n"), m_tierNumber) );
; 4339 : 
; 4340 :     EnterCriticalSection( &m_csDeviceLock );

  00018	e284000c	 add         r0, r4, #0xC
  0001c	eb000000	 bl          EnterCriticalSection

; 4341 : 
; 4342 :     PREFAST_DEBUGCHK( m_ppCPipe != NULL );
; 4343 :     DEBUGCHK( m_maxNumPipes > 0 &&
; 4344 :               m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ] != NULL );
; 4345 : 
; 4346 :     for ( UCHAR pipe = 0; pipe < m_maxNumPipes; pipe++ ) {

  00020	e5d43054	 ldrb        r3, [r4, #0x54]
  00024	e3a06000	 mov         r6, #0
  00028	e3530000	 cmp         r3, #0
  0002c	e3a05000	 mov         r5, #0
  00030	0a00001a	 beq         |$LN4@HandleDeta@2|
  00034	e3a07000	 mov         r7, #0
  00038		 |$LL6@HandleDeta@2|

; 4347 :         if ( m_ppCPipe[ pipe ] != NULL ) {

  00038	e594305c	 ldr         r3, [r4, #0x5C]
  0003c	e1a02106	 mov         r2, r6, lsl #2
  00040	e7b23003	 ldr         r3, [r2, +r3]!
  00044	e3530000	 cmp         r3, #0
  00048	0a00000e	 beq         |$LN5@HandleDeta@2|

; 4348 :             m_ppCPipe[ pipe ]->ClosePipe();

  0004c	e5920000	 ldr         r0, [r2]
  00050	e5903000	 ldr         r3, [r0]
  00054	e5933008	 ldr         r3, [r3, #8]
  00058	e1a0e00f	 mov         lr, pc
  0005c	e12fff13	 bx          r3

; 4349 :             delete m_ppCPipe[ pipe ];

  00060	e594305c	 ldr         r3, [r4, #0x5C]
  00064	e7933106	 ldr         r3, [r3, +r6, lsl #2]
  00068	e1b00003	 movs        r0, r3
  0006c	15903000	 ldrne       r3, [r0]
  00070	13a01001	 movne       r1, #1
  00074	15933000	 ldrne       r3, [r3]
  00078	11a0e00f	 movne       lr, pc
  0007c	112fff13	 bxne        r3

; 4350 :             m_ppCPipe[ pipe ] = NULL;

  00080	e594305c	 ldr         r3, [r4, #0x5C]
  00084	e7835106	 str         r5, [r3, +r6, lsl #2]
  00088		 |$LN5@HandleDeta@2|
  00088	e5d42054	 ldrb        r2, [r4, #0x54]
  0008c	e2873001	 add         r3, r7, #1
  00090	e20360ff	 and         r6, r3, #0xFF
  00094	e1a07006	 mov         r7, r6
  00098	e1560002	 cmp         r6, r2
  0009c	3affffe5	 bcc         |$LL6@HandleDeta@2|
  000a0		 |$LN4@HandleDeta@2|

; 4351 :         }
; 4352 :     }
; 4353 :     // m_ppCPipe[] freed in ~CDevice
; 4354 : 
; 4355 :     DEBUGCHK( m_pCHcd->GetpUSBDDetachProc() != NULL );
; 4356 :     DEBUGCHK( m_lpvDetachId != NULL );
; 4357 : 
; 4358 :     if(m_hFunctionFeatureEvent) {

  000a0	e5943064	 ldr         r3, [r4, #0x64]
  000a4	e3530000	 cmp         r3, #0
  000a8	0a000004	 beq         |$LN2@HandleDeta@2|

; 4359 :         SetEvent(m_hFunctionFeatureEvent);

  000ac	e3a01003	 mov         r1, #3
  000b0	e1a00003	 mov         r0, r3
  000b4	eb000000	 bl          EventModify

; 4360 :         CloseHandle(m_hFunctionFeatureEvent);

  000b8	e5940064	 ldr         r0, [r4, #0x64]
  000bc	eb000000	 bl          CloseHandle
  000c0		 |$LN2@HandleDeta@2|

; 4361 :     }
; 4362 :     m_hFunctionFeatureEvent = NULL;
; 4363 : 
; 4364 :     LPVOID lpvDetachId = m_lpvDetachId;

  000c0	e5946060	 ldr         r6, [r4, #0x60]

; 4365 :     m_lpvDetachId = NULL;
; 4366 : 
; 4367 :     LeaveCriticalSection( &m_csDeviceLock );

  000c4	e284000c	 add         r0, r4, #0xC
  000c8	e5845060	 str         r5, [r4, #0x60]
  000cc	e5845064	 str         r5, [r4, #0x64]
  000d0	eb000000	 bl          LeaveCriticalSection
  000d4		 |$LN16@HandleDeta@2|

; 4368 : 
; 4369 :     // Inform USBD of device detach, so the message can be passed
; 4370 :     // along to the client driver.
; 4371 : #pragma prefast(disable: 322, "Recover gracefully from hardware failure")
; 4372 :     __try {
; 4373 :         (*m_pCHcd->GetpUSBDDetachProc())(lpvDetachId);

  000d4	e5943068	 ldr         r3, [r4, #0x68]
  000d8	e1a00006	 mov         r0, r6
  000dc	e5933080	 ldr         r3, [r3, #0x80]
  000e0	e1a0e00f	 mov         lr, pc
  000e4	e12fff13	 bx          r3
  000e8		 |$LN17@HandleDeta@2|
  000e8	eaffffff	 b           |$LN18@HandleDeta@2|
  000ec		 |$LN13@HandleDeta@2|
  000ec		 |$LN18@HandleDeta@2|

; 4375 :     }
; 4376 : #pragma prefast(pop)
; 4377 : 
; 4378 :     DEBUGMSG( ZONE_ATTACH || ZONE_FUNCTION, (TEXT("-CFunction(tier %d)::HandleDetach\n"), m_tierNumber) );
; 4379 : }

  000ec	e24bd01c	 sub         sp, r11, #0x1C
  000f0	e89d68f0	 ldmia       sp, {r4 - r7, r11, sp, lr}
  000f4	e12fff1e	 bx          lr

			 ENDP  ; |?HandleDetach@CFunction@@EAAXXZ|, CFunction::HandleDetach

  000f8		 |$LN12@HandleDeta@2|
  000f8		 |$LN29@HandleDeta@2|

; 4374 :     } __except( EXCEPTION_EXECUTE_HANDLER ) {

  000f8	e52de004	 str         lr, [sp, #-4]!
  000fc		 |$LN15@HandleDeta@2|
  000fc		 |$LN32@HandleDeta@2|
  000fc	e3a00001	 mov         r0, #1
  00100		 |$LN14@HandleDeta@2|
  00100	e49df004	 ldr         pc, [sp], #4
  00104		 |$LN33@HandleDeta@2|
  00104		 |$LN31@HandleDeta@2|
	EXPORT	|?SetOrClearFeature@CFunction@@AAAHEGEG@Z| ; CFunction::SetOrClearFeature
	EXPORT	|??_C@_1KI@NHPPIIBA@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAS?$AAe?$AAt?$AAO?$AAr?$AAC?$AAl?$AAe@| [ DATA ] ; `string'
; File c:\wince600\osdesigns\z2170p\z2170p\wince600\z2170p_armv4i\cesysgen\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T37334| DCD	|$LN17@SetOrClear@5|
	DCD	0x40006802

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1KI@NHPPIIBA@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAS?$AAe?$AAt?$AAO?$AAr?$AAC?$AAl?$AAe@| DCB "!"
	DCB	0x0, "!", 0x0, "!", 0x0, "C", 0x0, "F", 0x0, "u", 0x0, "n"
	DCB	0x0, "c", 0x0, "t", 0x0, "i", 0x0, "o", 0x0, "n", 0x0, "("
	DCB	0x0, " ", 0x0, "t", 0x0, "i", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, ")", 0x0, ":", 0x0, ":", 0x0, "S"
	DCB	0x0, "e", 0x0, "t", 0x0, "O", 0x0, "r", 0x0, "C", 0x0, "l"
	DCB	0x0, "e", 0x0, "a", 0x0, "r", 0x0, "F", 0x0, "e", 0x0, "a"
	DCB	0x0, "t", 0x0, "u", 0x0, "r", 0x0, "e", 0x0, " ", 0x0, "o"
	DCB	0x0, "n", 0x0, " ", 0x0, "s", 0x0, "u", 0x0, "s", 0x0, "p"
	DCB	0x0, "e", 0x0, "n", 0x0, "d", 0x0, " ", 0x0, "s", 0x0, "t"
	DCB	0x0, "a", 0x0, "t", 0x0, "e", 0x0, " ", 0x0, "i", 0x0, "s"
	DCB	0x0, " ", 0x0, "i", 0x0, "l", 0x0, "l", 0x0, "g", 0x0, "l"
	DCB	0x0, "e", 0x0, ",", 0x0, " ", 0x0, "a", 0x0, "d", 0x0, "d"
	DCB	0x0, "r", 0x0, "e", 0x0, "s", 0x0, "s", 0x0, " ", 0x0, "="
	DCB	0x0, " ", 0x0, "%", 0x0, "d", 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetOrClearFeature@CFunction@@AAAHEGEG@Z| PROC ; CFunction::SetOrClearFeature

; 4403 : {

  00000		 |$LN17@SetOrClear@5|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd04c	 sub         sp, sp, #0x4C
  00008		 |$M37331|
  00008	e1a09000	 mov         r9, r0

; 4404 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("+CFunction::SetOrClearFeature - recipient = %d, wIndex = %d, set/clear = 0x%x, feature = 0x%x\n"), recipient, wIndex, setOrClearFeature, feature) );
; 4405 : 
; 4406 : #ifdef DEBUG
; 4407 :     {
; 4408 :     switch(recipient) {
; 4409 :             case USB_DEVICE_RECIPIENT:
; 4410 :                 // USB spec 1.1, 9.4 - there is only one
; 4411 :                 // features which should be set or cleared for ports
; 4412 :                 DEBUGCHK( wIndex == 0 && feature == USB_DEVICE_REMOTE_WAKEUP );
; 4413 :                 break;
; 4414 :             case USB_ENDPOINT_RECIPIENT:
; 4415 :                 // USB spec 1.1, 9.4 - there is only one
; 4416 :                 // features which should be set or cleared for endpoints
; 4417 :                 DEBUGCHK( feature == USB_FEATURE_ENDPOINT_HALT );
; 4418 :                 break;
; 4419 :             case USB_INTERFACE_RECIPIENT:
; 4420 :                 // USB spec 1.1, 9.4 - there are not features available at this time
; 4421 :                 DEBUGCHK( 0);
; 4422 :                 break;
; 4423 :             default:
; 4424 :                 DEBUGCHK(0);
; 4425 :     }
; 4426 :         DEBUGCHK( m_ppCPipe != NULL && m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ] != NULL);
; 4427 :     }
; 4428 : #endif // DEBUG
; 4429 : 
; 4430 :     BOOL                fTransferDone = FALSE;
; 4431 :     DWORD               dwBytesTransferred = 0;
; 4432 :     DWORD               dwErrorFlags = USB_NOT_COMPLETE_ERROR;
; 4433 :     HCD_REQUEST_STATUS  status = requestFailed;
; 4434 :     USB_DEVICE_REQUEST  usbRequest;
; 4435 : 
; 4436 :     usbRequest.bmRequestType = recipient;
; 4437 :     usbRequest.bRequest = setOrClearFeature;
; 4438 :     usbRequest.wValue = feature;

  0000c	e1dd47b0	 ldrh        r4, [sp, #0x70]
  00010	e3a00c01	 mov         r0, #1, 24

; 4439 :     usbRequest.wIndex = wIndex;
; 4440 :     usbRequest.wLength = 0;
; 4441 :     PREFAST_DEBUGCHK(m_ppCPipe!=NULL);
; 4442 :     EnterCriticalSection( &m_csDeviceLock );

  00014	e3a05000	 mov         r5, #0
  00018	e380e003	 orr         lr, r0, #3
  0001c	e3a06000	 mov         r6, #0
  00020	e3a07000	 mov         r7, #0
  00024	e289000c	 add         r0, r9, #0xC
  00028	e58d5038	 str         r5, [sp, #0x38]
  0002c	e58de040	 str         lr, [sp, #0x40]
  00030	e1cd44b6	 strh        r4, [sp, #0x46]
  00034	e58d603c	 str         r6, [sp, #0x3C]
  00038	e3a05000	 mov         r5, #0
  0003c	e5cd1044	 strb        r1, [sp, #0x44]
  00040	e5cd3045	 strb        r3, [sp, #0x45]
  00044	e1cd24b8	 strh        r2, [sp, #0x48]
  00048	e1cd74ba	 strh        r7, [sp, #0x4A]
  0004c	eb000000	 bl          EnterCriticalSection

; 4443 :     if (m_fIsSuspend | g_fOmapEhciSuspended) {

  00050	e59f3144	 ldr         r3, [pc, #0x144]
  00054	e5992058	 ldr         r2, [r9, #0x58]
  00058	e5933000	 ldr         r3, [r3]
  0005c	e1923003	 orrs        r3, r2, r3
  00060	0a000004	 beq         |$LN6@SetOrClear@5|

; 4444 :         RETAILMSG(1,(TEXT("!!!CFunction( tier %d)::SetOrClearFeature on suspend state is illgle, address = %d\n"), m_tierNumber, m_address));

  00064	e5d92020	 ldrb        r2, [r9, #0x20]
  00068	e5d9104c	 ldrb        r1, [r9, #0x4C]
  0006c	e59f0124	 ldr         r0, [pc, #0x124]
  00070	eb000000	 bl          NKDbgPrintfW

; 4445 :         ASSERT(FALSE);
; 4446 :     }
; 4447 :     else {

  00074	ea000035	 b           |$LN13@SetOrClear@5|
  00078		 |$LN6@SetOrClear@5|

; 4448 :         status = m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ]->IssueTransfer(
; 4449 :                          m_address, // address of this function
; 4450 :                          TransferDoneCallbackSetEvent, // callback func
; 4451 :                          m_hFunctionFeatureEvent, // callback param
; 4452 :                          USB_OUT_TRANSFER | USB_SEND_TO_DEVICE, // transfer flags
; 4453 :                          &usbRequest, // control request
; 4454 :                          0, // dwStartingFrame (not used)
; 4455 :                          0, // dwFrames (not used)
; 4456 :                          NULL, // aLengths (not used)
; 4457 :                          0, // buffer size
; 4458 :                          NULL, // buffer
; 4459 :                          0, // phys addr of buffer (not used)
; 4460 :                          this, // cancel id
; 4461 :                          NULL, // adwIsochErrors (not used)
; 4462 :                          NULL, // adwIsochLengths (not used)
; 4463 :                          &fTransferDone, // OUT param for transfer
; 4464 :                          &dwBytesTransferred, // OUT param for transfer
; 4465 :                          &dwErrorFlags ); // OUT param for transfer

  00078	e599105c	 ldr         r1, [r9, #0x5C]
  0007c	e5993064	 ldr         r3, [r9, #0x64]
  00080	e59f210c	 ldr         r2, [pc, #0x10C]
  00084	e5910000	 ldr         r0, [r1]
  00088	e5d91020	 ldrb        r1, [r9, #0x20]
  0008c	e28d6040	 add         r6, sp, #0x40
  00090	e590e000	 ldr         lr, [r0]
  00094	e28d403c	 add         r4, sp, #0x3C
  00098	e28d5038	 add         r5, sp, #0x38
  0009c	e59e800c	 ldr         r8, [lr, #0xC]
  000a0	e28d7044	 add         r7, sp, #0x44
  000a4	e3a0ba01	 mov         r11, #1, 20
  000a8	e3a0a000	 mov         r10, #0
  000ac	e58d6034	 str         r6, [sp, #0x34]
  000b0	e58d4030	 str         r4, [sp, #0x30]
  000b4	e58d502c	 str         r5, [sp, #0x2C]
  000b8	e58da028	 str         r10, [sp, #0x28]
  000bc	e58da024	 str         r10, [sp, #0x24]
  000c0	e58d9020	 str         r9, [sp, #0x20]
  000c4	e58da01c	 str         r10, [sp, #0x1C]
  000c8	e58da018	 str         r10, [sp, #0x18]
  000cc	e58da014	 str         r10, [sp, #0x14]
  000d0	e58da010	 str         r10, [sp, #0x10]
  000d4	e58da00c	 str         r10, [sp, #0xC]
  000d8	e58da008	 str         r10, [sp, #8]
  000dc	e58d7004	 str         r7, [sp, #4]
  000e0	e58db000	 str         r11, [sp]
  000e4	e1a0e00f	 mov         lr, pc
  000e8	e12fff18	 bx          r8
  000ec	e1a05000	 mov         r5, r0

; 4466 :         if ( status == requestOK ) {

  000f0	e3550001	 cmp         r5, #1
  000f4	1a000015	 bne         |$LN13@SetOrClear@5|

; 4467 :             DWORD dwReturn = WaitForSingleObject( m_hFunctionFeatureEvent, STANDARD_REQUEST_TIMEOUT );

  000f8	e5990064	 ldr         r0, [r9, #0x64]
  000fc	e3a01ffa	 mov         r1, #0xFA, 30
  00100	eb000000	 bl          WaitForSingleObject

; 4468 :             DEBUGCHK( fTransferDone );
; 4469 :             if (!fTransferDone || dwReturn!= WAIT_OBJECT_0) {

  00104	e59d3038	 ldr         r3, [sp, #0x38]
  00108	e3530000	 cmp         r3, #0
  0010c	0a000001	 beq         |$LN2@SetOrClear@5|
  00110	e3500000	 cmp         r0, #0
  00114	0a00000d	 beq         |$LN13@SetOrClear@5|
  00118		 |$LN2@SetOrClear@5|

; 4470 :                 HCD_REQUEST_STATUS abortStatus = m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ]->AbortTransfer(NULL, NULL, this );

  00118	e599105c	 ldr         r1, [r9, #0x5C]
  0011c	e1a03009	 mov         r3, r9
  00120	e3a02000	 mov         r2, #0
  00124	e5910000	 ldr         r0, [r1]
  00128	e3a01000	 mov         r1, #0
  0012c	e5904000	 ldr         r4, [r0]
  00130	e5944010	 ldr         r4, [r4, #0x10]
  00134	e1a0e00f	 mov         lr, pc
  00138	e12fff14	 bx          r4

; 4471 :                 ASSERT(abortStatus == requestOK);
; 4472 :                 if (m_hFunctionFeatureEvent)

  0013c	e5993064	 ldr         r3, [r9, #0x64]
  00140	e3530000	 cmp         r3, #0

; 4473 :                     ResetEvent(m_hFunctionFeatureEvent);

  00144	13a01002	 movne       r1, #2
  00148	11a00003	 movne       r0, r3
  0014c	1b000000	 blne        EventModify
  00150		 |$LN13@SetOrClear@5|

; 4474 :             }
; 4475 :         }
; 4476 :     }
; 4477 :     LeaveCriticalSection( &m_csDeviceLock );

  00150	e289000c	 add         r0, r9, #0xC
  00154	eb000000	 bl          LeaveCriticalSection

; 4478 : 
; 4479 :     BOOL fSuccess = (status == requestOK &&
; 4480 :                      fTransferDone &&
; 4481 :                      dwBytesTransferred == 0 &&
; 4482 :                      dwErrorFlags == USB_NO_ERROR);

  00158	e3550001	 cmp         r5, #1
  0015c	1a000008	 bne         |$LN11@SetOrClear@5|
  00160	e59d3038	 ldr         r3, [sp, #0x38]
  00164	e3530000	 cmp         r3, #0
  00168	0a000005	 beq         |$LN11@SetOrClear@5|
  0016c	e59d303c	 ldr         r3, [sp, #0x3C]
  00170	e3530000	 cmp         r3, #0
  00174	059d3040	 ldreq       r3, [sp, #0x40]
  00178	03530000	 cmpeq       r3, #0
  0017c	03a00001	 moveq       r0, #1
  00180	0a000000	 beq         |$LN12@SetOrClear@5|
  00184		 |$LN11@SetOrClear@5|
  00184	e3a00000	 mov         r0, #0
  00188		 |$LN12@SetOrClear@5|

; 4483 : 
; 4484 :     DEBUGMSG( ZONE_ERROR && !fSuccess, (TEXT("CFunction::SetOrClearFeature - recipient = %d, wIndex = %d, set/clear = 0x%x, feature = 0x%x, FAILED\n"), recipient, wIndex, setOrClearFeature, feature ) );
; 4485 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CFunction::SetOrClearFeature - recipient = %d, wIndex = %d, set/clear = 0x%x, feature = 0x%x, returing BOOL %d\n"), recipient, wIndex, setOrClearFeature, feature, fSuccess) );
; 4486 :     return fSuccess;
; 4487 : }

  00188	e28dd04c	 add         sp, sp, #0x4C
  0018c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00190	e12fff1e	 bx          lr
  00194		 |$LN18@SetOrClear@5|
  00194		 |$LN19@SetOrClear@5|
  00194	00000000	 DCD         |?TransferDoneCallbackSetEvent@CDevice@@KAKPAX@Z|
  00198		 |$LN20@SetOrClear@5|
  00198	00000000	 DCD         |??_C@_1KI@NHPPIIBA@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAS?$AAe?$AAt?$AAO?$AAr?$AAC?$AAl?$AAe@|
  0019c		 |$LN21@SetOrClear@5|
  0019c	00000000	 DCD         |g_fOmapEhciSuspended|
  001a0		 |$M37332|

			 ENDP  ; |?SetOrClearFeature@CFunction@@AAAHEGEG@Z|, CFunction::SetOrClearFeature

	EXPORT	|?ReserveAddress@CDevice@@QAAHAAE@Z|	; CDevice::ReserveAddress
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T37349| DCD	|$LN5@ReserveAdd@2|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ReserveAddress@CDevice@@QAAHAAE@Z| PROC ; CDevice::ReserveAddress

; 223  :     BOOL ReserveAddress( OUT UCHAR& rAddress ) { return m_pDeviceGlobal->ReserveAddress(rAddress); };

  00000		 |$LN5@ReserveAdd@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37346|
  00004	e5900050	 ldr         r0, [r0, #0x50]
  00008	eb000000	 bl          |?ReserveAddress@CDeviceGlobal@@QAAHAAE@Z|
  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M37347|

			 ENDP  ; |?ReserveAddress@CDevice@@QAAHAAE@Z|, CDevice::ReserveAddress

	EXPORT	|?FreeAddress@CDevice@@QAAXE@Z|		; CDevice::FreeAddress

  00000			 AREA	 |.pdata|, PDATA
|$T37358| DCD	|$LN5@FreeAddres@2|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FreeAddress@CDevice@@QAAXE@Z| PROC	; CDevice::FreeAddress

; 224  :     void  FreeAddress( IN const UCHAR address ) { m_pDeviceGlobal->FreeAddress(address); };

  00000		 |$LN5@FreeAddres@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37355|
  00004	e5900050	 ldr         r0, [r0, #0x50]
  00008	eb000000	 bl          |?FreeAddress@CDeviceGlobal@@QAAXE@Z|
  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M37356|

			 ENDP  ; |?FreeAddress@CDevice@@QAAXE@Z|, CDevice::FreeAddress

	EXPORT	|??1CDeviceGlobal@@QAA@XZ|		; CDeviceGlobal::~CDeviceGlobal
	IMPORT	|??1CritSec_Ex@@QAA@XZ|			; CritSec_Ex::~CritSec_Ex
	IMPORT	|??1Countdown@@QAA@XZ|			; Countdown::~Countdown
	IMPORT	|DeleteCriticalSection|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T37366| DCD	|$LN5@CDeviceGlo@2|
	DCD	0x40000e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CDeviceGlobal@@QAA@XZ| PROC	; CDeviceGlobal::~CDeviceGlobal

; 66   : {

  00000		 |$LN5@CDeviceGlo@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37363|
  00004	e1a04000	 mov         r4, r0
  00008	e59f3024	 ldr         r3, [pc, #0x24]

; 67   :     DeInitialize();

  0000c	e5843000	 str         r3, [r4]
  00010	eb000000	 bl          |?DeInitialize@CDeviceGlobal@@QAAXXZ|

; 68   :     // all devices, and hence all addresses, should have been freed by now
; 69   :     DeleteCriticalSection( &m_csFreeAddressArrayLock );

  00014	e2840008	 add         r0, r4, #8
  00018	eb000000	 bl          DeleteCriticalSection

; 70   :     //DeleteCritSec_Ex( &m_csAddress0Lock );
; 71   : }

  0001c	e2840054	 add         r0, r4, #0x54
  00020	eb000000	 bl          |??1Countdown@@QAA@XZ|
  00024	e284002c	 add         r0, r4, #0x2C
  00028	eb000000	 bl          |??1CritSec_Ex@@QAA@XZ|
  0002c	e8bd4010	 ldmia       sp!, {r4, lr}
  00030	e12fff1e	 bx          lr
  00034		 |$LN6@CDeviceGlo@2|
  00034		 |$LN7@CDeviceGlo@2|
  00034	00000000	 DCD         |??_7CDeviceGlobal@@6B@|
  00038		 |$M37364|

			 ENDP  ; |??1CDeviceGlobal@@QAA@XZ|, CDeviceGlobal::~CDeviceGlobal

	EXPORT	|??1CDevice@@UAA@XZ|			; CDevice::~CDevice
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T37385| DCD	|$LN13@CDevice@2|
	DCD	0x40002601
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CDevice@@UAA@XZ| PROC		; CDevice::~CDevice

; 358  : {

  00000		 |$LN13@CDevice@2|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M37382|
  00004	e1a04000	 mov         r4, r0
  00008	e59f3084	 ldr         r3, [pc, #0x84]

; 359  :     DEBUGMSG( ZONE_DEVICE && ZONE_VERBOSE, (TEXT("+CDevice::~CDevice\n")) );
; 360  : 
; 361  :     // delete m_deviceInfo structure
; 362  :     if ( m_deviceInfo.lpConfigs != NULL ) {

  0000c	e594203c	 ldr         r2, [r4, #0x3C]
  00010	e3a07000	 mov         r7, #0
  00014	e5843000	 str         r3, [r4]
  00018	e3520000	 cmp         r2, #0
  0001c	0a000010	 beq         |$LN4@CDevice@2|

; 363  :         DEBUGCHK( m_deviceInfo.Descriptor.bDescriptorType == USB_DEVICE_DESCRIPTOR_TYPE &&
; 364  :                   m_deviceInfo.Descriptor.bLength == sizeof( USB_DEVICE_DESCRIPTOR ) &&
; 365  :                   m_deviceInfo.dwCount == sizeof( USB_DEVICE_INFO ) &&
; 366  :                   m_deviceInfo.Descriptor.bNumConfigurations > 0 );
; 367  :         for ( UINT config = 0; config < m_deviceInfo.Descriptor.bNumConfigurations; config++ ) {

  00020	e5d43039	 ldrb        r3, [r4, #0x39]
  00024	e3a06000	 mov         r6, #0
  00028	e3530000	 cmp         r3, #0
  0002c	0a000009	 beq         |$LN1@CDevice@2|
  00030	e3a05000	 mov         r5, #0
  00034		 |$LL3@CDevice@2|
  00034	e594303c	 ldr         r3, [r4, #0x3C]

; 368  :             DeleteUsbConfigurationStructure( m_deviceInfo.lpConfigs[ config ] );

  00038	e1a00004	 mov         r0, r4
  0003c	e0851003	 add         r1, r5, r3
  00040	eb000000	 bl          |?DeleteUsbConfigurationStructure@CDevice@@QBAXAAU_NON_CONST_USB_CONFIGURATION@@@Z|
  00044	e5d43039	 ldrb        r3, [r4, #0x39]
  00048	e2866001	 add         r6, r6, #1
  0004c	e2855020	 add         r5, r5, #0x20
  00050	e1560003	 cmp         r6, r3
  00054	3afffff6	 bcc         |$LL3@CDevice@2|
  00058		 |$LN1@CDevice@2|

; 369  :         }
; 370  :         delete [] m_deviceInfo.lpConfigs;

  00058	e594003c	 ldr         r0, [r4, #0x3C]
  0005c	eb000000	 bl          |??3@YAXPAX@Z|

; 371  :         m_deviceInfo.lpConfigs = NULL;

  00060	e584703c	 str         r7, [r4, #0x3C]
  00064		 |$LN4@CDevice@2|

; 372  :     }
; 373  :     m_deviceInfo.lpActiveConfig = NULL;
; 374  : 
; 375  : #ifdef DEBUG
; 376  : {
; 377  :     DEBUGCHK( (m_ppCPipe == NULL && m_maxNumPipes == 0) ||
; 378  :               (m_ppCPipe != NULL && m_maxNumPipes > 0) );
; 379  :     // all pipes should have been closed/deleted by HandleDetach
; 380  :     for ( UCHAR pipe = 0; m_ppCPipe && pipe < m_maxNumPipes; pipe++ ) {
; 381  :         DEBUGCHK( m_ppCPipe[ pipe ] == NULL );
; 382  :     }
; 383  : }
; 384  : #endif // DEBUG
; 385  :     delete [] m_ppCPipe;

  00064	e594005c	 ldr         r0, [r4, #0x5C]
  00068	e5847040	 str         r7, [r4, #0x40]
  0006c	eb000000	 bl          |??3@YAXPAX@Z|

; 386  :     m_ppCPipe = NULL;
; 387  :     m_maxNumPipes = 0;
; 388  : 
; 389  :     // free address
; 390  :     FreeAddress( m_address );

  00070	e5d41020	 ldrb        r1, [r4, #0x20]
  00074	e5940050	 ldr         r0, [r4, #0x50]
  00078	e584705c	 str         r7, [r4, #0x5C]
  0007c	e5c47054	 strb        r7, [r4, #0x54]
  00080	eb000000	 bl          |?FreeAddress@CDeviceGlobal@@QAAXE@Z|

; 391  : 
; 392  :     // nothing to be done with any of these:
; 393  :     // m_deviceInfo;   // holds device's USB descriptors
; 394  :     // m_fIsLowSpeed;  // indicates if device is low speed
; 395  :     // m_tierNumber;   // indicates tier # of device
; 396  : 
; 397  :     DeleteCriticalSection( &m_csDeviceLock );

  00084	e284000c	 add         r0, r4, #0xC
  00088	eb000000	 bl          DeleteCriticalSection

; 398  :     DEBUGMSG( ZONE_DEVICE && ZONE_VERBOSE, (TEXT("-CDevice::~CDevice\n")) );
; 399  : }

  0008c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$LN14@CDevice@2|
  00094		 |$LN15@CDevice@2|
  00094	00000000	 DCD         |??_7CDevice@@6B@|
  00098		 |$M37383|

			 ENDP  ; |??1CDevice@@UAA@XZ|, CDevice::~CDevice

	EXPORT	|?CreateUsbConfigurationStructure@CDevice@@QBAHAAU_NON_CONST_USB_CONFIGURATION@@QAEI@Z| ; CDevice::CreateUsbConfigurationStructure

  00000			 AREA	 |.pdata|, PDATA
|$T37434| DCD	|$LN58@CreateUsbC|
	DCD	0x4000dd02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CreateUsbConfigurationStructure@CDevice@@QBAHAAU_NON_CONST_USB_CONFIGURATION@@QAEI@Z| PROC ; CDevice::CreateUsbConfigurationStructure

; 445  : {

  00000		 |$LN58@CreateUsbC|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M37431|
  00008	e1a07001	 mov         r7, r1
  0000c	e58d7004	 str         r7, [sp, #4]
  00010	e1a09003	 mov         r9, r3
  00014	e1b08002	 movs        r8, r2
  00018	e58d000c	 str         r0, [sp, #0xC]

; 446  :     DEBUGMSG( ZONE_DESCRIPTORS && ZONE_VERBOSE, (TEXT("+CDevice::CreateUsbConfigurationStructure\n")));
; 447  : 
; 448  :     DEBUGCHK( pDataBuffer != NULL &&
; 449  :               dataBufferLen == rConfig.Descriptor.wTotalLength );
; 450  : 
; 451  :     PUSB_CONFIGURATION_DESCRIPTOR pusbConfigDesc = (PUSB_CONFIGURATION_DESCRIPTOR) pDataBuffer;
; 452  :     DEBUGCHK( memcmp( &rConfig.Descriptor, pusbConfigDesc, sizeof( USB_CONFIGURATION_DESCRIPTOR ) ) == 0 );
; 453  : 
; 454  : #ifdef DEBUG
; 455  :     DumpConfigDescriptor( &rConfig.Descriptor );
; 456  : #endif // DEBUG
; 457  : 
; 458  :     rConfig.dwNumInterfaces = 0;

  0001c	e3a03000	 mov         r3, #0
  00020	e5873014	 str         r3, [r7, #0x14]

; 459  :     rConfig.lpbExtended = NULL;

  00024	e5873010	 str         r3, [r7, #0x10]

; 460  :     rConfig.lpInterfaces = NULL;

  00028	e5873018	 str         r3, [r7, #0x18]

; 461  :     rConfig.dwExtendedSize = 0;

  0002c	e587301c	 str         r3, [r7, #0x1C]

; 462  : 
; 463  :     BOOL retval = FALSE;

  00030	e3a00000	 mov         r0, #0

; 464  : 
; 465  :     if ( pusbConfigDesc != NULL &&
; 466  :          pusbConfigDesc->wTotalLength == rConfig.Descriptor.wTotalLength &&
; 467  :          dataBufferLen == pusbConfigDesc->wTotalLength &&
; 468  :          pusbConfigDesc->bLength >= sizeof( USB_CONFIGURATION_DESCRIPTOR ) &&
; 469  :          pusbConfigDesc->bDescriptorType == USB_CONFIGURATION_DESCRIPTOR_TYPE ) {

  00034	0a0000ca	 beq         |$LN39@CreateUsbC|
  00038	e5d86002	 ldrb        r6, [r8, #2]
  0003c	e5d84003	 ldrb        r4, [r8, #3]
  00040	e5d75006	 ldrb        r5, [r7, #6]
  00044	e5d7e007	 ldrb        lr, [r7, #7]
  00048	e1862404	 orr         r2, r6, r4, lsl #8
  0004c	e185e40e	 orr         lr, r5, lr, lsl #8
  00050	e152000e	 cmp         r2, lr
  00054	1a0000c2	 bne         |$LN39@CreateUsbC|
  00058	e1590002	 cmp         r9, r2
  0005c	1a0000c0	 bne         |$LN39@CreateUsbC|
  00060	e5d84000	 ldrb        r4, [r8]
  00064	e3540009	 cmp         r4, #9
  00068	3a0000bd	 bcc         |$LN39@CreateUsbC|
  0006c	e5d83001	 ldrb        r3, [r8, #1]
  00070	e3530002	 cmp         r3, #2
  00074	1a0000ba	 bne         |$LN39@CreateUsbC|

; 470  : 
; 471  :         UINT offset = pusbConfigDesc->bLength;
; 472  :         PUSB_COMMON_DESCRIPTOR pusbCommon = NULL;
; 473  :         rConfig.dwCount = sizeof ( NON_CONST_USB_CONFIGURATION );

  00078	e3a03020	 mov         r3, #0x20
  0007c	e5873000	 str         r3, [r7]

; 474  : 
; 475  :         // first step - count number of extended bytes for this config descriptor,
; 476  :         // and copy data if needed
; 477  :         {
; 478  :             UINT configDescExtendedBytes = 0;

  00080	e3a05000	 mov         r5, #0

; 479  :             while ( offset + configDescExtendedBytes < dataBufferLen ) {

  00084	e1540009	 cmp         r4, r9
  00088	2a000015	 bcs         |$LN34@CreateUsbC|
  0008c	e0846008	 add         r6, r4, r8
  00090		 |$LL38@CreateUsbC|

; 480  :                 pusbCommon = (PUSB_COMMON_DESCRIPTOR)(pDataBuffer + offset + configDescExtendedBytes );

  00090	e0862005	 add         r2, r6, r5

; 481  :                 if ( pusbCommon->bDescriptorType != USB_INTERFACE_DESCRIPTOR_TYPE ) {

  00094	e5d23001	 ldrb        r3, [r2, #1]
  00098	e3530004	 cmp         r3, #4
  0009c	0a000004	 beq         |$LN36@CreateUsbC|

; 482  :                     configDescExtendedBytes += pusbCommon->bLength;

  000a0	e5d23000	 ldrb        r3, [r2]
  000a4	e0855003	 add         r5, r5, r3
  000a8	e0853004	 add         r3, r5, r4
  000ac	e1530009	 cmp         r3, r9
  000b0	3afffff6	 bcc         |$LL38@CreateUsbC|
  000b4		 |$LN36@CreateUsbC|

; 483  :                 } else {
; 484  :                     break;
; 485  :                 }
; 486  :             }
; 487  :             // next, copy Config Descriptor's extended bytes
; 488  :             if ( configDescExtendedBytes > 0 ) {

  000b4	e3550000	 cmp         r5, #0
  000b8	0a000009	 beq         |$LN34@CreateUsbC|

; 489  :                 rConfig.lpbExtended = new BYTE[ configDescExtendedBytes ];

  000bc	e1a00005	 mov         r0, r5
  000c0	eb000000	 bl          |??2@YAPAXI@Z|
  000c4	e3500000	 cmp         r0, #0
  000c8	e5870010	 str         r0, [r7, #0x10]

; 490  :                 if ( rConfig.lpbExtended == NULL ) {

  000cc	0a0000a0	 beq         |$configDescMemoryError$34551|

; 491  :                     goto configDescMemoryError;
; 492  :                 }
; 493  :                 rConfig.dwExtendedSize = configDescExtendedBytes ;
; 494  :                 memcpy(  rConfig.lpbExtended, pDataBuffer + offset, configDescExtendedBytes );

  000d0	e1a02005	 mov         r2, r5
  000d4	e1a01006	 mov         r1, r6
  000d8	e587501c	 str         r5, [r7, #0x1C]
  000dc	eb000000	 bl          memcpy

; 495  :                 offset += configDescExtendedBytes;

  000e0	e0844005	 add         r4, r4, r5
  000e4		 |$LN34@CreateUsbC|

; 496  :             #ifdef DEBUG
; 497  :                 DumpExtendedBytes( rConfig.lpbExtended, configDescExtendedBytes );
; 498  :             #endif // DEBUG
; 499  :             }
; 500  :         }
; 501  :         // second step - get the number of interfaces for this configuration
; 502  :         // note - this isn't always the same as the bNumInterfaces field of
; 503  :         // rConfig.Descriptor, due to Alternate settings for Interfaces
; 504  :         {
; 505  :             UINT x = 0; // temporary counter
; 506  :             DEBUGCHK( rConfig.dwNumInterfaces == 0 );
; 507  :             while ( offset + x + sizeof( USB_INTERFACE_DESCRIPTOR ) <= dataBufferLen ) {

  000e4	e2841009	 add         r1, r4, #9
  000e8	e1510009	 cmp         r1, r9
  000ec	e3a02000	 mov         r2, #0
  000f0	8a00000b	 bhi         |$LN30@CreateUsbC|
  000f4	e084e008	 add         lr, r4, r8
  000f8		 |$LL31@CreateUsbC|

; 508  :                 pusbCommon = (PUSB_COMMON_DESCRIPTOR)(pDataBuffer + offset + x);

  000f8	e08e0002	 add         r0, lr, r2

; 509  :                 if ( pusbCommon->bDescriptorType == USB_INTERFACE_DESCRIPTOR_TYPE ) {

  000fc	e5d03001	 ldrb        r3, [r0, #1]
  00100	e3530004	 cmp         r3, #4

; 510  :                     rConfig.dwNumInterfaces++;

  00104	05973014	 ldreq       r3, [r7, #0x14]
  00108	02833001	 addeq       r3, r3, #1
  0010c	05873014	 streq       r3, [r7, #0x14]

; 511  :                 }
; 512  :                 x += pusbCommon->bLength;

  00110	e5d03000	 ldrb        r3, [r0]
  00114	e0822003	 add         r2, r2, r3
  00118	e0813002	 add         r3, r1, r2
  0011c	e1530009	 cmp         r3, r9
  00120	9afffff4	 bls         |$LL31@CreateUsbC|
  00124		 |$LN30@CreateUsbC|

; 513  :             }
; 514  :         }
; 515  : 
; 516  :         // next - create array for INTERFACE objects
; 517  :         DEBUGCHK( rConfig.lpInterfaces == NULL );
; 518  :         if ( rConfig.dwNumInterfaces > 0 ) {

  00124	e5973014	 ldr         r3, [r7, #0x14]
  00128	e1b02003	 movs        r2, r3
  0012c	0a000088	 beq         |$configDescMemoryError$34551|

; 519  :             // allocate this many interface objects
; 520  :             rConfig.lpInterfaces = new NON_CONST_USB_INTERFACE[ rConfig.dwNumInterfaces ];

  00130	e59f3238	 ldr         r3, [pc, #0x238]
  00134	e1520003	 cmp         r2, r3
  00138	90623182	 rsbls       r3, r2, r2, lsl #3
  0013c	91a00103	 movls       r0, r3, lsl #2
  00140	83e00000	 mvnhi       r0, #0
  00144	eb000000	 bl          |??2@YAPAXI@Z|
  00148	e3500000	 cmp         r0, #0
  0014c	e5870018	 str         r0, [r7, #0x18]

; 521  :             if ( rConfig.lpInterfaces == NULL ) {

  00150	0a00007f	 beq         |$configDescMemoryError$34551|

; 522  :                 goto configDescMemoryError;
; 523  :             }
; 524  :             memset( rConfig.lpInterfaces, 0, rConfig.dwNumInterfaces * sizeof( NON_CONST_USB_INTERFACE ) );

  00154	e5973014	 ldr         r3, [r7, #0x14]
  00158	e3a01000	 mov         r1, #0
  0015c	e0633183	 rsb         r3, r3, r3, lsl #3
  00160	e1a02103	 mov         r2, r3, lsl #2
  00164	eb000000	 bl          memset

; 525  :             for ( UCHAR interfaceNumber = 0; interfaceNumber < rConfig.dwNumInterfaces; interfaceNumber++ ) {

  00168	e5973014	 ldr         r3, [r7, #0x14]
  0016c	e3a01000	 mov         r1, #0
  00170	e5cd1000	 strb        r1, [sp]
  00174	e3530000	 cmp         r3, #0
  00178	9a000073	 bls         |$LN23@CreateUsbC|
  0017c	e3a0201c	 mov         r2, #0x1C
  00180		 |$LL25@CreateUsbC|

; 526  :                 NON_CONST_USB_INTERFACE & rInterface = rConfig.lpInterfaces[ interfaceNumber ];

  00180	e5976018	 ldr         r6, [r7, #0x18]
  00184	e0613181	 rsb         r3, r1, r1, lsl #3

; 527  :                 rInterface.dwCount = sizeof( NON_CONST_USB_INTERFACE );
; 528  :                 // for each interface,
; 529  :                 // 1) Copy the interface descriptor
; 530  :                 // 2) Allocate and copy any extended bytes
; 531  :                 // 3) Allocate room for endpoints, if any
; 532  :                 // 4) Copy over endpoints -
; 533  :                 //      for each endpoint:
; 534  :                 //      a) copy the endpoint descriptor
; 535  :                 //      b) copy any extended bytes
; 536  : 
; 537  : 
; 538  :                 // we should now be pointing to a complete USB_INTERFACE_DESCRIPTOR
; 539  :                 DEBUGCHK( offset + sizeof( USB_CONFIGURATION_DESCRIPTOR ) <= dataBufferLen );
; 540  :                 PUSB_INTERFACE_DESCRIPTOR pusbInterfaceDesc = (PUSB_INTERFACE_DESCRIPTOR)(pDataBuffer + offset);
; 541  :                 DEBUGCHK( pusbInterfaceDesc->bLength >= sizeof( USB_INTERFACE_DESCRIPTOR ) &&
; 542  :                           pusbInterfaceDesc->bDescriptorType == USB_INTERFACE_DESCRIPTOR_TYPE );
; 543  : 
; 544  :                 // 1) copy interface descriptor, and skip over it
; 545  :                 memcpy( &rInterface.Descriptor, pusbInterfaceDesc, sizeof( USB_INTERFACE_DESCRIPTOR ) );

  00188	e0841008	 add         r1, r4, r8
  0018c	e7a62103	 str         r2, [r6, +r3, lsl #2]!
  00190	e3a02009	 mov         r2, #9
  00194	e2860004	 add         r0, r6, #4
  00198	eb000000	 bl          memcpy

; 546  :                 offset += pusbInterfaceDesc->bLength;

  0019c	e7d43008	 ldrb        r3, [r4, +r8]

; 547  :             #ifdef DEBUG
; 548  :                 DumpInterfaceDescriptor( &rInterface.Descriptor );
; 549  :             #endif // DEBUG
; 550  : 
; 551  :                 // 2) copy any extended info, if it exists
; 552  :                 {
; 553  :                     UINT interfaceDescExtendedBytes = 0;

  001a0	e3a05000	 mov         r5, #0
  001a4	e0844003	 add         r4, r4, r3

; 554  :                     while ( offset + interfaceDescExtendedBytes < dataBufferLen ) {

  001a8	e1540009	 cmp         r4, r9
  001ac	2a00001b	 bcs         |$LN18@CreateUsbC|
  001b0	e084a008	 add         r10, r4, r8
  001b4		 |$LL22@CreateUsbC|

; 555  :                         pusbCommon = (PUSB_COMMON_DESCRIPTOR)(pDataBuffer + offset + interfaceDescExtendedBytes);

  001b4	e08a2005	 add         r2, r10, r5

; 556  :                         if ( pusbCommon->bDescriptorType != USB_INTERFACE_DESCRIPTOR_TYPE &&
; 557  :                              pusbCommon->bDescriptorType != USB_ENDPOINT_DESCRIPTOR_TYPE &&
; 558  :                              offset + interfaceDescExtendedBytes + pusbCommon->bLength <= dataBufferLen ) {

  001b8	e5d23001	 ldrb        r3, [r2, #1]
  001bc	e3530004	 cmp         r3, #4
  001c0	0a00000a	 beq         |$LN20@CreateUsbC|
  001c4	e3530005	 cmp         r3, #5
  001c8	0a000008	 beq         |$LN20@CreateUsbC|
  001cc	e5d23000	 ldrb        r3, [r2]
  001d0	e0832005	 add         r2, r3, r5
  001d4	e0823004	 add         r3, r2, r4
  001d8	e1530009	 cmp         r3, r9
  001dc	8a000003	 bhi         |$LN20@CreateUsbC|
  001e0	e0823004	 add         r3, r2, r4
  001e4	e1530009	 cmp         r3, r9

; 559  : 
; 560  :                             interfaceDescExtendedBytes += pusbCommon->bLength;

  001e8	e1a05002	 mov         r5, r2
  001ec	3afffff0	 bcc         |$LL22@CreateUsbC|
  001f0		 |$LN20@CreateUsbC|

; 561  :                         } else {
; 562  :                             break;
; 563  :                         }
; 564  :                     }
; 565  :                     DEBUGCHK( rInterface.lpbExtended == NULL );
; 566  :                     if ( interfaceDescExtendedBytes > 0 ) {

  001f0	e3550000	 cmp         r5, #0
  001f4	0a000009	 beq         |$LN18@CreateUsbC|

; 567  :                         rInterface.lpbExtended = new BYTE[ interfaceDescExtendedBytes ];

  001f8	e1a00005	 mov         r0, r5
  001fc	eb000000	 bl          |??2@YAPAXI@Z|
  00200	e3500000	 cmp         r0, #0
  00204	e5860010	 str         r0, [r6, #0x10]

; 568  :                         if ( rInterface.lpbExtended == NULL ) {

  00208	0a000051	 beq         |$configDescMemoryError$34551|

; 569  :                             goto configDescMemoryError;
; 570  :                         }
; 571  :                         rInterface.dwExtendedSize = interfaceDescExtendedBytes ;
; 572  :                         memcpy( rInterface.lpbExtended, pDataBuffer + offset, interfaceDescExtendedBytes );

  0020c	e1a02005	 mov         r2, r5
  00210	e1a0100a	 mov         r1, r10
  00214	e5865018	 str         r5, [r6, #0x18]
  00218	eb000000	 bl          memcpy

; 573  :                         offset += interfaceDescExtendedBytes;

  0021c	e0844005	 add         r4, r4, r5
  00220		 |$LN18@CreateUsbC|

; 574  :                     #ifdef DEBUG
; 575  :                         DumpExtendedBytes( rInterface.lpbExtended, interfaceDescExtendedBytes );
; 576  :                     #endif // DEBUG
; 577  :                     }
; 578  :                 }
; 579  : 
; 580  :                 // 3) allocate any endpoints
; 581  :                 DEBUGCHK( rInterface.lpEndpoints == NULL );
; 582  :                 if ( rInterface.Descriptor.bNumEndpoints == 0 ) {

  00220	e5d63008	 ldrb        r3, [r6, #8]
  00224	e3530000	 cmp         r3, #0
  00228	0a00003f	 beq         |$LN24@CreateUsbC|

; 583  :                     continue; // continue interface loop
; 584  :                 }
; 585  :                 rInterface.lpEndpoints = new NON_CONST_USB_ENDPOINT[ rInterface.Descriptor.bNumEndpoints ];

  0022c	e0833103	 add         r3, r3, r3, lsl #2
  00230	e1a00103	 mov         r0, r3, lsl #2
  00234	eb000000	 bl          |??2@YAPAXI@Z|
  00238	e3500000	 cmp         r0, #0
  0023c	e5860014	 str         r0, [r6, #0x14]

; 586  :                 if ( rInterface.lpEndpoints == NULL ) {

  00240	0a000043	 beq         |$configDescMemoryError$34551|

; 587  :                     goto configDescMemoryError;
; 588  :                 }
; 589  : 
; 590  :                 memset( rInterface.lpEndpoints, 0, rInterface.Descriptor.bNumEndpoints * sizeof( NON_CONST_USB_ENDPOINT ) );

  00244	e5d63008	 ldrb        r3, [r6, #8]
  00248	e3a01000	 mov         r1, #0
  0024c	e0833103	 add         r3, r3, r3, lsl #2
  00250	e1a02103	 mov         r2, r3, lsl #2
  00254	eb000000	 bl          memset

; 591  :                 for ( UINT endpoint = 0; endpoint < rInterface.Descriptor.bNumEndpoints; endpoint++ ) {

  00258	e5d63008	 ldrb        r3, [r6, #8]
  0025c	e3a0b000	 mov         r11, #0
  00260	e3530000	 cmp         r3, #0
  00264	0a000030	 beq         |$LN24@CreateUsbC|

; 587  :                     goto configDescMemoryError;
; 588  :                 }
; 589  : 
; 590  :                 memset( rInterface.lpEndpoints, 0, rInterface.Descriptor.bNumEndpoints * sizeof( NON_CONST_USB_ENDPOINT ) );

  00268	e3a0a000	 mov         r10, #0
  0026c		 |$LL12@CreateUsbC|

; 592  :                     NON_CONST_USB_ENDPOINT & rEndpoint = rInterface.lpEndpoints[ endpoint ];

  0026c	e5963014	 ldr         r3, [r6, #0x14]

; 593  :                     rEndpoint.dwCount = sizeof( NON_CONST_USB_ENDPOINT );
; 594  : 
; 595  :                     // should now be pointing at an endpoint descriptor
; 596  :                     PUSB_ENDPOINT_DESCRIPTOR pusbEndpointDesc = (PUSB_ENDPOINT_DESCRIPTOR)(pDataBuffer + offset);
; 597  :                     DEBUGCHK( pusbEndpointDesc->bDescriptorType == USB_ENDPOINT_DESCRIPTOR_TYPE &&
; 598  :                               pusbEndpointDesc->bLength >= sizeof( USB_ENDPOINT_DESCRIPTOR ) );
; 599  : 
; 600  :                     // 4a) copy the endpoint descriptor
; 601  :                     memcpy( &rEndpoint.Descriptor, pDataBuffer + offset, sizeof( USB_ENDPOINT_DESCRIPTOR ) );

  00270	e3a01014	 mov         r1, #0x14
  00274	e3a02007	 mov         r2, #7
  00278	e7a3100a	 str         r1, [r3, +r10]!
  0027c	e0841008	 add         r1, r4, r8
  00280	e2830004	 add         r0, r3, #4
  00284	e58d3008	 str         r3, [sp, #8]
  00288	eb000000	 bl          memcpy

; 602  :                     offset += pusbEndpointDesc->bLength;

  0028c	e7d43008	 ldrb        r3, [r4, +r8]

; 603  :                 #ifdef DEBUG
; 604  :                     DumpEndpointDescriptor( &rEndpoint.Descriptor );
; 605  :                 #endif // DEBUG
; 606  : 
; 607  :                     // 4b) copy any extended info, if it exists
; 608  :                     UINT endpointDescExtendedBytes = 0;

  00290	e3a05000	 mov         r5, #0
  00294	e0844003	 add         r4, r4, r3

; 609  :                     while ( offset + endpointDescExtendedBytes < dataBufferLen ) {

  00298	e1540009	 cmp         r4, r9
  0029c	2a00001d	 bcs         |$LN11@CreateUsbC|
  002a0	e0847008	 add         r7, r4, r8
  002a4		 |$LL9@CreateUsbC|

; 610  :                         pusbCommon = (PUSB_COMMON_DESCRIPTOR)(pDataBuffer + offset + endpointDescExtendedBytes);

  002a4	e0872005	 add         r2, r7, r5

; 611  :                         if ( pusbCommon->bDescriptorType != USB_ENDPOINT_DESCRIPTOR_TYPE &&
; 612  :                              pusbCommon->bDescriptorType != USB_INTERFACE_DESCRIPTOR_TYPE &&
; 613  :                              offset + endpointDescExtendedBytes + pusbCommon->bLength <= dataBufferLen ) {

  002a8	e5d23001	 ldrb        r3, [r2, #1]
  002ac	e3530005	 cmp         r3, #5
  002b0	0a00000a	 beq         |$LN7@CreateUsbC|
  002b4	e3530004	 cmp         r3, #4
  002b8	0a000008	 beq         |$LN7@CreateUsbC|
  002bc	e5d23000	 ldrb        r3, [r2]
  002c0	e0832005	 add         r2, r3, r5
  002c4	e0823004	 add         r3, r2, r4
  002c8	e1530009	 cmp         r3, r9
  002cc	8a000003	 bhi         |$LN7@CreateUsbC|
  002d0	e0823004	 add         r3, r2, r4
  002d4	e1530009	 cmp         r3, r9

; 614  : 
; 615  :                             endpointDescExtendedBytes += pusbCommon->bLength;

  002d8	e1a05002	 mov         r5, r2
  002dc	3afffff0	 bcc         |$LL9@CreateUsbC|
  002e0		 |$LN7@CreateUsbC|

; 616  :                         } else {
; 617  :                             break;
; 618  :                         }
; 619  :                     }
; 620  :                     DEBUGCHK( rEndpoint.lpbExtended == NULL );
; 621  :                     if ( endpointDescExtendedBytes > 0 ) {

  002e0	e59d7004	 ldr         r7, [sp, #4]
  002e4	e3550000	 cmp         r5, #0
  002e8	0a00000a	 beq         |$LN11@CreateUsbC|

; 622  :                         rEndpoint.lpbExtended = new BYTE[ endpointDescExtendedBytes ];

  002ec	e1a00005	 mov         r0, r5
  002f0	eb000000	 bl          |??2@YAPAXI@Z|
  002f4	e59d3008	 ldr         r3, [sp, #8]
  002f8	e3500000	 cmp         r0, #0
  002fc	e583000c	 str         r0, [r3, #0xC]

; 623  :                         if ( rEndpoint.lpbExtended == NULL ) {

  00300	0a000013	 beq         |$configDescMemoryError$34551|

; 624  :                             goto configDescMemoryError;
; 625  :                         }
; 626  :                         rEndpoint.dwExtendedSize = endpointDescExtendedBytes ;
; 627  :                         memcpy( rEndpoint.lpbExtended, pDataBuffer + offset, endpointDescExtendedBytes );

  00304	e1a02005	 mov         r2, r5
  00308	e0841008	 add         r1, r4, r8
  0030c	e5835010	 str         r5, [r3, #0x10]
  00310	eb000000	 bl          memcpy

; 628  :                         offset += endpointDescExtendedBytes;

  00314	e0844005	 add         r4, r4, r5
  00318		 |$LN11@CreateUsbC|
  00318	e5d63008	 ldrb        r3, [r6, #8]
  0031c	e28bb001	 add         r11, r11, #1
  00320	e28aa014	 add         r10, r10, #0x14
  00324	e15b0003	 cmp         r11, r3
  00328	3affffcf	 bcc         |$LL12@CreateUsbC|
  0032c		 |$LN24@CreateUsbC|

; 525  :             for ( UCHAR interfaceNumber = 0; interfaceNumber < rConfig.dwNumInterfaces; interfaceNumber++ ) {

  0032c	e5dd3000	 ldrb        r3, [sp]
  00330	e5972014	 ldr         r2, [r7, #0x14]
  00334	e2833001	 add         r3, r3, #1
  00338	e20310ff	 and         r1, r3, #0xFF
  0033c	e1510002	 cmp         r1, r2
  00340	e3a0201c	 mov         r2, #0x1C
  00344	e5cd1000	 strb        r1, [sp]
  00348	3affff8c	 bcc         |$LL25@CreateUsbC|
  0034c		 |$LN23@CreateUsbC|

; 629  :                     #ifdef DEBUG
; 630  :                         DumpExtendedBytes( rEndpoint.lpbExtended, endpointDescExtendedBytes );
; 631  :                     #endif // DEBUG
; 632  :                     }
; 633  :                 } // end endpoint for loop
; 634  :             } // end interface for loop
; 635  :         } // end check for interfaces
; 636  :         else {
; 637  :             goto configDescMemoryError;
; 638  :         }
; 639  :         retval = TRUE;

  0034c	e3a00001	 mov         r0, #1
  00350	ea000003	 b           |$LN39@CreateUsbC|
  00354		 |$configDescMemoryError$34551|

; 640  :     }
; 641  :     DEBUGMSG( ZONE_DESCRIPTORS && ZONE_VERBOSE, (TEXT("-CDevice::CreateUsbConfigurationStructure - returning %d\n"), retval));
; 642  :     return retval;
; 643  : 
; 644  : 
; 645  : configDescMemoryError:
; 646  :     DEBUGMSG( ZONE_ERROR, (TEXT("-CDevice::CreateUsbConfigurationStructure - error allocating memory\n")));
; 647  :     DeleteUsbConfigurationStructure( rConfig );

  00354	e59d000c	 ldr         r0, [sp, #0xC]
  00358	e1a01007	 mov         r1, r7
  0035c	eb000000	 bl          |?DeleteUsbConfigurationStructure@CDevice@@QBAXAAU_NON_CONST_USB_CONFIGURATION@@@Z|

; 648  :     return FALSE;

  00360	e3a00000	 mov         r0, #0
  00364		 |$LN39@CreateUsbC|

; 649  : }

  00364	e28dd010	 add         sp, sp, #0x10
  00368	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0036c	e12fff1e	 bx          lr
  00370		 |$LN59@CreateUsbC|
  00370		 |$LN60@CreateUsbC|
  00370	09249249	 DCD         0x9249249
  00374		 |$M37432|

			 ENDP  ; |?CreateUsbConfigurationStructure@CDevice@@QBAHAAU_NON_CONST_USB_CONFIGURATION@@QAEI@Z|, CDevice::CreateUsbConfigurationStructure

	EXPORT	|??0CHub@@QAA@EABU_USB_DEVICE_INFO@@HHEABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@QAV0@E@Z| ; CHub::CHub
	EXPORT	|??_7CHub@@6B@| [ DATA ]		; CHub::`vftable'
	EXPORT	|?ResumeNotification@CHub@@UAAHXZ|	; CHub::ResumeNotification
	EXPORT	|?DisableOffStreamDevice@CHub@@UAAHIH@Z| ; CHub::DisableOffStreamDevice
	IMPORT	|??_ECHub@@UAAPAXI@Z|, WEAK |??_GCHub@@UAAPAXI@Z| ; CHub::`vector deleting destructor', CHub::`scalar deleting destructor'

  00000			 AREA	 |.pdata|, PDATA
|$T37450| DCD	|$LN5@CHub|
	DCD	0x40002d02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7CHub@@6B@| DCD |??_ECHub@@UAAPAXI@Z|		; CHub::`vftable'
	DCD	|_purecall|
	DCD	|?OpenPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IQBU_USB_ENDPOINT_DESCRIPTOR@@QAI@Z|
	DCD	|?ClosePipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|
	DCD	|?IssueTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z|
	DCD	|?AbortTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXQBX@Z|
	DCD	|?IsPipeHalted@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQAH@Z|
	DCD	|?ResetPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|
	DCD	|?DisableDevice@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|
	DCD	|?SuspendResume@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|
	DCD	|?ResumeNotification@CHub@@UAAHXZ|
	DCD	|?NotifyOnSuspendedResumed@CHub@@UAAHH@Z|
	DCD	|?HandleDetach@CHub@@UAAXXZ|
	DCD	|?GetUSB2TT@CDevice@@UAAPAVCHub@@PAE0@Z|
	DCD	|?DisableOffStreamDevice@CHub@@UAAHIH@Z|
	DCD	|?SuspendResumeOffStreamDevice@CHub@@UAAHIH@Z|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CHub@@QAA@EABU_USB_DEVICE_INFO@@HHEABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@QAV0@E@Z| PROC ; CHub::CHub

; 941  : {

  00000		 |$LN5@CHub|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M37447|
  00008	e1a08000	 mov         r8, r0
  0000c	e5dd5040	 ldrb        r5, [sp, #0x40]
  00010	e59d603c	 ldr         r6, [sp, #0x3C]
  00014	e59d7038	 ldr         r7, [sp, #0x38]
  00018	e5dde030	 ldrb        lr, [sp, #0x30]
  0001c	e59d402c	 ldr         r4, [sp, #0x2C]
  00020	e58d5010	 str         r5, [sp, #0x10]
  00024	e58d600c	 str         r6, [sp, #0xC]
  00028	e58d7008	 str         r7, [sp, #8]
  0002c	e58de004	 str         lr, [sp, #4]
  00030	e58d4000	 str         r4, [sp]
  00034	eb000000	 bl          |??0CDevice@@QAA@EABU_USB_DEVICE_INFO@@HHEQAVCDeviceGlobal@@QAVCHub@@E@Z|
  00038	e59f3070	 ldr         r3, [pc, #0x70]
  0003c	e1a00008	 mov         r0, r8
  00040	e59d1034	 ldr         r1, [sp, #0x34]
  00044	e4803068	 str         r3, [r0], #0x68
  00048	e3a02047	 mov         r2, #0x47
  0004c	eb000000	 bl          memcpy
  00050	e3a0e000	 mov         lr, #0

; 942  :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CHub::CHub\n")) );
; 943  :     m_pDetachedDevice=NULL;
; 944  :     m_pDetachedDeviceHandled = CreateEvent(NULL,TRUE,FALSE,NULL); // Manual Reset Event;

  00054	e3a03000	 mov         r3, #0
  00058	e3a02000	 mov         r2, #0
  0005c	e3a01001	 mov         r1, #1
  00060	e3a00000	 mov         r0, #0
  00064	e588e0b0	 str         lr, [r8, #0xB0]
  00068	e588e0b8	 str         lr, [r8, #0xB8]
  0006c	e588e0bc	 str         lr, [r8, #0xBC]
  00070	e588e0c0	 str         lr, [r8, #0xC0]
  00074	e588e060	 str         lr, [r8, #0x60]
  00078	e58870c8	 str         r7, [r8, #0xC8]
  0007c	eb000000	 bl          CreateEventW
  00080	e1a03000	 mov         r3, r0

; 945  :     m_hHubSuspendBlockEvent = CreateEvent(NULL,TRUE,TRUE,NULL); // Manual Reset Event;

  00084	e5883064	 str         r3, [r8, #0x64]
  00088	e3a03000	 mov         r3, #0
  0008c	e3a00000	 mov         r0, #0
  00090	e3a02001	 mov         r2, #1
  00094	e3a01001	 mov         r1, #1
  00098	eb000000	 bl          CreateEventW
  0009c	e58800c4	 str         r0, [r8, #0xC4]

; 946  :     DEBUGCHK( rDeviceInfo.Descriptor.bDeviceClass == USB_DEVICE_CLASS_HUB &&
; 947  :               rUsbHubDescriptor.bDescriptorType == USB_HUB_DESCRIPTOR_TYPE &&
; 948  :               rUsbHubDescriptor.bDescriptorLength >= USB_HUB_DESCRIPTOR_MINIMUM_SIZE &&
; 949  :               rUsbHubDescriptor.bNumberOfPorts > 0 &&
; 950  :               tierNumber <= USB_MAXIMUM_HUB_TIER );
; 951  : 
; 952  :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CHub::CHub\n")) );
; 953  : }

  000a0	e1a00008	 mov         r0, r8
  000a4	e28dd014	 add         sp, sp, #0x14
  000a8	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000ac	e12fff1e	 bx          lr
  000b0		 |$LN6@CHub|
  000b0		 |$LN7@CHub|
  000b0	00000000	 DCD         |??_7CHub@@6B@|
  000b4		 |$M37448|

			 ENDP  ; |??0CHub@@QAA@EABU_USB_DEVICE_INFO@@HHEABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@QAV0@E@Z|, CHub::CHub

; File c:\wince600\osdesigns\z2170p\z2170p\wince600\z2170p_armv4i\cesysgen\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T37467| DCD	|$LN7@ResumeNoti@2|
	DCD	0x40000901
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.hpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResumeNotification@CHub@@UAAHXZ| PROC ; CHub::ResumeNotification

; 370  :     virtual BOOL ResumeNotification() { 

  00000		 |$LN7@ResumeNoti@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37464|
  00004	e1a03000	 mov         r3, r0

; 371  :         DEBUGMSG( ZONE_ATTACH, (TEXT("CHub(%s tier %d):: ResumeNotification(%d) !\n"), GetDeviceType(), m_tierNumber,m_address) );
; 372  :         m_fIsSuspend = FALSE;
; 373  :         return SetEvent(m_hHubSuspendBlockEvent);

  00008	e59300c4	 ldr         r0, [r3, #0xC4]
  0000c	e3a02000	 mov         r2, #0
  00010	e3a01003	 mov         r1, #3
  00014	e5832058	 str         r2, [r3, #0x58]
  00018	eb000000	 bl          EventModify

; 374  :     };

  0001c	e49de004	 ldr         lr, [sp], #4
  00020	e12fff1e	 bx          lr
  00024		 |$M37465|

			 ENDP  ; |?ResumeNotification@CHub@@UAAHXZ|, CHub::ResumeNotification

	EXPORT	|??1CHub@@UAA@XZ|			; CHub::~CHub
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T37477| DCD	|$LN9@CHub@2|
	DCD	0x40001e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CHub@@UAA@XZ| PROC			; CHub::~CHub

; 967  : {

  00000		 |$LN9@CHub@2|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37474|
  00004	e1a04000	 mov         r4, r0
  00008	e59f3064	 ldr         r3, [pc, #0x64]

; 968  :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CHub::~CHub\n")) );
; 969  : 
; 970  :     // this should have been taken care of in HandleDetach,
; 971  :     // or if EnterOperationalState failed.
; 972  :     DEBUGCHK( m_hHubStatusChangeEvent == NULL );
; 973  :     DEBUGCHK( m_hHubStatusChangeThread == NULL );
; 974  :     DEBUGCHK( m_pDetachedDevice == NULL);
; 975  : 
; 976  : #ifdef DEBUG
; 977  :     if ( m_ppCDeviceOnPort != NULL ) {
; 978  :         for ( UCHAR port = 1; port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {
; 979  :             // devices should have been freed by HandleDetach
; 980  :             DEBUGCHK( m_ppCDeviceOnPort[ port - 1 ] == NULL );
; 981  :         }
; 982  :     }
; 983  : #endif // DEBUG
; 984  :     if (m_ppCDeviceOnPort){

  0000c	e59420b0	 ldr         r2, [r4, #0xB0]
  00010	e3a05000	 mov         r5, #0
  00014	e5843000	 str         r3, [r4]
  00018	e3520000	 cmp         r2, #0
  0001c	0a000002	 beq         |$LN4@CHub@2|

; 985  :         delete [] m_ppCDeviceOnPort;

  00020	e1a00002	 mov         r0, r2
  00024	eb000000	 bl          |??3@YAXPAX@Z|

; 986  :         m_ppCDeviceOnPort = NULL;

  00028	e58450b0	 str         r5, [r4, #0xB0]
  0002c		 |$LN4@CHub@2|

; 987  :     }
; 988  :     if (m_pAddedTT){

  0002c	e59430b4	 ldr         r3, [r4, #0xB4]
  00030	e3530000	 cmp         r3, #0
  00034	0a000002	 beq         |$LN3@CHub@2|

; 989  :         delete m_pAddedTT;

  00038	e1a00003	 mov         r0, r3
  0003c	eb000000	 bl          |??3@YAXPAX@Z|

; 990  :         m_pAddedTT = NULL;

  00040	e58450b4	 str         r5, [r4, #0xB4]
  00044		 |$LN3@CHub@2|

; 991  :     }
; 992  :     if (m_pDetachedDeviceHandled)

  00044	e5943064	 ldr         r3, [r4, #0x64]
  00048	e3530000	 cmp         r3, #0

; 993  :         CloseHandle(m_pDetachedDeviceHandled );    

  0004c	11a00003	 movne       r0, r3
  00050	1b000000	 blne        CloseHandle

; 994  :     if (m_hHubSuspendBlockEvent)

  00054	e59430c4	 ldr         r3, [r4, #0xC4]
  00058	e3530000	 cmp         r3, #0

; 995  :         CloseHandle(m_hHubSuspendBlockEvent);

  0005c	11a00003	 movne       r0, r3
  00060	1b000000	 blne        CloseHandle

; 996  :     // nothing to do with m_usbHubDescriptor
; 997  :     // nothing to do with m_fHubThreadClosing
; 998  : 
; 999  :     // rest of work done in ~CDevice
; 1000 : 
; 1001 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CHub::~CHub\n")) );
; 1002 : }

  00064	e1a00004	 mov         r0, r4
  00068	eb000000	 bl          |??1CDevice@@UAA@XZ|
  0006c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00070	e12fff1e	 bx          lr
  00074		 |$LN10@CHub@2|
  00074		 |$LN11@CHub@2|
  00074	00000000	 DCD         |??_7CHub@@6B@|
  00078		 |$M37475|

			 ENDP  ; |??1CHub@@UAA@XZ|, CHub::~CHub

	EXPORT	|?DetachDownstreamDeviceThreadStub@CHub@@KAKPAX@Z| ; CHub::DetachDownstreamDeviceThreadStub

  00000			 AREA	 |.pdata|, PDATA
|$T37489| DCD	|$LN5@DetachDown@2|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DetachDownstreamDeviceThreadStub@CHub@@KAKPAX@Z| PROC ; CHub::DetachDownstreamDeviceThreadStub

; 2060 : {

  00000		 |$LN5@DetachDown@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37486|

; 2061 :     return ((CHub *)context )->DetachDownstreamDeviceThread();

  00004	eb000000	 bl          |?DetachDownstreamDeviceThread@CHub@@IAAKXZ|

; 2062 : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M37487|

			 ENDP  ; |?DetachDownstreamDeviceThreadStub@CHub@@KAKPAX@Z|, CHub::DetachDownstreamDeviceThreadStub

	EXPORT	|?DetachDevice@CHub@@IAAXE@Z|		; CHub::DetachDevice
	IMPORT	|CeGetThreadPriority|
	IMPORT	|CeSetThreadPriority|
	IMPORT	|g_IstThreadPriority|
	IMPORT	|CreateThread|
; File c:\wince600\osdesigns\z2170p\z2170p\wince600\z2170p_armv4i\cesysgen\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T37515| DCD	|$LN19@DetachDevi|
	DCD	0x40005002
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DetachDevice@CHub@@IAAXE@Z| PROC	; CHub::DetachDevice

; 2115 : {

  00000		 |$LN19@DetachDevi|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M37512|
  00008	e1a06001	 mov         r6, r1
  0000c	e1a05000	 mov         r5, r0

; 2116 :     DEBUGMSG( ZONE_ATTACH, (TEXT("+CHub(%s tier %d)::DetachDevice - port = %d\n"), GetDeviceType(), m_tierNumber, port) );
; 2117 : 
; 2118 :     CDevice*    pDevToDetach = NULL;
; 2119 :     // remove the device from our array. This will prevent
; 2120 :     // USBD from issuing any more requests to the device
; 2121 :     // or its pipes.
; 2122 :     EnterCriticalSection( &m_csDeviceLock );

  00010	e285000c	 add         r0, r5, #0xC
  00014	eb000000	 bl          EnterCriticalSection

; 2123 :     PREFAST_DEBUGCHK( m_ppCDeviceOnPort != NULL );
; 2124 :     DEBUGCHK( port >= 1 &&
; 2125 :               port <= m_usbHubDescriptor.bNumberOfPorts );
; 2126 :     pDevToDetach = m_ppCDeviceOnPort[ port - 1 ];

  00018	e59530b0	 ldr         r3, [r5, #0xB0]

; 2127 :     m_ppCDeviceOnPort[ port - 1 ] = NULL;

  0001c	e3a07000	 mov         r7, #0
  00020	e0833106	 add         r3, r3, r6, lsl #2
  00024	e5132004	 ldr         r2, [r3, #-4]
  00028	e5037004	 str         r7, [r3, #-4]
  0002c	e1b04002	 movs        r4, r2

; 2128 :     if (pDevToDetach) {
; 2129 :         BOOL fSuccess;
; 2130 :         //fSuccess = IncrCountdown(&m_objCountdown);
; 2131 :         fSuccess = m_pDeviceGlobal->ObjCountdownInc();

  00030	15953050	 ldrne       r3, [r5, #0x50]
  00034	12830054	 addne       r0, r3, #0x54
  00038	1b000000	 blne        |?IncrCountdown@Countdown@@QAAHXZ|

; 2132 :         // if the countdown couldn't be incremented then it must have
; 2133 :         // been deleted already, which would mean that all devices
; 2134 :         // have already been detached. Which would mean that the current
; 2135 :         // thread has already exited which is clearly not the case.
; 2136 :         DEBUGCHK( fSuccess );
; 2137 :     }
; 2138 :     LeaveCriticalSection( &m_csDeviceLock );

  0003c	e285000c	 add         r0, r5, #0xC
  00040	eb000000	 bl          LeaveCriticalSection

; 2139 :     // it is possible that we get a device detach
; 2140 :     // on a NULL device. That is, if we failed to
; 2141 :     // configure the device and it was left plugged
; 2142 :     // into the USB port. When it is unplugged, a
; 2143 :     // detach message will be read from the port.
; 2144 :     DEBUGMSG( ZONE_ATTACH && ZONE_WARNING && !pDevToDetach, (TEXT("CHub(%s tier %d)::DetachDevice - reading NULL device detached on port %d, doing nothing.\n"), GetDeviceType(), m_tierNumber, port) );
; 2145 :     if ( pDevToDetach != NULL ) {

  00044	e3540000	 cmp         r4, #0
  00048	0a000028	 beq         |$LN5@DetachDevi|

; 2146 :         ASSERT(m_pDetachedDevice==NULL);
; 2147 :         m_pDetachedDevice=pDevToDetach;
; 2148 :         HANDLE hWorkerThread = NULL;
; 2149 :         if (m_pDetachedDeviceHandled) {

  0004c	e5953064	 ldr         r3, [r5, #0x64]
  00050	e5854060	 str         r4, [r5, #0x60]
  00054	e3530000	 cmp         r3, #0
  00058	0a000016	 beq         |$LN3@DetachDevi|

; 2150 :             ResetEvent(m_pDetachedDeviceHandled);

  0005c	e3a01002	 mov         r1, #2
  00060	e1a00003	 mov         r0, r3
  00064	eb000000	 bl          EventModify

; 2151 :             hWorkerThread=CreateThread( 0, 0, DetachDownstreamDeviceThreadStub, this, 0, NULL );

  00068	e59f20cc	 ldr         r2, [pc, #0xCC]
  0006c	e1a03005	 mov         r3, r5
  00070	e3a01000	 mov         r1, #0
  00074	e3a00000	 mov         r0, #0
  00078	e58d7004	 str         r7, [sp, #4]
  0007c	e58d7000	 str         r7, [sp]
  00080	eb000000	 bl          CreateThread
  00084	e1b04000	 movs        r4, r0

; 2152 :         }
; 2153 :         if ( hWorkerThread != NULL ) {

  00088	0a00000a	 beq         |$LN3@DetachDevi|

; 2154 :             DEBUGMSG( ZONE_ATTACH, (TEXT("CHub(%s tier %d)::DetachDevice - created worker thread to handle device detach\n"), GetDeviceType(), m_tierNumber ));
; 2155 :             CeSetThreadPriority( hWorkerThread, g_IstThreadPriority + RELATIVE_PRIO_DOWNSTREAM);

  0008c	e59f30a4	 ldr         r3, [pc, #0xA4]
  00090	e1a00004	 mov         r0, r4
  00094	e5933000	 ldr         r3, [r3]
  00098	e2831003	 add         r1, r3, #3
  0009c	eb000000	 bl          CeSetThreadPriority

; 2156 :             // Wait for Thread DetachDownstreamDeviceThreadStub take m_pDetachedDevice before ending.
; 2157 :             WaitForSingleObject(m_pDetachedDeviceHandled,INFINITE);

  000a0	e5950064	 ldr         r0, [r5, #0x64]
  000a4	e3e01000	 mvn         r1, #0
  000a8	eb000000	 bl          WaitForSingleObject

; 2158 :             ASSERT(m_pDetachedDevice==NULL);
; 2159 :             CloseHandle( hWorkerThread );

  000ac	e1a00004	 mov         r0, r4
  000b0	eb000000	 bl          CloseHandle

; 2160 :             hWorkerThread = NULL;
; 2161 :         } else {

  000b4	ea000007	 b           |$LN2@DetachDevi|
  000b8		 |$LN3@DetachDevi|

; 2162 :             DWORD OriginalPrio = CeGetThreadPriority(GetCurrentThread());

  000b8	e3a00041	 mov         r0, #0x41
  000bc	eb000000	 bl          CeGetThreadPriority
  000c0	e1a04000	 mov         r4, r0

; 2163 :             // no threads available - need to handle detach ourself, which
; 2164 :             // can potentially block this hub for a while
; 2165 :             DEBUGMSG( ZONE_ATTACH, (TEXT("CHub(%s tier %d)::DetachDevice - no threads available, doing detach work now.\n"), GetDeviceType(), m_tierNumber ));
; 2166 :             DetachDownstreamDeviceThread();

  000c4	e1a00005	 mov         r0, r5
  000c8	eb000000	 bl          |?DetachDownstreamDeviceThread@CHub@@IAAKXZ|

; 2167 :             CeSetThreadPriority(GetCurrentThread(), OriginalPrio);

  000cc	e1a01004	 mov         r1, r4
  000d0	e3a00041	 mov         r0, #0x41
  000d4	eb000000	 bl          CeSetThreadPriority
  000d8		 |$LN2@DetachDevi|

; 2168 :         }
; 2169 :         DEBUGCHK( hWorkerThread == NULL );
; 2170 :         DisablePort( port );

  000d8	e5953000	 ldr         r3, [r5]
  000dc	e1a01006	 mov         r1, r6
  000e0	e1a00005	 mov         r0, r5
  000e4	e5933058	 ldr         r3, [r3, #0x58]
  000e8	e1a0e00f	 mov         lr, pc
  000ec	e12fff13	 bx          r3
  000f0		 |$LN5@DetachDevi|

; 2171 :     }
; 2172 :     if (m_pAddedTT[port-1]) {  // This is TT, we need delete this.

  000f0	e59530b4	 ldr         r3, [r5, #0xB4]
  000f4	e0833106	 add         r3, r3, r6, lsl #2
  000f8	e5133004	 ldr         r3, [r3, #-4]
  000fc	e3530000	 cmp         r3, #0
  00100	0a000009	 beq         |$LN1@DetachDevi|

; 2173 :         m_pDeviceGlobal->DeleteTt(m_address,port);

  00104	e5950050	 ldr         r0, [r5, #0x50]
  00108	e5d51020	 ldrb        r1, [r5, #0x20]
  0010c	e1a02006	 mov         r2, r6
  00110	e5903000	 ldr         r3, [r0]
  00114	e5933004	 ldr         r3, [r3, #4]
  00118	e1a0e00f	 mov         lr, pc
  0011c	e12fff13	 bx          r3

; 2174 :         m_pAddedTT[port-1]=FALSE;

  00120	e59530b4	 ldr         r3, [r5, #0xB4]
  00124	e0833106	 add         r3, r3, r6, lsl #2
  00128	e5037004	 str         r7, [r3, #-4]
  0012c		 |$LN1@DetachDevi|

; 2175 :     }
; 2176 :     DEBUGMSG( ZONE_ATTACH, (TEXT("-CHub(%s tier %d)::DetachDevice - port = %d\n"), GetDeviceType(), m_tierNumber, port) );
; 2177 : }

  0012c	e28dd008	 add         sp, sp, #8
  00130	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00134	e12fff1e	 bx          lr
  00138		 |$LN20@DetachDevi|
  00138		 |$LN21@DetachDevi|
  00138	00000000	 DCD         |g_IstThreadPriority|
  0013c		 |$LN22@DetachDevi|
  0013c	00000000	 DCD         |?DetachDownstreamDeviceThreadStub@CHub@@KAKPAX@Z|
  00140		 |$M37513|

			 ENDP  ; |?DetachDevice@CHub@@IAAXE@Z|, CHub::DetachDevice

	EXPORT	|??0CRootHub@@QAA@ABU_USB_DEVICE_INFO@@HHABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@@Z| ; CRootHub::CRootHub
	EXPORT	|??_7CRootHub@@6B@| [ DATA ]		; CRootHub::`vftable'
	EXPORT	|?EnterOperationalState@CRootHub@@UAAHQAVCPipeAbs@@@Z| ; CRootHub::EnterOperationalState
	IMPORT	|??_ECRootHub@@UAAPAXI@Z|, WEAK |??_GCRootHub@@UAAPAXI@Z| ; CRootHub::`vector deleting destructor', CRootHub::`scalar deleting destructor'

  00000			 AREA	 |.pdata|, PDATA
|$T37531| DCD	|$LN5@CRootHub|
	DCD	0x40001802

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7CRootHub@@6B@| DCD |??_ECRootHub@@UAAPAXI@Z|	; CRootHub::`vftable'
	DCD	|?EnterOperationalState@CRootHub@@UAAHQAVCPipeAbs@@@Z|
	DCD	|?OpenPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IQBU_USB_ENDPOINT_DESCRIPTOR@@QAI@Z|
	DCD	|?ClosePipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|
	DCD	|?IssueTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z|
	DCD	|?AbortTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXQBX@Z|
	DCD	|?IsPipeHalted@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQAH@Z|
	DCD	|?ResetPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|
	DCD	|?DisableDevice@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|
	DCD	|?SuspendResume@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|
	DCD	|?ResumeNotification@CHub@@UAAHXZ|
	DCD	|?NotifyOnSuspendedResumed@CHub@@UAAHH@Z|
	DCD	|?HandleDetach@CHub@@UAAXXZ|
	DCD	|?GetUSB2TT@CDevice@@UAAPAVCHub@@PAE0@Z|
	DCD	|?DisableOffStreamDevice@CHub@@UAAHIH@Z|
	DCD	|?SuspendResumeOffStreamDevice@CHub@@UAAHIH@Z|
	DCD	|?PowerAllHubPorts@CRootHub@@EAAHXZ|
	DCD	|?WaitForPortStatusChange@CRootHub@@EAAHAAEAAU_USB_HUB_AND_PORT_STATUS@@@Z|
	DCD	|?SetOrClearFeature@CRootHub@@EAAHGEG@Z|
	DCD	|?SetOrClearRemoteWakup@CRootHub@@EAAHH@Z|
	DCD	|?GetStatus@CRootHub@@EAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z|
	DCD	|?ResetAndEnablePort@CRootHub@@EAAHE@Z|
	DCD	|?DisablePort@CRootHub@@EAAXE@Z|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CRootHub@@QAA@ABU_USB_DEVICE_INFO@@HHABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@@Z| PROC ; CRootHub::CRootHub

; 2777 : {

  00000		 |$LN5@CRootHub|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M37528|
  00008	e1a04003	 mov         r4, r3
  0000c	e1a03002	 mov         r3, r2
  00010	e1a02001	 mov         r2, r1
  00014	e1a05000	 mov         r5, r0
  00018	e59d102c	 ldr         r1, [sp, #0x2C]
  0001c	e59de028	 ldr         lr, [sp, #0x28]
  00020	e3a06000	 mov         r6, #0
  00024	e58d100c	 str         r1, [sp, #0xC]
  00028	e3a01000	 mov         r1, #0
  0002c	e58de008	 str         lr, [sp, #8]
  00030	e58d6014	 str         r6, [sp, #0x14]
  00034	e58d6010	 str         r6, [sp, #0x10]
  00038	e58d6004	 str         r6, [sp, #4]
  0003c	e58d4000	 str         r4, [sp]
  00040	eb000000	 bl          |??0CHub@@QAA@EABU_USB_DEVICE_INFO@@HHEABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@QAV0@E@Z|
  00044	e59f3010	 ldr         r3, [pc, #0x10]

; 2778 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CRootHub::CRootHub\n")) );
; 2779 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CRootHub::CRootHub\n")) );
; 2780 : }

  00048	e1a00005	 mov         r0, r5
  0004c	e5853000	 str         r3, [r5]
  00050	e28dd018	 add         sp, sp, #0x18
  00054	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$LN6@CRootHub|
  0005c		 |$LN7@CRootHub|
  0005c	00000000	 DCD         |??_7CRootHub@@6B@|
  00060		 |$M37529|

			 ENDP  ; |??0CRootHub@@QAA@ABU_USB_DEVICE_INFO@@HHABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@@Z|, CRootHub::CRootHub

	EXPORT	|??1CRootHub@@UAA@XZ|			; CRootHub::~CRootHub

  00000			 AREA	 |.pdata|, PDATA
|$T37541| DCD	|$LN5@CRootHub@2|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CRootHub@@UAA@XZ| PROC		; CRootHub::~CRootHub

; 2794 : {

  00000		 |$LN5@CRootHub@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37538|
  00004	e1a02000	 mov         r2, r0
  00008	e59f300c	 ldr         r3, [pc, #0xC]

; 2795 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CRootHub::~CRootHub\n")) );
; 2796 :     // Nothing to do here yet...
; 2797 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CRootHub::~CRootHub\n")) );
; 2798 : }

  0000c	e5823000	 str         r3, [r2]
  00010	eb000000	 bl          |??1CHub@@UAA@XZ|
  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$LN6@CRootHub@2|
  0001c		 |$LN7@CRootHub@2|
  0001c	00000000	 DCD         |??_7CRootHub@@6B@|
  00020		 |$M37539|

			 ENDP  ; |??1CRootHub@@UAA@XZ|, CRootHub::~CRootHub

	EXPORT	|??0CExternalHub@@QAA@EABU_USB_DEVICE_INFO@@HHEABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@QAVCHub@@E@Z| ; CExternalHub::CExternalHub
	EXPORT	|??_7CExternalHub@@6B@| [ DATA ]	; CExternalHub::`vftable'
	EXPORT	|?EnterOperationalState@CExternalHub@@UAAHQAVCPipeAbs@@@Z| ; CExternalHub::EnterOperationalState
	IMPORT	|??_ECExternalHub@@UAAPAXI@Z|, WEAK |??_GCExternalHub@@UAAPAXI@Z| ; CExternalHub::`vector deleting destructor', CExternalHub::`scalar deleting destructor'

  00000			 AREA	 |.pdata|, PDATA
|$T37556| DCD	|$LN5@CExternalH|
	DCD	0x40001702

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7CExternalHub@@6B@| DCD |??_ECExternalHub@@UAAPAXI@Z| ; CExternalHub::`vftable'
	DCD	|?EnterOperationalState@CExternalHub@@UAAHQAVCPipeAbs@@@Z|
	DCD	|?OpenPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IQBU_USB_ENDPOINT_DESCRIPTOR@@QAI@Z|
	DCD	|?ClosePipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|
	DCD	|?IssueTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z|
	DCD	|?AbortTransfer@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXQBX@Z|
	DCD	|?IsPipeHalted@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IIQAH@Z|
	DCD	|?ResetPipe@CHub@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|
	DCD	|?DisableDevice@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|
	DCD	|?SuspendResume@CHub@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|
	DCD	|?ResumeNotification@CHub@@UAAHXZ|
	DCD	|?NotifyOnSuspendedResumed@CHub@@UAAHH@Z|
	DCD	|?HandleDetach@CHub@@UAAXXZ|
	DCD	|?GetUSB2TT@CDevice@@UAAPAVCHub@@PAE0@Z|
	DCD	|?DisableOffStreamDevice@CHub@@UAAHIH@Z|
	DCD	|?SuspendResumeOffStreamDevice@CHub@@UAAHIH@Z|
	DCD	|?PowerAllHubPorts@CExternalHub@@EAAHXZ|
	DCD	|?WaitForPortStatusChange@CExternalHub@@EAAHAAEAAU_USB_HUB_AND_PORT_STATUS@@@Z|
	DCD	|?SetOrClearFeature@CExternalHub@@EAAHGEG@Z|
	DCD	|?SetOrClearRemoteWakup@CExternalHub@@EAAHH@Z|
	DCD	|?GetStatus@CExternalHub@@EAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z|
	DCD	|?ResetAndEnablePort@CExternalHub@@EAAHE@Z|
	DCD	|?DisablePort@CExternalHub@@EAAXE@Z|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CExternalHub@@QAA@EABU_USB_DEVICE_INFO@@HHEABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@QAVCHub@@E@Z| PROC ; CExternalHub::CExternalHub

; 3103 : {

  00000		 |$LN5@CExternalH|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M37553|
  00008	e1a09000	 mov         r9, r0
  0000c	e5dde048	 ldrb        lr, [sp, #0x48]
  00010	e59d4044	 ldr         r4, [sp, #0x44]
  00014	e59d5040	 ldr         r5, [sp, #0x40]
  00018	e59d603c	 ldr         r6, [sp, #0x3C]
  0001c	e5dd7038	 ldrb        r7, [sp, #0x38]
  00020	e59d8034	 ldr         r8, [sp, #0x34]
  00024	e58de014	 str         lr, [sp, #0x14]
  00028	e58d4010	 str         r4, [sp, #0x10]
  0002c	e58d500c	 str         r5, [sp, #0xC]
  00030	e58d6008	 str         r6, [sp, #8]
  00034	e58d7004	 str         r7, [sp, #4]
  00038	e58d8000	 str         r8, [sp]
  0003c	eb000000	 bl          |??0CHub@@QAA@EABU_USB_DEVICE_INFO@@HHEABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@QAV0@E@Z|
  00040	e59f3010	 ldr         r3, [pc, #0x10]

; 3104 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CExternalHub::CExternalHub\n")) );
; 3105 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CExternalHub::CExternalHub\n")) );
; 3106 : }

  00044	e1a00009	 mov         r0, r9
  00048	e5893000	 str         r3, [r9]
  0004c	e28dd018	 add         sp, sp, #0x18
  00050	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$LN6@CExternalH|
  00058		 |$LN7@CExternalH|
  00058	00000000	 DCD         |??_7CExternalHub@@6B@|
  0005c		 |$M37554|

			 ENDP  ; |??0CExternalHub@@QAA@EABU_USB_DEVICE_INFO@@HHEABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@QAVCHub@@E@Z|, CExternalHub::CExternalHub

	EXPORT	|??1CExternalHub@@UAA@XZ|		; CExternalHub::~CExternalHub

  00000			 AREA	 |.pdata|, PDATA
|$T37566| DCD	|$LN5@CExternalH@2|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CExternalHub@@UAA@XZ| PROC		; CExternalHub::~CExternalHub

; 3120 : {

  00000		 |$LN5@CExternalH@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37563|
  00004	e1a02000	 mov         r2, r0
  00008	e59f300c	 ldr         r3, [pc, #0xC]

; 3121 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CExternalHub::~CExternalHub\n")) );
; 3122 :     // Nothing to do here yet...
; 3123 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CExternalHub::~CExternalHub\n")) );
; 3124 : }

  0000c	e5823000	 str         r3, [r2]
  00010	eb000000	 bl          |??1CHub@@UAA@XZ|
  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$LN6@CExternalH@2|
  0001c		 |$LN7@CExternalH@2|
  0001c	00000000	 DCD         |??_7CExternalHub@@6B@|
  00020		 |$M37564|

			 ENDP  ; |??1CExternalHub@@UAA@XZ|, CExternalHub::~CExternalHub

	EXPORT	|??0CFunction@@QAA@EABU_USB_DEVICE_INFO@@HHEQAVCHcd@@QAVCHub@@E@Z| ; CFunction::CFunction
	EXPORT	|??_7CFunction@@6B@| [ DATA ]		; CFunction::`vftable'
	EXPORT	|?ResetPipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@II@Z| ; CFunction::ResetPipe
	IMPORT	|??_ECFunction@@UAAPAXI@Z|, WEAK |??_GCFunction@@UAAPAXI@Z| ; CFunction::`vector deleting destructor', CFunction::`scalar deleting destructor'

  00000			 AREA	 |.pdata|, PDATA
|$T37582| DCD	|$LN5@CFunction|
	DCD	0x40001902

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7CFunction@@6B@| DCD |??_ECFunction@@UAAPAXI@Z|	; CFunction::`vftable'
	DCD	|?EnterOperationalState@CFunction@@UAAHQAVCPipeAbs@@@Z|
	DCD	|?OpenPipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IQBU_USB_ENDPOINT_DESCRIPTOR@@QAI@Z|
	DCD	|?ClosePipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|
	DCD	|?IssueTransfer@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXKQBXKKQBKK2K3QAK5QAH55@Z|
	DCD	|?AbortTransfer@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQ6AKPAX@ZQAXQBX@Z|
	DCD	|?IsPipeHalted@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@IIQAH@Z|
	DCD	|?ResetPipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|
	DCD	|?DisableDevice@CDevice@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|
	DCD	|?SuspendResume@CDevice@@UAA?AW4HCD_REQUEST_STATUS@@IH@Z|
	DCD	|?ResumeNotification@CDevice@@UAAHXZ|
	DCD	|?NotifyOnSuspendedResumed@CFunction@@UAAHH@Z|
	DCD	|?HandleDetach@CFunction@@EAAXXZ|
	DCD	|?GetUSB2TT@CDevice@@UAAPAVCHub@@PAE0@Z|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CFunction@@QAA@EABU_USB_DEVICE_INFO@@HHEQAVCHcd@@QAVCHub@@E@Z| PROC ; CFunction::CFunction

; 3797 : {

  00000		 |$LN5@CFunction|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M37579|
  00008	e1a08000	 mov         r8, r0
  0000c	e5dd503c	 ldrb        r5, [sp, #0x3C]
  00010	e59d6038	 ldr         r6, [sp, #0x38]
  00014	e59d7034	 ldr         r7, [sp, #0x34]
  00018	e5dde030	 ldrb        lr, [sp, #0x30]
  0001c	e59d402c	 ldr         r4, [sp, #0x2C]
  00020	e58d5010	 str         r5, [sp, #0x10]
  00024	e58d600c	 str         r6, [sp, #0xC]
  00028	e58d7008	 str         r7, [sp, #8]
  0002c	e58de004	 str         lr, [sp, #4]
  00030	e58d4000	 str         r4, [sp]
  00034	eb000000	 bl          |??0CDevice@@QAA@EABU_USB_DEVICE_INFO@@HHEQAVCDeviceGlobal@@QAVCHub@@E@Z|
  00038	e59f3020	 ldr         r3, [pc, #0x20]
  0003c	e3a02000	 mov         r2, #0
  00040	e5882060	 str         r2, [r8, #0x60]
  00044	e5883000	 str         r3, [r8]
  00048	e5882064	 str         r2, [r8, #0x64]
  0004c	e5887068	 str         r7, [r8, #0x68]

; 3798 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("+CFunction(tier %d)::CFunction\n"), tierNumber) );
; 3799 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("-CFunction(tier %d)::CFunction\n"), tierNumber) );
; 3800 : }

  00050	e1a00008	 mov         r0, r8
  00054	e28dd014	 add         sp, sp, #0x14
  00058	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$LN6@CFunction|
  00060		 |$LN7@CFunction|
  00060	00000000	 DCD         |??_7CFunction@@6B@|
  00064		 |$M37580|

			 ENDP  ; |??0CFunction@@QAA@EABU_USB_DEVICE_INFO@@HHEQAVCHcd@@QAVCHub@@E@Z|, CFunction::CFunction

	EXPORT	|??1CFunction@@UAA@XZ|			; CFunction::~CFunction

  00000			 AREA	 |.pdata|, PDATA
|$T37592| DCD	|$LN5@CFunction@2|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CFunction@@UAA@XZ| PROC		; CFunction::~CFunction

; 3815 : {

  00000		 |$LN5@CFunction@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37589|
  00004	e1a02000	 mov         r2, r0
  00008	e59f300c	 ldr         r3, [pc, #0xC]

; 3816 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("+CFunction(tier %d)::~CFunction\n"), m_tierNumber) );
; 3817 : 
; 3818 :     DEBUGCHK( m_lpvDetachId == NULL );
; 3819 : 
; 3820 :     // rest of processing done in base destructors...
; 3821 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("-CFunction(tier %d)::~CFunction\n"), m_tierNumber) );
; 3822 : }

  0000c	e5823000	 str         r3, [r2]
  00010	eb000000	 bl          |??1CDevice@@UAA@XZ|
  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$LN6@CFunction@2|
  0001c		 |$LN7@CFunction@2|
  0001c	00000000	 DCD         |??_7CFunction@@6B@|
  00020		 |$M37590|

			 ENDP  ; |??1CFunction@@UAA@XZ|, CFunction::~CFunction

	EXPORT	|??_C@_1KO@DBPBLAEA@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAR?$AAe?$AAs?$AAe?$AAt?$AAP?$AAi?$AAp@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T37609| DCD	|$LN13@ResetPipe@2|
	DCD	0x40003902

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1KO@DBPBLAEA@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAR?$AAe?$AAs?$AAe?$AAt?$AAP?$AAi?$AAp@| DCB "!"
	DCB	0x0, "!", 0x0, "!", 0x0, "C", 0x0, "F", 0x0, "u", 0x0, "n"
	DCB	0x0, "c", 0x0, "t", 0x0, "i", 0x0, "o", 0x0, "n", 0x0, "("
	DCB	0x0, " ", 0x0, "t", 0x0, "i", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, ")", 0x0, ":", 0x0, ":", 0x0, "R"
	DCB	0x0, "e", 0x0, "s", 0x0, "e", 0x0, "t", 0x0, "P", 0x0, "i"
	DCB	0x0, "p", 0x0, "e", 0x0, " ", 0x0, "o", 0x0, "n", 0x0, " "
	DCB	0x0, "s", 0x0, "u", 0x0, "s", 0x0, "p", 0x0, "e", 0x0, "n"
	DCB	0x0, "d", 0x0, " ", 0x0, "s", 0x0, "t", 0x0, "a", 0x0, "t"
	DCB	0x0, "e", 0x0, " ", 0x0, "i", 0x0, "s", 0x0, " ", 0x0, "i"
	DCB	0x0, "l", 0x0, "l", 0x0, "g", 0x0, "l", 0x0, "e", 0x0, ","
	DCB	0x0, " ", 0x0, "a", 0x0, "d", 0x0, "d", 0x0, "r", 0x0, "e"
	DCB	0x0, "s", 0x0, "s", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "%"
	DCB	0x0, "d", 0x0, ",", 0x0, " ", 0x0, "p", 0x0, "i", 0x0, "p"
	DCB	0x0, "e", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "%", 0x0, "d"
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResetPipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@II@Z| PROC ; CFunction::ResetPipe

; 4283 : {

  00000		 |$LN13@ResetPipe@2|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M37606|
  00008	e1b06002	 movs        r6, r2
  0000c	e1a07001	 mov         r7, r1
  00010	e1a04000	 mov         r4, r0

; 4284 :     // Some [broken] devices panic if you try to clear the HALT feature on EP0.
; 4285 :     // Since it's an unnecessary operation in any case, we'll translate it to a NOP.
; 4286 :     if (pipeIndex == 0)
; 4287 :         return requestOK;

  00014	03a05001	 moveq       r5, #1
  00018	0a00002b	 beq         |$LN5@ResetPipe@2|

; 4288 : 
; 4289 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("+CFunction(tier %d)::ResetPipe - address = %d, pipe = %d\n"), m_tierNumber, address, pipeIndex) );
; 4290 : 
; 4291 :     HCD_REQUEST_STATUS status = requestIgnored;
; 4292 : 
; 4293 :     // don't have to enter critical section until after checking
; 4294 :     // m_address (since m_address is const). That ensures we
; 4295 :     // won't wait for the critical section unless we actually
; 4296 :     // have something to do
; 4297 :     if ( address == m_address ) {

  0001c	e5d43020	 ldrb        r3, [r4, #0x20]
  00020	e3a05002	 mov         r5, #2
  00024	e1570003	 cmp         r7, r3
  00028	1a000027	 bne         |$LN5@ResetPipe@2|

; 4298 :         status = requestFailed;
; 4299 :         EnterCriticalSection( &m_csDeviceLock );

  0002c	e284000c	 add         r0, r4, #0xC
  00030	e3a05000	 mov         r5, #0
  00034	eb000000	 bl          EnterCriticalSection

; 4300 :         if (m_fIsSuspend | g_fOmapEhciSuspended) {

  00038	e59f30a0	 ldr         r3, [pc, #0xA0]
  0003c	e5942058	 ldr         r2, [r4, #0x58]
  00040	e5933000	 ldr         r3, [r3]
  00044	e1923003	 orrs        r3, r2, r3
  00048	0a000005	 beq         |$LN4@ResetPipe@2|

; 4301 :             RETAILMSG(1,(TEXT("!!!CFunction( tier %d)::ResetPipe on suspend state is illgle, address = %d, pipe = %d\n"), m_tierNumber, address, pipeIndex));

  0004c	e5d4104c	 ldrb        r1, [r4, #0x4C]
  00050	e59f0084	 ldr         r0, [pc, #0x84]
  00054	e1a03006	 mov         r3, r6
  00058	e1a02007	 mov         r2, r7
  0005c	eb000000	 bl          NKDbgPrintfW

; 4302 :             ASSERT(FALSE);
; 4303 :         }
; 4304 :         else

  00060	ea000017	 b           |$LN1@ResetPipe@2|
  00064		 |$LN4@ResetPipe@2|

; 4305 :         if ( pipeIndex < m_maxNumPipes && m_ppCPipe[ pipeIndex ] != NULL ) {

  00064	e5d43054	 ldrb        r3, [r4, #0x54]
  00068	e1560003	 cmp         r6, r3
  0006c	2a000014	 bcs         |$LN1@ResetPipe@2|
  00070	e594305c	 ldr         r3, [r4, #0x5C]
  00074	e7933106	 ldr         r3, [r3, +r6, lsl #2]
  00078	e3530000	 cmp         r3, #0
  0007c	0a000010	 beq         |$LN1@ResetPipe@2|

; 4306 :             m_ppCPipe[ pipeIndex ]->ClearHaltedFlag();

  00080	e594305c	 ldr         r3, [r4, #0x5C]
  00084	e7930106	 ldr         r0, [r3, +r6, lsl #2]
  00088	e5903000	 ldr         r3, [r0]
  0008c	e5933018	 ldr         r3, [r3, #0x18]
  00090	e1a0e00f	 mov         lr, pc
  00094	e12fff13	 bx          r3

; 4307 : 
; 4308 :             if(SetOrClearFeature( USB_ENDPOINT_RECIPIENT,
; 4309 :                                   m_ppCPipe[ pipeIndex ]->m_bEndpointAddress,
; 4310 :                                   USB_REQUEST_CLEAR_FEATURE,
; 4311 :                                   USB_FEATURE_ENDPOINT_HALT ))

  00098	e594205c	 ldr         r2, [r4, #0x5C]
  0009c	e3a0e000	 mov         lr, #0
  000a0	e3a03001	 mov         r3, #1
  000a4	e7922106	 ldr         r2, [r2, +r6, lsl #2]
  000a8	e3a01002	 mov         r1, #2
  000ac	e1a00004	 mov         r0, r4
  000b0	e5d22004	 ldrb        r2, [r2, #4]
  000b4	e58de000	 str         lr, [sp]
  000b8	eb000000	 bl          |?SetOrClearFeature@CFunction@@AAAHEGEG@Z|
  000bc	e3500000	 cmp         r0, #0

; 4312 :                 status = requestOK;

  000c0	13a05001	 movne       r5, #1
  000c4		 |$LN1@ResetPipe@2|

; 4313 :         }
; 4314 :         LeaveCriticalSection( &m_csDeviceLock );

  000c4	e284000c	 add         r0, r4, #0xC
  000c8	eb000000	 bl          LeaveCriticalSection
  000cc		 |$LN5@ResetPipe@2|

; 4315 :     }
; 4316 : 
; 4317 :     DEBUGMSG( ZONE_FUNCTION && ZONE_VERBOSE, (TEXT("-CFunction(tier %d)::ResetPipe - address = %d, pipe = %d, returing HCD_REQUEST_STATUS %d\n"), m_tierNumber, address, pipeIndex, status) );
; 4318 :     return status;
; 4319 : }

  000cc	e1a00005	 mov         r0, r5
  000d0	e28dd004	 add         sp, sp, #4
  000d4	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000d8	e12fff1e	 bx          lr
  000dc		 |$LN14@ResetPipe@2|
  000dc		 |$LN15@ResetPipe@2|
  000dc	00000000	 DCD         |??_C@_1KO@DBPBLAEA@?$AA?$CB?$AA?$CB?$AA?$CB?$AAC?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$CI?$AA?5?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAR?$AAe?$AAs?$AAe?$AAt?$AAP?$AAi?$AAp@|
  000e0		 |$LN16@ResetPipe@2|
  000e0	00000000	 DCD         |g_fOmapEhciSuspended|
  000e4		 |$M37607|

			 ENDP  ; |?ResetPipe@CFunction@@UAA?AW4HCD_REQUEST_STATUS@@II@Z|, CFunction::ResetPipe


  00000			 AREA	 |.pdata|, PDATA
|$T37623| DCD	|$LN6@scalar|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GCDevice@@UAAPAXI@Z| PROC		; CDevice::`scalar deleting destructor'
  00000		 |$LN6@scalar|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37620|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          |??1CDevice@@UAA@XZ|
  00010	e3140001	 tst         r4, #1
  00014	11a00005	 movne       r0, r5
  00018	1b000000	 blne        |??3@YAXPAX@Z|
  0001c	e1a00005	 mov         r0, r5
  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M37621|

			 ENDP  ; |??_GCDevice@@UAAPAXI@Z|, CDevice::`scalar deleting destructor'


  00000			 AREA	 |.pdata|, PDATA
|$T37634| DCD	|$LN6@scalar@2|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GCHub@@UAAPAXI@Z| PROC		; CHub::`scalar deleting destructor'
  00000		 |$LN6@scalar@2|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37631|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          |??1CHub@@UAA@XZ|
  00010	e3140001	 tst         r4, #1
  00014	11a00005	 movne       r0, r5
  00018	1b000000	 blne        |??3@YAXPAX@Z|
  0001c	e1a00005	 mov         r0, r5
  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M37632|

			 ENDP  ; |??_GCHub@@UAAPAXI@Z|, CHub::`scalar deleting destructor'

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?AttachDevice@CHub@@IAAXEHH@Z|		; CHub::AttachDevice
	EXPORT	|??_C@_1II@HDIFDMNL@?$AA?$CB?$AAU?$AAS?$AAB?$AA?5?$AAw?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAa?$AAt?$AAt?$AAa?$AAc?$AAh?$AA?5?$AAh?$AAi?$AAg?$AAh@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HE@DLPCNLDH@?$AA?$CB?$AAC?$AAH?$AAu?$AAb?$AA?3?$AA?3?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAw?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAi?$AAn?$AAv@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HK@HGAGGCPB@?$AAU?$AAS?$AAB?$AA?5?$AAs?$AAp?$AAe?$AAc?$AAi?$AAf?$AAi?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAd?$AAo?$AAe?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAw@| [ DATA ] ; `string'
	IMPORT	|HcdPdd_CheckConfigPower|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|__security_check_cookie|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T37811| DCD	|$LN206@AttachDevi|
	DCD	0xc0033f02

  00000			 AREA	 |.xdata|, DATA
|$T37807| DCD	0xffffffd8

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1II@HDIFDMNL@?$AA?$CB?$AAU?$AAS?$AAB?$AA?5?$AAw?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAa?$AAt?$AAt?$AAa?$AAc?$AAh?$AA?5?$AAh?$AAi?$AAg?$AAh@| DCB "!"
	DCB	0x0, "U", 0x0, "S", 0x0, "B", 0x0, " ", 0x0, "w", 0x0, "a"
	DCB	0x0, "r", 0x0, "n", 0x0, "i", 0x0, "n", 0x0, "g", 0x0, ":"
	DCB	0x0, " ", 0x0, "c", 0x0, "a", 0x0, "n", 0x0, "n", 0x0, "o"
	DCB	0x0, "t", 0x0, " ", 0x0, "a", 0x0, "t", 0x0, "t", 0x0, "a"
	DCB	0x0, "c", 0x0, "h", 0x0, " ", 0x0, "h", 0x0, "i", 0x0, "g"
	DCB	0x0, "h", 0x0, "-", 0x0, "p", 0x0, "o", 0x0, "w", 0x0, "e"
	DCB	0x0, "r", 0x0, " ", 0x0, "d", 0x0, "e", 0x0, "v", 0x0, "i"
	DCB	0x0, "c", 0x0, "e", 0x0, " ", 0x0, "t", 0x0, "o", 0x0, " "
	DCB	0x0, "a", 0x0, " ", 0x0, "b", 0x0, "u", 0x0, "s", 0x0, "-"
	DCB	0x0, "p", 0x0, "o", 0x0, "w", 0x0, "e", 0x0, "r", 0x0, "e"
	DCB	0x0, "d", 0x0, " ", 0x0, "h", 0x0, "u", 0x0, "b", 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HE@DLPCNLDH@?$AA?$CB?$AAC?$AAH?$AAu?$AAb?$AA?3?$AA?3?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAw?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAi?$AAn?$AAv@| DCB "!"
	DCB	0x0, "C", 0x0, "H", 0x0, "u", 0x0, "b", 0x0, ":", 0x0, ":"
	DCB	0x0, "A", 0x0, "t", 0x0, "t", 0x0, "a", 0x0, "c", 0x0, "h"
	DCB	0x0, "D", 0x0, "e", 0x0, "v", 0x0, "i", 0x0, "c", 0x0, "e"
	DCB	0x0, " ", 0x0, "w", 0x0, "a", 0x0, "r", 0x0, "n", 0x0, "i"
	DCB	0x0, "n", 0x0, "g", 0x0, ":", 0x0, " ", 0x0, "i", 0x0, "n"
	DCB	0x0, "v", 0x0, "a", 0x0, "l", 0x0, "i", 0x0, "d", 0x0, " "
	DCB	0x0, "p", 0x0, "o", 0x0, "w", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "c", 0x0, "o", 0x0, "n", 0x0, "f", 0x0, "i", 0x0, "g"
	DCB	0x0, "u", 0x0, "r", 0x0, "a", 0x0, "t", 0x0, "i", 0x0, "o"
	DCB	0x0, "n", 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HK@HGAGGCPB@?$AAU?$AAS?$AAB?$AA?5?$AAs?$AAp?$AAe?$AAc?$AAi?$AAf?$AAi?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAd?$AAo?$AAe?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAw@| DCB "U"
	DCB	0x0, "S", 0x0, "B", 0x0, " ", 0x0, "s", 0x0, "p", 0x0, "e"
	DCB	0x0, "c", 0x0, "i", 0x0, "f", 0x0, "i", 0x0, "c", 0x0, "a"
	DCB	0x0, "t", 0x0, "i", 0x0, "o", 0x0, "n", 0x0, " ", 0x0, "d"
	DCB	0x0, "o", 0x0, "e", 0x0, "s", 0x0, " ", 0x0, "n", 0x0, "o"
	DCB	0x0, "t", 0x0, " ", 0x0, "a", 0x0, "l", 0x0, "l", 0x0, "o"
	DCB	0x0, "w", 0x0, " ", 0x0, "m", 0x0, "o", 0x0, "r", 0x0, "e"
	DCB	0x0, " ", 0x0, "t", 0x0, "h", 0x0, "a", 0x0, "n", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, " ", 0x0, "h", 0x0, "u", 0x0, "b"
	DCB	0x0, "s", 0x0, " ", 0x0, "i", 0x0, "n", 0x0, " ", 0x0, "a"
	DCB	0x0, " ", 0x0, "r", 0x0, "o", 0x0, "w", 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T37807|

  00008		 |?AttachDevice@CHub@@IAAXEHH@Z| PROC	; CHub::AttachDevice

; 1362 : {

  00008		 |$LN206@AttachDevi|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd0ec	 sub         sp, sp, #0xEC
  00010		 |$M37808|
  00010	e58d3080	 str         r3, [sp, #0x80]
  00014	e58d2084	 str         r2, [sp, #0x84]
  00018	e5cd1040	 strb        r1, [sp, #0x40]
  0001c	e1a09000	 mov         r9, r0
  00020	e59fecd8	 ldr         lr, [pc, #0xCD8]
  00024	e59ee000	 ldr         lr, [lr]
  00028	e58de0e8	 str         lr, [sp, #0xE8]

; 1363 :     DEBUGMSG( ZONE_ATTACH, (TEXT("+CHub(%s tier %d)::AttachDevice - port = %d, fIsLowSpeed = %d, fIsHighSpeed =%d\n"), GetDeviceType(), m_tierNumber, port, fIsLowSpeed, fIsHighSpeed ) );
; 1364 : 
; 1365 :     DEBUGCHK( port > 0 && port <= m_usbHubDescriptor.bNumberOfPorts );
; 1366 : 
; 1367 :     // device related variables
; 1368 :     CDevice*                pNewDevice = NULL;
; 1369 :     UCHAR                   address = 0xff; // illegal address
; 1370 :     USB_DEVICE_INFO         deviceInfo;
; 1371 :     USB_HUB_DESCRIPTOR      usbHubDescriptor;
; 1372 :     CPipeAbs*               pControlPipe = NULL; // pipe to device's endpoint 0
; 1373 : 
; 1374 :     // setup process related varibles
; 1375 :     BOOL                    fUsingAddr0 = FALSE;
; 1376 :     DEVICE_CONFIG_STATUS    configStatus = DEVICE_CONFIG_STATUS_OPENING_ENDPOINT0_PIPE;
; 1377 :     UCHAR                   configFailures = 0;
; 1378 :     UINT                    currentConfigDescriptorIndex = 0;
; 1379 :     BOOL                    fPipeHalted = FALSE;
; 1380 : 
; 1381 :     deviceInfo.dwCount = sizeof( USB_DEVICE_INFO );
; 1382 :     deviceInfo.lpActiveConfig = NULL;
; 1383 :     deviceInfo.lpConfigs = NULL;
; 1384 : 
; 1385 :     if ( !ReserveAddress( address ) ) {

  0002c	e3a030ff	 mov         r3, #0xFF
  00030	e5990050	 ldr         r0, [r9, #0x50]
  00034	e5cd3039	 strb        r3, [sp, #0x39]
  00038	e3a03000	 mov         r3, #0
  0003c	e3a02000	 mov         r2, #0
  00040	e3a0e020	 mov         lr, #0x20
  00044	e3a04000	 mov         r4, #0
  00048	e3a08000	 mov         r8, #0
  0004c	e3a06000	 mov         r6, #0
  00050	e3a05000	 mov         r5, #0
  00054	e3a07000	 mov         r7, #0
  00058	e28d1039	 add         r1, sp, #0x39
  0005c	e58d3078	 str         r3, [sp, #0x78]
  00060	e58d6044	 str         r6, [sp, #0x44]
  00064	e3a0b000	 mov         r11, #0
  00068	e58d506c	 str         r5, [sp, #0x6C]
  0006c	e3a0a000	 mov         r10, #0
  00070	e5cd7038	 strb        r7, [sp, #0x38]
  00074	e58d203c	 str         r2, [sp, #0x3C]
  00078	e58de048	 str         lr, [sp, #0x48]
  0007c	e58d4064	 str         r4, [sp, #0x64]
  00080	e58d8060	 str         r8, [sp, #0x60]
  00084	eb000000	 bl          |?ReserveAddress@CDeviceGlobal@@QAAHAAE@Z|
  00088	e3500000	 cmp         r0, #0

; 1386 :         DEBUGMSG( ZONE_WARNING, (TEXT("CHub(%s tier %d)::AttachDevice - all USB addresses are in use!\n"), GetDeviceType(), m_tierNumber) );
; 1387 :         // don't do any attach processing
; 1388 :         configStatus = DEVICE_CONFIG_STATUS_DONE;
; 1389 :     }
; 1390 :     while ( configStatus != DEVICE_CONFIG_STATUS_DONE ) {

  0008c	0a000312	 beq         |$LN158@AttachDevi|
  00090	e5dd8039	 ldrb        r8, [sp, #0x39]
  00094		 |$LN171@AttachDevi|
  00094	e59d0060	 ldr         r0, [sp, #0x60]
  00098		 |$LN173@AttachDevi|
  00098	e5dde0a0	 ldrb        lr, [sp, #0xA0]
  0009c	e5dd405d	 ldrb        r4, [sp, #0x5D]
  000a0	e59d2064	 ldr         r2, [sp, #0x64]
  000a4	e59d103c	 ldr         r1, [sp, #0x3C]
  000a8		 |$LL98@AttachDevi|

; 1391 :         if ( m_fHubThreadClosing || fPipeHalted || configFailures > 2 ) {

  000a8	e59930b8	 ldr         r3, [r9, #0xB8]
  000ac	e1b05003	 movs        r5, r3
  000b0	1a000003	 bne         |$LN95@AttachDevi|
  000b4	e3510000	 cmp         r1, #0
  000b8	1a000001	 bne         |$LN95@AttachDevi|
  000bc	e3570002	 cmp         r7, #2
  000c0	9a000000	 bls         |$LN96@AttachDevi|
  000c4		 |$LN95@AttachDevi|

; 1392 :             configStatus = DEVICE_CONFIG_STATUS_FAILED;

  000c4	e3a0a013	 mov         r10, #0x13
  000c8		 |$LN96@AttachDevi|

; 1393 :         }
; 1394 :         DEBUGMSG( ZONE_ATTACH, (TEXT("CHub(%s tier %d)::AttachDevice - status = %s, failures = %d\n"), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ), configFailures ) );
; 1395 :         switch ( configStatus ) {

  000c8	e35a0013	 cmp         r10, #0x13
  000cc	8a0002ff	 bhi         |$LN93@AttachDevi|
  000d0	e1a0308a	 mov         r3, r10, lsl #1
  000d4	e083300f	 add         r3, r3, pc
  000d8	e1d330b4	 ldrh        r3, [r3, #4]
  000dc	e08ff003	 add         pc, pc, r3
  000e0		 |$LN183@AttachDevi|
  000e0		 |$LN182@AttachDevi|
  000e0		 |$LN184@AttachDevi|
  000e0	0024		 DCW         0x24
  000e2		 |$LN185@AttachDevi|
  000e2	0154		 DCW         0x154
  000e4		 |$LN186@AttachDevi|
  000e4	0184		 DCW         0x184
  000e6		 |$LN187@AttachDevi|
  000e6	01b8		 DCW         0x1b8
  000e8		 |$LN188@AttachDevi|
  000e8	021c		 DCW         0x21c
  000ea		 |$LN189@AttachDevi|
  000ea	03ac		 DCW         0x3ac
  000ec		 |$LN190@AttachDevi|
  000ec	03d0		 DCW         0x3d0
  000ee		 |$LN191@AttachDevi|
  000ee	0470		 DCW         0x470
  000f0		 |$LN192@AttachDevi|
  000f0	04c4		 DCW         0x4c4
  000f2		 |$LN193@AttachDevi|
  000f2	0530		 DCW         0x530
  000f4		 |$LN194@AttachDevi|
  000f4	058c		 DCW         0x58c
  000f6		 |$LN195@AttachDevi|
  000f6	066c		 DCW         0x66c
  000f8		 |$LN196@AttachDevi|
  000f8	0784		 DCW         0x784
  000fa		 |$LN197@AttachDevi|
  000fa	0910		 DCW         0x910
  000fc		 |$LN198@AttachDevi|
  000fc	0910		 DCW         0x910
  000fe		 |$LN199@AttachDevi|
  000fe	099c		 DCW         0x99c
  00100		 |$LN200@AttachDevi|
  00100	0a10		 DCW         0xa10
  00102		 |$LN201@AttachDevi|
  00102	0a64		 DCW         0xa64
  00104		 |$LN202@AttachDevi|
  00104	0a8c		 DCW         0xa8c
  00106		 |$LN203@AttachDevi|
  00106	0abc		 DCW         0xabc
  00108		 |$LN92@AttachDevi|

; 1396 :         case DEVICE_CONFIG_STATUS_OPENING_ENDPOINT0_PIPE:
; 1397 :         {
; 1398 :             // Create TT if it is neccessary.
; 1399 :             if (m_fIsHighSpeed && !fIsHighSpeed &&  !m_pAddedTT[port-1]) { // Hi-Speed Hub and Low Speed device.

  00108	e5993048	 ldr         r3, [r9, #0x48]
  0010c	e3530000	 cmp         r3, #0
  00110	0a000012	 beq         |$LN91@AttachDevi|
  00114	e59d3080	 ldr         r3, [sp, #0x80]
  00118	e3530000	 cmp         r3, #0
  0011c	1a00000f	 bne         |$LN91@AttachDevi|
  00120	e59930b4	 ldr         r3, [r9, #0xB4]
  00124	e5dd4040	 ldrb        r4, [sp, #0x40]
  00128	e0833104	 add         r3, r3, r4, lsl #2
  0012c	e5133004	 ldr         r3, [r3, #-4]
  00130	e3530000	 cmp         r3, #0
  00134	1a000009	 bne         |$LN91@AttachDevi|

; 1400 :                 m_pAddedTT[port-1] = m_pDeviceGlobal->AddedTt(m_address,port);

  00138	e5990050	 ldr         r0, [r9, #0x50]
  0013c	e5d91020	 ldrb        r1, [r9, #0x20]
  00140	e1a02004	 mov         r2, r4
  00144	e5903000	 ldr         r3, [r0]
  00148	e5933000	 ldr         r3, [r3]
  0014c	e1a0e00f	 mov         lr, pc
  00150	e12fff13	 bx          r3
  00154	e59930b4	 ldr         r3, [r9, #0xB4]
  00158	e0833104	 add         r3, r3, r4, lsl #2
  0015c	e5030004	 str         r0, [r3, #-4]
  00160		 |$LN91@AttachDevi|

; 1401 :             }
; 1402 :             DEBUGCHK( pControlPipe == NULL );
; 1403 :             USB_ENDPOINT_DESCRIPTOR usbEndpointZeroDescriptor;
; 1404 :             usbEndpointZeroDescriptor.bDescriptorType = USB_ENDPOINT_DESCRIPTOR_TYPE;
; 1405 :             usbEndpointZeroDescriptor.bEndpointAddress = 0;
; 1406 :             // usbEndpointZeroDescriptor.bInterval = ; <- ignored for control pipes
; 1407 :             usbEndpointZeroDescriptor.bLength = sizeof( USB_ENDPOINT_DESCRIPTOR );
; 1408 :             usbEndpointZeroDescriptor.bmAttributes = USB_ENDPOINT_TYPE_CONTROL;
; 1409 :             usbEndpointZeroDescriptor.wMaxPacketSize = ENDPOINT_ZERO_MIN_MAXPACKET_SIZE;
; 1410 :             UCHAR uTTHubAddr= m_address;
; 1411 :             UCHAR uTTHubPort= port;
; 1412 :             GetUSB2TT(&uTTHubAddr,&uTTHubPort);

  00160	e3a05005	 mov         r5, #5
  00164	e5d94020	 ldrb        r4, [r9, #0x20]
  00168	e5cd5089	 strb        r5, [sp, #0x89]
  0016c	e3a05000	 mov         r5, #0
  00170	e5cd508a	 strb        r5, [sp, #0x8A]
  00174	e5993000	 ldr         r3, [r9]
  00178	e3a05000	 mov         r5, #0
  0017c	e5cd4069	 strb        r4, [sp, #0x69]
  00180	e5dd4040	 ldrb        r4, [sp, #0x40]
  00184	e5cd508b	 strb        r5, [sp, #0x8B]
  00188	e3a05008	 mov         r5, #8
  0018c	e5933034	 ldr         r3, [r3, #0x34]
  00190	e3a0b007	 mov         r11, #7
  00194	e1cd58bc	 strh        r5, [sp, #0x8C]
  00198	e28d2068	 add         r2, sp, #0x68
  0019c	e28d1069	 add         r1, sp, #0x69
  001a0	e1a00009	 mov         r0, r9
  001a4	e5cdb088	 strb        r11, [sp, #0x88]
  001a8	e5cd4068	 strb        r4, [sp, #0x68]
  001ac	e1a0e00f	 mov         lr, pc
  001b0	e12fff13	 bx          r3

; 1413 :             pControlPipe = CreateControlPipe( &usbEndpointZeroDescriptor,
; 1414 :                                              fIsLowSpeed, fIsHighSpeed ,0,
; 1415 :                                              uTTHubAddr,uTTHubPort,
; 1416 :                                              m_pCHcd);

  001b4	e5dd2068	 ldrb        r2, [sp, #0x68]
  001b8	e5dd1069	 ldrb        r1, [sp, #0x69]
  001bc	e59930c8	 ldr         r3, [r9, #0xC8]
  001c0	e58d2004	 str         r2, [sp, #4]
  001c4	e59d2080	 ldr         r2, [sp, #0x80]
  001c8	e58d1000	 str         r1, [sp]
  001cc	e59d1084	 ldr         r1, [sp, #0x84]
  001d0	e58d3008	 str         r3, [sp, #8]
  001d4	e3a03000	 mov         r3, #0
  001d8	e28d0088	 add         r0, sp, #0x88
  001dc	eb000000	 bl          |?CreateControlPipe@@YAPAVCPipeAbs@@QBU_USB_ENDPOINT_DESCRIPTOR@@HHEEEQAVCHcd@@@Z|
  001e0	e1b0b000	 movs        r11, r0

; 1417 :             if ( pControlPipe != NULL && pControlPipe->OpenPipe() == requestOK ) {

  001e4	0a000007	 beq         |$LN90@AttachDevi|
  001e8	e59b3000	 ldr         r3, [r11]
  001ec	e1a0000b	 mov         r0, r11
  001f0	e5933004	 ldr         r3, [r3, #4]
  001f4	e1a0e00f	 mov         lr, pc
  001f8	e12fff13	 bx          r3
  001fc	e3500001	 cmp         r0, #1

; 1418 :                 // success
; 1419 :                 configStatus = DEVICE_CONFIG_STATUS_USING_ADDRESS0;
; 1420 :             } else {

  00200	03a0a001	 moveq       r10, #1
  00204	0affffa2	 beq         |$LN171@AttachDevi|
  00208		 |$LN90@AttachDevi|

; 1421 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("CHub(%s tier %d)::AttachDevice - failure on %s step, unable to open control pipe\n"), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1422 :                 configFailures++;

  00208	e2873001	 add         r3, r7, #1

; 1423 :                 delete pControlPipe;

  0020c	e35b0000	 cmp         r11, #0
  00210	e20370ff	 and         r7, r3, #0xFF
  00214	159b3000	 ldrne       r3, [r11]
  00218	e5cd7038	 strb        r7, [sp, #0x38]
  0021c	13a01001	 movne       r1, #1
  00220	15933000	 ldrne       r3, [r3]
  00224	11a0000b	 movne       r0, r11
  00228	11a0e00f	 movne       lr, pc
  0022c	112fff13	 bxne        r3

; 1424 :                 pControlPipe = NULL;
; 1425 :             }
; 1426 :             break;

  00230	e3a0b000	 mov         r11, #0
  00234	eaffff96	 b           |$LN171@AttachDevi|
  00238		 |$LN88@AttachDevi|

; 1427 :         }
; 1428 :         case DEVICE_CONFIG_STATUS_USING_ADDRESS0:
; 1429 :         {
; 1430 :             DEBUGCHK( !fUsingAddr0 );
; 1431 :             fUsingAddr0 = TRUE;
; 1432 :             //if (EnterCritSec_Ex( &m_csAddress0Lock, INFINITE ) != CSS_SUCCESS) {
; 1433 :             if (m_pDeviceGlobal->Addr0LockEntry(INFINITE )!= CSS_SUCCESS) {

  00238	e5993050	 ldr         r3, [r9, #0x50]
  0023c	e3a05001	 mov         r5, #1
  00240	e3e01000	 mvn         r1, #0
  00244	e283002c	 add         r0, r3, #0x2C
  00248	e58d506c	 str         r5, [sp, #0x6C]
  0024c	eb000000	 bl          |?EnterCritSec_Ex@CritSec_Ex@@QAA?AW4e_CritSec_Status@@K@Z|
  00250	e3500000	 cmp         r0, #0
  00254	0a000027	 beq         |$LN87@AttachDevi|

; 1434 :                 DEBUGMSG( ZONE_ATTACH, (TEXT("CHub(%s tier %d)::AttachDevice - shutdown signalled during enumeration\n"), GetDeviceType(), m_tierNumber) );
; 1435 :                 fUsingAddr0 = FALSE;
; 1436 :                 configStatus = DEVICE_CONFIG_STATUS_FAILED;
; 1437 :             } else

  00258	e3a05000	 mov         r5, #0
  0025c	e58d506c	 str         r5, [sp, #0x6C]
  00260	e3a0a013	 mov         r10, #0x13
  00264	eaffff8a	 b           |$LN171@AttachDevi|
  00268		 |$LN85@AttachDevi|

; 1441 :         }
; 1442 :         case DEVICE_CONFIG_STATUS_RESET_AND_ENABLE_PORT:
; 1443 :         {
; 1444 :             DEBUGCHK( fUsingAddr0 );
; 1445 :             if ( ResetAndEnablePort( port ) ) {

  00268	e5993000	 ldr         r3, [r9]
  0026c	e5dd1040	 ldrb        r1, [sp, #0x40]
  00270	e1a00009	 mov         r0, r9
  00274	e5933054	 ldr         r3, [r3, #0x54]
  00278	e1a0e00f	 mov         lr, pc
  0027c	e12fff13	 bx          r3
  00280	e3500000	 cmp         r0, #0

; 1446 :                 configStatus = DEVICE_CONFIG_STATUS_SCHEDULING_GET_DEVICE_DESCRIPTOR_TEST;
; 1447 :             } else {

  00284	13a0a003	 movne       r10, #3
  00288	1affff81	 bne         |$LN171@AttachDevi|
  0028c		 |$LN84@AttachDevi|

; 1448 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("CHub(%s tier %d)::AttachDevice - failure on %s step, unable to reset/enable port\n"), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1449 :                 configFailures++;

  0028c	e2873001	 add         r3, r7, #1
  00290	e20370ff	 and         r7, r3, #0xFF
  00294	e5cd7038	 strb        r7, [sp, #0x38]

; 1450 :             }
; 1451 :             break;

  00298	eaffff7d	 b           |$LN171@AttachDevi|
  0029c		 |$LN82@AttachDevi|

; 1452 :         }
; 1453 :         case DEVICE_CONFIG_STATUS_SCHEDULING_GET_DEVICE_DESCRIPTOR_TEST: {
; 1454 :             if ( GetDescriptor( pControlPipe,
; 1455 :                                 0,
; 1456 :                                 USB_DEVICE_DESCRIPTOR_TYPE,
; 1457 :                                 0, // descriptor index
; 1458 :                                 ENDPOINT_ZERO_MIN_MAXPACKET_SIZE,
; 1459 :                                 &deviceInfo.Descriptor ) ) {

  0029c	e3a0e008	 mov         lr, #8
  002a0	e28d304c	 add         r3, sp, #0x4C
  002a4	e58de004	 str         lr, [sp, #4]
  002a8	e3a0e000	 mov         lr, #0
  002ac	e58d3008	 str         r3, [sp, #8]
  002b0	e3a03001	 mov         r3, #1
  002b4	e3a02000	 mov         r2, #0
  002b8	e1a0100b	 mov         r1, r11
  002bc	e1a00009	 mov         r0, r9
  002c0	e58de000	 str         lr, [sp]
  002c4	eb000000	 bl          |?GetDescriptor@CHub@@IAAHQAVCPipeAbs@@EEEGPAX@Z|
  002c8	e3500000	 cmp         r0, #0

; 1460 :                 // success
; 1461 :                 configStatus = DEVICE_CONFIG_STATUS_SCHEDULING_SET_ADDRESS;
; 1462 :             } else {

  002cc	13a0a004	 movne       r10, #4
  002d0	1affff6f	 bne         |$LN171@AttachDevi|

; 1463 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("CHub(%s tier %d)::AttachDevice - failure on %s step\n"), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1464 :                 pControlPipe->IsPipeHalted( &fPipeHalted );

  002d4	e59b3000	 ldr         r3, [r11]
  002d8	e28d103c	 add         r1, sp, #0x3C
  002dc	e1a0000b	 mov         r0, r11
  002e0	e5933014	 ldr         r3, [r3, #0x14]
  002e4	e1a0e00f	 mov         lr, pc
  002e8	e12fff13	 bx          r3

; 1465 :                 configFailures++;

  002ec	e2873001	 add         r3, r7, #1
  002f0	e20370ff	 and         r7, r3, #0xFF
  002f4	e5cd7038	 strb        r7, [sp, #0x38]
  002f8		 |$LN87@AttachDevi|

; 1438 :                 // successfully acquired the Address0Lock
; 1439 :                 configStatus = DEVICE_CONFIG_STATUS_RESET_AND_ENABLE_PORT;
; 1440 :             break;

  002f8	e3a0a002	 mov         r10, #2
  002fc	eaffff64	 b           |$LN171@AttachDevi|
  00300		 |$LN79@AttachDevi|

; 1466 :                 configStatus = DEVICE_CONFIG_STATUS_RESET_AND_ENABLE_PORT;
; 1467 :             }
; 1468 :             break;
; 1469 :         }
; 1470 :         case DEVICE_CONFIG_STATUS_SCHEDULING_SET_ADDRESS:
; 1471 :         {
; 1472 :             DEBUGCHK( fUsingAddr0 &&
; 1473 :                       pControlPipe != NULL &&
; 1474 :                       address > 0 );
; 1475 :             BOOL                fTransferDone = FALSE;
; 1476 :             DWORD               dwBytesTransferred = 0;

  00300	e3a02000	 mov         r2, #0

; 1477 :             DWORD               dwErrorFlags = USB_NOT_COMPLETE_ERROR;
; 1478 :             HCD_REQUEST_STATUS  status = requestFailed;
; 1479 :             USB_DEVICE_REQUEST  usbRequest;
; 1480 : 
; 1481 :             usbRequest.bmRequestType = USB_REQUEST_HOST_TO_DEVICE | USB_REQUEST_STANDARD | USB_REQUEST_FOR_DEVICE;
; 1482 :             usbRequest.bRequest = USB_REQUEST_SET_ADDRESS;
; 1483 :             usbRequest.wValue = address; // new address
; 1484 :             usbRequest.wIndex = 0;
; 1485 :             usbRequest.wLength = 0;

  00304	e58d2074	 str         r2, [sp, #0x74]
  00308	e3a03000	 mov         r3, #0
  0030c	e3a02c01	 mov         r2, #1, 24
  00310	e58d307c	 str         r3, [sp, #0x7C]
  00314	e3823003	 orr         r3, r2, #3
  00318	e3a01000	 mov         r1, #0
  0031c	e3a00005	 mov         r0, #5
  00320	e3a0e000	 mov         lr, #0
  00324	e3a04000	 mov         r4, #0
  00328	e58d3070	 str         r3, [sp, #0x70]
  0032c	e5cd1090	 strb        r1, [sp, #0x90]
  00330	e5cd0091	 strb        r0, [sp, #0x91]
  00334	e1cde9b4	 strh        lr, [sp, #0x94]
  00338	e1cd49b6	 strh        r4, [sp, #0x96]
  0033c	e1cd89b2	 strh        r8, [sp, #0x92]

; 1486 :             // Note - at this point, the device is listening on address 0,
; 1487 :             // so we pass 0, not "address", to the IssueTransfer function
; 1488 :             if ( !m_fHubThreadClosing ) {

  00340	e3550000	 cmp         r5, #0
  00344	1a000046	 bne         |$LN74@AttachDevi|

; 1489 :                 status = pControlPipe->IssueTransfer(
; 1490 :                                         0, // device address (addr0)
; 1491 :                                         TransferDoneCallbackSetEvent, // callback func
; 1492 :                                         m_hHubStatusChangeEvent, // callback param
; 1493 :                                         USB_OUT_TRANSFER | USB_SEND_TO_DEVICE, // transfer params
; 1494 :                                         &usbRequest, // control request
; 1495 :                                         0, // dwStartingFrame (not used)
; 1496 :                                         0, // dwFrames (not used)
; 1497 :                                         NULL, // aLengths (not used)
; 1498 :                                         0, // buffer size
; 1499 :                                         NULL, // buffer
; 1500 :                                         0, // phys addr of buffer (not used)
; 1501 :                                         this, // cancel id
; 1502 :                                         NULL, // adwIsochErrors (not used)
; 1503 :                                         NULL, // adwIsochLengths (not used)
; 1504 :                                         &fTransferDone, // OUT status param
; 1505 :                                         &dwBytesTransferred, // OUT status param
; 1506 :                                         &dwErrorFlags ); // OUT status param

  00348	e28d4070	 add         r4, sp, #0x70
  0034c	e59b1000	 ldr         r1, [r11]
  00350	e58d4034	 str         r4, [sp, #0x34]
  00354	e3a04000	 mov         r4, #0
  00358	e58d4028	 str         r4, [sp, #0x28]
  0035c	e58d4024	 str         r4, [sp, #0x24]
  00360	e58d401c	 str         r4, [sp, #0x1C]
  00364	e58d4018	 str         r4, [sp, #0x18]
  00368	e58d4014	 str         r4, [sp, #0x14]
  0036c	e58d4010	 str         r4, [sp, #0x10]
  00370	e58d400c	 str         r4, [sp, #0xC]
  00374	e58d4008	 str         r4, [sp, #8]
  00378	e591800c	 ldr         r8, [r1, #0xC]
  0037c	e3a04a01	 mov         r4, #1, 20
  00380	e59930bc	 ldr         r3, [r9, #0xBC]
  00384	e59f2964	 ldr         r2, [pc, #0x964]
  00388	e28d5074	 add         r5, sp, #0x74
  0038c	e28d607c	 add         r6, sp, #0x7C
  00390	e28d7090	 add         r7, sp, #0x90
  00394	e58d4000	 str         r4, [sp]
  00398	e3a01000	 mov         r1, #0
  0039c	e1a0000b	 mov         r0, r11
  003a0	e58d5030	 str         r5, [sp, #0x30]
  003a4	e58d602c	 str         r6, [sp, #0x2C]
  003a8	e58d9020	 str         r9, [sp, #0x20]
  003ac	e58d7004	 str         r7, [sp, #4]
  003b0	e1a0e00f	 mov         lr, pc
  003b4	e12fff18	 bx          r8

; 1507 :                 if ( status == requestOK ) {

  003b8	e3500001	 cmp         r0, #1
  003bc	1a000025	 bne         |$LN166@AttachDevi|

; 1508 :                     DWORD dwResult = WaitForSingleObject( m_hHubStatusChangeEvent, STANDARD_REQUEST_TIMEOUT );

  003c0	e59900bc	 ldr         r0, [r9, #0xBC]
  003c4	e3a01ffa	 mov         r1, #0xFA, 30
  003c8	eb000000	 bl          WaitForSingleObject

; 1509 :                     if ( m_fHubThreadClosing || dwResult!= WAIT_OBJECT_0) {

  003cc	e59930b8	 ldr         r3, [r9, #0xB8]
  003d0	e3530000	 cmp         r3, #0
  003d4	1a000001	 bne         |$LN75@AttachDevi|
  003d8	e3500000	 cmp         r0, #0
  003dc	0a00000a	 beq         |$LN124@AttachDevi|
  003e0		 |$LN75@AttachDevi|

; 1510 :                         pControlPipe->AbortTransfer( NULL, // callback function
; 1511 :                                                      NULL, // callback parameter
; 1512 :                                                      this ); // cancel ID

  003e0	e59b1000	 ldr         r1, [r11]
  003e4	e1a03009	 mov         r3, r9
  003e8	e3a02000	 mov         r2, #0
  003ec	e5914010	 ldr         r4, [r1, #0x10]
  003f0	e3a01000	 mov         r1, #0
  003f4	e1a0000b	 mov         r0, r11
  003f8	e1a0e00f	 mov         lr, pc
  003fc	e12fff14	 bx          r4

; 1513 :                         ResetEvent(m_hHubStatusChangeEvent);

  00400	e59900bc	 ldr         r0, [r9, #0xBC]
  00404	e3a01002	 mov         r1, #2
  00408	eb000000	 bl          EventModify
  0040c		 |$LN124@AttachDevi|

; 1514 :                     }
; 1515 :                 }
; 1516 :                 DEBUGCHK( fTransferDone );
; 1517 :             }
; 1518 :             if ( status == requestOK &&
; 1519 :                  fTransferDone &&
; 1520 :                  dwBytesTransferred == 0 &&
; 1521 :                  dwErrorFlags == USB_NO_ERROR ) {

  0040c	e59d307c	 ldr         r3, [sp, #0x7C]
  00410	e3530000	 cmp         r3, #0
  00414	0a00000f	 beq         |$LN166@AttachDevi|
  00418	e59d3074	 ldr         r3, [sp, #0x74]
  0041c	e3530000	 cmp         r3, #0
  00420	1a00000c	 bne         |$LN166@AttachDevi|
  00424	e59d3070	 ldr         r3, [sp, #0x70]
  00428	e3530000	 cmp         r3, #0
  0042c	1a000009	 bne         |$LN166@AttachDevi|

; 1522 :                 configStatus = DEVICE_CONFIG_STATUS_LEAVE_ADDRESS0;
; 1523 :             } else {

  00430	e59d103c	 ldr         r1, [sp, #0x3C]
  00434	e59d2064	 ldr         r2, [sp, #0x64]
  00438	e59d0060	 ldr         r0, [sp, #0x60]
  0043c	e5dd405d	 ldrb        r4, [sp, #0x5D]
  00440	e3a0a005	 mov         r10, #5
  00444		 |$LN176@AttachDevi|
  00444	e5dde0a0	 ldrb        lr, [sp, #0xA0]
  00448		 |$LN168@AttachDevi|
  00448	e5dd7038	 ldrb        r7, [sp, #0x38]
  0044c	e59d6044	 ldr         r6, [sp, #0x44]
  00450	e5dd8039	 ldrb        r8, [sp, #0x39]
  00454	eaffff13	 b           |$LL98@AttachDevi|
  00458		 |$LN166@AttachDevi|

; 1883 :                 configStatus = DEVICE_CONFIG_STATUS_DONE;
; 1884 :             } else {
; 1885 :                 // don't do any retries here! EnterOperationalState
; 1886 :                 // should only be tried once
; 1887 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("CHub(%s tier %d)::AttachDevice - failure on %s step, aborting attach process\n"), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1888 :                 configStatus = DEVICE_CONFIG_STATUS_FAILED;
; 1889 :                 configFailures = 0xff;
; 1890 :             }
; 1891 :             break;

  00458	e5dd8039	 ldrb        r8, [sp, #0x39]
  0045c	e59d6044	 ldr         r6, [sp, #0x44]
  00460	e5dd7038	 ldrb        r7, [sp, #0x38]
  00464		 |$LN74@AttachDevi|
  00464	e59b3000	 ldr         r3, [r11]
  00468	e2872001	 add         r2, r7, #1
  0046c	e20270ff	 and         r7, r2, #0xFF
  00470	e5933014	 ldr         r3, [r3, #0x14]
  00474	e5cd7038	 strb        r7, [sp, #0x38]
  00478	e28d103c	 add         r1, sp, #0x3C
  0047c	e1a0000b	 mov         r0, r11
  00480	e1a0e00f	 mov         lr, pc
  00484	e12fff13	 bx          r3
  00488	e3a0a002	 mov         r10, #2
  0048c	eaffff00	 b           |$LN171@AttachDevi|
  00490		 |$LN72@AttachDevi|

; 1524 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("CHub(%s tier %d)::AttachDevice - failure on %s step, fTransferDone = %d, dwBytesTrans = 0x%x, dwErrorFlags = 0x%x\n"), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ), fTransferDone, dwBytesTransferred, dwErrorFlags ) );
; 1525 :                 configFailures++;
; 1526 :                 pControlPipe->IsPipeHalted( &fPipeHalted );
; 1527 :                 configStatus = DEVICE_CONFIG_STATUS_RESET_AND_ENABLE_PORT;
; 1528 :             }
; 1529 :             break;
; 1530 :         }
; 1531 :         case DEVICE_CONFIG_STATUS_LEAVE_ADDRESS0:
; 1532 :         {
; 1533 :             DEBUGCHK( fUsingAddr0 );
; 1534 :             // it can take some time for SetAddress to
; 1535 :             // take effect. In the OHCD code, there is a comment
; 1536 :             // that some devices (i.e. Andromeda hub) need a
; 1537 :             // delay here
; 1538 :             Sleep( 10 );

  00490	e3a0000a	 mov         r0, #0xA
  00494	eb000000	 bl          Sleep

; 1539 :             //LeaveCritSec_Ex( &m_csAddress0Lock );
; 1540 :             m_pDeviceGlobal->Addr0LockLeave();

  00498	e5993050	 ldr         r3, [r9, #0x50]
  0049c	e283002c	 add         r0, r3, #0x2C
  004a0	eb000000	 bl          |?LeaveCritSec_Ex@CritSec_Ex@@QAAXXZ|

; 1541 :             fUsingAddr0 = FALSE;
; 1542 :             configStatus = DEVICE_CONFIG_STATUS_SCHEDULING_GET_INITIAL_DEVICE_DESCRIPTOR;
; 1543 :             break;

  004a4	e3a05000	 mov         r5, #0
  004a8	e58d506c	 str         r5, [sp, #0x6C]
  004ac	e3a0a006	 mov         r10, #6
  004b0	eafffef7	 b           |$LN171@AttachDevi|
  004b4		 |$LN71@AttachDevi|

; 1544 :         }
; 1545 :         case DEVICE_CONFIG_STATUS_SCHEDULING_GET_INITIAL_DEVICE_DESCRIPTOR:
; 1546 :         {
; 1547 :             if ( GetDescriptor( pControlPipe,
; 1548 :                                 address,
; 1549 :                                 USB_DEVICE_DESCRIPTOR_TYPE,
; 1550 :                                 0, // descriptor index
; 1551 :                                 ENDPOINT_ZERO_MIN_MAXPACKET_SIZE,
; 1552 :                                 &deviceInfo.Descriptor ) ) {

  004b4	e3a0e008	 mov         lr, #8
  004b8	e28d304c	 add         r3, sp, #0x4C
  004bc	e58de004	 str         lr, [sp, #4]
  004c0	e3a0e000	 mov         lr, #0
  004c4	e58d3008	 str         r3, [sp, #8]
  004c8	e3a03001	 mov         r3, #1
  004cc	e1a02008	 mov         r2, r8
  004d0	e1a0100b	 mov         r1, r11
  004d4	e1a00009	 mov         r0, r9
  004d8	e58de000	 str         lr, [sp]
  004dc	eb000000	 bl          |?GetDescriptor@CHub@@IAAHQAVCPipeAbs@@EEEGPAX@Z|
  004e0	e3500000	 cmp         r0, #0
  004e4	0a000013	 beq         |$LN70@AttachDevi|

; 1553 : 
; 1554 :                 DEBUGCHK( m_tierNumber <= USB_MAXIMUM_HUB_TIER );
; 1555 :                 if ( m_tierNumber == USB_MAXIMUM_HUB_TIER &&
; 1556 :                      deviceInfo.Descriptor.bDeviceClass == USB_DEVICE_CLASS_HUB ) {

  004e8	e5d9304c	 ldrb        r3, [r9, #0x4C]
  004ec	e3530005	 cmp         r3, #5
  004f0	1a000007	 bne         |$LN69@AttachDevi|
  004f4	e5dd3050	 ldrb        r3, [sp, #0x50]
  004f8	e3530009	 cmp         r3, #9
  004fc	1a000004	 bne         |$LN69@AttachDevi|

; 1557 :                     RETAILMSG( 1, (TEXT("USB specification does not allow more than %d hubs in a row\n"), USB_MAXIMUM_HUB_TIER ));

  00500	e59f07f4	 ldr         r0, [pc, #0x7F4]
  00504	e3a01005	 mov         r1, #5
  00508	eb000000	 bl          NKDbgPrintfW
  0050c	e3a0a013	 mov         r10, #0x13
  00510	eafffedf	 b           |$LN171@AttachDevi|
  00514		 |$LN69@AttachDevi|

; 1558 :                     configStatus = DEVICE_CONFIG_STATUS_FAILED;
; 1559 :                 } else {
; 1560 :                     // success
; 1561 :                     if ( deviceInfo.Descriptor.bMaxPacketSize0 > ENDPOINT_ZERO_MIN_MAXPACKET_SIZE ) {

  00514	e5dd1053	 ldrb        r1, [sp, #0x53]
  00518	e3510008	 cmp         r1, #8

; 1562 :                         pControlPipe->ChangeMaxPacketSize( deviceInfo.Descriptor.bMaxPacketSize0 );

  0051c	859b3000	 ldrhi       r3, [r11]
  00520	81a0000b	 movhi       r0, r11
  00524	8593301c	 ldrhi       r3, [r3, #0x1C]
  00528	81a0e00f	 movhi       lr, pc
  0052c	812fff13	 bxhi        r3

; 1563 :                     }
; 1564 :                     configStatus = DEVICE_CONFIG_STATUS_SCHEDULING_GET_DEVICE_DESCRIPTOR;
; 1565 :                 }
; 1566 :             } else {

  00530	e3a0a007	 mov         r10, #7
  00534	eafffed6	 b           |$LN171@AttachDevi|
  00538		 |$LN70@AttachDevi|

; 1567 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("CHub(%s tier %d)::AttachDevice - failure on %s step\n"), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1568 :                 pControlPipe->IsPipeHalted( &fPipeHalted );

  00538	e59b3000	 ldr         r3, [r11]
  0053c	e28d103c	 add         r1, sp, #0x3C
  00540	e1a0000b	 mov         r0, r11
  00544	e5933014	 ldr         r3, [r3, #0x14]
  00548	e1a0e00f	 mov         lr, pc
  0054c	e12fff13	 bx          r3

; 1569 :                 configFailures++;
; 1570 :             }
; 1571 :             break;

  00550	eaffff4d	 b           |$LN84@AttachDevi|
  00554		 |$LN65@AttachDevi|

; 1572 :         }
; 1573 :         case DEVICE_CONFIG_STATUS_SCHEDULING_GET_DEVICE_DESCRIPTOR:
; 1574 :         {
; 1575 :             if ( GetDescriptor( pControlPipe,
; 1576 :                                 address,
; 1577 :                                 USB_DEVICE_DESCRIPTOR_TYPE,
; 1578 :                                 0, // descriptor index
; 1579 :                                 sizeof( deviceInfo.Descriptor ),
; 1580 :                                 &deviceInfo.Descriptor ) ) {

  00554	e28d304c	 add         r3, sp, #0x4C
  00558	e3a02012	 mov         r2, #0x12
  0055c	e58d3008	 str         r3, [sp, #8]
  00560	e58d2004	 str         r2, [sp, #4]
  00564	e3a0e000	 mov         lr, #0
  00568	e3a03001	 mov         r3, #1
  0056c	e1a02008	 mov         r2, r8
  00570	e1a0100b	 mov         r1, r11
  00574	e1a00009	 mov         r0, r9
  00578	e58de000	 str         lr, [sp]
  0057c	eb000000	 bl          |?GetDescriptor@CHub@@IAAHQAVCPipeAbs@@EEEGPAX@Z|
  00580	e3500000	 cmp         r0, #0

; 1581 :                 // success
; 1582 :                 configStatus = DEVICE_CONFIG_STATUS_SETUP_CONFIGURATION_DESCRIPTOR_ARRAY;
; 1583 :             #ifdef DEBUG
; 1584 :                 DumpDeviceDescriptor( &deviceInfo.Descriptor );
; 1585 :             #endif // DEBUG
; 1586 :             } else {

  00584	13a0a008	 movne       r10, #8
  00588	1afffec1	 bne         |$LN171@AttachDevi|

; 1587 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("CHub(%s tier %d)::AttachDevice - failure on %s step\n"), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1588 :                 pControlPipe->IsPipeHalted( &fPipeHalted );

  0058c	e59b3000	 ldr         r3, [r11]
  00590	e28d103c	 add         r1, sp, #0x3C
  00594	e1a0000b	 mov         r0, r11
  00598	e5933014	 ldr         r3, [r3, #0x14]
  0059c	e1a0e00f	 mov         lr, pc
  005a0	e12fff13	 bx          r3

; 1589 :                 configFailures++;
; 1590 :             }
; 1591 :             break;

  005a4	eaffff38	 b           |$LN84@AttachDevi|
  005a8		 |$LN62@AttachDevi|

; 1592 :         }
; 1593 :         case DEVICE_CONFIG_STATUS_SETUP_CONFIGURATION_DESCRIPTOR_ARRAY:
; 1594 :         {
; 1595 :             DEBUGCHK( deviceInfo.lpActiveConfig == NULL &&
; 1596 :                       deviceInfo.lpConfigs == NULL );
; 1597 : 
; 1598 :             const UINT numConfigurations = deviceInfo.Descriptor.bNumConfigurations;
; 1599 :             deviceInfo.lpConfigs = new NON_CONST_USB_CONFIGURATION[ numConfigurations ];

  005a8	e374037e	 cmn         r4, #0x7E, 6
  005ac	91a00284	 movls       r0, r4, lsl #5
  005b0	83e00000	 mvnhi       r0, #0
  005b4	eb000000	 bl          |??2@YAPAXI@Z|
  005b8	e3500000	 cmp         r0, #0
  005bc	e58d0060	 str         r0, [sp, #0x60]

; 1600 :             if ( deviceInfo.lpConfigs != NULL ) {

  005c0	0a00000f	 beq         |$LN61@AttachDevi|

; 1601 :                 memset( deviceInfo.lpConfigs, 0, numConfigurations * sizeof( NON_CONST_USB_CONFIGURATION ) );

  005c4	e1a02284	 mov         r2, r4, lsl #5
  005c8	e3a01000	 mov         r1, #0
  005cc	eb000000	 bl          memset

; 1602 :                 for ( UINT config = 0; config < numConfigurations ; config++ ) {

  005d0	e3540000	 cmp         r4, #0
  005d4	0a000006	 beq         |$LN58@AttachDevi|
  005d8	e3a02000	 mov         r2, #0
  005dc	e3a01020	 mov         r1, #0x20
  005e0		 |$LL60@AttachDevi|

; 1603 :                     deviceInfo.lpConfigs[ config ].dwCount = sizeof( NON_CONST_USB_CONFIGURATION );

  005e0	e59d3060	 ldr         r3, [sp, #0x60]
  005e4	e2544001	 subs        r4, r4, #1
  005e8	e7821003	 str         r1, [r2, +r3]
  005ec	e2822020	 add         r2, r2, #0x20
  005f0	1afffffa	 bne         |$LL60@AttachDevi|
  005f4		 |$LN58@AttachDevi|

; 1604 :                 }
; 1605 :                 currentConfigDescriptorIndex = 0;
; 1606 :                 configStatus = DEVICE_CONFIG_STATUS_SCHEDULING_GET_INITIAL_CONFIG_DESCRIPTOR;

  005f4	e3a03000	 mov         r3, #0
  005f8	e58d3078	 str         r3, [sp, #0x78]
  005fc	e3a0a009	 mov         r10, #9
  00600	eafffea3	 b           |$LN171@AttachDevi|
  00604		 |$LN61@AttachDevi|

; 1607 :             } else {
; 1608 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("CHub(%s tier %d)::AttachDevice - failure on %s step, no memory\n"), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1609 :                 configFailures++;

  00604	e2873001	 add         r3, r7, #1
  00608	e20370ff	 and         r7, r3, #0xFF
  0060c	e5cd7038	 strb        r7, [sp, #0x38]

; 1610 :             }
; 1611 :             break;

  00610	eafffea0	 b           |$LN173@AttachDevi|
  00614		 |$LN56@AttachDevi|

; 1612 :         }
; 1613 :         case DEVICE_CONFIG_STATUS_SCHEDULING_GET_INITIAL_CONFIG_DESCRIPTOR:
; 1614 :         {
; 1615 :             DEBUGCHK( currentConfigDescriptorIndex < deviceInfo.Descriptor.bNumConfigurations );
; 1616 :             DEBUGCHK( deviceInfo.lpActiveConfig == NULL &&
; 1617 :                       deviceInfo.lpConfigs != NULL );
; 1618 : 
; 1619 :             if ( GetDescriptor( pControlPipe,
; 1620 :                                 address,
; 1621 :                                 USB_CONFIGURATION_DESCRIPTOR_TYPE,
; 1622 :                                 currentConfigDescriptorIndex,
; 1623 :                                 sizeof( deviceInfo.lpConfigs[ currentConfigDescriptorIndex ].Descriptor ),
; 1624 :                                 &deviceInfo.lpConfigs[ currentConfigDescriptorIndex ].Descriptor ) ) {

  00614	e59d2078	 ldr         r2, [sp, #0x78]
  00618	e3a04009	 mov         r4, #9
  0061c	e1a0100b	 mov         r1, r11
  00620	e0803282	 add         r3, r0, r2, lsl #5
  00624	e2833004	 add         r3, r3, #4
  00628	e58d3008	 str         r3, [sp, #8]
  0062c	e202e0ff	 and         lr, r2, #0xFF
  00630	e3a03002	 mov         r3, #2
  00634	e1a02008	 mov         r2, r8
  00638	e1a00009	 mov         r0, r9
  0063c	e58d4004	 str         r4, [sp, #4]
  00640	e58de000	 str         lr, [sp]
  00644	eb000000	 bl          |?GetDescriptor@CHub@@IAAHQAVCPipeAbs@@EEEGPAX@Z|
  00648	e3500000	 cmp         r0, #0

; 1625 :                 // success
; 1626 :                 configStatus = DEVICE_CONFIG_STATUS_SCHEDULING_GET_CONFIG_DESCRIPTOR;
; 1627 :             } else {

  0064c	13a0a00a	 movne       r10, #0xA
  00650	1afffe8f	 bne         |$LN171@AttachDevi|

; 1628 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("CHub(%s tier %d)::AttachDevice - failure on %s step\n"), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1629 :                 pControlPipe->IsPipeHalted( &fPipeHalted );

  00654	e59b3000	 ldr         r3, [r11]
  00658	e28d103c	 add         r1, sp, #0x3C
  0065c	e1a0000b	 mov         r0, r11
  00660	e5933014	 ldr         r3, [r3, #0x14]
  00664	e1a0e00f	 mov         lr, pc
  00668	e12fff13	 bx          r3

; 1630 :                 configFailures++;
; 1631 :             }
; 1632 :             break;

  0066c	eaffff06	 b           |$LN84@AttachDevi|
  00670		 |$LN53@AttachDevi|

; 1633 :         }
; 1634 :         case DEVICE_CONFIG_STATUS_SCHEDULING_GET_CONFIG_DESCRIPTOR:
; 1635 :         {
; 1636 :             DEBUGCHK( currentConfigDescriptorIndex < deviceInfo.Descriptor.bNumConfigurations );
; 1637 :             DEBUGCHK( deviceInfo.lpActiveConfig == NULL &&
; 1638 :                       deviceInfo.lpConfigs != NULL &&
; 1639 :                       deviceInfo.lpConfigs[ currentConfigDescriptorIndex ].Descriptor.bDescriptorType == USB_CONFIGURATION_DESCRIPTOR_TYPE &&
; 1640 :                       deviceInfo.lpConfigs[ currentConfigDescriptorIndex ].Descriptor.bLength == sizeof( USB_CONFIGURATION_DESCRIPTOR ) &&
; 1641 :                       deviceInfo.lpConfigs[ currentConfigDescriptorIndex ].lpbExtended == NULL &&
; 1642 :                       deviceInfo.lpConfigs[ currentConfigDescriptorIndex ].lpInterfaces == NULL );
; 1643 : 
; 1644 :             const USHORT wTotalLength = deviceInfo.lpConfigs[ currentConfigDescriptorIndex ].Descriptor.wTotalLength;

  00670	e59d6078	 ldr         r6, [sp, #0x78]
  00674	e0803286	 add         r3, r0, r6, lsl #5
  00678	e5d32006	 ldrb        r2, [r3, #6]
  0067c	e5d33007	 ldrb        r3, [r3, #7]
  00680	e1825403	 orr         r5, r2, r3, lsl #8

; 1645 :             PUCHAR pDataBuffer = new UCHAR[ wTotalLength ];

  00684	e1a00005	 mov         r0, r5
  00688	eb000000	 bl          |??2@YAPAXI@Z|
  0068c	e1b04000	 movs        r4, r0

; 1646 :             if ( pDataBuffer != NULL &&
; 1647 :                  GetDescriptor( pControlPipe,
; 1648 :                                 address,
; 1649 :                                 USB_CONFIGURATION_DESCRIPTOR_TYPE,
; 1650 :                                 currentConfigDescriptorIndex,
; 1651 :                                 wTotalLength,
; 1652 :                                 pDataBuffer ) &&
; 1653 :                  memcmp( &deviceInfo.lpConfigs[ currentConfigDescriptorIndex ].Descriptor, pDataBuffer, sizeof( USB_CONFIGURATION_DESCRIPTOR ) ) == 0 &&
; 1654 :                  CreateUsbConfigurationStructure( deviceInfo.lpConfigs[ currentConfigDescriptorIndex ], pDataBuffer, wTotalLength ) ) {

  00690	0a000022	 beq         |$LN52@AttachDevi|
  00694	e20620ff	 and         r2, r6, #0xFF
  00698	e58d2000	 str         r2, [sp]
  0069c	e1a02008	 mov         r2, r8
  006a0	e3a03002	 mov         r3, #2
  006a4	e1a0100b	 mov         r1, r11
  006a8	e1a00009	 mov         r0, r9
  006ac	e58d4008	 str         r4, [sp, #8]
  006b0	e58d5004	 str         r5, [sp, #4]
  006b4	eb000000	 bl          |?GetDescriptor@CHub@@IAAHQAVCPipeAbs@@EEEGPAX@Z|
  006b8	e3500000	 cmp         r0, #0
  006bc	0a000017	 beq         |$LN52@AttachDevi|
  006c0	e59de060	 ldr         lr, [sp, #0x60]
  006c4	e3a02009	 mov         r2, #9
  006c8	e1a01004	 mov         r1, r4
  006cc	e08e6286	 add         r6, lr, r6, lsl #5
  006d0	e2860004	 add         r0, r6, #4
  006d4	eb000000	 bl          memcmp
  006d8	e3500000	 cmp         r0, #0
  006dc	1a00000f	 bne         |$LN52@AttachDevi|
  006e0	e1a03005	 mov         r3, r5
  006e4	e1a02004	 mov         r2, r4
  006e8	e1a01006	 mov         r1, r6
  006ec	e1a00009	 mov         r0, r9
  006f0	eb000000	 bl          |?CreateUsbConfigurationStructure@CDevice@@QBAHAAU_NON_CONST_USB_CONFIGURATION@@QAEI@Z|
  006f4	e3500000	 cmp         r0, #0
  006f8	0a000008	 beq         |$LN52@AttachDevi|

; 1655 :                 // success
; 1656 :                 currentConfigDescriptorIndex++;
; 1657 :                 if ( currentConfigDescriptorIndex < deviceInfo.Descriptor.bNumConfigurations ) {

  006fc	e59d6078	 ldr         r6, [sp, #0x78]
  00700	e5dd305d	 ldrb        r3, [sp, #0x5D]
  00704	e2866001	 add         r6, r6, #1
  00708	e1560003	 cmp         r6, r3

; 1658 :                     // need to get more descriptors
; 1659 :                     configStatus = DEVICE_CONFIG_STATUS_SCHEDULING_GET_INITIAL_CONFIG_DESCRIPTOR;

  0070c	33a0a009	 movcc       r10, #9
  00710	e58d6078	 str         r6, [sp, #0x78]
  00714	3a00000a	 bcc         |$LN49@AttachDevi|

; 1660 :                 } else {
; 1661 :                     // done getting config descriptors
; 1662 :                     configStatus = DEVICE_CONFIG_STATUS_DETERMINE_CONFIG_TO_CHOOSE;

  00718	e3a0a00b	 mov         r10, #0xB

; 1663 :                 }
; 1664 :             } else {

  0071c	ea000008	 b           |$LN49@AttachDevi|
  00720		 |$LN52@AttachDevi|

; 1665 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("CHub(%s tier %d)::AttachDevice - failure on %s step\n"), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1666 :                 pControlPipe->IsPipeHalted( &fPipeHalted );

  00720	e59b3000	 ldr         r3, [r11]
  00724	e28d103c	 add         r1, sp, #0x3C
  00728	e1a0000b	 mov         r0, r11
  0072c	e5933014	 ldr         r3, [r3, #0x14]
  00730	e1a0e00f	 mov         lr, pc
  00734	e12fff13	 bx          r3

; 1667 :                 configFailures++;

  00738	e2873001	 add         r3, r7, #1
  0073c	e20370ff	 and         r7, r3, #0xFF
  00740	e5cd7038	 strb        r7, [sp, #0x38]
  00744		 |$LN49@AttachDevi|

; 1668 :             }
; 1669 :             delete [] pDataBuffer;

  00744	e1a00004	 mov         r0, r4
  00748	eb000000	 bl          |??3@YAXPAX@Z|

; 1670 :             pDataBuffer = NULL;
; 1671 :             break;

  0074c	ea00015a	 b           |$LN174@AttachDevi|
  00750		 |$LN48@AttachDevi|

; 1672 :         }
; 1673 :         case DEVICE_CONFIG_STATUS_DETERMINE_CONFIG_TO_CHOOSE:
; 1674 :         {
; 1675 :             // We're not terribly smart about picking a config when the first one won't work. C'est la vie.
; 1676 :             // Also, we cannot check the device's actual power status until after it's configured.
; 1677 :             
; 1678 :             BYTE bConfig = 0;
; 1679 :             if ( m_pCHcd->GetpUSBDSelectConfigurationProc()!=NULL  // This function is supported by USBD.
; 1680 :                     && deviceInfo.Descriptor.bNumConfigurations > 1 ) {

  00750	e59930c8	 ldr         r3, [r9, #0xC8]
  00754	e3a02000	 mov         r2, #0
  00758	e5cd2041	 strb        r2, [sp, #0x41]
  0075c	e5933078	 ldr         r3, [r3, #0x78]
  00760	e3530000	 cmp         r3, #0
  00764	0a000010	 beq         |$LN46@AttachDevi|
  00768	e3540001	 cmp         r4, #1
  0076c	9a00000e	 bls         |$LN46@AttachDevi|

; 1681 :                 if (!(*m_pCHcd->GetpUSBDSelectConfigurationProc())(LPCUSB_DEVICE(&deviceInfo),&bConfig) || 
; 1682 :                         bConfig >= deviceInfo.Descriptor.bNumConfigurations ) { // if can not find anything return to 0.

  00770	e28d1041	 add         r1, sp, #0x41
  00774	e28d0048	 add         r0, sp, #0x48
  00778	e1a0e00f	 mov         lr, pc
  0077c	e12fff13	 bx          r3
  00780	e5dd405d	 ldrb        r4, [sp, #0x5D]
  00784	e3500000	 cmp         r0, #0
  00788	0a000002	 beq         |$LN45@AttachDevi|
  0078c	e5dd2041	 ldrb        r2, [sp, #0x41]
  00790	e1520004	 cmp         r2, r4

; 1683 :                     bConfig = 0;

  00794	3a000001	 bcc         |$LN175@AttachDevi|
  00798		 |$LN45@AttachDevi|
  00798	e3a02000	 mov         r2, #0
  0079c	e5cd2041	 strb        r2, [sp, #0x41]
  007a0		 |$LN175@AttachDevi|
  007a0	e5dde0a0	 ldrb        lr, [sp, #0xA0]
  007a4	e59d0060	 ldr         r0, [sp, #0x60]
  007a8	e59d103c	 ldr         r1, [sp, #0x3C]
  007ac		 |$LN46@AttachDevi|

; 1684 :                 }
; 1685 :             }
; 1686 :             DEBUGMSG( ZONE_ATTACH, (TEXT("CHub(%s tier %d)::AttachDevice - Select Configuration %d on %s step\n"), GetDeviceType(), m_tierNumber,bConfig,STATUS_TO_STRING( configStatus ) ) );
; 1687 :             if (deviceInfo.lpConfigs[bConfig].Descriptor.bmAttributes & SELF_POWERED) {

  007ac	e0805282	 add         r5, r0, r2, lsl #5
  007b0	e5d5300b	 ldrb        r3, [r5, #0xB]
  007b4	e3130040	 tst         r3, #0x40
  007b8	1a000026	 bne         |$LN152@AttachDevi|

; 1688 :                 // the device we're attaching is self-powered so power is of little concern
; 1689 :             } else {
; 1690 :                 DWORD dwCfgPower = deviceInfo.lpConfigs[bConfig].Descriptor.MaxPower * 2; // MaxPower is in units of 2mA

  007bc	e5d5300c	 ldrb        r3, [r5, #0xC]
  007c0	e3530000	 cmp         r3, #0
  007c4	e1a05083	 mov         r5, r3, lsl #1

; 1691 :                 if (deviceInfo.lpConfigs[bConfig].Descriptor.MaxPower == 0) {

  007c8	1a000007	 bne         |$LN42@AttachDevi|

; 1692 :                     RETAILMSG(1, (TEXT("!CHub::AttachDevice warning: invalid power configuration\n")));

  007cc	e59f0524	 ldr         r0, [pc, #0x524]
  007d0	eb000000	 bl          NKDbgPrintfW

; 1693 :                     dwCfgPower = 500; // If MaxPower is illigal, assume the maximum power is required.

  007d4	e5dde0a0	 ldrb        lr, [sp, #0xA0]
  007d8	e59d103c	 ldr         r1, [sp, #0x3C]
  007dc	e59d0060	 ldr         r0, [sp, #0x60]
  007e0	e5dd405d	 ldrb        r4, [sp, #0x5D]
  007e4	e5dd2041	 ldrb        r2, [sp, #0x41]
  007e8	e3a05f7d	 mov         r5, #0x7D, 30
  007ec		 |$LN42@AttachDevi|

; 1694 :                 }
; 1695 :                 {
; 1696 :                     BOOL isOK;
; 1697 :                     if (m_deviceInfo.lpConfigs == NULL) {

  007ec	e599303c	 ldr         r3, [r9, #0x3C]
  007f0	e3530000	 cmp         r3, #0
  007f4	1a00000a	 bne         |$LN41@AttachDevi|

; 1698 :                         // we must be a root hub; check with the PDD
; 1699 :                         isOK = HcdPdd_CheckConfigPower(port, dwCfgPower, 0);

  007f8	e5dd0040	 ldrb        r0, [sp, #0x40]
  007fc	e3a02000	 mov         r2, #0
  00800	e1a01005	 mov         r1, r5
  00804	eb000000	 bl          HcdPdd_CheckConfigPower
  00808	e59d103c	 ldr         r1, [sp, #0x3C]
  0080c	e5dd405d	 ldrb        r4, [sp, #0x5D]
  00810	e5dd2041	 ldrb        r2, [sp, #0x41]
  00814	e5dde0a0	 ldrb        lr, [sp, #0xA0]
  00818	e1a03000	 mov         r3, r0
  0081c	e59d0060	 ldr         r0, [sp, #0x60]
  00820	ea000006	 b           |$LN36@AttachDevi|
  00824		 |$LN41@AttachDevi|

; 1700 :                     } else if (m_deviceInfo.lpActiveConfig->Descriptor.bmAttributes & SELF_POWERED) {

  00824	e5993040	 ldr         r3, [r9, #0x40]
  00828	e5d3300b	 ldrb        r3, [r3, #0xB]
  0082c	e3130040	 tst         r3, #0x40

; 1701 :                         // we're self-powered so we can attach a high-powered device
; 1702 :                         isOK = TRUE;

  00830	1a000008	 bne         |$LN152@AttachDevi|

; 1703 :                     } else if (dwCfgPower <= 100) {

  00834	e3550064	 cmp         r5, #0x64

; 1704 :                         // we're bus-powered so we can only attach low-powered devices
; 1705 :                         isOK = TRUE;
; 1706 :                     } else {

  00838	9a000006	 bls         |$LN152@AttachDevi|

; 1707 :                         isOK = FALSE;

  0083c	e3a03000	 mov         r3, #0
  00840		 |$LN36@AttachDevi|

; 1708 :                     }
; 1709 :                     if ( ! isOK ) {

  00840	e3530000	 cmp         r3, #0
  00844	1a000003	 bne         |$LN152@AttachDevi|

; 1710 :                         RETAILMSG(1, (TEXT("!USB warning: cannot attach high-power device to a bus-powered hub\n")));

  00848	e59f04a4	 ldr         r0, [pc, #0x4A4]
  0084c	eb000000	 bl          NKDbgPrintfW
  00850	e3a0a013	 mov         r10, #0x13
  00854	eafffe0e	 b           |$LN171@AttachDevi|
  00858		 |$LN152@AttachDevi|

; 1711 :                         configStatus = DEVICE_CONFIG_STATUS_FAILED;
; 1712 :                     }
; 1713 :                 }
; 1714 :             }
; 1715 :             if (configStatus != DEVICE_CONFIG_STATUS_FAILED) {
; 1716 :                 DEBUGCHK( deviceInfo.lpActiveConfig == NULL && deviceInfo.lpConfigs != NULL );
; 1717 : 
; 1718 :                 deviceInfo.lpActiveConfig = &deviceInfo.lpConfigs[bConfig];

  00858	e0802282	 add         r2, r0, r2, lsl #5
  0085c	e58d2064	 str         r2, [sp, #0x64]

; 1719 :                 DEBUGCHK( deviceInfo.lpActiveConfig->lpInterfaces != NULL );
; 1720 : 
; 1721 :                 configStatus = DEVICE_CONFIG_STATUS_SCHEDULING_SET_CONFIG;

  00860	e3a0a00c	 mov         r10, #0xC

; 1722 :             }
; 1723 :             break;

  00864	eafffe0f	 b           |$LL98@AttachDevi|
  00868		 |$LN33@AttachDevi|

; 1724 :         }
; 1725 :         case DEVICE_CONFIG_STATUS_SCHEDULING_SET_CONFIG:
; 1726 :         {
; 1727 :             DEBUGCHK( deviceInfo.lpActiveConfig != NULL );
; 1728 : 
; 1729 :             BOOL                fTransferDone = FALSE;
; 1730 :             DWORD               dwBytesTransferred = 0;

  00868	e3a01000	 mov         r1, #0

; 1731 :             DWORD               dwErrorFlags = USB_NOT_COMPLETE_ERROR;
; 1732 :             HCD_REQUEST_STATUS  status = requestFailed;
; 1733 :             USB_DEVICE_REQUEST  usbRequest;
; 1734 : 
; 1735 :             usbRequest.bmRequestType = USB_REQUEST_HOST_TO_DEVICE | USB_REQUEST_STANDARD | USB_REQUEST_FOR_DEVICE;
; 1736 :             usbRequest.bRequest = USB_REQUEST_SET_CONFIGURATION;

  0086c	e58d1074	 str         r1, [sp, #0x74]
  00870	e3a03000	 mov         r3, #0
  00874	e3a01c01	 mov         r1, #1, 24
  00878	e58d3070	 str         r3, [sp, #0x70]
  0087c	e3813003	 orr         r3, r1, #3
  00880	e3a00000	 mov         r0, #0
  00884	e3a0e009	 mov         lr, #9
  00888	e58d307c	 str         r3, [sp, #0x7C]
  0088c	e5cd0098	 strb        r0, [sp, #0x98]
  00890	e5cde099	 strb        lr, [sp, #0x99]

; 1737 :             usbRequest.wValue = deviceInfo.lpActiveConfig->Descriptor.bConfigurationValue;

  00894	e5d23009	 ldrb        r3, [r2, #9]

; 1738 :             usbRequest.wIndex = 0;

  00898	e3a02000	 mov         r2, #0

; 1739 :             usbRequest.wLength = 0;

  0089c	e3a01000	 mov         r1, #0
  008a0	e1cd39ba	 strh        r3, [sp, #0x9A]
  008a4	e1cd29bc	 strh        r2, [sp, #0x9C]
  008a8	e1cd19be	 strh        r1, [sp, #0x9E]

; 1740 :             if ( !m_fHubThreadClosing ) {

  008ac	e3550000	 cmp         r5, #0
  008b0	1a000048	 bne         |$LN28@AttachDevi|

; 1741 :                 status = pControlPipe->IssueTransfer(
; 1742 :                                             address, // device rAddress
; 1743 :                                             TransferDoneCallbackSetEvent, // callback
; 1744 :                                             m_hHubStatusChangeEvent, // param for callback
; 1745 :                                             USB_OUT_TRANSFER | USB_SEND_TO_DEVICE, // transfer flags
; 1746 :                                             &usbRequest, // control request
; 1747 :                                             0, // dwStartingFrame (not used)
; 1748 :                                             0, // dwFrames (not used)
; 1749 :                                             NULL, // aLengths (not used)
; 1750 :                                             0, // buffer size
; 1751 :                                             NULL, // data buffer
; 1752 :                                             0, // phys addr of buffer (not used)
; 1753 :                                             this, // cancel ID
; 1754 :                                             NULL, // adwIsochErrors (not used)
; 1755 :                                             NULL, // adwIsochLengths (not used)
; 1756 :                                             &fTransferDone, // OUT status param
; 1757 :                                             &dwBytesTransferred, // OUT status param
; 1758 :                                             &dwErrorFlags ); // OUT status param

  008b4	e28d407c	 add         r4, sp, #0x7C
  008b8	e59b1000	 ldr         r1, [r11]
  008bc	e58d4034	 str         r4, [sp, #0x34]
  008c0	e3a04000	 mov         r4, #0
  008c4	e58d4028	 str         r4, [sp, #0x28]
  008c8	e58d4024	 str         r4, [sp, #0x24]
  008cc	e58d401c	 str         r4, [sp, #0x1C]
  008d0	e58d4018	 str         r4, [sp, #0x18]
  008d4	e58d4014	 str         r4, [sp, #0x14]
  008d8	e58d4010	 str         r4, [sp, #0x10]
  008dc	e58d400c	 str         r4, [sp, #0xC]
  008e0	e58d4008	 str         r4, [sp, #8]
  008e4	e591800c	 ldr         r8, [r1, #0xC]
  008e8	e3a04a01	 mov         r4, #1, 20
  008ec	e59930bc	 ldr         r3, [r9, #0xBC]
  008f0	e59f23f8	 ldr         r2, [pc, #0x3F8]
  008f4	e28d5074	 add         r5, sp, #0x74
  008f8	e28d6070	 add         r6, sp, #0x70
  008fc	e28d7098	 add         r7, sp, #0x98
  00900	e5dd1039	 ldrb        r1, [sp, #0x39]
  00904	e58d4000	 str         r4, [sp]
  00908	e1a0000b	 mov         r0, r11
  0090c	e58d5030	 str         r5, [sp, #0x30]
  00910	e58d602c	 str         r6, [sp, #0x2C]
  00914	e58d9020	 str         r9, [sp, #0x20]
  00918	e58d7004	 str         r7, [sp, #4]
  0091c	e1a0e00f	 mov         lr, pc
  00920	e12fff18	 bx          r8

; 1759 :                 if ( status == requestOK ) {

  00924	e3500001	 cmp         r0, #1
  00928	1a000027	 bne         |$LN162@AttachDevi|

; 1760 :                     DWORD dwResult = WaitForSingleObject( m_hHubStatusChangeEvent, STANDARD_REQUEST_TIMEOUT );

  0092c	e59900bc	 ldr         r0, [r9, #0xBC]
  00930	e3a01ffa	 mov         r1, #0xFA, 30
  00934	eb000000	 bl          WaitForSingleObject

; 1761 :                     if ( m_fHubThreadClosing || dwResult!= WAIT_OBJECT_0 ) {

  00938	e59930b8	 ldr         r3, [r9, #0xB8]
  0093c	e3530000	 cmp         r3, #0
  00940	1a000001	 bne         |$LN29@AttachDevi|
  00944	e3500000	 cmp         r0, #0
  00948	0a00000a	 beq         |$LN132@AttachDevi|
  0094c		 |$LN29@AttachDevi|

; 1762 :                         pControlPipe->AbortTransfer( NULL, // callback function
; 1763 :                                                      NULL, // callback parameter
; 1764 :                                                      this ); // cancel ID

  0094c	e59b1000	 ldr         r1, [r11]
  00950	e1a03009	 mov         r3, r9
  00954	e3a02000	 mov         r2, #0
  00958	e5914010	 ldr         r4, [r1, #0x10]
  0095c	e3a01000	 mov         r1, #0
  00960	e1a0000b	 mov         r0, r11
  00964	e1a0e00f	 mov         lr, pc
  00968	e12fff14	 bx          r4

; 1765 :                         ResetEvent(m_hHubStatusChangeEvent);                        

  0096c	e59900bc	 ldr         r0, [r9, #0xBC]
  00970	e3a01002	 mov         r1, #2
  00974	eb000000	 bl          EventModify
  00978		 |$LN132@AttachDevi|

; 1766 :                     }
; 1767 :                 }
; 1768 :                 DEBUGCHK( fTransferDone );
; 1769 :             }
; 1770 :             if ( status == requestOK &&
; 1771 :                  fTransferDone &&
; 1772 :                  dwBytesTransferred == 0 &&
; 1773 :                  dwErrorFlags == USB_NO_ERROR ) {

  00978	e59d3070	 ldr         r3, [sp, #0x70]
  0097c	e3530000	 cmp         r3, #0
  00980	0a000011	 beq         |$LN162@AttachDevi|
  00984	e59d3074	 ldr         r3, [sp, #0x74]
  00988	e3530000	 cmp         r3, #0
  0098c	1a00000e	 bne         |$LN162@AttachDevi|
  00990	e59d307c	 ldr         r3, [sp, #0x7C]
  00994	e3530000	 cmp         r3, #0
  00998	1a00000b	 bne         |$LN162@AttachDevi|

; 1774 :                 // move to next step
; 1775 :                 if ( deviceInfo.Descriptor.bDeviceClass == USB_DEVICE_CLASS_HUB ) {

  0099c	e5dd3050	 ldrb        r3, [sp, #0x50]

; 1776 :                     // more steps need to happen for hubs
; 1777 :                     usbHubDescriptor.bDescriptorLength = USB_HUB_DESCRIPTOR_MINIMUM_SIZE;
; 1778 :                     configStatus = DEVICE_CONFIG_STATUS_SCHEDULING_GET_INITIAL_HUB_DESCRIPTOR;
; 1779 :                 } else {

  009a0	e59d103c	 ldr         r1, [sp, #0x3C]
  009a4	e59d2064	 ldr         r2, [sp, #0x64]
  009a8	e3530009	 cmp         r3, #9
  009ac	03a0e009	 moveq       lr, #9
  009b0	e59d0060	 ldr         r0, [sp, #0x60]
  009b4	e5dd405d	 ldrb        r4, [sp, #0x5D]
  009b8	05cde0a0	 streqb      lr, [sp, #0xA0]
  009bc	03a0a00d	 moveq       r10, #0xD
  009c0	0afffea0	 beq         |$LN168@AttachDevi|

; 1780 :                     configStatus = DEVICE_CONFIG_STATUS_CREATE_NEW_FUNCTION;
; 1781 :                 }
; 1782 :             } else {

  009c4	e3a0a010	 mov         r10, #0x10
  009c8	eafffe9d	 b           |$LN176@AttachDevi|
  009cc		 |$LN162@AttachDevi|

; 1883 :                 configStatus = DEVICE_CONFIG_STATUS_DONE;
; 1884 :             } else {
; 1885 :                 // don't do any retries here! EnterOperationalState
; 1886 :                 // should only be tried once
; 1887 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("CHub(%s tier %d)::AttachDevice - failure on %s step, aborting attach process\n"), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1888 :                 configStatus = DEVICE_CONFIG_STATUS_FAILED;
; 1889 :                 configFailures = 0xff;
; 1890 :             }
; 1891 :             break;

  009cc	e5dd8039	 ldrb        r8, [sp, #0x39]
  009d0	e59d6044	 ldr         r6, [sp, #0x44]
  009d4	e5dd7038	 ldrb        r7, [sp, #0x38]
  009d8		 |$LN28@AttachDevi|
  009d8	e59b3000	 ldr         r3, [r11]
  009dc	e28d103c	 add         r1, sp, #0x3C
  009e0	e1a0000b	 mov         r0, r11
  009e4	e5933014	 ldr         r3, [r3, #0x14]
  009e8	e1a0e00f	 mov         lr, pc
  009ec	e12fff13	 bx          r3
  009f0	eafffe25	 b           |$LN84@AttachDevi|
  009f4		 |$LN24@AttachDevi|

; 1783 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("CHub(%s tier %d)::AttachDevice - failure on %s step, fTransferDone = %d, dwBytesTrans = 0x%x, dwErrorFlags = 0x%x\n"), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ), fTransferDone, dwBytesTransferred, dwErrorFlags ) );
; 1784 :                 pControlPipe->IsPipeHalted( &fPipeHalted );
; 1785 :                 configFailures++;
; 1786 :             }
; 1787 :             break;
; 1788 :         }
; 1789 :         case DEVICE_CONFIG_STATUS_SCHEDULING_GET_INITIAL_HUB_DESCRIPTOR:
; 1790 :         case DEVICE_CONFIG_STATUS_SCHEDULING_GET_HUB_DESCRIPTOR:
; 1791 :         {
; 1792 :             DEBUGCHK( deviceInfo.Descriptor.bDeviceClass == USB_DEVICE_CLASS_HUB );
; 1793 :             DEBUGCHK( (configStatus == DEVICE_CONFIG_STATUS_SCHEDULING_GET_INITIAL_HUB_DESCRIPTOR &&
; 1794 :                        usbHubDescriptor.bDescriptorLength == USB_HUB_DESCRIPTOR_MINIMUM_SIZE) ||
; 1795 :                       (configStatus == DEVICE_CONFIG_STATUS_SCHEDULING_GET_HUB_DESCRIPTOR &&
; 1796 :                        usbHubDescriptor.bDescriptorLength > USB_HUB_DESCRIPTOR_MINIMUM_SIZE &&
; 1797 :                        usbHubDescriptor.bDescriptorLength <= sizeof( usbHubDescriptor ) ) );
; 1798 :             const UCHAR descriptorLengthToGet = usbHubDescriptor.bDescriptorLength;
; 1799 :             if ( GetDescriptor( pControlPipe,
; 1800 :                                 address,
; 1801 :                                 USB_HUB_DESCRIPTOR_TYPE,
; 1802 :                                 0, // hub descriptor index is 0
; 1803 :                                 descriptorLengthToGet,
; 1804 :                                 &usbHubDescriptor ) ) {

  009f4	e28d30a0	 add         r3, sp, #0xA0
  009f8	e1a0500e	 mov         r5, lr
  009fc	e58de004	 str         lr, [sp, #4]
  00a00	e58d3008	 str         r3, [sp, #8]
  00a04	e3a0e000	 mov         lr, #0
  00a08	e3a03029	 mov         r3, #0x29
  00a0c	e1a02008	 mov         r2, r8
  00a10	e1a0100b	 mov         r1, r11
  00a14	e1a00009	 mov         r0, r9
  00a18	e58de000	 str         lr, [sp]
  00a1c	eb000000	 bl          |?GetDescriptor@CHub@@IAAHQAVCPipeAbs@@EEEGPAX@Z|
  00a20	e3500000	 cmp         r0, #0
  00a24	0a000009	 beq         |$LN23@AttachDevi|

; 1805 :                 // success
; 1806 :                 if ( usbHubDescriptor.bDescriptorLength > descriptorLengthToGet ) {

  00a28	e5dde0a0	 ldrb        lr, [sp, #0xA0]

; 1807 :                     DEBUGCHK( configStatus == DEVICE_CONFIG_STATUS_SCHEDULING_GET_INITIAL_HUB_DESCRIPTOR );
; 1808 :                     configStatus = DEVICE_CONFIG_STATUS_SCHEDULING_GET_HUB_DESCRIPTOR;
; 1809 :                 } else {

  00a2c	e59d103c	 ldr         r1, [sp, #0x3C]
  00a30	e59d2064	 ldr         r2, [sp, #0x64]
  00a34	e15e0005	 cmp         lr, r5
  00a38	e59d0060	 ldr         r0, [sp, #0x60]
  00a3c	e5dd405d	 ldrb        r4, [sp, #0x5D]
  00a40	83a0a00e	 movhi       r10, #0xE
  00a44	8afffd97	 bhi         |$LL98@AttachDevi|

; 1810 :                     DEBUGCHK( usbHubDescriptor.bDescriptorLength == descriptorLengthToGet );
; 1811 :                 #ifdef DEBUG
; 1812 :                     DumpHubDescriptor( &usbHubDescriptor );
; 1813 :                 #endif // DEBUG
; 1814 :                     configStatus = DEVICE_CONFIG_STATUS_CREATE_NEW_HUB;
; 1815 :                 }
; 1816 :             } else {

  00a48	e3a0a00f	 mov         r10, #0xF
  00a4c	eafffd95	 b           |$LL98@AttachDevi|
  00a50		 |$LN23@AttachDevi|

; 1817 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("CHub(%s tier %d)::AttachDevice - failure on %s step\n"), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1818 :                 pControlPipe->IsPipeHalted( &fPipeHalted );

  00a50	e59b3000	 ldr         r3, [r11]
  00a54	e28d103c	 add         r1, sp, #0x3C
  00a58	e1a0000b	 mov         r0, r11
  00a5c	e5933014	 ldr         r3, [r3, #0x14]
  00a60	e1a0e00f	 mov         lr, pc
  00a64	e12fff13	 bx          r3

; 1819 :                 configFailures++;

  00a68	e2873001	 add         r3, r7, #1
  00a6c	e20370ff	 and         r7, r3, #0xFF
  00a70	e5cd7038	 strb        r7, [sp, #0x38]

; 1820 :                 // Restore bDescriptorLength for the retry.
; 1821 :                 usbHubDescriptor.bDescriptorLength = descriptorLengthToGet;

  00a74	e1a0e005	 mov         lr, r5

; 1822 :             }
; 1823 :             break;

  00a78	e5cd50a0	 strb        r5, [sp, #0xA0]
  00a7c	ea00008f	 b           |$LN177@AttachDevi|
  00a80		 |$LN19@AttachDevi|

; 1824 :         }
; 1825 :         case DEVICE_CONFIG_STATUS_CREATE_NEW_HUB:
; 1826 :         {
; 1827 :             DEBUGCHK( pNewDevice == NULL );
; 1828 :             DEBUGCHK( deviceInfo.Descriptor.bDeviceClass == USB_DEVICE_CLASS_HUB &&
; 1829 :                       usbHubDescriptor.bDescriptorType == USB_HUB_DESCRIPTOR_TYPE &&
; 1830 :                       usbHubDescriptor.bDescriptorLength >= USB_HUB_DESCRIPTOR_MINIMUM_SIZE &&
; 1831 :                       deviceInfo.lpActiveConfig->lpInterfaces[0].Descriptor.bNumEndpoints == 1);
; 1832 : 
; 1833 :             DEBUGCHK( m_tierNumber < USB_MAXIMUM_HUB_TIER );
; 1834 :             pNewDevice = new CExternalHub( address,
; 1835 :                                            deviceInfo,
; 1836 :                                            fIsLowSpeed,fIsHighSpeed,
; 1837 :                                            m_tierNumber + 1,
; 1838 :                                            usbHubDescriptor,
; 1839 :                                            m_pCHcd,
; 1840 :                                            this,port);

  00a80	e3a000cc	 mov         r0, #0xCC
  00a84	eb000000	 bl          |??2@YAPAXI@Z|
  00a88	e3500000	 cmp         r0, #0
  00a8c	0a000012	 beq         |$LN112@AttachDevi|
  00a90	e5d9304c	 ldrb        r3, [r9, #0x4C]
  00a94	e599e0c8	 ldr         lr, [r9, #0xC8]
  00a98	e5dd5040	 ldrb        r5, [sp, #0x40]
  00a9c	e2833001	 add         r3, r3, #1
  00aa0	e20330ff	 and         r3, r3, #0xFF
  00aa4	e58de00c	 str         lr, [sp, #0xC]
  00aa8	e59de080	 ldr         lr, [sp, #0x80]
  00aac	e58d3004	 str         r3, [sp, #4]
  00ab0	e59d3084	 ldr         r3, [sp, #0x84]
  00ab4	e28d40a0	 add         r4, sp, #0xA0
  00ab8	e28d2048	 add         r2, sp, #0x48
  00abc	e1a01008	 mov         r1, r8
  00ac0	e58d5014	 str         r5, [sp, #0x14]
  00ac4	e58d9010	 str         r9, [sp, #0x10]
  00ac8	e58d4008	 str         r4, [sp, #8]
  00acc	e58de000	 str         lr, [sp]
  00ad0	eb000000	 bl          |??0CExternalHub@@QAA@EABU_USB_DEVICE_INFO@@HHEABU_USB_HUB_DESCRIPTOR@@QAVCHcd@@QAVCHub@@E@Z|
  00ad4	e1a06000	 mov         r6, r0
  00ad8	ea000000	 b           |$LN178@AttachDevi|
  00adc		 |$LN112@AttachDevi|
  00adc	e3a06000	 mov         r6, #0
  00ae0		 |$LN178@AttachDevi|

; 1841 :             if ( pNewDevice != NULL ) {

  00ae0	e3560000	 cmp         r6, #0
  00ae4	e58d6044	 str         r6, [sp, #0x44]
  00ae8	0afffde7	 beq         |$LN84@AttachDevi|

; 1842 :                 configStatus = DEVICE_CONFIG_STATUS_INSERT_NEW_DEVICE_INTO_UPSTREAM_HUB_PORT_ARRAY;
; 1843 :             } else {

  00aec	e3a0a011	 mov         r10, #0x11
  00af0	eafffd67	 b           |$LN171@AttachDevi|
  00af4		 |$LN16@AttachDevi|

; 1844 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("CHub(%s tier %d)::AttachDevice - failure on %s step, no memory\n"), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1845 :                 configFailures++;
; 1846 :             }
; 1847 :             break;
; 1848 :         }
; 1849 :         case DEVICE_CONFIG_STATUS_CREATE_NEW_FUNCTION:
; 1850 :         {
; 1851 :             DEBUGCHK( pNewDevice == NULL );
; 1852 :             DEBUGCHK( deviceInfo.Descriptor.bDeviceClass != USB_DEVICE_CLASS_HUB );
; 1853 :             DEBUGCHK( m_tierNumber <= USB_MAXIMUM_HUB_TIER );
; 1854 :             pNewDevice = new CFunction( address,
; 1855 :                                         deviceInfo,
; 1856 :                                         fIsLowSpeed,fIsHighSpeed,
; 1857 :                                         m_tierNumber + 1,
; 1858 :                                         m_pCHcd,
; 1859 :                                         this,port);

  00af4	e3a0006c	 mov         r0, #0x6C
  00af8	eb000000	 bl          |??2@YAPAXI@Z|
  00afc	e3500000	 cmp         r0, #0
  00b00	0afffff5	 beq         |$LN112@AttachDevi|
  00b04	e5d9204c	 ldrb        r2, [r9, #0x4C]
  00b08	e599e0c8	 ldr         lr, [r9, #0xC8]
  00b0c	e5dd4040	 ldrb        r4, [sp, #0x40]
  00b10	e2822001	 add         r2, r2, #1
  00b14	e59d3084	 ldr         r3, [sp, #0x84]
  00b18	e58de008	 str         lr, [sp, #8]
  00b1c	e59de080	 ldr         lr, [sp, #0x80]
  00b20	e20220ff	 and         r2, r2, #0xFF
  00b24	e58d2004	 str         r2, [sp, #4]
  00b28	e28d2048	 add         r2, sp, #0x48
  00b2c	e1a01008	 mov         r1, r8
  00b30	e58d4010	 str         r4, [sp, #0x10]
  00b34	e58d900c	 str         r9, [sp, #0xC]
  00b38	e58de000	 str         lr, [sp]
  00b3c	eb000000	 bl          |??0CFunction@@QAA@EABU_USB_DEVICE_INFO@@HHEQAVCHcd@@QAVCHub@@E@Z|
  00b40	e1a06000	 mov         r6, r0
  00b44	eaffffe5	 b           |$LN178@AttachDevi|
  00b48		 |$LN13@AttachDevi|

; 1860 :             if ( pNewDevice != NULL ) {
; 1861 :                 configStatus = DEVICE_CONFIG_STATUS_INSERT_NEW_DEVICE_INTO_UPSTREAM_HUB_PORT_ARRAY;
; 1862 :             } else {
; 1863 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("CHub(%s tier %d)::AttachDevice - failure on %s step, no memory\n"), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1864 :                 configFailures++;
; 1865 :             }
; 1866 :             break;
; 1867 :         }
; 1868 :         case DEVICE_CONFIG_STATUS_INSERT_NEW_DEVICE_INTO_UPSTREAM_HUB_PORT_ARRAY:
; 1869 :         {
; 1870 :             DEBUGCHK( pNewDevice != NULL );
; 1871 :             EnterCriticalSection( &m_csDeviceLock );

  00b48	e289000c	 add         r0, r9, #0xC
  00b4c	eb000000	 bl          EnterCriticalSection

; 1872 :             DEBUGCHK( m_ppCDeviceOnPort != NULL &&
; 1873 :                       m_ppCDeviceOnPort[ port - 1 ] == NULL );
; 1874 :             m_ppCDeviceOnPort[ port - 1 ] = pNewDevice;

  00b50	e59930b0	 ldr         r3, [r9, #0xB0]

; 1875 :             LeaveCriticalSection( &m_csDeviceLock );

  00b54	e5dd2040	 ldrb        r2, [sp, #0x40]
  00b58	e289000c	 add         r0, r9, #0xC
  00b5c	e0833102	 add         r3, r3, r2, lsl #2
  00b60	e5036004	 str         r6, [r3, #-4]
  00b64	eb000000	 bl          LeaveCriticalSection

; 1876 :             configStatus = DEVICE_CONFIG_STATUS_SIGNAL_NEW_DEVICE_ENTER_OPERATIONAL_STATE;
; 1877 :             break;

  00b68	e3a0a012	 mov         r10, #0x12
  00b6c	eafffd48	 b           |$LN171@AttachDevi|
  00b70		 |$LN12@AttachDevi|

; 1878 :         }
; 1879 :         case DEVICE_CONFIG_STATUS_SIGNAL_NEW_DEVICE_ENTER_OPERATIONAL_STATE:
; 1880 :         {
; 1881 :             DEBUGCHK( pNewDevice != NULL );
; 1882 :             if ( pNewDevice->EnterOperationalState( pControlPipe ) ) {

  00b70	e5963000	 ldr         r3, [r6]
  00b74	e1a0100b	 mov         r1, r11
  00b78	e1a00006	 mov         r0, r6
  00b7c	e5933004	 ldr         r3, [r3, #4]
  00b80	e1a0e00f	 mov         lr, pc
  00b84	e12fff13	 bx          r3
  00b88	e3500000	 cmp         r0, #0
  00b8c	1a000052	 bne         |$LN158@AttachDevi|

; 1883 :                 configStatus = DEVICE_CONFIG_STATUS_DONE;
; 1884 :             } else {
; 1885 :                 // don't do any retries here! EnterOperationalState
; 1886 :                 // should only be tried once
; 1887 :                 DEBUGMSG( ZONE_ATTACH && ZONE_ERROR, (TEXT("CHub(%s tier %d)::AttachDevice - failure on %s step, aborting attach process\n"), GetDeviceType(), m_tierNumber, STATUS_TO_STRING( configStatus ) ) );
; 1888 :                 configStatus = DEVICE_CONFIG_STATUS_FAILED;
; 1889 :                 configFailures = 0xff;
; 1890 :             }
; 1891 :             break;

  00b90	e3a070ff	 mov         r7, #0xFF
  00b94	e5cd7038	 strb        r7, [sp, #0x38]
  00b98	e3a0a013	 mov         r10, #0x13
  00b9c	eafffd3c	 b           |$LN171@AttachDevi|
  00ba0		 |$LN9@AttachDevi|

; 1892 :         }
; 1893 :         case DEVICE_CONFIG_STATUS_FAILED:
; 1894 :         {
; 1895 :             if ( pNewDevice != NULL ) {

  00ba0	e3560000	 cmp         r6, #0
  00ba4	0a000011	 beq         |$LN8@AttachDevi|

; 1896 :                 // this means we have placed the device into our array
; 1897 :                 EnterCriticalSection( &m_csDeviceLock );

  00ba8	e289000c	 add         r0, r9, #0xC
  00bac	eb000000	 bl          EnterCriticalSection

; 1898 :                 DEBUGCHK( (m_fHubThreadClosing && m_ppCDeviceOnPort[ port - 1 ] == NULL) ||
; 1899 :                           m_ppCDeviceOnPort[ port - 1 ] == pNewDevice );
; 1900 :                 m_ppCDeviceOnPort[ port - 1 ] = NULL;

  00bb0	e59930b0	 ldr         r3, [r9, #0xB0]

; 1901 :                 LeaveCriticalSection( &m_csDeviceLock );

  00bb4	e5dd4040	 ldrb        r4, [sp, #0x40]
  00bb8	e3a02000	 mov         r2, #0
  00bbc	e289000c	 add         r0, r9, #0xC
  00bc0	e0833104	 add         r3, r3, r4, lsl #2
  00bc4	e5032004	 str         r2, [r3, #-4]
  00bc8	eb000000	 bl          LeaveCriticalSection

; 1902 :                 // address will be freed by destructor
; 1903 :                 // deviceInfo will be freed by destructor
; 1904 :                 delete pNewDevice;

  00bcc	e5963000	 ldr         r3, [r6]
  00bd0	e3a01001	 mov         r1, #1
  00bd4	e1a00006	 mov         r0, r6
  00bd8	e5933000	 ldr         r3, [r3]
  00bdc	e1a0e00f	 mov         lr, pc
  00be0	e12fff13	 bx          r3

; 1905 :                 pNewDevice = NULL;

  00be4	e3a03000	 mov         r3, #0
  00be8	e58d3044	 str         r3, [sp, #0x44]

; 1906 :             } else {

  00bec	ea000013	 b           |$LN134@AttachDevi|
  00bf0		 |$LN8@AttachDevi|

; 1907 :                 if ( deviceInfo.lpConfigs != NULL ) {

  00bf0	e3500000	 cmp         r0, #0
  00bf4	0a00000d	 beq         |$LN6@AttachDevi|

; 1908 :                     for ( UINT config = 0; config < deviceInfo.Descriptor.bNumConfigurations; config++ ) {

  00bf8	e3a05000	 mov         r5, #0
  00bfc	e3540000	 cmp         r4, #0
  00c00	0a000009	 beq         |$LN3@AttachDevi|
  00c04	e3a04000	 mov         r4, #0
  00c08		 |$LL5@AttachDevi|
  00c08	e0841000	 add         r1, r4, r0

; 1909 :                         DeleteUsbConfigurationStructure( deviceInfo.lpConfigs[ config ] );

  00c0c	e1a00009	 mov         r0, r9
  00c10	eb000000	 bl          |?DeleteUsbConfigurationStructure@CDevice@@QBAXAAU_NON_CONST_USB_CONFIGURATION@@@Z|
  00c14	e5dd305d	 ldrb        r3, [sp, #0x5D]
  00c18	e2855001	 add         r5, r5, #1
  00c1c	e59d0060	 ldr         r0, [sp, #0x60]
  00c20	e1550003	 cmp         r5, r3
  00c24	e2844020	 add         r4, r4, #0x20
  00c28	3afffff6	 bcc         |$LL5@AttachDevi|
  00c2c		 |$LN3@AttachDevi|

; 1910 :                     }
; 1911 :                     delete [] deviceInfo.lpConfigs;

  00c2c	eb000000	 bl          |??3@YAXPAX@Z|
  00c30		 |$LN6@AttachDevi|

; 1912 :                 }
; 1913 :                 DEBUGCHK( address > 0 && address <= USB_MAX_ADDRESS );
; 1914 :                 FreeAddress( address );

  00c30	e5990050	 ldr         r0, [r9, #0x50]
  00c34	e1a01008	 mov         r1, r8
  00c38	eb000000	 bl          |?FreeAddress@CDeviceGlobal@@QAAXE@Z|
  00c3c	e5dd4040	 ldrb        r4, [sp, #0x40]
  00c40		 |$LN134@AttachDevi|

; 1915 :             }
; 1916 :             if ( pControlPipe ) {

  00c40	e35b0000	 cmp         r11, #0
  00c44	0a00000b	 beq         |$LN2@AttachDevi|

; 1917 :                 pControlPipe->ClosePipe();

  00c48	e59b3000	 ldr         r3, [r11]
  00c4c	e1a0000b	 mov         r0, r11
  00c50	e5933008	 ldr         r3, [r3, #8]
  00c54	e1a0e00f	 mov         lr, pc
  00c58	e12fff13	 bx          r3

; 1918 :                 delete pControlPipe;

  00c5c	e59b3000	 ldr         r3, [r11]
  00c60	e3a01001	 mov         r1, #1
  00c64	e1a0000b	 mov         r0, r11
  00c68	e5933000	 ldr         r3, [r3]
  00c6c	e1a0e00f	 mov         lr, pc
  00c70	e12fff13	 bx          r3

; 1919 :                 pControlPipe = NULL;

  00c74	e3a0b000	 mov         r11, #0
  00c78		 |$LN2@AttachDevi|

; 1920 :             }
; 1921 :             fPipeHalted = TRUE;
; 1922 :             DisablePort( port );

  00c78	e5993000	 ldr         r3, [r9]
  00c7c	e3a02001	 mov         r2, #1
  00c80	e1a01004	 mov         r1, r4
  00c84	e5933058	 ldr         r3, [r3, #0x58]
  00c88	e1a00009	 mov         r0, r9
  00c8c	e58d203c	 str         r2, [sp, #0x3C]
  00c90	e1a0e00f	 mov         lr, pc
  00c94	e12fff13	 bx          r3

; 1923 :             if ( fUsingAddr0 ) {

  00c98	e59d306c	 ldr         r3, [sp, #0x6C]
  00c9c	e3530000	 cmp         r3, #0
  00ca0	0a000004	 beq         |$LN1@AttachDevi|

; 1924 :                 //LeaveCritSec_Ex( &m_csAddress0Lock );
; 1925 :                 m_pDeviceGlobal->Addr0LockLeave();

  00ca4	e5993050	 ldr         r3, [r9, #0x50]
  00ca8	e283002c	 add         r0, r3, #0x2C
  00cac	eb000000	 bl          |?LeaveCritSec_Ex@CritSec_Ex@@QAAXXZ|

; 1926 :                 fUsingAddr0 = FALSE;

  00cb0	e3a05000	 mov         r5, #0
  00cb4	e58d506c	 str         r5, [sp, #0x6C]
  00cb8		 |$LN1@AttachDevi|

; 1927 :             }
; 1928 :             configStatus = DEVICE_CONFIG_STATUS_DONE;

  00cb8	e3a0a014	 mov         r10, #0x14
  00cbc		 |$LN174@AttachDevi|
  00cbc	e5dde0a0	 ldrb        lr, [sp, #0xA0]
  00cc0		 |$LN177@AttachDevi|
  00cc0	e59d103c	 ldr         r1, [sp, #0x3C]
  00cc4	e59d2064	 ldr         r2, [sp, #0x64]
  00cc8	e59d0060	 ldr         r0, [sp, #0x60]
  00ccc	e5dd405d	 ldrb        r4, [sp, #0x5D]
  00cd0		 |$LN93@AttachDevi|
  00cd0	e59d6044	 ldr         r6, [sp, #0x44]
  00cd4	e35a0014	 cmp         r10, #0x14
  00cd8	1afffcf2	 bne         |$LL98@AttachDevi|
  00cdc		 |$LN158@AttachDevi|

; 1362 : {

  00cdc	e59d00e8	 ldr         r0, [sp, #0xE8]
  00ce0	eb000000	 bl          __security_check_cookie

; 1929 :             break;
; 1930 :         }
; 1931 :     #ifdef DEBUG
; 1932 :         default:
; 1933 :         {
; 1934 :             DebugBreak(); // should never get here!
; 1935 :             break;
; 1936 :         }
; 1937 :     #endif // DEBUG
; 1938 :         } // end of switch ( configStatus )
; 1939 :     } // end of while ( configStatus != DEVICE_CONFIG_STATUS_DONE )
; 1940 : 
; 1941 :     DEBUGMSG( ZONE_ATTACH, (TEXT("-CHub(%s tier %d)::AttachDevice - port = %d, fIsLowSpeed = %d, address = %d\n"), GetDeviceType(), m_tierNumber, port, fIsLowSpeed, address ) );
; 1942 : }

  00ce4	e28dd0ec	 add         sp, sp, #0xEC
  00ce8	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00cec	e12fff1e	 bx          lr
  00cf0		 |$LN207@AttachDevi|
  00cf0		 |$LN208@AttachDevi|
  00cf0	00000000	 DCD         |?TransferDoneCallbackSetEvent@CDevice@@KAKPAX@Z|
  00cf4		 |$LN209@AttachDevi|
  00cf4	00000000	 DCD         |??_C@_1II@HDIFDMNL@?$AA?$CB?$AAU?$AAS?$AAB?$AA?5?$AAw?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAa?$AAt?$AAt?$AAa?$AAc?$AAh?$AA?5?$AAh?$AAi?$AAg?$AAh@|
  00cf8		 |$LN210@AttachDevi|
  00cf8	00000000	 DCD         |??_C@_1HE@DLPCNLDH@?$AA?$CB?$AAC?$AAH?$AAu?$AAb?$AA?3?$AA?3?$AAA?$AAt?$AAt?$AAa?$AAc?$AAh?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAw?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAi?$AAn?$AAv@|
  00cfc		 |$LN211@AttachDevi|
  00cfc	00000000	 DCD         |??_C@_1HK@HGAGGCPB@?$AAU?$AAS?$AAB?$AA?5?$AAs?$AAp?$AAe?$AAc?$AAi?$AAf?$AAi?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAd?$AAo?$AAe?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAw@|
  00d00		 |$LN212@AttachDevi|
  00d00	00000000	 DCD         |__security_cookie|
  00d04		 |$M37809|

			 ENDP  ; |?AttachDevice@CHub@@IAAXEHH@Z|, CHub::AttachDevice

; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T37840| DCD	|$LN17@DisableOff|
	DCD	0x40003802
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DisableOffStreamDevice@CHub@@UAAHIH@Z| PROC ; CHub::DisableOffStreamDevice

; 2708 : {

  00000		 |$LN17@DisableOff|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M37837|
  00008	e1a08002	 mov         r8, r2
  0000c	e1a09001	 mov         r9, r1
  00010	e1a04000	 mov         r4, r0

; 2709 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CHub(%s tier %d)::DisableOffStreamDevice - address = %d, pipeIndex = %d\n"), GetDeviceType(), m_tierNumber, address, fReset) );
; 2710 :     EnterCriticalSection( &m_csDeviceLock );

  00014	e284000c	 add         r0, r4, #0xC
  00018	eb000000	 bl          EnterCriticalSection

; 2711 :     BOOL fReturn = FALSE;
; 2712 :     for ( UCHAR port = 1; port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  0001c	e5d4706a	 ldrb        r7, [r4, #0x6A]
  00020	e3a06000	 mov         r6, #0
  00024	e3a05001	 mov         r5, #1
  00028	e3570001	 cmp         r7, #1
  0002c	3a000025	 bcc         |$LN14@DisableOff|
  00030	e594e0b0	 ldr         lr, [r4, #0xB0]
  00034		 |$LL6@DisableOff|

; 2713 :         if ( m_ppCDeviceOnPort[ port - 1 ] != NULL &&  m_ppCDeviceOnPort[ port - 1 ]->GetDeviceAddress()==address) {

  00034	e08e0105	 add         r0, lr, r5, lsl #2
  00038	e5103004	 ldr         r3, [r0, #-4]
  0003c	e3530000	 cmp         r3, #0
  00040	0a000002	 beq         |$LN5@DisableOff|
  00044	e5d33020	 ldrb        r3, [r3, #0x20]
  00048	e1530009	 cmp         r3, r9
  0004c	0a000004	 beq         |$LN12@DisableOff|
  00050		 |$LN5@DisableOff|

; 2711 :     BOOL fReturn = FALSE;
; 2712 :     for ( UCHAR port = 1; port <= m_usbHubDescriptor.bNumberOfPorts; port++ ) {

  00050	e2853001	 add         r3, r5, #1
  00054	e20350ff	 and         r5, r3, #0xFF
  00058	e1550007	 cmp         r5, r7
  0005c	9afffff4	 bls         |$LL6@DisableOff|
  00060	ea000018	 b           |$LN14@DisableOff|
  00064		 |$LN12@DisableOff|

; 2714 :             USB_HUB_AND_PORT_STATUS     hubStatus;
; 2715 :             if (GetStatus(port, hubStatus) && hubStatus.status.port.PortConnected) {

  00064	e5943000	 ldr         r3, [r4]
  00068	e28d2000	 add         r2, sp, #0
  0006c	e1a01005	 mov         r1, r5
  00070	e5933050	 ldr         r3, [r3, #0x50]
  00074	e1a00004	 mov         r0, r4
  00078	e1a0e00f	 mov         lr, pc
  0007c	e12fff13	 bx          r3
  00080	e3500000	 cmp         r0, #0
  00084	0a00000e	 beq         |$LN1@DisableOff|
  00088	e1dd30b0	 ldrh        r3, [sp]
  0008c	e3130001	 tst         r3, #1
  00090	0a00000b	 beq         |$LN1@DisableOff|

; 2716 :                 // Hub Status change thread will NOT wake up by Disable Port becuase
; 2717 :                 // DisablePort will NOT generate  hubStatus.change.port.PortEnableChange 
; 2718 :                 // So after DisablePort(port), we have to call AttachDevice Manually
; 2719 :                 DetachDevice(port );

  00094	e1a01005	 mov         r1, r5
  00098	e1a00004	 mov         r0, r4
  0009c	eb000000	 bl          |?DetachDevice@CHub@@IAAXE@Z|

; 2720 :                 if (fReset) 

  000a0	e3580000	 cmp         r8, #0

; 2721 :                     AttachDevice( port, hubStatus.status.port.DeviceIsLowSpeed,hubStatus.status.port.DeviceIsHighSpeed );

  000a4	11dd20b0	 ldrneh      r2, [sp]
  000a8	11a01005	 movne       r1, r5
  000ac	11a00004	 movne       r0, r4
  000b0	11a03a82	 movne       r3, r2, lsl #21
  000b4	11a02b02	 movne       r2, r2, lsl #22
  000b8	11a02fa2	 movne       r2, r2, lsr #31
  000bc	11a03fa3	 movne       r3, r3, lsr #31
  000c0	1b000000	 blne        |?AttachDevice@CHub@@IAAXEHH@Z|
  000c4		 |$LN1@DisableOff|

; 2722 :             }
; 2723 :             fReturn = TRUE;

  000c4	e3a06001	 mov         r6, #1
  000c8		 |$LN14@DisableOff|

; 2724 :             break;
; 2725 :         }
; 2726 :     }
; 2727 :     LeaveCriticalSection( &m_csDeviceLock );    

  000c8	e284000c	 add         r0, r4, #0xC
  000cc	eb000000	 bl          LeaveCriticalSection

; 2728 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("-CHub(%s tier %d)::DisableOffStreamDevice - address = %d, returing HCD_REQUEST_STATUS %d\n"), GetDeviceType(), m_tierNumber, address, fReturn) );
; 2729 :     ASSERT(fReturn == TRUE);
; 2730 :     return fReturn;
; 2731 : 
; 2732 : }

  000d0	e1a00006	 mov         r0, r6
  000d4	e28dd004	 add         sp, sp, #4
  000d8	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000dc	e12fff1e	 bx          lr
  000e0		 |$M37838|

			 ENDP  ; |?DisableOffStreamDevice@CHub@@UAAHIH@Z|, CHub::DisableOffStreamDevice


  00000			 AREA	 |.pdata|, PDATA
|$T37854| DCD	|$LN8@scalar@3|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GCRootHub@@UAAPAXI@Z| PROC		; CRootHub::`scalar deleting destructor'
  00000		 |$LN8@scalar@3|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37851|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	e59f301c	 ldr         r3, [pc, #0x1C]
  00010	e5853000	 str         r3, [r5]
  00014	eb000000	 bl          |??1CHub@@UAA@XZ|
  00018	e3140001	 tst         r4, #1
  0001c	11a00005	 movne       r0, r5
  00020	1b000000	 blne        |??3@YAXPAX@Z|
  00024	e1a00005	 mov         r0, r5
  00028	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$LN9@scalar@3|
  00030		 |$LN10@scalar@3|
  00030	00000000	 DCD         |??_7CRootHub@@6B@|
  00034		 |$M37852|

			 ENDP  ; |??_GCRootHub@@UAAPAXI@Z|, CRootHub::`scalar deleting destructor'


  00000			 AREA	 |.pdata|, PDATA
|$T37870| DCD	|$LN8@scalar@4|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GCExternalHub@@UAAPAXI@Z| PROC	; CExternalHub::`scalar deleting destructor'
  00000		 |$LN8@scalar@4|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37867|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	e59f301c	 ldr         r3, [pc, #0x1C]
  00010	e5853000	 str         r3, [r5]
  00014	eb000000	 bl          |??1CHub@@UAA@XZ|
  00018	e3140001	 tst         r4, #1
  0001c	11a00005	 movne       r0, r5
  00020	1b000000	 blne        |??3@YAXPAX@Z|
  00024	e1a00005	 mov         r0, r5
  00028	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$LN9@scalar@4|
  00030		 |$LN10@scalar@4|
  00030	00000000	 DCD         |??_7CExternalHub@@6B@|
  00034		 |$M37868|

			 ENDP  ; |??_GCExternalHub@@UAAPAXI@Z|, CExternalHub::`scalar deleting destructor'


  00000			 AREA	 |.pdata|, PDATA
|$T37886| DCD	|$LN8@scalar@5|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GCFunction@@UAAPAXI@Z| PROC	; CFunction::`scalar deleting destructor'
  00000		 |$LN8@scalar@5|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37883|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	e59f301c	 ldr         r3, [pc, #0x1C]
  00010	e5853000	 str         r3, [r5]
  00014	eb000000	 bl          |??1CDevice@@UAA@XZ|
  00018	e3140001	 tst         r4, #1
  0001c	11a00005	 movne       r0, r5
  00020	1b000000	 blne        |??3@YAXPAX@Z|
  00024	e1a00005	 mov         r0, r5
  00028	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$LN9@scalar@5|
  00030		 |$LN10@scalar@5|
  00030	00000000	 DCD         |??_7CFunction@@6B@|
  00034		 |$M37884|

			 ENDP  ; |??_GCFunction@@UAAPAXI@Z|, CFunction::`scalar deleting destructor'

	EXPORT	|?HubStatusChangeThread@CHub@@AAAKXZ|	; CHub::HubStatusChangeThread
	EXPORT	|??_C@_1IM@DCJHGIOD@?$AAC?$AAH?$AAu?$AAb?$AA?$CI?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAH?$AAu?$AAb?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AAC?$AAh?$AAa?$AAn?$AAg?$AAe?$AAT?$AAh@| [ DATA ] ; `string'
; File c:\wince600\osdesigns\z2170p\z2170p\wince600\z2170p_armv4i\cesysgen\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T37948| DCD	|$LN77@HubStatusC|
	DCD	0x40012a02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1IM@DCJHGIOD@?$AAC?$AAH?$AAu?$AAb?$AA?$CI?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAH?$AAu?$AAb?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AAC?$AAh?$AAa?$AAn?$AAg?$AAe?$AAT?$AAh@| DCB "C"
	DCB	0x0, "H", 0x0, "u", 0x0, "b", 0x0, "(", 0x0, "t", 0x0, "i"
	DCB	0x0, "e", 0x0, "r", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ")"
	DCB	0x0, ":", 0x0, ":", 0x0, "H", 0x0, "u", 0x0, "b", 0x0, "S"
	DCB	0x0, "t", 0x0, "a", 0x0, "t", 0x0, "u", 0x0, "s", 0x0, "C"
	DCB	0x0, "h", 0x0, "a", 0x0, "n", 0x0, "g", 0x0, "e", 0x0, "T"
	DCB	0x0, "h", 0x0, "r", 0x0, "e", 0x0, "a", 0x0, "d", 0x0, " "
	DCB	0x0, "-", 0x0, " ", 0x0, "a", 0x0, "d", 0x0, "d", 0x0, "r"
	DCB	0x0, " ", 0x0, "%", 0x0, "d", 0x0, " ", 0x0, "p", 0x0, "o"
	DCB	0x0, "r", 0x0, "t", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, " "
	DCB	0x0, "o", 0x0, "v", 0x0, "e", 0x0, "r", 0x0, " ", 0x0, "c"
	DCB	0x0, "u", 0x0, "r", 0x0, "r", 0x0, "e", 0x0, "n", 0x0, "t"
	DCB	0x0, "!", 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\usb2com\cdevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HubStatusChangeThread@CHub@@AAAKXZ| PROC ; CHub::HubStatusChangeThread

; 1031 : {

  00000		 |$LN77@HubStatusC|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M37945|
  00008	e1a05000	 mov         r5, r0

; 1032 :     DEBUGMSG( ZONE_HUB && ZONE_VERBOSE, (TEXT("+CHub(%s tier %d)::HubStatusChangeThread\n"), GetDeviceType(), m_tierNumber ) );
; 1033 :     DEBUGCHK( m_hHubStatusChangeEvent != NULL && m_hHubStatusChangeThread != NULL );
; 1034 : 
; 1035 :     UCHAR                       port;
; 1036 :     USB_HUB_AND_PORT_STATUS     hubStatus;
; 1037 :     BOOL                        fSuccess = FALSE;
; 1038 : 
; 1039 :     // before we can process port changes, we need
; 1040 :     // to power all ports
; 1041 :     while ( !m_fHubThreadClosing && !fSuccess) {

  0000c	e59530b8	 ldr         r3, [r5, #0xB8]
  00010	e3a00000	 mov         r0, #0
  00014	e3530000	 cmp         r3, #0
  00018	1a00000f	 bne         |$LN35@HubStatusC|
  0001c		 |$LL37@HubStatusC|
  0001c	e3500000	 cmp         r0, #0
  00020	1a000007	 bne         |$LN36@HubStatusC|

; 1042 :         fSuccess = PowerAllHubPorts();

  00024	e5953000	 ldr         r3, [r5]
  00028	e1a00005	 mov         r0, r5
  0002c	e5933040	 ldr         r3, [r3, #0x40]
  00030	e1a0e00f	 mov         lr, pc
  00034	e12fff13	 bx          r3
  00038	e59530b8	 ldr         r3, [r5, #0xB8]
  0003c	e3530000	 cmp         r3, #0
  00040	0afffff5	 beq         |$LL37@HubStatusC|
  00044		 |$LN36@HubStatusC|

; 1043 :     }
; 1044 :     if ( !m_fHubThreadClosing ) {

  00044	e59530b8	 ldr         r3, [r5, #0xB8]
  00048	e3530000	 cmp         r3, #0

; 1045 : #if 0
; 1046 :         Sleep( 2 * m_usbHubDescriptor.bPowerOnToPowerGood );
; 1047 : #else
; 1048 :         // According to the USB spec 1.1, section 7.1.7.1, there
; 1049 :         // is supposed to be a delay of up to 100ms (t2) before the device
; 1050 :         // can signal attach. I don't know if the software is
; 1051 :         // supposed to implement this delay. No harm in implementing
; 1052 :         // it though.
; 1053 :         Sleep( 100 + 2 * m_usbHubDescriptor.bPowerOnToPowerGood );

  0004c	05d5306d	 ldreqb      r3, [r5, #0x6D]
  00050	02833032	 addeq       r3, r3, #0x32
  00054	01a00083	 moveq       r0, r3, lsl #1
  00058	0b000000	 bleq        Sleep
  0005c		 |$LN35@HubStatusC|

; 1054 : #endif
; 1055 :     }
; 1056 :     SetOrClearRemoteWakup(TRUE);

  0005c	e5953000	 ldr         r3, [r5]
  00060	e3a01001	 mov         r1, #1
  00064	e1a00005	 mov         r0, r5
  00068	e593304c	 ldr         r3, [r3, #0x4C]
  0006c	e1a0e00f	 mov         lr, pc
  00070	e12fff13	 bx          r3

; 1057 :     while ( !m_fHubThreadClosing ) {

  00074	e59530b8	 ldr         r3, [r5, #0xB8]
  00078	e3530000	 cmp         r3, #0
  0007c	1a000104	 bne         |$LN74@HubStatusC|
  00080	e3a03cff	 mov         r3, #0xFF, 24
  00084	e38370fe	 orr         r7, r3, #0xFE
  00088	e3a08001	 mov         r8, #1
  0008c		 |$LL34@HubStatusC|

; 1058 :         
; 1059 :         fSuccess = (WaitForSingleObject(m_hHubSuspendBlockEvent,INFINITE) == WAIT_OBJECT_0);

  0008c	e59500c4	 ldr         r0, [r5, #0xC4]
  00090	e3e01000	 mvn         r1, #0
  00094	eb000000	 bl          WaitForSingleObject

; 1060 :         if (m_fHubThreadClosing || !fSuccess)

  00098	e59530b8	 ldr         r3, [r5, #0xB8]
  0009c	e3500000	 cmp         r0, #0
  000a0	03a02001	 moveq       r2, #1
  000a4	13a02000	 movne       r2, #0
  000a8	e3530000	 cmp         r3, #0
  000ac	1a0000f8	 bne         |$LN74@HubStatusC|
  000b0	e3520000	 cmp         r2, #0
  000b4	0a0000f6	 beq         |$LN74@HubStatusC|

; 1061 :             break;
; 1062 :         
; 1063 :         fSuccess = WaitForPortStatusChange( port, hubStatus );

  000b8	e5953000	 ldr         r3, [r5]
  000bc	e28d2004	 add         r2, sp, #4
  000c0	e28d1000	 add         r1, sp, #0
  000c4	e5933044	 ldr         r3, [r3, #0x44]
  000c8	e1a00005	 mov         r0, r5
  000cc	e1a0e00f	 mov         lr, pc
  000d0	e12fff13	 bx          r3

; 1064 :         if ( m_fHubThreadClosing || !fSuccess ) {

  000d4	e59530b8	 ldr         r3, [r5, #0xB8]
  000d8	e3530000	 cmp         r3, #0
  000dc	1a0000b0	 bne         |$LN29@HubStatusC|
  000e0	e3500000	 cmp         r0, #0
  000e4	0a0000b0	 beq         |$LN69@HubStatusC|

; 1085 :                     }
; 1086 :                 }
; 1087 :                 
; 1088 :             }
; 1089 :             else
; 1090 :                 DEBUGMSG( ZONE_ERROR && !m_fHubThreadClosing, (TEXT("CHub(%s tier %d)::HubStatusChangeThread - error reading port status change\n"), GetDeviceType(), m_tierNumber ));
; 1091 :             continue; // loop will exit if m_fHubThreadClosing is set
; 1092 :         }
; 1093 :         if ( port == 0 ) { // Port 0 indicate this is hub status.

  000e8	e5dd0000	 ldrb        r0, [sp]
  000ec	e3500000	 cmp         r0, #0
  000f0	1a00000b	 bne         |$LN20@HubStatusC|

; 1094 :             if (hubStatus.change.hub.OverCurrentIndicatorChange ) {

  000f4	e1dd30b6	 ldrh        r3, [sp, #6]
  000f8	e3130002	 tst         r3, #2
  000fc	0a0000e1	 beq         |$LN56@HubStatusC|

; 1095 :                 if ( hubStatus.status.hub.OverCurrentIndicator ) {

  00100	e1dd30b4	 ldrh        r3, [sp, #4]
  00104	e3130002	 tst         r3, #2
  00108	0a0000de	 beq         |$LN56@HubStatusC|

; 1096 :                     RETAILMSG(1, (TEXT("CHub(tier %d)::HubStatusChangeThread - addr %d port %d over current!\n"),
; 1097 :                                   m_tierNumber, m_address, port));

  0010c	e5d52020	 ldrb        r2, [r5, #0x20]
  00110	e5d5104c	 ldrb        r1, [r5, #0x4C]
  00114	e1a03000	 mov         r3, r0
  00118	e59f0384	 ldr         r0, [pc, #0x384]
  0011c	eb000000	 bl          NKDbgPrintfW

; 1098 :                 } else {
; 1099 :                     // hub is no longer over current - re-enumerate all ports
; 1100 :                     // todo - re-enumerate all hub ports during hub over-current recovery
; 1101 :                 }
; 1102 :             }
; 1103 :             continue;

  00120	ea0000d8	 b           |$LN56@HubStatusC|
  00124		 |$LN20@HubStatusC|

; 1104 :         }
; 1105 : 
; 1106 :         // we will get here if the status of port # "port" has changed.
; 1107 :         // the status information will be in "hubStatus"
; 1108 :         DEBUGCHK( port <= m_usbHubDescriptor.bNumberOfPorts );
; 1109 :         DEBUGMSG( ZONE_ATTACH, (TEXT("CHub(%s tier %d)::HubStatusChangeThread - port %d, change = 0x%04x, status = 0x%04x\n"), GetDeviceType(), m_tierNumber, port, hubStatus.change.word, hubStatus.status.word ) );
; 1110 : 
; 1111 :         if (hubStatus.change.port.OverCurrentChange ) {

  00124	e1dd20b6	 ldrh        r2, [sp, #6]
  00128	e1a03802	 mov         r3, r2, lsl #16
  0012c	e1a03823	 mov         r3, r3, lsr #16
  00130	e3130008	 tst         r3, #8
  00134	0a000015	 beq         |$LN14@HubStatusC|

; 1112 :             if ( hubStatus.status.port.PortOverCurrent ) {

  00138	e1dd30b4	 ldrh        r3, [sp, #4]
  0013c	e3130008	 tst         r3, #8
  00140	0a000010	 beq         |$LN15@HubStatusC|

; 1113 :                 RETAILMSG(1, (TEXT("CHub(tier %d)::HubStatusChangeThread - addr %d port %d over current!\n"),
; 1114 :                               m_tierNumber, m_address, port));

  00144	e5d52020	 ldrb        r2, [r5, #0x20]
  00148	e5d5104c	 ldrb        r1, [r5, #0x4C]
  0014c	e1a03000	 mov         r3, r0
  00150	e59f034c	 ldr         r0, [pc, #0x34C]
  00154	eb000000	 bl          NKDbgPrintfW

; 1115 :                 DetachDevice( port );

  00158	e5dd1000	 ldrb        r1, [sp]
  0015c	e1a00005	 mov         r0, r5
  00160	eb000000	 bl          |?DetachDevice@CHub@@IAAXE@Z|

; 1116 : #if 1   // the "correct" thing to do, according to my reading of the USB spec
; 1117 :                 SetOrClearFeature( port, USB_REQUEST_CLEAR_FEATURE, USB_HUB_FEATURE_PORT_POWER );

  00164	e5952000	 ldr         r2, [r5]
  00168	e5dd1000	 ldrb        r1, [sp]
  0016c	e3a03008	 mov         r3, #8
  00170	e5924048	 ldr         r4, [r2, #0x48]
  00174	e3a02001	 mov         r2, #1
  00178	e1a00005	 mov         r0, r5
  0017c	e1a0e00f	 mov         lr, pc
  00180	e12fff14	 bx          r4

; 1118 : #else   // another approach
; 1119 :                 do {
; 1120 :                     Sleep( 500 );
; 1121 :                     GetStatus( port, hubStatus );
; 1122 :                 } while (hubStatus.status.port.PortOverCurrent && !m_fHubThreadClosing);
; 1123 :                 hubStatus.change.port.ConnectStatusChange = 1;
; 1124 : #endif
; 1125 :             } else {

  00184	ea000001	 b           |$LN14@HubStatusC|
  00188		 |$LN15@HubStatusC|

; 1126 :                 // port is no longer over current - pretend this is a normal attach
; 1127 :                 // simulate a connect status change. this has the undesirable but basically harmless
; 1128 :                 // side effect of wasting 100 ms to needlessly debounce the power rail.
; 1129 :                 hubStatus.change.port.ConnectStatusChange = 1;

  00188	e3823001	 orr         r3, r2, #1
  0018c	e1cd30b6	 strh        r3, [sp, #6]
  00190		 |$LN14@HubStatusC|

; 1130 :             }
; 1131 :         }
; 1132 :         // Resume Notification.
; 1133 :         EnterCriticalSection( &m_csDeviceLock );

  00190	e285000c	 add         r0, r5, #0xC
  00194	eb000000	 bl          EnterCriticalSection

; 1134 :         if ( hubStatus.change.port.SuspendChange && !hubStatus.status.port.PortSuspended  && 
; 1135 :                 m_ppCDeviceOnPort[port-1]!=NULL ) {

  00198	e1dd30b6	 ldrh        r3, [sp, #6]
  0019c	e3130004	 tst         r3, #4
  001a0	0a00000c	 beq         |$LN13@HubStatusC|
  001a4	e1dd30b4	 ldrh        r3, [sp, #4]
  001a8	e3130004	 tst         r3, #4
  001ac	1a000009	 bne         |$LN13@HubStatusC|
  001b0	e59520b0	 ldr         r2, [r5, #0xB0]
  001b4	e5dd3000	 ldrb        r3, [sp]
  001b8	e0822103	 add         r2, r2, r3, lsl #2
  001bc	e5123004	 ldr         r3, [r2, #-4]
  001c0	e3530000	 cmp         r3, #0

; 1136 :             m_ppCDeviceOnPort[port-1]->ResumeNotification();

  001c4	11a00003	 movne       r0, r3
  001c8	15903000	 ldrne       r3, [r0]
  001cc	15933028	 ldrne       r3, [r3, #0x28]
  001d0	11a0e00f	 movne       lr, pc
  001d4	112fff13	 bxne        r3
  001d8		 |$LN13@HubStatusC|

; 1137 :         }
; 1138 :         LeaveCriticalSection( &m_csDeviceLock );

  001d8	e285000c	 add         r0, r5, #0xC
  001dc	eb000000	 bl          LeaveCriticalSection

; 1139 :         if ( hubStatus.change.port.PortEnableChange &&
; 1140 :              !hubStatus.status.port.PortEnabled &&
; 1141 :              hubStatus.status.port.PortConnected ) {

  001e0	e1dd20b6	 ldrh        r2, [sp, #6]
  001e4	e3120002	 tst         r2, #2
  001e8	0a00001b	 beq         |$LN11@HubStatusC|
  001ec	e1dd10b4	 ldrh        r1, [sp, #4]
  001f0	e1a03801	 mov         r3, r1, lsl #16
  001f4	e1a03823	 mov         r3, r3, lsr #16
  001f8	e3130002	 tst         r3, #2
  001fc	1a000016	 bne         |$LN11@HubStatusC|
  00200	e3110001	 tst         r1, #1
  00204	0a000014	 beq         |$LN11@HubStatusC|

; 1142 :             // Connected device has become disabled. If the device was
; 1143 :             // already successfully attached, let's try detach/reattach.
; 1144 :             // It is important to check that the device was successfully
; 1145 :             // attached - otherwise, we can get into an infinite loop
; 1146 :             // of try attach, fail, disable port, retry attach.
; 1147 :             BOOL fDeviceIsPresent;
; 1148 : 
; 1149 :             EnterCriticalSection( &m_csDeviceLock );

  00208	e285000c	 add         r0, r5, #0xC
  0020c	eb000000	 bl          EnterCriticalSection

; 1150 :             DEBUGCHK( m_ppCDeviceOnPort != NULL );
; 1151 :             fDeviceIsPresent = ( m_ppCDeviceOnPort[ port - 1 ] != NULL );

  00210	e59520b0	 ldr         r2, [r5, #0xB0]
  00214	e5dd3000	 ldrb        r3, [sp]

; 1152 :             LeaveCriticalSection( &m_csDeviceLock );

  00218	e285000c	 add         r0, r5, #0xC
  0021c	e0823103	 add         r3, r2, r3, lsl #2
  00220	e5133004	 ldr         r3, [r3, #-4]
  00224	e3530000	 cmp         r3, #0
  00228	13a04001	 movne       r4, #1
  0022c	03a04000	 moveq       r4, #0
  00230	eb000000	 bl          LeaveCriticalSection

; 1153 : 
; 1154 :             if ( fDeviceIsPresent ) {

  00234	e3540000	 cmp         r4, #0
  00238	0a000006	 beq         |$LN73@HubStatusC|

; 1155 :                 DEBUGMSG( ZONE_WARNING, (TEXT("CHub(%s tier %d)::HubStatusChangeThread - device on port %d is connected but has been disabled. Trying to detach & re-attach\n"), GetDeviceType(), m_tierNumber, port) );
; 1156 :                 DetachDevice( port );

  0023c	e5dd1000	 ldrb        r1, [sp]
  00240	e1a00005	 mov         r0, r5
  00244	eb000000	 bl          |?DetachDevice@CHub@@IAAXE@Z|

; 1157 :                 // this will cause device attach below, since
; 1158 :                 // hubStatus.status.port.PortConnected is already set
; 1159 :                 hubStatus.change.port.ConnectStatusChange = 1;

  00248	e1dd30b6	 ldrh        r3, [sp, #6]
  0024c	e3832001	 orr         r2, r3, #1
  00250	e1cd20b6	 strh        r2, [sp, #6]
  00254	ea000000	 b           |$LN11@HubStatusC|
  00258		 |$LN73@HubStatusC|
  00258	e1dd20b6	 ldrh        r2, [sp, #6]
  0025c		 |$LN11@HubStatusC|

; 1160 :                 DEBUGCHK( hubStatus.status.port.PortConnected );
; 1161 :             }
; 1162 :         } // we can ignore all other enabled changes
; 1163 : 
; 1164 :         // now check for connect changes
; 1165 :         if ( hubStatus.change.port.ConnectStatusChange ) {

  0025c	e3120001	 tst         r2, #1
  00260	0a000088	 beq         |$LN56@HubStatusC|

; 1166 :             EnterCriticalSection( &m_csDeviceLock );

  00264	e285000c	 add         r0, r5, #0xC
  00268	eb000000	 bl          EnterCriticalSection

; 1167 :             BOOL fDeviceAlreadyExists = (m_ppCDeviceOnPort[ port - 1 ] != NULL);

  0026c	e59520b0	 ldr         r2, [r5, #0xB0]
  00270	e5dd3000	 ldrb        r3, [sp]

; 1168 :             LeaveCriticalSection( &m_csDeviceLock );

  00274	e285000c	 add         r0, r5, #0xC
  00278	e0823103	 add         r3, r2, r3, lsl #2
  0027c	e5133004	 ldr         r3, [r3, #-4]
  00280	e3530000	 cmp         r3, #0
  00284	13a04001	 movne       r4, #1
  00288	03a04000	 moveq       r4, #0
  0028c	eb000000	 bl          LeaveCriticalSection

; 1169 : 
; 1170 :             // we got a connect status change notification on this port, so...
; 1171 :             if (fDeviceAlreadyExists) {

  00290	e3540000	 cmp         r4, #0

; 1172 :                 // ... a change when the device is already here must be a detach;
; 1173 :                 //     if there's still something connected then it must be new.
; 1174 :                 DEBUGMSG( ZONE_ATTACH, (TEXT("CHub(%s tier %d)::HubStatusChangeThread - device detached on port %d\n"), GetDeviceType(), m_tierNumber, port ) );
; 1175 :                 DetachDevice(port);

  00294	15dd1000	 ldrneb      r1, [sp]
  00298	11a00005	 movne       r0, r5
  0029c	1b000000	 blne        |?DetachDevice@CHub@@IAAXE@Z|

; 1176 : #ifdef DEBUG
; 1177 :                 if ( hubStatus.status.port.PortConnected ) {
; 1178 :                     DEBUGMSG( 1/*(ZONE_WARNING && ZONE_VERBOSE) || ZONE_ATTACH*/,
; 1179 :                               (TEXT("CHub(%s tier %d)::HubStatusChangeThread -")
; 1180 :                                TEXT(" quick detach and re-attach on port %d\n"),
; 1181 :                                GetDeviceType(), m_tierNumber, port) );
; 1182 :                 }
; 1183 : #endif // DEBUG
; 1184 :             }
; 1185 :             // ... a change with no device present must be an attach
; 1186 :             //     but section 7.1.7.1 of the USB 1.1 spec says we're
; 1187 :             //     responsible for de-bouncing the attach signalling.
; 1188 :             //
; 1189 :             // we do the de-bouncing by waiting until a 100 ms interval
; 1190 :             // (t3 on figure 7-19 in the spec) elapses with no connection
; 1191 :             // status change on the port. Then we can examine the current
; 1192 :             // connect status reliably.
; 1193 :             BOOL fPoll = TRUE;

  002a0	e3a06001	 mov         r6, #1
  002a4		 |$LL8@HubStatusC|

; 1196 :                 USB_HUB_AND_PORT_STATUS hubStatus2;
; 1197 :                 Sleep( 100 );

  002a4	e3a00064	 mov         r0, #0x64
  002a8	eb000000	 bl          Sleep

; 1198 :                 if ( GetStatus( port, hubStatus2 ) == FALSE ) {

  002ac	e5953000	 ldr         r3, [r5]
  002b0	e5dd1000	 ldrb        r1, [sp]
  002b4	e28d2008	 add         r2, sp, #8
  002b8	e5933050	 ldr         r3, [r3, #0x50]
  002bc	e1a00005	 mov         r0, r5
  002c0	e1a0e00f	 mov         lr, pc
  002c4	e12fff13	 bx          r3
  002c8	e3500000	 cmp         r0, #0
  002cc	0a000012	 beq         |$LN72@HubStatusC|

; 1201 :                     fPoll = FALSE;
; 1202 :                 }
; 1203 :                 else if ( hubStatus2.change.port.ConnectStatusChange ) {

  002d0	e1dd30ba	 ldrh        r3, [sp, #0xA]
  002d4	e3130001	 tst         r3, #1
  002d8	0a000009	 beq         |$LN4@HubStatusC|

; 1204 :                     // ack the status change and wait again
; 1205 :                     SetOrClearFeature( port, USB_REQUEST_CLEAR_FEATURE,
; 1206 :                                        USB_HUB_FEATURE_C_PORT_CONNECTION );

  002dc	e5952000	 ldr         r2, [r5]
  002e0	e5dd1000	 ldrb        r1, [sp]
  002e4	e3a03010	 mov         r3, #0x10
  002e8	e5924048	 ldr         r4, [r2, #0x48]
  002ec	e3a02001	 mov         r2, #1
  002f0	e1a00005	 mov         r0, r5
  002f4	e1a0e00f	 mov         lr, pc
  002f8	e12fff14	 bx          r4

; 1207 :                 }
; 1208 :                 else {

  002fc	e1dd30b4	 ldrh        r3, [sp, #4]
  00300	ea000002	 b           |$LN3@HubStatusC|
  00304		 |$LN4@HubStatusC|

; 1209 :                     // ah, stability.
; 1210 :                     hubStatus.status.word = hubStatus2.status.word;

  00304	e1dd30b8	 ldrh        r3, [sp, #8]

; 1211 :                     fPoll = FALSE;

  00308	e3a06000	 mov         r6, #0
  0030c	e1cd30b4	 strh        r3, [sp, #4]
  00310		 |$LN3@HubStatusC|

; 1194 : 
; 1195 :             while (fPoll) {

  00310	e3560000	 cmp         r6, #0
  00314	1affffe2	 bne         |$LL8@HubStatusC|
  00318	ea000002	 b           |$LN70@HubStatusC|
  0031c		 |$LN72@HubStatusC|

; 1199 :                     // failed to get status; probably power-cycle or upper-level detach
; 1200 :                     hubStatus.status.port.PortConnected = FALSE;

  0031c	e1dd30b4	 ldrh        r3, [sp, #4]
  00320	e0033007	 and         r3, r3, r7
  00324	e1cd30b4	 strh        r3, [sp, #4]
  00328		 |$LN70@HubStatusC|

; 1212 :                 }
; 1213 :             }
; 1214 : 
; 1215 :             //Do not Reset and Enable the port if there is no device connected.
; 1216 :             if(!hubStatus.status.port.PortConnected) continue;

  00328	e3130001	 tst         r3, #1
  0032c	0a000055	 beq         |$LN56@HubStatusC|

; 1217 : 
; 1218 :             // We have to reset port and get speed infomation.
; 1219 :             ResetAndEnablePort( port );

  00330	e5953000	 ldr         r3, [r5]
  00334	e5dd1000	 ldrb        r1, [sp]
  00338	e1a00005	 mov         r0, r5
  0033c	e5933054	 ldr         r3, [r3, #0x54]
  00340	e1a0e00f	 mov         lr, pc
  00344	e12fff13	 bx          r3

; 1220 : 			
; 1221 :             Sleep(20);

  00348	e3a00014	 mov         r0, #0x14
  0034c	eb000000	 bl          Sleep

; 1222 :             GetStatus(port , hubStatus);

  00350	e5953000	 ldr         r3, [r5]
  00354	e5dd1000	 ldrb        r1, [sp]
  00358	e28d2004	 add         r2, sp, #4
  0035c	e5933050	 ldr         r3, [r3, #0x50]
  00360	e1a00005	 mov         r0, r5
  00364	e1a0e00f	 mov         lr, pc
  00368	e12fff13	 bx          r3

; 1223 :             if ( hubStatus.status.port.PortConnected ) {

  0036c	e1dd20b4	 ldrh        r2, [sp, #4]
  00370	e3120001	 tst         r2, #1
  00374	0a000043	 beq         |$LN56@HubStatusC|

; 1224 :                 // device attach
; 1225 :                 DEBUGMSG( ZONE_ATTACH, (TEXT("CHub(%s tier %d)::HubStatusChangeThread - device attached on port %d\n"), GetDeviceType(), m_tierNumber, port ) );
; 1226 :                 AttachDevice( port,
; 1227 :                               hubStatus.status.port.DeviceIsLowSpeed,
; 1228 :                               m_fIsHighSpeed?hubStatus.status.port.DeviceIsHighSpeed:FALSE );

  00378	e5953048	 ldr         r3, [r5, #0x48]
  0037c	e5dd1000	 ldrb        r1, [sp]
  00380	e1a00005	 mov         r0, r5
  00384	e3530000	 cmp         r3, #0
  00388	11a03a82	 movne       r3, r2, lsl #21
  0038c	e1a02b02	 mov         r2, r2, lsl #22
  00390	11a03fa3	 movne       r3, r3, lsr #31
  00394	03a03000	 moveq       r3, #0
  00398	e1a02fa2	 mov         r2, r2, lsr #31
  0039c	eb000000	 bl          |?AttachDevice@CHub@@IAAXEHH@Z|

; 1229 :             }
; 1230 :         } // end of ConnectStatusChange processing
; 1231 :     }

  003a0	ea000038	 b           |$LN56@HubStatusC|
  003a4		 |$LN29@HubStatusC|

; 1065 :             if (!fSuccess && !m_fHubThreadClosing && (m_pCHcd->GetCapability() & HCD_SUSPEND_ON_REQUEST)!=0 ) { 

  003a4	e3500000	 cmp         r0, #0
  003a8	1a000036	 bne         |$LN56@HubStatusC|
  003ac		 |$LN69@HubStatusC|
  003ac	e3530000	 cmp         r3, #0
  003b0	1a000034	 bne         |$LN56@HubStatusC|
  003b4	e59500c8	 ldr         r0, [r5, #0xC8]
  003b8	e5903000	 ldr         r3, [r0]
  003bc	e593304c	 ldr         r3, [r3, #0x4C]
  003c0	e1a0e00f	 mov         lr, pc
  003c4	e12fff13	 bx          r3
  003c8	e3100004	 tst         r0, #4
  003cc	0a00002d	 beq         |$LN56@HubStatusC|

; 1066 :                 // We need check to find out this hub need put into suspend mode.
; 1067 :                 PREFAST_ASSERT(m_ppCDeviceOnPort!=NULL);
; 1068 :                 EnterCriticalSection( &m_csDeviceLock );

  003d0	e285000c	 add         r0, r5, #0xC
  003d4	eb000000	 bl          EnterCriticalSection

; 1069 :                 BOOL bDoSuspend = TRUE;
; 1070 :                 for ( UCHAR port2 = 1; port2 <= m_usbHubDescriptor.bNumberOfPorts; port2++ ) {

  003d8	e5d5306a	 ldrb        r3, [r5, #0x6A]
  003dc	e3a04001	 mov         r4, #1
  003e0	e3a01001	 mov         r1, #1
  003e4	e3530001	 cmp         r3, #1
  003e8	3a00000b	 bcc         |$LN25@HubStatusC|
  003ec	e59500b0	 ldr         r0, [r5, #0xB0]
  003f0		 |$LL27@HubStatusC|

; 1071 :                     if (m_ppCDeviceOnPort [port2 -1] != NULL) { // Can not.

  003f0	e0803101	 add         r3, r0, r1, lsl #2
  003f4	e5133004	 ldr         r3, [r3, #-4]
  003f8	e3530000	 cmp         r3, #0
  003fc	1a000005	 bne         |$LN65@HubStatusC|
  00400	e5d5206a	 ldrb        r2, [r5, #0x6A]
  00404	e2813001	 add         r3, r1, #1
  00408	e20310ff	 and         r1, r3, #0xFF
  0040c	e1510002	 cmp         r1, r2
  00410	9afffff6	 bls         |$LL27@HubStatusC|

; 1060 :         if (m_fHubThreadClosing || !fSuccess)

  00414	ea000000	 b           |$LN25@HubStatusC|
  00418		 |$LN65@HubStatusC|

; 1072 :                         bDoSuspend = FALSE;

  00418	e3a04000	 mov         r4, #0
  0041c		 |$LN25@HubStatusC|

; 1073 :                         break;
; 1074 :                     }
; 1075 :                 }
; 1076 :                 LeaveCriticalSection( &m_csDeviceLock );

  0041c	e285000c	 add         r0, r5, #0xC
  00420	eb000000	 bl          LeaveCriticalSection

; 1077 :                 if (bDoSuspend) {

  00424	e3540000	 cmp         r4, #0
  00428	0a000016	 beq         |$LN56@HubStatusC|

; 1078 :                     BOOL bSuspend =((m_pAttachedHub!=NULL)? 
; 1079 :                             (m_pAttachedHub->SuspendResumeOffStreamDevice(m_address, TRUE)==requestOK):
; 1080 :                             m_pCHcd->SuspendHC());

  0042c	e5953004	 ldr         r3, [r5, #4]
  00430	e1b00003	 movs        r0, r3
  00434	0a000008	 beq         |$LN44@HubStatusC|
  00438	e5903000	 ldr         r3, [r0]
  0043c	e5d51020	 ldrb        r1, [r5, #0x20]
  00440	e3a02001	 mov         r2, #1
  00444	e593303c	 ldr         r3, [r3, #0x3C]
  00448	e1a0e00f	 mov         lr, pc
  0044c	e12fff13	 bx          r3
  00450	e3500001	 cmp         r0, #1
  00454	0a000007	 beq         |$LN71@HubStatusC|
  00458	ea00000a	 b           |$LN56@HubStatusC|
  0045c		 |$LN44@HubStatusC|
  0045c	e59500c8	 ldr         r0, [r5, #0xC8]
  00460	e5903000	 ldr         r3, [r0]
  00464	e5933050	 ldr         r3, [r3, #0x50]
  00468	e1a0e00f	 mov         lr, pc
  0046c	e12fff13	 bx          r3
  00470	e3500000	 cmp         r0, #0

; 1081 :                     DEBUGMSG( ZONE_HUB, (TEXT("CHub(%s tier %d):: Suspend Device (%d) return %s!\n"), GetDeviceType(), m_tierNumber,m_address,bSuspend?TEXT("Success"):TEXT("FAIL")) );
; 1082 :                     if (bSuspend) {

  00474	0a000003	 beq         |$LN56@HubStatusC|
  00478		 |$LN71@HubStatusC|

; 1083 :                         m_fIsSuspend = TRUE;
; 1084 :                         ResetEvent(m_hHubSuspendBlockEvent);// Stop this thread.

  00478	e59500c4	 ldr         r0, [r5, #0xC4]
  0047c	e3a01002	 mov         r1, #2
  00480	e5858058	 str         r8, [r5, #0x58]
  00484	eb000000	 bl          EventModify
  00488		 |$LN56@HubStatusC|
  00488	e59530b8	 ldr         r3, [r5, #0xB8]
  0048c	e3530000	 cmp         r3, #0
  00490	0afffefd	 beq         |$LL34@HubStatusC|
  00494		 |$LN74@HubStatusC|

; 1232 :     DEBUGMSG( ZONE_HUB, (TEXT("-CHub(%s tier %d)::HubStatusChangeThread, THREAD EXITING, returning 0\n"), GetDeviceType(), m_tierNumber ) );
; 1233 :     return 0;

  00494	e3a00000	 mov         r0, #0

; 1234 : }

  00498	e28dd00c	 add         sp, sp, #0xC
  0049c	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  004a0	e12fff1e	 bx          lr
  004a4		 |$LN78@HubStatusC|
  004a4		 |$LN79@HubStatusC|
  004a4	00000000	 DCD         |??_C@_1IM@DCJHGIOD@?$AAC?$AAH?$AAu?$AAb?$AA?$CI?$AAt?$AAi?$AAe?$AAr?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?3?$AA?3?$AAH?$AAu?$AAb?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AAC?$AAh?$AAa?$AAn?$AAg?$AAe?$AAT?$AAh@|
  004a8		 |$M37946|

			 ENDP  ; |?HubStatusChangeThread@CHub@@AAAKXZ|, CHub::HubStatusChangeThread

	EXPORT	|?HubStatusChangeThreadStub@CHub@@KAKPAX@Z| ; CHub::HubStatusChangeThreadStub

  00000			 AREA	 |.pdata|, PDATA
|$T37960| DCD	|$LN5@HubStatusC@2|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HubStatusChangeThreadStub@CHub@@KAKPAX@Z| PROC ; CHub::HubStatusChangeThreadStub

; 1017 : {

  00000		 |$LN5@HubStatusC@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37957|

; 1018 :     return ((CHub*)context)->HubStatusChangeThread();

  00004	eb000000	 bl          |?HubStatusChangeThread@CHub@@AAAKXZ|

; 1019 : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M37958|

			 ENDP  ; |?HubStatusChangeThreadStub@CHub@@KAKPAX@Z|, CHub::HubStatusChangeThreadStub


  00000			 AREA	 |.pdata|, PDATA
|$T37972| DCD	|$LN10@EnterOpera@2|
	DCD	0x40003102
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?EnterOperationalState@CRootHub@@UAAHQAVCPipeAbs@@@Z| PROC ; CRootHub::EnterOperationalState

; 2814 : {

  00000		 |$LN10@EnterOpera@2|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M37969|
  00008	e1a04000	 mov         r4, r0

; 2815 :     DEBUGMSG( ZONE_HUB, (TEXT("+CRootHub::EnterOperationalState\n")) );
; 2816 : 
; 2817 :     BOOL fSuccess = FALSE;
; 2818 : 
; 2819 :     EnterCriticalSection( &m_csDeviceLock );

  0000c	e284000c	 add         r0, r4, #0xC
  00010	e3a05000	 mov         r5, #0
  00014	eb000000	 bl          EnterCriticalSection

; 2820 : 
; 2821 :     // don't need to allocate a Pipe array for Root Hubs
; 2822 :     DEBUGCHK( m_address == 0 &&
; 2823 :               m_maxNumPipes == 0 &&
; 2824 :               m_ppCPipe == NULL &&
; 2825 :               pEndpoint0Pipe == NULL &&
; 2826 :               m_deviceInfo.Descriptor.bDeviceClass == USB_DEVICE_CLASS_HUB &&
; 2827 :               m_deviceInfo.Descriptor.bNumConfigurations == 0 &&
; 2828 :               m_deviceInfo.lpActiveConfig == NULL &&
; 2829 :               m_deviceInfo.lpConfigs == NULL );
; 2830 : 
; 2831 :     DEBUGCHK( m_hHubStatusChangeEvent == NULL && m_hHubStatusChangeThread == NULL );
; 2832 : 
; 2833 :     // m_hHubStatusChangeEvent - Auto Reset, and Initial State = non-signaled
; 2834 :     m_hHubStatusChangeEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

  00018	e3a03000	 mov         r3, #0
  0001c	e3a02000	 mov         r2, #0
  00020	e3a01000	 mov         r1, #0
  00024	e3a00000	 mov         r0, #0
  00028	eb000000	 bl          CreateEventW
  0002c	e3500000	 cmp         r0, #0
  00030	e58400bc	 str         r0, [r4, #0xBC]

; 2835 : 
; 2836 :     if ( m_hHubStatusChangeEvent != NULL &&
; 2837 :          AllocateDeviceArray() ) {

  00034	0a00001a	 beq         |$LN1@EnterOpera@2|
  00038	e1a00004	 mov         r0, r4
  0003c	eb000000	 bl          |?AllocateDeviceArray@CHub@@IAAHXZ|
  00040	e3500000	 cmp         r0, #0
  00044	e3a06000	 mov         r6, #0
  00048	0a00000f	 beq         |$LN7@EnterOpera@2|

; 2838 : 
; 2839 :         m_hHubStatusChangeThread = CreateThread( 0, 0, HubStatusChangeThreadStub, this, 0, NULL );

  0004c	e59f206c	 ldr         r2, [pc, #0x6C]
  00050	e1a03004	 mov         r3, r4
  00054	e3a01000	 mov         r1, #0
  00058	e3a00000	 mov         r0, #0
  0005c	e58d6004	 str         r6, [sp, #4]
  00060	e58d6000	 str         r6, [sp]
  00064	eb000000	 bl          CreateThread
  00068	e3500000	 cmp         r0, #0
  0006c	e58400c0	 str         r0, [r4, #0xC0]

; 2840 :         if ( m_hHubStatusChangeThread != NULL ) {

  00070	0a000005	 beq         |$LN7@EnterOpera@2|

; 2841 :             CeSetThreadPriority( m_hHubStatusChangeThread, g_IstThreadPriority + RELATIVE_PRIO_STSCHG);

  00074	e59f3040	 ldr         r3, [pc, #0x40]
  00078	e5933000	 ldr         r3, [r3]
  0007c	e2831005	 add         r1, r3, #5
  00080	eb000000	 bl          CeSetThreadPriority

; 2842 :             fSuccess = TRUE;

  00084	e3a05001	 mov         r5, #1

; 2843 :         }
; 2844 :     }
; 2845 :     if ( !fSuccess ) {

  00088	ea000005	 b           |$LN1@EnterOpera@2|
  0008c		 |$LN7@EnterOpera@2|

; 2846 :         // m_ppCDeviceOnPort will be freed in ~CHub if needed
; 2847 : 
; 2848 :         if ( m_hHubStatusChangeEvent ) {

  0008c	e59430bc	 ldr         r3, [r4, #0xBC]
  00090	e3530000	 cmp         r3, #0
  00094	0a000002	 beq         |$LN1@EnterOpera@2|

; 2849 :             CloseHandle( m_hHubStatusChangeEvent );

  00098	e1a00003	 mov         r0, r3
  0009c	eb000000	 bl          CloseHandle

; 2850 :             m_hHubStatusChangeEvent = NULL;

  000a0	e58460bc	 str         r6, [r4, #0xBC]
  000a4		 |$LN1@EnterOpera@2|

; 2851 :         }
; 2852 :         DEBUGCHK( m_hHubStatusChangeThread == NULL );
; 2853 :     }
; 2854 : 
; 2855 :     LeaveCriticalSection( &m_csDeviceLock );

  000a4	e284000c	 add         r0, r4, #0xC
  000a8	eb000000	 bl          LeaveCriticalSection

; 2856 : 
; 2857 :     DEBUGMSG( ZONE_HUB, (TEXT("-CRootHub::EnterOperationalState, returning BOOL %d\n"), fSuccess) );
; 2858 :     return fSuccess;
; 2859 : }

  000ac	e1a00005	 mov         r0, r5
  000b0	e28dd008	 add         sp, sp, #8
  000b4	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000b8	e12fff1e	 bx          lr
  000bc		 |$LN11@EnterOpera@2|
  000bc		 |$LN12@EnterOpera@2|
  000bc	00000000	 DCD         |g_IstThreadPriority|
  000c0		 |$LN13@EnterOpera@2|
  000c0	00000000	 DCD         |?HubStatusChangeThreadStub@CHub@@KAKPAX@Z|
  000c4		 |$M37970|

			 ENDP  ; |?EnterOperationalState@CRootHub@@UAAHQAVCPipeAbs@@@Z|, CRootHub::EnterOperationalState


  00000			 AREA	 |.pdata|, PDATA
|$T37993| DCD	|$LN13@EnterOpera@3|
	DCD	0x40006d02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?EnterOperationalState@CExternalHub@@UAAHQAVCPipeAbs@@@Z| PROC ; CExternalHub::EnterOperationalState

; 3141 : {

  00000		 |$LN13@EnterOpera@3|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M37990|
  00008	e1a08001	 mov         r8, r1
  0000c	e1a06000	 mov         r6, r0

; 3142 :     DEBUGMSG( ZONE_HUB, (TEXT("+CExternalHub::EnterOperationalState\n")) );
; 3143 : 
; 3144 :     BOOL fSuccess = FALSE;
; 3145 : 
; 3146 :     EnterCriticalSection( &m_csDeviceLock );

  00010	e286000c	 add         r0, r6, #0xC
  00014	e3a07000	 mov         r7, #0
  00018	eb000000	 bl          EnterCriticalSection

; 3147 : 
; 3148 :     DEBUGCHK( m_address > 0 &&
; 3149 :               m_address <= USB_MAX_ADDRESS &&
; 3150 :               m_maxNumPipes == 0 && // not yet allocated
; 3151 :               m_ppCPipe == NULL && // not yet allocated
; 3152 :               pEndpoint0Pipe != NULL && // should be passed in non NULL by caller
; 3153 :               m_deviceInfo.Descriptor.bDeviceClass == USB_DEVICE_CLASS_HUB );
; 3154 : 
; 3155 :     DEBUGCHK( m_hHubStatusChangeEvent == NULL );
; 3156 :     // m_hHubStatusChangeEvent - Auto Reset, and Initial State = non-signaled
; 3157 :     m_hHubStatusChangeEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

  0001c	e3a03000	 mov         r3, #0
  00020	e3a02000	 mov         r2, #0
  00024	e3a01000	 mov         r1, #0
  00028	e3a00000	 mov         r0, #0
  0002c	eb000000	 bl          CreateEventW

; 3158 : 
; 3159 :     #ifdef DEBUG
; 3160 :     {
; 3161 : 
; 3162 : #ifndef USB_STRICT_ENFORCEMENT
; 3163 :         // The correct settings are listed in the 1.1 USB spec at section 11.15.1.
; 3164 :         // I have found at least one hub (builtin on the Clarion CDC) that does this wrong.
; 3165 :         if (!m_fIsHighSpeed)
; 3166 :             m_deviceInfo.lpActiveConfig->lpInterfaces[0].lpEndpoints[0].Descriptor.bInterval = 0xff;
; 3167 : #endif
; 3168 :         // check for status change endpoint descriptor
; 3169 :         const USB_ENDPOINT_DESCRIPTOR& rED = m_deviceInfo.lpActiveConfig->lpInterfaces[0].lpEndpoints[0].Descriptor;
; 3170 :         DEBUGCHK( rED.bDescriptorType == USB_ENDPOINT_DESCRIPTOR_TYPE &&
; 3171 :                   (rED.bEndpointAddress & 0xf) > 0 &&
; 3172 :                   (rED.bInterval == 0xff || m_fIsHighSpeed) &&
; 3173 :                   (rED.bmAttributes & USB_ENDPOINT_TYPE_MASK) == USB_ENDPOINT_TYPE_INTERRUPT );
; 3174 :     }
; 3175 :     #endif // DEBUG
; 3176 :     UCHAR uTTAddress=0;
; 3177 :     UCHAR uTTPort=0;
; 3178 :     GetUSB2TT(&uTTAddress, &uTTPort);

  00030	e5963000	 ldr         r3, [r6]
  00034	e1a04000	 mov         r4, r0
  00038	e3a09000	 mov         r9, #0
  0003c	e5933034	 ldr         r3, [r3, #0x34]
  00040	e3a05000	 mov         r5, #0
  00044	e28d200c	 add         r2, sp, #0xC
  00048	e28d100d	 add         r1, sp, #0xD
  0004c	e1a00006	 mov         r0, r6
  00050	e58640bc	 str         r4, [r6, #0xBC]
  00054	e5cd900d	 strb        r9, [sp, #0xD]
  00058	e5cd500c	 strb        r5, [sp, #0xC]
  0005c	e1a0e00f	 mov         lr, pc
  00060	e12fff13	 bx          r3

; 3179 :     CPipeAbs* pStatusChangePipe = CreateInterruptPipe ( &m_deviceInfo.lpActiveConfig->lpInterfaces[0].lpEndpoints[0].Descriptor,
; 3180 :                                                             m_fIsLowSpeed,m_fIsHighSpeed,m_address,
; 3181 :                                                             uTTAddress,uTTPort,
; 3182 :                                                             m_pCHcd);

  00064	e5963040	 ldr         r3, [r6, #0x40]
  00068	e59640c8	 ldr         r4, [r6, #0xC8]
  0006c	e5dd500c	 ldrb        r5, [sp, #0xC]
  00070	e5932018	 ldr         r2, [r3, #0x18]
  00074	e5dde00d	 ldrb        lr, [sp, #0xD]
  00078	e5d63020	 ldrb        r3, [r6, #0x20]
  0007c	e5920014	 ldr         r0, [r2, #0x14]
  00080	e5962048	 ldr         r2, [r6, #0x48]
  00084	e5961044	 ldr         r1, [r6, #0x44]
  00088	e2800004	 add         r0, r0, #4
  0008c	e58d4008	 str         r4, [sp, #8]
  00090	e58d5004	 str         r5, [sp, #4]
  00094	e58de000	 str         lr, [sp]
  00098	eb000000	 bl          |?CreateInterruptPipe@@YAPAVCPipeAbs@@QBU_USB_ENDPOINT_DESCRIPTOR@@HHEEEQAVCHcd@@@Z|
  0009c	e1b04000	 movs        r4, r0
  000a0	e3a05000	 mov         r5, #0

; 3183 : 
; 3184 :     // be sure to call OpenPipe last
; 3185 :     if ( pStatusChangePipe != NULL &&
; 3186 :          m_hHubStatusChangeEvent != NULL &&
; 3187 :          AllocatePipeArray() &&
; 3188 :          AllocateDeviceArray() &&
; 3189 :          requestOK == pStatusChangePipe->OpenPipe() ) {

  000a4	0a000030	 beq         |$LN8@EnterOpera@3|
  000a8	e59630bc	 ldr         r3, [r6, #0xBC]
  000ac	e3530000	 cmp         r3, #0
  000b0	0a000027	 beq         |$LN3@EnterOpera@3|
  000b4	e1a00006	 mov         r0, r6
  000b8	eb000000	 bl          |?AllocatePipeArray@CDevice@@IAAHXZ|
  000bc	e3500000	 cmp         r0, #0
  000c0	0a000023	 beq         |$LN3@EnterOpera@3|
  000c4	e1a00006	 mov         r0, r6
  000c8	eb000000	 bl          |?AllocateDeviceArray@CHub@@IAAHXZ|
  000cc	e3500000	 cmp         r0, #0
  000d0	0a00001f	 beq         |$LN3@EnterOpera@3|
  000d4	e5943000	 ldr         r3, [r4]
  000d8	e1a00004	 mov         r0, r4
  000dc	e5933004	 ldr         r3, [r3, #4]
  000e0	e1a0e00f	 mov         lr, pc
  000e4	e12fff13	 bx          r3
  000e8	e3500001	 cmp         r0, #1
  000ec	1a000018	 bne         |$LN3@EnterOpera@3|

; 3190 : 
; 3191 :         // Thread will use the pipes, so put them into our array
; 3192 :         DEBUGCHK( m_maxNumPipes == 2 &&
; 3193 :                   m_ppCPipe != NULL );
; 3194 :         m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ] = pEndpoint0Pipe;

  000f0	e596105c	 ldr         r1, [r6, #0x5C]

; 3195 :         m_ppCPipe[ STATUS_CHANGE_INTERRUPT_PIPE ] = pStatusChangePipe;
; 3196 :         m_hHubStatusChangeThread = CreateThread( 0, 0, HubStatusChangeThreadStub, this, 0, NULL );

  000f4	e59f20b4	 ldr         r2, [pc, #0xB4]
  000f8	e1a03006	 mov         r3, r6
  000fc	e5818000	 str         r8, [r1]
  00100	e596e05c	 ldr         lr, [r6, #0x5C]
  00104	e3a01000	 mov         r1, #0
  00108	e3a00000	 mov         r0, #0
  0010c	e58e4004	 str         r4, [lr, #4]
  00110	e58d5004	 str         r5, [sp, #4]
  00114	e58d5000	 str         r5, [sp]
  00118	eb000000	 bl          CreateThread
  0011c	e3500000	 cmp         r0, #0
  00120	e58600c0	 str         r0, [r6, #0xC0]

; 3197 :         if ( m_hHubStatusChangeThread != NULL ) {

  00124	0a000005	 beq         |$LN4@EnterOpera@3|

; 3198 :             CeSetThreadPriority( m_hHubStatusChangeThread, g_IstThreadPriority + RELATIVE_PRIO_STSCHG);

  00128	e59f307c	 ldr         r3, [pc, #0x7C]
  0012c	e5933000	 ldr         r3, [r3]
  00130	e2831005	 add         r1, r3, #5
  00134	eb000000	 bl          CeSetThreadPriority

; 3199 :             fSuccess = TRUE;

  00138	e3a07001	 mov         r7, #1

; 3200 :         } else {

  0013c	ea000014	 b           |$LN1@EnterOpera@3|
  00140		 |$LN4@EnterOpera@3|

; 3201 :             pStatusChangePipe->ClosePipe();

  00140	e5943000	 ldr         r3, [r4]
  00144	e1a00004	 mov         r0, r4
  00148	e5933008	 ldr         r3, [r3, #8]
  0014c	e1a0e00f	 mov         lr, pc
  00150	e12fff13	 bx          r3
  00154		 |$LN3@EnterOpera@3|

; 3202 :         }
; 3203 :     }
; 3204 :     if ( !fSuccess ) {
; 3205 :         // pStatusChangePipe would have been closed above in case of failure
; 3206 :         delete pStatusChangePipe;

  00154	e5943000	 ldr         r3, [r4]
  00158	e3a01001	 mov         r1, #1
  0015c	e1a00004	 mov         r0, r4
  00160	e5933000	 ldr         r3, [r3]
  00164	e1a0e00f	 mov         lr, pc
  00168	e12fff13	 bx          r3
  0016c		 |$LN8@EnterOpera@3|

; 3207 : 
; 3208 :         // caller will take care of closing the endpoint 0 pipe. We NULL out
; 3209 :         // the entries in the m_ppCPipe array because otherwise both our
; 3210 :         // ~CDevice destructor and the caller would try to free the pipe.
; 3211 :         m_ppCPipe[ ENDPOINT0_CONTROL_PIPE ] = NULL;

  0016c	e596305c	 ldr         r3, [r6, #0x5C]
  00170	e5835000	 str         r5, [r3]

; 3212 :         m_ppCPipe[ STATUS_CHANGE_INTERRUPT_PIPE ] = NULL;

  00174	e596305c	 ldr         r3, [r6, #0x5C]
  00178	e5835004	 str         r5, [r3, #4]

; 3213 :         // m_ppCPipe[] will be freed in ~CDevice
; 3214 : 
; 3215 :         // m_ppCDeviceOnPort [] will be freed in ~CHub
; 3216 : 
; 3217 :         if ( m_hHubStatusChangeEvent ) {

  0017c	e59630bc	 ldr         r3, [r6, #0xBC]
  00180	e3530000	 cmp         r3, #0
  00184	0a000002	 beq         |$LN1@EnterOpera@3|

; 3218 :             CloseHandle( m_hHubStatusChangeEvent );

  00188	e1a00003	 mov         r0, r3
  0018c	eb000000	 bl          CloseHandle

; 3219 :             m_hHubStatusChangeEvent = NULL;

  00190	e58650bc	 str         r5, [r6, #0xBC]
  00194		 |$LN1@EnterOpera@3|

; 3220 :         }
; 3221 : 
; 3222 :         DEBUGCHK( m_hHubStatusChangeThread == NULL );
; 3223 :     }
; 3224 : 
; 3225 :     LeaveCriticalSection( &m_csDeviceLock );

  00194	e286000c	 add         r0, r6, #0xC
  00198	eb000000	 bl          LeaveCriticalSection

; 3226 : 
; 3227 :     DEBUGMSG( ZONE_HUB, (TEXT("-CExternalHub::EnterOperationalState, returning BOOL %d\n"), fSuccess) );
; 3228 :     return fSuccess;
; 3229 : }

  0019c	e1a00007	 mov         r0, r7
  001a0	e28dd010	 add         sp, sp, #0x10
  001a4	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  001a8	e12fff1e	 bx          lr
  001ac		 |$LN14@EnterOpera@3|
  001ac		 |$LN15@EnterOpera@3|
  001ac	00000000	 DCD         |g_IstThreadPriority|
  001b0		 |$LN16@EnterOpera@3|
  001b0	00000000	 DCD         |?HubStatusChangeThreadStub@CHub@@KAKPAX@Z|
  001b4		 |$M37991|

			 ENDP  ; |?EnterOperationalState@CExternalHub@@UAAHQAVCPipeAbs@@@Z|, CExternalHub::EnterOperationalState

	END
