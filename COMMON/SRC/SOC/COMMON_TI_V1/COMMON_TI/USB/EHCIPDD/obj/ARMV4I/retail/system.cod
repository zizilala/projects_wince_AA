; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\USB\EHCIPDD\system.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1BE@EKANOLAD@?$AAD?$AAV?$AAF?$AAS?$AAO?$AAr?$AAd?$AAe?$AAr?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BM@KPOFJNCO@?$AAP?$AAo?$AAr?$AAt?$AA3?$AAP?$AAw?$AAr?$AAL?$AAe?$AAv?$AAe?$AAl?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BM@MKICKGGI@?$AAP?$AAo?$AAr?$AAt?$AA2?$AAP?$AAw?$AAr?$AAL?$AAe?$AAv?$AAe?$AAl?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BM@GFCLOLKC@?$AAP?$AAo?$AAr?$AAt?$AA1?$AAP?$AAw?$AAr?$AAL?$AAe?$AAv?$AAe?$AAl?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@LKINDMOC@?$AAP?$AAo?$AAr?$AAt?$AA3?$AAR?$AAs?$AAt?$AAG?$AAp?$AAi?$AAo?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@FFNPIKAD@?$AAP?$AAo?$AAr?$AAt?$AA2?$AAR?$AAs?$AAt?$AAG?$AAp?$AAi?$AAo?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@LPFJFHGB@?$AAP?$AAo?$AAr?$AAt?$AA1?$AAR?$AAs?$AAt?$AAG?$AAp?$AAi?$AAo?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@MLLMDDHK@?$AAP?$AAo?$AAr?$AAt?$AA3?$AAP?$AAw?$AAr?$AAG?$AAp?$AAi?$AAo?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@CEOOIFJL@?$AAP?$AAo?$AAr?$AAt?$AA2?$AAP?$AAw?$AAr?$AAG?$AAp?$AAi?$AAo?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@MOGIFIPJ@?$AAP?$AAo?$AAr?$AAt?$AA1?$AAP?$AAw?$AAr?$AAG?$AAp?$AAi?$AAo?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BE@BAADJND@?$AAP?$AAo?$AAr?$AAt?$AA3?$AAM?$AAo?$AAd?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BE@JKKFHFLM@?$AAP?$AAo?$AAr?$AAt?$AA2?$AAM?$AAo?$AAd?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BE@ONDLKHEM@?$AAP?$AAo?$AAr?$AAt?$AA1?$AAM?$AAo?$AAd?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CC@BCHLEGNP@?$AAB?$AAu?$AAs?$AAS?$AAu?$AAs?$AAp?$AAe?$AAn?$AAd?$AAR?$AAe?$AAs?$AAu?$AAm?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1O@LBBNFMDB@?$AAM?$AAe?$AAm?$AAL?$AAe?$AAn?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@INLDIDEN@?$AAM?$AAe?$AAm?$AAB?$AAa?$AAs?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|g_fOmapEhciSuspended| [ DATA ]

  00000			 AREA	 |.bss|, NOINIT
|g_fOmapEhciSuspended| % 0x4

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@EKANOLAD@?$AAD?$AAV?$AAF?$AAS?$AAO?$AAr?$AAd?$AAe?$AAr?$AA?$AA@| DCB "D"
	DCB	0x0, "V", 0x0, "F", 0x0, "S", 0x0, "O", 0x0, "r", 0x0, "d"
	DCB	0x0, "e", 0x0, "r", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BM@KPOFJNCO@?$AAP?$AAo?$AAr?$AAt?$AA3?$AAP?$AAw?$AAr?$AAL?$AAe?$AAv?$AAe?$AAl?$AA?$AA@| DCB "P"
	DCB	0x0, "o", 0x0, "r", 0x0, "t", 0x0, "3", 0x0, "P", 0x0, "w"
	DCB	0x0, "r", 0x0, "L", 0x0, "e", 0x0, "v", 0x0, "e", 0x0, "l"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BM@MKICKGGI@?$AAP?$AAo?$AAr?$AAt?$AA2?$AAP?$AAw?$AAr?$AAL?$AAe?$AAv?$AAe?$AAl?$AA?$AA@| DCB "P"
	DCB	0x0, "o", 0x0, "r", 0x0, "t", 0x0, "2", 0x0, "P", 0x0, "w"
	DCB	0x0, "r", 0x0, "L", 0x0, "e", 0x0, "v", 0x0, "e", 0x0, "l"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BM@GFCLOLKC@?$AAP?$AAo?$AAr?$AAt?$AA1?$AAP?$AAw?$AAr?$AAL?$AAe?$AAv?$AAe?$AAl?$AA?$AA@| DCB "P"
	DCB	0x0, "o", 0x0, "r", 0x0, "t", 0x0, "1", 0x0, "P", 0x0, "w"
	DCB	0x0, "r", 0x0, "L", 0x0, "e", 0x0, "v", 0x0, "e", 0x0, "l"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@LKINDMOC@?$AAP?$AAo?$AAr?$AAt?$AA3?$AAR?$AAs?$AAt?$AAG?$AAp?$AAi?$AAo?$AA?$AA@| DCB "P"
	DCB	0x0, "o", 0x0, "r", 0x0, "t", 0x0, "3", 0x0, "R", 0x0, "s"
	DCB	0x0, "t", 0x0, "G", 0x0, "p", 0x0, "i", 0x0, "o", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@FFNPIKAD@?$AAP?$AAo?$AAr?$AAt?$AA2?$AAR?$AAs?$AAt?$AAG?$AAp?$AAi?$AAo?$AA?$AA@| DCB "P"
	DCB	0x0, "o", 0x0, "r", 0x0, "t", 0x0, "2", 0x0, "R", 0x0, "s"
	DCB	0x0, "t", 0x0, "G", 0x0, "p", 0x0, "i", 0x0, "o", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@LPFJFHGB@?$AAP?$AAo?$AAr?$AAt?$AA1?$AAR?$AAs?$AAt?$AAG?$AAp?$AAi?$AAo?$AA?$AA@| DCB "P"
	DCB	0x0, "o", 0x0, "r", 0x0, "t", 0x0, "1", 0x0, "R", 0x0, "s"
	DCB	0x0, "t", 0x0, "G", 0x0, "p", 0x0, "i", 0x0, "o", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@MLLMDDHK@?$AAP?$AAo?$AAr?$AAt?$AA3?$AAP?$AAw?$AAr?$AAG?$AAp?$AAi?$AAo?$AA?$AA@| DCB "P"
	DCB	0x0, "o", 0x0, "r", 0x0, "t", 0x0, "3", 0x0, "P", 0x0, "w"
	DCB	0x0, "r", 0x0, "G", 0x0, "p", 0x0, "i", 0x0, "o", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@CEOOIFJL@?$AAP?$AAo?$AAr?$AAt?$AA2?$AAP?$AAw?$AAr?$AAG?$AAp?$AAi?$AAo?$AA?$AA@| DCB "P"
	DCB	0x0, "o", 0x0, "r", 0x0, "t", 0x0, "2", 0x0, "P", 0x0, "w"
	DCB	0x0, "r", 0x0, "G", 0x0, "p", 0x0, "i", 0x0, "o", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@MOGIFIPJ@?$AAP?$AAo?$AAr?$AAt?$AA1?$AAP?$AAw?$AAr?$AAG?$AAp?$AAi?$AAo?$AA?$AA@| DCB "P"
	DCB	0x0, "o", 0x0, "r", 0x0, "t", 0x0, "1", 0x0, "P", 0x0, "w"
	DCB	0x0, "r", 0x0, "G", 0x0, "p", 0x0, "i", 0x0, "o", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@BAADJND@?$AAP?$AAo?$AAr?$AAt?$AA3?$AAM?$AAo?$AAd?$AAe?$AA?$AA@| DCB "P"
	DCB	0x0, "o", 0x0, "r", 0x0, "t", 0x0, "3", 0x0, "M", 0x0, "o"
	DCB	0x0, "d", 0x0, "e", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@JKKFHFLM@?$AAP?$AAo?$AAr?$AAt?$AA2?$AAM?$AAo?$AAd?$AAe?$AA?$AA@| DCB "P"
	DCB	0x0, "o", 0x0, "r", 0x0, "t", 0x0, "2", 0x0, "M", 0x0, "o"
	DCB	0x0, "d", 0x0, "e", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@ONDLKHEM@?$AAP?$AAo?$AAr?$AAt?$AA1?$AAM?$AAo?$AAd?$AAe?$AA?$AA@| DCB "P"
	DCB	0x0, "o", 0x0, "r", 0x0, "t", 0x0, "1", 0x0, "M", 0x0, "o"
	DCB	0x0, "d", 0x0, "e", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@BCHLEGNP@?$AAB?$AAu?$AAs?$AAS?$AAu?$AAs?$AAp?$AAe?$AAn?$AAd?$AAR?$AAe?$AAs?$AAu?$AAm?$AAe?$AA?$AA@| DCB "B"
	DCB	0x0, "u", 0x0, "s", 0x0, "S", 0x0, "u", 0x0, "s", 0x0, "p"
	DCB	0x0, "e", 0x0, "n", 0x0, "d", 0x0, "R", 0x0, "e", 0x0, "s"
	DCB	0x0, "u", 0x0, "m", 0x0, "e", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1O@LBBNFMDB@?$AAM?$AAe?$AAm?$AAL?$AAe?$AAn?$AA?$AA@| DCB "M", 0x0, "e"
	DCB	0x0, "m", 0x0, "L", 0x0, "e", 0x0, "n", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@INLDIDEN@?$AAM?$AAe?$AAm?$AAB?$AAa?$AAs?$AAe?$AA?$AA@| DCB "M", 0x0
	DCB	"e", 0x0, "m", 0x0, "B", 0x0, "a", 0x0, "s", 0x0, "e", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
|g_deviceRegParams| DCD |??_C@_1BA@INLDIDEN@?$AAM?$AAe?$AAm?$AAB?$AAa?$AAs?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x1
	DCD	0x0
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1O@LBBNFMDB@?$AAM?$AAe?$AAm?$AAL?$AAe?$AAn?$AA?$AA@|
	DCD	0x1
	DCD	0x1
	DCD	0x4
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1CC@BCHLEGNP@?$AAB?$AAu?$AAs?$AAS?$AAu?$AAs?$AAp?$AAe?$AAn?$AAd?$AAR?$AAe?$AAs?$AAu?$AAm?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x8
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BE@ONDLKHEM@?$AAP?$AAo?$AAr?$AAt?$AA1?$AAM?$AAo?$AAd?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x260
	DCD	0x4
	DCD	0x1
	DCD	|??_C@_1BE@JKKFHFLM@?$AAP?$AAo?$AAr?$AAt?$AA2?$AAM?$AAo?$AAd?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x264
	DCD	0x4
	DCD	0x1
	DCD	|??_C@_1BE@BAADJND@?$AAP?$AAo?$AAr?$AAt?$AA3?$AAM?$AAo?$AAd?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x268
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BK@MOGIFIPJ@?$AAP?$AAo?$AAr?$AAt?$AA1?$AAP?$AAw?$AAr?$AAG?$AAp?$AAi?$AAo?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x26c
	DCD	0x4
	DCD	0xffffffff
	DCD	|??_C@_1BK@CEOOIFJL@?$AAP?$AAo?$AAr?$AAt?$AA2?$AAP?$AAw?$AAr?$AAG?$AAp?$AAi?$AAo?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x270
	DCD	0x4
	DCD	0xffffffff
	DCD	|??_C@_1BK@MLLMDDHK@?$AAP?$AAo?$AAr?$AAt?$AA3?$AAP?$AAw?$AAr?$AAG?$AAp?$AAi?$AAo?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x274
	DCD	0x4
	DCD	0xffffffff
	DCD	|??_C@_1BK@LPFJFHGB@?$AAP?$AAo?$AAr?$AAt?$AA1?$AAR?$AAs?$AAt?$AAG?$AAp?$AAi?$AAo?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x278
	DCD	0x4
	DCD	0xffffffff
	DCD	|??_C@_1BK@FFNPIKAD@?$AAP?$AAo?$AAr?$AAt?$AA2?$AAR?$AAs?$AAt?$AAG?$AAp?$AAi?$AAo?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x27c
	DCD	0x4
	DCD	0xffffffff
	DCD	|??_C@_1BK@LKINDMOC@?$AAP?$AAo?$AAr?$AAt?$AA3?$AAR?$AAs?$AAt?$AAG?$AAp?$AAi?$AAo?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x280
	DCD	0x4
	DCD	0xffffffff
	DCD	|??_C@_1BM@GFCLOLKC@?$AAP?$AAo?$AAr?$AAt?$AA1?$AAP?$AAw?$AAr?$AAL?$AAe?$AAv?$AAe?$AAl?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x284
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BM@MKICKGGI@?$AAP?$AAo?$AAr?$AAt?$AA2?$AAP?$AAw?$AAr?$AAL?$AAe?$AAv?$AAe?$AAl?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x288
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BM@KPOFJNCO@?$AAP?$AAo?$AAr?$AAt?$AA3?$AAP?$AAw?$AAr?$AAL?$AAe?$AAv?$AAe?$AAl?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x28c
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BE@EKANOLAD@?$AAD?$AAV?$AAF?$AAS?$AAO?$AAr?$AAd?$AAe?$AAr?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x2c4
	DCD	0x4
	DCD	0x96
	EXPORT	|DelayMilliSeconds|
	IMPORT	|Sleep|
	IMPORT	|GetTickCount|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\usb\ehcipdd\system.c

  00000			 AREA	 |.pdata|, PDATA
|$T45534| DCD	|$LN10@DelayMilli|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DelayMilliSeconds| PROC

; 164  : {

  00000		 |$LN10@DelayMilli|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45531|
  00004	e3510000	 cmp         r1, #0
  00008	e1a04000	 mov         r4, r0

; 165  :     if (bInPowerHandler)

  0000c	0a000008	 beq         |$LN4@DelayMilli|

; 166  :     {
; 167  :         DWORD StartingTickCount;
; 168  : 
; 169  :         StartingTickCount = GetTickCount();

  00010	eb000000	 bl          GetTickCount
  00014	e1a05000	 mov         r5, r0
  00018	e2844001	 add         r4, r4, #1
  0001c		 |$LL3@DelayMilli|

; 170  :         while (GetTickCount() - StartingTickCount < dwMilliSeconds + 1)

  0001c	eb000000	 bl          GetTickCount
  00020	e0403005	 sub         r3, r0, r5
  00024	e1530004	 cmp         r3, r4
  00028	3afffffb	 bcc         |$LL3@DelayMilli|

; 177  :     }
; 178  : }

  0002c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00030	e12fff1e	 bx          lr
  00034		 |$LN4@DelayMilli|

; 171  :         {
; 172  :         }
; 173  :     }
; 174  :     else
; 175  :     {
; 176  :         Sleep(dwMilliSeconds);

  00034	e1a00004	 mov         r0, r4
  00038	eb000000	 bl          Sleep

; 177  :     }
; 178  : }

  0003c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M45532|

			 ENDP  ; |DelayMilliSeconds|

	EXPORT	|EhciWriteReg|

  00000			 AREA	 |.pdata|, PDATA
|$T45544| DCD	|$LN5@EhciWriteR|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |EhciWriteReg| PROC

; 181  : {

  00000		 |$LN5@EhciWriteR|
  00000		 |$M45541|

; 182  :     volatile DWORD * pEhciReg = (volatile DWORD *)(EhciRegBase + Offset);
; 183  : 
; 184  :     *pEhciReg = Data;

  00000	e7802001	 str         r2, [r0, +r1]

; 185  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M45542|

			 ENDP  ; |EhciWriteReg|

	EXPORT	|UlpiWriteReg|

  00000			 AREA	 |.pdata|, PDATA
|$T45558| DCD	|$LN9@UlpiWriteR|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UlpiWriteReg| PROC

; 188  : {

  00000		 |$LN9@UlpiWriteR|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45555|
  00004	e3e0ec7f	 mvn         lr, #0x7F, 24

; 189  :     volatile DWORD * pEhciUlpiAccess = (volatile DWORD *)(EhciRegBase + 0xa4);
; 190  :     DWORD ReadData;
; 191  : 
; 192  :     *pEhciUlpiAccess = START_WRITE_ULPI_DATA(Port, Register, Data);

  00008	e22ee07f	 eor         lr, lr, #0x7F
  0000c	e1822401	 orr         r2, r2, r1, lsl #8
  00010	e182200e	 orr         r2, r2, lr
  00014	e1833802	 orr         r3, r3, r2, lsl #16
  00018	e58030a4	 str         r3, [r0, #0xA4]
  0001c		 |$LL3@UlpiWriteR|

; 193  : 
; 194  :     // wait for register access done
; 195  :     do
; 196  :     {
; 197  :         ReadData = *pEhciUlpiAccess;

  0001c	e59030a4	 ldr         r3, [r0, #0xA4]

; 198  :         DEBUGMSG(ZONE_INFO, (TEXT("EHCI ULPI access port %d, register 0x%x = 0x%x\r\n"), Port, Register, ReadData));
; 199  :     }
; 200  :     while (ReadData & 0x80000000);

  00020	e3130102	 tst         r3, #2, 2
  00024	1afffffc	 bne         |$LL3@UlpiWriteR|

; 201  : }

  00028	e49de004	 ldr         lr, [sp], #4
  0002c	e12fff1e	 bx          lr
  00030		 |$M45556|

			 ENDP  ; |UlpiWriteReg|

	EXPORT	|UlpiReadReg|

  00000			 AREA	 |.pdata|, PDATA
|$T45572| DCD	|$LN9@UlpiReadRe|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UlpiReadReg| PROC

; 204  : {

  00000		 |$LN9@UlpiReadRe|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45569|
  00004	e3e0ec7f	 mvn         lr, #0x7F, 24

; 205  :     volatile DWORD * pEhciUlpiAccess = (volatile DWORD *)(EhciRegBase + 0xa4);
; 206  :     DWORD ReadData;
; 207  : 
; 208  :     *pEhciUlpiAccess = START_READ_ULPI_DATA(Port, Register);

  00008	e22ee03f	 eor         lr, lr, #0x3F
  0000c	e1822401	 orr         r2, r2, r1, lsl #8
  00010	e182200e	 orr         r2, r2, lr
  00014	e1a02802	 mov         r2, r2, lsl #16
  00018	e58020a4	 str         r2, [r0, #0xA4]
  0001c		 |$LL3@UlpiReadRe|

; 209  : 
; 210  :     // wait for register access done
; 211  :     do
; 212  :     {
; 213  :         ReadData = *pEhciUlpiAccess;

  0001c	e59020a4	 ldr         r2, [r0, #0xA4]

; 214  :         DEBUGMSG(ZONE_INFO, (TEXT("EHCI ULPI access port %d, register 0x%x = 0x%x\r\n"), Port, Register, ReadData));
; 215  :     }
; 216  :     while (ReadData & 0x80000000);

  00020	e3120102	 tst         r2, #2, 2
  00024	1afffffc	 bne         |$LL3@UlpiReadRe|

; 217  : 
; 218  :     *pData = (BYTE)ReadData;

  00028	e5c32000	 strb        r2, [r3]

; 219  : }

  0002c	e49de004	 ldr         lr, [sp], #4
  00030	e12fff1e	 bx          lr
  00034		 |$M45570|

			 ENDP  ; |UlpiReadReg|

	EXPORT	|PHY_AssertReset|
	IMPORT	|GPIOClrBit|

  00000			 AREA	 |.pdata|, PDATA
|$T45583| DCD	|$LN8@PHY_Assert|
	DCD	0x40001501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PHY_AssertReset| PROC

; 222  : {

  00000		 |$LN8@PHY_Assert|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45580|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 223  : 	if (pPddObject->Port1RstGpio != -1)

  0000c	e5941278	 ldr         r1, [r4, #0x278]
  00010	e3710001	 cmn         r1, #1

; 224  : 	{
; 225  : 		GPIOClrBit(pPddObject->hGpio, pPddObject->Port1RstGpio);

  00014	15940290	 ldrne       r0, [r4, #0x290]
  00018	1b000000	 blne        GPIOClrBit

; 226  : 	}
; 227  : 
; 228  : 	if (pPddObject->Port2RstGpio != -1)

  0001c	e594127c	 ldr         r1, [r4, #0x27C]
  00020	e3710001	 cmn         r1, #1

; 229  : 	{
; 230  : 		GPIOClrBit(pPddObject->hGpio, pPddObject->Port2RstGpio);

  00024	15940290	 ldrne       r0, [r4, #0x290]
  00028	1b000000	 blne        GPIOClrBit

; 231  : 	}
; 232  : 
; 233  : 	if (pPddObject->Port3RstGpio != -1)

  0002c	e5941280	 ldr         r1, [r4, #0x280]
  00030	e3710001	 cmn         r1, #1

; 234  : 	{
; 235  : 		GPIOClrBit(pPddObject->hGpio, pPddObject->Port3RstGpio);

  00034	15940290	 ldrne       r0, [r4, #0x290]
  00038	1b000000	 blne        GPIOClrBit

; 236  : 	}
; 237  : 
; 238  :     DelayMilliSeconds(10, bCalledFromPowerUp);

  0003c	e1a01005	 mov         r1, r5
  00040	e3a0000a	 mov         r0, #0xA
  00044	eb000000	 bl          DelayMilliSeconds

; 239  : 
; 240  :     return TRUE;

  00048	e3a00001	 mov         r0, #1

; 241  : }

  0004c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$M45581|

			 ENDP  ; |PHY_AssertReset|

	EXPORT	|PHY_DeassertReset|
	IMPORT	|GPIOSetBit|

  00000			 AREA	 |.pdata|, PDATA
|$T45593| DCD	|$LN8@PHY_Deasse|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PHY_DeassertReset| PROC

; 244  : {

  00000		 |$LN8@PHY_Deasse|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M45590|
  00004	e1a04000	 mov         r4, r0

; 245  : 	if (pPddObject->Port1RstGpio != -1)

  00008	e5941278	 ldr         r1, [r4, #0x278]
  0000c	e3710001	 cmn         r1, #1

; 246  : 	{
; 247  : 		GPIOSetBit(pPddObject->hGpio, pPddObject->Port1RstGpio);

  00010	15940290	 ldrne       r0, [r4, #0x290]
  00014	1b000000	 blne        GPIOSetBit

; 248  : 	}
; 249  : 
; 250  : 	if (pPddObject->Port2RstGpio != -1)

  00018	e594127c	 ldr         r1, [r4, #0x27C]
  0001c	e3710001	 cmn         r1, #1

; 251  : 	{
; 252  : 		GPIOSetBit(pPddObject->hGpio, pPddObject->Port2RstGpio);

  00020	15940290	 ldrne       r0, [r4, #0x290]
  00024	1b000000	 blne        GPIOSetBit

; 253  : 	}
; 254  : 
; 255  : 	if (pPddObject->Port3RstGpio != -1)

  00028	e5941280	 ldr         r1, [r4, #0x280]
  0002c	e3710001	 cmn         r1, #1

; 256  : 	{
; 257  : 		GPIOSetBit(pPddObject->hGpio, pPddObject->Port3RstGpio);

  00030	15940290	 ldrne       r0, [r4, #0x290]
  00034	1b000000	 blne        GPIOSetBit

; 258  : 	}
; 259  : 
; 260  :     return TRUE;

  00038	e3a00001	 mov         r0, #1

; 261  : }

  0003c	e8bd4010	 ldmia       sp!, {r4, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M45591|

			 ENDP  ; |PHY_DeassertReset|

	EXPORT	|TLLDevice_AssertReset|

  00000			 AREA	 |.pdata|, PDATA
|$T45602| DCD	|$LN5@TLLDevice_|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TLLDevice_AssertReset| PROC

; 264  : {

  00000		 |$LN5@TLLDevice_|
  00000		 |$M45599|

; 265  : 	UNREFERENCED_PARAMETER(pPddObject);
; 266  : 
; 267  :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 268  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M45600|

			 ENDP  ; |TLLDevice_AssertReset|

	EXPORT	|TLLDevice_DeassertReset|

  00000			 AREA	 |.pdata|, PDATA
|$T45611| DCD	|$LN5@TLLDevice_@2|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TLLDevice_DeassertReset| PROC

; 271  : {

  00000		 |$LN5@TLLDevice_@2|
  00000		 |$M45608|

; 272  : 	UNREFERENCED_PARAMETER(pPddObject);
; 273  : 
; 274  :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 275  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M45609|

			 ENDP  ; |TLLDevice_DeassertReset|

	EXPORT	|ExternalDeviceAssertReset|

  00000			 AREA	 |.pdata|, PDATA
|$T45623| DCD	|$LN11@ExternalDe|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ExternalDeviceAssertReset| PROC

; 278  : {

  00000		 |$LN11@ExternalDe|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45620|

; 279  :     if ((pPddObject->port1Mode == USB_PORT_TLL_MODE) ||
; 280  :         (pPddObject->port2Mode == USB_PORT_TLL_MODE) ||
; 281  :         (pPddObject->port3Mode == USB_PORT_TLL_MODE))
; 282  :     {
; 283  :        TLLDevice_AssertReset(pPddObject);
; 284  :     }
; 285  : 
; 286  :     if ((pPddObject->port1Mode == USB_PORT_PHY_MODE) ||
; 287  :         (pPddObject->port2Mode == USB_PORT_PHY_MODE) ||
; 288  :         (pPddObject->port3Mode == USB_PORT_PHY_MODE))

  00004	e5903260	 ldr         r3, [r0, #0x260]
  00008	e3530001	 cmp         r3, #1
  0000c	0a000005	 beq         |$LN1@ExternalDe|
  00010	e5903264	 ldr         r3, [r0, #0x264]
  00014	e3530001	 cmp         r3, #1
  00018	0a000002	 beq         |$LN1@ExternalDe|
  0001c	e5903268	 ldr         r3, [r0, #0x268]
  00020	e3530001	 cmp         r3, #1
  00024	1a000000	 bne         |$LN2@ExternalDe|
  00028		 |$LN1@ExternalDe|

; 289  :     {
; 290  :        PHY_AssertReset(pPddObject, bCalledFromPowerUp);

  00028	eb000000	 bl          PHY_AssertReset
  0002c		 |$LN2@ExternalDe|

; 291  :     }
; 292  : }

  0002c	e49de004	 ldr         lr, [sp], #4
  00030	e12fff1e	 bx          lr
  00034		 |$M45621|

			 ENDP  ; |ExternalDeviceAssertReset|

	EXPORT	|ExternalDeviceDeassertReset|

  00000			 AREA	 |.pdata|, PDATA
|$T45634| DCD	|$LN11@ExternalDe@2|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ExternalDeviceDeassertReset| PROC

; 295  : {

  00000		 |$LN11@ExternalDe@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45631|

; 296  :     if ((pPddObject->port1Mode == USB_PORT_TLL_MODE) ||
; 297  :         (pPddObject->port2Mode == USB_PORT_TLL_MODE) ||
; 298  :         (pPddObject->port3Mode == USB_PORT_TLL_MODE))
; 299  :     {
; 300  :        TLLDevice_DeassertReset(pPddObject);
; 301  :     }
; 302  : 
; 303  :     if ((pPddObject->port1Mode == USB_PORT_PHY_MODE) ||
; 304  :         (pPddObject->port2Mode == USB_PORT_PHY_MODE) ||
; 305  :         (pPddObject->port3Mode == USB_PORT_PHY_MODE))

  00004	e5903260	 ldr         r3, [r0, #0x260]
  00008	e3530001	 cmp         r3, #1
  0000c	0a000005	 beq         |$LN1@ExternalDe@2|
  00010	e5903264	 ldr         r3, [r0, #0x264]
  00014	e3530001	 cmp         r3, #1
  00018	0a000002	 beq         |$LN1@ExternalDe@2|
  0001c	e5903268	 ldr         r3, [r0, #0x268]
  00020	e3530001	 cmp         r3, #1
  00024	1a000000	 bne         |$LN2@ExternalDe@2|
  00028		 |$LN1@ExternalDe@2|

; 306  :     {
; 307  :        PHY_DeassertReset(pPddObject);

  00028	eb000000	 bl          PHY_DeassertReset
  0002c		 |$LN2@ExternalDe@2|

; 308  :     }
; 309  : }

  0002c	e49de004	 ldr         lr, [sp], #4
  00030	e12fff1e	 bx          lr
  00034		 |$M45632|

			 ENDP  ; |ExternalDeviceDeassertReset|

	EXPORT	|DelayExtDevDeassertReset|

  00000			 AREA	 |.pdata|, PDATA
|$T45644| DCD	|$LN5@DelayExtDe|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DelayExtDevDeassertReset| PROC

; 312  : {

  00000		 |$LN5@DelayExtDe|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M45641|
  00004	e1a04000	 mov         r4, r0
  00008	e3a03c13	 mov         r3, #0x13, 24

; 313  :     Sleep(5000);

  0000c	e3830088	 orr         r0, r3, #0x88
  00010	eb000000	 bl          Sleep

; 314  :     ExternalDeviceDeassertReset(pPddObject);

  00014	e1a00004	 mov         r0, r4
  00018	eb000000	 bl          ExternalDeviceDeassertReset

; 315  :     Sleep(10);

  0001c	e3a0000a	 mov         r0, #0xA
  00020	eb000000	 bl          Sleep

; 316  :     DEBUGMSG(ZONE_INFO, (TEXT("EHCI: External device reset deasserted\r\n")));
; 317  :     return 0;

  00024	e3a00000	 mov         r0, #0

; 318  : }

  00028	e8bd4010	 ldmia       sp!, {r4, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$M45642|

			 ENDP  ; |DelayExtDevDeassertReset|

	IMPORT	|GPIOSetMode|

  00000			 AREA	 |.pdata|, PDATA
|$T45658| DCD	|$LN20@PortPowerC|
	DCD	0x40002501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PortPowerControl| PROC

; 321  : {

  00000		 |$LN20@PortPowerC|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M45655|
  00004	e1a07002	 mov         r7, r2
  00008	e1a04000	 mov         r4, r0

; 322  :     DWORD PortPwrLevel;
; 323  :     DWORD PortPwrGpio;
; 324  : 
; 325  :     switch (dwPortNumber)

  0000c	e3510001	 cmp         r1, #1
  00010	0a000009	 beq         |$LN11@PortPowerC|
  00014	e3510002	 cmp         r1, #2
  00018	0a000004	 beq         |$LN10@PortPowerC|
  0001c	e3510003	 cmp         r1, #3
  00020	1a000014	 bne         |$LN1@PortPowerC|

; 336  : 
; 337  :         case 3:
; 338  :             PortPwrLevel = pPddObject->Port3PwrLevel;

  00024	e594628c	 ldr         r6, [r4, #0x28C]

; 339  :             PortPwrGpio = pPddObject->Port3PwrGpio;

  00028	e5945274	 ldr         r5, [r4, #0x274]

; 340  :             break;

  0002c	ea000004	 b           |$LN12@PortPowerC|
  00030		 |$LN10@PortPowerC|

; 330  :             break;
; 331  : 
; 332  :         case 2:
; 333  :             PortPwrLevel = pPddObject->Port2PwrLevel;

  00030	e5946288	 ldr         r6, [r4, #0x288]

; 334  :             PortPwrGpio = pPddObject->Port2PwrGpio;

  00034	e5945270	 ldr         r5, [r4, #0x270]

; 335  :             break;

  00038	ea000001	 b           |$LN12@PortPowerC|
  0003c		 |$LN11@PortPowerC|

; 326  :     {
; 327  :         case 1:
; 328  :             PortPwrLevel = pPddObject->Port1PwrLevel;

  0003c	e5946284	 ldr         r6, [r4, #0x284]

; 329  :             PortPwrGpio = pPddObject->Port1PwrGpio;

  00040	e594526c	 ldr         r5, [r4, #0x26C]
  00044		 |$LN12@PortPowerC|

; 341  : 
; 342  :         default:
; 343  :             return;
; 344  :     }
; 345  : 
; 346  :     if (PortPwrGpio == -1)

  00044	e3750001	 cmn         r5, #1
  00048	0a00000a	 beq         |$LN1@PortPowerC|

; 347  :         return;
; 348  : 
; 349  :     GPIOSetMode(pPddObject->hGpio, PortPwrGpio, GPIO_DIR_OUTPUT);

  0004c	e5940290	 ldr         r0, [r4, #0x290]
  00050	e3a02000	 mov         r2, #0
  00054	e1a01005	 mov         r1, r5
  00058	eb000000	 bl          GPIOSetMode

; 354  :             GPIOClrBit(pPddObject->hGpio , PortPwrGpio);

  0005c	e5940290	 ldr         r0, [r4, #0x290]
  00060	e3570000	 cmp         r7, #0
  00064	e1a01005	 mov         r1, r5
  00068	0a000004	 beq         |$LN6@PortPowerC|

; 350  : 
; 351  :     if (bPowerOn)
; 352  :     {
; 353  :         if (PortPwrLevel == 0)

  0006c	e3560000	 cmp         r6, #0

; 355  :         else

  00070	1a000004	 bne         |$LN17@PortPowerC|
  00074		 |$LN16@PortPowerC|

; 362  :         else
; 363  :             GPIOClrBit(pPddObject->hGpio , PortPwrGpio);

  00074	eb000000	 bl          GPIOClrBit
  00078		 |$LN1@PortPowerC|

; 364  :     }
; 365  : }

  00078	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$LN6@PortPowerC|

; 356  :             GPIOSetBit(pPddObject->hGpio , PortPwrGpio);
; 357  :     }
; 358  :     else
; 359  :     {
; 360  :         if (PortPwrLevel == 0)

  00080	e3560000	 cmp         r6, #0
  00084	1afffffa	 bne         |$LN16@PortPowerC|
  00088		 |$LN17@PortPowerC|

; 361  :             GPIOSetBit(pPddObject->hGpio , PortPwrGpio);

  00088	eb000000	 bl          GPIOSetBit

; 364  :     }
; 365  : }

  0008c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$M45656|

			 ENDP  ; |PortPowerControl|

	IMPORT	|CreateThread|
	IMPORT	|MmUnmapIoSpace|
	IMPORT	|SOCEhciConfigure|
	IMPORT	|MmMapIoSpace|

  00000			 AREA	 |.pdata|, PDATA
|$T45761| DCD	|$LN106@Configure_|
	DCD	0x4000d602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Configure_EHCI| PROC

; 368  : {

  00000		 |$LN106@Configure_|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M45758|
  00008	e1a09001	 mov         r9, r1
  0000c	e1a04000	 mov         r4, r0

; 369  :     BOOL rv													= TRUE;
; 370  : 	DWORD dwStartTickCount									= 0;
; 371  :     PHYSICAL_ADDRESS pa;
; 372  : 	DWORD dwCnt												= 0;
; 373  : 	DWORD dwHostConfig										= 0;
; 374  :     OMAP_USB_TLL_REGS* pOMAP_USB_TLL_REGS					= NULL;
; 375  :     OMAP_UHH_REGS* pUHHRegs									= NULL;
; 376  :     DWORD StartingTickCount									= 0;
; 377  : 	BOOL bPortTLLmode[NUM_PORTS];
; 378  : 
; 379  : 	// Map registers
; 380  : 	pa.QuadPart = pPddObject->USBHInfo.UHH_REGS_PA;

  00010	e59402a8	 ldr         r0, [r4, #0x2A8]
  00014	e3a01000	 mov         r1, #0

; 381  :     pUHHRegs    =(OMAP_UHH_REGS *)MmMapIoSpace(pa, sizeof(OMAP_UHH_REGS), FALSE);

  00018	e3a03000	 mov         r3, #0
  0001c	e3a02048	 mov         r2, #0x48
  00020	e3a0a001	 mov         r10, #1
  00024	e3a06000	 mov         r6, #0
  00028	eb000000	 bl          MmMapIoSpace
  0002c	e1a07000	 mov         r7, r0

; 382  : 
; 383  : 	pa.QuadPart = pPddObject->USBHInfo.USBTLL_REGS_PA;

  00030	e59402ac	 ldr         r0, [r4, #0x2AC]
  00034	e3a01000	 mov         r1, #0

; 384  :     pOMAP_USB_TLL_REGS =(OMAP_USB_TLL_REGS*)MmMapIoSpace(pa, sizeof(OMAP_USB_TLL_REGS), FALSE);

  00038	e3a03000	 mov         r3, #0
  0003c	e3a0204c	 mov         r2, #0x4C
  00040	eb000000	 bl          MmMapIoSpace
  00044	e1a05000	 mov         r5, r0

; 385  : 
; 386  : 	// Perform SOC specific configuration
; 387  : 	SOCEhciConfigure(pPddObject);

  00048	e1a00004	 mov         r0, r4
  0004c	eb000000	 bl          SOCEhciConfigure

; 388  : 
; 389  : 	// put external USB devices in reset before enabling EHCI controller.
; 390  :     // Some USB transceivers require to be held in reset before USB host supplies ULPI clock.
; 391  :     ExternalDeviceAssertReset(pPddObject, bCalledFromPowerUp);

  00050	e1a01009	 mov         r1, r9
  00054	e1a00004	 mov         r0, r4
  00058	eb000000	 bl          ExternalDeviceAssertReset

; 392  : 
; 393  :     if (pOMAP_USB_TLL_REGS)

  0005c	e3550000	 cmp         r5, #0
  00060	0a000076	 beq         |$LN34@Configure_|
  00064	e3a03c01	 mov         r3, #1, 24

; 394  :     {
; 395  :         /* start a soft reset on usb tll*/
; 396  :         pOMAP_USB_TLL_REGS->USBTLL_SYSCONFIG = USBTLL_SYSCONFIG_SOFTRESET | USBTLL_SYSCONFIG_ENAWAKEUP | USBTLL_SYSCONFIG_SIDLEMODE(SIDLE_IGNORE)| USBTLL_SYSCONFIG_CACTIVITY;

  00068	e383300e	 orr         r3, r3, #0xE
  0006c	e5853010	 str         r3, [r5, #0x10]

; 397  :         dwStartTickCount = GetTickCount();

  00070	eb000000	 bl          GetTickCount

; 398  :         while (!(pOMAP_USB_TLL_REGS->USBTLL_SYSSTATUS & USBTLL_SYSSTATUS_RESETDONE))

  00074	e1a08000	 mov         r8, r0
  00078	ea000006	 b           |$LN101@Configure_|
  0007c		 |$LL33@Configure_|

; 399  :         {
; 400  :             if (GetTickCount() - dwStartTickCount > EHCI_PRCM_TIMEOUT)

  0007c	eb000000	 bl          GetTickCount
  00080	e0403008	 sub         r3, r0, r8
  00084	e3530ffa	 cmp         r3, #0xFA, 30
  00088	8a000005	 bhi         |$LN98@Configure_|

; 401  :             {
; 402  :                 DEBUGMSG(ZONE_INFO, (TEXT("EHCI -  USB_TLL 1 reset Timeout 0x%x\r\n"), pOMAP_USB_TLL_REGS->USBTLL_SYSSTATUS));
; 403  :                 break;
; 404  :             }
; 405  :             DelayMilliSeconds(1, bCalledFromPowerUp);

  0008c	e1a01009	 mov         r1, r9
  00090	e3a00001	 mov         r0, #1
  00094	eb000000	 bl          DelayMilliSeconds
  00098		 |$LN101@Configure_|
  00098	e5953014	 ldr         r3, [r5, #0x14]
  0009c	e3130001	 tst         r3, #1
  000a0	0afffff5	 beq         |$LL33@Configure_|
  000a4		 |$LN98@Configure_|

; 406  :         }
; 407  : 
; 408  :         pUHHRegs->SYSCONFIG |= UHH_SYSCONFIG_AUTOIDLE | UHH_SYSCONFIG_SOFTRESET;

  000a4	e5973010	 ldr         r3, [r7, #0x10]

; 409  :         while (!(pUHHRegs->SYSSTATUS & UHH_SYSSTATUS_RESETDONE))

  000a8	e3833003	 orr         r3, r3, #3
  000ac	e5873010	 str         r3, [r7, #0x10]
  000b0	ea000006	 b           |$LN103@Configure_|
  000b4		 |$LL30@Configure_|

; 410  :         {
; 411  :             if (GetTickCount() - dwStartTickCount > EHCI_PRCM_TIMEOUT)

  000b4	eb000000	 bl          GetTickCount
  000b8	e0403008	 sub         r3, r0, r8
  000bc	e3530ffa	 cmp         r3, #0xFA, 30
  000c0	8a000005	 bhi         |$LN99@Configure_|

; 412  :             {
; 413  :                 DEBUGMSG(ZONE_INFO, (TEXT("EHCI -  UHH reset Timeout 0x%x\r\n"), pUHHRegs->SYSSTATUS));
; 414  :                 break;
; 415  :             }
; 416  :             DelayMilliSeconds(1, bCalledFromPowerUp);

  000c4	e1a01009	 mov         r1, r9
  000c8	e3a00001	 mov         r0, #1
  000cc	eb000000	 bl          DelayMilliSeconds
  000d0		 |$LN103@Configure_|
  000d0	e5973014	 ldr         r3, [r7, #0x14]
  000d4	e3130001	 tst         r3, #1
  000d8	0afffff5	 beq         |$LL30@Configure_|
  000dc		 |$LN99@Configure_|

; 417  :         }
; 418  :         DEBUGMSG(ZONE_INFO, (TEXT("EHCI -  UHH SYSSTATUS 0x%x\r\n"), pUHHRegs->SYSSTATUS));
; 419  :         pUHHRegs->SYSCONFIG &= ~UHH_SYSCONFIG_SOFTRESET;

  000dc	e5973010	 ldr         r3, [r7, #0x10]
  000e0	e3a02a02	 mov         r2, #2, 20

; 420  : 
; 421  :         pUHHRegs->SYSCONFIG = UHH_SYSCONFIG_ENAWAKEUP |
; 422  :                               UHH_SYSCONFIG_SIDLEMODE(SIDLE_SMART) |
; 423  :                               UHH_SYSCONFIG_MIDLEMODE(MIDLE_SMART);
; 424  : 
; 425  :         for (dwCnt = 0; dwCnt < NUM_PORTS; dwCnt++)
; 426  :             bPortTLLmode[dwCnt] = FALSE;

  000e4	e3a01000	 mov         r1, #0
  000e8	e3c33002	 bic         r3, r3, #2
  000ec	e5873010	 str         r3, [r7, #0x10]
  000f0	e3823014	 orr         r3, r2, #0x14
  000f4	e28d2008	 add         r2, sp, #8
  000f8	e5873010	 str         r3, [r7, #0x10]
  000fc	e282300c	 add         r3, r2, #0xC
  00100		 |$LN96@Configure_|
  00100	e4821004	 str         r1, [r2], #4
  00104	e1520003	 cmp         r2, r3
  00108	1afffffc	 bne         |$LN96@Configure_|

; 427  : 
; 428  :         if (pPddObject->port1Mode == USB_PORT_TLL_MODE)

  0010c	e5943260	 ldr         r3, [r4, #0x260]
  00110	e3530002	 cmp         r3, #2

; 429  :         {
; 430  :             dwHostConfig |= UHH_HOSTCONFIG_P1_ULPI_BYPASS;
; 431  :             bPortTLLmode[0] = TRUE;

  00114	03a03001	 moveq       r3, #1
  00118	058d3008	 streq       r3, [sp, #8]

; 432  :         }
; 433  : 
; 434  :         // bypass bits were added for ports 2 and 3
; 435  :         if (pPddObject->port2Mode == USB_PORT_TLL_MODE)

  0011c	e5943264	 ldr         r3, [r4, #0x264]
  00120	03a06001	 moveq       r6, #1
  00124	e3530002	 cmp         r3, #2

; 436  :         {
; 437  :             dwHostConfig |= UHH_HOSTCONFIG_P2_ULPI_BYPASS;
; 438  :             bPortTLLmode[1] = TRUE;

  00128	03a03001	 moveq       r3, #1
  0012c	058d300c	 streq       r3, [sp, #0xC]

; 439  :         }
; 440  : 
; 441  :         if (pPddObject->port3Mode == USB_PORT_TLL_MODE)

  00130	e5943268	 ldr         r3, [r4, #0x268]
  00134	03866b02	 orreq       r6, r6, #2, 22
  00138	e3530002	 cmp         r3, #2

; 442  :         {
; 443  :             dwHostConfig |= UHH_HOSTCONFIG_P3_ULPI_BYPASS;
; 444  :             bPortTLLmode[2] = TRUE;

  0013c	03a03001	 moveq       r3, #1
  00140	03866a01	 orreq       r6, r6, #1, 20
  00144	058d3010	 streq       r3, [sp, #0x10]

; 445  :         }
; 446  : 
; 447  :         dwHostConfig |= UHH_HOSTCONFIG_ENA_INCR4 |
; 448  :             UHH_HOSTCONFIG_ENA_INCR8 | UHH_HOSTCONFIG_ENA_INCR16;
; 449  : 
; 450  :         pUHHRegs->HOSTCONFIG = dwHostConfig;

  00148	e386301c	 orr         r3, r6, #0x1C
  0014c	e5873040	 str         r3, [r7, #0x40]

; 451  : 
; 452  :         // Not sure what this polling loop is for...
; 453  :         if (pPddObject->port1Mode == USB_PORT_PHY_MODE)

  00150	e5942260	 ldr         r2, [r4, #0x260]
  00154	e3520001	 cmp         r2, #1
  00158	1a000002	 bne         |$LN19@Configure_|
  0015c		 |$LL20@Configure_|

; 454  :         {
; 455  :             while (pUHHRegs->HOSTCONFIG & UHH_HOSTCONFIG_P1_ULPI_BYPASS);

  0015c	e5973040	 ldr         r3, [r7, #0x40]
  00160	e3130001	 tst         r3, #1
  00164	1afffffc	 bne         |$LL20@Configure_|
  00168		 |$LN19@Configure_|

; 456  : 
; 457  :             DEBUGMSG(ZONE_INFO, (TEXT("EHCI: PHY Mode Polling done\r\n")));
; 458  :         }
; 459  : 
; 460  :         if ((pPddObject->port1Mode == USB_PORT_TLL_MODE) ||
; 461  :             (pPddObject->port2Mode == USB_PORT_TLL_MODE) ||
; 462  :             (pPddObject->port3Mode == USB_PORT_TLL_MODE)
; 463  :             )

  00168	e3520002	 cmp         r2, #2
  0016c	0a000005	 beq         |$LN17@Configure_|
  00170	e5943264	 ldr         r3, [r4, #0x264]
  00174	e3530002	 cmp         r3, #2
  00178	0a000002	 beq         |$LN17@Configure_|
  0017c	e5943268	 ldr         r3, [r4, #0x268]
  00180	e3530002	 cmp         r3, #2
  00184	1a00001c	 bne         |$LN10@Configure_|
  00188		 |$LN17@Configure_|

; 464  :         {
; 465  :             DEBUGMSG(ZONE_INFO, (TEXT("EHCI: TLL Mode Polling start...\r\n")));
; 466  :             DEBUGMSG(ZONE_INFO, (TEXT("##########USBTLL_SYSSTATUS =0x%x\r\n"), pOMAP_USB_TLL_REGS->USBTLL_SYSSTATUS));
; 467  : 
; 468  :             for (dwCnt = 0; dwCnt < NUM_PORTS; dwCnt++)

  00188	e2852040	 add         r2, r5, #0x40
  0018c	e1a01002	 mov         r1, r2
  00190	e28d0008	 add         r0, sp, #8
  00194	e3a0e003	 mov         lr, #3
  00198		 |$LL16@Configure_|

; 469  :             {
; 470  :                 if (bPortTLLmode[dwCnt] == TRUE)

  00198	e5903000	 ldr         r3, [r0]

; 471  :                     pOMAP_USB_TLL_REGS->TLL_CHANNEL_CONF[dwCnt] &=
; 472  :                              ~(USBTLL_CHANNEL_CONF_i_ULPIDDRMODE |
; 473  :                              USBTLL_CHANNEL_CONF_i_UTMIAUTOIDLE |
; 474  :                              USBTLL_CHANNEL_CONF_i_ULPIAUTOIDLE);

  0019c	e2800004	 add         r0, r0, #4
  001a0	e3530001	 cmp         r3, #1
  001a4	05913000	 ldreq       r3, [r1]
  001a8	03c33c07	 biceq       r3, r3, #7, 24
  001ac	05813000	 streq       r3, [r1]
  001b0	e2811004	 add         r1, r1, #4
  001b4	e25ee001	 subs        lr, lr, #1
  001b8	1afffff6	 bne         |$LL16@Configure_|

; 475  :             }
; 476  : 
; 477  :             DEBUGMSG(ZONE_INFO, (TEXT("##########USBTLL_SYSSTATUS =0x%x\r\n"), pOMAP_USB_TLL_REGS->USBTLL_SYSSTATUS));
; 478  :             pOMAP_USB_TLL_REGS->TLL_SHARED_CONF |= USBTLL_SHARED_CONF_FCLK_IS_ON | USBTLL_SHARED_CONF_USB_DIVRATIO(1);

  001bc	e5953030	 ldr         r3, [r5, #0x30]
  001c0	e28d1008	 add         r1, sp, #8
  001c4	e3a00003	 mov         r0, #3
  001c8	e3833005	 orr         r3, r3, #5
  001cc	e5853030	 str         r3, [r5, #0x30]
  001d0	e3a03b02	 mov         r3, #2, 22
  001d4	e383e001	 orr         lr, r3, #1
  001d8		 |$LL12@Configure_|

; 479  : 
; 480  :             for (dwCnt = 0; dwCnt < NUM_PORTS; dwCnt++)
; 481  :             {
; 482  :                 if (bPortTLLmode[dwCnt] == TRUE)

  001d8	e5913000	 ldr         r3, [r1]

; 483  :                     pOMAP_USB_TLL_REGS->TLL_CHANNEL_CONF[dwCnt] |=
; 484  :                         USBTLL_CHANNEL_CONF_i_CHANEN | USBTLL_CHANNEL_CONF_i_ULPINOBITSTUFF;

  001dc	e2811004	 add         r1, r1, #4
  001e0	e3530001	 cmp         r3, #1
  001e4	05923000	 ldreq       r3, [r2]
  001e8	0183300e	 orreq       r3, r3, lr
  001ec	05823000	 streq       r3, [r2]
  001f0	e2822004	 add         r2, r2, #4
  001f4	e2500001	 subs        r0, r0, #1
  001f8	1afffff6	 bne         |$LL12@Configure_|
  001fc		 |$LN10@Configure_|

; 485  :             }
; 486  :         }
; 487  : 
; 488  :         if (pPddObject->port1Mode == USB_PORT_PHY_MODE)

  001fc	e5943260	 ldr         r3, [r4, #0x260]
  00200	e3a02085	 mov         r2, #0x85

; 489  :         {
; 490  :             pOMAP_USB_TLL_REGS->TLL_CHANNEL_CONF[0] =
; 491  :                 USBTLL_CHANNEL_CONF_i_ULPIOUTCLKMODE |
; 492  :                 USBTLL_CHANNEL_CONF_i_CHANMODE(2) |
; 493  :                 USBTLL_CHANNEL_CONF_i_CHANEN;
; 494  :         }
; 495  : 
; 496  :         if (pPddObject->port2Mode == USB_PORT_PHY_MODE)
; 497  :         {
; 498  :             pOMAP_USB_TLL_REGS->TLL_CHANNEL_CONF[1] =
; 499  :                 USBTLL_CHANNEL_CONF_i_ULPIOUTCLKMODE |
; 500  :                 USBTLL_CHANNEL_CONF_i_CHANMODE(2) |
; 501  :                 USBTLL_CHANNEL_CONF_i_CHANEN;
; 502  :         }
; 503  : 
; 504  :         if (pPddObject->port3Mode == USB_PORT_PHY_MODE)
; 505  :         {
; 506  :             pOMAP_USB_TLL_REGS->TLL_CHANNEL_CONF[2] =
; 507  :                 USBTLL_CHANNEL_CONF_i_ULPIOUTCLKMODE |
; 508  :                 USBTLL_CHANNEL_CONF_i_CHANMODE(2) |
; 509  :                 USBTLL_CHANNEL_CONF_i_CHANEN;
; 510  :         }
; 511  : 
; 512  :         MmUnmapIoSpace((PVOID)pOMAP_USB_TLL_REGS, sizeof(OMAP_USB_TLL_REGS));

  00204	e3a0104c	 mov         r1, #0x4C
  00208	e3530001	 cmp         r3, #1
  0020c	05852040	 streq       r2, [r5, #0x40]
  00210	e5943264	 ldr         r3, [r4, #0x264]
  00214	e1a00005	 mov         r0, r5
  00218	e3530001	 cmp         r3, #1
  0021c	05852044	 streq       r2, [r5, #0x44]
  00220	e5943268	 ldr         r3, [r4, #0x268]
  00224	e3530001	 cmp         r3, #1
  00228	05852048	 streq       r2, [r5, #0x48]
  0022c	eb000000	 bl          MmUnmapIoSpace

; 513  :         MmUnmapIoSpace((PVOID)pUHHRegs, sizeof(OMAP_UHH_REGS));

  00230	e3a01048	 mov         r1, #0x48
  00234	e1a00007	 mov         r0, r7
  00238	eb000000	 bl          MmUnmapIoSpace

; 514  :     }
; 515  :     else

  0023c	ea000000	 b           |$LN5@Configure_|
  00240		 |$LN34@Configure_|

; 516  :     {
; 517  :         DEBUGMSG(ZONE_ERROR, (TEXT("EHCI - ConfigurePRCMFailed to mmap OMAP_PRCM_USBHOST_CM_REGS_PA")));
; 518  :         rv = FALSE;

  00240	e3a0a000	 mov         r10, #0
  00244		 |$LN5@Configure_|

; 519  :     }
; 520  : 
; 521  :     // power up ports
; 522  :     PortPowerControl(pPddObject, 1, TRUE);

  00244	e594526c	 ldr         r5, [r4, #0x26C]
  00248	e5946284	 ldr         r6, [r4, #0x284]
  0024c	e3750001	 cmn         r5, #1
  00250	0a00000a	 beq         |$LN40@Configure_|
  00254	e5940290	 ldr         r0, [r4, #0x290]
  00258	e3a02000	 mov         r2, #0
  0025c	e1a01005	 mov         r1, r5
  00260	eb000000	 bl          GPIOSetMode
  00264	e5940290	 ldr         r0, [r4, #0x290]
  00268	e3560000	 cmp         r6, #0
  0026c	e1a01005	 mov         r1, r5
  00270	1a000001	 bne         |$LN41@Configure_|
  00274	eb000000	 bl          GPIOClrBit
  00278	ea000000	 b           |$LN40@Configure_|
  0027c		 |$LN41@Configure_|
  0027c	eb000000	 bl          GPIOSetBit
  00280		 |$LN40@Configure_|

; 523  :     PortPowerControl(pPddObject, 2, TRUE);

  00280	e5945270	 ldr         r5, [r4, #0x270]
  00284	e5946288	 ldr         r6, [r4, #0x288]
  00288	e3750001	 cmn         r5, #1
  0028c	0a00000a	 beq         |$LN55@Configure_|
  00290	e5940290	 ldr         r0, [r4, #0x290]
  00294	e3a02000	 mov         r2, #0
  00298	e1a01005	 mov         r1, r5
  0029c	eb000000	 bl          GPIOSetMode
  002a0	e5940290	 ldr         r0, [r4, #0x290]
  002a4	e3560000	 cmp         r6, #0
  002a8	e1a01005	 mov         r1, r5
  002ac	1a000001	 bne         |$LN56@Configure_|
  002b0	eb000000	 bl          GPIOClrBit
  002b4	ea000000	 b           |$LN55@Configure_|
  002b8		 |$LN56@Configure_|
  002b8	eb000000	 bl          GPIOSetBit
  002bc		 |$LN55@Configure_|

; 524  :     PortPowerControl(pPddObject, 3, TRUE);

  002bc	e5945274	 ldr         r5, [r4, #0x274]
  002c0	e594628c	 ldr         r6, [r4, #0x28C]
  002c4	e3750001	 cmn         r5, #1
  002c8	0a00000a	 beq         |$LN70@Configure_|
  002cc	e5940290	 ldr         r0, [r4, #0x290]
  002d0	e3a02000	 mov         r2, #0
  002d4	e1a01005	 mov         r1, r5
  002d8	eb000000	 bl          GPIOSetMode
  002dc	e5940290	 ldr         r0, [r4, #0x290]
  002e0	e3560000	 cmp         r6, #0
  002e4	e1a01005	 mov         r1, r5
  002e8	1a000001	 bne         |$LN71@Configure_|
  002ec	eb000000	 bl          GPIOClrBit
  002f0	ea000000	 b           |$LN70@Configure_|
  002f4		 |$LN71@Configure_|
  002f4	eb000000	 bl          GPIOSetBit
  002f8		 |$LN70@Configure_|

; 525  : 
; 526  :     #if DUMP_REGS
; 527  :         dumpRegs(pPddObject);
; 528  :     #endif
; 529  : 
; 530  :     if (!bCalledFromPowerUp)

  002f8	e3590000	 cmp         r9, #0
  002fc	1a000008	 bne         |$LN4@Configure_|

; 531  :     {
; 532  :         CreateThread(NULL, 0, DelayExtDevDeassertReset, (LPVOID)pPddObject, 0, 0);

  00300	e59f204c	 ldr         r2, [pc, #0x4C]
  00304	e3a0e000	 mov         lr, #0
  00308	e1a03004	 mov         r3, r4
  0030c	e3a01000	 mov         r1, #0
  00310	e3a00000	 mov         r0, #0
  00314	e58de004	 str         lr, [sp, #4]
  00318	e58de000	 str         lr, [sp]
  0031c	eb000000	 bl          CreateThread

; 533  :     }
; 534  :     else

  00320	ea000007	 b           |$LN3@Configure_|
  00324		 |$LN4@Configure_|

; 535  :     {
; 536  :         StartingTickCount = GetTickCount();

  00324	eb000000	 bl          GetTickCount
  00328	e1a05000	 mov         r5, r0
  0032c		 |$LL2@Configure_|

; 537  :         while (GetTickCount() - StartingTickCount < 500)

  0032c	eb000000	 bl          GetTickCount
  00330	e0403005	 sub         r3, r0, r5
  00334	e3530f7d	 cmp         r3, #0x7D, 30
  00338	3afffffb	 bcc         |$LL2@Configure_|

; 538  :         {
; 539  :         }
; 540  :         ExternalDeviceDeassertReset(pPddObject);

  0033c	e1a00004	 mov         r0, r4
  00340	eb000000	 bl          ExternalDeviceDeassertReset
  00344		 |$LN3@Configure_|

; 541  :     }
; 542  : 
; 543  :     return rv;
; 544  : }

  00344	e1a0000a	 mov         r0, r10
  00348	e28dd014	 add         sp, sp, #0x14
  0034c	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00350	e12fff1e	 bx          lr
  00354		 |$LN107@Configure_|
  00354		 |$LN108@Configure_|
  00354	00000000	 DCD         |DelayExtDevDeassertReset|
  00358		 |$M45759|

			 ENDP  ; |Configure_EHCI|

	EXPORT	|HcdPdd_DllMain|

  00000			 AREA	 |.pdata|, PDATA
|$T45772| DCD	|$LN5@HcdPdd_Dll|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_DllMain| PROC

; 553  : {

  00000		 |$LN5@HcdPdd_Dll|
  00000		 |$M45769|

; 554  :     UNREFERENCED_PARAMETER(hinstDLL);
; 555  :     UNREFERENCED_PARAMETER(dwReason);
; 556  :     UNREFERENCED_PARAMETER(lpvReserved);
; 557  : 
; 558  :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 559  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M45770|

			 ENDP  ; |HcdPdd_DllMain|

	EXPORT	|??_C@_1CC@NPEFILDH@?$AAP?$AAh?$AAy?$AAs?$AAi?$AAc?$AAa?$AAl?$AAP?$AAa?$AAg?$AAe?$AAS?$AAi?$AAz?$AAe?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|RegCloseKey|
	IMPORT	|RegQueryValueExW|
	IMPORT	|RegOpenKeyExW|

  00000			 AREA	 |.pdata|, PDATA
|$T45784| DCD	|$LN8@GetRegistr|
	DCD	0x40002602

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@NPEFILDH@?$AAP?$AAh?$AAy?$AAs?$AAi?$AAc?$AAa?$AAl?$AAP?$AAa?$AAg?$AAe?$AAS?$AAi?$AAz?$AAe?$AA?$AA@| DCB "P"
	DCB	0x0, "h", 0x0, "y", 0x0, "s", 0x0, "i", 0x0, "c", 0x0, "a"
	DCB	0x0, "l", 0x0, "P", 0x0, "a", 0x0, "g", 0x0, "e", 0x0, "S"
	DCB	0x0, "i", 0x0, "z", 0x0, "e", 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetRegistryPhysicalMemSize| PROC

; 571  : {

  00000		 |$LN8@GetRegistr|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M45781|
  00008	e1a06001	 mov         r6, r1
  0000c	e1a01000	 mov         r1, r0

; 572  :     HKEY hKey;
; 573  :     DWORD dwData;
; 574  :     DWORD dwSize;
; 575  :     DWORD dwType;
; 576  :     BOOL  fRet=FALSE;
; 577  :     DWORD dwRet;
; 578  : 
; 579  :     // Open key
; 580  :     dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,RegKeyPath,0,0,&hKey);

  00010	e28d3008	 add         r3, sp, #8
  00014	e58d3000	 str         r3, [sp]
  00018	e3a03000	 mov         r3, #0
  0001c	e3a02000	 mov         r2, #0
  00020	e3a0010a	 mov         r0, #0xA, 2
  00024	e3a05000	 mov         r5, #0
  00028	eb000000	 bl          RegOpenKeyExW
  0002c	e3500000	 cmp         r0, #0

; 581  :     if (dwRet != ERROR_SUCCESS) {
; 582  :         DEBUGMSG(ZONE_ERROR,(TEXT("EHCD:GetRegistryConfig RegOpenKeyEx(%s) failed %d\r\n"),
; 583  :                              RegKeyPath, dwRet));
; 584  :         return FALSE;

  00030	13a05000	 movne       r5, #0
  00034	1a000012	 bne         |$LN4@GetRegistr|

; 585  :     }
; 586  : 
; 587  :     // Read base address, range from registry and determine IOSpace
; 588  :     dwSize = sizeof(dwData);
; 589  :     dwRet = RegQueryValueEx(hKey, REG_PHYSICAL_PAGE_SIZE, 0, &dwType, (PUCHAR)&dwData, &dwSize);

  00038	e59f1054	 ldr         r1, [pc, #0x54]
  0003c	e59d0008	 ldr         r0, [sp, #8]
  00040	e3a07004	 mov         r7, #4
  00044	e28de00c	 add         lr, sp, #0xC
  00048	e28d4010	 add         r4, sp, #0x10
  0004c	e28d3014	 add         r3, sp, #0x14
  00050	e3a02000	 mov         r2, #0
  00054	e58d700c	 str         r7, [sp, #0xC]
  00058	e58de004	 str         lr, [sp, #4]
  0005c	e58d4000	 str         r4, [sp]
  00060	eb000000	 bl          RegQueryValueExW
  00064	e3500000	 cmp         r0, #0

; 590  :     if (dwRet == ERROR_SUCCESS) {

  00068	1a000003	 bne         |$LN2@GetRegistr|

; 591  :         if (lpdwPhyscialMemSize)

  0006c	e3560000	 cmp         r6, #0

; 592  :             *lpdwPhyscialMemSize = dwData;

  00070	159d3010	 ldrne       r3, [sp, #0x10]

; 593  :         fRet=TRUE;

  00074	e3a05001	 mov         r5, #1
  00078	15863000	 strne       r3, [r6]
  0007c		 |$LN2@GetRegistr|

; 594  :     }
; 595  :     RegCloseKey(hKey);

  0007c	e59d0008	 ldr         r0, [sp, #8]
  00080	eb000000	 bl          RegCloseKey

; 596  :     return fRet;

  00084		 |$LN4@GetRegistr|

; 597  : }

  00084	e1a00005	 mov         r0, r5
  00088	e28dd018	 add         sp, sp, #0x18
  0008c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$LN9@GetRegistr|
  00094		 |$LN10@GetRegistr|
  00094	00000000	 DCD         |??_C@_1CC@NPEFILDH@?$AAP?$AAh?$AAy?$AAs?$AAi?$AAc?$AAa?$AAl?$AAP?$AAa?$AAg?$AAe?$AAS?$AAi?$AAz?$AAe?$AA?$AA@|
  00098		 |$M45782|

			 ENDP  ; |GetRegistryPhysicalMemSize|

	EXPORT	|??_C@_1BM@KKKMKIHE@?$AAH?$AAc?$AAd?$AAC?$AAa?$AAp?$AAa?$AAb?$AAi?$AAl?$AAi?$AAt?$AAy?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|HalFreeCommonBuffer|
	IMPORT	|HcdMdd_DestroyMemoryObject|
	IMPORT	|HcdMdd_DestroyHcdObject|
	IMPORT	|FreeIntChainHandler|
	IMPORT	|HcdMdd_SetCapability|
	IMPORT	|HcdMdd_CreateHcdObject|
	IMPORT	|HcdMdd_CreateMemoryObject|
	IMPORT	|KernelIoControl|
	IMPORT	|GetIrqByDevice|
	IMPORT	|wcsncpy|

  00000			 AREA	 |.pdata|, PDATA
|$T45822| DCD	|$LN25@Initialize|
	DCD	0x4000b102

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BM@KKKMKIHE@?$AAH?$AAc?$AAd?$AAC?$AAa?$AAp?$AAa?$AAb?$AAi?$AAl?$AAi?$AAt?$AAy?$AA?$AA@| DCB "H"
	DCB	0x0, "c", 0x0, "d", 0x0, "C", 0x0, "a", 0x0, "p", 0x0, "a"
	DCB	0x0, "b", 0x0, "i", 0x0, "l", 0x0, "i", 0x0, "t", 0x0, "y"
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |InitializeEHCI| PROC

; 610  : {

  00000		 |$LN25@Initialize|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd020	 sub         sp, sp, #0x20
  00008		 |$M45819|
  00008	e1a08001	 mov         r8, r1
  0000c	e1a05000	 mov         r5, r0

; 611  :     LPVOID  pobMem = NULL;
; 612  :     LPVOID  pobEHCD = NULL;
; 613  :     DWORD   dwHPPhysicalMemSize = 0;
; 614  :     HKEY    hKey;
; 615  :     DWORD   dwIrq = 0;
; 616  : 	PHYSICAL_ADDRESS pa;
; 617  : 
; 618  : 	// Retrieve IRQ number
; 619  : 	dwIrq = GetIrqByDevice(pPddObject->USBHInfo.EHCIDevice, NULL);

  00010	e5950294	 ldr         r0, [r5, #0x294]
  00014	e3a03000	 mov         r3, #0
  00018	e3a01000	 mov         r1, #0
  0001c	e3a06000	 mov         r6, #0
  00020	e3a09000	 mov         r9, #0
  00024	e58d300c	 str         r3, [sp, #0xC]
  00028	eb000000	 bl          GetIrqByDevice
  0002c	e1a03000	 mov         r3, r0

; 620  : 
; 621  :     Configure_EHCI(pPddObject, FALSE);

  00030	e1a00005	 mov         r0, r5
  00034	e3a01000	 mov         r1, #0
  00038	e58d300c	 str         r3, [sp, #0xC]
  0003c	eb000000	 bl          Configure_EHCI

; 622  : 
; 623  :     if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szDriverRegKey, 0, 0, &hKey)!= ERROR_SUCCESS)

  00040	e28d3008	 add         r3, sp, #8
  00044	e58d3000	 str         r3, [sp]
  00048	e3a03000	 mov         r3, #0
  0004c	e3a02000	 mov         r2, #0
  00050	e1a01008	 mov         r1, r8
  00054	e3a0010a	 mov         r0, #0xA, 2
  00058	eb000000	 bl          RegOpenKeyExW
  0005c	e3500000	 cmp         r0, #0

; 624  :     {
; 625  :         DEBUGMSG(ZONE_ERROR, (TEXT("InitializeEHCI:GetRegistryConfig RegOpenKeyEx(%s) failed\r\n"), szDriverRegKey));
; 626  :         return FALSE;

  00060	1a000090	 bne         |$LN1@Initialize|

; 627  :     }
; 628  : 
; 629  :     // Map register base to virtual address
; 630  : 	pa.QuadPart = pPddObject->USBHInfo.EHCI_REGS_PA;

  00064	e59502b0	 ldr         r0, [r5, #0x2B0]
  00068	e3a01000	 mov         r1, #0

; 631  :     pPddObject->ioPortBase  =(UCHAR *)MmMapIoSpace(pa, OMAP_EHCI_REGS_SIZE, FALSE);

  0006c	e3a03000	 mov         r3, #0
  00070	e3a02b01	 mov         r2, #1, 22
  00074	eb000000	 bl          MmMapIoSpace
  00078	e3500000	 cmp         r0, #0
  0007c	e585023c	 str         r0, [r5, #0x23C]

; 632  :     if (pPddObject->ioPortBase == NULL)
; 633  :     {
; 634  :         DEBUGMSG(ZONE_ERROR, (TEXT("EHCI: Failed to map 0x%x...\r\n"), pPddObject->USBHInfo.EHCI_REGS_PA));
; 635  :         return FALSE;

  00080	0a000088	 beq         |$LN1@Initialize|

; 636  :     }
; 637  : 
; 638  :     // Request SYSINTR for interrupt
; 639  :     if (!KernelIoControl(IOCTL_HAL_REQUEST_SYSINTR,
; 640  :         &dwIrq,
; 641  :         sizeof(dwIrq),
; 642  :         &pPddObject->dwSysIntr,
; 643  :         sizeof(pPddObject->dwSysIntr),
; 644  :         NULL))

  00084	e59f0234	 ldr         r0, [pc, #0x234]
  00088	e3a0e004	 mov         lr, #4
  0008c	e3a0b000	 mov         r11, #0
  00090	e2853d09	 add         r3, r5, #9, 26
  00094	e3a02004	 mov         r2, #4
  00098	e28d100c	 add         r1, sp, #0xC
  0009c	e58db004	 str         r11, [sp, #4]
  000a0	e58de000	 str         lr, [sp]
  000a4	eb000000	 bl          KernelIoControl
  000a8	e3500000	 cmp         r0, #0

; 645  :     {
; 646  :         DEBUGMSG(ZONE_ERROR, (TEXT("EHCI: Failed to aquire IRQ_USB_HGEN")));
; 647  :         return FALSE;

  000ac	0a00007d	 beq         |$LN1@Initialize|

; 648  :     }
; 649  : 
; 650  :     DEBUGMSG(ZONE_INFO, (L"EHCI: SYSINTR %d\r\n", pPddObject->dwSysIntr));
; 651  : 
; 652  :     ////////////////////////////////////////////////////////////////////////////////////////////////////
; 653  :     // The PDD can supply a buffer of contiguous physical memory here, or can let the
; 654  :     // MDD try to allocate the memory from system RAM.  We will use the HalAllocateCommonBuffer()
; 655  :     // API to allocate the memory and bus controller physical addresses and pass this information
; 656  :     // into the MDD.
; 657  :     ////////////////////////////////////////////////////////////////////////////////////////////////////
; 658  :     if (GetRegistryPhysicalMemSize(szDriverRegKey, &pPddObject->dwPhysicalMemSize))

  000b0	e28d3010	 add         r3, sp, #0x10
  000b4	e58d3000	 str         r3, [sp]
  000b8	e3a03000	 mov         r3, #0
  000bc	e3a02000	 mov         r2, #0
  000c0	e1a01008	 mov         r1, r8
  000c4	e3a0010a	 mov         r0, #0xA, 2
  000c8	e3a07000	 mov         r7, #0
  000cc	eb000000	 bl          RegOpenKeyExW
  000d0	e3500000	 cmp         r0, #0
  000d4	1a000025	 bne         |$LN12@Initialize|
  000d8	e59f11dc	 ldr         r1, [pc, #0x1DC]
  000dc	e59d0010	 ldr         r0, [sp, #0x10]
  000e0	e3a0a004	 mov         r10, #4
  000e4	e28de014	 add         lr, sp, #0x14
  000e8	e28d4018	 add         r4, sp, #0x18
  000ec	e28d301c	 add         r3, sp, #0x1C
  000f0	e3a02000	 mov         r2, #0
  000f4	e58da014	 str         r10, [sp, #0x14]
  000f8	e58de004	 str         lr, [sp, #4]
  000fc	e58d4000	 str         r4, [sp]
  00100	eb000000	 bl          RegQueryValueExW
  00104	e3500000	 cmp         r0, #0
  00108	1a000003	 bne         |$LN19@Initialize|
  0010c	e3750018	 cmn         r5, #0x18
  00110	159d3018	 ldrne       r3, [sp, #0x18]
  00114	e3a07001	 mov         r7, #1
  00118	15853018	 strne       r3, [r5, #0x18]
  0011c		 |$LN19@Initialize|
  0011c	e59d0010	 ldr         r0, [sp, #0x10]
  00120	eb000000	 bl          RegCloseKey
  00124	e3570000	 cmp         r7, #0
  00128	0a000010	 beq         |$LN12@Initialize|

; 659  :     {
; 660  :         // A quarter for High priority Memory.
; 661  :         dwHPPhysicalMemSize = pPddObject->dwPhysicalMemSize/4;
; 662  :         // Align with page size.
; 663  :         pPddObject->dwPhysicalMemSize =(pPddObject->dwPhysicalMemSize + PAGE_SIZE -1) & ~(PAGE_SIZE -1);

  0012c	e3e03b0d	 mvn         r3, #0xD, 22
  00130	e223e0fb	 eor         lr, r3, #0xFB
  00134	e59e2000	 ldr         r2, [lr]
  00138	e5950018	 ldr         r0, [r5, #0x18]
  0013c	e1a03002	 mov         r3, r2
  00140	e2431001	 sub         r1, r3, #1
  00144	e0803002	 add         r3, r0, r2
  00148	e2433001	 sub         r3, r3, #1
  0014c	e1c33001	 bic         r3, r3, r1
  00150	e5853018	 str         r3, [r5, #0x18]

; 664  :         dwHPPhysicalMemSize =((dwHPPhysicalMemSize +  PAGE_SIZE -1) & ~(PAGE_SIZE -1));

  00154	e59e3000	 ldr         r3, [lr]
  00158	e1a02003	 mov         r2, r3
  0015c	e0833120	 add         r3, r3, r0, lsr #2
  00160	e2433001	 sub         r3, r3, #1
  00164	e2422001	 sub         r2, r2, #1
  00168	e1c39002	 bic         r9, r3, r2

; 665  :     }
; 666  :     else

  0016c	ea000000	 b           |$LN11@Initialize|
  00170		 |$LN12@Initialize|

; 667  :     {
; 668  :         pPddObject->dwPhysicalMemSize = 0;

  00170	e585b018	 str         r11, [r5, #0x18]
  00174		 |$LN11@Initialize|

; 669  :     }
; 670  : 
; 671  :     if (pPddObject->dwPhysicalMemSize < gcTotalAvailablePhysicalMemory)

  00174	e5953018	 ldr         r3, [r5, #0x18]

; 672  :     {
; 673  :         pPddObject->dwPhysicalMemSize = gcTotalAvailablePhysicalMemory;
; 674  :         dwHPPhysicalMemSize = gcHighPriorityPhysicalMemory;
; 675  :     }
; 676  : 
; 677  : #if (EHCI_DMA_ALLOC)
; 678  :     // Fill out the DMA adapter descriptor.  The bus address and type is irrelevant
; 679  :     pPddObject->AdapterObject.ObjectSize    = sizeof(DMA_ADAPTER_OBJECT);
; 680  :     pPddObject->AdapterObject.InterfaceType = PCIBus;
; 681  :     pPddObject->AdapterObject.BusNumber     = 0;
; 682  : 
; 683  : 
; 684  :     if ((pPddObject->pvVirtualAddress = HalAllocateCommonBuffer(&pPddObject->AdapterObject, pPddObject->dwPhysicalMemSize, &pPddObject->LogicalAddress, FALSE)) == NULL)
; 685  :     {
; 686  :         DEBUGMSG(ZONE_ERROR, (TEXT("EHCI - HalAllocateCommonBuffer Failed 0x%x\r\n"), GetLastError()));
; 687  :         goto InitializeEHCI_Error;
; 688  :     }
; 689  : 
; 690  : 
; 691  :     pobMem = HcdMdd_CreateMemoryObject(pPddObject->dwPhysicalMemSize, dwHPPhysicalMemSize, (PUCHAR) pPddObject->pvVirtualAddress, (PUCHAR) pPddObject->LogicalAddress.LowPart);
; 692  : #endif
; 693  : 
; 694  : 	pobMem = HcdMdd_CreateMemoryObject(pPddObject->dwPhysicalMemSize, dwHPPhysicalMemSize, NULL, NULL);

  00178	e3a02000	 mov         r2, #0
  0017c	e3530802	 cmp         r3, #2, 16
  00180	33a03802	 movcc       r3, #2, 16
  00184	35853018	 strcc       r3, [r5, #0x18]
  00188	e5950018	 ldr         r0, [r5, #0x18]
  0018c	33a09902	 movcc       r9, #2, 18
  00190	e3a03000	 mov         r3, #0
  00194	e1a01009	 mov         r1, r9
  00198	eb000000	 bl          HcdMdd_CreateMemoryObject
  0019c	e1b04000	 movs        r4, r0

; 695  :     if (!pobMem)

  001a0	0a000025	 beq         |$InitializeEHCI_Error$45177|

; 696  :     {
; 697  :         DEBUGMSG(ZONE_ERROR, (TEXT("EHCI - HcdMdd_CreateMemoryObject Failed 0x%x\r\n"), GetLastError()));
; 698  :         goto InitializeEHCI_Error;
; 699  :     }
; 700  : 
; 701  : 	pobEHCD = HcdMdd_CreateHcdObject(pPddObject, pobMem, szDriverRegKey, pPddObject->ioPortBase, pPddObject->dwSysIntr);

  001a4	e5951240	 ldr         r1, [r5, #0x240]
  001a8	e595323c	 ldr         r3, [r5, #0x23C]
  001ac	e1a02008	 mov         r2, r8
  001b0	e58d1000	 str         r1, [sp]
  001b4	e1a01004	 mov         r1, r4
  001b8	e1a00005	 mov         r0, r5
  001bc	eb000000	 bl          HcdMdd_CreateHcdObject
  001c0	e1b06000	 movs        r6, r0

; 702  :     if (!pobEHCD)

  001c4	0a00001c	 beq         |$InitializeEHCI_Error$45177|

; 703  :     {
; 704  :         DEBUGMSG(ZONE_ERROR, (TEXT("EHCI - HcdMdd_CreateHcdObject Failed 0x%x\r\n"), GetLastError()));
; 705  :         goto InitializeEHCI_Error;
; 706  :     }
; 707  : 
; 708  :     pPddObject->lpvMemoryObject  = pobMem;
; 709  :     pPddObject->lpvEHCDMddObject = pobEHCD;
; 710  : 
; 711  :     _tcsncpy(pPddObject->szDriverRegKey, szDriverRegKey, MAX_PATH);

  001c8	e3a02f41	 mov         r2, #0x41, 30
  001cc	e1a01008	 mov         r1, r8
  001d0	e2850034	 add         r0, r5, #0x34
  001d4	e585400c	 str         r4, [r5, #0xC]
  001d8	e5856010	 str         r6, [r5, #0x10]
  001dc	eb000000	 bl          wcsncpy

; 712  : 
; 713  :     if (hKey != NULL)

  001e0	e59d0008	 ldr         r0, [sp, #8]
  001e4	e3500000	 cmp         r0, #0
  001e8	0a00000f	 beq         |$LN7@Initialize|

; 714  :     {
; 715  :         DWORD dwCapability;
; 716  :         DWORD dwType;
; 717  :         DWORD dwLength = sizeof(DWORD);
; 718  :         if (RegQueryValueEx(hKey, HCD_CAPABILITY_VALNAME, 0, &dwType, (PUCHAR)&dwCapability, &dwLength) == ERROR_SUCCESS)

  001ec	e59f10c4	 ldr         r1, [pc, #0xC4]
  001f0	e3a07004	 mov         r7, #4
  001f4	e28de018	 add         lr, sp, #0x18
  001f8	e28d4014	 add         r4, sp, #0x14
  001fc	e28d301c	 add         r3, sp, #0x1C
  00200	e3a02000	 mov         r2, #0
  00204	e58d7018	 str         r7, [sp, #0x18]
  00208	e58de004	 str         lr, [sp, #4]
  0020c	e58d4000	 str         r4, [sp]
  00210	eb000000	 bl          RegQueryValueExW
  00214	e3500000	 cmp         r0, #0

; 719  :         {
; 720  :             HcdMdd_SetCapability(pobEHCD, dwCapability);

  00218	059d1014	 ldreq       r1, [sp, #0x14]
  0021c	01a00006	 moveq       r0, r6
  00220	0b000000	 bleq        HcdMdd_SetCapability

; 721  :         }
; 722  :         RegCloseKey(hKey);

  00224	e59d0008	 ldr         r0, [sp, #8]
  00228	eb000000	 bl          RegCloseKey
  0022c		 |$LN7@Initialize|

; 723  :     }
; 724  : 
; 725  :     ExternalDeviceDeassertReset(pPddObject);

  0022c	e1a00005	 mov         r0, r5
  00230	eb000000	 bl          ExternalDeviceDeassertReset

; 726  :     return TRUE;

  00234	e3a00001	 mov         r0, #1
  00238	ea00001b	 b           |$LN16@Initialize|
  0023c		 |$InitializeEHCI_Error$45177|

; 727  : 
; 728  : InitializeEHCI_Error:
; 729  :     if (pPddObject->IsrHandle)

  0023c	e5953258	 ldr         r3, [r5, #0x258]
  00240	e3530000	 cmp         r3, #0
  00244	0a000002	 beq         |$LN5@Initialize|

; 730  :     {
; 731  :         FreeIntChainHandler(pPddObject->IsrHandle);

  00248	e1a00003	 mov         r0, r3
  0024c	eb000000	 bl          FreeIntChainHandler

; 732  :         pPddObject->IsrHandle = NULL;

  00250	e585b258	 str         r11, [r5, #0x258]
  00254		 |$LN5@Initialize|

; 733  :     }
; 734  : 
; 735  :     if (pobEHCD)

  00254	e3560000	 cmp         r6, #0

; 736  :         HcdMdd_DestroyHcdObject(pobEHCD);

  00258	11a00006	 movne       r0, r6
  0025c	1b000000	 blne        HcdMdd_DestroyHcdObject

; 737  :     if (pobMem)

  00260	e3540000	 cmp         r4, #0

; 738  :         HcdMdd_DestroyMemoryObject(pobMem);

  00264	11a00004	 movne       r0, r4
  00268	1b000000	 blne        HcdMdd_DestroyMemoryObject

; 739  :     if (pPddObject->pvVirtualAddress)

  0026c	e5953014	 ldr         r3, [r5, #0x14]
  00270	e1b0e003	 movs        lr, r3

; 740  :         HalFreeCommonBuffer(&pPddObject->AdapterObject, pPddObject->dwPhysicalMemSize, pPddObject->LogicalAddress, pPddObject->pvVirtualAddress, FALSE);

  00274	15952020	 ldrne       r2, [r5, #0x20]
  00278	15953024	 ldrne       r3, [r5, #0x24]
  0027c	15951018	 ldrne       r1, [r5, #0x18]
  00280	12850028	 addne       r0, r5, #0x28
  00284	158db004	 strne       r11, [sp, #4]
  00288	158de000	 strne       lr, [sp]
  0028c	1b000000	 blne        HalFreeCommonBuffer

; 741  : 
; 742  :     pPddObject->lpvMemoryObject = NULL;
; 743  :     pPddObject->lpvEHCDMddObject = NULL;
; 744  :     pPddObject->pvVirtualAddress = NULL;
; 745  :     if (hKey != NULL)

  00290	e59d0008	 ldr         r0, [sp, #8]
  00294	e585b00c	 str         r11, [r5, #0xC]
  00298	e585b010	 str         r11, [r5, #0x10]
  0029c	e3500000	 cmp         r0, #0
  002a0	e585b014	 str         r11, [r5, #0x14]

; 746  :         RegCloseKey(hKey);

  002a4	1b000000	 blne        RegCloseKey
  002a8		 |$LN1@Initialize|

; 747  : 
; 748  :     return FALSE;

  002a8	e3a00000	 mov         r0, #0

; 726  :     return TRUE;

  002ac		 |$LN16@Initialize|

; 749  : }

  002ac	e28dd020	 add         sp, sp, #0x20
  002b0	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  002b4	e12fff1e	 bx          lr
  002b8		 |$LN26@Initialize|
  002b8		 |$LN27@Initialize|
  002b8	00000000	 DCD         |??_C@_1BM@KKKMKIHE@?$AAH?$AAc?$AAd?$AAC?$AAa?$AAp?$AAa?$AAb?$AAi?$AAl?$AAi?$AAt?$AAy?$AA?$AA@|
  002bc		 |$LN28@Initialize|
  002bc	00000000	 DCD         |??_C@_1CC@NPEFILDH@?$AAP?$AAh?$AAy?$AAs?$AAi?$AAc?$AAa?$AAl?$AAP?$AAa?$AAg?$AAe?$AAS?$AAi?$AAz?$AAe?$AA?$AA@|
  002c0		 |$LN29@Initialize|
  002c0	01010098	 DCD         0x1010098
  002c4		 |$M45820|

			 ENDP  ; |InitializeEHCI|

	EXPORT	|HcdPdd_Init|
	EXPORT	|??_C@_1HC@CMFPDCNE@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAH?$AAc?$AAd?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAo?$AAp?$AAe?$AAn?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1M@IMFGGFBL@?$AAB?$AAU?$AAS?$AA1?$AA?3?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HO@PPCCOIND@?$AAE?$AAH?$AAC?$AAI?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAu?$AAr?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AA?5?$AAb?$AAu?$AAs?$AA?5?$AAa?$AAc?$AAc?$AAe@| [ DATA ] ; `string'
	IMPORT	|CloseBusAccessHandle|
	IMPORT	|free|
	IMPORT	|DeleteCriticalSection|
	IMPORT	|RequestDevicePads|
	IMPORT	|DeviceIoControl|
	IMPORT	|CreateFileW|
	IMPORT	|GPIOOpen|
	IMPORT	|SOCGetUSBHInfo|
	IMPORT	|SetDevicePowerState|
	IMPORT	|NKDbgPrintfW|
	IMPORT	|CreateBusAccessHandle|
	IMPORT	|g_dwContext|
	IMPORT	|GetDeviceRegistryParams|
	IMPORT	|InitializeCriticalSection|
	IMPORT	|malloc|

  00000			 AREA	 |.pdata|, PDATA
|$T45840| DCD	|$LN31@HcdPdd_Ini|
	DCD	0x40009f02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HC@CMFPDCNE@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAH?$AAc?$AAd?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAo?$AAp?$AAe?$AAn?$AA?5@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "H", 0x0, "c", 0x0, "d", 0x0, "P", 0x0, "d", 0x0, "d"
	DCB	0x0, "_", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, ":"
	DCB	0x0, " ", 0x0, "F", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e"
	DCB	0x0, "d", 0x0, " ", 0x0, "o", 0x0, "p", 0x0, "e", 0x0, "n"
	DCB	0x0, " ", 0x0, "r", 0x0, "o", 0x0, "o", 0x0, "t", 0x0, " "
	DCB	0x0, "b", 0x0, "u", 0x0, "s", 0x0, " ", 0x0, "d", 0x0, "r"
	DCB	0x0, "i", 0x0, "v", 0x0, "e", 0x0, "r", 0x0, " ", 0x0, "h"
	DCB	0x0, "a", 0x0, "n", 0x0, "d", 0x0, "l", 0x0, "e", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1M@IMFGGFBL@?$AAB?$AAU?$AAS?$AA1?$AA?3?$AA?$AA@| DCB "B", 0x0, "U", 0x0
	DCB	"S", 0x0, "1", 0x0, ":", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HO@PPCCOIND@?$AAE?$AAH?$AAC?$AAI?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAu?$AAr?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AA?5?$AAb?$AAu?$AAs?$AA?5?$AAa?$AAc?$AAc?$AAe@| DCB "E"
	DCB	0x0, "H", 0x0, "C", 0x0, "I", 0x0, ":", 0x0, " ", 0x0, "F"
	DCB	0x0, "a", 0x0, "i", 0x0, "l", 0x0, "u", 0x0, "r", 0x0, "e"
	DCB	0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "c", 0x0, "r"
	DCB	0x0, "e", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, " ", 0x0, "b"
	DCB	0x0, "u", 0x0, "s", 0x0, " ", 0x0, "a", 0x0, "c", 0x0, "c"
	DCB	0x0, "e", 0x0, "s", 0x0, "s", 0x0, " ", 0x0, "h", 0x0, "a"
	DCB	0x0, "n", 0x0, "d", 0x0, "l", 0x0, "e", 0x0, ".", 0x0, " "
	DCB	0x0, " ", 0x0, "g", 0x0, "_", 0x0, "d", 0x0, "w", 0x0, "C"
	DCB	0x0, "o", 0x0, "n", 0x0, "t", 0x0, "e", 0x0, "x", 0x0, "t"
	DCB	0x0, " ", 0x0, "=", 0x0, " ", 0x0, "%", 0x0, "s", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_Init| PROC

; 762  : {

  00000		 |$LN31@HcdPdd_Ini|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M45837|
  00008	e1a06000	 mov         r6, r0

; 763  :     SEHCDPdd *  pPddObject = malloc(sizeof(SEHCDPdd));

  0000c	e3a00fb2	 mov         r0, #0xB2, 30
  00010	eb000000	 bl          malloc

; 764  :     BOOL        fRet = FALSE;
; 765  :     extern DWORD g_dwContext;
; 766  : 	DWORD dwClock = OMAP_DEVICE_NONE;

  00014	e3e03000	 mvn         r3, #0
  00018	e58d3010	 str         r3, [sp, #0x10]
  0001c	e1b04000	 movs        r4, r0

; 767  : 
; 768  :     DEBUGMSG(ZONE_INFO, (TEXT("EHCI USB Host: HcdPdd_Init+\r\n")));
; 769  : 
; 770  :     if (pPddObject)

  00020	0a00008b	 beq         |$LN4@HcdPdd_Ini|

; 771  :     {
; 772  :         pPddObject->pvVirtualAddress = NULL;
; 773  :         InitializeCriticalSection(&pPddObject->csPdd);

  00024	e3a07000	 mov         r7, #0
  00028	e2840f91	 add         r0, r4, #0x91, 30
  0002c	e5847014	 str         r7, [r4, #0x14]
  00030	eb000000	 bl          InitializeCriticalSection

; 774  :         pPddObject->IsrHandle = NULL;
; 775  : 
; 776  :         // Read device parameters
; 777  :         if (GetDeviceRegistryParams((LPCWSTR)dwContext, pPddObject,
; 778  :             dimof(g_deviceRegParams), g_deviceRegParams) != ERROR_SUCCESS)

  00034	e59f323c	 ldr         r3, [pc, #0x23C]
  00038	e3a02010	 mov         r2, #0x10
  0003c	e1a01004	 mov         r1, r4
  00040	e1a00006	 mov         r0, r6
  00044	e5847258	 str         r7, [r4, #0x258]
  00048	eb000000	 bl          GetDeviceRegistryParams
  0004c	e3500000	 cmp         r0, #0
  00050	1a000067	 bne         |$LN27@HcdPdd_Ini|

; 779  :         {
; 780  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: HcdPdd_Init: Failed read registry parameters\r\n"));
; 781  :             goto cleanUp;
; 782  :         }
; 783  : 
; 784  :         pPddObject->hParentBusHandle = CreateBusAccessHandle( (LPCTSTR) g_dwContext ) ;

  00054	e59f5218	 ldr         r5, [pc, #0x218]
  00058	e5950000	 ldr         r0, [r5]
  0005c	eb000000	 bl          CreateBusAccessHandle
  00060	e3500000	 cmp         r0, #0
  00064	e58402bc	 str         r0, [r4, #0x2BC]

; 785  :         if (pPddObject->hParentBusHandle == NULL)

  00068	1a000003	 bne         |$LN21@HcdPdd_Ini|

; 786  : 		{
; 787  :             RETAILMSG(TRUE, (TEXT("EHCI: Failure to create bus access handle.  g_dwContext = %s\r\n"), (char *)g_dwContext));

  0006c	e5951000	 ldr         r1, [r5]
  00070	e59f01f8	 ldr         r0, [pc, #0x1F8]
  00074	eb000000	 bl          NKDbgPrintfW

; 788  : 			goto cleanUp;

  00078	ea00005d	 b           |$LN27@HcdPdd_Ini|
  0007c		 |$LN21@HcdPdd_Ini|

; 789  : 		}
; 790  : 
; 791  :         SetDevicePowerState(pPddObject->hParentBusHandle, D0, NULL);

  0007c	e3a02000	 mov         r2, #0
  00080	e3a01000	 mov         r1, #0
  00084	eb000000	 bl          SetDevicePowerState

; 792  : 
; 793  : 		// Retrieve SOC specific info
; 794  : 		SOCGetUSBHInfo(&pPddObject->USBHInfo);

  00088	e2840fa5	 add         r0, r4, #0xA5, 30
  0008c	eb000000	 bl          SOCGetUSBHInfo

; 795  : 
; 796  :         // Open GPIO driver
; 797  :         pPddObject->hGpio = GPIOOpen();

  00090	eb000000	 bl          GPIOOpen
  00094	e5840290	 str         r0, [r4, #0x290]

; 798  :         if (pPddObject->hGpio == INVALID_HANDLE_VALUE)

  00098	e3700001	 cmn         r0, #1
  0009c	0a000054	 beq         |$LN27@HcdPdd_Ini|

; 799  : 		{
; 800  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: HcdPdd_Init: Failed to open GPIO driver\r\n"));
; 801  :             goto cleanUp;
; 802  : 		}
; 803  : 
; 804  :         // open root bus driver
; 805  :         pPddObject->hRootBus = CreateFile(L"BUS1:", 0, 0, NULL, 0, 0, 0 );

  000a0	e59f01c4	 ldr         r0, [pc, #0x1C4]
  000a4	e3a03000	 mov         r3, #0
  000a8	e3a02000	 mov         r2, #0
  000ac	e3a01000	 mov         r1, #0
  000b0	e58d7008	 str         r7, [sp, #8]
  000b4	e58d7004	 str         r7, [sp, #4]
  000b8	e58d7000	 str         r7, [sp]
  000bc	eb000000	 bl          CreateFileW
  000c0	e3500000	 cmp         r0, #0
  000c4	e58402c0	 str         r0, [r4, #0x2C0]

; 806  :         if (pPddObject->hRootBus == NULL)

  000c8	1a000002	 bne         |$LN19@HcdPdd_Ini|

; 807  :         {
; 808  :             RETAILMSG(TRUE, (L"ERROR: HcdPdd_Init: Failed open root bus driver handle\r\n"));

  000cc	e59f0194	 ldr         r0, [pc, #0x194]
  000d0	eb000000	 bl          NKDbgPrintfW

; 809  :             goto cleanUp;

  000d4	ea000046	 b           |$LN27@HcdPdd_Ini|
  000d8		 |$LN19@HcdPdd_Ini|

; 810  :         }
; 811  : 
; 812  :         // enable USBTLL clocks
; 813  : 		dwClock = pPddObject->USBHInfo.TLLDevice;

  000d8	e5942298	 ldr         r2, [r4, #0x298]
  000dc	e3a01822	 mov         r1, #0x22, 16

; 814  :         if (!DeviceIoControl(pPddObject->hRootBus, IOCTL_BUS_REQUEST_CLOCK, &dwClock, sizeof(dwClock), NULL, 0, NULL, NULL))

  000e0	e3a03004	 mov         r3, #4
  000e4	e58d2010	 str         r2, [sp, #0x10]
  000e8	e28d2010	 add         r2, sp, #0x10
  000ec	e3811b03	 orr         r1, r1, #3, 22
  000f0	e58d700c	 str         r7, [sp, #0xC]
  000f4	e58d7008	 str         r7, [sp, #8]
  000f8	e58d7004	 str         r7, [sp, #4]
  000fc	e58d7000	 str         r7, [sp]
  00100	eb000000	 bl          DeviceIoControl
  00104	e3500000	 cmp         r0, #0
  00108	0a000039	 beq         |$LN27@HcdPdd_Ini|

; 815  :         {
; 816  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: HcdPdd_Init: IOCTL_BUS_REQUEST_CLOCK failed\r\n"));
; 817  :             goto cleanUp;
; 818  :         }
; 819  : 
; 820  : 		// Request Pads and enable clocks for each host device if enabled
; 821  : 		if (pPddObject->port1Mode != USB_PORT_NOT_USED)

  0010c	e5943260	 ldr         r3, [r4, #0x260]
  00110	e3530000	 cmp         r3, #0
  00114	0a000003	 beq         |$LN16@HcdPdd_Ini|

; 822  : 		{
; 823  : 			if (!RequestDevicePads(pPddObject->USBHInfo.Host1Device))

  00118	e594029c	 ldr         r0, [r4, #0x29C]
  0011c	eb000000	 bl          RequestDevicePads
  00120	e3500000	 cmp         r0, #0
  00124	0a000032	 beq         |$LN27@HcdPdd_Ini|
  00128		 |$LN16@HcdPdd_Ini|

; 824  :             {
; 825  :                 DEBUGMSG(ZONE_ERROR, (L"ERROR: HcdPdd_Init: Failed to request pads for port 1\r\n"));
; 826  :                 goto cleanUp;
; 827  :             }
; 828  : 
; 829  : 		}
; 830  : 		if (pPddObject->port2Mode != USB_PORT_NOT_USED)

  00128	e5943264	 ldr         r3, [r4, #0x264]
  0012c	e3530000	 cmp         r3, #0
  00130	0a000003	 beq         |$LN14@HcdPdd_Ini|

; 831  : 		{
; 832  :             if (!RequestDevicePads(pPddObject->USBHInfo.Host2Device))

  00134	e59402a0	 ldr         r0, [r4, #0x2A0]
  00138	eb000000	 bl          RequestDevicePads
  0013c	e3500000	 cmp         r0, #0
  00140	0a00002b	 beq         |$LN27@HcdPdd_Ini|
  00144		 |$LN14@HcdPdd_Ini|

; 833  :             {
; 834  :                 DEBUGMSG(ZONE_ERROR, (L"ERROR: HcdPdd_Init: Failed to request pads for port 2\r\n"));
; 835  :                 goto cleanUp;
; 836  :             }
; 837  : 		}
; 838  : 		if (pPddObject->port3Mode != USB_PORT_NOT_USED)

  00144	e5943268	 ldr         r3, [r4, #0x268]
  00148	e3530000	 cmp         r3, #0
  0014c	0a000003	 beq         |$LN12@HcdPdd_Ini|

; 839  : 		{
; 840  : 			if (!RequestDevicePads(pPddObject->USBHInfo.Host3Device))

  00150	e59402a4	 ldr         r0, [r4, #0x2A4]
  00154	eb000000	 bl          RequestDevicePads
  00158	e3500000	 cmp         r0, #0
  0015c	0a000024	 beq         |$LN27@HcdPdd_Ini|
  00160		 |$LN12@HcdPdd_Ini|

; 841  :             {
; 842  :                 DEBUGMSG(ZONE_ERROR, (L"ERROR: HcdPdd_Init: Failed to request pads for port 3\r\n"));
; 843  :                 goto cleanUp;
; 844  :             }
; 845  : 		}
; 846  : 
; 847  : 		// Configure reset pins as outputs
; 848  : 		if (pPddObject->Port1RstGpio != -1)

  00160	e5941278	 ldr         r1, [r4, #0x278]
  00164	e3710001	 cmn         r1, #1

; 849  : 		{
; 850  : 			GPIOSetMode(pPddObject->hGpio, pPddObject->Port1RstGpio ,GPIO_DIR_OUTPUT);

  00168	15940290	 ldrne       r0, [r4, #0x290]
  0016c	13a02000	 movne       r2, #0
  00170	1b000000	 blne        GPIOSetMode

; 851  : 		}
; 852  : 		if (pPddObject->Port2RstGpio != -1)

  00174	e594127c	 ldr         r1, [r4, #0x27C]
  00178	e3710001	 cmn         r1, #1

; 853  : 		{
; 854  : 			GPIOSetMode(pPddObject->hGpio, pPddObject->Port2RstGpio ,GPIO_DIR_OUTPUT);

  0017c	15940290	 ldrne       r0, [r4, #0x290]
  00180	13a02000	 movne       r2, #0
  00184	1b000000	 blne        GPIOSetMode

; 855  : 		}
; 856  : 		if (pPddObject->Port3RstGpio != -1)

  00188	e5941280	 ldr         r1, [r4, #0x280]
  0018c	e3710001	 cmn         r1, #1

; 857  : 		{
; 858  : 			GPIOSetMode(pPddObject->hGpio, pPddObject->Port3RstGpio ,GPIO_DIR_OUTPUT);

  00190	15940290	 ldrne       r0, [r4, #0x290]
  00194	13a02000	 movne       r2, #0
  00198	1b000000	 blne        GPIOSetMode

; 859  : 		}
; 860  : 
; 861  :         Sleep(10);

  0019c	e3a0000a	 mov         r0, #0xA
  001a0	eb000000	 bl          Sleep

; 862  : 
; 863  :         fRet = InitializeEHCI(pPddObject, (LPCWSTR)dwContext);

  001a4	e1a01006	 mov         r1, r6
  001a8	e1a00004	 mov         r0, r4
  001ac	eb000000	 bl          InitializeEHCI
  001b0	e3500000	 cmp         r0, #0

; 864  : 
; 865  :         if (fRet)

  001b4	0a000009	 beq         |$LN26@HcdPdd_Ini|

; 866  : 		{
; 867  : 			if (pPddObject->BusSuspendResume)

  001b8	e5943008	 ldr         r3, [r4, #8]

; 868  : 	            HcdMdd_SetCapability(pPddObject->lpvEHCDMddObject, HCD_SUSPEND_RESUME | HCD_ROOT_HUB_INTERRUPT);

  001bc	e5940010	 ldr         r0, [r4, #0x10]
  001c0	e3530000	 cmp         r3, #0
  001c4	0a000002	 beq         |$LN7@HcdPdd_Ini|
  001c8	e3a01003	 mov         r1, #3

; 869  :     	    else
; 870  :         	    HcdMdd_SetCapability(pPddObject->lpvEHCDMddObject, HCD_ROOT_HUB_INTERRUPT);

  001cc	eb000000	 bl          HcdMdd_SetCapability

; 871  : 		}
; 872  : 
; 873  :         if(!fRet)

  001d0	ea00001f	 b           |$LN4@HcdPdd_Ini|
  001d4		 |$LN7@HcdPdd_Ini|

; 869  :     	    else
; 870  :         	    HcdMdd_SetCapability(pPddObject->lpvEHCDMddObject, HCD_ROOT_HUB_INTERRUPT);

  001d4	e3a01002	 mov         r1, #2
  001d8	eb000000	 bl          HcdMdd_SetCapability

; 871  : 		}
; 872  : 
; 873  :         if(!fRet)

  001dc	ea00001c	 b           |$LN4@HcdPdd_Ini|
  001e0		 |$LN26@HcdPdd_Ini|

; 874  :         {
; 875  :             DeleteCriticalSection(&pPddObject->csPdd);

  001e0	e2840f91	 add         r0, r4, #0x91, 30
  001e4	eb000000	 bl          DeleteCriticalSection

; 876  :             free(pPddObject);

  001e8	e1a00004	 mov         r0, r4
  001ec	eb000000	 bl          free

; 877  :             pPddObject = NULL;

  001f0	e3a04000	 mov         r4, #0
  001f4		 |$cleanUp$45215|
  001f4		 |$LN27@HcdPdd_Ini|

; 878  :         }
; 879  :     }
; 880  : 
; 881  : cleanUp:
; 882  :     if (!fRet && pPddObject != NULL)

  001f4	e3540000	 cmp         r4, #0
  001f8	0a000015	 beq         |$LN4@HcdPdd_Ini|

; 883  :     {
; 884  :         if (pPddObject->lpvEHCDMddObject != NULL)

  001fc	e5943010	 ldr         r3, [r4, #0x10]
  00200	e3530000	 cmp         r3, #0

; 885  :         HcdMdd_DestroyHcdObject(pPddObject->lpvEHCDMddObject);

  00204	11a00003	 movne       r0, r3
  00208	1b000000	 blne        HcdMdd_DestroyHcdObject

; 886  :         if (pPddObject->lpvMemoryObject != NULL)

  0020c	e594300c	 ldr         r3, [r4, #0xC]
  00210	e3530000	 cmp         r3, #0

; 887  :         HcdMdd_DestroyMemoryObject(pPddObject->lpvMemoryObject);

  00214	11a00003	 movne       r0, r3
  00218	1b000000	 blne        HcdMdd_DestroyMemoryObject

; 888  :         if (pPddObject->dwSysIntr != 0)

  0021c	e5943240	 ldr         r3, [r4, #0x240]
  00220	e3530000	 cmp         r3, #0

; 889  :         KernelIoControl(IOCTL_HAL_RELEASE_SYSINTR, (PVOID)&pPddObject->dwSysIntr,
; 890  :             sizeof(&pPddObject->dwSysIntr), NULL, 0, NULL);

  00224	159f0038	 ldrne       r0, [pc, #0x38]
  00228	13a03000	 movne       r3, #0
  0022c	13a02004	 movne       r2, #4
  00230	12841d09	 addne       r1, r4, #9, 26
  00234	158d7004	 strne       r7, [sp, #4]
  00238	158d7000	 strne       r7, [sp]
  0023c	1b000000	 blne        KernelIoControl

; 891  :         CloseBusAccessHandle(pPddObject->hParentBusHandle);

  00240	e59402bc	 ldr         r0, [r4, #0x2BC]
  00244	eb000000	 bl          CloseBusAccessHandle

; 892  :         free(pPddObject);

  00248	e1a00004	 mov         r0, r4
  0024c	eb000000	 bl          free

; 893  :         pPddObject = NULL;

  00250	e3a04000	 mov         r4, #0
  00254		 |$LN4@HcdPdd_Ini|

; 894  :     }
; 895  : 
; 896  :     DEBUGMSG(ZONE_INFO, (TEXT("EHCI USB Host: HcdPdd_Init -\r\n")));
; 897  : 
; 898  :     return (DWORD)pPddObject;
; 899  : }

  00254	e1a00004	 mov         r0, r4
  00258	e28dd014	 add         sp, sp, #0x14
  0025c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00260	e12fff1e	 bx          lr
  00264		 |$LN32@HcdPdd_Ini|
  00264		 |$LN33@HcdPdd_Ini|
  00264	010100d8	 DCD         0x10100d8
  00268		 |$LN34@HcdPdd_Ini|
  00268	00000000	 DCD         |??_C@_1HC@CMFPDCNE@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAH?$AAc?$AAd?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAo?$AAp?$AAe?$AAn?$AA?5@|
  0026c		 |$LN35@HcdPdd_Ini|
  0026c	00000000	 DCD         |??_C@_1M@IMFGGFBL@?$AAB?$AAU?$AAS?$AA1?$AA?3?$AA?$AA@|
  00270		 |$LN36@HcdPdd_Ini|
  00270	00000000	 DCD         |??_C@_1HO@PPCCOIND@?$AAE?$AAH?$AAC?$AAI?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAu?$AAr?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AA?5?$AAb?$AAu?$AAs?$AA?5?$AAa?$AAc?$AAc?$AAe@|
  00274		 |$LN37@HcdPdd_Ini|
  00274	00000000	 DCD         |g_dwContext|
  00278		 |$LN38@HcdPdd_Ini|
  00278	00000000	 DCD         |g_deviceRegParams|
  0027c		 |$M45838|

			 ENDP  ; |HcdPdd_Init|

	EXPORT	|HcdPdd_CheckConfigPower|

  00000			 AREA	 |.pdata|, PDATA
|$T45860| DCD	|$LN7@HcdPdd_Che|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_CheckConfigPower| PROC

; 915  : {

  00000		 |$LN7@HcdPdd_Che|
  00000		 |$M45857|

; 916  : 	UNREFERENCED_PARAMETER(bPort);
; 917  : 
; 918  :     return ((dwCfgPower + dwTotalPower) > 500) ? FALSE : TRUE;

  00000	e0813002	 add         r3, r1, r2
  00004	e3530f7d	 cmp         r3, #0x7D, 30
  00008	83a00000	 movhi       r0, #0
  0000c	93a00001	 movls       r0, #1

; 919  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M45858|

			 ENDP  ; |HcdPdd_CheckConfigPower|

	EXPORT	|HcdPdd_PowerUp|

  00000			 AREA	 |.pdata|, PDATA
|$T45867| DCD	|$LN5@HcdPdd_Pow|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_PowerUp| PROC

; 922  : {

  00000		 |$LN5@HcdPdd_Pow|
  00000		 |$M45864|

; 923  :     UNREFERENCED_PARAMETER(hDeviceContext);
; 924  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M45865|

			 ENDP  ; |HcdPdd_PowerUp|

	EXPORT	|HcdPdd_PowerDown|

  00000			 AREA	 |.pdata|, PDATA
|$T45875| DCD	|$LN5@HcdPdd_Pow@2|
	DCD	0x40001702
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_PowerDown| PROC

; 927  : {

  00000		 |$LN5@HcdPdd_Pow@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M45872|
  00008	e1a04000	 mov         r4, r0

; 928  : 	SEHCDPdd * pPddObject = (SEHCDPdd *)hDeviceContext;
; 929  : 	DWORD dwClock = pPddObject->USBHInfo.TLLDevice;

  0000c	e5943298	 ldr         r3, [r4, #0x298]

; 930  : 
; 931  :     SetDevicePowerState(pPddObject->hParentBusHandle, D4, NULL);

  00010	e59402bc	 ldr         r0, [r4, #0x2BC]
  00014	e3a02000	 mov         r2, #0
  00018	e3a01004	 mov         r1, #4
  0001c	e58d3010	 str         r3, [sp, #0x10]
  00020	eb000000	 bl          SetDevicePowerState

; 932  :     DeviceIoControl(pPddObject->hRootBus, IOCTL_BUS_RELEASE_CLOCK, &dwClock, sizeof(dwClock), NULL, 0, NULL, NULL);

  00024	e59f102c	 ldr         r1, [pc, #0x2C]
  00028	e59402c0	 ldr         r0, [r4, #0x2C0]
  0002c	e3a0e000	 mov         lr, #0
  00030	e3a03004	 mov         r3, #4
  00034	e28d2010	 add         r2, sp, #0x10
  00038	e58de00c	 str         lr, [sp, #0xC]
  0003c	e58de008	 str         lr, [sp, #8]
  00040	e58de004	 str         lr, [sp, #4]
  00044	e58de000	 str         lr, [sp]
  00048	eb000000	 bl          DeviceIoControl

; 933  : }

  0004c	e28dd014	 add         sp, sp, #0x14
  00050	e8bd4010	 ldmia       sp!, {r4, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$LN6@HcdPdd_Pow@2|
  00058		 |$LN7@HcdPdd_Pow@2|
  00058	00220c04	 DCD         0x220c04
  0005c		 |$M45873|

			 ENDP  ; |HcdPdd_PowerDown|

	EXPORT	|HcdPdd_Deinit|
	IMPORT	|CloseHandle|

  00000			 AREA	 |.pdata|, PDATA
|$T45888| DCD	|$LN10@HcdPdd_Dei@3|
	DCD	0x40002702
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_Deinit| PROC

; 936  : {

  00000		 |$LN10@HcdPdd_Dei@3|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M45885|
  00008	e1a04000	 mov         r4, r0

; 937  :     SEHCDPdd * pPddObject = (SEHCDPdd *)hDeviceContext;
; 938  : 
; 939  :     if(pPddObject->lpvEHCDMddObject)

  0000c	e5943010	 ldr         r3, [r4, #0x10]
  00010	e3530000	 cmp         r3, #0

; 940  :         HcdMdd_DestroyHcdObject(pPddObject->lpvEHCDMddObject);

  00014	11a00003	 movne       r0, r3
  00018	1b000000	 blne        HcdMdd_DestroyHcdObject

; 941  :     if(pPddObject->lpvMemoryObject)

  0001c	e594300c	 ldr         r3, [r4, #0xC]
  00020	e3530000	 cmp         r3, #0

; 942  :         HcdMdd_DestroyMemoryObject(pPddObject->lpvMemoryObject);

  00024	11a00003	 movne       r0, r3
  00028	1b000000	 blne        HcdMdd_DestroyMemoryObject

; 943  :     if(pPddObject->pvVirtualAddress)

  0002c	e5943014	 ldr         r3, [r4, #0x14]
  00030	e1b0e003	 movs        lr, r3

; 944  :         HalFreeCommonBuffer(&pPddObject->AdapterObject, pPddObject->dwPhysicalMemSize, pPddObject->LogicalAddress, pPddObject->pvVirtualAddress, FALSE);

  00034	15942020	 ldrne       r2, [r4, #0x20]
  00038	15943024	 ldrne       r3, [r4, #0x24]
  0003c	15941018	 ldrne       r1, [r4, #0x18]
  00040	13a05000	 movne       r5, #0
  00044	12840028	 addne       r0, r4, #0x28
  00048	158d5004	 strne       r5, [sp, #4]
  0004c	158de000	 strne       lr, [sp]
  00050	1b000000	 blne        HalFreeCommonBuffer

; 945  :     SetDevicePowerState(pPddObject->hParentBusHandle, D4, NULL);

  00054	e59402bc	 ldr         r0, [r4, #0x2BC]
  00058	e3a02000	 mov         r2, #0
  0005c	e3a01004	 mov         r1, #4
  00060	eb000000	 bl          SetDevicePowerState

; 946  :     if (pPddObject->hParentBusHandle)

  00064	e59432bc	 ldr         r3, [r4, #0x2BC]
  00068	e3530000	 cmp         r3, #0

; 947  :         CloseBusAccessHandle(pPddObject->hParentBusHandle);

  0006c	11a00003	 movne       r0, r3
  00070	1b000000	 blne        CloseBusAccessHandle

; 948  : 	if (pPddObject->hRootBus)

  00074	e59432c0	 ldr         r3, [r4, #0x2C0]
  00078	e3530000	 cmp         r3, #0

; 949  : 		CloseHandle(pPddObject->hRootBus);

  0007c	11a00003	 movne       r0, r3
  00080	1b000000	 blne        CloseHandle

; 950  : 
; 951  :     free(pPddObject);

  00084	e1a00004	 mov         r0, r4
  00088	eb000000	 bl          free

; 952  :     return TRUE;

  0008c	e3a00001	 mov         r0, #1

; 953  : }

  00090	e28dd008	 add         sp, sp, #8
  00094	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00098	e12fff1e	 bx          lr
  0009c		 |$M45886|

			 ENDP  ; |HcdPdd_Deinit|

	EXPORT	|HcdPdd_Open|

  00000			 AREA	 |.pdata|, PDATA
|$T45898| DCD	|$LN5@HcdPdd_Ope|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_Open| PROC

; 957  : {

  00000		 |$LN5@HcdPdd_Ope|
  00000		 |$M45895|

; 958  :     UNREFERENCED_PARAMETER(hDeviceContext);
; 959  :     UNREFERENCED_PARAMETER(AccessCode);
; 960  :     UNREFERENCED_PARAMETER(ShareMode);
; 961  : #ifdef USB_IF_ELECTRICAL_TEST_MODE
; 962  :     return (DWORD) (((SEHCDPdd*)hDeviceContext)->lpvEHCDMddObject);
; 963  : #endif //#ifdef USB_IF_ELECTRICAL_TEST_MODE
; 964  : 
; 965  :     return hDeviceContext;
; 966  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M45896|

			 ENDP  ; |HcdPdd_Open|

	EXPORT	|HcdPdd_Close|

  00000			 AREA	 |.pdata|, PDATA
|$T45907| DCD	|$LN5@HcdPdd_Clo|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_Close| PROC

; 969  : {

  00000		 |$LN5@HcdPdd_Clo|
  00000		 |$M45904|

; 970  :     UNREFERENCED_PARAMETER(hOpenContext);
; 971  : 
; 972  :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 973  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M45905|

			 ENDP  ; |HcdPdd_Close|

	EXPORT	|HcdPdd_Read|

  00000			 AREA	 |.pdata|, PDATA
|$T45916| DCD	|$LN5@HcdPdd_Rea|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_Read| PROC

; 976  : {

  00000		 |$LN5@HcdPdd_Rea|
  00000		 |$M45913|

; 977  :     UNREFERENCED_PARAMETER(hOpenContext);
; 978  :     UNREFERENCED_PARAMETER(pBuffer);
; 979  :     UNREFERENCED_PARAMETER(Count);
; 980  : 
; 981  :     return (DWORD)-1; // an error occured

  00000	e3e00000	 mvn         r0, #0

; 982  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M45914|

			 ENDP  ; |HcdPdd_Read|

	EXPORT	|HcdPdd_Write|

  00000			 AREA	 |.pdata|, PDATA
|$T45925| DCD	|$LN5@HcdPdd_Wri|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_Write| PROC

; 986  : {

  00000		 |$LN5@HcdPdd_Wri|
  00000		 |$M45922|

; 987  :     UNREFERENCED_PARAMETER(hOpenContext);
; 988  :     UNREFERENCED_PARAMETER(pSourceBytes);
; 989  :     UNREFERENCED_PARAMETER(NumberOfBytes);
; 990  : 
; 991  :     return (DWORD)-1;

  00000	e3e00000	 mvn         r0, #0

; 992  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M45923|

			 ENDP  ; |HcdPdd_Write|

	EXPORT	|HcdPdd_Seek|

  00000			 AREA	 |.pdata|, PDATA
|$T45934| DCD	|$LN5@HcdPdd_See|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_Seek| PROC

; 995  : {

  00000		 |$LN5@HcdPdd_See|
  00000		 |$M45931|

; 996  :     UNREFERENCED_PARAMETER(hOpenContext);
; 997  :     UNREFERENCED_PARAMETER(Amount);
; 998  :     UNREFERENCED_PARAMETER(Type);
; 999  : 
; 1000 :     return (DWORD)-1;

  00000	e3e00000	 mvn         r0, #0

; 1001 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M45932|

			 ENDP  ; |HcdPdd_Seek|

	EXPORT	|HcdPdd_IOControl|
	EXPORT	|??_C@_1EK@FJEIBADC@?$AAE?$AAH?$AAC?$AAI?$AA?3?$AA?5?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAO?$AAW?$AAE?$AAR?$AA_?$AAS@| [ DATA ] ; `string'
	IMPORT	|HcdMdd_PowerUp|
	IMPORT	|HcdMdd_PowerDown|
	IMPORT	|__C_specific_handler|
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T45996| DCD	|$LN59@HcdPdd_IOC|
	DCD	0xc0008d04

  00000			 AREA	 |.pdata|, PDATA
|$T45998| DCD	|$LN22@HcdPdd_IOC|
	DCD	0x40000502

  00000			 AREA	 |.pdata|, PDATA
|$T46000| DCD	|$LN36@HcdPdd_IOC|
	DCD	0x40000502

  00000			 AREA	 |.pdata|, PDATA
|$T46002| DCD	|$LN29@HcdPdd_IOC|
	DCD	0x40000a02

  00000			 AREA	 |.xdata|, DATA
|$T45994| DCD	0x3
	DCD	|$LN26@HcdPdd_IOC|
	DCD	|$LN27@HcdPdd_IOC|
	DCD	|$LN22@HcdPdd_IOC|
	DCD	|$LN23@HcdPdd_IOC|
	DCD	|$LN40@HcdPdd_IOC|
	DCD	|$LN41@HcdPdd_IOC|
	DCD	|$LN36@HcdPdd_IOC|
	DCD	|$LN37@HcdPdd_IOC|
	DCD	|$LN33@HcdPdd_IOC|
	DCD	|$LN34@HcdPdd_IOC|
	DCD	|$LN29@HcdPdd_IOC|
	DCD	|$LN30@HcdPdd_IOC|

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EK@FJEIBADC@?$AAE?$AAH?$AAC?$AAI?$AA?3?$AA?5?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAO?$AAW?$AAE?$AAR?$AA_?$AAS@| DCB "E"
	DCB	0x0, "H", 0x0, "C", 0x0, "I", 0x0, ":", 0x0, " ", 0x0, "E"
	DCB	0x0, "x", 0x0, "c", 0x0, "e", 0x0, "p", 0x0, "t", 0x0, "i"
	DCB	0x0, "o", 0x0, "n", 0x0, " ", 0x0, "i", 0x0, "n", 0x0, " "
	DCB	0x0, "I", 0x0, "O", 0x0, "C", 0x0, "T", 0x0, "L", 0x0, "_"
	DCB	0x0, "P", 0x0, "O", 0x0, "W", 0x0, "E", 0x0, "R", 0x0, "_"
	DCB	0x0, "S", 0x0, "E", 0x0, "T", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T45994|

  00008		 |HcdPdd_IOControl| PROC

; 1005 : {

  00008		 |$LN59@HcdPdd_IOC|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d58f0	 stmdb       sp!, {r4 - r7, r11, r12, lr}
  00010	e28db01c	 add         r11, sp, #0x1C
  00014	e24dd020	 sub         sp, sp, #0x20
  00018		 |$LN57@HcdPdd_IOC|
  00018	e1a05000	 mov         r5, r0

; 1006 :     BOOL rc = FALSE;
; 1007 :     SEHCDPdd *pPddObject = (SEHCDPdd *)hOpenContext;
; 1008 :     DWORD dwClock = pPddObject->USBHInfo.TLLDevice;

  0001c	e5952298	 ldr         r2, [r5, #0x298]
  00020	e3a03832	 mov         r3, #0x32, 16

; 1009 : 
; 1010 :     UNREFERENCED_PARAMETER(pBufIn);
; 1011 :     UNREFERENCED_PARAMETER(dwLenIn);
; 1012 : 
; 1013 :     // Check if we get correct context
; 1014 :     if (pPddObject == NULL)
; 1015 :         {
; 1016 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: HcdPdd_IOControl: Incorrect context paramer\r\n"));
; 1017 :         goto cleanUp;
; 1018 :         }
; 1019 : 
; 1020 :     switch (dwCode)

  00024	e3833a01	 orr         r3, r3, #1, 20
  00028	e3a04000	 mov         r4, #0
  0002c	e50b2028	 str         r2, [r11, #-0x28]
  00030	e1510003	 cmp         r1, r3
  00034	e50b402c	 str         r4, [r11, #-0x2C]
  00038	0a000064	 beq         |$LN15@HcdPdd_IOC|
  0003c	e59f3244	 ldr         r3, [pc, #0x244]
  00040	e1510003	 cmp         r1, r3
  00044	0a000054	 beq         |$LN4@HcdPdd_IOC|
  00048	e59f3234	 ldr         r3, [pc, #0x234]
  0004c	e1510003	 cmp         r1, r3
  00050	0a000004	 beq         |$LN11@HcdPdd_IOC|
  00054	e59f3224	 ldr         r3, [pc, #0x224]
  00058	e1510003	 cmp         r1, r3
  0005c	1a000072	 bne         |$cleanUp$45353|

; 1040 :                         {
; 1041 :                         DEBUGMSG(ZONE_ERROR, (L"exception in ioctl\r\n"));
; 1042 :                         }
; 1043 :                 }
; 1044 :             break;
; 1045 : 
; 1046 :         // deprecated
; 1047 :         case IOCTL_POWER_QUERY:
; 1048 :             rc = TRUE;

  00060	e3a04001	 mov         r4, #1

; 1049 :             DEBUGMSG(ZONE_INFO,(L"EHCI: Received IOCTL_POWER_QUERY\r\n"));
; 1050 :             break;

  00064	ea000070	 b           |$cleanUp$45353|
  00068		 |$LN11@HcdPdd_IOC|

; 1051 : 
; 1052 :         // requests a change from one device power state to another
; 1053 :         case IOCTL_POWER_SET:
; 1054 :             DEBUGMSG(ZONE_INFO,(L"EHCI: Received IOCTL_POWER_SET\r\n"));
; 1055 :             if (pBufOut && dwLenOut >= sizeof(CEDEVICE_POWER_STATE))

  00068	e59b2000	 ldr         r2, [r11]
  0006c	e3520000	 cmp         r2, #0
  00070	0a00006d	 beq         |$cleanUp$45353|
  00074	e59b3004	 ldr         r3, [r11, #4]
  00078	e3530004	 cmp         r3, #4
  0007c	3a00006a	 bcc         |$cleanUp$45353|
  00080		 |$LN33@HcdPdd_IOC|

; 1056 :             {
; 1057 :                 __try
; 1058 :                 {
; 1059 :                     PHYSICAL_ADDRESS pa;
; 1060 :                     OMAP_UHH_REGS * pUHHRegs;
; 1061 :                     CEDEVICE_POWER_STATE ReqDx = *(PCEDEVICE_POWER_STATE)pBufOut;
; 1062 :                     DWORD RegVal = 0;
; 1063 : 
; 1064 :                     pa.QuadPart = pPddObject->USBHInfo.UHH_REGS_PA;

  00080	e59502a8	 ldr         r0, [r5, #0x2A8]
  00084	e5924000	 ldr         r4, [r2]

; 1065 :                     pUHHRegs =(OMAP_UHH_REGS *)MmMapIoSpace(pa, sizeof(OMAP_UHH_REGS), FALSE);

  00088	e3a03000	 mov         r3, #0
  0008c	e50b0024	 str         r0, [r11, #-0x24]
  00090	e3a07000	 mov         r7, #0
  00094	e50b7020	 str         r7, [r11, #-0x20]
  00098	e1a01007	 mov         r1, r7
  0009c	e3a02048	 mov         r2, #0x48
  000a0	eb000000	 bl          MmMapIoSpace
  000a4	e1a06000	 mov         r6, r0

; 1066 : 
; 1067 :                     switch (ReqDx)

  000a8	e3540000	 cmp         r4, #0
  000ac	0a000010	 beq         |$LN6@HcdPdd_IOC|
  000b0	e3540004	 cmp         r4, #4
  000b4	1a00002b	 bne         |$LN55@HcdPdd_IOC|

; 1078 :                             #if DUMP_REGS
; 1079 :                                 dumpRegs(pPddObject);
; 1080 :                             #endif
; 1081 :                             break;
; 1082 : 
; 1083 :                         case D4:
; 1084 :                             HcdMdd_PowerDown(pPddObject->lpvEHCDMddObject);

  000b8	e5950010	 ldr         r0, [r5, #0x10]
  000bc	eb000000	 bl          HcdMdd_PowerDown

; 1085 :                             g_fOmapEhciSuspended = TRUE;

  000c0	e59f31b4	 ldr         r3, [pc, #0x1B4]
  000c4	e3a04001	 mov         r4, #1

; 1086 :                             pUHHRegs->SYSCONFIG &= ~(UHH_SYSCONFIG_MIDLEMODE(0x03) | UHH_SYSCONFIG_SIDLEMODE(0x03));

  000c8	e5834000	 str         r4, [r3]
  000cc	e5962010	 ldr         r2, [r6, #0x10]
  000d0	e3e03a03	 mvn         r3, #3, 20
  000d4	e2233018	 eor         r3, r3, #0x18
  000d8	e0023003	 and         r3, r2, r3
  000dc	e5863010	 str         r3, [r6, #0x10]

; 1087 :                             pUHHRegs->SYSCONFIG |= (UHH_SYSCONFIG_MIDLEMODE(MIDLE_FORCE) | UHH_SYSCONFIG_SIDLEMODE(SIDLE_FORCE));

  000e0	e5963010	 ldr         r3, [r6, #0x10]
  000e4	e5863010	 str         r3, [r6, #0x10]

; 1088 :                             pPddObject->dwActualPowerState = ReqDx;

  000e8	e3a02004	 mov         r2, #4
  000ec	e585225c	 str         r2, [r5, #0x25C]

; 1089 :                             break;

  000f0	ea00001e	 b           |$LN7@HcdPdd_IOC|
  000f4		 |$LN6@HcdPdd_IOC|

; 1068 :                         {
; 1069 :                         case D0:
; 1070 : 		                    DeviceIoControl(pPddObject->hRootBus, IOCTL_BUS_REQUEST_CLOCK, &dwClock, sizeof(dwClock), NULL, 0, NULL, NULL);

  000f4	e59502c0	 ldr         r0, [r5, #0x2C0]
  000f8	e3a03822	 mov         r3, #0x22, 16
  000fc	e3831b03	 orr         r1, r3, #3, 22
  00100	e3a03004	 mov         r3, #4
  00104	e24b2028	 sub         r2, r11, #0x28
  00108	e58d700c	 str         r7, [sp, #0xC]
  0010c	e58d7008	 str         r7, [sp, #8]
  00110	e58d7004	 str         r7, [sp, #4]
  00114	e58d7000	 str         r7, [sp]
  00118	eb000000	 bl          DeviceIoControl

; 1071 :                             SetDevicePowerState(pPddObject->hParentBusHandle, D0, NULL);

  0011c	e59502bc	 ldr         r0, [r5, #0x2BC]
  00120	e3a02000	 mov         r2, #0
  00124	e3a01000	 mov         r1, #0
  00128	eb000000	 bl          SetDevicePowerState

; 1072 :                             DelayMilliSeconds(200, FALSE);

  0012c	e3a000c8	 mov         r0, #0xC8
  00130	eb000000	 bl          Sleep

; 1073 :                             RegVal = pUHHRegs->SYSCONFIG & ~(UHH_SYSCONFIG_MIDLEMODE(0x03) | UHH_SYSCONFIG_SIDLEMODE(0x03));

  00134	e5962010	 ldr         r2, [r6, #0x10]
  00138	e3e03a03	 mvn         r3, #3, 20
  0013c	e2233018	 eor         r3, r3, #0x18
  00140	e3a01a02	 mov         r1, #2, 20
  00144	e0022003	 and         r2, r2, r3

; 1074 :                             pUHHRegs->SYSCONFIG = RegVal | UHH_SYSCONFIG_MIDLEMODE(MIDLE_SMART) | UHH_SYSCONFIG_SIDLEMODE(SIDLE_SMART);

  00148	e3813010	 orr         r3, r1, #0x10
  0014c	e1823003	 orr         r3, r2, r3
  00150	e5863010	 str         r3, [r6, #0x10]

; 1075 :                             HcdMdd_PowerUp(pPddObject->lpvEHCDMddObject);

  00154	e5950010	 ldr         r0, [r5, #0x10]
  00158	eb000000	 bl          HcdMdd_PowerUp

; 1076 :                             g_fOmapEhciSuspended = FALSE;

  0015c	e59f3118	 ldr         r3, [pc, #0x118]
  00160	e5837000	 str         r7, [r3]

; 1077 :                             pPddObject->dwActualPowerState = ReqDx;

  00164	e585725c	 str         r7, [r5, #0x25C]
  00168		 |$LN55@HcdPdd_IOC|
  00168	e3a02004	 mov         r2, #4
  0016c	e3a04001	 mov         r4, #1
  00170		 |$LN7@HcdPdd_IOC|

; 1090 :                         }
; 1091 :                     *pdwActualOut = sizeof(CEDEVICE_POWER_STATE);

  00170	e59b3008	 ldr         r3, [r11, #8]

; 1092 :                     DEBUGMSG(ZONE_INFO, (L"EHCI: IOCTL_POWER_SET to D%u \r\n", pPddObject->dwActualPowerState));
; 1093 :                     rc = TRUE;
; 1094 : 
; 1095 :                     MmUnmapIoSpace((PVOID)pUHHRegs, sizeof(OMAP_UHH_REGS));

  00174	e3a01048	 mov         r1, #0x48
  00178	e1a00006	 mov         r0, r6
  0017c	e5832000	 str         r2, [r3]
  00180	e50b402c	 str         r4, [r11, #-0x2C]
  00184	eb000000	 bl          MmUnmapIoSpace
  00188		 |$LN34@HcdPdd_IOC|

; 1096 :                     }

  00188	ea000027	 b           |$cleanUp$45353|
  0018c		 |$LN30@HcdPdd_IOC|

; 1098 :                     {
; 1099 : 					RETAILMSG(1, (L"EHCI: Exception in IOCTL_POWER_SET\r\n"));

  0018c	e59f00e4	 ldr         r0, [pc, #0xE4]
  00190	eb000000	 bl          NKDbgPrintfW
  00194	e51b402c	 ldr         r4, [r11, #-0x2C]
  00198	ea000023	 b           |$cleanUp$45353|
  0019c		 |$LN4@HcdPdd_IOC|

; 1100 :                     }
; 1101 :                 }
; 1102 :             break;
; 1103 : 
; 1104 :         // gets the current device power state
; 1105 :         case IOCTL_POWER_GET:
; 1106 :             DEBUGMSG(ZONE_INFO, (L"EHCI: Received IOCTL_POWER_GET\r\n"));
; 1107 :             if (pBufOut != NULL && dwLenOut >= sizeof(CEDEVICE_POWER_STATE))

  0019c	e59b2000	 ldr         r2, [r11]
  001a0	e3520000	 cmp         r2, #0
  001a4	0a000020	 beq         |$cleanUp$45353|
  001a8	e59b3004	 ldr         r3, [r11, #4]
  001ac	e3530004	 cmp         r3, #4
  001b0	3a00001d	 bcc         |$cleanUp$45353|
  001b4		 |$LN40@HcdPdd_IOC|

; 1108 :                 {
; 1109 :                 __try
; 1110 :                     {
; 1111 :                     *(PCEDEVICE_POWER_STATE)pBufOut = pPddObject->dwActualPowerState;

  001b4	e595325c	 ldr         r3, [r5, #0x25C]
  001b8	e5823000	 str         r3, [r2]

; 1112 : 
; 1113 :                     rc = TRUE;

  001bc	e3a04001	 mov         r4, #1
  001c0	e50b402c	 str         r4, [r11, #-0x2C]
  001c4		 |$LN41@HcdPdd_IOC|

; 1114 : 
; 1115 :                     DEBUGMSG(ZONE_INFO, (L"EHCI: IOCTL_POWER_GET to D%u \r\n", pPddObject->dwActualPowerState));
; 1116 :                     }

  001c4	ea000018	 b           |$cleanUp$45353|
  001c8		 |$LN37@HcdPdd_IOC|

; 1117 :                 __except(EXCEPTION_EXECUTE_HANDLER)

  001c8	e51b402c	 ldr         r4, [r11, #-0x2C]
  001cc	ea000016	 b           |$cleanUp$45353|
  001d0		 |$LN15@HcdPdd_IOC|

; 1021 :         {
; 1022 :         case IOCTL_POWER_CAPABILITIES:
; 1023 :             DEBUGMSG(ZONE_INFO, (L"EHCI: Received IOCTL_POWER_CAPABILITIES\r\n"));
; 1024 :             if (pBufOut && dwLenOut >= sizeof (POWER_CAPABILITIES) &&
; 1025 :                 pdwActualOut)

  001d0	e59b5000	 ldr         r5, [r11]
  001d4	e3550000	 cmp         r5, #0
  001d8	0a000013	 beq         |$cleanUp$45353|
  001dc	e59b3004	 ldr         r3, [r11, #4]
  001e0	e3530030	 cmp         r3, #0x30
  001e4	3a000010	 bcc         |$cleanUp$45353|
  001e8	e59b6008	 ldr         r6, [r11, #8]
  001ec	e3560000	 cmp         r6, #0
  001f0	0a00000d	 beq         |$cleanUp$45353|
  001f4		 |$LN26@HcdPdd_IOC|

; 1026 :                 {
; 1027 :                     __try
; 1028 :                         {
; 1029 :                         PPOWER_CAPABILITIES PowerCaps;
; 1030 :                         PowerCaps = (PPOWER_CAPABILITIES)pBufOut;
; 1031 : 
; 1032 :                         // Only supports D0 (permanently on) and D4(off).
; 1033 :                         memset(PowerCaps, 0, sizeof(*PowerCaps));

  001f4	e3a02030	 mov         r2, #0x30
  001f8	e3a01000	 mov         r1, #0
  001fc	e1a00005	 mov         r0, r5
  00200	eb000000	 bl          memset

; 1034 :                         PowerCaps->DeviceDx = (DX_MASK(D0) |
; 1035 :                                                DX_MASK(D4));

  00204	e3a03011	 mov         r3, #0x11
  00208	e5c53000	 strb        r3, [r5]

; 1036 :                         *pdwActualOut = sizeof(*PowerCaps);

  0020c	e3a03030	 mov         r3, #0x30
  00210	e5863000	 str         r3, [r6]

; 1037 :                         rc = TRUE;

  00214	e3a04001	 mov         r4, #1
  00218	e50b402c	 str         r4, [r11, #-0x2C]
  0021c		 |$LN27@HcdPdd_IOC|

; 1038 :                         }

  0021c	ea000002	 b           |$cleanUp$45353|
  00220		 |$LN23@HcdPdd_IOC|

; 1039 :                     __except(EXCEPTION_EXECUTE_HANDLER)

  00220	e51b402c	 ldr         r4, [r11, #-0x2C]
  00224	ea000000	 b           |$cleanUp$45353|
  00228		 |$LN56@HcdPdd_IOC|

; 1118 :                     {
; 1119 :                     DEBUGMSG(ZONE_ERROR, (L"Exception in ioctl\r\n"));
; 1120 :                     }
; 1121 :                 }
; 1122 :             break;
; 1123 : 
; 1124 :         default:
; 1125 :             DEBUGMSG(ZONE_CONTROL, (L"EHCI: Not handled IOCTL 0x%X", dwCode));
; 1126 :             break;
; 1127 :         }
; 1128 : 
; 1129 : cleanUp:
; 1130 :     DEBUGMSG(ZONE_CONTROL, (L"-HcdPdd_IOControl(rc = %d)\r\n", rc));
; 1131 :     return rc;

  00228	e51b4028	 ldr         r4, [r11, #-0x28]
  0022c		 |$cleanUp$45353|

; 1132 : }

  0022c	e1a00004	 mov         r0, r4
  00230	e24bd01c	 sub         sp, r11, #0x1C
  00234	e89d68f0	 ldmia       sp, {r4 - r7, r11, sp, lr}
  00238	e12fff1e	 bx          lr

			 ENDP  ; |HcdPdd_IOControl|

  0023c		 |$LN22@HcdPdd_IOC|
  0023c		 |$LN58@HcdPdd_IOC|

; 1039 :                     __except(EXCEPTION_EXECUTE_HANDLER)

  0023c	e52de004	 str         lr, [sp, #-4]!
  00240	e24dd010	 sub         sp, sp, #0x10
  00244		 |$LN25@HcdPdd_IOC|
  00244		 |$LN63@HcdPdd_IOC|
  00244	e3a00001	 mov         r0, #1
  00248		 |$LN24@HcdPdd_IOC|
  00248	e28dd010	 add         sp, sp, #0x10
  0024c	e49df004	 ldr         pc, [sp], #4
  00250		 |$LN64@HcdPdd_IOC|
  00250		 |$LN36@HcdPdd_IOC|
  00250		 |$LN60@HcdPdd_IOC|

; 1117 :                 __except(EXCEPTION_EXECUTE_HANDLER)

  00250	e52de004	 str         lr, [sp, #-4]!
  00254	e24dd010	 sub         sp, sp, #0x10
  00258		 |$LN39@HcdPdd_IOC|
  00258		 |$LN65@HcdPdd_IOC|
  00258	e3a00001	 mov         r0, #1
  0025c		 |$LN38@HcdPdd_IOC|
  0025c	e28dd010	 add         sp, sp, #0x10
  00260	e49df004	 ldr         pc, [sp], #4
  00264		 |$LN66@HcdPdd_IOC|
  00264		 |$LN29@HcdPdd_IOC|
  00264		 |$LN61@HcdPdd_IOC|

; 1097 :                 __except(EXCEPTION_EXECUTE_HANDLER)

  00264	e52de004	 str         lr, [sp, #-4]!
  00268	e24dd010	 sub         sp, sp, #0x10
  0026c		 |$LN32@HcdPdd_IOC|
  0026c		 |$LN67@HcdPdd_IOC|
  0026c	e3a00001	 mov         r0, #1
  00270		 |$LN31@HcdPdd_IOC|
  00270	e28dd010	 add         sp, sp, #0x10
  00274	e49df004	 ldr         pc, [sp], #4
  00278		 |$LN69@HcdPdd_IOC|
  00278		 |$LN70@HcdPdd_IOC|
  00278	00000000	 DCD         |??_C@_1EK@FJEIBADC@?$AAE?$AAH?$AAC?$AAI?$AA?3?$AA?5?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAO?$AAW?$AAE?$AAR?$AA_?$AAS@|
  0027c		 |$LN71@HcdPdd_IOC|
  0027c	00000000	 DCD         |g_fOmapEhciSuspended|
  00280		 |$LN72@HcdPdd_IOC|
  00280	0032100c	 DCD         0x32100c
  00284		 |$LN73@HcdPdd_IOC|
  00284	00321008	 DCD         0x321008
  00288		 |$LN74@HcdPdd_IOC|
  00288	00321004	 DCD         0x321004
  0028c		 |$LN68@HcdPdd_IOC|
  0028c		 |$LN62@HcdPdd_IOC|
	EXPORT	|HcdPdd_InitiatePowerUp|

  00000			 AREA	 |.pdata|, PDATA
|$T46025| DCD	|$LN5@HcdPdd_Ini@2|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_InitiatePowerUp| PROC

; 1140 : {

  00000		 |$LN5@HcdPdd_Ini@2|
  00000		 |$M46022|

; 1141 : 	UNREFERENCED_PARAMETER(hDeviceContext);
; 1142 : }

  00000	e12fff1e	 bx          lr
  00004		 |$M46023|

			 ENDP  ; |HcdPdd_InitiatePowerUp|

	END
