; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\CEDDK\REG\registry.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1EA@FGNHCGNB@?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?3?$AA?5?$AAm?$AAi?$AAs?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|LocalAlloc|
	IMPORT	|NKDbgPrintfW|
	IMPORT	|RegQueryValueExW|
	IMPORT	|memcpy|
	IMPORT	|wcslen|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\ceddk\reg\registry.c

  00000			 AREA	 |.pdata|, PDATA
|$T39556| DCD	|$LN20@GetStringP|
	DCD	0x40005902

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EA@FGNHCGNB@?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?3?$AA?5?$AAm?$AAi?$AAs?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?$AN?$AA?6?$AA?$AA@| DCB "R"
	DCB	0x0, "e", 0x0, "g", 0x0, "i", 0x0, "s", 0x0, "t", 0x0, "r"
	DCB	0x0, "y", 0x0, ":", 0x0, " ", 0x0, "m", 0x0, "i", 0x0, "s"
	DCB	0x0, "s", 0x0, "i", 0x0, "n", 0x0, "g", 0x0, " ", 0x0, "s"
	DCB	0x0, "t", 0x0, "r", 0x0, "i", 0x0, "n", 0x0, "g", 0x0, " "
	DCB	0x0, """", 0x0, "%", 0x0, "s", 0x0, """", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetStringParam| PROC

; 30   : {

  00000		 |$LN20@GetStringP|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M39553|
  00008	e1a05002	 mov         r5, r2
  0000c	e1a08000	 mov         r8, r0

; 31   :     DWORD status, size, type;
; 32   :     WCHAR *pName;
; 33   :     UCHAR *pBuffer, *pValue;
; 34   : 
; 35   :     pName = pParam->name;
; 36   :     pValue = (UCHAR*)pBase + pParam->offset;
; 37   :     size = pParam->size;

  00010	e5953010	 ldr         r3, [r5, #0x10]
  00014	e595e00c	 ldr         lr, [r5, #0xC]
  00018	e5956000	 ldr         r6, [r5]
  0001c	e3530000	 cmp         r3, #0
  00020	e58d3008	 str         r3, [sp, #8]
  00024	e08e7001	 add         r7, lr, r1

; 38   : 
; 39   :     // If there is parameter size we simply try to read value or used default
; 40   :     if (size > 0)
; 41   :         {
; 42   :         status = RegQueryValueEx(hKey, pName, NULL, &type, pValue, &size);

  00028	e28d3008	 add         r3, sp, #8
  0002c	e1a01006	 mov         r1, r6
  00030	e3a02000	 mov         r2, #0
  00034	0a00001a	 beq         |$LN11@GetStringP|
  00038	e58d3004	 str         r3, [sp, #4]
  0003c	e28d300c	 add         r3, sp, #0xC
  00040	e58d7000	 str         r7, [sp]
  00044	eb000000	 bl          RegQueryValueExW
  00048	e1b04000	 movs        r4, r0

; 43   :         if (status == ERROR_SUCCESS || pParam->required) 

  0004c	0a00003f	 beq         |$cleanUp$39269|
  00050	e5953008	 ldr         r3, [r5, #8]
  00054	e3530000	 cmp         r3, #0
  00058	1a00000d	 bne         |$LN9@GetStringP|

; 47   :         }
; 48   :         size = (wcslen((WCHAR*)pParam->pDefault) + 1) * sizeof(WCHAR);

  0005c	e5950014	 ldr         r0, [r5, #0x14]
  00060	eb000000	 bl          wcslen

; 49   :         if (size > pParam->size)

  00064	e5952010	 ldr         r2, [r5, #0x10]
  00068	e2803001	 add         r3, r0, #1
  0006c	e1a03083	 mov         r3, r3, lsl #1
  00070	e58d3008	 str         r3, [sp, #8]
  00074	e1530002	 cmp         r3, r2

; 50   :             {
; 51   :             status = ERROR_OUTOFMEMORY;
; 52   :             }
; 53   :         else

  00078	8a00001c	 bhi         |$LN16@GetStringP|

; 54   :             {
; 55   :             memcpy(pValue, pParam->pDefault, size);

  0007c	e5951014	 ldr         r1, [r5, #0x14]
  00080	e1a02003	 mov         r2, r3
  00084	e1a00007	 mov         r0, r7
  00088	eb000000	 bl          memcpy

; 80   :             status = ERROR_SUCCESS;

  0008c	e3a04000	 mov         r4, #0

; 81   :             }
; 82   :         else

  00090	ea00002e	 b           |$cleanUp$39269|
  00094		 |$LN9@GetStringP|

; 44   :         {
; 45   :             RETAILMSG(status != ERROR_SUCCESS, (L"Registry: missing string \"%s\"\r\n", pName));

  00094	e59f00c4	 ldr         r0, [pc, #0xC4]
  00098	e1a01006	 mov         r1, r6
  0009c	eb000000	 bl          NKDbgPrintfW

; 46   :             goto cleanUp;

  000a0	ea00002a	 b           |$cleanUp$39269|
  000a4		 |$LN11@GetStringP|

; 56   :             status = ERROR_SUCCESS;
; 57   :             }
; 58   :         }
; 59   :     else
; 60   :         {
; 61   :         // First find if value is there
; 62   :         status = RegQueryValueEx(hKey, pName, NULL, &type, NULL, &size);

  000a4	e58d3004	 str         r3, [sp, #4]
  000a8	e58d2000	 str         r2, [sp]
  000ac	e28d300c	 add         r3, sp, #0xC
  000b0	e3a02000	 mov         r2, #0
  000b4	eb000000	 bl          RegQueryValueExW
  000b8	e1b04000	 movs        r4, r0

; 63   :         // Value isn't in registry, break or use default
; 64   :         if (status != ERROR_SUCCESS)

  000bc	0a000014	 beq         |$LN5@GetStringP|

; 65   :             {
; 66   :             if (pParam->required) 

  000c0	e5953008	 ldr         r3, [r5, #8]
  000c4	e3530000	 cmp         r3, #0

; 67   :             {
; 68   :                 RETAILMSG(1, (L"Registry: missing string \"%s\"\r\n", pName));
; 69   :                 goto cleanUp;

  000c8	1afffff1	 bne         |$LN9@GetStringP|

; 70   :             }
; 71   :             size = (wcslen((WCHAR*)pParam->pDefault) + 1) * sizeof(WCHAR);

  000cc	e5950014	 ldr         r0, [r5, #0x14]
  000d0	eb000000	 bl          wcslen
  000d4	e2803001	 add         r3, r0, #1
  000d8	e1a01083	 mov         r1, r3, lsl #1

; 72   :             pBuffer = (UCHAR*)LocalAlloc(LMEM_FIXED, size);

  000dc	e3a00000	 mov         r0, #0
  000e0	e58d1008	 str         r1, [sp, #8]
  000e4	eb000000	 bl          LocalAlloc
  000e8	e1b04000	 movs        r4, r0

; 73   :             if (pBuffer == NULL)

  000ec	1a000001	 bne         |$LN3@GetStringP|
  000f0		 |$LN16@GetStringP|

; 74   :                 {
; 75   :                 status = ERROR_OUTOFMEMORY;

  000f0	e3a0400e	 mov         r4, #0xE

; 76   :                 goto cleanUp;

  000f4	ea000015	 b           |$cleanUp$39269|
  000f8		 |$LN3@GetStringP|

; 77   :                 }
; 78   :             memcpy(pBuffer, pParam->pDefault, size);

  000f8	e59d2008	 ldr         r2, [sp, #8]
  000fc	e5951014	 ldr         r1, [r5, #0x14]
  00100	e1a00004	 mov         r0, r4
  00104	eb000000	 bl          memcpy

; 79   :             *(VOID**)pValue = pBuffer;

  00108	e5874000	 str         r4, [r7]

; 80   :             status = ERROR_SUCCESS;

  0010c	e3a04000	 mov         r4, #0

; 81   :             }
; 82   :         else

  00110	ea00000e	 b           |$cleanUp$39269|
  00114		 |$LN5@GetStringP|

; 83   :             {
; 84   :             pBuffer = (UCHAR*)LocalAlloc(LMEM_FIXED, size);

  00114	e59d1008	 ldr         r1, [sp, #8]
  00118	e3a00000	 mov         r0, #0
  0011c	eb000000	 bl          LocalAlloc
  00120	e1b05000	 movs        r5, r0

; 85   :             if (pBuffer == NULL)
; 86   :                 {
; 87   :                 status = ERROR_OUTOFMEMORY;
; 88   :                 goto cleanUp;

  00124	0afffff1	 beq         |$LN16@GetStringP|

; 89   :                 }
; 90   :             status = RegQueryValueEx(hKey, pName, NULL, &type, pBuffer, &size);

  00128	e28d3008	 add         r3, sp, #8
  0012c	e58d3004	 str         r3, [sp, #4]
  00130	e28d300c	 add         r3, sp, #0xC
  00134	e3a02000	 mov         r2, #0
  00138	e1a01006	 mov         r1, r6
  0013c	e1a00008	 mov         r0, r8
  00140	e58d5000	 str         r5, [sp]
  00144	eb000000	 bl          RegQueryValueExW
  00148	e1a04000	 mov         r4, r0

; 91   :             *(VOID**)pValue = pBuffer;

  0014c	e5875000	 str         r5, [r7]
  00150		 |$cleanUp$39269|

; 92   :             }
; 93   :         }
; 94   : 
; 95   : cleanUp:
; 96   :     return status;
; 97   : }

  00150	e1a00004	 mov         r0, r4
  00154	e28dd010	 add         sp, sp, #0x10
  00158	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0015c	e12fff1e	 bx          lr
  00160		 |$LN21@GetStringP|
  00160		 |$LN22@GetStringP|
  00160	00000000	 DCD         |??_C@_1EA@FGNHCGNB@?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?3?$AA?5?$AAm?$AAi?$AAs?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?$AN?$AA?6?$AA?$AA@|
  00164		 |$M39554|

			 ENDP  ; |GetStringParam|

	EXPORT	|??_C@_1DO@MCOMFDBG@?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?3?$AA?5?$AAm?$AAi?$AAs?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAd?$AAw?$AAo?$AAr?$AAd?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T39573| DCD	|$LN7@GetDWordPa|
	DCD	0x40002002

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DO@MCOMFDBG@?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?3?$AA?5?$AAm?$AAi?$AAs?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAd?$AAw?$AAo?$AAr?$AAd?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?$AN?$AA?6?$AA?$AA@| DCB "R"
	DCB	0x0, "e", 0x0, "g", 0x0, "i", 0x0, "s", 0x0, "t", 0x0, "r"
	DCB	0x0, "y", 0x0, ":", 0x0, " ", 0x0, "m", 0x0, "i", 0x0, "s"
	DCB	0x0, "s", 0x0, "i", 0x0, "n", 0x0, "g", 0x0, " ", 0x0, "d"
	DCB	0x0, "w", 0x0, "o", 0x0, "r", 0x0, "d", 0x0, " ", 0x0, """"
	DCB	0x0, "%", 0x0, "s", 0x0, """", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetDWordParam| PROC

; 107  : {

  00000		 |$LN7@GetDWordPa|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M39570|
  00008	e1a05002	 mov         r5, r2

; 108  :     DWORD status, size, type;
; 109  :     WCHAR *pName;
; 110  :     UCHAR *pValue;
; 111  : 
; 112  : 
; 113  :     pName = pParam->name;
; 114  :     pValue = (UCHAR*)pBase + pParam->offset;

  0000c	e595300c	 ldr         r3, [r5, #0xC]
  00010	e5956000	 ldr         r6, [r5]

; 115  :     size = pParam->size;

  00014	e5954010	 ldr         r4, [r5, #0x10]
  00018	e0837001	 add         r7, r3, r1

; 116  : 
; 117  :     status = RegQueryValueEx(hKey, pName, NULL, &type, pValue, &size);

  0001c	e28de008	 add         lr, sp, #8
  00020	e28d300c	 add         r3, sp, #0xC
  00024	e1a01006	 mov         r1, r6
  00028	e3a02000	 mov         r2, #0
  0002c	e58d7000	 str         r7, [sp]
  00030	e58d4008	 str         r4, [sp, #8]
  00034	e58de004	 str         lr, [sp, #4]
  00038	eb000000	 bl          RegQueryValueExW
  0003c	e1b04000	 movs        r4, r0

; 118  :     if (status != ERROR_SUCCESS)

  00040	0a000009	 beq         |$cleanUp$39309|

; 119  :     {
; 120  :         if (pParam->required)

  00044	e5953008	 ldr         r3, [r5, #8]
  00048	e3530000	 cmp         r3, #0
  0004c	0a000003	 beq         |$LN1@GetDWordPa|

; 121  :         {
; 122  :             RETAILMSG(1, (L"Registry: missing dword \"%s\"\r\n", pName));

  00050	e59f0024	 ldr         r0, [pc, #0x24]
  00054	e1a01006	 mov         r1, r6
  00058	eb000000	 bl          NKDbgPrintfW

; 123  : 	        goto cleanUp;

  0005c	ea000002	 b           |$cleanUp$39309|
  00060		 |$LN1@GetDWordPa|

; 124  :         }		
; 125  :     *(DWORD*)pValue = (DWORD)pParam->pDefault;

  00060	e5953014	 ldr         r3, [r5, #0x14]

; 126  :     status = ERROR_SUCCESS;

  00064	e3a04000	 mov         r4, #0
  00068	e5873000	 str         r3, [r7]
  0006c		 |$cleanUp$39309|

; 127  :     }
; 128  : 
; 129  : cleanUp:
; 130  :     return status;
; 131  : }

  0006c	e1a00004	 mov         r0, r4
  00070	e28dd010	 add         sp, sp, #0x10
  00074	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00078	e12fff1e	 bx          lr
  0007c		 |$LN8@GetDWordPa|
  0007c		 |$LN9@GetDWordPa|
  0007c	00000000	 DCD         |??_C@_1DO@MCOMFDBG@?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?3?$AA?5?$AAm?$AAi?$AAs?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAd?$AAw?$AAo?$AAr?$AAd?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?$AN?$AA?6?$AA?$AA@|
  00080		 |$M39571|

			 ENDP  ; |GetDWordParam|

	EXPORT	|??_C@_1EO@IOCGNGDN@?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?3?$AA?5?$AAb?$AAa?$AAd?$AA?5?$AAm?$AAu?$AAl?$AAt?$AAi?$AAd?$AAw?$AAo?$AAr?$AAd?$AA?5?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1IE@MEPOILFJ@?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?3?$AA?5?$AAm?$AAu?$AAl?$AAt?$AAi?$AAd?$AAw?$AAo?$AAr?$AAd?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAR?$AAE?$AAG?$AA_?$AAD?$AAW?$AAO@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EI@MOBDLJII@?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?3?$AA?5?$AAm?$AAi?$AAs?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAm?$AAu?$AAl?$AAt?$AAi?$AAd?$AAw?$AAo?$AAr?$AAd?$AA?5?$AA?$CC?$AA?$CF?$AAs@| [ DATA ] ; `string'
	IMPORT	|LocalFree|
	IMPORT	|wcstoul|

  00000			 AREA	 |.pdata|, PDATA
|$T39608| DCD	|$LN35@GetMultiDW|
	DCD	0x40008102

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EO@IOCGNGDN@?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?3?$AA?5?$AAb?$AAa?$AAd?$AA?5?$AAm?$AAu?$AAl?$AAt?$AAi?$AAd?$AAw?$AAo?$AAr?$AAd?$AA?5?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5@| DCB "R"
	DCB	0x0, "e", 0x0, "g", 0x0, "i", 0x0, "s", 0x0, "t", 0x0, "r"
	DCB	0x0, "y", 0x0, ":", 0x0, " ", 0x0, "b", 0x0, "a", 0x0, "d"
	DCB	0x0, " ", 0x0, "m", 0x0, "u", 0x0, "l", 0x0, "t", 0x0, "i"
	DCB	0x0, "d", 0x0, "w", 0x0, "o", 0x0, "r", 0x0, "d", 0x0, " "
	DCB	0x0, "s", 0x0, "t", 0x0, "r", 0x0, "i", 0x0, "n", 0x0, "g"
	DCB	0x0, " ", 0x0, """", 0x0, "%", 0x0, "s", 0x0, """", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1IE@MEPOILFJ@?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?3?$AA?5?$AAm?$AAu?$AAl?$AAt?$AAi?$AAd?$AAw?$AAo?$AAr?$AAd?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAR?$AAE?$AAG?$AA_?$AAD?$AAW?$AAO@| DCB "R"
	DCB	0x0, "e", 0x0, "g", 0x0, "i", 0x0, "s", 0x0, "t", 0x0, "r"
	DCB	0x0, "y", 0x0, ":", 0x0, " ", 0x0, "m", 0x0, "u", 0x0, "l"
	DCB	0x0, "t", 0x0, "i", 0x0, "d", 0x0, "w", 0x0, "o", 0x0, "r"
	DCB	0x0, "d", 0x0, " ", 0x0, "n", 0x0, "o", 0x0, "t", 0x0, " "
	DCB	0x0, "R", 0x0, "E", 0x0, "G", 0x0, "_", 0x0, "D", 0x0, "W"
	DCB	0x0, "O", 0x0, "R", 0x0, "D", 0x0, ",", 0x0, " ", 0x0, "R"
	DCB	0x0, "E", 0x0, "G", 0x0, "_", 0x0, "S", 0x0, "Z", 0x0, " "
	DCB	0x0, "o", 0x0, "r", 0x0, " ", 0x0, "R", 0x0, "E", 0x0, "G"
	DCB	0x0, "_", 0x0, "M", 0x0, "U", 0x0, "L", 0x0, "T", 0x0, "I"
	DCB	0x0, "_", 0x0, "S", 0x0, "Z", 0x0, " ", 0x0, """", 0x0, "%"
	DCB	0x0, "s", 0x0, """", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EI@MOBDLJII@?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?3?$AA?5?$AAm?$AAi?$AAs?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAm?$AAu?$AAl?$AAt?$AAi?$AAd?$AAw?$AAo?$AAr?$AAd?$AA?5?$AA?$CC?$AA?$CF?$AAs@| DCB "R"
	DCB	0x0, "e", 0x0, "g", 0x0, "i", 0x0, "s", 0x0, "t", 0x0, "r"
	DCB	0x0, "y", 0x0, ":", 0x0, " ", 0x0, "m", 0x0, "i", 0x0, "s"
	DCB	0x0, "s", 0x0, "i", 0x0, "n", 0x0, "g", 0x0, " ", 0x0, "m"
	DCB	0x0, "u", 0x0, "l", 0x0, "t", 0x0, "i", 0x0, "d", 0x0, "w"
	DCB	0x0, "o", 0x0, "r", 0x0, "d", 0x0, " ", 0x0, """", 0x0, "%"
	DCB	0x0, "s", 0x0, """", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetMultiDWordParam| PROC

; 141  : {

  00000		 |$LN35@GetMultiDW|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M39605|
  00008	e1a06002	 mov         r6, r2
  0000c	e1a05001	 mov         r5, r1
  00010	e1a09000	 mov         r9, r0

; 142  :     DWORD status, size, type;
; 143  :     WCHAR *pName, *pBuffer = NULL, *pPos;
; 144  :     UCHAR *pValue, *pDefault;
; 145  : 
; 146  :     pName = pParam->name;

  00014	e5967000	 ldr         r7, [r6]

; 147  :     pValue = (UCHAR*)pBase + pParam->offset;

  00018	e596e00c	 ldr         lr, [r6, #0xC]

; 148  :     pDefault = (UCHAR*)pParam->pDefault;
; 149  : 
; 150  :     // Get registry value type and size
; 151  :     status = RegQueryValueEx(hKey, pName, NULL, &type, NULL, &size);

  0001c	e28d4008	 add         r4, sp, #8
  00020	e3a0b000	 mov         r11, #0
  00024	e5968014	 ldr         r8, [r6, #0x14]
  00028	e1a01007	 mov         r1, r7
  0002c	e28d3010	 add         r3, sp, #0x10
  00030	e3a02000	 mov         r2, #0
  00034	e08ea005	 add         r10, lr, r5
  00038	e58d4004	 str         r4, [sp, #4]
  0003c	e58db000	 str         r11, [sp]
  00040	eb000000	 bl          RegQueryValueExW
  00044	e1b04000	 movs        r4, r0

; 152  :     if (status != ERROR_SUCCESS)

  00048	0a00000d	 beq         |$LN19@GetMultiDW|

; 153  :         {
; 154  :         // If value doesn't exists use default value if optional
; 155  :         if (pParam->required)

  0004c	e5963008	 ldr         r3, [r6, #8]
  00050	e3530000	 cmp         r3, #0
  00054	0a000003	 beq         |$LN18@GetMultiDW|

; 156  :         {
; 157  :             RETAILMSG(1, (L"Registry: missing multidword \"%s\"\r\n", pName));

  00058	e59f01a0	 ldr         r0, [pc, #0x1A0]
  0005c	e1a01007	 mov         r1, r7
  00060	eb000000	 bl          NKDbgPrintfW

; 158  :             goto cleanUp;

  00064	ea00005f	 b           |$LN1@GetMultiDW|
  00068		 |$LN18@GetMultiDW|

; 159  :         }
; 160  :         if (pDefault != NULL) memcpy(pValue, pDefault, pParam->size);

  00068	e3580000	 cmp         r8, #0
  0006c	15962010	 ldrne       r2, [r6, #0x10]
  00070	11a01008	 movne       r1, r8
  00074	11a0000a	 movne       r0, r10
  00078	1b000000	 blne        memcpy

; 161  :         status = ERROR_SUCCESS;

  0007c	e3a04000	 mov         r4, #0

; 162  :         goto cleanUp;

  00080	ea000058	 b           |$LN1@GetMultiDW|
  00084		 |$LN19@GetMultiDW|

; 163  :         }
; 164  : 
; 165  :     // If type is DWORD and we expect it, simply read it
; 166  :     if (type == REG_DWORD)

  00084	e59d3010	 ldr         r3, [sp, #0x10]
  00088	e3530004	 cmp         r3, #4
  0008c	1a00000f	 bne         |$LN16@GetMultiDW|

; 167  :         {
; 168  :         if (size == pParam->size)

  00090	e5962010	 ldr         r2, [r6, #0x10]
  00094	e59d3008	 ldr         r3, [sp, #8]
  00098	e1530002	 cmp         r3, r2
  0009c	1a000009	 bne         |$LN15@GetMultiDW|

; 169  :             {
; 170  :             status = RegQueryValueEx(hKey, pName, NULL, NULL, pValue, &size);

  000a0	e28d3008	 add         r3, sp, #8
  000a4	e58d3004	 str         r3, [sp, #4]
  000a8	e3a03000	 mov         r3, #0
  000ac	e3a02000	 mov         r2, #0
  000b0	e1a01007	 mov         r1, r7
  000b4	e1a00009	 mov         r0, r9
  000b8	e58da000	 str         r10, [sp]
  000bc	eb000000	 bl          RegQueryValueExW
  000c0	e1a04000	 mov         r4, r0

; 171  :             }
; 172  :         else

  000c4	ea000047	 b           |$LN1@GetMultiDW|
  000c8		 |$LN15@GetMultiDW|

; 173  :             {
; 174  :             status = ERROR_BAD_LENGTH;

  000c8	e3a04018	 mov         r4, #0x18

; 175  :             }

  000cc	ea000045	 b           |$LN1@GetMultiDW|
  000d0		 |$LN16@GetMultiDW|

; 176  :         }
; 177  :     else if ((type == REG_SZ) || (type == REG_MULTI_SZ))

  000d0	e3530001	 cmp         r3, #1
  000d4	0a000006	 beq         |$LN11@GetMultiDW|
  000d8	e3530007	 cmp         r3, #7
  000dc	0a000004	 beq         |$LN11@GetMultiDW|

; 206  :         }
; 207  :     else
; 208  :         {
; 209  :         RETAILMSG(1, (L"Registry: multidword not REG_DWORD, REG_SZ or REG_MULTI_SZ \"%s\"\r\n", pName));

  000e0	e59f0114	 ldr         r0, [pc, #0x114]
  000e4	e1a01007	 mov         r1, r7
  000e8	eb000000	 bl          NKDbgPrintfW

; 210  :         status = ERROR_BAD_FORMAT;

  000ec	e3a0400b	 mov         r4, #0xB
  000f0	ea00003c	 b           |$LN1@GetMultiDW|
  000f4		 |$LN11@GetMultiDW|

; 178  :         {
; 179  :         // Allocate buffer for key
; 180  :         pBuffer = LocalAlloc(LPTR, size);

  000f4	e59d1008	 ldr         r1, [sp, #8]
  000f8	e3a00040	 mov         r0, #0x40
  000fc	eb000000	 bl          LocalAlloc
  00100	e1b05000	 movs        r5, r0

; 181  :         if (pBuffer == NULL)
; 182  :             {
; 183  :             status = ERROR_OUTOFMEMORY;

  00104	03a0400e	 moveq       r4, #0xE
  00108	0a000033	 beq         |$cleanUp$39336|

; 184  :             goto cleanUp;
; 185  :             }
; 186  :         // Read registry value (in most cases it should not fail)
; 187  :         status = RegQueryValueEx(
; 188  :             hKey, pName, NULL, NULL, (UCHAR*)pBuffer, &size
; 189  :             );

  0010c	e28d3008	 add         r3, sp, #8
  00110	e58d3004	 str         r3, [sp, #4]
  00114	e3a03000	 mov         r3, #0
  00118	e3a02000	 mov         r2, #0
  0011c	e1a01007	 mov         r1, r7
  00120	e1a00009	 mov         r0, r9
  00124	e58d5000	 str         r5, [sp]
  00128	eb000000	 bl          RegQueryValueExW
  0012c	e1b04000	 movs        r4, r0

; 190  :         if (status != ERROR_SUCCESS) 

  00130	1a000029	 bne         |$cleanUp$39336|

; 191  :         {
; 192  :             goto cleanUp;
; 193  :         }
; 194  :         pPos = pBuffer;
; 195  :         size = pParam->size;

  00134	e5962010	 ldr         r2, [r6, #0x10]
  00138	e1a00005	 mov         r0, r5

; 196  :         while (size >= sizeof(DWORD) && *pPos != L'\0')

  0013c	e58d500c	 str         r5, [sp, #0xC]
  00140	e58d2008	 str         r2, [sp, #8]
  00144	e3520004	 cmp         r2, #4
  00148	3a00001d	 bcc         |$LN32@GetMultiDW|
  0014c	e59d1010	 ldr         r1, [sp, #0x10]
  00150		 |$LL8@GetMultiDW|
  00150	e1d030b0	 ldrh        r3, [r0]
  00154	e3530000	 cmp         r3, #0
  00158	0a000019	 beq         |$LN32@GetMultiDW|
  0015c		 |$LL6@GetMultiDW|

; 197  :             {
; 198  :             while (*pPos == L' ' || (type == REG_SZ && *pPos == L',')) pPos++;

  0015c	e1d030b0	 ldrh        r3, [r0]
  00160	e3530020	 cmp         r3, #0x20
  00164	0a000003	 beq         |$LN4@GetMultiDW|
  00168	e3510001	 cmp         r1, #1
  0016c	1a000004	 bne         |$LN5@GetMultiDW|
  00170	e353002c	 cmp         r3, #0x2C
  00174	1a000002	 bne         |$LN5@GetMultiDW|
  00178		 |$LN4@GetMultiDW|
  00178	e2800002	 add         r0, r0, #2
  0017c	e58d000c	 str         r0, [sp, #0xC]
  00180	eafffff5	 b           |$LL6@GetMultiDW|
  00184		 |$LN5@GetMultiDW|

; 199  :             *(DWORD*)pValue = wcstoul(pPos, &pPos, 16);

  00184	e3a02010	 mov         r2, #0x10
  00188	e28d100c	 add         r1, sp, #0xC
  0018c	eb000000	 bl          wcstoul
  00190	e48a0004	 str         r0, [r10], #4

; 200  :             pValue += sizeof(DWORD);
; 201  :             size -= sizeof(DWORD);

  00194	e59d3008	 ldr         r3, [sp, #8]

; 202  :             if (type == REG_MULTI_SZ && *pPos == L'\0') pPos++;

  00198	e59d1010	 ldr         r1, [sp, #0x10]
  0019c	e59d000c	 ldr         r0, [sp, #0xC]
  001a0	e2432004	 sub         r2, r3, #4
  001a4	e3510007	 cmp         r1, #7
  001a8	e58d2008	 str         r2, [sp, #8]
  001ac	01d030b0	 ldreqh      r3, [r0]
  001b0	03530000	 cmpeq       r3, #0
  001b4	02800002	 addeq       r0, r0, #2
  001b8	058d000c	 streq       r0, [sp, #0xC]
  001bc	e3520004	 cmp         r2, #4
  001c0	2affffe2	 bcs         |$LL8@GetMultiDW|
  001c4		 |$LN32@GetMultiDW|

; 203  :             }
; 204  :         status = size == 0 ? ERROR_SUCCESS : ERROR_BAD_FORMAT;

  001c4	e3520000	 cmp         r2, #0

; 205  :         RETAILMSG(status == ERROR_BAD_FORMAT, (L"Registry: bad multidword string \"%s\"\r\n", pName));

  001c8	159f0028	 ldrne       r0, [pc, #0x28]
  001cc	03a04000	 moveq       r4, #0
  001d0	11a01007	 movne       r1, r7
  001d4	13a0400b	 movne       r4, #0xB
  001d8	1b000000	 blne        NKDbgPrintfW
  001dc		 |$cleanUp$39336|

; 211  :         }
; 212  : 
; 213  : cleanUp:
; 214  :     if (pBuffer != NULL) LocalFree(pBuffer);

  001dc	e3550000	 cmp         r5, #0
  001e0	11a00005	 movne       r0, r5
  001e4	1b000000	 blne        LocalFree
  001e8		 |$LN1@GetMultiDW|

; 215  :     return status;
; 216  : }

  001e8	e1a00004	 mov         r0, r4
  001ec	e28dd014	 add         sp, sp, #0x14
  001f0	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001f4	e12fff1e	 bx          lr
  001f8		 |$LN36@GetMultiDW|
  001f8		 |$LN37@GetMultiDW|
  001f8	00000000	 DCD         |??_C@_1EO@IOCGNGDN@?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?3?$AA?5?$AAb?$AAa?$AAd?$AA?5?$AAm?$AAu?$AAl?$AAt?$AAi?$AAd?$AAw?$AAo?$AAr?$AAd?$AA?5?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5@|
  001fc		 |$LN38@GetMultiDW|
  001fc	00000000	 DCD         |??_C@_1IE@MEPOILFJ@?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?3?$AA?5?$AAm?$AAu?$AAl?$AAt?$AAi?$AAd?$AAw?$AAo?$AAr?$AAd?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAR?$AAE?$AAG?$AA_?$AAD?$AAW?$AAO@|
  00200		 |$LN39@GetMultiDW|
  00200	00000000	 DCD         |??_C@_1EI@MOBDLJII@?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?3?$AA?5?$AAm?$AAi?$AAs?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAm?$AAu?$AAl?$AAt?$AAi?$AAd?$AAw?$AAo?$AAr?$AAd?$AA?5?$AA?$CC?$AA?$CF?$AAs@|
  00204		 |$M39606|

			 ENDP  ; |GetMultiDWordParam|

	EXPORT	|??_C@_1DK@FFJGJOJE@?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?3?$AA?5?$AAm?$AAi?$AAs?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAb?$AAi?$AAn?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T39631| DCD	|$LN16@GetBinPara|
	DCD	0x40004302

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DK@FFJGJOJE@?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?3?$AA?5?$AAm?$AAi?$AAs?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAb?$AAi?$AAn?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?$AN?$AA?6?$AA?$AA@| DCB "R"
	DCB	0x0, "e", 0x0, "g", 0x0, "i", 0x0, "s", 0x0, "t", 0x0, "r"
	DCB	0x0, "y", 0x0, ":", 0x0, " ", 0x0, "m", 0x0, "i", 0x0, "s"
	DCB	0x0, "s", 0x0, "i", 0x0, "n", 0x0, "g", 0x0, " ", 0x0, "b"
	DCB	0x0, "i", 0x0, "n", 0x0, " ", 0x0, """", 0x0, "%", 0x0, "s"
	DCB	0x0, """", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetBinParam| PROC

; 226  : {

  00000		 |$LN16@GetBinPara|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M39628|
  00008	e1a05002	 mov         r5, r2
  0000c	e1a08000	 mov         r8, r0

; 227  :     DWORD status, size, type;
; 228  :     WCHAR *pName;
; 229  :     UCHAR *pBuffer, *pValue;
; 230  : 
; 231  :     pName = pParam->name;
; 232  :     pValue = (UCHAR*)pBase + pParam->offset;
; 233  :     size = pParam->size;

  00010	e5953010	 ldr         r3, [r5, #0x10]
  00014	e595e00c	 ldr         lr, [r5, #0xC]
  00018	e5956000	 ldr         r6, [r5]
  0001c	e3530000	 cmp         r3, #0
  00020	e58d3008	 str         r3, [sp, #8]
  00024	e08e7001	 add         r7, lr, r1

; 234  : 
; 235  :     // If there is parameter size we simply try to read value or use default
; 236  :     if (size > 0)
; 237  :         {
; 238  :         status = RegQueryValueEx(hKey, pName, NULL, &type, pValue, &size);

  00028	e28d3008	 add         r3, sp, #8
  0002c	e1a01006	 mov         r1, r6
  00030	e3a02000	 mov         r2, #0
  00034	0a000012	 beq         |$LN8@GetBinPara|
  00038	e58d3004	 str         r3, [sp, #4]
  0003c	e28d300c	 add         r3, sp, #0xC
  00040	e58d7000	 str         r7, [sp]
  00044	eb000000	 bl          RegQueryValueExW
  00048	e1b04000	 movs        r4, r0

; 239  :         if (status == ERROR_SUCCESS || pParam->required) 

  0004c	0a000029	 beq         |$cleanUp$39390|
  00050	e5953008	 ldr         r3, [r5, #8]
  00054	e3530000	 cmp         r3, #0
  00058	1a000005	 bne         |$LN6@GetBinPara|

; 243  :         }
; 244  :         memcpy(pValue, pParam->pDefault, pParam->size);

  0005c	e5952010	 ldr         r2, [r5, #0x10]
  00060	e5951014	 ldr         r1, [r5, #0x14]
  00064	e1a00007	 mov         r0, r7
  00068	eb000000	 bl          memcpy

; 260  :             status = ERROR_SUCCESS;

  0006c	e3a04000	 mov         r4, #0

; 261  :             }
; 262  :         else

  00070	ea000020	 b           |$cleanUp$39390|
  00074		 |$LN6@GetBinPara|

; 240  :         {
; 241  :             RETAILMSG(status != ERROR_SUCCESS, (L"Registry: missing bin \"%s\"\r\n", pName));

  00074	e59f008c	 ldr         r0, [pc, #0x8C]
  00078	e1a01006	 mov         r1, r6
  0007c	eb000000	 bl          NKDbgPrintfW

; 242  :             goto cleanUp;

  00080	ea00001c	 b           |$cleanUp$39390|
  00084		 |$LN8@GetBinPara|

; 245  :         status = ERROR_SUCCESS;
; 246  :         }
; 247  :     else 
; 248  :         {
; 249  :         // First find if value is there
; 250  :         status = RegQueryValueEx(hKey, pName, NULL, &type, NULL, &size);

  00084	e58d3004	 str         r3, [sp, #4]
  00088	e3a09000	 mov         r9, #0
  0008c	e28d300c	 add         r3, sp, #0xC
  00090	e58d9000	 str         r9, [sp]
  00094	eb000000	 bl          RegQueryValueExW
  00098	e1b04000	 movs        r4, r0

; 251  :         // Value isn't in registry, break or use default
; 252  :         if (status != ERROR_SUCCESS)

  0009c	0a000005	 beq         |$LN4@GetBinPara|

; 253  :             {
; 254  :             if (pParam->required) 

  000a0	e5953008	 ldr         r3, [r5, #8]
  000a4	e3530000	 cmp         r3, #0

; 255  :         	{
; 256  :                 RETAILMSG(1, (L"Registry: missing bin \"%s\"\r\n", pName));
; 257  :                 goto cleanUp;

  000a8	1afffff1	 bne         |$LN6@GetBinPara|

; 258  :         	}
; 259  :             *(VOID**)pValue = NULL;

  000ac	e5879000	 str         r9, [r7]

; 260  :             status = ERROR_SUCCESS;

  000b0	e3a04000	 mov         r4, #0

; 261  :             }
; 262  :         else

  000b4	ea00000f	 b           |$cleanUp$39390|
  000b8		 |$LN4@GetBinPara|

; 263  :             {
; 264  :             pBuffer = (UCHAR*)LocalAlloc(LMEM_FIXED, size);

  000b8	e59d1008	 ldr         r1, [sp, #8]
  000bc	e3a00000	 mov         r0, #0
  000c0	eb000000	 bl          LocalAlloc
  000c4	e1b05000	 movs        r5, r0

; 265  :             if (pBuffer == NULL)
; 266  :                 {
; 267  :                 status = ERROR_OUTOFMEMORY;

  000c8	03a0400e	 moveq       r4, #0xE
  000cc	0a000009	 beq         |$cleanUp$39390|

; 268  :                 goto cleanUp;
; 269  :                 }
; 270  :             status = RegQueryValueEx(hKey, pName, NULL, &type, pBuffer, &size);

  000d0	e28d3008	 add         r3, sp, #8
  000d4	e58d3004	 str         r3, [sp, #4]
  000d8	e28d300c	 add         r3, sp, #0xC
  000dc	e3a02000	 mov         r2, #0
  000e0	e1a01006	 mov         r1, r6
  000e4	e1a00008	 mov         r0, r8
  000e8	e58d5000	 str         r5, [sp]
  000ec	eb000000	 bl          RegQueryValueExW
  000f0	e1a04000	 mov         r4, r0

; 271  :             *(VOID**)pValue = pBuffer;

  000f4	e5875000	 str         r5, [r7]
  000f8		 |$cleanUp$39390|

; 272  :             }
; 273  :         }
; 274  : 
; 275  : cleanUp:
; 276  :     return status;
; 277  : }

  000f8	e1a00004	 mov         r0, r4
  000fc	e28dd010	 add         sp, sp, #0x10
  00100	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00104	e12fff1e	 bx          lr
  00108		 |$LN17@GetBinPara|
  00108		 |$LN18@GetBinPara|
  00108	00000000	 DCD         |??_C@_1DK@FFJGJOJE@?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?3?$AA?5?$AAm?$AAi?$AAs?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAb?$AAi?$AAn?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?$AN?$AA?6?$AA?$AA@|
  0010c		 |$M39629|

			 ENDP  ; |GetBinParam|

	EXPORT	|GetDeviceRegistryParams|
	EXPORT	|??_C@_1DG@HMCHMIHB@?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?3?$AA?5?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAo?$AAp?$AAe?$AAn?$AA?5?$AAk?$AAe?$AAy?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|RegCloseKey|
	IMPORT	|RegOpenKeyExW|
	IMPORT	|OpenDeviceKey|

  00000			 AREA	 |.pdata|, PDATA
|$T39674| DCD	|$LN35@GetDeviceR|
	DCD	0x40007502

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DG@HMCHMIHB@?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?3?$AA?5?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAo?$AAp?$AAe?$AAn?$AA?5?$AAk?$AAe?$AAy?$AA?$AN?$AA?6?$AA?$AA@| DCB "R"
	DCB	0x0, "e", 0x0, "g", 0x0, "i", 0x0, "s", 0x0, "t", 0x0, "r"
	DCB	0x0, "y", 0x0, ":", 0x0, " ", 0x0, "c", 0x0, "a", 0x0, "n"
	DCB	0x0, "'", 0x0, "t", 0x0, " ", 0x0, "o", 0x0, "p", 0x0, "e"
	DCB	0x0, "n", 0x0, " ", 0x0, "k", 0x0, "e", 0x0, "y", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetDeviceRegistryParams| PROC

; 288  : {

  00000		 |$LN35@GetDeviceR|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M39671|
  00008	e1a0b003	 mov         r11, r3
  0000c	e58db010	 str         r11, [sp, #0x10]
  00010	e1a0a002	 mov         r10, r2
  00014	e1a07001	 mov         r7, r1
  00018	e1a04000	 mov         r4, r0

; 289  :     DWORD status = ERROR_SUCCESS;
; 290  :     HKEY hKey;
; 291  :     DWORD i;
; 292  : 
; 293  :     // Open registry context to read parameters
; 294  :     if ((hKey = OpenDeviceKey(context)) == NULL)

  0001c	e3a05000	 mov         r5, #0
  00020	eb000000	 bl          OpenDeviceKey
  00024	e3500000	 cmp         r0, #0
  00028	e58d0008	 str         r0, [sp, #8]
  0002c	1a00000c	 bne         |$LN18@GetDeviceR|

; 295  :         {
; 296  :         // It looks like we didn't get active registry key,
; 297  :         // try open key directly
; 298  :         if ((status = RegOpenKeyEx(
; 299  :             HKEY_LOCAL_MACHINE, context, 0, 0, &hKey
; 300  :             )) != ERROR_SUCCESS) 

  00030	e28de008	 add         lr, sp, #8
  00034	e3a03000	 mov         r3, #0
  00038	e3a02000	 mov         r2, #0
  0003c	e1a01004	 mov         r1, r4
  00040	e3a0010a	 mov         r0, #0xA, 2
  00044	e58de000	 str         lr, [sp]
  00048	eb000000	 bl          RegOpenKeyExW
  0004c	e1b05000	 movs        r5, r0
  00050	0a000002	 beq         |$LN30@GetDeviceR|

; 301  :         {
; 302  :             RETAILMSG(1, (L"Registry: can't open key\r\n"));

  00054	e59f0174	 ldr         r0, [pc, #0x174]
  00058	eb000000	 bl          NKDbgPrintfW

; 303  :             goto cleanUp;

  0005c	ea000056	 b           |$cleanUp$39422|
  00060		 |$LN30@GetDeviceR|
  00060	e59d0008	 ldr         r0, [sp, #8]
  00064		 |$LN18@GetDeviceR|

; 304  :         }
; 305  :         }
; 306  : 
; 307  :     // For all members of array
; 308  :     for (i = 0; i < count && status == ERROR_SUCCESS; i++)

  00064	e3a04000	 mov         r4, #0
  00068	e35a0000	 cmp         r10, #0
  0006c	0a00003b	 beq         |$LN15@GetDeviceR|
  00070	e1a0600b	 mov         r6, r11
  00074	e28db00c	 add         r11, sp, #0xC
  00078	e3a02107	 mov         r2, #7, 2
  0007c		 |$LL17@GetDeviceR|
  0007c	e3550000	 cmp         r5, #0
  00080	1a000035	 bne         |$LN31@GetDeviceR|

; 309  :         {
; 310  :         switch (params[i].type)

  00084	e5963004	 ldr         r3, [r6, #4]
  00088	e3530001	 cmp         r3, #1
  0008c	0a000015	 beq         |$LN12@GetDeviceR|
  00090	e3530002	 cmp         r3, #2
  00094	0a00000e	 beq         |$LN11@GetDeviceR|
  00098	e3530003	 cmp         r3, #3
  0009c	0a000007	 beq         |$LN10@GetDeviceR|
  000a0	e3530004	 cmp         r3, #4

; 324  :             default:
; 325  :                 status = (DWORD) STATUS_FAIL_CHECK;

  000a4	13825f8a	 orrne       r5, r2, #0x8A, 30
  000a8	1a000027	 bne         |$LN16@GetDeviceR|
  000ac	e1a02006	 mov         r2, r6
  000b0	e1a01007	 mov         r1, r7
  000b4	eb000000	 bl          GetBinParam
  000b8	e1a05000	 mov         r5, r0
  000bc	ea000020	 b           |$cleanUp$39646|
  000c0		 |$LN10@GetDeviceR|

; 317  :                 break;
; 318  :             case PARAM_MULTIDWORD:
; 319  :                 status = GetMultiDWordParam(hKey, pBase, &params[i]);

  000c0	e1a02006	 mov         r2, r6
  000c4	e1a01007	 mov         r1, r7
  000c8	eb000000	 bl          GetMultiDWordParam

; 320  :                 break;
; 321  :             case PARAM_BIN:
; 322  :                 status = GetBinParam(hKey, pBase, &params[i]);

  000cc	e1a05000	 mov         r5, r0

; 323  :                 break;

  000d0	ea00001b	 b           |$cleanUp$39646|
  000d4		 |$LN11@GetDeviceR|

; 314  :                 break;
; 315  :             case PARAM_STRING:
; 316  :                 status = GetStringParam(hKey, pBase, &params[i]);

  000d4	e1a02006	 mov         r2, r6
  000d8	e1a01007	 mov         r1, r7
  000dc	eb000000	 bl          GetStringParam

; 320  :                 break;
; 321  :             case PARAM_BIN:
; 322  :                 status = GetBinParam(hKey, pBase, &params[i]);

  000e0	e1a05000	 mov         r5, r0

; 323  :                 break;

  000e4	ea000016	 b           |$cleanUp$39646|
  000e8		 |$LN12@GetDeviceR|

; 311  :             {
; 312  :             case PARAM_DWORD:
; 313  :                 status = GetDWordParam(hKey, pBase, &params[i]);

  000e8	e596300c	 ldr         r3, [r6, #0xC]
  000ec	e5969000	 ldr         r9, [r6]
  000f0	e596e010	 ldr         lr, [r6, #0x10]
  000f4	e0838007	 add         r8, r3, r7
  000f8	e28d3014	 add         r3, sp, #0x14
  000fc	e3a02000	 mov         r2, #0
  00100	e1a01009	 mov         r1, r9
  00104	e58d8000	 str         r8, [sp]
  00108	e58de00c	 str         lr, [sp, #0xC]
  0010c	e58db004	 str         r11, [sp, #4]
  00110	eb000000	 bl          RegQueryValueExW
  00114	e1b05000	 movs        r5, r0
  00118	0a000009	 beq         |$cleanUp$39646|
  0011c	e5963008	 ldr         r3, [r6, #8]
  00120	e3530000	 cmp         r3, #0
  00124	0a000003	 beq         |$LN22@GetDeviceR|
  00128	e59f009c	 ldr         r0, [pc, #0x9C]
  0012c	e1a01009	 mov         r1, r9
  00130	eb000000	 bl          NKDbgPrintfW
  00134	ea000002	 b           |$cleanUp$39646|
  00138		 |$LN22@GetDeviceR|
  00138	e5963014	 ldr         r3, [r6, #0x14]
  0013c	e3a05000	 mov         r5, #0
  00140	e5883000	 str         r3, [r8]
  00144		 |$cleanUp$39646|
  00144	e59d0008	 ldr         r0, [sp, #8]
  00148	e3a02107	 mov         r2, #7, 2
  0014c		 |$LN16@GetDeviceR|
  0014c	e2844001	 add         r4, r4, #1
  00150	e154000a	 cmp         r4, r10
  00154	e2866018	 add         r6, r6, #0x18
  00158	3affffc7	 bcc         |$LL17@GetDeviceR|
  0015c		 |$LN31@GetDeviceR|

; 288  : {

  0015c	e59db010	 ldr         r11, [sp, #0x10]
  00160		 |$LN15@GetDeviceR|

; 326  :                 break;
; 327  :             }
; 328  :         }
; 329  : 
; 330  :     // Close key
; 331  :     RegCloseKey(hKey);

  00160	eb000000	 bl          RegCloseKey

; 332  : 
; 333  :     // Release allocated memory in case of failure
; 334  :     if (status != ERROR_SUCCESS)

  00164	e3550000	 cmp         r5, #0
  00168	0a000013	 beq         |$cleanUp$39422|

; 335  :         {
; 336  :         UCHAR *pBuffer, *pValue;
; 337  : 
; 338  :         while (i-- > 0)

  0016c	e3540000	 cmp         r4, #0
  00170	0a000011	 beq         |$cleanUp$39422|
  00174	e0843084	 add         r3, r4, r4, lsl #1
  00178	e08b6183	 add         r6, r11, r3, lsl #3
  0017c	e3a08000	 mov         r8, #0
  00180		 |$LL6@GetDeviceR|
  00180	e2466018	 sub         r6, r6, #0x18

; 339  :             {
; 340  :             pValue = (UCHAR*)pBase + params[i].offset;
; 341  :             switch (params[i].type)

  00184	e5963004	 ldr         r3, [r6, #4]
  00188	e596200c	 ldr         r2, [r6, #0xC]
  0018c	e2444001	 sub         r4, r4, #1
  00190	e3530002	 cmp         r3, #2
  00194	0a000001	 beq         |$LN2@GetDeviceR|
  00198	e3530004	 cmp         r3, #4
  0019c	1a000004	 bne         |$LN1@GetDeviceR|
  001a0		 |$LN2@GetDeviceR|

; 342  :                 {
; 343  :                 case PARAM_STRING:
; 344  :                 case PARAM_BIN:
; 345  :                     if (params[i].size == 0)

  001a0	e5963010	 ldr         r3, [r6, #0x10]
  001a4	e3530000	 cmp         r3, #0

; 346  :                         {
; 347  :                         pBuffer = (UCHAR*)(*(VOID**)pValue);

  001a8	07920007	 ldreq       r0, [r2, +r7]

; 348  :                         *(VOID**)pValue = NULL;

  001ac	07828007	 streq       r8, [r2, +r7]

; 349  :                         LocalFree(pBuffer);

  001b0	0b000000	 bleq        LocalFree
  001b4		 |$LN1@GetDeviceR|

; 335  :         {
; 336  :         UCHAR *pBuffer, *pValue;
; 337  : 
; 338  :         while (i-- > 0)

  001b4	e3540000	 cmp         r4, #0
  001b8	1afffff0	 bne         |$LL6@GetDeviceR|
  001bc		 |$cleanUp$39422|

; 350  :                         }
; 351  :                     break;
; 352  :                 }
; 353  :             }
; 354  :         }
; 355  : 
; 356  : cleanUp:
; 357  :     return status;
; 358  : }

  001bc	e1a00005	 mov         r0, r5
  001c0	e28dd018	 add         sp, sp, #0x18
  001c4	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001c8	e12fff1e	 bx          lr
  001cc		 |$LN36@GetDeviceR|
  001cc		 |$LN37@GetDeviceR|
  001cc	00000000	 DCD         |??_C@_1DO@MCOMFDBG@?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?3?$AA?5?$AAm?$AAi?$AAs?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAd?$AAw?$AAo?$AAr?$AAd?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?$AN?$AA?6?$AA?$AA@|
  001d0		 |$LN38@GetDeviceR|
  001d0	00000000	 DCD         |??_C@_1DG@HMCHMIHB@?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAy?$AA?3?$AA?5?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAo?$AAp?$AAe?$AAn?$AA?5?$AAk?$AAe?$AAy?$AA?$AN?$AA?6?$AA?$AA@|
  001d4		 |$M39672|

			 ENDP  ; |GetDeviceRegistryParams|

	IMPORT	|RegSetValueExW|

  00000			 AREA	 |.pdata|, PDATA
|$T39692| DCD	|$LN5@SetDWordPa|
	DCD	0x40000f02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetDWordParam| PROC

; 368  : {

  00000		 |$LN5@SetDWordPa|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M39689|
  00008	e1a0e001	 mov         lr, r1

; 369  :     DWORD status, size;
; 370  :     WCHAR *pName;
; 371  :     UCHAR *pValue;
; 372  : 
; 373  : 
; 374  :     pName = pParam->name;
; 375  :     pValue = (UCHAR*)pBase + pParam->offset;

  0000c	e592300c	 ldr         r3, [r2, #0xC]

; 376  :     size = pParam->size;

  00010	e5924010	 ldr         r4, [r2, #0x10]
  00014	e5921000	 ldr         r1, [r2]
  00018	e083300e	 add         r3, r3, lr

; 377  : 
; 378  :     status = RegSetValueEx(hKey, pName, 0, REG_DWORD, pValue, size);

  0001c	e58d3000	 str         r3, [sp]
  00020	e3a03004	 mov         r3, #4
  00024	e3a02000	 mov         r2, #0
  00028	e58d4004	 str         r4, [sp, #4]
  0002c	eb000000	 bl          RegSetValueExW

; 379  : 
; 380  :     return status;
; 381  : }

  00030	e28dd008	 add         sp, sp, #8
  00034	e8bd4010	 ldmia       sp!, {r4, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$M39690|

			 ENDP  ; |SetDWordParam|

	EXPORT	|SetDeviceRegistryParams|

  00000			 AREA	 |.pdata|, PDATA
|$T39723| DCD	|$LN22@SetDeviceR|
	DCD	0x40003a02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetDeviceRegistryParams| PROC

; 392  : {

  00000		 |$LN22@SetDeviceR|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M39720|
  00008	e1a06003	 mov         r6, r3
  0000c	e1a07002	 mov         r7, r2
  00010	e1a08001	 mov         r8, r1
  00014	e1a05000	 mov         r5, r0

; 393  :     DWORD status = ERROR_SUCCESS;
; 394  :     HKEY hKey;
; 395  :     DWORD i;
; 396  : 
; 397  :     // Open registry context to read parameters
; 398  :     if ((hKey = OpenDeviceKey(context)) == NULL)

  00018	e3a04000	 mov         r4, #0
  0001c	eb000000	 bl          OpenDeviceKey
  00020	e3500000	 cmp         r0, #0
  00024	e58d0008	 str         r0, [sp, #8]
  00028	1a000009	 bne         |$LN11@SetDeviceR|

; 399  :         {
; 400  :         // It looks like we didn't get active registry key,
; 401  :         // try open key directly
; 402  :         if ((status = RegOpenKeyEx(
; 403  :             HKEY_LOCAL_MACHINE, context, 0, 0, &hKey
; 404  :             )) != ERROR_SUCCESS)

  0002c	e28de008	 add         lr, sp, #8
  00030	e3a03000	 mov         r3, #0
  00034	e3a02000	 mov         r2, #0
  00038	e1a01005	 mov         r1, r5
  0003c	e3a0010a	 mov         r0, #0xA, 2
  00040	e58de000	 str         lr, [sp]
  00044	eb000000	 bl          RegOpenKeyExW
  00048	e1b04000	 movs        r4, r0
  0004c	1a000021	 bne         |$cleanUp$39484|
  00050	e59d0008	 ldr         r0, [sp, #8]
  00054		 |$LN11@SetDeviceR|

; 405  :         {
; 406  :             goto cleanUp;
; 407  :         }
; 408  :         }
; 409  : 
; 410  :     // For all members of array
; 411  :     for (i = 0; i < count && status == ERROR_SUCCESS; i++)

  00054	e3a05000	 mov         r5, #0
  00058	e3570000	 cmp         r7, #0
  0005c	0a00001c	 beq         |$LN19@SetDeviceR|
  00060	e3a09107	 mov         r9, #7, 2
  00064		 |$LL10@SetDeviceR|
  00064	e3540000	 cmp         r4, #0
  00068	1a000019	 bne         |$LN19@SetDeviceR|

; 412  :         {
; 413  :         switch (params[i].type)

  0006c	e5963004	 ldr         r3, [r6, #4]
  00070	e3530001	 cmp         r3, #1
  00074	0a000007	 beq         |$LN5@SetDeviceR|
  00078	e3530002	 cmp         r3, #2
  0007c	0a000010	 beq         |$LN9@SetDeviceR|
  00080	e3530003	 cmp         r3, #3
  00084	0a00000e	 beq         |$LN9@SetDeviceR|
  00088	e3530004	 cmp         r3, #4
  0008c	0a00000c	 beq         |$LN9@SetDeviceR|

; 417  :                 break;
; 418  :             case PARAM_STRING:
; 419  :               //  status = SetStringParam(hKey, pBase, &params[i]);
; 420  :                 break;
; 421  :             case PARAM_MULTIDWORD:
; 422  :               //  status = GetMultiDWordParam(hKey, pBase, &params[i]);
; 423  :                 break;
; 424  :             case PARAM_BIN:
; 425  :               //  status = GetBinParam(hKey, pBase, &params[i]);
; 426  :                 break;
; 427  :             default:
; 428  :                 status = (DWORD) STATUS_FAIL_CHECK;

  00090	e3894f8a	 orr         r4, r9, #0x8A, 30

; 429  :                 break;

  00094	ea00000a	 b           |$LN9@SetDeviceR|
  00098		 |$LN5@SetDeviceR|

; 414  :             {
; 415  :             case PARAM_DWORD:
; 416  :                 status = SetDWordParam(hKey, pBase, &params[i]);

  00098	e596300c	 ldr         r3, [r6, #0xC]
  0009c	e596e010	 ldr         lr, [r6, #0x10]
  000a0	e5961000	 ldr         r1, [r6]
  000a4	e0833008	 add         r3, r3, r8
  000a8	e58d3000	 str         r3, [sp]
  000ac	e3a03004	 mov         r3, #4
  000b0	e3a02000	 mov         r2, #0
  000b4	e58de004	 str         lr, [sp, #4]
  000b8	eb000000	 bl          RegSetValueExW
  000bc	e1a04000	 mov         r4, r0
  000c0	e59d0008	 ldr         r0, [sp, #8]
  000c4		 |$LN9@SetDeviceR|
  000c4	e2855001	 add         r5, r5, #1
  000c8	e1550007	 cmp         r5, r7
  000cc	e2866018	 add         r6, r6, #0x18
  000d0	3affffe3	 bcc         |$LL10@SetDeviceR|
  000d4		 |$LN19@SetDeviceR|

; 430  :             }
; 431  :         }
; 432  : 
; 433  :     // Close key
; 434  :     RegCloseKey(hKey);

  000d4	eb000000	 bl          RegCloseKey
  000d8		 |$cleanUp$39484|

; 435  : 
; 436  : cleanUp:
; 437  :     return status;
; 438  : }

  000d8	e1a00004	 mov         r0, r4
  000dc	e28dd00c	 add         sp, sp, #0xC
  000e0	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000e4	e12fff1e	 bx          lr
  000e8		 |$M39721|

			 ENDP  ; |SetDeviceRegistryParams|

	END
