; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\CEDDK\BUS\bus.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|CreateBusAccessHandle|
	IMPORT	|LocalFree|
	IMPORT	|CloseHandle|
	IMPORT	|CreateFileW|
	IMPORT	|LocalAlloc|
	IMPORT	|GetDeviceInformationByDeviceHandle|
	IMPORT	|GetDeviceHandleFromContext|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|memcpy|
	IMPORT	|wcslen|
	IMPORT	|memset|
	IMPORT	|__security_check_cookie|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\ceddk\bus\bus.c

  00000			 AREA	 |.pdata|, PDATA
|$T43637| DCD	|$LN15@CreateBusA|
	DCD	0xc0005d02

  00000			 AREA	 |.xdata|, DATA
|$T43633| DCD	0xfffffff0
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T43633|

  00008		 |CreateBusAccessHandle| PROC

; 33   : {

  00008		 |$LN15@CreateBusA|
  00008	e92d4030	 stmdb       sp!, {r4, r5, lr}
  0000c	e24ddd19	 sub         sp, sp, #0x19, 26
  00010		 |$M43634|
  00010	e59f3160	 ldr         r3, [pc, #0x160]
  00014	e5933000	 ldr         r3, [r3]
  00018	e58d363c	 str         r3, [sp, #0x63C]

; 34   :     BOOL rc = FALSE;
; 35   :     PARENT_BUS_ACCESS *pBusAccess = NULL;

  0001c	e3a04000	 mov         r4, #0

; 36   :     HANDLE hDevice;
; 37   :     DEVMGR_DEVICE_INFORMATION di;
; 38   :     DWORD length;
; 39   : 
; 40   :     // Get device handle
; 41   :     hDevice = GetDeviceHandleFromContext(szActivePath);

  00020	eb000000	 bl          GetDeviceHandleFromContext
  00024	e1b05000	 movs        r5, r0

; 42   :     if (hDevice == NULL) goto cleanUp;

  00028	0a00004b	 beq         |$LN3@CreateBusA|

; 43   : 
; 44   :     // Get device name and parent bus device manager handler
; 45   :     memset(&di, 0, sizeof(di));

  0002c	e3a02e63	 mov         r2, #0x63, 28
  00030	e3a01000	 mov         r1, #0
  00034	e28d000c	 add         r0, sp, #0xC
  00038	eb000000	 bl          memset

; 46   :     di.dwSize = sizeof(di);

  0003c	e3a03e63	 mov         r3, #0x63, 28

; 47   :     if (!GetDeviceInformationByDeviceHandle(hDevice, &di)) goto cleanUp;

  00040	e28d100c	 add         r1, sp, #0xC
  00044	e1a00005	 mov         r0, r5
  00048	e58d300c	 str         r3, [sp, #0xC]
  0004c	eb000000	 bl          GetDeviceInformationByDeviceHandle
  00050	e3500000	 cmp         r0, #0
  00054	0a000040	 beq         |$LN3@CreateBusA|

; 48   : 
; 49   :     // Allocate internal structure
; 50   :     pBusAccess = LocalAlloc(LPTR, sizeof(PARENT_BUS_ACCESS));

  00058	e3a01010	 mov         r1, #0x10
  0005c	e3a00040	 mov         r0, #0x40
  00060	eb000000	 bl          LocalAlloc
  00064	e1b04000	 movs        r4, r0

; 51   :     if (pBusAccess == NULL) goto cleanUp;

  00068	0a00003b	 beq         |$LN3@CreateBusA|

; 52   : 
; 53   :     // Set cookie & hBus
; 54   :     pBusAccess->cookie = BUS_ACCESS_COOKIE;

  0006c	e59f3100	 ldr         r3, [pc, #0x100]

; 55   :     pBusAccess->hBus = INVALID_HANDLE_VALUE;

  00070	e3e02000	 mvn         r2, #0
  00074	e5842008	 str         r2, [r4, #8]
  00078	e5843000	 str         r3, [r4]

; 56   : 
; 57   :     // Save parent bus handler
; 58   :     pBusAccess->hRefBus = di.hParentDevice;

  0007c	e59d3014	 ldr         r3, [sp, #0x14]

; 59   : 
; 60   :     // Save device bus name
; 61   :     length = (wcslen(di.szBusName) + 1) * sizeof(WCHAR);

  00080	e3a00b01	 mov         r0, #1, 22
  00084	e3800034	 orr         r0, r0, #0x34
  00088	e08d0000	 add         r0, sp, r0
  0008c	e5843004	 str         r3, [r4, #4]
  00090	eb000000	 bl          wcslen
  00094	e2805001	 add         r5, r0, #1

; 62   :     pBusAccess->pszDeviceName = LocalAlloc(LPTR, length);

  00098	e1a01085	 mov         r1, r5, lsl #1
  0009c	e3a00040	 mov         r0, #0x40
  000a0	eb000000	 bl          LocalAlloc
  000a4	e3500000	 cmp         r0, #0
  000a8	e584000c	 str         r0, [r4, #0xC]

; 63   :     if (pBusAccess->pszDeviceName == NULL) goto cleanUp;

  000ac	0a000020	 beq         |$LN12@CreateBusA|

; 64   :     memcpy(pBusAccess->pszDeviceName, di.szBusName, length);

  000b0	e1a02085	 mov         r2, r5, lsl #1
  000b4	e3a01b01	 mov         r1, #1, 22
  000b8	e3811034	 orr         r1, r1, #0x34
  000bc	e08d1001	 add         r1, sp, r1
  000c0	eb000000	 bl          memcpy

; 65   : 
; 66   :     // Get parent bus info when there is one
; 67   :     if (pBusAccess->hRefBus != NULL)

  000c4	e5943004	 ldr         r3, [r4, #4]
  000c8	e3530000	 cmp         r3, #0
  000cc	0a000022	 beq         |$LN3@CreateBusA|

; 68   :         {
; 69   :         // Get parent bus device information
; 70   :         memset(&di, 0, sizeof(di));

  000d0	e3a02e63	 mov         r2, #0x63, 28
  000d4	e3a01000	 mov         r1, #0
  000d8	e28d000c	 add         r0, sp, #0xC
  000dc	eb000000	 bl          memset

; 71   :         di.dwSize = sizeof(di);

  000e0	e3a03e63	 mov         r3, #0x63, 28
  000e4	e58d300c	 str         r3, [sp, #0xC]

; 72   :         if (!GetDeviceInformationByDeviceHandle(pBusAccess->hRefBus, &di))

  000e8	e5940004	 ldr         r0, [r4, #4]
  000ec	e28d100c	 add         r1, sp, #0xC
  000f0	eb000000	 bl          GetDeviceInformationByDeviceHandle
  000f4	e3500000	 cmp         r0, #0
  000f8	0a00000d	 beq         |$LN12@CreateBusA|

; 73   :             {
; 74   :             goto cleanUp;
; 75   :             }
; 76   :         // Open bus for later calls
; 77   :         pBusAccess->hBus = CreateFile(
; 78   :             di.szBusName, GENERIC_READ|GENERIC_WRITE,
; 79   :             FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL
; 80   :             );

  000fc	e3a03003	 mov         r3, #3
  00100	e58d3000	 str         r3, [sp]
  00104	e3a0e000	 mov         lr, #0
  00108	e3a03000	 mov         r3, #0
  0010c	e3a02003	 mov         r2, #3
  00110	e3a01103	 mov         r1, #3, 2
  00114	e3a00b01	 mov         r0, #1, 22
  00118	e3800034	 orr         r0, r0, #0x34
  0011c	e08d0000	 add         r0, sp, r0
  00120	e58de008	 str         lr, [sp, #8]
  00124	e58de004	 str         lr, [sp, #4]
  00128	eb000000	 bl          CreateFileW
  0012c	e5840008	 str         r0, [r4, #8]
  00130		 |$cleanUp$43221|

; 81   :         }        
; 82   : 
; 83   :     // Done
; 84   :     rc = TRUE;
; 85   : 
; 86   : cleanUp:
; 87   :     if (!rc && pBusAccess != NULL)

  00130	ea000009	 b           |$LN3@CreateBusA|
  00134		 |$LN12@CreateBusA|

; 88   :         {
; 89   :         if (pBusAccess->hBus != INVALID_HANDLE_VALUE)

  00134	e5940008	 ldr         r0, [r4, #8]
  00138	e3700001	 cmn         r0, #1

; 90   :             {
; 91   :             CloseHandle(pBusAccess->hBus);

  0013c	1b000000	 blne        CloseHandle

; 92   :             }            
; 93   :         if (pBusAccess->pszDeviceName != NULL)

  00140	e594300c	 ldr         r3, [r4, #0xC]
  00144	e3530000	 cmp         r3, #0

; 94   :             {
; 95   :             LocalFree(pBusAccess->pszDeviceName);

  00148	11a00003	 movne       r0, r3
  0014c	1b000000	 blne        LocalFree

; 96   :             }
; 97   :         LocalFree(pBusAccess);

  00150	e1a00004	 mov         r0, r4
  00154	eb000000	 bl          LocalFree

; 98   :         pBusAccess = NULL;

  00158	e3a04000	 mov         r4, #0
  0015c		 |$LN3@CreateBusA|

; 99   :         }
; 100  :     return pBusAccess;

  0015c	e59d063c	 ldr         r0, [sp, #0x63C]
  00160	eb000000	 bl          __security_check_cookie

; 101  : }

  00164	e1a00004	 mov         r0, r4
  00168	e28ddd19	 add         sp, sp, #0x19, 26
  0016c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00170	e12fff1e	 bx          lr
  00174		 |$LN16@CreateBusA|
  00174		 |$LN17@CreateBusA|
  00174	41737562	 DCD         0x41737562
  00178		 |$LN18@CreateBusA|
  00178	00000000	 DCD         |__security_cookie|
  0017c		 |$M43635|

			 ENDP  ; |CreateBusAccessHandle|

	EXPORT	|CloseBusAccessHandle|
	IMPORT	|SetLastError|

  00000			 AREA	 |.pdata|, PDATA
|$T43649| DCD	|$LN9@CloseBusAc|
	DCD	0x40001701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |CloseBusAccessHandle| PROC

; 106  : {

  00000		 |$LN9@CloseBusAc|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M43646|
  00004	e1b04000	 movs        r4, r0

; 107  :     PARENT_BUS_ACCESS *pBusAccess = (PARENT_BUS_ACCESS *)hBusAccess;
; 108  : 
; 109  :     if ((pBusAccess == NULL) || (pBusAccess->cookie != BUS_ACCESS_COOKIE))

  00008	0a00000e	 beq         |$LN3@CloseBusAc|
  0000c	e5942000	 ldr         r2, [r4]
  00010	e59f3040	 ldr         r3, [pc, #0x40]
  00014	e1520003	 cmp         r2, r3
  00018	1a00000a	 bne         |$LN3@CloseBusAc|

; 112  :         goto cleanUp;
; 113  :         }
; 114  : 
; 115  :     if (pBusAccess->hBus != INVALID_HANDLE_VALUE) CloseHandle(pBusAccess->hBus);

  0001c	e5940008	 ldr         r0, [r4, #8]
  00020	e3700001	 cmn         r0, #1
  00024	1b000000	 blne        CloseHandle

; 116  :     if (pBusAccess->pszDeviceName != NULL) LocalFree(pBusAccess->pszDeviceName);

  00028	e594300c	 ldr         r3, [r4, #0xC]
  0002c	e3530000	 cmp         r3, #0
  00030	11a00003	 movne       r0, r3
  00034	1b000000	 blne        LocalFree

; 117  :     LocalFree(pBusAccess);

  00038	e1a00004	 mov         r0, r4
  0003c	eb000000	 bl          LocalFree

; 118  : 
; 119  : cleanUp:
; 120  :     return;
; 121  : }

  00040	e8bd4010	 ldmia       sp!, {r4, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$LN3@CloseBusAc|

; 110  :         {
; 111  :         SetLastError(ERROR_INVALID_HANDLE);

  00048	e3a00006	 mov         r0, #6
  0004c	eb000000	 bl          SetLastError
  00050		 |$cleanUp$43250|

; 118  : 
; 119  : cleanUp:
; 120  :     return;
; 121  : }

  00050	e8bd4010	 ldmia       sp!, {r4, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$LN10@CloseBusAc|
  00058		 |$LN11@CloseBusAc|
  00058	41737562	 DCD         0x41737562
  0005c		 |$M43647|

			 ENDP  ; |CloseBusAccessHandle|

	EXPORT	|SetDevicePowerState|
	IMPORT	|DeviceIoControl|

  00000			 AREA	 |.pdata|, PDATA
|$T43663| DCD	|$LN8@SetDeviceP|
	DCD	0x40002a04
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetDevicePowerState| PROC

; 127  : ) {

  00000		 |$LN8@SetDeviceP|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d51f0	 stmdb       sp!, {r4 - r8, r12, lr}
  0000c	e24dd028	 sub         sp, sp, #0x28
  00010		 |$M43660|
  00010	e1a06002	 mov         r6, r2
  00014	e3500000	 cmp         r0, #0

; 128  :     BOOL rc = FALSE;

  00018	e3a04000	 mov         r4, #0

; 129  :     PARENT_BUS_ACCESS *pBusAccess = (PARENT_BUS_ACCESS *)hBusAccess;
; 130  :     CE_BUS_POWER_STATE ps, psout;
; 131  :     
; 132  :     // Check passed handler
; 133  :     if (pBusAccess == NULL || pBusAccess->cookie != BUS_ACCESS_COOKIE)

  0001c	0a00001a	 beq         |$LN2@SetDeviceP|
  00020	e5901000	 ldr         r1, [r0]
  00024	e59f3078	 ldr         r3, [pc, #0x78]
  00028	e1510003	 cmp         r1, r3
  0002c	1a000016	 bne         |$LN2@SetDeviceP|

; 136  :         goto cleanUp;
; 137  :         }
; 138  : 
; 139  :     // Call parent device
; 140  :     if (pBusAccess->hBus != INVALID_HANDLE_VALUE)

  00030	e5905008	 ldr         r5, [r0, #8]
  00034	e3750001	 cmn         r5, #1
  00038	0a000015	 beq         |$cleanUp$43270|

; 141  :         {
; 142  :         ps.lpDeviceBusName = pBusAccess->pszDeviceName;

  0003c	e590300c	 ldr         r3, [r0, #0xC]
  00040	e3a0182a	 mov         r1, #0x2A, 16

; 143  :         ps.lpceDevicePowerState = &powerState;

  00044	e28de048	 add         lr, sp, #0x48

; 144  :         ps.lpReserved = pReserved;
; 145  : 
; 146  :         // Due to problem with public\common\oak\busenum\defbus\defbus.cpp
; 147  :         // IOCTL_BUS_SET_POWER_STATE should always be called with lpOutBuffer
; 148  :         // pointing to a CE_BUS_POWER_STATE structure.
; 149  :         rc = DeviceIoControl(
; 150  :             pBusAccess->hBus, IOCTL_BUS_SET_POWER_STATE, &ps, sizeof(ps),
; 151  :             &psout, sizeof(psout), NULL, 0
; 152  :             );

  00048	e58d3010	 str         r3, [sp, #0x10]
  0004c	e3a0800c	 mov         r8, #0xC
  00050	e28d401c	 add         r4, sp, #0x1C
  00054	e3a07000	 mov         r7, #0
  00058	e3a0300c	 mov         r3, #0xC
  0005c	e28d2010	 add         r2, sp, #0x10
  00060	e3811010	 orr         r1, r1, #0x10
  00064	e1a00005	 mov         r0, r5
  00068	e58de014	 str         lr, [sp, #0x14]
  0006c	e58d6018	 str         r6, [sp, #0x18]
  00070	e58d700c	 str         r7, [sp, #0xC]
  00074	e58d7008	 str         r7, [sp, #8]
  00078	e58d8004	 str         r8, [sp, #4]
  0007c	e58d4000	 str         r4, [sp]
  00080	eb000000	 bl          DeviceIoControl
  00084	e1a04000	 mov         r4, r0
  00088	ea000001	 b           |$cleanUp$43270|
  0008c		 |$LN2@SetDeviceP|

; 134  :         {
; 135  :         SetLastError(ERROR_INVALID_HANDLE);

  0008c	e3a00006	 mov         r0, #6
  00090	eb000000	 bl          SetLastError
  00094		 |$cleanUp$43270|

; 153  :         }
; 154  : 
; 155  : cleanUp:
; 156  :     return rc;
; 157  : }

  00094	e1a00004	 mov         r0, r4
  00098	e28dd028	 add         sp, sp, #0x28
  0009c	e89d61f0	 ldmia       sp, {r4 - r8, sp, lr}
  000a0	e12fff1e	 bx          lr
  000a4		 |$LN9@SetDeviceP|
  000a4		 |$LN10@SetDeviceP|
  000a4	41737562	 DCD         0x41737562
  000a8		 |$M43661|

			 ENDP  ; |SetDevicePowerState|

	EXPORT	|GetDevicePowerState|

  00000			 AREA	 |.pdata|, PDATA
|$T43678| DCD	|$LN8@GetDeviceP|
	DCD	0x40002602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetDevicePowerState| PROC

; 163  : ) {

  00000		 |$LN8@GetDeviceP|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd01c	 sub         sp, sp, #0x1C
  00008		 |$M43675|
  00008	e1a05002	 mov         r5, r2
  0000c	e1a06001	 mov         r6, r1
  00010	e3500000	 cmp         r0, #0

; 164  :     BOOL rc = FALSE;

  00014	e3a04000	 mov         r4, #0

; 165  :     PARENT_BUS_ACCESS *pBusAccess = (PARENT_BUS_ACCESS *)hBusAccess;
; 166  :     CE_BUS_POWER_STATE ps;
; 167  : 
; 168  :     // Check passed handler
; 169  :     if (pBusAccess == NULL || pBusAccess->cookie != BUS_ACCESS_COOKIE)

  00018	0a000017	 beq         |$LN2@GetDeviceP|
  0001c	e590e000	 ldr         lr, [r0]
  00020	e59f306c	 ldr         r3, [pc, #0x6C]
  00024	e15e0003	 cmp         lr, r3
  00028	1a000013	 bne         |$LN2@GetDeviceP|

; 172  :         goto cleanUp;
; 173  :         }
; 174  : 
; 175  :     // Call parent device
; 176  :     if (pBusAccess->hBus != INVALID_HANDLE_VALUE)

  0002c	e590e008	 ldr         lr, [r0, #8]
  00030	e37e0001	 cmn         lr, #1
  00034	0a000012	 beq         |$cleanUp$43288|

; 177  :         {
; 178  :         ps.lpDeviceBusName = pBusAccess->pszDeviceName;

  00038	e590300c	 ldr         r3, [r0, #0xC]
  0003c	e3a0182a	 mov         r1, #0x2A, 16

; 179  :         ps.lpceDevicePowerState = pPowerState;
; 180  :         ps.lpReserved = pReserved;
; 181  :         rc = DeviceIoControl(
; 182  :             pBusAccess->hBus, IOCTL_BUS_GET_POWER_STATE, &ps, sizeof(ps),
; 183  :             NULL, 0, NULL, 0
; 184  :             );

  00040	e3a04000	 mov         r4, #0
  00044	e58d3010	 str         r3, [sp, #0x10]
  00048	e3a0300c	 mov         r3, #0xC
  0004c	e28d2010	 add         r2, sp, #0x10
  00050	e381100c	 orr         r1, r1, #0xC
  00054	e1a0000e	 mov         r0, lr
  00058	e58d6014	 str         r6, [sp, #0x14]
  0005c	e58d5018	 str         r5, [sp, #0x18]
  00060	e58d400c	 str         r4, [sp, #0xC]
  00064	e58d4008	 str         r4, [sp, #8]
  00068	e58d4004	 str         r4, [sp, #4]
  0006c	e58d4000	 str         r4, [sp]
  00070	eb000000	 bl          DeviceIoControl
  00074	e1a04000	 mov         r4, r0
  00078	ea000001	 b           |$cleanUp$43288|
  0007c		 |$LN2@GetDeviceP|

; 170  :         {
; 171  :         SetLastError(ERROR_INVALID_HANDLE);

  0007c	e3a00006	 mov         r0, #6
  00080	eb000000	 bl          SetLastError
  00084		 |$cleanUp$43288|

; 185  :         }
; 186  : 
; 187  : cleanUp:
; 188  :     return rc;
; 189  : }

  00084	e1a00004	 mov         r0, r4
  00088	e28dd01c	 add         sp, sp, #0x1C
  0008c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$LN9@GetDeviceP|
  00094		 |$LN10@GetDeviceP|
  00094	41737562	 DCD         0x41737562
  00098		 |$M43676|

			 ENDP  ; |GetDevicePowerState|

	EXPORT	|TranslateBusAddr|
	IMPORT	|HalTranslateBusAddress|

  00000			 AREA	 |.pdata|, PDATA
|$T43694| DCD	|$LN9@TranslateB|
	DCD	0x40003b04
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TranslateBusAddr| PROC

; 197  : ) {

  00000		 |$LN9@TranslateB|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d57f0	 stmdb       sp!, {r4 - r10, r12, lr}
  0000c	e24dd030	 sub         sp, sp, #0x30
  00010		 |$M43691|
  00010	e1a08003	 mov         r8, r3
  00014	e1a09002	 mov         r9, r2
  00018	e1a0a001	 mov         r10, r1
  0001c	e3500000	 cmp         r0, #0

; 198  :     BOOL rc = FALSE;

  00020	e3a05000	 mov         r5, #0

; 199  :     PARENT_BUS_ACCESS *pBusAccess = (PARENT_BUS_ACCESS *)hBusAccess;
; 200  :     CE_BUS_TRANSLATE_BUS_ADDR busTranslate;
; 201  : 
; 202  :     // Check passed handler
; 203  :     if (pBusAccess == NULL || pBusAccess->cookie != BUS_ACCESS_COOKIE) {

  00024	0a000029	 beq         |$LN3@TranslateB|
  00028	e5904000	 ldr         r4, [r0]
  0002c	e59fe0b4	 ldr         lr, [pc, #0xB4]
  00030	e154000e	 cmp         r4, lr
  00034	1a000025	 bne         |$LN3@TranslateB|

; 205  :         goto clean;
; 206  :     }
; 207  : 
; 208  :     if (pBusAccess->hBus != INVALID_HANDLE_VALUE) {

  00038	e5907008	 ldr         r7, [r0, #8]
  0003c	e3770001	 cmn         r7, #1
  00040	0a000017	 beq         |$LN2@TranslateB|

; 209  :         // Call parent device bus
; 210  :         busTranslate.lpDeviceBusName = pBusAccess->pszDeviceName;

  00044	e590e00c	 ldr         lr, [r0, #0xC]

; 211  :         busTranslate.InterfaceType = interfaceType;
; 212  :         busTranslate.BusNumber = busNumber;
; 213  :         busTranslate.BusAddress = busAddress;

  00048	e59d4064	 ldr         r4, [sp, #0x64]

; 214  :         busTranslate.AddressSpace = pAddressSpace;

  0004c	e59d5068	 ldr         r5, [sp, #0x68]

; 215  :         busTranslate.TranslatedAddress = pTranslatedAddress;

  00050	e59d606c	 ldr         r6, [sp, #0x6C]
  00054	e58de010	 str         lr, [sp, #0x10]
  00058	e3a0182a	 mov         r1, #0x2A, 16

; 216  :         rc = DeviceIoControl(
; 217  :             pBusAccess->hBus, IOCTL_BUS_TRANSLATE_BUS_ADDRESS, &busTranslate,
; 218  :             sizeof(busTranslate), NULL, 0, NULL, 0
; 219  :         );

  0005c	e3a0e000	 mov         lr, #0
  00060	e3a03020	 mov         r3, #0x20
  00064	e28d2010	 add         r2, sp, #0x10
  00068	e3811004	 orr         r1, r1, #4
  0006c	e1a00007	 mov         r0, r7
  00070	e58de00c	 str         lr, [sp, #0xC]
  00074	e58de008	 str         lr, [sp, #8]
  00078	e58de004	 str         lr, [sp, #4]
  0007c	e58de000	 str         lr, [sp]
  00080	e58d4024	 str         r4, [sp, #0x24]
  00084	e58d5028	 str         r5, [sp, #0x28]
  00088	e58d602c	 str         r6, [sp, #0x2C]
  0008c	e58da014	 str         r10, [sp, #0x14]
  00090	e58d9018	 str         r9, [sp, #0x18]
  00094	e58d8020	 str         r8, [sp, #0x20]
  00098	eb000000	 bl          DeviceIoControl
  0009c	e1a05000	 mov         r5, r0

; 220  :     } else {

  000a0	ea00000c	 b           |$clean$43313|
  000a4		 |$LN2@TranslateB|

; 221  :         // Call HAL
; 222  :         rc = HalTranslateBusAddress(
; 223  :             interfaceType, busNumber, busAddress, pAddressSpace, 
; 224  :             pTranslatedAddress
; 225  :         );

  000a4	e59d206c	 ldr         r2, [sp, #0x6C]
  000a8	e59d1068	 ldr         r1, [sp, #0x68]
  000ac	e59d3064	 ldr         r3, [sp, #0x64]
  000b0	e58d2004	 str         r2, [sp, #4]
  000b4	e58d1000	 str         r1, [sp]
  000b8	e1a02008	 mov         r2, r8
  000bc	e1a01009	 mov         r1, r9
  000c0	e1a0000a	 mov         r0, r10
  000c4	eb000000	 bl          HalTranslateBusAddress
  000c8	e1a05000	 mov         r5, r0
  000cc	ea000001	 b           |$clean$43313|
  000d0		 |$LN3@TranslateB|

; 204  :         SetLastError(ERROR_INVALID_HANDLE);

  000d0	e3a00006	 mov         r0, #6
  000d4	eb000000	 bl          SetLastError
  000d8		 |$clean$43313|

; 226  :     }
; 227  :     
; 228  : clean:
; 229  :     return rc;
; 230  : }

  000d8	e1a00005	 mov         r0, r5
  000dc	e28dd030	 add         sp, sp, #0x30
  000e0	e89d67f0	 ldmia       sp, {r4 - r10, sp, lr}
  000e4	e12fff1e	 bx          lr
  000e8		 |$LN10@TranslateB|
  000e8		 |$LN11@TranslateB|
  000e8	41737562	 DCD         0x41737562
  000ec		 |$M43692|

			 ENDP  ; |TranslateBusAddr|

	EXPORT	|TranslateSystemAddr|
	IMPORT	|HalTranslateSystemAddress|

  00000			 AREA	 |.pdata|, PDATA
|$T43710| DCD	|$LN9@TranslateS|
	DCD	0x40003704
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TranslateSystemAddr| PROC

; 237  : ) {

  00000		 |$LN9@TranslateS|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d53f0	 stmdb       sp!, {r4 - r9, r12, lr}
  0000c	e24dd030	 sub         sp, sp, #0x30
  00010		 |$M43707|
  00010	e1a07003	 mov         r7, r3
  00014	e1a08002	 mov         r8, r2
  00018	e1a09001	 mov         r9, r1
  0001c	e3500000	 cmp         r0, #0

; 238  :     BOOL rc = FALSE;

  00020	e3a05000	 mov         r5, #0

; 239  :     PARENT_BUS_ACCESS *pBusAccess = (PARENT_BUS_ACCESS *)hBusAccess;
; 240  :     CE_BUS_TRANSLATE_SYSTEM_ADDR systemTranslate;
; 241  : 
; 242  : 
; 243  :     // Check passed handler
; 244  :     if (pBusAccess == NULL || pBusAccess->cookie != BUS_ACCESS_COOKIE) {

  00024	0a000025	 beq         |$LN3@TranslateS|
  00028	e5904000	 ldr         r4, [r0]
  0002c	e59fe0a4	 ldr         lr, [pc, #0xA4]
  00030	e154000e	 cmp         r4, lr
  00034	1a000021	 bne         |$LN3@TranslateS|

; 246  :         goto clean;
; 247  :     }
; 248  : 
; 249  :     if (pBusAccess->hBus != INVALID_HANDLE_VALUE) {

  00038	e5906008	 ldr         r6, [r0, #8]
  0003c	e3760001	 cmn         r6, #1
  00040	0a000015	 beq         |$LN2@TranslateS|

; 250  :         // Call parent device bus
; 251  :         systemTranslate.lpDeviceBusName = pBusAccess->pszDeviceName;

  00044	e590e00c	 ldr         lr, [r0, #0xC]

; 252  :         systemTranslate.InterfaceType =  interfaceType;
; 253  :         systemTranslate.BusNumber = busNumber;
; 254  :         systemTranslate.SystemAddress = systemAddress;

  00048	e59d4060	 ldr         r4, [sp, #0x60]

; 255  :         systemTranslate.TranslatedAddress = pTranslatedAddress;

  0004c	e59d5064	 ldr         r5, [sp, #0x64]
  00050	e58de010	 str         lr, [sp, #0x10]
  00054	e3a0182a	 mov         r1, #0x2A, 16

; 256  :         rc = DeviceIoControl(
; 257  :             pBusAccess->hBus, IOCTL_BUS_TRANSLATE_SYSTEM_ADDRESS,
; 258  :             &systemTranslate, sizeof(systemTranslate), NULL, 0, NULL, 0
; 259  :         );

  00058	e3a0e000	 mov         lr, #0
  0005c	e3a03020	 mov         r3, #0x20
  00060	e28d2010	 add         r2, sp, #0x10
  00064	e3811008	 orr         r1, r1, #8
  00068	e1a00006	 mov         r0, r6
  0006c	e58de00c	 str         lr, [sp, #0xC]
  00070	e58de008	 str         lr, [sp, #8]
  00074	e58de004	 str         lr, [sp, #4]
  00078	e58de000	 str         lr, [sp]
  0007c	e58d4024	 str         r4, [sp, #0x24]
  00080	e58d5028	 str         r5, [sp, #0x28]
  00084	e58d9014	 str         r9, [sp, #0x14]
  00088	e58d8018	 str         r8, [sp, #0x18]
  0008c	e58d7020	 str         r7, [sp, #0x20]
  00090	eb000000	 bl          DeviceIoControl
  00094	e1a05000	 mov         r5, r0

; 260  :     }  else {

  00098	ea00000a	 b           |$clean$43337|
  0009c		 |$LN2@TranslateS|

; 261  :         // Call HAL
; 262  :         rc = HalTranslateSystemAddress(
; 263  :             interfaceType, busNumber, systemAddress, pTranslatedAddress
; 264  :         );

  0009c	e59d1064	 ldr         r1, [sp, #0x64]
  000a0	e59d3060	 ldr         r3, [sp, #0x60]
  000a4	e1a02007	 mov         r2, r7
  000a8	e58d1000	 str         r1, [sp]
  000ac	e1a01008	 mov         r1, r8
  000b0	e1a00009	 mov         r0, r9
  000b4	eb000000	 bl          HalTranslateSystemAddress
  000b8	e1a05000	 mov         r5, r0
  000bc	ea000001	 b           |$clean$43337|
  000c0		 |$LN3@TranslateS|

; 245  :         SetLastError(ERROR_INVALID_HANDLE);

  000c0	e3a00006	 mov         r0, #6
  000c4	eb000000	 bl          SetLastError
  000c8		 |$clean$43337|

; 265  :     }
; 266  : 
; 267  : clean:
; 268  :     return rc;
; 269  : }

  000c8	e1a00005	 mov         r0, r5
  000cc	e28dd030	 add         sp, sp, #0x30
  000d0	e89d63f0	 ldmia       sp, {r4 - r9, sp, lr}
  000d4	e12fff1e	 bx          lr
  000d8		 |$LN10@TranslateS|
  000d8		 |$LN11@TranslateS|
  000d8	41737562	 DCD         0x41737562
  000dc		 |$M43708|

			 ENDP  ; |TranslateSystemAddr|

	EXPORT	|SetDeviceConfigurationData|
	IMPORT	|HalSetBusDataByOffset|

  00000			 AREA	 |.pdata|, PDATA
|$T43727| DCD	|$LN13@SetDeviceC|
	DCD	0x40003902
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetDeviceConfigurationData| PROC

; 276  : ) {

  00000		 |$LN13@SetDeviceC|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd024	 sub         sp, sp, #0x24
  00008		 |$M43724|
  00008	e1a08003	 mov         r8, r3
  0000c	e1a09002	 mov         r9, r2
  00010	e1a07001	 mov         r7, r1
  00014	e3500000	 cmp         r0, #0

; 277  :     ULONG rc = 0;

  00018	e3a05000	 mov         r5, #0

; 278  :     PARENT_BUS_ACCESS *pBusAccess = (PARENT_BUS_ACCESS *)hBusAccess;
; 279  :     CE_BUS_DEVICE_CONFIGURATION_DATA deviceConfigData;
; 280  : 
; 281  : 
; 282  :     // Check passed handler
; 283  :     if (pBusAccess == NULL || pBusAccess->cookie != BUS_ACCESS_COOKIE) {

  0001c	0a000029	 beq         |$LN6@SetDeviceC|
  00020	e5904000	 ldr         r4, [r0]
  00024	e59fe0b4	 ldr         lr, [pc, #0xB4]
  00028	e154000e	 cmp         r4, lr
  0002c	1a000025	 bne         |$LN6@SetDeviceC|

; 285  :         goto clean;
; 286  :     }
; 287  : 
; 288  :     if (pBusAccess->hBus != INVALID_HANDLE_VALUE) {

  00030	e5906008	 ldr         r6, [r0, #8]
  00034	e3760001	 cmn         r6, #1
  00038	0a000015	 beq         |$LN5@SetDeviceC|

; 289  :         // Call parent device bus
; 290  :         deviceConfigData.lpDeviceBusName = pBusAccess->pszDeviceName;
; 291  :         deviceConfigData.dwSpace = space;
; 292  :         deviceConfigData.dwOffset = offset;
; 293  :         deviceConfigData.dwLength = length;

  0003c	e59de044	 ldr         lr, [sp, #0x44]
  00040	e590300c	 ldr         r3, [r0, #0xC]
  00044	e59d2040	 ldr         r2, [sp, #0x40]

; 294  :         deviceConfigData.pBuffer = pBuffer;

  00048	e59d4048	 ldr         r4, [sp, #0x48]
  0004c	e58de01c	 str         lr, [sp, #0x1C]
  00050	e3a0182a	 mov         r1, #0x2A, 16

; 295  :         rc = DeviceIoControl(
; 296  :             pBusAccess->hBus, IOCTL_BUS_SET_CONFIGURE_DATA, &deviceConfigData,
; 297  :             sizeof(deviceConfigData), NULL, 0, NULL, 0
; 298  :         );

  00054	e3a0e000	 mov         lr, #0
  00058	e58d3010	 str         r3, [sp, #0x10]
  0005c	e58d2018	 str         r2, [sp, #0x18]
  00060	e3a03014	 mov         r3, #0x14
  00064	e28d2010	 add         r2, sp, #0x10
  00068	e3811018	 orr         r1, r1, #0x18
  0006c	e1a00006	 mov         r0, r6
  00070	e58de00c	 str         lr, [sp, #0xC]
  00074	e58de008	 str         lr, [sp, #8]
  00078	e58de004	 str         lr, [sp, #4]
  0007c	e58de000	 str         lr, [sp]
  00080	e58d4020	 str         r4, [sp, #0x20]
  00084	e58d7014	 str         r7, [sp, #0x14]
  00088	eb000000	 bl          DeviceIoControl

; 303  :         // Call HAL for config space
; 304  :         rc = HalSetBusDataByOffset(
; 305  :             PCIConfiguration, busNumber, slotNumber, pBuffer, offset, length
; 306  :         );

  0008c	e1a05000	 mov         r5, r0

; 307  :     } else {

  00090	ea00000e	 b           |$clean$43365|
  00094		 |$LN5@SetDeviceC|

; 299  :     } else if (
; 300  :         space == PCI_WHICHSPACE_CONFIG || 
; 301  :         space == PCCARD_PCI_CONFIGURATION_SPACE
; 302  :     ) {

  00094	e3570000	 cmp         r7, #0

; 308  :         SetLastError(ERROR_INVALID_HANDLE);

  00098	1a00000a	 bne         |$LN6@SetDeviceC|
  0009c	e59d2044	 ldr         r2, [sp, #0x44]
  000a0	e59d1040	 ldr         r1, [sp, #0x40]
  000a4	e59d3048	 ldr         r3, [sp, #0x48]
  000a8	e58d2004	 str         r2, [sp, #4]
  000ac	e58d1000	 str         r1, [sp]
  000b0	e1a02008	 mov         r2, r8
  000b4	e1a01009	 mov         r1, r9
  000b8	e3a00004	 mov         r0, #4
  000bc	eb000000	 bl          HalSetBusDataByOffset
  000c0	e1a05000	 mov         r5, r0
  000c4	ea000001	 b           |$clean$43365|
  000c8		 |$LN6@SetDeviceC|

; 284  :         SetLastError(ERROR_INVALID_HANDLE);

  000c8	e3a00006	 mov         r0, #6
  000cc	eb000000	 bl          SetLastError
  000d0		 |$clean$43365|

; 309  :     }
; 310  : 
; 311  : clean:
; 312  :     return rc;
; 313  : }

  000d0	e1a00005	 mov         r0, r5
  000d4	e28dd024	 add         sp, sp, #0x24
  000d8	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000dc	e12fff1e	 bx          lr
  000e0		 |$LN14@SetDeviceC|
  000e0		 |$LN15@SetDeviceC|
  000e0	41737562	 DCD         0x41737562
  000e4		 |$M43725|

			 ENDP  ; |SetDeviceConfigurationData|

	EXPORT	|GetDeviceConfigurationData|
	IMPORT	|HalGetBusDataByOffset|

  00000			 AREA	 |.pdata|, PDATA
|$T43744| DCD	|$LN13@GetDeviceC|
	DCD	0x40003902
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetDeviceConfigurationData| PROC

; 320  : ) {

  00000		 |$LN13@GetDeviceC|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd024	 sub         sp, sp, #0x24
  00008		 |$M43741|
  00008	e1a08003	 mov         r8, r3
  0000c	e1a09002	 mov         r9, r2
  00010	e1a07001	 mov         r7, r1
  00014	e3500000	 cmp         r0, #0

; 321  :     ULONG rc = 0;

  00018	e3a05000	 mov         r5, #0

; 322  :     PARENT_BUS_ACCESS *pBusAccess = (PARENT_BUS_ACCESS *)hBusAccess;
; 323  :     CE_BUS_DEVICE_CONFIGURATION_DATA deviceConfigData;
; 324  : 
; 325  : 
; 326  :     // Check passed handler
; 327  :     if (pBusAccess == NULL || pBusAccess->cookie != BUS_ACCESS_COOKIE) {

  0001c	0a000029	 beq         |$LN6@GetDeviceC|
  00020	e5904000	 ldr         r4, [r0]
  00024	e59fe0b4	 ldr         lr, [pc, #0xB4]
  00028	e154000e	 cmp         r4, lr
  0002c	1a000025	 bne         |$LN6@GetDeviceC|

; 329  :         goto clean;
; 330  :     }
; 331  : 
; 332  :     if (pBusAccess->hBus != INVALID_HANDLE_VALUE) {

  00030	e5906008	 ldr         r6, [r0, #8]
  00034	e3760001	 cmn         r6, #1
  00038	0a000015	 beq         |$LN5@GetDeviceC|

; 333  :         // Call parent device bus
; 334  :         deviceConfigData.lpDeviceBusName = pBusAccess->pszDeviceName;
; 335  :         deviceConfigData.dwSpace = space;
; 336  :         deviceConfigData.dwOffset = offset;
; 337  :         deviceConfigData.dwLength = length;

  0003c	e59de044	 ldr         lr, [sp, #0x44]
  00040	e590300c	 ldr         r3, [r0, #0xC]
  00044	e59d2040	 ldr         r2, [sp, #0x40]

; 338  :         deviceConfigData.pBuffer = pBuffer;

  00048	e59d4048	 ldr         r4, [sp, #0x48]
  0004c	e58de01c	 str         lr, [sp, #0x1C]
  00050	e3a0182a	 mov         r1, #0x2A, 16

; 339  :         rc = DeviceIoControl(
; 340  :             pBusAccess->hBus, IOCTL_BUS_GET_CONFIGURE_DATA, &deviceConfigData,
; 341  :             sizeof(deviceConfigData), NULL, 0, NULL, 0
; 342  :         );

  00054	e3a0e000	 mov         lr, #0
  00058	e58d3010	 str         r3, [sp, #0x10]
  0005c	e58d2018	 str         r2, [sp, #0x18]
  00060	e3a03014	 mov         r3, #0x14
  00064	e28d2010	 add         r2, sp, #0x10
  00068	e3811014	 orr         r1, r1, #0x14
  0006c	e1a00006	 mov         r0, r6
  00070	e58de00c	 str         lr, [sp, #0xC]
  00074	e58de008	 str         lr, [sp, #8]
  00078	e58de004	 str         lr, [sp, #4]
  0007c	e58de000	 str         lr, [sp]
  00080	e58d4020	 str         r4, [sp, #0x20]
  00084	e58d7014	 str         r7, [sp, #0x14]
  00088	eb000000	 bl          DeviceIoControl

; 347  :         // Call HAL for config space
; 348  :         rc = HalGetBusDataByOffset(
; 349  :             PCIConfiguration, busNumber, slotNumber, pBuffer, offset, length
; 350  :         );

  0008c	e1a05000	 mov         r5, r0

; 351  :     } else {

  00090	ea00000e	 b           |$clean$43396|
  00094		 |$LN5@GetDeviceC|

; 343  :     } else if (
; 344  :         space == PCI_WHICHSPACE_CONFIG || 
; 345  :         space == PCCARD_PCI_CONFIGURATION_SPACE
; 346  :     ) {

  00094	e3570000	 cmp         r7, #0

; 352  :         SetLastError(ERROR_INVALID_HANDLE);

  00098	1a00000a	 bne         |$LN6@GetDeviceC|
  0009c	e59d2044	 ldr         r2, [sp, #0x44]
  000a0	e59d1040	 ldr         r1, [sp, #0x40]
  000a4	e59d3048	 ldr         r3, [sp, #0x48]
  000a8	e58d2004	 str         r2, [sp, #4]
  000ac	e58d1000	 str         r1, [sp]
  000b0	e1a02008	 mov         r2, r8
  000b4	e1a01009	 mov         r1, r9
  000b8	e3a00004	 mov         r0, #4
  000bc	eb000000	 bl          HalGetBusDataByOffset
  000c0	e1a05000	 mov         r5, r0
  000c4	ea000001	 b           |$clean$43396|
  000c8		 |$LN6@GetDeviceC|

; 328  :         SetLastError(ERROR_INVALID_HANDLE);

  000c8	e3a00006	 mov         r0, #6
  000cc	eb000000	 bl          SetLastError
  000d0		 |$clean$43396|

; 353  :     }
; 354  : 
; 355  : clean:
; 356  :     return rc;
; 357  : }

  000d0	e1a00005	 mov         r0, r5
  000d4	e28dd024	 add         sp, sp, #0x24
  000d8	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000dc	e12fff1e	 bx          lr
  000e0		 |$LN14@GetDeviceC|
  000e0		 |$LN15@GetDeviceC|
  000e0	41737562	 DCD         0x41737562
  000e4		 |$M43742|

			 ENDP  ; |GetDeviceConfigurationData|

	EXPORT	|GetParentDeviceInfo|

  00000			 AREA	 |.pdata|, PDATA
|$T43758| DCD	|$LN7@GetParentD|
	DCD	0x40001201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetParentDeviceInfo| PROC

; 362  : {

  00000		 |$LN7@GetParentD|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M43755|
  00004	e3500000	 cmp         r0, #0

; 363  :     BOOL rc = FALSE;

  00008	e3a04000	 mov         r4, #0

; 364  :     PARENT_BUS_ACCESS *pBusAccess = (PARENT_BUS_ACCESS *)hBusAccess;
; 365  : 
; 366  :     // Check passed handler
; 367  :     if (pBusAccess == NULL || pBusAccess->cookie != BUS_ACCESS_COOKIE) {

  0000c	0a000007	 beq         |$LN1@GetParentD|
  00010	e5902000	 ldr         r2, [r0]
  00014	e59f3028	 ldr         r3, [pc, #0x28]
  00018	e1520003	 cmp         r2, r3
  0001c	1a000003	 bne         |$LN1@GetParentD|

; 369  :         goto clean;
; 370  :     }
; 371  : 
; 372  :     rc = GetDeviceInformationByDeviceHandle(pBusAccess->hRefBus, pInfo);

  00020	e5900004	 ldr         r0, [r0, #4]
  00024	eb000000	 bl          GetDeviceInformationByDeviceHandle
  00028	e1a04000	 mov         r4, r0
  0002c	ea000001	 b           |$clean$43416|
  00030		 |$LN1@GetParentD|

; 368  :         SetLastError(ERROR_INVALID_HANDLE);

  00030	e3a00006	 mov         r0, #6
  00034	eb000000	 bl          SetLastError
  00038		 |$clean$43416|

; 373  : 
; 374  : clean:
; 375  :     return rc;
; 376  : }

  00038	e1a00004	 mov         r0, r4
  0003c	e8bd4010	 ldmia       sp!, {r4, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$LN8@GetParentD|
  00044		 |$LN9@GetParentD|
  00044	41737562	 DCD         0x41737562
  00048		 |$M43756|

			 ENDP  ; |GetParentDeviceInfo|

	EXPORT	|GetChildDeviceRemoveState|

  00000			 AREA	 |.pdata|, PDATA
|$T43772| DCD	|$LN8@GetChildDe|
	DCD	0x40002502
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetChildDeviceRemoveState| PROC

; 381  : {

  00000		 |$LN8@GetChildDe|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M43769|
  00008	e1a07001	 mov         r7, r1
  0000c	e1b04000	 movs        r4, r0

; 382  :     BOOL rc = FALSE;

  00010	e3a05000	 mov         r5, #0

; 383  :     PARENT_BUS_ACCESS *pBusAccess = (PARENT_BUS_ACCESS *)hBusAccess;
; 384  : 
; 385  :     // Check passed handler
; 386  :     if (pBusAccess == NULL || pBusAccess->cookie != BUS_ACCESS_COOKIE) {

  00014	0a000017	 beq         |$LN2@GetChildDe|
  00018	e5942000	 ldr         r2, [r4]
  0001c	e59f306c	 ldr         r3, [pc, #0x6C]
  00020	e1520003	 cmp         r2, r3
  00024	1a000013	 bne         |$LN2@GetChildDe|

; 388  :         goto clean;
; 389  :     }
; 390  : 
; 391  :     // Call parent device if exists
; 392  :     if (pBusAccess->hBus != INVALID_HANDLE_VALUE) {

  00028	e5946008	 ldr         r6, [r4, #8]
  0002c	e3760001	 cmn         r6, #1
  00030	0a000012	 beq         |$clean$43428|

; 393  :         rc = DeviceIoControl(
; 394  :             pBusAccess->hBus, IOCTL_BUS_GET_CONFIGURE_DATA, 
; 395  :             pBusAccess->pszDeviceName, 
; 396  :             (_tcslen(pBusAccess->pszDeviceName) + 1) * sizeof(TCHAR),
; 397  :             pChildDeviceState, sizeof(DWORD), NULL, 0
; 398  :         );

  00034	e594000c	 ldr         r0, [r4, #0xC]
  00038	eb000000	 bl          wcslen
  0003c	e594200c	 ldr         r2, [r4, #0xC]
  00040	e2803001	 add         r3, r0, #1
  00044	e3a0182a	 mov         r1, #0x2A, 16
  00048	e3a05004	 mov         r5, #4
  0004c	e3a0e000	 mov         lr, #0
  00050	e1a03083	 mov         r3, r3, lsl #1
  00054	e3811014	 orr         r1, r1, #0x14
  00058	e1a00006	 mov         r0, r6
  0005c	e58de00c	 str         lr, [sp, #0xC]
  00060	e58de008	 str         lr, [sp, #8]
  00064	e58d5004	 str         r5, [sp, #4]
  00068	e58d7000	 str         r7, [sp]
  0006c	eb000000	 bl          DeviceIoControl
  00070	e1a05000	 mov         r5, r0
  00074	ea000001	 b           |$clean$43428|
  00078		 |$LN2@GetChildDe|

; 387  :         SetLastError(ERROR_INVALID_HANDLE);

  00078	e3a00006	 mov         r0, #6
  0007c	eb000000	 bl          SetLastError
  00080		 |$clean$43428|

; 399  :     }
; 400  : 
; 401  : clean:
; 402  :     return rc;
; 403  : }

  00080	e1a00005	 mov         r0, r5
  00084	e28dd010	 add         sp, sp, #0x10
  00088	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0008c	e12fff1e	 bx          lr
  00090		 |$LN9@GetChildDe|
  00090		 |$LN10@GetChildDe|
  00090	41737562	 DCD         0x41737562
  00094		 |$M43770|

			 ENDP  ; |GetChildDeviceRemoveState|

	EXPORT	|GetBusNamePrefix|

  00000			 AREA	 |.pdata|, PDATA
|$T43787| DCD	|$LN8@GetBusName|
	DCD	0x40002602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetBusNamePrefix| PROC

; 408  : {

  00000		 |$LN8@GetBusName|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M43784|
  00008	e1a07002	 mov         r7, r2
  0000c	e1a08001	 mov         r8, r1
  00010	e1b04000	 movs        r4, r0

; 409  :     BOOL rc = FALSE;

  00014	e3a05000	 mov         r5, #0

; 410  :     PARENT_BUS_ACCESS *pBusAccess = (PARENT_BUS_ACCESS *)hBusAccess;
; 411  : 
; 412  :     // Check passed handler
; 413  :     if (pBusAccess == NULL || pBusAccess->cookie != BUS_ACCESS_COOKIE) {

  00018	0a000017	 beq         |$LN2@GetBusName|
  0001c	e594e000	 ldr         lr, [r4]
  00020	e59f306c	 ldr         r3, [pc, #0x6C]
  00024	e15e0003	 cmp         lr, r3
  00028	1a000013	 bne         |$LN2@GetBusName|

; 415  :         goto clean;
; 416  :     }
; 417  : 
; 418  :     // Call parent device if exists
; 419  :     if (pBusAccess->hBus != INVALID_HANDLE_VALUE) {

  0002c	e5946008	 ldr         r6, [r4, #8]
  00030	e3760001	 cmn         r6, #1
  00034	0a000012	 beq         |$clean$43447|

; 420  :         rc = DeviceIoControl(
; 421  :             pBusAccess->hBus, IOCTL_BUS_NAME_PREFIX, pBusAccess->pszDeviceName, 
; 422  :             (_tcslen(pBusAccess->pszDeviceName) + 1) * sizeof(TCHAR),
; 423  :             pOutString, outSize * sizeof(TCHAR), NULL, 0
; 424  :         );

  00038	e594000c	 ldr         r0, [r4, #0xC]
  0003c	eb000000	 bl          wcslen
  00040	e594200c	 ldr         r2, [r4, #0xC]
  00044	e2803001	 add         r3, r0, #1
  00048	e3a0182a	 mov         r1, #0x2A, 16
  0004c	e1a0e087	 mov         lr, r7, lsl #1
  00050	e3a05000	 mov         r5, #0
  00054	e1a03083	 mov         r3, r3, lsl #1
  00058	e3811084	 orr         r1, r1, #0x84
  0005c	e1a00006	 mov         r0, r6
  00060	e58d500c	 str         r5, [sp, #0xC]
  00064	e58d5008	 str         r5, [sp, #8]
  00068	e58de004	 str         lr, [sp, #4]
  0006c	e58d8000	 str         r8, [sp]
  00070	eb000000	 bl          DeviceIoControl
  00074	e1a05000	 mov         r5, r0
  00078	ea000001	 b           |$clean$43447|
  0007c		 |$LN2@GetBusName|

; 414  :         SetLastError(ERROR_INVALID_HANDLE);

  0007c	e3a00006	 mov         r0, #6
  00080	eb000000	 bl          SetLastError
  00084		 |$clean$43447|

; 425  :     }
; 426  : 
; 427  : clean:
; 428  :     return rc;
; 429  : }

  00084	e1a00005	 mov         r0, r5
  00088	e28dd010	 add         sp, sp, #0x10
  0008c	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$LN9@GetBusName|
  00094		 |$LN10@GetBusName|
  00094	41737562	 DCD         0x41737562
  00098		 |$M43785|

			 ENDP  ; |GetBusNamePrefix|

	EXPORT	|BusTransBusAddrToVirtual|
	IMPORT	|MmMapIoSpace|

  00000			 AREA	 |.pdata|, PDATA
|$T43807| DCD	|$LN11@BusTransBu|
	DCD	0x40002404
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BusTransBusAddrToVirtual| PROC

; 437  : ) {

  00000		 |$LN11@BusTransBu|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5070	 stmdb       sp!, {r4 - r6, r12, lr}
  0000c	e24dd014	 sub         sp, sp, #0x14
  00010		 |$M43804|

; 438  :     BOOL rc = FALSE;
; 439  :     PHYSICAL_ADDRESS translatedAddress;
; 440  : 
; 441  :     if (!TranslateBusAddr(
; 442  :         hBusAccess, interfaceType, busNumber, busAddress, pAddressSpace, 
; 443  :         &translatedAddress
; 444  :     )) goto clean;

  00010	e59d6040	 ldr         r6, [sp, #0x40]
  00014	e59de038	 ldr         lr, [sp, #0x38]
  00018	e28d400c	 add         r4, sp, #0xC
  0001c	e58d6004	 str         r6, [sp, #4]
  00020	e58de000	 str         lr, [sp]
  00024	e3a05000	 mov         r5, #0
  00028	e58d4008	 str         r4, [sp, #8]
  0002c	eb000000	 bl          TranslateBusAddr
  00030	e3500000	 cmp         r0, #0
  00034	0a000011	 beq         |$clean$43471|

; 445  : 
; 446  :     if (*pAddressSpace == 0) {

  00038	e5963000	 ldr         r3, [r6]
  0003c	e3530000	 cmp         r3, #0
  00040	1a00000a	 bne         |$LN2@BusTransBu|

; 447  :         // Memory-mapped I/O, get virtual address
; 448  :         *ppMappedAddress = MmMapIoSpace(translatedAddress, length, FALSE);

  00044	e59d203c	 ldr         r2, [sp, #0x3C]
  00048	e59d000c	 ldr         r0, [sp, #0xC]
  0004c	e59d1010	 ldr         r1, [sp, #0x10]
  00050	e3a03000	 mov         r3, #0
  00054	eb000000	 bl          MmMapIoSpace
  00058	e59d3044	 ldr         r3, [sp, #0x44]
  0005c	e3500000	 cmp         r0, #0
  00060	e5830000	 str         r0, [r3]

; 449  :         rc = (*ppMappedAddress != NULL);

  00064	1a000004	 bne         |$LN8@BusTransBu|
  00068	e3a05000	 mov         r5, #0

; 450  :     } else {

  0006c	ea000003	 b           |$clean$43471|
  00070		 |$LN2@BusTransBu|

; 451  :         // I/O port
; 452  :         *ppMappedAddress = (VOID*)translatedAddress.LowPart;

  00070	e59d2044	 ldr         r2, [sp, #0x44]
  00074	e59d300c	 ldr         r3, [sp, #0xC]

; 453  :         rc = TRUE;

  00078	e5823000	 str         r3, [r2]
  0007c		 |$LN8@BusTransBu|
  0007c	e3a05001	 mov         r5, #1
  00080		 |$clean$43471|

; 454  :     }
; 455  : 
; 456  : clean:
; 457  :     return rc;
; 458  : }

  00080	e1a00005	 mov         r0, r5
  00084	e28dd014	 add         sp, sp, #0x14
  00088	e89d6070	 ldmia       sp, {r4 - r6, sp, lr}
  0008c	e12fff1e	 bx          lr
  00090		 |$M43805|

			 ENDP  ; |BusTransBusAddrToVirtual|

	EXPORT	|BusTransBusAddrToStatic|
	IMPORT	|CreateStaticMapping|

  00000			 AREA	 |.pdata|, PDATA
|$T43827| DCD	|$LN10@BusTransBu@2|
	DCD	0x40002e04
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BusTransBusAddrToStatic| PROC

; 466  : ) {

  00000		 |$LN10@BusTransBu@2|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5070	 stmdb       sp!, {r4 - r6, r12, lr}
  0000c	e24dd014	 sub         sp, sp, #0x14
  00010		 |$M43824|

; 467  :     BOOL rc = FALSE;
; 468  :     PHYSICAL_ADDRESS translatedAddress;
; 469  :     UCHAR *pStaticAddress;
; 470  :     DWORD alignedAddress, alignedSize;
; 471  : 
; 472  :     if (!TranslateBusAddr(
; 473  :         hBusAccess, interfaceType, busNumber, busAddress, pAddressSpace, 
; 474  :         &translatedAddress
; 475  :     )) goto clean;

  00010	e59d6040	 ldr         r6, [sp, #0x40]
  00014	e59de038	 ldr         lr, [sp, #0x38]
  00018	e28d400c	 add         r4, sp, #0xC
  0001c	e58d6004	 str         r6, [sp, #4]
  00020	e58de000	 str         lr, [sp]
  00024	e3a05000	 mov         r5, #0
  00028	e58d4008	 str         r4, [sp, #8]
  0002c	eb000000	 bl          TranslateBusAddr
  00030	e3500000	 cmp         r0, #0
  00034	0a00001b	 beq         |$clean$43497|

; 476  : 
; 477  :     if (*pAddressSpace == 0) {

  00038	e5963000	 ldr         r3, [r6]
  0003c	e3530000	 cmp         r3, #0
  00040	1a000014	 bne         |$LN3@BusTransBu@2|

; 478  :         alignedAddress = translatedAddress.LowPart & ~(PAGE_SIZE - 1);

  00044	e3e03b0d	 mvn         r3, #0xD, 22
  00048	e22340fb	 eor         r4, r3, #0xFB
  0004c	e5943000	 ldr         r3, [r4]

; 479  :         alignedSize = length + (translatedAddress.LowPart & (PAGE_SIZE - 1));

  00050	e59d100c	 ldr         r1, [sp, #0xC]
  00054	e59de03c	 ldr         lr, [sp, #0x3C]
  00058	e2432001	 sub         r2, r3, #1
  0005c	e1c13002	 bic         r3, r1, r2
  00060	e0022001	 and         r2, r2, r1

; 480  :         pStaticAddress = CreateStaticMapping(alignedAddress >> 8, alignedSize);

  00064	e082100e	 add         r1, r2, lr
  00068	e1a00423	 mov         r0, r3, lsr #8
  0006c	eb000000	 bl          CreateStaticMapping
  00070	e3500000	 cmp         r0, #0

; 481  :         if (pStaticAddress == NULL) goto clean;

  00074	0a00000b	 beq         |$clean$43497|

; 482  :         pStaticAddress += translatedAddress.LowPart & (PAGE_SIZE - 1);

  00078	e5943000	 ldr         r3, [r4]
  0007c	e59d200c	 ldr         r2, [sp, #0xC]

; 483  :         *ppMappedAddress = pStaticAddress;

  00080	e59d1044	 ldr         r1, [sp, #0x44]
  00084	e2433001	 sub         r3, r3, #1
  00088	e0033002	 and         r3, r3, r2
  0008c	e0833000	 add         r3, r3, r0
  00090	e5813000	 str         r3, [r1]

; 484  :         rc = TRUE;
; 485  :     } else {

  00094	ea000002	 b           |$LN7@BusTransBu@2|
  00098		 |$LN3@BusTransBu@2|

; 486  :         // I/O port
; 487  :         *ppMappedAddress = (VOID*)translatedAddress.LowPart;

  00098	e59d2044	 ldr         r2, [sp, #0x44]
  0009c	e59d300c	 ldr         r3, [sp, #0xC]

; 488  :         rc = TRUE;

  000a0	e5823000	 str         r3, [r2]
  000a4		 |$LN7@BusTransBu@2|
  000a4	e3a05001	 mov         r5, #1
  000a8		 |$clean$43497|

; 489  :     }
; 490  : 
; 491  : clean:
; 492  :     return rc;
; 493  : }

  000a8	e1a00005	 mov         r0, r5
  000ac	e28dd014	 add         sp, sp, #0x14
  000b0	e89d6070	 ldmia       sp, {r4 - r6, sp, lr}
  000b4	e12fff1e	 bx          lr
  000b8		 |$M43825|

			 ENDP  ; |BusTransBusAddrToStatic|

	EXPORT	|BusIoControl|

  00000			 AREA	 |.pdata|, PDATA
|$T43841| DCD	|$LN9@BusIoContr|
	DCD	0x40002e02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BusIoControl| PROC

; 500  : ) {

  00000		 |$LN9@BusIoContr|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M43838|
  00008	e1a06003	 mov         r6, r3
  0000c	e1a05002	 mov         r5, r2
  00010	e1a08001	 mov         r8, r1
  00014	e3500000	 cmp         r0, #0

; 501  :     BOOL rc = FALSE;

  00018	e3a07000	 mov         r7, #0

; 502  :     PARENT_BUS_ACCESS *pBusAccess = (PARENT_BUS_ACCESS *)hBusAccess;
; 503  : 
; 504  :     // Check passed handler
; 505  :     if (pBusAccess == NULL || pBusAccess->cookie != BUS_ACCESS_COOKIE) {

  0001c	0a00001e	 beq         |$LN3@BusIoContr|
  00020	e5904000	 ldr         r4, [r0]
  00024	e59fe088	 ldr         lr, [pc, #0x88]
  00028	e154000e	 cmp         r4, lr
  0002c	1a00001a	 bne         |$LN3@BusIoContr|

; 507  :         goto clean;
; 508  :     }
; 509  : 
; 510  :     // Call parent device if exists
; 511  :     if (pBusAccess->hBus != INVALID_HANDLE_VALUE) {

  00030	e5904008	 ldr         r4, [r0, #8]
  00034	e3740001	 cmn         r4, #1
  00038	0a000019	 beq         |$clean$43532|

; 512  : 
; 513  :         // If there isn't any input buffer, pass device name instead
; 514  :         if (pInBuffer == NULL && inSize == 0) {

  0003c	e3550000	 cmp         r5, #0
  00040	1a000006	 bne         |$LN1@BusIoContr|
  00044	e3560000	 cmp         r6, #0
  00048	1a000004	 bne         |$LN1@BusIoContr|

; 515  :             pInBuffer = pBusAccess->pszDeviceName;

  0004c	e590500c	 ldr         r5, [r0, #0xC]

; 516  :             inSize = (_tcslen(pBusAccess->pszDeviceName) + 1)*sizeof(TCHAR);

  00050	e1a00005	 mov         r0, r5
  00054	eb000000	 bl          wcslen
  00058	e2803001	 add         r3, r0, #1
  0005c	e1a06083	 mov         r6, r3, lsl #1
  00060		 |$LN1@BusIoContr|

; 517  :         }        
; 518  : 
; 519  :         // Call bus driver
; 520  :         rc = DeviceIoControl(
; 521  :             pBusAccess->hBus, code, pInBuffer, inSize, pOutBuffer, outSize, 
; 522  :             pOutSize, pOverlapped
; 523  :         );        

  00060	e59d3034	 ldr         r3, [sp, #0x34]
  00064	e59d2030	 ldr         r2, [sp, #0x30]
  00068	e59d102c	 ldr         r1, [sp, #0x2C]
  0006c	e59de028	 ldr         lr, [sp, #0x28]
  00070	e58d300c	 str         r3, [sp, #0xC]
  00074	e58d2008	 str         r2, [sp, #8]
  00078	e58d1004	 str         r1, [sp, #4]
  0007c	e1a03006	 mov         r3, r6
  00080	e1a02005	 mov         r2, r5
  00084	e1a01008	 mov         r1, r8
  00088	e1a00004	 mov         r0, r4
  0008c	e58de000	 str         lr, [sp]
  00090	eb000000	 bl          DeviceIoControl
  00094	e1a07000	 mov         r7, r0
  00098	ea000001	 b           |$clean$43532|
  0009c		 |$LN3@BusIoContr|

; 506  :         SetLastError(ERROR_INVALID_HANDLE);

  0009c	e3a00006	 mov         r0, #6
  000a0	eb000000	 bl          SetLastError
  000a4		 |$clean$43532|

; 524  :     }
; 525  : 
; 526  : clean:
; 527  :     return rc;
; 528  : }

  000a4	e1a00007	 mov         r0, r7
  000a8	e28dd010	 add         sp, sp, #0x10
  000ac	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000b0	e12fff1e	 bx          lr
  000b4		 |$LN10@BusIoContr|
  000b4		 |$LN11@BusIoContr|
  000b4	41737562	 DCD         0x41737562
  000b8		 |$M43839|

			 ENDP  ; |BusIoControl|

	EXPORT	|BusChildIoControl|

  00000			 AREA	 |.pdata|, PDATA
|$T43858| DCD	|$LN8@BusChildIo|
	DCD	0x40002502
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BusChildIoControl| PROC

; 534  : ) {

  00000		 |$LN8@BusChildIo|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M43855|
  00008	e1a07003	 mov         r7, r3
  0000c	e1a08002	 mov         r8, r2
  00010	e1a09001	 mov         r9, r1
  00014	e1b05000	 movs        r5, r0

; 535  :     BOOL rc = FALSE;

  00018	e3a06000	 mov         r6, #0

; 536  :     LPVOID pInBuffer;
; 537  :     DWORD inSize;
; 538  :     PARENT_BUS_ACCESS *pBusAccess = (PARENT_BUS_ACCESS *)hBusAccess;
; 539  : 
; 540  :     // Check passed handler
; 541  :     if (pBusAccess == NULL || pBusAccess->cookie != BUS_ACCESS_COOKIE) {

  0001c	0a000015	 beq         |$LN2@BusChildIo|
  00020	e5954000	 ldr         r4, [r5]
  00024	e59fe064	 ldr         lr, [pc, #0x64]
  00028	e154000e	 cmp         r4, lr
  0002c	1a000011	 bne         |$LN2@BusChildIo|

; 543  :         goto clean;
; 544  :     }
; 545  : 
; 546  :     // Call parent device if exists
; 547  :     if (pBusAccess->hBus != INVALID_HANDLE_VALUE) {

  00030	e5954008	 ldr         r4, [r5, #8]
  00034	e3740001	 cmn         r4, #1
  00038	0a000010	 beq         |$clean$43555|

; 548  : 
; 549  :         pInBuffer = pBusAccess->pszDeviceName;
; 550  :         inSize = (_tcslen(pBusAccess->pszDeviceName) + 1)*sizeof(TCHAR);

  0003c	e595000c	 ldr         r0, [r5, #0xC]
  00040	eb000000	 bl          wcslen

; 551  : 
; 552  :         // Call bus driver
; 553  :         rc = DeviceIoControl(
; 554  :             pBusAccess->hBus, code, pInBuffer, inSize, pBuffer, size, NULL, NULL
; 555  :         );        

  00044	e280e001	 add         lr, r0, #1
  00048	e595200c	 ldr         r2, [r5, #0xC]
  0004c	e1a0308e	 mov         r3, lr, lsl #1
  00050	e3a0e000	 mov         lr, #0
  00054	e1a01009	 mov         r1, r9
  00058	e1a00004	 mov         r0, r4
  0005c	e58de00c	 str         lr, [sp, #0xC]
  00060	e58de008	 str         lr, [sp, #8]
  00064	e58d7004	 str         r7, [sp, #4]
  00068	e58d8000	 str         r8, [sp]
  0006c	eb000000	 bl          DeviceIoControl
  00070	e1a06000	 mov         r6, r0
  00074	ea000001	 b           |$clean$43555|
  00078		 |$LN2@BusChildIo|

; 542  :         SetLastError(ERROR_INVALID_HANDLE);

  00078	e3a00006	 mov         r0, #6
  0007c	eb000000	 bl          SetLastError
  00080		 |$clean$43555|

; 556  :     }
; 557  : 
; 558  : clean:
; 559  :     return rc;
; 560  : }

  00080	e1a00006	 mov         r0, r6
  00084	e28dd010	 add         sp, sp, #0x10
  00088	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  0008c	e12fff1e	 bx          lr
  00090		 |$LN9@BusChildIo|
  00090		 |$LN10@BusChildIo|
  00090	41737562	 DCD         0x41737562
  00094		 |$M43856|

			 ENDP  ; |BusChildIoControl|

	END
