; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\CEDDK\SPI\mcspi.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|DEVICE_IFC_SPI_GUID| [ DATA ]

  00000			 AREA	 |.rdata|, DATA, READONLY
|DEVICE_IFC_SPI_GUID| DCD 0x2e559225
	DCW	0xc95e
	DCW	0x4300
	DCB	0x86
	DCB	0xe9
	DCB	0x6a
	DCB	0x5c
	DCB	0xbc
	DCB	0x7
	DCB	0x32
	DCB	0x8f
	EXPORT	|SPIOpen|
	IMPORT	|DeviceIoControl|
	IMPORT	|CloseHandle|
	IMPORT	|LocalAlloc|
	IMPORT	|CreateFileW|
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\ceddk\spi\mcspi.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T35982| DCD	|$LN10@SPIOpen|
	DCD	0x40002902
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPIOpen| PROC

; 25   : {

  00000		 |$LN10@SPIOpen|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M35979|

; 26   :     HANDLE hDevice;
; 27   :     DEVICE_CONTEXT_SPI *pContext = NULL;
; 28   :    
; 29   :     hDevice = CreateFile(pSpiName, GENERIC_READ | GENERIC_WRITE,    
; 30   :                          FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);    

  00008	e3a03003	 mov         r3, #3
  0000c	e58d3000	 str         r3, [sp]
  00010	e3a06000	 mov         r6, #0
  00014	e3a03000	 mov         r3, #0
  00018	e3a02003	 mov         r2, #3
  0001c	e3a01103	 mov         r1, #3, 2
  00020	e3a04000	 mov         r4, #0
  00024	e58d6008	 str         r6, [sp, #8]
  00028	e58d6004	 str         r6, [sp, #4]
  0002c	eb000000	 bl          CreateFileW
  00030	e1a05000	 mov         r5, r0

; 31   :     if (hDevice == INVALID_HANDLE_VALUE) goto clean;

  00034	e3750001	 cmn         r5, #1
  00038	0a000014	 beq         |$clean$35811|

; 32   : 
; 33   :     // Allocate memory for our handler...
; 34   :     if ((pContext = (DEVICE_CONTEXT_SPI *)LocalAlloc(
; 35   :         LPTR, sizeof(DEVICE_CONTEXT_SPI)
; 36   :     )) == NULL) {

  0003c	e3a01034	 mov         r1, #0x34
  00040	e3a00040	 mov         r0, #0x40
  00044	eb000000	 bl          LocalAlloc
  00048	e1b04000	 movs        r4, r0

; 37   :         CloseHandle(hDevice);

  0004c	e1a00005	 mov         r0, r5
  00050	1a000001	 bne         |$LN3@SPIOpen|
  00054	eb000000	 bl          CloseHandle

; 53   : 
; 54   : clean:

  00058	ea00000c	 b           |$clean$35811|
  0005c		 |$LN3@SPIOpen|

; 38   :         goto clean;
; 39   :     }
; 40   : 
; 41   :     // Get function pointers.  If not possible (b/c of cross process calls), use IOCTLs instead
; 42   :     if (!DeviceIoControl(
; 43   :         hDevice, IOCTL_DDK_GET_DRIVER_IFC, (VOID*)&DEVICE_IFC_SPI_GUID,
; 44   :         sizeof(DEVICE_IFC_SPI_GUID), &pContext->ifc, sizeof(DEVICE_IFC_SPI),
; 45   :         NULL, NULL
; 46   :     )) {

  0005c	e59f203c	 ldr         r2, [pc, #0x3C]
  00060	e3a03822	 mov         r3, #0x22, 16
  00064	e3831b01	 orr         r1, r3, #1, 22
  00068	e3a0e030	 mov         lr, #0x30
  0006c	e3a03010	 mov         r3, #0x10
  00070	e58d600c	 str         r6, [sp, #0xC]
  00074	e58d6008	 str         r6, [sp, #8]
  00078	e58de004	 str         lr, [sp, #4]
  0007c	e58d4000	 str         r4, [sp]
  00080	eb000000	 bl          DeviceIoControl
  00084	e3500000	 cmp         r0, #0

; 47   :         //  Need to use IOCTLs instead of direct function ptrs
; 48   :         pContext->ifc.context = 0;

  00088	05846000	 streq       r6, [r4]

; 49   :     }
; 50   : 
; 51   :     // Save device handle
; 52   :     pContext->hDevice = hDevice;

  0008c	e5845030	 str         r5, [r4, #0x30]
  00090		 |$clean$35811|

; 55   :     return pContext;
; 56   : }

  00090	e1a00004	 mov         r0, r4
  00094	e28dd010	 add         sp, sp, #0x10
  00098	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$LN11@SPIOpen|
  000a0		 |$LN12@SPIOpen|
  000a0	00000000	 DCD         |DEVICE_IFC_SPI_GUID|
  000a4		 |$M35980|

			 ENDP  ; |SPIOpen|

	EXPORT	|SPIClose|
	IMPORT	|LocalFree|

  00000			 AREA	 |.pdata|, PDATA
|$T35992| DCD	|$LN5@SPIClose|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPIClose| PROC

; 59   : {

  00000		 |$LN5@SPIClose|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M35989|
  00004	e1a04000	 mov         r4, r0

; 60   :     DEVICE_CONTEXT_SPI *pContext = (DEVICE_CONTEXT_SPI *)hContext;
; 61   :     CloseHandle(pContext->hDevice);

  00008	e5940030	 ldr         r0, [r4, #0x30]
  0000c	eb000000	 bl          CloseHandle

; 62   :     LocalFree(pContext);

  00010	e1a00004	 mov         r0, r4
  00014	eb000000	 bl          LocalFree

; 63   : }

  00018	e8bd4010	 ldmia       sp!, {r4, lr}
  0001c	e12fff1e	 bx          lr
  00020		 |$M35990|

			 ENDP  ; |SPIClose|

	EXPORT	|SPILockController|

  00000			 AREA	 |.pdata|, PDATA
|$T36003| DCD	|$LN7@SPILockCon|
	DCD	0x40001b04
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPILockController| PROC

; 66   : {

  00000		 |$LN7@SPILockCon|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd010	 sub         sp, sp, #0x10
  00010		 |$M36000|
  00010	e58d101c	 str         r1, [sp, #0x1C]

; 67   :     DEVICE_CONTEXT_SPI *pContext = (DEVICE_CONTEXT_SPI *)hContext;
; 68   :     if( pContext->ifc.context )

  00014	e5903000	 ldr         r3, [r0]
  00018	e1b02003	 movs        r2, r3
  0001c	0a000004	 beq         |$LN2@SPILockCon|

; 69   :     {
; 70   :         return pContext->ifc.pfnLockController(pContext->ifc.context, dwTimeout);

  00020	e5903014	 ldr         r3, [r0, #0x14]
  00024	e1a00002	 mov         r0, r2
  00028	e1a0e00f	 mov         lr, pc
  0002c	e12fff13	 bx          r3
  00030	ea000009	 b           |$LN1@SPILockCon|
  00034		 |$LN2@SPILockCon|

; 71   :     }
; 72   :     else
; 73   :     {
; 74   :         return DeviceIoControl(pContext->hDevice,
; 75   :                         IOCTL_SPI_LOCK_CTRL,
; 76   :                         &dwTimeout,
; 77   :                         sizeof(dwTimeout),
; 78   :                         NULL,
; 79   :                         0,
; 80   :                         NULL,
; 81   :                         NULL );

  00034	e59f102c	 ldr         r1, [pc, #0x2C]
  00038	e5900030	 ldr         r0, [r0, #0x30]
  0003c	e3a0e000	 mov         lr, #0
  00040	e3a03004	 mov         r3, #4
  00044	e28d201c	 add         r2, sp, #0x1C
  00048	e58de00c	 str         lr, [sp, #0xC]
  0004c	e58de008	 str         lr, [sp, #8]
  00050	e58de004	 str         lr, [sp, #4]
  00054	e58de000	 str         lr, [sp]
  00058	eb000000	 bl          DeviceIoControl
  0005c		 |$LN1@SPILockCon|

; 82   :     }
; 83   : }

  0005c	e28dd010	 add         sp, sp, #0x10
  00060	e89d6000	 ldmia       sp, {sp, lr}
  00064	e12fff1e	 bx          lr
  00068		 |$LN8@SPILockCon|
  00068		 |$LN9@SPILockCon|
  00068	00220814	 DCD         0x220814
  0006c		 |$M36001|

			 ENDP  ; |SPILockController|

	EXPORT	|SPIUnlockController|

  00000			 AREA	 |.pdata|, PDATA
|$T36015| DCD	|$LN7@SPIUnlockC|
	DCD	0x40001802
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPIUnlockController| PROC

; 86   : {

  00000		 |$LN7@SPIUnlockC|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M36012|

; 87   :     DEVICE_CONTEXT_SPI *pContext = (DEVICE_CONTEXT_SPI *)hContext;
; 88   :     if( pContext->ifc.context )

  00008	e5903000	 ldr         r3, [r0]
  0000c	e1b02003	 movs        r2, r3
  00010	0a000004	 beq         |$LN2@SPIUnlockC|

; 89   :     {
; 90   :         return pContext->ifc.pfnUnlockController(pContext->ifc.context);

  00014	e5903018	 ldr         r3, [r0, #0x18]
  00018	e1a00002	 mov         r0, r2
  0001c	e1a0e00f	 mov         lr, pc
  00020	e12fff13	 bx          r3
  00024	ea000009	 b           |$LN1@SPIUnlockC|
  00028		 |$LN2@SPIUnlockC|

; 91   :     }
; 92   :     else
; 93   :     {
; 94   :         return DeviceIoControl(pContext->hDevice,
; 95   :                         IOCTL_SPI_UNLOCK_CTRL,
; 96   :                         NULL,
; 97   :                         0,
; 98   :                         NULL,
; 99   :                         0,
; 100  :                         NULL,
; 101  :                         NULL );

  00028	e59f102c	 ldr         r1, [pc, #0x2C]
  0002c	e5900030	 ldr         r0, [r0, #0x30]
  00030	e3a0e000	 mov         lr, #0
  00034	e3a03000	 mov         r3, #0
  00038	e3a02000	 mov         r2, #0
  0003c	e58de00c	 str         lr, [sp, #0xC]
  00040	e58de008	 str         lr, [sp, #8]
  00044	e58de004	 str         lr, [sp, #4]
  00048	e58de000	 str         lr, [sp]
  0004c	eb000000	 bl          DeviceIoControl
  00050		 |$LN1@SPIUnlockC|

; 102  :     }
; 103  : }

  00050	e28dd010	 add         sp, sp, #0x10
  00054	e49de004	 ldr         lr, [sp], #4
  00058	e12fff1e	 bx          lr
  0005c		 |$LN8@SPIUnlockC|
  0005c		 |$LN9@SPIUnlockC|
  0005c	00220818	 DCD         0x220818
  00060		 |$M36013|

			 ENDP  ; |SPIUnlockController|

	EXPORT	|SPIEnableChannel|

  00000			 AREA	 |.pdata|, PDATA
|$T36027| DCD	|$LN7@SPIEnableC|
	DCD	0x40001802
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPIEnableChannel| PROC

; 106  : {

  00000		 |$LN7@SPIEnableC|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M36024|

; 107  :     DEVICE_CONTEXT_SPI *pContext = (DEVICE_CONTEXT_SPI *)hContext;
; 108  :     if( pContext->ifc.context )

  00008	e5903000	 ldr         r3, [r0]
  0000c	e1b02003	 movs        r2, r3
  00010	0a000004	 beq         |$LN2@SPIEnableC|

; 109  :     {
; 110  :         return pContext->ifc.pfnEnableChannel(pContext->ifc.context);

  00014	e590301c	 ldr         r3, [r0, #0x1C]
  00018	e1a00002	 mov         r0, r2
  0001c	e1a0e00f	 mov         lr, pc
  00020	e12fff13	 bx          r3
  00024	ea000009	 b           |$LN1@SPIEnableC|
  00028		 |$LN2@SPIEnableC|

; 111  :     }
; 112  :     else
; 113  :     {
; 114  :         return DeviceIoControl(pContext->hDevice,
; 115  :                         IOCTL_SPI_ENABLE_CHANNEL,
; 116  :                         NULL,
; 117  :                         0,
; 118  :                         NULL,
; 119  :                         0,
; 120  :                         NULL,
; 121  :                         NULL );

  00028	e59f102c	 ldr         r1, [pc, #0x2C]
  0002c	e5900030	 ldr         r0, [r0, #0x30]
  00030	e3a0e000	 mov         lr, #0
  00034	e3a03000	 mov         r3, #0
  00038	e3a02000	 mov         r2, #0
  0003c	e58de00c	 str         lr, [sp, #0xC]
  00040	e58de008	 str         lr, [sp, #8]
  00044	e58de004	 str         lr, [sp, #4]
  00048	e58de000	 str         lr, [sp]
  0004c	eb000000	 bl          DeviceIoControl
  00050		 |$LN1@SPIEnableC|

; 122  :     }
; 123  : }

  00050	e28dd010	 add         sp, sp, #0x10
  00054	e49de004	 ldr         lr, [sp], #4
  00058	e12fff1e	 bx          lr
  0005c		 |$LN8@SPIEnableC|
  0005c		 |$LN9@SPIEnableC|
  0005c	0022081c	 DCD         0x22081c
  00060		 |$M36025|

			 ENDP  ; |SPIEnableChannel|

	EXPORT	|SPIDisableChannel|

  00000			 AREA	 |.pdata|, PDATA
|$T36039| DCD	|$LN7@SPIDisable|
	DCD	0x40001802
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPIDisableChannel| PROC

; 126  : {

  00000		 |$LN7@SPIDisable|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M36036|

; 127  :     DEVICE_CONTEXT_SPI *pContext = (DEVICE_CONTEXT_SPI *)hContext;
; 128  :     if( pContext->ifc.context )

  00008	e5903000	 ldr         r3, [r0]
  0000c	e1b02003	 movs        r2, r3
  00010	0a000004	 beq         |$LN2@SPIDisable|

; 129  :     {
; 130  :         return pContext->ifc.pfnDisableChannel(pContext->ifc.context);

  00014	e5903020	 ldr         r3, [r0, #0x20]
  00018	e1a00002	 mov         r0, r2
  0001c	e1a0e00f	 mov         lr, pc
  00020	e12fff13	 bx          r3
  00024	ea00000a	 b           |$LN1@SPIDisable|
  00028		 |$LN2@SPIDisable|

; 131  :     }
; 132  :     else
; 133  :     {
; 134  :         return DeviceIoControl(pContext->hDevice,
; 135  :                         IOCTL_SPI_DISABLE_CHANNEL,
; 136  :                         NULL,
; 137  :                         0,
; 138  :                         NULL,
; 139  :                         0,
; 140  :                         NULL,
; 141  :                         NULL );

  00028	e5900030	 ldr         r0, [r0, #0x30]
  0002c	e3a03822	 mov         r3, #0x22, 16
  00030	e3831e82	 orr         r1, r3, #0x82, 28
  00034	e3a0e000	 mov         lr, #0
  00038	e3a03000	 mov         r3, #0
  0003c	e3a02000	 mov         r2, #0
  00040	e58de00c	 str         lr, [sp, #0xC]
  00044	e58de008	 str         lr, [sp, #8]
  00048	e58de004	 str         lr, [sp, #4]
  0004c	e58de000	 str         lr, [sp]
  00050	eb000000	 bl          DeviceIoControl
  00054		 |$LN1@SPIDisable|

; 142  :     }
; 143  : }

  00054	e28dd010	 add         sp, sp, #0x10
  00058	e49de004	 ldr         lr, [sp], #4
  0005c	e12fff1e	 bx          lr
  00060		 |$M36037|

			 ENDP  ; |SPIDisableChannel|

	EXPORT	|SPIConfigure|

  00000			 AREA	 |.pdata|, PDATA
|$T36051| DCD	|$LN7@SPIConfigu|
	DCD	0x40001c02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPIConfigure| PROC

; 147  : {

  00000		 |$LN7@SPIConfigu|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M36048|
  00008	e1a0e002	 mov         lr, r2
  0000c	e1a04001	 mov         r4, r1

; 148  :     DEVICE_CONTEXT_SPI *pContext = (DEVICE_CONTEXT_SPI *)hContext;
; 149  :     if( pContext->ifc.context )

  00010	e5903000	 ldr         r3, [r0]
  00014	e1b05003	 movs        r5, r3
  00018	0a000004	 beq         |$LN2@SPIConfigu|

; 150  :     {
; 151  : 	    return pContext->ifc.pfnConfigure(pContext->ifc.context, address, config);

  0001c	e5903004	 ldr         r3, [r0, #4]
  00020	e1a00005	 mov         r0, r5
  00024	e1a0e00f	 mov         lr, pc
  00028	e12fff13	 bx          r3
  0002c	ea00000c	 b           |$LN1@SPIConfigu|
  00030		 |$LN2@SPIConfigu|

; 152  : 	}
; 153  :     else
; 154  :     {
; 155  :         IOCTL_SPI_CONFIGURE_IN  dwIn;
; 156  : 
; 157  :         dwIn.address = address;
; 158  :         dwIn.config = config;
; 159  : 
; 160  :         return DeviceIoControl(pContext->hDevice,
; 161  :                         IOCTL_SPI_CONFIGURE,
; 162  :                         &dwIn,
; 163  :                         sizeof(dwIn),
; 164  :                         NULL,
; 165  :                         0,
; 166  :                         NULL,
; 167  :                         NULL );

  00030	e5900030	 ldr         r0, [r0, #0x30]
  00034	e3a03822	 mov         r3, #0x22, 16
  00038	e3831b02	 orr         r1, r3, #2, 22
  0003c	e3a05000	 mov         r5, #0
  00040	e3a03008	 mov         r3, #8
  00044	e28d2010	 add         r2, sp, #0x10
  00048	e58d4010	 str         r4, [sp, #0x10]
  0004c	e58de014	 str         lr, [sp, #0x14]
  00050	e58d500c	 str         r5, [sp, #0xC]
  00054	e58d5008	 str         r5, [sp, #8]
  00058	e58d5004	 str         r5, [sp, #4]
  0005c	e58d5000	 str         r5, [sp]
  00060	eb000000	 bl          DeviceIoControl
  00064		 |$LN1@SPIConfigu|

; 168  :     }
; 169  : }

  00064	e28dd018	 add         sp, sp, #0x18
  00068	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0006c	e12fff1e	 bx          lr
  00070		 |$M36049|

			 ENDP  ; |SPIConfigure|

	EXPORT	|SPISetSlaveMode|

  00000			 AREA	 |.pdata|, PDATA
|$T36061| DCD	|$LN7@SPISetSlav|
	DCD	0x40001802
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPISetSlaveMode| PROC

; 172  : {

  00000		 |$LN7@SPISetSlav|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M36058|

; 173  :     DEVICE_CONTEXT_SPI *pContext = (DEVICE_CONTEXT_SPI *)hContext;
; 174  :     if( pContext->ifc.context )

  00008	e5903000	 ldr         r3, [r0]
  0000c	e1b02003	 movs        r2, r3
  00010	0a000004	 beq         |$LN2@SPISetSlav|

; 175  :     {
; 176  :         return pContext->ifc.pfnSetSlaveMode(pContext->ifc.context);

  00014	e590302c	 ldr         r3, [r0, #0x2C]
  00018	e1a00002	 mov         r0, r2
  0001c	e1a0e00f	 mov         lr, pc
  00020	e12fff13	 bx          r3
  00024	ea00000a	 b           |$LN1@SPISetSlav|
  00028		 |$LN2@SPISetSlav|

; 177  :     }
; 178  :     else
; 179  :     {
; 180  :         return DeviceIoControl(pContext->hDevice,
; 181  :                         IOCTL_SPI_SET_SLAVEMODE,
; 182  :                         NULL,
; 183  :                         0,
; 184  :                         NULL,
; 185  :                         0,
; 186  :                         NULL,
; 187  :                         NULL );

  00028	e5900030	 ldr         r0, [r0, #0x30]
  0002c	e3a03822	 mov         r3, #0x22, 16
  00030	e3831e81	 orr         r1, r3, #0x81, 28
  00034	e3a0e000	 mov         lr, #0
  00038	e3a03000	 mov         r3, #0
  0003c	e3a02000	 mov         r2, #0
  00040	e58de00c	 str         lr, [sp, #0xC]
  00044	e58de008	 str         lr, [sp, #8]
  00048	e58de004	 str         lr, [sp, #4]
  0004c	e58de000	 str         lr, [sp]
  00050	eb000000	 bl          DeviceIoControl
  00054		 |$LN1@SPISetSlav|

; 188  :     }
; 189  : }

  00054	e28dd010	 add         sp, sp, #0x10
  00058	e49de004	 ldr         lr, [sp], #4
  0005c	e12fff1e	 bx          lr
  00060		 |$M36059|

			 ENDP  ; |SPISetSlaveMode|

	EXPORT	|SPIRead|
	IMPORT	|ReadFile|

  00000			 AREA	 |.pdata|, PDATA
|$T36073| DCD	|$LN7@SPIRead|
	DCD	0x40001802
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPIRead| PROC

; 192  : {

  00000		 |$LN7@SPIRead|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M36070|
  00008	e1a0e002	 mov         lr, r2

; 193  :     DEVICE_CONTEXT_SPI *pContext = (DEVICE_CONTEXT_SPI *)hContext;
; 194  :     if( pContext->ifc.context )

  0000c	e5903000	 ldr         r3, [r0]

; 195  :     {
; 196  :     	return pContext->ifc.pfnRead(pContext->ifc.context, pBuffer, size);

  00010	e1a02001	 mov         r2, r1
  00014	e1a0100e	 mov         r1, lr
  00018	e1b04003	 movs        r4, r3
  0001c	0a000004	 beq         |$LN2@SPIRead|
  00020	e5903008	 ldr         r3, [r0, #8]
  00024	e1a00004	 mov         r0, r4
  00028	e1a0e00f	 mov         lr, pc
  0002c	e12fff13	 bx          r3
  00030	ea000007	 b           |$LN1@SPIRead|
  00034		 |$LN2@SPIRead|

; 197  : 	}
; 198  :     else
; 199  :     {
; 200  :         DWORD   dwCount = 0;
; 201  : 		BOOL ret; 
; 202  : 		ret = ReadFile( pContext->hDevice, pBuffer, size, &dwCount, NULL );

  00034	e5900030	 ldr         r0, [r0, #0x30]
  00038	e3a04000	 mov         r4, #0
  0003c	e3a05000	 mov         r5, #0
  00040	e28d3004	 add         r3, sp, #4
  00044	e58d4004	 str         r4, [sp, #4]
  00048	e58d5000	 str         r5, [sp]
  0004c	eb000000	 bl          ReadFile

; 203  :         return dwCount;

  00050	e59d0004	 ldr         r0, [sp, #4]
  00054		 |$LN1@SPIRead|

; 204  :     }
; 205  : }

  00054	e28dd008	 add         sp, sp, #8
  00058	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$M36071|

			 ENDP  ; |SPIRead|

	EXPORT	|SPIWrite|
	IMPORT	|WriteFile|

  00000			 AREA	 |.pdata|, PDATA
|$T36085| DCD	|$LN7@SPIWrite|
	DCD	0x40001802
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPIWrite| PROC

; 208  : {

  00000		 |$LN7@SPIWrite|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M36082|
  00008	e1a0e002	 mov         lr, r2

; 209  :     DEVICE_CONTEXT_SPI *pContext = (DEVICE_CONTEXT_SPI *)hContext;
; 210  :     if( pContext->ifc.context )

  0000c	e5903000	 ldr         r3, [r0]

; 211  :     {
; 212  : 	    return pContext->ifc.pfnWrite(pContext->ifc.context, pBuffer, size);

  00010	e1a02001	 mov         r2, r1
  00014	e1a0100e	 mov         r1, lr
  00018	e1b04003	 movs        r4, r3
  0001c	0a000004	 beq         |$LN2@SPIWrite|
  00020	e590300c	 ldr         r3, [r0, #0xC]
  00024	e1a00004	 mov         r0, r4
  00028	e1a0e00f	 mov         lr, pc
  0002c	e12fff13	 bx          r3
  00030	ea000007	 b           |$LN1@SPIWrite|
  00034		 |$LN2@SPIWrite|

; 213  : 	}
; 214  :     else
; 215  :     {
; 216  :         DWORD   dwCount = 0;
; 217  : 
; 218  :         WriteFile( pContext->hDevice, pBuffer, size, &dwCount, NULL );

  00034	e5900030	 ldr         r0, [r0, #0x30]
  00038	e3a04000	 mov         r4, #0
  0003c	e3a05000	 mov         r5, #0
  00040	e28d3004	 add         r3, sp, #4
  00044	e58d4004	 str         r4, [sp, #4]
  00048	e58d5000	 str         r5, [sp]
  0004c	eb000000	 bl          WriteFile

; 219  :         return dwCount;

  00050	e59d0004	 ldr         r0, [sp, #4]
  00054		 |$LN1@SPIWrite|

; 220  :     }
; 221  : }

  00054	e28dd008	 add         sp, sp, #8
  00058	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$M36083|

			 ENDP  ; |SPIWrite|

	EXPORT	|SPIWriteRead|

  00000			 AREA	 |.pdata|, PDATA
|$T36098| DCD	|$LN7@SPIWriteRe|
	DCD	0x40001b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPIWriteRead| PROC

; 224  : {

  00000		 |$LN7@SPIWriteRe|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M36095|
  00008	e1a06003	 mov         r6, r3
  0000c	e1a07002	 mov         r7, r2
  00010	e1a05001	 mov         r5, r1

; 225  :     DEVICE_CONTEXT_SPI *pContext = (DEVICE_CONTEXT_SPI *)hContext;
; 226  :     if( pContext->ifc.context )

  00014	e590e000	 ldr         lr, [r0]
  00018	e35e0000	 cmp         lr, #0
  0001c	0a000004	 beq         |$LN2@SPIWriteRe|

; 227  :     {
; 228  : 	    return pContext->ifc.pfnWriteRead(pContext->ifc.context, size, pOutBuffer, pInBuffer);

  00020	e5904010	 ldr         r4, [r0, #0x10]
  00024	e1a0000e	 mov         r0, lr
  00028	e1a0e00f	 mov         lr, pc
  0002c	e12fff14	 bx          r4
  00030	ea000009	 b           |$LN1@SPIWriteRe|
  00034		 |$LN2@SPIWriteRe|

; 229  : 	}
; 230  :     else
; 231  :     {
; 232  :         return DeviceIoControl(pContext->hDevice,
; 233  :                         IOCTL_SPI_WRITEREAD,
; 234  :                         pInBuffer,
; 235  :                         size,
; 236  :                         pOutBuffer,
; 237  :                         size,
; 238  :                         NULL,
; 239  :                         NULL );

  00034	e59f102c	 ldr         r1, [pc, #0x2C]
  00038	e5900030	 ldr         r0, [r0, #0x30]
  0003c	e3a0e000	 mov         lr, #0
  00040	e1a03005	 mov         r3, r5
  00044	e1a02006	 mov         r2, r6
  00048	e58de00c	 str         lr, [sp, #0xC]
  0004c	e58de008	 str         lr, [sp, #8]
  00050	e58d5004	 str         r5, [sp, #4]
  00054	e58d7000	 str         r7, [sp]
  00058	eb000000	 bl          DeviceIoControl
  0005c		 |$LN1@SPIWriteRe|

; 240  :     }
; 241  : }

  0005c	e28dd010	 add         sp, sp, #0x10
  00060	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00064	e12fff1e	 bx          lr
  00068		 |$LN8@SPIWriteRe|
  00068		 |$LN9@SPIWriteRe|
  00068	00220804	 DCD         0x220804
  0006c		 |$M36096|

			 ENDP  ; |SPIWriteRead|

	EXPORT	|SPIAsyncWriteRead|

  00000			 AREA	 |.pdata|, PDATA
|$T36113| DCD	|$LN7@SPIAsyncWr|
	DCD	0x40001b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPIAsyncWriteRead| PROC

; 244  : {

  00000		 |$LN7@SPIAsyncWr|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M36110|
  00008	e1a06003	 mov         r6, r3
  0000c	e1a07002	 mov         r7, r2
  00010	e1a05001	 mov         r5, r1

; 245  :     DEVICE_CONTEXT_SPI *pContext = (DEVICE_CONTEXT_SPI *)hContext;
; 246  :     if( pContext->ifc.context )

  00014	e590e000	 ldr         lr, [r0]
  00018	e35e0000	 cmp         lr, #0
  0001c	0a000004	 beq         |$LN2@SPIAsyncWr|

; 247  :     {
; 248  :         return pContext->ifc.pfnAsyncWriteRead(pContext->ifc.context, size, pOutBuffer, pInBuffer);

  00020	e5904024	 ldr         r4, [r0, #0x24]
  00024	e1a0000e	 mov         r0, lr
  00028	e1a0e00f	 mov         lr, pc
  0002c	e12fff14	 bx          r4
  00030	ea000009	 b           |$LN1@SPIAsyncWr|
  00034		 |$LN2@SPIAsyncWr|

; 249  :     }
; 250  :     else
; 251  :     {
; 252  :         return DeviceIoControl(pContext->hDevice,
; 253  :                         IOCTL_SPI_ASYNC_WRITEREAD,
; 254  :                         pInBuffer,
; 255  :                         size,
; 256  :                         pOutBuffer,
; 257  :                         size,
; 258  :                         NULL,
; 259  :                         NULL );

  00034	e59f102c	 ldr         r1, [pc, #0x2C]
  00038	e5900030	 ldr         r0, [r0, #0x30]
  0003c	e3a0e000	 mov         lr, #0
  00040	e1a03005	 mov         r3, r5
  00044	e1a02006	 mov         r2, r6
  00048	e58de00c	 str         lr, [sp, #0xC]
  0004c	e58de008	 str         lr, [sp, #8]
  00050	e58d5004	 str         r5, [sp, #4]
  00054	e58d7000	 str         r7, [sp]
  00058	eb000000	 bl          DeviceIoControl
  0005c		 |$LN1@SPIAsyncWr|

; 260  :     }
; 261  : }

  0005c	e28dd010	 add         sp, sp, #0x10
  00060	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00064	e12fff1e	 bx          lr
  00068		 |$LN8@SPIAsyncWr|
  00068		 |$LN9@SPIAsyncWr|
  00068	00220808	 DCD         0x220808
  0006c		 |$M36111|

			 ENDP  ; |SPIAsyncWriteRead|

	EXPORT	|SPIWaitForAsyncWriteReadComplet|

  00000			 AREA	 |.pdata|, PDATA
|$T36127| DCD	|$LN7@SPIWaitFor|
	DCD	0x40001a02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPIWaitForAsyncWriteReadComplet| PROC

; 264  : {

  00000		 |$LN7@SPIWaitFor|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M36124|
  00008	e1a0e002	 mov         lr, r2
  0000c	e1a04001	 mov         r4, r1

; 265  :     DEVICE_CONTEXT_SPI *pContext = (DEVICE_CONTEXT_SPI *)hContext;
; 266  :     if( pContext->ifc.context )

  00010	e5903000	 ldr         r3, [r0]
  00014	e1b05003	 movs        r5, r3
  00018	0a000004	 beq         |$LN2@SPIWaitFor|

; 267  :     {
; 268  :         return pContext->ifc.pfnWaitForAsyncWriteReadComplete(pContext->ifc.context, size, pOutBuffer);

  0001c	e5903028	 ldr         r3, [r0, #0x28]
  00020	e1a00005	 mov         r0, r5
  00024	e1a0e00f	 mov         lr, pc
  00028	e12fff13	 bx          r3
  0002c	ea000009	 b           |$LN1@SPIWaitFor|
  00030		 |$LN2@SPIWaitFor|

; 269  :     }
; 270  :     else
; 271  :     {
; 272  :         return DeviceIoControl(pContext->hDevice,
; 273  :                         IOCTL_SPI_ASYNC_WRITEREAD_COMPLETE,
; 274  :                         NULL,
; 275  :                         0,
; 276  :                         pOutBuffer,
; 277  :                         size,
; 278  :                         NULL,
; 279  :                         NULL );

  00030	e59f102c	 ldr         r1, [pc, #0x2C]
  00034	e5900030	 ldr         r0, [r0, #0x30]
  00038	e3a05000	 mov         r5, #0
  0003c	e3a03000	 mov         r3, #0
  00040	e3a02000	 mov         r2, #0
  00044	e58d500c	 str         r5, [sp, #0xC]
  00048	e58d5008	 str         r5, [sp, #8]
  0004c	e58d4004	 str         r4, [sp, #4]
  00050	e58de000	 str         lr, [sp]
  00054	eb000000	 bl          DeviceIoControl
  00058		 |$LN1@SPIWaitFor|

; 280  :     }
; 281  : }

  00058	e28dd010	 add         sp, sp, #0x10
  0005c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$LN8@SPIWaitFor|
  00064		 |$LN9@SPIWaitFor|
  00064	0022080c	 DCD         0x22080c
  00068		 |$M36125|

			 ENDP  ; |SPIWaitForAsyncWriteReadComplet|

	END
