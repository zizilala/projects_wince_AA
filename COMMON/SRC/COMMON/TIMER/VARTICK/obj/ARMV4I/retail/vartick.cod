; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\COMMON\TIMER\VARTICK\vartick.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|OALTimerUpdateRescheduleTime|
	IMPORT	|OALTimerUpdate|
	IMPORT	|OALTimerCountsSinceSysTick|
	IMPORT	|g_oalTimer|
	IMPORT	|g_pNKGlobal|
; File c:\wince600\platform\common\src\common\timer\vartick\vartick.c

  00000			 AREA	 |.pdata|, PDATA
|$T43139| DCD	|$LN10@OALTimerUp|
	DCD	0x40002201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALTimerUpdateRescheduleTime| PROC

; 25   : {

  00000		 |$LN10@OALTimerUp|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M43136|
  00004	e1a06000	 mov         r6, r0

; 26   :     UINT32 baseMSec, diffMSec, diffCounts;
; 27   :     INT32 counts;
; 28   : 
; 29   :     // Get current system timer counter
; 30   :     baseMSec = CurMSec;

  00008	e59f7074	 ldr         r7, [pc, #0x74]

; 31   : 
; 32   :     // Return if we are already setup correctly
; 33   :     if (time == (baseMSec + g_oalTimer.actualMSecPerSysTick)) goto cleanUp;

  0000c	e59f406c	 ldr         r4, [pc, #0x6C]
  00010	e5972000	 ldr         r2, [r7]
  00014	e5943014	 ldr         r3, [r4, #0x14]
  00018	e59250c8	 ldr         r5, [r2, #0xC8]
  0001c	e0833005	 add         r3, r3, r5
  00020	e1560003	 cmp         r6, r3
  00024	0a000013	 beq         |$cleanUp$43111|

; 34   : 
; 35   :     // How far we are from next tick
; 36   :     counts = g_oalTimer.actualCountsPerSysTick - OALTimerCountsSinceSysTick();

  00028	eb000000	 bl          OALTimerCountsSinceSysTick

; 37   : 
; 38   :     // If timer interrupts occurs, or we are within 1 ms of the scheduled
; 39   :     // interrupt, just return - timer ISR will take care of it.
; 40   :     if (baseMSec != CurMSec || counts < (INT32)g_oalTimer.countsPerMSec) {

  0002c	e5973000	 ldr         r3, [r7]
  00030	e59330c8	 ldr         r3, [r3, #0xC8]
  00034	e1550003	 cmp         r5, r3
  00038	1a00000e	 bne         |$cleanUp$43111|
  0003c	e5943018	 ldr         r3, [r4, #0x18]
  00040	e5941000	 ldr         r1, [r4]
  00044	e0433000	 sub         r3, r3, r0
  00048	e1530001	 cmp         r3, r1
  0004c	ba000009	 blt         |$cleanUp$43111|

; 41   :         goto cleanUp;
; 42   :     }        
; 43   : 
; 44   :     // Calculate the distance between the new time and the last timer interrupt
; 45   :     diffMSec = time - baseMSec;
; 46   : 
; 47   :     // Trying to set reschedule time prior or equal to CurMSec - this could
; 48   :     // happen if a thread is on its way to sleep while preempted before
; 49   :     // getting into the Sleep Queue
; 50   :     if ((INT32)diffMSec < 0) diffMSec = 0;
; 51   : 
; 52   :     // Account for limitation (we are using msecPerSysTick instead
; 53   :     // maxPeriodMSec - this allows little more ways how to modify timer
; 54   :     // behavior, but in most cases those values will be same)
; 55   :     if (diffMSec > g_oalTimer.msecPerSysTick) {

  00050	e594200c	 ldr         r2, [r4, #0xC]
  00054	e0563005	 subs        r3, r6, r5
  00058	43a03000	 movmi       r3, #0
  0005c	e1530002	 cmp         r3, r2

; 56   :         diffMSec = g_oalTimer.msecPerSysTick;

  00060	81a03002	 movhi       r3, r2

; 57   :     }        
; 58   : 
; 59   :     // Calculate count difference
; 60   :     diffCounts = diffMSec * g_oalTimer.countsPerMSec;

  00064	e0000391	 mul         r0, r1, r3

; 61   : 
; 62   :     // Actual values to be used by interrupt handler
; 63   :     g_oalTimer.actualMSecPerSysTick = diffMSec;

  00068	e5843014	 str         r3, [r4, #0x14]

; 64   :     g_oalTimer.actualCountsPerSysTick = diffCounts;

  0006c	e5840018	 str         r0, [r4, #0x18]

; 65   : 
; 66   :     // Reduct actual timer period (implementation must shift interrupt time
; 67   :     // if we are too close to new tick time)
; 68   :     OALTimerUpdate(diffCounts, g_oalTimer.countsMargin);

  00070	e5941004	 ldr         r1, [r4, #4]
  00074	eb000000	 bl          OALTimerUpdate
  00078		 |$cleanUp$43111|

; 69   : 
; 70   : cleanUp:
; 71   :     return;    
; 72   : }

  00078	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$LN11@OALTimerUp|
  00080		 |$LN12@OALTimerUp|
  00080	00000000	 DCD         |g_oalTimer|
  00084		 |$LN13@OALTimerUp|
  00084	00000000	 DCD         |g_pNKGlobal|
  00088		 |$M43137|

			 ENDP  ; |OALTimerUpdateRescheduleTime|

	END
