; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\COMMON\TIMER\IDLE\idle.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|OEMIdle|
	IMPORT	|OALCPUIdle|
	IMPORT	|OALTimerUpdate|
	IMPORT	|OALTimerCountsSinceSysTick|
	IMPORT	|g_pNKGlobal|
	IMPORT	|g_oalTimer|
	IMPORT	|__rt_udiv|
; File c:\wince600\platform\common\src\common\timer\idle\idle.c

  00000			 AREA	 |.pdata|, PDATA
|$T43152| DCD	|$LN14@OEMIdle|
	DCD	0x40004a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OEMIdle| PROC

; 56   : {

  00000		 |$LN14@OEMIdle|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M43149|

; 57   :     UINT32 baseMSec, idleMSec, idleSysTicks;
; 58   :     INT32 usedCounts, idleCounts;
; 59   :     ULARGE_INTEGER idle;
; 60   : 
; 61   : 
; 62   :     // Get current system timer counter
; 63   :     baseMSec = CurMSec;

  00004	e59f6118	 ldr         r6, [pc, #0x118]
  00008	e5963000	 ldr         r3, [r6]
  0000c	e59380c8	 ldr         r8, [r3, #0xC8]

; 64   : 
; 65   :     // Compute the remaining idle time
; 66   :     idleMSec = dwReschedTime - baseMSec;

  00010	e59330c4	 ldr         r3, [r3, #0xC4]
  00014	e0434008	 sub         r4, r3, r8

; 67   :     
; 68   :     // Idle time has expired - we need to return
; 69   :     if ((INT32)idleMSec <= 0) return;

  00018	e3540000	 cmp         r4, #0
  0001c	da00003d	 ble         |$LN9@OEMIdle|

; 70   : 
; 71   :     // Limit the maximum idle time to what is supported.  
; 72   :     // Counter size is the limiting parameter.  When kernel 
; 73   :     // profiler or interrupt latency timing is active it is set
; 74   :     // to one system tick.
; 75   :     if (idleMSec > g_oalTimer.maxPeriodMSec) {

  00020	e59f50f8	 ldr         r5, [pc, #0xF8]
  00024	e5953008	 ldr         r3, [r5, #8]

; 76   :         idleMSec = g_oalTimer.maxPeriodMSec;
; 77   :     }
; 78   :     
; 79   :     // We can wait only full systick
; 80   :     idleSysTicks = idleMSec/g_oalTimer.msecPerSysTick;

  00028	e595000c	 ldr         r0, [r5, #0xC]
  0002c	e1540003	 cmp         r4, r3
  00030	81a04003	 movhi       r4, r3
  00034	e1a01004	 mov         r1, r4
  00038	eb000000	 bl          __rt_udiv

; 81   :     
; 82   :     // This is idle time in hi-res ticks
; 83   :     idleCounts = idleSysTicks * g_oalTimer.countsPerSysTick;

  0003c	e5953010	 ldr         r3, [r5, #0x10]
  00040	e1a09000	 mov         r9, r0
  00044	e0070993	 mul         r7, r3, r9

; 84   : 
; 85   :     // Find how many hi-res ticks was already used
; 86   :     usedCounts = OALTimerCountsSinceSysTick();

  00048	eb000000	 bl          OALTimerCountsSinceSysTick
  0004c	e1a0a000	 mov         r10, r0

; 87   : 
; 88   :     // Prolong beat period to idle time -- don't do it idle time isn't
; 89   :     // longer than one system tick. Even if OALTimerExtendSysTick function
; 90   :     // should accept this value it can cause problems if kernel profiler
; 91   :     // or interrupt latency timing is active.
; 92   :     if (idleSysTicks > 1) {

  00050	e3590001	 cmp         r9, #1
  00054	9a000004	 bls         |$LN6@OEMIdle|

; 93   :         // Extend timer period
; 94   :         OALTimerUpdate(idleCounts, g_oalTimer.countsMargin);

  00058	e5951004	 ldr         r1, [r5, #4]
  0005c	e1a00007	 mov         r0, r7
  00060	eb000000	 bl          OALTimerUpdate

; 95   :         // Update value for timer interrupt which wakeup from idle
; 96   :         g_oalTimer.actualMSecPerSysTick = idleMSec;

  00064	e5854014	 str         r4, [r5, #0x14]

; 97   :         g_oalTimer.actualCountsPerSysTick = idleCounts;

  00068	e5857018	 str         r7, [r5, #0x18]
  0006c		 |$LN6@OEMIdle|

; 98   :     }
; 99   : 
; 100  :     // Move SoC/CPU to idle mode
; 101  :     OALCPUIdle();

  0006c	eb000000	 bl          OALCPUIdle

; 102  : 
; 103  :     // Return system tick period back to original. Don't call when idle
; 104  :     // time was one system tick. See comment above.
; 105  :     if (idleSysTicks > 1) {
; 106  : 
; 107  :         // If there wasn't timer interrupt we have to update CurMSec&curCounts
; 108  :         if (CurMSec == baseMSec) {

  00070	e5962000	 ldr         r2, [r6]
  00074	e3590001	 cmp         r9, #1
  00078	e59230c8	 ldr         r3, [r2, #0xC8]
  0007c	9a000017	 bls         |$LN5@OEMIdle|
  00080	e1530008	 cmp         r3, r8
  00084	1a00001a	 bne         |$LN2@OEMIdle|

; 109  :             // Return system tick period back to original
; 110  :             idleSysTicks = OALTimerUpdate(
; 111  :                 g_oalTimer.countsPerSysTick, g_oalTimer.countsMargin
; 112  :             );

  00088	e5951004	 ldr         r1, [r5, #4]
  0008c	e5950010	 ldr         r0, [r5, #0x10]
  00090	eb000000	 bl          OALTimerUpdate

; 113  :             // Restore original values
; 114  :             g_oalTimer.actualMSecPerSysTick = g_oalTimer.msecPerSysTick;

  00094	e595100c	 ldr         r1, [r5, #0xC]

; 115  :             g_oalTimer.actualCountsPerSysTick = g_oalTimer.countsPerSysTick;
; 116  :             // Fix system tick counters & idle counter
; 117  :             CurMSec += idleSysTicks * g_oalTimer.actualMSecPerSysTick;

  00098	e5962000	 ldr         r2, [r6]
  0009c	e5851014	 str         r1, [r5, #0x14]
  000a0	e5953010	 ldr         r3, [r5, #0x10]
  000a4	e5853018	 str         r3, [r5, #0x18]
  000a8	e59230c8	 ldr         r3, [r2, #0xC8]
  000ac	e0233091	 mla         r3, r1, r0, r3
  000b0	e58230c8	 str         r3, [r2, #0xC8]

; 118  :             idleCounts = idleSysTicks * g_oalTimer.actualCountsPerSysTick;

  000b4	e5951018	 ldr         r1, [r5, #0x18]

; 119  :             g_oalTimer.curCounts += idleCounts;

  000b8	e5953020	 ldr         r3, [r5, #0x20]
  000bc	e5952024	 ldr         r2, [r5, #0x24]
  000c0	e0040091	 mul         r4, r1, r0
  000c4	e0933004	 adds        r3, r3, r4
  000c8	e0a22fc4	 adc         r2, r2, r4, asr #31
  000cc	e5853020	 str         r3, [r5, #0x20]
  000d0	e5852024	 str         r2, [r5, #0x24]

; 120  :             idleCounts += OALTimerCountsSinceSysTick(); 

  000d4	eb000000	 bl          OALTimerCountsSinceSysTick
  000d8	e0847000	 add         r7, r4, r0

; 121  :         }            
; 122  : 
; 123  :     } else {

  000dc	ea000003	 b           |$LN11@OEMIdle|
  000e0		 |$LN5@OEMIdle|

; 124  : 
; 125  :         if (CurMSec == baseMSec) {

  000e0	e1530008	 cmp         r3, r8
  000e4	1a000002	 bne         |$LN2@OEMIdle|

; 126  :            // Update actual idle counts, if there wasn't timer interrupt
; 127  :             idleCounts = OALTimerCountsSinceSysTick();

  000e8	eb000000	 bl          OALTimerCountsSinceSysTick
  000ec	e1a07000	 mov         r7, r0
  000f0		 |$LN11@OEMIdle|
  000f0	e5962000	 ldr         r2, [r6]
  000f4		 |$LN2@OEMIdle|

; 128  :         }            
; 129  : 
; 130  :     } 
; 131  : 
; 132  :     // Get real idle value. If result is negative we didn't idle at all.
; 133  :     idleCounts -= usedCounts;
; 134  :     if (idleCounts < 0) idleCounts = 0;
; 135  :     
; 136  :     // Update idle counters
; 137  :     idle.LowPart = curridlelow;

  000f4	e59230d0	 ldr         r3, [r2, #0xD0]
  000f8	e057000a	 subs        r0, r7, r10
  000fc	43a00000	 movmi       r0, #0

; 138  :     idle.HighPart = curridlehigh;

  00100	e59210d4	 ldr         r1, [r2, #0xD4]

; 139  :     idle.QuadPart += idleCounts;

  00104	e0933000	 adds        r3, r3, r0

; 140  :     curridlelow  = idle.LowPart;

  00108	e58230d0	 str         r3, [r2, #0xD0]

; 141  :     curridlehigh = idle.HighPart;

  0010c	e5962000	 ldr         r2, [r6]
  00110	e0a13fc0	 adc         r3, r1, r0, asr #31
  00114	e58230d4	 str         r3, [r2, #0xD4]
  00118		 |$LN9@OEMIdle|

; 142  : }

  00118	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  0011c	e12fff1e	 bx          lr
  00120		 |$LN15@OEMIdle|
  00120		 |$LN16@OEMIdle|
  00120	00000000	 DCD         |g_oalTimer|
  00124		 |$LN17@OEMIdle|
  00124	00000000	 DCD         |g_pNKGlobal|
  00128		 |$M43150|

			 ENDP  ; |OEMIdle|

	END
