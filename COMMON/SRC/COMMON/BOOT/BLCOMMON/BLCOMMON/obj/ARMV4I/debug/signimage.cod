; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\COMMON\BOOT\BLCOMMON\signimage.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|CatSigExtName| [ DATA ]
	EXPORT	|rgbOID_Attr| [ DATA ]
	EXPORT	|rgbManufacturerTag| [ DATA ]
	EXPORT	|rgbModelTag| [ DATA ]

  00000			 AREA	 |.data|, DATA
	 COMMON	|g_hashCtx|, 0xc8

	 COMMON	|g_hHash|, 0x4

|rgbOID_Attr| DCB 0x2b
	DCB	0x6
	DCB	0x1
	DCB	0x4
	DCB	0x1
	DCB	0x82
	DCB	0x37
	DCB	0xc
	DCB	0x2
	DCB	0x1
	%	2
|rgbManufacturerTag| DCB 0x0
	DCB	0x4d
	DCB	0x0
	DCB	0x61
	DCB	0x0
	DCB	0x6e
	DCB	0x0
	DCB	0x75
	DCB	0x0
	DCB	0x66
	DCB	0x0
	DCB	0x61
	DCB	0x0
	DCB	0x63
	DCB	0x0
	DCB	0x74
	DCB	0x0
	DCB	0x75
	DCB	0x0
	DCB	0x72
	DCB	0x0
	DCB	0x65
	DCB	0x0
	DCB	0x72
|rgbModelTag| DCB 0x0
	DCB	0x4d
	DCB	0x0
	DCB	0x6f
	DCB	0x0
	DCB	0x64
	DCB	0x0
	DCB	0x65
	DCB	0x0
	DCB	0x6c

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
|CatSigExtName| DCB "cat_sig", 0x0
	EXPORT	|UpdateHash|
	IMPORT	|MinCryptUpdateHashMemory|

  00000			 AREA	 |.pdata|, PDATA
|$T45289| DCD	|$LN6@UpdateHash|
	DCD	0x40001d04
; Function compile flags: /Odtp
; File c:\wince600\platform\common\src\common\boot\blcommon\signimage.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UpdateHash| PROC

; 42   : {

  00000		 |$LN6@UpdateHash|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd010	 sub         sp, sp, #0x10
  00010		 |$M45286|

; 43   :     CRYPT_DER_BLOB ScratchBlob;
; 44   : 
; 45   :     ScratchBlob.cbData = dwSize;

  00010	e59d301c	 ldr         r3, [sp, #0x1C]
  00014	e58d3000	 str         r3, [sp]

; 46   :     ScratchBlob.pbData = (BYTE *)dwAddr;

  00018	e59d3018	 ldr         r3, [sp, #0x18]
  0001c	e58d3004	 str         r3, [sp, #4]

; 47   : 
; 48   :     if (MinCryptUpdateHashMemory(CALG_SHA1, g_hHash, 1, &ScratchBlob))

  00020	e28d3000	 add         r3, sp, #0
  00024	e3a02001	 mov         r2, #1
  00028	e59f1040	 ldr         r1, [pc, #0x40]
  0002c	e5911000	 ldr         r1, [r1]
  00030	e3a00902	 mov         r0, #2, 18
  00034	e3800004	 orr         r0, r0, #4
  00038	eb000000	 bl          MinCryptUpdateHashMemory
  0003c	e58d000c	 str         r0, [sp, #0xC]
  00040	e59d300c	 ldr         r3, [sp, #0xC]
  00044	e3530000	 cmp         r3, #0
  00048	0a000002	 beq         |$LN1@UpdateHash|

; 49   :     {
; 50   :         return(FALSE);

  0004c	e3a03000	 mov         r3, #0
  00050	e58d3008	 str         r3, [sp, #8]
  00054	ea000001	 b           |$LN2@UpdateHash|
  00058		 |$LN1@UpdateHash|

; 51   :     }
; 52   : 
; 53   :     return(TRUE);

  00058	e3a03001	 mov         r3, #1
  0005c	e58d3008	 str         r3, [sp, #8]
  00060		 |$LN2@UpdateHash|

; 54   : }

  00060	e59d0008	 ldr         r0, [sp, #8]
  00064	e28dd010	 add         sp, sp, #0x10
  00068	e89d6000	 ldmia       sp, {sp, lr}
  0006c	e12fff1e	 bx          lr
  00070		 |$LN7@UpdateHash|
  00070		 |$LN8@UpdateHash|
  00070	00000000	 DCD         |g_hHash|
  00074		 |$M45287|

			 ENDP  ; |UpdateHash|

	EXPORT	|??_C@_0CA@CJAKEIDB@INFO?3?5Signature?5check?5passed?$CB?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0DI@JLFAGPEN@ERROR?3?5MinCryptVerifyExtension?5f@| [ DATA ] ; `string'
	EXPORT	|??_C@_0DP@JAPCEMMG@ERROR?3?5MinCryptVerifyExtension?5f@| [ DATA ] ; `string'
	EXPORT	|??_C@_0ED@EKFNLABC@ERROR?3?5MinCryptVerifyHashInCatal@| [ DATA ] ; `string'
	EXPORT	|??_C@_0DF@HLPIFOJI@INFO?3?5Found?5signature?5?$CIAddress?$DN0@| [ DATA ] ; `string'
	EXPORT	|??_C@_0EN@CGKICGAI@ERROR?3?5Signature?5length?5is?5zero?4@| [ DATA ] ; `string'
	EXPORT	|??_C@_0GJ@DEHFEOBE@ERROR?3?5No?5signature?5record?5in?5ex@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CM@IEOABDFO@ERROR?3?5No?5extensions?5list?5?$CINULL?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_0DF@PDEEFBOO@?$CB?5ERROR?3?5Did?5not?5find?5pTOC?5signa@| [ DATA ] ; `string'
	EXPORT	|??_C@_0DF@PDKEKFNJ@?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB@| [ DATA ] ; `string'
	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|CheckSignature|
	IMPORT	|MinCryptVerifyExtension|
	IMPORT	|MinCryptVerifyHashInCatalogBlob|
	IMPORT	|memset|
	IMPORT	|MinCryptGetHashParam|
	IMPORT	|SigProcessImage|
	IMPORT	|MinCryptCreateHashMemoryMTH|
	IMPORT	|memcmp|
	IMPORT	|strlen|
	IMPORT	|KITLOutputDebugString|
	IMPORT	|__security_cookie|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|memcpy|
	IMPORT	|__security_check_cookie|

  00008			 AREA	 |.pdata|, PDATA
|$T45306| DCD	|$LN19@CheckSigna|
	DCD	0xc0015104

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CA@CJAKEIDB@INFO?3?5Signature?5check?5passed?$CB?$AN?6?$AA@| DCB "I"
	DCB	"NFO: Signature check passed!", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DI@JLFAGPEN@ERROR?3?5MinCryptVerifyExtension?5f@| DCB "ERROR: Min"
	DCB	"CryptVerifyExtension failed to verify Model", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DP@JAPCEMMG@ERROR?3?5MinCryptVerifyExtension?5f@| DCB "ERROR: Min"
	DCB	"CryptVerifyExtension failed to verify manufacturer", 0xd
	DCB	0xa, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0ED@EKFNLABC@ERROR?3?5MinCryptVerifyHashInCatal@| DCB "ERROR: MinC"
	DCB	"ryptVerifyHashInCatalogs returned 0x%x (rglErr=0x%x).", 0xd
	DCB	0xa, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DF@HLPIFOJI@INFO?3?5Found?5signature?5?$CIAddress?$DN0@| DCB "INF"
	DCB	"O: Found signature (Address=0x%x  Length=0x%x).", 0xd, 0xa
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0EN@CGKICGAI@ERROR?3?5Signature?5length?5is?5zero?4@| DCB "ERROR: "
	DCB	"Signature length is zero.  Was this image stamped with a"
	DCB	" signature?", 0xd, 0xa, 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0GJ@DEHFEOBE@ERROR?3?5No?5signature?5record?5in?5ex@| DCB "ERROR: "
	DCB	"No signature record in extensions list (an extension blo"
	DCB	"ck hasn't been reserved in this image)?", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CM@IEOABDFO@ERROR?3?5No?5extensions?5list?5?$CINULL?5@| DCB "ERRO"
	DCB	"R: No extensions list (NULL pointer).", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DF@PDEEFBOO@?$CB?5ERROR?3?5Did?5not?5find?5pTOC?5signa@| DCB "! E"
	DCB	"RROR: Did not find pTOC signature.  ABORTING. !", 0xd, 0xa
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DF@PDKEKFNJ@?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB@| DCB "!"
	DCB	"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", 0xd, 0xa
	DCB	0x0					; `string'

  00000			 AREA	 |.xdata|, DATA
|$T45302| DCD	0xffffffbc
; Function compile flags: /Odtp

  00074			 AREA	 |.text|, CODE, ARM

  00074	00000000	 DCD         |__GSHandlerCheck|
  00078	00000000	 DCD         |$T45302|

  0007c		 |CheckSignature| PROC

; 60   : {

  0007c		 |$LN19@CheckSigna|
  0007c	e1a0c00d	 mov         r12, sp
  00080	e92d000f	 stmdb       sp!, {r0 - r3}
  00084	e92d5000	 stmdb       sp!, {r12, lr}
  00088	e24dd0d4	 sub         sp, sp, #0xD4
  0008c		 |$M45303|
  0008c	e59f3528	 ldr         r3, [pc, #0x528]
  00090	e5933000	 ldr         r3, [r3]
  00094	e58d30a8	 str         r3, [sp, #0xA8]

; 61   : #define REBASE_ADDR(x)   (x + (dwStoreBase - dwRunBase))
; 62   :     DWORD dwpTOC = 0;

  00098	e3a03000	 mov         r3, #0
  0009c	e58d303c	 str         r3, [sp, #0x3C]

; 63   :     ROMHDR *pROMHdr = NULL;

  000a0	e3a03000	 mov         r3, #0
  000a4	e58d3034	 str         r3, [sp, #0x34]

; 64   :     EXTENSION *pExt = NULL;

  000a8	e3a03000	 mov         r3, #0
  000ac	e58d30a4	 str         r3, [sp, #0xA4]

; 65   :     BYTE *pSig = NULL;

  000b0	e3a03000	 mov         r3, #0
  000b4	e58d302c	 str         r3, [sp, #0x2C]

; 66   :     DWORD dwSigLen = 0;

  000b8	e3a03000	 mov         r3, #0
  000bc	e58d3030	 str         r3, [sp, #0x30]

; 67   :     DWORD cbHash = 0;

  000c0	e3a03000	 mov         r3, #0
  000c4	e58d3068	 str         r3, [sp, #0x68]

; 68   :     DWORD cbAttr = 0;

  000c8	e3a03000	 mov         r3, #0
  000cc	e58d304c	 str         r3, [sp, #0x4C]

; 69   :     LONG rglErr = 0;

  000d0	e3a03000	 mov         r3, #0
  000d4	e58d3038	 str         r3, [sp, #0x38]

; 70   :     LONG lStatus = 0;

  000d8	e3a03000	 mov         r3, #0
  000dc	e58d3048	 str         r3, [sp, #0x48]

; 71   :     BYTE rgbHash[MINCRYPT_MAX_HASH_LEN];
; 72   :     CRYPT_HASH_BLOB rgHashBlob;
; 73   :     MAP_CAT_INFO rgMapCatInfo;
; 74   :     CRYPT_DATA_BLOB rgExtensionTagName;
; 75   :     CRYPT_DATA_BLOB rgExtensionValue;
; 76   :     CRYPT_DATA_BLOB rgAttrEncodedOIDBlob;
; 77   : 
; 78   : 
; 79   :     // Check for TOC signature.
; 80   :     //
; 81   :     if (*(LPDWORD)(dwStoreBase + ROM_SIGNATURE_OFFSET) != ROM_SIGNATURE)

  000e0	e59d30dc	 ldr         r3, [sp, #0xDC]
  000e4	e2833040	 add         r3, r3, #0x40
  000e8	e5932000	 ldr         r2, [r3]
  000ec	e59f34c4	 ldr         r3, [pc, #0x4C4]
  000f0	e1520003	 cmp         r2, r3
  000f4	0a00000a	 beq         |$LN14@CheckSigna|

; 82   :     {
; 83   :         KITLOutputDebugString ("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n");

  000f8	e59f04b0	 ldr         r0, [pc, #0x4B0]
  000fc	eb000000	 bl          KITLOutputDebugString

; 84   :         KITLOutputDebugString ("! ERROR: Did not find pTOC signature.  ABORTING. !\r\n");

  00100	e59f04ac	 ldr         r0, [pc, #0x4AC]
  00104	eb000000	 bl          KITLOutputDebugString

; 85   :         KITLOutputDebugString ("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n");

  00108	e59f04a0	 ldr         r0, [pc, #0x4A0]
  0010c	eb000000	 bl          KITLOutputDebugString

; 86   : 
; 87   :         return(FALSE);

  00110	e59d00a8	 ldr         r0, [sp, #0xA8]
  00114	eb000000	 bl          __security_check_cookie
  00118	e3a03000	 mov         r3, #0
  0011c	e58d30ac	 str         r3, [sp, #0xAC]
  00120	ea00010f	 b           |$LN15@CheckSigna|
  00124		 |$LN14@CheckSigna|

; 88   :     }
; 89   : 
; 90   :     // Get pointer to TOC.
; 91   :     //
; 92   :     dwpTOC = *(LPDWORD)(dwStoreBase + ROM_SIGNATURE_OFFSET + sizeof(ULONG));

  00124	e59d30dc	 ldr         r3, [sp, #0xDC]
  00128	e2833044	 add         r3, r3, #0x44
  0012c	e5933000	 ldr         r3, [r3]
  00130	e58d303c	 str         r3, [sp, #0x3C]

; 93   : 
; 94   :     // Locate the catalog file signature record via the ROMHDR extension pointer.
; 95   :     //
; 96   :     pROMHdr = (ROMHDR *)REBASE_ADDR(dwpTOC);

  00134	e59d20dc	 ldr         r2, [sp, #0xDC]
  00138	e59d30e0	 ldr         r3, [sp, #0xE0]
  0013c	e0422003	 sub         r2, r2, r3
  00140	e59d303c	 ldr         r3, [sp, #0x3C]
  00144	e0833002	 add         r3, r3, r2
  00148	e58d3034	 str         r3, [sp, #0x34]

; 97   : 
; 98   :     if (!pROMHdr->pExtensions)

  0014c	e59d3034	 ldr         r3, [sp, #0x34]
  00150	e2833048	 add         r3, r3, #0x48
  00154	e5933000	 ldr         r3, [r3]
  00158	e3530000	 cmp         r3, #0
  0015c	1a000006	 bne         |$LN13@CheckSigna|

; 99   :     {
; 100  :         KITLOutputDebugString("ERROR: No extensions list (NULL pointer).\r\n");

  00160	e59f0444	 ldr         r0, [pc, #0x444]
  00164	eb000000	 bl          KITLOutputDebugString

; 101  :         return(FALSE);

  00168	e59d00a8	 ldr         r0, [sp, #0xA8]
  0016c	eb000000	 bl          __security_check_cookie
  00170	e3a03000	 mov         r3, #0
  00174	e58d30ac	 str         r3, [sp, #0xAC]
  00178	ea0000f9	 b           |$LN15@CheckSigna|
  0017c		 |$LN13@CheckSigna|

; 102  :     }
; 103  : 
; 104  :     pExt = (EXTENSION *)REBASE_ADDR((DWORD)pROMHdr->pExtensions);

  0017c	e59d3034	 ldr         r3, [sp, #0x34]
  00180	e2831048	 add         r1, r3, #0x48
  00184	e59d20dc	 ldr         r2, [sp, #0xDC]
  00188	e59d30e0	 ldr         r3, [sp, #0xE0]
  0018c	e0422003	 sub         r2, r2, r3
  00190	e5913000	 ldr         r3, [r1]
  00194	e0833002	 add         r3, r3, r2
  00198	e58d30a4	 str         r3, [sp, #0xA4]
  0019c		 |$LN12@CheckSigna|

; 105  : 
; 106  :     while(pExt && memcmp(pExt->name, CatSigExtName, strlen(CatSigExtName)))

  0019c	e59d30a4	 ldr         r3, [sp, #0xA4]
  001a0	e3530000	 cmp         r3, #0
  001a4	0a00001b	 beq         |$LN11@CheckSigna|
  001a8	e59f03f8	 ldr         r0, [pc, #0x3F8]
  001ac	eb000000	 bl          strlen
  001b0	e58d00bc	 str         r0, [sp, #0xBC]
  001b4	e59d20bc	 ldr         r2, [sp, #0xBC]
  001b8	e59f13e8	 ldr         r1, [pc, #0x3E8]
  001bc	e59d00a4	 ldr         r0, [sp, #0xA4]
  001c0	eb000000	 bl          memcmp
  001c4	e58d00c0	 str         r0, [sp, #0xC0]
  001c8	e59d30c0	 ldr         r3, [sp, #0xC0]
  001cc	e3530000	 cmp         r3, #0
  001d0	0a000010	 beq         |$LN11@CheckSigna|

; 107  :     {
; 108  :         if (!pExt->pNextExt)

  001d4	e59d30a4	 ldr         r3, [sp, #0xA4]
  001d8	e2833028	 add         r3, r3, #0x28
  001dc	e5933000	 ldr         r3, [r3]
  001e0	e3530000	 cmp         r3, #0
  001e4	1a000002	 bne         |$LN10@CheckSigna|

; 109  :         {
; 110  :             pExt = NULL;

  001e8	e3a03000	 mov         r3, #0
  001ec	e58d30a4	 str         r3, [sp, #0xA4]

; 111  :             break;

  001f0	ea000008	 b           |$LN11@CheckSigna|
  001f4		 |$LN10@CheckSigna|

; 112  :         }
; 113  : 
; 114  :         pExt = (EXTENSION *)REBASE_ADDR((DWORD)pExt->pNextExt);

  001f4	e59d30a4	 ldr         r3, [sp, #0xA4]
  001f8	e2831028	 add         r1, r3, #0x28
  001fc	e59d20dc	 ldr         r2, [sp, #0xDC]
  00200	e59d30e0	 ldr         r3, [sp, #0xE0]
  00204	e0422003	 sub         r2, r2, r3
  00208	e5913000	 ldr         r3, [r1]
  0020c	e0833002	 add         r3, r3, r2
  00210	e58d30a4	 str         r3, [sp, #0xA4]

; 115  :     }

  00214	eaffffe0	 b           |$LN12@CheckSigna|
  00218		 |$LN11@CheckSigna|

; 116  : 
; 117  :     if (!pExt)

  00218	e59d30a4	 ldr         r3, [sp, #0xA4]
  0021c	e3530000	 cmp         r3, #0
  00220	1a000006	 bne         |$LN9@CheckSigna|

; 118  :     {
; 119  :         KITLOutputDebugString("ERROR: No signature record in extensions list (an extension block hasn't been reserved in this image)?\r\n");

  00224	e59f0378	 ldr         r0, [pc, #0x378]
  00228	eb000000	 bl          KITLOutputDebugString

; 120  :         return(FALSE);

  0022c	e59d00a8	 ldr         r0, [sp, #0xA8]
  00230	eb000000	 bl          __security_check_cookie
  00234	e3a03000	 mov         r3, #0
  00238	e58d30ac	 str         r3, [sp, #0xAC]
  0023c	ea0000c8	 b           |$LN15@CheckSigna|
  00240		 |$LN9@CheckSigna|

; 121  :     }
; 122  : 
; 123  :     // Get location and length of the signature.
; 124  :     //
; 125  :     dwSigLen = pExt->length;

  00240	e59d30a4	 ldr         r3, [sp, #0xA4]
  00244	e2833020	 add         r3, r3, #0x20
  00248	e5933000	 ldr         r3, [r3]
  0024c	e58d3030	 str         r3, [sp, #0x30]

; 126  :     pSig     = (BYTE *)REBASE_ADDR((DWORD)pExt->pdata);

  00250	e59d30a4	 ldr         r3, [sp, #0xA4]
  00254	e283101c	 add         r1, r3, #0x1C
  00258	e59d20dc	 ldr         r2, [sp, #0xDC]
  0025c	e59d30e0	 ldr         r3, [sp, #0xE0]
  00260	e0422003	 sub         r2, r2, r3
  00264	e5913000	 ldr         r3, [r1]
  00268	e0833002	 add         r3, r3, r2
  0026c	e58d302c	 str         r3, [sp, #0x2C]

; 127  :     if (!dwSigLen)

  00270	e59d3030	 ldr         r3, [sp, #0x30]
  00274	e3530000	 cmp         r3, #0
  00278	1a000006	 bne         |$LN8@CheckSigna|

; 128  :     {
; 129  :         KITLOutputDebugString("ERROR: Signature length is zero.  Was this image stamped with a signature?\r\n");

  0027c	e59f031c	 ldr         r0, [pc, #0x31C]
  00280	eb000000	 bl          KITLOutputDebugString

; 130  :         return(FALSE);

  00284	e59d00a8	 ldr         r0, [sp, #0xA8]
  00288	eb000000	 bl          __security_check_cookie
  0028c	e3a03000	 mov         r3, #0
  00290	e58d30ac	 str         r3, [sp, #0xAC]
  00294	ea0000b2	 b           |$LN15@CheckSigna|
  00298		 |$LN8@CheckSigna|

; 131  :     }
; 132  :     
; 133  :     KITLOutputDebugString("INFO: Found signature (Address=0x%x  Length=0x%x).\r\n", (DWORD)pSig, dwSigLen);

  00298	e59d2030	 ldr         r2, [sp, #0x30]
  0029c	e59d102c	 ldr         r1, [sp, #0x2C]
  002a0	e59f02f4	 ldr         r0, [pc, #0x2F4]
  002a4	eb000000	 bl          KITLOutputDebugString

; 134  : 
; 135  :     // Hash memory initialization.
; 136  :     //
; 137  :     // MinCryptCreateHashMemoryMTH() is the thread-safe version of 
; 138  :     // MinCryptCreateHashMemory().  We're running in a boot loader without 
; 139  :     // threading, but it's recommended to use this API to be future-proof.
; 140  :     //
; 141  :     // The other MinCrypt APIs were thread-safe to begin with, so there are no 
; 142  :     // xxxMTH() equivalents.
; 143  :     //
; 144  :     // The hash context is filled in by MinCrypt and used for its own purposes; 
; 145  :     // just make sure it doesn't get modified/invalidated until we're finished 
; 146  :     // using g_hHash.
; 147  :     //
; 148  :     MinCryptCreateHashMemoryMTH(CALG_SHA1, g_hashCtx, &g_hHash);

  002a8	e59f22e0	 ldr         r2, [pc, #0x2E0]
  002ac	e59f12e4	 ldr         r1, [pc, #0x2E4]
  002b0	e3a00902	 mov         r0, #2, 18
  002b4	e3800004	 orr         r0, r0, #4
  002b8	eb000000	 bl          MinCryptCreateHashMemoryMTH

; 149  : 
; 150  :     // Traverse the image and compute the hash.
; 151  :     //
; 152  :     if (!SigProcessImage((ROMHDR *)dwpTOC, (dwStoreBase - dwRunBase), UpdateHash))

  002bc	e59f22d0	 ldr         r2, [pc, #0x2D0]
  002c0	e59d10dc	 ldr         r1, [sp, #0xDC]
  002c4	e59d30e0	 ldr         r3, [sp, #0xE0]
  002c8	e0411003	 sub         r1, r1, r3
  002cc	e59d003c	 ldr         r0, [sp, #0x3C]
  002d0	eb000000	 bl          SigProcessImage
  002d4	e58d00c4	 str         r0, [sp, #0xC4]
  002d8	e59d30c4	 ldr         r3, [sp, #0xC4]
  002dc	e3530000	 cmp         r3, #0
  002e0	1a000004	 bne         |$LN7@CheckSigna|

; 153  :     {
; 154  :         return(FALSE);

  002e4	e59d00a8	 ldr         r0, [sp, #0xA8]
  002e8	eb000000	 bl          __security_check_cookie
  002ec	e3a03000	 mov         r3, #0
  002f0	e58d30ac	 str         r3, [sp, #0xAC]
  002f4	ea00009a	 b           |$LN15@CheckSigna|
  002f8		 |$LN7@CheckSigna|

; 155  :     }
; 156  : 
; 157  :     // Finish computing the hash.
; 158  :     //
; 159  :     MinCryptGetHashParam(CALG_SHA1, g_hHash, rgbHash, &cbHash);

  002f8	e28d3068	 add         r3, sp, #0x68
  002fc	e28d2090	 add         r2, sp, #0x90
  00300	e59f1288	 ldr         r1, [pc, #0x288]
  00304	e5911000	 ldr         r1, [r1]
  00308	e3a00902	 mov         r0, #2, 18
  0030c	e3800004	 orr         r0, r0, #4
  00310	eb000000	 bl          MinCryptGetHashParam

; 160  :     
; 161  :     rgHashBlob.cbData = cbHash;

  00314	e59d3068	 ldr         r3, [sp, #0x68]
  00318	e58d3050	 str         r3, [sp, #0x50]

; 162  :     rgHashBlob.pbData = rgbHash;

  0031c	e28d3090	 add         r3, sp, #0x90
  00320	e58d3054	 str         r3, [sp, #0x54]

; 163  : 
; 164  :     memset(&rgMapCatInfo, 0, sizeof(MAP_CAT_INFO));

  00324	e3a02024	 mov         r2, #0x24
  00328	e3a01000	 mov         r1, #0
  0032c	e28d006c	 add         r0, sp, #0x6C
  00330	eb000000	 bl          memset

; 165  :     
; 166  :     rgMapCatInfo.FileBlob.cbData = dwSigLen;

  00334	e59d3030	 ldr         r3, [sp, #0x30]
  00338	e58d3070	 str         r3, [sp, #0x70]

; 167  :     rgMapCatInfo.FileBlob.pbData = pSig;

  0033c	e59d302c	 ldr         r3, [sp, #0x2C]
  00340	e58d3074	 str         r3, [sp, #0x74]

; 168  : 
; 169  :     rgAttrEncodedOIDBlob.cbData = sizeof(rgbOID_Attr);

  00344	e3a0300a	 mov         r3, #0xA
  00348	e58d3040	 str         r3, [sp, #0x40]

; 170  :     rgAttrEncodedOIDBlob.pbData = rgbOID_Attr;

  0034c	e59f3238	 ldr         r3, [pc, #0x238]
  00350	e58d3044	 str         r3, [sp, #0x44]

; 171  : 
; 172  :     // Compute a CAT record for the hashed data and compare against the CAT record stamped in the image.
; 173  :     //
; 174  :     lStatus = MinCryptVerifyHashInCatalogBlob(CALG_SHA1, 1, &rgHashBlob, 1, &rgMapCatInfo, fTestSignature, &rglErr);

  00354	e28d3038	 add         r3, sp, #0x38
  00358	e58d3008	 str         r3, [sp, #8]
  0035c	e59d30e4	 ldr         r3, [sp, #0xE4]
  00360	e58d3004	 str         r3, [sp, #4]
  00364	e28d306c	 add         r3, sp, #0x6C
  00368	e58d3000	 str         r3, [sp]
  0036c	e3a03001	 mov         r3, #1
  00370	e28d2050	 add         r2, sp, #0x50
  00374	e3a01001	 mov         r1, #1
  00378	e3a00902	 mov         r0, #2, 18
  0037c	e3800004	 orr         r0, r0, #4
  00380	eb000000	 bl          MinCryptVerifyHashInCatalogBlob
  00384	e58d00c8	 str         r0, [sp, #0xC8]
  00388	e59d30c8	 ldr         r3, [sp, #0xC8]
  0038c	e58d3048	 str         r3, [sp, #0x48]

; 175  :     if (lStatus || rglErr)

  00390	e59d3048	 ldr         r3, [sp, #0x48]
  00394	e3530000	 cmp         r3, #0
  00398	1a000002	 bne         |$LN5@CheckSigna|
  0039c	e59d3038	 ldr         r3, [sp, #0x38]
  003a0	e3530000	 cmp         r3, #0
  003a4	0a000008	 beq         |$LN6@CheckSigna|
  003a8		 |$LN5@CheckSigna|

; 176  :     {
; 177  :         KITLOutputDebugString("ERROR: MinCryptVerifyHashInCatalogs returned 0x%x (rglErr=0x%x).\r\n", lStatus, rglErr);

  003a8	e59d2038	 ldr         r2, [sp, #0x38]
  003ac	e59d1048	 ldr         r1, [sp, #0x48]
  003b0	e59f01d0	 ldr         r0, [pc, #0x1D0]
  003b4	eb000000	 bl          KITLOutputDebugString

; 178  :         return(FALSE);

  003b8	e59d00a8	 ldr         r0, [sp, #0xA8]
  003bc	eb000000	 bl          __security_check_cookie
  003c0	e3a03000	 mov         r3, #0
  003c4	e58d30ac	 str         r3, [sp, #0xAC]
  003c8	ea000065	 b           |$LN15@CheckSigna|
  003cc		 |$LN6@CheckSigna|

; 179  :     }
; 180  : 
; 181  :     // Optionally verify the Make attribute.    
; 182  :     if (pbDeviceMakeData && dwDeviceMakeSize)

  003cc	e59d30e8	 ldr         r3, [sp, #0xE8]
  003d0	e3530000	 cmp         r3, #0
  003d4	0a00002c	 beq         |$LN4@CheckSigna|
  003d8	e59d30ec	 ldr         r3, [sp, #0xEC]
  003dc	e3530000	 cmp         r3, #0
  003e0	0a000029	 beq         |$LN4@CheckSigna|

; 183  :     {
; 184  :         // Now check the Make string
; 185  :         rgExtensionTagName.cbData = sizeof(rgbManufacturerTag);

  003e4	e3a03018	 mov         r3, #0x18
  003e8	e58d3060	 str         r3, [sp, #0x60]

; 186  :         rgExtensionTagName.pbData = rgbManufacturerTag;

  003ec	e59f3190	 ldr         r3, [pc, #0x190]
  003f0	e58d3064	 str         r3, [sp, #0x64]

; 187  :        
; 188  :         rgExtensionValue.cbData = dwDeviceMakeSize;

  003f4	e59d30ec	 ldr         r3, [sp, #0xEC]
  003f8	e58d3058	 str         r3, [sp, #0x58]

; 189  :         rgExtensionValue.pbData = pbDeviceMakeData;

  003fc	e59d30e8	 ldr         r3, [sp, #0xE8]
  00400	e58d305c	 str         r3, [sp, #0x5C]

; 190  :         
; 191  :         lStatus = MinCryptVerifyExtension(rgMapCatInfo, rgAttrEncodedOIDBlob, rgExtensionTagName, rgExtensionValue);

  00404	e28d0024	 add         r0, sp, #0x24
  00408	e28d1058	 add         r1, sp, #0x58
  0040c	e3a02008	 mov         r2, #8
  00410	eb000000	 bl          memcpy
  00414	e28d001c	 add         r0, sp, #0x1C
  00418	e28d1060	 add         r1, sp, #0x60
  0041c	e3a02008	 mov         r2, #8
  00420	eb000000	 bl          memcpy
  00424	e28d0014	 add         r0, sp, #0x14
  00428	e28d1040	 add         r1, sp, #0x40
  0042c	e3a02008	 mov         r2, #8
  00430	eb000000	 bl          memcpy
  00434	e28d0000	 add         r0, sp, #0
  00438	e28d107c	 add         r1, sp, #0x7C
  0043c	e3a02014	 mov         r2, #0x14
  00440	eb000000	 bl          memcpy
  00444	e59d006c	 ldr         r0, [sp, #0x6C]
  00448	e59d1070	 ldr         r1, [sp, #0x70]
  0044c	e59d2074	 ldr         r2, [sp, #0x74]
  00450	e59d3078	 ldr         r3, [sp, #0x78]
  00454	eb000000	 bl          MinCryptVerifyExtension
  00458	e58d00cc	 str         r0, [sp, #0xCC]
  0045c	e59d30cc	 ldr         r3, [sp, #0xCC]
  00460	e58d3048	 str         r3, [sp, #0x48]

; 192  :         if (lStatus)

  00464	e59d3048	 ldr         r3, [sp, #0x48]
  00468	e3530000	 cmp         r3, #0
  0046c	0a000006	 beq         |$LN3@CheckSigna|

; 193  :         {
; 194  :             KITLOutputDebugString("ERROR: MinCryptVerifyExtension failed to verify manufacturer\r\n");

  00470	e59f0108	 ldr         r0, [pc, #0x108]
  00474	eb000000	 bl          KITLOutputDebugString

; 195  :             return (FALSE);

  00478	e59d00a8	 ldr         r0, [sp, #0xA8]
  0047c	eb000000	 bl          __security_check_cookie
  00480	e3a03000	 mov         r3, #0
  00484	e58d30ac	 str         r3, [sp, #0xAC]
  00488	ea000035	 b           |$LN15@CheckSigna|
  0048c		 |$LN3@CheckSigna|
  0048c		 |$LN4@CheckSigna|

; 196  :         }
; 197  :     }
; 198  :     
; 199  :     // Optionally verify the Model attribute.    
; 200  :     if (pbDeviceModelData && dwDeviceModelSize)

  0048c	e59d30f0	 ldr         r3, [sp, #0xF0]
  00490	e3530000	 cmp         r3, #0
  00494	0a00002c	 beq         |$LN2@CheckSigna|
  00498	e59d30f4	 ldr         r3, [sp, #0xF4]
  0049c	e3530000	 cmp         r3, #0
  004a0	0a000029	 beq         |$LN2@CheckSigna|

; 201  :     {
; 202  :         rgExtensionTagName.cbData = sizeof(rgbModelTag);

  004a4	e3a0300a	 mov         r3, #0xA
  004a8	e58d3060	 str         r3, [sp, #0x60]

; 203  :         rgExtensionTagName.pbData = rgbModelTag;

  004ac	e59f30c8	 ldr         r3, [pc, #0xC8]
  004b0	e58d3064	 str         r3, [sp, #0x64]

; 204  :        
; 205  :         rgExtensionValue.cbData = dwDeviceModelSize;

  004b4	e59d30f4	 ldr         r3, [sp, #0xF4]
  004b8	e58d3058	 str         r3, [sp, #0x58]

; 206  :         rgExtensionValue.pbData = pbDeviceModelData;

  004bc	e59d30f0	 ldr         r3, [sp, #0xF0]
  004c0	e58d305c	 str         r3, [sp, #0x5C]

; 207  :     
; 208  :         lStatus = MinCryptVerifyExtension(rgMapCatInfo, rgAttrEncodedOIDBlob, rgExtensionTagName, rgExtensionValue);

  004c4	e28d0024	 add         r0, sp, #0x24
  004c8	e28d1058	 add         r1, sp, #0x58
  004cc	e3a02008	 mov         r2, #8
  004d0	eb000000	 bl          memcpy
  004d4	e28d001c	 add         r0, sp, #0x1C
  004d8	e28d1060	 add         r1, sp, #0x60
  004dc	e3a02008	 mov         r2, #8
  004e0	eb000000	 bl          memcpy
  004e4	e28d0014	 add         r0, sp, #0x14
  004e8	e28d1040	 add         r1, sp, #0x40
  004ec	e3a02008	 mov         r2, #8
  004f0	eb000000	 bl          memcpy
  004f4	e28d0000	 add         r0, sp, #0
  004f8	e28d107c	 add         r1, sp, #0x7C
  004fc	e3a02014	 mov         r2, #0x14
  00500	eb000000	 bl          memcpy
  00504	e59d006c	 ldr         r0, [sp, #0x6C]
  00508	e59d1070	 ldr         r1, [sp, #0x70]
  0050c	e59d2074	 ldr         r2, [sp, #0x74]
  00510	e59d3078	 ldr         r3, [sp, #0x78]
  00514	eb000000	 bl          MinCryptVerifyExtension
  00518	e58d00d0	 str         r0, [sp, #0xD0]
  0051c	e59d30d0	 ldr         r3, [sp, #0xD0]
  00520	e58d3048	 str         r3, [sp, #0x48]

; 209  :         if (lStatus)

  00524	e59d3048	 ldr         r3, [sp, #0x48]
  00528	e3530000	 cmp         r3, #0
  0052c	0a000006	 beq         |$LN1@CheckSigna|

; 210  :         {
; 211  :             KITLOutputDebugString("ERROR: MinCryptVerifyExtension failed to verify Model\r\n");

  00530	e59f0040	 ldr         r0, [pc, #0x40]
  00534	eb000000	 bl          KITLOutputDebugString

; 212  :             return (FALSE);

  00538	e59d00a8	 ldr         r0, [sp, #0xA8]
  0053c	eb000000	 bl          __security_check_cookie
  00540	e3a03000	 mov         r3, #0
  00544	e58d30ac	 str         r3, [sp, #0xAC]
  00548	ea000005	 b           |$LN15@CheckSigna|
  0054c		 |$LN1@CheckSigna|
  0054c		 |$LN2@CheckSigna|

; 213  :         }
; 214  :     }
; 215  : 
; 216  :     KITLOutputDebugString("INFO: Signature check passed!\r\n");

  0054c	e59f0020	 ldr         r0, [pc, #0x20]
  00550	eb000000	 bl          KITLOutputDebugString

; 217  :     
; 218  :     return(TRUE);

  00554	e59d00a8	 ldr         r0, [sp, #0xA8]
  00558	eb000000	 bl          __security_check_cookie
  0055c	e3a03001	 mov         r3, #1
  00560	e58d30ac	 str         r3, [sp, #0xAC]
  00564		 |$LN15@CheckSigna|

; 219  : }

  00564	e59d00ac	 ldr         r0, [sp, #0xAC]
  00568	e28dd0d4	 add         sp, sp, #0xD4
  0056c	e89d6000	 ldmia       sp, {sp, lr}
  00570	e12fff1e	 bx          lr
  00574		 |$LN20@CheckSigna|
  00574		 |$LN21@CheckSigna|
  00574	00000000	 DCD         |??_C@_0CA@CJAKEIDB@INFO?3?5Signature?5check?5passed?$CB?$AN?6?$AA@|
  00578		 |$LN22@CheckSigna|
  00578	00000000	 DCD         |??_C@_0DI@JLFAGPEN@ERROR?3?5MinCryptVerifyExtension?5f@|
  0057c		 |$LN23@CheckSigna|
  0057c	00000000	 DCD         |rgbModelTag|
  00580		 |$LN24@CheckSigna|
  00580	00000000	 DCD         |??_C@_0DP@JAPCEMMG@ERROR?3?5MinCryptVerifyExtension?5f@|
  00584		 |$LN25@CheckSigna|
  00584	00000000	 DCD         |rgbManufacturerTag|
  00588		 |$LN26@CheckSigna|
  00588	00000000	 DCD         |??_C@_0ED@EKFNLABC@ERROR?3?5MinCryptVerifyHashInCatal@|
  0058c		 |$LN27@CheckSigna|
  0058c	00000000	 DCD         |rgbOID_Attr|
  00590		 |$LN28@CheckSigna|
  00590	00000000	 DCD         |g_hHash|
  00594		 |$LN29@CheckSigna|
  00594	00000000	 DCD         |UpdateHash|
  00598		 |$LN30@CheckSigna|
  00598	00000000	 DCD         |g_hashCtx|
  0059c		 |$LN31@CheckSigna|
  0059c	00000000	 DCD         |??_C@_0DF@HLPIFOJI@INFO?3?5Found?5signature?5?$CIAddress?$DN0@|
  005a0		 |$LN32@CheckSigna|
  005a0	00000000	 DCD         |??_C@_0EN@CGKICGAI@ERROR?3?5Signature?5length?5is?5zero?4@|
  005a4		 |$LN33@CheckSigna|
  005a4	00000000	 DCD         |??_C@_0GJ@DEHFEOBE@ERROR?3?5No?5signature?5record?5in?5ex@|
  005a8		 |$LN34@CheckSigna|
  005a8	00000000	 DCD         |CatSigExtName|
  005ac		 |$LN35@CheckSigna|
  005ac	00000000	 DCD         |??_C@_0CM@IEOABDFO@ERROR?3?5No?5extensions?5list?5?$CINULL?5@|
  005b0		 |$LN36@CheckSigna|
  005b0	00000000	 DCD         |??_C@_0DF@PDKEKFNJ@?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB@|
  005b4		 |$LN37@CheckSigna|
  005b4	00000000	 DCD         |??_C@_0DF@PDEEFBOO@?$CB?5ERROR?3?5Did?5not?5find?5pTOC?5signa@|
  005b8		 |$LN38@CheckSigna|
  005b8	43454345	 DCD         0x43454345
  005bc		 |$LN39@CheckSigna|
  005bc	00000000	 DCD         |__security_cookie|
  005c0		 |$M45304|

			 ENDP  ; |CheckSignature|

	END
