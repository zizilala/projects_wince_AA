; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\COMMON\BOOT\BLSERIAL\serfuncs.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|?g_buffer@@3PAEA| [ DATA ]		; g_buffer

  00000			 AREA	 |.bss|, NOINIT
|?g_buffer@@3PAEA| % 0x5f0				; g_buffer

  00000			 AREA	 |.rdata|, DATA, READONLY
|packetHeaderSig| DCB 0x6b
	DCB	0x49
	DCB	0x54
	DCB	0x4c
	EXPORT	|?CalcChksum@@YAEPAEG@Z|		; CalcChksum
; File c:\wince600\platform\common\src\common\boot\blserial\serfuncs.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T32494| DCD	|$LN10@CalcChksum|
	DCD	0x40001201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CalcChksum@@YAEPAEG@Z| PROC		; CalcChksum

; 121  : {

  00000		 |$LN10@CalcChksum|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M32491|
  00004	e1a04000	 mov         r4, r0

; 122  :     USHORT s = 0;
; 123  :     UCHAR csum = 0;

  00008	e3a00000	 mov         r0, #0

; 124  : 
; 125  :     for(s = 0; s < len; s++)

  0000c	e3a0e000	 mov         lr, #0
  00010	e3510000	 cmp         r1, #0
  00014	0a000009	 beq         |$LN1@CalcChksum|
  00018	e3a03000	 mov         r3, #0
  0001c		 |$LL3@CalcChksum|

; 126  :         csum += *(pBuf + s);

  0001c	e7de2004	 ldrb        r2, [lr, +r4]
  00020	e2833001	 add         r3, r3, #1
  00024	e1a0e803	 mov         lr, r3, lsl #16
  00028	e0823000	 add         r3, r2, r0
  0002c	e1a0e82e	 mov         lr, lr, lsr #16
  00030	e20300ff	 and         r0, r3, #0xFF
  00034	e1a0300e	 mov         r3, lr
  00038	e15e0001	 cmp         lr, r1
  0003c	3afffff6	 bcc         |$LL3@CalcChksum|
  00040		 |$LN1@CalcChksum|

; 127  : 
; 128  :     return csum;
; 129  : }

  00040	e8bd4010	 ldmia       sp!, {r4, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$M32492|

			 ENDP  ; |?CalcChksum@@YAEPAEG@Z|, CalcChksum

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|SerialSendBootRequest|
	IMPORT	|OEMSerialSendRaw|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|strncpy|
	IMPORT	|memset|
	IMPORT	|__security_check_cookie|

  00000			 AREA	 |.pdata|, PDATA
|$T32513| DCD	|$LN5@SerialSend|
	DCD	0xc0002c02

  00000			 AREA	 |.xdata|, DATA
|$T32509| DCD	0xfffffff4
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T32509|

  00008		 |SerialSendBootRequest| PROC

; 137  : {

  00008		 |$LN5@SerialSend|
  00008	e92d4010	 stmdb       sp!, {r4, lr}
  0000c	e24dd034	 sub         sp, sp, #0x34
  00010		 |$M32510|
  00010	e1a04000	 mov         r4, r0
  00014	e59f3098	 ldr         r3, [pc, #0x98]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3030	 str         r3, [sp, #0x30]

; 138  :     BYTE buffer[sizeof(SERIAL_PACKET_HEADER) + sizeof(SERIAL_BOOT_REQUEST)] = {0};

  00020	e3a0202d	 mov         r2, #0x2D
  00024	e3a01000	 mov         r1, #0
  00028	e28d0001	 add         r0, sp, #1
  0002c	eb000000	 bl          memset

; 139  :     PSERIAL_PACKET_HEADER pHeader = (PSERIAL_PACKET_HEADER)buffer;
; 140  :     PSERIAL_BOOT_REQUEST pBootReq = (PSERIAL_BOOT_REQUEST)(buffer + sizeof(SERIAL_PACKET_HEADER));
; 141  : 
; 142  :     // create boot request
; 143  :     strncpy((char *)pBootReq->PlatformId, platformString, sizeof(pBootReq->PlatformId));

  00030	e3a02011	 mov         r2, #0x11
  00034	e1a01004	 mov         r1, r4
  00038	e28d000a	 add         r0, sp, #0xA
  0003c	eb000000	 bl          strncpy

; 144  :     pBootReq->PlatformId[ sizeof(pBootReq->PlatformId) - 1 ] = '\0';
; 145  : 
; 146  :     // create header
; 147  :     memcpy(pHeader->headerSig, packetHeaderSig, HEADER_SIG_BYTES);

  00040	e59f3068	 ldr         r3, [pc, #0x68]
  00044	e3a0e000	 mov         lr, #0

; 148  :     pHeader->pktType = KS_PKT_DLREQ;

  00048	e3a040bb	 mov         r4, #0xBB
  0004c	e5933000	 ldr         r3, [r3]

; 149  :     pHeader->payloadSize = sizeof(SERIAL_BOOT_REQUEST);

  00050	e3a02024	 mov         r2, #0x24

; 150  :     pHeader->crcData = CalcChksum((PBYTE)pBootReq, sizeof(SERIAL_BOOT_REQUEST));

  00054	e3a01024	 mov         r1, #0x24
  00058	e28d000a	 add         r0, sp, #0xA
  0005c	e58d3000	 str         r3, [sp]
  00060	e5cde01a	 strb        lr, [sp, #0x1A]
  00064	e5cd4004	 strb        r4, [sp, #4]
  00068	e1cd20b6	 strh        r2, [sp, #6]
  0006c	eb000000	 bl          |?CalcChksum@@YAEPAEG@Z|
  00070	e1a03000	 mov         r3, r0

; 151  :     pHeader->crcHdr = CalcChksum((PBYTE)pHeader,
; 152  :         sizeof(SERIAL_PACKET_HEADER) - sizeof(pHeader->crcHdr));

  00074	e28d0000	 add         r0, sp, #0
  00078	e3a01009	 mov         r1, #9
  0007c	e5cd3008	 strb        r3, [sp, #8]
  00080	eb000000	 bl          |?CalcChksum@@YAEPAEG@Z|
  00084	e1a03000	 mov         r3, r0

; 153  : 
; 154  :     OEMSerialSendRaw(buffer, sizeof(SERIAL_PACKET_HEADER) + sizeof(SERIAL_BOOT_REQUEST));

  00088	e28d0000	 add         r0, sp, #0
  0008c	e3a0102e	 mov         r1, #0x2E
  00090	e5cd3009	 strb        r3, [sp, #9]
  00094	eb000000	 bl          OEMSerialSendRaw

; 155  : 
; 156  :     return TRUE;

  00098	e59d0030	 ldr         r0, [sp, #0x30]
  0009c	eb000000	 bl          __security_check_cookie
  000a0	e3a00001	 mov         r0, #1

; 157  : }

  000a4	e28dd034	 add         sp, sp, #0x34
  000a8	e8bd4010	 ldmia       sp!, {r4, lr}
  000ac	e12fff1e	 bx          lr
  000b0		 |$LN6@SerialSend|
  000b0		 |$LN7@SerialSend|
  000b0	00000000	 DCD         |packetHeaderSig|
  000b4		 |$LN8@SerialSend|
  000b4	00000000	 DCD         |__security_cookie|
  000b8		 |$M32511|

			 ENDP  ; |SerialSendBootRequest|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|SerialSendBlockAck|

  00000			 AREA	 |.pdata|, PDATA
|$T32529| DCD	|$LN5@SerialSend@2|
	DCD	0xc0002902

  00000			 AREA	 |.xdata|, DATA
|$T32525| DCD	0xffffffe8
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T32525|

  00008		 |SerialSendBlockAck| PROC

; 166  : {

  00008		 |$LN5@SerialSend@2|
  00008	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  0000c	e24dd014	 sub         sp, sp, #0x14
  00010		 |$M32526|
  00010	e1a05000	 mov         r5, r0
  00014	e59f308c	 ldr         r3, [pc, #0x8C]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3010	 str         r3, [sp, #0x10]

; 167  :     BYTE buffer[sizeof(SERIAL_PACKET_HEADER) + sizeof(SERIAL_BLOCK_HEADER)];
; 168  :     PSERIAL_PACKET_HEADER pHeader = (PSERIAL_PACKET_HEADER)buffer;
; 169  :     PBYTE pBlockAck = (buffer + sizeof(SERIAL_PACKET_HEADER));
; 170  : 
; 171  :     // create block ack
; 172  :     pBlockAck[0] = (BYTE)(uBlockNumber >> 0) & 0xFF;
; 173  :     pBlockAck[1] = (BYTE)(uBlockNumber >> 8) & 0xFF;
; 174  :     pBlockAck[2] = (BYTE)(uBlockNumber >> 16) & 0xFF;
; 175  :     pBlockAck[3] = (BYTE)(uBlockNumber >> 24) & 0xFF;
; 176  : 
; 177  :     // create header
; 178  :     memcpy(pHeader->headerSig, packetHeaderSig, HEADER_SIG_BYTES);

  00020	e59f307c	 ldr         r3, [pc, #0x7C]
  00024	e1a0e425	 mov         lr, r5, lsr #8
  00028	e1a04825	 mov         r4, r5, lsr #16
  0002c	e5933000	 ldr         r3, [r3]
  00030	e1a02c25	 mov         r2, r5, lsr #24

; 179  :     pHeader->pktType = KS_PKT_DLACK;

  00034	e3a060dd	 mov         r6, #0xDD

; 180  :     pHeader->payloadSize = sizeof(SERIAL_BLOCK_HEADER);

  00038	e3a07004	 mov         r7, #4

; 181  :     pHeader->crcData = CalcChksum((PBYTE)pBlockAck, sizeof(SERIAL_BLOCK_HEADER));

  0003c	e3a01004	 mov         r1, #4
  00040	e28d000a	 add         r0, sp, #0xA
  00044	e58d3000	 str         r3, [sp]
  00048	e5cd500a	 strb        r5, [sp, #0xA]
  0004c	e5cde00b	 strb        lr, [sp, #0xB]
  00050	e5cd400c	 strb        r4, [sp, #0xC]
  00054	e5cd200d	 strb        r2, [sp, #0xD]
  00058	e5cd6004	 strb        r6, [sp, #4]
  0005c	e1cd70b6	 strh        r7, [sp, #6]
  00060	eb000000	 bl          |?CalcChksum@@YAEPAEG@Z|
  00064	e1a03000	 mov         r3, r0

; 182  :     pHeader->crcHdr = CalcChksum((PBYTE)pHeader,
; 183  :         sizeof(SERIAL_PACKET_HEADER) - sizeof(pHeader->crcHdr));

  00068	e28d0000	 add         r0, sp, #0
  0006c	e3a01009	 mov         r1, #9
  00070	e5cd3008	 strb        r3, [sp, #8]
  00074	eb000000	 bl          |?CalcChksum@@YAEPAEG@Z|
  00078	e1a03000	 mov         r3, r0

; 184  : 
; 185  :     OEMSerialSendRaw(buffer, sizeof(SERIAL_PACKET_HEADER) + sizeof(SERIAL_BLOCK_HEADER));

  0007c	e28d0000	 add         r0, sp, #0
  00080	e3a0100e	 mov         r1, #0xE
  00084	e5cd3009	 strb        r3, [sp, #9]
  00088	eb000000	 bl          OEMSerialSendRaw

; 186  : 
; 187  :     return TRUE;

  0008c	e59d0010	 ldr         r0, [sp, #0x10]
  00090	eb000000	 bl          __security_check_cookie
  00094	e3a00001	 mov         r0, #1

; 188  : }

  00098	e28dd014	 add         sp, sp, #0x14
  0009c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000a0	e12fff1e	 bx          lr
  000a4		 |$LN6@SerialSend@2|
  000a4		 |$LN7@SerialSend@2|
  000a4	00000000	 DCD         |packetHeaderSig|
  000a8		 |$LN8@SerialSend@2|
  000a8	00000000	 DCD         |__security_cookie|
  000ac		 |$M32527|

			 ENDP  ; |SerialSendBlockAck|

	EXPORT	|?RecvHeader@@YAHPAUtagSERIAL_PACKET_HEADER@@E@Z| ; RecvHeader
	EXPORT	|??_C@_0CA@LIHOEDHI@failed?5to?5receive?5header?5data?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BH@MJPKDDID@header?5checksum?5fail?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CF@PODCGAIM@failed?5to?5receive?5header?5signatu@| [ DATA ] ; `string'
	IMPORT	|KITLOutputDebugString|
	IMPORT	|OEMSerialRecvRaw|

  00000			 AREA	 |.pdata|, PDATA
|$T32548| DCD	|$LN17@RecvHeader|
	DCD	0x40003802

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CA@LIHOEDHI@failed?5to?5receive?5header?5data?$AN?6?$AA@| DCB "fa"
	DCB	"iled to receive header data", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BH@MJPKDDID@header?5checksum?5fail?$AN?6?$AA@| DCB "header checks"
	DCB	"um fail", 0xd, 0xa, 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CF@PODCGAIM@failed?5to?5receive?5header?5signatu@| DCB "failed to"
	DCB	" receive header signature", 0xd, 0xa, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?RecvHeader@@YAHPAUtagSERIAL_PACKET_HEADER@@E@Z| PROC ; RecvHeader

; 323  : {

  00000		 |$LN17@RecvHeader|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M32545|
  00008	e1a06001	 mov         r6, r1
  0000c	e1a05000	 mov         r5, r0

; 324  :     USHORT cbRead;
; 325  :     UINT i = 0;
; 326  :     cbRead = sizeof(UCHAR);

  00010	e3a03001	 mov         r3, #1
  00014	e59f70c0	 ldr         r7, [pc, #0xC0]
  00018	e1cd30b0	 strh        r3, [sp]
  0001c	e3a04000	 mov         r4, #0
  00020		 |$LL9@RecvHeader|

; 327  : 
; 328  :     // read the header bytes
; 329  :     while(i < HEADER_SIG_BYTES)
; 330  :     {
; 331  :         if(!OEMSerialRecvRaw((PBYTE)&(pHeader->headerSig[i]), &cbRead, bWaitInfinite) || sizeof(UCHAR) != cbRead)

  00020	e0840005	 add         r0, r4, r5
  00024	e1a02006	 mov         r2, r6
  00028	e28d1000	 add         r1, sp, #0
  0002c	eb000000	 bl          OEMSerialRecvRaw
  00030	e3500000	 cmp         r0, #0
  00034	0a00001f	 beq         |$LN13@RecvHeader|
  00038	e1dd30b0	 ldrh        r3, [sp]
  0003c	e3530001	 cmp         r3, #1
  00040	1a00001c	 bne         |$LN13@RecvHeader|

; 335  :         }
; 336  : 
; 337  :         if(pHeader->headerSig[i] == packetHeaderSig[i])

  00044	e7d42007	 ldrb        r2, [r4, +r7]
  00048	e7d43005	 ldrb        r3, [r4, +r5]
  0004c	e1530002	 cmp         r3, r2

; 338  :         {
; 339  :             i++;

  00050	02844001	 addeq       r4, r4, #1

; 340  :         }
; 341  : 
; 342  :         else
; 343  :         {
; 344  :             i = 0;

  00054	13a04000	 movne       r4, #0
  00058	e3540004	 cmp         r4, #4
  0005c	3affffef	 bcc         |$LL9@RecvHeader|

; 345  :         }
; 346  :     }
; 347  : 
; 348  :     // read the remaining header
; 349  :     cbRead = sizeof(SERIAL_PACKET_HEADER) - HEADER_SIG_BYTES;

  00060	e3a03006	 mov         r3, #6

; 350  :     if(!OEMSerialRecvRaw((PUCHAR)pHeader + HEADER_SIG_BYTES, &cbRead, bWaitInfinite) ||
; 351  :         sizeof(SERIAL_PACKET_HEADER) - HEADER_SIG_BYTES != cbRead)

  00064	e1a02006	 mov         r2, r6
  00068	e28d1000	 add         r1, sp, #0
  0006c	e2850004	 add         r0, r5, #4
  00070	e1cd30b0	 strh        r3, [sp]
  00074	eb000000	 bl          OEMSerialRecvRaw
  00078	e3500000	 cmp         r0, #0
  0007c	0a00000b	 beq         |$LN2@RecvHeader|
  00080	e1dd30b0	 ldrh        r3, [sp]
  00084	e3530006	 cmp         r3, #6
  00088	1a000008	 bne         |$LN2@RecvHeader|

; 355  :     }
; 356  : 
; 357  :     // verify the header checksum
; 358  :     if(pHeader->crcHdr != CalcChksum((PUCHAR)pHeader,
; 359  :         sizeof(SERIAL_PACKET_HEADER) - sizeof(pHeader->crcHdr)))

  0008c	e3a01009	 mov         r1, #9
  00090	e1a00005	 mov         r0, r5
  00094	eb000000	 bl          |?CalcChksum@@YAEPAEG@Z|
  00098	e5d53009	 ldrb        r3, [r5, #9]
  0009c	e1530000	 cmp         r3, r0

; 360  :     {
; 361  :         KITLOutputDebugString("header checksum fail\r\n");

  000a0	159f0030	 ldrne       r0, [pc, #0x30]
  000a4	1a000004	 bne         |$LN14@RecvHeader|

; 362  :         return FALSE;
; 363  :     }
; 364  : 
; 365  :     return TRUE;

  000a8	e3a00001	 mov         r0, #1
  000ac	ea000004	 b           |$LN10@RecvHeader|
  000b0		 |$LN2@RecvHeader|

; 352  :     {
; 353  :         KITLOutputDebugString("failed to receive header data\r\n");

  000b0	e59f001c	 ldr         r0, [pc, #0x1C]

; 354  :         return FALSE;

  000b4	ea000000	 b           |$LN14@RecvHeader|
  000b8		 |$LN13@RecvHeader|

; 332  :         {
; 333  :             KITLOutputDebugString("failed to receive header signature\r\n");

  000b8	e59f0010	 ldr         r0, [pc, #0x10]
  000bc		 |$LN14@RecvHeader|
  000bc	eb000000	 bl          KITLOutputDebugString

; 334  :             return FALSE;

  000c0	e3a00000	 mov         r0, #0

; 354  :         return FALSE;

  000c4		 |$LN10@RecvHeader|

; 366  : }

  000c4	e28dd004	 add         sp, sp, #4
  000c8	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000cc	e12fff1e	 bx          lr
  000d0		 |$LN18@RecvHeader|
  000d0		 |$LN19@RecvHeader|
  000d0	00000000	 DCD         |??_C@_0CF@PODCGAIM@failed?5to?5receive?5header?5signatu@|
  000d4		 |$LN20@RecvHeader|
  000d4	00000000	 DCD         |??_C@_0CA@LIHOEDHI@failed?5to?5receive?5header?5data?$AN?6?$AA@|
  000d8		 |$LN21@RecvHeader|
  000d8	00000000	 DCD         |??_C@_0BH@MJPKDDID@header?5checksum?5fail?$AN?6?$AA@|
  000dc		 |$LN22@RecvHeader|
  000dc	00000000	 DCD         |packetHeaderSig|
  000e0		 |$M32546|

			 ENDP  ; |?RecvHeader@@YAHPAUtagSERIAL_PACKET_HEADER@@E@Z|, RecvHeader

	EXPORT	|?RecvPacket@@YAHPAUtagSERIAL_PACKET_HEADER@@PAEPAGE@Z| ; RecvPacket
	EXPORT	|??_C@_0CJ@CHGIGMLG@received?5non?9download?5packet?5typ@| [ DATA ] ; `string'
	EXPORT	|??_C@_0DG@MLEBFPEB@data?5checksum?5failure?4?5expected?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BN@FEFEJPIP@failed?5to?5read?5packet?5data?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CM@DECDFMCF@insufficient?5buffer?5size?$DL?5ignori@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BK@JKGMIDGI@header?5checksum?5failure?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BL@MMGBDAGN@failed?5to?5receive?5header?$AN?6?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T32568| DCD	|$LN13@RecvPacket|
	DCD	0x40004601

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CJ@CHGIGMLG@received?5non?9download?5packet?5typ@| DCB "received "
	DCB	"non-download packet type 0x%X", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0DG@MLEBFPEB@data?5checksum?5failure?4?5expected?5@| DCB "data che"
	DCB	"cksum failure. expected 0x%X, received 0x%X", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BN@FEFEJPIP@failed?5to?5read?5packet?5data?$AN?6?$AA@| DCB "faile"
	DCB	"d to read packet data", 0xd, 0xa, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CM@DECDFMCF@insufficient?5buffer?5size?$DL?5ignori@| DCB "insuffi"
	DCB	"cient buffer size; ignoring packet", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BK@JKGMIDGI@header?5checksum?5failure?$AN?6?$AA@| DCB "header che"
	DCB	"cksum failure", 0xd, 0xa, 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BL@MMGBDAGN@failed?5to?5receive?5header?$AN?6?$AA@| DCB "failed t"
	DCB	"o receive header", 0xd, 0xa, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?RecvPacket@@YAHPAUtagSERIAL_PACKET_HEADER@@PAEPAGE@Z| PROC ; RecvPacket

; 264  : {

  00000		 |$LN13@RecvPacket|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M32565|
  00004	e1a06003	 mov         r6, r3
  00008	e1a05002	 mov         r5, r2
  0000c	e1a07001	 mov         r7, r1
  00010	e1a04000	 mov         r4, r0

; 265  :     // receive header
; 266  :     if(!RecvHeader(pHeader, bWaitInfinite))

  00014	e1a01006	 mov         r1, r6
  00018	eb000000	 bl          |?RecvHeader@@YAHPAUtagSERIAL_PACKET_HEADER@@E@Z|
  0001c	e3500000	 cmp         r0, #0
  00020	1a000004	 bne         |$LN6@RecvPacket|

; 267  :     {
; 268  :         KITLOutputDebugString("failed to receive header\r\n");

  00024	e59f00e8	 ldr         r0, [pc, #0xE8]
  00028		 |$LN9@RecvPacket|
  00028	eb000000	 bl          KITLOutputDebugString
  0002c		 |$LN10@RecvPacket|

; 269  :         return FALSE;

  0002c	e3a00000	 mov         r0, #0

; 313  : }

  00030	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00034	e12fff1e	 bx          lr
  00038		 |$LN6@RecvPacket|

; 270  :     }
; 271  : 
; 272  :     // verify packet checksum
; 273  :     if(pHeader->crcHdr != CalcChksum((PBYTE)pHeader,
; 274  :         sizeof(SERIAL_PACKET_HEADER) - sizeof(pHeader->crcHdr)))

  00038	e3a01009	 mov         r1, #9
  0003c	e1a00004	 mov         r0, r4
  00040	eb000000	 bl          |?CalcChksum@@YAEPAEG@Z|
  00044	e5d43009	 ldrb        r3, [r4, #9]
  00048	e1530000	 cmp         r3, r0

; 275  :     {
; 276  :         KITLOutputDebugString("header checksum failure\r\n");

  0004c	159f00bc	 ldrne       r0, [pc, #0xBC]
  00050	1afffff4	 bne         |$LN9@RecvPacket|

; 277  :         return FALSE;
; 278  :     }
; 279  : 
; 280  :     // make sure sufficient buffer is provided
; 281  :     if(*pcbFrame < pHeader->payloadSize)

  00054	e5d41006	 ldrb        r1, [r4, #6]
  00058	e5d43007	 ldrb        r3, [r4, #7]
  0005c	e1d520b0	 ldrh        r2, [r5]
  00060	e1813403	 orr         r3, r1, r3, lsl #8
  00064	e1520003	 cmp         r2, r3

; 282  :     {
; 283  :         KITLOutputDebugString("insufficient buffer size; ignoring packet\r\n");

  00068	359f009c	 ldrcc       r0, [pc, #0x9C]
  0006c	3affffed	 bcc         |$LN9@RecvPacket|

; 284  :         return FALSE;
; 285  :     }
; 286  : 
; 287  :     // receive data
; 288  :     *pcbFrame = pHeader->payloadSize;
; 289  :     if(!OEMSerialRecvRaw(pbFrame, pcbFrame, bWaitInfinite))

  00070	e1a02006	 mov         r2, r6
  00074	e1a01005	 mov         r1, r5
  00078	e1a00007	 mov         r0, r7
  0007c	e1c530b0	 strh        r3, [r5]
  00080	eb000000	 bl          OEMSerialRecvRaw
  00084	e3500000	 cmp         r0, #0

; 290  :     {
; 291  :         KITLOutputDebugString("failed to read packet data\r\n");

  00088	059f0078	 ldreq       r0, [pc, #0x78]
  0008c	0affffe5	 beq         |$LN9@RecvPacket|

; 292  :         return FALSE;
; 293  :     }
; 294  : 
; 295  :     // verify data checksum
; 296  :     if(pHeader->crcData != CalcChksum(pbFrame, *pcbFrame))

  00090	e1d510b0	 ldrh        r1, [r5]
  00094	e1a00007	 mov         r0, r7
  00098	eb000000	 bl          |?CalcChksum@@YAEPAEG@Z|
  0009c	e5d46008	 ldrb        r6, [r4, #8]
  000a0	e1560000	 cmp         r6, r0
  000a4	0a000007	 beq         |$LN2@RecvPacket|

; 297  :     {
; 298  :         KITLOutputDebugString("data checksum failure. expected 0x%X, received 0x%X\r\n",pHeader->crcData,CalcChksum(pbFrame,*pcbFrame));

  000a8	e1d510b0	 ldrh        r1, [r5]
  000ac	e1a00007	 mov         r0, r7
  000b0	eb000000	 bl          |?CalcChksum@@YAEPAEG@Z|
  000b4	e1a02000	 mov         r2, r0
  000b8	e59f0044	 ldr         r0, [pc, #0x44]
  000bc	e1a01006	 mov         r1, r6
  000c0	eb000000	 bl          KITLOutputDebugString

; 299  :         return FALSE;

  000c4	eaffffd8	 b           |$LN10@RecvPacket|
  000c8		 |$LN2@RecvPacket|

; 300  :     }
; 301  : 
; 302  :     // verify packet type -- don't return any packet that is not
; 303  :     // a type the bootloader expects to receive
; 304  :     if(KS_PKT_DLPKT != pHeader->pktType &&
; 305  :        KS_PKT_DLACK != pHeader->pktType &&
; 306  :        KS_PKT_JUMP != pHeader->pktType)

  000c8	e5d43004	 ldrb        r3, [r4, #4]
  000cc	e35300cc	 cmp         r3, #0xCC
  000d0	0a000007	 beq         |$LN1@RecvPacket|
  000d4	e35300dd	 cmp         r3, #0xDD
  000d8	0a000005	 beq         |$LN1@RecvPacket|
  000dc	e35300ee	 cmp         r3, #0xEE
  000e0	0a000003	 beq         |$LN1@RecvPacket|

; 307  :     {
; 308  :         KITLOutputDebugString("received non-download packet type 0x%X\r\n", pHeader->pktType);

  000e4	e59f0014	 ldr         r0, [pc, #0x14]
  000e8	e1a01003	 mov         r1, r3
  000ec	eb000000	 bl          KITLOutputDebugString

; 309  :         return FALSE;

  000f0	eaffffcd	 b           |$LN10@RecvPacket|
  000f4		 |$LN1@RecvPacket|

; 310  :     }
; 311  : 
; 312  :     return TRUE;

  000f4	e3a00001	 mov         r0, #1

; 313  : }

  000f8	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000fc	e12fff1e	 bx          lr
  00100		 |$LN14@RecvPacket|
  00100		 |$LN15@RecvPacket|
  00100	00000000	 DCD         |??_C@_0CJ@CHGIGMLG@received?5non?9download?5packet?5typ@|
  00104		 |$LN16@RecvPacket|
  00104	00000000	 DCD         |??_C@_0DG@MLEBFPEB@data?5checksum?5failure?4?5expected?5@|
  00108		 |$LN17@RecvPacket|
  00108	00000000	 DCD         |??_C@_0BN@FEFEJPIP@failed?5to?5read?5packet?5data?$AN?6?$AA@|
  0010c		 |$LN18@RecvPacket|
  0010c	00000000	 DCD         |??_C@_0CM@DECDFMCF@insufficient?5buffer?5size?$DL?5ignori@|
  00110		 |$LN19@RecvPacket|
  00110	00000000	 DCD         |??_C@_0BK@JKGMIDGI@header?5checksum?5failure?$AN?6?$AA@|
  00114		 |$LN20@RecvPacket|
  00114	00000000	 DCD         |??_C@_0BL@MMGBDAGN@failed?5to?5receive?5header?$AN?6?$AA@|
  00118		 |$M32566|

			 ENDP  ; |?RecvPacket@@YAHPAUtagSERIAL_PACKET_HEADER@@PAEPAGE@Z|, RecvPacket

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|SerialReadData|
	EXPORT	|??_C@_0CE@HOCBBCP@Received?5out?5of?5sequence?5block?5?$CF@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BE@KEIPDPMM@Expected?5block?5?$CFu?$AN?6?$AA@| [ DATA ] ; `string'
	IMPORT	|memmove|
	IMPORT	|memcpy|

  00000			 AREA	 |.bss|, NOINIT
|?dwBlockNumber@?1??SerialReadData@@9@4KA| % 0x4	; `SerialReadData'::`2'::dwBlockNumber

  00000			 AREA	 |.bss|, NOINIT
|?cbDataBuffer@?1??SerialReadData@@9@4GA| % 0x2		; `SerialReadData'::`2'::cbDataBuffer

  00000			 AREA	 |.bss|, NOINIT
|?dataBuffer@?1??SerialReadData@@9@4PAEA| % 0x5f0	; `SerialReadData'::`2'::dataBuffer

  00000			 AREA	 |.pdata|, PDATA
|$T32603| DCD	|$LN24@SerialRead|
	DCD	0xc0006602

  00000			 AREA	 |.data|, DATA
|?pBlockHeader@?1??SerialReadData@@9@4PAUtagSERIAL_BLOCK_HEADER@@A| DCD |?dataBuffer@?1??SerialReadData@@9@4PAEA| ; `SerialReadData'::`2'::pBlockHeader

  00000			 AREA	 |.data|, DATA
|?pBlock@?1??SerialReadData@@9@4PAEA| DCD |?dataBuffer@?1??SerialReadData@@9@4PAEA|+4 ; `SerialReadData'::`2'::pBlock

  00000			 AREA	 |.xdata|, DATA
|$T32599| DCD	0xffffffd8

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CE@HOCBBCP@Received?5out?5of?5sequence?5block?5?$CF@| DCB "Receiv"
	DCB	"ed out of sequence block %u", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BE@KEIPDPMM@Expected?5block?5?$CFu?$AN?6?$AA@| DCB "Expected bloc"
	DCB	"k %u", 0xd, 0xa, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T32599|

  00008		 |SerialReadData| PROC

; 30   : {

  00008		 |$LN24@SerialRead|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd014	 sub         sp, sp, #0x14
  00010		 |$M32600|
  00010	e1a08001	 mov         r8, r1
  00014	e59f3180	 ldr         r3, [pc, #0x180]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3010	 str         r3, [sp, #0x10]
  00020	e1b06000	 movs        r6, r0

; 31   :     static DWORD dwBlockNumber = 0;
; 32   :     static USHORT cbDataBuffer = 0;
; 33   :     static BYTE dataBuffer[KITL_MTU] = {0};
; 34   : 
; 35   :     // the first DWORD in the local buffer is the block header which contains
; 36   :     // the sequence number of the block received
; 37   :     static PSERIAL_BLOCK_HEADER pBlockHeader = (PSERIAL_BLOCK_HEADER)dataBuffer;
; 38   :     static PBYTE pBlock = dataBuffer + sizeof(PSERIAL_BLOCK_HEADER);
; 39   : 
; 40   :     SERIAL_PACKET_HEADER header;
; 41   :     USHORT cbPacket;
; 42   : 
; 43   :     LPBYTE pOutBuffer = pbData;
; 44   : 
; 45   :     while(cbData)

  00024	0a00004e	 beq         |$LN11@SerialRead|
  00028	e59fa168	 ldr         r10, [pc, #0x168]
  0002c	e59f7160	 ldr         r7, [pc, #0x160]
  00030	e59fb158	 ldr         r11, [pc, #0x158]
  00034	e59a5000	 ldr         r5, [r10]
  00038	e1d740b0	 ldrh        r4, [r7]
  0003c	e59f9148	 ldr         r9, [pc, #0x148]
  00040		 |$LN21@SerialRead|
  00040	e3a0ee5f	 mov         lr, #0x5F, 28

; 46   :     {
; 47   :         // if there is no data in the local buffer, read some
; 48   :         //
; 49   :         while(0 == cbDataBuffer)

  00044	e3540000	 cmp         r4, #0
  00048	1a000028	 bne         |$LN9@SerialRead|
  0004c		 |$LL10@SerialRead|

; 50   :         {
; 51   :              // read from port
; 52   :              cbPacket = sizeof(dataBuffer);
; 53   :              if(RecvPacket(&header, dataBuffer, &cbPacket, TRUE))

  0004c	e59f1134	 ldr         r1, [pc, #0x134]
  00050	e3a03001	 mov         r3, #1
  00054	e28d2000	 add         r2, sp, #0
  00058	e28d0004	 add         r0, sp, #4
  0005c	e1cde0b0	 strh        lr, [sp]
  00060	eb000000	 bl          |?RecvPacket@@YAHPAUtagSERIAL_PACKET_HEADER@@PAEPAGE@Z|
  00064	e3500000	 cmp         r0, #0
  00068	0a00001b	 beq         |$LN19@SerialRead|

; 54   :              {
; 55   :                 // ignore non-download packet types
; 56   :                 if(KS_PKT_DLPKT == header.pktType)

  0006c	e5dd3008	 ldrb        r3, [sp, #8]
  00070	e35300cc	 cmp         r3, #0xCC
  00074	1a000029	 bne         |$LN7@SerialRead|

; 57   :                 {
; 58   :                     // make sure we received the correct block in the sequence
; 59   :                     if(dwBlockNumber == pBlockHeader->uBlockNum)

  00078	e59b3000	 ldr         r3, [r11]
  0007c	e5992000	 ldr         r2, [r9]
  00080	e5931000	 ldr         r1, [r3]
  00084	e1520001	 cmp         r2, r1
  00088	1a000008	 bne         |$LN6@SerialRead|

; 60   :                     {
; 61   :                         cbDataBuffer = header.payloadSize - sizeof(SERIAL_BLOCK_HEADER);

  0008c	e1dd30ba	 ldrh        r3, [sp, #0xA]
  00090	e2833cff	 add         r3, r3, #0xFF, 24
  00094	e28330fc	 add         r3, r3, #0xFC
  00098	e1a04803	 mov         r4, r3, lsl #16
  0009c	e1a04824	 mov         r4, r4, lsr #16

; 62   :                         dwBlockNumber++;

  000a0	e2823001	 add         r3, r2, #1
  000a4	e1c740b0	 strh        r4, [r7]
  000a8	e5893000	 str         r3, [r9]

; 63   :                     }
; 64   :                     else

  000ac	ea000006	 b           |$LN5@SerialRead|
  000b0		 |$LN6@SerialRead|

; 65   :                     {
; 66   :                         KITLOutputDebugString("Received out of sequence block %u\r\n", pBlockHeader->uBlockNum);

  000b0	e59f00cc	 ldr         r0, [pc, #0xCC]
  000b4	eb000000	 bl          KITLOutputDebugString

; 67   :                         KITLOutputDebugString("Expected block %u\r\n", dwBlockNumber);

  000b8	e5991000	 ldr         r1, [r9]
  000bc	e59f00bc	 ldr         r0, [pc, #0xBC]
  000c0	eb000000	 bl          KITLOutputDebugString
  000c4	e1d740b0	 ldrh        r4, [r7]
  000c8	e5993000	 ldr         r3, [r9]
  000cc		 |$LN5@SerialRead|

; 68   :                     }
; 69   : 
; 70   :                     // ack, or re-ack the sender
; 71   :                     if(dwBlockNumber > 0)

  000cc	e3530000	 cmp         r3, #0
  000d0	0a000002	 beq         |$LN4@SerialRead|

; 72   :                     {
; 73   :                         // block number has already been incremented when appropriate
; 74   :                         SerialSendBlockAck(dwBlockNumber - 1);

  000d4	e2430001	 sub         r0, r3, #1
  000d8	eb000000	 bl          SerialSendBlockAck
  000dc		 |$LN19@SerialRead|
  000dc	e1d740b0	 ldrh        r4, [r7]
  000e0		 |$LN4@SerialRead|

; 46   :     {
; 47   :         // if there is no data in the local buffer, read some
; 48   :         //
; 49   :         while(0 == cbDataBuffer)

  000e0	e3540000	 cmp         r4, #0
  000e4	e3a0ee5f	 mov         lr, #0x5F, 28
  000e8	0affffd7	 beq         |$LL10@SerialRead|
  000ec	e59a5000	 ldr         r5, [r10]
  000f0		 |$LN9@SerialRead|

; 82   :                 }
; 83   :              }
; 84   :         }
; 85   : 
; 86   :         // copy from local buffer into output buffer
; 87   :         //
; 88   : 
; 89   :         // if there are more than the requested bytes, copy and shift
; 90   :         // the local data buffer
; 91   :         if(cbDataBuffer > cbData)

  000f0	e1540006	 cmp         r4, r6

; 99   :             cbData = 0;
; 100  :         }
; 101  :         else // cbDataBuffer <= cbData
; 102  :         {
; 103  :             // copy all bytes in local buffer to output buffer
; 104  :             memcpy(pOutBuffer, pBlock, cbDataBuffer);

  000f4	e1a01005	 mov         r1, r5
  000f8	e1a00008	 mov         r0, r8
  000fc	8a00000e	 bhi         |$LN18@SerialRead|
  00100	e1a02004	 mov         r2, r4
  00104	eb000000	 bl          memcpy

; 105  :             cbData -= cbDataBuffer;

  00108	e0566004	 subs        r6, r6, r4

; 106  :             pOutBuffer += cbDataBuffer;

  0010c	e0888004	 add         r8, r8, r4

; 107  :             cbDataBuffer = 0;

  00110	e3a04000	 mov         r4, #0
  00114	e1c740b0	 strh        r4, [r7]
  00118	0a000011	 beq         |$LN11@SerialRead|

; 31   :     static DWORD dwBlockNumber = 0;
; 32   :     static USHORT cbDataBuffer = 0;
; 33   :     static BYTE dataBuffer[KITL_MTU] = {0};
; 34   : 
; 35   :     // the first DWORD in the local buffer is the block header which contains
; 36   :     // the sequence number of the block received
; 37   :     static PSERIAL_BLOCK_HEADER pBlockHeader = (PSERIAL_BLOCK_HEADER)dataBuffer;
; 38   :     static PBYTE pBlock = dataBuffer + sizeof(PSERIAL_BLOCK_HEADER);
; 39   : 
; 40   :     SERIAL_PACKET_HEADER header;
; 41   :     USHORT cbPacket;
; 42   : 
; 43   :     LPBYTE pOutBuffer = pbData;
; 44   : 
; 45   :     while(cbData)

  0011c	eaffffc7	 b           |$LN21@SerialRead|
  00120		 |$LN7@SerialRead|

; 75   :                     }
; 76   :                 }
; 77   :                 else
; 78   :                 {
; 79   :                     //Error received non-download packet type
; 80   :                     KITLOutputDebugString("received non-download packet type 0x%X\r\n", header.pktType);

  00120	e59f0054	 ldr         r0, [pc, #0x54]
  00124	e1a01003	 mov         r1, r3
  00128	eb000000	 bl          KITLOutputDebugString

; 81   :                     return FALSE;

  0012c	e59d0010	 ldr         r0, [sp, #0x10]
  00130	eb000000	 bl          __security_check_cookie
  00134	e3a00000	 mov         r0, #0
  00138	ea00000c	 b           |$LN13@SerialRead|
  0013c		 |$LN18@SerialRead|

; 92   :         {
; 93   :             // copy requested bytes from local buffer into output buffer
; 94   :             memcpy(pOutBuffer, pBlock, cbData);

  0013c	e1a02006	 mov         r2, r6
  00140	eb000000	 bl          memcpy

; 95   :             cbDataBuffer -= (USHORT)cbData;

  00144	e0443006	 sub         r3, r4, r6
  00148	e1a03803	 mov         r3, r3, lsl #16
  0014c	e1a03823	 mov         r3, r3, lsr #16

; 96   : 
; 97   :             // shift the local buffer accordingly because not all data was used
; 98   :             memmove(pBlock, pBlock + cbData, cbDataBuffer);

  00150	e1a02003	 mov         r2, r3
  00154	e0851006	 add         r1, r5, r6
  00158	e1a00005	 mov         r0, r5
  0015c	e1c730b0	 strh        r3, [r7]
  00160	eb000000	 bl          memmove
  00164		 |$LN11@SerialRead|

; 108  :         }
; 109  :     }
; 110  : 
; 111  :     return TRUE;

  00164	e59d0010	 ldr         r0, [sp, #0x10]
  00168	eb000000	 bl          __security_check_cookie
  0016c	e3a00001	 mov         r0, #1
  00170		 |$LN13@SerialRead|

; 112  : }

  00170	e28dd014	 add         sp, sp, #0x14
  00174	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00178	e12fff1e	 bx          lr
  0017c		 |$LN25@SerialRead|
  0017c		 |$LN26@SerialRead|
  0017c	00000000	 DCD         |??_C@_0CJ@CHGIGMLG@received?5non?9download?5packet?5typ@|
  00180		 |$LN27@SerialRead|
  00180	00000000	 DCD         |??_C@_0BE@KEIPDPMM@Expected?5block?5?$CFu?$AN?6?$AA@|
  00184		 |$LN28@SerialRead|
  00184	00000000	 DCD         |??_C@_0CE@HOCBBCP@Received?5out?5of?5sequence?5block?5?$CF@|
  00188		 |$LN29@SerialRead|
  00188	00000000	 DCD         |?dataBuffer@?1??SerialReadData@@9@4PAEA|
  0018c		 |$LN30@SerialRead|
  0018c	00000000	 DCD         |?dwBlockNumber@?1??SerialReadData@@9@4KA|
  00190		 |$LN31@SerialRead|
  00190	00000000	 DCD         |?pBlockHeader@?1??SerialReadData@@9@4PAUtagSERIAL_BLOCK_HEADER@@A|
  00194		 |$LN32@SerialRead|
  00194	00000000	 DCD         |?cbDataBuffer@?1??SerialReadData@@9@4GA|
  00198		 |$LN33@SerialRead|
  00198	00000000	 DCD         |?pBlock@?1??SerialReadData@@9@4PAEA|
  0019c		 |$LN34@SerialRead|
  0019c	00000000	 DCD         |__security_cookie|
  001a0		 |$M32601|

			 ENDP  ; |SerialReadData|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|SerialWaitForBootAck|
	EXPORT	|??_C@_0BK@IPKIMKPH@Waiting?5for?5boot?5ack?4?4?4?$AN?6?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T32632| DCD	|$LN7@SerialWait|
	DCD	0xc0002c02

  00000			 AREA	 |.xdata|, DATA
|$T32628| DCD	0xffffffec

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BK@IPKIMKPH@Waiting?5for?5boot?5ack?4?4?4?$AN?6?$AA@| DCB "Waitin"
	DCB	"g for boot ack...", 0xd, 0xa, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T32628|

  00008		 |SerialWaitForBootAck| PROC

; 199  : {

  00008		 |$LN7@SerialWait|
  00008	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  0000c	e24dd014	 sub         sp, sp, #0x14
  00010		 |$M32629|
  00010	e1a06000	 mov         r6, r0
  00014	e59f3098	 ldr         r3, [pc, #0x98]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3010	 str         r3, [sp, #0x10]

; 200  :     BOOL fRet = FALSE;
; 201  :     USHORT cbBuffer = KITL_MTU;
; 202  :     SERIAL_PACKET_HEADER header = {0};

  00020	e3a03000	 mov         r3, #0
  00024	e5cd3004	 strb        r3, [sp, #4]
  00028	e3a03000	 mov         r3, #0
  0002c	e5cd3005	 strb        r3, [sp, #5]

; 203  :     PSERIAL_BOOT_ACK pBootAck = (PSERIAL_BOOT_ACK)g_buffer;
; 204  : 
; 205  :     KITLOutputDebugString("Waiting for boot ack...\r\n");

  00030	e59f0078	 ldr         r0, [pc, #0x78]
  00034	e5cd3006	 strb        r3, [sp, #6]
  00038	e5cd3007	 strb        r3, [sp, #7]
  0003c	e3a03000	 mov         r3, #0
  00040	e3a02e5f	 mov         r2, #0x5F, 28
  00044	e58d3008	 str         r3, [sp, #8]
  00048	e1cd30bc	 strh        r3, [sp, #0xC]
  0004c	e3a04000	 mov         r4, #0
  00050	e1cd20b0	 strh        r2, [sp]
  00054	eb000000	 bl          KITLOutputDebugString

; 206  :     if(RecvPacket(&header, g_buffer, &cbBuffer, FALSE))

  00058	e59f504c	 ldr         r5, [pc, #0x4C]
  0005c	e3a03000	 mov         r3, #0
  00060	e28d2000	 add         r2, sp, #0
  00064	e1a01005	 mov         r1, r5
  00068	e28d0004	 add         r0, sp, #4
  0006c	eb000000	 bl          |?RecvPacket@@YAHPAUtagSERIAL_PACKET_HEADER@@PAEPAGE@Z|
  00070	e3500000	 cmp         r0, #0
  00074	0a000006	 beq         |$LN1@SerialWait|

; 207  :     {
; 208  :         // header checksum already verified
; 209  :         if(KS_PKT_DLACK == header.pktType &&
; 210  :             sizeof(SERIAL_BOOT_ACK) == header.payloadSize)

  00078	e5dd3008	 ldrb        r3, [sp, #8]
  0007c	e35300dd	 cmp         r3, #0xDD
  00080	01dd30ba	 ldreqh      r3, [sp, #0xA]
  00084	03530004	 cmpeq       r3, #4

; 211  :         {
; 212  :             *pfJump = pBootAck->fJumping;

  00088	05953000	 ldreq       r3, [r5]

; 213  :             fRet = TRUE;

  0008c	03a04001	 moveq       r4, #1
  00090	05863000	 streq       r3, [r6]
  00094		 |$LN1@SerialWait|

; 214  :         }
; 215  :     }
; 216  : 
; 217  :     return fRet;

  00094	e59d0010	 ldr         r0, [sp, #0x10]
  00098	eb000000	 bl          __security_check_cookie

; 218  : }

  0009c	e1a00004	 mov         r0, r4
  000a0	e28dd014	 add         sp, sp, #0x14
  000a4	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000a8	e12fff1e	 bx          lr
  000ac		 |$LN8@SerialWait|
  000ac		 |$LN9@SerialWait|
  000ac	00000000	 DCD         |?g_buffer@@3PAEA|
  000b0		 |$LN10@SerialWait|
  000b0	00000000	 DCD         |??_C@_0BK@IPKIMKPH@Waiting?5for?5boot?5ack?4?4?4?$AN?6?$AA@|
  000b4		 |$LN11@SerialWait|
  000b4	00000000	 DCD         |__security_cookie|
  000b8		 |$M32630|

			 ENDP  ; |SerialWaitForBootAck|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|SerialWaitForJump|
	EXPORT	|??_C@_0CK@DMEOPGMB@Got?5jump?5request?0?5KITL?5transport@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T32651| DCD	|$LN12@SerialWait@2|
	DCD	0xc0002c02

  00000			 AREA	 |.xdata|, DATA
|$T32647| DCD	0xfffffff4

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CK@DMEOPGMB@Got?5jump?5request?0?5KITL?5transport@| DCB "Got jump"
	DCB	" request, KITL transport = 0x%x", 0xd, 0xa, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T32647|

  00008		 |SerialWaitForJump| PROC

; 230  : {

  00008		 |$LN12@SerialWait@2|
  00008	e92d4010	 stmdb       sp!, {r4, lr}
  0000c	e24dd014	 sub         sp, sp, #0x14
  00010		 |$M32648|
  00010	e59f309c	 ldr         r3, [pc, #0x9C]
  00014	e5933000	 ldr         r3, [r3]
  00018	e58d3010	 str         r3, [sp, #0x10]

; 231  :     USHORT cbBuffer = KITL_MTU;
; 232  :     SERIAL_PACKET_HEADER header = {0};

  0001c	e3a03000	 mov         r3, #0
  00020	e5cd3004	 strb        r3, [sp, #4]
  00024	e3a03000	 mov         r3, #0
  00028	e5cd3005	 strb        r3, [sp, #5]
  0002c	e5cd3006	 strb        r3, [sp, #6]
  00030	e5cd3007	 strb        r3, [sp, #7]
  00034	e3a03000	 mov         r3, #0
  00038	e3a02e5f	 mov         r2, #0x5F, 28
  0003c	e59f406c	 ldr         r4, [pc, #0x6C]
  00040	e58d3008	 str         r3, [sp, #8]
  00044	e1cd30bc	 strh        r3, [sp, #0xC]
  00048	e1cd20b0	 strh        r2, [sp]
  0004c		 |$LL4@SerialWait@2|

; 233  :     PSERIAL_JUMP_REQUEST pJumpReq = (PSERIAL_JUMP_REQUEST)g_buffer;
; 234  : 
; 235  :     // wait indefinitely for a jump request
; 236  :     while(1)
; 237  :     {
; 238  :         if(RecvPacket(&header, g_buffer, &cbBuffer, TRUE))

  0004c	e3a03001	 mov         r3, #1
  00050	e28d2000	 add         r2, sp, #0
  00054	e1a01004	 mov         r1, r4
  00058	e28d0004	 add         r0, sp, #4
  0005c	eb000000	 bl          |?RecvPacket@@YAHPAUtagSERIAL_PACKET_HEADER@@PAEPAGE@Z|
  00060	e3500000	 cmp         r0, #0
  00064	0afffff8	 beq         |$LL4@SerialWait@2|

; 239  :         {
; 240  :             // header & checksum already verified
; 241  :             if(KS_PKT_JUMP == header.pktType &&
; 242  :                 sizeof(SERIAL_JUMP_REQUEST) == header.payloadSize)

  00068	e5dd3008	 ldrb        r3, [sp, #8]
  0006c	e35300ee	 cmp         r3, #0xEE
  00070	1afffff5	 bne         |$LL4@SerialWait@2|
  00074	e1dd30ba	 ldrh        r3, [sp, #0xA]
  00078	e3530004	 cmp         r3, #4

; 243  :             {
; 244  :                 SerialSendBlockAck(0);
; 245  :                 KITLOutputDebugString("Got jump request, KITL transport = 0x%x\r\n",
; 246  :                     pJumpReq->dwKitlTransport);
; 247  :                 return pJumpReq->dwKitlTransport;
; 248  :             }
; 249  :         }
; 250  :     }

  0007c	1afffff2	 bne         |$LL4@SerialWait@2|
  00080	e3a00000	 mov         r0, #0
  00084	eb000000	 bl          SerialSendBlockAck
  00088	e5941000	 ldr         r1, [r4]
  0008c	e59f0018	 ldr         r0, [pc, #0x18]
  00090	eb000000	 bl          KITLOutputDebugString
  00094	e59d0010	 ldr         r0, [sp, #0x10]
  00098	eb000000	 bl          __security_check_cookie
  0009c	e5940000	 ldr         r0, [r4]

; 251  : 
; 252  :     // never reached
; 253  :     return KTS_NONE;
; 254  : }

  000a0	e28dd014	 add         sp, sp, #0x14
  000a4	e8bd4010	 ldmia       sp!, {r4, lr}
  000a8	e12fff1e	 bx          lr
  000ac		 |$LN13@SerialWait@2|
  000ac		 |$LN14@SerialWait@2|
  000ac	00000000	 DCD         |??_C@_0CK@DMEOPGMB@Got?5jump?5request?0?5KITL?5transport@|
  000b0		 |$LN15@SerialWait@2|
  000b0	00000000	 DCD         |?g_buffer@@3PAEA|
  000b4		 |$LN16@SerialWait@2|
  000b4	00000000	 DCD         |__security_cookie|
  000b8		 |$M32649|

			 ENDP  ; |SerialWaitForJump|

	END
