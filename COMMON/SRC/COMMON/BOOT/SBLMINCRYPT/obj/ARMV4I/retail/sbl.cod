; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\COMMON\BOOT\SBLMINCRYPT\sbl.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.bss|, NOINIT
|bFoundCorrectKey| % 0x4
	IMPORT	|MinCryptVerifySignedHash|
; File c:\wince600\platform\common\src\common\boot\sblmincrypt\sbl.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T36902| DCD	|$LN7@Verify|
	DCD	0x40001a02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Verify@@YAJPBEK0KPAEK@Z| PROC	; Verify

; 45   : {

  00000		 |$LN7@Verify|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M36899|
  00008	e1a06003	 mov         r6, r3
  0000c	e1a07002	 mov         r7, r2
  00010	e1a04001	 mov         r4, r1
  00014	e1a05000	 mov         r5, r0

; 46   :     
; 47   :     HRESULT hr = S_OK;
; 48   :     LONG lResult;
; 49   : 
; 50   :     CRYPT_DER_BLOB blobSig;
; 51   :     CRYPT_DER_BLOB blobKey;
; 52   : 
; 53   :     blobSig.cbData = dwSigLen;
; 54   :     blobSig.pbData = const_cast <BYTE *> (pbSig);
; 55   : 
; 56   :     blobKey.cbData = dwKeyLen;
; 57   :     blobKey.pbData = const_cast <BYTE *> (pbKey);
; 58   : 
; 59   :     lResult = MinCryptVerifySignedHash(
; 60   :         CALG_SHA1,
; 61   :         pbHash,
; 62   :         dwHashLen,
; 63   :         &blobSig,
; 64   :         &blobKey);

  00018	e59d2030	 ldr         r2, [sp, #0x30]
  0001c	e59d102c	 ldr         r1, [sp, #0x2C]
  00020	e3a03902	 mov         r3, #2, 18
  00024	e3830004	 orr         r0, r3, #4
  00028	e28de00c	 add         lr, sp, #0xC
  0002c	e28d3004	 add         r3, sp, #4
  00030	e3a08000	 mov         r8, #0
  00034	e58d4004	 str         r4, [sp, #4]
  00038	e58d5008	 str         r5, [sp, #8]
  0003c	e58d600c	 str         r6, [sp, #0xC]
  00040	e58d7010	 str         r7, [sp, #0x10]
  00044	e58de000	 str         lr, [sp]
  00048	eb000000	 bl          MinCryptVerifySignedHash
  0004c	e3500000	 cmp         r0, #0

; 65   : 
; 66   : #ifdef DEBUG
; 67   :     NKDbgPrintfW(L"MinCryptVerifySignedHash() returned 0x%x\r\n", lResult);
; 68   : #endif 
; 69   : 
; 70   :     CBR(ERROR_SUCCESS == lResult);

  00050	13a03116	 movne       r3, #0x16, 2
  00054	13838901	 orrne       r8, r3, #1, 18
  00058		 |$Error$36813|

; 71   : 
; 72   : Error:
; 73   :     return hr;
; 74   : }

  00058	e1a00008	 mov         r0, r8
  0005c	e28dd014	 add         sp, sp, #0x14
  00060	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00064	e12fff1e	 bx          lr
  00068		 |$M36900|

			 ENDP  ; |?Verify@@YAJPBEK0KPAEK@Z|, Verify

	EXPORT	|SBL_VerifyPacket|
	IMPORT	|MinCryptGetHashParam|
	IMPORT	|MinCryptUpdateHashMemory|
	IMPORT	|MinCryptCreateHashMemory|

  00004			 AREA	 |.bss|, NOINIT
|bHash|	%	0x14
|gpbPublicKey| % 0x4
|gdwPublicKeyLen| % 0x4
|bHash|	%	0x14

  00000			 AREA	 |.pdata|, PDATA
|$T36957| DCD	|$LN52@SBL_Verify|
	DCD	0x4000aa02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SBL_VerifyPacket| PROC

; 82   : {

  00000		 |$LN52@SBL_Verify|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd024	 sub         sp, sp, #0x24
  00008		 |$M36954|
  00008	e1a09001	 mov         r9, r1
  0000c	e1a05000	 mov         r5, r0

; 83   :     
; 84   :     DWORD i, hHash, dwHashLen = 0;
; 85   :     HRESULT hr = S_OK;
; 86   :     LONG lReturn;
; 87   :     BOOL bVerified = FALSE;
; 88   :     CRYPT_DER_BLOB blob;
; 89   :     
; 90   :     lReturn = MinCryptCreateHashMemory(CALG_SHA1, &hHash);

  00010	e3a0b902	 mov         r11, #2, 18
  00014	e3a03000	 mov         r3, #0
  00018	e38b0004	 orr         r0, r11, #4
  0001c	e28d1004	 add         r1, sp, #4
  00020	e58d3008	 str         r3, [sp, #8]
  00024	e3a06000	 mov         r6, #0
  00028	eb000000	 bl          MinCryptCreateHashMemory
  0002c	e3500000	 cmp         r0, #0

; 91   :     CBR(ERROR_SUCCESS == lReturn);

  00030	1a000095	 bne         |$LN46@SBL_Verify|

; 92   :     
; 93   :     // See if this packet contains any data
; 94   :     // If so hash that data
; 95   :     
; 96   :     if (0 != pPacketData->dwDataLength) 

  00034	e5953004	 ldr         r3, [r5, #4]
  00038	e1b0e003	 movs        lr, r3
  0003c	0a000009	 beq         |$LN25@SBL_Verify|

; 97   :     {
; 98   :         blob.cbData = pPacketData->dwDataLength;
; 99   :         blob.pbData = const_cast <BYTE *> (pPacketData->pbData);

  00040	e5952000	 ldr         r2, [r5]

; 100  : 
; 101  :         lReturn = MinCryptUpdateHashMemory(CALG_SHA1, hHash, 1, &blob);

  00044	e59d1004	 ldr         r1, [sp, #4]
  00048	e28d300c	 add         r3, sp, #0xC
  0004c	e58d2010	 str         r2, [sp, #0x10]
  00050	e3a02001	 mov         r2, #1
  00054	e38b0004	 orr         r0, r11, #4
  00058	e58de00c	 str         lr, [sp, #0xC]
  0005c	eb000000	 bl          MinCryptUpdateHashMemory
  00060	e3500000	 cmp         r0, #0

; 185  :     
; 186  : Error:

  00064	1a000088	 bne         |$LN46@SBL_Verify|
  00068		 |$LN25@SBL_Verify|

; 102  :         CBR(ERROR_SUCCESS == lReturn);
; 103  :     }
; 104  : 
; 105  :     // Store RecAddress, RecLength, RecCheck in the hash
; 106  :     // Allows verification of these elements
; 107  : 
; 108  :     blob.cbData = sizeof(pPacketData->dwRecAddress);
; 109  :     blob.pbData = (BYTE *) &pPacketData->dwRecAddress;
; 110  :     lReturn = MinCryptUpdateHashMemory(CALG_SHA1, hHash, 1, &blob);

  00068	e59d1004	 ldr         r1, [sp, #4]
  0006c	e3a04004	 mov         r4, #4
  00070	e285e010	 add         lr, r5, #0x10
  00074	e28d300c	 add         r3, sp, #0xC
  00078	e3a02001	 mov         r2, #1
  0007c	e38b0004	 orr         r0, r11, #4
  00080	e58d400c	 str         r4, [sp, #0xC]
  00084	e58de010	 str         lr, [sp, #0x10]
  00088	eb000000	 bl          MinCryptUpdateHashMemory
  0008c	e3500000	 cmp         r0, #0

; 185  :     
; 186  : Error:

  00090	1a00007d	 bne         |$LN46@SBL_Verify|
  00094	e59d1004	 ldr         r1, [sp, #4]
  00098	e3a04004	 mov         r4, #4
  0009c	e285e014	 add         lr, r5, #0x14
  000a0	e28d300c	 add         r3, sp, #0xC
  000a4	e3a02001	 mov         r2, #1
  000a8	e38b0004	 orr         r0, r11, #4
  000ac	e58d400c	 str         r4, [sp, #0xC]
  000b0	e58de010	 str         lr, [sp, #0x10]
  000b4	eb000000	 bl          MinCryptUpdateHashMemory
  000b8	e3500000	 cmp         r0, #0
  000bc	1a000072	 bne         |$LN46@SBL_Verify|
  000c0	e59d1004	 ldr         r1, [sp, #4]
  000c4	e3a04004	 mov         r4, #4
  000c8	e285e018	 add         lr, r5, #0x18
  000cc	e28d300c	 add         r3, sp, #0xC
  000d0	e3a02001	 mov         r2, #1
  000d4	e38b0004	 orr         r0, r11, #4
  000d8	e58d400c	 str         r4, [sp, #0xC]
  000dc	e58de010	 str         lr, [sp, #0x10]
  000e0	eb000000	 bl          MinCryptUpdateHashMemory
  000e4	e3500000	 cmp         r0, #0
  000e8	1a000067	 bne         |$LN46@SBL_Verify|
  000ec	e59d1004	 ldr         r1, [sp, #4]
  000f0	e3a04001	 mov         r4, #1
  000f4	e285e030	 add         lr, r5, #0x30
  000f8	e28d300c	 add         r3, sp, #0xC
  000fc	e3a02001	 mov         r2, #1
  00100	e38b0004	 orr         r0, r11, #4
  00104	e58d400c	 str         r4, [sp, #0xC]
  00108	e58de010	 str         lr, [sp, #0x10]
  0010c	eb000000	 bl          MinCryptUpdateHashMemory
  00110	e3500000	 cmp         r0, #0
  00114	1a00005c	 bne         |$LN46@SBL_Verify|
  00118	e59d1004	 ldr         r1, [sp, #4]
  0011c	e3a04010	 mov         r4, #0x10
  00120	e285e01c	 add         lr, r5, #0x1C
  00124	e28d300c	 add         r3, sp, #0xC
  00128	e3a02001	 mov         r2, #1
  0012c	e38b0004	 orr         r0, r11, #4
  00130	e58d400c	 str         r4, [sp, #0xC]
  00134	e58de010	 str         lr, [sp, #0x10]
  00138	eb000000	 bl          MinCryptUpdateHashMemory
  0013c	e3500000	 cmp         r0, #0
  00140	1a000051	 bne         |$LN46@SBL_Verify|
  00144	e59d1004	 ldr         r1, [sp, #4]
  00148	e3a04004	 mov         r4, #4
  0014c	e285e02c	 add         lr, r5, #0x2C
  00150	e28d300c	 add         r3, sp, #0xC
  00154	e3a02001	 mov         r2, #1
  00158	e38b0004	 orr         r0, r11, #4
  0015c	e58d400c	 str         r4, [sp, #0xC]
  00160	e58de010	 str         lr, [sp, #0x10]
  00164	eb000000	 bl          MinCryptUpdateHashMemory
  00168	e3500000	 cmp         r0, #0
  0016c	1a000046	 bne         |$LN46@SBL_Verify|
  00170	e59f712c	 ldr         r7, [pc, #0x12C]
  00174	e59d1004	 ldr         r1, [sp, #4]
  00178	e28d3008	 add         r3, sp, #8
  0017c	e1a02007	 mov         r2, r7
  00180	e38b0004	 orr         r0, r11, #4
  00184	eb000000	 bl          MinCryptGetHashParam
  00188	e3500000	 cmp         r0, #0
  0018c	1a00003e	 bne         |$LN46@SBL_Verify|
  00190	e597301c	 ldr         r3, [r7, #0x1C]
  00194	e3530000	 cmp         r3, #0
  00198	1a000027	 bne         |$LN9@SBL_Verify|
  0019c	e1d980ba	 ldrh        r8, [r9, #0xA]
  001a0	e1d930bc	 ldrh        r3, [r9, #0xC]
  001a4	e1580003	 cmp         r8, r3
  001a8	8a000037	 bhi         |$LN46@SBL_Verify|

; 111  :     CBR(ERROR_SUCCESS == lReturn);
; 112  : 
; 113  :     blob.cbData = sizeof(pPacketData->dwRecLength);
; 114  :     blob.pbData = (BYTE *) &pPacketData->dwRecLength;
; 115  :     lReturn = MinCryptUpdateHashMemory(CALG_SHA1, hHash, 1, &blob);
; 116  :     CBR(ERROR_SUCCESS == lReturn);
; 117  : 
; 118  :     blob.cbData = sizeof(pPacketData->dwRecCheck);
; 119  :     blob.pbData = (BYTE *) &pPacketData->dwRecCheck;
; 120  :     lReturn = MinCryptUpdateHashMemory(CALG_SHA1, hHash, 1, &blob);
; 121  :     CBR(ERROR_SUCCESS == lReturn);
; 122  : 
; 123  :     blob.cbData = sizeof(pPacketData->bFlags);
; 124  :     blob.pbData = (BYTE *) &pPacketData->bFlags;
; 125  :     lReturn = MinCryptUpdateHashMemory(CALG_SHA1, hHash, 1, &blob);
; 126  :     CBR(ERROR_SUCCESS == lReturn);
; 127  : 
; 128  :     // Hash the global file random seed
; 129  : 
; 130  :     blob.cbData = RANDOM_SEED_LENGTH;
; 131  :     blob.pbData = (BYTE *) pPacketData->bRandomSeed;
; 132  :     lReturn = MinCryptUpdateHashMemory(CALG_SHA1, hHash, 1, &blob);
; 133  :     CBR(ERROR_SUCCESS == lReturn);
; 134  : 
; 135  :     // Hash the sequence number
; 136  : 
; 137  :     blob.cbData = sizeof(pPacketData->dwSequenceNumber);
; 138  :     blob.pbData = (BYTE *) &pPacketData->dwSequenceNumber;
; 139  :     lReturn = MinCryptUpdateHashMemory(CALG_SHA1, hHash, 1, &blob);
; 140  :     CBR(ERROR_SUCCESS == lReturn);
; 141  : 
; 142  :     lReturn = MinCryptGetHashParam(CALG_SHA1, hHash, bHash, &dwHashLen);
; 143  :     CBR(ERROR_SUCCESS == lReturn);
; 144  : 
; 145  : #ifdef DEBUG
; 146  :     NKDbgPrintfW(L"Hash = [");
; 147  :     for (i = 0; i < dwHashLen; i++)
; 148  :     {
; 149  :         NKDbgPrintfW(L"%x ", bHash[i]);
; 150  :     }
; 151  :     NKDbgPrintfW(L"]\r\n\r\n");
; 152  : #endif
; 153  : 
; 154  :     // This is an optimization. We could have many public keys and we don't know
; 155  :     // which one this image was signed with. However once we find one that works
; 156  :     // this will be the key that every packet is signed with so we don't have to
; 157  :     // search again. After finding a key that works just verify each packet with
; 158  :     // that key.
; 159  : 
; 160  :     if (!bFoundCorrectKey) 
; 161  :     {
; 162  :         for (i = pKeyData->wMinSearchIndex; i <= pKeyData->wMaxSearchIndex; i++) 

  001ac	e28da014	 add         r10, sp, #0x14
  001b0		 |$LL8@SBL_Verify|

; 163  :         {
; 164  :             bVerified = (S_OK == Verify(pPacketData->pbSig, pPacketData->dwSigLength, pKeyData->rgpbPublicKeys[i], pKeyData->rgdwKeyLengths[i], bHash, dwHashLen));

  001b0	e5993004	 ldr         r3, [r9, #4]
  001b4	e5992000	 ldr         r2, [r9]
  001b8	e595e00c	 ldr         lr, [r5, #0xC]
  001bc	e7933108	 ldr         r3, [r3, +r8, lsl #2]
  001c0	e7921108	 ldr         r1, [r2, +r8, lsl #2]
  001c4	e5954008	 ldr         r4, [r5, #8]
  001c8	e59d2008	 ldr         r2, [sp, #8]
  001cc	e58d3014	 str         r3, [sp, #0x14]
  001d0	e58d1018	 str         r1, [sp, #0x18]
  001d4	e28d301c	 add         r3, sp, #0x1C
  001d8	e1a01007	 mov         r1, r7
  001dc	e38b0004	 orr         r0, r11, #4
  001e0	e58de01c	 str         lr, [sp, #0x1C]
  001e4	e58d4020	 str         r4, [sp, #0x20]
  001e8	e58da000	 str         r10, [sp]
  001ec	eb000000	 bl          MinCryptVerifySignedHash

; 165  :             gpbPublicKey = pKeyData->rgpbPublicKeys[i];

  001f0	e5993000	 ldr         r3, [r9]

; 166  :             gdwPublicKeyLen = pKeyData->rgdwKeyLengths[i];

  001f4	e5992004	 ldr         r2, [r9, #4]
  001f8	e3500000	 cmp         r0, #0

; 167  :             
; 168  :             if (bVerified) 

  001fc	e7933108	 ldr         r3, [r3, +r8, lsl #2]
  00200	e7922108	 ldr         r2, [r2, +r8, lsl #2]
  00204	03a01001	 moveq       r1, #1
  00208	13a01000	 movne       r1, #0
  0020c	e5873014	 str         r3, [r7, #0x14]
  00210	e5872018	 str         r2, [r7, #0x18]
  00214		 |$Error$36918|
  00214	e3510000	 cmp         r1, #0
  00218	1a000004	 bne         |$LN47@SBL_Verify|
  0021c	e1d930bc	 ldrh        r3, [r9, #0xC]
  00220	e2888001	 add         r8, r8, #1
  00224	e1580003	 cmp         r8, r3
  00228	9affffe0	 bls         |$LL8@SBL_Verify|

; 169  :             {
; 170  :                 break;
; 171  :             }
; 172  :         }
; 173  : 
; 174  :         if (bVerified) 

  0022c	ea000016	 b           |$LN46@SBL_Verify|
  00230		 |$LN47@SBL_Verify|

; 175  :         {
; 176  :             bFoundCorrectKey = TRUE;

  00230	e3a03001	 mov         r3, #1
  00234	e587301c	 str         r3, [r7, #0x1C]

; 177  :         }
; 178  :     } 
; 179  :     else 

  00238	ea000011	 b           |$LN34@SBL_Verify|
  0023c		 |$LN9@SBL_Verify|

; 180  :     {
; 181  :         bVerified = (S_OK == Verify(pPacketData->pbSig, pPacketData->dwSigLength, gpbPublicKey, gdwPublicKeyLen, bHash, dwHashLen));

  0023c	e595300c	 ldr         r3, [r5, #0xC]
  00240	e5950008	 ldr         r0, [r5, #8]
  00244	e597e018	 ldr         lr, [r7, #0x18]
  00248	e5974014	 ldr         r4, [r7, #0x14]
  0024c	e59d2008	 ldr         r2, [sp, #8]
  00250	e58d3014	 str         r3, [sp, #0x14]
  00254	e58d0018	 str         r0, [sp, #0x18]
  00258	e28d501c	 add         r5, sp, #0x1C
  0025c	e28d3014	 add         r3, sp, #0x14
  00260	e38b0004	 orr         r0, r11, #4
  00264	e1a01007	 mov         r1, r7
  00268	e58de01c	 str         lr, [sp, #0x1C]
  0026c	e58d4020	 str         r4, [sp, #0x20]
  00270	e58d5000	 str         r5, [sp]
  00274	eb000000	 bl          MinCryptVerifySignedHash
  00278	e3500000	 cmp         r0, #0
  0027c	0a000004	 beq         |$Error$36829|
  00280		 |$Error$36933|
  00280	e3a01000	 mov         r1, #0
  00284		 |$LN34@SBL_Verify|

; 182  :     }
; 183  : 
; 184  :     CBR(bVerified);

  00284	e3510000	 cmp         r1, #0
  00288	1a000001	 bne         |$Error$36829|
  0028c		 |$LN46@SBL_Verify|
  0028c	e3a03116	 mov         r3, #0x16, 2
  00290	e3836901	 orr         r6, r3, #1, 18
  00294		 |$Error$36829|

; 187  :     return hr;
; 188  : }

  00294	e1a00006	 mov         r0, r6
  00298	e28dd024	 add         sp, sp, #0x24
  0029c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  002a0	e12fff1e	 bx          lr
  002a4		 |$LN53@SBL_Verify|
  002a4		 |$LN54@SBL_Verify|
  002a4	00000000	 DCD         |bHash|
  002a8		 |$M36955|

			 ENDP  ; |SBL_VerifyPacket|

	END
