; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\COMMON\KITL\registry.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|??_C@_0BC@EPFFAFOO@?9?5RegisterKITL?5?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EE@PDFCDEEO@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAB?$AAu?$AAi?$AAl?$AAt?$AAI?$AAn?$AA?2?$AAP?$AAC?$AAI?$AA?2?$AAI?$AAn?$AAs?$AAt?$AAa?$AAn?$AAc?$AAe?$AA?2?$AAK?$AAI?$AAT@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BC@EBCJLJGL@?$CL?5RegisterKITL?5?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|RegisterKITL|
	IMPORT	|PCIReg|
	IMPORT	|PCIInitInfo|
	IMPORT	|OALPCICfgRead|
	IMPORT	|OALKitlGetDevLoc|
	IMPORT	|KITLOutputDebugString|
	IMPORT	|dpCurSettings|
	IMPORT	|__security_cookie|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|memcpy|
	IMPORT	|__security_check_cookie|

  00000			 AREA	 |.pdata|, PDATA
|$T43166| DCD	|$LN9@RegisterKI|
	DCD	0xc0004402
; File c:\wince600\platform\common\src\common\kitl\registry.c

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BC@EPFFAFOO@?9?5RegisterKITL?5?$AN?6?$AA@| DCB "- RegisterKITL ", 0xd
	DCB	0xa, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EE@PDFCDEEO@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAB?$AAu?$AAi?$AAl?$AAt?$AAI?$AAn?$AA?2?$AAP?$AAC?$AAI?$AA?2?$AAI?$AAn?$AAs?$AAt?$AAa?$AAn?$AAc?$AAe?$AA?2?$AAK?$AAI?$AAT@| DCB "D"
	DCB	0x0, "r", 0x0, "i", 0x0, "v", 0x0, "e", 0x0, "r", 0x0, "s"
	DCB	0x0, "\\", 0x0, "B", 0x0, "u", 0x0, "i", 0x0, "l", 0x0, "t"
	DCB	0x0, "I", 0x0, "n", 0x0, "\\", 0x0, "P", 0x0, "C", 0x0, "I"
	DCB	0x0, "\\", 0x0, "I", 0x0, "n", 0x0, "s", 0x0, "t", 0x0, "a"
	DCB	0x0, "n", 0x0, "c", 0x0, "e", 0x0, "\\", 0x0, "K", 0x0, "I"
	DCB	0x0, "T", 0x0, "L", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BC@EBCJLJGL@?$CL?5RegisterKITL?5?$AN?6?$AA@| DCB "+ RegisterKITL "
	DCB	0xd, 0xa, 0x0				; `string'

  00000			 AREA	 |.xdata|, DATA
|$T43162| DCD	0xffffffe0
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T43162|

  00008		 |RegisterKITL| PROC

; 137  : {

  00008		 |$LN9@RegisterKI|
  00008	e52de004	 str         lr, [sp, #-4]!
  0000c	e24ddd13	 sub         sp, sp, #0x13, 26
  00010		 |$M43163|
  00010	e59f30fc	 ldr         r3, [pc, #0xFC]
  00014	e5933000	 ldr         r3, [r3]
  00018	e58d34a4	 str         r3, [sp, #0x4A4]

; 138  : 
; 139  :     PCI_REG_INFO KitlPCIInfo;
; 140  :     DEVICE_LOCATION devLoc;
; 141  : 
; 142  :     PCI_COMMON_CONFIG pciCfg;
; 143  :     OAL_PCI_LOCATION pciLoc;
; 144  : 
; 145  :     KITL_RETAILMSG(ZONE_KITL_OAL, ("+ RegisterKITL \r\n"));

  0001c	e59f30e4	 ldr         r3, [pc, #0xE4]
  00020	e5933440	 ldr         r3, [r3, #0x440]
  00024	e3130a01	 tst         r3, #1, 20
  00028	0a000004	 beq         |$LN3@RegisterKI|
  0002c	e59f00dc	 ldr         r0, [pc, #0xDC]
  00030	eb000000	 bl          KITLOutputDebugString
  00034	e3a03001	 mov         r3, #1
  00038	e58d34b8	 str         r3, [sp, #0x4B8]
  0003c	ea000001	 b           |$LN4@RegisterKI|
  00040		 |$LN3@RegisterKI|
  00040	e3a03000	 mov         r3, #0
  00044	e58d34b8	 str         r3, [sp, #0x4B8]
  00048		 |$LN4@RegisterKI|

; 146  : 
; 147  :     OALKitlGetDevLoc(&devLoc);

  00048	e28d0e49	 add         r0, sp, #0x49, 28
  0004c	eb000000	 bl          OALKitlGetDevLoc

; 148  :     pciLoc = *(OAL_PCI_LOCATION*)&devLoc.LogicalLoc;

  00050	e28d000c	 add         r0, sp, #0xC
  00054	e3a01b01	 mov         r1, #1, 22
  00058	e3811098	 orr         r1, r1, #0x98
  0005c	e08d1001	 add         r1, sp, r1
  00060	e3a02004	 mov         r2, #4
  00064	eb000000	 bl          memcpy

; 149  : 
; 150  :     // First read all device configuration space
; 151  :     OALPCICfgRead(devLoc.BusNumber, pciLoc, 0, sizeof(pciCfg), &pciCfg);

  00068	e28d3e39	 add         r3, sp, #0x39, 28
  0006c	e58d3000	 str         r3, [sp]
  00070	e3a03c01	 mov         r3, #1, 24
  00074	e3a02000	 mov         r2, #0
  00078	e59d100c	 ldr         r1, [sp, #0xC]
  0007c	e59d0494	 ldr         r0, [sp, #0x494]
  00080	eb000000	 bl          OALPCICfgRead

; 152  : 
; 153  : 
; 154  :     // Fill info structure
; 155  :     PCIInitInfo(
; 156  :        L"Drivers\\BuiltIn\\PCI\\Instance\\KITL", pciLoc.bus, pciLoc.dev, 
; 157  :        pciLoc.fnc, pciCfg.u.type0.InterruptLine, &pciCfg, &KitlPCIInfo
; 158  :     );

  00084	e28d3010	 add         r3, sp, #0x10
  00088	e58d3008	 str         r3, [sp, #8]
  0008c	e28d3e39	 add         r3, sp, #0x39, 28
  00090	e58d3004	 str         r3, [sp, #4]
  00094	e5dd33cc	 ldrb        r3, [sp, #0x3CC]
  00098	e58d3000	 str         r3, [sp]
  0009c	e5dd300c	 ldrb        r3, [sp, #0xC]
  000a0	e5dd200d	 ldrb        r2, [sp, #0xD]
  000a4	e5dd100e	 ldrb        r1, [sp, #0xE]
  000a8	e59f005c	 ldr         r0, [pc, #0x5C]
  000ac	eb000000	 bl          PCIInitInfo

; 159  : 
; 160  :     PCIReadBARs(devLoc.BusNumber, &KitlPCIInfo);

  000b0	e28d1010	 add         r1, sp, #0x10
  000b4	e59d0494	 ldr         r0, [sp, #0x494]
  000b8	eb000000	 bl          PCIReadBARs

; 161  :     PCIReg(&KitlPCIInfo);

  000bc	e28d0010	 add         r0, sp, #0x10
  000c0	eb000000	 bl          PCIReg

; 162  :     KITL_RETAILMSG(ZONE_KITL_OAL, ("- RegisterKITL \r\n"));

  000c4	e59f303c	 ldr         r3, [pc, #0x3C]
  000c8	e5933440	 ldr         r3, [r3, #0x440]
  000cc	e3130a01	 tst         r3, #1, 20
  000d0	0a000004	 beq         |$LN5@RegisterKI|
  000d4	e59f0028	 ldr         r0, [pc, #0x28]
  000d8	eb000000	 bl          KITLOutputDebugString
  000dc	e3a03001	 mov         r3, #1
  000e0	e58d34bc	 str         r3, [sp, #0x4BC]
  000e4	ea000001	 b           |$LN6@RegisterKI|
  000e8		 |$LN5@RegisterKI|
  000e8	e3a03000	 mov         r3, #0
  000ec	e58d34bc	 str         r3, [sp, #0x4BC]
  000f0		 |$LN6@RegisterKI|

; 137  : {

  000f0	e59d04a4	 ldr         r0, [sp, #0x4A4]
  000f4	eb000000	 bl          __security_check_cookie

; 163  : 
; 164  : }

  000f8	e28ddd13	 add         sp, sp, #0x13, 26
  000fc	e49de004	 ldr         lr, [sp], #4
  00100	e12fff1e	 bx          lr
  00104		 |$LN10@RegisterKI|
  00104		 |$LN11@RegisterKI|
  00104	00000000	 DCD         |??_C@_0BC@EPFFAFOO@?9?5RegisterKITL?5?$AN?6?$AA@|
  00108		 |$LN12@RegisterKI|
  00108	00000000	 DCD         |dpCurSettings|
  0010c		 |$LN13@RegisterKI|
  0010c	00000000	 DCD         |??_C@_1EE@PDFCDEEO@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAB?$AAu?$AAi?$AAl?$AAt?$AAI?$AAn?$AA?2?$AAP?$AAC?$AAI?$AA?2?$AAI?$AAn?$AAs?$AAt?$AAa?$AAn?$AAc?$AAe?$AA?2?$AAK?$AAI?$AAT@|
  00110		 |$LN14@RegisterKI|
  00110	00000000	 DCD         |??_C@_0BC@EBCJLJGL@?$CL?5RegisterKITL?5?$AN?6?$AA@|
  00114		 |$LN15@RegisterKI|
  00114	00000000	 DCD         |__security_cookie|
  00118		 |$M43164|

			 ENDP  ; |RegisterKITL|

	IMPORT	|OALPCICfgWrite|

  00008			 AREA	 |.pdata|, PDATA
|$T43181| DCD	|$LN22@PCIReadBAR|
	DCD	0x4000fb04
; Function compile flags: /Odtp

  00118			 AREA	 |.text|, CODE, ARM

  00118		 |PCIReadBARs| PROC

; 36   : {   

  00118		 |$LN22@PCIReadBAR|
  00118	e1a0c00d	 mov         r12, sp
  0011c	e92d0003	 stmdb       sp!, {r0, r1}
  00120	e92d5000	 stmdb       sp!, {r12, lr}
  00124	e24dd03c	 sub         sp, sp, #0x3C
  00128		 |$M43178|

; 37   :     DWORD NumberOfRegs;
; 38   :     DWORD Offset;
; 39   :     DWORD i;
; 40   :     DWORD BaseAddress;
; 41   :     DWORD Size;
; 42   :     DWORD Reg;
; 43   :     DWORD IoIndex = 0;

  00128	e3a03000	 mov         r3, #0
  0012c	e58d3014	 str         r3, [sp, #0x14]

; 44   :     DWORD MemIndex = 0;

  00130	e3a03000	 mov         r3, #0
  00134	e58d3018	 str         r3, [sp, #0x18]

; 45   :     OAL_PCI_LOCATION pciLoc;
; 46   :     pciLoc.fnc = (UINT8)pInfo->Function;

  00138	e59d3048	 ldr         r3, [sp, #0x48]
  0013c	e2833f82	 add         r3, r3, #0x82, 30
  00140	e5933000	 ldr         r3, [r3]
  00144	e20330ff	 and         r3, r3, #0xFF
  00148	e5cd3004	 strb        r3, [sp, #4]

; 47   :     pciLoc.dev = (UINT8)pInfo->Device;

  0014c	e59d3048	 ldr         r3, [sp, #0x48]
  00150	e2833f81	 add         r3, r3, #0x81, 30
  00154	e5933000	 ldr         r3, [r3]
  00158	e20330ff	 and         r3, r3, #0xFF
  0015c	e5cd3005	 strb        r3, [sp, #5]

; 48   :     pciLoc.bus = (UINT8)pInfo->Bus;

  00160	e59d3048	 ldr         r3, [sp, #0x48]
  00164	e2833c02	 add         r3, r3, #2, 24
  00168	e5933000	 ldr         r3, [r3]
  0016c	e20330ff	 and         r3, r3, #0xFF
  00170	e5cd3006	 strb        r3, [sp, #6]

; 49   :     busNumber >>= 8; // bits 8-15 are host-to-PCI-bridge bus number

  00174	e59d3044	 ldr         r3, [sp, #0x44]
  00178	e1a03423	 mov         r3, r3, lsr #8
  0017c	e58d3044	 str         r3, [sp, #0x44]

; 50   : 
; 51   :     // Determine number of BARs to examine from header type
; 52   :     switch (pInfo->Cfg.HeaderType & ~PCI_MULTIFUNCTION) {

  00180	e59d3048	 ldr         r3, [sp, #0x48]
  00184	e2833c02	 add         r3, r3, #2, 24
  00188	e283301a	 add         r3, r3, #0x1A
  0018c	e5d33000	 ldrb        r3, [r3]
  00190	e1a02003	 mov         r2, r3
  00194	e3e03080	 mvn         r3, #0x80
  00198	e0023003	 and         r3, r2, r3
  0019c	e58d3038	 str         r3, [sp, #0x38]
  001a0	e59d3038	 ldr         r3, [sp, #0x38]
  001a4	e3530000	 cmp         r3, #0
  001a8	0a000006	 beq         |$LN15@PCIReadBAR|
  001ac	e59d3038	 ldr         r3, [sp, #0x38]
  001b0	e3530001	 cmp         r3, #1
  001b4	0a000006	 beq         |$LN14@PCIReadBAR|
  001b8	e59d3038	 ldr         r3, [sp, #0x38]
  001bc	e3530002	 cmp         r3, #2
  001c0	0a000006	 beq         |$LN13@PCIReadBAR|
  001c4	ea000008	 b           |$LN12@PCIReadBAR|
  001c8		 |$LN15@PCIReadBAR|

; 53   :     case PCI_DEVICE_TYPE:
; 54   :         NumberOfRegs = PCI_TYPE0_ADDRESSES;

  001c8	e3a03006	 mov         r3, #6
  001cc	e58d3024	 str         r3, [sp, #0x24]

; 55   :         break;

  001d0	ea000008	 b           |$LN16@PCIReadBAR|
  001d4		 |$LN14@PCIReadBAR|

; 56   : 
; 57   :     case PCI_BRIDGE_TYPE:
; 58   :         NumberOfRegs = PCI_TYPE1_ADDRESSES;

  001d4	e3a03002	 mov         r3, #2
  001d8	e58d3024	 str         r3, [sp, #0x24]

; 59   :         break;

  001dc	ea000005	 b           |$LN16@PCIReadBAR|
  001e0		 |$LN13@PCIReadBAR|

; 60   : 
; 61   :     case PCI_CARDBUS_TYPE:
; 62   :         NumberOfRegs = PCI_TYPE2_ADDRESSES;

  001e0	e3a03001	 mov         r3, #1
  001e4	e58d3024	 str         r3, [sp, #0x24]

; 63   :         break;

  001e8	ea000002	 b           |$LN16@PCIReadBAR|
  001ec		 |$LN12@PCIReadBAR|

; 64   : 
; 65   :     default:
; 66   :         return FALSE;

  001ec	e3a03000	 mov         r3, #0
  001f0	e58d3028	 str         r3, [sp, #0x28]
  001f4	ea0000be	 b           |$LN18@PCIReadBAR|
  001f8		 |$LN16@PCIReadBAR|

; 67   :     }
; 68   :         
; 69   :     for (i = 0, Offset = 0x10; i < NumberOfRegs; i++, Offset += 4) {

  001f8	e3a03000	 mov         r3, #0
  001fc	e58d3010	 str         r3, [sp, #0x10]
  00200	e3a03010	 mov         r3, #0x10
  00204	e58d3008	 str         r3, [sp, #8]
  00208	ea000005	 b           |$LN11@PCIReadBAR|
  0020c		 |$LN10@PCIReadBAR|
  0020c	e59d3010	 ldr         r3, [sp, #0x10]
  00210	e2833001	 add         r3, r3, #1
  00214	e58d3010	 str         r3, [sp, #0x10]
  00218	e59d3008	 ldr         r3, [sp, #8]
  0021c	e2833004	 add         r3, r3, #4
  00220	e58d3008	 str         r3, [sp, #8]
  00224		 |$LN11@PCIReadBAR|
  00224	e59d2010	 ldr         r2, [sp, #0x10]
  00228	e59d3024	 ldr         r3, [sp, #0x24]
  0022c	e1520003	 cmp         r2, r3
  00230	2a0000ad	 bcs         |$LN9@PCIReadBAR|

; 70   :         // Get base address register value
; 71   :         Reg = pInfo->Cfg.u.type0.BaseAddresses[i];

  00234	e59d3048	 ldr         r3, [sp, #0x48]
  00238	e2831f87	 add         r1, r3, #0x87, 30
  0023c	e59d2010	 ldr         r2, [sp, #0x10]
  00240	e3a03004	 mov         r3, #4
  00244	e0030392	 mul         r3, r2, r3
  00248	e0813003	 add         r3, r1, r3
  0024c	e5933000	 ldr         r3, [r3]
  00250	e58d301c	 str         r3, [sp, #0x1C]

; 72   : 
; 73   :         // Get size info
; 74   :         BaseAddress = 0xFFFFFFFF;

  00254	e3e03000	 mvn         r3, #0
  00258	e58d3020	 str         r3, [sp, #0x20]

; 75   :         OALPCICfgWrite(busNumber, pciLoc, Offset, sizeof(BaseAddress), &BaseAddress);

  0025c	e28d3020	 add         r3, sp, #0x20
  00260	e58d3000	 str         r3, [sp]
  00264	e3a03004	 mov         r3, #4
  00268	e59d2008	 ldr         r2, [sp, #8]
  0026c	e59d1004	 ldr         r1, [sp, #4]
  00270	e59d0044	 ldr         r0, [sp, #0x44]
  00274	eb000000	 bl          OALPCICfgWrite

; 76   :         OALPCICfgRead(busNumber, pciLoc, Offset, sizeof(BaseAddress), &BaseAddress);

  00278	e28d3020	 add         r3, sp, #0x20
  0027c	e58d3000	 str         r3, [sp]
  00280	e3a03004	 mov         r3, #4
  00284	e59d2008	 ldr         r2, [sp, #8]
  00288	e59d1004	 ldr         r1, [sp, #4]
  0028c	e59d0044	 ldr         r0, [sp, #0x44]
  00290	eb000000	 bl          OALPCICfgRead

; 77   :         OALPCICfgWrite(busNumber, pciLoc, Offset, sizeof(Reg), &Reg);

  00294	e28d301c	 add         r3, sp, #0x1C
  00298	e58d3000	 str         r3, [sp]
  0029c	e3a03004	 mov         r3, #4
  002a0	e59d2008	 ldr         r2, [sp, #8]
  002a4	e59d1004	 ldr         r1, [sp, #4]
  002a8	e59d0044	 ldr         r0, [sp, #0x44]
  002ac	eb000000	 bl          OALPCICfgWrite

; 78   : 
; 79   :         // Re-adjust BaseAddress if upper 16-bits are 0 (this happens on some devices that don't follow
; 80   :         // the PCI spec, like the Intel UHCI controllers)
; 81   :         if (((BaseAddress & 0xFFFFFFFC) != 0) && ((BaseAddress & 0xFFFF0000) == 0)) {

  002b0	e59d2020	 ldr         r2, [sp, #0x20]
  002b4	e3e03003	 mvn         r3, #3
  002b8	e1120003	 tst         r2, r3
  002bc	0a000009	 beq         |$LN8@PCIReadBAR|
  002c0	e59d2020	 ldr         r2, [sp, #0x20]
  002c4	e3e03cff	 mvn         r3, #0xFF, 24
  002c8	e22330ff	 eor         r3, r3, #0xFF
  002cc	e1120003	 tst         r2, r3
  002d0	1a000004	 bne         |$LN8@PCIReadBAR|

; 82   :             BaseAddress |= 0xFFFF0000;

  002d4	e59d2020	 ldr         r2, [sp, #0x20]
  002d8	e3e03cff	 mvn         r3, #0xFF, 24
  002dc	e22330ff	 eor         r3, r3, #0xFF
  002e0	e1823003	 orr         r3, r2, r3
  002e4	e58d3020	 str         r3, [sp, #0x20]
  002e8		 |$LN8@PCIReadBAR|

; 83   :         }
; 84   :         
; 85   :         if (Reg & 1) {

  002e8	e59d301c	 ldr         r3, [sp, #0x1C]
  002ec	e3130001	 tst         r3, #1
  002f0	0a000036	 beq         |$LN7@PCIReadBAR|

; 86   :             // IO space
; 87   :             Size = ~(BaseAddress & 0xFFFFFFFC);

  002f4	e59d2020	 ldr         r2, [sp, #0x20]
  002f8	e3e03003	 mvn         r3, #3
  002fc	e0023003	 and         r3, r2, r3
  00300	e1e03003	 mvn         r3, r3
  00304	e58d300c	 str         r3, [sp, #0xC]

; 88   : 
; 89   :             if ((BaseAddress != 0) && (BaseAddress != 0xFFFFFFFF) && (((Size + 1) & Size) == 0)) {

  00308	e59d3020	 ldr         r3, [sp, #0x20]
  0030c	e3530000	 cmp         r3, #0
  00310	0a00002c	 beq         |$LN6@PCIReadBAR|
  00314	e59d3020	 ldr         r3, [sp, #0x20]
  00318	e3730001	 cmn         r3, #1
  0031c	0a000029	 beq         |$LN6@PCIReadBAR|
  00320	e59d300c	 ldr         r3, [sp, #0xC]
  00324	e2832001	 add         r2, r3, #1
  00328	e59d300c	 ldr         r3, [sp, #0xC]
  0032c	e1120003	 tst         r2, r3
  00330	1a000024	 bne         |$LN6@PCIReadBAR|

; 90   :                 // BAR has valid format (consecutive high 1's and consecutive low 0's)
; 91   :                 pInfo->IoLen.Reg[IoIndex] = Size + 1;

  00334	e59d300c	 ldr         r3, [sp, #0xC]
  00338	e2830001	 add         r0, r3, #1
  0033c	e59d3048	 ldr         r3, [sp, #0x48]
  00340	e2831fd9	 add         r1, r3, #0xD9, 30
  00344	e59d2014	 ldr         r2, [sp, #0x14]
  00348	e3a03004	 mov         r3, #4
  0034c	e0030392	 mul         r3, r2, r3
  00350	e0813003	 add         r3, r1, r3
  00354	e5830000	 str         r0, [r3]

; 92   :                 pInfo->IoLen.Num++;

  00358	e59d3048	 ldr         r3, [sp, #0x48]
  0035c	e2833e36	 add         r3, r3, #0x36, 28
  00360	e5933000	 ldr         r3, [r3]
  00364	e2832001	 add         r2, r3, #1
  00368	e59d3048	 ldr         r3, [sp, #0x48]
  0036c	e2833e36	 add         r3, r3, #0x36, 28
  00370	e5832000	 str         r2, [r3]

; 93   :                 pInfo->IoBase.Reg[IoIndex++] = Reg & 0xFFFFFFFC;

  00374	e59d201c	 ldr         r2, [sp, #0x1C]
  00378	e3e03003	 mvn         r3, #3
  0037c	e0020003	 and         r0, r2, r3
  00380	e59d3048	 ldr         r3, [sp, #0x48]
  00384	e2831fd2	 add         r1, r3, #0xD2, 30
  00388	e59d2014	 ldr         r2, [sp, #0x14]
  0038c	e3a03004	 mov         r3, #4
  00390	e0030392	 mul         r3, r2, r3
  00394	e0813003	 add         r3, r1, r3
  00398	e5830000	 str         r0, [r3]
  0039c	e59d3014	 ldr         r3, [sp, #0x14]
  003a0	e2833001	 add         r3, r3, #1
  003a4	e58d3014	 str         r3, [sp, #0x14]

; 94   :                 pInfo->IoBase.Num++;

  003a8	e59d3048	 ldr         r3, [sp, #0x48]
  003ac	e2833fd1	 add         r3, r3, #0xD1, 30
  003b0	e5933000	 ldr         r3, [r3]
  003b4	e2832001	 add         r2, r3, #1
  003b8	e59d3048	 ldr         r3, [sp, #0x48]
  003bc	e2833fd1	 add         r3, r3, #0xD1, 30
  003c0	e5832000	 str         r2, [r3]

; 95   :             } else {

  003c4	ea000000	 b           |$LN5@PCIReadBAR|
  003c8		 |$LN6@PCIReadBAR|

; 96   :                 // BAR invalid => skip to next one
; 97   :                 continue;

  003c8	eaffff8f	 b           |$LN10@PCIReadBAR|
  003cc		 |$LN5@PCIReadBAR|

; 98   :             }
; 99   :         } else {

  003cc	ea000035	 b           |$LN4@PCIReadBAR|
  003d0		 |$LN7@PCIReadBAR|

; 100  :             // Memory space
; 101  :             // TODO: don't properly handle the MEM20 case
; 102  :             Size = ~(BaseAddress & 0xFFFFFFF0);

  003d0	e59d2020	 ldr         r2, [sp, #0x20]
  003d4	e3e0300f	 mvn         r3, #0xF
  003d8	e0023003	 and         r3, r2, r3
  003dc	e1e03003	 mvn         r3, r3
  003e0	e58d300c	 str         r3, [sp, #0xC]

; 103  :             
; 104  :             if ((BaseAddress != 0) && (BaseAddress != 0xFFFFFFFF) && (((Size + 1) & Size) == 0)) {

  003e4	e59d3020	 ldr         r3, [sp, #0x20]
  003e8	e3530000	 cmp         r3, #0
  003ec	0a00002c	 beq         |$LN3@PCIReadBAR|
  003f0	e59d3020	 ldr         r3, [sp, #0x20]
  003f4	e3730001	 cmn         r3, #1
  003f8	0a000029	 beq         |$LN3@PCIReadBAR|
  003fc	e59d300c	 ldr         r3, [sp, #0xC]
  00400	e2832001	 add         r2, r3, #1
  00404	e59d300c	 ldr         r3, [sp, #0xC]
  00408	e1120003	 tst         r2, r3
  0040c	1a000024	 bne         |$LN3@PCIReadBAR|

; 105  :                 // BAR has valid format (consecutive high 1's and consecutive low 0's)
; 106  :                 pInfo->MemLen.Reg[MemIndex] = Size + 1;

  00410	e59d300c	 ldr         r3, [sp, #0xC]
  00414	e2830001	 add         r0, r3, #1
  00418	e59d3048	 ldr         r3, [sp, #0x48]
  0041c	e2831fcb	 add         r1, r3, #0xCB, 30
  00420	e59d2018	 ldr         r2, [sp, #0x18]
  00424	e3a03004	 mov         r3, #4
  00428	e0030392	 mul         r3, r2, r3
  0042c	e0813003	 add         r3, r1, r3
  00430	e5830000	 str         r0, [r3]

; 107  :                 pInfo->MemLen.Num++;

  00434	e59d3048	 ldr         r3, [sp, #0x48]
  00438	e2833fca	 add         r3, r3, #0xCA, 30
  0043c	e5933000	 ldr         r3, [r3]
  00440	e2832001	 add         r2, r3, #1
  00444	e59d3048	 ldr         r3, [sp, #0x48]
  00448	e2833fca	 add         r3, r3, #0xCA, 30
  0044c	e5832000	 str         r2, [r3]

; 108  :                 pInfo->MemBase.Reg[MemIndex++] = Reg & 0xFFFFFFF0;

  00450	e59d201c	 ldr         r2, [sp, #0x1C]
  00454	e3e0300f	 mvn         r3, #0xF
  00458	e0020003	 and         r0, r2, r3
  0045c	e59d3048	 ldr         r3, [sp, #0x48]
  00460	e2831e31	 add         r1, r3, #0x31, 28
  00464	e59d2018	 ldr         r2, [sp, #0x18]
  00468	e3a03004	 mov         r3, #4
  0046c	e0030392	 mul         r3, r2, r3
  00470	e0813003	 add         r3, r1, r3
  00474	e5830000	 str         r0, [r3]
  00478	e59d3018	 ldr         r3, [sp, #0x18]
  0047c	e2833001	 add         r3, r3, #1
  00480	e58d3018	 str         r3, [sp, #0x18]

; 109  :                 pInfo->MemBase.Num++;

  00484	e59d3048	 ldr         r3, [sp, #0x48]
  00488	e2833fc3	 add         r3, r3, #0xC3, 30
  0048c	e5933000	 ldr         r3, [r3]
  00490	e2832001	 add         r2, r3, #1
  00494	e59d3048	 ldr         r3, [sp, #0x48]
  00498	e2833fc3	 add         r3, r3, #0xC3, 30
  0049c	e5832000	 str         r2, [r3]

; 110  :             } else {

  004a0	ea000000	 b           |$LN2@PCIReadBAR|
  004a4		 |$LN3@PCIReadBAR|

; 111  :                 // BAR invalid => skip to next one
; 112  :                 continue;

  004a4	eaffff58	 b           |$LN10@PCIReadBAR|
  004a8		 |$LN2@PCIReadBAR|
  004a8		 |$LN4@PCIReadBAR|

; 113  :             }
; 114  :         }
; 115  : 
; 116  :         //
; 117  :         // check for 64 bit device - BAR is twice as big
; 118  :         //
; 119  :         if ((pInfo->Cfg.u.type0.BaseAddresses[i] & 0x7) == 0x4) {

  004a8	e59d3048	 ldr         r3, [sp, #0x48]
  004ac	e2831f87	 add         r1, r3, #0x87, 30
  004b0	e59d2010	 ldr         r2, [sp, #0x10]
  004b4	e3a03004	 mov         r3, #4
  004b8	e0030392	 mul         r3, r2, r3
  004bc	e0813003	 add         r3, r1, r3
  004c0	e5933000	 ldr         r3, [r3]
  004c4	e2033007	 and         r3, r3, #7
  004c8	e3530004	 cmp         r3, #4
  004cc	1a000005	 bne         |$LN1@PCIReadBAR|

; 120  :             // 64 bit device - BAR is twice as wide - zero out high part
; 121  :             Offset += 4;

  004d0	e59d3008	 ldr         r3, [sp, #8]
  004d4	e2833004	 add         r3, r3, #4
  004d8	e58d3008	 str         r3, [sp, #8]

; 122  :             i++;

  004dc	e59d3010	 ldr         r3, [sp, #0x10]
  004e0	e2833001	 add         r3, r3, #1
  004e4	e58d3010	 str         r3, [sp, #0x10]
  004e8		 |$LN1@PCIReadBAR|

; 123  :         }
; 124  :     }

  004e8	eaffff47	 b           |$LN10@PCIReadBAR|
  004ec		 |$LN9@PCIReadBAR|

; 125  : 
; 126  :     return TRUE;

  004ec	e3a03001	 mov         r3, #1
  004f0	e58d3028	 str         r3, [sp, #0x28]
  004f4		 |$LN18@PCIReadBAR|

; 127  : }

  004f4	e59d0028	 ldr         r0, [sp, #0x28]
  004f8	e28dd03c	 add         sp, sp, #0x3C
  004fc	e89d6000	 ldmia       sp, {sp, lr}
  00500	e12fff1e	 bx          lr
  00504		 |$M43179|

			 ENDP  ; |PCIReadBARs|

	EXPORT	|??_C@_0BH@GBJLCFLG@?9OALKitlInitRegistry?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BH@IMFBFHMM@?$CLOALKitlInitRegistry?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|OALKitlInitRegistry|

  00010			 AREA	 |.pdata|, PDATA
|$T43190| DCD	|$LN13@OALKitlIni|
	DCD	0x40002a02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BH@GBJLCFLG@?9OALKitlInitRegistry?$AN?6?$AA@| DCB "-OALKitlInitRe"
	DCB	"gistry", 0xd, 0xa, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BH@IMFBFHMM@?$CLOALKitlInitRegistry?$AN?6?$AA@| DCB "+OALKitlInit"
	DCB	"Registry", 0xd, 0xa, 0x0		; `string'
; Function compile flags: /Odtp

  00504			 AREA	 |.text|, CODE, ARM

  00504		 |OALKitlInitRegistry| PROC

; 181  : {

  00504		 |$LN13@OALKitlIni|
  00504	e52de004	 str         lr, [sp, #-4]!
  00508	e24dd020	 sub         sp, sp, #0x20
  0050c		 |$M43187|

; 182  :     DEVICE_LOCATION devLoc;
; 183  :     
; 184  :     KITL_RETAILMSG(ZONE_KITL_OAL, ("+OALKitlInitRegistry\r\n"));

  0050c	e59f3090	 ldr         r3, [pc, #0x90]
  00510	e5933440	 ldr         r3, [r3, #0x440]
  00514	e3130a01	 tst         r3, #1, 20
  00518	0a000004	 beq         |$LN7@OALKitlIni|
  0051c	e59f0084	 ldr         r0, [pc, #0x84]
  00520	eb000000	 bl          KITLOutputDebugString
  00524	e3a03001	 mov         r3, #1
  00528	e58d3014	 str         r3, [sp, #0x14]
  0052c	ea000001	 b           |$LN8@OALKitlIni|
  00530		 |$LN7@OALKitlIni|
  00530	e3a03000	 mov         r3, #0
  00534	e58d3014	 str         r3, [sp, #0x14]
  00538		 |$LN8@OALKitlIni|

; 185  : 
; 186  :     if (!OALKitlGetDevLoc(&devLoc)) goto cleanUp;

  00538	e28d0000	 add         r0, sp, #0
  0053c	eb000000	 bl          OALKitlGetDevLoc
  00540	e58d0018	 str         r0, [sp, #0x18]
  00544	e59d3018	 ldr         r3, [sp, #0x18]
  00548	e3530000	 cmp         r3, #0
  0054c	1a000000	 bne         |$LN4@OALKitlIni|
  00550	ea000004	 b           |$cleanUp$43127|
  00554		 |$LN4@OALKitlIni|

; 187  :     
; 188  :     switch (devLoc.IfcType) {

  00554	e59d3000	 ldr         r3, [sp]
  00558	e3530005	 cmp         r3, #5
  0055c	0a000000	 beq         |$LN1@OALKitlIni|
  00560	ea000000	 b           |$LN2@OALKitlIni|
  00564		 |$LN1@OALKitlIni|

; 189  : #ifdef KITL_PCI        
; 190  :     case PCIBus:
; 191  :             RegisterKITL();

  00564	eb000000	 bl          RegisterKITL
  00568		 |$LN2@OALKitlIni|
  00568		 |$cleanUp$43127|

; 192  :         break;
; 193  : #endif
; 194  :     }        
; 195  : 
; 196  : cleanUp:
; 197  :     KITL_RETAILMSG(ZONE_KITL_OAL, ("-OALKitlInitRegistry\r\n"));

  00568	e59f3034	 ldr         r3, [pc, #0x34]
  0056c	e5933440	 ldr         r3, [r3, #0x440]
  00570	e3130a01	 tst         r3, #1, 20
  00574	0a000004	 beq         |$LN9@OALKitlIni|
  00578	e59f0020	 ldr         r0, [pc, #0x20]
  0057c	eb000000	 bl          KITLOutputDebugString
  00580	e3a03001	 mov         r3, #1
  00584	e58d301c	 str         r3, [sp, #0x1C]
  00588	ea000001	 b           |$LN10@OALKitlIni|
  0058c		 |$LN9@OALKitlIni|
  0058c	e3a03000	 mov         r3, #0
  00590	e58d301c	 str         r3, [sp, #0x1C]
  00594		 |$LN10@OALKitlIni|

; 198  : }

  00594	e28dd020	 add         sp, sp, #0x20
  00598	e49de004	 ldr         lr, [sp], #4
  0059c	e12fff1e	 bx          lr
  005a0		 |$LN14@OALKitlIni|
  005a0		 |$LN15@OALKitlIni|
  005a0	00000000	 DCD         |??_C@_0BH@GBJLCFLG@?9OALKitlInitRegistry?$AN?6?$AA@|
  005a4		 |$LN16@OALKitlIni|
  005a4	00000000	 DCD         |dpCurSettings|
  005a8		 |$LN17@OALKitlIni|
  005a8	00000000	 DCD         |??_C@_0BH@IMFBFHMM@?$CLOALKitlInitRegistry?$AN?6?$AA@|
  005ac		 |$M43188|

			 ENDP  ; |OALKitlInitRegistry|

	END
