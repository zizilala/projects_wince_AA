; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\COMMON\KITL\registry.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	IMPORT	|OALPCICfgRead|
	IMPORT	|OALPCICfgWrite|
; File c:\wince600\platform\common\src\common\kitl\registry.c

  00000			 AREA	 |.pdata|, PDATA
|$T43202| DCD	|$LN24@PCIReadBAR|
	DCD	0x40007c02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PCIReadBARs| PROC

; 36   : {   

  00000		 |$LN24@PCIReadBAR|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M43199|
  00008	e1a05001	 mov         r5, r1
  0000c	e58d000c	 str         r0, [sp, #0xC]

; 37   :     DWORD NumberOfRegs;
; 38   :     DWORD Offset;
; 39   :     DWORD i;
; 40   :     DWORD BaseAddress;
; 41   :     DWORD Size;
; 42   :     DWORD Reg;
; 43   :     DWORD IoIndex = 0;
; 44   :     DWORD MemIndex = 0;
; 45   :     OAL_PCI_LOCATION pciLoc;
; 46   :     pciLoc.fnc = (UINT8)pInfo->Function;

  00010	e5953208	 ldr         r3, [r5, #0x208]

; 47   :     pciLoc.dev = (UINT8)pInfo->Device;

  00014	e5952204	 ldr         r2, [r5, #0x204]

; 48   :     pciLoc.bus = (UINT8)pInfo->Bus;

  00018	e595e200	 ldr         lr, [r5, #0x200]

; 49   :     busNumber >>= 8; // bits 8-15 are host-to-PCI-bridge bus number
; 50   : 
; 51   :     // Determine number of BARs to examine from header type
; 52   :     switch (pInfo->Cfg.HeaderType & ~PCI_MULTIFUNCTION) {

  0001c	e5d5421a	 ldrb        r4, [r5, #0x21A]
  00020	e5cd3004	 strb        r3, [sp, #4]
  00024	e5cd2005	 strb        r2, [sp, #5]
  00028	e3d43080	 bics        r3, r4, #0x80
  0002c	e5cde006	 strb        lr, [sp, #6]
  00030	0a000008	 beq         |$LN15@PCIReadBAR|
  00034	e3530001	 cmp         r3, #1
  00038	0a000004	 beq         |$LN14@PCIReadBAR|
  0003c	e3530002	 cmp         r3, #2

; 64   : 
; 65   :     default:
; 66   :         return FALSE;

  00040	13a00000	 movne       r0, #0
  00044	1a000066	 bne         |$LN18@PCIReadBAR|

; 60   : 
; 61   :     case PCI_CARDBUS_TYPE:
; 62   :         NumberOfRegs = PCI_TYPE2_ADDRESSES;

  00048	e3a04001	 mov         r4, #1

; 63   :         break;

  0004c	ea000002	 b           |$LN16@PCIReadBAR|
  00050		 |$LN14@PCIReadBAR|

; 55   :         break;
; 56   : 
; 57   :     case PCI_BRIDGE_TYPE:
; 58   :         NumberOfRegs = PCI_TYPE1_ADDRESSES;

  00050	e3a04002	 mov         r4, #2

; 59   :         break;

  00054	ea000000	 b           |$LN16@PCIReadBAR|
  00058		 |$LN15@PCIReadBAR|

; 53   :     case PCI_DEVICE_TYPE:
; 54   :         NumberOfRegs = PCI_TYPE0_ADDRESSES;

  00058	e3a04006	 mov         r4, #6
  0005c		 |$LN16@PCIReadBAR|

; 67   :     }
; 68   :         
; 69   :     for (i = 0, Offset = 0x10; i < NumberOfRegs; i++, Offset += 4) {

  0005c	e3a06000	 mov         r6, #0
  00060	e3a08010	 mov         r8, #0x10
  00064	e3540000	 cmp         r4, #0
  00068	0a00005c	 beq         |$LN9@PCIReadBAR|
  0006c	e3e03cff	 mvn         r3, #0xFF, 24
  00070	e223b0ff	 eor         r11, r3, #0xFF
  00074	e1a07005	 mov         r7, r5
  00078	e1a09005	 mov         r9, r5
  0007c	e1a0a005	 mov         r10, r5
  00080	e28de008	 add         lr, sp, #8
  00084		 |$LL11@PCIReadBAR|

; 70   :         // Get base address register value
; 71   :         Reg = pInfo->Cfg.u.type0.BaseAddresses[i];

  00084	e597121c	 ldr         r1, [r7, #0x21C]

; 72   : 
; 73   :         // Get size info
; 74   :         BaseAddress = 0xFFFFFFFF;
; 75   :         OALPCICfgWrite(busNumber, pciLoc, Offset, sizeof(BaseAddress), &BaseAddress);

  00088	e3e0e000	 mvn         lr, #0
  0008c	e58de008	 str         lr, [sp, #8]
  00090	e58d1010	 str         r1, [sp, #0x10]
  00094	e59d1004	 ldr         r1, [sp, #4]
  00098	e28de008	 add         lr, sp, #8
  0009c	e3a03004	 mov         r3, #4
  000a0	e1a02008	 mov         r2, r8
  000a4	e1a00420	 mov         r0, r0, lsr #8
  000a8	e58de000	 str         lr, [sp]
  000ac	eb000000	 bl          OALPCICfgWrite

; 76   :         OALPCICfgRead(busNumber, pciLoc, Offset, sizeof(BaseAddress), &BaseAddress);

  000b0	e59d000c	 ldr         r0, [sp, #0xC]
  000b4	e59d1004	 ldr         r1, [sp, #4]
  000b8	e28de008	 add         lr, sp, #8
  000bc	e1a00420	 mov         r0, r0, lsr #8
  000c0	e3a03004	 mov         r3, #4
  000c4	e1a02008	 mov         r2, r8
  000c8	e58de000	 str         lr, [sp]
  000cc	eb000000	 bl          OALPCICfgRead

; 77   :         OALPCICfgWrite(busNumber, pciLoc, Offset, sizeof(Reg), &Reg);

  000d0	e59d000c	 ldr         r0, [sp, #0xC]
  000d4	e59d1004	 ldr         r1, [sp, #4]
  000d8	e28de010	 add         lr, sp, #0x10
  000dc	e1a00420	 mov         r0, r0, lsr #8
  000e0	e3a03004	 mov         r3, #4
  000e4	e1a02008	 mov         r2, r8
  000e8	e58de000	 str         lr, [sp]
  000ec	eb000000	 bl          OALPCICfgWrite

; 78   : 
; 79   :         // Re-adjust BaseAddress if upper 16-bits are 0 (this happens on some devices that don't follow
; 80   :         // the PCI spec, like the Intel UHCI controllers)
; 81   :         if (((BaseAddress & 0xFFFFFFFC) != 0) && ((BaseAddress & 0xFFFF0000) == 0)) {

  000f0	e59d2008	 ldr         r2, [sp, #8]
  000f4	e3d2c003	 bics        r12, r2, #3
  000f8	0a000001	 beq         |$LN8@PCIReadBAR|
  000fc	e112000b	 tst         r2, r11

; 82   :             BaseAddress |= 0xFFFF0000;

  00100	0182200b	 orreq       r2, r2, r11
  00104		 |$LN8@PCIReadBAR|

; 83   :         }
; 84   :         
; 85   :         if (Reg & 1) {

  00104	e59d0010	 ldr         r0, [sp, #0x10]
  00108	e3100001	 tst         r0, #1
  0010c	0a000013	 beq         |$LN7@PCIReadBAR|

; 86   :             // IO space
; 87   :             Size = ~(BaseAddress & 0xFFFFFFFC);

  00110	e3c23003	 bic         r3, r2, #3
  00114	e1e01003	 mvn         r1, r3

; 88   : 
; 89   :             if ((BaseAddress != 0) && (BaseAddress != 0xFFFFFFFF) && (((Size + 1) & Size) == 0)) {

  00118	e3520000	 cmp         r2, #0
  0011c	0a000028	 beq         |$LN10@PCIReadBAR|
  00120	e3720001	 cmn         r2, #1
  00124	0a000026	 beq         |$LN10@PCIReadBAR|
  00128	e2813001	 add         r3, r1, #1
  0012c	e1130001	 tst         r3, r1
  00130	1a000023	 bne         |$LN10@PCIReadBAR|

; 90   :                 // BAR has valid format (consecutive high 1's and consecutive low 0's)
; 91   :                 pInfo->IoLen.Reg[IoIndex] = Size + 1;

  00134	e58a3364	 str         r3, [r10, #0x364]

; 92   :                 pInfo->IoLen.Num++;

  00138	e5953360	 ldr         r3, [r5, #0x360]

; 93   :                 pInfo->IoBase.Reg[IoIndex++] = Reg & 0xFFFFFFFC;

  0013c	e3c02003	 bic         r2, r0, #3
  00140	e2833001	 add         r3, r3, #1
  00144	e5853360	 str         r3, [r5, #0x360]
  00148	e58a2348	 str         r2, [r10, #0x348]

; 94   :                 pInfo->IoBase.Num++;

  0014c	e5953344	 ldr         r3, [r5, #0x344]
  00150	e28aa004	 add         r10, r10, #4
  00154	e2833001	 add         r3, r3, #1
  00158	e5853344	 str         r3, [r5, #0x344]

; 95   :             } else {
; 96   :                 // BAR invalid => skip to next one
; 97   :                 continue;
; 98   :             }
; 99   :         } else {

  0015c	ea000012	 b           |$LN2@PCIReadBAR|
  00160		 |$LN7@PCIReadBAR|

; 100  :             // Memory space
; 101  :             // TODO: don't properly handle the MEM20 case
; 102  :             Size = ~(BaseAddress & 0xFFFFFFF0);

  00160	e3c2300f	 bic         r3, r2, #0xF
  00164	e1e01003	 mvn         r1, r3

; 103  :             
; 104  :             if ((BaseAddress != 0) && (BaseAddress != 0xFFFFFFFF) && (((Size + 1) & Size) == 0)) {

  00168	e3520000	 cmp         r2, #0
  0016c	0a000014	 beq         |$LN10@PCIReadBAR|
  00170	e3720001	 cmn         r2, #1
  00174	0a000012	 beq         |$LN10@PCIReadBAR|
  00178	e2813001	 add         r3, r1, #1
  0017c	e1130001	 tst         r3, r1
  00180	1a00000f	 bne         |$LN10@PCIReadBAR|

; 105  :                 // BAR has valid format (consecutive high 1's and consecutive low 0's)
; 106  :                 pInfo->MemLen.Reg[MemIndex] = Size + 1;

  00184	e589332c	 str         r3, [r9, #0x32C]

; 107  :                 pInfo->MemLen.Num++;

  00188	e5953328	 ldr         r3, [r5, #0x328]

; 108  :                 pInfo->MemBase.Reg[MemIndex++] = Reg & 0xFFFFFFF0;

  0018c	e3c0200f	 bic         r2, r0, #0xF
  00190	e2833001	 add         r3, r3, #1
  00194	e5853328	 str         r3, [r5, #0x328]
  00198	e5892310	 str         r2, [r9, #0x310]

; 109  :                 pInfo->MemBase.Num++;

  0019c	e595330c	 ldr         r3, [r5, #0x30C]
  001a0	e2899004	 add         r9, r9, #4
  001a4	e2833001	 add         r3, r3, #1
  001a8	e585330c	 str         r3, [r5, #0x30C]
  001ac		 |$LN2@PCIReadBAR|

; 110  :             } else {
; 111  :                 // BAR invalid => skip to next one
; 112  :                 continue;
; 113  :             }
; 114  :         }
; 115  : 
; 116  :         //
; 117  :         // check for 64 bit device - BAR is twice as big
; 118  :         //
; 119  :         if ((pInfo->Cfg.u.type0.BaseAddresses[i] & 0x7) == 0x4) {

  001ac	e597321c	 ldr         r3, [r7, #0x21C]
  001b0	e2033007	 and         r3, r3, #7
  001b4	e3530004	 cmp         r3, #4

; 120  :             // 64 bit device - BAR is twice as wide - zero out high part
; 121  :             Offset += 4;

  001b8	02888004	 addeq       r8, r8, #4

; 122  :             i++;

  001bc	02866001	 addeq       r6, r6, #1
  001c0	02877004	 addeq       r7, r7, #4
  001c4		 |$LN10@PCIReadBAR|
  001c4	e2866001	 add         r6, r6, #1
  001c8	e59d000c	 ldr         r0, [sp, #0xC]
  001cc	e1560004	 cmp         r6, r4
  001d0	e2877004	 add         r7, r7, #4
  001d4	e2888004	 add         r8, r8, #4
  001d8	e28de008	 add         lr, sp, #8
  001dc	3affffa8	 bcc         |$LL11@PCIReadBAR|
  001e0		 |$LN9@PCIReadBAR|

; 123  :         }
; 124  :     }
; 125  : 
; 126  :     return TRUE;

  001e0	e3a00001	 mov         r0, #1
  001e4		 |$LN18@PCIReadBAR|

; 127  : }

  001e4	e28dd014	 add         sp, sp, #0x14
  001e8	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001ec	e12fff1e	 bx          lr
  001f0		 |$M43200|

			 ENDP  ; |PCIReadBARs|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|RegisterKITL|
	EXPORT	|??_C@_0BC@EPFFAFOO@?9?5RegisterKITL?5?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EE@PDFCDEEO@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAB?$AAu?$AAi?$AAl?$AAt?$AAI?$AAn?$AA?2?$AAP?$AAC?$AAI?$AA?2?$AAI?$AAn?$AAs?$AAt?$AAa?$AAn?$AAc?$AAe?$AA?2?$AAK?$AAI?$AAT@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BC@EBCJLJGL@?$CL?5RegisterKITL?5?$AN?6?$AA@| [ DATA ] ; `string'
	IMPORT	|PCIReg|
	IMPORT	|PCIInitInfo|
	IMPORT	|OALKitlGetDevLoc|
	IMPORT	|KITLOutputDebugString|
	IMPORT	|dpCurSettings|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|__security_check_cookie|

  00000			 AREA	 |.pdata|, PDATA
|$T43219| DCD	|$LN9@RegisterKI|
	DCD	0xc0003703

  00000			 AREA	 |.xdata|, DATA
|$T43215| DCD	0xffffffec

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BC@EPFFAFOO@?9?5RegisterKITL?5?$AN?6?$AA@| DCB "- RegisterKITL ", 0xd
	DCB	0xa, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EE@PDFCDEEO@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAB?$AAu?$AAi?$AAl?$AAt?$AAI?$AAn?$AA?2?$AAP?$AAC?$AAI?$AA?2?$AAI?$AAn?$AAs?$AAt?$AAa?$AAn?$AAc?$AAe?$AA?2?$AAK?$AAI?$AAT@| DCB "D"
	DCB	0x0, "r", 0x0, "i", 0x0, "v", 0x0, "e", 0x0, "r", 0x0, "s"
	DCB	0x0, "\\", 0x0, "B", 0x0, "u", 0x0, "i", 0x0, "l", 0x0, "t"
	DCB	0x0, "I", 0x0, "n", 0x0, "\\", 0x0, "P", 0x0, "C", 0x0, "I"
	DCB	0x0, "\\", 0x0, "I", 0x0, "n", 0x0, "s", 0x0, "t", 0x0, "a"
	DCB	0x0, "n", 0x0, "c", 0x0, "e", 0x0, "\\", 0x0, "K", 0x0, "I"
	DCB	0x0, "T", 0x0, "L", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BC@EBCJLJGL@?$CL?5RegisterKITL?5?$AN?6?$AA@| DCB "+ RegisterKITL "
	DCB	0xd, 0xa, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T43215|

  00008		 |RegisterKITL| PROC

; 137  : {

  00008		 |$LN9@RegisterKI|
  00008	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  0000c	e59fc0cc	 ldr         r12, [pc, #0xCC]
  00010	e08dd00c	 add         sp, sp, r12
  00014		 |$M43216|
  00014	e59f30c0	 ldr         r3, [pc, #0xC0]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d34a4	 str         r3, [sp, #0x4A4]

; 138  : 
; 139  :     PCI_REG_INFO KitlPCIInfo;
; 140  :     DEVICE_LOCATION devLoc;
; 141  : 
; 142  :     PCI_COMMON_CONFIG pciCfg;
; 143  :     OAL_PCI_LOCATION pciLoc;
; 144  : 
; 145  :     KITL_RETAILMSG(ZONE_KITL_OAL, ("+ RegisterKITL \r\n"));

  00020	e59f60b0	 ldr         r6, [pc, #0xB0]
  00024	e5963440	 ldr         r3, [r6, #0x440]
  00028	e3130a01	 tst         r3, #1, 20
  0002c	159f00a0	 ldrne       r0, [pc, #0xA0]
  00030	1b000000	 blne        KITLOutputDebugString

; 146  : 
; 147  :     OALKitlGetDevLoc(&devLoc);

  00034	e28d0010	 add         r0, sp, #0x10
  00038	eb000000	 bl          OALKitlGetDevLoc

; 148  :     pciLoc = *(OAL_PCI_LOCATION*)&devLoc.LogicalLoc;

  0003c	e59d4018	 ldr         r4, [sp, #0x18]

; 149  : 
; 150  :     // First read all device configuration space
; 151  :     OALPCICfgRead(devLoc.BusNumber, pciLoc, 0, sizeof(pciCfg), &pciCfg);

  00040	e59d0014	 ldr         r0, [sp, #0x14]
  00044	e28de024	 add         lr, sp, #0x24
  00048	e1a01004	 mov         r1, r4
  0004c	e3a03c01	 mov         r3, #1, 24
  00050	e3a02000	 mov         r2, #0
  00054	e58d400c	 str         r4, [sp, #0xC]
  00058	e58de000	 str         lr, [sp]
  0005c	eb000000	 bl          OALPCICfgRead

; 152  : 
; 153  : 
; 154  :     // Fill info structure
; 155  :     PCIInitInfo(
; 156  :        L"Drivers\\BuiltIn\\PCI\\Instance\\KITL", pciLoc.bus, pciLoc.dev, 
; 157  :        pciLoc.fnc, pciCfg.u.type0.InterruptLine, &pciCfg, &KitlPCIInfo
; 158  :     );

  00060	e5dd5060	 ldrb        r5, [sp, #0x60]
  00064	e5dd300c	 ldrb        r3, [sp, #0xC]
  00068	e5dd200d	 ldrb        r2, [sp, #0xD]
  0006c	e5dd100e	 ldrb        r1, [sp, #0xE]
  00070	e59f0058	 ldr         r0, [pc, #0x58]
  00074	e28def49	 add         lr, sp, #0x49, 30
  00078	e28d4024	 add         r4, sp, #0x24
  0007c	e58d5000	 str         r5, [sp]
  00080	e58de008	 str         lr, [sp, #8]
  00084	e58d4004	 str         r4, [sp, #4]
  00088	eb000000	 bl          PCIInitInfo

; 159  : 
; 160  :     PCIReadBARs(devLoc.BusNumber, &KitlPCIInfo);

  0008c	e59d0014	 ldr         r0, [sp, #0x14]
  00090	e28d1f49	 add         r1, sp, #0x49, 30
  00094	eb000000	 bl          PCIReadBARs

; 161  :     PCIReg(&KitlPCIInfo);

  00098	e28d0f49	 add         r0, sp, #0x49, 30
  0009c	eb000000	 bl          PCIReg

; 162  :     KITL_RETAILMSG(ZONE_KITL_OAL, ("- RegisterKITL \r\n"));

  000a0	e5963440	 ldr         r3, [r6, #0x440]
  000a4	e3130a01	 tst         r3, #1, 20
  000a8	159f001c	 ldrne       r0, [pc, #0x1C]
  000ac	1b000000	 blne        KITLOutputDebugString
  000b0	e59d04a4	 ldr         r0, [sp, #0x4A4]
  000b4	eb000000	 bl          __security_check_cookie

; 163  : 
; 164  : }

  000b8	e3a0cb01	 mov         r12, #1, 22
  000bc	e38cc0a8	 orr         r12, r12, #0xA8
  000c0	e08dd00c	 add         sp, sp, r12
  000c4	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000c8	e12fff1e	 bx          lr
  000cc		 |$LN10@RegisterKI|
  000cc		 |$LN11@RegisterKI|
  000cc	00000000	 DCD         |??_C@_0BC@EPFFAFOO@?9?5RegisterKITL?5?$AN?6?$AA@|
  000d0		 |$LN12@RegisterKI|
  000d0	00000000	 DCD         |??_C@_1EE@PDFCDEEO@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAB?$AAu?$AAi?$AAl?$AAt?$AAI?$AAn?$AA?2?$AAP?$AAC?$AAI?$AA?2?$AAI?$AAn?$AAs?$AAt?$AAa?$AAn?$AAc?$AAe?$AA?2?$AAK?$AAI?$AAT@|
  000d4		 |$LN13@RegisterKI|
  000d4	00000000	 DCD         |??_C@_0BC@EBCJLJGL@?$CL?5RegisterKITL?5?$AN?6?$AA@|
  000d8		 |$LN14@RegisterKI|
  000d8	00000000	 DCD         |dpCurSettings|
  000dc		 |$LN15@RegisterKI|
  000dc	00000000	 DCD         |__security_cookie|
  000e0		 |$LN16@RegisterKI|
  000e0	fffffb58	 DCD         0xfffffb58
  000e4		 |$M43217|

			 ENDP  ; |RegisterKITL|

	EXPORT	|OALKitlInitRegistry|
	EXPORT	|??_C@_0BH@GBJLCFLG@?9OALKitlInitRegistry?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BH@IMFBFHMM@?$CLOALKitlInitRegistry?$AN?6?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T43238| DCD	|$LN13@OALKitlIni|
	DCD	0x40001802

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BH@GBJLCFLG@?9OALKitlInitRegistry?$AN?6?$AA@| DCB "-OALKitlInitRe"
	DCB	"gistry", 0xd, 0xa, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BH@IMFBFHMM@?$CLOALKitlInitRegistry?$AN?6?$AA@| DCB "+OALKitlInit"
	DCB	"Registry", 0xd, 0xa, 0x0		; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALKitlInitRegistry| PROC

; 181  : {

  00000		 |$LN13@OALKitlIni|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M43235|

; 182  :     DEVICE_LOCATION devLoc;
; 183  :     
; 184  :     KITL_RETAILMSG(ZONE_KITL_OAL, ("+OALKitlInitRegistry\r\n"));

  00008	e59f404c	 ldr         r4, [pc, #0x4C]
  0000c	e5943440	 ldr         r3, [r4, #0x440]
  00010	e3130a01	 tst         r3, #1, 20
  00014	159f003c	 ldrne       r0, [pc, #0x3C]
  00018	1b000000	 blne        KITLOutputDebugString

; 185  : 
; 186  :     if (!OALKitlGetDevLoc(&devLoc)) goto cleanUp;

  0001c	e28d0000	 add         r0, sp, #0
  00020	eb000000	 bl          OALKitlGetDevLoc
  00024	e3500000	 cmp         r0, #0
  00028	0a000002	 beq         |$cleanUp$43151|

; 187  :     
; 188  :     switch (devLoc.IfcType) {

  0002c	e59d3000	 ldr         r3, [sp]
  00030	e3530005	 cmp         r3, #5

; 189  : #ifdef KITL_PCI        
; 190  :     case PCIBus:
; 191  :             RegisterKITL();

  00034	0b000000	 bleq        RegisterKITL
  00038		 |$cleanUp$43151|

; 192  :         break;
; 193  : #endif
; 194  :     }        
; 195  : 
; 196  : cleanUp:
; 197  :     KITL_RETAILMSG(ZONE_KITL_OAL, ("-OALKitlInitRegistry\r\n"));

  00038	e5943440	 ldr         r3, [r4, #0x440]
  0003c	e3130a01	 tst         r3, #1, 20
  00040	159f000c	 ldrne       r0, [pc, #0xC]
  00044	1b000000	 blne        KITLOutputDebugString

; 198  : }

  00048	e28dd014	 add         sp, sp, #0x14
  0004c	e8bd4010	 ldmia       sp!, {r4, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$LN14@OALKitlIni|
  00054		 |$LN15@OALKitlIni|
  00054	00000000	 DCD         |??_C@_0BH@GBJLCFLG@?9OALKitlInitRegistry?$AN?6?$AA@|
  00058		 |$LN16@OALKitlIni|
  00058	00000000	 DCD         |??_C@_0BH@IMFBFHMM@?$CLOALKitlInitRegistry?$AN?6?$AA@|
  0005c		 |$LN17@OALKitlIni|
  0005c	00000000	 DCD         |dpCurSettings|
  00060		 |$M43236|

			 ENDP  ; |OALKitlInitRegistry|

	END
