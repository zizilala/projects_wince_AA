; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\COMMON\KITL\kitleth.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.bss|, NOINIT
|?ipId@?1??EncodeIP@@9@9| % 0x2				; `EncodeIP'::`2'::ipId

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
; File c:\wince600\platform\common\src\common\kitl\kitleth.c

  00000			 AREA	 |.pdata|, PDATA
|$T44031| DCD	|$LN14@Sum|
	DCD	0x40001a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Sum|	 PROC

; 65   : {

  00000		 |$LN14@Sum|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44028|

; 72   :     p = (UINT16*)pData;
; 73   :     while (size >= sizeof(UINT16)) {

  00004	e3520002	 cmp         r2, #2
  00008	3a000005	 bcc         |$LN4@Sum|

; 66   :     UINT32 sum;
; 67   :     UINT16 *p;
; 68   : 
; 69   :     // There is no need to swap for network ordering during calculation
; 70   :     // because of the end around carry used in 1's complement addition
; 71   :     sum = seed;

  0000c	e1a0e0a2	 mov         lr, r2, lsr #1
  00010		 |$LL5@Sum|

; 74   :         sum += *p++;

  00010	e0d130b2	 ldrh        r3, [r1], #2

; 75   :         size -= sizeof(UINT16);

  00014	e2422002	 sub         r2, r2, #2
  00018	e25ee001	 subs        lr, lr, #1
  0001c	e0800003	 add         r0, r0, r3
  00020	1afffffa	 bne         |$LL5@Sum|
  00024		 |$LN4@Sum|

; 76   :     }
; 77   :     if (size > 0) sum += *((UINT8*)p);

  00024	e3520000	 cmp         r2, #0
  00028	15d13000	 ldrneb      r3, [r1]
  0002c	10800003	 addne       r0, r0, r3

; 78   : 
; 79   :     while ((sum & 0xFFFF0000) != 0) {

  00030	e3e03cff	 mvn         r3, #0xFF, 24
  00034	e22320ff	 eor         r2, r3, #0xFF
  00038	e1100002	 tst         r0, r2
  0003c	0a000005	 beq         |$LN1@Sum|
  00040	e3a03cff	 mov         r3, #0xFF, 24
  00044	e38310ff	 orr         r1, r3, #0xFF
  00048		 |$LL2@Sum|

; 80   :         sum = (sum & 0x0000FFFF) + (sum >> 16);

  00048	e0003001	 and         r3, r0, r1
  0004c	e0830820	 add         r0, r3, r0, lsr #16
  00050	e1100002	 tst         r0, r2
  00054	1afffffb	 bne         |$LL2@Sum|
  00058		 |$LN1@Sum|

; 81   :     }
; 82   :     return (UINT16)sum;

  00058	e1a00800	 mov         r0, r0, lsl #16
  0005c	e1a00820	 mov         r0, r0, lsr #16

; 83   : }

  00060	e49de004	 ldr         lr, [sp], #4
  00064	e12fff1e	 bx          lr
  00068		 |$M44029|

			 ENDP  ; |Sum|

	IMPORT	|memcpy|

  00002			 AREA	 |.bss|, NOINIT
|g_kitlEthState| % 0x6f4

  00000			 AREA	 |.pdata|, PDATA
|$T44042| DCD	|$LN5@SendARP|
	DCD	0x40003201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SendARP| PROC

; 88   : {

  00000		 |$LN5@SendARP|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M44039|
  00004	e1a07002	 mov         r7, r2
  00008	e1a06001	 mov         r6, r1
  0000c	e1a04000	 mov         r4, r0

; 89   :     UINT8 *pFrame = g_kitlEthState.packet;
; 90   :     ETH_HEADER *pEth = (ETH_HEADER*)pFrame;
; 91   :     ARP_MESSAGE *pARP = (ARP_MESSAGE*)((UINT8*)pEth + sizeof(ETH_HEADER));
; 92   : 
; 93   :     memcpy(pEth->destmac, mac, sizeof(pEth->destmac));

  00010	e59f80ac	 ldr         r8, [pc, #0xAC]
  00014	e3a02006	 mov         r2, #6
  00018	e2880f42	 add         r0, r8, #0x42, 30
  0001c	eb000000	 bl          memcpy

; 94   :     memcpy(pEth->srcmac, g_kitlEthState.deviceMAC, sizeof(pEth->srcmac));

  00020	e2883c01	 add         r3, r8, #1, 24
  00024	e283000e	 add         r0, r3, #0xE
  00028	e2881008	 add         r1, r8, #8
  0002c	e3a02006	 mov         r2, #6
  00030	eb000000	 bl          memcpy
  00034	e3a03c06	 mov         r3, #6, 24

; 95   :     pEth->ftype = htons(ARP_FRAME);

  00038	e3833008	 orr         r3, r3, #8
  0003c	e2885c01	 add         r5, r8, #1, 24
  00040	e1c531b4	 strh        r3, [r5, #0x14]

; 96   : 
; 97   :     pARP->htype = htons(1);         // Ethernet

  00044	e3a03c01	 mov         r3, #1, 24
  00048	e1c531b6	 strh        r3, [r5, #0x16]

; 98   :     pARP->ptype = htons(IP_FRAME);  // IP4 addresses

  0004c	e3a03008	 mov         r3, #8

; 99   :     pARP->hsize = 6;                // MAC address is 6 bytes long

  00050	e3a02006	 mov         r2, #6
  00054	e1c531b8	 strh        r3, [r5, #0x18]

; 100  :     pARP->psize = 4;                // IP4 addresses are 4 bytes long
; 101  :     pARP->op = htons(op);           // Specify an ARP op

  00058	e5c8211a	 strb        r2, [r8, #0x11A]

; 102  : 
; 103  :     // Fill in the source side information
; 104  :     memcpy(pARP->srcmac, g_kitlEthState.deviceMAC, sizeof(pARP->srcmac));

  0005c	e2882c01	 add         r2, r8, #1, 24
  00060	e1a03424	 mov         r3, r4, lsr #8
  00064	e3a01004	 mov         r1, #4
  00068	e282001e	 add         r0, r2, #0x1E
  0006c	e5c8111b	 strb        r1, [r8, #0x11B]
  00070	e1833404	 orr         r3, r3, r4, lsl #8
  00074	e3a02006	 mov         r2, #6
  00078	e2881008	 add         r1, r8, #8
  0007c	e1c531bc	 strh        r3, [r5, #0x1C]
  00080	eb000000	 bl          memcpy

; 105  :     pARP->srcip = g_kitlEthState.deviceIP;

  00084	e5983010	 ldr         r3, [r8, #0x10]

; 106  : 
; 107  :     // Fill in the destination information
; 108  :     memcpy(pARP->destmac, mac, sizeof(pARP->destmac));

  00088	e2880f4a	 add         r0, r8, #0x4A, 30
  0008c	e3a02006	 mov         r2, #6
  00090	e1a01006	 mov         r1, r6
  00094	e5883124	 str         r3, [r8, #0x124]
  00098	eb000000	 bl          memcpy

; 109  :     pARP->destip = ip;

  0009c	e1a03827	 mov         r3, r7, lsr #16
  000a0	e1c572be	 strh        r7, [r5, #0x2E]
  000a4	e1c533b0	 strh        r3, [r5, #0x30]

; 110  : 
; 111  :     // Send packet
; 112  :     g_kitlEthState.pfnSend(pFrame, sizeof(ETH_HEADER) + sizeof(ARP_MESSAGE));

  000a8	e5983030	 ldr         r3, [r8, #0x30]
  000ac	e3a0102a	 mov         r1, #0x2A
  000b0	e2880f42	 add         r0, r8, #0x42, 30
  000b4	e1a0e00f	 mov         lr, pc
  000b8	e12fff13	 bx          r3

; 113  : }

  000bc	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000c0	e12fff1e	 bx          lr
  000c4		 |$LN6@SendARP|
  000c4		 |$LN7@SendARP|
  000c4	00000000	 DCD         |g_kitlEthState|
  000c8		 |$M44040|

			 ENDP  ; |SendARP|


  00000			 AREA	 |.pdata|, PDATA
|$T44055| DCD	|$LN6@GetOpARP|
	DCD	0x40001200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetOpARP| PROC

; 118  : {

  00000		 |$LN6@GetOpARP|
  00000		 |$M44052|

; 119  :     ETH_HEADER *pEth = (ETH_HEADER*)pFrame;
; 120  :     ARP_MESSAGE *pARP = (ARP_MESSAGE*)((UINT8*)pEth + sizeof(ETH_HEADER));
; 121  : 
; 122  :     if (pEth->ftype != htons(ARP_FRAME)) return 0;

  00000	e5d0100c	 ldrb        r1, [r0, #0xC]
  00004	e5d0300d	 ldrb        r3, [r0, #0xD]
  00008	e3a02c06	 mov         r2, #6, 24
  0000c	e3822008	 orr         r2, r2, #8
  00010	e1813403	 orr         r3, r1, r3, lsl #8
  00014	e1530002	 cmp         r3, r2
  00018	13a00000	 movne       r0, #0

; 124  : }

  0001c	112fff1e	 bxne        lr

; 123  :     return htons(pARP->op);

  00020	e5d02014	 ldrb        r2, [r0, #0x14]
  00024	e5d03015	 ldrb        r3, [r0, #0x15]
  00028	e1823403	 orr         r3, r2, r3, lsl #8
  0002c	e1a02403	 mov         r2, r3, lsl #8
  00030	e1a03423	 mov         r3, r3, lsr #8
  00034	e1a02802	 mov         r2, r2, lsl #16
  00038	e1a03803	 mov         r3, r3, lsl #16
  0003c	e1a03823	 mov         r3, r3, lsr #16
  00040	e1830822	 orr         r0, r3, r2, lsr #16

; 124  : }

  00044	e12fff1e	 bx          lr
  00048		 |$M44053|

			 ENDP  ; |GetOpARP|


  00000			 AREA	 |.pdata|, PDATA
|$T44066| DCD	|$LN8@DecodeARP|
	DCD	0x40002401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DecodeARP| PROC

; 129  : {

  00000		 |$LN8@DecodeARP|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M44063|
  00004	e1a06002	 mov         r6, r2

; 130  :     ETH_HEADER *pEth = (ETH_HEADER*)pFrame;
; 131  :     ARP_MESSAGE *pARP = (ARP_MESSAGE*)((UINT8*)pEth + sizeof(ETH_HEADER));

  00008	e280500e	 add         r5, r0, #0xE

; 132  : 
; 133  : 
; 134  :     // Check to see that they were requesting the ARP response from us,
; 135  :     // send reply to ARP request, but ignore other ops
; 136  :     if (
; 137  :         pARP->destip == g_kitlEthState.deviceIP &&
; 138  :         pARP->op == htons(ARP_REQUEST)
; 139  :     ) {

  0000c	e5d51018	 ldrb        r1, [r5, #0x18]
  00010	e5d53019	 ldrb        r3, [r5, #0x19]
  00014	e5d5001a	 ldrb        r0, [r5, #0x1A]
  00018	e59fe06c	 ldr         lr, [pc, #0x6C]
  0001c	e5d5401b	 ldrb        r4, [r5, #0x1B]
  00020	e1813403	 orr         r3, r1, r3, lsl #8
  00024	e59e1010	 ldr         r1, [lr, #0x10]
  00028	e1833800	 orr         r3, r3, r0, lsl #16
  0002c	e1833c04	 orr         r3, r3, r4, lsl #24
  00030	e1530001	 cmp         r3, r1
  00034	1a000010	 bne         |$LN2@DecodeARP|
  00038	e5d51006	 ldrb        r1, [r5, #6]
  0003c	e5d53007	 ldrb        r3, [r5, #7]
  00040	e1813403	 orr         r3, r1, r3, lsl #8
  00044	e3530c01	 cmp         r3, #1, 24
  00048	1a00000b	 bne         |$LN2@DecodeARP|

; 140  :         SendARP(ARP_RESPONSE, pARP->srcmac, pARP->srcip);

  0004c	e5d5000e	 ldrb        r0, [r5, #0xE]
  00050	e5d5300f	 ldrb        r3, [r5, #0xF]
  00054	e5d52010	 ldrb        r2, [r5, #0x10]
  00058	e5d51011	 ldrb        r1, [r5, #0x11]
  0005c	e1803403	 orr         r3, r0, r3, lsl #8
  00060	e1833802	 orr         r3, r3, r2, lsl #16
  00064	e1832c01	 orr         r2, r3, r1, lsl #24
  00068	e2851008	 add         r1, r5, #8
  0006c	e3a00002	 mov         r0, #2
  00070	eb000000	 bl          SendARP

; 141  :         *pUsed = TRUE;

  00074	e3a03001	 mov         r3, #1

; 142  :     } else {

  00078	ea000000	 b           |$LN5@DecodeARP|
  0007c		 |$LN2@DecodeARP|

; 143  :         *pUsed = FALSE;

  0007c	e3a03000	 mov         r3, #0
  00080		 |$LN5@DecodeARP|
  00080	e5863000	 str         r3, [r6]

; 144  :     }
; 145  : }

  00084	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$LN9@DecodeARP|
  0008c		 |$LN10@DecodeARP|
  0008c	00000000	 DCD         |g_kitlEthState|
  00090		 |$M44064|

			 ENDP  ; |DecodeARP|

	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T44086| DCD	|$LN7@EncodeIP|
	DCD	0x40005902
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |EncodeIP| PROC

; 152  : ) {

  00000		 |$LN7@EncodeIP|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M44083|
  00008	e1a07003	 mov         r7, r3
  0000c	e1a04000	 mov         r4, r0
  00010	e58d7004	 str         r7, [sp, #4]
  00014	e58d4000	 str         r4, [sp]
  00018	e1b0e002	 movs        lr, r2

; 153  :     static UINT16 ipId = 0;
; 154  :     ETH_HEADER *pEth = (ETH_HEADER*)pFrame;
; 155  :     IP4_HEADER *pIP = (IP4_HEADER*)((UINT8*)pEth + sizeof(ETH_HEADER));
; 156  :     UINT16 ipLength, ethLength;
; 157  : 
; 158  :     // Get final length
; 159  :     ipLength = sizeof(IP4_HEADER) + length;

  0001c	e2811014	 add         r1, r1, #0x14
  00020	e1a05801	 mov         r5, r1, lsl #16
  00024	e1a05825	 mov         r5, r5, lsr #16

; 160  :     ethLength = sizeof(ETH_HEADER) + ipLength;

  00028	e285300e	 add         r3, r5, #0xE
  0002c	e58d3008	 str         r3, [sp, #8]

; 161  : 
; 162  :     // Fill in Ethernet header
; 163  :     if (pDestMAC != NULL) {
; 164  :         memcpy(pEth->destmac, pDestMAC, sizeof(pEth->destmac));

  00030	e3a02006	 mov         r2, #6
  00034	0a000002	 beq         |$LN2@EncodeIP|
  00038	e1a0100e	 mov         r1, lr
  0003c	eb000000	 bl          memcpy

; 165  :     } else {

  00040	ea000001	 b           |$LN1@EncodeIP|
  00044		 |$LN2@EncodeIP|

; 166  :         memset(pEth->destmac, 0xFF, sizeof(pEth->destmac));

  00044	e3a010ff	 mov         r1, #0xFF
  00048	eb000000	 bl          memset
  0004c		 |$LN1@EncodeIP|

; 167  :     }
; 168  :     memcpy(pEth->srcmac, g_kitlEthState.deviceMAC, sizeof(pEth->srcmac));

  0004c	e59f310c	 ldr         r3, [pc, #0x10C]
  00050	e2840006	 add         r0, r4, #6
  00054	e3a02006	 mov         r2, #6
  00058	e2831008	 add         r1, r3, #8
  0005c	eb000000	 bl          memcpy

; 169  :     pEth->ftype = htons(IP_FRAME);
; 170  : 
; 171  :     // Fill in IP4 header
; 172  :     pIP->verlen = 0x45;
; 173  :     pIP->tos = 0;
; 174  :     pIP->length = htons(ipLength);
; 175  :     pIP->id = ipId++;
; 176  :     pIP->fragment = 0;
; 177  :     pIP->ttl = 64;
; 178  :     pIP->protocol = protocol;
; 179  :     pIP->sum = 0;
; 180  :     pIP->srcip = srcIP;
; 181  :     pIP->destip = destIP;

  00060	e59d0030	 ldr         r0, [sp, #0x30]
  00064	e59f10f0	 ldr         r1, [pc, #0xF0]
  00068	e1a03425	 mov         r3, r5, lsr #8
  0006c	e1a09820	 mov         r9, r0, lsr #16
  00070	e1a0ac20	 mov         r10, r0, lsr #24
  00074	e59d0000	 ldr         r0, [sp]
  00078	e1d1b0b0	 ldrh        r11, [r1]
  0007c	e3a01008	 mov         r1, #8
  00080	e5c0100c	 strb        r1, [r0, #0xC]
  00084	e3a01000	 mov         r1, #0
  00088	e1834405	 orr         r4, r3, r5, lsl #8
  0008c	e1a0342b	 mov         r3, r11, lsr #8
  00090	e5c0100d	 strb        r1, [r0, #0xD]
  00094	e59f10c0	 ldr         r1, [pc, #0xC0]
  00098	e5c03013	 strb        r3, [r0, #0x13]

; 182  : 
; 183  :     // Compute IP4 header checksum
; 184  :     pIP->sum = ~ Sum(0, pIP, sizeof(IP4_HEADER));

  0009c	e1a03000	 mov         r3, r0
  000a0	e3a08045	 mov         r8, #0x45
  000a4	e5c3800e	 strb        r8, [r3, #0xE]
  000a8	e28b2001	 add         r2, r11, #1
  000ac	e3a08000	 mov         r8, #0
  000b0	e1a0e424	 mov         lr, r4, lsr #8
  000b4	e1c120b0	 strh        r2, [r1]
  000b8	e5c34010	 strb        r4, [r3, #0x10]
  000bc	e5c3800f	 strb        r8, [r3, #0xF]
  000c0	e283100e	 add         r1, r3, #0xE
  000c4	e1a04003	 mov         r4, r3
  000c8	e3a03040	 mov         r3, #0x40
  000cc	e5c43016	 strb        r3, [r4, #0x16]
  000d0	e5dd3034	 ldrb        r3, [sp, #0x34]
  000d4	e1a05427	 mov         r5, r7, lsr #8
  000d8	e1a06827	 mov         r6, r7, lsr #16
  000dc	e5c43017	 strb        r3, [r4, #0x17]
  000e0	e59d3004	 ldr         r3, [sp, #4]
  000e4	e5c48014	 strb        r8, [r4, #0x14]
  000e8	e5c48015	 strb        r8, [r4, #0x15]
  000ec	e5c4301a	 strb        r3, [r4, #0x1A]
  000f0	e59d3030	 ldr         r3, [sp, #0x30]
  000f4	e5c48018	 strb        r8, [r4, #0x18]
  000f8	e5c48019	 strb        r8, [r4, #0x19]
  000fc	e1a08423	 mov         r8, r3, lsr #8
  00100	e1a07c27	 mov         r7, r7, lsr #24
  00104	e3a02014	 mov         r2, #0x14
  00108	e3a00000	 mov         r0, #0
  0010c	e5c4801f	 strb        r8, [r4, #0x1F]
  00110	e5c4e011	 strb        lr, [r4, #0x11]
  00114	e5c4b012	 strb        r11, [r4, #0x12]
  00118	e5c4501b	 strb        r5, [r4, #0x1B]
  0011c	e5c4601c	 strb        r6, [r4, #0x1C]
  00120	e5c4701d	 strb        r7, [r4, #0x1D]
  00124	e5c4301e	 strb        r3, [r4, #0x1E]
  00128	e5c49020	 strb        r9, [r4, #0x20]
  0012c	e5c4a021	 strb        r10, [r4, #0x21]
  00130	eb000000	 bl          Sum
  00134	e1e02000	 mvn         r2, r0
  00138	e1a03422	 mov         r3, r2, lsr #8
  0013c	e5c43019	 strb        r3, [r4, #0x19]

; 185  : 
; 186  :     // We are done
; 187  :     return ethLength;
; 188  : }

  00140	e59d3008	 ldr         r3, [sp, #8]
  00144	e5c42018	 strb        r2, [r4, #0x18]
  00148	e1a00803	 mov         r0, r3, lsl #16
  0014c	e1a00820	 mov         r0, r0, lsr #16
  00150	e28dd00c	 add         sp, sp, #0xC
  00154	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00158	e12fff1e	 bx          lr
  0015c		 |$LN8@EncodeIP|
  0015c		 |$LN9@EncodeIP|
  0015c	00000000	 DCD         |?ipId@?1??EncodeIP@@9@9|
  00160		 |$LN10@EncodeIP|
  00160	00000000	 DCD         |g_kitlEthState|
  00164		 |$M44084|

			 ENDP  ; |EncodeIP|


  00000			 AREA	 |.pdata|, PDATA
|$T44109| DCD	|$LN5@EncodeUDP|
	DCD	0x40003904
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |EncodeUDP| PROC

; 195  : ) {

  00000		 |$LN5@EncodeUDP|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5ff0	 stmdb       sp!, {r4 - r12, lr}
  0000c	e24dd008	 sub         sp, sp, #8
  00010		 |$M44106|
  00010	e1a0b003	 mov         r11, r3
  00014	e58db03c	 str         r11, [sp, #0x3C]
  00018	e1a09002	 mov         r9, r2
  0001c	e1a0a000	 mov         r10, r0

; 196  :     UDP_HEADER *pUDP;
; 197  :     UINT16 xsum, udpLength;
; 198  : 
; 199  :     // First calculate UDP length
; 200  :     udpLength = sizeof(UDP_HEADER) + length;

  00020	e2811008	 add         r1, r1, #8
  00024	e1a08801	 mov         r8, r1, lsl #16

; 201  : 
; 202  :     // Fill in UDP header
; 203  :     pUDP = (UDP_HEADER*)(pFrame + sizeof(ETH_HEADER) + sizeof(IP4_HEADER));
; 204  :     pUDP->srcPort = srcPort;

  00028	e1dde4b4	 ldrh        lr, [sp, #0x44]
  0002c	e1a08828	 mov         r8, r8, lsr #16

; 205  :     pUDP->dstPort = destPort;
; 206  :     pUDP->length = htons(udpLength);

  00030	e1a01428	 mov         r1, r8, lsr #8
  00034	e1dd64b8	 ldrh        r6, [sp, #0x48]
  00038	e1a0700a	 mov         r7, r10
  0003c	e1815408	 orr         r5, r1, r8, lsl #8
  00040	e5e7e022	 strb        lr, [r7, #0x22]!
  00044	e1a01425	 mov         r1, r5, lsr #8
  00048	e1a0e42e	 mov         lr, lr, lsr #8
  0004c	e5c71005	 strb        r1, [r7, #5]
  00050	e1a04426	 mov         r4, r6, lsr #8

; 207  :     pUDP->sum = 0;

  00054	e3a03000	 mov         r3, #0

; 208  : 
; 209  :     // Compute UDP header checksum
; 210  :     xsum = htons(UDP_PROTOCOL);
; 211  :     xsum = Sum(xsum, &srcIP, sizeof(UINT32));

  00058	e28d103c	 add         r1, sp, #0x3C
  0005c	e3a02004	 mov         r2, #4
  00060	e3a00c11	 mov         r0, #0x11, 24
  00064	e5c7e001	 strb        lr, [r7, #1]
  00068	e5c76002	 strb        r6, [r7, #2]
  0006c	e5c74003	 strb        r4, [r7, #3]
  00070	e5c75004	 strb        r5, [r7, #4]
  00074	e5c73006	 strb        r3, [r7, #6]
  00078	e5c73007	 strb        r3, [r7, #7]
  0007c	eb000000	 bl          Sum

; 212  :     xsum = Sum(xsum, &destIP, sizeof(UINT32));

  00080	e3a02004	 mov         r2, #4
  00084	e28d1040	 add         r1, sp, #0x40
  00088	eb000000	 bl          Sum

; 213  :     xsum = Sum(xsum, &pUDP->length, sizeof(UINT32));

  0008c	e3a02004	 mov         r2, #4
  00090	e2871004	 add         r1, r7, #4
  00094	eb000000	 bl          Sum

; 214  :     xsum = Sum(xsum, pUDP, udpLength);

  00098	e1a02008	 mov         r2, r8
  0009c	e1a01007	 mov         r1, r7
  000a0	eb000000	 bl          Sum

; 215  :     pUDP->sum = ~xsum;

  000a4	e1e0e000	 mvn         lr, r0

; 216  : 
; 217  :     // And now do IP encode
; 218  :     return EncodeIP(pFrame, udpLength, pDestMAC, srcIP, destIP, UDP_PROTOCOL);

  000a8	e59d4040	 ldr         r4, [sp, #0x40]
  000ac	e1a0342e	 mov         r3, lr, lsr #8
  000b0	e5c73007	 strb        r3, [r7, #7]
  000b4	e3a05011	 mov         r5, #0x11
  000b8	e1a0300b	 mov         r3, r11
  000bc	e1a02009	 mov         r2, r9
  000c0	e1a01008	 mov         r1, r8
  000c4	e1a0000a	 mov         r0, r10
  000c8	e5c7e006	 strb        lr, [r7, #6]
  000cc	e58d5004	 str         r5, [sp, #4]
  000d0	e58d4000	 str         r4, [sp]
  000d4	eb000000	 bl          EncodeIP

; 219  : }

  000d8	e28dd008	 add         sp, sp, #8
  000dc	e89d6ff0	 ldmia       sp, {r4 - r11, sp, lr}
  000e0	e12fff1e	 bx          lr
  000e4		 |$M44107|

			 ENDP  ; |EncodeUDP|


  00000			 AREA	 |.pdata|, PDATA
|$T44126| DCD	|$LN14@FindDHCPOp|
	DCD	0x40000d00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FindDHCPOption| PROC

; 224  : {

  00000		 |$LN14@FindDHCPOp|
  00000		 |$M44123|

; 225  :     UINT8 *p;
; 226  : 
; 227  :     p = &pDHCP->options[4];
; 228  :     while (*p != DHCP_END) {

  00000	e5f030f0	 ldrb        r3, [r0, #0xF0]!
  00004	ea000004	 b           |$LN11@FindDHCPOp|
  00008		 |$LL4@FindDHCPOp|

; 229  :         if (*p == option) break;

  00008	e1530001	 cmp         r3, r1
  0000c	0a000004	 beq         |$LN10@FindDHCPOp|

; 230  :         p += p[1] + 2;

  00010	e5d03001	 ldrb        r3, [r0, #1]
  00014	e0800003	 add         r0, r0, r3
  00018	e5f03002	 ldrb        r3, [r0, #2]!
  0001c		 |$LN11@FindDHCPOp|
  0001c	e35300ff	 cmp         r3, #0xFF
  00020	1afffff8	 bne         |$LL4@FindDHCPOp|
  00024		 |$LN10@FindDHCPOp|

; 231  :     }
; 232  :     if (*p == DHCP_END) p = NULL;

  00024	e5d03000	 ldrb        r3, [r0]
  00028	e35300ff	 cmp         r3, #0xFF
  0002c	03a00000	 moveq       r0, #0

; 233  :     return p;
; 234  : }

  00030	e12fff1e	 bx          lr
  00034		 |$M44124|

			 ENDP  ; |FindDHCPOption|


  00000			 AREA	 |.pdata|, PDATA
|$T44138| DCD	|$LN5@AddDHCPOpt|
	DCD	0x40001901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |AddDHCPOption| PROC

; 241  : ) {

  00000		 |$LN5@AddDHCPOpt|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M44135|
  00004	e1a06002	 mov         r6, r2
  00008	e1a04001	 mov         r4, r1

; 242  :     pDHCP->options[(*pOffset)++] = option;

  0000c	e596e000	 ldr         lr, [r6]

; 243  :     pDHCP->options[(*pOffset)++] = size;
; 244  :     memcpy(&pDHCP->options[*pOffset], pData, size);

  00010	e1a01003	 mov         r1, r3
  00014	e59d5010	 ldr         r5, [sp, #0x10]
  00018	e08e3000	 add         r3, lr, r0
  0001c	e5c340ec	 strb        r4, [r3, #0xEC]
  00020	e5963000	 ldr         r3, [r6]
  00024	e1a02005	 mov         r2, r5
  00028	e2833001	 add         r3, r3, #1
  0002c	e083e000	 add         lr, r3, r0
  00030	e5863000	 str         r3, [r6]
  00034	e5ce50ec	 strb        r5, [lr, #0xEC]
  00038	e5963000	 ldr         r3, [r6]
  0003c	e283e001	 add         lr, r3, #1
  00040	e08e3000	 add         r3, lr, r0
  00044	e28300ec	 add         r0, r3, #0xEC
  00048	e586e000	 str         lr, [r6]
  0004c	eb000000	 bl          memcpy

; 245  :     *pOffset += size;

  00050	e5963000	 ldr         r3, [r6]
  00054	e0833005	 add         r3, r3, r5
  00058	e5863000	 str         r3, [r6]

; 246  : }

  0005c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$M44136|

			 ENDP  ; |AddDHCPOption|

	EXPORT	|__$ArrayPad$| [ DATA ]
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|__security_check_cookie|

  00000			 AREA	 |.pdata|, PDATA
|$T44173| DCD	|$LN24@SendDHCP|
	DCD	0xc0007c04

  00000			 AREA	 |.xdata|, DATA
|$T44169| DCD	0xffffffcc
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T44169|

  00008		 |SendDHCP| PROC

; 251  : {

  00008		 |$LN24@SendDHCP|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d000f	 stmdb       sp!, {r0 - r3}
  00010	e92d53f0	 stmdb       sp!, {r4 - r9, r12, lr}
  00014	e24dd018	 sub         sp, sp, #0x18
  00018		 |$M44170|
  00018	e1a05001	 mov         r5, r1
  0001c	e1a06000	 mov         r6, r0
  00020	e58d503c	 str         r5, [sp, #0x3C]
  00024	e58d6038	 str         r6, [sp, #0x38]
  00028	e59f31c4	 ldr         r3, [pc, #0x1C4]
  0002c	e5933000	 ldr         r3, [r3]
  00030	e58d3014	 str         r3, [sp, #0x14]

; 252  :     UINT8 *pFrame = g_kitlEthState.packet;
; 253  :     BOOTP_MESSAGE *pDHCP;
; 254  :     UINT32 offset;
; 255  :     UINT16 size;
; 256  :     UINT8 clientId[7];
; 257  : 
; 258  :     // Get pointer to BOOTP/DHCP message
; 259  :     pDHCP = (BOOTP_MESSAGE*)(
; 260  :         pFrame + sizeof(ETH_HEADER) + sizeof(IP4_HEADER) + sizeof(UDP_HEADER)
; 261  :     );
; 262  : 
; 263  :     // Clear all fields
; 264  :     memset(pDHCP, 0, sizeof(BOOTP_MESSAGE));

  00034	e59f41b4	 ldr         r4, [pc, #0x1B4]
  00038	e3a020ec	 mov         r2, #0xEC
  0003c	e3a01000	 mov         r1, #0
  00040	e2843c01	 add         r3, r4, #1, 24
  00044	e2830032	 add         r0, r3, #0x32
  00048	eb000000	 bl          memset

; 265  : 
; 266  :     // BOOTP header
; 267  :     pDHCP->op = 1;                              // BOOTREQUEST

  0004c	e3a03001	 mov         r3, #1
  00050	e5c43132	 strb        r3, [r4, #0x132]

; 268  :     pDHCP->htype = 1;                           // 10 Mbps Ethernet

  00054	e3a03001	 mov         r3, #1
  00058	e5c43133	 strb        r3, [r4, #0x133]

; 269  :     pDHCP->hlen = 6;                            // Ethernet address size

  0005c	e3a03006	 mov         r3, #6
  00060	e5c43134	 strb        r3, [r4, #0x134]

; 270  :     pDHCP->secs = 0;                            // Who care?

  00064	e3a03000	 mov         r3, #0
  00068	e284ec01	 add         lr, r4, #1, 24
  0006c	e1ce33ba	 strh        r3, [lr, #0x3A]

; 271  :     pDHCP->xid = g_kitlEthState.dhcpXId;

  00070	e594202c	 ldr         r2, [r4, #0x2C]

; 272  : 
; 273  :     // Device MAC address
; 274  :     memcpy(
; 275  :         pDHCP->chaddr, g_kitlEthState.deviceMAC,
; 276  :         sizeof(g_kitlEthState.deviceMAC)
; 277  :     );

  00074	e2840c01	 add         r0, r4, #1, 24
  00078	e2841008	 add         r1, r4, #8
  0007c	e1a03822	 mov         r3, r2, lsr #16
  00080	e1ce23b6	 strh        r2, [lr, #0x36]
  00084	e3a02006	 mov         r2, #6
  00088	e280004e	 add         r0, r0, #0x4E
  0008c	e1ce33b8	 strh        r3, [lr, #0x38]
  00090	eb000000	 bl          memcpy

; 278  : 
; 279  :     // Start with options
; 280  :     offset = 0;
; 281  : 
; 282  :     // DHCP cookie
; 283  :     pDHCP->options[offset++] = 0x63;

  00094	e3a03063	 mov         r3, #0x63
  00098	e5c4321e	 strb        r3, [r4, #0x21E]

; 284  :     pDHCP->options[offset++] = 0x82;

  0009c	e3a03082	 mov         r3, #0x82
  000a0	e5c4321f	 strb        r3, [r4, #0x21F]

; 285  :     pDHCP->options[offset++] = 0x53;

  000a4	e3a03053	 mov         r3, #0x53

; 286  :     pDHCP->options[offset++] = 0x63;
; 287  : 
; 288  :     // DHCP message type
; 289  :     AddDHCPOption(pDHCP, DHCP_MSGTYPE, &offset, &msgType, 1);

  000a8	e3a02063	 mov         r2, #0x63
  000ac	e5c43220	 strb        r3, [r4, #0x220]
  000b0	e5c42221	 strb        r2, [r4, #0x221]
  000b4	e3a02035	 mov         r2, #0x35
  000b8	e5dd3038	 ldrb        r3, [sp, #0x38]
  000bc	e5c42222	 strb        r2, [r4, #0x222]
  000c0	e3a02001	 mov         r2, #1
  000c4	e5c42223	 strb        r2, [r4, #0x223]

; 290  : 
; 291  :     // Add client id
; 292  :     clientId[0] = 1;

  000c8	e3a0e001	 mov         lr, #1

; 293  :     memcpy(&clientId[1], g_kitlEthState.deviceMAC, 6);

  000cc	e3a02006	 mov         r2, #6
  000d0	e2841008	 add         r1, r4, #8
  000d4	e28d000d	 add         r0, sp, #0xD
  000d8	e5c43224	 strb        r3, [r4, #0x224]
  000dc	e5cde00c	 strb        lr, [sp, #0xC]
  000e0	eb000000	 bl          memcpy

; 294  :     AddDHCPOption(pDHCP, DHCP_CLIENT_ID, &offset, clientId, 7);

  000e4	e3a0203d	 mov         r2, #0x3D
  000e8	e5c42225	 strb        r2, [r4, #0x225]
  000ec	e3a02007	 mov         r2, #7
  000f0	e2843c02	 add         r3, r4, #2, 24
  000f4	e5c42226	 strb        r2, [r4, #0x226]
  000f8	e3a02007	 mov         r2, #7
  000fc	e2830027	 add         r0, r3, #0x27
  00100	e28d100c	 add         r1, sp, #0xC
  00104	eb000000	 bl          memcpy
  00108	e3a00010	 mov         r0, #0x10

; 295  : 
; 296  :     switch (msgType) {

  0010c	e3560003	 cmp         r6, #3
  00110	0a000002	 beq         |$LN4@SendDHCP|
  00114	e3560004	 cmp         r6, #4
  00118	1a00001a	 bne         |$LN2@SendDHCP|

; 308  :         }
; 309  :         break;
; 310  :     case DHCP_DECLINE:
; 311  :         AddDHCPOption(
; 312  :             pDHCP, DHCP_IP_ADDR_REQ, &offset, &requestIP, sizeof(requestIP)
; 313  :         );
; 314  :         AddDHCPOption(
; 315  :             pDHCP, DHCP_SERVER_ID, &offset, &g_kitlEthState.dhcpServerIP,
; 316  :             sizeof(g_kitlEthState.dhcpServerIP)
; 317  :         );
; 318  :         break;

  0011c	ea000001	 b           |$LN21@SendDHCP|
  00120		 |$LN4@SendDHCP|

; 297  :     case DHCP_REQUEST:
; 298  :         if (requestIP != 0) {

  00120	e3550000	 cmp         r5, #0
  00124	0a000012	 beq         |$LN3@SendDHCP|
  00128		 |$LN21@SendDHCP|

; 299  :             AddDHCPOption(
; 300  :                 pDHCP, DHCP_IP_ADDR_REQ, &offset, &requestIP, sizeof(requestIP)
; 301  :             );

  00128	e3a03032	 mov         r3, #0x32
  0012c	e5c4322e	 strb        r3, [r4, #0x22E]
  00130	e3a03004	 mov         r3, #4
  00134	e28d103c	 add         r1, sp, #0x3C
  00138	e2840e23	 add         r0, r4, #0x23, 28
  0013c	e3a02004	 mov         r2, #4
  00140	e5c4322f	 strb        r3, [r4, #0x22F]
  00144	eb000000	 bl          memcpy

; 302  :             AddDHCPOption(
; 303  :                 pDHCP, DHCP_SERVER_ID, &offset, &g_kitlEthState.dhcpServerIP,
; 304  :                 sizeof(g_kitlEthState.dhcpServerIP)
; 305  :             );

  00148	e3a02036	 mov         r2, #0x36
  0014c	e5c42234	 strb        r2, [r4, #0x234]
  00150	e3a02004	 mov         r2, #4
  00154	e2843c02	 add         r3, r4, #2, 24
  00158	e5c42235	 strb        r2, [r4, #0x235]
  0015c	e3a02004	 mov         r2, #4
  00160	e2830036	 add         r0, r3, #0x36
  00164	e2841028	 add         r1, r4, #0x28
  00168	eb000000	 bl          memcpy
  0016c	e3a0001c	 mov         r0, #0x1C

; 306  :         } else {

  00170	ea000004	 b           |$LN2@SendDHCP|
  00174		 |$LN3@SendDHCP|

; 307  :             pDHCP->ciaddr = g_kitlEthState.deviceIP;

  00174	e5941010	 ldr         r1, [r4, #0x10]
  00178	e2842c01	 add         r2, r4, #1, 24
  0017c	e1a03821	 mov         r3, r1, lsr #16
  00180	e1c213be	 strh        r1, [r2, #0x3E]
  00184	e1c234b0	 strh        r3, [r2, #0x40]
  00188		 |$LN2@SendDHCP|

; 319  :     }
; 320  : 
; 321  :     // DHCP message end
; 322  :     pDHCP->options[offset++] = DHCP_END;
; 323  : 
; 324  :     // Add MAC/IP/UDP header and checksum
; 325  :     size = EncodeUDP(
; 326  :         pFrame, sizeof(BOOTP_MESSAGE) + offset, NULL, requestIP, 0xFFFFFFFF,
; 327  :         htons(DHCP_CLIENT_PORT), htons(DHCP_SERVER_PORT)
; 328  :     );

  00188	e28030ed	 add         r3, r0, #0xED
  0018c	e1a01803	 mov         r1, r3, lsl #16
  00190	e084e000	 add         lr, r4, r0
  00194	e3a060ff	 mov         r6, #0xFF
  00198	e3a07c43	 mov         r7, #0x43, 24
  0019c	e3a08b11	 mov         r8, #0x11, 22
  001a0	e3e09000	 mvn         r9, #0
  001a4	e1a01821	 mov         r1, r1, lsr #16
  001a8	e1a03005	 mov         r3, r5
  001ac	e3a02000	 mov         r2, #0
  001b0	e2840f42	 add         r0, r4, #0x42, 30
  001b4	e5ce621e	 strb        r6, [lr, #0x21E]
  001b8	e58d7008	 str         r7, [sp, #8]
  001bc	e58d8004	 str         r8, [sp, #4]
  001c0	e58d9000	 str         r9, [sp]
  001c4	eb000000	 bl          EncodeUDP

; 329  : 
; 330  :     // Send packet on wire
; 331  :     g_kitlEthState.pfnSend(pFrame, size);

  001c8	e5943030	 ldr         r3, [r4, #0x30]
  001cc	e1a01000	 mov         r1, r0
  001d0	e2840f42	 add         r0, r4, #0x42, 30
  001d4	e1a0e00f	 mov         lr, pc
  001d8	e12fff13	 bx          r3
  001dc	e59d0014	 ldr         r0, [sp, #0x14]
  001e0	eb000000	 bl          __security_check_cookie

; 332  : }

  001e4	e28dd018	 add         sp, sp, #0x18
  001e8	e89d63f0	 ldmia       sp, {r4 - r9, sp, lr}
  001ec	e12fff1e	 bx          lr
  001f0		 |$LN25@SendDHCP|
  001f0		 |$LN26@SendDHCP|
  001f0	00000000	 DCD         |g_kitlEthState|
  001f4		 |$LN27@SendDHCP|
  001f4	00000000	 DCD         |__security_cookie|
  001f8		 |$M44171|

			 ENDP  ; |SendDHCP|

	EXPORT	|??_C@_0CB@GFLGAKPJ@KITL?3?5Start?5DHCP?5RENEW?5process?$AN?6@| [ DATA ] ; `string'
	IMPORT	|KITLOutputDebugString|
	IMPORT	|dpCurSettings|

  00000			 AREA	 |.pdata|, PDATA
|$T44186| DCD	|$LN7@RenewDHCP|
	DCD	0x40001601

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CB@GFLGAKPJ@KITL?3?5Start?5DHCP?5RENEW?5process?$AN?6@| DCB "KITL"
	DCB	": Start DHCP RENEW process", 0xd, 0xa, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |RenewDHCP| PROC

; 337  : {

  00000		 |$LN7@RenewDHCP|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M44183|

; 338  :     KITL_RETAILMSG(ZONE_WARNING, ("KITL: Start DHCP RENEW process\r\n"));

  00004	e59f3048	 ldr         r3, [pc, #0x48]
  00008	e5933440	 ldr         r3, [r3, #0x440]
  0000c	e3130001	 tst         r3, #1
  00010	159f0038	 ldrne       r0, [pc, #0x38]
  00014	1b000000	 blne        KITLOutputDebugString

; 339  : 
; 340  :     // Change transaction id (ok, not too random)
; 341  :     g_kitlEthState.dhcpXId += 0x01080217;

  00018	e59f402c	 ldr         r4, [pc, #0x2C]
  0001c	e59f2024	 ldr         r2, [pc, #0x24]

; 342  :     // Send request
; 343  :     SendDHCP(DHCP_REQUEST, 0);

  00020	e3a01000	 mov         r1, #0
  00024	e594302c	 ldr         r3, [r4, #0x2C]
  00028	e3a00003	 mov         r0, #3
  0002c	e0833002	 add         r3, r3, r2
  00030	e584302c	 str         r3, [r4, #0x2C]
  00034	eb000000	 bl          SendDHCP

; 344  :     g_kitlEthState.dhcpState = DHCP_REQUESTING;

  00038	e3a03002	 mov         r3, #2
  0003c	e5843024	 str         r3, [r4, #0x24]

; 345  : }

  00040	e8bd4010	 ldmia       sp!, {r4, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$LN8@RenewDHCP|
  00048		 |$LN9@RenewDHCP|
  00048	01080217	 DCD         0x1080217
  0004c		 |$LN10@RenewDHCP|
  0004c	00000000	 DCD         |g_kitlEthState|
  00050		 |$LN11@RenewDHCP|
  00050	00000000	 DCD         |??_C@_0CB@GFLGAKPJ@KITL?3?5Start?5DHCP?5RENEW?5process?$AN?6@|
  00054		 |$LN12@RenewDHCP|
  00054	00000000	 DCD         |dpCurSettings|
  00058		 |$M44184|

			 ENDP  ; |RenewDHCP|

	IMPORT	|KitlSetTimerCallback|

  00000			 AREA	 |.pdata|, PDATA
|$T44247| DCD	|$LN54@DecodeDHCP|
	DCD	0x40009101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DecodeDHCP| PROC

; 434  : {

  00000		 |$LN54@DecodeDHCP|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44244|
  00004	e1a0e002	 mov         lr, r2

; 435  :     BOOTP_MESSAGE *pDHCP;
; 436  :     UINT8 *pOption, msgType;
; 437  :     UINT32 value;
; 438  :     BOOL rc;
; 439  : 
; 440  :     // Be pesimistic
; 441  :     *pUsed = FALSE;

  00008	e3a03000	 mov         r3, #0

; 442  : 
; 443  :     // Get pointers to BOOTP/DHCP message
; 444  :     pDHCP = (BOOTP_MESSAGE*)(
; 445  :         pFrame + sizeof(ETH_HEADER) + sizeof(IP4_HEADER) + sizeof(UDP_HEADER)
; 446  :     );

  0000c	e280402a	 add         r4, r0, #0x2A
  00010	e58e3000	 str         r3, [lr]

; 447  : 
; 448  :     // Check magic DHCP cookie & transaction id
; 449  :     if (
; 450  :         pDHCP->options[0] != 0x63 || pDHCP->options[1] != 0x82 ||
; 451  :         pDHCP->options[2] != 0x53 || pDHCP->options[3] != 0x63 ||
; 452  :         pDHCP->xid != g_kitlEthState.dhcpXId
; 453  :     ) goto cleanUp;

  00014	e5d430ec	 ldrb        r3, [r4, #0xEC]
  00018	e3530063	 cmp         r3, #0x63
  0001c	1a000084	 bne         |$cleanUp$43507|
  00020	e5d430ed	 ldrb        r3, [r4, #0xED]
  00024	e3530082	 cmp         r3, #0x82
  00028	1a000081	 bne         |$cleanUp$43507|
  0002c	e5d430ee	 ldrb        r3, [r4, #0xEE]
  00030	e3530053	 cmp         r3, #0x53
  00034	1a00007e	 bne         |$cleanUp$43507|
  00038	e5d430ef	 ldrb        r3, [r4, #0xEF]
  0003c	e3530063	 cmp         r3, #0x63
  00040	1a00007b	 bne         |$cleanUp$43507|
  00044	e5d41004	 ldrb        r1, [r4, #4]
  00048	e5d43005	 ldrb        r3, [r4, #5]
  0004c	e5d40006	 ldrb        r0, [r4, #6]
  00050	e59f51e8	 ldr         r5, [pc, #0x1E8]
  00054	e1813403	 orr         r3, r1, r3, lsl #8
  00058	e5d41007	 ldrb        r1, [r4, #7]
  0005c	e595202c	 ldr         r2, [r5, #0x2C]
  00060	e1833800	 orr         r3, r3, r0, lsl #16
  00064	e1833c01	 orr         r3, r3, r1, lsl #24
  00068	e1530002	 cmp         r3, r2
  0006c	1a000070	 bne         |$cleanUp$43507|

; 454  : 
; 455  :     // This is our DHCP transaction
; 456  :     *pUsed = TRUE;

  00070	e3a03001	 mov         r3, #1
  00074	e58e3000	 str         r3, [lr]

; 457  : 
; 458  :     // Then find DHCP message type
; 459  :     pOption = FindDHCPOption(pDHCP, DHCP_MSGTYPE);

  00078	e284e0f0	 add         lr, r4, #0xF0
  0007c	e5de3000	 ldrb        r3, [lr]
  00080	e1a0200e	 mov         r2, lr
  00084	ea000004	 b           |$LN47@DecodeDHCP|
  00088		 |$LL20@DecodeDHCP|
  00088	e3530035	 cmp         r3, #0x35
  0008c	0a000004	 beq         |$LN44@DecodeDHCP|
  00090	e5d23001	 ldrb        r3, [r2, #1]
  00094	e0822003	 add         r2, r2, r3
  00098	e5f23002	 ldrb        r3, [r2, #2]!
  0009c		 |$LN47@DecodeDHCP|
  0009c	e35300ff	 cmp         r3, #0xFF
  000a0	1afffff8	 bne         |$LL20@DecodeDHCP|
  000a4		 |$LN44@DecodeDHCP|
  000a4	e5d23000	 ldrb        r3, [r2]
  000a8	e35300ff	 cmp         r3, #0xFF
  000ac	03a02000	 moveq       r2, #0

; 460  :     if (pOption == NULL) return;

  000b0	e3520000	 cmp         r2, #0
  000b4	0a00005e	 beq         |$cleanUp$43507|

; 461  :     msgType = pOption[2];
; 462  : 
; 463  :     // Message processing depend on DHCP client state
; 464  :     switch (g_kitlEthState.dhcpState) {

  000b8	e5951024	 ldr         r1, [r5, #0x24]
  000bc	e5d23002	 ldrb        r3, [r2, #2]
  000c0	e3510001	 cmp         r1, #1
  000c4	0a000037	 beq         |$LN9@DecodeDHCP|
  000c8	e3510002	 cmp         r1, #2
  000cc	1a000058	 bne         |$cleanUp$43507|

; 476  :         break;
; 477  :     case DHCP_REQUESTING:
; 478  :         if (msgType == DHCP_ACK) {

  000d0	e3530005	 cmp         r3, #5
  000d4	1a00002a	 bne         |$LN5@DecodeDHCP|

; 479  :             // Set assigned address
; 480  :             g_kitlEthState.deviceIP = pDHCP->yiaddr;

  000d8	e5d40010	 ldrb        r0, [r4, #0x10]
  000dc	e5d43011	 ldrb        r3, [r4, #0x11]
  000e0	e5d42012	 ldrb        r2, [r4, #0x12]
  000e4	e5d41013	 ldrb        r1, [r4, #0x13]
  000e8	e1803403	 orr         r3, r0, r3, lsl #8
  000ec	e1833802	 orr         r3, r3, r2, lsl #16
  000f0	e1833c01	 orr         r3, r3, r1, lsl #24
  000f4	e5853010	 str         r3, [r5, #0x10]

; 481  :             // Find renew period & set timer callback
; 482  :             pOption = FindDHCPOption(pDHCP, DHCP_RENEW_TIME);

  000f8	e5de3000	 ldrb        r3, [lr]
  000fc	ea000004	 b           |$LN48@DecodeDHCP|
  00100		 |$LL32@DecodeDHCP|
  00100	e353003a	 cmp         r3, #0x3A
  00104	0a000004	 beq         |$LN45@DecodeDHCP|
  00108	e5de3001	 ldrb        r3, [lr, #1]
  0010c	e08ee003	 add         lr, lr, r3
  00110	e5fe3002	 ldrb        r3, [lr, #2]!
  00114		 |$LN48@DecodeDHCP|
  00114	e35300ff	 cmp         r3, #0xFF
  00118	1afffff8	 bne         |$LL32@DecodeDHCP|
  0011c		 |$LN45@DecodeDHCP|
  0011c	e5de3000	 ldrb        r3, [lr]
  00120	e35300ff	 cmp         r3, #0xFF
  00124	03a0e000	 moveq       lr, #0

; 483  :             if (pOption != NULL) {

  00128	e35e0000	 cmp         lr, #0
  0012c	0a00000d	 beq         |$LN4@DecodeDHCP|

; 484  :                 memcpy(&value, &pOption[2], sizeof(UINT32));

  00130	e5de0002	 ldrb        r0, [lr, #2]
  00134	e5de3003	 ldrb        r3, [lr, #3]
  00138	e5de2004	 ldrb        r2, [lr, #4]
  0013c	e5de1005	 ldrb        r1, [lr, #5]
  00140	e1803403	 orr         r3, r0, r3, lsl #8
  00144	e1833802	 orr         r3, r3, r2, lsl #16
  00148	e183ec01	 orr         lr, r3, r1, lsl #24

; 485  :                 rc = KitlSetTimerCallback(ntohl(value), RenewDHCP, NULL);

  0014c	e20e38ff	 and         r3, lr, #0xFF, 16
  00150	e183382e	 orr         r3, r3, lr, lsr #16
  00154	e20e2cff	 and         r2, lr, #0xFF, 24
  00158	e1a00423	 mov         r0, r3, lsr #8
  0015c	e182380e	 orr         r3, r2, lr, lsl #16
  00160	e1800403	 orr         r0, r0, r3, lsl #8

; 486  :             } else {

  00164	ea000001	 b           |$LN49@DecodeDHCP|
  00168		 |$LN4@DecodeDHCP|

; 487  :                 // If there isn't renew period select 30 minutes
; 488  :                 KitlSetTimerCallback(30*60, RenewDHCP, NULL);

  00168	e3a03c07	 mov         r3, #7, 24
  0016c	e3830008	 orr         r0, r3, #8
  00170		 |$LN49@DecodeDHCP|
  00170	e59f10c4	 ldr         r1, [pc, #0xC4]
  00174	e3a02000	 mov         r2, #0
  00178	eb000000	 bl          KitlSetTimerCallback

; 489  :             }
; 490  :             // We get address, let check it...
; 491  :             g_kitlEthState.dhcpState = DHCP_BOUND;

  0017c	e3a03000	 mov         r3, #0
  00180	ea00002a	 b           |$LN50@DecodeDHCP|
  00184		 |$LN5@DecodeDHCP|

; 492  :         } else if (msgType == DHCP_NAK) {

  00184	e3530006	 cmp         r3, #6
  00188	1a000029	 bne         |$cleanUp$43507|

; 493  :             g_kitlEthState.deviceIP = 0;

  0018c	e3a03000	 mov         r3, #0

; 494  :             // Discover DHCP servers
; 495  :             SendDHCP(DHCP_DISCOVER, 0);

  00190	e3a01000	 mov         r1, #0
  00194	e3a00001	 mov         r0, #1
  00198	e5853010	 str         r3, [r5, #0x10]
  0019c	eb000000	 bl          SendDHCP

; 496  :             // Start with discover again
; 497  :             g_kitlEthState.dhcpState = DHCP_SELECTING;

  001a0	e3a03001	 mov         r3, #1

; 498  :         }
; 499  :         break;

  001a4	ea000021	 b           |$LN50@DecodeDHCP|
  001a8		 |$LN9@DecodeDHCP|

; 465  :     case DHCP_SELECTING:
; 466  :         // Ignore anything other then offer
; 467  :         if (msgType != DHCP_OFFER) break;

  001a8	e3530002	 cmp         r3, #2
  001ac	1a000020	 bne         |$cleanUp$43507|

; 468  :         // Find server IP address
; 469  :         pOption = FindDHCPOption(pDHCP, DHCP_SERVER_ID);

  001b0	e5de3000	 ldrb        r3, [lr]
  001b4	ea000004	 b           |$LN51@DecodeDHCP|
  001b8		 |$LL26@DecodeDHCP|
  001b8	e3530036	 cmp         r3, #0x36
  001bc	0a000004	 beq         |$LN46@DecodeDHCP|
  001c0	e5de3001	 ldrb        r3, [lr, #1]
  001c4	e08ee003	 add         lr, lr, r3
  001c8	e5fe3002	 ldrb        r3, [lr, #2]!
  001cc		 |$LN51@DecodeDHCP|
  001cc	e35300ff	 cmp         r3, #0xFF
  001d0	1afffff8	 bne         |$LL26@DecodeDHCP|
  001d4		 |$LN46@DecodeDHCP|
  001d4	e5de3000	 ldrb        r3, [lr]
  001d8	e35300ff	 cmp         r3, #0xFF
  001dc	03a0e000	 moveq       lr, #0

; 470  :         if (pOption == NULL) break;

  001e0	e35e0000	 cmp         lr, #0
  001e4	0a000012	 beq         |$cleanUp$43507|

; 471  :         memcpy(&g_kitlEthState.dhcpServerIP, &pOption[2], sizeof(UINT32));

  001e8	e5de0002	 ldrb        r0, [lr, #2]
  001ec	e5de3003	 ldrb        r3, [lr, #3]
  001f0	e5de2004	 ldrb        r2, [lr, #4]
  001f4	e5de1005	 ldrb        r1, [lr, #5]
  001f8	e1803403	 orr         r3, r0, r3, lsl #8
  001fc	e1833802	 orr         r3, r3, r2, lsl #16
  00200	e1833c01	 orr         r3, r3, r1, lsl #24
  00204	e5853028	 str         r3, [r5, #0x28]

; 472  :         // Request offered IP address
; 473  :         SendDHCP(DHCP_REQUEST, pDHCP->yiaddr);

  00208	e5d40010	 ldrb        r0, [r4, #0x10]
  0020c	e5d43011	 ldrb        r3, [r4, #0x11]
  00210	e5d42012	 ldrb        r2, [r4, #0x12]
  00214	e5d41013	 ldrb        r1, [r4, #0x13]
  00218	e1803403	 orr         r3, r0, r3, lsl #8
  0021c	e1833802	 orr         r3, r3, r2, lsl #16
  00220	e1831c01	 orr         r1, r3, r1, lsl #24
  00224	e3a00003	 mov         r0, #3
  00228	eb000000	 bl          SendDHCP

; 474  :         // We moved to new state
; 475  :         g_kitlEthState.dhcpState = DHCP_REQUESTING;

  0022c	e3a03002	 mov         r3, #2
  00230		 |$LN50@DecodeDHCP|
  00230	e5853024	 str         r3, [r5, #0x24]
  00234		 |$cleanUp$43507|

; 500  :     }
; 501  : 
; 502  : cleanUp:
; 503  :     return;
; 504  : }

  00234	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00238	e12fff1e	 bx          lr
  0023c		 |$LN55@DecodeDHCP|
  0023c		 |$LN56@DecodeDHCP|
  0023c	00000000	 DCD         |RenewDHCP|
  00240		 |$LN57@DecodeDHCP|
  00240	00000000	 DCD         |g_kitlEthState|
  00244		 |$M44245|

			 ENDP  ; |DecodeDHCP|


  00000			 AREA	 |.pdata|, PDATA
|$T44263| DCD	|$LN7@DecodeICMP|
	DCD	0x40004c02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DecodeICMP| PROC

; 509  : {

  00000		 |$LN7@DecodeICMP|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M44260|
  00008	e1a04002	 mov         r4, r2
  0000c	e1a09001	 mov         r9, r1
  00010	e1a07000	 mov         r7, r0

; 510  :     ETH_HEADER *pEth = (ETH_HEADER*)pFrame;
; 511  :     IP4_HEADER *pIP = (IP4_HEADER*)((UINT8*)pEth + sizeof(ETH_HEADER));
; 512  :     ICMP_HEADER *pICMP = (ICMP_HEADER*)((UINT8*)pIP + sizeof(IP4_HEADER));
; 513  :     UINT16 icmpLength;
; 514  : 
; 515  :     // Be pesimistic
; 516  :     *pUsed = FALSE;

  00014	e3a05000	 mov         r5, #0
  00018	e287600e	 add         r6, r7, #0xE
  0001c	e5845000	 str         r5, [r4]

; 517  : 
; 518  :     // Get ICMP message size & verify checksum
; 519  :     icmpLength = ntohs(pIP->length) - sizeof(IP4_HEADER);

  00020	e5d6e002	 ldrb        lr, [r6, #2]
  00024	e5d63003	 ldrb        r3, [r6, #3]

; 520  :     if (Sum(0, pICMP, icmpLength) != 0xFFFF) goto cleanUp;

  00028	e2861014	 add         r1, r6, #0x14
  0002c	e3a00000	 mov         r0, #0
  00030	e18e3403	 orr         r3, lr, r3, lsl #8
  00034	e1a0e403	 mov         lr, r3, lsl #8
  00038	e1a03423	 mov         r3, r3, lsr #8
  0003c	e1a03803	 mov         r3, r3, lsl #16
  00040	e1a03823	 mov         r3, r3, lsr #16
  00044	e1a0e80e	 mov         lr, lr, lsl #16
  00048	e183382e	 orr         r3, r3, lr, lsr #16
  0004c	e2438014	 sub         r8, r3, #0x14
  00050	e1a02808	 mov         r2, r8, lsl #16
  00054	e1a02822	 mov         r2, r2, lsr #16
  00058	eb000000	 bl          Sum
  0005c	e3a03cff	 mov         r3, #0xFF, 24
  00060	e38330ff	 orr         r3, r3, #0xFF
  00064	e1500003	 cmp         r0, r3
  00068	1a00002c	 bne         |$cleanUp$43558|

; 521  : 
; 522  :     // Reply to ping only
; 523  :     if (pICMP->op != ICMP_ECHOREQ) goto cleanUp;

  0006c	e5d63014	 ldrb        r3, [r6, #0x14]
  00070	e3530008	 cmp         r3, #8
  00074	1a000029	 bne         |$cleanUp$43558|

; 524  : 
; 525  :     // We now know that packet is used
; 526  :     *pUsed = TRUE;

  00078	e3a0a001	 mov         r10, #1

; 527  : 
; 528  :     // Encode reply & do checksum
; 529  :     pICMP->op = 0;
; 530  :     pICMP->code = 0;
; 531  :     pICMP->sum = 0;
; 532  :     pICMP->sum = ~ Sum(0, pICMP, icmpLength);

  0007c	e1a02808	 mov         r2, r8, lsl #16
  00080	e584a000	 str         r10, [r4]
  00084	e1a02822	 mov         r2, r2, lsr #16
  00088	e2861014	 add         r1, r6, #0x14
  0008c	e3a00000	 mov         r0, #0
  00090	e5c65014	 strb        r5, [r6, #0x14]
  00094	e5c65015	 strb        r5, [r6, #0x15]
  00098	e5c65016	 strb        r5, [r6, #0x16]
  0009c	e5c65017	 strb        r5, [r6, #0x17]
  000a0	eb000000	 bl          Sum
  000a4	e1e02000	 mvn         r2, r0
  000a8	e1a03422	 mov         r3, r2, lsr #8
  000ac	e5c63017	 strb        r3, [r6, #0x17]
  000b0	e5c62016	 strb        r2, [r6, #0x16]

; 533  : 
; 534  :     // Add IP header
; 535  :     EncodeIP(
; 536  :         pFrame, icmpLength, pEth->srcmac, pIP->destip, pIP->srcip, ICMP_PROTOCOL
; 537  :     );

  000b4	e5d6100c	 ldrb        r1, [r6, #0xC]
  000b8	e5d6300d	 ldrb        r3, [r6, #0xD]
  000bc	e5d6200e	 ldrb        r2, [r6, #0xE]
  000c0	e5d65010	 ldrb        r5, [r6, #0x10]
  000c4	e5d6e011	 ldrb        lr, [r6, #0x11]
  000c8	e1813403	 orr         r3, r1, r3, lsl #8
  000cc	e5d6100f	 ldrb        r1, [r6, #0xF]
  000d0	e5d64012	 ldrb        r4, [r6, #0x12]
  000d4	e5d60013	 ldrb        r0, [r6, #0x13]
  000d8	e1833802	 orr         r3, r3, r2, lsl #16
  000dc	e185240e	 orr         r2, r5, lr, lsl #8
  000e0	e1833c01	 orr         r3, r3, r1, lsl #24
  000e4	e1822804	 orr         r2, r2, r4, lsl #16
  000e8	e58d3000	 str         r3, [sp]
  000ec	e1a01808	 mov         r1, r8, lsl #16
  000f0	e1823c00	 orr         r3, r2, r0, lsl #24
  000f4	e2872006	 add         r2, r7, #6
  000f8	e1a00007	 mov         r0, r7
  000fc	e1a01821	 mov         r1, r1, lsr #16
  00100	e58da004	 str         r10, [sp, #4]
  00104	eb000000	 bl          EncodeIP

; 538  : 
; 539  :     // Send packet
; 540  :     g_kitlEthState.pfnSend(pFrame, length);

  00108	e59f301c	 ldr         r3, [pc, #0x1C]
  0010c	e1a01009	 mov         r1, r9
  00110	e1a00007	 mov         r0, r7
  00114	e5933030	 ldr         r3, [r3, #0x30]
  00118	e1a0e00f	 mov         lr, pc
  0011c	e12fff13	 bx          r3
  00120		 |$cleanUp$43558|

; 541  : 
; 542  : cleanUp:
; 543  :     return;
; 544  : }

  00120	e28dd008	 add         sp, sp, #8
  00124	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00128	e12fff1e	 bx          lr
  0012c		 |$LN8@DecodeICMP|
  0012c		 |$LN9@DecodeICMP|
  0012c	00000000	 DCD         |g_kitlEthState|
  00130		 |$M44261|

			 ENDP  ; |DecodeICMP|

	EXPORT	|??_C@_0CJ@OFEHEAMD@KITL?3?5Connected?5host?5?5IP?3?5?$CFs?5?5Po@| [ DATA ] ; `string'
	IMPORT	|OALKitlIPtoString|

  00000			 AREA	 |.pdata|, PDATA
|$T44286| DCD	|$LN17@DecodeUDP|
	DCD	0x40007801

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CJ@OFEHEAMD@KITL?3?5Connected?5host?5?5IP?3?5?$CFs?5?5Po@| DCB "K"
	DCB	"ITL: Connected host  IP: %s  Port: %d", 0xd, 0xa, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DecodeUDP| PROC

; 549  : {

  00000		 |$LN17@DecodeUDP|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M44283|
  00004	e1a08002	 mov         r8, r2
  00008	e1a09001	 mov         r9, r1
  0000c	e1a0a000	 mov         r10, r0

; 550  :     UINT8 *pData = NULL;
; 551  :     ETH_HEADER *pEth = (ETH_HEADER*)pFrame;
; 552  :     IP4_HEADER *pIP = (IP4_HEADER*)((UINT8*)pEth + sizeof(ETH_HEADER));

  00010	e28a700e	 add         r7, r10, #0xE

; 553  :     UDP_HEADER *pUDP = (UDP_HEADER*)((UINT8*)pIP + sizeof(IP4_HEADER));
; 554  :     UINT16 xsum;
; 555  :     UINT32 ipLength, udpLength;
; 556  : 
; 557  :     // Be pesimistic
; 558  :     *pUsed = FALSE;

  00014	e3a03000	 mov         r3, #0
  00018	e2876014	 add         r6, r7, #0x14
  0001c	e5883000	 str         r3, [r8]

; 559  : 
; 560  :     // Get IP and UDP lengths from packet
; 561  :     ipLength = ntohs(pIP->length);
; 562  :     udpLength = ntohs(pUDP->length);

  00020	e5d64004	 ldrb        r4, [r6, #4]
  00024	e5d63005	 ldrb        r3, [r6, #5]
  00028	e5d75002	 ldrb        r5, [r7, #2]
  0002c	e5d7e003	 ldrb        lr, [r7, #3]
  00030	e1844403	 orr         r4, r4, r3, lsl #8
  00034	e1a03404	 mov         r3, r4, lsl #8
  00038	e1a03803	 mov         r3, r3, lsl #16
  0003c	e185540e	 orr         r5, r5, lr, lsl #8
  00040	e1a03823	 mov         r3, r3, lsr #16
  00044	e1a0e405	 mov         lr, r5, lsl #8
  00048	e183b424	 orr         r11, r3, r4, lsr #8

; 563  : 
; 564  :     // UPD length must be in sync with IP length
; 565  :     if (ipLength < sizeof(IP4_HEADER) + udpLength) goto cleanUp;

  0004c	e1a0380e	 mov         r3, lr, lsl #16
  00050	e1a03823	 mov         r3, r3, lsr #16
  00054	e1833425	 orr         r3, r3, r5, lsr #8
  00058	e28be014	 add         lr, r11, #0x14
  0005c	e153000e	 cmp         r3, lr
  00060	e3a05000	 mov         r5, #0
  00064	3a000057	 bcc         |$cleanUp$43593|

; 566  : 
; 567  :     // Verify UDP header checksum
; 568  :     if (pUDP->sum != 0) {    

  00068	e5d62006	 ldrb        r2, [r6, #6]
  0006c	e5d63007	 ldrb        r3, [r6, #7]
  00070	e1924403	 orrs        r4, r2, r3, lsl #8
  00074	0a00000e	 beq         |$LN8@DecodeUDP|

; 569  :        xsum = htons(UDP_PROTOCOL);
; 570  :        xsum = Sum(xsum, &pIP->srcip, sizeof(UINT32));

  00078	e3a02004	 mov         r2, #4
  0007c	e287100c	 add         r1, r7, #0xC
  00080	e3a00c11	 mov         r0, #0x11, 24
  00084	eb000000	 bl          Sum

; 571  :        xsum = Sum(xsum, &pIP->destip, sizeof(UINT32));

  00088	e3a02004	 mov         r2, #4
  0008c	e2871010	 add         r1, r7, #0x10
  00090	eb000000	 bl          Sum

; 572  :        xsum = Sum(xsum, &pUDP->length, sizeof(UINT32));

  00094	e3a02004	 mov         r2, #4
  00098	e2861004	 add         r1, r6, #4
  0009c	eb000000	 bl          Sum

; 573  :        xsum = Sum(xsum, pUDP, udpLength);

  000a0	e1a0200b	 mov         r2, r11
  000a4	e1a01006	 mov         r1, r6
  000a8	eb000000	 bl          Sum

; 574  :        if (xsum != pUDP->sum) goto cleanUp;

  000ac	e1540000	 cmp         r4, r0
  000b0	1a000044	 bne         |$cleanUp$43593|
  000b4		 |$LN8@DecodeUDP|

; 575  :     }
; 576  : 
; 577  :     switch (ntohs(pUDP->dstPort)) {

  000b4	e5d62002	 ldrb        r2, [r6, #2]
  000b8	e5d63003	 ldrb        r3, [r6, #3]
  000bc	e1822403	 orr         r2, r2, r3, lsl #8
  000c0	e1a03402	 mov         r3, r2, lsl #8
  000c4	e1a03803	 mov         r3, r3, lsl #16
  000c8	e1a03823	 mov         r3, r3, lsr #16
  000cc	e1832422	 orr         r2, r3, r2, lsr #8
  000d0	e3520044	 cmp         r2, #0x44
  000d4	0a000037	 beq         |$LN5@DecodeUDP|
  000d8	e3a03c03	 mov         r3, #3, 24
  000dc	e38330d5	 orr         r3, r3, #0xD5
  000e0	e1520003	 cmp         r2, r3
  000e4	1a000037	 bne         |$cleanUp$43593|

; 580  :         break;
; 581  :     case KITL_CLIENT_PORT:
; 582  :         // Message must be for us and client must have an address
; 583  :         if (
; 584  :             g_kitlEthState.deviceIP != pIP->destip ||
; 585  :             g_kitlEthState.deviceIP == 0
; 586  :         ) break;

  000e8	e5d72010	 ldrb        r2, [r7, #0x10]
  000ec	e5d73011	 ldrb        r3, [r7, #0x11]
  000f0	e5d71012	 ldrb        r1, [r7, #0x12]
  000f4	e59f40e0	 ldr         r4, [pc, #0xE0]
  000f8	e1823403	 orr         r3, r2, r3, lsl #8
  000fc	e5d72013	 ldrb        r2, [r7, #0x13]
  00100	e1833801	 orr         r3, r3, r1, lsl #16
  00104	e5941010	 ldr         r1, [r4, #0x10]
  00108	e1833c02	 orr         r3, r3, r2, lsl #24
  0010c	e1510003	 cmp         r1, r3
  00110	1a00002c	 bne         |$cleanUp$43593|
  00114	e3510000	 cmp         r1, #0
  00118	0a00002a	 beq         |$cleanUp$43593|

; 587  :         // Initialize KITL server address
; 588  :         if (g_kitlEthState.kitlServerIP == 0xFFFFFFFF) {

  0011c	e594301c	 ldr         r3, [r4, #0x1C]
  00120	e3730001	 cmn         r3, #1
  00124	1a00001c	 bne         |$LN13@DecodeUDP|

; 589  :             memcpy(
; 590  :                 g_kitlEthState.kitlServerMAC, pEth->srcmac,
; 591  :                 sizeof(g_kitlEthState.kitlServerMAC)
; 592  :             );

  00128	e2840014	 add         r0, r4, #0x14
  0012c	e28a1006	 add         r1, r10, #6
  00130	e3a02006	 mov         r2, #6
  00134	eb000000	 bl          memcpy

; 593  :             g_kitlEthState.kitlServerIP = pIP->srcip;

  00138	e5d7000c	 ldrb        r0, [r7, #0xC]
  0013c	e5d7300d	 ldrb        r3, [r7, #0xD]
  00140	e5d7200e	 ldrb        r2, [r7, #0xE]
  00144	e5d7100f	 ldrb        r1, [r7, #0xF]
  00148	e1803403	 orr         r3, r0, r3, lsl #8
  0014c	e1833802	 orr         r3, r3, r2, lsl #16

; 594  :             g_kitlEthState.kitlServerPort = pUDP->srcPort;
; 595  :             KITL_RETAILMSG(ZONE_INIT, (
; 596  :                 "KITL: Connected host  IP: %s  Port: %d\r\n",
; 597  :                 OALKitlIPtoString(g_kitlEthState.kitlServerIP),
; 598  :                 ntohs(g_kitlEthState.kitlServerPort)
; 599  :             ));

  00150	e59f2080	 ldr         r2, [pc, #0x80]
  00154	e1830c01	 orr         r0, r3, r1, lsl #24
  00158	e584001c	 str         r0, [r4, #0x1C]
  0015c	e5d61000	 ldrb        r1, [r6]
  00160	e5d63001	 ldrb        r3, [r6, #1]
  00164	e5922440	 ldr         r2, [r2, #0x440]
  00168	e1813403	 orr         r3, r1, r3, lsl #8
  0016c	e1c432b0	 strh        r3, [r4, #0x20]
  00170	e3120002	 tst         r2, #2
  00174	0a000008	 beq         |$LN13@DecodeUDP|
  00178	eb000000	 bl          OALKitlIPtoString
  0017c	e1d422b0	 ldrh        r2, [r4, #0x20]
  00180	e1a01000	 mov         r1, r0
  00184	e59f0048	 ldr         r0, [pc, #0x48]
  00188	e1a03402	 mov         r3, r2, lsl #8
  0018c	e1a03803	 mov         r3, r3, lsl #16
  00190	e1a03823	 mov         r3, r3, lsr #16
  00194	e1832422	 orr         r2, r3, r2, lsr #8
  00198	eb000000	 bl          KITLOutputDebugString
  0019c		 |$LN13@DecodeUDP|

; 600  :         }
; 601  :         *pUsed = TRUE;
; 602  :         pData = (UINT8*)pUDP + sizeof(UDP_HEADER);
; 603  :         *pLength = udpLength - sizeof(UDP_HEADER);

  0019c	e28b3cff	 add         r3, r11, #0xFF, 24
  001a0	e3a02001	 mov         r2, #1
  001a4	e28330f8	 add         r3, r3, #0xF8
  001a8	e5882000	 str         r2, [r8]
  001ac	e1c930b0	 strh        r3, [r9]
  001b0	e2865008	 add         r5, r6, #8

; 604  :         break;

  001b4	ea000003	 b           |$cleanUp$43593|
  001b8		 |$LN5@DecodeUDP|

; 578  :     case DHCP_CLIENT_PORT:
; 579  :         DecodeDHCP(pFrame, pLength, pUsed);

  001b8	e1a02008	 mov         r2, r8
  001bc	e1a01009	 mov         r1, r9
  001c0	e1a0000a	 mov         r0, r10
  001c4	eb000000	 bl          DecodeDHCP
  001c8		 |$cleanUp$43593|

; 605  :     }
; 606  : 
; 607  : cleanUp:
; 608  :     return pData;
; 609  : }

  001c8	e1a00005	 mov         r0, r5
  001cc	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001d0	e12fff1e	 bx          lr
  001d4		 |$LN18@DecodeUDP|
  001d4		 |$LN19@DecodeUDP|
  001d4	00000000	 DCD         |??_C@_0CJ@OFEHEAMD@KITL?3?5Connected?5host?5?5IP?3?5?$CFs?5?5Po@|
  001d8		 |$LN20@DecodeUDP|
  001d8	00000000	 DCD         |dpCurSettings|
  001dc		 |$LN21@DecodeUDP|
  001dc	00000000	 DCD         |g_kitlEthState|
  001e0		 |$M44284|

			 ENDP  ; |DecodeUDP|

	EXPORT	|DecodeIP|

  00000			 AREA	 |.pdata|, PDATA
|$T44304| DCD	|$LN12@DecodeIP|
	DCD	0x40003501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DecodeIP| PROC

; 614  : {

  00000		 |$LN12@DecodeIP|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M44301|
  00004	e1a07002	 mov         r7, r2
  00008	e1a0a001	 mov         r10, r1
  0000c	e1a08000	 mov         r8, r0

; 615  :     UINT8 *pData = NULL;
; 616  :     ETH_HEADER *pEth = (ETH_HEADER*)pFrame;
; 617  :     IP4_HEADER *pIP = (IP4_HEADER*)((UINT8*)pEth + sizeof(ETH_HEADER));
; 618  : 
; 619  :     // Be pesimistic
; 620  :     *pUsed = FALSE;

  00010	e3a03000	 mov         r3, #0
  00014	e1a06008	 mov         r6, r8
  00018	e5873000	 str         r3, [r7]

; 621  : 
; 622  :     // We support only IP4 with standard IP4 header (no options...)
; 623  :     if (pIP->verlen != 0x45) goto cleanUp;

  0001c	e5f6300e	 ldrb        r3, [r6, #0xE]!
  00020	e3a09000	 mov         r9, #0
  00024	e3530045	 cmp         r3, #0x45
  00028	1a000025	 bne         |$cleanUp$43642|

; 624  : 
; 625  :     // First check if packet is for us
; 626  :     if (
; 627  :         pIP->destip != g_kitlEthState.deviceIP &&
; 628  :         pIP->destip != 0xFFFFFFFF &&
; 629  :         g_kitlEthState.deviceIP != 0
; 630  :     ) goto cleanUp;

  0002c	e5d6e010	 ldrb        lr, [r6, #0x10]
  00030	e5d63011	 ldrb        r3, [r6, #0x11]
  00034	e5d64012	 ldrb        r4, [r6, #0x12]
  00038	e59f5090	 ldr         r5, [pc, #0x90]
  0003c	e18e3403	 orr         r3, lr, r3, lsl #8
  00040	e5d6e013	 ldrb        lr, [r6, #0x13]
  00044	e5952010	 ldr         r2, [r5, #0x10]
  00048	e1833804	 orr         r3, r3, r4, lsl #16
  0004c	e1833c0e	 orr         r3, r3, lr, lsl #24
  00050	e1530002	 cmp         r3, r2
  00054	0a000003	 beq         |$LN6@DecodeIP|
  00058	e3730001	 cmn         r3, #1
  0005c	0a000001	 beq         |$LN6@DecodeIP|
  00060	e3520000	 cmp         r2, #0
  00064	1a000016	 bne         |$cleanUp$43642|
  00068		 |$LN6@DecodeIP|

; 631  : 
; 632  :     // Verify IP4 header checksum
; 633  :     if (Sum(0, pIP, sizeof(IP4_HEADER)) != 0xFFFF) goto cleanUp;

  00068	e3a02014	 mov         r2, #0x14
  0006c	e1a01006	 mov         r1, r6
  00070	e3a00000	 mov         r0, #0
  00074	eb000000	 bl          Sum
  00078	e3a03cff	 mov         r3, #0xFF, 24
  0007c	e38330ff	 orr         r3, r3, #0xFF
  00080	e1500003	 cmp         r0, r3
  00084	1a00000e	 bne         |$cleanUp$43642|

; 634  : 
; 635  :     // Then decode protocol
; 636  :     switch (pIP->protocol) {

  00088	e5d63009	 ldrb        r3, [r6, #9]
  0008c	e3530001	 cmp         r3, #1
  00090	0a000007	 beq         |$LN1@DecodeIP|
  00094	e3530011	 cmp         r3, #0x11
  00098	1a000009	 bne         |$cleanUp$43642|

; 637  :     case UDP_PROTOCOL:
; 638  :         pData = DecodeUDP(pFrame, pLength, pUsed);

  0009c	e1a02007	 mov         r2, r7
  000a0	e1a0100a	 mov         r1, r10
  000a4	e1a00008	 mov         r0, r8
  000a8	eb000000	 bl          DecodeUDP
  000ac	e1a09000	 mov         r9, r0

; 639  :         break;

  000b0	ea000003	 b           |$cleanUp$43642|
  000b4		 |$LN1@DecodeIP|

; 640  :     case ICMP_PROTOCOL:
; 641  :         DecodeICMP(pFrame, *pLength, pUsed);

  000b4	e1da10b0	 ldrh        r1, [r10]
  000b8	e1a02007	 mov         r2, r7
  000bc	e1a00008	 mov         r0, r8
  000c0	eb000000	 bl          DecodeICMP
  000c4		 |$cleanUp$43642|

; 642  :         break;
; 643  :     }
; 644  : 
; 645  : cleanUp:
; 646  :     return pData;
; 647  : }

  000c4	e1a00009	 mov         r0, r9
  000c8	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  000cc	e12fff1e	 bx          lr
  000d0		 |$LN13@DecodeIP|
  000d0		 |$LN14@DecodeIP|
  000d0	00000000	 DCD         |g_kitlEthState|
  000d4		 |$M44302|

			 ENDP  ; |DecodeIP|

	EXPORT	|??_C@_0CO@LIMJACDF@?9KitlEthDecode?$CIpData?5?$DN?50x?$CF08x?0?5l@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CF@DCHGBGAP@?$CLKitlEthDecode?$CI0x?$CF08x?0?50x?$CF08x?9?$DO?$CF@| [ DATA ] ; `string'
	IMPORT	|VBridgeKIndicateOneRxBuffer|

  00000			 AREA	 |.pdata|, PDATA
|$T44333| DCD	|$LN19@KitlEthDec|
	DCD	0x40005c02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CO@LIMJACDF@?9KitlEthDecode?$CIpData?5?$DN?50x?$CF08x?0?5l@| DCB "-"
	DCB	"KitlEthDecode(pData = 0x%08x, length = %d)", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CF@DCHGBGAP@?$CLKitlEthDecode?$CI0x?$CF08x?0?50x?$CF08x?9?$DO?$CF@| DCB "+"
	DCB	"KitlEthDecode(0x%08x, 0x%08x->%d)", 0xd, 0xa, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KitlEthDecode| PROC

; 661  : {

  00000		 |$LN19@KitlEthDec|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M44330|
  00008	e1a04001	 mov         r4, r1
  0000c	e1a05000	 mov         r5, r0

; 662  :     ETH_HEADER *pEth = (ETH_HEADER*)pFrame;
; 663  :     UINT8 *pData = NULL;
; 664  :     BOOL used = FALSE;
; 665  : 
; 666  : 
; 667  :     KITL_RETAILMSG(ZONE_RECV, (
; 668  :         "+KitlEthDecode(0x%08x, 0x%08x->%d)\r\n", pFrame, pLength, *pLength
; 669  :     ));

  00010	e59f7154	 ldr         r7, [pc, #0x154]
  00014	e3a01000	 mov         r1, #0
  00018	e3a06000	 mov         r6, #0
  0001c	e5973440	 ldr         r3, [r7, #0x440]
  00020	e58d1000	 str         r1, [sp]
  00024	e3130020	 tst         r3, #0x20
  00028	0a000005	 beq         |$LN8@KitlEthDec|
  0002c	e1d430b0	 ldrh        r3, [r4]
  00030	e59f0130	 ldr         r0, [pc, #0x130]
  00034	e1a02004	 mov         r2, r4
  00038	e1a01005	 mov         r1, r5
  0003c	eb000000	 bl          KITLOutputDebugString
  00040	e59d1000	 ldr         r1, [sp]
  00044		 |$LN8@KitlEthDec|

; 670  : 
; 671  :     // Process received packet
; 672  :     switch (ntohs(pEth->ftype)) {

  00044	e5d5200c	 ldrb        r2, [r5, #0xC]
  00048	e5d5300d	 ldrb        r3, [r5, #0xD]
  0004c	e59f8110	 ldr         r8, [pc, #0x110]
  00050	e1822403	 orr         r2, r2, r3, lsl #8
  00054	e1a03402	 mov         r3, r2, lsl #8
  00058	e1a03803	 mov         r3, r3, lsl #16
  0005c	e1a03823	 mov         r3, r3, lsr #16
  00060	e1832422	 orr         r2, r3, r2, lsr #8
  00064	e3520b02	 cmp         r2, #2, 22
  00068	0a000023	 beq         |$LN2@KitlEthDec|
  0006c	e3a03b02	 mov         r3, #2, 22
  00070	e3833006	 orr         r3, r3, #6
  00074	e1520003	 cmp         r2, r3
  00078	1a000025	 bne         |$LN4@KitlEthDec|

; 673  :     case ARP_FRAME:
; 674  :         DecodeARP(pFrame, *pLength, &used);

  0007c	e285e00e	 add         lr, r5, #0xE
  00080	e5de1018	 ldrb        r1, [lr, #0x18]
  00084	e5de3019	 ldrb        r3, [lr, #0x19]
  00088	e5de201a	 ldrb        r2, [lr, #0x1A]
  0008c	e5de001b	 ldrb        r0, [lr, #0x1B]
  00090	e1813403	 orr         r3, r1, r3, lsl #8
  00094	e1833802	 orr         r3, r3, r2, lsl #16
  00098	e5982010	 ldr         r2, [r8, #0x10]
  0009c	e1833c00	 orr         r3, r3, r0, lsl #24
  000a0	e1530002	 cmp         r3, r2
  000a4	1a000011	 bne         |$LN13@KitlEthDec|
  000a8	e5de2006	 ldrb        r2, [lr, #6]
  000ac	e5de3007	 ldrb        r3, [lr, #7]
  000b0	e1823403	 orr         r3, r2, r3, lsl #8
  000b4	e3530c01	 cmp         r3, #1, 24
  000b8	1a00000c	 bne         |$LN13@KitlEthDec|
  000bc	e5de000e	 ldrb        r0, [lr, #0xE]
  000c0	e5de300f	 ldrb        r3, [lr, #0xF]
  000c4	e5de2010	 ldrb        r2, [lr, #0x10]
  000c8	e5de1011	 ldrb        r1, [lr, #0x11]
  000cc	e1803403	 orr         r3, r0, r3, lsl #8
  000d0	e1833802	 orr         r3, r3, r2, lsl #16
  000d4	e1832c01	 orr         r2, r3, r1, lsl #24
  000d8	e28e1008	 add         r1, lr, #8
  000dc	e3a00002	 mov         r0, #2
  000e0	eb000000	 bl          SendARP
  000e4	e3a03001	 mov         r3, #1
  000e8	e58d3000	 str         r3, [sp]
  000ec	ea000011	 b           |$LN1@KitlEthDec|
  000f0		 |$LN13@KitlEthDec|
  000f0	e3a03000	 mov         r3, #0
  000f4	e58d3000	 str         r3, [sp]

; 675  :         break;

  000f8	ea000007	 b           |$LN16@KitlEthDec|
  000fc		 |$LN2@KitlEthDec|

; 676  :     case IP_FRAME:
; 677  :         pData = DecodeIP(pFrame, pLength, &used);

  000fc	e28d2000	 add         r2, sp, #0
  00100	e1a01004	 mov         r1, r4
  00104	e1a00005	 mov         r0, r5
  00108	eb000000	 bl          DecodeIP
  0010c	e59d1000	 ldr         r1, [sp]
  00110	e1a06000	 mov         r6, r0
  00114		 |$LN4@KitlEthDec|

; 678  :         break;
; 679  :     }
; 680  : 
; 681  :     // If packet wasn't used, indicate it to VMINI
; 682  :     if (!used && (g_kitlEthState.flags & OAL_KITL_FLAGS_VMINI) != 0) {

  00114	e3510000	 cmp         r1, #0
  00118	1a000006	 bne         |$LN1@KitlEthDec|
  0011c		 |$LN16@KitlEthDec|
  0011c	e5983004	 ldr         r3, [r8, #4]
  00120	e3130008	 tst         r3, #8

; 683  :         VBridgeKIndicateOneRxBuffer(pFrame, *pLength, FALSE, &used);

  00124	11d410b0	 ldrneh      r1, [r4]
  00128	128d3000	 addne       r3, sp, #0
  0012c	13a02000	 movne       r2, #0
  00130	11a00005	 movne       r0, r5
  00134	1b000000	 blne        VBridgeKIndicateOneRxBuffer
  00138		 |$LN1@KitlEthDec|
  00138	e5973440	 ldr         r3, [r7, #0x440]

; 684  :     }
; 685  : 
; 686  :     KITL_RETAILMSG(ZONE_RECV, (
; 687  :         "-KitlEthDecode(pData = 0x%08x, length = %d)\r\n", pData, *pLength
; 688  :     ));

  0013c	e3130020	 tst         r3, #0x20
  00140	11d420b0	 ldrneh      r2, [r4]
  00144	159f0014	 ldrne       r0, [pc, #0x14]
  00148	11a01006	 movne       r1, r6
  0014c	1b000000	 blne        KITLOutputDebugString

; 689  :     return pData;
; 690  : }

  00150	e1a00006	 mov         r0, r6
  00154	e28dd004	 add         sp, sp, #4
  00158	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0015c	e12fff1e	 bx          lr
  00160		 |$LN20@KitlEthDec|
  00160		 |$LN21@KitlEthDec|
  00160	00000000	 DCD         |??_C@_0CO@LIMJACDF@?9KitlEthDecode?$CIpData?5?$DN?50x?$CF08x?0?5l@|
  00164		 |$LN22@KitlEthDec|
  00164	00000000	 DCD         |g_kitlEthState|
  00168		 |$LN23@KitlEthDec|
  00168	00000000	 DCD         |??_C@_0CF@DCHGBGAP@?$CLKitlEthDecode?$CI0x?$CF08x?0?50x?$CF08x?9?$DO?$CF@|
  0016c		 |$LN24@KitlEthDec|
  0016c	00000000	 DCD         |dpCurSettings|
  00170		 |$M44331|

			 ENDP  ; |KitlEthDecode|

	EXPORT	|??_C@_0BJ@BAFHPAIJ@?9KitlEthEncode?$CIrc?5?$DN?51?$CJ?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BL@NHDADPAH@?$CLKitlEthEncode?$CI?$CF08x?0?5?$CFd?$CJ?$AN?6?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T44353| DCD	|$LN9@KitlEthEnc|
	DCD	0x40002402

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BJ@BAFHPAIJ@?9KitlEthEncode?$CIrc?5?$DN?51?$CJ?$AN?6?$AA@| DCB "-"
	DCB	"KitlEthEncode(rc = 1)", 0xd, 0xa, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BL@NHDADPAH@?$CLKitlEthEncode?$CI?$CF08x?0?5?$CFd?$CJ?$AN?6?$AA@| DCB "+"
	DCB	"KitlEthEncode(%08x, %d)", 0xd, 0xa, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KitlEthEncode| PROC

; 700  : {

  00000		 |$LN9@KitlEthEnc|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M44350|
  00008	e1a06001	 mov         r6, r1
  0000c	e1a07000	 mov         r7, r0

; 701  :     KITL_RETAILMSG(ZONE_SEND, (
; 702  :         "+KitlEthEncode(%08x, %d)\r\n", pFrame, length
; 703  :     ));

  00010	e59f8074	 ldr         r8, [pc, #0x74]
  00014	e5983440	 ldr         r3, [r8, #0x440]
  00018	e3130010	 tst         r3, #0x10
  0001c	159f0064	 ldrne       r0, [pc, #0x64]
  00020	11a02006	 movne       r2, r6
  00024	11a01007	 movne       r1, r7
  00028	1b000000	 blne        KITLOutputDebugString

; 704  : 
; 705  :     // Encode packets
; 706  :     EncodeUDP(
; 707  :         pFrame, length,
; 708  :         g_kitlEthState.kitlServerMAC, g_kitlEthState.deviceIP,
; 709  :         g_kitlEthState.kitlServerIP, htons(KITL_CLIENT_PORT),
; 710  :         g_kitlEthState.kitlServerPort
; 711  :     );

  0002c	e59f4050	 ldr         r4, [pc, #0x50]
  00030	e3a03cd5	 mov         r3, #0xD5, 24
  00034	e3835003	 orr         r5, r3, #3
  00038	e594201c	 ldr         r2, [r4, #0x1C]
  0003c	e1d4e2b0	 ldrh        lr, [r4, #0x20]
  00040	e5943010	 ldr         r3, [r4, #0x10]
  00044	e58d2000	 str         r2, [sp]
  00048	e2842014	 add         r2, r4, #0x14
  0004c	e1a01006	 mov         r1, r6
  00050	e1a00007	 mov         r0, r7
  00054	e58de008	 str         lr, [sp, #8]
  00058	e58d5004	 str         r5, [sp, #4]
  0005c	eb000000	 bl          EncodeUDP

; 712  : 
; 713  :     KITL_RETAILMSG(ZONE_SEND, ("-KitlEthEncode(rc = 1)\r\n"));

  00060	e5983440	 ldr         r3, [r8, #0x440]
  00064	e3130010	 tst         r3, #0x10
  00068	159f0010	 ldrne       r0, [pc, #0x10]
  0006c	1b000000	 blne        KITLOutputDebugString

; 714  :     return TRUE;

  00070	e3a00001	 mov         r0, #1

; 715  : }

  00074	e28dd00c	 add         sp, sp, #0xC
  00078	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$LN10@KitlEthEnc|
  00080		 |$LN11@KitlEthEnc|
  00080	00000000	 DCD         |??_C@_0BJ@BAFHPAIJ@?9KitlEthEncode?$CIrc?5?$DN?51?$CJ?$AN?6?$AA@|
  00084		 |$LN12@KitlEthEnc|
  00084	00000000	 DCD         |g_kitlEthState|
  00088		 |$LN13@KitlEthEnc|
  00088	00000000	 DCD         |??_C@_0BL@NHDADPAH@?$CLKitlEthEncode?$CI?$CF08x?0?5?$CFd?$CJ?$AN?6?$AA@|
  0008c		 |$LN14@KitlEthEnc|
  0008c	00000000	 DCD         |dpCurSettings|
  00090		 |$M44351|

			 ENDP  ; |KitlEthEncode|


  00000			 AREA	 |.pdata|, PDATA
|$T44367| DCD	|$LN5@KitlEthGet|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KitlEthGetFrameHdrSize| PROC

; 725  : {

  00000		 |$LN5@KitlEthGet|
  00000		 |$M44364|

; 726  :     return sizeof(ETH_HEADER) + sizeof(IP4_HEADER) + sizeof(UDP_HEADER);

  00000	e3a0002a	 mov         r0, #0x2A

; 727  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M44365|

			 ENDP  ; |KitlEthGetFrameHdrSize|


  00000			 AREA	 |.pdata|, PDATA
|$T44376| DCD	|$LN5@KitlEthSet|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KitlEthSetHostCfg| PROC

; 737  : {

  00000		 |$LN5@KitlEthSet|
  00000		 |$M44373|

; 738  :      return TRUE;

  00000	e3a00001	 mov         r0, #1

; 739  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M44374|

			 ENDP  ; |KitlEthSetHostCfg|

	EXPORT	|??_C@_0BN@OHPDCAJH@?9KitlEthGetDevCfg?$CIrc?5?$DN?5?$CFd?$CJ?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CI@LLEHHLED@?$CLKitlEthGetDevCfg?$CI0x?$CF08x?0?50x?$CF08x@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T44393| DCD	|$LN10@KitlEthGet@2|
	DCD	0x40003c01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BN@OHPDCAJH@?9KitlEthGetDevCfg?$CIrc?5?$DN?5?$CFd?$CJ?$AN?6?$AA@| DCB "-"
	DCB	"KitlEthGetDevCfg(rc = %d)", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CI@LLEHHLED@?$CLKitlEthGetDevCfg?$CI0x?$CF08x?0?50x?$CF08x@| DCB "+"
	DCB	"KitlEthGetDevCfg(0x%08x, 0x%08x->%d)", 0xd, 0xa, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KitlEthGetDevCfg| PROC

; 749  : {

  00000		 |$LN10@KitlEthGet@2|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M44390|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 750  :     BOOL rc = FALSE;
; 751  :     UINT16 port = htons(KITL_CLIENT_PORT);
; 752  : 
; 753  :     KITL_RETAILMSG(ZONE_KITL_OAL,  (
; 754  :         "+KitlEthGetDevCfg(0x%08x, 0x%08x->%d)\r\n", pData, pSize, *pSize
; 755  :     ));

  0000c	e59f70d8	 ldr         r7, [pc, #0xD8]
  00010	e3a06000	 mov         r6, #0
  00014	e5973440	 ldr         r3, [r7, #0x440]
  00018	e3130a01	 tst         r3, #1, 20
  0001c	11d530b0	 ldrneh      r3, [r5]
  00020	159f00c0	 ldrne       r0, [pc, #0xC0]
  00024	11a02005	 movne       r2, r5
  00028	11a01004	 movne       r1, r4
  0002c	1b000000	 blne        KITLOutputDebugString

; 756  : 
; 757  :     // Is there space in buffer?
; 758  :     if (*pSize < (sizeof(UINT32) + 4 * sizeof(UINT16))) goto cleanUp;

  00030	e1d530b0	 ldrh        r3, [r5]
  00034	e353000c	 cmp         r3, #0xC
  00038	3a000020	 bcc         |$cleanUp$43719|

; 759  : 
; 760  :     *pSize = 0;
; 761  :     memcpy(pData, &g_kitlEthState.deviceIP, sizeof(UINT32));

  0003c	e59fe0a0	 ldr         lr, [pc, #0xA0]
  00040	e3a03000	 mov         r3, #0
  00044	e1c530b0	 strh        r3, [r5]
  00048	e59e3010	 ldr         r3, [lr, #0x10]

; 762  :     pData += sizeof(UINT32);
; 763  :     *pSize += sizeof(UINT32);
; 764  :     memcpy(pData, g_kitlEthState.deviceMAC, 3*sizeof(UINT16));

  0004c	e28e1008	 add         r1, lr, #8
  00050	e3a02006	 mov         r2, #6
  00054	e5c43000	 strb        r3, [r4]
  00058	e59e3010	 ldr         r3, [lr, #0x10]
  0005c	e1a03423	 mov         r3, r3, lsr #8
  00060	e5c43001	 strb        r3, [r4, #1]
  00064	e59e3010	 ldr         r3, [lr, #0x10]
  00068	e1a03823	 mov         r3, r3, lsr #16
  0006c	e5c43002	 strb        r3, [r4, #2]
  00070	e59e3010	 ldr         r3, [lr, #0x10]
  00074	e1a03c23	 mov         r3, r3, lsr #24
  00078	e5c43003	 strb        r3, [r4, #3]
  0007c	e1d530b0	 ldrh        r3, [r5]
  00080	e2844004	 add         r4, r4, #4
  00084	e1a00004	 mov         r0, r4
  00088	e2833004	 add         r3, r3, #4
  0008c	e1c530b0	 strh        r3, [r5]
  00090	eb000000	 bl          memcpy

; 765  :     pData += 3*sizeof(UINT16);
; 766  :     *pSize += 3*sizeof(UINT16);

  00094	e1d530b0	 ldrh        r3, [r5]

; 767  :     memcpy(pData, &port, sizeof(UINT16));

  00098	e3a02003	 mov         r2, #3

; 768  :     pData += sizeof(UINT16);
; 769  :     *pSize += sizeof(UINT16);
; 770  : 
; 771  :     // We are done
; 772  :     rc = TRUE;

  0009c	e3a06001	 mov         r6, #1
  000a0	e2833006	 add         r3, r3, #6
  000a4	e1c530b0	 strh        r3, [r5]
  000a8	e5e42006	 strb        r2, [r4, #6]!
  000ac	e3a030d5	 mov         r3, #0xD5
  000b0	e5c43001	 strb        r3, [r4, #1]
  000b4	e1d530b0	 ldrh        r3, [r5]
  000b8	e2833002	 add         r3, r3, #2
  000bc	e1c530b0	 strh        r3, [r5]
  000c0		 |$cleanUp$43719|
  000c0	e5973440	 ldr         r3, [r7, #0x440]

; 773  : 
; 774  : cleanUp:
; 775  :     KITL_RETAILMSG(ZONE_KITL_OAL, ("-KitlEthGetDevCfg(rc = %d)\r\n", rc));

  000c4	e3130a01	 tst         r3, #1, 20
  000c8	159f0010	 ldrne       r0, [pc, #0x10]
  000cc	11a01006	 movne       r1, r6
  000d0	1b000000	 blne        KITLOutputDebugString

; 776  :     return rc;
; 777  : }

  000d4	e1a00006	 mov         r0, r6
  000d8	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000dc	e12fff1e	 bx          lr
  000e0		 |$LN11@KitlEthGet@2|
  000e0		 |$LN12@KitlEthGet@2|
  000e0	00000000	 DCD         |??_C@_0BN@OHPDCAJH@?9KitlEthGetDevCfg?$CIrc?5?$DN?5?$CFd?$CJ?$AN?6?$AA@|
  000e4		 |$LN13@KitlEthGet@2|
  000e4	00000000	 DCD         |g_kitlEthState|
  000e8		 |$LN14@KitlEthGet@2|
  000e8	00000000	 DCD         |??_C@_0CI@LLEHHLED@?$CLKitlEthGetDevCfg?$CI0x?$CF08x?0?50x?$CF08x@|
  000ec		 |$LN15@KitlEthGet@2|
  000ec	00000000	 DCD         |dpCurSettings|
  000f0		 |$M44391|

			 ENDP  ; |KitlEthGetDevCfg|

	EXPORT	|??_C@_0BI@DJIGCCGG@?9KitlEthSend?$CIrc?5?$DN?5?$CFd?$CJ?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CA@ELPHLPBP@?$CBDriver?5Send?5failure?0?5retry?5?$CFu?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BL@MJDALEMH@?$CLKitlEthSend?$CI0x?$CF08x?0?5?$CFd?$CJ?$AN?6?$AA@| [ DATA ] ; `string'
	IMPORT	|VBridgeKGetOneTxBuffer|
	IMPORT	|VBridgeKGetOneTxBufferComplete|
	IMPORT	|VBridgeUCurrentPacketFilter|

  00000			 AREA	 |.pdata|, PDATA
|$T44431| DCD	|$LN35@KitlEthSen|
	DCD	0x40005d02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BI@DJIGCCGG@?9KitlEthSend?$CIrc?5?$DN?5?$CFd?$CJ?$AN?6?$AA@| DCB "-"
	DCB	"KitlEthSend(rc = %d)", 0xd, 0xa, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CA@ELPHLPBP@?$CBDriver?5Send?5failure?0?5retry?5?$CFu?6?$AA@| DCB "!"
	DCB	"Driver Send failure, retry %u", 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BL@MJDALEMH@?$CLKitlEthSend?$CI0x?$CF08x?0?5?$CFd?$CJ?$AN?6?$AA@| DCB "+"
	DCB	"KitlEthSend(0x%08x, %d)", 0xd, 0xa, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KitlEthSend| PROC

; 786  : {

  00000		 |$LN35@KitlEthSen|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M44428|
  00008	e1a08001	 mov         r8, r1
  0000c	e1a09000	 mov         r9, r0

; 787  :     UCHAR *pSendData;
; 788  :     ULONG sendLength;
; 789  :     USHORT code;
; 790  :     int   nRetries = 0;
; 791  : 
; 792  :     KITL_RETAILMSG(ZONE_SEND,  (
; 793  :         "+KitlEthSend(0x%08x, %d)\r\n", pData, length
; 794  :     ));

  00010	e59f7158	 ldr         r7, [pc, #0x158]
  00014	e3a05000	 mov         r5, #0
  00018	e5973440	 ldr         r3, [r7, #0x440]
  0001c	e3130010	 tst         r3, #0x10
  00020	159f0144	 ldrne       r0, [pc, #0x144]
  00024	11a02008	 movne       r2, r8
  00028	11a01009	 movne       r1, r9
  0002c	1b000000	 blne        KITLOutputDebugString

; 795  : 
; 796  :     // Update multicast addresses
; 797  :     if (g_kitlEthState.updateMCast) {

  00030	e59f4130	 ldr         r4, [pc, #0x130]
  00034	e5943040	 ldr         r3, [r4, #0x40]
  00038	e3530000	 cmp         r3, #0
  0003c	0a000008	 beq         |$LN29@KitlEthSen|

; 798  :         if (g_kitlEthState.pDriver->pfnMulticastList)

  00040	e5943000	 ldr         r3, [r4]
  00044	e5933028	 ldr         r3, [r3, #0x28]
  00048	e3530000	 cmp         r3, #0

; 799  :             g_kitlEthState.pDriver->pfnMulticastList(
; 800  :                 g_kitlEthState.deviceMCast, g_kitlEthState.deviceMCastSize
; 801  :             );

  0004c	15941044	 ldrne       r1, [r4, #0x44]
  00050	12840048	 addne       r0, r4, #0x48
  00054	11a0e00f	 movne       lr, pc
  00058	112fff13	 bxne        r3

; 802  :         g_kitlEthState.updateMCast = FALSE;

  0005c	e3a03000	 mov         r3, #0
  00060	e5843040	 str         r3, [r4, #0x40]
  00064		 |$LN29@KitlEthSen|

; 803  :     }
; 804  : 
; 805  :     // Update filter 
; 806  :     if (g_kitlEthState.updateFilter) {

  00064	e5943038	 ldr         r3, [r4, #0x38]
  00068	e3530000	 cmp         r3, #0
  0006c	0a000008	 beq         |$LL7@KitlEthSen|
  00070	e5943000	 ldr         r3, [r4]

; 807  :         // Update filter
; 808  :         g_kitlEthState.pDriver->pfnCurrentPacketFilter(
; 809  :             g_kitlEthState.deviceFilter
; 810  :         );

  00074	e594003c	 ldr         r0, [r4, #0x3C]
  00078	e5933024	 ldr         r3, [r3, #0x24]
  0007c	e1a0e00f	 mov         lr, pc
  00080	e12fff13	 bx          r3

; 811  :         // Tell VBRIDGE that there is new filter
; 812  :         VBridgeUCurrentPacketFilter(&g_kitlEthState.deviceFilter);

  00084	e284003c	 add         r0, r4, #0x3C
  00088	eb000000	 bl          VBridgeUCurrentPacketFilter

; 813  :         g_kitlEthState.updateFilter = FALSE;

  0008c	e3a03000	 mov         r3, #0
  00090	e5843038	 str         r3, [r4, #0x38]
  00094		 |$LL7@KitlEthSen|
  00094	e5943000	 ldr         r3, [r4]

; 814  :     }
; 815  : 
; 816  :     do {
; 817  :         code = g_kitlEthState.pDriver->pfnSendFrame(pData, length);

  00098	e1a01008	 mov         r1, r8
  0009c	e1a00009	 mov         r0, r9
  000a0	e593300c	 ldr         r3, [r3, #0xC]
  000a4	e1a0e00f	 mov         lr, pc
  000a8	e12fff13	 bx          r3
  000ac	e1a06800	 mov         r6, r0, lsl #16
  000b0	e1b06826	 movs        r6, r6, lsr #16

; 818  :         if (code == 0) {

  000b4	0a000008	 beq         |$LN25@KitlEthSen|

; 824  :                 }
; 825  :             }
; 826  :             break;
; 827  :         }
; 828  :         KITL_RETAILMSG(ZONE_ERROR, ("!Driver Send failure, retry %u\n",nRetries));

  000b8	e5973440	 ldr         r3, [r7, #0x440]
  000bc	e3130902	 tst         r3, #2, 18
  000c0	159f009c	 ldrne       r0, [pc, #0x9C]
  000c4	11a01005	 movne       r1, r5
  000c8	1b000000	 blne        KITLOutputDebugString

; 829  :     } while (nRetries ++ < 8);

  000cc	e3550008	 cmp         r5, #8
  000d0	e2855001	 add         r5, r5, #1
  000d4	baffffee	 blt         |$LL7@KitlEthSen|
  000d8	ea000012	 b           |$LN5@KitlEthSen|
  000dc		 |$LN25@KitlEthSen|

; 819  :             if (g_kitlEthState.flags & OAL_KITL_FLAGS_VMINI) {

  000dc	e5943004	 ldr         r3, [r4, #4]
  000e0	e3130008	 tst         r3, #8
  000e4	0a00000f	 beq         |$LN5@KitlEthSen|

; 820  :                 // Consume all the client packets.
; 821  :                 while (VBridgeKGetOneTxBuffer(&pSendData, &sendLength)) {

  000e8	ea000009	 b           |$LN32@KitlEthSen|
  000ec		 |$LL2@KitlEthSen|

; 822  :                     g_kitlEthState.pDriver->pfnSendFrame(pSendData, (USHORT)sendLength);

  000ec	e59d3004	 ldr         r3, [sp, #4]
  000f0	e5942000	 ldr         r2, [r4]
  000f4	e59d0000	 ldr         r0, [sp]
  000f8	e1a01803	 mov         r1, r3, lsl #16
  000fc	e592200c	 ldr         r2, [r2, #0xC]
  00100	e1a01821	 mov         r1, r1, lsr #16
  00104	e1a0e00f	 mov         lr, pc
  00108	e12fff12	 bx          r2

; 823  :                     VBridgeKGetOneTxBufferComplete(pSendData);

  0010c	e59d0000	 ldr         r0, [sp]
  00110	eb000000	 bl          VBridgeKGetOneTxBufferComplete
  00114		 |$LN32@KitlEthSen|
  00114	e28d1004	 add         r1, sp, #4
  00118	e28d0000	 add         r0, sp, #0
  0011c	eb000000	 bl          VBridgeKGetOneTxBuffer
  00120	e3500000	 cmp         r0, #0
  00124	1afffff0	 bne         |$LL2@KitlEthSen|
  00128		 |$LN5@KitlEthSen|

; 824  :                 }
; 825  :             }
; 826  :             break;
; 827  :         }
; 828  :         KITL_RETAILMSG(ZONE_ERROR, ("!Driver Send failure, retry %u\n",nRetries));

  00128	e5973440	 ldr         r3, [r7, #0x440]

; 830  : 
; 831  :     KITL_RETAILMSG(ZONE_SEND,  (
; 832  :         "-KitlEthSend(rc = %d)\r\n", code == 0));

  0012c	e3130010	 tst         r3, #0x10
  00130	0a000004	 beq         |$LN19@KitlEthSen|
  00134	e59f0024	 ldr         r0, [pc, #0x24]
  00138	e3560000	 cmp         r6, #0
  0013c	03a01001	 moveq       r1, #1
  00140	13a01000	 movne       r1, #0
  00144	eb000000	 bl          KITLOutputDebugString
  00148		 |$LN19@KitlEthSen|

; 833  :     return code == 0;

  00148	e3560000	 cmp         r6, #0
  0014c	03a00001	 moveq       r0, #1
  00150	13a00000	 movne       r0, #0

; 834  : }

  00154	e28dd008	 add         sp, sp, #8
  00158	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  0015c	e12fff1e	 bx          lr
  00160		 |$LN36@KitlEthSen|
  00160		 |$LN37@KitlEthSen|
  00160	00000000	 DCD         |??_C@_0BI@DJIGCCGG@?9KitlEthSend?$CIrc?5?$DN?5?$CFd?$CJ?$AN?6?$AA@|
  00164		 |$LN38@KitlEthSen|
  00164	00000000	 DCD         |??_C@_0CA@ELPHLPBP@?$CBDriver?5Send?5failure?0?5retry?5?$CFu?6?$AA@|
  00168		 |$LN39@KitlEthSen|
  00168	00000000	 DCD         |g_kitlEthState|
  0016c		 |$LN40@KitlEthSen|
  0016c	00000000	 DCD         |??_C@_0BL@MJDALEMH@?$CLKitlEthSend?$CI0x?$CF08x?0?5?$CFd?$CJ?$AN?6?$AA@|
  00170		 |$LN41@KitlEthSen|
  00170	00000000	 DCD         |dpCurSettings|
  00174		 |$M44429|

			 ENDP  ; |KitlEthSend|

	EXPORT	|??_C@_0BI@PEEPNADN@?9KitlEthRecv?$CIrc?5?$DN?5?$CFd?$CJ?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CD@HNBDALDE@?$CLKitlEthRecv?$CI0x?$CF08x?0?50x?$CF08x?9?$DO?$CFd?$CJ@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T44463| DCD	|$LN25@KitlEthRec|
	DCD	0x40005202

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BI@PEEPNADN@?9KitlEthRecv?$CIrc?5?$DN?5?$CFd?$CJ?$AN?6?$AA@| DCB "-"
	DCB	"KitlEthRecv(rc = %d)", 0xd, 0xa, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CD@HNBDALDE@?$CLKitlEthRecv?$CI0x?$CF08x?0?50x?$CF08x?9?$DO?$CFd?$CJ@| DCB "+"
	DCB	"KitlEthRecv(0x%08x, 0x%08x->%d)", 0xd, 0xa, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KitlEthRecv| PROC

; 843  : {

  00000		 |$LN25@KitlEthRec|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M44460|
  00008	e1a05001	 mov         r5, r1
  0000c	e1a06000	 mov         r6, r0

; 844  :     USHORT code;
; 845  :     UCHAR *pSendData;
; 846  :     ULONG sendLength;
; 847  : 
; 848  :     KITL_RETAILMSG(ZONE_RECV,  (
; 849  :         "+KitlEthRecv(0x%08x, 0x%08x->%d)\r\n", pData, pLength, *pLength
; 850  :     ));

  00010	e59f712c	 ldr         r7, [pc, #0x12C]
  00014	e5973440	 ldr         r3, [r7, #0x440]
  00018	e3130020	 tst         r3, #0x20
  0001c	11d530b0	 ldrneh      r3, [r5]
  00020	159f0118	 ldrne       r0, [pc, #0x118]
  00024	11a02005	 movne       r2, r5
  00028	11a01006	 movne       r1, r6
  0002c	1b000000	 blne        KITLOutputDebugString

; 851  : 
; 852  :     // Update multicast addresses
; 853  :     if (g_kitlEthState.updateMCast) {

  00030	e59f4104	 ldr         r4, [pc, #0x104]
  00034	e5943040	 ldr         r3, [r4, #0x40]
  00038	e3530000	 cmp         r3, #0
  0003c	0a000008	 beq         |$LN19@KitlEthRec|

; 854  :         if (g_kitlEthState.pDriver->pfnMulticastList)

  00040	e5943000	 ldr         r3, [r4]
  00044	e5933028	 ldr         r3, [r3, #0x28]
  00048	e3530000	 cmp         r3, #0

; 855  :             g_kitlEthState.pDriver->pfnMulticastList(
; 856  :                 g_kitlEthState.deviceMCast, g_kitlEthState.deviceMCastSize
; 857  :             );

  0004c	15941044	 ldrne       r1, [r4, #0x44]
  00050	12840048	 addne       r0, r4, #0x48
  00054	11a0e00f	 movne       lr, pc
  00058	112fff13	 bxne        r3

; 858  :         g_kitlEthState.updateMCast = FALSE;

  0005c	e3a03000	 mov         r3, #0
  00060	e5843040	 str         r3, [r4, #0x40]
  00064		 |$LN19@KitlEthRec|

; 859  :     }
; 860  : 
; 861  :     // Update filter 
; 862  :     if (g_kitlEthState.updateFilter) {

  00064	e5943038	 ldr         r3, [r4, #0x38]
  00068	e3530000	 cmp         r3, #0
  0006c	0a000008	 beq         |$LN4@KitlEthRec|
  00070	e5943000	 ldr         r3, [r4]

; 863  :         // Update filter
; 864  :         g_kitlEthState.pDriver->pfnCurrentPacketFilter(
; 865  :             g_kitlEthState.deviceFilter
; 866  :         );

  00074	e594003c	 ldr         r0, [r4, #0x3C]
  00078	e5933024	 ldr         r3, [r3, #0x24]
  0007c	e1a0e00f	 mov         lr, pc
  00080	e12fff13	 bx          r3

; 867  :         // Tell VBRIDGE that there is new filter
; 868  :         VBridgeUCurrentPacketFilter(&g_kitlEthState.deviceFilter);

  00084	e284003c	 add         r0, r4, #0x3C
  00088	eb000000	 bl          VBridgeUCurrentPacketFilter

; 869  :         g_kitlEthState.updateFilter = FALSE;

  0008c	e3a03000	 mov         r3, #0
  00090	e5843038	 str         r3, [r4, #0x38]
  00094		 |$LN4@KitlEthRec|

; 870  :     }
; 871  : 
; 872  :     // When VMINI is active send all queued VMINI packets
; 873  :     if ((g_kitlEthState.flags & OAL_KITL_FLAGS_VMINI) != 0) {

  00094	e5943004	 ldr         r3, [r4, #4]
  00098	e3130008	 tst         r3, #8
  0009c	0a00000f	 beq         |$LN20@KitlEthRec|

; 874  :         // First send all VMINI packets
; 875  :         while (VBridgeKGetOneTxBuffer(&pSendData, &sendLength)) {

  000a0	ea000009	 b           |$LN22@KitlEthRec|
  000a4		 |$LL2@KitlEthRec|

; 876  :             g_kitlEthState.pDriver->pfnSendFrame(pSendData, (USHORT)sendLength);

  000a4	e59d3004	 ldr         r3, [sp, #4]
  000a8	e5942000	 ldr         r2, [r4]
  000ac	e59d0000	 ldr         r0, [sp]
  000b0	e1a01803	 mov         r1, r3, lsl #16
  000b4	e592200c	 ldr         r2, [r2, #0xC]
  000b8	e1a01821	 mov         r1, r1, lsr #16
  000bc	e1a0e00f	 mov         lr, pc
  000c0	e12fff12	 bx          r2

; 877  :             VBridgeKGetOneTxBufferComplete(pSendData);

  000c4	e59d0000	 ldr         r0, [sp]
  000c8	eb000000	 bl          VBridgeKGetOneTxBufferComplete
  000cc		 |$LN22@KitlEthRec|
  000cc	e28d1004	 add         r1, sp, #4
  000d0	e28d0000	 add         r0, sp, #0
  000d4	eb000000	 bl          VBridgeKGetOneTxBuffer
  000d8	e3500000	 cmp         r0, #0
  000dc	1afffff0	 bne         |$LL2@KitlEthRec|
  000e0		 |$LN20@KitlEthRec|

; 854  :         if (g_kitlEthState.pDriver->pfnMulticastList)

  000e0	e5943000	 ldr         r3, [r4]

; 878  :         }
; 879  :     }
; 880  : 
; 881  :     // Now get packet
; 882  :     code = g_kitlEthState.pDriver->pfnGetFrame(pData, pLength);

  000e4	e1a01005	 mov         r1, r5
  000e8	e1a00006	 mov         r0, r6
  000ec	e5933010	 ldr         r3, [r3, #0x10]
  000f0	e1a0e00f	 mov         lr, pc
  000f4	e12fff13	 bx          r3

; 883  : 
; 884  :     KITL_RETAILMSG(ZONE_RECV, ("-KitlEthRecv(rc = %d)\r\n", code > 0));

  000f8	e5973440	 ldr         r3, [r7, #0x440]
  000fc	e1a04800	 mov         r4, r0, lsl #16
  00100	e1a04824	 mov         r4, r4, lsr #16
  00104	e3130020	 tst         r3, #0x20
  00108	0a000004	 beq         |$LN13@KitlEthRec|
  0010c	e59f0024	 ldr         r0, [pc, #0x24]
  00110	e3540000	 cmp         r4, #0
  00114	13a01001	 movne       r1, #1
  00118	03a01000	 moveq       r1, #0
  0011c	eb000000	 bl          KITLOutputDebugString
  00120		 |$LN13@KitlEthRec|

; 885  :     return code > 0;

  00120	e3540000	 cmp         r4, #0
  00124	13a00001	 movne       r0, #1
  00128	03a00000	 moveq       r0, #0

; 886  : }

  0012c	e28dd008	 add         sp, sp, #8
  00130	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00134	e12fff1e	 bx          lr
  00138		 |$LN26@KitlEthRec|
  00138		 |$LN27@KitlEthRec|
  00138	00000000	 DCD         |??_C@_0BI@PEEPNADN@?9KitlEthRecv?$CIrc?5?$DN?5?$CFd?$CJ?$AN?6?$AA@|
  0013c		 |$LN28@KitlEthRec|
  0013c	00000000	 DCD         |g_kitlEthState|
  00140		 |$LN29@KitlEthRec|
  00140	00000000	 DCD         |??_C@_0CD@HNBDALDE@?$CLKitlEthRecv?$CI0x?$CF08x?0?50x?$CF08x?9?$DO?$CFd?$CJ@|
  00144		 |$LN30@KitlEthRec|
  00144	00000000	 DCD         |dpCurSettings|
  00148		 |$M44461|

			 ENDP  ; |KitlEthRecv|

	EXPORT	|??_C@_0BE@NDAHGBJL@?9KitlEthEnableInt?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BI@OLDCGLHD@?$CLKitlEthEnableInt?$CI?$CFd?$CJ?$AN?6?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T44480| DCD	|$LN11@KitlEthEna|
	DCD	0x40001d01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BE@NDAHGBJL@?9KitlEthEnableInt?$AN?6?$AA@| DCB "-KitlEthEnableInt"
	DCB	0xd, 0xa, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BI@OLDCGLHD@?$CLKitlEthEnableInt?$CI?$CFd?$CJ?$AN?6?$AA@| DCB "+K"
	DCB	"itlEthEnableInt(%d)", 0xd, 0xa, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KitlEthEnableInt| PROC

; 898  : {

  00000		 |$LN11@KitlEthEna|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44477|
  00004	e1a04000	 mov         r4, r0

; 899  :     KITL_RETAILMSG(ZONE_KITL_OAL, ("+KitlEthEnableInt(%d)\r\n", enable));

  00008	e59f5060	 ldr         r5, [pc, #0x60]
  0000c	e5953440	 ldr         r3, [r5, #0x440]
  00010	e3130a01	 tst         r3, #1, 20
  00014	159f0050	 ldrne       r0, [pc, #0x50]
  00018	11a01004	 movne       r1, r4
  0001c	1b000000	 blne        KITLOutputDebugString

; 900  :     if (enable) {
; 901  :         g_kitlEthState.pDriver->pfnEnableInts();

  00020	e59f3040	 ldr         r3, [pc, #0x40]
  00024	e3540000	 cmp         r4, #0
  00028	e5933000	 ldr         r3, [r3]
  0002c	0a000003	 beq         |$LN2@KitlEthEna|
  00030	e5933014	 ldr         r3, [r3, #0x14]
  00034	e1a0e00f	 mov         lr, pc
  00038	e12fff13	 bx          r3

; 902  :     } else {

  0003c	ea000002	 b           |$LN1@KitlEthEna|
  00040		 |$LN2@KitlEthEna|

; 903  :         g_kitlEthState.pDriver->pfnDisableInts();

  00040	e5933018	 ldr         r3, [r3, #0x18]
  00044	e1a0e00f	 mov         lr, pc
  00048	e12fff13	 bx          r3
  0004c		 |$LN1@KitlEthEna|

; 904  :     }
; 905  :     KITL_RETAILMSG(ZONE_KITL_OAL, ("-KitlEthEnableInt\r\n"));

  0004c	e5953440	 ldr         r3, [r5, #0x440]
  00050	e3130a01	 tst         r3, #1, 20
  00054	159f0008	 ldrne       r0, [pc, #8]
  00058	1b000000	 blne        KITLOutputDebugString

; 906  : }

  0005c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$LN12@KitlEthEna|
  00064		 |$LN13@KitlEthEna|
  00064	00000000	 DCD         |??_C@_0BE@NDAHGBJL@?9KitlEthEnableInt?$AN?6?$AA@|
  00068		 |$LN14@KitlEthEna|
  00068	00000000	 DCD         |g_kitlEthState|
  0006c		 |$LN15@KitlEthEna|
  0006c	00000000	 DCD         |??_C@_0BI@OLDCGLHD@?$CLKitlEthEnableInt?$CI?$CFd?$CJ?$AN?6?$AA@|
  00070		 |$LN16@KitlEthEna|
  00070	00000000	 DCD         |dpCurSettings|
  00074		 |$M44478|

			 ENDP  ; |KitlEthEnableInt|

	EXPORT	|OALIoCtlVBridge|
	EXPORT	|??_C@_0BM@FALEIOIG@?9OALIoCtlVBridge?$CIrc?5?$DN?5?$CFd?$CJ?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BP@BIAFCCDM@?$CLOALIoCtlVBridge?$CI0x?$CF08x?0?4?4?4?$CJ?$AN?6?$AA@| [ DATA ] ; `string'
	IMPORT	|VBridgeUWildCard|
	IMPORT	|NKSetLastError|
	IMPORT	|VBridgeUGetEDBGMac|
	IMPORT	|VBridgeUGetOneTxPacket|
	IMPORT	|VBridgeUGetOneTxPacketComplete|
	IMPORT	|VBridgeUGetOneRxPacket|
	IMPORT	|VBridgeUGetOneRxPacketComplete|

  00000			 AREA	 |.pdata|, PDATA
|$T44505| DCD	|$LN25@OALIoCtlVB|
	DCD	0x40007102

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BM@FALEIOIG@?9OALIoCtlVBridge?$CIrc?5?$DN?5?$CFd?$CJ?$AN?6?$AA@| DCB "-"
	DCB	"OALIoCtlVBridge(rc = %d)", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BP@BIAFCCDM@?$CLOALIoCtlVBridge?$CI0x?$CF08x?0?4?4?4?$CJ?$AN?6?$AA@| DCB "+"
	DCB	"OALIoCtlVBridge(0x%08x,...)", 0xd, 0xa, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALIoCtlVBridge| PROC

; 917  : ) {

  00000		 |$LN25@OALIoCtlVB|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M44502|
  00008	e1a08003	 mov         r8, r3
  0000c	e1a06002	 mov         r6, r2
  00010	e1a07001	 mov         r7, r1
  00014	e1a04000	 mov         r4, r0

; 918  :     BOOL rc = TRUE;
; 919  : 
; 920  :     KITL_RETAILMSG(ZONE_SEND|ZONE_RECV, ("+OALIoCtlVBridge(0x%08x,...)\r\n", code));

  00018	e59f91a0	 ldr         r9, [pc, #0x1A0]
  0001c	e3a05001	 mov         r5, #1
  00020	e599e440	 ldr         lr, [r9, #0x440]
  00024	e31e0030	 tst         lr, #0x30
  00028	159f018c	 ldrne       r0, [pc, #0x18C]
  0002c	11a01004	 movne       r1, r4
  00030	1b000000	 blne        KITLOutputDebugString

; 921  : 
; 922  :     switch (code) {

  00034	e59f317c	 ldr         r3, [pc, #0x17C]
  00038	e1540003	 cmp         r4, r3
  0003c	8a000020	 bhi         |$LN19@OALIoCtlVB|
  00040	0a00001c	 beq         |$LN8@OALIoCtlVB|
  00044	e59fe168	 ldr         lr, [pc, #0x168]
  00048	e154000e	 cmp         r4, lr
  0004c	0a000014	 beq         |$LN12@OALIoCtlVB|
  00050	e59f3158	 ldr         r3, [pc, #0x158]
  00054	e1540003	 cmp         r4, r3
  00058	0a00000d	 beq         |$LN11@OALIoCtlVB|
  0005c	e59f3148	 ldr         r3, [pc, #0x148]
  00060	e1540003	 cmp         r4, r3
  00064	0a000005	 beq         |$LN10@OALIoCtlVB|
  00068	e59f3138	 ldr         r3, [pc, #0x138]
  0006c	e1540003	 cmp         r4, r3
  00070	1a00001f	 bne         |$LN1@OALIoCtlVB|

; 933  :         break;
; 934  : 
; 935  :     case IOCTL_VBRIDGE_GET_RX_PACKET_COMPLETE:
; 936  :         VBridgeUGetOneRxPacketComplete((UINT8*)pInBuffer);

  00074	e1a00007	 mov         r0, r7
  00078	eb000000	 bl          VBridgeUGetOneRxPacketComplete

; 937  :         break;

  0007c	ea00003a	 b           |$LN2@OALIoCtlVB|
  00080		 |$LN10@OALIoCtlVB|

; 930  : 
; 931  :     case IOCTL_VBRIDGE_GET_RX_PACKET:
; 932  :         rc = VBridgeUGetOneRxPacket((UINT8**)pOutBuffer, pOutSize);

  00080	e59d1024	 ldr         r1, [sp, #0x24]
  00084	e1a00008	 mov         r0, r8
  00088	eb000000	 bl          VBridgeUGetOneRxPacket
  0008c	e1a05000	 mov         r5, r0
  00090	ea000035	 b           |$LN2@OALIoCtlVB|
  00094		 |$LN11@OALIoCtlVB|

; 926  : 
; 927  :     case IOCTL_VBRIDGE_GET_TX_PACKET_COMPLETE:
; 928  :         VBridgeUGetOneTxPacketComplete((UINT8*)pInBuffer, inSize);

  00094	e1a01006	 mov         r1, r6
  00098	e1a00007	 mov         r0, r7
  0009c	eb000000	 bl          VBridgeUGetOneTxPacketComplete

; 929  :         break;

  000a0	ea000031	 b           |$LN2@OALIoCtlVB|
  000a4		 |$LN12@OALIoCtlVB|

; 923  :     case IOCTL_VBRIDGE_GET_TX_PACKET:
; 924  :         rc = VBridgeUGetOneTxPacket((UINT8**)pOutBuffer, inSize);

  000a4	e1a01006	 mov         r1, r6
  000a8	e1a00008	 mov         r0, r8
  000ac	eb000000	 bl          VBridgeUGetOneTxPacket
  000b0	e1a05000	 mov         r5, r0

; 925  :         break;

  000b4	ea00002c	 b           |$LN2@OALIoCtlVB|
  000b8		 |$LN8@OALIoCtlVB|

; 938  : 
; 939  :     case IOCTL_VBRIDGE_GET_ETHERNET_MAC:
; 940  :         VBridgeUGetEDBGMac((UINT8*)pOutBuffer);

  000b8	e1a00008	 mov         r0, r8
  000bc	eb000000	 bl          VBridgeUGetEDBGMac

; 941  :         break;

  000c0	ea000029	 b           |$LN2@OALIoCtlVB|
  000c4		 |$LN19@OALIoCtlVB|

; 921  : 
; 922  :     switch (code) {

  000c4	e59f30d8	 ldr         r3, [pc, #0xD8]
  000c8	e1540003	 cmp         r4, r3
  000cc	0a000026	 beq         |$LN2@OALIoCtlVB|
  000d0	e59f30c8	 ldr         r3, [pc, #0xC8]
  000d4	e1540003	 cmp         r4, r3
  000d8	0a00001e	 beq         |$LN7@OALIoCtlVB|
  000dc	e59f30b8	 ldr         r3, [pc, #0xB8]
  000e0	e1540003	 cmp         r4, r3
  000e4	0a00000f	 beq         |$LN6@OALIoCtlVB|
  000e8	e59f30a8	 ldr         r3, [pc, #0xA8]
  000ec	e1540003	 cmp         r4, r3
  000f0	0a000003	 beq         |$LN3@OALIoCtlVB|
  000f4		 |$LN1@OALIoCtlVB|

; 962  :         break;
; 963  : 
; 964  :     case IOCTL_VBRIDGE_SHARED_ETHERNET:
; 965  :         break;
; 966  : 
; 967  :     default:
; 968  :         NKSetLastError (ERROR_NOT_SUPPORTED);

  000f4	e3a00032	 mov         r0, #0x32
  000f8	eb000000	 bl          NKSetLastError
  000fc		 |$LN5@OALIoCtlVB|

; 969  :         rc = FALSE;

  000fc	e3a05000	 mov         r5, #0
  00100	ea000019	 b           |$LN2@OALIoCtlVB|
  00104		 |$LN3@OALIoCtlVB|

; 954  :             rc = FALSE;
; 955  :         }
; 956  :         break;
; 957  : 
; 958  :     case IOCTL_VBRIDGE_WILD_CARD:
; 959  :         rc = VBridgeUWildCard(
; 960  :             pInBuffer, inSize, pOutBuffer, outSize, pOutSize
; 961  :         );

  00104	e59d1024	 ldr         r1, [sp, #0x24]
  00108	e59d3020	 ldr         r3, [sp, #0x20]
  0010c	e1a02008	 mov         r2, r8
  00110	e58d1000	 str         r1, [sp]
  00114	e1a01006	 mov         r1, r6
  00118	e1a00007	 mov         r0, r7
  0011c	eb000000	 bl          VBridgeUWildCard
  00120	e1a05000	 mov         r5, r0
  00124	ea000010	 b           |$LN2@OALIoCtlVB|
  00128		 |$LN6@OALIoCtlVB|

; 946  :         break;
; 947  : 
; 948  :     case IOCTL_VBRIDGE_802_3_MULTICAST_LIST:
; 949  :         if (inSize * 6 <= sizeof(g_kitlEthState.deviceMCast)) {

  00128	e0863086	 add         r3, r6, r6, lsl #1
  0012c	e1a02083	 mov         r2, r3, lsl #1
  00130	e35200c0	 cmp         r2, #0xC0
  00134	8afffff0	 bhi         |$LN5@OALIoCtlVB|

; 950  :             memcpy(g_kitlEthState.deviceMCast, pInBuffer, inSize * 6);

  00138	e59f4054	 ldr         r4, [pc, #0x54]
  0013c	e1a01007	 mov         r1, r7
  00140	e2840048	 add         r0, r4, #0x48
  00144	eb000000	 bl          memcpy

; 951  :             g_kitlEthState.deviceMCastSize = inSize;
; 952  :             g_kitlEthState.updateMCast = TRUE;

  00148	e3a03001	 mov         r3, #1
  0014c	e5846044	 str         r6, [r4, #0x44]
  00150	e5843040	 str         r3, [r4, #0x40]

; 953  :         } else {

  00154	ea000004	 b           |$LN2@OALIoCtlVB|
  00158		 |$LN7@OALIoCtlVB|

; 942  : 
; 943  :     case IOCTL_VBRIDGE_CURRENT_PACKET_FILTER:
; 944  :         g_kitlEthState.deviceFilter = *(UINT32*)pInBuffer;

  00158	e59f2034	 ldr         r2, [pc, #0x34]
  0015c	e5973000	 ldr         r3, [r7]

; 945  :         g_kitlEthState.updateFilter = TRUE;

  00160	e3a01001	 mov         r1, #1
  00164	e582303c	 str         r3, [r2, #0x3C]
  00168	e5821038	 str         r1, [r2, #0x38]
  0016c		 |$LN2@OALIoCtlVB|
  0016c	e5993440	 ldr         r3, [r9, #0x440]

; 970  :     }
; 971  : 
; 972  :     KITL_RETAILMSG(ZONE_SEND|ZONE_RECV, ("-OALIoCtlVBridge(rc = %d)\r\n", rc));

  00170	e3130030	 tst         r3, #0x30
  00174	159f0014	 ldrne       r0, [pc, #0x14]
  00178	11a01005	 movne       r1, r5
  0017c	1b000000	 blne        KITLOutputDebugString

; 973  :     return rc;
; 974  : }

  00180	e1a00005	 mov         r0, r5
  00184	e28dd004	 add         sp, sp, #4
  00188	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  0018c	e12fff1e	 bx          lr
  00190		 |$LN26@OALIoCtlVB|
  00190		 |$LN27@OALIoCtlVB|
  00190	00000000	 DCD         |??_C@_0BM@FALEIOIG@?9OALIoCtlVBridge?$CIrc?5?$DN?5?$CFd?$CJ?$AN?6?$AA@|
  00194		 |$LN28@OALIoCtlVB|
  00194	00000000	 DCD         |g_kitlEthState|
  00198		 |$LN29@OALIoCtlVB|
  00198	0101009c	 DCD         0x101009c
  0019c		 |$LN30@OALIoCtlVB|
  0019c	01010088	 DCD         0x1010088
  001a0		 |$LN31@OALIoCtlVB|
  001a0	01010084	 DCD         0x1010084
  001a4		 |$LN32@OALIoCtlVB|
  001a4	01010080	 DCD         0x1010080
  001a8		 |$LN33@OALIoCtlVB|
  001a8	01010074	 DCD         0x1010074
  001ac		 |$LN34@OALIoCtlVB|
  001ac	01010070	 DCD         0x1010070
  001b0		 |$LN35@OALIoCtlVB|
  001b0	0101006c	 DCD         0x101006c
  001b4		 |$LN36@OALIoCtlVB|
  001b4	01010068	 DCD         0x1010068
  001b8		 |$LN37@OALIoCtlVB|
  001b8	01010078	 DCD         0x1010078
  001bc		 |$LN38@OALIoCtlVB|
  001bc	00000000	 DCD         |??_C@_0BP@BIAFCCDM@?$CLOALIoCtlVBridge?$CI0x?$CF08x?0?4?4?4?$CJ?$AN?6?$AA@|
  001c0		 |$LN39@OALIoCtlVB|
  001c0	00000000	 DCD         |dpCurSettings|
  001c4		 |$M44503|

			 ENDP  ; |OALIoCtlVBridge|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|??_C@_0CF@CNPGAGEH@KITL?3?5DHCP?5get?1renew?5device?5IP?3?5@| [ DATA ] ; `string'
	IMPORT	|OALGetTickCount|

  00000			 AREA	 |.pdata|, PDATA
|$T44564| DCD	|$LN50@GetAddress|
	DCD	0xc000a002

  00000			 AREA	 |.xdata|, DATA
|$T44560| DCD	0xffffffd8

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CF@CNPGAGEH@KITL?3?5DHCP?5get?1renew?5device?5IP?3?5@| DCB "KITL:"
	DCB	" DHCP get/renew device IP: %s", 0xd, 0xa, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T44560|

  00008		 |GetAddressDHCP| PROC

; 350  : {

  00008		 |$LN50@GetAddress|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd010	 sub         sp, sp, #0x10
  00010		 |$M44561|
  00010	e3500000	 cmp         r0, #0
  00014	e59f3268	 ldr         r3, [pc, #0x268]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d300c	 str         r3, [sp, #0xC]

; 351  :     UINT32 startTime, attempts;
; 352  :     UINT16 size;
; 353  :     UINT8 mac[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

  00020	e3a030ff	 mov         r3, #0xFF
  00024	e5cd3004	 strb        r3, [sp, #4]

; 354  : 
; 355  : 
; 356  :     // If there is already IP adress, try first renew it
; 357  :     if (ip != 0) {

  00028	e3a03c75	 mov         r3, #0x75, 24
  0002c	e3836030	 orr         r6, r3, #0x30
  00030	e3a040ff	 mov         r4, #0xFF
  00034	e3a03c05	 mov         r3, #5, 24
  00038	e3a020ff	 mov         r2, #0xFF
  0003c	e3a010ff	 mov         r1, #0xFF
  00040	e3a000ff	 mov         r0, #0xFF
  00044	e3a0e0ff	 mov         lr, #0xFF
  00048	e5cd4009	 strb        r4, [sp, #9]
  0004c	e59f422c	 ldr         r4, [pc, #0x22C]
  00050	e38380ec	 orr         r8, r3, #0xEC
  00054	e5cd2005	 strb        r2, [sp, #5]
  00058	e5cd1006	 strb        r1, [sp, #6]
  0005c	e5cd0007	 strb        r0, [sp, #7]
  00060	e5cde008	 strb        lr, [sp, #8]
  00064	0a00001c	 beq         |$LN14@GetAddress|

; 358  :         // Send request
; 359  :         SendDHCP(DHCP_REQUEST, 0);

  00068	e3a01000	 mov         r1, #0
  0006c	e3a00003	 mov         r0, #3
  00070	eb000000	 bl          SendDHCP

; 360  : 
; 361  :         g_kitlEthState.dhcpState = DHCP_REQUESTING;

  00074	e3a03002	 mov         r3, #2
  00078	e5843024	 str         r3, [r4, #0x24]

; 362  :         // Wait until DHCP gets address or timeout
; 363  :         startTime = OALGetTickCount();

  0007c	eb000000	 bl          OALGetTickCount
  00080	e1a05000	 mov         r5, r0

; 364  :         while ((OALGetTickCount() - startTime) < DHCP_TIMEOUT) {

  00084	ea00000d	 b           |$LN15@GetAddress|
  00088		 |$LL18@GetAddress|

; 365  :             size = sizeof(g_kitlEthState.packet);
; 366  :             if (!g_kitlEthState.pfnRecv(g_kitlEthState.packet, &size)) continue;

  00088	e5943034	 ldr         r3, [r4, #0x34]
  0008c	e28d1000	 add         r1, sp, #0
  00090	e2840f42	 add         r0, r4, #0x42, 30
  00094	e1cd80b0	 strh        r8, [sp]
  00098	e1a0e00f	 mov         lr, pc
  0009c	e12fff13	 bx          r3
  000a0	e3500000	 cmp         r0, #0
  000a4	0a000005	 beq         |$LN15@GetAddress|

; 367  :             KitlEthDecode(g_kitlEthState.packet, &size);

  000a8	e28d1000	 add         r1, sp, #0
  000ac	e2840f42	 add         r0, r4, #0x42, 30
  000b0	eb000000	 bl          KitlEthDecode

; 368  :             if (g_kitlEthState.dhcpState == DHCP_BOUND) break;

  000b4	e5943024	 ldr         r3, [r4, #0x24]
  000b8	e3530000	 cmp         r3, #0
  000bc	0a00005c	 beq         |$cleanUp$43469|
  000c0		 |$LN15@GetAddress|

; 364  :         while ((OALGetTickCount() - startTime) < DHCP_TIMEOUT) {

  000c0	eb000000	 bl          OALGetTickCount
  000c4	e0403005	 sub         r3, r0, r5
  000c8	e1530006	 cmp         r3, r6
  000cc	3affffed	 bcc         |$LL18@GetAddress|

; 369  :         }
; 370  :         // If we end in BOUND state we renew it...
; 371  :         if (g_kitlEthState.dhcpState == DHCP_BOUND) goto cleanUp;

  000d0	e5943024	 ldr         r3, [r4, #0x24]
  000d4	e3530000	 cmp         r3, #0
  000d8	0a000055	 beq         |$cleanUp$43469|
  000dc		 |$LN14@GetAddress|

; 372  :     }
; 373  : 
; 374  :     // Allocate new IP address
; 375  :     attempts = 0;

  000dc	e3a03c06	 mov         r3, #6, 24
  000e0	e3839008	 orr         r9, r3, #8
  000e4	e3a03000	 mov         r3, #0
  000e8	e3a07000	 mov         r7, #0
  000ec	e3a0b000	 mov         r11, #0
  000f0	e3a05001	 mov         r5, #1
  000f4	e3a0a000	 mov         r10, #0
  000f8		 |$LL13@GetAddress|

; 376  :     while (attempts++ < 3) {
; 377  : 
; 378  :         // Reset device and server IP
; 379  :         g_kitlEthState.deviceIP = 0;

  000f8	e584b010	 str         r11, [r4, #0x10]

; 380  :         g_kitlEthState.dhcpServerIP = 0;
; 381  : 
; 382  :         // Send DHCP discover message
; 383  :         SendDHCP(DHCP_DISCOVER, 0);

  000fc	e3a01000	 mov         r1, #0
  00100	e3a00001	 mov         r0, #1
  00104	e5843028	 str         r3, [r4, #0x28]
  00108	e2877001	 add         r7, r7, #1
  0010c	eb000000	 bl          SendDHCP

; 384  :         g_kitlEthState.dhcpState = DHCP_SELECTING;

  00110	e5845024	 str         r5, [r4, #0x24]

; 385  : 
; 386  :         // Wait until DHCP gets address or timeout
; 387  :         startTime = OALGetTickCount();

  00114	eb000000	 bl          OALGetTickCount
  00118	e1a05000	 mov         r5, r0

; 388  :         while ((OALGetTickCount() - startTime) < DHCP_TIMEOUT) {

  0011c	ea00000d	 b           |$LN8@GetAddress|
  00120		 |$LL11@GetAddress|

; 389  :             size = sizeof(g_kitlEthState.packet);
; 390  :             if (!g_kitlEthState.pfnRecv(g_kitlEthState.packet, &size)) continue;

  00120	e5943034	 ldr         r3, [r4, #0x34]
  00124	e28d1000	 add         r1, sp, #0
  00128	e2840f42	 add         r0, r4, #0x42, 30
  0012c	e1cd80b0	 strh        r8, [sp]
  00130	e1a0e00f	 mov         lr, pc
  00134	e12fff13	 bx          r3
  00138	e3500000	 cmp         r0, #0
  0013c	0a000005	 beq         |$LN8@GetAddress|

; 391  :             KitlEthDecode(g_kitlEthState.packet, &size);

  00140	e28d1000	 add         r1, sp, #0
  00144	e2840f42	 add         r0, r4, #0x42, 30
  00148	eb000000	 bl          KitlEthDecode

; 392  :             if (g_kitlEthState.dhcpState == DHCP_BOUND) break;

  0014c	e5943024	 ldr         r3, [r4, #0x24]
  00150	e3530000	 cmp         r3, #0
  00154	0a000008	 beq         |$LN7@GetAddress|
  00158		 |$LN8@GetAddress|

; 388  :         while ((OALGetTickCount() - startTime) < DHCP_TIMEOUT) {

  00158	eb000000	 bl          OALGetTickCount
  0015c	e0403005	 sub         r3, r0, r5
  00160	e1530006	 cmp         r3, r6
  00164	3affffed	 bcc         |$LL11@GetAddress|

; 393  :         }
; 394  : 
; 395  :         // If there was timeout try start DHCP againg with new transaction id
; 396  :         if (g_kitlEthState.dhcpState != DHCP_BOUND) {

  00168	e5943024	 ldr         r3, [r4, #0x24]
  0016c	e3530000	 cmp         r3, #0

; 397  :             g_kitlEthState.dhcpXId += 0x00080000;

  00170	1594302c	 ldrne       r3, [r4, #0x2C]
  00174	12833702	 addne       r3, r3, #2, 14
  00178	1a000028	 bne         |$LN46@GetAddress|
  0017c		 |$LN7@GetAddress|

; 399  :         }
; 400  : 
; 401  :         // We get address, verify if it isn't used by somebody else...
; 402  :         SendARP(ARP_REQUEST, mac, g_kitlEthState.deviceIP);

  0017c	e5942010	 ldr         r2, [r4, #0x10]
  00180	e28d1004	 add         r1, sp, #4
  00184	e3a00001	 mov         r0, #1
  00188	eb000000	 bl          SendARP

; 403  :         startTime = OALGetTickCount();

  0018c	eb000000	 bl          OALGetTickCount
  00190	e1a05000	 mov         r5, r0

; 404  :         while ((OALGetTickCount() - startTime) < ARP_TIMEOUT) {

  00194	ea000013	 b           |$LN3@GetAddress|
  00198		 |$LL6@GetAddress|

; 405  :             size = sizeof(g_kitlEthState.packet);
; 406  :             if (g_kitlEthState.pfnRecv(g_kitlEthState.packet, &size)) {

  00198	e5943034	 ldr         r3, [r4, #0x34]
  0019c	e28d1000	 add         r1, sp, #0
  001a0	e2840f42	 add         r0, r4, #0x42, 30
  001a4	e1cd80b0	 strh        r8, [sp]
  001a8	e1a0e00f	 mov         lr, pc
  001ac	e12fff13	 bx          r3
  001b0	e3500000	 cmp         r0, #0
  001b4	0a00000b	 beq         |$LN3@GetAddress|

; 407  :                 if (GetOpARP(g_kitlEthState.packet, size) == ARP_RESPONSE) {

  001b8	e2843c01	 add         r3, r4, #1, 24
  001bc	e1d331b4	 ldrh        r3, [r3, #0x14]
  001c0	e1530009	 cmp         r3, r9
  001c4	13a03000	 movne       r3, #0
  001c8	02843c01	 addeq       r3, r4, #1, 24
  001cc	01d331bc	 ldreqh      r3, [r3, #0x1C]
  001d0	05d4211d	 ldreqb      r2, [r4, #0x11D]
  001d4	01823403	 orreq       r3, r2, r3, lsl #8
  001d8	01a03803	 moveq       r3, r3, lsl #16
  001dc	01a03823	 moveq       r3, r3, lsr #16
  001e0	e3530002	 cmp         r3, #2
  001e4	0a000004	 beq         |$LN36@GetAddress|
  001e8		 |$LN3@GetAddress|

; 404  :         while ((OALGetTickCount() - startTime) < ARP_TIMEOUT) {

  001e8	eb000000	 bl          OALGetTickCount
  001ec	e0403005	 sub         r3, r0, r5
  001f0	e3530e7d	 cmp         r3, #0x7D, 28
  001f4	3affffe7	 bcc         |$LL6@GetAddress|
  001f8	ea000003	 b           |$LN43@GetAddress|
  001fc		 |$LN36@GetAddress|

; 408  :                     // Oops, somebody is using assigned address, decline...
; 409  :                     SendDHCP(DHCP_DECLINE, g_kitlEthState.deviceIP);

  001fc	e5941010	 ldr         r1, [r4, #0x10]
  00200	e3a00004	 mov         r0, #4
  00204	eb000000	 bl          SendDHCP

; 410  :                     g_kitlEthState.deviceIP = 0;

  00208	e584a010	 str         r10, [r4, #0x10]
  0020c		 |$LN43@GetAddress|
  0020c	e5943010	 ldr         r3, [r4, #0x10]

; 411  :                     break;
; 412  :                 }
; 413  :             }
; 414  :         }
; 415  : 
; 416  :         // If we get with valid address we are done
; 417  :         if (g_kitlEthState.deviceIP != 0) break;

  00210	e3530000	 cmp         r3, #0
  00214	1a000009	 bne         |$LN40@GetAddress|

; 418  : 
; 419  :         // Let try new DHCP transaction
; 420  :         g_kitlEthState.dhcpXId += 0x01080000;

  00218	e594302c	 ldr         r3, [r4, #0x2C]
  0021c	e2833742	 add         r3, r3, #0x42, 14
  00220		 |$LN46@GetAddress|
  00220	e584302c	 str         r3, [r4, #0x2C]
  00224	e3a03000	 mov         r3, #0
  00228	e3570003	 cmp         r7, #3
  0022c	e3a05001	 mov         r5, #1
  00230	3affffb0	 bcc         |$LL13@GetAddress|
  00234		 |$cleanUp$43469|

; 398  :             continue;

  00234	e5943010	 ldr         r3, [r4, #0x10]

; 421  : 
; 422  :     }
; 423  : 
; 424  : cleanUp:
; 425  :     if(g_kitlEthState.deviceIP != 0)

  00238	e3530000	 cmp         r3, #0
  0023c	0a000008	 beq         |$LN22@GetAddress|
  00240		 |$LN40@GetAddress|

; 426  :     KITL_RETAILMSG(ZONE_INIT, ("KITL: DHCP get/renew device IP: %s\r\n",
; 427  :         OALKitlIPtoString(g_kitlEthState.deviceIP)
; 428  :     ));

  00240	e59f3034	 ldr         r3, [pc, #0x34]
  00244	e5933440	 ldr         r3, [r3, #0x440]
  00248	e3130002	 tst         r3, #2
  0024c	0a000004	 beq         |$LN22@GetAddress|
  00250	e5940010	 ldr         r0, [r4, #0x10]
  00254	eb000000	 bl          OALKitlIPtoString
  00258	e1a01000	 mov         r1, r0
  0025c	e59f0014	 ldr         r0, [pc, #0x14]
  00260	eb000000	 bl          KITLOutputDebugString
  00264		 |$LN22@GetAddress|
  00264	e59d000c	 ldr         r0, [sp, #0xC]
  00268	eb000000	 bl          __security_check_cookie

; 429  : }

  0026c	e28dd010	 add         sp, sp, #0x10
  00270	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00274	e12fff1e	 bx          lr
  00278		 |$LN51@GetAddress|
  00278		 |$LN52@GetAddress|
  00278	00000000	 DCD         |??_C@_0CF@CNPGAGEH@KITL?3?5DHCP?5get?1renew?5device?5IP?3?5@|
  0027c		 |$LN53@GetAddress|
  0027c	00000000	 DCD         |dpCurSettings|
  00280		 |$LN54@GetAddress|
  00280	00000000	 DCD         |g_kitlEthState|
  00284		 |$LN55@GetAddress|
  00284	00000000	 DCD         |__security_cookie|
  00288		 |$M44562|

			 ENDP  ; |GetAddressDHCP|

	EXPORT	|OALKitlEthInit|
	EXPORT	|??_C@_0BL@OCIIDPCB@?9OALKitlEthInit?$CIrc?5?$DN?5?$CFd?$CJ?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CG@IJDAEBCE@WARN?3?5KITL?5will?5run?5in?5polling?5m@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CN@MENCFIED@WARN?3?5KITL?5can?8t?5obtain?5SYSINTR?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BL@EIDMIDBA@KITL?3?5using?5sysintr?50x?$CFx?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CO@BPFMIJNH@WARN?3?5KITL?5can?8t?5obtain?5IRQ?5for?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BP@ILGKAKAA@KITL?3?5?$CK?$CK?$CK?5Device?5Name?5?$CFs?5?$CK?$CK?$CK?$AN?6?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CF@GMMNDEHJ@ERROR?3?5KITL?5call?5to?5pfnInit?5fail@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CO@PDOCGCJP@ERROR?3?5KITL?5call?5to?5pfnInitDmaBu@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CE@LGCGCDLA@ERROR?3?5KITL?5device?5driver?5is?5NUL@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CO@HIMCOMKP@?$CLOALKitlEthInit?$CI?8?$CFS?8?0?5?8?$CFs?8?0?50x?$CF0@| [ DATA ] ; `string'
	IMPORT	|VBridgeKSetLocalMacAddress|
	IMPORT	|VBridgeInit|
	IMPORT	|KitlSendRawData|
	IMPORT	|OEMIoControl|
	IMPORT	|OALKitlCreateName|
	IMPORT	|g_oalKitlBuffer|

  00000			 AREA	 |.pdata|, PDATA
|$T44618| DCD	|$LN52@OALKitlEth|
	DCD	0x40010702

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BL@OCIIDPCB@?9OALKitlEthInit?$CIrc?5?$DN?5?$CFd?$CJ?$AN?6?$AA@| DCB "-"
	DCB	"OALKitlEthInit(rc = %d)", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CG@IJDAEBCE@WARN?3?5KITL?5will?5run?5in?5polling?5m@| DCB "WARN: "
	DCB	"KITL will run in polling mode", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CN@MENCFIED@WARN?3?5KITL?5can?8t?5obtain?5SYSINTR?5@| DCB "WARN: "
	DCB	"KITL can't obtain SYSINTR for IRQ %d", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BL@EIDMIDBA@KITL?3?5using?5sysintr?50x?$CFx?$AN?6?$AA@| DCB "KITL"
	DCB	": using sysintr 0x%x", 0xd, 0xa, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CO@BPFMIJNH@WARN?3?5KITL?5can?8t?5obtain?5IRQ?5for?5@| DCB "WARN:"
	DCB	" KITL can't obtain IRQ for KITL device", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0BP@ILGKAKAA@KITL?3?5?$CK?$CK?$CK?5Device?5Name?5?$CFs?5?$CK?$CK?$CK?$AN?6?$AA@| DCB "K"
	DCB	"ITL: *** Device Name %s ***", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CF@GMMNDEHJ@ERROR?3?5KITL?5call?5to?5pfnInit?5fail@| DCB "ERROR: "
	DCB	"KITL call to pfnInit failed", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CO@PDOCGCJP@ERROR?3?5KITL?5call?5to?5pfnInitDmaBu@| DCB "ERROR: K"
	DCB	"ITL call to pfnInitDmaBuffer failed", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CE@LGCGCDLA@ERROR?3?5KITL?5device?5driver?5is?5NUL@| DCB "ERROR: "
	DCB	"KITL device driver is NULL", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CO@HIMCOMKP@?$CLOALKitlEthInit?$CI?8?$CFS?8?0?5?8?$CFs?8?0?50x?$CF0@| DCB "+"
	DCB	"OALKitlEthInit('%S', '%s', 0x%08x, 0x%08x)", 0xd, 0xa, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALKitlEthInit| PROC

; 988  : ) {

  00000		 |$LN52@OALKitlEth|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd020	 sub         sp, sp, #0x20
  00008		 |$M44615|
  00008	e1a0b003	 mov         r11, r3
  0000c	e1a06002	 mov         r6, r2
  00010	e1a08001	 mov         r8, r1
  00014	e1a05000	 mov         r5, r0

; 989  :     BOOL rc = FALSE;
; 990  :     OAL_KITL_ETH_DRIVER *pDriver;
; 991  :     UINT32 irq, sysIntr;
; 992  : 
; 993  :     KITL_RETAILMSG(ZONE_KITL_OAL, (
; 994  :         "+OALKitlEthInit('%S', '%s', 0x%08x, 0x%08x)\r\n",
; 995  :         deviceId, pDevice->name, pArgs, pKitl
; 996  :     ));

  00018	e59f73a4	 ldr         r7, [pc, #0x3A4]
  0001c	e3a04000	 mov         r4, #0
  00020	e597e440	 ldr         lr, [r7, #0x440]
  00024	e31e0a01	 tst         lr, #1, 20
  00028	15982000	 ldrne       r2, [r8]
  0002c	159f03e4	 ldrne       r0, [pc, #0x3E4]
  00030	11a03006	 movne       r3, r6
  00034	11a01005	 movne       r1, r5
  00038	158db000	 strne       r11, [sp]
  0003c	1b000000	 blne        KITLOutputDebugString

; 997  : 
; 998  :     // Cast driver config parameter
; 999  :     pDriver = (OAL_KITL_ETH_DRIVER*)pDevice->pDriver;

  00040	e5981014	 ldr         r1, [r8, #0x14]
  00044	e1b08001	 movs        r8, r1
  00048	e58d8010	 str         r8, [sp, #0x10]

; 1000 :     if (pDriver == NULL) {

  0004c	1a000005	 bne         |$LN17@OALKitlEth|
  00050	e5973440	 ldr         r3, [r7, #0x440]

; 1001 :         KITL_RETAILMSG(ZONE_ERROR, ("ERROR: KITL device driver is NULL\r\n"));

  00054	e3130902	 tst         r3, #2, 18
  00058	0a0000ce	 beq         |$cleanUp$43851|
  0005c	e59f03b0	 ldr         r0, [pc, #0x3B0]
  00060	eb000000	 bl          KITLOutputDebugString

; 1002 :         goto cleanUp;

  00064	ea0000cb	 b           |$cleanUp$43851|
  00068		 |$LN17@OALKitlEth|

; 1003 :     }
; 1004 : 
; 1005 :     // Call InitDmaBuffer if there is any
; 1006 :     if (pDriver->pfnInitDmaBuffer != NULL) {

  00068	e5983004	 ldr         r3, [r8, #4]
  0006c	e3530000	 cmp         r3, #0
  00070	0a00000b	 beq         |$LN15@OALKitlEth|

; 1007 :         if (!pDriver->pfnInitDmaBuffer(
; 1008 :             (DWORD)g_oalKitlBuffer, sizeof(g_oalKitlBuffer)
; 1009 :         )) {

  00074	e59f0394	 ldr         r0, [pc, #0x394]
  00078	e3a01801	 mov         r1, #1, 16
  0007c	e1a0e00f	 mov         lr, pc
  00080	e12fff13	 bx          r3
  00084	e3500000	 cmp         r0, #0
  00088	1a000005	 bne         |$LN15@OALKitlEth|
  0008c	e5973440	 ldr         r3, [r7, #0x440]

; 1010 :                 KITL_RETAILMSG(ZONE_ERROR, (
; 1011 :                 "ERROR: KITL call to pfnInitDmaBuffer failed\r\n"
; 1012 :             ));

  00090	e3130902	 tst         r3, #2, 18
  00094	0a0000bf	 beq         |$cleanUp$43851|
  00098	e59f036c	 ldr         r0, [pc, #0x36C]
  0009c	eb000000	 bl          KITLOutputDebugString
  000a0	ea0000bc	 b           |$cleanUp$43851|
  000a4		 |$LN15@OALKitlEth|

; 1013 :             goto cleanUp;
; 1014 :         }
; 1015 :     }
; 1016 : 
; 1017 :     // Call pfnInit
; 1018 :     if (!pDriver->pfnInit(
; 1019 :         (UCHAR*)pArgs->devLoc.PhysicalLoc, pArgs->devLoc.LogicalLoc, pArgs->mac
; 1020 :     )) {

  000a4	e596100c	 ldr         r1, [r6, #0xC]
  000a8	e5960010	 ldr         r0, [r6, #0x10]
  000ac	e5983000	 ldr         r3, [r8]
  000b0	e2862018	 add         r2, r6, #0x18
  000b4	e1a0e00f	 mov         lr, pc
  000b8	e12fff13	 bx          r3
  000bc	e3500000	 cmp         r0, #0
  000c0	1a000005	 bne         |$LN14@OALKitlEth|
  000c4	e5973440	 ldr         r3, [r7, #0x440]

; 1021 :         KITL_RETAILMSG(ZONE_ERROR, ("ERROR: KITL call to pfnInit failed\r\n"));

  000c8	e3130902	 tst         r3, #2, 18
  000cc	0a0000b1	 beq         |$cleanUp$43851|
  000d0	e59f0330	 ldr         r0, [pc, #0x330]
  000d4	eb000000	 bl          KITLOutputDebugString
  000d8	ea0000ae	 b           |$cleanUp$43851|
  000dc		 |$LN14@OALKitlEth|

; 1022 :         goto cleanUp;
; 1023 :     }
; 1024 : 
; 1025 :     // Extend name if flag is set
; 1026 :     if ((pArgs->flags & OAL_KITL_FLAGS_EXTNAME) != 0) {

  000dc	e5963000	 ldr         r3, [r6]
  000e0	e3130020	 tst         r3, #0x20

; 1027 :         OALKitlCreateName(deviceId, pArgs->mac, deviceId);

  000e4	11a02005	 movne       r2, r5
  000e8	12861018	 addne       r1, r6, #0x18
  000ec	11a00005	 movne       r0, r5
  000f0	1b000000	 blne        OALKitlCreateName

; 1028 :     }
; 1029 : 
; 1030 :     // Now we know final name, print it
; 1031 :     KITL_RETAILMSG(ZONE_INIT, ("KITL: *** Device Name %s ***\r\n", deviceId));

  000f4	e5973440	 ldr         r3, [r7, #0x440]
  000f8	e3130002	 tst         r3, #2
  000fc	159f0300	 ldrne       r0, [pc, #0x300]
  00100	11a01005	 movne       r1, r5
  00104	1b000000	 blne        KITLOutputDebugString

; 1032 : 
; 1033 :     // Map and enable interrupt
; 1034 :     if ((pArgs->flags & OAL_KITL_FLAGS_POLL) != 0) {

  00108	e5963000	 ldr         r3, [r6]

; 1035 :         sysIntr = KITL_SYSINTR_NOINTR;

  0010c	e3e08000	 mvn         r8, #0
  00110	e3a09000	 mov         r9, #0
  00114	e3130010	 tst         r3, #0x10
  00118	11a09008	 movne       r9, r8
  0011c	158d8008	 strne       r8, [sp, #8]
  00120	1a00003c	 bne         |$LN46@OALKitlEth|

; 1036 :     } else {
; 1037 :         // Get IRQ, when interface is undefined use Pin as IRQ
; 1038 :         if (pArgs->devLoc.IfcType == InterfaceTypeUndefined) {

  00124	e5963004	 ldr         r3, [r6, #4]
  00128	e3a04004	 mov         r4, #4
  0012c	e3730001	 cmn         r3, #1

; 1039 :             irq = pArgs->devLoc.Pin;

  00130	0596e014	 ldreq       lr, [r6, #0x14]
  00134	058de00c	 streq       lr, [sp, #0xC]
  00138	0a000010	 beq         |$LN8@OALKitlEth|

; 1040 :         } else {
; 1041 :             if (!OEMIoControl(
; 1042 :                 IOCTL_HAL_REQUEST_IRQ, &pArgs->devLoc, sizeof(pArgs->devLoc),
; 1043 :                 &irq, sizeof(irq), NULL
; 1044 :             )) {                

  0013c	e59f02bc	 ldr         r0, [pc, #0x2BC]
  00140	e28d300c	 add         r3, sp, #0xC
  00144	e3a02014	 mov         r2, #0x14
  00148	e2861004	 add         r1, r6, #4
  0014c	e58d9004	 str         r9, [sp, #4]
  00150	e58d4000	 str         r4, [sp]
  00154	eb000000	 bl          OEMIoControl
  00158	e3500000	 cmp         r0, #0
  0015c	1a000006	 bne         |$LN47@OALKitlEth|
  00160	e5973440	 ldr         r3, [r7, #0x440]

; 1045 :                     KITL_RETAILMSG(ZONE_WARNING, (
; 1046 :                     "WARN: KITL can't obtain IRQ for KITL device\r\n"
; 1047 :                 ));

  00164	e3130001	 tst         r3, #1
  00168	159f028c	 ldrne       r0, [pc, #0x28C]
  0016c	1b000000	 blne        KITLOutputDebugString

; 1048 :                 irq = OAL_INTR_IRQ_UNDEFINED;

  00170	e1a0e008	 mov         lr, r8
  00174	e58d800c	 str         r8, [sp, #0xC]
  00178	ea000000	 b           |$LN8@OALKitlEth|
  0017c		 |$LN47@OALKitlEth|
  0017c	e59de00c	 ldr         lr, [sp, #0xC]
  00180		 |$LN8@OALKitlEth|

; 1049 :             }
; 1050 :         }
; 1051 :         // Get SYSINTR for IRQ
; 1052 :         if (irq != OAL_INTR_IRQ_UNDEFINED) {

  00180	e37e0001	 cmn         lr, #1
  00184	0a00001f	 beq         |$LN7@OALKitlEth|

; 1053 :             UINT32 aIrqs[3];
; 1054 : 
; 1055 :             aIrqs[0] = -1;
; 1056 :             aIrqs[1] = (pArgs->devLoc.IfcType == InterfaceTypeUndefined)
; 1057 :                         ? OAL_INTR_TRANSLATE
; 1058 :                         : OAL_INTR_FORCE_STATIC;

  00188	e5963004	 ldr         r3, [r6, #4]

; 1059 :             aIrqs[2] = irq;
; 1060 :             if (
; 1061 :                 OEMIoControl(
; 1062 :                     IOCTL_HAL_REQUEST_SYSINTR, aIrqs, sizeof(aIrqs), &sysIntr,
; 1063 :                     sizeof(sysIntr), NULL
; 1064 :                 ) && sysIntr != SYSINTR_UNDEFINED
; 1065 :             ) {                

  0018c	e59f0264	 ldr         r0, [pc, #0x264]
  00190	e3a0200c	 mov         r2, #0xC
  00194	e3730001	 cmn         r3, #1
  00198	03a03008	 moveq       r3, #8
  0019c	13a03004	 movne       r3, #4
  001a0	e58d3018	 str         r3, [sp, #0x18]
  001a4	e28d3008	 add         r3, sp, #8
  001a8	e28d1014	 add         r1, sp, #0x14
  001ac	e58d8014	 str         r8, [sp, #0x14]
  001b0	e58de01c	 str         lr, [sp, #0x1C]
  001b4	e58d9004	 str         r9, [sp, #4]
  001b8	e58d4000	 str         r4, [sp]
  001bc	eb000000	 bl          OEMIoControl
  001c0	e3500000	 cmp         r0, #0
  001c4	0a00000a	 beq         |$LN6@OALKitlEth|
  001c8	e59d9008	 ldr         r9, [sp, #8]
  001cc	e3790001	 cmn         r9, #1
  001d0	0a000007	 beq         |$LN6@OALKitlEth|
  001d4	e5973440	 ldr         r3, [r7, #0x440]

; 1066 :                 KITL_RETAILMSG(ZONE_INIT, ("KITL: using sysintr 0x%x\r\n", sysIntr));

  001d8	e3130002	 tst         r3, #2
  001dc	0a00000b	 beq         |$LN4@OALKitlEth|
  001e0	e59f020c	 ldr         r0, [pc, #0x20C]
  001e4	e1a01009	 mov         r1, r9
  001e8	eb000000	 bl          KITLOutputDebugString

; 1067 :             } else {

  001ec	e59d9008	 ldr         r9, [sp, #8]
  001f0	ea000006	 b           |$LN4@OALKitlEth|
  001f4		 |$LN6@OALKitlEth|

; 1028 :     }
; 1029 : 
; 1030 :     // Now we know final name, print it
; 1031 :     KITL_RETAILMSG(ZONE_INIT, ("KITL: *** Device Name %s ***\r\n", deviceId));

  001f4	e5973440	 ldr         r3, [r7, #0x440]

; 1068 :                 KITL_RETAILMSG(ZONE_WARNING, (
; 1069 :                     "WARN: KITL can't obtain SYSINTR for IRQ %d\r\n", irq
; 1070 :                 ));

  001f8	e3130001	 tst         r3, #1
  001fc	159d100c	 ldrne       r1, [sp, #0xC]
  00200	159f01e8	 ldrne       r0, [pc, #0x1E8]
  00204	1b000000	 blne        KITLOutputDebugString
  00208		 |$LN7@OALKitlEth|

; 1071 :                 sysIntr = KITL_SYSINTR_NOINTR;
; 1072 :             }
; 1073 :         } else {
; 1074 :             sysIntr = KITL_SYSINTR_NOINTR;

  00208	e58d8008	 str         r8, [sp, #8]
  0020c	e1a09008	 mov         r9, r8
  00210		 |$LN4@OALKitlEth|

; 1075 :         }
; 1076 :     }
; 1077 : 
; 1078 : 
; 1079 :     if (sysIntr == KITL_SYSINTR_NOINTR) {

  00210	e3790001	 cmn         r9, #1
  00214	1a000005	 bne         |$LN38@OALKitlEth|
  00218		 |$LN46@OALKitlEth|

; 1028 :     }
; 1029 : 
; 1030 :     // Now we know final name, print it
; 1031 :     KITL_RETAILMSG(ZONE_INIT, ("KITL: *** Device Name %s ***\r\n", deviceId));

  00218	e5973440	 ldr         r3, [r7, #0x440]

; 1080 :         KITL_RETAILMSG(ZONE_WARNING, (
; 1081 :             "WARN: KITL will run in polling mode\r\n"
; 1082 :         ));

  0021c	e3130001	 tst         r3, #1
  00220	0a000002	 beq         |$LN38@OALKitlEth|
  00224	e59f01c0	 ldr         r0, [pc, #0x1C0]
  00228	eb000000	 bl          KITLOutputDebugString
  0022c	e59d9008	 ldr         r9, [sp, #8]
  00230		 |$LN38@OALKitlEth|

; 1083 :     }
; 1084 : 
; 1085 :     //-----------------------------------------------------------------------
; 1086 :     // Initalize KITL transport structure
; 1087 :     //-----------------------------------------------------------------------
; 1088 : 
; 1089 :     memcpy(pKitl->szName, deviceId, sizeof(pKitl->szName));

  00230	e28b0004	 add         r0, r11, #4
  00234	e3a02010	 mov         r2, #0x10
  00238	e1a01005	 mov         r1, r5
  0023c	eb000000	 bl          memcpy

; 1090 :     pKitl->Interrupt     = (UCHAR)sysIntr;
; 1091 :     pKitl->WindowSize    = OAL_KITL_WINDOW_SIZE;
; 1092 :     pKitl->FrmHdrSize    = KitlEthGetFrameHdrSize();
; 1093 :     pKitl->dwPhysBuffer  = 0;
; 1094 :     pKitl->dwPhysBufLen  = 0;
; 1095 :     pKitl->pfnEncode     = KitlEthEncode;

  00240	e59f31a0	 ldr         r3, [pc, #0x1A0]

; 1096 :     pKitl->pfnDecode     = KitlEthDecode;

  00244	e59f2198	 ldr         r2, [pc, #0x198]

; 1097 :     pKitl->pfnSend       = KitlEthSend;

  00248	e59f1190	 ldr         r1, [pc, #0x190]

; 1098 :     pKitl->pfnRecv       = KitlEthRecv;
; 1099 :     pKitl->pfnEnableInt  = KitlEthEnableInt;
; 1100 :     pKitl->pfnGetDevCfg  = KitlEthGetDevCfg;
; 1101 :     pKitl->pfnSetHostCfg = KitlEthSetHostCfg;
; 1102 : 
; 1103 :     //-----------------------------------------------------------------------
; 1104 :     // Initalize KITL IP4 state structure
; 1105 :     //-----------------------------------------------------------------------
; 1106 : 
; 1107 :     g_kitlEthState.pDriver = pDriver;

  0024c	e58b3020	 str         r3, [r11, #0x20]
  00250	e3a03008	 mov         r3, #8
  00254	e5cb3015	 strb        r3, [r11, #0x15]
  00258	e3a03000	 mov         r3, #0
  0025c	e59f0178	 ldr         r0, [pc, #0x178]
  00260	e59fe170	 ldr         lr, [pc, #0x170]
  00264	e59f4168	 ldr         r4, [pc, #0x168]
  00268	e59f5160	 ldr         r5, [pc, #0x160]
  0026c	e59fa158	 ldr         r10, [pc, #0x158]
  00270	e58b3018	 str         r3, [r11, #0x18]
  00274	e58b301c	 str         r3, [r11, #0x1C]
  00278	e59d3010	 ldr         r3, [sp, #0x10]
  0027c	e3a0702a	 mov         r7, #0x2A
  00280	e58b2024	 str         r2, [r11, #0x24]
  00284	e58b1028	 str         r1, [r11, #0x28]
  00288	e58b002c	 str         r0, [r11, #0x2C]
  0028c	e58be030	 str         lr, [r11, #0x30]
  00290	e58b4034	 str         r4, [r11, #0x34]
  00294	e58b5038	 str         r5, [r11, #0x38]
  00298	e5cb9014	 strb        r9, [r11, #0x14]
  0029c	e5cb7016	 strb        r7, [r11, #0x16]
  002a0	e58a3000	 str         r3, [r10]

; 1108 :     g_kitlEthState.flags = pArgs->flags;

  002a4	e5963000	 ldr         r3, [r6]

; 1109 :     g_kitlEthState.deviceMAC[0] = (UINT8)pArgs->mac[0];
; 1110 :     g_kitlEthState.deviceMAC[1] = (UINT8)(pArgs->mac[0] >> 8);
; 1111 :     g_kitlEthState.deviceMAC[2] = (UINT8)pArgs->mac[1];
; 1112 :     g_kitlEthState.deviceMAC[3] = (UINT8)(pArgs->mac[1] >> 8);
; 1113 :     g_kitlEthState.deviceMAC[4] = (UINT8)pArgs->mac[2];
; 1114 :     g_kitlEthState.deviceMAC[5] = (UINT8)(pArgs->mac[2] >> 8);
; 1115 :     g_kitlEthState.deviceIP = pArgs->ipAddress;
; 1116 : 
; 1117 :     g_kitlEthState.kitlServerMAC[0] = 0xFF;

  002a8	e3a090ff	 mov         r9, #0xFF

; 1118 :     g_kitlEthState.kitlServerMAC[1] = 0xFF;
; 1119 :     g_kitlEthState.kitlServerMAC[2] = 0xFF;

  002ac	e3a050ff	 mov         r5, #0xFF
  002b0	e58a3004	 str         r3, [r10, #4]
  002b4	e1d631b8	 ldrh        r3, [r6, #0x18]

; 1120 :     g_kitlEthState.kitlServerMAC[3] = 0xFF;

  002b8	e3a070ff	 mov         r7, #0xFF

; 1121 :     g_kitlEthState.kitlServerMAC[4] = 0xFF;

  002bc	e3a0e0ff	 mov         lr, #0xFF
  002c0	e5ca3008	 strb        r3, [r10, #8]
  002c4	e5d63019	 ldrb        r3, [r6, #0x19]

; 1122 :     g_kitlEthState.kitlServerMAC[5] = 0xFF;

  002c8	e3a040ff	 mov         r4, #0xFF
  002cc	e3a02cd5	 mov         r2, #0xD5, 24
  002d0	e5ca3009	 strb        r3, [r10, #9]
  002d4	e1d631ba	 ldrh        r3, [r6, #0x1A]

; 1123 :     g_kitlEthState.kitlServerIP = 0xFFFFFFFF;
; 1124 :     g_kitlEthState.kitlServerPort = htons(KITL_SERVER_PORT);

  002d8	e3821003	 orr         r1, r2, #3

; 1125 : 
; 1126 :     g_kitlEthState.dhcpXId = pArgs->mac[2] | 0x17016414;

  002dc	e59f20e4	 ldr         r2, [pc, #0xE4]
  002e0	e5ca300a	 strb        r3, [r10, #0xA]
  002e4	e5d6301b	 ldrb        r3, [r6, #0x1B]

; 1127 :     g_kitlEthState.dhcpState = DHCP_BOUND;

  002e8	e3a00000	 mov         r0, #0
  002ec	e5ca300b	 strb        r3, [r10, #0xB]
  002f0	e1d631bc	 ldrh        r3, [r6, #0x1C]
  002f4	e5ca300c	 strb        r3, [r10, #0xC]
  002f8	e5d6301d	 ldrb        r3, [r6, #0x1D]
  002fc	e5ca300d	 strb        r3, [r10, #0xD]
  00300	e5963020	 ldr         r3, [r6, #0x20]
  00304	e58a3010	 str         r3, [r10, #0x10]
  00308	e3a030ff	 mov         r3, #0xFF
  0030c	e5ca9014	 strb        r9, [r10, #0x14]
  00310	e5ca3015	 strb        r3, [r10, #0x15]
  00314	e5ca5016	 strb        r5, [r10, #0x16]
  00318	e5ca7017	 strb        r7, [r10, #0x17]
  0031c	e5cae018	 strb        lr, [r10, #0x18]
  00320	e5ca4019	 strb        r4, [r10, #0x19]
  00324	e58a801c	 str         r8, [r10, #0x1C]
  00328	e1ca12b0	 strh        r1, [r10, #0x20]
  0032c	e1d631bc	 ldrh        r3, [r6, #0x1C]

; 1128 : 
; 1129 :     // Get or renew DHCP address
; 1130 :     if ((pArgs->flags & OAL_KITL_FLAGS_DHCP) != 0) {

  00330	e59f708c	 ldr         r7, [pc, #0x8C]
  00334	e1833002	 orr         r3, r3, r2
  00338	e58a302c	 str         r3, [r10, #0x2C]
  0033c	e58a0024	 str         r0, [r10, #0x24]
  00340	e5963000	 ldr         r3, [r6]
  00344	e3130004	 tst         r3, #4

; 1131 :         // KITL isn't running let use direct functions for send/receive
; 1132 :         g_kitlEthState.pfnSend = pKitl->pfnSend;

  00348	159b3028	 ldrne       r3, [r11, #0x28]
  0034c	158a3030	 strne       r3, [r10, #0x30]

; 1133 :         g_kitlEthState.pfnRecv = pKitl->pfnRecv;

  00350	159b302c	 ldrne       r3, [r11, #0x2C]
  00354	158a3034	 strne       r3, [r10, #0x34]

; 1134 :         // Get or renew address from DHCP server
; 1135 :         GetAddressDHCP(pArgs->ipAddress);

  00358	15960020	 ldrne       r0, [r6, #0x20]
  0035c	1b000000	 blne        GetAddressDHCP

; 1136 :     }
; 1137 : 
; 1138 :     // When KITL is running we should call sync function for send
; 1139 :     g_kitlEthState.pfnSend = KitlSendRawData;

  00360	e59f3058	 ldr         r3, [pc, #0x58]

; 1140 : 
; 1141 :     // There should not be direct receive
; 1142 :     g_kitlEthState.pfnRecv = NULL;

  00364	e3a02000	 mov         r2, #0
  00368	e58a3030	 str         r3, [r10, #0x30]
  0036c	e58a2034	 str         r2, [r10, #0x34]

; 1143 : 
; 1144 : #ifdef KITL_ETHER     
; 1145 :     // Activate VMINI bridge...
; 1146 :     if ((pArgs->flags & OAL_KITL_FLAGS_VMINI) != 0) {

  00370	e5963000	 ldr         r3, [r6]
  00374	e3130008	 tst         r3, #8
  00378	0a000002	 beq         |$LN1@OALKitlEth|

; 1147 :         VBridgeInit();

  0037c	eb000000	 bl          VBridgeInit

; 1148 :         VBridgeKSetLocalMacAddress((char*)pArgs->mac);

  00380	e2860018	 add         r0, r6, #0x18
  00384	eb000000	 bl          VBridgeKSetLocalMacAddress
  00388		 |$LN1@OALKitlEth|
  00388	e59a3010	 ldr         r3, [r10, #0x10]

; 1149 :     }
; 1150 : #endif
; 1151 : 
; 1152 :     // Result depends on fact if we get IP address
; 1153 :     rc = (g_kitlEthState.deviceIP != 0);

  0038c	e3530000	 cmp         r3, #0
  00390	13a04001	 movne       r4, #1
  00394	03a04000	 moveq       r4, #0
  00398		 |$cleanUp$43851|
  00398	e5973440	 ldr         r3, [r7, #0x440]

; 1154 :     
; 1155 : 
; 1156 : cleanUp:
; 1157 :     KITL_RETAILMSG(ZONE_KITL_OAL, ("-OALKitlEthInit(rc = %d)\r\n", rc));

  0039c	e3130a01	 tst         r3, #1, 20
  003a0	159f0014	 ldrne       r0, [pc, #0x14]
  003a4	11a01004	 movne       r1, r4
  003a8	1b000000	 blne        KITLOutputDebugString

; 1158 :     return rc;
; 1159 : }

  003ac	e1a00004	 mov         r0, r4
  003b0	e28dd020	 add         sp, sp, #0x20
  003b4	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  003b8	e12fff1e	 bx          lr
  003bc		 |$LN53@OALKitlEth|
  003bc		 |$LN54@OALKitlEth|
  003bc	00000000	 DCD         |??_C@_0BL@OCIIDPCB@?9OALKitlEthInit?$CIrc?5?$DN?5?$CFd?$CJ?$AN?6?$AA@|
  003c0		 |$LN55@OALKitlEth|
  003c0	00000000	 DCD         |KitlSendRawData|
  003c4		 |$LN56@OALKitlEth|
  003c4	00000000	 DCD         |dpCurSettings|
  003c8		 |$LN57@OALKitlEth|
  003c8	17016414	 DCD         0x17016414
  003cc		 |$LN58@OALKitlEth|
  003cc	00000000	 DCD         |g_kitlEthState|
  003d0		 |$LN59@OALKitlEth|
  003d0	00000000	 DCD         |KitlEthSetHostCfg|
  003d4		 |$LN60@OALKitlEth|
  003d4	00000000	 DCD         |KitlEthGetDevCfg|
  003d8		 |$LN61@OALKitlEth|
  003d8	00000000	 DCD         |KitlEthEnableInt|
  003dc		 |$LN62@OALKitlEth|
  003dc	00000000	 DCD         |KitlEthRecv|
  003e0		 |$LN63@OALKitlEth|
  003e0	00000000	 DCD         |KitlEthSend|
  003e4		 |$LN64@OALKitlEth|
  003e4	00000000	 DCD         |KitlEthDecode|
  003e8		 |$LN65@OALKitlEth|
  003e8	00000000	 DCD         |KitlEthEncode|
  003ec		 |$LN66@OALKitlEth|
  003ec	00000000	 DCD         |??_C@_0CG@IJDAEBCE@WARN?3?5KITL?5will?5run?5in?5polling?5m@|
  003f0		 |$LN67@OALKitlEth|
  003f0	00000000	 DCD         |??_C@_0CN@MENCFIED@WARN?3?5KITL?5can?8t?5obtain?5SYSINTR?5@|
  003f4		 |$LN68@OALKitlEth|
  003f4	00000000	 DCD         |??_C@_0BL@EIDMIDBA@KITL?3?5using?5sysintr?50x?$CFx?$AN?6?$AA@|
  003f8		 |$LN69@OALKitlEth|
  003f8	01010098	 DCD         0x1010098
  003fc		 |$LN70@OALKitlEth|
  003fc	00000000	 DCD         |??_C@_0CO@BPFMIJNH@WARN?3?5KITL?5can?8t?5obtain?5IRQ?5for?5@|
  00400		 |$LN71@OALKitlEth|
  00400	01010090	 DCD         0x1010090
  00404		 |$LN72@OALKitlEth|
  00404	00000000	 DCD         |??_C@_0BP@ILGKAKAA@KITL?3?5?$CK?$CK?$CK?5Device?5Name?5?$CFs?5?$CK?$CK?$CK?$AN?6?$AA@|
  00408		 |$LN73@OALKitlEth|
  00408	00000000	 DCD         |??_C@_0CF@GMMNDEHJ@ERROR?3?5KITL?5call?5to?5pfnInit?5fail@|
  0040c		 |$LN74@OALKitlEth|
  0040c	00000000	 DCD         |??_C@_0CO@PDOCGCJP@ERROR?3?5KITL?5call?5to?5pfnInitDmaBu@|
  00410		 |$LN75@OALKitlEth|
  00410	00000000	 DCD         |g_oalKitlBuffer|
  00414		 |$LN76@OALKitlEth|
  00414	00000000	 DCD         |??_C@_0CE@LGCGCDLA@ERROR?3?5KITL?5device?5driver?5is?5NUL@|
  00418		 |$LN77@OALKitlEth|
  00418	00000000	 DCD         |??_C@_0CO@HIMCOMKP@?$CLOALKitlEthInit?$CI?8?$CFS?8?0?5?8?$CFs?8?0?50x?$CF0@|
  0041c		 |$M44616|

			 ENDP  ; |OALKitlEthInit|

	END
