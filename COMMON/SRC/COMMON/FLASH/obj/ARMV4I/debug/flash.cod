; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\COMMON\FLASH\flash.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|??_C@_1DC@LLEMLIAM@?$AA?9?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAI?$AAn?$AAf?$AAo?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DK@HABCIMDF@?$AA?$CL?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAI?$AAn?$AAf?$AAo?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?0?$AA?5?$AA?4?$AA?4?$AA?4?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|OALFlashInfo|
	IMPORT	|READ_REGISTER_UCHAR|
	IMPORT	|WRITE_REGISTER_UCHAR|
	IMPORT	|READ_REGISTER_USHORT|
	IMPORT	|WRITE_REGISTER_USHORT|
	IMPORT	|READ_REGISTER_ULONG|
	IMPORT	|WRITE_REGISTER_ULONG|
	IMPORT	|memset|
	IMPORT	|NKDbgPrintfW|
	IMPORT	|dpCurSettings|

  00000			 AREA	 |.pdata|, PDATA
|$T43726| DCD	|$LN35@OALFlashIn|
	DCD	0x4001d004
; File c:\wince600\platform\common\src\common\flash\flash.c

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DC@LLEMLIAM@?$AA?9?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAI?$AAn?$AAf?$AAo?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "-"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "F", 0x0, "l", 0x0, "a"
	DCB	0x0, "s", 0x0, "h", 0x0, "I", 0x0, "n", 0x0, "f", 0x0, "o"
	DCB	0x0, "(", 0x0, "r", 0x0, "c", 0x0, " ", 0x0, "=", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, ")", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DK@HABCIMDF@?$AA?$CL?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAI?$AAn?$AAf?$AAo?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?0?$AA?5?$AA?4?$AA?4?$AA?4?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "+"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "F", 0x0, "l", 0x0, "a"
	DCB	0x0, "s", 0x0, "h", 0x0, "I", 0x0, "n", 0x0, "f", 0x0, "o"
	DCB	0x0, "(", 0x0, "0", 0x0, "x", 0x0, "%", 0x0, "0", 0x0, "8"
	DCB	0x0, "x", 0x0, ",", 0x0, " ", 0x0, ".", 0x0, ".", 0x0, "."
	DCB	0x0, ")", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALFlashInfo| PROC

; 613  : {

  00000		 |$LN35@OALFlashIn|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd08c	 sub         sp, sp, #0x8C
  00010		 |$M43723|

; 614  :     BOOL rc = FALSE;

  00010	e3a03000	 mov         r3, #0
  00014	e58d300c	 str         r3, [sp, #0xC]

; 615  :     UINT32 base = (UINT32)pBase;

  00018	e59d3094	 ldr         r3, [sp, #0x94]
  0001c	e58d3018	 str         r3, [sp, #0x18]

; 616  :     UINT32 code1, code2, code3;
; 617  :     UINT32 i;
; 618  :     
; 619  :     OALMSG(OAL_FUNC, (L"+OALFlashInfo(0x%08x, ...)\r\n", pBase));

  00020	e59f3700	 ldr         r3, [pc, #0x700]
  00024	e5933440	 ldr         r3, [r3, #0x440]
  00028	e3130004	 tst         r3, #4
  0002c	0a000005	 beq         |$LN29@OALFlashIn|
  00030	e59d1094	 ldr         r1, [sp, #0x94]
  00034	e59f0700	 ldr         r0, [pc, #0x700]
  00038	eb000000	 bl          NKDbgPrintfW
  0003c	e3a03001	 mov         r3, #1
  00040	e58d3044	 str         r3, [sp, #0x44]
  00044	ea000001	 b           |$LN30@OALFlashIn|
  00048		 |$LN29@OALFlashIn|
  00048	e3a03000	 mov         r3, #0
  0004c	e58d3044	 str         r3, [sp, #0x44]
  00050		 |$LN30@OALFlashIn|

; 620  : 
; 621  :     // Just to avoid possible problems
; 622  :     memset(pInfo, 0, sizeof(*pInfo));

  00050	e3a02058	 mov         r2, #0x58
  00054	e3a01000	 mov         r1, #0
  00058	e59d0098	 ldr         r0, [sp, #0x98]
  0005c	eb000000	 bl          memset

; 623  : 
; 624  :     // Try 32-bit geometry
; 625  :     OUTREG32((UINT32*)(base + 4 * 0x55), 0x98989898);

  00060	e59f16d0	 ldr         r1, [pc, #0x6D0]
  00064	e59d3018	 ldr         r3, [sp, #0x18]
  00068	e2830f55	 add         r0, r3, #0x55, 30
  0006c	eb000000	 bl          WRITE_REGISTER_ULONG

; 626  :     code1 = INREG32((UINT32*)(base + 4 * 0x10));

  00070	e59d3018	 ldr         r3, [sp, #0x18]
  00074	e2830040	 add         r0, r3, #0x40
  00078	eb000000	 bl          READ_REGISTER_ULONG
  0007c	e58d0048	 str         r0, [sp, #0x48]
  00080	e59d3048	 ldr         r3, [sp, #0x48]
  00084	e58d3008	 str         r3, [sp, #8]

; 627  :     code2 = INREG32((UINT32*)(base + 4 * 0x11));

  00088	e59d3018	 ldr         r3, [sp, #0x18]
  0008c	e2830044	 add         r0, r3, #0x44
  00090	eb000000	 bl          READ_REGISTER_ULONG
  00094	e58d004c	 str         r0, [sp, #0x4C]
  00098	e59d304c	 ldr         r3, [sp, #0x4C]
  0009c	e58d3014	 str         r3, [sp, #0x14]

; 628  :     code3 = INREG32((UINT32*)(base + 4 * 0x12));

  000a0	e59d3018	 ldr         r3, [sp, #0x18]
  000a4	e2830048	 add         r0, r3, #0x48
  000a8	eb000000	 bl          READ_REGISTER_ULONG
  000ac	e58d0050	 str         r0, [sp, #0x50]
  000b0	e59d3050	 ldr         r3, [sp, #0x50]
  000b4	e58d3004	 str         r3, [sp, #4]

; 629  :     if (code1 == 'QQQQ' && code2 == 'RRRR' && code3 == 'YYYY')

  000b8	e59d2008	 ldr         r2, [sp, #8]
  000bc	e59f3670	 ldr         r3, [pc, #0x670]
  000c0	e1520003	 cmp         r2, r3
  000c4	1a00000f	 bne         |$LN26@OALFlashIn|
  000c8	e59d2014	 ldr         r2, [sp, #0x14]
  000cc	e59f365c	 ldr         r3, [pc, #0x65C]
  000d0	e1520003	 cmp         r2, r3
  000d4	1a00000b	 bne         |$LN26@OALFlashIn|
  000d8	e59d2004	 ldr         r2, [sp, #4]
  000dc	e59f3648	 ldr         r3, [pc, #0x648]
  000e0	e1520003	 cmp         r2, r3
  000e4	1a000007	 bne         |$LN26@OALFlashIn|

; 630  :         {
; 631  :         pInfo->width = 4;

  000e8	e59d2098	 ldr         r2, [sp, #0x98]
  000ec	e3a03004	 mov         r3, #4
  000f0	e5823000	 str         r3, [r2]

; 632  :         pInfo->parallel = 4;

  000f4	e59d3098	 ldr         r3, [sp, #0x98]
  000f8	e2832004	 add         r2, r3, #4
  000fc	e3a03004	 mov         r3, #4
  00100	e5823000	 str         r3, [r2]
  00104	ea000093	 b           |$LN25@OALFlashIn|
  00108		 |$LN26@OALFlashIn|

; 633  :         }
; 634  :     else if (code1 == 'Q\0Q\0' && code2 == 'R\0R\0' && code3 == 'Y\0Y\0')

  00108	e59d2008	 ldr         r2, [sp, #8]
  0010c	e3a03851	 mov         r3, #0x51, 16
  00110	e3833051	 orr         r3, r3, #0x51
  00114	e1520003	 cmp         r2, r3
  00118	1a000011	 bne         |$LN24@OALFlashIn|
  0011c	e59d2014	 ldr         r2, [sp, #0x14]
  00120	e3a03852	 mov         r3, #0x52, 16
  00124	e3833052	 orr         r3, r3, #0x52
  00128	e1520003	 cmp         r2, r3
  0012c	1a00000c	 bne         |$LN24@OALFlashIn|
  00130	e59d2004	 ldr         r2, [sp, #4]
  00134	e3a03859	 mov         r3, #0x59, 16
  00138	e3833059	 orr         r3, r3, #0x59
  0013c	e1520003	 cmp         r2, r3
  00140	1a000007	 bne         |$LN24@OALFlashIn|

; 635  :         {
; 636  :         pInfo->width = 4;

  00144	e59d2098	 ldr         r2, [sp, #0x98]
  00148	e3a03004	 mov         r3, #4
  0014c	e5823000	 str         r3, [r2]

; 637  :         pInfo->parallel = 2;

  00150	e59d3098	 ldr         r3, [sp, #0x98]
  00154	e2832004	 add         r2, r3, #4
  00158	e3a03002	 mov         r3, #2
  0015c	e5823000	 str         r3, [r2]
  00160	ea00007c	 b           |$LN23@OALFlashIn|
  00164		 |$LN24@OALFlashIn|

; 638  :         }
; 639  :     else if (code1 == 'Q\0\0\0' && code2 == 'R\0\0\0' && code3 == 'Y\0\0\0')

  00164	e59d3008	 ldr         r3, [sp, #8]
  00168	e3530c51	 cmp         r3, #0x51, 24
  0016c	1a00000d	 bne         |$LN22@OALFlashIn|
  00170	e59d3014	 ldr         r3, [sp, #0x14]
  00174	e3530c52	 cmp         r3, #0x52, 24
  00178	1a00000a	 bne         |$LN22@OALFlashIn|
  0017c	e59d3004	 ldr         r3, [sp, #4]
  00180	e3530c59	 cmp         r3, #0x59, 24
  00184	1a000007	 bne         |$LN22@OALFlashIn|

; 640  :         {
; 641  :         pInfo->width = 4;

  00188	e59d2098	 ldr         r2, [sp, #0x98]
  0018c	e3a03004	 mov         r3, #4
  00190	e5823000	 str         r3, [r2]

; 642  :         pInfo->parallel = 1;

  00194	e59d3098	 ldr         r3, [sp, #0x98]
  00198	e2832004	 add         r2, r3, #4
  0019c	e3a03001	 mov         r3, #1
  001a0	e5823000	 str         r3, [r2]

; 643  :         }
; 644  :     else 

  001a4	ea00006b	 b           |$LN21@OALFlashIn|
  001a8		 |$LN22@OALFlashIn|

; 645  :         {
; 646  :         // Now try luck with 16-bit geometry
; 647  :         OUTREG16((UINT16*)(base + 2 * 0x55), 0x0098);

  001a8	e3a01098	 mov         r1, #0x98
  001ac	e59d3018	 ldr         r3, [sp, #0x18]
  001b0	e28300aa	 add         r0, r3, #0xAA
  001b4	eb000000	 bl          WRITE_REGISTER_USHORT

; 648  :         code1 = INREG16((UINT16*)(base + 2 * 0x10));

  001b8	e59d3018	 ldr         r3, [sp, #0x18]
  001bc	e2830020	 add         r0, r3, #0x20
  001c0	eb000000	 bl          READ_REGISTER_USHORT
  001c4	e1a03800	 mov         r3, r0, lsl #16
  001c8	e1a03823	 mov         r3, r3, lsr #16
  001cc	e1cd35b4	 strh        r3, [sp, #0x54]
  001d0	e1dd35b4	 ldrh        r3, [sp, #0x54]
  001d4	e58d3008	 str         r3, [sp, #8]

; 649  :         code2 = INREG16((UINT16*)(base + 2 * 0x11));

  001d8	e59d3018	 ldr         r3, [sp, #0x18]
  001dc	e2830022	 add         r0, r3, #0x22
  001e0	eb000000	 bl          READ_REGISTER_USHORT
  001e4	e1a03800	 mov         r3, r0, lsl #16
  001e8	e1a03823	 mov         r3, r3, lsr #16
  001ec	e1cd35b6	 strh        r3, [sp, #0x56]
  001f0	e1dd35b6	 ldrh        r3, [sp, #0x56]
  001f4	e58d3014	 str         r3, [sp, #0x14]

; 650  :         code3 = INREG16((UINT16*)(base + 2 * 0x12));

  001f8	e59d3018	 ldr         r3, [sp, #0x18]
  001fc	e2830024	 add         r0, r3, #0x24
  00200	eb000000	 bl          READ_REGISTER_USHORT
  00204	e1a03800	 mov         r3, r0, lsl #16
  00208	e1a03823	 mov         r3, r3, lsr #16
  0020c	e1cd35b8	 strh        r3, [sp, #0x58]
  00210	e1dd35b8	 ldrh        r3, [sp, #0x58]
  00214	e58d3004	 str         r3, [sp, #4]

; 651  :         if (code1 == 'QQ' && code2 == 'RR' && code3 == 'YY')

  00218	e59d2008	 ldr         r2, [sp, #8]
  0021c	e3a03c51	 mov         r3, #0x51, 24
  00220	e3833051	 orr         r3, r3, #0x51
  00224	e1520003	 cmp         r2, r3
  00228	1a000011	 bne         |$LN20@OALFlashIn|
  0022c	e59d2014	 ldr         r2, [sp, #0x14]
  00230	e3a03c52	 mov         r3, #0x52, 24
  00234	e3833052	 orr         r3, r3, #0x52
  00238	e1520003	 cmp         r2, r3
  0023c	1a00000c	 bne         |$LN20@OALFlashIn|
  00240	e59d2004	 ldr         r2, [sp, #4]
  00244	e3a03c59	 mov         r3, #0x59, 24
  00248	e3833059	 orr         r3, r3, #0x59
  0024c	e1520003	 cmp         r2, r3
  00250	1a000007	 bne         |$LN20@OALFlashIn|

; 652  :             {
; 653  :             pInfo->width = 2;

  00254	e59d2098	 ldr         r2, [sp, #0x98]
  00258	e3a03002	 mov         r3, #2
  0025c	e5823000	 str         r3, [r2]

; 654  :             pInfo->parallel = 2;

  00260	e59d3098	 ldr         r3, [sp, #0x98]
  00264	e2832004	 add         r2, r3, #4
  00268	e3a03002	 mov         r3, #2
  0026c	e5823000	 str         r3, [r2]
  00270	ea000038	 b           |$LN19@OALFlashIn|
  00274		 |$LN20@OALFlashIn|

; 655  :             }
; 656  :         else if (code1 == '\0Q' && code2 == '\0R' && code3 == '\0Y')

  00274	e59d3008	 ldr         r3, [sp, #8]
  00278	e3530051	 cmp         r3, #0x51
  0027c	1a00000d	 bne         |$LN18@OALFlashIn|
  00280	e59d3014	 ldr         r3, [sp, #0x14]
  00284	e3530052	 cmp         r3, #0x52
  00288	1a00000a	 bne         |$LN18@OALFlashIn|
  0028c	e59d3004	 ldr         r3, [sp, #4]
  00290	e3530059	 cmp         r3, #0x59
  00294	1a000007	 bne         |$LN18@OALFlashIn|

; 657  :             {
; 658  :             pInfo->width = 2;

  00298	e59d2098	 ldr         r2, [sp, #0x98]
  0029c	e3a03002	 mov         r3, #2
  002a0	e5823000	 str         r3, [r2]

; 659  :             pInfo->parallel = 1;

  002a4	e59d3098	 ldr         r3, [sp, #0x98]
  002a8	e2832004	 add         r2, r3, #4
  002ac	e3a03001	 mov         r3, #1
  002b0	e5823000	 str         r3, [r2]

; 660  :             }
; 661  :         else 

  002b4	ea000027	 b           |$LN17@OALFlashIn|
  002b8		 |$LN18@OALFlashIn|

; 662  :             {
; 663  :             // So last opportunity is 8-bit mode
; 664  :             OUTREG8((UINT8*)(base + 0x55), 0x98);

  002b8	e3a01098	 mov         r1, #0x98
  002bc	e59d3018	 ldr         r3, [sp, #0x18]
  002c0	e2830055	 add         r0, r3, #0x55
  002c4	eb000000	 bl          WRITE_REGISTER_UCHAR

; 665  :             code1 = INREG8((UINT8*)(base + 0x10));

  002c8	e59d3018	 ldr         r3, [sp, #0x18]
  002cc	e2830010	 add         r0, r3, #0x10
  002d0	eb000000	 bl          READ_REGISTER_UCHAR
  002d4	e5cd005a	 strb        r0, [sp, #0x5A]
  002d8	e5dd305a	 ldrb        r3, [sp, #0x5A]
  002dc	e58d3008	 str         r3, [sp, #8]

; 666  :             code2 = INREG8((UINT8*)(base + 0x11));

  002e0	e59d3018	 ldr         r3, [sp, #0x18]
  002e4	e2830011	 add         r0, r3, #0x11
  002e8	eb000000	 bl          READ_REGISTER_UCHAR
  002ec	e5cd005b	 strb        r0, [sp, #0x5B]
  002f0	e5dd305b	 ldrb        r3, [sp, #0x5B]
  002f4	e58d3014	 str         r3, [sp, #0x14]

; 667  :             code3 = INREG8((UINT8*)(base + 0x12));

  002f8	e59d3018	 ldr         r3, [sp, #0x18]
  002fc	e2830012	 add         r0, r3, #0x12
  00300	eb000000	 bl          READ_REGISTER_UCHAR
  00304	e5cd005c	 strb        r0, [sp, #0x5C]
  00308	e5dd305c	 ldrb        r3, [sp, #0x5C]
  0030c	e58d3004	 str         r3, [sp, #4]

; 668  :             if (code1 == 'Q' && code2 == 'R' && code3 == 'Y')

  00310	e59d3008	 ldr         r3, [sp, #8]
  00314	e3530051	 cmp         r3, #0x51
  00318	1a00000d	 bne         |$LN16@OALFlashIn|
  0031c	e59d3014	 ldr         r3, [sp, #0x14]
  00320	e3530052	 cmp         r3, #0x52
  00324	1a00000a	 bne         |$LN16@OALFlashIn|
  00328	e59d3004	 ldr         r3, [sp, #4]
  0032c	e3530059	 cmp         r3, #0x59
  00330	1a000007	 bne         |$LN16@OALFlashIn|

; 669  :                 {
; 670  :                 pInfo->width = 1;

  00334	e59d2098	 ldr         r2, [sp, #0x98]
  00338	e3a03001	 mov         r3, #1
  0033c	e5823000	 str         r3, [r2]

; 671  :                 pInfo->parallel = 1;

  00340	e59d3098	 ldr         r3, [sp, #0x98]
  00344	e2832004	 add         r2, r3, #4
  00348	e3a03001	 mov         r3, #1
  0034c	e5823000	 str         r3, [r2]

; 672  :                 }
; 673  :             else 

  00350	ea000000	 b           |$LN15@OALFlashIn|
  00354		 |$LN16@OALFlashIn|

; 674  :                 {
; 675  :                 goto cleanUp;

  00354	ea0000e0	 b           |$cleanUp$43380|
  00358		 |$LN15@OALFlashIn|
  00358		 |$LN17@OALFlashIn|
  00358		 |$LN19@OALFlashIn|
  00358		 |$LN21@OALFlashIn|
  00358		 |$LN23@OALFlashIn|
  00358		 |$LN25@OALFlashIn|

; 676  :                 }                
; 677  :             }
; 678  :         }        
; 679  : 
; 680  :     // Read primary command set, size, burst size and number of regions
; 681  :     pInfo->set = ReadInfo(pInfo, base, 0x13, 0, 1);

  00358	e3a03001	 mov         r3, #1
  0035c	e58d3000	 str         r3, [sp]
  00360	e3a03000	 mov         r3, #0
  00364	e3a02013	 mov         r2, #0x13
  00368	e59d1018	 ldr         r1, [sp, #0x18]
  0036c	e59d0098	 ldr         r0, [sp, #0x98]
  00370	eb000000	 bl          ReadInfo
  00374	e58d0060	 str         r0, [sp, #0x60]
  00378	e59d3098	 ldr         r3, [sp, #0x98]
  0037c	e2832008	 add         r2, r3, #8
  00380	e59d3060	 ldr         r3, [sp, #0x60]
  00384	e5823000	 str         r3, [r2]

; 682  :     pInfo->size = 1 << ReadInfo(pInfo, base, 0x27, 0, 1);

  00388	e3a03001	 mov         r3, #1
  0038c	e58d3000	 str         r3, [sp]
  00390	e3a03000	 mov         r3, #0
  00394	e3a02027	 mov         r2, #0x27
  00398	e59d1018	 ldr         r1, [sp, #0x18]
  0039c	e59d0098	 ldr         r0, [sp, #0x98]
  003a0	eb000000	 bl          ReadInfo
  003a4	e58d0064	 str         r0, [sp, #0x64]
  003a8	e59d2064	 ldr         r2, [sp, #0x64]
  003ac	e3a03001	 mov         r3, #1
  003b0	e1a02213	 mov         r2, r3, lsl r2
  003b4	e59d3098	 ldr         r3, [sp, #0x98]
  003b8	e283300c	 add         r3, r3, #0xC
  003bc	e5832000	 str         r2, [r3]

; 683  :     pInfo->burst = 1 << ReadInfo(pInfo, base, 0x2A, 0, 1);

  003c0	e3a03001	 mov         r3, #1
  003c4	e58d3000	 str         r3, [sp]
  003c8	e3a03000	 mov         r3, #0
  003cc	e3a0202a	 mov         r2, #0x2A
  003d0	e59d1018	 ldr         r1, [sp, #0x18]
  003d4	e59d0098	 ldr         r0, [sp, #0x98]
  003d8	eb000000	 bl          ReadInfo
  003dc	e58d0068	 str         r0, [sp, #0x68]
  003e0	e59d2068	 ldr         r2, [sp, #0x68]
  003e4	e3a03001	 mov         r3, #1
  003e8	e1a02213	 mov         r2, r3, lsl r2
  003ec	e59d3098	 ldr         r3, [sp, #0x98]
  003f0	e2833010	 add         r3, r3, #0x10
  003f4	e5832000	 str         r2, [r3]

; 684  :     pInfo->regions = ReadInfo(pInfo, base, 0x2C, 0, 1);

  003f8	e3a03001	 mov         r3, #1
  003fc	e58d3000	 str         r3, [sp]
  00400	e3a03000	 mov         r3, #0
  00404	e3a0202c	 mov         r2, #0x2C
  00408	e59d1018	 ldr         r1, [sp, #0x18]
  0040c	e59d0098	 ldr         r0, [sp, #0x98]
  00410	eb000000	 bl          ReadInfo
  00414	e58d006c	 str         r0, [sp, #0x6C]
  00418	e59d3098	 ldr         r3, [sp, #0x98]
  0041c	e2832014	 add         r2, r3, #0x14
  00420	e59d306c	 ldr         r3, [sp, #0x6C]
  00424	e5823000	 str         r3, [r2]

; 685  : 
; 686  :     // Verify that parallel chips are same
; 687  :     for (i = 1; i < pInfo->parallel; i++)

  00428	e3a03001	 mov         r3, #1
  0042c	e58d3010	 str         r3, [sp, #0x10]
  00430	ea000002	 b           |$LN14@OALFlashIn|
  00434		 |$LN13@OALFlashIn|
  00434	e59d3010	 ldr         r3, [sp, #0x10]
  00438	e2833001	 add         r3, r3, #1
  0043c	e58d3010	 str         r3, [sp, #0x10]
  00440		 |$LN14@OALFlashIn|
  00440	e59d3098	 ldr         r3, [sp, #0x98]
  00444	e2833004	 add         r3, r3, #4
  00448	e59d2010	 ldr         r2, [sp, #0x10]
  0044c	e5933000	 ldr         r3, [r3]
  00450	e1520003	 cmp         r2, r3
  00454	2a00003d	 bcs         |$LN12@OALFlashIn|

; 688  :         {
; 689  :             if ( (pInfo->set != ReadInfo(pInfo, base, 0x13, i, 1)) ||
; 690  :                  (pInfo->size != (1 << ReadInfo(pInfo, base, 0x27, 0, 1))) ||
; 691  :                  (pInfo->burst != (1 << ReadInfo(pInfo, base, 0x2A, 0, 1))) ||
; 692  :                  (pInfo->regions != ReadInfo(pInfo, base, 0x2C, 0, 1)) )

  00458	e3a03001	 mov         r3, #1
  0045c	e58d3000	 str         r3, [sp]
  00460	e59d3010	 ldr         r3, [sp, #0x10]
  00464	e3a02013	 mov         r2, #0x13
  00468	e59d1018	 ldr         r1, [sp, #0x18]
  0046c	e59d0098	 ldr         r0, [sp, #0x98]
  00470	eb000000	 bl          ReadInfo
  00474	e58d0070	 str         r0, [sp, #0x70]
  00478	e59d3098	 ldr         r3, [sp, #0x98]
  0047c	e2833008	 add         r3, r3, #8
  00480	e5932000	 ldr         r2, [r3]
  00484	e59d3070	 ldr         r3, [sp, #0x70]
  00488	e1520003	 cmp         r2, r3
  0048c	1a00002d	 bne         |$LN10@OALFlashIn|
  00490	e3a03001	 mov         r3, #1
  00494	e58d3000	 str         r3, [sp]
  00498	e3a03000	 mov         r3, #0
  0049c	e3a02027	 mov         r2, #0x27
  004a0	e59d1018	 ldr         r1, [sp, #0x18]
  004a4	e59d0098	 ldr         r0, [sp, #0x98]
  004a8	eb000000	 bl          ReadInfo
  004ac	e58d0074	 str         r0, [sp, #0x74]
  004b0	e59d3098	 ldr         r3, [sp, #0x98]
  004b4	e283100c	 add         r1, r3, #0xC
  004b8	e59d2074	 ldr         r2, [sp, #0x74]
  004bc	e3a03001	 mov         r3, #1
  004c0	e1a02213	 mov         r2, r3, lsl r2
  004c4	e5913000	 ldr         r3, [r1]
  004c8	e1530002	 cmp         r3, r2
  004cc	1a00001d	 bne         |$LN10@OALFlashIn|
  004d0	e3a03001	 mov         r3, #1
  004d4	e58d3000	 str         r3, [sp]
  004d8	e3a03000	 mov         r3, #0
  004dc	e3a0202a	 mov         r2, #0x2A
  004e0	e59d1018	 ldr         r1, [sp, #0x18]
  004e4	e59d0098	 ldr         r0, [sp, #0x98]
  004e8	eb000000	 bl          ReadInfo
  004ec	e58d0078	 str         r0, [sp, #0x78]
  004f0	e59d3098	 ldr         r3, [sp, #0x98]
  004f4	e2831010	 add         r1, r3, #0x10
  004f8	e59d2078	 ldr         r2, [sp, #0x78]
  004fc	e3a03001	 mov         r3, #1
  00500	e1a02213	 mov         r2, r3, lsl r2
  00504	e5913000	 ldr         r3, [r1]
  00508	e1530002	 cmp         r3, r2
  0050c	1a00000d	 bne         |$LN10@OALFlashIn|
  00510	e3a03001	 mov         r3, #1
  00514	e58d3000	 str         r3, [sp]
  00518	e3a03000	 mov         r3, #0
  0051c	e3a0202c	 mov         r2, #0x2C
  00520	e59d1018	 ldr         r1, [sp, #0x18]
  00524	e59d0098	 ldr         r0, [sp, #0x98]
  00528	eb000000	 bl          ReadInfo
  0052c	e58d007c	 str         r0, [sp, #0x7C]
  00530	e59d3098	 ldr         r3, [sp, #0x98]
  00534	e2833014	 add         r3, r3, #0x14
  00538	e5932000	 ldr         r2, [r3]
  0053c	e59d307c	 ldr         r3, [sp, #0x7C]
  00540	e1520003	 cmp         r2, r3
  00544	0a000000	 beq         |$LN11@OALFlashIn|
  00548		 |$LN10@OALFlashIn|

; 693  :                 {
; 694  :                     goto cleanUp;

  00548	ea000063	 b           |$cleanUp$43380|
  0054c		 |$LN11@OALFlashIn|

; 695  :                 }
; 696  :             
; 697  :         }

  0054c	eaffffb8	 b           |$LN13@OALFlashIn|
  00550		 |$LN12@OALFlashIn|

; 698  :     
; 699  :     // If there is more regions than expected
; 700  :     if (pInfo->regions > 8) goto cleanUp;

  00550	e59d3098	 ldr         r3, [sp, #0x98]
  00554	e2833014	 add         r3, r3, #0x14
  00558	e5933000	 ldr         r3, [r3]
  0055c	e3530008	 cmp         r3, #8
  00560	9a000000	 bls         |$LN9@OALFlashIn|
  00564	ea00005c	 b           |$cleanUp$43380|
  00568		 |$LN9@OALFlashIn|

; 701  :    
; 702  :     // Read region info
; 703  :     for (i = 0; i < pInfo->regions; i++)

  00568	e3a03000	 mov         r3, #0
  0056c	e58d3010	 str         r3, [sp, #0x10]
  00570	ea000002	 b           |$LN8@OALFlashIn|
  00574		 |$LN7@OALFlashIn|
  00574	e59d3010	 ldr         r3, [sp, #0x10]
  00578	e2833001	 add         r3, r3, #1
  0057c	e58d3010	 str         r3, [sp, #0x10]
  00580		 |$LN8@OALFlashIn|
  00580	e59d3098	 ldr         r3, [sp, #0x98]
  00584	e2833014	 add         r3, r3, #0x14
  00588	e59d2010	 ldr         r2, [sp, #0x10]
  0058c	e5933000	 ldr         r3, [r3]
  00590	e1520003	 cmp         r2, r3
  00594	2a000035	 bcs         |$LN6@OALFlashIn|

; 704  :         {
; 705  :         code1 = ReadInfo(pInfo, base, 0x2d + (i << 2), 0, 4);

  00598	e3a03004	 mov         r3, #4
  0059c	e58d3000	 str         r3, [sp]
  005a0	e3a03000	 mov         r3, #0
  005a4	e59d2010	 ldr         r2, [sp, #0x10]
  005a8	e1a02102	 mov         r2, r2, lsl #2
  005ac	e282202d	 add         r2, r2, #0x2D
  005b0	e59d1018	 ldr         r1, [sp, #0x18]
  005b4	e59d0098	 ldr         r0, [sp, #0x98]
  005b8	eb000000	 bl          ReadInfo
  005bc	e58d0080	 str         r0, [sp, #0x80]
  005c0	e59d3080	 ldr         r3, [sp, #0x80]
  005c4	e58d3008	 str         r3, [sp, #8]

; 706  :         pInfo->aBlocks[i] = (code1 & 0xFFFF) + 1;

  005c8	e59d2008	 ldr         r2, [sp, #8]
  005cc	e3a03cff	 mov         r3, #0xFF, 24
  005d0	e38330ff	 orr         r3, r3, #0xFF
  005d4	e0023003	 and         r3, r2, r3
  005d8	e2830001	 add         r0, r3, #1
  005dc	e59d3098	 ldr         r3, [sp, #0x98]
  005e0	e2831038	 add         r1, r3, #0x38
  005e4	e59d2010	 ldr         r2, [sp, #0x10]
  005e8	e3a03004	 mov         r3, #4
  005ec	e0030392	 mul         r3, r2, r3
  005f0	e0813003	 add         r3, r1, r3
  005f4	e5830000	 str         r0, [r3]

; 707  :         pInfo->aBlockSize[i] = (code1 >> 8) & 0x00FFFF00;

  005f8	e59d3008	 ldr         r3, [sp, #8]
  005fc	e1a02423	 mov         r2, r3, lsr #8
  00600	e3e034ff	 mvn         r3, #0xFF, 8
  00604	e22330ff	 eor         r3, r3, #0xFF
  00608	e0020003	 and         r0, r2, r3
  0060c	e59d3098	 ldr         r3, [sp, #0x98]
  00610	e2831018	 add         r1, r3, #0x18
  00614	e59d2010	 ldr         r2, [sp, #0x10]
  00618	e3a03004	 mov         r3, #4
  0061c	e0030392	 mul         r3, r2, r3
  00620	e0813003	 add         r3, r1, r3
  00624	e5830000	 str         r0, [r3]

; 708  :         if (pInfo->aBlockSize[i] == 0) pInfo->aBlockSize[i] = 128;

  00628	e59d3098	 ldr         r3, [sp, #0x98]
  0062c	e2831018	 add         r1, r3, #0x18
  00630	e59d2010	 ldr         r2, [sp, #0x10]
  00634	e3a03004	 mov         r3, #4
  00638	e0030392	 mul         r3, r2, r3
  0063c	e0813003	 add         r3, r1, r3
  00640	e5933000	 ldr         r3, [r3]
  00644	e3530000	 cmp         r3, #0
  00648	1a000007	 bne         |$LN5@OALFlashIn|
  0064c	e59d3098	 ldr         r3, [sp, #0x98]
  00650	e2831018	 add         r1, r3, #0x18
  00654	e59d2010	 ldr         r2, [sp, #0x10]
  00658	e3a03004	 mov         r3, #4
  0065c	e0030392	 mul         r3, r2, r3
  00660	e0812003	 add         r2, r1, r3
  00664	e3a03080	 mov         r3, #0x80
  00668	e5823000	 str         r3, [r2]
  0066c		 |$LN5@OALFlashIn|

; 709  :         }

  0066c	eaffffc0	 b           |$LN7@OALFlashIn|
  00670		 |$LN6@OALFlashIn|

; 710  : 
; 711  :     // Switch back to read mode
; 712  :     switch (pInfo->set)

  00670	e59d3098	 ldr         r3, [sp, #0x98]
  00674	e2833008	 add         r3, r3, #8
  00678	e5933000	 ldr         r3, [r3]
  0067c	e58d3084	 str         r3, [sp, #0x84]
  00680	e59d3084	 ldr         r3, [sp, #0x84]
  00684	e3530001	 cmp         r3, #1
  00688	0a000006	 beq         |$LN2@OALFlashIn|
  0068c	e59d3084	 ldr         r3, [sp, #0x84]
  00690	e3530002	 cmp         r3, #2
  00694	0a000009	 beq         |$LN1@OALFlashIn|
  00698	e59d3084	 ldr         r3, [sp, #0x84]
  0069c	e3530003	 cmp         r3, #3
  006a0	0a000000	 beq         |$LN2@OALFlashIn|
  006a4	ea00000a	 b           |$LN3@OALFlashIn|
  006a8		 |$LN2@OALFlashIn|

; 713  :         {
; 714  :         case 1:  // Intel/Sharp
; 715  :         case 3:
; 716  :             WriteCommand(pInfo, base, 0, 0xFF);

  006a8	e3a030ff	 mov         r3, #0xFF
  006ac	e3a02000	 mov         r2, #0
  006b0	e59d1018	 ldr         r1, [sp, #0x18]
  006b4	e59d0098	 ldr         r0, [sp, #0x98]
  006b8	eb000000	 bl          WriteCommand

; 717  :             break;

  006bc	ea000004	 b           |$LN3@OALFlashIn|
  006c0		 |$LN1@OALFlashIn|

; 718  :         case 2:  // AMD/Fujitsu
; 719  :             WriteCommand(pInfo, base, 0, 0xF0);

  006c0	e3a030f0	 mov         r3, #0xF0
  006c4	e3a02000	 mov         r2, #0
  006c8	e59d1018	 ldr         r1, [sp, #0x18]
  006cc	e59d0098	 ldr         r0, [sp, #0x98]
  006d0	eb000000	 bl          WriteCommand
  006d4		 |$LN3@OALFlashIn|

; 720  :             break;
; 721  :         }      
; 722  : 
; 723  :     rc = TRUE;

  006d4	e3a03001	 mov         r3, #1
  006d8	e58d300c	 str         r3, [sp, #0xC]
  006dc		 |$cleanUp$43380|

; 724  : 
; 725  : cleanUp:
; 726  :     OALMSG(OAL_FUNC, (L"-OALFlashInfo(rc = %d)\r\n", rc));

  006dc	e59f3044	 ldr         r3, [pc, #0x44]
  006e0	e5933440	 ldr         r3, [r3, #0x440]
  006e4	e3130004	 tst         r3, #4
  006e8	0a000005	 beq         |$LN31@OALFlashIn|
  006ec	e59d100c	 ldr         r1, [sp, #0xC]
  006f0	e59f002c	 ldr         r0, [pc, #0x2C]
  006f4	eb000000	 bl          NKDbgPrintfW
  006f8	e3a03001	 mov         r3, #1
  006fc	e58d3088	 str         r3, [sp, #0x88]
  00700	ea000001	 b           |$LN32@OALFlashIn|
  00704		 |$LN31@OALFlashIn|
  00704	e3a03000	 mov         r3, #0
  00708	e58d3088	 str         r3, [sp, #0x88]
  0070c		 |$LN32@OALFlashIn|

; 727  :     return rc;

  0070c	e59d300c	 ldr         r3, [sp, #0xC]
  00710	e58d3040	 str         r3, [sp, #0x40]

; 728  : }

  00714	e59d0040	 ldr         r0, [sp, #0x40]
  00718	e28dd08c	 add         sp, sp, #0x8C
  0071c	e89d6000	 ldmia       sp, {sp, lr}
  00720	e12fff1e	 bx          lr
  00724		 |$LN36@OALFlashIn|
  00724		 |$LN37@OALFlashIn|
  00724	00000000	 DCD         |??_C@_1DC@LLEMLIAM@?$AA?9?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAI?$AAn?$AAf?$AAo?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  00728		 |$LN38@OALFlashIn|
  00728	00000000	 DCD         |dpCurSettings|
  0072c		 |$LN39@OALFlashIn|
  0072c	59595959	 DCD         0x59595959
  00730		 |$LN40@OALFlashIn|
  00730	52525252	 DCD         0x52525252
  00734		 |$LN41@OALFlashIn|
  00734	51515151	 DCD         0x51515151
  00738		 |$LN42@OALFlashIn|
  00738	98989898	 DCD         0x98989898
  0073c		 |$LN43@OALFlashIn|
  0073c	00000000	 DCD         |??_C@_1DK@HABCIMDF@?$AA?$CL?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAI?$AAn?$AAf?$AAo?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?0?$AA?5?$AA?4?$AA?4?$AA?4?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  00740		 |$M43724|

			 ENDP  ; |OALFlashInfo|


  00008			 AREA	 |.pdata|, PDATA
|$T43740| DCD	|$LN18@ReadInfo|
	DCD	0x40007004
; Function compile flags: /Odtp

  00740			 AREA	 |.text|, CODE, ARM

  00740		 |ReadInfo| PROC

; 146  : {

  00740		 |$LN18@ReadInfo|
  00740	e1a0c00d	 mov         r12, sp
  00744	e92d000f	 stmdb       sp!, {r0 - r3}
  00748	e92d5000	 stmdb       sp!, {r12, lr}
  0074c	e24dd018	 sub         sp, sp, #0x18
  00750		 |$M43737|

; 147  :     DWORD data = 0;

  00750	e3a03000	 mov         r3, #0
  00754	e58d3004	 str         r3, [sp, #4]

; 148  :     ULONG count = (INT32)size;

  00758	e59d3030	 ldr         r3, [sp, #0x30]
  0075c	e58d3000	 str         r3, [sp]

; 149  :     
; 150  :     switch (pInfo->width)

  00760	e59d3020	 ldr         r3, [sp, #0x20]
  00764	e5933000	 ldr         r3, [r3]
  00768	e58d300c	 str         r3, [sp, #0xC]
  0076c	e59d300c	 ldr         r3, [sp, #0xC]
  00770	e3530001	 cmp         r3, #1
  00774	0a000046	 beq         |$LN3@ReadInfo|
  00778	e59d300c	 ldr         r3, [sp, #0xC]
  0077c	e3530002	 cmp         r3, #2
  00780	0a000022	 beq         |$LN7@ReadInfo|
  00784	e59d300c	 ldr         r3, [sp, #0xC]
  00788	e3530004	 cmp         r3, #4
  0078c	0a000000	 beq         |$LN11@ReadInfo|
  00790	ea000054	 b           |$LN12@ReadInfo|
  00794		 |$LN11@ReadInfo|

; 151  :         {
; 152  :         case 4:        
; 153  :             if (shift >= 4) shift = 0;

  00794	e59d302c	 ldr         r3, [sp, #0x2C]
  00798	e3530004	 cmp         r3, #4
  0079c	3a000001	 bcc         |$LN10@ReadInfo|
  007a0	e3a03000	 mov         r3, #0
  007a4	e58d302c	 str         r3, [sp, #0x2C]
  007a8		 |$LN10@ReadInfo|
  007a8		 |$LN9@ReadInfo|

; 154  :             while (count-- > 0)

  007a8	e59d3000	 ldr         r3, [sp]
  007ac	e3530000	 cmp         r3, #0
  007b0	e59d3000	 ldr         r3, [sp]
  007b4	e2433001	 sub         r3, r3, #1
  007b8	e58d3000	 str         r3, [sp]
  007bc	9a000012	 bls         |$LN8@ReadInfo|

; 155  :                 {
; 156  :                 data <<= 8;

  007c0	e59d3004	 ldr         r3, [sp, #4]
  007c4	e1a03403	 mov         r3, r3, lsl #8
  007c8	e58d3004	 str         r3, [sp, #4]

; 157  :                 data |= INREG32(
; 158  :                         (UINT32*)(base + ((offset + count) << 2) + shift)
; 159  :                     ) & 0xFF;

  007cc	e59d2028	 ldr         r2, [sp, #0x28]
  007d0	e59d3000	 ldr         r3, [sp]
  007d4	e0823003	 add         r3, r2, r3
  007d8	e1a02103	 mov         r2, r3, lsl #2
  007dc	e59d3024	 ldr         r3, [sp, #0x24]
  007e0	e0832002	 add         r2, r3, r2
  007e4	e59d302c	 ldr         r3, [sp, #0x2C]
  007e8	e0820003	 add         r0, r2, r3
  007ec	eb000000	 bl          READ_REGISTER_ULONG
  007f0	e58d0010	 str         r0, [sp, #0x10]
  007f4	e59d3010	 ldr         r3, [sp, #0x10]
  007f8	e20320ff	 and         r2, r3, #0xFF
  007fc	e59d3004	 ldr         r3, [sp, #4]
  00800	e1833002	 orr         r3, r3, r2
  00804	e58d3004	 str         r3, [sp, #4]

; 160  :                 }

  00808	eaffffe6	 b           |$LN9@ReadInfo|
  0080c		 |$LN8@ReadInfo|

; 161  :             break;

  0080c	ea000035	 b           |$LN12@ReadInfo|
  00810		 |$LN7@ReadInfo|

; 162  :         case 2:        
; 163  :             if (shift >= 2) shift = 0;

  00810	e59d302c	 ldr         r3, [sp, #0x2C]
  00814	e3530002	 cmp         r3, #2
  00818	3a000001	 bcc         |$LN6@ReadInfo|
  0081c	e3a03000	 mov         r3, #0
  00820	e58d302c	 str         r3, [sp, #0x2C]
  00824		 |$LN6@ReadInfo|
  00824		 |$LN5@ReadInfo|

; 164  :             while (count-- > 0)

  00824	e59d3000	 ldr         r3, [sp]
  00828	e3530000	 cmp         r3, #0
  0082c	e59d3000	 ldr         r3, [sp]
  00830	e2433001	 sub         r3, r3, #1
  00834	e58d3000	 str         r3, [sp]
  00838	9a000014	 bls         |$LN4@ReadInfo|

; 165  :                 {
; 166  :                 data <<= 8;

  0083c	e59d3004	 ldr         r3, [sp, #4]
  00840	e1a03403	 mov         r3, r3, lsl #8
  00844	e58d3004	 str         r3, [sp, #4]

; 167  :                 data |= INREG16(
; 168  :                         (UINT16*)(base + ((offset + count) << 1) + shift)
; 169  :                     ) & 0xFF;

  00848	e59d2028	 ldr         r2, [sp, #0x28]
  0084c	e59d3000	 ldr         r3, [sp]
  00850	e0823003	 add         r3, r2, r3
  00854	e1a02083	 mov         r2, r3, lsl #1
  00858	e59d3024	 ldr         r3, [sp, #0x24]
  0085c	e0832002	 add         r2, r3, r2
  00860	e59d302c	 ldr         r3, [sp, #0x2C]
  00864	e0820003	 add         r0, r2, r3
  00868	eb000000	 bl          READ_REGISTER_USHORT
  0086c	e1a03800	 mov         r3, r0, lsl #16
  00870	e1a03823	 mov         r3, r3, lsr #16
  00874	e1cd31b4	 strh        r3, [sp, #0x14]
  00878	e1dd31b4	 ldrh        r3, [sp, #0x14]
  0087c	e20320ff	 and         r2, r3, #0xFF
  00880	e59d3004	 ldr         r3, [sp, #4]
  00884	e1833002	 orr         r3, r3, r2
  00888	e58d3004	 str         r3, [sp, #4]

; 170  :                 }

  0088c	eaffffe4	 b           |$LN5@ReadInfo|
  00890		 |$LN4@ReadInfo|

; 171  :             break;

  00890	ea000014	 b           |$LN12@ReadInfo|
  00894		 |$LN3@ReadInfo|
  00894		 |$LN2@ReadInfo|

; 172  :         case 1:
; 173  :             while (count-- > 0)

  00894	e59d3000	 ldr         r3, [sp]
  00898	e3530000	 cmp         r3, #0
  0089c	e59d3000	 ldr         r3, [sp]
  008a0	e2433001	 sub         r3, r3, #1
  008a4	e58d3000	 str         r3, [sp]
  008a8	9a00000e	 bls         |$LN1@ReadInfo|

; 174  :                 {
; 175  :                 data <<= 8;

  008ac	e59d3004	 ldr         r3, [sp, #4]
  008b0	e1a03403	 mov         r3, r3, lsl #8
  008b4	e58d3004	 str         r3, [sp, #4]

; 176  :                 data |= INREG8((UINT8*)(base + offset + count));

  008b8	e59d2024	 ldr         r2, [sp, #0x24]
  008bc	e59d3028	 ldr         r3, [sp, #0x28]
  008c0	e0822003	 add         r2, r2, r3
  008c4	e59d3000	 ldr         r3, [sp]
  008c8	e0820003	 add         r0, r2, r3
  008cc	eb000000	 bl          READ_REGISTER_UCHAR
  008d0	e5cd0016	 strb        r0, [sp, #0x16]
  008d4	e5dd2016	 ldrb        r2, [sp, #0x16]
  008d8	e59d3004	 ldr         r3, [sp, #4]
  008dc	e1833002	 orr         r3, r3, r2
  008e0	e58d3004	 str         r3, [sp, #4]

; 177  :                 }

  008e4	eaffffea	 b           |$LN2@ReadInfo|
  008e8		 |$LN1@ReadInfo|
  008e8		 |$LN12@ReadInfo|

; 178  :             break;
; 179  :         }
; 180  : 
; 181  :     return data;            

  008e8	e59d3004	 ldr         r3, [sp, #4]
  008ec	e58d3008	 str         r3, [sp, #8]

; 182  : }

  008f0	e59d0008	 ldr         r0, [sp, #8]
  008f4	e28dd018	 add         sp, sp, #0x18
  008f8	e89d6000	 ldmia       sp, {sp, lr}
  008fc	e12fff1e	 bx          lr
  00900		 |$M43738|

			 ENDP  ; |ReadInfo|


  00010			 AREA	 |.pdata|, PDATA
|$T43745| DCD	|$LN21@WriteComma|
	DCD	0x40006804
; Function compile flags: /Odtp

  00900			 AREA	 |.text|, CODE, ARM

  00900		 |WriteCommand| PROC

; 193  : {

  00900		 |$LN21@WriteComma|
  00900	e1a0c00d	 mov         r12, sp
  00904	e92d000f	 stmdb       sp!, {r0 - r3}
  00908	e92d5000	 stmdb       sp!, {r12, lr}
  0090c	e24dd010	 sub         sp, sp, #0x10
  00910		 |$M43742|

; 194  :     DWORD code;
; 195  :     ULONG width = pInfo->width;

  00910	e59d3018	 ldr         r3, [sp, #0x18]
  00914	e5933000	 ldr         r3, [r3]
  00918	e58d3008	 str         r3, [sp, #8]

; 196  :     ULONG parallel = pInfo->parallel;

  0091c	e59d3018	 ldr         r3, [sp, #0x18]
  00920	e2833004	 add         r3, r3, #4
  00924	e5933000	 ldr         r3, [r3]
  00928	e58d3004	 str         r3, [sp, #4]

; 197  :         
; 198  :     switch (width)

  0092c	e59d3008	 ldr         r3, [sp, #8]
  00930	e58d300c	 str         r3, [sp, #0xC]
  00934	e59d300c	 ldr         r3, [sp, #0xC]
  00938	e3530001	 cmp         r3, #1
  0093c	0a000048	 beq         |$LN2@WriteComma|
  00940	e59d300c	 ldr         r3, [sp, #0xC]
  00944	e3530002	 cmp         r3, #2
  00948	0a00002b	 beq         |$LN7@WriteComma|
  0094c	e59d300c	 ldr         r3, [sp, #0xC]
  00950	e3530004	 cmp         r3, #4
  00954	0a000000	 beq         |$LN14@WriteComma|
  00958	ea00004d	 b           |$LN15@WriteComma|
  0095c		 |$LN14@WriteComma|

; 199  :         {
; 200  :         case 4:
; 201  :             if (parallel == 4)

  0095c	e59d3004	 ldr         r3, [sp, #4]
  00960	e3530004	 cmp         r3, #4
  00964	1a00000c	 bne         |$LN13@WriteComma|

; 202  :                 {
; 203  :                 code = cmd | (cmd << 8) | (cmd << 16) | (cmd << 24);

  00968	e5dd3024	 ldrb        r3, [sp, #0x24]
  0096c	e1a02003	 mov         r2, r3
  00970	e5dd3024	 ldrb        r3, [sp, #0x24]
  00974	e1a03403	 mov         r3, r3, lsl #8
  00978	e1822003	 orr         r2, r2, r3
  0097c	e5dd3024	 ldrb        r3, [sp, #0x24]
  00980	e1a03803	 mov         r3, r3, lsl #16
  00984	e1822003	 orr         r2, r2, r3
  00988	e5dd3024	 ldrb        r3, [sp, #0x24]
  0098c	e1a03c03	 mov         r3, r3, lsl #24
  00990	e1823003	 orr         r3, r2, r3
  00994	e58d3000	 str         r3, [sp]
  00998	ea000010	 b           |$LN12@WriteComma|
  0099c		 |$LN13@WriteComma|

; 204  :                 }
; 205  :             else if (parallel == 2) 

  0099c	e59d3004	 ldr         r3, [sp, #4]
  009a0	e3530002	 cmp         r3, #2
  009a4	1a000006	 bne         |$LN11@WriteComma|

; 206  :                 {
; 207  :                 code = cmd | (cmd << 16);

  009a8	e5dd3024	 ldrb        r3, [sp, #0x24]
  009ac	e1a02003	 mov         r2, r3
  009b0	e5dd3024	 ldrb        r3, [sp, #0x24]
  009b4	e1a03803	 mov         r3, r3, lsl #16
  009b8	e1823003	 orr         r3, r2, r3
  009bc	e58d3000	 str         r3, [sp]
  009c0	ea000006	 b           |$LN10@WriteComma|
  009c4		 |$LN11@WriteComma|

; 208  :                 }
; 209  :             else if (parallel == 1)

  009c4	e59d3004	 ldr         r3, [sp, #4]
  009c8	e3530001	 cmp         r3, #1
  009cc	1a000002	 bne         |$LN9@WriteComma|

; 210  :                 {
; 211  :                 code = cmd;

  009d0	e5dd3024	 ldrb        r3, [sp, #0x24]
  009d4	e58d3000	 str         r3, [sp]

; 212  :                 }
; 213  :             else

  009d8	ea000000	 b           |$LN8@WriteComma|
  009dc		 |$LN9@WriteComma|

; 214  :                 {
; 215  :                 break;

  009dc	ea00002c	 b           |$LN15@WriteComma|
  009e0		 |$LN8@WriteComma|
  009e0		 |$LN10@WriteComma|
  009e0		 |$LN12@WriteComma|

; 216  :                 }
; 217  :             OUTREG32((UINT32*)(base + (offset << 2)), code);

  009e0	e59d1000	 ldr         r1, [sp]
  009e4	e59d3020	 ldr         r3, [sp, #0x20]
  009e8	e1a02103	 mov         r2, r3, lsl #2
  009ec	e59d301c	 ldr         r3, [sp, #0x1C]
  009f0	e0830002	 add         r0, r3, r2
  009f4	eb000000	 bl          WRITE_REGISTER_ULONG

; 218  :             break;

  009f8	ea000025	 b           |$LN15@WriteComma|
  009fc		 |$LN7@WriteComma|

; 219  :         case 2:
; 220  :             if (parallel == 2)

  009fc	e59d3004	 ldr         r3, [sp, #4]
  00a00	e3530002	 cmp         r3, #2
  00a04	1a000006	 bne         |$LN6@WriteComma|

; 221  :                 {
; 222  :                 code = cmd | (cmd << 8);

  00a08	e5dd3024	 ldrb        r3, [sp, #0x24]
  00a0c	e1a02003	 mov         r2, r3
  00a10	e5dd3024	 ldrb        r3, [sp, #0x24]
  00a14	e1a03403	 mov         r3, r3, lsl #8
  00a18	e1823003	 orr         r3, r2, r3
  00a1c	e58d3000	 str         r3, [sp]
  00a20	ea000006	 b           |$LN5@WriteComma|
  00a24		 |$LN6@WriteComma|

; 223  :                 }
; 224  :             else if (parallel == 1)

  00a24	e59d3004	 ldr         r3, [sp, #4]
  00a28	e3530001	 cmp         r3, #1
  00a2c	1a000002	 bne         |$LN4@WriteComma|

; 225  :                 {
; 226  :                 code = cmd;

  00a30	e5dd3024	 ldrb        r3, [sp, #0x24]
  00a34	e58d3000	 str         r3, [sp]

; 227  :                 }
; 228  :             else

  00a38	ea000000	 b           |$LN3@WriteComma|
  00a3c		 |$LN4@WriteComma|

; 229  :                 {
; 230  :                 break;

  00a3c	ea000014	 b           |$LN15@WriteComma|
  00a40		 |$LN3@WriteComma|
  00a40		 |$LN5@WriteComma|

; 231  :                 }
; 232  :             OUTREG16((UINT16*)(base + (offset << 1)), code);

  00a40	e59d3000	 ldr         r3, [sp]
  00a44	e1a01803	 mov         r1, r3, lsl #16
  00a48	e1a01821	 mov         r1, r1, lsr #16
  00a4c	e59d3020	 ldr         r3, [sp, #0x20]
  00a50	e1a02083	 mov         r2, r3, lsl #1
  00a54	e59d301c	 ldr         r3, [sp, #0x1C]
  00a58	e0830002	 add         r0, r3, r2
  00a5c	eb000000	 bl          WRITE_REGISTER_USHORT

; 233  :             break;

  00a60	ea00000b	 b           |$LN15@WriteComma|
  00a64		 |$LN2@WriteComma|

; 234  :         case 1:
; 235  :             if (parallel != 1) break;

  00a64	e59d3004	 ldr         r3, [sp, #4]
  00a68	e3530001	 cmp         r3, #1
  00a6c	0a000000	 beq         |$LN1@WriteComma|
  00a70	ea000007	 b           |$LN15@WriteComma|
  00a74		 |$LN1@WriteComma|

; 236  :             code = cmd;

  00a74	e5dd3024	 ldrb        r3, [sp, #0x24]
  00a78	e58d3000	 str         r3, [sp]

; 237  :             OUTREG8((UINT8*)(base + offset), code);

  00a7c	e59d3000	 ldr         r3, [sp]
  00a80	e20310ff	 and         r1, r3, #0xFF
  00a84	e59d201c	 ldr         r2, [sp, #0x1C]
  00a88	e59d3020	 ldr         r3, [sp, #0x20]
  00a8c	e0820003	 add         r0, r2, r3
  00a90	eb000000	 bl          WRITE_REGISTER_UCHAR
  00a94		 |$LN15@WriteComma|

; 238  :             break;
; 239  :         }
; 240  : }

  00a94	e28dd010	 add         sp, sp, #0x10
  00a98	e89d6000	 ldmia       sp, {sp, lr}
  00a9c	e12fff1e	 bx          lr
  00aa0		 |$M43743|

			 ENDP  ; |WriteCommand|

	EXPORT	|OALFlashTiming|

  00018			 AREA	 |.pdata|, PDATA
|$T43757| DCD	|$LN10@OALFlashTi|
	DCD	0x40007b04
; Function compile flags: /Odtp

  00aa0			 AREA	 |.text|, CODE, ARM

  00aa0		 |OALFlashTiming| PROC

; 737  : {

  00aa0		 |$LN10@OALFlashTi|
  00aa0	e1a0c00d	 mov         r12, sp
  00aa4	e92d0003	 stmdb       sp!, {r0, r1}
  00aa8	e92d5000	 stmdb       sp!, {r12, lr}
  00aac	e24dd0a0	 sub         sp, sp, #0xA0
  00ab0		 |$M43754|

; 738  :     BOOL rc = FALSE;

  00ab0	e3a03000	 mov         r3, #0
  00ab4	e58d3004	 str         r3, [sp, #4]

; 739  :     UINT32 base = (UINT32)pBase;

  00ab8	e59d30a8	 ldr         r3, [sp, #0xA8]
  00abc	e58d3008	 str         r3, [sp, #8]

; 740  :     OAL_FLASH_INFO info;
; 741  : 
; 742  :     // Ther read first chip info
; 743  :     if (!OALFlashInfo((VOID*)base, &info)) goto cleanUp;

  00ac0	e28d100c	 add         r1, sp, #0xC
  00ac4	e59d0008	 ldr         r0, [sp, #8]
  00ac8	eb000000	 bl          OALFlashInfo
  00acc	e58d0080	 str         r0, [sp, #0x80]
  00ad0	e59d3080	 ldr         r3, [sp, #0x80]
  00ad4	e3530000	 cmp         r3, #0
  00ad8	1a000000	 bne         |$LN5@OALFlashTi|
  00adc	ea000064	 b           |$cleanUp$43410|
  00ae0		 |$LN5@OALFlashTi|

; 744  : 
; 745  :     // Switch to CFI Query
; 746  :     WriteCommand(&info, base, 0x55, 0x98);

  00ae0	e3a03098	 mov         r3, #0x98
  00ae4	e3a02055	 mov         r2, #0x55
  00ae8	e59d1008	 ldr         r1, [sp, #8]
  00aec	e28d000c	 add         r0, sp, #0xC
  00af0	eb000000	 bl          WriteCommand

; 747  :     
; 748  :     // Read timeout parameters
; 749  :     pTimingInfo->writeDelay    = ReadInfo(&info, base, 0x1F, 0, 1);

  00af4	e3a03001	 mov         r3, #1
  00af8	e58d3000	 str         r3, [sp]
  00afc	e3a03000	 mov         r3, #0
  00b00	e3a0201f	 mov         r2, #0x1F
  00b04	e59d1008	 ldr         r1, [sp, #8]
  00b08	e28d000c	 add         r0, sp, #0xC
  00b0c	eb000000	 bl          ReadInfo
  00b10	e58d0084	 str         r0, [sp, #0x84]
  00b14	e59d2084	 ldr         r2, [sp, #0x84]
  00b18	e59d30ac	 ldr         r3, [sp, #0xAC]
  00b1c	e5832000	 str         r2, [r3]

; 750  :     pTimingInfo->writeTimeout  = ReadInfo(&info, base, 0x23, 0, 1);

  00b20	e3a03001	 mov         r3, #1
  00b24	e58d3000	 str         r3, [sp]
  00b28	e3a03000	 mov         r3, #0
  00b2c	e3a02023	 mov         r2, #0x23
  00b30	e59d1008	 ldr         r1, [sp, #8]
  00b34	e28d000c	 add         r0, sp, #0xC
  00b38	eb000000	 bl          ReadInfo
  00b3c	e58d0088	 str         r0, [sp, #0x88]
  00b40	e59d30ac	 ldr         r3, [sp, #0xAC]
  00b44	e2832004	 add         r2, r3, #4
  00b48	e59d3088	 ldr         r3, [sp, #0x88]
  00b4c	e5823000	 str         r3, [r2]

; 751  :     pTimingInfo->bufferDelay   = ReadInfo(&info, base, 0x20, 0, 1);

  00b50	e3a03001	 mov         r3, #1
  00b54	e58d3000	 str         r3, [sp]
  00b58	e3a03000	 mov         r3, #0
  00b5c	e3a02020	 mov         r2, #0x20
  00b60	e59d1008	 ldr         r1, [sp, #8]
  00b64	e28d000c	 add         r0, sp, #0xC
  00b68	eb000000	 bl          ReadInfo
  00b6c	e58d008c	 str         r0, [sp, #0x8C]
  00b70	e59d30ac	 ldr         r3, [sp, #0xAC]
  00b74	e2832008	 add         r2, r3, #8
  00b78	e59d308c	 ldr         r3, [sp, #0x8C]
  00b7c	e5823000	 str         r3, [r2]

; 752  :     pTimingInfo->bufferTimeout = ReadInfo(&info, base, 0x24, 0, 1);

  00b80	e3a03001	 mov         r3, #1
  00b84	e58d3000	 str         r3, [sp]
  00b88	e3a03000	 mov         r3, #0
  00b8c	e3a02024	 mov         r2, #0x24
  00b90	e59d1008	 ldr         r1, [sp, #8]
  00b94	e28d000c	 add         r0, sp, #0xC
  00b98	eb000000	 bl          ReadInfo
  00b9c	e58d0090	 str         r0, [sp, #0x90]
  00ba0	e59d30ac	 ldr         r3, [sp, #0xAC]
  00ba4	e283200c	 add         r2, r3, #0xC
  00ba8	e59d3090	 ldr         r3, [sp, #0x90]
  00bac	e5823000	 str         r3, [r2]

; 753  :     pTimingInfo->eraseDelay    = ReadInfo(&info, base, 0x21, 0, 1);

  00bb0	e3a03001	 mov         r3, #1
  00bb4	e58d3000	 str         r3, [sp]
  00bb8	e3a03000	 mov         r3, #0
  00bbc	e3a02021	 mov         r2, #0x21
  00bc0	e59d1008	 ldr         r1, [sp, #8]
  00bc4	e28d000c	 add         r0, sp, #0xC
  00bc8	eb000000	 bl          ReadInfo
  00bcc	e58d0094	 str         r0, [sp, #0x94]
  00bd0	e59d30ac	 ldr         r3, [sp, #0xAC]
  00bd4	e2832010	 add         r2, r3, #0x10
  00bd8	e59d3094	 ldr         r3, [sp, #0x94]
  00bdc	e5823000	 str         r3, [r2]

; 754  :     pTimingInfo->eraseTimeout  = ReadInfo(&info, base, 0x25, 0, 1);

  00be0	e3a03001	 mov         r3, #1
  00be4	e58d3000	 str         r3, [sp]
  00be8	e3a03000	 mov         r3, #0
  00bec	e3a02025	 mov         r2, #0x25
  00bf0	e59d1008	 ldr         r1, [sp, #8]
  00bf4	e28d000c	 add         r0, sp, #0xC
  00bf8	eb000000	 bl          ReadInfo
  00bfc	e58d0098	 str         r0, [sp, #0x98]
  00c00	e59d30ac	 ldr         r3, [sp, #0xAC]
  00c04	e2832014	 add         r2, r3, #0x14
  00c08	e59d3098	 ldr         r3, [sp, #0x98]
  00c0c	e5823000	 str         r3, [r2]

; 755  : 
; 756  :     // Switch back to read mode
; 757  :     switch (info.set)

  00c10	e59d3014	 ldr         r3, [sp, #0x14]
  00c14	e58d309c	 str         r3, [sp, #0x9C]
  00c18	e59d309c	 ldr         r3, [sp, #0x9C]
  00c1c	e3530001	 cmp         r3, #1
  00c20	0a000006	 beq         |$LN2@OALFlashTi|
  00c24	e59d309c	 ldr         r3, [sp, #0x9C]
  00c28	e3530002	 cmp         r3, #2
  00c2c	0a000009	 beq         |$LN1@OALFlashTi|
  00c30	e59d309c	 ldr         r3, [sp, #0x9C]
  00c34	e3530003	 cmp         r3, #3
  00c38	0a000000	 beq         |$LN2@OALFlashTi|
  00c3c	ea00000a	 b           |$LN3@OALFlashTi|
  00c40		 |$LN2@OALFlashTi|

; 758  :         {
; 759  :         case 1:  // Intel/Sharp
; 760  :         case 3:
; 761  :             WriteCommand(&info, base, 0, 0xFF);

  00c40	e3a030ff	 mov         r3, #0xFF
  00c44	e3a02000	 mov         r2, #0
  00c48	e59d1008	 ldr         r1, [sp, #8]
  00c4c	e28d000c	 add         r0, sp, #0xC
  00c50	eb000000	 bl          WriteCommand

; 762  :             break;

  00c54	ea000004	 b           |$LN3@OALFlashTi|
  00c58		 |$LN1@OALFlashTi|

; 763  :         case 2:  // AMD/Fujitsu
; 764  :             WriteCommand(&info, base, 0, 0xF0);

  00c58	e3a030f0	 mov         r3, #0xF0
  00c5c	e3a02000	 mov         r2, #0
  00c60	e59d1008	 ldr         r1, [sp, #8]
  00c64	e28d000c	 add         r0, sp, #0xC
  00c68	eb000000	 bl          WriteCommand
  00c6c		 |$LN3@OALFlashTi|

; 765  :             break;
; 766  :         }      
; 767  : 
; 768  :     rc = TRUE;

  00c6c	e3a03001	 mov         r3, #1
  00c70	e58d3004	 str         r3, [sp, #4]
  00c74		 |$cleanUp$43410|

; 769  :     
; 770  : cleanUp:
; 771  :     return rc;

  00c74	e59d3004	 ldr         r3, [sp, #4]
  00c78	e58d307c	 str         r3, [sp, #0x7C]

; 772  : }

  00c7c	e59d007c	 ldr         r0, [sp, #0x7C]
  00c80	e28dd0a0	 add         sp, sp, #0xA0
  00c84	e89d6000	 ldmia       sp, {sp, lr}
  00c88	e12fff1e	 bx          lr
  00c8c		 |$M43755|

			 ENDP  ; |OALFlashTiming|

	EXPORT	|OALFlashLock|

  00020			 AREA	 |.pdata|, PDATA
|$T43763| DCD	|$LN20@OALFlashLo|
	DCD	0x40008904
; Function compile flags: /Odtp

  00c8c			 AREA	 |.text|, CODE, ARM

  00c8c		 |OALFlashLock| PROC

; 787  : {

  00c8c		 |$LN20@OALFlashLo|
  00c8c	e1a0c00d	 mov         r12, sp
  00c90	e92d000f	 stmdb       sp!, {r0 - r3}
  00c94	e92d5000	 stmdb       sp!, {r12, lr}
  00c98	e24dd094	 sub         sp, sp, #0x94
  00c9c		 |$M43760|

; 788  :     BOOL rc = FALSE;

  00c9c	e3a03000	 mov         r3, #0
  00ca0	e58d3000	 str         r3, [sp]

; 789  :     OAL_FLASH_INFO info;
; 790  :     UINT32 base = (UINT32)pBase;

  00ca4	e59d309c	 ldr         r3, [sp, #0x9C]
  00ca8	e58d3004	 str         r3, [sp, #4]

; 791  :     UINT32 start = (UINT32)pStart;

  00cac	e59d30a0	 ldr         r3, [sp, #0xA0]
  00cb0	e58d3010	 str         r3, [sp, #0x10]

; 792  :     UINT32 end, chip, blockStart, blockEnd;
; 793  :     UINT32 region, block;
; 794  : 
; 795  : 
; 796  :     // First get end addresss
; 797  :     end = start + size;

  00cb4	e59d2010	 ldr         r2, [sp, #0x10]
  00cb8	e59d30a4	 ldr         r3, [sp, #0xA4]
  00cbc	e0823003	 add         r3, r2, r3
  00cc0	e58d300c	 str         r3, [sp, #0xC]

; 798  :    
; 799  :     // Ther read first chip info
; 800  :     if (!OALFlashInfo((VOID*)base, &info))

  00cc4	e28d101c	 add         r1, sp, #0x1C
  00cc8	e59d0004	 ldr         r0, [sp, #4]
  00ccc	eb000000	 bl          OALFlashInfo
  00cd0	e58d0080	 str         r0, [sp, #0x80]
  00cd4	e59d3080	 ldr         r3, [sp, #0x80]
  00cd8	e3530000	 cmp         r3, #0
  00cdc	1a000000	 bne         |$LN15@OALFlashLo|

; 801  :         {
; 802  :             goto cleanUp;

  00ce0	ea00006c	 b           |$cleanUp$43440|
  00ce4		 |$LN15@OALFlashLo|

; 803  :         }
; 804  : 
; 805  :     region = block = 0;

  00ce4	e3a03000	 mov         r3, #0
  00ce8	e58d3078	 str         r3, [sp, #0x78]
  00cec	e59d3078	 ldr         r3, [sp, #0x78]
  00cf0	e58d3008	 str         r3, [sp, #8]

; 806  :     blockStart = chip = base;

  00cf4	e59d3004	 ldr         r3, [sp, #4]
  00cf8	e58d3018	 str         r3, [sp, #0x18]
  00cfc	e59d3018	 ldr         r3, [sp, #0x18]
  00d00	e58d3074	 str         r3, [sp, #0x74]
  00d04		 |$LN14@OALFlashLo|

; 807  :     while (blockStart < end)

  00d04	e59d2074	 ldr         r2, [sp, #0x74]
  00d08	e59d300c	 ldr         r3, [sp, #0xC]
  00d0c	e1520003	 cmp         r2, r3
  00d10	2a00005e	 bcs         |$LN13@OALFlashLo|

; 808  :         {
; 809  : 
; 810  :         // Block end
; 811  :         blockEnd = blockStart + info.aBlockSize[region] * info.parallel;

  00d14	e59d1008	 ldr         r1, [sp, #8]
  00d18	e3a03004	 mov         r3, #4
  00d1c	e0020391	 mul         r2, r1, r3
  00d20	e28d3034	 add         r3, sp, #0x34
  00d24	e0833002	 add         r3, r3, r2
  00d28	e5931000	 ldr         r1, [r3]
  00d2c	e59d3020	 ldr         r3, [sp, #0x20]
  00d30	e0020391	 mul         r2, r1, r3
  00d34	e59d3074	 ldr         r3, [sp, #0x74]
  00d38	e0833002	 add         r3, r3, r2
  00d3c	e58d3014	 str         r3, [sp, #0x14]

; 812  : 
; 813  :         // Should block be erased?
; 814  :         if (start < blockEnd && end >= blockStart)

  00d40	e59d2010	 ldr         r2, [sp, #0x10]
  00d44	e59d3014	 ldr         r3, [sp, #0x14]
  00d48	e1520003	 cmp         r2, r3
  00d4c	2a000026	 bcs         |$LN12@OALFlashLo|
  00d50	e59d200c	 ldr         r2, [sp, #0xC]
  00d54	e59d3074	 ldr         r3, [sp, #0x74]
  00d58	e1520003	 cmp         r2, r3
  00d5c	3a000022	 bcc         |$LN12@OALFlashLo|

; 815  :             {
; 816  :             switch (info.set)

  00d60	e59d3024	 ldr         r3, [sp, #0x24]
  00d64	e58d3084	 str         r3, [sp, #0x84]
  00d68	e59d3084	 ldr         r3, [sp, #0x84]
  00d6c	e3530001	 cmp         r3, #1
  00d70	0a000006	 beq         |$LN9@OALFlashLo|
  00d74	e59d3084	 ldr         r3, [sp, #0x84]
  00d78	e3530002	 cmp         r3, #2
  00d7c	0a00000e	 beq         |$LN7@OALFlashLo|
  00d80	e59d3084	 ldr         r3, [sp, #0x84]
  00d84	e3530003	 cmp         r3, #3
  00d88	0a000000	 beq         |$LN9@OALFlashLo|
  00d8c	ea000015	 b           |$LN5@OALFlashLo|
  00d90		 |$LN9@OALFlashLo|

; 817  :                 {
; 818  : 
; 819  : #ifndef OAL_FLASH_NO_COMMAND_SET_1                
; 820  :                 case 1: // Intel/Sharp
; 821  :                 case 3:
; 822  :                     if (!LockBlock1(&info, chip, blockStart, lock))

  00d90	e59d30a8	 ldr         r3, [sp, #0xA8]
  00d94	e59d2074	 ldr         r2, [sp, #0x74]
  00d98	e59d1018	 ldr         r1, [sp, #0x18]
  00d9c	e28d001c	 add         r0, sp, #0x1C
  00da0	eb000000	 bl          LockBlock1
  00da4	e58d0088	 str         r0, [sp, #0x88]
  00da8	e59d3088	 ldr         r3, [sp, #0x88]
  00dac	e3530000	 cmp         r3, #0
  00db0	1a000000	 bne         |$LN8@OALFlashLo|

; 823  :                         {
; 824  :                         goto cleanUp;

  00db4	ea000037	 b           |$cleanUp$43440|
  00db8		 |$LN8@OALFlashLo|

; 825  :                         }
; 826  :                     break;

  00db8	ea00000b	 b           |$LN10@OALFlashLo|
  00dbc		 |$LN7@OALFlashLo|

; 827  : #endif OAL_FLASH_NO_COMMAND_SET_1                
; 828  :                     
; 829  : #ifndef OAL_FLASH_NO_COMMAND_SET_2
; 830  :                 case 2: // AMD
; 831  :                     if (!LockBlock2(&info, chip, blockStart, lock))

  00dbc	e59d30a8	 ldr         r3, [sp, #0xA8]
  00dc0	e59d2074	 ldr         r2, [sp, #0x74]
  00dc4	e59d1018	 ldr         r1, [sp, #0x18]
  00dc8	e28d001c	 add         r0, sp, #0x1C
  00dcc	eb000000	 bl          LockBlock2
  00dd0	e58d008c	 str         r0, [sp, #0x8C]
  00dd4	e59d308c	 ldr         r3, [sp, #0x8C]
  00dd8	e3530000	 cmp         r3, #0
  00ddc	1a000000	 bne         |$LN6@OALFlashLo|

; 832  :                         {
; 833  :                         goto cleanUp;

  00de0	ea00002c	 b           |$cleanUp$43440|
  00de4		 |$LN6@OALFlashLo|

; 834  :                         }                    
; 835  :                     break;

  00de4	ea000000	 b           |$LN10@OALFlashLo|
  00de8		 |$LN5@OALFlashLo|

; 836  : #endif OAL_FLASH_NO_COMMAND_SET_2
; 837  :                 default:
; 838  :                     goto cleanUp;

  00de8	ea00002a	 b           |$cleanUp$43440|
  00dec		 |$LN10@OALFlashLo|
  00dec		 |$LN12@OALFlashLo|

; 839  :                 }
; 840  :             }         
; 841  : 
; 842  :         // Move to next block
; 843  :         blockStart = blockEnd;

  00dec	e59d3014	 ldr         r3, [sp, #0x14]
  00df0	e58d3074	 str         r3, [sp, #0x74]

; 844  :         if (blockStart >= end) break;

  00df4	e59d2074	 ldr         r2, [sp, #0x74]
  00df8	e59d300c	 ldr         r3, [sp, #0xC]
  00dfc	e1520003	 cmp         r2, r3
  00e00	3a000000	 bcc         |$LN4@OALFlashLo|
  00e04	ea000021	 b           |$LN13@OALFlashLo|
  00e08		 |$LN4@OALFlashLo|

; 845  :         if (++block >= info.aBlocks[region])

  00e08	e59d3078	 ldr         r3, [sp, #0x78]
  00e0c	e2833001	 add         r3, r3, #1
  00e10	e58d3078	 str         r3, [sp, #0x78]
  00e14	e59d1008	 ldr         r1, [sp, #8]
  00e18	e3a03004	 mov         r3, #4
  00e1c	e0020391	 mul         r2, r1, r3
  00e20	e28d3054	 add         r3, sp, #0x54
  00e24	e0833002	 add         r3, r3, r2
  00e28	e59d2078	 ldr         r2, [sp, #0x78]
  00e2c	e5933000	 ldr         r3, [r3]
  00e30	e1520003	 cmp         r2, r3
  00e34	3a000014	 bcc         |$LN3@OALFlashLo|

; 846  :             {
; 847  :             block = 0;

  00e38	e3a03000	 mov         r3, #0
  00e3c	e58d3078	 str         r3, [sp, #0x78]

; 848  :             if (++region >= info.regions)

  00e40	e59d3008	 ldr         r3, [sp, #8]
  00e44	e2833001	 add         r3, r3, #1
  00e48	e58d3008	 str         r3, [sp, #8]
  00e4c	e59d2008	 ldr         r2, [sp, #8]
  00e50	e59d3030	 ldr         r3, [sp, #0x30]
  00e54	e1520003	 cmp         r2, r3
  00e58	3a00000b	 bcc         |$LN2@OALFlashLo|

; 849  :                 {
; 850  :                 // Try read next chip layout
; 851  :                 if (!OALFlashInfo((VOID*)block, &info)) break;

  00e5c	e28d101c	 add         r1, sp, #0x1C
  00e60	e59d0078	 ldr         r0, [sp, #0x78]
  00e64	eb000000	 bl          OALFlashInfo
  00e68	e58d0090	 str         r0, [sp, #0x90]
  00e6c	e59d3090	 ldr         r3, [sp, #0x90]
  00e70	e3530000	 cmp         r3, #0
  00e74	1a000000	 bne         |$LN1@OALFlashLo|
  00e78	ea000004	 b           |$LN13@OALFlashLo|
  00e7c		 |$LN1@OALFlashLo|

; 852  :                 region = 0;

  00e7c	e3a03000	 mov         r3, #0
  00e80	e58d3008	 str         r3, [sp, #8]

; 853  :                 chip = block;

  00e84	e59d3078	 ldr         r3, [sp, #0x78]
  00e88	e58d3018	 str         r3, [sp, #0x18]
  00e8c		 |$LN2@OALFlashLo|
  00e8c		 |$LN3@OALFlashLo|

; 854  :                 }
; 855  :             }
; 856  :         }

  00e8c	eaffff9c	 b           |$LN14@OALFlashLo|
  00e90		 |$LN13@OALFlashLo|

; 857  : 
; 858  :     rc = TRUE;

  00e90	e3a03001	 mov         r3, #1
  00e94	e58d3000	 str         r3, [sp]
  00e98		 |$cleanUp$43440|

; 859  :    
; 860  : cleanUp:
; 861  :     return rc;

  00e98	e59d3000	 ldr         r3, [sp]
  00e9c	e58d307c	 str         r3, [sp, #0x7C]

; 862  : }

  00ea0	e59d007c	 ldr         r0, [sp, #0x7C]
  00ea4	e28dd094	 add         sp, sp, #0x94
  00ea8	e89d6000	 ldmia       sp, {sp, lr}
  00eac	e12fff1e	 bx          lr
  00eb0		 |$M43761|

			 ENDP  ; |OALFlashLock|


  00028			 AREA	 |.pdata|, PDATA
|$T43775| DCD	|$LN13@LockBlock1|
	DCD	0x40004c04
; Function compile flags: /Odtp

  00eb0			 AREA	 |.text|, CODE, ARM

  00eb0		 |LockBlock1| PROC

; 257  : {

  00eb0		 |$LN13@LockBlock1|
  00eb0	e1a0c00d	 mov         r12, sp
  00eb4	e92d000f	 stmdb       sp!, {r0 - r3}
  00eb8	e92d5000	 stmdb       sp!, {r12, lr}
  00ebc	e24dd018	 sub         sp, sp, #0x18
  00ec0		 |$M43772|

; 258  :     UCHAR command;
; 259  :     UCHAR bits;
; 260  : 
; 261  :     command = lock ? 0x01 : 0xD0;

  00ec0	e59d302c	 ldr         r3, [sp, #0x2C]
  00ec4	e3530000	 cmp         r3, #0
  00ec8	0a000002	 beq         |$LN5@LockBlock1|
  00ecc	e3a03001	 mov         r3, #1
  00ed0	e58d3008	 str         r3, [sp, #8]
  00ed4	ea000001	 b           |$LN6@LockBlock1|
  00ed8		 |$LN5@LockBlock1|
  00ed8	e3a030d0	 mov         r3, #0xD0
  00edc	e58d3008	 str         r3, [sp, #8]
  00ee0		 |$LN6@LockBlock1|
  00ee0	e59d3008	 ldr         r3, [sp, #8]
  00ee4	e20330ff	 and         r3, r3, #0xFF
  00ee8	e5cd3000	 strb        r3, [sp]

; 262  :     
; 263  :     // Set block lock
; 264  :     WriteCommand(pInfo, block, 0, 0x60);

  00eec	e3a03060	 mov         r3, #0x60
  00ef0	e3a02000	 mov         r2, #0
  00ef4	e59d1028	 ldr         r1, [sp, #0x28]
  00ef8	e59d0020	 ldr         r0, [sp, #0x20]
  00efc	eb000000	 bl          WriteCommand

; 265  :     WriteCommand(pInfo, block, 0, command);

  00f00	e5dd3000	 ldrb        r3, [sp]
  00f04	e3a02000	 mov         r2, #0
  00f08	e59d1028	 ldr         r1, [sp, #0x28]
  00f0c	e59d0020	 ldr         r0, [sp, #0x20]
  00f10	eb000000	 bl          WriteCommand

; 266  : 
; 267  :     // Verify it is correct
; 268  :     WriteCommand(pInfo, block, 0x02, 0x90);

  00f14	e3a03090	 mov         r3, #0x90
  00f18	e3a02002	 mov         r2, #2
  00f1c	e59d1028	 ldr         r1, [sp, #0x28]
  00f20	e59d0020	 ldr         r0, [sp, #0x20]
  00f24	eb000000	 bl          WriteCommand

; 269  :     if (lock)

  00f28	e59d302c	 ldr         r3, [sp, #0x2C]
  00f2c	e3530000	 cmp         r3, #0
  00f30	0a000007	 beq         |$LN2@LockBlock1|

; 270  :         {
; 271  :         bits = BitsAnd(pInfo, block, 0x02);

  00f34	e3a02002	 mov         r2, #2
  00f38	e59d1028	 ldr         r1, [sp, #0x28]
  00f3c	e59d0020	 ldr         r0, [sp, #0x20]
  00f40	eb000000	 bl          BitsAnd
  00f44	e5cd000c	 strb        r0, [sp, #0xC]
  00f48	e5dd300c	 ldrb        r3, [sp, #0xC]
  00f4c	e5cd3001	 strb        r3, [sp, #1]

; 272  :         }
; 273  :     else

  00f50	ea000006	 b           |$LN1@LockBlock1|
  00f54		 |$LN2@LockBlock1|

; 274  :         {
; 275  :         bits = BitsOr(pInfo, block, 0x02);

  00f54	e3a02002	 mov         r2, #2
  00f58	e59d1028	 ldr         r1, [sp, #0x28]
  00f5c	e59d0020	 ldr         r0, [sp, #0x20]
  00f60	eb000000	 bl          BitsOr
  00f64	e5cd000d	 strb        r0, [sp, #0xD]
  00f68	e5dd300d	 ldrb        r3, [sp, #0xD]
  00f6c	e5cd3001	 strb        r3, [sp, #1]
  00f70		 |$LN1@LockBlock1|

; 276  :         }
; 277  :     
; 278  :     // Reset memory back to normal state
; 279  :     WriteCommand(pInfo, block, 0, 0xFF);

  00f70	e3a030ff	 mov         r3, #0xFF
  00f74	e3a02000	 mov         r2, #0
  00f78	e59d1028	 ldr         r1, [sp, #0x28]
  00f7c	e59d0020	 ldr         r0, [sp, #0x20]
  00f80	eb000000	 bl          WriteCommand

; 280  : 
; 281  :     return (((bits & (1 << 0)) != 0) == lock);

  00f84	e5dd3001	 ldrb        r3, [sp, #1]
  00f88	e3130001	 tst         r3, #1
  00f8c	0a000002	 beq         |$LN7@LockBlock1|
  00f90	e3a03001	 mov         r3, #1
  00f94	e58d3010	 str         r3, [sp, #0x10]
  00f98	ea000001	 b           |$LN8@LockBlock1|
  00f9c		 |$LN7@LockBlock1|
  00f9c	e3a03000	 mov         r3, #0
  00fa0	e58d3010	 str         r3, [sp, #0x10]
  00fa4		 |$LN8@LockBlock1|
  00fa4	e59d2010	 ldr         r2, [sp, #0x10]
  00fa8	e59d302c	 ldr         r3, [sp, #0x2C]
  00fac	e1520003	 cmp         r2, r3
  00fb0	1a000002	 bne         |$LN9@LockBlock1|
  00fb4	e3a03001	 mov         r3, #1
  00fb8	e58d3014	 str         r3, [sp, #0x14]
  00fbc	ea000001	 b           |$LN10@LockBlock1|
  00fc0		 |$LN9@LockBlock1|
  00fc0	e3a03000	 mov         r3, #0
  00fc4	e58d3014	 str         r3, [sp, #0x14]
  00fc8		 |$LN10@LockBlock1|
  00fc8	e59d3014	 ldr         r3, [sp, #0x14]
  00fcc	e58d3004	 str         r3, [sp, #4]

; 282  : }

  00fd0	e59d0004	 ldr         r0, [sp, #4]
  00fd4	e28dd018	 add         sp, sp, #0x18
  00fd8	e89d6000	 ldmia       sp, {sp, lr}
  00fdc	e12fff1e	 bx          lr
  00fe0		 |$M43773|

			 ENDP  ; |LockBlock1|


  00030			 AREA	 |.pdata|, PDATA
|$T43781| DCD	|$LN19@BitsOr|
	DCD	0x40007e04
; Function compile flags: /Odtp

  00fe0			 AREA	 |.text|, CODE, ARM

  00fe0		 |BitsOr| PROC

; 40   : {

  00fe0		 |$LN19@BitsOr|
  00fe0	e1a0c00d	 mov         r12, sp
  00fe4	e92d0007	 stmdb       sp!, {r0 - r2}
  00fe8	e92d5000	 stmdb       sp!, {r12, lr}
  00fec	e24dd02c	 sub         sp, sp, #0x2C
  00ff0		 |$M43778|

; 41   :     UCHAR bits = 0;

  00ff0	e3a03000	 mov         r3, #0
  00ff4	e5cd3004	 strb        r3, [sp, #4]

; 42   :     DWORD data;    
; 43   :     ULONG width = pInfo->width;

  00ff8	e59d3034	 ldr         r3, [sp, #0x34]
  00ffc	e5933000	 ldr         r3, [r3]
  01000	e58d3008	 str         r3, [sp, #8]

; 44   :     ULONG parallel = pInfo->parallel;

  01004	e59d3034	 ldr         r3, [sp, #0x34]
  01008	e2833004	 add         r3, r3, #4
  0100c	e5933000	 ldr         r3, [r3]
  01010	e58d3000	 str         r3, [sp]

; 45   : 
; 46   :     switch (width)

  01014	e59d3008	 ldr         r3, [sp, #8]
  01018	e58d3014	 str         r3, [sp, #0x14]
  0101c	e59d3014	 ldr         r3, [sp, #0x14]
  01020	e3530001	 cmp         r3, #1
  01024	0a00005e	 beq         |$LN1@BitsOr|
  01028	e59d3014	 ldr         r3, [sp, #0x14]
  0102c	e3530002	 cmp         r3, #2
  01030	0a00003a	 beq         |$LN6@BitsOr|
  01034	e59d3014	 ldr         r3, [sp, #0x14]
  01038	e3530004	 cmp         r3, #4
  0103c	0a000000	 beq         |$LN12@BitsOr|
  01040	ea00005e	 b           |$LN13@BitsOr|
  01044		 |$LN12@BitsOr|

; 47   :         {
; 48   :         case 4:
; 49   :             data = INREG32((UINT32*)(base + (offset << 2)));

  01044	e59d303c	 ldr         r3, [sp, #0x3C]
  01048	e1a02103	 mov         r2, r3, lsl #2
  0104c	e59d3038	 ldr         r3, [sp, #0x38]
  01050	e0830002	 add         r0, r3, r2
  01054	eb000000	 bl          READ_REGISTER_ULONG
  01058	e58d0018	 str         r0, [sp, #0x18]
  0105c	e59d3018	 ldr         r3, [sp, #0x18]
  01060	e58d300c	 str         r3, [sp, #0xC]

; 50   :             switch (parallel)

  01064	e59d3000	 ldr         r3, [sp]
  01068	e58d301c	 str         r3, [sp, #0x1C]
  0106c	e59d301c	 ldr         r3, [sp, #0x1C]
  01070	e3530001	 cmp         r3, #1
  01074	0a000024	 beq         |$LN7@BitsOr|
  01078	e59d301c	 ldr         r3, [sp, #0x1C]
  0107c	e3530002	 cmp         r3, #2
  01080	0a000018	 beq         |$LN8@BitsOr|
  01084	e59d301c	 ldr         r3, [sp, #0x1C]
  01088	e3530004	 cmp         r3, #4
  0108c	0a000000	 beq         |$LN9@BitsOr|
  01090	ea000021	 b           |$LN10@BitsOr|
  01094		 |$LN9@BitsOr|

; 51   :                 {
; 52   :                 case 4:
; 53   :                     bits  = (UCHAR)(((data >> 24)&0xFF) | ((data >> 16)&0xFF));

  01094	e59d300c	 ldr         r3, [sp, #0xC]
  01098	e1a02c23	 mov         r2, r3, lsr #24
  0109c	e59d300c	 ldr         r3, [sp, #0xC]
  010a0	e1a03403	 mov         r3, r3, lsl #8
  010a4	e1a03c23	 mov         r3, r3, lsr #24
  010a8	e1823003	 orr         r3, r2, r3
  010ac	e20330ff	 and         r3, r3, #0xFF
  010b0	e5cd3004	 strb        r3, [sp, #4]

; 54   :                     bits |= (UCHAR)(((data >>  8)&0xFF) | ((data >>  0)&0xFF));

  010b4	e59d300c	 ldr         r3, [sp, #0xC]
  010b8	e1a03803	 mov         r3, r3, lsl #16
  010bc	e1a02c23	 mov         r2, r3, lsr #24
  010c0	e59d300c	 ldr         r3, [sp, #0xC]
  010c4	e20330ff	 and         r3, r3, #0xFF
  010c8	e1823003	 orr         r3, r2, r3
  010cc	e20330ff	 and         r3, r3, #0xFF
  010d0	e1a02003	 mov         r2, r3
  010d4	e5dd3004	 ldrb        r3, [sp, #4]
  010d8	e1833002	 orr         r3, r3, r2
  010dc	e20330ff	 and         r3, r3, #0xFF
  010e0	e5cd3004	 strb        r3, [sp, #4]

; 55   :                     break;

  010e4	ea00000c	 b           |$LN10@BitsOr|
  010e8		 |$LN8@BitsOr|

; 56   :                 case 2:
; 57   :                     bits  = (UCHAR)(((data >> 16)&0xFF) | ((data >> 0)&0xFF));

  010e8	e59d300c	 ldr         r3, [sp, #0xC]
  010ec	e1a03403	 mov         r3, r3, lsl #8
  010f0	e1a02c23	 mov         r2, r3, lsr #24
  010f4	e59d300c	 ldr         r3, [sp, #0xC]
  010f8	e20330ff	 and         r3, r3, #0xFF
  010fc	e1823003	 orr         r3, r2, r3
  01100	e20330ff	 and         r3, r3, #0xFF
  01104	e5cd3004	 strb        r3, [sp, #4]

; 58   :                     break;                    

  01108	ea000003	 b           |$LN10@BitsOr|
  0110c		 |$LN7@BitsOr|

; 59   :                 case 1:
; 60   :                     bits = (UCHAR)(data&0xFF);

  0110c	e59d300c	 ldr         r3, [sp, #0xC]
  01110	e20330ff	 and         r3, r3, #0xFF
  01114	e20330ff	 and         r3, r3, #0xFF
  01118	e5cd3004	 strb        r3, [sp, #4]
  0111c		 |$LN10@BitsOr|

; 61   :                     break;
; 62   :                 }
; 63   :             break;

  0111c	ea000027	 b           |$LN13@BitsOr|
  01120		 |$LN6@BitsOr|

; 64   :         case 2:
; 65   :             data = INREG16((UINT16*)(base + (offset << 1)));

  01120	e59d303c	 ldr         r3, [sp, #0x3C]
  01124	e1a02083	 mov         r2, r3, lsl #1
  01128	e59d3038	 ldr         r3, [sp, #0x38]
  0112c	e0830002	 add         r0, r3, r2
  01130	eb000000	 bl          READ_REGISTER_USHORT
  01134	e1a03800	 mov         r3, r0, lsl #16
  01138	e1a03823	 mov         r3, r3, lsr #16
  0113c	e1cd32b0	 strh        r3, [sp, #0x20]
  01140	e1dd32b0	 ldrh        r3, [sp, #0x20]
  01144	e58d300c	 str         r3, [sp, #0xC]

; 66   :             switch (parallel)

  01148	e59d3000	 ldr         r3, [sp]
  0114c	e58d3024	 str         r3, [sp, #0x24]
  01150	e59d3024	 ldr         r3, [sp, #0x24]
  01154	e3530001	 cmp         r3, #1
  01158	0a00000c	 beq         |$LN2@BitsOr|
  0115c	e59d3024	 ldr         r3, [sp, #0x24]
  01160	e3530002	 cmp         r3, #2
  01164	0a000000	 beq         |$LN3@BitsOr|
  01168	ea00000c	 b           |$LN4@BitsOr|
  0116c		 |$LN3@BitsOr|

; 67   :                 {
; 68   :                 case 2:
; 69   :                     bits = (UCHAR)(((data >> 8)&0xFF) | ((data >> 0)&0xFF));

  0116c	e59d300c	 ldr         r3, [sp, #0xC]
  01170	e1a03803	 mov         r3, r3, lsl #16
  01174	e1a02c23	 mov         r2, r3, lsr #24
  01178	e59d300c	 ldr         r3, [sp, #0xC]
  0117c	e20330ff	 and         r3, r3, #0xFF
  01180	e1823003	 orr         r3, r2, r3
  01184	e20330ff	 and         r3, r3, #0xFF
  01188	e5cd3004	 strb        r3, [sp, #4]

; 70   :                     break;                    

  0118c	ea000003	 b           |$LN4@BitsOr|
  01190		 |$LN2@BitsOr|

; 71   :                 case 1:
; 72   :                     bits = (UCHAR)(data&0xFF);

  01190	e59d300c	 ldr         r3, [sp, #0xC]
  01194	e20330ff	 and         r3, r3, #0xFF
  01198	e20330ff	 and         r3, r3, #0xFF
  0119c	e5cd3004	 strb        r3, [sp, #4]
  011a0		 |$LN4@BitsOr|

; 73   :                     break;
; 74   :                 }
; 75   :             break;

  011a0	ea000006	 b           |$LN13@BitsOr|
  011a4		 |$LN1@BitsOr|

; 76   :         case 1:
; 77   :             bits = INREG8((UINT8*)(base + offset));

  011a4	e59d2038	 ldr         r2, [sp, #0x38]
  011a8	e59d303c	 ldr         r3, [sp, #0x3C]
  011ac	e0820003	 add         r0, r2, r3
  011b0	eb000000	 bl          READ_REGISTER_UCHAR
  011b4	e5cd0028	 strb        r0, [sp, #0x28]
  011b8	e5dd3028	 ldrb        r3, [sp, #0x28]
  011bc	e5cd3004	 strb        r3, [sp, #4]
  011c0		 |$LN13@BitsOr|

; 78   :             break;
; 79   :         }            
; 80   : 
; 81   :     return bits;   

  011c0	e5dd3004	 ldrb        r3, [sp, #4]
  011c4	e5cd3010	 strb        r3, [sp, #0x10]

; 82   : }

  011c8	e5dd0010	 ldrb        r0, [sp, #0x10]
  011cc	e28dd02c	 add         sp, sp, #0x2C
  011d0	e89d6000	 ldmia       sp, {sp, lr}
  011d4	e12fff1e	 bx          lr
  011d8		 |$M43779|

			 ENDP  ; |BitsOr|


  00038			 AREA	 |.pdata|, PDATA
|$T43787| DCD	|$LN19@BitsAnd|
	DCD	0x40007904
; Function compile flags: /Odtp

  011d8			 AREA	 |.text|, CODE, ARM

  011d8		 |BitsAnd| PROC

; 92   : {

  011d8		 |$LN19@BitsAnd|
  011d8	e1a0c00d	 mov         r12, sp
  011dc	e92d0007	 stmdb       sp!, {r0 - r2}
  011e0	e92d5000	 stmdb       sp!, {r12, lr}
  011e4	e24dd02c	 sub         sp, sp, #0x2C
  011e8		 |$M43784|

; 93   :     UINT8 bits = 0;

  011e8	e3a03000	 mov         r3, #0
  011ec	e5cd3004	 strb        r3, [sp, #4]

; 94   :     UINT32 data;    
; 95   :     ULONG width = pInfo->width;

  011f0	e59d3034	 ldr         r3, [sp, #0x34]
  011f4	e5933000	 ldr         r3, [r3]
  011f8	e58d3008	 str         r3, [sp, #8]

; 96   :     ULONG parallel = pInfo->parallel;

  011fc	e59d3034	 ldr         r3, [sp, #0x34]
  01200	e2833004	 add         r3, r3, #4
  01204	e5933000	 ldr         r3, [r3]
  01208	e58d3000	 str         r3, [sp]

; 97   : 
; 98   :     switch (width)

  0120c	e59d3008	 ldr         r3, [sp, #8]
  01210	e58d3014	 str         r3, [sp, #0x14]
  01214	e59d3014	 ldr         r3, [sp, #0x14]
  01218	e3530001	 cmp         r3, #1
  0121c	0a00005b	 beq         |$LN1@BitsAnd|
  01220	e59d3014	 ldr         r3, [sp, #0x14]
  01224	e3530002	 cmp         r3, #2
  01228	0a00003a	 beq         |$LN6@BitsAnd|
  0122c	e59d3014	 ldr         r3, [sp, #0x14]
  01230	e3530004	 cmp         r3, #4
  01234	0a000000	 beq         |$LN12@BitsAnd|
  01238	ea000059	 b           |$LN13@BitsAnd|
  0123c		 |$LN12@BitsAnd|

; 99   :         {
; 100  :         case 4:
; 101  :             data = INREG32((UINT32*)(base + (offset << 2)));

  0123c	e59d303c	 ldr         r3, [sp, #0x3C]
  01240	e1a02103	 mov         r2, r3, lsl #2
  01244	e59d3038	 ldr         r3, [sp, #0x38]
  01248	e0830002	 add         r0, r3, r2
  0124c	eb000000	 bl          READ_REGISTER_ULONG
  01250	e58d0018	 str         r0, [sp, #0x18]
  01254	e59d3018	 ldr         r3, [sp, #0x18]
  01258	e58d300c	 str         r3, [sp, #0xC]

; 102  :             switch (parallel)

  0125c	e59d3000	 ldr         r3, [sp]
  01260	e58d301c	 str         r3, [sp, #0x1C]
  01264	e59d301c	 ldr         r3, [sp, #0x1C]
  01268	e3530001	 cmp         r3, #1
  0126c	0a000024	 beq         |$LN7@BitsAnd|
  01270	e59d301c	 ldr         r3, [sp, #0x1C]
  01274	e3530002	 cmp         r3, #2
  01278	0a000018	 beq         |$LN8@BitsAnd|
  0127c	e59d301c	 ldr         r3, [sp, #0x1C]
  01280	e3530004	 cmp         r3, #4
  01284	0a000000	 beq         |$LN9@BitsAnd|
  01288	ea000021	 b           |$LN10@BitsAnd|
  0128c		 |$LN9@BitsAnd|

; 103  :                 {
; 104  :                 case 4:
; 105  :                     bits  = (UCHAR)(((data >> 24)&0xFF) & ((data >> 16)&0xFF));

  0128c	e59d300c	 ldr         r3, [sp, #0xC]
  01290	e1a02c23	 mov         r2, r3, lsr #24
  01294	e59d300c	 ldr         r3, [sp, #0xC]
  01298	e1a03403	 mov         r3, r3, lsl #8
  0129c	e1a03c23	 mov         r3, r3, lsr #24
  012a0	e0023003	 and         r3, r2, r3
  012a4	e20330ff	 and         r3, r3, #0xFF
  012a8	e5cd3004	 strb        r3, [sp, #4]

; 106  :                     bits &= (UCHAR)(((data >>  8)&0xFF) & ((data >>  0)&0xFF));

  012ac	e59d300c	 ldr         r3, [sp, #0xC]
  012b0	e1a03803	 mov         r3, r3, lsl #16
  012b4	e1a02c23	 mov         r2, r3, lsr #24
  012b8	e59d300c	 ldr         r3, [sp, #0xC]
  012bc	e20330ff	 and         r3, r3, #0xFF
  012c0	e0023003	 and         r3, r2, r3
  012c4	e20330ff	 and         r3, r3, #0xFF
  012c8	e1a02003	 mov         r2, r3
  012cc	e5dd3004	 ldrb        r3, [sp, #4]
  012d0	e0033002	 and         r3, r3, r2
  012d4	e20330ff	 and         r3, r3, #0xFF
  012d8	e5cd3004	 strb        r3, [sp, #4]

; 107  :                     break;

  012dc	ea00000c	 b           |$LN10@BitsAnd|
  012e0		 |$LN8@BitsAnd|

; 108  :                 case 2:
; 109  :                     bits = (UCHAR)(((data >> 16)&0xFF) & ((data >> 0)&0xFF));

  012e0	e59d300c	 ldr         r3, [sp, #0xC]
  012e4	e1a03403	 mov         r3, r3, lsl #8
  012e8	e1a02c23	 mov         r2, r3, lsr #24
  012ec	e59d300c	 ldr         r3, [sp, #0xC]
  012f0	e20330ff	 and         r3, r3, #0xFF
  012f4	e0023003	 and         r3, r2, r3
  012f8	e20330ff	 and         r3, r3, #0xFF
  012fc	e5cd3004	 strb        r3, [sp, #4]

; 110  :                     break;                    

  01300	ea000003	 b           |$LN10@BitsAnd|
  01304		 |$LN7@BitsAnd|

; 111  :                 case 1:
; 112  :                     bits = (UCHAR)(data&0xFF);

  01304	e59d300c	 ldr         r3, [sp, #0xC]
  01308	e20330ff	 and         r3, r3, #0xFF
  0130c	e20330ff	 and         r3, r3, #0xFF
  01310	e5cd3004	 strb        r3, [sp, #4]
  01314		 |$LN10@BitsAnd|

; 113  :                     break;
; 114  :                 }
; 115  :             break;

  01314	ea000022	 b           |$LN13@BitsAnd|
  01318		 |$LN6@BitsAnd|

; 116  :         case 2:
; 117  :             data = INREG16((UINT16*)base);

  01318	e59d0038	 ldr         r0, [sp, #0x38]
  0131c	eb000000	 bl          READ_REGISTER_USHORT
  01320	e1a03800	 mov         r3, r0, lsl #16
  01324	e1a03823	 mov         r3, r3, lsr #16
  01328	e1cd32b0	 strh        r3, [sp, #0x20]
  0132c	e1dd32b0	 ldrh        r3, [sp, #0x20]
  01330	e58d300c	 str         r3, [sp, #0xC]

; 118  :             switch (parallel)

  01334	e59d3000	 ldr         r3, [sp]
  01338	e58d3024	 str         r3, [sp, #0x24]
  0133c	e59d3024	 ldr         r3, [sp, #0x24]
  01340	e3530001	 cmp         r3, #1
  01344	0a00000c	 beq         |$LN2@BitsAnd|
  01348	e59d3024	 ldr         r3, [sp, #0x24]
  0134c	e3530002	 cmp         r3, #2
  01350	0a000000	 beq         |$LN3@BitsAnd|
  01354	ea00000c	 b           |$LN4@BitsAnd|
  01358		 |$LN3@BitsAnd|

; 119  :                 {
; 120  :                 case 2:
; 121  :                     bits  = (UCHAR)(((data >> 8)&0xFF) & ((data >> 0) & 0xFF));

  01358	e59d300c	 ldr         r3, [sp, #0xC]
  0135c	e1a03803	 mov         r3, r3, lsl #16
  01360	e1a02c23	 mov         r2, r3, lsr #24
  01364	e59d300c	 ldr         r3, [sp, #0xC]
  01368	e20330ff	 and         r3, r3, #0xFF
  0136c	e0023003	 and         r3, r2, r3
  01370	e20330ff	 and         r3, r3, #0xFF
  01374	e5cd3004	 strb        r3, [sp, #4]

; 122  :                     break;                    

  01378	ea000003	 b           |$LN4@BitsAnd|
  0137c		 |$LN2@BitsAnd|

; 123  :                 case 1:
; 124  :                     bits = (UCHAR)(data&0xFF);

  0137c	e59d300c	 ldr         r3, [sp, #0xC]
  01380	e20330ff	 and         r3, r3, #0xFF
  01384	e20330ff	 and         r3, r3, #0xFF
  01388	e5cd3004	 strb        r3, [sp, #4]
  0138c		 |$LN4@BitsAnd|

; 125  :                     break;
; 126  :                 }
; 127  :             break;

  0138c	ea000004	 b           |$LN13@BitsAnd|
  01390		 |$LN1@BitsAnd|

; 128  :         case 1:
; 129  :             bits = INREG8((UINT8*)base);

  01390	e59d0038	 ldr         r0, [sp, #0x38]
  01394	eb000000	 bl          READ_REGISTER_UCHAR
  01398	e5cd0028	 strb        r0, [sp, #0x28]
  0139c	e5dd3028	 ldrb        r3, [sp, #0x28]
  013a0	e5cd3004	 strb        r3, [sp, #4]
  013a4		 |$LN13@BitsAnd|

; 130  :             break;
; 131  :         }            
; 132  : 
; 133  :     return bits;   

  013a4	e5dd3004	 ldrb        r3, [sp, #4]
  013a8	e5cd3010	 strb        r3, [sp, #0x10]

; 134  : }

  013ac	e5dd0010	 ldrb        r0, [sp, #0x10]
  013b0	e28dd02c	 add         sp, sp, #0x2C
  013b4	e89d6000	 ldmia       sp, {sp, lr}
  013b8	e12fff1e	 bx          lr
  013bc		 |$M43785|

			 ENDP  ; |BitsAnd|


  00040			 AREA	 |.pdata|, PDATA
|$T43793| DCD	|$LN5@LockBlock2|
	DCD	0x40000a04
; Function compile flags: /Odtp

  013bc			 AREA	 |.text|, CODE, ARM

  013bc		 |LockBlock2| PROC

; 458  : {

  013bc		 |$LN5@LockBlock2|
  013bc	e1a0c00d	 mov         r12, sp
  013c0	e92d000f	 stmdb       sp!, {r0 - r3}
  013c4	e92d5000	 stmdb       sp!, {r12, lr}
  013c8	e24dd004	 sub         sp, sp, #4
  013cc		 |$M43790|

; 459  :     return TRUE;

  013cc	e3a03001	 mov         r3, #1
  013d0	e58d3000	 str         r3, [sp]

; 460  : }

  013d4	e59d0000	 ldr         r0, [sp]
  013d8	e28dd004	 add         sp, sp, #4
  013dc	e89d6000	 ldmia       sp, {sp, lr}
  013e0	e12fff1e	 bx          lr
  013e4		 |$M43791|

			 ENDP  ; |LockBlock2|

	EXPORT	|??_C@_1DE@HNBCKGCA@?$AA?9?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAE?$AAr?$AAa?$AAs?$AAe?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EO@JKEJJFHN@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAF?$AAl?$AAa?$AAs?$AAh?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CF?$AAd?$AA?5?$AAi?$AAs?$AAn?$AA?8?$AAt?$AA?5?$AAs?$AAu?$AAp?$AAp?$AAo@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GI@CMIOIPEM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAE?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAg?$AAe?$AAt?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FC@JNEIGENB@?$AA?$CL?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAE?$AAr?$AAa?$AAs?$AAe?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?0?$AA?5?$AA0@| [ DATA ] ; `string'
	EXPORT	|OALFlashErase|

  00048			 AREA	 |.pdata|, PDATA
|$T43807| DCD	|$LN28@OALFlashEr|
	DCD	0x4000bd04

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DE@HNBCKGCA@?$AA?9?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAE?$AAr?$AAa?$AAs?$AAe?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "-"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "F", 0x0, "l", 0x0, "a"
	DCB	0x0, "s", 0x0, "h", 0x0, "E", 0x0, "r", 0x0, "a", 0x0, "s"
	DCB	0x0, "e", 0x0, "(", 0x0, "r", 0x0, "c", 0x0, " ", 0x0, "="
	DCB	0x0, " ", 0x0, "%", 0x0, "d", 0x0, ")", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EO@JKEJJFHN@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAF?$AAl?$AAa?$AAs?$AAh?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CF?$AAd?$AA?5?$AAi?$AAs?$AAn?$AA?8?$AAt?$AA?5?$AAs?$AAu?$AAp?$AAp?$AAo@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "F", 0x0, "l", 0x0, "a", 0x0, "s", 0x0, "h", 0x0, " "
	DCB	0x0, "t", 0x0, "y", 0x0, "p", 0x0, "e", 0x0, " ", 0x0, "%"
	DCB	0x0, "d", 0x0, " ", 0x0, "i", 0x0, "s", 0x0, "n", 0x0, "'"
	DCB	0x0, "t", 0x0, " ", 0x0, "s", 0x0, "u", 0x0, "p", 0x0, "p"
	DCB	0x0, "o", 0x0, "r", 0x0, "t", 0x0, "e", 0x0, "d", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GI@CMIOIPEM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAE?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAg?$AAe?$AAt?$AA?5@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "F", 0x0, "l", 0x0, "a"
	DCB	0x0, "s", 0x0, "h", 0x0, "E", 0x0, "r", 0x0, "a", 0x0, "s"
	DCB	0x0, "e", 0x0, " ", 0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l"
	DCB	0x0, "e", 0x0, "d", 0x0, " ", 0x0, "g", 0x0, "e", 0x0, "t"
	DCB	0x0, " ", 0x0, "f", 0x0, "l", 0x0, "a", 0x0, "s", 0x0, "h"
	DCB	0x0, " ", 0x0, "m", 0x0, "e", 0x0, "m", 0x0, "o", 0x0, "r"
	DCB	0x0, "y", 0x0, " ", 0x0, "i", 0x0, "n", 0x0, "f", 0x0, "o"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FC@JNEIGENB@?$AA?$CL?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAE?$AAr?$AAa?$AAs?$AAe?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?0?$AA?5?$AA0@| DCB "+"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "F", 0x0, "l", 0x0, "a"
	DCB	0x0, "s", 0x0, "h", 0x0, "E", 0x0, "r", 0x0, "a", 0x0, "s"
	DCB	0x0, "e", 0x0, "(", 0x0, "0", 0x0, "x", 0x0, "%", 0x0, "0"
	DCB	0x0, "8", 0x0, "x", 0x0, ",", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "x", 0x0, ",", 0x0, " "
	DCB	0x0, "0", 0x0, "x", 0x0, "%", 0x0, "0", 0x0, "8", 0x0, "x"
	DCB	0x0, ")", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Odtp

  013e4			 AREA	 |.text|, CODE, ARM

  013e4		 |OALFlashErase| PROC

; 875  : {

  013e4		 |$LN28@OALFlashEr|
  013e4	e1a0c00d	 mov         r12, sp
  013e8	e92d0007	 stmdb       sp!, {r0 - r2}
  013ec	e92d5000	 stmdb       sp!, {r12, lr}
  013f0	e24dd0a4	 sub         sp, sp, #0xA4
  013f4		 |$M43804|

; 876  :     BOOL rc = FALSE;

  013f4	e3a03000	 mov         r3, #0
  013f8	e58d3000	 str         r3, [sp]

; 877  :     OAL_FLASH_INFO info;
; 878  :     UINT32 base = (UINT32)pBase;

  013fc	e59d30ac	 ldr         r3, [sp, #0xAC]
  01400	e58d3004	 str         r3, [sp, #4]

; 879  :     UINT32 start = (UINT32)pStart;

  01404	e59d30b0	 ldr         r3, [sp, #0xB0]
  01408	e58d3010	 str         r3, [sp, #0x10]

; 880  :     UINT32 end = start + size;

  0140c	e59d2010	 ldr         r2, [sp, #0x10]
  01410	e59d30b4	 ldr         r3, [sp, #0xB4]
  01414	e0823003	 add         r3, r2, r3
  01418	e58d300c	 str         r3, [sp, #0xC]

; 881  :     UINT32 chip, blockStart, blockEnd;
; 882  :     UINT32 region, block;
; 883  : 
; 884  :     OALMSG(OAL_FUNC, (
; 885  :         L"+OALFlashErase(0x%08x, 0x%08x, 0x%08x)\r\n", pBase, pStart, size
; 886  :     ));

  0141c	e59f32a4	 ldr         r3, [pc, #0x2A4]
  01420	e5933440	 ldr         r3, [r3, #0x440]
  01424	e3130004	 tst         r3, #4
  01428	0a000007	 beq         |$LN18@OALFlashEr|
  0142c	e59d30b4	 ldr         r3, [sp, #0xB4]
  01430	e59d20b0	 ldr         r2, [sp, #0xB0]
  01434	e59d10ac	 ldr         r1, [sp, #0xAC]
  01438	e59f0294	 ldr         r0, [pc, #0x294]
  0143c	eb000000	 bl          NKDbgPrintfW
  01440	e3a03001	 mov         r3, #1
  01444	e58d3080	 str         r3, [sp, #0x80]
  01448	ea000001	 b           |$LN19@OALFlashEr|
  0144c		 |$LN18@OALFlashEr|
  0144c	e3a03000	 mov         r3, #0
  01450	e58d3080	 str         r3, [sp, #0x80]
  01454		 |$LN19@OALFlashEr|

; 887  : 
; 888  :     // Read first chip layout
; 889  :     if (!OALFlashInfo((VOID*)base, &info))

  01454	e28d101c	 add         r1, sp, #0x1C
  01458	e59d0004	 ldr         r0, [sp, #4]
  0145c	eb000000	 bl          OALFlashInfo
  01460	e58d0084	 str         r0, [sp, #0x84]
  01464	e59d3084	 ldr         r3, [sp, #0x84]
  01468	e3530000	 cmp         r3, #0
  0146c	1a00000b	 bne         |$LN15@OALFlashEr|

; 890  :     {
; 891  :         OALMSG(OAL_ERROR, (
; 892  :             L"ERROR: OALFlashErase failed get flash memory info\r\n"
; 893  :         ));

  01470	e59f3250	 ldr         r3, [pc, #0x250]
  01474	e5933440	 ldr         r3, [r3, #0x440]
  01478	e3130001	 tst         r3, #1
  0147c	0a000004	 beq         |$LN20@OALFlashEr|
  01480	e59f0248	 ldr         r0, [pc, #0x248]
  01484	eb000000	 bl          NKDbgPrintfW
  01488	e3a03001	 mov         r3, #1
  0148c	e58d3088	 str         r3, [sp, #0x88]
  01490	ea000001	 b           |$LN21@OALFlashEr|
  01494		 |$LN20@OALFlashEr|
  01494	e3a03000	 mov         r3, #0
  01498	e58d3088	 str         r3, [sp, #0x88]
  0149c		 |$LN21@OALFlashEr|

; 894  :             goto cleanUp;

  0149c	ea000076	 b           |$cleanUp$43484|
  014a0		 |$LN15@OALFlashEr|

; 895  :     }
; 896  : 
; 897  :     region = block = 0;

  014a0	e3a03000	 mov         r3, #0
  014a4	e58d3078	 str         r3, [sp, #0x78]
  014a8	e59d3078	 ldr         r3, [sp, #0x78]
  014ac	e58d3008	 str         r3, [sp, #8]

; 898  :     blockStart = chip = base;

  014b0	e59d3004	 ldr         r3, [sp, #4]
  014b4	e58d3018	 str         r3, [sp, #0x18]
  014b8	e59d3018	 ldr         r3, [sp, #0x18]
  014bc	e58d3074	 str         r3, [sp, #0x74]
  014c0		 |$LN14@OALFlashEr|

; 899  :     while (blockStart < end)

  014c0	e59d2074	 ldr         r2, [sp, #0x74]
  014c4	e59d300c	 ldr         r3, [sp, #0xC]
  014c8	e1520003	 cmp         r2, r3
  014cc	2a000068	 bcs         |$LN13@OALFlashEr|

; 900  :         {
; 901  : 
; 902  :         // Block end (+1)
; 903  :         blockEnd = blockStart + info.aBlockSize[region] * info.parallel;

  014d0	e59d1008	 ldr         r1, [sp, #8]
  014d4	e3a03004	 mov         r3, #4
  014d8	e0020391	 mul         r2, r1, r3
  014dc	e28d3034	 add         r3, sp, #0x34
  014e0	e0833002	 add         r3, r3, r2
  014e4	e5931000	 ldr         r1, [r3]
  014e8	e59d3020	 ldr         r3, [sp, #0x20]
  014ec	e0020391	 mul         r2, r1, r3
  014f0	e59d3074	 ldr         r3, [sp, #0x74]
  014f4	e0833002	 add         r3, r3, r2
  014f8	e58d3014	 str         r3, [sp, #0x14]

; 904  : 
; 905  :         // Should block be erased?
; 906  :         if (start < blockEnd && end >= blockStart)

  014fc	e59d2010	 ldr         r2, [sp, #0x10]
  01500	e59d3014	 ldr         r3, [sp, #0x14]
  01504	e1520003	 cmp         r2, r3
  01508	2a000030	 bcs         |$LN12@OALFlashEr|
  0150c	e59d200c	 ldr         r2, [sp, #0xC]
  01510	e59d3074	 ldr         r3, [sp, #0x74]
  01514	e1520003	 cmp         r2, r3
  01518	3a00002c	 bcc         |$LN12@OALFlashEr|

; 907  :             {
; 908  :             switch (info.set)

  0151c	e59d3024	 ldr         r3, [sp, #0x24]
  01520	e58d308c	 str         r3, [sp, #0x8C]
  01524	e59d308c	 ldr         r3, [sp, #0x8C]
  01528	e3530001	 cmp         r3, #1
  0152c	0a000006	 beq         |$LN9@OALFlashEr|
  01530	e59d308c	 ldr         r3, [sp, #0x8C]
  01534	e3530002	 cmp         r3, #2
  01538	0a00000d	 beq         |$LN7@OALFlashEr|
  0153c	e59d308c	 ldr         r3, [sp, #0x8C]
  01540	e3530003	 cmp         r3, #3
  01544	0a000000	 beq         |$LN9@OALFlashEr|
  01548	ea000013	 b           |$LN5@OALFlashEr|
  0154c		 |$LN9@OALFlashEr|

; 909  :                 {
; 910  : 
; 911  : #ifndef OAL_FLASH_NO_COMMAND_SET_1                
; 912  :                 case 1: // Intel/Sharp
; 913  :                 case 3:
; 914  :                     if (!EraseBlock1(&info, chip, blockStart))

  0154c	e59d2074	 ldr         r2, [sp, #0x74]
  01550	e59d1018	 ldr         r1, [sp, #0x18]
  01554	e28d001c	 add         r0, sp, #0x1C
  01558	eb000000	 bl          EraseBlock1
  0155c	e58d0090	 str         r0, [sp, #0x90]
  01560	e59d3090	 ldr         r3, [sp, #0x90]
  01564	e3530000	 cmp         r3, #0
  01568	1a000000	 bne         |$LN8@OALFlashEr|

; 915  :                         {
; 916  :                         goto cleanUp;

  0156c	ea000042	 b           |$cleanUp$43484|
  01570		 |$LN8@OALFlashEr|

; 917  :                         }
; 918  :                     break;

  01570	ea000016	 b           |$LN10@OALFlashEr|
  01574		 |$LN7@OALFlashEr|

; 919  : #endif OAL_FLASH_NO_COMMAND_SET_1                
; 920  : 
; 921  : #ifndef OAL_FLASH_NO_COMMAND_SET_2
; 922  :                 case 2: // AMD
; 923  :                     if (!EraseBlock2(&info, chip, blockStart))

  01574	e59d2074	 ldr         r2, [sp, #0x74]
  01578	e59d1018	 ldr         r1, [sp, #0x18]
  0157c	e28d001c	 add         r0, sp, #0x1C
  01580	eb000000	 bl          EraseBlock2
  01584	e58d0094	 str         r0, [sp, #0x94]
  01588	e59d3094	 ldr         r3, [sp, #0x94]
  0158c	e3530000	 cmp         r3, #0
  01590	1a000000	 bne         |$LN6@OALFlashEr|

; 924  :                         {
; 925  :                         goto cleanUp;

  01594	ea000038	 b           |$cleanUp$43484|
  01598		 |$LN6@OALFlashEr|

; 926  :                         }                    
; 927  :                     break;

  01598	ea00000c	 b           |$LN10@OALFlashEr|
  0159c		 |$LN5@OALFlashEr|

; 928  : #endif OAL_FLASH_NO_COMMAND_SET_2
; 929  : 
; 930  :                 default:
; 931  :                 OALMSG(OAL_ERROR, (
; 932  :                     L"ERROR: Flash type %d isn't supported\r\n", info.set
; 933  :                 ));

  0159c	e59f3124	 ldr         r3, [pc, #0x124]
  015a0	e5933440	 ldr         r3, [r3, #0x440]
  015a4	e3130001	 tst         r3, #1
  015a8	0a000005	 beq         |$LN22@OALFlashEr|
  015ac	e59d1024	 ldr         r1, [sp, #0x24]
  015b0	e59f0114	 ldr         r0, [pc, #0x114]
  015b4	eb000000	 bl          NKDbgPrintfW
  015b8	e3a03001	 mov         r3, #1
  015bc	e58d3098	 str         r3, [sp, #0x98]
  015c0	ea000001	 b           |$LN23@OALFlashEr|
  015c4		 |$LN22@OALFlashEr|
  015c4	e3a03000	 mov         r3, #0
  015c8	e58d3098	 str         r3, [sp, #0x98]
  015cc		 |$LN23@OALFlashEr|

; 934  :                     goto cleanUp;

  015cc	ea00002a	 b           |$cleanUp$43484|
  015d0		 |$LN10@OALFlashEr|
  015d0		 |$LN12@OALFlashEr|

; 935  :                 }
; 936  :             }         
; 937  : 
; 938  :         // Move to next block
; 939  :         blockStart = blockEnd;

  015d0	e59d3014	 ldr         r3, [sp, #0x14]
  015d4	e58d3074	 str         r3, [sp, #0x74]

; 940  :         if (blockStart >= end) break;

  015d8	e59d2074	 ldr         r2, [sp, #0x74]
  015dc	e59d300c	 ldr         r3, [sp, #0xC]
  015e0	e1520003	 cmp         r2, r3
  015e4	3a000000	 bcc         |$LN4@OALFlashEr|
  015e8	ea000021	 b           |$LN13@OALFlashEr|
  015ec		 |$LN4@OALFlashEr|

; 941  :         if (++block >= info.aBlocks[region])

  015ec	e59d3078	 ldr         r3, [sp, #0x78]
  015f0	e2833001	 add         r3, r3, #1
  015f4	e58d3078	 str         r3, [sp, #0x78]
  015f8	e59d1008	 ldr         r1, [sp, #8]
  015fc	e3a03004	 mov         r3, #4
  01600	e0020391	 mul         r2, r1, r3
  01604	e28d3054	 add         r3, sp, #0x54
  01608	e0833002	 add         r3, r3, r2
  0160c	e59d2078	 ldr         r2, [sp, #0x78]
  01610	e5933000	 ldr         r3, [r3]
  01614	e1520003	 cmp         r2, r3
  01618	3a000014	 bcc         |$LN3@OALFlashEr|

; 942  :             {
; 943  :             block = 0;

  0161c	e3a03000	 mov         r3, #0
  01620	e58d3078	 str         r3, [sp, #0x78]

; 944  :             if (++region >= info.regions)

  01624	e59d3008	 ldr         r3, [sp, #8]
  01628	e2833001	 add         r3, r3, #1
  0162c	e58d3008	 str         r3, [sp, #8]
  01630	e59d2008	 ldr         r2, [sp, #8]
  01634	e59d3030	 ldr         r3, [sp, #0x30]
  01638	e1520003	 cmp         r2, r3
  0163c	3a00000b	 bcc         |$LN2@OALFlashEr|

; 945  :                 {
; 946  :                 // Try read next chip info
; 947  :                 if (!OALFlashInfo((VOID*)blockStart, &info)) break;

  01640	e28d101c	 add         r1, sp, #0x1C
  01644	e59d0074	 ldr         r0, [sp, #0x74]
  01648	eb000000	 bl          OALFlashInfo
  0164c	e58d009c	 str         r0, [sp, #0x9C]
  01650	e59d309c	 ldr         r3, [sp, #0x9C]
  01654	e3530000	 cmp         r3, #0
  01658	1a000000	 bne         |$LN1@OALFlashEr|
  0165c	ea000004	 b           |$LN13@OALFlashEr|
  01660		 |$LN1@OALFlashEr|

; 948  :                 region = 0;

  01660	e3a03000	 mov         r3, #0
  01664	e58d3008	 str         r3, [sp, #8]

; 949  :                 chip = blockStart;

  01668	e59d3074	 ldr         r3, [sp, #0x74]
  0166c	e58d3018	 str         r3, [sp, #0x18]
  01670		 |$LN2@OALFlashEr|
  01670		 |$LN3@OALFlashEr|

; 950  :                 }
; 951  :             }
; 952  :         }

  01670	eaffff92	 b           |$LN14@OALFlashEr|
  01674		 |$LN13@OALFlashEr|

; 953  : 
; 954  :     rc = TRUE;

  01674	e3a03001	 mov         r3, #1
  01678	e58d3000	 str         r3, [sp]
  0167c		 |$cleanUp$43484|

; 955  :    
; 956  : cleanUp:
; 957  :     OALMSG(OAL_FUNC, (L"-OALFlashErase(rc = %d)\r\n", rc));

  0167c	e59f3044	 ldr         r3, [pc, #0x44]
  01680	e5933440	 ldr         r3, [r3, #0x440]
  01684	e3130004	 tst         r3, #4
  01688	0a000005	 beq         |$LN24@OALFlashEr|
  0168c	e59d1000	 ldr         r1, [sp]
  01690	e59f002c	 ldr         r0, [pc, #0x2C]
  01694	eb000000	 bl          NKDbgPrintfW
  01698	e3a03001	 mov         r3, #1
  0169c	e58d30a0	 str         r3, [sp, #0xA0]
  016a0	ea000001	 b           |$LN25@OALFlashEr|
  016a4		 |$LN24@OALFlashEr|
  016a4	e3a03000	 mov         r3, #0
  016a8	e58d30a0	 str         r3, [sp, #0xA0]
  016ac		 |$LN25@OALFlashEr|

; 958  :     return rc;

  016ac	e59d3000	 ldr         r3, [sp]
  016b0	e58d307c	 str         r3, [sp, #0x7C]

; 959  : }

  016b4	e59d007c	 ldr         r0, [sp, #0x7C]
  016b8	e28dd0a4	 add         sp, sp, #0xA4
  016bc	e89d6000	 ldmia       sp, {sp, lr}
  016c0	e12fff1e	 bx          lr
  016c4		 |$LN29@OALFlashEr|
  016c4		 |$LN30@OALFlashEr|
  016c4	00000000	 DCD         |??_C@_1DE@HNBCKGCA@?$AA?9?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAE?$AAr?$AAa?$AAs?$AAe?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  016c8		 |$LN31@OALFlashEr|
  016c8	00000000	 DCD         |dpCurSettings|
  016cc		 |$LN32@OALFlashEr|
  016cc	00000000	 DCD         |??_C@_1EO@JKEJJFHN@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAF?$AAl?$AAa?$AAs?$AAh?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CF?$AAd?$AA?5?$AAi?$AAs?$AAn?$AA?8?$AAt?$AA?5?$AAs?$AAu?$AAp?$AAp?$AAo@|
  016d0		 |$LN33@OALFlashEr|
  016d0	00000000	 DCD         |??_C@_1GI@CMIOIPEM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAE?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAg?$AAe?$AAt?$AA?5@|
  016d4		 |$LN34@OALFlashEr|
  016d4	00000000	 DCD         |??_C@_1FC@JNEIGENB@?$AA?$CL?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAE?$AAr?$AAa?$AAs?$AAe?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?0?$AA?5?$AA0@|
  016d8		 |$M43805|

			 ENDP  ; |OALFlashErase|


  00050			 AREA	 |.pdata|, PDATA
|$T43821| DCD	|$LN10@EraseBlock|
	DCD	0x40004804
; Function compile flags: /Odtp

  016d8			 AREA	 |.text|, CODE, ARM

  016d8		 |EraseBlock1| PROC

; 317  : {

  016d8		 |$LN10@EraseBlock|
  016d8	e1a0c00d	 mov         r12, sp
  016dc	e92d0007	 stmdb       sp!, {r0 - r2}
  016e0	e92d5000	 stmdb       sp!, {r12, lr}
  016e4	e24dd014	 sub         sp, sp, #0x14
  016e8		 |$M43818|

; 318  :     BOOL rc;
; 319  :     UCHAR bits;
; 320  : 
; 321  :     // Start block reset
; 322  :     WriteCommand(pInfo, base, 0, 0x50);

  016e8	e3a03050	 mov         r3, #0x50
  016ec	e3a02000	 mov         r2, #0
  016f0	e59d1020	 ldr         r1, [sp, #0x20]
  016f4	e59d001c	 ldr         r0, [sp, #0x1C]
  016f8	eb000000	 bl          WriteCommand

; 323  :     WriteCommand(pInfo, block, 0, 0x20);

  016fc	e3a03020	 mov         r3, #0x20
  01700	e3a02000	 mov         r2, #0
  01704	e59d1024	 ldr         r1, [sp, #0x24]
  01708	e59d001c	 ldr         r0, [sp, #0x1C]
  0170c	eb000000	 bl          WriteCommand

; 324  :     WriteCommand(pInfo, block, 0, 0xD0);

  01710	e3a030d0	 mov         r3, #0xD0
  01714	e3a02000	 mov         r2, #0
  01718	e59d1024	 ldr         r1, [sp, #0x24]
  0171c	e59d001c	 ldr         r0, [sp, #0x1C]
  01720	eb000000	 bl          WriteCommand
  01724		 |$LN3@EraseBlock|

; 325  : 
; 326  :     // Wait until it is done
; 327  :     do {
; 328  :         WriteCommand(pInfo, base, 0, 0x70);

  01724	e3a03070	 mov         r3, #0x70
  01728	e3a02000	 mov         r2, #0
  0172c	e59d1020	 ldr         r1, [sp, #0x20]
  01730	e59d001c	 ldr         r0, [sp, #0x1C]
  01734	eb000000	 bl          WriteCommand

; 329  :         bits = BitsAnd(pInfo, base, 0);

  01738	e3a02000	 mov         r2, #0
  0173c	e59d1020	 ldr         r1, [sp, #0x20]
  01740	e59d001c	 ldr         r0, [sp, #0x1C]
  01744	eb000000	 bl          BitsAnd
  01748	e5cd000c	 strb        r0, [sp, #0xC]
  0174c	e5dd300c	 ldrb        r3, [sp, #0xC]
  01750	e5cd3004	 strb        r3, [sp, #4]

; 330  :        }
; 331  :     while ((bits & (1 << 7)) == 0);

  01754	e5dd3004	 ldrb        r3, [sp, #4]
  01758	e3130080	 tst         r3, #0x80
  0175c	0afffff0	 beq         |$LN3@EraseBlock|

; 332  : 
; 333  :     // Reset memory back to normal state
; 334  :     WriteCommand(pInfo, base, 0, 0xFF);

  01760	e3a030ff	 mov         r3, #0xFF
  01764	e3a02000	 mov         r2, #0
  01768	e59d1020	 ldr         r1, [sp, #0x20]
  0176c	e59d001c	 ldr         r0, [sp, #0x1C]
  01770	eb000000	 bl          WriteCommand

; 335  : 
; 336  :     // Bit 5 is zero if erase succeeded
; 337  :     WriteCommand(pInfo, base, 0, 0x70);

  01774	e3a03070	 mov         r3, #0x70
  01778	e3a02000	 mov         r2, #0
  0177c	e59d1020	 ldr         r1, [sp, #0x20]
  01780	e59d001c	 ldr         r0, [sp, #0x1C]
  01784	eb000000	 bl          WriteCommand

; 338  :     bits = BitsOr(pInfo, base, 0);

  01788	e3a02000	 mov         r2, #0
  0178c	e59d1020	 ldr         r1, [sp, #0x20]
  01790	e59d001c	 ldr         r0, [sp, #0x1C]
  01794	eb000000	 bl          BitsOr
  01798	e5cd000d	 strb        r0, [sp, #0xD]
  0179c	e5dd300d	 ldrb        r3, [sp, #0xD]
  017a0	e5cd3004	 strb        r3, [sp, #4]

; 339  :     rc = (bits & (1 << 5)) == 0;

  017a4	e5dd3004	 ldrb        r3, [sp, #4]
  017a8	e3130020	 tst         r3, #0x20
  017ac	1a000002	 bne         |$LN6@EraseBlock|
  017b0	e3a03001	 mov         r3, #1
  017b4	e58d3010	 str         r3, [sp, #0x10]
  017b8	ea000001	 b           |$LN7@EraseBlock|
  017bc		 |$LN6@EraseBlock|
  017bc	e3a03000	 mov         r3, #0
  017c0	e58d3010	 str         r3, [sp, #0x10]
  017c4		 |$LN7@EraseBlock|
  017c4	e59d3010	 ldr         r3, [sp, #0x10]
  017c8	e58d3000	 str         r3, [sp]

; 340  :     
; 341  :     // Switch back to read mode
; 342  :     WriteCommand(pInfo, base, 0, 0xFF);

  017cc	e3a030ff	 mov         r3, #0xFF
  017d0	e3a02000	 mov         r2, #0
  017d4	e59d1020	 ldr         r1, [sp, #0x20]
  017d8	e59d001c	 ldr         r0, [sp, #0x1C]
  017dc	eb000000	 bl          WriteCommand

; 343  : 
; 344  :     return rc;

  017e0	e59d3000	 ldr         r3, [sp]
  017e4	e58d3008	 str         r3, [sp, #8]

; 345  : }

  017e8	e59d0008	 ldr         r0, [sp, #8]
  017ec	e28dd014	 add         sp, sp, #0x14
  017f0	e89d6000	 ldmia       sp, {sp, lr}
  017f4	e12fff1e	 bx          lr
  017f8		 |$M43819|

			 ENDP  ; |EraseBlock1|


  00058			 AREA	 |.pdata|, PDATA
|$T43829| DCD	|$LN11@EraseBlock@2|
	DCD	0x40005004
; Function compile flags: /Odtp

  017f8			 AREA	 |.text|, CODE, ARM

  017f8		 |EraseBlock2| PROC

; 482  : {

  017f8		 |$LN11@EraseBlock@2|
  017f8	e1a0c00d	 mov         r12, sp
  017fc	e92d0007	 stmdb       sp!, {r0 - r2}
  01800	e92d5000	 stmdb       sp!, {r12, lr}
  01804	e24dd018	 sub         sp, sp, #0x18
  01808		 |$M43826|

; 483  :     UINT32 code;
; 484  :     UINT8 bits;
; 485  :    
; 486  :     // Start block reset
; 487  :     WriteCommand(pInfo, base, 0x0555, 0xAA);

  01808	e3a030aa	 mov         r3, #0xAA
  0180c	e3a02c05	 mov         r2, #5, 24
  01810	e3822055	 orr         r2, r2, #0x55
  01814	e59d1024	 ldr         r1, [sp, #0x24]
  01818	e59d0020	 ldr         r0, [sp, #0x20]
  0181c	eb000000	 bl          WriteCommand

; 488  :     WriteCommand(pInfo, base, 0x02AA, 0x55);

  01820	e3a03055	 mov         r3, #0x55
  01824	e3a02c02	 mov         r2, #2, 24
  01828	e38220aa	 orr         r2, r2, #0xAA
  0182c	e59d1024	 ldr         r1, [sp, #0x24]
  01830	e59d0020	 ldr         r0, [sp, #0x20]
  01834	eb000000	 bl          WriteCommand

; 489  :     WriteCommand(pInfo, base, 0x0555, 0x80);

  01838	e3a03080	 mov         r3, #0x80
  0183c	e3a02c05	 mov         r2, #5, 24
  01840	e3822055	 orr         r2, r2, #0x55
  01844	e59d1024	 ldr         r1, [sp, #0x24]
  01848	e59d0020	 ldr         r0, [sp, #0x20]
  0184c	eb000000	 bl          WriteCommand

; 490  :     WriteCommand(pInfo, base, 0x0555, 0xAA);

  01850	e3a030aa	 mov         r3, #0xAA
  01854	e3a02c05	 mov         r2, #5, 24
  01858	e3822055	 orr         r2, r2, #0x55
  0185c	e59d1024	 ldr         r1, [sp, #0x24]
  01860	e59d0020	 ldr         r0, [sp, #0x20]
  01864	eb000000	 bl          WriteCommand

; 491  :     WriteCommand(pInfo, base, 0x02AA, 0x55);

  01868	e3a03055	 mov         r3, #0x55
  0186c	e3a02c02	 mov         r2, #2, 24
  01870	e38220aa	 orr         r2, r2, #0xAA
  01874	e59d1024	 ldr         r1, [sp, #0x24]
  01878	e59d0020	 ldr         r0, [sp, #0x20]
  0187c	eb000000	 bl          WriteCommand

; 492  :     WriteCommand(pInfo, block, 0, 0x30);

  01880	e3a03030	 mov         r3, #0x30
  01884	e3a02000	 mov         r2, #0
  01888	e59d1028	 ldr         r1, [sp, #0x28]
  0188c	e59d0020	 ldr         r0, [sp, #0x20]
  01890	eb000000	 bl          WriteCommand
  01894		 |$LN4@EraseBlock@2|

; 493  :    
; 494  :     // Wait until it is done
; 495  :     while (TRUE)
; 496  :         {
; 497  :         bits = BitsAnd(pInfo, block, 0);

  01894	e3a02000	 mov         r2, #0
  01898	e59d1028	 ldr         r1, [sp, #0x28]
  0189c	e59d0020	 ldr         r0, [sp, #0x20]
  018a0	eb000000	 bl          BitsAnd
  018a4	e5cd000c	 strb        r0, [sp, #0xC]
  018a8	e5dd300c	 ldrb        r3, [sp, #0xC]
  018ac	e5cd3004	 strb        r3, [sp, #4]

; 498  :         if ((bits & (1 << 5)) == 0) continue;

  018b0	e5dd3004	 ldrb        r3, [sp, #4]
  018b4	e3130020	 tst         r3, #0x20
  018b8	1a000000	 bne         |$LN2@EraseBlock@2|
  018bc	eafffff4	 b           |$LN4@EraseBlock@2|
  018c0		 |$LN2@EraseBlock@2|

; 499  :         code = INREG32((UINT32*)block);

  018c0	e59d0028	 ldr         r0, [sp, #0x28]
  018c4	eb000000	 bl          READ_REGISTER_ULONG
  018c8	e58d0010	 str         r0, [sp, #0x10]
  018cc	e59d3010	 ldr         r3, [sp, #0x10]
  018d0	e58d3000	 str         r3, [sp]

; 500  :         if (code == 0xFFFFFFFF) break;

  018d4	e59d3000	 ldr         r3, [sp]
  018d8	e3730001	 cmn         r3, #1
  018dc	1a000000	 bne         |$LN1@EraseBlock@2|
  018e0	ea000001	 b           |$LN3@EraseBlock@2|
  018e4		 |$LN1@EraseBlock@2|

; 501  :         break;

  018e4	ea000000	 b           |$LN3@EraseBlock@2|

; 502  :         }

  018e8	eaffffe9	 b           |$LN4@EraseBlock@2|
  018ec		 |$LN3@EraseBlock@2|

; 503  : 
; 504  :     // Switch back to read mode
; 505  :     WriteCommand(pInfo, base, 0, 0xF0);

  018ec	e3a030f0	 mov         r3, #0xF0
  018f0	e3a02000	 mov         r2, #0
  018f4	e59d1024	 ldr         r1, [sp, #0x24]
  018f8	e59d0020	 ldr         r0, [sp, #0x20]
  018fc	eb000000	 bl          WriteCommand

; 506  : 
; 507  :     return (code == 0xFFFFFFFF);

  01900	e59d3000	 ldr         r3, [sp]
  01904	e3730001	 cmn         r3, #1
  01908	1a000002	 bne         |$LN7@EraseBlock@2|
  0190c	e3a03001	 mov         r3, #1
  01910	e58d3014	 str         r3, [sp, #0x14]
  01914	ea000001	 b           |$LN8@EraseBlock@2|
  01918		 |$LN7@EraseBlock@2|
  01918	e3a03000	 mov         r3, #0
  0191c	e58d3014	 str         r3, [sp, #0x14]
  01920		 |$LN8@EraseBlock@2|
  01920	e59d3014	 ldr         r3, [sp, #0x14]
  01924	e58d3008	 str         r3, [sp, #8]

; 508  : }

  01928	e59d0008	 ldr         r0, [sp, #8]
  0192c	e28dd018	 add         sp, sp, #0x18
  01930	e89d6000	 ldmia       sp, {sp, lr}
  01934	e12fff1e	 bx          lr
  01938		 |$M43827|

			 ENDP  ; |EraseBlock2|

	EXPORT	|OALFlashEraseStart|
	IMPORT	|memcpy|

  00000			 AREA	 |.bss|, NOINIT
|s_erase| %	0x70

  00060			 AREA	 |.pdata|, PDATA
|$T43836| DCD	|$LN21@OALFlashEr@2|
	DCD	0x4000a504
; Function compile flags: /Odtp

  01938			 AREA	 |.text|, CODE, ARM

  01938		 |OALFlashEraseStart| PROC

; 969  : {

  01938		 |$LN21@OALFlashEr@2|
  01938	e1a0c00d	 mov         r12, sp
  0193c	e92d0007	 stmdb       sp!, {r0 - r2}
  01940	e92d5000	 stmdb       sp!, {r12, lr}
  01944	e24dd094	 sub         sp, sp, #0x94
  01948		 |$M43833|

; 970  :     BOOL rc = FALSE;

  01948	e3a03000	 mov         r3, #0
  0194c	e58d3000	 str         r3, [sp]

; 971  :     OAL_FLASH_INFO info;
; 972  :     UINT32 base = (UINT32)pBase;

  01950	e59d309c	 ldr         r3, [sp, #0x9C]
  01954	e58d3004	 str         r3, [sp, #4]

; 973  :     UINT32 start = (UINT32)pStart;

  01958	e59d30a0	 ldr         r3, [sp, #0xA0]
  0195c	e58d3010	 str         r3, [sp, #0x10]

; 974  :     UINT32 end = start + size;

  01960	e59d2010	 ldr         r2, [sp, #0x10]
  01964	e59d30a4	 ldr         r3, [sp, #0xA4]
  01968	e0823003	 add         r3, r2, r3
  0196c	e58d300c	 str         r3, [sp, #0xC]

; 975  :     UINT32 chip, blockStart, blockEnd;
; 976  :     UINT32 region, block;
; 977  : 
; 978  :     // There can be only one pending erase
; 979  :     if (s_erase.pending) goto cleanUp;

  01970	e59f3250	 ldr         r3, [pc, #0x250]
  01974	e5933000	 ldr         r3, [r3]
  01978	e3530000	 cmp         r3, #0
  0197c	0a000000	 beq         |$LN16@OALFlashEr@2|
  01980	ea00008a	 b           |$cleanUp$43527|
  01984		 |$LN16@OALFlashEr@2|

; 980  : 
; 981  :     // First detect flash at base
; 982  :     if (!OALFlashInfo((VOID*)base, &info))

  01984	e28d101c	 add         r1, sp, #0x1C
  01988	e59d0004	 ldr         r0, [sp, #4]
  0198c	eb000000	 bl          OALFlashInfo
  01990	e58d0080	 str         r0, [sp, #0x80]
  01994	e59d3080	 ldr         r3, [sp, #0x80]
  01998	e3530000	 cmp         r3, #0
  0199c	1a000000	 bne         |$LN15@OALFlashEr@2|

; 983  :         {
; 984  :         goto cleanUp;

  019a0	ea000082	 b           |$cleanUp$43527|
  019a4		 |$LN15@OALFlashEr@2|

; 985  :         }
; 986  : 
; 987  :     // Find first block to be erased
; 988  :     region = block = 0;

  019a4	e3a03000	 mov         r3, #0
  019a8	e58d3078	 str         r3, [sp, #0x78]
  019ac	e59d3078	 ldr         r3, [sp, #0x78]
  019b0	e58d3008	 str         r3, [sp, #8]

; 989  :     blockStart = chip = base;

  019b4	e59d3004	 ldr         r3, [sp, #4]
  019b8	e58d3018	 str         r3, [sp, #0x18]
  019bc	e59d3018	 ldr         r3, [sp, #0x18]
  019c0	e58d3074	 str         r3, [sp, #0x74]
  019c4		 |$LN14@OALFlashEr@2|

; 990  :     while (blockStart < end)

  019c4	e59d2074	 ldr         r2, [sp, #0x74]
  019c8	e59d300c	 ldr         r3, [sp, #0xC]
  019cc	e1520003	 cmp         r2, r3
  019d0	2a00003c	 bcs         |$LN13@OALFlashEr@2|

; 991  :         {
; 992  : 
; 993  :         // Block end (+1)
; 994  :         blockEnd  = blockStart + info.aBlockSize[region] * info.parallel;

  019d4	e59d1008	 ldr         r1, [sp, #8]
  019d8	e3a03004	 mov         r3, #4
  019dc	e0020391	 mul         r2, r1, r3
  019e0	e28d3034	 add         r3, sp, #0x34
  019e4	e0833002	 add         r3, r3, r2
  019e8	e5931000	 ldr         r1, [r3]
  019ec	e59d3020	 ldr         r3, [sp, #0x20]
  019f0	e0020391	 mul         r2, r1, r3
  019f4	e59d3074	 ldr         r3, [sp, #0x74]
  019f8	e0833002	 add         r3, r3, r2
  019fc	e58d3014	 str         r3, [sp, #0x14]

; 995  : 
; 996  :         // Should block be erased?
; 997  :         if (start < blockEnd && end >= blockStart) break;

  01a00	e59d2010	 ldr         r2, [sp, #0x10]
  01a04	e59d3014	 ldr         r3, [sp, #0x14]
  01a08	e1520003	 cmp         r2, r3
  01a0c	2a000004	 bcs         |$LN12@OALFlashEr@2|
  01a10	e59d200c	 ldr         r2, [sp, #0xC]
  01a14	e59d3074	 ldr         r3, [sp, #0x74]
  01a18	e1520003	 cmp         r2, r3
  01a1c	3a000000	 bcc         |$LN12@OALFlashEr@2|
  01a20	ea000028	 b           |$LN13@OALFlashEr@2|
  01a24		 |$LN12@OALFlashEr@2|

; 998  : 
; 999  :         // This should not happen...
; 1000 :         if (blockEnd >= end) goto cleanUp;

  01a24	e59d2014	 ldr         r2, [sp, #0x14]
  01a28	e59d300c	 ldr         r3, [sp, #0xC]
  01a2c	e1520003	 cmp         r2, r3
  01a30	3a000000	 bcc         |$LN11@OALFlashEr@2|
  01a34	ea00005d	 b           |$cleanUp$43527|
  01a38		 |$LN11@OALFlashEr@2|

; 1001 : 
; 1002 :         // Move to next block
; 1003 :         blockStart = blockEnd;

  01a38	e59d3014	 ldr         r3, [sp, #0x14]
  01a3c	e58d3074	 str         r3, [sp, #0x74]

; 1004 :         if (++block >= info.aBlocks[region])

  01a40	e59d3078	 ldr         r3, [sp, #0x78]
  01a44	e2833001	 add         r3, r3, #1
  01a48	e58d3078	 str         r3, [sp, #0x78]
  01a4c	e59d1008	 ldr         r1, [sp, #8]
  01a50	e3a03004	 mov         r3, #4
  01a54	e0020391	 mul         r2, r1, r3
  01a58	e28d3054	 add         r3, sp, #0x54
  01a5c	e0833002	 add         r3, r3, r2
  01a60	e59d2078	 ldr         r2, [sp, #0x78]
  01a64	e5933000	 ldr         r3, [r3]
  01a68	e1520003	 cmp         r2, r3
  01a6c	3a000014	 bcc         |$LN10@OALFlashEr@2|

; 1005 :             {
; 1006 :             block = 0;

  01a70	e3a03000	 mov         r3, #0
  01a74	e58d3078	 str         r3, [sp, #0x78]

; 1007 :             if (++region >= info.regions)

  01a78	e59d3008	 ldr         r3, [sp, #8]
  01a7c	e2833001	 add         r3, r3, #1
  01a80	e58d3008	 str         r3, [sp, #8]
  01a84	e59d2008	 ldr         r2, [sp, #8]
  01a88	e59d3030	 ldr         r3, [sp, #0x30]
  01a8c	e1520003	 cmp         r2, r3
  01a90	3a00000b	 bcc         |$LN9@OALFlashEr@2|

; 1008 :                 {
; 1009 :                 // Try read next chip info
; 1010 :                 if (!OALFlashInfo((VOID*)block, &info)) goto cleanUp;

  01a94	e28d101c	 add         r1, sp, #0x1C
  01a98	e59d0078	 ldr         r0, [sp, #0x78]
  01a9c	eb000000	 bl          OALFlashInfo
  01aa0	e58d0084	 str         r0, [sp, #0x84]
  01aa4	e59d3084	 ldr         r3, [sp, #0x84]
  01aa8	e3530000	 cmp         r3, #0
  01aac	1a000000	 bne         |$LN8@OALFlashEr@2|
  01ab0	ea00003e	 b           |$cleanUp$43527|
  01ab4		 |$LN8@OALFlashEr@2|

; 1011 :                 region = 0;

  01ab4	e3a03000	 mov         r3, #0
  01ab8	e58d3008	 str         r3, [sp, #8]

; 1012 :                 chip = block;

  01abc	e59d3078	 ldr         r3, [sp, #0x78]
  01ac0	e58d3018	 str         r3, [sp, #0x18]
  01ac4		 |$LN9@OALFlashEr@2|
  01ac4		 |$LN10@OALFlashEr@2|

; 1013 :                 }
; 1014 :             }
; 1015 :         }

  01ac4	eaffffbe	 b           |$LN14@OALFlashEr@2|
  01ac8		 |$LN13@OALFlashEr@2|

; 1016 : 
; 1017 :     // Start erase
; 1018 :     switch (info.set)

  01ac8	e59d3024	 ldr         r3, [sp, #0x24]
  01acc	e58d3088	 str         r3, [sp, #0x88]
  01ad0	e59d3088	 ldr         r3, [sp, #0x88]
  01ad4	e3530001	 cmp         r3, #1
  01ad8	0a000006	 beq         |$LN5@OALFlashEr@2|
  01adc	e59d3088	 ldr         r3, [sp, #0x88]
  01ae0	e3530002	 cmp         r3, #2
  01ae4	0a00000d	 beq         |$LN3@OALFlashEr@2|
  01ae8	e59d3088	 ldr         r3, [sp, #0x88]
  01aec	e3530003	 cmp         r3, #3
  01af0	0a000000	 beq         |$LN5@OALFlashEr@2|
  01af4	ea000013	 b           |$LN1@OALFlashEr@2|
  01af8		 |$LN5@OALFlashEr@2|

; 1019 :         {
; 1020 : 
; 1021 : #ifndef OAL_FLASH_NO_COMMAND_SET_1                
; 1022 :         case 1: // Intel/Sharp
; 1023 :         case 3:
; 1024 :             if (!StartEraseBlock1(&info, chip, blockStart))

  01af8	e59d2074	 ldr         r2, [sp, #0x74]
  01afc	e59d1018	 ldr         r1, [sp, #0x18]
  01b00	e28d001c	 add         r0, sp, #0x1C
  01b04	eb000000	 bl          StartEraseBlock1
  01b08	e58d008c	 str         r0, [sp, #0x8C]
  01b0c	e59d308c	 ldr         r3, [sp, #0x8C]
  01b10	e3530000	 cmp         r3, #0
  01b14	1a000000	 bne         |$LN4@OALFlashEr@2|

; 1025 :                 {
; 1026 :                 goto cleanUp;

  01b18	ea000024	 b           |$cleanUp$43527|
  01b1c		 |$LN4@OALFlashEr@2|

; 1027 :                 }
; 1028 :             break;

  01b1c	ea00000a	 b           |$LN6@OALFlashEr@2|
  01b20		 |$LN3@OALFlashEr@2|

; 1029 : #endif OAL_FLASH_NO_COMMAND_SET_1                
; 1030 : 
; 1031 : #ifndef OAL_FLASH_NO_COMMAND_SET_2
; 1032 :         case 2: // AMD
; 1033 :             if (!StartEraseBlock2(&info, chip, blockStart))

  01b20	e59d2074	 ldr         r2, [sp, #0x74]
  01b24	e59d1018	 ldr         r1, [sp, #0x18]
  01b28	e28d001c	 add         r0, sp, #0x1C
  01b2c	eb000000	 bl          StartEraseBlock2
  01b30	e58d0090	 str         r0, [sp, #0x90]
  01b34	e59d3090	 ldr         r3, [sp, #0x90]
  01b38	e3530000	 cmp         r3, #0
  01b3c	1a000000	 bne         |$LN2@OALFlashEr@2|

; 1034 :                 {
; 1035 :                 goto cleanUp;

  01b40	ea00001a	 b           |$cleanUp$43527|
  01b44		 |$LN2@OALFlashEr@2|

; 1036 :                 }                    
; 1037 :             break;

  01b44	ea000000	 b           |$LN6@OALFlashEr@2|
  01b48		 |$LN1@OALFlashEr@2|

; 1038 : #endif OAL_FLASH_NO_COMMAND_SET_2
; 1039 : 
; 1040 :         default:
; 1041 :             goto cleanUp;

  01b48	ea000018	 b           |$cleanUp$43527|
  01b4c		 |$LN6@OALFlashEr@2|

; 1042 :         }
; 1043 : 
; 1044 : 
; 1045 :     // Save context for continue...
; 1046 :     s_erase.info = info;

  01b4c	e59f3074	 ldr         r3, [pc, #0x74]
  01b50	e2830004	 add         r0, r3, #4
  01b54	e28d101c	 add         r1, sp, #0x1C
  01b58	e3a02058	 mov         r2, #0x58
  01b5c	eb000000	 bl          memcpy

; 1047 :     s_erase.base = chip;

  01b60	e59d2018	 ldr         r2, [sp, #0x18]
  01b64	e59f305c	 ldr         r3, [pc, #0x5C]
  01b68	e583205c	 str         r2, [r3, #0x5C]

; 1048 :     s_erase.end = end;

  01b6c	e59d200c	 ldr         r2, [sp, #0xC]
  01b70	e59f3050	 ldr         r3, [pc, #0x50]
  01b74	e5832060	 str         r2, [r3, #0x60]

; 1049 :     s_erase.pos = blockStart;

  01b78	e59d2074	 ldr         r2, [sp, #0x74]
  01b7c	e59f3044	 ldr         r3, [pc, #0x44]
  01b80	e5832064	 str         r2, [r3, #0x64]

; 1050 :     s_erase.region = region;

  01b84	e59d2008	 ldr         r2, [sp, #8]
  01b88	e59f3038	 ldr         r3, [pc, #0x38]
  01b8c	e5832068	 str         r2, [r3, #0x68]

; 1051 :     s_erase.block = block;

  01b90	e59d2078	 ldr         r2, [sp, #0x78]
  01b94	e59f302c	 ldr         r3, [pc, #0x2C]
  01b98	e583206c	 str         r2, [r3, #0x6C]

; 1052 :     s_erase.pending = TRUE;

  01b9c	e59f2024	 ldr         r2, [pc, #0x24]
  01ba0	e3a03001	 mov         r3, #1
  01ba4	e5823000	 str         r3, [r2]

; 1053 :     
; 1054 :     rc = TRUE;

  01ba8	e3a03001	 mov         r3, #1
  01bac	e58d3000	 str         r3, [sp]
  01bb0		 |$cleanUp$43527|

; 1055 : 
; 1056 : cleanUp:
; 1057 :     return rc;

  01bb0	e59d3000	 ldr         r3, [sp]
  01bb4	e58d307c	 str         r3, [sp, #0x7C]

; 1058 : }

  01bb8	e59d007c	 ldr         r0, [sp, #0x7C]
  01bbc	e28dd094	 add         sp, sp, #0x94
  01bc0	e89d6000	 ldmia       sp, {sp, lr}
  01bc4	e12fff1e	 bx          lr
  01bc8		 |$LN22@OALFlashEr@2|
  01bc8		 |$LN23@OALFlashEr@2|
  01bc8	00000000	 DCD         |s_erase|
  01bcc		 |$M43834|

			 ENDP  ; |OALFlashEraseStart|


  00068			 AREA	 |.pdata|, PDATA
|$T43844| DCD	|$LN5@StartErase|
	DCD	0x40001904
; Function compile flags: /Odtp

  01bcc			 AREA	 |.text|, CODE, ARM

  01bcc		 |StartEraseBlock1| PROC

; 355  : {

  01bcc		 |$LN5@StartErase|
  01bcc	e1a0c00d	 mov         r12, sp
  01bd0	e92d0007	 stmdb       sp!, {r0 - r2}
  01bd4	e92d5000	 stmdb       sp!, {r12, lr}
  01bd8	e24dd004	 sub         sp, sp, #4
  01bdc		 |$M43841|

; 356  :     // Erase status register
; 357  :     WriteCommand(pInfo, block, 0, 0x50);

  01bdc	e3a03050	 mov         r3, #0x50
  01be0	e3a02000	 mov         r2, #0
  01be4	e59d1014	 ldr         r1, [sp, #0x14]
  01be8	e59d000c	 ldr         r0, [sp, #0xC]
  01bec	eb000000	 bl          WriteCommand

; 358  : 
; 359  :     // Start block reset
; 360  :     WriteCommand(pInfo, block, 0, 0x20);

  01bf0	e3a03020	 mov         r3, #0x20
  01bf4	e3a02000	 mov         r2, #0
  01bf8	e59d1014	 ldr         r1, [sp, #0x14]
  01bfc	e59d000c	 ldr         r0, [sp, #0xC]
  01c00	eb000000	 bl          WriteCommand

; 361  :     WriteCommand(pInfo, block, 0, 0xD0);

  01c04	e3a030d0	 mov         r3, #0xD0
  01c08	e3a02000	 mov         r2, #0
  01c0c	e59d1014	 ldr         r1, [sp, #0x14]
  01c10	e59d000c	 ldr         r0, [sp, #0xC]
  01c14	eb000000	 bl          WriteCommand

; 362  : 
; 363  :     return TRUE;

  01c18	e3a03001	 mov         r3, #1
  01c1c	e58d3000	 str         r3, [sp]

; 364  : }

  01c20	e59d0000	 ldr         r0, [sp]
  01c24	e28dd004	 add         sp, sp, #4
  01c28	e89d6000	 ldmia       sp, {sp, lr}
  01c2c	e12fff1e	 bx          lr
  01c30		 |$M43842|

			 ENDP  ; |StartEraseBlock1|


  00070			 AREA	 |.pdata|, PDATA
|$T43850| DCD	|$LN5@StartErase@2|
	DCD	0x40000a04
; Function compile flags: /Odtp

  01c30			 AREA	 |.text|, CODE, ARM

  01c30		 |StartEraseBlock2| PROC

; 518  : {

  01c30		 |$LN5@StartErase@2|
  01c30	e1a0c00d	 mov         r12, sp
  01c34	e92d0007	 stmdb       sp!, {r0 - r2}
  01c38	e92d5000	 stmdb       sp!, {r12, lr}
  01c3c	e24dd004	 sub         sp, sp, #4
  01c40		 |$M43847|

; 519  :     return FALSE;

  01c40	e3a03000	 mov         r3, #0
  01c44	e58d3000	 str         r3, [sp]

; 520  : }

  01c48	e59d0000	 ldr         r0, [sp]
  01c4c	e28dd004	 add         sp, sp, #4
  01c50	e89d6000	 ldmia       sp, {sp, lr}
  01c54	e12fff1e	 bx          lr
  01c58		 |$M43848|

			 ENDP  ; |StartEraseBlock2|

	EXPORT	|OALFlashEraseContinue|

  00078			 AREA	 |.pdata|, PDATA
|$T43856| DCD	|$LN17@OALFlashEr@3|
	DCD	0x40008902
; Function compile flags: /Odtp

  01c58			 AREA	 |.text|, CODE, ARM

  01c58		 |OALFlashEraseContinue| PROC

; 1065 : {

  01c58		 |$LN17@OALFlashEr@3|
  01c58	e52de004	 str         lr, [sp, #-4]!
  01c5c	e24dd01c	 sub         sp, sp, #0x1C
  01c60		 |$M43853|

; 1066 :     UINT32 rc = OAL_FLASH_ERASE_FAILED;

  01c60	e3e03000	 mvn         r3, #0
  01c64	e58d3000	 str         r3, [sp]

; 1067 :     OAL_FLASH_INFO *pInfo = &s_erase.info;

  01c68	e59f3208	 ldr         r3, [pc, #0x208]
  01c6c	e2833004	 add         r3, r3, #4
  01c70	e58d3004	 str         r3, [sp, #4]

; 1068 :     
; 1069 :     // There must be pending erase
; 1070 :     if (!s_erase.pending) goto cleanUp;

  01c74	e59f31fc	 ldr         r3, [pc, #0x1FC]
  01c78	e5933000	 ldr         r3, [r3]
  01c7c	e3530000	 cmp         r3, #0
  01c80	1a000000	 bne         |$LN12@OALFlashEr@3|
  01c84	ea00006f	 b           |$cleanUp$43552|
  01c88		 |$LN12@OALFlashEr@3|

; 1071 : 
; 1072 :     // Look if erase is done
; 1073 :     switch (s_erase.info.set)

  01c88	e59f31e8	 ldr         r3, [pc, #0x1E8]
  01c8c	e593300c	 ldr         r3, [r3, #0xC]
  01c90	e58d300c	 str         r3, [sp, #0xC]
  01c94	e59d300c	 ldr         r3, [sp, #0xC]
  01c98	e3530001	 cmp         r3, #1
  01c9c	0a000006	 beq         |$LN9@OALFlashEr@3|
  01ca0	e59d300c	 ldr         r3, [sp, #0xC]
  01ca4	e3530002	 cmp         r3, #2
  01ca8	0a00000e	 beq         |$LN8@OALFlashEr@3|
  01cac	e59d300c	 ldr         r3, [sp, #0xC]
  01cb0	e3530003	 cmp         r3, #3
  01cb4	0a000000	 beq         |$LN9@OALFlashEr@3|
  01cb8	ea000015	 b           |$LN7@OALFlashEr@3|
  01cbc		 |$LN9@OALFlashEr@3|

; 1074 :         {
; 1075 : 
; 1076 : #ifndef OAL_FLASH_NO_COMMAND_SET_1                
; 1077 :         case 1: // Intel/Sharp
; 1078 :         case 3:
; 1079 :             rc = ContinueEraseBlock1(&s_erase.info, s_erase.base, s_erase.pos);

  01cbc	e59f31b4	 ldr         r3, [pc, #0x1B4]
  01cc0	e5932064	 ldr         r2, [r3, #0x64]
  01cc4	e59f31ac	 ldr         r3, [pc, #0x1AC]
  01cc8	e593105c	 ldr         r1, [r3, #0x5C]
  01ccc	e59f31a4	 ldr         r3, [pc, #0x1A4]
  01cd0	e2830004	 add         r0, r3, #4
  01cd4	eb000000	 bl          ContinueEraseBlock1
  01cd8	e58d0010	 str         r0, [sp, #0x10]
  01cdc	e59d3010	 ldr         r3, [sp, #0x10]
  01ce0	e58d3000	 str         r3, [sp]

; 1080 :             break;

  01ce4	ea00000b	 b           |$LN10@OALFlashEr@3|
  01ce8		 |$LN8@OALFlashEr@3|

; 1081 : #endif OAL_FLASH_NO_COMMAND_SET_1                
; 1082 : 
; 1083 : #ifndef OAL_FLASH_NO_COMMAND_SET_2
; 1084 :         case 2: // AMD
; 1085 :             rc = ContinueEraseBlock2(&s_erase.info, s_erase.base, s_erase.pos);

  01ce8	e59f3188	 ldr         r3, [pc, #0x188]
  01cec	e5932064	 ldr         r2, [r3, #0x64]
  01cf0	e59f3180	 ldr         r3, [pc, #0x180]
  01cf4	e593105c	 ldr         r1, [r3, #0x5C]
  01cf8	e59f3178	 ldr         r3, [pc, #0x178]
  01cfc	e2830004	 add         r0, r3, #4
  01d00	eb000000	 bl          ContinueEraseBlock2
  01d04	e58d0014	 str         r0, [sp, #0x14]
  01d08	e59d3014	 ldr         r3, [sp, #0x14]
  01d0c	e58d3000	 str         r3, [sp]

; 1086 :             break;

  01d10	ea000000	 b           |$LN10@OALFlashEr@3|
  01d14		 |$LN7@OALFlashEr@3|

; 1087 : #endif OAL_FLASH_NO_COMMAND_SET_2
; 1088 : 
; 1089 :         default:
; 1090 :             goto cleanUp;

  01d14	ea00004b	 b           |$cleanUp$43552|
  01d18		 |$LN10@OALFlashEr@3|

; 1091 :         }
; 1092 : 
; 1093 :     // If erase is pending or failed we are done
; 1094 :     if (rc != OAL_FLASH_ERASE_DONE) goto cleanUp;

  01d18	e59d3000	 ldr         r3, [sp]
  01d1c	e3530001	 cmp         r3, #1
  01d20	0a000000	 beq         |$LN6@OALFlashEr@3|
  01d24	ea000047	 b           |$cleanUp$43552|
  01d28		 |$LN6@OALFlashEr@3|

; 1095 : 
; 1096 :     // Move to next block
; 1097 :     s_erase.pos += pInfo->aBlockSize[s_erase.region] * pInfo->parallel;

  01d28	e59d3004	 ldr         r3, [sp, #4]
  01d2c	e2831018	 add         r1, r3, #0x18
  01d30	e59f3140	 ldr         r3, [pc, #0x140]
  01d34	e5932068	 ldr         r2, [r3, #0x68]
  01d38	e3a03004	 mov         r3, #4
  01d3c	e0030392	 mul         r3, r2, r3
  01d40	e0812003	 add         r2, r1, r3
  01d44	e59d3004	 ldr         r3, [sp, #4]
  01d48	e2833004	 add         r3, r3, #4
  01d4c	e5921000	 ldr         r1, [r2]
  01d50	e5933000	 ldr         r3, [r3]
  01d54	e0020391	 mul         r2, r1, r3
  01d58	e59f3118	 ldr         r3, [pc, #0x118]
  01d5c	e5933064	 ldr         r3, [r3, #0x64]
  01d60	e0832002	 add         r2, r3, r2
  01d64	e59f310c	 ldr         r3, [pc, #0x10C]
  01d68	e5832064	 str         r2, [r3, #0x64]

; 1098 :     // Are we done?
; 1099 :     if (s_erase.pos >= s_erase.end) goto cleanUp;

  01d6c	e59f3104	 ldr         r3, [pc, #0x104]
  01d70	e5932064	 ldr         r2, [r3, #0x64]
  01d74	e59f30fc	 ldr         r3, [pc, #0xFC]
  01d78	e5933060	 ldr         r3, [r3, #0x60]
  01d7c	e1520003	 cmp         r2, r3
  01d80	3a000000	 bcc         |$LN5@OALFlashEr@3|
  01d84	ea00002f	 b           |$cleanUp$43552|
  01d88		 |$LN5@OALFlashEr@3|

; 1100 : 
; 1101 :     // Is is next chip?
; 1102 :     if (++s_erase.block >= pInfo->aBlocks[s_erase.region])

  01d88	e59f30e8	 ldr         r3, [pc, #0xE8]
  01d8c	e593306c	 ldr         r3, [r3, #0x6C]
  01d90	e2832001	 add         r2, r3, #1
  01d94	e59f30dc	 ldr         r3, [pc, #0xDC]
  01d98	e583206c	 str         r2, [r3, #0x6C]
  01d9c	e59d3004	 ldr         r3, [sp, #4]
  01da0	e2831038	 add         r1, r3, #0x38
  01da4	e59f30cc	 ldr         r3, [pc, #0xCC]
  01da8	e5932068	 ldr         r2, [r3, #0x68]
  01dac	e3a03004	 mov         r3, #4
  01db0	e0030392	 mul         r3, r2, r3
  01db4	e0811003	 add         r1, r1, r3
  01db8	e59f30b8	 ldr         r3, [pc, #0xB8]
  01dbc	e593206c	 ldr         r2, [r3, #0x6C]
  01dc0	e5913000	 ldr         r3, [r1]
  01dc4	e1520003	 cmp         r2, r3
  01dc8	3a00001e	 bcc         |$LN4@OALFlashEr@3|

; 1103 :         {
; 1104 :         s_erase.block = 0;

  01dcc	e59f20a4	 ldr         r2, [pc, #0xA4]
  01dd0	e3a03000	 mov         r3, #0
  01dd4	e582306c	 str         r3, [r2, #0x6C]

; 1105 :         if (++s_erase.region >= pInfo->regions)

  01dd8	e59f3098	 ldr         r3, [pc, #0x98]
  01ddc	e5933068	 ldr         r3, [r3, #0x68]
  01de0	e2832001	 add         r2, r3, #1
  01de4	e59f308c	 ldr         r3, [pc, #0x8C]
  01de8	e5832068	 str         r2, [r3, #0x68]
  01dec	e59d3004	 ldr         r3, [sp, #4]
  01df0	e2831014	 add         r1, r3, #0x14
  01df4	e59f307c	 ldr         r3, [pc, #0x7C]
  01df8	e5932068	 ldr         r2, [r3, #0x68]
  01dfc	e5913000	 ldr         r3, [r1]
  01e00	e1520003	 cmp         r2, r3
  01e04	3a00000f	 bcc         |$LN3@OALFlashEr@3|

; 1106 :             {
; 1107 :             s_erase.base = s_erase.pos;

  01e08	e59f3068	 ldr         r3, [pc, #0x68]
  01e0c	e5932064	 ldr         r2, [r3, #0x64]
  01e10	e59f3060	 ldr         r3, [pc, #0x60]
  01e14	e583205c	 str         r2, [r3, #0x5C]

; 1108 :             // Try read next chip info
; 1109 :             if (!OALFlashInfo((VOID*)s_erase.base, pInfo)) goto cleanUp;

  01e18	e59d1004	 ldr         r1, [sp, #4]
  01e1c	e59f3054	 ldr         r3, [pc, #0x54]
  01e20	e593005c	 ldr         r0, [r3, #0x5C]
  01e24	eb000000	 bl          OALFlashInfo
  01e28	e58d0018	 str         r0, [sp, #0x18]
  01e2c	e59d3018	 ldr         r3, [sp, #0x18]
  01e30	e3530000	 cmp         r3, #0
  01e34	1a000000	 bne         |$LN2@OALFlashEr@3|
  01e38	ea000002	 b           |$cleanUp$43552|
  01e3c		 |$LN2@OALFlashEr@3|

; 1110 :             s_erase.region = 0;

  01e3c	e59f2034	 ldr         r2, [pc, #0x34]
  01e40	e3a03000	 mov         r3, #0
  01e44	e5823068	 str         r3, [r2, #0x68]
  01e48		 |$LN3@OALFlashEr@3|
  01e48		 |$LN4@OALFlashEr@3|
  01e48		 |$cleanUp$43552|

; 1111 :             }
; 1112 :         }
; 1113 :     
; 1114 : cleanUp:
; 1115 :     if (rc != OAL_FLASH_ERASE_PENDING) s_erase.pending = FALSE;    

  01e48	e59d3000	 ldr         r3, [sp]
  01e4c	e3530000	 cmp         r3, #0
  01e50	0a000002	 beq         |$LN1@OALFlashEr@3|
  01e54	e59f201c	 ldr         r2, [pc, #0x1C]
  01e58	e3a03000	 mov         r3, #0
  01e5c	e5823000	 str         r3, [r2]
  01e60		 |$LN1@OALFlashEr@3|

; 1116 :     return rc;

  01e60	e59d3000	 ldr         r3, [sp]
  01e64	e58d3008	 str         r3, [sp, #8]

; 1117 : }

  01e68	e59d0008	 ldr         r0, [sp, #8]
  01e6c	e28dd01c	 add         sp, sp, #0x1C
  01e70	e49de004	 ldr         lr, [sp], #4
  01e74	e12fff1e	 bx          lr
  01e78		 |$LN18@OALFlashEr@3|
  01e78		 |$LN19@OALFlashEr@3|
  01e78	00000000	 DCD         |s_erase|
  01e7c		 |$M43854|

			 ENDP  ; |OALFlashEraseContinue|


  00080			 AREA	 |.pdata|, PDATA
|$T43866| DCD	|$LN8@ContinueEr|
	DCD	0x40002b04
; Function compile flags: /Odtp

  01e7c			 AREA	 |.text|, CODE, ARM

  01e7c		 |ContinueEraseBlock1| PROC

; 374  : {

  01e7c		 |$LN8@ContinueEr|
  01e7c	e1a0c00d	 mov         r12, sp
  01e80	e92d0007	 stmdb       sp!, {r0 - r2}
  01e84	e92d5000	 stmdb       sp!, {r12, lr}
  01e88	e24dd014	 sub         sp, sp, #0x14
  01e8c		 |$M43863|

; 375  :     UINT32 rc = OAL_FLASH_ERASE_PENDING;

  01e8c	e3a03000	 mov         r3, #0
  01e90	e58d3000	 str         r3, [sp]

; 376  :     UINT8 bits;
; 377  : 
; 378  :     // Check if erase is done
; 379  :     WriteCommand(pInfo, block, 0, 0x70);

  01e94	e3a03070	 mov         r3, #0x70
  01e98	e3a02000	 mov         r2, #0
  01e9c	e59d1024	 ldr         r1, [sp, #0x24]
  01ea0	e59d001c	 ldr         r0, [sp, #0x1C]
  01ea4	eb000000	 bl          WriteCommand

; 380  :     bits = BitsAnd(pInfo, block, 0);

  01ea8	e3a02000	 mov         r2, #0
  01eac	e59d1024	 ldr         r1, [sp, #0x24]
  01eb0	e59d001c	 ldr         r0, [sp, #0x1C]
  01eb4	eb000000	 bl          BitsAnd
  01eb8	e5cd000c	 strb        r0, [sp, #0xC]
  01ebc	e5dd300c	 ldrb        r3, [sp, #0xC]
  01ec0	e5cd3004	 strb        r3, [sp, #4]

; 381  :     if ((bits & (1 << 7)) == 0) goto cleanUp;

  01ec4	e5dd3004	 ldrb        r3, [sp, #4]
  01ec8	e3130080	 tst         r3, #0x80
  01ecc	1a000000	 bne         |$LN1@ContinueEr|
  01ed0	ea000009	 b           |$cleanUp$43203|
  01ed4		 |$LN1@ContinueEr|

; 382  :         
; 383  :     // Bit 5 is zero if erase succeeded
; 384  :     rc = (bits & (1 << 5)) == 0 ? OAL_FLASH_ERASE_DONE : OAL_FLASH_ERASE_FAILED;

  01ed4	e5dd3004	 ldrb        r3, [sp, #4]
  01ed8	e3130020	 tst         r3, #0x20
  01edc	1a000002	 bne         |$LN4@ContinueEr|
  01ee0	e3a03001	 mov         r3, #1
  01ee4	e58d3010	 str         r3, [sp, #0x10]
  01ee8	ea000001	 b           |$LN5@ContinueEr|
  01eec		 |$LN4@ContinueEr|
  01eec	e3e03000	 mvn         r3, #0
  01ef0	e58d3010	 str         r3, [sp, #0x10]
  01ef4		 |$LN5@ContinueEr|
  01ef4	e59d3010	 ldr         r3, [sp, #0x10]
  01ef8	e58d3000	 str         r3, [sp]
  01efc		 |$cleanUp$43203|

; 385  :     
; 386  : cleanUp:
; 387  :     // Switch back to read mode
; 388  :     WriteCommand(pInfo, block, 0, 0xFF);

  01efc	e3a030ff	 mov         r3, #0xFF
  01f00	e3a02000	 mov         r2, #0
  01f04	e59d1024	 ldr         r1, [sp, #0x24]
  01f08	e59d001c	 ldr         r0, [sp, #0x1C]
  01f0c	eb000000	 bl          WriteCommand

; 389  :     return rc;

  01f10	e59d3000	 ldr         r3, [sp]
  01f14	e58d3008	 str         r3, [sp, #8]

; 390  : }

  01f18	e59d0008	 ldr         r0, [sp, #8]
  01f1c	e28dd014	 add         sp, sp, #0x14
  01f20	e89d6000	 ldmia       sp, {sp, lr}
  01f24	e12fff1e	 bx          lr
  01f28		 |$M43864|

			 ENDP  ; |ContinueEraseBlock1|


  00088			 AREA	 |.pdata|, PDATA
|$T43872| DCD	|$LN5@ContinueEr@2|
	DCD	0x40000a04
; Function compile flags: /Odtp

  01f28			 AREA	 |.text|, CODE, ARM

  01f28		 |ContinueEraseBlock2| PROC

; 530  : {

  01f28		 |$LN5@ContinueEr@2|
  01f28	e1a0c00d	 mov         r12, sp
  01f2c	e92d0007	 stmdb       sp!, {r0 - r2}
  01f30	e92d5000	 stmdb       sp!, {r12, lr}
  01f34	e24dd004	 sub         sp, sp, #4
  01f38		 |$M43869|

; 531  :     return OAL_FLASH_ERASE_FAILED;

  01f38	e3e03000	 mvn         r3, #0
  01f3c	e58d3000	 str         r3, [sp]

; 532  : }

  01f40	e59d0000	 ldr         r0, [sp]
  01f44	e28dd004	 add         sp, sp, #4
  01f48	e89d6000	 ldmia       sp, {sp, lr}
  01f4c	e12fff1e	 bx          lr
  01f50		 |$M43870|

			 ENDP  ; |ContinueEraseBlock2|

	EXPORT	|??_C@_1DA@LONNECBI@?$AA?9?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAW?$AAr?$AAi?$AAt?$AAe?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1IC@GHJADINJ@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAF?$AAl?$AAa?$AAs?$AAh?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAa?$AAt?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?5?$AA?9?$AA?9@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EM@LDCAJBDO@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAF?$AAl?$AAa?$AAs?$AAh?$AA?5?$AAw?$AAr?$AAi?$AAt?$AAe?$AA?5?$AAa?$AAt?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?5?$AAf?$AAa?$AAi@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HC@JDIFMGOM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAW?$AAr?$AAi?$AAt?$AAe?$AA?5?$AA?9?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAg?$AAe@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GC@GHFGCNFL@?$AA?$CL?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAW?$AAr?$AAi?$AAt?$AAe?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?0?$AA?5?$AA0@| [ DATA ] ; `string'
	EXPORT	|OALFlashWrite|

  00090			 AREA	 |.pdata|, PDATA
|$T43893| DCD	|$LN48@OALFlashWr|
	DCD	0x40013a04

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DA@LONNECBI@?$AA?9?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAW?$AAr?$AAi?$AAt?$AAe?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AA@| DCB "-"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "F", 0x0, "l", 0x0, "a"
	DCB	0x0, "s", 0x0, "h", 0x0, "W", 0x0, "r", 0x0, "i", 0x0, "t"
	DCB	0x0, "e", 0x0, "(", 0x0, "r", 0x0, "c", 0x0, " ", 0x0, "="
	DCB	0x0, " ", 0x0, "%", 0x0, "d", 0x0, ")", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1IC@GHJADINJ@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAF?$AAl?$AAa?$AAs?$AAh?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAa?$AAt?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?5?$AA?9?$AA?9@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "F", 0x0, "l", 0x0, "a", 0x0, "s", 0x0, "h", 0x0, " "
	DCB	0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "a", 0x0, "t", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "x", 0x0, " ", 0x0, "-"
	DCB	0x0, "-", 0x0, " ", 0x0, "w", 0x0, "r", 0x0, "i", 0x0, "t"
	DCB	0x0, "e", 0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%", 0x0, "0"
	DCB	0x0, "8", 0x0, "x", 0x0, ",", 0x0, " ", 0x0, "b", 0x0, "u"
	DCB	0x0, "t", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "a", 0x0, "d"
	DCB	0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%", 0x0, "0", 0x0, "8"
	DCB	0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EM@LDCAJBDO@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAF?$AAl?$AAa?$AAs?$AAh?$AA?5?$AAw?$AAr?$AAi?$AAt?$AAe?$AA?5?$AAa?$AAt?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?5?$AAf?$AAa?$AAi@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "F", 0x0, "l", 0x0, "a", 0x0, "s", 0x0, "h", 0x0, " "
	DCB	0x0, "w", 0x0, "r", 0x0, "i", 0x0, "t", 0x0, "e", 0x0, " "
	DCB	0x0, "a", 0x0, "t", 0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%"
	DCB	0x0, "0", 0x0, "8", 0x0, "x", 0x0, " ", 0x0, "f", 0x0, "a"
	DCB	0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HC@JDIFMGOM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAW?$AAr?$AAi?$AAt?$AAe?$AA?5?$AA?9?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAg?$AAe@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "F", 0x0, "l", 0x0, "a"
	DCB	0x0, "s", 0x0, "h", 0x0, "W", 0x0, "r", 0x0, "i", 0x0, "t"
	DCB	0x0, "e", 0x0, " ", 0x0, "-", 0x0, " ", 0x0, "f", 0x0, "a"
	DCB	0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, " ", 0x0, "g"
	DCB	0x0, "e", 0x0, "t", 0x0, " ", 0x0, "f", 0x0, "l", 0x0, "a"
	DCB	0x0, "s", 0x0, "h", 0x0, " ", 0x0, "i", 0x0, "n", 0x0, "f"
	DCB	0x0, "o", 0x0, " ", 0x0, "a", 0x0, "t", 0x0, " ", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "0", 0x0, "8", 0x0, "x", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GC@GHFGCNFL@?$AA?$CL?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAW?$AAr?$AAi?$AAt?$AAe?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?0?$AA?5?$AA0@| DCB "+"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "F", 0x0, "l", 0x0, "a"
	DCB	0x0, "s", 0x0, "h", 0x0, "W", 0x0, "r", 0x0, "i", 0x0, "t"
	DCB	0x0, "e", 0x0, "(", 0x0, "0", 0x0, "x", 0x0, "%", 0x0, "0"
	DCB	0x0, "8", 0x0, "x", 0x0, ",", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "x", 0x0, ",", 0x0, " "
	DCB	0x0, "0", 0x0, "x", 0x0, "%", 0x0, "0", 0x0, "8", 0x0, "x"
	DCB	0x0, ",", 0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%", 0x0, "0"
	DCB	0x0, "8", 0x0, "x", 0x0, ")", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Odtp

  01f50			 AREA	 |.text|, CODE, ARM

  01f50		 |OALFlashWrite| PROC

; 1132 : {

  01f50		 |$LN48@OALFlashWr|
  01f50	e1a0c00d	 mov         r12, sp
  01f54	e92d000f	 stmdb       sp!, {r0 - r3}
  01f58	e92d5000	 stmdb       sp!, {r12, lr}
  01f5c	e24dd0c0	 sub         sp, sp, #0xC0
  01f60		 |$M43890|

; 1133 :     BOOL rc = FALSE;

  01f60	e3a03000	 mov         r3, #0
  01f64	e58d3008	 str         r3, [sp, #8]

; 1134 :     OAL_FLASH_INFO info;
; 1135 :     DWORD base = (DWORD)pBase;

  01f68	e59d30c8	 ldr         r3, [sp, #0xC8]
  01f6c	e58d3014	 str         r3, [sp, #0x14]

; 1136 :     DWORD start = (DWORD)pStart;

  01f70	e59d30cc	 ldr         r3, [sp, #0xCC]
  01f74	e58d301c	 str         r3, [sp, #0x1C]

; 1137 :     DWORD end = start + size;

  01f78	e59d201c	 ldr         r2, [sp, #0x1C]
  01f7c	e59d30d0	 ldr         r3, [sp, #0xD0]
  01f80	e0823003	 add         r3, r2, r3
  01f84	e58d3018	 str         r3, [sp, #0x18]

; 1138 :     DWORD chipStart;
; 1139 :     DWORD chipEnd;
; 1140 :     DWORD pos, count;
; 1141 :     UCHAR *pPos;
; 1142 : 
; 1143 :     OALMSG(OAL_FUNC, (
; 1144 :         L"+OALFlashWrite(0x%08x, 0x%08x, 0x%08x, 0x%08x)\r\n", 
; 1145 :         pBase, pStart, size, pBuffer
; 1146 :     ));

  01f88	e59f3490	 ldr         r3, [pc, #0x490]
  01f8c	e5933440	 ldr         r3, [r3, #0x440]
  01f90	e3130004	 tst         r3, #4
  01f94	0a000009	 beq         |$LN32@OALFlashWr|
  01f98	e59d30d4	 ldr         r3, [sp, #0xD4]
  01f9c	e58d3000	 str         r3, [sp]
  01fa0	e59d30d0	 ldr         r3, [sp, #0xD0]
  01fa4	e59d20cc	 ldr         r2, [sp, #0xCC]
  01fa8	e59d10c8	 ldr         r1, [sp, #0xC8]
  01fac	e59f0480	 ldr         r0, [pc, #0x480]
  01fb0	eb000000	 bl          NKDbgPrintfW
  01fb4	e3a03001	 mov         r3, #1
  01fb8	e58d3088	 str         r3, [sp, #0x88]
  01fbc	ea000001	 b           |$LN33@OALFlashWr|
  01fc0		 |$LN32@OALFlashWr|
  01fc0	e3a03000	 mov         r3, #0
  01fc4	e58d3088	 str         r3, [sp, #0x88]
  01fc8		 |$LN33@OALFlashWr|

; 1147 : 
; 1148 :     chipStart = base;

  01fc8	e59d3014	 ldr         r3, [sp, #0x14]
  01fcc	e58d300c	 str         r3, [sp, #0xC]

; 1149 :     pPos = (UCHAR*)pBuffer;

  01fd0	e59d30d4	 ldr         r3, [sp, #0xD4]
  01fd4	e58d3078	 str         r3, [sp, #0x78]
  01fd8		 |$LN29@OALFlashWr|

; 1150 : 
; 1151 :     // First read first chip info
; 1152 :     while (TRUE)
; 1153 :     {
; 1154 :         if (!OALFlashInfo((VOID*)chipStart, &info))

  01fd8	e28d1020	 add         r1, sp, #0x20
  01fdc	e59d000c	 ldr         r0, [sp, #0xC]
  01fe0	eb000000	 bl          OALFlashInfo
  01fe4	e58d008c	 str         r0, [sp, #0x8C]
  01fe8	e59d308c	 ldr         r3, [sp, #0x8C]
  01fec	e3530000	 cmp         r3, #0
  01ff0	1a00000c	 bne         |$LN27@OALFlashWr|

; 1155 :         {
; 1156 :                 OALMSG(OAL_ERROR, (
; 1157 :                     L"ERROR: OALFlashWrite - failed get flash info at 0x%08x\r\n",
; 1158 :                     chipStart
; 1159 :                 ));

  01ff4	e59f3424	 ldr         r3, [pc, #0x424]
  01ff8	e5933440	 ldr         r3, [r3, #0x440]
  01ffc	e3130001	 tst         r3, #1
  02000	0a000005	 beq         |$LN34@OALFlashWr|
  02004	e59d100c	 ldr         r1, [sp, #0xC]
  02008	e59f0420	 ldr         r0, [pc, #0x420]
  0200c	eb000000	 bl          NKDbgPrintfW
  02010	e3a03001	 mov         r3, #1
  02014	e58d3090	 str         r3, [sp, #0x90]
  02018	ea000001	 b           |$LN35@OALFlashWr|
  0201c		 |$LN34@OALFlashWr|
  0201c	e3a03000	 mov         r3, #0
  02020	e58d3090	 str         r3, [sp, #0x90]
  02024		 |$LN35@OALFlashWr|

; 1160 :                 goto cleanUp;

  02024	ea0000ea	 b           |$cleanUp$43598|
  02028		 |$LN27@OALFlashWr|

; 1161 :         }
; 1162 :         chipEnd = chipStart + info.size * info.parallel;

  02028	e59d102c	 ldr         r1, [sp, #0x2C]
  0202c	e59d3024	 ldr         r3, [sp, #0x24]
  02030	e0020391	 mul         r2, r1, r3
  02034	e59d300c	 ldr         r3, [sp, #0xC]
  02038	e0833002	 add         r3, r3, r2
  0203c	e58d3010	 str         r3, [sp, #0x10]

; 1163 :         // Is start address on this chip
; 1164 :         if (start >= chipStart && start < chipEnd) break;

  02040	e59d201c	 ldr         r2, [sp, #0x1C]
  02044	e59d300c	 ldr         r3, [sp, #0xC]
  02048	e1520003	 cmp         r2, r3
  0204c	3a000004	 bcc         |$LN26@OALFlashWr|
  02050	e59d201c	 ldr         r2, [sp, #0x1C]
  02054	e59d3010	 ldr         r3, [sp, #0x10]
  02058	e1520003	 cmp         r2, r3
  0205c	2a000000	 bcs         |$LN26@OALFlashWr|
  02060	ea000002	 b           |$LN28@OALFlashWr|
  02064		 |$LN26@OALFlashWr|

; 1165 :         // Move to next chip
; 1166 :         chipStart = chipEnd;

  02064	e59d3010	 ldr         r3, [sp, #0x10]
  02068	e58d300c	 str         r3, [sp, #0xC]

; 1167 :     }

  0206c	eaffffd9	 b           |$LN29@OALFlashWr|
  02070		 |$LN28@OALFlashWr|

; 1168 :    
; 1169 :     pos = start;

  02070	e59d301c	 ldr         r3, [sp, #0x1C]
  02074	e58d307c	 str         r3, [sp, #0x7C]
  02078		 |$LN25@OALFlashWr|

; 1170 :     while (pos < end)

  02078	e59d207c	 ldr         r2, [sp, #0x7C]
  0207c	e59d3018	 ldr         r3, [sp, #0x18]
  02080	e1520003	 cmp         r2, r3
  02084	2a000082	 bcs         |$LN24@OALFlashWr|

; 1171 :         {
; 1172 : 
; 1173 :         // How many data we can write
; 1174 :         if (end > chipEnd)

  02088	e59d2018	 ldr         r2, [sp, #0x18]
  0208c	e59d3010	 ldr         r3, [sp, #0x10]
  02090	e1520003	 cmp         r2, r3
  02094	9a000004	 bls         |$LN23@OALFlashWr|

; 1175 :             {
; 1176 :             count = chipEnd - pos;

  02098	e59d2010	 ldr         r2, [sp, #0x10]
  0209c	e59d307c	 ldr         r3, [sp, #0x7C]
  020a0	e0423003	 sub         r3, r2, r3
  020a4	e58d3004	 str         r3, [sp, #4]

; 1177 :             }
; 1178 :         else

  020a8	ea000003	 b           |$LN22@OALFlashWr|
  020ac		 |$LN23@OALFlashWr|

; 1179 :             {
; 1180 :             count = end - pos;

  020ac	e59d2018	 ldr         r2, [sp, #0x18]
  020b0	e59d307c	 ldr         r3, [sp, #0x7C]
  020b4	e0423003	 sub         r3, r2, r3
  020b8	e58d3004	 str         r3, [sp, #4]
  020bc		 |$LN22@OALFlashWr|

; 1181 :             }
; 1182 :         
; 1183 :         // Program data chunk
; 1184 :         switch (info.set)

  020bc	e59d3028	 ldr         r3, [sp, #0x28]
  020c0	e58d3094	 str         r3, [sp, #0x94]
  020c4	e59d3094	 ldr         r3, [sp, #0x94]
  020c8	e3530001	 cmp         r3, #1
  020cc	0a000006	 beq         |$LN19@OALFlashWr|
  020d0	e59d3094	 ldr         r3, [sp, #0x94]
  020d4	e3530002	 cmp         r3, #2
  020d8	0a00000c	 beq         |$LN18@OALFlashWr|
  020dc	e59d3094	 ldr         r3, [sp, #0x94]
  020e0	e3530003	 cmp         r3, #3
  020e4	0a000000	 beq         |$LN19@OALFlashWr|
  020e8	ea000011	 b           |$LN17@OALFlashWr|
  020ec		 |$LN19@OALFlashWr|

; 1185 :             {
; 1186 : 
; 1187 : #ifndef OAL_FLASH_NO_COMMAND_SET_1                
; 1188 :             case 1:
; 1189 :             case 3:
; 1190 :                 count = WriteData1(&info, chipStart, pos, pPos);

  020ec	e59d3078	 ldr         r3, [sp, #0x78]
  020f0	e59d207c	 ldr         r2, [sp, #0x7C]
  020f4	e59d100c	 ldr         r1, [sp, #0xC]
  020f8	e28d0020	 add         r0, sp, #0x20
  020fc	eb000000	 bl          WriteData1
  02100	e58d0098	 str         r0, [sp, #0x98]
  02104	e59d3098	 ldr         r3, [sp, #0x98]
  02108	e58d3004	 str         r3, [sp, #4]

; 1191 :                 break;

  0210c	ea000015	 b           |$LN20@OALFlashWr|
  02110		 |$LN18@OALFlashWr|

; 1192 : #endif OAL_FLASH_NO_COMMAND_SET_1
; 1193 : 
; 1194 : #ifndef OAL_FLASH_NO_COMMAND_SET_2
; 1195 :             case 2:
; 1196 :                 count = WriteData2(&info, chipStart, pos, pPos);

  02110	e59d3078	 ldr         r3, [sp, #0x78]
  02114	e59d207c	 ldr         r2, [sp, #0x7C]
  02118	e59d100c	 ldr         r1, [sp, #0xC]
  0211c	e28d0020	 add         r0, sp, #0x20
  02120	eb000000	 bl          WriteData2
  02124	e58d009c	 str         r0, [sp, #0x9C]
  02128	e59d309c	 ldr         r3, [sp, #0x9C]
  0212c	e58d3004	 str         r3, [sp, #4]

; 1197 :                 break;

  02130	ea00000c	 b           |$LN20@OALFlashWr|
  02134		 |$LN17@OALFlashWr|

; 1198 : #endif OAL_FLASH_NO_COMMAND_SET_2
; 1199 : 
; 1200 :             default:
; 1201 :             OALMSG(OAL_ERROR, (
; 1202 :                 L"ERROR: Flash type %d isn't supported\r\n", info.set
; 1203 :             ));

  02134	e59f32e4	 ldr         r3, [pc, #0x2E4]
  02138	e5933440	 ldr         r3, [r3, #0x440]
  0213c	e3130001	 tst         r3, #1
  02140	0a000005	 beq         |$LN36@OALFlashWr|
  02144	e59d1028	 ldr         r1, [sp, #0x28]
  02148	e59f02dc	 ldr         r0, [pc, #0x2DC]
  0214c	eb000000	 bl          NKDbgPrintfW
  02150	e3a03001	 mov         r3, #1
  02154	e58d30a0	 str         r3, [sp, #0xA0]
  02158	ea000001	 b           |$LN37@OALFlashWr|
  0215c		 |$LN36@OALFlashWr|
  0215c	e3a03000	 mov         r3, #0
  02160	e58d30a0	 str         r3, [sp, #0xA0]
  02164		 |$LN37@OALFlashWr|

; 1204 :                 goto cleanUp;

  02164	ea00009a	 b           |$cleanUp$43598|
  02168		 |$LN20@OALFlashWr|

; 1205 :             }
; 1206 : 
; 1207 :         // If we write nothing something wrong happen
; 1208 :         if (count == 0)

  02168	e59d3004	 ldr         r3, [sp, #4]
  0216c	e3530000	 cmp         r3, #0
  02170	1a00000e	 bne         |$LN16@OALFlashWr|

; 1209 :             {
; 1210 :             rc = FALSE;

  02174	e3a03000	 mov         r3, #0
  02178	e58d3008	 str         r3, [sp, #8]

; 1211 :             OALMSG(OAL_ERROR, (
; 1212 :                 L"ERROR: Flash write at 0x%08x failed\r\n", pos
; 1213 :             ));

  0217c	e59f329c	 ldr         r3, [pc, #0x29C]
  02180	e5933440	 ldr         r3, [r3, #0x440]
  02184	e3130001	 tst         r3, #1
  02188	0a000005	 beq         |$LN38@OALFlashWr|
  0218c	e59d107c	 ldr         r1, [sp, #0x7C]
  02190	e59f0290	 ldr         r0, [pc, #0x290]
  02194	eb000000	 bl          NKDbgPrintfW
  02198	e3a03001	 mov         r3, #1
  0219c	e58d30a4	 str         r3, [sp, #0xA4]
  021a0	ea000001	 b           |$LN39@OALFlashWr|
  021a4		 |$LN38@OALFlashWr|
  021a4	e3a03000	 mov         r3, #0
  021a8	e58d30a4	 str         r3, [sp, #0xA4]
  021ac		 |$LN39@OALFlashWr|

; 1214 :             goto cleanUp;

  021ac	ea000088	 b           |$cleanUp$43598|
  021b0		 |$LN16@OALFlashWr|

; 1215 :             }
; 1216 :       
; 1217 :         // Move position
; 1218 :         pos += count;

  021b0	e59d207c	 ldr         r2, [sp, #0x7C]
  021b4	e59d3004	 ldr         r3, [sp, #4]
  021b8	e0823003	 add         r3, r2, r3
  021bc	e58d307c	 str         r3, [sp, #0x7C]

; 1219 :         pPos += count;

  021c0	e59d2078	 ldr         r2, [sp, #0x78]
  021c4	e59d3004	 ldr         r3, [sp, #4]
  021c8	e0823003	 add         r3, r2, r3
  021cc	e58d3078	 str         r3, [sp, #0x78]

; 1220 : 
; 1221 :         // Break when we are done
; 1222 :         if (pos >= end) break;

  021d0	e59d207c	 ldr         r2, [sp, #0x7C]
  021d4	e59d3018	 ldr         r3, [sp, #0x18]
  021d8	e1520003	 cmp         r2, r3
  021dc	3a000000	 bcc         |$LN15@OALFlashWr|
  021e0	ea00002b	 b           |$LN24@OALFlashWr|
  021e4		 |$LN15@OALFlashWr|

; 1223 :         
; 1224 :         // If we run out of chip move to next one
; 1225 :         if (pos > chipEnd)

  021e4	e59d207c	 ldr         r2, [sp, #0x7C]
  021e8	e59d3010	 ldr         r3, [sp, #0x10]
  021ec	e1520003	 cmp         r2, r3
  021f0	9a000026	 bls         |$LN14@OALFlashWr|

; 1226 :             {
; 1227 :             switch(info.set) {

  021f4	e59d3028	 ldr         r3, [sp, #0x28]
  021f8	e58d30a8	 str         r3, [sp, #0xA8]
  021fc	e59d30a8	 ldr         r3, [sp, #0xA8]
  02200	e3530001	 cmp         r3, #1
  02204	0a000006	 beq         |$LN11@OALFlashWr|
  02208	e59d30a8	 ldr         r3, [sp, #0xA8]
  0220c	e3530002	 cmp         r3, #2
  02210	0a000009	 beq         |$LN10@OALFlashWr|
  02214	e59d30a8	 ldr         r3, [sp, #0xA8]
  02218	e3530003	 cmp         r3, #3
  0221c	0a000000	 beq         |$LN11@OALFlashWr|
  02220	ea00000a	 b           |$LN12@OALFlashWr|
  02224		 |$LN11@OALFlashWr|

; 1228 :                 case 1:
; 1229 :                 case 3:
; 1230 :                     WriteCommand(&info, chipStart, 0, 0xFF);

  02224	e3a030ff	 mov         r3, #0xFF
  02228	e3a02000	 mov         r2, #0
  0222c	e59d100c	 ldr         r1, [sp, #0xC]
  02230	e28d0020	 add         r0, sp, #0x20
  02234	eb000000	 bl          WriteCommand

; 1231 :                     break;

  02238	ea000004	 b           |$LN12@OALFlashWr|
  0223c		 |$LN10@OALFlashWr|

; 1232 :                 case 2:
; 1233 :                     WriteCommand(&info, chipStart, 0, 0xF0);

  0223c	e3a030f0	 mov         r3, #0xF0
  02240	e3a02000	 mov         r2, #0
  02244	e59d100c	 ldr         r1, [sp, #0xC]
  02248	e28d0020	 add         r0, sp, #0x20
  0224c	eb000000	 bl          WriteCommand
  02250		 |$LN12@OALFlashWr|

; 1234 :                     break;
; 1235 :                 }
; 1236 :             chipStart = chipEnd;

  02250	e59d3010	 ldr         r3, [sp, #0x10]
  02254	e58d300c	 str         r3, [sp, #0xC]

; 1237 :             if (!OALFlashInfo((VOID*)chipStart, &info)) break;

  02258	e28d1020	 add         r1, sp, #0x20
  0225c	e59d000c	 ldr         r0, [sp, #0xC]
  02260	eb000000	 bl          OALFlashInfo
  02264	e58d00ac	 str         r0, [sp, #0xAC]
  02268	e59d30ac	 ldr         r3, [sp, #0xAC]
  0226c	e3530000	 cmp         r3, #0
  02270	1a000000	 bne         |$LN9@OALFlashWr|
  02274	ea000006	 b           |$LN24@OALFlashWr|
  02278		 |$LN9@OALFlashWr|

; 1238 :             chipEnd = chipStart + info.size * info.parallel;

  02278	e59d102c	 ldr         r1, [sp, #0x2C]
  0227c	e59d3024	 ldr         r3, [sp, #0x24]
  02280	e0020391	 mul         r2, r1, r3
  02284	e59d300c	 ldr         r3, [sp, #0xC]
  02288	e0833002	 add         r3, r3, r2
  0228c	e58d3010	 str         r3, [sp, #0x10]
  02290		 |$LN14@OALFlashWr|

; 1239 :             }         
; 1240 :         }

  02290	eaffff78	 b           |$LN25@OALFlashWr|
  02294		 |$LN24@OALFlashWr|

; 1241 : 
; 1242 :     // Done
; 1243 :     //rc = TRUE;
; 1244 :     switch (info.set) {

  02294	e59d3028	 ldr         r3, [sp, #0x28]
  02298	e58d30b0	 str         r3, [sp, #0xB0]
  0229c	e59d30b0	 ldr         r3, [sp, #0xB0]
  022a0	e3530001	 cmp         r3, #1
  022a4	0a000006	 beq         |$LN6@OALFlashWr|
  022a8	e59d30b0	 ldr         r3, [sp, #0xB0]
  022ac	e3530002	 cmp         r3, #2
  022b0	0a000009	 beq         |$LN5@OALFlashWr|
  022b4	e59d30b0	 ldr         r3, [sp, #0xB0]
  022b8	e3530003	 cmp         r3, #3
  022bc	0a000000	 beq         |$LN6@OALFlashWr|
  022c0	ea00000a	 b           |$LN7@OALFlashWr|
  022c4		 |$LN6@OALFlashWr|

; 1245 :     case 1:
; 1246 :     case 3:
; 1247 :         WriteCommand(&info, chipStart, 0, 0xFF);

  022c4	e3a030ff	 mov         r3, #0xFF
  022c8	e3a02000	 mov         r2, #0
  022cc	e59d100c	 ldr         r1, [sp, #0xC]
  022d0	e28d0020	 add         r0, sp, #0x20
  022d4	eb000000	 bl          WriteCommand

; 1248 :         break;

  022d8	ea000004	 b           |$LN7@OALFlashWr|
  022dc		 |$LN5@OALFlashWr|

; 1249 :     case 2:
; 1250 :         WriteCommand(&info, chipStart, 0, 0xF0);

  022dc	e3a030f0	 mov         r3, #0xF0
  022e0	e3a02000	 mov         r2, #0
  022e4	e59d100c	 ldr         r1, [sp, #0xC]
  022e8	e28d0020	 add         r0, sp, #0x20
  022ec	eb000000	 bl          WriteCommand
  022f0		 |$LN7@OALFlashWr|

; 1251 :         break;
; 1252 :     }
; 1253 : 
; 1254 :     // Do final check
; 1255 :     pPos = (UINT8*)pBuffer;

  022f0	e59d30d4	 ldr         r3, [sp, #0xD4]
  022f4	e58d3078	 str         r3, [sp, #0x78]

; 1256 :     for (pos = start; pos < end - sizeof(UINT32) + 1; pos += sizeof(UINT32)) {

  022f8	e59d301c	 ldr         r3, [sp, #0x1C]
  022fc	e58d307c	 str         r3, [sp, #0x7C]
  02300	ea000002	 b           |$LN4@OALFlashWr|
  02304		 |$LN3@OALFlashWr|
  02304	e59d307c	 ldr         r3, [sp, #0x7C]
  02308	e2833004	 add         r3, r3, #4
  0230c	e58d307c	 str         r3, [sp, #0x7C]
  02310		 |$LN4@OALFlashWr|
  02310	e59d3018	 ldr         r3, [sp, #0x18]
  02314	e2433004	 sub         r3, r3, #4
  02318	e2832001	 add         r2, r3, #1
  0231c	e59d307c	 ldr         r3, [sp, #0x7C]
  02320	e1530002	 cmp         r3, r2
  02324	2a00000a	 bcs         |$LN2@OALFlashWr|

; 1257 :         if (*(UINT32*)pPos != *(UINT32*)pos) break;

  02328	e59d3078	 ldr         r3, [sp, #0x78]
  0232c	e5932000	 ldr         r2, [r3]
  02330	e59d307c	 ldr         r3, [sp, #0x7C]
  02334	e5933000	 ldr         r3, [r3]
  02338	e1520003	 cmp         r2, r3
  0233c	0a000000	 beq         |$LN1@OALFlashWr|
  02340	ea000003	 b           |$LN2@OALFlashWr|
  02344		 |$LN1@OALFlashWr|

; 1258 :         pPos += sizeof(UINT32);

  02344	e59d3078	 ldr         r3, [sp, #0x78]
  02348	e2833004	 add         r3, r3, #4
  0234c	e58d3078	 str         r3, [sp, #0x78]

; 1259 :     }

  02350	eaffffeb	 b           |$LN3@OALFlashWr|
  02354		 |$LN2@OALFlashWr|

; 1260 : 
; 1261 :     // If we reach end, all is ok
; 1262 :     rc = (pos >= end - sizeof(UINT32) + 1);

  02354	e59d3018	 ldr         r3, [sp, #0x18]
  02358	e2433004	 sub         r3, r3, #4
  0235c	e2832001	 add         r2, r3, #1
  02360	e59d307c	 ldr         r3, [sp, #0x7C]
  02364	e1530002	 cmp         r3, r2
  02368	3a000002	 bcc         |$LN40@OALFlashWr|
  0236c	e3a03001	 mov         r3, #1
  02370	e58d30b4	 str         r3, [sp, #0xB4]
  02374	ea000001	 b           |$LN41@OALFlashWr|
  02378		 |$LN40@OALFlashWr|
  02378	e3a03000	 mov         r3, #0
  0237c	e58d30b4	 str         r3, [sp, #0xB4]
  02380		 |$LN41@OALFlashWr|
  02380	e59d30b4	 ldr         r3, [sp, #0xB4]
  02384	e58d3008	 str         r3, [sp, #8]

; 1263 :     OALMSG(!rc&&OAL_ERROR, (
; 1264 :         L"ERROR: Flash failed at 0x%08x -- write 0x%08x, but read 0x%08x\r\n",
; 1265 :         pos, *(UINT32*)pPos, *(UINT32*)pos
; 1266 :     ));

  02388	e59d3008	 ldr         r3, [sp, #8]
  0238c	e3530000	 cmp         r3, #0
  02390	1a00000d	 bne         |$LN42@OALFlashWr|
  02394	e59f3084	 ldr         r3, [pc, #0x84]
  02398	e5933440	 ldr         r3, [r3, #0x440]
  0239c	e3130001	 tst         r3, #1
  023a0	0a000009	 beq         |$LN42@OALFlashWr|
  023a4	e59d307c	 ldr         r3, [sp, #0x7C]
  023a8	e5933000	 ldr         r3, [r3]
  023ac	e59d2078	 ldr         r2, [sp, #0x78]
  023b0	e5922000	 ldr         r2, [r2]
  023b4	e59d107c	 ldr         r1, [sp, #0x7C]
  023b8	e59f0064	 ldr         r0, [pc, #0x64]
  023bc	eb000000	 bl          NKDbgPrintfW
  023c0	e3a03001	 mov         r3, #1
  023c4	e58d30b8	 str         r3, [sp, #0xB8]
  023c8	ea000001	 b           |$LN43@OALFlashWr|
  023cc		 |$LN42@OALFlashWr|
  023cc	e3a03000	 mov         r3, #0
  023d0	e58d30b8	 str         r3, [sp, #0xB8]
  023d4		 |$LN43@OALFlashWr|
  023d4		 |$cleanUp$43598|

; 1267 :     
; 1268 : cleanUp:
; 1269 :     OALMSG(OAL_FUNC, (L"-OALFlashWrite(rc = %d)", rc));

  023d4	e59f3044	 ldr         r3, [pc, #0x44]
  023d8	e5933440	 ldr         r3, [r3, #0x440]
  023dc	e3130004	 tst         r3, #4
  023e0	0a000005	 beq         |$LN44@OALFlashWr|
  023e4	e59d1008	 ldr         r1, [sp, #8]
  023e8	e59f002c	 ldr         r0, [pc, #0x2C]
  023ec	eb000000	 bl          NKDbgPrintfW
  023f0	e3a03001	 mov         r3, #1
  023f4	e58d30bc	 str         r3, [sp, #0xBC]
  023f8	ea000001	 b           |$LN45@OALFlashWr|
  023fc		 |$LN44@OALFlashWr|
  023fc	e3a03000	 mov         r3, #0
  02400	e58d30bc	 str         r3, [sp, #0xBC]
  02404		 |$LN45@OALFlashWr|

; 1270 :     return rc;

  02404	e59d3008	 ldr         r3, [sp, #8]
  02408	e58d3084	 str         r3, [sp, #0x84]

; 1271 : }

  0240c	e59d0084	 ldr         r0, [sp, #0x84]
  02410	e28dd0c0	 add         sp, sp, #0xC0
  02414	e89d6000	 ldmia       sp, {sp, lr}
  02418	e12fff1e	 bx          lr
  0241c		 |$LN49@OALFlashWr|
  0241c		 |$LN50@OALFlashWr|
  0241c	00000000	 DCD         |??_C@_1DA@LONNECBI@?$AA?9?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAW?$AAr?$AAi?$AAt?$AAe?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AA@|
  02420		 |$LN51@OALFlashWr|
  02420	00000000	 DCD         |dpCurSettings|
  02424		 |$LN52@OALFlashWr|
  02424	00000000	 DCD         |??_C@_1IC@GHJADINJ@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAF?$AAl?$AAa?$AAs?$AAh?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAa?$AAt?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?5?$AA?9?$AA?9@|
  02428		 |$LN53@OALFlashWr|
  02428	00000000	 DCD         |??_C@_1EM@LDCAJBDO@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAF?$AAl?$AAa?$AAs?$AAh?$AA?5?$AAw?$AAr?$AAi?$AAt?$AAe?$AA?5?$AAa?$AAt?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?5?$AAf?$AAa?$AAi@|
  0242c		 |$LN54@OALFlashWr|
  0242c	00000000	 DCD         |??_C@_1EO@JKEJJFHN@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAF?$AAl?$AAa?$AAs?$AAh?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CF?$AAd?$AA?5?$AAi?$AAs?$AAn?$AA?8?$AAt?$AA?5?$AAs?$AAu?$AAp?$AAp?$AAo@|
  02430		 |$LN55@OALFlashWr|
  02430	00000000	 DCD         |??_C@_1HC@JDIFMGOM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAW?$AAr?$AAi?$AAt?$AAe?$AA?5?$AA?9?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAg?$AAe@|
  02434		 |$LN56@OALFlashWr|
  02434	00000000	 DCD         |??_C@_1GC@GHFGCNFL@?$AA?$CL?$AAO?$AAA?$AAL?$AAF?$AAl?$AAa?$AAs?$AAh?$AAW?$AAr?$AAi?$AAt?$AAe?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?0?$AA?5?$AA0@|
  02438		 |$M43891|

			 ENDP  ; |OALFlashWrite|


  00098			 AREA	 |.pdata|, PDATA
|$T43907| DCD	|$LN13@WriteData1|
	DCD	0x40005304
; Function compile flags: /Odtp

  02438			 AREA	 |.text|, CODE, ARM

  02438		 |WriteData1| PROC

; 401  : {

  02438		 |$LN13@WriteData1|
  02438	e1a0c00d	 mov         r12, sp
  0243c	e92d000f	 stmdb       sp!, {r0 - r3}
  02440	e92d5000	 stmdb       sp!, {r12, lr}
  02444	e24dd014	 sub         sp, sp, #0x14
  02448		 |$M43904|

; 402  :     UINT32 size = 0;

  02448	e3a03000	 mov         r3, #0
  0244c	e58d3004	 str         r3, [sp, #4]

; 403  :     UINT8 bits;
; 404  : 
; 405  :     // Issue write command
; 406  :     WriteCommand(pInfo, base, 0, 0x40);

  02450	e3a03040	 mov         r3, #0x40
  02454	e3a02000	 mov         r2, #0
  02458	e59d1020	 ldr         r1, [sp, #0x20]
  0245c	e59d001c	 ldr         r0, [sp, #0x1C]
  02460	eb000000	 bl          WriteCommand

; 407  :    
; 408  :     // Now write info and wait until it is done
; 409  :     switch (pInfo->width)

  02464	e59d301c	 ldr         r3, [sp, #0x1C]
  02468	e5933000	 ldr         r3, [r3]
  0246c	e58d300c	 str         r3, [sp, #0xC]
  02470	e59d300c	 ldr         r3, [sp, #0xC]
  02474	e3530001	 cmp         r3, #1
  02478	0a000010	 beq         |$LN4@WriteData1|
  0247c	e59d300c	 ldr         r3, [sp, #0xC]
  02480	e3530002	 cmp         r3, #2
  02484	0a000008	 beq         |$LN5@WriteData1|
  02488	e59d300c	 ldr         r3, [sp, #0xC]
  0248c	e3530004	 cmp         r3, #4
  02490	0a000000	 beq         |$LN6@WriteData1|
  02494	ea00000d	 b           |$LN7@WriteData1|
  02498		 |$LN6@WriteData1|

; 410  :         {
; 411  :         case 4:
; 412  :             OUTREG32((UINT32*)pos, *(UINT32*)pBuffer);

  02498	e59d3028	 ldr         r3, [sp, #0x28]
  0249c	e5931000	 ldr         r1, [r3]
  024a0	e59d0024	 ldr         r0, [sp, #0x24]
  024a4	eb000000	 bl          WRITE_REGISTER_ULONG

; 413  :             break;

  024a8	ea000008	 b           |$LN7@WriteData1|
  024ac		 |$LN5@WriteData1|

; 414  :         case 2:
; 415  :             OUTREG16((UINT16*)pos, *(UINT16*)pBuffer);

  024ac	e59d3028	 ldr         r3, [sp, #0x28]
  024b0	e1d310b0	 ldrh        r1, [r3]
  024b4	e59d0024	 ldr         r0, [sp, #0x24]
  024b8	eb000000	 bl          WRITE_REGISTER_USHORT

; 416  :             break;

  024bc	ea000003	 b           |$LN7@WriteData1|
  024c0		 |$LN4@WriteData1|

; 417  :         case 1:
; 418  :             OUTREG8((UINT8*)pos, *(UINT8*)pBuffer);

  024c0	e59d3028	 ldr         r3, [sp, #0x28]
  024c4	e5d31000	 ldrb        r1, [r3]
  024c8	e59d0024	 ldr         r0, [sp, #0x24]
  024cc	eb000000	 bl          WRITE_REGISTER_UCHAR
  024d0		 |$LN7@WriteData1|

; 419  :             break;
; 420  :         }
; 421  : 
; 422  :     // Wait until write is done
; 423  :     WriteCommand(pInfo, base, 0, 0x70);

  024d0	e3a03070	 mov         r3, #0x70
  024d4	e3a02000	 mov         r2, #0
  024d8	e59d1020	 ldr         r1, [sp, #0x20]
  024dc	e59d001c	 ldr         r0, [sp, #0x1C]
  024e0	eb000000	 bl          WriteCommand

; 424  :     bits = BitsAnd(pInfo, pos, 0);

  024e4	e3a02000	 mov         r2, #0
  024e8	e59d1024	 ldr         r1, [sp, #0x24]
  024ec	e59d001c	 ldr         r0, [sp, #0x1C]
  024f0	eb000000	 bl          BitsAnd
  024f4	e5cd0010	 strb        r0, [sp, #0x10]
  024f8	e5dd3010	 ldrb        r3, [sp, #0x10]
  024fc	e5cd3000	 strb        r3, [sp]
  02500		 |$LN3@WriteData1|

; 425  :     while ((bits & (1 << 7)) == 0)

  02500	e5dd3000	 ldrb        r3, [sp]
  02504	e3130080	 tst         r3, #0x80
  02508	1a00000c	 bne         |$LN2@WriteData1|

; 426  :         {
; 427  :         WriteCommand(pInfo, base, 0, 0x70);

  0250c	e3a03070	 mov         r3, #0x70
  02510	e3a02000	 mov         r2, #0
  02514	e59d1020	 ldr         r1, [sp, #0x20]
  02518	e59d001c	 ldr         r0, [sp, #0x1C]
  0251c	eb000000	 bl          WriteCommand

; 428  :         bits = BitsAnd(pInfo, pos, 0);

  02520	e3a02000	 mov         r2, #0
  02524	e59d1024	 ldr         r1, [sp, #0x24]
  02528	e59d001c	 ldr         r0, [sp, #0x1C]
  0252c	eb000000	 bl          BitsAnd
  02530	e5cd0011	 strb        r0, [sp, #0x11]
  02534	e5dd3011	 ldrb        r3, [sp, #0x11]
  02538	e5cd3000	 strb        r3, [sp]

; 429  :         }

  0253c	eaffffef	 b           |$LN3@WriteData1|
  02540		 |$LN2@WriteData1|

; 430  :     
; 431  :     // Bit 4 is zero if write succeeded
; 432  :     if ((bits & (1 << 4)) == 0) size = pInfo->width;

  02540	e5dd3000	 ldrb        r3, [sp]
  02544	e3130010	 tst         r3, #0x10
  02548	1a000002	 bne         |$LN1@WriteData1|
  0254c	e59d301c	 ldr         r3, [sp, #0x1C]
  02550	e5933000	 ldr         r3, [r3]
  02554	e58d3004	 str         r3, [sp, #4]
  02558		 |$LN1@WriteData1|

; 433  : 
; 434  :     // Reset memory back to normal state
; 435  :     WriteCommand(pInfo, base, 0, 0xFF);

  02558	e3a030ff	 mov         r3, #0xFF
  0255c	e3a02000	 mov         r2, #0
  02560	e59d1020	 ldr         r1, [sp, #0x20]
  02564	e59d001c	 ldr         r0, [sp, #0x1C]
  02568	eb000000	 bl          WriteCommand

; 436  : 
; 437  :     // Return result
; 438  :     return size;

  0256c	e59d3004	 ldr         r3, [sp, #4]
  02570	e58d3008	 str         r3, [sp, #8]

; 439  : }

  02574	e59d0008	 ldr         r0, [sp, #8]
  02578	e28dd014	 add         sp, sp, #0x14
  0257c	e89d6000	 ldmia       sp, {sp, lr}
  02580	e12fff1e	 bx          lr
  02584		 |$M43905|

			 ENDP  ; |WriteData1|


  000a0			 AREA	 |.pdata|, PDATA
|$T43913| DCD	|$LN22@WriteData2|
	DCD	0x40008604
; Function compile flags: /Odtp

  02584			 AREA	 |.text|, CODE, ARM

  02584		 |WriteData2| PROC

; 543  : {

  02584		 |$LN22@WriteData2|
  02584	e1a0c00d	 mov         r12, sp
  02588	e92d000f	 stmdb       sp!, {r0 - r3}
  0258c	e92d5000	 stmdb       sp!, {r12, lr}
  02590	e24dd024	 sub         sp, sp, #0x24
  02594		 |$M43910|

; 544  :     UINT32 size = 0;

  02594	e3a03000	 mov         r3, #0
  02598	e58d3008	 str         r3, [sp, #8]

; 545  :     UINT32 code;
; 546  :     UINT8 bits;
; 547  : 
; 548  :     // Set flash memory to write mode
; 549  :     WriteCommand(pInfo, base, 0x555, 0xAA);

  0259c	e3a030aa	 mov         r3, #0xAA
  025a0	e3a02c05	 mov         r2, #5, 24
  025a4	e3822055	 orr         r2, r2, #0x55
  025a8	e59d1030	 ldr         r1, [sp, #0x30]
  025ac	e59d002c	 ldr         r0, [sp, #0x2C]
  025b0	eb000000	 bl          WriteCommand

; 550  :     WriteCommand(pInfo, base, 0x2AA, 0x55);

  025b4	e3a03055	 mov         r3, #0x55
  025b8	e3a02c02	 mov         r2, #2, 24
  025bc	e38220aa	 orr         r2, r2, #0xAA
  025c0	e59d1030	 ldr         r1, [sp, #0x30]
  025c4	e59d002c	 ldr         r0, [sp, #0x2C]
  025c8	eb000000	 bl          WriteCommand

; 551  :     WriteCommand(pInfo, base, 0x555, 0xA0);

  025cc	e3a030a0	 mov         r3, #0xA0
  025d0	e3a02c05	 mov         r2, #5, 24
  025d4	e3822055	 orr         r2, r2, #0x55
  025d8	e59d1030	 ldr         r1, [sp, #0x30]
  025dc	e59d002c	 ldr         r0, [sp, #0x2C]
  025e0	eb000000	 bl          WriteCommand

; 552  : 
; 553  :     // Now write info and wait until it is done
; 554  :     switch (pInfo->width)

  025e4	e59d302c	 ldr         r3, [sp, #0x2C]
  025e8	e5933000	 ldr         r3, [r3]
  025ec	e58d3010	 str         r3, [sp, #0x10]
  025f0	e59d3010	 ldr         r3, [sp, #0x10]
  025f4	e3530001	 cmp         r3, #1
  025f8	0a000044	 beq         |$LN5@WriteData2|
  025fc	e59d3010	 ldr         r3, [sp, #0x10]
  02600	e3530002	 cmp         r3, #2
  02604	0a000021	 beq         |$LN10@WriteData2|
  02608	e59d3010	 ldr         r3, [sp, #0x10]
  0260c	e3530004	 cmp         r3, #4
  02610	0a000000	 beq         |$LN15@WriteData2|
  02614	ea00005a	 b           |$LN16@WriteData2|
  02618		 |$LN15@WriteData2|

; 555  :         {
; 556  :         case 4:
; 557  :             OUTREG32((UINT32*)pos, *(UINT32*)pBuffer);

  02618	e59d3038	 ldr         r3, [sp, #0x38]
  0261c	e5931000	 ldr         r1, [r3]
  02620	e59d0034	 ldr         r0, [sp, #0x34]
  02624	eb000000	 bl          WRITE_REGISTER_ULONG
  02628		 |$LN14@WriteData2|

; 558  :             while (TRUE)
; 559  :                 {
; 560  :                 bits = BitsAnd(pInfo, pos, 0);

  02628	e3a02000	 mov         r2, #0
  0262c	e59d1034	 ldr         r1, [sp, #0x34]
  02630	e59d002c	 ldr         r0, [sp, #0x2C]
  02634	eb000000	 bl          BitsAnd
  02638	e5cd0014	 strb        r0, [sp, #0x14]
  0263c	e5dd3014	 ldrb        r3, [sp, #0x14]
  02640	e5cd3004	 strb        r3, [sp, #4]

; 561  :                 if ((bits & (1 << 5)) == 0) continue;

  02644	e5dd3004	 ldrb        r3, [sp, #4]
  02648	e3130020	 tst         r3, #0x20
  0264c	1a000000	 bne         |$LN12@WriteData2|
  02650	eafffff4	 b           |$LN14@WriteData2|
  02654		 |$LN12@WriteData2|

; 562  :                 code = INREG32((UINT32*)pos);

  02654	e59d0034	 ldr         r0, [sp, #0x34]
  02658	eb000000	 bl          READ_REGISTER_ULONG
  0265c	e58d0018	 str         r0, [sp, #0x18]
  02660	e59d3018	 ldr         r3, [sp, #0x18]
  02664	e58d3000	 str         r3, [sp]

; 563  :                 break;

  02668	ea000000	 b           |$LN13@WriteData2|

; 564  :                 }

  0266c	eaffffed	 b           |$LN14@WriteData2|
  02670		 |$LN13@WriteData2|

; 565  :             if (code == *(UINT32*)pBuffer) size = sizeof(UINT32);

  02670	e59d2000	 ldr         r2, [sp]
  02674	e59d3038	 ldr         r3, [sp, #0x38]
  02678	e5933000	 ldr         r3, [r3]
  0267c	e1520003	 cmp         r2, r3
  02680	1a000001	 bne         |$LN11@WriteData2|
  02684	e3a03004	 mov         r3, #4
  02688	e58d3008	 str         r3, [sp, #8]
  0268c		 |$LN11@WriteData2|

; 566  :             break;

  0268c	ea00003c	 b           |$LN16@WriteData2|
  02690		 |$LN10@WriteData2|

; 567  :         case 2:
; 568  :             OUTREG16((UINT16*)pos, *(UINT16*)pBuffer);

  02690	e59d3038	 ldr         r3, [sp, #0x38]
  02694	e1d310b0	 ldrh        r1, [r3]
  02698	e59d0034	 ldr         r0, [sp, #0x34]
  0269c	eb000000	 bl          WRITE_REGISTER_USHORT
  026a0		 |$LN9@WriteData2|

; 569  :             while (TRUE)
; 570  :                 {
; 571  :                 bits = BitsAnd(pInfo, pos, 0);

  026a0	e3a02000	 mov         r2, #0
  026a4	e59d1034	 ldr         r1, [sp, #0x34]
  026a8	e59d002c	 ldr         r0, [sp, #0x2C]
  026ac	eb000000	 bl          BitsAnd
  026b0	e5cd001c	 strb        r0, [sp, #0x1C]
  026b4	e5dd301c	 ldrb        r3, [sp, #0x1C]
  026b8	e5cd3004	 strb        r3, [sp, #4]

; 572  :                 if ((bits & (1 << 5)) == 0) continue;

  026bc	e5dd3004	 ldrb        r3, [sp, #4]
  026c0	e3130020	 tst         r3, #0x20
  026c4	1a000000	 bne         |$LN7@WriteData2|
  026c8	eafffff4	 b           |$LN9@WriteData2|
  026cc		 |$LN7@WriteData2|

; 573  :                 code = INREG16((UINT16*)pos);

  026cc	e59d0034	 ldr         r0, [sp, #0x34]
  026d0	eb000000	 bl          READ_REGISTER_USHORT
  026d4	e1a03800	 mov         r3, r0, lsl #16
  026d8	e1a03823	 mov         r3, r3, lsr #16
  026dc	e1cd31be	 strh        r3, [sp, #0x1E]
  026e0	e1dd31be	 ldrh        r3, [sp, #0x1E]
  026e4	e58d3000	 str         r3, [sp]

; 574  :                 break;

  026e8	ea000000	 b           |$LN8@WriteData2|

; 575  :                 }

  026ec	eaffffeb	 b           |$LN9@WriteData2|
  026f0		 |$LN8@WriteData2|

; 576  :             if (code == *(UINT16*)pBuffer) size = sizeof(UINT16);

  026f0	e59d3038	 ldr         r3, [sp, #0x38]
  026f4	e1d320b0	 ldrh        r2, [r3]
  026f8	e59d3000	 ldr         r3, [sp]
  026fc	e1530002	 cmp         r3, r2
  02700	1a000001	 bne         |$LN6@WriteData2|
  02704	e3a03002	 mov         r3, #2
  02708	e58d3008	 str         r3, [sp, #8]
  0270c		 |$LN6@WriteData2|

; 577  :             break;

  0270c	ea00001c	 b           |$LN16@WriteData2|
  02710		 |$LN5@WriteData2|

; 578  :         case 1:
; 579  :             OUTREG8((UINT8*)pos, *(UINT8*)pBuffer);

  02710	e59d3038	 ldr         r3, [sp, #0x38]
  02714	e5d31000	 ldrb        r1, [r3]
  02718	e59d0034	 ldr         r0, [sp, #0x34]
  0271c	eb000000	 bl          WRITE_REGISTER_UCHAR
  02720		 |$LN4@WriteData2|

; 580  :             while (TRUE)
; 581  :                 {
; 582  :                 bits = BitsAnd(pInfo, pos, 0);

  02720	e3a02000	 mov         r2, #0
  02724	e59d1034	 ldr         r1, [sp, #0x34]
  02728	e59d002c	 ldr         r0, [sp, #0x2C]
  0272c	eb000000	 bl          BitsAnd
  02730	e5cd0020	 strb        r0, [sp, #0x20]
  02734	e5dd3020	 ldrb        r3, [sp, #0x20]
  02738	e5cd3004	 strb        r3, [sp, #4]

; 583  :                 if ((bits & (1 << 5)) == 0) continue;

  0273c	e5dd3004	 ldrb        r3, [sp, #4]
  02740	e3130020	 tst         r3, #0x20
  02744	1a000000	 bne         |$LN2@WriteData2|
  02748	eafffff4	 b           |$LN4@WriteData2|
  0274c		 |$LN2@WriteData2|

; 584  :                 code = INREG8((UINT8*)pos);

  0274c	e59d0034	 ldr         r0, [sp, #0x34]
  02750	eb000000	 bl          READ_REGISTER_UCHAR
  02754	e5cd0021	 strb        r0, [sp, #0x21]
  02758	e5dd3021	 ldrb        r3, [sp, #0x21]
  0275c	e58d3000	 str         r3, [sp]

; 585  :                 break;

  02760	ea000000	 b           |$LN3@WriteData2|

; 586  :                 }

  02764	eaffffed	 b           |$LN4@WriteData2|
  02768		 |$LN3@WriteData2|

; 587  :             if (code == *(UINT8*)pBuffer) size = sizeof(UINT8);

  02768	e59d3038	 ldr         r3, [sp, #0x38]
  0276c	e5d32000	 ldrb        r2, [r3]
  02770	e59d3000	 ldr         r3, [sp]
  02774	e1530002	 cmp         r3, r2
  02778	1a000001	 bne         |$LN1@WriteData2|
  0277c	e3a03001	 mov         r3, #1
  02780	e58d3008	 str         r3, [sp, #8]
  02784		 |$LN1@WriteData2|
  02784		 |$LN16@WriteData2|

; 588  :             break;
; 589  :         }
; 590  : 
; 591  :     return size;

  02784	e59d3008	 ldr         r3, [sp, #8]
  02788	e58d300c	 str         r3, [sp, #0xC]

; 592  : }

  0278c	e59d000c	 ldr         r0, [sp, #0xC]
  02790	e28dd024	 add         sp, sp, #0x24
  02794	e89d6000	 ldmia       sp, {sp, lr}
  02798	e12fff1e	 bx          lr
  0279c		 |$M43911|

			 ENDP  ; |WriteData2|

	EXPORT	|OALFlashLockDown|

  000a8			 AREA	 |.pdata|, PDATA
|$T43919| DCD	|$LN20@OALFlashLo@2|
	DCD	0x40008704
; Function compile flags: /Odtp

  0279c			 AREA	 |.text|, CODE, ARM

  0279c		 |OALFlashLockDown| PROC

; 1281 : {

  0279c		 |$LN20@OALFlashLo@2|
  0279c	e1a0c00d	 mov         r12, sp
  027a0	e92d0007	 stmdb       sp!, {r0 - r2}
  027a4	e92d5000	 stmdb       sp!, {r12, lr}
  027a8	e24dd094	 sub         sp, sp, #0x94
  027ac		 |$M43916|

; 1282 :     BOOL rc = FALSE;

  027ac	e3a03000	 mov         r3, #0
  027b0	e58d3000	 str         r3, [sp]

; 1283 :     OAL_FLASH_INFO info;
; 1284 :     UINT32 base = (UINT32)pBase;

  027b4	e59d309c	 ldr         r3, [sp, #0x9C]
  027b8	e58d3004	 str         r3, [sp, #4]

; 1285 :     UINT32 start = (UINT32)pStart;

  027bc	e59d30a0	 ldr         r3, [sp, #0xA0]
  027c0	e58d3010	 str         r3, [sp, #0x10]

; 1286 :     UINT32 end = start + size;

  027c4	e59d2010	 ldr         r2, [sp, #0x10]
  027c8	e59d30a4	 ldr         r3, [sp, #0xA4]
  027cc	e0823003	 add         r3, r2, r3
  027d0	e58d300c	 str         r3, [sp, #0xC]

; 1287 :     UINT32 chip, blockStart, blockEnd;
; 1288 :     UINT32 region, block;
; 1289 : 
; 1290 : 
; 1291 :     // Ther read first chip info
; 1292 :     if (!OALFlashInfo((VOID*)base, &info))

  027d4	e28d101c	 add         r1, sp, #0x1C
  027d8	e59d0004	 ldr         r0, [sp, #4]
  027dc	eb000000	 bl          OALFlashInfo
  027e0	e58d0080	 str         r0, [sp, #0x80]
  027e4	e59d3080	 ldr         r3, [sp, #0x80]
  027e8	e3530000	 cmp         r3, #0
  027ec	1a000000	 bne         |$LN15@OALFlashLo@2|

; 1293 :         {
; 1294 :             goto cleanUp;

  027f0	ea00006a	 b           |$cleanUp$43670|
  027f4		 |$LN15@OALFlashLo@2|

; 1295 :         }
; 1296 : 
; 1297 :     region = block = 0;

  027f4	e3a03000	 mov         r3, #0
  027f8	e58d3078	 str         r3, [sp, #0x78]
  027fc	e59d3078	 ldr         r3, [sp, #0x78]
  02800	e58d3008	 str         r3, [sp, #8]

; 1298 :     blockStart = chip = base;

  02804	e59d3004	 ldr         r3, [sp, #4]
  02808	e58d3018	 str         r3, [sp, #0x18]
  0280c	e59d3018	 ldr         r3, [sp, #0x18]
  02810	e58d3074	 str         r3, [sp, #0x74]
  02814		 |$LN14@OALFlashLo@2|

; 1299 :     while (blockStart < end)

  02814	e59d2074	 ldr         r2, [sp, #0x74]
  02818	e59d300c	 ldr         r3, [sp, #0xC]
  0281c	e1520003	 cmp         r2, r3
  02820	2a00005c	 bcs         |$LN13@OALFlashLo@2|

; 1300 :         {
; 1301 : 
; 1302 :         // Block end (+1)
; 1303 :         blockEnd = blockStart + info.aBlockSize[region] * info.parallel;

  02824	e59d1008	 ldr         r1, [sp, #8]
  02828	e3a03004	 mov         r3, #4
  0282c	e0020391	 mul         r2, r1, r3
  02830	e28d3034	 add         r3, sp, #0x34
  02834	e0833002	 add         r3, r3, r2
  02838	e5931000	 ldr         r1, [r3]
  0283c	e59d3020	 ldr         r3, [sp, #0x20]
  02840	e0020391	 mul         r2, r1, r3
  02844	e59d3074	 ldr         r3, [sp, #0x74]
  02848	e0833002	 add         r3, r3, r2
  0284c	e58d3014	 str         r3, [sp, #0x14]

; 1304 : 
; 1305 :         // Should block be erased?
; 1306 :         if (start < blockEnd && end >= blockStart)

  02850	e59d2010	 ldr         r2, [sp, #0x10]
  02854	e59d3014	 ldr         r3, [sp, #0x14]
  02858	e1520003	 cmp         r2, r3
  0285c	2a000024	 bcs         |$LN12@OALFlashLo@2|
  02860	e59d200c	 ldr         r2, [sp, #0xC]
  02864	e59d3074	 ldr         r3, [sp, #0x74]
  02868	e1520003	 cmp         r2, r3
  0286c	3a000020	 bcc         |$LN12@OALFlashLo@2|

; 1307 :             {
; 1308 :             switch (info.set)

  02870	e59d3024	 ldr         r3, [sp, #0x24]
  02874	e58d3084	 str         r3, [sp, #0x84]
  02878	e59d3084	 ldr         r3, [sp, #0x84]
  0287c	e3530001	 cmp         r3, #1
  02880	0a000006	 beq         |$LN9@OALFlashLo@2|
  02884	e59d3084	 ldr         r3, [sp, #0x84]
  02888	e3530002	 cmp         r3, #2
  0288c	0a00000d	 beq         |$LN7@OALFlashLo@2|
  02890	e59d3084	 ldr         r3, [sp, #0x84]
  02894	e3530003	 cmp         r3, #3
  02898	0a000000	 beq         |$LN9@OALFlashLo@2|
  0289c	ea000013	 b           |$LN5@OALFlashLo@2|
  028a0		 |$LN9@OALFlashLo@2|

; 1309 :                 {
; 1310 : 
; 1311 : #ifndef OAL_FLASH_NO_COMMAND_SET_1
; 1312 :                 case 1: // Intel/Sharp
; 1313 :                 case 3:
; 1314 :                     if (!LockDownBlock1(&info, chip, blockStart))

  028a0	e59d2074	 ldr         r2, [sp, #0x74]
  028a4	e59d1018	 ldr         r1, [sp, #0x18]
  028a8	e28d001c	 add         r0, sp, #0x1C
  028ac	eb000000	 bl          LockDownBlock1
  028b0	e58d0088	 str         r0, [sp, #0x88]
  028b4	e59d3088	 ldr         r3, [sp, #0x88]
  028b8	e3530000	 cmp         r3, #0
  028bc	1a000000	 bne         |$LN8@OALFlashLo@2|

; 1315 :                         {
; 1316 :                         goto cleanUp;

  028c0	ea000036	 b           |$cleanUp$43670|
  028c4		 |$LN8@OALFlashLo@2|

; 1317 :                         }
; 1318 :                     break;

  028c4	ea00000a	 b           |$LN10@OALFlashLo@2|
  028c8		 |$LN7@OALFlashLo@2|

; 1319 : #endif OAL_FLASH_NO_COMMAND_SET_1
; 1320 : 
; 1321 : #ifndef OAL_FLASH_NO_COMMAND_SET_2
; 1322 :                 case 2: // AMD
; 1323 :                     if (!LockDownBlock2(&info, chip, blockStart))

  028c8	e59d2074	 ldr         r2, [sp, #0x74]
  028cc	e59d1018	 ldr         r1, [sp, #0x18]
  028d0	e28d001c	 add         r0, sp, #0x1C
  028d4	eb000000	 bl          LockDownBlock2
  028d8	e58d008c	 str         r0, [sp, #0x8C]
  028dc	e59d308c	 ldr         r3, [sp, #0x8C]
  028e0	e3530000	 cmp         r3, #0
  028e4	1a000000	 bne         |$LN6@OALFlashLo@2|

; 1324 :                         {
; 1325 :                         goto cleanUp;

  028e8	ea00002c	 b           |$cleanUp$43670|
  028ec		 |$LN6@OALFlashLo@2|

; 1326 :                         }                    
; 1327 :                     break;

  028ec	ea000000	 b           |$LN10@OALFlashLo@2|
  028f0		 |$LN5@OALFlashLo@2|

; 1328 : #endif OAL_FLASH_NO_COMMAND_SET_2
; 1329 : 
; 1330 :                 default:
; 1331 :                     goto cleanUp;

  028f0	ea00002a	 b           |$cleanUp$43670|
  028f4		 |$LN10@OALFlashLo@2|
  028f4		 |$LN12@OALFlashLo@2|

; 1332 :                 }
; 1333 :             }         
; 1334 : 
; 1335 :         // Move to next block
; 1336 :         blockStart = blockEnd;

  028f4	e59d3014	 ldr         r3, [sp, #0x14]
  028f8	e58d3074	 str         r3, [sp, #0x74]

; 1337 :         if (blockStart >= end) break;

  028fc	e59d2074	 ldr         r2, [sp, #0x74]
  02900	e59d300c	 ldr         r3, [sp, #0xC]
  02904	e1520003	 cmp         r2, r3
  02908	3a000000	 bcc         |$LN4@OALFlashLo@2|
  0290c	ea000021	 b           |$LN13@OALFlashLo@2|
  02910		 |$LN4@OALFlashLo@2|

; 1338 :         if (++block >= info.aBlocks[region])

  02910	e59d3078	 ldr         r3, [sp, #0x78]
  02914	e2833001	 add         r3, r3, #1
  02918	e58d3078	 str         r3, [sp, #0x78]
  0291c	e59d1008	 ldr         r1, [sp, #8]
  02920	e3a03004	 mov         r3, #4
  02924	e0020391	 mul         r2, r1, r3
  02928	e28d3054	 add         r3, sp, #0x54
  0292c	e0833002	 add         r3, r3, r2
  02930	e59d2078	 ldr         r2, [sp, #0x78]
  02934	e5933000	 ldr         r3, [r3]
  02938	e1520003	 cmp         r2, r3
  0293c	3a000014	 bcc         |$LN3@OALFlashLo@2|

; 1339 :             {
; 1340 :             block = 0;

  02940	e3a03000	 mov         r3, #0
  02944	e58d3078	 str         r3, [sp, #0x78]

; 1341 :             if (++region >= info.regions)

  02948	e59d3008	 ldr         r3, [sp, #8]
  0294c	e2833001	 add         r3, r3, #1
  02950	e58d3008	 str         r3, [sp, #8]
  02954	e59d2008	 ldr         r2, [sp, #8]
  02958	e59d3030	 ldr         r3, [sp, #0x30]
  0295c	e1520003	 cmp         r2, r3
  02960	3a00000b	 bcc         |$LN2@OALFlashLo@2|

; 1342 :                 {
; 1343 :                 // Try read next chip info
; 1344 :                 if (!OALFlashInfo((VOID*)block, &info)) break;

  02964	e28d101c	 add         r1, sp, #0x1C
  02968	e59d0078	 ldr         r0, [sp, #0x78]
  0296c	eb000000	 bl          OALFlashInfo
  02970	e58d0090	 str         r0, [sp, #0x90]
  02974	e59d3090	 ldr         r3, [sp, #0x90]
  02978	e3530000	 cmp         r3, #0
  0297c	1a000000	 bne         |$LN1@OALFlashLo@2|
  02980	ea000004	 b           |$LN13@OALFlashLo@2|
  02984		 |$LN1@OALFlashLo@2|

; 1345 :                 region = 0;

  02984	e3a03000	 mov         r3, #0
  02988	e58d3008	 str         r3, [sp, #8]

; 1346 :                 chip = block;

  0298c	e59d3078	 ldr         r3, [sp, #0x78]
  02990	e58d3018	 str         r3, [sp, #0x18]
  02994		 |$LN2@OALFlashLo@2|
  02994		 |$LN3@OALFlashLo@2|

; 1347 :                 }
; 1348 :             }
; 1349 :         }

  02994	eaffff9e	 b           |$LN14@OALFlashLo@2|
  02998		 |$LN13@OALFlashLo@2|

; 1350 : 
; 1351 :     rc = TRUE;

  02998	e3a03001	 mov         r3, #1
  0299c	e58d3000	 str         r3, [sp]
  029a0		 |$cleanUp$43670|

; 1352 :    
; 1353 : cleanUp:
; 1354 :     return rc;

  029a0	e59d3000	 ldr         r3, [sp]
  029a4	e58d307c	 str         r3, [sp, #0x7C]

; 1355 : }

  029a8	e59d007c	 ldr         r0, [sp, #0x7C]
  029ac	e28dd094	 add         sp, sp, #0x94
  029b0	e89d6000	 ldmia       sp, {sp, lr}
  029b4	e12fff1e	 bx          lr
  029b8		 |$M43917|

			 ENDP  ; |OALFlashLockDown|


  000b0			 AREA	 |.pdata|, PDATA
|$T43927| DCD	|$LN7@LockDownBl|
	DCD	0x40002d04
; Function compile flags: /Odtp

  029b8			 AREA	 |.text|, CODE, ARM

  029b8		 |LockDownBlock1| PROC

; 292  : {

  029b8		 |$LN7@LockDownBl|
  029b8	e1a0c00d	 mov         r12, sp
  029bc	e92d0007	 stmdb       sp!, {r0 - r2}
  029c0	e92d5000	 stmdb       sp!, {r12, lr}
  029c4	e24dd010	 sub         sp, sp, #0x10
  029c8		 |$M43924|

; 293  :     UCHAR bits;
; 294  : 
; 295  :     // Set block lock-down
; 296  :     WriteCommand(pInfo, block, 0, 0x60);

  029c8	e3a03060	 mov         r3, #0x60
  029cc	e3a02000	 mov         r2, #0
  029d0	e59d1020	 ldr         r1, [sp, #0x20]
  029d4	e59d0018	 ldr         r0, [sp, #0x18]
  029d8	eb000000	 bl          WriteCommand

; 297  :     WriteCommand(pInfo, block, 0, 0x2F);

  029dc	e3a0302f	 mov         r3, #0x2F
  029e0	e3a02000	 mov         r2, #0
  029e4	e59d1020	 ldr         r1, [sp, #0x20]
  029e8	e59d0018	 ldr         r0, [sp, #0x18]
  029ec	eb000000	 bl          WriteCommand

; 298  : 
; 299  :     // Verify it is correct
; 300  :     WriteCommand(pInfo, block, 0x02, 0x90);

  029f0	e3a03090	 mov         r3, #0x90
  029f4	e3a02002	 mov         r2, #2
  029f8	e59d1020	 ldr         r1, [sp, #0x20]
  029fc	e59d0018	 ldr         r0, [sp, #0x18]
  02a00	eb000000	 bl          WriteCommand

; 301  :     bits = BitsAnd(pInfo, block, 0x02);

  02a04	e3a02002	 mov         r2, #2
  02a08	e59d1020	 ldr         r1, [sp, #0x20]
  02a0c	e59d0018	 ldr         r0, [sp, #0x18]
  02a10	eb000000	 bl          BitsAnd
  02a14	e5cd0008	 strb        r0, [sp, #8]
  02a18	e5dd3008	 ldrb        r3, [sp, #8]
  02a1c	e5cd3000	 strb        r3, [sp]

; 302  :     
; 303  :     // Reset memory back to normal state
; 304  :     WriteCommand(pInfo, block, 0, 0xFF);

  02a20	e3a030ff	 mov         r3, #0xFF
  02a24	e3a02000	 mov         r2, #0
  02a28	e59d1020	 ldr         r1, [sp, #0x20]
  02a2c	e59d0018	 ldr         r0, [sp, #0x18]
  02a30	eb000000	 bl          WriteCommand

; 305  : 
; 306  :     return ((bits & (1 << 1)) != 0);

  02a34	e5dd3000	 ldrb        r3, [sp]
  02a38	e3130002	 tst         r3, #2
  02a3c	0a000002	 beq         |$LN3@LockDownBl|
  02a40	e3a03001	 mov         r3, #1
  02a44	e58d300c	 str         r3, [sp, #0xC]
  02a48	ea000001	 b           |$LN4@LockDownBl|
  02a4c		 |$LN3@LockDownBl|
  02a4c	e3a03000	 mov         r3, #0
  02a50	e58d300c	 str         r3, [sp, #0xC]
  02a54		 |$LN4@LockDownBl|
  02a54	e59d300c	 ldr         r3, [sp, #0xC]
  02a58	e58d3004	 str         r3, [sp, #4]

; 307  : }

  02a5c	e59d0004	 ldr         r0, [sp, #4]
  02a60	e28dd010	 add         sp, sp, #0x10
  02a64	e89d6000	 ldmia       sp, {sp, lr}
  02a68	e12fff1e	 bx          lr
  02a6c		 |$M43925|

			 ENDP  ; |LockDownBlock1|


  000b8			 AREA	 |.pdata|, PDATA
|$T43933| DCD	|$LN5@LockDownBl@2|
	DCD	0x40000a04
; Function compile flags: /Odtp

  02a6c			 AREA	 |.text|, CODE, ARM

  02a6c		 |LockDownBlock2| PROC

; 470  : {

  02a6c		 |$LN5@LockDownBl@2|
  02a6c	e1a0c00d	 mov         r12, sp
  02a70	e92d0007	 stmdb       sp!, {r0 - r2}
  02a74	e92d5000	 stmdb       sp!, {r12, lr}
  02a78	e24dd004	 sub         sp, sp, #4
  02a7c		 |$M43930|

; 471  :     return TRUE;

  02a7c	e3a03001	 mov         r3, #1
  02a80	e58d3000	 str         r3, [sp]

; 472  : }

  02a84	e59d0000	 ldr         r0, [sp]
  02a88	e28dd004	 add         sp, sp, #4
  02a8c	e89d6000	 ldmia       sp, {sp, lr}
  02a90	e12fff1e	 bx          lr
  02a94		 |$M43931|

			 ENDP  ; |LockDownBlock2|

	END
