; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\Z2170P\SRC\OAL\OALLIB\opp_map.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|Vdd1_init_val_35xx| [ DATA ]
	EXPORT	|Vdd1_init_val_37xx| [ DATA ]
	EXPORT	|_rgSr1ErrConfig_v1| [ DATA ]
	EXPORT	|_rgSr1ErrConfig_v2| [ DATA ]
	EXPORT	|_rgSr2ErrConfig_v1| [ DATA ]
	EXPORT	|_rgSr2ErrConfig_v2| [ DATA ]
	EXPORT	|_SR_driver_data_35xx| [ DATA ]
	EXPORT	|_SR_driver_data_37xx| [ DATA ]

  00000			 AREA	 |.data|, DATA
	 COMMON	|SmartReflex_funcs|, 0x4


  00000			 AREA	 |.bss|, NOINIT
|_rgSmartReflexInfo| % 0x38
|_Max_Vdd1_OPP| % 0x4

  00000			 AREA	 |.data|, DATA
|Vdd1_init_val_35xx| DCD 0xffffffff
	DCD	0x0
	DCD	0x1
	DCD	0x2
	DCD	0x3
	DCD	0x4
	DCD	0x5
|Vdd1_init_val_37xx| DCD 0xffffffff
	DCD	0x0
	DCD	0x1
	DCD	0x2
	DCD	0x3
|vdd1Opp0Info| DCD 0x0
	DCD	0x82
	%	16
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x2
	DCD	0x0
	DCD	0x0					; 0
	DCD	0xffffffff
	DCD	0x0
	DCD	0x0
	DCD	0x1
	DCD	0x1
	DCD	0x0					; 0
	DCD	0xffffffff
	DCD	0x0
	DCD	0x0
	DCD	0x1
|vdd1Opp1Info| DCD 0x0
	DCD	0x82
	%	16
	DCD	0x0
	DCD	0x1e
	DCD	0x1e
	DCD	0x2
	DCD	0x0
	DCD	0x42fa0000				; 125
	DCD	0xfa
	DCD	0xc
	DCD	0x7
	DCD	0x4
	DCD	0x1
	DCD	0x42b40000				; 90
	DCD	0xb4
	DCD	0xc
	DCD	0x7
	DCD	0x4
|vdd1Opp2Info| DCD 0x0
	DCD	0x82
	%	16
	DCD	0x0
	DCD	0x24
	DCD	0x24
	DCD	0x2
	DCD	0x0
	DCD	0x437a0000				; 250
	DCD	0xfa
	DCD	0xc
	DCD	0x7
	DCD	0x2
	DCD	0x1
	DCD	0x43340000				; 180
	DCD	0xb4
	DCD	0xc
	DCD	0x7
	DCD	0x2
|vdd1Opp3Info| DCD 0x0
	DCD	0x82
	%	16
	DCD	0x0
	DCD	0x30
	DCD	0x30
	DCD	0x2
	DCD	0x0
	DCD	0x43fa0000				; 500
	DCD	0xfa
	DCD	0xc
	DCD	0x7
	DCD	0x1
	DCD	0x1
	DCD	0x43b40000				; 360
	DCD	0xb4
	DCD	0xc
	DCD	0x7
	DCD	0x1
|vdd1Opp4Info| DCD 0x0
	DCD	0x82
	%	16
	DCD	0x0
	DCD	0x35
	DCD	0x35
	DCD	0x2
	DCD	0x0
	DCD	0x44098000				; 550
	DCD	0x113
	DCD	0xc
	DCD	0x7
	DCD	0x1
	DCD	0x1
	DCD	0x43c60000				; 396
	DCD	0xc8
	DCD	0xc
	DCD	0x7
	DCD	0x1
|vdd1Opp5Info| DCD 0x0
	DCD	0x82
	%	16
	DCD	0x0
	DCD	0x3c
	DCD	0x3c
	DCD	0x2
	DCD	0x0
	DCD	0x44160000				; 600
	DCD	0x12c
	DCD	0xc
	DCD	0x7
	DCD	0x1
	DCD	0x1
	DCD	0x43d70000				; 430
	DCD	0xd7
	DCD	0xc
	DCD	0x7
	DCD	0x1
|vdd1Opp6Info| DCD 0x0
	DCD	0x82
	%	16
	DCD	0x0
	DCD	0x3c
	DCD	0x3c
	DCD	0x2
	DCD	0x0
	DCD	0x44340000				; 720
	DCD	0x168
	DCD	0xc
	DCD	0x7
	DCD	0x1
	DCD	0x1
	DCD	0x44020000				; 520
	DCD	0x104
	DCD	0xc
	DCD	0x7
	DCD	0x1
|vdd2Opp0Info| DCD 0x1
	DCD	0x82
	%	16
	DCD	0x1
	DCD	0x0
	DCD	0x0
	DCD	0x1
	DCD	0x2
	DCD	0x0					; 0
	DCD	0xffffffff
	DCD	0x0
	DCD	0x0
	DCD	0x0
|vdd2Opp1Info| DCD 0x1
	DCD	0x82
	%	16
	DCD	0x1
	DCD	0x24
	DCD	0x24
	DCD	0x1
	DCD	0x2
	DCD	0x43260000				; 166
	DCD	0xa6
	DCD	0xc
	DCD	0x7
	DCD	0x2
|vdd2Opp2Info| DCD 0x1
	DCD	0x82
	%	16
	DCD	0x1
	DCD	0x2c
	DCD	0x2c
	DCD	0x1
	DCD	0x2
	DCD	0x43a60000				; 332
	DCD	0xa6
	DCD	0xc
	DCD	0x7
	DCD	0x1
|_rgVdd1OppMap| DCD |vdd1Opp1Info|
	DCD	|vdd1Opp2Info|
	DCD	|vdd1Opp3Info|
	DCD	|vdd1Opp4Info|
	DCD	|vdd1Opp5Info|
	DCD	|vdd1Opp6Info|
|_rgVdd2OppMap| DCD |vdd2Opp1Info|
	DCD	|vdd2Opp2Info|
|vdd1Opp0Info_37x| DCD 0x0
	DCD	0x82
	%	16
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x2
	DCD	0x0
	DCD	0x0					; 0
	DCD	0xffffffff
	DCD	0x0
	DCD	0x0
	DCD	0x1
	DCD	0x1
	DCD	0x0					; 0
	DCD	0xffffffff
	DCD	0x0
	DCD	0x0
	DCD	0x1
|vdd1Opp1Info_37x| DCD 0x0
	DCD	0x82
	%	16
	DCD	0x0
	DCD	0x1b
	DCD	0x1b
	DCD	0x2
	DCD	0x0
	DCD	0x43960000				; 300
	DCD	0x96
	DCD	0xc
	DCD	0x0
	DCD	0x1
	DCD	0x1
	DCD	0x43820000				; 260
	DCD	0x82
	DCD	0xc
	DCD	0x0
	DCD	0x1
|vdd1Opp2Info_37x| DCD 0x0
	DCD	0x82
	%	16
	DCD	0x0
	DCD	0x28
	DCD	0x28
	DCD	0x2
	DCD	0x0
	DCD	0x44160000				; 600
	DCD	0x12c
	DCD	0xc
	DCD	0x0
	DCD	0x1
	DCD	0x1
	DCD	0x44020000				; 520
	DCD	0x104
	DCD	0xc
	DCD	0x0
	DCD	0x1
|vdd1Opp3Info_37x| DCD 0x0
	DCD	0x82
	%	16
	DCD	0x0
	DCD	0x35
	DCD	0x35
	DCD	0x2
	DCD	0x0
	DCD	0x44480000				; 800
	DCD	0x190
	DCD	0xc
	DCD	0x0
	DCD	0x1
	DCD	0x1
	DCD	0x44250000				; 660
	DCD	0x14a
	DCD	0xc
	DCD	0x0
	DCD	0x1
|vdd1Opp4Info_37x| DCD 0x0
	DCD	0x82
	%	16
	DCD	0x0
	DCD	0x3e
	DCD	0x3e
	DCD	0x2
	DCD	0x0
	DCD	0x447a0000				; 1000
	DCD	0x1f4
	DCD	0xc
	DCD	0x0
	DCD	0x1
	DCD	0x1
	DCD	0x44480000				; 800
	DCD	0x190
	DCD	0xc
	DCD	0x0
	DCD	0x1
|vdd2Opp0Info_37x| DCD 0x1
	DCD	0x82
	%	16
	DCD	0x1
	DCD	0x0
	DCD	0x0
	DCD	0x1
	DCD	0x2
	DCD	0x0					; 0
	DCD	0xffffffff
	DCD	0x0
	DCD	0x0
	DCD	0x0
|vdd2Opp1Info_37x| DCD 0x1
	DCD	0x82
	%	16
	DCD	0x1
	DCD	0x1b
	DCD	0x1b
	DCD	0x1
	DCD	0x2
	DCD	0x43480000				; 200
	DCD	0xc8
	DCD	0xc
	DCD	0x0
	DCD	0x2
|vdd2Opp2Info_37x| DCD 0x1
	DCD	0x82
	%	16
	DCD	0x1
	DCD	0x2b
	DCD	0x2b
	DCD	0x1
	DCD	0x2
	DCD	0x43c80000				; 400
	DCD	0xc8
	DCD	0xc
	DCD	0x0
	DCD	0x1
|_rgVdd1OppMap_37x| DCD |vdd1Opp1Info_37x|
	DCD	|vdd1Opp2Info_37x|
	DCD	|vdd1Opp3Info_37x|
	DCD	|vdd1Opp4Info_37x|
|_rgVdd2OppMap_37x| DCD |vdd2Opp1Info_37x|
	DCD	|vdd2Opp2Info_37x|
|_rgInitialRetentionVoltages| DCD 0x20
	DCD	0x20
|_rgVp1ErrConfig_v1| DCD 0xc
	DCD	0x0
	DCD	0xc
	DCD	0x0
	DCD	0x18
	DCD	0x0
	DCD	0x18
	DCD	0x0
	DCD	0x18
	DCD	0x0
|_rgVp1ErrConfig_v2| DCD 0xc
	DCD	0x0
	DCD	0x16
	DCD	0x0
	DCD	0x23
	DCD	0x0
	DCD	0x27
	DCD	0x0
|_rgVp2ErrConfig_v1| DCD 0xc
	DCD	0x0
	DCD	0x18
	DCD	0x0
|_rgVp2ErrConfig_v2| DCD 0xc
	DCD	0x0
	DCD	0x16
	DCD	0x0
|_rgSr1ErrConfig_v1| DCD 0x402f4
	DCD	0x402f4
	DCD	0x402f9
	DCD	0x402f9
	DCD	0x402f9
|_rgSr1ErrConfig_v2| DCD 0x402f4
	DCD	0x402f9
	DCD	0x402fa
	DCD	0x402fa
|_rgSr2ErrConfig_v1| DCD 0x402f4
	DCD	0x402f9
|_rgSr2ErrConfig_v2| DCD 0x402f4
	DCD	0x402f9
|omap37xx_sr1_test_nvalues| DCD 0x898beb
	DCD	0x999b83
	DCD	0xaac5a8
	DCD	0xaab197
|omap37xx_sr2_test_nvalues| DCD 0x898beb
	DCD	0x898beb
	DCD	0x9a8cee
|_SR_driver_data_35xx| DCD 0x1
	DCD	0x0
	DCD	|_rgSr1ErrConfig_v1|
	DCD	|_rgSr2ErrConfig_v1|
	DCD	|_rgVdd1OppMap|
	DCD	|_rgVdd2OppMap|
	DCD	|_rgVp1ErrConfig_v1|
	DCD	|_rgVp2ErrConfig_v1|
|_SR_driver_data_37xx| DCD 0x2
	DCD	0x0
	DCD	|_rgSr1ErrConfig_v2|
	DCD	|_rgSr2ErrConfig_v2|
	DCD	|_rgVdd1OppMap_37x|
	DCD	|_rgVdd2OppMap_37x|
	DCD	|_rgVp1ErrConfig_v2|
	DCD	|_rgVp2ErrConfig_v2|

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|SmartReflexLock|
	IMPORT	|EnterCriticalSection|
	IMPORT	|INTERRUPTS_STATUS|
; File c:\wince600\platform\z2170p\src\oal\oallib\opp_map.c

  00000			 AREA	 |.pdata|, PDATA
|$T47749| DCD	|$LN6@SmartRefle|
	DCD	0x40000e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SmartReflexLock| PROC

; 247  : {

  00000		 |$LN6@SmartRefle|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47746|

; 248  :     if (_rgSmartReflexInfo[channel].bInitialized && INTERRUPTS_STATUS()) 

  00004	e59f4028	 ldr         r4, [pc, #0x28]
  00008	e0605180	 rsb         r5, r0, r0, lsl #3
  0000c	e7943105	 ldr         r3, [r4, +r5, lsl #2]
  00010	e3530000	 cmp         r3, #0
  00014	0a000004	 beq         |$LN1@SmartRefle|
  00018	eb000000	 bl          INTERRUPTS_STATUS
  0001c	e3500000	 cmp         r0, #0

; 249  :         {
; 250  :         EnterCriticalSection(&_rgSmartReflexInfo[channel].cs);

  00020	12843008	 addne       r3, r4, #8
  00024	10830105	 addne       r0, r3, r5, lsl #2
  00028	1b000000	 blne        EnterCriticalSection
  0002c		 |$LN1@SmartRefle|

; 251  :         }
; 252  : }

  0002c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00030	e12fff1e	 bx          lr
  00034		 |$LN7@SmartRefle|
  00034		 |$LN8@SmartRefle|
  00034	00000000	 DCD         |_rgSmartReflexInfo|
  00038		 |$M47747|

			 ENDP  ; |SmartReflexLock|

	EXPORT	|SmartReflexUnlock|
	IMPORT	|LeaveCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T47759| DCD	|$LN6@SmartRefle@2|
	DCD	0x40000e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SmartReflexUnlock| PROC

; 258  : {

  00000		 |$LN6@SmartRefle@2|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47756|

; 259  :     if (_rgSmartReflexInfo[channel].bInitialized && INTERRUPTS_STATUS()) 

  00004	e59f4028	 ldr         r4, [pc, #0x28]
  00008	e0605180	 rsb         r5, r0, r0, lsl #3
  0000c	e7943105	 ldr         r3, [r4, +r5, lsl #2]
  00010	e3530000	 cmp         r3, #0
  00014	0a000004	 beq         |$LN1@SmartRefle@2|
  00018	eb000000	 bl          INTERRUPTS_STATUS
  0001c	e3500000	 cmp         r0, #0

; 260  :         {
; 261  :         LeaveCriticalSection(&_rgSmartReflexInfo[channel].cs);

  00020	12843008	 addne       r3, r4, #8
  00024	10830105	 addne       r0, r3, r5, lsl #2
  00028	1b000000	 blne        LeaveCriticalSection
  0002c		 |$LN1@SmartRefle@2|

; 262  :         }
; 263  : }

  0002c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00030	e12fff1e	 bx          lr
  00034		 |$LN7@SmartRefle@2|
  00034		 |$LN8@SmartRefle@2|
  00034	00000000	 DCD         |_rgSmartReflexInfo|
  00038		 |$M47757|

			 ENDP  ; |SmartReflexUnlock|

	EXPORT	|IsSmartReflexMonitoringEnabled|

  00000			 AREA	 |.pdata|, PDATA
|$T47771| DCD	|$LN5@IsSmartRef|
	DCD	0x40000600
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |IsSmartReflexMonitoringEnabled| PROC

; 268  : {   

  00000		 |$LN5@IsSmartRef|
  00000		 |$M47768|

; 269  :     return _rgSmartReflexInfo[channel].bEnabled;

  00000	e59f300c	 ldr         r3, [pc, #0xC]
  00004	e0602180	 rsb         r2, r0, r0, lsl #3
  00008	e2833004	 add         r3, r3, #4
  0000c	e7930102	 ldr         r0, [r3, +r2, lsl #2]

; 270  : }

  00010	e12fff1e	 bx          lr
  00014		 |$LN6@IsSmartRef|
  00014		 |$LN7@IsSmartRef|
  00014	00000000	 DCD         |_rgSmartReflexInfo|
  00018		 |$M47769|

			 ENDP  ; |IsSmartReflexMonitoringEnabled|

	EXPORT	|SmartReflex_dump_sensor_data|
	EXPORT	|??_C@_1FA@GPKMIFJB@?$AA?$AN?$AA?6?$AAS?$AAm?$AAa?$AAr?$AAt?$AAR?$AAe?$AAf?$AAl?$AAe?$AAx?$AA_?$AAd?$AAu?$AAm?$AAp?$AA_?$AAs?$AAe?$AAn?$AAs?$AAo?$AAr?$AA_?$AAd?$AAa?$AAt?$AAa?$AA?5?$AA?3@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CE@FNBKDMFJ@?$AAi?$AAd?$AAx?$AA?$DN?$AA?$CF?$AAd?$AA?7?$AA?5?$AAo?$AAp?$AAp?$AA?$DN?$AA?$CF?$AAx?$AA?5?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EM@KCFGIBMD@?$AAS?$AAm?$AAa?$AAr?$AAt?$AAR?$AAe?$AAf?$AAl?$AAe?$AAx?$AA_?$AAd?$AAu?$AAm?$AAp?$AA_?$AAs?$AAe?$AAn?$AAs?$AAo?$AAr?$AA_?$AAd?$AAa?$AAt?$AAa?$AA?5?$AA?3?$AA?5?$AAV@| [ DATA ] ; `string'
	IMPORT	|NKDbgPrintfW|

  00000			 AREA	 |.pdata|, PDATA
|$T47787| DCD	|$LN15@SmartRefle@3|
	DCD	0x40002201

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FA@GPKMIFJB@?$AA?$AN?$AA?6?$AAS?$AAm?$AAa?$AAr?$AAt?$AAR?$AAe?$AAf?$AAl?$AAe?$AAx?$AA_?$AAd?$AAu?$AAm?$AAp?$AA_?$AAs?$AAe?$AAn?$AAs?$AAo?$AAr?$AA_?$AAd?$AAa?$AAt?$AAa?$AA?5?$AA?3@| DCB 0xd
	DCB	0x0, 0xa, 0x0, "S", 0x0, "m", 0x0, "a", 0x0, "r", 0x0, "t"
	DCB	0x0, "R", 0x0, "e", 0x0, "f", 0x0, "l", 0x0, "e", 0x0, "x"
	DCB	0x0, "_", 0x0, "d", 0x0, "u", 0x0, "m", 0x0, "p", 0x0, "_"
	DCB	0x0, "s", 0x0, "e", 0x0, "n", 0x0, "s", 0x0, "o", 0x0, "r"
	DCB	0x0, "_", 0x0, "d", 0x0, "a", 0x0, "t", 0x0, "a", 0x0, " "
	DCB	0x0, ":", 0x0, " ", 0x0, "V", 0x0, "D", 0x0, "D", 0x0, "2"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CE@FNBKDMFJ@?$AAi?$AAd?$AAx?$AA?$DN?$AA?$CF?$AAd?$AA?7?$AA?5?$AAo?$AAp?$AAp?$AA?$DN?$AA?$CF?$AAx?$AA?5?$AA?$AN?$AA?6?$AA?$AA@| DCB "i"
	DCB	0x0, "d", 0x0, "x", 0x0, "=", 0x0, "%", 0x0, "d", 0x0, 0x9
	DCB	0x0, " ", 0x0, "o", 0x0, "p", 0x0, "p", 0x0, "=", 0x0, "%"
	DCB	0x0, "x", 0x0, " ", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EM@KCFGIBMD@?$AAS?$AAm?$AAa?$AAr?$AAt?$AAR?$AAe?$AAf?$AAl?$AAe?$AAx?$AA_?$AAd?$AAu?$AAm?$AAp?$AA_?$AAs?$AAe?$AAn?$AAs?$AAo?$AAr?$AA_?$AAd?$AAa?$AAt?$AAa?$AA?5?$AA?3?$AA?5?$AAV@| DCB "S"
	DCB	0x0, "m", 0x0, "a", 0x0, "r", 0x0, "t", 0x0, "R", 0x0, "e"
	DCB	0x0, "f", 0x0, "l", 0x0, "e", 0x0, "x", 0x0, "_", 0x0, "d"
	DCB	0x0, "u", 0x0, "m", 0x0, "p", 0x0, "_", 0x0, "s", 0x0, "e"
	DCB	0x0, "n", 0x0, "s", 0x0, "o", 0x0, "r", 0x0, "_", 0x0, "d"
	DCB	0x0, "a", 0x0, "t", 0x0, "a", 0x0, " ", 0x0, ":", 0x0, " "
	DCB	0x0, "V", 0x0, "D", 0x0, "D", 0x0, "1", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SmartReflex_dump_sensor_data| PROC

; 275  : {

  00000		 |$LN15@SmartRefle@3|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47784|
  00004	e1a05000	 mov         r5, r0

; 276  : #ifndef SHIP_BUILD
; 277  :     UINT8 idx;
; 278  : 
; 279  :     OALMSG(1, (L"SmartReflex_dump_sensor_data : VDD1\r\n"));

  00008	e59f0074	 ldr         r0, [pc, #0x74]
  0000c	eb000000	 bl          NKDbgPrintfW

; 280  : 
; 281  :     for(idx=0;idx<kOpp6;idx++)

  00010	e3a03000	 mov         r3, #0
  00014	e3a04000	 mov         r4, #0
  00018		 |$LL6@SmartRefle@3|

; 282  :     {
; 283  :         OALMSG(1, (L"idx=%d\t opp=%x \r\n", idx, pdata->Efuse_Vdd1_Opp[idx]));

  00018	e7952103	 ldr         r2, [r5, +r3, lsl #2]
  0001c	e59f0058	 ldr         r0, [pc, #0x58]
  00020	e1a01004	 mov         r1, r4
  00024	eb000000	 bl          NKDbgPrintfW
  00028	e2843001	 add         r3, r4, #1
  0002c	e20330ff	 and         r3, r3, #0xFF
  00030	e1a04003	 mov         r4, r3
  00034	e3530005	 cmp         r3, #5
  00038	3afffff6	 bcc         |$LL6@SmartRefle@3|

; 284  :     }
; 285  :     OALMSG(1, (L"\r\nSmartReflex_dump_sensor_data : VDD2\r\n"));

  0003c	e59f003c	 ldr         r0, [pc, #0x3C]
  00040	eb000000	 bl          NKDbgPrintfW

; 286  : 
; 287  :     for(idx = 0; idx<= kOpp3; idx++)

  00044	e3a03000	 mov         r3, #0
  00048	e3a04000	 mov         r4, #0
  0004c		 |$LL3@SmartRefle@3|

; 288  :     {
; 289  :         OALMSG(1, (L"idx=%d\t opp=%x \r\n", idx, pdata->Efuse_Vdd2_Opp[idx]));

  0004c	e0853103	 add         r3, r5, r3, lsl #2
  00050	e5932014	 ldr         r2, [r3, #0x14]
  00054	e59f0020	 ldr         r0, [pc, #0x20]
  00058	e1a01004	 mov         r1, r4
  0005c	eb000000	 bl          NKDbgPrintfW
  00060	e2843001	 add         r3, r4, #1
  00064	e20330ff	 and         r3, r3, #0xFF
  00068	e1a04003	 mov         r4, r3
  0006c	e3530002	 cmp         r3, #2
  00070	9afffff5	 bls         |$LL3@SmartRefle@3|

; 290  :     }
; 291  : #else
; 292  : 	UNREFERENCED_PARAMETER(pdata);
; 293  : #endif
; 294  : }

  00074	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00078	e12fff1e	 bx          lr
  0007c		 |$LN16@SmartRefle@3|
  0007c		 |$LN17@SmartRefle@3|
  0007c	00000000	 DCD         |??_C@_1CE@FNBKDMFJ@?$AAi?$AAd?$AAx?$AA?$DN?$AA?$CF?$AAd?$AA?7?$AA?5?$AAo?$AAp?$AAp?$AA?$DN?$AA?$CF?$AAx?$AA?5?$AA?$AN?$AA?6?$AA?$AA@|
  00080		 |$LN18@SmartRefle@3|
  00080	00000000	 DCD         |??_C@_1FA@GPKMIFJB@?$AA?$AN?$AA?6?$AAS?$AAm?$AAa?$AAr?$AAt?$AAR?$AAe?$AAf?$AAl?$AAe?$AAx?$AA_?$AAd?$AAu?$AAm?$AAp?$AA_?$AAs?$AAe?$AAn?$AAs?$AAo?$AAr?$AA_?$AAd?$AAa?$AAt?$AAa?$AA?5?$AA?3@|
  00084		 |$LN19@SmartRefle@3|
  00084	00000000	 DCD         |??_C@_1EM@KCFGIBMD@?$AAS?$AAm?$AAa?$AAr?$AAt?$AAR?$AAe?$AAf?$AAl?$AAe?$AAx?$AA_?$AAd?$AAu?$AAm?$AAp?$AA_?$AAs?$AAe?$AAn?$AAs?$AAo?$AAr?$AA_?$AAd?$AAa?$AAt?$AAa?$AA?5?$AA?3?$AA?5?$AAV@|
  00088		 |$M47785|

			 ENDP  ; |SmartReflex_dump_sensor_data|

	IMPORT	|__rt_udiv|

  00000			 AREA	 |.pdata|, PDATA
|$T47806| DCD	|$LN11@cal_recipr|
	DCD	0x40001201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cal_reciprocal| PROC

; 306  : {

  00000		 |$LN11@cal_recipr|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M47803|
  00004	e1a05002	 mov         r5, r2
  00008	e1a06001	 mov         r6, r1
  0000c	e1a07000	 mov         r7, r0

; 307  : 	UINT32 gn, rn, mul;
; 308  : 
; 309  : 	for (gn = 0; gn < GAIN_MAXLIMIT; gn++) {

  00010	e3a04000	 mov         r4, #0
  00014	e3a08001	 mov         r8, #1
  00018		 |$LL4@cal_recipr|

; 310  : 		mul = 1 << (gn + 8);

  00018	e2841008	 add         r1, r4, #8

; 311  : 		rn = mul / sensor;

  0001c	e1a01118	 mov         r1, r8, lsl r1
  00020	e1a00007	 mov         r0, r7
  00024	eb000000	 bl          __rt_udiv

; 312  : 		if (rn < R_MAXLIMIT) {

  00028	e3500c01	 cmp         r0, #1, 24

; 313  : 			*sengain = gn;

  0002c	35864000	 strcc       r4, [r6]

; 314  : 			*rnsen = rn;

  00030	e2844001	 add         r4, r4, #1
  00034	35850000	 strcc       r0, [r5]
  00038	e3540010	 cmp         r4, #0x10
  0003c	3afffff5	 bcc         |$LL4@cal_recipr|

; 315  : 		}
; 316  : 	}
; 317  : }

  00040	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$M47804|

			 ENDP  ; |cal_reciprocal|


  00000			 AREA	 |.pdata|, PDATA
|$T47849| DCD	|$LN21@cal_test_n|
	DCD	0x40002602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |cal_test_nvalue| PROC

; 320  : {

  00000		 |$LN21@cal_test_n|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M47846|
  00008	e1a05001	 mov         r5, r1
  0000c	e1a09000	 mov         r9, r0

; 321  : 	UINT32 senpgain, senngain;
; 322  : 	UINT32 rnsenp, rnsenn;
; 323  : 
; 324  : 	/* Calculating the gain and reciprocal of the SenN and SenP values */
; 325  : 	cal_reciprocal(senpval, &senpgain, &rnsenp);

  00010	e59d7000	 ldr         r7, [sp]
  00014	e59d8000	 ldr         r8, [sp]
  00018	e3a04000	 mov         r4, #0
  0001c	e3a06001	 mov         r6, #1
  00020		 |$LL6@cal_test_n|
  00020	e2841008	 add         r1, r4, #8
  00024	e1a01116	 mov         r1, r6, lsl r1
  00028	e1a00005	 mov         r0, r5
  0002c	eb000000	 bl          __rt_udiv
  00030	e3500c01	 cmp         r0, #1, 24
  00034	31a08004	 movcc       r8, r4
  00038	e2844001	 add         r4, r4, #1
  0003c	31a07000	 movcc       r7, r0
  00040	e3540010	 cmp         r4, #0x10
  00044	3afffff5	 bcc         |$LL6@cal_test_n|

; 326  : 	cal_reciprocal(sennval, &senngain, &rnsenn);

  00048	e59d5000	 ldr         r5, [sp]
  0004c	e59d6000	 ldr         r6, [sp]
  00050	e3a04000	 mov         r4, #0
  00054	e3a0a001	 mov         r10, #1
  00058		 |$LL12@cal_test_n|
  00058	e2841008	 add         r1, r4, #8
  0005c	e1a0111a	 mov         r1, r10, lsl r1
  00060	e1a00009	 mov         r0, r9
  00064	eb000000	 bl          __rt_udiv
  00068	e3500c01	 cmp         r0, #1, 24
  0006c	31a06004	 movcc       r6, r4
  00070	e2844001	 add         r4, r4, #1
  00074	31a05000	 movcc       r5, r0
  00078	e3540010	 cmp         r4, #0x10
  0007c	3afffff5	 bcc         |$LL12@cal_test_n|

; 327  : 
; 328  : 	return (senpgain << NVALUERECIPROCAL_SENPGAIN_SHIFT) |
; 329  : 		(senngain << NVALUERECIPROCAL_SENNGAIN_SHIFT) |
; 330  : 		(rnsenp << NVALUERECIPROCAL_RNSENP_SHIFT) |
; 331  : 		(rnsenn << NVALUERECIPROCAL_RNSENN_SHIFT);

  00080	e1863208	 orr         r3, r6, r8, lsl #4
  00084	e1873403	 orr         r3, r7, r3, lsl #8
  00088	e1850403	 orr         r0, r5, r3, lsl #8

; 332  : }

  0008c	e28dd004	 add         sp, sp, #4
  00090	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00094	e12fff1e	 bx          lr
  00098		 |$M47847|

			 ENDP  ; |cal_test_nvalue|

	EXPORT	|??_C@_1IA@BDMNHBLK@?$AAC?$AAo?$AAm?$AAp?$AAe?$AAn?$AAs?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAO?$AAP?$AAP?$AA?$CF?$AAd?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AA?$CF?$AAd?$AAm?$AAV?$AA?5?$AAO?$AAr?$AAi?$AAg@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T47921| DCD	|$LN24@SmartRefle@4|
	DCD	0x40005002

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1IA@BDMNHBLK@?$AAC?$AAo?$AAm?$AAp?$AAe?$AAn?$AAs?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAO?$AAP?$AAP?$AA?$CF?$AAd?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AA?$CF?$AAd?$AAm?$AAV?$AA?5?$AAO?$AAr?$AAi?$AAg@| DCB "C"
	DCB	0x0, "o", 0x0, "m", 0x0, "p", 0x0, "e", 0x0, "n", 0x0, "s"
	DCB	0x0, "a", 0x0, "t", 0x0, "i", 0x0, "n", 0x0, "g", 0x0, " "
	DCB	0x0, "O", 0x0, "P", 0x0, "P", 0x0, "%", 0x0, "d", 0x0, " "
	DCB	0x0, "f", 0x0, "o", 0x0, "r", 0x0, " ", 0x0, "%", 0x0, "d"
	DCB	0x0, "m", 0x0, "V", 0x0, " ", 0x0, "O", 0x0, "r", 0x0, "i"
	DCB	0x0, "g", 0x0, " ", 0x0, "n", 0x0, "v", 0x0, "a", 0x0, "l"
	DCB	0x0, "u", 0x0, "e", 0x0, ":", 0x0, "0", 0x0, "x", 0x0, "%"
	DCB	0x0, "x", 0x0, " ", 0x0, "N", 0x0, "e", 0x0, "w", 0x0, " "
	DCB	0x0, "n", 0x0, "v", 0x0, "a", 0x0, "l", 0x0, "u", 0x0, "e"
	DCB	0x0, ":", 0x0, "0", 0x0, "x", 0x0, "%", 0x0, "x", 0x0, " "
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SmartReflex_Adjust_EFUSE_nvalue| PROC

; 337  : {

  00000		 |$LN24@SmartRefle@4|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M47918|
  00008	e1a08002	 mov         r8, r2
  0000c	e1b07001	 movs        r7, r1
  00010	e1a0b000	 mov         r11, r0
  00014	e58d8004	 str         r8, [sp, #4]
  00018	e58d700c	 str         r7, [sp, #0xC]
  0001c	e58db010	 str         r11, [sp, #0x10]

; 338  : 	unsigned int new_opp_nvalue = 0;

  00020	e3a04000	 mov         r4, #0

; 339  : 	unsigned int senp_gain, senn_gain, rnsenp, rnsenn, pnt_delta, nnt_delta;
; 340  : 	unsigned int new_senn, new_senp, senn, senp;
; 341  : 
; 342  :     UNREFERENCED_PARAMETER(opp_no);
; 343  : 
; 344  : 	if (orig_opp_nvalue != 0)

  00024	0a00003f	 beq         |$LN1@SmartRefle@4|

; 345  : 	{
; 346  : 	/* calculate SenN and SenP from the efuse value */
; 347  : 	senp_gain = ((orig_opp_nvalue >> 20) & 0xf);
; 348  : 	senn_gain = ((orig_opp_nvalue >> 16) & 0xf);
; 349  : 	rnsenp = ((orig_opp_nvalue >> 8) & 0xff);
; 350  : 	rnsenn = (orig_opp_nvalue & 0xff);
; 351  : 
; 352  : 	senp = ((1<<(senp_gain+8))/(rnsenp));
; 353  : 	senn = ((1<<(senn_gain+8))/(rnsenn));
; 354  : 
; 355  : 	/* calculate the voltage delta */
; 356  : 	pnt_delta = (26 * mv_delta)/10;
; 357  : 	nnt_delta = (3 * mv_delta);
; 358  : 
; 359  : 	/* now lets add the voltage delta to the sensor values */
; 360  : 	new_senn = senn + nnt_delta;

  00028	e1a03607	 mov         r3, r7, lsl #12
  0002c	e1a03e23	 mov         r3, r3, lsr #28
  00030	e2831008	 add         r1, r3, #8
  00034	e3a03001	 mov         r3, #1
  00038	e1a01113	 mov         r1, r3, lsl r1
  0003c	e20700ff	 and         r0, r7, #0xFF
  00040	eb000000	 bl          __rt_udiv

; 361  : 	new_senp = senp + pnt_delta;

  00044	e1a03407	 mov         r3, r7, lsl #8
  00048	e1a03e23	 mov         r3, r3, lsr #28
  0004c	e2831008	 add         r1, r3, #8
  00050	e3a02001	 mov         r2, #1
  00054	e088e088	 add         lr, r8, r8, lsl #1
  00058	e1a01112	 mov         r1, r2, lsl r1
  0005c	e1a03807	 mov         r3, r7, lsl #16
  00060	e08e2000	 add         r2, lr, r0
  00064	e1a00c23	 mov         r0, r3, lsr #24
  00068	e58d2008	 str         r2, [sp, #8]
  0006c	eb000000	 bl          __rt_udiv
  00070	e3a0301a	 mov         r3, #0x1A
  00074	e0020398	 mul         r2, r8, r3
  00078	e59f30bc	 ldr         r3, [pc, #0xBC]

; 362  : 
; 363  : 	new_opp_nvalue = cal_test_nvalue(new_senn, new_senp);

  0007c	e59d9010	 ldr         r9, [sp, #0x10]
  00080	e59da010	 ldr         r10, [sp, #0x10]
  00084	e0863392	 umull       r3, r6, r2, r3
  00088	e1a05000	 mov         r5, r0
  0008c	e3a04000	 mov         r4, #0
  00090	e3a08001	 mov         r8, #1
  00094		 |$LL9@SmartRefle@4|
  00094	e2841008	 add         r1, r4, #8
  00098	e1a01118	 mov         r1, r8, lsl r1
  0009c	e08501a6	 add         r0, r5, r6, lsr #3
  000a0	eb000000	 bl          __rt_udiv
  000a4	e3500c01	 cmp         r0, #1, 24
  000a8	31a0a004	 movcc       r10, r4
  000ac	e2844001	 add         r4, r4, #1
  000b0	31a09000	 movcc       r9, r0
  000b4	e3540010	 cmp         r4, #0x10
  000b8	3afffff5	 bcc         |$LL9@SmartRefle@4|
  000bc	e59d5010	 ldr         r5, [sp, #0x10]
  000c0	e59d6010	 ldr         r6, [sp, #0x10]
  000c4	e59d8004	 ldr         r8, [sp, #4]

; 364  : 
; 365  : 	OALMSG( TRUE, (L"Compensating OPP%d for %dmV Orig nvalue:0x%x New nvalue:0x%x \r\n",
; 366  : 			opp_no, mv_delta, orig_opp_nvalue, new_opp_nvalue));

  000c8	e59db008	 ldr         r11, [sp, #8]
  000cc	e3a04000	 mov         r4, #0
  000d0	e3a07001	 mov         r7, #1
  000d4		 |$LL15@SmartRefle@4|
  000d4	e2841008	 add         r1, r4, #8
  000d8	e1a01117	 mov         r1, r7, lsl r1
  000dc	e1a0000b	 mov         r0, r11
  000e0	eb000000	 bl          __rt_udiv
  000e4	e3500c01	 cmp         r0, #1, 24
  000e8	31a06004	 movcc       r6, r4
  000ec	e2844001	 add         r4, r4, #1
  000f0	31a05000	 movcc       r5, r0
  000f4	e3540010	 cmp         r4, #0x10
  000f8	3afffff5	 bcc         |$LL15@SmartRefle@4|
  000fc	e59d700c	 ldr         r7, [sp, #0xC]
  00100	e59db010	 ldr         r11, [sp, #0x10]
  00104	e186320a	 orr         r3, r6, r10, lsl #4
  00108	e59f0028	 ldr         r0, [pc, #0x28]
  0010c	e1893403	 orr         r3, r9, r3, lsl #8
  00110	e1854403	 orr         r4, r5, r3, lsl #8
  00114	e1a03007	 mov         r3, r7
  00118	e1a02008	 mov         r2, r8
  0011c	e1a0100b	 mov         r1, r11
  00120	e58d4000	 str         r4, [sp]
  00124	eb000000	 bl          NKDbgPrintfW
  00128		 |$LN1@SmartRefle@4|

; 367  : 	}
; 368  : 
; 369  : 	return new_opp_nvalue;
; 370  : }

  00128	e1a00004	 mov         r0, r4
  0012c	e28dd014	 add         sp, sp, #0x14
  00130	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00134	e12fff1e	 bx          lr
  00138		 |$LN25@SmartRefle@4|
  00138		 |$LN26@SmartRefle@4|
  00138	00000000	 DCD         |??_C@_1IA@BDMNHBLK@?$AAC?$AAo?$AAm?$AAp?$AAe?$AAn?$AAs?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAO?$AAP?$AAP?$AA?$CF?$AAd?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AA?$CF?$AAd?$AAm?$AAV?$AA?5?$AAO?$AAr?$AAi?$AAg@|
  0013c		 |$LN27@SmartRefle@4|
  0013c	cccccccd	 DCD         0xcccccccd
  00140		 |$M47919|

			 ENDP  ; |SmartReflex_Adjust_EFUSE_nvalue|

	EXPORT	|SmartReflex_Read_EFUSE|
	IMPORT	|g_dwCpuRevision|
	IMPORT	|g_dwCpuFamily|
	IMPORT	|OALPAtoVA|
	IMPORT	|memset|

  0003c			 AREA	 |.bss|, NOINIT
|_sensorEnData| % 0x4
|_sensorEnData| % 0x4
|_bSmartreflexCapable| % 0x4
|_SR_driver_data| % 0x4

  00000			 AREA	 |.pdata|, PDATA
|$T47958| DCD	|$LN42@SmartRefle@5|
	DCD	0x40009302
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SmartReflex_Read_EFUSE| PROC

; 377  : {

  00000		 |$LN42@SmartRefle@5|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd020	 sub         sp, sp, #0x20
  00008		 |$M47955|

; 378  :     SmartReflexSensorData_t *pSRInfo;
; 379  :     Efuse_SensorData_t      sensorData;
; 380  :     Efuse_SensorData_field_t 	*pSenData;
; 381  :     OMAP_SYSC_GENERAL_REGS  *pSysc = OALPAtoVA(OMAP_SYSC_GENERAL_REGS_PA, FALSE);

  00008	e59f0238	 ldr         r0, [pc, #0x238]
  0000c	e3a01000	 mov         r1, #0
  00010	eb000000	 bl          OALPAtoVA
  00014	e1a05000	 mov         r5, r0

; 382  :     UINT idx;
; 383  : 
; 384  :     memset(&sensorData, 0, sizeof(sensorData));

  00018	e28d0000	 add         r0, sp, #0
  0001c	e3a02020	 mov         r2, #0x20
  00020	e3a01000	 mov         r1, #0
  00024	eb000000	 bl          memset

; 385  : 
; 386  :     if(_SR_driver_data->Use_test_value == TRUE)

  00028	e59f4214	 ldr         r4, [pc, #0x214]
  0002c	e5946008	 ldr         r6, [r4, #8]
  00030	e5963004	 ldr         r3, [r6, #4]
  00034	e3530001	 cmp         r3, #1
  00038	1a000015	 bne         |$LN21@SmartRefle@5|

; 387  :     {
; 388  :         /* VDD1 */ 
; 389  : 	 sensorData.Efuse_Vdd1_Opp_1 = omap37xx_sr1_test_nvalues[0];

  0003c	e59fe1fc	 ldr         lr, [pc, #0x1FC]

; 390  : 	 sensorData.Efuse_Vdd1_Opp_2 = omap37xx_sr1_test_nvalues[1];
; 391  : 	 sensorData.Efuse_Vdd1_Opp_3 = omap37xx_sr1_test_nvalues[2];
; 392  : 	 sensorData.Efuse_Vdd1_Opp_4 = omap37xx_sr1_test_nvalues[3];
; 393  : 
; 394  :         /* VDD2 */
; 395  :         for(idx=0;idx<3;idx++)
; 396  :             sensorData.Efuse_Vdd2_Opp[idx]= omap37xx_sr2_test_nvalues[idx];

  00040	e28d5014	 add         r5, sp, #0x14
  00044	e285700c	 add         r7, r5, #0xC
  00048	e59e2004	 ldr         r2, [lr, #4]
  0004c	e59e3000	 ldr         r3, [lr]
  00050	e59e1008	 ldr         r1, [lr, #8]
  00054	e59e000c	 ldr         r0, [lr, #0xC]
  00058	e58d2004	 str         r2, [sp, #4]
  0005c	e28e2010	 add         r2, lr, #0x10
  00060	e58d3000	 str         r3, [sp]
  00064	e58d1008	 str         r1, [sp, #8]
  00068	e58d000c	 str         r0, [sp, #0xC]
  0006c		 |$LN36@SmartRefle@5|
  0006c	e4923004	 ldr         r3, [r2], #4
  00070	e4853004	 str         r3, [r5], #4
  00074	e1550007	 cmp         r5, r7
  00078	1afffffb	 bne         |$LN36@SmartRefle@5|
  0007c	e3a03c0f	 mov         r3, #0xF, 24

; 397  : 
; 398  :         /* when use test value, enable both senN and senP by default */
; 399  :         _sensorEnData.Efuse_SR       = 0x0f0f;

  00080	e383300f	 orr         r3, r3, #0xF

; 400  : 
; 401  :         _bSmartreflexCapable = TRUE;    

  00084	e3a02001	 mov         r2, #1
  00088	e5843000	 str         r3, [r4]
  0008c	e5842004	 str         r2, [r4, #4]

; 402  :     }	
; 403  :     else

  00090	ea000040	 b           |$LN7@SmartRefle@5|
  00094		 |$LN21@SmartRefle@5|

; 404  :     {
; 405  :         if(g_dwCpuFamily == CPU_FAMILY_DM37XX)

  00094	e59f31a0	 ldr         r3, [pc, #0x1A0]
  00098	e5933000	 ldr         r3, [r3]
  0009c	e3530001	 cmp         r3, #1
  000a0	1a000022	 bne         |$LN16@SmartRefle@5|

; 406  :         {            
; 407  :             unsigned int opp_nvalue;
; 408  :             // EFuse data for Vdd1
; 409  :             /* 37xx has 4 OPPs, and the efuse are in the following order: 
; 410  :                         offset           OPP        varible   
; 411  :                         0x11c               
; 412  :                         0x114         OPP50       OPP1_VDD1
; 413  :                         0x118         OPP100      OPP2_VDD1
; 414  :                         0x120         OPP130      OPP3_VDD1
; 415  :                         0X110         OPP1G       OPP4_VDD1
; 416  :                     */
; 417  :             opp_nvalue = INREG32(&pSysc->CONTROL_FUSE_OPP_VDD1[1]);

  000a4	e5951114	 ldr         r1, [r5, #0x114]

; 418  :             sensorData.Efuse_Vdd1_Opp_1 = SmartReflex_Adjust_EFUSE_nvalue(1, opp_nvalue,
; 419  :                                                       OMAP37XX_LOW_OPP_VMARGIN);

  000a8	e3a0203f	 mov         r2, #0x3F
  000ac	e3a00001	 mov         r0, #1
  000b0	eb000000	 bl          SmartReflex_Adjust_EFUSE_nvalue

; 420  :             opp_nvalue = INREG32(&pSysc->CONTROL_FUSE_OPP_VDD1[2]);

  000b4	e5951118	 ldr         r1, [r5, #0x118]
  000b8	e1a03000	 mov         r3, r0

; 421  :             sensorData.Efuse_Vdd1_Opp_2 = SmartReflex_Adjust_EFUSE_nvalue(2, opp_nvalue,
; 422  :                                                       OMAP37XX_LOW_OPP_VMARGIN);

  000bc	e3a00002	 mov         r0, #2
  000c0	e3a0203f	 mov         r2, #0x3F
  000c4	e58d3000	 str         r3, [sp]
  000c8	eb000000	 bl          SmartReflex_Adjust_EFUSE_nvalue

; 423  :             opp_nvalue = INREG32(&pSysc->CONTROL_FUSE_OPP_VDD1[4]);

  000cc	e5951120	 ldr         r1, [r5, #0x120]
  000d0	e1a03000	 mov         r3, r0

; 424  :             sensorData.Efuse_Vdd1_Opp_3 = SmartReflex_Adjust_EFUSE_nvalue(3, opp_nvalue,
; 425  :                                                       OMAP37XX_HIGH_OPP_VMARGIN);

  000d4	e3a00003	 mov         r0, #3
  000d8	e3a0204b	 mov         r2, #0x4B
  000dc	e58d3004	 str         r3, [sp, #4]
  000e0	eb000000	 bl          SmartReflex_Adjust_EFUSE_nvalue

; 426  :             opp_nvalue = INREG32(&pSysc->CONTROL_FUSE_OPP_VDD1[0]);

  000e4	e5951110	 ldr         r1, [r5, #0x110]
  000e8	e1a03000	 mov         r3, r0

; 427  :             sensorData.Efuse_Vdd1_Opp_4 = SmartReflex_Adjust_EFUSE_nvalue(4, opp_nvalue,
; 428  :                                                       OMAP37XX_HIGH_OPP4_VMARGIN);

  000ec	e3a00004	 mov         r0, #4
  000f0	e3a02064	 mov         r2, #0x64
  000f4	e58d3008	 str         r3, [sp, #8]
  000f8	eb000000	 bl          SmartReflex_Adjust_EFUSE_nvalue

; 429  :           
; 430  :             _sensorEnData.Efuse_SR       = INREG32(&pSysc->CONTROL_FUSE_SR);            

  000fc	e5953130	 ldr         r3, [r5, #0x130]
  00100	e58d000c	 str         r0, [sp, #0xC]
  00104	e1b02003	 movs        r2, r3

; 431  :             if ((_sensorEnData.Efuse_SR == 0) &&
; 432  :                 (g_dwCpuRevision==CPU_FAMILY_37XX_REVISION_ES_1_2))

  00108	059f3128	 ldreq       r3, [pc, #0x128]
  0010c	e5842000	 str         r2, [r4]
  00110	05933000	 ldreq       r3, [r3]
  00114	03530012	 cmpeq       r3, #0x12
  00118	03a03c0f	 moveq       r3, #0xF, 24

; 433  :             {
; 434  :                 _sensorEnData.Efuse_SR       = 0x0f0f;
; 435  :             }                        
; 436  :         }
; 437  :         else

  0011c	05946008	 ldreq       r6, [r4, #8]
  00120	0383200f	 orreq       r2, r3, #0xF
  00124	0a00000d	 beq         |$LN39@SmartRefle@5|
  00128	e5946008	 ldr         r6, [r4, #8]
  0012c	ea00000c	 b           |$LN14@SmartRefle@5|
  00130		 |$LN16@SmartRefle@5|

; 438  :         {
; 439  : 	        // EFuse data for Vdd1
; 440  : 	        for(idx = 0; idx < 5 && (idx <=_Max_Vdd1_OPP); idx++)

  00130	e594e04c	 ldr         lr, [r4, #0x4C]
  00134	e3a02000	 mov         r2, #0
  00138	e28d1000	 add         r1, sp, #0
  0013c	e2850e11	 add         r0, r5, #0x11, 28
  00140		 |$LL13@SmartRefle@5|
  00140	e152000e	 cmp         r2, lr
  00144	8a000004	 bhi         |$LN11@SmartRefle@5|

; 441  : 	        {
; 442  : 	            sensorData.Efuse_Vdd1_Opp[idx] = INREG32(&pSysc->CONTROL_FUSE_OPP_VDD1[idx]);

  00148	e4903004	 ldr         r3, [r0], #4
  0014c	e2822001	 add         r2, r2, #1
  00150	e3520005	 cmp         r2, #5
  00154	e4813004	 str         r3, [r1], #4
  00158	3afffff8	 bcc         |$LL13@SmartRefle@5|
  0015c		 |$LN11@SmartRefle@5|

; 443  : 	        }
; 444  :             _sensorEnData.Efuse_SR       = INREG32(&pSysc->CONTROL_FUSE_SR);

  0015c	e5952130	 ldr         r2, [r5, #0x130]
  00160		 |$LN39@SmartRefle@5|
  00160	e5842000	 str         r2, [r4]
  00164		 |$LN14@SmartRefle@5|

; 445  :         }
; 446  : 
; 447  :         /* VDD2 */
; 448  :         for(idx=0;idx<3;idx++)

  00164	e28d1000	 add         r1, sp, #0
  00168	e2850f49	 add         r0, r5, #0x49, 30
  0016c	e3a0e003	 mov         lr, #3
  00170		 |$LL10@SmartRefle@5|

; 449  :         {
; 450  :             sensorData.Efuse_Vdd2_Opp[idx]= INREG32(&pSysc->CONTROL_FUSE_OPP_VDD2[idx]);

  00170	e4903004	 ldr         r3, [r0], #4
  00174	e25ee001	 subs        lr, lr, #1
  00178	e5813014	 str         r3, [r1, #0x14]
  0017c	e2811004	 add         r1, r1, #4
  00180	1afffffa	 bne         |$LL10@SmartRefle@5|

; 451  :         }
; 452  :         
; 453  : 	
; 454  :         //SmartReflex_dump_sensor_data(&sensorData);
; 455  :         _bSmartreflexCapable = FALSE;

  00184	e3a03000	 mov         r3, #0

; 456  : 
; 457  :        /*for(idx = 0; idx< 5; idx++)
; 458  :         {
; 459  :             if(sensorData.Efuse_Vdd1_Opp[idx] != 0) 
; 460  :             {
; 461  :                  _bSmartreflexCapable = TRUE;
; 462  : 	          break;
; 463  :             }
; 464  :         }
; 465  :         for(idx = 0; idx<= 2 && !_bSmartreflexCapable; idx++)
; 466  :         {
; 467  :             if(sensorData.Efuse_Vdd2_Opp[idx] != 0) 
; 468  :             {
; 469  :                  _bSmartreflexCapable = TRUE;
; 470  : 	         break;
; 471  :             }
; 472  :         } */
; 473  :         if((!_bSmartreflexCapable) && (_sensorEnData.Efuse_SR  != 0x00))

  00188	e3520000	 cmp         r2, #0
  0018c	e5843004	 str         r3, [r4, #4]

; 474  :             _bSmartreflexCapable = TRUE; 	

  00190	13a03001	 movne       r3, #1
  00194	15843004	 strne       r3, [r4, #4]
  00198		 |$LN7@SmartRefle@5|

; 475  : 
; 476  :     }
; 477  : 	
; 478  :     /* VDD1 */
; 479  :     for(idx=kOpp1; idx<= kOpp6;idx++)

  00198	e3a0e000	 mov         lr, #0
  0019c	e28d5000	 add         r5, sp, #0
  001a0		 |$LL6@SmartRefle@5|

; 480  :     {
; 481  :         pSRInfo = &_SR_driver_data->ppVoltDomain1[idx]->smartReflexInfo;

  001a0	e5963010	 ldr         r3, [r6, #0x10]

; 482  :   	 /* KOpp6 is duplicate of KOpp5 */
; 483  :         pSenData = (idx==kOpp6) ? (Efuse_SensorData_field_t *)&sensorData.Efuse_Vdd1_Opp[kOpp5]: 
; 484  :                                                   (Efuse_SensorData_field_t *)&sensorData.Efuse_Vdd1_Opp[idx];

  001a4	e35e0005	 cmp         lr, #5
  001a8	e793410e	 ldr         r4, [r3, +lr, lsl #2]
  001ac	028d3010	 addeq       r3, sp, #0x10
  001b0	1085310e	 addne       r3, r5, lr, lsl #2

; 485  :         pSRInfo->rnsenn = pSenData->rnsenn;

  001b4	e5931000	 ldr         r1, [r3]

; 486  :         pSRInfo->rnsenp = pSenData->rnsenp;

  001b8	e5d30001	 ldrb        r0, [r3, #1]
  001bc	e28ee001	 add         lr, lr, #1

; 487  :         pSRInfo->senngain = pSenData->senngain;

  001c0	e1a03601	 mov         r3, r1, lsl #12

; 488  :         pSRInfo->senpgain = pSenData->senpgain;

  001c4	e1a02401	 mov         r2, r1, lsl #8
  001c8	e1a03e23	 mov         r3, r3, lsr #28
  001cc	e1a02e22	 mov         r2, r2, lsr #28
  001d0	e20110ff	 and         r1, r1, #0xFF
  001d4	e284c008	 add         r12, r4, #8
  001d8	e88c000f	 stmia       r12, {r0 - r3}
  001dc	e35e0005	 cmp         lr, #5
  001e0	9affffee	 bls         |$LL6@SmartRefle@5|

; 489  : 
; 490  :     }
; 491  : 
; 492  :     /* VDD2 */
; 493  :     // VDD2 OPP1 corresponds to EFUSE VDD2 OPP2
; 494  :     // VDD2 OPP2 corresponds to EFUSE VDD2 OPP3
; 495  :     for(idx=kOpp1; idx<= kOpp2;idx++)

  001e4	e3a05000	 mov         r5, #0
  001e8	e28d7018	 add         r7, sp, #0x18
  001ec		 |$LL3@SmartRefle@5|

; 496  :     {
; 497  :         pSRInfo = &_SR_driver_data->ppVoltDomain2[idx]->smartReflexInfo;
; 498  : 
; 499  :         pSenData = (Efuse_SensorData_field_t *)&sensorData.Efuse_Vdd2_Opp[idx+1];
; 500  :         pSRInfo->rnsenn = pSenData->rnsenn;

  001ec	e1a03005	 mov         r3, r5
  001f0	e7b30007	 ldr         r0, [r3, +r7]!
  001f4	e5961014	 ldr         r1, [r6, #0x14]

; 501  :         pSRInfo->rnsenp = pSenData->rnsenp;

  001f8	e5d3e001	 ldrb        lr, [r3, #1]

; 502  :         pSRInfo->senngain = pSenData->senngain;
; 503  :         pSRInfo->senpgain = pSenData->senpgain;

  001fc	e7954001	 ldr         r4, [r5, +r1]
  00200	e1a03600	 mov         r3, r0, lsl #12
  00204	e1a02400	 mov         r2, r0, lsl #8
  00208	e1a03e23	 mov         r3, r3, lsr #28
  0020c	e1a02e22	 mov         r2, r2, lsr #28
  00210	e20010ff	 and         r1, r0, #0xFF
  00214	e2855004	 add         r5, r5, #4
  00218	e284c00c	 add         r12, r4, #0xC
  0021c	e88c000e	 stmia       r12, {r1 - r3}
  00220	e3550004	 cmp         r5, #4
  00224	e584e008	 str         lr, [r4, #8]
  00228	9affffef	 bls         |$LL3@SmartRefle@5|

; 504  :     }
; 505  :     
; 506  : }

  0022c	e28dd020	 add         sp, sp, #0x20
  00230	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00234	e12fff1e	 bx          lr
  00238		 |$LN43@SmartRefle@5|
  00238		 |$LN44@SmartRefle@5|
  00238	00000000	 DCD         |g_dwCpuRevision|
  0023c		 |$LN45@SmartRefle@5|
  0023c	00000000	 DCD         |g_dwCpuFamily|
  00240		 |$LN46@SmartRefle@5|
  00240	00000000	 DCD         |omap37xx_sr1_test_nvalues|
  00244		 |$LN47@SmartRefle@5|
  00244	00000000	 DCD         |_sensorEnData|
  00248		 |$LN48@SmartRefle@5|
  00248	48002270	 DCD         0x48002270
  0024c		 |$M47956|

			 ENDP  ; |SmartReflex_Read_EFUSE|

	EXPORT	|SmartReflex_PostInitialize|
	IMPORT	|InitializeCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T47971| DCD	|$LN5@SmartRefle@6|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SmartReflex_PostInitialize| PROC

; 547  : {

  00000		 |$LN5@SmartRefle@6|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M47968|

; 548  :     InitializeCriticalSection(&_rgSmartReflexInfo[kSmartReflex_Channel1].cs);

  00004	e59f4024	 ldr         r4, [pc, #0x24]
  00008	e2840008	 add         r0, r4, #8
  0000c	eb000000	 bl          InitializeCriticalSection

; 549  :     InitializeCriticalSection(&_rgSmartReflexInfo[kSmartReflex_Channel2].cs);

  00010	e2840024	 add         r0, r4, #0x24
  00014	eb000000	 bl          InitializeCriticalSection

; 550  : 
; 551  :     _rgSmartReflexInfo[kSmartReflex_Channel1].bInitialized = TRUE;

  00018	e3a03001	 mov         r3, #1
  0001c	e5843000	 str         r3, [r4]

; 552  :     _rgSmartReflexInfo[kSmartReflex_Channel2].bInitialized = TRUE;

  00020	e3a03001	 mov         r3, #1
  00024	e584301c	 str         r3, [r4, #0x1C]

; 553  : }

  00028	e8bd4010	 ldmia       sp!, {r4, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$LN6@SmartRefle@6|
  00030		 |$LN7@SmartRefle@6|
  00030	00000000	 DCD         |_rgSmartReflexInfo|
  00034		 |$M47969|

			 ENDP  ; |SmartReflex_PostInitialize|

	EXPORT	|SmartReflex_Configure|

  0004c			 AREA	 |.bss|, NOINIT
|_rgOppVdd| %	0x8

  00000			 AREA	 |.pdata|, PDATA
|$T47981| DCD	|$LN8@SmartRefle@7|
	DCD	0x40005301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SmartReflex_Configure| PROC

; 558  : {

  00000		 |$LN8@SmartRefle@7|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M47978|
  00004	e1a08000	 mov         r8, r0

; 559  :     if (SmartReflex_funcs == NULL)

  00008	e59f7138	 ldr         r7, [pc, #0x138]
  0000c	e5973000	 ldr         r3, [r7]
  00010	e3530000	 cmp         r3, #0
  00014	0a000048	 beq         |$CleanUp$47523|

; 560  :     {
; 561  :         OALMSG(OAL_LOG_ERROR, (L"\r\nInvalid Smart Reflex Functions pointer\r\n"));
; 562  :         goto CleanUp;
; 563  :     }
; 564  :     if (channel == kSmartReflex_Channel1)
; 565  :         {
; 566  :         // Configure SR1 Parameters
; 567  :         SmartReflex_funcs->SetErrorControl(kSmartReflex_Channel1, 
; 568  :                                     _SR_driver_data->Sr1ErrCfg[_rgOppVdd[channel]].errWeight,
; 569  :                                     _SR_driver_data->Sr1ErrCfg[_rgOppVdd[channel]].errMaxLimit,
; 570  :                                     _SR_driver_data->Sr1ErrCfg[_rgOppVdd[channel]].errMinLimit
; 571  :                                     );

  00018	e59f6124	 ldr         r6, [pc, #0x124]
  0001c	e5935014	 ldr         r5, [r3, #0x14]
  00020	e3580000	 cmp         r8, #0
  00024	1a00001b	 bne         |$LN2@SmartRefle@7|
  00028	e5963008	 ldr         r3, [r6, #8]
  0002c	e596200c	 ldr         r2, [r6, #0xC]
  00030	e3a00000	 mov         r0, #0
  00034	e5933008	 ldr         r3, [r3, #8]
  00038	e7b34102	 ldr         r4, [r3, +r2, lsl #2]!
  0003c	e5d32001	 ldrb        r2, [r3, #1]
  00040	e1a03684	 mov         r3, r4, lsl #13
  00044	e1a01ea3	 mov         r1, r3, lsr #29
  00048	e20430ff	 and         r3, r4, #0xFF
  0004c	e1a0e00f	 mov         lr, pc
  00050	e12fff15	 bx          r5

; 572  : 
; 573  :         SmartReflex_funcs->SetSensorMode(kSmartReflex_Channel1, 
; 574  :                                     _sensorEnData.sr1_sennenable, 
; 575  :                                     _sensorEnData.sr1_senpenable
; 576  :                                     );

  00054	e5961000	 ldr         r1, [r6]
  00058	e5972000	 ldr         r2, [r7]
  0005c	e3a00000	 mov         r0, #0
  00060	e1a03e01	 mov         r3, r1, lsl #28
  00064	e5924008	 ldr         r4, [r2, #8]
  00068	e1a02f23	 mov         r2, r3, lsr #30
  0006c	e2011003	 and         r1, r1, #3
  00070	e1a0e00f	 mov         lr, pc
  00074	e12fff14	 bx          r4

; 577  :         
; 578  :         SmartReflex_funcs->SetAvgWeight(kSmartReflex_Channel1, 
; 579  :                                     BSP_SR1_SENN_AVGWEIGHT, 
; 580  :                                     BSP_SR1_SENP_AVGWEIGHT
; 581  :                                     );

  00078	e5973000	 ldr         r3, [r7]
  0007c	e3a02003	 mov         r2, #3
  00080	e3a01003	 mov         r1, #3
  00084	e5933034	 ldr         r3, [r3, #0x34]
  00088	e3a00000	 mov         r0, #0
  0008c	e1a0e00f	 mov         lr, pc
  00090	e12fff13	 bx          r3

; 582  :         }
; 583  :     else

  00094	ea00001c	 b           |$LN1@SmartRefle@7|
  00098		 |$LN2@SmartRefle@7|

; 584  :         {
; 585  :         // Configure SR2 Parameters
; 586  :         SmartReflex_funcs->SetErrorControl(kSmartReflex_Channel2, 
; 587  :                                     _SR_driver_data->Sr2ErrCfg[_rgOppVdd[channel]].errWeight,
; 588  :                                     _SR_driver_data->Sr2ErrCfg[_rgOppVdd[channel]].errMaxLimit,
; 589  :                                     _SR_driver_data->Sr2ErrCfg[_rgOppVdd[channel]].errMinLimit
; 590  :                                     );

  00098	e5962008	 ldr         r2, [r6, #8]
  0009c	e286300c	 add         r3, r6, #0xC
  000a0	e7933108	 ldr         r3, [r3, +r8, lsl #2]
  000a4	e592200c	 ldr         r2, [r2, #0xC]
  000a8	e3a00001	 mov         r0, #1
  000ac	e7b24103	 ldr         r4, [r2, +r3, lsl #2]!
  000b0	e1a03684	 mov         r3, r4, lsl #13
  000b4	e5d22001	 ldrb        r2, [r2, #1]
  000b8	e1a01ea3	 mov         r1, r3, lsr #29
  000bc	e20430ff	 and         r3, r4, #0xFF
  000c0	e1a0e00f	 mov         lr, pc
  000c4	e12fff15	 bx          r5

; 591  : 
; 592  :         SmartReflex_funcs->SetSensorMode(kSmartReflex_Channel2, 
; 593  :                                     _sensorEnData.sr2_sennenable, 
; 594  :                                     _sensorEnData.sr2_senpenable
; 595  :                                     );

  000c8	e5973000	 ldr         r3, [r7]
  000cc	e5961000	 ldr         r1, [r6]
  000d0	e3a00001	 mov         r0, #1
  000d4	e5934008	 ldr         r4, [r3, #8]
  000d8	e1a03b01	 mov         r3, r1, lsl #22
  000dc	e1a02a01	 mov         r2, r1, lsl #20
  000e0	e1a01f23	 mov         r1, r3, lsr #30
  000e4	e1a02f22	 mov         r2, r2, lsr #30
  000e8	e1a0e00f	 mov         lr, pc
  000ec	e12fff14	 bx          r4

; 596  : 
; 597  :         SmartReflex_funcs->SetAvgWeight(kSmartReflex_Channel2, 
; 598  :                                     BSP_SR2_SENN_AVGWEIGHT,
; 599  :                                     BSP_SR2_SENP_AVGWEIGHT
; 600  :                                     );

  000f0	e5973000	 ldr         r3, [r7]
  000f4	e3a02001	 mov         r2, #1
  000f8	e3a01001	 mov         r1, #1
  000fc	e5933034	 ldr         r3, [r3, #0x34]
  00100	e3a00001	 mov         r0, #1
  00104	e1a0e00f	 mov         lr, pc
  00108	e12fff13	 bx          r3
  0010c		 |$LN1@SmartRefle@7|

; 601  :         }
; 602  : 
; 603  :     // Enable Smartreflex Sensor Block
; 604  :     SmartReflex_funcs->EnableSensorBlock(channel, TRUE);

  0010c	e5973000	 ldr         r3, [r7]
  00110	e3a01001	 mov         r1, #1
  00114	e1a00008	 mov         r0, r8
  00118	e5933024	 ldr         r3, [r3, #0x24]
  0011c	e1a0e00f	 mov         lr, pc
  00120	e12fff13	 bx          r3

; 605  : 
; 606  :     // Enable Smartreflex ErrorGenerator Block
; 607  :     SmartReflex_funcs->EnableErrorGeneratorBlock(channel, TRUE);

  00124	e5973000	 ldr         r3, [r7]
  00128	e3a01001	 mov         r1, #1
  0012c	e1a00008	 mov         r0, r8
  00130	e593301c	 ldr         r3, [r3, #0x1C]
  00134	e1a0e00f	 mov         lr, pc
  00138	e12fff13	 bx          r3
  0013c		 |$CleanUp$47523|

; 608  : CleanUp:
; 609  :     return;
; 610  : }

  0013c	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00140	e12fff1e	 bx          lr
  00144		 |$LN9@SmartRefle@7|
  00144		 |$LN10@SmartRefle@7|
  00144	00000000	 DCD         |_sensorEnData|
  00148		 |$LN11@SmartRefle@7|
  00148	00000000	 DCD         |SmartReflex_funcs|
  0014c		 |$M47979|

			 ENDP  ; |SmartReflex_Configure|

	EXPORT	|SmartReflex_Deconfigure|

  00000			 AREA	 |.pdata|, PDATA
|$T47992| DCD	|$LN6@SmartRefle@8|
	DCD	0x40001901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SmartReflex_Deconfigure| PROC

; 620  : {

  00000		 |$LN6@SmartRefle@8|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47989|
  00004	e1a05000	 mov         r5, r0

; 621  :     if (SmartReflex_funcs == NULL)

  00008	e59f4050	 ldr         r4, [pc, #0x50]
  0000c	e5943000	 ldr         r3, [r4]
  00010	e3530000	 cmp         r3, #0
  00014	0a00000f	 beq         |$CleanUp$47533|

; 622  :     {
; 623  :         OALMSG(OAL_LOG_ERROR, (L"\r\nInvalid Smart Reflex Functions pointer\r\n"));
; 624  :         goto CleanUp;
; 625  :     }
; 626  : 
; 627  :     // Disable Smartreflex Sensor Block
; 628  :     SmartReflex_funcs->EnableSensorBlock(channel, FALSE);

  00018	e5933024	 ldr         r3, [r3, #0x24]
  0001c	e3a01000	 mov         r1, #0
  00020	e1a0e00f	 mov         lr, pc
  00024	e12fff13	 bx          r3

; 629  : 
; 630  :     // Disable Smartreflex ErrorGenerator Block
; 631  :     SmartReflex_funcs->EnableErrorGeneratorBlock(channel, FALSE);

  00028	e5943000	 ldr         r3, [r4]
  0002c	e3a01000	 mov         r1, #0
  00030	e1a00005	 mov         r0, r5
  00034	e593301c	 ldr         r3, [r3, #0x1C]
  00038	e1a0e00f	 mov         lr, pc
  0003c	e12fff13	 bx          r3

; 632  : 
; 633  :     // Disable Smartreflex MinMaxAvg Block
; 634  :     SmartReflex_funcs->EnableMinMaxAvgBlock(channel, FALSE);

  00040	e5943000	 ldr         r3, [r4]
  00044	e3a01000	 mov         r1, #0
  00048	e1a00005	 mov         r0, r5
  0004c	e5933020	 ldr         r3, [r3, #0x20]
  00050	e1a0e00f	 mov         lr, pc
  00054	e12fff13	 bx          r3
  00058		 |$CleanUp$47533|

; 635  : 	
; 636  : CleanUp:
; 637  :     return;	
; 638  : }

  00058	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$LN7@SmartRefle@8|
  00060		 |$LN8@SmartRefle@8|
  00060	00000000	 DCD         |SmartReflex_funcs|
  00064		 |$M47990|

			 ENDP  ; |SmartReflex_Deconfigure|

	EXPORT	|SmartReflex_VoltageFlush|
	IMPORT	|OALStall|
	IMPORT	|OALTimerGetCount|
	IMPORT	|PrcmVoltFlushVoltageLevels|
	IMPORT	|PrcmInterruptClearStatus|
	IMPORT	|PrcmVoltGetVoltageRampDelay|
	IMPORT	|PrcmVoltEnableVp|

  00000			 AREA	 |.pdata|, PDATA
|$T48006| DCD	|$LN11@SmartRefle@9|
	DCD	0x40002001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SmartReflex_VoltageFlush| PROC

; 648  : {

  00000		 |$LN11@SmartRefle@9|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M48003|
  00004	e1b05000	 movs        r5, r0

; 649  :     UINT32 interruptMask;
; 650  :     UINT32 tcrr;
; 651  :     UINT rampDelay = 0;
; 652  : 
; 653  :     if (vp == kVoltageProcessor1)
; 654  :         {
; 655  :         interruptMask = PRM_IRQENABLE_VP1_TRANXDONE_EN;

  00008	03a04902	 moveq       r4, #2, 18

; 656  :         }
; 657  :     else
; 658  :         {
; 659  :         interruptMask = PRM_IRQENABLE_VP2_TRANXDONE_EN;
; 660  :         }
; 661  :     
; 662  :     PrcmVoltEnableVp(vp, TRUE);

  0000c	e3a01001	 mov         r1, #1
  00010	e1a00005	 mov         r0, r5
  00014	13a04602	 movne       r4, #2, 12
  00018	eb000000	 bl          PrcmVoltEnableVp

; 663  :     
; 664  :     // Get the delay required 
; 665  :     rampDelay = PrcmVoltGetVoltageRampDelay(vp);

  0001c	e1a00005	 mov         r0, r5
  00020	eb000000	 bl          PrcmVoltGetVoltageRampDelay
  00024	e1a06000	 mov         r6, r0

; 666  : 
; 667  :     // clear prcm interrupts
; 668  :     PrcmInterruptClearStatus(interruptMask);

  00028	e1a00004	 mov         r0, r4
  0002c	eb000000	 bl          PrcmInterruptClearStatus

; 669  : 
; 670  :     // force SMPS voltage update through voltage processor
; 671  :     PrcmVoltFlushVoltageLevels(vp);

  00030	e1a00005	 mov         r0, r5
  00034	eb000000	 bl          PrcmVoltFlushVoltageLevels

; 672  :         
; 673  :     tcrr = OALTimerGetCount();

  00038	eb000000	 bl          OALTimerGetCount
  0003c	e1a07000	 mov         r7, r0
  00040		 |$LL3@SmartRefle@9|

; 674  :     while ((PrcmInterruptClearStatus(interruptMask) & interruptMask) == 0 &&
; 675  :         (OALTimerGetCount() - tcrr) < BSP_ONE_MILLISECOND_TICKS);

  00040	e1a00004	 mov         r0, r4
  00044	eb000000	 bl          PrcmInterruptClearStatus
  00048	e1100004	 tst         r0, r4
  0004c	1a000003	 bne         |$LN2@SmartRefle@9|
  00050	eb000000	 bl          OALTimerGetCount
  00054	e0403007	 sub         r3, r0, r7
  00058	e3530021	 cmp         r3, #0x21
  0005c	3afffff7	 bcc         |$LL3@SmartRefle@9|
  00060		 |$LN2@SmartRefle@9|

; 676  : 
; 677  :     // wait for voltage change complete
; 678  :     if (rampDelay)

  00060	e3560000	 cmp         r6, #0

; 679  :         {
; 680  :         OALStall(rampDelay);

  00064	11a00006	 movne       r0, r6
  00068	1b000000	 blne        OALStall

; 681  :         }
; 682  :     
; 683  :     PrcmVoltEnableVp(vp, FALSE);

  0006c	e3a01000	 mov         r1, #0
  00070	e1a00005	 mov         r0, r5
  00074	eb000000	 bl          PrcmVoltEnableVp

; 684  : }

  00078	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$M48004|

			 ENDP  ; |SmartReflex_VoltageFlush|

	EXPORT	|SmartReflex_EnableMonitor|
	IMPORT	|PrcmVoltIdleCheck|
	IMPORT	|PrcmDeviceEnableClocks|
	IMPORT	|PrcmVoltSetAutoControl|

  00000			 AREA	 |.pdata|, PDATA
|$T48035| DCD	|$LN27@SmartRefle@10|
	DCD	0x4000bc02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SmartReflex_EnableMonitor| PROC

; 698  : {

  00000		 |$LN27@SmartRefle@10|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M48032|
  00008	e1a09001	 mov         r9, r1
  0000c	e1a05000	 mov         r5, r0

; 699  :     VddOppSetting_t   **ppVoltDomain;
; 700  :     UINT32 tcrr;
; 701  :     VoltageProcessor_e  vp;
; 702  :     UINT interruptMask;
; 703  : 
; 704  :     if(!_bSmartreflexCapable) goto cleanUp;

  00010	e59f62d0	 ldr         r6, [pc, #0x2D0]
  00014	e5963000	 ldr         r3, [r6]
  00018	e3530000	 cmp         r3, #0
  0001c	0a0000ad	 beq         |$cleanUp$47557|

; 705  : 
; 706  :     if (_rgSmartReflexInfo[channel].bEnabled == bEnable ) goto cleanUp;

  00020	e0657185	 rsb         r7, r5, r5, lsl #3
  00024	e2863010	 add         r3, r6, #0x10
  00028	e083b107	 add         r11, r3, r7, lsl #2
  0002c	e59b3004	 ldr         r3, [r11, #4]
  00030	e58db004	 str         r11, [sp, #4]
  00034	e1530009	 cmp         r3, r9
  00038	0a0000a6	 beq         |$cleanUp$47557|

; 707  :     
; 708  :     SmartReflexLock(channel);

  0003c	e2863010	 add         r3, r6, #0x10
  00040	e1a0a107	 mov         r10, r7, lsl #2
  00044	e7ba3003	 ldr         r3, [r10, +r3]!
  00048	e3530000	 cmp         r3, #0
  0004c	0a000005	 beq         |$LN17@SmartRefle@10|
  00050	eb000000	 bl          INTERRUPTS_STATUS
  00054	e3500000	 cmp         r0, #0
  00058	12863010	 addne       r3, r6, #0x10
  0005c	12833008	 addne       r3, r3, #8
  00060	10830107	 addne       r0, r3, r7, lsl #2
  00064	1b000000	 blne        EnterCriticalSection
  00068		 |$LN17@SmartRefle@10|

; 709  : 
; 710  :     // select correct array
; 711  :     if (channel == kSmartReflex_Channel1)
; 712  :         {
; 713  :         ppVoltDomain = _SR_driver_data->ppVoltDomain1; 

  00068	e5963004	 ldr         r3, [r6, #4]
  0006c	e3550000	 cmp         r5, #0

; 714  :         interruptMask = PRM_IRQENABLE_VP1_TRANXDONE_EN;
; 715  :         vp = kVoltageProcessor1;

  00070	03a04000	 moveq       r4, #0
  00074	05938010	 ldreq       r8, [r3, #0x10]

; 716  :         }
; 717  :     else
; 718  :         {
; 719  :         ppVoltDomain = _SR_driver_data->ppVoltDomain2; 
; 720  :         interruptMask = PRM_IRQENABLE_VP2_TRANXDONE_EN;
; 721  :         vp = kVoltageProcessor2;

  00078	15938014	 ldrne       r8, [r3, #0x14]
  0007c	13a04001	 movne       r4, #1

; 722  :         }
; 723  :     
; 724  :     if (bEnable)

  00080	e3590000	 cmp         r9, #0
  00084	0a000035	 beq         |$LN6@SmartRefle@10|

; 725  :         {
; 726  :         // Disable Auto Retention and Sleep
; 727  :         PrcmVoltSetAutoControl(AUTO_SLEEP_DISABLED | AUTO_RET_DISABLED | AUTO_OFF_ENABLED, 
; 728  :                                 AUTO_SLEEP | AUTO_RET | AUTO_OFF );

  00088	e3a01007	 mov         r1, #7
  0008c	e3a00004	 mov         r0, #4
  00090	eb000000	 bl          PrcmVoltSetAutoControl

; 729  : 
; 730  :         PrcmVoltEnableVp(vp, TRUE);

  00094	e3a01001	 mov         r1, #1
  00098	e1a00004	 mov         r0, r4
  0009c	eb000000	 bl          PrcmVoltEnableVp

; 731  :         
; 732  :         // Enable Smartreflex
; 733  :         PrcmDeviceEnableClocks(
; 734  :             channel == kSmartReflex_Channel1 ? OMAP_DEVICE_SR1 : OMAP_DEVICE_SR2, 
; 735  :             TRUE
; 736  :             );

  000a0	e3550000	 cmp         r5, #0
  000a4	03a0002a	 moveq       r0, #0x2A
  000a8	13a0002b	 movne       r0, #0x2B
  000ac	e3a01001	 mov         r1, #1
  000b0	eb000000	 bl          PrcmDeviceEnableClocks

; 737  : 
; 738  :         // Set Interface Clk gating on Idle mode
; 739  :         SmartReflex_funcs->SetIdleMode(channel, SR_CLKACTIVITY_NOIDLE);

  000b4	e59f4230	 ldr         r4, [pc, #0x230]
  000b8	e3a01002	 mov         r1, #2
  000bc	e1a00005	 mov         r0, r5
  000c0	e5943000	 ldr         r3, [r4]
  000c4	e593300c	 ldr         r3, [r3, #0xC]
  000c8	e1a0e00f	 mov         lr, pc
  000cc	e12fff13	 bx          r3

; 740  :         
; 741  :         // Disable SmartReflex before updating sensor ref values
; 742  :         SmartReflex_funcs->Enable(channel, FALSE);

  000d0	e5943000	 ldr         r3, [r4]
  000d4	e3a01000	 mov         r1, #0
  000d8	e1a00005	 mov         r0, r5
  000dc	e5933028	 ldr         r3, [r3, #0x28]
  000e0	e1a0e00f	 mov         lr, pc
  000e4	e12fff13	 bx          r3

; 743  : 
; 744  :         SmartReflex_Configure(channel);

  000e8	e1a00005	 mov         r0, r5
  000ec	eb000000	 bl          SmartReflex_Configure

; 745  : 
; 746  :         // enable smartreflex
; 747  :         SmartReflex_funcs->SetSensorReferenceData(channel, 
; 748  :             &(ppVoltDomain[_rgOppVdd[channel]]->smartReflexInfo));

  000f0	e2863008	 add         r3, r6, #8
  000f4	e7933105	 ldr         r3, [r3, +r5, lsl #2]
  000f8	e5942000	 ldr         r2, [r4]
  000fc	e1a00005	 mov         r0, r5
  00100	e7981103	 ldr         r1, [r8, +r3, lsl #2]
  00104	e5923010	 ldr         r3, [r2, #0x10]
  00108	e1a0e00f	 mov         lr, pc
  0010c	e12fff13	 bx          r3

; 749  :         
; 750  :         SmartReflex_funcs->ClearInterruptStatus(channel,        
; 751  :                                          ERRCONFIG_VP_BOUNDINT_ST
; 752  :                                          );

  00110	e5943000	 ldr         r3, [r4]
  00114	e3a01101	 mov         r1, #1, 2
  00118	e1a00005	 mov         r0, r5
  0011c	e593302c	 ldr         r3, [r3, #0x2C]
  00120	e1a0e00f	 mov         lr, pc
  00124	e12fff13	 bx          r3

; 753  : 
; 754  :         SmartReflex_funcs->EnableInterrupts(channel,
; 755  :                                         (UINT) ERRCONFIG_VP_BOUNDINT_EN,
; 756  :                                         TRUE
; 757  :                                         );

  00128	e5943000	 ldr         r3, [r4]
  0012c	e3a02001	 mov         r2, #1
  00130	e3a01102	 mov         r1, #2, 2
  00134	e5933018	 ldr         r3, [r3, #0x18]
  00138	e1a00005	 mov         r0, r5
  0013c	e1a0e00f	 mov         lr, pc
  00140	e12fff13	 bx          r3

; 758  :         
; 759  :         // Enable Voltage Processor and Smart Reflex
; 760  :         SmartReflex_funcs->Enable(channel, TRUE);

  00144	e5943000	 ldr         r3, [r4]
  00148	e3a01001	 mov         r1, #1
  0014c	e1a00005	 mov         r0, r5
  00150	e5933028	 ldr         r3, [r3, #0x28]
  00154	e1a0e00f	 mov         lr, pc
  00158	e12fff13	 bx          r3

; 761  :         }
; 762  :     else

  0015c	ea000053	 b           |$LN5@SmartRefle@10|
  00160		 |$LN6@SmartRefle@10|

; 763  :         {
; 764  :         // Disable Voltage Processor
; 765  :         PrcmVoltEnableVp(vp, FALSE);

  00160	e3a01000	 mov         r1, #0
  00164	e1a00004	 mov         r0, r4
  00168	eb000000	 bl          PrcmVoltEnableVp

; 766  : 
; 767  :         // Wait till the Voltage processor is Idle
; 768  :         tcrr = OALTimerGetCount();

  0016c	eb000000	 bl          OALTimerGetCount
  00170	e3a03c01	 mov         r3, #1, 24
  00174	e383304a	 orr         r3, r3, #0x4A
  00178	e58d3000	 str         r3, [sp]
  0017c	e1a06003	 mov         r6, r3
  00180	e1a08000	 mov         r8, r0
  00184		 |$LL4@SmartRefle@10|

; 769  :         while(!PrcmVoltIdleCheck(vp) &&
; 770  :                 ((OALTimerGetCount() - tcrr) < BSP_TEN_MILLISECOND_TICKS)); 

  00184	e1a00004	 mov         r0, r4
  00188	eb000000	 bl          PrcmVoltIdleCheck
  0018c	e3500000	 cmp         r0, #0
  00190	1a000003	 bne         |$LN3@SmartRefle@10|
  00194	eb000000	 bl          OALTimerGetCount
  00198	e0403008	 sub         r3, r0, r8
  0019c	e1530006	 cmp         r3, r6
  001a0	3afffff7	 bcc         |$LL4@SmartRefle@10|
  001a4		 |$LN3@SmartRefle@10|

; 771  : 
; 772  :         SmartReflex_funcs->EnableInterrupts(channel,
; 773  :                                         ERRCONFIG_MCU_DISACKINT_EN,
; 774  :                                         TRUE
; 775  :                                         );

  001a4	e59f8140	 ldr         r8, [pc, #0x140]
  001a8	e3a02001	 mov         r2, #1
  001ac	e3a01502	 mov         r1, #2, 10
  001b0	e5983000	 ldr         r3, [r8]
  001b4	e1a00005	 mov         r0, r5
  001b8	e5933018	 ldr         r3, [r3, #0x18]
  001bc	e1a0e00f	 mov         lr, pc
  001c0	e12fff13	 bx          r3

; 776  : 
; 777  :         // Disable SmartReflex
; 778  :         SmartReflex_funcs->Enable(channel, FALSE);

  001c4	e5983000	 ldr         r3, [r8]
  001c8	e3a01000	 mov         r1, #0
  001cc	e1a00005	 mov         r0, r5
  001d0	e5933028	 ldr         r3, [r3, #0x28]
  001d4	e1a0e00f	 mov         lr, pc
  001d8	e12fff13	 bx          r3

; 779  : 
; 780  :         SmartReflex_funcs->EnableInterrupts(channel,
; 781  :                                         (UINT)ERRCONFIG_VP_BOUNDINT_EN,
; 782  :                                         FALSE
; 783  :                                         );

  001dc	e5983000	 ldr         r3, [r8]
  001e0	e3a02000	 mov         r2, #0
  001e4	e3a01102	 mov         r1, #2, 2
  001e8	e5933018	 ldr         r3, [r3, #0x18]
  001ec	e1a00005	 mov         r0, r5
  001f0	e1a0e00f	 mov         lr, pc
  001f4	e12fff13	 bx          r3

; 784  : 
; 785  :         SmartReflex_funcs->ClearInterruptStatus(channel,        
; 786  :                                          (UINT)ERRCONFIG_VP_BOUNDINT_ST
; 787  :                                          );

  001f8	e5983000	 ldr         r3, [r8]
  001fc	e3a01101	 mov         r1, #1, 2
  00200	e1a00005	 mov         r0, r5
  00204	e593302c	 ldr         r3, [r3, #0x2C]
  00208	e1a0e00f	 mov         lr, pc
  0020c	e12fff13	 bx          r3

; 788  : 
; 789  :         SmartReflex_Deconfigure(channel);

  00210	e1a00005	 mov         r0, r5
  00214	eb000000	 bl          SmartReflex_Deconfigure

; 790  : 
; 791  :         // Wait till SR is disabled
; 792  :         tcrr = OALTimerGetCount();

  00218	eb000000	 bl          OALTimerGetCount
  0021c	e1a03000	 mov         r3, r0
  00220	e59f60c0	 ldr         r6, [pc, #0xC0]
  00224	e58d3000	 str         r3, [sp]
  00228	e1a0b000	 mov         r11, r0
  0022c		 |$LL2@SmartRefle@10|

; 793  :         while(((SmartReflex_funcs->ClearInterruptStatus(channel, 
; 794  :                     ERRCONFIG_MCU_DISACKINT_ST) & ERRCONFIG_MCU_DISACKINT_ST) == 0) &&
; 795  :                     ((OALTimerGetCount() - tcrr) < BSP_ONE_MILLISECOND_TICKS)); 

  0022c	e5983000	 ldr         r3, [r8]
  00230	e3a01501	 mov         r1, #1, 10
  00234	e1a00005	 mov         r0, r5
  00238	e593302c	 ldr         r3, [r3, #0x2C]
  0023c	e1a0e00f	 mov         lr, pc
  00240	e12fff13	 bx          r3
  00244	e3100501	 tst         r0, #1, 10
  00248	1a000003	 bne         |$LN1@SmartRefle@10|
  0024c	eb000000	 bl          OALTimerGetCount
  00250	e040300b	 sub         r3, r0, r11
  00254	e3530021	 cmp         r3, #0x21
  00258	3afffff3	 bcc         |$LL2@SmartRefle@10|
  0025c		 |$LN1@SmartRefle@10|

; 796  : 
; 797  :         SmartReflex_funcs->EnableInterrupts(channel,
; 798  :                                         ERRCONFIG_MCU_DISACKINT_EN,
; 799  :                                         FALSE
; 800  :                                         );

  0025c	e5983000	 ldr         r3, [r8]
  00260	e3a02000	 mov         r2, #0
  00264	e3a01502	 mov         r1, #2, 10
  00268	e5933018	 ldr         r3, [r3, #0x18]
  0026c	e1a00005	 mov         r0, r5
  00270	e1a0e00f	 mov         lr, pc
  00274	e12fff13	 bx          r3

; 801  : 
; 802  :         // Set Interface and functional Clk gating on Idle mode
; 803  :         SmartReflex_funcs->SetIdleMode(channel, SR_CLKACTIVITY_IDLE);

  00278	e5983000	 ldr         r3, [r8]
  0027c	e3a01000	 mov         r1, #0
  00280	e1a00005	 mov         r0, r5
  00284	e593300c	 ldr         r3, [r3, #0xC]
  00288	e1a0e00f	 mov         lr, pc
  0028c	e12fff13	 bx          r3

; 804  : 
; 805  :         PrcmDeviceEnableClocks(
; 806  :             channel == kSmartReflex_Channel1 ? OMAP_DEVICE_SR1 : OMAP_DEVICE_SR2, 
; 807  :             FALSE
; 808  :             );

  00290	e3550000	 cmp         r5, #0
  00294	03a0002a	 moveq       r0, #0x2A
  00298	13a0002b	 movne       r0, #0x2B
  0029c	e3a01000	 mov         r1, #0
  002a0	eb000000	 bl          PrcmDeviceEnableClocks

; 809  : 
; 810  :         SmartReflex_VoltageFlush(vp);

  002a4	e1a00004	 mov         r0, r4
  002a8	eb000000	 bl          SmartReflex_VoltageFlush
  002ac	e59db004	 ldr         r11, [sp, #4]
  002b0		 |$LN5@SmartRefle@10|

; 811  :         }
; 812  : 
; 813  :     _rgSmartReflexInfo[channel].bEnabled = bEnable;
; 814  : 
; 815  :     SmartReflexUnlock(channel);

  002b0	e59a3000	 ldr         r3, [r10]
  002b4	e58b9004	 str         r9, [r11, #4]
  002b8	e3530000	 cmp         r3, #0
  002bc	0a000005	 beq         |$cleanUp$47557|
  002c0	eb000000	 bl          INTERRUPTS_STATUS
  002c4	e3500000	 cmp         r0, #0
  002c8	12863010	 addne       r3, r6, #0x10
  002cc	12833008	 addne       r3, r3, #8
  002d0	10830107	 addne       r0, r3, r7, lsl #2
  002d4	1b000000	 blne        LeaveCriticalSection
  002d8		 |$cleanUp$47557|

; 816  : 
; 817  : cleanUp:
; 818  :     return TRUE;

  002d8	e3a00001	 mov         r0, #1

; 819  : }

  002dc	e28dd008	 add         sp, sp, #8
  002e0	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  002e4	e12fff1e	 bx          lr
  002e8		 |$LN28@SmartRefle@10|
  002e8		 |$LN29@SmartRefle@10|
  002e8	00000000	 DCD         |_bSmartreflexCapable|
  002ec		 |$LN30@SmartRefle@10|
  002ec	00000000	 DCD         |SmartReflex_funcs|
  002f0		 |$M48033|

			 ENDP  ; |SmartReflex_EnableMonitor|

	EXPORT	|UpdateRetentionVoltages|
	EXPORT	|??_C@_1FG@JEKJNIJ@?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AAR?$AAe?$AAt?$AAe?$AAn?$AAt?$AAi?$AAo?$AAn?$AAV?$AAo?$AAl?$AAt?$AAa?$AAg?$AAe?$AAs?$AA?3?$AA?5?$AAV?$AAD?$AAD?$AA?$CF?$AAd?$AA?5?$AA?$CF@| [ DATA ] ; `string'
	IMPORT	|PrcmVoltSetInitVddLevel|
	IMPORT	|PrcmVoltSetVoltageLevel|
	IMPORT	|PrcmVoltEnableTimeout|

  00000			 AREA	 |.pdata|, PDATA
|$T48056| DCD	|$LN18@UpdateRete|
	DCD	0x40005f02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FG@JEKJNIJ@?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AAR?$AAe?$AAt?$AAe?$AAn?$AAt?$AAi?$AAo?$AAn?$AAV?$AAo?$AAl?$AAt?$AAa?$AAg?$AAe?$AAs?$AA?3?$AA?5?$AAV?$AAD?$AAD?$AA?$CF?$AAd?$AA?5?$AA?$CF@| DCB "U"
	DCB	0x0, "p", 0x0, "d", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, "R"
	DCB	0x0, "e", 0x0, "t", 0x0, "e", 0x0, "n", 0x0, "t", 0x0, "i"
	DCB	0x0, "o", 0x0, "n", 0x0, "V", 0x0, "o", 0x0, "l", 0x0, "t"
	DCB	0x0, "a", 0x0, "g", 0x0, "e", 0x0, "s", 0x0, ":", 0x0, " "
	DCB	0x0, "V", 0x0, "D", 0x0, "D", 0x0, "%", 0x0, "d", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, ".", 0x0, "%", 0x0, "0", 0x0, "4"
	DCB	0x0, "d", 0x0, "V", 0x0, " ", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UpdateRetentionVoltages| PROC

; 824  : {

  00000		 |$LN18@UpdateRete|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M48053|
  00008	e1a06000	 mov         r6, r0

; 825  :     BOOL    bEnableSmartReflex = FALSE;
; 826  :     UINT32  tcrr;
; 827  :     UINT    vp;
; 828  :     UINT    interruptMask[kVoltageProcessorCount] = {
; 829  :                             PRM_IRQENABLE_VP1_TRANXDONE_EN,
; 830  :                             PRM_IRQENABLE_VP2_TRANXDONE_EN
; 831  :                             };
; 832  : 
; 833  :     if(!_bSmartreflexCapable) goto cleanUp;

  0000c	e59f2164	 ldr         r2, [pc, #0x164]
  00010	e3a01902	 mov         r1, #2, 18
  00014	e3a00602	 mov         r0, #2, 12
  00018	e5923000	 ldr         r3, [r2]
  0001c	e3a09000	 mov         r9, #0
  00020	e58d1004	 str         r1, [sp, #4]
  00024	e3530000	 cmp         r3, #0
  00028	e58d0008	 str         r0, [sp, #8]
  0002c	0a00004c	 beq         |$cleanUp$47581|

; 834  : 
; 835  :     for (vp = kVoltageProcessor1 ; vp < kVoltageProcessorCount ; vp++)

  00030	e28d3004	 add         r3, sp, #4
  00034	e0433006	 sub         r3, r3, r6
  00038	e58d3000	 str         r3, [sp]
  0003c	e3a03c27	 mov         r3, #0x27, 24
  00040	e59f0128	 ldr         r0, [pc, #0x128]
  00044	e383b010	 orr         r11, r3, #0x10
  00048	e3a05000	 mov         r5, #0
  0004c	e2827010	 add         r7, r2, #0x10
  00050		 |$LL7@UpdateRete|

; 836  :         {
; 837  : 
; 838  :         OALMSG(1, (L"UpdateRetentionVoltages: VDD%d %d.%04dV \r\n", vp + 1, VP_VOLTS(pData->retentionVoltage[vp]), VP_MILLIVOLTS(pData->retentionVoltage[vp])));

  00050	e5963000	 ldr         r3, [r6]
  00054	e2858001	 add         r8, r5, #1
  00058	e1a01008	 mov         r1, r8
  0005c	e2832030	 add         r2, r3, #0x30
  00060	e0623282	 rsb         r3, r2, r2, lsl #5
  00064	e0824103	 add         r4, r2, r3, lsl #2
  00068	e083e094	 umull       lr, r3, r4, r0
  0006c	e59f0100	 ldr         r0, [pc, #0x100]
  00070	e1a026a3	 mov         r2, r3, lsr #13
  00074	e0030b92	 mul         r3, r2, r11
  00078	e0443003	 sub         r3, r4, r3
  0007c	eb000000	 bl          NKDbgPrintfW

; 839  : 
; 840  :         //check if SmartReflex was enabled
; 841  :         if (IsSmartReflexMonitoringEnabled(vp))

  00080	e5973004	 ldr         r3, [r7, #4]
  00084	e3530000	 cmp         r3, #0

; 842  :             {
; 843  :             bEnableSmartReflex = TRUE;
; 844  :             SmartReflex_EnableMonitor(vp, FALSE);

  00088	13a01000	 movne       r1, #0
  0008c	11a00005	 movne       r0, r5
  00090	13a09001	 movne       r9, #1
  00094	1b000000	 blne        SmartReflex_EnableMonitor

; 845  :             }
; 846  :     
; 847  :         // disable vp
; 848  :         PrcmVoltEnableVp(vp, FALSE);

  00098	e3a01000	 mov         r1, #0
  0009c	e1a00005	 mov         r0, r5
  000a0	eb000000	 bl          PrcmVoltEnableVp

; 849  :     
; 850  :         // enable voltage processor timeout
; 851  :         PrcmVoltEnableTimeout(vp, TRUE);

  000a4	e3a01001	 mov         r1, #1
  000a8	e1a00005	 mov         r0, r5
  000ac	eb000000	 bl          PrcmVoltEnableTimeout

; 852  :     
; 853  :         // update retention value
; 854  :         PrcmVoltSetVoltageLevel(
; 855  :             vp, 
; 856  :             pData->retentionVoltage[vp], 
; 857  :             SMPS_RET_MASK
; 858  :             );

  000b0	e5961000	 ldr         r1, [r6]
  000b4	e3a02cff	 mov         r2, #0xFF, 24
  000b8	e1a00005	 mov         r0, r5
  000bc	eb000000	 bl          PrcmVoltSetVoltageLevel

; 859  :         
; 860  :         PrcmVoltSetVoltageLevel(
; 861  :             vp, 
; 862  :             pData->retentionVoltage[vp], 
; 863  :             (UINT)SMPS_ON_MASK
; 864  :             );

  000c0	e5961000	 ldr         r1, [r6]
  000c4	e3a024ff	 mov         r2, #0xFF, 8
  000c8	e1a00005	 mov         r0, r5
  000cc	eb000000	 bl          PrcmVoltSetVoltageLevel

; 865  :     
; 866  :         PrcmVoltSetVoltageLevel(
; 867  :             vp, 
; 868  :             pData->retentionVoltage[vp], 
; 869  :             SMPS_ONLP_MASK
; 870  :             );

  000d0	e5961000	 ldr         r1, [r6]
  000d4	e3a028ff	 mov         r2, #0xFF, 16
  000d8	e1a00005	 mov         r0, r5
  000dc	eb000000	 bl          PrcmVoltSetVoltageLevel

; 871  :     
; 872  :         PrcmVoltSetInitVddLevel(
; 873  :             vp, 
; 874  :             pData->retentionVoltage[vp]
; 875  :             );

  000e0	e5961000	 ldr         r1, [r6]
  000e4	e1a00005	 mov         r0, r5
  000e8	eb000000	 bl          PrcmVoltSetInitVddLevel

; 876  :     
; 877  :         // enable voltage processor
; 878  :         PrcmVoltEnableVp(vp, TRUE);

  000ec	e3a01001	 mov         r1, #1
  000f0	e1a00005	 mov         r0, r5
  000f4	eb000000	 bl          PrcmVoltEnableVp

; 879  :             
; 880  :         // force SMPS voltage update through voltage processor
; 881  :         PrcmVoltFlushVoltageLevels(vp);

  000f8	e1a00005	 mov         r0, r5
  000fc	eb000000	 bl          PrcmVoltFlushVoltageLevels

; 882  :     
; 883  :         // wait for voltage change complete
; 884  :         tcrr = OALTimerGetCount();

  00100	eb000000	 bl          OALTimerGetCount
  00104	e59d3000	 ldr         r3, [sp]
  00108	e1a0a000	 mov         r10, r0
  0010c	e7934006	 ldr         r4, [r3, +r6]
  00110		 |$LL3@UpdateRete|

; 885  :         while ((PrcmInterruptClearStatus(interruptMask[vp]) & interruptMask[vp]) == 0 &&
; 886  :             (OALTimerGetCount() - tcrr) < BSP_MAX_VOLTTRANSITION_TIME);

  00110	e1a00004	 mov         r0, r4
  00114	eb000000	 bl          PrcmInterruptClearStatus
  00118	e1140000	 tst         r4, r0
  0011c	1a000003	 bne         |$LN2@UpdateRete|
  00120	eb000000	 bl          OALTimerGetCount
  00124	e040300a	 sub         r3, r0, r10
  00128	e3530064	 cmp         r3, #0x64
  0012c	3afffff7	 bcc         |$LL3@UpdateRete|
  00130		 |$LN2@UpdateRete|

; 887  :     
; 888  :     
; 889  :         // disable the voltage processor sub-chip
; 890  :         PrcmVoltEnableVp(vp, FALSE);

  00130	e3a01000	 mov         r1, #0
  00134	e1a00005	 mov         r0, r5
  00138	eb000000	 bl          PrcmVoltEnableVp

; 891  :     
; 892  :         //restore SmartReflex state	
; 893  :         if (bEnableSmartReflex == TRUE) 

  0013c	e3590001	 cmp         r9, #1

; 894  :             {
; 895  :             SmartReflex_EnableMonitor(vp, TRUE);

  00140	03a01001	 moveq       r1, #1
  00144	01a00005	 moveq       r0, r5
  00148	0b000000	 bleq        SmartReflex_EnableMonitor
  0014c	e59f001c	 ldr         r0, [pc, #0x1C]
  00150	e1a05008	 mov         r5, r8
  00154	e287701c	 add         r7, r7, #0x1C
  00158	e2866004	 add         r6, r6, #4
  0015c	e3580002	 cmp         r8, #2
  00160	3affffba	 bcc         |$LL7@UpdateRete|
  00164		 |$cleanUp$47581|

; 896  :             }
; 897  :         }
; 898  :     
; 899  : cleanUp:
; 900  :     return;
; 901  : }

  00164	e28dd00c	 add         sp, sp, #0xC
  00168	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0016c	e12fff1e	 bx          lr
  00170		 |$LN19@UpdateRete|
  00170		 |$LN20@UpdateRete|
  00170	d1b71759	 DCD         0xd1b71759
  00174		 |$LN21@UpdateRete|
  00174	00000000	 DCD         |??_C@_1FG@JEKJNIJ@?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AAR?$AAe?$AAt?$AAe?$AAn?$AAt?$AAi?$AAo?$AAn?$AAV?$AAo?$AAl?$AAt?$AAa?$AAg?$AAe?$AAs?$AA?3?$AA?5?$AAV?$AAD?$AAD?$AA?$CF?$AAd?$AA?5?$AA?$CF@|
  00178		 |$LN22@UpdateRete|
  00178	00000000	 DCD         |_bSmartreflexCapable|
  0017c		 |$M48054|

			 ENDP  ; |UpdateRetentionVoltages|

	EXPORT	|SetVoltageOppViaVoltageProcessor|
	EXPORT	|??_C@_1CE@DELMDCMO@?$AAV?$AAD?$AAD?$AA?$CF?$AAd?$AA?5?$AA?$CF?$AAd?$AA?4?$AA?$CF?$AA0?$AA4?$AAd?$AAV?$AA?5?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BO@NNGOGLGP@?$AAV?$AAd?$AAd?$AA?$CF?$AAd?$AA?$DN?$AA0?$AAx?$AA?$CF?$AA0?$AA2?$AAX?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|dpCurSettings|

  00000			 AREA	 |.pdata|, PDATA
|$T48078| DCD	|$LN12@SetVoltage|
	DCD	0x40004e01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CE@DELMDCMO@?$AAV?$AAD?$AAD?$AA?$CF?$AAd?$AA?5?$AA?$CF?$AAd?$AA?4?$AA?$CF?$AA0?$AA4?$AAd?$AAV?$AA?5?$AA?$AN?$AA?6?$AA?$AA@| DCB "V"
	DCB	0x0, "D", 0x0, "D", 0x0, "%", 0x0, "d", 0x0, " ", 0x0, "%"
	DCB	0x0, "d", 0x0, ".", 0x0, "%", 0x0, "0", 0x0, "4", 0x0, "d"
	DCB	0x0, "V", 0x0, " ", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BO@NNGOGLGP@?$AAV?$AAd?$AAd?$AA?$CF?$AAd?$AA?$DN?$AA0?$AAx?$AA?$CF?$AA0?$AA2?$AAX?$AA?$AN?$AA?6?$AA?$AA@| DCB "V"
	DCB	0x0, "d", 0x0, "d", 0x0, "%", 0x0, "d", 0x0, "=", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "0", 0x0, "2", 0x0, "X", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetVoltageOppViaVoltageProcessor| PROC

; 909  : {

  00000		 |$LN12@SetVoltage|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M48075|
  00004	e1a07001	 mov         r7, r1
  00008	e1a05000	 mov         r5, r0

; 910  :     UINT32 tcrr;
; 911  :     BOOL rc = FALSE;        
; 912  :     UINT interruptMask = (pVddOppSetting->vpInfo.vp == kVoltageProcessor1) ?
; 913  :                             PRM_IRQENABLE_VP1_TRANXDONE_EN :
; 914  :                             PRM_IRQENABLE_VP2_TRANXDONE_EN;

  0000c	e5953018	 ldr         r3, [r5, #0x18]

; 915  : 
; 916  :     // disable vp
; 917  :     PrcmVoltEnableVp(pVddOppSetting->vpInfo.vp, FALSE);

  00010	e3a01000	 mov         r1, #0
  00014	e3530000	 cmp         r3, #0
  00018	03a06902	 moveq       r6, #2, 18
  0001c	e1a00003	 mov         r0, r3
  00020	13a06602	 movne       r6, #2, 12
  00024	eb000000	 bl          PrcmVoltEnableVp

; 918  : 
; 919  :     // enable voltage processor timeout
; 920  :     PrcmVoltEnableTimeout(pVddOppSetting->vpInfo.vp, TRUE);

  00028	e5950018	 ldr         r0, [r5, #0x18]
  0002c	e3a01001	 mov         r1, #1
  00030	eb000000	 bl          PrcmVoltEnableTimeout

; 921  : 
; 922  :     OALMSG(OAL_INFO, (L"Vdd%d=0x%02X\r\n", pVddOppSetting->vpInfo.vp + 1,
; 923  :         pVddOppSetting->vpInfo.initVolt)
; 924  :         );

  00034	e59f30f8	 ldr         r3, [pc, #0xF8]
  00038	e5933440	 ldr         r3, [r3, #0x440]
  0003c	e3130008	 tst         r3, #8
  00040	15953018	 ldrne       r3, [r5, #0x18]
  00044	1595201c	 ldrne       r2, [r5, #0x1C]
  00048	159f00e0	 ldrne       r0, [pc, #0xE0]
  0004c	12831001	 addne       r1, r3, #1
  00050	1b000000	 blne        NKDbgPrintfW

; 925  : 
; 926  :     // configure voltage processor parameters
; 927  :     PrcmVoltSetVoltageLevel(
; 928  :         pVddOppSetting->vpInfo.vp, 
; 929  :         pVddOppSetting->vpInfo.initVolt, 
; 930  :         (UINT) SMPS_ON_MASK
; 931  :         );

  00054	e595101c	 ldr         r1, [r5, #0x1C]
  00058	e5950018	 ldr         r0, [r5, #0x18]
  0005c	e3a024ff	 mov         r2, #0xFF, 8
  00060	eb000000	 bl          PrcmVoltSetVoltageLevel

; 932  : 
; 933  :     OALMSG(1, (L"VDD%d %d.%04dV \r\n", pVddOppSetting->vpInfo.vp + 1, VP_VOLTS(pVddOppSetting->vpInfo.initVolt), VP_MILLIVOLTS(pVddOppSetting->vpInfo.initVolt)));

  00064	e595301c	 ldr         r3, [r5, #0x1C]
  00068	e59f10bc	 ldr         r1, [pc, #0xBC]
  0006c	e3a00c27	 mov         r0, #0x27, 24
  00070	e2832030	 add         r2, r3, #0x30
  00074	e0623282	 rsb         r3, r2, r2, lsl #5
  00078	e0824103	 add         r4, r2, r3, lsl #2
  0007c	e083e194	 umull       lr, r3, r4, r1
  00080	e3801010	 orr         r1, r0, #0x10
  00084	e1a026a3	 mov         r2, r3, lsr #13
  00088	e0030192	 mul         r3, r2, r1
  0008c	e59f0094	 ldr         r0, [pc, #0x94]
  00090	e5951018	 ldr         r1, [r5, #0x18]
  00094	e2811001	 add         r1, r1, #1
  00098	e0443003	 sub         r3, r4, r3
  0009c	eb000000	 bl          NKDbgPrintfW

; 934  : 
; 935  :     PrcmVoltSetVoltageLevel(
; 936  :         pVddOppSetting->vpInfo.vp, 
; 937  :         pVddOppSetting->vpInfo.lpVolt, 
; 938  :         (UINT) SMPS_ONLP_MASK
; 939  :         );

  000a0	e5951020	 ldr         r1, [r5, #0x20]
  000a4	e5950018	 ldr         r0, [r5, #0x18]
  000a8	e3a028ff	 mov         r2, #0xFF, 16
  000ac	eb000000	 bl          PrcmVoltSetVoltageLevel

; 940  :     
; 941  :     PrcmVoltSetVoltageLevel(
; 942  :         pVddOppSetting->vpInfo.vp, 
; 943  :         retentionVoltages[pVddOppSetting->vpInfo.vp], 
; 944  :         SMPS_RET_MASK
; 945  :         );

  000b0	e5950018	 ldr         r0, [r5, #0x18]
  000b4	e3a02cff	 mov         r2, #0xFF, 24
  000b8	e7971100	 ldr         r1, [r7, +r0, lsl #2]
  000bc	eb000000	 bl          PrcmVoltSetVoltageLevel

; 946  : 
; 947  :     PrcmVoltSetInitVddLevel(
; 948  :         pVddOppSetting->vpInfo.vp, 
; 949  :         pVddOppSetting->vpInfo.initVolt
; 950  :         );

  000c0	e595101c	 ldr         r1, [r5, #0x1C]
  000c4	e5950018	 ldr         r0, [r5, #0x18]
  000c8	eb000000	 bl          PrcmVoltSetInitVddLevel

; 951  : 
; 952  :     // clear prcm interrupts
; 953  :     PrcmInterruptClearStatus(interruptMask);

  000cc	e1a00006	 mov         r0, r6
  000d0	eb000000	 bl          PrcmInterruptClearStatus

; 954  : 
; 955  :     // enable voltage processor
; 956  :     PrcmVoltEnableVp(pVddOppSetting->vpInfo.vp, TRUE);

  000d4	e5950018	 ldr         r0, [r5, #0x18]
  000d8	e3a01001	 mov         r1, #1
  000dc	eb000000	 bl          PrcmVoltEnableVp

; 957  :         
; 958  :     // force SMPS voltage update through voltage processor
; 959  :     PrcmVoltFlushVoltageLevels(pVddOppSetting->vpInfo.vp);

  000e0	e5950018	 ldr         r0, [r5, #0x18]
  000e4	eb000000	 bl          PrcmVoltFlushVoltageLevels

; 960  : 
; 961  :     tcrr = OALTimerGetCount();

  000e8	eb000000	 bl          OALTimerGetCount
  000ec	e1a04000	 mov         r4, r0
  000f0		 |$LL2@SetVoltage|

; 962  :     while ((PrcmInterruptClearStatus(interruptMask) & interruptMask) == 0 &&
; 963  :         (OALTimerGetCount() - tcrr) < BSP_ONE_MILLISECOND_TICKS);

  000f0	e1a00006	 mov         r0, r6
  000f4	eb000000	 bl          PrcmInterruptClearStatus
  000f8	e1100006	 tst         r0, r6
  000fc	1a000003	 bne         |$LN1@SetVoltage|
  00100	eb000000	 bl          OALTimerGetCount
  00104	e0403004	 sub         r3, r0, r4
  00108	e3530021	 cmp         r3, #0x21
  0010c	3afffff7	 bcc         |$LL2@SetVoltage|
  00110		 |$LN1@SetVoltage|

; 964  : 
; 965  :     // disable the voltage processor sub-chip
; 966  :     PrcmVoltEnableVp(pVddOppSetting->vpInfo.vp, FALSE);

  00110	e5950018	 ldr         r0, [r5, #0x18]
  00114	e3a01000	 mov         r1, #0
  00118	eb000000	 bl          PrcmVoltEnableVp

; 967  : 
; 968  :     rc = TRUE;
; 969  : 
; 970  :     return rc;

  0011c	e3a00001	 mov         r0, #1

; 971  : }

  00120	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00124	e12fff1e	 bx          lr
  00128		 |$LN13@SetVoltage|
  00128		 |$LN14@SetVoltage|
  00128	00000000	 DCD         |??_C@_1CE@DELMDCMO@?$AAV?$AAD?$AAD?$AA?$CF?$AAd?$AA?5?$AA?$CF?$AAd?$AA?4?$AA?$CF?$AA0?$AA4?$AAd?$AAV?$AA?5?$AA?$AN?$AA?6?$AA?$AA@|
  0012c		 |$LN15@SetVoltage|
  0012c	d1b71759	 DCD         0xd1b71759
  00130		 |$LN16@SetVoltage|
  00130	00000000	 DCD         |??_C@_1BO@NNGOGLGP@?$AAV?$AAd?$AAd?$AA?$CF?$AAd?$AA?$DN?$AA0?$AAx?$AA?$CF?$AA0?$AA2?$AAX?$AA?$AN?$AA?6?$AA?$AA@|
  00134		 |$LN17@SetVoltage|
  00134	00000000	 DCD         |dpCurSettings|
  00138		 |$M48076|

			 ENDP  ; |SetVoltageOppViaVoltageProcessor|

	EXPORT	|SetFrequencyOpp|
	IMPORT	|PrcmClockSetDpllFrequency|

  00000			 AREA	 |.pdata|, PDATA
|$T48096| DCD	|$LN10@SetFrequen|
	DCD	0x40001802
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetFrequencyOpp| PROC

; 978  : {

  00000		 |$LN10@SetFrequen|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M48093|
  00008	e1a04000	 mov         r4, r0

; 979  :     int i;
; 980  :     BOOL rc = FALSE;
; 981  : 
; 982  :     // iterate through and set the dpll frequency settings    
; 983  :     for (i = 0; i < pVddOppSetting->dpllCount; ++i)

  0000c	e5943024	 ldr         r3, [r4, #0x24]
  00010	e3a06000	 mov         r6, #0
  00014	e3530000	 cmp         r3, #0
  00018	da00000c	 ble         |$LN1@SetFrequen|
  0001c	e1a05004	 mov         r5, r4
  00020		 |$LL3@SetFrequen|

; 984  :         {
; 985  :         PrcmClockSetDpllFrequency(
; 986  :             pVddOppSetting->rgFrequencySettings[i].dpllId,
; 987  :             pVddOppSetting->rgFrequencySettings[i].m,
; 988  :             pVddOppSetting->rgFrequencySettings[i].n,
; 989  :             pVddOppSetting->rgFrequencySettings[i].freqSel,
; 990  :             pVddOppSetting->rgFrequencySettings[i].outputDivisor
; 991  :             );

  00020	e595e03c	 ldr         lr, [r5, #0x3C]
  00024	e5953038	 ldr         r3, [r5, #0x38]
  00028	e5952034	 ldr         r2, [r5, #0x34]
  0002c	e5951030	 ldr         r1, [r5, #0x30]
  00030	e5950028	 ldr         r0, [r5, #0x28]
  00034	e58de000	 str         lr, [sp]
  00038	eb000000	 bl          PrcmClockSetDpllFrequency
  0003c	e5943024	 ldr         r3, [r4, #0x24]
  00040	e2866001	 add         r6, r6, #1
  00044	e2855018	 add         r5, r5, #0x18
  00048	e1560003	 cmp         r6, r3
  0004c	bafffff3	 blt         |$LL3@SetFrequen|
  00050		 |$LN1@SetFrequen|

; 992  :         };
; 993  : 
; 994  :     rc = TRUE;
; 995  : 
; 996  :     return rc;

  00050	e3a00001	 mov         r0, #1

; 997  : }

  00054	e28dd004	 add         sp, sp, #4
  00058	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$M48094|

			 ENDP  ; |SetFrequencyOpp|

	EXPORT	|SetVoltageOpp|

  00000			 AREA	 |.pdata|, PDATA
|$T48106| DCD	|$LN5@SetVoltage@2|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetVoltageOpp| PROC

; 1004 : {

  00000		 |$LN5@SetVoltage@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M48103|

; 1005 :     return SetVoltageOppViaVoltageProcessor(pVddOppSetting,_rgInitialRetentionVoltages);

  00004	e59f1008	 ldr         r1, [pc, #8]
  00008	eb000000	 bl          SetVoltageOppViaVoltageProcessor

; 1006 : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$LN6@SetVoltage@2|
  00014		 |$LN7@SetVoltage@2|
  00014	00000000	 DCD         |_rgInitialRetentionVoltages|
  00018		 |$M48104|

			 ENDP  ; |SetVoltageOpp|

	EXPORT	|Opp_init|

  00000			 AREA	 |.pdata|, PDATA
|$T48116| DCD	|$LN8@Opp_init|
	DCD	0x40001100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Opp_init| PROC

; 1009 : {

  00000		 |$LN8@Opp_init|
  00000		 |$M48113|

; 1010 :     if(g_dwCpuFamily == CPU_FAMILY_DM37XX)

  00000	e59f3038	 ldr         r3, [pc, #0x38]

; 1011 :     {
; 1012 :         _rgOppVdd[0] = Vdd1_init_val_37xx[BSP_OPM_SELECT_37XX];

  00004	e59f2030	 ldr         r2, [pc, #0x30]
  00008	e5933000	 ldr         r3, [r3]
  0000c	e3530001	 cmp         r3, #1
  00010	e59f3020	 ldr         r3, [pc, #0x20]

; 1013 :         _Max_Vdd1_OPP	 = MAX_VDD1_OPP_37xx;

  00014	03a01003	 moveq       r1, #3

; 1014 :     }
; 1015 :     else
; 1016 :     {
; 1017 :         _rgOppVdd[0] = Vdd1_init_val_35xx[BSP_OPM_SELECT_35XX];
; 1018 :         _Max_Vdd1_OPP	 = MAX_VDD1_OPP_35xx;

  00018	13a01005	 movne       r1, #5
  0001c	0593302c	 ldreq       r3, [r3, #0x2C]
  00020	e5821040	 str         r1, [r2, #0x40]
  00024	15933014	 ldrne       r3, [r3, #0x14]
  00028	e5823000	 str         r3, [r2]

; 1019 : 		
; 1020 :     }
; 1021 : 
; 1022 :     _rgOppVdd[1] = INITIAL_VDD2_OPP;

  0002c	e3a03001	 mov         r3, #1
  00030	e5823004	 str         r3, [r2, #4]

; 1023 : 	
; 1024 : }

  00034	e12fff1e	 bx          lr
  00038		 |$LN9@Opp_init|
  00038		 |$LN10@Opp_init|
  00038	00000000	 DCD         |Vdd1_init_val_35xx|
  0003c		 |$LN11@Opp_init|
  0003c	00000000	 DCD         |_rgOppVdd|
  00040		 |$LN12@Opp_init|
  00040	00000000	 DCD         |g_dwCpuFamily|
  00044		 |$M48114|

			 ENDP  ; |Opp_init|

	EXPORT	|SetOpp|
	EXPORT	|??_C@_1CA@OACLPOKB@?$AAS?$AAe?$AAt?$AAO?$AAp?$AAp?$AA?5?$AAt?$AAo?$AA?5?$AA?$CF?$AAd?$AA?5?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|OALWakeupLatency_UpdateOpp|
	IMPORT	|OEMWriteDebugLED|
	IMPORT	|PrcmVoltSetErrorConfiguration|
	IMPORT	|PrcmVoltScaleVoltageABB|

  00000			 AREA	 |.pdata|, PDATA
|$T48156| DCD	|$LN37@SetOpp|
	DCD	0x40007802

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CA@OACLPOKB@?$AAS?$AAe?$AAt?$AAO?$AAp?$AAp?$AA?5?$AAt?$AAo?$AA?5?$AA?$CF?$AAd?$AA?5?$AA?$AN?$AA?6?$AA?$AA@| DCB "S"
	DCB	0x0, "e", 0x0, "t", 0x0, "O", 0x0, "p", 0x0, "p", 0x0, " "
	DCB	0x0, "t", 0x0, "o", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, " "
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetOpp| PROC

; 1032 : {

  00000		 |$LN37@SetOpp|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M48153|
  00008	e1b03002	 movs        r3, r2
  0000c	e1a02000	 mov         r2, r0
  00010	e1a0a001	 mov         r10, r1
  00014	e58d2010	 str         r2, [sp, #0x10]
  00018	e58d300c	 str         r3, [sp, #0xC]
  0001c	e58da008	 str         r10, [sp, #8]

; 1033 :     UINT                opp;
; 1034 :     UINT                i;
; 1035 :     int                 vdd = 0;
; 1036 :     VddOppSetting_t   **ppVoltDomain;
; 1037 :     BOOL                bEnableSmartReflex = FALSE;
; 1038 :     VoltageProcessorErrConfig_t *ErrConfig;
; 1039 : 
; 1040 : 
; 1041 :     // loop through and update all changing voltage domains
; 1042 :     //
; 1043 :     for (i = 0; i < count; ++i)

  00020	e3a01000	 mov         r1, #0
  00024	e59f61b0	 ldr         r6, [pc, #0x1B0]
  00028	e58d1004	 str         r1, [sp, #4]
  0002c	0a000057	 beq         |$LN17@SetOpp|
  00030	e042200a	 sub         r2, r2, r10
  00034	e1a0700a	 mov         r7, r10
  00038	e58d2000	 str         r2, [sp]
  0003c	e1a0a003	 mov         r10, r3
  00040		 |$LL19@SetOpp|

; 1044 :         {
; 1045 :         // select the Opp table to use
; 1046 :         switch (rgDomains[i])

  00040	e7923007	 ldr         r3, [r2, +r7]
  00044	e3530000	 cmp         r3, #0
  00048	0a00000a	 beq         |$LN12@SetOpp|
  0004c	e3530010	 cmp         r3, #0x10
  00050	1a00004a	 bne         |$LN18@SetOpp|

; 1047 :             {
; 1048 :             case DVFS_MPU1_OPP:
; 1049 :                 vdd = kVDD1;
; 1050 :                 if (rgOpps[i] > _Max_Vdd1_OPP) continue;

  00054	e5974000	 ldr         r4, [r7]
  00058	e5963044	 ldr         r3, [r6, #0x44]
  0005c	e3a05000	 mov         r5, #0
  00060	e1540003	 cmp         r4, r3
  00064	8a000045	 bhi         |$LN18@SetOpp|

; 1051 :                 ppVoltDomain = _SR_driver_data->ppVoltDomain1; 

  00068	e5963000	 ldr         r3, [r6]
  0006c	e5938010	 ldr         r8, [r3, #0x10]

; 1052 :                 ErrConfig = _SR_driver_data->Vp1ErrConfig;

  00070	e5939018	 ldr         r9, [r3, #0x18]

; 1053 :                 break;

  00074	ea000006	 b           |$LN15@SetOpp|
  00078		 |$LN12@SetOpp|

; 1054 :                 
; 1055 :             case DVFS_CORE1_OPP:
; 1056 :                 // validate parameters
; 1057 :                 if (rgOpps[i] > MAX_VDD2_OPP) continue;

  00078	e5974000	 ldr         r4, [r7]
  0007c	e3540001	 cmp         r4, #1
  00080	8a00003e	 bhi         |$LN18@SetOpp|

; 1058 :                 
; 1059 :                 vdd = kVDD2;
; 1060 :                 ppVoltDomain = _SR_driver_data->ppVoltDomain2; 

  00084	e5963000	 ldr         r3, [r6]
  00088	e3a05001	 mov         r5, #1
  0008c	e5938014	 ldr         r8, [r3, #0x14]

; 1061 :                 ErrConfig = _SR_driver_data->Vp2ErrConfig;

  00090	e593901c	 ldr         r9, [r3, #0x1C]
  00094		 |$LN15@SetOpp|

; 1062 :                 break;
; 1063 :                 
; 1064 :             default:
; 1065 :                 continue;
; 1066 :             }
; 1067 : 
; 1068 :         // check if the operating point is actually changing
; 1069 :         opp = rgOpps[i];
; 1070 :         OALMSG(1, (L"SetOpp to %d \r\n", opp));

  00094	e59f013c	 ldr         r0, [pc, #0x13C]
  00098	e1a01004	 mov         r1, r4
  0009c	eb000000	 bl          NKDbgPrintfW

; 1071 :         if (_rgOppVdd[vdd] == opp) continue;

  000a0	e286b004	 add         r11, r6, #4
  000a4	e7bb3105	 ldr         r3, [r11, +r5, lsl #2]!
  000a8	e1530004	 cmp         r3, r4
  000ac	0a000032	 beq         |$LN33@SetOpp|

; 1072 : 
; 1073 :         // disable smartreflex if it's enabled
; 1074 :         if (IsSmartReflexMonitoringEnabled(vdd))

  000b0	e0653185	 rsb         r3, r5, r5, lsl #3
  000b4	e286200c	 add         r2, r6, #0xC
  000b8	e0823103	 add         r3, r2, r3, lsl #2
  000bc	e5933004	 ldr         r3, [r3, #4]
  000c0	e3530000	 cmp         r3, #0

; 1075 :             {
; 1076 :             bEnableSmartReflex = TRUE;
; 1077 :             SmartReflex_EnableMonitor(vdd, FALSE);

  000c4	13a03001	 movne       r3, #1
  000c8	13a01000	 movne       r1, #0
  000cc	11a00005	 movne       r0, r5
  000d0	158d3004	 strne       r3, [sp, #4]
  000d4	1b000000	 blne        SmartReflex_EnableMonitor

; 1078 :             }
; 1079 : 
; 1080 :         // depending on which way the transition is occurring change
; 1081 :         // the frequency and voltage levels in the proper order
; 1082 :         if (opp > _rgOppVdd[vdd])

  000d8	e59b3000	 ldr         r3, [r11]

; 1083 :             {
; 1084 :             // transitioning to higher performance, change voltage first
; 1085 :             SetVoltageOpp(ppVoltDomain[opp]);

  000dc	e7b80104	 ldr         r0, [r8, +r4, lsl #2]!
  000e0	e1540003	 cmp         r4, r3
  000e4	9a00000a	 bls         |$LN7@SetOpp|
  000e8	e59f10e4	 ldr         r1, [pc, #0xE4]
  000ec	eb000000	 bl          SetVoltageOppViaVoltageProcessor

; 1086 :                 if ((vdd == kVDD1)&& (g_dwCpuFamily == CPU_FAMILY_DM37XX))

  000f0	e3550000	 cmp         r5, #0
  000f4	059f30d4	 ldreq       r3, [pc, #0xD4]
  000f8	05933000	 ldreq       r3, [r3]
  000fc	03530001	 cmpeq       r3, #1

; 1087 :                     PrcmVoltScaleVoltageABB(opp);

  00100	01a00004	 moveq       r0, r4
  00104	0b000000	 bleq        PrcmVoltScaleVoltageABB

; 1088 :             SetFrequencyOpp(ppVoltDomain[opp]);         

  00108	e5980000	 ldr         r0, [r8]
  0010c	eb000000	 bl          SetFrequencyOpp

; 1089 :             }
; 1090 :         else

  00110	ea00000b	 b           |$LN4@SetOpp|
  00114		 |$LN7@SetOpp|

; 1091 :             {
; 1092 :             // transitioning to lower performance, change frequency first
; 1093 :             SetFrequencyOpp(ppVoltDomain[opp]); 

  00114	eb000000	 bl          SetFrequencyOpp

; 1094 :             SetVoltageOpp(ppVoltDomain[opp]);         

  00118	e5980000	 ldr         r0, [r8]
  0011c	e59f10b0	 ldr         r1, [pc, #0xB0]
  00120	eb000000	 bl          SetVoltageOppViaVoltageProcessor

; 1095 :                 if ((vdd == kVDD1)&& (g_dwCpuFamily == CPU_FAMILY_DM37XX))

  00124	e3550000	 cmp         r5, #0
  00128	1a000009	 bne         |$LN3@SetOpp|
  0012c	e59f309c	 ldr         r3, [pc, #0x9C]
  00130	e5933000	 ldr         r3, [r3]
  00134	e3530001	 cmp         r3, #1
  00138	1a000003	 bne         |$LN30@SetOpp|

; 1096 :                     PrcmVoltScaleVoltageABB(opp);

  0013c	e1a00004	 mov         r0, r4
  00140	eb000000	 bl          PrcmVoltScaleVoltageABB
  00144		 |$LN4@SetOpp|

; 1097 :             }
; 1098 : 
; 1099 :         if (vdd == kVDD1)

  00144	e3550000	 cmp         r5, #0
  00148	1a000001	 bne         |$LN3@SetOpp|
  0014c		 |$LN30@SetOpp|

; 1100 :             {
; 1101 :             PrcmVoltSetErrorConfiguration(kVoltageProcessor1, 
; 1102 :                                           ErrConfig[opp].errOffset, 
; 1103 :                                           ErrConfig[opp].errGain);

  0014c	e3a00000	 mov         r0, #0

; 1104 :             }
; 1105 :         else

  00150	ea000000	 b           |$LN34@SetOpp|
  00154		 |$LN3@SetOpp|

; 1106 :             {
; 1107 :             PrcmVoltSetErrorConfiguration(kVoltageProcessor2, 
; 1108 :                                           ErrConfig[opp].errOffset, 
; 1109 :                                           ErrConfig[opp].errGain);

  00154	e3a00001	 mov         r0, #1
  00158		 |$LN34@SetOpp|
  00158	e7b92184	 ldr         r2, [r9, +r4, lsl #3]!
  0015c	e5991004	 ldr         r1, [r9, #4]
  00160	eb000000	 bl          PrcmVoltSetErrorConfiguration

; 1110 :             }
; 1111 :             
; 1112 :         // update opp for voltage domain
; 1113 :         _rgOppVdd[vdd] = opp;
; 1114 : 
; 1115 :         // re-enable smartreflex if previously enabled
; 1116 :         if (bEnableSmartReflex == TRUE) 

  00164	e59d3004	 ldr         r3, [sp, #4]
  00168	e58b4000	 str         r4, [r11]
  0016c	e3530001	 cmp         r3, #1

; 1117 :             {
; 1118 :             SmartReflex_EnableMonitor(vdd, TRUE);

  00170	03a01001	 moveq       r1, #1
  00174	01a00005	 moveq       r0, r5
  00178	0b000000	 bleq        SmartReflex_EnableMonitor
  0017c		 |$LN33@SetOpp|

; 1033 :     UINT                opp;
; 1034 :     UINT                i;
; 1035 :     int                 vdd = 0;
; 1036 :     VddOppSetting_t   **ppVoltDomain;
; 1037 :     BOOL                bEnableSmartReflex = FALSE;
; 1038 :     VoltageProcessorErrConfig_t *ErrConfig;
; 1039 : 
; 1040 : 
; 1041 :     // loop through and update all changing voltage domains
; 1042 :     //
; 1043 :     for (i = 0; i < count; ++i)

  0017c	e59d2000	 ldr         r2, [sp]

; 1117 :             {
; 1118 :             SmartReflex_EnableMonitor(vdd, TRUE);

  00180		 |$LN18@SetOpp|
  00180	e2877004	 add         r7, r7, #4
  00184	e25aa001	 subs        r10, r10, #1
  00188	1affffac	 bne         |$LL19@SetOpp|

; 1032 : {

  0018c	e59da008	 ldr         r10, [sp, #8]
  00190		 |$LN17@SetOpp|

; 1119 :             }
; 1120 :         }
; 1121 : 
; 1122 :     OALLED(LED_IDX_MPU_VDD, (_rgOppVdd[kVDD1] + 1));

  00190	e5963004	 ldr         r3, [r6, #4]
  00194	e3a0000f	 mov         r0, #0xF
  00198	e2831001	 add         r1, r3, #1
  0019c	eb000000	 bl          OEMWriteDebugLED

; 1123 :     OALLED(LED_IDX_CORE_VDD, (_rgOppVdd[kVDD2] + 1));

  001a0	e5963008	 ldr         r3, [r6, #8]
  001a4	e3a0000e	 mov         r0, #0xE
  001a8	e2831001	 add         r1, r3, #1
  001ac	eb000000	 bl          OEMWriteDebugLED

; 1124 :                 
; 1125 :     // update latency table
; 1126 :     OALWakeupLatency_UpdateOpp(rgDomains, rgOpps, count);

  001b0	e59d200c	 ldr         r2, [sp, #0xC]
  001b4	e59d0010	 ldr         r0, [sp, #0x10]
  001b8	e1a0100a	 mov         r1, r10
  001bc	eb000000	 bl          OALWakeupLatency_UpdateOpp

; 1127 :     
; 1128 :     return TRUE;    

  001c0	e3a00001	 mov         r0, #1

; 1129 : }

  001c4	e28dd014	 add         sp, sp, #0x14
  001c8	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001cc	e12fff1e	 bx          lr
  001d0		 |$LN38@SetOpp|
  001d0		 |$LN39@SetOpp|
  001d0	00000000	 DCD         |g_dwCpuFamily|
  001d4		 |$LN40@SetOpp|
  001d4	00000000	 DCD         |_rgInitialRetentionVoltages|
  001d8		 |$LN41@SetOpp|
  001d8	00000000	 DCD         |??_C@_1CA@OACLPOKB@?$AAS?$AAe?$AAt?$AAO?$AAp?$AAp?$AA?5?$AAt?$AAo?$AA?5?$AA?$CF?$AAd?$AA?5?$AA?$AN?$AA?6?$AA?$AA@|
  001dc		 |$LN42@SetOpp|
  001dc	00000000	 DCD         |_SR_driver_data|
  001e0		 |$M48154|

			 ENDP  ; |SetOpp|

	EXPORT	|SmartReflex_Initialize|
	EXPORT	|??_C@_1HM@FDKIOMPF@?$AA?$AN?$AA?6?$AAS?$AAm?$AAa?$AAr?$AAt?$AAR?$AAe?$AAf?$AAl?$AAe?$AAx?$AA_?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?3?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AAS@| [ DATA ] ; `string'
	IMPORT	|SmartReflex_Get_functions_hander|

  00000			 AREA	 |.pdata|, PDATA
|$T48170| DCD	|$LN10@SmartRefle@11|
	DCD	0x40003701

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HM@FDKIOMPF@?$AA?$AN?$AA?6?$AAS?$AAm?$AAa?$AAr?$AAt?$AAR?$AAe?$AAf?$AAl?$AAe?$AAx?$AA_?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?3?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AAS@| DCB 0xd
	DCB	0x0, 0xa, 0x0, "S", 0x0, "m", 0x0, "a", 0x0, "r", 0x0, "t"
	DCB	0x0, "R", 0x0, "e", 0x0, "f", 0x0, "l", 0x0, "e", 0x0, "x"
	DCB	0x0, "_", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, "i"
	DCB	0x0, "a", 0x0, "l", 0x0, "i", 0x0, "z", 0x0, "e", 0x0, ":"
	DCB	0x0, " ", 0x0, "N", 0x0, "U", 0x0, "L", 0x0, "L", 0x0, " "
	DCB	0x0, "S", 0x0, "m", 0x0, "a", 0x0, "r", 0x0, "t", 0x0, "R"
	DCB	0x0, "e", 0x0, "f", 0x0, "l", 0x0, "e", 0x0, "x", 0x0, " "
	DCB	0x0, "f", 0x0, "u", 0x0, "n", 0x0, "c", 0x0, "t", 0x0, "i"
	DCB	0x0, "o", 0x0, "n", 0x0, " ", 0x0, "p", 0x0, "o", 0x0, "i"
	DCB	0x0, "n", 0x0, "t", 0x0, "e", 0x0, "r", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SmartReflex_Initialize| PROC

; 511  : {

  00000		 |$LN10@SmartRefle@11|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M48167|

; 512  :     if(g_dwCpuFamily == CPU_FAMILY_DM37XX)

  00004	e59f30cc	 ldr         r3, [pc, #0xCC]

; 513  :     {
; 514  :         _SR_driver_data = &_SR_driver_data_37xx;

  00008	e59f40c4	 ldr         r4, [pc, #0xC4]

; 515  :     }
; 516  :     else
; 517  :     {
; 518  :         _SR_driver_data = &_SR_driver_data_35xx;
; 519  :     }
; 520  : 
; 521  :     // Initialize the voltage processor with the current OPP voltage.
; 522  :     SmartReflex_VoltageFlush(kVoltageProcessor1);

  0000c	e3a00000	 mov         r0, #0
  00010	e5933000	 ldr         r3, [r3]
  00014	e3530001	 cmp         r3, #1
  00018	e59f30b0	 ldr         r3, [pc, #0xB0]
  0001c	02833020	 addeq       r3, r3, #0x20
  00020	e5843000	 str         r3, [r4]
  00024	eb000000	 bl          SmartReflex_VoltageFlush

; 523  :     SmartReflex_VoltageFlush(kVoltageProcessor2);

  00028	e3a00001	 mov         r0, #1
  0002c	eb000000	 bl          SmartReflex_VoltageFlush

; 524  : 
; 525  :     SmartReflex_Read_EFUSE();

  00030	eb000000	 bl          SmartReflex_Read_EFUSE

; 526  :     SmartReflex_funcs = SmartReflex_Get_functions_hander(_SR_driver_data->SmartReflex_rev);	

  00034	e5943000	 ldr         r3, [r4]
  00038	e5930000	 ldr         r0, [r3]
  0003c	eb000000	 bl          SmartReflex_Get_functions_hander
  00040	e59f4084	 ldr         r4, [pc, #0x84]
  00044	e3500000	 cmp         r0, #0
  00048	e5840000	 str         r0, [r4]

; 527  : 
; 528  :     if(SmartReflex_funcs == NULL)

  0004c	1a000007	 bne         |$LN1@SmartRefle@11|

; 529  :     {
; 530  :         OALMSG( OAL_ERROR, (L"\r\nSmartReflex_Initialize: NULL SmartReflex function pointer\r\n"));

  00050	e59f3070	 ldr         r3, [pc, #0x70]
  00054	e5933440	 ldr         r3, [r3, #0x440]
  00058	e3130001	 tst         r3, #1
  0005c	0a000016	 beq         |$Cleanup$47513|
  00060	e59f005c	 ldr         r0, [pc, #0x5C]
  00064	eb000000	 bl          NKDbgPrintfW

; 540  : Cleanup:
; 541  :     return;
; 542  : }

  00068	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0006c	e12fff1e	 bx          lr
  00070		 |$LN1@SmartRefle@11|

; 531  :         goto Cleanup;

  00070	e3a05312	 mov         r5, #0x12, 6

; 532  :     }
; 533  :     // initialize smartreflex library
; 534  :     SmartReflex_funcs->InitializeChannel(kSmartReflex_Channel1, 
; 535  :         OALPAtoVA(OMAP_SMARTREFLEX1_PA, FALSE)
; 536  :         );

  00074	e3850ac9	 orr         r0, r5, #0xC9, 20
  00078	e3a01000	 mov         r1, #0
  0007c	eb000000	 bl          OALPAtoVA
  00080	e5943000	 ldr         r3, [r4]
  00084	e1a01000	 mov         r1, r0
  00088	e3a00000	 mov         r0, #0
  0008c	e5933000	 ldr         r3, [r3]
  00090	e1a0e00f	 mov         lr, pc
  00094	e12fff13	 bx          r3

; 537  :     SmartReflex_funcs->InitializeChannel(kSmartReflex_Channel2, 
; 538  :         OALPAtoVA(OMAP_SMARTREFLEX2_PA, FALSE)
; 539  :         );

  00098	e3a01000	 mov         r1, #0
  0009c	e3850acb	 orr         r0, r5, #0xCB, 20
  000a0	eb000000	 bl          OALPAtoVA
  000a4	e5943000	 ldr         r3, [r4]
  000a8	e1a01000	 mov         r1, r0
  000ac	e3a00001	 mov         r0, #1
  000b0	e5933000	 ldr         r3, [r3]
  000b4	e1a0e00f	 mov         lr, pc
  000b8	e12fff13	 bx          r3
  000bc		 |$Cleanup$47513|

; 540  : Cleanup:
; 541  :     return;
; 542  : }

  000bc	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000c0	e12fff1e	 bx          lr
  000c4		 |$LN11@SmartRefle@11|
  000c4		 |$LN12@SmartRefle@11|
  000c4	00000000	 DCD         |??_C@_1HM@FDKIOMPF@?$AA?$AN?$AA?6?$AAS?$AAm?$AAa?$AAr?$AAt?$AAR?$AAe?$AAf?$AAl?$AAe?$AAx?$AA_?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?3?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AAS@|
  000c8		 |$LN13@SmartRefle@11|
  000c8	00000000	 DCD         |dpCurSettings|
  000cc		 |$LN14@SmartRefle@11|
  000cc	00000000	 DCD         |SmartReflex_funcs|
  000d0		 |$LN15@SmartRefle@11|
  000d0	00000000	 DCD         |_SR_driver_data_35xx|
  000d4		 |$LN16@SmartRefle@11|
  000d4	00000000	 DCD         |_SR_driver_data|
  000d8		 |$LN17@SmartRefle@11|
  000d8	00000000	 DCD         |g_dwCpuFamily|
  000dc		 |$M48168|

			 ENDP  ; |SmartReflex_Initialize|

	END
