; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\Z2170P\SRC\OAL\OALLIB\oem_intrex.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.bss|, NOINIT
|s_swInterruptMask| % 0x4
|s_logIndex| %	0x4

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|OALSWIntrSetDataIrq|
	IMPORT	|__utos|
	IMPORT	|__divs|
	IMPORT	|__stou|

  00008			 AREA	 |.bss|, NOINIT
|s_maxBucketSize| % 0x4
|s_idleThreshold| % 0x4
|s_maxBucketSize| % 0x4
; File c:\wince600\platform\z2170p\src\oal\oallib\oem_intrex.c

  00000			 AREA	 |.pdata|, PDATA
|$T46949| DCD	|$LN8@OALSWIntrS|
	DCD	0x40001401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALSWIntrSetDataIrq| PROC

; 74   : {

  00000		 |$LN8@OALSWIntrS|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46946|

; 75   :     DWORD dwVal;
; 76   : 
; 77   :     UNREFERENCED_PARAMETER(cbData);
; 78   : 
; 79   :     if (irq == IRQ_SW_CPUMONITOR)

  00004	e3500065	 cmp         r0, #0x65
  00008	1a00000d	 bne         |$LN1@OALSWIntrS|

; 80   :         {
; 81   :         // value is in cpu_load_%, convert to idle_load_%
; 82   :         dwVal = min(100, *(DWORD*)pvData);

  0000c	e5913000	 ldr         r3, [r1]
  00010	e3530064	 cmp         r3, #0x64
  00014	83a03064	 movhi       r3, #0x64

; 83   :         dwVal = 100 - dwVal;
; 84   : 
; 85   :         // convert idle threshold to 0.8f
; 86   :         s_idleThreshold = (DWORD)((float)(256*dwVal)/100.0f);

  00018	e2633064	 rsb         r3, r3, #0x64
  0001c	e1a00403	 mov         r0, r3, lsl #8
  00020	eb000000	 bl          __utos
  00024	e3a03442	 mov         r3, #0x42, 8
  00028	e3831732	 orr         r1, r3, #0x32, 14
  0002c	eb000000	 bl          __divs
  00030	eb000000	 bl          __stou
  00034	e59f3010	 ldr         r3, [pc, #0x10]

; 87   :         s_maxBucketSize = HISTORY_PERIOD / HISTORY_COUNT;

  00038	e3a02a02	 mov         r2, #2, 20
  0003c	e583000c	 str         r0, [r3, #0xC]
  00040	e5832000	 str         r2, [r3]
  00044		 |$LN1@OALSWIntrS|

; 88   :         }
; 89   : }

  00044	e49de004	 ldr         lr, [sp], #4
  00048	e12fff1e	 bx          lr
  0004c		 |$LN9@OALSWIntrS|
  0004c		 |$LN10@OALSWIntrS|
  0004c	00000000	 DCD         |s_maxBucketSize|
  00050		 |$M46947|

			 ENDP  ; |OALSWIntrSetDataIrq|

	EXPORT	|OALSWIntrEnableIrq|
	IMPORT	|memset|

  00014			 AREA	 |.bss|, NOINIT
|s_idleSum| %	0x4
|s_tickSum| %	0x4
|s_idleSum| %	0x4
|s_TickLog| %	0x20

  00000			 AREA	 |.pdata|, PDATA
|$T46962| DCD	|$LN6@OALSWIntrE|
	DCD	0x40001801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALSWIntrEnableIrq| PROC

; 101  : {   

  00000		 |$LN6@OALSWIntrE|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M46959|
  00004	e1a05000	 mov         r5, r0

; 102  :     if (irq == IRQ_SW_CPUMONITOR)

  00008	e59f404c	 ldr         r4, [pc, #0x4C]
  0000c	e3550065	 cmp         r5, #0x65
  00010	1a000009	 bne         |$LN1@OALSWIntrE|

; 103  :         {
; 104  :         // reset cpu monitor counters
; 105  :         s_tickSum = 0;
; 106  :         s_idleSum = 0;

  00014	e3a02000	 mov         r2, #0

; 107  :         s_logIndex = 0;        

  00018	e3a01000	 mov         r1, #0
  0001c	e5842000	 str         r2, [r4]
  00020	e5841030	 str         r1, [r4, #0x30]
  00024	e3a03000	 mov         r3, #0

; 108  :         memset(&s_TickLog, 0, sizeof(TICK_LOG));        

  00028	e3a02020	 mov         r2, #0x20
  0002c	e3a01000	 mov         r1, #0
  00030	e284000c	 add         r0, r4, #0xC
  00034	e5843008	 str         r3, [r4, #8]
  00038	eb000000	 bl          memset
  0003c		 |$LN1@OALSWIntrE|

; 109  :         }
; 110  :     s_swInterruptMask |= (1 << (irq - IRQ_SW_RTC_QUERY));

  0003c	e594202c	 ldr         r2, [r4, #0x2C]
  00040	e2453064	 sub         r3, r5, #0x64
  00044	e3a01001	 mov         r1, #1
  00048	e1823311	 orr         r3, r2, r1, lsl r3

; 111  :     return TRUE;

  0004c	e3a00001	 mov         r0, #1
  00050	e584302c	 str         r3, [r4, #0x2C]

; 112  : }

  00054	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$LN7@OALSWIntrE|
  0005c		 |$LN8@OALSWIntrE|
  0005c	00000000	 DCD         |s_idleSum|
  00060		 |$M46960|

			 ENDP  ; |OALSWIntrEnableIrq|

	EXPORT	|OALSWIntrDisableIrq|

  00000			 AREA	 |.pdata|, PDATA
|$T46972| DCD	|$LN6@OALSWIntrD|
	DCD	0x40001701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALSWIntrDisableIrq| PROC

; 124  : {

  00000		 |$LN6@OALSWIntrD|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M46969|
  00004	e1a05000	 mov         r5, r0

; 125  :     if (irq == IRQ_SW_CPUMONITOR)

  00008	e59f4048	 ldr         r4, [pc, #0x48]
  0000c	e3550065	 cmp         r5, #0x65
  00010	1a000009	 bne         |$LN1@OALSWIntrD|

; 126  :         {
; 127  :         // reset cpu monitor counters
; 128  :         s_tickSum = 0;
; 129  :         s_idleSum = 0;

  00014	e3a02000	 mov         r2, #0

; 130  :         s_logIndex = 0;

  00018	e3a01000	 mov         r1, #0
  0001c	e5842000	 str         r2, [r4]
  00020	e5841030	 str         r1, [r4, #0x30]
  00024	e3a03000	 mov         r3, #0

; 131  :         memset(&s_TickLog, 0, sizeof(TICK_LOG));

  00028	e3a02020	 mov         r2, #0x20
  0002c	e3a01000	 mov         r1, #0
  00030	e284000c	 add         r0, r4, #0xC
  00034	e5843008	 str         r3, [r4, #8]
  00038	eb000000	 bl          memset
  0003c		 |$LN1@OALSWIntrD|

; 132  :         }
; 133  :     s_swInterruptMask &= ~(1 << (irq - IRQ_SW_RTC_QUERY));

  0003c	e594302c	 ldr         r3, [r4, #0x2C]
  00040	e2452064	 sub         r2, r5, #0x64
  00044	e3a01001	 mov         r1, #1
  00048	e1c33211	 bic         r3, r3, r1, lsl r2
  0004c	e584302c	 str         r3, [r4, #0x2C]

; 134  : }

  00050	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$LN7@OALSWIntrD|
  00058		 |$LN8@OALSWIntrD|
  00058	00000000	 DCD         |s_idleSum|
  0005c		 |$M46970|

			 ENDP  ; |OALSWIntrDisableIrq|

	EXPORT	|OALSWIntrDoneIrq|

  00000			 AREA	 |.pdata|, PDATA
|$T46982| DCD	|$LN5@OALSWIntrD@2|
	DCD	0x40000800
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALSWIntrDoneIrq| PROC

; 146  : {    

  00000		 |$LN5@OALSWIntrD@2|
  00000		 |$M46979|

; 147  :     s_swInterruptMask |= (1 << (irq - IRQ_SW_RTC_QUERY));

  00000	e59f1014	 ldr         r1, [pc, #0x14]
  00004	e2402064	 sub         r2, r0, #0x64
  00008	e3a00001	 mov         r0, #1
  0000c	e5913000	 ldr         r3, [r1]
  00010	e1833210	 orr         r3, r3, r0, lsl r2
  00014	e5813000	 str         r3, [r1]

; 148  : }

  00018	e12fff1e	 bx          lr
  0001c		 |$LN6@OALSWIntrD@2|
  0001c		 |$LN7@OALSWIntrD@2|
  0001c	00000000	 DCD         |s_swInterruptMask|
  00020		 |$M46980|

			 ENDP  ; |OALSWIntrDoneIrq|

	EXPORT	|OALTickTimerIntr|
	IMPORT	|OALIntrTranslateIrq|
	IMPORT	|g_pNKGlobal|
	IMPORT	|OALTimerGetCount|
	IMPORT	|__rt_udiv64by64|

  00040			 AREA	 |.bss|, NOINIT
|s_tcrrCount| %	0x4
|s_idleCount| %	0x4
|s_tcrrCount| %	0x4

  00000			 AREA	 |.pdata|, PDATA
|$T47017| DCD	|$LN26@OALTickTim|
	DCD	0x4000a302
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALTickTimerIntr| PROC

; 159  : {

  00000		 |$LN26@OALTickTim|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd01c	 sub         sp, sp, #0x1C
  00008		 |$M47014|

; 171  :     DWORD tickRemove = 0;

  00008	e3a03000	 mov         r3, #0
  0000c	e58d300c	 str         r3, [sp, #0xC]

; 172  :     BOOL bRatioCalculated = FALSE;

  00010	e3a03000	 mov         r3, #0
  00014	e3a0b000	 mov         r11, #0
  00018	e58d3008	 str         r3, [sp, #8]
  0001c	e3a09000	 mov         r9, #0
  00020	e58db004	 str         r11, [sp, #4]

; 173  :     UINT32 sysIntr = SYSINTR_NOP;

  00024	e3a0a000	 mov         r10, #0

; 174  :    
; 175  :     currentTick = OALTimerGetCount();

  00028	eb000000	 bl          OALTimerGetCount

; 176  :     if (s_swInterruptMask & (1 << (IRQ_SW_CPUMONITOR - IRQ_SW_RTC_QUERY)))

  0002c	e59f4254	 ldr         r4, [pc, #0x254]
  00030	e58d0010	 str         r0, [sp, #0x10]
  00034	e5943038	 ldr         r3, [r4, #0x38]
  00038	e3130002	 tst         r3, #2
  0003c	0a000086	 beq         |$LN19@OALTickTim|

; 177  :         {
; 178  :         // calculate idle time and active time since last gptimer interrupt
; 179  :         idleTime = curridlelow - s_idleCount;

  00040	e59f323c	 ldr         r3, [pc, #0x23C]

; 180  :         tickTime = currentTick - s_tcrrCount;

  00044	e594e000	 ldr         lr, [r4]

; 181  : 
; 182  :         // typically cpuload is calculated as 
; 183  :         // idle_threshold >= idleTime/activeTime
; 184  :         //
; 185  :         // to remove division us following eq. instead
; 186  :         //  idle_threshold * activeTime >= idleTime
; 187  :         //
; 188  :         idleTotalTime = idleTime + s_idleSum;
; 189  :         tickTotalTime = tickTime + s_tickSum;

  00048	e5947014	 ldr         r7, [r4, #0x14]
  0004c	e5933000	 ldr         r3, [r3]
  00050	e5941008	 ldr         r1, [r4, #8]

; 190  :         tickTotalTime *= s_idleThreshold;    //24.8f

  00054	e5942010	 ldr         r2, [r4, #0x10]
  00058	e59300d0	 ldr         r0, [r3, #0xD0]
  0005c	e59d3010	 ldr         r3, [sp, #0x10]
  00060	e594800c	 ldr         r8, [r4, #0xC]
  00064	e0406001	 sub         r6, r0, r1
  00068	e043500e	 sub         r5, r3, lr
  0006c	e0873005	 add         r3, r7, r5
  00070	e0020293	 mul         r2, r3, r2
  00074	e0883006	 add         r3, r8, r6

; 191  :         tickTotalTime >>= 8;                 //32.0f
; 192  : 
; 193  :         if (idleTotalTime <= tickTotalTime && s_tickSum > 0)

  00078	e1530422	 cmp         r3, r2, lsr #8
  0007c	8a000007	 bhi         |$LN10@OALTickTim|
  00080	e3570000	 cmp         r7, #0
  00084	0a000005	 beq         |$LN10@OALTickTim|

; 194  :             {
; 195  :             OALSWIntrDisableIrq(IRQ_SW_CPUMONITOR);

  00088	e3a00065	 mov         r0, #0x65
  0008c	eb000000	 bl          OALSWIntrDisableIrq

; 196  :             sysIntr = OALIntrTranslateIrq(IRQ_SW_CPUMONITOR);

  00090	e3a00065	 mov         r0, #0x65
  00094	eb000000	 bl          OALIntrTranslateIrq
  00098	e1a0a000	 mov         r10, r0

; 197  :             }
; 198  :         else 

  0009c	ea00006e	 b           |$LN19@OALTickTim|
  000a0		 |$LN10@OALTickTim|

; 199  :             {
; 200  :             // Need to check if ticktime exceeds maximum history time.
; 201  :             if (tickTime > HISTORY_PERIOD)

  000a0	e3550902	 cmp         r5, #2, 18
  000a4	9a00000c	 bls         |$LN22@OALTickTim|

; 202  :                 {                
; 203  :                 ratio = (DWORD)(((UINT64)idleTime << 16) / (UINT64)tickTime); // u0.16

  000a8	e1a00806	 mov         r0, r6, lsl #16
  000ac	e1a01826	 mov         r1, r6, lsr #16
  000b0	e1a02005	 mov         r2, r5
  000b4	e3a03000	 mov         r3, #0
  000b8	eb000000	 bl          __rt_udiv64by64
  000bc	e1a09000	 mov         r9, r0

; 204  :                 bRatioCalculated = TRUE;
; 205  : 
; 206  :                 // update idleTime and tickTime to maximum allowed period
; 207  :                 idleTime -= (((tickTime - HISTORY_PERIOD) * ratio) >> 16);

  000c0	e2453902	 sub         r3, r5, #2, 18
  000c4	e0020993	 mul         r2, r3, r9

; 208  :                 tickTime = HISTORY_PERIOD;

  000c8	e3a05902	 mov         r5, #2, 18
  000cc	e0466822	 sub         r6, r6, r2, lsr #16
  000d0	e3a02001	 mov         r2, #1
  000d4	e58d2008	 str         r2, [sp, #8]
  000d8	ea000000	 b           |$LN8@OALTickTim|
  000dc		 |$LN22@OALTickTim|

; 262  :                 s_TickLog.rgIdleCount[s_logIndex] = 0;

  000dc	e3a02000	 mov         r2, #0

; 208  :                 tickTime = HISTORY_PERIOD;

  000e0		 |$LN8@OALTickTim|

; 209  :                 }
; 210  :             
; 211  :             // update sum with the amount of tick and idle time that is
; 212  :             // being added to the sum
; 213  :             //
; 214  :             remainder = 0x8000;
; 215  :             s_tickSum = s_tickSum + tickTime;

  000e0	e0873005	 add         r3, r7, r5
  000e4	e58d3014	 str         r3, [sp, #0x14]

; 216  :             s_idleSum = s_idleSum + idleTime;

  000e8	e0883006	 add         r3, r8, r6
  000ec	e3a00902	 mov         r0, #2, 18
  000f0	e58d3018	 str         r3, [sp, #0x18]
  000f4	e58d0000	 str         r0, [sp]

; 217  :             
; 218  :             while (tickTime > 0)

  000f8	e3550000	 cmp         r5, #0
  000fc	0a00004f	 beq         |$LN20@OALTickTim|
  00100	e594703c	 ldr         r7, [r4, #0x3C]
  00104	e2843018	 add         r3, r4, #0x18
  00108	e0838107	 add         r8, r3, r7, lsl #2
  0010c		 |$LN23@OALTickTim|
  0010c	e5941004	 ldr         r1, [r4, #4]

; 219  :                 {
; 220  :                 bucketSpace = s_maxBucketSize - s_TickLog.rgTickCount[s_logIndex];

  00110	e598e000	 ldr         lr, [r8]
  00114	e051b00e	 subs        r11, r1, lr

; 221  :                 if (bucketSpace > 0)

  00118	0a000027	 beq         |$LN5@OALTickTim|

; 222  :                     {
; 223  :                     // check if current tick count will fit into bucket
; 224  :                     if (tickTime <= bucketSpace)

  0011c	e155000b	 cmp         r5, r11
  00120	9a00003b	 bls         |$LN17@OALTickTim|

; 228  :                         break;
; 229  :                         }
; 230  : 
; 231  :                     if (bRatioCalculated == FALSE)

  00124	e3520000	 cmp         r2, #0
  00128	1a000009	 bne         |$LN3@OALTickTim|

; 232  :                         { 
; 233  :                         ratio = (DWORD)(((UINT64)idleTime << 16) / (UINT64)tickTime); // u0.16

  0012c	e1a00806	 mov         r0, r6, lsl #16
  00130	e1a01826	 mov         r1, r6, lsr #16
  00134	e1a02005	 mov         r2, r5
  00138	e3a03000	 mov         r3, #0
  0013c	eb000000	 bl          __rt_udiv64by64

; 234  :                         bRatioCalculated = TRUE;

  00140	e3a03001	 mov         r3, #1
  00144	e598e000	 ldr         lr, [r8]
  00148	e1a09000	 mov         r9, r0
  0014c	e59d0000	 ldr         r0, [sp]
  00150	e58d3008	 str         r3, [sp, #8]
  00154		 |$LN3@OALTickTim|

; 235  :                         }
; 236  : 
; 237  :                     if (ratio == 0)

  00154	e3590000	 cmp         r9, #0

; 238  :                         {
; 239  :                         idleDelta = 0;

  00158	03a00000	 moveq       r0, #0
  0015c	0a00000c	 beq         |$LN15@OALTickTim|

; 240  :                         }
; 241  :                     else
; 242  :                         {
; 243  :                         // calculate how many idle and tick counts to add into bucket   
; 244  :                         preDelta = (UINT64)bucketSpace * (UINT64)ratio;             // u32.16

  00160	e083199b	 umull       r1, r3, r11, r9

; 245  :                         idleDelta = (DWORD)((preDelta + (UINT64)remainder) >> 16);  // u32                 

  00164	e0902001	 adds        r2, r0, r1
  00168	e2a33000	 adc         r3, r3, #0
  0016c	e1a03803	 mov         r3, r3, lsl #16
  00170	e1830822	 orr         r0, r3, r2, lsr #16

; 246  :                         remainder = ((DWORD)preDelta + remainder) & 0xFFFF;         // u0.16

  00174	e59d3000	 ldr         r3, [sp]

; 247  :                         idleDelta = min(idleDelta, idleTime);

  00178	e1500006	 cmp         r0, r6
  0017c	21a00006	 movcs       r0, r6
  00180	e0813003	 add         r3, r1, r3
  00184	e3a01cff	 mov         r1, #0xFF, 24
  00188	e38120ff	 orr         r2, r1, #0xFF
  0018c	e0033002	 and         r3, r3, r2
  00190	e58d3000	 str         r3, [sp]
  00194		 |$LN15@OALTickTim|

; 248  :                         }
; 249  : 
; 250  :                     // update buckets and leftover times
; 251  :                     s_TickLog.rgTickCount[s_logIndex] += bucketSpace;

  00194	e08e300b	 add         r3, lr, r11
  00198	e5883000	 str         r3, [r8]

; 252  :                     s_TickLog.rgIdleCount[s_logIndex] += idleDelta;

  0019c	e2843018	 add         r3, r4, #0x18
  001a0	e0832107	 add         r2, r3, r7, lsl #2
  001a4	e5923010	 ldr         r3, [r2, #0x10]

; 253  :                     tickTime -= bucketSpace;
; 254  :                     idleTime -= idleDelta;

  001a8	e0466000	 sub         r6, r6, r0
  001ac	e045500b	 sub         r5, r5, r11
  001b0	e0833000	 add         r3, r3, r0
  001b4	e59d0000	 ldr         r0, [sp]
  001b8	e5823010	 str         r3, [r2, #0x10]
  001bc		 |$LN5@OALTickTim|

; 255  :                     }
; 256  :                 
; 257  :                 // update with next log                
; 258  :                 s_logIndex = (s_logIndex + 1) & HISTORY_MASK;

  001bc	e2873001	 add         r3, r7, #1
  001c0	e2037003	 and         r7, r3, #3

; 259  :                 tickRemove += s_TickLog.rgTickCount[s_logIndex];

  001c4	e1a08107	 mov         r8, r7, lsl #2
  001c8	e2843018	 add         r3, r4, #0x18
  001cc	e7b81003	 ldr         r1, [r8, +r3]!

; 260  :                 idleRemove += s_TickLog.rgIdleCount[s_logIndex];

  001d0	e2843018	 add         r3, r4, #0x18
  001d4	e0833107	 add         r3, r3, r7, lsl #2
  001d8	e5932010	 ldr         r2, [r3, #0x10]

; 261  :                 s_TickLog.rgTickCount[s_logIndex] = 0;

  001dc	e3a0e000	 mov         lr, #0
  001e0	e588e000	 str         lr, [r8]

; 262  :                 s_TickLog.rgIdleCount[s_logIndex] = 0;

  001e4	e583e010	 str         lr, [r3, #0x10]
  001e8	e59d300c	 ldr         r3, [sp, #0xC]
  001ec	e584703c	 str         r7, [r4, #0x3C]
  001f0	e3550000	 cmp         r5, #0
  001f4	e0833001	 add         r3, r3, r1
  001f8	e58d300c	 str         r3, [sp, #0xC]
  001fc	e59d3004	 ldr         r3, [sp, #4]
  00200	e0833002	 add         r3, r3, r2
  00204	e58d3004	 str         r3, [sp, #4]
  00208	0a00000b	 beq         |$LN21@OALTickTim|
  0020c	e59d2008	 ldr         r2, [sp, #8]
  00210	eaffffbd	 b           |$LN23@OALTickTim|
  00214		 |$LN17@OALTickTim|

; 225  :                         {
; 226  :                         s_TickLog.rgTickCount[s_logIndex] += tickTime;

  00214	e1a00107	 mov         r0, r7, lsl #2
  00218	e2843018	 add         r3, r4, #0x18
  0021c	e7b02003	 ldr         r2, [r0, +r3]!

; 227  :                         s_TickLog.rgIdleCount[s_logIndex] += idleTime;                       

  00220	e2843018	 add         r3, r4, #0x18
  00224	e0831107	 add         r1, r3, r7, lsl #2
  00228	e0853002	 add         r3, r5, r2
  0022c	e5803000	 str         r3, [r0]
  00230	e5913010	 ldr         r3, [r1, #0x10]
  00234	e0833006	 add         r3, r3, r6
  00238	e5813010	 str         r3, [r1, #0x10]
  0023c		 |$LN21@OALTickTim|

; 160  :     DWORD ratio = 0;    
; 161  :     DWORD idleTime;
; 162  :     DWORD tickTime;
; 163  :     UINT64 preDelta;
; 164  :     DWORD remainder;
; 165  :     DWORD idleDelta;
; 166  :     DWORD bucketSpace;
; 167  :     DWORD currentTick;
; 168  :     DWORD idleTotalTime;
; 169  :     DWORD tickTotalTime;
; 170  :     DWORD idleRemove = 0;

  0023c	e59db004	 ldr         r11, [sp, #4]
  00240		 |$LN20@OALTickTim|

; 263  :                 }
; 264  : 
; 265  :             // update sum with the amount of tick and idle time that
; 266  :             // is being removed
; 267  :             s_tickSum -= tickRemove;

  00240	e59d300c	 ldr         r3, [sp, #0xC]
  00244	e59d2014	 ldr         r2, [sp, #0x14]
  00248	e0423003	 sub         r3, r2, r3

; 268  :             s_idleSum -= idleRemove;

  0024c	e59d2018	 ldr         r2, [sp, #0x18]
  00250	e5843014	 str         r3, [r4, #0x14]
  00254	e042200b	 sub         r2, r2, r11
  00258	e584200c	 str         r2, [r4, #0xC]
  0025c		 |$LN19@OALTickTim|
  0025c	e59f3020	 ldr         r3, [pc, #0x20]

; 269  :             }       
; 270  :         }
; 271  : 
; 272  :     // keep track of timer information
; 273  :     s_tcrrCount = currentTick;

  00260	e59d2010	 ldr         r2, [sp, #0x10]

; 274  :     s_idleCount = curridlelow;
; 275  : 
; 276  :     return sysIntr;
; 277  : }

  00264	e1a0000a	 mov         r0, r10
  00268	e5933000	 ldr         r3, [r3]
  0026c	e5842000	 str         r2, [r4]
  00270	e59330d0	 ldr         r3, [r3, #0xD0]
  00274	e5843008	 str         r3, [r4, #8]
  00278	e28dd01c	 add         sp, sp, #0x1C
  0027c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00280	e12fff1e	 bx          lr
  00284		 |$LN27@OALTickTim|
  00284		 |$LN28@OALTickTim|
  00284	00000000	 DCD         |g_pNKGlobal|
  00288		 |$LN29@OALTickTim|
  00288	00000000	 DCD         |s_tcrrCount|
  0028c		 |$M47015|

			 ENDP  ; |OALTickTimerIntr|

	END
