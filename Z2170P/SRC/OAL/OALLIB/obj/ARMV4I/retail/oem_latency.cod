; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\Z2170P\SRC\OAL\OALLIB\oem_latency.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|k32khzFrequency| [ DATA ]

  00000			 AREA	 |.bss|, NOINIT
|_vddCore| %	0x4
|_suspendState| % 0x4
|_domainInactiveMask| % 0x4
|_domainRetentionMask| % 0x4
|_coreDevice| %	0x4
|_otherDevice| % 0x4
|s_coreOffWaitTickCount| % 0x4
|s_tickRollOver| % 0x4

  00000			 AREA	 |.data|, DATA
|_rgLatencyOffsetTable| DCD 0x39afa2f0			; 0.000335
	DCD	0x3ba20147				; 0.004944
	DCD	0x393673c5				; 0.000174
	DCD	0x370637bd				; 8e-006
	DCD	0x383cbe62				; 4.5e-005
	DCD	0x383cbe62				; 4.5e-005
	DCD	0x383cbe62				; 4.5e-005
	DCD	0x39afa2f0				; 0.000335
	DCD	0x3b99fa12				; 0.004699
	DCD	0x3908509c				; 0.00013
	DCD	0x370637bd				; 8e-006
	DCD	0x383cbe62				; 4.5e-005
	DCD	0x383cbe62				; 4.5e-005
	DCD	0x383cbe62				; 4.5e-005
	DCD	0x39afa2f0				; 0.000335
	DCD	0x3b37f5a5				; 0.002807
	DCD	0x38d1b717				; 0.0001
	DCD	0x370637bd				; 8e-006
	DCD	0x383cbe62				; 4.5e-005
	DCD	0x383cbe62				; 4.5e-005
	DCD	0x383cbe62				; 4.5e-005
	DCD	0x39afa2f0				; 0.000335
	DCD	0x3b37f5a5				; 0.002807
	DCD	0x3890b418				; 6.9e-005
	DCD	0x370637bd				; 8e-006
	DCD	0x383cbe62				; 4.5e-005
	DCD	0x383cbe62				; 4.5e-005
	DCD	0x383cbe62				; 4.5e-005
	DCD	0x39afa2f0				; 0.000335
	DCD	0x3b37f5a5				; 0.002807
	DCD	0x3890b418				; 6.9e-005
	DCD	0x370637bd				; 8e-006
	DCD	0x383cbe62				; 4.5e-005
	DCD	0x383cbe62				; 4.5e-005
	DCD	0x383cbe62				; 4.5e-005
	DCD	0x39afa2f0				; 0.000335
	DCD	0x3b37f5a5				; 0.002807
	DCD	0x3890b418				; 6.9e-005
	DCD	0x370637bd				; 8e-006
	DCD	0x383cbe62				; 4.5e-005
	DCD	0x383cbe62				; 4.5e-005
	DCD	0x383cbe62				; 4.5e-005
	DCD	0x39afa2f0				; 0.000335
	DCD	0x3b37f5a5				; 0.002807
	DCD	0x3890b418				; 6.9e-005
	DCD	0x370637bd				; 8e-006
	DCD	0x383cbe62				; 4.5e-005
	DCD	0x383cbe62				; 4.5e-005
	DCD	0x383cbe62				; 4.5e-005
	DCD	0x0					; 0
	DCD	0x0					; 0
	DCD	0x0					; 0
	DCD	0x0					; 0
	DCD	0x0					; 0
	DCD	0x0					; 0
	DCD	0x0					; 0
	DCD	0x0					; 0
	DCD	0x0					; 0
	DCD	0x0					; 0
	DCD	0x0					; 0
	DCD	0x0					; 0
	DCD	0x0					; 0
	DCD	0x0					; 0
|_bOffMode_SignalMode| DCD 0x1
|_mapLatencyTransitionTable| DCD 0x0
	DCD	0x1
	DCD	0x2
	DCD	0x3
	DCD	0x4
	DCD	0x5
	DCD	0xffffffff
	DCD	0x1
	DCD	0x2
	DCD	0x3
	DCD	0x4
	DCD	0x5
	DCD	0xffffffff
	%	4
	DCD	0x2
	DCD	0x3
	DCD	0x4
	DCD	0x5
	DCD	0xffffffff
	%	8
	DCD	0x3
	DCD	0x4
	DCD	0x5
	DCD	0xffffffff
	%	12
	DCD	0x4
	DCD	0x5
	DCD	0xffffffff
	%	16
	DCD	0x5
	DCD	0xffffffff
	%	20
|_mapLatencyIndex| DCD 0x0
	DCD	0x1
	DCD	0x1
	DCD	0x1
	DCD	0x1
	DCD	0x1
	DCD	0x1
	DCD	0x1
	DCD	0x1
	DCD	0x2
	DCD	0x2
	DCD	0x2
	DCD	0x2
	DCD	0x2
	DCD	0x2
	DCD	0x2
	DCD	0x2
	DCD	0x2
	DCD	0x3
	DCD	0x3
	DCD	0x3
	DCD	0x3
	DCD	0x3
	DCD	0x3
	DCD	0x3
	DCD	0x3
	DCD	0x3
	DCD	0x4
	DCD	0x4
	DCD	0x4
	DCD	0x4
	DCD	0x4
	DCD	0x4
	DCD	0x4
	DCD	0x4
	DCD	0x4
	DCD	0x5
	DCD	0x5
	DCD	0x5
	DCD	0x5
	DCD	0x5
	DCD	0x5
	DCD	0x5
	DCD	0x5
	DCD	0x5
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
	DCD	0x6
|_vddMpu| DCD	0x2
|_domainMpu| DCD 0x3
|_domainCore| DCD 0x3
|_logicCore| DCD 0x4

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
|k32khzFrequency| DCD 0x8000
	IMPORT	|EnterCriticalSection|

  00020			 AREA	 |.bss|, NOINIT
|_csLatency| %	0x14
|_csLatency| %	0x14
; File c:\wince600\platform\z2170p\src\oal\oallib\oem_latency.c

  00000			 AREA	 |.pdata|, PDATA
|$T47344| DCD	|$LN5@OALWakeupL|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |_OALWakeupLatency_Lock| PROC

; 230  : {    

  00000		 |$LN5@OALWakeupL|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M47341|

; 231  :     // check if constraint needs to be updated
; 232  :     EnterCriticalSection(&_csLatency);

  00004	e59f0008	 ldr         r0, [pc, #8]
  00008	eb000000	 bl          EnterCriticalSection

; 233  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$LN6@OALWakeupL|
  00014		 |$LN7@OALWakeupL|
  00014	00000000	 DCD         |_csLatency|
  00018		 |$M47342|

			 ENDP  ; |_OALWakeupLatency_Lock|

	IMPORT	|LeaveCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T47353| DCD	|$LN5@OALWakeupL@2|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |_OALWakeupLatency_Unlock| PROC

; 244  : {    

  00000		 |$LN5@OALWakeupL@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M47350|

; 245  :     // check if constraint needs to be updated
; 246  :     LeaveCriticalSection(&_csLatency);

  00004	e59f0008	 ldr         r0, [pc, #8]
  00008	eb000000	 bl          LeaveCriticalSection

; 247  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$LN6@OALWakeupL@2|
  00014		 |$LN7@OALWakeupL@2|
  00014	00000000	 DCD         |_csLatency|
  00018		 |$M47351|

			 ENDP  ; |_OALWakeupLatency_Unlock|

	EXPORT	|OALWakeupLatency_Initialize|
	EXPORT	|??_C@_1BBK@MCBACDBJ@?$AAo?$AAp?$AAm?$AA?$CF?$AAd?$AA?3?$AA?5?$AAc?$AAh?$AAi?$AAp?$AAO?$AAf?$AAf?$AAO?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?3?$AA?$CF?$AAd?$AA?0?$AA?$CF?$AAd?$AA?5?$AAc?$AAh?$AAi?$AAp?$AAO@| [ DATA ] ; `string'
	IMPORT	|NKDbgPrintfW|
	IMPORT	|dpCurSettings|
	IMPORT	|PrcmClockGetSystemClockFrequency|
	IMPORT	|g_pPrcmPrm|
	IMPORT	|InitializeCriticalSection|
	IMPORT	|__utos|
	IMPORT	|__divs|
	IMPORT	|__gts|
	IMPORT	|__adds|
	IMPORT	|__muls|
	IMPORT	|__stou|

  00048			 AREA	 |.bss|, NOINIT
|_rgLatencyTable| % 0x1e0
|_rgLatencyTable| % 0x1e0

  00000			 AREA	 |.pdata|, PDATA
|$T47390| DCD	|$LN17@OALWakeupL@3|
	DCD	0x4000be02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BBK@MCBACDBJ@?$AAo?$AAp?$AAm?$AA?$CF?$AAd?$AA?3?$AA?5?$AAc?$AAh?$AAi?$AAp?$AAO?$AAf?$AAf?$AAO?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?3?$AA?$CF?$AAd?$AA?0?$AA?$CF?$AAd?$AA?5?$AAc?$AAh?$AAi?$AAp?$AAO@| DCB "o"
	DCB	0x0, "p", 0x0, "m", 0x0, "%", 0x0, "d", 0x0, ":", 0x0, " "
	DCB	0x0, "c", 0x0, "h", 0x0, "i", 0x0, "p", 0x0, "O", 0x0, "f"
	DCB	0x0, "f", 0x0, "O", 0x0, "f", 0x0, "f", 0x0, "s", 0x0, "e"
	DCB	0x0, "t", 0x0, ":", 0x0, "%", 0x0, "d", 0x0, ",", 0x0, "%"
	DCB	0x0, "d", 0x0, " ", 0x0, "c", 0x0, "h", 0x0, "i", 0x0, "p"
	DCB	0x0, "O", 0x0, "S", 0x0, "W", 0x0, "R", 0x0, "O", 0x0, "f"
	DCB	0x0, "f", 0x0, "s", 0x0, "e", 0x0, "t", 0x0, ":", 0x0, "%"
	DCB	0x0, "d", 0x0, ",", 0x0, "%", 0x0, "d", 0x0, " ", 0x0, "c"
	DCB	0x0, "h", 0x0, "i", 0x0, "p", 0x0, "C", 0x0, "S", 0x0, "W"
	DCB	0x0, "R", 0x0, "O", 0x0, "f", 0x0, "f", 0x0, "s", 0x0, "e"
	DCB	0x0, "t", 0x0, ":", 0x0, "%", 0x0, "d", 0x0, ",", 0x0, "%"
	DCB	0x0, "d", 0x0, " ", 0x0, "c", 0x0, "o", 0x0, "r", 0x0, "e"
	DCB	0x0, "C", 0x0, "S", 0x0, "W", 0x0, "R", 0x0, "O", 0x0, "f"
	DCB	0x0, "f", 0x0, "s", 0x0, "e", 0x0, "t", 0x0, ":", 0x0, "%"
	DCB	0x0, "d", 0x0, ",", 0x0, "%", 0x0, "d", 0x0, " ", 0x0, "c"
	DCB	0x0, "o", 0x0, "r", 0x0, "e", 0x0, "I", 0x0, "n", 0x0, "a"
	DCB	0x0, "c", 0x0, "t", 0x0, "i", 0x0, "v", 0x0, "e", 0x0, "O"
	DCB	0x0, "f", 0x0, "f", 0x0, "s", 0x0, "e", 0x0, "t", 0x0, ":"
	DCB	0x0, "%", 0x0, "d", 0x0, ",", 0x0, "%", 0x0, "d", 0x0, " "
	DCB	0x0, "m", 0x0, "p", 0x0, "u", 0x0, "I", 0x0, "n", 0x0, "a"
	DCB	0x0, "c", 0x0, "t", 0x0, "i", 0x0, "v", 0x0, "e", 0x0, "O"
	DCB	0x0, "f", 0x0, "f", 0x0, "s", 0x0, "e", 0x0, "t", 0x0, ":"
	DCB	0x0, "%", 0x0, "d", 0x0, ",", 0x0, "%", 0x0, "d", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALWakeupLatency_Initialize| PROC

; 259  : {

  00000		 |$LN17@OALWakeupL@3|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd028	 sub         sp, sp, #0x28
  00008		 |$M47387|

; 260  :     int i;
; 261  :     DWORD voltSetup1;
; 262  :     float latencyTime;
; 263  :     float fixedOffset;
; 264  :     float clkSetupTime;
; 265  :     float clkOffSetupTime;
; 266  :     float voltRetentionSetupTime;    
; 267  :     float voltOffsetTime;    
; 268  :     float voltOffSetupTime;    
; 269  : 
; 270  :     #ifdef DEBUG_PRCM_SUSPEND_RESUME
; 271  :         for (i = 0; i < OMAP_DEVICE_COUNT; i++)
; 272  :     	    DeviceEnabledCount[i] = 0;
; 273  :     #endif
; 274  : 			
; 275  :     // initialize synchronization objects
; 276  :     InitializeCriticalSection(&_csLatency);

  00008	e59f52e4	 ldr         r5, [pc, #0x2E4]
  0000c	e2850f79	 add         r0, r5, #0x79, 30
  00010	eb000000	 bl          InitializeCriticalSection

; 277  : 
; 278  :     // get sys_clk setup times for offmode and other sleep modes
; 279  :     clkSetupTime = ((float)BSP_PRM_CLKSETUP)/(float)k32khzFrequency;
; 280  :     clkOffSetupTime = ((float)BSP_PRM_CLKSETUP_OFFMODE)/(float)k32khzFrequency;
; 281  : 
; 282  :     // get vdd setup offset for off and sleep modes
; 283  :     voltOffsetTime = (float)INREG32(&g_pPrcmPrm->pOMAP_GLOBAL_PRM->PRM_VOLTOFFSET);

  00014	e59f42d4	 ldr         r4, [pc, #0x2D4]
  00018	e5943000	 ldr         r3, [r4]
  0001c	e593302c	 ldr         r3, [r3, #0x2C]
  00020	e5930094	 ldr         r0, [r3, #0x94]
  00024	eb000000	 bl          __utos

; 284  :     voltOffsetTime = voltOffsetTime/(float)k32khzFrequency;

  00028	e3a0130e	 mov         r1, #0xE, 6
  0002c	eb000000	 bl          __muls
  00030	e1a08000	 mov         r8, r0

; 285  : 
; 286  :     // get vdd setup time for retention mode
; 287  :     voltSetup1 = HIWORD(BSP_PRM_VOLTSETUP1_INIT) + LOWORD((BSP_PRM_VOLTSETUP1_INIT & 0x0000FFFF));
; 288  :     voltRetentionSetupTime = ((float)voltSetup1 * 8.0f)/(float)PrcmClockGetSystemClockFrequency();

  00034	eb000000	 bl          PrcmClockGetSystemClockFrequency
  00038	e3a03445	 mov         r3, #0x45, 8
  0003c	e1a01000	 mov         r1, r0
  00040	e3830889	 orr         r0, r3, #0x89, 16
  00044	eb000000	 bl          __divs

; 289  : 
; 290  :     // get vdd setup time for OFF mode
; 291  :     if (INREG32(&g_pPrcmPrm->pOMAP_GLOBAL_PRM->PRM_VOLTCTRL) & SEL_OFF_SIGNALLINE)

  00048	e5943000	 ldr         r3, [r4]

; 292  :         {
; 293  :         _bOffMode_SignalMode = TRUE;

  0004c	e59f4298	 ldr         r4, [pc, #0x298]
  00050	e1a06000	 mov         r6, r0
  00054	e593302c	 ldr         r3, [r3, #0x2C]
  00058	e5933060	 ldr         r3, [r3, #0x60]
  0005c	e3130008	 tst         r3, #8
  00060	0a000005	 beq         |$LN5@OALWakeupL@3|
  00064	e3a03001	 mov         r3, #1

; 294  :         voltOffSetupTime = ((float)BSP_PRM_VOLTSETUP2)/(float)k32khzFrequency;

  00068	e3a00000	 mov         r0, #0
  0006c	e3a0130e	 mov         r1, #0xE, 6
  00070	e58430fc	 str         r3, [r4, #0xFC]
  00074	eb000000	 bl          __muls

; 295  :         }
; 296  :     else

  00078	ea000006	 b           |$LN14@OALWakeupL@3|
  0007c		 |$LN5@OALWakeupL@3|

; 297  :         {
; 298  :         // get vdd setup time for i2c based off mode
; 299  :         _bOffMode_SignalMode = FALSE;

  0007c	e3a03000	 mov         r3, #0
  00080	e58430fc	 str         r3, [r4, #0xFC]

; 300  :         voltSetup1 = HIWORD(BSP_PRM_VOLTSETUP1_OFF_MODE) + LOWORD((BSP_PRM_VOLTSETUP1_OFF_MODE & 0x0000FFFF));
; 301  :         voltOffSetupTime = ((float)voltSetup1 * 8.0f)/(float)PrcmClockGetSystemClockFrequency();

  00084	eb000000	 bl          PrcmClockGetSystemClockFrequency
  00088	e3a03445	 mov         r3, #0x45, 8
  0008c	e1a01000	 mov         r1, r0
  00090	e38309a6	 orr         r0, r3, #0xA6, 18
  00094	eb000000	 bl          __divs
  00098		 |$LN14@OALWakeupL@3|
  00098	e1a07000	 mov         r7, r0

; 302  :         }
; 303  : 
; 304  :     // Loop through each opm entry in the latency table
; 305  :     for (i = 0; i <= MAX_OPM; i++)

  0009c	e1a00006	 mov         r0, r6
  000a0	e1a01008	 mov         r1, r8
  000a4	e3a06000	 mov         r6, #0
  000a8	eb000000	 bl          __adds
  000ac	e3a01439	 mov         r1, #0x39, 8
  000b0	eb000000	 bl          __adds
  000b4	e59fb22c	 ldr         r11, [pc, #0x22C]
  000b8	e1a0a000	 mov         r10, r0
  000bc		 |$LL3@OALWakeupL@3|

; 306  :         {
; 307  :         // global latency added to all latency entries
; 308  :         fixedOffset = _rgLatencyOffsetTable[i].fixedOffset;
; 309  : 
; 310  :         // chip off latency
; 311  :         latencyTime = _rgLatencyOffsetTable[i].chipOffOffset + fixedOffset;

  000bc	e5940004	 ldr         r0, [r4, #4]
  000c0	e5941000	 ldr         r1, [r4]
  000c4	eb000000	 bl          __adds

; 312  :         latencyTime += voltOffsetTime + max(voltOffSetupTime,clkOffSetupTime);

  000c8	e3a035ee	 mov         r3, #0xEE, 10
  000cc	e1a09000	 mov         r9, r0
  000d0	e1a00007	 mov         r0, r7
  000d4	e3831602	 orr         r1, r3, #2, 12
  000d8	eb000000	 bl          __gts
  000dc	e3500000	 cmp         r0, #0
  000e0	03a035ee	 moveq       r3, #0xEE, 10
  000e4	11a00007	 movne       r0, r7
  000e8	03830602	 orreq       r0, r3, #2, 12
  000ec	e1a01008	 mov         r1, r8
  000f0	eb000000	 bl          __adds
  000f4	e1a01009	 mov         r1, r9
  000f8	eb000000	 bl          __adds
  000fc	e1a03000	 mov         r3, r0

; 313  :         _rgLatencyTable[i][LATENCY_STATE_CHIP_OFF].us = latencyTime;
; 314  :         _rgLatencyTable[i][LATENCY_STATE_CHIP_OFF].ticks = (DWORD)((latencyTime) * (float)k32khzFrequency);

  00100	e3a01447	 mov         r1, #0x47, 8
  00104	e5853004	 str         r3, [r5, #4]
  00108	eb000000	 bl          __muls
  0010c	eb000000	 bl          __stou

; 315  : 
; 316  :         // chip oswr latency
; 317  :         latencyTime = _rgLatencyOffsetTable[i].chipOSWROffset + fixedOffset;

  00110	e5941000	 ldr         r1, [r4]
  00114	e1a03000	 mov         r3, r0
  00118	e5940008	 ldr         r0, [r4, #8]
  0011c	e5853000	 str         r3, [r5]
  00120	eb000000	 bl          __adds

; 318  :         latencyTime += voltRetentionSetupTime + voltOffsetTime + clkSetupTime;

  00124	e1a0100a	 mov         r1, r10
  00128	eb000000	 bl          __adds
  0012c	e1a03000	 mov         r3, r0

; 319  :         _rgLatencyTable[i][LATENCY_STATE_CHIP_OSWR].us = latencyTime;
; 320  :         _rgLatencyTable[i][LATENCY_STATE_CHIP_OSWR].ticks = (DWORD)((latencyTime) * (float)k32khzFrequency);

  00130	e3a01447	 mov         r1, #0x47, 8
  00134	e585300c	 str         r3, [r5, #0xC]
  00138	eb000000	 bl          __muls
  0013c	eb000000	 bl          __stou

; 321  : 
; 322  :         // chip cswr latency
; 323  :         latencyTime = _rgLatencyOffsetTable[i].chipCSWROffset + fixedOffset;

  00140	e5941000	 ldr         r1, [r4]
  00144	e1a03000	 mov         r3, r0
  00148	e594000c	 ldr         r0, [r4, #0xC]
  0014c	e5853008	 str         r3, [r5, #8]
  00150	eb000000	 bl          __adds

; 324  :         latencyTime += voltRetentionSetupTime + voltOffsetTime + clkSetupTime;

  00154	e1a0100a	 mov         r1, r10
  00158	eb000000	 bl          __adds
  0015c	e1a03000	 mov         r3, r0

; 325  :         _rgLatencyTable[i][LATENCY_STATE_CHIP_CSWR].us = latencyTime;
; 326  :         _rgLatencyTable[i][LATENCY_STATE_CHIP_CSWR].ticks = (DWORD)((latencyTime) * (float)k32khzFrequency);

  00160	e3a01447	 mov         r1, #0x47, 8
  00164	e5853014	 str         r3, [r5, #0x14]
  00168	eb000000	 bl          __muls
  0016c	eb000000	 bl          __stou

; 327  : 
; 328  :         // core cswr latency
; 329  :         latencyTime = _rgLatencyOffsetTable[i].coreCSWROffset + fixedOffset;

  00170	e5941000	 ldr         r1, [r4]
  00174	e1a03000	 mov         r3, r0
  00178	e5940010	 ldr         r0, [r4, #0x10]
  0017c	e5853010	 str         r3, [r5, #0x10]
  00180	eb000000	 bl          __adds
  00184	e1a03000	 mov         r3, r0

; 330  :         _rgLatencyTable[i][LATENCY_STATE_CORE_CSWR].us = latencyTime;
; 331  :         _rgLatencyTable[i][LATENCY_STATE_CORE_CSWR].ticks = (DWORD)((latencyTime) * (float)k32khzFrequency);

  00188	e3a01447	 mov         r1, #0x47, 8
  0018c	e585301c	 str         r3, [r5, #0x1C]
  00190	eb000000	 bl          __muls
  00194	eb000000	 bl          __stou

; 332  : 
; 333  :         // core inactive latency
; 334  :         latencyTime = _rgLatencyOffsetTable[i].coreInactiveOffset + fixedOffset;

  00198	e5941000	 ldr         r1, [r4]
  0019c	e1a03000	 mov         r3, r0
  001a0	e5940014	 ldr         r0, [r4, #0x14]
  001a4	e5853018	 str         r3, [r5, #0x18]
  001a8	eb000000	 bl          __adds
  001ac	e1a03000	 mov         r3, r0

; 335  :         _rgLatencyTable[i][LATENCY_STATE_CORE_INACTIVE].us = latencyTime;
; 336  :         _rgLatencyTable[i][LATENCY_STATE_CORE_INACTIVE].ticks = (DWORD)((latencyTime) * (float)k32khzFrequency);

  001b0	e3a01447	 mov         r1, #0x47, 8
  001b4	e5853024	 str         r3, [r5, #0x24]
  001b8	eb000000	 bl          __muls
  001bc	eb000000	 bl          __stou

; 337  : 
; 338  :         // mpu inactive latency
; 339  :         latencyTime = _rgLatencyOffsetTable[i].mpuInactiveOffset + fixedOffset;

  001c0	e5941000	 ldr         r1, [r4]
  001c4	e1a03000	 mov         r3, r0
  001c8	e5940018	 ldr         r0, [r4, #0x18]
  001cc	e5853020	 str         r3, [r5, #0x20]
  001d0	eb000000	 bl          __adds
  001d4	e1a09000	 mov         r9, r0

; 340  :         _rgLatencyTable[i][LATENCY_STATE_MPU_INACTIVE].us = latencyTime;
; 341  :         _rgLatencyTable[i][LATENCY_STATE_MPU_INACTIVE].ticks = (DWORD)((latencyTime) * (float)k32khzFrequency);

  001d8	e3a01447	 mov         r1, #0x47, 8
  001dc	e585902c	 str         r9, [r5, #0x2C]
  001e0	eb000000	 bl          __muls
  001e4	eb000000	 bl          __stou
  001e8	e59b3440	 ldr         r3, [r11, #0x440]
  001ec	e1a02000	 mov         r2, r0
  001f0	e5852028	 str         r2, [r5, #0x28]

; 342  : 
; 343  :         OALMSG(OAL_INFO, (L"opm%d: chipOffOffset:%d,%d chipOSWROffset:%d,%d chipCSWROffset:%d,%d "
; 344  :                    L"coreCSWROffset:%d,%d coreInactiveOffset:%d,%d mpuInactiveOffset:%d,%d\r\n",
; 345  :             i,
; 346  :             (DWORD)(_rgLatencyTable[i][LATENCY_STATE_CHIP_OFF].us * 1000000.0f), _rgLatencyTable[i][LATENCY_STATE_CHIP_OFF].ticks,
; 347  :             (DWORD)(_rgLatencyTable[i][LATENCY_STATE_CHIP_OSWR].us * 1000000.0f), _rgLatencyTable[i][LATENCY_STATE_CHIP_OSWR].ticks,
; 348  :             (DWORD)(_rgLatencyTable[i][LATENCY_STATE_CHIP_CSWR].us * 1000000.0f), _rgLatencyTable[i][LATENCY_STATE_CHIP_CSWR].ticks,
; 349  :             (DWORD)(_rgLatencyTable[i][LATENCY_STATE_CORE_CSWR].us * 1000000.0f), _rgLatencyTable[i][LATENCY_STATE_CORE_CSWR].ticks,
; 350  :             (DWORD)(_rgLatencyTable[i][LATENCY_STATE_CORE_INACTIVE].us * 1000000.0f), _rgLatencyTable[i][LATENCY_STATE_CORE_INACTIVE].ticks,
; 351  :             (DWORD)(_rgLatencyTable[i][LATENCY_STATE_MPU_INACTIVE].us * 1000000.0f), _rgLatencyTable[i][LATENCY_STATE_MPU_INACTIVE].ticks
; 352  :             ));

  001f4	e3130008	 tst         r3, #8
  001f8	0a00002f	 beq         |$LN2@OALWakeupL@3|
  001fc	e59f10e0	 ldr         r1, [pc, #0xE0]
  00200	e1a00009	 mov         r0, r9
  00204	e58d2024	 str         r2, [sp, #0x24]
  00208	eb000000	 bl          __muls
  0020c	eb000000	 bl          __stou
  00210	e5952020	 ldr         r2, [r5, #0x20]
  00214	e59f10c8	 ldr         r1, [pc, #0xC8]
  00218	e1a03000	 mov         r3, r0
  0021c	e5950024	 ldr         r0, [r5, #0x24]
  00220	e58d3020	 str         r3, [sp, #0x20]
  00224	e58d201c	 str         r2, [sp, #0x1C]
  00228	eb000000	 bl          __muls
  0022c	eb000000	 bl          __stou
  00230	e5952018	 ldr         r2, [r5, #0x18]
  00234	e59f10a8	 ldr         r1, [pc, #0xA8]
  00238	e1a03000	 mov         r3, r0
  0023c	e595001c	 ldr         r0, [r5, #0x1C]
  00240	e58d3018	 str         r3, [sp, #0x18]
  00244	e58d2014	 str         r2, [sp, #0x14]
  00248	eb000000	 bl          __muls
  0024c	eb000000	 bl          __stou
  00250	e5952010	 ldr         r2, [r5, #0x10]
  00254	e59f1088	 ldr         r1, [pc, #0x88]
  00258	e1a03000	 mov         r3, r0
  0025c	e5950014	 ldr         r0, [r5, #0x14]
  00260	e58d3010	 str         r3, [sp, #0x10]
  00264	e58d200c	 str         r2, [sp, #0xC]
  00268	eb000000	 bl          __muls
  0026c	eb000000	 bl          __stou
  00270	e5952008	 ldr         r2, [r5, #8]
  00274	e59f1068	 ldr         r1, [pc, #0x68]
  00278	e1a03000	 mov         r3, r0
  0027c	e595000c	 ldr         r0, [r5, #0xC]
  00280	e58d3008	 str         r3, [sp, #8]
  00284	e58d2004	 str         r2, [sp, #4]
  00288	eb000000	 bl          __muls
  0028c	eb000000	 bl          __stou
  00290	e59f104c	 ldr         r1, [pc, #0x4C]
  00294	e1a02000	 mov         r2, r0
  00298	e5950004	 ldr         r0, [r5, #4]
  0029c	e58d2000	 str         r2, [sp]
  002a0	eb000000	 bl          __muls
  002a4	eb000000	 bl          __stou
  002a8	e5953000	 ldr         r3, [r5]
  002ac	e1a02000	 mov         r2, r0
  002b0	e59f0028	 ldr         r0, [pc, #0x28]
  002b4	e1a01006	 mov         r1, r6
  002b8	eb000000	 bl          NKDbgPrintfW
  002bc		 |$LN2@OALWakeupL@3|
  002bc	e2866001	 add         r6, r6, #1
  002c0	e3560006	 cmp         r6, #6
  002c4	e284401c	 add         r4, r4, #0x1C
  002c8	e2855030	 add         r5, r5, #0x30
  002cc	daffff7a	 ble         |$LL3@OALWakeupL@3|

; 353  :         }
; 354  : 
; 355  :     return TRUE;

  002d0	e3a00001	 mov         r0, #1

; 356  : }

  002d4	e28dd028	 add         sp, sp, #0x28
  002d8	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  002dc	e12fff1e	 bx          lr
  002e0		 |$LN18@OALWakeupL@3|
  002e0		 |$LN19@OALWakeupL@3|
  002e0	00000000	 DCD         |??_C@_1BBK@MCBACDBJ@?$AAo?$AAp?$AAm?$AA?$CF?$AAd?$AA?3?$AA?5?$AAc?$AAh?$AAi?$AAp?$AAO?$AAf?$AAf?$AAO?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?3?$AA?$CF?$AAd?$AA?0?$AA?$CF?$AAd?$AA?5?$AAc?$AAh?$AAi?$AAp?$AAO@|
  002e4		 |$LN20@OALWakeupL@3|
  002e4	49742400	 DCD         0x49742400
  002e8		 |$LN21@OALWakeupL@3|
  002e8	00000000	 DCD         |dpCurSettings|
  002ec		 |$LN22@OALWakeupL@3|
  002ec	00000000	 DCD         |_rgLatencyOffsetTable|
  002f0		 |$LN23@OALWakeupL@3|
  002f0	00000000	 DCD         |g_pPrcmPrm|
  002f4		 |$LN24@OALWakeupL@3|
  002f4	00000000	 DCD         |_rgLatencyTable|
  002f8		 |$M47388|

			 ENDP  ; |OALWakeupLatency_Initialize|

	EXPORT	|OALWakeupLatency_SetOffModeConstraint|

  00000			 AREA	 |.pdata|, PDATA
|$T47405| DCD	|$LN6@OALWakeupL@4|
	DCD	0x40000900
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALWakeupLatency_SetOffModeConstraint| PROC

; 371  : {

  00000		 |$LN6@OALWakeupL@4|
  00000		 |$M47402|

; 372  :     // CORE can go OFF only after RNG Reset Complete (2 ^ 26 * L4 Clock cycles)         
; 373  :     s_coreOffWaitTickCount = tcrr + RNG_RESET_DELAY;

  00000	e59f2018	 ldr         r2, [pc, #0x18]
  00004	e2803a0d	 add         r3, r0, #0xD, 20
  00008	e28330d4	 add         r3, r3, #0xD4

; 374  : 
; 375  :     if (s_coreOffWaitTickCount < tcrr)

  0000c	e1530000	 cmp         r3, r0
  00010	e5823000	 str         r3, [r2]

; 376  :         {
; 377  :         s_tickRollOver = TRUE;

  00014	33a03001	 movcc       r3, #1
  00018	35823004	 strcc       r3, [r2, #4]

; 378  :         }
; 379  : } 

  0001c	e12fff1e	 bx          lr
  00020		 |$LN7@OALWakeupL@4|
  00020		 |$LN8@OALWakeupL@4|
  00020	00000000	 DCD         |s_coreOffWaitTickCount|
  00024		 |$M47403|

			 ENDP  ; |OALWakeupLatency_SetOffModeConstraint|

	EXPORT	|OALWakeupLatency_PushState|
	IMPORT	|OALEnableIOWakeupDaisyChain|
	IMPORT	|OALEnableIOPadWakeup|
	IMPORT	|PrcmVoltSetAutoControl|
	IMPORT	|IsSmartReflexMonitoringEnabled|
	IMPORT	|dwOEMHighSecurity|

  00408			 AREA	 |.bss|, NOINIT
|_powerDomainPerState| % 0x4
|_powerDomainCoreState| % 0x4
|_powerDomainMpuState| % 0x4
|_powerDomainPerState| % 0x4
|_powerDomainNeonState| % 0x4

  00000			 AREA	 |.pdata|, PDATA
|$T47426| DCD	|$LN24@OALWakeupL@5|
	DCD	0x40008a02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALWakeupLatency_PushState| PROC

; 394  : {

  00000		 |$LN24@OALWakeupL@5|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M47423|
  00008	e1a08000	 mov         r8, r0

; 395  :     DWORD mpuState;
; 396  :     DWORD coreState;
; 397  :     DWORD perState;
; 398  :     DWORD neonState;
; 399  :     DWORD clkSetup;
; 400  :     DWORD voltSetup1;
; 401  :     DWORD voltSetup2;
; 402  : 
; 403  :     // UNDONE:
; 404  :     // Need to dynamically update vdd1 setup time based on predicted sleep states
; 405  : 
; 406  :     // save current states
; 407  :     _powerDomainCoreState = INREG32(&g_pPrcmPrm->pOMAP_CORE_PRM->PM_PWSTCTRL_CORE);

  0000c	e59fb210	 ldr         r11, [pc, #0x210]
  00010	e59f9208	 ldr         r9, [pc, #0x208]

; 408  :     _powerDomainMpuState = INREG32(&g_pPrcmPrm->pOMAP_MPU_PRM->PM_PWSTCTRL_MPU);
; 409  :     _powerDomainPerState = INREG32(&g_pPrcmPrm->pOMAP_PER_PRM->PM_PWSTCTRL_PER);
; 410  :     _powerDomainNeonState = INREG32(&g_pPrcmPrm->pOMAP_NEON_PRM->PM_PWSTCTRL_NEON);
; 411  : 
; 412  :     coreState = _powerDomainCoreState & ~POWERSTATE_MASK;
; 413  :     mpuState = _powerDomainMpuState & ~POWERSTATE_MASK;
; 414  :     perState = _powerDomainPerState & ~POWERSTATE_MASK;
; 415  :     neonState = _powerDomainNeonState & ~POWERSTATE_MASK;
; 416  : 
; 417  :     // For Idle mode (other than OFF)
; 418  :     clkSetup = BSP_PRM_CLKSETUP;
; 419  :     voltSetup1 = BSP_PRM_VOLTSETUP1_INIT;
; 420  :     voltSetup2 = 0;
; 421  :     
; 422  :     // Clear the wkup status
; 423  :     OUTREG32(&g_pPrcmPrm->pOMAP_WKUP_PRM->PM_WKST_WKUP,
; 424  :     INREG32(&g_pPrcmPrm->pOMAP_WKUP_PRM->PM_WKST_WKUP) | CM_CLKEN_IO);
; 425  : 
; 426  :     if ((!IsSmartReflexMonitoringEnabled(kSmartReflex_Channel1)) &&
; 427  :         (!IsSmartReflexMonitoringEnabled(kSmartReflex_Channel2)))

  00014	e59fa200	 ldr         r10, [pc, #0x200]
  00018	e59be000	 ldr         lr, [r11]
  0001c	e3a00000	 mov         r0, #0
  00020	e59e3004	 ldr         r3, [lr, #4]
  00024	e59e2014	 ldr         r2, [lr, #0x14]
  00028	e59e1008	 ldr         r1, [lr, #8]
  0002c	e59e401c	 ldr         r4, [lr, #0x1C]
  00030	e59360e0	 ldr         r6, [r3, #0xE0]
  00034	e59ee000	 ldr         lr, [lr]
  00038	e59250e0	 ldr         r5, [r2, #0xE0]
  0003c	e59110e0	 ldr         r1, [r1, #0xE0]
  00040	e59420e0	 ldr         r2, [r4, #0xE0]
  00044	e59e30b0	 ldr         r3, [lr, #0xB0]
  00048	e5896018	 str         r6, [r9, #0x18]
  0004c	e589501c	 str         r5, [r9, #0x1C]
  00050	e3833c01	 orr         r3, r3, #1, 24
  00054	e58e30b0	 str         r3, [lr, #0xB0]
  00058	e3a03004	 mov         r3, #4
  0005c	e3c67003	 bic         r7, r6, #3
  00060	e3c54003	 bic         r4, r5, #3
  00064	e58d3000	 str         r3, [sp]
  00068	e5891000	 str         r1, [r9]
  0006c	e5892020	 str         r2, [r9, #0x20]
  00070	e3c15003	 bic         r5, r1, #3
  00074	e3c26003	 bic         r6, r2, #3
  00078	eb000000	 bl          IsSmartReflexMonitoringEnabled
  0007c	e3500000	 cmp         r0, #0
  00080	1a000037	 bne         |$LN12@OALWakeupL@5|
  00084	e3a00001	 mov         r0, #1
  00088	eb000000	 bl          IsSmartReflexMonitoringEnabled
  0008c	e3500000	 cmp         r0, #0
  00090	1a000033	 bne         |$LN12@OALWakeupL@5|

; 428  :         {
; 429  :         if (state == LATENCY_STATE_CHIP_OFF)

  00094	e3580000	 cmp         r8, #0

; 430  :         {
; 431  :               PrcmVoltSetAutoControl(AUTO_SLEEP_DISABLED | AUTO_RET_DISABLED | AUTO_OFF_ENABLED,
; 432  :                                     AUTO_SLEEP | AUTO_RET | AUTO_OFF);

  00098	e3a01007	 mov         r1, #7
  0009c	1a00002c	 bne         |$LN15@OALWakeupL@5|
  000a0	e3a00004	 mov         r0, #4
  000a4	eb000000	 bl          PrcmVoltSetAutoControl
  000a8		 |$LN9@OALWakeupL@5|

; 492  :             break;

  000a8	e3a0360a	 mov         r3, #0xA, 12
  000ac	e383a0b3	 orr         r10, r3, #0xB3
  000b0	e3a030a0	 mov         r3, #0xA0
  000b4	e58d3000	 str         r3, [sp]
  000b8	eb000000	 bl          OALEnableIOPadWakeup
  000bc	eb000000	 bl          OALEnableIOWakeupDaisyChain
  000c0	e59f314c	 ldr         r3, [pc, #0x14C]
  000c4	e5933000	 ldr         r3, [r3]
  000c8	e3530001	 cmp         r3, #1
  000cc	03a03000	 moveq       r3, #0
  000d0	03a02000	 moveq       r2, #0
  000d4	05893040	 streq       r3, [r9, #0x40]
  000d8	0589203c	 streq       r2, [r9, #0x3C]
  000dc		 |$LN8@OALWakeupL@5|

; 515  :         }
; 516  : 
; 517  :     OUTREG32(&g_pPrcmPrm->pOMAP_CORE_PRM->PM_PWSTCTRL_CORE, coreState);

  000dc	e59b2000	 ldr         r2, [r11]

; 518  :     OUTREG32(&g_pPrcmPrm->pOMAP_MPU_PRM->PM_PWSTCTRL_MPU, mpuState);
; 519  :     OUTREG32(&g_pPrcmPrm->pOMAP_PER_PRM->PM_PWSTCTRL_PER, perState);
; 520  :     OUTREG32(&g_pPrcmPrm->pOMAP_NEON_PRM->PM_PWSTCTRL_NEON, neonState);
; 521  : 
; 522  :     // update clock setup and vdd setup times
; 523  :     OUTREG32(&g_pPrcmPrm->pOMAP_GLOBAL_PRM->PRM_CLKSETUP, clkSetup);
; 524  :     OUTREG32(&g_pPrcmPrm->pOMAP_GLOBAL_PRM->PRM_VOLTSETUP2, voltSetup2);
; 525  :     if (_bOffMode_SignalMode == FALSE)

  000e0	e59f3130	 ldr         r3, [pc, #0x130]
  000e4	e3a00000	 mov         r0, #0
  000e8	e5922004	 ldr         r2, [r2, #4]
  000ec	e5931000	 ldr         r1, [r3]
  000f0	e58270e0	 str         r7, [r2, #0xE0]
  000f4	e59b3000	 ldr         r3, [r11]
  000f8	e59d2000	 ldr         r2, [sp]
  000fc	e3510000	 cmp         r1, #0
  00100	e5933014	 ldr         r3, [r3, #0x14]
  00104	e58340e0	 str         r4, [r3, #0xE0]
  00108	e59b3000	 ldr         r3, [r11]
  0010c	e5933008	 ldr         r3, [r3, #8]
  00110	e58350e0	 str         r5, [r3, #0xE0]
  00114	e59b3000	 ldr         r3, [r11]
  00118	e593301c	 ldr         r3, [r3, #0x1C]
  0011c	e58360e0	 str         r6, [r3, #0xE0]
  00120	e59b3000	 ldr         r3, [r11]
  00124	e593302c	 ldr         r3, [r3, #0x2C]
  00128	e5832098	 str         r2, [r3, #0x98]
  0012c	e59b3000	 ldr         r3, [r11]
  00130	e593302c	 ldr         r3, [r3, #0x2C]
  00134	e58300a0	 str         r0, [r3, #0xA0]

; 526  :         {
; 527  :         OUTREG32(&g_pPrcmPrm->pOMAP_GLOBAL_PRM->PRM_VOLTSETUP1, voltSetup1);

  00138	059b3000	 ldreq       r3, [r11]

; 528  :         }
; 529  : 
; 530  :     return TRUE;

  0013c	e3a00001	 mov         r0, #1
  00140	0593302c	 ldreq       r3, [r3, #0x2C]
  00144	0583a090	 streq       r10, [r3, #0x90]

; 531  : }

  00148	e28dd004	 add         sp, sp, #4
  0014c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00150	e12fff1e	 bx          lr
  00154		 |$LN15@OALWakeupL@5|

; 433  :       	
; 434  :         }
; 435  :         else if (state <= LATENCY_STATE_CHIP_CSWR )

  00154	e3580002	 cmp         r8, #2

; 436  :             {
; 437  :             // Enable Auto RET
; 438  :             PrcmVoltSetAutoControl(AUTO_SLEEP_DISABLED | AUTO_RET_ENABLED | AUTO_OFF_DISABLED,
; 439  :                                     AUTO_SLEEP | AUTO_RET | AUTO_OFF);

  00158	93a00002	 movls       r0, #2

; 440  :             }
; 441  :         else
; 442  :             {
; 443  :             // Enable Auto sleep
; 444  :             PrcmVoltSetAutoControl(AUTO_SLEEP_ENABLED | AUTO_RET_DISABLED | AUTO_OFF_DISABLED, 
; 445  :                                     AUTO_SLEEP | AUTO_RET | AUTO_OFF);

  0015c	83a00001	 movhi       r0, #1
  00160	eb000000	 bl          PrcmVoltSetAutoControl
  00164		 |$LN12@OALWakeupL@5|

; 446  :             }
; 447  :         }
; 448  :     
; 449  :     switch (state)

  00164	e3580000	 cmp         r8, #0
  00168	0affffce	 beq         |$LN9@OALWakeupL@5|
  0016c	e3580001	 cmp         r8, #1
  00170	0a000017	 beq         |$LN7@OALWakeupL@5|
  00174	e3580002	 cmp         r8, #2
  00178	0a000020	 beq         |$LN6@OALWakeupL@5|
  0017c	e3580003	 cmp         r8, #3
  00180	0a00000a	 beq         |$LN4@OALWakeupL@5|
  00184	e3580004	 cmp         r8, #4
  00188	0a000006	 beq         |$LN3@OALWakeupL@5|
  0018c	e3580005	 cmp         r8, #5
  00190	1affffd1	 bne         |$LN8@OALWakeupL@5|

; 508  : 
; 509  :         case LATENCY_STATE_MPU_INACTIVE:
; 510  :             coreState |= POWERSTATE_ON;

  00194	e3877003	 orr         r7, r7, #3

; 511  :             mpuState |= POWERSTATE_ON;

  00198	e3844003	 orr         r4, r4, #3

; 512  :             perState |= POWERSTATE_ON;

  0019c	e3855003	 orr         r5, r5, #3

; 513  :             neonState |= POWERSTATE_ON;

  001a0	e3866003	 orr         r6, r6, #3

; 514  :             break;

  001a4	eaffffcc	 b           |$LN8@OALWakeupL@5|
  001a8		 |$LN3@OALWakeupL@5|

; 501  : 
; 502  :         case LATENCY_STATE_CORE_INACTIVE:
; 503  :             coreState |= POWERSTATE_ON;
; 504  :             mpuState |= _powerDomainMpuState & POWERSTATE_MASK;
; 505  :             perState |= POWERSTATE_ON;
; 506  :             neonState |= _powerDomainNeonState & POWERSTATE_MASK;

  001a8	e3877003	 orr         r7, r7, #3

; 507  :             break;

  001ac	ea000000	 b           |$LN21@OALWakeupL@5|
  001b0		 |$LN4@OALWakeupL@5|

; 493  : 
; 494  :         case LATENCY_STATE_CORE_CSWR:
; 495  :             coreState |= LOGICRETSTATE_LOGICRET_DOMAINRET;
; 496  :             coreState |= POWERSTATE_RETENTION;
; 497  :             mpuState |= _powerDomainMpuState & POWERSTATE_MASK;
; 498  :             perState |= POWERSTATE_ON;
; 499  :             neonState |= _powerDomainNeonState & POWERSTATE_MASK;

  001b0	e3877005	 orr         r7, r7, #5
  001b4		 |$LN21@OALWakeupL@5|
  001b4	e5992020	 ldr         r2, [r9, #0x20]
  001b8	e599301c	 ldr         r3, [r9, #0x1C]
  001bc	e3855003	 orr         r5, r5, #3
  001c0	e2022003	 and         r2, r2, #3
  001c4	e2033003	 and         r3, r3, #3
  001c8	e1834004	 orr         r4, r3, r4
  001cc	e1826006	 orr         r6, r2, r6

; 500  :             break;

  001d0	eaffffc1	 b           |$LN8@OALWakeupL@5|
  001d4		 |$LN7@OALWakeupL@5|

; 450  :         {
; 451  :         case LATENCY_STATE_CHIP_OFF:
; 452  : 
; 453  :             // For Off mode, the clksetup need to count for oscillator startup
; 454  :             clkSetup = BSP_PRM_CLKSETUP_OFFMODE;
; 455  :             voltSetup1 = BSP_PRM_VOLTSETUP1_OFF_MODE;
; 456  :             voltSetup2 = BSP_PRM_VOLTSETUP2;
; 457  : 
; 458  :             coreState |= POWERSTATE_OFF;
; 459  :             mpuState |= POWERSTATE_OFF;
; 460  :             perState |= POWERSTATE_OFF;
; 461  :             neonState |= POWERSTATE_OFF;
; 462  :             OALEnableIOPadWakeup();
; 463  :             OALEnableIOWakeupDaisyChain();
; 464  : 
; 465  :             // reset the RNG reset variables 
; 466  :             if (dwOEMHighSecurity == OEM_HIGH_SECURITY_HS)
; 467  :                 {
; 468  :                 s_tickRollOver = FALSE;
; 469  :                 s_coreOffWaitTickCount = 0;
; 470  :                 }
; 471  :             break;
; 472  : 
; 473  :         case LATENCY_STATE_CHIP_OSWR:
; 474  :             // UNDONE : OSWR is not yet supported in HS device
; 475  :             if (dwOEMHighSecurity == OEM_HIGH_SECURITY_GP)

  001d4	e59f3038	 ldr         r3, [pc, #0x38]
  001d8	e5933000	 ldr         r3, [r3]
  001dc	e3530002	 cmp         r3, #2
  001e0	1a000006	 bne         |$LN6@OALWakeupL@5|

; 476  :                 {
; 477  :                 coreState &= ~LOGICRETSTATE_LOGICRET_DOMAINRET;

  001e4	e3c73004	 bic         r3, r7, #4

; 478  :                 coreState |= POWERSTATE_RETENTION;

  001e8	e3837001	 orr         r7, r3, #1

; 479  :                 mpuState |= POWERSTATE_RETENTION;

  001ec	e3844001	 orr         r4, r4, #1

; 480  :                 perState |= POWERSTATE_RETENTION;

  001f0	e3855001	 orr         r5, r5, #1

; 481  :                 neonState |= POWERSTATE_RETENTION;

  001f4	e3866001	 orr         r6, r6, #1

; 482  :                 OALEnableIOPadWakeup(); 

  001f8	eb000000	 bl          OALEnableIOPadWakeup

; 483  :                 break;

  001fc	eaffffb6	 b           |$LN8@OALWakeupL@5|
  00200		 |$LN6@OALWakeupL@5|

; 484  :                 }
; 485  : 
; 486  :         case LATENCY_STATE_CHIP_CSWR:
; 487  :             coreState |= LOGICRETSTATE_LOGICRET_DOMAINRET;
; 488  :             coreState |= POWERSTATE_RETENTION;

  00200	e3877005	 orr         r7, r7, #5

; 489  :             mpuState |= POWERSTATE_RETENTION;

  00204	e3844001	 orr         r4, r4, #1

; 490  :             perState |= POWERSTATE_RETENTION;

  00208	e3855001	 orr         r5, r5, #1

; 491  :             neonState |= POWERSTATE_RETENTION;

  0020c	e3866001	 orr         r6, r6, #1

; 492  :             break;

  00210	eaffffb1	 b           |$LN8@OALWakeupL@5|
  00214		 |$LN25@OALWakeupL@5|
  00214		 |$LN26@OALWakeupL@5|
  00214	00000000	 DCD         |dwOEMHighSecurity|
  00218		 |$LN27@OALWakeupL@5|
  00218	00000000	 DCD         |_bOffMode_SignalMode|
  0021c		 |$LN28@OALWakeupL@5|
  0021c	01120112	 DCD         0x1120112
  00220		 |$LN29@OALWakeupL@5|
  00220	00000000	 DCD         |_powerDomainPerState|
  00224		 |$LN30@OALWakeupL@5|
  00224	00000000	 DCD         |g_pPrcmPrm|
  00228		 |$M47424|

			 ENDP  ; |OALWakeupLatency_PushState|

	EXPORT	|OALWakeupLatency_PopState|
	IMPORT	|OALDisableIOPadWakeup|
	IMPORT	|OALDisableIOWakeupDaisyChain|
	IMPORT	|OALIOPadWakeupEnableStatus|

  00000			 AREA	 |.pdata|, PDATA
|$T47439| DCD	|$LN7@OALWakeupL@6|
	DCD	0x40002501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALWakeupLatency_PopState| PROC

; 543  : {

  00000		 |$LN7@OALWakeupL@6|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M47436|

; 544  :     // change states back to previous states.  This should be done
; 545  :     // by hitting the hardware registers directly so that the prcm library
; 546  :     // structures are not modified.
; 547  : 
; 548  :     // this is only called in OEMIdle and OEMPowerOff
; 549  :     OUTREG32(&g_pPrcmPrm->pOMAP_CORE_PRM->PM_PWSTCTRL_CORE, _powerDomainCoreState);

  00004	e59f4084	 ldr         r4, [pc, #0x84]
  00008	e59f207c	 ldr         r2, [pc, #0x7C]
  0000c	e5943000	 ldr         r3, [r4]
  00010	e5921018	 ldr         r1, [r2, #0x18]

; 550  :     OUTREG32(&g_pPrcmPrm->pOMAP_MPU_PRM->PM_PWSTCTRL_MPU, _powerDomainMpuState);

  00014	e592001c	 ldr         r0, [r2, #0x1C]
  00018	e5933004	 ldr         r3, [r3, #4]

; 551  :     OUTREG32(&g_pPrcmPrm->pOMAP_PER_PRM->PM_PWSTCTRL_PER, _powerDomainPerState);

  0001c	e592e000	 ldr         lr, [r2]

; 552  :     OUTREG32(&g_pPrcmPrm->pOMAP_NEON_PRM->PM_PWSTCTRL_NEON, _powerDomainNeonState);

  00020	e5922020	 ldr         r2, [r2, #0x20]
  00024	e58310e0	 str         r1, [r3, #0xE0]
  00028	e5943000	 ldr         r3, [r4]
  0002c	e5933014	 ldr         r3, [r3, #0x14]
  00030	e58300e0	 str         r0, [r3, #0xE0]
  00034	e5943000	 ldr         r3, [r4]
  00038	e5933008	 ldr         r3, [r3, #8]
  0003c	e583e0e0	 str         lr, [r3, #0xE0]
  00040	e5943000	 ldr         r3, [r4]
  00044	e593301c	 ldr         r3, [r3, #0x1C]
  00048	e58320e0	 str         r2, [r3, #0xE0]

; 553  :     
; 554  :     if (OALIOPadWakeupEnableStatus())

  0004c	eb000000	 bl          OALIOPadWakeupEnableStatus
  00050	e3500000	 cmp         r0, #0
  00054	0a000001	 beq         |$LN2@OALWakeupL@6|

; 555  :         {
; 556  :         // Disable IO PAD wakeup 
; 557  :         OALDisableIOWakeupDaisyChain();

  00058	eb000000	 bl          OALDisableIOWakeupDaisyChain

; 558  :         OALDisableIOPadWakeup();

  0005c	eb000000	 bl          OALDisableIOPadWakeup
  00060		 |$LN2@OALWakeupL@6|

; 559  :         }
; 560  :     
; 561  :     // restore vdd setup time if in i2c mode
; 562  :     if (_bOffMode_SignalMode == FALSE)

  00060	e59f3020	 ldr         r3, [pc, #0x20]
  00064	e5933000	 ldr         r3, [r3]
  00068	e3530000	 cmp         r3, #0

; 563  :         {
; 564  :         OUTREG32(&g_pPrcmPrm->pOMAP_GLOBAL_PRM->PRM_VOLTSETUP1, 
; 565  :             BSP_PRM_VOLTSETUP1_INIT
; 566  :             );

  0006c	05943000	 ldreq       r3, [r4]
  00070	059f200c	 ldreq       r2, [pc, #0xC]
  00074	0593302c	 ldreq       r3, [r3, #0x2C]
  00078	05832090	 streq       r2, [r3, #0x90]

; 567  :         }
; 568  : }

  0007c	e8bd4010	 ldmia       sp!, {r4, lr}
  00080	e12fff1e	 bx          lr
  00084		 |$LN8@OALWakeupL@6|
  00084		 |$LN9@OALWakeupL@6|
  00084	01120112	 DCD         0x1120112
  00088		 |$LN10@OALWakeupL@6|
  00088	00000000	 DCD         |_bOffMode_SignalMode|
  0008c		 |$LN11@OALWakeupL@6|
  0008c	00000000	 DCD         |_powerDomainPerState|
  00090		 |$LN12@OALWakeupL@6|
  00090	00000000	 DCD         |g_pPrcmPrm|
  00094		 |$M47437|

			 ENDP  ; |OALWakeupLatency_PopState|

	EXPORT	|OALWakeupLatency_GetCurrentState|

  00000			 AREA	 |.pdata|, PDATA
|$T47456| DCD	|$LN18@OALWakeupL@7|
	DCD	0x40002f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALWakeupLatency_GetCurrentState| PROC

; 579  : {

  00000		 |$LN18@OALWakeupL@7|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M47453|

; 580  :     DWORD rc;
; 581  : 
; 582  :     if (_domainMpu == POWERSTATE_INACTIVE)

  00004	e59f20ac	 ldr         r2, [pc, #0xAC]
  00008	e5921004	 ldr         r1, [r2, #4]
  0000c	e3510002	 cmp         r1, #2

; 583  :         {
; 584  :         // LATENCY_STATE_MPU_INACTIVE state
; 585  :         //
; 586  :         rc = LATENCY_STATE_MPU_INACTIVE;

  00010	03a00005	 moveq       r0, #5

; 609  :         }
; 610  : 
; 611  :     return rc;
; 612  : }

  00014	049de004	 ldreq       lr, [sp], #4
  00018	012fff1e	 bxeq        lr

; 587  :         }
; 588  :     else if (_domainCore == POWERSTATE_INACTIVE || _coreDevice != 0)

  0001c	e5920008	 ldr         r0, [r2, #8]
  00020	e3500002	 cmp         r0, #2
  00024	0a00001f	 beq         |$LN8@OALWakeupL@7|
  00028	e59fe084	 ldr         lr, [pc, #0x84]
  0002c	e59e3008	 ldr         r3, [lr, #8]
  00030	e3530000	 cmp         r3, #0
  00034	1a00001b	 bne         |$LN8@OALWakeupL@7|

; 593  :         }
; 594  :     else if (_domainInactiveMask != 0 || _otherDevice != 0)

  00038	e59e3000	 ldr         r3, [lr]
  0003c	e3530000	 cmp         r3, #0
  00040	1a000015	 bne         |$LN5@OALWakeupL@7|
  00044	e59e300c	 ldr         r3, [lr, #0xC]
  00048	e3530000	 cmp         r3, #0
  0004c	1a000012	 bne         |$LN5@OALWakeupL@7|

; 599  :         }
; 600  :     else if (_domainCore == POWERSTATE_RETENTION || _domainMpu == POWERSTATE_RETENTION || _domainRetentionMask != 0 || _vddMpu > kOpp2)

  00050	e3500001	 cmp         r0, #1
  00054	0a000009	 beq         |$LN2@OALWakeupL@7|
  00058	e3510001	 cmp         r1, #1
  0005c	0a000007	 beq         |$LN2@OALWakeupL@7|
  00060	e59e3004	 ldr         r3, [lr, #4]
  00064	e3530000	 cmp         r3, #0
  00068	1a000004	 bne         |$LN2@OALWakeupL@7|
  0006c	e5923000	 ldr         r3, [r2]
  00070	e3530001	 cmp         r3, #1

; 605  :         }
; 606  :     else
; 607  :         {
; 608  :         rc = LATENCY_STATE_CHIP_OFF;

  00074	d3a00000	 movle       r0, #0

; 609  :         }
; 610  : 
; 611  :     return rc;
; 612  : }

  00078	d49de004	 ldrle       lr, [sp], #4
  0007c	d12fff1e	 bxle        lr
  00080		 |$LN2@OALWakeupL@7|

; 601  :         {
; 602  :         // LATENCY_STATE_CHIP_OSWR, LATENCY_STATE_CHIP_CSWR state
; 603  :         //
; 604  :         rc = (_logicCore == LOGICRETSTATE_LOGICRET_DOMAINRET) ? LATENCY_STATE_CHIP_CSWR : LATENCY_STATE_CHIP_OSWR;

  00080	e592300c	 ldr         r3, [r2, #0xC]
  00084	e3530004	 cmp         r3, #4
  00088	03a00002	 moveq       r0, #2

; 609  :         }
; 610  : 
; 611  :     return rc;
; 612  : }

  0008c	049de004	 ldreq       lr, [sp], #4

; 601  :         {
; 602  :         // LATENCY_STATE_CHIP_OSWR, LATENCY_STATE_CHIP_CSWR state
; 603  :         //
; 604  :         rc = (_logicCore == LOGICRETSTATE_LOGICRET_DOMAINRET) ? LATENCY_STATE_CHIP_CSWR : LATENCY_STATE_CHIP_OSWR;

  00090	13a00001	 movne       r0, #1

; 609  :         }
; 610  : 
; 611  :     return rc;
; 612  : }

  00094	149de004	 ldrne       lr, [sp], #4
  00098	e12fff1e	 bx          lr
  0009c		 |$LN5@OALWakeupL@7|

; 595  :         {
; 596  :         // LATENCY_STATE_CORE_CSWR,
; 597  :         //
; 598  :         rc = LATENCY_STATE_CORE_CSWR;

  0009c	e3a00003	 mov         r0, #3

; 609  :         }
; 610  : 
; 611  :     return rc;
; 612  : }

  000a0	e49de004	 ldr         lr, [sp], #4
  000a4	e12fff1e	 bx          lr
  000a8		 |$LN8@OALWakeupL@7|

; 589  :         {
; 590  :         // LATENCY_STATE_CORE_INACTIVE state
; 591  :         //
; 592  :         rc = LATENCY_STATE_CORE_INACTIVE;

  000a8	e3a00004	 mov         r0, #4

; 609  :         }
; 610  : 
; 611  :     return rc;
; 612  : }

  000ac	e49de004	 ldr         lr, [sp], #4
  000b0	e12fff1e	 bx          lr
  000b4		 |$LN19@OALWakeupL@7|
  000b4		 |$LN20@OALWakeupL@7|
  000b4	00000000	 DCD         |_domainInactiveMask|
  000b8		 |$LN21@OALWakeupL@7|
  000b8	00000000	 DCD         |_vddMpu|
  000bc		 |$M47454|

			 ENDP  ; |OALWakeupLatency_GetCurrentState|

	EXPORT	|OALWakeupLatency_GetDelayInTicks|

  00000			 AREA	 |.pdata|, PDATA
|$T47469| DCD	|$LN7@OALWakeupL@8|
	DCD	0x40001601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALWakeupLatency_GetDelayInTicks| PROC

; 625  : {

  00000		 |$LN7@OALWakeupL@8|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M47466|

; 626  :     if ((state >= LATENCY_STATE_COUNT) || (state == STATE_NOCPUIDLE)) return MAX_INT;

  00004	e3500006	 cmp         r0, #6
  00008	2a00000d	 bcs         |$LN1@OALWakeupL@8|
  0000c	e3700001	 cmn         r0, #1
  00010	0a00000b	 beq         |$LN1@OALWakeupL@8|

; 627  :     return _rgLatencyTable[_mapLatencyIndex[_vddMpu][_vddCore]][state].ticks;

  00014	e59f1038	 ldr         r1, [pc, #0x38]
  00018	e59fe030	 ldr         lr, [pc, #0x30]
  0001c	e5913144	 ldr         r3, [r1, #0x144]
  00020	e59e2204	 ldr         r2, [lr, #0x204]
  00024	e0833183	 add         r3, r3, r3, lsl #3
  00028	e0833002	 add         r3, r3, r2
  0002c	e7913103	 ldr         r3, [r1, +r3, lsl #2]
  00030	e0833083	 add         r3, r3, r3, lsl #1
  00034	e0803083	 add         r3, r0, r3, lsl #1
  00038	e79e0183	 ldr         r0, [lr, +r3, lsl #3]

; 628  : }

  0003c	e49de004	 ldr         lr, [sp], #4
  00040	e12fff1e	 bx          lr
  00044		 |$LN1@OALWakeupL@8|

; 626  :     if ((state >= LATENCY_STATE_COUNT) || (state == STATE_NOCPUIDLE)) return MAX_INT;

  00044	e3e00102	 mvn         r0, #2, 2

; 628  : }

  00048	e49de004	 ldr         lr, [sp], #4
  0004c	e12fff1e	 bx          lr
  00050		 |$LN8@OALWakeupL@8|
  00050		 |$LN9@OALWakeupL@8|
  00050	00000000	 DCD         |_rgLatencyTable|
  00054		 |$LN10@OALWakeupL@8|
  00054	00000000	 DCD         |_mapLatencyIndex|
  00058		 |$M47467|

			 ENDP  ; |OALWakeupLatency_GetDelayInTicks|

	EXPORT	|OALWakeupLatency_FindStateByMaxDelayInTicks|

  00000			 AREA	 |.pdata|, PDATA
|$T47489| DCD	|$LN13@OALWakeupL@9|
	DCD	0x40002001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALWakeupLatency_FindStateByMaxDelayInTicks| PROC

; 642  : {

  00000		 |$LN13@OALWakeupL@9|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47486|
  00004	e1a05000	 mov         r5, r0

; 643  :     DWORD i;
; 644  :     int *rgStateTransitions = _mapLatencyTransitionTable[OALWakeupLatency_GetCurrentState()];

  00008	eb000000	 bl          OALWakeupLatency_GetCurrentState
  0000c	e59f4068	 ldr         r4, [pc, #0x68]

; 645  :     LatencyEntry *rgLatencies = _rgLatencyTable[_mapLatencyIndex[_vddMpu][_vddCore]];

  00010	e59fe060	 ldr         lr, [pc, #0x60]
  00014	e59431ec	 ldr         r3, [r4, #0x1EC]
  00018	e59e1204	 ldr         r1, [lr, #0x204]
  0001c	e28420a8	 add         r2, r4, #0xA8
  00020	e0833183	 add         r3, r3, r3, lsl #3
  00024	e0833001	 add         r3, r3, r1
  00028	e7922103	 ldr         r2, [r2, +r3, lsl #2]
  0002c	e0603180	 rsb         r3, r0, r0, lsl #3

; 646  :     for (i = 0; rgStateTransitions[i] != STATE_NOCPUIDLE; ++i)

  00030	e7b41103	 ldr         r1, [r4, +r3, lsl #2]!
  00034	e0823082	 add         r3, r2, r2, lsl #1
  00038	e08e0203	 add         r0, lr, r3, lsl #4
  0003c	e3a02000	 mov         r2, #0
  00040	ea000004	 b           |$LN10@OALWakeupL@9|
  00044		 |$LL4@OALWakeupL@9|

; 647  :         {
; 648  :         if ((DWORD)delayTicks >= rgLatencies[rgStateTransitions[i]].ticks)

  00044	e7903181	 ldr         r3, [r0, +r1, lsl #3]
  00048	e1550003	 cmp         r5, r3
  0004c	2a000006	 bcs         |$LN8@OALWakeupL@9|
  00050	e2822001	 add         r2, r2, #1
  00054	e7941102	 ldr         r1, [r4, +r2, lsl #2]
  00058		 |$LN10@OALWakeupL@9|
  00058	e3710001	 cmn         r1, #1
  0005c	1afffff8	 bne         |$LL4@OALWakeupL@9|

; 651  :             }
; 652  :         }
; 653  :     return (DWORD) STATE_NOCPUIDLE;

  00060	e3e00000	 mvn         r0, #0

; 654  : }

  00064	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00068	e12fff1e	 bx          lr
  0006c		 |$LN8@OALWakeupL@9|

; 649  :             {
; 650  :             return rgStateTransitions[i];

  0006c	e7940102	 ldr         r0, [r4, +r2, lsl #2]

; 654  : }

  00070	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00074	e12fff1e	 bx          lr
  00078		 |$LN14@OALWakeupL@9|
  00078		 |$LN15@OALWakeupL@9|
  00078	00000000	 DCD         |_rgLatencyTable|
  0007c		 |$LN16@OALWakeupL@9|
  0007c	00000000	 DCD         |_mapLatencyTransitionTable|
  00080		 |$M47487|

			 ENDP  ; |OALWakeupLatency_FindStateByMaxDelayInTicks|

	EXPORT	|OALWakeupLatency_UpdateOpp|

  00000			 AREA	 |.pdata|, PDATA
|$T47506| DCD	|$LN14@OALWakeupL@10|
	DCD	0x40001801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALWakeupLatency_UpdateOpp| PROC

; 670  : {

  00000		 |$LN14@OALWakeupL@10|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M47503|
  00004	e3520000	 cmp         r2, #0

; 671  :     DWORD i;
; 672  :     
; 673  :     for (i = 0; i < count; ++i)

  00008	0a00000f	 beq         |$LN5@OALWakeupL@10|
  0000c	e59fe048	 ldr         lr, [pc, #0x48]
  00010	e59f4040	 ldr         r4, [pc, #0x40]
  00014	e0400001	 sub         r0, r0, r1
  00018		 |$LL7@OALWakeupL@10|

; 674  :         {
; 675  :         switch (rgDomains[i])

  00018	e7903001	 ldr         r3, [r0, +r1]
  0001c	e3530000	 cmp         r3, #0
  00020	0a000004	 beq         |$LN1@OALWakeupL@10|
  00024	e3530010	 cmp         r3, #0x10
  00028	1a000004	 bne         |$LN6@OALWakeupL@10|

; 676  :             {
; 677  :             case DVFS_MPU1_OPP:
; 678  :                 _vddMpu = rgOpps[i];

  0002c	e5913000	 ldr         r3, [r1]
  00030	e5843000	 str         r3, [r4]

; 679  :                 break;

  00034	ea000001	 b           |$LN6@OALWakeupL@10|
  00038		 |$LN1@OALWakeupL@10|

; 680  : 
; 681  :             case DVFS_CORE1_OPP:
; 682  :                 _vddCore = rgOpps[i];                

  00038	e5913000	 ldr         r3, [r1]
  0003c	e58e3000	 str         r3, [lr]
  00040		 |$LN6@OALWakeupL@10|
  00040	e2811004	 add         r1, r1, #4
  00044	e2522001	 subs        r2, r2, #1
  00048	1afffff2	 bne         |$LL7@OALWakeupL@10|
  0004c		 |$LN5@OALWakeupL@10|

; 683  :                 break;
; 684  :             }
; 685  :         }
; 686  :     
; 687  :     return TRUE;

  0004c	e3a00001	 mov         r0, #1

; 688  : }

  00050	e8bd4010	 ldmia       sp!, {r4, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$LN15@OALWakeupL@10|
  00058		 |$LN16@OALWakeupL@10|
  00058	00000000	 DCD         |_vddMpu|
  0005c		 |$LN17@OALWakeupL@10|
  0005c	00000000	 DCD         |_vddCore|
  00060		 |$M47504|

			 ENDP  ; |OALWakeupLatency_UpdateOpp|

	EXPORT	|OALWakeupLatency_UpdateDomainState|

  00000			 AREA	 |.pdata|, PDATA
|$T47527| DCD	|$LN24@OALWakeupL@11|
	DCD	0x40003400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALWakeupLatency_UpdateDomainState| PROC

; 705  : {

  00000		 |$LN24@OALWakeupL@11|
  00000		 |$M47524|

; 706  :     // only care about MPU and CORE power domain states
; 707  :     switch (powerDomain)

  00000	e3500001	 cmp         r0, #1
  00004	0a000028	 beq         |$LN6@OALWakeupL@11|
  00008	e3500005	 cmp         r0, #5
  0000c	0a000013	 beq         |$LN11@OALWakeupL@11|

; 724  :             break;
; 725  : 
; 726  :         default:
; 727  :             if (powerState == POWERSTATE_ON)
; 728  :                 {
; 729  :                 _domainInactiveMask |= (1 << powerDomain);

  00010	e59f20b4	 ldr         r2, [pc, #0xB4]
  00014	e3a03001	 mov         r3, #1
  00018	e1a00013	 mov         r0, r3, lsl r0
  0001c	e5923000	 ldr         r3, [r2]
  00020	e3510003	 cmp         r1, #3
  00024	1a000006	 bne         |$LN4@OALWakeupL@11|
  00028	e1803003	 orr         r3, r0, r3
  0002c	e5823000	 str         r3, [r2]
  00030		 |$LN2@OALWakeupL@11|

; 741  :                 {
; 742  :                 _domainRetentionMask &= ~(1 << powerDomain);

  00030	e5923004	 ldr         r3, [r2, #4]
  00034	e1c33000	 bic         r3, r3, r0
  00038		 |$LN20@OALWakeupL@11|
  00038	e5823004	 str         r3, [r2, #4]

; 743  :                 }
; 744  :             break;
; 745  :         }
; 746  :   
; 747  :     return TRUE;

  0003c	e3a00001	 mov         r0, #1

; 748  : }

  00040	e12fff1e	 bx          lr
  00044		 |$LN4@OALWakeupL@11|

; 730  :                 }
; 731  :             else
; 732  :                 {
; 733  :                 _domainInactiveMask &= ~(1 << powerDomain);
; 734  :                 }
; 735  : 
; 736  :             if (powerState == POWERSTATE_RETENTION)

  00044	e1c33000	 bic         r3, r3, r0
  00048	e5823000	 str         r3, [r2]
  0004c	e3510001	 cmp         r1, #1
  00050	1afffff6	 bne         |$LN2@OALWakeupL@11|

; 737  :                 {
; 738  :                 _domainRetentionMask |= (1 << powerDomain);

  00054	e5923004	 ldr         r3, [r2, #4]
  00058	e1803003	 orr         r3, r0, r3

; 739  :                 }
; 740  :             else

  0005c	eafffff5	 b           |$LN20@OALWakeupL@11|
  00060		 |$LN11@OALWakeupL@11|

; 708  :         {
; 709  :         case POWERDOMAIN_MPU:
; 710  :             if ((powerState == POWERSTATE_RETENTION && logicState != LOGICRETSTATE) ||
; 711  :                  powerState == POWERSTATE_OFF)

  00060	e3510001	 cmp         r1, #1
  00064	1a000001	 bne         |$LN8@OALWakeupL@11|
  00068	e3520004	 cmp         r2, #4
  0006c	1a000001	 bne         |$LN9@OALWakeupL@11|
  00070		 |$LN8@OALWakeupL@11|
  00070	e3510000	 cmp         r1, #0
  00074	1a000004	 bne         |$LN10@OALWakeupL@11|
  00078		 |$LN9@OALWakeupL@11|

; 712  :                 {
; 713  :                 _domainMpu = POWERSTATE_OFF;

  00078	e59f3048	 ldr         r3, [pc, #0x48]
  0007c	e3a02000	 mov         r2, #0

; 743  :                 }
; 744  :             break;
; 745  :         }
; 746  :   
; 747  :     return TRUE;

  00080	e3a00001	 mov         r0, #1
  00084	e5832000	 str         r2, [r3]

; 748  : }

  00088	e12fff1e	 bx          lr
  0008c		 |$LN10@OALWakeupL@11|

; 714  :                 }
; 715  :             else
; 716  :                 {
; 717  :                 _domainMpu = powerState == POWERSTATE_ON ? POWERSTATE_INACTIVE : powerState;

  0008c	e59f3034	 ldr         r3, [pc, #0x34]
  00090	e3510003	 cmp         r1, #3
  00094	03a02002	 moveq       r2, #2
  00098	05832000	 streq       r2, [r3]

; 743  :                 }
; 744  :             break;
; 745  :         }
; 746  :   
; 747  :     return TRUE;

  0009c	03a00001	 moveq       r0, #1

; 714  :                 }
; 715  :             else
; 716  :                 {
; 717  :                 _domainMpu = powerState == POWERSTATE_ON ? POWERSTATE_INACTIVE : powerState;

  000a0	15831000	 strne       r1, [r3]

; 743  :                 }
; 744  :             break;
; 745  :         }
; 746  :   
; 747  :     return TRUE;

  000a4	13a00001	 movne       r0, #1

; 748  : }

  000a8	e12fff1e	 bx          lr
  000ac		 |$LN6@OALWakeupL@11|

; 718  :                 }
; 719  :             break;
; 720  : 
; 721  :         case POWERDOMAIN_CORE:
; 722  :             _domainCore = powerState == POWERSTATE_ON ? POWERSTATE_INACTIVE : powerState;

  000ac	e59f3014	 ldr         r3, [pc, #0x14]
  000b0	e3510003	 cmp         r1, #3
  000b4	03a01002	 moveq       r1, #2
  000b8	e5831004	 str         r1, [r3, #4]

; 723  :             _logicCore = logicState;

  000bc	e5832008	 str         r2, [r3, #8]

; 743  :                 }
; 744  :             break;
; 745  :         }
; 746  :   
; 747  :     return TRUE;

  000c0	e3a00001	 mov         r0, #1

; 748  : }

  000c4	e12fff1e	 bx          lr
  000c8		 |$LN25@OALWakeupL@11|
  000c8		 |$LN26@OALWakeupL@11|
  000c8	00000000	 DCD         |_domainMpu|
  000cc		 |$LN27@OALWakeupL@11|
  000cc	00000000	 DCD         |_domainInactiveMask|
  000d0		 |$M47525|

			 ENDP  ; |OALWakeupLatency_UpdateDomainState|

	EXPORT	|OALWakeupLatency_DeviceEnabled|

  00000			 AREA	 |.pdata|, PDATA
|$T47544| DCD	|$LN18@OALWakeupL@12|
	DCD	0x40002b00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALWakeupLatency_DeviceEnabled| PROC

; 763  : {

  00000		 |$LN18@OALWakeupL@12|
  00000		 |$M47541|

; 764  :    
; 765  :     switch (devId)

  00000	e350002b	 cmp         r0, #0x2B
  00004	8a000016	 bhi         |$LN13@OALWakeupL@12|
  00008	e350002a	 cmp         r0, #0x2A
  0000c	2a000007	 bcs         |$LN8@OALWakeupL@12|
  00010	e3500006	 cmp         r0, #6
  00014	3a000021	 bcc         |$LN1@OALWakeupL@12|
  00018	e3500017	 cmp         r0, #0x17
  0001c	9a000003	 bls         |$LN8@OALWakeupL@12|
  00020	e3500020	 cmp         r0, #0x20
  00024	9a00001d	 bls         |$LN1@OALWakeupL@12|
  00028	e3500023	 cmp         r0, #0x23
  0002c	8a00001b	 bhi         |$LN1@OALWakeupL@12|
  00030		 |$LN8@OALWakeupL@12|

; 766  :         {
; 767  :         case OMAP_DEVICE_I2C1:
; 768  :         case OMAP_DEVICE_I2C2:
; 769  :         case OMAP_DEVICE_I2C3:
; 770  :         case OMAP_DEVICE_MMC1:
; 771  :         case OMAP_DEVICE_MMC2:
; 772  :         case OMAP_DEVICE_MMC3:
; 773  :         case OMAP_DEVICE_USBTLL:
; 774  :         case OMAP_DEVICE_HDQ:
; 775  :         case OMAP_DEVICE_MCBSP1:
; 776  :         case OMAP_DEVICE_MCBSP5:
; 777  :         case OMAP_DEVICE_MCSPI1:
; 778  :         case OMAP_DEVICE_MCSPI2:
; 779  :         case OMAP_DEVICE_MCSPI3:
; 780  :         case OMAP_DEVICE_MCSPI4:
; 781  :         case OMAP_DEVICE_UART1:
; 782  :         case OMAP_DEVICE_UART2:
; 783  :         case OMAP_DEVICE_TS:
; 784  :         case OMAP_DEVICE_GPTIMER10:
; 785  :         case OMAP_DEVICE_GPTIMER11:
; 786  :         case OMAP_DEVICE_MSPRO:
; 787  :         case OMAP_DEVICE_EFUSE:
; 788  :         case OMAP_DEVICE_SR1:
; 789  :         case OMAP_DEVICE_SR2:
; 790  :             if (bEnabled == TRUE)
; 791  :                 {
; 792  :                 #ifdef DEBUG_PRCM_SUSPEND_RESUME
; 793  :                     DeviceEnabledCount[devId]++;
; 794  : 				#endif
; 795  :                 ++_coreDevice;

  00030	e59f2070	 ldr         r2, [pc, #0x70]
  00034	e3510001	 cmp         r1, #1

; 860  :                 }
; 861  :             break; 
; 862  :         }
; 863  : 
; 864  :     return TRUE;

  00038	03a00001	 moveq       r0, #1
  0003c	e5923000	 ldr         r3, [r2]
  00040	02833001	 addeq       r3, r3, #1
  00044	05823000	 streq       r3, [r2]

; 865  : }

  00048	012fff1e	 bxeq        lr

; 796  :                 }
; 797  :             else
; 798  :                 {
; 799  :                 #ifdef DEBUG_PRCM_SUSPEND_RESUME
; 800  :                     if (DeviceEnabledCount[devId] > 0)
; 801  :                         DeviceEnabledCount[devId]--;
; 802  : 				#endif
; 803  :                 if (_coreDevice > 0) 

  0004c	e3530000	 cmp         r3, #0
  00050	0a000012	 beq         |$LN1@OALWakeupL@12|

; 804  : 				    --_coreDevice;

  00054	e2433001	 sub         r3, r3, #1
  00058	e5823000	 str         r3, [r2]

; 860  :                 }
; 861  :             break; 
; 862  :         }
; 863  : 
; 864  :     return TRUE;

  0005c	e3a00001	 mov         r0, #1

; 865  : }

  00060	e12fff1e	 bx          lr
  00064		 |$LN13@OALWakeupL@12|

; 764  :    
; 765  :     switch (devId)

  00064	e3500032	 cmp         r0, #0x32
  00068	3a00000c	 bcc         |$LN1@OALWakeupL@12|
  0006c	e350004d	 cmp         r0, #0x4D
  00070	9a000001	 bls         |$LN4@OALWakeupL@12|
  00074	e350004f	 cmp         r0, #0x4F
  00078	1a000008	 bne         |$LN1@OALWakeupL@12|
  0007c		 |$LN4@OALWakeupL@12|

; 805  :                 }
; 806  :             break;
; 807  : 
; 808  :         /*
; 809  :         GPIO clocks not included, always on unless in suspend
; 810  :         case OMAP_DEVICE_GPIO2:
; 811  :         case OMAP_DEVICE_GPIO3:
; 812  :         case OMAP_DEVICE_GPIO4:
; 813  :         case OMAP_DEVICE_GPIO5:
; 814  :         case OMAP_DEVICE_GPIO6:
; 815  :         */
; 816  :         case OMAP_DEVICE_MCBSP2:          
; 817  :         case OMAP_DEVICE_MCBSP3:
; 818  :         case OMAP_DEVICE_MCBSP4:
; 819  :         case OMAP_DEVICE_GPTIMER2:
; 820  :         case OMAP_DEVICE_GPTIMER3:
; 821  :         case OMAP_DEVICE_GPTIMER4:
; 822  :         case OMAP_DEVICE_GPTIMER5:
; 823  :         case OMAP_DEVICE_GPTIMER6:
; 824  :         case OMAP_DEVICE_GPTIMER7: 
; 825  :         case OMAP_DEVICE_GPTIMER8:
; 826  :         case OMAP_DEVICE_GPTIMER9:    
; 827  :         case OMAP_DEVICE_UART3:
; 828  :         case OMAP_DEVICE_UART4:
; 829  :         case OMAP_DEVICE_WDT3:       
; 830  :         case OMAP_DEVICE_DSS: 
; 831  :         case OMAP_DEVICE_DSS1:
; 832  :         case OMAP_DEVICE_DSS2:
; 833  :         case OMAP_DEVICE_TVOUT:
; 834  :         case OMAP_DEVICE_CAMERA: 
; 835  :         case OMAP_DEVICE_CSI2: 
; 836  :         case OMAP_DEVICE_DSP:
; 837  :         case OMAP_DEVICE_2D: 
; 838  :         case OMAP_DEVICE_3D:
; 839  :         case OMAP_DEVICE_SGX:
; 840  :         case OMAP_DEVICE_HSUSB1: 
; 841  :         case OMAP_DEVICE_HSUSB2: 
; 842  :         case OMAP_DEVICE_USBHOST1: 
; 843  :         case OMAP_DEVICE_USBHOST2:
; 844  :         case OMAP_DEVICE_USBHOST3:
; 845  :             if (bEnabled == TRUE)
; 846  :                 {
; 847  :                 #ifdef DEBUG_PRCM_SUSPEND_RESUME
; 848  :                     DeviceEnabledCount[devId]++;
; 849  :                 #endif
; 850  :                 ++_otherDevice;

  0007c	e59f2024	 ldr         r2, [pc, #0x24]
  00080	e3510001	 cmp         r1, #1
  00084	e5923004	 ldr         r3, [r2, #4]
  00088	02833001	 addeq       r3, r3, #1
  0008c	0a000002	 beq         |$LN14@OALWakeupL@12|

; 851  :                 }
; 852  :             else
; 853  :                 {
; 854  :                 #ifdef DEBUG_PRCM_SUSPEND_RESUME
; 855  :                     if (DeviceEnabledCount[devId] > 0)
; 856  :                         DeviceEnabledCount[devId]--;
; 857  :                 #endif
; 858  :                 if (_otherDevice > 0) 

  00090	e3530000	 cmp         r3, #0
  00094	0a000001	 beq         |$LN1@OALWakeupL@12|

; 859  :     				--_otherDevice;

  00098	e2433001	 sub         r3, r3, #1
  0009c		 |$LN14@OALWakeupL@12|
  0009c	e5823004	 str         r3, [r2, #4]
  000a0		 |$LN1@OALWakeupL@12|

; 860  :                 }
; 861  :             break; 
; 862  :         }
; 863  : 
; 864  :     return TRUE;

  000a0	e3a00001	 mov         r0, #1

; 865  : }

  000a4	e12fff1e	 bx          lr
  000a8		 |$LN19@OALWakeupL@12|
  000a8		 |$LN20@OALWakeupL@12|
  000a8	00000000	 DCD         |_coreDevice|
  000ac		 |$M47542|

			 ENDP  ; |OALWakeupLatency_DeviceEnabled|

	EXPORT	|OALWakeupLatency_IsChipOff|

  00000			 AREA	 |.pdata|, PDATA
|$T47558| DCD	|$LN7@OALWakeupL@13|
	DCD	0x40000400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALWakeupLatency_IsChipOff| PROC

; 878  : {

  00000		 |$LN7@OALWakeupL@13|
  00000		 |$M47555|
  00000	e3500000	 cmp         r0, #0

; 879  :     return  (latencyState == LATENCY_STATE_CHIP_OFF);

  00004	03a00001	 moveq       r0, #1
  00008	13a00000	 movne       r0, #0

; 880  : }

  0000c	e12fff1e	 bx          lr
  00010		 |$M47556|

			 ENDP  ; |OALWakeupLatency_IsChipOff|

	EXPORT	|OALWakeupLatency_GetSuspendState|

  00000			 AREA	 |.pdata|, PDATA
|$T47570| DCD	|$LN9@OALWakeupL@14|
	DCD	0x40001501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALWakeupLatency_GetSuspendState| PROC

; 892  : {

  00000		 |$LN9@OALWakeupL@14|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M47567|

; 893  :     DWORD rc = _suspendState;

  00004	e59f1044	 ldr         r1, [pc, #0x44]

; 894  :     DWORD domainMask = _domainInactiveMask | _domainRetentionMask;
; 895  : 
; 896  :     // ignore peripheral and neon power state
; 897  :     domainMask &= ~(1 << POWERDOMAIN_NEON);
; 898  :     domainMask &= ~(1 << POWERDOMAIN_PERIPHERAL);
; 899  : 
; 900  :     // check if there's something which may prevent a lower sleep state
; 901  :     if (domainMask != 0 || _otherDevice != 0 || _coreDevice != 0)

  00008	e5912008	 ldr         r2, [r1, #8]
  0000c	e5913004	 ldr         r3, [r1, #4]
  00010	e5914000	 ldr         r4, [r1]
  00014	e1823003	 orr         r3, r2, r3
  00018	e3d3c084	 bics        r12, r3, #0x84
  0001c	1a000005	 bne         |$LN1@OALWakeupL@14|
  00020	e5913010	 ldr         r3, [r1, #0x10]
  00024	e3530000	 cmp         r3, #0
  00028	1a000002	 bne         |$LN1@OALWakeupL@14|
  0002c	e591300c	 ldr         r3, [r1, #0xC]
  00030	e3530000	 cmp         r3, #0
  00034	0a000002	 beq         |$LN6@OALWakeupL@14|
  00038		 |$LN1@OALWakeupL@14|

; 902  :         {
; 903  :         rc = max(rc, OALWakeupLatency_GetCurrentState());

  00038	eb000000	 bl          OALWakeupLatency_GetCurrentState
  0003c	e1540000	 cmp         r4, r0
  00040	91a04000	 movls       r4, r0
  00044		 |$LN6@OALWakeupL@14|

; 904  :         }
; 905  : 
; 906  :     return rc;
; 907  : }

  00044	e1a00004	 mov         r0, r4
  00048	e8bd4010	 ldmia       sp!, {r4, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$LN10@OALWakeupL@14|
  00050		 |$LN11@OALWakeupL@14|
  00050	00000000	 DCD         |_suspendState|
  00054		 |$M47568|

			 ENDP  ; |OALWakeupLatency_GetSuspendState|

	EXPORT	|OALWakeupLatency_SetSuspendState|

  00000			 AREA	 |.pdata|, PDATA
|$T47583| DCD	|$LN6@OALWakeupL@15|
	DCD	0x40000800
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALWakeupLatency_SetSuspendState| PROC

; 920  : {

  00000		 |$LN6@OALWakeupL@15|
  00000		 |$M47580|
  00000	e1a02000	 mov         r2, r0

; 921  :     BOOL rc = FALSE;
; 922  :     if (suspendState < LATENCY_STATE_COUNT)

  00004	e3520006	 cmp         r2, #6

; 923  :         {
; 924  :         _suspendState = suspendState;

  00008	359f300c	 ldrcc       r3, [pc, #0xC]
  0000c	e3a00000	 mov         r0, #0

; 925  :         rc = TRUE;

  00010	33a00001	 movcc       r0, #1
  00014	35832000	 strcc       r2, [r3]

; 926  :         }
; 927  : 
; 928  :     return rc;
; 929  : }

  00018	e12fff1e	 bx          lr
  0001c		 |$LN7@OALWakeupL@15|
  0001c		 |$LN8@OALWakeupL@15|
  0001c	00000000	 DCD         |_suspendState|
  00020		 |$M47581|

			 ENDP  ; |OALWakeupLatency_SetSuspendState|

	EXPORT	|OALIoCtlInterruptLatencyConstraint|
	EXPORT	|??_C@_1FO@DPCMIAE@?$AA?9?$AAO?$AAA?$AAL?$AAI?$AAo?$AAC?$AAt?$AAl?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAL?$AAa?$AAt?$AAe?$AAn?$AAc?$AAy?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EM@HALJGOAC@?$AA?$CL?$AAO?$AAA?$AAL?$AAI?$AAo?$AAC?$AAt?$AAl?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAL?$AAa?$AAt?$AAe?$AAn?$AAc?$AAy?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa@| [ DATA ] ; `string'
	IMPORT	|g_wakeupLatencyConstraintTickCount|
	IMPORT	|__lts|

  00000			 AREA	 |.pdata|, PDATA
|$T47608| DCD	|$LN17@OALIoCtlIn|
	DCD	0x40003201

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FO@DPCMIAE@?$AA?9?$AAO?$AAA?$AAL?$AAI?$AAo?$AAC?$AAt?$AAl?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAL?$AAa?$AAt?$AAe?$AAn?$AAc?$AAy?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa@| DCB "-"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "I", 0x0, "o", 0x0, "C"
	DCB	0x0, "t", 0x0, "l", 0x0, "I", 0x0, "n", 0x0, "t", 0x0, "e"
	DCB	0x0, "r", 0x0, "r", 0x0, "u", 0x0, "p", 0x0, "t", 0x0, "L"
	DCB	0x0, "a", 0x0, "t", 0x0, "e", 0x0, "n", 0x0, "c", 0x0, "y"
	DCB	0x0, "C", 0x0, "o", 0x0, "n", 0x0, "s", 0x0, "t", 0x0, "r"
	DCB	0x0, "a", 0x0, "i", 0x0, "n", 0x0, "t", 0x0, "(", 0x0, "r"
	DCB	0x0, "c", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "%", 0x0, "d"
	DCB	0x0, ")", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EM@HALJGOAC@?$AA?$CL?$AAO?$AAA?$AAL?$AAI?$AAo?$AAC?$AAt?$AAl?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAL?$AAa?$AAt?$AAe?$AAn?$AAc?$AAy?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa@| DCB "+"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "I", 0x0, "o", 0x0, "C"
	DCB	0x0, "t", 0x0, "l", 0x0, "I", 0x0, "n", 0x0, "t", 0x0, "e"
	DCB	0x0, "r", 0x0, "r", 0x0, "u", 0x0, "p", 0x0, "t", 0x0, "L"
	DCB	0x0, "a", 0x0, "t", 0x0, "e", 0x0, "n", 0x0, "c", 0x0, "y"
	DCB	0x0, "C", 0x0, "o", 0x0, "n", 0x0, "s", 0x0, "t", 0x0, "r"
	DCB	0x0, "a", 0x0, "i", 0x0, "n", 0x0, "t", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALIoCtlInterruptLatencyConstraint| PROC

; 946  : {

  00000		 |$LN17@OALIoCtlIn|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M47605|
  00004	e1a07002	 mov         r7, r2
  00008	e1a06001	 mov         r6, r1

; 947  :     BOOL rc = FALSE;
; 948  : 
; 949  :     UNREFERENCED_PARAMETER(code);
; 950  :     UNREFERENCED_PARAMETER(pOutBuffer);
; 951  :     UNREFERENCED_PARAMETER(outSize);
; 952  :     UNREFERENCED_PARAMETER(pOutSize);
; 953  : 
; 954  :     OALMSG(OAL_IOCTL&&OAL_FUNC, (L"+OALIoCtlInterruptLatencyConstraint\r\n"));

  0000c	e59f50b0	 ldr         r5, [pc, #0xB0]
  00010	e3a04000	 mov         r4, #0
  00014	e5953440	 ldr         r3, [r5, #0x440]
  00018	e3130a01	 tst         r3, #1, 20
  0001c	0a000004	 beq         |$LN7@OALIoCtlIn|
  00020	e3130004	 tst         r3, #4
  00024	0a000002	 beq         |$LN7@OALIoCtlIn|
  00028	e59f0090	 ldr         r0, [pc, #0x90]
  0002c	eb000000	 bl          NKDbgPrintfW
  00030	e5953440	 ldr         r3, [r5, #0x440]
  00034		 |$LN7@OALIoCtlIn|

; 955  : 
; 956  :     if (pInBuffer == NULL || inSize != sizeof(float)) goto cleanUp;

  00034	e3560000	 cmp         r6, #0
  00038	0a000015	 beq         |$cleanUp$47262|
  0003c	e3570004	 cmp         r7, #4
  00040	1a000013	 bne         |$cleanUp$47262|

; 957  : 
; 958  :     // check if pInBuffer is less than 0 which means to release 
; 959  :     // interrupt constraints
; 960  :     _OALWakeupLatency_Lock();

  00044	e59f006c	 ldr         r0, [pc, #0x6C]
  00048	eb000000	 bl          EnterCriticalSection

; 961  :     if (*(float*)pInBuffer < 0.0f)

  0004c	e5960000	 ldr         r0, [r6]
  00050	e3a01000	 mov         r1, #0
  00054	eb000000	 bl          __lts
  00058	e3500000	 cmp         r0, #0

; 962  :         {
; 963  :         g_wakeupLatencyConstraintTickCount = MAX_INT;

  0005c	159f3058	 ldrne       r3, [pc, #0x58]
  00060	13e02102	 mvnne       r2, #2, 2
  00064	15832000	 strne       r2, [r3]
  00068	1a000005	 bne         |$LN1@OALIoCtlIn|

; 964  :         }
; 965  :     else
; 966  :         {
; 967  :         g_wakeupLatencyConstraintTickCount = (DWORD)(*(float*)pInBuffer * (float)k32khzFrequency);

  0006c	e5960000	 ldr         r0, [r6]
  00070	e3a01447	 mov         r1, #0x47, 8
  00074	eb000000	 bl          __muls
  00078	eb000000	 bl          __stou
  0007c	e59f3038	 ldr         r3, [pc, #0x38]
  00080	e5830000	 str         r0, [r3]
  00084		 |$LN1@OALIoCtlIn|

; 968  :         }
; 969  :     _OALWakeupLatency_Unlock();

  00084	e59f002c	 ldr         r0, [pc, #0x2C]
  00088	eb000000	 bl          LeaveCriticalSection

; 970  :     
; 971  :     rc = TRUE;

  0008c	e5953440	 ldr         r3, [r5, #0x440]
  00090	e3a04001	 mov         r4, #1
  00094		 |$cleanUp$47262|

; 972  :     
; 973  : cleanUp:    
; 974  :     OALMSG(OAL_INTR&&OAL_FUNC, 
; 975  :         (L"-OALIoCtlInterruptLatencyConstraint(rc = %d)\r\n", rc)
; 976  :         );

  00094	e3130901	 tst         r3, #1, 18
  00098	13130004	 tstne       r3, #4
  0009c	159f0010	 ldrne       r0, [pc, #0x10]
  000a0	11a01004	 movne       r1, r4
  000a4	1b000000	 blne        NKDbgPrintfW

; 977  :     
; 978  :     return rc;
; 979  : }

  000a8	e1a00004	 mov         r0, r4
  000ac	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000b0	e12fff1e	 bx          lr
  000b4		 |$LN18@OALIoCtlIn|
  000b4		 |$LN19@OALIoCtlIn|
  000b4	00000000	 DCD         |??_C@_1FO@DPCMIAE@?$AA?9?$AAO?$AAA?$AAL?$AAI?$AAo?$AAC?$AAt?$AAl?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAL?$AAa?$AAt?$AAe?$AAn?$AAc?$AAy?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa@|
  000b8		 |$LN20@OALIoCtlIn|
  000b8	00000000	 DCD         |_csLatency|
  000bc		 |$LN21@OALIoCtlIn|
  000bc	00000000	 DCD         |g_wakeupLatencyConstraintTickCount|
  000c0		 |$LN22@OALIoCtlIn|
  000c0	00000000	 DCD         |??_C@_1EM@HALJGOAC@?$AA?$CL?$AAO?$AAA?$AAL?$AAI?$AAo?$AAC?$AAt?$AAl?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAL?$AAa?$AAt?$AAe?$AAn?$AAc?$AAy?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa@|
  000c4		 |$LN23@OALIoCtlIn|
  000c4	00000000	 DCD         |dpCurSettings|
  000c8		 |$M47606|

			 ENDP  ; |OALIoCtlInterruptLatencyConstraint|

	EXPORT	|OALWakeupLatency_SaveSnapshot|

  00000			 AREA	 |.pdata|, PDATA
|$T47621| DCD	|$LN5@OALWakeupL@16|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALWakeupLatency_SaveSnapshot| PROC

; 1017 :     {

  00000		 |$LN5@OALWakeupL@16|
  00000		 |$M47618|

; 1018 :     }

  00000	e12fff1e	 bx          lr
  00004		 |$M47619|

			 ENDP  ; |OALWakeupLatency_SaveSnapshot|

	EXPORT	|OALWakeupLatency_DumpSnapshot|

  00000			 AREA	 |.pdata|, PDATA
|$T47628| DCD	|$LN5@OALWakeupL@17|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALWakeupLatency_DumpSnapshot| PROC

; 1021 :     {

  00000		 |$LN5@OALWakeupL@17|
  00000		 |$M47625|

; 1022 :     }

  00000	e12fff1e	 bx          lr
  00004		 |$M47626|

			 ENDP  ; |OALWakeupLatency_DumpSnapshot|

	END
