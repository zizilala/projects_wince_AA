; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\Z2170P\SRC\BOOTLOADER\EBOOT\SDMEMORY\flash.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|g_ulFlashBase| [ DATA ]
	EXPORT	|g_ulFlashLengthBytes| [ DATA ]
	EXPORT	|g_ulBPartBase| [ DATA ]
	EXPORT	|g_ulBPartLengthBytes| [ DATA ]

  00000			 AREA	 |.bss|, NOINIT
|g_bpartBuffer| % 0x20a00

  00000			 AREA	 |.data|, DATA
	 COMMON	|s_binDio|, 0x10

|g_ulFlashBase| DCD 0x8000000
|g_ulFlashLengthBytes| DCD 0x2
|g_ulBPartBase| DCD |g_bpartBuffer|
|g_ulBPartLengthBytes| DCD 0x20a00

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|BLFlashDownload|
; File c:\wince600\platform\z2170p\src\bootloader\eboot\sdmemory\flash.c

  00000			 AREA	 |.pdata|, PDATA
|$T47739| DCD	|$LN5@BLFlashDow|
	DCD	0x40000c04
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BLFlashDownload| PROC

; 125  : {

  00000		 |$LN5@BLFlashDow|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd008	 sub         sp, sp, #8
  00010		 |$M47736|

; 126  :     UINT32 rc = (UINT32) BL_ERROR;

  00010	e3e03000	 mvn         r3, #0
  00014	e58d3000	 str         r3, [sp]

; 127  : 
; 128  :     UNREFERENCED_PARAMETER(pBootDevices);
; 129  : #ifndef BSP_NO_NAND_IN_SDBOOT
; 130  :     // We have do device initialization for some devices
; 131  :     switch (pConfig->bootDevLoc.IfcType)
; 132  :         {
; 133  :         case Internal:
; 134  :             switch (pConfig->bootDevLoc.LogicalLoc)
; 135  :                 {
; 136  :                 case BSP_NAND_REGS_PA + 0x20:
; 137  :                 rc = ReadFlashNK();
; 138  :                 break;
; 139  :                 }
; 140  :             break;
; 141  :         }
; 142  : #else
; 143  :     UNREFERENCED_PARAMETER(pConfig);
; 144  : #endif
; 145  :     return rc;

  00018	e59d3000	 ldr         r3, [sp]
  0001c	e58d3004	 str         r3, [sp, #4]

; 146  : }

  00020	e59d0004	 ldr         r0, [sp, #4]
  00024	e28dd008	 add         sp, sp, #8
  00028	e89d6000	 ldmia       sp, {sp, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$M47737|

			 ENDP  ; |BLFlashDownload|

	EXPORT	|OEMStartEraseFlash|

  00000			 AREA	 |.pdata|, PDATA
|$T47747| DCD	|$LN5@OEMStartEr|
	DCD	0x40000c04
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OEMStartEraseFlash| PROC

; 160  : {

  00000		 |$LN5@OEMStartEr|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd008	 sub         sp, sp, #8
  00010		 |$M47744|

; 161  :     BOOL rc;
; 162  :     
; 163  :     UNREFERENCED_PARAMETER(address);
; 164  :     UNREFERENCED_PARAMETER(size);
; 165  :     
; 166  : #ifndef BSP_NO_NAND_IN_SDBOOT
; 167  :     rc = TRUE;
; 168  : 
; 169  :     OALMSG(OAL_FUNC, (
; 170  :         L"+OEMStartEraseFlash(0x%08x, 0x%08x)\r\n", address, size
; 171  :         ));
; 172  :     
; 173  :     OALMSG(OAL_FUNC, (L"-OEMStartEraseFlash(rc = %d)\r\n", rc));   
; 174  :     
; 175  : #else   
; 176  :     rc = FALSE;    

  00010	e3a03000	 mov         r3, #0
  00014	e58d3000	 str         r3, [sp]

; 177  : #endif	
; 178  : 
; 179  :     return rc;

  00018	e59d3000	 ldr         r3, [sp]
  0001c	e58d3004	 str         r3, [sp, #4]

; 180  : }

  00020	e59d0004	 ldr         r0, [sp, #4]
  00024	e28dd008	 add         sp, sp, #8
  00028	e89d6000	 ldmia       sp, {sp, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$M47745|

			 ENDP  ; |OEMStartEraseFlash|

	EXPORT	|OEMContinueEraseFlash|

  00000			 AREA	 |.pdata|, PDATA
|$T47754| DCD	|$LN5@OEMContinu|
	DCD	0x40000100
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OEMContinueEraseFlash| PROC

; 193  : {

  00000		 |$LN5@OEMContinu|
  00000		 |$M47751|

; 194  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M47752|

			 ENDP  ; |OEMContinueEraseFlash|

	EXPORT	|OEMFinishEraseFlash|

  00000			 AREA	 |.pdata|, PDATA
|$T47762| DCD	|$LN5@OEMFinishE|
	DCD	0x40000801
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OEMFinishEraseFlash| PROC

; 207  : {

  00000		 |$LN5@OEMFinishE|
  00000	e24dd008	 sub         sp, sp, #8
  00004		 |$M47759|

; 208  :     BOOL rc = TRUE;

  00004	e3a03001	 mov         r3, #1
  00008	e58d3000	 str         r3, [sp]

; 209  : 
; 210  :     return rc;

  0000c	e59d3000	 ldr         r3, [sp]
  00010	e58d3004	 str         r3, [sp, #4]

; 211  : }

  00014	e59d0004	 ldr         r0, [sp, #4]
  00018	e28dd008	 add         sp, sp, #8
  0001c	e12fff1e	 bx          lr
  00020		 |$M47760|

			 ENDP  ; |OEMFinishEraseFlash|

	EXPORT	|OEMWriteFlash|

  00000			 AREA	 |.pdata|, PDATA
|$T47770| DCD	|$LN5@OEMWriteFl|
	DCD	0x40000a04
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OEMWriteFlash| PROC

; 226  : {

  00000		 |$LN5@OEMWriteFl|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M47767|

; 227  : #ifndef BSP_NO_NAND_IN_SDBOOT
; 228  :     BOOL rc;
; 229  : 
; 230  :     switch (g_eboot.type)
; 231  :         {
; 232  :         case DOWNLOAD_TYPE_XLDR:
; 233  :             rc = WriteFlashXLDR(address, size);
; 234  :             break;
; 235  :         case DOWNLOAD_TYPE_EBOOT:
; 236  :             rc = WriteFlashEBOOT(address, size);
; 237  :             break;
; 238  : 		case DOWNLOAD_TYPE_LOGO:
; 239  :             rc = WriteFlashLogo(address, size);
; 240  : 			break;
; 241  :         case DOWNLOAD_TYPE_FLASHNAND:
; 242  :             rc = WriteFlashNK(address, size);
; 243  :             break;
; 244  : #ifdef IMGMULTIXIP
; 245  :         case DOWNLOAD_TYPE_EXT:
; 246  :             rc = WriteFlashEXT(address, size);
; 247  :             break;
; 248  : #endif			
; 249  :         default:
; 250  :             rc = FALSE;
; 251  :             break;
; 252  :         }
; 253  :     return rc;
; 254  : 	
; 255  : #else
; 256  :     UNREFERENCED_PARAMETER(address);
; 257  :     UNREFERENCED_PARAMETER(size);
; 258  :     return FALSE;

  00010	e3a03000	 mov         r3, #0
  00014	e58d3000	 str         r3, [sp]

; 259  : #endif
; 260  : }

  00018	e59d0000	 ldr         r0, [sp]
  0001c	e28dd004	 add         sp, sp, #4
  00020	e89d6000	 ldmia       sp, {sp, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M47768|

			 ENDP  ; |OEMWriteFlash|

	EXPORT	|WriteFlashNK|

  00000			 AREA	 |.pdata|, PDATA
|$T47778| DCD	|$LN5@WriteFlash|
	DCD	0x40000a04
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |WriteFlashNK| PROC

; 269  : {

  00000		 |$LN5@WriteFlash|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M47775|

; 270  : #ifndef BSP_NO_NAND_IN_SDBOOT
; 271  :     BOOL rc = FALSE;
; 272  :     BOOL bExt = FALSE;
; 273  :     HANDLE hPartition;
; 274  :     UCHAR *pData;
; 275  :     PCI_REG_INFO regInfo;
; 276  : 
; 277  :     memset(&regInfo, 0, sizeof(PCI_REG_INFO));
; 278  :     regInfo.MemBase.Num    = 1;
; 279  :     regInfo.MemLen.Num     = 1;
; 280  :     regInfo.MemBase.Reg[0] = g_ulFlashBase;
; 281  :     regInfo.MemLen.Reg[0]  = g_ulFlashLengthBytes;
; 282  : 
; 283  : 
; 284  :     // Get data location
; 285  :     pData = OEMMapMemAddr(address, address);
; 286  : #ifdef IMGMULTIXIP
; 287  :     // Checking if this is an EXT region
; 288  :     if((address == (IMAGE_WINCE_EXT_CA + NAND_ROMOFFSET)) || (address == IMAGE_WINCE_EXT_CA) )
; 289  :     {
; 290  :         bExt = TRUE;
; 291  :         OALLog(L"\r\nWriting EXT image to OS partition, address=%x, SIZE=%x\r\n", address, size);
; 292  :     }
; 293  :     else if ((address == (IMAGE_WINCE_CODE_CA + NAND_ROMOFFSET) )|| (address == IMAGE_WINCE_CODE_CA))
; 294  :     {
; 295  :         OALLog(L"\r\nWriting NK image to OS partition address=%x, SIZE=%x\r\n", address, size);
; 296  :     }
; 297  : #endif
; 298  : 
; 299  :     // Verify that we get CE image.
; 300  :     if (!VerifyImage(pData, NULL))
; 301  :         {
; 302  :         OALMSG(OAL_ERROR, (L"ERROR: OEMWriteFlash: "
; 303  :             L"NK image signature not found\r\n"
; 304  :             ));
; 305  :         rc = TRUE;
; 306  :         goto cleanUp;
; 307  :         }
; 308  : 
; 309  :     // Initialize boot partition library
; 310  :     if (!BP_Init((LPBYTE)g_ulBPartBase, g_ulBPartLengthBytes, NULL, &regInfo, NULL))
; 311  :     {
; 312  :         OALLog(L"WriteFlashNK: Error initializing bootpart library!!\r\n");
; 313  :         goto cleanUp;
; 314  :     }
; 315  :     
; 316  :     // Open partition based on region type 
; 317  :     hPartition = BP_OpenPartition((DWORD)NEXT_FREE_LOC, (DWORD)USE_REMAINING_SPACE, bExt ? PART_BINFS : PART_BOOTSECTION, FALSE, PART_OPEN_EXISTING);
; 318  :     if (hPartition == INVALID_HANDLE_VALUE)
; 319  :     {
; 320  :         OALMSG(OAL_ERROR, (L"ERROR: OS partition not found!\r\n"));
; 321  :         goto cleanUp;
; 322  :     }
; 323  :     
; 324  :     // Check length against size of partition
; 325  :     if (!BP_SetDataPointer(hPartition, size))
; 326  :     {
; 327  :         OALMSG(OAL_ERROR, (L"ERROR: OS partition too small!  Aborting...\r\n"));
; 328  :         goto cleanUp;
; 329  :     }
; 330  :     
; 331  :     // Write image to partition
; 332  :     BP_SetDataPointer(hPartition, 0);
; 333  :     if (!BP_WriteData(hPartition, pData, size))
; 334  :     {
; 335  :         OALMSG(OAL_ERROR, (L"ERROR: Failed writing to OS partition!\r\n"));
; 336  :         goto cleanUp;
; 337  :     }
; 338  :     
; 339  :     //OALLog(L"%s image written\r\n", bExt ? L"EXT" :L"nk");
; 340  : 
; 341  :     // Change boot device to NAND
; 342  :     g_bootCfg.bootDevLoc.IfcType = Internal;
; 343  :     g_bootCfg.bootDevLoc.LogicalLoc = BSP_NAND_REGS_PA + 0x20;
; 344  : 
; 345  :     // Done
; 346  :     rc = TRUE;
; 347  : 
; 348  : cleanUp:
; 349  :     return rc;
; 350  : #else
; 351  :     UNREFERENCED_PARAMETER(address);
; 352  :     UNREFERENCED_PARAMETER(size);
; 353  :     return TRUE;

  00010	e3a03001	 mov         r3, #1
  00014	e58d3000	 str         r3, [sp]

; 354  : #endif
; 355  : }

  00018	e59d0000	 ldr         r0, [sp]
  0001c	e28dd004	 add         sp, sp, #4
  00020	e89d6000	 ldmia       sp, {sp, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M47776|

			 ENDP  ; |WriteFlashNK|

	EXPORT	|BLConfigureFlashPartitions|

  00000			 AREA	 |.pdata|, PDATA
|$T47786| DCD	|$LN5@BLConfigur|
	DCD	0x40000c04
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BLConfigureFlashPartitions| PROC

; 865  : {

  00000		 |$LN5@BLConfigur|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd008	 sub         sp, sp, #8
  00010		 |$M47783|

; 866  :     BOOL rc = FALSE;

  00010	e3a03000	 mov         r3, #0
  00014	e58d3000	 str         r3, [sp]

; 867  : 	
; 868  : #ifndef BSP_NO_NAND_IN_SDBOOT
; 869  : 	
; 870  :     HANDLE hFMD;
; 871  :     PCI_REG_INFO regInfo;
; 872  :     FlashInfo flashInfo;
; 873  :     HANDLE hPartition;
; 874  :     PPARTENTRY pPartitionEntry;
; 875  :     DWORD dwBootPartitionSectorCount;
; 876  : 
; 877  : #ifdef IMGMULTIXIP
; 878  :     // Variable for sector count for the new BinFS region (EXT) 
; 879  :     DWORD dwExtPartitionSectorCount;
; 880  : #endif
; 881  : 
; 882  :     memset(&regInfo, 0, sizeof(PCI_REG_INFO));
; 883  :     regInfo.MemBase.Num    = 1;
; 884  :     regInfo.MemLen.Num     = 1;
; 885  :     regInfo.MemBase.Reg[0] = g_ulFlashBase;
; 886  :     
; 887  :     // Get flash info
; 888  :     hFMD = FMD_Init(NULL, &regInfo, NULL);
; 889  :     if (hFMD == NULL)
; 890  :         goto cleanUp;
; 891  : 
; 892  :     if (!FMD_GetInfo(&flashInfo))
; 893  :         goto cleanUp;
; 894  :     
; 895  :     FMD_Deinit(hFMD);
; 896  :     
; 897  :     // Initialize boot partition library
; 898  :     if (!BP_Init((LPBYTE)g_ulBPartBase, g_ulBPartLengthBytes, NULL, &regInfo, NULL))
; 899  :     {
; 900  :         OALLog(L"BLConfigureFlashPartitions: Error initializing bootpart library!!\r\n");
; 901  :         goto cleanUp;
; 902  :     }
; 903  :     
; 904  :     // Get boot partition size
; 905  :     // Ensure boot partition uses entire blocks with no space left over
; 906  :     // Round up to an even block size
; 907  :     dwBootPartitionSectorCount = ((g_bootCfg.osPartitionSize + (flashInfo.dwBytesPerBlock - 1))/ flashInfo.dwBytesPerBlock) * flashInfo.wSectorsPerBlock;
; 908  : 
; 909  :     // Reduce by one to account for MBR, which will be the first sector in non reserved area.
; 910  :     // This causes boot partition to end on a block boundary
; 911  :     dwBootPartitionSectorCount -= 1;
; 912  : 
; 913  : #ifdef IMGMULTIXIP
; 914  :     
; 915  :     // Calculation of the size for the EXT region
; 916  :     dwExtPartitionSectorCount = ((IMAGE_WINCE_EXT_SIZE + (flashInfo.dwBytesPerBlock - 1))/ flashInfo.dwBytesPerBlock) * flashInfo.wSectorsPerBlock;
; 917  : 
; 918  :     dwExtPartitionSectorCount -= 1;
; 919  : #endif
; 920  : 
; 921  :     // Check for existence and size of OS boot partition
; 922  :     hPartition = BP_OpenPartition((DWORD)NEXT_FREE_LOC, (DWORD)USE_REMAINING_SPACE, PART_BOOTSECTION, FALSE, PART_OPEN_EXISTING);
; 923  :     if (hPartition == INVALID_HANDLE_VALUE)
; 924  :         OALLog(L"OS partition does not exist!!\r\n");
; 925  :     else
; 926  :     {
; 927  :         pPartitionEntry = BP_GetPartitionInfo(hPartition);
; 928  :         if (dwBootPartitionSectorCount != pPartitionEntry->Part_TotalSectors)
; 929  :         {
; 930  :             OALLog(L"OS partition does not match configured size!!  Sector count expected: 0x%x, actual 0x%x\r\n", dwBootPartitionSectorCount, pPartitionEntry->Part_TotalSectors);
; 931  :             // Mark handle invalid to kick us into formatting code
; 932  :             hPartition = INVALID_HANDLE_VALUE;
; 933  :         }
; 934  :     }
; 935  :         
; 936  :     if ((hPartition == INVALID_HANDLE_VALUE) || (bForceEnable == TRUE))
; 937  :     {
; 938  :         // OS binary partition either does not exist or does not match configured size
; 939  :         OALLog(L"Formatting flash...\r\n");
; 940  :         // Create a new partion
; 941  :         // Can't just call BP_OpenPartition with PART_OPEN_ALWAYS because it will erase reserved 
; 942  :         // blocks (bootloader) if MBR doesn't exist.  Also, we want to ensure the boot partition
; 943  :         // is actually the first partition on the flash.  So do low level format here (note that 
; 944  :         // this destroys all other partitions on the device)
; 945  :         // Note, we're skipping the block check for speed reasons. Might not want this in a production device...
; 946  :         BP_LowLevelFormat (0, flashInfo.dwNumBlocks, FORMAT_SKIP_RESERVED|FORMAT_SKIP_BLOCK_CHECK);
; 947  :         // Create the OS partition
; 948  :         hPartition = BP_OpenPartition((DWORD)NEXT_FREE_LOC, dwBootPartitionSectorCount, PART_BOOTSECTION, FALSE, PART_CREATE_NEW);
; 949  :         if (hPartition == INVALID_HANDLE_VALUE)
; 950  :         {
; 951  :             OALLog(L"Error creating OS partition!!\r\n");
; 952  :             goto cleanUp;
; 953  :         }
; 954  :         OALLog(L"NK partition created\r\n");
; 955  : 		
; 956  : #ifdef IMGMULTIXIP
; 957  : 
; 958  :        // Creation of the BinFS partition
; 959  :        hPartition = BP_OpenPartition((DWORD)NEXT_FREE_LOC, dwExtPartitionSectorCount, PART_BINFS, FALSE, PART_CREATE_NEW);
; 960  :        if (hPartition == INVALID_HANDLE_VALUE)
; 961  :        {
; 962  :            OALLog(L"Error creating OS partition!!\r\n");
; 963  :            goto cleanUp;
; 964  :        }
; 965  :        OALLog(L"EXT partition created\r\n");
; 966  : #endif
; 967  : 
; 968  :         // Create FAT partition on remaining flash (can be automatically mounted)
; 969  :         hPartition = BP_OpenPartition((DWORD)NEXT_FREE_LOC, (DWORD)USE_REMAINING_SPACE, PART_DOS32, FALSE, PART_CREATE_NEW);
; 970  :         if (hPartition == INVALID_HANDLE_VALUE)
; 971  :         {
; 972  :             OALLog(L"Error creating file partition!!\r\n");
; 973  :             goto cleanUp;
; 974  :         }
; 975  :         OALLog(L"Flash format complete!\r\n");
; 976  :     }
; 977  :     
; 978  :     // Done
; 979  :     rc = TRUE;
; 980  : 
; 981  : cleanUp:
; 982  : #else
; 983  :     UNREFERENCED_PARAMETER(bForceEnable);
; 984  : #endif
; 985  :     return rc;

  00018	e59d3000	 ldr         r3, [sp]
  0001c	e58d3004	 str         r3, [sp, #4]

; 986  : }

  00020	e59d0004	 ldr         r0, [sp, #4]
  00024	e28dd008	 add         sp, sp, #8
  00028	e89d6000	 ldmia       sp, {sp, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$M47784|

			 ENDP  ; |BLConfigureFlashPartitions|

	END
