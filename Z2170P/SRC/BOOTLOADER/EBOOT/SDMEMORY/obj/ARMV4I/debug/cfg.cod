; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\Z2170P\SRC\BOOTLOADER\EBOOT\SDMEMORY\cfg.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|BLReadBootCfg|
; File c:\wince600\platform\z2170p\src\bootloader\eboot\sdmemory\cfg.c

  00000			 AREA	 |.pdata|, PDATA
|$T46778| DCD	|$LN5@BLReadBoot|
	DCD	0x40000c04
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BLReadBootCfg| PROC

; 29   : {

  00000		 |$LN5@BLReadBoot|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd008	 sub         sp, sp, #8
  00010		 |$M46775|

; 30   :     BOOL rc = FALSE;

  00010	e3a03000	 mov         r3, #0
  00014	e58d3000	 str         r3, [sp]

; 31   : #ifndef BSP_NO_NAND_IN_SDBOOT
; 32   :     HANDLE hFMD;
; 33   :     PCI_REG_INFO regInfo;
; 34   :     FlashInfo flashInfo;
; 35   :     SectorInfo sectorInfo;
; 36   :     SECTOR_ADDR sector;
; 37   :     BLOCK_ID block;
; 38   :     UINT32 count, offset;
; 39   :     UINT8 buffer[2048];
; 40   :     
; 41   : 
; 42   :     // EBOOT configuration is placed in last sector of EBOOT image
; 43   :     regInfo.MemBase.Reg[0] = g_ulFlashBase;
; 44   :     hFMD = FMD_Init(NULL, &regInfo, NULL);
; 45   :     if (hFMD == NULL)
; 46   :         {
; 47   :         OALMSG(OAL_ERROR, (L"ERROR: FMD_Init call failed!\r\n"));
; 48   :         goto cleanUp;
; 49   :         }
; 50   : 
; 51   :     // Get flash info
; 52   :     if (!FMD_GetInfo(&flashInfo))
; 53   :         {
; 54   :         OALMSG(OAL_ERROR, (L"ERROR: FMD_GetInfo call failed!\r\n"));
; 55   :         goto cleanUp;
; 56   :         }
; 57   : 
; 58   :     // We can support only flash with sector size < 2048 bytes
; 59   :     if (flashInfo.wDataBytesPerSector > sizeof(buffer))
; 60   :         {
; 61   :         OALMSG(OAL_ERROR, (L"ERROR: "
; 62   :             L"Flash sector size %d bytes bigger than supported %d bytes\r\n",
; 63   :             flashInfo.wDataBytesPerSector, sizeof(buffer)    
; 64   :             ));
; 65   :         goto cleanUp;
; 66   :         }
; 67   : 
; 68   :     // Configuration is located in last sector of EBOOT image
; 69   :     offset = IMAGE_XLDR_BOOTSEC_NAND_SIZE + IMAGE_EBOOT_BOOTSEC_NAND_SIZE;
; 70   :     
; 71   :     // Start from beginning
; 72   :     block  = 0;
; 73   :     sector = 0;
; 74   : 
; 75   :     // Skip X-Loader & EBOOT code & bad blocks
; 76   :     // Note that we also check the last eboot block in order to ensure it is good
; 77   :     count = 0;
; 78   :     while ((count < offset) && (block < flashInfo.dwNumBlocks))
; 79   :         {
; 80   :         if ((FMD_GetBlockStatus(block) & BLOCK_STATUS_BAD) == 0)
; 81   :             {
; 82   :             count += flashInfo.dwBytesPerBlock;
; 83   :             }
; 84   :         block++;
; 85   :         }
; 86   : 
; 87   :     // We've incremented past the last eboot block in order to check it too
; 88   :     // Back up now, the previous block is the last one containing eboot and is good
; 89   :     block--;
; 90   : 
; 91   :     //  Compute sector within the block where config lies
; 92   :     sector = block * flashInfo.wSectorsPerBlock;
; 93   :     sector += flashInfo.wSectorsPerBlock - 1;
; 94   : 
; 95   :     // Read sector to buffer
; 96   :     if (!FMD_ReadSector(sector, buffer, &sectorInfo, 1)) {
; 97   :         OALMSG(OAL_ERROR, (L"ERROR: EBOOT!BLReadBootCfg: "
; 98   :             L"Flash sector %d read failed\r\n", sector
; 99   :         ));
; 100  :             goto cleanUp;
; 101  :     }
; 102  : 
; 103  :     // Copy data to BOOT_CFG structure
; 104  :     memcpy(pBootCfg, buffer, sizeof(BOOT_CFG));        
; 105  : 
; 106  :     // Done    
; 107  :     rc = TRUE;
; 108  : 
; 109  : cleanUp:
; 110  :     if (hFMD != NULL) FMD_Deinit(hFMD);
; 111  : #else
; 112  :     UNREFERENCED_PARAMETER(pBootCfg);
; 113  : #endif
; 114  :     return rc;

  00018	e59d3000	 ldr         r3, [sp]
  0001c	e58d3004	 str         r3, [sp, #4]

; 115  : }

  00020	e59d0004	 ldr         r0, [sp, #4]
  00024	e28dd008	 add         sp, sp, #8
  00028	e89d6000	 ldmia       sp, {sp, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$M46776|

			 ENDP  ; |BLReadBootCfg|

	EXPORT	|BLWriteBootCfg|

  00000			 AREA	 |.pdata|, PDATA
|$T46786| DCD	|$LN5@BLWriteBoo|
	DCD	0x40000c04
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BLWriteBootCfg| PROC

; 123  : {

  00000		 |$LN5@BLWriteBoo|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd008	 sub         sp, sp, #8
  00010		 |$M46783|

; 124  :     BOOL rc = FALSE;

  00010	e3a03000	 mov         r3, #0
  00014	e58d3000	 str         r3, [sp]

; 125  : #ifndef BSP_NO_NAND_IN_SDBOOT
; 126  :     HANDLE hFMD;
; 127  :     PCI_REG_INFO regInfo;
; 128  :     FlashInfo flashInfo;
; 129  :     SectorInfo sectorInfo;
; 130  :     SECTOR_ADDR sector;
; 131  :     BLOCK_ID block;
; 132  :     UINT32 count, offset, length;
; 133  :     UINT8 buffer[2048];
; 134  :     UINT8 *pEBOOT;
; 135  :     
; 136  : 
; 137  :     // EBOOT configuration is placed in last sector of image
; 138  :     regInfo.MemBase.Reg[0] = g_ulFlashBase;
; 139  :     hFMD = FMD_Init(NULL, &regInfo, NULL);
; 140  :     if (hFMD == NULL)
; 141  :         {
; 142  :         OALMSG(OAL_ERROR, (L"ERROR: FMD_Init call failed!\r\n"));
; 143  :         goto cleanUp;
; 144  :         }
; 145  : 
; 146  :     // Get flash info
; 147  :     if (!FMD_GetInfo(&flashInfo))
; 148  :         {
; 149  :         OALMSG(OAL_ERROR, (L"ERROR: FMD_GetInfo call failed!\r\n"));
; 150  :         goto cleanUp;
; 151  :         }
; 152  : 
; 153  :     // We can support only flash with sector size which fit to our buffer
; 154  :     if (flashInfo.wDataBytesPerSector > sizeof(buffer))
; 155  :         {
; 156  :         OALMSG(OAL_ERROR, (L"ERROR: "
; 157  :             L"Flash sector size %d bytes bigger that supported %d bytes\r\n",
; 158  :             flashInfo.wDataBytesPerSector, sizeof(buffer)    
; 159  :             ));
; 160  :         goto cleanUp;
; 161  :         }
; 162  : 
; 163  :     // Configuration is located in last sector of last EBOOT block
; 164  :     offset = IMAGE_XLDR_BOOTSEC_NAND_SIZE + IMAGE_EBOOT_BOOTSEC_NAND_SIZE;
; 165  :     
; 166  :     // Skip X-Loader & EBOOT code & bad blocks
; 167  :     // Note that we also check the last eboot block in order to ensure it is good
; 168  :     block  = 0;
; 169  :     count = 0;
; 170  :     while ((count < offset) && (block < flashInfo.dwNumBlocks))
; 171  :         {
; 172  :         if ((FMD_GetBlockStatus(block) & BLOCK_STATUS_BAD) == 0)
; 173  :             {
; 174  :             count += flashInfo.dwBytesPerBlock;
; 175  :             }
; 176  :         block++;
; 177  :         }
; 178  : 
; 179  :     // We've incremented past the last eboot block in order to check it too
; 180  :     // Back up now, the previous block is the last one containing eboot and is good
; 181  :     block--;
; 182  : 
; 183  :     // Need to copy off the block contents to RAM (minus the config sector)
; 184  :     pEBOOT = (UINT8*)IMAGE_WINCE_CODE_CA;
; 185  :     length = flashInfo.dwBytesPerBlock - flashInfo.wDataBytesPerSector;
; 186  : 
; 187  :     memset((VOID*)pEBOOT, 0xFF, flashInfo.dwBytesPerBlock);
; 188  :     sector = block * flashInfo.wSectorsPerBlock;
; 189  :     offset = 0;
; 190  : 
; 191  :     while (offset < length) 
; 192  :     {
; 193  :         // When block read fail, there isn't what we can do more
; 194  :         if (!FMD_ReadSector(sector, pEBOOT + offset, &sectorInfo, 1)) {
; 195  :                 OALMSG(OAL_ERROR, (L"\r\nERROR: EBOOT!BLWriteBootCfg: "
; 196  :                     L"Failed read sector %d from flash\r\n", sector
; 197  :                 ));
; 198  :             goto cleanUp;
; 199  :             }
; 200  : 
; 201  :         // Move to next sector
; 202  :         sector++;
; 203  :         offset += flashInfo.wDataBytesPerSector;
; 204  :     }
; 205  : 
; 206  : 
; 207  :     //  Copy the config info into last sector of saved block in RAM
; 208  :     memcpy(pEBOOT + offset, pBootCfg, sizeof(BOOT_CFG)); 
; 209  : 
; 210  : 
; 211  :     // Erase block
; 212  :     if (!FMD_EraseBlock(block))
; 213  :         {
; 214  :         OALMSG(OAL_ERROR, (L"ERROR: EBOOT!BLWriteBootCfg: "
; 215  :             L"Flash block %d erase failed\r\n", block
; 216  :             ));
; 217  :         goto cleanUp;
; 218  :         }
; 219  : 
; 220  : 
; 221  :     // Write contents of the save block + config sector back to flash
; 222  :     pEBOOT = (UINT8*)IMAGE_WINCE_CODE_CA;
; 223  :     length = flashInfo.dwBytesPerBlock;
; 224  : 
; 225  :     sector = block * flashInfo.wSectorsPerBlock;
; 226  :     offset = 0;
; 227  :     while (offset < length)
; 228  :     {
; 229  :         // Prepare sector info
; 230  :         memset(&sectorInfo, 0xFF, sizeof(sectorInfo));
; 231  :         sectorInfo.bOEMReserved &= ~(OEM_BLOCK_READONLY|OEM_BLOCK_RESERVED);
; 232  :         sectorInfo.dwReserved1 = 0;
; 233  :         sectorInfo.wReserved2 = 0;
; 234  : 
; 235  :         // Write sector        
; 236  :         if (!FMD_WriteSector(sector, pEBOOT + offset, &sectorInfo, 1))
; 237  :             {
; 238  :             OALMSG(OAL_ERROR, (L"ERROR: EBOOT!BLWriteBootCfg: "
; 239  :                 L"Flash sector %d write failed\r\n", sector
; 240  :                 ));
; 241  :             goto cleanUp;
; 242  :             }
; 243  : 
; 244  :         // Move to next sector
; 245  :         sector++;
; 246  :         offset += flashInfo.wDataBytesPerSector;
; 247  :     }
; 248  : 
; 249  :     // Done    
; 250  :     rc = TRUE;
; 251  : 
; 252  : cleanUp:
; 253  :     if (hFMD != NULL) FMD_Deinit(hFMD);
; 254  : #else
; 255  :     UNREFERENCED_PARAMETER(pBootCfg);
; 256  : #endif
; 257  :     return rc;

  00018	e59d3000	 ldr         r3, [sp]
  0001c	e58d3004	 str         r3, [sp, #4]

; 258  : }

  00020	e59d0004	 ldr         r0, [sp, #4]
  00024	e28dd008	 add         sp, sp, #8
  00028	e89d6000	 ldmia       sp, {sp, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$M46784|

			 ENDP  ; |BLWriteBootCfg|

	EXPORT	|BLReserveBootBlocks|

  00000			 AREA	 |.pdata|, PDATA
|$T46794| DCD	|$LN5@BLReserveB|
	DCD	0x40000a04
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BLReserveBootBlocks| PROC

; 266  : {

  00000		 |$LN5@BLReserveB|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M46791|

; 267  : #ifndef BSP_NO_NAND_IN_SDBOOT
; 268  :     BOOL rc = FALSE;
; 269  :     HANDLE hFMD;
; 270  :     PCI_REG_INFO regInfo;
; 271  :     FlashInfo flashInfo;
; 272  :     UINT32 size;
; 273  :     BLOCK_ID firstblock, lastblock;
; 274  :     //UINT32 status;
; 275  :     
; 276  :     UNREFERENCED_PARAMETER(pBootCfg);
; 277  : 
; 278  :     // Automatically mark the bootloader blocks as read-only/reserved
; 279  :     regInfo.MemBase.Reg[0] = g_ulFlashBase;
; 280  :     hFMD = FMD_Init(NULL, &regInfo, NULL);
; 281  :     if (hFMD == NULL)
; 282  : 	{
; 283  :         OALMSG(OAL_ERROR, (L"ERROR: FMD_Init call failed!\r\n"));
; 284  :         goto cleanUp;
; 285  : 	}
; 286  : 
; 287  :     // Get flash info
; 288  :     if (!FMD_GetInfo(&flashInfo))
; 289  : 	{
; 290  :         OALMSG(OAL_ERROR, (L"ERROR: FMD_GetInfo call failed!\r\n"));
; 291  :         goto cleanUp;
; 292  : 	}
; 293  : 
; 294  :     //  Loop thru the bootloader blocks to ensure they are marked reserved
; 295  :     firstblock = 0;
; 296  :     size = IMAGE_BOOTLOADER_NAND_SIZE;
; 297  :     lastblock = ((size -1) / flashInfo.dwBytesPerBlock) + 1;
; 298  : 	OALLog(L"IMAGE_BOOTLOADER_NAND_SIZE = 0x%x\r\n", IMAGE_BOOTLOADER_NAND_SIZE);
; 299  : 	OALLog(L"dwBytesPerBlock = 0x%x\r\n", flashInfo.dwBytesPerBlock);
; 300  :     OALLog(L"Checking bootloader blocks are marked as reserved (Num = %d)\r\n", lastblock-firstblock);
; 301  : 
; 302  :     while (firstblock < lastblock)
; 303  : 	{
; 304  : 
; 305  :         // If block is bad, we have to offset it
; 306  :         status = FMD_GetBlockStatus(firstblock);
; 307  : 
; 308  :         // Skip bad blocks
; 309  :         if ((status & BLOCK_STATUS_BAD) != 0) 
; 310  :             {
; 311  :             OALLog(L" Skip bad block %d\r\n", firstblock);
; 312  :             // blocks marked bad would not have been written either, so don't include this 
; 313  :             // in the count of blocks that are reserved.
; 314  :             firstblock++;
; 315  :             lastblock++;
; 316  :             continue;
; 317  :             }
; 318  : 
; 319  :         // Skip already reserved blocks
; 320  :         if ((status & BLOCK_STATUS_RESERVED) != 0) 
; 321  :             {
; 322  :             firstblock++;
; 323  :             continue;
; 324  :             }
; 325  : 
; 326  :         // Mark block as read-only & reserved
; 327  :         if (!FMD_SetBlockStatus(firstblock, BLOCK_STATUS_READONLY|BLOCK_STATUS_RESERVED)) 
; 328  :             {
; 329  :             OALLog(L" Oops, can't mark block %d - as reserved\r\n", firstblock);
; 330  :             }
; 331  : 
; 332  :         firstblock++;
; 333  :         OALLog(L".");
; 334  : 	}
; 335  : 
; 336  :     // Done    
; 337  :     rc = TRUE;
; 338  : 
; 339  :     OALLog(L"\r\n");
; 340  : 
; 341  : cleanUp:
; 342  :     if (hFMD != NULL) FMD_Deinit(hFMD);
; 343  :     return rc;
; 344  : #else
; 345  :     UNREFERENCED_PARAMETER(pBootCfg);
; 346  :     // Nothing to do...
; 347  :     return TRUE;

  00010	e3a03001	 mov         r3, #1
  00014	e58d3000	 str         r3, [sp]

; 348  : 
; 349  : #endif
; 350  : }

  00018	e59d0000	 ldr         r0, [sp]
  0001c	e28dd004	 add         sp, sp, #4
  00020	e89d6000	 ldmia       sp, {sp, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M46792|

			 ENDP  ; |BLReserveBootBlocks|

	EXPORT	|BLShowLogo|
	IMPORT	|ShowLogo|
	IMPORT	|ShowSDLogo|

  00000			 AREA	 |.pdata|, PDATA
|$T46802| DCD	|$LN6@BLShowLogo|
	DCD	0x40001002
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BLShowLogo| PROC

; 357  : {

  00000		 |$LN6@BLShowLogo|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M46799|

; 358  : 	//  Show the bootloader splashscreen if present on the SDCard
; 359  : 	if (!ShowSDLogo())

  00008	eb000000	 bl          ShowSDLogo
  0000c	e58d0004	 str         r0, [sp, #4]
  00010	e59d3004	 ldr         r3, [sp, #4]
  00014	e3530000	 cmp         r3, #0
  00018	1a000002	 bne         |$LN1@BLShowLogo|

; 360  : 	{
; 361  : 		ShowLogo((UINT32)-1, 0);

  0001c	e3a01000	 mov         r1, #0
  00020	e3e00000	 mvn         r0, #0
  00024	eb000000	 bl          ShowLogo
  00028		 |$LN1@BLShowLogo|

; 362  : 	}
; 363  : 
; 364  :     return TRUE;

  00028	e3a03001	 mov         r3, #1
  0002c	e58d3000	 str         r3, [sp]

; 365  : }

  00030	e59d0000	 ldr         r0, [sp]
  00034	e28dd008	 add         sp, sp, #8
  00038	e49de004	 ldr         lr, [sp], #4
  0003c	e12fff1e	 bx          lr
  00040		 |$M46800|

			 ENDP  ; |BLShowLogo|

	END
