; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\Z2170P\SRC\DRIVERS\SDBUS\sddevinf.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.rdata|, DATA, READONLY
|cInandProductName04G| DCB 0x47
	DCB	0x34
	DCB	0x30
	DCB	0x4d
	DCB	0x45
	DCB	0x53
	%	2
|cInandProductName08G| DCB 0x47
	DCB	0x38
	DCB	0x30
	DCB	0x4d
	DCB	0x45
	DCB	0x53
	%	2
|cInandProductName16G| DCB 0x47
	DCB	0x36
	DCB	0x31
	DCB	0x4d
	DCB	0x45
	DCB	0x53
	%	2
|cInandProductName32G| DCB 0x47
	DCB	0x32
	DCB	0x33
	DCB	0x4d
	DCB	0x45
	DCB	0x53
	%	2
|cInandProductName16G_Builtin| DCB 0x47
	DCB	0x36
	DCB	0x31
	DCB	0x4d
	DCB	0x54
	DCB	0x53
	EXPORT	|?SafeIntOnOverflow@@YAXXZ|		; SafeIntOnOverflow
	IMPORT	|RaiseException|
; File c:\wince600\public\common\sdk\inc\safeint.hxx

  00000			 AREA	 |.pdata|, PDATA
|$T40500| DCD	|$LN5@SafeIntOnO|
	DCD	0x40000901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SafeIntOnOverflow@@YAXXZ| PROC	; SafeIntOnOverflow

; 352  : {

  00000		 |$LN5@SafeIntOnO|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M40497|
  00004	e3a03103	 mov         r3, #3, 2

; 353  : 	RaiseException((DWORD) EXCEPTION_INT_OVERFLOW,0,0,NULL);

  00008	e3830095	 orr         r0, r3, #0x95
  0000c	e3a03000	 mov         r3, #0
  00010	e3a02000	 mov         r2, #0
  00014	e3a01000	 mov         r1, #0
  00018	eb000000	 bl          RaiseException

; 354  : }

  0001c	e49de004	 ldr         lr, [sp], #4
  00020	e12fff1e	 bx          lr
  00024		 |$M40498|

			 ENDP  ; |?SafeIntOnOverflow@@YAXXZ|, SafeIntOnOverflow

	EXPORT	|?Lock@CLockObject@@QAAXXZ|		; CLockObject::Lock
	IMPORT	|EnterCriticalSection|
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T40508| DCD	|$LN5@Lock|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Lock@CLockObject@@QAAXXZ| PROC	; CLockObject::Lock

; 45   :     {

  00000		 |$LN5@Lock|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M40505|

; 46   :         EnterCriticalSection( &m_CSection );

  00004	eb000000	 bl          EnterCriticalSection

; 47   :     };

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M40506|

			 ENDP  ; |?Lock@CLockObject@@QAAXXZ|, CLockObject::Lock

	EXPORT	|?Unlock@CLockObject@@QAAXXZ|		; CLockObject::Unlock
	IMPORT	|LeaveCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T40516| DCD	|$LN5@Unlock|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Unlock@CLockObject@@QAAXXZ| PROC	; CLockObject::Unlock

; 49   :     {

  00000		 |$LN5@Unlock|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M40513|

; 50   :         LeaveCriticalSection( &m_CSection );

  00004	eb000000	 bl          LeaveCriticalSection

; 51   :     };

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M40514|

			 ENDP  ; |?Unlock@CLockObject@@QAAXXZ|, CLockObject::Unlock

	EXPORT	|?AddRef@CRefObject@@QAAKXZ|		; CRefObject::AddRef
	IMPORT	|InterlockedIncrement|
; File c:\wince600\public\common\oak\inc\crefcon.h

  00000			 AREA	 |.pdata|, PDATA
|$T40526| DCD	|$LN5@AddRef|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AddRef@CRefObject@@QAAKXZ| PROC	; CRefObject::AddRef

; 43   :     {

  00000		 |$LN5@AddRef|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M40523|

; 44   :         return (DWORD)InterlockedIncrement(&m_lRefCount);

  00004	e2800004	 add         r0, r0, #4
  00008	eb000000	 bl          InterlockedIncrement

; 45   :     };

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M40524|

			 ENDP  ; |?AddRef@CRefObject@@QAAKXZ|, CRefObject::AddRef

	EXPORT	|?DeRef@CRefObject@@QAAKXZ|		; CRefObject::DeRef
	IMPORT	|InterlockedDecrement|

  00000			 AREA	 |.pdata|, PDATA
|$T40541| DCD	|$LN8@DeRef|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DeRef@CRefObject@@QAAKXZ| PROC	; CRefObject::DeRef

; 47   :     {

  00000		 |$LN8@DeRef|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M40538|
  00004	e1a04000	 mov         r4, r0

; 48   :         LONG lReturn = InterlockedDecrement(&m_lRefCount);

  00008	e2840004	 add         r0, r4, #4
  0000c	eb000000	 bl          InterlockedDecrement
  00010	e1a05000	 mov         r5, r0

; 49   :         if( lReturn <= 0 ) {

  00014	e3550000	 cmp         r5, #0
  00018	ca000006	 bgt         |$LN4@DeRef|

; 50   :             delete this;

  0001c	e3540000	 cmp         r4, #0
  00020	15943000	 ldrne       r3, [r4]
  00024	13a01001	 movne       r1, #1
  00028	11a00004	 movne       r0, r4
  0002c	15933000	 ldrne       r3, [r3]
  00030	11a0e00f	 movne       lr, pc
  00034	112fff13	 bxne        r3
  00038		 |$LN4@DeRef|

; 51   :         }
; 52   :         return (DWORD)lReturn;
; 53   :     }

  00038	e1a00005	 mov         r0, r5
  0003c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M40539|

			 ENDP  ; |?DeRef@CRefObject@@QAAKXZ|, CRefObject::DeRef

	EXPORT	|?ConvertFromEx@@YA?AU_SD_CARD_INTERFACE@@U_SD_CARD_INTERFACE_EX@@@Z| ; ConvertFromEx
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdbus.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T40561| DCD	|$LN11@ConvertFro|
	DCD	0x40000d00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ConvertFromEx@@YA?AU_SD_CARD_INTERFACE@@U_SD_CARD_INTERFACE_EX@@@Z| PROC ; ConvertFromEx

; 91   : {

  00000		 |$LN11@ConvertFro|
  00000		 |$M40558|

; 92   : 	// default to 1 bit
; 93   : 	SD_INTERFACE_MODE bInterfaceMode = SD_INTERFACE_SD_MMC_1BIT;
; 94   : 
; 95   : 	// can we upgrade to 4 bits? if not use original value of bInterfaceMode
; 96   : 	bInterfaceMode = sdInterfaceEx.InterfaceModeEx.bit.sd4Bit!=0?SD_INTERFACE_SD_4BIT: bInterfaceMode;

  00000	e3110001	 tst         r1, #1
  00004	e3a03000	 mov         r3, #0
  00008	13a03001	 movne       r3, #1

; 97   : 
; 98   : 	// can we upgrade to 8 bits? if not use bInterfaceMode, which could be 4 or 1 at this point
; 99   : 	bInterfaceMode = sdInterfaceEx.InterfaceModeEx.bit.sd8Bit!=0?SD_INTERFACE_SD_MMC_8BIT: bInterfaceMode;

  0000c	e3110004	 tst         r1, #4
  00010	13a03002	 movne       r3, #2

; 100  : 
; 101  : 
; 102  : 
; 103  : 
; 104  :     SD_CARD_INTERFACE sdCardInterface = {
; 105  :         bInterfaceMode,
; 106  :         sdInterfaceEx.ClockRate,
; 107  :         sdInterfaceEx.InterfaceModeEx.bit.sdWriteProtected!=0
; 108  :     };

  00014	e3110101	 tst         r1, #1, 2
  00018	e5803000	 str         r3, [r0]
  0001c	13a03001	 movne       r3, #1
  00020	15803008	 strne       r3, [r0, #8]
  00024	e5802004	 str         r2, [r0, #4]
  00028	03a03000	 moveq       r3, #0
  0002c	05803008	 streq       r3, [r0, #8]

; 109  :     return sdCardInterface;
; 110  : }

  00030	e12fff1e	 bx          lr
  00034		 |$M40559|

			 ENDP  ; |?ConvertFromEx@@YA?AU_SD_CARD_INTERFACE@@U_SD_CARD_INTERFACE_EX@@@Z|, ConvertFromEx

	EXPORT	|?SlotOptionHandler@CSDHost@@QAAJKW4_SD_SLOT_OPTION_CODE@@PAXK@Z| ; CSDHost::SlotOptionHandler

  00000			 AREA	 |.pdata|, PDATA
|$T40576| DCD	|$LN7@SlotOption|
	DCD	0x40000f02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SlotOptionHandler@CSDHost@@QAAJKW4_SD_SLOT_OPTION_CODE@@PAXK@Z| PROC ; CSDHost::SlotOptionHandler

; 139  :     SD_API_STATUS   SlotOptionHandler(DWORD dwSlot, SD_SLOT_OPTION_CODE sdSlotOption, PVOID pvParam, ULONG uSize) { // slot option handler

  00000		 |$LN7@SlotOption|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M40573|
  00008	e1a05002	 mov         r5, r2
  0000c	e1b0e000	 movs        lr, r0

; 140  :         return pSlotOptionHandler((PSDCARD_HC_CONTEXT)this,dwSlot,sdSlotOption,pvParam,uSize);

  00010	e59d2010	 ldr         r2, [sp, #0x10]
  00014	e59e4044	 ldr         r4, [lr, #0x44]
  00018	128e0008	 addne       r0, lr, #8
  0001c	e58d2000	 str         r2, [sp]
  00020	e1a02005	 mov         r2, r5
  00024	03a00000	 moveq       r0, #0
  00028	e1a0e00f	 mov         lr, pc
  0002c	e12fff14	 bx          r4

; 141  :     }

  00030	e28dd004	 add         sp, sp, #4
  00034	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$M40574|

			 ENDP  ; |?SlotOptionHandler@CSDHost@@QAAJKW4_SD_SLOT_OPTION_CODE@@PAXK@Z|, CSDHost::SlotOptionHandler

	EXPORT	|?GetCardInfo@CSDDevice@@QAAAAU_SDCARD_INFORMATION@@XZ| ; CSDDevice::GetCardInfo
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T40586| DCD	|$LN5@GetCardInf|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetCardInfo@CSDDevice@@QAAAAU_SDCARD_INFORMATION@@XZ| PROC ; CSDDevice::GetCardInfo

; 149  :     SDCARD_INFORMATION& GetCardInfo() { return m_SDCardInfo; };

  00000		 |$LN5@GetCardInf|
  00000		 |$M40583|
  00000	e2803b01	 add         r3, r0, #1, 22
  00004	e28300d8	 add         r0, r3, #0xD8
  00008	e12fff1e	 bx          lr
  0000c		 |$M40584|

			 ENDP  ; |?GetCardInfo@CSDDevice@@QAAAAU_SDCARD_INFORMATION@@XZ|, CSDDevice::GetCardInfo

	EXPORT	|?GetHost@CSDSlot@@QAAAAVCSDHost@@XZ|	; CSDSlot::GetHost
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdslot.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T40596| DCD	|$LN5@GetHost|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetHost@CSDSlot@@QAAAAVCSDHost@@XZ| PROC ; CSDSlot::GetHost

; 99   :     CSDHost&    GetHost() { return m_SdHost; };

  00000		 |$LN5@GetHost|
  00000		 |$M40593|
  00000	e590007c	 ldr         r0, [r0, #0x7C]
  00004	e12fff1e	 bx          lr
  00008		 |$M40594|

			 ENDP  ; |?GetHost@CSDSlot@@QAAAAVCSDHost@@XZ|, CSDSlot::GetHost

	EXPORT	|?GetSlotIndex@CSDSlot@@QAAKXZ|		; CSDSlot::GetSlotIndex

  00000			 AREA	 |.pdata|, PDATA
|$T40606| DCD	|$LN5@GetSlotInd|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetSlotIndex@CSDSlot@@QAAKXZ| PROC	; CSDSlot::GetSlotIndex

; 106  :     DWORD   GetSlotIndex() { return m_dwSlotIndex; };

  00000		 |$LN5@GetSlotInd|
  00000		 |$M40603|
  00000	e5900080	 ldr         r0, [r0, #0x80]
  00004	e12fff1e	 bx          lr
  00008		 |$M40604|

			 ENDP  ; |?GetSlotIndex@CSDSlot@@QAAKXZ|, CSDSlot::GetSlotIndex

	EXPORT	|?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z| ; CSDSlot::GetFunctionDevice
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T40629| DCD	|$LN15@GetFunctio|
	DCD	0x40001401
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdslot.hpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z| PROC ; CSDSlot::GetFunctionDevice

; 155  :     inline CSDDevice * GetFunctionDevice(DWORD dwIndex){

  00000		 |$LN15@GetFunctio|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M40626|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 156  :         m_SlotLock.Lock();

  0000c	e28500b4	 add         r0, r5, #0xB4
  00010	eb000000	 bl          EnterCriticalSection

; 157  :         CSDDevice*  pReturn = dwIndex < SD_MAXIMUM_DEVICE_PER_SLOT ? m_pFuncDevice[dwIndex] : NULL;

  00014	e3540008	 cmp         r4, #8
  00018	30853104	 addcc       r3, r5, r4, lsl #2
  0001c	359340c8	 ldrcc       r4, [r3, #0xC8]
  00020	23a04000	 movcs       r4, #0

; 158  :         if( pReturn )  {

  00024	e3540000	 cmp         r4, #0
  00028	0a000002	 beq         |$LN2@GetFunctio|

; 159  :             pReturn->AddRef();

  0002c	e2840004	 add         r0, r4, #4
  00030	eb000000	 bl          InterlockedIncrement

; 160  :         }
; 161  :         else

  00034	ea000000	 b           |$LN1@GetFunctio|
  00038		 |$LN2@GetFunctio|

; 162  :             pReturn = NULL;

  00038	e3a04000	 mov         r4, #0
  0003c		 |$LN1@GetFunctio|

; 163  :         m_SlotLock.Unlock();

  0003c	e28500b4	 add         r0, r5, #0xB4
  00040	eb000000	 bl          LeaveCriticalSection

; 164  :         return pReturn;
; 165  :     }

  00044	e1a00004	 mov         r0, r4
  00048	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M40627|

			 ENDP  ; |?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z|, CSDSlot::GetFunctionDevice

	EXPORT	|?IsHighCapacitySDMemory@CSDDevice@@QAAHXZ| ; CSDDevice::IsHighCapacitySDMemory
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevinf.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T40641| DCD	|$LN10@IsHighCapa|
	DCD	0x40000d00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsHighCapacitySDMemory@CSDDevice@@QAAHXZ| PROC ; CSDDevice::IsHighCapacitySDMemory

; 49   : {

  00000		 |$LN10@IsHighCapa|
  00000		 |$M40638|

; 50   :     if (m_DeviceType == Device_SD_Memory || m_DeviceType == Device_MMC || m_DeviceType == Device_SD_Combo ) {

  00000	e5903494	 ldr         r3, [r0, #0x494]
  00004	e3530002	 cmp         r3, #2
  00008	0a000003	 beq         |$LN2@IsHighCapa|
  0000c	e3530001	 cmp         r3, #1
  00010	0a000001	 beq         |$LN2@IsHighCapa|
  00014	e3530004	 cmp         r3, #4

; 52   :     }
; 53   :     else 
; 54   :         return FALSE;

  00018	1a000003	 bne         |$LN6@IsHighCapa|
  0001c		 |$LN2@IsHighCapa|

; 51   :         return ( (m_CachedRegisters.OCR[3] & 0x40)!=0) ; // OCR Bit 30 is Card Capacity Status bit.

  0001c	e5d034a5	 ldrb        r3, [r0, #0x4A5]
  00020	e3130040	 tst         r3, #0x40
  00024	13a00001	 movne       r0, #1

; 55   : }

  00028	112fff1e	 bxne        lr
  0002c		 |$LN6@IsHighCapa|

; 51   :         return ( (m_CachedRegisters.OCR[3] & 0x40)!=0) ; // OCR Bit 30 is Card Capacity Status bit.

  0002c	e3a00000	 mov         r0, #0

; 55   : }

  00030	e12fff1e	 bx          lr
  00034		 |$M40639|

			 ENDP  ; |?IsHighCapacitySDMemory@CSDDevice@@QAAHXZ|, CSDDevice::IsHighCapacitySDMemory

	EXPORT	|?SDGetTupleBytes@CSDDevice@@IAAJKPAEKH@Z| ; CSDDevice::SDGetTupleBytes

  00000			 AREA	 |.pdata|, PDATA
|$T40660| DCD	|$LN15@SDGetTuple|
	DCD	0x40003902
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDGetTupleBytes@CSDDevice@@IAAJKPAEKH@Z| PROC ; CSDDevice::SDGetTupleBytes

; 190  : {

  00000		 |$LN15@SDGetTuple|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M40657|
  00008	e1a08003	 mov         r8, r3
  0000c	e1a07002	 mov         r7, r2
  00010	e1a09001	 mov         r9, r1

; 191  :     SD_API_STATUS          status;          // intermediate status
; 192  :     DWORD                  tupleAddress;    // calculated tuple address
; 193  : 
; 194  : 
; 195  :     status = SD_API_STATUS_INVALID_PARAMETER;
; 196  : 
; 197  :     if (m_DeviceType == Device_SD_IO || m_DeviceType == Device_SD_Combo ) {

  00014	e590e494	 ldr         lr, [r0, #0x494]
  00018	e3a0411f	 mov         r4, #0x1F, 2
  0001c	e35e0003	 cmp         lr, #3
  00020	0a000001	 beq         |$LN8@SDGetTuple|
  00024	e35e0004	 cmp         lr, #4
  00028	1a000029	 bne         |$LN10@SDGetTuple|
  0002c		 |$LN8@SDGetTuple|

; 198  :         if (CommonCIS) {

  0002c	e59d5024	 ldr         r5, [sp, #0x24]
  00030	e3550000	 cmp         r5, #0
  00034	0a000011	 beq         |$LN7@SDGetTuple|

; 199  :             if (m_FuncionIndex!=0) {

  00038	e590e43c	 ldr         lr, [r0, #0x43C]
  0003c	e35e0000	 cmp         lr, #0
  00040	0a00000b	 beq         |$LN6@SDGetTuple|

; 200  :                 CSDDevice * psdDevice0 = m_sdSlot.GetFunctionDevice(0);

  00044	e5900438	 ldr         r0, [r0, #0x438]
  00048	e3a01000	 mov         r1, #0
  0004c	eb000000	 bl          |?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z|
  00050	e1b06000	 movs        r6, r0

; 201  :                 if (psdDevice0) {

  00054	0a00001e	 beq         |$LN10@SDGetTuple|

; 202  :                     status = psdDevice0->SDGetTupleBytes(Offset,pBuffer,NumberOfBytes, CommonCIS);

  00058	e1a03008	 mov         r3, r8
  0005c	e1a02007	 mov         r2, r7
  00060	e1a01009	 mov         r1, r9
  00064	e1a00006	 mov         r0, r6
  00068	e58d5000	 str         r5, [sp]
  0006c	eb000000	 bl          |?SDGetTupleBytes@CSDDevice@@IAAJKPAEKH@Z|

; 203  :                     psdDevice0->DeRef();
; 204  :                 }
; 205  :                 return status;

  00070	ea000014	 b           |$LN12@SDGetTuple|
  00074		 |$LN6@SDGetTuple|

; 206  :             }
; 207  :             else {
; 208  :                 DEBUGCHK(NULL != m_SDCardInfo.SDIOInformation.pCommonInformation);
; 209  :                 DEBUGCHK(0 != m_SDCardInfo.SDIOInformation.pCommonInformation->CommonCISPointer);
; 210  :                 // the tuple starting address is at the common CIS pointer
; 211  :                 tupleAddress = m_SDCardInfo.SDIOInformation.pCommonInformation->CommonCISPointer;

  00074	e59034ec	 ldr         r3, [r0, #0x4EC]
  00078	e5935004	 ldr         r5, [r3, #4]

; 212  :             }
; 213  :         } else { 

  0007c	ea000000	 b           |$LN3@SDGetTuple|
  00080		 |$LN7@SDGetTuple|

; 214  :             DEBUGCHK(0 != m_SDCardInfo.SDIOInformation.CISPointer);
; 215  :             // the tuple starting address is at the function CIS pointer
; 216  :             tupleAddress = m_SDCardInfo.SDIOInformation.CISPointer;

  00080	e59054dc	 ldr         r5, [r0, #0x4DC]
  00084		 |$LN3@SDGetTuple|

; 217  :         }
; 218  : 
; 219  :         // add the desired offset
; 220  :         tupleAddress += Offset;
; 221  : 
; 222  :         if (NULL != pBuffer) {

  00084	e3570000	 cmp         r7, #0
  00088	0a000011	 beq         |$LN10@SDGetTuple|

; 223  :             CSDDevice * psdDevice0 = m_sdSlot.GetFunctionDevice(0);

  0008c	e5900438	 ldr         r0, [r0, #0x438]
  00090	e3a01000	 mov         r1, #0
  00094	eb000000	 bl          |?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z|
  00098	e1b06000	 movs        r6, r0

; 224  :             if (psdDevice0) {

  0009c	0a00000c	 beq         |$LN10@SDGetTuple|

; 225  :                 status = psdDevice0->SDReadWriteRegistersDirect_I( SD_IO_READ,tupleAddress,FALSE,pBuffer,NumberOfBytes); 

  000a0	e5961000	 ldr         r1, [r6]
  000a4	e3a03000	 mov         r3, #0
  000a8	e0852009	 add         r2, r5, r9
  000ac	e5914010	 ldr         r4, [r1, #0x10]
  000b0	e3a01000	 mov         r1, #0
  000b4	e1a00006	 mov         r0, r6
  000b8	e58d8004	 str         r8, [sp, #4]
  000bc	e58d7000	 str         r7, [sp]
  000c0	e1a0e00f	 mov         lr, pc
  000c4	e12fff14	 bx          r4
  000c8		 |$LN12@SDGetTuple|
  000c8	e1a04000	 mov         r4, r0

; 226  :                 psdDevice0->DeRef();

  000cc	e1a00006	 mov         r0, r6
  000d0	eb000000	 bl          |?DeRef@CRefObject@@QAAKXZ|
  000d4		 |$LN10@SDGetTuple|

; 227  :             }
; 228  : 
; 229  :         }
; 230  :     }
; 231  :     ASSERT(SD_API_SUCCESS(status));
; 232  :     return status;
; 233  : }

  000d4	e1a00004	 mov         r0, r4
  000d8	e28dd008	 add         sp, sp, #8
  000dc	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000e0	e12fff1e	 bx          lr
  000e4		 |$M40658|

			 ENDP  ; |?SDGetTupleBytes@CSDDevice@@IAAJKPAEKH@Z|, CSDDevice::SDGetTupleBytes

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?SDGetFunctionPowerControlTuples@CSDDevice@@IAAJXZ| ; CSDDevice::SDGetFunctionPowerControlTuples
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|__security_check_cookie|

  00000			 AREA	 |.pdata|, PDATA
|$T40683| DCD	|$LN15@SDGetFunct|
	DCD	0xc0005102

  00000			 AREA	 |.xdata|, DATA
|$T40679| DCD	0xffffffe4
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T40679|

  00008		 |?SDGetFunctionPowerControlTuples@CSDDevice@@IAAJXZ| PROC ; CSDDevice::SDGetFunctionPowerControlTuples

; 277  : {

  00008		 |$LN15@SDGetFunct|
  00008	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  0000c	e24ddf43	 sub         sp, sp, #0x43, 30
  00010		 |$M40680|
  00010	e1a06000	 mov         r6, r0
  00014	e59f312c	 ldr         r3, [pc, #0x12C]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3108	 str         r3, [sp, #0x108]

; 278  :     SD_API_STATUS               status;             // intermediate status
; 279  :     ULONG                       length;             // tuple length
; 280  :     UCHAR                       buffer[SD_CISTPLE_MAX_BODY_SIZE]; //tupple info
; 281  :     P_SDIO_TPLFID_FUNC17_V10    pV1FunctionTuple;   // SDIO V1.0 Function Tuple
; 282  :     P_SDIO_TPLFID_FUNC17_V11    pV11FunctionTupleExt;// SDIO V1.1 Extentions to Function Tuple
; 283  :     PSD_FUNCTION_POWER_DRAW     pPowerDrawData = &m_SDCardInfo.SDIOInformation.PowerDrawData;
; 284  : 
; 285  :     length = 0;
; 286  : 
; 287  :         // get the FUNCE tuple
; 288  :     status = SDGetTuple_I( SD_CISTPL_FUNCE, NULL, &length, FALSE);

  00020	e5963000	 ldr         r3, [r6]
  00024	e3a07000	 mov         r7, #0
  00028	e3a08000	 mov         r8, #0
  0002c	e5934030	 ldr         r4, [r3, #0x30]
  00030	e28d3004	 add         r3, sp, #4
  00034	e2865c05	 add         r5, r6, #5, 24
  00038	e3a02000	 mov         r2, #0
  0003c	e3a01022	 mov         r1, #0x22
  00040	e58d7004	 str         r7, [sp, #4]
  00044	e58d8000	 str         r8, [sp]
  00048	e1a0e00f	 mov         lr, pc
  0004c	e12fff14	 bx          r4
  00050	e1b04000	 movs        r4, r0

; 289  : 
; 290  :     if (!SD_API_SUCCESS(status)) {

  00054	5a000002	 bpl         |$LN8@SDGetFunct|
  00058		 |$LN11@SDGetFunct|

; 291  :          return status;

  00058	e59d0108	 ldr         r0, [sp, #0x108]
  0005c	eb000000	 bl          __security_check_cookie
  00060	ea000034	 b           |$LN9@SDGetFunct|
  00064		 |$LN8@SDGetFunct|

; 292  :     }
; 293  : 
; 294  :     if (0 == length) {

  00064	e59d3004	 ldr         r3, [sp, #4]
  00068	e3530000	 cmp         r3, #0
  0006c	1a000003	 bne         |$LN7@SDGetFunct|
  00070		 |$LN12@SDGetFunct|

; 295  :         DbgPrintZo(SDCARD_ZONE_ERROR, 
; 296  :             (TEXT("SDBusDriver: Card does not have FUNCE tuple! \n")));
; 297  :            return SD_API_STATUS_DEVICE_UNSUPPORTED;

  00070	e59d0108	 ldr         r0, [sp, #0x108]
  00074	eb000000	 bl          __security_check_cookie
  00078	e3a0415f	 mov         r4, #0x5F, 2
  0007c	ea00002d	 b           |$LN9@SDGetFunct|
  00080		 |$LN7@SDGetFunct|

; 298  :     } else {
; 299  : 
; 300  :         if (length < sizeof(SDIO_TPLFID_FUNC17_V10)) {

  00080	e3530018	 cmp         r3, #0x18

; 301  :              DbgPrintZo(SDCARD_ZONE_ERROR, 
; 302  :                 (TEXT("SDBusDriver: Function tuple reports size of %d , expecting %d or greater\n"),
; 303  :                 length, sizeof(SDIO_TPLFID_FUNC17_V10)));
; 304  :             return SD_API_STATUS_DEVICE_UNSUPPORTED;   

  00084	3afffff9	 bcc         |$LN12@SDGetFunct|

; 305  :         }
; 306  : 
; 307  :             // get the tplIDfunction tuple 
; 308  :         status = SDGetTuple_I(SD_CISTPL_FUNCE,(PUCHAR)buffer,&length,FALSE);

  00088	e5961000	 ldr         r1, [r6]
  0008c	e28d3004	 add         r3, sp, #4
  00090	e28d2008	 add         r2, sp, #8
  00094	e5914030	 ldr         r4, [r1, #0x30]
  00098	e3a01022	 mov         r1, #0x22
  0009c	e1a00006	 mov         r0, r6
  000a0	e58d8000	 str         r8, [sp]
  000a4	e1a0e00f	 mov         lr, pc
  000a8	e12fff14	 bx          r4
  000ac	e1b04000	 movs        r4, r0

; 309  : 
; 310  :         if (!SD_API_SUCCESS(status)) {
; 311  :              return status;

  000b0	4affffe8	 bmi         |$LN11@SDGetFunct|

; 312  :         }
; 313  : 
; 314  :         if (buffer[0] != 0x01) {

  000b4	e5dd3008	 ldrb        r3, [sp, #8]
  000b8	e3530001	 cmp         r3, #1

; 315  :              DbgPrintZo(SDCARD_ZONE_ERROR, 
; 316  :                 (TEXT("SDBusDriver: Tuple is not Extended Data type: %d \n"),
; 317  :                 buffer[0]));
; 318  :             return SD_API_STATUS_DEVICE_UNSUPPORTED;   

  000bc	1affffeb	 bne         |$LN12@SDGetFunct|

; 319  :         }
; 320  : 
; 321  :         pV1FunctionTuple = (P_SDIO_TPLFID_FUNC17_V10)buffer;
; 322  : 
; 323  :         pPowerDrawData->OpMinPower = pV1FunctionTuple->OpMinPwr;
; 324  :         pPowerDrawData->OpAvePower = pV1FunctionTuple->OpAvgPwr;
; 325  :         pPowerDrawData->OpMaxPower = pV1FunctionTuple->OpMaxPwr;
; 326  : 
; 327  : 
; 328  :         if (length < (sizeof(SDIO_TPLFID_FUNC17_V10) + sizeof(SDIO_TPLFID_FUNC17_V11))) {

  000c0	e59d0004	 ldr         r0, [sp, #4]
  000c4	e5dd3016	 ldrb        r3, [sp, #0x16]
  000c8	e5dd2017	 ldrb        r2, [sp, #0x17]
  000cc	e5dd1018	 ldrb        r1, [sp, #0x18]
  000d0	e3500026	 cmp         r0, #0x26

; 329  :             pPowerDrawData->SpAvePower33 = 0;

  000d4	31c581b8	 strcch      r8, [r5, #0x18]

; 330  :             pPowerDrawData->SpMaxPower33 = 0;

  000d8	31c581ba	 strcch      r8, [r5, #0x1A]

; 331  : 
; 332  :             pPowerDrawData->HpAvePower33 = 0;

  000dc	31c581bc	 strcch      r8, [r5, #0x1C]

; 333  :             pPowerDrawData->HpMaxPower33 = 0;

  000e0	31c581be	 strcch      r8, [r5, #0x1E]

; 334  : 
; 335  :             pPowerDrawData->LpAvePower33 = 0;

  000e4	31c582b0	 strcch      r8, [r5, #0x20]

; 336  :             pPowerDrawData->LpMaxPower33 = 0;

  000e8	31c582b2	 strcch      r8, [r5, #0x22]
  000ec	e1c531b2	 strh        r3, [r5, #0x12]
  000f0	e1c521b4	 strh        r2, [r5, #0x14]
  000f4	e1c511b6	 strh        r1, [r5, #0x16]
  000f8	3a00000b	 bcc         |$LN1@SDGetFunct|

; 337  :         }
; 338  :         else
; 339  :         {
; 340  :             pV11FunctionTupleExt = (P_SDIO_TPLFID_FUNC17_V11)(&buffer[sizeof(SDIO_TPLFID_FUNC17_V10)]);
; 341  : 
; 342  :             pPowerDrawData->SpAvePower33 = pV11FunctionTupleExt->SpAvePwr33V;

  000fc	e1dd32b2	 ldrh        r3, [sp, #0x22]

; 343  :             pPowerDrawData->SpMaxPower33 = pV11FunctionTupleExt->SpMaxPwr33V;

  00100	e1dd22b4	 ldrh        r2, [sp, #0x24]

; 344  : 
; 345  :             pPowerDrawData->HpAvePower33 = pV11FunctionTupleExt->HpAvePwr33V;

  00104	e1dd12b6	 ldrh        r1, [sp, #0x26]

; 346  :             pPowerDrawData->HpMaxPower33 = pV11FunctionTupleExt->HpMaxPwr33V;

  00108	e1dd02b8	 ldrh        r0, [sp, #0x28]

; 347  : 
; 348  :             pPowerDrawData->LpAvePower33 = pV11FunctionTupleExt->LpAvePwr33V;

  0010c	e1dde2ba	 ldrh        lr, [sp, #0x2A]

; 349  :             pPowerDrawData->LpMaxPower33 = pV11FunctionTupleExt->LpMaxPwr33V;

  00110	e1dd42bc	 ldrh        r4, [sp, #0x2C]
  00114	e1c531b8	 strh        r3, [r5, #0x18]
  00118	e1c521ba	 strh        r2, [r5, #0x1A]
  0011c	e1c511bc	 strh        r1, [r5, #0x1C]
  00120	e1c501be	 strh        r0, [r5, #0x1E]
  00124	e1c5e2b0	 strh        lr, [r5, #0x20]
  00128	e1c542b2	 strh        r4, [r5, #0x22]
  0012c		 |$LN1@SDGetFunct|

; 350  :         }
; 351  :     }
; 352  : 
; 353  :     DbgPrintZo(SDBUS_ZONE_DEVICE, (TEXT("SDBusDriver: Function %d Power Draw:\r\n"),m_SDCardInfo.SDIOInformation.Function));
; 354  :     DbgPrintZo(SDBUS_ZONE_DEVICE, (TEXT("    OpMinPower %d mA\r\n"),   m_SDCardInfo.SDIOInformation.PowerDrawData.OpMinPower));
; 355  :     DbgPrintZo(SDBUS_ZONE_DEVICE, (TEXT("    OpAvePower %d mA\r\n"),   m_SDCardInfo.SDIOInformation.PowerDrawData.OpAvePower));
; 356  :     DbgPrintZo(SDBUS_ZONE_DEVICE, (TEXT("    OpMaxPower %d mA\r\n"),   m_SDCardInfo.SDIOInformation.PowerDrawData.OpMaxPower));
; 357  :     DbgPrintZo(SDBUS_ZONE_DEVICE, (TEXT("    SpAvePower33 %d mA\r\n"), m_SDCardInfo.SDIOInformation.PowerDrawData.SpAvePower33));
; 358  :     DbgPrintZo(SDBUS_ZONE_DEVICE, (TEXT("    SpAvePower33 %d mA\r\n"), m_SDCardInfo.SDIOInformation.PowerDrawData.SpMaxPower33));
; 359  :     DbgPrintZo(SDBUS_ZONE_DEVICE, (TEXT("    HpAvePower33 %d mA\r\n"), m_SDCardInfo.SDIOInformation.PowerDrawData.HpAvePower33));
; 360  :     DbgPrintZo(SDBUS_ZONE_DEVICE, (TEXT("    HpMaxPower33 %d mA\r\n"), m_SDCardInfo.SDIOInformation.PowerDrawData.HpMaxPower33));
; 361  :     DbgPrintZo(SDBUS_ZONE_DEVICE, (TEXT("    LpAvePower33 %d mA\r\n"), m_SDCardInfo.SDIOInformation.PowerDrawData.LpAvePower33));
; 362  :     DbgPrintZo(SDBUS_ZONE_DEVICE, (TEXT("    LpMaxPower33 %d mA\r\n"), m_SDCardInfo.SDIOInformation.PowerDrawData.LpMaxPower33));
; 363  : 
; 364  : 
; 365  :     return SD_API_STATUS_SUCCESS;

  0012c	e59d0108	 ldr         r0, [sp, #0x108]
  00130	eb000000	 bl          __security_check_cookie
  00134	e3a04000	 mov         r4, #0
  00138		 |$LN9@SDGetFunct|

; 366  : }

  00138	e1a00004	 mov         r0, r4
  0013c	e28ddf43	 add         sp, sp, #0x43, 30
  00140	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00144	e12fff1e	 bx          lr
  00148		 |$LN16@SDGetFunct|
  00148		 |$LN17@SDGetFunct|
  00148	00000000	 DCD         |__security_cookie|
  0014c		 |$M40681|

			 ENDP  ; |?SDGetFunctionPowerControlTuples@CSDDevice@@IAAJXZ|, CSDDevice::SDGetFunctionPowerControlTuples

	EXPORT	|?GetFunctionPowerState@CSDDevice@@QAAJPAU_FUNCTION_POWER_STATE@@@Z| ; CSDDevice::GetFunctionPowerState
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T40719| DCD	|$LN43@GetFunctio@2|
	DCD	0x40009202
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevinf.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetFunctionPowerState@CSDDevice@@QAAJPAU_FUNCTION_POWER_STATE@@@Z| PROC ; CSDDevice::GetFunctionPowerState

; 377  : {

  00000		 |$LN43@GetFunctio@2|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M40716|
  00008	e1a06001	 mov         r6, r1
  0000c	e1a07000	 mov         r7, r0

; 378  :     SD_API_STATUS   status = SD_API_STATUS_INVALID_PARAMETER;         // intermediate status
; 379  :     DWORD           FBROffset;      // calculated FBR offset
; 380  :     UCHAR           regValue;       // register value
; 381  :     
; 382  :     if (m_FuncionIndex == 0 || pPowerState == NULL) {

  00010	e597343c	 ldr         r3, [r7, #0x43C]
  00014	e3530000	 cmp         r3, #0
  00018	0a000086	 beq         |$LN22@GetFunctio@2|
  0001c	e3560000	 cmp         r6, #0
  00020	0a000084	 beq         |$LN22@GetFunctio@2|

; 384  :     }
; 385  :     CSDDevice *pDevice0 = m_sdSlot.GetFunctionDevice(0);

  00024	e5970438	 ldr         r0, [r7, #0x438]
  00028	e3a01000	 mov         r1, #0
  0002c	eb000000	 bl          |?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z|
  00030	e3500000	 cmp         r0, #0

; 386  :     if (pDevice0 == NULL) {
; 387  :         return SD_API_STATUS_INVALID_PARAMETER;

  00034	0a00007f	 beq         |$LN22@GetFunctio@2|

; 388  :     }
; 389  :     
; 390  : 
; 391  :     pPowerState->fPowerControlSupport = pDevice0->GetCardInfo().SDIOInformation.pCommonInformation->fCardSupportsPowerControl;

  00038	e59034ec	 ldr         r3, [r0, #0x4EC]

; 392  :     pPowerState->fPowerControlEnabled = pDevice0->GetCardInfo().SDIOInformation.pCommonInformation->fPowerControlEnabled;
; 393  : 
; 394  :     pPowerState->fFunctionEnabled = (pDevice0->GetCardInfo().SDIOInformation.pCommonInformation->CCCRShadowIOEnable 
; 395  :                 & (1 <<  m_FuncionIndex)) ? TRUE : FALSE;

  0003c	e3a01001	 mov         r1, #1

; 396  :     
; 397  :     FBROffset = SD_IO_FBR_1_OFFSET + (m_FuncionIndex - 1) * SD_IO_FBR_LENGTH;
; 398  : 
; 399  :     status = pDevice0->SDReadWriteRegistersDirect_I( SD_IO_READ, FBROffset + SD_IO_FBR_POWER_SELECT, FALSE, &regValue, 1); 

  00040	e3a08001	 mov         r8, #1
  00044	e5933014	 ldr         r3, [r3, #0x14]
  00048	e28d4008	 add         r4, sp, #8
  0004c	e58d8004	 str         r8, [sp, #4]
  00050	e5863000	 str         r3, [r6]
  00054	e59034ec	 ldr         r3, [r0, #0x4EC]
  00058	e58d4000	 str         r4, [sp]
  0005c	e5933018	 ldr         r3, [r3, #0x18]
  00060	e5863004	 str         r3, [r6, #4]
  00064	e59034ec	 ldr         r3, [r0, #0x4EC]
  00068	e597243c	 ldr         r2, [r7, #0x43C]
  0006c	e5d33011	 ldrb        r3, [r3, #0x11]
  00070	e1130211	 tst         r3, r1, lsl r2
  00074	e3a01000	 mov         r1, #0
  00078	13a03001	 movne       r3, #1
  0007c	03a03000	 moveq       r3, #0
  00080	e5863008	 str         r3, [r6, #8]
  00084	e597343c	 ldr         r3, [r7, #0x43C]
  00088	e5902000	 ldr         r2, [r0]
  0008c	e1a03403	 mov         r3, r3, lsl #8
  00090	e5925010	 ldr         r5, [r2, #0x10]
  00094	e2832002	 add         r2, r3, #2
  00098	e3a03000	 mov         r3, #0
  0009c	e1a0e00f	 mov         lr, pc
  000a0	e12fff15	 bx          r5
  000a4	e3500000	 cmp         r0, #0

; 400  :     if (!SD_API_SUCCESS(status)) {
; 401  :         return status;

  000a8	4a000063	 bmi         |$LN24@GetFunctio@2|

; 402  :     }
; 403  : 
; 404  :     pPowerState->fSupportsPowerSelect = (regValue & SD_IO_FUNCTION_POWER_SELECT_SUPPORT) ? TRUE : FALSE;

  000ac	e5dd3008	 ldrb        r3, [sp, #8]

; 405  :     if(pPowerState->fSupportsPowerSelect) {

  000b0	e3a00000	 mov         r0, #0
  000b4	e3130001	 tst         r3, #1
  000b8	13a01001	 movne       r1, #1
  000bc	03a01000	 moveq       r1, #0
  000c0	e586100c	 str         r1, [r6, #0xC]
  000c4	e3510000	 cmp         r1, #0
  000c8	0a000006	 beq         |$LN19@GetFunctio@2|

; 406  :         pPowerState->fLowPower = regValue & SD_IO_FUNCTION_POWER_SELECT_STATE ? TRUE : FALSE;

  000cc	e3130002	 tst         r3, #2
  000d0	13a03001	 movne       r3, #1
  000d4	15863010	 strne       r3, [r6, #0x10]
  000d8	1a000003	 bne         |$LN18@GetFunctio@2|
  000dc	e3a03000	 mov         r3, #0
  000e0	e5863010	 str         r3, [r6, #0x10]

; 407  :     }
; 408  :     else {

  000e4	ea000000	 b           |$LN18@GetFunctio@2|
  000e8		 |$LN19@GetFunctio@2|

; 409  :         pPowerState->fLowPower = 0;

  000e8	e5860010	 str         r0, [r6, #0x10]
  000ec		 |$LN18@GetFunctio@2|

; 410  :     }
; 411  : 
; 412  :     pPowerState->OperatingVoltage = m_OperatingVoltage;

  000ec	e59734d0	 ldr         r3, [r7, #0x4D0]

; 413  :     
; 414  :     //calculate the current draw
; 415  :     if(pPowerState->fPowerControlSupport) {

  000f0	e5962000	 ldr         r2, [r6]
  000f4	e5863014	 str         r3, [r6, #0x14]
  000f8	e3520000	 cmp         r2, #0
  000fc	0a00003c	 beq         |$LN17@GetFunctio@2|

; 416  :         if(pPowerState->fFunctionEnabled) {

  00100	e5963008	 ldr         r3, [r6, #8]
  00104	e3530000	 cmp         r3, #0

; 417  :             //
; 418  :             // in future when more power tuples are added select the proper tuple here
; 419  :             // currently only the 3.3V tuple is supported
; 420  :             //
; 421  :             if((pPowerState->fPowerControlEnabled) && (pPowerState->fSupportsPowerSelect)) {

  00108	e5963004	 ldr         r3, [r6, #4]
  0010c	0a000024	 beq         |$LN16@GetFunctio@2|
  00110	e3530000	 cmp         r3, #0
  00114	0a00001b	 beq         |$LN15@GetFunctio@2|
  00118	e3510000	 cmp         r1, #0
  0011c	0a000019	 beq         |$LN15@GetFunctio@2|

; 422  :                 if(pPowerState->fLowPower){

  00120	e5963010	 ldr         r3, [r6, #0x10]

; 423  :                         //function enabled at low power
; 424  :                     pPowerState->CurrentDrawNow = m_SDCardInfo.SDIOInformation.PowerDrawData.LpMaxPower33;

  00124	e2871c05	 add         r1, r7, #5, 24
  00128	e3530000	 cmp         r3, #0
  0012c	0a00000a	 beq         |$LN14@GetFunctio@2|
  00130	e1d132b2	 ldrh        r3, [r1, #0x22]

; 488  :         }
; 489  :     }
; 490  :     return SD_API_STATUS_SUCCESS;

  00134	e3a00000	 mov         r0, #0
  00138	e1c631b8	 strh        r3, [r6, #0x18]
  0013c	e1d132b2	 ldrh        r3, [r1, #0x22]
  00140	e2633000	 rsb         r3, r3, #0
  00144	e586301c	 str         r3, [r6, #0x1C]
  00148	e1d122b2	 ldrh        r2, [r1, #0x22]
  0014c	e1d131be	 ldrh        r3, [r1, #0x1E]
  00150	e0433002	 sub         r3, r3, r2
  00154	e5863020	 str         r3, [r6, #0x20]
  00158	ea000037	 b           |$LN24@GetFunctio@2|
  0015c		 |$LN14@GetFunctio@2|

; 425  :                     pPowerState->EnableDelta = ((INT)m_SDCardInfo.SDIOInformation.PowerDrawData.LpMaxPower33) * -1;
; 426  :                     pPowerState->SelectDelta = ((INT)m_SDCardInfo.SDIOInformation.PowerDrawData.HpMaxPower33)
; 427  :                                                - ((INT)m_SDCardInfo.SDIOInformation.PowerDrawData.LpMaxPower33);
; 428  :                 }
; 429  :                 else {
; 430  :                         //function enabled at high power
; 431  :                     pPowerState->CurrentDrawNow = m_SDCardInfo.SDIOInformation.PowerDrawData.HpMaxPower33;

  0015c	e1d131be	 ldrh        r3, [r1, #0x1E]

; 488  :         }
; 489  :     }
; 490  :     return SD_API_STATUS_SUCCESS;

  00160	e3a00000	 mov         r0, #0
  00164	e1c631b8	 strh        r3, [r6, #0x18]
  00168	e1d131be	 ldrh        r3, [r1, #0x1E]
  0016c	e2633000	 rsb         r3, r3, #0
  00170	e586301c	 str         r3, [r6, #0x1C]
  00174	e1d122b2	 ldrh        r2, [r1, #0x22]
  00178	e1d131be	 ldrh        r3, [r1, #0x1E]
  0017c	e0423003	 sub         r3, r2, r3
  00180	e5863020	 str         r3, [r6, #0x20]
  00184	ea00002c	 b           |$LN24@GetFunctio@2|
  00188		 |$LN15@GetFunctio@2|

; 432  :                     pPowerState->EnableDelta = ((INT)m_SDCardInfo.SDIOInformation.PowerDrawData.HpMaxPower33) * -1;
; 433  :                     pPowerState->SelectDelta = ((INT)m_SDCardInfo.SDIOInformation.PowerDrawData.LpMaxPower33)
; 434  :                                                - ((INT)m_SDCardInfo.SDIOInformation.PowerDrawData.HpMaxPower33);
; 435  :                 }
; 436  :             }
; 437  :             else {
; 438  :                     //function enabled at no power select
; 439  :                 pPowerState->CurrentDrawNow = m_SDCardInfo.SDIOInformation.PowerDrawData.SpMaxPower33;

  00188	e2872c05	 add         r2, r7, #5, 24
  0018c	e1d231ba	 ldrh        r3, [r2, #0x1A]
  00190	e1c631b8	 strh        r3, [r6, #0x18]

; 440  :                 pPowerState->EnableDelta = ((INT)m_SDCardInfo.SDIOInformation.PowerDrawData.SpMaxPower33) * -1;

  00194	e1d231ba	 ldrh        r3, [r2, #0x1A]

; 441  :                 pPowerState->SelectDelta = 0;

  00198	e2633000	 rsb         r3, r3, #0
  0019c	e586301c	 str         r3, [r6, #0x1C]

; 442  :             }
; 443  :         }
; 444  :         else {

  001a0	ea000021	 b           |$LN38@GetFunctio@2|
  001a4		 |$LN16@GetFunctio@2|

; 445  :             if((pPowerState->fPowerControlEnabled) && (pPowerState->fSupportsPowerSelect)) {

  001a4	e3530000	 cmp         r3, #0
  001a8	0a00000b	 beq         |$LN10@GetFunctio@2|
  001ac	e3510000	 cmp         r1, #0
  001b0	0a000009	 beq         |$LN10@GetFunctio@2|

; 446  :                 if(pPowerState->fLowPower) {

  001b4	e5963010	 ldr         r3, [r6, #0x10]

; 447  :                         //function disabled power select set to low
; 448  :                     pPowerState->CurrentDrawNow = 0;
; 449  :                     pPowerState->EnableDelta = m_SDCardInfo.SDIOInformation.PowerDrawData.LpMaxPower33;

  001b8	e1c601b8	 strh        r0, [r6, #0x18]
  001bc	e3530000	 cmp         r3, #0
  001c0	e2873c05	 add         r3, r7, #5, 24
  001c4	11d332b2	 ldrneh      r3, [r3, #0x22]
  001c8	1586301c	 strne       r3, [r6, #0x1C]
  001cc	1a000016	 bne         |$LN38@GetFunctio@2|

; 450  :                     pPowerState->SelectDelta = 0;
; 451  :                 }
; 452  :                 else  {
; 453  :                         //function disabled power select set to low
; 454  :                     pPowerState->CurrentDrawNow = 0;
; 455  :                     pPowerState->EnableDelta = m_SDCardInfo.SDIOInformation.PowerDrawData.HpMaxPower33;

  001d0	e1d331be	 ldrh        r3, [r3, #0x1E]
  001d4	e586301c	 str         r3, [r6, #0x1C]
  001d8	ea000013	 b           |$LN38@GetFunctio@2|
  001dc		 |$LN10@GetFunctio@2|

; 456  :                     pPowerState->SelectDelta = 0;
; 457  :                 }
; 458  :             }
; 459  :             else {
; 460  :                     //function disabled, no power select
; 461  :                 pPowerState->CurrentDrawNow = 0;
; 462  :                 pPowerState->EnableDelta = m_SDCardInfo.SDIOInformation.PowerDrawData.SpMaxPower33;

  001dc	e2873c05	 add         r3, r7, #5, 24
  001e0	e1c601b8	 strh        r0, [r6, #0x18]
  001e4	e1d331ba	 ldrh        r3, [r3, #0x1A]

; 488  :         }
; 489  :     }
; 490  :     return SD_API_STATUS_SUCCESS;

  001e8	e3a00000	 mov         r0, #0
  001ec	e586301c	 str         r3, [r6, #0x1C]
  001f0	ea000011	 b           |$LN24@GetFunctio@2|
  001f4		 |$LN17@GetFunctio@2|

; 463  :             }
; 464  :         }
; 465  :     }
; 466  :     else
; 467  :     {
; 468  :         USHORT TempMaxPower;
; 469  :             //the current draw must never be greater than 200mA for a non Power Control enabled card
; 470  :         if((0 == m_SDCardInfo.SDIOInformation.PowerDrawData.OpMaxPower) || (200 < m_SDCardInfo.SDIOInformation.PowerDrawData.OpMaxPower)){

  001f4	e2873c05	 add         r3, r7, #5, 24
  001f8	e1d321b6	 ldrh        r2, [r3, #0x16]
  001fc	e1b03002	 movs        r3, r2
  00200	0a000001	 beq         |$LN4@GetFunctio@2|
  00204	e35300c8	 cmp         r3, #0xC8

; 472  :         }
; 473  :         else {
; 474  :             TempMaxPower = m_SDCardInfo.SDIOInformation.PowerDrawData.OpMaxPower; 

  00208	9a000000	 bls         |$LN3@GetFunctio@2|
  0020c		 |$LN4@GetFunctio@2|

; 471  :             TempMaxPower = 200; 

  0020c	e3a020c8	 mov         r2, #0xC8
  00210		 |$LN3@GetFunctio@2|

; 475  :         }
; 476  : 
; 477  :         if(pPowerState->fFunctionEnabled) {

  00210	e5963008	 ldr         r3, [r6, #8]
  00214	e3530000	 cmp         r3, #0

; 478  :                 //function enabled, no power control
; 479  :             pPowerState->CurrentDrawNow = TempMaxPower;
; 480  :             pPowerState->EnableDelta = ((INT)TempMaxPower) * -1;

  00218	12623000	 rsbne       r3, r2, #0
  0021c	1586301c	 strne       r3, [r6, #0x1C]
  00220	11c621b8	 strneh      r2, [r6, #0x18]

; 481  :             pPowerState->SelectDelta = 0;
; 482  :         }
; 483  :         else {
; 484  :                 //function disabled, no power control
; 485  :             pPowerState->CurrentDrawNow = 0;
; 486  :             pPowerState->EnableDelta = (INT)TempMaxPower;

  00224	0586201c	 streq       r2, [r6, #0x1C]
  00228	01c601b8	 streqh      r0, [r6, #0x18]
  0022c		 |$LN38@GetFunctio@2|

; 487  :             pPowerState->SelectDelta = 0;

  0022c	e5860020	 str         r0, [r6, #0x20]

; 488  :         }
; 489  :     }
; 490  :     return SD_API_STATUS_SUCCESS;

  00230	e3a00000	 mov         r0, #0
  00234	ea000000	 b           |$LN24@GetFunctio@2|
  00238		 |$LN22@GetFunctio@2|

; 383  :         return SD_API_STATUS_INVALID_PARAMETER;

  00238	e3a0011f	 mov         r0, #0x1F, 2
  0023c		 |$LN24@GetFunctio@2|

; 491  : }

  0023c	e28dd00c	 add         sp, sp, #0xC
  00240	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00244	e12fff1e	 bx          lr
  00248		 |$M40717|

			 ENDP  ; |?GetFunctionPowerState@CSDDevice@@QAAJPAU_FUNCTION_POWER_STATE@@@Z|, CSDDevice::GetFunctionPowerState

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?GetCardStatus@CSDDevice@@IAAJPAK@Z|	; CSDDevice::GetCardStatus

  00000			 AREA	 |.pdata|, PDATA
|$T40738| DCD	|$LN7@GetCardSta|
	DCD	0xc0003602

  00000			 AREA	 |.xdata|, DATA
|$T40734| DCD	0xffffffe4
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T40734|

  00008		 |?GetCardStatus@CSDDevice@@IAAJPAK@Z| PROC ; CSDDevice::GetCardStatus

; 501  : {

  00008		 |$LN7@GetCardSta|
  00008	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  0000c	e24dd03c	 sub         sp, sp, #0x3C
  00010		 |$M40735|
  00010	e1a08001	 mov         r8, r1
  00014	e59f30c0	 ldr         r3, [pc, #0xC0]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3038	 str         r3, [sp, #0x38]

; 502  :     SD_API_STATUS       status;         // status
; 503  :     SD_COMMAND_RESPONSE cardResponse;   // response buffer
; 504  : 
; 505  :     // Initiate the bus transaction
; 506  :     status = SDSynchronousBusRequest_I(
; 507  :         SD_CMD_SEND_STATUS,
; 508  :         ((DWORD)(m_RelativeAddress) << 16),
; 509  :         SD_COMMAND,
; 510  :         ResponseR1,
; 511  :         &cardResponse,
; 512  :         0,
; 513  :         0,
; 514  :         NULL,
; 515  :         0);

  00020	e5902000	 ldr         r2, [r0]
  00024	e2803b01	 add         r3, r0, #1, 22
  00028	e1d33ab0	 ldrh        r3, [r3, #0xA0]
  0002c	e5925014	 ldr         r5, [r2, #0x14]
  00030	e28d4020	 add         r4, sp, #0x20
  00034	e3a07001	 mov         r7, #1
  00038	e3a06000	 mov         r6, #0
  0003c	e1a02803	 mov         r2, r3, lsl #16
  00040	e3a03002	 mov         r3, #2
  00044	e3a0100d	 mov         r1, #0xD
  00048	e58d601c	 str         r6, [sp, #0x1C]
  0004c	e58d6018	 str         r6, [sp, #0x18]
  00050	e58d6014	 str         r6, [sp, #0x14]
  00054	e58d6010	 str         r6, [sp, #0x10]
  00058	e58d600c	 str         r6, [sp, #0xC]
  0005c	e58d6008	 str         r6, [sp, #8]
  00060	e58d4004	 str         r4, [sp, #4]
  00064	e58d7000	 str         r7, [sp]
  00068	e1a0e00f	 mov         lr, pc
  0006c	e12fff15	 bx          r5
  00070	e1b07000	 movs        r7, r0

; 516  : 
; 517  :     // Get the status and convert if necessary
; 518  :     if (!SD_API_SUCCESS(status) ) {
; 519  :         DEBUGMSG( SDCARD_ZONE_ERROR, (TEXT("SDGetCardStatus Failed: status 0x%X\r\n"),status));
; 520  :         return status;

  00074	4a000012	 bmi         |$LN4@GetCardSta|

; 521  :     }
; 522  : 
; 523  :     SDGetCardStatusFromResponse(&cardResponse, pCardStatus);

  00078	e5dd2029	 ldrb        r2, [sp, #0x29]
  0007c	e5dd3028	 ldrb        r3, [sp, #0x28]
  00080	e5dd102a	 ldrb        r1, [sp, #0x2A]
  00084	e5dde02b	 ldrb        lr, [sp, #0x2B]
  00088	e5dd6025	 ldrb        r6, [sp, #0x25]
  0008c	e1833402	 orr         r3, r3, r2, lsl #8
  00090	e5dd2024	 ldrb        r2, [sp, #0x24]
  00094	e5dd4026	 ldrb        r4, [sp, #0x26]
  00098	e1833801	 orr         r3, r3, r1, lsl #16
  0009c	e5dd5027	 ldrb        r5, [sp, #0x27]
  000a0	e1833c0e	 orr         r3, r3, lr, lsl #24
  000a4	e1822406	 orr         r2, r2, r6, lsl #8
  000a8	e1a03c03	 mov         r3, r3, lsl #24
  000ac	e1822804	 orr         r2, r2, r4, lsl #16
  000b0	e1a01c23	 mov         r1, r3, lsr #24
  000b4	e1823c05	 orr         r3, r2, r5, lsl #24
  000b8	e1a03423	 mov         r3, r3, lsr #8
  000bc	e1833c01	 orr         r3, r3, r1, lsl #24
  000c0	e5883000	 str         r3, [r8]
  000c4		 |$LN4@GetCardSta|

; 524  : 
; 525  :     DEBUGMSG(SDCARD_ZONE_INFO, (TEXT("Status: 0x%08X, current state: %d \r\n"),
; 526  :         *pCardStatus, SD_STATUS_CURRENT_STATE(*pCardStatus)));
; 527  : 
; 528  :     return status;

  000c4	e59d0038	 ldr         r0, [sp, #0x38]
  000c8	eb000000	 bl          __security_check_cookie

; 529  : }

  000cc	e1a00007	 mov         r0, r7
  000d0	e28dd03c	 add         sp, sp, #0x3C
  000d4	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000d8	e12fff1e	 bx          lr
  000dc		 |$LN8@GetCardSta|
  000dc		 |$LN9@GetCardSta|
  000dc	00000000	 DCD         |__security_cookie|
  000e0		 |$M40736|

			 ENDP  ; |?GetCardStatus@CSDDevice@@IAAJPAK@Z|, CSDDevice::GetCardStatus

	EXPORT	|?InfoQueryCID@CSDDevice@@IAAJPAXK@Z|	; CSDDevice::InfoQueryCID
	IMPORT	|memcpy|

  00000			 AREA	 |.pdata|, PDATA
|$T40757| DCD	|$LN8@InfoQueryC|
	DCD	0x40005b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InfoQueryCID@CSDDevice@@IAAJPAXK@Z| PROC ; CSDDevice::InfoQueryCID

; 534  : {

  00000		 |$LN8@InfoQueryC|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M40754|
  00004	e1a0e001	 mov         lr, r1
  00008	e1a04000	 mov         r4, r0

; 535  :     PREFAST_DEBUGCHK(pCardInfo);
; 536  :     DEBUGCHK(cbCardInfo == sizeof(SD_PARSED_REGISTER_CID));
; 537  : 
; 538  :     PSD_PARSED_REGISTER_CID pParsedCID = (PSD_PARSED_REGISTER_CID)pCardInfo;
; 539  :     PUCHAR                  pCid  = m_CachedRegisters.CID;
; 540  :     UCHAR                   Prv;
; 541  : 
; 542  :     pParsedCID->ManufacturerID = pCid[SD_CID_MID_OFFSET];  

  0000c	e5d434b5	 ldrb        r3, [r4, #0x4B5]

; 543  : 
; 544  :     // get the application ID string
; 545  :     pParsedCID->OEMApplicationID[0] = pCid[SD_CID_OID_OFFSET];
; 546  :     pParsedCID->OEMApplicationID[1] = pCid[SD_CID_OID_OFFSET+1];
; 547  :     pParsedCID->OEMApplicationID[2] = '\0';

  00010	e3a02000	 mov         r2, #0
  00014	e5ce3000	 strb        r3, [lr]
  00018	e5d434b3	 ldrb        r3, [r4, #0x4B3]
  0001c	e5ce3001	 strb        r3, [lr, #1]
  00020	e5d434b4	 ldrb        r3, [r4, #0x4B4]
  00024	e5ce2003	 strb        r2, [lr, #3]
  00028	e5ce3002	 strb        r3, [lr, #2]

; 548  : 
; 549  : 
; 550  :     // MMC cards have a 1 char larger Product Name
; 551  :     // and it starts 1 byte earlier in the CID data.
; 552  :     // PSN and PRV are offset by 1 byte and the date
; 553  :     // field has just a 4 bit year code starting at 1997.
; 554  :     if( m_DeviceType == Device_MMC ) {

  0002c	e5943494	 ldr         r3, [r4, #0x494]
  00030	e3530001	 cmp         r3, #1
  00034	1a000021	 bne         |$LN2@InfoQueryC|

; 555  :         pParsedCID->ProductName[0] = pCid[MMC_CID_PNM_OFFSET]; 

  00038	e5d434ad	 ldrb        r3, [r4, #0x4AD]
  0003c	e5ce3004	 strb        r3, [lr, #4]

; 556  :         pParsedCID->ProductName[1] = pCid[MMC_CID_PNM_OFFSET+1]; 

  00040	e5d434ae	 ldrb        r3, [r4, #0x4AE]
  00044	e5ce3005	 strb        r3, [lr, #5]

; 557  :         pParsedCID->ProductName[2] = pCid[MMC_CID_PNM_OFFSET+2]; 

  00048	e5d434af	 ldrb        r3, [r4, #0x4AF]
  0004c	e5ce3006	 strb        r3, [lr, #6]

; 558  :         pParsedCID->ProductName[3] = pCid[MMC_CID_PNM_OFFSET+3]; 

  00050	e5d434b0	 ldrb        r3, [r4, #0x4B0]
  00054	e5ce3007	 strb        r3, [lr, #7]

; 559  :         pParsedCID->ProductName[4] = pCid[MMC_CID_PNM_OFFSET+4];

  00058	e5d434b1	 ldrb        r3, [r4, #0x4B1]
  0005c	e5ce3008	 strb        r3, [lr, #8]

; 560  :         pParsedCID->ProductName[5] = pCid[MMC_CID_PNM_OFFSET+5];

  00060	e5d434b2	 ldrb        r3, [r4, #0x4B2]

; 561  :         pParsedCID->ProductName[6] = '\0';

  00064	e5ce200a	 strb        r2, [lr, #0xA]
  00068	e5ce3009	 strb        r3, [lr, #9]

; 562  : 
; 563  :         // get major and minor revs                                                               
; 564  :         Prv = pCid[MMC_CID_PRV_OFFSET];    

  0006c	e5d434ac	 ldrb        r3, [r4, #0x4AC]

; 565  :         pParsedCID->MajorProductRevision = (Prv & 0xF0) >> 4;  

  00070	e1a02223	 mov         r2, r3, lsr #4

; 566  :         pParsedCID->MinorProductRevision = Prv & 0x0F;                     

  00074	e203300f	 and         r3, r3, #0xF
  00078	e5ce300c	 strb        r3, [lr, #0xC]
  0007c	e5ce200b	 strb        r2, [lr, #0xB]

; 567  : 
; 568  :         // serial number
; 569  :         pParsedCID->ProductSerialNumber = pCid[MMC_CID_PSN_OFFSET] | 
; 570  :             (pCid[MMC_CID_PSN_OFFSET + 1] << 8)| 
; 571  :             (pCid[MMC_CID_PSN_OFFSET + 2] << 16) | 
; 572  :             (pCid[MMC_CID_PSN_OFFSET + 3] << 24); 

  00080	e5d404ab	 ldrb        r0, [r4, #0x4AB]
  00084	e5d434aa	 ldrb        r3, [r4, #0x4AA]
  00088	e5d424a9	 ldrb        r2, [r4, #0x4A9]
  0008c	e5d414a8	 ldrb        r1, [r4, #0x4A8]
  00090	e1833400	 orr         r3, r3, r0, lsl #8
  00094	e1823403	 orr         r3, r2, r3, lsl #8
  00098	e1813403	 orr         r3, r1, r3, lsl #8
  0009c	e58e3010	 str         r3, [lr, #0x10]

; 573  : 
; 574  :         // Manufacturing month
; 575  :         pParsedCID->ManufacturingMonth = (pCid[MMC_CID_MDT_OFFSET] & MMC_CID_MONTH_MASK) >> MMC_CID_MONTH_SHIFT;

  000a0	e5d434a7	 ldrb        r3, [r4, #0x4A7]
  000a4	e1a03223	 mov         r3, r3, lsr #4
  000a8	e5ce3014	 strb        r3, [lr, #0x14]

; 576  :         // Manufacturing year
; 577  :         pParsedCID->ManufacturingYear = pCid[MMC_CID_MDT_OFFSET] & MMC_CID_YEAR_MASK; 
; 578  :         // Year starts at 1997
; 579  :         pParsedCID->ManufacturingYear += 1997;

  000ac	e5d434a7	 ldrb        r3, [r4, #0x4A7]
  000b0	e203300f	 and         r3, r3, #0xF
  000b4	e2833c07	 add         r3, r3, #7, 24
  000b8	e28330cd	 add         r3, r3, #0xCD

; 580  :     } else {  

  000bc	ea000021	 b           |$LN5@InfoQueryC|
  000c0		 |$LN2@InfoQueryC|

; 581  :         pParsedCID->ProductName[0] = pCid[SD_CID_PNM_OFFSET]; 

  000c0	e5d434ae	 ldrb        r3, [r4, #0x4AE]
  000c4	e5ce3004	 strb        r3, [lr, #4]

; 582  :         pParsedCID->ProductName[1] = pCid[SD_CID_PNM_OFFSET+1]; 

  000c8	e5d434af	 ldrb        r3, [r4, #0x4AF]
  000cc	e5ce3005	 strb        r3, [lr, #5]

; 583  :         pParsedCID->ProductName[2] = pCid[SD_CID_PNM_OFFSET+2]; 

  000d0	e5d434b0	 ldrb        r3, [r4, #0x4B0]
  000d4	e5ce3006	 strb        r3, [lr, #6]

; 584  :         pParsedCID->ProductName[3] = pCid[SD_CID_PNM_OFFSET+3]; 

  000d8	e5d434b1	 ldrb        r3, [r4, #0x4B1]
  000dc	e5ce3007	 strb        r3, [lr, #7]

; 585  :         pParsedCID->ProductName[4] = pCid[SD_CID_PNM_OFFSET+4];

  000e0	e5d434b2	 ldrb        r3, [r4, #0x4B2]

; 586  :         pParsedCID->ProductName[5] = '\0';

  000e4	e5ce2009	 strb        r2, [lr, #9]

; 587  :         pParsedCID->ProductName[6] = '\0';

  000e8	e5ce200a	 strb        r2, [lr, #0xA]
  000ec	e5ce3008	 strb        r3, [lr, #8]

; 588  : 
; 589  :         // get major and minor revs                                                               
; 590  :         Prv = pCid[SD_CID_PRV_OFFSET];    

  000f0	e5d434ad	 ldrb        r3, [r4, #0x4AD]

; 591  :         pParsedCID->MajorProductRevision = (Prv & 0xF0) >> 4;  

  000f4	e1a02223	 mov         r2, r3, lsr #4

; 592  :         pParsedCID->MinorProductRevision = Prv & 0x0F;                     

  000f8	e203300f	 and         r3, r3, #0xF
  000fc	e5ce300c	 strb        r3, [lr, #0xC]
  00100	e5ce200b	 strb        r2, [lr, #0xB]

; 593  : 
; 594  :         // serial number
; 595  :         pParsedCID->ProductSerialNumber = pCid[SD_CID_PSN_OFFSET] | 
; 596  :             (pCid[SD_CID_PSN_OFFSET + 1] << 8)| 
; 597  :             (pCid[SD_CID_PSN_OFFSET + 2] << 16) | 
; 598  :             (pCid[SD_CID_PSN_OFFSET + 3] << 24); 

  00104	e5d404ac	 ldrb        r0, [r4, #0x4AC]
  00108	e5d434ab	 ldrb        r3, [r4, #0x4AB]
  0010c	e5d424aa	 ldrb        r2, [r4, #0x4AA]
  00110	e5d414a9	 ldrb        r1, [r4, #0x4A9]
  00114	e1833400	 orr         r3, r3, r0, lsl #8
  00118	e1823403	 orr         r3, r2, r3, lsl #8
  0011c	e1813403	 orr         r3, r1, r3, lsl #8
  00120	e58e3010	 str         r3, [lr, #0x10]

; 599  : 
; 600  :         pParsedCID->ManufacturingMonth = pCid[SD_CID_MDT_OFFSET] & SD_CID_MONTH_MASK;

  00124	e5d434a7	 ldrb        r3, [r4, #0x4A7]
  00128	e203300f	 and         r3, r3, #0xF
  0012c	e5ce3014	 strb        r3, [lr, #0x14]

; 601  :         // get lower 4 bits
; 602  :         pParsedCID->ManufacturingYear = (pCid[SD_CID_MDT_OFFSET] & SD_CID_YEAR0_MASK) >> SD_CID_YEAR_SHIFT ; 

  00130	e5d434a7	 ldrb        r3, [r4, #0x4A7]
  00134	e1a02223	 mov         r2, r3, lsr #4
  00138	e1ce21b6	 strh        r2, [lr, #0x16]

; 603  :         // get upper 4 bits
; 604  :         pParsedCID->ManufacturingYear  |= pCid[SD_CID_MDT_OFFSET+1] << SD_CID_YEAR_SHIFT;  
; 605  :         // starts at year 2000
; 606  :         pParsedCID->ManufacturingYear += 2000;

  0013c	e5d434a8	 ldrb        r3, [r4, #0x4A8]
  00140	e1823203	 orr         r3, r2, r3, lsl #4
  00144	e2833e7d	 add         r3, r3, #0x7D, 28
  00148		 |$LN5@InfoQueryC|
  00148	e1ce31b6	 strh        r3, [lr, #0x16]

; 607  :     }     
; 608  : 
; 609  :     memcpy(pParsedCID->RawCIDRegister, m_CachedRegisters.CID, SD_CID_REGISTER_SIZE);

  0014c	e2843b01	 add         r3, r4, #1, 22
  00150	e28310a6	 add         r1, r3, #0xA6
  00154	e28e0018	 add         r0, lr, #0x18
  00158	e3a02010	 mov         r2, #0x10
  0015c	eb000000	 bl          memcpy

; 610  : 
; 611  :     return SD_API_STATUS_SUCCESS;

  00160	e3a00000	 mov         r0, #0

; 612  : }

  00164	e8bd4010	 ldmia       sp!, {r4, lr}
  00168	e12fff1e	 bx          lr
  0016c		 |$M40755|

			 ENDP  ; |?InfoQueryCID@CSDDevice@@IAAJPAXK@Z|, CSDDevice::InfoQueryCID

	EXPORT	|?DumpParsedCSDRegisters@@YAXPAU_SD_PARSED_REGISTER_CSD@@@Z| ; DumpParsedCSDRegisters

  00000			 AREA	 |.pdata|, PDATA
|$T40764| DCD	|$LN11@DumpParsed|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DumpParsedCSDRegisters@@YAXPAU_SD_PARSED_REGISTER_CSD@@@Z| PROC ; DumpParsedCSDRegisters

; 625  : {

  00000		 |$LN11@DumpParsed|
  00000		 |$M40761|

; 626  : 
; 627  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT("\n\n\nSDCard: Dumping parsed Registers : \n")));
; 628  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" Version:%d \n"),pParsedCSD->CSDVersion)); 
; 629  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" TAAC: %f ns \n"),pParsedCSD->DataAccessTime.TAAC));  
; 630  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" NSAC: %d clocks \n"),pParsedCSD->DataAccessTime.NSAC)); 
; 631  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" MaxDataTransferRate: %d kb/s \n"),pParsedCSD->MaxDataTransferRate));
; 632  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" Card Command Classes: 0x%04X \n"),pParsedCSD->CardCommandClasses));
; 633  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" Max Read Block Length: %d bytes \n"),pParsedCSD->MaxReadBlockLength));
; 634  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" Read Block Partial? : %d  \n"),pParsedCSD->ReadBlockPartial));
; 635  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" Max Write Block Length: %d bytes \n"),pParsedCSD->MaxWriteBlockLength));
; 636  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" Write Block Partial? : %d  \n"),pParsedCSD->WriteBlockPartial));
; 637  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" Write Block Misaligned? : %d  \n"),pParsedCSD->WriteBlockMisalign));
; 638  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" Read Block Misaligned? : %d  \n"),pParsedCSD->ReadBlockMisalign));
; 639  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" DSR Implemented? : %d  \n"),pParsedCSD->DSRImplemented));
; 640  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" Device Size : %d bytes  \n"),pParsedCSD->DeviceSize));
; 641  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" VDD Read Current Min : %d mA \n"),pParsedCSD->VDDReadCurrentMin));
; 642  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" VDD Read Current Max : %d mA \n"),pParsedCSD->VDDReadCurrentMax));
; 643  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" VDD Write Current Min : %d mA \n"),pParsedCSD->VDDWriteCurrentMin));
; 644  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" VDD Write Current Max : %d mA \n"),pParsedCSD->VDDWriteCurrentMax));
; 645  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" Erase Block Enabled?: %d  \n"),pParsedCSD->EraseBlockEnable));
; 646  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" Erase Sector Size: %d blocks \n"),pParsedCSD->EraseSectorSize));
; 647  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" Write Protect Group Enabled? %d \n"),pParsedCSD->WPGroupEnable));
; 648  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" Write Group Protect Size: %d blocks \n"),pParsedCSD->WPGroupSize));
; 649  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" Write Speed Factor: %d blocks \n"),pParsedCSD->WriteSpeedFactor));
; 650  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" Copy Flag?:  %d \n"),pParsedCSD->CopyFlag));
; 651  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" Permanent Write Protect?:  %d \n"),pParsedCSD->PermanentWP));
; 652  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" Temporary Write Protect?:  %d \n"),pParsedCSD->TemporaryWP));
; 653  : 
; 654  :     switch (pParsedCSD->FileSystem ) {
; 655  :         case SD_FS_FAT_PARTITION_TABLE: 
; 656  :             DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" FileSystem = FAT with Partition Table \n")));
; 657  :             break;
; 658  :         case SD_FS_FAT_NO_PARTITION_TABLE: 
; 659  :             DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" FileSystem = FAT with No Partition Table \n")));
; 660  :             break;
; 661  :         case SD_FS_UNIVERSAL:  
; 662  :             DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" FileSystem = Universal \n")));
; 663  :             break;
; 664  :         default: 
; 665  :             DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT(" FileSystem = Other/Unknown \n")));
; 666  :     }
; 667  : 
; 668  :     DEBUGMSG(SDBUS_ZONE_REQUEST, (TEXT("---------------------------------------------- \n\n\n")));
; 669  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M40762|

			 ENDP  ; |?DumpParsedCSDRegisters@@YAXPAU_SD_PARSED_REGISTER_CSD@@@Z|, DumpParsedCSDRegisters

	EXPORT	|?InfoQueryRCA@CSDDevice@@IAAJPAXK@Z|	; CSDDevice::InfoQueryRCA

  00000			 AREA	 |.pdata|, PDATA
|$T40775| DCD	|$LN5@InfoQueryR|
	DCD	0x40000700
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InfoQueryRCA@CSDDevice@@IAAJPAXK@Z| PROC ; CSDDevice::InfoQueryRCA

; 1055 : {

  00000		 |$LN5@InfoQueryR|
  00000		 |$M40772|

; 1056 :     PREFAST_DEBUGCHK(pCardInfo);
; 1057 :     DEBUGCHK(cbCardInfo == sizeof(SD_CARD_RCA));
; 1058 : 
; 1059 :     memcpy(pCardInfo, &m_RelativeAddress, sizeof(SD_CARD_RCA));

  00000	e2803b01	 add         r3, r0, #1, 22
  00004	e1d32ab0	 ldrh        r2, [r3, #0xA0]

; 1060 : 
; 1061 :     return SD_API_STATUS_SUCCESS;

  00008	e3a00000	 mov         r0, #0
  0000c	e1a03422	 mov         r3, r2, lsr #8
  00010	e5c13001	 strb        r3, [r1, #1]
  00014	e5c12000	 strb        r2, [r1]

; 1062 : }

  00018	e12fff1e	 bx          lr
  0001c		 |$M40773|

			 ENDP  ; |?InfoQueryRCA@CSDDevice@@IAAJPAXK@Z|, CSDDevice::InfoQueryRCA

	EXPORT	|?InfoQueryCardInterface@CSDDevice@@IAAJPAXK@Z| ; CSDDevice::InfoQueryCardInterface

  00000			 AREA	 |.pdata|, PDATA
|$T40788| DCD	|$LN7@InfoQueryC@2|
	DCD	0x40001201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InfoQueryCardInterface@CSDDevice@@IAAJPAXK@Z| PROC ; CSDDevice::InfoQueryCardInterface

; 1065 : {

  00000		 |$LN7@InfoQueryC@2|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M40785|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 1066 :     PREFAST_DEBUGCHK(pCardInfo);
; 1067 :     DEBUGCHK(cbCardInfo == sizeof(SD_CARD_INTERFACE_EX));
; 1068 : 
; 1069 :     m_CardInterfaceEx.InterfaceModeEx.bit.sdHighCapacity = (IsHighCapacitySDMemory()?1: 0);

  0000c	eb000000	 bl          |?IsHighCapacitySDMemory@CSDDevice@@QAAHXZ|
  00010	e5943540	 ldr         r3, [r4, #0x540]
  00014	e3500000	 cmp         r0, #0
  00018	13a02001	 movne       r2, #1
  0001c	03a02000	 moveq       r2, #0

; 1070 :     *(PSD_CARD_INTERFACE_EX)pCardInfo = m_CardInterfaceEx;

  00020	e3c33102	 bic         r3, r3, #2, 2
  00024	e1833f82	 orr         r3, r3, r2, lsl #31
  00028	e5a43540	 str         r3, [r4, #0x540]!
  0002c	e3a02020	 mov         r2, #0x20
  00030	e1a00005	 mov         r0, r5
  00034	e1a01004	 mov         r1, r4
  00038	eb000000	 bl          memcpy

; 1071 :     return SD_API_STATUS_SUCCESS;

  0003c	e3a00000	 mov         r0, #0

; 1072 : }

  00040	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$M40786|

			 ENDP  ; |?InfoQueryCardInterface@CSDDevice@@IAAJPAXK@Z|, CSDDevice::InfoQueryCardInterface

	EXPORT	|?InfoQueryStatus@CSDDevice@@IAAJPAXK@Z| ; CSDDevice::InfoQueryStatus

  00000			 AREA	 |.pdata|, PDATA
|$T40799| DCD	|$LN5@InfoQueryS|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InfoQueryStatus@CSDDevice@@IAAJPAXK@Z| PROC ; CSDDevice::InfoQueryStatus

; 1079 : {

  00000		 |$LN5@InfoQueryS|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M40796|

; 1080 :     DEBUGCHK(pCardInfo);
; 1081 :     DEBUGCHK(cbCardInfo == sizeof(SD_CARD_STATUS));
; 1082 : 
; 1083 :     // get the card status
; 1084 :     return GetCardStatus((SD_CARD_STATUS *)pCardInfo);

  00004	eb000000	 bl          |?GetCardStatus@CSDDevice@@IAAJPAK@Z|

; 1085 : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M40797|

			 ENDP  ; |?InfoQueryStatus@CSDDevice@@IAAJPAXK@Z|, CSDDevice::InfoQueryStatus

	EXPORT	|?InfoQuerySDIOInfo@CSDDevice@@IAAJPAXK@Z| ; CSDDevice::InfoQuerySDIOInfo
	IMPORT	|SDProcessException|
	IMPORT	|__C_specific_handler|

  00000			 AREA	 |.pdata|, PDATA
|$T40827| DCD	|$LN21@InfoQueryS@2|
	DCD	0xc0002d04

  00000			 AREA	 |.pdata|, PDATA
|$T40829| DCD	|$LN9@InfoQueryS@2|
	DCD	0x40000301

  00000			 AREA	 |.xdata|, DATA
|$T40825| DCD	0x1
	DCD	|$LN13@InfoQueryS@2|
	DCD	|$LN14@InfoQueryS@2|
	DCD	|$LN9@InfoQueryS@2|
	DCD	|$LN10@InfoQueryS@2|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T40825|

  00008		 |?InfoQuerySDIOInfo@CSDDevice@@IAAJPAXK@Z| PROC ; CSDDevice::InfoQuerySDIOInfo

; 1089 : {

  00008		 |$LN21@InfoQueryS@2|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d5870	 stmdb       sp!, {r4 - r6, r11, r12, lr}
  00010	e28db018	 add         r11, sp, #0x18
  00014	e24dd008	 sub         sp, sp, #8
  00018		 |$LN19@InfoQueryS@2|
  00018	e1a06001	 mov         r6, r1
  0001c	e1a05000	 mov         r5, r0

; 1090 :     PREFAST_DEBUGCHK(pCardInfo);
; 1091 :     DEBUGCHK(cbCardInfo == sizeof(SDIO_CARD_INFO));
; 1092 :     
; 1093 :     if (Device_SD_IO != m_DeviceType || m_FuncionIndex==0) {

  00020	e5953494	 ldr         r3, [r5, #0x494]
  00024	e3530003	 cmp         r3, #3
  00028	1a00001e	 bne         |$LN4@InfoQueryS@2|
  0002c	e595343c	 ldr         r3, [r5, #0x43C]
  00030	e3530000	 cmp         r3, #0
  00034	0a00001b	 beq         |$LN4@InfoQueryS@2|

; 1096 :     }
; 1097 :     
; 1098 :     SD_API_STATUS status = SD_API_STATUS_INVALID_PARAMETER;
; 1099 :     CSDDevice * device0 = m_sdSlot.GetFunctionDevice(0);

  00038	e5950438	 ldr         r0, [r5, #0x438]
  0003c	e3a01000	 mov         r1, #0
  00040	e3a0411f	 mov         r4, #0x1F, 2
  00044	eb000000	 bl          |?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z|
  00048	e3500000	 cmp         r0, #0
  0004c	e50b001c	 str         r0, [r11, #-0x1C]

; 1100 :     if (device0) {

  00050	0a000015	 beq         |$LN6@InfoQueryS@2|
  00054		 |$LN13@InfoQueryS@2|

; 1101 :         __try {
; 1102 :             ((PSDIO_CARD_INFO)pCardInfo)->FunctionNumber = m_SDCardInfo.SDIOInformation.Function;

  00054	e5d534d8	 ldrb        r3, [r5, #0x4D8]
  00058	e5c63000	 strb        r3, [r6]

; 1103 :             ((PSDIO_CARD_INFO)pCardInfo)->DeviceCode = m_SDCardInfo.SDIOInformation.DeviceCode;

  0005c	e5d534d9	 ldrb        r3, [r5, #0x4D9]
  00060	e5c63001	 strb        r3, [r6, #1]

; 1104 :             ((PSDIO_CARD_INFO)pCardInfo)->CISPointer = m_SDCardInfo.SDIOInformation.CISPointer;

  00064	e59534dc	 ldr         r3, [r5, #0x4DC]
  00068	e5863004	 str         r3, [r6, #4]

; 1105 :             ((PSDIO_CARD_INFO)pCardInfo)->CSAPointer = m_SDCardInfo.SDIOInformation.CSAPointer;

  0006c	e59534e0	 ldr         r3, [r5, #0x4E0]
  00070	e5863008	 str         r3, [r6, #8]

; 1106 : 
; 1107 :             DEBUGCHK(device0->m_SDCardInfo.SDIOInformation.pCommonInformation != NULL);
; 1108 : 
; 1109 :             ((PSDIO_CARD_INFO)pCardInfo)->CardCapability = 
; 1110 :                 device0->m_SDCardInfo.SDIOInformation.pCommonInformation->CardCapability;

  00074	e59034ec	 ldr         r3, [r0, #0x4EC]
  00078	e5d33002	 ldrb        r3, [r3, #2]
  0007c	e5c6300c	 strb        r3, [r6, #0xC]

; 1111 :             status = SD_API_STATUS_SUCCESS;

  00080	e3a04000	 mov         r4, #0
  00084	e50b4020	 str         r4, [r11, #-0x20]
  00088		 |$LN14@InfoQueryS@2|

; 1112 :         }

  00088	ea000002	 b           |$LN15@InfoQueryS@2|
  0008c		 |$LN10@InfoQueryS@2|

; 1114 :             status = SD_API_STATUS_INVALID_PARAMETER;

  0008c	e3a0411f	 mov         r4, #0x1F, 2
  00090	e50b4020	 str         r4, [r11, #-0x20]
  00094	e51b001c	 ldr         r0, [r11, #-0x1C]
  00098		 |$LN15@InfoQueryS@2|

; 1115 :         }
; 1116 :         device0->DeRef();

  00098	eb000000	 bl          |?DeRef@CRefObject@@QAAKXZ|
  0009c	ea000002	 b           |$LN6@InfoQueryS@2|
  000a0		 |$LN18@InfoQueryS@2|

; 1094 :         ASSERT(FALSE);
; 1095 :         return SD_API_STATUS_INVALID_PARAMETER;

  000a0	e51b401c	 ldr         r4, [r11, #-0x1C]
  000a4	ea000000	 b           |$LN6@InfoQueryS@2|
  000a8		 |$LN4@InfoQueryS@2|
  000a8	e3a0411f	 mov         r4, #0x1F, 2
  000ac		 |$LN6@InfoQueryS@2|

; 1117 :     }
; 1118 :     else {
; 1119 :         ASSERT(FALSE);
; 1120 :     }
; 1121 :     return status;
; 1122 : }

  000ac	e1a00004	 mov         r0, r4
  000b0	e24bd018	 sub         sp, r11, #0x18
  000b4	e89d6870	 ldmia       sp, {r4 - r6, r11, sp, lr}
  000b8	e12fff1e	 bx          lr

			 ENDP  ; |?InfoQuerySDIOInfo@CSDDevice@@IAAJPAXK@Z|, CSDDevice::InfoQuerySDIOInfo

  000bc		 |$LN9@InfoQueryS@2|
  000bc		 |$LN20@InfoQueryS@2|

; 1113 :         __except(SDProcessException(GetExceptionInformation())) {

  000bc	e52de004	 str         lr, [sp, #-4]!
  000c0		 |$LN12@InfoQueryS@2|
  000c0		 |$LN23@InfoQueryS@2|
  000c0	eb000000	 bl          SDProcessException
  000c4		 |$LN11@InfoQueryS@2|
  000c4	e49df004	 ldr         pc, [sp], #4
  000c8		 |$LN24@InfoQueryS@2|
  000c8		 |$LN22@InfoQueryS@2|
	EXPORT	|?InfoQueryHostInterface@CSDDevice@@IAAJPAXK@Z| ; CSDDevice::InfoQueryHostInterface

  00000			 AREA	 |.pdata|, PDATA
|$T40845| DCD	|$LN10@InfoQueryH|
	DCD	0x40001300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InfoQueryHostInterface@CSDDevice@@IAAJPAXK@Z| PROC ; CSDDevice::InfoQueryHostInterface

; 1126 : {

  00000		 |$LN10@InfoQueryH|
  00000		 |$M40842|

; 1127 :     PREFAST_DEBUGCHK(pCardInfo);
; 1128 :     DEBUGCHK(cbCardInfo == sizeof(SD_CARD_INTERFACE));
; 1129 : 
; 1130 :     PSD_CARD_INTERFACE pCardCapabilities = (PSD_CARD_INTERFACE)pCardInfo;
; 1131 :     // fetch the max clock rate
; 1132 :     pCardCapabilities->ClockRate = m_sdSlot.MaxClockRate;

  00000	e5903438	 ldr         r3, [r0, #0x438]

; 1133 : 
; 1134 :     // work out the best interface the HC can provide
; 1135 :     if( m_sdSlot.Capabilities & SD_SLOT_SD_4BIT_CAPABLE ) {

  00004	e3a02000	 mov         r2, #0
  00008	e5933074	 ldr         r3, [r3, #0x74]
  0000c	e5813004	 str         r3, [r1, #4]
  00010	e5903438	 ldr         r3, [r0, #0x438]
  00014	e5933068	 ldr         r3, [r3, #0x68]
  00018	e3130008	 tst         r3, #8

; 1136 :         pCardCapabilities->InterfaceMode = SD_INTERFACE_SD_4BIT;

  0001c	13a03001	 movne       r3, #1

; 1137 : 	} else if(m_sdSlot.Capabilities & SD_SLOT_MMC_8BIT_CAPABLE) {
; 1138 : 		pCardCapabilities->InterfaceMode = SD_INTERFACE_SD_MMC_8BIT;

  00020	15813000	 strne       r3, [r1]
  00024	1a000005	 bne         |$LN1@InfoQueryH|
  00028	e5903438	 ldr         r3, [r0, #0x438]
  0002c	e5933068	 ldr         r3, [r3, #0x68]
  00030	e3130002	 tst         r3, #2
  00034	13a03002	 movne       r3, #2
  00038	15813000	 strne       r3, [r1]

; 1139 :     } else {
; 1140 :         pCardCapabilities->InterfaceMode = SD_INTERFACE_SD_MMC_1BIT;

  0003c	05812000	 streq       r2, [r1]
  00040		 |$LN1@InfoQueryH|

; 1141 :     }
; 1142 : 
; 1143 :     // write protect is meaningless for a capability query, set to FALSE
; 1144 :     pCardCapabilities->WriteProtected = FALSE;    

  00040	e5812008	 str         r2, [r1, #8]

; 1145 : 
; 1146 :     return SD_API_STATUS_SUCCESS;

  00044	e3a00000	 mov         r0, #0

; 1147 : }

  00048	e12fff1e	 bx          lr
  0004c		 |$M40843|

			 ENDP  ; |?InfoQueryHostInterface@CSDDevice@@IAAJPAXK@Z|, CSDDevice::InfoQueryHostInterface

	EXPORT	|?InfoQueryBlockCaps@CSDDevice@@IAAJPAXK@Z| ; CSDDevice::InfoQueryBlockCaps
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdbus.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T40876| DCD	|$LN14@InfoQueryB|
	DCD	0x40001d02
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevinf.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InfoQueryBlockCaps@CSDDevice@@IAAJPAXK@Z| PROC ; CSDDevice::InfoQueryBlockCaps

; 1151 : {

  00000		 |$LN14@InfoQueryB|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M40873|
  00008	e1a05001	 mov         r5, r1
  0000c	e1a04000	 mov         r4, r0

; 1152 :     DEBUGCHK(pCardInfo);
; 1153 :     DEBUGCHK(cbCardInfo == sizeof(SD_HOST_BLOCK_CAPABILITY));
; 1154 :     SD_HOST_BLOCK_CAPABILITY sdHostBLockCap = *(PSD_HOST_BLOCK_CAPABILITY)pCardInfo;

  00010	e28d0004	 add         r0, sp, #4
  00014	e3a02008	 mov         r2, #8
  00018	eb000000	 bl          memcpy

; 1155 :     // send the requested block transfer size to the HC, if the HC is
; 1156 :     // unable to support the requested block size it will return the 
; 1157 :     // next supported block size smaller than that requested
; 1158 :     SD_API_STATUS status = m_sdSlot.GetHost().SlotOptionHandler(m_sdSlot.GetSlotIndex(),
; 1159 :         SDHCDQueryBlockCapability,
; 1160 :         &sdHostBLockCap,                
; 1161 :         sizeof(SD_HOST_BLOCK_CAPABILITY));

  0001c	e5943438	 ldr         r3, [r4, #0x438]
  00020	e3a06008	 mov         r6, #8
  00024	e58d6000	 str         r6, [sp]
  00028	e593207c	 ldr         r2, [r3, #0x7C]
  0002c	e5931080	 ldr         r1, [r3, #0x80]
  00030	e28d3004	 add         r3, sp, #4
  00034	e3520000	 cmp         r2, #0
  00038	e5924044	 ldr         r4, [r2, #0x44]
  0003c	12820008	 addne       r0, r2, #8
  00040	03a00000	 moveq       r0, #0
  00044	e3a02006	 mov         r2, #6
  00048	e1a0e00f	 mov         lr, pc
  0004c	e12fff14	 bx          r4
  00050	e1b04000	 movs        r4, r0

; 1162 :     if (SD_API_SUCCESS(status)) {
; 1163 :         *(PSD_HOST_BLOCK_CAPABILITY)pCardInfo = sdHostBLockCap;

  00054	528d1004	 addpl       r1, sp, #4
  00058	53a02008	 movpl       r2, #8
  0005c	51a00005	 movpl       r0, r5
  00060	5b000000	 blpl        memcpy

; 1164 :     }
; 1165 :     return status;
; 1166 : }

  00064	e1a00004	 mov         r0, r4
  00068	e28dd00c	 add         sp, sp, #0xC
  0006c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00070	e12fff1e	 bx          lr
  00074		 |$M40874|

			 ENDP  ; |?InfoQueryBlockCaps@CSDDevice@@IAAJPAXK@Z|, CSDDevice::InfoQueryBlockCaps


  00000			 AREA	 |.pdata|, PDATA
|$T40895| DCD	|$LN12@ShiftBytes|
	DCD	0x40001b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ShiftBytes@@YAXPAEKK0@Z| PROC	; ShiftBytes

; 1266 : {

  00000		 |$LN12@ShiftBytes|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M40892|
  00004	e1a04003	 mov         r4, r3
  00008	e1a07000	 mov         r7, r0

; 1267 :     PREFAST_DEBUGCHK(pbInput);
; 1268 :     PREFAST_DEBUGCHK(pbOutput);
; 1269 : 
; 1270 :     DWORD dwByteIndex = dwBitOffset / 8;

  0000c	e1a0e1a2	 mov         lr, r2, lsr #3

; 1271 :     dwBitOffset %= 8;
; 1272 : 
; 1273 :     DWORD dwRemainderShift = 8 - dwBitOffset;
; 1274 : 
; 1275 :     // Only copy 4 bytes max.
; 1276 :     DWORD dwEndIndex = min(dwByteIndex + sizeof(DWORD), cbInput);

  00010	e28e5004	 add         r5, lr, #4
  00014	e1550001	 cmp         r5, r1
  00018	21a05001	 movcs       r5, r1
  0001c	e2023007	 and         r3, r2, #7

; 1277 :     DWORD dwCurrOutputIndex = 0;
; 1278 :     while (dwByteIndex < dwEndIndex) {

  00020	e15e0005	 cmp         lr, r5
  00024	e2632008	 rsb         r2, r3, #8
  00028	2a00000d	 bcs         |$LN2@ShiftBytes|
  0002c	e1a00003	 mov         r0, r3
  00030	e20260ff	 and         r6, r2, #0xFF
  00034		 |$LL3@ShiftBytes|

; 1279 :         DEBUGCHK(dwCurrOutputIndex < sizeof(DWORD));
; 1280 :         DEBUGCHK(dwByteIndex < cbInput);
; 1281 : 
; 1282 :         pbOutput[dwCurrOutputIndex] = pbInput[dwByteIndex] >> dwBitOffset;

  00034	e7de3007	 ldrb        r3, [lr, +r7]

; 1283 : 
; 1284 :         ++dwByteIndex;

  00038	e28ee001	 add         lr, lr, #1

; 1285 : 
; 1286 :         if (dwByteIndex != cbInput) {

  0003c	e15e0001	 cmp         lr, r1
  00040	e1a03033	 mov         r3, r3, lsr r0
  00044	e5c43000	 strb        r3, [r4]

; 1287 :             BYTE bTemp = pbInput[dwByteIndex];
; 1288 :             bTemp <<= dwRemainderShift;
; 1289 :             pbOutput[dwCurrOutputIndex] |= bTemp;

  00048	17de2007	 ldrneb      r2, [lr, +r7]
  0004c	120330ff	 andne       r3, r3, #0xFF
  00050	11833612	 orrne       r3, r3, r2, lsl r6
  00054	15c43000	 strneb      r3, [r4]

; 1290 :         }
; 1291 : 
; 1292 :         ++dwCurrOutputIndex;

  00058	e2844001	 add         r4, r4, #1
  0005c	e15e0005	 cmp         lr, r5
  00060	3afffff3	 bcc         |$LL3@ShiftBytes|
  00064		 |$LN2@ShiftBytes|

; 1293 :     }
; 1294 : }

  00064	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00068	e12fff1e	 bx          lr
  0006c		 |$M40893|

			 ENDP  ; |?ShiftBytes@@YAXPAEKK0@Z|, ShiftBytes

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?EmulateSectorNumberByProdutID@CSDDevice@@QAAKXZ| ; CSDDevice::EmulateSectorNumberByProdutID
	IMPORT	|memcmp|

  00000			 AREA	 |.pdata|, PDATA
|$T40911| DCD	|$LN17@EmulateSec|
	DCD	0xc0004102

  00000			 AREA	 |.xdata|, DATA
|$T40907| DCD	0xfffffff0
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T40907|

  00008		 |?EmulateSectorNumberByProdutID@CSDDevice@@QAAKXZ| PROC ; CSDDevice::EmulateSectorNumberByProdutID

; 1355 : {

  00008		 |$LN17@EmulateSec|
  00008	e92d4030	 stmdb       sp!, {r4, r5, lr}
  0000c	e24dd02c	 sub         sp, sp, #0x2C
  00010		 |$M40908|
  00010	e59f30f0	 ldr         r3, [pc, #0xF0]
  00014	e5933000	 ldr         r3, [r3]
  00018	e58d3028	 str         r3, [sp, #0x28]

; 1356 :    DWORD dwReturnSectorSize=0;
; 1357 :    SD_PARSED_REGISTER_CID  ParsedRegisters; 
; 1358 :    SD_API_STATUS           status = SD_API_STATUS_SUCCESS; // intermediate status
; 1359 : 
; 1360 :    status = SDCardInfoQuery_I(SD_INFO_REGISTER_CID,&ParsedRegisters, sizeof(ParsedRegisters));
; 1361 : 
; 1362 :    if (SD_API_SUCCESS(status)) 

  0001c	e5901000	 ldr         r1, [r0]
  00020	e3a03028	 mov         r3, #0x28
  00024	e28d2000	 add         r2, sp, #0
  00028	e5914034	 ldr         r4, [r1, #0x34]
  0002c	e3a01001	 mov         r1, #1
  00030	e3a05000	 mov         r5, #0
  00034	e1a0e00f	 mov         lr, pc
  00038	e12fff14	 bx          r4
  0003c	e3500000	 cmp         r0, #0
  00040	4a000027	 bmi         |$LN12@EmulateSec|

; 1363 :        {
; 1364 :        DEBUGMSG(SDCARD_ZONE_FUNC,(TEXT("SDBUSDRIEVR::Product ID =%c,%c,%c,%c,%c,%c\n"),ParsedRegisters.ProductName[0],
; 1365 :        ParsedRegisters.ProductName[1],ParsedRegisters.ProductName[2],ParsedRegisters.ProductName[3],
; 1366 :        ParsedRegisters.ProductName[4],ParsedRegisters.ProductName[5]));
; 1367 :        if (!memcmp(ParsedRegisters.ProductName,cInandProductName04G,(sizeof(ParsedRegisters.ProductName)-1)))

  00044	e59f40b8	 ldr         r4, [pc, #0xB8]
  00048	e3a02006	 mov         r2, #6
  0004c	e28d0004	 add         r0, sp, #4
  00050	e1a01004	 mov         r1, r4
  00054	eb000000	 bl          memcmp
  00058	e3500000	 cmp         r0, #0
  0005c	03a03876	 moveq       r3, #0x76, 16

; 1368 :            {
; 1369 :            dwReturnSectorSize = EMMC_INAND_4GB_SECTOR_NUMBER;

  00060	03835b0b	 orreq       r5, r3, #0xB, 22
  00064	0a000020	 beq         |$LN1@EmulateSec|

; 1370 :            DEBUGMSG(SDCARD_ZONE_FUNC,(TEXT("SDBUSDRIEVR::INAND 4GB\n")));
; 1371 :            }
; 1372 :        else if (!memcmp(ParsedRegisters.ProductName,cInandProductName08G,(sizeof(ParsedRegisters.ProductName)-1)))

  00068	e3a02006	 mov         r2, #6
  0006c	e2841008	 add         r1, r4, #8
  00070	e28d0004	 add         r0, sp, #4
  00074	eb000000	 bl          memcmp
  00078	e3500000	 cmp         r0, #0
  0007c	03a0373b	 moveq       r3, #0x3B, 14

; 1373 :            {
; 1374 :            dwReturnSectorSize = EMMC_INAND_8GB_SECTOR_NUMBER;

  00080	03835a0e	 orreq       r5, r3, #0xE, 20
  00084	0a000018	 beq         |$LN1@EmulateSec|

; 1375 :            DEBUGMSG(SDCARD_ZONE_FUNC,(TEXT("SDBUSDRIEVR::INAND 8GB\n")));
; 1376 :            }
; 1377 :        else if (!memcmp(ParsedRegisters.ProductName,cInandProductName16G,(sizeof(ParsedRegisters.ProductName)-1)))

  00088	e3a02006	 mov         r2, #6
  0008c	e2841010	 add         r1, r4, #0x10
  00090	e28d0004	 add         r0, sp, #4
  00094	eb000000	 bl          memcmp
  00098	e3500000	 cmp         r0, #0

; 1378 :            {
; 1379 :            dwReturnSectorSize = EMMC_INAND_16GB_SECTOR_NUMBER;

  0009c	0a000010	 beq         |$LN12@EmulateSec|

; 1380 :            DEBUGMSG(SDCARD_ZONE_FUNC,(TEXT("SDBUSDRIEVR::INAND 16GB\n")));
; 1381 :            }
; 1382 : 	   else if (!memcmp(ParsedRegisters.ProductName,cInandProductName16G_Builtin,(sizeof(ParsedRegisters.ProductName)-1)) )

  000a0	e3a02006	 mov         r2, #6
  000a4	e2841020	 add         r1, r4, #0x20
  000a8	e28d0004	 add         r0, sp, #4
  000ac	eb000000	 bl          memcmp
  000b0	e3500000	 cmp         r0, #0
  000b4	03a03776	 moveq       r3, #0x76, 14

; 1383 :            {
; 1384 :            dwReturnSectorSize = EMMC_INAND_16GB_SECTOR_NUMBER_INT;

  000b8	03835bb3	 orreq       r5, r3, #0xB3, 22
  000bc	0a00000a	 beq         |$LN1@EmulateSec|

; 1385 :            DEBUGMSG(SDCARD_ZONE_FUNC,(TEXT("SDBUSDRIEVR::INAND 16G, Built-in\n")));
; 1386 :            }
; 1387 :        else if (!memcmp(ParsedRegisters.ProductName,cInandProductName32G,(sizeof(ParsedRegisters.ProductName)-1)))

  000c0	e3a02006	 mov         r2, #6
  000c4	e2841018	 add         r1, r4, #0x18
  000c8	e28d0004	 add         r0, sp, #4
  000cc	eb000000	 bl          memcmp
  000d0	e3500000	 cmp         r0, #0
  000d4	1a000004	 bne         |$LN1@EmulateSec|
  000d8	e3a037ed	 mov         r3, #0xED, 14

; 1388 :            {
; 1389 :            dwReturnSectorSize = EMMC_INAND_32GB_SECTOR_NUMBER;

  000dc	e3835803	 orr         r5, r3, #3, 16

; 1390 :            DEBUGMSG(SDCARD_ZONE_FUNC,(TEXT("SDBUSDRIEVR::INAND 32GB\n")));
; 1391 :            }
; 1392 :        else
; 1393 :            {
; 1394 :            DEBUGMSG(SDCARD_ZONE_ERROR,(TEXT("SDBUSDRIEVR::Product ID is not on the support list\n")));
; 1395 :            }
; 1396 :        }   
; 1397 :     else

  000e0	ea000001	 b           |$LN1@EmulateSec|
  000e4		 |$LN12@EmulateSec|
  000e4	e3a03776	 mov         r3, #0x76, 14

; 1398 :        {
; 1399 :        DEBUGMSG(SDCARD_ZONE_FUNC,(TEXT("SDBUSDRIEVR::SDCardInfoQuery_I Fail\n")));
; 1400 :        dwReturnSectorSize = EMMC_INAND_16GB_SECTOR_NUMBER;

  000e8	e3835a2a	 orr         r5, r3, #0x2A, 20
  000ec		 |$LN1@EmulateSec|

; 1401 :        }
; 1402 :     return  dwReturnSectorSize;

  000ec	e59d0028	 ldr         r0, [sp, #0x28]
  000f0	eb000000	 bl          __security_check_cookie

; 1403 : }

  000f4	e1a00005	 mov         r0, r5
  000f8	e28dd02c	 add         sp, sp, #0x2C
  000fc	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00100	e12fff1e	 bx          lr
  00104		 |$LN18@EmulateSec|
  00104		 |$LN19@EmulateSec|
  00104	00000000	 DCD         |cInandProductName04G|
  00108		 |$LN20@EmulateSec|
  00108	00000000	 DCD         |__security_cookie|
  0010c		 |$M40909|

			 ENDP  ; |?EmulateSectorNumberByProdutID@CSDDevice@@QAAKXZ|, CSDDevice::EmulateSectorNumberByProdutID

	EXPORT	|??0?$SafeInt@K@@QAA@K@Z|		; SafeInt<unsigned long>::SafeInt<unsigned long>
; File c:\wince600\public\common\sdk\inc\safeint.hxx

  00000			 AREA	 |.pdata|, PDATA
|$T40926| DCD	|$LN5@SafeInt|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0?$SafeInt@K@@QAA@K@Z| PROC		; SafeInt<unsigned long>::SafeInt<unsigned long>

; 373  : 	SafeInt(T i)

  00000		 |$LN5@SafeInt|
  00000		 |$M40923|

; 374  : 	{
; 375  : 		//always safe
; 376  : 		m_int = i;

  00000	e5801000	 str         r1, [r0]

; 377  : 	}

  00004	e12fff1e	 bx          lr
  00008		 |$M40924|

			 ENDP  ; |??0?$SafeInt@K@@QAA@K@Z|, SafeInt<unsigned long>::SafeInt<unsigned long>

	EXPORT	|??O?$SafeInt@K@@QBA_NV0@@Z|		; SafeInt<unsigned long>::operator>

  00000			 AREA	 |.pdata|, PDATA
|$T40939| DCD	|$LN7@operator|
	DCD	0x40000700
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??O?$SafeInt@K@@QBA_NV0@@Z| PROC	; SafeInt<unsigned long>::operator>

; 896  : 	{

  00000		 |$LN7@operator|
  00000		 |$M40936|

; 897  : 		return m_int > rhs.m_int;

  00000	e5903000	 ldr         r3, [r0]
  00004	e1530001	 cmp         r3, r1
  00008	83a03001	 movhi       r3, #1
  0000c	820300ff	 andhi       r0, r3, #0xFF
  00010	93a03000	 movls       r3, #0
  00014	920300ff	 andls       r0, r3, #0xFF

; 898  : 	}

  00018	e12fff1e	 bx          lr
  0001c		 |$M40937|

			 ENDP  ; |??O?$SafeInt@K@@QBA_NV0@@Z|, SafeInt<unsigned long>::operator>

	EXPORT	|?Value@?$SafeInt@K@@QBAKXZ|		; SafeInt<unsigned long>::Value

  00000			 AREA	 |.pdata|, PDATA
|$T40949| DCD	|$LN5@Value|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Value@?$SafeInt@K@@QBAKXZ| PROC	; SafeInt<unsigned long>::Value

; 564  : 	T Value() const {return m_int;}

  00000		 |$LN5@Value|
  00000		 |$M40946|
  00000	e5900000	 ldr         r0, [r0]
  00004	e12fff1e	 bx          lr
  00008		 |$M40947|

			 ENDP  ; |?Value@?$SafeInt@K@@QBAKXZ|, SafeInt<unsigned long>::Value

	EXPORT	|?IsSigned@?$SafeInt@K@@SA_NXZ|		; SafeInt<unsigned long>::IsSigned

  00000			 AREA	 |.pdata|, PDATA
|$T40958| DCD	|$LN5@IsSigned|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsSigned@?$SafeInt@K@@SA_NXZ| PROC	; SafeInt<unsigned long>::IsSigned

; 449  : 	{

  00000		 |$LN5@IsSigned|
  00000		 |$M40955|

; 450  : 		return( (T)-1 < 0 );

  00000	e3a00000	 mov         r0, #0

; 451  : 	}

  00004	e12fff1e	 bx          lr
  00008		 |$M40956|

			 ENDP  ; |?IsSigned@?$SafeInt@K@@SA_NXZ|, SafeInt<unsigned long>::IsSigned

	EXPORT	|?IsMixedSign@?$SafeInt@K@@CA_NKK@Z|	; SafeInt<unsigned long>::IsMixedSign

  00000			 AREA	 |.pdata|, PDATA
|$T40969| DCD	|$LN7@IsMixedSig|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsMixedSign@?$SafeInt@K@@CA_NKK@Z| PROC ; SafeInt<unsigned long>::IsMixedSign

; 2315 : 	{

  00000		 |$LN7@IsMixedSig|
  00000		 |$M40966|

; 2316 : 		return ((lhs ^ rhs) < 0);

  00000	e3a00000	 mov         r0, #0

; 2317 : 	}

  00004	e12fff1e	 bx          lr
  00008		 |$M40967|

			 ENDP  ; |?IsMixedSign@?$SafeInt@K@@CA_NKK@Z|, SafeInt<unsigned long>::IsMixedSign

	EXPORT	|?IsSigned@?$SafeInt@E@@SA_NXZ|		; SafeInt<unsigned char>::IsSigned

  00000			 AREA	 |.pdata|, PDATA
|$T40978| DCD	|$LN5@IsSigned@2|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsSigned@?$SafeInt@E@@SA_NXZ| PROC	; SafeInt<unsigned char>::IsSigned

; 449  : 	{

  00000		 |$LN5@IsSigned@2|
  00000		 |$M40975|

; 450  : 		return( (T)-1 < 0 );

  00000	e3a00000	 mov         r0, #0

; 451  : 	}

  00004	e12fff1e	 bx          lr
  00008		 |$M40976|

			 ENDP  ; |?IsSigned@?$SafeInt@E@@SA_NXZ|, SafeInt<unsigned char>::IsSigned

	EXPORT	|?BitCount@?$SafeInt@K@@SAEXZ|		; SafeInt<unsigned long>::BitCount

  00000			 AREA	 |.pdata|, PDATA
|$T40987| DCD	|$LN5@BitCount|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?BitCount@?$SafeInt@K@@SAEXZ| PROC	; SafeInt<unsigned long>::BitCount

; 453  : 	static unsigned char BitCount(){return (sizeof(T)*8);}

  00000		 |$LN5@BitCount|
  00000		 |$M40984|
  00000	e3a00020	 mov         r0, #0x20
  00004	e12fff1e	 bx          lr
  00008		 |$M40985|

			 ENDP  ; |?BitCount@?$SafeInt@K@@SAEXZ|, SafeInt<unsigned long>::BitCount

	EXPORT	|??0?$SafeInt@H@@QAA@H@Z|		; SafeInt<int>::SafeInt<int>

  00000			 AREA	 |.pdata|, PDATA
|$T40998| DCD	|$LN5@SafeInt@2|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0?$SafeInt@H@@QAA@H@Z| PROC		; SafeInt<int>::SafeInt<int>

; 373  : 	SafeInt(T i)

  00000		 |$LN5@SafeInt@2|
  00000		 |$M40995|

; 374  : 	{
; 375  : 		//always safe
; 376  : 		m_int = i;

  00000	e5801000	 str         r1, [r0]

; 377  : 	}

  00004	e12fff1e	 bx          lr
  00008		 |$M40996|

			 ENDP  ; |??0?$SafeInt@H@@QAA@H@Z|, SafeInt<int>::SafeInt<int>

	EXPORT	|?IsSigned@?$SafeInt@H@@SA_NXZ|		; SafeInt<int>::IsSigned

  00000			 AREA	 |.pdata|, PDATA
|$T41007| DCD	|$LN5@IsSigned@3|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsSigned@?$SafeInt@H@@SA_NXZ| PROC	; SafeInt<int>::IsSigned

; 449  : 	{

  00000		 |$LN5@IsSigned@3|
  00000		 |$M41004|

; 450  : 		return( (T)-1 < 0 );

  00000	e3a00001	 mov         r0, #1

; 451  : 	}

  00004	e12fff1e	 bx          lr
  00008		 |$M41005|

			 ENDP  ; |?IsSigned@?$SafeInt@H@@SA_NXZ|, SafeInt<int>::IsSigned

	EXPORT	|?Value@?$SafeInt@H@@QBAHXZ|		; SafeInt<int>::Value

  00000			 AREA	 |.pdata|, PDATA
|$T41017| DCD	|$LN5@Value@2|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Value@?$SafeInt@H@@QBAHXZ| PROC	; SafeInt<int>::Value

; 564  : 	T Value() const {return m_int;}

  00000		 |$LN5@Value@2|
  00000		 |$M41014|
  00000	e5900000	 ldr         r0, [r0]
  00004	e12fff1e	 bx          lr
  00008		 |$M41015|

			 ENDP  ; |?Value@?$SafeInt@H@@QBAHXZ|, SafeInt<int>::Value

	EXPORT	|?Is64Bit@?$SafeInt@K@@SA_NXZ|		; SafeInt<unsigned long>::Is64Bit

  00000			 AREA	 |.pdata|, PDATA
|$T41026| DCD	|$LN5@Is64Bit|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Is64Bit@?$SafeInt@K@@SA_NXZ| PROC	; SafeInt<unsigned long>::Is64Bit

; 456  : 	static bool Is64Bit(){return sizeof(T) == 8;}

  00000		 |$LN5@Is64Bit|
  00000		 |$M41023|
  00000	e3a00000	 mov         r0, #0
  00004	e12fff1e	 bx          lr
  00008		 |$M41024|

			 ENDP  ; |?Is64Bit@?$SafeInt@K@@SA_NXZ|, SafeInt<unsigned long>::Is64Bit

	EXPORT	|?Is32Bit@?$SafeInt@K@@SA_NXZ|		; SafeInt<unsigned long>::Is32Bit

  00000			 AREA	 |.pdata|, PDATA
|$T41035| DCD	|$LN5@Is32Bit|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Is32Bit@?$SafeInt@K@@SA_NXZ| PROC	; SafeInt<unsigned long>::Is32Bit

; 457  : 	static bool Is32Bit(){return sizeof(T) == 4;}

  00000		 |$LN5@Is32Bit|
  00000		 |$M41032|
  00000	e3a00001	 mov         r0, #1
  00004	e12fff1e	 bx          lr
  00008		 |$M41033|

			 ENDP  ; |?Is32Bit@?$SafeInt@K@@SA_NXZ|, SafeInt<unsigned long>::Is32Bit

	EXPORT	|?Is16Bit@?$SafeInt@K@@SA_NXZ|		; SafeInt<unsigned long>::Is16Bit

  00000			 AREA	 |.pdata|, PDATA
|$T41044| DCD	|$LN5@Is16Bit|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Is16Bit@?$SafeInt@K@@SA_NXZ| PROC	; SafeInt<unsigned long>::Is16Bit

; 458  : 	static bool Is16Bit(){return sizeof(T) == 2;}

  00000		 |$LN5@Is16Bit|
  00000		 |$M41041|
  00000	e3a00000	 mov         r0, #0
  00004	e12fff1e	 bx          lr
  00008		 |$M41042|

			 ENDP  ; |?Is16Bit@?$SafeInt@K@@SA_NXZ|, SafeInt<unsigned long>::Is16Bit

	EXPORT	|??4?$SafeInt@H@@QAAAAV0@V0@@Z|		; SafeInt<int>::operator=

  00000			 AREA	 |.pdata|, PDATA
|$T41055| DCD	|$LN5@operator@2|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??4?$SafeInt@H@@QAAAAV0@V0@@Z| PROC	; SafeInt<int>::operator=

; 515  : 	{

  00000		 |$LN5@operator@2|
  00000		 |$M41052|

; 516  : 		m_int = rhs.m_int;

  00000	e5801000	 str         r1, [r0]

; 517  : 		return *this;
; 518  : 	}

  00004	e12fff1e	 bx          lr
  00008		 |$M41053|

			 ENDP  ; |??4?$SafeInt@H@@QAAAAV0@V0@@Z|, SafeInt<int>::operator=

	EXPORT	|?IsSigned@?$SafeInt@_J@@SA_NXZ|	; SafeInt<__int64>::IsSigned

  00000			 AREA	 |.pdata|, PDATA
|$T41064| DCD	|$LN5@IsSigned@4|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsSigned@?$SafeInt@_J@@SA_NXZ| PROC	; SafeInt<__int64>::IsSigned

; 449  : 	{

  00000		 |$LN5@IsSigned@4|
  00000		 |$M41061|

; 450  : 		return( (T)-1 < 0 );

  00000	e3a00001	 mov         r0, #1

; 451  : 	}

  00004	e12fff1e	 bx          lr
  00008		 |$M41062|

			 ENDP  ; |?IsSigned@?$SafeInt@_J@@SA_NXZ|, SafeInt<__int64>::IsSigned

	EXPORT	|?IsSigned@?$SafeInt@I@@SA_NXZ|		; SafeInt<unsigned int>::IsSigned

  00000			 AREA	 |.pdata|, PDATA
|$T41073| DCD	|$LN5@IsSigned@5|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsSigned@?$SafeInt@I@@SA_NXZ| PROC	; SafeInt<unsigned int>::IsSigned

; 449  : 	{

  00000		 |$LN5@IsSigned@5|
  00000		 |$M41070|

; 450  : 		return( (T)-1 < 0 );

  00000	e3a00000	 mov         r0, #0

; 451  : 	}

  00004	e12fff1e	 bx          lr
  00008		 |$M41071|

			 ENDP  ; |?IsSigned@?$SafeInt@I@@SA_NXZ|, SafeInt<unsigned int>::IsSigned

	EXPORT	|?IsSigned@?$SafeInt@_K@@SA_NXZ|	; SafeInt<unsigned __int64>::IsSigned

  00000			 AREA	 |.pdata|, PDATA
|$T41082| DCD	|$LN5@IsSigned@6|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsSigned@?$SafeInt@_K@@SA_NXZ| PROC	; SafeInt<unsigned __int64>::IsSigned

; 449  : 	{

  00000		 |$LN5@IsSigned@6|
  00000		 |$M41079|

; 450  : 		return( (T)-1 < 0 );

  00000	e3a00000	 mov         r0, #0

; 451  : 	}

  00004	e12fff1e	 bx          lr
  00008		 |$M41080|

			 ENDP  ; |?IsSigned@?$SafeInt@_K@@SA_NXZ|, SafeInt<unsigned __int64>::IsSigned

	EXPORT	|?BitCount@?$SafeInt@H@@SAEXZ|		; SafeInt<int>::BitCount

  00000			 AREA	 |.pdata|, PDATA
|$T41091| DCD	|$LN5@BitCount@2|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?BitCount@?$SafeInt@H@@SAEXZ| PROC	; SafeInt<int>::BitCount

; 453  : 	static unsigned char BitCount(){return (sizeof(T)*8);}

  00000		 |$LN5@BitCount@2|
  00000		 |$M41088|
  00000	e3a00020	 mov         r0, #0x20
  00004	e12fff1e	 bx          lr
  00008		 |$M41089|

			 ENDP  ; |?BitCount@?$SafeInt@H@@SAEXZ|, SafeInt<int>::BitCount

	EXPORT	|?Is64Bit@?$SafeInt@H@@SA_NXZ|		; SafeInt<int>::Is64Bit

  00000			 AREA	 |.pdata|, PDATA
|$T41100| DCD	|$LN5@Is64Bit@2|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Is64Bit@?$SafeInt@H@@SA_NXZ| PROC	; SafeInt<int>::Is64Bit

; 456  : 	static bool Is64Bit(){return sizeof(T) == 8;}

  00000		 |$LN5@Is64Bit@2|
  00000		 |$M41097|
  00000	e3a00000	 mov         r0, #0
  00004	e12fff1e	 bx          lr
  00008		 |$M41098|

			 ENDP  ; |?Is64Bit@?$SafeInt@H@@SA_NXZ|, SafeInt<int>::Is64Bit

	EXPORT	|?Is32Bit@?$SafeInt@H@@SA_NXZ|		; SafeInt<int>::Is32Bit

  00000			 AREA	 |.pdata|, PDATA
|$T41109| DCD	|$LN5@Is32Bit@2|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Is32Bit@?$SafeInt@H@@SA_NXZ| PROC	; SafeInt<int>::Is32Bit

; 457  : 	static bool Is32Bit(){return sizeof(T) == 4;}

  00000		 |$LN5@Is32Bit@2|
  00000		 |$M41106|
  00000	e3a00001	 mov         r0, #1
  00004	e12fff1e	 bx          lr
  00008		 |$M41107|

			 ENDP  ; |?Is32Bit@?$SafeInt@H@@SA_NXZ|, SafeInt<int>::Is32Bit

	EXPORT	|?Is16Bit@?$SafeInt@H@@SA_NXZ|		; SafeInt<int>::Is16Bit

  00000			 AREA	 |.pdata|, PDATA
|$T41118| DCD	|$LN5@Is16Bit@2|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Is16Bit@?$SafeInt@H@@SA_NXZ| PROC	; SafeInt<int>::Is16Bit

; 458  : 	static bool Is16Bit(){return sizeof(T) == 2;}

  00000		 |$LN5@Is16Bit@2|
  00000		 |$M41115|
  00000	e3a00000	 mov         r0, #0
  00004	e12fff1e	 bx          lr
  00008		 |$M41116|

			 ENDP  ; |?Is16Bit@?$SafeInt@H@@SA_NXZ|, SafeInt<int>::Is16Bit

	EXPORT	|?IsMixedSign@?$SafeInt@H@@CA_NHH@Z|	; SafeInt<int>::IsMixedSign

  00000			 AREA	 |.pdata|, PDATA
|$T41131| DCD	|$LN7@IsMixedSig@2|
	DCD	0x40000600
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsMixedSign@?$SafeInt@H@@CA_NHH@Z| PROC ; SafeInt<int>::IsMixedSign

; 2315 : 	{

  00000		 |$LN7@IsMixedSig@2|
  00000		 |$M41128|

; 2316 : 		return ((lhs ^ rhs) < 0);

  00000	e1300001	 teq         r0, r1
  00004	43a03001	 movmi       r3, #1
  00008	420300ff	 andmi       r0, r3, #0xFF
  0000c	53a03000	 movpl       r3, #0
  00010	520300ff	 andpl       r0, r3, #0xFF

; 2317 : 	}

  00014	e12fff1e	 bx          lr
  00018		 |$M41129|

			 ENDP  ; |?IsMixedSign@?$SafeInt@H@@CA_NHH@Z|, SafeInt<int>::IsMixedSign

	EXPORT	|??4?$SafeInt@K@@QAAAAV0@V0@@Z|		; SafeInt<unsigned long>::operator=

  00000			 AREA	 |.pdata|, PDATA
|$T41142| DCD	|$LN5@operator@3|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??4?$SafeInt@K@@QAAAAV0@V0@@Z| PROC	; SafeInt<unsigned long>::operator=

; 515  : 	{

  00000		 |$LN5@operator@3|
  00000		 |$M41139|

; 516  : 		m_int = rhs.m_int;

  00000	e5801000	 str         r1, [r0]

; 517  : 		return *this;
; 518  : 	}

  00004	e12fff1e	 bx          lr
  00008		 |$M41140|

			 ENDP  ; |??4?$SafeInt@K@@QAAAAV0@V0@@Z|, SafeInt<unsigned long>::operator=

	EXPORT	|?SDGetTuple_I@CSDDevice@@UAAJEPAEPAKH@Z| ; CSDDevice::SDGetTuple_I
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevinf.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T41170| DCD	|$LN28@SDGetTuple@2|
	DCD	0x40004102
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDGetTuple_I@CSDDevice@@UAAJEPAEPAKH@Z| PROC ; CSDDevice::SDGetTuple_I

; 77   : {

  00000		 |$LN28@SDGetTuple@2|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M41167|
  00008	e1b04003	 movs        r4, r3
  0000c	e1a05002	 mov         r5, r2
  00010	e1a09001	 mov         r9, r1
  00014	e1a07000	 mov         r7, r0

; 78   :     SD_API_STATUS status = SD_API_STATUS_SUCCESS;  // intermediate status
; 79   :     UCHAR                  tCode;                  // tuple code we've read so far
; 80   :     UCHAR                  tupleLink;              // tuple link offset
; 81   :     ULONG                  currentOffset;          // current offset
; 82   : 
; 83   :     DEBUGMSG(SDCARD_ZONE_FUNC, (TEXT("SDCard: +SDGetTuple\n")));
; 84   : 
; 85   : 
; 86   :     if (NULL == pBufferSize) {
; 87   :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDGetTuple: NULL buffer size \n")));
; 88   :         return SD_API_STATUS_INVALID_PARAMETER;

  00018	0a00002d	 beq         |$LN25@SDGetTuple@2|

; 89   :     }
; 90   : 
; 91   :     if (pBuffer == NULL) {

  0001c	e3550000	 cmp         r5, #0

; 92   :         // Initialize pBufferSize to zero to indicate that the tuple 
; 93   :         // was not found
; 94   :         *pBufferSize = 0; 
; 95   :     }
; 96   :     
; 97   :     currentOffset = 0;
; 98   :     // walk through the CIS
; 99   :     while (TRUE) {
; 100  : 
; 101  :         // get 1 byte at the current position
; 102  :         status = SDGetTupleBytes(currentOffset,  &tCode, 1, CommonCIS);

  00020	e59d8024	 ldr         r8, [sp, #0x24]
  00024	03a03000	 moveq       r3, #0
  00028	05843000	 streq       r3, [r4]
  0002c	e3a03001	 mov         r3, #1
  00030	e28d2004	 add         r2, sp, #4
  00034	e3a01000	 mov         r1, #0
  00038	e1a00007	 mov         r0, r7
  0003c	e58d8000	 str         r8, [sp]
  00040	e3a06000	 mov         r6, #0
  00044	eb000000	 bl          |?SDGetTupleBytes@CSDDevice@@IAAJKPAEKH@Z|
  00048	ea000019	 b           |$LN24@SDGetTuple@2|

; 103  : 
; 104  :         if (!SD_API_SUCCESS(status)) {

  0004c		 |$LL12@SDGetTuple@2|

; 106  :         }
; 107  :         // add the tCode
; 108  :         currentOffset += 1;
; 109  : 
; 110  :         if(SD_CISTPL_END == tCode) {

  0004c	e5dd3004	 ldrb        r3, [sp, #4]
  00050	e2866001	 add         r6, r6, #1
  00054	e35300ff	 cmp         r3, #0xFF
  00058	0a000026	 beq         |$LN2@SDGetTuple@2|

; 111  :             // this is the End of chain Tuple
; 112  :             // break out of while loop
; 113  :             break;
; 114  : 
; 115  :         } else  {
; 116  : 
; 117  :             // get the tuple link offset in the next byte, we always need this
; 118  :             // value, so we fetch it before we compare the tuple code
; 119  :             status = SDGetTupleBytes(currentOffset, &tupleLink, 1, CommonCIS);

  0005c	e3a03001	 mov         r3, #1
  00060	e28d2005	 add         r2, sp, #5
  00064	e1a01006	 mov         r1, r6
  00068	e1a00007	 mov         r0, r7
  0006c	e58d8000	 str         r8, [sp]
  00070	eb000000	 bl          |?SDGetTupleBytes@CSDDevice@@IAAJKPAEKH@Z|
  00074	e3500000	 cmp         r0, #0

; 120  : 
; 121  :             if (!SD_API_SUCCESS(status)) {

  00078	4a00001e	 bmi         |$LN2@SDGetTuple@2|

; 122  :                 break;
; 123  :             }
; 124  : 
; 125  :             // add the link
; 126  :             currentOffset += 1;
; 127  : 
; 128  :             // check for the end link flag, this is the alternative method to stop
; 129  :             // tuple scanning
; 130  :             if (SD_TUPLE_LINK_END == tupleLink) {

  0007c	e5dd2005	 ldrb        r2, [sp, #5]
  00080	e2861001	 add         r1, r6, #1
  00084	e35200ff	 cmp         r2, #0xFF
  00088	0a00001a	 beq         |$LN2@SDGetTuple@2|

; 131  :                 // we reached an end of chain
; 132  :                 break;
; 133  :             }
; 134  :             // go back and check the tuple code
; 135  :             if (tCode == TupleCode) {

  0008c	e5dd3004	 ldrb        r3, [sp, #4]
  00090	e1530009	 cmp         r3, r9
  00094	0a000009	 beq         |$LN23@SDGetTuple@2|

; 159  :                 }
; 160  :                 // break out of the while loop 
; 161  :                 break;
; 162  : 
; 163  :             } else {
; 164  : 
; 165  :                 // add the value of the link
; 166  :                 currentOffset += tupleLink;

  00098	e0816002	 add         r6, r1, r2
  0009c	e1a01006	 mov         r1, r6
  000a0	e3a03001	 mov         r3, #1
  000a4	e28d2004	 add         r2, sp, #4
  000a8	e1a00007	 mov         r0, r7
  000ac	e58d8000	 str         r8, [sp]
  000b0	eb000000	 bl          |?SDGetTupleBytes@CSDDevice@@IAAJKPAEKH@Z|
  000b4		 |$LN24@SDGetTuple@2|
  000b4	e3500000	 cmp         r0, #0
  000b8	5affffe3	 bpl         |$LL12@SDGetTuple@2|

; 105  :             break;

  000bc	ea00000d	 b           |$LN2@SDGetTuple@2|
  000c0		 |$LN23@SDGetTuple@2|

; 136  :                 // found it
; 137  : 
; 138  :                 // check to see if the caller is interested in the data
; 139  :                 if (NULL != pBuffer) {

  000c0	e3550000	 cmp         r5, #0
  000c4	0a00000a	 beq         |$LN4@SDGetTuple@2|

; 140  : 
; 141  :                     // if the user passed a buffer, they must pass the buffer size, double check the length
; 142  :                     if (*pBufferSize < tupleLink) {

  000c8	e5943000	 ldr         r3, [r4]
  000cc	e1530002	 cmp         r3, r2
  000d0	2a000001	 bcs         |$LN3@SDGetTuple@2|
  000d4		 |$LN25@SDGetTuple@2|

; 143  :                         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDCard: SDGetTuple, caller supplied buffer of size: %d bytes but tuple body (code=0x%02X) reports size of %d bytes\n"),
; 144  :                             *pBufferSize, tCode, tupleLink));    
; 145  :                         status = SD_API_STATUS_INVALID_PARAMETER;

  000d4	e3a0011f	 mov         r0, #0x1F, 2

; 146  :                         break;

  000d8	ea000006	 b           |$LN2@SDGetTuple@2|
  000dc		 |$LN3@SDGetTuple@2|

; 147  :                     }
; 148  : 
; 149  :                     // fetch the tuple body
; 150  :                     status = SDGetTupleBytes(currentOffset, 
; 151  :                         pBuffer, 
; 152  :                         tupleLink, 
; 153  :                         CommonCIS);

  000dc	e1a03002	 mov         r3, r2
  000e0	e1a02005	 mov         r2, r5
  000e4	e1a00007	 mov         r0, r7
  000e8	e58d8000	 str         r8, [sp]
  000ec	eb000000	 bl          |?SDGetTupleBytes@CSDDevice@@IAAJKPAEKH@Z|

; 154  : 
; 155  :                 } else {

  000f0	ea000000	 b           |$LN2@SDGetTuple@2|
  000f4		 |$LN4@SDGetTuple@2|

; 156  : 
; 157  :                     // return the size of the tuple body we just found, no need to fetch
; 158  :                     *pBufferSize = tupleLink;

  000f4	e5842000	 str         r2, [r4]
  000f8		 |$LN2@SDGetTuple@2|

; 167  :             }
; 168  : 
; 169  :         } 
; 170  : 
; 171  :     }
; 172  : 
; 173  :     DEBUGMSG(SDCARD_ZONE_FUNC, (TEXT("SDCard: -SDGetTuple\n")));
; 174  :     return status;
; 175  : }

  000f8	e28dd008	 add         sp, sp, #8
  000fc	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00100	e12fff1e	 bx          lr
  00104		 |$M41168|

			 ENDP  ; |?SDGetTuple_I@CSDDevice@@UAAJEPAEPAKH@Z|, CSDDevice::SDGetTuple_I

	EXPORT	|?addition@?$SafeInt@K@@CAKKK@Z|	; SafeInt<unsigned long>::addition
; File c:\wince600\public\common\sdk\inc\safeint.hxx

  00000			 AREA	 |.pdata|, PDATA
|$T41213| DCD	|$LN32@addition|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?addition@?$SafeInt@K@@CAKKK@Z| PROC	; SafeInt<unsigned long>::addition

; 1443 : 	{

  00000		 |$LN32@addition|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41210|

; 1444 : 		T tmp = rhs + lhs;

  00004	e0803001	 add         r3, r0, r1

; 1445 : 
; 1446 : 		if(IsSigned() &&
; 1447 : 		   !IsMixedSign(lhs, rhs) && //either two negatives, or 2 positives
; 1448 : 		   rhs < 0)//two negatives
; 1449 : 		{			
; 1450 : 			if(lhs < tmp) 
; 1451 : 			{
; 1452 : 				//we added a negative and it got bigger
; 1453 : 				SafeIntOnOverflow();
; 1454 : 			}
; 1455 : 			//ok
; 1456 : 		}
; 1457 : 		else if((IsSigned() && !IsMixedSign(lhs, rhs)) ||
; 1458 : 			    !IsSigned())
; 1459 : 		{
; 1460 : 			//signed case with two positives
; 1461 : 			//OR is unsigned	
; 1462 : 
; 1463 : 			//added two positives and result is smaller
; 1464 : 			if(lhs > tmp)

  00008	e1500003	 cmp         r0, r3
  0000c	9a000005	 bls         |$LN1@addition|
  00010	e3a03103	 mov         r3, #3, 2

; 1465 : 			{
; 1466 : 				SafeIntOnOverflow();

  00014	e3830095	 orr         r0, r3, #0x95
  00018	e3a03000	 mov         r3, #0
  0001c	e3a02000	 mov         r2, #0
  00020	e3a01000	 mov         r1, #0
  00024	eb000000	 bl          RaiseException
  00028		 |$LN33@addition|
  00028		 |$LN1@addition|

; 1467 : 			}
; 1468 : 			//OK
; 1469 : 		}
; 1470 : 		//else overflow not possible
; 1471 : 
; 1472 : 		return tmp;
; 1473 : 	}

  00028	e1a00003	 mov         r0, r3
  0002c	e49de004	 ldr         lr, [sp], #4
  00030	e12fff1e	 bx          lr
  00034		 |$LN29@addition|
  00034		 |$M41211|

			 ENDP  ; |?addition@?$SafeInt@K@@CAKKK@Z|, SafeInt<unsigned long>::addition

	EXPORT	|?MaxInt@?$SafeInt@K@@SAKXZ|		; SafeInt<unsigned long>::MaxInt

  00000			 AREA	 |.pdata|, PDATA
|$T41229| DCD	|$LN10@MaxInt|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?MaxInt@?$SafeInt@K@@SAKXZ| PROC	; SafeInt<unsigned long>::MaxInt

; 468  : 	{

  00000		 |$LN10@MaxInt|
  00000		 |$M41226|

; 469  : 		if(IsSigned())
; 470  : 		{
; 471  : 			return (T)~((T)1 << (BitCount()-1));
; 472  : 		}
; 473  : 		//else
; 474  : 		return (T)(~(T)0);

  00000	e3e00000	 mvn         r0, #0

; 475  : 	}

  00004	e12fff1e	 bx          lr
  00008		 |$M41227|

			 ENDP  ; |?MaxInt@?$SafeInt@K@@SAKXZ|, SafeInt<unsigned long>::MaxInt

	EXPORT	|?MinInt@?$SafeInt@K@@SAKXZ|		; SafeInt<unsigned long>::MinInt

  00000			 AREA	 |.pdata|, PDATA
|$T41244| DCD	|$LN11@MinInt|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?MinInt@?$SafeInt@K@@SAKXZ| PROC	; SafeInt<unsigned long>::MinInt

; 478  : 	{

  00000		 |$LN11@MinInt|
  00000		 |$M41241|

; 479  : 		if(IsSigned())
; 480  : 		{
; 481  : 			return (T)((T)1 << (BitCount()-1));
; 482  : 		}
; 483  : 		else
; 484  : 		{
; 485  : 			return ((T)0);

  00000	e3a00000	 mov         r0, #0

; 486  : 		}
; 487  : 	}

  00004	e12fff1e	 bx          lr
  00008		 |$M41242|

			 ENDP  ; |?MinInt@?$SafeInt@K@@SAKXZ|, SafeInt<unsigned long>::MinInt

	EXPORT	|?multiply@?$SafeInt@K@@CAKKK@Z|	; SafeInt<unsigned long>::multiply

  00000			 AREA	 |.pdata|, PDATA
|$T41432| DCD	|$LN140@multiply|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?multiply@?$SafeInt@K@@CAKKK@Z| PROC	; SafeInt<unsigned long>::multiply

; 1266 : 	{

  00000		 |$LN140@multiply|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41429|

; 1267 : 		if(Is64Bit())
; 1268 : 		{
; 1269 : 			//fast track this one - and avoid DIV_0 below
; 1270 : 			if(lhs == 0 || rhs == 0)
; 1271 : 				return 0;
; 1272 : 
; 1273 : 			//we're 64 bit - slow, but the only way to do it
; 1274 : 			if(IsSigned())
; 1275 : 			{
; 1276 : 				if(!IsMixedSign(lhs, rhs))
; 1277 : 				{
; 1278 : 					//both positive or both negative
; 1279 : 					//result will be positive, check for lhs * rhs > MaxInt
; 1280 : 					if(lhs > 0)
; 1281 : 					{
; 1282 : 						//both positive
; 1283 : 						if(MaxInt()/lhs < rhs)
; 1284 : 						{
; 1285 : 							//overflow
; 1286 : 							SafeIntOnOverflow();
; 1287 : 						}
; 1288 : 					}
; 1289 : 					else
; 1290 : 					{
; 1291 : 						//both negative
; 1292 : 
; 1293 : 						//comparison gets tricky unless we force it to positive
; 1294 : 						//EXCEPT that -MinInt is undefined - can't be done
; 1295 : 						//And MinInt always has a greater magnitude than MaxInt
; 1296 : 						if(lhs == MinInt() || rhs == MinInt())
; 1297 : 						{
; 1298 : 							//overflow
; 1299 : 							SafeIntOnOverflow();
; 1300 : 						}
; 1301 : 
; 1302 : 						if(MaxInt()/(-lhs) < (-rhs) )
; 1303 : 						{
; 1304 : 							//overflow
; 1305 : 							SafeIntOnOverflow();
; 1306 : 						}
; 1307 : 					}
; 1308 : 				}
; 1309 : 				else
; 1310 : 				{
; 1311 : 					//mixed sign - this case is difficult
; 1312 : 					//test case is lhs * rhs < MinInt => overflow
; 1313 : 					//if lhs < 0 (implies rhs > 0), 
; 1314 : 					//lhs < MinInt/rhs is the correct test
; 1315 : 					//else if lhs > 0 
; 1316 : 					//rhs < MinInt/lhs is the correct test
; 1317 : 					//avoid dividing MinInt by a negative number, 
; 1318 : 					//because MinInt/-1 is a corner case
; 1319 : 
; 1320 : 					if(lhs < 0)
; 1321 : 					{
; 1322 : 						if(lhs < MinInt()/rhs)
; 1323 : 						{
; 1324 : 							//overflow
; 1325 : 							SafeIntOnOverflow();
; 1326 : 						}
; 1327 : 					}
; 1328 : 					else
; 1329 : 					{
; 1330 : 						if(rhs < MinInt()/lhs)
; 1331 : 						{
; 1332 : 							//overflow
; 1333 : 							SafeIntOnOverflow();
; 1334 : 						}
; 1335 : 					}
; 1336 : 				}
; 1337 : 
; 1338 : 				//ok
; 1339 : 				return lhs * rhs;
; 1340 : 			}
; 1341 : 			else
; 1342 : 			{
; 1343 : 				//unsigned, easy case
; 1344 : 				if(MaxInt()/lhs < rhs)
; 1345 : 				{
; 1346 : 					//overflow
; 1347 : 					SafeIntOnOverflow();
; 1348 : 				}
; 1349 : 				//ok
; 1350 : 				return lhs * rhs;
; 1351 : 			}
; 1352 : 		}
; 1353 : 		else if(Is32Bit())
; 1354 : 		{
; 1355 : 			//we're 32-bit
; 1356 : 			if(IsSigned())
; 1357 : 			{
; 1358 : 				signed _int64 tmp = (signed _int64)lhs * (signed _int64)rhs;
; 1359 : 
; 1360 : 				//upper 33 bits must be the same
; 1361 : 				//most common case is likely that both are positive - test first
; 1362 : 				if( (tmp & 0xffffffff80000000LL) == 0 || 
; 1363 : 					(tmp & 0xffffffff80000000LL) == 0xffffffff80000000LL)
; 1364 : 				{
; 1365 : 					//this is OK
; 1366 : 					return (T)tmp;
; 1367 : 				}
; 1368 : 
; 1369 : 				//overflow
; 1370 : 				SafeIntOnOverflow();
; 1371 : 				
; 1372 : 			}
; 1373 : 			else
; 1374 : 			{
; 1375 : 				unsigned _int64 tmp = (unsigned _int64)lhs * (unsigned _int64)rhs;

  00004	e0832190	 umull       r2, r3, r0, r1

; 1376 : 				if (tmp & 0xffffffff00000000ULL) //overflow

  00008	e3530000	 cmp         r3, #0
  0000c	0a000005	 beq         |$LN14@multiply|
  00010	e3a03103	 mov         r3, #3, 2

; 1377 : 				{
; 1378 : 					//overflow
; 1379 : 					SafeIntOnOverflow();

  00014	e3830095	 orr         r0, r3, #0x95
  00018	e3a03000	 mov         r3, #0
  0001c	e3a02000	 mov         r2, #0
  00020	e3a01000	 mov         r1, #0
  00024	eb000000	 bl          RaiseException
  00028		 |$LN141@multiply|
  00028		 |$LN14@multiply|

; 1380 : 				}
; 1381 : 				return (T)tmp;
; 1382 : 			}
; 1383 : 		}
; 1384 : 		else if(Is16Bit())
; 1385 : 		{
; 1386 : 			//16-bit
; 1387 : 			if(IsSigned())
; 1388 : 			{
; 1389 : 				signed _int32 tmp = (signed _int32)lhs * (signed _int32)rhs;
; 1390 : 				//upper 17 bits must be the same
; 1391 : 				//most common case is likely that both are positive - test first
; 1392 : 				if( (tmp & 0xffff8000) == 0 || (tmp & 0xffff8000) == 0xffff8000)
; 1393 : 				{
; 1394 : 					//this is OK
; 1395 : 					return (T)tmp;
; 1396 : 				}
; 1397 : 
; 1398 : 				//overflow
; 1399 : 				SafeIntOnOverflow();
; 1400 : 			}
; 1401 : 			else
; 1402 : 			{
; 1403 : 				unsigned _int32 tmp = (unsigned _int32)lhs * (unsigned _int32)rhs;
; 1404 : 				if (tmp & 0xffff0000) //overflow
; 1405 : 				{
; 1406 : 					SafeIntOnOverflow();
; 1407 : 				}
; 1408 : 				return (T)tmp;
; 1409 : 			}
; 1410 : 		}
; 1411 : 		else //8-bit
; 1412 : 		{
; 1413 : 			assert(Is8Bit());
; 1414 : 
; 1415 : 			if(IsSigned())
; 1416 : 			{
; 1417 : 				signed _int16 tmp = (signed _int16)lhs * (signed _int16)rhs;
; 1418 : 				//upper 9 bits must be the same
; 1419 : 				//most common case is likely that both are positive - test first
; 1420 : 				if( (tmp & 0xff80) == 0 || (tmp & 0xff80) == 0xff80)
; 1421 : 				{
; 1422 : 					//this is OK
; 1423 : 					return (T)tmp;
; 1424 : 				}
; 1425 : 
; 1426 : 				//overflow
; 1427 : 				SafeIntOnOverflow();
; 1428 : 			}
; 1429 : 			else
; 1430 : 			{
; 1431 : 				unsigned _int16 tmp = ((unsigned _int16)lhs) * ((unsigned _int16)rhs);
; 1432 : 
; 1433 : 				if (tmp & 0xff00) //overflow
; 1434 : 				{
; 1435 : 					SafeIntOnOverflow();
; 1436 : 				}
; 1437 : 				return (T)tmp;
; 1438 : 			}
; 1439 : 		}
; 1440 : 	}

  00028	e1a00002	 mov         r0, r2
  0002c	e49de004	 ldr         lr, [sp], #4
  00030	e12fff1e	 bx          lr
  00034		 |$LN137@multiply|
  00034		 |$M41430|

			 ENDP  ; |?multiply@?$SafeInt@K@@CAKKK@Z|, SafeInt<unsigned long>::multiply

	EXPORT	|??$?0H@?$SafeInt@K@@QAA@H@Z|		; SafeInt<unsigned long>::SafeInt<unsigned long><int>

  00000			 AREA	 |.pdata|, PDATA
|$T41513| DCD	|$LN55@SafeInt@3|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??$?0H@?$SafeInt@K@@QAA@H@Z| PROC	; SafeInt<unsigned long>::SafeInt<unsigned long><int>

; 390  : 	template <typename U> SafeInt(U i)

  00000		 |$LN55@SafeInt@3|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41510|
  00004	e3510000	 cmp         r1, #0

; 391  : 	{
; 392  : 		//use signed-unsigned test on U
; 393  : 		if(SafeInt<U>::IsSigned())
; 394  : 		{
; 395  : 			//U is signed
; 396  : 			//whether T is signed or unsigned, must test range if sizeof T is smaller 
; 397  : 			//than sizeof U
; 398  : 			//if sizeof(T) >= sizeof(U) this optimizes out, only test for negative
; 399  : 			//for completely safe cases, optimizes to NOOP
; 400  : 			if(sizeof(T) < sizeof(U))
; 401  : 			{
; 402  : 				//test size
; 403  : 				if(i > (U)SafeInt<T>::MaxInt() || i < (U)SafeInt<T>::MinInt())
; 404  : 					SafeIntOnOverflow();
; 405  : 			}
; 406  : 			else //test +/- for sizeof(T) >= sizeof(U) and T unsigned
; 407  : 			if(!IsSigned())
; 408  : 			{
; 409  : 				if(i < 0)

  00008	5a000005	 bpl         |$LN6@SafeInt@3|
  0000c	e3a03103	 mov         r3, #3, 2

; 410  : 					SafeIntOnOverflow();

  00010	e3830095	 orr         r0, r3, #0x95
  00014	e3a03000	 mov         r3, #0
  00018	e3a02000	 mov         r2, #0
  0001c	e3a01000	 mov         r1, #0
  00020	eb000000	 bl          RaiseException
  00024		 |$LN56@SafeInt@3|
  00024		 |$LN6@SafeInt@3|

; 411  : 			}
; 412  : 		}
; 413  : 		else
; 414  : 		{
; 415  : 			//U is unsigned
; 416  : 			//if sizeof T <= sizeof U AND T is signed,
; 417  : 			//test upper bound because MaxInt(unsigned) > MaxInt(signed)
; 418  : 			//OR
; 419  : 			//if sizeof T < sizeof U and T is unsigned
; 420  : 			if((IsSigned() && sizeof(T) <= sizeof(U)) ||
; 421  : 			(!IsSigned() && sizeof(T) < sizeof(U)) )
; 422  : 			{
; 423  : 				if(i > (U)MaxInt())
; 424  : 					SafeIntOnOverflow();
; 425  : 			}	
; 426  : 		}
; 427  : 
; 428  : 		m_int = (T)i;

  00024	e5801000	 str         r1, [r0]

; 429  : 	}

  00028	e49de004	 ldr         lr, [sp], #4
  0002c	e12fff1e	 bx          lr
  00030		 |$LN52@SafeInt@3|
  00030		 |$M41511|

			 ENDP  ; |??$?0H@?$SafeInt@K@@QAA@H@Z|, SafeInt<unsigned long>::SafeInt<unsigned long><int>

	EXPORT	|??$?0_J@?$SafeInt@K@@QAA@_J@Z|		; SafeInt<unsigned long>::SafeInt<unsigned long><__int64>

  00000			 AREA	 |.pdata|, PDATA
|$T41597| DCD	|$LN57@SafeInt@4|
	DCD	0x40001502
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??$?0_J@?$SafeInt@K@@QAA@_J@Z| PROC	; SafeInt<unsigned long>::SafeInt<unsigned long><__int64>

; 390  : 	template <typename U> SafeInt(U i)

  00000		 |$LN57@SafeInt@4|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M41594|

; 391  : 	{
; 392  : 		//use signed-unsigned test on U
; 393  : 		if(SafeInt<U>::IsSigned())
; 394  : 		{
; 395  : 			//U is signed
; 396  : 			//whether T is signed or unsigned, must test range if sizeof T is smaller 
; 397  : 			//than sizeof U
; 398  : 			//if sizeof(T) >= sizeof(U) this optimizes out, only test for negative
; 399  : 			//for completely safe cases, optimizes to NOOP
; 400  : 			if(sizeof(T) < sizeof(U))
; 401  : 			{
; 402  : 				//test size
; 403  : 				if(i > (U)SafeInt<T>::MaxInt() || i < (U)SafeInt<T>::MinInt())

  00008	e3520000	 cmp         r2, #0
  0000c	ca00000a	 bgt         |$LN52@SafeInt@4|
  00010	ba000001	 blt         |$LN51@SafeInt@4|
  00014	e3710001	 cmn         r1, #1
  00018	8a000007	 bhi         |$LN52@SafeInt@4|
  0001c		 |$LN51@SafeInt@4|
  0001c	e58d1000	 str         r1, [sp]
  00020	e3520000	 cmp         r2, #0
  00024	ca000000	 bgt         |$LN1@SafeInt@4|
  00028	ba000003	 blt         |$LN52@SafeInt@4|
  0002c		 |$LN1@SafeInt@4|

; 404  : 					SafeIntOnOverflow();
; 405  : 			}
; 406  : 			else //test +/- for sizeof(T) >= sizeof(U) and T unsigned
; 407  : 			if(!IsSigned())
; 408  : 			{
; 409  : 				if(i < 0)
; 410  : 					SafeIntOnOverflow();
; 411  : 			}
; 412  : 		}
; 413  : 		else
; 414  : 		{
; 415  : 			//U is unsigned
; 416  : 			//if sizeof T <= sizeof U AND T is signed,
; 417  : 			//test upper bound because MaxInt(unsigned) > MaxInt(signed)
; 418  : 			//OR
; 419  : 			//if sizeof T < sizeof U and T is unsigned
; 420  : 			if((IsSigned() && sizeof(T) <= sizeof(U)) ||
; 421  : 			(!IsSigned() && sizeof(T) < sizeof(U)) )
; 422  : 			{
; 423  : 				if(i > (U)MaxInt())
; 424  : 					SafeIntOnOverflow();
; 425  : 			}	
; 426  : 		}
; 427  : 
; 428  : 		m_int = (T)i;

  0002c	e5801000	 str         r1, [r0]

; 429  : 	}

  00030	e28dd008	 add         sp, sp, #8
  00034	e49de004	 ldr         lr, [sp], #4
  00038	e12fff1e	 bx          lr
  0003c		 |$LN52@SafeInt@4|
  0003c	e3a03103	 mov         r3, #3, 2
  00040	e3830095	 orr         r0, r3, #0x95
  00044	e3a03000	 mov         r3, #0
  00048	e3a02000	 mov         r2, #0
  0004c	e3a01000	 mov         r1, #0
  00050	eb000000	 bl          RaiseException
  00054		 |$LN58@SafeInt@4|
  00054		 |$LN54@SafeInt@4|
  00054		 |$M41595|

			 ENDP  ; |??$?0_J@?$SafeInt@K@@QAA@_J@Z|, SafeInt<unsigned long>::SafeInt<unsigned long><__int64>

	EXPORT	|??$?0I@?$SafeInt@K@@QAA@I@Z|		; SafeInt<unsigned long>::SafeInt<unsigned long><unsigned int>

  00000			 AREA	 |.pdata|, PDATA
|$T41676| DCD	|$LN53@SafeInt@5|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??$?0I@?$SafeInt@K@@QAA@I@Z| PROC	; SafeInt<unsigned long>::SafeInt<unsigned long><unsigned int>

; 390  : 	template <typename U> SafeInt(U i)

  00000		 |$LN53@SafeInt@5|
  00000		 |$M41673|

; 391  : 	{
; 392  : 		//use signed-unsigned test on U
; 393  : 		if(SafeInt<U>::IsSigned())
; 394  : 		{
; 395  : 			//U is signed
; 396  : 			//whether T is signed or unsigned, must test range if sizeof T is smaller 
; 397  : 			//than sizeof U
; 398  : 			//if sizeof(T) >= sizeof(U) this optimizes out, only test for negative
; 399  : 			//for completely safe cases, optimizes to NOOP
; 400  : 			if(sizeof(T) < sizeof(U))
; 401  : 			{
; 402  : 				//test size
; 403  : 				if(i > (U)SafeInt<T>::MaxInt() || i < (U)SafeInt<T>::MinInt())
; 404  : 					SafeIntOnOverflow();
; 405  : 			}
; 406  : 			else //test +/- for sizeof(T) >= sizeof(U) and T unsigned
; 407  : 			if(!IsSigned())
; 408  : 			{
; 409  : 				if(i < 0)
; 410  : 					SafeIntOnOverflow();
; 411  : 			}
; 412  : 		}
; 413  : 		else
; 414  : 		{
; 415  : 			//U is unsigned
; 416  : 			//if sizeof T <= sizeof U AND T is signed,
; 417  : 			//test upper bound because MaxInt(unsigned) > MaxInt(signed)
; 418  : 			//OR
; 419  : 			//if sizeof T < sizeof U and T is unsigned
; 420  : 			if((IsSigned() && sizeof(T) <= sizeof(U)) ||
; 421  : 			(!IsSigned() && sizeof(T) < sizeof(U)) )
; 422  : 			{
; 423  : 				if(i > (U)MaxInt())
; 424  : 					SafeIntOnOverflow();
; 425  : 			}	
; 426  : 		}
; 427  : 
; 428  : 		m_int = (T)i;

  00000	e5801000	 str         r1, [r0]

; 429  : 	}

  00004	e12fff1e	 bx          lr
  00008		 |$M41674|

			 ENDP  ; |??$?0I@?$SafeInt@K@@QAA@I@Z|, SafeInt<unsigned long>::SafeInt<unsigned long><unsigned int>

	EXPORT	|??$?0_K@?$SafeInt@K@@QAA@_K@Z|		; SafeInt<unsigned long>::SafeInt<unsigned long><unsigned __int64>

  00000			 AREA	 |.pdata|, PDATA
|$T41758| DCD	|$LN56@SafeInt@6|
	DCD	0x40001002
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??$?0_K@?$SafeInt@K@@QAA@_K@Z| PROC	; SafeInt<unsigned long>::SafeInt<unsigned long><unsigned __int64>

; 390  : 	template <typename U> SafeInt(U i)

  00000		 |$LN56@SafeInt@6|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M41755|

; 391  : 	{
; 392  : 		//use signed-unsigned test on U
; 393  : 		if(SafeInt<U>::IsSigned())
; 394  : 		{
; 395  : 			//U is signed
; 396  : 			//whether T is signed or unsigned, must test range if sizeof T is smaller 
; 397  : 			//than sizeof U
; 398  : 			//if sizeof(T) >= sizeof(U) this optimizes out, only test for negative
; 399  : 			//for completely safe cases, optimizes to NOOP
; 400  : 			if(sizeof(T) < sizeof(U))
; 401  : 			{
; 402  : 				//test size
; 403  : 				if(i > (U)SafeInt<T>::MaxInt() || i < (U)SafeInt<T>::MinInt())
; 404  : 					SafeIntOnOverflow();
; 405  : 			}
; 406  : 			else //test +/- for sizeof(T) >= sizeof(U) and T unsigned
; 407  : 			if(!IsSigned())
; 408  : 			{
; 409  : 				if(i < 0)
; 410  : 					SafeIntOnOverflow();
; 411  : 			}
; 412  : 		}
; 413  : 		else
; 414  : 		{
; 415  : 			//U is unsigned
; 416  : 			//if sizeof T <= sizeof U AND T is signed,
; 417  : 			//test upper bound because MaxInt(unsigned) > MaxInt(signed)
; 418  : 			//OR
; 419  : 			//if sizeof T < sizeof U and T is unsigned
; 420  : 			if((IsSigned() && sizeof(T) <= sizeof(U)) ||
; 421  : 			(!IsSigned() && sizeof(T) < sizeof(U)) )
; 422  : 			{
; 423  : 				if(i > (U)MaxInt())

  00008	e1b03002	 movs        r3, r2
  0000c	e58d3004	 str         r3, [sp, #4]
  00010	1a000004	 bne         |$LN51@SafeInt@6|
  00014	e3710001	 cmn         r1, #1

; 424  : 					SafeIntOnOverflow();
; 425  : 			}	
; 426  : 		}
; 427  : 
; 428  : 		m_int = (T)i;

  00018	95801000	 strls       r1, [r0]

; 429  : 	}

  0001c	928dd008	 addls       sp, sp, #8
  00020	949de004	 ldrls       lr, [sp], #4
  00024	912fff1e	 bxls        lr
  00028		 |$LN51@SafeInt@6|
  00028	e3a03103	 mov         r3, #3, 2
  0002c	e3830095	 orr         r0, r3, #0x95
  00030	e3a03000	 mov         r3, #0
  00034	e3a02000	 mov         r2, #0
  00038	e3a01000	 mov         r1, #0
  0003c	eb000000	 bl          RaiseException
  00040		 |$LN57@SafeInt@6|
  00040		 |$LN53@SafeInt@6|
  00040		 |$M41756|

			 ENDP  ; |??$?0_K@?$SafeInt@K@@QAA@_K@Z|, SafeInt<unsigned long>::SafeInt<unsigned long><unsigned __int64>

	EXPORT	|?MaxInt@?$SafeInt@H@@SAHXZ|		; SafeInt<int>::MaxInt

  00000			 AREA	 |.pdata|, PDATA
|$T41774| DCD	|$LN10@MaxInt@2|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?MaxInt@?$SafeInt@H@@SAHXZ| PROC	; SafeInt<int>::MaxInt

; 468  : 	{

  00000		 |$LN10@MaxInt@2|
  00000		 |$M41771|

; 469  : 		if(IsSigned())
; 470  : 		{
; 471  : 			return (T)~((T)1 << (BitCount()-1));

  00000	e3e00102	 mvn         r0, #2, 2

; 472  : 		}
; 473  : 		//else
; 474  : 		return (T)(~(T)0);
; 475  : 	}

  00004	e12fff1e	 bx          lr
  00008		 |$M41772|

			 ENDP  ; |?MaxInt@?$SafeInt@H@@SAHXZ|, SafeInt<int>::MaxInt

	EXPORT	|?MinInt@?$SafeInt@H@@SAHXZ|		; SafeInt<int>::MinInt

  00000			 AREA	 |.pdata|, PDATA
|$T41789| DCD	|$LN11@MinInt@2|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?MinInt@?$SafeInt@H@@SAHXZ| PROC	; SafeInt<int>::MinInt

; 478  : 	{

  00000		 |$LN11@MinInt@2|
  00000		 |$M41786|

; 479  : 		if(IsSigned())
; 480  : 		{
; 481  : 			return (T)((T)1 << (BitCount()-1));

  00000	e3a00102	 mov         r0, #2, 2

; 482  : 		}
; 483  : 		else
; 484  : 		{
; 485  : 			return ((T)0);
; 486  : 		}
; 487  : 	}

  00004	e12fff1e	 bx          lr
  00008		 |$M41787|

			 ENDP  ; |?MinInt@?$SafeInt@H@@SAHXZ|, SafeInt<int>::MinInt

	EXPORT	|?multiply@?$SafeInt@H@@CAHHH@Z|	; SafeInt<int>::multiply

  00000			 AREA	 |.pdata|, PDATA
|$T41978| DCD	|$LN141@multiply@2|
	DCD	0x40001201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?multiply@?$SafeInt@H@@CAHHH@Z| PROC	; SafeInt<int>::multiply

; 1266 : 	{

  00000		 |$LN141@multiply@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41975|

; 1267 : 		if(Is64Bit())
; 1268 : 		{
; 1269 : 			//fast track this one - and avoid DIV_0 below
; 1270 : 			if(lhs == 0 || rhs == 0)
; 1271 : 				return 0;
; 1272 : 
; 1273 : 			//we're 64 bit - slow, but the only way to do it
; 1274 : 			if(IsSigned())
; 1275 : 			{
; 1276 : 				if(!IsMixedSign(lhs, rhs))
; 1277 : 				{
; 1278 : 					//both positive or both negative
; 1279 : 					//result will be positive, check for lhs * rhs > MaxInt
; 1280 : 					if(lhs > 0)
; 1281 : 					{
; 1282 : 						//both positive
; 1283 : 						if(MaxInt()/lhs < rhs)
; 1284 : 						{
; 1285 : 							//overflow
; 1286 : 							SafeIntOnOverflow();
; 1287 : 						}
; 1288 : 					}
; 1289 : 					else
; 1290 : 					{
; 1291 : 						//both negative
; 1292 : 
; 1293 : 						//comparison gets tricky unless we force it to positive
; 1294 : 						//EXCEPT that -MinInt is undefined - can't be done
; 1295 : 						//And MinInt always has a greater magnitude than MaxInt
; 1296 : 						if(lhs == MinInt() || rhs == MinInt())
; 1297 : 						{
; 1298 : 							//overflow
; 1299 : 							SafeIntOnOverflow();
; 1300 : 						}
; 1301 : 
; 1302 : 						if(MaxInt()/(-lhs) < (-rhs) )
; 1303 : 						{
; 1304 : 							//overflow
; 1305 : 							SafeIntOnOverflow();
; 1306 : 						}
; 1307 : 					}
; 1308 : 				}
; 1309 : 				else
; 1310 : 				{
; 1311 : 					//mixed sign - this case is difficult
; 1312 : 					//test case is lhs * rhs < MinInt => overflow
; 1313 : 					//if lhs < 0 (implies rhs > 0), 
; 1314 : 					//lhs < MinInt/rhs is the correct test
; 1315 : 					//else if lhs > 0 
; 1316 : 					//rhs < MinInt/lhs is the correct test
; 1317 : 					//avoid dividing MinInt by a negative number, 
; 1318 : 					//because MinInt/-1 is a corner case
; 1319 : 
; 1320 : 					if(lhs < 0)
; 1321 : 					{
; 1322 : 						if(lhs < MinInt()/rhs)
; 1323 : 						{
; 1324 : 							//overflow
; 1325 : 							SafeIntOnOverflow();
; 1326 : 						}
; 1327 : 					}
; 1328 : 					else
; 1329 : 					{
; 1330 : 						if(rhs < MinInt()/lhs)
; 1331 : 						{
; 1332 : 							//overflow
; 1333 : 							SafeIntOnOverflow();
; 1334 : 						}
; 1335 : 					}
; 1336 : 				}
; 1337 : 
; 1338 : 				//ok
; 1339 : 				return lhs * rhs;
; 1340 : 			}
; 1341 : 			else
; 1342 : 			{
; 1343 : 				//unsigned, easy case
; 1344 : 				if(MaxInt()/lhs < rhs)
; 1345 : 				{
; 1346 : 					//overflow
; 1347 : 					SafeIntOnOverflow();
; 1348 : 				}
; 1349 : 				//ok
; 1350 : 				return lhs * rhs;
; 1351 : 			}
; 1352 : 		}
; 1353 : 		else if(Is32Bit())
; 1354 : 		{
; 1355 : 			//we're 32-bit
; 1356 : 			if(IsSigned())
; 1357 : 			{
; 1358 : 				signed _int64 tmp = (signed _int64)lhs * (signed _int64)rhs;

  00004	e0c12190	 smull       r2, r1, r0, r1

; 1359 : 
; 1360 : 				//upper 33 bits must be the same
; 1361 : 				//most common case is likely that both are positive - test first
; 1362 : 				if( (tmp & 0xffffffff80000000LL) == 0 || 
; 1363 : 					(tmp & 0xffffffff80000000LL) == 0xffffffff80000000LL)

  00008	e2020102	 and         r0, r2, #2, 2
  0000c	e1903001	 orrs        r3, r0, r1
  00010	0a000009	 beq         |$LN16@multiply@2|
  00014	e3500102	 cmp         r0, #2, 2
  00018	1a000001	 bne         |$LN136@multiply@2|
  0001c	e3710001	 cmn         r1, #1
  00020	0a000005	 beq         |$LN16@multiply@2|
  00024		 |$LN136@multiply@2|
  00024	e3a03103	 mov         r3, #3, 2

; 1364 : 				{
; 1365 : 					//this is OK
; 1366 : 					return (T)tmp;
; 1367 : 				}
; 1368 : 
; 1369 : 				//overflow
; 1370 : 				SafeIntOnOverflow();

  00028	e3830095	 orr         r0, r3, #0x95
  0002c	e3a03000	 mov         r3, #0
  00030	e3a02000	 mov         r2, #0
  00034	e3a01000	 mov         r1, #0
  00038	eb000000	 bl          RaiseException
  0003c		 |$LN142@multiply@2|
  0003c		 |$LN16@multiply@2|

; 1371 : 				
; 1372 : 			}
; 1373 : 			else
; 1374 : 			{
; 1375 : 				unsigned _int64 tmp = (unsigned _int64)lhs * (unsigned _int64)rhs;
; 1376 : 				if (tmp & 0xffffffff00000000ULL) //overflow
; 1377 : 				{
; 1378 : 					//overflow
; 1379 : 					SafeIntOnOverflow();
; 1380 : 				}
; 1381 : 				return (T)tmp;
; 1382 : 			}
; 1383 : 		}
; 1384 : 		else if(Is16Bit())
; 1385 : 		{
; 1386 : 			//16-bit
; 1387 : 			if(IsSigned())
; 1388 : 			{
; 1389 : 				signed _int32 tmp = (signed _int32)lhs * (signed _int32)rhs;
; 1390 : 				//upper 17 bits must be the same
; 1391 : 				//most common case is likely that both are positive - test first
; 1392 : 				if( (tmp & 0xffff8000) == 0 || (tmp & 0xffff8000) == 0xffff8000)
; 1393 : 				{
; 1394 : 					//this is OK
; 1395 : 					return (T)tmp;
; 1396 : 				}
; 1397 : 
; 1398 : 				//overflow
; 1399 : 				SafeIntOnOverflow();
; 1400 : 			}
; 1401 : 			else
; 1402 : 			{
; 1403 : 				unsigned _int32 tmp = (unsigned _int32)lhs * (unsigned _int32)rhs;
; 1404 : 				if (tmp & 0xffff0000) //overflow
; 1405 : 				{
; 1406 : 					SafeIntOnOverflow();
; 1407 : 				}
; 1408 : 				return (T)tmp;
; 1409 : 			}
; 1410 : 		}
; 1411 : 		else //8-bit
; 1412 : 		{
; 1413 : 			assert(Is8Bit());
; 1414 : 
; 1415 : 			if(IsSigned())
; 1416 : 			{
; 1417 : 				signed _int16 tmp = (signed _int16)lhs * (signed _int16)rhs;
; 1418 : 				//upper 9 bits must be the same
; 1419 : 				//most common case is likely that both are positive - test first
; 1420 : 				if( (tmp & 0xff80) == 0 || (tmp & 0xff80) == 0xff80)
; 1421 : 				{
; 1422 : 					//this is OK
; 1423 : 					return (T)tmp;
; 1424 : 				}
; 1425 : 
; 1426 : 				//overflow
; 1427 : 				SafeIntOnOverflow();
; 1428 : 			}
; 1429 : 			else
; 1430 : 			{
; 1431 : 				unsigned _int16 tmp = ((unsigned _int16)lhs) * ((unsigned _int16)rhs);
; 1432 : 
; 1433 : 				if (tmp & 0xff00) //overflow
; 1434 : 				{
; 1435 : 					SafeIntOnOverflow();
; 1436 : 				}
; 1437 : 				return (T)tmp;
; 1438 : 			}
; 1439 : 		}
; 1440 : 	}

  0003c	e1a00002	 mov         r0, r2
  00040	e49de004	 ldr         lr, [sp], #4
  00044	e12fff1e	 bx          lr
  00048		 |$LN138@multiply@2|
  00048		 |$M41976|

			 ENDP  ; |?multiply@?$SafeInt@H@@CAHHH@Z|, SafeInt<int>::multiply

	EXPORT	|??$?0K@?$SafeInt@H@@QAA@K@Z|		; SafeInt<int>::SafeInt<int><unsigned long>

  00000			 AREA	 |.pdata|, PDATA
|$T42059| DCD	|$LN55@SafeInt@7|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??$?0K@?$SafeInt@H@@QAA@K@Z| PROC	; SafeInt<int>::SafeInt<int><unsigned long>

; 390  : 	template <typename U> SafeInt(U i)

  00000		 |$LN55@SafeInt@7|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42056|

; 391  : 	{
; 392  : 		//use signed-unsigned test on U
; 393  : 		if(SafeInt<U>::IsSigned())
; 394  : 		{
; 395  : 			//U is signed
; 396  : 			//whether T is signed or unsigned, must test range if sizeof T is smaller 
; 397  : 			//than sizeof U
; 398  : 			//if sizeof(T) >= sizeof(U) this optimizes out, only test for negative
; 399  : 			//for completely safe cases, optimizes to NOOP
; 400  : 			if(sizeof(T) < sizeof(U))
; 401  : 			{
; 402  : 				//test size
; 403  : 				if(i > (U)SafeInt<T>::MaxInt() || i < (U)SafeInt<T>::MinInt())
; 404  : 					SafeIntOnOverflow();
; 405  : 			}
; 406  : 			else //test +/- for sizeof(T) >= sizeof(U) and T unsigned
; 407  : 			if(!IsSigned())
; 408  : 			{
; 409  : 				if(i < 0)
; 410  : 					SafeIntOnOverflow();
; 411  : 			}
; 412  : 		}
; 413  : 		else
; 414  : 		{
; 415  : 			//U is unsigned
; 416  : 			//if sizeof T <= sizeof U AND T is signed,
; 417  : 			//test upper bound because MaxInt(unsigned) > MaxInt(signed)
; 418  : 			//OR
; 419  : 			//if sizeof T < sizeof U and T is unsigned
; 420  : 			if((IsSigned() && sizeof(T) <= sizeof(U)) ||
; 421  : 			(!IsSigned() && sizeof(T) < sizeof(U)) )
; 422  : 			{
; 423  : 				if(i > (U)MaxInt())

  00004	e3710106	 cmn         r1, #6, 2
  00008	9a000005	 bls         |$LN2@SafeInt@7|
  0000c	e3a03103	 mov         r3, #3, 2

; 424  : 					SafeIntOnOverflow();

  00010	e3830095	 orr         r0, r3, #0x95
  00014	e3a03000	 mov         r3, #0
  00018	e3a02000	 mov         r2, #0
  0001c	e3a01000	 mov         r1, #0
  00020	eb000000	 bl          RaiseException
  00024		 |$LN56@SafeInt@7|
  00024		 |$LN2@SafeInt@7|

; 425  : 			}	
; 426  : 		}
; 427  : 
; 428  : 		m_int = (T)i;

  00024	e5801000	 str         r1, [r0]

; 429  : 	}

  00028	e49de004	 ldr         lr, [sp], #4
  0002c	e12fff1e	 bx          lr
  00030		 |$LN52@SafeInt@7|
  00030		 |$M42057|

			 ENDP  ; |??$?0K@?$SafeInt@H@@QAA@K@Z|, SafeInt<int>::SafeInt<int><unsigned long>

	EXPORT	|??$?0_J@?$SafeInt@H@@QAA@_J@Z|		; SafeInt<int>::SafeInt<int><__int64>

  00000			 AREA	 |.pdata|, PDATA
|$T42143| DCD	|$LN57@SafeInt@8|
	DCD	0x40001401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??$?0_J@?$SafeInt@H@@QAA@_J@Z| PROC	; SafeInt<int>::SafeInt<int><__int64>

; 390  : 	template <typename U> SafeInt(U i)

  00000		 |$LN57@SafeInt@8|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42140|

; 391  : 	{
; 392  : 		//use signed-unsigned test on U
; 393  : 		if(SafeInt<U>::IsSigned())
; 394  : 		{
; 395  : 			//U is signed
; 396  : 			//whether T is signed or unsigned, must test range if sizeof T is smaller 
; 397  : 			//than sizeof U
; 398  : 			//if sizeof(T) >= sizeof(U) this optimizes out, only test for negative
; 399  : 			//for completely safe cases, optimizes to NOOP
; 400  : 			if(sizeof(T) < sizeof(U))
; 401  : 			{
; 402  : 				//test size
; 403  : 				if(i > (U)SafeInt<T>::MaxInt() || i < (U)SafeInt<T>::MinInt())

  00004	e3520000	 cmp         r2, #0
  00008	ca00000a	 bgt         |$LN52@SafeInt@8|
  0000c	ba000001	 blt         |$LN51@SafeInt@8|
  00010	e3710106	 cmn         r1, #6, 2
  00014	8a000007	 bhi         |$LN52@SafeInt@8|
  00018		 |$LN51@SafeInt@8|
  00018	e3720001	 cmn         r2, #1
  0001c	ca000002	 bgt         |$LN1@SafeInt@8|
  00020	ba000004	 blt         |$LN52@SafeInt@8|
  00024	e3510102	 cmp         r1, #2, 2
  00028	3a000002	 bcc         |$LN52@SafeInt@8|
  0002c		 |$LN1@SafeInt@8|

; 404  : 					SafeIntOnOverflow();
; 405  : 			}
; 406  : 			else //test +/- for sizeof(T) >= sizeof(U) and T unsigned
; 407  : 			if(!IsSigned())
; 408  : 			{
; 409  : 				if(i < 0)
; 410  : 					SafeIntOnOverflow();
; 411  : 			}
; 412  : 		}
; 413  : 		else
; 414  : 		{
; 415  : 			//U is unsigned
; 416  : 			//if sizeof T <= sizeof U AND T is signed,
; 417  : 			//test upper bound because MaxInt(unsigned) > MaxInt(signed)
; 418  : 			//OR
; 419  : 			//if sizeof T < sizeof U and T is unsigned
; 420  : 			if((IsSigned() && sizeof(T) <= sizeof(U)) ||
; 421  : 			(!IsSigned() && sizeof(T) < sizeof(U)) )
; 422  : 			{
; 423  : 				if(i > (U)MaxInt())
; 424  : 					SafeIntOnOverflow();
; 425  : 			}	
; 426  : 		}
; 427  : 
; 428  : 		m_int = (T)i;

  0002c	e5801000	 str         r1, [r0]

; 429  : 	}

  00030	e49de004	 ldr         lr, [sp], #4
  00034	e12fff1e	 bx          lr
  00038		 |$LN52@SafeInt@8|
  00038	e3a03103	 mov         r3, #3, 2
  0003c	e3830095	 orr         r0, r3, #0x95
  00040	e3a03000	 mov         r3, #0
  00044	e3a02000	 mov         r2, #0
  00048	e3a01000	 mov         r1, #0
  0004c	eb000000	 bl          RaiseException
  00050		 |$LN58@SafeInt@8|
  00050		 |$LN54@SafeInt@8|
  00050		 |$M42141|

			 ENDP  ; |??$?0_J@?$SafeInt@H@@QAA@_J@Z|, SafeInt<int>::SafeInt<int><__int64>

	EXPORT	|??$?0I@?$SafeInt@H@@QAA@I@Z|		; SafeInt<int>::SafeInt<int><unsigned int>

  00000			 AREA	 |.pdata|, PDATA
|$T42224| DCD	|$LN55@SafeInt@9|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??$?0I@?$SafeInt@H@@QAA@I@Z| PROC	; SafeInt<int>::SafeInt<int><unsigned int>

; 390  : 	template <typename U> SafeInt(U i)

  00000		 |$LN55@SafeInt@9|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42221|

; 391  : 	{
; 392  : 		//use signed-unsigned test on U
; 393  : 		if(SafeInt<U>::IsSigned())
; 394  : 		{
; 395  : 			//U is signed
; 396  : 			//whether T is signed or unsigned, must test range if sizeof T is smaller 
; 397  : 			//than sizeof U
; 398  : 			//if sizeof(T) >= sizeof(U) this optimizes out, only test for negative
; 399  : 			//for completely safe cases, optimizes to NOOP
; 400  : 			if(sizeof(T) < sizeof(U))
; 401  : 			{
; 402  : 				//test size
; 403  : 				if(i > (U)SafeInt<T>::MaxInt() || i < (U)SafeInt<T>::MinInt())
; 404  : 					SafeIntOnOverflow();
; 405  : 			}
; 406  : 			else //test +/- for sizeof(T) >= sizeof(U) and T unsigned
; 407  : 			if(!IsSigned())
; 408  : 			{
; 409  : 				if(i < 0)
; 410  : 					SafeIntOnOverflow();
; 411  : 			}
; 412  : 		}
; 413  : 		else
; 414  : 		{
; 415  : 			//U is unsigned
; 416  : 			//if sizeof T <= sizeof U AND T is signed,
; 417  : 			//test upper bound because MaxInt(unsigned) > MaxInt(signed)
; 418  : 			//OR
; 419  : 			//if sizeof T < sizeof U and T is unsigned
; 420  : 			if((IsSigned() && sizeof(T) <= sizeof(U)) ||
; 421  : 			(!IsSigned() && sizeof(T) < sizeof(U)) )
; 422  : 			{
; 423  : 				if(i > (U)MaxInt())

  00004	e3710106	 cmn         r1, #6, 2
  00008	9a000005	 bls         |$LN2@SafeInt@9|
  0000c	e3a03103	 mov         r3, #3, 2

; 424  : 					SafeIntOnOverflow();

  00010	e3830095	 orr         r0, r3, #0x95
  00014	e3a03000	 mov         r3, #0
  00018	e3a02000	 mov         r2, #0
  0001c	e3a01000	 mov         r1, #0
  00020	eb000000	 bl          RaiseException
  00024		 |$LN56@SafeInt@9|
  00024		 |$LN2@SafeInt@9|

; 425  : 			}	
; 426  : 		}
; 427  : 
; 428  : 		m_int = (T)i;

  00024	e5801000	 str         r1, [r0]

; 429  : 	}

  00028	e49de004	 ldr         lr, [sp], #4
  0002c	e12fff1e	 bx          lr
  00030		 |$LN52@SafeInt@9|
  00030		 |$M42222|

			 ENDP  ; |??$?0I@?$SafeInt@H@@QAA@I@Z|, SafeInt<int>::SafeInt<int><unsigned int>

	EXPORT	|??$?0_K@?$SafeInt@H@@QAA@_K@Z|		; SafeInt<int>::SafeInt<int><unsigned __int64>

  00000			 AREA	 |.pdata|, PDATA
|$T42307| DCD	|$LN56@SafeInt@10|
	DCD	0x40001002
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??$?0_K@?$SafeInt@H@@QAA@_K@Z| PROC	; SafeInt<int>::SafeInt<int><unsigned __int64>

; 390  : 	template <typename U> SafeInt(U i)

  00000		 |$LN56@SafeInt@10|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M42304|

; 391  : 	{
; 392  : 		//use signed-unsigned test on U
; 393  : 		if(SafeInt<U>::IsSigned())
; 394  : 		{
; 395  : 			//U is signed
; 396  : 			//whether T is signed or unsigned, must test range if sizeof T is smaller 
; 397  : 			//than sizeof U
; 398  : 			//if sizeof(T) >= sizeof(U) this optimizes out, only test for negative
; 399  : 			//for completely safe cases, optimizes to NOOP
; 400  : 			if(sizeof(T) < sizeof(U))
; 401  : 			{
; 402  : 				//test size
; 403  : 				if(i > (U)SafeInt<T>::MaxInt() || i < (U)SafeInt<T>::MinInt())
; 404  : 					SafeIntOnOverflow();
; 405  : 			}
; 406  : 			else //test +/- for sizeof(T) >= sizeof(U) and T unsigned
; 407  : 			if(!IsSigned())
; 408  : 			{
; 409  : 				if(i < 0)
; 410  : 					SafeIntOnOverflow();
; 411  : 			}
; 412  : 		}
; 413  : 		else
; 414  : 		{
; 415  : 			//U is unsigned
; 416  : 			//if sizeof T <= sizeof U AND T is signed,
; 417  : 			//test upper bound because MaxInt(unsigned) > MaxInt(signed)
; 418  : 			//OR
; 419  : 			//if sizeof T < sizeof U and T is unsigned
; 420  : 			if((IsSigned() && sizeof(T) <= sizeof(U)) ||
; 421  : 			(!IsSigned() && sizeof(T) < sizeof(U)) )
; 422  : 			{
; 423  : 				if(i > (U)MaxInt())

  00008	e1b03002	 movs        r3, r2
  0000c	e58d3004	 str         r3, [sp, #4]
  00010	1a000004	 bne         |$LN51@SafeInt@10|
  00014	e3710106	 cmn         r1, #6, 2

; 424  : 					SafeIntOnOverflow();
; 425  : 			}	
; 426  : 		}
; 427  : 
; 428  : 		m_int = (T)i;

  00018	95801000	 strls       r1, [r0]

; 429  : 	}

  0001c	928dd008	 addls       sp, sp, #8
  00020	949de004	 ldrls       lr, [sp], #4
  00024	912fff1e	 bxls        lr
  00028		 |$LN51@SafeInt@10|
  00028	e3a03103	 mov         r3, #3, 2
  0002c	e3830095	 orr         r0, r3, #0x95
  00030	e3a03000	 mov         r3, #0
  00034	e3a02000	 mov         r2, #0
  00038	e3a01000	 mov         r1, #0
  0003c	eb000000	 bl          RaiseException
  00040		 |$LN57@SafeInt@10|
  00040		 |$LN53@SafeInt@10|
  00040		 |$M42305|

			 ENDP  ; |??$?0_K@?$SafeInt@H@@QAA@_K@Z|, SafeInt<int>::SafeInt<int><unsigned __int64>

	EXPORT	|??H?$SafeInt@K@@QBA?AV0@V0@@Z|		; SafeInt<unsigned long>::operator+

  00000			 AREA	 |.pdata|, PDATA
|$T42393| DCD	|$LN39@operator@4|
	DCD	0x40000f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??H?$SafeInt@K@@QBA?AV0@V0@@Z| PROC	; SafeInt<unsigned long>::operator+

; 799  : 	{

  00000		 |$LN39@operator@4|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42390|

; 800  : 		return SafeInt<T>(addition(m_int, rhs.Value()));

  00004	e5903000	 ldr         r3, [r0]
  00008	e0832002	 add         r2, r3, r2
  0000c	e1530002	 cmp         r3, r2
  00010	9a000005	 bls         |$LN5@operator@4|
  00014	e3a03103	 mov         r3, #3, 2
  00018	e3830095	 orr         r0, r3, #0x95
  0001c	e3a03000	 mov         r3, #0
  00020	e3a02000	 mov         r2, #0
  00024	e3a01000	 mov         r1, #0
  00028	eb000000	 bl          RaiseException
  0002c		 |$LN40@operator@4|
  0002c		 |$LN5@operator@4|
  0002c	e5812000	 str         r2, [r1]

; 801  : 	}

  00030	e1a00001	 mov         r0, r1
  00034	e49de004	 ldr         lr, [sp], #4
  00038	e12fff1e	 bx          lr
  0003c		 |$LN36@operator@4|
  0003c		 |$M42391|

			 ENDP  ; |??H?$SafeInt@K@@QBA?AV0@V0@@Z|, SafeInt<unsigned long>::operator+

	EXPORT	|??$?0E@?$SafeInt@K@@QAA@E@Z|		; SafeInt<unsigned long>::SafeInt<unsigned long><unsigned char>

  00000			 AREA	 |.pdata|, PDATA
|$T42472| DCD	|$LN53@SafeInt@11|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??$?0E@?$SafeInt@K@@QAA@E@Z| PROC	; SafeInt<unsigned long>::SafeInt<unsigned long><unsigned char>

; 390  : 	template <typename U> SafeInt(U i)

  00000		 |$LN53@SafeInt@11|
  00000		 |$M42469|

; 391  : 	{
; 392  : 		//use signed-unsigned test on U
; 393  : 		if(SafeInt<U>::IsSigned())
; 394  : 		{
; 395  : 			//U is signed
; 396  : 			//whether T is signed or unsigned, must test range if sizeof T is smaller 
; 397  : 			//than sizeof U
; 398  : 			//if sizeof(T) >= sizeof(U) this optimizes out, only test for negative
; 399  : 			//for completely safe cases, optimizes to NOOP
; 400  : 			if(sizeof(T) < sizeof(U))
; 401  : 			{
; 402  : 				//test size
; 403  : 				if(i > (U)SafeInt<T>::MaxInt() || i < (U)SafeInt<T>::MinInt())
; 404  : 					SafeIntOnOverflow();
; 405  : 			}
; 406  : 			else //test +/- for sizeof(T) >= sizeof(U) and T unsigned
; 407  : 			if(!IsSigned())
; 408  : 			{
; 409  : 				if(i < 0)
; 410  : 					SafeIntOnOverflow();
; 411  : 			}
; 412  : 		}
; 413  : 		else
; 414  : 		{
; 415  : 			//U is unsigned
; 416  : 			//if sizeof T <= sizeof U AND T is signed,
; 417  : 			//test upper bound because MaxInt(unsigned) > MaxInt(signed)
; 418  : 			//OR
; 419  : 			//if sizeof T < sizeof U and T is unsigned
; 420  : 			if((IsSigned() && sizeof(T) <= sizeof(U)) ||
; 421  : 			(!IsSigned() && sizeof(T) < sizeof(U)) )
; 422  : 			{
; 423  : 				if(i > (U)MaxInt())
; 424  : 					SafeIntOnOverflow();
; 425  : 			}	
; 426  : 		}
; 427  : 
; 428  : 		m_int = (T)i;

  00000	e5801000	 str         r1, [r0]

; 429  : 	}

  00004	e12fff1e	 bx          lr
  00008		 |$M42470|

			 ENDP  ; |??$?0E@?$SafeInt@K@@QAA@E@Z|, SafeInt<unsigned long>::SafeInt<unsigned long><unsigned char>

	EXPORT	|??$MixedSizeMultiply@K@?$SafeInt@H@@CA?AV0@V0@K@Z| ; SafeInt<int>::MixedSizeMultiply<unsigned long>

  00000			 AREA	 |.pdata|, PDATA
|$T43022| DCD	|$LN273@MixedSizeM|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??$MixedSizeMultiply@K@?$SafeInt@H@@CA?AV0@V0@K@Z| PROC ; SafeInt<int>::MixedSizeMultiply<unsigned long>

; 1993 : 	static SafeInt<T> MixedSizeMultiply(SafeInt<T> lhs, U rhs)

  00000		 |$LN273@MixedSizeM|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M43019|
  00004	e1a03001	 mov         r3, r1
  00008	e1a04000	 mov         r4, r0

; 1994 : 	{
; 1995 : 		//what is U?
; 1996 : 		//if T is unsigned, and sizeof(T) >= sizeof(U)
; 1997 : 		//T can hold all values of U for rhs > 0
; 1998 : 		//if T is unsigned and sizeof(T) < sizeof(U)
; 1999 : 		//declare an unsigned SafeInt of same size as U
; 2000 : 
; 2001 : 		//if T is signed and sizeof(T) > sizeof(U)
; 2002 : 		//T can hold all values of U
; 2003 : 		//if T is signed and sizeof(T) <= sizeof(U)
; 2004 : 		//declare a signed SafeInt of same size as U
; 2005 : 
; 2006 : 		if(SafeInt<T>::IsSigned() == SafeInt<U>::IsSigned())
; 2007 : 		{
; 2008 : 			//simple case - same signedness and U always fits in T
; 2009 : 			if(sizeof(T) >= sizeof(U))
; 2010 : 			{
; 2011 : 				return SafeInt<T>(multiply(lhs.Value(), (T)rhs));
; 2012 : 			}
; 2013 : 
; 2014 : 			//simple case - same signedness and U bigger than T
; 2015 : 			//looks like a lot of code, but is compile-time constants
; 2016 : 			//must handle signed and unsigned in different cases - unless sizeof(U) == 8
; 2017 : 
; 2018 : 			if(sizeof(U) == 8)
; 2019 : 			{
; 2020 : 				SafeInt<U> u(rhs);
; 2021 : 				u *= lhs.m_int;
; 2022 : 				return SafeInt<T>(u.Value());
; 2023 : 			}
; 2024 : 
; 2025 : 			if(SafeInt<T>::IsSigned())
; 2026 : 			{
; 2027 : 				if(sizeof(U) < 4)
; 2028 : 				{
; 2029 : 					//the result must always fit into an int
; 2030 : 					return SafeInt<T>((_int32)((_int32)lhs.m_int * (_int32)rhs));
; 2031 : 				}
; 2032 : 
; 2033 : 				//result must fit into an _int64
; 2034 : 				return SafeInt<T>((_int64)((_int64)lhs.m_int * (_int64)rhs));
; 2035 : 			}
; 2036 : 
; 2037 : 			//else unsigned
; 2038 : 			if(sizeof(U) < 4)
; 2039 : 			{
; 2040 : 				//the result must always fit into an int
; 2041 : 				return SafeInt<T>((unsigned _int32)((unsigned _int32)lhs.m_int * (unsigned _int32)rhs));
; 2042 : 			}
; 2043 : 
; 2044 : 			//result must fit into an _int64
; 2045 : 			return SafeInt<T>((unsigned _int64)((unsigned _int64)lhs.m_int * (unsigned _int64)rhs));
; 2046 : 		}
; 2047 : 
; 2048 : 		//mixed sign - consider T is signed, U unsigned
; 2049 : 		if(SafeInt<T>::IsSigned() && !SafeInt<U>::IsSigned())
; 2050 : 		{
; 2051 : 			//if T > U, we're OK
; 2052 : 			if(sizeof(T) > sizeof(U))
; 2053 : 			{
; 2054 : 				return SafeInt<T>(multiply(lhs.Value(), (T)rhs));
; 2055 : 			}
; 2056 : 
; 2057 : 			//else sizeof(T) <= sizeof(U) - upcast T to signed U
; 2058 : 			//otherwise, we have to make an signed next size up from U
; 2059 : 			if(sizeof(U) < 4)
; 2060 : 			{
; 2061 : 				//T is a signed char or _int16, U is unsigned _int16 or char
; 2062 : 				//this must also always fit into an int
; 2063 : 				return SafeInt<T>((_int32)((_int32)lhs.m_int * (_int32)rhs));
; 2064 : 			}
; 2065 : 			else if(sizeof(U) == 4)
; 2066 : 			{
; 2067 : 				//T is signed int or smaller, U is unsigned int
; 2068 : 				//result must fit into an _int64
; 2069 : 				return SafeInt<T>((_int64)((_int64)lhs.m_int * (_int64)rhs));

  0000c	e08e1293	 umull       r1, lr, r3, r2
  00010	e1a03fc3	 mov         r3, r3, asr #31
  00014	e022e293	 mla         r2, r3, r2, lr
  00018	eb000000	 bl          |??$?0_J@?$SafeInt@H@@QAA@_J@Z|

; 2070 : 			}
; 2071 : 			else
; 2072 : 			{
; 2073 : 				//U is unsigned 64-bit
; 2074 : 
; 2075 : 				//now if rhs > MaxInt(T), overflow unless lhs == 0
; 2076 : 				//or the corner case
; 2077 : 				if(rhs > (U)SafeInt<T>::MaxInt())
; 2078 : 				{
; 2079 : 					//corner case -1 * (MaxInt + 1) = MinInt
; 2080 : 					//do lhs comparison first, since is cheaper than 64-bit test
; 2081 : 					if(lhs.Value() == -1 && ((U)SafeInt<T>::MaxInt()+1) == rhs)
; 2082 : 						return SafeInt<T>(SafeInt<T>::MinInt());
; 2083 : 
; 2084 : 					if(lhs.Value() == 0)
; 2085 : 						return SafeInt<T>(0);
; 2086 : 
; 2087 : 					SafeIntOnOverflow();
; 2088 : 				}
; 2089 : 
; 2090 : 				//now rhs must fit into T
; 2091 : 				return SafeInt<T>(multiply(lhs.Value(), (T)rhs));
; 2092 : 			}
; 2093 : 		}
; 2094 : 
; 2095 : 		//now mixed sign where T is unsigned, U signed
; 2096 : 			
; 2097 : 		//negative numbers are always bad
; 2098 : 		//test here to avoid having to test in constructors below
; 2099 : 		//also allows some simplifying assumptions
; 2100 : 		if(rhs < 0)
; 2101 : 			SafeIntOnOverflow();
; 2102 : 
; 2103 : 		if(sizeof(T) >= sizeof(U))
; 2104 : 		{
; 2105 : 			return SafeInt<T>(multiply(lhs.Value(), (T)rhs));
; 2106 : 		}
; 2107 : 
; 2108 : 		//U > T
; 2109 : 		//else there is no corner case, but we do have to check overflow
; 2110 : 		if(sizeof(U) < 4)
; 2111 : 		{
; 2112 : 			//both U and T can be contained in an unsigned int
; 2113 : 			return SafeInt<T>((unsigned _int32)((unsigned _int32)lhs.m_int * (unsigned _int32)rhs));
; 2114 : 		}
; 2115 : 		else if(sizeof(U) == 4)
; 2116 : 		{
; 2117 : 			//now go up to 64-bit
; 2118 : 			return SafeInt<T>((unsigned _int64)((unsigned _int64)lhs.m_int * (unsigned _int64)rhs));
; 2119 : 		}
; 2120 : 		else
; 2121 : 		{
; 2122 : 			//U = signed _int64, T = unsigned [char|_int16|int]
; 2123 : 			SafeInt<U> u(rhs);
; 2124 : 			u *= lhs.Value();
; 2125 : 
; 2126 : 			//now bounds check
; 2127 : 			if(u.Value() > (U)SafeInt<T>::MaxInt())
; 2128 : 				SafeIntOnOverflow();
; 2129 : 
; 2130 : 			//it has to be safe, since rhs is non-negative
; 2131 : 			return SafeInt<T>((T)u.Value());
; 2132 : 		}
; 2133 : 	}

  0001c	e1a00004	 mov         r0, r4
  00020	e8bd4010	 ldmia       sp!, {r4, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M43020|

			 ENDP  ; |??$MixedSizeMultiply@K@?$SafeInt@H@@CA?AV0@V0@K@Z|, SafeInt<int>::MixedSizeMultiply<unsigned long>

	EXPORT	|??$?XK@?$SafeInt@H@@QAAAAV0@K@Z|	; SafeInt<int>::operator*=<unsigned long>

  00000			 AREA	 |.pdata|, PDATA
|$T43852| DCD	|$LN278@operator@5|
	DCD	0x40001002
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??$?XK@?$SafeInt@H@@QAAAAV0@K@Z| PROC	; SafeInt<int>::operator*=<unsigned long>

; 751  : 	SafeInt<T>& operator *=(U rhs)

  00000		 |$LN278@operator@5|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M43849|
  00008	e1a0e001	 mov         lr, r1
  0000c	e1a04000	 mov         r4, r0

; 752  : 	{
; 753  : 		*this = MixedSizeMultiply(*this, rhs);

  00010	e5943000	 ldr         r3, [r4]
  00014	e28d0000	 add         r0, sp, #0
  00018	e0821e93	 umull       r1, r2, r3, lr
  0001c	e1a03fc3	 mov         r3, r3, asr #31
  00020	e0222e93	 mla         r2, r3, lr, r2
  00024	eb000000	 bl          |??$?0_J@?$SafeInt@H@@QAA@_J@Z|

; 754  : 		return *this;
; 755  : 	}

  00028	e59d3000	 ldr         r3, [sp]
  0002c	e1a00004	 mov         r0, r4
  00030	e5843000	 str         r3, [r4]
  00034	e28dd004	 add         sp, sp, #4
  00038	e8bd4010	 ldmia       sp!, {r4, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$M43850|

			 ENDP  ; |??$?XK@?$SafeInt@H@@QAAAAV0@K@Z|, SafeInt<int>::operator*=<unsigned long>

	EXPORT	|??$MixedSizeMultiply@H@?$SafeInt@K@@CA?AV0@V0@H@Z| ; SafeInt<unsigned long>::MixedSizeMultiply<int>

  00000			 AREA	 |.pdata|, PDATA
|$T45995| DCD	|$LN951@MixedSizeM@2|
	DCD	0x40001501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??$MixedSizeMultiply@H@?$SafeInt@K@@CA?AV0@V0@H@Z| PROC ; SafeInt<unsigned long>::MixedSizeMultiply<int>

; 1993 : 	static SafeInt<T> MixedSizeMultiply(SafeInt<T> lhs, U rhs)

  00000		 |$LN951@MixedSizeM@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45992|
  00004	e3520000	 cmp         r2, #0

; 1994 : 	{
; 1995 : 		//what is U?
; 1996 : 		//if T is unsigned, and sizeof(T) >= sizeof(U)
; 1997 : 		//T can hold all values of U for rhs > 0
; 1998 : 		//if T is unsigned and sizeof(T) < sizeof(U)
; 1999 : 		//declare an unsigned SafeInt of same size as U
; 2000 : 
; 2001 : 		//if T is signed and sizeof(T) > sizeof(U)
; 2002 : 		//T can hold all values of U
; 2003 : 		//if T is signed and sizeof(T) <= sizeof(U)
; 2004 : 		//declare a signed SafeInt of same size as U
; 2005 : 
; 2006 : 		if(SafeInt<T>::IsSigned() == SafeInt<U>::IsSigned())
; 2007 : 		{
; 2008 : 			//simple case - same signedness and U always fits in T
; 2009 : 			if(sizeof(T) >= sizeof(U))
; 2010 : 			{
; 2011 : 				return SafeInt<T>(multiply(lhs.Value(), (T)rhs));
; 2012 : 			}
; 2013 : 
; 2014 : 			//simple case - same signedness and U bigger than T
; 2015 : 			//looks like a lot of code, but is compile-time constants
; 2016 : 			//must handle signed and unsigned in different cases - unless sizeof(U) == 8
; 2017 : 
; 2018 : 			if(sizeof(U) == 8)
; 2019 : 			{
; 2020 : 				SafeInt<U> u(rhs);
; 2021 : 				u *= lhs.m_int;
; 2022 : 				return SafeInt<T>(u.Value());
; 2023 : 			}
; 2024 : 
; 2025 : 			if(SafeInt<T>::IsSigned())
; 2026 : 			{
; 2027 : 				if(sizeof(U) < 4)
; 2028 : 				{
; 2029 : 					//the result must always fit into an int
; 2030 : 					return SafeInt<T>((_int32)((_int32)lhs.m_int * (_int32)rhs));
; 2031 : 				}
; 2032 : 
; 2033 : 				//result must fit into an _int64
; 2034 : 				return SafeInt<T>((_int64)((_int64)lhs.m_int * (_int64)rhs));
; 2035 : 			}
; 2036 : 
; 2037 : 			//else unsigned
; 2038 : 			if(sizeof(U) < 4)
; 2039 : 			{
; 2040 : 				//the result must always fit into an int
; 2041 : 				return SafeInt<T>((unsigned _int32)((unsigned _int32)lhs.m_int * (unsigned _int32)rhs));
; 2042 : 			}
; 2043 : 
; 2044 : 			//result must fit into an _int64
; 2045 : 			return SafeInt<T>((unsigned _int64)((unsigned _int64)lhs.m_int * (unsigned _int64)rhs));
; 2046 : 		}
; 2047 : 
; 2048 : 		//mixed sign - consider T is signed, U unsigned
; 2049 : 		if(SafeInt<T>::IsSigned() && !SafeInt<U>::IsSigned())
; 2050 : 		{
; 2051 : 			//if T > U, we're OK
; 2052 : 			if(sizeof(T) > sizeof(U))
; 2053 : 			{
; 2054 : 				return SafeInt<T>(multiply(lhs.Value(), (T)rhs));
; 2055 : 			}
; 2056 : 
; 2057 : 			//else sizeof(T) <= sizeof(U) - upcast T to signed U
; 2058 : 			//otherwise, we have to make an signed next size up from U
; 2059 : 			if(sizeof(U) < 4)
; 2060 : 			{
; 2061 : 				//T is a signed char or _int16, U is unsigned _int16 or char
; 2062 : 				//this must also always fit into an int
; 2063 : 				return SafeInt<T>((_int32)((_int32)lhs.m_int * (_int32)rhs));
; 2064 : 			}
; 2065 : 			else if(sizeof(U) == 4)
; 2066 : 			{
; 2067 : 				//T is signed int or smaller, U is unsigned int
; 2068 : 				//result must fit into an _int64
; 2069 : 				return SafeInt<T>((_int64)((_int64)lhs.m_int * (_int64)rhs));
; 2070 : 			}
; 2071 : 			else
; 2072 : 			{
; 2073 : 				//U is unsigned 64-bit
; 2074 : 
; 2075 : 				//now if rhs > MaxInt(T), overflow unless lhs == 0
; 2076 : 				//or the corner case
; 2077 : 				if(rhs > (U)SafeInt<T>::MaxInt())
; 2078 : 				{
; 2079 : 					//corner case -1 * (MaxInt + 1) = MinInt
; 2080 : 					//do lhs comparison first, since is cheaper than 64-bit test
; 2081 : 					if(lhs.Value() == -1 && ((U)SafeInt<T>::MaxInt()+1) == rhs)
; 2082 : 						return SafeInt<T>(SafeInt<T>::MinInt());
; 2083 : 
; 2084 : 					if(lhs.Value() == 0)
; 2085 : 						return SafeInt<T>(0);
; 2086 : 
; 2087 : 					SafeIntOnOverflow();
; 2088 : 				}
; 2089 : 
; 2090 : 				//now rhs must fit into T
; 2091 : 				return SafeInt<T>(multiply(lhs.Value(), (T)rhs));
; 2092 : 			}
; 2093 : 		}
; 2094 : 
; 2095 : 		//now mixed sign where T is unsigned, U signed
; 2096 : 			
; 2097 : 		//negative numbers are always bad
; 2098 : 		//test here to avoid having to test in constructors below
; 2099 : 		//also allows some simplifying assumptions
; 2100 : 		if(rhs < 0)

  00008	5a000005	 bpl         |$LN7@MixedSizeM@2|
  0000c	e3a03103	 mov         r3, #3, 2

; 2101 : 			SafeIntOnOverflow();

  00010	e3830095	 orr         r0, r3, #0x95
  00014	e3a03000	 mov         r3, #0
  00018	e3a02000	 mov         r2, #0
  0001c	e3a01000	 mov         r1, #0
  00020	eb000000	 bl          RaiseException
  00024		 |$LN952@MixedSizeM@2|
  00024		 |$LN7@MixedSizeM@2|

; 2102 : 
; 2103 : 		if(sizeof(T) >= sizeof(U))
; 2104 : 		{
; 2105 : 			return SafeInt<T>(multiply(lhs.Value(), (T)rhs));

  00024	e0832291	 umull       r2, r3, r1, r2
  00028	e3530000	 cmp         r3, #0
  0002c	0a000005	 beq         |$LN754@MixedSizeM@2|
  00030	e3a03103	 mov         r3, #3, 2
  00034	e3830095	 orr         r0, r3, #0x95
  00038	e3a03000	 mov         r3, #0
  0003c	e3a02000	 mov         r2, #0
  00040	e3a01000	 mov         r1, #0
  00044	eb000000	 bl          RaiseException
  00048		 |$LN953@MixedSizeM@2|
  00048		 |$LN754@MixedSizeM@2|
  00048	e5802000	 str         r2, [r0]

; 2106 : 		}
; 2107 : 
; 2108 : 		//U > T
; 2109 : 		//else there is no corner case, but we do have to check overflow
; 2110 : 		if(sizeof(U) < 4)
; 2111 : 		{
; 2112 : 			//both U and T can be contained in an unsigned int
; 2113 : 			return SafeInt<T>((unsigned _int32)((unsigned _int32)lhs.m_int * (unsigned _int32)rhs));
; 2114 : 		}
; 2115 : 		else if(sizeof(U) == 4)
; 2116 : 		{
; 2117 : 			//now go up to 64-bit
; 2118 : 			return SafeInt<T>((unsigned _int64)((unsigned _int64)lhs.m_int * (unsigned _int64)rhs));
; 2119 : 		}
; 2120 : 		else
; 2121 : 		{
; 2122 : 			//U = signed _int64, T = unsigned [char|_int16|int]
; 2123 : 			SafeInt<U> u(rhs);
; 2124 : 			u *= lhs.Value();
; 2125 : 
; 2126 : 			//now bounds check
; 2127 : 			if(u.Value() > (U)SafeInt<T>::MaxInt())
; 2128 : 				SafeIntOnOverflow();
; 2129 : 
; 2130 : 			//it has to be safe, since rhs is non-negative
; 2131 : 			return SafeInt<T>((T)u.Value());
; 2132 : 		}
; 2133 : 	}

  0004c	e49de004	 ldr         lr, [sp], #4
  00050	e12fff1e	 bx          lr
  00054		 |$LN948@MixedSizeM@2|
  00054		 |$M45993|

			 ENDP  ; |??$MixedSizeMultiply@H@?$SafeInt@K@@CA?AV0@V0@H@Z|, SafeInt<unsigned long>::MixedSizeMultiply<int>

	EXPORT	|??$?XH@?$SafeInt@K@@QAAAAV0@H@Z|	; SafeInt<unsigned long>::operator*=<int>

  00000			 AREA	 |.pdata|, PDATA
|$T46013| DCD	|$LN7@operator@6|
	DCD	0x40000d02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??$?XH@?$SafeInt@K@@QAAAAV0@H@Z| PROC	; SafeInt<unsigned long>::operator*=<int>

; 751  : 	SafeInt<T>& operator *=(U rhs)

  00000		 |$LN7@operator@6|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M46010|
  00008	e1a02001	 mov         r2, r1
  0000c	e1a04000	 mov         r4, r0

; 752  : 	{
; 753  : 		*this = MixedSizeMultiply(*this, rhs);

  00010	e5941000	 ldr         r1, [r4]
  00014	e28d0000	 add         r0, sp, #0
  00018	eb000000	 bl          |??$MixedSizeMultiply@H@?$SafeInt@K@@CA?AV0@V0@H@Z|
  0001c	e5903000	 ldr         r3, [r0]

; 754  : 		return *this;
; 755  : 	}

  00020	e1a00004	 mov         r0, r4
  00024	e5843000	 str         r3, [r4]
  00028	e28dd004	 add         sp, sp, #4
  0002c	e8bd4010	 ldmia       sp!, {r4, lr}
  00030	e12fff1e	 bx          lr
  00034		 |$M46011|

			 ENDP  ; |??$?XH@?$SafeInt@K@@QAAAAV0@H@Z|, SafeInt<unsigned long>::operator*=<int>

	EXPORT	|??$?DH@?$SafeInt@K@@QBA?AV0@H@Z|	; SafeInt<unsigned long>::operator*<int>

  00000			 AREA	 |.pdata|, PDATA
|$T46025| DCD	|$LN5@operator@7|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??$?DH@?$SafeInt@K@@QBA?AV0@H@Z| PROC	; SafeInt<unsigned long>::operator*<int>

; 733  : 	SafeInt<T> operator *(U rhs) const

  00000		 |$LN5@operator@7|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M46022|
  00004	e1a04001	 mov         r4, r1

; 734  : 	{
; 735  : 		return MixedSizeMultiply(*this, rhs);

  00008	e5901000	 ldr         r1, [r0]
  0000c	e1a00004	 mov         r0, r4
  00010	eb000000	 bl          |??$MixedSizeMultiply@H@?$SafeInt@K@@CA?AV0@V0@H@Z|

; 736  : 	}

  00014	e1a00004	 mov         r0, r4
  00018	e8bd4010	 ldmia       sp!, {r4, lr}
  0001c	e12fff1e	 bx          lr
  00020		 |$M46023|

			 ENDP  ; |??$?DH@?$SafeInt@K@@QBA?AV0@H@Z|, SafeInt<unsigned long>::operator*<int>

	EXPORT	|?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|	; CSDDevice::GetBitSlice
	IMPORT	|memset|
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevinf.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T50394| DCD	|$LN1064@GetBitSlic|
	DCD	0x40005c02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z| PROC ; CSDDevice::GetBitSlice

; 1309 : {

  00000		 |$LN1064@GetBitSlic|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M50391|
  00008	e1a0e003	 mov         lr, r3
  0000c	e1a05002	 mov         r5, r2
  00010	e1a08001	 mov         r8, r1

; 1310 :     UCHAR rgbShifted[4] = { 0 };

  00014	e3a03000	 mov         r3, #0

; 1311 : 
; 1312 :     if (ucBitCount > 32) {

  00018	e5dd0020	 ldrb        r0, [sp, #0x20]
  0001c	e5cd3000	 strb        r3, [sp]
  00020	e3a03000	 mov         r3, #0
  00024	e5cd3001	 strb        r3, [sp, #1]
  00028	e5cd3002	 strb        r3, [sp, #2]
  0002c	e5cd3003	 strb        r3, [sp, #3]
  00030	e3500020	 cmp         r0, #0x20
  00034	9a000001	 bls         |$LN5@GetBitSlic|
  00038		 |$LN1061@GetBitSlic|

; 1313 :         DEBUG_CHECK(FALSE, (TEXT("GetBitSlice: invalid number of bits \n")));
; 1314 :         return 0;

  00038	e3a00000	 mov         r0, #0
  0003c	ea000048	 b           |$LN1059@GetBitSlic|
  00040		 |$LN5@GetBitSlic|

; 1315 :     }
; 1316 : 
; 1317 :     typedef SafeInt<DWORD> SafeDW;
; 1318 :     // Exception will be raised on the next line if there is an overflow.
; 1319 :     if ( (SafeDW(dwBitOffset) + SafeDW(ucBitCount)) > (SafeDW(cbBuffer) * 8) ) {

  00040	e3a03008	 mov         r3, #8
  00044	e0832395	 umull       r2, r3, r5, r3
  00048	e3530000	 cmp         r3, #0
  0004c	0a000005	 beq         |$LN765@GetBitSlic|
  00050	e3a03103	 mov         r3, #3, 2
  00054	e3830095	 orr         r0, r3, #0x95
  00058	e3a03000	 mov         r3, #0
  0005c	e3a02000	 mov         r2, #0
  00060	e3a01000	 mov         r1, #0
  00064	eb000000	 bl          RaiseException
  00068		 |$LN1065@GetBitSlic|
  00068		 |$LN765@GetBitSlic|
  00068	e080300e	 add         r3, r0, lr
  0006c	e15e0003	 cmp         lr, r3
  00070	9a000005	 bls         |$LN1016@GetBitSlic|
  00074	e3a03103	 mov         r3, #3, 2
  00078	e3830095	 orr         r0, r3, #0x95
  0007c	e3a03000	 mov         r3, #0
  00080	e3a02000	 mov         r2, #0
  00084	e3a01000	 mov         r1, #0
  00088	eb000000	 bl          RaiseException
  0008c		 |$LN1066@GetBitSlic|
  0008c		 |$LN1016@GetBitSlic|
  0008c	e1530002	 cmp         r3, r2
  00090	83a03001	 movhi       r3, #1
  00094	93a03000	 movls       r3, #0
  00098	e21330ff	 ands        r3, r3, #0xFF

; 1320 :         DEBUG_CHECK(FALSE, (TEXT("GetBitSlice: invalid bit offset given the number of bits \n")));
; 1321 :         return 0;

  0009c	1affffe5	 bne         |$LN1061@GetBitSlic|

; 1322 :     }
; 1323 : 
; 1324 :     // Shift the pBuffer down by dwBitOffset bits.
; 1325 :     ShiftBytes(pBuffer, cbBuffer, dwBitOffset, rgbShifted);

  000a0	e1a011ae	 mov         r1, lr, lsr #3
  000a4	e2814004	 add         r4, r1, #4
  000a8	e1540005	 cmp         r4, r5
  000ac	21a04005	 movcs       r4, r5
  000b0	e20e3007	 and         r3, lr, #7
  000b4	e1510004	 cmp         r1, r4
  000b8	e2632008	 rsb         r2, r3, #8
  000bc	2a00000e	 bcs         |$LN1051@GetBitSlic|
  000c0	e1a06003	 mov         r6, r3
  000c4	e28de000	 add         lr, sp, #0
  000c8	e20270ff	 and         r7, r2, #0xFF
  000cc		 |$LL1052@GetBitSlic|
  000cc	e7d13008	 ldrb        r3, [r1, +r8]
  000d0	e2811001	 add         r1, r1, #1
  000d4	e1510005	 cmp         r1, r5
  000d8	e1a03633	 mov         r3, r3, lsr r6
  000dc	17d12008	 ldrneb      r2, [r1, +r8]
  000e0	e5ce3000	 strb        r3, [lr]
  000e4	120330ff	 andne       r3, r3, #0xFF
  000e8	11833712	 orrne       r3, r3, r2, lsl r7
  000ec	15ce3000	 strneb      r3, [lr]
  000f0	e28ee001	 add         lr, lr, #1
  000f4	e1510004	 cmp         r1, r4
  000f8	3afffff3	 bcc         |$LL1052@GetBitSlic|
  000fc		 |$LN1051@GetBitSlic|

; 1326 : 
; 1327 :     DWORD dwUsedBytes; // How many bytes have valid data.
; 1328 : 
; 1329 :     if (ucBitCount % 8 == 0) {

  000fc	e1b03000	 movs        r3, r0
  00100	42833007	 addmi       r3, r3, #7
  00104	e1a031c3	 mov         r3, r3, asr #3
  00108	e0501183	 subs        r1, r0, r3, lsl #3

; 1330 :         // Return a byte multiple.
; 1331 :         dwUsedBytes = ucBitCount / 8;

  0010c	01a041a0	 moveq       r4, r0, lsr #3
  00110	0a00000c	 beq         |$LN2@GetBitSlic|

; 1332 :     }
; 1333 :     else {
; 1334 :         // Clear the last used byte of upper bits.
; 1335 :         DWORD dwLastByteIndex = (ucBitCount - 1) / 8;

  00114	e2503001	 subs        r3, r0, #1
  00118	42833007	 addmi       r3, r3, #7
  0011c	e1a001c3	 mov         r0, r3, asr #3

; 1336 :         DWORD dwRemainderShift = 8 - (ucBitCount % 8);
; 1337 :         rgbShifted[dwLastByteIndex] <<= dwRemainderShift;

  00120	e1a0e000	 mov         lr, r0
  00124	e28d3000	 add         r3, sp, #0

; 1338 :         rgbShifted[dwLastByteIndex] >>= dwRemainderShift;

  00128	e7fe2003	 ldrb        r2, [lr, +r3]!
  0012c	e2613008	 rsb         r3, r1, #8
  00130	e20310ff	 and         r1, r3, #0xFF

; 1339 :         dwUsedBytes = dwLastByteIndex + 1;

  00134	e2804001	 add         r4, r0, #1
  00138	e1a03112	 mov         r3, r2, lsl r1
  0013c	e20330ff	 and         r3, r3, #0xFF
  00140	e1a03133	 mov         r3, r3, lsr r1
  00144	e5ce3000	 strb        r3, [lr]
  00148		 |$LN2@GetBitSlic|

; 1340 :     }
; 1341 : 
; 1342 :     // Clear the unused bytes.
; 1343 :     if (dwUsedBytes != sizeof(rgbShifted)) {

  00148	e3540004	 cmp         r4, #4

; 1344 :         memset(rgbShifted + dwUsedBytes, 0, sizeof(rgbShifted) - dwUsedBytes);

  0014c	128d3000	 addne       r3, sp, #0
  00150	10840003	 addne       r0, r4, r3
  00154	12642004	 rsbne       r2, r4, #4
  00158	13a01000	 movne       r1, #0
  0015c	1b000000	 blne        memset

; 1345 :     }
; 1346 : 
; 1347 :     DWORD dwRet;
; 1348 :     memcpy(&dwRet, rgbShifted, sizeof(dwRet));
; 1349 : 
; 1350 :     return dwRet;

  00160	e59d0000	 ldr         r0, [sp]
  00164		 |$LN1059@GetBitSlic|

; 1351 : }

  00164	e28dd008	 add         sp, sp, #8
  00168	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0016c	e12fff1e	 bx          lr
  00170		 |$LN1060@GetBitSlic|
  00170		 |$M50392|

			 ENDP  ; |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|, CSDDevice::GetBitSlice

	EXPORT	|?InfoQueryCSD@CSDDevice@@IAAJPAXK@Z|	; CSDDevice::InfoQueryCSD
	IMPORT	|__muld|

  00000			 AREA	 |.pdata|, PDATA
|$T50532| DCD	|$LN223@InfoQueryC@3|
	DCD	0x40028d02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InfoQueryCSD@CSDDevice@@IAAJPAXK@Z| PROC ; CSDDevice::InfoQueryCSD

; 672  : {

  00000		 |$LN223@InfoQueryC@3|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M50529|
  00008	e1a05001	 mov         r5, r1
  0000c	e1a06000	 mov         r6, r0

; 673  :     PREFAST_DEBUGCHK(pCardInfo);
; 674  :     DEBUGCHK(cbCardInfo == sizeof(SD_PARSED_REGISTER_CSD));
; 675  : 
; 676  :     PSD_PARSED_REGISTER_CSD pParsedCSD = (PSD_PARSED_REGISTER_CSD)pCardInfo;
; 677  :     PUCHAR                  pCSD  = m_CachedRegisters.CSD;

  00010	e2867b01	 add         r7, r6, #1, 22

; 678  :     UCHAR                   value, unit;        // Used for access time/transfer rate calculations
; 679  :     DWORD                   cSize, cSizeMult;   // Used for device size calculation
; 680  :     UCHAR                   fileFormatGroup, fileFormat;
; 681  :     UCHAR                   rblLength;
; 682  : 
; 683  :     pParsedCSD->CSDVersion = (UCHAR)GET_BIT_SLICE_FROM_CSD(pCSD,SD_CSD_VERSION_BIT_SLICE, 
; 684  :         SD_CSD_VERSION_SLICE_SIZE);

  00014	e3a0e002	 mov         lr, #2
  00018	e28710b6	 add         r1, r7, #0xB6
  0001c	e3a0307e	 mov         r3, #0x7E
  00020	e3a02010	 mov         r2, #0x10
  00024	e58de000	 str         lr, [sp]
  00028	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  0002c	e20030ff	 and         r3, r0, #0xFF
  00030	e5c53000	 strb        r3, [r5]

; 685  : 
; 686  :     // check the CSD version code
; 687  :     if (Device_SD_Memory == m_DeviceType) {

  00034	e5962494	 ldr         r2, [r6, #0x494]
  00038	e3a09001	 mov         r9, #1
  0003c	e3520002	 cmp         r2, #2
  00040	1a000003	 bne         |$LN104@InfoQueryC@3|

; 688  :         if (pParsedCSD->CSDVersion > (SD_CSD_VERSION_CODE_SUPPORTED)) {

  00044	e3530001	 cmp         r3, #1
  00048	9a000009	 bls         |$LN100@InfoQueryC@3|

; 689  :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDCardInfoQuery: SD CSD version : %d currently not supported \n"),pParsedCSD->CSDVersion));
; 690  :             DEBUGCHK(FALSE);
; 691  :             return SD_API_STATUS_DEVICE_UNSUPPORTED;

  0004c	e3a0015f	 mov         r0, #0x5F, 2
  00050	ea000270	 b           |$LN105@InfoQueryC@3|
  00054		 |$LN104@InfoQueryC@3|

; 692  :         }
; 693  :     } else if (Device_MMC == m_DeviceType) {

  00054	e3520001	 cmp         r2, #1
  00058	1a00026d	 bne         |$LN101@InfoQueryC@3|

; 694  :         // remove MMC CSD version check. To do this, we would allow MMC v4.x card to be able
; 695  :         // to operate as V3.1 card in 1 bit mode.
; 696  : #ifdef BSP_EMMCFEATURE         
; 697  :           if ((pParsedCSD->CSDVersion >= MMC_CSD_VERSION_CODE_SUPPORTED)&&(IsHighCapacitySDMemory()))

  0005c	e3530002	 cmp         r3, #2
  00060	3a000003	 bcc         |$LN100@InfoQueryC@3|
  00064	e1a00006	 mov         r0, r6
  00068	eb000000	 bl          |?IsHighCapacitySDMemory@CSDDevice@@QAAHXZ|
  0006c	e3500000	 cmp         r0, #0

; 698  :               {
; 699  :               DEBUGMSG(SDCARD_ZONE_FUNC,(TEXT("SDCardInfoQuery:Current MMC CSD version:%d, Change to %d for eMMC\r\n"),pParsedCSD->CSDVersion,SD_CSD_VERSION_CODE_2_0));
; 700  :               pParsedCSD->CSDVersion = SD_CSD_VERSION_CODE_2_0;

  00070	15c59000	 strneb      r9, [r5]
  00074		 |$LN100@InfoQueryC@3|

; 713  :     }
; 714  : 
; 715  :     // get the value
; 716  :     value = (UCHAR)GET_BIT_SLICE_FROM_CSD(pCSD,SD_CSD_TAAC_BIT_SLICE, 
; 717  :         SD_CSD_TAAC_SLICE_SIZE);

  00074	e3a0a008	 mov         r10, #8
  00078	e3a03070	 mov         r3, #0x70
  0007c	e3a02010	 mov         r2, #0x10
  00080	e28710b6	 add         r1, r7, #0xB6
  00084	e1a00006	 mov         r0, r6
  00088	e58da000	 str         r10, [sp]
  0008c	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  00090	e20010ff	 and         r1, r0, #0xFF

; 718  :     // extract the time units
; 719  :     unit  = value & SD_CSD_TAAC_UNIT_MASK;
; 720  :     // get the timee value into position
; 721  :     value = (value & SD_CSD_TAAC_VALUE_MASK) >> SD_CSD_TAAC_VALUE_SHIFT;
; 722  : 
; 723  :     switch( value ) {

  00094	e1a03c81	 mov         r3, r1, lsl #25
  00098	e1a03e23	 mov         r3, r3, lsr #28
  0009c	e2432001	 sub         r2, r3, #1
  000a0	e352000e	 cmp         r2, #0xE
  000a4	e3a08000	 mov         r8, #0
  000a8	8a000041	 bhi         |$LN81@InfoQueryC@3|
  000ac	e28f3004	 add         r3, pc, #4
  000b0	e7d33002	 ldrb        r3, [r3, +r2]
  000b4	e08ff003	 add         pc, pc, r3
  000b8		 |$LN148@InfoQueryC@3|
  000b8		 |$LN147@InfoQueryC@3|
  000b8		 |$LN149@InfoQueryC@3|
  000b8	0ced		 DCB         0xc
  000b9		 |$LN150@InfoQueryC@3|
  000b9	1ced		 DCB         0x1c
  000ba		 |$LN151@InfoQueryC@3|
  000ba	30ed		 DCB         0x30
  000bb		 |$LN152@InfoQueryC@3|
  000bb	3ced		 DCB         0x3c
  000bc		 |$LN153@InfoQueryC@3|
  000bc	4ced		 DCB         0x4c
  000bd		 |$LN154@InfoQueryC@3|
  000bd	58ed		 DCB         0x58
  000be		 |$LN155@InfoQueryC@3|
  000be	68ed		 DCB         0x68
  000bf		 |$LN156@InfoQueryC@3|
  000bf	78ed		 DCB         0x78
  000c0		 |$LN157@InfoQueryC@3|
  000c0	88ed		 DCB         0x88
  000c1		 |$LN158@InfoQueryC@3|
  000c1	98ed		 DCB         0x98
  000c2		 |$LN159@InfoQueryC@3|
  000c2	a8ed		 DCB         0xa8
  000c3		 |$LN160@InfoQueryC@3|
  000c3	b8ed		 DCB         0xb8
  000c4		 |$LN161@InfoQueryC@3|
  000c4	c8ed		 DCB         0xc8
  000c5		 |$LN162@InfoQueryC@3|
  000c5	d8ed		 DCB         0xd8
  000c6		 |$LN163@InfoQueryC@3|
  000c6	e8ed		 DCB         0xe8
  000c7		 |$LN229@InfoQueryC@3|

; 1052 : }

  000c7	e8ed		 DCB         0xe8
  000c8		 |$LN96@InfoQueryC@3|

; 718  :     // extract the time units
; 719  :     unit  = value & SD_CSD_TAAC_UNIT_MASK;
; 720  :     // get the timee value into position
; 721  :     value = (value & SD_CSD_TAAC_VALUE_MASK) >> SD_CSD_TAAC_VALUE_SHIFT;
; 722  : 
; 723  :     switch( value ) {

  000c8	e3a035ff	 mov         r3, #0xFF, 10

; 724  :         case 1:  pParsedCSD->DataAccessTime.TAAC = 1.0; break;

  000cc	e3833603	 orr         r3, r3, #3, 12
  000d0	e585300c	 str         r3, [r5, #0xC]
  000d4	ea000037	 b           |$LN139@InfoQueryC@3|
  000d8		 |$LN95@InfoQueryC@3|

; 725  :         case 2:  pParsedCSD->DataAccessTime.TAAC = 1.2; break;

  000d8	e59f3950	 ldr         r3, [pc, #0x950]
  000dc	e59f2948	 ldr         r2, [pc, #0x948]
  000e0		 |$LN141@InfoQueryC@3|
  000e0	e5853008	 str         r3, [r5, #8]
  000e4	e585200c	 str         r2, [r5, #0xC]
  000e8	ea000033	 b           |$LN97@InfoQueryC@3|
  000ec		 |$LN94@InfoQueryC@3|

; 726  :         case 3:  pParsedCSD->DataAccessTime.TAAC = 1.3; break;

  000ec	e59f3934	 ldr         r3, [pc, #0x934]
  000f0	e59f292c	 ldr         r2, [pc, #0x92C]
  000f4	eafffff9	 b           |$LN141@InfoQueryC@3|
  000f8		 |$LN93@InfoQueryC@3|
  000f8	e3a035ff	 mov         r3, #0xFF, 10

; 727  :         case 4:  pParsedCSD->DataAccessTime.TAAC = 1.5; break;

  000fc	e383370e	 orr         r3, r3, #0xE, 14
  00100	e585300c	 str         r3, [r5, #0xC]
  00104	ea00002b	 b           |$LN139@InfoQueryC@3|
  00108		 |$LN92@InfoQueryC@3|

; 728  :         case 5:  pParsedCSD->DataAccessTime.TAAC = 2.0; break;

  00108	e3a03101	 mov         r3, #1, 2
  0010c	e585300c	 str         r3, [r5, #0xC]
  00110	ea000028	 b           |$LN139@InfoQueryC@3|
  00114		 |$LN91@InfoQueryC@3|
  00114	e3a03101	 mov         r3, #1, 2

; 729  :         case 6:  pParsedCSD->DataAccessTime.TAAC = 2.5; break;

  00118	e3833701	 orr         r3, r3, #1, 14
  0011c	e585300c	 str         r3, [r5, #0xC]
  00120	ea000024	 b           |$LN139@InfoQueryC@3|
  00124		 |$LN90@InfoQueryC@3|
  00124	e3a03101	 mov         r3, #1, 2

; 730  :         case 7:  pParsedCSD->DataAccessTime.TAAC = 3.0; break;

  00128	e3833702	 orr         r3, r3, #2, 14
  0012c	e585300c	 str         r3, [r5, #0xC]
  00130	ea000020	 b           |$LN139@InfoQueryC@3|
  00134		 |$LN89@InfoQueryC@3|
  00134	e3a03101	 mov         r3, #1, 2

; 731  :         case 8:  pParsedCSD->DataAccessTime.TAAC = 3.5; break;

  00138	e3833703	 orr         r3, r3, #3, 14
  0013c	e585300c	 str         r3, [r5, #0xC]
  00140	ea00001c	 b           |$LN139@InfoQueryC@3|
  00144		 |$LN88@InfoQueryC@3|
  00144	e3a03101	 mov         r3, #1, 2

; 732  :         case 9:  pParsedCSD->DataAccessTime.TAAC = 4.0; break;

  00148	e3833601	 orr         r3, r3, #1, 12
  0014c	e585300c	 str         r3, [r5, #0xC]
  00150	ea000018	 b           |$LN139@InfoQueryC@3|
  00154		 |$LN87@InfoQueryC@3|
  00154	e3a03101	 mov         r3, #1, 2

; 733  :         case 10: pParsedCSD->DataAccessTime.TAAC = 4.5; break;

  00158	e3833812	 orr         r3, r3, #0x12, 16
  0015c	e585300c	 str         r3, [r5, #0xC]
  00160	ea000014	 b           |$LN139@InfoQueryC@3|
  00164		 |$LN86@InfoQueryC@3|
  00164	e3a03101	 mov         r3, #1, 2

; 734  :         case 11: pParsedCSD->DataAccessTime.TAAC = 5.0; break;

  00168	e3833705	 orr         r3, r3, #5, 14
  0016c	e585300c	 str         r3, [r5, #0xC]
  00170	ea000010	 b           |$LN139@InfoQueryC@3|
  00174		 |$LN85@InfoQueryC@3|
  00174	e3a03101	 mov         r3, #1, 2

; 735  :         case 12: pParsedCSD->DataAccessTime.TAAC = 5.5; break;

  00178	e3833816	 orr         r3, r3, #0x16, 16
  0017c	e585300c	 str         r3, [r5, #0xC]
  00180	ea00000c	 b           |$LN139@InfoQueryC@3|
  00184		 |$LN84@InfoQueryC@3|
  00184	e3a03101	 mov         r3, #1, 2

; 736  :         case 13: pParsedCSD->DataAccessTime.TAAC = 6.0; break;

  00188	e3833706	 orr         r3, r3, #6, 14
  0018c	e585300c	 str         r3, [r5, #0xC]
  00190	ea000008	 b           |$LN139@InfoQueryC@3|
  00194		 |$LN83@InfoQueryC@3|
  00194	e3a03101	 mov         r3, #1, 2

; 737  :         case 14: pParsedCSD->DataAccessTime.TAAC = 7.0; break;

  00198	e3833707	 orr         r3, r3, #7, 14
  0019c	e585300c	 str         r3, [r5, #0xC]
  001a0	ea000004	 b           |$LN139@InfoQueryC@3|
  001a4		 |$LN82@InfoQueryC@3|
  001a4	e3a03101	 mov         r3, #1, 2

; 738  :         case 15: pParsedCSD->DataAccessTime.TAAC = 8.0; break;

  001a8	e3833602	 orr         r3, r3, #2, 12
  001ac	e585300c	 str         r3, [r5, #0xC]
  001b0	ea000000	 b           |$LN139@InfoQueryC@3|
  001b4		 |$LN81@InfoQueryC@3|

; 739  :         default: pParsedCSD->DataAccessTime.TAAC = 0.0; break;

  001b4	e585800c	 str         r8, [r5, #0xC]
  001b8		 |$LN139@InfoQueryC@3|
  001b8	e5858008	 str         r8, [r5, #8]
  001bc		 |$LN97@InfoQueryC@3|

; 740  :     };
; 741  : 
; 742  :     for( ; unit; unit-- ) {

  001bc	e2114007	 ands        r4, r1, #7
  001c0	0a00000a	 beq         |$LN78@InfoQueryC@3|
  001c4	e5950008	 ldr         r0, [r5, #8]
  001c8	e595100c	 ldr         r1, [r5, #0xC]
  001cc	e3a0b101	 mov         r11, #1, 2
  001d0		 |$LL80@InfoQueryC@3|

; 743  :         pParsedCSD->DataAccessTime.TAAC *= 10; 

  001d0	e3a02000	 mov         r2, #0
  001d4	e38b3709	 orr         r3, r11, #9, 14
  001d8	eb000000	 bl          __muld
  001dc	e28430ff	 add         r3, r4, #0xFF
  001e0	e21340ff	 ands        r4, r3, #0xFF
  001e4	1afffff9	 bne         |$LL80@InfoQueryC@3|
  001e8	e5850008	 str         r0, [r5, #8]
  001ec	e585100c	 str         r1, [r5, #0xC]
  001f0		 |$LN78@InfoQueryC@3|

; 744  :     }
; 745  : 
; 746  :     pParsedCSD->DataAccessTime.NSAC = (UCHAR)GET_BIT_SLICE_FROM_CSD(pCSD,SD_CSD_NSAC_BIT_SLICE, 
; 747  :         SD_CSD_NSAC_SLICE_SIZE);

  001f0	e3a03068	 mov         r3, #0x68
  001f4	e3a02010	 mov         r2, #0x10
  001f8	e28710b6	 add         r1, r7, #0xB6
  001fc	e1a00006	 mov         r0, r6
  00200	e58da000	 str         r10, [sp]
  00204	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  00208	e20030ff	 and         r3, r0, #0xFF
  0020c	e1c531b0	 strh        r3, [r5, #0x10]

; 748  : 
; 749  : 
; 750  :     // Calculate transfer rate in kbit/s
; 751  :     value = (UCHAR)GET_BIT_SLICE_FROM_CSD(pCSD,SD_CSD_TRANS_SPEED_BIT_SLICE, 
; 752  :         SD_CSD_TRANS_SPEED_SLICE_SIZE);

  00210	e3a03060	 mov         r3, #0x60
  00214	e3a02010	 mov         r2, #0x10
  00218	e28710b6	 add         r1, r7, #0xB6
  0021c	e1a00006	 mov         r0, r6
  00220	e58da000	 str         r10, [sp]
  00224	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  00228	e20010ff	 and         r1, r0, #0xFF

; 753  : 
; 754  :     unit  = value & SD_CSD_TRANS_SPEED_UNIT_MASK;
; 755  : 
; 756  :     // get value bits into position
; 757  :     value = (value & SD_CSD_TRANS_SPEED_VALUE_MASK) >> SD_CSD_TRANS_SPEED_VALUE_SHIFT;
; 758  : 
; 759  :     switch( value ) {            

  0022c	e1a03c81	 mov         r3, r1, lsl #25
  00230	e1a03e23	 mov         r3, r3, lsr #28
  00234	e2432001	 sub         r2, r3, #1
  00238	e352000e	 cmp         r2, #0xE
  0023c	e3a0e0c8	 mov         lr, #0xC8
  00240	e3a00064	 mov         r0, #0x64
  00244	8a000034	 bhi         |$LN60@InfoQueryC@3|
  00248	e28f3004	 add         r3, pc, #4
  0024c	e7d33002	 ldrb        r3, [r3, +r2]
  00250	e08ff003	 add         pc, pc, r3
  00254		 |$LN165@InfoQueryC@3|
  00254		 |$LN164@InfoQueryC@3|
  00254		 |$LN166@InfoQueryC@3|
  00254	0ced		 DCB         0xc
  00255		 |$LN167@InfoQueryC@3|
  00255	14ed		 DCB         0x14
  00256		 |$LN168@InfoQueryC@3|
  00256	20ed		 DCB         0x20
  00257		 |$LN169@InfoQueryC@3|
  00257	2ced		 DCB         0x2c
  00258		 |$LN170@InfoQueryC@3|
  00258	38ed		 DCB         0x38
  00259		 |$LN171@InfoQueryC@3|
  00259	40ed		 DCB         0x40
  0025a		 |$LN172@InfoQueryC@3|
  0025a	4ced		 DCB         0x4c
  0025b		 |$LN173@InfoQueryC@3|
  0025b	58ed		 DCB         0x58
  0025c		 |$LN174@InfoQueryC@3|
  0025c	68ed		 DCB         0x68
  0025d		 |$LN175@InfoQueryC@3|
  0025d	74ed		 DCB         0x74
  0025e		 |$LN176@InfoQueryC@3|
  0025e	84ed		 DCB         0x84
  0025f		 |$LN177@InfoQueryC@3|
  0025f	90ed		 DCB         0x90
  00260		 |$LN178@InfoQueryC@3|
  00260	a0ed		 DCB         0xa0
  00261		 |$LN179@InfoQueryC@3|
  00261	aced		 DCB         0xac
  00262		 |$LN180@InfoQueryC@3|
  00262	b8ed		 DCB         0xb8
  00263		 |$LN230@InfoQueryC@3|

; 1052 : }

  00263	b8ed		 DCB         0xb8
  00264		 |$LN75@InfoQueryC@3|

; 760  :         case 1:  pParsedCSD->MaxDataTransferRate = 100; break;

  00264	e5850018	 str         r0, [r5, #0x18]
  00268	ea00002c	 b           |$LN76@InfoQueryC@3|
  0026c		 |$LN74@InfoQueryC@3|

; 761  :         case 2:  pParsedCSD->MaxDataTransferRate = 120; break;

  0026c	e3a03078	 mov         r3, #0x78
  00270	e5853018	 str         r3, [r5, #0x18]
  00274	ea000029	 b           |$LN76@InfoQueryC@3|
  00278		 |$LN73@InfoQueryC@3|

; 762  :         case 3:  pParsedCSD->MaxDataTransferRate = 130; break;

  00278	e3a03082	 mov         r3, #0x82
  0027c	e5853018	 str         r3, [r5, #0x18]
  00280	ea000026	 b           |$LN76@InfoQueryC@3|
  00284		 |$LN72@InfoQueryC@3|

; 763  :         case 4:  pParsedCSD->MaxDataTransferRate = 150; break;

  00284	e3a03096	 mov         r3, #0x96
  00288	e5853018	 str         r3, [r5, #0x18]
  0028c	ea000023	 b           |$LN76@InfoQueryC@3|
  00290		 |$LN71@InfoQueryC@3|

; 764  :         case 5:  pParsedCSD->MaxDataTransferRate = 200; break;

  00290	e585e018	 str         lr, [r5, #0x18]
  00294	ea000021	 b           |$LN76@InfoQueryC@3|
  00298		 |$LN70@InfoQueryC@3|

; 765  :         case 6:  pParsedCSD->MaxDataTransferRate = 250; break;

  00298	e3a030fa	 mov         r3, #0xFA
  0029c	e5853018	 str         r3, [r5, #0x18]
  002a0	ea00001e	 b           |$LN76@InfoQueryC@3|
  002a4		 |$LN69@InfoQueryC@3|

; 766  :         case 7:  pParsedCSD->MaxDataTransferRate = 300; break;

  002a4	e3a03f4b	 mov         r3, #0x4B, 30
  002a8	e5853018	 str         r3, [r5, #0x18]
  002ac	ea00001b	 b           |$LN76@InfoQueryC@3|
  002b0		 |$LN68@InfoQueryC@3|
  002b0	e3a03c01	 mov         r3, #1, 24

; 767  :         case 8:  pParsedCSD->MaxDataTransferRate = 350; break;

  002b4	e383305e	 orr         r3, r3, #0x5E
  002b8	e5853018	 str         r3, [r5, #0x18]
  002bc	ea000017	 b           |$LN76@InfoQueryC@3|
  002c0		 |$LN67@InfoQueryC@3|

; 768  :         case 9:  pParsedCSD->MaxDataTransferRate = 400; break;

  002c0	e3a03e19	 mov         r3, #0x19, 28
  002c4	e5853018	 str         r3, [r5, #0x18]
  002c8	ea000014	 b           |$LN76@InfoQueryC@3|
  002cc		 |$LN66@InfoQueryC@3|
  002cc	e3a03c01	 mov         r3, #1, 24

; 769  :         case 10: pParsedCSD->MaxDataTransferRate = 450; break;

  002d0	e38330c2	 orr         r3, r3, #0xC2
  002d4	e5853018	 str         r3, [r5, #0x18]
  002d8	ea000010	 b           |$LN76@InfoQueryC@3|
  002dc		 |$LN65@InfoQueryC@3|

; 770  :         case 11: pParsedCSD->MaxDataTransferRate = 500; break;

  002dc	e3a03f7d	 mov         r3, #0x7D, 30
  002e0	e5853018	 str         r3, [r5, #0x18]
  002e4	ea00000d	 b           |$LN76@InfoQueryC@3|
  002e8		 |$LN64@InfoQueryC@3|
  002e8	e3a03c02	 mov         r3, #2, 24

; 771  :         case 12: pParsedCSD->MaxDataTransferRate = 550; break;

  002ec	e3833026	 orr         r3, r3, #0x26
  002f0	e5853018	 str         r3, [r5, #0x18]
  002f4	ea000009	 b           |$LN76@InfoQueryC@3|
  002f8		 |$LN63@InfoQueryC@3|

; 772  :         case 13: pParsedCSD->MaxDataTransferRate = 600; break;

  002f8	e3a03f96	 mov         r3, #0x96, 30
  002fc	e5853018	 str         r3, [r5, #0x18]
  00300	ea000006	 b           |$LN76@InfoQueryC@3|
  00304		 |$LN62@InfoQueryC@3|

; 773  :         case 14: pParsedCSD->MaxDataTransferRate = 700; break;

  00304	e3a03faf	 mov         r3, #0xAF, 30
  00308	e5853018	 str         r3, [r5, #0x18]
  0030c	ea000003	 b           |$LN76@InfoQueryC@3|
  00310		 |$LN61@InfoQueryC@3|

; 774  :         case 15: pParsedCSD->MaxDataTransferRate = 800; break;

  00310	e3a03e32	 mov         r3, #0x32, 28
  00314	e5853018	 str         r3, [r5, #0x18]
  00318	ea000000	 b           |$LN76@InfoQueryC@3|
  0031c		 |$LN60@InfoQueryC@3|

; 775  :         default: pParsedCSD->MaxDataTransferRate = 0;   break;

  0031c	e5858018	 str         r8, [r5, #0x18]
  00320		 |$LN76@InfoQueryC@3|

; 776  :     };                              
; 777  : 
; 778  :     for( ; unit; unit-- )   

  00320	e2112007	 ands        r2, r1, #7
  00324	0a000006	 beq         |$LN57@InfoQueryC@3|
  00328	e5953018	 ldr         r3, [r5, #0x18]
  0032c		 |$LL59@InfoQueryC@3|
  0032c	e28220ff	 add         r2, r2, #0xFF

; 779  :         pParsedCSD->MaxDataTransferRate *= 10;              

  00330	e0833103	 add         r3, r3, r3, lsl #2
  00334	e21220ff	 ands        r2, r2, #0xFF
  00338	e1a03083	 mov         r3, r3, lsl #1
  0033c	1afffffa	 bne         |$LL59@InfoQueryC@3|

; 776  :     };                              
; 777  : 
; 778  :     for( ; unit; unit-- )   

  00340	e5853018	 str         r3, [r5, #0x18]
  00344		 |$LN57@InfoQueryC@3|

; 780  : 
; 781  : 
; 782  :     pParsedCSD->CardCommandClasses = (USHORT)GET_BIT_SLICE_FROM_CSD(pCSD,SD_CSD_CCC_BIT_SLICE, 
; 783  :         SD_CSD_CCC_SLICE_SIZE);

  00344	e3a0a00c	 mov         r10, #0xC
  00348	e3a03054	 mov         r3, #0x54
  0034c	e3a02010	 mov         r2, #0x10
  00350	e28710b6	 add         r1, r7, #0xB6
  00354	e1a00006	 mov         r0, r6
  00358	e58da000	 str         r10, [sp]
  0035c	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  00360	e1a03000	 mov         r3, r0

; 784  : 
; 785  : 
; 786  : 
; 787  :     rblLength = (UCHAR)GET_BIT_SLICE_FROM_CSD(pCSD, SD_CSD_READ_BL_LEN_BIT_SLICE, 
; 788  :         SD_CSD_READ_BL_LEN_SLICE_SIZE);

  00364	e1c531bc	 strh        r3, [r5, #0x1C]
  00368	e3a04004	 mov         r4, #4
  0036c	e3a03050	 mov         r3, #0x50
  00370	e1a00006	 mov         r0, r6
  00374	e3a02010	 mov         r2, #0x10
  00378	e28710b6	 add         r1, r7, #0xB6
  0037c	e58d4000	 str         r4, [sp]
  00380	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|

; 789  : 
; 790  :     DEBUG_CHECK((rblLength < 12), (TEXT("SDCardInfoQuery - Read Block Length %d is invalid \n"),rblLength));
; 791  : 
; 792  :     // Read Block Length
; 793  :     pParsedCSD->MaxReadBlockLength = 1 << rblLength;

  00384	e20030ff	 and         r3, r0, #0xFF
  00388	e3a02001	 mov         r2, #1
  0038c	e1a02312	 mov         r2, r2, lsl r3

; 794  : 
; 795  :     // Write Block Length
; 796  :     pParsedCSD->MaxWriteBlockLength = (UCHAR)GET_BIT_SLICE_FROM_CSD(pCSD,
; 797  :         SD_CSD_WRITE_BL_LEN_BIT_SLICE, 
; 798  :         SD_CSD_WRITE_BL_LEN_SLICE_SIZE);             

  00390	e3a03016	 mov         r3, #0x16
  00394	e1c521be	 strh        r2, [r5, #0x1E]
  00398	e3a02010	 mov         r2, #0x10
  0039c	e28710b6	 add         r1, r7, #0xB6
  003a0	e1a00006	 mov         r0, r6
  003a4	e58d4000	 str         r4, [sp]
  003a8	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|

; 799  : 
; 800  :     DEBUG_CHECK((pParsedCSD->MaxWriteBlockLength < 12), (TEXT("SDCardInfoQuery - Write Block Length Length %d is invalid \n"), 
; 801  :         pParsedCSD->MaxWriteBlockLength));
; 802  : 
; 803  :     pParsedCSD->MaxWriteBlockLength = 1 << pParsedCSD->MaxWriteBlockLength;

  003ac	e20030ff	 and         r3, r0, #0xFF
  003b0	e3a02001	 mov         r2, #1
  003b4	e1a02312	 mov         r2, r2, lsl r3

; 804  : 
; 805  : 
; 806  : 
; 807  :     pParsedCSD->ReadBlockPartial =  GET_BIT_SLICE_FROM_CSD(pCSD,
; 808  :         SD_CSD_READ_BL_PARTIAL_BIT_SLICE, 
; 809  :         SD_CSD_READ_BL_PARTIAL_SLICE_SIZE) 
; 810  :         ? TRUE:FALSE;

  003b8	e3a0304f	 mov         r3, #0x4F
  003bc	e1c523b6	 strh        r2, [r5, #0x36]
  003c0	e3a02010	 mov         r2, #0x10
  003c4	e28710b6	 add         r1, r7, #0xB6
  003c8	e1a00006	 mov         r0, r6
  003cc	e58d9000	 str         r9, [sp]
  003d0	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  003d4	e3500000	 cmp         r0, #0
  003d8	13a0e001	 movne       lr, #1
  003dc	03a0e000	 moveq       lr, #0

; 811  : 
; 812  :     pParsedCSD->WriteBlockPartial = GET_BIT_SLICE_FROM_CSD(pCSD,
; 813  :         SD_CSD_WRITE_BL_PARTIAL_BIT_SLICE, 
; 814  :         SD_CSD_WRITE_BL_PARTIAL_SLICE_SIZE) 
; 815  :         ? TRUE:FALSE;

  003e0	e3a03015	 mov         r3, #0x15
  003e4	e3a02010	 mov         r2, #0x10
  003e8	e28710b6	 add         r1, r7, #0xB6
  003ec	e1a00006	 mov         r0, r6
  003f0	e5c5e020	 strb        lr, [r5, #0x20]
  003f4	e58d9000	 str         r9, [sp]
  003f8	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  003fc	e3500000	 cmp         r0, #0
  00400	13a0e001	 movne       lr, #1
  00404	03a0e000	 moveq       lr, #0

; 816  : 
; 817  : 
; 818  :     // Read/Write Block Misalign
; 819  :     pParsedCSD->WriteBlockMisalign = GET_BIT_SLICE_FROM_CSD(pCSD,
; 820  :         SD_CSD_WRITE_BL_MISALIGN_BIT_SLICE, 
; 821  :         SD_CSD_WRITE_BL_MISALIGN_SLICE_SIZE) 
; 822  :         ? TRUE:FALSE;

  00408	e3a0304e	 mov         r3, #0x4E
  0040c	e3a02010	 mov         r2, #0x10
  00410	e28710b6	 add         r1, r7, #0xB6
  00414	e1a00006	 mov         r0, r6
  00418	e5c5e038	 strb        lr, [r5, #0x38]
  0041c	e58d9000	 str         r9, [sp]
  00420	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  00424	e3500000	 cmp         r0, #0
  00428	13a0e001	 movne       lr, #1
  0042c	03a0e000	 moveq       lr, #0

; 823  : 
; 824  : 
; 825  :     pParsedCSD->ReadBlockMisalign = GET_BIT_SLICE_FROM_CSD(pCSD,
; 826  :         SD_CSD_READ_BL_MISALIGN_BIT_SLICE, 
; 827  :         SD_CSD_READ_BL_MISALIGN_SLICE_SIZE) 
; 828  :         ? TRUE:FALSE;

  00430	e3a0304d	 mov         r3, #0x4D
  00434	e3a02010	 mov         r2, #0x10
  00438	e28710b6	 add         r1, r7, #0xB6
  0043c	e1a00006	 mov         r0, r6
  00440	e5c5e021	 strb        lr, [r5, #0x21]
  00444	e58d9000	 str         r9, [sp]
  00448	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  0044c	e3500000	 cmp         r0, #0
  00450	13a0e001	 movne       lr, #1
  00454	03a0e000	 moveq       lr, #0

; 829  : 
; 830  : 
; 831  : 
; 832  :     // DSR Implemented
; 833  :     pParsedCSD->DSRImplemented = GET_BIT_SLICE_FROM_CSD(pCSD,
; 834  :         SD_CSD_DSR_IMP_BIT_SLICE, 
; 835  :         SD_CSD_DSR_IMP_SLICE_SIZE) 
; 836  :         ? TRUE:FALSE;

  00458	e3a0304c	 mov         r3, #0x4C
  0045c	e3a02010	 mov         r2, #0x10
  00460	e28710b6	 add         r1, r7, #0xB6
  00464	e1a00006	 mov         r0, r6
  00468	e5c5e022	 strb        lr, [r5, #0x22]
  0046c	e58d9000	 str         r9, [sp]
  00470	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  00474	e3500000	 cmp         r0, #0
  00478	13a0e001	 movne       lr, #1
  0047c	03a0e000	 moveq       lr, #0

; 837  : 
; 838  :     // Write Protect Group Enabled
; 839  :     pParsedCSD->WPGroupEnable = GET_BIT_SLICE_FROM_CSD(pCSD,
; 840  :         SD_CSD_WP_GRP_ENABLE_BIT_SLICE, 
; 841  :         SD_CSD_WP_GRP_ENABLE_SLICE_SIZE) 
; 842  :         ? TRUE:FALSE;

  00480	e3a0301f	 mov         r3, #0x1F
  00484	e3a02010	 mov         r2, #0x10
  00488	e28710b6	 add         r1, r7, #0xB6
  0048c	e1a00006	 mov         r0, r6
  00490	e5c5e023	 strb        lr, [r5, #0x23]
  00494	e58d9000	 str         r9, [sp]
  00498	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  0049c	e3500000	 cmp         r0, #0
  004a0	13a0e001	 movne       lr, #1
  004a4	03a0e000	 moveq       lr, #0

; 843  : 
; 844  : 
; 845  : 
; 846  :     // Copy Flag
; 847  :     pParsedCSD->CopyFlag = GET_BIT_SLICE_FROM_CSD(pCSD,
; 848  :         SD_CSD_COPY_FLAG_BIT_SLICE, 
; 849  :         SD_CSD_COPY_FLAG_SLICE_SIZE) 
; 850  :         ? TRUE:FALSE;

  004a8	e3a0300e	 mov         r3, #0xE
  004ac	e3a02010	 mov         r2, #0x10
  004b0	e28710b6	 add         r1, r7, #0xB6
  004b4	e1a00006	 mov         r0, r6
  004b8	e5c5e033	 strb        lr, [r5, #0x33]
  004bc	e58d9000	 str         r9, [sp]
  004c0	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  004c4	e3500000	 cmp         r0, #0
  004c8	13a0e001	 movne       lr, #1
  004cc	03a0e000	 moveq       lr, #0

; 851  : 
; 852  :     // Permanent Write Protect
; 853  :     pParsedCSD->PermanentWP = GET_BIT_SLICE_FROM_CSD(pCSD,
; 854  :         SD_CSD_PERM_WR_PROT_BIT_SLICE, 
; 855  :         SD_CSD_PERM_WR_PROT_SLICE_SIZE) 
; 856  :         ? TRUE:FALSE;

  004d0	e3a0300d	 mov         r3, #0xD
  004d4	e3a02010	 mov         r2, #0x10
  004d8	e28710b6	 add         r1, r7, #0xB6
  004dc	e1a00006	 mov         r0, r6
  004e0	e5c5e039	 strb        lr, [r5, #0x39]
  004e4	e58d9000	 str         r9, [sp]
  004e8	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  004ec	e3500000	 cmp         r0, #0
  004f0	13a0e001	 movne       lr, #1
  004f4	03a0e000	 moveq       lr, #0

; 857  : 
; 858  : 
; 859  :     // Temporary Write Protect
; 860  :     pParsedCSD->TemporaryWP = GET_BIT_SLICE_FROM_CSD(pCSD,
; 861  :         SD_CSD_TEMP_WR_PROT_BIT_SLICE, 
; 862  :         SD_CSD_TEMP_WR_PROT_SLICE_SIZE) 
; 863  :         ? TRUE:FALSE;

  004f8	e3a0300c	 mov         r3, #0xC
  004fc	e3a02010	 mov         r2, #0x10
  00500	e28710b6	 add         r1, r7, #0xB6
  00504	e1a00006	 mov         r0, r6
  00508	e5c5e03a	 strb        lr, [r5, #0x3A]
  0050c	e58d9000	 str         r9, [sp]
  00510	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  00514	e3500000	 cmp         r0, #0
  00518	13a0e001	 movne       lr, #1
  0051c	03a0e000	 moveq       lr, #0

; 864  : 
; 865  :     // Calculate the device size as per SD Spec
; 866  :     cSize =  GET_BIT_SLICE_FROM_CSD(pCSD,
; 867  :         SD_CSD_CSIZE_BIT_SLICE, 
; 868  :         SD_CSD_CSIZE_SLICE_SIZE);

  00520	e3a0303e	 mov         r3, #0x3E
  00524	e3a02010	 mov         r2, #0x10
  00528	e28710b6	 add         r1, r7, #0xB6
  0052c	e1a00006	 mov         r0, r6
  00530	e5c5e03b	 strb        lr, [r5, #0x3B]
  00534	e58da000	 str         r10, [sp]
  00538	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  0053c	e1a04000	 mov         r4, r0

; 869  : 
; 870  : 
; 871  : 
; 872  :     cSizeMult = GET_BIT_SLICE_FROM_CSD(pCSD,
; 873  :         SD_CSD_CSIZE_MULT_BIT_SLICE, 
; 874  :         SD_CSD_CSIZE_MULT_SLICE_SIZE); 

  00540	e3a0a003	 mov         r10, #3
  00544	e1a00006	 mov         r0, r6
  00548	e3a0302f	 mov         r3, #0x2F
  0054c	e3a02010	 mov         r2, #0x10
  00550	e28710b6	 add         r1, r7, #0xB6
  00554	e58da000	 str         r10, [sp]
  00558	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|

; 875  : 
; 876  :     DEBUG_CHECK((cSizeMult < 8), (TEXT("SDCardInfoQuery - C_SIZE %d is invalid \n"),cSizeMult));
; 877  : 
; 878  :     // Perform actual device size calculation
; 879  :     pParsedCSD->DeviceSize = pParsedCSD->MaxReadBlockLength * ((cSize+1) * (1<<(cSizeMult+2)));

  0055c	e2803002	 add         r3, r0, #2
  00560	e3a02001	 mov         r2, #1
  00564	e1a02312	 mov         r2, r2, lsl r3
  00568	e2843001	 add         r3, r4, #1
  0056c	e1d511be	 ldrh        r1, [r5, #0x1E]
  00570	e0000392	 mul         r0, r2, r3

; 880  :     m_SDCardInfo.SDMMCInformation.ullDeviceSize = pParsedCSD->DeviceSize;
; 881  : 
; 882  :     // VDD Read Current Minimum
; 883  :     pParsedCSD->VDDReadCurrentMin = (USHORT)GET_BIT_SLICE_FROM_CSD(pCSD, SD_CSD_R_CURR_MIN_BIT_SLICE, 
; 884  :         SD_CSD_R_CURR_MIN_SLICE_SIZE);

  00574	e3a0303b	 mov         r3, #0x3B
  00578	e00e0190	 mul         lr, r0, r1
  0057c	e3a02010	 mov         r2, #0x10
  00580	e28710b6	 add         r1, r7, #0xB6
  00584	e1a00006	 mov         r0, r6
  00588	e585e024	 str         lr, [r5, #0x24]
  0058c	e586e538	 str         lr, [r6, #0x538]
  00590	e586853c	 str         r8, [r6, #0x53C]
  00594	e58da000	 str         r10, [sp]
  00598	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  0059c	e1a02800	 mov         r2, r0, lsl #16
  005a0	e1a02822	 mov         r2, r2, lsr #16
  005a4	e1c522b8	 strh        r2, [r5, #0x28]

; 885  : 
; 886  :     switch( pParsedCSD->VDDReadCurrentMin ) {

  005a8	e3520007	 cmp         r2, #7
  005ac	e3a0b005	 mov         r11, #5
  005b0	e3a0400a	 mov         r4, #0xA
  005b4	e3a01019	 mov         r1, #0x19
  005b8	e3a00023	 mov         r0, #0x23
  005bc	e3a0e03c	 mov         lr, #0x3C
  005c0	8a000013	 bhi         |$LN46@InfoQueryC@3|
  005c4	e28f3004	 add         r3, pc, #4
  005c8	e7d33002	 ldrb        r3, [r3, +r2]
  005cc	e08ff003	 add         pc, pc, r3
  005d0		 |$LN182@InfoQueryC@3|
  005d0		 |$LN181@InfoQueryC@3|
  005d0		 |$LN183@InfoQueryC@3|
  005d0	04ed		 DCB         0x4
  005d1		 |$LN184@InfoQueryC@3|
  005d1	04ed		 DCB         0x4
  005d2		 |$LN185@InfoQueryC@3|
  005d2	0ced		 DCB         0xc
  005d3		 |$LN186@InfoQueryC@3|
  005d3	14ed		 DCB         0x14
  005d4		 |$LN187@InfoQueryC@3|
  005d4	1ced		 DCB         0x1c
  005d5		 |$LN188@InfoQueryC@3|
  005d5	24ed		 DCB         0x24
  005d6		 |$LN189@InfoQueryC@3|
  005d6	2ced		 DCB         0x2c
  005d7		 |$LN190@InfoQueryC@3|
  005d7	34ed		 DCB         0x34
  005d8		 |$LN54@InfoQueryC@3|

; 887  :         case 0:  pParsedCSD->VDDReadCurrentMin = 1;   break;

  005d8	e1c592b8	 strh        r9, [r5, #0x28]
  005dc	ea00000d	 b           |$LN55@InfoQueryC@3|
  005e0		 |$LN52@InfoQueryC@3|

; 888  :         case 1:  pParsedCSD->VDDReadCurrentMin = 1;   break;
; 889  :         case 2:  pParsedCSD->VDDReadCurrentMin = 5;   break;

  005e0	e1c5b2b8	 strh        r11, [r5, #0x28]
  005e4	ea00000b	 b           |$LN55@InfoQueryC@3|
  005e8		 |$LN51@InfoQueryC@3|

; 890  :         case 3:  pParsedCSD->VDDReadCurrentMin = 10;  break;

  005e8	e1c542b8	 strh        r4, [r5, #0x28]
  005ec	ea000009	 b           |$LN55@InfoQueryC@3|
  005f0		 |$LN50@InfoQueryC@3|

; 891  :         case 4:  pParsedCSD->VDDReadCurrentMin = 25;  break;

  005f0	e1c512b8	 strh        r1, [r5, #0x28]
  005f4	ea000007	 b           |$LN55@InfoQueryC@3|
  005f8		 |$LN49@InfoQueryC@3|

; 892  :         case 5:  pParsedCSD->VDDReadCurrentMin = 35;  break;

  005f8	e1c502b8	 strh        r0, [r5, #0x28]
  005fc	ea000005	 b           |$LN55@InfoQueryC@3|
  00600		 |$LN48@InfoQueryC@3|

; 893  :         case 6:  pParsedCSD->VDDReadCurrentMin = 60;  break;

  00600	e1c5e2b8	 strh        lr, [r5, #0x28]
  00604	ea000003	 b           |$LN55@InfoQueryC@3|
  00608		 |$LN47@InfoQueryC@3|

; 894  :         case 7:  pParsedCSD->VDDReadCurrentMin = 100; break;

  00608	e3a03064	 mov         r3, #0x64
  0060c	e1c532b8	 strh        r3, [r5, #0x28]
  00610	ea000000	 b           |$LN55@InfoQueryC@3|
  00614		 |$LN46@InfoQueryC@3|

; 895  :         default: pParsedCSD->VDDReadCurrentMin = 0;   break;

  00614	e1c582b8	 strh        r8, [r5, #0x28]
  00618		 |$LN55@InfoQueryC@3|

; 896  :     }
; 897  : 
; 898  : 
; 899  :     // VDD Write Current Minimum
; 900  :     pParsedCSD->VDDWriteCurrentMin = (USHORT)GET_BIT_SLICE_FROM_CSD(pCSD,SD_CSD_W_CURR_MIN_BIT_SLICE, 
; 901  :         SD_CSD_W_CURR_MIN_SLICE_SIZE);

  00618	e3a03035	 mov         r3, #0x35
  0061c	e3a02010	 mov         r2, #0x10
  00620	e28710b6	 add         r1, r7, #0xB6
  00624	e1a00006	 mov         r0, r6
  00628	e58da000	 str         r10, [sp]
  0062c	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  00630	e1a02800	 mov         r2, r0, lsl #16
  00634	e1a02822	 mov         r2, r2, lsr #16
  00638	e1c522bc	 strh        r2, [r5, #0x2C]

; 902  : 
; 903  :     switch( pParsedCSD->VDDWriteCurrentMin ) {

  0063c	e3520007	 cmp         r2, #7
  00640	8a000016	 bhi         |$LN35@InfoQueryC@3|
  00644	e28f3004	 add         r3, pc, #4
  00648	e7d33002	 ldrb        r3, [r3, +r2]
  0064c	e08ff003	 add         pc, pc, r3
  00650		 |$LN192@InfoQueryC@3|
  00650		 |$LN191@InfoQueryC@3|
  00650		 |$LN193@InfoQueryC@3|
  00650	04ed		 DCB         0x4
  00651		 |$LN194@InfoQueryC@3|
  00651	04ed		 DCB         0x4
  00652		 |$LN195@InfoQueryC@3|
  00652	0ced		 DCB         0xc
  00653		 |$LN196@InfoQueryC@3|
  00653	14ed		 DCB         0x14
  00654		 |$LN197@InfoQueryC@3|
  00654	1ced		 DCB         0x1c
  00655		 |$LN198@InfoQueryC@3|
  00655	28ed		 DCB         0x28
  00656		 |$LN199@InfoQueryC@3|
  00656	34ed		 DCB         0x34
  00657		 |$LN200@InfoQueryC@3|
  00657	40ed		 DCB         0x40
  00658		 |$LN43@InfoQueryC@3|

; 904  :         case 0:  pParsedCSD->VDDWriteCurrentMin = 1;   break;

  00658	e1c592bc	 strh        r9, [r5, #0x2C]
  0065c	ea000010	 b           |$LN44@InfoQueryC@3|
  00660		 |$LN41@InfoQueryC@3|

; 905  :         case 1:  pParsedCSD->VDDWriteCurrentMin = 1;   break;
; 906  :         case 2:  pParsedCSD->VDDWriteCurrentMin = 5;   break;

  00660	e1c5b2bc	 strh        r11, [r5, #0x2C]
  00664	ea00000e	 b           |$LN44@InfoQueryC@3|
  00668		 |$LN40@InfoQueryC@3|

; 907  :         case 3:  pParsedCSD->VDDWriteCurrentMin = 10;  break;

  00668	e1c542bc	 strh        r4, [r5, #0x2C]
  0066c	ea00000c	 b           |$LN44@InfoQueryC@3|
  00670		 |$LN39@InfoQueryC@3|

; 908  :         case 4:  pParsedCSD->VDDWriteCurrentMin = 25;  break;

  00670	e3a03019	 mov         r3, #0x19
  00674	e1c532bc	 strh        r3, [r5, #0x2C]
  00678	ea000009	 b           |$LN44@InfoQueryC@3|
  0067c		 |$LN38@InfoQueryC@3|

; 909  :         case 5:  pParsedCSD->VDDWriteCurrentMin = 35;  break;

  0067c	e3a03023	 mov         r3, #0x23
  00680	e1c532bc	 strh        r3, [r5, #0x2C]
  00684	ea000006	 b           |$LN44@InfoQueryC@3|
  00688		 |$LN37@InfoQueryC@3|

; 910  :         case 6:  pParsedCSD->VDDWriteCurrentMin = 60;  break;

  00688	e3a0303c	 mov         r3, #0x3C
  0068c	e1c532bc	 strh        r3, [r5, #0x2C]
  00690	ea000003	 b           |$LN44@InfoQueryC@3|
  00694		 |$LN36@InfoQueryC@3|

; 911  :         case 7:  pParsedCSD->VDDWriteCurrentMin = 100; break;

  00694	e3a03064	 mov         r3, #0x64
  00698	e1c532bc	 strh        r3, [r5, #0x2C]
  0069c	ea000000	 b           |$LN44@InfoQueryC@3|
  006a0		 |$LN35@InfoQueryC@3|

; 912  :         default: pParsedCSD->VDDWriteCurrentMin = 0;   break;

  006a0	e1c582bc	 strh        r8, [r5, #0x2C]
  006a4		 |$LN44@InfoQueryC@3|

; 913  :     }
; 914  : 
; 915  : 
; 916  :     // VDD Read Current Maximum
; 917  :     pParsedCSD->VDDReadCurrentMax = (USHORT)GET_BIT_SLICE_FROM_CSD(pCSD,SD_CSD_R_CURR_MAX_BIT_SLICE, 
; 918  :         SD_CSD_R_CURR_MAX_SLICE_SIZE);

  006a4	e3a03038	 mov         r3, #0x38
  006a8	e3a02010	 mov         r2, #0x10
  006ac	e28710b6	 add         r1, r7, #0xB6
  006b0	e1a00006	 mov         r0, r6
  006b4	e58da000	 str         r10, [sp]
  006b8	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  006bc	e1a02800	 mov         r2, r0, lsl #16
  006c0	e1a02822	 mov         r2, r2, lsr #16
  006c4	e1c522ba	 strh        r2, [r5, #0x2A]

; 919  : 
; 920  :     switch( pParsedCSD->VDDReadCurrentMax ) {

  006c8	e3520007	 cmp         r2, #7
  006cc	e3a0102d	 mov         r1, #0x2D
  006d0	e3a00050	 mov         r0, #0x50
  006d4	8a000017	 bhi         |$LN24@InfoQueryC@3|
  006d8	e28f3004	 add         r3, pc, #4
  006dc	e7d33002	 ldrb        r3, [r3, +r2]
  006e0	e08ff003	 add         pc, pc, r3
  006e4		 |$LN202@InfoQueryC@3|
  006e4		 |$LN201@InfoQueryC@3|
  006e4		 |$LN203@InfoQueryC@3|
  006e4	04ed		 DCB         0x4
  006e5		 |$LN204@InfoQueryC@3|
  006e5	0ced		 DCB         0xc
  006e6		 |$LN205@InfoQueryC@3|
  006e6	14ed		 DCB         0x14
  006e7		 |$LN206@InfoQueryC@3|
  006e7	1ced		 DCB         0x1c
  006e8		 |$LN207@InfoQueryC@3|
  006e8	28ed		 DCB         0x28
  006e9		 |$LN208@InfoQueryC@3|
  006e9	34ed		 DCB         0x34
  006ea		 |$LN209@InfoQueryC@3|
  006ea	3ced		 DCB         0x3c
  006eb		 |$LN210@InfoQueryC@3|
  006eb	44ed		 DCB         0x44
  006ec		 |$LN32@InfoQueryC@3|

; 921  :         case 0:  pParsedCSD->VDDReadCurrentMax = 1;   break;

  006ec	e1c592ba	 strh        r9, [r5, #0x2A]
  006f0	ea000011	 b           |$LN33@InfoQueryC@3|
  006f4		 |$LN31@InfoQueryC@3|

; 922  :         case 1:  pParsedCSD->VDDReadCurrentMax = 5;   break;

  006f4	e1c5b2ba	 strh        r11, [r5, #0x2A]
  006f8	ea00000f	 b           |$LN33@InfoQueryC@3|
  006fc		 |$LN30@InfoQueryC@3|

; 923  :         case 2:  pParsedCSD->VDDReadCurrentMax = 10;  break;

  006fc	e1c542ba	 strh        r4, [r5, #0x2A]
  00700	ea00000d	 b           |$LN33@InfoQueryC@3|
  00704		 |$LN29@InfoQueryC@3|

; 924  :         case 3:  pParsedCSD->VDDReadCurrentMax = 25;  break;

  00704	e3a03019	 mov         r3, #0x19
  00708	e1c532ba	 strh        r3, [r5, #0x2A]
  0070c	ea00000a	 b           |$LN33@InfoQueryC@3|
  00710		 |$LN28@InfoQueryC@3|

; 925  :         case 4:  pParsedCSD->VDDReadCurrentMax = 35;  break;

  00710	e3a03023	 mov         r3, #0x23
  00714	e1c532ba	 strh        r3, [r5, #0x2A]
  00718	ea000007	 b           |$LN33@InfoQueryC@3|
  0071c		 |$LN27@InfoQueryC@3|

; 926  :         case 5:  pParsedCSD->VDDReadCurrentMax = 45;  break;

  0071c	e1c512ba	 strh        r1, [r5, #0x2A]
  00720	ea000005	 b           |$LN33@InfoQueryC@3|
  00724		 |$LN26@InfoQueryC@3|

; 927  :         case 6:  pParsedCSD->VDDReadCurrentMax = 80;  break;

  00724	e1c502ba	 strh        r0, [r5, #0x2A]
  00728	ea000003	 b           |$LN33@InfoQueryC@3|
  0072c		 |$LN25@InfoQueryC@3|

; 928  :         case 7:  pParsedCSD->VDDReadCurrentMax = 200; break;

  0072c	e3a030c8	 mov         r3, #0xC8
  00730	e1c532ba	 strh        r3, [r5, #0x2A]
  00734	ea000000	 b           |$LN33@InfoQueryC@3|
  00738		 |$LN24@InfoQueryC@3|

; 929  :         default: pParsedCSD->VDDReadCurrentMax = 0;   break;

  00738	e1c582ba	 strh        r8, [r5, #0x2A]
  0073c		 |$LN33@InfoQueryC@3|

; 930  :     }
; 931  : 
; 932  : 
; 933  :     // VDD Write Current Maximum
; 934  :     pParsedCSD->VDDWriteCurrentMax = (USHORT)GET_BIT_SLICE_FROM_CSD(pCSD,SD_CSD_W_CURR_MAX_BIT_SLICE, 
; 935  :         SD_CSD_W_CURR_MAX_SLICE_SIZE);

  0073c	e3a03032	 mov         r3, #0x32
  00740	e3a02010	 mov         r2, #0x10
  00744	e28710b6	 add         r1, r7, #0xB6
  00748	e1a00006	 mov         r0, r6
  0074c	e58da000	 str         r10, [sp]
  00750	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  00754	e1a02800	 mov         r2, r0, lsl #16
  00758	e1a02822	 mov         r2, r2, lsr #16
  0075c	e1c522be	 strh        r2, [r5, #0x2E]

; 936  : 
; 937  :     switch( pParsedCSD->VDDWriteCurrentMax ) {

  00760	e3520007	 cmp         r2, #7
  00764	8a000019	 bhi         |$LN13@InfoQueryC@3|
  00768	e28f3004	 add         r3, pc, #4
  0076c	e7d33002	 ldrb        r3, [r3, +r2]
  00770	e08ff003	 add         pc, pc, r3
  00774		 |$LN212@InfoQueryC@3|
  00774		 |$LN211@InfoQueryC@3|
  00774		 |$LN213@InfoQueryC@3|
  00774	04ed		 DCB         0x4
  00775		 |$LN214@InfoQueryC@3|
  00775	0ced		 DCB         0xc
  00776		 |$LN215@InfoQueryC@3|
  00776	14ed		 DCB         0x14
  00777		 |$LN216@InfoQueryC@3|
  00777	1ced		 DCB         0x1c
  00778		 |$LN217@InfoQueryC@3|
  00778	28ed		 DCB         0x28
  00779		 |$LN218@InfoQueryC@3|
  00779	34ed		 DCB         0x34
  0077a		 |$LN219@InfoQueryC@3|
  0077a	40ed		 DCB         0x40
  0077b		 |$LN220@InfoQueryC@3|
  0077b	4ced		 DCB         0x4c
  0077c		 |$LN21@InfoQueryC@3|

; 938  :         case 0:  pParsedCSD->VDDWriteCurrentMax = 1;   break;

  0077c	e1c592be	 strh        r9, [r5, #0x2E]
  00780	ea000013	 b           |$LN145@InfoQueryC@3|
  00784		 |$LN20@InfoQueryC@3|

; 939  :         case 1:  pParsedCSD->VDDWriteCurrentMax = 5;   break;

  00784	e1c5b2be	 strh        r11, [r5, #0x2E]
  00788	ea000011	 b           |$LN145@InfoQueryC@3|
  0078c		 |$LN19@InfoQueryC@3|

; 940  :         case 2:  pParsedCSD->VDDWriteCurrentMax = 10;  break;

  0078c	e1c542be	 strh        r4, [r5, #0x2E]
  00790	ea00000f	 b           |$LN145@InfoQueryC@3|
  00794		 |$LN18@InfoQueryC@3|

; 941  :         case 3:  pParsedCSD->VDDWriteCurrentMax = 25;  break;

  00794	e3a03019	 mov         r3, #0x19
  00798	e1c532be	 strh        r3, [r5, #0x2E]
  0079c	ea00000c	 b           |$LN145@InfoQueryC@3|
  007a0		 |$LN17@InfoQueryC@3|

; 942  :         case 4:  pParsedCSD->VDDWriteCurrentMax = 35;  break;

  007a0	e3a03023	 mov         r3, #0x23
  007a4	e1c532be	 strh        r3, [r5, #0x2E]
  007a8	ea000009	 b           |$LN145@InfoQueryC@3|
  007ac		 |$LN16@InfoQueryC@3|

; 943  :         case 5:  pParsedCSD->VDDWriteCurrentMax = 45;  break;

  007ac	e3a0302d	 mov         r3, #0x2D
  007b0	e1c532be	 strh        r3, [r5, #0x2E]
  007b4	ea000006	 b           |$LN145@InfoQueryC@3|
  007b8		 |$LN15@InfoQueryC@3|

; 944  :         case 6:  pParsedCSD->VDDWriteCurrentMax = 80;  break;

  007b8	e3a03050	 mov         r3, #0x50
  007bc	e1c532be	 strh        r3, [r5, #0x2E]
  007c0	ea000003	 b           |$LN145@InfoQueryC@3|
  007c4		 |$LN14@InfoQueryC@3|

; 945  :         case 7:  pParsedCSD->VDDWriteCurrentMax = 200; break;

  007c4	e3a040c8	 mov         r4, #0xC8
  007c8	e1c542be	 strh        r4, [r5, #0x2E]
  007cc	ea000001	 b           |$LN22@InfoQueryC@3|
  007d0		 |$LN13@InfoQueryC@3|

; 946  :         default: pParsedCSD->VDDWriteCurrentMax = 0;   break;

  007d0	e1c582be	 strh        r8, [r5, #0x2E]
  007d4		 |$LN145@InfoQueryC@3|
  007d4	e3a040c8	 mov         r4, #0xC8
  007d8		 |$LN22@InfoQueryC@3|

; 947  :     }
; 948  : 
; 949  : 
; 950  :     pParsedCSD->WriteSpeedFactor = (UCHAR)GET_BIT_SLICE_FROM_CSD(pCSD,SD_CSD_R2W_FACTOR_BIT_SLICE, 
; 951  :         SD_CSD_R2W_FACTOR_SLICE_SIZE);

  007d8	e3a0301a	 mov         r3, #0x1A
  007dc	e3a02010	 mov         r2, #0x10
  007e0	e28710b6	 add         r1, r7, #0xB6
  007e4	e1a00006	 mov         r0, r6
  007e8	e58da000	 str         r10, [sp]
  007ec	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  007f0	e5c50034	 strb        r0, [r5, #0x34]

; 952  : 
; 953  :     // For CSD Version 2.0 above is wrong the following code correct them.
; 954  :     if (Device_SD_Memory == m_DeviceType && pParsedCSD->CSDVersion == SD_CSD_VERSION_CODE_2_0 ) { 

  007f4	e5963494	 ldr         r3, [r6, #0x494]
  007f8	e3530002	 cmp         r3, #2
  007fc	1a000019	 bne         |$LN12@InfoQueryC@3|
  00800	e5d53000	 ldrb        r3, [r5]
  00804	e3530001	 cmp         r3, #1
  00808	1a000016	 bne         |$LN12@InfoQueryC@3|

; 955  :         // SD Physical Layer Spec(2.0) 5.3.3
; 956  :         ASSERT(pParsedCSD->MaxReadBlockLength==0x200);
; 957  :         ASSERT(pParsedCSD->MaxWriteBlockLength==0x200);
; 958  :         // THis field no long exist in SD Memory 2.0 So we made them up.
; 959  :         pParsedCSD->VDDReadCurrentMin = 0;
; 960  :         pParsedCSD->VDDWriteCurrentMin = 0;
; 961  :         pParsedCSD->VDDReadCurrentMax = 200;
; 962  :         pParsedCSD->VDDWriteCurrentMax = 200 ;
; 963  :         // C_SIZE is different from 1.0.
; 964  :         m_SDCardInfo.SDMMCInformation.ullDeviceSize = (ULONGLONG)GET_BIT_SLICE_FROM_CSD(pCSD, SD_CSD20_CSIZE_BIT_SLICE,  SD_CSD20_CSIZE_SLICE_SIZE)
; 965  :             *0x200*0x400; 

  0080c	e3a03016	 mov         r3, #0x16
  00810	e58d3000	 str         r3, [sp]
  00814	e3a03030	 mov         r3, #0x30
  00818	e3a02010	 mov         r2, #0x10
  0081c	e28710b6	 add         r1, r7, #0xB6
  00820	e1a00006	 mov         r0, r6
  00824	e1c582b8	 strh        r8, [r5, #0x28]
  00828	e1c582bc	 strh        r8, [r5, #0x2C]
  0082c	e1c542ba	 strh        r4, [r5, #0x2A]
  00830	e1c542be	 strh        r4, [r5, #0x2E]
  00834	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  00838	e3a03b01	 mov         r3, #1, 22
  0083c	e0832390	 umull       r2, r3, r0, r3
  00840	e1a03483	 mov         r3, r3, lsl #9
  00844	e1833ba2	 orr         r3, r3, r2, lsr #23
  00848	e586353c	 str         r3, [r6, #0x53C]

; 966  :         // We had no choic but provide low portion of value for BC. The Full value can get from Card Extention function.
; 967  :         pParsedCSD->DeviceSize = (ULONG)(m_SDCardInfo.SDMMCInformation.ullDeviceSize/0x200); // return as block size.

  0084c	e1a01003	 mov         r1, r3
  00850	e1a03482	 mov         r3, r2, lsl #9
  00854	e5863538	 str         r3, [r6, #0x538]
  00858	e1a02003	 mov         r2, r3
  0085c	e1a03b81	 mov         r3, r1, lsl #23
  00860	e18334a2	 orr         r3, r3, r2, lsr #9
  00864	e5853024	 str         r3, [r5, #0x24]
  00868		 |$LN12@InfoQueryC@3|

; 968  :     }
; 969  : 
; 970  : 
; 971  :     pParsedCSD->WriteSpeedFactor = 1 << pParsedCSD->WriteSpeedFactor;

  00868	e5d52034	 ldrb        r2, [r5, #0x34]
  0086c	e3a01001	 mov         r1, #1

; 972  : 
; 973  : 
; 974  :     fileFormatGroup = (UCHAR)GET_BIT_SLICE_FROM_CSD(pCSD,SD_CSD_FILE_GROUP_BIT_SLICE, 
; 975  :         SD_CSD_FILE_GROUP_SLICE_SIZE);

  00870	e3a0300f	 mov         r3, #0xF
  00874	e1a01211	 mov         r1, r1, lsl r2
  00878	e3a02010	 mov         r2, #0x10
  0087c	e5c51034	 strb        r1, [r5, #0x34]
  00880	e28710b6	 add         r1, r7, #0xB6
  00884	e1a00006	 mov         r0, r6
  00888	e58d9000	 str         r9, [sp]
  0088c	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  00890	e1a04000	 mov         r4, r0

; 976  : 
; 977  :     fileFormat  = (UCHAR)GET_BIT_SLICE_FROM_CSD(pCSD,SD_CSD_FILE_FORMAT_BIT_SLICE, 
; 978  :         SD_CSD_FILE_FORMAT_SLICE_SIZE);

  00894	e3a0e002	 mov         lr, #2
  00898	e1a00006	 mov         r0, r6
  0089c	e3a0300a	 mov         r3, #0xA
  008a0	e3a02010	 mov         r2, #0x10
  008a4	e28710b6	 add         r1, r7, #0xB6
  008a8	e58de000	 str         lr, [sp]
  008ac	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|

; 979  : 
; 980  :     if( fileFormatGroup == 0 ) {

  008b0	e21430ff	 ands        r3, r4, #0xFF

; 1052 : }

  008b4	1a00000c	 bne         |$LN11@InfoQueryC@3|

; 981  :         switch( fileFormat ) {

  008b8	e21030ff	 ands        r3, r0, #0xFF
  008bc	0a000008	 beq         |$LN8@InfoQueryC@3|
  008c0	e3530001	 cmp         r3, #1
  008c4	0a000004	 beq         |$LN7@InfoQueryC@3|
  008c8	e3530002	 cmp         r3, #2

; 984  :             case 2:  pParsedCSD->FileSystem = SD_FS_UNIVERSAL;              break;
; 985  :             default: pParsedCSD->FileSystem = SD_FS_OTHER;                  break;

  008cc	1a000006	 bne         |$LN11@InfoQueryC@3|
  008d0	e3a03002	 mov         r3, #2
  008d4	e585303c	 str         r3, [r5, #0x3C]
  008d8	ea000004	 b           |$LN4@InfoQueryC@3|
  008dc		 |$LN7@InfoQueryC@3|

; 983  :             case 1:  pParsedCSD->FileSystem = SD_FS_FAT_NO_PARTITION_TABLE; break;

  008dc	e585903c	 str         r9, [r5, #0x3C]
  008e0	ea000002	 b           |$LN4@InfoQueryC@3|
  008e4		 |$LN8@InfoQueryC@3|

; 982  :             case 0:  pParsedCSD->FileSystem = SD_FS_FAT_PARTITION_TABLE;    break;

  008e4	e585803c	 str         r8, [r5, #0x3C]

; 986  :         }
; 987  :     } else {

  008e8	ea000000	 b           |$LN4@InfoQueryC@3|
  008ec		 |$LN11@InfoQueryC@3|

; 988  :         pParsedCSD->FileSystem = SD_FS_OTHER;

  008ec	e585a03c	 str         r10, [r5, #0x3C]
  008f0		 |$LN4@InfoQueryC@3|

; 989  :     }
; 990  : 
; 991  :     // For MMC cards the WP Group Size is now 5 bits rather than 7, Erase sector size 
; 992  :     // is calculated from 2 5bit fields. Erase block enable does not exist for MMC cards.
; 993  :     if( m_DeviceType == Device_MMC ) {

  008f0	e5963494	 ldr         r3, [r6, #0x494]

; 994  : 
; 995  :         UCHAR eraseGroupSize, eraseGroupMult;
; 996  : 
; 997  :         // Set EraseBlockEnable to FALSE
; 998  :         pParsedCSD->EraseBlockEnable = FALSE;
; 999  : 
; 1000 :         // Calculate Erase Sector Size from the Erase Group Size and
; 1001 :         // Erase Group Mult fields
; 1002 :         eraseGroupSize = (UCHAR)GET_BIT_SLICE_FROM_CSD(pCSD,MMC_CSD_ER_GRP_SIZE_BIT_SLICE, 
; 1003 :             MMC_CSD_ER_GRP_SIZE_SLICE_SIZE);

  008f4	e3a02010	 mov         r2, #0x10
  008f8	e28710b6	 add         r1, r7, #0xB6
  008fc	e3530001	 cmp         r3, #1
  00900	e1a00006	 mov         r0, r6
  00904	1a000023	 bne         |$LN3@InfoQueryC@3|
  00908	e3a0302a	 mov         r3, #0x2A
  0090c	e5c58030	 strb        r8, [r5, #0x30]
  00910	e58db000	 str         r11, [sp]
  00914	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  00918	e1a04000	 mov         r4, r0

; 1004 : 
; 1005 :         eraseGroupMult = (UCHAR)GET_BIT_SLICE_FROM_CSD(pCSD,MMC_CSD_ER_GRP_MULT_BIT_SLICE, 
; 1006 :             MMC_CSD_ER_GRP_MULT_SLICE_SIZE);

  0091c	e1a00006	 mov         r0, r6
  00920	e3a03025	 mov         r3, #0x25
  00924	e3a02010	 mov         r2, #0x10
  00928	e28710b6	 add         r1, r7, #0xB6
  0092c	e58db000	 str         r11, [sp]
  00930	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|

; 1007 : 
; 1008 : 
; 1009 :         pParsedCSD->EraseSectorSize = (eraseGroupSize+1)*(eraseGroupMult+1);

  00934	e2802001	 add         r2, r0, #1
  00938	e2843001	 add         r3, r4, #1
  0093c	e0010392	 mul         r1, r2, r3

; 1010 : 
; 1011 :         pParsedCSD->WPGroupSize = (UCHAR)GET_BIT_SLICE_FROM_CSD(pCSD,MMC_CSD_WP_GROUP_SIZE_BIT_SLICE, 
; 1012 :             MMC_CSD_WP_GROUP_SIZE_SLICE_SIZE);

  00940	e3a03020	 mov         r3, #0x20
  00944	e3a02010	 mov         r2, #0x10
  00948	e5c51031	 strb        r1, [r5, #0x31]
  0094c	e28710b6	 add         r1, r7, #0xB6
  00950	e1a00006	 mov         r0, r6
  00954	e58db000	 str         r11, [sp]
  00958	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|

; 1013 : 
; 1014 :         pParsedCSD->WPGroupSize++;
; 1015 : 
; 1016 : #ifdef BSP_EMMCFEATURE
; 1017 :         if (  (pParsedCSD->CSDVersion == SD_CSD_VERSION_CODE_2_0)
; 1018 :             &&(m_CachedRegisters.CSD[15]&EMMC_CSD_SPEC_VERSION_VALUE)
; 1019 :             &&(Device_MMC == m_DeviceType)) 

  0095c	e5d52000	 ldrb        r2, [r5]
  00960	e2803001	 add         r3, r0, #1
  00964	e5c53032	 strb        r3, [r5, #0x32]
  00968	e3520001	 cmp         r2, #1
  0096c	1a000021	 bne         |$LN1@InfoQueryC@3|
  00970	e5d634c5	 ldrb        r3, [r6, #0x4C5]
  00974	e3130010	 tst         r3, #0x10
  00978	0a00001e	 beq         |$LN1@InfoQueryC@3|
  0097c	e5963494	 ldr         r3, [r6, #0x494]
  00980	e3530001	 cmp         r3, #1
  00984	1a00001b	 bne         |$LN1@InfoQueryC@3|

; 1020 :             {
; 1021 :             pParsedCSD->DeviceSize = EmulateSectorNumberByProdutID(); 

  00988	e1a00006	 mov         r0, r6
  0098c	eb000000	 bl          |?EmulateSectorNumberByProdutID@CSDDevice@@QAAKXZ|
  00990	e5850024	 str         r0, [r5, #0x24]

; 1022 :             DEBUGMSG(SDCARD_ZONE_FUNC,(TEXT("SDCardInfoQuery::eMMC emulated as SDHC,Sector# = %d\r\n"),pParsedCSD->DeviceSize));
; 1023 :             }	
; 1024 : #endif
; 1025 :     } else {

  00994	ea000017	 b           |$LN1@InfoQueryC@3|
  00998		 |$LN3@InfoQueryC@3|

; 1026 : 
; 1027 :         // Erase by block size enabled
; 1028 :         pParsedCSD->EraseBlockEnable = GET_BIT_SLICE_FROM_CSD(pCSD,SD_CSD_ERASE_BL_ENABLE_BIT_SLICE, 
; 1029 :             SD_CSD_ERASE_BL_ENABLE_SLICE_SIZE)
; 1030 :             ? TRUE:FALSE;

  00998	e3a0302e	 mov         r3, #0x2E
  0099c	e58d9000	 str         r9, [sp]
  009a0	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  009a4	e3500000	 cmp         r0, #0
  009a8	13a0e001	 movne       lr, #1
  009ac	03a0e000	 moveq       lr, #0

; 1031 : 
; 1032 :         // Erase Sector Size
; 1033 : 
; 1034 :         pParsedCSD->EraseSectorSize = (UCHAR)GET_BIT_SLICE_FROM_CSD(pCSD,SD_CSD_ERASE_SECT_SIZE_BIT_SLICE, 
; 1035 :             SD_CSD_ERASE_SECT_SIZE_SLICE_SIZE);

  009b0	e3a04007	 mov         r4, #7
  009b4	e3a03027	 mov         r3, #0x27
  009b8	e3a02010	 mov         r2, #0x10
  009bc	e28710b6	 add         r1, r7, #0xB6
  009c0	e1a00006	 mov         r0, r6
  009c4	e5c5e030	 strb        lr, [r5, #0x30]
  009c8	e58d4000	 str         r4, [sp]
  009cc	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|

; 1036 : 
; 1037 : 
; 1038 :         pParsedCSD->EraseSectorSize++;

  009d0	e2803001	 add         r3, r0, #1
  009d4	e5c53031	 strb        r3, [r5, #0x31]

; 1039 : 
; 1040 : 
; 1041 :         // Write Protect Group Size
; 1042 :         pParsedCSD->WPGroupSize = (UCHAR)GET_BIT_SLICE_FROM_CSD(pCSD,SD_CSD_WP_GROUP_SIZE_BIT_SLICE, 
; 1043 :             SD_CSD_WP_GROUP_SIZE_SLICE_SIZE);

  009d8	e3a03020	 mov         r3, #0x20
  009dc	e3a02010	 mov         r2, #0x10
  009e0	e28710b6	 add         r1, r7, #0xB6
  009e4	e1a00006	 mov         r0, r6
  009e8	e58d4000	 str         r4, [sp]
  009ec	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|

; 1044 : 
; 1045 :         pParsedCSD->WPGroupSize++;

  009f0	e2803001	 add         r3, r0, #1
  009f4	e5c53032	 strb        r3, [r5, #0x32]
  009f8		 |$LN1@InfoQueryC@3|

; 1046 :     }
; 1047 : 
; 1048 :     memcpy(pParsedCSD->RawCSDRegister, m_CachedRegisters.CSD, SD_CSD_REGISTER_SIZE );

  009f8	e2863b01	 add         r3, r6, #1, 22
  009fc	e28310b6	 add         r1, r3, #0xB6
  00a00	e2850040	 add         r0, r5, #0x40
  00a04	e3a02010	 mov         r2, #0x10
  00a08	eb000000	 bl          memcpy

; 1049 :     DumpParsedCSDRegisters(pParsedCSD);
; 1050 : 
; 1051 :     return SD_API_STATUS_SUCCESS;

  00a0c	e3a00000	 mov         r0, #0
  00a10	ea000000	 b           |$LN105@InfoQueryC@3|
  00a14		 |$LN101@InfoQueryC@3|

; 701  :               }
; 702  : #else
; 703  :           if (pParsedCSD->CSDVersion > MMC_CSD_VERSION_CODE_SUPPORTED) 
; 704  :               {
; 705  :               DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDCardInfoQuery: MMC CSD version : %d currently not supported \n"),pParsedCSD->CSDVersion));
; 706  : //            DEBUGCHK(FALSE);
; 707  : //            return SD_API_STATUS_DEVICE_UNSUPPORTED;
; 708  :               }			        
; 709  : #endif		
; 710  :     } else {
; 711  :         DEBUGCHK(FALSE);
; 712  :         return SD_API_STATUS_INVALID_PARAMETER;

  00a14	e3a0011f	 mov         r0, #0x1F, 2
  00a18		 |$LN105@InfoQueryC@3|

; 1052 : }

  00a18	e28dd004	 add         sp, sp, #4
  00a1c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00a20	e12fff1e	 bx          lr
  00a24		 |$LN224@InfoQueryC@3|
  00a24		 |$LN225@InfoQueryC@3|
  00a24	3ff4cccc	 DCD         0x3ff4cccc
  00a28		 |$LN226@InfoQueryC@3|
  00a28	cccccccd	 DCD         0xcccccccd
  00a2c		 |$LN227@InfoQueryC@3|
  00a2c	3ff33333	 DCD         0x3ff33333
  00a30		 |$LN228@InfoQueryC@3|
  00a30	33333333	 DCD         0x33333333
  00a34		 |$M50530|

			 ENDP  ; |?InfoQueryCSD@CSDDevice@@IAAJPAXK@Z|, CSDDevice::InfoQueryCSD

	EXPORT	|?SDCardInfoQuery_I@CSDDevice@@UAAJW4SD_INFO_TYPE@@PAXK@Z| ; CSDDevice::SDCardInfoQuery_I
	IMPORT	|?SwitchFunction@CSDDevice@@IAAJPAU_SD_CARD_SWITCH_FUNCTION@@H@Z| ; CSDDevice::SwitchFunction

  00000			 AREA	 |.pdata|, PDATA
|$T50601| DCD	|$LN59@SDCardInfo|
	DCD	0xc0009504

  00000			 AREA	 |.pdata|, PDATA
|$T50603| DCD	|$LN33@SDCardInfo|
	DCD	0x40000301

  00000			 AREA	 |.xdata|, DATA
|$T50599| DCD	0x1
	DCD	|$LN37@SDCardInfo|
	DCD	|$LN38@SDCardInfo|
	DCD	|$LN33@SDCardInfo|
	DCD	|$LN34@SDCardInfo|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T50599|

  00008		 |?SDCardInfoQuery_I@CSDDevice@@UAAJW4SD_INFO_TYPE@@PAXK@Z| PROC ; CSDDevice::SDCardInfoQuery_I

; 1180 : {

  00008		 |$LN59@SDCardInfo|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d5830	 stmdb       sp!, {r4, r5, r11, r12, lr}
  00010	e28db014	 add         r11, sp, #0x14
  00014	e24dd054	 sub         sp, sp, #0x54
  00018		 |$LN57@SDCardInfo|
  00018	e1a04002	 mov         r4, r2

; 1181 :     DEBUGMSG(SDCARD_ZONE_FUNC, (TEXT("SDCard: +SDCardInfoQuery\n")));
; 1182 :     SD_API_STATUS status = SD_API_STATUS_INVALID_PARAMETER;

  0001c	e3a0511f	 mov         r5, #0x1F, 2
  00020		 |$LN37@SDCardInfo|

; 1183 :     __try {
; 1184 :         switch (InfoType) {

  00020	e2412001	 sub         r2, r1, #1
  00024	e352000c	 cmp         r2, #0xC
  00028	8a000082	 bhi         |$LN38@SDCardInfo|
  0002c	e1a01082	 mov         r1, r2, lsl #1
  00030	e081100f	 add         r1, r1, pc
  00034	e1d110b4	 ldrh        r1, [r1, #4]
  00038	e08ff001	 add         pc, pc, r1
  0003c		 |$LN62@SDCardInfo|
  0003c		 |$LN61@SDCardInfo|
  0003c		 |$LN63@SDCardInfo|
  0003c	0018		 DCW         0x18
  0003e		 |$LN64@SDCardInfo|
  0003e	0038		 DCW         0x38
  00040		 |$LN65@SDCardInfo|
  00040	0058		 DCW         0x58
  00042		 |$LN66@SDCardInfo|
  00042	01f8		 DCW         0x1f8
  00044		 |$LN67@SDCardInfo|
  00044	0084		 DCW         0x84
  00046		 |$LN68@SDCardInfo|
  00046	0120		 DCW         0x120
  00048		 |$LN69@SDCardInfo|
  00048	013c		 DCW         0x13c
  0004a		 |$LN70@SDCardInfo|
  0004a	015c		 DCW         0x15c
  0004c		 |$LN71@SDCardInfo|
  0004c	017c		 DCW         0x17c
  0004e		 |$LN72@SDCardInfo|
  0004e	019c		 DCW         0x19c
  00050		 |$LN73@SDCardInfo|
  00050	01f8		 DCW         0x1f8
  00052		 |$LN74@SDCardInfo|
  00052	0100		 DCW         0x100
  00054		 |$LN75@SDCardInfo|
  00054	01d4		 DCW         0x1d4
  00056		 |$LN78@SDCardInfo|

; 1253 :     }__except(SDProcessException(GetExceptionInformation())) {

  00056	01d4		 DCW         0x1d4
  00058		 |$LN25@SDCardInfo|

; 1185 :           case SD_INFO_REGISTER_OCR:
; 1186 :             break;
; 1187 :           case SD_INFO_REGISTER_CID:
; 1188 :             if (StructureSize>=sizeof(SD_PARSED_REGISTER_CID) && pCardInfo!=NULL) {

  00058	e3530028	 cmp         r3, #0x28
  0005c	3a000075	 bcc         |$LN38@SDCardInfo|
  00060	e3540000	 cmp         r4, #0
  00064	0a000073	 beq         |$LN38@SDCardInfo|

; 1189 :                 status = InfoQueryCID(pCardInfo, StructureSize);

  00068	e1a02003	 mov         r2, r3
  0006c	e1a01004	 mov         r1, r4
  00070	eb000000	 bl          |?InfoQueryCID@CSDDevice@@IAAJPAXK@Z|

; 1190 :             }
; 1191 :             break;

  00074	ea00006d	 b           |$LN55@SDCardInfo|
  00078		 |$LN23@SDCardInfo|

; 1192 :           case  SD_INFO_REGISTER_CSD: 
; 1193 :             if (StructureSize>=sizeof(SD_PARSED_REGISTER_CSD) && pCardInfo!=NULL ) {

  00078	e3530050	 cmp         r3, #0x50
  0007c	3a00006d	 bcc         |$LN38@SDCardInfo|
  00080	e3540000	 cmp         r4, #0
  00084	0a00006b	 beq         |$LN38@SDCardInfo|

; 1194 :                 status = InfoQueryCSD(pCardInfo, StructureSize);

  00088	e1a02003	 mov         r2, r3
  0008c	e1a01004	 mov         r1, r4
  00090	eb000000	 bl          |?InfoQueryCSD@CSDDevice@@IAAJPAXK@Z|

; 1195 :             }
; 1196 :             break;

  00094	ea000065	 b           |$LN55@SDCardInfo|
  00098		 |$LN21@SDCardInfo|

; 1197 :           case SD_INFO_REGISTER_RCA:
; 1198 :             if (StructureSize>=sizeof(SD_CARD_RCA) && pCardInfo!=NULL) {

  00098	e3530002	 cmp         r3, #2
  0009c	3a000065	 bcc         |$LN38@SDCardInfo|
  000a0	e3540000	 cmp         r4, #0
  000a4	0a000063	 beq         |$LN38@SDCardInfo|

; 1199 :                 status = InfoQueryRCA(pCardInfo, StructureSize);

  000a8	e2803b01	 add         r3, r0, #1, 22
  000ac	e1d33ab0	 ldrh        r3, [r3, #0xA0]
  000b0	e1a02423	 mov         r2, r3, lsr #8
  000b4	e5c43000	 strb        r3, [r4]
  000b8	e5c42001	 strb        r2, [r4, #1]
  000bc	e3a05000	 mov         r5, #0

; 1200 :             }
; 1201 :             break;

  000c0	ea00005b	 b           |$LN56@SDCardInfo|
  000c4		 |$LN18@SDCardInfo|

; 1202 :           case SD_INFO_REGISTER_IO_OCR:
; 1203 :             break;
; 1204 :           case SD_INFO_CARD_INTERFACE:
; 1205 :             if (StructureSize>=sizeof(SD_CARD_INTERFACE) && pCardInfo!=NULL) {

  000c4	e353000c	 cmp         r3, #0xC
  000c8	3a00005a	 bcc         |$LN38@SDCardInfo|
  000cc	e3540000	 cmp         r4, #0
  000d0	0a000058	 beq         |$LN38@SDCardInfo|

; 1206 :                 SD_CARD_INTERFACE_EX sdCardInterfacEx;
; 1207 :                 status = InfoQueryCardInterface(&sdCardInterfacEx, sizeof(sdCardInterfacEx));

  000d4	e3a02020	 mov         r2, #0x20
  000d8	e24b1054	 sub         r1, r11, #0x54
  000dc	eb000000	 bl          |?InfoQueryCardInterface@CSDDevice@@IAAJPAXK@Z|
  000e0	e1b05000	 movs        r5, r0
  000e4	e50b5068	 str         r5, [r11, #-0x68]

; 1208 :                 if (SD_API_SUCCESS(status)) {

  000e8	4a000052	 bmi         |$LN38@SDCardInfo|

; 1209 :                     *(PSD_CARD_INTERFACE)pCardInfo = ConvertFromEx(sdCardInterfacEx);

  000ec	e24b0034	 sub         r0, r11, #0x34
  000f0	e24b1054	 sub         r1, r11, #0x54
  000f4	e3a02020	 mov         r2, #0x20
  000f8	eb000000	 bl          memcpy
  000fc	e51b3054	 ldr         r3, [r11, #-0x54]
  00100	e3130001	 tst         r3, #1
  00104	e3a02000	 mov         r2, #0
  00108	13a02001	 movne       r2, #1
  0010c	e3130004	 tst         r3, #4
  00110	13a02002	 movne       r2, #2
  00114	e50b2060	 str         r2, [r11, #-0x60]
  00118	e51b1050	 ldr         r1, [r11, #-0x50]
  0011c	e50b105c	 str         r1, [r11, #-0x5C]
  00120	e3130101	 tst         r3, #1, 2
  00124	13a03001	 movne       r3, #1
  00128	03a03000	 moveq       r3, #0
  0012c	e50b3058	 str         r3, [r11, #-0x58]
  00130	e5842000	 str         r2, [r4]
  00134	e5841004	 str         r1, [r4, #4]
  00138	e5843008	 str         r3, [r4, #8]

; 1210 :                 }
; 1211 :             }
; 1212 :             break;

  0013c	ea00003d	 b           |$LN38@SDCardInfo|
  00140		 |$LN15@SDCardInfo|

; 1213 :           case SD_INFO_CARD_INTERFACE_EX:
; 1214 :             if (StructureSize>=sizeof(SD_CARD_INTERFACE_EX) && pCardInfo!=NULL) {

  00140	e3530020	 cmp         r3, #0x20
  00144	3a00003b	 bcc         |$LN38@SDCardInfo|
  00148	e3540000	 cmp         r4, #0
  0014c	0a000039	 beq         |$LN38@SDCardInfo|

; 1215 :                 status = InfoQueryCardInterface((PSD_CARD_INTERFACE_EX)pCardInfo, sizeof(SD_CARD_INTERFACE_EX));

  00150	e3a02020	 mov         r2, #0x20
  00154	e1a01004	 mov         r1, r4
  00158	eb000000	 bl          |?InfoQueryCardInterface@CSDDevice@@IAAJPAXK@Z|

; 1216 :             }
; 1217 :             break;

  0015c	ea000033	 b           |$LN55@SDCardInfo|
  00160		 |$LN13@SDCardInfo|

; 1218 :           case SD_INFO_CARD_STATUS:
; 1219 :             if (StructureSize>=sizeof(SD_CARD_STATUS)&& pCardInfo!=NULL) {

  00160	e3530004	 cmp         r3, #4
  00164	3a000033	 bcc         |$LN38@SDCardInfo|
  00168	e3540000	 cmp         r4, #0
  0016c	0a000031	 beq         |$LN38@SDCardInfo|

; 1220 :                 status = InfoQueryStatus(pCardInfo, StructureSize);

  00170	e1a01004	 mov         r1, r4
  00174	eb000000	 bl          |?GetCardStatus@CSDDevice@@IAAJPAK@Z|

; 1221 :             }
; 1222 :             break;

  00178	ea00002c	 b           |$LN55@SDCardInfo|
  0017c		 |$LN11@SDCardInfo|

; 1223 :           case SD_INFO_SDIO:
; 1224 :             if ( StructureSize>=sizeof(SDIO_CARD_INFO) && pCardInfo!=NULL) {

  0017c	e3530010	 cmp         r3, #0x10
  00180	3a00002c	 bcc         |$LN38@SDCardInfo|
  00184	e3540000	 cmp         r4, #0
  00188	0a00002a	 beq         |$LN38@SDCardInfo|

; 1225 :                 status = InfoQuerySDIOInfo(pCardInfo, StructureSize);

  0018c	e1a02003	 mov         r2, r3
  00190	e1a01004	 mov         r1, r4
  00194	eb000000	 bl          |?InfoQuerySDIOInfo@CSDDevice@@IAAJPAXK@Z|

; 1226 :             }
; 1227 :             break;

  00198	ea000024	 b           |$LN55@SDCardInfo|
  0019c		 |$LN9@SDCardInfo|

; 1228 :           case SD_INFO_HOST_IF_CAPABILITIES:
; 1229 :             if ( StructureSize>=sizeof(SD_CARD_INTERFACE)  && pCardInfo!=NULL) {

  0019c	e353000c	 cmp         r3, #0xC
  001a0	3a000024	 bcc         |$LN38@SDCardInfo|
  001a4	e3540000	 cmp         r4, #0
  001a8	0a000022	 beq         |$LN38@SDCardInfo|

; 1230 :                 status = InfoQueryHostInterface(pCardInfo, StructureSize);

  001ac	e1a02003	 mov         r2, r3
  001b0	e1a01004	 mov         r1, r4
  001b4	eb000000	 bl          |?InfoQueryHostInterface@CSDDevice@@IAAJPAXK@Z|

; 1231 :             }
; 1232 :             break;

  001b8	ea00001c	 b           |$LN55@SDCardInfo|
  001bc		 |$LN7@SDCardInfo|

; 1233 :           case SD_INFO_HOST_BLOCK_CAPABILITY:
; 1234 :             if (StructureSize >= sizeof(SD_HOST_BLOCK_CAPABILITY) && pCardInfo!=NULL) {

  001bc	e3530008	 cmp         r3, #8
  001c0	3a00001c	 bcc         |$LN38@SDCardInfo|
  001c4	e3540000	 cmp         r4, #0
  001c8	0a00001a	 beq         |$LN38@SDCardInfo|

; 1235 :                 status = InfoQueryBlockCaps(pCardInfo, StructureSize);

  001cc	e1a02003	 mov         r2, r3
  001d0	e1a01004	 mov         r1, r4
  001d4	eb000000	 bl          |?InfoQueryBlockCaps@CSDDevice@@IAAJPAXK@Z|

; 1236 :             }
; 1237 :             break;

  001d8	ea000014	 b           |$LN55@SDCardInfo|
  001dc		 |$LN5@SDCardInfo|

; 1238 :           case SD_INFO_HIGH_CAPACITY_SUPPORT:
; 1239 :             if (StructureSize>= sizeof(DWORD) && pCardInfo!=NULL) {

  001dc	e3530004	 cmp         r3, #4
  001e0	3a000014	 bcc         |$LN38@SDCardInfo|
  001e4	e3540000	 cmp         r4, #0
  001e8	0a000012	 beq         |$LN38@SDCardInfo|

; 1240 :                 SD_CARD_INTERFACE_EX sdCardInterfacEx;
; 1241 :                 status = InfoQueryCardInterface(&sdCardInterfacEx, sizeof(sdCardInterfacEx));

  001ec	e3a02020	 mov         r2, #0x20
  001f0	e24b1054	 sub         r1, r11, #0x54
  001f4	eb000000	 bl          |?InfoQueryCardInterface@CSDDevice@@IAAJPAXK@Z|
  001f8	e1b05000	 movs        r5, r0
  001fc	e50b5068	 str         r5, [r11, #-0x68]

; 1242 :                 if (SD_API_SUCCESS(status)) {

  00200	4a00000c	 bmi         |$LN38@SDCardInfo|

; 1243 :                     *(PDWORD)pCardInfo = sdCardInterfacEx.InterfaceModeEx.bit.sdHighCapacity;

  00204	e51b3054	 ldr         r3, [r11, #-0x54]
  00208	e1a03fa3	 mov         r3, r3, lsr #31
  0020c	e5843000	 str         r3, [r4]

; 1244 :                 }
; 1245 :             };
; 1246 :             break;

  00210	ea000008	 b           |$LN38@SDCardInfo|
  00214		 |$LN2@SDCardInfo|

; 1247 :           case SD_INFO_SWITCH_FUNCTION:
; 1248 :             if (StructureSize>= sizeof(SD_CARD_SWITCH_FUNCTION) && pCardInfo!=NULL) {

  00214	e353004c	 cmp         r3, #0x4C
  00218	3a000006	 bcc         |$LN38@SDCardInfo|
  0021c	e3540000	 cmp         r4, #0
  00220	0a000004	 beq         |$LN38@SDCardInfo|

; 1249 :                 status =SwitchFunction((PSD_CARD_SWITCH_FUNCTION)pCardInfo, TRUE);

  00224	e3a02001	 mov         r2, #1
  00228	e1a01004	 mov         r1, r4
  0022c	eb000000	 bl          |?SwitchFunction@CSDDevice@@IAAJPAU_SD_CARD_SWITCH_FUNCTION@@H@Z|
  00230		 |$LN55@SDCardInfo|
  00230	e1a05000	 mov         r5, r0
  00234		 |$LN56@SDCardInfo|
  00234	e50b5068	 str         r5, [r11, #-0x68]
  00238		 |$LN38@SDCardInfo|

; 1250 :             }
; 1251 :             break;
; 1252 :         }

  00238	ea000003	 b           |$LN30@SDCardInfo|
  0023c		 |$LN34@SDCardInfo|

; 1254 :         status = SD_API_STATUS_ACCESS_VIOLATION;

  0023c	e3a05117	 mov         r5, #0x17, 2
  00240	e50b5068	 str         r5, [r11, #-0x68]
  00244	ea000000	 b           |$LN30@SDCardInfo|
  00248		 |$LN54@SDCardInfo|

; 1255 :     };
; 1256 : 
; 1257 :     DEBUGMSG(SDCARD_ZONE_FUNC, (TEXT("SDCard: -SDCardInfoQuery status = %x\n"),status));
; 1258 :     return status;

  00248	e51b5064	 ldr         r5, [r11, #-0x64]
  0024c		 |$LN30@SDCardInfo|

; 1259 : }

  0024c	e1a00005	 mov         r0, r5
  00250	e24bd014	 sub         sp, r11, #0x14
  00254	e89d6830	 ldmia       sp, {r4, r5, r11, sp, lr}
  00258	e12fff1e	 bx          lr

			 ENDP  ; |?SDCardInfoQuery_I@CSDDevice@@UAAJW4SD_INFO_TYPE@@PAXK@Z|, CSDDevice::SDCardInfoQuery_I

  0025c		 |$LN33@SDCardInfo|
  0025c		 |$LN58@SDCardInfo|

; 1253 :     }__except(SDProcessException(GetExceptionInformation())) {

  0025c	e52de004	 str         lr, [sp, #-4]!
  00260		 |$LN36@SDCardInfo|
  00260		 |$LN76@SDCardInfo|
  00260	eb000000	 bl          SDProcessException
  00264		 |$LN35@SDCardInfo|
  00264	e49df004	 ldr         pc, [sp], #4
  00268		 |$LN77@SDCardInfo|
  00268		 |$LN60@SDCardInfo|
	END
