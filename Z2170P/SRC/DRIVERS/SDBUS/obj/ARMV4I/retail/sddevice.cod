; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\Z2170P\SRC\DRIVERS\SDBUS\sddevice.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|?g_FuncRef@CSDDevice@@1KA| [ DATA ]	; CSDDevice::g_FuncRef

  00000			 AREA	 |.bss|, NOINIT
|?g_FuncRef@CSDDevice@@1KA| % 0x4			; CSDDevice::g_FuncRef
	EXPORT	|ResetEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T41128| DCD	|$LN5@ResetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ResetEvent| PROC

; 223  : _inline BOOL ResetEvent(HANDLE h) {

  00000		 |$LN5@ResetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41125|

; 224  : 	return EventModify(h,EVENT_RESET);

  00004	e3a01002	 mov         r1, #2
  00008	eb000000	 bl          EventModify

; 225  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M41126|

			 ENDP  ; |ResetEvent|

	EXPORT	|SetEvent|

  00000			 AREA	 |.pdata|, PDATA
|$T41138| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41135|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M41136|

			 ENDP  ; |SetEvent|

	EXPORT	|GetCurrentProcessId|
	IMPORT	|__GetUserKData|

  00000			 AREA	 |.pdata|, PDATA
|$T41147| DCD	|$LN5@GetCurrent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentProcessId| PROC

; 373  : _inline DWORD GetCurrentProcessId(void) {

  00000		 |$LN5@GetCurrent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41144|

; 374  :     return __GetUserKData (SYSHANDLE_OFFSET + (SH_CURPROC * sizeof(HANDLE)));

  00004	e3a0000c	 mov         r0, #0xC
  00008	eb000000	 bl          __GetUserKData

; 375  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M41145|

			 ENDP  ; |GetCurrentProcessId|

	EXPORT	|?ZeroEntries@CReg@@AAAXXZ|		; CReg::ZeroEntries
; File c:\wince600\public\common\sdk\inc\creg.hxx

  00000			 AREA	 |.pdata|, PDATA
|$T41155| DCD	|$LN5@ZeroEntrie|
	DCD	0x40000600
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ZeroEntries@CReg@@AAAXXZ| PROC	; CReg::ZeroEntries

; 35   : 	void ZeroEntries() {

  00000		 |$LN5@ZeroEntrie|
  00000		 |$M41152|

; 36   : 		m_hKey      = NULL;

  00000	e3a03000	 mov         r3, #0
  00004	e5803000	 str         r3, [r0]

; 37   : 		m_Index     = 0;

  00008	e5803004	 str         r3, [r0, #4]

; 38   : 		m_lpbValue  = NULL;

  0000c	e5803008	 str         r3, [r0, #8]

; 39   : 		m_iValueLen = 0;

  00010	e580300c	 str         r3, [r0, #0xC]

; 40   : 	}

  00014	e12fff1e	 bx          lr
  00018		 |$M41153|

			 ENDP  ; |?ZeroEntries@CReg@@AAAXXZ|, CReg::ZeroEntries

	EXPORT	|??1CReg@@QAA@XZ|			; CReg::~CReg
	IMPORT	|LocalFree|
	IMPORT	|RegCloseKey|

  00000			 AREA	 |.pdata|, PDATA
|$T41163| DCD	|$LN7@CReg|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CReg@@QAA@XZ| PROC			; CReg::~CReg

; 67   : 	~CReg() { 

  00000		 |$LN7@CReg|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M41160|
  00004	e1a04000	 mov         r4, r0

; 68   : 		if(m_hKey) RegCloseKey(m_hKey); 

  00008	e5943000	 ldr         r3, [r4]
  0000c	e3530000	 cmp         r3, #0
  00010	11a00003	 movne       r0, r3
  00014	1b000000	 blne        RegCloseKey

; 69   : 		if (m_lpbValue) {

  00018	e5943008	 ldr         r3, [r4, #8]
  0001c	e3530000	 cmp         r3, #0

; 70   : 			ASSERT(m_iValueLen != 0);
; 71   : 			LocalFree(m_lpbValue);

  00020	11a00003	 movne       r0, r3
  00024	1b000000	 blne        LocalFree

; 72   : 		}
; 73   : 	}

  00028	e8bd4010	 ldmia       sp!, {r4, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$M41161|

			 ENDP  ; |??1CReg@@QAA@XZ|, CReg::~CReg

	EXPORT	|?Reset@CReg@@QAAXXZ|			; CReg::Reset

  00000			 AREA	 |.pdata|, PDATA
|$T41171| DCD	|$LN6@Reset|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Reset@CReg@@QAAXXZ| PROC		; CReg::Reset

; 75   : 	void Reset() { 

  00000		 |$LN6@Reset|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M41168|
  00004	e1a04000	 mov         r4, r0

; 76   : 		if(m_hKey) {

  00008	e5943000	 ldr         r3, [r4]
  0000c	e3a05000	 mov         r5, #0
  00010	e3530000	 cmp         r3, #0
  00014	0a000002	 beq         |$LN1@Reset|

; 77   : 			RegCloseKey(m_hKey); 

  00018	e1a00003	 mov         r0, r3
  0001c	eb000000	 bl          RegCloseKey

; 78   : 			m_hKey = NULL;

  00020	e5845000	 str         r5, [r4]
  00024		 |$LN1@Reset|

; 79   : 		}
; 80   : 		m_Index = 0;

  00024	e5845004	 str         r5, [r4, #4]

; 81   : 	}

  00028	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$M41169|

			 ENDP  ; |?Reset@CReg@@QAAXXZ|, CReg::Reset

	EXPORT	|?IsOK@CReg@@QAAHXZ|			; CReg::IsOK

  00000			 AREA	 |.pdata|, PDATA
|$T41183| DCD	|$LN7@IsOK|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsOK@CReg@@QAAHXZ| PROC		; CReg::IsOK

; 85   : 	BOOL IsOK(void) { return m_hKey!=NULL; }

  00000		 |$LN7@IsOK|
  00000		 |$M41180|
  00000	e5903000	 ldr         r3, [r0]
  00004	e3530000	 cmp         r3, #0
  00008	13a00001	 movne       r0, #1
  0000c	03a00000	 moveq       r0, #0
  00010	e12fff1e	 bx          lr
  00014		 |$M41181|

			 ENDP  ; |?IsOK@CReg@@QAAHXZ|, CReg::IsOK

	EXPORT	|?ValueDW@CReg@@QAAKPBGK@Z|		; CReg::ValueDW
	IMPORT	|RegQueryValueExW|

  00000			 AREA	 |.pdata|, PDATA
|$T41196| DCD	|$LN6@ValueDW|
	DCD	0x40001402
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ValueDW@CReg@@QAAKPBGK@Z| PROC	; CReg::ValueDW

; 197  : 	DWORD ValueDW(LPCTSTR szName, DWORD dwDefault=0) {

  00000		 |$LN6@ValueDW|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M41193|

; 198  : 		DWORD dwValue = dwDefault;
; 199  : 		if(m_hKey) 

  00008	e5903000	 ldr         r3, [r0]
  0000c	e58d2008	 str         r2, [sp, #8]
  00010	e1b00003	 movs        r0, r3
  00014	0a000009	 beq         |$LN1@ValueDW|

; 200  : 		{
; 201  : 			DWORD dwLen = sizeof(DWORD);
; 202  : 			RegQueryValueEx(m_hKey, szName, NULL, NULL, (LPBYTE)&dwValue, &dwLen);

  00018	e28d300c	 add         r3, sp, #0xC
  0001c	e28d2008	 add         r2, sp, #8
  00020	e58d3004	 str         r3, [sp, #4]
  00024	e58d2000	 str         r2, [sp]
  00028	e3a0e004	 mov         lr, #4
  0002c	e3a03000	 mov         r3, #0
  00030	e3a02000	 mov         r2, #0
  00034	e58de00c	 str         lr, [sp, #0xC]
  00038	eb000000	 bl          RegQueryValueExW
  0003c	e59d2008	 ldr         r2, [sp, #8]
  00040		 |$LN1@ValueDW|

; 203  : 		}
; 204  : 		return dwValue;
; 205  : 	}

  00040	e1a00002	 mov         r0, r2
  00044	e28dd010	 add         sp, sp, #0x10
  00048	e49de004	 ldr         lr, [sp], #4
  0004c	e12fff1e	 bx          lr
  00050		 |$M41194|

			 ENDP  ; |?ValueDW@CReg@@QAAKPBGK@Z|, CReg::ValueDW

	EXPORT	|??0CLockObject@@QAA@XZ|		; CLockObject::CLockObject
	IMPORT	|InitializeCriticalSection|
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T41206| DCD	|$LN5@CLockObjec|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CLockObject@@QAA@XZ| PROC		; CLockObject::CLockObject

; 36   :     CLockObject()

  00000		 |$LN5@CLockObjec|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M41203|
  00004	e1a04000	 mov         r4, r0

; 37   :     {
; 38   :         InitializeCriticalSection( &m_CSection );

  00008	eb000000	 bl          InitializeCriticalSection

; 39   :     };

  0000c	e1a00004	 mov         r0, r4
  00010	e8bd4010	 ldmia       sp!, {r4, lr}
  00014	e12fff1e	 bx          lr
  00018		 |$M41204|

			 ENDP  ; |??0CLockObject@@QAA@XZ|, CLockObject::CLockObject

	EXPORT	|??1CLockObject@@QAA@XZ|		; CLockObject::~CLockObject
	IMPORT	|DeleteCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T41214| DCD	|$LN5@CLockObjec@2|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CLockObject@@QAA@XZ| PROC		; CLockObject::~CLockObject

; 41   :     {

  00000		 |$LN5@CLockObjec@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41211|

; 42   :         DeleteCriticalSection( &m_CSection );

  00004	eb000000	 bl          DeleteCriticalSection

; 43   :     };

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M41212|

			 ENDP  ; |??1CLockObject@@QAA@XZ|, CLockObject::~CLockObject

	EXPORT	|?Lock@CLockObject@@QAAXXZ|		; CLockObject::Lock
	IMPORT	|EnterCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T41222| DCD	|$LN5@Lock|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Lock@CLockObject@@QAAXXZ| PROC	; CLockObject::Lock

; 45   :     {

  00000		 |$LN5@Lock|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41219|

; 46   :         EnterCriticalSection( &m_CSection );

  00004	eb000000	 bl          EnterCriticalSection

; 47   :     };

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M41220|

			 ENDP  ; |?Lock@CLockObject@@QAAXXZ|, CLockObject::Lock

	EXPORT	|?Unlock@CLockObject@@QAAXXZ|		; CLockObject::Unlock
	IMPORT	|LeaveCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T41230| DCD	|$LN5@Unlock|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Unlock@CLockObject@@QAAXXZ| PROC	; CLockObject::Unlock

; 49   :     {

  00000		 |$LN5@Unlock|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41227|

; 50   :         LeaveCriticalSection( &m_CSection );

  00004	eb000000	 bl          LeaveCriticalSection

; 51   :     };

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M41228|

			 ENDP  ; |?Unlock@CLockObject@@QAAXXZ|, CLockObject::Unlock

	EXPORT	|??0CRefObject@@QAA@XZ|			; CRefObject::CRefObject
	EXPORT	|??_7CRefObject@@6B@| [ DATA ]		; CRefObject::`vftable'
	IMPORT	|??_ECRefObject@@UAAPAXI@Z|, WEAK |??_GCRefObject@@UAAPAXI@Z| ; CRefObject::`vector deleting destructor', CRefObject::`scalar deleting destructor'
; File c:\wince600\public\common\oak\inc\crefcon.h

  00000			 AREA	 |.pdata|, PDATA
|$T41240| DCD	|$LN5@CRefObject|
	DCD	0x40000600

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7CRefObject@@6B@| DCD |??_ECRefObject@@UAAPAXI@Z|	; CRefObject::`vftable'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CRefObject@@QAA@XZ| PROC		; CRefObject::CRefObject

; 35   :     CRefObject()

  00000		 |$LN5@CRefObject|
  00000		 |$M41237|
  00000	e59f300c	 ldr         r3, [pc, #0xC]

; 36   :     {
; 37   :         m_lRefCount = 0;

  00004	e3a02000	 mov         r2, #0
  00008	e5802004	 str         r2, [r0, #4]
  0000c	e5803000	 str         r3, [r0]

; 38   :     };

  00010	e12fff1e	 bx          lr
  00014		 |$LN6@CRefObject|
  00014		 |$LN7@CRefObject|
  00014	00000000	 DCD         |??_7CRefObject@@6B@|
  00018		 |$M41238|

			 ENDP  ; |??0CRefObject@@QAA@XZ|, CRefObject::CRefObject

	EXPORT	|??1CRefObject@@UAA@XZ|			; CRefObject::~CRefObject

  00000			 AREA	 |.pdata|, PDATA
|$T41250| DCD	|$LN5@CRefObject@2|
	DCD	0x40000400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CRefObject@@UAA@XZ| PROC		; CRefObject::~CRefObject

; 40   :     {

  00000		 |$LN5@CRefObject@2|
  00000		 |$M41247|
  00000	e59f3004	 ldr         r3, [pc, #4]
  00004	e5803000	 str         r3, [r0]

; 41   :         ;};

  00008	e12fff1e	 bx          lr
  0000c		 |$LN6@CRefObject@2|
  0000c		 |$LN7@CRefObject@2|
  0000c	00000000	 DCD         |??_7CRefObject@@6B@|
  00010		 |$M41248|

			 ENDP  ; |??1CRefObject@@UAA@XZ|, CRefObject::~CRefObject

	EXPORT	|?AddRef@CRefObject@@QAAKXZ|		; CRefObject::AddRef
	IMPORT	|InterlockedIncrement|

  00000			 AREA	 |.pdata|, PDATA
|$T41262| DCD	|$LN5@AddRef|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AddRef@CRefObject@@QAAKXZ| PROC	; CRefObject::AddRef

; 43   :     {

  00000		 |$LN5@AddRef|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41259|

; 44   :         return (DWORD)InterlockedIncrement(&m_lRefCount);

  00004	e2800004	 add         r0, r0, #4
  00008	eb000000	 bl          InterlockedIncrement

; 45   :     };

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M41260|

			 ENDP  ; |?AddRef@CRefObject@@QAAKXZ|, CRefObject::AddRef

	EXPORT	|?DeRef@CRefObject@@QAAKXZ|		; CRefObject::DeRef
	IMPORT	|InterlockedDecrement|

  00000			 AREA	 |.pdata|, PDATA
|$T41277| DCD	|$LN8@DeRef|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DeRef@CRefObject@@QAAKXZ| PROC	; CRefObject::DeRef

; 47   :     {

  00000		 |$LN8@DeRef|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M41274|
  00004	e1a04000	 mov         r4, r0

; 48   :         LONG lReturn = InterlockedDecrement(&m_lRefCount);

  00008	e2840004	 add         r0, r4, #4
  0000c	eb000000	 bl          InterlockedDecrement
  00010	e1a05000	 mov         r5, r0

; 49   :         if( lReturn <= 0 ) {

  00014	e3550000	 cmp         r5, #0
  00018	ca000006	 bgt         |$LN4@DeRef|

; 50   :             delete this;

  0001c	e3540000	 cmp         r4, #0
  00020	15943000	 ldrne       r3, [r4]
  00024	13a01001	 movne       r1, #1
  00028	11a00004	 movne       r0, r4
  0002c	15933000	 ldrne       r3, [r3]
  00030	11a0e00f	 movne       lr, pc
  00034	112fff13	 bxne        r3
  00038		 |$LN4@DeRef|

; 51   :         }
; 52   :         return (DWORD)lReturn;
; 53   :     }

  00038	e1a00005	 mov         r0, r5
  0003c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M41275|

			 ENDP  ; |?DeRef@CRefObject@@QAAKXZ|, CRefObject::DeRef

	IMPORT	|??3@YAXPAX@Z|				; operator delete

  00000			 AREA	 |.pdata|, PDATA
|$T41291| DCD	|$LN8@scalar|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GCRefObject@@UAAPAXI@Z| PROC	; CRefObject::`scalar deleting destructor'
  00000		 |$LN8@scalar|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M41288|
  00004	e1a04000	 mov         r4, r0
  00008	e59f3014	 ldr         r3, [pc, #0x14]
  0000c	e3110001	 tst         r1, #1
  00010	e5843000	 str         r3, [r4]
  00014	1b000000	 blne        |??3@YAXPAX@Z|
  00018	e1a00004	 mov         r0, r4
  0001c	e8bd4010	 ldmia       sp!, {r4, lr}
  00020	e12fff1e	 bx          lr
  00024		 |$LN9@scalar|
  00024		 |$LN10@scalar|
  00024	00000000	 DCD         |??_7CRefObject@@6B@|
  00028		 |$M41289|

			 ENDP  ; |??_GCRefObject@@UAAPAXI@Z|, CRefObject::`scalar deleting destructor'

	EXPORT	|?GetRegValue@CRegistryEdit@@QAAHPBGPAEK@Z| ; CRegistryEdit::GetRegValue
; File c:\wince600\public\common\oak\inc\cregedit.h

  00000			 AREA	 |.pdata|, PDATA
|$T41307| DCD	|$LN7@GetRegValu|
	DCD	0x40001404
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetRegValue@CRegistryEdit@@QAAHPBGPAEK@Z| PROC ; CRegistryEdit::GetRegValue

; 130  :     {

  00000		 |$LN7@GetRegValu|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5030	 stmdb       sp!, {r4, r5, r12, lr}
  0000c	e24dd00c	 sub         sp, sp, #0xC
  00010		 |$M41304|
  00010	e1a04002	 mov         r4, r2

; 131  :         DWORD dwType = 0;
; 132  :         LONG status = ::RegQueryValueEx( m_hDevKey,
; 133  :                                            lpcName,
; 134  :                                            NULL,
; 135  :                                            &dwType,
; 136  :                                            lpData,
; 137  :                                            &dwDataLen );

  00014	e5900000	 ldr         r0, [r0]
  00018	e3a05000	 mov         r5, #0
  0001c	e28de028	 add         lr, sp, #0x28
  00020	e28d3008	 add         r3, sp, #8
  00024	e3a02000	 mov         r2, #0
  00028	e58d5008	 str         r5, [sp, #8]
  0002c	e58de004	 str         lr, [sp, #4]
  00030	e58d4000	 str         r4, [sp]
  00034	eb000000	 bl          RegQueryValueExW
  00038	e3500000	 cmp         r0, #0

; 138  :         return ( status == ERROR_SUCCESS );

  0003c	03a00001	 moveq       r0, #1
  00040	13a00000	 movne       r0, #0

; 139  :     }

  00044	e28dd00c	 add         sp, sp, #0xC
  00048	e89d6030	 ldmia       sp, {r4, r5, sp, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M41305|

			 ENDP  ; |?GetRegValue@CRegistryEdit@@QAAHPBGPAEK@Z|, CRegistryEdit::GetRegValue

	EXPORT	|?IsDriverLoaded@DeviceFolder@@QAAHXZ|	; DeviceFolder::IsDriverLoaded
; File c:\wince600\public\common\oak\inc\defbus.h

  00000			 AREA	 |.pdata|, PDATA
|$T41317| DCD	|$LN5@IsDriverLo|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsDriverLoaded@DeviceFolder@@QAAHXZ| PROC ; DeviceFolder::IsDriverLoaded

; 85   :     BOOL    IsDriverLoaded() { return m_fDriverLoaded; };

  00000		 |$LN5@IsDriverLo|
  00000		 |$M41314|
  00000	e5900028	 ldr         r0, [r0, #0x28]
  00004	e12fff1e	 bx          lr
  00008		 |$M41315|

			 ENDP  ; |?IsDriverLoaded@DeviceFolder@@QAAHXZ|, DeviceFolder::IsDriverLoaded

	EXPORT	|?GetDeviceHandle@DefaultBusDriver@@QAAPAXXZ| ; DefaultBusDriver::GetDeviceHandle

  00000			 AREA	 |.pdata|, PDATA
|$T41327| DCD	|$LN5@GetDeviceH|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetDeviceHandle@DefaultBusDriver@@QAAPAXXZ| PROC ; DefaultBusDriver::GetDeviceHandle

; 167  :     HANDLE GetDeviceHandle() { return m_hDevice; };

  00000		 |$LN5@GetDeviceH|
  00000		 |$M41324|
  00000	e5900020	 ldr         r0, [r0, #0x20]
  00004	e12fff1e	 bx          lr
  00008		 |$M41325|

			 ENDP  ; |?GetDeviceHandle@DefaultBusDriver@@QAAPAXXZ|, DefaultBusDriver::GetDeviceHandle

	EXPORT	|?GetIndex@CSDHost@@QAAKXZ|		; CSDHost::GetIndex
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdbus.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T41337| DCD	|$LN5@GetIndex|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetIndex@CSDHost@@QAAKXZ| PROC	; CSDHost::GetIndex

; 131  :     DWORD   GetIndex() {    return m_dwSdHostIndex;  };

  00000		 |$LN5@GetIndex|
  00000		 |$M41334|
  00000	e590005c	 ldr         r0, [r0, #0x5C]
  00004	e12fff1e	 bx          lr
  00008		 |$M41335|

			 ENDP  ; |?GetIndex@CSDHost@@QAAKXZ|, CSDHost::GetIndex

	EXPORT	|?SlotOptionHandler@CSDHost@@QAAJKW4_SD_SLOT_OPTION_CODE@@PAXK@Z| ; CSDHost::SlotOptionHandler

  00000			 AREA	 |.pdata|, PDATA
|$T41352| DCD	|$LN7@SlotOption|
	DCD	0x40000f02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SlotOptionHandler@CSDHost@@QAAJKW4_SD_SLOT_OPTION_CODE@@PAXK@Z| PROC ; CSDHost::SlotOptionHandler

; 139  :     SD_API_STATUS   SlotOptionHandler(DWORD dwSlot, SD_SLOT_OPTION_CODE sdSlotOption, PVOID pvParam, ULONG uSize) { // slot option handler

  00000		 |$LN7@SlotOption|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M41349|
  00008	e1a05002	 mov         r5, r2
  0000c	e1b0e000	 movs        lr, r0

; 140  :         return pSlotOptionHandler((PSDCARD_HC_CONTEXT)this,dwSlot,sdSlotOption,pvParam,uSize);

  00010	e59d2010	 ldr         r2, [sp, #0x10]
  00014	e59e4044	 ldr         r4, [lr, #0x44]
  00018	128e0008	 addne       r0, lr, #8
  0001c	e58d2000	 str         r2, [sp]
  00020	e1a02005	 mov         r2, r5
  00024	03a00000	 moveq       r0, #0
  00028	e1a0e00f	 mov         lr, pc
  0002c	e12fff14	 bx          r4

; 141  :     }

  00030	e28dd004	 add         sp, sp, #4
  00034	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$M41350|

			 ENDP  ; |?SlotOptionHandler@CSDHost@@QAAJKW4_SD_SLOT_OPTION_CODE@@PAXK@Z|, CSDHost::SlotOptionHandler

	EXPORT	|?GetRetryCount@CSDHostContainer@@SAKXZ| ; CSDHostContainer::GetRetryCount
	IMPORT	|?g_pSdContainer@CSDHostContainer@@0PAV1@A| ; CSDHostContainer::g_pSdContainer

  00000			 AREA	 |.pdata|, PDATA
|$T41363| DCD	|$LN7@GetRetryCo|
	DCD	0x40000700
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetRetryCount@CSDHostContainer@@SAKXZ| PROC ; CSDHostContainer::GetRetryCount

; 184  :     static DWORD    GetRetryCount()  { return g_pSdContainer!=NULL? g_pSdContainer->m_BusRequestRetryCount: 0; };

  00000		 |$LN7@GetRetryCo|
  00000		 |$M41360|
  00000	e59f3010	 ldr         r3, [pc, #0x10]
  00004	e5933000	 ldr         r3, [r3]
  00008	e3530000	 cmp         r3, #0
  0000c	159300b0	 ldrne       r0, [r3, #0xB0]
  00010	03a00000	 moveq       r0, #0
  00014	e12fff1e	 bx          lr
  00018		 |$LN8@GetRetryCo|
  00018		 |$LN9@GetRetryCo|
  00018	00000000	 DCD         |?g_pSdContainer@CSDHostContainer@@0PAV1@A|
  0001c		 |$M41361|

			 ENDP  ; |?GetRetryCount@CSDHostContainer@@SAKXZ|, CSDHostContainer::GetRetryCount

	EXPORT	|?GetHostContainer@CSDHostContainer@@SAPAV1@XZ| ; CSDHostContainer::GetHostContainer

  00000			 AREA	 |.pdata|, PDATA
|$T41374| DCD	|$LN5@GetHostCon|
	DCD	0x40000400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetHostContainer@CSDHostContainer@@SAPAV1@XZ| PROC ; CSDHostContainer::GetHostContainer

; 207  :     static CSDHostContainer * GetHostContainer () { return g_pSdContainer; };

  00000		 |$LN5@GetHostCon|
  00000		 |$M41371|
  00000	e59f3004	 ldr         r3, [pc, #4]
  00004	e5930000	 ldr         r0, [r3]
  00008	e12fff1e	 bx          lr
  0000c		 |$LN6@GetHostCon|
  0000c		 |$LN7@GetHostCon|
  0000c	00000000	 DCD         |?g_pSdContainer@CSDHostContainer@@0PAV1@A|
  00010		 |$M41372|

			 ENDP  ; |?GetHostContainer@CSDHostContainer@@SAPAV1@XZ|, CSDHostContainer::GetHostContainer

	EXPORT	|?SetDeviceType@CSDDevice@@QAA?AW4_SDCARD_DEVICE_TYPE@@W42@@Z| ; CSDDevice::SetDeviceType
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T41387| DCD	|$LN5@SetDeviceT|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetDeviceType@CSDDevice@@QAA?AW4_SDCARD_DEVICE_TYPE@@W42@@Z| PROC ; CSDDevice::SetDeviceType

; 133  :     SDCARD_DEVICE_TYPE SetDeviceType(SDCARD_DEVICE_TYPE deviceType) { return m_DeviceType = deviceType; };

  00000		 |$LN5@SetDeviceT|
  00000		 |$M41384|
  00000	e5801494	 str         r1, [r0, #0x494]
  00004	e1a00001	 mov         r0, r1
  00008	e12fff1e	 bx          lr
  0000c		 |$M41385|

			 ENDP  ; |?SetDeviceType@CSDDevice@@QAA?AW4_SDCARD_DEVICE_TYPE@@W42@@Z|, CSDDevice::SetDeviceType

	EXPORT	|?SendSDAppCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z| ; CSDDevice::SendSDAppCommand

  00000			 AREA	 |.pdata|, PDATA
|$T41400| DCD	|$LN5@SendSDAppC|
	DCD	0x40001202
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SendSDAppCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z| PROC ; CSDDevice::SendSDAppCommand

; 221  :     SD_API_STATUS SendSDAppCommand(UCHAR AppCommand,DWORD Argument,SD_RESPONSE_TYPE ResponseType, PSD_COMMAND_RESPONSE pResponse) {

  00000		 |$LN5@SendSDAppC|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M41397|
  00008	e1a06003	 mov         r6, r3

; 222  :         return SendSDAppCmd( AppCommand, Argument, SD_COMMAND, ResponseType,pResponse,0,0,0);

  0000c	e590e000	 ldr         lr, [r0]
  00010	e59d4028	 ldr         r4, [sp, #0x28]
  00014	e3a07000	 mov         r7, #0
  00018	e59e5038	 ldr         r5, [lr, #0x38]
  0001c	e58d4004	 str         r4, [sp, #4]
  00020	e3a03002	 mov         r3, #2
  00024	e58d7010	 str         r7, [sp, #0x10]
  00028	e58d700c	 str         r7, [sp, #0xC]
  0002c	e58d7008	 str         r7, [sp, #8]
  00030	e58d6000	 str         r6, [sp]
  00034	e1a0e00f	 mov         lr, pc
  00038	e12fff15	 bx          r5

; 223  :     }

  0003c	e28dd014	 add         sp, sp, #0x14
  00040	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$M41398|

			 ENDP  ; |?SendSDAppCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|, CSDDevice::SendSDAppCommand

	EXPORT	|?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z| ; CSDDevice::SendSDCommand

  00000			 AREA	 |.pdata|, PDATA
|$T41413| DCD	|$LN5@SendSDComm|
	DCD	0x40001602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z| PROC ; CSDDevice::SendSDCommand

; 224  :     SD_API_STATUS SendSDCommand(UCHAR Command, DWORD Argument,SD_RESPONSE_TYPE ResponseType, PSD_COMMAND_RESPONSE pResponse) {

  00000		 |$LN5@SendSDComm|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd020	 sub         sp, sp, #0x20
  00008		 |$M41410|
  00008	e1a06003	 mov         r6, r3

; 225  :         return SDSynchronousBusRequest_I(Command,Argument,SD_COMMAND,ResponseType,pResponse,0,0,NULL,(DWORD)SD_SLOTRESET_REQUEST);

  0000c	e590e000	 ldr         lr, [r0]
  00010	e59d4038	 ldr         r4, [sp, #0x38]
  00014	e3a07008	 mov         r7, #8
  00018	e59e5014	 ldr         r5, [lr, #0x14]
  0001c	e3a08000	 mov         r8, #0
  00020	e58d4004	 str         r4, [sp, #4]
  00024	e3a03002	 mov         r3, #2
  00028	e58d801c	 str         r8, [sp, #0x1C]
  0002c	e58d8018	 str         r8, [sp, #0x18]
  00030	e58d7014	 str         r7, [sp, #0x14]
  00034	e58d8010	 str         r8, [sp, #0x10]
  00038	e58d800c	 str         r8, [sp, #0xC]
  0003c	e58d8008	 str         r8, [sp, #8]
  00040	e58d6000	 str         r6, [sp]
  00044	e1a0e00f	 mov         lr, pc
  00048	e12fff15	 bx          r5

; 226  :     }

  0004c	e28dd020	 add         sp, sp, #0x20
  00050	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M41411|

			 ENDP  ; |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|, CSDDevice::SendSDCommand

	EXPORT	|?GetRelativeAddress@CSDDevice@@IAAGXZ|	; CSDDevice::GetRelativeAddress

  00000			 AREA	 |.pdata|, PDATA
|$T41423| DCD	|$LN5@GetRelativ|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetRelativeAddress@CSDDevice@@IAAGXZ| PROC ; CSDDevice::GetRelativeAddress

; 228  :     SD_CARD_RCA GetRelativeAddress() { return m_RelativeAddress; };

  00000		 |$LN5@GetRelativ|
  00000		 |$M41420|
  00000	e2803e4a	 add         r3, r0, #0x4A, 28
  00004	e1d300b0	 ldrh        r0, [r3]
  00008	e12fff1e	 bx          lr
  0000c		 |$M41421|

			 ENDP  ; |?GetRelativeAddress@CSDDevice@@IAAGXZ|, CSDDevice::GetRelativeAddress

	EXPORT	|?SDSyncRequestCallback@CSDDevice@@KAXPAXPAU_SD_BUS_REQUEST@@0K@Z| ; CSDDevice::SDSyncRequestCallback
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T41434| DCD	|$LN7@SDSyncRequ|
	DCD	0x40000601
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.hpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDSyncRequestCallback@CSDDevice@@KAXPAXPAU_SD_BUS_REQUEST@@0K@Z| PROC ; CSDDevice::SDSyncRequestCallback

; 239  :     static void SDSyncRequestCallback(HANDLE hDevice,PSD_BUS_REQUEST hRequest,PVOID pContext,DWORD BusRequestParam) {

  00000		 |$LN7@SDSyncRequ|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41431|

; 240  :         BOOL fResult = SetEvent((HANDLE)BusRequestParam);

  00004	e3a01003	 mov         r1, #3
  00008	e1a00003	 mov         r0, r3
  0000c	eb000000	 bl          EventModify

; 241  :         ASSERT(fResult);
; 242  :     }

  00010	e49de004	 ldr         lr, [sp], #4
  00014	e12fff1e	 bx          lr
  00018		 |$M41432|

			 ENDP  ; |?SDSyncRequestCallback@CSDDevice@@KAXPAXPAU_SD_BUS_REQUEST@@0K@Z|, CSDDevice::SDSyncRequestCallback

	EXPORT	|?GetHost@CSDSlot@@QAAAAVCSDHost@@XZ|	; CSDSlot::GetHost
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdslot.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T41444| DCD	|$LN5@GetHost|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetHost@CSDSlot@@QAAAAVCSDHost@@XZ| PROC ; CSDSlot::GetHost

; 99   :     CSDHost&    GetHost() { return m_SdHost; };

  00000		 |$LN5@GetHost|
  00000		 |$M41441|
  00000	e590007c	 ldr         r0, [r0, #0x7C]
  00004	e12fff1e	 bx          lr
  00008		 |$M41442|

			 ENDP  ; |?GetHost@CSDSlot@@QAAAAVCSDHost@@XZ|, CSDSlot::GetHost

	EXPORT	|?GetSlotIndex@CSDSlot@@QAAKXZ|		; CSDSlot::GetSlotIndex

  00000			 AREA	 |.pdata|, PDATA
|$T41454| DCD	|$LN5@GetSlotInd|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetSlotIndex@CSDSlot@@QAAKXZ| PROC	; CSDSlot::GetSlotIndex

; 106  :     DWORD   GetSlotIndex() { return m_dwSlotIndex; };

  00000		 |$LN5@GetSlotInd|
  00000		 |$M41451|
  00000	e5900080	 ldr         r0, [r0, #0x80]
  00004	e12fff1e	 bx          lr
  00008		 |$M41452|

			 ENDP  ; |?GetSlotIndex@CSDSlot@@QAAKXZ|, CSDSlot::GetSlotIndex

	EXPORT	|?GetSlotState@CSDSlot@@QAA?AW4__SD_SLOT_STATE@@XZ| ; CSDSlot::GetSlotState

  00000			 AREA	 |.pdata|, PDATA
|$T41464| DCD	|$LN5@GetSlotSta|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetSlotState@CSDSlot@@QAA?AW4__SD_SLOT_STATE@@XZ| PROC ; CSDSlot::GetSlotState

; 109  :     SD_SLOT_STATE   GetSlotState() { return m_SlotState; };

  00000		 |$LN5@GetSlotSta|
  00000		 |$M41461|
  00000	e5900084	 ldr         r0, [r0, #0x84]
  00004	e12fff1e	 bx          lr
  00008		 |$M41462|

			 ENDP  ; |?GetSlotState@CSDSlot@@QAA?AW4__SD_SLOT_STATE@@XZ|, CSDSlot::GetSlotState

	EXPORT	|?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z| ; CSDSlot::GetFunctionDevice
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T41487| DCD	|$LN15@GetFunctio|
	DCD	0x40001401
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdslot.hpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z| PROC ; CSDSlot::GetFunctionDevice

; 155  :     inline CSDDevice * GetFunctionDevice(DWORD dwIndex){

  00000		 |$LN15@GetFunctio|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M41484|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 156  :         m_SlotLock.Lock();

  0000c	e28500b4	 add         r0, r5, #0xB4
  00010	eb000000	 bl          EnterCriticalSection

; 157  :         CSDDevice*  pReturn = dwIndex < SD_MAXIMUM_DEVICE_PER_SLOT ? m_pFuncDevice[dwIndex] : NULL;

  00014	e3540008	 cmp         r4, #8
  00018	30853104	 addcc       r3, r5, r4, lsl #2
  0001c	359340c8	 ldrcc       r4, [r3, #0xC8]
  00020	23a04000	 movcs       r4, #0

; 158  :         if( pReturn )  {

  00024	e3540000	 cmp         r4, #0
  00028	0a000002	 beq         |$LN2@GetFunctio|

; 159  :             pReturn->AddRef();

  0002c	e2840004	 add         r0, r4, #4
  00030	eb000000	 bl          InterlockedIncrement

; 160  :         }
; 161  :         else

  00034	ea000000	 b           |$LN1@GetFunctio|
  00038		 |$LN2@GetFunctio|

; 162  :             pReturn = NULL;

  00038	e3a04000	 mov         r4, #0
  0003c		 |$LN1@GetFunctio|

; 163  :         m_SlotLock.Unlock();

  0003c	e28500b4	 add         r0, r5, #0xB4
  00040	eb000000	 bl          LeaveCriticalSection

; 164  :         return pReturn;
; 165  :     }

  00044	e1a00004	 mov         r0, r4
  00048	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M41485|

			 ENDP  ; |?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z|, CSDSlot::GetFunctionDevice

	EXPORT	|?GetSlotPowerControl@CSDSlot@@QAAHXZ|	; CSDSlot::GetSlotPowerControl

  00000			 AREA	 |.pdata|, PDATA
|$T41497| DCD	|$LN5@GetSlotPow|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetSlotPowerControl@CSDSlot@@QAAHXZ| PROC ; CSDSlot::GetSlotPowerControl

; 168  :     BOOL    GetSlotPowerControl() { return m_fEnablePowerControl; };

  00000		 |$LN5@GetSlotPow|
  00000		 |$M41494|
  00000	e59000ac	 ldr         r0, [r0, #0xAC]
  00004	e12fff1e	 bx          lr
  00008		 |$M41495|

			 ENDP  ; |?GetSlotPowerControl@CSDSlot@@QAAHXZ|, CSDSlot::GetSlotPowerControl

	EXPORT	|?SDSetSlotPower@CSDSlot@@IAAJK@Z|	; CSDSlot::SDSetSlotPower
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdbus.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T41518| DCD	|$LN9@SDSetSlotP|
	DCD	0x40001304
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdslot.hpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDSetSlotPower@CSDSlot@@IAAJK@Z| PROC ; CSDSlot::SDSetSlotPower

; 183  :     SD_API_STATUS   SDSetSlotPower(DWORD Setting) {

  00000		 |$LN9@SDSetSlotP|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5030	 stmdb       sp!, {r4, r5, r12, lr}
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M41515|

; 184  :         return m_SdHost.SlotOptionHandler(m_dwSlotIndex,SDHCDSetSlotPower,&(Setting),sizeof(Setting));

  00010	e590307c	 ldr         r3, [r0, #0x7C]
  00014	e5901080	 ldr         r1, [r0, #0x80]
  00018	e3a05004	 mov         r5, #4
  0001c	e3530000	 cmp         r3, #0
  00020	e5934044	 ldr         r4, [r3, #0x44]
  00024	12830008	 addne       r0, r3, #8
  00028	03a00000	 moveq       r0, #0
  0002c	e28d3018	 add         r3, sp, #0x18
  00030	e3a02000	 mov         r2, #0
  00034	e58d5000	 str         r5, [sp]
  00038	e1a0e00f	 mov         lr, pc
  0003c	e12fff14	 bx          r4

; 185  :     }

  00040	e28dd004	 add         sp, sp, #4
  00044	e89d6030	 ldmia       sp, {r4, r5, sp, lr}
  00048	e12fff1e	 bx          lr
  0004c		 |$M41516|

			 ENDP  ; |?SDSetSlotPower@CSDSlot@@IAAJK@Z|, CSDSlot::SDSetSlotPower

	EXPORT	|?IsComplete@CSDBusRequest@@QAAHXZ|	; CSDBusRequest::IsComplete
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdbusreq.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T41530| DCD	|$LN9@IsComplete|
	DCD	0x40001301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsComplete@CSDBusRequest@@QAAHXZ| PROC ; CSDBusRequest::IsComplete

; 99   :     BOOL    IsComplete() { 

  00000		 |$LN9@IsComplete|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41527|

; 100  :         if (m_pChildListNext) 

  00004	e5903070	 ldr         r3, [r0, #0x70]
  00008	e1b02003	 movs        r2, r3
  0000c	0a00000b	 beq         |$LN2@IsComplete|

; 101  :             return (m_fCompleted && m_pChildListNext->IsComplete());

  00010	e5903080	 ldr         r3, [r0, #0x80]
  00014	e3530000	 cmp         r3, #0
  00018	0a000005	 beq         |$LN5@IsComplete|
  0001c	e1a00002	 mov         r0, r2
  00020	eb000000	 bl          |?IsComplete@CSDBusRequest@@QAAHXZ|
  00024	e3500000	 cmp         r0, #0
  00028	13a00001	 movne       r0, #1

; 104  :     };

  0002c	149de004	 ldrne       lr, [sp], #4
  00030	112fff1e	 bxne        lr
  00034		 |$LN5@IsComplete|

; 101  :             return (m_fCompleted && m_pChildListNext->IsComplete());

  00034	e3a00000	 mov         r0, #0

; 104  :     };

  00038	e49de004	 ldr         lr, [sp], #4
  0003c	e12fff1e	 bx          lr
  00040		 |$LN2@IsComplete|

; 102  :         else
; 103  :             return m_fCompleted; 

  00040	e5900080	 ldr         r0, [r0, #0x80]

; 104  :     };

  00044	e49de004	 ldr         lr, [sp], #4
  00048	e12fff1e	 bx          lr
  0004c		 |$M41528|

			 ENDP  ; |?IsComplete@CSDBusRequest@@QAAHXZ|, CSDBusRequest::IsComplete

	EXPORT	|?AddRef@CSDBusRequest@@QAAKXZ|		; CSDBusRequest::AddRef

  00000			 AREA	 |.pdata|, PDATA
|$T41540| DCD	|$LN5@AddRef@2|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AddRef@CSDBusRequest@@QAAKXZ| PROC	; CSDBusRequest::AddRef

; 107  :     DWORD AddRef( void ) {

  00000		 |$LN5@AddRef@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41537|

; 108  :         return (DWORD)InterlockedIncrement(&m_lRefCount);

  00004	e280007c	 add         r0, r0, #0x7C
  00008	eb000000	 bl          InterlockedIncrement

; 109  :     };

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M41538|

			 ENDP  ; |?AddRef@CSDBusRequest@@QAAKXZ|, CSDBusRequest::AddRef

	EXPORT	|?DeRef@CSDBusRequest@@QAAKXZ|		; CSDBusRequest::DeRef

  00000			 AREA	 |.pdata|, PDATA
|$T41555| DCD	|$LN8@DeRef@2|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DeRef@CSDBusRequest@@QAAKXZ| PROC	; CSDBusRequest::DeRef

; 110  :     DWORD DeRef( void ) {

  00000		 |$LN8@DeRef@2|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M41552|
  00004	e1a04000	 mov         r4, r0

; 111  :         LONG lReturn = InterlockedDecrement(&m_lRefCount);

  00008	e284007c	 add         r0, r4, #0x7C
  0000c	eb000000	 bl          InterlockedDecrement
  00010	e1a05000	 mov         r5, r0

; 112  :         // Last thing to do
; 113  :         if( lReturn <= 0 ) {

  00014	e3550000	 cmp         r5, #0
  00018	ca000006	 bgt         |$LN4@DeRef@2|

; 114  :             delete this;

  0001c	e3540000	 cmp         r4, #0
  00020	15943000	 ldrne       r3, [r4]
  00024	13a01001	 movne       r1, #1
  00028	11a00004	 movne       r0, r4
  0002c	15933000	 ldrne       r3, [r3]
  00030	11a0e00f	 movne       lr, pc
  00034	112fff13	 bxne        r3
  00038		 |$LN4@DeRef@2|

; 115  :         }
; 116  :         return (DWORD)lReturn;
; 117  :     }

  00038	e1a00005	 mov         r0, r5
  0003c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M41553|

			 ENDP  ; |?DeRef@CSDBusRequest@@QAAKXZ|, CSDBusRequest::DeRef

	EXPORT	|?GetChildListNext@CSDBusRequest@@QAAPAV1@XZ| ; CSDBusRequest::GetChildListNext

  00000			 AREA	 |.pdata|, PDATA
|$T41565| DCD	|$LN5@GetChildLi|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetChildListNext@CSDBusRequest@@QAAPAV1@XZ| PROC ; CSDBusRequest::GetChildListNext

; 139  :     CSDBusRequest * GetChildListNext() { return m_pChildListNext; };

  00000		 |$LN5@GetChildLi|
  00000		 |$M41562|
  00000	e5900070	 ldr         r0, [r0, #0x70]
  00004	e12fff1e	 bx          lr
  00008		 |$M41563|

			 ENDP  ; |?GetChildListNext@CSDBusRequest@@QAAPAV1@XZ|, CSDBusRequest::GetChildListNext

	EXPORT	|?GetRequestRandomIndex@CSDBusRequest@@QAAKXZ| ; CSDBusRequest::GetRequestRandomIndex

  00000			 AREA	 |.pdata|, PDATA
|$T41575| DCD	|$LN5@GetRequest|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetRequestRandomIndex@CSDBusRequest@@QAAKXZ| PROC ; CSDBusRequest::GetRequestRandomIndex

; 140  :     DWORD   GetRequestRandomIndex() { return m_dwRequestIndex; };

  00000		 |$LN5@GetRequest|
  00000		 |$M41572|
  00000	e5900078	 ldr         r0, [r0, #0x78]
  00004	e12fff1e	 bx          lr
  00008		 |$M41573|

			 ENDP  ; |?GetRequestRandomIndex@CSDBusRequest@@QAAKXZ|, CSDBusRequest::GetRequestRandomIndex

	EXPORT	|?CompleteBusRequest@CSDBusRequest@@QAAHJ@Z| ; CSDBusRequest::CompleteBusRequest
	IMPORT	|?CheckForCompletion@CSDBusRequest@@IAAHXZ| ; CSDBusRequest::CheckForCompletion

  00000			 AREA	 |.pdata|, PDATA
|$T41588| DCD	|$LN7@CompleteBu|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CompleteBusRequest@CSDBusRequest@@QAAHJ@Z| PROC ; CSDBusRequest::CompleteBusRequest

; 146  :     BOOL CompleteBusRequest(SD_API_STATUS SdStatus) {

  00000		 |$LN7@CompleteBu|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41585|

; 147  :         // Note the response should be updaed by SDHC.
; 148  :         Status  = SdStatus;
; 149  :         m_fCompleted = TRUE;
; 150  :         return (m_pParentBus!=NULL? m_pParentBus->CheckForCompletion():CheckForCompletion());

  00004	e590306c	 ldr         r3, [r0, #0x6C]
  00008	e3a02001	 mov         r2, #1
  0000c	e580103c	 str         r1, [r0, #0x3C]
  00010	e3530000	 cmp         r3, #0
  00014	e5802080	 str         r2, [r0, #0x80]
  00018	11a00003	 movne       r0, r3
  0001c	eb000000	 bl          |?CheckForCompletion@CSDBusRequest@@IAAHXZ|

; 151  :     }

  00020	e49de004	 ldr         lr, [sp], #4
  00024	e12fff1e	 bx          lr
  00028		 |$M41586|

			 ENDP  ; |?CompleteBusRequest@CSDBusRequest@@QAAHJ@Z|, CSDBusRequest::CompleteBusRequest

	EXPORT	|?GetFirstFailedStatus@CSDBusRequest@@QAAJXZ| ; CSDBusRequest::GetFirstFailedStatus

  00000			 AREA	 |.pdata|, PDATA
|$T41603| DCD	|$LN12@GetFirstFa|
	DCD	0x40000b00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetFirstFailedStatus@CSDBusRequest@@QAAJXZ| PROC ; CSDBusRequest::GetFirstFailedStatus

; 158  :     SD_API_STATUS GetFirstFailedStatus() {

  00000		 |$LN12@GetFirstFa|
  00000		 |$M41600|

; 159  :         if (SD_API_SUCCESS(Status) && m_pChildListNext!=NULL )

  00000	e590303c	 ldr         r3, [r0, #0x3C]
  00004	ea000004	 b           |$LN9@GetFirstFa|
  00008		 |$LL5@GetFirstFa|
  00008	e5903070	 ldr         r3, [r0, #0x70]
  0000c	e1b02003	 movs        r2, r3
  00010	0a000003	 beq         |$LN8@GetFirstFa|
  00014	e592303c	 ldr         r3, [r2, #0x3C]

; 160  :             return m_pChildListNext->GetFirstFailedStatus();

  00018	e1a00002	 mov         r0, r2
  0001c		 |$LN9@GetFirstFa|
  0001c	e3530000	 cmp         r3, #0
  00020	aafffff8	 bge         |$LL5@GetFirstFa|
  00024		 |$LN8@GetFirstFa|

; 161  :         else
; 162  :             return Status;

  00024	e590003c	 ldr         r0, [r0, #0x3C]

; 163  :     }

  00028	e12fff1e	 bx          lr
  0002c		 |$M41601|

			 ENDP  ; |?GetFirstFailedStatus@CSDBusRequest@@QAAJXZ|, CSDBusRequest::GetFirstFailedStatus

	EXPORT	|?TerminateLink@CSDBusRequest@@QAAHXZ|	; CSDBusRequest::TerminateLink
	IMPORT	|InterlockedExchange|

  00000			 AREA	 |.pdata|, PDATA
|$T41615| DCD	|$LN7@TerminateL|
	DCD	0x40000f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TerminateLink@CSDBusRequest@@QAAHXZ| PROC ; CSDBusRequest::TerminateLink

; 164  :     BOOL    TerminateLink()  {

  00000		 |$LN7@TerminateL|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M41612|
  00004	e1a04000	 mov         r4, r0

; 165  :         CSDBusRequest * pCur = (CSDBusRequest *)InterlockedExchange((LONG *)&m_pChildListNext,(LONG)NULL);

  00008	e3a01000	 mov         r1, #0
  0000c	e2840070	 add         r0, r4, #0x70
  00010	eb000000	 bl          InterlockedExchange
  00014	e3500000	 cmp         r0, #0

; 166  :         if (pCur) {
; 167  :             pCur->DeRef();

  00018	1b000000	 blne        |?DeRef@CSDBusRequest@@QAAKXZ|

; 168  :         }
; 169  :         pCur = (CSDBusRequest *)InterlockedExchange((LONG *)&m_pParentBus,(LONG)NULL);

  0001c	e3a01000	 mov         r1, #0
  00020	e284006c	 add         r0, r4, #0x6C
  00024	eb000000	 bl          InterlockedExchange
  00028	e3500000	 cmp         r0, #0

; 170  :         if (pCur) {
; 171  :             pCur->DeRef();

  0002c	1b000000	 blne        |?DeRef@CSDBusRequest@@QAAKXZ|

; 172  :         }
; 173  :         return TRUE;

  00030	e3a00001	 mov         r0, #1

; 174  :     }

  00034	e8bd4010	 ldmia       sp!, {r4, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$M41613|

			 ENDP  ; |?TerminateLink@CSDBusRequest@@QAAHXZ|, CSDBusRequest::TerminateLink

	EXPORT	|?SetExternalHandle@CSDBusRequest@@QAAPAXPAX@Z| ; CSDBusRequest::SetExternalHandle

  00000			 AREA	 |.pdata|, PDATA
|$T41626| DCD	|$LN5@SetExterna|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetExternalHandle@CSDBusRequest@@QAAPAXPAX@Z| PROC ; CSDBusRequest::SetExternalHandle

; 175  :     HANDLE SetExternalHandle(HANDLE hHandle) { return (m_ExternalHandle=hHandle); };

  00000		 |$LN5@SetExterna|
  00000		 |$M41623|
  00000	e5801074	 str         r1, [r0, #0x74]
  00004	e1a00001	 mov         r0, r1
  00008	e12fff1e	 bx          lr
  0000c		 |$M41624|

			 ENDP  ; |?SetExternalHandle@CSDBusRequest@@QAAPAXPAX@Z|, CSDBusRequest::SetExternalHandle

	EXPORT	|?Init@CSDDevice@@UAAHXZ|		; CSDDevice::Init
	IMPORT	|memset|
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T41637| DCD	|$LN6@Init|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Init@CSDDevice@@UAAHXZ| PROC		; CSDDevice::Init

; 91   : {

  00000		 |$LN6@Init|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M41634|
  00004	e1a04000	 mov         r4, r0

; 92   :     if (!m_hSyncEvent)

  00008	e5943434	 ldr         r3, [r4, #0x434]
  0000c	e3530000	 cmp         r3, #0

; 93   :         return FALSE;

  00010	03a00000	 moveq       r0, #0

; 97   : }

  00014	08bd4010	 ldmeqia     sp!, {r4, lr}
  00018	012fff1e	 bxeq        lr

; 94   :     memset(&m_CardInterfaceEx,0,sizeof(m_CardInterfaceEx));

  0001c	e3a02020	 mov         r2, #0x20
  00020	e3a01000	 mov         r1, #0
  00024	e2840d15	 add         r0, r4, #0x15, 26
  00028	eb000000	 bl          memset
  0002c	e3a03b61	 mov         r3, #0x61, 22

; 95   :     m_CardInterfaceEx.ClockRate = SD_DEFAULT_CARD_ID_CLOCK_RATE;

  00030	e3833e2a	 orr         r3, r3, #0x2A, 28
  00034	e5843544	 str         r3, [r4, #0x544]

; 96   :     return TRUE;

  00038	e3a00001	 mov         r0, #1

; 97   : }

  0003c	e8bd4010	 ldmia       sp!, {r4, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M41635|

			 ENDP  ; |?Init@CSDDevice@@UAAHXZ|, CSDDevice::Init

	EXPORT	|?Attach@CSDDevice@@UAAHXZ|		; CSDDevice::Attach

  00000			 AREA	 |.pdata|, PDATA
|$T41647| DCD	|$LN5@Attach|
	DCD	0x40000400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Attach@CSDDevice@@UAAHXZ| PROC	; CSDDevice::Attach

; 99   : {

  00000		 |$LN5@Attach|
  00000		 |$M41644|

; 100  :     m_fAttached = TRUE;

  00000	e3a03001	 mov         r3, #1
  00004	e5803444	 str         r3, [r0, #0x444]

; 101  :     return TRUE;

  00008	e3a00001	 mov         r0, #1

; 102  : }

  0000c	e12fff1e	 bx          lr
  00010		 |$M41645|

			 ENDP  ; |?Attach@CSDDevice@@UAAHXZ|, CSDDevice::Attach

	EXPORT	|?GetDeviceHandle@CSDDevice@@QAA?AT__SDBUS_DEVICE_HANDLE@@XZ| ; CSDDevice::GetDeviceHandle
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdslot.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T41672| DCD	|$LN14@GetDeviceH@2|
	DCD	0x40001f01
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetDeviceHandle@CSDDevice@@QAA?AT__SDBUS_DEVICE_HANDLE@@XZ| PROC ; CSDDevice::GetDeviceHandle

; 131  : {

  00000		 |$LN14@GetDeviceH@2|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M41669|

; 132  :     SDBUS_DEVICE_HANDLE retHandle ;
; 133  :     if (m_fAttached) {

  00004	e5903444	 ldr         r3, [r0, #0x444]
  00008	e3530000	 cmp         r3, #0
  0000c	0a000015	 beq         |$LN2@GetDeviceH@2|

; 134  :         retHandle.bit.sdBusIndex = m_sdSlot.GetHost().GetIndex();

  00010	e5902438	 ldr         r2, [r0, #0x438]

; 135  :         retHandle.bit.sdSlotIndex = m_sdSlot.GetSlotIndex();
; 136  :         retHandle.bit.sdFunctionIndex = m_FuncionIndex;

  00014	e590e43c	 ldr         lr, [r0, #0x43C]
  00018	e5915000	 ldr         r5, [r1]
  0001c	e592307c	 ldr         r3, [r2, #0x7C]
  00020	e5922080	 ldr         r2, [r2, #0x80]
  00024	e20e4007	 and         r4, lr, #7
  00028	e593305c	 ldr         r3, [r3, #0x5C]
  0002c	e202200f	 and         r2, r2, #0xF
  00030	e3e06c07	 mvn         r6, #7, 24
  00034	e203e00f	 and         lr, r3, #0xF
  00038	e1823204	 orr         r3, r2, r4, lsl #4
  0003c	e22620ff	 eor         r2, r6, #0xFF
  00040	e18ee203	 orr         lr, lr, r3, lsl #4
  00044	e0053002	 and         r3, r5, r2

; 137  :         retHandle.bit.sdRandamNumber = m_FuncRef;

  00048	e5902440	 ldr         r2, [r0, #0x440]
  0004c	e18e3003	 orr         r3, lr, r3
  00050	e5813000	 str         r3, [r1]
  00054	e1c120b2	 strh        r2, [r1, #2]

; 138  :         retHandle.bit.sdF = SDBUS_DEVICE_HANDLE_FLAG;

  00058	e5913000	 ldr         r3, [r1]
  0005c	e3c33b3e	 bic         r3, r3, #0x3E, 22
  00060	e3833b1e	 orr         r3, r3, #0x1E, 22

; 139  :     }
; 140  :     else

  00064	ea000000	 b           |$LN11@GetDeviceH@2|
  00068		 |$LN2@GetDeviceH@2|

; 141  :         retHandle.hValue = NULL;

  00068	e3a03000	 mov         r3, #0
  0006c		 |$LN11@GetDeviceH@2|
  0006c	e5813000	 str         r3, [r1]

; 142  :     return retHandle;
; 143  : }

  00070	e1a00001	 mov         r0, r1
  00074	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00078	e12fff1e	 bx          lr
  0007c		 |$M41670|

			 ENDP  ; |?GetDeviceHandle@CSDDevice@@QAA?AT__SDBUS_DEVICE_HANDLE@@XZ|, CSDDevice::GetDeviceHandle

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?IsValid20Card@CSDDevice@@IAAHXZ|	; CSDDevice::IsValid20Card
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|__security_check_cookie|

  00000			 AREA	 |.pdata|, PDATA
|$T41693| DCD	|$LN12@IsValid20C|
	DCD	0xc0002602

  00000			 AREA	 |.xdata|, DATA
|$T41689| DCD	0xfffffff0
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T41689|

  00008		 |?IsValid20Card@CSDDevice@@IAAHXZ| PROC ; CSDDevice::IsValid20Card

; 145  : {

  00008		 |$LN12@IsValid20C|
  00008	e92d4030	 stmdb       sp!, {r4, r5, lr}
  0000c	e24dd020	 sub         sp, sp, #0x20
  00010		 |$M41690|
  00010	e59f3084	 ldr         r3, [pc, #0x84]
  00014	e5933000	 ldr         r3, [r3]
  00018	e58d301c	 str         r3, [sp, #0x1C]

; 146  :     BOOL fValid20Card = FALSE;
; 147  :     if (m_DeviceType!= Device_SD_IO && m_DeviceType != Device_SD_Combo ) {

  0001c	e5903494	 ldr         r3, [r0, #0x494]
  00020	e3a04000	 mov         r4, #0
  00024	e3530003	 cmp         r3, #3
  00028	0a000015	 beq         |$LN3@IsValid20C|
  0002c	e3530004	 cmp         r3, #4
  00030	0a000013	 beq         |$LN3@IsValid20C|

; 148  :         SD_API_STATUS status = SD_API_STATUS_DEVICE_UNSUPPORTED;
; 149  :         SD_COMMAND_RESPONSE  response;                       // response buffer
; 150  :         // Supported Voltage.
; 151  :         const BYTE fCheckFlags = 0x5a;
; 152  :         BYTE fVHS = (((m_sdSlot.VoltageWindowMask & 0x00f80000)!=0)? 1: 2); // 2.0 / 4.3.13

  00034	e5903438	 ldr         r3, [r0, #0x438]

; 153  :         status = SendSDCommand(SD_CMD_SEND_IF_COND,((DWORD)fVHS<<8)| fCheckFlags , ResponseR7, &response);

  00038	e28de004	 add         lr, sp, #4
  0003c	e3a01008	 mov         r1, #8
  00040	e593306c	 ldr         r3, [r3, #0x6C]
  00044	e58de000	 str         lr, [sp]
  00048	e313073e	 tst         r3, #0x3E, 14
  0004c	13a03001	 movne       r3, #1
  00050	03a03002	 moveq       r3, #2
  00054	e20350ff	 and         r5, r3, #0xFF
  00058	e1a03405	 mov         r3, r5, lsl #8
  0005c	e383205a	 orr         r2, r3, #0x5A
  00060	e3a03008	 mov         r3, #8
  00064	eb000000	 bl          |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|
  00068	e3500000	 cmp         r0, #0

; 154  :         if (SD_API_SUCCESS(status)) {

  0006c	4a000004	 bmi         |$LN3@IsValid20C|

; 155  :             if (response.ResponseBuffer[1]== fCheckFlags && response.ResponseBuffer[2]== fVHS) {

  00070	e5dd3009	 ldrb        r3, [sp, #9]
  00074	e353005a	 cmp         r3, #0x5A
  00078	05dd300a	 ldreqb      r3, [sp, #0xA]
  0007c	01530005	 cmpeq       r3, r5

; 156  :                 fValid20Card = TRUE;

  00080	03a04001	 moveq       r4, #1
  00084		 |$LN3@IsValid20C|

; 157  :             }
; 158  :             else {
; 159  :                 DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("CSDDevice::DetectSDCard: unusable device found in slot %d , CMD8 response %x, %x \n"),
; 160  :                     m_sdSlot.GetSlotIndex(),response.ResponseBuffer[1],response.ResponseBuffer[2]));                         
; 161  :                 status = SD_API_STATUS_DEVICE_UNSUPPORTED ;
; 162  :             }
; 163  :         }
; 164  :         else {//if (SD_API_SUCCESS_RESPONSE_TIMEOUT_OK(status)) // This may cause by SDHC. we have know way to tell.
; 165  :             ASSERT(SD_API_SUCCESS_RESPONSE_TIMEOUT_OK(status));
; 166  :             DEBUGMSG(SDCARD_ZONE_ERROR && !SD_API_SUCCESS_RESPONSE_TIMEOUT_OK(status), 
; 167  :                 (TEXT("CSDDevice::DetectSDCard:  found CMD8 failed in slot %d, please check SDHC make sure to support Response7, SD error =0x%x \n"),m_sdSlot.GetSlotIndex(),status));                         
; 168  :             status = SD_API_STATUS_SUCCESS;
; 169  :         }
; 170  :     }
; 171  :     return fValid20Card;

  00084	e59d001c	 ldr         r0, [sp, #0x1C]
  00088	eb000000	 bl          __security_check_cookie

; 172  : }

  0008c	e1a00004	 mov         r0, r4
  00090	e28dd020	 add         sp, sp, #0x20
  00094	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00098	e12fff1e	 bx          lr
  0009c		 |$LN13@IsValid20C|
  0009c		 |$LN14@IsValid20C|
  0009c	00000000	 DCD         |__security_cookie|
  000a0		 |$M41691|

			 ENDP  ; |?IsValid20Card@CSDDevice@@IAAHXZ|, CSDDevice::IsValid20Card

	EXPORT	|?InsertRequestAtEmpty@CSDDevice@@IAAPAVCSDBusRequest@@PAKPAV2@@Z| ; CSDDevice::InsertRequestAtEmpty
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T41721| DCD	|$LN23@InsertRequ|
	DCD	0x40002d01
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InsertRequestAtEmpty@CSDDevice@@IAAPAVCSDBusRequest@@PAKPAV2@@Z| PROC ; CSDDevice::InsertRequestAtEmpty

; 265  : {

  00000		 |$LN23@InsertRequ|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M41718|
  00004	e1b06002	 movs        r6, r2
  00008	e1a07001	 mov         r7, r1
  0000c	e1a04000	 mov         r4, r0

; 266  :     if( pObject )

  00010	0a000023	 beq         |$LN10@InsertRequ|

; 267  :     {
; 268  :         Lock();

  00014	e2840008	 add         r0, r4, #8
  00018	eb000000	 bl          EnterCriticalSection

; 269  :         CSDBusRequest*  pReturn = NULL;
; 270  :         DWORD dwStopIndex = m_dwCurSearchIndex;

  0001c	e5940424	 ldr         r0, [r4, #0x424]
  00020	e3a05000	 mov         r5, #0
  00024	e3a01000	 mov         r1, #0
  00028	e1a02000	 mov         r2, r0
  0002c		 |$LL9@InsertRequ|

; 271  :         do  {
; 272  :             if( m_rgObjectArray[m_dwCurSearchIndex] == NULL )

  0002c	e0843100	 add         r3, r4, r0, lsl #2
  00030	e593301c	 ldr         r3, [r3, #0x1C]
  00034	e3530000	 cmp         r3, #0
  00038	0a000007	 beq         |$LN7@InsertRequ|

; 273  :                 break;
; 274  :             else if (++m_dwCurSearchIndex>=m_dwArraySize)

  0003c	e594e41c	 ldr         lr, [r4, #0x41C]
  00040	e2803001	 add         r3, r0, #1
  00044	e5843424	 str         r3, [r4, #0x424]
  00048	e153000e	 cmp         r3, lr

; 275  :                 m_dwCurSearchIndex = 0 ;

  0004c	25841424	 strcs       r1, [r4, #0x424]

; 276  :         } while (dwStopIndex != m_dwCurSearchIndex);

  00050	e5940424	 ldr         r0, [r4, #0x424]
  00054	e1520000	 cmp         r2, r0
  00058	1afffff3	 bne         |$LL9@InsertRequ|
  0005c		 |$LN7@InsertRequ|

; 277  :         
; 278  :         ASSERT(m_dwCurSearchIndex<m_dwArraySize);
; 279  :         if( m_dwCurSearchIndex < m_dwArraySize && m_rgObjectArray[m_dwCurSearchIndex] == NULL )  {

  0005c	e5942424	 ldr         r2, [r4, #0x424]
  00060	e594341c	 ldr         r3, [r4, #0x41C]
  00064	e1520003	 cmp         r2, r3
  00068	2a00000a	 bcs         |$LN2@InsertRequ|
  0006c	e0842102	 add         r2, r4, r2, lsl #2
  00070	e592301c	 ldr         r3, [r2, #0x1C]
  00074	e3530000	 cmp         r3, #0
  00078	1a000006	 bne         |$LN2@InsertRequ|

; 280  :             pReturn = m_rgObjectArray[m_dwCurSearchIndex] = pObject;
; 281  :             pReturn->AddRef();

  0007c	e286007c	 add         r0, r6, #0x7C
  00080	e582601c	 str         r6, [r2, #0x1C]
  00084	e1a05006	 mov         r5, r6
  00088	eb000000	 bl          InterlockedIncrement

; 282  :             if( pdwIndex )

  0008c	e3570000	 cmp         r7, #0

; 283  :                 *( pdwIndex ) = m_dwCurSearchIndex;

  00090	15943424	 ldrne       r3, [r4, #0x424]
  00094	15873000	 strne       r3, [r7]
  00098		 |$LN2@InsertRequ|

; 284  :         };
; 285  :         Unlock();

  00098	e2840008	 add         r0, r4, #8
  0009c	eb000000	 bl          LeaveCriticalSection

; 286  :         return pReturn;

  000a0	ea000000	 b           |$LN1@InsertRequ|
  000a4		 |$LN10@InsertRequ|

; 287  :     }
; 288  :     else
; 289  :     {
; 290  :         return NULL;

  000a4	e3a05000	 mov         r5, #0
  000a8		 |$LN1@InsertRequ|

; 291  :     }
; 292  : }

  000a8	e1a00005	 mov         r0, r5
  000ac	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000b0	e12fff1e	 bx          lr
  000b4		 |$M41719|

			 ENDP  ; |?InsertRequestAtEmpty@CSDDevice@@IAAPAVCSDBusRequest@@PAKPAV2@@Z|, CSDDevice::InsertRequestAtEmpty

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?DeactivateCardDetect@CSDDevice@@QAAJXZ| ; CSDDevice::DeactivateCardDetect
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T41743| DCD	|$LN20@Deactivate|
	DCD	0xc0005202

  00000			 AREA	 |.xdata|, DATA
|$T41739| DCD	0xffffffe0
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T41739|

  00008		 |?DeactivateCardDetect@CSDDevice@@QAAJXZ| PROC ; CSDDevice::DeactivateCardDetect

; 592  : {

  00008		 |$LN20@Deactivate|
  00008	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  0000c	e24dd034	 sub         sp, sp, #0x34
  00010		 |$M41740|
  00010	e1a07000	 mov         r7, r0
  00014	e59f3130	 ldr         r3, [pc, #0x130]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3030	 str         r3, [sp, #0x30]

; 593  :     UCHAR                   regValue;       // intermediate value
; 594  :     SD_API_STATUS           status;         // status
; 595  :     SD_COMMAND_RESPONSE     response;       // response
; 596  :     BOOL                    fDisableSDIO;   // disable SDIO portion?
; 597  : 
; 598  :     ASSERT(m_FuncionIndex == 0);
; 599  :     if (Device_SD_IO == m_DeviceType ) {

  00020	e5973494	 ldr         r3, [r7, #0x494]
  00024	e3a09001	 mov         r9, #1
  00028	e3530003	 cmp         r3, #3

; 600  :         fDisableSDIO = TRUE;

  0002c	03a06001	 moveq       r6, #1
  00030	0a000014	 beq         |$LN6@Deactivate|

; 601  :     }
; 602  :     else if (Device_SD_Combo == m_DeviceType) {

  00034	e3530004	 cmp         r3, #4
  00038	1a000011	 bne         |$LN10@Deactivate|

; 603  :         fDisableSDIO = TRUE;
; 604  :         
; 605  :         // *** Combo Card Issue ***
; 606  :         // SDIO 1.00 requires that both memory and SDIO portions of combo
; 607  :         // cards be deactivated.
; 608  :         // SDIO 1.10 only requires one of memory or SDIO combo to be disabled. (4.6)
; 609  :         // Some 1.10 cards have a problem where only one can be disabled--disabling 
; 610  :         // both simultaneously will fail.
; 611  :         //
; 612  :         // Our solution is to disable both for < 1.10 and only disable memory 
; 613  :         // for >= 1.10.
; 614  :         
; 615  :         BYTE bSDIORevision; // SDIO spec version
; 616  :         status = SDReadWriteRegistersDirect_I(SD_IO_READ, SD_IO_REG_CCCR, FALSE, &bSDIORevision, sizeof(bSDIORevision));
; 617  :         if (!SD_API_SUCCESS(status)) {

  0003c	e5972000	 ldr         r2, [r7]
  00040	e28d5015	 add         r5, sp, #0x15
  00044	e3a03000	 mov         r3, #0
  00048	e5924010	 ldr         r4, [r2, #0x10]
  0004c	e3a02000	 mov         r2, #0
  00050	e3a01000	 mov         r1, #0
  00054	e1a00007	 mov         r0, r7
  00058	e3a06001	 mov         r6, #1
  0005c	e58d9004	 str         r9, [sp, #4]
  00060	e58d5000	 str         r5, [sp]
  00064	e1a0e00f	 mov         lr, pc
  00068	e12fff14	 bx          r4
  0006c	e3500000	 cmp         r0, #0
  00070	4a000004	 bmi         |$LN6@Deactivate|

; 618  :             DEBUGMSG(SDCARD_ZONE_ERROR, 
; 619  :                 (TEXT("SDBusDriver: Failed to read SDIO revision in slot %d. We will treat it as a 1.0 combo card \n"),
; 620  :                 m_sdSlot.GetSlotIndex()));
; 621  :         }
; 622  :         else {
; 623  :             bSDIORevision >>= 4; // SDIO revision is in the upper four bits.

  00074	e5dd3015	 ldrb        r3, [sp, #0x15]
  00078	e1a03223	 mov         r3, r3, lsr #4
  0007c	e21330ff	 ands        r3, r3, #0xFF

; 624  :             if (bSDIORevision != 0x0) {

  00080	0a000000	 beq         |$LN6@Deactivate|
  00084		 |$LN10@Deactivate|

; 625  :                 fDisableSDIO = FALSE;
; 626  :             }
; 627  :         }
; 628  :     }
; 629  :     else {
; 630  :         DEBUGCHK(Device_SD_Memory == m_DeviceType || 
; 631  :             Device_MMC == m_DeviceType);
; 632  :         fDisableSDIO = FALSE;

  00084	e3a06000	 mov         r6, #0
  00088		 |$LN6@Deactivate|

; 633  :     }
; 634  : 
; 635  :     // for SD memory or combo, send ACMD42 to turn off card detect resistor
; 636  :     if ( (Device_SD_Memory == m_DeviceType) || 
; 637  :          (Device_SD_Combo == m_DeviceType) ) {

  00088	e5973494	 ldr         r3, [r7, #0x494]
  0008c	e3530002	 cmp         r3, #2
  00090	0a000001	 beq         |$LN4@Deactivate|
  00094	e3530004	 cmp         r3, #4
  00098	1a000013	 bne         |$LN3@Deactivate|
  0009c		 |$LN4@Deactivate|

; 638  :         // send ACMD42
; 639  :         status = SendSDAppCommand(SD_ACMD_SET_CLR_CARD_DETECT,
; 640  :             0x00000000,  // bit 0 - cleared to disconnect pullup resistor
; 641  :             ResponseR1,
; 642  :             &response);

  0009c	e5973000	 ldr         r3, [r7]
  000a0	e28d4018	 add         r4, sp, #0x18
  000a4	e3a08000	 mov         r8, #0
  000a8	e5935038	 ldr         r5, [r3, #0x38]
  000ac	e3a03002	 mov         r3, #2
  000b0	e3a02000	 mov         r2, #0
  000b4	e3a0102a	 mov         r1, #0x2A
  000b8	e1a00007	 mov         r0, r7
  000bc	e58d8010	 str         r8, [sp, #0x10]
  000c0	e58d800c	 str         r8, [sp, #0xC]
  000c4	e58d8008	 str         r8, [sp, #8]
  000c8	e58d4004	 str         r4, [sp, #4]
  000cc	e58d9000	 str         r9, [sp]
  000d0	e1a0e00f	 mov         lr, pc
  000d4	e12fff15	 bx          r5
  000d8	e1b04000	 movs        r4, r0

; 643  : 
; 644  :         if (!SD_API_SUCCESS(status)){

  000dc	5a000002	 bpl         |$LN3@Deactivate|
  000e0		 |$LN17@Deactivate|

; 645  :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDBusDriver: Failed to turn off CD resistor in slot %d \n"), m_sdSlot.GetSlotIndex())); 
; 646  :             return status;

  000e0	e59d0030	 ldr         r0, [sp, #0x30]
  000e4	eb000000	 bl          __security_check_cookie
  000e8	ea000013	 b           |$LN13@Deactivate|
  000ec		 |$LN3@Deactivate|

; 647  :         }
; 648  :     }
; 649  : 
; 650  :     // for SD I/O or SD Combo cards, write to the Bus Interface control register and clear the CD bit
; 651  :     if (fDisableSDIO) {

  000ec	e3560000	 cmp         r6, #0
  000f0	0a00000e	 beq         |$LN1@Deactivate|

; 652  :         regValue = SD_IO_BUS_CONTROL_CD_DETECT_DISABLE; 
; 653  : 
; 654  :         status = SDReadWriteRegistersDirect_I(SD_IO_WRITE,
; 655  :             SD_IO_REG_BUS_CONTROL,
; 656  :             TRUE,        // read after write
; 657  :             &regValue,
; 658  :             1);

  000f4	e5973000	 ldr         r3, [r7]
  000f8	e3a06080	 mov         r6, #0x80
  000fc	e28d4014	 add         r4, sp, #0x14
  00100	e5935010	 ldr         r5, [r3, #0x10]
  00104	e3a03001	 mov         r3, #1
  00108	e3a02007	 mov         r2, #7
  0010c	e3a01001	 mov         r1, #1
  00110	e1a00007	 mov         r0, r7
  00114	e5cd6014	 strb        r6, [sp, #0x14]
  00118	e58d9004	 str         r9, [sp, #4]
  0011c	e58d4000	 str         r4, [sp]
  00120	e1a0e00f	 mov         lr, pc
  00124	e12fff15	 bx          r5
  00128	e1b04000	 movs        r4, r0

; 659  : 
; 660  :         if (!SD_API_SUCCESS(status)){
; 661  :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDBusDriver: Failed to turn off CD resistor for SDIO Device in slot %d \n"), m_sdSlot.GetSlotIndex())); 
; 662  :             return status;

  0012c	4affffeb	 bmi         |$LN17@Deactivate|
  00130		 |$LN1@Deactivate|

; 663  :         }
; 664  :     }
; 665  : 
; 666  :     return SD_API_STATUS_SUCCESS;

  00130	e59d0030	 ldr         r0, [sp, #0x30]
  00134	eb000000	 bl          __security_check_cookie
  00138	e3a04000	 mov         r4, #0
  0013c		 |$LN13@Deactivate|

; 667  : }

  0013c	e1a00004	 mov         r0, r4
  00140	e28dd034	 add         sp, sp, #0x34
  00144	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00148	e12fff1e	 bx          lr
  0014c		 |$LN21@Deactivate|
  0014c		 |$LN22@Deactivate|
  0014c	00000000	 DCD         |__security_cookie|
  00150		 |$M41741|

			 ENDP  ; |?DeactivateCardDetect@CSDDevice@@QAAJXZ|, CSDDevice::DeactivateCardDetect

	EXPORT	|?UpdateCachedRegisterFromResponse@CSDDevice@@IAAXW4SD_INFO_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z| ; CSDDevice::UpdateCachedRegisterFromResponse
	IMPORT	|memcpy|

  00000			 AREA	 |.pdata|, PDATA
|$T41759| DCD	|$LN15@UpdateCach|
	DCD	0x40002901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdateCachedRegisterFromResponse@CSDDevice@@IAAXW4SD_INFO_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z| PROC ; CSDDevice::UpdateCachedRegisterFromResponse

; 680  : {

  00000		 |$LN15@UpdateCach|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41756|
  00004	e1a0e002	 mov         lr, r2
  00008	e3510000	 cmp         r1, #0

; 681  : 
; 682  :     switch (Register) { 

  0000c	0a00001a	 beq         |$LN4@UpdateCach|
  00010	e3510001	 cmp         r1, #1
  00014	0a000011	 beq         |$LN6@UpdateCach|
  00018	e3510002	 cmp         r1, #2
  0001c	0a00000c	 beq         |$LN3@UpdateCach|
  00020	e3510003	 cmp         r1, #3
  00024	0a000002	 beq         |$LN5@UpdateCach|
  00028	e3510004	 cmp         r1, #4
  0002c	1a00001a	 bne         |$LN1@UpdateCach|

; 701  :         case SD_INFO_REGISTER_IO_OCR:
; 702  :             m_CachedRegisters.IO_OCR[2] = pResponse->ResponseBuffer[3];
; 703  :             m_CachedRegisters.IO_OCR[1] = pResponse->ResponseBuffer[2];
; 704  :             m_CachedRegisters.IO_OCR[0] = pResponse->ResponseBuffer[1];
; 705  :             break;

  00030	ea000013	 b           |$LN11@UpdateCach|
  00034		 |$LN5@UpdateCach|

; 686  :             break;
; 687  :         case SD_INFO_REGISTER_RCA:
; 688  :             // RCA is in bytes 3,4
; 689  :             m_RelativeAddress = (SD_CARD_RCA)pResponse->ResponseBuffer[3];

  00034	e5de2007	 ldrb        r2, [lr, #7]
  00038	e2801b01	 add         r1, r0, #1, 22
  0003c	e1c12ab0	 strh        r2, [r1, #0xA0]

; 690  :             m_RelativeAddress |= ((SD_CARD_RCA)pResponse->ResponseBuffer[4]) << 8;

  00040	e5de3008	 ldrb        r3, [lr, #8]
  00044	e1823403	 orr         r3, r2, r3, lsl #8
  00048	e1c13ab0	 strh        r3, [r1, #0xA0]

; 706  :         default:
; 707  :             DEBUGCHK(FALSE);
; 708  :     }
; 709  : 
; 710  : }

  0004c	e49de004	 ldr         lr, [sp], #4
  00050	e12fff1e	 bx          lr
  00054		 |$LN3@UpdateCach|

; 697  :             break;
; 698  :         case SD_INFO_REGISTER_CSD:
; 699  :             memcpy(m_CachedRegisters.CSD, pResponse->ResponseBuffer, SD_CSD_REGISTER_SIZE);

  00054	e2803b01	 add         r3, r0, #1, 22
  00058	e28300b6	 add         r0, r3, #0xB6

; 700  :             break;

  0005c	ea000001	 b           |$LN12@UpdateCach|
  00060		 |$LN6@UpdateCach|

; 683  : 
; 684  :         case SD_INFO_REGISTER_CID:
; 685  :             memcpy(m_CachedRegisters.CID, pResponse->ResponseBuffer, SD_CID_REGISTER_SIZE);

  00060	e2803b01	 add         r3, r0, #1, 22
  00064	e28300a6	 add         r0, r3, #0xA6
  00068		 |$LN12@UpdateCach|
  00068	e28e1004	 add         r1, lr, #4
  0006c	e3a02010	 mov         r2, #0x10
  00070	eb000000	 bl          memcpy

; 706  :         default:
; 707  :             DEBUGCHK(FALSE);
; 708  :     }
; 709  : 
; 710  : }

  00074	e49de004	 ldr         lr, [sp], #4
  00078	e12fff1e	 bx          lr
  0007c		 |$LN4@UpdateCach|

; 691  :             break;
; 692  :         case SD_INFO_REGISTER_OCR: 
; 693  :             m_CachedRegisters.OCR[3] = pResponse->ResponseBuffer[4];

  0007c	e5de3008	 ldrb        r3, [lr, #8]
  00080	e5c034a5	 strb        r3, [r0, #0x4A5]
  00084		 |$LN11@UpdateCach|

; 694  :             m_CachedRegisters.OCR[2] = pResponse->ResponseBuffer[3];

  00084	e5de3007	 ldrb        r3, [lr, #7]
  00088	e5c034a4	 strb        r3, [r0, #0x4A4]

; 695  :             m_CachedRegisters.OCR[1] = pResponse->ResponseBuffer[2];

  0008c	e5de3006	 ldrb        r3, [lr, #6]
  00090	e5c034a3	 strb        r3, [r0, #0x4A3]

; 696  :             m_CachedRegisters.OCR[0] = pResponse->ResponseBuffer[1];

  00094	e5de3005	 ldrb        r3, [lr, #5]
  00098	e5c034a2	 strb        r3, [r0, #0x4A2]
  0009c		 |$LN1@UpdateCach|

; 706  :         default:
; 707  :             DEBUGCHK(FALSE);
; 708  :     }
; 709  : 
; 710  : }

  0009c	e49de004	 ldr         lr, [sp], #4
  000a0	e12fff1e	 bx          lr
  000a4		 |$M41757|

			 ENDP  ; |?UpdateCachedRegisterFromResponse@CSDDevice@@IAAXW4SD_INFO_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|, CSDDevice::UpdateCachedRegisterFromResponse

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?SetCardPower@CSDDevice@@IAAJW4_SDCARD_DEVICE_TYPE@@KH@Z| ; CSDDevice::SetCardPower
	EXPORT	|??_C@_1CG@DOEKGKEL@?$AAP?$AAo?$AAw?$AAe?$AAr?$AAU?$AAp?$AAP?$AAo?$AAl?$AAl?$AAi?$AAn?$AAg?$AAT?$AAi?$AAm?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CO@CJCNBDKB@?$AAP?$AAo?$AAw?$AAe?$AAr?$AAU?$AAp?$AAP?$AAo?$AAl?$AAl?$AAi?$AAn?$AAg?$AAI?$AAn?$AAt?$AAe?$AAr?$AAv?$AAa?$AAl?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|Sleep|
	IMPORT	|?RegValueDWORD@CSDHostContainer@@SAKPAGK@Z| ; CSDHostContainer::RegValueDWORD
	IMPORT	|?DelayForPowerUp@CSDSlot@@IAAXXZ|	; CSDSlot::DelayForPowerUp
	IMPORT	|__rt_udiv|

  00000			 AREA	 |.pdata|, PDATA
|$T41823| DCD	|$LN60@SetCardPow|
	DCD	0xc0008502

  00000			 AREA	 |.xdata|, DATA
|$T41819| DCD	0xffffffd8

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CG@DOEKGKEL@?$AAP?$AAo?$AAw?$AAe?$AAr?$AAU?$AAp?$AAP?$AAo?$AAl?$AAl?$AAi?$AAn?$AAg?$AAT?$AAi?$AAm?$AAe?$AA?$AA@| DCB "P"
	DCB	0x0, "o", 0x0, "w", 0x0, "e", 0x0, "r", 0x0, "U", 0x0, "p"
	DCB	0x0, "P", 0x0, "o", 0x0, "l", 0x0, "l", 0x0, "i", 0x0, "n"
	DCB	0x0, "g", 0x0, "T", 0x0, "i", 0x0, "m", 0x0, "e", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CO@CJCNBDKB@?$AAP?$AAo?$AAw?$AAe?$AAr?$AAU?$AAp?$AAP?$AAo?$AAl?$AAl?$AAi?$AAn?$AAg?$AAI?$AAn?$AAt?$AAe?$AAr?$AAv?$AAa?$AAl?$AA?$AA@| DCB "P"
	DCB	0x0, "o", 0x0, "w", 0x0, "e", 0x0, "r", 0x0, "U", 0x0, "p"
	DCB	0x0, "P", 0x0, "o", 0x0, "l", 0x0, "l", 0x0, "i", 0x0, "n"
	DCB	0x0, "g", 0x0, "I", 0x0, "n", 0x0, "t", 0x0, "e", 0x0, "r"
	DCB	0x0, "v", 0x0, "a", 0x0, "l", 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T41819|

  00008		 |?SetCardPower@CSDDevice@@IAAJW4_SDCARD_DEVICE_TYPE@@KH@Z| PROC ; CSDDevice::SetCardPower

; 756  : {

  00008		 |$LN60@SetCardPow|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd038	 sub         sp, sp, #0x38
  00010		 |$M41820|
  00010	e1a06001	 mov         r6, r1
  00014	e58d6018	 str         r6, [sp, #0x18]
  00018	e1a08002	 mov         r8, r2
  0001c	e1a05000	 mov         r5, r0
  00020	e59fe1f0	 ldr         lr, [pc, #0x1F0]
  00024	e59ee000	 ldr         lr, [lr]
  00028	e58de034	 str         lr, [sp, #0x34]

; 757  :     SD_API_STATUS       status = SD_API_STATUS_SUCCESS;  // intermediate status 
; 758  :     SD_COMMAND_RESPONSE response;                        // response
; 759  :     UCHAR               command;                         // command
; 760  :     SD_RESPONSE_TYPE    responseType;                    // response type
; 761  :     ULONG               powerUpRetries;                  // power up retries
; 762  :     BOOL                appcmd = FALSE;                  // command is an app cmd

  0002c	e3a0b000	 mov         r11, #0

; 763  :     ULONG               powerUpInterval;                 // powerup interval
; 764  :     ULONG               totalPowerUpTime;                // total powerup time
; 765  :     ULONG               powerUpIntervalByDevice;         // powerup interval by device
; 766  : 
; 767  :     switch (DeviceType) {

  00030	e3560001	 cmp         r6, #1
  00034	0a00000e	 beq         |$LN21@SetCardPow|
  00038	e3560002	 cmp         r6, #2
  0003c	0a000009	 beq         |$LN19@SetCardPow|
  00040	e3560003	 cmp         r6, #3
  00044	0a000003	 beq         |$LN20@SetCardPow|

; 785  :         default:
; 786  :             DEBUGCHK(FALSE);
; 787  :             return SD_API_STATUS_INVALID_PARAMETER;

  00048	e59d0034	 ldr         r0, [sp, #0x34]
  0004c	eb000000	 bl          __security_check_cookie
  00050	e3a0411f	 mov         r4, #0x1F, 2
  00054	ea000069	 b           |$LN24@SetCardPow|
  00058		 |$LN20@SetCardPow|

; 773  :             break;
; 774  :         case Device_SD_IO:
; 775  :             command = SD_CMD_IO_OP_COND;

  00058	e3a09005	 mov         r9, #5

; 776  :             responseType = ResponseR4;

  0005c	e3a0a005	 mov         r10, #5

; 777  :             powerUpIntervalByDevice = DEFAULT_POWER_UP_SDIO_POLL_INTERVAL;

  00060	e3a07002	 mov         r7, #2

; 778  :             break;

  00064	ea000005	 b           |$LN22@SetCardPow|
  00068		 |$LN19@SetCardPow|

; 779  :         case Device_SD_Memory:
; 780  :             command = SD_ACMD_SD_SEND_OP_COND;

  00068	e3a09029	 mov         r9, #0x29

; 781  :             responseType = ResponseR3;
; 782  :             appcmd = TRUE;

  0006c	e3a0b001	 mov         r11, #1

; 783  :             powerUpIntervalByDevice = DEFAULT_POWER_UP_SD_POLL_INTERVAL;
; 784  :             break;

  00070	ea000000	 b           |$LN55@SetCardPow|
  00074		 |$LN21@SetCardPow|

; 768  : 
; 769  :         case Device_MMC:
; 770  :             command = SD_CMD_MMC_SEND_OPCOND;

  00074	e3a09001	 mov         r9, #1
  00078		 |$LN55@SetCardPow|

; 771  :             responseType = ResponseR3;
; 772  : 			powerUpIntervalByDevice = DEFAULT_POWER_UP_MMC_POLL_INTERVAL;

  00078	e3a07032	 mov         r7, #0x32
  0007c	e3a0a004	 mov         r10, #4
  00080		 |$LN22@SetCardPow|

; 788  :     }
; 789  : 
; 790  :     // check to see if we need to apply power
; 791  :     if (SetHCPower) {

  00080	e3530000	 cmp         r3, #0
  00084	0a000006	 beq         |$LN17@SetCardPow|

; 792  :         DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDBusDriver: Setting slot %d power to 0x%08X \n"), 
; 793  :             m_sdSlot.GetSlotIndex(), OperatingVoltageMask)); 
; 794  :         // set slot power           
; 795  :         status = m_sdSlot.SDSetSlotPower(OperatingVoltageMask);    

  00088	e5950438	 ldr         r0, [r5, #0x438]
  0008c	e1a01008	 mov         r1, r8
  00090	eb000000	 bl          |?SDSetSlotPower@CSDSlot@@IAAJK@Z|
  00094	e1b04000	 movs        r4, r0

; 796  : 
; 797  :         if (!SD_API_SUCCESS(status)) {
; 798  :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDBusDriver: Host failed to set slot power 0x%08X on slot:%d \n"),
; 799  :                 status, m_sdSlot.GetSlotIndex()));
; 800  :             return status;

  00098	4a000056	 bmi         |$LN2@SetCardPow|

; 801  :         }
; 802  : 
; 803  :         m_sdSlot.DelayForPowerUp();

  0009c	e5950438	 ldr         r0, [r5, #0x438]
  000a0	eb000000	 bl          |?DelayForPowerUp@CSDSlot@@IAAXXZ|
  000a4		 |$LN17@SetCardPow|

; 804  :     }
; 805  : 
; 806  :     if (Device_SD_IO != DeviceType) {

  000a4	e3a0e000	 mov         lr, #0
  000a8	e3560003	 cmp         r6, #3
  000ac	0a00000f	 beq         |$LN13@SetCardPow|

; 807  :         // put the card into idle again
; 808  :         status = SendSDCommand(SD_CMD_GO_IDLE_STATE, 0x00000000, NoResponse, NULL);

  000b0	e3a03000	 mov         r3, #0
  000b4	e3a02000	 mov         r2, #0
  000b8	e3a01000	 mov         r1, #0
  000bc	e1a00005	 mov         r0, r5
  000c0	e58de000	 str         lr, [sp]
  000c4	eb000000	 bl          |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|
  000c8	e1b04000	 movs        r4, r0

; 809  :         if (!SD_API_SUCCESS(status)){
; 810  :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDBusDriver: Go Idle Failed during powerup: Status: 0x%08X on slot:%d \n"),status,
; 811  :                 m_sdSlot.GetSlotIndex()));
; 812  :             return status;

  000cc	4a000049	 bmi         |$LN2@SetCardPow|

; 813  :         }
; 814  :         if ((Device_SD_Memory == DeviceType || Device_MMC==DeviceType) && IsValid20Card()) {

  000d0	e3560002	 cmp         r6, #2
  000d4	0a000001	 beq         |$LN12@SetCardPow|
  000d8	e3560001	 cmp         r6, #1
  000dc	1a000003	 bne         |$LN13@SetCardPow|
  000e0		 |$LN12@SetCardPow|
  000e0	e1a00005	 mov         r0, r5
  000e4	eb000000	 bl          |?IsValid20Card@CSDDevice@@IAAHXZ|
  000e8	e3500000	 cmp         r0, #0

; 815  :             OperatingVoltageMask |= 0x40000000; // HCS

  000ec	13888101	 orrne       r8, r8, #1, 2
  000f0		 |$LN13@SetCardPow|

; 816  :         }
; 817  :     }
; 818  : 
; 819  :     totalPowerUpTime = CSDHostContainer::RegValueDWORD(POWER_UP_POLL_TIME_KEY, DEFAULT_POWER_UP_TOTAL_WAIT_TIME);

  000f0	e59f011c	 ldr         r0, [pc, #0x11C]
  000f4	e3a03c4e	 mov         r3, #0x4E, 24
  000f8	e3831020	 orr         r1, r3, #0x20
  000fc	eb000000	 bl          |?RegValueDWORD@CSDHostContainer@@SAKPAGK@Z|
  00100	e1a04000	 mov         r4, r0

; 820  :     powerUpInterval = CSDHostContainer::RegValueDWORD(POWER_UP_POLL_TIME_INTERVAL_KEY, powerUpIntervalByDevice);

  00104	e59f0104	 ldr         r0, [pc, #0x104]
  00108	e1a01007	 mov         r1, r7
  0010c	eb000000	 bl          |?RegValueDWORD@CSDHostContainer@@SAKPAGK@Z|
  00110	e1a03000	 mov         r3, r0

; 821  : 
; 822  :     powerUpRetries = totalPowerUpTime/powerUpInterval;

  00114	e1a01004	 mov         r1, r4
  00118	e58d3014	 str         r3, [sp, #0x14]
  0011c	eb000000	 bl          __rt_udiv
  00120	e1b07000	 movs        r7, r0
  00124		 |$LN57@SetCardPow|

; 823  : 
; 824  :     DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDBusDriver: Power Set, checking card in slot %d, MaxRetries: %d, Time: %d MS, Interval: %d MS \n"), 
; 825  :         m_sdSlot.GetSlotIndex(), powerUpRetries, totalPowerUpTime , powerUpInterval)); 
; 826  : 
; 827  :     while (powerUpRetries != 0) {

  00124	0a000032	 beq         |$LN53@SetCardPow|
  00128	e28de01c	 add         lr, sp, #0x1C

; 828  : 
; 829  :         if (appcmd) {

  0012c	e35b0000	 cmp         r11, #0

; 830  :             // send it as an APP cmd
; 831  :             status = SendSDAppCommand(command,
; 832  :                 OperatingVoltageMask,
; 833  :                 responseType,
; 834  :                 &response);

  00130	e1a00005	 mov         r0, r5
  00134	0a00000f	 beq         |$LN9@SetCardPow|
  00138	e5951000	 ldr         r1, [r5]
  0013c	e3a06000	 mov         r6, #0
  00140	e58d6010	 str         r6, [sp, #0x10]
  00144	e5914038	 ldr         r4, [r1, #0x38]
  00148	e58d600c	 str         r6, [sp, #0xC]
  0014c	e58d6008	 str         r6, [sp, #8]
  00150	e28d601c	 add         r6, sp, #0x1C
  00154	e1a01009	 mov         r1, r9
  00158	e58d6004	 str         r6, [sp, #4]
  0015c	e3a03002	 mov         r3, #2
  00160	e1a02008	 mov         r2, r8
  00164	e58da000	 str         r10, [sp]
  00168	e1a0e00f	 mov         lr, pc
  0016c	e12fff14	 bx          r4

; 835  :         } else {

  00170	e59d6018	 ldr         r6, [sp, #0x18]
  00174	ea000004	 b           |$LN56@SetCardPow|
  00178		 |$LN9@SetCardPow|

; 836  : 
; 837  :             // send the command to get the ready bit
; 838  :             status = SendSDCommand(command,
; 839  :                 (0x40000000)|OperatingVoltageMask, // GWRIGHT: check for HC MMC card
; 840  :                 responseType,
; 841  :                 &response);

  00178	e1a0300a	 mov         r3, r10
  0017c	e3882101	 orr         r2, r8, #1, 2
  00180	e1a01009	 mov         r1, r9
  00184	e58de000	 str         lr, [sp]
  00188	eb000000	 bl          |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|
  0018c		 |$LN56@SetCardPow|
  0018c	e1a04000	 mov         r4, r0

; 842  :         }
; 843  : 
; 844  :         if (!SD_API_SUCCESS(status)){

  00190	e3540000	 cmp         r4, #0
  00194	4a000014	 bmi         |$LN38@SetCardPow|

; 845  :             break;
; 846  :         }
; 847  : 
; 848  :         if (Device_SD_IO == DeviceType) {

  00198	e3560003	 cmp         r6, #3
  0019c	1a000003	 bne         |$LN6@SetCardPow|

; 849  :             // check to see if the I/O is ready
; 850  :             if (SD_IS_IO_READY(&response)) {

  001a0	e5dd3024	 ldrb        r3, [sp, #0x24]
  001a4	e3130080	 tst         r3, #0x80
  001a8	1a000009	 bne         |$LN50@SetCardPow|

; 851  :                 UpdateCachedRegisterFromResponse(SD_INFO_REGISTER_IO_OCR, &response);
; 852  :                 // we're done
; 853  :                 break;
; 854  :             }
; 855  :         } else {

  001ac	ea000002	 b           |$LN3@SetCardPow|
  001b0		 |$LN6@SetCardPow|

; 856  :             // check to see if the MMC or Memory card is ready
; 857  :             if (SD_IS_MEM_READY(&response)) {

  001b0	e5dd0024	 ldrb        r0, [sp, #0x24]
  001b4	e3100080	 tst         r0, #0x80
  001b8	1a000004	 bne         |$LN51@SetCardPow|
  001bc		 |$LN3@SetCardPow|

; 860  :                 break;
; 861  :             }
; 862  :         }
; 863  : 
; 864  : 
; 865  :         DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDBusDriver: Card in slot %d not ready, countdown: %d \n"),m_sdSlot.GetSlotIndex(), powerUpRetries)); 
; 866  :         powerUpRetries--;
; 867  :         // sleep the powerup interval
; 868  :         Sleep(powerUpInterval);

  001bc	e59d0014	 ldr         r0, [sp, #0x14]
  001c0	e2477001	 sub         r7, r7, #1
  001c4	eb000000	 bl          Sleep
  001c8	e3570000	 cmp         r7, #0
  001cc	eaffffd4	 b           |$LN57@SetCardPow|
  001d0		 |$LN51@SetCardPow|

; 858  :                 // card is ready
; 859  :                 UpdateCachedRegisterFromResponse(SD_INFO_REGISTER_OCR, &response);

  001d0	e5c504a5	 strb        r0, [r5, #0x4A5]
  001d4		 |$LN50@SetCardPow|
  001d4	e5dd1021	 ldrb        r1, [sp, #0x21]
  001d8	e5dd2022	 ldrb        r2, [sp, #0x22]
  001dc	e5dd3023	 ldrb        r3, [sp, #0x23]
  001e0	e5c514a2	 strb        r1, [r5, #0x4A2]
  001e4	e5c524a3	 strb        r2, [r5, #0x4A3]
  001e8	e5c534a4	 strb        r3, [r5, #0x4A4]
  001ec		 |$LN38@SetCardPow|

; 869  :     }
; 870  : 
; 871  :     if (0 == powerUpRetries) {

  001ec	e3570000	 cmp         r7, #0
  001f0	1a000000	 bne         |$LN2@SetCardPow|
  001f4		 |$LN53@SetCardPow|

; 872  :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDBusDriver: Device failed to powerup after voltage setting \n")));
; 873  :         status = SD_API_STATUS_DEVICE_NOT_RESPONDING;

  001f4	e3a0414b	 mov         r4, #0x4B, 2
  001f8		 |$LN2@SetCardPow|

; 874  :     } 
; 875  : 
; 876  :     if (SD_API_SUCCESS(status)) {
; 877  :         DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDBusDriver: Card in slot %d ready \n"),m_sdSlot.GetSlotIndex())); 
; 878  :     }
; 879  : 
; 880  :     return status;

  001f8	e59d0034	 ldr         r0, [sp, #0x34]
  001fc	eb000000	 bl          __security_check_cookie
  00200		 |$LN24@SetCardPow|

; 881  : }

  00200	e1a00004	 mov         r0, r4
  00204	e28dd038	 add         sp, sp, #0x38
  00208	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0020c	e12fff1e	 bx          lr
  00210		 |$LN61@SetCardPow|
  00210		 |$LN62@SetCardPow|
  00210	00000000	 DCD         |??_C@_1CO@CJCNBDKB@?$AAP?$AAo?$AAw?$AAe?$AAr?$AAU?$AAp?$AAP?$AAo?$AAl?$AAl?$AAi?$AAn?$AAg?$AAI?$AAn?$AAt?$AAe?$AAr?$AAv?$AAa?$AAl?$AA?$AA@|
  00214		 |$LN63@SetCardPow|
  00214	00000000	 DCD         |??_C@_1CG@DOEKGKEL@?$AAP?$AAo?$AAw?$AAe?$AAr?$AAU?$AAp?$AAP?$AAo?$AAl?$AAl?$AAi?$AAn?$AAg?$AAT?$AAi?$AAm?$AAe?$AA?$AA@|
  00218		 |$LN64@SetCardPow|
  00218	00000000	 DCD         |__security_cookie|
  0021c		 |$M41821|

			 ENDP  ; |?SetCardPower@CSDDevice@@IAAJW4_SDCARD_DEVICE_TYPE@@KH@Z|, CSDDevice::SetCardPower

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?GetCustomRegPath@CSDDevice@@IAAJPAGKH@Z| ; CSDDevice::GetCustomRegPath
	EXPORT	|??_C@_1DE@IKOGLCHN@?$AA?$CF?$AAs?$AA?2?$AAC?$AAI?$AAD?$AA?9?$AA?$CF?$AAd?$AA?9?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?9?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_19NHPFCCLF@?$AA?$CF?$AA0?$AA2?$AAx?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_15DAMPJCDE@?$AA?$CF?$AAc?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EC@JKGNMBMJ@?$AA?$CF?$AAs?$AA?2?$AAM?$AAA?$AAN?$AAF?$AA?9?$AA?$CF?$AA0?$AA4?$AAX?$AA?9?$AAC?$AAA?$AAR?$AAD?$AAI?$AAD?$AA?9?$AA?$CF?$AA0?$AA4?$AAX?$AA?9?$AAF?$AAU?$AAN?$AAC?$AA?9?$AA?$CF?$AAd@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EK@KEBJJNMI@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAS?$AAD?$AAC?$AAA?$AAR?$AAD?$AA?2?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAC?$AAu@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DC@IGHBEOGB@?$AA?$CF?$AAs?$AA?2?$AAM?$AAA?$AAN?$AAF?$AA?9?$AA?$CF?$AA0?$AA4?$AAX?$AA?9?$AAC?$AAA?$AAR?$AAD?$AAI?$AAD?$AA?9?$AA?$CF?$AA0?$AA4?$AAX?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|StringCchPrintfW|

  00000			 AREA	 |.pdata|, PDATA
|$T41862| DCD	|$LN34@GetCustomR|
	DCD	0xc000ac02

  00000			 AREA	 |.xdata|, DATA
|$T41858| DCD	0xffffffd8

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DE@IKOGLCHN@?$AA?$CF?$AAs?$AA?2?$AAC?$AAI?$AAD?$AA?9?$AA?$CF?$AAd?$AA?9?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?9?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@| DCB "%"
	DCB	0x0, "s", 0x0, "\\", 0x0, "C", 0x0, "I", 0x0, "D", 0x0, "-"
	DCB	0x0, "%", 0x0, "d", 0x0, "-", 0x0, "%", 0x0, "s", 0x0, "%"
	DCB	0x0, "s", 0x0, "-", 0x0, "%", 0x0, "s", 0x0, "%", 0x0, "s"
	DCB	0x0, "%", 0x0, "s", 0x0, "%", 0x0, "s", 0x0, "%", 0x0, "s"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_19NHPFCCLF@?$AA?$CF?$AA0?$AA2?$AAx?$AA?$AA@| DCB "%", 0x0, "0", 0x0
	DCB	"2", 0x0, "x", 0x0, 0x0, 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_15DAMPJCDE@?$AA?$CF?$AAc?$AA?$AA@| DCB "%", 0x0, "c", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EC@JKGNMBMJ@?$AA?$CF?$AAs?$AA?2?$AAM?$AAA?$AAN?$AAF?$AA?9?$AA?$CF?$AA0?$AA4?$AAX?$AA?9?$AAC?$AAA?$AAR?$AAD?$AAI?$AAD?$AA?9?$AA?$CF?$AA0?$AA4?$AAX?$AA?9?$AAF?$AAU?$AAN?$AAC?$AA?9?$AA?$CF?$AAd@| DCB "%"
	DCB	0x0, "s", 0x0, "\\", 0x0, "M", 0x0, "A", 0x0, "N", 0x0, "F"
	DCB	0x0, "-", 0x0, "%", 0x0, "0", 0x0, "4", 0x0, "X", 0x0, "-"
	DCB	0x0, "C", 0x0, "A", 0x0, "R", 0x0, "D", 0x0, "I", 0x0, "D"
	DCB	0x0, "-", 0x0, "%", 0x0, "0", 0x0, "4", 0x0, "X", 0x0, "-"
	DCB	0x0, "F", 0x0, "U", 0x0, "N", 0x0, "C", 0x0, "-", 0x0, "%"
	DCB	0x0, "d", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EK@KEBJJNMI@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAS?$AAD?$AAC?$AAA?$AAR?$AAD?$AA?2?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAC?$AAu@| DCB "\\"
	DCB	0x0, "D", 0x0, "r", 0x0, "i", 0x0, "v", 0x0, "e", 0x0, "r"
	DCB	0x0, "s", 0x0, "\\", 0x0, "S", 0x0, "D", 0x0, "C", 0x0, "A"
	DCB	0x0, "R", 0x0, "D", 0x0, "\\", 0x0, "C", 0x0, "l", 0x0, "i"
	DCB	0x0, "e", 0x0, "n", 0x0, "t", 0x0, "D", 0x0, "r", 0x0, "i"
	DCB	0x0, "v", 0x0, "e", 0x0, "r", 0x0, "s", 0x0, "\\", 0x0, "C"
	DCB	0x0, "u", 0x0, "s", 0x0, "t", 0x0, "o", 0x0, "m", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DC@IGHBEOGB@?$AA?$CF?$AAs?$AA?2?$AAM?$AAA?$AAN?$AAF?$AA?9?$AA?$CF?$AA0?$AA4?$AAX?$AA?9?$AAC?$AAA?$AAR?$AAD?$AAI?$AAD?$AA?9?$AA?$CF?$AA0?$AA4?$AAX?$AA?$AA@| DCB "%"
	DCB	0x0, "s", 0x0, "\\", 0x0, "M", 0x0, "A", 0x0, "N", 0x0, "F"
	DCB	0x0, "-", 0x0, "%", 0x0, "0", 0x0, "4", 0x0, "X", 0x0, "-"
	DCB	0x0, "C", 0x0, "A", 0x0, "R", 0x0, "D", 0x0, "I", 0x0, "D"
	DCB	0x0, "-", 0x0, "%", 0x0, "0", 0x0, "4", 0x0, "X", 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T41858|

  00008		 |?GetCustomRegPath@CSDDevice@@IAAJPAGKH@Z| PROC ; CSDDevice::GetCustomRegPath

; 1344 : {

  00008		 |$LN34@GetCustomR|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd088	 sub         sp, sp, #0x88
  00010		 |$M41859|
  00010	e1a04001	 mov         r4, r1
  00014	e58d4020	 str         r4, [sp, #0x20]
  00018	e1a0b002	 mov         r11, r2
  0001c	e59fe290	 ldr         lr, [pc, #0x290]
  00020	e59ee000	 ldr         lr, [lr]
  00024	e58de084	 str         lr, [sp, #0x84]

; 1345 :     SD_PARSED_REGISTER_CID  ParsedRegisters;                // parsed registers
; 1346 :     SD_API_STATUS           status = SD_API_STATUS_SUCCESS; // intermediate status
; 1347 : 
; 1348 :     DEBUGCHK(pPath);
; 1349 : 
; 1350 :     // for Memory or MMC get the CID
; 1351 :     if ( (Device_SD_Memory == m_DeviceType) ||(Device_MMC == m_DeviceType) || (Device_SD_Combo==m_DeviceType) ) {

  00028	e590e494	 ldr         lr, [r0, #0x494]
  0002c	e3a0a000	 mov         r10, #0
  00030	e35e0002	 cmp         lr, #2
  00034	0a000020	 beq         |$LN21@GetCustomR|
  00038	e35e0001	 cmp         lr, #1
  0003c	0a00001e	 beq         |$LN21@GetCustomR|
  00040	e35e0004	 cmp         lr, #4
  00044	0a00001c	 beq         |$LN21@GetCustomR|

; 1412 :             DEBUGCHK(SUCCEEDED(hr));
; 1413 : 
; 1414 :             DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDBusDriver: built custom MMC/SD path: %s \n"),pPath));
; 1415 :         }
; 1416 :     }
; 1417 :     else if (Device_SD_IO == m_DeviceType) {

  00048	e35e0003	 cmp         lr, #3
  0004c	1a000018	 bne         |$LN4@GetCustomR|

; 1418 :         if (BasePath) {

  00050	e3530000	 cmp         r3, #0

; 1419 :             // build the custom registry path for the card as a whole
; 1420 :             HRESULT hr = StringCchPrintf(pPath, cchPath, TEXT("%s\\MANF-%04X-CARDID-%04X"),
; 1421 :                 SDCARD_CUSTOM_DEVICE_REG_PATH,
; 1422 :                 m_SDCardInfo.SDIOInformation.pCommonInformation->ManufacturerID,
; 1423 :                 m_SDCardInfo.SDIOInformation.pCommonInformation->CardID);  

  00054	e59f3244	 ldr         r3, [pc, #0x244]
  00058	0a000009	 beq         |$LN3@GetCustomR|
  0005c	e59014ec	 ldr         r1, [r0, #0x4EC]
  00060	e59f2248	 ldr         r2, [pc, #0x248]
  00064	e1d100ba	 ldrh        r0, [r1, #0xA]
  00068	e1d1e0b8	 ldrh        lr, [r1, #8]
  0006c	e1a0100b	 mov         r1, r11
  00070	e58d0004	 str         r0, [sp, #4]
  00074	e1a00004	 mov         r0, r4
  00078	e58de000	 str         lr, [sp]
  0007c	eb000000	 bl          StringCchPrintfW

; 1424 :             DEBUGCHK(SUCCEEDED(hr));
; 1425 :         } else {

  00080	ea00007f	 b           |$LN20@GetCustomR|
  00084		 |$LN3@GetCustomR|

; 1426 :             // build the custom registry path for the SDIO card function
; 1427 :             HRESULT hr = StringCchPrintf(pPath, cchPath, TEXT("%s\\MANF-%04X-CARDID-%04X-FUNC-%d"),
; 1428 :                 SDCARD_CUSTOM_DEVICE_REG_PATH,
; 1429 :                 m_SDCardInfo.SDIOInformation.pCommonInformation->ManufacturerID,
; 1430 :                 m_SDCardInfo.SDIOInformation.pCommonInformation->CardID,
; 1431 :                 m_SDCardInfo.SDIOInformation.Function);

  00084	e59024ec	 ldr         r2, [r0, #0x4EC]
  00088	e5d0e4d8	 ldrb        lr, [r0, #0x4D8]
  0008c	e1d210ba	 ldrh        r1, [r2, #0xA]
  00090	e1d200b8	 ldrh        r0, [r2, #8]
  00094	e59f2210	 ldr         r2, [pc, #0x210]
  00098	e58d1004	 str         r1, [sp, #4]
  0009c	e58d0000	 str         r0, [sp]
  000a0	e1a0100b	 mov         r1, r11
  000a4	e1a00004	 mov         r0, r4
  000a8	e58de008	 str         lr, [sp, #8]
  000ac	eb000000	 bl          StringCchPrintfW

; 1432 :             DEBUGCHK(SUCCEEDED(hr));
; 1433 :         }
; 1434 : 
; 1435 :         DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDBusDriver: built custom SDIO path: %s \n"),pPath));
; 1436 :     }
; 1437 :     else {

  000b0	ea000073	 b           |$LN20@GetCustomR|
  000b4		 |$LN4@GetCustomR|

; 1438 :         DEBUG_ASSERT(FALSE);
; 1439 :         status = SD_API_STATUS_INVALID_PARAMETER;

  000b4	e3a0a11f	 mov         r10, #0x1F, 2
  000b8	ea000071	 b           |$LN20@GetCustomR|
  000bc		 |$LN21@GetCustomR|

; 1352 :         // get the parsed CID registers
; 1353 :         status = SDCardInfoQuery_I( SD_INFO_REGISTER_CID,&ParsedRegisters, sizeof(ParsedRegisters));

  000bc	e5901000	 ldr         r1, [r0]
  000c0	e3a03028	 mov         r3, #0x28
  000c4	e28d2024	 add         r2, sp, #0x24
  000c8	e5914034	 ldr         r4, [r1, #0x34]
  000cc	e3a01001	 mov         r1, #1
  000d0	e1a0e00f	 mov         lr, pc
  000d4	e12fff14	 bx          r4
  000d8	e1b0a000	 movs        r10, r0

; 1354 : #define TEMP_CHAR_BUFFER_SIZE 3
; 1355 :         if (SD_API_SUCCESS(status)) {

  000dc	4a000068	 bmi         |$LN20@GetCustomR|

; 1356 :             TCHAR szOEMID0[TEMP_CHAR_BUFFER_SIZE];
; 1357 :             TCHAR szOEMID1[TEMP_CHAR_BUFFER_SIZE];
; 1358 :             TCHAR szProductName0[TEMP_CHAR_BUFFER_SIZE];
; 1359 :             TCHAR szProductName1[TEMP_CHAR_BUFFER_SIZE];
; 1360 :             TCHAR szProductName2[TEMP_CHAR_BUFFER_SIZE];
; 1361 :             TCHAR szProductName3[TEMP_CHAR_BUFFER_SIZE];
; 1362 :             TCHAR szProductName4[TEMP_CHAR_BUFFER_SIZE];
; 1363 : 
; 1364 :             // the OEM application ID and product name should only contain 7 bit ASCII characters, 
; 1365 :             // but some cards use other characters in the 127-255 range).  This causes a problem because
; 1366 :             // the registry path is made up of these characters, and should not contain any characters 
; 1367 :             // outside of the 32-126 range.
; 1368 :             // the following code will check each of the characters, and replace them with two digit 
; 1369 :             // hexadecimal string representation if necessary
; 1370 : 
; 1371 :             if( ParsedRegisters.OEMApplicationID[0] >= 32 && ParsedRegisters.OEMApplicationID[0] < 127 )

  000e0	e1dd32d5	 ldrsb       r3, [sp, #0x25]
  000e4	e3530020	 cmp         r3, #0x20
  000e8	ba000002	 blt         |$LN19@GetCustomR|
  000ec	e353007f	 cmp         r3, #0x7F

; 1372 :                 StringCchPrintf( szOEMID0, TEMP_CHAR_BUFFER_SIZE, TEXT("%c"), (TCHAR)ParsedRegisters.OEMApplicationID[0] );

  000f0	b59f21b0	 ldrlt       r2, [pc, #0x1B0]
  000f4	ba000000	 blt         |$LN25@GetCustomR|
  000f8		 |$LN19@GetCustomR|

; 1373 :             else
; 1374 :                 StringCchPrintf( szOEMID0, TEMP_CHAR_BUFFER_SIZE, TEXT("%02x"), (TCHAR)ParsedRegisters.OEMApplicationID[0] );

  000f8	e59f21a4	 ldr         r2, [pc, #0x1A4]
  000fc		 |$LN25@GetCustomR|
  000fc	e1a03803	 mov         r3, r3, lsl #16
  00100	e1a03823	 mov         r3, r3, lsr #16
  00104	e3a01003	 mov         r1, #3
  00108	e28d006c	 add         r0, sp, #0x6C
  0010c	eb000000	 bl          StringCchPrintfW

; 1375 : 
; 1376 :             if( ParsedRegisters.OEMApplicationID[1] >= 32 && ParsedRegisters.OEMApplicationID[1] < 127 )

  00110	e1dd32d6	 ldrsb       r3, [sp, #0x26]
  00114	e3530020	 cmp         r3, #0x20
  00118	ba000002	 blt         |$LN17@GetCustomR|
  0011c	e353007f	 cmp         r3, #0x7F

; 1377 :                 StringCchPrintf( szOEMID1, TEMP_CHAR_BUFFER_SIZE, TEXT("%c"), (TCHAR)ParsedRegisters.OEMApplicationID[1] );

  00120	b59f2180	 ldrlt       r2, [pc, #0x180]
  00124	ba000000	 blt         |$LN26@GetCustomR|
  00128		 |$LN17@GetCustomR|

; 1378 :             else
; 1379 :                 StringCchPrintf( szOEMID1, TEMP_CHAR_BUFFER_SIZE, TEXT("%02x"), (TCHAR)ParsedRegisters.OEMApplicationID[1] );

  00128	e59f2174	 ldr         r2, [pc, #0x174]
  0012c		 |$LN26@GetCustomR|
  0012c	e1a03803	 mov         r3, r3, lsl #16
  00130	e1a03823	 mov         r3, r3, lsr #16
  00134	e3a01003	 mov         r1, #3
  00138	e28d005c	 add         r0, sp, #0x5C
  0013c	eb000000	 bl          StringCchPrintfW

; 1380 : 
; 1381 :             if( ParsedRegisters.ProductName[0] >= 32 && ParsedRegisters.ProductName[0] < 127 )

  00140	e1dd32d8	 ldrsb       r3, [sp, #0x28]
  00144	e3530020	 cmp         r3, #0x20
  00148	ba000002	 blt         |$LN15@GetCustomR|
  0014c	e353007f	 cmp         r3, #0x7F

; 1382 :                 StringCchPrintf( szProductName0, TEMP_CHAR_BUFFER_SIZE, TEXT("%c"), (TCHAR)ParsedRegisters.ProductName[0] );

  00150	b59f2150	 ldrlt       r2, [pc, #0x150]
  00154	ba000000	 blt         |$LN27@GetCustomR|
  00158		 |$LN15@GetCustomR|

; 1383 :             else
; 1384 :                 StringCchPrintf( szProductName0, TEMP_CHAR_BUFFER_SIZE, TEXT("%02x"), (TCHAR)ParsedRegisters.ProductName[0] );

  00158	e59f2144	 ldr         r2, [pc, #0x144]
  0015c		 |$LN27@GetCustomR|
  0015c	e1a03803	 mov         r3, r3, lsl #16
  00160	e1a03823	 mov         r3, r3, lsr #16
  00164	e3a01003	 mov         r1, #3
  00168	e28d0054	 add         r0, sp, #0x54
  0016c	eb000000	 bl          StringCchPrintfW

; 1385 : 
; 1386 :             if( ParsedRegisters.ProductName[1] >= 32 && ParsedRegisters.ProductName[1] < 127 )

  00170	e1dd32d9	 ldrsb       r3, [sp, #0x29]
  00174	e3530020	 cmp         r3, #0x20
  00178	ba000002	 blt         |$LN13@GetCustomR|
  0017c	e353007f	 cmp         r3, #0x7F

; 1387 :                 StringCchPrintf( szProductName1, TEMP_CHAR_BUFFER_SIZE, TEXT("%c"), (TCHAR)ParsedRegisters.ProductName[1] );

  00180	b59f2120	 ldrlt       r2, [pc, #0x120]
  00184	ba000000	 blt         |$LN28@GetCustomR|
  00188		 |$LN13@GetCustomR|

; 1388 :             else
; 1389 :                 StringCchPrintf( szProductName1, TEMP_CHAR_BUFFER_SIZE, TEXT("%02x"), (TCHAR)ParsedRegisters.ProductName[1] );

  00188	e59f2114	 ldr         r2, [pc, #0x114]
  0018c		 |$LN28@GetCustomR|
  0018c	e1a03803	 mov         r3, r3, lsl #16
  00190	e1a03823	 mov         r3, r3, lsr #16
  00194	e3a01003	 mov         r1, #3
  00198	e28d004c	 add         r0, sp, #0x4C
  0019c	eb000000	 bl          StringCchPrintfW

; 1390 : 
; 1391 :             if( ParsedRegisters.ProductName[2] >= 32 && ParsedRegisters.ProductName[2] < 127 )

  001a0	e1dd32da	 ldrsb       r3, [sp, #0x2A]
  001a4	e3530020	 cmp         r3, #0x20
  001a8	ba000002	 blt         |$LN11@GetCustomR|
  001ac	e353007f	 cmp         r3, #0x7F

; 1392 :                 StringCchPrintf( szProductName2, TEMP_CHAR_BUFFER_SIZE, TEXT("%c"), (TCHAR)ParsedRegisters.ProductName[2] );

  001b0	b59f20f0	 ldrlt       r2, [pc, #0xF0]
  001b4	ba000000	 blt         |$LN29@GetCustomR|
  001b8		 |$LN11@GetCustomR|

; 1393 :             else
; 1394 :                 StringCchPrintf( szProductName2, TEMP_CHAR_BUFFER_SIZE, TEXT("%02x"), (TCHAR)ParsedRegisters.ProductName[2] );

  001b8	e59f20e4	 ldr         r2, [pc, #0xE4]
  001bc		 |$LN29@GetCustomR|
  001bc	e1a03803	 mov         r3, r3, lsl #16
  001c0	e1a03823	 mov         r3, r3, lsr #16
  001c4	e3a01003	 mov         r1, #3
  001c8	e28d0074	 add         r0, sp, #0x74
  001cc	eb000000	 bl          StringCchPrintfW

; 1395 : 
; 1396 :             if( ParsedRegisters.ProductName[3] >= 32 && ParsedRegisters.ProductName[3] < 127 )

  001d0	e1dd32db	 ldrsb       r3, [sp, #0x2B]
  001d4	e3530020	 cmp         r3, #0x20
  001d8	ba000002	 blt         |$LN9@GetCustomR|
  001dc	e353007f	 cmp         r3, #0x7F

; 1397 :                 StringCchPrintf( szProductName3, TEMP_CHAR_BUFFER_SIZE, TEXT("%c"), (TCHAR)ParsedRegisters.ProductName[3] );

  001e0	b59f20c0	 ldrlt       r2, [pc, #0xC0]
  001e4	ba000000	 blt         |$LN30@GetCustomR|
  001e8		 |$LN9@GetCustomR|

; 1398 :             else
; 1399 :                 StringCchPrintf( szProductName3, TEMP_CHAR_BUFFER_SIZE, TEXT("%02x"), (TCHAR)ParsedRegisters.ProductName[3] );

  001e8	e59f20b4	 ldr         r2, [pc, #0xB4]
  001ec		 |$LN30@GetCustomR|
  001ec	e1a03803	 mov         r3, r3, lsl #16
  001f0	e1a03823	 mov         r3, r3, lsr #16
  001f4	e3a01003	 mov         r1, #3
  001f8	e28d007c	 add         r0, sp, #0x7C
  001fc	eb000000	 bl          StringCchPrintfW

; 1400 : 
; 1401 :             if( ParsedRegisters.ProductName[4] >= 32 && ParsedRegisters.ProductName[4] < 127 )

  00200	e1dd32dc	 ldrsb       r3, [sp, #0x2C]
  00204	e3530020	 cmp         r3, #0x20
  00208	ba000002	 blt         |$LN7@GetCustomR|
  0020c	e353007f	 cmp         r3, #0x7F

; 1402 :                 StringCchPrintf( szProductName4, TEMP_CHAR_BUFFER_SIZE, TEXT("%c"), (TCHAR)ParsedRegisters.ProductName[4] );

  00210	b59f2090	 ldrlt       r2, [pc, #0x90]
  00214	ba000000	 blt         |$LN31@GetCustomR|
  00218		 |$LN7@GetCustomR|

; 1403 :             else
; 1404 :                 StringCchPrintf( szProductName4, TEMP_CHAR_BUFFER_SIZE, TEXT("%02x"), (TCHAR)ParsedRegisters.ProductName[4] );

  00218	e59f2084	 ldr         r2, [pc, #0x84]
  0021c		 |$LN31@GetCustomR|
  0021c	e1a03803	 mov         r3, r3, lsl #16
  00220	e1a03823	 mov         r3, r3, lsr #16
  00224	e3a01003	 mov         r1, #3
  00228	e28d0064	 add         r0, sp, #0x64
  0022c	eb000000	 bl          StringCchPrintfW

; 1405 : 
; 1406 :             // build up the string
; 1407 :             HRESULT hr = StringCchPrintf(pPath, cchPath, TEXT("%s\\CID-%d-%s%s-%s%s%s%s%s"),
; 1408 :                 SDCARD_CUSTOM_DEVICE_REG_PATH,
; 1409 :                 ParsedRegisters.ManufacturerID,
; 1410 :                 szOEMID0, szOEMID1,
; 1411 :                 szProductName0, szProductName1, szProductName2, szProductName3, szProductName4 );

  00230	e5dd1024	 ldrb        r1, [sp, #0x24]
  00234	e59f3064	 ldr         r3, [pc, #0x64]
  00238	e59f205c	 ldr         r2, [pc, #0x5C]
  0023c	e59d0020	 ldr         r0, [sp, #0x20]
  00240	e58d1000	 str         r1, [sp]
  00244	e28de064	 add         lr, sp, #0x64
  00248	e28d407c	 add         r4, sp, #0x7C
  0024c	e28d5074	 add         r5, sp, #0x74
  00250	e28d604c	 add         r6, sp, #0x4C
  00254	e28d7054	 add         r7, sp, #0x54
  00258	e28d805c	 add         r8, sp, #0x5C
  0025c	e28d906c	 add         r9, sp, #0x6C
  00260	e1a0100b	 mov         r1, r11
  00264	e58de01c	 str         lr, [sp, #0x1C]
  00268	e58d4018	 str         r4, [sp, #0x18]
  0026c	e58d5014	 str         r5, [sp, #0x14]
  00270	e58d6010	 str         r6, [sp, #0x10]
  00274	e58d700c	 str         r7, [sp, #0xC]
  00278	e58d8008	 str         r8, [sp, #8]
  0027c	e58d9004	 str         r9, [sp, #4]
  00280	eb000000	 bl          StringCchPrintfW
  00284		 |$LN20@GetCustomR|

; 1440 :     }
; 1441 :     DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDBusDriver:: path: %s \n"),pPath));        
; 1442 :     return status;

  00284	e59d0084	 ldr         r0, [sp, #0x84]
  00288	eb000000	 bl          __security_check_cookie

; 1443 : }

  0028c	e1a0000a	 mov         r0, r10
  00290	e28dd088	 add         sp, sp, #0x88
  00294	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00298	e12fff1e	 bx          lr
  0029c		 |$LN35@GetCustomR|
  0029c		 |$LN36@GetCustomR|
  0029c	00000000	 DCD         |??_C@_1DE@IKOGLCHN@?$AA?$CF?$AAs?$AA?2?$AAC?$AAI?$AAD?$AA?9?$AA?$CF?$AAd?$AA?9?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?9?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@|
  002a0		 |$LN37@GetCustomR|
  002a0	00000000	 DCD         |??_C@_1EK@KEBJJNMI@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAS?$AAD?$AAC?$AAA?$AAR?$AAD?$AA?2?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAC?$AAu@|
  002a4		 |$LN38@GetCustomR|
  002a4	00000000	 DCD         |??_C@_19NHPFCCLF@?$AA?$CF?$AA0?$AA2?$AAx?$AA?$AA@|
  002a8		 |$LN39@GetCustomR|
  002a8	00000000	 DCD         |??_C@_15DAMPJCDE@?$AA?$CF?$AAc?$AA?$AA@|
  002ac		 |$LN40@GetCustomR|
  002ac	00000000	 DCD         |??_C@_1EC@JKGNMBMJ@?$AA?$CF?$AAs?$AA?2?$AAM?$AAA?$AAN?$AAF?$AA?9?$AA?$CF?$AA0?$AA4?$AAX?$AA?9?$AAC?$AAA?$AAR?$AAD?$AAI?$AAD?$AA?9?$AA?$CF?$AA0?$AA4?$AAX?$AA?9?$AAF?$AAU?$AAN?$AAC?$AA?9?$AA?$CF?$AAd@|
  002b0		 |$LN41@GetCustomR|
  002b0	00000000	 DCD         |??_C@_1DC@IGHBEOGB@?$AA?$CF?$AAs?$AA?2?$AAM?$AAA?$AAN?$AAF?$AA?9?$AA?$CF?$AA0?$AA4?$AAX?$AA?9?$AAC?$AAA?$AAR?$AAD?$AAI?$AAD?$AA?9?$AA?$CF?$AA0?$AA4?$AAX?$AA?$AA@|
  002b4		 |$LN42@GetCustomR|
  002b4	00000000	 DCD         |__security_cookie|
  002b8		 |$M41860|

			 ENDP  ; |?GetCustomRegPath@CSDDevice@@IAAJPAGKH@Z|, CSDDevice::GetCustomRegPath

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?SDLoadDevice@CSDDevice@@QAAJXZ|	; CSDDevice::SDLoadDevice
	EXPORT	|??_C@_1CK@NJIGGLHH@?$AAW?$AAa?$AAk?$AAe?$AAO?$AAn?$AAS?$AAD?$AAI?$AAO?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAs?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BG@HOCOHIJB@?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AAI?$AAn?$AAf?$AAo?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GG@MMDBJFNM@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAS?$AAD?$AAC?$AAA?$AAR?$AAD?$AA?2?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAC?$AAl@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FO@EMODNFIA@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAS?$AAD?$AAC?$AAA?$AAR?$AAD?$AA?2?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAC?$AAl@| [ DATA ] ; `string'
	EXPORT	|??_C@_1M@PIGKLJLL@?$AA?$CF?$AAs?$AA?2?$AA?$CF?$AAd?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BO@JBKDDDIL@?$AA?2?$AAH?$AAi?$AAg?$AAh?$AA_?$AAC?$AAa?$AAp?$AAa?$AAc?$AAi?$AAt?$AAy?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FM@FFGGNHKA@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAS?$AAD?$AAC?$AAA?$AAR?$AAD?$AA?2?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAC?$AAl@| [ DATA ] ; `string'
	IMPORT	|?AddInitReg@DeviceFolder@@QAAHHPAU_REGINI@@@Z| ; DeviceFolder::AddInitReg
	IMPORT	|??0DeviceFolder@@QAA@PBG0KKKKPAXK0@Z|	; DeviceFolder::DeviceFolder
	IMPORT	|?GetSubBusNamePrefix@CSDHostContainer@@QAAPBGXZ| ; CSDHostContainer::GetSubBusNamePrefix
	IMPORT	|??2@YAPAXI@Z|				; operator new
	IMPORT	|StringCchCatW|
	IMPORT	|?IsHighCapacitySDMemory@CSDDevice@@QAAHXZ| ; CSDDevice::IsHighCapacitySDMemory
	IMPORT	|StringCchCopyW|
	IMPORT	|RegOpenKeyExW|
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T41956| DCD	|$LN66@SDLoadDevi|
	DCD	0xc000e302

  00000			 AREA	 |.xdata|, DATA
|$T41952| DCD	0xffffffd8

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CK@NJIGGLHH@?$AAW?$AAa?$AAk?$AAe?$AAO?$AAn?$AAS?$AAD?$AAI?$AAO?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAs?$AA?$AA@| DCB "W"
	DCB	0x0, "a", 0x0, "k", 0x0, "e", 0x0, "O", 0x0, "n", 0x0, "S"
	DCB	0x0, "D", 0x0, "I", 0x0, "O", 0x0, "I", 0x0, "n", 0x0, "t"
	DCB	0x0, "e", 0x0, "r", 0x0, "r", 0x0, "u", 0x0, "p", 0x0, "t"
	DCB	0x0, "s", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BG@HOCOHIJB@?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AAI?$AAn?$AAf?$AAo?$AA?$AA@| DCB "C"
	DCB	0x0, "l", 0x0, "i", 0x0, "e", 0x0, "n", 0x0, "t", 0x0, "I"
	DCB	0x0, "n", 0x0, "f", 0x0, "o", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GG@MMDBJFNM@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAS?$AAD?$AAC?$AAA?$AAR?$AAD?$AA?2?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAC?$AAl@| DCB "\\"
	DCB	0x0, "D", 0x0, "r", 0x0, "i", 0x0, "v", 0x0, "e", 0x0, "r"
	DCB	0x0, "s", 0x0, "\\", 0x0, "S", 0x0, "D", 0x0, "C", 0x0, "A"
	DCB	0x0, "R", 0x0, "D", 0x0, "\\", 0x0, "C", 0x0, "l", 0x0, "i"
	DCB	0x0, "e", 0x0, "n", 0x0, "t", 0x0, "D", 0x0, "r", 0x0, "i"
	DCB	0x0, "v", 0x0, "e", 0x0, "r", 0x0, "s", 0x0, "\\", 0x0, "C"
	DCB	0x0, "l", 0x0, "a", 0x0, "s", 0x0, "s", 0x0, "\\", 0x0, "S"
	DCB	0x0, "D", 0x0, "M", 0x0, "e", 0x0, "m", 0x0, "o", 0x0, "r"
	DCB	0x0, "y", 0x0, "_", 0x0, "C", 0x0, "l", 0x0, "a", 0x0, "s"
	DCB	0x0, "s", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FO@EMODNFIA@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAS?$AAD?$AAC?$AAA?$AAR?$AAD?$AA?2?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAC?$AAl@| DCB "\\"
	DCB	0x0, "D", 0x0, "r", 0x0, "i", 0x0, "v", 0x0, "e", 0x0, "r"
	DCB	0x0, "s", 0x0, "\\", 0x0, "S", 0x0, "D", 0x0, "C", 0x0, "A"
	DCB	0x0, "R", 0x0, "D", 0x0, "\\", 0x0, "C", 0x0, "l", 0x0, "i"
	DCB	0x0, "e", 0x0, "n", 0x0, "t", 0x0, "D", 0x0, "r", 0x0, "i"
	DCB	0x0, "v", 0x0, "e", 0x0, "r", 0x0, "s", 0x0, "\\", 0x0, "C"
	DCB	0x0, "l", 0x0, "a", 0x0, "s", 0x0, "s", 0x0, "\\", 0x0, "S"
	DCB	0x0, "D", 0x0, "I", 0x0, "O", 0x0, "_", 0x0, "C", 0x0, "l"
	DCB	0x0, "a", 0x0, "s", 0x0, "s", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1M@PIGKLJLL@?$AA?$CF?$AAs?$AA?2?$AA?$CF?$AAd?$AA?$AA@| DCB "%", 0x0
	DCB	"s", 0x0, "\\", 0x0, "%", 0x0, "d", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BO@JBKDDDIL@?$AA?2?$AAH?$AAi?$AAg?$AAh?$AA_?$AAC?$AAa?$AAp?$AAa?$AAc?$AAi?$AAt?$AAy?$AA?$AA@| DCB "\\"
	DCB	0x0, "H", 0x0, "i", 0x0, "g", 0x0, "h", 0x0, "_", 0x0, "C"
	DCB	0x0, "a", 0x0, "p", 0x0, "a", 0x0, "c", 0x0, "i", 0x0, "t"
	DCB	0x0, "y", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FM@FFGGNHKA@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAS?$AAD?$AAC?$AAA?$AAR?$AAD?$AA?2?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAC?$AAl@| DCB "\\"
	DCB	0x0, "D", 0x0, "r", 0x0, "i", 0x0, "v", 0x0, "e", 0x0, "r"
	DCB	0x0, "s", 0x0, "\\", 0x0, "S", 0x0, "D", 0x0, "C", 0x0, "A"
	DCB	0x0, "R", 0x0, "D", 0x0, "\\", 0x0, "C", 0x0, "l", 0x0, "i"
	DCB	0x0, "e", 0x0, "n", 0x0, "t", 0x0, "D", 0x0, "r", 0x0, "i"
	DCB	0x0, "v", 0x0, "e", 0x0, "r", 0x0, "s", 0x0, "\\", 0x0, "C"
	DCB	0x0, "l", 0x0, "a", 0x0, "s", 0x0, "s", 0x0, "\\", 0x0, "M"
	DCB	0x0, "M", 0x0, "C", 0x0, "_", 0x0, "C", 0x0, "l", 0x0, "a"
	DCB	0x0, "s", 0x0, "s", 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T41952|

  00008		 |?SDLoadDevice@CSDDevice@@QAAJXZ| PROC	; CSDDevice::SDLoadDevice

; 1453 : {

  00008		 |$LN66@SDLoadDevi|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24ddf8f	 sub         sp, sp, #0x8F, 30
  00010		 |$M41953|
  00010	e1a07000	 mov         r7, r0
  00014	e59f3374	 ldr         r3, [pc, #0x374]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3238	 str         r3, [sp, #0x238]

; 1454 :     TCHAR                   loadPath[MAX_KEY_PATH_LENGTH];  // string buffer
; 1455 :     BOOLEAN                 deviceFound = FALSE;            // device found flag
; 1456 :     SD_API_STATUS           status;                         // intermediate status
; 1457 :     HKEY                    hKey;                           // the key
; 1458 :     
; 1459 :     // get the custom path for the card or function
; 1460 :     status = GetCustomRegPath(loadPath, dim(loadPath), FALSE);

  00020	e3a03000	 mov         r3, #0
  00024	e3a02c01	 mov         r2, #1, 24
  00028	e28d1038	 add         r1, sp, #0x38
  0002c	e3a04000	 mov         r4, #0
  00030	eb000000	 bl          |?GetCustomRegPath@CSDDevice@@IAAJPAGKH@Z|
  00034	e1b08000	 movs        r8, r0

; 1461 : 
; 1462 :     if (!SD_API_SUCCESS(status)) {

  00038	5a000002	 bpl         |$LN28@SDLoadDevi|

; 1463 :         return status;

  0003c	e59d0238	 ldr         r0, [sp, #0x238]
  00040		 |$LN63@SDLoadDevi|
  00040	eb000000	 bl          __security_check_cookie
  00044	ea0000c5	 b           |$LN29@SDLoadDevi|
  00048		 |$LN28@SDLoadDevi|
  00048	e3a0380f	 mov         r3, #0xF, 16

; 1464 :     }
; 1465 : 
; 1466 :     // attempt to open the path
; 1467 :     if ( (RegOpenKeyEx(HKEY_LOCAL_MACHINE, loadPath, 0, KEY_ALL_ACCESS,&hKey) == ERROR_SUCCESS) ) {

  0004c	e28de020	 add         lr, sp, #0x20
  00050	e383303f	 orr         r3, r3, #0x3F
  00054	e3a02000	 mov         r2, #0
  00058	e28d1038	 add         r1, sp, #0x38
  0005c	e3a0010a	 mov         r0, #0xA, 2
  00060	e58de000	 str         lr, [sp]
  00064	eb000000	 bl          RegOpenKeyExW
  00068	e3500000	 cmp         r0, #0
  0006c	1a000002	 bne         |$LN27@SDLoadDevi|

; 1468 :         RegCloseKey(hKey);

  00070	e59d0020	 ldr         r0, [sp, #0x20]
  00074	eb000000	 bl          RegCloseKey

; 1469 :         deviceFound = TRUE;
; 1470 :     } else {

  00078	ea000024	 b           |$LN60@SDLoadDevi|
  0007c		 |$LN27@SDLoadDevi|

; 1471 :         // no CUSTOM driver path was found so set the default path
; 1472 :         if (Device_SD_Memory == m_DeviceType || Device_SD_Combo == m_DeviceType ) {

  0007c	e5973494	 ldr         r3, [r7, #0x494]
  00080	e3530002	 cmp         r3, #2
  00084	0a000010	 beq         |$LN24@SDLoadDevi|
  00088	e3530004	 cmp         r3, #4
  0008c	0a00000e	 beq         |$LN24@SDLoadDevi|

; 1482 :         } else if (Device_MMC == m_DeviceType) {

  00090	e3530001	 cmp         r3, #1

; 1483 :             // set the default load path for MMC devices
; 1484 :             HRESULT hr = StringCchCopy(loadPath, _countof(loadPath), SDCARD_MMC_CLASS_REG_PATH);

  00094	059f22f0	 ldreq       r2, [pc, #0x2F0]
  00098	0a00000c	 beq         |$LN62@SDLoadDevi|

; 1485 :             if ( SUCCEEDED(hr)) {
; 1486 :                 if (IsHighCapacitySDMemory()) {
; 1487 : #ifdef BSP_EMMCFEATURE                     
; 1488 :                     hr = StringCchCat(loadPath, _countof(loadPath),SDCARD_HIGH_CAPACITY_REG_PATH);
; 1489 : #else
; 1490 :                     hr = StringCchCopy(loadPath, _countof(loadPath),SDCARD_HIGH_CAPACITY_REG_PATH);
; 1491 : #endif                    
; 1492 :                 }
; 1493 :             }
; 1494 :             if (SUCCEEDED(hr))               
; 1495 :                 deviceFound = TRUE;
; 1496 :                 
; 1497 :         } else if (Device_SD_IO == m_DeviceType) {

  0009c	e3530003	 cmp         r3, #3
  000a0	1a00001b	 bne         |$LN21@SDLoadDevi|

; 1498 :             if (SD_IO_NON_STANDARD_DEVICE_CODE == m_SDCardInfo.SDIOInformation.DeviceCode) {

  000a4	e5d7e4d9	 ldrb        lr, [r7, #0x4D9]
  000a8	e35e0000	 cmp         lr, #0
  000ac	0a000018	 beq         |$LN21@SDLoadDevi|

; 1499 :                 // can't support this device, it has the non-standard device code and the registry does not
; 1500 :                 // contain the settings for the driver
; 1501 :                 DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDBusDriver: SDIO Device class is of type UNKNOWN, no custom driver found at %s\n"), loadPath));              
; 1502 :             } else {
; 1503 :                 // put back in the default device code reg path
; 1504 :                 HRESULT hr = StringCchPrintf(loadPath, dim(loadPath), 
; 1505 :                     TEXT("%s\\%d"),SDCARD_SDIO_CLASS_REG_PATH,
; 1506 :                     m_SDCardInfo.SDIOInformation.DeviceCode);

  000b0	e59f32d0	 ldr         r3, [pc, #0x2D0]
  000b4	e59f22c8	 ldr         r2, [pc, #0x2C8]
  000b8	e3a01c01	 mov         r1, #1, 24
  000bc	e28d0038	 add         r0, sp, #0x38
  000c0	e58de000	 str         lr, [sp]
  000c4	eb000000	 bl          StringCchPrintfW

; 1507 :                 DEBUGCHK(SUCCEEDED(hr));
; 1508 :                 deviceFound = TRUE;

  000c8	ea000010	 b           |$LN60@SDLoadDevi|
  000cc		 |$LN24@SDLoadDevi|

; 1473 :             // set the default load path for SD Memory Devices
; 1474 :             HRESULT hr = StringCchCopy(loadPath, _countof(loadPath),SDCARD_SDMEMORY_CLASS_REG_PATH);

  000cc	e59f22ac	 ldr         r2, [pc, #0x2AC]
  000d0		 |$LN62@SDLoadDevi|
  000d0	e3a01c01	 mov         r1, #1, 24
  000d4	e28d0038	 add         r0, sp, #0x38
  000d8	eb000000	 bl          StringCchCopyW
  000dc	e1b05000	 movs        r5, r0

; 1475 :             if ( SUCCEEDED(hr)) {

  000e0	4a00000b	 bmi         |$LN21@SDLoadDevi|

; 1476 :                 if (IsHighCapacitySDMemory()) {

  000e4	e1a00007	 mov         r0, r7
  000e8	eb000000	 bl          |?IsHighCapacitySDMemory@CSDDevice@@QAAHXZ|
  000ec	e3500000	 cmp         r0, #0
  000f0	0a000004	 beq         |$LN22@SDLoadDevi|

; 1477 :                     hr = StringCchCat(loadPath, _countof(loadPath),SDCARD_HIGH_CAPACITY_REG_PATH);

  000f4	e59f2280	 ldr         r2, [pc, #0x280]
  000f8	e3a01c01	 mov         r1, #1, 24
  000fc	e28d0038	 add         r0, sp, #0x38
  00100	eb000000	 bl          StringCchCatW
  00104	e1a05000	 mov         r5, r0
  00108		 |$LN22@SDLoadDevi|

; 1478 :                 }
; 1479 :             }
; 1480 :             if (SUCCEEDED(hr)) 

  00108	e3550000	 cmp         r5, #0
  0010c	4a000000	 bmi         |$LN21@SDLoadDevi|
  00110		 |$LN60@SDLoadDevi|

; 1481 :                 deviceFound = TRUE;

  00110	e3a04001	 mov         r4, #1
  00114		 |$LN21@SDLoadDevi|

; 1509 :             }
; 1510 :         }
; 1511 :     }
; 1512 :     ASSERT(deviceFound);
; 1513 :     CSDHostContainer * pHostContainer = CSDHostContainer::GetHostContainer();

  00114	e59f325c	 ldr         r3, [pc, #0x25C]

; 1514 :     
; 1515 :     if (deviceFound && pHostContainer && m_pDriverFolder == NULL  ) {

  00118	e3540000	 cmp         r4, #0
  0011c	e5939000	 ldr         r9, [r3]
  00120	0a00008b	 beq         |$LN11@SDLoadDevi|
  00124	e3590000	 cmp         r9, #0
  00128	0a000089	 beq         |$LN11@SDLoadDevi|
  0012c	e5973420	 ldr         r3, [r7, #0x420]
  00130	e3530000	 cmp         r3, #0
  00134	1a000086	 bne         |$LN11@SDLoadDevi|

; 1516 :         status = SD_API_STATUS_UNSUCCESSFUL;
; 1517 :         Lock();

  00138	e2870008	 add         r0, r7, #8
  0013c	e3a0810f	 mov         r8, #0xF, 2
  00140	eb000000	 bl          EnterCriticalSection

; 1518 : 
; 1519 :         // the reason we pass a regini structure is to make client drivers
; 1520 :         // source code compatible with CE 3.0 where the card handle has to be
; 1521 :         // retrieved from the registry. ActivateDeviceEx does not create the
; 1522 :         // context key. 
; 1523 :         // this little task sets up the context key in the active path 
; 1524 :         HANDLE hDeviceHandle = GetDeviceHandle().hValue;

  00144	e28d1034	 add         r1, sp, #0x34
  00148	e1a00007	 mov         r0, r7
  0014c	eb000000	 bl          |?GetDeviceHandle@CSDDevice@@QAA?AT__SDBUS_DEVICE_HANDLE@@XZ|
  00150	e5903000	 ldr         r3, [r0]

; 1525 :         REGINI riDevice = {
; 1526 :             DEVLOAD_CLIENTINFO_VALNAME,

  00154	e59f2218	 ldr         r2, [pc, #0x218]

; 1527 :                 (PBYTE) &hDeviceHandle,

  00158	e28d101c	 add         r1, sp, #0x1C

; 1528 :                 sizeof(hDeviceHandle),

  0015c	e3a0e004	 mov         lr, #4

; 1529 :                 DEVLOAD_CLIENTINFO_VALTYPE
; 1530 :         };

  00160	e3a04004	 mov         r4, #4

; 1531 :         m_pDriverFolder = new DeviceFolder(pHostContainer->GetSubBusNamePrefix(),loadPath,Internal,
; 1532 :             m_sdSlot.GetHost().GetIndex(),m_sdSlot.GetSlotIndex(),m_FuncionIndex,
; 1533 :             pHostContainer->GetDeviceHandle());

  00164	e3a00060	 mov         r0, #0x60
  00168	e58d301c	 str         r3, [sp, #0x1C]
  0016c	e58d2024	 str         r2, [sp, #0x24]
  00170	e58d1028	 str         r1, [sp, #0x28]
  00174	e58de02c	 str         lr, [sp, #0x2C]
  00178	e58d4030	 str         r4, [sp, #0x30]
  0017c	eb000000	 bl          |??2@YAPAXI@Z|
  00180	e1b0a000	 movs        r10, r0
  00184	e3a0b000	 mov         r11, #0
  00188	0a000014	 beq         |$LN31@SDLoadDevi|
  0018c	e5972438	 ldr         r2, [r7, #0x438]
  00190	e5996020	 ldr         r6, [r9, #0x20]
  00194	e1a00009	 mov         r0, r9
  00198	e592307c	 ldr         r3, [r2, #0x7C]
  0019c	e5924080	 ldr         r4, [r2, #0x80]
  001a0	e593505c	 ldr         r5, [r3, #0x5C]
  001a4	eb000000	 bl          |?GetSubBusNamePrefix@CSDHostContainer@@QAAPBGXZ|
  001a8	e597343c	 ldr         r3, [r7, #0x43C]
  001ac	e1a01000	 mov         r1, r0
  001b0	e3a0e008	 mov         lr, #8
  001b4	e58d3008	 str         r3, [sp, #8]
  001b8	e3a03000	 mov         r3, #0
  001bc	e28d2038	 add         r2, sp, #0x38
  001c0	e1a0000a	 mov         r0, r10
  001c4	e58db014	 str         r11, [sp, #0x14]
  001c8	e58de010	 str         lr, [sp, #0x10]
  001cc	e58d600c	 str         r6, [sp, #0xC]
  001d0	e58d4004	 str         r4, [sp, #4]
  001d4	e58d5000	 str         r5, [sp]
  001d8	eb000000	 bl          |??0DeviceFolder@@QAA@PBG0KKKKPAXK0@Z|
  001dc	ea000000	 b           |$LN32@SDLoadDevi|
  001e0		 |$LN31@SDLoadDevi|
  001e0	e3a00000	 mov         r0, #0
  001e4		 |$LN32@SDLoadDevi|
  001e4	e5870420	 str         r0, [r7, #0x420]

; 1534 :         if (m_pDriverFolder && m_pDriverFolder->Init() && m_pDriverFolder->AddInitReg(1, &riDevice) && pHostContainer->InsertChild(m_pDriverFolder)) {

  001e8	e3500000	 cmp         r0, #0
  001ec	0a000050	 beq         |$LN2@SDLoadDevi|
  001f0	e5903000	 ldr         r3, [r0]
  001f4	e5933004	 ldr         r3, [r3, #4]
  001f8	e1a0e00f	 mov         lr, pc
  001fc	e12fff13	 bx          r3
  00200	e3500000	 cmp         r0, #0
  00204	0a000041	 beq         |$LN10@SDLoadDevi|
  00208	e5970420	 ldr         r0, [r7, #0x420]
  0020c	e28d2024	 add         r2, sp, #0x24
  00210	e3a01001	 mov         r1, #1
  00214	eb000000	 bl          |?AddInitReg@DeviceFolder@@QAAHHPAU_REGINI@@@Z|
  00218	e3500000	 cmp         r0, #0
  0021c	0a00003b	 beq         |$LN10@SDLoadDevi|
  00220	e5993000	 ldr         r3, [r9]
  00224	e5971420	 ldr         r1, [r7, #0x420]
  00228	e1a00009	 mov         r0, r9
  0022c	e5933044	 ldr         r3, [r3, #0x44]
  00230	e1a0e00f	 mov         lr, pc
  00234	e12fff13	 bx          r3
  00238	e3500000	 cmp         r0, #0
  0023c	0a000033	 beq         |$LN10@SDLoadDevi|

; 1535 :             m_pDriverFolder->AddRef();            

  00240	e5973420	 ldr         r3, [r7, #0x420]
  00244	e2830004	 add         r0, r3, #4
  00248	eb000000	 bl          InterlockedIncrement

; 1536 :             m_sdSlot.m_SlotState = Ready;

  0024c	e5973438	 ldr         r3, [r7, #0x438]
  00250	e3a02002	 mov         r2, #2

; 1537 : /*
; 1538 :             // Testing Code
; 1539 :             if (m_DeviceType == Device_SD_Memory) {
; 1540 :                 SD_CARD_SWITCH_FUNCTION sdSwitchData = {
; 1541 :                     0x00000001, // Group 1 set to function 1 High Speed Table 4.7, SD Spec 2.0
; 1542 :                     MAXDWORD,
; 1543 :                     INFINITE,
; 1544 :                 };
; 1545 :                 SD_API_STATUS status = SwitchFunction(&sdSwitchData,FALSE);
; 1546 :             }
; 1547 :             // Endof Test.
; 1548 : */
; 1549 :             m_pDriverFolder->LoadDevice();

  00254	e5832084	 str         r2, [r3, #0x84]
  00258	e5970420	 ldr         r0, [r7, #0x420]
  0025c	e5903000	 ldr         r3, [r0]
  00260	e5933008	 ldr         r3, [r3, #8]
  00264	e1a0e00f	 mov         lr, pc
  00268	e12fff13	 bx          r3

; 1550 :             if ( (m_DeviceType == Device_SD_IO) &&
; 1551 :                  m_SDCardInfo.SDIOInformation.fWUS ) {

  0026c	e5973494	 ldr         r3, [r7, #0x494]
  00270	e3530003	 cmp         r3, #3
  00274	1a00001b	 bne         |$LN6@SDLoadDevi|
  00278	e59734f0	 ldr         r3, [r7, #0x4F0]
  0027c	e3530000	 cmp         r3, #0
  00280	0a000018	 beq         |$LN6@SDLoadDevi|

; 1552 :                 // This SDIO function supports wake up. Tell the host to 
; 1553 :                 // allow waking on SDIO interrupts if the client has a 
; 1554 :                 // registry entry enabling this. It is okay if the host fails 
; 1555 :                 // this call.
; 1556 :                 DWORD fWakeOnSDIOInterrupts;
; 1557 :                 if (!m_pDriverFolder->GetRegValue(SDCARD_WAKE_ON_SDIO_INTERRUPTS_VALNAME,(LPBYTE)&fWakeOnSDIOInterrupts,sizeof(fWakeOnSDIOInterrupts)))

  00284	e5972420	 ldr         r2, [r7, #0x420]
  00288	e59f10e0	 ldr         r1, [pc, #0xE0]
  0028c	e3a03004	 mov         r3, #4
  00290	e2820008	 add         r0, r2, #8
  00294	e28d2018	 add         r2, sp, #0x18
  00298	eb000000	 bl          |?GetRegValue@CRegistryEdit@@QAAHPBGPAEK@Z|
  0029c	e3500000	 cmp         r0, #0

; 1558 :                     fWakeOnSDIOInterrupts = 0 ;

  002a0	03a03000	 moveq       r3, #0
  002a4	058d3018	 streq       r3, [sp, #0x18]
  002a8	159d3018	 ldrne       r3, [sp, #0x18]

; 1559 :                 if (fWakeOnSDIOInterrupts) {

  002ac	e3530000	 cmp         r3, #0
  002b0	0a00000c	 beq         |$LN6@SDLoadDevi|

; 1560 :                     SD_API_STATUS statusHandler = 
; 1561 :                         m_sdSlot.GetHost().SlotOptionHandler(m_sdSlot.m_dwSlotIndex, SDHCDWakeOnSDIOInterrupts,
; 1562 :                             &fWakeOnSDIOInterrupts, sizeof(fWakeOnSDIOInterrupts));

  002b4	e5973438	 ldr         r3, [r7, #0x438]
  002b8	e3a05004	 mov         r5, #4
  002bc	e58d5000	 str         r5, [sp]
  002c0	e593207c	 ldr         r2, [r3, #0x7C]
  002c4	e5931080	 ldr         r1, [r3, #0x80]
  002c8	e28d3018	 add         r3, sp, #0x18
  002cc	e3520000	 cmp         r2, #0
  002d0	e5924044	 ldr         r4, [r2, #0x44]
  002d4	12820008	 addne       r0, r2, #8
  002d8	03a00000	 moveq       r0, #0
  002dc	e3a0200a	 mov         r2, #0xA
  002e0	e1a0e00f	 mov         lr, pc
  002e4	e12fff14	 bx          r4
  002e8		 |$LN6@SDLoadDevi|

; 1563 : 
; 1564 :                     if (!SD_API_SUCCESS(statusHandler)) {
; 1565 :                         DEBUGMSG(SDCARD_ZONE_WARN, (_T("SD: Could not enable waking on SDIO interrupts\r\n")));
; 1566 :                     }
; 1567 :                 }
; 1568 :             }
; 1569 :             if (m_pDriverFolder->IsDriverLoaded())

  002e8	e5970420	 ldr         r0, [r7, #0x420]
  002ec	e5903028	 ldr         r3, [r0, #0x28]
  002f0	e3530000	 cmp         r3, #0
  002f4	0a000002	 beq         |$LN5@SDLoadDevi|

; 1570 :                 status = SD_API_STATUS_SUCCESS;

  002f8	e3a08000	 mov         r8, #0

; 1573 :             }
; 1574 :             
; 1575 :             m_pDriverFolder->DeRef();

  002fc	eb000000	 bl          |?DeRef@CRefObject@@QAAKXZ|
  00300	ea00000b	 b           |$LN2@SDLoadDevi|
  00304		 |$LN5@SDLoadDevi|

; 1571 :             else { // Driver loading failed. So, it mail Register Client callback. We need take it out becaose code is gone.
; 1572 :                 m_pSlotEventCallBack = NULL;

  00304	e587b49c	 str         r11, [r7, #0x49C]

; 1573 :             }
; 1574 :             
; 1575 :             m_pDriverFolder->DeRef();

  00308	eb000000	 bl          |?DeRef@CRefObject@@QAAKXZ|
  0030c	ea000008	 b           |$LN2@SDLoadDevi|
  00310		 |$LN10@SDLoadDevi|

; 1576 :         }
; 1577 :         else if (m_pDriverFolder) {

  00310	e5973420	 ldr         r3, [r7, #0x420]
  00314	e1b00003	 movs        r0, r3
  00318	0a000005	 beq         |$LN2@SDLoadDevi|

; 1578 :             delete m_pDriverFolder;

  0031c	e5903000	 ldr         r3, [r0]
  00320	e3a01001	 mov         r1, #1
  00324	e5933000	 ldr         r3, [r3]
  00328	e1a0e00f	 mov         lr, pc
  0032c	e12fff13	 bx          r3

; 1579 :             m_pDriverFolder = NULL;

  00330	e587b420	 str         r11, [r7, #0x420]
  00334		 |$LN2@SDLoadDevi|

; 1580 :         }
; 1581 :         Unlock();

  00334	e2870008	 add         r0, r7, #8
  00338	eb000000	 bl          LeaveCriticalSection

; 1582 : 
; 1583 :         if (!SD_API_SUCCESS(status)) {

  0033c	e3580000	 cmp         r8, #0

; 1584 :             //m_sdSlot.m_SlotState = SlotInitFailed;
; 1585 :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDBusDriver: Failed to load driver with path: %s \n"), loadPath));
; 1586 :             return status;

  00340	e59d0238	 ldr         r0, [sp, #0x238]
  00344	4affff3d	 bmi         |$LN63@SDLoadDevi|

; 1587 :         }
; 1588 : 
; 1589 :         return SD_API_STATUS_SUCCESS;    

  00348	eb000000	 bl          __security_check_cookie
  0034c	e3a08000	 mov         r8, #0
  00350	ea000002	 b           |$LN29@SDLoadDevi|
  00354		 |$LN11@SDLoadDevi|

; 1590 :     }
; 1591 : 
; 1592 :     return SD_API_STATUS_NO_SUCH_DEVICE;

  00354	e59d0238	 ldr         r0, [sp, #0x238]
  00358	eb000000	 bl          __security_check_cookie
  0035c	e3a08123	 mov         r8, #0x23, 2
  00360		 |$LN29@SDLoadDevi|

; 1593 : 
; 1594 : }

  00360	e1a00008	 mov         r0, r8
  00364	e28ddf8f	 add         sp, sp, #0x8F, 30
  00368	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0036c	e12fff1e	 bx          lr
  00370		 |$LN67@SDLoadDevi|
  00370		 |$LN68@SDLoadDevi|
  00370	00000000	 DCD         |??_C@_1CK@NJIGGLHH@?$AAW?$AAa?$AAk?$AAe?$AAO?$AAn?$AAS?$AAD?$AAI?$AAO?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAs?$AA?$AA@|
  00374		 |$LN69@SDLoadDevi|
  00374	00000000	 DCD         |??_C@_1BG@HOCOHIJB@?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AAI?$AAn?$AAf?$AAo?$AA?$AA@|
  00378		 |$LN70@SDLoadDevi|
  00378	00000000	 DCD         |?g_pSdContainer@CSDHostContainer@@0PAV1@A|
  0037c		 |$LN71@SDLoadDevi|
  0037c	00000000	 DCD         |??_C@_1BO@JBKDDDIL@?$AA?2?$AAH?$AAi?$AAg?$AAh?$AA_?$AAC?$AAa?$AAp?$AAa?$AAc?$AAi?$AAt?$AAy?$AA?$AA@|
  00380		 |$LN72@SDLoadDevi|
  00380	00000000	 DCD         |??_C@_1GG@MMDBJFNM@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAS?$AAD?$AAC?$AAA?$AAR?$AAD?$AA?2?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAC?$AAl@|
  00384		 |$LN73@SDLoadDevi|
  00384	00000000	 DCD         |??_C@_1M@PIGKLJLL@?$AA?$CF?$AAs?$AA?2?$AA?$CF?$AAd?$AA?$AA@|
  00388		 |$LN74@SDLoadDevi|
  00388	00000000	 DCD         |??_C@_1FO@EMODNFIA@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAS?$AAD?$AAC?$AAA?$AAR?$AAD?$AA?2?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAC?$AAl@|
  0038c		 |$LN75@SDLoadDevi|
  0038c	00000000	 DCD         |??_C@_1FM@FFGGNHKA@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAS?$AAD?$AAC?$AAA?$AAR?$AAD?$AA?2?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAC?$AAl@|
  00390		 |$LN76@SDLoadDevi|
  00390	00000000	 DCD         |__security_cookie|
  00394		 |$M41954|

			 ENDP  ; |?SDLoadDevice@CSDDevice@@QAAJXZ|, CSDDevice::SDLoadDevice

	EXPORT	|?RegisterClient@CSDDevice@@QAAJPAX0PAU_SDCARD_CLIENT_REGISTRATION_INFO@@@Z| ; CSDDevice::RegisterClient
	IMPORT	|SDProcessException|
	IMPORT	|CeDriverDuplicateCallerHandle|
	IMPORT	|CeDriverGetDirectCaller|
	IMPORT	|__C_specific_handler|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T42000| DCD	|$LN28@RegisterCl|
	DCD	0xc0003904

  00000			 AREA	 |.pdata|, PDATA
|$T42002| DCD	|$LN13@RegisterCl|
	DCD	0x40000301

  00000			 AREA	 |.xdata|, DATA
|$T41998| DCD	0x1
	DCD	|$LN17@RegisterCl|
	DCD	|$LN18@RegisterCl|
	DCD	|$LN13@RegisterCl|
	DCD	|$LN14@RegisterCl|
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T41998|

  00008		 |?RegisterClient@CSDDevice@@QAAJPAX0PAU_SDCARD_CLIENT_REGISTRATION_INFO@@@Z| PROC ; CSDDevice::RegisterClient

; 1633 : {

  00008		 |$LN28@RegisterCl|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d5bf0	 stmdb       sp!, {r4 - r9, r11, r12, lr}
  00010	e28db024	 add         r11, sp, #0x24
  00014	e24dd004	 sub         sp, sp, #4
  00018		 |$LN26@RegisterCl|
  00018	e1a08003	 mov         r8, r3
  0001c	e1a09002	 mov         r9, r2
  00020	e1a07001	 mov         r7, r1
  00024	e1a06000	 mov         r6, r0

; 1634 :     PREFAST_DEBUGCHK(pInfo);
; 1635 :     SD_API_STATUS status  = SD_API_STATUS_SUCCESS ;
; 1636 :     if (m_hCallbackHandle) { // we already called. We can trash the the handle now

  00028	e596e44c	 ldr         lr, [r6, #0x44C]
  0002c	e3a05000	 mov         r5, #0
  00030	e35e0000	 cmp         lr, #0

; 1637 :         status = SD_API_STATUS_ACCESS_VIOLATION ;

  00034	13a05117	 movne       r5, #0x17, 2

; 1634 :     PREFAST_DEBUGCHK(pInfo);
; 1635 :     SD_API_STATUS status  = SD_API_STATUS_SUCCESS ;
; 1636 :     if (m_hCallbackHandle) { // we already called. We can trash the the handle now

  00038	1a000027	 bne         |$LN19@RegisterCl|

; 1638 :     }
; 1639 :     else  if (hCallbackHandle) {

  0003c	e3570000	 cmp         r7, #0
  00040	0a000014	 beq         |$LN7@RegisterCl|

; 1640 :         if (CeDriverGetDirectCaller() == GetCurrentProcessId()) { // We can use it directly.

  00044	eb000000	 bl          CeDriverGetDirectCaller
  00048	e1a04000	 mov         r4, r0
  0004c	e3a0000c	 mov         r0, #0xC
  00050	eb000000	 bl          __GetUserKData
  00054	e1540000	 cmp         r4, r0

; 1641 :             m_hCallbackHandle = hCallbackHandle;
; 1642 :             m_fIsHandleCopied = FALSE;

  00058	03a03000	 moveq       r3, #0
  0005c	0586744c	 streq       r7, [r6, #0x44C]

; 1640 :         if (CeDriverGetDirectCaller() == GetCurrentProcessId()) { // We can use it directly.

  00060	0a000006	 beq         |$LN25@RegisterCl|

; 1643 :         }
; 1644 :         else {
; 1645 :             m_hCallbackHandle = CeDriverDuplicateCallerHandle(hCallbackHandle,
; 1646 :                 0,FALSE,DUPLICATE_SAME_ACCESS);

  00064	e3a03002	 mov         r3, #2
  00068	e3a02000	 mov         r2, #0
  0006c	e3a01000	 mov         r1, #0
  00070	e1a00007	 mov         r0, r7
  00074	eb000000	 bl          CeDriverDuplicateCallerHandle

; 1647 :             m_fIsHandleCopied = TRUE;

  00078	e3a03001	 mov         r3, #1
  0007c	e586044c	 str         r0, [r6, #0x44C]
  00080		 |$LN25@RegisterCl|
  00080	e5863448	 str         r3, [r6, #0x448]

; 1648 :         }
; 1649 :         if (m_hCallbackHandle == NULL) {

  00084	e596344c	 ldr         r3, [r6, #0x44C]
  00088	e3530000	 cmp         r3, #0
  0008c	1a000003	 bne         |$LN3@RegisterCl|

; 1650 :             status = SD_API_STATUS_INVALID_HANDLE;

  00090	e3a0511b	 mov         r5, #0x1B, 2

; 1651 :         }
; 1652 :     }
; 1653 :     else

  00094	ea000001	 b           |$LN3@RegisterCl|
  00098		 |$LN7@RegisterCl|

; 1654 :         m_hCallbackHandle = NULL ;

  00098	e3a03000	 mov         r3, #0
  0009c	e586344c	 str         r3, [r6, #0x44C]
  000a0		 |$LN3@RegisterCl|

; 1655 :     
; 1656 :     if (SD_API_SUCCESS(status)) {

  000a0	e3550000	 cmp         r5, #0
  000a4	4a00000c	 bmi         |$LN19@RegisterCl|
  000a8		 |$LN17@RegisterCl|

; 1657 :     // save the registration information
; 1658 :         __try {
; 1659 :             HRESULT hr = StringCchCopy(  m_ClientName , _countof(m_ClientName), pInfo->ClientName);

  000a8	e1a02008	 mov         r2, r8
  000ac	e3a01020	 mov         r1, #0x20
  000b0	e2860e45	 add         r0, r6, #0x45, 28
  000b4	eb000000	 bl          StringCchCopyW

; 1660 :             ASSERT(SUCCEEDED(hr));
; 1661 :             m_pDeviceContext = pContext;

  000b8	e5869498	 str         r9, [r6, #0x498]

; 1662 :             m_pSlotEventCallBack = pInfo->pSlotEventCallBack;

  000bc	e5983040	 ldr         r3, [r8, #0x40]
  000c0	e586349c	 str         r3, [r6, #0x49C]

; 1663 :             m_ClientFlags = pInfo->ClientFlags;

  000c4	e5983044	 ldr         r3, [r8, #0x44]
  000c8	e5863490	 str         r3, [r6, #0x490]
  000cc		 |$LN18@RegisterCl|

; 1664 :         }

  000cc	ea000002	 b           |$LN19@RegisterCl|
  000d0		 |$LN14@RegisterCl|

; 1666 :             status = SD_API_STATUS_ACCESS_VIOLATION;

  000d0	e3a05117	 mov         r5, #0x17, 2
  000d4	ea000000	 b           |$LN19@RegisterCl|
  000d8		 |$LN24@RegisterCl|

; 1667 :         }
; 1668 :     }
; 1669 :     ASSERT(SD_API_SUCCESS(status));
; 1670 :     return status;

  000d8	e51b5028	 ldr         r5, [r11, #-0x28]
  000dc		 |$LN19@RegisterCl|

; 1671 : }

  000dc	e1a00005	 mov         r0, r5
  000e0	e24bd024	 sub         sp, r11, #0x24
  000e4	e89d6bf0	 ldmia       sp, {r4 - r9, r11, sp, lr}
  000e8	e12fff1e	 bx          lr

			 ENDP  ; |?RegisterClient@CSDDevice@@QAAJPAX0PAU_SDCARD_CLIENT_REGISTRATION_INFO@@@Z|, CSDDevice::RegisterClient

  000ec		 |$LN13@RegisterCl|
  000ec		 |$LN27@RegisterCl|

; 1665 :         __except (SDProcessException(GetExceptionInformation())) {

  000ec	e52de004	 str         lr, [sp, #-4]!
  000f0		 |$LN16@RegisterCl|
  000f0		 |$LN30@RegisterCl|
  000f0	eb000000	 bl          SDProcessException
  000f4		 |$LN15@RegisterCl|
  000f4	e49df004	 ldr         pc, [sp], #4
  000f8		 |$LN31@RegisterCl|
  000f8		 |$LN29@RegisterCl|
	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?SetupWakeupSupport@CSDDevice@@QAAXXZ|	; CSDDevice::SetupWakeupSupport

  00000			 AREA	 |.pdata|, PDATA
|$T42019| DCD	|$LN8@SetupWakeu|
	DCD	0xc0002d02

  00000			 AREA	 |.xdata|, DATA
|$T42015| DCD	0xffffffe8
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T42015|

  00008		 |?SetupWakeupSupport@CSDDevice@@QAAXXZ| PROC ; CSDDevice::SetupWakeupSupport

; 1682 : {

  00008		 |$LN8@SetupWakeu|
  00008	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  0000c	e24ddf43	 sub         sp, sp, #0x43, 30
  00010		 |$M42016|
  00010	e1a06000	 mov         r6, r0
  00014	e59f309c	 ldr         r3, [pc, #0x9C]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3108	 str         r3, [sp, #0x108]

; 1683 :     BOOL fRet = FALSE;
; 1684 :     BYTE rgbFunce[SD_CISTPLE_MAX_BODY_SIZE];
; 1685 :     PSD_CISTPL_FUNCE_FUNCTION pFunce = (PSD_CISTPL_FUNCE_FUNCTION) rgbFunce;
; 1686 :     DWORD cbTuple;
; 1687 :     
; 1688 :     SD_API_STATUS status = SDGetTuple_I(SD_CISTPL_FUNCE, NULL, &cbTuple, FALSE);
; 1689 : 
; 1690 :     if ( SD_API_SUCCESS(status) && (cbTuple <= sizeof(rgbFunce)) ) {

  00020	e5962000	 ldr         r2, [r6]
  00024	e3a07000	 mov         r7, #0
  00028	e28d3004	 add         r3, sp, #4
  0002c	e5924030	 ldr         r4, [r2, #0x30]
  00030	e3a02000	 mov         r2, #0
  00034	e3a01022	 mov         r1, #0x22
  00038	e3a05000	 mov         r5, #0
  0003c	e58d7000	 str         r7, [sp]
  00040	e1a0e00f	 mov         lr, pc
  00044	e12fff14	 bx          r4
  00048	e3500000	 cmp         r0, #0
  0004c	4a000013	 bmi         |$LN1@SetupWakeu|
  00050	e59d3004	 ldr         r3, [sp, #4]
  00054	e3530c01	 cmp         r3, #1, 24
  00058	8a000010	 bhi         |$LN1@SetupWakeu|

; 1691 :         status = SDGetTuple_I(SD_CISTPL_FUNCE, rgbFunce, &cbTuple, FALSE);
; 1692 :         if ( SD_API_SUCCESS(status) && (pFunce->bType == SD_CISTPL_FUNCE_FUNCTION_TYPE) ) {

  0005c	e5961000	 ldr         r1, [r6]
  00060	e28d3004	 add         r3, sp, #4
  00064	e28d2008	 add         r2, sp, #8
  00068	e5914030	 ldr         r4, [r1, #0x30]
  0006c	e3a01022	 mov         r1, #0x22
  00070	e1a00006	 mov         r0, r6
  00074	e58d7000	 str         r7, [sp]
  00078	e1a0e00f	 mov         lr, pc
  0007c	e12fff14	 bx          r4
  00080	e3500000	 cmp         r0, #0
  00084	4a000005	 bmi         |$LN1@SetupWakeu|
  00088	e5dd3008	 ldrb        r3, [sp, #8]
  0008c	e3530001	 cmp         r3, #1
  00090	1a000002	 bne         |$LN1@SetupWakeu|

; 1693 :             // Valid FUNCE tuple. Check the wake up support bit.
; 1694 :             if (pFunce->FN_WUS) {

  00094	e5dd3009	 ldrb        r3, [sp, #9]
  00098	e3130001	 tst         r3, #1

; 1695 :                 fRet = TRUE;

  0009c	13a05001	 movne       r5, #1
  000a0		 |$LN1@SetupWakeu|

; 1696 :             }
; 1697 :         }
; 1698 :     }
; 1699 :     m_SDCardInfo.SDIOInformation.fWUS = fRet;

  000a0	e58654f0	 str         r5, [r6, #0x4F0]
  000a4	e59d0108	 ldr         r0, [sp, #0x108]
  000a8	eb000000	 bl          __security_check_cookie

; 1700 :     
; 1701 : }

  000ac	e28ddf43	 add         sp, sp, #0x43, 30
  000b0	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000b4	e12fff1e	 bx          lr
  000b8		 |$LN9@SetupWakeu|
  000b8		 |$LN10@SetupWakeu|
  000b8	00000000	 DCD         |__security_cookie|
  000bc		 |$M42017|

			 ENDP  ; |?SetupWakeupSupport@CSDDevice@@QAAXXZ|, CSDDevice::SetupWakeupSupport

	EXPORT	|?FormatProductString@CSDDevice@@IBAXPADPAG@Z| ; CSDDevice::FormatProductString
	IMPORT	|strlen|

  00000			 AREA	 |.pdata|, PDATA
|$T42035| DCD	|$LN12@FormatProd|
	DCD	0x40002001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FormatProductString@CSDDevice@@IBAXPADPAG@Z| PROC ; CSDDevice::FormatProductString

; 2030 : {

  00000		 |$LN12@FormatProd|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M42032|
  00004	e1a06002	 mov         r6, r2
  00008	e1a07001	 mov         r7, r1

; 2031 :     ULONG  ii;  // loop variable
; 2032 : 
; 2033 :     for (ii = 0; ii < strlen(pAsciiString); ii++) {

  0000c	e1a00007	 mov         r0, r7
  00010	e3a05000	 mov         r5, #0
  00014	eb000000	 bl          strlen
  00018	e3500000	 cmp         r0, #0
  0001c	0a000012	 beq         |$LN3@FormatProd|
  00020	e1a04006	 mov         r4, r6
  00024	e3a0805f	 mov         r8, #0x5F
  00028		 |$LL5@FormatProd|
  00028	e1a00005	 mov         r0, r5

; 2034 :         // convert to Wide char
; 2035 :         pString[ii] = (WCHAR)pAsciiString[ii];

  0002c	e1b030d7	 ldrsb       r3, [r0, +r7]!
  00030	e1c430b0	 strh        r3, [r4]

; 2036 : 
; 2037 :         // if the character is outside the range of displayable characters
; 2038 :         // then substitute with an under score
; 2039 :         if ((pAsciiString[ii] <= 0x20) || (pAsciiString[ii] > 0x7E)) {

  00034	e1d030d0	 ldrsb       r3, [r0]
  00038	e3530020	 cmp         r3, #0x20
  0003c	da000003	 ble         |$LN1@FormatProd|
  00040	e1a03c03	 mov         r3, r3, lsl #24
  00044	e1a03c43	 mov         r3, r3, asr #24
  00048	e353007e	 cmp         r3, #0x7E
  0004c	da000000	 ble         |$LN4@FormatProd|
  00050		 |$LN1@FormatProd|

; 2040 :             pString[ii] = TEXT('_');

  00050	e1c480b0	 strh        r8, [r4]
  00054		 |$LN4@FormatProd|

; 2031 :     ULONG  ii;  // loop variable
; 2032 : 
; 2033 :     for (ii = 0; ii < strlen(pAsciiString); ii++) {

  00054	e1a00007	 mov         r0, r7
  00058	e2855001	 add         r5, r5, #1
  0005c	e2844002	 add         r4, r4, #2
  00060	eb000000	 bl          strlen
  00064	e1550000	 cmp         r5, r0
  00068	3affffee	 bcc         |$LL5@FormatProd|
  0006c		 |$LN3@FormatProd|

; 2041 :         }
; 2042 :     }
; 2043 : 
; 2044 :     // terminate
; 2045 :     pString[ii] = NULL;

  0006c	e0863085	 add         r3, r6, r5, lsl #1
  00070	e3a02000	 mov         r2, #0
  00074	e1c320b0	 strh        r2, [r3]

; 2046 : }

  00078	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$M42033|

			 ENDP  ; |?FormatProductString@CSDDevice@@IBAXPADPAG@Z|, CSDDevice::FormatProductString

	EXPORT	|?SendSDAppCmd@CSDDevice@@MAAJEKW4SD_TRANSFER_CLASS@@W4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@KKPAE@Z| ; CSDDevice::SendSDAppCmd
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T42078| DCD	|$LN27@SendSDAppC@2|
	DCD	0x40007b02
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SendSDAppCmd@CSDDevice@@MAAJEKW4SD_TRANSFER_CLASS@@W4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@KKPAE@Z| PROC ; CSDDevice::SendSDAppCmd

; 2071 : {

  00000		 |$LN27@SendSDAppC@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd030	 sub         sp, sp, #0x30
  00008		 |$M42075|
  00008	e1a07003	 mov         r7, r3
  0000c	e1a08002	 mov         r8, r2
  00010	e58d7024	 str         r7, [sp, #0x24]
  00014	e58d8028	 str         r8, [sp, #0x28]
  00018	e5cd1020	 strb        r1, [sp, #0x20]
  0001c	e1a09000	 mov         r9, r0

; 2072 :     SD_API_STATUS          status;          // intermediate status
; 2073 :     ULONG                  retryCount;      // retry count
; 2074 :     ULONG                  i;               // loop variable
; 2075 : 
; 2076 : 
; 2077 :     // send the APP Command primer (CMD 55)
; 2078 :     status = SendSDCommand(SD_CMD_APP_CMD,((DWORD)GetRelativeAddress()) << 16,ResponseR1, pResponse);

  00020	e289eb01	 add         lr, r9, #1, 22
  00024	e1deeab0	 ldrh        lr, [lr, #0xA0]
  00028	e59da058	 ldr         r10, [sp, #0x58]
  0002c	e3a03001	 mov         r3, #1
  00030	e1a0280e	 mov         r2, lr, lsl #16
  00034	e3a01037	 mov         r1, #0x37
  00038	e58da000	 str         r10, [sp]
  0003c	eb000000	 bl          |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|
  00040	e3500000	 cmp         r0, #0

; 2079 : 
; 2080 :     if (!SD_API_SUCCESS(status)){
; 2081 :         return status;

  00044	4a000064	 bmi         |$LN7@SendSDAppC@2|

; 2082 :     } 
; 2083 :     
; 2084 :     // CMD55 did not timeout so send the command
; 2085 :     if ((m_ClientFlags & SD_CLIENT_HANDLES_RETRY)!=0 ) {

  00048	e5996490	 ldr         r6, [r9, #0x490]

; 2086 :         status = SDSynchronousBusRequest_I( Command,
; 2087 :             Argument,
; 2088 :             TransferClass, 
; 2089 :             ResponseType,
; 2090 :             pResponse,
; 2091 :             NumberOfBlocks,
; 2092 :             BlockSize, 
; 2093 :             pBlockBuffer,
; 2094 :             SD_SLOTRESET_REQUEST);

  0004c	e5993000	 ldr         r3, [r9]
  00050	e5dd1020	 ldrb        r1, [sp, #0x20]
  00054	e58d602c	 str         r6, [sp, #0x2C]
  00058	e3160001	 tst         r6, #1
  0005c	e3a0b000	 mov         r11, #0
  00060	e1a00009	 mov         r0, r9
  00064	0a000012	 beq         |$LN8@SendSDAppC@2|
  00068	e59d4064	 ldr         r4, [sp, #0x64]
  0006c	e59d5060	 ldr         r5, [sp, #0x60]
  00070	e59d605c	 ldr         r6, [sp, #0x5C]
  00074	e59d7054	 ldr         r7, [sp, #0x54]
  00078	e5938014	 ldr         r8, [r3, #0x14]
  0007c	e59d3024	 ldr         r3, [sp, #0x24]
  00080	e59d2028	 ldr         r2, [sp, #0x28]
  00084	e3a09008	 mov         r9, #8
  00088	e58d4010	 str         r4, [sp, #0x10]
  0008c	e58d500c	 str         r5, [sp, #0xC]
  00090	e58d6008	 str         r6, [sp, #8]
  00094	e58d7000	 str         r7, [sp]
  00098	e58db01c	 str         r11, [sp, #0x1C]
  0009c	e58db018	 str         r11, [sp, #0x18]
  000a0	e58d9014	 str         r9, [sp, #0x14]
  000a4	e58da004	 str         r10, [sp, #4]
  000a8	e1a0e00f	 mov         lr, pc
  000ac	e12fff18	 bx          r8

; 2095 :     }
; 2096 :     else {

  000b0	ea000049	 b           |$LN7@SendSDAppC@2|
  000b4		 |$LN8@SendSDAppC@2|

; 2097 :         
; 2098 :         // save original ClientFlags
; 2099 :         DWORD clientFlags = m_ClientFlags;   
; 2100 :         m_ClientFlags |= SD_CLIENT_HANDLES_RETRY;
; 2101 : 
; 2102 :         status = SDSynchronousBusRequest_I( Command,
; 2103 :             Argument,
; 2104 :             TransferClass, 
; 2105 :             ResponseType,
; 2106 :             pResponse,
; 2107 :             NumberOfBlocks,
; 2108 :             BlockSize, 
; 2109 :             pBlockBuffer,
; 2110 :             SD_SLOTRESET_REQUEST);

  000b4	e3864001	 orr         r4, r6, #1
  000b8	e5894490	 str         r4, [r9, #0x490]
  000bc	e3a04008	 mov         r4, #8
  000c0	e58d4014	 str         r4, [sp, #0x14]
  000c4	e59d4064	 ldr         r4, [sp, #0x64]
  000c8	e5935014	 ldr         r5, [r3, #0x14]
  000cc	e1a03007	 mov         r3, r7
  000d0	e58d4010	 str         r4, [sp, #0x10]
  000d4	e59d4060	 ldr         r4, [sp, #0x60]
  000d8	e1a02008	 mov         r2, r8
  000dc	e58db01c	 str         r11, [sp, #0x1C]
  000e0	e58d400c	 str         r4, [sp, #0xC]
  000e4	e59d405c	 ldr         r4, [sp, #0x5C]
  000e8	e58db018	 str         r11, [sp, #0x18]
  000ec	e58da004	 str         r10, [sp, #4]
  000f0	e58d4008	 str         r4, [sp, #8]
  000f4	e59d4054	 ldr         r4, [sp, #0x54]
  000f8	e58d4000	 str         r4, [sp]
  000fc	e1a0e00f	 mov         lr, pc
  00100	e12fff15	 bx          r5
  00104	e3500000	 cmp         r0, #0

; 2111 : 
; 2112 :         if (!SD_API_SUCCESS(status)) {

  00108	5a000032	 bpl         |$LN21@SendSDAppC@2|

; 2113 :             retryCount = CSDHostContainer::GetRetryCount();

  0010c	e59f30d4	 ldr         r3, [pc, #0xD4]

; 2114 : 
; 2115 :             for (i = 0; i < retryCount; i++) {

  00110	e3a07000	 mov         r7, #0
  00114	e5933000	 ldr         r3, [r3]
  00118	e3530000	 cmp         r3, #0
  0011c	159350b0	 ldrne       r5, [r3, #0xB0]
  00120	03a05000	 moveq       r5, #0
  00124	e3550000	 cmp         r5, #0
  00128	0a00002a	 beq         |$LN21@SendSDAppC@2|
  0012c	e59d6024	 ldr         r6, [sp, #0x24]
  00130	e2898b01	 add         r8, r9, #1, 22
  00134		 |$LL5@SendSDAppC@2|

; 2116 :                 // check for retry
; 2117 :                 if ( !( (SD_API_STATUS_RESPONSE_TIMEOUT == status) || 
; 2118 :                         (SD_API_STATUS_DATA_TIMEOUT == status) ||
; 2119 :                         (SD_API_STATUS_CRC_ERROR == status) ) ) {

  00134	e3500153	 cmp         r0, #0x53, 2
  00138	0a000003	 beq         |$LN2@SendSDAppC@2|
  0013c	e3500157	 cmp         r0, #0x57, 2
  00140	0a000001	 beq         |$LN2@SendSDAppC@2|
  00144	e3500137	 cmp         r0, #0x37, 2
  00148	1a000021	 bne         |$LN24@SendSDAppC@2|
  0014c		 |$LN2@SendSDAppC@2|

; 2120 :                     break;
; 2121 :                 }
; 2122 : 
; 2123 :                 // send the APP Command primer (CMD55)
; 2124 :                 status = SendSDCommand(SD_CMD_APP_CMD,((DWORD)GetRelativeAddress()) << 16, ResponseR1, pResponse);

  0014c	e1d82ab0	 ldrh        r2, [r8, #0xA0]
  00150	e3a03001	 mov         r3, #1
  00154	e3a01037	 mov         r1, #0x37
  00158	e1a02802	 mov         r2, r2, lsl #16
  0015c	e1a00009	 mov         r0, r9
  00160	e58da000	 str         r10, [sp]
  00164	eb000000	 bl          |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|
  00168	e3500000	 cmp         r0, #0

; 2125 : 
; 2126 :                 if (!SD_API_SUCCESS(status)){

  0016c	4a000018	 bmi         |$LN24@SendSDAppC@2|

; 2127 :                      break;
; 2128 :                 }
; 2129 : 
; 2130 :                 // send the command again
; 2131 :                 status = SDSynchronousBusRequest_I( Command,
; 2132 :                     Argument,
; 2133 :                     TransferClass, 
; 2134 :                     ResponseType,
; 2135 :                     pResponse,
; 2136 :                     NumberOfBlocks,
; 2137 :                     BlockSize, 
; 2138 :                     pBlockBuffer,
; 2139 :                     SD_SLOTRESET_REQUEST);

  00170	e3a08008	 mov         r8, #8
  00174	e58d8014	 str         r8, [sp, #0x14]
  00178	e59d8064	 ldr         r8, [sp, #0x64]
  0017c	e5991000	 ldr         r1, [r9]
  00180	e59d2028	 ldr         r2, [sp, #0x28]
  00184	e58d8010	 str         r8, [sp, #0x10]
  00188	e59d8060	 ldr         r8, [sp, #0x60]
  0018c	e5914014	 ldr         r4, [r1, #0x14]
  00190	e5dd1020	 ldrb        r1, [sp, #0x20]
  00194	e58d800c	 str         r8, [sp, #0xC]
  00198	e59d805c	 ldr         r8, [sp, #0x5C]
  0019c	e1a03006	 mov         r3, r6
  001a0	e1a00009	 mov         r0, r9
  001a4	e58d8008	 str         r8, [sp, #8]
  001a8	e59d8054	 ldr         r8, [sp, #0x54]
  001ac	e58db01c	 str         r11, [sp, #0x1C]
  001b0	e58db018	 str         r11, [sp, #0x18]
  001b4	e58d8000	 str         r8, [sp]
  001b8	e58da004	 str         r10, [sp, #4]
  001bc	e1a0e00f	 mov         lr, pc
  001c0	e12fff14	 bx          r4
  001c4	e2877001	 add         r7, r7, #1
  001c8	e1570005	 cmp         r7, r5
  001cc	e2898b01	 add         r8, r9, #1, 22
  001d0	3affffd7	 bcc         |$LL5@SendSDAppC@2|
  001d4		 |$LN24@SendSDAppC@2|

; 2082 :     } 
; 2083 :     
; 2084 :     // CMD55 did not timeout so send the command
; 2085 :     if ((m_ClientFlags & SD_CLIENT_HANDLES_RETRY)!=0 ) {

  001d4	e59d602c	 ldr         r6, [sp, #0x2C]
  001d8		 |$LN21@SendSDAppC@2|

; 2140 : 
; 2141 :             }
; 2142 :         }
; 2143 : 
; 2144 :         // restore client flags
; 2145 :         m_ClientFlags = clientFlags;

  001d8	e5896490	 str         r6, [r9, #0x490]
  001dc		 |$LN7@SendSDAppC@2|

; 2146 :     }
; 2147 : 
; 2148 :     return status;
; 2149 : }

  001dc	e28dd030	 add         sp, sp, #0x30
  001e0	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001e4	e12fff1e	 bx          lr
  001e8		 |$LN28@SendSDAppC@2|
  001e8		 |$LN29@SendSDAppC@2|
  001e8	00000000	 DCD         |?g_pSdContainer@CSDHostContainer@@0PAV1@A|
  001ec		 |$M42076|

			 ENDP  ; |?SendSDAppCmd@CSDDevice@@MAAJEKW4SD_TRANSFER_CLASS@@W4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@KKPAE@Z|, CSDDevice::SendSDAppCmd

	EXPORT	|?CopyContentFromParent@CSDDevice@@QAAXAAV1@@Z| ; CSDDevice::CopyContentFromParent

  00000			 AREA	 |.pdata|, PDATA
|$T42089| DCD	|$LN5@CopyConten|
	DCD	0x40001001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CopyContentFromParent@CSDDevice@@QAAXAAV1@@Z| PROC ; CSDDevice::CopyContentFromParent

; 2153 : {

  00000		 |$LN5@CopyConten|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M42086|
  00004	e1a04000	 mov         r4, r0

; 2154 :     m_RelativeAddress = psdDevice0.m_RelativeAddress;

  00008	e2813b01	 add         r3, r1, #1, 22
  0000c	e1d32ab0	 ldrh        r2, [r3, #0xA0]
  00010	e2843b01	 add         r3, r4, #1, 22

; 2155 :     m_OperatingVoltage = psdDevice0.m_OperatingVoltage;
; 2156 :     m_CachedRegisters = psdDevice0.m_CachedRegisters;

  00014	e284eb01	 add         lr, r4, #1, 22
  00018	e1c32ab0	 strh        r2, [r3, #0xA0]
  0001c	e59134d0	 ldr         r3, [r1, #0x4D0]
  00020	e2812b01	 add         r2, r1, #1, 22
  00024	e28210a2	 add         r1, r2, #0xA2
  00028	e3a0202c	 mov         r2, #0x2C
  0002c	e28e00a2	 add         r0, lr, #0xA2
  00030	e58434d0	 str         r3, [r4, #0x4D0]
  00034	eb000000	 bl          memcpy

; 2157 : 
; 2158 : }

  00038	e8bd4010	 ldmia       sp!, {r4, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$M42087|

			 ENDP  ; |?CopyContentFromParent@CSDDevice@@QAAXAAV1@@Z|, CSDDevice::CopyContentFromParent

	EXPORT	|?NotifyClient@CSDDevice@@QAAXW4_SD_SLOT_EVENT_TYPE@@@Z| ; CSDDevice::NotifyClient
	IMPORT	|CeDriverPerformCallback|
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T42119| DCD	|$LN28@NotifyClie|
	DCD	0xc0003e05

  00000			 AREA	 |.pdata|, PDATA
|$T42121| DCD	|$LN13@NotifyClie|
	DCD	0x40000602

  00000			 AREA	 |.xdata|, DATA
|$T42117| DCD	0x1
	DCD	|$LN17@NotifyClie|
	DCD	|$LN18@NotifyClie|
	DCD	|$LN13@NotifyClie|
	DCD	|$LN14@NotifyClie|
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T42117|

  00008		 |?NotifyClient@CSDDevice@@QAAXW4_SD_SLOT_EVENT_TYPE@@@Z| PROC ; CSDDevice::NotifyClient

; 2160 : {

  00008		 |$LN28@NotifyClie|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d0003	 stmdb       sp!, {r0, r1}
  00010	e92d58f0	 stmdb       sp!, {r4 - r7, r11, r12, lr}
  00014	e28db01c	 add         r11, sp, #0x1C
  00018	e24dd02c	 sub         sp, sp, #0x2C
  0001c		 |$LN26@NotifyClie|
  0001c	e1a06001	 mov         r6, r1
  00020	e1a04000	 mov         r4, r0
  00024	e58b4000	 str         r4, [r11]

; 2161 :     PVOID pEventData = NULL;    // event data (defaults to NULL)
; 2162 :     DWORD eventDataLength = 0;  // event data length
; 2163 : 
; 2164 :     switch (Event) {
; 2165 :         case SDCardEjected :
; 2166 :         case SDCardBeginSelectDeselect:
; 2167 :         case SDCardDeselected:
; 2168 :         case SDCardSelected:
; 2169 :         case SDCardDeselectRequest:
; 2170 :         case SDCardSelectRequest:
; 2171 : 
; 2172 :             break;
; 2173 :         default:
; 2174 :             DEBUGCHK(FALSE);
; 2175 :     }
; 2176 :     Lock();

  00028	e2840008	 add         r0, r4, #8
  0002c	eb000000	 bl          EnterCriticalSection

; 2177 :         // make sure this callback can be called
; 2178 :     if (NULL != m_pDriverFolder ) {

  00030	e5943420	 ldr         r3, [r4, #0x420]
  00034	e3530000	 cmp         r3, #0
  00038	0a00002b	 beq         |$LN19@NotifyClie|
  0003c		 |$LN17@NotifyClie|

; 2179 :         __try {
; 2180 :             if (NULL != m_hCallbackHandle && m_pSlotEventCallBack!=NULL ) {

  0003c	e594344c	 ldr         r3, [r4, #0x44C]
  00040	e1b05003	 movs        r5, r3
  00044	0a000018	 beq         |$LN3@NotifyClie|
  00048	e594349c	 ldr         r3, [r4, #0x49C]
  0004c	e3530000	 cmp         r3, #0
  00050	0a000015	 beq         |$LN3@NotifyClie|

; 2181 :                 IO_BUS_SD_SLOT_EVENT_CALLBACK busSdSlogEventCallback = {
; 2182 :                     m_pSlotEventCallBack,(SD_DEVICE_HANDLE)GetDeviceHandle().hValue,

  00054	e24b1038	 sub         r1, r11, #0x38
  00058	e1a00004	 mov         r0, r4
  0005c	e50b3034	 str         r3, [r11, #-0x34]
  00060	eb000000	 bl          |?GetDeviceHandle@CSDDevice@@QAA?AT__SDBUS_DEVICE_HANDLE@@XZ|
  00064	e5902000	 ldr         r2, [r0]

; 2183 :                     m_pDeviceContext, 
; 2184 :                     Event,  0, 0  };
; 2185 :                 CeDriverPerformCallback(m_hCallbackHandle,IOCTL_BUS_SD_SLOT_EVENT_CALLBACK,&busSdSlogEventCallback,sizeof(busSdSlogEventCallback),
; 2186 :                     NULL,0,NULL,NULL);

  00068	e59f10a4	 ldr         r1, [pc, #0xA4]
  0006c	e3a03018	 mov         r3, #0x18
  00070	e50b2030	 str         r2, [r11, #-0x30]
  00074	e594e498	 ldr         lr, [r4, #0x498]
  00078	e24b2034	 sub         r2, r11, #0x34
  0007c	e1a00005	 mov         r0, r5
  00080	e50be02c	 str         lr, [r11, #-0x2C]
  00084	e50b6028	 str         r6, [r11, #-0x28]
  00088	e3a0e000	 mov         lr, #0
  0008c	e50be024	 str         lr, [r11, #-0x24]
  00090	e50be020	 str         lr, [r11, #-0x20]
  00094	e58de00c	 str         lr, [sp, #0xC]
  00098	e58de008	 str         lr, [sp, #8]
  0009c	e58de004	 str         lr, [sp, #4]
  000a0	e58de000	 str         lr, [sp]
  000a4	eb000000	 bl          CeDriverPerformCallback
  000a8	ea00000d	 b           |$LN18@NotifyClie|
  000ac		 |$LN3@NotifyClie|

; 2187 :             }
; 2188 :             else if (NULL != m_pSlotEventCallBack ) {

  000ac	e594349c	 ldr         r3, [r4, #0x49C]
  000b0	e1b05003	 movs        r5, r3
  000b4	0a00000a	 beq         |$LN18@NotifyClie|

; 2189 :                 m_pSlotEventCallBack ((SD_DEVICE_HANDLE)GetDeviceHandle().hValue,          
; 2190 :                     m_pDeviceContext, Event, pEventData, eventDataLength);    

  000b8	e24b1038	 sub         r1, r11, #0x38
  000bc	e1a00004	 mov         r0, r4
  000c0	eb000000	 bl          |?GetDeviceHandle@CSDDevice@@QAA?AT__SDBUS_DEVICE_HANDLE@@XZ|
  000c4	e5900000	 ldr         r0, [r0]
  000c8	e5941498	 ldr         r1, [r4, #0x498]
  000cc	e3a07000	 mov         r7, #0
  000d0	e3a03000	 mov         r3, #0
  000d4	e1a02006	 mov         r2, r6
  000d8	e58d7000	 str         r7, [sp]
  000dc	e1a0e00f	 mov         lr, pc
  000e0	e12fff15	 bx          r5
  000e4		 |$LN18@NotifyClie|

; 2191 :             }

  000e4	ea000000	 b           |$LN19@NotifyClie|
  000e8		 |$LN14@NotifyClie|

; 2192 :                 
; 2193 :         } __except (SDProcessException(GetExceptionInformation())) {

  000e8	e59b4000	 ldr         r4, [r11]
  000ec		 |$LN19@NotifyClie|

; 2194 :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDBusDriver: slot event callback resulted in an exception \n")));              
; 2195 :         }
; 2196 :     }
; 2197 :     Unlock();

  000ec	e2840008	 add         r0, r4, #8
  000f0	eb000000	 bl          LeaveCriticalSection
  000f4		 |$LN22@NotifyClie|

; 2198 : 
; 2199 : }

  000f4	e24bd01c	 sub         sp, r11, #0x1C
  000f8	e89d68f0	 ldmia       sp, {r4 - r7, r11, sp, lr}
  000fc	e12fff1e	 bx          lr

			 ENDP  ; |?NotifyClient@CSDDevice@@QAAXW4_SD_SLOT_EVENT_TYPE@@@Z|, CSDDevice::NotifyClient

  00100		 |$LN13@NotifyClie|
  00100		 |$LN27@NotifyClie|

; 2192 :                 
; 2193 :         } __except (SDProcessException(GetExceptionInformation())) {

  00100	e52de004	 str         lr, [sp, #-4]!
  00104	e24dd010	 sub         sp, sp, #0x10
  00108		 |$LN16@NotifyClie|
  00108		 |$LN30@NotifyClie|
  00108	eb000000	 bl          SDProcessException
  0010c		 |$LN15@NotifyClie|
  0010c	e28dd010	 add         sp, sp, #0x10
  00110	e49df004	 ldr         pc, [sp], #4
  00114		 |$LN32@NotifyClie|
  00114		 |$LN33@NotifyClie|
  00114	002a0504	 DCD         0x2a0504
  00118		 |$LN31@NotifyClie|
  00118		 |$LN29@NotifyClie|
	EXPORT	|pBuffer$GSCopy$| [ DATA ]
	EXPORT	|this$GSCopy$| [ DATA ]
	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?SDReadWriteRegistersDirect_I@CSDDevice@@UAAJW4SD_IO_TRANSFER_TYPE@@KEPAEK@Z| ; CSDDevice::SDReadWriteRegistersDirect_I
	IMPORT	|WaitForSingleObject|
	IMPORT	|?QueueBusRequest@CSDBusReqAsyncQueue@@QAAJPAVCSDBusRequest@@@Z| ; CSDBusReqAsyncQueue::QueueBusRequest
	IMPORT	|??0CSDBusRequest@@QAA@AAVCSDDevice@@AAU_SD_BUS_REQUEST@@PAXPAV0@@Z| ; CSDBusRequest::CSDBusRequest
	IMPORT	|??2CSDBusRequest@@SAPAXI@Z|		; CSDBusRequest::operator new
	IMPORT	|__GSHandlerCheck_SEH|
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T42230| DCD	|$LN76@SDReadWrit|
	DCD	0xc000ed05

  00000			 AREA	 |.pdata|, PDATA
|$T42232| DCD	|$LN35@SDReadWrit|
	DCD	0x40000702

  00000			 AREA	 |.xdata|, DATA
|$T42228| DCD	0x1
	DCD	|$LN39@SDReadWrit|
	DCD	|$LN40@SDReadWrit|
	DCD	|$LN35@SDReadWrit|
	DCD	|$LN36@SDReadWrit|
	DCD	0xffffffc4
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck_SEH|
  00004	00000000	 DCD         |$T42228|

  00008		 |?SDReadWriteRegistersDirect_I@CSDDevice@@UAAJW4SD_IO_TRANSFER_TYPE@@KEPAEK@Z| PROC ; CSDDevice::SDReadWriteRegistersDirect_I

; 2202 : {

  00008		 |$LN76@SDReadWrit|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d000f	 stmdb       sp!, {r0 - r3}
  00010	e92d5ff0	 stmdb       sp!, {r4 - r12, lr}
  00014	e28db028	 add         r11, sp, #0x28
  00018	e24dd08c	 sub         sp, sp, #0x8C
  0001c		 |$LN74@SDReadWrit|
  0001c	e1a04003	 mov         r4, r3
  00020	e54b40b0	 strb        r4, [r11, #-0xB0]
  00024	e5cb400c	 strb        r4, [r11, #0xC]
  00028	e1a03002	 mov         r3, r2
  0002c	e50b30a8	 str         r3, [r11, #-0xA8]
  00030	e58b3008	 str         r3, [r11, #8]
  00034	e1a08001	 mov         r8, r1
  00038	e58b8004	 str         r8, [r11, #4]
  0003c	e1a07000	 mov         r7, r0
  00040	e59fe38c	 ldr         lr, [pc, #0x38C]
  00044	e59ee000	 ldr         lr, [lr]
  00048	e50be02c	 str         lr, [r11, #-0x2C]

; 2203 :     SD_API_STATUS   status = SD_API_STATUS_UNSUCCESSFUL;

  0004c	e59be010	 ldr         lr, [r11, #0x10]
  00050	e3a0510f	 mov         r5, #0xF, 2
  00054	e1b0a00e	 movs        r10, lr
  00058	e50b7090	 str         r7, [r11, #-0x90]
  0005c	e50ba09c	 str         r10, [r11, #-0x9C]
  00060	e50b50ac	 str         r5, [r11, #-0xAC]

; 2204 :     if (pBuffer && BufferLength) {

  00064	0a000031	 beq         |$LN60@SDReadWrit|
  00068	e59b9014	 ldr         r9, [r11, #0x14]
  0006c	e3590000	 cmp         r9, #0
  00070	0a00002e	 beq         |$LN60@SDReadWrit|

; 2205 :         m_sdSlot.m_RequestLock.Lock();

  00074	e5973438	 ldr         r3, [r7, #0x438]
  00078	e28300e8	 add         r0, r3, #0xE8
  0007c	eb000000	 bl          EnterCriticalSection

; 2206 :         for (DWORD dwCount = 0; dwCount < BufferLength ; dwCount ++ ) {

  00080	e3a06000	 mov         r6, #0
  00084		 |$LN73@SDReadWrit|
  00084	e50b60a4	 str         r6, [r11, #-0xA4]
  00088	e1560009	 cmp         r6, r9
  0008c	2a000024	 bcs         |$LN6@SDReadWrit|
  00090		 |$LN39@SDReadWrit|

; 2207 :             DWORD dwArg;
; 2208 :             BOOL fArgSuccess = FALSE;
; 2209 :             __try {
; 2210 :                 dwArg = BUILD_IO_RW_DIRECT_ARG((UCHAR)ReadWrite,ReadAfterWrite,m_FuncionIndex,(Address + dwCount),ReadWrite==SD_IO_READ?0: pBuffer[dwCount]);

  00090	e3580000	 cmp         r8, #0
  00094	03a0e000	 moveq       lr, #0
  00098	17dae006	 ldrneb      lr, [r10, +r6]
  0009c	e597343c	 ldr         r3, [r7, #0x43C]
  000a0	e3e093ff	 mvn         r9, #0xFF, 6
  000a4	e2040001	 and         r0, r4, #1
  000a8	e2033007	 and         r3, r3, #7
  000ac	e1832188	 orr         r2, r3, r8, lsl #3
  000b0	e51b30a8	 ldr         r3, [r11, #-0xA8]
  000b4	e0861003	 add         r1, r6, r3
  000b8	e2293f7f	 eor         r3, r9, #0x7F, 30
  000bc	e1802082	 orr         r2, r0, r2, lsl #1
  000c0	e0033481	 and         r3, r3, r1, lsl #9
  000c4	e1833d82	 orr         r3, r3, r2, lsl #27
  000c8	e183400e	 orr         r4, r3, lr
  000cc	e50b4098	 str         r4, [r11, #-0x98]

; 2211 :                 fArgSuccess = TRUE;

  000d0	e3a02001	 mov         r2, #1
  000d4	e1a03002	 mov         r3, r2
  000d8	e50b20a0	 str         r2, [r11, #-0xA0]
  000dc		 |$LN40@SDReadWrit|

; 2212 :                     
; 2213 :             }

  000dc	e3a09000	 mov         r9, #0
  000e0	ea00000c	 b           |$LN41@SDReadWrit|
  000e4		 |$LN36@SDReadWrit|

; 2215 :                 fArgSuccess = FALSE;

  000e4	e3a09000	 mov         r9, #0
  000e8	e1a03009	 mov         r3, r9
  000ec	e50b90a0	 str         r9, [r11, #-0xA0]
  000f0	e5db200c	 ldrb        r2, [r11, #0xC]
  000f4	e54b20b0	 strb        r2, [r11, #-0xB0]
  000f8	e59b2008	 ldr         r2, [r11, #8]
  000fc	e50b20a8	 str         r2, [r11, #-0xA8]
  00100	e59b8004	 ldr         r8, [r11, #4]
  00104	e51b50ac	 ldr         r5, [r11, #-0xAC]
  00108	e51b60a4	 ldr         r6, [r11, #-0xA4]
  0010c	e51b4098	 ldr         r4, [r11, #-0x98]
  00110	e51b7090	 ldr         r7, [r11, #-0x90]
  00114	e51ba09c	 ldr         r10, [r11, #-0x9C]
  00118		 |$LN41@SDReadWrit|

; 2216 :             }
; 2217 :             if (!fArgSuccess) {

  00118	e3530000	 cmp         r3, #0
  0011c	1a000009	 bne         |$LN18@SDReadWrit|

; 2218 :                 status = SD_API_STATUS_ACCESS_VIOLATION;

  00120	e3a05117	 mov         r5, #0x17, 2
  00124		 |$LN6@SDReadWrit|

; 2288 :                     break;
; 2289 :                 }
; 2290 :             }
; 2291 :             else
; 2292 :                 break;
; 2293 :         };
; 2294 :         m_sdSlot.m_RequestLock.Unlock();

  00124	e5973438	 ldr         r3, [r7, #0x438]
  00128	e28300e8	 add         r0, r3, #0xE8
  0012c	eb000000	 bl          LeaveCriticalSection
  00130		 |$LN60@SDReadWrit|

; 2295 :         
; 2296 :     }
; 2297 :     ASSERT(SD_API_SUCCESS(status));
; 2298 :     return (status);

  00130	e51b002c	 ldr         r0, [r11, #-0x2C]
  00134	eb000000	 bl          __security_check_cookie
  00138		 |$LN24@SDReadWrit|

; 2299 : };

  00138	e1a00005	 mov         r0, r5
  0013c	e24bd028	 sub         sp, r11, #0x28
  00140	e89d6ff0	 ldmia       sp, {r4 - r11, sp, lr}
  00144	e12fff1e	 bx          lr
  00148		 |$LN18@SDReadWrit|

; 2219 :                 break;
; 2220 :             }
; 2221 :             SD_BUS_REQUEST sdRequest = {
; 2222 :                 {NULL},(SD_DEVICE_HANDLE)GetDeviceHandle().hValue,0,

  00148	e3a03000	 mov         r3, #0
  0014c	e50b308c	 str         r3, [r11, #-0x8C]
  00150	e3a03000	 mov         r3, #0
  00154	e50b3088	 str         r3, [r11, #-0x88]
  00158	e24b1094	 sub         r1, r11, #0x94
  0015c	e1a00007	 mov         r0, r7
  00160	eb000000	 bl          |?GetDeviceHandle@CSDDevice@@QAA?AT__SDBUS_DEVICE_HANDLE@@XZ|
  00164	e5903000	 ldr         r3, [r0]
  00168	e3a0e000	 mov         lr, #0

; 2223 :                 SD_COMMAND,SD_IO_RW_DIRECT,dwArg ,
; 2224 :                 {ResponseR5,{0}},

  0016c	e50b3084	 str         r3, [r11, #-0x84]
  00170	e3a02010	 mov         r2, #0x10
  00174	e3a01000	 mov         r1, #0
  00178	e24b006b	 sub         r0, r11, #0x6B
  0017c	e50be080	 str         lr, [r11, #-0x80]
  00180	e3a03002	 mov         r3, #2
  00184	e50b307c	 str         r3, [r11, #-0x7C]
  00188	e3a03034	 mov         r3, #0x34
  0018c	e54b3078	 strb        r3, [r11, #-0x78]
  00190	e50b4074	 str         r4, [r11, #-0x74]
  00194	e3a03006	 mov         r3, #6
  00198	e50b3070	 str         r3, [r11, #-0x70]
  0019c	e3a03000	 mov         r3, #0
  001a0	e54b306c	 strb        r3, [r11, #-0x6C]
  001a4	eb000000	 bl          memset
  001a8	e3a03000	 mov         r3, #0
  001ac	e54b305b	 strb        r3, [r11, #-0x5B]
  001b0	e54b305a	 strb        r3, [r11, #-0x5A]
  001b4	e54b3059	 strb        r3, [r11, #-0x59]

; 2225 :                 NULL,
; 2226 :                 SD_API_STATUS_UNSUCCESSFUL,

  001b8	e3a0210f	 mov         r2, #0xF, 2

; 2227 :                 0,0,0,

  001bc	e3a01000	 mov         r1, #0
  001c0	e3a00000	 mov         r0, #0
  001c4	e3a0e000	 mov         lr, #0

; 2228 :                 NULL,NULL,

  001c8	e3a04000	 mov         r4, #0

; 2229 :                 0
; 2230 :             };
; 2231 :             
; 2232 :             if ((m_SDCardInfo.SDIOInformation.Flags & FSTPTH_DISABLE ) == 0 ) {

  001cc	e5d73511	 ldrb        r3, [r7, #0x511]
  001d0	e50b2054	 str         r2, [r11, #-0x54]
  001d4	e50b1050	 str         r1, [r11, #-0x50]
  001d8	e50b004c	 str         r0, [r11, #-0x4C]
  001dc	e50be048	 str         lr, [r11, #-0x48]
  001e0	e50b4044	 str         r4, [r11, #-0x44]
  001e4	e3a02000	 mov         r2, #0
  001e8	e50b203c	 str         r2, [r11, #-0x3C]
  001ec	e3a02000	 mov         r2, #0
  001f0	e50b2038	 str         r2, [r11, #-0x38]
  001f4	e50b2034	 str         r2, [r11, #-0x34]
  001f8	e50b2030	 str         r2, [r11, #-0x30]
  001fc	e3130020	 tst         r3, #0x20

; 2233 :                 sdRequest.Flags |= SD_SYNCHRONOUS_REQUEST ;

  00200	01a03002	 moveq       r3, r2

; 2234 :                 sdRequest.SystemFlags |= SD_FAST_PATH_AVAILABLE;

  00204	051b2080	 ldreq       r2, [r11, #-0x80]
  00208	03833004	 orreq       r3, r3, #4
  0020c	03822102	 orreq       r2, r2, #2, 2
  00210	050b3038	 streq       r3, [r11, #-0x38]
  00214	050b2080	 streq       r2, [r11, #-0x80]

; 2235 :             }
; 2236 :             sdRequest.pCallback = SDSyncRequestCallback ;
; 2237 :             sdRequest.RequestParam = (DWORD)m_hSyncEvent;

  00218	e5972434	 ldr         r2, [r7, #0x434]
  0021c	e59f31ac	 ldr         r3, [pc, #0x1AC]

; 2238 :             ResetEvent(m_hSyncEvent);

  00220	e3a01002	 mov         r1, #2
  00224	e1a00002	 mov         r0, r2
  00228	e50b3040	 str         r3, [r11, #-0x40]
  0022c	e50b2058	 str         r2, [r11, #-0x58]
  00230	eb000000	 bl          EventModify

; 2239 :             CSDBusRequest * pNewRequest =  new CSDBusRequest(*this, sdRequest );

  00234	e3a00094	 mov         r0, #0x94
  00238	eb000000	 bl          |??2CSDBusRequest@@SAPAXI@Z|
  0023c	e3500000	 cmp         r0, #0
  00240	0a000006	 beq         |$LN28@SDReadWrit|
  00244	e3a03000	 mov         r3, #0
  00248	e24b208c	 sub         r2, r11, #0x8C
  0024c	e1a01007	 mov         r1, r7
  00250	e58d9000	 str         r9, [sp]
  00254	eb000000	 bl          |??0CSDBusRequest@@QAA@AAVCSDDevice@@AAU_SD_BUS_REQUEST@@PAXPAV0@@Z|
  00258	e1a04000	 mov         r4, r0
  0025c	ea000000	 b           |$LN70@SDReadWrit|
  00260		 |$LN28@SDReadWrit|
  00260	e3a04000	 mov         r4, #0
  00264		 |$LN70@SDReadWrit|
  00264	e50b40ac	 str         r4, [r11, #-0xAC]

; 2240 :             if (pNewRequest && pNewRequest->Init() ) {

  00268	e3540000	 cmp         r4, #0
  0026c	0a00003d	 beq         |$LN32@SDReadWrit|
  00270	e5943000	 ldr         r3, [r4]
  00274	e1a00004	 mov         r0, r4
  00278	e5933004	 ldr         r3, [r3, #4]
  0027c	e1a0e00f	 mov         lr, pc
  00280	e12fff13	 bx          r3
  00284	e3500000	 cmp         r0, #0
  00288	0a00002f	 beq         |$LN16@SDReadWrit|

; 2241 :                 pNewRequest->AddRef();

  0028c	e284007c	 add         r0, r4, #0x7C
  00290	eb000000	 bl          InterlockedIncrement

; 2242 :                 CSDBusRequest * pCur = pNewRequest; 

  00294	e1a05004	 mov         r5, r4
  00298		 |$LL15@SDReadWrit|

; 2243 :                 while (pCur) {
; 2244 :                     status = m_sdSlot.QueueBusRequest(pNewRequest);

  00298	e5973438	 ldr         r3, [r7, #0x438]
  0029c	e1a01004	 mov         r1, r4
  002a0	e2830044	 add         r0, r3, #0x44
  002a4	eb000000	 bl          |?QueueBusRequest@CSDBusReqAsyncQueue@@QAAJPAVCSDBusRequest@@@Z|
  002a8	e1b09000	 movs        r9, r0

; 2245 :                     if (!SD_API_SUCCESS(status)) {

  002ac	4a000002	 bmi         |$LN67@SDReadWrit|

; 2246 :                         DEBUGMSG(SDCARD_ZONE_ERROR, (_T("SDReadWriteRegistersDirect_I: queue request failed(0x%x),TransferClass(%x), CommandCode(%x),CommandArgument(%x)\r\n"),
; 2247 :                             status, pCur->TransferClass, pCur->CommandCode,pCur->CommandArgument));
; 2248 :                         break;
; 2249 :                     }
; 2250 :                     else {
; 2251 :                         pCur = pCur->GetChildListNext();

  002b0	e5953070	 ldr         r3, [r5, #0x70]
  002b4	e1b05003	 movs        r5, r3
  002b8	1afffff6	 bne         |$LL15@SDReadWrit|
  002bc		 |$LN67@SDReadWrit|

; 2252 :                     }
; 2253 :                 }
; 2254 :                 while (pCur) { // This failed. So we complete the rest of them.

  002bc	e3550000	 cmp         r5, #0
  002c0	0a00000b	 beq         |$LN10@SDReadWrit|
  002c4	e3a04001	 mov         r4, #1
  002c8		 |$LL11@SDReadWrit|

; 2255 :                     pCur->CompleteBusRequest(status );

  002c8	e595306c	 ldr         r3, [r5, #0x6C]
  002cc	e585903c	 str         r9, [r5, #0x3C]
  002d0	e5854080	 str         r4, [r5, #0x80]
  002d4	e3530000	 cmp         r3, #0
  002d8	11a00003	 movne       r0, r3
  002dc	01a00005	 moveq       r0, r5
  002e0	eb000000	 bl          |?CheckForCompletion@CSDBusRequest@@IAAHXZ|

; 2256 :                     pCur = pCur->GetChildListNext();

  002e4	e5953070	 ldr         r3, [r5, #0x70]
  002e8	e1b05003	 movs        r5, r3
  002ec	1afffff5	 bne         |$LL11@SDReadWrit|

; 2239 :             CSDBusRequest * pNewRequest =  new CSDBusRequest(*this, sdRequest );

  002f0	e51b40ac	 ldr         r4, [r11, #-0xAC]
  002f4		 |$LN10@SDReadWrit|

; 2257 :                 }
; 2258 :                 // wait for the I/O to complete
; 2259 :                 if (!pNewRequest->IsComplete()) {

  002f4	e1a00004	 mov         r0, r4
  002f8	eb000000	 bl          |?IsComplete@CSDBusRequest@@QAAHXZ|
  002fc	e3500000	 cmp         r0, #0

; 2260 :                     DWORD waitResult = WaitForSingleObject(m_hSyncEvent, INFINITE);

  00300	05970434	 ldreq       r0, [r7, #0x434]
  00304	03e01000	 mvneq       r1, #0
  00308	0b000000	 bleq        WaitForSingleObject

; 2261 :                     ASSERT(WAIT_OBJECT_0 == waitResult);
; 2262 :                 }
; 2263 :                 ASSERT(pNewRequest->IsComplete());
; 2264 :                 sdRequest = *(SD_BUS_REQUEST *)pNewRequest;

  0030c	e24b008c	 sub         r0, r11, #0x8C
  00310	e2841004	 add         r1, r4, #4
  00314	e3a02060	 mov         r2, #0x60
  00318	eb000000	 bl          memcpy

; 2265 :                 status = pNewRequest->GetFirstFailedStatus();

  0031c	e594303c	 ldr         r3, [r4, #0x3C]
  00320	e1b05003	 movs        r5, r3
  00324	4a000005	 bmi         |$LN57@SDReadWrit|
  00328	e5943070	 ldr         r3, [r4, #0x70]
  0032c	e3530000	 cmp         r3, #0
  00330	0a000002	 beq         |$LN57@SDReadWrit|
  00334	e1a00003	 mov         r0, r3
  00338	eb000000	 bl          |?GetFirstFailedStatus@CSDBusRequest@@QAAJXZ|
  0033c	e1a05000	 mov         r5, r0
  00340		 |$LN57@SDReadWrit|

; 2266 :                 pNewRequest->DeRef();

  00340	e1a00004	 mov         r0, r4
  00344	eb000000	 bl          |?DeRef@CSDBusRequest@@QAAKXZ|
  00348	ea000006	 b           |$LN32@SDReadWrit|
  0034c		 |$LN16@SDReadWrit|

; 2267 :             }
; 2268 :             else if (pNewRequest){

  0034c	e3540000	 cmp         r4, #0

; 2269 :                 delete pNewRequest;

  00350	15943000	 ldrne       r3, [r4]
  00354	13a01001	 movne       r1, #1
  00358	11a00004	 movne       r0, r4
  0035c	15933000	 ldrne       r3, [r3]
  00360	11a0e00f	 movne       lr, pc
  00364	112fff13	 bxne        r3
  00368		 |$LN32@SDReadWrit|

; 2270 :             }
; 2271 :             
; 2272 :             if (SD_API_SUCCESS(status)) {

  00368	e3550000	 cmp         r5, #0
  0036c	4affff6c	 bmi         |$LN6@SDReadWrit|

; 2273 :                 UCHAR responseStatus = SD_GET_IO_RW_DIRECT_RESPONSE_FLAGS(&sdRequest.CommandResponse);
; 2274 :                 // mask out the previous CRC error, the command is retried on CRC errors
; 2275 :                 // so this bit will reflect the previous command instead
; 2276 :                 responseStatus &= ~SD_IO_COM_CRC_ERROR;
; 2277 : 
; 2278 :                 if (!SD_IO_R5_RESPONSE_ERROR(responseStatus)) {

  00370	e55b306a	 ldrb        r3, [r11, #-0x6A]
  00374	e313004b	 tst         r3, #0x4B
  00378	1a00000b	 bne         |$LN5@SDReadWrit|

; 2279 :                     status = SD_API_STATUS_SUCCESS;

  0037c	e3a05000	 mov         r5, #0
  00380	e50b50ac	 str         r5, [r11, #-0xAC]

; 2280 :                     // check to see if read after write or just a read
; 2281 :                     if (ReadAfterWrite || (SD_IO_READ == ReadWrite)) {

  00384	e55b40b0	 ldrb        r4, [r11, #-0xB0]
  00388	e3540000	 cmp         r4, #0
  0038c	1a000001	 bne         |$LN3@SDReadWrit|
  00390	e3580000	 cmp         r8, #0
  00394	1a000001	 bne         |$LN21@SDReadWrit|
  00398		 |$LN3@SDReadWrit|

; 2282 :                         pBuffer[dwCount] = SD_GET_IO_RW_DIRECT_DATA(&sdRequest.CommandResponse);

  00398	e55b306b	 ldrb        r3, [r11, #-0x6B]
  0039c	e7ca3006	 strb        r3, [r10, +r6]
  003a0		 |$LN21@SDReadWrit|
  003a0	e2866001	 add         r6, r6, #1
  003a4	e59b9014	 ldr         r9, [r11, #0x14]
  003a8	eaffff35	 b           |$LN73@SDReadWrit|
  003ac		 |$LN5@SDReadWrit|

; 2283 :                     }
; 2284 : 
; 2285 :                 } else {
; 2286 :                     DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDCard: SDReadWriteRegistersDirect- R5 response returned error code : 0x%02X \n"),responseStatus));
; 2287 :                     status = SD_API_STATUS_DEVICE_RESPONSE_ERROR;

  003ac	e3a0515b	 mov         r5, #0x5B, 2
  003b0	eaffff5b	 b           |$LN6@SDReadWrit|
  003b4		 |$LN69@SDReadWrit|

; 2295 :         
; 2296 :     }
; 2297 :     ASSERT(SD_API_SUCCESS(status));
; 2298 :     return (status);

  003b4	e51b5094	 ldr         r5, [r11, #-0x94]
  003b8	eaffff5e	 b           |$LN24@SDReadWrit|

			 ENDP  ; |?SDReadWriteRegistersDirect_I@CSDDevice@@UAAJW4SD_IO_TRANSFER_TYPE@@KEPAEK@Z|, CSDDevice::SDReadWriteRegistersDirect_I

  003bc		 |$LN35@SDReadWrit|
  003bc		 |$LN75@SDReadWrit|

; 2214 :             __except(SDProcessException(GetExceptionInformation())) {

  003bc	e52de004	 str         lr, [sp, #-4]!
  003c0	e24dd004	 sub         sp, sp, #4
  003c4		 |$LN38@SDReadWrit|
  003c4		 |$LN78@SDReadWrit|
  003c4	eb000000	 bl          SDProcessException
  003c8		 |$LN37@SDReadWrit|
  003c8	e28dd004	 add         sp, sp, #4
  003cc	e49df004	 ldr         pc, [sp], #4
  003d0		 |$LN80@SDReadWrit|
  003d0		 |$LN81@SDReadWrit|
  003d0	00000000	 DCD         |?SDSyncRequestCallback@CSDDevice@@KAXPAXPAU_SD_BUS_REQUEST@@0K@Z|
  003d4		 |$LN82@SDReadWrit|
  003d4	00000000	 DCD         |__security_cookie|
  003d8		 |$LN79@SDReadWrit|
  003d8		 |$LN77@SDReadWrit|
	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?TestCardBusWidth@CSDDevice@@IAAJPAU_SD_CARD_INTERFACE@@PAE@Z| ; CSDDevice::TestCardBusWidth
	IMPORT	|memcmp|
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdbus.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T42299| DCD	|$LN42@TestCardBu|
	DCD	0xc0007f02

  00000			 AREA	 |.xdata|, DATA
|$T42295| DCD	0xffffffd8
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T42295|

  00008		 |?TestCardBusWidth@CSDDevice@@IAAJPAU_SD_CARD_INTERFACE@@PAE@Z| PROC ; CSDDevice::TestCardBusWidth

; 2304 : {

  00008		 |$LN42@TestCardBu|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24ddf8f	 sub         sp, sp, #0x8F, 30
  00010		 |$M42296|
  00010	e1a09002	 mov         r9, r2
  00014	e1a08001	 mov         r8, r1
  00018	e1a07000	 mov         r7, r0
  0001c	e59f31dc	 ldr         r3, [pc, #0x1DC]
  00020	e5933000	 ldr         r3, [r3]
  00024	e58d3238	 str         r3, [sp, #0x238]

; 2305 : 	UCHAR						readBuff[512]; // temporary buffer
; 2306 : 	SD_COMMAND_RESPONSE         response;  // response
; 2307 : 	SD_API_STATUS				status = SD_API_STATUS_UNSUCCESSFUL;
; 2308 : 
; 2309 : 	memset (&readBuff, 0, sizeof(readBuff));

  00028	e3a02c02	 mov         r2, #2, 24
  0002c	e3a01000	 mov         r1, #0
  00030	e28d0038	 add         r0, sp, #0x38
  00034	eb000000	 bl          memset

; 2310 : 
; 2311 : 	switch(psdCardInterface->InterfaceMode)

  00038	e5983000	 ldr         r3, [r8]
  0003c	e3a057ed	 mov         r5, #0xED, 14
  00040	e3a0600c	 mov         r6, #0xC
  00044	e3530000	 cmp         r3, #0
  00048	0a000017	 beq         |$LN11@TestCardBu|
  0004c	e3530001	 cmp         r3, #1
  00050	0a00000c	 beq         |$LN14@TestCardBu|
  00054	e3530002	 cmp         r3, #2
  00058	0a000001	 beq         |$LN17@TestCardBu|
  0005c		 |$LN2@TestCardBu|

; 2330 : 			DEBUGMSG(SDCARD_ZONE_ERROR, (_T("TestCardBusWidth: error setting card bus width to 1 bit\r\n")));
; 2331 : 			goto cleanup;
; 2332 : 		}
; 2333 : 		break;
; 2334 : 	default:
; 2335 : 		DEBUGMSG(SDCARD_ZONE_ERROR, (_T("TestCardBusWidth: Interface Mode not supported\r\n")));
; 2336 : 		status = SD_API_STATUS_UNSUCCESSFUL;

  0005c	e3a0510f	 mov         r5, #0xF, 2

; 2365 : 		status = SD_API_STATUS_UNSUCCESSFUL;
; 2366 : 
; 2367 : cleanup:

  00060	ea00004a	 b           |$cleanup$39714|
  00064		 |$LN17@TestCardBu|
  00064	e3a037ee	 mov         r3, #0xEE, 14
  00068	e2432cfe	 sub         r2, r3, #0xFE, 24
  0006c	e28de020	 add         lr, sp, #0x20
  00070	e3a03002	 mov         r3, #2
  00074	e3a01006	 mov         r1, #6
  00078	e1a00007	 mov         r0, r7
  0007c	e58de000	 str         lr, [sp]
  00080	eb000000	 bl          |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|
  00084	ea00000f	 b           |$LN39@TestCardBu|
  00088		 |$LN14@TestCardBu|

; 2312 : 	{
; 2313 : 	case SD_INTERFACE_SD_MMC_8BIT:
; 2314 : 		status = SendSDCommand( SD_CMD_SWITCH_FUNCTION,EMMC_SWITCH2_8BITSBUS_ARGUMENT, ResponseR1b, &response);
; 2315 : 		if (!SD_API_SUCCESS(status)) {
; 2316 : 			DEBUGMSG(SDCARD_ZONE_ERROR, (_T("TestCardBusWidth: error setting card bus width to 8 bits\r\n")));
; 2317 : 			goto cleanup;
; 2318 : 		}
; 2319 : 		break;

  00088	e3a037ee	 mov         r3, #0xEE, 14

; 2320 : 	case SD_INTERFACE_SD_4BIT:
; 2321 : 		status = SendSDCommand( SD_CMD_SWITCH_FUNCTION,EMMC_SWITCH2_4BITSBUS_ARGUMENT, ResponseR1b, &response);

  0008c	e2432cff	 sub         r2, r3, #0xFF, 24
  00090	e28de020	 add         lr, sp, #0x20
  00094	e3a03002	 mov         r3, #2
  00098	e3a01006	 mov         r1, #6
  0009c	e1a00007	 mov         r0, r7
  000a0	e58de000	 str         lr, [sp]
  000a4	eb000000	 bl          |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|

; 2322 : 		if (!SD_API_SUCCESS(status)) {
; 2323 : 			DEBUGMSG(SDCARD_ZONE_ERROR, (_T("TestCardBusWidth: error setting card bus width to 4 bits\r\n")));
; 2324 : 			goto cleanup;
; 2325 : 		}
; 2326 : 		break;

  000a8	ea000006	 b           |$LN39@TestCardBu|
  000ac		 |$LN11@TestCardBu|

; 2327 : 	case SD_INTERFACE_SD_MMC_1BIT:
; 2328 : 		status = SendSDCommand( SD_CMD_SWITCH_FUNCTION,EMMC_SWITCH2_1BITSBUS_ARGUMENT, ResponseR1b, &response);

  000ac	e28d3020	 add         r3, sp, #0x20
  000b0	e58d3000	 str         r3, [sp]
  000b4	e3a03002	 mov         r3, #2
  000b8	e3852803	 orr         r2, r5, #3, 16
  000bc	e3a01006	 mov         r1, #6
  000c0	e1a00007	 mov         r0, r7
  000c4	eb000000	 bl          |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|
  000c8		 |$LN39@TestCardBu|
  000c8	e1b05000	 movs        r5, r0

; 2329 : 		if (!SD_API_SUCCESS(status)) {

  000cc	4a00002f	 bmi         |$cleanup$39714|

; 2337 : 		goto cleanup;
; 2338 : 		break;
; 2339 : 	}
; 2340 : 
; 2341 : 
; 2342 : 	status = m_sdSlot.GetHost().SlotOptionHandler(m_sdSlot.GetSlotIndex(), SDHCDSetSlotInterface, psdCardInterface, sizeof(*psdCardInterface));

  000d0	e5973438	 ldr         r3, [r7, #0x438]
  000d4	e58d6000	 str         r6, [sp]
  000d8	e593207c	 ldr         r2, [r3, #0x7C]
  000dc	e5931080	 ldr         r1, [r3, #0x80]
  000e0	e1a03008	 mov         r3, r8
  000e4	e3520000	 cmp         r2, #0
  000e8	e5924044	 ldr         r4, [r2, #0x44]
  000ec	12820008	 addne       r0, r2, #8
  000f0	03a00000	 moveq       r0, #0
  000f4	e3a02001	 mov         r2, #1
  000f8	e1a0e00f	 mov         lr, pc
  000fc	e12fff14	 bx          r4
  00100	e1b05000	 movs        r5, r0

; 2343 :     if (!SD_API_SUCCESS(status)) {

  00104	4a000021	 bmi         |$cleanup$39714|

; 2344 :         DEBUGMSG(SDCARD_ZONE_ERROR, (_T("TestCardBusWidth: error updating card interface\r\n")));
; 2345 : 		goto cleanup;
; 2346 : 	}
; 2347 : 
; 2348 : 	status = SDSynchronousBusRequest_I( SD_CMD_READ_SINGLE_BLOCK,
; 2349 : 	  0,
; 2350 : 	  SD_READ, 
; 2351 : 	  ResponseR1,
; 2352 : 	  &response,
; 2353 : 	  1,
; 2354 : 	  512, 
; 2355 : 	  &readBuff[0],
; 2356 : 	  SD_SLOTRESET_REQUEST);

  00108	e5973000	 ldr         r3, [r7]
  0010c	e28d4038	 add         r4, sp, #0x38
  00110	e3a0b000	 mov         r11, #0
  00114	e5936014	 ldr         r6, [r3, #0x14]
  00118	e58db01c	 str         r11, [sp, #0x1C]
  0011c	e58db018	 str         r11, [sp, #0x18]
  00120	e58d4010	 str         r4, [sp, #0x10]
  00124	e3a0b008	 mov         r11, #8
  00128	e3a04001	 mov         r4, #1
  0012c	e3a0ac02	 mov         r10, #2, 24
  00130	e28d5020	 add         r5, sp, #0x20
  00134	e3a03000	 mov         r3, #0
  00138	e58db014	 str         r11, [sp, #0x14]
  0013c	e58d4008	 str         r4, [sp, #8]
  00140	e58d4000	 str         r4, [sp]
  00144	e3a02000	 mov         r2, #0
  00148	e3a01011	 mov         r1, #0x11
  0014c	e1a00007	 mov         r0, r7
  00150	e58da00c	 str         r10, [sp, #0xC]
  00154	e58d5004	 str         r5, [sp, #4]
  00158	e1a0e00f	 mov         lr, pc
  0015c	e12fff16	 bx          r6
  00160	e1b05000	 movs        r5, r0

; 2357 :     if (!SD_API_SUCCESS(status)) {

  00164	4a000008	 bmi         |$LN38@TestCardBu|

; 2358 :         DEBUGMSG(SDCARD_ZONE_ERROR, (_T("TestCardBusWidth: error reading first block\r\n")));
; 2359 : 		goto cleanup;
; 2360 : 	}
; 2361 : 
; 2362 : 	if(memcmp(backupBuff,&readBuff,sizeof(backupBuff)) == 0)

  00168	e3a02004	 mov         r2, #4
  0016c	e28d1038	 add         r1, sp, #0x38
  00170	e1a00009	 mov         r0, r9
  00174	eb000000	 bl          memcmp
  00178	e3500000	 cmp         r0, #0

; 2364 : 	else

  0017c	e3a0600c	 mov         r6, #0xC
  00180	1affffb5	 bne         |$LN2@TestCardBu|

; 2363 : 		status = SD_API_STATUS_SUCCESS;

  00184	e3a05000	 mov         r5, #0

; 2364 : 	else

  00188	ea000000	 b           |$cleanup$39714|
  0018c		 |$LN38@TestCardBu|
  0018c	e3a0600c	 mov         r6, #0xC
  00190		 |$cleanup$39714|

; 2368 : 	SendSDCommand( SD_CMD_SWITCH_FUNCTION,EMMC_SWITCH2_1BITSBUS_ARGUMENT, ResponseR1b, &response);

  00190	e28d3020	 add         r3, sp, #0x20
  00194	e3a027ed	 mov         r2, #0xED, 14
  00198	e58d3000	 str         r3, [sp]
  0019c	e3a03002	 mov         r3, #2
  001a0	e3822803	 orr         r2, r2, #3, 16
  001a4	e3a01006	 mov         r1, #6
  001a8	e1a00007	 mov         r0, r7
  001ac	eb000000	 bl          |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|

; 2369 : 	psdCardInterface->InterfaceMode = SD_INTERFACE_SD_MMC_1BIT;

  001b0	e3a03000	 mov         r3, #0
  001b4	e5883000	 str         r3, [r8]

; 2370 : 	m_sdSlot.GetHost().SlotOptionHandler(m_sdSlot.GetSlotIndex(), SDHCDSetSlotInterface, psdCardInterface, sizeof(*psdCardInterface));	

  001b8	e5973438	 ldr         r3, [r7, #0x438]
  001bc	e58d6000	 str         r6, [sp]
  001c0	e593207c	 ldr         r2, [r3, #0x7C]
  001c4	e5931080	 ldr         r1, [r3, #0x80]
  001c8	e1a03008	 mov         r3, r8
  001cc	e3520000	 cmp         r2, #0
  001d0	e5924044	 ldr         r4, [r2, #0x44]
  001d4	12820008	 addne       r0, r2, #8
  001d8	03a00000	 moveq       r0, #0
  001dc	e3a02001	 mov         r2, #1
  001e0	e1a0e00f	 mov         lr, pc
  001e4	e12fff14	 bx          r4

; 2371 : 
; 2372 : 	return (status);

  001e8	e59d0238	 ldr         r0, [sp, #0x238]
  001ec	eb000000	 bl          __security_check_cookie

; 2373 : }

  001f0	e1a00005	 mov         r0, r5
  001f4	e28ddf8f	 add         sp, sp, #0x8F, 30
  001f8	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001fc	e12fff1e	 bx          lr
  00200		 |$LN43@TestCardBu|
  00200		 |$LN44@TestCardBu|
  00200	00000000	 DCD         |__security_cookie|
  00204		 |$M42297|

			 ENDP  ; |?TestCardBusWidth@CSDDevice@@IAAJPAU_SD_CARD_INTERFACE@@PAE@Z|, CSDDevice::TestCardBusWidth

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?GetCardBusWidthCapability@CSDDevice@@IAAJPAK@Z| ; CSDDevice::GetCardBusWidthCapability
	EXPORT	|??_C@_1IE@DBGDJCBF@?$AAG?$AAe?$AAt?$AAC?$AAa?$AAr?$AAd?$AAB?$AAu?$AAs?$AAW?$AAi?$AAd?$AAt?$AAh?$AAC?$AAa?$AAp?$AAa?$AAb?$AAi?$AAl?$AAi?$AAt?$AAy?$AA?3?$AA?5?$AAc?$AAo?$AAu?$AAl?$AAd@| [ DATA ] ; `string'
	IMPORT	|NKDbgPrintfW|

  00000			 AREA	 |.pdata|, PDATA
|$T42328| DCD	|$LN16@GetCardBus|
	DCD	0xc0004802

  00000			 AREA	 |.xdata|, DATA
|$T42324| DCD	0xffffffd8

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1IE@DBGDJCBF@?$AAG?$AAe?$AAt?$AAC?$AAa?$AAr?$AAd?$AAB?$AAu?$AAs?$AAW?$AAi?$AAd?$AAt?$AAh?$AAC?$AAa?$AAp?$AAa?$AAb?$AAi?$AAl?$AAi?$AAt?$AAy?$AA?3?$AA?5?$AAc?$AAo?$AAu?$AAl?$AAd@| DCB "G"
	DCB	0x0, "e", 0x0, "t", 0x0, "C", 0x0, "a", 0x0, "r", 0x0, "d"
	DCB	0x0, "B", 0x0, "u", 0x0, "s", 0x0, "W", 0x0, "i", 0x0, "d"
	DCB	0x0, "t", 0x0, "h", 0x0, "C", 0x0, "a", 0x0, "p", 0x0, "a"
	DCB	0x0, "b", 0x0, "i", 0x0, "l", 0x0, "i", 0x0, "t", 0x0, "y"
	DCB	0x0, ":", 0x0, " ", 0x0, "c", 0x0, "o", 0x0, "u", 0x0, "l"
	DCB	0x0, "d", 0x0, " ", 0x0, "n", 0x0, "o", 0x0, "t", 0x0, " "
	DCB	0x0, "r", 0x0, "e", 0x0, "a", 0x0, "d", 0x0, " ", 0x0, "f"
	DCB	0x0, "i", 0x0, "r", 0x0, "s", 0x0, "t", 0x0, " ", 0x0, "b"
	DCB	0x0, "l", 0x0, "o", 0x0, "c", 0x0, "k", 0x0, " ", 0x0, "f"
	DCB	0x0, "r", 0x0, "o", 0x0, "m", 0x0, " ", 0x0, "c", 0x0, "a"
	DCB	0x0, "r", 0x0, "d", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T42324|

  00008		 |?GetCardBusWidthCapability@CSDDevice@@IAAJPAK@Z| PROC ; CSDDevice::GetCardBusWidthCapability

; 2376 : {

  00008		 |$LN16@GetCardBus|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24ddf92	 sub         sp, sp, #0x92, 30
  00010		 |$M42325|
  00010	e1a08001	 mov         r8, r1
  00014	e1a09000	 mov         r9, r0
  00018	e59f3104	 ldr         r3, [pc, #0x104]
  0001c	e5933000	 ldr         r3, [r3]
  00020	e58d3244	 str         r3, [sp, #0x244]

; 2377 : 	SD_COMMAND_RESPONSE         response;  // response
; 2378 : 	UCHAR                       backupBuff[512];
; 2379 : 	SD_API_STATUS				status = SD_API_STATUS_UNSUCCESSFUL;
; 2380 : 	DWORD						dwCardInterfaceMode;
; 2381 : 	int i;
; 2382 : 
; 2383 : 	
; 2384 : 
; 2385 : 	dwCardInterfaceMode = SD_INTERFACE_SD_MMC_1BIT;
; 2386 : 
; 2387 :     SD_CARD_INTERFACE sdCardInterface;
; 2388 :     memset (&sdCardInterface, 0, sizeof(sdCardInterface));
; 2389 : 	sdCardInterface.ClockRate = m_CardInterfaceEx.ClockRate;
; 2390 : 	sdCardInterface.WriteProtected = m_CardInterfaceEx.InterfaceModeEx.bit.sdWriteProtected;

  00024	e5993540	 ldr         r3, [r9, #0x540]
  00028	e599e544	 ldr         lr, [r9, #0x544]
  0002c	e3a02000	 mov         r2, #0
  00030	e1a03083	 mov         r3, r3, lsl #1
  00034	e1a03fa3	 mov         r3, r3, lsr #31
  00038	e58d2020	 str         r2, [sp, #0x20]
  0003c	e58d2024	 str         r2, [sp, #0x24]

; 2391 : 	sdCardInterface.InterfaceMode = SD_INTERFACE_SD_MMC_1BIT;

  00040	e3a04000	 mov         r4, #0
  00044	e58d2028	 str         r2, [sp, #0x28]

; 2392 : 
; 2393 : 	memset (&backupBuff, 0, sizeof(backupBuff));

  00048	e3a02c02	 mov         r2, #2, 24
  0004c	e3a01000	 mov         r1, #0
  00050	e28d0044	 add         r0, sp, #0x44
  00054	e58d3028	 str         r3, [sp, #0x28]
  00058	e3a07000	 mov         r7, #0
  0005c	e58de024	 str         lr, [sp, #0x24]
  00060	e58d4020	 str         r4, [sp, #0x20]
  00064	eb000000	 bl          memset

; 2394 : 
; 2395 : 	// first read out first block of card to back it up
; 2396 :     status = SDSynchronousBusRequest_I( SD_CMD_READ_SINGLE_BLOCK,
; 2397 :     0,
; 2398 :     SD_READ, 
; 2399 :     ResponseR1,
; 2400 :     &response,
; 2401 :     1,
; 2402 :     512, 
; 2403 :     &backupBuff[0],
; 2404 :     SD_SLOTRESET_REQUEST);

  00068	e5993000	 ldr         r3, [r9]
  0006c	e28d4044	 add         r4, sp, #0x44
  00070	e3a0a000	 mov         r10, #0
  00074	e5936014	 ldr         r6, [r3, #0x14]
  00078	e58da01c	 str         r10, [sp, #0x1C]
  0007c	e58da018	 str         r10, [sp, #0x18]
  00080	e58d4010	 str         r4, [sp, #0x10]
  00084	e3a0a008	 mov         r10, #8
  00088	e3a04001	 mov         r4, #1
  0008c	e3a0bc02	 mov         r11, #2, 24
  00090	e28d502c	 add         r5, sp, #0x2C
  00094	e3a03000	 mov         r3, #0
  00098	e58da014	 str         r10, [sp, #0x14]
  0009c	e58d4008	 str         r4, [sp, #8]
  000a0	e58d4000	 str         r4, [sp]
  000a4	e3a02000	 mov         r2, #0
  000a8	e3a01011	 mov         r1, #0x11
  000ac	e1a00009	 mov         r0, r9
  000b0	e58db00c	 str         r11, [sp, #0xC]
  000b4	e58d5004	 str         r5, [sp, #4]
  000b8	e1a0e00f	 mov         lr, pc
  000bc	e12fff16	 bx          r6
  000c0	e1b05000	 movs        r5, r0

; 2405 : 
; 2406 :     if (!SD_API_SUCCESS(status)) {

  000c4	5a000002	 bpl         |$LN6@GetCardBus|

; 2407 :         RETAILMSG(1, (_T("GetCardBusWidthCapability: could not read first block from card\r\n")));

  000c8	e59f0050	 ldr         r0, [pc, #0x50]
  000cc	eb000000	 bl          NKDbgPrintfW

; 2408 : 		return status;

  000d0	ea00000c	 b           |$LN13@GetCardBus|
  000d4		 |$LN6@GetCardBus|

; 2409 : 	}
; 2410 : 
; 2411 : 	for(i = (int)SD_INTERFACE_SD_MMC_8BIT; i >= (int)SD_INTERFACE_SD_MMC_1BIT; i--)

  000d4	e3a04002	 mov         r4, #2
  000d8		 |$LL5@GetCardBus|

; 2412 : 	{
; 2413 : 		sdCardInterface.InterfaceMode = (SD_INTERFACE_MODE)i;
; 2414 : 		status = TestCardBusWidth(&sdCardInterface, backupBuff);

  000d8	e28d2044	 add         r2, sp, #0x44
  000dc	e28d1020	 add         r1, sp, #0x20
  000e0	e1a00009	 mov         r0, r9
  000e4	e58d4020	 str         r4, [sp, #0x20]
  000e8	eb000000	 bl          |?TestCardBusWidth@CSDDevice@@IAAJPAU_SD_CARD_INTERFACE@@PAE@Z|
  000ec	e1b05000	 movs        r5, r0

; 2415 : 		if (!SD_API_SUCCESS(status)) {

  000f0	5a000002	 bpl         |$LN2@GetCardBus|

; 2409 : 	}
; 2410 : 
; 2411 : 	for(i = (int)SD_INTERFACE_SD_MMC_8BIT; i >= (int)SD_INTERFACE_SD_MMC_1BIT; i--)

  000f4	e2544001	 subs        r4, r4, #1
  000f8	5afffff6	 bpl         |$LL5@GetCardBus|
  000fc	ea000000	 b           |$LN3@GetCardBus|
  00100		 |$LN2@GetCardBus|

; 2416 : 			DEBUGMSG(SDBUS_ZONE_DEVICE, (_T("GetCardBusWidthCapability: MMC card does not support requested bus width\r\n"),i));
; 2417 : 		}
; 2418 : 		else
; 2419 : 		{
; 2420 : 			dwCardInterfaceMode = (SD_INTERFACE_MODE)i;

  00100	e1a07004	 mov         r7, r4
  00104		 |$LN3@GetCardBus|

; 2421 : 			break;
; 2422 : 		}
; 2423 : 	}
; 2424 : 
; 2425 : 	*pInterfaceMode = dwCardInterfaceMode;

  00104	e5887000	 str         r7, [r8]
  00108		 |$LN13@GetCardBus|

; 2426 : 	return status;

  00108	e59d0244	 ldr         r0, [sp, #0x244]
  0010c	eb000000	 bl          __security_check_cookie

; 2427 : }

  00110	e1a00005	 mov         r0, r5
  00114	e28ddf92	 add         sp, sp, #0x92, 30
  00118	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0011c	e12fff1e	 bx          lr
  00120		 |$LN17@GetCardBus|
  00120		 |$LN18@GetCardBus|
  00120	00000000	 DCD         |??_C@_1IE@DBGDJCBF@?$AAG?$AAe?$AAt?$AAC?$AAa?$AAr?$AAd?$AAB?$AAu?$AAs?$AAW?$AAi?$AAd?$AAt?$AAh?$AAC?$AAa?$AAp?$AAa?$AAb?$AAi?$AAl?$AAi?$AAt?$AAy?$AA?3?$AA?5?$AAc?$AAo?$AAu?$AAl?$AAd@|
  00124		 |$LN19@GetCardBus|
  00124	00000000	 DCD         |__security_cookie|
  00128		 |$M42326|

			 ENDP  ; |?GetCardBusWidthCapability@CSDDevice@@IAAJPAK@Z|, CSDDevice::GetCardBusWidthCapability

	EXPORT	|this$GSCopy$| [ DATA ]
	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?SDSynchronousBusRequest_I@CSDDevice@@UAAJEKW4SD_TRANSFER_CLASS@@W4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@KKPAEKKPAU__PHYS_BUFF_LIST@@@Z| ; CSDDevice::SDSynchronousBusRequest_I
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T42426| DCD	|$LN60@SDSynchron|
	DCD	0xc000b604

  00000			 AREA	 |.pdata|, PDATA
|$T42428| DCD	|$LN26@SDSynchron|
	DCD	0x40000702

  00000			 AREA	 |.xdata|, DATA
|$T42424| DCD	0x1
	DCD	|$LN30@SDSynchron|
	DCD	|$LN31@SDSynchron|
	DCD	|$LN26@SDSynchron|
	DCD	|$LN27@SDSynchron|
	DCD	0xffffffd4
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck_SEH|
  00004	00000000	 DCD         |$T42424|

  00008		 |?SDSynchronousBusRequest_I@CSDDevice@@UAAJEKW4SD_TRANSFER_CLASS@@W4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@KKPAEKKPAU__PHYS_BUFF_LIST@@@Z| PROC ; CSDDevice::SDSynchronousBusRequest_I

; 2432 : {

  00008		 |$LN60@SDSynchron|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d5ff0	 stmdb       sp!, {r4 - r12, lr}
  00010	e28db028	 add         r11, sp, #0x28
  00014	e24dd074	 sub         sp, sp, #0x74
  00018		 |$LN58@SDSynchron|
  00018	e1a04003	 mov         r4, r3
  0001c	e1a05002	 mov         r5, r2
  00020	e1a08001	 mov         r8, r1
  00024	e1a0a000	 mov         r10, r0
  00028	e59fe2c8	 ldr         lr, [pc, #0x2C8]
  0002c	e59ee000	 ldr         lr, [lr]
  00030	e50be02c	 str         lr, [r11, #-0x2C]

; 2433 :     SD_API_STATUS   status = SD_API_STATUS_UNSUCCESSFUL;

  00034	e50ba098	 str         r10, [r11, #-0x98]
  00038	e59b3004	 ldr         r3, [r11, #4]
  0003c	e50b3090	 str         r3, [r11, #-0x90]

; 2434 :     
; 2435 :     m_sdSlot.m_RequestLock.Lock();

  00040	e59ae438	 ldr         lr, [r10, #0x438]
  00044	e59b6010	 ldr         r6, [r11, #0x10]
  00048	e59b701c	 ldr         r7, [r11, #0x1C]
  0004c	e28e00e8	 add         r0, lr, #0xE8
  00050	e3a0910f	 mov         r9, #0xF, 2
  00054	eb000000	 bl          EnterCriticalSection

; 2436 :     
; 2437 :     SD_BUS_REQUEST sdRequest = {
; 2438 :         {NULL},GetDeviceHandle().hValue,0,

  00058	e3a03000	 mov         r3, #0
  0005c	e50b308c	 str         r3, [r11, #-0x8C]
  00060	e3a03000	 mov         r3, #0
  00064	e50b3088	 str         r3, [r11, #-0x88]
  00068	e24b1094	 sub         r1, r11, #0x94
  0006c	e1a0000a	 mov         r0, r10
  00070	eb000000	 bl          |?GetDeviceHandle@CSDDevice@@QAA?AT__SDBUS_DEVICE_HANDLE@@XZ|
  00074	e5903000	 ldr         r3, [r0]

; 2439 :         TransferClass,Command, Argument,
; 2440 :         {ResponseType,{0}},

  00078	e59be000	 ldr         lr, [r11]
  0007c	e50b3084	 str         r3, [r11, #-0x84]
  00080	e3a02010	 mov         r2, #0x10
  00084	e3a01000	 mov         r1, #0
  00088	e24b006b	 sub         r0, r11, #0x6B
  0008c	e3a03000	 mov         r3, #0
  00090	e50b3080	 str         r3, [r11, #-0x80]
  00094	e50b407c	 str         r4, [r11, #-0x7C]
  00098	e54b8078	 strb        r8, [r11, #-0x78]
  0009c	e50b5074	 str         r5, [r11, #-0x74]
  000a0	e50be070	 str         lr, [r11, #-0x70]
  000a4	e3a03000	 mov         r3, #0
  000a8	e54b306c	 strb        r3, [r11, #-0x6C]
  000ac	eb000000	 bl          memset
  000b0	e3a0e000	 mov         lr, #0

; 2441 :         NULL,
; 2442 :         SD_API_STATUS_UNSUCCESSFUL,
; 2443 :         NumBlocks,BlockSize,0,

  000b4	e59b1008	 ldr         r1, [r11, #8]
  000b8	e59b200c	 ldr         r2, [r11, #0xC]

; 2444 :         pBuffer,NULL,
; 2445 :         0, // DATA Clock
; 2446 :         Flags,

  000bc	e59b0014	 ldr         r0, [r11, #0x14]

; 2447 :         cbSize, pPhysBuffList 

  000c0	e59b3018	 ldr         r3, [r11, #0x18]
  000c4	e54be05b	 strb        lr, [r11, #-0x5B]
  000c8	e54be05a	 strb        lr, [r11, #-0x5A]
  000cc	e54be059	 strb        lr, [r11, #-0x59]
  000d0	e3a0e000	 mov         lr, #0
  000d4	e3a0410f	 mov         r4, #0xF, 2
  000d8	e50be058	 str         lr, [r11, #-0x58]
  000dc	e50b4054	 str         r4, [r11, #-0x54]
  000e0	e50b1050	 str         r1, [r11, #-0x50]
  000e4	e50b204c	 str         r2, [r11, #-0x4C]
  000e8	e3a05000	 mov         r5, #0
  000ec	e50b5048	 str         r5, [r11, #-0x48]
  000f0	e50b6044	 str         r6, [r11, #-0x44]
  000f4	e3a0e000	 mov         lr, #0
  000f8	e50be040	 str         lr, [r11, #-0x40]
  000fc	e3a0e000	 mov         lr, #0
  00100	e50be03c	 str         lr, [r11, #-0x3C]
  00104	e50b0038	 str         r0, [r11, #-0x38]
  00108	e50b3034	 str         r3, [r11, #-0x34]

; 2448 :     };

  0010c	e50b7030	 str         r7, [r11, #-0x30]

; 2449 : 
; 2450 :     BOOL fFastPathSuitable = (Command == SD_COMMAND || (NumBlocks*BlockSize)<= m_sdSlot.m_FastPathThreshHold );

  00110	e3580002	 cmp         r8, #2
  00114	0a000004	 beq         |$LN17@SDSynchron|
  00118	e59a3438	 ldr         r3, [r10, #0x438]
  0011c	e0020291	 mul         r2, r1, r2
  00120	e5933104	 ldr         r3, [r3, #0x104]
  00124	e1520003	 cmp         r2, r3
  00128	8a000006	 bhi         |$LN14@SDSynchron|
  0012c		 |$LN17@SDSynchron|

; 2451 :     
; 2452 :     if (fFastPathSuitable && (m_SDCardInfo.SDIOInformation.Flags & FSTPTH_DISABLE ) == 0  ) {

  0012c	e5da3511	 ldrb        r3, [r10, #0x511]
  00130	e3130020	 tst         r3, #0x20

; 2453 :         sdRequest.Flags |= SD_SYNCHRONOUS_REQUEST ;
; 2454 :         sdRequest.SystemFlags |= SD_FAST_PATH_AVAILABLE;

  00134	051b3080	 ldreq       r3, [r11, #-0x80]
  00138	03833102	 orreq       r3, r3, #2, 2
  0013c	03802004	 orreq       r2, r0, #4
  00140	050b3080	 streq       r3, [r11, #-0x80]
  00144	050b2038	 streq       r2, [r11, #-0x38]
  00148		 |$LN14@SDSynchron|

; 2455 :     }
; 2456 :     sdRequest.pCallback = SDSyncRequestCallback ;
; 2457 :     sdRequest.RequestParam = (DWORD)m_hSyncEvent;

  00148	e59a2434	 ldr         r2, [r10, #0x434]
  0014c	e59f31a0	 ldr         r3, [pc, #0x1A0]

; 2458 :     ResetEvent(m_hSyncEvent);

  00150	e3a01002	 mov         r1, #2
  00154	e1a00002	 mov         r0, r2
  00158	e50b3040	 str         r3, [r11, #-0x40]
  0015c	e50b2058	 str         r2, [r11, #-0x58]
  00160	eb000000	 bl          EventModify

; 2459 :     CSDBusRequest * pNewRequest =  new CSDBusRequest(*this, sdRequest );

  00164	e3a00094	 mov         r0, #0x94
  00168	eb000000	 bl          |??2CSDBusRequest@@SAPAXI@Z|
  0016c	e3500000	 cmp         r0, #0
  00170	0a000007	 beq         |$LN19@SDSynchron|
  00174	e3a03000	 mov         r3, #0
  00178	e58d3000	 str         r3, [sp]
  0017c	e3a03000	 mov         r3, #0
  00180	e24b208c	 sub         r2, r11, #0x8C
  00184	e1a0100a	 mov         r1, r10
  00188	eb000000	 bl          |??0CSDBusRequest@@QAA@AAVCSDDevice@@AAU_SD_BUS_REQUEST@@PAXPAV0@@Z|
  0018c	e1a04000	 mov         r4, r0
  00190	ea000000	 b           |$LN20@SDSynchron|
  00194		 |$LN19@SDSynchron|
  00194	e3a04000	 mov         r4, #0
  00198		 |$LN20@SDSynchron|

; 2460 :     if (pNewRequest && pNewRequest->Init() ) {

  00198	e3540000	 cmp         r4, #0
  0019c	0a000037	 beq         |$LN23@SDSynchron|
  001a0	e5943000	 ldr         r3, [r4]
  001a4	e1a00004	 mov         r0, r4
  001a8	e5933004	 ldr         r3, [r3, #4]
  001ac	e1a0e00f	 mov         lr, pc
  001b0	e12fff13	 bx          r3
  001b4	e3500000	 cmp         r0, #0
  001b8	0a000029	 beq         |$LN13@SDSynchron|

; 2461 :         pNewRequest->AddRef();

  001bc	e284007c	 add         r0, r4, #0x7C
  001c0	eb000000	 bl          InterlockedIncrement

; 2462 :         CSDBusRequest * pCur = pNewRequest; 

  001c4	e1a05004	 mov         r5, r4
  001c8		 |$LL12@SDSynchron|

; 2463 :         while (pCur) {
; 2464 :             status = m_sdSlot.QueueBusRequest(pCur);

  001c8	e59a3438	 ldr         r3, [r10, #0x438]
  001cc	e1a01005	 mov         r1, r5
  001d0	e2830044	 add         r0, r3, #0x44
  001d4	eb000000	 bl          |?QueueBusRequest@CSDBusReqAsyncQueue@@QAAJPAVCSDBusRequest@@@Z|
  001d8	e1b09000	 movs        r9, r0

; 2465 :             if (!SD_API_SUCCESS(status)) {

  001dc	4a000002	 bmi         |$LN53@SDSynchron|

; 2466 :                 DEBUGMSG(SDCARD_ZONE_ERROR, (_T("SDSynchronousBusRequest_I: queue request failed(0x%x),TransferClass(%x), CommandCode(%x),CommandArgument(%x)\r\n"),
; 2467 :                     status, pCur->TransferClass, pCur->CommandCode,pCur->CommandArgument));
; 2468 :                 break;
; 2469 :             }
; 2470 :             else {
; 2471 :                 pCur = pCur->GetChildListNext();

  001e0	e5953070	 ldr         r3, [r5, #0x70]
  001e4	e1b05003	 movs        r5, r3
  001e8	1afffff6	 bne         |$LL12@SDSynchron|
  001ec		 |$LN53@SDSynchron|

; 2472 :             }
; 2473 :         }
; 2474 :         while (pCur) { // This failed. So we complete the rest of them.

  001ec	e3550000	 cmp         r5, #0
  001f0	0a00000a	 beq         |$LN7@SDSynchron|
  001f4	e3a06001	 mov         r6, #1
  001f8		 |$LL8@SDSynchron|

; 2475 :             pCur->CompleteBusRequest(status );

  001f8	e595306c	 ldr         r3, [r5, #0x6C]
  001fc	e585903c	 str         r9, [r5, #0x3C]
  00200	e5856080	 str         r6, [r5, #0x80]
  00204	e3530000	 cmp         r3, #0
  00208	11a00003	 movne       r0, r3
  0020c	01a00005	 moveq       r0, r5
  00210	eb000000	 bl          |?CheckForCompletion@CSDBusRequest@@IAAHXZ|

; 2476 :             pCur = pCur->GetChildListNext();

  00214	e5953070	 ldr         r3, [r5, #0x70]
  00218	e1b05003	 movs        r5, r3
  0021c	1afffff5	 bne         |$LL8@SDSynchron|
  00220		 |$LN7@SDSynchron|

; 2477 :         }
; 2478 :         // wait for the I/O to complete
; 2479 :         if (!pNewRequest->IsComplete()) {

  00220	e1a00004	 mov         r0, r4
  00224	eb000000	 bl          |?IsComplete@CSDBusRequest@@QAAHXZ|
  00228	e3500000	 cmp         r0, #0

; 2480 :             DWORD waitResult = WaitForSingleObject(m_hSyncEvent, INFINITE);

  0022c	059a0434	 ldreq       r0, [r10, #0x434]
  00230	03e01000	 mvneq       r1, #0
  00234	0b000000	 bleq        WaitForSingleObject

; 2481 :             ASSERT(WAIT_OBJECT_0 == waitResult);
; 2482 :         }
; 2483 :         ASSERT(pNewRequest->IsComplete());
; 2484 :         sdRequest = *(SD_BUS_REQUEST *)pNewRequest;

  00238	e24b008c	 sub         r0, r11, #0x8C
  0023c	e2841004	 add         r1, r4, #4
  00240	e3a02060	 mov         r2, #0x60
  00244	eb000000	 bl          memcpy

; 2485 :         if (SD_API_SUCCESS(status)) { // If Request Submit Correct and Get Answered. We should get STatus.

  00248	e3590000	 cmp         r9, #0

; 2486 :             status = sdRequest.Status;

  0024c	551b9054	 ldrpl       r9, [r11, #-0x54]

; 2487 :         }
; 2488 :         pNewRequest->TerminateLink();

  00250	e1a00004	 mov         r0, r4
  00254	eb000000	 bl          |?TerminateLink@CSDBusRequest@@QAAHXZ|

; 2489 :         pNewRequest->DeRef();

  00258	e1a00004	 mov         r0, r4
  0025c	eb000000	 bl          |?DeRef@CSDBusRequest@@QAAKXZ|
  00260	ea000006	 b           |$LN23@SDSynchron|
  00264		 |$LN13@SDSynchron|

; 2490 :     }
; 2491 :     else if (pNewRequest)

  00264	e3540000	 cmp         r4, #0

; 2492 :         delete pNewRequest;                

  00268	15943000	 ldrne       r3, [r4]
  0026c	13a01001	 movne       r1, #1
  00270	11a00004	 movne       r0, r4
  00274	15933000	 ldrne       r3, [r3]
  00278	11a0e00f	 movne       lr, pc
  0027c	112fff13	 bxne        r3
  00280		 |$LN23@SDSynchron|

; 2493 :         
; 2494 :     if (SD_API_SUCCESS(status) && NULL != pResponse) {

  00280	e3590000	 cmp         r9, #0
  00284	4a00000c	 bmi         |$LN32@SDSynchron|
  00288	e51b3090	 ldr         r3, [r11, #-0x90]
  0028c	e3530000	 cmp         r3, #0
  00290	0a000009	 beq         |$LN32@SDSynchron|
  00294		 |$LN30@SDSynchron|

; 2495 :         __try {
; 2496 :             *pResponse = sdRequest.CommandResponse ;

  00294	e24b1070	 sub         r1, r11, #0x70
  00298	e3a02018	 mov         r2, #0x18
  0029c	e1a00003	 mov         r0, r3
  002a0	eb000000	 bl          memcpy
  002a4		 |$LN31@SDSynchron|
  002a4	ea000004	 b           |$LN32@SDSynchron|
  002a8		 |$LN27@SDSynchron|

; 2498 :             DEBUGMSG(SDCARD_ZONE_ERROR, (_T("SDCard: Access violation while copying command response to user buffer\r\n")));
; 2499 :             status = SD_API_STATUS_ACCESS_VIOLATION;

  002a8	e3a09117	 mov         r9, #0x17, 2
  002ac	e51ba098	 ldr         r10, [r11, #-0x98]
  002b0	ea000001	 b           |$LN32@SDSynchron|
  002b4		 |$LN55@SDSynchron|

; 2505 :     return (status);    

  002b4	e51b9094	 ldr         r9, [r11, #-0x94]
  002b8	ea000004	 b           |$LN15@SDSynchron|
  002bc		 |$LN32@SDSynchron|

; 2500 :         };
; 2501 : 
; 2502 :     }
; 2503 :     
; 2504 :     m_sdSlot.m_RequestLock.Unlock();

  002bc	e59a3438	 ldr         r3, [r10, #0x438]
  002c0	e28300e8	 add         r0, r3, #0xE8
  002c4	eb000000	 bl          LeaveCriticalSection

; 2505 :     return (status);    

  002c8	e51b002c	 ldr         r0, [r11, #-0x2C]
  002cc	eb000000	 bl          __security_check_cookie
  002d0		 |$LN15@SDSynchron|

; 2506 : }

  002d0	e1a00009	 mov         r0, r9
  002d4	e24bd028	 sub         sp, r11, #0x28
  002d8	e89d6ff0	 ldmia       sp, {r4 - r11, sp, lr}
  002dc	e12fff1e	 bx          lr

			 ENDP  ; |?SDSynchronousBusRequest_I@CSDDevice@@UAAJEKW4SD_TRANSFER_CLASS@@W4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@KKPAEKKPAU__PHYS_BUFF_LIST@@@Z|, CSDDevice::SDSynchronousBusRequest_I

  002e0		 |$LN26@SDSynchron|
  002e0		 |$LN59@SDSynchron|

; 2497 :         } __except (SDProcessException(GetExceptionInformation())) {

  002e0	e52de004	 str         lr, [sp, #-4]!
  002e4	e24dd004	 sub         sp, sp, #4
  002e8		 |$LN29@SDSynchron|
  002e8		 |$LN62@SDSynchron|
  002e8	eb000000	 bl          SDProcessException
  002ec		 |$LN28@SDSynchron|
  002ec	e28dd004	 add         sp, sp, #4
  002f0	e49df004	 ldr         pc, [sp], #4
  002f4		 |$LN64@SDSynchron|
  002f4		 |$LN65@SDSynchron|
  002f4	00000000	 DCD         |?SDSyncRequestCallback@CSDDevice@@KAXPAXPAU_SD_BUS_REQUEST@@0K@Z|
  002f8		 |$LN66@SDSynchron|
  002f8	00000000	 DCD         |__security_cookie|
  002fc		 |$LN63@SDSynchron|
  002fc		 |$LN61@SDSynchron|
	EXPORT	|this$GSCopy$| [ DATA ]
	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?SDBusRequest_I@CSDDevice@@UAAJEKW4SD_TRANSFER_CLASS@@W4_SD_RESPONSE_TYPE@@KKPAEP6AXPAXPAU_SD_BUS_REQUEST@@3K@ZKPAPAXKKPAU__PHYS_BUFF_LIST@@@Z| ; CSDDevice::SDBusRequest_I
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T42541| DCD	|$LN64@SDBusReque|
	DCD	0xc000b604

  00000			 AREA	 |.pdata|, PDATA
|$T42543| DCD	|$LN22@SDBusReque|
	DCD	0x40000602

  00000			 AREA	 |.xdata|, DATA
|$T42539| DCD	0x1
	DCD	|$LN26@SDBusReque|
	DCD	|$LN27@SDBusReque|
	DCD	|$LN22@SDBusReque|
	DCD	|$LN23@SDBusReque|
	DCD	0xffffffd4
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck_SEH|
  00004	00000000	 DCD         |$T42539|

  00008		 |?SDBusRequest_I@CSDDevice@@UAAJEKW4SD_TRANSFER_CLASS@@W4_SD_RESPONSE_TYPE@@KKPAEP6AXPAXPAU_SD_BUS_REQUEST@@3K@ZKPAPAXKKPAU__PHYS_BUFF_LIST@@@Z| PROC ; CSDDevice::SDBusRequest_I

; 2510 : {

  00008		 |$LN64@SDBusReque|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d5ff0	 stmdb       sp!, {r4 - r12, lr}
  00010	e28db028	 add         r11, sp, #0x28
  00014	e24dd074	 sub         sp, sp, #0x74
  00018		 |$LN62@SDBusReque|
  00018	e1a05003	 mov         r5, r3
  0001c	e1a06002	 mov         r6, r2
  00020	e1a04001	 mov         r4, r1
  00024	e1a0a000	 mov         r10, r0
  00028	e59fe2c4	 ldr         lr, [pc, #0x2C4]
  0002c	e59ee000	 ldr         lr, [lr]
  00030	e50be02c	 str         lr, [r11, #-0x2C]

; 2511 :     SD_API_STATUS   status = SD_API_STATUS_UNSUCCESSFUL;
; 2512 :     
; 2513 :     m_sdSlot.m_RequestLock.Lock();

  00034	e50ba090	 str         r10, [r11, #-0x90]
  00038	e59b800c	 ldr         r8, [r11, #0xC]
  0003c	e59ae438	 ldr         lr, [r10, #0x438]
  00040	e59b7010	 ldr         r7, [r11, #0x10]
  00044	e59b3018	 ldr         r3, [r11, #0x18]
  00048	e50b3098	 str         r3, [r11, #-0x98]
  0004c	e28e00e8	 add         r0, lr, #0xE8
  00050	e59b9024	 ldr         r9, [r11, #0x24]
  00054	eb000000	 bl          EnterCriticalSection

; 2514 : 
; 2515 :     SD_BUS_REQUEST sdRequest = {
; 2516 :         {NULL},GetDeviceHandle().hValue,0,

  00058	e3a03000	 mov         r3, #0
  0005c	e50b308c	 str         r3, [r11, #-0x8C]
  00060	e3a03000	 mov         r3, #0
  00064	e50b3088	 str         r3, [r11, #-0x88]
  00068	e24b1094	 sub         r1, r11, #0x94
  0006c	e1a0000a	 mov         r0, r10
  00070	eb000000	 bl          |?GetDeviceHandle@CSDDevice@@QAA?AT__SDBUS_DEVICE_HANDLE@@XZ|
  00074	e5903000	 ldr         r3, [r0]

; 2517 :         TransferClass,Command, Argument,
; 2518 :         {ResponseType,{0}},

  00078	e59be000	 ldr         lr, [r11]
  0007c	e50b3084	 str         r3, [r11, #-0x84]
  00080	e3a02010	 mov         r2, #0x10
  00084	e3a01000	 mov         r1, #0
  00088	e24b006b	 sub         r0, r11, #0x6B
  0008c	e3a03000	 mov         r3, #0
  00090	e50b3080	 str         r3, [r11, #-0x80]
  00094	e50b507c	 str         r5, [r11, #-0x7C]
  00098	e54b4078	 strb        r4, [r11, #-0x78]
  0009c	e50b6074	 str         r6, [r11, #-0x74]
  000a0	e50be070	 str         lr, [r11, #-0x70]
  000a4	e3a03000	 mov         r3, #0
  000a8	e54b306c	 strb        r3, [r11, #-0x6C]
  000ac	eb000000	 bl          memset
  000b0	e3a04000	 mov         r4, #0

; 2519 :         RequestParam,

  000b4	e59b3014	 ldr         r3, [r11, #0x14]

; 2520 :         SD_API_STATUS_UNSUCCESSFUL,
; 2521 :         NumBlocks,BlockSize,0,

  000b8	e59b2004	 ldr         r2, [r11, #4]
  000bc	e59b1008	 ldr         r1, [r11, #8]

; 2522 :         pBuffer,pCallback,
; 2523 :         0, // DATA Clock
; 2524 :         Flags,

  000c0	e59b001c	 ldr         r0, [r11, #0x1C]

; 2525 :         cbSize,

  000c4	e59be020	 ldr         lr, [r11, #0x20]
  000c8	e54b405b	 strb        r4, [r11, #-0x5B]
  000cc	e54b405a	 strb        r4, [r11, #-0x5A]
  000d0	e54b4059	 strb        r4, [r11, #-0x59]
  000d4	e3a0410f	 mov         r4, #0xF, 2
  000d8	e3a05000	 mov         r5, #0
  000dc	e3a06000	 mov         r6, #0
  000e0	e50b3058	 str         r3, [r11, #-0x58]
  000e4	e50b4054	 str         r4, [r11, #-0x54]
  000e8	e50b2050	 str         r2, [r11, #-0x50]
  000ec	e50b104c	 str         r1, [r11, #-0x4C]
  000f0	e50b5048	 str         r5, [r11, #-0x48]
  000f4	e50b8044	 str         r8, [r11, #-0x44]
  000f8	e50b7040	 str         r7, [r11, #-0x40]
  000fc	e50b603c	 str         r6, [r11, #-0x3C]
  00100	e50b0038	 str         r0, [r11, #-0x38]
  00104	e50be034	 str         lr, [r11, #-0x34]

; 2526 :         pPhysBuffList
; 2527 :     };

  00108	e50b9030	 str         r9, [r11, #-0x30]

; 2528 :     
; 2529 :     CSDBusRequest * pNewRequest =  new CSDBusRequest(*this, sdRequest, m_hCallbackHandle );// This is from external

  0010c	e3a00094	 mov         r0, #0x94
  00110	eb000000	 bl          |??2CSDBusRequest@@SAPAXI@Z|
  00114	e3500000	 cmp         r0, #0
  00118	0a000007	 beq         |$LN17@SDBusReque|
  0011c	e59a344c	 ldr         r3, [r10, #0x44C]
  00120	e3a0e000	 mov         lr, #0
  00124	e24b208c	 sub         r2, r11, #0x8C
  00128	e1a0100a	 mov         r1, r10
  0012c	e58de000	 str         lr, [sp]
  00130	eb000000	 bl          |??0CSDBusRequest@@QAA@AAVCSDDevice@@AAU_SD_BUS_REQUEST@@PAXPAV0@@Z|
  00134	e1a04000	 mov         r4, r0
  00138	ea000000	 b           |$LN60@SDBusReque|
  0013c		 |$LN17@SDBusReque|
  0013c	e3a04000	 mov         r4, #0
  00140		 |$LN60@SDBusReque|
  00140	e50b4094	 str         r4, [r11, #-0x94]

; 2530 :     if (phRequest && pNewRequest && pNewRequest->Init() ) {

  00144	e51b6098	 ldr         r6, [r11, #-0x98]
  00148	e3560000	 cmp         r6, #0
  0014c	0a000052	 beq         |$LN14@SDBusReque|
  00150	e3540000	 cmp         r4, #0
  00154	0a000050	 beq         |$LN14@SDBusReque|
  00158	e5943000	 ldr         r3, [r4]
  0015c	e1a00004	 mov         r0, r4
  00160	e5933004	 ldr         r3, [r3, #4]
  00164	e1a0e00f	 mov         lr, pc
  00168	e12fff13	 bx          r3
  0016c	e3500000	 cmp         r0, #0
  00170	0a000049	 beq         |$LN14@SDBusReque|

; 2531 :         DWORD dwIndex = 0;

  00174	e3a03000	 mov         r3, #0
  00178	e50b3098	 str         r3, [r11, #-0x98]

; 2532 :         pNewRequest->AddRef();

  0017c	e284007c	 add         r0, r4, #0x7C
  00180	eb000000	 bl          InterlockedIncrement

; 2533 :         if (InsertRequestAtEmpty(&dwIndex,pNewRequest )) {

  00184	e1a02004	 mov         r2, r4
  00188	e24b1098	 sub         r1, r11, #0x98
  0018c	e1a0000a	 mov         r0, r10
  00190	eb000000	 bl          |?InsertRequestAtEmpty@CSDDevice@@IAAPAVCSDBusRequest@@PAKPAV2@@Z|
  00194	e3500000	 cmp         r0, #0
  00198	0a00003b	 beq         |$LN13@SDBusReque|

; 2534 :             // After this point the status should return during the completion.
; 2535 :             SDBUS_REQUEST_HANDLE sdBusRequestHandle;
; 2536 :             sdBusRequestHandle.bit.sdBusIndex = m_sdSlot.GetHost().GetIndex();

  0019c	e59ae438	 ldr         lr, [r10, #0x438]

; 2537 :             sdBusRequestHandle.bit.sdSlotIndex = m_sdSlot.GetSlotIndex();
; 2538 :             sdBusRequestHandle.bit.sdFunctionIndex = m_FuncionIndex; 
; 2539 :             sdBusRequestHandle.bit.sdRequestIndex = dwIndex;
; 2540 :             sdBusRequestHandle.bit.sd1f = 0x1f;
; 2541 :             sdBusRequestHandle.bit.sdRandamNumber = pNewRequest->GetRequestRandomIndex();

  001a0	e51b3098	 ldr         r3, [r11, #-0x98]
  001a4	e5942078	 ldr         r2, [r4, #0x78]
  001a8	e59a143c	 ldr         r1, [r10, #0x43C]
  001ac	e59e007c	 ldr         r0, [lr, #0x7C]
  001b0	e20330ff	 and         r3, r3, #0xFF
  001b4	e1832402	 orr         r2, r3, r2, lsl #8
  001b8	e59ee080	 ldr         lr, [lr, #0x80]
  001bc	e2013007	 and         r3, r1, #7
  001c0	e590105c	 ldr         r1, [r0, #0x5C]
  001c4	e1833402	 orr         r3, r3, r2, lsl #8
  001c8	e38320f8	 orr         r2, r3, #0xF8
  001cc	e20e300f	 and         r3, lr, #0xF
  001d0	e1832202	 orr         r2, r3, r2, lsl #4
  001d4	e201300f	 and         r3, r1, #0xF
  001d8	e1831202	 orr         r1, r3, r2, lsl #4
  001dc	e50b1098	 str         r1, [r11, #-0x98]

; 2542 : 
; 2543 :             status = SD_API_STATUS_PENDING ;

  001e0	e3a05001	 mov         r5, #1
  001e4		 |$LN26@SDBusReque|

; 2544 :             __try {
; 2545 :                 *phRequest = sdBusRequestHandle.hValue;

  001e4	e5861000	 str         r1, [r6]
  001e8		 |$LN27@SDBusReque|

; 2546 :             }

  001e8	ea000003	 b           |$LN28@SDBusReque|
  001ec		 |$LN23@SDBusReque|

; 2548 :                 DEBUGMSG(SDCARD_ZONE_ERROR, (_T("SDCard: Access violation while copying command response to user buffer\r\n")));
; 2549 :                 status = SD_API_STATUS_ACCESS_VIOLATION;

  001ec	e3a05117	 mov         r5, #0x17, 2
  001f0	e51b4094	 ldr         r4, [r11, #-0x94]
  001f4	e51b1098	 ldr         r1, [r11, #-0x98]
  001f8	e51ba090	 ldr         r10, [r11, #-0x90]
  001fc		 |$LN28@SDBusReque|

; 2550 :             }
; 2551 :             if (SD_API_SUCCESS(status)) {

  001fc	e3550000	 cmp         r5, #0
  00200	4a000019	 bmi         |$LN11@SDBusReque|

; 2552 :                 pNewRequest->SetExternalHandle(sdBusRequestHandle.hValue);

  00204	e5841074	 str         r1, [r4, #0x74]

; 2553 :                 CSDBusRequest * pCur = pNewRequest;

  00208	e1a05004	 mov         r5, r4
  0020c		 |$LL10@SDBusReque|

; 2554 :                 while (pCur) {
; 2555 :                     status = m_sdSlot.QueueBusRequest(pCur);

  0020c	e59a3438	 ldr         r3, [r10, #0x438]
  00210	e1a01005	 mov         r1, r5
  00214	e2830044	 add         r0, r3, #0x44
  00218	eb000000	 bl          |?QueueBusRequest@CSDBusReqAsyncQueue@@QAAJPAVCSDBusRequest@@@Z|
  0021c	e1b06000	 movs        r6, r0

; 2556 :                     if (!SD_API_SUCCESS(status)) {

  00220	4a000002	 bmi         |$LN57@SDBusReque|

; 2557 :                         ASSERT(FALSE);
; 2558 :                         break;
; 2559 :                     }
; 2560 :                     else {
; 2561 :                         pCur = pCur->GetChildListNext();

  00224	e5953070	 ldr         r3, [r5, #0x70]
  00228	e1b05003	 movs        r5, r3
  0022c	1afffff6	 bne         |$LL10@SDBusReque|
  00230		 |$LN57@SDBusReque|

; 2562 :                     }
; 2563 :                 }
; 2564 :                 while (pCur) { // This failed. So we complete the rest of them.

  00230	e3550000	 cmp         r5, #0
  00234	0a00000a	 beq         |$LN5@SDBusReque|
  00238	e3a07001	 mov         r7, #1
  0023c		 |$LL6@SDBusReque|

; 2565 :                     pCur->CompleteBusRequest(status );

  0023c	e595306c	 ldr         r3, [r5, #0x6C]
  00240	e585603c	 str         r6, [r5, #0x3C]
  00244	e5857080	 str         r7, [r5, #0x80]
  00248	e3530000	 cmp         r3, #0
  0024c	11a00003	 movne       r0, r3
  00250	01a00005	 moveq       r0, r5
  00254	eb000000	 bl          |?CheckForCompletion@CSDBusRequest@@IAAHXZ|

; 2566 :                     pCur = pCur->GetChildListNext();

  00258	e5953070	 ldr         r3, [r5, #0x70]
  0025c	e1b05003	 movs        r5, r3
  00260	1afffff5	 bne         |$LL6@SDBusReque|
  00264		 |$LN5@SDBusReque|

; 2567 :                 }
; 2568 :                 status = SD_API_STATUS_PENDING; // Real status should be return from callback from this point.

  00264	e3a05001	 mov         r5, #1

; 2569 :             }
; 2570 :             else {

  00268	ea000008	 b           |$LN3@SDBusReque|
  0026c		 |$LN11@SDBusReque|

; 2571 :                 ASSERT(FALSE);
; 2572 :                 SDFreeBusRequest_I(sdBusRequestHandle.hValue);

  0026c	e59a3000	 ldr         r3, [r10]
  00270	e1a0000a	 mov         r0, r10
  00274	e593301c	 ldr         r3, [r3, #0x1C]
  00278	e1a0e00f	 mov         lr, pc
  0027c	e12fff13	 bx          r3

; 2573 :             }
; 2574 :         }
; 2575 :         else 

  00280	ea000002	 b           |$LN3@SDBusReque|
  00284		 |$LN59@SDBusReque|

; 2589 :         
; 2590 :     ASSERT(SD_API_SUCCESS(status));
; 2591 :     return (status);    

  00284	e51b5090	 ldr         r5, [r11, #-0x90]
  00288	ea000010	 b           |$LN15@SDBusReque|
  0028c		 |$LN13@SDBusReque|

; 2576 :             status = SD_API_STATUS_NO_MEMORY;

  0028c	e3a0512b	 mov         r5, #0x2B, 2
  00290		 |$LN3@SDBusReque|

; 2577 :         pNewRequest->DeRef();

  00290	e1a00004	 mov         r0, r4
  00294	eb000000	 bl          |?DeRef@CSDBusRequest@@QAAKXZ|

; 2578 :         pNewRequest = NULL;
; 2579 :         
; 2580 :     }
; 2581 :     else {

  00298	ea000007	 b           |$LN19@SDBusReque|
  0029c		 |$LN14@SDBusReque|

; 2582 :         status = SD_API_STATUS_NO_MEMORY;

  0029c	e3a0512b	 mov         r5, #0x2B, 2

; 2583 :         if (pNewRequest ) {

  002a0	e3540000	 cmp         r4, #0

; 2584 :             delete pNewRequest;

  002a4	15943000	 ldrne       r3, [r4]
  002a8	13a01001	 movne       r1, #1
  002ac	11a00004	 movne       r0, r4
  002b0	15933000	 ldrne       r3, [r3]
  002b4	11a0e00f	 movne       lr, pc
  002b8	112fff13	 bxne        r3
  002bc		 |$LN19@SDBusReque|

; 2585 :         }
; 2586 :     }
; 2587 :     
; 2588 :     m_sdSlot.m_RequestLock.Unlock();

  002bc	e59a3438	 ldr         r3, [r10, #0x438]
  002c0	e28300e8	 add         r0, r3, #0xE8
  002c4	eb000000	 bl          LeaveCriticalSection

; 2589 :         
; 2590 :     ASSERT(SD_API_SUCCESS(status));
; 2591 :     return (status);    

  002c8	e51b002c	 ldr         r0, [r11, #-0x2C]
  002cc	eb000000	 bl          __security_check_cookie
  002d0		 |$LN15@SDBusReque|

; 2592 : 
; 2593 : 
; 2594 : }

  002d0	e1a00005	 mov         r0, r5
  002d4	e24bd028	 sub         sp, r11, #0x28
  002d8	e89d6ff0	 ldmia       sp, {r4 - r11, sp, lr}
  002dc	e12fff1e	 bx          lr

			 ENDP  ; |?SDBusRequest_I@CSDDevice@@UAAJEKW4SD_TRANSFER_CLASS@@W4_SD_RESPONSE_TYPE@@KKPAEP6AXPAXPAU_SD_BUS_REQUEST@@3K@ZKPAPAXKKPAU__PHYS_BUFF_LIST@@@Z|, CSDDevice::SDBusRequest_I

  002e0		 |$LN22@SDBusReque|
  002e0		 |$LN63@SDBusReque|

; 2547 :             __except (SDProcessException(GetExceptionInformation())) {

  002e0	e52de004	 str         lr, [sp, #-4]!
  002e4	e24dd004	 sub         sp, sp, #4
  002e8		 |$LN25@SDBusReque|
  002e8		 |$LN66@SDBusReque|
  002e8	eb000000	 bl          SDProcessException
  002ec		 |$LN24@SDBusReque|
  002ec	e28dd004	 add         sp, sp, #4
  002f0	e49df004	 ldr         pc, [sp], #4
  002f4		 |$LN68@SDBusReque|
  002f4		 |$LN69@SDBusReque|
  002f4	00000000	 DCD         |__security_cookie|
  002f8		 |$LN67@SDBusReque|
  002f8		 |$LN65@SDBusReque|
	EXPORT	|?HandleDeviceInterrupt@CSDDevice@@UAAXXZ| ; CSDDevice::HandleDeviceInterrupt

  00000			 AREA	 |.pdata|, PDATA
|$T42572| DCD	|$LN20@HandleDevi|
	DCD	0xc0002704

  00000			 AREA	 |.pdata|, PDATA
|$T42574| DCD	|$LN9@HandleDevi|
	DCD	0x40000602

  00000			 AREA	 |.xdata|, DATA
|$T42570| DCD	0x1
	DCD	|$LN13@HandleDevi|
	DCD	|$LN14@HandleDevi|
	DCD	|$LN9@HandleDevi|
	DCD	|$LN10@HandleDevi|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T42570|

  00008		 |?HandleDeviceInterrupt@CSDDevice@@UAAXXZ| PROC ; CSDDevice::HandleDeviceInterrupt

; 2676 : {

  00008		 |$LN20@HandleDevi|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d5870	 stmdb       sp!, {r4 - r6, r11, r12, lr}
  00010	e28db018	 add         r11, sp, #0x18
  00014	e24dd020	 sub         sp, sp, #0x20
  00018		 |$LN18@HandleDevi|
  00018	e1a04000	 mov         r4, r0

; 2677 :     SD_API_STATUS status = SD_API_STATUS_INVALID_HANDLE;
; 2678 :     if (m_SDCardInfo.SDIOInformation.pInterruptCallBack!=NULL) {

  0001c	e59434e8	 ldr         r3, [r4, #0x4E8]
  00020	e1b05003	 movs        r5, r3
  00024	0a00001b	 beq         |$LN15@HandleDevi|
  00028		 |$LN13@HandleDevi|

; 2679 :         DEBUGMSG(SDBUS_ZONE_DEVICE,(TEXT("HandleDeviceInterrupting - Calling interrupt handler for %s \n"), 
; 2680 :             m_ClientName));
; 2681 :         if (m_SDCardInfo.SDIOInformation.pInterruptCallBack!=NULL) { // We need callback.
; 2682 :             __try {
; 2683 :                 if (m_hCallbackHandle!=NULL) { // Callback between proc.

  00028	e594344c	 ldr         r3, [r4, #0x44C]
  0002c	e1b06003	 movs        r6, r3

; 2684 :                     IO_BUS_SD_INTERRUPT_CALLBACK sdInterruptCallback = {
; 2685 :                         m_SDCardInfo.SDIOInformation.pInterruptCallBack, GetDeviceHandle().hValue,m_pDeviceContext

  00030	e24b1028	 sub         r1, r11, #0x28
  00034	e1a00004	 mov         r0, r4

; 2679 :         DEBUGMSG(SDBUS_ZONE_DEVICE,(TEXT("HandleDeviceInterrupting - Calling interrupt handler for %s \n"), 
; 2680 :             m_ClientName));
; 2681 :         if (m_SDCardInfo.SDIOInformation.pInterruptCallBack!=NULL) { // We need callback.
; 2682 :             __try {
; 2683 :                 if (m_hCallbackHandle!=NULL) { // Callback between proc.

  00038	0a000010	 beq         |$LN2@HandleDevi|

; 2684 :                     IO_BUS_SD_INTERRUPT_CALLBACK sdInterruptCallback = {
; 2685 :                         m_SDCardInfo.SDIOInformation.pInterruptCallBack, GetDeviceHandle().hValue,m_pDeviceContext

  0003c	e50b5024	 str         r5, [r11, #-0x24]
  00040	eb000000	 bl          |?GetDeviceHandle@CSDDevice@@QAA?AT__SDBUS_DEVICE_HANDLE@@XZ|
  00044	e5902000	 ldr         r2, [r0]

; 2686 :                     };
; 2687 :                     CeDriverPerformCallback(m_hCallbackHandle, IOCTL_BUS_SD_INTERRUPT_CALLBACK, &sdInterruptCallback, sizeof(sdInterruptCallback),
; 2688 :                         NULL,0,
; 2689 :                         NULL,NULL);

  00048	e59f1068	 ldr         r1, [pc, #0x68]
  0004c	e3a0300c	 mov         r3, #0xC
  00050	e50b2020	 str         r2, [r11, #-0x20]
  00054	e594e498	 ldr         lr, [r4, #0x498]
  00058	e24b2024	 sub         r2, r11, #0x24
  0005c	e1a00006	 mov         r0, r6
  00060	e50be01c	 str         lr, [r11, #-0x1C]
  00064	e3a0e000	 mov         lr, #0
  00068	e58de00c	 str         lr, [sp, #0xC]
  0006c	e58de008	 str         lr, [sp, #8]
  00070	e58de004	 str         lr, [sp, #4]
  00074	e58de000	 str         lr, [sp]
  00078	eb000000	 bl          CeDriverPerformCallback

; 2690 :                     status = SD_API_STATUS_SUCCESS ;
; 2691 :                     
; 2692 :                 }
; 2693 :                 else { // In-proc

  0007c	ea000004	 b           |$LN14@HandleDevi|
  00080		 |$LN2@HandleDevi|

; 2694 :                     status = m_SDCardInfo.SDIOInformation.pInterruptCallBack(GetDeviceHandle().hValue,m_pDeviceContext);

  00080	eb000000	 bl          |?GetDeviceHandle@CSDDevice@@QAA?AT__SDBUS_DEVICE_HANDLE@@XZ|
  00084	e5900000	 ldr         r0, [r0]
  00088	e5941498	 ldr         r1, [r4, #0x498]
  0008c	e1a0e00f	 mov         lr, pc
  00090	e12fff15	 bx          r5
  00094		 |$LN14@HandleDevi|

; 2695 :                 }
; 2696 :             }

  00094	eaffffff	 b           |$LN15@HandleDevi|
  00098		 |$LN10@HandleDevi|
  00098		 |$LN15@HandleDevi|

; 2698 :                 status = SD_API_STATUS_ACCESS_VIOLATION ;
; 2699 :             }
; 2700 :         }
; 2701 :     }
; 2702 :     ASSERT(SD_API_SUCCESS(status));
; 2703 : }

  00098	e24bd018	 sub         sp, r11, #0x18
  0009c	e89d6870	 ldmia       sp, {r4 - r6, r11, sp, lr}
  000a0	e12fff1e	 bx          lr

			 ENDP  ; |?HandleDeviceInterrupt@CSDDevice@@UAAXXZ|, CSDDevice::HandleDeviceInterrupt

  000a4		 |$LN9@HandleDevi|
  000a4		 |$LN19@HandleDevi|

; 2697 :             __except(SDProcessException(GetExceptionInformation())) {

  000a4	e52de004	 str         lr, [sp, #-4]!
  000a8	e24dd010	 sub         sp, sp, #0x10
  000ac		 |$LN12@HandleDevi|
  000ac		 |$LN22@HandleDevi|
  000ac	eb000000	 bl          SDProcessException
  000b0		 |$LN11@HandleDevi|
  000b0	e28dd010	 add         sp, sp, #0x10
  000b4	e49df004	 ldr         pc, [sp], #4
  000b8		 |$LN24@HandleDevi|
  000b8		 |$LN25@HandleDevi|
  000b8	002a0508	 DCD         0x2a0508
  000bc		 |$LN23@HandleDevi|
  000bc		 |$LN21@HandleDevi|
	EXPORT	|?SDIOConnectDisconnectInterrupt@CSDDevice@@UAAJP6AJPAX0@ZH@Z| ; CSDDevice::SDIOConnectDisconnectInterrupt
	IMPORT	|?SDSlotDisableSDIOInterrupts@CSDSlot@@QAAHXZ| ; CSDSlot::SDSlotDisableSDIOInterrupts
	IMPORT	|?SDSlotEnableSDIOInterrupts@CSDSlot@@QAAHXZ| ; CSDSlot::SDSlotEnableSDIOInterrupts
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T42604| DCD	|$LN25@SDIOConnec|
	DCD	0x40004c02
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDIOConnectDisconnectInterrupt@CSDDevice@@UAAJP6AJPAX0@ZH@Z| PROC ; CSDDevice::SDIOConnectDisconnectInterrupt

; 2706 : {

  00000		 |$LN25@SDIOConnec|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M42601|
  00008	e1a04002	 mov         r4, r2
  0000c	e1a05001	 mov         r5, r1
  00010	e1a06000	 mov         r6, r0

; 2707 :     UCHAR                       regValue;           // intermediate register value
; 2708 :     SD_API_STATUS               status;             // intermediate status
; 2709 : 
; 2710 :     if (Device_SD_IO != m_DeviceType) {

  00014	e5963494	 ldr         r3, [r6, #0x494]
  00018	e3530003	 cmp         r3, #3
  0001c	0a000001	 beq         |$LN14@SDIOConnec|
  00020		 |$LN22@SDIOConnec|

; 2711 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDIOConnectDisconnectInterrupt: device is not SDIO ! \n")));
; 2712 :         return SD_API_STATUS_INVALID_PARAMETER;

  00020	e3a0411f	 mov         r4, #0x1F, 2
  00024	ea00003d	 b           |$LN15@SDIOConnec|
  00028		 |$LN14@SDIOConnec|

; 2713 :     }
; 2714 : 
; 2715 :     if ( Connect && (NULL == pIsrFunction) ) {

  00028	e3540000	 cmp         r4, #0
  0002c	0a000001	 beq         |$LN13@SDIOConnec|
  00030	e3550000	 cmp         r5, #0

; 2716 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDCard: SDIOConnectInterrupt: callback function is NULL \n")));
; 2717 :         return SD_API_STATUS_INVALID_PARAMETER;

  00034	0afffff9	 beq         |$LN22@SDIOConnec|
  00038		 |$LN13@SDIOConnec|

; 2718 :     }
; 2719 : 
; 2720 :     if (m_FuncionIndex == 0 ) { // Function zero.

  00038	e596343c	 ldr         r3, [r6, #0x43C]
  0003c	e3530000	 cmp         r3, #0

; 2721 :         DEBUGCHK(FALSE);
; 2722 :         return SD_API_STATUS_INVALID_PARAMETER;

  00040	0afffff6	 beq         |$LN22@SDIOConnec|

; 2723 :     }
; 2724 :     CSDDevice * device0 = m_sdSlot.GetFunctionDevice(0 );

  00044	e5960438	 ldr         r0, [r6, #0x438]
  00048	e3a01000	 mov         r1, #0
  0004c	eb000000	 bl          |?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z|
  00050	e1b07000	 movs        r7, r0

; 2725 :     if (device0 == NULL) {
; 2726 :         DEBUGCHK(FALSE);
; 2727 :         return SD_API_STATUS_INVALID_PARAMETER;

  00054	0afffff1	 beq         |$LN22@SDIOConnec|

; 2728 :     }
; 2729 :     Lock();

  00058	e2860008	 add         r0, r6, #8
  0005c	eb000000	 bl          EnterCriticalSection

; 2730 :     if (Connect) {

  00060	e3540000	 cmp         r4, #0

; 2731 :         m_SDCardInfo.SDIOInformation.pInterruptCallBack = pIsrFunction;

  00064	158654e8	 strne       r5, [r6, #0x4E8]

; 2732 :         // update shadow register , we automatically enable the master interrupt enable bit
; 2733 :         device0->m_SDCardInfo.SDIOInformation.pCommonInformation->CCCRShadowIntEnable |= 
; 2734 :             ((1 << m_SDCardInfo.SDIOInformation.Function) | SD_IO_INT_ENABLE_MASTER_ENABLE);

  00068	159714ec	 ldrne       r1, [r7, #0x4EC]
  0006c	e5d624d8	 ldrb        r2, [r6, #0x4D8]
  00070	e3a09000	 mov         r9, #0
  00074	15d13010	 ldrneb      r3, [r1, #0x10]
  00078	e3a00001	 mov         r0, #1

; 2735 :     } else {
; 2736 :         DEBUGCHK(pIsrFunction == NULL);
; 2737 :         m_SDCardInfo.SDIOInformation.pInterruptCallBack = NULL;

  0007c	058694e8	 streq       r9, [r6, #0x4E8]

; 2738 :         // mask out this function
; 2739 :         device0->m_SDCardInfo.SDIOInformation.pCommonInformation->CCCRShadowIntEnable &= 
; 2740 :             ~(1 << m_SDCardInfo.SDIOInformation.Function);

  00080	059714ec	 ldreq       r1, [r7, #0x4EC]
  00084	11833210	 orrne       r3, r3, r0, lsl r2
  00088	13833001	 orrne       r3, r3, #1
  0008c	05d13010	 ldreqb      r3, [r1, #0x10]
  00090	01c33210	 biceq       r3, r3, r0, lsl r2
  00094	e5c13010	 strb        r3, [r1, #0x10]

; 2741 :     }
; 2742 : 
; 2743 :     // get a copy
; 2744 :     regValue = device0->m_SDCardInfo.SDIOInformation.pCommonInformation->CCCRShadowIntEnable;

  00098	e59734ec	 ldr         r3, [r7, #0x4EC]
  0009c	e5d33010	 ldrb        r3, [r3, #0x10]

; 2745 : 
; 2746 :     // check to see if there are interrupts to keep enabled
; 2747 :     if (!(regValue & SD_IO_INT_ENABLE_ALL_FUNCTIONS)) {

  000a0	e21320fe	 ands        r2, r3, #0xFE
  000a4	e5cd3008	 strb        r3, [sp, #8]

; 2748 :         // if none, then clear out master enable
; 2749 :         regValue &= ~SD_IO_INT_ENABLE_MASTER_ENABLE;

  000a8	05cd2008	 streqb      r2, [sp, #8]

; 2750 :         device0->m_SDCardInfo.SDIOInformation.pCommonInformation->CCCRShadowIntEnable = regValue;

  000ac	059734ec	 ldreq       r3, [r7, #0x4EC]
  000b0	05c32010	 streqb      r2, [r3, #0x10]
  000b4	05dd3008	 ldreqb      r3, [sp, #8]

; 2751 :     }
; 2752 : 
; 2753 :     // set status
; 2754 :     status = SD_API_STATUS_SUCCESS; 
; 2755 : 
; 2756 :     // now check and see if we need to enable/disable interrupts in the host controller
; 2757 :     if (Connect) {

  000b8	e3540000	 cmp         r4, #0
  000bc	0a000002	 beq         |$LN7@SDIOConnec|

; 2758 :         m_sdSlot.SDSlotEnableSDIOInterrupts();

  000c0	e5960438	 ldr         r0, [r6, #0x438]
  000c4	eb000000	 bl          |?SDSlotEnableSDIOInterrupts@CSDSlot@@QAAHXZ|

; 2759 :     } else {

  000c8	ea000002	 b           |$LN5@SDIOConnec|
  000cc		 |$LN7@SDIOConnec|

; 2760 :         // check to see if all the interrupts have been turned off
; 2761 :         if (0 == regValue) {

  000cc	e3530000	 cmp         r3, #0

; 2762 :             // disable interrupts, we don't really care about the result
; 2763 :             m_sdSlot.SDSlotDisableSDIOInterrupts();

  000d0	05960438	 ldreq       r0, [r6, #0x438]
  000d4	0b000000	 bleq        |?SDSlotDisableSDIOInterrupts@CSDSlot@@QAAHXZ|
  000d8		 |$LN5@SDIOConnec|

; 2764 :         } 
; 2765 :     }
; 2766 :     Unlock();

  000d8	e2860008	 add         r0, r6, #8
  000dc	eb000000	 bl          LeaveCriticalSection

; 2767 : 
; 2768 :     // update the INT Enable register
; 2769 :     status = device0->SDReadWriteRegistersDirect_I(SD_IO_WRITE, SD_IO_REG_INT_ENABLE,FALSE,&regValue, 1);           

  000e0	e5973000	 ldr         r3, [r7]
  000e4	e3a08001	 mov         r8, #1
  000e8	e28d4008	 add         r4, sp, #8
  000ec	e5935010	 ldr         r5, [r3, #0x10]
  000f0	e3a03000	 mov         r3, #0
  000f4	e3a02004	 mov         r2, #4
  000f8	e3a01001	 mov         r1, #1
  000fc	e1a00007	 mov         r0, r7
  00100	e58d8004	 str         r8, [sp, #4]
  00104	e58d4000	 str         r4, [sp]
  00108	e1a0e00f	 mov         lr, pc
  0010c	e12fff15	 bx          r5
  00110	e1b04000	 movs        r4, r0

; 2770 : 
; 2771 :     if (!SD_API_SUCCESS(status)) {
; 2772 :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDIOConnectDisconnectInterrupt: failed to write INT_ENABLE register for function %d \n"),
; 2773 :             m_SDCardInfo.SDIOInformation.Function));                
; 2774 :         m_SDCardInfo.SDIOInformation.pInterruptCallBack = NULL;
; 2775 :     } else {
; 2776 :         if (Connect) {
; 2777 :             DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDIOConnectDisconnectInterrupt: Interrupt enabled for function %d \n"),
; 2778 :                 m_SDCardInfo.SDIOInformation.Function));
; 2779 :         } else {
; 2780 :             DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDIOConnectDisconnectInterrupt: Interrupt disabled for function %d \n"),
; 2781 :                 m_SDCardInfo.SDIOInformation.Function)); 
; 2782 :         }
; 2783 :     }
; 2784 :     device0->DeRef();

  00114	e1a00007	 mov         r0, r7
  00118	458694e8	 strmi       r9, [r6, #0x4E8]
  0011c	eb000000	 bl          |?DeRef@CRefObject@@QAAKXZ|

; 2785 :     
; 2786 :     return status;

  00120		 |$LN15@SDIOConnec|

; 2787 : 
; 2788 : }

  00120	e1a00004	 mov         r0, r4
  00124	e28dd00c	 add         sp, sp, #0xC
  00128	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  0012c	e12fff1e	 bx          lr
  00130		 |$M42602|

			 ENDP  ; |?SDIOConnectDisconnectInterrupt@CSDDevice@@UAAJP6AJPAX0@ZH@Z|, CSDDevice::SDIOConnectDisconnectInterrupt

	EXPORT	|?SwapByte@CSDDevice@@IAAXPAEK@Z|	; CSDDevice::SwapByte

  00000			 AREA	 |.pdata|, PDATA
|$T42618| DCD	|$LN10@SwapByte|
	DCD	0x40001401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SwapByte@CSDDevice@@IAAXPAEK@Z| PROC	; CSDDevice::SwapByte

; 2906 : {

  00000		 |$LN10@SwapByte|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M42615|
  00004	e3510000	 cmp         r1, #0

; 2907 :     ASSERT(pPtr!=NULL);
; 2908 :     ASSERT(dwLength!=0);
; 2909 :     if (pPtr!=NULL && dwLength) {

  00008	0a00000e	 beq         |$LN1@SwapByte|
  0000c	e3520000	 cmp         r2, #0
  00010	0a00000c	 beq         |$LN1@SwapByte|

; 2910 :         DWORD dwLeft = 0;

  00014	e3a04000	 mov         r4, #0

; 2911 :         DWORD dwRight = dwLength-1;

  00018	e2525001	 subs        r5, r2, #1

; 2912 :         while (dwLeft < dwRight) {

  0001c	0a000009	 beq         |$LN1@SwapByte|
  00020		 |$LL2@SwapByte|
  00020	e1a00005	 mov         r0, r5
  00024	e1a0e004	 mov         lr, r4

; 2913 :             BYTE chTemp = *(pPtr + dwRight);

  00028	e7f02001	 ldrb        r2, [r0, +r1]!

; 2914 :             *(pPtr + dwRight) = *(pPtr + dwLeft);

  0002c	e7fe3001	 ldrb        r3, [lr, +r1]!

; 2915 :             *(pPtr + dwLeft) = chTemp;
; 2916 :             dwLeft ++;

  00030	e2844001	 add         r4, r4, #1

; 2917 :             dwRight --;

  00034	e2455001	 sub         r5, r5, #1
  00038	e1540005	 cmp         r4, r5
  0003c	e5c03000	 strb        r3, [r0]
  00040	e5ce2000	 strb        r2, [lr]
  00044	3afffff5	 bcc         |$LL2@SwapByte|
  00048		 |$LN1@SwapByte|

; 2918 :         }
; 2919 :     }
; 2920 : }

  00048	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M42616|

			 ENDP  ; |?SwapByte@CSDDevice@@IAAXPAEK@Z|, CSDDevice::SwapByte

	EXPORT	|??0?$CStaticContainer@VCSDBusRequest@@$0BAA@@@QAA@XZ| ; CStaticContainer<CSDBusRequest,256>::CStaticContainer<CSDBusRequest,256>
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T42634| DCD	|$LN12@CStaticCon|
	DCD	0x40001101
; Function compile flags: /Ogspy
; File c:\wince600\public\common\oak\inc\crefcon.h

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0?$CStaticContainer@VCSDBusRequest@@$0BAA@@@QAA@XZ| PROC ; CStaticContainer<CSDBusRequest,256>::CStaticContainer<CSDBusRequest,256>

; 64   :     CStaticContainer()

  00000		 |$LN12@CStaticCon|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M42631|
  00004	e1a04000	 mov         r4, r0
  00008	eb000000	 bl          InitializeCriticalSection

; 65   :     {
; 66   :         m_dwArraySize = dwNumArray;

  0000c	e3a03c01	 mov         r3, #1, 24
  00010	e5843414	 str         r3, [r4, #0x414]

; 67   :         for( DWORD dwIndex = 0; dwIndex < m_dwArraySize; dwIndex++ )

  00014	e3a02000	 mov         r2, #0
  00018	e1a01004	 mov         r1, r4
  0001c	e3a00000	 mov         r0, #0
  00020		 |$LL3@CStaticCon|

; 68   :         {
; 69   :             m_rgObjectArray[dwIndex] = NULL;

  00020	e5810014	 str         r0, [r1, #0x14]
  00024	e5943414	 ldr         r3, [r4, #0x414]
  00028	e2822001	 add         r2, r2, #1
  0002c	e2811004	 add         r1, r1, #4
  00030	e1520003	 cmp         r2, r3
  00034	3afffff9	 bcc         |$LL3@CStaticCon|

; 70   :         }
; 71   :     }

  00038	e1a00004	 mov         r0, r4
  0003c	e8bd4010	 ldmia       sp!, {r4, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M42632|

			 ENDP  ; |??0?$CStaticContainer@VCSDBusRequest@@$0BAA@@@QAA@XZ|, CStaticContainer<CSDBusRequest,256>::CStaticContainer<CSDBusRequest,256>

	EXPORT	|??1?$CStaticContainer@VCSDBusRequest@@$0BAA@@@QAA@XZ| ; CStaticContainer<CSDBusRequest,256>::~CStaticContainer<CSDBusRequest,256>
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T42659| DCD	|$LN19@CStaticCon@2|
	DCD	0x40001a01
; Function compile flags: /Ogspy
; File c:\wince600\public\common\oak\inc\crefcon.h

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1?$CStaticContainer@VCSDBusRequest@@$0BAA@@@QAA@XZ| PROC ; CStaticContainer<CSDBusRequest,256>::~CStaticContainer<CSDBusRequest,256>

; 73   :     {

  00000		 |$LN19@CStaticCon@2|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M42656|
  00004	e1a04000	 mov         r4, r0

; 74   :         Lock();

  00008	eb000000	 bl          EnterCriticalSection

; 75   :         for( DWORD dwIndex = 0; dwIndex < m_dwArraySize; dwIndex++ )

  0000c	e5943414	 ldr         r3, [r4, #0x414]
  00010	e3a06000	 mov         r6, #0
  00014	e3530000	 cmp         r3, #0
  00018	9a00000c	 bls         |$LN2@CStaticCon@2|

; 74   :         Lock();

  0001c	e1a05004	 mov         r5, r4
  00020		 |$LL4@CStaticCon@2|

; 76   :         {
; 77   :             if( m_rgObjectArray[dwIndex] != NULL )

  00020	e5953014	 ldr         r3, [r5, #0x14]
  00024	e1b00003	 movs        r0, r3

; 78   :             {
; 79   :                 delete m_rgObjectArray[dwIndex];

  00028	15903000	 ldrne       r3, [r0]
  0002c	13a01001	 movne       r1, #1
  00030	15933000	 ldrne       r3, [r3]
  00034	11a0e00f	 movne       lr, pc
  00038	112fff13	 bxne        r3
  0003c	e5943414	 ldr         r3, [r4, #0x414]
  00040	e2866001	 add         r6, r6, #1
  00044	e2855004	 add         r5, r5, #4
  00048	e1560003	 cmp         r6, r3
  0004c	3afffff3	 bcc         |$LL4@CStaticCon@2|
  00050		 |$LN2@CStaticCon@2|

; 80   :             }
; 81   :         };
; 82   :         Unlock();

  00050	e1a00004	 mov         r0, r4
  00054	eb000000	 bl          LeaveCriticalSection

; 83   :     }

  00058	e1a00004	 mov         r0, r4
  0005c	eb000000	 bl          DeleteCriticalSection
  00060	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00064	e12fff1e	 bx          lr
  00068		 |$M42657|

			 ENDP  ; |??1?$CStaticContainer@VCSDBusRequest@@$0BAA@@@QAA@XZ|, CStaticContainer<CSDBusRequest,256>::~CStaticContainer<CSDBusRequest,256>

	EXPORT	|?ObjectIndex@?$CStaticContainer@VCSDBusRequest@@$0BAA@@@QAAPAVCSDBusRequest@@K@Z| ; CStaticContainer<CSDBusRequest,256>::ObjectIndex
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T42682| DCD	|$LN14@ObjectInde|
	DCD	0x40001101
; Function compile flags: /Ogspy
; File c:\wince600\public\common\oak\inc\crefcon.h

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ObjectIndex@?$CStaticContainer@VCSDBusRequest@@$0BAA@@@QAAPAVCSDBusRequest@@K@Z| PROC ; CStaticContainer<CSDBusRequest,256>::ObjectIndex

; 105  :     {

  00000		 |$LN14@ObjectInde|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M42679|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 106  :         Lock();

  0000c	eb000000	 bl          EnterCriticalSection

; 107  :         T*  pReturn = dwIndex <
; 108  :                       m_dwArraySize ?
; 109  :                       m_rgObjectArray[dwIndex] :
; 110  :                       NULL;

  00010	e5953414	 ldr         r3, [r5, #0x414]
  00014	e1540003	 cmp         r4, r3
  00018	30853104	 addcc       r3, r5, r4, lsl #2
  0001c	35934014	 ldrcc       r4, [r3, #0x14]
  00020	23a04000	 movcs       r4, #0

; 111  :         if( pReturn )

  00024	e3540000	 cmp         r4, #0

; 112  :         {
; 113  :             pReturn->AddRef();

  00028	1284007c	 addne       r0, r4, #0x7C
  0002c	1b000000	 blne        InterlockedIncrement

; 114  :         }
; 115  :         Unlock();

  00030	e1a00005	 mov         r0, r5
  00034	eb000000	 bl          LeaveCriticalSection

; 116  :         return pReturn;
; 117  :     }

  00038	e1a00004	 mov         r0, r4
  0003c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M42680|

			 ENDP  ; |?ObjectIndex@?$CStaticContainer@VCSDBusRequest@@$0BAA@@@QAAPAVCSDBusRequest@@K@Z|, CStaticContainer<CSDBusRequest,256>::ObjectIndex

	EXPORT	|?RemoveObjectBy@?$CStaticContainer@VCSDBusRequest@@$0BAA@@@QAAPAVCSDBusRequest@@K@Z| ; CStaticContainer<CSDBusRequest,256>::RemoveObjectBy
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T42700| DCD	|$LN11@RemoveObje|
	DCD	0x40001301
; Function compile flags: /Ogspy
; File c:\wince600\public\common\oak\inc\crefcon.h

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?RemoveObjectBy@?$CStaticContainer@VCSDBusRequest@@$0BAA@@@QAAPAVCSDBusRequest@@K@Z| PROC ; CStaticContainer<CSDBusRequest,256>::RemoveObjectBy

; 119  :     {

  00000		 |$LN11@RemoveObje|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M42697|
  00004	e1a06001	 mov         r6, r1
  00008	e1a05000	 mov         r5, r0

; 120  :         Lock();

  0000c	eb000000	 bl          EnterCriticalSection

; 121  :         T*  pReturn = NULL;
; 122  :         if( dwIndex < m_dwArraySize )

  00010	e5953414	 ldr         r3, [r5, #0x414]
  00014	e3a04000	 mov         r4, #0

; 123  :         {
; 124  :             pReturn = m_rgObjectArray[dwIndex];
; 125  :             m_rgObjectArray[dwIndex] = NULL;
; 126  :         };
; 127  :         Unlock();

  00018	e1a00005	 mov         r0, r5
  0001c	e1560003	 cmp         r6, r3
  00020	30853106	 addcc       r3, r5, r6, lsl #2
  00024	35934014	 ldrcc       r4, [r3, #0x14]
  00028	33a02000	 movcc       r2, #0
  0002c	35832014	 strcc       r2, [r3, #0x14]
  00030	eb000000	 bl          LeaveCriticalSection

; 128  :         if( pReturn )

  00034	e3540000	 cmp         r4, #0

; 129  :         {
; 130  :             pReturn->DeRef();

  00038	11a00004	 movne       r0, r4
  0003c	1b000000	 blne        |?DeRef@CSDBusRequest@@QAAKXZ|

; 131  :         }
; 132  :         return pReturn;
; 133  :     }

  00040	e1a00004	 mov         r0, r4
  00044	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00048	e12fff1e	 bx          lr
  0004c		 |$M42698|

			 ENDP  ; |?RemoveObjectBy@?$CStaticContainer@VCSDBusRequest@@$0BAA@@@QAAPAVCSDBusRequest@@K@Z|, CStaticContainer<CSDBusRequest,256>::RemoveObjectBy

	EXPORT	|?RawObjectIndex@?$CStaticContainer@VCSDBusRequest@@$0BAA@@@QAAPAVCSDBusRequest@@K@Z| ; CStaticContainer<CSDBusRequest,256>::RawObjectIndex

  00000			 AREA	 |.pdata|, PDATA
|$T42713| DCD	|$LN7@RawObjectI|
	DCD	0x40000600
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?RawObjectIndex@?$CStaticContainer@VCSDBusRequest@@$0BAA@@@QAAPAVCSDBusRequest@@K@Z| PROC ; CStaticContainer<CSDBusRequest,256>::RawObjectIndex

; 199  :     {

  00000		 |$LN7@RawObjectI|
  00000		 |$M42710|

; 200  :         // This is only should be usded during suspend & resume.
; 201  :         return ( dwIndex < m_dwArraySize ? m_rgObjectArray[dwIndex] : NULL );

  00000	e5903414	 ldr         r3, [r0, #0x414]
  00004	e1510003	 cmp         r1, r3
  00008	30803101	 addcc       r3, r0, r1, lsl #2
  0000c	35930014	 ldrcc       r0, [r3, #0x14]
  00010	23a00000	 movcs       r0, #0

; 202  :     }

  00014	e12fff1e	 bx          lr
  00018		 |$M42711|

			 ENDP  ; |?RawObjectIndex@?$CStaticContainer@VCSDBusRequest@@$0BAA@@@QAAPAVCSDBusRequest@@K@Z|, CStaticContainer<CSDBusRequest,256>::RawObjectIndex

	EXPORT	|?Open@CReg@@QAAHPAUHKEY__@@PBGK@Z|	; CReg::Open
; File c:\wince600\public\common\sdk\inc\creg.hxx

  00000			 AREA	 |.pdata|, PDATA
|$T42732| DCD	|$LN10@Open|
	DCD	0x40001a02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Open@CReg@@QAAHPAUHKEY__@@PBGK@Z| PROC ; CReg::Open

; 49   : 	BOOL Open(HKEY hkRoot, LPCTSTR pszKey, REGSAM sam=KEY_READ) {

  00000		 |$LN10@Open|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M42729|
  00008	e1a05003	 mov         r5, r3
  0000c	e1a06002	 mov         r6, r2
  00010	e1a07001	 mov         r7, r1
  00014	e1a04000	 mov         r4, r0

; 50   : 		Reset();

  00018	e594e000	 ldr         lr, [r4]
  0001c	e3a08000	 mov         r8, #0
  00020	e35e0000	 cmp         lr, #0
  00024	0a000002	 beq         |$LN5@Open|
  00028	e1a0000e	 mov         r0, lr
  0002c	eb000000	 bl          RegCloseKey
  00030	e5848000	 str         r8, [r4]
  00034		 |$LN5@Open|

; 51   : 		return ERROR_SUCCESS==RegOpenKeyEx(hkRoot, pszKey, 0, sam, &m_hKey);

  00034	e1a03005	 mov         r3, r5
  00038	e3a02000	 mov         r2, #0
  0003c	e1a01006	 mov         r1, r6
  00040	e1a00007	 mov         r0, r7
  00044	e5848004	 str         r8, [r4, #4]
  00048	e58d4000	 str         r4, [sp]
  0004c	eb000000	 bl          RegOpenKeyExW
  00050	e3500000	 cmp         r0, #0
  00054	03a00001	 moveq       r0, #1
  00058	13a00000	 movne       r0, #0

; 52   : 	}

  0005c	e28dd004	 add         sp, sp, #4
  00060	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00064	e12fff1e	 bx          lr
  00068		 |$M42730|

			 ENDP  ; |?Open@CReg@@QAAHPAUHKEY__@@PBGK@Z|, CReg::Open

	EXPORT	|??0CReg@@QAA@PAUHKEY__@@PBG@Z|		; CReg::CReg

  00000			 AREA	 |.pdata|, PDATA
|$T42747| DCD	|$LN7@CReg@2|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CReg@@QAA@PAUHKEY__@@PBG@Z| PROC	; CReg::CReg

; 58   : 	CReg(HKEY hkRoot, LPCTSTR pszKey) {

  00000		 |$LN7@CReg@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M42744|
  00004	e1a04000	 mov         r4, r0
  00008	e3a03802	 mov         r3, #2, 16

; 59   : 		ZeroEntries();
; 60   : 		Open(hkRoot, pszKey);

  0000c	e3a0e000	 mov         lr, #0
  00010	e3833019	 orr         r3, r3, #0x19
  00014	e584e000	 str         lr, [r4]
  00018	e584e004	 str         lr, [r4, #4]
  0001c	e584e008	 str         lr, [r4, #8]
  00020	e584e00c	 str         lr, [r4, #0xC]
  00024	eb000000	 bl          |?Open@CReg@@QAAHPAUHKEY__@@PBGK@Z|

; 61   : 	}

  00028	e1a00004	 mov         r0, r4
  0002c	e8bd4010	 ldmia       sp!, {r4, lr}
  00030	e12fff1e	 bx          lr
  00034		 |$M42745|

			 ENDP  ; |??0CReg@@QAA@PAUHKEY__@@PBG@Z|, CReg::CReg

	EXPORT	|??0CSDDevice@@QAA@KAAVCSDSlot@@@Z|	; CSDDevice::CSDDevice
	EXPORT	|??_7CSDDevice@@6B@| [ DATA ]		; CSDDevice::`vftable'
	EXPORT	|?Detach@CSDDevice@@UAAHXZ|		; CSDDevice::Detach
	EXPORT	|?SDFreeBusRequest_I@CSDDevice@@UAAXPAX@Z| ; CSDDevice::SDFreeBusRequest_I
	EXPORT	|?SDBusRequestResponse_I@CSDDevice@@UAAJPAXPAU_SD_COMMAND_RESPONSE@@@Z| ; CSDDevice::SDBusRequestResponse_I
	EXPORT	|?SDCancelBusRequest_I@CSDDevice@@UAAHPAX@Z| ; CSDDevice::SDCancelBusRequest_I
	IMPORT	|CreateEventW|
	IMPORT	|??_ECSDDevice@@UAAPAXI@Z|, WEAK |??_GCSDDevice@@UAAPAXI@Z| ; CSDDevice::`vector deleting destructor', CSDDevice::`scalar deleting destructor'
	IMPORT	|?SDGetTuple_I@CSDDevice@@UAAJEPAEPAKH@Z| ; CSDDevice::SDGetTuple_I
	IMPORT	|?SDCardInfoQuery_I@CSDDevice@@UAAJW4SD_INFO_TYPE@@PAXK@Z| ; CSDDevice::SDCardInfoQuery_I
; File c:\wince600\public\common\oak\inc\crefcon.h

  00000			 AREA	 |.pdata|, PDATA
|$T42762| DCD	|$LN7@CSDDevice|
	DCD	0x40003a01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7CSDDevice@@6B@| DCD |??_ECSDDevice@@UAAPAXI@Z|	; CSDDevice::`vftable'
	DCD	|?Init@CSDDevice@@UAAHXZ|
	DCD	|?Attach@CSDDevice@@UAAHXZ|
	DCD	|?Detach@CSDDevice@@UAAHXZ|
	DCD	|?SDReadWriteRegistersDirect_I@CSDDevice@@UAAJW4SD_IO_TRANSFER_TYPE@@KEPAEK@Z|
	DCD	|?SDSynchronousBusRequest_I@CSDDevice@@UAAJEKW4SD_TRANSFER_CLASS@@W4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@KKPAEKKPAU__PHYS_BUFF_LIST@@@Z|
	DCD	|?SDBusRequest_I@CSDDevice@@UAAJEKW4SD_TRANSFER_CLASS@@W4_SD_RESPONSE_TYPE@@KKPAEP6AXPAXPAU_SD_BUS_REQUEST@@3K@ZKPAPAXKKPAU__PHYS_BUFF_LIST@@@Z|
	DCD	|?SDFreeBusRequest_I@CSDDevice@@UAAXPAX@Z|
	DCD	|?SDBusRequestResponse_I@CSDDevice@@UAAJPAXPAU_SD_COMMAND_RESPONSE@@@Z|
	DCD	|?SDCancelBusRequest_I@CSDDevice@@UAAHPAX@Z|
	DCD	|?SDIOConnectDisconnectInterrupt@CSDDevice@@UAAJP6AJPAX0@ZH@Z|
	DCD	|?HandleDeviceInterrupt@CSDDevice@@UAAXXZ|
	DCD	|?SDGetTuple_I@CSDDevice@@UAAJEPAEPAKH@Z|
	DCD	|?SDCardInfoQuery_I@CSDDevice@@UAAJW4SD_INFO_TYPE@@PAXK@Z|
	DCD	|?SendSDAppCmd@CSDDevice@@MAAJEKW4SD_TRANSFER_CLASS@@W4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@KKPAE@Z|
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CSDDevice@@QAA@KAAVCSDSlot@@@Z| PROC ; CSDDevice::CSDDevice

; 45   : {

  00000		 |$LN7@CSDDevice|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M42759|
  00004	e1a04002	 mov         r4, r2
  00008	e1a06001	 mov         r6, r1
  0000c	e1a07000	 mov         r7, r0
  00010	e59f30cc	 ldr         r3, [pc, #0xCC]
  00014	e3a08000	 mov         r8, #0
  00018	e2870008	 add         r0, r7, #8
  0001c	e5873000	 str         r3, [r7]
  00020	e5878004	 str         r8, [r7, #4]
  00024	eb000000	 bl          |??0?$CStaticContainer@VCSDBusRequest@@$0BAA@@@QAA@XZ|
  00028	e59f30b0	 ldr         r3, [pc, #0xB0]

; 46   :     m_DeviceType = Device_Unknown;
; 47   :     m_RelativeAddress = 0 ;
; 48   :     m_FuncRef = (DWORD)InterlockedIncrement((LPLONG)&g_FuncRef);

  0002c	e59f00a8	 ldr         r0, [pc, #0xA8]
  00030	e2875b01	 add         r5, r7, #1, 22
  00034	e5873000	 str         r3, [r7]
  00038	e5874438	 str         r4, [r7, #0x438]
  0003c	e587643c	 str         r6, [r7, #0x43C]
  00040	e5878494	 str         r8, [r7, #0x494]
  00044	e1c58ab0	 strh        r8, [r5, #0xA0]
  00048	eb000000	 bl          InterlockedIncrement

; 49   : 
; 50   :     
; 51   :     m_fAttached = FALSE;
; 52   :     m_pDriverFolder = NULL;
; 53   :     
; 54   :     m_hCallbackHandle = NULL;
; 55   :     m_fIsHandleCopied = FALSE;
; 56   :     m_ClientName[0] = 0;
; 57   :     m_ClientFlags = 0;
; 58   :     m_DeviceType=Device_Unknown;
; 59   :     m_pDeviceContext = NULL;
; 60   :     m_pSlotEventCallBack = NULL;
; 61   :     m_RelativeAddress = 0;
; 62   :     m_OperatingVoltage =0 ;
; 63   :     m_pSystemContext = NULL;
; 64   :     // set default access clocks
; 65   :     memset(&m_SDCardInfo,0,sizeof(m_SDCardInfo));

  0004c	e1a02000	 mov         r2, r0
  00050	e2873b01	 add         r3, r7, #1, 22
  00054	e5872440	 str         r2, [r7, #0x440]
  00058	e3a02068	 mov         r2, #0x68
  0005c	e28300d8	 add         r0, r3, #0xD8
  00060	e3a01000	 mov         r1, #0
  00064	e5878444	 str         r8, [r7, #0x444]
  00068	e5878420	 str         r8, [r7, #0x420]
  0006c	e587844c	 str         r8, [r7, #0x44C]
  00070	e5878448	 str         r8, [r7, #0x448]
  00074	e1c585b0	 strh        r8, [r5, #0x50]
  00078	e5878490	 str         r8, [r7, #0x490]
  0007c	e5878494	 str         r8, [r7, #0x494]
  00080	e5878498	 str         r8, [r7, #0x498]
  00084	e587849c	 str         r8, [r7, #0x49C]
  00088	e1c58ab0	 strh        r8, [r5, #0xA0]
  0008c	e58784d0	 str         r8, [r7, #0x4D0]
  00090	e58784d4	 str         r8, [r7, #0x4D4]
  00094	eb000000	 bl          memset

; 66   :     m_SDCardInfo.SDMMCInformation.DataAccessReadClocks = SD_UNSPECIFIED_ACCESS_CLOCKS;

  00098	e3e0e000	 mvn         lr, #0

; 67   :     m_SDCardInfo.SDMMCInformation.DataAccessWriteClocks = SD_UNSPECIFIED_ACCESS_CLOCKS;
; 68   :     m_SDCardInfo.SDIOInformation.Function = (UCHAR)dwFunctionIndex;
; 69   :     m_bCardSelectRequest = FALSE;
; 70   :     m_bCardDeselectRequest = FALSE;
; 71   :     
; 72   :     m_dwCurSearchIndex = 0; 
; 73   :     m_dwCurFunctionGroup = 0 ;
; 74   :     m_hSyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  0009c	e3a03000	 mov         r3, #0
  000a0	e3a02000	 mov         r2, #0
  000a4	e3a01000	 mov         r1, #0
  000a8	e3a00000	 mov         r0, #0
  000ac	e587e52c	 str         lr, [r7, #0x52C]
  000b0	e587e528	 str         lr, [r7, #0x528]
  000b4	e5c764d8	 strb        r6, [r7, #0x4D8]
  000b8	e5878560	 str         r8, [r7, #0x560]
  000bc	e5878564	 str         r8, [r7, #0x564]
  000c0	e5878424	 str         r8, [r7, #0x424]
  000c4	e5878428	 str         r8, [r7, #0x428]
  000c8	eb000000	 bl          CreateEventW
  000cc	e5870434	 str         r0, [r7, #0x434]

; 75   : 
; 76   : }

  000d0	e1a00007	 mov         r0, r7
  000d4	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000d8	e12fff1e	 bx          lr
  000dc		 |$LN8@CSDDevice|
  000dc		 |$LN9@CSDDevice|
  000dc	00000000	 DCD         |?g_FuncRef@CSDDevice@@1KA|
  000e0		 |$LN10@CSDDevice|
  000e0	00000000	 DCD         |??_7CSDDevice@@6B@|
  000e4		 |$LN11@CSDDevice|
  000e4	00000000	 DCD         |??_7CRefObject@@6B@|
  000e8		 |$M42760|

			 ENDP  ; |??0CSDDevice@@QAA@KAAVCSDSlot@@@Z|, CSDDevice::CSDDevice

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?GetCardRegisters@CSDDevice@@QAAJXZ|	; CSDDevice::GetCardRegisters
	IMPORT	|?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|	; CSDDevice::GetBitSlice

  00000			 AREA	 |.pdata|, PDATA
|$T42827| DCD	|$LN61@GetCardReg|
	DCD	0xc000bf02

  00000			 AREA	 |.xdata|, DATA
|$T42823| DCD	0xffffffe0
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T42823|

  00008		 |?GetCardRegisters@CSDDevice@@QAAJXZ| PROC ; CSDDevice::GetCardRegisters

; 303  : {

  00008		 |$LN61@GetCardReg|
  00008	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  0000c	e24dd038	 sub         sp, sp, #0x38
  00010		 |$M42824|
  00010	e1a07000	 mov         r7, r0
  00014	e59f32e4	 ldr         r3, [pc, #0x2E4]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3034	 str         r3, [sp, #0x34]

; 304  :     if (m_FuncionIndex!=0) {

  00020	e597343c	 ldr         r3, [r7, #0x43C]
  00024	e3530000	 cmp         r3, #0
  00028	0a000003	 beq         |$LN21@GetCardReg|

; 305  :         ASSERT(FALSE);
; 306  :         return SD_API_STATUS_DEVICE_UNSUPPORTED;

  0002c	e59d0034	 ldr         r0, [sp, #0x34]
  00030	eb000000	 bl          __security_check_cookie
  00034	e3a0415f	 mov         r4, #0x5F, 2
  00038	ea0000ac	 b           |$LN22@GetCardReg|
  0003c		 |$LN21@GetCardReg|

; 307  :     }
; 308  :     SD_API_STATUS               status = SD_API_STATUS_DEVICE_UNSUPPORTED;    // status
; 309  :     SD_COMMAND_RESPONSE         response;  // response
; 310  :     UCHAR                       scrReg[SD_SCR_REGISTER_SIZE]; // temporary buffer
; 311  :     USHORT                      oidValue;  // oid value
; 312  :     SD_CARD_STATUS              cardStatus; // card status
; 313  : 
; 314  :     // must get CID first in order to get the cards into the IDENT state.
; 315  :     // Check for SD I/O - only cards; will not have  CID.
; 316  :     if (Device_SD_IO != m_DeviceType) {

  0003c	e5973494	 ldr         r3, [r7, #0x494]
  00040	e3530003	 cmp         r3, #3
  00044	0a000010	 beq         |$LN24@GetCardReg|

; 317  :         DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("CSDDevice:  Getting registers from slot %d \n"), m_sdSlot.GetSlotIndex())); 
; 318  :         
; 319  :         // for MMC, SD Memory and SD Combo cards, retreive the CID
; 320  :         status = SendSDCommand(SD_CMD_ALL_SEND_CID,0x00000000,ResponseR2,&response);

  00048	e28d3014	 add         r3, sp, #0x14
  0004c	e58d3000	 str         r3, [sp]
  00050	e3a03003	 mov         r3, #3
  00054	e3a02000	 mov         r2, #0
  00058	e3a01002	 mov         r1, #2
  0005c	e1a00007	 mov         r0, r7
  00060	eb000000	 bl          |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|
  00064	e1b04000	 movs        r4, r0

; 321  : 
; 322  :         if (!SD_API_SUCCESS(status)){

  00068	5a000002	 bpl         |$LN19@GetCardReg|
  0006c		 |$LN58@GetCardReg|

; 323  :             return status;

  0006c	e59d0034	 ldr         r0, [sp, #0x34]
  00070	eb000000	 bl          __security_check_cookie
  00074	ea00009d	 b           |$LN22@GetCardReg|
  00078		 |$LN19@GetCardReg|

; 324  :         }
; 325  : 
; 326  :         DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("CSDDevice: Got CID from device in slot %d \n"), m_sdSlot.GetSlotIndex())); 
; 327  :         // update shadow registers
; 328  :         UpdateCachedRegisterFromResponse( SD_INFO_REGISTER_CID, &response);

  00078	e2873b01	 add         r3, r7, #1, 22
  0007c	e28300a6	 add         r0, r3, #0xA6
  00080	e28d1018	 add         r1, sp, #0x18
  00084	e3a02010	 mov         r2, #0x10
  00088	eb000000	 bl          memcpy
  0008c		 |$LN24@GetCardReg|

; 329  :     }
; 330  : 
; 331  :     // fetch/set the RCA
; 332  :     if (Device_MMC != m_DeviceType) {

  0008c	e5973494	 ldr         r3, [r7, #0x494]
  00090	e3a09001	 mov         r9, #1
  00094	e3530001	 cmp         r3, #1
  00098	0a00000e	 beq         |$LN18@GetCardReg|

; 333  :         DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("CSDDevice: Getting RCA from SD card in  slot %d .... \n"),m_sdSlot.GetSlotIndex())); 
; 334  :         // get the RCA
; 335  :         status = SendSDCommand(SD_CMD_SEND_RELATIVE_ADDR, 0x00000000,ResponseR6,&response);

  0009c	e28d3014	 add         r3, sp, #0x14
  000a0	e58d3000	 str         r3, [sp]
  000a4	e3a03007	 mov         r3, #7
  000a8	e3a02000	 mov         r2, #0
  000ac	e3a01003	 mov         r1, #3
  000b0	e1a00007	 mov         r0, r7
  000b4	eb000000	 bl          |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|
  000b8	e1b04000	 movs        r4, r0

; 336  : 
; 337  :         if (!SD_API_SUCCESS(status)){
; 338  :             return status;

  000bc	4affffea	 bmi         |$LN58@GetCardReg|

; 339  :         }
; 340  :         // update shadow registers
; 341  :         UpdateCachedRegisterFromResponse(SD_INFO_REGISTER_RCA, &response);

  000c0	e5dd101c	 ldrb        r1, [sp, #0x1C]
  000c4	e5dd301b	 ldrb        r3, [sp, #0x1B]
  000c8	e2872b01	 add         r2, r7, #1, 22
  000cc	e1833401	 orr         r3, r3, r1, lsl #8
  000d0	e1c23ab0	 strh        r3, [r2, #0xA0]

; 342  : 
; 343  :         DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("CSDDevice: Got RCA (0x%04X) from SD card in slot %d \n"), 
; 344  :             m_RelativeAddress, m_sdSlot.GetSlotIndex())); 
; 345  :     } else {

  000d4	ea000016	 b           |$LN14@GetCardReg|
  000d8		 |$LN18@GetCardReg|

; 346  :         // get OEM ID from the CID
; 347  :         oidValue = m_CachedRegisters.CID[SD_CID_OID_OFFSET];
; 348  :         oidValue |= (((USHORT)m_CachedRegisters.CID[SD_CID_OID_OFFSET + 1]) << 8);
; 349  : 
; 350  :         // for MMC cards set the RCA
; 351  :         // take the unique OEM ID and add the slot number to it to form a system unique address
; 352  :         m_RelativeAddress = (SD_CARD_RCA)(oidValue + m_sdSlot.GetSlotIndex());

  000d8	e5973438	 ldr         r3, [r7, #0x438]
  000dc	e5d704b4	 ldrb        r0, [r7, #0x4B4]
  000e0	e5d724b3	 ldrb        r2, [r7, #0x4B3]
  000e4	e5931080	 ldr         r1, [r3, #0x80]
  000e8	e287eb01	 add         lr, r7, #1, 22
  000ec	e1823400	 orr         r3, r2, r0, lsl #8
  000f0	e0833001	 add         r3, r3, r1
  000f4	e1a03803	 mov         r3, r3, lsl #16
  000f8	e1b03823	 movs        r3, r3, lsr #16
  000fc	e1ce3ab0	 strh        r3, [lr, #0xA0]

; 353  : 
; 354  :         // add 1 if this is zero
; 355  :         if (m_RelativeAddress == 0) {
; 356  :             m_RelativeAddress++;

  00100	02873b01	 addeq       r3, r7, #1, 22
  00104	01c39ab0	 streqh      r9, [r3, #0xA0]

; 357  :         }
; 358  :         // for MMC cards, we must set the RCA
; 359  :         DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("CSDDevice: Setting MMC RCA to 0x%04X .... \n"), m_RelativeAddress)); 
; 360  : 
; 361  :         // set the RCA
; 362  :         status = SendSDCommand(SD_CMD_MMC_SET_RCA,((DWORD)m_RelativeAddress) << 16, ResponseR1,&response);

  00108	e2873b01	 add         r3, r7, #1, 22
  0010c	e1d32ab0	 ldrh        r2, [r3, #0xA0]
  00110	e28de014	 add         lr, sp, #0x14
  00114	e3a03001	 mov         r3, #1
  00118	e1a02802	 mov         r2, r2, lsl #16
  0011c	e3a01003	 mov         r1, #3
  00120	e1a00007	 mov         r0, r7
  00124	e58de000	 str         lr, [sp]
  00128	eb000000	 bl          |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|
  0012c	e1b04000	 movs        r4, r0

; 363  : 
; 364  :         if (!SD_API_SUCCESS(status)){
; 365  :             return status;

  00130	4affffcd	 bmi         |$LN58@GetCardReg|
  00134		 |$LN14@GetCardReg|

; 366  :         }
; 367  : 
; 368  :         DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("CSDDevice: RCA set for MMC device in slot %d \n"), m_sdSlot.GetSlotIndex())); 
; 369  :     }
; 370  : 
; 371  :     // now that the RCA has been fetched/set, we can move on to do other things.........
; 372  : 
; 373  :     // check for SD I/O - Only cards. They will not have a CSD or card status
; 374  :     if (Device_SD_IO != m_DeviceType) {

  00134	e5973494	 ldr         r3, [r7, #0x494]
  00138	e3530003	 cmp         r3, #3
  0013c	0a000036	 beq         |$LN10@GetCardReg|

; 375  :         DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("CSDDevice: Getting CSD in slot %d .... \n"), m_sdSlot.GetSlotIndex())); 
; 376  : 
; 377  :         // get the CSD
; 378  :         status = SendSDCommand(SD_CMD_SEND_CSD,
; 379  :             ((DWORD)m_RelativeAddress) << 16,
; 380  :             ResponseR2,
; 381  :             &response);

  00140	e2873b01	 add         r3, r7, #1, 22
  00144	e1d32ab0	 ldrh        r2, [r3, #0xA0]
  00148	e28de014	 add         lr, sp, #0x14
  0014c	e3a03003	 mov         r3, #3
  00150	e1a02802	 mov         r2, r2, lsl #16
  00154	e3a01009	 mov         r1, #9
  00158	e1a00007	 mov         r0, r7
  0015c	e58de000	 str         lr, [sp]
  00160	eb000000	 bl          |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|
  00164	e1b04000	 movs        r4, r0

; 382  : 
; 383  :         if (!SD_API_SUCCESS(status)){
; 384  :             return status;

  00168	4affffbf	 bmi         |$LN58@GetCardReg|

; 385  :         }
; 386  : 
; 387  :         // update shadow registers
; 388  :         UpdateCachedRegisterFromResponse(SD_INFO_REGISTER_CSD, &response);

  0016c	e2874b01	 add         r4, r7, #1, 22
  00170	e28400b6	 add         r0, r4, #0xB6
  00174	e28d1018	 add         r1, sp, #0x18
  00178	e3a02010	 mov         r2, #0x10
  0017c	eb000000	 bl          memcpy

; 389  : 		
; 390  : 		// MMC card will contain its spec version in CSD register
; 391  : 		// even if this is SD card, read it anyways
; 392  : 		m_dwSpecVers = (DWORD)GetBitSlice(m_CachedRegisters.CSD, SD_CSD_REGISTER_SIZE, MMC_CSD_SPEC_VERS_BIT_SLICE, MMC_CSD_SPEC_VERS_SLICE_SIZE);

  00180	e3a03004	 mov         r3, #4
  00184	e58d3000	 str         r3, [sp]
  00188	e3a0307a	 mov         r3, #0x7A
  0018c	e3a02010	 mov         r2, #0x10
  00190	e28410b6	 add         r1, r4, #0xB6
  00194	e1a00007	 mov         r0, r7
  00198	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|

; 393  : 
; 394  :         DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("CSDDevice: Got CSD from device in slot %d \n"), m_sdSlot.GetSlotIndex())); 
; 395  :         // get the card status
; 396  :         status = SendSDCommand( SD_CMD_SEND_STATUS,((DWORD)m_RelativeAddress) << 16,ResponseR1, &response);

  0019c	e1d43ab0	 ldrh        r3, [r4, #0xA0]
  001a0	e1a0e000	 mov         lr, r0
  001a4	e28d4014	 add         r4, sp, #0x14
  001a8	e1a02803	 mov         r2, r3, lsl #16
  001ac	e3a03001	 mov         r3, #1
  001b0	e3a0100d	 mov         r1, #0xD
  001b4	e1a00007	 mov         r0, r7
  001b8	e587e42c	 str         lr, [r7, #0x42C]
  001bc	e58d4000	 str         r4, [sp]
  001c0	eb000000	 bl          |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|
  001c4	e1b04000	 movs        r4, r0

; 397  :         if (!SD_API_SUCCESS(status)){
; 398  :             return status;

  001c8	4affffa7	 bmi         |$LN58@GetCardReg|

; 399  :         }
; 400  : 
; 401  : 
; 402  :         SDGetCardStatusFromResponse(&response, &cardStatus);
; 403  : 
; 404  :         if (cardStatus & SD_STATUS_CARD_IS_LOCKED) {

  001cc	e5dd201d	 ldrb        r2, [sp, #0x1D]
  001d0	e5dd301c	 ldrb        r3, [sp, #0x1C]
  001d4	e5dd101e	 ldrb        r1, [sp, #0x1E]
  001d8	e5dd001f	 ldrb        r0, [sp, #0x1F]
  001dc	e5dd5019	 ldrb        r5, [sp, #0x19]
  001e0	e1833402	 orr         r3, r3, r2, lsl #8
  001e4	e5dd2018	 ldrb        r2, [sp, #0x18]
  001e8	e5dde01a	 ldrb        lr, [sp, #0x1A]
  001ec	e1833801	 orr         r3, r3, r1, lsl #16
  001f0	e5dd401b	 ldrb        r4, [sp, #0x1B]
  001f4	e1833c00	 orr         r3, r3, r0, lsl #24
  001f8	e1822405	 orr         r2, r2, r5, lsl #8
  001fc	e1a03c03	 mov         r3, r3, lsl #24
  00200	e182280e	 orr         r2, r2, lr, lsl #16
  00204	e1a01c23	 mov         r1, r3, lsr #24
  00208	e1823c04	 orr         r3, r2, r4, lsl #24
  0020c	e1a03423	 mov         r3, r3, lsr #8
  00210	e1833c01	 orr         r3, r3, r1, lsl #24
  00214	e3130402	 tst         r3, #2, 8

; 405  :             DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("CSDDevice: card in slot %d is locked\n"), m_sdSlot.GetSlotIndex())); 
; 406  :             m_SDCardInfo.SDMMCInformation.CardIsLocked = TRUE;

  00218	15879530	 strne       r9, [r7, #0x530]
  0021c		 |$LN10@GetCardReg|

; 407  :         }
; 408  : 
; 409  :     }
; 410  : 
; 411  :     // now in order to get the SCR register we must be in the trans state
; 412  :     // also in order to do a few other things, so lets select the card now and leave it
; 413  :     // selected
; 414  :     // send CMD 7 to select the card and keep it selected, this is required  for SDIO cards
; 415  :     // too as mentioned in I/O working group newsgroup
; 416  :     status = SendSDCommand( SD_CMD_SELECT_DESELECT_CARD,((DWORD)m_RelativeAddress) << 16, ResponseR1b, &response);

  0021c	e2873b01	 add         r3, r7, #1, 22
  00220	e1d32ab0	 ldrh        r2, [r3, #0xA0]
  00224	e28de014	 add         lr, sp, #0x14
  00228	e3a03002	 mov         r3, #2
  0022c	e1a02802	 mov         r2, r2, lsl #16
  00230	e3a01007	 mov         r1, #7
  00234	e1a00007	 mov         r0, r7
  00238	e58de000	 str         lr, [sp]
  0023c	eb000000	 bl          |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|
  00240	e1b04000	 movs        r4, r0

; 417  : 
; 418  :     if (!SD_API_SUCCESS(status)){
; 419  :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("CSDDevice: Failed to select card in slot %d \n"), m_sdSlot.GetSlotIndex()));     
; 420  :         return status;

  00244	4affff88	 bmi         |$LN58@GetCardReg|

; 421  :     }
; 422  : 
; 423  :     DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("CSDDevice:Card in slot %d is now selected \n"), m_sdSlot.GetSlotIndex())); 
; 424  : 
; 425  :     // only SD Memory and Combo cards have an SCR
; 426  :     if ((Device_SD_Memory == m_DeviceType) || (Device_SD_Combo == m_DeviceType)) {

  00248	e5973494	 ldr         r3, [r7, #0x494]
  0024c	e3530002	 cmp         r3, #2
  00250	0a000001	 beq         |$LN7@GetCardReg|
  00254	e3530004	 cmp         r3, #4
  00258	1a000021	 bne         |$LN1@GetCardReg|
  0025c		 |$LN7@GetCardReg|

; 427  :         // if the card is unlocked, get the SCR
; 428  :         if (!m_SDCardInfo.SDMMCInformation.CardIsLocked) {

  0025c	e5973530	 ldr         r3, [r7, #0x530]
  00260	e3530000	 cmp         r3, #0
  00264	1a00001e	 bne         |$LN1@GetCardReg|

; 429  :             // get the SD Configuration register
; 430  :             status = SendSDAppCmd(SD_ACMD_SEND_SCR, 0, SD_READ,  ResponseR1,&response,
; 431  :                 1,                    // 1 block
; 432  :                 SD_SCR_REGISTER_SIZE, // 64 bits
; 433  :                 scrReg);
; 434  : 
; 435  :             // If the memory card is locked then the SCR becomes inaccessable. If we fail
; 436  :             // to read the SCR then just set up the cached SCR register to default to
; 437  :             // a 1bit access mode.
; 438  : 
; 439  :             if (!SD_API_SUCCESS(status)){

  00268	e5973000	 ldr         r3, [r7]
  0026c	e28d402c	 add         r4, sp, #0x2C
  00270	e3a08008	 mov         r8, #8
  00274	e5936038	 ldr         r6, [r3, #0x38]
  00278	e28d5014	 add         r5, sp, #0x14
  0027c	e3a03000	 mov         r3, #0
  00280	e3a02000	 mov         r2, #0
  00284	e3a01033	 mov         r1, #0x33
  00288	e1a00007	 mov         r0, r7
  0028c	e58d4010	 str         r4, [sp, #0x10]
  00290	e58d800c	 str         r8, [sp, #0xC]
  00294	e58d9008	 str         r9, [sp, #8]
  00298	e58d5004	 str         r5, [sp, #4]
  0029c	e58d9000	 str         r9, [sp]
  002a0	e1a0e00f	 mov         lr, pc
  002a4	e12fff16	 bx          r6
  002a8	e3500000	 cmp         r0, #0

; 440  :                 DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("CSDDevice: Failed to get SCR from device in slot %d \n"), m_sdSlot.GetSlotIndex()));
; 441  :                 memset(m_CachedRegisters.SCR, 0, sizeof(m_CachedRegisters.SCR));

  002ac	e3a01000	 mov         r1, #0
  002b0	5a000004	 bpl         |$LN5@GetCardReg|
  002b4	e2873b01	 add         r3, r7, #1, 22
  002b8	e28300c6	 add         r0, r3, #0xC6
  002bc	e3a02008	 mov         r2, #8
  002c0	eb000000	 bl          memset

; 442  :             } else {            

  002c4	ea000006	 b           |$LN1@GetCardReg|
  002c8		 |$LN5@GetCardReg|

; 443  :                 // this is a spec discrepency, since the SCR register is not associated with 
; 444  :                 // an address, the byte order it ambiguous.  All the cards we have seen store the data 
; 445  :                 // most significant byte first as it arrives.  
; 446  :                 for (ULONG ii = 0 ; ii < sizeof(m_CachedRegisters.SCR); ii++) {

  002c8	e28d0033	 add         r0, sp, #0x33
  002cc		 |$LL3@GetCardReg|

; 447  :                     m_CachedRegisters.SCR[ii] = scrReg[(SD_SCR_REGISTER_SIZE - 1) - ii];

  002cc	e4502001	 ldrb        r2, [r0], #-1
  002d0	e0873001	 add         r3, r7, r1
  002d4	e2811001	 add         r1, r1, #1
  002d8	e3510008	 cmp         r1, #8
  002dc	e5c324c6	 strb        r2, [r3, #0x4C6]
  002e0	3afffff9	 bcc         |$LL3@GetCardReg|
  002e4		 |$LN1@GetCardReg|

; 448  :                 }
; 449  : 
; 450  :                 DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDBusDriver: Got SCR from device in slot %d \n"), m_sdSlot.GetSlotIndex()));     
; 451  :             }
; 452  :         }
; 453  :     }
; 454  : 
; 455  :     return SD_API_STATUS_SUCCESS;

  002e4	e59d0034	 ldr         r0, [sp, #0x34]
  002e8	eb000000	 bl          __security_check_cookie
  002ec	e3a04000	 mov         r4, #0
  002f0		 |$LN22@GetCardReg|

; 456  : }

  002f0	e1a00004	 mov         r0, r4
  002f4	e28dd038	 add         sp, sp, #0x38
  002f8	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  002fc	e12fff1e	 bx          lr
  00300		 |$LN62@GetCardReg|
  00300		 |$LN63@GetCardReg|
  00300	00000000	 DCD         |__security_cookie|
  00304		 |$M42825|

			 ENDP  ; |?GetCardRegisters@CSDDevice@@QAAJXZ|, CSDDevice::GetCardRegisters

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?HandleDeviceSelectDeselect@CSDDevice@@QAAJW4_SD_SLOT_EVENT@@H@Z| ; CSDDevice::HandleDeviceSelectDeselect

  00000			 AREA	 |.pdata|, PDATA
|$T42861| DCD	|$LN43@HandleDevi@2|
	DCD	0xc000d702

  00000			 AREA	 |.xdata|, DATA
|$T42857| DCD	0xffffffd8
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T42857|

  00008		 |?HandleDeviceSelectDeselect@CSDDevice@@QAAJW4_SD_SLOT_EVENT@@H@Z| PROC ; CSDDevice::HandleDeviceSelectDeselect

; 458  : {

  00008		 |$LN43@HandleDevi@2|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd040	 sub         sp, sp, #0x40
  00010		 |$M42858|
  00010	e1a07000	 mov         r7, r0
  00014	e59f3344	 ldr         r3, [pc, #0x344]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d303c	 str         r3, [sp, #0x3C]

; 459  :     SD_API_STATUS          status = SD_API_STATUS_SUCCESS;
; 460  :     UCHAR                  regValue;
; 461  :     SD_COMMAND_RESPONSE    response;
; 462  :     DbgPrintZo(SDBUS_ZONE_DEVICE, (TEXT("CSDDevice: HandleSlotSelectDeselect++: %d \n"),SlotEvent));
; 463  :     BOOL fSDIO = FALSE;
; 464  :     BOOL fSDMemory = FALSE;
; 465  :     
; 466  :     if (m_DeviceType ==Device_SD_IO ||  m_DeviceType == Device_SD_Combo ) {

  00020	e5973494	 ldr         r3, [r7, #0x494]
  00024	e3a04000	 mov         r4, #0
  00028	e3a00000	 mov         r0, #0
  0002c	e3530003	 cmp         r3, #3
  00030	e3a09000	 mov         r9, #0
  00034	0a000001	 beq         |$LN30@HandleDevi@2|
  00038	e3530004	 cmp         r3, #4
  0003c	1a000000	 bne         |$LN31@HandleDevi@2|
  00040		 |$LN30@HandleDevi@2|

; 467  :         fSDIO = TRUE;

  00040	e3a00001	 mov         r0, #1
  00044		 |$LN31@HandleDevi@2|

; 468  :     }
; 469  :     if ((m_DeviceType == Device_MMC) || (m_DeviceType == Device_SD_Memory) ||(m_DeviceType == Device_SD_Combo)) { 

  00044	e3530001	 cmp         r3, #1
  00048	0a000003	 beq         |$LN28@HandleDevi@2|
  0004c	e3530002	 cmp         r3, #2
  00050	0a000001	 beq         |$LN28@HandleDevi@2|
  00054	e3530004	 cmp         r3, #4
  00058	1a000000	 bne         |$LN29@HandleDevi@2|
  0005c		 |$LN28@HandleDevi@2|

; 470  :         fSDMemory = TRUE;

  0005c	e3a09001	 mov         r9, #1
  00060		 |$LN29@HandleDevi@2|

; 471  :     }
; 472  : 
; 473  :     if (fSelect) {

  00060	e3520000	 cmp         r2, #0
  00064	0a000083	 beq         |$LN27@HandleDevi@2|

; 474  :         if (m_FuncionIndex == 0 ) {

  00068	e597343c	 ldr         r3, [r7, #0x43C]
  0006c	e3530000	 cmp         r3, #0
  00070	1a00006c	 bne         |$LN26@HandleDevi@2|

; 475  :             // Select I/O controller first
; 476  :             if (fSDIO) {

  00074	e3a08000	 mov         r8, #0
  00078	e3a0a008	 mov         r10, #8
  0007c	e3500000	 cmp         r0, #0
  00080	0a000030	 beq         |$LN21@HandleDevi@2|

; 477  :                 if ( m_sdSlot.GetSlotState()!= SlotDeselected ) {

  00084	e5973438	 ldr         r3, [r7, #0x438]
  00088	e5933084	 ldr         r3, [r3, #0x84]
  0008c	e3530005	 cmp         r3, #5
  00090	0a000019	 beq         |$LN40@HandleDevi@2|

; 478  :                     // reset I/O controller 
; 479  :                     regValue = SD_IO_REG_IO_ABORT_RES;
; 480  :                     status = SDSynchronousBusRequest_I(SD_IO_RW_DIRECT,
; 481  :                         BUILD_IO_RW_DIRECT_ARG((UCHAR)SD_IO_WRITE,FALSE,0,(SD_IO_REG_IO_ABORT),SD_IO_REG_IO_ABORT_RES),
; 482  :                         SD_COMMAND,ResponseR5,&response,0,0,NULL,(DWORD)SD_SLOTRESET_REQUEST); 
; 483  :                     m_RelativeAddress = 0;

  00094	e1a06007	 mov         r6, r7
  00098	e4963400	 ldr         r3, [r6], #0x400
  0009c	e3a0a008	 mov         r10, #8
  000a0	e5cda020	 strb        r10, [sp, #0x20]
  000a4	e3a02122	 mov         r2, #0x22, 2
  000a8	e5935014	 ldr         r5, [r3, #0x14]
  000ac	e28d4024	 add         r4, sp, #0x24
  000b0	e3a0b006	 mov         r11, #6
  000b4	e3a0a008	 mov         r10, #8
  000b8	e3a03002	 mov         r3, #2
  000bc	e3822b03	 orr         r2, r2, #3, 22
  000c0	e3a01034	 mov         r1, #0x34
  000c4	e1a00007	 mov         r0, r7
  000c8	e58d801c	 str         r8, [sp, #0x1C]
  000cc	e58d8018	 str         r8, [sp, #0x18]
  000d0	e58da014	 str         r10, [sp, #0x14]
  000d4	e58d8010	 str         r8, [sp, #0x10]
  000d8	e58d800c	 str         r8, [sp, #0xC]
  000dc	e58d8008	 str         r8, [sp, #8]
  000e0	e58d4004	 str         r4, [sp, #4]
  000e4	e58db000	 str         r11, [sp]
  000e8	e1a0e00f	 mov         lr, pc
  000ec	e12fff15	 bx          r5
  000f0	e1b04000	 movs        r4, r0
  000f4	e1c68ab0	 strh        r8, [r6, #0xA0]

; 484  :                 }
; 485  : 
; 486  :                 // Query OCR
; 487  :                 if (SD_API_SUCCESS(status)) {

  000f8	4a000012	 bmi         |$LN21@HandleDevi@2|
  000fc		 |$LN40@HandleDevi@2|

; 488  :                     status = SendSDCommand(SD_CMD_IO_OP_COND,0,ResponseR4,&response);

  000fc	e28d3024	 add         r3, sp, #0x24
  00100	e58d3000	 str         r3, [sp]
  00104	e3a03005	 mov         r3, #5
  00108	e3a02000	 mov         r2, #0
  0010c	e3a01005	 mov         r1, #5
  00110	e1a00007	 mov         r0, r7
  00114	eb000000	 bl          |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|
  00118	e1b04000	 movs        r4, r0

; 489  :                 }
; 490  : 
; 491  :                 // Re-init I/O controller by powering it up
; 492  :                 if (SD_API_SUCCESS(status)) {

  0011c	4a000009	 bmi         |$LN21@HandleDevi@2|

; 493  :                     status = SetCardPower(Device_SD_IO,m_OperatingVoltage,FALSE);

  00120	e59724d0	 ldr         r2, [r7, #0x4D0]
  00124	e3a03000	 mov         r3, #0
  00128	e3a01003	 mov         r1, #3
  0012c	e1a00007	 mov         r0, r7
  00130	eb000000	 bl          |?SetCardPower@CSDDevice@@IAAJW4_SDCARD_DEVICE_TYPE@@KH@Z|
  00134	e1b04000	 movs        r4, r0

; 494  :                 }
; 495  : 
; 496  :                 if (SD_API_SUCCESS(status)) {

  00138	4a000002	 bmi         |$LN21@HandleDevi@2|

; 497  :                     status = GetCardRegisters();

  0013c	e1a00007	 mov         r0, r7
  00140	eb000000	 bl          |?GetCardRegisters@CSDDevice@@QAAJXZ|
  00144	e1a04000	 mov         r4, r0
  00148		 |$LN21@HandleDevi@2|

; 498  :                 }
; 499  :                 else {
; 500  :                     DbgPrintZo(SDCARD_ZONE_ERROR, (TEXT("CSDSlot: Failed to power up SDIO card \n")));  
; 501  :                 }
; 502  :             }
; 503  :             if (fSDMemory) {

  00148	e3590000	 cmp         r9, #0
  0014c	0a00007d	 beq         |$LN8@HandleDevi@2|

; 504  : 
; 505  :                 status = SDSynchronousBusRequest_I(SD_CMD_GO_IDLE_STATE,0x00000000,SD_COMMAND,NoResponse,
; 506  :                         NULL,0,0,NULL,(DWORD)SD_SLOTRESET_REQUEST);

  00150	e5971000	 ldr         r1, [r7]
  00154	e3a03002	 mov         r3, #2
  00158	e3a02000	 mov         r2, #0
  0015c	e5914014	 ldr         r4, [r1, #0x14]
  00160	e3a01000	 mov         r1, #0
  00164	e1a00007	 mov         r0, r7
  00168	e58d801c	 str         r8, [sp, #0x1C]
  0016c	e58d8018	 str         r8, [sp, #0x18]
  00170	e58da014	 str         r10, [sp, #0x14]
  00174	e58d8010	 str         r8, [sp, #0x10]
  00178	e58d800c	 str         r8, [sp, #0xC]
  0017c	e58d8008	 str         r8, [sp, #8]
  00180	e58d8004	 str         r8, [sp, #4]
  00184	e58d8000	 str         r8, [sp]
  00188	e1a0e00f	 mov         lr, pc
  0018c	e12fff14	 bx          r4
  00190	e1b04000	 movs        r4, r0

; 507  : 
; 508  :                 if (SD_API_SUCCESS(status)) {

  00194	4a00006b	 bmi         |$LN8@HandleDevi@2|

; 509  :                     m_RelativeAddress = 0;
; 510  :                 }
; 511  :                 else{
; 512  :                     DbgPrintZo(SDCARD_ZONE_ERROR,
; 513  :                         (TEXT("CSDSlot: Go Idle Failed during selection: Status: 0x%08X on slot:%d \n"),status,m_sdSlot.GetSlotIndex()));
; 514  :                 }
; 515  :                 if (SD_API_SUCCESS(status)) { 
; 516  :                     if ((m_DeviceType == Device_SD_Memory) || (m_DeviceType == Device_SD_Combo)) {

  00198	e5972494	 ldr         r2, [r7, #0x494]
  0019c	e2873b01	 add         r3, r7, #1, 22
  001a0	e1c38ab0	 strh        r8, [r3, #0xA0]
  001a4	e3520002	 cmp         r2, #2
  001a8	0a000001	 beq         |$LN14@HandleDevi@2|
  001ac	e3520004	 cmp         r2, #4
  001b0	1a00000f	 bne         |$LN15@HandleDevi@2|
  001b4		 |$LN14@HandleDevi@2|

; 517  :                         status = SendSDAppCommand(SD_ACMD_SD_SEND_OP_COND,0,ResponseR3,&response);

  001b4	e5973000	 ldr         r3, [r7]
  001b8	e28d4024	 add         r4, sp, #0x24
  001bc	e3a06004	 mov         r6, #4
  001c0	e5935038	 ldr         r5, [r3, #0x38]
  001c4	e3a03002	 mov         r3, #2
  001c8	e3a02000	 mov         r2, #0
  001cc	e3a01029	 mov         r1, #0x29
  001d0	e1a00007	 mov         r0, r7
  001d4	e58d8010	 str         r8, [sp, #0x10]
  001d8	e58d800c	 str         r8, [sp, #0xC]
  001dc	e58d8008	 str         r8, [sp, #8]
  001e0	e58d4004	 str         r4, [sp, #4]
  001e4	e58d6000	 str         r6, [sp]
  001e8	e1a0e00f	 mov         lr, pc
  001ec	e12fff15	 bx          r5
  001f0	e1a04000	 mov         r4, r0
  001f4		 |$LN15@HandleDevi@2|

; 518  :                     }
; 519  :                 }
; 520  :                 // Should I send CMD1 for MMC card here????  TODO!!!
; 521  : 
; 522  :                 // Now it is ready to re-initialize memory controller.
; 523  :                 // Re-initialize memory controller by powering it up
; 524  :                 // SetCardPower will send CMD0 first before issuing ACMD41
; 525  :                 if (SD_API_SUCCESS(status)) { 

  001f4	e3540000	 cmp         r4, #0
  001f8	4a000052	 bmi         |$LN8@HandleDevi@2|

; 526  :                     status = SetCardPower(m_DeviceType, m_OperatingVoltage,FALSE);

  001fc	e59724d0	 ldr         r2, [r7, #0x4D0]
  00200	e5971494	 ldr         r1, [r7, #0x494]
  00204	e3a03000	 mov         r3, #0
  00208	e1a00007	 mov         r0, r7
  0020c	eb000000	 bl          |?SetCardPower@CSDDevice@@IAAJW4_SDCARD_DEVICE_TYPE@@KH@Z|
  00210	e1b04000	 movs        r4, r0

; 527  :                 }
; 528  :                 // For SD Memory, GetCardRegisters will do the following things:
; 529  :                 //  Issue CMD2 to make memory state trans to IDENT
; 530  :                 //  Issue CMD3 to get or set RCA
; 531  :                 //  Issue CMD7 to select the card again
; 532  :                 //  For SD Memory card, additional ACMD51 would be issued too, but
; 533  :                 //  should not have impact for init process.
; 534  :                 if (SD_API_SUCCESS(status)) { 

  00214	4a00004b	 bmi         |$LN8@HandleDevi@2|

; 535  :                     status = GetCardRegisters();

  00218	e1a00007	 mov         r0, r7
  0021c	eb000000	 bl          |?GetCardRegisters@CSDDevice@@QAAJXZ|
  00220	e1a04000	 mov         r4, r0

; 536  :                 }
; 537  :             }
; 538  :         }
; 539  :         else {

  00224	ea000047	 b           |$LN8@HandleDevi@2|
  00228		 |$LN26@HandleDevi@2|

; 540  :             CSDDevice * pDevice0 = m_sdSlot.GetFunctionDevice(0);

  00228	e5970438	 ldr         r0, [r7, #0x438]
  0022c	e3a01000	 mov         r1, #0
  00230	eb000000	 bl          |?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z|
  00234	e1b05000	 movs        r5, r0

; 541  :             if (pDevice0) {

  00238	0a000042	 beq         |$LN8@HandleDevi@2|

; 542  :                 CopyContentFromParent(*pDevice0);

  0023c	e2853b01	 add         r3, r5, #1, 22
  00240	e1d32ab0	 ldrh        r2, [r3, #0xA0]
  00244	e2873b01	 add         r3, r7, #1, 22
  00248	e2871b01	 add         r1, r7, #1, 22
  0024c	e1c32ab0	 strh        r2, [r3, #0xA0]
  00250	e59534d0	 ldr         r3, [r5, #0x4D0]
  00254	e2852b01	 add         r2, r5, #1, 22
  00258	e28100a2	 add         r0, r1, #0xA2
  0025c	e28210a2	 add         r1, r2, #0xA2
  00260	e3a0202c	 mov         r2, #0x2C
  00264	e58734d0	 str         r3, [r7, #0x4D0]
  00268	eb000000	 bl          memcpy

; 543  :                 pDevice0->DeRef();

  0026c	e1a00005	 mov         r0, r5
  00270	eb000000	 bl          |?DeRef@CRefObject@@QAAKXZ|

; 544  :             }
; 545  :         }
; 546  :     }
; 547  :     else {// De select Card.

  00274	ea000033	 b           |$LN8@HandleDevi@2|
  00278		 |$LN27@HandleDevi@2|

; 548  :         if ((SlotEvent == SlotResetRequest) || (SlotEvent == SlotDeselectRequest)) {

  00278	e3510007	 cmp         r1, #7
  0027c	0a000001	 beq         |$LN7@HandleDevi@2|
  00280	e3510005	 cmp         r1, #5
  00284	1a00002f	 bne         |$LN8@HandleDevi@2|
  00288		 |$LN7@HandleDevi@2|

; 549  :             DbgPrintZo(SDBUS_ZONE_DEVICE, (TEXT("CSDSlot: Deselect the card\n")));
; 550  :             
; 551  :             if (m_FuncionIndex == 0 ) {

  00288	e597343c	 ldr         r3, [r7, #0x43C]
  0028c	e3a08000	 mov         r8, #0
  00290	e3530000	 cmp         r3, #0
  00294	1a000028	 bne         |$LN1@HandleDevi@2|

; 552  :                 // deselect I/O controller first, see SDIO Spec v1.1 Section 3.4.4
; 553  :                 if (fSDIO) {

  00298	e3500000	 cmp         r0, #0
  0029c	0a000010	 beq         |$LN4@HandleDevi@2|

; 554  :                     regValue = SD_IO_REG_IO_ABORT_RES;
; 555  :                     status = SDReadWriteRegistersDirect_I(SD_IO_WRITE,SD_IO_REG_IO_ABORT,FALSE,&regValue,1);

  002a0	e5973000	 ldr         r3, [r7]
  002a4	e3a06008	 mov         r6, #8
  002a8	e3a0a001	 mov         r10, #1
  002ac	e5935010	 ldr         r5, [r3, #0x10]
  002b0	e28d4020	 add         r4, sp, #0x20
  002b4	e3a03000	 mov         r3, #0
  002b8	e3a02006	 mov         r2, #6
  002bc	e3a01001	 mov         r1, #1
  002c0	e1a00007	 mov         r0, r7
  002c4	e5cd6020	 strb        r6, [sp, #0x20]
  002c8	e58da004	 str         r10, [sp, #4]
  002cc	e58d4000	 str         r4, [sp]
  002d0	e1a0e00f	 mov         lr, pc
  002d4	e12fff15	 bx          r5
  002d8	e1b04000	 movs        r4, r0

; 556  :                     if (SD_API_SUCCESS(status))  {
; 557  :                         // TODO, should CCCRShadowIntEnable to be updated???
; 558  :                         m_SDCardInfo.SDIOInformation.pCommonInformation->CCCRShadowIOEnable = 0;

  002dc	559734ec	 ldrpl       r3, [r7, #0x4EC]
  002e0	55c38011	 strplb      r8, [r3, #0x11]
  002e4		 |$LN4@HandleDevi@2|

; 559  :                     }
; 560  :                     else {
; 561  :                         DbgPrintZo(SDCARD_ZONE_ERROR, (TEXT("SDBusDriver: Failed to deselect SDIO card \n")));  
; 562  :                     }
; 563  :                 }
; 564  :                 if (fSDMemory && SD_API_SUCCESS(status)) {

  002e4	e3590000	 cmp         r9, #0
  002e8	0a000013	 beq         |$LN1@HandleDevi@2|
  002ec	e3540000	 cmp         r4, #0
  002f0	4a000011	 bmi         |$LN1@HandleDevi@2|

; 565  :                     status = SDSynchronousBusRequest_I(SD_CMD_GO_IDLE_STATE,
; 566  :                         0x00000000,SD_COMMAND,NoResponse,NULL,0,0,NULL,(DWORD)SD_SLOTRESET_REQUEST);

  002f4	e5972000	 ldr         r2, [r7]
  002f8	e3a05008	 mov         r5, #8
  002fc	e3a03002	 mov         r3, #2
  00300	e5924014	 ldr         r4, [r2, #0x14]
  00304	e3a02000	 mov         r2, #0
  00308	e3a01000	 mov         r1, #0
  0030c	e1a00007	 mov         r0, r7
  00310	e58d801c	 str         r8, [sp, #0x1C]
  00314	e58d8018	 str         r8, [sp, #0x18]
  00318	e58d5014	 str         r5, [sp, #0x14]
  0031c	e58d8010	 str         r8, [sp, #0x10]
  00320	e58d800c	 str         r8, [sp, #0xC]
  00324	e58d8008	 str         r8, [sp, #8]
  00328	e58d8004	 str         r8, [sp, #4]
  0032c	e58d8000	 str         r8, [sp]
  00330	e1a0e00f	 mov         lr, pc
  00334	e12fff14	 bx          r4
  00338	e1a04000	 mov         r4, r0
  0033c		 |$LN1@HandleDevi@2|

; 567  :                     if (SD_API_SUCCESS(status))  {
; 568  :                         DbgPrintZo(SDCARD_ZONE_ERROR,(TEXT("CSDSlot: Go Idle Failed during deselection: Status: 0x%08X \n"),
; 569  :                             status));
; 570  :                     }
; 571  : 
; 572  :                 }
; 573  :             }
; 574  :             m_RelativeAddress = 0;

  0033c	e2873b01	 add         r3, r7, #1, 22
  00340	e1c38ab0	 strh        r8, [r3, #0xA0]

; 575  :             m_bCardDeselectRequest = FALSE;

  00344	e5878564	 str         r8, [r7, #0x564]
  00348		 |$LN8@HandleDevi@2|

; 576  :         }
; 577  :     }
; 578  :     return status;

  00348	e59d003c	 ldr         r0, [sp, #0x3C]
  0034c	eb000000	 bl          __security_check_cookie

; 579  : }

  00350	e1a00004	 mov         r0, r4
  00354	e28dd040	 add         sp, sp, #0x40
  00358	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0035c	e12fff1e	 bx          lr
  00360		 |$LN44@HandleDevi@2|
  00360		 |$LN45@HandleDevi@2|
  00360	00000000	 DCD         |__security_cookie|
  00364		 |$M42859|

			 ENDP  ; |?HandleDeviceSelectDeselect@CSDDevice@@QAAJW4_SD_SLOT_EVENT@@H@Z|, CSDDevice::HandleDeviceSelectDeselect

	EXPORT	|?SetOperationVoltage@CSDDevice@@QAAJW4_SDCARD_DEVICE_TYPE@@H@Z| ; CSDDevice::SetOperationVoltage
	IMPORT	|?SDGetOperationalVoltageRange@CSDSlot@@IAAKK@Z| ; CSDSlot::SDGetOperationalVoltageRange

  00000			 AREA	 |.pdata|, PDATA
|$T42879| DCD	|$LN14@SetOperati|
	DCD	0x40002502
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetOperationVoltage@CSDDevice@@QAAJW4_SDCARD_DEVICE_TYPE@@H@Z| PROC ; CSDDevice::SetOperationVoltage

; 712  : {

  00000		 |$LN14@SetOperati|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M42876|
  00008	e1b06002	 movs        r6, r2
  0000c	e1a07001	 mov         r7, r1
  00010	e1a04000	 mov         r4, r0

; 713  :     SD_API_STATUS status = SD_API_STATUS_DEVICE_UNSUPPORTED;

  00014	e3a0515f	 mov         r5, #0x5F, 2

; 714  :     if (SetHCPower) {

  00018	0a000011	 beq         |$LN8@SetOperati|

; 715  :         DWORD ocrValue;
; 716  :         ASSERT(m_FuncionIndex == 0 );
; 717  :         if (m_DeviceType == Device_SD_Memory || m_DeviceType == Device_MMC) {

  0001c	e5943494	 ldr         r3, [r4, #0x494]
  00020	e3530002	 cmp         r3, #2
  00024	0a000005	 beq         |$LN6@SetOperati|
  00028	e3530001	 cmp         r3, #1
  0002c	0a000003	 beq         |$LN6@SetOperati|

; 721  :         }
; 722  :         else if (m_DeviceType == Device_SD_IO || m_DeviceType == Device_SD_Combo) {

  00030	e3530003	 cmp         r3, #3
  00034	13530004	 cmpne       r3, #4
  00038	159d1000	 ldrne       r1, [sp]
  0003c	1a000005	 bne         |$LN4@SetOperati|
  00040		 |$LN6@SetOperati|

; 718  :             ocrValue = (DWORD)m_CachedRegisters.OCR[0] & ~0xF;
; 719  :             ocrValue |= ((DWORD)m_CachedRegisters.OCR[1]) << 8;  
; 720  :             ocrValue |= ((DWORD)m_CachedRegisters.OCR[2]) << 16; 

  00040	e5d424a4	 ldrb        r2, [r4, #0x4A4]
  00044	e5d434a3	 ldrb        r3, [r4, #0x4A3]
  00048	e5d414a2	 ldrb        r1, [r4, #0x4A2]
  0004c	e1832402	 orr         r2, r3, r2, lsl #8
  00050	e3c1300f	 bic         r3, r1, #0xF
  00054	e1831402	 orr         r1, r3, r2, lsl #8
  00058		 |$LN4@SetOperati|

; 723  :             ocrValue = (DWORD)m_CachedRegisters.IO_OCR[0] & ~0xF;
; 724  :             ocrValue |= ((DWORD)m_CachedRegisters.IO_OCR[1]) << 8; 
; 725  :             ocrValue |= ((DWORD)m_CachedRegisters.IO_OCR[2]) << 16;
; 726  :         }
; 727  :         else 
; 728  :             ASSERT(FALSE);
; 729  :         m_OperatingVoltage = m_sdSlot.SDGetOperationalVoltageRange(ocrValue);

  00058	e5940438	 ldr         r0, [r4, #0x438]
  0005c	eb000000	 bl          |?SDGetOperationalVoltageRange@CSDSlot@@IAAKK@Z|
  00060	e58404d0	 str         r0, [r4, #0x4D0]
  00064		 |$LN8@SetOperati|

; 730  :     }
; 731  :     // check to see if the voltages can be supported
; 732  :     if (0 != m_OperatingVoltage ) {

  00064	e59434d0	 ldr         r3, [r4, #0x4D0]
  00068	e1b02003	 movs        r2, r3
  0006c	0a000004	 beq         |$LN1@SetOperati|

; 733  : 
; 734  :         // power up the card
; 735  :         status = SetCardPower(DeviceType, m_OperatingVoltage, SetHCPower);

  00070	e1a03006	 mov         r3, r6
  00074	e1a01007	 mov         r1, r7
  00078	e1a00004	 mov         r0, r4
  0007c	eb000000	 bl          |?SetCardPower@CSDDevice@@IAAJW4_SDCARD_DEVICE_TYPE@@KH@Z|
  00080	e1a05000	 mov         r5, r0
  00084		 |$LN1@SetOperati|

; 736  :     }
; 737  :     return status;
; 738  : 
; 739  : }

  00084	e1a00005	 mov         r0, r5
  00088	e28dd004	 add         sp, sp, #4
  0008c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$M42877|

			 ENDP  ; |?SetOperationVoltage@CSDDevice@@QAAJW4_SDCARD_DEVICE_TYPE@@H@Z|, CSDDevice::SetOperationVoltage

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?GetInterfaceOverrides@CSDDevice@@IAAXXZ| ; CSDDevice::GetInterfaceOverrides
	EXPORT	|??_C@_1CI@MGGPKLHN@?$AAS?$AAD?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@GEDDMCFF@?$AAS?$AAD?$AAC?$AAl?$AAo?$AAc?$AAk?$AAR?$AAa?$AAt?$AAe?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd?$AAe?$AA?$AA@| [ DATA ] ; `string'
; File c:\wince600\public\common\sdk\inc\creg.hxx

  00000			 AREA	 |.pdata|, PDATA
|$T42917| DCD	|$LN26@GetInterfa@3|
	DCD	0xc0004002

  00000			 AREA	 |.xdata|, DATA
|$T42913| DCD	0xffffffe8

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@MGGPKLHN@?$AAS?$AAD?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd?$AAe?$AA?$AA@| DCB "S"
	DCB	0x0, "D", 0x0, "I", 0x0, "n", 0x0, "t", 0x0, "e", 0x0, "r"
	DCB	0x0, "f", 0x0, "a", 0x0, "c", 0x0, "e", 0x0, "O", 0x0, "v"
	DCB	0x0, "e", 0x0, "r", 0x0, "r", 0x0, "i", 0x0, "d", 0x0, "e"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@GEDDMCFF@?$AAS?$AAD?$AAC?$AAl?$AAo?$AAc?$AAk?$AAR?$AAa?$AAt?$AAe?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd?$AAe?$AA?$AA@| DCB "S"
	DCB	0x0, "D", 0x0, "C", 0x0, "l", 0x0, "o", 0x0, "c", 0x0, "k"
	DCB	0x0, "R", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, "O", 0x0, "v"
	DCB	0x0, "e", 0x0, "r", 0x0, "r", 0x0, "i", 0x0, "d", 0x0, "e"
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T42913|

  00008		 |?GetInterfaceOverrides@CSDDevice@@IAAXXZ| PROC ; CSDDevice::GetInterfaceOverrides

; 1295 : {

  00008		 |$LN26@GetInterfa@3|
  00008	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  0000c	e24ddf85	 sub         sp, sp, #0x85, 30
  00010		 |$M42914|
  00010	e1a04000	 mov         r4, r0
  00014	e59f30e8	 ldr         r3, [pc, #0xE8]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3210	 str         r3, [sp, #0x210]

; 1296 :     WCHAR regPath[MAX_KEY_PATH_LENGTH]; // regpath
; 1297 :     DWORD clockRate;                    // clockrate override
; 1298 :     DWORD interfaceMode;                // interface mode override
; 1299 : 
; 1300 :     // get the card registry path
; 1301 :     if (!SD_API_SUCCESS(GetCustomRegPath(regPath, dim(regPath), TRUE))) {

  00020	e3a03001	 mov         r3, #1
  00024	e3a02c01	 mov         r2, #1, 24
  00028	e28d1010	 add         r1, sp, #0x10
  0002c	eb000000	 bl          |?GetCustomRegPath@CSDDevice@@IAAJPAGKH@Z|
  00030	e3500000	 cmp         r0, #0
  00034	4a00002b	 bmi         |$LN18@GetInterfa@3|
  00038	e3a03802	 mov         r3, #2, 16

; 1302 :         return;
; 1303 :     }
; 1304 : 
; 1305 :     CReg regDevice(HKEY_LOCAL_MACHINE, regPath);

  0003c	e3a0e000	 mov         lr, #0
  00040	e3a05000	 mov         r5, #0
  00044	e3a06000	 mov         r6, #0
  00048	e3a07000	 mov         r7, #0
  0004c	e3833019	 orr         r3, r3, #0x19
  00050	e28d2010	 add         r2, sp, #0x10
  00054	e3a0110a	 mov         r1, #0xA, 2
  00058	e28d0000	 add         r0, sp, #0
  0005c	e58de000	 str         lr, [sp]
  00060	e58d5004	 str         r5, [sp, #4]
  00064	e58d6008	 str         r6, [sp, #8]
  00068	e58d700c	 str         r7, [sp, #0xC]
  0006c	eb000000	 bl          |?Open@CReg@@QAAHPAUHKEY__@@PBGK@Z|

; 1306 :     if (regDevice.IsOK()) {

  00070	e59d3000	 ldr         r3, [sp]
  00074	e3530000	 cmp         r3, #0
  00078	0a000017	 beq         |$LN19@GetInterfa@3|

; 1307 :         // check for clock rate override
; 1308 :         clockRate = regDevice.ValueDW(SDCARD_CLOCK_RATE_OVERRIDE, -1);

  0007c	e59f107c	 ldr         r1, [pc, #0x7C]
  00080	e3e02000	 mvn         r2, #0
  00084	e28d0000	 add         r0, sp, #0
  00088	eb000000	 bl          |?ValueDW@CReg@@QAAKPBGK@Z|

; 1309 :         if (clockRate != -1) {
; 1310 :             DEBUGMSG(SDCARD_ZONE_WARN, (TEXT("SDBusDriver: RegPath: %s overrides clock rate to : %d\n"),
; 1311 :                  regPath,clockRate));
; 1312 :             m_CardInterfaceEx.ClockRate = clockRate;
; 1313 :         }
; 1314 :     
; 1315 :         // check for interface mode override
; 1316 :         interfaceMode = regDevice.ValueDW(SDCARD_INTERFACE_MODE_OVERRIDE, -1);

  0008c	e59f1068	 ldr         r1, [pc, #0x68]
  00090	e3700001	 cmn         r0, #1
  00094	15840544	 strne       r0, [r4, #0x544]
  00098	e28d0000	 add         r0, sp, #0
  0009c	e3e02000	 mvn         r2, #0
  000a0	eb000000	 bl          |?ValueDW@CReg@@QAAKPBGK@Z|

; 1317 :         if (interfaceMode != -1) {

  000a4	e3700001	 cmn         r0, #1
  000a8	0a000008	 beq         |$LN1@GetInterfa@3|

; 1318 :             if (interfaceMode == SDCARD_INTERFACE_OVERRIDE_1BIT) {

  000ac	e3500000	 cmp         r0, #0

; 1319 :                 m_CardInterfaceEx.InterfaceModeEx.bit.sd4Bit = 0 ;

  000b0	05943540	 ldreq       r3, [r4, #0x540]
  000b4	03c33001	 biceq       r3, r3, #1
  000b8	0a000003	 beq         |$LN23@GetInterfa@3|

; 1320 :                 DEBUGMSG(SDCARD_ZONE_WARN, (TEXT("SDBusDriver: RegPath: %s overrides interface mode to 1 bit \n"),regPath));
; 1321 :             } else if (interfaceMode == SDCARD_INTERFACE_OVERRIDE_4BIT) {

  000bc	e3500001	 cmp         r0, #1
  000c0	1a000002	 bne         |$LN1@GetInterfa@3|

; 1322 :                 m_CardInterfaceEx.InterfaceModeEx.bit.sd4Bit = 1;

  000c4	e5943540	 ldr         r3, [r4, #0x540]
  000c8	e3833001	 orr         r3, r3, #1
  000cc		 |$LN23@GetInterfa@3|
  000cc	e5843540	 str         r3, [r4, #0x540]
  000d0		 |$LN1@GetInterfa@3|

; 1323 :                 DEBUGMSG(SDCARD_ZONE_WARN, (TEXT("SDBusDriver: RegPath: %s overrides interface mode to 4 bit \n"),regPath));
; 1324 :             }
; 1325 :         }
; 1326 :     }
; 1327 : }

  000d0	e59d0000	 ldr         r0, [sp]
  000d4	e3500000	 cmp         r0, #0
  000d8	1b000000	 blne        RegCloseKey
  000dc		 |$LN19@GetInterfa@3|
  000dc	e59d0008	 ldr         r0, [sp, #8]
  000e0	e3500000	 cmp         r0, #0
  000e4	1b000000	 blne        LocalFree
  000e8		 |$LN18@GetInterfa@3|
  000e8	e59d0210	 ldr         r0, [sp, #0x210]
  000ec	eb000000	 bl          __security_check_cookie
  000f0	e28ddf85	 add         sp, sp, #0x85, 30
  000f4	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000f8	e12fff1e	 bx          lr
  000fc		 |$LN27@GetInterfa@3|
  000fc		 |$LN28@GetInterfa@3|
  000fc	00000000	 DCD         |??_C@_1CI@MGGPKLHN@?$AAS?$AAD?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd?$AAe?$AA?$AA@|
  00100		 |$LN29@GetInterfa@3|
  00100	00000000	 DCD         |??_C@_1CI@GEDDMCFF@?$AAS?$AAD?$AAC?$AAl?$AAo?$AAc?$AAk?$AAR?$AAa?$AAt?$AAe?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd?$AAe?$AA?$AA@|
  00104		 |$LN30@GetInterfa@3|
  00104	00000000	 DCD         |__security_cookie|
  00108		 |$M42915|

			 ENDP  ; |?GetInterfaceOverrides@CSDDevice@@IAAXXZ|, CSDDevice::GetInterfaceOverrides

	EXPORT	|?SDUnloadDevice@CSDDevice@@QAAHXZ|	; CSDDevice::SDUnloadDevice
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T42943| DCD	|$LN13@SDUnloadDe|
	DCD	0x40001c01
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDUnloadDevice@CSDDevice@@QAAHXZ| PROC ; CSDDevice::SDUnloadDevice

; 1605 : {

  00000		 |$LN13@SDUnloadDe|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M42940|
  00004	e1a04000	 mov         r4, r0

; 1606 :     // notify the client
; 1607 :     BOOL fResult = FALSE;
; 1608 :     NotifyClient( SDCardEjected);

  00008	e3a01001	 mov         r1, #1
  0000c	e3a05000	 mov         r5, #0
  00010	eb000000	 bl          |?NotifyClient@CSDDevice@@QAAXW4_SD_SLOT_EVENT_TYPE@@@Z|

; 1609 :     CSDHostContainer * pHostContainer = CSDHostContainer::GetHostContainer();

  00014	e59f3050	 ldr         r3, [pc, #0x50]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e1b06003	 movs        r6, r3

; 1610 :     if (pHostContainer) {

  00020	0a00000e	 beq         |$LN9@SDUnloadDe|

; 1611 :         Lock();

  00024	e2840008	 add         r0, r4, #8
  00028	eb000000	 bl          EnterCriticalSection

; 1612 :         if (m_pDriverFolder ) {

  0002c	e5943420	 ldr         r3, [r4, #0x420]
  00030	e1b01003	 movs        r1, r3
  00034	0a000007	 beq         |$LN1@SDUnloadDe|

; 1613 :             fResult = pHostContainer->RemoveChildByFolder(m_pDriverFolder);

  00038	e5963000	 ldr         r3, [r6]
  0003c	e1a00006	 mov         r0, r6
  00040	e593304c	 ldr         r3, [r3, #0x4C]
  00044	e1a0e00f	 mov         lr, pc
  00048	e12fff13	 bx          r3

; 1614 :             ASSERT(fResult);
; 1615 :             m_pDriverFolder = NULL;

  0004c	e3a03000	 mov         r3, #0
  00050	e5843420	 str         r3, [r4, #0x420]
  00054	e1a05000	 mov         r5, r0
  00058		 |$LN1@SDUnloadDe|

; 1616 :         }
; 1617 :         Unlock();

  00058	e2840008	 add         r0, r4, #8
  0005c	eb000000	 bl          LeaveCriticalSection
  00060		 |$LN9@SDUnloadDe|

; 1618 :     };
; 1619 :     DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDUnloadDevice: Client Device deleted \n")));
; 1620 :     return fResult;
; 1621 : }

  00060	e1a00005	 mov         r0, r5
  00064	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00068	e12fff1e	 bx          lr
  0006c		 |$LN14@SDUnloadDe|
  0006c		 |$LN15@SDUnloadDe|
  0006c	00000000	 DCD         |?g_pSdContainer@CSDHostContainer@@0PAV1@A|
  00070		 |$M42941|

			 ENDP  ; |?SDUnloadDevice@CSDDevice@@QAAHXZ|, CSDDevice::SDUnloadDevice

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?SDGetSDIOPnpInformation@CSDDevice@@QAAJAAV1@@Z| ; CSDDevice::SDGetSDIOPnpInformation
	EXPORT	|??_C@_1DC@GIMPIHDB@?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAo?$AAf?$AA?5?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAT?$AAy?$AAp?$AAe?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EO@GLAKDDC@?$AAM?$AAa?$AAn?$AAu?$AAf?$AAa?$AAc?$AAt?$AAu?$AAr?$AAe?$AAr?$AA?5?$AAI?$AAD?$AA?3?$AA0?$AAx?$AA?$CF?$AA0?$AA4?$AAX?$AA?0?$AA?5?$AAC?$AAa?$AAr?$AAd?$AA?5?$AAI?$AAD?$AA?3@| [ DATA ] ; `string'
	IMPORT	|?SDGetFunctionPowerControlTuples@CSDDevice@@IAAJXZ| ; CSDDevice::SDGetFunctionPowerControlTuples
	IMPORT	|swprintf|
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdslot.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T42991| DCD	|$LN39@SDGetSDIOP|
	DCD	0xc0015f02

  00000			 AREA	 |.xdata|, DATA
|$T42987| DCD	0xffffffe0

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DC@GIMPIHDB@?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAo?$AAf?$AA?5?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAT?$AAy?$AAp?$AAe?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?$AA@| DCB "D"
	DCB	0x0, "e", 0x0, "v", 0x0, "i", 0x0, "c", 0x0, "e", 0x0, " "
	DCB	0x0, "o", 0x0, "f", 0x0, " ", 0x0, "C", 0x0, "l", 0x0, "a"
	DCB	0x0, "s", 0x0, "s", 0x0, " ", 0x0, "T", 0x0, "y", 0x0, "p"
	DCB	0x0, "e", 0x0, ":", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EO@GLAKDDC@?$AAM?$AAa?$AAn?$AAu?$AAf?$AAa?$AAc?$AAt?$AAu?$AAr?$AAe?$AAr?$AA?5?$AAI?$AAD?$AA?3?$AA0?$AAx?$AA?$CF?$AA0?$AA4?$AAX?$AA?0?$AA?5?$AAC?$AAa?$AAr?$AAd?$AA?5?$AAI?$AAD?$AA?3@| DCB "M"
	DCB	0x0, "a", 0x0, "n", 0x0, "u", 0x0, "f", 0x0, "a", 0x0, "c"
	DCB	0x0, "t", 0x0, "u", 0x0, "r", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "I", 0x0, "D", 0x0, ":", 0x0, "0", 0x0, "x", 0x0, "%"
	DCB	0x0, "0", 0x0, "4", 0x0, "X", 0x0, ",", 0x0, " ", 0x0, "C"
	DCB	0x0, "a", 0x0, "r", 0x0, "d", 0x0, " ", 0x0, "I", 0x0, "D"
	DCB	0x0, ":", 0x0, "0", 0x0, "x", 0x0, "%", 0x0, "0", 0x0, "4"
	DCB	0x0, "X", 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T42987|

  00008		 |?SDGetSDIOPnpInformation@CSDDevice@@QAAJAAV1@@Z| PROC ; CSDDevice::SDGetSDIOPnpInformation

; 1714 : {

  00008		 |$LN39@SDGetSDIOP|
  00008	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  0000c	e24dd020	 sub         sp, sp, #0x20
  00010		 |$M42988|
  00010	e1a06001	 mov         r6, r1
  00014	e1a07000	 mov         r7, r0
  00018	e59f3560	 ldr         r3, [pc, #0x560]
  0001c	e5933000	 ldr         r3, [r3]
  00020	e58d301c	 str         r3, [sp, #0x1C]

; 1715 : 
; 1716 :     SD_API_STATUS          status;           // intermediate status
; 1717 :     UCHAR                  regValue[4];      // most tuples are 4 bytes
; 1718 :     UCHAR                  CSA_CISBuffer[CIS_CSA_BYTES]; // CIS and CSA are in contiguous locations
; 1719 :     DWORD                  FBROffset;        // calculated FBR offset
; 1720 :     DWORD                  manFid;           // manufacturer ID
; 1721 :     ULONG                  length;           // buffer length
; 1722 :     BOOL                   found;            // CIS found flag
; 1723 :     PCHAR                  pVersionBuffer;   // tuple buffer for vers1 info
; 1724 : 
; 1725 :     status = SD_API_STATUS_SUCCESS;
; 1726 :     ASSERT(m_SDCardInfo.SDIOInformation.pFunctionInformation == NULL);
; 1727 :     ASSERT(m_SDCardInfo.SDIOInformation.pCommonInformation == NULL);
; 1728 :     
; 1729 :     // allocate the common information
; 1730 :     ASSERT(m_SDCardInfo.SDIOInformation.pCommonInformation == NULL);
; 1731 :     m_SDCardInfo.SDIOInformation.pCommonInformation = new SDIO_COMMON_INFORMATION;

  00024	e3a0001c	 mov         r0, #0x1C
  00028	e3a04000	 mov         r4, #0
  0002c	eb000000	 bl          |??2@YAPAXI@Z|
  00030	e3500000	 cmp         r0, #0
  00034	e58704ec	 str         r0, [r7, #0x4EC]

; 1732 : 
; 1733 :     if (NULL == m_SDCardInfo.SDIOInformation.pCommonInformation) {

  00038	1a000003	 bne         |$LN29@SDGetSDIOP|
  0003c		 |$LN36@SDGetSDIOP|

; 1734 :         return SD_API_STATUS_INSUFFICIENT_RESOURCES;

  0003c	e59d001c	 ldr         r0, [sp, #0x1C]
  00040	eb000000	 bl          __security_check_cookie
  00044	e3a0413b	 mov         r4, #0x3B, 2
  00048	ea000146	 b           |$LN30@SDGetSDIOP|
  0004c		 |$LN29@SDGetSDIOP|

; 1735 :     }
; 1736 :     memset(m_SDCardInfo.SDIOInformation.pCommonInformation, 0, sizeof(SDIO_COMMON_INFORMATION));

  0004c	e3a0201c	 mov         r2, #0x1C
  00050	e3a01000	 mov         r1, #0
  00054	eb000000	 bl          memset

; 1737 :     
; 1738 :     if ((Device_SD_IO == m_DeviceType) || (Device_SD_Combo == m_DeviceType)) {

  00058	e5973494	 ldr         r3, [r7, #0x494]
  0005c	e3530003	 cmp         r3, #3
  00060	0a000001	 beq         |$LN27@SDGetSDIOP|
  00064	e3530004	 cmp         r3, #4
  00068	1a00013c	 bne         |$LN7@SDGetSDIOP|
  0006c		 |$LN27@SDGetSDIOP|

; 1739 :         // for the parent device save the common information
; 1740 :         if (m_FuncionIndex == 0 ) { // Function zero is parent.

  0006c	e597343c	 ldr         r3, [r7, #0x43C]

; 1741 : 
; 1742 : 
; 1743 :             // get the CCCR
; 1744 :             status = SDReadWriteRegistersDirect_I(SD_IO_READ, SD_IO_REG_CCCR,FALSE,regValue,1); 

  00070	e28d5008	 add         r5, sp, #8
  00074	e3a08001	 mov         r8, #1
  00078	e3530000	 cmp         r3, #0
  0007c	e3a01000	 mov         r1, #0
  00080	1a0000d1	 bne         |$LN26@SDGetSDIOP|
  00084	e5973000	 ldr         r3, [r7]
  00088	e3a02000	 mov         r2, #0
  0008c	e1a00007	 mov         r0, r7
  00090	e5934010	 ldr         r4, [r3, #0x10]
  00094	e3a03000	 mov         r3, #0
  00098	e58d8004	 str         r8, [sp, #4]
  0009c	e58d5000	 str         r5, [sp]
  000a0	e1a0e00f	 mov         lr, pc
  000a4	e12fff14	 bx          r4
  000a8	e1b04000	 movs        r4, r0

; 1745 : 
; 1746 :             if (!SD_API_SUCCESS(status)) {
; 1747 :                 DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDBusDriver: Failed to get CCCR \n")));
; 1748 :                 return status;

  000ac	4a00012b	 bmi         |$LN7@SDGetSDIOP|

; 1749 :             }
; 1750 : 
; 1751 :             m_SDCardInfo.SDIOInformation.pCommonInformation->CCCRRev = regValue[0];

  000b0	e59714ec	 ldr         r1, [r7, #0x4EC]
  000b4	e5dd2008	 ldrb        r2, [sp, #8]

; 1752 : 
; 1753 :             // get the card capabilities register
; 1754 :             status = SDReadWriteRegistersDirect_I( SD_IO_READ, SD_IO_REG_CARD_CAPABILITY, FALSE, regValue,1); 

  000b8	e28d5008	 add         r5, sp, #8
  000bc	e3a03000	 mov         r3, #0
  000c0	e5c12000	 strb        r2, [r1]
  000c4	e5970000	 ldr         r0, [r7]
  000c8	e3a02008	 mov         r2, #8
  000cc	e3a01000	 mov         r1, #0
  000d0	e5904010	 ldr         r4, [r0, #0x10]
  000d4	e1a00007	 mov         r0, r7
  000d8	e58d8004	 str         r8, [sp, #4]
  000dc	e58d5000	 str         r5, [sp]
  000e0	e1a0e00f	 mov         lr, pc
  000e4	e12fff14	 bx          r4
  000e8	e1b04000	 movs        r4, r0

; 1755 : 
; 1756 :             if (!SD_API_SUCCESS(status)) {
; 1757 :                 DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDBusDriver: Failed to get CARD CAPABILITY register \n")));
; 1758 :                 return status;

  000ec	4a00011b	 bmi         |$LN7@SDGetSDIOP|

; 1759 :             }
; 1760 : 
; 1761 :             m_SDCardInfo.SDIOInformation.pCommonInformation->CardCapability = regValue[0];

  000f0	e59714ec	 ldr         r1, [r7, #0x4EC]
  000f4	e5dd2008	 ldrb        r2, [sp, #8]

; 1762 : 
; 1763 :             // get the SD Spec rev
; 1764 :             status = SDReadWriteRegistersDirect_I(SD_IO_READ, SD_IO_REG_SPEC_REV,FALSE,regValue,1); 

  000f8	e28d5008	 add         r5, sp, #8
  000fc	e3a03000	 mov         r3, #0
  00100	e5c12002	 strb        r2, [r1, #2]
  00104	e5970000	 ldr         r0, [r7]
  00108	e3a02001	 mov         r2, #1
  0010c	e3a01000	 mov         r1, #0
  00110	e5904010	 ldr         r4, [r0, #0x10]
  00114	e1a00007	 mov         r0, r7
  00118	e58d8004	 str         r8, [sp, #4]
  0011c	e58d5000	 str         r5, [sp]
  00120	e1a0e00f	 mov         lr, pc
  00124	e12fff14	 bx          r4
  00128	e1b04000	 movs        r4, r0

; 1765 : 
; 1766 :             if (!SD_API_SUCCESS(status)) {
; 1767 :                 DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDBusDriver: Failed to get SD Spec revision \n")));
; 1768 :                 return status;

  0012c	4a00010b	 bmi         |$LN7@SDGetSDIOP|

; 1769 :             }
; 1770 : 
; 1771 :             m_SDCardInfo.SDIOInformation.pCommonInformation->SDSpec = regValue[0];

  00130	e59724ec	 ldr         r2, [r7, #0x4EC]
  00134	e5dd3008	 ldrb        r3, [sp, #8]

; 1772 : 
; 1773 :             DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDBusDriver: SDIO Card Function %d, CCCR 0x%02X , Card Caps: 0x%02X, Spec Ver: %d \n"), 
; 1774 :                 m_SDCardInfo.SDIOInformation.Function,
; 1775 :                 m_SDCardInfo.SDIOInformation.pCommonInformation->CCCRRev,
; 1776 :                 m_SDCardInfo.SDIOInformation.pCommonInformation->CardCapability,
; 1777 :                 m_SDCardInfo.SDIOInformation.pCommonInformation->SDSpec)); 
; 1778 : 
; 1779 : 
; 1780 :             // get the CIS pointer
; 1781 :             // function 0 only has a CIS, no CSA
; 1782 :             status = SDReadWriteRegistersDirect_I(SD_IO_READ, SD_IO_REG_COMMON_CIS_POINTER,FALSE,CSA_CISBuffer,SD_IO_CIS_PTR_BYTES); 

  00138	e3a06003	 mov         r6, #3
  0013c	e28d5014	 add         r5, sp, #0x14
  00140	e5c23001	 strb        r3, [r2, #1]
  00144	e5971000	 ldr         r1, [r7]
  00148	e3a03000	 mov         r3, #0
  0014c	e3a02009	 mov         r2, #9
  00150	e5914010	 ldr         r4, [r1, #0x10]
  00154	e3a01000	 mov         r1, #0
  00158	e1a00007	 mov         r0, r7
  0015c	e58d6004	 str         r6, [sp, #4]
  00160	e58d5000	 str         r5, [sp]
  00164	e1a0e00f	 mov         lr, pc
  00168	e12fff14	 bx          r4
  0016c	e1b04000	 movs        r4, r0

; 1783 :             if (!SD_API_SUCCESS(status)) {
; 1784 :                 return status;

  00170	4a0000fa	 bmi         |$LN7@SDGetSDIOP|

; 1785 :             }
; 1786 : 
; 1787 :             m_SDCardInfo.SDIOInformation.pCommonInformation->CommonCISPointer = CSA_CISBuffer[CIS_OFFSET_BYTE_0] | 
; 1788 :                 (CSA_CISBuffer[CIS_OFFSET_BYTE_1] << 8) |
; 1789 :                 (CSA_CISBuffer[CIS_OFFSET_BYTE_2] << 16);    

  00174	e5dd0016	 ldrb        r0, [sp, #0x16]
  00178	e5dd3015	 ldrb        r3, [sp, #0x15]
  0017c	e5dd2014	 ldrb        r2, [sp, #0x14]
  00180	e59714ec	 ldr         r1, [r7, #0x4EC]
  00184	e1833400	 orr         r3, r3, r0, lsl #8
  00188	e1823403	 orr         r3, r2, r3, lsl #8
  0018c	e5813004	 str         r3, [r1, #4]

; 1790 : 
; 1791 : #if 0
; 1792 :             // for Debugging a bad CIS only
; 1793 :             {
; 1794 :                 UCHAR tupleBuffer[256];
; 1795 :                 status = SDReadWriteRegistersDirect((SD_DEVICE_HANDLE)pDevice,
; 1796 :                     SD_IO_READ,          
; 1797 :                     0,      // all from function 0
; 1798 :                     pDevice->SDCardInfo.SDIOInformation.pCommonInformation->CommonCISPointer,
; 1799 :                     FALSE,
; 1800 :                     tupleBuffer,
; 1801 :                     256); 
; 1802 :                 if (SD_API_SUCCESS(status)) {
; 1803 :                     DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDBusDriver:  Common CIS Pointer: 0x%08X \n"),
; 1804 :                         pDevice->SDCardInfo.SDIOInformation.pCommonInformation->CommonCISPointer));     
; 1805 :                     SDOutputBuffer(tupleBuffer, 256);         
; 1806 :                 }
; 1807 : 
; 1808 :             }
; 1809 : 
; 1810 : #endif
; 1811 :             length = SD_CISTPL_MANFID_BODY_SIZE;
; 1812 : 
; 1813 :             // for function 0 get the Manufacturer ID (this is not the same as the VER1 string)
; 1814 :             status = SDGetTuple_I(SD_CISTPL_MANFID, (PUCHAR)&manFid, &length,TRUE);

  00190	e5972000	 ldr         r2, [r7]
  00194	e3a05004	 mov         r5, #4
  00198	e28d300c	 add         r3, sp, #0xC
  0019c	e5924030	 ldr         r4, [r2, #0x30]
  001a0	e28d2010	 add         r2, sp, #0x10
  001a4	e3a01020	 mov         r1, #0x20
  001a8	e1a00007	 mov         r0, r7
  001ac	e58d500c	 str         r5, [sp, #0xC]
  001b0	e58d8000	 str         r8, [sp]
  001b4	e1a0e00f	 mov         lr, pc
  001b8	e12fff14	 bx          r4
  001bc	e1b04000	 movs        r4, r0

; 1815 : 
; 1816 :             if (!SD_API_SUCCESS(status)) {
; 1817 :                 return status;

  001c0	4a0000e6	 bmi         |$LN7@SDGetSDIOP|

; 1818 :             }
; 1819 : 
; 1820 :             if (0 == length) {

  001c4	e59d300c	 ldr         r3, [sp, #0xC]
  001c8	e3530000	 cmp         r3, #0
  001cc	1a000003	 bne         |$LN20@SDGetSDIOP|

; 1821 :                 DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDBusDriver:  Card is missing CISTPL_MANFID \n")));
; 1822 :                 status = SD_API_STATUS_DEVICE_UNSUPPORTED;
; 1823 :                 return status;   

  001d0	e59d001c	 ldr         r0, [sp, #0x1C]
  001d4	eb000000	 bl          __security_check_cookie
  001d8	e3a0415f	 mov         r4, #0x5F, 2
  001dc	ea0000e1	 b           |$LN30@SDGetSDIOP|
  001e0		 |$LN20@SDGetSDIOP|

; 1824 :             }
; 1825 :             // set Manufacturer and CardID 
; 1826 :             m_SDCardInfo.SDIOInformation.pCommonInformation->ManufacturerID = (USHORT)manFid;

  001e0	e59d1010	 ldr         r1, [sp, #0x10]
  001e4	e59724ec	 ldr         r2, [r7, #0x4EC]

; 1827 :             m_SDCardInfo.SDIOInformation.pCommonInformation->CardID = (USHORT)(manFid >> 16);
; 1828 : 
; 1829 :             // retrieve the ver_1 tuple to retrieve the manufacturer string
; 1830 :             length = 0;

  001e8	e3a05000	 mov         r5, #0

; 1831 : 
; 1832 : 
; 1833 :             // query the size of the tuple from the common CIS
; 1834 :             // the VERS_1 tuple is a variable length tuple
; 1835 :             status = SDGetTuple_I(SD_CISTPL_VERS_1, NULL,&length, TRUE);

  001ec	e28d300c	 add         r3, sp, #0xC
  001f0	e1c210b8	 strh        r1, [r2, #8]
  001f4	e59d1010	 ldr         r1, [sp, #0x10]
  001f8	e59704ec	 ldr         r0, [r7, #0x4EC]
  001fc	e3a02000	 mov         r2, #0
  00200	e1a01821	 mov         r1, r1, lsr #16
  00204	e1c010ba	 strh        r1, [r0, #0xA]
  00208	e597e000	 ldr         lr, [r7]
  0020c	e3a01015	 mov         r1, #0x15
  00210	e1a00007	 mov         r0, r7
  00214	e59e4030	 ldr         r4, [lr, #0x30]
  00218	e58d500c	 str         r5, [sp, #0xC]
  0021c	e58d8000	 str         r8, [sp]
  00220	e1a0e00f	 mov         lr, pc
  00224	e12fff14	 bx          r4
  00228	e1b04000	 movs        r4, r0

; 1836 : 
; 1837 :             if (!SD_API_SUCCESS(status)) {
; 1838 :                 return status;

  0022c	4a0000cb	 bmi         |$LN7@SDGetSDIOP|

; 1839 :             }
; 1840 : 
; 1841 :             if (0 != length ) {

  00230	e59d300c	 ldr         r3, [sp, #0xC]
  00234	e3530000	 cmp         r3, #0

; 1842 :                 found = TRUE;
; 1843 :             } else {
; 1844 :                 // the VER_1 tuple is optional, so if we could not find it, we
; 1845 :                 // allocate the string identifying it as unknown
; 1846 :                 found = FALSE;
; 1847 :                 length = UNKNOWN_PRODUCT_INFO_STRING_LENGTH;

  00238	03a03040	 moveq       r3, #0x40
  0023c	058d300c	 streq       r3, [sp, #0xC]

; 1848 :             }
; 1849 :             // allocate the string (include NULL) even if no tuple
; 1850 :             m_SDCardInfo.SDIOInformation.pCommonInformation->pProductInformation = new WCHAR[length+1];

  00240	e2833001	 add         r3, r3, #1
  00244	13a05001	 movne       r5, #1
  00248	03a05000	 moveq       r5, #0
  0024c	e3730106	 cmn         r3, #6, 2
  00250	91a00083	 movls       r0, r3, lsl #1
  00254	83e00000	 mvnhi       r0, #0
  00258	eb000000	 bl          |??2@YAPAXI@Z|
  0025c	e59734ec	 ldr         r3, [r7, #0x4EC]
  00260	e583000c	 str         r0, [r3, #0xC]

; 1851 : 
; 1852 :             if (NULL == m_SDCardInfo.SDIOInformation.pCommonInformation->pProductInformation) {

  00264	e59724ec	 ldr         r2, [r7, #0x4EC]
  00268	e592300c	 ldr         r3, [r2, #0xC]
  0026c	e1b00003	 movs        r0, r3

; 1853 :                 DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDBusDriver:  Failed to allocate product information string \n")));
; 1854 :                 return SD_API_STATUS_INSUFFICIENT_RESOURCES;

  00270	0affff71	 beq         |$LN36@SDGetSDIOP|

; 1855 :             }
; 1856 : 
; 1857 :             if (found) {

  00274	e3a09000	 mov         r9, #0
  00278	e3550000	 cmp         r5, #0
  0027c	0a00001c	 beq         |$LN15@SDGetSDIOP|

; 1858 : 
; 1859 :                 pVersionBuffer = new CHAR [length + 1];

  00280	e59d300c	 ldr         r3, [sp, #0xC]
  00284	e2830001	 add         r0, r3, #1
  00288	eb000000	 bl          |??2@YAPAXI@Z|
  0028c	e1b05000	 movs        r5, r0

; 1860 : 
; 1861 :                 if (NULL == pVersionBuffer) {
; 1862 :                     DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDBusDriver:  Failed to allocate product information string \n")));            
; 1863 :                     return SD_API_STATUS_INSUFFICIENT_RESOURCES;

  00290	0affff69	 beq         |$LN36@SDGetSDIOP|

; 1864 :                 }
; 1865 : 
; 1866 :                 // retrieve the tuple from the common CIS
; 1867 :                 status = SDGetTuple_I( SD_CISTPL_VERS_1,(PUCHAR)pVersionBuffer,&length, TRUE);   

  00294	e5971000	 ldr         r1, [r7]
  00298	e28d300c	 add         r3, sp, #0xC
  0029c	e1a02005	 mov         r2, r5
  002a0	e5914030	 ldr         r4, [r1, #0x30]
  002a4	e3a01015	 mov         r1, #0x15
  002a8	e1a00007	 mov         r0, r7
  002ac	e58d8000	 str         r8, [sp]
  002b0	e1a0e00f	 mov         lr, pc
  002b4	e12fff14	 bx          r4
  002b8	e1b04000	 movs        r4, r0

; 1868 : 
; 1869 : 
; 1870 :                 if (!SD_API_SUCCESS(status)) {

  002bc	5a000002	 bpl         |$LN13@SDGetSDIOP|

; 1871 :                     delete[] pVersionBuffer ;

  002c0	e1a00005	 mov         r0, r5
  002c4	eb000000	 bl          |??3@YAXPAX@Z|

; 1872 :                     return status;

  002c8	ea0000a4	 b           |$LN7@SDGetSDIOP|
  002cc		 |$LN13@SDGetSDIOP|

; 1873 :                 }
; 1874 : 
; 1875 :                 // make sure the string is null terminated
; 1876 :                 pVersionBuffer[length] = NULL;

  002cc	e59d300c	 ldr         r3, [sp, #0xC]

; 1877 : 
; 1878 :                 // bump past the binary version info,
; 1879 :                 // and format the string to wide char
; 1880 :                 FormatProductString(&pVersionBuffer[2],  
; 1881 :                     m_SDCardInfo.SDIOInformation.pCommonInformation->pProductInformation);

  002d0	e2851002	 add         r1, r5, #2
  002d4	e1a00007	 mov         r0, r7
  002d8	e7c59003	 strb        r9, [r5, +r3]
  002dc	e59734ec	 ldr         r3, [r7, #0x4EC]
  002e0	e593200c	 ldr         r2, [r3, #0xC]
  002e4	eb000000	 bl          |?FormatProductString@CSDDevice@@IBAXPADPAG@Z|

; 1882 :                 // free the version buffer
; 1883 :                 delete[] pVersionBuffer;

  002e8	e1a00005	 mov         r0, r5
  002ec	eb000000	 bl          |??3@YAXPAX@Z|

; 1884 : 
; 1885 :             } else {

  002f0	ea000003	 b           |$LN12@SDGetSDIOP|
  002f4		 |$LN15@SDGetSDIOP|

; 1886 :                 // form the product name based on the required MANF and CARDID instead of the
; 1887 :                 // ver1 string
; 1888 :                 swprintf( m_SDCardInfo.SDIOInformation.pCommonInformation->pProductInformation,
; 1889 :                     TEXT("Manufacturer ID:0x%04X, Card ID:0x%04X"),
; 1890 :                     m_SDCardInfo.SDIOInformation.pCommonInformation->ManufacturerID,
; 1891 :                     m_SDCardInfo.SDIOInformation.pCommonInformation->CardID);

  002f4	e1d230ba	 ldrh        r3, [r2, #0xA]
  002f8	e1d220b8	 ldrh        r2, [r2, #8]
  002fc	e59f1278	 ldr         r1, [pc, #0x278]
  00300	eb000000	 bl          swprintf
  00304		 |$LN12@SDGetSDIOP|

; 1892 : 
; 1893 :             }  
; 1894 :             
; 1895 :                 // enable power control on the card if available
; 1896 :             m_SDCardInfo.SDIOInformation.pCommonInformation->fCardSupportsPowerControl = FALSE;

  00304	e59734ec	 ldr         r3, [r7, #0x4EC]
  00308	e5839014	 str         r9, [r3, #0x14]

; 1897 :             m_SDCardInfo.SDIOInformation.pCommonInformation->fPowerControlEnabled = FALSE;

  0030c	e59734ec	 ldr         r3, [r7, #0x4EC]
  00310	e5839018	 str         r9, [r3, #0x18]

; 1898 : 
; 1899 :             if((m_SDCardInfo.SDIOInformation.pCommonInformation->CCCRRev //only attempt on 1.1 cards
; 1900 :                   & SDIO_CCCR_SPEC_REV_MASK) == SDIO_CCCR_SPEC_REV_1_1)  {

  00314	e59734ec	 ldr         r3, [r7, #0x4EC]
  00318	e5d33000	 ldrb        r3, [r3]
  0031c	e203300f	 and         r3, r3, #0xF
  00320	e3530001	 cmp         r3, #1
  00324	1a00008d	 bne         |$LN7@SDGetSDIOP|

; 1901 :                 status = SDReadWriteRegistersDirect_I(SD_IO_READ, SD_IO_REG_POWER_CONTROL,FALSE, regValue,1); 

  00328	e5972000	 ldr         r2, [r7]
  0032c	e28d5008	 add         r5, sp, #8
  00330	e3a03000	 mov         r3, #0
  00334	e5924010	 ldr         r4, [r2, #0x10]
  00338	e3a02012	 mov         r2, #0x12
  0033c	e3a01000	 mov         r1, #0
  00340	e1a00007	 mov         r0, r7
  00344	e58d8004	 str         r8, [sp, #4]
  00348	e58d5000	 str         r5, [sp]
  0034c	e1a0e00f	 mov         lr, pc
  00350	e12fff14	 bx          r4
  00354	e1b04000	 movs        r4, r0

; 1902 : 
; 1903 :                 if (SD_API_SUCCESS(status) &&
; 1904 :                         (*regValue & SD_IO_CARD_POWER_CONTROL_SUPPORT)) {

  00358	4a000080	 bmi         |$LN7@SDGetSDIOP|
  0035c	e5dd3008	 ldrb        r3, [sp, #8]
  00360	e3130001	 tst         r3, #1
  00364	0a00007d	 beq         |$LN7@SDGetSDIOP|

; 1905 :                     m_SDCardInfo.SDIOInformation.pCommonInformation->fCardSupportsPowerControl = TRUE;

  00368	e59734ec	 ldr         r3, [r7, #0x4EC]
  0036c	e5838014	 str         r8, [r3, #0x14]

; 1906 : 
; 1907 :                     if(m_sdSlot.GetSlotPowerControl()) {

  00370	e5973438	 ldr         r3, [r7, #0x438]
  00374	e59330ac	 ldr         r3, [r3, #0xAC]
  00378	e3530000	 cmp         r3, #0
  0037c	0a000077	 beq         |$LN7@SDGetSDIOP|

; 1908 :                         *regValue |= SD_IO_CARD_POWER_CONTROL_ENABLE;
; 1909 :                         status = SDReadWriteRegistersDirect_I( SD_IO_WRITE,SD_IO_REG_POWER_CONTROL, FALSE,regValue, 1);

  00380	e5dd3008	 ldrb        r3, [sp, #8]
  00384	e5972000	 ldr         r2, [r7]
  00388	e28d5008	 add         r5, sp, #8
  0038c	e3834002	 orr         r4, r3, #2
  00390	e5926010	 ldr         r6, [r2, #0x10]
  00394	e5cd4008	 strb        r4, [sp, #8]
  00398	e3a03000	 mov         r3, #0
  0039c	e3a02012	 mov         r2, #0x12
  003a0	e3a01001	 mov         r1, #1
  003a4	e1a00007	 mov         r0, r7
  003a8	e58d8004	 str         r8, [sp, #4]
  003ac	e58d5000	 str         r5, [sp]
  003b0	e1a0e00f	 mov         lr, pc
  003b4	e12fff16	 bx          r6
  003b8	e1b04000	 movs        r4, r0

; 1910 :                         if (SD_API_SUCCESS(status)) {

  003bc	4a000067	 bmi         |$LN7@SDGetSDIOP|

; 1911 :                             DbgPrintZo(SDBUS_ZONE_DEVICE, (TEXT("SDBusDriver: Power Control Enabled for SDIO Card.\n"))); 
; 1912 :                             m_SDCardInfo.SDIOInformation.pCommonInformation->fPowerControlEnabled = TRUE;

  003c0	e59734ec	 ldr         r3, [r7, #0x4EC]
  003c4	e5838018	 str         r8, [r3, #0x18]

; 1913 :                         }
; 1914 :                     }
; 1915 :                 }
; 1916 :             }
; 1917 :         }
; 1918 :         else {

  003c8	ea000064	 b           |$LN7@SDGetSDIOP|
  003cc		 |$LN26@SDGetSDIOP|

; 1919 :             // Copy Common Info
; 1920 :             m_SDCardInfo.SDIOInformation.pCommonInformation->CCCRRev = psdDevice0.m_SDCardInfo.SDIOInformation.pCommonInformation->CCCRRev;

  003cc	e59634ec	 ldr         r3, [r6, #0x4EC]
  003d0	e59724ec	 ldr         r2, [r7, #0x4EC]

; 1921 :             m_SDCardInfo.SDIOInformation.pCommonInformation->CardCapability = psdDevice0.m_SDCardInfo.SDIOInformation.pCommonInformation->CardCapability;
; 1922 :             m_SDCardInfo.SDIOInformation.pCommonInformation->SDSpec = psdDevice0.m_SDCardInfo.SDIOInformation.pCommonInformation->SDSpec;
; 1923 : 
; 1924 :             DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDBusDriver: SDIO Card Function %d, CCCR 0x%02X , Card Caps: 0x%02X, Spec Ver: %d \n"), 
; 1925 :                 m_SDCardInfo.SDIOInformation.Function,
; 1926 :                 m_SDCardInfo.SDIOInformation.pCommonInformation->CCCRRev,
; 1927 :                 m_SDCardInfo.SDIOInformation.pCommonInformation->CardCapability,
; 1928 :                 m_SDCardInfo.SDIOInformation.pCommonInformation->SDSpec)); 
; 1929 : 
; 1930 :             m_SDCardInfo.SDIOInformation.pCommonInformation->CommonCISPointer = NULL;

  003d4	e3a09000	 mov         r9, #0
  003d8	e5d33000	 ldrb        r3, [r3]

; 1931 :             m_SDCardInfo.SDIOInformation.pCommonInformation->ManufacturerID = psdDevice0.m_SDCardInfo.SDIOInformation.pCommonInformation->ManufacturerID;
; 1932 :             m_SDCardInfo.SDIOInformation.pCommonInformation->CardID = psdDevice0.m_SDCardInfo.SDIOInformation.pCommonInformation->CardID;
; 1933 :             m_SDCardInfo.SDIOInformation.pCommonInformation->pProductInformation = NULL;
; 1934 :             
; 1935 :             // calculate the FBR offset
; 1936 :             FBROffset = SD_IO_FBR_1_OFFSET + (m_SDCardInfo.SDIOInformation.Function - 1) *
; 1937 :                 SD_IO_FBR_LENGTH;
; 1938 : 
; 1939 :             // fetch the device code
; 1940 :             status = psdDevice0.SDReadWriteRegistersDirect_I(SD_IO_READ,FBROffset + SD_IO_FBR_DEVICE_CODE, FALSE,regValue,1); 

  003dc	e1a00006	 mov         r0, r6
  003e0	e58d8004	 str         r8, [sp, #4]
  003e4	e5c23000	 strb        r3, [r2]
  003e8	e59624ec	 ldr         r2, [r6, #0x4EC]
  003ec	e597e4ec	 ldr         lr, [r7, #0x4EC]
  003f0	e3a03000	 mov         r3, #0
  003f4	e5d22002	 ldrb        r2, [r2, #2]
  003f8	e58d5000	 str         r5, [sp]
  003fc	e5ce2002	 strb        r2, [lr, #2]
  00400	e59624ec	 ldr         r2, [r6, #0x4EC]
  00404	e59744ec	 ldr         r4, [r7, #0x4EC]
  00408	e5d22001	 ldrb        r2, [r2, #1]
  0040c	e5c42001	 strb        r2, [r4, #1]
  00410	e59724ec	 ldr         r2, [r7, #0x4EC]
  00414	e5829004	 str         r9, [r2, #4]
  00418	e59624ec	 ldr         r2, [r6, #0x4EC]
  0041c	e59744ec	 ldr         r4, [r7, #0x4EC]
  00420	e1d220b8	 ldrh        r2, [r2, #8]
  00424	e1c420b8	 strh        r2, [r4, #8]
  00428	e59624ec	 ldr         r2, [r6, #0x4EC]
  0042c	e59744ec	 ldr         r4, [r7, #0x4EC]
  00430	e1d220ba	 ldrh        r2, [r2, #0xA]
  00434	e1c420ba	 strh        r2, [r4, #0xA]
  00438	e59724ec	 ldr         r2, [r7, #0x4EC]
  0043c	e582900c	 str         r9, [r2, #0xC]
  00440	e5d724d8	 ldrb        r2, [r7, #0x4D8]
  00444	e5964000	 ldr         r4, [r6]
  00448	e1a09402	 mov         r9, r2, lsl #8
  0044c	e5944010	 ldr         r4, [r4, #0x10]
  00450	e1a02009	 mov         r2, r9
  00454	e1a0e00f	 mov         lr, pc
  00458	e12fff14	 bx          r4
  0045c	e1b04000	 movs        r4, r0

; 1941 :             if (!SD_API_SUCCESS(status)) {
; 1942 :                 return status;   

  00460	4a00003e	 bmi         |$LN7@SDGetSDIOP|

; 1943 :             }
; 1944 : 
; 1945 :             // save the device code, 1.0 style
; 1946 :             m_SDCardInfo.SDIOInformation.DeviceCode = (regValue[0] & SDIO_DEV_CODE_MASK);  

  00464	e5dd3008	 ldrb        r3, [sp, #8]
  00468	e203300f	 and         r3, r3, #0xF
  0046c	e5c734d9	 strb        r3, [r7, #0x4D9]

; 1947 :             
; 1948 :             // check to see if we are using the special device code extension token
; 1949 :             if (SDIO_DEV_CODE_USES_EXTENSION == m_SDCardInfo.SDIOInformation.DeviceCode) {

  00470	e353000f	 cmp         r3, #0xF
  00474	1a000013	 bne         |$LN4@SDGetSDIOP|

; 1950 : 
; 1951 :                     // check the CCCR revision for 1.1
; 1952 :                 if ((psdDevice0.m_SDCardInfo.SDIOInformation.pCommonInformation->CCCRRev & SDIO_CCCR_SPEC_REV_MASK) == SDIO_CCCR_SPEC_REV_1_1) {

  00478	e59634ec	 ldr         r3, [r6, #0x4EC]
  0047c	e5d33000	 ldrb        r3, [r3]
  00480	e203300f	 and         r3, r3, #0xF
  00484	e3530001	 cmp         r3, #1
  00488	1a00000e	 bne         |$LN4@SDGetSDIOP|

; 1953 : 
; 1954 :                     // fetch the device code extension
; 1955 :                     status = psdDevice0.SDReadWriteRegistersDirect_I(SD_IO_READ, FBROffset + SD_IO_FBR_DEVICE_CODE_EXT,
; 1956 :                         FALSE, regValue,1); 

  0048c	e5962000	 ldr         r2, [r6]
  00490	e28d5008	 add         r5, sp, #8
  00494	e3a03000	 mov         r3, #0
  00498	e5924010	 ldr         r4, [r2, #0x10]
  0049c	e2892001	 add         r2, r9, #1
  004a0	e3a01000	 mov         r1, #0
  004a4	e1a00006	 mov         r0, r6
  004a8	e58d8004	 str         r8, [sp, #4]
  004ac	e58d5000	 str         r5, [sp]
  004b0	e1a0e00f	 mov         lr, pc
  004b4	e12fff14	 bx          r4
  004b8	e1b04000	 movs        r4, r0

; 1957 : 
; 1958 :                     if (!SD_API_SUCCESS(status)) {
; 1959 :                         return status;   

  004bc	4a000027	 bmi         |$LN7@SDGetSDIOP|

; 1960 :                     }   
; 1961 : 
; 1962 :                     // now 0x10-0xFF are available as device code extensions    
; 1963 :                     m_SDCardInfo.SDIOInformation.DeviceCode = regValue[0];

  004c0	e5dd3008	 ldrb        r3, [sp, #8]
  004c4	e5c734d9	 strb        r3, [r7, #0x4D9]
  004c8		 |$LN4@SDGetSDIOP|

; 1964 : 
; 1965 :                 }
; 1966 :             }
; 1967 : 
; 1968 :             // get the CIS and CSA pointers, we do a multi-byte read here
; 1969 :             status = psdDevice0.SDReadWriteRegistersDirect_I(SD_IO_READ, FBROffset + SD_IO_FBR_CISP_BYTE_0, FALSE,
; 1970 :                 CSA_CISBuffer, CIS_CSA_BYTES); 

  004c8	e5963000	 ldr         r3, [r6]
  004cc	e3a08006	 mov         r8, #6
  004d0	e28d4014	 add         r4, sp, #0x14
  004d4	e5935010	 ldr         r5, [r3, #0x10]
  004d8	e3a03000	 mov         r3, #0
  004dc	e2892009	 add         r2, r9, #9
  004e0	e3a01000	 mov         r1, #0
  004e4	e1a00006	 mov         r0, r6
  004e8	e58d8004	 str         r8, [sp, #4]
  004ec	e58d4000	 str         r4, [sp]
  004f0	e1a0e00f	 mov         lr, pc
  004f4	e12fff15	 bx          r5
  004f8	e1b04000	 movs        r4, r0

; 1971 :             if (!SD_API_SUCCESS(status)) {
; 1972 :                 return status;   

  004fc	4a000017	 bmi         |$LN7@SDGetSDIOP|

; 1973 :             }
; 1974 : 
; 1975 :             m_SDCardInfo.SDIOInformation.CISPointer = CSA_CISBuffer[CIS_OFFSET_BYTE_0] | 
; 1976 :                 (CSA_CISBuffer[CIS_OFFSET_BYTE_1] << 8) |
; 1977 :                 (CSA_CISBuffer[CIS_OFFSET_BYTE_2] << 16);

  00500	e5dd4016	 ldrb        r4, [sp, #0x16]
  00504	e5dd3015	 ldrb        r3, [sp, #0x15]

; 1978 : 
; 1979 :             m_SDCardInfo.SDIOInformation.CSAPointer = CSA_CISBuffer[CSA_OFFSET_BYTE_0] | 
; 1980 :                 (CSA_CISBuffer[CSA_OFFSET_BYTE_1] << 8) |
; 1981 :                 (CSA_CISBuffer[CSA_OFFSET_BYTE_2] << 16);

  00508	e5dde019	 ldrb        lr, [sp, #0x19]
  0050c	e5dd2018	 ldrb        r2, [sp, #0x18]
  00510	e5dd1014	 ldrb        r1, [sp, #0x14]
  00514	e5dd0017	 ldrb        r0, [sp, #0x17]
  00518	e1833404	 orr         r3, r3, r4, lsl #8
  0051c	e182240e	 orr         r2, r2, lr, lsl #8
  00520	e1813403	 orr         r3, r1, r3, lsl #8
  00524	e1802402	 orr         r2, r0, r2, lsl #8

; 1982 : 
; 1983 :             // allocate a product information tuple and fill it will some sort of
; 1984 :             // friendly name string
; 1985 :             ASSERT(m_SDCardInfo.SDIOInformation.pFunctionInformation == NULL);
; 1986 :             m_SDCardInfo.SDIOInformation.pFunctionInformation = new WCHAR[UNKNOWN_PRODUCT_INFO_STRING_LENGTH + 1];

  00528	e3a00082	 mov         r0, #0x82
  0052c	e58734dc	 str         r3, [r7, #0x4DC]
  00530	e58724e0	 str         r2, [r7, #0x4E0]
  00534	eb000000	 bl          |??2@YAPAXI@Z|
  00538	e3500000	 cmp         r0, #0
  0053c	e58704e4	 str         r0, [r7, #0x4E4]

; 1987 : 
; 1988 :             if (NULL == m_SDCardInfo.SDIOInformation.pFunctionInformation) {
; 1989 :                 DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDBusDriver:  Failed to allocate product information string \n")));
; 1990 :                 status = SD_API_STATUS_INSUFFICIENT_RESOURCES;
; 1991 :                 return status;

  00540	0afffebd	 beq         |$LN36@SDGetSDIOP|

; 1992 :             }
; 1993 : 
; 1994 :             // get the power control infomation via the Function FUNCE Tuple
; 1995 :             status = SDGetFunctionPowerControlTuples();

  00544	e1a00007	 mov         r0, r7
  00548	eb000000	 bl          |?SDGetFunctionPowerControlTuples@CSDDevice@@IAAJXZ|

; 1996 :                  
; 1997 : 
; 1998 :             // form the product name using the device class
; 1999 :             swprintf(m_SDCardInfo.SDIOInformation.pFunctionInformation,
; 2000 :                 TEXT("Device of Class Type: %d"),
; 2001 :                 m_SDCardInfo.SDIOInformation.DeviceCode);

  0054c	e5d724d9	 ldrb        r2, [r7, #0x4D9]
  00550	e59f1020	 ldr         r1, [pc, #0x20]
  00554	e1a04000	 mov         r4, r0
  00558	e59704e4	 ldr         r0, [r7, #0x4E4]
  0055c	eb000000	 bl          swprintf
  00560		 |$LN7@SDGetSDIOP|

; 2002 : 
; 2003 : 
; 2004 :             DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDBusDriver: Device 0x%08X , Function String: %s \n"),
; 2005 :                 this,m_SDCardInfo.SDIOInformation.pFunctionInformation));
; 2006 : 
; 2007 :             DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDBusDriver: Common Product String: %s \n"),
; 2008 :                 psdDevice0.m_SDCardInfo.SDIOInformation.pCommonInformation->pProductInformation));
; 2009 :         }
; 2010 :     }
; 2011 :     return status;

  00560	e59d001c	 ldr         r0, [sp, #0x1C]
  00564	eb000000	 bl          __security_check_cookie
  00568		 |$LN30@SDGetSDIOP|

; 2012 : }

  00568	e1a00004	 mov         r0, r4
  0056c	e28dd020	 add         sp, sp, #0x20
  00570	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00574	e12fff1e	 bx          lr
  00578		 |$LN40@SDGetSDIOP|
  00578		 |$LN41@SDGetSDIOP|
  00578	00000000	 DCD         |??_C@_1DC@GIMPIHDB@?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAo?$AAf?$AA?5?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAT?$AAy?$AAp?$AAe?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?$AA@|
  0057c		 |$LN42@SDGetSDIOP|
  0057c	00000000	 DCD         |??_C@_1EO@GLAKDDC@?$AAM?$AAa?$AAn?$AAu?$AAf?$AAa?$AAc?$AAt?$AAu?$AAr?$AAe?$AAr?$AA?5?$AAI?$AAD?$AA?3?$AA0?$AAx?$AA?$CF?$AA0?$AA4?$AAX?$AA?0?$AA?5?$AAC?$AAa?$AAr?$AAd?$AA?5?$AAI?$AAD?$AA?3@|
  00580		 |$LN43@SDGetSDIOP|
  00580	00000000	 DCD         |__security_cookie|
  00584		 |$M42989|

			 ENDP  ; |?SDGetSDIOPnpInformation@CSDDevice@@QAAJAAV1@@Z|, CSDDevice::SDGetSDIOPnpInformation

	IMPORT	|?RemoveRequest@CSDBusReqAsyncQueue@@QAAPAVCSDBusRequest@@PAV2@@Z| ; CSDBusReqAsyncQueue::RemoveRequest
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdbusreq.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T43017| DCD	|$LN19@SDFreeBusR|
	DCD	0x40002401
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDFreeBusRequest_I@CSDDevice@@UAAXPAX@Z| PROC ; CSDDevice::SDFreeBusRequest_I

; 2596 : {

  00000		 |$LN19@SDFreeBusR|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M43014|
  00004	e1b04001	 movs        r4, r1
  00008	e1a06000	 mov         r6, r0

; 2597 :     SDBUS_REQUEST_HANDLE sdBusRequestHandle;
; 2598 :     sdBusRequestHandle.hValue = hRequest;
; 2599 :     BOOL fFreedRequest = FALSE;
; 2600 :     if (hRequest && sdBusRequestHandle.bit.sd1f == 0x1f) {

  0000c	0a00001d	 beq         |$LN7@SDFreeBusR|
  00010	e2043b3e	 and         r3, r4, #0x3E, 22
  00014	e3530b3e	 cmp         r3, #0x3E, 22
  00018	1a00001a	 bne         |$LN7@SDFreeBusR|

; 2601 :         CSDBusRequest * pCurRequest = ObjectIndex(sdBusRequestHandle.bit.sdRequestIndex);

  0001c	e1a07404	 mov         r7, r4, lsl #8
  00020	e1a01c27	 mov         r1, r7, lsr #24
  00024	e2860008	 add         r0, r6, #8
  00028	eb000000	 bl          |?ObjectIndex@?$CStaticContainer@VCSDBusRequest@@$0BAA@@@QAAPAVCSDBusRequest@@K@Z|
  0002c	e1b05000	 movs        r5, r0

; 2602 :         if (pCurRequest ) {

  00030	0a000014	 beq         |$LN7@SDFreeBusR|

; 2603 :             if (pCurRequest->GetRequestRandomIndex() == sdBusRequestHandle.bit.sdRandamNumber) { // this is right requerst.

  00034	e5953078	 ldr         r3, [r5, #0x78]
  00038	e1530c24	 cmp         r3, r4, lsr #24
  0003c	1a00000a	 bne         |$LN4@SDFreeBusR|

; 2604 :                 CSDBusRequest * pCurRequest2 = pCurRequest ;

  00040	e1a04005	 mov         r4, r5
  00044		 |$LL5@SDFreeBusR|

; 2605 :                 while (pCurRequest2 ) {
; 2606 :                     if (!pCurRequest2->IsComplete()) {

  00044	e1a00004	 mov         r0, r4
  00048	eb000000	 bl          |?IsComplete@CSDBusRequest@@QAAHXZ|
  0004c	e3500000	 cmp         r0, #0

; 2607 :                         m_sdSlot.RemoveRequest(pCurRequest2);

  00050	05963438	 ldreq       r3, [r6, #0x438]
  00054	01a01004	 moveq       r1, r4
  00058	02830044	 addeq       r0, r3, #0x44
  0005c	0b000000	 bleq        |?RemoveRequest@CSDBusReqAsyncQueue@@QAAPAVCSDBusRequest@@PAV2@@Z|

; 2608 :                     }
; 2609 :                     pCurRequest2 = pCurRequest2->GetChildListNext();

  00060	e5943070	 ldr         r3, [r4, #0x70]
  00064	e1b04003	 movs        r4, r3
  00068	1afffff5	 bne         |$LL5@SDFreeBusR|
  0006c		 |$LN4@SDFreeBusR|

; 2610 :                 }
; 2611 :                 fFreedRequest = TRUE;
; 2612 :             }
; 2613 :             else
; 2614 :                 ASSERT(FALSE);
; 2615 :             CSDBusRequest * pCurRequest2 = RemoveObjectBy(sdBusRequestHandle.bit.sdRequestIndex );

  0006c	e1a01c27	 mov         r1, r7, lsr #24
  00070	e2860008	 add         r0, r6, #8
  00074	eb000000	 bl          |?RemoveObjectBy@?$CStaticContainer@VCSDBusRequest@@$0BAA@@@QAAPAVCSDBusRequest@@K@Z|

; 2616 :             ASSERT(pCurRequest2!=NULL);
; 2617 :             pCurRequest->TerminateLink();

  00078	e1a00005	 mov         r0, r5
  0007c	eb000000	 bl          |?TerminateLink@CSDBusRequest@@QAAHXZ|

; 2618 :             pCurRequest->DeRef();

  00080	e1a00005	 mov         r0, r5
  00084	eb000000	 bl          |?DeRef@CSDBusRequest@@QAAKXZ|
  00088		 |$LN7@SDFreeBusR|

; 2619 :         }
; 2620 :         else
; 2621 :             ASSERT(FALSE);
; 2622 :     }
; 2623 :     ASSERT(fFreedRequest);
; 2624 :     DEBUGMSG(SDCARD_ZONE_ERROR && !fFreedRequest, (_T("SDFreeBusRequest_I: Invalid request h=0x%x\r\n"),hRequest));
; 2625 : }

  00088	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0008c	e12fff1e	 bx          lr
  00090		 |$M43015|

			 ENDP  ; |?SDFreeBusRequest_I@CSDDevice@@UAAXPAX@Z|, CSDDevice::SDFreeBusRequest_I

; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdbusreq.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T43047| DCD	|$LN22@SDBusReque@2|
	DCD	0xc0002a04

  00000			 AREA	 |.pdata|, PDATA
|$T43049| DCD	|$LN8@SDBusReque@2|
	DCD	0x40000301

  00000			 AREA	 |.xdata|, DATA
|$T43045| DCD	0x1
	DCD	|$LN12@SDBusReque@2|
	DCD	|$LN13@SDBusReque@2|
	DCD	|$LN8@SDBusReque@2|
	DCD	|$LN9@SDBusReque@2|
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T43045|

  00008		 |?SDBusRequestResponse_I@CSDDevice@@UAAJPAXPAU_SD_COMMAND_RESPONSE@@@Z| PROC ; CSDDevice::SDBusRequestResponse_I

; 2627 : {

  00008		 |$LN22@SDBusReque@2|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d58f0	 stmdb       sp!, {r4 - r7, r11, r12, lr}
  00010	e28db01c	 add         r11, sp, #0x1C
  00014	e24dd008	 sub         sp, sp, #8
  00018		 |$LN20@SDBusReque@2|
  00018	e1a07002	 mov         r7, r2
  0001c	e1b06001	 movs        r6, r1

; 2628 :     SDBUS_REQUEST_HANDLE sdBusRequestHandle;
; 2629 :     sdBusRequestHandle.hValue = hRequest;
; 2630 :     SD_API_STATUS   status = SD_API_STATUS_INVALID_PARAMETER;  // intermediate status

  00020	e3a0411f	 mov         r4, #0x1F, 2

; 2631 :     if (hRequest && sdBusRequestHandle.bit.sd1f == 0x1f) {

  00024	0a00001d	 beq         |$LN3@SDBusReque@2|
  00028	e2063b3e	 and         r3, r6, #0x3E, 22
  0002c	e3530b3e	 cmp         r3, #0x3E, 22
  00030	1a00001a	 bne         |$LN3@SDBusReque@2|

; 2632 :         CSDBusRequest * pCurRequest = ObjectIndex(sdBusRequestHandle.bit.sdRequestIndex);

  00034	e1a03406	 mov         r3, r6, lsl #8
  00038	e1a01c23	 mov         r1, r3, lsr #24
  0003c	e2800008	 add         r0, r0, #8
  00040	eb000000	 bl          |?ObjectIndex@?$CStaticContainer@VCSDBusRequest@@$0BAA@@@QAAPAVCSDBusRequest@@K@Z|
  00044	e1b05000	 movs        r5, r0
  00048	e50b5020	 str         r5, [r11, #-0x20]

; 2633 :         if (pCurRequest ) {

  0004c	0a000013	 beq         |$LN3@SDBusReque@2|

; 2634 :             if ( pSdCmdResp && pCurRequest->GetRequestRandomIndex() == sdBusRequestHandle.bit.sdRandamNumber) { // this is right requerst.

  00050	e3570000	 cmp         r7, #0
  00054	0a00000f	 beq         |$LN14@SDBusReque@2|
  00058	e5953078	 ldr         r3, [r5, #0x78]
  0005c	e1530c26	 cmp         r3, r6, lsr #24
  00060	1a00000c	 bne         |$LN14@SDBusReque@2|
  00064		 |$LN12@SDBusReque@2|

; 2635 :                 __try {
; 2636 :                     *pSdCmdResp = pCurRequest->CommandResponse;

  00064	e2851020	 add         r1, r5, #0x20
  00068	e3a02018	 mov         r2, #0x18
  0006c	e1a00007	 mov         r0, r7
  00070	eb000000	 bl          memcpy

; 2637 :                     status = pCurRequest->Status;

  00074	e595403c	 ldr         r4, [r5, #0x3C]
  00078	e50b4024	 str         r4, [r11, #-0x24]
  0007c		 |$LN13@SDBusReque@2|
  0007c	ea000005	 b           |$LN14@SDBusReque@2|
  00080		 |$LN9@SDBusReque@2|

; 2639 :                     status = SD_API_STATUS_INVALID_PARAMETER;

  00080	e3a0411f	 mov         r4, #0x1F, 2
  00084	e50b4024	 str         r4, [r11, #-0x24]
  00088	e51b5020	 ldr         r5, [r11, #-0x20]
  0008c	ea000001	 b           |$LN14@SDBusReque@2|
  00090		 |$LN19@SDBusReque@2|

; 2643 :         }
; 2644 :     }
; 2645 :     DEBUGMSG(SDCARD_ZONE_ERROR && !SD_API_SUCCESS(status), (_T("SDBusRequestResponse_I:  Invalid request h=0x%x\r\n"),hRequest));
; 2646 :     return status;

  00090	e51b4020	 ldr         r4, [r11, #-0x20]
  00094	ea000001	 b           |$LN3@SDBusReque@2|
  00098		 |$LN14@SDBusReque@2|

; 2640 :                 }                
; 2641 :             }
; 2642 :             pCurRequest->DeRef();

  00098	e1a00005	 mov         r0, r5
  0009c	eb000000	 bl          |?DeRef@CSDBusRequest@@QAAKXZ|
  000a0		 |$LN3@SDBusReque@2|

; 2647 : }

  000a0	e1a00004	 mov         r0, r4
  000a4	e24bd01c	 sub         sp, r11, #0x1C
  000a8	e89d68f0	 ldmia       sp, {r4 - r7, r11, sp, lr}
  000ac	e12fff1e	 bx          lr

			 ENDP  ; |?SDBusRequestResponse_I@CSDDevice@@UAAJPAXPAU_SD_COMMAND_RESPONSE@@@Z|, CSDDevice::SDBusRequestResponse_I

  000b0		 |$LN8@SDBusReque@2|
  000b0		 |$LN21@SDBusReque@2|

; 2638 :                 }__except(EXCEPTION_EXECUTE_HANDLER){

  000b0	e52de004	 str         lr, [sp, #-4]!
  000b4		 |$LN11@SDBusReque@2|
  000b4		 |$LN24@SDBusReque@2|
  000b4	e3a00001	 mov         r0, #1
  000b8		 |$LN10@SDBusReque@2|
  000b8	e49df004	 ldr         pc, [sp], #4
  000bc		 |$LN25@SDBusReque@2|
  000bc		 |$LN23@SDBusReque@2|
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdbusreq.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T43077| DCD	|$LN17@SDCancelBu|
	DCD	0x40002201
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDCancelBusRequest_I@CSDDevice@@UAAHPAX@Z| PROC ; CSDDevice::SDCancelBusRequest_I

; 2649 : {

  00000		 |$LN17@SDCancelBu|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M43074|
  00004	e1b06001	 movs        r6, r1
  00008	e1a07000	 mov         r7, r0

; 2650 :     SDBUS_REQUEST_HANDLE sdBusRequestHandle;
; 2651 :     sdBusRequestHandle.hValue = hRequest;
; 2652 :     BOOL fCanceledRequest = FALSE;

  0000c	e3a04000	 mov         r4, #0

; 2653 :     if (hRequest && sdBusRequestHandle.bit.sd1f == 0x1f) {

  00010	0a000019	 beq         |$LN5@SDCancelBu|
  00014	e2063b3e	 and         r3, r6, #0x3E, 22
  00018	e3530b3e	 cmp         r3, #0x3E, 22
  0001c	1a000016	 bne         |$LN5@SDCancelBu|

; 2654 :         CSDBusRequest * pCurRequest = ObjectIndex(sdBusRequestHandle.bit.sdRequestIndex);

  00020	e1a03406	 mov         r3, r6, lsl #8
  00024	e1a01c23	 mov         r1, r3, lsr #24
  00028	e2870008	 add         r0, r7, #8
  0002c	eb000000	 bl          |?ObjectIndex@?$CStaticContainer@VCSDBusRequest@@$0BAA@@@QAAPAVCSDBusRequest@@K@Z|
  00030	e1b05000	 movs        r5, r0

; 2655 :         if (pCurRequest ) {

  00034	0a000010	 beq         |$LN5@SDCancelBu|

; 2656 :             if (pCurRequest->GetRequestRandomIndex() == sdBusRequestHandle.bit.sdRandamNumber) { // this is right requerst.

  00038	e5953078	 ldr         r3, [r5, #0x78]
  0003c	e1530c26	 cmp         r3, r6, lsr #24
  00040	1a00000b	 bne         |$LN4@SDCancelBu|

; 2657 :                 CSDBusRequest * pCurRequest2 = pCurRequest ;

  00044	e1a04005	 mov         r4, r5
  00048		 |$LL3@SDCancelBu|

; 2658 :                 while (pCurRequest2 ) {
; 2659 :                     if (!pCurRequest2->IsComplete()) {

  00048	e1a00004	 mov         r0, r4
  0004c	eb000000	 bl          |?IsComplete@CSDBusRequest@@QAAHXZ|
  00050	e3500000	 cmp         r0, #0

; 2660 :                         m_sdSlot.RemoveRequest(pCurRequest2);

  00054	05973438	 ldreq       r3, [r7, #0x438]
  00058	01a01004	 moveq       r1, r4
  0005c	02830044	 addeq       r0, r3, #0x44
  00060	0b000000	 bleq        |?RemoveRequest@CSDBusReqAsyncQueue@@QAAPAVCSDBusRequest@@PAV2@@Z|

; 2661 :                     }
; 2662 :                     pCurRequest2 = pCurRequest2->GetChildListNext();

  00064	e5943070	 ldr         r3, [r4, #0x70]
  00068	e1b04003	 movs        r4, r3
  0006c	1afffff5	 bne         |$LL3@SDCancelBu|

; 2663 :                 }
; 2664 :                 fCanceledRequest = TRUE;

  00070	e3a04001	 mov         r4, #1
  00074		 |$LN4@SDCancelBu|

; 2665 :             }
; 2666 :             pCurRequest->DeRef();

  00074	e1a00005	 mov         r0, r5
  00078	eb000000	 bl          |?DeRef@CSDBusRequest@@QAAKXZ|
  0007c		 |$LN5@SDCancelBu|

; 2667 :         }
; 2668 :     }
; 2669 :     ASSERT(fCanceledRequest);
; 2670 :     DEBUGMSG(SDCARD_ZONE_ERROR && !fCanceledRequest, (_T("SDCancelBusRequest_I:  Invalid request h=0x%x\r\n"),hRequest));
; 2671 :     return fCanceledRequest;
; 2672 : }

  0007c	e1a00004	 mov         r0, r4
  00080	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00084	e12fff1e	 bx          lr
  00088		 |$M43075|

			 ENDP  ; |?SDCancelBusRequest_I@CSDDevice@@UAAHPAX@Z|, CSDDevice::SDCancelBusRequest_I

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?SwitchFunction@CSDDevice@@IAAJPAU_SD_CARD_SWITCH_FUNCTION@@H@Z| ; CSDDevice::SwitchFunction
	IMPORT	|GetTickCount|
	IMPORT	|?GetNumOfFunctionDevice@CSDSlot@@QAAKXZ| ; CSDSlot::GetNumOfFunctionDevice
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T43120| DCD	|$LN43@SwitchFunc|
	DCD	0xc0012e02

  00000			 AREA	 |.xdata|, DATA
|$T43116| DCD	0xffffffd8
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T43116|

  00008		 |?SwitchFunction@CSDDevice@@IAAJPAU_SD_CARD_SWITCH_FUNCTION@@H@Z| PROC ; CSDDevice::SwitchFunction

; 2791 : {

  00008		 |$LN43@SwitchFunc|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd084	 sub         sp, sp, #0x84
  00010		 |$M43117|
  00010	e1a06002	 mov         r6, r2
  00014	e1a08001	 mov         r8, r1
  00018	e1a07000	 mov         r7, r0
  0001c	e59f3498	 ldr         r3, [pc, #0x498]
  00020	e5933000	 ldr         r3, [r3]
  00024	e58d3080	 str         r3, [sp, #0x80]

; 2792 :     
; 2793 :     SD_API_STATUS  status = SD_API_STATUS_DEVICE_UNSUPPORTED ;
; 2794 :     DWORD dwOutputFunctioGroup = 0xffffff;
; 2795 :     if (m_DeviceType == Device_SD_Memory && m_sdSlot.GetNumOfFunctionDevice()<=1 && pSwitchData!=NULL ) {

  00028	e5973494	 ldr         r3, [r7, #0x494]
  0002c	e3e0a4ff	 mvn         r10, #0xFF, 8
  00030	e3a0415f	 mov         r4, #0x5F, 2
  00034	e3530002	 cmp         r3, #2
  00038	1a0000d4	 bne         |$LN27@SwitchFunc|
  0003c	e5970438	 ldr         r0, [r7, #0x438]
  00040	eb000000	 bl          |?GetNumOfFunctionDevice@CSDSlot@@QAAKXZ|
  00044	e3500001	 cmp         r0, #1
  00048	8a0000d0	 bhi         |$LN27@SwitchFunc|
  0004c	e3580000	 cmp         r8, #0
  00050	0a0000ce	 beq         |$LN27@SwitchFunc|

; 2796 :         DWORD dwInputFunctionGroup = pSwitchData->dwSelectedFunction & 0xffffff; 
; 2797 :         DWORD dwSCRVersion = GetBitSlice(m_CachedRegisters.SCR, sizeof(m_CachedRegisters.SCR), SD_SCR_VERSION_BIT_SLICE , SD_SCR_VERSION_SLICE_SIZE);

  00054	e598e000	 ldr         lr, [r8]
  00058	e2875b01	 add         r5, r7, #1, 22
  0005c	e3a09004	 mov         r9, #4
  00060	e00ee00a	 and         lr, lr, r10
  00064	e28510c6	 add         r1, r5, #0xC6
  00068	e3a0303c	 mov         r3, #0x3C
  0006c	e3a02008	 mov         r2, #8
  00070	e1a00007	 mov         r0, r7
  00074	e58de020	 str         lr, [sp, #0x20]
  00078	e58d9000	 str         r9, [sp]
  0007c	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  00080	e3500000	 cmp         r0, #0

; 2798 :         DWORD dwSDSpecVersion = 0 ; 
; 2799 :         if (dwSCRVersion == 0 ) {

  00084	1a000106	 bne         |$LN1@SwitchFunc|

; 2800 :             dwSDSpecVersion = GetBitSlice(m_CachedRegisters.SCR, sizeof(m_CachedRegisters.SCR), SD_SCR_SD_SPEC_BIT_SLICE , SD_SCR_SD_SPEC_SLICE_SIZE); 

  00088	e3a03038	 mov         r3, #0x38
  0008c	e3a02008	 mov         r2, #8
  00090	e28510c6	 add         r1, r5, #0xC6
  00094	e1a00007	 mov         r0, r7
  00098	e58d9000	 str         r9, [sp]
  0009c	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|

; 2801 :         }
; 2802 :         if (dwSDSpecVersion >=1 ) { // Spec 1.1 and above.

  000a0	e3500001	 cmp         r0, #1
  000a4	3a0000fe	 bcc         |$LN1@SwitchFunc|

; 2803 :             if (fReadOnly) {

  000a8	e3560000	 cmp         r6, #0
  000ac	0a00002b	 beq         |$LN24@SwitchFunc|

; 2804 :                 UCHAR SwitchStatus[512/8];
; 2805 :                 dwOutputFunctioGroup = m_dwCurFunctionGroup ;
; 2806 :                 SD_COMMAND_RESPONSE response;  // response
; 2807 :                 status = SDSynchronousBusRequest_I(SD_CMD_SWITCH_FUNCTION, dwInputFunctionGroup, SD_READ,  ResponseR1,&response,
; 2808 :                     1,sizeof(SwitchStatus),SwitchStatus,SD_SLOTRESET_REQUEST);

  000b0	e5973000	 ldr         r3, [r7]
  000b4	e3a09000	 mov         r9, #0
  000b8	e58d901c	 str         r9, [sp, #0x1C]
  000bc	e5936014	 ldr         r6, [r3, #0x14]
  000c0	e58d9018	 str         r9, [sp, #0x18]
  000c4	e3a09008	 mov         r9, #8
  000c8	e28d4040	 add         r4, sp, #0x40
  000cc	e3a0a040	 mov         r10, #0x40
  000d0	e28d5028	 add         r5, sp, #0x28
  000d4	e3a0b001	 mov         r11, #1
  000d8	e59d2020	 ldr         r2, [sp, #0x20]
  000dc	e3a03000	 mov         r3, #0
  000e0	e58d9014	 str         r9, [sp, #0x14]
  000e4	e3a01006	 mov         r1, #6
  000e8	e1a00007	 mov         r0, r7
  000ec	e58d4010	 str         r4, [sp, #0x10]
  000f0	e58da00c	 str         r10, [sp, #0xC]
  000f4	e58db008	 str         r11, [sp, #8]
  000f8	e58d5004	 str         r5, [sp, #4]
  000fc	e58db000	 str         r11, [sp]
  00100	e1a0e00f	 mov         lr, pc
  00104	e12fff16	 bx          r6
  00108	e1b04000	 movs        r4, r0

; 2809 :                 ASSERT(sizeof(SwitchStatus) == sizeof(pSwitchData->clientData));
; 2810 :                 if (SD_API_SUCCESS(status)) {

  0010c	4a0000e4	 bmi         |$LN1@SwitchFunc|

; 2811 :                     SwapByte(SwitchStatus,sizeof(SwitchStatus));

  00110	e3a02040	 mov         r2, #0x40
  00114	e28d1040	 add         r1, sp, #0x40
  00118	e1a00007	 mov         r0, r7
  0011c	eb000000	 bl          |?SwapByte@CSDDevice@@IAAXPAEK@Z|

; 2812 :                     dwOutputFunctioGroup = GetBitSlice(SwitchStatus,sizeof(SwitchStatus),376,4*6);

  00120	e3a03018	 mov         r3, #0x18
  00124	e58d3000	 str         r3, [sp]
  00128	e3a03f5e	 mov         r3, #0x5E, 30
  0012c	e3a02040	 mov         r2, #0x40
  00130	e28d1040	 add         r1, sp, #0x40
  00134	e1a00007	 mov         r0, r7
  00138	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  0013c	e1a0a000	 mov         r10, r0

; 2813 :                     pSwitchData->dwMaxCurrentAllowed = GetBitSlice(SwitchStatus,sizeof(SwitchStatus),496,16); 

  00140	e3a0e010	 mov         lr, #0x10
  00144	e1a00007	 mov         r0, r7
  00148	e3a03e1f	 mov         r3, #0x1F, 28
  0014c	e3a02040	 mov         r2, #0x40
  00150	e28d1040	 add         r1, sp, #0x40
  00154	e58de000	 str         lr, [sp]
  00158	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|

; 2814 :                     memcpy(pSwitchData->clientData , SwitchStatus, sizeof(pSwitchData->clientData));
; 2815 :                 }
; 2816 :             }
; 2817 :             else {

  0015c	ea0000c8	 b           |$LN40@SwitchFunc|
  00160		 |$LN24@SwitchFunc|

; 2818 :                 m_sdSlot.m_RequestLock.Lock(); 

  00160	e5973438	 ldr         r3, [r7, #0x438]
  00164	e28300e8	 add         r0, r3, #0xE8
  00168	eb000000	 bl          EnterCriticalSection

; 2819 :                 DWORD dwStartTick = GetTickCount();

  0016c	eb000000	 bl          GetTickCount
  00170	e1a03000	 mov         r3, r0

; 2823 :                     // Send out CMD6 Mode 0 to read it.
; 2824 :                     UCHAR SwitchStatus[512/8];
; 2825 :                     SD_COMMAND_RESPONSE response;  // response
; 2826 :                     status = SDSynchronousBusRequest_I(SD_CMD_SWITCH_FUNCTION, dwInputFunctionGroup, SD_READ,  ResponseR1,&response,
; 2827 :                         1,sizeof(SwitchStatus),SwitchStatus,SD_SLOTRESET_REQUEST);
; 2828 :                     if (SD_API_SUCCESS(status)) {
; 2829 :                         SwapByte(SwitchStatus,sizeof(SwitchStatus));
; 2830 :                         dwOutputFunctioGroup = GetBitSlice(SwitchStatus,sizeof(SwitchStatus),376,4*6);
; 2831 :                         DWORD dwCurrentRequired = GetBitSlice(SwitchStatus,sizeof(SwitchStatus),496,16); 
; 2832 :                         if (dwOutputFunctioGroup == dwInputFunctionGroup && dwCurrentRequired<= pSwitchData->dwMaxCurrentAllowed) { // it is ready to set.
; 2833 :                             status = SDSynchronousBusRequest_I(SD_CMD_SWITCH_FUNCTION, dwInputFunctionGroup|0x80000000, SD_READ,  
; 2834 :                                 ResponseR1,&response, 1,sizeof(SwitchStatus),SwitchStatus,SD_SLOTRESET_REQUEST);
; 2835 :                             if (SD_API_SUCCESS(status)) {

  00174	e59d6020	 ldr         r6, [sp, #0x20]
  00178	e58d3024	 str         r3, [sp, #0x24]
  0017c	e3a05001	 mov         r5, #1
  00180	e3a0410b	 mov         r4, #0xB, 2
  00184	e3a09000	 mov         r9, #0
  00188	e3a0b001	 mov         r11, #1
  0018c		 |$LL21@SwitchFunc|
  0018c	eb000000	 bl          GetTickCount
  00190	e59d3024	 ldr         r3, [sp, #0x24]
  00194	e5982008	 ldr         r2, [r8, #8]
  00198	e0403003	 sub         r3, r0, r3
  0019c	e1530002	 cmp         r3, r2
  001a0	2a000076	 bcs         |$LN20@SwitchFunc|
  001a4	e1a02006	 mov         r2, r6
  001a8	e3a06008	 mov         r6, #8
  001ac	e58d6014	 str         r6, [sp, #0x14]
  001b0	e28d6040	 add         r6, sp, #0x40
  001b4	e5971000	 ldr         r1, [r7]
  001b8	e58d6010	 str         r6, [sp, #0x10]
  001bc	e3a06040	 mov         r6, #0x40
  001c0	e58d600c	 str         r6, [sp, #0xC]
  001c4	e5914014	 ldr         r4, [r1, #0x14]
  001c8	e28d6028	 add         r6, sp, #0x28
  001cc	e58d6004	 str         r6, [sp, #4]
  001d0	e3a03000	 mov         r3, #0
  001d4	e3a01006	 mov         r1, #6
  001d8	e1a00007	 mov         r0, r7
  001dc	e58d901c	 str         r9, [sp, #0x1C]
  001e0	e58d9018	 str         r9, [sp, #0x18]
  001e4	e58db008	 str         r11, [sp, #8]
  001e8	e58db000	 str         r11, [sp]
  001ec	e1a0e00f	 mov         lr, pc
  001f0	e12fff14	 bx          r4
  001f4	e59d6020	 ldr         r6, [sp, #0x20]
  001f8	e1b04000	 movs        r4, r0
  001fc	4a000056	 bmi         |$LN19@SwitchFunc|
  00200	e3a02040	 mov         r2, #0x40
  00204	e28d1040	 add         r1, sp, #0x40
  00208	e1a00007	 mov         r0, r7
  0020c	eb000000	 bl          |?SwapByte@CSDDevice@@IAAXPAEK@Z|
  00210	e3a0e018	 mov         lr, #0x18
  00214	e3a03f5e	 mov         r3, #0x5E, 30
  00218	e3a02040	 mov         r2, #0x40
  0021c	e28d1040	 add         r1, sp, #0x40
  00220	e1a00007	 mov         r0, r7
  00224	e58de000	 str         lr, [sp]
  00228	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  0022c	e1a0a000	 mov         r10, r0
  00230	e3a0e010	 mov         lr, #0x10
  00234	e1a00007	 mov         r0, r7
  00238	e3a03e1f	 mov         r3, #0x1F, 28
  0023c	e3a02040	 mov         r2, #0x40
  00240	e28d1040	 add         r1, sp, #0x40
  00244	e58de000	 str         lr, [sp]
  00248	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  0024c	e15a0006	 cmp         r10, r6
  00250	1a000032	 bne         |$LN18@SwitchFunc|
  00254	e5983004	 ldr         r3, [r8, #4]
  00258	e1500003	 cmp         r0, r3
  0025c	8a00002f	 bhi         |$LN18@SwitchFunc|
  00260	e3862102	 orr         r2, r6, #2, 2
  00264	e3a06008	 mov         r6, #8
  00268	e58d6014	 str         r6, [sp, #0x14]
  0026c	e28d6040	 add         r6, sp, #0x40
  00270	e5971000	 ldr         r1, [r7]
  00274	e58d6010	 str         r6, [sp, #0x10]
  00278	e3a06040	 mov         r6, #0x40
  0027c	e58d600c	 str         r6, [sp, #0xC]
  00280	e5914014	 ldr         r4, [r1, #0x14]
  00284	e28d6028	 add         r6, sp, #0x28
  00288	e58d6004	 str         r6, [sp, #4]
  0028c	e3a03000	 mov         r3, #0
  00290	e3a01006	 mov         r1, #6
  00294	e1a00007	 mov         r0, r7
  00298	e58d901c	 str         r9, [sp, #0x1C]
  0029c	e58d9018	 str         r9, [sp, #0x18]
  002a0	e58db008	 str         r11, [sp, #8]
  002a4	e58db000	 str         r11, [sp]
  002a8	e1a0e00f	 mov         lr, pc
  002ac	e12fff14	 bx          r4
  002b0	e59d6020	 ldr         r6, [sp, #0x20]
  002b4	e3500000	 cmp         r0, #0
  002b8	4a000012	 bmi         |$LN17@SwitchFunc|

; 2836 :                                 Sleep(1);

  002bc	e3a00001	 mov         r0, #1
  002c0	eb000000	 bl          Sleep

; 2837 :                                 SwapByte(SwitchStatus,sizeof(SwitchStatus));

  002c4	e3a02040	 mov         r2, #0x40
  002c8	e28d1040	 add         r1, sp, #0x40
  002cc	e1a00007	 mov         r0, r7
  002d0	eb000000	 bl          |?SwapByte@CSDDevice@@IAAXPAEK@Z|

; 2838 :                                 m_dwCurFunctionGroup = dwOutputFunctioGroup = GetBitSlice(SwitchStatus,sizeof(SwitchStatus),376,4*6);

  002d4	e3a0e018	 mov         lr, #0x18
  002d8	e3a03f5e	 mov         r3, #0x5E, 30
  002dc	e3a02040	 mov         r2, #0x40
  002e0	e28d1040	 add         r1, sp, #0x40
  002e4	e1a00007	 mov         r0, r7
  002e8	e58de000	 str         lr, [sp]
  002ec	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  002f0	e1a0a000	 mov         r10, r0
  002f4	e587a428	 str         r10, [r7, #0x428]

; 2839 :                                 if (dwOutputFunctioGroup == dwInputFunctionGroup) {

  002f8	e15a0006	 cmp         r10, r6
  002fc	0a00001a	 beq         |$LN39@SwitchFunc|

; 2843 :                                     fContinue = FALSE;
; 2844 :                                 }
; 2845 :                                 else 
; 2846 :                                     status = SD_API_STATUS_DEVICE_BUSY;

  00300	e3a0410b	 mov         r4, #0xB, 2

; 2847 :                             }
; 2848 :                             else{ // This is serious error. device now is in unknow state. we need reset to recover.

  00304	ea000015	 b           |$LN5@SwitchFunc|
  00308		 |$LN17@SwitchFunc|

; 2849 :                                 ASSERT(FALSE);
; 2850 :                                 m_sdSlot.m_SlotState = SlotInitFailed;

  00308	e5973438	 ldr         r3, [r7, #0x438]

; 2851 :                                 m_dwCurFunctionGroup = 0 ; // Back to default.
; 2852 :                                 fContinue = FALSE;
; 2853 :                                 status = SD_API_STATUS_ACCESS_VIOLATION ;

  0030c	e3a02004	 mov         r2, #4
  00310	e3a04117	 mov         r4, #0x17, 2
  00314	e5832084	 str         r2, [r3, #0x84]
  00318	e5879428	 str         r9, [r7, #0x428]

; 2854 :                             }
; 2855 :                                 
; 2856 :                         }
; 2857 :                         else {

  0031c	ea00000e	 b           |$LN19@SwitchFunc|
  00320		 |$LN18@SwitchFunc|

; 2858 :                             DWORD dwCheck = dwOutputFunctioGroup;

  00320	e1a0100a	 mov         r1, r10

; 2859 :                             for (DWORD dwIndex=0; dwIndex<6; dwIndex++) {

  00324	e3a02000	 mov         r2, #0
  00328		 |$LL12@SwitchFunc|

; 2860 :                                 if ((dwCheck & 0xf) == 0xf) { // unsported function.

  00328	e201300f	 and         r3, r1, #0xF
  0032c	e353000f	 cmp         r3, #0xF
  00330	0a000003	 beq         |$LN36@SwitchFunc|
  00334	e2822001	 add         r2, r2, #1
  00338	e3520006	 cmp         r2, #6

; 2861 :                                     break;
; 2862 :                                 }
; 2863 :                                 else {
; 2864 :                                     dwCheck >>= 4;

  0033c	e1a01221	 mov         r1, r1, lsr #4
  00340	3afffff8	 bcc         |$LL12@SwitchFunc|
  00344		 |$LN36@SwitchFunc|

; 2865 :                                 }
; 2866 :                             }
; 2867 :                             if (dwIndex<6 || dwCurrentRequired>pSwitchData->dwMaxCurrentAllowed) { // failed.

  00344	e3520006	 cmp         r2, #6
  00348	3a000002	 bcc         |$LN6@SwitchFunc|
  0034c	e5983004	 ldr         r3, [r8, #4]
  00350	e1500003	 cmp         r0, r3
  00354	9a000001	 bls         |$LN5@SwitchFunc|
  00358		 |$LN6@SwitchFunc|

; 2868 :                                 status = SD_API_STATUS_DEVICE_UNSUPPORTED ;

  00358	e3a0415f	 mov         r4, #0x5F, 2
  0035c		 |$LN19@SwitchFunc|

; 2869 :                                 fContinue = FALSE;
; 2870 :                             }
; 2871 :                         }
; 2872 :                     }
; 2873 :                     else 
; 2874 :                         fContinue = FALSE;

  0035c	e3a05000	 mov         r5, #0
  00360		 |$LN5@SwitchFunc|

; 2820 :                 BOOL fContinue = TRUE;
; 2821 :                 status = SD_API_STATUS_DEVICE_BUSY;
; 2822 :                 while (fContinue && GetTickCount()- dwStartTick  < pSwitchData->dwTimeOut ) {

  00360	e3550000	 cmp         r5, #0
  00364	1affff88	 bne         |$LL21@SwitchFunc|
  00368	ea000004	 b           |$LN20@SwitchFunc|
  0036c		 |$LN39@SwitchFunc|

; 2840 :                                     ASSERT(sizeof(SwitchStatus) == sizeof(pSwitchData->clientData));
; 2841 :                                     memcpy(pSwitchData->clientData , SwitchStatus, sizeof(pSwitchData->clientData));

  0036c	e288000c	 add         r0, r8, #0xC
  00370	e28d1040	 add         r1, sp, #0x40
  00374	e3a02040	 mov         r2, #0x40
  00378	eb000000	 bl          memcpy

; 2842 :                                     status = SD_API_STATUS_SUCCESS;

  0037c	e3a04000	 mov         r4, #0
  00380		 |$LN20@SwitchFunc|

; 2875 :                 }
; 2876 :                 m_sdSlot.m_RequestLock.Unlock();

  00380	e5973438	 ldr         r3, [r7, #0x438]
  00384	e28300e8	 add         r0, r3, #0xE8
  00388	eb000000	 bl          LeaveCriticalSection

; 2877 :             }
; 2878 :             
; 2879 :         }
; 2880 :     }

  0038c	ea000042	 b           |$LN2@SwitchFunc|
  00390		 |$LN27@SwitchFunc|

; 2881 : 	else if (m_DeviceType == Device_MMC && m_sdSlot.GetNumOfFunctionDevice()<=1 && pSwitchData!=NULL ) {

  00390	e5973494	 ldr         r3, [r7, #0x494]
  00394	e3530001	 cmp         r3, #1
  00398	1a000041	 bne         |$LN1@SwitchFunc|
  0039c	e5970438	 ldr         r0, [r7, #0x438]
  003a0	eb000000	 bl          |?GetNumOfFunctionDevice@CSDSlot@@QAAKXZ|
  003a4	e3500001	 cmp         r0, #1
  003a8	8a00003d	 bhi         |$LN1@SwitchFunc|
  003ac	e3580000	 cmp         r8, #0
  003b0	0a00003b	 beq         |$LN1@SwitchFunc|

; 2882 :         DWORD dwInputFunctionGroup = pSwitchData->dwSelectedFunction & 0xffffff; 
; 2883 :         DWORD dwSCRVersion = GetBitSlice(m_CachedRegisters.SCR, sizeof(m_CachedRegisters.SCR), SD_SCR_VERSION_BIT_SLICE , SD_SCR_VERSION_SLICE_SIZE);

  003b4	e2871b01	 add         r1, r7, #1, 22
  003b8	e5986000	 ldr         r6, [r8]
  003bc	e3a0e004	 mov         lr, #4
  003c0	e28110c6	 add         r1, r1, #0xC6
  003c4	e3a0303c	 mov         r3, #0x3C
  003c8	e3a02008	 mov         r2, #8
  003cc	e1a00007	 mov         r0, r7
  003d0	e58de000	 str         lr, [sp]
  003d4	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|

; 2884 :         DWORD dwSDSpecVersion = 0 ;
; 2885 : 
; 2886 :         UCHAR SwitchStatus[512/8];
; 2887 :         dwOutputFunctioGroup = m_dwCurFunctionGroup ;
; 2888 :         SD_COMMAND_RESPONSE response;  // response
; 2889 :         status = SDSynchronousBusRequest_I(SD_CMD_SWITCH_FUNCTION, dwInputFunctionGroup, SD_COMMAND,  ResponseR1b,&response,
; 2890 :             1,sizeof(SwitchStatus),NULL,SD_SLOTRESET_REQUEST);

  003d8	e5973000	 ldr         r3, [r7]
  003dc	e006200a	 and         r2, r6, r10
  003e0	e3a06040	 mov         r6, #0x40
  003e4	e28d4028	 add         r4, sp, #0x28
  003e8	e58d600c	 str         r6, [sp, #0xC]
  003ec	e5935014	 ldr         r5, [r3, #0x14]
  003f0	e58d4004	 str         r4, [sp, #4]
  003f4	e3a06001	 mov         r6, #1
  003f8	e3a0b008	 mov         r11, #8
  003fc	e3a09000	 mov         r9, #0
  00400	e3a04002	 mov         r4, #2
  00404	e58d6008	 str         r6, [sp, #8]
  00408	e3a03002	 mov         r3, #2
  0040c	e3a01006	 mov         r1, #6
  00410	e1a00007	 mov         r0, r7
  00414	e58d901c	 str         r9, [sp, #0x1C]
  00418	e58d9018	 str         r9, [sp, #0x18]
  0041c	e58db014	 str         r11, [sp, #0x14]
  00420	e58d9010	 str         r9, [sp, #0x10]
  00424	e58d4000	 str         r4, [sp]
  00428	e1a0e00f	 mov         lr, pc
  0042c	e12fff15	 bx          r5
  00430	e1b04000	 movs        r4, r0

; 2891 :         ASSERT(sizeof(SwitchStatus) == sizeof(pSwitchData->clientData));
; 2892 :         if (SD_API_SUCCESS(status)) {

  00434	4a00001a	 bmi         |$LN1@SwitchFunc|

; 2893 :             SwapByte(SwitchStatus,sizeof(SwitchStatus));

  00438	e3a02040	 mov         r2, #0x40
  0043c	e28d1040	 add         r1, sp, #0x40
  00440	e1a00007	 mov         r0, r7
  00444	eb000000	 bl          |?SwapByte@CSDDevice@@IAAXPAEK@Z|

; 2894 :             dwOutputFunctioGroup = GetBitSlice(SwitchStatus,sizeof(SwitchStatus),376,4*6);

  00448	e3a03018	 mov         r3, #0x18
  0044c	e58d3000	 str         r3, [sp]
  00450	e3a03f5e	 mov         r3, #0x5E, 30
  00454	e3a02040	 mov         r2, #0x40
  00458	e28d1040	 add         r1, sp, #0x40
  0045c	e1a00007	 mov         r0, r7
  00460	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  00464	e1a0a000	 mov         r10, r0

; 2895 :             pSwitchData->dwMaxCurrentAllowed = GetBitSlice(SwitchStatus,sizeof(SwitchStatus),496,16); 

  00468	e3a0e010	 mov         lr, #0x10
  0046c	e1a00007	 mov         r0, r7
  00470	e3a03e1f	 mov         r3, #0x1F, 28
  00474	e3a02040	 mov         r2, #0x40
  00478	e28d1040	 add         r1, sp, #0x40
  0047c	e58de000	 str         lr, [sp]
  00480	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|
  00484		 |$LN40@SwitchFunc|
  00484	e1a03000	 mov         r3, r0

; 2896 :             memcpy(pSwitchData->clientData , SwitchStatus, sizeof(pSwitchData->clientData));

  00488	e288000c	 add         r0, r8, #0xC
  0048c	e3a02040	 mov         r2, #0x40
  00490	e28d1040	 add         r1, sp, #0x40
  00494	e5883004	 str         r3, [r8, #4]
  00498	eb000000	 bl          memcpy
  0049c		 |$LN2@SwitchFunc|

; 2897 :         }
; 2898 : 	}
; 2899 : 
; 2900 :     if (SD_API_SUCCESS(status) && pSwitchData)

  0049c	e3540000	 cmp         r4, #0

; 2901 :         pSwitchData->dwSelectedFunction = dwOutputFunctioGroup ;

  004a0	5588a000	 strpl       r10, [r8]
  004a4		 |$LN1@SwitchFunc|

; 2902 : 
; 2903 :     return status;

  004a4	e59d0080	 ldr         r0, [sp, #0x80]
  004a8	eb000000	 bl          __security_check_cookie

; 2904 : }

  004ac	e1a00004	 mov         r0, r4
  004b0	e28dd084	 add         sp, sp, #0x84
  004b4	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  004b8	e12fff1e	 bx          lr
  004bc		 |$LN44@SwitchFunc|
  004bc		 |$LN45@SwitchFunc|
  004bc	00000000	 DCD         |__security_cookie|
  004c0		 |$M43118|

			 ENDP  ; |?SwitchFunction@CSDDevice@@IAAJPAU_SD_CARD_SWITCH_FUNCTION@@H@Z|, CSDDevice::SwitchFunction

; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T43174| DCD	|$LN28@Detach|
	DCD	0x40004702
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Detach@CSDDevice@@UAAHXZ| PROC	; CSDDevice::Detach

; 105  : {

  00000		 |$LN28@Detach|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M43171|
  00008	e1a04000	 mov         r4, r0

; 106  :     Lock();

  0000c	e2845008	 add         r5, r4, #8
  00010	e1a00005	 mov         r0, r5
  00014	eb000000	 bl          EnterCriticalSection

; 107  :     if (m_fAttached) {

  00018	e5943444	 ldr         r3, [r4, #0x444]
  0001c	e3530000	 cmp         r3, #0
  00020	0a000037	 beq         |$LN2@Detach|

; 108  :         m_fAttached = FALSE;
; 109  :         SDIOConnectDisconnectInterrupt(NULL,FALSE);

  00024	e5943000	 ldr         r3, [r4]
  00028	e3a06000	 mov         r6, #0
  0002c	e3a02000	 mov         r2, #0
  00030	e5933028	 ldr         r3, [r3, #0x28]
  00034	e3a01000	 mov         r1, #0
  00038	e1a00004	 mov         r0, r4
  0003c	e5846444	 str         r6, [r4, #0x444]
  00040	e1a0e00f	 mov         lr, pc
  00044	e12fff13	 bx          r3

; 110  :         SDUnloadDevice();

  00048	e1a00004	 mov         r0, r4
  0004c	eb000000	 bl          |?SDUnloadDevice@CSDDevice@@QAAHXZ|

; 111  :         for (DWORD dwIndex=0; dwIndex<m_dwArraySize ; dwIndex++ ) {

  00050	e594341c	 ldr         r3, [r4, #0x41C]
  00054	e3a06000	 mov         r6, #0
  00058	e3530000	 cmp         r3, #0
  0005c	9a000028	 bls         |$LN2@Detach|
  00060	e3a034ff	 mov         r3, #0xFF, 8
  00064	e59d8000	 ldr         r8, [sp]
  00068	e3839b3e	 orr         r9, r3, #0x3E, 22
  0006c		 |$LL4@Detach|

; 112  :             if( m_rgObjectArray[m_dwCurSearchIndex] ) {

  0006c	e5947424	 ldr         r7, [r4, #0x424]
  00070	e0843107	 add         r3, r4, r7, lsl #2
  00074	e593301c	 ldr         r3, [r3, #0x1C]
  00078	e3530000	 cmp         r3, #0
  0007c	0a00001c	 beq         |$LN3@Detach|

; 113  :                 // After this point the status should return during the completion.
; 114  :                 SDBUS_REQUEST_HANDLE sdBusRequestHandle ;
; 115  :                 sdBusRequestHandle.bit.sdBusIndex = m_sdSlot.GetHost().GetIndex();

  00080	e5943438	 ldr         r3, [r4, #0x438]

; 116  :                 sdBusRequestHandle.bit.sdSlotIndex = m_sdSlot.GetSlotIndex();
; 117  :                 sdBusRequestHandle.bit.sdFunctionIndex = m_FuncionIndex;
; 118  :                 sdBusRequestHandle.bit.sdRequestIndex = dwIndex;
; 119  :                 sdBusRequestHandle.bit.sd1f = 0x1f;

  00084	e594143c	 ldr         r1, [r4, #0x43C]
  00088	e20600ff	 and         r0, r6, #0xFF
  0008c	e593207c	 ldr         r2, [r3, #0x7C]
  00090	e593e080	 ldr         lr, [r3, #0x80]
  00094	e2013007	 and         r3, r1, #7
  00098	e592205c	 ldr         r2, [r2, #0x5C]
  0009c	e1833400	 orr         r3, r3, r0, lsl #8
  000a0	e38310f8	 orr         r1, r3, #0xF8
  000a4	e20e300f	 and         r3, lr, #0xF

; 120  :                 sdBusRequestHandle.bit.sdRandamNumber =RawObjectIndex(m_dwCurSearchIndex)->GetRequestRandomIndex();

  000a8	e5950414	 ldr         r0, [r5, #0x414]
  000ac	e202200f	 and         r2, r2, #0xF
  000b0	e1833201	 orr         r3, r3, r1, lsl #4
  000b4	e1822203	 orr         r2, r2, r3, lsl #4
  000b8	e0083009	 and         r3, r8, r9
  000bc	e1570000	 cmp         r7, r0
  000c0	e182e003	 orr         lr, r2, r3
  000c4	30853107	 addcc       r3, r5, r7, lsl #2
  000c8	35933014	 ldrcc       r3, [r3, #0x14]
  000cc	23a03000	 movcs       r3, #0
  000d0	e5932078	 ldr         r2, [r3, #0x78]

; 121  :                 
; 122  :                 SDFreeBusRequest_I(sdBusRequestHandle.hValue);

  000d4	e5941000	 ldr         r1, [r4]
  000d8	e3ce34ff	 bic         r3, lr, #0xFF, 8
  000dc	e1838c02	 orr         r8, r3, r2, lsl #24
  000e0	e591301c	 ldr         r3, [r1, #0x1C]
  000e4	e1a01008	 mov         r1, r8
  000e8	e1a00004	 mov         r0, r4
  000ec	e1a0e00f	 mov         lr, pc
  000f0	e12fff13	 bx          r3
  000f4		 |$LN3@Detach|
  000f4	e594341c	 ldr         r3, [r4, #0x41C]
  000f8	e2866001	 add         r6, r6, #1
  000fc	e1560003	 cmp         r6, r3
  00100	3affffd9	 bcc         |$LL4@Detach|
  00104		 |$LN2@Detach|

; 123  :             }
; 124  :         }
; 125  :     }
; 126  :     Unlock();    

  00104	e1a00005	 mov         r0, r5
  00108	eb000000	 bl          LeaveCriticalSection

; 127  :     return FALSE;

  0010c	e3a00000	 mov         r0, #0

; 128  : }

  00110	e28dd004	 add         sp, sp, #4
  00114	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00118	e12fff1e	 bx          lr
  0011c		 |$M43172|

			 ENDP  ; |?Detach@CSDDevice@@UAAHXZ|, CSDDevice::Detach

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?DetectSDCard@CSDDevice@@QAAJAAK@Z|	; CSDDevice::DetectSDCard
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T43260| DCD	|$LN82@DetectSDCa|
	DCD	0xc000ac02

  00000			 AREA	 |.xdata|, DATA
|$T43256| DCD	0xffffffe0
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T43256|

  00008		 |?DetectSDCard@CSDDevice@@QAAJAAK@Z| PROC ; CSDDevice::DetectSDCard

; 175  : {

  00008		 |$LN82@DetectSDCa|
  00008	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  0000c	e24dd030	 sub         sp, sp, #0x30
  00010		 |$M43257|
  00010	e1a05001	 mov         r5, r1
  00014	e1a06000	 mov         r6, r0
  00018	e59f3294	 ldr         r3, [pc, #0x294]
  0001c	e5933000	 ldr         r3, [r3]
  00020	e58d302c	 str         r3, [sp, #0x2C]

; 176  :     if (m_FuncionIndex!=0) {

  00024	e596343c	 ldr         r3, [r6, #0x43C]
  00028	e3530000	 cmp         r3, #0
  0002c	0a000003	 beq         |$LN24@DetectSDCa|

; 177  :         ASSERT(FALSE);
; 178  :         return SD_API_STATUS_DEVICE_UNSUPPORTED;

  00030	e59d002c	 ldr         r0, [sp, #0x2C]
  00034	eb000000	 bl          __security_check_cookie
  00038	e3a0415f	 mov         r4, #0x5F, 2
  0003c	ea000098	 b           |$LN25@DetectSDCa|
  00040		 |$LN24@DetectSDCa|

; 179  :     }
; 180  :     SD_API_STATUS status = SD_API_STATUS_DEVICE_UNSUPPORTED;
; 181  :     SD_COMMAND_RESPONSE  response;                       // response buffer
; 182  :     dwNumOfFunct = 1;
; 183  :     SDCARD_DEVICE_TYPE deviceType = Device_Unknown;  
; 184  :     
; 185  :     // Detect SD IO Card.
; 186  :     status = SendSDCommand(SD_CMD_IO_OP_COND, 0,ResponseR4,&response);

  00040	e28d3014	 add         r3, sp, #0x14
  00044	e58d3000	 str         r3, [sp]
  00048	e3a08001	 mov         r8, #1
  0004c	e3a03005	 mov         r3, #5
  00050	e3a02000	 mov         r2, #0
  00054	e3a01005	 mov         r1, #5
  00058	e1a00006	 mov         r0, r6
  0005c	e5858000	 str         r8, [r5]
  00060	e3a07000	 mov         r7, #0
  00064	eb000000	 bl          |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|
  00068	e1b04000	 movs        r4, r0
  0006c	e3a09000	 mov         r9, #0

; 187  :     if (SD_API_SUCCESS_RESPONSE_TIMEOUT_OK(status)) {

  00070	5a000003	 bpl         |$LN78@DetectSDCa|
  00074	e3540153	 cmp         r4, #0x53, 2
  00078	1a000021	 bne         |$LN16@DetectSDCa|

; 199  :                     status = SD_API_STATUS_SUCCESS;

  0007c	e3a04000	 mov         r4, #0

; 200  :                 }
; 201  :             }
; 202  :             else // Only one function.

  00080	ea00001f	 b           |$LN16@DetectSDCa|
  00084		 |$LN78@DetectSDCa|

; 188  :         if (SD_API_SUCCESS(status)) {
; 189  :             UpdateCachedRegisterFromResponse(SD_INFO_REGISTER_IO_OCR,&response);
; 190  :             DWORD   dwNumFunctions = SD_GET_NUMBER_OF_FUNCTIONS(&response);

  00084	e5dd201c	 ldrb        r2, [sp, #0x1C]
  00088	e5dd001b	 ldrb        r0, [sp, #0x1B]
  0008c	e5dde01a	 ldrb        lr, [sp, #0x1A]
  00090	e5dd1019	 ldrb        r1, [sp, #0x19]
  00094	e1a03c82	 mov         r3, r2, lsl #25
  00098	e1b03ea3	 movs        r3, r3, lsr #29

; 191  :             BOOL    fMemoryPresent = SD_MEMORY_PRESENT_WITH_IO(&response);
; 192  :             // Note. dwNumOfFunc does not include function 0. SDIO 3.3
; 193  :             dwNumOfFunct = dwNumFunctions + 1; 

  0009c	e2833001	 add         r3, r3, #1
  000a0	e1a02e02	 mov         r2, r2, lsl #28
  000a4	e5c604a4	 strb        r0, [r6, #0x4A4]
  000a8	e5c6e4a3	 strb        lr, [r6, #0x4A3]
  000ac	e5c614a2	 strb        r1, [r6, #0x4A2]
  000b0	e5853000	 str         r3, [r5]
  000b4	e1a05fa2	 mov         r5, r2, lsr #31

; 194  :             if (dwNumFunctions ) {

  000b8	0a00000f	 beq         |$LN20@DetectSDCa|

; 195  :                 SetDeviceType(deviceType = (fMemoryPresent? Device_SD_Combo: Device_SD_IO));

  000bc	e3550000	 cmp         r5, #0
  000c0	13a07004	 movne       r7, #4
  000c4	03a07003	 moveq       r7, #3

; 196  :                 status = SetOperationVoltage(Device_SD_IO, TRUE);

  000c8	e3a02001	 mov         r2, #1
  000cc	e3a01003	 mov         r1, #3
  000d0	e1a00006	 mov         r0, r6
  000d4	e5867494	 str         r7, [r6, #0x494]
  000d8	eb000000	 bl          |?SetOperationVoltage@CSDDevice@@QAAJW4_SDCARD_DEVICE_TYPE@@H@Z|
  000dc	e1b04000	 movs        r4, r0

; 197  :                 if (!SD_API_SUCCESS(status) && fMemoryPresent) {

  000e0	5a000009	 bpl         |$LN77@DetectSDCa|
  000e4	e3550000	 cmp         r5, #0
  000e8	0a000005	 beq         |$LN16@DetectSDCa|

; 198  :                     SetDeviceType(deviceType = Device_Unknown); // Try Memory

  000ec	e3a07000	 mov         r7, #0
  000f0	e5869494	 str         r9, [r6, #0x494]

; 199  :                     status = SD_API_STATUS_SUCCESS;

  000f4	e3a04000	 mov         r4, #0

; 200  :                 }
; 201  :             }
; 202  :             else // Only one function.

  000f8	ea000001	 b           |$LN16@DetectSDCa|
  000fc		 |$LN20@DetectSDCa|

; 203  :                 if (!fMemoryPresent) { // This is unsported.

  000fc	e3550000	 cmp         r5, #0

; 204  :                     status = SD_API_STATUS_DEVICE_UNSUPPORTED ;

  00100	03a0415f	 moveq       r4, #0x5F, 2
  00104		 |$LN16@DetectSDCa|

; 205  :                 }
; 206  : 
; 207  :         }
; 208  :         else {
; 209  :             DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDBusDriver: SDIO Card check timeout, moving on \n"))); 
; 210  :             status = SD_API_STATUS_SUCCESS; // Timeout is OK . we will continue to skan memory.
; 211  :         }
; 212  :     }
; 213  :     // Detect SD MMC 
; 214  :     if (SD_API_SUCCESS(status) && (deviceType == Device_Unknown || deviceType == Device_SD_Combo )) { // We have to do other than SD_IO.

  00104	e3540000	 cmp         r4, #0
  00108	4a000063	 bmi         |$LN1@DetectSDCa|
  0010c		 |$LN77@DetectSDCa|
  0010c	e3570000	 cmp         r7, #0
  00110	0a000001	 beq         |$LN14@DetectSDCa|
  00114	e3570004	 cmp         r7, #4
  00118	1a00005f	 bne         |$LN1@DetectSDCa|
  0011c		 |$LN14@DetectSDCa|

; 215  :         // Intiaize 
; 216  :          status = SendSDCommand( SD_CMD_GO_IDLE_STATE,  0x00000000,  NoResponse, NULL);

  0011c	e3a03000	 mov         r3, #0
  00120	e3a02000	 mov         r2, #0
  00124	e3a01000	 mov         r1, #0
  00128	e1a00006	 mov         r0, r6
  0012c	e58d9000	 str         r9, [sp]
  00130	eb000000	 bl          |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|
  00134	e1a04000	 mov         r4, r0

; 217  :         BOOL fValid20Card = IsValid20Card();

  00138	e1a00006	 mov         r0, r6
  0013c	eb000000	 bl          |?IsValid20Card@CSDDevice@@IAAHXZ|
  00140	e1a05000	 mov         r5, r0

; 218  :         if (SD_API_SUCCESS(status)) {

  00144	e3540000	 cmp         r4, #0
  00148	4a00004e	 bmi         |$LN75@DetectSDCa|

; 219  :             if (deviceType != Device_SD_Combo) {

  0014c	e3570004	 cmp         r7, #4
  00150	0a00001c	 beq         |$LN8@DetectSDCa|

; 220  :                 // Detect MMC Card.
; 221  :                 status = SendSDCommand( SD_CMD_MMC_SEND_OPCOND,m_sdSlot.VoltageWindowMask, ResponseR3, &response);

  00154	e5962438	 ldr         r2, [r6, #0x438]
  00158	e28de014	 add         lr, sp, #0x14
  0015c	e3a03004	 mov         r3, #4
  00160	e592206c	 ldr         r2, [r2, #0x6C]
  00164	e3a01001	 mov         r1, #1
  00168	e1a00006	 mov         r0, r6
  0016c	e58de000	 str         lr, [sp]
  00170	eb000000	 bl          |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|
  00174	e1b04000	 movs        r4, r0

; 222  :                 if (SD_API_SUCCESS_RESPONSE_TIMEOUT_OK(status)) {

  00178	5a000003	 bpl         |$LN76@DetectSDCa|
  0017c	e3540153	 cmp         r4, #0x53, 2
  00180	1a000010	 bne         |$LN8@DetectSDCa|

; 227  :                     }
; 228  :                     else {
; 229  :                         status = SD_API_STATUS_SUCCESS;

  00184	e3a04000	 mov         r4, #0
  00188	ea00000e	 b           |$LN8@DetectSDCa|
  0018c		 |$LN76@DetectSDCa|

; 223  :                     if (SD_API_SUCCESS(status)) {
; 224  :                         UpdateCachedRegisterFromResponse( SD_INFO_REGISTER_OCR, &response);

  0018c	e5dd201b	 ldrb        r2, [sp, #0x1B]
  00190	e5dd101a	 ldrb        r1, [sp, #0x1A]
  00194	e5dd0019	 ldrb        r0, [sp, #0x19]
  00198	e5dd301c	 ldrb        r3, [sp, #0x1C]
  0019c	e5c624a4	 strb        r2, [r6, #0x4A4]
  001a0	e5c614a3	 strb        r1, [r6, #0x4A3]
  001a4	e5c604a2	 strb        r0, [r6, #0x4A2]

; 225  :                         SetDeviceType(deviceType = Device_MMC);
; 226  :                         status = SetOperationVoltage(Device_MMC,TRUE);

  001a8	e3a02001	 mov         r2, #1
  001ac	e3a01001	 mov         r1, #1
  001b0	e1a00006	 mov         r0, r6
  001b4	e5c634a5	 strb        r3, [r6, #0x4A5]
  001b8	e3a07001	 mov         r7, #1
  001bc	e5868494	 str         r8, [r6, #0x494]
  001c0	eb000000	 bl          |?SetOperationVoltage@CSDDevice@@QAAJW4_SDCARD_DEVICE_TYPE@@H@Z|
  001c4	e1a04000	 mov         r4, r0
  001c8		 |$LN8@DetectSDCa|

; 230  :                     }
; 231  :                 }
; 232  :             }
; 233  :              // Detect SD Memory
; 234  :             if (SD_API_SUCCESS(status) && (deviceType == Device_Unknown || deviceType == Device_SD_Combo )) { // We Try Memory

  001c8	e3540000	 cmp         r4, #0
  001cc	4a00002d	 bmi         |$LN75@DetectSDCa|
  001d0	e3570000	 cmp         r7, #0
  001d4	0a000001	 beq         |$LN6@DetectSDCa|
  001d8	e3570004	 cmp         r7, #4
  001dc	1a000027	 bne         |$LN5@DetectSDCa|
  001e0		 |$LN6@DetectSDCa|

; 235  :                 // PhiscalLayer 2.0 Table 4-27.
; 236  :                 status = SendSDAppCommand( SD_ACMD_SD_SEND_OP_COND, (fValid20Card? (m_sdSlot.VoltageWindowMask | 0x40000000): 0), ResponseR3,  &response);

  001e0	e3550000	 cmp         r5, #0
  001e4	15963438	 ldrne       r3, [r6, #0x438]
  001e8	e28d4014	 add         r4, sp, #0x14
  001ec	e3a08004	 mov         r8, #4
  001f0	1593306c	 ldrne       r3, [r3, #0x6C]
  001f4	e3a01029	 mov         r1, #0x29
  001f8	e1a00006	 mov         r0, r6
  001fc	13832101	 orrne       r2, r3, #1, 2
  00200	e5963000	 ldr         r3, [r6]
  00204	03a02000	 moveq       r2, #0
  00208	e58d9010	 str         r9, [sp, #0x10]
  0020c	e5935038	 ldr         r5, [r3, #0x38]
  00210	e3a03002	 mov         r3, #2
  00214	e58d900c	 str         r9, [sp, #0xC]
  00218	e58d9008	 str         r9, [sp, #8]
  0021c	e58d4004	 str         r4, [sp, #4]
  00220	e58d8000	 str         r8, [sp]
  00224	e1a0e00f	 mov         lr, pc
  00228	e12fff15	 bx          r5
  0022c	e3500000	 cmp         r0, #0

; 237  :                 if (SD_API_SUCCESS(status)) {

  00230	4a000014	 bmi         |$LN75@DetectSDCa|

; 238  :                     UpdateCachedRegisterFromResponse( SD_INFO_REGISTER_OCR, &response);

  00234	e5dd301c	 ldrb        r3, [sp, #0x1C]
  00238	e5dd201b	 ldrb        r2, [sp, #0x1B]

; 239  :                     if (deviceType == Device_Unknown) 

  0023c	e3570000	 cmp         r7, #0
  00240	e5c634a5	 strb        r3, [r6, #0x4A5]
  00244	e5dd101a	 ldrb        r1, [sp, #0x1A]
  00248	e5dd0019	 ldrb        r0, [sp, #0x19]

; 240  :                         SetDeviceType(deviceType = Device_SD_Memory);

  0024c	03a03002	 moveq       r3, #2
  00250	03a07002	 moveq       r7, #2
  00254	05863494	 streq       r3, [r6, #0x494]

; 241  :                     status = SetOperationVoltage(Device_SD_Memory, deviceType == Device_SD_Memory );                    

  00258	e3570002	 cmp         r7, #2
  0025c	e5c624a4	 strb        r2, [r6, #0x4A4]
  00260	03a02001	 moveq       r2, #1
  00264	e5c614a3	 strb        r1, [r6, #0x4A3]
  00268	e5c604a2	 strb        r0, [r6, #0x4A2]
  0026c	13a02000	 movne       r2, #0
  00270	e3a01002	 mov         r1, #2
  00274	e1a00006	 mov         r0, r6
  00278	eb000000	 bl          |?SetOperationVoltage@CSDDevice@@QAAJW4_SDCARD_DEVICE_TYPE@@H@Z|
  0027c	e1a04000	 mov         r4, r0
  00280		 |$LN5@DetectSDCa|

; 242  :                 }
; 243  : 
; 244  :             }
; 245  :                
; 246  :         }
; 247  :         if (!SD_API_SUCCESS(status)){

  00280	e3540000	 cmp         r4, #0
  00284	5a000004	 bpl         |$LN1@DetectSDCa|
  00288		 |$LN75@DetectSDCa|

; 248  :             // check to see what we discovered and post the appropriate error message
; 249  :             if (Device_SD_Combo == deviceType) {

  00288	e3570004	 cmp         r7, #4

; 250  :                 DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDBusDriver: SDIOCombo, Memory portion in slot %d not responsing to ACMD41 \n"), m_sdSlot.GetSlotIndex()));          
; 251  :                 status = SD_API_STATUS_SUCCESS;
; 252  :                 SetDeviceType(deviceType = Device_SD_IO);

  0028c	03a03003	 moveq       r3, #3
  00290	03a04000	 moveq       r4, #0
  00294	05863494	 streq       r3, [r6, #0x494]

; 253  :             } else {            
; 254  :                 DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDBusDriver: Unknown device found in slot %d \n"),m_sdSlot.GetSlotIndex()));                         
; 255  :                 status = SD_API_STATUS_DEVICE_UNSUPPORTED;

  00298	13a0415f	 movne       r4, #0x5F, 2
  0029c		 |$LN1@DetectSDCa|

; 256  :             }
; 257  :         }
; 258  :     }
; 259  :     ASSERT(SD_API_SUCCESS(status));
; 260  :     ASSERT(deviceType != Device_Unknown);
; 261  :     return status;

  0029c	e59d002c	 ldr         r0, [sp, #0x2C]
  002a0	eb000000	 bl          __security_check_cookie
  002a4		 |$LN25@DetectSDCa|

; 262  : }

  002a4	e1a00004	 mov         r0, r4
  002a8	e28dd030	 add         sp, sp, #0x30
  002ac	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  002b0	e12fff1e	 bx          lr
  002b4		 |$LN83@DetectSDCa|
  002b4		 |$LN84@DetectSDCa|
  002b4	00000000	 DCD         |__security_cookie|
  002b8		 |$M43258|

			 ENDP  ; |?DetectSDCard@CSDDevice@@QAAJAAK@Z|, CSDDevice::DetectSDCard

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?SetCardInterface@CSDDevice@@QAAJPAU_SD_CARD_INTERFACE_EX@@@Z| ; CSDDevice::SetCardInterface
	EXPORT	|??_C@_1IE@PMFOLIBK@?$AA8?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK@| [ DATA ] ; `string'
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T43294| DCD	|$LN53@SetCardInt|
	DCD	0xc0011002

  00000			 AREA	 |.xdata|, DATA
|$T43290| DCD	0xffffffe0

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1IE@PMFOLIBK@?$AA8?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK@| DCB "8"
	DCB	0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*"
	DCB	0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*"
	DCB	0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*"
	DCB	0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*"
	DCB	0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*"
	DCB	0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*"
	DCB	0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*"
	DCB	0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*"
	DCB	0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*"
	DCB	0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*", 0x0, "*"
	DCB	0x0, "*", 0x0, "*", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T43290|

  00008		 |?SetCardInterface@CSDDevice@@QAAJPAU_SD_CARD_INTERFACE_EX@@@Z| PROC ; CSDDevice::SetCardInterface

; 892  : {

  00008		 |$LN53@SetCardInt|
  00008	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  0000c	e24dd080	 sub         sp, sp, #0x80
  00010		 |$M43291|
  00010	e1b07001	 movs        r7, r1
  00014	e1a06000	 mov         r6, r0
  00018	e59f3424	 ldr         r3, [pc, #0x424]
  0001c	e5933000	 ldr         r3, [r3]
  00020	e58d307c	 str         r3, [sp, #0x7C]

; 893  :     UCHAR                   regValue;                           // register value
; 894  :     SD_API_STATUS           status = SD_API_STATUS_SUCCESS;     // intermediate status
; 895  :     SD_COMMAND_RESPONSE     response;                           // response
; 896  :     PSD_CARD_INTERFACE_EX   pInterfaceToUse;                    // interface to use
; 897  : 
; 898  :     if (NULL != pInterfaceEx) {
; 899  :         pInterfaceToUse = pInterfaceEx;
; 900  :     } else {
; 901  :         // otherwise use the one set in the device 
; 902  :         pInterfaceToUse = &m_CardInterfaceEx;
; 903  :     }    
; 904  : 
; 905  :         //  Determine if Soft-Block should be used.
; 906  :     if (( NULL != m_SDCardInfo.SDIOInformation.pCommonInformation )
; 907  :         && ( 0 == ( m_SDCardInfo.SDIOInformation.pCommonInformation->CardCapability
; 908  :                     & SD_IO_CARD_CAP_SUPPORTS_MULTI_BLOCK_TRANS )))

  00024	e59634ec	 ldr         r3, [r6, #0x4EC]
  00028	02867d15	 addeq       r7, r6, #0x15, 26
  0002c	e3a04000	 mov         r4, #0
  00030	e3530000	 cmp         r3, #0
  00034	0a000003	 beq         |$LN37@SetCardInt|
  00038	e5d33002	 ldrb        r3, [r3, #2]
  0003c	e3130002	 tst         r3, #2

; 909  :     {
; 910  :             //  The SDIO card does not support block mode.  Use Soft-Block instead.
; 911  :         m_SDCardInfo.SDIOInformation.Flags = SFTBLK_USE_FOR_CMD53_READ | SFTBLK_USE_FOR_CMD53_WRITE;

  00040	03a0300c	 moveq       r3, #0xC
  00044	05c63511	 streqb      r3, [r6, #0x511]
  00048		 |$LN37@SetCardInt|

; 912  :         DbgPrintZo(SDCARD_ZONE_WARN, (TEXT("SDBusDriver: The SDIO card does not support block mode.  Use Soft-Block instead. \n")));  
; 913  :     }
; 914  : 
; 915  :     //  Some host controllers can not properly support multi-block operations.
; 916  :     //  Enable Soft-Block for these operations.
; 917  :     if ( 0 != (m_sdSlot.Capabilities & SD_SLOT_USE_SOFT_BLOCK_CMD18 ))

  00048	e5960438	 ldr         r0, [r6, #0x438]
  0004c	e5903068	 ldr         r3, [r0, #0x68]
  00050	e3130c02	 tst         r3, #2, 24
  00054	0a000010	 beq         |$LN32@SetCardInt|

; 918  :     {
; 919  :         if ( 0 != ( m_sdSlot.Capabilities & SD_SLOT_USE_SOFT_BLOCK_CMD18 )) {
; 920  :                 //  The host controller needs to use Soft-Block for CMD18 read operations.
; 921  :             m_SDCardInfo.SDIOInformation.Flags |= SFTBLK_USE_FOR_CMD18;

  00058	e5d63511	 ldrb        r3, [r6, #0x511]
  0005c	e3832001	 orr         r2, r3, #1
  00060	e5c62511	 strb        r2, [r6, #0x511]

; 922  :             DbgPrintZo(SDCARD_ZONE_WARN, (TEXT("SDBusDriver: The host controller needs to use Soft-Block for CMD18 read operations. \n")));  
; 923  :         }
; 924  :         if ( 0 != ( m_sdSlot.Capabilities & SD_SLOT_USE_SOFT_BLOCK_CMD25 )) {

  00064	e5903068	 ldr         r3, [r0, #0x68]
  00068	e3130b01	 tst         r3, #1, 22

; 925  :                 //  The host controller needs to use Soft-Block for CMD25 write operations.
; 926  :             m_SDCardInfo.SDIOInformation.Flags |= SFTBLK_USE_FOR_CMD25;

  0006c	13823002	 orrne       r3, r2, #2
  00070	15c63511	 strneb      r3, [r6, #0x511]

; 927  :             DbgPrintZo(SDCARD_ZONE_WARN, (TEXT("SDBusDriver: The host controller needs to use Soft-Block for CMD25 write operations. \n")));  
; 928  :         }
; 929  :         if ( 0 != (m_sdSlot.Capabilities & SD_SLOT_USE_SOFT_BLOCK_CMD53_READ )) {

  00074	e5903068	 ldr         r3, [r0, #0x68]
  00078	e3130b02	 tst         r3, #2, 22

; 930  :             //  The host controller needs to use Soft-Block for CMD53 multi-block read operations.
; 931  :             m_SDCardInfo.SDIOInformation.Flags |= SFTBLK_USE_FOR_CMD53_READ;

  0007c	15d63511	 ldrneb      r3, [r6, #0x511]
  00080	13833004	 orrne       r3, r3, #4
  00084	15c63511	 strneb      r3, [r6, #0x511]

; 932  :             DbgPrintZo(SDCARD_ZONE_WARN, (TEXT("SDBusDriver: The host controller needs to use Soft-Block for CMD53 multi-block read operations. \n")));  
; 933  :         }
; 934  :         if ( 0 != ( m_sdSlot.Capabilities & SD_SLOT_USE_SOFT_BLOCK_CMD53_WRITE )) {

  00088	e5903068	 ldr         r3, [r0, #0x68]
  0008c	e3130a01	 tst         r3, #1, 20

; 935  :                 //  The host controller needs to use Soft-Block for CMD53 multi-block write operations.
; 936  :             m_SDCardInfo.SDIOInformation.Flags |= SFTBLK_USE_FOR_CMD53_WRITE;

  00090	15d63511	 ldrneb      r3, [r6, #0x511]
  00094	13833008	 orrne       r3, r3, #8
  00098	15c63511	 strneb      r3, [r6, #0x511]
  0009c		 |$LN32@SetCardInt|

; 937  :             DbgPrintZo(SDCARD_ZONE_WARN, (TEXT("SDBusDriver: The host controller needs to use Soft-Block for CMD53 multi-block write operations. \n")));  
; 938  :         }
; 939  :     }
; 940  :     if ( 0 != ( m_sdSlot.Capabilities & SD_SLOT_USE_SOFT_BLOCK_CMD25 )) {

  0009c	e5903068	 ldr         r3, [r0, #0x68]
  000a0	e3130b01	 tst         r3, #1, 22

; 941  :             //  The host controller needs to use Soft-Block for CMD25 write operations.
; 942  :         m_SDCardInfo.SDIOInformation.Flags = SFTBLK_USE_FOR_CMD25;

  000a4	13a03002	 movne       r3, #2
  000a8	15c63511	 strneb      r3, [r6, #0x511]

; 943  :         DbgPrintZo(SDCARD_ZONE_WARN, (TEXT("SDBusDriver: The host controller needs to use Soft-Block for CMD25 write operations. \n")));  
; 944  :     }
; 945  :     if ( 0 != ( m_sdSlot.Capabilities & SD_SLOT_USE_SOFT_BLOCK_CMD53_READ )) {

  000ac	e5903068	 ldr         r3, [r0, #0x68]
  000b0	e3130b02	 tst         r3, #2, 22

; 946  :             //  The host controller needs to use Soft-Block for CMD53 multi-block read operations.
; 947  :         m_SDCardInfo.SDIOInformation.Flags = SFTBLK_USE_FOR_CMD53_READ;

  000b4	13a03004	 movne       r3, #4
  000b8	15c63511	 strneb      r3, [r6, #0x511]

; 948  :         DbgPrintZo(SDCARD_ZONE_WARN, (TEXT("SDBusDriver: The host controller needs to use Soft-Block for CMD53 multi-block read operations. \n")));  
; 949  :     }
; 950  :     if ( 0 != (m_sdSlot.Capabilities & SD_SLOT_USE_SOFT_BLOCK_CMD53_WRITE )) {

  000bc	e5903068	 ldr         r3, [r0, #0x68]
  000c0	e3130a01	 tst         r3, #1, 20

; 951  :             //  The host controller needs to use Soft-Block for CMD53 multi-block write operations.
; 952  :         m_SDCardInfo.SDIOInformation.Flags = SFTBLK_USE_FOR_CMD53_WRITE;

  000c4	13a03008	 movne       r3, #8
  000c8	15c63511	 strneb      r3, [r6, #0x511]

; 953  :         DbgPrintZo(SDCARD_ZONE_WARN, (TEXT("SDBusDriver: The host controller needs to use Soft-Block for CMD53 multi-block write operations. \n")));  
; 954  :     }
; 955  :     // set the card interface
; 956  :     if (Device_SD_IO == m_DeviceType) {

  000cc	e5963494	 ldr         r3, [r6, #0x494]
  000d0	e3530003	 cmp         r3, #3
  000d4	1a000055	 bne         |$LN28@SetCardInt|

; 957  :         CSDDevice * pDevice0 = m_sdSlot.GetFunctionDevice(0);

  000d8	e3a01000	 mov         r1, #0
  000dc	eb000000	 bl          |?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z|
  000e0	e1b08000	 movs        r8, r0

; 958  :         status = SD_API_STATUS_DEVICE_REMOVED;

  000e4	e3a04147	 mov         r4, #0x47, 2

; 959  :         
; 960  :         if (pDevice0) {

  000e8	0a0000cd	 beq         |$LN1@SetCardInt|

; 961  :             // read the bus control register to keep its current bits
; 962  :             status = pDevice0->SDReadWriteRegistersDirect_I(SD_IO_READ, SD_IO_REG_BUS_CONTROL,FALSE,&regValue,1);

  000ec	e5983000	 ldr         r3, [r8]
  000f0	e28d5014	 add         r5, sp, #0x14
  000f4	e3a09001	 mov         r9, #1
  000f8	e5934010	 ldr         r4, [r3, #0x10]
  000fc	e3a03000	 mov         r3, #0
  00100	e3a02007	 mov         r2, #7
  00104	e3a01000	 mov         r1, #0
  00108	e1a00008	 mov         r0, r8
  0010c	e58d9004	 str         r9, [sp, #4]
  00110	e58d5000	 str         r5, [sp]
  00114	e1a0e00f	 mov         lr, pc
  00118	e12fff14	 bx          r4
  0011c	e1b04000	 movs        r4, r0

; 963  :             
; 964  :             if (SD_API_SUCCESS(status)) {            

  00120	4a00003f	 bmi         |$LN20@SetCardInt|

; 965  :                 // write the bus control register to set for 4 bit mode
; 966  :                 if (pInterfaceToUse->InterfaceModeEx.bit.sd4Bit) {

  00124	e5973000	 ldr         r3, [r7]

; 967  :                     regValue |= SD_IO_BUS_CONTROL_BUS_WIDTH_4BIT; 
; 968  :                     status = pDevice0->SDReadWriteRegistersDirect_I( SD_IO_WRITE, SD_IO_REG_BUS_CONTROL,FALSE,&regValue,1);

  00128	e28d5014	 add         r5, sp, #0x14
  0012c	e3a01001	 mov         r1, #1
  00130	e3130001	 tst         r3, #1
  00134	e5dd3014	 ldrb        r3, [sp, #0x14]
  00138	e1a00008	 mov         r0, r8
  0013c	0a00002d	 beq         |$LN25@SetCardInt|
  00140	e3833002	 orr         r3, r3, #2
  00144	e5cd3014	 strb        r3, [sp, #0x14]
  00148	e5982000	 ldr         r2, [r8]
  0014c	e3a03000	 mov         r3, #0
  00150	e58d9004	 str         r9, [sp, #4]
  00154	e5924010	 ldr         r4, [r2, #0x10]
  00158	e3a02007	 mov         r2, #7
  0015c	e58d5000	 str         r5, [sp]
  00160	e1a0e00f	 mov         lr, pc
  00164	e12fff14	 bx          r4
  00168	e1b04000	 movs        r4, r0

; 969  :                     
; 970  :                     if (SD_API_SUCCESS(status)) {

  0016c	4a00002c	 bmi         |$LN20@SetCardInt|

; 971  :                         if (m_sdSlot.Capabilities & SD_SLOT_SDIO_INT_DETECT_4BIT_MULTI_BLOCK) {

  00170	e5963438	 ldr         r3, [r6, #0x438]
  00174	e5933068	 ldr         r3, [r3, #0x68]
  00178	e3130c01	 tst         r3, #1, 24
  0017c	0a000028	 beq         |$LN20@SetCardInt|

; 972  : 
; 973  :                             // get the card capabilities register
; 974  :                             status = pDevice0->SDReadWriteRegistersDirect_I(SD_IO_READ,SD_IO_REG_CARD_CAPABILITY,FALSE,&regValue,1); 

  00180	e5982000	 ldr         r2, [r8]
  00184	e28d5014	 add         r5, sp, #0x14
  00188	e3a03000	 mov         r3, #0
  0018c	e5924010	 ldr         r4, [r2, #0x10]
  00190	e3a02008	 mov         r2, #8
  00194	e3a01000	 mov         r1, #0
  00198	e1a00008	 mov         r0, r8
  0019c	e58d9004	 str         r9, [sp, #4]
  001a0	e58d5000	 str         r5, [sp]
  001a4	e1a0e00f	 mov         lr, pc
  001a8	e12fff14	 bx          r4
  001ac	e1b04000	 movs        r4, r0

; 975  : 
; 976  :                             if (SD_API_SUCCESS(status)) {

  001b0	4a00001b	 bmi         |$LN20@SetCardInt|

; 977  :                                 // check the bit
; 978  :                                 if (regValue & SD_IO_CARD_CAP_SUPPORTS_INTS_4_BIT_MB_MODE) {

  001b4	e5dd3014	 ldrb        r3, [sp, #0x14]
  001b8	e3130010	 tst         r3, #0x10
  001bc	0a000018	 beq         |$LN20@SetCardInt|

; 979  :                                     DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDBusDriver: Host and Card supports interrupts in 4bit Multi-block mode\n")));  
; 980  : 
; 981  :                                     // set the bit, it's in the same register
; 982  :                                     regValue |= SD_IO_CARD_CAP_ENABLE_INTS_4_BIT_MB_MODE;

  001c0	e3833020	 orr         r3, r3, #0x20
  001c4	e5cd3014	 strb        r3, [sp, #0x14]

; 983  :                                     // write out the card capabilities register
; 984  :                                     status = pDevice0->SDReadWriteRegistersDirect_I( SD_IO_WRITE,SD_IO_REG_CARD_CAPABILITY,FALSE,&regValue,1); 

  001c8	e5982000	 ldr         r2, [r8]
  001cc	e28d5014	 add         r5, sp, #0x14
  001d0	e3a03000	 mov         r3, #0
  001d4	e5924010	 ldr         r4, [r2, #0x10]
  001d8	e3a02008	 mov         r2, #8
  001dc	e3a01001	 mov         r1, #1
  001e0	e1a00008	 mov         r0, r8
  001e4	e58d9004	 str         r9, [sp, #4]
  001e8	e58d5000	 str         r5, [sp]
  001ec	e1a0e00f	 mov         lr, pc
  001f0	e12fff14	 bx          r4

; 985  : 
; 986  :                                     DEBUGMSG(SDBUS_ZONE_DEVICE && SD_API_SUCCESS(status), 
; 987  :                                         (TEXT("SDBusDriver: 4 Bit multi-block interrupts capability enabled \n")));  
; 988  :                                 }
; 989  :                             }
; 990  :                         }
; 991  :                     }
; 992  :                 }
; 993  :                 else {

  001f4	ea000009	 b           |$LN49@SetCardInt|
  001f8		 |$LN25@SetCardInt|

; 994  :                     regValue &= ~SD_IO_BUS_CONTROL_BUS_WIDTH_4BIT; 

  001f8	e20330fd	 and         r3, r3, #0xFD
  001fc	e5cd3014	 strb        r3, [sp, #0x14]

; 995  :                     status = pDevice0->SDReadWriteRegistersDirect_I(SD_IO_WRITE,SD_IO_REG_BUS_CONTROL,FALSE,&regValue,1);

  00200	e5982000	 ldr         r2, [r8]
  00204	e3a03000	 mov         r3, #0
  00208	e58d9004	 str         r9, [sp, #4]
  0020c	e5924010	 ldr         r4, [r2, #0x10]
  00210	e3a02007	 mov         r2, #7
  00214	e58d5000	 str         r5, [sp]
  00218	e1a0e00f	 mov         lr, pc
  0021c	e12fff14	 bx          r4
  00220		 |$LN49@SetCardInt|
  00220	e1a04000	 mov         r4, r0
  00224		 |$LN20@SetCardInt|

; 996  :                     DEBUGMSG(SDCARD_ZONE_ERROR && !SD_API_SUCCESS(status), (TEXT("SDBusDriver: Failed to set I/O Card Bus Width \n")));  
; 997  : 
; 998  :                 }
; 999  :             }
; 1000 :             pDevice0->DeRef();

  00224	e1a00008	 mov         r0, r8
  00228	eb000000	 bl          |?DeRef@CRefObject@@QAAKXZ|

; 1001 :         }
; 1002 :     } 

  0022c	ea000050	 b           |$LN14@SetCardInt|
  00230		 |$LN28@SetCardInt|

; 1003 :     else if (Device_SD_Memory == m_DeviceType || Device_SD_Combo == m_DeviceType ) 

  00230	e3530002	 cmp         r3, #2
  00234	0a00002e	 beq         |$LN17@SetCardInt|
  00238	e3530004	 cmp         r3, #4
  0023c	0a00002c	 beq         |$LN17@SetCardInt|

; 1044 :                 DEBUGMSG(SDCARD_ZONE_ERROR && !SD_API_SUCCESS(status), (TEXT("SDBusDriver: Failed to set Memory Card Bus Width in Slot \n")));  
; 1045 :             }
; 1046 :         }
; 1047 :     }
; 1048 :     else if (Device_MMC == m_DeviceType) 

  00240	e3530001	 cmp         r3, #1
  00244	1a00004c	 bne         |$LN48@SetCardInt|

; 1049 : 	{   
; 1050 : #ifdef BSP_EMMCFEATURE
; 1051 :         // send the SET_BUS_WIDTH command to the device if 8 bit mode is used
; 1052 :         if (pInterfaceToUse->InterfaceModeEx.bit.sd8Bit) {

  00248	e5973000	 ldr         r3, [r7]
  0024c	e3130004	 tst         r3, #4
  00250	0a00000a	 beq         |$LN11@SetCardInt|

; 1053 : 			RETAILMSG(1,(TEXT("8**************************************************************\r\n")));

  00254	e59f01e4	 ldr         r0, [pc, #0x1E4]
  00258	eb000000	 bl          NKDbgPrintfW
  0025c	e3a037ee	 mov         r3, #0xEE, 14

; 1054 : 			status = SendSDCommand( SD_CMD_SWITCH_FUNCTION,0x03B70200, ResponseR1b, &response);

  00260	e2432cfe	 sub         r2, r3, #0xFE, 24
  00264	e28de018	 add         lr, sp, #0x18
  00268	e3a03002	 mov         r3, #2
  0026c	e3a01006	 mov         r1, #6
  00270	e1a00006	 mov         r0, r6
  00274	e58de000	 str         lr, [sp]
  00278	eb000000	 bl          |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|
  0027c	ea00000f	 b           |$LN8@SetCardInt|
  00280		 |$LN11@SetCardInt|

; 1055 : 
; 1056 :             DEBUGMSG(SDCARD_ZONE_ERROR && !SD_API_SUCCESS(status), (TEXT("SDBusDriver: Failed to set Memory Card Bus Width in Slot \n")));  
; 1057 :         }
; 1058 :         else if (pInterfaceToUse->InterfaceModeEx.bit.sd4Bit) 

  00280	e3130001	 tst         r3, #1

; 1059 :         {
; 1060 :         	status = SendSDCommand(SD_CMD_SWITCH_FUNCTION,EMMC_SWITCH2_4BITSBUS_ARGUMENT , ResponseR1b, &response);

  00284	e28de018	 add         lr, sp, #0x18
  00288	e3a01006	 mov         r1, #6
  0028c	e1a00006	 mov         r0, r6
  00290	0a000005	 beq         |$LN9@SetCardInt|
  00294	e3a037ee	 mov         r3, #0xEE, 14
  00298	e2432cff	 sub         r2, r3, #0xFF, 24
  0029c	e3a03002	 mov         r3, #2
  002a0	e58de000	 str         lr, [sp]
  002a4	eb000000	 bl          |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|

; 1061 :         	DEBUGMSG(SDCARD_ZONE_ERROR,(TEXT("SDBusDriver::Switch Function!status=0x%.8x,4bit support for MMC\n"),status));  
; 1062 :         }
; 1063 : 		else {

  002a8	ea000004	 b           |$LN8@SetCardInt|
  002ac		 |$LN9@SetCardInt|
  002ac	e3a037ed	 mov         r3, #0xED, 14

; 1064 :         	// send command
; 1065 :         	status = SendSDCommand( SD_CMD_SWITCH_FUNCTION,0x03B70000, ResponseR1b, &response);

  002b0	e3832803	 orr         r2, r3, #3, 16
  002b4	e3a03002	 mov         r3, #2
  002b8	e58de000	 str         lr, [sp]
  002bc	eb000000	 bl          |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|
  002c0		 |$LN8@SetCardInt|

; 1066 :         	DEBUGMSG(SDCARD_ZONE_ERROR && !SD_API_SUCCESS(status), (TEXT("SDBusDriver: Failed to set Memory Card Bus Width in Slot \n")));  
; 1067 : 		}
; 1068 : 
; 1069 :         status = SendSDCommand(SD_CMD_SWITCH_FUNCTION,EMMC_SWITCH2_HIGHSPEED_ARGUMENT , ResponseR1b, &response);

  002c0	e59f2174	 ldr         r2, [pc, #0x174]
  002c4	e28de018	 add         lr, sp, #0x18
  002c8	e3a03002	 mov         r3, #2
  002cc	e3a01006	 mov         r1, #6
  002d0	e1a00006	 mov         r0, r6
  002d4	e58de000	 str         lr, [sp]
  002d8	eb000000	 bl          |?SendSDCommand@CSDDevice@@IAAJEKW4_SD_RESPONSE_TYPE@@PAU_SD_COMMAND_RESPONSE@@@Z|
  002dc	e1b04000	 movs        r4, r0

; 1070 :         if (SD_API_SUCCESS(status)) 

  002e0	4a00004f	 bmi         |$LN1@SetCardInt|

; 1071 :         {
; 1072 :        		m_CardInterfaceEx.InterfaceModeEx.bit.sdHighSpeed = 1;

  002e4	e5963540	 ldr         r3, [r6, #0x540]
  002e8	e3833002	 orr         r3, r3, #2
  002ec	e5863540	 str         r3, [r6, #0x540]

; 1073 :         	DEBUGMSG(SDCARD_ZONE_ERROR,(TEXT("SDBusDriver::Switch Function !status=0x%.8x,highspeed=%d\n"),status,m_CardInterfaceEx.InterfaceModeEx.bit.sdHighSpeed));  
; 1074 :         }
; 1075 : 
; 1076 : 
; 1077 : #endif
; 1078 :         } 
; 1079 :     else 

  002f0	ea00001f	 b           |$LN14@SetCardInt|
  002f4		 |$LN17@SetCardInt|

; 1004 : 	{
; 1005 :         // bus width commands are only allowed if the card is unlocked
; 1006 :         if (!m_SDCardInfo.SDMMCInformation.CardIsLocked) 

  002f4	e5963530	 ldr         r3, [r6, #0x530]
  002f8	e3530000	 cmp         r3, #0
  002fc	1a00001e	 bne         |$LN48@SetCardInt|

; 1007 : 		{
; 1008 : #if (defined BSP_SDHIGHSPEEDSUPPORT_SDHC1 || defined BSP_SDHIGHSPEEDSUPPORT_SDHC2)
; 1009 :             pInterfaceToUse->InterfaceModeEx.bit.sdHighSpeed = 1;
; 1010 :             if (SD_API_SUCCESS(status) && 
; 1011 :                 (m_CardInterfaceEx.InterfaceModeEx.bit.sdHighSpeed != pInterfaceToUse->InterfaceModeEx.bit.sdHighSpeed) &&
; 1012 :                 pInterfaceToUse->InterfaceModeEx.bit.sdHighSpeed != 0)  // We need switch to high speed.
; 1013 :        		{ 
; 1014 :                 if (Device_SD_Memory == m_DeviceType && (m_sdSlot.Capabilities &SD_SLOT_HIGH_SPEED_CAPABLE)!=0 ) 
; 1015 :                 { 
; 1016 :                     // We are going to try to switch card to high speed.
; 1017 :                     SD_CARD_SWITCH_FUNCTION switchData = {
; 1018 :                         0x00000001, // Group 1 set to function 1 High Speed Table 4.7, SD Spec 2.0
; 1019 :                         MAXDWORD,
; 1020 :                         2*1000,     // let use try 2 second maximun.
; 1021 :                     };
; 1022 :                     status = SwitchFunction(&switchData,FALSE); 
; 1023 :                     if (SD_API_SUCCESS(status)) 
; 1024 :                     {
; 1025 :                         m_CardInterfaceEx.InterfaceModeEx.bit.sdHighSpeed = 1;
; 1026 :                         pInterfaceToUse->ClockRate = SDHC_HIGHSPEED_MAXCLOCKRATE;
; 1027 :                     }
; 1028 :                     else
; 1029 :                     {
; 1030 :                         m_CardInterfaceEx.InterfaceModeEx.bit.sdHighSpeed = 0;   
; 1031 :                         pInterfaceToUse->ClockRate = SD_FULL_SPEED_RATE;     
; 1032 :                     }
; 1033 :                 }
; 1034 :             }
; 1035 : #endif
; 1036 :             // send the SET_BUS_WIDTH command to the device if 4 bit mode is used
; 1037 :             if (pInterfaceToUse->InterfaceModeEx.bit.sd4Bit) {

  00300	e5973000	 ldr         r3, [r7]

; 1038 :                 // send command
; 1039 :                 status = SendSDAppCommand(SD_ACMD_SET_BUS_WIDTH, SD_ACMD_ARG_SET_BUS_4BIT, ResponseR1, &response);

  00304	e28d4018	 add         r4, sp, #0x18
  00308	e3a09001	 mov         r9, #1
  0030c	e3130001	 tst         r3, #1
  00310	e5963000	 ldr         r3, [r6]
  00314	e3a08000	 mov         r8, #0
  00318	e3a01006	 mov         r1, #6
  0031c	e5935038	 ldr         r5, [r3, #0x38]
  00320	e3a03002	 mov         r3, #2
  00324	e1a00006	 mov         r0, r6
  00328	0a000008	 beq         |$LN15@SetCardInt|
  0032c	e3a02002	 mov         r2, #2
  00330	e58d8010	 str         r8, [sp, #0x10]
  00334	e58d800c	 str         r8, [sp, #0xC]
  00338	e58d8008	 str         r8, [sp, #8]
  0033c	e58d4004	 str         r4, [sp, #4]
  00340	e58d9000	 str         r9, [sp]
  00344	e1a0e00f	 mov         lr, pc
  00348	e12fff15	 bx          r5

; 1040 :                 DEBUGMSG(SDCARD_ZONE_ERROR && !SD_API_SUCCESS(status), (TEXT("SDBusDriver: Failed to set Memory Card Bus Width in Slot \n")));  
; 1041 :             } else {

  0034c	ea000007	 b           |$LN50@SetCardInt|
  00350		 |$LN15@SetCardInt|

; 1042 :                 // send command
; 1043 :                 status = SendSDAppCommand(SD_ACMD_SET_BUS_WIDTH,0x00,ResponseR1,&response);

  00350	e3a02000	 mov         r2, #0
  00354	e58d8010	 str         r8, [sp, #0x10]
  00358	e58d800c	 str         r8, [sp, #0xC]
  0035c	e58d8008	 str         r8, [sp, #8]
  00360	e58d4004	 str         r4, [sp, #4]
  00364	e58d9000	 str         r9, [sp]
  00368	e1a0e00f	 mov         lr, pc
  0036c	e12fff15	 bx          r5
  00370		 |$LN50@SetCardInt|
  00370	e1a04000	 mov         r4, r0
  00374		 |$LN14@SetCardInt|

; 1080 : 	    {
; 1081 :             //DEBUGCHK(FALSE);
; 1082 :         }
; 1083 : #if !defined(BSP_SDHIGHSPEEDSUPPORT_SDHC1) && !defined(BSP_SDHIGHSPEEDSUPPORT_SDHC2)
; 1084 :     if (SD_API_SUCCESS(status) && 
; 1085 :         (m_CardInterfaceEx.InterfaceModeEx.bit.sdHighSpeed != pInterfaceToUse->InterfaceModeEx.bit.sdHighSpeed) &&
; 1086 :         pInterfaceToUse->InterfaceModeEx.bit.sdHighSpeed!=0) 

  00374	e3540000	 cmp         r4, #0
  00378	4a000029	 bmi         |$LN1@SetCardInt|
  0037c		 |$LN48@SetCardInt|
  0037c	e5973000	 ldr         r3, [r7]
  00380	e5962540	 ldr         r2, [r6, #0x540]
  00384	e1a03f03	 mov         r3, r3, lsl #30
  00388	e1a01fa3	 mov         r1, r3, lsr #31
  0038c	e1a03f02	 mov         r3, r2, lsl #30
  00390	e1510fa3	 cmp         r1, r3, lsr #31
  00394	0a00001d	 beq         |$LN2@SetCardInt|
  00398	e3510000	 cmp         r1, #0
  0039c	0a00001b	 beq         |$LN2@SetCardInt|

; 1087 :     { // We need switch to high speed.
; 1088 :         if (Device_SD_Memory == m_DeviceType && (m_sdSlot.Capabilities &SD_SLOT_HIGH_SPEED_CAPABLE)!=0 ) 

  003a0	e5963494	 ldr         r3, [r6, #0x494]
  003a4	e3530002	 cmp         r3, #2
  003a8	1a000017	 bne         |$LN4@SetCardInt|
  003ac	e5963438	 ldr         r3, [r6, #0x438]
  003b0	e5933068	 ldr         r3, [r3, #0x68]
  003b4	e3130010	 tst         r3, #0x10
  003b8	0a000013	 beq         |$LN4@SetCardInt|

; 1089 :         { 
; 1090 :             // We are going to try to switch card to high speed.
; 1091 :             SD_CARD_SWITCH_FUNCTION switchData = {
; 1092 :                 0x00000001, // Group 1 set to function 1 High Speed Table 4.7, SD Spec 2.0
; 1093 :                 MAXDWORD,

  003bc	e3e02000	 mvn         r2, #0

; 1094 :                 2*1000,     // let use try 2 second maximun.

  003c0	e3a01e7d	 mov         r1, #0x7D, 28
  003c4	e58d2034	 str         r2, [sp, #0x34]
  003c8	e58d1038	 str         r1, [sp, #0x38]
  003cc	e3a03001	 mov         r3, #1

; 1095 :             };

  003d0	e3a02040	 mov         r2, #0x40
  003d4	e3a01000	 mov         r1, #0
  003d8	e28d003c	 add         r0, sp, #0x3C
  003dc	e58d3030	 str         r3, [sp, #0x30]
  003e0	eb000000	 bl          memset

; 1096 :             status = SwitchFunction(&switchData,FALSE); 

  003e4	e3a02000	 mov         r2, #0
  003e8	e28d1030	 add         r1, sp, #0x30
  003ec	e1a00006	 mov         r0, r6
  003f0	eb000000	 bl          |?SwitchFunction@CSDDevice@@IAAJPAU_SD_CARD_SWITCH_FUNCTION@@H@Z|
  003f4	e1b04000	 movs        r4, r0

; 1097 :             if (SD_API_SUCCESS(status)) 

  003f8	4a000009	 bmi         |$LN1@SetCardInt|

; 1098 :             {
; 1099 :                 m_CardInterfaceEx.InterfaceModeEx.bit.sdHighSpeed = 1;

  003fc	e5963540	 ldr         r3, [r6, #0x540]
  00400	e3833002	 orr         r3, r3, #2
  00404	e5863540	 str         r3, [r6, #0x540]

; 1100 :             }
; 1101 :         }
; 1102 :         else 

  00408	ea000000	 b           |$LN2@SetCardInt|
  0040c		 |$LN4@SetCardInt|

; 1103 :         {
; 1104 :             status = SD_API_STATUS_DEVICE_UNSUPPORTED;

  0040c	e3a0415f	 mov         r4, #0x5F, 2
  00410		 |$LN2@SetCardInt|

; 1105 :         }		
; 1106 :     }
; 1107 : #endif	
; 1108 :     if (SD_API_SUCCESS(status)) {

  00410	e3540000	 cmp         r4, #0

; 1109 :         m_CardInterfaceEx = *pInterfaceToUse;

  00414	52860d15	 addpl       r0, r6, #0x15, 26
  00418	53a02020	 movpl       r2, #0x20
  0041c	51a01007	 movpl       r1, r7
  00420	5b000000	 blpl        memcpy
  00424		 |$LN1@SetCardInt|

; 1110 :     }
; 1111 : 
; 1112 :     ASSERT(SD_API_SUCCESS(status));
; 1113 :     return status;

  00424	e59d007c	 ldr         r0, [sp, #0x7C]
  00428	eb000000	 bl          __security_check_cookie

; 1114 : 
; 1115 : }

  0042c	e1a00004	 mov         r0, r4
  00430	e28dd080	 add         sp, sp, #0x80
  00434	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00438	e12fff1e	 bx          lr
  0043c		 |$LN54@SetCardInt|
  0043c		 |$LN55@SetCardInt|
  0043c	03b90100	 DCD         0x3b90100
  00440		 |$LN56@SetCardInt|
  00440	00000000	 DCD         |??_C@_1IE@PMFOLIBK@?$AA8?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK@|
  00444		 |$LN57@SetCardInt|
  00444	00000000	 DCD         |__security_cookie|
  00448		 |$M43292|

			 ENDP  ; |?SetCardInterface@CSDDevice@@QAAJPAU_SD_CARD_INTERFACE_EX@@@Z|, CSDDevice::SetCardInterface

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?SelectCardInterface@CSDDevice@@QAAJXZ| ; CSDDevice::SelectCardInterface
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdbus.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T43344| DCD	|$LN50@SelectCard|
	DCD	0xc000c002

  00000			 AREA	 |.xdata|, DATA
|$T43340| DCD	0xffffffec
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T43340|

  00008		 |?SelectCardInterface@CSDDevice@@QAAJXZ| PROC ; CSDDevice::SelectCardInterface

; 1127 : {

  00008		 |$LN50@SelectCard|
  00008	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  0000c	e24dd068	 sub         sp, sp, #0x68
  00010		 |$M43341|
  00010	e1a05000	 mov         r5, r0
  00014	e59f32e8	 ldr         r3, [pc, #0x2E8]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3064	 str         r3, [sp, #0x64]

; 1128 :     DWORD                   bitSlice;              // bit slice
; 1129 :     SD_API_STATUS           status;                // intermediate status
; 1130 : 
; 1131 :     status = SD_API_STATUS_SUCCESS;
; 1132 : 
; 1133 :     SD_PARSED_REGISTER_CSD CSDRegister ;
; 1134 : 
; 1135 :     // for MMC and SD cards allocate storage for the parsed CSD
; 1136 :     if ( (Device_SD_Memory == m_DeviceType) || (Device_MMC == m_DeviceType)) {

  00020	e5953494	 ldr         r3, [r5, #0x494]
  00024	e3a04000	 mov         r4, #0
  00028	e3530002	 cmp         r3, #2
  0002c	0a000001	 beq         |$LN27@SelectCard|
  00030	e3530001	 cmp         r3, #1
  00034	1a000009	 bne         |$LN26@SelectCard|
  00038		 |$LN27@SelectCard|

; 1137 :         // get the parsed CSD registers
; 1138 :         status = SDCardInfoQuery_I(SD_INFO_REGISTER_CSD,&CSDRegister,sizeof(SD_PARSED_REGISTER_CSD));

  00038	e5951000	 ldr         r1, [r5]
  0003c	e3a03050	 mov         r3, #0x50
  00040	e28d2014	 add         r2, sp, #0x14
  00044	e5914034	 ldr         r4, [r1, #0x34]
  00048	e3a01002	 mov         r1, #2
  0004c	e1a00005	 mov         r0, r5
  00050	e1a0e00f	 mov         lr, pc
  00054	e12fff14	 bx          r4
  00058	e1b04000	 movs        r4, r0

; 1139 : 
; 1140 :         if (!SD_API_SUCCESS(status)) {
; 1141 :             return status;

  0005c	4a00009f	 bmi         |$LN1@SelectCard|
  00060		 |$LN26@SelectCard|

; 1142 :         }
; 1143 :     }
; 1144 : 
; 1145 :     // Set default interface for the current device. SelectSlotInterface()
; 1146 :     // will be used to select one interface which fits for all devices
; 1147 :     if (Device_MMC != m_DeviceType) {

  00060	e5951494	 ldr         r1, [r5, #0x494]
  00064	e59f6294	 ldr         r6, [pc, #0x294]
  00068	e3510001	 cmp         r1, #1
  0006c	0a00001b	 beq         |$LN25@SelectCard|

; 1148 :         m_CardInterfaceEx.InterfaceModeEx.bit.sd4Bit = ((m_sdSlot.Capabilities & SD_SLOT_SD_4BIT_CAPABLE)!=0 ? 1 : 0);

  00070	e5950438	 ldr         r0, [r5, #0x438]
  00074	e5903068	 ldr         r3, [r0, #0x68]
  00078	e3130008	 tst         r3, #8
  0007c	e5953540	 ldr         r3, [r5, #0x540]
  00080	13a02001	 movne       r2, #1
  00084	03a02000	 moveq       r2, #0
  00088	e2022001	 and         r2, r2, #1

; 1149 :         // deal with special cases
; 1150 :         // 1 bit SD memory + 4 bit SDIO
; 1151 :         // SD_SLOT_SD_1BIT_CAPABLE | SD_SLOT_SDIO_CAPABLE | SD_SLOT_SDIO_4BIT_CAPABLE
; 1152 :         if (Device_SD_IO == m_DeviceType && (m_sdSlot.Capabilities & SD_SLOT_SDIO_4BIT_CAPABLE)!=0) {

  0008c	e3c33001	 bic         r3, r3, #1
  00090	e1832002	 orr         r2, r3, r2
  00094	e5852540	 str         r2, [r5, #0x540]
  00098	e3510003	 cmp         r1, #3
  0009c	1a000003	 bne         |$LN24@SelectCard|
  000a0	e5903068	 ldr         r3, [r0, #0x68]
  000a4	e3130080	 tst         r3, #0x80

; 1153 :             m_CardInterfaceEx.InterfaceModeEx.bit.sd4Bit = 1 ;

  000a8	13823001	 orrne       r3, r2, #1
  000ac	15853540	 strne       r3, [r5, #0x540]
  000b0		 |$LN24@SelectCard|

; 1154 :         }
; 1155 : 
; 1156 :         // 1 bit SDIO + 4 bit SD Memory
; 1157 :         // SD_SLOT_SD_1BIT_CAPABLE | SD_SLOT_SDIO_CAPABLE | SD_SLOT_SDMEM_4BIT_CAPABLE
; 1158 :         if ((Device_SD_Memory == m_DeviceType  || Device_SD_Combo == m_DeviceType ) && (m_sdSlot.Capabilities & SD_SLOT_SDMEM_4BIT_CAPABLE)!=0) {

  000b0	e3510002	 cmp         r1, #2
  000b4	0a000001	 beq         |$LN22@SelectCard|
  000b8	e3510004	 cmp         r1, #4
  000bc	1a000004	 bne         |$LN23@SelectCard|
  000c0		 |$LN22@SelectCard|
  000c0	e5903068	 ldr         r3, [r0, #0x68]
  000c4	e3130040	 tst         r3, #0x40

; 1159 :             m_CardInterfaceEx.InterfaceModeEx.bit.sd4Bit = 1;

  000c8	15953540	 ldrne       r3, [r5, #0x540]
  000cc	13833001	 orrne       r3, r3, #1
  000d0	15853540	 strne       r3, [r5, #0x540]
  000d4		 |$LN23@SelectCard|

; 1160 :         }
; 1161 : 
; 1162 :         // try all cards at full speed	
; 1163 :         m_CardInterfaceEx.ClockRate = SD_FULL_SPEED_RATE;

  000d4	e59f3220	 ldr         r3, [pc, #0x220]
  000d8	e5853544	 str         r3, [r5, #0x544]

; 1164 : 
; 1165 :     } else {

  000dc	ea000020	 b           |$LN19@SelectCard|
  000e0		 |$LN25@SelectCard|

; 1166 :         // MMC cards are always 1 bit, set the clock rate to the default MMC rate
; 1167 : #ifdef BSP_EMMCFEATURE		
; 1168 : 		   DWORD dwCardInterfaceMode;
; 1169 :            if ((CSDRegister.RawCSDRegister[15] & EMMC_CSD_SPEC_VERSION_VALUE) //CSD SPEC VERSION = 4
; 1170 : 			         &&(m_dwSpecVers >= MMC_CSD_VERSION_CODE_SUPPORTED) ) //MMC > 4.1

  000e0	e5dd3063	 ldrb        r3, [sp, #0x63]
  000e4	e3130010	 tst         r3, #0x10
  000e8	0a000019	 beq         |$LN20@SelectCard|
  000ec	e595342c	 ldr         r3, [r5, #0x42C]
  000f0	e3530002	 cmp         r3, #2
  000f4	3a000016	 bcc         |$LN20@SelectCard|

; 1171 :                {
; 1172 : 			   status = GetCardBusWidthCapability(&dwCardInterfaceMode);

  000f8	e28d1004	 add         r1, sp, #4
  000fc	e1a00005	 mov         r0, r5
  00100	eb000000	 bl          |?GetCardBusWidthCapability@CSDDevice@@IAAJPAK@Z|

; 1173 : 			   m_CardInterfaceEx.InterfaceModeEx.bit.sd4Bit=(dwCardInterfaceMode==SD_INTERFACE_SD_4BIT)?1:0;

  00104	e59d1004	 ldr         r1, [sp, #4]
  00108	e5953540	 ldr         r3, [r5, #0x540]
  0010c	e1a04000	 mov         r4, r0
  00110	e3510001	 cmp         r1, #1
  00114	03a02001	 moveq       r2, #1
  00118	13a02000	 movne       r2, #0
  0011c	e2022001	 and         r2, r2, #1

; 1174 : 			   m_CardInterfaceEx.InterfaceModeEx.bit.sd8Bit=(dwCardInterfaceMode==SD_INTERFACE_SD_MMC_8BIT)?1:0;

  00120	e3c33001	 bic         r3, r3, #1
  00124	e3510002	 cmp         r1, #2
  00128	e1832002	 orr         r2, r3, r2
  0012c	03a03001	 moveq       r3, #1
  00130	13a03000	 movne       r3, #0

; 1175 : 			   m_CardInterfaceEx.InterfaceModeEx.bit.sdHighSpeed = 1;

  00134	e0223103	 eor         r3, r2, r3, lsl #2
  00138	e2033004	 and         r3, r3, #4
  0013c	e0233002	 eor         r3, r3, r2
  00140	e5852540	 str         r2, [r5, #0x540]

; 1176 :                m_CardInterfaceEx.ClockRate = EMMC_HIGHSPEED_MAXCLOCKRATE;

  00144	e59f21ac	 ldr         r2, [pc, #0x1AC]
  00148	e3833002	 orr         r3, r3, #2
  0014c	e5852544	 str         r2, [r5, #0x544]

; 1177 :                DEBUGMSG(SDBUS_ZONE_DEVICE,(TEXT("SDBusDriver:4 Bits & HighSpeed\n")));
; 1178 : 			   DEBUGMSG(SDBUS_ZONE_DEVICE,(TEXT("CSR[15]: %x      CSDVersion: %d\r\n"),CSDRegister.RawCSDRegister[15],
; 1179 : 				   CSDRegister.CSDVersion));
; 1180 :                }
; 1181 :            else

  00150	ea000002	 b           |$LN47@SelectCard|
  00154		 |$LN20@SelectCard|

; 1182 :                {
; 1183 :                m_CardInterfaceEx.InterfaceModeEx.bit.sd4Bit = 0;
; 1184 : 			   m_CardInterfaceEx.InterfaceModeEx.bit.sd8Bit = 0;
; 1185 :                m_CardInterfaceEx.InterfaceModeEx.bit.sdHighSpeed = 0;

  00154	e5953540	 ldr         r3, [r5, #0x540]

; 1186 :                m_CardInterfaceEx.ClockRate = MMC_FULL_SPEED_RATE;

  00158	e5856544	 str         r6, [r5, #0x544]
  0015c	e3c33007	 bic         r3, r3, #7
  00160		 |$LN47@SelectCard|
  00160	e5853540	 str         r3, [r5, #0x540]
  00164		 |$LN19@SelectCard|

; 1187 :                DEBUGMSG(SDBUS_ZONE_DEVICE,(TEXT("SDBusDriver:1 Bits & LowSpeed\n")));
; 1188 :                }
; 1189 : #else
; 1190 :            m_CardInterfaceEx.InterfaceModeEx.bit.sd4Bit = 0;
; 1191 :            m_CardInterfaceEx.ClockRate = MMC_FULL_SPEED_RATE;
; 1192 : #endif
; 1193 :     }
; 1194 : 
; 1195 :     // select the actual interface speed and type based on the card type 
; 1196 :     if (Device_SD_IO == m_DeviceType) {

  00164	e5953494	 ldr         r3, [r5, #0x494]
  00168	e3530003	 cmp         r3, #3
  0016c	1a000015	 bne         |$LN18@SelectCard|

; 1197 :         CSDDevice * pParentDevice = m_sdSlot.GetFunctionDevice( 0 );

  00170	e5950438	 ldr         r0, [r5, #0x438]
  00174	e3a01000	 mov         r1, #0
  00178	eb000000	 bl          |?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z|
  0017c	e3500000	 cmp         r0, #0

; 1198 :         if (pParentDevice) {

  00180	0a00000e	 beq         |$LN17@SelectCard|

; 1199 :             // check for a low speed device
; 1200 :             if (pParentDevice->m_SDCardInfo.SDIOInformation.pCommonInformation->CardCapability & SD_IO_CARD_CAP_LOW_SPEED) {

  00184	e59034ec	 ldr         r3, [r0, #0x4EC]
  00188	e5d33002	 ldrb        r3, [r3, #2]
  0018c	e3130040	 tst         r3, #0x40
  00190	0a000008	 beq         |$LN15@SelectCard|
  00194	e3a03a61	 mov         r3, #0x61, 20

; 1201 :                 // drop it down to low speed
; 1202 :                 m_CardInterfaceEx.ClockRate = SD_LOW_SPEED_RATE;

  00198	e3833d2a	 orr         r3, r3, #0x2A, 26
  0019c	e5853544	 str         r3, [r5, #0x544]

; 1203 :                 // check for 4 bit support at low speed
; 1204 :                 if (!(pParentDevice->m_SDCardInfo.SDIOInformation.pCommonInformation->CardCapability & SD_IO_CARD_CAP_4_BIT_LOW_SPEED)) {

  001a0	e59034ec	 ldr         r3, [r0, #0x4EC]
  001a4	e5d33002	 ldrb        r3, [r3, #2]
  001a8	e3130080	 tst         r3, #0x80

; 1205 :                     // drop to 1 bit mode if the low speed device doesn't support
; 1206 :                     // 4 bit operation
; 1207 :                     m_CardInterfaceEx.InterfaceModeEx.bit.sd4Bit = 0 ;

  001ac	05953540	 ldreq       r3, [r5, #0x540]
  001b0	03c33001	 biceq       r3, r3, #1
  001b4	05853540	 streq       r3, [r5, #0x540]
  001b8		 |$LN15@SelectCard|

; 1208 :                 }
; 1209 :             } 
; 1210 :             pParentDevice->DeRef();

  001b8	eb000000	 bl          |?DeRef@CRefObject@@QAAKXZ|

; 1211 :         }
; 1212 :         else {

  001bc	ea00001e	 b           |$LN10@SelectCard|
  001c0		 |$LN17@SelectCard|

; 1213 :             ASSERT(FALSE);
; 1214 :             status = SD_API_STATUS_UNSUCCESSFUL;

  001c0	e3a0410f	 mov         r4, #0xF, 2

; 1215 :         }

  001c4	ea00001c	 b           |$LN10@SelectCard|
  001c8		 |$LN18@SelectCard|

; 1216 : 
; 1217 :     }
; 1218 :     else if (Device_SD_Memory == m_DeviceType || Device_SD_Combo == m_DeviceType) {

  001c8	e3530002	 cmp         r3, #2
  001cc	0a00000e	 beq         |$LN11@SelectCard|
  001d0	e3530004	 cmp         r3, #4
  001d4	0a00000c	 beq         |$LN11@SelectCard|

; 1229 :         }
; 1230 : 
; 1231 :     // SD cards have their Max transfer rate set to 25 Mhz, we do not need to check the CSD register
; 1232 : 
; 1233 :     } else if (Device_MMC == m_DeviceType) {

  001d8	e3530001	 cmp         r3, #1
  001dc	1a000006	 bne         |$LN8@SelectCard|

; 1234 : 
; 1235 :         // for MMC cards we need to check the Max Transfer Rate reported by the card
; 1236 :         // the data rate is in kbits/sec
; 1237 :         if ((CSDRegister.MaxDataTransferRate * 1000) < MMC_FULL_SPEED_RATE) {

  001e0	e59d302c	 ldr         r3, [sp, #0x2C]
  001e4	e3a02ffa	 mov         r2, #0xFA, 30
  001e8	e0020293	 mul         r2, r3, r2
  001ec	e1520006	 cmp         r2, r6
  001f0	2a000011	 bcs         |$LN10@SelectCard|

; 1238 :                 // set for a lower rate
; 1239 :             m_CardInterfaceEx.ClockRate = CSDRegister.MaxDataTransferRate * 1000;   

  001f4	e5852544	 str         r2, [r5, #0x544]

; 1240 :         } 
; 1241 : 
; 1242 :         DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDBusDriver: MMC Card Max Transfer Rate: %d Hz \n"),
; 1243 :                 m_CardInterfaceEx.ClockRate));
; 1244 :     } else {

  001f8	ea00000f	 b           |$LN10@SelectCard|
  001fc		 |$LN8@SelectCard|

; 1245 :         DEBUGCHK(FALSE);
; 1246 :         return SD_API_STATUS_INVALID_PARAMETER;

  001fc	e59d0064	 ldr         r0, [sp, #0x64]
  00200	eb000000	 bl          __security_check_cookie
  00204	e3a0411f	 mov         r4, #0x1F, 2
  00208	ea000036	 b           |$LN29@SelectCard|
  0020c		 |$LN11@SelectCard|

; 1219 : 
; 1220 :         // get the bus width bits from the SCR to check for 4 bit
; 1221 :         // all cards must minimally support 1 bit mode
; 1222 :         bitSlice = GetBitSlice(m_CachedRegisters.SCR, sizeof(m_CachedRegisters.SCR), SD_SCR_BUS_WIDTH_BIT_SLICE , SD_SCR_BUS_WIDTH_SLICE_SIZE);

  0020c	e2853b01	 add         r3, r5, #1, 22
  00210	e28310c6	 add         r1, r3, #0xC6
  00214	e3a0e004	 mov         lr, #4
  00218	e3a03030	 mov         r3, #0x30
  0021c	e3a02008	 mov         r2, #8
  00220	e1a00005	 mov         r0, r5
  00224	e58de000	 str         lr, [sp]
  00228	eb000000	 bl          |?GetBitSlice@CSDDevice@@IAAKPAEKKE@Z|

; 1223 : 
; 1224 :         if (!(bitSlice & SD_SCR_BUS_WIDTH_4_BIT)) {

  0022c	e3100004	 tst         r0, #4

; 1225 :             // card only supports 1 bit mode
; 1226 :             DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDBusDriver: SD Memory Card only supports 1 bit mode! \n"),
; 1227 :                 m_FuncionIndex));
; 1228 :             m_CardInterfaceEx.InterfaceModeEx.bit.sd4Bit = 0 ;

  00230	05953540	 ldreq       r3, [r5, #0x540]
  00234	03c33001	 biceq       r3, r3, #1
  00238	05853540	 streq       r3, [r5, #0x540]
  0023c		 |$LN10@SelectCard|

; 1247 :     }
; 1248 : 
; 1249 :     if (SD_API_SUCCESS(status)) {

  0023c	e3540000	 cmp         r4, #0
  00240	4a000026	 bmi         |$LN1@SelectCard|

; 1250 :         // get any interface overrides via the registry
; 1251 :         GetInterfaceOverrides();

  00244	e1a00005	 mov         r0, r5
  00248	eb000000	 bl          |?GetInterfaceOverrides@CSDDevice@@IAAXXZ|

; 1252 :         // sanity check the overrides
; 1253 :         if ((!(m_sdSlot.Capabilities & SD_SLOT_SD_4BIT_CAPABLE)) && (m_CardInterfaceEx.InterfaceModeEx.bit.sd4Bit)) {

  0024c	e5951438	 ldr         r1, [r5, #0x438]
  00250	e5912068	 ldr         r2, [r1, #0x68]
  00254	e3120008	 tst         r2, #8
  00258	1a000006	 bne         |$LN3@SelectCard|
  0025c	e5953540	 ldr         r3, [r5, #0x540]
  00260	e3130001	 tst         r3, #1
  00264	0a000003	 beq         |$LN3@SelectCard|

; 1254 :             if ( (!(m_sdSlot.Capabilities & SD_SLOT_SDMEM_4BIT_CAPABLE)) &&(!( m_sdSlot.Capabilities & SD_SLOT_SDIO_4BIT_CAPABLE)) ) {

  00268	e3120040	 tst         r2, #0x40
  0026c	1a000001	 bne         |$LN3@SelectCard|
  00270	e3120080	 tst         r2, #0x80

; 1255 :                 DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDBusDriver: override to 4 bit on non-4-bit capable host, not allowed! \n")));
; 1256 :                 return SD_API_STATUS_INVALID_PARAMETER;

  00274	0affffe0	 beq         |$LN8@SelectCard|
  00278		 |$LN3@SelectCard|

; 1257 :             }
; 1258 :         }    
; 1259 :        
; 1260 :             // get the write protect status
; 1261 :         if (Device_SD_Memory == m_DeviceType) {

  00278	e5953494	 ldr         r3, [r5, #0x494]
  0027c	e3530002	 cmp         r3, #2
  00280	1a000016	 bne         |$LN1@SelectCard|

; 1262 :             SD_CARD_INTERFACE sdCardInterface;
; 1263 :             status = m_sdSlot.GetHost().SlotOptionHandler(m_sdSlot.GetSlotIndex(), SDHCDGetWriteProtectStatus, &sdCardInterface, sizeof(sdCardInterface));

  00284	e591307c	 ldr         r3, [r1, #0x7C]
  00288	e5911080	 ldr         r1, [r1, #0x80]
  0028c	e3a0600c	 mov         r6, #0xC
  00290	e3530000	 cmp         r3, #0
  00294	e5934044	 ldr         r4, [r3, #0x44]
  00298	12830008	 addne       r0, r3, #8
  0029c	03a00000	 moveq       r0, #0
  002a0	e28d3008	 add         r3, sp, #8
  002a4	e3a02005	 mov         r2, #5
  002a8	e58d6000	 str         r6, [sp]
  002ac	e1a0e00f	 mov         lr, pc
  002b0	e12fff14	 bx          r4

; 1264 :             m_CardInterfaceEx.InterfaceModeEx.bit.sdWriteProtected = (sdCardInterface.WriteProtected?1:0);

  002b4	e59d3010	 ldr         r3, [sp, #0x10]
  002b8	e1a04000	 mov         r4, r0
  002bc	e3530000	 cmp         r3, #0
  002c0	e5953540	 ldr         r3, [r5, #0x540]
  002c4	13a01001	 movne       r1, #1
  002c8	03a01000	 moveq       r1, #0
  002cc	e1a02003	 mov         r2, r3
  002d0	e0233f01	 eor         r3, r3, r1, lsl #30
  002d4	e2033101	 and         r3, r3, #1, 2
  002d8	e0233002	 eor         r3, r3, r2
  002dc	e5853540	 str         r3, [r5, #0x540]
  002e0		 |$LN1@SelectCard|

; 1265 :             if (m_CardInterfaceEx.InterfaceModeEx.bit.sdWriteProtected) {
; 1266 :                 DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDBusDriver: Card in slot %d is write protected \n"),m_sdSlot.GetSlotIndex()));
; 1267 :             }
; 1268 : 
; 1269 :         }
; 1270 :     }
; 1271 : 	DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDBusDriver: Interface for slot %d , Mode :%x, Clock:%d  m_sdSlot.Capabilities: %d  4bit: %d  8bit: %d\n"),
; 1272 :         m_sdSlot.GetSlotIndex(),m_CardInterfaceEx.InterfaceModeEx.uInterfaceMode,m_CardInterfaceEx.ClockRate,
; 1273 : 		m_sdSlot.Capabilities, m_CardInterfaceEx.InterfaceModeEx.bit.sd4Bit,
; 1274 : 		m_CardInterfaceEx.InterfaceModeEx.bit.sd8Bit)); 
; 1275 : 
; 1276 :     ASSERT(SD_API_SUCCESS(status));
; 1277 :     return status;

  002e0	e59d0064	 ldr         r0, [sp, #0x64]
  002e4	eb000000	 bl          __security_check_cookie
  002e8		 |$LN29@SelectCard|

; 1278 : 
; 1279 : }

  002e8	e1a00004	 mov         r0, r4
  002ec	e28dd068	 add         sp, sp, #0x68
  002f0	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  002f4	e12fff1e	 bx          lr
  002f8		 |$LN51@SelectCard|
  002f8		 |$LN52@SelectCard|
  002f8	03197500	 DCD         0x3197500
  002fc		 |$LN53@SelectCard|
  002fc	017d7840	 DCD         0x17d7840
  00300		 |$LN54@SelectCard|
  00300	01312d00	 DCD         0x1312d00
  00304		 |$LN55@SelectCard|
  00304	00000000	 DCD         |__security_cookie|
  00308		 |$M43342|

			 ENDP  ; |?SelectCardInterface@CSDDevice@@QAAJXZ|, CSDDevice::SelectCardInterface

	EXPORT	|??1CSDDevice@@UAA@XZ|			; CSDDevice::~CSDDevice
	IMPORT	|CloseHandle|
; File c:\wince600\public\common\oak\inc\crefcon.h

  00000			 AREA	 |.pdata|, PDATA
|$T43365| DCD	|$LN12@CSDDevice@2|
	DCD	0x40001a01
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CSDDevice@@UAA@XZ| PROC		; CSDDevice::~CSDDevice

; 78   : {

  00000		 |$LN12@CSDDevice@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M43362|
  00004	e1a04000	 mov         r4, r0
  00008	e59f3054	 ldr         r3, [pc, #0x54]

; 79   :     Detach();

  0000c	e5843000	 str         r3, [r4]
  00010	eb000000	 bl          |?Detach@CSDDevice@@UAAHXZ|

; 80   :     if (m_hSyncEvent)

  00014	e5943434	 ldr         r3, [r4, #0x434]
  00018	e3530000	 cmp         r3, #0

; 81   :         CloseHandle(m_hSyncEvent);

  0001c	11a00003	 movne       r0, r3
  00020	1b000000	 blne        CloseHandle

; 82   :     if (m_SDCardInfo.SDIOInformation.pCommonInformation!=NULL) {

  00024	e59434ec	 ldr         r3, [r4, #0x4EC]
  00028	e3530000	 cmp         r3, #0
  0002c	0a000005	 beq         |$LN2@CSDDevice@2|

; 83   :         if (m_SDCardInfo.SDIOInformation.pCommonInformation->pProductInformation)

  00030	e593300c	 ldr         r3, [r3, #0xC]
  00034	e3530000	 cmp         r3, #0

; 84   :             delete[] m_SDCardInfo.SDIOInformation.pCommonInformation->pProductInformation;

  00038	11a00003	 movne       r0, r3
  0003c	1b000000	 blne        |??3@YAXPAX@Z|

; 85   :         delete m_SDCardInfo.SDIOInformation.pCommonInformation;

  00040	e59404ec	 ldr         r0, [r4, #0x4EC]
  00044	eb000000	 bl          |??3@YAXPAX@Z|
  00048		 |$LN2@CSDDevice@2|

; 86   :     }
; 87   :     
; 88   : }

  00048	e2840008	 add         r0, r4, #8
  0004c	eb000000	 bl          |??1?$CStaticContainer@VCSDBusRequest@@$0BAA@@@QAA@XZ|
  00050	e59f3008	 ldr         r3, [pc, #8]
  00054	e5843000	 str         r3, [r4]
  00058	e8bd4010	 ldmia       sp!, {r4, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$LN13@CSDDevice@2|
  00060		 |$LN14@CSDDevice@2|
  00060	00000000	 DCD         |??_7CRefObject@@6B@|
  00064		 |$LN15@CSDDevice@2|
  00064	00000000	 DCD         |??_7CSDDevice@@6B@|
  00068		 |$M43363|

			 ENDP  ; |??1CSDDevice@@UAA@XZ|, CSDDevice::~CSDDevice


  00000			 AREA	 |.pdata|, PDATA
|$T43379| DCD	|$LN6@scalar@2|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GCSDDevice@@UAAPAXI@Z| PROC	; CSDDevice::`scalar deleting destructor'
  00000		 |$LN6@scalar@2|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43376|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          |??1CSDDevice@@UAA@XZ|
  00010	e3140001	 tst         r4, #1
  00014	11a00005	 movne       r0, r5
  00018	1b000000	 blne        |??3@YAXPAX@Z|
  0001c	e1a00005	 mov         r0, r5
  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M43377|

			 ENDP  ; |??_GCSDDevice@@UAAPAXI@Z|, CSDDevice::`scalar deleting destructor'

	END
