; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\Z2170P\SRC\DRIVERS\SDBUS\sdiofeat.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|?Lock@CLockObject@@QAAXXZ|		; CLockObject::Lock
	IMPORT	|EnterCriticalSection|
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T36191| DCD	|$LN5@Lock|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Lock@CLockObject@@QAAXXZ| PROC	; CLockObject::Lock

; 45   :     {

  00000		 |$LN5@Lock|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36188|

; 46   :         EnterCriticalSection( &m_CSection );

  00004	eb000000	 bl          EnterCriticalSection

; 47   :     };

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M36189|

			 ENDP  ; |?Lock@CLockObject@@QAAXXZ|, CLockObject::Lock

	EXPORT	|?Unlock@CLockObject@@QAAXXZ|		; CLockObject::Unlock
	IMPORT	|LeaveCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T36199| DCD	|$LN5@Unlock|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Unlock@CLockObject@@QAAXXZ| PROC	; CLockObject::Unlock

; 49   :     {

  00000		 |$LN5@Unlock|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36196|

; 50   :         LeaveCriticalSection( &m_CSection );

  00004	eb000000	 bl          LeaveCriticalSection

; 51   :     };

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M36197|

			 ENDP  ; |?Unlock@CLockObject@@QAAXXZ|, CLockObject::Unlock

	EXPORT	|?AddRef@CRefObject@@QAAKXZ|		; CRefObject::AddRef
	IMPORT	|InterlockedIncrement|
; File c:\wince600\public\common\oak\inc\crefcon.h

  00000			 AREA	 |.pdata|, PDATA
|$T36209| DCD	|$LN5@AddRef|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AddRef@CRefObject@@QAAKXZ| PROC	; CRefObject::AddRef

; 43   :     {

  00000		 |$LN5@AddRef|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36206|

; 44   :         return (DWORD)InterlockedIncrement(&m_lRefCount);

  00004	e2800004	 add         r0, r0, #4
  00008	eb000000	 bl          InterlockedIncrement

; 45   :     };

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M36207|

			 ENDP  ; |?AddRef@CRefObject@@QAAKXZ|, CRefObject::AddRef

	EXPORT	|?DeRef@CRefObject@@QAAKXZ|		; CRefObject::DeRef
	IMPORT	|InterlockedDecrement|

  00000			 AREA	 |.pdata|, PDATA
|$T36224| DCD	|$LN8@DeRef|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DeRef@CRefObject@@QAAKXZ| PROC	; CRefObject::DeRef

; 47   :     {

  00000		 |$LN8@DeRef|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M36221|
  00004	e1a04000	 mov         r4, r0

; 48   :         LONG lReturn = InterlockedDecrement(&m_lRefCount);

  00008	e2840004	 add         r0, r4, #4
  0000c	eb000000	 bl          InterlockedDecrement
  00010	e1a05000	 mov         r5, r0

; 49   :         if( lReturn <= 0 ) {

  00014	e3550000	 cmp         r5, #0
  00018	ca000006	 bgt         |$LN4@DeRef|

; 50   :             delete this;

  0001c	e3540000	 cmp         r4, #0
  00020	15943000	 ldrne       r3, [r4]
  00024	13a01001	 movne       r1, #1
  00028	11a00004	 movne       r0, r4
  0002c	15933000	 ldrne       r3, [r3]
  00030	11a0e00f	 movne       lr, pc
  00034	112fff13	 bxne        r3
  00038		 |$LN4@DeRef|

; 51   :         }
; 52   :         return (DWORD)lReturn;
; 53   :     }

  00038	e1a00005	 mov         r0, r5
  0003c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M36222|

			 ENDP  ; |?DeRef@CRefObject@@QAAKXZ|, CRefObject::DeRef

	EXPORT	|?SlotOptionHandler@CSDHost@@QAAJKW4_SD_SLOT_OPTION_CODE@@PAXK@Z| ; CSDHost::SlotOptionHandler
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdbus.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T36239| DCD	|$LN7@SlotOption|
	DCD	0x40000f02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SlotOptionHandler@CSDHost@@QAAJKW4_SD_SLOT_OPTION_CODE@@PAXK@Z| PROC ; CSDHost::SlotOptionHandler

; 139  :     SD_API_STATUS   SlotOptionHandler(DWORD dwSlot, SD_SLOT_OPTION_CODE sdSlotOption, PVOID pvParam, ULONG uSize) { // slot option handler

  00000		 |$LN7@SlotOption|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M36236|
  00008	e1a05002	 mov         r5, r2
  0000c	e1b0e000	 movs        lr, r0

; 140  :         return pSlotOptionHandler((PSDCARD_HC_CONTEXT)this,dwSlot,sdSlotOption,pvParam,uSize);

  00010	e59d2010	 ldr         r2, [sp, #0x10]
  00014	e59e4044	 ldr         r4, [lr, #0x44]
  00018	128e0008	 addne       r0, lr, #8
  0001c	e58d2000	 str         r2, [sp]
  00020	e1a02005	 mov         r2, r5
  00024	03a00000	 moveq       r0, #0
  00028	e1a0e00f	 mov         lr, pc
  0002c	e12fff14	 bx          r4

; 141  :     }

  00030	e28dd004	 add         sp, sp, #4
  00034	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$M36237|

			 ENDP  ; |?SlotOptionHandler@CSDHost@@QAAJKW4_SD_SLOT_OPTION_CODE@@PAXK@Z|, CSDHost::SlotOptionHandler

	EXPORT	|?ChangeCardPowerHandler@CSDHost@@QAAJKH@Z| ; CSDHost::ChangeCardPowerHandler

  00000			 AREA	 |.pdata|, PDATA
|$T36253| DCD	|$LN7@ChangeCard|
	DCD	0x40000901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ChangeCardPowerHandler@CSDHost@@QAAJKH@Z| PROC ; CSDHost::ChangeCardPowerHandler

; 147  :     SD_API_STATUS   ChangeCardPowerHandler(DWORD dwSlot, INT iPower) { ; // Pointer to power control handler

  00000		 |$LN7@ChangeCard|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36250|
  00004	e1b03000	 movs        r3, r0

; 148  :         return pChangeCardPowerHandler((PSDCARD_HC_CONTEXT)this,dwSlot,iPower);

  00008	12830008	 addne       r0, r3, #8
  0000c	e5933058	 ldr         r3, [r3, #0x58]
  00010	03a00000	 moveq       r0, #0
  00014	e1a0e00f	 mov         lr, pc
  00018	e12fff13	 bx          r3

; 149  :     }

  0001c	e49de004	 ldr         lr, [sp], #4
  00020	e12fff1e	 bx          lr
  00024		 |$M36251|

			 ENDP  ; |?ChangeCardPowerHandler@CSDHost@@QAAJKH@Z|, CSDHost::ChangeCardPowerHandler

	EXPORT	|?GetDeviceFuncionIndex@CSDDevice@@QAAKXZ| ; CSDDevice::GetDeviceFuncionIndex
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sddevice.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T36263| DCD	|$LN5@GetDeviceF|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetDeviceFuncionIndex@CSDDevice@@QAAKXZ| PROC ; CSDDevice::GetDeviceFuncionIndex

; 129  :     DWORD   GetDeviceFuncionIndex() { return m_FuncionIndex; };

  00000		 |$LN5@GetDeviceF|
  00000		 |$M36260|
  00000	e590043c	 ldr         r0, [r0, #0x43C]
  00004	e12fff1e	 bx          lr
  00008		 |$M36261|

			 ENDP  ; |?GetDeviceFuncionIndex@CSDDevice@@QAAKXZ|, CSDDevice::GetDeviceFuncionIndex

	EXPORT	|?GetDeviceType@CSDDevice@@QAA?AW4_SDCARD_DEVICE_TYPE@@XZ| ; CSDDevice::GetDeviceType

  00000			 AREA	 |.pdata|, PDATA
|$T36273| DCD	|$LN5@GetDeviceT|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetDeviceType@CSDDevice@@QAA?AW4_SDCARD_DEVICE_TYPE@@XZ| PROC ; CSDDevice::GetDeviceType

; 134  :     SDCARD_DEVICE_TYPE GetDeviceType() { return m_DeviceType; };

  00000		 |$LN5@GetDeviceT|
  00000		 |$M36270|
  00000	e5900494	 ldr         r0, [r0, #0x494]
  00004	e12fff1e	 bx          lr
  00008		 |$M36271|

			 ENDP  ; |?GetDeviceType@CSDDevice@@QAA?AW4_SDCARD_DEVICE_TYPE@@XZ|, CSDDevice::GetDeviceType

	EXPORT	|?GetHost@CSDSlot@@QAAAAVCSDHost@@XZ|	; CSDSlot::GetHost
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdslot.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T36283| DCD	|$LN5@GetHost|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetHost@CSDSlot@@QAAAAVCSDHost@@XZ| PROC ; CSDSlot::GetHost

; 99   :     CSDHost&    GetHost() { return m_SdHost; };

  00000		 |$LN5@GetHost|
  00000		 |$M36280|
  00000	e590007c	 ldr         r0, [r0, #0x7C]
  00004	e12fff1e	 bx          lr
  00008		 |$M36281|

			 ENDP  ; |?GetHost@CSDSlot@@QAAAAVCSDHost@@XZ|, CSDSlot::GetHost

	EXPORT	|?GetSlotIndex@CSDSlot@@QAAKXZ|		; CSDSlot::GetSlotIndex

  00000			 AREA	 |.pdata|, PDATA
|$T36293| DCD	|$LN5@GetSlotInd|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetSlotIndex@CSDSlot@@QAAKXZ| PROC	; CSDSlot::GetSlotIndex

; 106  :     DWORD   GetSlotIndex() { return m_dwSlotIndex; };

  00000		 |$LN5@GetSlotInd|
  00000		 |$M36290|
  00000	e5900080	 ldr         r0, [r0, #0x80]
  00004	e12fff1e	 bx          lr
  00008		 |$M36291|

			 ENDP  ; |?GetSlotIndex@CSDSlot@@QAAKXZ|, CSDSlot::GetSlotIndex

	EXPORT	|?GetSlotPower@CSDSlot@@QAAGXZ|		; CSDSlot::GetSlotPower

  00000			 AREA	 |.pdata|, PDATA
|$T36303| DCD	|$LN5@GetSlotPow|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetSlotPower@CSDSlot@@QAAGXZ| PROC	; CSDSlot::GetSlotPower

; 107  :     USHORT  GetSlotPower() { return m_AllocatedPower; };

  00000		 |$LN5@GetSlotPow|
  00000		 |$M36300|
  00000	e1d00bb0	 ldrh        r0, [r0, #0xB0]
  00004	e12fff1e	 bx          lr
  00008		 |$M36301|

			 ENDP  ; |?GetSlotPower@CSDSlot@@QAAGXZ|, CSDSlot::GetSlotPower

	EXPORT	|?SetSlotPower@CSDSlot@@QAAGG@Z|	; CSDSlot::SetSlotPower

  00000			 AREA	 |.pdata|, PDATA
|$T36314| DCD	|$LN5@SetSlotPow|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetSlotPower@CSDSlot@@QAAGG@Z| PROC	; CSDSlot::SetSlotPower

; 108  :     USHORT  SetSlotPower(USHORT allocatedPower) { return m_AllocatedPower = allocatedPower; };

  00000		 |$LN5@SetSlotPow|
  00000		 |$M36311|
  00000	e1c01bb0	 strh        r1, [r0, #0xB0]
  00004	e1a00001	 mov         r0, r1
  00008	e12fff1e	 bx          lr
  0000c		 |$M36312|

			 ENDP  ; |?SetSlotPower@CSDSlot@@QAAGG@Z|, CSDSlot::SetSlotPower

	EXPORT	|?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z| ; CSDSlot::GetFunctionDevice
; File c:\wince600\public\common\oak\inc\csync.h

  00000			 AREA	 |.pdata|, PDATA
|$T36337| DCD	|$LN15@GetFunctio|
	DCD	0x40001401
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdslot.hpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z| PROC ; CSDSlot::GetFunctionDevice

; 155  :     inline CSDDevice * GetFunctionDevice(DWORD dwIndex){

  00000		 |$LN15@GetFunctio|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M36334|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 156  :         m_SlotLock.Lock();

  0000c	e28500b4	 add         r0, r5, #0xB4
  00010	eb000000	 bl          EnterCriticalSection

; 157  :         CSDDevice*  pReturn = dwIndex < SD_MAXIMUM_DEVICE_PER_SLOT ? m_pFuncDevice[dwIndex] : NULL;

  00014	e3540008	 cmp         r4, #8
  00018	30853104	 addcc       r3, r5, r4, lsl #2
  0001c	359340c8	 ldrcc       r4, [r3, #0xC8]
  00020	23a04000	 movcs       r4, #0

; 158  :         if( pReturn )  {

  00024	e3540000	 cmp         r4, #0
  00028	0a000002	 beq         |$LN2@GetFunctio|

; 159  :             pReturn->AddRef();

  0002c	e2840004	 add         r0, r4, #4
  00030	eb000000	 bl          InterlockedIncrement

; 160  :         }
; 161  :         else

  00034	ea000000	 b           |$LN1@GetFunctio|
  00038		 |$LN2@GetFunctio|

; 162  :             pReturn = NULL;

  00038	e3a04000	 mov         r4, #0
  0003c		 |$LN1@GetFunctio|

; 163  :         m_SlotLock.Unlock();

  0003c	e28500b4	 add         r0, r5, #0xB4
  00040	eb000000	 bl          LeaveCriticalSection

; 164  :         return pReturn;
; 165  :     }

  00044	e1a00004	 mov         r0, r4
  00048	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M36335|

			 ENDP  ; |?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z|, CSDSlot::GetFunctionDevice

	EXPORT	|?IsSlotInterruptOn@CSDSlot@@QAAHXZ|	; CSDSlot::IsSlotInterruptOn

  00000			 AREA	 |.pdata|, PDATA
|$T36349| DCD	|$LN7@IsSlotInte|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsSlotInterruptOn@CSDSlot@@QAAHXZ| PROC ; CSDSlot::IsSlotInterruptOn

; 171  :     BOOL    IsSlotInterruptOn() { return ((m_Flags & SD_SLOT_FLAG_SDIO_INTERRUPTS_ENABLED)!=0) ; };

  00000		 |$LN7@IsSlotInte|
  00000		 |$M36346|
  00000	e5903088	 ldr         r3, [r0, #0x88]
  00004	e3130001	 tst         r3, #1
  00008	13a00001	 movne       r0, #1
  0000c	03a00000	 moveq       r0, #0
  00010	e12fff1e	 bx          lr
  00014		 |$M36347|

			 ENDP  ; |?IsSlotInterruptOn@CSDSlot@@QAAHXZ|, CSDSlot::IsSlotInterruptOn

	EXPORT	|?SDEnableDisableFunction@CSDDevice@@IAAJPAU_SD_IO_FUNCTION_ENABLE_INFO@@H@Z| ; CSDDevice::SDEnableDisableFunction
	IMPORT	|Sleep|
	IMPORT	|?GetFunctionPowerState@CSDDevice@@QAAJPAU_FUNCTION_POWER_STATE@@@Z| ; CSDDevice::GetFunctionPowerState

  00000			 AREA	 |.pdata|, PDATA
|$T36409| DCD	|$LN48@SDEnableDi|
	DCD	0x40007302
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdiofeat.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDEnableDisableFunction@CSDDevice@@IAAJPAU_SD_IO_FUNCTION_ENABLE_INFO@@H@Z| PROC ; CSDDevice::SDEnableDisableFunction

; 50   : {

  00000		 |$LN48@SDEnableDi|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd030	 sub         sp, sp, #0x30
  00008		 |$M36406|
  00008	e1a07002	 mov         r7, r2
  0000c	e1a09001	 mov         r9, r1
  00010	e1a06000	 mov         r6, r0

; 51   :     UCHAR                       regValue;       // temp register value
; 52   :     ULONG                       retryCount;     // ready retry count
; 53   :     SD_API_STATUS               status;         // intermediate status
; 54   :     BOOL                        fSkipIfMatch;   // Test for setting the same bit twice
; 55   :     FUNCTION_POWER_STATE        PowerState;     // The function's power state
; 56   : 
; 57   :     if (m_FuncionIndex == 0 ) {

  00014	e596343c	 ldr         r3, [r6, #0x43C]
  00018	e3530000	 cmp         r3, #0

; 58   :         DEBUGCHK(FALSE);
; 59   :         return SD_API_STATUS_INVALID_PARAMETER;

  0001c	03a0411f	 moveq       r4, #0x1F, 2
  00020	0a00002e	 beq         |$LN19@SDEnableDi|

; 60   :     }
; 61   : 
; 62   :     DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDEnableDisableFunction: Enabling/Disabling SDIO Device Function %d \n"), m_FuncionIndex));
; 63   :     
; 64   : 
; 65   :         // Get the functions power state
; 66   :     status = GetFunctionPowerState(&PowerState);

  00024	e28d100c	 add         r1, sp, #0xC
  00028	e1a00006	 mov         r0, r6
  0002c	eb000000	 bl          |?GetFunctionPowerState@CSDDevice@@QAAJPAU_FUNCTION_POWER_STATE@@@Z|
  00030	e1b04000	 movs        r4, r0

; 67   : 
; 68   :     if (!SD_API_SUCCESS(status)) {
; 69   :         return status;

  00034	4a000029	 bmi         |$LN19@SDEnableDi|

; 70   :     }
; 71   : 
; 72   :     // First check if states already match
; 73   :     fSkipIfMatch = FALSE;
; 74   :     if (PowerState.fFunctionEnabled == Enable) {

  00038	e59d3014	 ldr         r3, [sp, #0x14]
  0003c	e3a0b001	 mov         r11, #1
  00040	e1530007	 cmp         r3, r7
  00044	1a000029	 bne         |$LN40@SDEnableDi|
  00048		 |$LN45@SDEnableDi|

; 75   :         if (Enable) { 

  00048	e3570000	 cmp         r7, #0

; 76   :             DEBUGMSG(SDCARD_ZONE_WARN,(TEXT("SDEnableDisableFunction: Attempting to enable function that is already enabled \n")));
; 77   :             fSkipIfMatch = TRUE;
; 78   :         }
; 79   :         else {

  0004c	0a000023	 beq         |$LN19@SDEnableDi|

; 119  :             return status;
; 120  :         }
; 121  :     }
; 122  : 
; 123  :     // if enabling we check for I/O ready
; 124  :     if (Enable) { 
; 125  :         CSDDevice *pDevice0 = m_sdSlot.GetFunctionDevice(0 );

  00050	e5960438	 ldr         r0, [r6, #0x438]
  00054	e3a01000	 mov         r1, #0
  00058	eb000000	 bl          |?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z|
  0005c	e1b07000	 movs        r7, r0

; 126  :         status = SD_API_STATUS_NO_SUCH_DEVICE;

  00060	e3a04123	 mov         r4, #0x23, 2

; 127  :         if (pDevice0) {

  00064	0a00001d	 beq         |$LN19@SDEnableDi|

; 128  :             retryCount = pInfo->ReadyRetryCount;

  00068	e5993000	 ldr         r3, [r9]
  0006c	e1b05003	 movs        r5, r3

; 129  : 
; 130  :             while (retryCount) {

  00070	0a000017	 beq         |$LN39@SDEnableDi|
  00074	e28d8008	 add         r8, sp, #8
  00078	e3a0a001	 mov         r10, #1
  0007c		 |$LL5@SDEnableDi|

; 131  :                 // delay the interval time
; 132  :                 Sleep(pInfo->Interval);

  0007c	e5990004	 ldr         r0, [r9, #4]
  00080	eb000000	 bl          Sleep

; 133  : 
; 134  :                 // read the I/O ready register
; 135  :                 status = pDevice0->SDReadWriteRegistersDirect_I( SD_IO_READ, SD_IO_REG_IO_READY,FALSE,&regValue,1);         // one byte

  00084	e5971000	 ldr         r1, [r7]
  00088	e3a03000	 mov         r3, #0
  0008c	e3a02003	 mov         r2, #3
  00090	e5914010	 ldr         r4, [r1, #0x10]
  00094	e3a01000	 mov         r1, #0
  00098	e1a00007	 mov         r0, r7
  0009c	e58db004	 str         r11, [sp, #4]
  000a0	e58d8000	 str         r8, [sp]
  000a4	e1a0e00f	 mov         lr, pc
  000a8	e12fff14	 bx          r4
  000ac	e1b04000	 movs        r4, r0

; 136  :                 if (!SD_API_SUCCESS(status)) {

  000b0	4a000005	 bmi         |$LN36@SDEnableDi|

; 137  :                     break;
; 138  :                 }
; 139  : 
; 140  :                 // see if it is ready
; 141  :                 if (regValue & (1 << m_SDCardInfo.SDIOInformation.Function)) {

  000b4	e5d624d8	 ldrb        r2, [r6, #0x4D8]
  000b8	e5dd3008	 ldrb        r3, [sp, #8]
  000bc	e113021a	 tst         r3, r10, lsl r2
  000c0	1a000001	 bne         |$LN36@SDEnableDi|

; 142  :                     DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDEnableDisableFunction: Card Function %d is now ready \n"),
; 143  :                         m_SDCardInfo.SDIOInformation.Function));
; 144  :                     break;
; 145  :                 }
; 146  :                 // decrement the count
; 147  :                 retryCount--; 

  000c4	e2555001	 subs        r5, r5, #1

; 129  : 
; 130  :             while (retryCount) {

  000c8	1affffeb	 bne         |$LL5@SDEnableDi|
  000cc		 |$LN36@SDEnableDi|

; 148  :                 DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDEnableDisableFunction: Card Function %d, Not Ready, re-checking (%d) \n"),
; 149  :                     m_SDCardInfo.SDIOInformation.Function, retryCount));
; 150  :             }
; 151  : 
; 152  :             if (0 == retryCount) {

  000cc	e3550000	 cmp         r5, #0
  000d0	1a000000	 bne         |$LN1@SDEnableDi|
  000d4		 |$LN39@SDEnableDi|

; 153  :                 DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDEnableDisableFunction: Card Function %d, Not ready , exceeded retry count\n"),
; 154  :                     m_SDCardInfo.SDIOInformation.Function));
; 155  :                 status = SD_API_STATUS_DEVICE_NOT_RESPONDING;

  000d4	e3a0414b	 mov         r4, #0x4B, 2
  000d8		 |$LN1@SDEnableDi|

; 156  :             }
; 157  :             pDevice0->DeRef();

  000d8	e1a00007	 mov         r0, r7
  000dc	eb000000	 bl          |?DeRef@CRefObject@@QAAKXZ|
  000e0		 |$LN19@SDEnableDi|

; 158  :         }
; 159  :     }
; 160  : 
; 161  :     return status;
; 162  : } 

  000e0	e1a00004	 mov         r0, r4
  000e4	e28dd030	 add         sp, sp, #0x30
  000e8	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  000ec	e12fff1e	 bx          lr
  000f0		 |$LN40@SDEnableDi|

; 80   :             DEBUGMSG(SDCARD_ZONE_WARN,(TEXT("SDEnableDisableFunction: Attempting to disable function that is already disabled \n")));
; 81   :             fSkipIfMatch = TRUE;
; 82   :         }
; 83   :     }
; 84   :         
; 85   :     if (!fSkipIfMatch) {
; 86   :         // Attempt to change cards power draw
; 87   :         status = m_sdSlot.GetHost().ChangeCardPowerHandler(m_sdSlot.GetSlotIndex(),PowerState.EnableDelta);

  000f0	e5963438	 ldr         r3, [r6, #0x438]
  000f4	e593207c	 ldr         r2, [r3, #0x7C]
  000f8	e5931080	 ldr         r1, [r3, #0x80]
  000fc	e1b03002	 movs        r3, r2
  00100	e59d2028	 ldr         r2, [sp, #0x28]
  00104	12830008	 addne       r0, r3, #8
  00108	e5933058	 ldr         r3, [r3, #0x58]
  0010c	03a00000	 moveq       r0, #0
  00110	e1a0e00f	 mov         lr, pc
  00114	e12fff13	 bx          r3
  00118	e1b04000	 movs        r4, r0

; 88   : 
; 89   :         if (!SD_API_SUCCESS(status)) {
; 90   :             return status;

  0011c	4affffef	 bmi         |$LN19@SDEnableDi|

; 91   :         }
; 92   : 
; 93   :             //update the power used at the slot
; 94   :         {
; 95   :             INT SlotPower = m_sdSlot.GetSlotPower();

  00120	e5963438	 ldr         r3, [r6, #0x438]

; 96   :             SlotPower += PowerState.EnableDelta;

  00124	e59d2028	 ldr         r2, [sp, #0x28]

; 97   :             m_sdSlot.SetSlotPower( SlotPower >= 0? (USHORT)SlotPower : 0 );
; 98   :         }
; 99   : 
; 100  :         CSDDevice *pDevice0 = m_sdSlot.GetFunctionDevice(0 );

  00128	e3a01000	 mov         r1, #0
  0012c	e1d33bb0	 ldrh        r3, [r3, #0xB0]
  00130	e0933002	 adds        r3, r3, r2
  00134	51a02803	 movpl       r2, r3, lsl #16
  00138	e5963438	 ldr         r3, [r6, #0x438]
  0013c	51a02822	 movpl       r2, r2, lsr #16
  00140	43a02000	 movmi       r2, #0
  00144	e1c32bb0	 strh        r2, [r3, #0xB0]
  00148	e5960438	 ldr         r0, [r6, #0x438]
  0014c	eb000000	 bl          |?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z|
  00150	e1b08000	 movs        r8, r0

; 101  :         status = SD_API_STATUS_NO_SUCH_DEVICE;

  00154	e3a04123	 mov         r4, #0x23, 2

; 102  :         if (pDevice0) {

  00158	0affffe0	 beq         |$LN19@SDEnableDi|

; 103  :                 // update the parent device shadow register
; 104  :             if (Enable) {     
; 105  :                 pDevice0->m_SDCardInfo.SDIOInformation.pCommonInformation->CCCRShadowIOEnable 
; 106  :                     |= (1 <<  m_SDCardInfo.SDIOInformation.Function);

  0015c	e59814ec	 ldr         r1, [r8, #0x4EC]
  00160	e5d624d8	 ldrb        r2, [r6, #0x4D8]
  00164	e3570000	 cmp         r7, #0
  00168	e5d13011	 ldrb        r3, [r1, #0x11]
  0016c	e3a00001	 mov         r0, #1

; 107  :             } else {
; 108  :                 pDevice0->m_SDCardInfo.SDIOInformation.pCommonInformation->CCCRShadowIOEnable &= 
; 109  :                     ~(1 <<  m_SDCardInfo.SDIOInformation.Function);
; 110  :             }
; 111  :             // get a copy
; 112  :             regValue = pDevice0->m_SDCardInfo.SDIOInformation.pCommonInformation->CCCRShadowIOEnable;
; 113  : 
; 114  :             // update the register
; 115  :             status = pDevice0->SDReadWriteRegistersDirect_I(SD_IO_WRITE, SD_IO_REG_ENABLE,FALSE, &regValue, 1);

  00170	e28d5008	 add         r5, sp, #8
  00174	11833210	 orrne       r3, r3, r0, lsl r2
  00178	e58db004	 str         r11, [sp, #4]
  0017c	01c33210	 biceq       r3, r3, r0, lsl r2
  00180	e58d5000	 str         r5, [sp]
  00184	e5c13011	 strb        r3, [r1, #0x11]
  00188	e59824ec	 ldr         r2, [r8, #0x4EC]
  0018c	e3a03000	 mov         r3, #0
  00190	e3a01001	 mov         r1, #1
  00194	e5d20011	 ldrb        r0, [r2, #0x11]
  00198	e3a02002	 mov         r2, #2
  0019c	e5cd0008	 strb        r0, [sp, #8]
  001a0	e5984000	 ldr         r4, [r8]
  001a4	e1a00008	 mov         r0, r8
  001a8	e5944010	 ldr         r4, [r4, #0x10]
  001ac	e1a0e00f	 mov         lr, pc
  001b0	e12fff14	 bx          r4
  001b4	e1a04000	 mov         r4, r0

; 116  :             pDevice0->DeRef();

  001b8	e1a00008	 mov         r0, r8
  001bc	eb000000	 bl          |?DeRef@CRefObject@@QAAKXZ|

; 117  :         }        
; 118  :         if (!SD_API_SUCCESS(status)) {

  001c0	e3540000	 cmp         r4, #0
  001c4	4affffc5	 bmi         |$LN19@SDEnableDi|
  001c8	eaffff9e	 b           |$LN45@SDEnableDi|
  001cc		 |$M36407|

			 ENDP  ; |?SDEnableDisableFunction@CSDDevice@@IAAJPAU_SD_IO_FUNCTION_ENABLE_INFO@@H@Z|, CSDDevice::SDEnableDisableFunction

	EXPORT	|?SDFunctionSelectPower@CSDDevice@@IAAJH@Z| ; CSDDevice::SDFunctionSelectPower
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdslot.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T36460| DCD	|$LN32@SDFunction|
	DCD	0x40005b02
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdiofeat.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDFunctionSelectPower@CSDDevice@@IAAJH@Z| PROC ; CSDDevice::SDFunctionSelectPower

; 175  : {

  00000		 |$LN32@SDFunction|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd030	 sub         sp, sp, #0x30
  00008		 |$M36457|
  00008	e1a07001	 mov         r7, r1
  0000c	e1a05000	 mov         r5, r0

; 176  :     UCHAR                       regValue;       // temp register value
; 177  :     SD_API_STATUS               status;         // intermediate status
; 178  :     FUNCTION_POWER_STATE        PowerState;     // The function's power state
; 179  :     DWORD                       FBROffset;      // calculated FBR offset
; 180  : 
; 181  : 
; 182  :         // get the parent device
; 183  :     
; 184  :     if (0 == m_FuncionIndex) {

  00010	e595343c	 ldr         r3, [r5, #0x43C]
  00014	e3530000	 cmp         r3, #0

; 185  :         DEBUG_ASSERT(FALSE);
; 186  :         return SD_API_STATUS_INVALID_PARAMETER;

  00018	03a0411f	 moveq       r4, #0x1F, 2
  0001c	0a00004e	 beq         |$LN13@SDFunction|

; 187  :     }
; 188  : 
; 189  :     DEBUGMSG(SDBUS_ZONE_DEVICE, (TEXT("SDFunctionSelectPower: SDIO Device Function %d Power Select\n"),
; 190  :             m_SDCardInfo.SDIOInformation.Function));
; 191  : 
; 192  :         // Get the functions power state
; 193  :     status = GetFunctionPowerState(&PowerState);

  00020	e28d100c	 add         r1, sp, #0xC
  00024	e1a00005	 mov         r0, r5
  00028	eb000000	 bl          |?GetFunctionPowerState@CSDDevice@@QAAJPAU_FUNCTION_POWER_STATE@@@Z|
  0002c	e1b04000	 movs        r4, r0

; 194  : 
; 195  :     if (!SD_API_SUCCESS(status)) {
; 196  :         return status;

  00030	4a000049	 bmi         |$LN13@SDFunction|

; 197  :     }
; 198  : 
; 199  :     //check if power selection is supported
; 200  :     if((!PowerState.fPowerControlSupport) || (!PowerState.fSupportsPowerSelect)) {

  00034	e59d300c	 ldr         r3, [sp, #0xC]
  00038	e3530000	 cmp         r3, #0
  0003c	0a000045	 beq         |$LN9@SDFunction|
  00040	e59d3018	 ldr         r3, [sp, #0x18]
  00044	e3530000	 cmp         r3, #0
  00048	0a000042	 beq         |$LN9@SDFunction|

; 203  :     }
; 204  :     // Check if states already match
; 205  :     if (PowerState.fLowPower == fLowPower){

  0004c	e59d301c	 ldr         r3, [sp, #0x1C]
  00050	e1530007	 cmp         r3, r7

; 206  :         if (fLowPower) { 
; 207  :             DEBUGMSG(SDCARD_ZONE_WARN, (TEXT("SDFunctionSelectPower: Attempting to select low power state when that is already enabled \n")));
; 208  :         }
; 209  :         else{
; 210  :             DEBUGMSG(SDCARD_ZONE_WARN, (TEXT("SDFunctionSelectPower: Attempting to select high power state when that is already enabled \n")));
; 211  :         }
; 212  :         return SD_API_STATUS_SUCCESS;

  00054	03a04000	 moveq       r4, #0
  00058	0a00003f	 beq         |$LN13@SDFunction|

; 213  :     }
; 214  :         
; 215  :     // Attempt to change cards power draw
; 216  :     status = m_sdSlot.GetHost().ChangeCardPowerHandler(m_sdSlot.GetSlotIndex(),PowerState.SelectDelta);

  0005c	e5953438	 ldr         r3, [r5, #0x438]
  00060	e593207c	 ldr         r2, [r3, #0x7C]
  00064	e5931080	 ldr         r1, [r3, #0x80]
  00068	e1b03002	 movs        r3, r2
  0006c	e59d202c	 ldr         r2, [sp, #0x2C]
  00070	12830008	 addne       r0, r3, #8
  00074	e5933058	 ldr         r3, [r3, #0x58]
  00078	03a00000	 moveq       r0, #0
  0007c	e1a0e00f	 mov         lr, pc
  00080	e12fff13	 bx          r3
  00084	e1b04000	 movs        r4, r0

; 217  :     if (!SD_API_SUCCESS(status)) {
; 218  :         return status;

  00088	4a000033	 bmi         |$LN13@SDFunction|

; 219  :     }
; 220  : 
; 221  :     //update the power used at the slot
; 222  :     {
; 223  :         INT SlotPower = m_sdSlot.GetSlotPower();

  0008c	e5953438	 ldr         r3, [r5, #0x438]

; 224  :         SlotPower += PowerState.SelectDelta;

  00090	e59d202c	 ldr         r2, [sp, #0x2C]

; 225  :         m_sdSlot.SetSlotPower( SlotPower >= 0? (USHORT)SlotPower : 0 );
; 226  :     }
; 227  : 
; 228  :     CSDDevice *pDevice0 = m_sdSlot.GetFunctionDevice(0 );

  00094	e3a01000	 mov         r1, #0
  00098	e1d33bb0	 ldrh        r3, [r3, #0xB0]
  0009c	e0933002	 adds        r3, r3, r2
  000a0	51a02803	 movpl       r2, r3, lsl #16
  000a4	e5953438	 ldr         r3, [r5, #0x438]
  000a8	51a02822	 movpl       r2, r2, lsr #16
  000ac	43a02000	 movmi       r2, #0
  000b0	e1c32bb0	 strh        r2, [r3, #0xB0]
  000b4	e5950438	 ldr         r0, [r5, #0x438]
  000b8	eb000000	 bl          |?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z|
  000bc	e1b06000	 movs        r6, r0

; 229  :     status = SD_API_STATUS_NO_SUCH_DEVICE;

  000c0	e3a04123	 mov         r4, #0x23, 2

; 230  :     if (pDevice0) {

  000c4	0a000024	 beq         |$LN13@SDFunction|

; 231  :         // select the function's power state
; 232  :         FBROffset = SD_IO_FBR_1_OFFSET + (m_SDCardInfo.SDIOInformation.Function - 1) * SD_IO_FBR_LENGTH;

  000c8	e5d534d8	 ldrb        r3, [r5, #0x4D8]

; 233  :         status = pDevice0->SDReadWriteRegistersDirect_I(SD_IO_READ,FBROffset + SD_IO_FBR_POWER_SELECT,FALSE,&regValue,1); 

  000cc	e5962000	 ldr         r2, [r6]
  000d0	e28d5008	 add         r5, sp, #8
  000d4	e1a08403	 mov         r8, r3, lsl #8
  000d8	e5924010	 ldr         r4, [r2, #0x10]
  000dc	e3a09001	 mov         r9, #1
  000e0	e2882002	 add         r2, r8, #2
  000e4	e3a03000	 mov         r3, #0
  000e8	e3a01000	 mov         r1, #0
  000ec	e1a00006	 mov         r0, r6
  000f0	e58d9004	 str         r9, [sp, #4]
  000f4	e58d5000	 str         r5, [sp]
  000f8	e1a0e00f	 mov         lr, pc
  000fc	e12fff14	 bx          r4
  00100	e1b04000	 movs        r4, r0

; 234  : 
; 235  :         if (SD_API_SUCCESS(status)) {

  00104	4a000010	 bmi         |$LN3@SDFunction|

; 236  :             if(fLowPower) {
; 237  :                 regValue |= SD_IO_FUNCTION_POWER_SELECT_STATE;

  00108	e5dd3008	 ldrb        r3, [sp, #8]
  0010c	e3570000	 cmp         r7, #0

; 238  :             }
; 239  :             else {
; 240  :                 regValue &= ~SD_IO_FUNCTION_POWER_SELECT_STATE;
; 241  :             }
; 242  : 
; 243  :             status = pDevice0->SDReadWriteRegistersDirect_I(SD_IO_WRITE,FBROffset + SD_IO_FBR_POWER_SELECT,FALSE,&regValue,1);

  00110	e28d5008	 add         r5, sp, #8
  00114	13833002	 orrne       r3, r3, #2
  00118	020330fd	 andeq       r3, r3, #0xFD
  0011c	e5cd3008	 strb        r3, [sp, #8]
  00120	e5962000	 ldr         r2, [r6]
  00124	e3a03000	 mov         r3, #0
  00128	e3a01001	 mov         r1, #1
  0012c	e5924010	 ldr         r4, [r2, #0x10]
  00130	e2882002	 add         r2, r8, #2
  00134	e1a00006	 mov         r0, r6
  00138	e58d9004	 str         r9, [sp, #4]
  0013c	e58d5000	 str         r5, [sp]
  00140	e1a0e00f	 mov         lr, pc
  00144	e12fff14	 bx          r4
  00148	e1a04000	 mov         r4, r0
  0014c		 |$LN3@SDFunction|

; 244  :         }
; 245  :         pDevice0->DeRef();

  0014c	e1a00006	 mov         r0, r6
  00150	eb000000	 bl          |?DeRef@CRefObject@@QAAKXZ|

; 246  :     }
; 247  :     return status;

  00154	ea000000	 b           |$LN13@SDFunction|
  00158		 |$LN9@SDFunction|

; 201  :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDFunctionSelectPower: Card or Function does not support Power Select.\n")));
; 202  :         return SD_API_STATUS_INVALID_DEVICE_REQUEST;

  00158	e3a04127	 mov         r4, #0x27, 2
  0015c		 |$LN13@SDFunction|

; 248  : } 

  0015c	e1a00004	 mov         r0, r4
  00160	e28dd030	 add         sp, sp, #0x30
  00164	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00168	e12fff1e	 bx          lr
  0016c		 |$M36458|

			 ENDP  ; |?SDFunctionSelectPower@CSDDevice@@IAAJH@Z|, CSDDevice::SDFunctionSelectPower

	EXPORT	|?SDSetFunctionBlockSize@CSDDevice@@IAAJK@Z| ; CSDDevice::SDSetFunctionBlockSize

  00000			 AREA	 |.pdata|, PDATA
|$T36474| DCD	|$LN6@SDSetFunct|
	DCD	0x40001f02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDSetFunctionBlockSize@CSDDevice@@IAAJK@Z| PROC ; CSDDevice::SDSetFunctionBlockSize

; 260  : {

  00000		 |$LN6@SDSetFunct|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M36471|
  00008	e1a02001	 mov         r2, r1

; 261  :     USHORT bytesPerBlock = (USHORT)BlockSize; // desired block size
; 262  :     DWORD                  FBROffset;         // FBR offset
; 263  :     SD_API_STATUS          status;
; 264  :     
; 265  :     DEBUGCHK(0 != m_SDCardInfo.SDIOInformation.Function);
; 266  :     // calculate the FBR offset based on the function number
; 267  :     FBROffset = SD_IO_FBR_1_OFFSET + (m_SDCardInfo.SDIOInformation.Function - 1) * SD_IO_FBR_LENGTH;

  0000c	e5d034d8	 ldrb        r3, [r0, #0x4D8]

; 268  :     CSDDevice *pDevice0 = m_sdSlot.GetFunctionDevice(0 );

  00010	e5900438	 ldr         r0, [r0, #0x438]
  00014	e3a01000	 mov         r1, #0
  00018	e1a07403	 mov         r7, r3, lsl #8
  0001c	e1cd20b8	 strh        r2, [sp, #8]
  00020	eb000000	 bl          |?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z|
  00024	e1b06000	 movs        r6, r0

; 269  :     status = SD_API_STATUS_NO_SUCH_DEVICE;

  00028	e3a04123	 mov         r4, #0x23, 2

; 270  :     
; 271  :     if (pDevice0) {

  0002c	0a00000e	 beq         |$LN1@SDSetFunct|

; 272  :         // update the register
; 273  :         status = pDevice0->SDReadWriteRegistersDirect_I( SD_IO_WRITE, FBROffset + SD_IO_FBR_IO_BLOCK_SIZE, FALSE,(PUCHAR)&bytesPerBlock,sizeof(USHORT));           // two bytes    

  00030	e5963000	 ldr         r3, [r6]
  00034	e3a08002	 mov         r8, #2
  00038	e28d4008	 add         r4, sp, #8
  0003c	e5935010	 ldr         r5, [r3, #0x10]
  00040	e3a03000	 mov         r3, #0
  00044	e2872010	 add         r2, r7, #0x10
  00048	e3a01001	 mov         r1, #1
  0004c	e1a00006	 mov         r0, r6
  00050	e58d8004	 str         r8, [sp, #4]
  00054	e58d4000	 str         r4, [sp]
  00058	e1a0e00f	 mov         lr, pc
  0005c	e12fff15	 bx          r5
  00060	e1a04000	 mov         r4, r0

; 274  :         pDevice0->DeRef();

  00064	e1a00006	 mov         r0, r6
  00068	eb000000	 bl          |?DeRef@CRefObject@@QAAKXZ|
  0006c		 |$LN1@SDSetFunct|

; 275  :     }
; 276  :     
; 277  :     return status;
; 278  : }

  0006c	e1a00004	 mov         r0, r4
  00070	e28dd00c	 add         sp, sp, #0xC
  00074	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00078	e12fff1e	 bx          lr
  0007c		 |$M36472|

			 ENDP  ; |?SDSetFunctionBlockSize@CSDDevice@@IAAJK@Z|, CSDDevice::SDSetFunctionBlockSize

	EXPORT	|?SetCardFeature_Interface@CSDDevice@@IAAJAAU_SD_CARD_INTERFACE_EX@@@Z| ; CSDDevice::SetCardFeature_Interface
	IMPORT	|?SetCardInterface@CSDDevice@@QAAJPAU_SD_CARD_INTERFACE_EX@@@Z| ; CSDDevice::SetCardInterface
	IMPORT	|?SlotSetupInterface@CSDHost@@IAAJKPAU_SD_CARD_INTERFACE_EX@@@Z| ; CSDHost::SlotSetupInterface
	IMPORT	|memcpy|
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdslot.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T36529| DCD	|$LN49@SetCardFea|
	DCD	0x40007802
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdiofeat.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetCardFeature_Interface@CSDDevice@@IAAJAAU_SD_CARD_INTERFACE_EX@@@Z| PROC ; CSDDevice::SetCardFeature_Interface

; 280  : {

  00000		 |$LN49@SetCardFea|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd024	 sub         sp, sp, #0x24
  00008		 |$M36526|
  00008	e1a0b001	 mov         r11, r1
  0000c	e1a04000	 mov         r4, r0

; 281  :     SD_API_STATUS               status = SD_API_STATUS_SUCCESS;  // intermediate status

  00010	e3a08000	 mov         r8, #0
  00014	e58d8000	 str         r8, [sp]

; 282  :     // Check if the slot can accept this interface request
; 283  :     // For multifunction card or combo card, the requested interface may not be fitted
; 284  :     // for other functions.
; 285  :     {
; 286  :         BOOL bAllFunctionsAcceptThisInterface = TRUE;

  00018	e3a05001	 mov         r5, #1

; 287  : 
; 288  :         // Start from parent device
; 289  :         BOOL fContinue = TRUE; 

  0001c	e3a07001	 mov         r7, #1

; 290  :         for (DWORD dwIndex = 0; dwIndex < SD_MAXIMUM_DEVICE_PER_SLOT && fContinue ; dwIndex++) {

  00020	e3a06000	 mov         r6, #0
  00024		 |$LL23@SetCardFea|
  00024	e3570000	 cmp         r7, #0
  00028	0a00001f	 beq         |$LN21@SetCardFea|

; 291  :             CSDDevice * pDevice = m_sdSlot.GetFunctionDevice(dwIndex);

  0002c	e5940438	 ldr         r0, [r4, #0x438]
  00030	e1a01006	 mov         r1, r6
  00034	eb000000	 bl          |?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z|
  00038	e3500000	 cmp         r0, #0

; 292  :             if (pDevice != NULL ) {

  0003c	0a000017	 beq         |$LN22@SetCardFea|

; 293  :                 if (dwIndex!=GetDeviceFuncionIndex() &&  pDevice->GetDeviceType() != Device_Unknown ) {

  00040	e594343c	 ldr         r3, [r4, #0x43C]
  00044	e1560003	 cmp         r6, r3
  00048	0a000013	 beq         |$LN14@SetCardFea|
  0004c	e5903494	 ldr         r3, [r0, #0x494]
  00050	e3530000	 cmp         r3, #0
  00054	0a000010	 beq         |$LN14@SetCardFea|

; 294  :                     // Check if current device supports 4 bit mode request
; 295  :                     if (CardInterfaceEx.InterfaceModeEx.bit.sd4Bit && !(pDevice->m_CardInterfaceEx.InterfaceModeEx.bit.sd4Bit)) {

  00058	e59b1000	 ldr         r1, [r11]
  0005c	e3110001	 tst         r1, #1
  00060	0a000002	 beq         |$LN18@SetCardFea|
  00064	e5903540	 ldr         r3, [r0, #0x540]
  00068	e3130001	 tst         r3, #1

; 296  :                         bAllFunctionsAcceptThisInterface = FALSE;
; 297  :                         fContinue = FALSE;
; 298  :                     }
; 299  :                     else

  0006c	0a000008	 beq         |$LN46@SetCardFea|
  00070		 |$LN18@SetCardFea|

; 300  :                     // Check if request clock rate is too high for this device
; 301  :                     if (CardInterfaceEx.ClockRate > pDevice->m_CardInterfaceEx.ClockRate) {

  00070	e59b2004	 ldr         r2, [r11, #4]
  00074	e5903544	 ldr         r3, [r0, #0x544]
  00078	e1520003	 cmp         r2, r3

; 302  :                         bAllFunctionsAcceptThisInterface = FALSE;
; 303  :                         fContinue = FALSE;
; 304  :                     }
; 305  :                     else 

  0007c	8a000004	 bhi         |$LN46@SetCardFea|

; 306  :                     if (!(CardInterfaceEx.InterfaceModeEx.bit.sdHighSpeed) && pDevice->m_CardInterfaceEx.InterfaceModeEx.bit.sdHighSpeed){

  00080	e3110002	 tst         r1, #2
  00084	1a000004	 bne         |$LN14@SetCardFea|
  00088	e5903540	 ldr         r3, [r0, #0x540]
  0008c	e3130002	 tst         r3, #2
  00090	0a000001	 beq         |$LN14@SetCardFea|
  00094		 |$LN46@SetCardFea|

; 307  :                         bAllFunctionsAcceptThisInterface = FALSE;

  00094	e3a05000	 mov         r5, #0

; 308  :                         fContinue = FALSE;

  00098	e3a07000	 mov         r7, #0
  0009c		 |$LN14@SetCardFea|

; 309  :                     }
; 310  :                 }
; 311  :                 pDevice->DeRef();

  0009c	eb000000	 bl          |?DeRef@CRefObject@@QAAKXZ|
  000a0		 |$LN22@SetCardFea|
  000a0	e2866001	 add         r6, r6, #1
  000a4	e3560008	 cmp         r6, #8
  000a8	3affffdd	 bcc         |$LL23@SetCardFea|
  000ac		 |$LN21@SetCardFea|

; 312  :             }
; 313  :         }
; 314  : 
; 315  :         if (bAllFunctionsAcceptThisInterface == FALSE) {

  000ac	e3550000	 cmp         r5, #0

; 316  :             DbgPrintZo(SDCARD_ZONE_ERROR, (TEXT("SDSetCardFeature: SD_SET_CARD_INTERFACE - invalod interface request\n")));
; 317  :             return SD_API_STATUS_INVALID_DEVICE_REQUEST;

  000b0	03a08127	 moveq       r8, #0x27, 2
  000b4	0a000045	 beq         |$LN24@SetCardFea|

; 318  :         }
; 319  :     }
; 320  : 
; 321  :     // Changing the bus width is tricky when SDIO interrupts are 
; 322  :     // enabled. In 1-bit mode, DAT[1] is used as the interrupt line.
; 323  :     // In 4-bit mode, DAT[1] is used for data and interrupts. If
; 324  :     // we change from 1-bit mode to 4-bit mode while interrupts are 
; 325  :     // occurring (like when a BTH mouse is being moved franticly), we
; 326  :     // need to disable SDIO interrupts while we are changing the mode
; 327  :     // on both the host controller and the card. Otherwise an interrupt in
; 328  :     // the middle could confuse the host controller.
; 329  : 
; 330  :     PSD_INTERRUPT_CALLBACK pInterruptCallBack = NULL;
; 331  :     if ( (Device_SD_IO == m_DeviceType) && m_sdSlot.IsSlotInterruptOn() && 
; 332  :              (m_CardInterfaceEx.InterfaceModeEx.bit.sd4Bit != CardInterfaceEx.InterfaceModeEx.bit.sd4Bit) ) {

  000b8	e5943494	 ldr         r3, [r4, #0x494]
  000bc	e3a07000	 mov         r7, #0
  000c0	e3530003	 cmp         r3, #3
  000c4	1a00000e	 bne         |$LN12@SetCardFea|
  000c8	e5943438	 ldr         r3, [r4, #0x438]
  000cc	e5933088	 ldr         r3, [r3, #0x88]
  000d0	e3130001	 tst         r3, #1
  000d4	159b2000	 ldrne       r2, [r11]
  000d8	15943540	 ldrne       r3, [r4, #0x540]
  000dc	10223003	 eorne       r3, r2, r3
  000e0	13130001	 tstne       r3, #1

; 333  :         // Temporarily disable SDIO interrupts
; 334  :         pInterruptCallBack = m_SDCardInfo.SDIOInformation.pInterruptCallBack;
; 335  :         DEBUGCHK(pInterruptCallBack);
; 336  :         SDIOConnectDisconnectInterrupt( NULL, FALSE);

  000e4	15943000	 ldrne       r3, [r4]
  000e8	159474e8	 ldrne       r7, [r4, #0x4E8]
  000ec	13a02000	 movne       r2, #0
  000f0	15933028	 ldrne       r3, [r3, #0x28]
  000f4	13a01000	 movne       r1, #0
  000f8	11a00004	 movne       r0, r4
  000fc	11a0e00f	 movne       lr, pc
  00100	112fff13	 bxne        r3
  00104		 |$LN12@SetCardFea|

; 337  :     }
; 338  :     SD_CARD_INTERFACE_EX CardInterfaceExBackup = m_CardInterfaceEx;

  00104	e28d0004	 add         r0, sp, #4
  00108	e2841d15	 add         r1, r4, #0x15, 26
  0010c	e3a02020	 mov         r2, #0x20
  00110	eb000000	 bl          memcpy

; 339  :     BOOL isRestore = FALSE;

  00114	e3a0a000	 mov         r10, #0
  00118		 |$LL11@SetCardFea|

; 340  :     while (TRUE) {
; 341  :         SD_API_STATUS inStatus = SD_API_STATUS_SUCCESS ;
; 342  :         
; 343  :         // check for success
; 344  :         BOOL fContinue = TRUE;
; 345  :         if (SD_API_SUCCESS(inStatus)) {
; 346  :             // set the card interface for device's slot        
; 347  :             inStatus = m_sdSlot.GetHost().SlotSetupInterface(m_sdSlot.GetSlotIndex(),&CardInterfaceEx);

  00118	e5943438	 ldr         r3, [r4, #0x438]
  0011c	e1a0200b	 mov         r2, r11
  00120	e5931080	 ldr         r1, [r3, #0x80]
  00124	e593007c	 ldr         r0, [r3, #0x7C]
  00128	eb000000	 bl          |?SlotSetupInterface@CSDHost@@IAAJKPAU_SD_CARD_INTERFACE_EX@@@Z|
  0012c	e1b09000	 movs        r9, r0

; 348  :             //m_sdSlot.GetHost().SlotOptionHandler(m_sdSlot.GetSlotIndex(), SDHCDSetSlotInterface, &CardInterface, sizeof(CardInterface));
; 349  :             fContinue = SD_API_SUCCESS(inStatus) ;

  00130	53a05001	 movpl       r5, #1
  00134	43a05000	 movmi       r5, #0

; 350  :         }
; 351  :             
; 352  :         for (DWORD dwIndex = 0; dwIndex < SD_MAXIMUM_DEVICE_PER_SLOT && fContinue; dwIndex++) {

  00138	e3a06000	 mov         r6, #0
  0013c		 |$LL8@SetCardFea|
  0013c	e3550000	 cmp         r5, #0
  00140	0a00000e	 beq         |$LN6@SetCardFea|

; 353  :             CSDDevice * pDevice = m_sdSlot.GetFunctionDevice(dwIndex);

  00144	e5940438	 ldr         r0, [r4, #0x438]
  00148	e1a01006	 mov         r1, r6
  0014c	eb000000	 bl          |?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z|
  00150	e1b08000	 movs        r8, r0

; 354  :             if (pDevice != NULL) {

  00154	0a000006	 beq         |$LN7@SetCardFea|

; 355  :                 inStatus = pDevice->SetCardInterface(&CardInterfaceEx);

  00158	e1a0100b	 mov         r1, r11
  0015c	e1a00008	 mov         r0, r8
  00160	eb000000	 bl          |?SetCardInterface@CSDDevice@@QAAJPAU_SD_CARD_INTERFACE_EX@@@Z|
  00164	e1b09000	 movs        r9, r0

; 356  :                 if (!SD_API_SUCCESS(inStatus)) {
; 357  :                     fContinue = FALSE;
; 358  :                 }
; 359  :                 pDevice->DeRef();

  00168	e1a00008	 mov         r0, r8
  0016c	43a05000	 movmi       r5, #0
  00170	eb000000	 bl          |?DeRef@CRefObject@@QAAKXZ|
  00174		 |$LN7@SetCardFea|
  00174	e2866001	 add         r6, r6, #1
  00178	e3560008	 cmp         r6, #8
  0017c	3affffee	 bcc         |$LL8@SetCardFea|
  00180		 |$LN6@SetCardFea|

; 360  :             }
; 361  :         }
; 362  : 
; 363  :         if (!SD_API_SUCCESS(inStatus) &&!isRestore ) {

  00180	e3590000	 cmp         r9, #0
  00184	5a000008	 bpl         |$LN3@SetCardFea|
  00188	e35a0000	 cmp         r10, #0
  0018c	1a000006	 bne         |$LN3@SetCardFea|

; 364  :             ASSERT(FALSE);
; 365  :             status = inStatus;
; 366  :             CardInterfaceEx = CardInterfaceExBackup;

  00190	e28d1004	 add         r1, sp, #4
  00194	e3a02020	 mov         r2, #0x20
  00198	e1a0000b	 mov         r0, r11
  0019c	e58d9000	 str         r9, [sp]
  001a0	eb000000	 bl          memcpy

; 367  :             isRestore = TRUE;

  001a4	e3a0a001	 mov         r10, #1

; 368  :         }
; 369  :         else 
; 370  :             break;
; 371  :     }

  001a8	eaffffda	 b           |$LL11@SetCardFea|
  001ac		 |$LN3@SetCardFea|

; 372  :     if (pInterruptCallBack) {

  001ac	e3570000	 cmp         r7, #0

; 373  :         // Re-enable SDIO interrupts
; 374  :         DEBUGCHK(!m_sdSlot.IsSlotInterruptOn());
; 375  :         DEBUGCHK(Device_SD_IO == m_DeviceType);
; 376  :         SDIOConnectDisconnectInterrupt(pInterruptCallBack, TRUE);

  001b0	15943000	 ldrne       r3, [r4]
  001b4	13a02001	 movne       r2, #1
  001b8	11a01007	 movne       r1, r7
  001bc	15933028	 ldrne       r3, [r3, #0x28]
  001c0	11a00004	 movne       r0, r4
  001c4	11a0e00f	 movne       lr, pc
  001c8	112fff13	 bxne        r3
  001cc	e59d8000	 ldr         r8, [sp]
  001d0		 |$LN24@SetCardFea|

; 377  :     }
; 378  :     return status;
; 379  : 
; 380  : }

  001d0	e1a00008	 mov         r0, r8
  001d4	e28dd024	 add         sp, sp, #0x24
  001d8	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001dc	e12fff1e	 bx          lr
  001e0		 |$M36527|

			 ENDP  ; |?SetCardFeature_Interface@CSDDevice@@IAAJAAU_SD_CARD_INTERFACE_EX@@@Z|, CSDDevice::SetCardFeature_Interface

	EXPORT	|?SDSetCardFeature_I@CSDDevice@@QAAJW4SD_SET_FEATURE_TYPE@@PAXK@Z| ; CSDDevice::SDSetCardFeature_I
	IMPORT	|?SwitchFunction@CSDDevice@@IAAJPAU_SD_CARD_SWITCH_FUNCTION@@H@Z| ; CSDDevice::SwitchFunction
	IMPORT	|?NotifyClient@CSDDevice@@QAAXW4_SD_SLOT_EVENT_TYPE@@@Z| ; CSDDevice::NotifyClient
	IMPORT	|?PostEvent@CSDWorkItem@@QAAHW4_SD_SLOT_EVENT@@K@Z| ; CSDWorkItem::PostEvent
	IMPORT	|memset|
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdbus.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T36660| DCD	|$LN137@SDSetCardF|
	DCD	0x40011202
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\drivers\sdbus\sdiofeat.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDSetCardFeature_I@CSDDevice@@QAAJW4SD_SET_FEATURE_TYPE@@PAXK@Z| PROC ; CSDDevice::SDSetCardFeature_I

; 397  : {

  00000		 |$LN137@SDSetCardF|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd024	 sub         sp, sp, #0x24
  00008		 |$M36657|
  00008	e1a06002	 mov         r6, r2
  0000c	e1a05000	 mov         r5, r0

; 398  :     SD_API_STATUS               status = SD_API_STATUS_SUCCESS;  // intermediate status

  00010	e3a04000	 mov         r4, #0

; 399  :     PSD_DATA_TRANSFER_CLOCKS    pClocks;                         // data transfer clocks variable  
; 400  : 
; 401  :     switch (CardFeature) {

  00014	e3510015	 cmp         r1, #0x15
  00018	8a000105	 bhi         |$LN1@SDSetCardF|
  0001c	e1a0e081	 mov         lr, r1, lsl #1
  00020	e08ee00f	 add         lr, lr, pc
  00024	e1dee0b4	 ldrh        lr, [lr, #4]
  00028	e08ff00e	 add         pc, pc, lr
  0002c		 |$LN112@SDSetCardF|
  0002c		 |$LN111@SDSetCardF|
  0002c		 |$LN113@SDSetCardF|
  0002c	0028		 DCW         0x28
  0002e		 |$LN114@SDSetCardF|
  0002e	0050		 DCW         0x50
  00030		 |$LN115@SDSetCardF|
  00030	00d8		 DCW         0xd8
  00032		 |$LN116@SDSetCardF|
  00032	0108		 DCW         0x108
  00034		 |$LN117@SDSetCardF|
  00034	0170		 DCW         0x170
  00036		 |$LN118@SDSetCardF|
  00036	0204		 DCW         0x204
  00038		 |$LN119@SDSetCardF|
  00038	0130		 DCW         0x130
  0003a		 |$LN120@SDSetCardF|
  0003a	0158		 DCW         0x158
  0003c		 |$LN121@SDSetCardF|
  0003c	0164		 DCW         0x164
  0003e		 |$LN122@SDSetCardF|
  0003e	0264		 DCW         0x264
  00040		 |$LN123@SDSetCardF|
  00040	02d4		 DCW         0x2d4
  00042		 |$LN124@SDSetCardF|
  00042	0250		 DCW         0x250
  00044		 |$LN125@SDSetCardF|
  00044	0130		 DCW         0x130
  00046		 |$LN126@SDSetCardF|
  00046	0138		 DCW         0x138
  00048		 |$LN127@SDSetCardF|
  00048	014c		 DCW         0x14c
  0004a		 |$LN128@SDSetCardF|
  0004a	0074		 DCW         0x74
  0004c		 |$LN129@SDSetCardF|
  0004c	0094		 DCW         0x94
  0004e		 |$LN130@SDSetCardF|
  0004e	00a8		 DCW         0xa8
  00050		 |$LN131@SDSetCardF|
  00050	01ec		 DCW         0x1ec
  00052		 |$LN132@SDSetCardF|
  00052	0344		 DCW         0x344
  00054		 |$LN133@SDSetCardF|
  00054	036c		 DCW         0x36c
  00056		 |$LN134@SDSetCardF|
  00056	03b8		 DCW         0x3b8
  00058		 |$LN59@SDSetCardF|

; 402  : 
; 403  :       case SD_IO_FUNCTION_ENABLE:
; 404  :         if ((sizeof(SD_IO_FUNCTION_ENABLE_INFO) != StructureSize) || (NULL == pCardInfo)) {

  00058	e3530008	 cmp         r3, #8
  0005c	1a0000f4	 bne         |$LN1@SDSetCardF|
  00060	e3560000	 cmp         r6, #0
  00064	0a0000f2	 beq         |$LN1@SDSetCardF|

; 405  :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDSetCardFeature: SD_IO_FUNCTION_ENABLE - Invalid params \n")));
; 406  :             return SD_API_STATUS_INVALID_PARAMETER;
; 407  :         }
; 408  :         if (Device_SD_IO != m_DeviceType) {

  00068	e5953494	 ldr         r3, [r5, #0x494]
  0006c	e3530003	 cmp         r3, #3

; 409  :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDSetCardFeature: device is not SDIO ! \n")));
; 410  :             return SD_API_STATUS_INVALID_PARAMETER;

  00070	1a0000ef	 bne         |$LN1@SDSetCardF|

; 411  :         }        
; 412  :         status = SDEnableDisableFunction((PSD_IO_FUNCTION_ENABLE_INFO)pCardInfo, TRUE);

  00074	e3a02001	 mov         r2, #1
  00078	e1a01006	 mov         r1, r6
  0007c	ea000004	 b           |$LN107@SDSetCardF|
  00080		 |$LN55@SDSetCardF|

; 413  :         break;
; 414  :         
; 415  :       case SD_IO_FUNCTION_DISABLE:
; 416  :         if (Device_SD_IO != m_DeviceType) {

  00080	e5953494	 ldr         r3, [r5, #0x494]
  00084	e3530003	 cmp         r3, #3

; 417  :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDSetCardFeature: device is not SDIO ! \n")));
; 418  :             return SD_API_STATUS_INVALID_PARAMETER;

  00088	1a0000e9	 bne         |$LN1@SDSetCardF|

; 419  :         }
; 420  :         status = SDEnableDisableFunction(NULL, FALSE);

  0008c	e3a02000	 mov         r2, #0
  00090	e3a01000	 mov         r1, #0
  00094		 |$LN107@SDSetCardF|
  00094	e1a00005	 mov         r0, r5
  00098	eb000000	 bl          |?SDEnableDisableFunction@CSDDevice@@IAAJPAU_SD_IO_FUNCTION_ENABLE_INFO@@H@Z|
  0009c	e1a04000	 mov         r4, r0

; 421  :         break;

  000a0	ea0000e4	 b           |$LN60@SDSetCardF|
  000a4		 |$LN53@SDSetCardF|

; 422  :       case SD_IO_FUNCTION_HIGH_POWER:         
; 423  :         if (Device_SD_IO != m_DeviceType) {

  000a4	e5953494	 ldr         r3, [r5, #0x494]
  000a8	e3530003	 cmp         r3, #3

; 424  :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDSetCardFeature: device is not SDIO ! \n")));
; 425  :             return SD_API_STATUS_INVALID_PARAMETER;

  000ac	1a0000e0	 bne         |$LN1@SDSetCardF|

; 426  :         }
; 427  :         status = SDFunctionSelectPower(FALSE);

  000b0	e3a01000	 mov         r1, #0
  000b4		 |$LN108@SDSetCardF|
  000b4	e1a00005	 mov         r0, r5
  000b8	eb000000	 bl          |?SDFunctionSelectPower@CSDDevice@@IAAJH@Z|
  000bc	e1a04000	 mov         r4, r0
  000c0	ea0000dc	 b           |$LN60@SDSetCardF|
  000c4		 |$LN51@SDSetCardF|

; 428  :         break;
; 429  : 
; 430  :       case SD_IO_FUNCTION_LOW_POWER:
; 431  :         if (Device_SD_IO != m_DeviceType) {

  000c4	e5953494	 ldr         r3, [r5, #0x494]
  000c8	e3530003	 cmp         r3, #3

; 432  :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDSetCardFeature: device is not SDIO ! \n")));
; 433  :             return SD_API_STATUS_INVALID_PARAMETER;

  000cc	1a0000d8	 bne         |$LN1@SDSetCardF|

; 434  :         }
; 435  :         status = SDFunctionSelectPower(TRUE);

  000d0	e3a01001	 mov         r1, #1

; 436  :         break;

  000d4	eafffff6	 b           |$LN108@SDSetCardF|
  000d8		 |$LN49@SDSetCardF|

; 437  : 
; 438  :       case SD_INFO_POWER_CONTROL_STATE:
; 439  :         if ((sizeof(FUNCTION_POWER_STATE) != StructureSize) || (NULL == pCardInfo)) {

  000d8	e3530024	 cmp         r3, #0x24
  000dc	1a0000d4	 bne         |$LN1@SDSetCardF|
  000e0	e3560000	 cmp         r6, #0
  000e4	0a0000d2	 beq         |$LN1@SDSetCardF|

; 440  :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDSetCardFeature: SD_INFO_POWER_CONTROL_STATE - Invalid params \n")));
; 441  :             return SD_API_STATUS_INVALID_PARAMETER;
; 442  :         }
; 443  :         if (Device_SD_IO != m_DeviceType) {

  000e8	e5953494	 ldr         r3, [r5, #0x494]
  000ec	e3530003	 cmp         r3, #3

; 444  :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDSetCardFeature: device is not SDIO ! \n")));
; 445  :             return SD_API_STATUS_INVALID_PARAMETER;

  000f0	1a0000cf	 bne         |$LN1@SDSetCardF|

; 446  :         }
; 447  : 
; 448  :         status = GetFunctionPowerState((PFUNCTION_POWER_STATE)pCardInfo);

  000f4	e1a01006	 mov         r1, r6
  000f8	e1a00005	 mov         r0, r5
  000fc	eb000000	 bl          |?GetFunctionPowerState@CSDDevice@@QAAJPAU_FUNCTION_POWER_STATE@@@Z|
  00100	e1a04000	 mov         r4, r0
  00104	ea0000cb	 b           |$LN60@SDSetCardF|
  00108		 |$LN45@SDSetCardF|

; 449  :         break;
; 450  : 
; 451  :       case SD_IO_FUNCTION_SET_BLOCK_SIZE:
; 452  :         if ((sizeof(DWORD) != StructureSize) || (NULL == pCardInfo)) {

  00108	e3530004	 cmp         r3, #4
  0010c	1a0000c8	 bne         |$LN1@SDSetCardF|
  00110	e3560000	 cmp         r6, #0
  00114	0a0000c6	 beq         |$LN1@SDSetCardF|

; 453  :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDSetCardFeature: SD_IO_FUNCTION_SET_BLOCK_SIZE - Invalid params \n")));
; 454  :             return SD_API_STATUS_INVALID_PARAMETER;
; 455  :         }
; 456  :         if (Device_SD_IO != m_DeviceType) {

  00118	e5953494	 ldr         r3, [r5, #0x494]
  0011c	e3530003	 cmp         r3, #3

; 457  :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDSetCardFeature: device is not SDIO ! \n")));
; 458  :             return SD_API_STATUS_INVALID_PARAMETER;

  00120	1a0000c3	 bne         |$LN1@SDSetCardF|

; 459  :         }
; 460  :         status = SDSetFunctionBlockSize(*((DWORD *)pCardInfo));

  00124	e5961000	 ldr         r1, [r6]
  00128	e1a00005	 mov         r0, r5
  0012c	eb000000	 bl          |?SDSetFunctionBlockSize@CSDDevice@@IAAJK@Z|
  00130	e1a04000	 mov         r4, r0
  00134	ea0000bf	 b           |$LN60@SDSetCardF|
  00138		 |$LN41@SDSetCardF|

; 461  :         break;
; 462  : 
; 463  :       case SD_SET_DATA_TRANSFER_CLOCKS:
; 464  :         if ((sizeof(SD_DATA_TRANSFER_CLOCKS) != StructureSize) || (NULL == pCardInfo)) {

  00138	e3530008	 cmp         r3, #8
  0013c	1a0000bc	 bne         |$LN1@SDSetCardF|
  00140	e3560000	 cmp         r6, #0
  00144	0a0000ba	 beq         |$LN1@SDSetCardF|

; 465  :             DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDSetCardFeature: SD_SET_DATA_TRANSFER_CLOCKS - Invalid params \n")));
; 466  :             return SD_API_STATUS_INVALID_PARAMETER;
; 467  :         }
; 468  : 
; 469  :         pClocks = (PSD_DATA_TRANSFER_CLOCKS)pCardInfo;
; 470  :         m_SDCardInfo.SDMMCInformation.DataAccessReadClocks = pClocks->ReadClocks;

  00148	e5963000	 ldr         r3, [r6]

; 471  :         m_SDCardInfo.SDMMCInformation.DataAccessWriteClocks = pClocks->WriteClocks;
; 472  :         status = SD_API_STATUS_SUCCESS;

  0014c	e3a04000	 mov         r4, #0
  00150	e585352c	 str         r3, [r5, #0x52C]
  00154	e5963004	 ldr         r3, [r6, #4]
  00158	e5853528	 str         r3, [r5, #0x528]
  0015c	ea0000b5	 b           |$LN60@SDSetCardF|
  00160		 |$LN38@SDSetCardF|

; 473  :         break;
; 474  : 
; 475  :       case SD_IS_FAST_PATH_AVAILABLE:
; 476  :         status = SD_API_STATUS_SUCCESS;

  00160	e3a04000	 mov         r4, #0

; 477  :         break;

  00164	ea0000b3	 b           |$LN60@SDSetCardF|
  00168		 |$LN37@SDSetCardF|

; 478  : 
; 479  :       case SD_FAST_PATH_DISABLE:
; 480  :         //  Disable the use of Fast-Path for testing.
; 481  :         m_SDCardInfo.SDIOInformation.Flags |= FSTPTH_DISABLE;

  00168	e5d53511	 ldrb        r3, [r5, #0x511]

; 482  :         status = SD_API_STATUS_SUCCESS;

  0016c	e3833020	 orr         r3, r3, #0x20
  00170		 |$LN109@SDSetCardF|
  00170	e3a04000	 mov         r4, #0
  00174	e5c53511	 strb        r3, [r5, #0x511]

; 483  :         break;

  00178	ea0000ae	 b           |$LN60@SDSetCardF|
  0017c		 |$LN36@SDSetCardF|

; 484  : 
; 485  :       case SD_FAST_PATH_ENABLE:
; 486  :         //  Always use Fast-Path operations.
; 487  :         m_SDCardInfo.SDIOInformation.Flags &= ~ FSTPTH_DISABLE;

  0017c	e5d53511	 ldrb        r3, [r5, #0x511]

; 488  :         status = SD_API_STATUS_SUCCESS;

  00180	e20330df	 and         r3, r3, #0xDF

; 489  :         break;

  00184	eafffff9	 b           |$LN109@SDSetCardF|
  00188		 |$LN34@SDSetCardF|

; 490  : 
; 491  :       case SD_IS_SOFT_BLOCK_AVAILABLE:
; 492  :         status = SD_API_STATUS_SUCCESS;
; 493  :         break;
; 494  : 
; 495  :       case SD_SOFT_BLOCK_FORCE_UTILIZATION:
; 496  :         //  Always use Soft-Block operations.
; 497  :         m_SDCardInfo.SDIOInformation.Flags |= SFTBLK_USE_ALWAYS;

  00188	e5d53511	 ldrb        r3, [r5, #0x511]

; 498  :         status = SD_API_STATUS_SUCCESS;

  0018c	e3833010	 orr         r3, r3, #0x10

; 499  :         break;

  00190	eafffff6	 b           |$LN109@SDSetCardF|
  00194		 |$LN33@SDSetCardF|

; 500  : 
; 501  :       case SD_SOFT_BLOCK_DEFAULT_UTILIZATON:
; 502  :         //  Use hardware multi-block operations if supported by the card,
; 503  :         //  otherwise use Soft-Block.
; 504  :         m_SDCardInfo.SDIOInformation.Flags &= ~ SFTBLK_USE_ALWAYS;

  00194	e5d53511	 ldrb        r3, [r5, #0x511]

; 505  :         status = SD_API_STATUS_SUCCESS;

  00198	e20330ef	 and         r3, r3, #0xEF

; 506  :         break;

  0019c	eafffff3	 b           |$LN109@SDSetCardF|
  001a0		 |$LN32@SDSetCardF|

; 507  : 
; 508  :       case SD_SET_CARD_INTERFACE: {
; 509  :         if ((sizeof(SD_CARD_INTERFACE) != StructureSize) || (NULL == pCardInfo)) {

  001a0	e353000c	 cmp         r3, #0xC
  001a4	1a0000a2	 bne         |$LN1@SDSetCardF|
  001a8	e3560000	 cmp         r6, #0
  001ac	0a0000a0	 beq         |$LN1@SDSetCardF|

; 510  :                 DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDSetCardFeature: SD_SET_CARD_INTERFACE - Invalid params \n")));
; 511  :                 return SD_API_STATUS_INVALID_PARAMETER;
; 512  :         }
; 513  :         PSD_CARD_INTERFACE pCardInterface = (PSD_CARD_INTERFACE) pCardInfo ;
; 514  :         SD_CARD_INTERFACE_EX sdCardInterfaceEx;
; 515  :         memset (&sdCardInterfaceEx, 0, sizeof(sdCardInterfaceEx));

  001b0	e3a02020	 mov         r2, #0x20
  001b4	e3a01000	 mov         r1, #0
  001b8	e28d0004	 add         r0, sp, #4
  001bc	eb000000	 bl          memset

; 516  :         sdCardInterfaceEx.ClockRate = pCardInterface->ClockRate;
; 517  :         sdCardInterfaceEx.InterfaceModeEx.bit.sdWriteProtected = (pCardInterface->WriteProtected?1:0);

  001c0	e5962008	 ldr         r2, [r6, #8]
  001c4	e5963004	 ldr         r3, [r6, #4]
  001c8	e59d1004	 ldr         r1, [sp, #4]
  001cc	e3520000	 cmp         r2, #0
  001d0	e58d3008	 str         r3, [sp, #8]
  001d4	13a03001	 movne       r3, #1

; 518  :         sdCardInterfaceEx.InterfaceModeEx.bit.sd4Bit = (pCardInterface->InterfaceMode == SD_INTERFACE_SD_4BIT?1:0) ;

  001d8	e5962000	 ldr         r2, [r6]
  001dc	03a03000	 moveq       r3, #0
  001e0	e0213f03	 eor         r3, r1, r3, lsl #30
  001e4	e2033101	 and         r3, r3, #1, 2
  001e8	e3520001	 cmp         r2, #1
  001ec	e0231001	 eor         r1, r3, r1
  001f0	03a03001	 moveq       r3, #1
  001f4	13a03000	 movne       r3, #0
  001f8	e2033001	 and         r3, r3, #1
  001fc	e3c12001	 bic         r2, r1, #1
  00200	e1823003	 orr         r3, r2, r3
  00204	e58d3004	 str         r3, [sp, #4]

; 519  :         status =SetCardFeature_Interface(sdCardInterfaceEx);

  00208	e28d1004	 add         r1, sp, #4
  0020c		 |$LN102@SDSetCardF|
  0020c	e1a00005	 mov         r0, r5
  00210	eb000000	 bl          |?SetCardFeature_Interface@CSDDevice@@IAAJAAU_SD_CARD_INTERFACE_EX@@@Z|
  00214	e1a04000	 mov         r4, r0
  00218	ea000086	 b           |$LN60@SDSetCardF|
  0021c		 |$LN29@SDSetCardF|

; 520  :         break;
; 521  :       }
; 522  :      case SD_SET_CARD_INTERFACE_EX: {
; 523  :         if ((sizeof(SD_CARD_INTERFACE_EX) != StructureSize) || (NULL == pCardInfo)) {

  0021c	e3530020	 cmp         r3, #0x20
  00220	1a000083	 bne         |$LN1@SDSetCardF|
  00224	e3560000	 cmp         r6, #0
  00228	0a000081	 beq         |$LN1@SDSetCardF|

; 526  :         }
; 527  :         status = SetCardFeature_Interface(*(PSD_CARD_INTERFACE_EX)pCardInfo);

  0022c	e1a01006	 mov         r1, r6

; 524  :                 DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("SDSetCardFeature: SD_SET_CARD_INTERFACE_EX - Invalid params \n")));
; 525  :                 return SD_API_STATUS_INVALID_PARAMETER;

  00230	eafffff5	 b           |$LN102@SDSetCardF|
  00234		 |$LN26@SDSetCardF|

; 528  :         break;
; 529  :       }
; 530  : 
; 531  :       case SD_SET_CLOCK_STATE_DURING_IDLE:
; 532  :         if ( (sizeof(BOOL) != StructureSize) || (NULL == pCardInfo) ) {

  00234	e3530004	 cmp         r3, #4
  00238	1a00007d	 bne         |$LN1@SDSetCardF|
  0023c	e3560000	 cmp         r6, #0
  00240	0a00007b	 beq         |$LN1@SDSetCardF|

; 533  :             DEBUGMSG(SDCARD_ZONE_ERROR,(TEXT("SDSetCardFeature: SD_SET_CLOCK_ON_DURING_IDLE - Invalid params \n")));
; 534  :             return SD_API_STATUS_INVALID_PARAMETER;
; 535  :         }
; 536  : 
; 537  :         // prompt the host to turn on or off the clock during the idle state based on the client's
; 538  :         // request.
; 539  :         status = m_sdSlot.GetHost().SlotOptionHandler(m_sdSlot.GetSlotIndex(), SDHCDSetClockStateDuringIdle, pCardInfo,StructureSize);

  00244	e5953438	 ldr         r3, [r5, #0x438]
  00248	e3a05004	 mov         r5, #4
  0024c	e58d5000	 str         r5, [sp]
  00250	e593207c	 ldr         r2, [r3, #0x7C]
  00254	e5931080	 ldr         r1, [r3, #0x80]
  00258	e1a03006	 mov         r3, r6
  0025c	e3520000	 cmp         r2, #0
  00260	e5924044	 ldr         r4, [r2, #0x44]
  00264	12820008	 addne       r0, r2, #8
  00268	03a00000	 moveq       r0, #0
  0026c	e3a02007	 mov         r2, #7
  00270	e1a0e00f	 mov         lr, pc
  00274	e12fff14	 bx          r4
  00278	e1a04000	 mov         r4, r0
  0027c	ea00006d	 b           |$LN60@SDSetCardF|
  00280		 |$LN23@SDSetCardF|

; 540  : 
; 541  :         DEBUGMSG(SDCARD_ZONE_INFO, (TEXT("SDSetCardFeature: SDHCDSetClockStateDuringIdle finished with status: %x\n"),
; 542  :             status));
; 543  :         break;
; 544  :       case SD_CARD_FORCE_RESET:
; 545  :         DbgPrintZo(SDCARD_ZONE_INIT, (TEXT("SDSetCardFeature: call SD_CARD_FORCE_RESET \n")));
; 546  :         m_sdSlot.PostEvent(SlotResetRequest);

  00280	e3a01007	 mov         r1, #7
  00284		 |$LN110@SDSetCardF|
  00284	e5950438	 ldr         r0, [r5, #0x438]
  00288	e3e02000	 mvn         r2, #0
  0028c	eb000000	 bl          |?PostEvent@CSDWorkItem@@QAAHW4_SD_SLOT_EVENT@@K@Z|

; 547  :         break;

  00290	ea000068	 b           |$LN60@SDSetCardF|
  00294		 |$LN22@SDSetCardF|

; 548  : 
; 549  :       case SD_CARD_SELECT_REQUEST:
; 550  :         // request made by client driver to select the card. The request will not be honored
; 551  :         // until all client drivers in this slot make such request.
; 552  :         {
; 553  :             BOOL bAllFunctionsRequestedCardSelect  = TRUE;;
; 554  :             DbgPrintZo(SDCARD_ZONE_INIT,(TEXT("SDSetCardFeature: call SD_CARD_SELECT_REQUEST \n")));
; 555  :             m_bCardSelectRequest = TRUE;

  00294	e3a03001	 mov         r3, #1

; 556  :             NotifyClient(SDCardSelectRequest);

  00298	e3a01006	 mov         r1, #6
  0029c	e1a00005	 mov         r0, r5
  002a0	e5853560	 str         r3, [r5, #0x560]
  002a4	e3a07001	 mov         r7, #1
  002a8	eb000000	 bl          |?NotifyClient@CSDDevice@@QAAXW4_SD_SLOT_EVENT_TYPE@@@Z|

; 557  :             for (DWORD dwIndex = 0; dwIndex < SD_MAXIMUM_DEVICE_PER_SLOT; dwIndex++) {

  002ac	e3a06000	 mov         r6, #0
  002b0		 |$LL21@SDSetCardF|

; 558  :                 CSDDevice * pDevice = m_sdSlot.GetFunctionDevice(dwIndex);

  002b0	e5950438	 ldr         r0, [r5, #0x438]
  002b4	e1a01006	 mov         r1, r6
  002b8	eb000000	 bl          |?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z|
  002bc	e3500000	 cmp         r0, #0

; 559  :                 if (pDevice != NULL) {

  002c0	0a000006	 beq         |$LN20@SDSetCardF|

; 560  :                     if (pDevice->m_bCardSelectRequest == FALSE && pDevice->GetDeviceType()!= Device_Unknown ) {

  002c4	e5903560	 ldr         r3, [r0, #0x560]
  002c8	e3530000	 cmp         r3, #0
  002cc	1a000002	 bne         |$LN17@SDSetCardF|
  002d0	e5903494	 ldr         r3, [r0, #0x494]
  002d4	e3530000	 cmp         r3, #0

; 561  :                         bAllFunctionsRequestedCardSelect = FALSE;

  002d8	13a07000	 movne       r7, #0
  002dc		 |$LN17@SDSetCardF|

; 562  :                     }
; 563  :                     pDevice->DeRef();

  002dc	eb000000	 bl          |?DeRef@CRefObject@@QAAKXZ|
  002e0		 |$LN20@SDSetCardF|
  002e0	e2866001	 add         r6, r6, #1
  002e4	e3560008	 cmp         r6, #8
  002e8	3afffff0	 bcc         |$LL21@SDSetCardF|

; 564  :                 }
; 565  :             }
; 566  :             if (bAllFunctionsRequestedCardSelect == FALSE) {

  002ec	e3570000	 cmp         r7, #0
  002f0	1a000001	 bne         |$LN16@SDSetCardF|
  002f4		 |$LN106@SDSetCardF|

; 567  :                 DbgPrintZo(SDCARD_ZONE_INFO, (TEXT("SDSetCardFeature: SD_CARD_SELECT_REQUEST - request is pending\n")));
; 568  :                 return SD_API_STATUS_PENDING;

  002f4	e3a04001	 mov         r4, #1
  002f8	ea00004e	 b           |$LN60@SDSetCardF|
  002fc		 |$LN16@SDSetCardF|

; 569  :             }
; 570  :             DbgPrintZo(SDCARD_ZONE_INIT, (TEXT("SDSetCardFeature: SD_CARD_SELECT_REQUEST - request is processing\n")));
; 571  :             m_sdSlot.PostEvent(SlotSelectRequest);

  002fc	e3a01006	 mov         r1, #6

; 572  :         }
; 573  :         break;

  00300	eaffffdf	 b           |$LN110@SDSetCardF|
  00304		 |$LN15@SDSetCardF|

; 574  :       case SD_CARD_DESELECT_REQUEST:
; 575  :         {
; 576  :             BOOL bAllFunctionsRequestedCardDeselect= TRUE;;
; 577  :             DbgPrintZo(SDCARD_ZONE_INIT, (TEXT("SDSetCardFeature: call SD_CARD_DESELECT_REQUEST \n")));
; 578  :             if (!m_bCardDeselectRequest) {

  00304	e5953564	 ldr         r3, [r5, #0x564]
  00308	e3a07001	 mov         r7, #1
  0030c	e3530000	 cmp         r3, #0

; 579  :                 m_bCardDeselectRequest = TRUE;

  00310	03a03001	 moveq       r3, #1

; 580  :                 NotifyClient(SDCardDeselectRequest);

  00314	03a01005	 moveq       r1, #5
  00318	01a00005	 moveq       r0, r5
  0031c	05853564	 streq       r3, [r5, #0x564]
  00320	0b000000	 bleq        |?NotifyClient@CSDDevice@@QAAXW4_SD_SLOT_EVENT_TYPE@@@Z|

; 581  :             }
; 582  :             for (DWORD dwIndex = 0; dwIndex < SD_MAXIMUM_DEVICE_PER_SLOT; dwIndex++) {

  00324	e3a06000	 mov         r6, #0
  00328		 |$LL13@SDSetCardF|

; 583  :                 CSDDevice * pDevice = m_sdSlot.GetFunctionDevice(dwIndex);

  00328	e5950438	 ldr         r0, [r5, #0x438]
  0032c	e1a01006	 mov         r1, r6
  00330	eb000000	 bl          |?GetFunctionDevice@CSDSlot@@QAAPAVCSDDevice@@K@Z|
  00334	e3500000	 cmp         r0, #0

; 584  :                 if (pDevice != NULL) {

  00338	0a000006	 beq         |$LN12@SDSetCardF|

; 585  :                     if (pDevice->m_bCardDeselectRequest == FALSE && pDevice->GetDeviceType()!= Device_Unknown) {

  0033c	e5903564	 ldr         r3, [r0, #0x564]
  00340	e3530000	 cmp         r3, #0
  00344	1a000002	 bne         |$LN9@SDSetCardF|
  00348	e5903494	 ldr         r3, [r0, #0x494]
  0034c	e3530000	 cmp         r3, #0

; 586  :                         bAllFunctionsRequestedCardDeselect = FALSE ;

  00350	13a07000	 movne       r7, #0
  00354		 |$LN9@SDSetCardF|

; 587  :                     }
; 588  :                     pDevice->DeRef();

  00354	eb000000	 bl          |?DeRef@CRefObject@@QAAKXZ|
  00358		 |$LN12@SDSetCardF|
  00358	e2866001	 add         r6, r6, #1
  0035c	e3560008	 cmp         r6, #8
  00360	3afffff0	 bcc         |$LL13@SDSetCardF|

; 589  :                 }
; 590  :             }
; 591  :             if (bAllFunctionsRequestedCardDeselect == FALSE) {

  00364	e3570000	 cmp         r7, #0

; 592  :                 DbgPrintZo(SDCARD_ZONE_INFO, (TEXT("SDSetCardFeature: SD_CARD_DESELECT_REQUEST - request is pending\n")));
; 593  :                 return SD_API_STATUS_PENDING;

  00368	0affffe1	 beq         |$LN106@SDSetCardF|

; 594  :             }
; 595  :             DbgPrintZo(SDCARD_ZONE_INIT, (TEXT("SDSetCardFeature: SD_CARD_DESELECT_REQUEST - request is processing\n")));
; 596  :             m_sdSlot.PostEvent(SlotDeselectRequest);

  0036c	e3a01005	 mov         r1, #5

; 597  :         }
; 598  :         break;

  00370	eaffffc3	 b           |$LN110@SDSetCardF|
  00374		 |$LN7@SDSetCardF|

; 599  :       case SD_SET_SWITCH_FUNCTION: {
; 600  :         if (pCardInfo!=NULL && StructureSize >= sizeof(SD_CARD_SWITCH_FUNCTION)) {

  00374	e3560000	 cmp         r6, #0
  00378	0a00002e	 beq         |$LN60@SDSetCardF|
  0037c	e353004c	 cmp         r3, #0x4C
  00380	3a00002c	 bcc         |$LN60@SDSetCardF|

; 601  :             PSD_CARD_SWITCH_FUNCTION psdSwitchFunction = (PSD_CARD_SWITCH_FUNCTION)pCardInfo;
; 602  :             status = SwitchFunction((PSD_CARD_SWITCH_FUNCTION)pCardInfo,FALSE);

  00384	e3a02000	 mov         r2, #0
  00388	e1a01006	 mov         r1, r6
  0038c	e1a00005	 mov         r0, r5
  00390	eb000000	 bl          |?SwitchFunction@CSDDevice@@IAAJPAU_SD_CARD_SWITCH_FUNCTION@@H@Z|
  00394	e1a04000	 mov         r4, r0
  00398	ea000026	 b           |$LN60@SDSetCardF|
  0039c		 |$LN5@SDSetCardF|

; 603  :         }
; 604  :       }
; 605  :       break;
; 606  :       case SD_DMA_ALLOC_PHYS_MEM:
; 607  :         if (pCardInfo!=NULL && StructureSize >= sizeof(SD_HOST_ALLOC_FREE_DMA_BUFFER)) {

  0039c	e3560000	 cmp         r6, #0
  003a0	0a000024	 beq         |$LN60@SDSetCardF|
  003a4	e3530018	 cmp         r3, #0x18
  003a8	3a000022	 bcc         |$LN60@SDSetCardF|

; 608  :             status = m_sdSlot.GetHost().SlotOptionHandler(m_sdSlot.GetSlotIndex(),SDHCAllocateDMABuffer, pCardInfo,sizeof(SD_HOST_ALLOC_FREE_DMA_BUFFER));                

  003ac	e5953438	 ldr         r3, [r5, #0x438]
  003b0	e3a05018	 mov         r5, #0x18
  003b4	e58d5000	 str         r5, [sp]
  003b8	e593207c	 ldr         r2, [r3, #0x7C]
  003bc	e5931080	 ldr         r1, [r3, #0x80]
  003c0	e1a03006	 mov         r3, r6
  003c4	e3520000	 cmp         r2, #0
  003c8	e5924044	 ldr         r4, [r2, #0x44]
  003cc	12820008	 addne       r0, r2, #8
  003d0	03a00000	 moveq       r0, #0
  003d4	e3a0200d	 mov         r2, #0xD
  003d8	e1a0e00f	 mov         lr, pc
  003dc	e12fff14	 bx          r4
  003e0	e1a04000	 mov         r4, r0
  003e4	ea000013	 b           |$LN60@SDSetCardF|
  003e8		 |$LN3@SDSetCardF|

; 609  :         }
; 610  :         break;
; 611  :       case SD_DMA_FREE_PHYS_MEM:
; 612  :         if (pCardInfo!=NULL && StructureSize >= sizeof(SD_HOST_ALLOC_FREE_DMA_BUFFER)) {

  003e8	e3560000	 cmp         r6, #0
  003ec	0a000011	 beq         |$LN60@SDSetCardF|
  003f0	e3530018	 cmp         r3, #0x18
  003f4	3a00000f	 bcc         |$LN60@SDSetCardF|

; 613  :             status = m_sdSlot.GetHost().SlotOptionHandler(m_sdSlot.GetSlotIndex(),SDHCFreeDMABuffer, pCardInfo,sizeof(SD_HOST_ALLOC_FREE_DMA_BUFFER));                

  003f8	e5953438	 ldr         r3, [r5, #0x438]
  003fc	e3a05018	 mov         r5, #0x18
  00400	e58d5000	 str         r5, [sp]
  00404	e593207c	 ldr         r2, [r3, #0x7C]
  00408	e5931080	 ldr         r1, [r3, #0x80]
  0040c	e1a03006	 mov         r3, r6
  00410	e3520000	 cmp         r2, #0
  00414	e5924044	 ldr         r4, [r2, #0x44]
  00418	12820008	 addne       r0, r2, #8
  0041c	03a00000	 moveq       r0, #0
  00420	e3a0200e	 mov         r2, #0xE
  00424	e1a0e00f	 mov         lr, pc
  00428	e12fff14	 bx          r4
  0042c	e1a04000	 mov         r4, r0
  00430	ea000000	 b           |$LN60@SDSetCardF|
  00434		 |$LN1@SDSetCardF|

; 614  :         }
; 615  :         break;
; 616  :     default:
; 617  :         status = SD_API_STATUS_INVALID_PARAMETER;

  00434	e3a0411f	 mov         r4, #0x1F, 2
  00438		 |$LN60@SDSetCardF|

; 618  :         break;
; 619  :     }
; 620  : 
; 621  :     return status;
; 622  : }

  00438	e1a00004	 mov         r0, r4
  0043c	e28dd024	 add         sp, sp, #0x24
  00440	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00444	e12fff1e	 bx          lr
  00448		 |$M36658|

			 ENDP  ; |?SDSetCardFeature_I@CSDDevice@@QAAJW4SD_SET_FEATURE_TYPE@@PAXK@Z|, CSDDevice::SDSetCardFeature_I

	END
