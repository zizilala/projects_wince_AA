; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\Z2170\SRC\DRIVERS\sysctrl\flash.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1BE@BKKMLFKH@?$AA8?$AA0?$AA6?$AA?5?$AAH?$AAS?$AAM?$AAH?$AAZ?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@HLPDAKHN@?$AA8?$AA0?$AA6?$AA?5?$AAM?$AAH?$AAZ?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@FGCEKGOE@?$AA6?$AA2?$AA4?$AA?5?$AAM?$AAH?$AAZ?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@EBNODIMD@?$AA4?$AA1?$AA6?$AA?5?$AAM?$AAH?$AAZ?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@GGHBGDEP@?$AA2?$AA0?$AA8?$AA?5?$AAM?$AAH?$AAZ?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BC@EKPDPFCF@?$AAR?$AAi?$AAn?$AAg?$AA?5?$AAO?$AAS?$AAC?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.data|, DATA
	 COMMON	|g_FlashInfo|, 0x10


  00000			 AREA	 |.bss|, NOINIT
|g_BlockArrayType| % 0x4
|g_FlashDeviceType| % 0x4

  00000			 AREA	 |.data|, DATA
|g_szOPDescription| DCD |??_C@_1BC@EKPDPFCF@?$AAR?$AAi?$AAn?$AAg?$AA?5?$AAO?$AAS?$AAC?$AA?$AA@|
	DCD	|??_C@_1BA@GGHBGDEP@?$AA2?$AA0?$AA8?$AA?5?$AAM?$AAH?$AAZ?$AA?$AA@|
	DCD	|??_C@_1BA@EBNODIMD@?$AA4?$AA1?$AA6?$AA?5?$AAM?$AAH?$AAZ?$AA?$AA@|
	DCD	|??_C@_1BA@FGCEKGOE@?$AA6?$AA2?$AA4?$AA?5?$AAM?$AAH?$AAZ?$AA?$AA@|
	DCD	|??_C@_1BA@HLPDAKHN@?$AA8?$AA0?$AA6?$AA?5?$AAM?$AAH?$AAZ?$AA?$AA@|
	DCD	|??_C@_1BE@BKKMLFKH@?$AA8?$AA0?$AA6?$AA?5?$AAH?$AAS?$AAM?$AAH?$AAZ?$AA?$AA@|
|FLASH_SIZE| DCD 0x2000000
|ERASE_BLOCKS| DCD 0x80
|L3_BLOCK_SIZE| DCD 0x10000

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@BKKMLFKH@?$AA8?$AA0?$AA6?$AA?5?$AAH?$AAS?$AAM?$AAH?$AAZ?$AA?$AA@| DCB "8"
	DCB	0x0, "0", 0x0, "6", 0x0, " ", 0x0, "H", 0x0, "S", 0x0, "M"
	DCB	0x0, "H", 0x0, "Z", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@HLPDAKHN@?$AA8?$AA0?$AA6?$AA?5?$AAM?$AAH?$AAZ?$AA?$AA@| DCB "8"
	DCB	0x0, "0", 0x0, "6", 0x0, " ", 0x0, "M", 0x0, "H", 0x0, "Z"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@FGCEKGOE@?$AA6?$AA2?$AA4?$AA?5?$AAM?$AAH?$AAZ?$AA?$AA@| DCB "6"
	DCB	0x0, "2", 0x0, "4", 0x0, " ", 0x0, "M", 0x0, "H", 0x0, "Z"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@EBNODIMD@?$AA4?$AA1?$AA6?$AA?5?$AAM?$AAH?$AAZ?$AA?$AA@| DCB "4"
	DCB	0x0, "1", 0x0, "6", 0x0, " ", 0x0, "M", 0x0, "H", 0x0, "Z"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@GGHBGDEP@?$AA2?$AA0?$AA8?$AA?5?$AAM?$AAH?$AAZ?$AA?$AA@| DCB "2"
	DCB	0x0, "0", 0x0, "8", 0x0, " ", 0x0, "M", 0x0, "H", 0x0, "Z"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BC@EKPDPFCF@?$AAR?$AAi?$AAn?$AAg?$AA?5?$AAO?$AAS?$AAC?$AA?$AA@| DCB "R"
	DCB	0x0, "i", 0x0, "n", 0x0, "g", 0x0, " ", 0x0, "O", 0x0, "S"
	DCB	0x0, "C", 0x0, 0x0, 0x0			; `string'
	EXPORT	|InitializeCriticalSection|
; File c:\wince600\platform\z2170\src\drivers\sysctrl\flash.c

  00000			 AREA	 |.pdata|, PDATA
|$T41678| DCD	|$LN5@Initialize|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |InitializeCriticalSection| PROC

; 97   : VOID WINAPI InitializeCriticalSection(LPCRITICAL_SECTION lpcs){}

  00000		 |$LN5@Initialize|
  00000		 |$M41675|
  00000	e12fff1e	 bx          lr
  00004		 |$M41676|

			 ENDP  ; |InitializeCriticalSection|

	EXPORT	|EnterCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T41685| DCD	|$LN5@EnterCriti|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |EnterCriticalSection| PROC

; 98   : VOID WINAPI EnterCriticalSection(LPCRITICAL_SECTION lpcs){}

  00000		 |$LN5@EnterCriti|
  00000		 |$M41682|
  00000	e12fff1e	 bx          lr
  00004		 |$M41683|

			 ENDP  ; |EnterCriticalSection|

	EXPORT	|LeaveCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T41692| DCD	|$LN5@LeaveCriti|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |LeaveCriticalSection| PROC

; 99   : VOID WINAPI LeaveCriticalSection(LPCRITICAL_SECTION lpcs){}

  00000		 |$LN5@LeaveCriti|
  00000		 |$M41689|
  00000	e12fff1e	 bx          lr
  00004		 |$M41690|

			 ENDP  ; |LeaveCriticalSection|

	EXPORT	|DeleteCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T41699| DCD	|$LN5@DeleteCrit|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DeleteCriticalSection| PROC

; 100  : VOID WINAPI DeleteCriticalSection(LPCRITICAL_SECTION lpcs){}

  00000		 |$LN5@DeleteCrit|
  00000		 |$M41696|
  00000	e12fff1e	 bx          lr
  00004		 |$M41697|

			 ENDP  ; |DeleteCriticalSection|

	EXPORT	|PXA_DMA_ArmTransfer|

  00000			 AREA	 |.pdata|, PDATA
|$T41708| DCD	|$LN5@PXA_DMA_Ar|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PXA_DMA_ArmTransfer| PROC

; 102  : BOOL PXA_DMA_ArmTransfer(PXA_DMA_ChannelHandle channel,PXA_DMA_TransferHandle transfer){return TRUE;}

  00000		 |$LN5@PXA_DMA_Ar|
  00000		 |$M41705|
  00000	e3a00001	 mov         r0, #1
  00004	e12fff1e	 bx          lr
  00008		 |$M41706|

			 ENDP  ; |PXA_DMA_ArmTransfer|

	EXPORT	|PXA_DMA_UpdateTransferLength|

  00000			 AREA	 |.pdata|, PDATA
|$T41715| DCD	|$LN5@PXA_DMA_Up|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PXA_DMA_UpdateTransferLength| PROC

; 103  : VOID PXA_DMA_UpdateTransferLength(PXA_DMA_TransferHandle transfer,UINT32 pos,UINT32 length){}

  00000		 |$LN5@PXA_DMA_Up|
  00000		 |$M41712|
  00000	e12fff1e	 bx          lr
  00004		 |$M41713|

			 ENDP  ; |PXA_DMA_UpdateTransferLength|

	EXPORT	|PXA_DMA_TerminateTransfer|

  00000			 AREA	 |.pdata|, PDATA
|$T41724| DCD	|$LN5@PXA_DMA_Te|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PXA_DMA_TerminateTransfer| PROC

; 104  : BOOL PXA_DMA_TerminateTransfer(PXA_DMA_ChannelHandle channel, PXA_DMA_TransferStatus * p_status){return TRUE;}

  00000		 |$LN5@PXA_DMA_Te|
  00000		 |$M41721|
  00000	e3a00001	 mov         r0, #1
  00004	e12fff1e	 bx          lr
  00008		 |$M41722|

			 ENDP  ; |PXA_DMA_TerminateTransfer|

	EXPORT	|PXA_DMA_StartTransfer|

  00000			 AREA	 |.pdata|, PDATA
|$T41733| DCD	|$LN5@PXA_DMA_St|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PXA_DMA_StartTransfer| PROC

; 105  : BOOL PXA_DMA_StartTransfer(PXA_DMA_ChannelHandle channel){return TRUE;}

  00000		 |$LN5@PXA_DMA_St|
  00000		 |$M41730|
  00000	e3a00001	 mov         r0, #1
  00004	e12fff1e	 bx          lr
  00008		 |$M41731|

			 ENDP  ; |PXA_DMA_StartTransfer|

	EXPORT	|PXA_DMA_PollingForTransferDone|

  00000			 AREA	 |.pdata|, PDATA
|$T41742| DCD	|$LN5@PXA_DMA_Po|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PXA_DMA_PollingForTransferDone| PROC

; 106  : BOOL PXA_DMA_PollingForTransferDone(PXA_DMA_ChannelHandle channel){return TRUE;}

  00000		 |$LN5@PXA_DMA_Po|
  00000		 |$M41739|
  00000	e3a00001	 mov         r0, #1
  00004	e12fff1e	 bx          lr
  00008		 |$M41740|

			 ENDP  ; |PXA_DMA_PollingForTransferDone|

	EXPORT	|FlashInit|
	EXPORT	|??_C@_1CE@MHJNFEAG@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AA?2?$AAX?$AAX?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|FMD_GetInfo|
	IMPORT	|FMD_Init|

  00000			 AREA	 |.pdata|, PDATA
|$T41751| DCD	|$LN5@FlashInit|
	DCD	0x40000b01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CE@MHJNFEAG@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AA?2?$AAX?$AAX?$AA?$AA@| DCB "D"
	DCB	0x0, "r", 0x0, "i", 0x0, "v", 0x0, "e", 0x0, "r", 0x0, "s"
	DCB	0x0, "\\", 0x0, "A", 0x0, "c", 0x0, "t", 0x0, "i", 0x0, "v"
	DCB	0x0, "e", 0x0, "\\", 0x0, "X", 0x0, "X", 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FlashInit| PROC

; 110  : {

  00000		 |$LN5@FlashInit|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41748|

; 111  :     PVOID hFMD = NULL;
; 112  :     hFMD = FMD_Init(FMD_CALLER_DLL, NULL, NULL);    

  00004	e59f001c	 ldr         r0, [pc, #0x1C]
  00008	e3a02000	 mov         r2, #0
  0000c	e3a01000	 mov         r1, #0
  00010	eb000000	 bl          FMD_Init

; 113  : 
; 114  :     return FMD_GetInfo(&g_FlashInfo);

  00014	e59f0008	 ldr         r0, [pc, #8]
  00018	eb000000	 bl          FMD_GetInfo

; 115  : }

  0001c	e49de004	 ldr         lr, [sp], #4
  00020	e12fff1e	 bx          lr
  00024		 |$LN6@FlashInit|
  00024		 |$LN7@FlashInit|
  00024	00000000	 DCD         |g_FlashInfo|
  00028		 |$LN8@FlashInit|
  00028	00000000	 DCD         |??_C@_1CE@MHJNFEAG@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AA?2?$AAX?$AAX?$AA?$AA@|
  0002c		 |$M41749|

			 ENDP  ; |FlashInit|

	EXPORT	|FlashReadSector|
	IMPORT	|FMD_ReadSector|

  00000			 AREA	 |.pdata|, PDATA
|$T41769| DCD	|$LN10@FlashReadS|
	DCD	0x40001001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FlashReadSector| PROC

; 118  : {

  00000		 |$LN10@FlashReadS|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M41766|
  00004	e1a05002	 mov         r5, r2
  00008	e1a06001	 mov         r6, r1
  0000c	e1a07000	 mov         r7, r0

; 119  :     BOOL rc;
; 120  :     UINT32 retry = NAND_ATTEMPT_NUMBER;

  00010	e3a04003	 mov         r4, #3
  00014		 |$LL4@FlashReadS|

; 121  :     do {
; 122  :         rc=FMD_ReadSector(sector, pTmp, pSectorInfo, 1);

  00014	e3a03001	 mov         r3, #1
  00018	e1a02005	 mov         r2, r5
  0001c	e1a01006	 mov         r1, r6
  00020	e1a00007	 mov         r0, r7
  00024	eb000000	 bl          FMD_ReadSector
  00028	e3500000	 cmp         r0, #0

; 123  :     }while (!rc && --retry > 0);

  0002c	1a000001	 bne         |$LN1@FlashReadS|
  00030	e2544001	 subs        r4, r4, #1
  00034	1afffff6	 bne         |$LL4@FlashReadS|
  00038		 |$LN1@FlashReadS|

; 124  :     return rc;
; 125  : }

  00038	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$M41767|

			 ENDP  ; |FlashReadSector|

	EXPORT	|FlashWriteSector|
	IMPORT	|FMD_WriteSector|

  00000			 AREA	 |.pdata|, PDATA
|$T41784| DCD	|$LN10@FlashWrite|
	DCD	0x40001001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FlashWriteSector| PROC

; 128  : {

  00000		 |$LN10@FlashWrite|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M41781|
  00004	e1a05002	 mov         r5, r2
  00008	e1a06001	 mov         r6, r1
  0000c	e1a07000	 mov         r7, r0

; 129  :     BOOL rc;
; 130  :     UINT32 retry = NAND_ATTEMPT_NUMBER;

  00010	e3a04003	 mov         r4, #3
  00014		 |$LL4@FlashWrite|

; 131  :     do {
; 132  :         rc = FMD_WriteSector(sector, pBuffer, pInfo, 1);

  00014	e3a03001	 mov         r3, #1
  00018	e1a02005	 mov         r2, r5
  0001c	e1a01006	 mov         r1, r6
  00020	e1a00007	 mov         r0, r7
  00024	eb000000	 bl          FMD_WriteSector
  00028	e3500000	 cmp         r0, #0

; 133  :     } while (!rc && --retry > 0);

  0002c	1a000001	 bne         |$LN1@FlashWrite|
  00030	e2544001	 subs        r4, r4, #1
  00034	1afffff6	 bne         |$LL4@FlashWrite|
  00038		 |$LN1@FlashWrite|

; 134  :     return rc;
; 135  : }

  00038	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$M41782|

			 ENDP  ; |FlashWriteSector|

	EXPORT	|FlashEraseBlock|
	IMPORT	|FMD_EraseBlock|

  00000			 AREA	 |.pdata|, PDATA
|$T41797| DCD	|$LN10@FlashErase|
	DCD	0x40000b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FlashEraseBlock| PROC

; 138  : {

  00000		 |$LN10@FlashErase|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M41794|
  00004	e1a05000	 mov         r5, r0

; 139  :     BOOL rc;
; 140  :     UINT32 retry = NAND_ATTEMPT_NUMBER;

  00008	e3a04003	 mov         r4, #3
  0000c		 |$LL4@FlashErase|

; 141  :     do {
; 142  :         rc = FMD_EraseBlock(block);

  0000c	e1a00005	 mov         r0, r5
  00010	eb000000	 bl          FMD_EraseBlock
  00014	e3500000	 cmp         r0, #0

; 143  :     } while (!rc && --retry > 0);

  00018	1a000001	 bne         |$LN1@FlashErase|
  0001c	e2544001	 subs        r4, r4, #1
  00020	1afffff9	 bne         |$LL4@FlashErase|
  00024		 |$LN1@FlashErase|

; 144  :     return rc;
; 145  : }

  00024	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$M41795|

			 ENDP  ; |FlashEraseBlock|

	EXPORT	|FlashReadNANDFlash|

  00008			 AREA	 |.bss|, NOINIT
|tempBuffer| %	0x800
|tempBuffer| %	0x800

  00000			 AREA	 |.pdata|, PDATA
|$T41817| DCD	|$LN17@FlashReadN|
	DCD	0x40002402
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FlashReadNANDFlash| PROC

; 153  : {

  00000		 |$LN17@FlashReadN|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M41814|
  00008	e1a08001	 mov         r8, r1
  0000c	e1a04000	 mov         r4, r0

; 154  :     BOOL rc = FALSE;
; 155  :     FlashInfo flashInfo;    
; 156  :     BLOCK_ID block;
; 157  :     UINT32  sectorsPerBlock;
; 158  :     SECTOR_ADDR sector;
; 159  :     SectorInfo sectorInfo;
; 160  : 
; 161  :     //KITLOutputDebugString("+FlashReadNANDFlash\r\n");
; 162  : 
; 163  :     if (!FMD_GetInfo(&flashInfo))

  00010	e28d0008	 add         r0, sp, #8
  00014	eb000000	 bl          FMD_GetInfo
  00018	e3500000	 cmp         r0, #0
  0001c	1a000001	 bne         |$LN6@FlashReadN|
  00020		 |$LN11@FlashReadN|

; 164  :     {
; 165  :         //KITLOutputDebugString("ERROR: FlashReadNANDFlash: FMD_GetInfo call failed!\r\n");
; 166  :         return rc;

  00020	e3a00000	 mov         r0, #0
  00024	ea000015	 b           |$LN7@FlashReadN|
  00028		 |$LN6@FlashReadN|

; 167  :     }
; 168  : 
; 169  :     sectorsPerBlock = flashInfo.wSectorsPerBlock;

  00028	e1dd61b4	 ldrh        r6, [sp, #0x14]

; 170  :     block = startBlock;
; 171  :     
; 172  :     while (block <= endBlock)

  0002c	e1540008	 cmp         r4, r8
  00030	8a000011	 bhi         |$LN14@FlashReadN|
  00034	e0050496	 mul         r5, r6, r4
  00038		 |$LL5@FlashReadN|

; 173  :     {
; 174  :         //no need to read the relocation table, FMD_ReadSector will do the mapping operation
; 175  :         sector = block * sectorsPerBlock;
; 176  :         while(sector<(block+1) * sectorsPerBlock)

  00038	e0859006	 add         r9, r5, r6
  0003c	e1550009	 cmp         r5, r9
  00040	e1a07005	 mov         r7, r5
  00044	2a000008	 bcs         |$LN2@FlashReadN|
  00048		 |$LL3@FlashReadN|

; 177  :         {
; 178  :         if (!FlashReadSector(sector, tempBuffer, &sectorInfo))

  00048	e59f103c	 ldr         r1, [pc, #0x3C]
  0004c	e28d2000	 add         r2, sp, #0
  00050	e1a00007	 mov         r0, r7
  00054	eb000000	 bl          FlashReadSector
  00058	e3500000	 cmp         r0, #0
  0005c	0affffef	 beq         |$LN11@FlashReadN|

; 179  :         {
; 180  :             //KITLOutputDebugString("ERROR: FlashRead: Failed read sector %d from flash\r\n", sector);
; 181  :             return rc;
; 182  :         }
; 183  :             sector++;

  00060	e2877001	 add         r7, r7, #1
  00064	e1570009	 cmp         r7, r9
  00068	3afffff6	 bcc         |$LL3@FlashReadN|
  0006c		 |$LN2@FlashReadN|

; 184  :         }
; 185  :             //KITLOutputDebugString(".", block);
; 186  :         block++;

  0006c	e2844001	 add         r4, r4, #1
  00070	e1540008	 cmp         r4, r8
  00074	e0855006	 add         r5, r5, r6
  00078	9affffee	 bls         |$LL5@FlashReadN|
  0007c		 |$LN14@FlashReadN|

; 187  :     }
; 188  : 
; 189  :     //KITLOutputDebugString("-FlashReadNANDFlash successfully\r\n");
; 190  :     return TRUE;

  0007c	e3a00001	 mov         r0, #1
  00080		 |$LN7@FlashReadN|

; 191  : }

  00080	e28dd018	 add         sp, sp, #0x18
  00084	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$LN18@FlashReadN|
  0008c		 |$LN19@FlashReadN|
  0008c	00000000	 DCD         |tempBuffer|
  00090		 |$M41815|

			 ENDP  ; |FlashReadNANDFlash|

	EXPORT	|FlashFormatNANDFlash|

  00000			 AREA	 |.pdata|, PDATA
|$T41853| DCD	|$LN28@FlashForma|
	DCD	0x40001902
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FlashFormatNANDFlash| PROC

; 200  : {

  00000		 |$LN28@FlashForma|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M41850|
  00008	e1a06001	 mov         r6, r1
  0000c	e1a04000	 mov         r4, r0

; 201  :     BOOL rc = FALSE;
; 202  :     FlashInfo flashInfo;        
; 203  :     BLOCK_ID block = startBlock;
; 204  : 
; 205  :     //KITLOutputDebugString("+FlashFormatNANDFlash: startBlock = %d, endBlock = %d\r\n", startBlock, endBlock);
; 206  : 
; 207  :     if (!FMD_GetInfo(&flashInfo)) 

  00010	e28d0000	 add         r0, sp, #0
  00014	eb000000	 bl          FMD_GetInfo
  00018	e3500000	 cmp         r0, #0

; 208  :     {
; 209  :         //KITLOutputDebugString("ERROR: FlashFormatNANDFlash: FMD_GetInfo call failed!\r\n");
; 210  :         return rc;

  0001c	03a00000	 moveq       r0, #0
  00020	0a00000c	 beq         |$LN6@FlashForma|
  00024		 |$LL4@FlashForma|

; 211  :     }
; 212  : 
; 213  :     do {
; 214  :         //KITLOutputDebugString(".");
; 215  :         if (!FlashEraseBlock(block))

  00024	e3a05003	 mov         r5, #3
  00028		 |$LL11@FlashForma|
  00028	e1a00004	 mov         r0, r4
  0002c	eb000000	 bl          FMD_EraseBlock
  00030	e3500000	 cmp         r0, #0
  00034	1a000003	 bne         |$LN18@FlashForma|
  00038	e2555001	 subs        r5, r5, #1
  0003c	1afffff9	 bne         |$LL11@FlashForma|

; 208  :     {
; 209  :         //KITLOutputDebugString("ERROR: FlashFormatNANDFlash: FMD_GetInfo call failed!\r\n");
; 210  :         return rc;

  00040	e3a00000	 mov         r0, #0
  00044	ea000003	 b           |$LN6@FlashForma|
  00048		 |$LN18@FlashForma|

; 216  :         {
; 217  :             //KITLOutputDebugString("ERROR: FlashFormatNANDFlash: Erase block %d failed!\r\n", block);
; 218  :             return rc;
; 219  :         }
; 220  :     } while (++block <= endBlock);

  00048	e2844001	 add         r4, r4, #1
  0004c	e1540006	 cmp         r4, r6
  00050	9afffff3	 bls         |$LL4@FlashForma|

; 221  : 
; 222  :     //KITLOutputDebugString("\r\n-FlashFormatNANDFlash: startBlock = %d, endBlock = %d block = %d\r\n", startBlock, endBlock, block);
; 223  : 
; 224  :     return TRUE;

  00054	e3a00001	 mov         r0, #1
  00058		 |$LN6@FlashForma|

; 225  : }

  00058	e28dd010	 add         sp, sp, #0x10
  0005c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$M41851|

			 ENDP  ; |FlashFormatNANDFlash|


  00000			 AREA	 |.pdata|, PDATA
|$T41872| DCD	|$LN14@ReadBlock|
	DCD	0x40001b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ReadBlock| PROC

; 234  : {

  00000		 |$LN14@ReadBlock|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M41869|
  00008	e1b07001	 movs        r7, r1

; 235  :     BOOL rc = FALSE;
; 236  :     UINT32 count;
; 237  :     UINT32 sectorSize, sectorsPerBlock;
; 238  :     SectorInfo sectorInfo;
; 239  :     SECTOR_ADDR sector;
; 240  : 
; 241  :     // Get flash info
; 242  :     sectorSize = pFlashInfo->wDataBytesPerSector;

  0000c	e1d280be	 ldrh        r8, [r2, #0xE]

; 243  :     sectorsPerBlock = pFlashInfo->wSectorsPerBlock;

  00010	e1d250bc	 ldrh        r5, [r2, #0xC]

; 244  : 
; 245  :     // Read data from block
; 246  :     if (pDataBuffer != NULL)

  00014	0a000010	 beq         |$LN6@ReadBlock|

; 247  :     {
; 248  :        // RETAILMSG(1, (TEXT("\n\r+++ReadBlock\r\n")));
; 249  :         sector = block * sectorsPerBlock;

  00018	e0060095	 mul         r6, r5, r0

; 250  :         for(count = 0; count < sectorsPerBlock; count++)

  0001c	e3a04000	 mov         r4, #0
  00020	e3550000	 cmp         r5, #0
  00024	0a00000a	 beq         |$LN3@ReadBlock|
  00028		 |$LL5@ReadBlock|

; 251  :         {
; 252  :             ////KITLOutputDebugString("FMD_ReadSector: sector=%d\r\n", sector);
; 253  :             if (!FlashReadSector(sector, pDataBuffer, &sectorInfo))

  00028	e28d2000	 add         r2, sp, #0
  0002c	e1a01007	 mov         r1, r7
  00030	e1a00006	 mov         r0, r6
  00034	eb000000	 bl          FlashReadSector
  00038	e3500000	 cmp         r0, #0
  0003c	0a000006	 beq         |$LN6@ReadBlock|
  00040	e2844001	 add         r4, r4, #1
  00044	e1540005	 cmp         r4, r5

; 254  :             {
; 255  :                 // When block read fail, there isn't much we can do more
; 256  :                 //KITLOutputDebugString("ERROR: ReadBlock: Failed read sector %d from flash\r\n",  sector);
; 257  :              //   RETAILMSG(1, (TEXT("\n\rReadBlock: Failed read sector %d from flash\r\n")sector));
; 258  :                 return rc;
; 259  :             }
; 260  :             // Move to next sector
; 261  :             sector++;

  00048	e2866001	 add         r6, r6, #1

; 262  :             pDataBuffer += sectorSize;

  0004c	e0877008	 add         r7, r7, r8
  00050	3afffff4	 bcc         |$LL5@ReadBlock|
  00054		 |$LN3@ReadBlock|

; 267  :     
; 268  :   //  RETAILMSG(1, (TEXT("--ReadBlock\r\n")));
; 269  :     
; 270  :     return TRUE;

  00054	e3a00001	 mov         r0, #1
  00058	ea000000	 b           |$LN7@ReadBlock|
  0005c		 |$LN6@ReadBlock|

; 263  :         }
; 264  :     }
; 265  :     else
; 266  :         return rc;

  0005c	e3a00000	 mov         r0, #0
  00060		 |$LN7@ReadBlock|

; 271  : }

  00060	e28dd008	 add         sp, sp, #8
  00064	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00068	e12fff1e	 bx          lr
  0006c		 |$M41870|

			 ENDP  ; |ReadBlock|

	IMPORT	|FMD_SetBlockStatus|
	IMPORT	|memcpy|

  00000			 AREA	 |.pdata|, PDATA
|$T41919| DCD	|$LN49@WriteBlock|
	DCD	0x40006e02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |WriteBlock| PROC

; 283  : {   

  00000		 |$LN49@WriteBlock|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M41916|
  00008	e1a06003	 mov         r6, r3
  0000c	e58d6004	 str         r6, [sp, #4]
  00010	e1a04001	 mov         r4, r1
  00014	e1a0a000	 mov         r10, r0

; 284  :     UINT32 count;
; 285  :     UINT32 sectorSize, sectorsPerBlock;
; 286  :     SectorInfo sectorInfo;
; 287  :     SECTOR_ADDR sector;
; 288  :     UINT32 nextSectorSize;
; 289  : 	BOOL badBlock = FALSE;
; 290  : 	UINT32 attemptTimes = 0;
; 291  : 
; 292  : 
; 293  :     // Get flash info
; 294  :     sectorSize = pFlashInfo->wDataBytesPerSector;

  00018	e1d210be	 ldrh        r1, [r2, #0xE]

; 295  :     sectorsPerBlock = pFlashInfo->wSectorsPerBlock;

  0001c	e1d270bc	 ldrh        r7, [r2, #0xC]
  00020	e3a0b000	 mov         r11, #0
  00024	e58d1008	 str         r1, [sp, #8]
  00028	e58db000	 str         r11, [sp]
  0002c		 |$LL25@WriteBlock|

; 296  : 	//RETAILMSG (1, (TEXT("WriteBlock (%d)\r\n"),block));
; 297  : 	do{
; 298  : 		badBlock = FALSE;

  0002c	e3a09000	 mov         r9, #0

; 299  : 		// Erase block
; 300  : 		if (!FlashEraseBlock(block))

  00030	e3a05003	 mov         r5, #3
  00034		 |$LL31@WriteBlock|
  00034	e1a0000a	 mov         r0, r10
  00038	eb000000	 bl          FMD_EraseBlock
  0003c	e3500000	 cmp         r0, #0
  00040	1a000006	 bne         |$LN45@WriteBlock|
  00044	e2555001	 subs        r5, r5, #1
  00048	1afffff9	 bne         |$LL31@WriteBlock|
  0004c		 |$LN21@WriteBlock|

; 383  : 			}
; 384  : 		}
; 385  : 		else
; 386  : 			return NULL;

  0004c	e3a04000	 mov         r4, #0
  00050		 |$LN26@WriteBlock|

; 394  :     
; 395  :     return pDataBuffer;
; 396  : }

  00050	e1a00004	 mov         r0, r4
  00054	e28dd014	 add         sp, sp, #0x14
  00058	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$LN45@WriteBlock|

; 301  : 		{
; 302  : 			//KITLOutputDebugString("ERROR: WriteBlock: Erase block %d failed!\r\n", block);
; 303  : 			//    //KITLOutputDebugString("WARNING: Would just try to write the block directly\r\n");
; 304  : 			return NULL;
; 305  : 		}
; 306  : 
; 307  : 		// Read data from block
; 308  : 		if (pDataBuffer != NULL)

  00060	e3540000	 cmp         r4, #0
  00064	0afffff8	 beq         |$LN21@WriteBlock|

; 309  : 		{
; 310  : 			sector = block * sectorsPerBlock;

  00068	e0050a97	 mul         r5, r7, r10

; 311  : 			for(count = 0; count < sectorsPerBlock; count++)

  0006c	e3570000	 cmp         r7, #0
  00070	0afffff6	 beq         |$LN26@WriteBlock|
  00074	e59db008	 ldr         r11, [sp, #8]
  00078	e1a08007	 mov         r8, r7
  0007c		 |$LL20@WriteBlock|

; 312  : 			{
; 313  : 				unsigned int i;
; 314  : 				BOOL allones = FALSE;
; 315  : 				////KITLOutputDebugString("-");
; 316  : 				// Prepare sector info
; 317  : 				if (fSectorInfo)

  0007c	e3560000	 cmp         r6, #0
  00080	0a00000a	 beq         |$LN17@WriteBlock|

; 318  : 				{
; 319  : 					memcpy(&sectorInfo, pDataBuffer+sectorSize,sizeof(SectorInfo));

  00084	e08b1004	 add         r1, r11, r4
  00088	e28d000c	 add         r0, sp, #0xC
  0008c	e3a02008	 mov         r2, #8
  00090	eb000000	 bl          memcpy

; 320  : 					// In case the BIN/DIO image accidentally sets bBadBlock to anything other than 0xFF...
; 321  : 					// (this will turn a good block bad!)
; 322  : 					if (sectorInfo.bBadBlock != 0xFF)

  00094	e5dd3011	 ldrb        r3, [sp, #0x11]

; 323  : 					{
; 324  : 						//KITLOutputDebugString("WARNING: Bad block byte is set (%B) on sector %d of block %d! Resetting to 0xFF.\r\n", sectorInfo.bBadBlock, count, block);
; 325  : 						sectorInfo.bBadBlock = 0xFF; 
; 326  : 					}
; 327  : 					nextSectorSize = sectorSize+sizeof(SectorInfo);
; 328  : 				}
; 329  : 				else

  00098	e1dd11b2	 ldrh        r1, [sp, #0x12]
  0009c	e28b6008	 add         r6, r11, #8
  000a0	e35300ff	 cmp         r3, #0xFF
  000a4	13a030ff	 movne       r3, #0xFF
  000a8	15cd3011	 strneb      r3, [sp, #0x11]
  000ac	ea00000a	 b           |$LN15@WriteBlock|
  000b0		 |$LN17@WriteBlock|

; 330  : 				{               
; 331  : 					memset(&sectorInfo, 0xFF, sizeof(sectorInfo));

  000b0	e3e03000	 mvn         r3, #0
  000b4	e58d300c	 str         r3, [sp, #0xC]
  000b8	e58d3010	 str         r3, [sp, #0x10]

; 332  : 					sectorInfo.bOEMReserved &= ~(OEM_BLOCK_READONLY|OEM_BLOCK_RESERVED);

  000bc	e5dd3010	 ldrb        r3, [sp, #0x10]

; 333  : 					sectorInfo.dwReserved1 = 0;
; 334  : 					sectorInfo.wReserved2 = 0;

  000c0	e3a01000	 mov         r1, #0
  000c4	e1cd11b2	 strh        r1, [sp, #0x12]
  000c8	e20330fc	 and         r3, r3, #0xFC
  000cc	e5cd3010	 strb        r3, [sp, #0x10]
  000d0	e3a03000	 mov         r3, #0
  000d4	e58d300c	 str         r3, [sp, #0xC]

; 335  : 					nextSectorSize = sectorSize;

  000d8	e1a0600b	 mov         r6, r11
  000dc		 |$LN15@WriteBlock|

; 336  : 				}
; 337  : 
; 338  : 				//Skip write operation for BBT reserved area and OS Image partision if all data are 'FF'
; 339  : 				//Thus we could be in accordance with XDB
; 340  : 				if(((sector >= (sectorsPerBlock - LB_RELOCATION_TABLE_NUM))&&(sector < sectorsPerBlock)) || (block >= LB_FLASH_BLOCK_OS_START))

  000dc	e247303e	 sub         r3, r7, #0x3E
  000e0	e1550003	 cmp         r5, r3
  000e4	3a000001	 bcc         |$LN12@WriteBlock|
  000e8	e1550007	 cmp         r5, r7
  000ec	3a000001	 bcc         |$LN13@WriteBlock|
  000f0		 |$LN12@WriteBlock|
  000f0	e35a0006	 cmp         r10, #6
  000f4	3a000009	 bcc         |$LN38@WriteBlock|
  000f8		 |$LN13@WriteBlock|

; 341  : 				{
; 342  : 					allones = TRUE;
; 343  : 				for(i=0;i<nextSectorSize;i++)

  000f8	e3a02000	 mov         r2, #0
  000fc	e3560000	 cmp         r6, #0
  00100	0a00001f	 beq         |$LN5@WriteBlock|
  00104		 |$LL11@WriteBlock|

; 344  : 				{
; 345  : 					if ((*(pDataBuffer+i))!=0xff)

  00104	e7d23004	 ldrb        r3, [r2, +r4]
  00108	e35300ff	 cmp         r3, #0xFF
  0010c	1a000003	 bne         |$LN38@WriteBlock|
  00110	e2822001	 add         r2, r2, #1
  00114	e1520006	 cmp         r2, r6
  00118	3afffff9	 bcc         |$LL11@WriteBlock|

; 390  : 			if(attemptTimes >= NAND_ATTEMPT_NUMBER)

  0011c	ea000018	 b           |$LN5@WriteBlock|
  00120		 |$LN38@WriteBlock|

; 346  : 					{
; 347  : 						allones = FALSE;
; 348  : 						break;
; 349  : 					}
; 350  : 				}
; 351  : 				}
; 352  : 
; 353  : 				if (!allones) 
; 354  : 				{
; 355  : 					// Mark the Sector as Write in Progress
; 356  : 					sectorInfo.wReserved2 &= ~SECTOR_WRITE_IN_PROGRESS;

  00120	e3a02cff	 mov         r2, #0xFF, 24
  00124	e38230fd	 orr         r3, r2, #0xFD
  00128	e0013003	 and         r3, r1, r3

; 357  : 					if (!FlashWriteSector(sector, NULL, &sectorInfo))

  0012c	e3a01000	 mov         r1, #0
  00130	e28d200c	 add         r2, sp, #0xC
  00134	e1a00005	 mov         r0, r5
  00138	e1cd31b2	 strh        r3, [sp, #0x12]
  0013c	eb000000	 bl          FlashWriteSector
  00140	e3500000	 cmp         r0, #0
  00144	1a000003	 bne         |$LN6@WriteBlock|

; 358  : 					{
; 359  : 						// Write failed, mark block as bad
; 360  : 						FMD_SetBlockStatus(block, BLOCK_STATUS_BAD);

  00148	e3a01002	 mov         r1, #2
  0014c	e1a0000a	 mov         r0, r10
  00150	eb000000	 bl          FMD_SetBlockStatus

; 361  : 						//KITLOutputDebugString("ERROR: WriteBlock: Failed write sector %d to flash\r\n", sector);
; 362  : 						badBlock = TRUE;

  00154	e3a09001	 mov         r9, #1
  00158		 |$LN6@WriteBlock|

; 363  : 					}
; 364  : 					// Mark the Sector as Completed if success
; 365  : 					sectorInfo.wReserved2 &= ~SECTOR_WRITE_COMPLETED;

  00158	e1dd31b2	 ldrh        r3, [sp, #0x12]
  0015c	e3a01cff	 mov         r1, #0xFF, 24
  00160	e38120fb	 orr         r2, r1, #0xFB
  00164	e0033002	 and         r3, r3, r2

; 366  : 
; 367  : 					if (!FlashWriteSector(sector, pDataBuffer, &sectorInfo))

  00168	e28d200c	 add         r2, sp, #0xC
  0016c	e1a01004	 mov         r1, r4
  00170	e1a00005	 mov         r0, r5
  00174	e1cd31b2	 strh        r3, [sp, #0x12]
  00178	eb000000	 bl          FlashWriteSector
  0017c	e3500000	 cmp         r0, #0

; 368  : 					{
; 369  : 						//KITLOutputDebugString("ERROR: WriteBlock: Failed write sector %d to flash\r\n", sector);
; 370  : 						badBlock = TRUE;

  00180	03a09001	 moveq       r9, #1
  00184		 |$LN5@WriteBlock|

; 371  : 					}
; 372  : 				}
; 373  : 				else
; 374  : 				{
; 375  : 					////KITLOutputDebugString("INFO: WriteBlock: all-one write sector %d to flash\r\n", sector);
; 376  : 					//dumpData((char *)(pDataBuffer+sectorSize), 8, 0);
; 377  : 					// Do nothing here. Don't program this page. Just skip it.
; 378  : 				}
; 379  : 
; 380  : 				//Move to next sector
; 381  : 				sector++;
; 382  : 				pDataBuffer += nextSectorSize;

  00184	e0844006	 add         r4, r4, r6
  00188	e59d6004	 ldr         r6, [sp, #4]
  0018c	e2855001	 add         r5, r5, #1
  00190	e2588001	 subs        r8, r8, #1
  00194	1affffb8	 bne         |$LL20@WriteBlock|

; 387  : 		if(badBlock)
; 388  : 		{
; 389  : 			attemptTimes++;

  00198	e59db000	 ldr         r11, [sp]
  0019c	e3590000	 cmp         r9, #0
  001a0	0affffaa	 beq         |$LN26@WriteBlock|
  001a4	e28bb001	 add         r11, r11, #1
  001a8	e58db000	 str         r11, [sp]

; 390  : 			if(attemptTimes >= NAND_ATTEMPT_NUMBER)

  001ac	e35b0003	 cmp         r11, #3
  001b0	2affffa5	 bcs         |$LN21@WriteBlock|

; 391  : 				return NULL;
; 392  : 		}
; 393  : 	}while(badBlock);

  001b4	eaffff9c	 b           |$LL25@WriteBlock|
  001b8		 |$M41917|

			 ENDP  ; |WriteBlock|

	EXPORT	|FlashReadNAND|
	IMPORT	|__rt_udiv|

  00000			 AREA	 |.pdata|, PDATA
|$T41968| DCD	|$LN30@FlashReadN@2|
	DCD	0x40003a02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FlashReadNAND| PROC

; 399  : {

  00000		 |$LN30@FlashReadN@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd020	 sub         sp, sp, #0x20
  00008		 |$M41965|
  00008	e1a06000	 mov         r6, r0
  0000c	e58d6004	 str         r6, [sp, #4]
  00010	e1a04002	 mov         r4, r2
  00014	e1a0b001	 mov         r11, r1

; 400  :     BOOL rc = FALSE;
; 401  :     FlashInfo flashInfo;
; 402  :     BLOCK_ID block = startBlock;
; 403  :     DWORD i=0;
; 404  :     DWORD index=0;
; 405  :     DWORD dwReadSize=size;    
; 406  :     UINT8 *lpBuffer=pDataBuffer;        
; 407  :     
; 408  :     if (!FMD_GetInfo(&flashInfo)) 

  00018	e28d0010	 add         r0, sp, #0x10
  0001c	eb000000	 bl          FMD_GetInfo
  00020	e3500000	 cmp         r0, #0
  00024	1a000001	 bne         |$LN8@FlashReadN@2|
  00028		 |$LN27@FlashReadN@2|

; 409  :     {
; 410  :         //KITLOutputDebugString("ERROR: FlashReadNAND: FMD_GetInfo call failed!\r\n");
; 411  :         return rc;

  00028	e3a00000	 mov         r0, #0
  0002c	ea00002a	 b           |$LN9@FlashReadN@2|
  00030		 |$LN8@FlashReadN@2|

; 412  :     }
; 413  : 
; 414  :     if (!lpBuffer)

  00030	e35b0000	 cmp         r11, #0

; 415  :     {
; 416  :         //KITLOutputDebugString("ERROR: no buffer for configuration data!\r\n");
; 417  :         return rc;

  00034	0afffffb	 beq         |$LN27@FlashReadN@2|

; 418  :     }
; 419  :     else
; 420  :     {
; 421  :       
; 422  :     	  i=(size/flashInfo.dwBytesPerBlock);

  00038	e59d8018	 ldr         r8, [sp, #0x18]
  0003c	e1a01004	 mov         r1, r4
  00040	e1a00008	 mov         r0, r8
  00044	eb000000	 bl          __rt_udiv
  00048	e3510000	 cmp         r1, #0
  0004c	e1a04000	 mov         r4, r0

; 423  : 
; 424  :     	  if(size%flashInfo.dwBytesPerBlock)
; 425  :     	  i++;	

  00050	12844001	 addne       r4, r4, #1

; 426  :     	  
; 427  :     //	  RETAILMSG(1, (TEXT("\n\rStart block %d, read  %d / %d blocks BytesPerBlock(%d)\r\n\r\n"),startBlock,(index+1),i,flashInfo.dwBytesPerBlock));
; 428  :     	  
; 429  :         for(index=0; index < i ; index++)

  00054	e3540000	 cmp         r4, #0
  00058	e3a05000	 mov         r5, #0
  0005c	0a00001d	 beq         |$LN2@FlashReadN@2|
  00060	e1dd31be	 ldrh        r3, [sp, #0x1E]
  00064	e1dd71bc	 ldrh        r7, [sp, #0x1C]
  00068	e1cd30b0	 strh        r3, [sp]
  0006c		 |$LL4@FlashReadN@2|

; 430  :     	  {
; 431  :     	  	
; 432  :     	  	 ////KITLOutputDebugString("\n\rStart block %d, read  %d / %d blocks\r\n",startBlock,(index+1),i );
; 433  :     	  	  
; 434  :     	  	  lpBuffer=pDataBuffer+(flashInfo.dwBytesPerBlock*index);            

  0006c	e039b598	 mlas        r9, r8, r5, r11

; 435  :     	  	 
; 436  :     	  //	 RETAILMSG (1, (TEXT("\n\rFlashReadNAND data address (%x)\r\n"),lpBuffer));
; 437  :     	  	 
; 438  :             if(!ReadBlock((startBlock+index), lpBuffer, &flashInfo))

  00070	0affffec	 beq         |$LN27@FlashReadN@2|
  00074	e0853006	 add         r3, r5, r6
  00078	e00a0793	 mul         r10, r3, r7
  0007c	e3a06000	 mov         r6, #0
  00080	e3570000	 cmp         r7, #0
  00084	0a00000f	 beq         |$LN13@FlashReadN@2|
  00088	e1dd80b0	 ldrh        r8, [sp]
  0008c		 |$LL15@FlashReadN@2|
  0008c	e28d2008	 add         r2, sp, #8
  00090	e1a01009	 mov         r1, r9
  00094	e1a0000a	 mov         r0, r10
  00098	eb000000	 bl          FlashReadSector
  0009c	e3500000	 cmp         r0, #0
  000a0	0affffe0	 beq         |$LN27@FlashReadN@2|
  000a4	e2866001	 add         r6, r6, #1
  000a8	e1560007	 cmp         r6, r7
  000ac	e28aa001	 add         r10, r10, #1
  000b0	e0899008	 add         r9, r9, r8
  000b4	3afffff4	 bcc         |$LL15@FlashReadN@2|
  000b8	e1dd31be	 ldrh        r3, [sp, #0x1E]
  000bc	e1dd71bc	 ldrh        r7, [sp, #0x1C]
  000c0	e59d8018	 ldr         r8, [sp, #0x18]
  000c4	e1cd30b0	 strh        r3, [sp]
  000c8		 |$LN13@FlashReadN@2|
  000c8	e2855001	 add         r5, r5, #1
  000cc	e1550004	 cmp         r5, r4
  000d0	359d6004	 ldrcc       r6, [sp, #4]
  000d4	3affffe4	 bcc         |$LL4@FlashReadN@2|
  000d8		 |$LN2@FlashReadN@2|

; 439  :         {
; 440  :             // When block read fail, there isn't much we can do more
; 441  :                //KITLOutputDebugString("ERROR: FlashRead: Failed read block %d from flash\r\n", (startBlock+index));
; 442  :           //     RETAILMSG (1, (TEXT("\n\rERROR: FlashRead: Failed read block %d from flash\r\n"),startBlock+index));
; 443  :                return FALSE;
; 444  :         }
; 445  :        } 
; 446  :            
; 447  :          	
; 448  :     }
; 449  :  //    RETAILMSG (1, (TEXT("\n\r---FlashReadNAND \r\n")));
; 450  :     return (TRUE);

  000d8	e3a00001	 mov         r0, #1
  000dc		 |$LN9@FlashReadN@2|

; 451  : }

  000dc	e28dd020	 add         sp, sp, #0x20
  000e0	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  000e4	e12fff1e	 bx          lr
  000e8		 |$M41966|

			 ENDP  ; |FlashReadNAND|

	EXPORT	|FlashWriteNAND|

  00000			 AREA	 |.pdata|, PDATA
|$T42007| DCD	|$LN36@FlashWrite@2|
	DCD	0x40003602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FlashWriteNAND| PROC

; 454  : {

  00000		 |$LN36@FlashWrite@2|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M42004|
  00008	e1a04002	 mov         r4, r2
  0000c	e1b09001	 movs        r9, r1
  00010	e1a08000	 mov         r8, r0

; 455  :     BOOL rc = FALSE;
; 456  :     FlashInfo flashInfo;
; 457  :     UINT32 blockSize;
; 458  :     BLOCK_ID block = startBlock; 
; 459  :     UINT32 count, numBlocksProgram, i;
; 460  : 
; 461  :     if (pDataBuffer == NULL)

  00014	1a000001	 bne         |$LN14@FlashWrite@2|
  00018		 |$LN33@FlashWrite@2|

; 462  :     {
; 463  :         //KITLOutputDebugString("ERROR: no buffer for configuration data!\r\n");
; 464  :         return rc; 

  00018	e3a00000	 mov         r0, #0
  0001c	ea00002a	 b           |$LN15@FlashWrite@2|
  00020		 |$LN14@FlashWrite@2|

; 465  :     }    
; 466  :     
; 467  :     // Get flash info
; 468  :     if (!FMD_GetInfo(&flashInfo)) 

  00020	e28d0000	 add         r0, sp, #0
  00024	eb000000	 bl          FMD_GetInfo
  00028	e3500000	 cmp         r0, #0

; 469  :     {
; 470  :         //KITLOutputDebugString("ERROR: FlashWrite: FMD_GetInfo call failed!\r\n");
; 471  :         return rc;

  0002c	0afffff9	 beq         |$LN33@FlashWrite@2|

; 472  :     }
; 473  : 
; 474  :     blockSize = flashInfo.dwBytesPerBlock;

  00030	e59da008	 ldr         r10, [sp, #8]

; 475  : 
; 476  :     numBlocksProgram = size / blockSize;

  00034	e1a01004	 mov         r1, r4
  00038	e1a0000a	 mov         r0, r10
  0003c	eb000000	 bl          __rt_udiv
  00040	e1b04000	 movs        r4, r0

; 477  :     if ((numBlocksProgram == 0) || (size%blockSize != 0)) numBlocksProgram++;

  00044	0a000001	 beq         |$LN11@FlashWrite@2|
  00048	e3510000	 cmp         r1, #0
  0004c	0a000000	 beq         |$LN12@FlashWrite@2|
  00050		 |$LN11@FlashWrite@2|
  00050	e2844001	 add         r4, r4, #1
  00054		 |$LN12@FlashWrite@2|

; 478  :     
; 479  : 
; 480  :     ////KITLOutputDebugString("FlashWrite: blockSize = 0x%x\r\n", blockSize);
; 481  :     ////KITLOutputDebugString("FlashWrite: start writing at block %d\r\n", block);
; 482  :     ////KITLOutputDebugString("FlashWrite: numBlocksProgram: %d\r\n", numBlocksProgram);
; 483  : 
; 484  :     // Write image down to flash
; 485  :     for (count = 0; count < numBlocksProgram; count++)

  00054	e3a06000	 mov         r6, #0
  00058	e3540000	 cmp         r4, #0
  0005c	0a000019	 beq         |$LN8@FlashWrite@2|
  00060		 |$LL10@FlashWrite@2|

; 486  :     {
; 487  :        // //KITLOutputDebugString(".");
; 488  :         // Scan for bad block in bad block table
; 489  :         
; 490  :         i = 3;

  00060	e3a05003	 mov         r5, #3
  00064		 |$LL7@FlashWrite@2|

; 491  :         do 
; 492  :         {
; 493  :             ////KITLOutputDebugString("FlashWriteNAND: pData: %x\r\n", pDataBuffer);
; 494  : 
; 495  :             if (WriteBlock(block, pDataBuffer, &flashInfo, FALSE) == NULL)

  00064	e3a03000	 mov         r3, #0
  00068	e28d2000	 add         r2, sp, #0
  0006c	e1a01009	 mov         r1, r9
  00070	e1a00008	 mov         r0, r8
  00074	eb000000	 bl          WriteBlock
  00078	e3500000	 cmp         r0, #0
  0007c	1a00000a	 bne         |$LN5@FlashWrite@2|

; 496  :             {   
; 497  :                 // Let us try three times
; 498  : 
; 499  :                 if (!FlashEraseBlock(block)) //Bad block will be relocated when erase

  00080	e3a07003	 mov         r7, #3
  00084		 |$LL20@FlashWrite@2|
  00084	e1a00008	 mov         r0, r8
  00088	eb000000	 bl          FMD_EraseBlock
  0008c	e3500000	 cmp         r0, #0
  00090	1a000003	 bne         |$LN30@FlashWrite@2|
  00094	e2577001	 subs        r7, r7, #1
  00098	1afffff9	 bne         |$LL20@FlashWrite@2|

; 462  :     {
; 463  :         //KITLOutputDebugString("ERROR: no buffer for configuration data!\r\n");
; 464  :         return rc; 

  0009c	e3a00000	 mov         r0, #0
  000a0	ea000009	 b           |$LN15@FlashWrite@2|
  000a4		 |$LN30@FlashWrite@2|

; 500  :                     return rc;
; 501  :                 i--;

  000a4	e2555001	 subs        r5, r5, #1

; 502  :             }
; 503  :             else
; 504  :                 break;
; 505  :         } while (i > 0);

  000a8	1affffed	 bne         |$LL7@FlashWrite@2|
  000ac		 |$LN5@FlashWrite@2|

; 506  : 
; 507  :         if (i == 0)

  000ac	e3550000	 cmp         r5, #0
  000b0	0affffd8	 beq         |$LN33@FlashWrite@2|
  000b4	e2866001	 add         r6, r6, #1
  000b8	e1560004	 cmp         r6, r4

; 508  :         {
; 509  :             //KITLOutputDebugString("ERROR: FlashWrite: failed!\r\n");
; 510  :             return rc;
; 511  :         }
; 512  :         
; 513  :         block++;

  000bc	e2888001	 add         r8, r8, #1

; 514  :         pDataBuffer += blockSize;

  000c0	e089900a	 add         r9, r9, r10
  000c4	3affffe5	 bcc         |$LL10@FlashWrite@2|
  000c8		 |$LN8@FlashWrite@2|

; 515  :     }
; 516  : 
; 517  :    // //KITLOutputDebugString("\r\nFlashWrite: Image written\r\n");
; 518  :    
; 519  :     return TRUE;

  000c8	e3a00001	 mov         r0, #1
  000cc		 |$LN15@FlashWrite@2|

; 520  : }

  000cc	e28dd010	 add         sp, sp, #0x10
  000d0	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  000d4	e12fff1e	 bx          lr
  000d8		 |$M42005|

			 ENDP  ; |FlashWriteNAND|

	EXPORT	|WriteDataToFlash|
	EXPORT	|??_C@_1EA@PDHBGDDH@?$AA?6?$AA?$AN?$AAW?$AAr?$AAi?$AAt?$AAe?$AAN?$AAa?$AAn?$AAd?$AA?5?$AAO?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?5?$AAd?$AAo?$AAn?$AAe?$AA?6?$AA?$AN?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|free|
	IMPORT	|NKDbgPrintfW|
	IMPORT	|malloc|

  00000			 AREA	 |.pdata|, PDATA
|$T42035| DCD	|$LN22@WriteDataT|
	DCD	0x40005002

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EA@PDHBGDDH@?$AA?6?$AA?$AN?$AAW?$AAr?$AAi?$AAt?$AAe?$AAN?$AAa?$AAn?$AAd?$AA?5?$AAO?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?5?$AAd?$AAo?$AAn?$AAe?$AA?6?$AA?$AN?$AA?$AA@| DCB 0xa
	DCB	0x0, 0xd, 0x0, "W", 0x0, "r", 0x0, "i", 0x0, "t", 0x0, "e"
	DCB	0x0, "N", 0x0, "a", 0x0, "n", 0x0, "d", 0x0, " ", 0x0, "O"
	DCB	0x0, "f", 0x0, "f", 0x0, "s", 0x0, "e", 0x0, "t", 0x0, ":"
	DCB	0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%", 0x0, "x", 0x0, " "
	DCB	0x0, "d", 0x0, "o", 0x0, "n", 0x0, "e", 0x0, 0xa, 0x0, 0xd
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |WriteDataToFlash| PROC

; 525  : {

  00000		 |$LN22@WriteDataT|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M42032|
  00008	e1a03000	 mov         r3, r0
  0000c	e58d3008	 str         r3, [sp, #8]
  00010	e58d2004	 str         r2, [sp, #4]
  00014	e1a09001	 mov         r9, r1

; 526  : 	  BOOL  status=FALSE;
; 527  : 	
; 528  :     DWORD StartBlock=Offset/g_FlashInfo.dwBytesPerBlock;

  00018	e59fa11c	 ldr         r10, [pc, #0x11C]
  0001c	e1a01003	 mov         r1, r3
  00020	e3a07000	 mov         r7, #0
  00024	e59a5008	 ldr         r5, [r10, #8]
  00028	e1a00005	 mov         r0, r5
  0002c	eb000000	 bl          __rt_udiv
  00030	e1a04001	 mov         r4, r1
  00034	e58d0000	 str         r0, [sp]

; 529  :     
; 530  :     int iBlocks=DataSize/g_FlashInfo.dwBytesPerBlock;   

  00038	e1a00005	 mov         r0, r5
  0003c	e1a01009	 mov         r1, r9
  00040	eb000000	 bl          __rt_udiv
  00044	e1a0b000	 mov         r11, r0

; 531  :     
; 532  :     int i=0;    
; 533  :     
; 534  :     PBYTE DataBuffer=NULL;

  00048	e3a06000	 mov         r6, #0

; 535  :     
; 536  :     DWORD wBytes=(Offset%g_FlashInfo.dwBytesPerBlock);

  0004c	e3540000	 cmp         r4, #0

; 537  :     
; 538  :     
; 539  :     BYTE *lpTragetData=NULL;
; 540  :     
; 541  :     DWORD ShiftBytes,UpdateSize;  
; 542  :     
; 543  :     
; 544  :     
; 545  :     if(wBytes)

  00050	0a000010	 beq         |$LN10@WriteDataT|

; 546  :     {
; 547  :     	
; 548  :     	UpdateSize=(DataSize+wBytes);

  00054	e0848009	 add         r8, r4, r9

; 549  :     	
; 550  :     	DataBuffer= (PBYTE)malloc( UpdateSize );

  00058	e1a00008	 mov         r0, r8
  0005c	eb000000	 bl          malloc
  00060	e1b06000	 movs        r6, r0

; 551  :     	
; 552  :     	if(!DataBuffer)
; 553  :     	return FALSE;	

  00064	03a07000	 moveq       r7, #0
  00068	0a00002e	 beq         |$LN1@WriteDataT|

; 554  :     	
; 555  :         FlashReadNAND(StartBlock, DataBuffer, wBytes );   

  0006c	e59d0000	 ldr         r0, [sp]
  00070	e1a02004	 mov         r2, r4
  00074	e1a01006	 mov         r1, r6
  00078	eb000000	 bl          FlashReadNAND

; 556  :       
; 557  :         memcpy( (PBYTE)(DataBuffer+wBytes),lpSourceData,DataSize);

  0007c	e59d1004	 ldr         r1, [sp, #4]
  00080	e1a02009	 mov         r2, r9
  00084	e0840006	 add         r0, r4, r6
  00088	eb000000	 bl          memcpy

; 558  :       
; 559  :         lpTragetData=DataBuffer;
; 560  :            
; 561  :     
; 562  :     }
; 563  :     else

  0008c	e59a5008	 ldr         r5, [r10, #8]
  00090	e1a09006	 mov         r9, r6
  00094	ea000001	 b           |$LN8@WriteDataT|
  00098		 |$LN10@WriteDataT|

; 564  :     {	
; 565  :       lpTragetData=lpSourceData;
; 566  :       
; 567  :       UpdateSize=DataSize;

  00098	e1a08009	 mov         r8, r9
  0009c	e59d9004	 ldr         r9, [sp, #4]
  000a0		 |$LN8@WriteDataT|

; 568  :     }
; 569  :     
; 570  :     
; 571  :     for(i =0 ; i<iBlocks ;i++ )

  000a0	e3a04000	 mov         r4, #0
  000a4	e35b0000	 cmp         r11, #0
  000a8	da00000e	 ble         |$LN5@WriteDataT|
  000ac		 |$LL7@WriteDataT|

; 572  :     {
; 573  :     	 ShiftBytes=(i*g_FlashInfo.dwBytesPerBlock);    	
; 574  :     	  
; 575  :        if(!FlashWriteNAND( (StartBlock+i), (lpTragetData+ShiftBytes),g_FlashInfo.dwBytesPerBlock))

  000ac	e59d3000	 ldr         r3, [sp]
  000b0	e0219495	 mla         r1, r5, r4, r9
  000b4	e0840003	 add         r0, r4, r3
  000b8	e1a02005	 mov         r2, r5
  000bc	eb000000	 bl          FlashWriteNAND
  000c0	e3500000	 cmp         r0, #0
  000c4	0a000014	 beq         |$exit$41520|

; 576  :        goto exit;
; 577  :        
; 578  :       
; 579  :       RETAILMSG (1,(TEXT("\n\rWriteNand Offset: 0x%x done\n\r"),Offset+ShiftBytes)); 

  000c8	e59d3008	 ldr         r3, [sp, #8]
  000cc	e59f0064	 ldr         r0, [pc, #0x64]
  000d0	e0213495	 mla         r1, r5, r4, r3
  000d4	eb000000	 bl          NKDbgPrintfW
  000d8	e2844001	 add         r4, r4, #1
  000dc	e59a5008	 ldr         r5, [r10, #8]
  000e0	e154000b	 cmp         r4, r11
  000e4	bafffff0	 blt         |$LL7@WriteDataT|
  000e8		 |$LN5@WriteDataT|

; 580  :     }
; 581  :     
; 582  :     if(UpdateSize%g_FlashInfo.dwBytesPerBlock)

  000e8	e1a00005	 mov         r0, r5
  000ec	e1a01008	 mov         r1, r8
  000f0	eb000000	 bl          __rt_udiv
  000f4	e3510000	 cmp         r1, #0
  000f8	0a000006	 beq         |$LN2@WriteDataT|

; 583  :     {	 
; 584  :     	   	
; 585  :     	 if(!FlashWriteNAND( (StartBlock+i), (lpTragetData+(i*g_FlashInfo.dwBytesPerBlock)),(UpdateSize%g_FlashInfo.dwBytesPerBlock) ))

  000fc	e59d3000	 ldr         r3, [sp]
  00100	e1a02001	 mov         r2, r1
  00104	e0219495	 mla         r1, r5, r4, r9
  00108	e0840003	 add         r0, r4, r3
  0010c	eb000000	 bl          FlashWriteNAND
  00110	e3500000	 cmp         r0, #0
  00114	0a000000	 beq         |$exit$41520|
  00118		 |$LN2@WriteDataT|

; 586  :     	 goto exit;	
; 587  :     }
; 588  :     
; 589  :      status=TRUE;

  00118	e3a07001	 mov         r7, #1
  0011c		 |$exit$41520|

; 590  :     
; 591  : exit:
; 592  : 	    
; 593  :     if(DataBuffer)

  0011c	e3560000	 cmp         r6, #0

; 594  : 	  {	
; 595  : 	   free((void *) DataBuffer );

  00120	11a00006	 movne       r0, r6
  00124	1b000000	 blne        free
  00128		 |$LN1@WriteDataT|

; 596  : 	
; 597  : 	   DataBuffer=NULL;	
; 598  :     } 
; 599  :     	
; 600  :     return status;
; 601  :     	
; 602  : 
; 603  : }

  00128	e1a00007	 mov         r0, r7
  0012c	e28dd00c	 add         sp, sp, #0xC
  00130	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00134	e12fff1e	 bx          lr
  00138		 |$LN23@WriteDataT|
  00138		 |$LN24@WriteDataT|
  00138	00000000	 DCD         |??_C@_1EA@PDHBGDDH@?$AA?6?$AA?$AN?$AAW?$AAr?$AAi?$AAt?$AAe?$AAN?$AAa?$AAn?$AAd?$AA?5?$AAO?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?5?$AAd?$AAo?$AAn?$AAe?$AA?6?$AA?$AN?$AA?$AA@|
  0013c		 |$LN25@WriteDataT|
  0013c	00000000	 DCD         |g_FlashInfo|
  00140		 |$M42033|

			 ENDP  ; |WriteDataToFlash|

	EXPORT	|ReadDataFromFlash|

  00000			 AREA	 |.pdata|, PDATA
|$T42051| DCD	|$LN5@ReadDataFr|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ReadDataFromFlash| PROC

; 607  : {	

  00000		 |$LN5@ReadDataFr|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M42048|
  00004	e1a04001	 mov         r4, r1
  00008	e1a01000	 mov         r1, r0
  0000c	e1a05002	 mov         r5, r2

; 608  :     DWORD StartBlock=Offset/g_FlashInfo.dwBytesPerBlock;                  

  00010	e59f3018	 ldr         r3, [pc, #0x18]
  00014	e5930008	 ldr         r0, [r3, #8]
  00018	eb000000	 bl          __rt_udiv

; 609  :     	
; 610  :     return FlashReadNAND(StartBlock, lpTargetData, DataSize );   

  0001c	e1a02004	 mov         r2, r4
  00020	e1a01005	 mov         r1, r5
  00024	eb000000	 bl          FlashReadNAND

; 611  :     	
; 612  : 
; 613  : }

  00028	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$LN6@ReadDataFr|
  00030		 |$LN7@ReadDataFr|
  00030	00000000	 DCD         |g_FlashInfo|
  00034		 |$M42049|

			 ENDP  ; |ReadDataFromFlash|

	EXPORT	|ReadFlashData|
	EXPORT	|??_C@_1JG@DADAFIOP@?$AA?6?$AA?$AN?$AAR?$AAe?$AAa?$AAd?$AAF?$AAl?$AAa?$AAs?$AAh?$AAD?$AAa?$AAt?$AAa?$AA?3?$AA?5?$AAS?$AAt?$AAa?$AAr?$AAt?$AAS?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$CI?$AA?$CF?$AAd?$AA?$CJ@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T42071| DCD	|$LN9@ReadFlashD|
	DCD	0x40002c02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1JG@DADAFIOP@?$AA?6?$AA?$AN?$AAR?$AAe?$AAa?$AAd?$AAF?$AAl?$AAa?$AAs?$AAh?$AAD?$AAa?$AAt?$AAa?$AA?3?$AA?5?$AAS?$AAt?$AAa?$AAr?$AAt?$AAS?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$CI?$AA?$CF?$AAd?$AA?$CJ@| DCB 0xa
	DCB	0x0, 0xd, 0x0, "R", 0x0, "e", 0x0, "a", 0x0, "d", 0x0, "F"
	DCB	0x0, "l", 0x0, "a", 0x0, "s", 0x0, "h", 0x0, "D", 0x0, "a"
	DCB	0x0, "t", 0x0, "a", 0x0, ":", 0x0, " ", 0x0, "S", 0x0, "t"
	DCB	0x0, "a", 0x0, "r", 0x0, "t", 0x0, "S", 0x0, "e", 0x0, "c"
	DCB	0x0, "t", 0x0, "o", 0x0, "r", 0x0, "(", 0x0, "%", 0x0, "d"
	DCB	0x0, ")", 0x0, ",", 0x0, " ", 0x0, "E", 0x0, "n", 0x0, "d"
	DCB	0x0, "S", 0x0, "e", 0x0, "c", 0x0, "t", 0x0, "o", 0x0, "r"
	DCB	0x0, "(", 0x0, "%", 0x0, "d", 0x0, ")", 0x0, ",", 0x0, " "
	DCB	0x0, "O", 0x0, "f", 0x0, "f", 0x0, "s", 0x0, "e", 0x0, "t"
	DCB	0x0, "i", 0x0, "n", 0x0, "S", 0x0, "t", 0x0, "a", 0x0, "r"
	DCB	0x0, "t", 0x0, "S", 0x0, "e", 0x0, "c", 0x0, "t", 0x0, "o"
	DCB	0x0, "r", 0x0, "(", 0x0, "%", 0x0, "d", 0x0, ")", 0x0, 0xa
	DCB	0x0, 0xd, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ReadFlashData| PROC

; 617  : {

  00000		 |$LN9@ReadFlashD|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M42068|
  00008	e1a0a002	 mov         r10, r2
  0000c	e1a07001	 mov         r7, r1
  00010	e1a04000	 mov         r4, r0
  00014	e3a03c07	 mov         r3, #7, 24

; 618  : 
; 619  :     BOOL rc = FALSE;
; 620  :     UINT32  sectorSize,OffsetinStartSector;
; 621  :     SECTOR_ADDR StartSector,EndSector; //DWORD
; 622  :     SectorInfo sectorInfo;
; 623  :     PBYTE pData=NULL;
; 624  :     int i=0;
; 625  :   
; 626  :       
; 627  :     //1.Get Nand Flash info from FlashInit
; 628  :     sectorSize   = g_FlashInfo.wDataBytesPerSector;
; 629  :     
; 630  :     
; 631  :     //2.Check start sector
; 632  :     //StartSector =Offset/sectorSize; //count from Block0.sector0
; 633  :     StartSector =(Offset>>11); //my gy friend asked
; 634  :     
; 635  :     //check if not start from sector start address
; 636  :     OffsetinStartSector  = (Offset&0x7FF);//(Offset%sectorSize);

  00018	e38330ff	 orr         r3, r3, #0xFF

; 637  :  
; 638  :     //check the end of sector
; 639  :   //  EndSector =  (Offset+DataSize)/sectorSize;//count from Block0.sector0
; 640  :     EndSector =  (Offset+DataSize)>>11;//my gy friend asked

  0001c	e59f5088	 ldr         r5, [pc, #0x88]
  00020	e084e007	 add         lr, r4, r7

; 641  :    
; 642  :     RETAILMSG (1,(TEXT("\n\rReadFlashData: StartSector(%d), EndSector(%d), OffsetinStartSector(%d)\n\r"),StartSector,EndSector,OffsetinStartSector));

  00024	e59f007c	 ldr         r0, [pc, #0x7C]
  00028	e0048003	 and         r8, r4, r3
  0002c	e1a045a4	 mov         r4, r4, lsr #11
  00030	e1a095ae	 mov         r9, lr, lsr #11
  00034	e1d5b0be	 ldrh        r11, [r5, #0xE]
  00038	e1a01004	 mov         r1, r4
  0003c	e1a03008	 mov         r3, r8
  00040	e1a02009	 mov         r2, r9
  00044	eb000000	 bl          NKDbgPrintfW

; 643  :     
; 644  : 
; 645  :      pData = (PBYTE)malloc( (EndSector-StartSector+1)*sectorSize );

  00048	e0493004	 sub         r3, r9, r4
  0004c	e2833001	 add         r3, r3, #1
  00050	e0000b93	 mul         r0, r3, r11
  00054	eb000000	 bl          malloc
  00058	e1a06000	 mov         r6, r0
  0005c	e1a05006	 mov         r5, r6
  00060		 |$LL3@ReadFlashD|

; 646  :      
; 647  :     do
; 648  :     {
; 649  :       FlashReadSector(StartSector+i, (pData+sectorSize*i), &sectorInfo);

  00060	e28d2000	 add         r2, sp, #0
  00064	e1a01005	 mov         r1, r5
  00068	e1a00004	 mov         r0, r4
  0006c	eb000000	 bl          FlashReadSector

; 650  :       i++;

  00070	e2844001	 add         r4, r4, #1

; 651  :     }while(StartSector+i<=EndSector);

  00074	e1540009	 cmp         r4, r9
  00078	e085500b	 add         r5, r5, r11
  0007c	9afffff7	 bls         |$LL3@ReadFlashD|

; 652  :     
; 653  :     memcpy( lpTargetData ,(pData+OffsetinStartSector),DataSize);

  00080	e1a02007	 mov         r2, r7
  00084	e0881006	 add         r1, r8, r6
  00088	e1a0000a	 mov         r0, r10
  0008c	eb000000	 bl          memcpy

; 654  : 
; 655  :     free((void *) pData );

  00090	e1a00006	 mov         r0, r6
  00094	eb000000	 bl          free

; 656  :     
; 657  :  
; 658  :     return TRUE;

  00098	e3a00001	 mov         r0, #1

; 659  : }

  0009c	e28dd008	 add         sp, sp, #8
  000a0	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  000a4	e12fff1e	 bx          lr
  000a8		 |$LN10@ReadFlashD|
  000a8		 |$LN11@ReadFlashD|
  000a8	00000000	 DCD         |??_C@_1JG@DADAFIOP@?$AA?6?$AA?$AN?$AAR?$AAe?$AAa?$AAd?$AAF?$AAl?$AAa?$AAs?$AAh?$AAD?$AAa?$AAt?$AAa?$AA?3?$AA?5?$AAS?$AAt?$AAa?$AAr?$AAt?$AAS?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$CI?$AA?$CF?$AAd?$AA?$CJ@|
  000ac		 |$LN12@ReadFlashD|
  000ac	00000000	 DCD         |g_FlashInfo|
  000b0		 |$M42069|

			 ENDP  ; |ReadFlashData|

	EXPORT	|WriteFlashData|
	EXPORT	|??_C@_1ME@DANHLFAN@?$AA?6?$AA?$AN?$AAW?$AAr?$AAi?$AAt?$AAe?$AAF?$AAl?$AAa?$AAs?$AAh?$AAD?$AAa?$AAt?$AAa?$AA?3?$AA?5?$AAS?$AAt?$AAa?$AAr?$AAt?$AAB?$AAl?$AAo?$AAc?$AAk?$AA?$CI?$AA?$CF?$AAd?$AA?$CJ@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T42101| DCD	|$LN19@WriteFlash|
	DCD	0x40005d02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1ME@DANHLFAN@?$AA?6?$AA?$AN?$AAW?$AAr?$AAi?$AAt?$AAe?$AAF?$AAl?$AAa?$AAs?$AAh?$AAD?$AAa?$AAt?$AAa?$AA?3?$AA?5?$AAS?$AAt?$AAa?$AAr?$AAt?$AAB?$AAl?$AAo?$AAc?$AAk?$AA?$CI?$AA?$CF?$AAd?$AA?$CJ@| DCB 0xa
	DCB	0x0, 0xd, 0x0, "W", 0x0, "r", 0x0, "i", 0x0, "t", 0x0, "e"
	DCB	0x0, "F", 0x0, "l", 0x0, "a", 0x0, "s", 0x0, "h", 0x0, "D"
	DCB	0x0, "a", 0x0, "t", 0x0, "a", 0x0, ":", 0x0, " ", 0x0, "S"
	DCB	0x0, "t", 0x0, "a", 0x0, "r", 0x0, "t", 0x0, "B", 0x0, "l"
	DCB	0x0, "o", 0x0, "c", 0x0, "k", 0x0, "(", 0x0, "%", 0x0, "d"
	DCB	0x0, ")", 0x0, ",", 0x0, " ", 0x0, "E", 0x0, "n", 0x0, "d"
	DCB	0x0, "B", 0x0, "l", 0x0, "o", 0x0, "c", 0x0, "k", 0x0, "("
	DCB	0x0, "%", 0x0, "d", 0x0, ")", 0x0, ",", 0x0, " ", 0x0, "O"
	DCB	0x0, "f", 0x0, "f", 0x0, "s", 0x0, "e", 0x0, "t", 0x0, "i"
	DCB	0x0, "n", 0x0, "S", 0x0, "t", 0x0, "a", 0x0, "r", 0x0, "t"
	DCB	0x0, "B", 0x0, "l", 0x0, "o", 0x0, "c", 0x0, "k", 0x0, "("
	DCB	0x0, "%", 0x0, "d", 0x0, ")", 0x0, ",", 0x0, " ", 0x0, "L"
	DCB	0x0, "e", 0x0, "f", 0x0, "t", 0x0, "B", 0x0, "y", 0x0, "t"
	DCB	0x0, "e", 0x0, "s", 0x0, "i", 0x0, "n", 0x0, "E", 0x0, "n"
	DCB	0x0, "d", 0x0, "B", 0x0, "l", 0x0, "o", 0x0, "c", 0x0, "k"
	DCB	0x0, "(", 0x0, "%", 0x0, "d", 0x0, ")", 0x0, 0xa, 0x0, 0xd
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |WriteFlashData| PROC

; 662  : {

  00000		 |$LN19@WriteFlash|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M42098|
  00008	e1a0b002	 mov         r11, r2
  0000c	e1a02001	 mov         r2, r1
  00010	e58d2008	 str         r2, [sp, #8]
  00014	e1a05000	 mov         r5, r0

; 663  : 
; 664  : 
; 665  :     BOOL rc = FALSE;
; 666  :     UINT32  sectorSize,blockSize,OffsetinStartBlock,LeftBytesinEndBlock;
; 667  :     UINT32 StartBlock,EndBlock;
; 668  : //    FlashInfo  flashInfo;
; 669  :     
; 670  :     PBYTE pData=NULL;
; 671  :     UINT32 i=0,blockcount=0;
; 672  :   
; 673  :       
; 674  :     //1.Get Nand Flash info from FlashInit
; 675  :     sectorSize   = g_FlashInfo.wDataBytesPerSector;
; 676  :     blockSize    = g_FlashInfo.dwBytesPerBlock;

  00018	e59f3150	 ldr         r3, [pc, #0x150]

; 677  :     
; 678  :     //2.Check start sector
; 679  :     //StartSector =Offset/sectorSize; //count from Block0.sector0
; 680  :     StartBlock = (Offset>>17);
; 681  : //    StartSector =(Offset>>11); 
; 682  :     
; 683  :     //check if not start from sector start address
; 684  : //    OffsetinStartSector = (Offset&0x8FF);
; 685  :  
; 686  :     //check the end of sector
; 687  :   //  EndSector =  (Offset+DataSize)/sectorSize;//count from Block0.sector0
; 688  :     EndBlock = (Offset+DataSize-1)>>17;

  0001c	e0854002	 add         r4, r5, r2
  00020	e244e001	 sub         lr, r4, #1
  00024	e5937008	 ldr         r7, [r3, #8]
  00028	e1a088a5	 mov         r8, r5, lsr #17
  0002c	e1a098ae	 mov         r9, lr, lsr #17

; 689  : //    EndSector =  (Offset+DataSize)>>11;
; 690  :    
; 691  : //    LeftBytesinEndSector =((Offset+DataSize)&0x8FF);
; 692  :     
; 693  :     pData= (PBYTE)malloc(blockSize);

  00030	e1a00007	 mov         r0, r7
  00034	eb000000	 bl          malloc

; 694  :         
; 695  :     i=0;
; 696  :     blockcount=0;
; 697  :     
; 698  :     OffsetinStartBlock =(Offset&0x1FFFF);
; 699  :     LeftBytesinEndBlock =(Offset+DataSize)&0x1FFFF;
; 700  :  
; 701  :     RETAILMSG (1,(TEXT("\n\rWriteFlashData: StartBlock(%d), EndBlock(%d), OffsetinStartBlock(%d), LeftBytesinEndBlock(%d)\n\r"),
; 702  :                               StartBlock,EndBlock,OffsetinStartBlock,LeftBytesinEndBlock));

  00038	e3e034ff	 mvn         r3, #0xFF, 8
  0003c	e22338fe	 eor         r3, r3, #0xFE, 16
  00040	e1a06000	 mov         r6, r0
  00044	e59f0120	 ldr         r0, [pc, #0x120]
  00048	e0055003	 and         r5, r5, r3
  0004c	e004e003	 and         lr, r4, r3
  00050	e1a03005	 mov         r3, r5
  00054	e1a02009	 mov         r2, r9
  00058	e1a01008	 mov         r1, r8
  0005c	e58de00c	 str         lr, [sp, #0xC]
  00060	e3a0a000	 mov         r10, #0
  00064	e58de000	 str         lr, [sp]
  00068	eb000000	 bl          NKDbgPrintfW

; 703  :     
; 704  :     for(i=StartBlock;i<=EndBlock;i++)

  0006c	e1a04008	 mov         r4, r8
  00070	e1580009	 cmp         r8, r9
  00074	8a000036	 bhi         |$LN5@WriteFlash|
  00078	e085300b	 add         r3, r5, r11
  0007c	e59d2008	 ldr         r2, [sp, #8]
  00080	e58d3004	 str         r3, [sp, #4]
  00084	e59d300c	 ldr         r3, [sp, #0xC]
  00088	e0423003	 sub         r3, r2, r3
  0008c	e58d3010	 str         r3, [sp, #0x10]
  00090		 |$LL7@WriteFlash|

; 705  :     {
; 706  :       //before write, we need ro erase block(min size), so we have to save block data first.
; 707  :      // ReadBlock(i, pData, &flashInfo);    
; 708  :         
; 709  :       FlashReadNAND(i, pData, blockSize);

  00090	e1a02007	 mov         r2, r7
  00094	e1a01006	 mov         r1, r6
  00098	e1a00004	 mov         r0, r4
  0009c	eb000000	 bl          FlashReadNAND

; 710  :       
; 711  :       if(OffsetinStartBlock&&(i==StartBlock))

  000a0	e3550000	 cmp         r5, #0
  000a4	0a00000c	 beq         |$LN4@WriteFlash|
  000a8	e1540008	 cmp         r4, r8
  000ac	1a00000a	 bne         |$LN4@WriteFlash|

; 712  :       {
; 713  :         if(StartBlock==EndBlock)

  000b0	e1580009	 cmp         r8, r9

; 714  :           memcpy(pData+OffsetinStartBlock,lpSourceData,DataSize);

  000b4	059d2008	 ldreq       r2, [sp, #8]

; 715  :         else  
; 716  :           memcpy(pData+OffsetinStartBlock,lpSourceData,blockSize-OffsetinStartBlock);

  000b8	10472005	 subne       r2, r7, r5
  000bc	e1a0100b	 mov         r1, r11
  000c0	e0850006	 add         r0, r5, r6
  000c4	eb000000	 bl          memcpy

; 717  :        //blockcount++;
; 718  :         FlashWriteNAND(StartBlock,pData,blockSize);

  000c8	e1a00008	 mov         r0, r8
  000cc		 |$LN16@WriteFlash|
  000cc	e1a01006	 mov         r1, r6
  000d0	e1a02007	 mov         r2, r7
  000d4	eb000000	 bl          FlashWriteNAND

; 719  :         continue;

  000d8	ea00001a	 b           |$LN6@WriteFlash|
  000dc		 |$LN4@WriteFlash|

; 720  :       }
; 721  :       
; 722  :       if(LeftBytesinEndBlock&&(i==EndBlock))

  000dc	e59d300c	 ldr         r3, [sp, #0xC]
  000e0	e3530000	 cmp         r3, #0
  000e4	0a000008	 beq         |$LN1@WriteFlash|
  000e8	e1540009	 cmp         r4, r9
  000ec	1a000006	 bne         |$LN1@WriteFlash|

; 723  :       {
; 724  :         memcpy(pData,(lpSourceData+DataSize-LeftBytesinEndBlock),LeftBytesinEndBlock);

  000f0	e1a02003	 mov         r2, r3
  000f4	e59d3010	 ldr         r3, [sp, #0x10]
  000f8	e1a00006	 mov         r0, r6
  000fc	e083100b	 add         r1, r3, r11
  00100	eb000000	 bl          memcpy

; 725  :         FlashWriteNAND(EndBlock,pData,blockSize);

  00104	e1a00009	 mov         r0, r9

; 726  :         continue;

  00108	eaffffef	 b           |$LN16@WriteFlash|
  0010c		 |$LN1@WriteFlash|

; 727  :       }
; 728  :       
; 729  :       memcpy(pData, lpSourceData+OffsetinStartBlock+blockSize*blockcount, blockSize);

  0010c	e59d1004	 ldr         r1, [sp, #4]
  00110	e1a02007	 mov         r2, r7
  00114	e1a00006	 mov         r0, r6
  00118	eb000000	 bl          memcpy

; 730  :       FlashWriteNAND(StartBlock+(OffsetinStartBlock?blockcount+1:blockcount),pData,blockSize);

  0011c	e3550000	 cmp         r5, #0
  00120	128a3001	 addne       r3, r10, #1
  00124	01a0300a	 moveq       r3, r10
  00128	e0830008	 add         r0, r3, r8
  0012c	e1a02007	 mov         r2, r7
  00130	e1a01006	 mov         r1, r6
  00134	eb000000	 bl          FlashWriteNAND

; 731  :       
; 732  :       blockcount++;

  00138	e59d3004	 ldr         r3, [sp, #4]
  0013c	e28aa001	 add         r10, r10, #1
  00140	e0833007	 add         r3, r3, r7
  00144	e58d3004	 str         r3, [sp, #4]
  00148		 |$LN6@WriteFlash|
  00148	e2844001	 add         r4, r4, #1
  0014c	e1540009	 cmp         r4, r9
  00150	9affffce	 bls         |$LL7@WriteFlash|
  00154		 |$LN5@WriteFlash|

; 733  :       
; 734  :     }
; 735  :      
; 736  :    
; 737  :     free((void *) pData );

  00154	e1a00006	 mov         r0, r6
  00158	eb000000	 bl          free

; 738  :     
; 739  :     return TRUE; 

  0015c	e3a00001	 mov         r0, #1

; 740  : }

  00160	e28dd014	 add         sp, sp, #0x14
  00164	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00168	e12fff1e	 bx          lr
  0016c		 |$LN20@WriteFlash|
  0016c		 |$LN21@WriteFlash|
  0016c	00000000	 DCD         |??_C@_1ME@DANHLFAN@?$AA?6?$AA?$AN?$AAW?$AAr?$AAi?$AAt?$AAe?$AAF?$AAl?$AAa?$AAs?$AAh?$AAD?$AAa?$AAt?$AAa?$AA?3?$AA?5?$AAS?$AAt?$AAa?$AAr?$AAt?$AAB?$AAl?$AAo?$AAc?$AAk?$AA?$CI?$AA?$CF?$AAd?$AA?$CJ@|
  00170		 |$LN22@WriteFlash|
  00170	00000000	 DCD         |g_FlashInfo|
  00174		 |$M42099|

			 ENDP  ; |WriteFlashData|

	END
