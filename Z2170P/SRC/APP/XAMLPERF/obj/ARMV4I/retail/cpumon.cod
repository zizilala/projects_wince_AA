; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\EVM_OMAP3530\SRC\APP\XAMLPERF\cpumon.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|?CPUDriver@@3PAXA| [ DATA ]		; CPUDriver
	EXPORT	|?stop@@3HA| [ DATA ]			; stop
	EXPORT	|?bStarted@@3_NA| [ DATA ]		; bStarted
	EXPORT	|?idleCounter@@3JA| [ DATA ]		; idleCounter
	EXPORT	|?hMeasureThread@@3PAXA| [ DATA ]	; hMeasureThread
	EXPORT	|?hIdleThread@@3PAXA| [ DATA ]		; hIdleThread
	EXPORT	|?lMostrecentidlecount@@3JA| [ DATA ]	; lMostrecentidlecount
	EXPORT	|?CalibrateMax@@3JA| [ DATA ]		; CalibrateMax
	EXPORT	|?hSharedMem@@3PAXA| [ DATA ]		; hSharedMem

  00000			 AREA	 |.bss|, NOINIT
|?CPUDriver@@3PAXA| % 0x4				; CPUDriver
|?stop@@3HA| %	0x4					; stop
|?bStarted@@3_NA| % 0x1					; bStarted
|?idleCounter@@3JA| % 0x4				; idleCounter
|?hMeasureThread@@3PAXA| % 0x4				; hMeasureThread
|?hIdleThread@@3PAXA| % 0x4				; hIdleThread
|?lMostrecentidlecount@@3JA| % 0x4			; lMostrecentidlecount
|?CalibrateMax@@3JA| % 0x4				; CalibrateMax
|?hSharedMem@@3PAXA| % 0x4				; hSharedMem
	EXPORT	|GetCurrentThread|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T32168| DCD	|$LN5@GetCurrent|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentThread| PROC

; 351  : _inline HANDLE GetCurrentThread(void) {

  00000		 |$LN5@GetCurrent|
  00000		 |$M32165|

; 352  : 	return ((HANDLE)(SH_CURTHREAD+SYS_HANDLE_BASE));

  00000	e3a00041	 mov         r0, #0x41

; 353  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M32166|

			 ENDP  ; |GetCurrentThread|

	EXPORT	|StopCPUMonitor|
	IMPORT	|WaitForSingleObject|
	IMPORT	|CloseHandle|
	IMPORT	|SetLastError|
; File c:\wince600\platform\evm_omap3530\src\app\xamlperf\cpumon.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T32180| DCD	|$LN14@StopCPUMon|
	DCD	0x40003e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |StopCPUMonitor| PROC

; 201  : {

  00000		 |$LN14@StopCPUMon|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M32177|

; 202  : 
; 203  :     int rc=0;
; 204  : 
; 205  : 
; 206  :     //Have we calibrated the CPUMon
; 207  :     if(hSharedMem==NULL)

  00004	e59f40e8	 ldr         r4, [pc, #0xE8]
  00008	e5940020	 ldr         r0, [r4, #0x20]
  0000c	e3500000	 cmp         r0, #0
  00010	1a000005	 bne         |$LN6@StopCPUMon|
  00014		 |$LN9@StopCPUMon|

; 208  :     {
; 209  :         SetLastError(ERROR_NOT_READY);

  00014	e3a00015	 mov         r0, #0x15
  00018		 |$LN10@StopCPUMon|
  00018	eb000000	 bl          SetLastError
  0001c	e3a03116	 mov         r3, #0x16, 2

; 210  :         return(E_FAIL);

  00020	e3830901	 orr         r0, r3, #1, 18

; 261  : }

  00024	e8bd4010	 ldmia       sp!, {r4, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$LN6@StopCPUMon|

; 211  :     }
; 212  : 
; 213  :     //Have we actually started the CPUMon?
; 214  :     if(bStarted==false)

  0002c	e5d43008	 ldrb        r3, [r4, #8]
  00030	e3530000	 cmp         r3, #0
  00034	1a000003	 bne         |$LN5@StopCPUMon|

; 215  :     {
; 216  :         //let's get rid of the shared memory so that we don't leave it around
; 217  :         CloseHandle(hSharedMem);

  00038	eb000000	 bl          CloseHandle

; 218  :         hSharedMem=NULL;

  0003c	e3a03000	 mov         r3, #0
  00040	e5843020	 str         r3, [r4, #0x20]

; 219  : 
; 220  :         SetLastError(ERROR_NOT_READY);
; 221  :         return(E_FAIL);

  00044	eafffff2	 b           |$LN9@StopCPUMon|
  00048		 |$LN5@StopCPUMon|

; 222  :     }
; 223  : 
; 224  :     stop=2;
; 225  : 
; 226  :     rc=WaitForSingleObject(hIdleThread, INFINITE);

  00048	e5940014	 ldr         r0, [r4, #0x14]
  0004c	e3a03002	 mov         r3, #2
  00050	e3e01000	 mvn         r1, #0
  00054	e5843000	 str         r3, [r4]
  00058	eb000000	 bl          WaitForSingleObject

; 227  :     if(rc==WAIT_ABANDONED)

  0005c	e3500080	 cmp         r0, #0x80
  00060	1a000001	 bne         |$LN4@StopCPUMon|
  00064		 |$LN11@StopCPUMon|

; 228  :     {
; 229  :         SetLastError(ERROR_INVALID_FUNCTION);

  00064	e3a00001	 mov         r0, #1

; 230  :         return(E_FAIL);

  00068	eaffffea	 b           |$LN10@StopCPUMon|
  0006c		 |$LN4@StopCPUMon|

; 231  :     }
; 232  : 
; 233  :     rc=WaitForSingleObject(hMeasureThread, INFINITE);

  0006c	e5940010	 ldr         r0, [r4, #0x10]
  00070	e3e01000	 mvn         r1, #0
  00074	eb000000	 bl          WaitForSingleObject

; 234  :     if(rc==WAIT_ABANDONED)

  00078	e3500080	 cmp         r0, #0x80

; 235  :     {
; 236  :         SetLastError(ERROR_INVALID_FUNCTION);
; 237  :         return(E_FAIL);

  0007c	0afffff8	 beq         |$LN11@StopCPUMon|

; 238  :     }
; 239  : 
; 240  :     stop=0;
; 241  :     bStarted=false;
; 242  :     idleCounter=0L;
; 243  :     if (hMeasureThread)

  00080	e5940010	 ldr         r0, [r4, #0x10]
  00084	e3a03000	 mov         r3, #0
  00088	e3a02000	 mov         r2, #0
  0008c	e3a01000	 mov         r1, #0
  00090	e3500000	 cmp         r0, #0
  00094	e5843000	 str         r3, [r4]
  00098	e5c42008	 strb        r2, [r4, #8]
  0009c	e584100c	 str         r1, [r4, #0xC]
  000a0	0a000002	 beq         |$LN2@StopCPUMon|

; 244  :     {
; 245  :         CloseHandle(hMeasureThread);

  000a4	eb000000	 bl          CloseHandle

; 246  :         hMeasureThread=NULL;

  000a8	e3a03000	 mov         r3, #0
  000ac	e5843010	 str         r3, [r4, #0x10]
  000b0		 |$LN2@StopCPUMon|

; 247  :     }
; 248  :     if (hIdleThread)

  000b0	e5940014	 ldr         r0, [r4, #0x14]
  000b4	e3500000	 cmp         r0, #0
  000b8	0a000002	 beq         |$LN1@StopCPUMon|

; 249  :     {
; 250  :         CloseHandle(hIdleThread);

  000bc	eb000000	 bl          CloseHandle

; 251  :         hIdleThread=NULL;

  000c0	e3a03000	 mov         r3, #0
  000c4	e5843014	 str         r3, [r4, #0x14]
  000c8		 |$LN1@StopCPUMon|

; 252  :     }
; 253  :     lMostrecentidlecount=0;
; 254  :     CalibrateMax=0;
; 255  : 
; 256  :     //let's get rid of the shared memory
; 257  :     CloseHandle(hSharedMem);

  000c8	e5940020	 ldr         r0, [r4, #0x20]
  000cc	e3a03000	 mov         r3, #0
  000d0	e3a02000	 mov         r2, #0
  000d4	e5843018	 str         r3, [r4, #0x18]
  000d8	e584201c	 str         r2, [r4, #0x1C]
  000dc	eb000000	 bl          CloseHandle

; 258  :     hSharedMem=NULL;

  000e0	e3a03000	 mov         r3, #0
  000e4	e5843020	 str         r3, [r4, #0x20]

; 259  : 
; 260  :     return S_OK;

  000e8	e3a00000	 mov         r0, #0

; 261  : }

  000ec	e8bd4010	 ldmia       sp!, {r4, lr}
  000f0	e12fff1e	 bx          lr
  000f4		 |$LN15@StopCPUMon|
  000f4		 |$LN16@StopCPUMon|
  000f4	00000000	 DCD         |?stop@@3HA|
  000f8		 |$M32178|

			 ENDP  ; |StopCPUMonitor|

	EXPORT	|GetCurrentCPUUtilization|
	IMPORT	|__muls|
	IMPORT	|__itos|
	IMPORT	|__divs|
	IMPORT	|__subs|

  00000			 AREA	 |.pdata|, PDATA
|$T32197| DCD	|$LN10@GetCurrent@2|
	DCD	0x40002801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentCPUUtilization| PROC

; 277  : {

  00000		 |$LN10@GetCurrent@2|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M32194|

; 278  : 
; 279  :     float fPercentfree,fPercentused;
; 280  : 
; 281  :     //Have we calibrated the CPUMon
; 282  :     if(hSharedMem==NULL)

  00004	e59f4090	 ldr         r4, [pc, #0x90]
  00008	e5940018	 ldr         r0, [r4, #0x18]
  0000c	e3500000	 cmp         r0, #0
  00010	1a000005	 bne         |$LN4@GetCurrent@2|
  00014		 |$LN7@GetCurrent@2|

; 283  :     {
; 284  :         SetLastError(ERROR_NOT_READY);

  00014	e3a00015	 mov         r0, #0x15
  00018	eb000000	 bl          SetLastError
  0001c	e3e03080	 mvn         r3, #0x80

; 285  :         return(-1.00);

  00020	e1a00b83	 mov         r0, r3, lsl #23

; 308  : 
; 309  :     return(fPercentused);
; 310  : 
; 311  : }

  00024	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$LN4@GetCurrent@2|

; 286  :     }
; 287  : 
; 288  :     //Have we actually started the CPUMon?
; 289  :     if(bStarted==false)

  0002c	e5d43000	 ldrb        r3, [r4]
  00030	e3530000	 cmp         r3, #0
  00034	1a000003	 bne         |$LN3@GetCurrent@2|

; 290  :     {
; 291  :         //let's get rid of the shared memory so that we don't leave it around
; 292  :         CloseHandle(hSharedMem);

  00038	eb000000	 bl          CloseHandle

; 293  :         hSharedMem=NULL;

  0003c	e3a03000	 mov         r3, #0
  00040	e5843018	 str         r3, [r4, #0x18]

; 294  : 
; 295  :         SetLastError(ERROR_NOT_READY);
; 296  :         return(-1.00);

  00044	eafffff2	 b           |$LN7@GetCurrent@2|
  00048		 |$LN3@GetCurrent@2|

; 297  :     }
; 298  : 
; 299  :     if(CalibrateMax>0)

  00048	e5945014	 ldr         r5, [r4, #0x14]
  0004c	e3a06442	 mov         r6, #0x42, 8
  00050	e3550000	 cmp         r5, #0
  00054	da00000b	 ble         |$LN2@GetCurrent@2|

; 300  :     {
; 301  :         fPercentfree=((float)(lMostrecentidlecount)*100)/CalibrateMax;

  00058	e5940010	 ldr         r0, [r4, #0x10]
  0005c	eb000000	 bl          __itos
  00060	e3861732	 orr         r1, r6, #0x32, 14
  00064	eb000000	 bl          __muls
  00068	e1a04000	 mov         r4, r0
  0006c	e1a00005	 mov         r0, r5
  00070	eb000000	 bl          __itos
  00074	e1a01000	 mov         r1, r0
  00078	e1a00004	 mov         r0, r4
  0007c	eb000000	 bl          __divs
  00080	e1a01000	 mov         r1, r0

; 302  :     }
; 303  :     else

  00084	ea000000	 b           |$LN1@GetCurrent@2|
  00088		 |$LN2@GetCurrent@2|

; 304  :     {
; 305  :         fPercentfree=0;

  00088	e3a01000	 mov         r1, #0
  0008c		 |$LN1@GetCurrent@2|

; 306  :     }
; 307  :     fPercentused=(float)(100.000f-fPercentfree);

  0008c	e3860732	 orr         r0, r6, #0x32, 14
  00090	eb000000	 bl          __subs

; 308  : 
; 309  :     return(fPercentused);
; 310  : 
; 311  : }

  00094	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00098	e12fff1e	 bx          lr
  0009c		 |$LN11@GetCurrent@2|
  0009c		 |$LN12@GetCurrent@2|
  0009c	00000000	 DCD         |?bStarted@@3_NA|
  000a0		 |$M32195|

			 ENDP  ; |GetCurrentCPUUtilization|

	EXPORT	|RestartIdleCount|

  00000			 AREA	 |.pdata|, PDATA
|$T32209| DCD	|$LN5@RestartIdl|
	DCD	0x40000600
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |RestartIdleCount| PROC

; 314  : {

  00000		 |$LN5@RestartIdl|
  00000		 |$M32206|

; 315  : 
; 316  :     long retval;
; 317  : 
; 318  :     retval=idleCounter;

  00000	e59f300c	 ldr         r3, [pc, #0xC]

; 319  :     idleCounter=0;

  00004	e3a02000	 mov         r2, #0
  00008	e5930000	 ldr         r0, [r3]
  0000c	e5832000	 str         r2, [r3]

; 320  : 
; 321  :     return(retval);
; 322  : }

  00010	e12fff1e	 bx          lr
  00014		 |$LN6@RestartIdl|
  00014		 |$LN7@RestartIdl|
  00014	00000000	 DCD         |?idleCounter@@3JA|
  00018		 |$M32207|

			 ENDP  ; |RestartIdleCount|

	EXPORT	|UnitOfWork|
	IMPORT	|InterlockedIncrement|

  00000			 AREA	 |.pdata|, PDATA
|$T32220| DCD	|$LN10@UnitOfWork|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UnitOfWork| PROC

; 325  : {

  00000		 |$LN10@UnitOfWork|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M32217|

; 326  :     int counter = 0;
; 327  : 
; 328  :     for (int i=0; i<400; i++)
; 329  :     {
; 330  :         counter += i;
; 331  :     }
; 332  :     InterlockedIncrement(&idleCounter);

  00004	e59f0008	 ldr         r0, [pc, #8]
  00008	eb000000	 bl          InterlockedIncrement

; 333  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$LN11@UnitOfWork|
  00014		 |$LN12@UnitOfWork|
  00014	00000000	 DCD         |?idleCounter@@3JA|
  00018		 |$M32218|

			 ENDP  ; |UnitOfWork|

	EXPORT	|IdleWorkerThreadProc|
	IMPORT	|ExitThread|
	IMPORT	|SetThreadPriority|

  00000			 AREA	 |.pdata|, PDATA
|$T32243| DCD	|$LN18@IdleWorker|
	DCD	0x40000e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |IdleWorkerThreadProc| PROC

; 337  : {

  00000		 |$LN18@IdleWorker|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M32240|

; 338  :     UNREFERENCED_PARAMETER(arg);
; 339  :     
; 340  :     SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_IDLE);

  00004	e3a01007	 mov         r1, #7
  00008	e3a00041	 mov         r0, #0x41
  0000c	eb000000	 bl          SetThreadPriority
  00010	e59f401c	 ldr         r4, [pc, #0x1C]
  00014		 |$LL3@IdleWorker|

; 341  : 
; 342  :     /*
; 343  :      *  How many "units of work" can an idle thread do?
; 344  :      *  This is how we are going to measure the CPU
; 345  :      */
; 346  :     for(;;)
; 347  :     {
; 348  :         UnitOfWork();

  00014	e284000c	 add         r0, r4, #0xC
  00018	eb000000	 bl          InterlockedIncrement

; 349  : 
; 350  :         //Not useing an event-checking mechanism helps keep this lightweight.
; 351  :         if(stop>0)

  0001c	e5943000	 ldr         r3, [r4]
  00020	e3530000	 cmp         r3, #0
  00024	dafffffa	 ble         |$LL3@IdleWorker|

; 352  :         {
; 353  :             ExitThread(5);

  00028	e3a00005	 mov         r0, #5
  0002c	eb000000	 bl          ExitThread

; 354  :         }
; 355  :     }

  00030	eafffff7	 b           |$LL3@IdleWorker|
  00034		 |$LN19@IdleWorker|
  00034		 |$LN20@IdleWorker|
  00034	00000000	 DCD         |?stop@@3HA|
  00038		 |$M32241|

			 ENDP  ; |IdleWorkerThreadProc|

	EXPORT	|UpdateMeasurementsThreadProc|
	IMPORT	|Sleep|
	IMPORT	|GetTickCount|

  00000			 AREA	 |.pdata|, PDATA
|$T32265| DCD	|$LN16@UpdateMeas|
	DCD	0x40001901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UpdateMeasurementsThreadProc| PROC

; 361  : {

  00000		 |$LN16@UpdateMeas|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M32262|

; 362  : 
; 363  :     long lStartofquant;
; 364  :     UNREFERENCED_PARAMETER(arg);
; 365  : 
; 366  :     SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_TIME_CRITICAL);

  00004	e3a01000	 mov         r1, #0
  00008	e3a00041	 mov         r0, #0x41
  0000c	eb000000	 bl          SetThreadPriority

; 367  : 
; 368  :     RestartIdleCount();

  00010	e59f4048	 ldr         r4, [pc, #0x48]
  00014	e3a03000	 mov         r3, #0
  00018	e584300c	 str         r3, [r4, #0xC]

; 369  :     lStartofquant=GetTickCount();

  0001c	eb000000	 bl          GetTickCount
  00020	e3a05000	 mov         r5, #0
  00024		 |$LL4@UpdateMeas|

; 370  : 
; 371  :     for(;;)
; 372  :     {
; 373  :         Sleep(STANDARD_REFRESH_RATE);

  00024	e3a00e7d	 mov         r0, #0x7D, 28
  00028	eb000000	 bl          Sleep

; 374  : 
; 375  :         /*
; 376  :          *  Wake up every N milliseconds, reset the idle count and store our last count.
; 377  :          *  This basically gives us the abilty to see how "used" the CPU was over the past
; 378  :          *  N milliseconds.  CPU utilization is never an instaneous measurement, 
; 379  :          *  it's a sliding window measurement.
; 380  :          */
; 381  :         lMostrecentidlecount=RestartIdleCount();

  0002c	e594200c	 ldr         r2, [r4, #0xC]

; 382  :         if(lMostrecentidlecount > CalibrateMax)

  00030	e594301c	 ldr         r3, [r4, #0x1C]
  00034	e584500c	 str         r5, [r4, #0xC]
  00038	e5842018	 str         r2, [r4, #0x18]
  0003c	e1520003	 cmp         r2, r3

; 383  :         {
; 384  :             CalibrateMax=lMostrecentidlecount;

  00040	c584201c	 strgt       r2, [r4, #0x1C]

; 385  :         }
; 386  :         lStartofquant=GetTickCount();

  00044	eb000000	 bl          GetTickCount

; 387  : 
; 388  :         //Not useing an event-checking mechanism helps keep this lightweight.
; 389  :         if(stop>0)

  00048	e5943000	 ldr         r3, [r4]
  0004c	e3530000	 cmp         r3, #0
  00050	dafffff3	 ble         |$LL4@UpdateMeas|

; 390  :         {
; 391  :             ExitThread(5);

  00054	e3a00005	 mov         r0, #5
  00058	eb000000	 bl          ExitThread

; 392  :         }
; 393  :     }

  0005c	eafffff0	 b           |$LL4@UpdateMeas|
  00060		 |$LN17@UpdateMeas|
  00060		 |$LN18@UpdateMeas|
  00060	00000000	 DCD         |?stop@@3HA|
  00064		 |$M32263|

			 ENDP  ; |UpdateMeasurementsThreadProc|

	EXPORT	|CalibrateCPUMon|
	EXPORT	|??_C@_1DE@JCPMEAFP@?$AAC?$AAP?$AAU?$AA_?$AAM?$AAo?$AAn?$AAi?$AAt?$AAo?$AAr?$AA_?$AAS?$AAh?$AAa?$AAr?$AAe?$AAd?$AA_?$AAM?$AAe?$AAm?$AAo?$AAr?$AAy?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|GetThreadPriority|
	IMPORT	|GetLastError|
	IMPORT	|CreateFileMappingW|

  00000			 AREA	 |.pdata|, PDATA
|$T32295| DCD	|$LN27@CalibrateC|
	DCD	0x40005402

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DE@JCPMEAFP@?$AAC?$AAP?$AAU?$AA_?$AAM?$AAo?$AAn?$AAi?$AAt?$AAo?$AAr?$AA_?$AAS?$AAh?$AAa?$AAr?$AAe?$AAd?$AA_?$AAM?$AAe?$AAm?$AAo?$AAr?$AAy?$AA?$AA@| DCB "C"
	DCB	0x0, "P", 0x0, "U", 0x0, "_", 0x0, "M", 0x0, "o", 0x0, "n"
	DCB	0x0, "i", 0x0, "t", 0x0, "o", 0x0, "r", 0x0, "_", 0x0, "S"
	DCB	0x0, "h", 0x0, "a", 0x0, "r", 0x0, "e", 0x0, "d", 0x0, "_"
	DCB	0x0, "M", 0x0, "e", 0x0, "m", 0x0, "o", 0x0, "r", 0x0, "y"
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |CalibrateCPUMon| PROC

; 54   : {

  00000		 |$LN27@CalibrateC|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M32292|

; 55   : 
; 56   : DWORD prio,start;
; 57   : HANDLE CalibrateThread;
; 58   : int retval;
; 59   : 
; 60   :     if(hSharedMem!=NULL)

  00008	e59f413c	 ldr         r4, [pc, #0x13C]
  0000c	e5943020	 ldr         r3, [r4, #0x20]
  00010	e3530000	 cmp         r3, #0
  00014	0a000004	 beq         |$LN9@CalibrateC|
  00018		 |$LN23@CalibrateC|

; 61   :     {
; 62   :         SetLastError(ERROR_ALREADY_EXISTS);

  00018	e3a000b7	 mov         r0, #0xB7
  0001c		 |$LN22@CalibrateC|
  0001c	eb000000	 bl          SetLastError
  00020	e3a03116	 mov         r3, #0x16, 2

; 63   :         return(E_FAIL);

  00024	e3830901	 orr         r0, r3, #1, 18
  00028	ea000042	 b           |$LN10@CalibrateC|
  0002c		 |$LN9@CalibrateC|

; 64   :     }
; 65   : 
; 66   :     /*
; 67   :     *   Before we do anything, let's create some shared memory so other (future) CPUmons
; 68   :     *   know we are running.
; 69   :     */
; 70   : 
; 71   :     hSharedMem=NULL;
; 72   :     hSharedMem=CreateFileMapping(INVALID_HANDLE_VALUE,NULL,PAGE_READWRITE,0,CPUMON_SHARED_MEM_SIZE,CPUMON_SHARED_MEM_NAME);

  0002c	e59f3114	 ldr         r3, [pc, #0x114]
  00030	e3a0e000	 mov         lr, #0
  00034	e3a05c01	 mov         r5, #1, 24
  00038	e58d3004	 str         r3, [sp, #4]
  0003c	e3a03000	 mov         r3, #0
  00040	e3a02004	 mov         r2, #4
  00044	e3a01000	 mov         r1, #0
  00048	e3e00000	 mvn         r0, #0
  0004c	e584e020	 str         lr, [r4, #0x20]
  00050	e58d5000	 str         r5, [sp]
  00054	eb000000	 bl          CreateFileMappingW
  00058	e3500000	 cmp         r0, #0
  0005c	e5840020	 str         r0, [r4, #0x20]

; 73   : 
; 74   :     if(hSharedMem==NULL)

  00060	1a000001	 bne         |$LN8@CalibrateC|

; 75   :     {
; 76   :         SetLastError(GetLastError());

  00064	eb000000	 bl          GetLastError

; 77   :         return(E_FAIL);

  00068	eaffffeb	 b           |$LN22@CalibrateC|
  0006c		 |$LN8@CalibrateC|

; 78   :     }
; 79   : 
; 80   :     if(GetLastError()==ERROR_ALREADY_EXISTS)

  0006c	eb000000	 bl          GetLastError
  00070	e35000b7	 cmp         r0, #0xB7
  00074	1a000004	 bne         |$LN7@CalibrateC|

; 81   :     {
; 82   :         //we still need to close the handle to make sure we don't mess up any ref counting	
; 83   :         CloseHandle(hSharedMem);

  00078	e5940020	 ldr         r0, [r4, #0x20]
  0007c	eb000000	 bl          CloseHandle

; 84   :         hSharedMem=NULL;

  00080	e3a03000	 mov         r3, #0
  00084	e5843020	 str         r3, [r4, #0x20]

; 85   :         SetLastError(ERROR_ALREADY_EXISTS);
; 86   :         return(E_FAIL);

  00088	eaffffe2	 b           |$LN23@CalibrateC|
  0008c		 |$LN7@CalibrateC|

; 87   :     }
; 88   : 
; 89   :     //if we made it here, no one else is using the CPU Monitor
; 90   :     stop=0;

  0008c	e3a03000	 mov         r3, #0

; 91   :     CalibrateThread=GetCurrentThread();
; 92   :     prio=GetThreadPriority(CalibrateThread);

  00090	e3a00041	 mov         r0, #0x41
  00094	e5843000	 str         r3, [r4]
  00098	eb000000	 bl          GetThreadPriority
  0009c	e1a05000	 mov         r5, r0

; 93   : 
; 94   :     retval=SetThreadPriority(CalibrateThread,THREAD_PRIORITY_TIME_CRITICAL);

  000a0	e3a00041	 mov         r0, #0x41
  000a4	e3a01000	 mov         r1, #0
  000a8	eb000000	 bl          SetThreadPriority
  000ac	e3500000	 cmp         r0, #0

; 95   :     if(retval==0)

  000b0	1a000005	 bne         |$LN6@CalibrateC|
  000b4		 |$LN24@CalibrateC|

; 96   :     {
; 97   :         //let's get rid of the shared memory so that we don't leave it around
; 98   :         CloseHandle(hSharedMem);

  000b4	e5940020	 ldr         r0, [r4, #0x20]
  000b8	eb000000	 bl          CloseHandle

; 99   :         hSharedMem=NULL;

  000bc	e3a03000	 mov         r3, #0
  000c0	e5843020	 str         r3, [r4, #0x20]

; 100  : 
; 101  :         SetLastError(ERROR_INVALID_FUNCTION);

  000c4	e3a00001	 mov         r0, #1

; 102  :         return(E_FAIL);

  000c8	eaffffd3	 b           |$LN22@CalibrateC|
  000cc		 |$LN6@CalibrateC|

; 103  :     }
; 104  : 
; 105  :     start=GetTickCount();

  000cc	eb000000	 bl          GetTickCount

; 106  :     CalibrateMax=0;

  000d0	e3a03000	 mov         r3, #0
  000d4	e584301c	 str         r3, [r4, #0x1C]
  000d8	e1a06000	 mov         r6, r0
  000dc		 |$LL5@CalibrateC|

; 107  : 
; 108  :     do{
; 109  :         UnitOfWork();

  000dc	e284000c	 add         r0, r4, #0xC
  000e0	eb000000	 bl          InterlockedIncrement

; 110  :         if(stop>0)
; 111  :         {
; 112  :             //DO NOTHING
; 113  :         }
; 114  : 
; 115  :         CalibrateMax++;

  000e4	e594301c	 ldr         r3, [r4, #0x1C]
  000e8	e2833001	 add         r3, r3, #1
  000ec	e584301c	 str         r3, [r4, #0x1C]

; 116  :     }while(((long)(GetTickCount()-start))<STANDARD_CALIBRATION_TIME);

  000f0	eb000000	 bl          GetTickCount
  000f4	e0403006	 sub         r3, r0, r6
  000f8	e3530e7d	 cmp         r3, #0x7D, 28
  000fc	bafffff6	 blt         |$LL5@CalibrateC|

; 117  : 
; 118  :     retval=SetThreadPriority(CalibrateThread,prio);

  00100	e1a01005	 mov         r1, r5
  00104	e3a00041	 mov         r0, #0x41
  00108	eb000000	 bl          SetThreadPriority
  0010c	e3500000	 cmp         r0, #0

; 119  :     if(retval==0)
; 120  :     {
; 121  :         //let's get rid of the shared memory so that we don't leave it around
; 122  :         CloseHandle(hSharedMem);
; 123  :         hSharedMem=NULL;
; 124  : 
; 125  :         SetLastError(ERROR_INVALID_FUNCTION);
; 126  :         return(E_FAIL);

  00110	0affffe7	 beq         |$LN24@CalibrateC|

; 127  :     }
; 128  : 
; 129  :     CalibrateMax=(CalibrateMax*STANDARD_REFRESH_RATE)/STANDARD_CALIBRATION_TIME;

  00114	e594201c	 ldr         r2, [r4, #0x1C]
  00118	e3a01e7d	 mov         r1, #0x7D, 28
  0011c	e59f3020	 ldr         r3, [pc, #0x20]
  00120	e0010192	 mul         r1, r2, r1

; 130  : 
; 131  :     return S_OK;

  00124	e3a00000	 mov         r0, #0
  00128	e0c32391	 smull       r2, r3, r1, r3
  0012c	e1a033c3	 mov         r3, r3, asr #7
  00130	e0833fa3	 add         r3, r3, r3, lsr #31
  00134	e584301c	 str         r3, [r4, #0x1C]
  00138		 |$LN10@CalibrateC|

; 132  : }

  00138	e28dd008	 add         sp, sp, #8
  0013c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00140	e12fff1e	 bx          lr
  00144		 |$LN28@CalibrateC|
  00144		 |$LN29@CalibrateC|
  00144	10624dd3	 DCD         0x10624dd3
  00148		 |$LN30@CalibrateC|
  00148	00000000	 DCD         |??_C@_1DE@JCPMEAFP@?$AAC?$AAP?$AAU?$AA_?$AAM?$AAo?$AAn?$AAi?$AAt?$AAo?$AAr?$AA_?$AAS?$AAh?$AAa?$AAr?$AAe?$AAd?$AA_?$AAM?$AAe?$AAm?$AAo?$AAr?$AAy?$AA?$AA@|
  0014c		 |$LN31@CalibrateC|
  0014c	00000000	 DCD         |?stop@@3HA|
  00150		 |$M32293|

			 ENDP  ; |CalibrateCPUMon|

	EXPORT	|StartCPUMonitor|
	IMPORT	|CreateThread|

  00000			 AREA	 |.pdata|, PDATA
|$T32309| DCD	|$LN9@StartCPUMo|
	DCD	0x40002b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |StartCPUMonitor| PROC

; 152  : {

  00000		 |$LN9@StartCPUMo|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M32306|

; 153  : 
; 154  :     DWORD ThreadID;
; 155  : 
; 156  :     //Have we calibrated the CPUMon
; 157  :     if(hSharedMem==NULL)

  00008	e59f4098	 ldr         r4, [pc, #0x98]
  0000c	e5943018	 ldr         r3, [r4, #0x18]
  00010	e3530000	 cmp         r3, #0
  00014	1a000004	 bne         |$LN3@StartCPUMo|

; 158  :     {
; 159  :         SetLastError(ERROR_NOT_READY);

  00018	e3a00015	 mov         r0, #0x15
  0001c	eb000000	 bl          SetLastError
  00020		 |$LN6@StartCPUMo|
  00020	e3a03116	 mov         r3, #0x16, 2

; 160  :         return(E_FAIL);

  00024	e3830901	 orr         r0, r3, #1, 18
  00028	ea000019	 b           |$LN4@StartCPUMo|
  0002c		 |$LN3@StartCPUMo|

; 161  :     }
; 162  : 
; 163  :     //Start Worker thread
; 164  :     hIdleThread=CreateThread(NULL,0,IdleWorkerThreadProc,(void *)NULL,0,&ThreadID);

  0002c	e59f2070	 ldr         r2, [pc, #0x70]
  00030	e28de008	 add         lr, sp, #8
  00034	e3a05000	 mov         r5, #0
  00038	e3a03000	 mov         r3, #0
  0003c	e3a01000	 mov         r1, #0
  00040	e3a00000	 mov         r0, #0
  00044	e58de004	 str         lr, [sp, #4]
  00048	e58d5000	 str         r5, [sp]
  0004c	eb000000	 bl          CreateThread
  00050	e3500000	 cmp         r0, #0
  00054	e584000c	 str         r0, [r4, #0xC]

; 165  :     if(hIdleThread==NULL)
; 166  :     {
; 167  :         //SetLastError already called by CreateThread	
; 168  :         return(E_FAIL);

  00058	0afffff0	 beq         |$LN6@StartCPUMo|

; 169  :     }
; 170  :     
; 171  :     //Start Sampling thread
; 172  :     hMeasureThread=CreateThread(NULL,0,UpdateMeasurementsThreadProc,(void *)NULL,0,&ThreadID);

  0005c	e59f203c	 ldr         r2, [pc, #0x3C]
  00060	e28de008	 add         lr, sp, #8
  00064	e3a03000	 mov         r3, #0
  00068	e3a01000	 mov         r1, #0
  0006c	e3a00000	 mov         r0, #0
  00070	e58de004	 str         lr, [sp, #4]
  00074	e58d5000	 str         r5, [sp]
  00078	eb000000	 bl          CreateThread
  0007c	e3500000	 cmp         r0, #0
  00080	e5840008	 str         r0, [r4, #8]

; 173  :     if(hMeasureThread==NULL)
; 174  :     {
; 175  :         //SetLastError already called by CreateThread	
; 176  :         return(E_FAIL);

  00084	0affffe5	 beq         |$LN6@StartCPUMo|

; 177  :     }
; 178  :     
; 179  :     bStarted=true;

  00088	e3a03001	 mov         r3, #1
  0008c	e5c43000	 strb        r3, [r4]

; 180  : 
; 181  :     return S_OK;

  00090	e3a00000	 mov         r0, #0
  00094		 |$LN4@StartCPUMo|

; 182  : }

  00094	e28dd00c	 add         sp, sp, #0xC
  00098	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$LN10@StartCPUMo|
  000a0		 |$LN11@StartCPUMo|
  000a0	00000000	 DCD         |UpdateMeasurementsThreadProc|
  000a4		 |$LN12@StartCPUMo|
  000a4	00000000	 DCD         |IdleWorkerThreadProc|
  000a8		 |$LN13@StartCPUMo|
  000a8	00000000	 DCD         |?bStarted@@3_NA|
  000ac		 |$M32307|

			 ENDP  ; |StartCPUMonitor|

	END
