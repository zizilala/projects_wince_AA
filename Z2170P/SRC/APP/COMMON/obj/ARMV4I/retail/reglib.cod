; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\platform\Z2170P\src\APP\common\reglib.cxx
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

; File c:\wince600\platform\z2170p\src\app\common\reglib.cxx

  00000			 AREA	 |.pdata|, PDATA
|$T32476| DCD	|$LN22@GetToken|
	DCD	0x40002501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetToken@@YA?AW4RegToken@@PBGPAGPAI@Z| PROC ; GetToken

; 33   : {

  00000		 |$LN22@GetToken|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M32473|
  00004	e1a06002	 mov         r6, r2
  00008	e1a05000	 mov         r5, r0

; 34   :     UINT nOffset = 0;
; 35   :     RegToken token;
; 36   :     
; 37   :     // check for single character tokens
; 38   :     if (*pch == L'\\')

  0000c	e1d5e0b0	 ldrh        lr, [r5]
  00010	e3a03000	 mov         r3, #0
  00014	e35e005c	 cmp         lr, #0x5C

; 39   :         {
; 40   :         token = kBackSlash;

  00018	03a00001	 moveq       r0, #1

; 41   :         nOffset = 1;

  0001c	03a03001	 moveq       r3, #1
  00020	0a000018	 beq         |$LN1@GetToken|

; 42   :         }
; 43   :     else if (*pch == L'\0')

  00024	e35e0000	 cmp         lr, #0

; 44   :         {
; 45   :         token = kEnd;

  00028	03a00002	 moveq       r0, #2

; 46   :         nOffset = 0;

  0002c	03a03000	 moveq       r3, #0
  00030	0a000014	 beq         |$LN1@GetToken|

; 47   :         }
; 48   :     else
; 49   :         {
; 50   :         int i;
; 51   :         token = kError;

  00034	e3a00003	 mov         r0, #3

; 52   :         BOOL bCharFound = FALSE;

  00038	e3a0e000	 mov         lr, #0

; 53   :         for (i = 0; i < MAX_PATH; ++i)

  0003c	e3a04000	 mov         r4, #0
  00040		 |$LL9@GetToken|

; 54   :             {
; 55   :             if (*pch == L'\\')

  00040	e1d520b0	 ldrh        r2, [r5]
  00044	e352005c	 cmp         r2, #0x5C
  00048	0a00000a	 beq         |$LN17@GetToken|

; 59   :                 break;
; 60   :                 }
; 61   :             else if (*pch == L'\0')

  0004c	e3520000	 cmp         r2, #0
  00050	0a000008	 beq         |$LN17@GetToken|

; 65   :                 break;                
; 66   :                 }
; 67   :             else if (*pch != L' ')

  00054	e3520020	 cmp         r2, #0x20
  00058	e2844001	 add         r4, r4, #1

; 68   :                 {
; 69   :                 bCharFound = TRUE;                

  0005c	13a0e001	 movne       lr, #1
  00060	e3540f41	 cmp         r4, #0x41, 30

; 70   :                 }
; 71   :             *pchDest++ = *pch++;

  00064	e0c120b2	 strh        r2, [r1], #2
  00068	e2855002	 add         r5, r5, #2

; 72   :             nOffset++;

  0006c	e2833001	 add         r3, r3, #1
  00070	bafffff2	 blt         |$LL9@GetToken|

; 59   :                 break;
; 60   :                 }
; 61   :             else if (*pch == L'\0')

  00074	ea000001	 b           |$LN7@GetToken|
  00078		 |$LN17@GetToken|

; 56   :                 {
; 57   :                 // hit end of token
; 58   :                 *pchDest = L'\0';

  00078	e3a02000	 mov         r2, #0
  0007c	e1c120b0	 strh        r2, [r1]

; 62   :                 {
; 63   :                 // hit end of string
; 64   :                 *pchDest = L'\0';

  00080		 |$LN7@GetToken|

; 73   :             }
; 74   :         
; 75   :         if (bCharFound == TRUE) token = kKeyName;

  00080	e35e0001	 cmp         lr, #1
  00084	03a00000	 moveq       r0, #0
  00088		 |$LN1@GetToken|

; 76   :         }
; 77   :     *pnTokenLen = nOffset;

  00088	e5863000	 str         r3, [r6]

; 78   :     return token;
; 79   : }

  0008c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$M32474|

			 ENDP  ; |?GetToken@@YA?AW4RegToken@@PBGPAGPAI@Z|, GetToken

	IMPORT	|RegCreateKeyExW|

  00000			 AREA	 |.pdata|, PDATA
|$T32489| DCD	|$LN7@CreateRegK|
	DCD	0x40001302
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CreateRegKeyHelper@@YAPAUHKEY__@@PAU1@PBG@Z| PROC ; CreateRegKeyHelper

; 84   : {

  00000		 |$LN7@CreateRegK|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd01c	 sub         sp, sp, #0x1C
  00008		 |$M32486|

; 85   :     DWORD dwDisp;
; 86   :     HKEY hNewKey;
; 87   : 
; 88   :     LONG nRet = RegCreateKeyEx(hKey, lpSubKey, 0, NULL, 
; 89   :                     REG_OPTION_NON_VOLATILE, 0, NULL, &hNewKey, &dwDisp);

  00008	e28d3018	 add         r3, sp, #0x18
  0000c	e28d2014	 add         r2, sp, #0x14
  00010	e58d3010	 str         r3, [sp, #0x10]
  00014	e58d200c	 str         r2, [sp, #0xC]
  00018	e3a0e000	 mov         lr, #0
  0001c	e3a03000	 mov         r3, #0
  00020	e3a02000	 mov         r2, #0
  00024	e58de008	 str         lr, [sp, #8]
  00028	e58de004	 str         lr, [sp, #4]
  0002c	e58de000	 str         lr, [sp]
  00030	eb000000	 bl          RegCreateKeyExW
  00034	e3500000	 cmp         r0, #0

; 90   : 
; 91   :     if (nRet != ERROR_SUCCESS) hNewKey = NULL;

  00038	13a00000	 movne       r0, #0
  0003c	059d0014	 ldreq       r0, [sp, #0x14]

; 92   :     return hNewKey;
; 93   : }

  00040	e28dd01c	 add         sp, sp, #0x1C
  00044	e49de004	 ldr         lr, [sp], #4
  00048	e12fff1e	 bx          lr
  0004c		 |$M32487|

			 ENDP  ; |?CreateRegKeyHelper@@YAPAUHKEY__@@PAU1@PBG@Z|, CreateRegKeyHelper

	IMPORT	|RegSetValueExW|
	IMPORT	|RegQueryValueExW|
	IMPORT	|wcslen|

  00000			 AREA	 |.pdata|, PDATA
|$T32507| DCD	|$LN8@SetStringP|
	DCD	0x40002402
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetStringParam@@YAKPAUHKEY__@@PAXPBUDEVICE_WRITEREGISTRY_PARAM@@@Z| PROC ; SetStringParam

; 103  : {

  00000		 |$LN8@SetStringP|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M32504|
  00008	e1a05002	 mov         r5, r2
  0000c	e1a04001	 mov         r4, r1
  00010	e1a06000	 mov         r6, r0

; 104  :     DWORD status, size, type;
; 105  :     WCHAR *pName;
; 106  :     UCHAR *pValue;
; 107  : 
; 108  :     // check if no overwrite then check if key already exists
; 109  :     pName = pParam->name;
; 110  :     if (pParam->overwrite == FALSE)

  00014	e5953008	 ldr         r3, [r5, #8]
  00018	e5957000	 ldr         r7, [r5]
  0001c	e3530000	 cmp         r3, #0
  00020	1a000009	 bne         |$LN2@SetStringP|

; 111  :         {
; 112  :         status = RegQueryValueEx(hKey, pName, NULL, &type, NULL, &size);

  00024	e28d3008	 add         r3, sp, #8
  00028	e3a02000	 mov         r2, #0
  0002c	e58d3004	 str         r3, [sp, #4]
  00030	e58d2000	 str         r2, [sp]
  00034	e28d300c	 add         r3, sp, #0xC
  00038	e3a02000	 mov         r2, #0
  0003c	e1a01007	 mov         r1, r7
  00040	eb000000	 bl          RegQueryValueExW
  00044	e3500000	 cmp         r0, #0

; 113  :         if (status == ERROR_SUCCESS) goto cleanUp;

  00048	0a00000d	 beq         |$cleanUp$32363|
  0004c		 |$LN2@SetStringP|

; 114  :         }
; 115  :     
; 116  :     pValue = (UCHAR*)pBase + pParam->offset;

  0004c	e595300c	 ldr         r3, [r5, #0xC]
  00050	e0834004	 add         r4, r3, r4

; 117  :     size = wcslen((WCHAR*)pValue) * sizeof(WCHAR);

  00054	e1a00004	 mov         r0, r4
  00058	eb000000	 bl          wcslen

; 118  :     type = pParam->type;

  0005c	e5953004	 ldr         r3, [r5, #4]
  00060	e1a02080	 mov         r2, r0, lsl #1
  00064	e58d2008	 str         r2, [sp, #8]

; 119  : 
; 120  :     status = RegSetValueEx(hKey, pName, 0, type, pValue, size);

  00068	e58d2004	 str         r2, [sp, #4]
  0006c	e3a02000	 mov         r2, #0
  00070	e1a01007	 mov         r1, r7
  00074	e1a00006	 mov         r0, r6
  00078	e58d300c	 str         r3, [sp, #0xC]
  0007c	e58d4000	 str         r4, [sp]
  00080	eb000000	 bl          RegSetValueExW
  00084		 |$cleanUp$32363|

; 121  : 
; 122  : cleanUp:
; 123  :     return status;
; 124  : }

  00084	e28dd010	 add         sp, sp, #0x10
  00088	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0008c	e12fff1e	 bx          lr
  00090		 |$M32505|

			 ENDP  ; |?SetStringParam@@YAKPAUHKEY__@@PAXPBUDEVICE_WRITEREGISTRY_PARAM@@@Z|, SetStringParam


  00000			 AREA	 |.pdata|, PDATA
|$T32524| DCD	|$LN8@SetBlobPar|
	DCD	0x40002202
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetBlobParam@@YAKPAUHKEY__@@PAXPBUDEVICE_WRITEREGISTRY_PARAM@@@Z| PROC ; SetBlobParam

; 134  : {

  00000		 |$LN8@SetBlobPar|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M32521|
  00008	e1a04002	 mov         r4, r2
  0000c	e1a07001	 mov         r7, r1
  00010	e1a05000	 mov         r5, r0

; 135  :     DWORD status, size, type;
; 136  :     WCHAR *pName;
; 137  :     UCHAR *pValue;
; 138  : 
; 139  :     // check if no overwrite then check if key already exists
; 140  :     pName = pParam->name;
; 141  :     if (pParam->overwrite == FALSE)

  00014	e5943008	 ldr         r3, [r4, #8]
  00018	e5946000	 ldr         r6, [r4]
  0001c	e3530000	 cmp         r3, #0
  00020	1a000009	 bne         |$LN2@SetBlobPar|

; 142  :         {
; 143  :         status = RegQueryValueEx(hKey, pName, NULL, &type, NULL, &size);

  00024	e28d300c	 add         r3, sp, #0xC
  00028	e3a02000	 mov         r2, #0
  0002c	e58d3004	 str         r3, [sp, #4]
  00030	e58d2000	 str         r2, [sp]
  00034	e28d3008	 add         r3, sp, #8
  00038	e3a02000	 mov         r2, #0
  0003c	e1a01006	 mov         r1, r6
  00040	eb000000	 bl          RegQueryValueExW
  00044	e3500000	 cmp         r0, #0

; 144  :         if (status == ERROR_SUCCESS) goto cleanUp;

  00048	0a00000b	 beq         |$cleanUp$32380|
  0004c		 |$LN2@SetBlobPar|

; 145  :         }
; 146  :     
; 147  :     type = pParam->type;
; 148  :     pValue = (UCHAR*)pBase + pParam->offset;

  0004c	e594e00c	 ldr         lr, [r4, #0xC]
  00050	e5943004	 ldr         r3, [r4, #4]

; 149  :     size = pParam->size;

  00054	e5944010	 ldr         r4, [r4, #0x10]
  00058	e08e2007	 add         r2, lr, r7

; 150  :     status = RegSetValueEx(hKey, pName, 0, type, pValue, size);

  0005c	e58d2000	 str         r2, [sp]
  00060	e3a02000	 mov         r2, #0
  00064	e1a01006	 mov         r1, r6
  00068	e1a00005	 mov         r0, r5
  0006c	e58d3008	 str         r3, [sp, #8]
  00070	e58d400c	 str         r4, [sp, #0xC]
  00074	e58d4004	 str         r4, [sp, #4]
  00078	eb000000	 bl          RegSetValueExW
  0007c		 |$cleanUp$32380|

; 151  : 
; 152  : cleanUp:
; 153  :     return status;
; 154  : }

  0007c	e28dd010	 add         sp, sp, #0x10
  00080	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00084	e12fff1e	 bx          lr
  00088		 |$M32522|

			 ENDP  ; |?SetBlobParam@@YAKPAUHKEY__@@PAXPBUDEVICE_WRITEREGISTRY_PARAM@@@Z|, SetBlobParam

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?CreateRegKey@@YAPAUHKEY__@@PAU1@PBG@Z| ; CreateRegKey
	IMPORT	|RegCloseKey|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|__security_check_cookie|

  00000			 AREA	 |.pdata|, PDATA
|$T32593| DCD	|$LN48@CreateRegK@2|
	DCD	0xc0004b02

  00000			 AREA	 |.xdata|, DATA
|$T32589| DCD	0xffffffd8
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T32589|

  00008		 |?CreateRegKey@@YAPAUHKEY__@@PAU1@PBG@Z| PROC ; CreateRegKey

; 159  : {

  00008		 |$LN48@CreateRegK@2|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24ddf8a	 sub         sp, sp, #0x8A, 30
  00010		 |$M32590|
  00010	e1a06001	 mov         r6, r1
  00014	e1a05000	 mov         r5, r0
  00018	e59f3110	 ldr         r3, [pc, #0x110]
  0001c	e5933000	 ldr         r3, [r3]
  00020	e58d3224	 str         r3, [sp, #0x224]

; 160  :     HKEY hKeyNew = NULL;
; 161  :     HKEY hKey = hKeyRoot;
; 162  :     RegToken token = kBackSlash;
; 163  :     UINT nNextToken;
; 164  :     WCHAR szBuffer[MAX_PATH];
; 165  :     WCHAR const *pch = szPath;
; 166  :     LONG status = ERROR_INVALID_DATA;

  00024	e3a0700d	 mov         r7, #0xD
  00028	e3a0b000	 mov         r11, #0
  0002c	e28d9018	 add         r9, sp, #0x18
  00030	e28da014	 add         r10, sp, #0x14
  00034		 |$LL13@CreateRegK@2|

; 167  :     
; 168  :     for(;;)
; 169  :         {
; 170  :         token = GetToken(pch, szBuffer, &nNextToken);

  00034	e1d630b0	 ldrh        r3, [r6]
  00038	e28d201c	 add         r2, sp, #0x1C
  0003c	e1a0e006	 mov         lr, r6
  00040	e353005c	 cmp         r3, #0x5C
  00044	e3a08000	 mov         r8, #0
  00048	0a00002a	 beq         |$LN9@CreateRegK@2|
  0004c	e3530000	 cmp         r3, #0
  00050	0a00002b	 beq         |$cleanUp$32404|
  00054	e3a01000	 mov         r1, #0
  00058	e3a00000	 mov         r0, #0
  0005c		 |$LL24@CreateRegK@2|
  0005c	e1de30b0	 ldrh        r3, [lr]
  00060	e353005c	 cmp         r3, #0x5C
  00064	0a00000a	 beq         |$LN37@CreateRegK@2|
  00068	e3530000	 cmp         r3, #0
  0006c	0a000008	 beq         |$LN37@CreateRegK@2|
  00070	e3530020	 cmp         r3, #0x20
  00074	e2800001	 add         r0, r0, #1
  00078	13a01001	 movne       r1, #1
  0007c	e3500f41	 cmp         r0, #0x41, 30
  00080	e0c230b2	 strh        r3, [r2], #2
  00084	e28ee002	 add         lr, lr, #2
  00088	e2888001	 add         r8, r8, #1
  0008c	bafffff2	 blt         |$LL24@CreateRegK@2|

; 180  :                 if (hKeyNew == NULL) goto cleanUp; 

  00090	ea000000	 b           |$LN22@CreateRegK@2|
  00094		 |$LN37@CreateRegK@2|

; 167  :     
; 168  :     for(;;)
; 169  :         {
; 170  :         token = GetToken(pch, szBuffer, &nNextToken);

  00094	e1c2b0b0	 strh        r11, [r2]
  00098		 |$LN22@CreateRegK@2|
  00098	e3510001	 cmp         r1, #1
  0009c	1a000017	 bne         |$LN3@CreateRegK@2|

; 176  : 
; 177  :             case kKeyName:
; 178  :                 // create key using the key name
; 179  :                 hKeyNew = CreateRegKeyHelper(hKey, szBuffer);

  000a0	e3a03000	 mov         r3, #0
  000a4	e3a02000	 mov         r2, #0
  000a8	e28d101c	 add         r1, sp, #0x1C
  000ac	e1a00005	 mov         r0, r5
  000b0	e58d9010	 str         r9, [sp, #0x10]
  000b4	e58da00c	 str         r10, [sp, #0xC]
  000b8	e58db008	 str         r11, [sp, #8]
  000bc	e58db004	 str         r11, [sp, #4]
  000c0	e58db000	 str         r11, [sp]
  000c4	eb000000	 bl          RegCreateKeyExW
  000c8	e3500000	 cmp         r0, #0
  000cc	13a04000	 movne       r4, #0
  000d0	158d4014	 strne       r4, [sp, #0x14]
  000d4	059d4014	 ldreq       r4, [sp, #0x14]

; 180  :                 if (hKeyNew == NULL) goto cleanUp; 

  000d8	e3540000	 cmp         r4, #0
  000dc	0a000008	 beq         |$cleanUp$32404|

; 181  : 
; 182  :                 // close old key and use new one
; 183  :                 RegCloseKey(hKey);

  000e0	e1a00005	 mov         r0, r5
  000e4	eb000000	 bl          RegCloseKey

; 184  :                 hKey = hKeyNew;

  000e8	e1a05004	 mov         r5, r4

; 185  : 
; 186  :                 // flag indicating key was created
; 187  :                 status = ERROR_SUCCESS;

  000ec	e3a07000	 mov         r7, #0

; 188  :                 pch += nNextToken;

  000f0	e0866088	 add         r6, r6, r8, lsl #1

; 196  :                 goto cleanUp;
; 197  :             }
; 198  :         }

  000f4	eaffffce	 b           |$LL13@CreateRegK@2|
  000f8		 |$LN9@CreateRegK@2|

; 171  :         switch (token)
; 172  :             {
; 173  :             case kBackSlash:
; 174  :                 pch++;

  000f8	e2866002	 add         r6, r6, #2

; 175  :                 break;

  000fc	eaffffcc	 b           |$LL13@CreateRegK@2|
  00100		 |$LN3@CreateRegK@2|

; 189  :                 break;
; 190  : 
; 191  :             case kEnd:
; 192  :                 goto cleanUp;
; 193  :                 
; 194  :             case kError:
; 195  :                 status = ERROR_INVALID_DATA;

  00100	e3a0700d	 mov         r7, #0xD
  00104		 |$cleanUp$32404|

; 199  : 
; 200  : cleanUp:
; 201  :     if (status != ERROR_SUCCESS) 

  00104	e3570000	 cmp         r7, #0
  00108	0a000002	 beq         |$LN1@CreateRegK@2|

; 202  :         {
; 203  :         RegCloseKey(hKey);

  0010c	e1a00005	 mov         r0, r5
  00110	eb000000	 bl          RegCloseKey

; 204  :         hKey = NULL;

  00114	e3a05000	 mov         r5, #0
  00118		 |$LN1@CreateRegK@2|

; 205  :         }
; 206  :     
; 207  :     return hKey;

  00118	e59d0224	 ldr         r0, [sp, #0x224]
  0011c	eb000000	 bl          __security_check_cookie

; 208  : }

  00120	e1a00005	 mov         r0, r5
  00124	e28ddf8a	 add         sp, sp, #0x8A, 30
  00128	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0012c	e12fff1e	 bx          lr
  00130		 |$LN49@CreateRegK@2|
  00130		 |$LN50@CreateRegK@2|
  00130	00000000	 DCD         |__security_cookie|
  00134		 |$M32591|

			 ENDP  ; |?CreateRegKey@@YAPAUHKEY__@@PAU1@PBG@Z|, CreateRegKey

	EXPORT	|?WriteRegistryParams@@YAKPAUHKEY__@@PBGPAXKQBUDEVICE_WRITEREGISTRY_PARAM@@@Z| ; WriteRegistryParams

  00000			 AREA	 |.pdata|, PDATA
|$T32652| DCD	|$LN27@WriteRegis|
	DCD	0x40005602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?WriteRegistryParams@@YAKPAUHKEY__@@PBGPAXKQBUDEVICE_WRITEREGISTRY_PARAM@@@Z| PROC ; WriteRegistryParams

; 220  : {

  00000		 |$LN27@WriteRegis|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd01c	 sub         sp, sp, #0x1C
  00008		 |$M32649|
  00008	e1a09003	 mov         r9, r3
  0000c	e58d2008	 str         r2, [sp, #8]

; 221  :     DWORD status = ERROR_SUCCESS;
; 222  :     HKEY hKey;
; 223  :     DWORD i;
; 224  : 
; 225  :     // Open registry context to read parameters
; 226  :     if ((hKey = CreateRegKey(hKeyRoot, szPath)) == NULL)

  00010	e3a04000	 mov         r4, #0
  00014	eb000000	 bl          |?CreateRegKey@@YAPAUHKEY__@@PAU1@PBG@Z|
  00018	e1b06000	 movs        r6, r0

; 227  :         {
; 228  :         return ERROR_OUTOFMEMORY;

  0001c	03a0400e	 moveq       r4, #0xE
  00020	0a000048	 beq         |$LN9@WriteRegis|

; 229  :         }
; 230  : 
; 231  :     // For all members of array
; 232  :     for (i = 0; i < count && status == ERROR_SUCCESS; i++)

  00024	e3a07000	 mov         r7, #0
  00028	e3590000	 cmp         r9, #0
  0002c	0a000043	 beq         |$LN23@WriteRegis|
  00030	e59d5040	 ldr         r5, [sp, #0x40]
  00034	e3a0e000	 mov         lr, #0
  00038	e28da010	 add         r10, sp, #0x10
  0003c	e28db014	 add         r11, sp, #0x14
  00040		 |$LL7@WriteRegis|
  00040	e3540000	 cmp         r4, #0
  00044	1a00003d	 bne         |$LN23@WriteRegis|

; 233  :         {
; 234  :             switch (params[i].type)

  00048	e5953004	 ldr         r3, [r5, #4]

; 238  :                 break;
; 239  : 
; 240  :             default:
; 241  :                 status = SetBlobParam(hKey, pBase, &params[i]);

  0004c	e5958000	 ldr         r8, [r5]
  00050	e3530001	 cmp         r3, #1
  00054	e5953008	 ldr         r3, [r5, #8]
  00058	0a000018	 beq         |$LN2@WriteRegis|
  0005c	e3530000	 cmp         r3, #0
  00060	1a000008	 bne         |$LN17@WriteRegis|
  00064	e28d300c	 add         r3, sp, #0xC
  00068	e3a02000	 mov         r2, #0
  0006c	e1a01008	 mov         r1, r8
  00070	e1a00006	 mov         r0, r6
  00074	e58da004	 str         r10, [sp, #4]
  00078	e58de000	 str         lr, [sp]
  0007c	eb000000	 bl          RegQueryValueExW
  00080	e1b04000	 movs        r4, r0
  00084	0a000028	 beq         |$cleanUp$32609|
  00088		 |$LN17@WriteRegis|
  00088	e595200c	 ldr         r2, [r5, #0xC]
  0008c	e59d1008	 ldr         r1, [sp, #8]
  00090	e5953004	 ldr         r3, [r5, #4]
  00094	e595e010	 ldr         lr, [r5, #0x10]
  00098	e0812002	 add         r2, r1, r2
  0009c	e58d2000	 str         r2, [sp]
  000a0	e3a02000	 mov         r2, #0
  000a4	e1a01008	 mov         r1, r8
  000a8	e1a00006	 mov         r0, r6
  000ac	e58d300c	 str         r3, [sp, #0xC]
  000b0	e58de010	 str         lr, [sp, #0x10]
  000b4	e58de004	 str         lr, [sp, #4]
  000b8	eb000000	 bl          RegSetValueExW
  000bc		 |$cleanUp$32622|
  000bc	ea000019	 b           |$LN24@WriteRegis|
  000c0		 |$LN2@WriteRegis|

; 235  :             {
; 236  :             case REG_SZ:
; 237  :                 status = SetStringParam(hKey, pBase, &params[i]);

  000c0	e3530000	 cmp         r3, #0
  000c4	1a000008	 bne         |$LN12@WriteRegis|
  000c8	e28d3018	 add         r3, sp, #0x18
  000cc	e3a02000	 mov         r2, #0
  000d0	e1a01008	 mov         r1, r8
  000d4	e1a00006	 mov         r0, r6
  000d8	e58db004	 str         r11, [sp, #4]
  000dc	e58de000	 str         lr, [sp]
  000e0	eb000000	 bl          RegQueryValueExW
  000e4	e1b04000	 movs        r4, r0
  000e8	0a00000f	 beq         |$cleanUp$32609|
  000ec		 |$LN12@WriteRegis|
  000ec	e595300c	 ldr         r3, [r5, #0xC]
  000f0	e59d2008	 ldr         r2, [sp, #8]
  000f4	e0824003	 add         r4, r2, r3
  000f8	e1a00004	 mov         r0, r4
  000fc	eb000000	 bl          wcslen
  00100	e5953004	 ldr         r3, [r5, #4]
  00104	e1a02080	 mov         r2, r0, lsl #1
  00108	e58d2014	 str         r2, [sp, #0x14]
  0010c	e58d2004	 str         r2, [sp, #4]
  00110	e3a02000	 mov         r2, #0
  00114	e1a01008	 mov         r1, r8
  00118	e1a00006	 mov         r0, r6
  0011c	e58d3018	 str         r3, [sp, #0x18]
  00120	e58d4000	 str         r4, [sp]
  00124	eb000000	 bl          RegSetValueExW
  00128		 |$LN24@WriteRegis|
  00128	e1a04000	 mov         r4, r0
  0012c		 |$cleanUp$32609|
  0012c	e2877001	 add         r7, r7, #1
  00130	e1570009	 cmp         r7, r9
  00134	e2855018	 add         r5, r5, #0x18
  00138	e3a0e000	 mov         lr, #0
  0013c	3affffbf	 bcc         |$LL7@WriteRegis|
  00140		 |$LN23@WriteRegis|

; 242  :             }
; 243  :         }
; 244  : 
; 245  :     // Close key
; 246  :     RegCloseKey(hKey);

  00140	e1a00006	 mov         r0, r6
  00144	eb000000	 bl          RegCloseKey

; 247  :     return status;

  00148		 |$LN9@WriteRegis|

; 248  : }

  00148	e1a00004	 mov         r0, r4
  0014c	e28dd01c	 add         sp, sp, #0x1C
  00150	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00154	e12fff1e	 bx          lr
  00158		 |$M32650|

			 ENDP  ; |?WriteRegistryParams@@YAKPAUHKEY__@@PBGPAXKQBUDEVICE_WRITEREGISTRY_PARAM@@@Z|, WriteRegistryParams

	END
